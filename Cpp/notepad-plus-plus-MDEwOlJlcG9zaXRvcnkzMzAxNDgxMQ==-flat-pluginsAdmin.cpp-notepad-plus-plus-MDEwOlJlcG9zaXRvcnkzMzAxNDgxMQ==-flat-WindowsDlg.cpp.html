
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.776049766718507%, Tokens: 10</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-pluginsAdmin.cpp</h3>
            <pre><code>1  #include "json.hpp"
2  #include <algorithm>
3  #include <iostream>
4  #include <fstream>
5  #include <string>
6  #include <cctype>
7  #include <shlobj.h>
8  #include <shlwapi.h>
9  #include "pluginsAdmin.h"
10  #include "ScintillaEditView.h"
11  #include "localization.h"
12  #include "Processus.h"
13  #include "PluginsManager.h"
14  #include "verifySignedfile.h"
15  #define TEXTFILE        256
16  #define IDR_PLUGINLISTJSONFILE  101
17  using namespace std;
18  using nlohmann::json;
19  generic_string PluginUpdateInfo::describe()
20  {
21  	generic_string desc;
22  	const TCHAR *EOL = TEXT("\r\n");
23  	if (!_description.empty())
24  	{
25  		desc = _description;
26  		desc += EOL;
27  	}
28  	if (!_author.empty())
29  	{
30  		desc += TEXT("Author: ");
31  		desc += _author;
32  		desc += EOL;
33  	}
34  	if (!_homepage.empty())
35  	{
36  		desc += TEXT("Homepage: ");
37  		desc += _homepage;
38  		desc += EOL;
39  	}
40  	return desc;
41  }
42  bool findStrNoCase(const generic_string & strHaystack, const generic_string & strNeedle)
43  {
44  	auto it = std::search(
45  		strHaystack.begin(), strHaystack.end(),
46  		strNeedle.begin(), strNeedle.end(),
47  		[](wchar_t ch1, wchar_t ch2){return towupper(ch1) == towupper(ch2); }
48  	);
49  	return (it != strHaystack.end());
50  }
51  bool PluginsAdminDlg::isFoundInListFromIndex(const PluginViewList& inWhichList, int index, const generic_string& str2search, bool inWhichPart) const
52  {
53  	PluginUpdateInfo* pui = inWhichList.getPluginInfoFromUiIndex(index);
54  	generic_string searchIn;
55  	if (inWhichPart == _inNames)
56  		searchIn = pui->_displayName;
57  	else 
58  		searchIn = pui->_description;
59  	return (findStrNoCase(searchIn, str2search));
60  }
61  long PluginsAdminDlg::searchFromCurrentSel(const PluginViewList& inWhichList, const generic_string& str2search, bool inWhichPart, bool isNextMode) const
62  {
63  	long currentIndex = inWhichList.getSelectedIndex();
64  	int nbItem = static_cast<int>(inWhichList.nbItem());
65  	if (currentIndex == -1)
66  	{
67  		for (int i = 0; i < nbItem; ++i)
68  		{
69  			if (isFoundInListFromIndex(inWhichList, i, str2search, inWhichPart))
70  				return i;
71  		}
72  	}
73  	else 
74  	{
75  		for (int i = currentIndex + (isNextMode ? 1 : 0); i < nbItem; ++i)
76  		{
77  			if (isFoundInListFromIndex(inWhichList, i, str2search, inWhichPart))
78  				return i;
79  		}
80  		for (int i = 0; i < currentIndex + (isNextMode ? 1 : 0); ++i)
81  		{
82  			if (isFoundInListFromIndex(inWhichList, i, str2search, inWhichPart))
83  				return i;
84  		}
85  	}
86  	return -1;
87  }
88  void PluginsAdminDlg::create(int dialogID, bool isRTL, bool msgDestParent)
89  {
90  	collectNppCurrentStatusInfos();
91  	StaticDialog::create(dialogID, isRTL, msgDestParent);
92  	RECT rect{};
93  	getClientRect(rect);
94  	_tab.init(_hInst, _hSelf, false, true);
95  	NppDarkMode::subclassTabControl(_tab.getHSelf());
96  	DPIManager& dpiManager = NppParameters::getInstance()._dpiManager;
97  	int tabDpiDynamicalHeight = dpiManager.scaleY(13);
98  	_tab.setFont(TEXT("Tahoma"), tabDpiDynamicalHeight);
99  	const TCHAR *available = TEXT("Available");
100  	const TCHAR *updates = TEXT("Updates");
101  	const TCHAR *installed = TEXT("Installed");
102  	const TCHAR *incompatible = TEXT("Incompatible");
103  	_tab.insertAtEnd(available);
104  	_tab.insertAtEnd(updates);
105  	_tab.insertAtEnd(installed);
106  	_tab.insertAtEnd(incompatible);
107  	RECT rcDesc{};
108  	getMappedChildRect(IDC_PLUGINADM_EDIT, rcDesc);
109  	const long margeX = ::GetSystemMetrics(SM_CXEDGE);
110  	const long margeY = tabDpiDynamicalHeight;
111  	rect.bottom = rcDesc.bottom + margeY;
112  	_tab.reSizeTo(rect);
113  	_tab.display();
114  	RECT rcSearch{};
115  	getMappedChildRect(IDC_PLUGINADM_SEARCH_EDIT, rcSearch);
116  	RECT listRect{
117  		rcDesc.left - margeX,
118  		rcSearch.bottom + margeY,
119  		rcDesc.right + ::GetSystemMetrics(SM_CXVSCROLL) + margeX,
120  		rcDesc.top - margeY
121  	};
122  	NppParameters& nppParam = NppParameters::getInstance();
123  	NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
124  	generic_string pluginStr = pNativeSpeaker->getAttrNameStr(TEXT("Plugin"), "PluginAdmin", "Plugin");
125  	generic_string vesionStr = pNativeSpeaker->getAttrNameStr(TEXT("Version"), "PluginAdmin", "Version");
126  	const COLORREF fgColor = nppParam.getCurrentDefaultFgColor();
127  	const COLORREF bgColor = nppParam.getCurrentDefaultBgColor();
128  	const size_t szColVer = dpiManager.scaleX(100);
129  	const size_t szColName = szColVer * 2;
130  	auto initListView = [&](PluginViewList& list) -> void {
131  		list.addColumn(columnInfo(pluginStr, szColName));
132  		list.addColumn(columnInfo(vesionStr, szColVer));
133  		list.setViewStyleOption(LVS_EX_CHECKBOXES);
134  		list.initView(_hInst, _hSelf);
135  		const HWND hList = list.getViewHwnd();
136  		ListView_SetBkColor(hList, bgColor);
137  		ListView_SetTextBkColor(hList, bgColor);
138  		ListView_SetTextColor(hList, fgColor);
139  		list.reSizeView(listRect);
140  	};
141  	initListView(_availableList);
142  	initListView(_updateList);
143  	initListView(_installedList);
144  	initListView(_incompatibleList);
145  	switchDialog(0);
146  	NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
147  	NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
148  	HWND hPluginListVersionNumber = ::GetDlgItem(_hSelf, IDC_PLUGINLIST_VERSIONNUMBER_STATIC);
149  	::SetWindowText(hPluginListVersionNumber, _pluginListVersion.c_str());
150  	_repoLink.init(_hInst, _hSelf);
151  	_repoLink.create(::GetDlgItem(_hSelf, IDC_PLUGINLIST_ADDR), TEXT("https:&bsol;&bsol;github.com/notepad-plus-plus/nppPluginList"));
152  	goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
153  }
154  void PluginsAdminDlg::collectNppCurrentStatusInfos()
155  {
156  	NppParameters& nppParam = NppParameters::getInstance();
157  	_nppCurrentStatus._nppInstallPath = nppParam.getNppPath();
158  	_nppCurrentStatus._isAppDataPluginsAllowed = ::SendMessage(_hParent, NPPM_GETAPPDATAPLUGINSALLOWED, 0, 0) == TRUE;
159  	_nppCurrentStatus._appdataPath = nppParam.getAppDataNppDir();
160  	generic_string programFilesPath = NppParameters::getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
161  	_nppCurrentStatus._isInProgramFiles = (_nppCurrentStatus._nppInstallPath.find(programFilesPath) == 0);
162  }
163  vector<PluginUpdateInfo*> PluginViewList::fromUiIndexesToPluginInfos(const std::vector<size_t>& uiIndexes) const
164  {
165  	std::vector<PluginUpdateInfo*> r;
166  	size_t nb = _ui.nbItem();
167  	for (const auto &i : uiIndexes)
168  	{
169  		if (i < nb)
170  		{
171  			r.push_back(getPluginInfoFromUiIndex(i));
172  		}
173  	}
174  	return r;
175  }
176  PluginsAdminDlg::PluginsAdminDlg()
177  {
178  	NppParameters& nppParameters = NppParameters::getInstance();
179  	_updaterDir = nppParameters.getNppPath();
180  	pathAppend(_updaterDir, TEXT("updater"));
181  	_updaterFullPath = _updaterDir;
182  	pathAppend(_updaterFullPath, TEXT("gup.exe"));
183  	_pluginListFullPath = nppParameters.getPluginConfDir();
184  #ifdef DEBUG 
185  	pathAppend(_pluginListFullPath, TEXT("nppPluginList.json"));
186  #else 
187  	pathAppend(_pluginListFullPath, TEXT("nppPluginList.dll"));
188  #endif
189  }
190  generic_string PluginsAdminDlg::getPluginListVerStr() const
191  {
192  	Version v;
193  	v.setVersionFrom(_pluginListFullPath);
194  	return v.toString();
195  }
196  bool PluginsAdminDlg::exitToInstallRemovePlugins(Operation op, const vector<PluginUpdateInfo*>& puis)
197  {
198  	generic_string opStr;
199  	if (op == pa_install)
200  		opStr = TEXT("-unzipTo ");
201  	else if (op == pa_update)
202  		opStr = TEXT("-unzipTo -clean ");
203  	else if (op == pa_remove)
204  		opStr = TEXT("-clean ");
205  	else
206  		return false;
207  	NppParameters& nppParameters = NppParameters::getInstance();
208  	generic_string updaterDir = nppParameters.getNppPath();
209  	updaterDir += TEXT("\\updater\\");
210  	generic_string updaterFullPath = updaterDir + TEXT("gup.exe");
211  	generic_string updaterParams = opStr;
212  	TCHAR nppFullPath[MAX_PATH]{};
213  	::GetModuleFileName(NULL, nppFullPath, MAX_PATH);
214  	updaterParams += TEXT("\"");
215  	updaterParams += nppFullPath;
216  	updaterParams += TEXT("\" ");
217  	updaterParams += TEXT("\"");
218  	updaterParams += nppParameters.getPluginRootDir();
219  	updaterParams += TEXT("\"");
220  	for (const auto &i : puis)
221  	{
222  		if (op == pa_install || op == pa_update)
223  		{
224  			updaterParams += TEXT(" \"");
225  			updaterParams += i->_folderName;
226  			updaterParams += TEXT(" ");
227  			updaterParams += i->_repository;
228  			updaterParams += TEXT(" ");
229  			updaterParams += i->_id;
230  			updaterParams += TEXT("\"");
231  		}
232  		else 
233  		{
234  			updaterParams += TEXT(" \"");
235  			generic_string folderName = i->_folderName;
236  			if (folderName.empty())
237  			{
238  				auto lastindex = i->_displayName.find_last_of(TEXT("."));
239  				if (lastindex != generic_string::npos)
240  					folderName = i->_displayName.substr(0, lastindex);
241  				else
242  					folderName = i->_displayName;	
243  			}
244  			updaterParams += folderName;
245  			updaterParams += TEXT("\"");
246  		}
247  	}
248  	NativeLangSpeaker *pNativeSpeaker = nppParameters.getNativeLangSpeaker();
249  	auto res = pNativeSpeaker->messageBox("ExitToUpdatePlugins",
250  		_hSelf,
251  		TEXT("If you click YES, you will quit Notepad++ to continue the operations.\nNotepad++ will be restarted after all the operations are terminated.\nContinue?"),
252  		TEXT("Notepad++ is about to exit"),
253  		MB_YESNO | MB_APPLMODAL);
254  	if (res == IDYES)
255  	{
256  		NppParameters& nppParam = NppParameters::getInstance();
257  		nppParam.setWingupFullPath(updaterFullPath);
258  		nppParam.setWingupParams(updaterParams);
259  		nppParam.setWingupDir(updaterDir);
260  		::PostMessage(_hParent, WM_COMMAND, IDM_FILE_EXIT, 0);
261  	}
262  	return true;
263  }
264  bool PluginsAdminDlg::installPlugins()
265  {
266  	vector<size_t> indexes = _availableList.getCheckedIndexes();
267  	vector<PluginUpdateInfo*> puis = _availableList.fromUiIndexesToPluginInfos(indexes);
268  	return exitToInstallRemovePlugins(pa_install, puis);
269  }
270  bool PluginsAdminDlg::updatePlugins()
271  {
272  	vector<size_t> indexes = _updateList.getCheckedIndexes();
273  	vector<PluginUpdateInfo*> puis = _updateList.fromUiIndexesToPluginInfos(indexes);
274  	return exitToInstallRemovePlugins(pa_update, puis);
275  }
276  bool PluginsAdminDlg::removePlugins()
277  {
278  	vector<size_t> indexes = _installedList.getCheckedIndexes();
279  	vector<PluginUpdateInfo*> puis = _installedList.fromUiIndexesToPluginInfos(indexes);
280  	return exitToInstallRemovePlugins(pa_remove, puis);
281  }
282  void PluginsAdminDlg::changeTabName(LIST_TYPE index, const TCHAR *name2change)
283  {
284  	TCITEM tie{};
285  	tie.mask = TCIF_TEXT;
286  	tie.pszText = (TCHAR *)name2change;
287  	TabCtrl_SetItem(_tab.getHSelf(), index, &tie);
288  	TCHAR label[MAX_PATH]{};
289  	_tab.getCurrentTitle(label, MAX_PATH);
290  	::SetWindowText(_hSelf, label);
291  }
292  void PluginsAdminDlg::changeColumnName(COLUMN_TYPE index, const TCHAR *name2change)
293  {
294  	_availableList.changeColumnName(index, name2change);
295  	_updateList.changeColumnName(index, name2change);
296  	_installedList.changeColumnName(index, name2change);
297  	_incompatibleList.changeColumnName(index, name2change);
298  }
299  void PluginViewList::changeColumnName(COLUMN_TYPE index, const TCHAR *name2change)
300  {
301  	_ui.setColumnText(index, name2change);
302  }
303  bool PluginViewList::removeFromFolderName(const generic_string& folderName)
304  {
305  	for (size_t i = 0; i < _ui.nbItem(); ++i)
306  	{
307  		PluginUpdateInfo* pi = getPluginInfoFromUiIndex(i);
308  		if (pi->_folderName == folderName)
309  		{
310  			if (!_ui.removeFromIndex(i))
311  				return false;
312  			for (size_t j = 0; j < _list.size(); ++j)
313  			{
314  				if (_list[j] == pi)
315  				{
316  					_list.erase(_list.begin() + j);
317  					return true;
318  				}
319  			}
320  		}
321  	}
322  	return false;
323  }
324  void PluginViewList::pushBack(PluginUpdateInfo* pi)
325  {
326  	_list.push_back(pi);
327  	vector<generic_string> values2Add;
328  	values2Add.push_back(pi->_displayName);
329  	Version v = pi->_version;
330  	values2Add.push_back(v.toString());
331  	size_t i = _ui.findAlphabeticalOrderPos(pi->_displayName, _sortType == DISPLAY_NAME_ALPHABET_ENCREASE ? _ui.sortEncrease : _ui.sortDecrease);
332  	_ui.addLine(values2Add, reinterpret_cast<LPARAM>(pi), static_cast<int>(i));
333  }
334  std::pair<Version, Version> getIntervalVersions(generic_string intervalVerStr)
335  {
336  	std::pair<Version, Version> result;
337  	if (intervalVerStr.empty())
338  		return result;
339  	const size_t indexEnd = intervalVerStr.length() - 1;
340  	if (intervalVerStr[0] == '[' && intervalVerStr[indexEnd] == ']') 
341  	{
342  		generic_string cleanIntervalVerStr = intervalVerStr.substr(1, indexEnd - 1);
343  		vector<generic_string> versionVect;
344  		cutStringBy(cleanIntervalVerStr.c_str(), versionVect, ',', true);
345  		if (versionVect.size() == 2)
346  		{
347  			if (!versionVect[0].empty() && !versionVect[1].empty()) 
348  			{
349  				result.first = Version(versionVect[0]);
350  				result.second = Version(versionVect[1]);
351  			}
<span onclick='openModal()' class='match'>352  			else if (!versionVect[0].empty() && versionVect[1].empty()) 
353  			{
354  				result.first = Version(versionVect[0]);
355  			}
356  			else if (versionVect[0].empty() && !versionVect[1].empty()) 
357  			{
358  				result.second = Version(versionVect[1]);
359  			}
360  		}
</span>361  	}
362  	else if (intervalVerStr[0] != '[' && intervalVerStr[indexEnd] != ']') 
363  	{
364  		result.first = Version(intervalVerStr);
365  		result.second = Version(intervalVerStr);
366  	}
367  	else 
368  	{
369  	}
370  	return result;
371  }
372  std::pair<std::pair<Version, Version>, std::pair<Version, Version>> getTwoIntervalVersions(generic_string twoIntervalVerStr)
373  {
374  	std::pair<std::pair<Version, Version>, std::pair<Version, Version>> r;
375  	generic_string sep = TEXT("][");
376  	generic_string::size_type pos = twoIntervalVerStr.find(sep, 0);
377  	if (pos == string::npos)
378  		return r;
379  	generic_string intervalStr1 = twoIntervalVerStr.substr(0, pos + 1);
380  	generic_string intervalStr2 = twoIntervalVerStr.substr(pos + 1, twoIntervalVerStr.length() - pos + 1);
381  	r.first = getIntervalVersions(intervalStr1);
382  	r.second = getIntervalVersions(intervalStr2);
383  	return r;
384  }
385  bool loadFromJson(std::vector<PluginUpdateInfo*>& pl, wstring& verStr, const json& j)
386  {
387  	if (j.empty())
388  		return false;
389  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
390  	json jVerStr = j["version"];
391  	if (jVerStr.empty() || jVerStr.type() != json::value_t::string)
392  		return false;
393  	string s = jVerStr.get<std::string>();
394  	verStr = wmc.char2wchar(s.c_str(), CP_ACP);
395  	json jArray = j["npp-plugins"];
396  	if (jArray.empty() || jArray.type() != json::value_t::array)
397  		return false;
398  	for (const auto& i : jArray)
399  	{
400  		try {
401  			PluginUpdateInfo* pi = new PluginUpdateInfo();
402  			string valStr = i.at("folder-name").get<std::string>();
403  			pi->_folderName = wmc.char2wchar(valStr.c_str(), CP_ACP);
404  			valStr = i.at("display-name").get<std::string>();
405  			pi->_displayName = wmc.char2wchar(valStr.c_str(), CP_ACP);
406  			valStr = i.at("author").get<std::string>();
407  			pi->_author = wmc.char2wchar(valStr.c_str(), CP_UTF8);
408  			valStr = i.at("description").get<std::string>();
409  			pi->_description = wmc.char2wchar(valStr.c_str(), CP_UTF8);
410  			valStr = i.at("id").get<std::string>();
411  			pi->_id = wmc.char2wchar(valStr.c_str(), CP_ACP);
412  			try {
413  				valStr = i.at("version").get<std::string>();
414  				generic_string newValStr(valStr.begin(), valStr.end());
415  				pi->_version = Version(newValStr);
416  				if (i.contains("npp-compatible-versions"))
417  				{
418  					json jNppCompatibleVer = i["npp-compatible-versions"];
419  					string versionsStr = jNppCompatibleVer.get<std::string>();
420  					generic_string nppCompatibleVersionStr(versionsStr.begin(), versionsStr.end());
421  					pi->_nppCompatibleVersions = getIntervalVersions(nppCompatibleVersionStr);
422  				}
423  				if (i.contains("old-versions-compatibility"))
424  				{
425  					json jOldVerCompatibility = i["old-versions-compatibility"];
426  					string versionsStr = jOldVerCompatibility.get<std::string>();
427  					generic_string oldVerCompatibilityStr(versionsStr.begin(), versionsStr.end());
428  					pi->_oldVersionCompatibility = getTwoIntervalVersions(oldVerCompatibilityStr);
429  				}
430  			}
431  			catch (const wstring& s)
432  			{
433  				wstring msg = pi->_displayName;
434  				msg += L": ";
435  				throw msg + s;
436  			}
437  			valStr = i.at("repository").get<std::string>();
438  			pi->_repository = wmc.char2wchar(valStr.c_str(), CP_ACP);
439  			valStr = i.at("homepage").get<std::string>();
440  			pi->_homepage = wmc.char2wchar(valStr.c_str(), CP_ACP);
441  			pl.push_back(pi);
442  		}
443  #ifdef DEBUG
444  		catch (const wstring& s)
445  		{
446  			::MessageBox(NULL, s.c_str(), TEXT("Exception caught in: PluginsAdmin loadFromJson()"), MB_ICONERROR);
447  			continue;
448  		}
449  		catch (std::exception& e)
450  		{
451  			::MessageBoxA(NULL, e.what(), "Exception caught in: PluginsAdmin loadFromJson()", MB_ICONERROR);
452  			continue;
453  		}
454  #endif
455  		catch (...) 
456  		{
457  #ifdef DEBUG
458  			::MessageBoxA(NULL, "An unknown exception is just caught", "Unknown Exception", MB_OK);
459  #endif
460  			continue; 
461  		}
462  	}
463  	return true;
464  }
465  PluginUpdateInfo::PluginUpdateInfo(const generic_string& fullFilePath, const generic_string& filename)
466  {
467  	if (!::PathFileExists(fullFilePath.c_str()))
468  		return;
469  	_fullFilePath = fullFilePath;
470  	_displayName = filename;
471  	std::string content = getFileContent(fullFilePath.c_str());
472  	if (content.empty())
473  		return;
474  	_version.setVersionFrom(fullFilePath);
475  }
476  typedef const char * (__cdecl * PFUNCGETPLUGINLIST)();
477  bool PluginsAdminDlg::initFromJson()
478  {
479  	winVer winVersion = (NppParameters::getInstance()).getWinVersion();
480  	if (winVersion <= WV_XP)
481  	{
482  		return false;
483  	}
484  	if (!::PathFileExists(_pluginListFullPath.c_str()))
485  	{
486  		return false;
487  	}
488  	if (!::PathFileExists(_updaterFullPath.c_str()))
489  	{
490  		return false;
491  	}
492  	json j;
493  #ifdef DEBUG 
494  #ifdef __MINGW32__
495  	ifstream nppPluginListJson(wstring2string(_pluginListFullPath, CP_UTF8));
496  #else 
497  	ifstream nppPluginListJson(_pluginListFullPath);
498  #endif
499  	nppPluginListJson >> j;
500  #else 
501  	SecurityGuard securityGuard;
502  	bool isSecured = securityGuard.checkModule(_pluginListFullPath, nm_pluginList);
503  	if (!isSecured)
504  		return false;
505  	isSecured = securityGuard.checkModule(_updaterFullPath, nm_gup);
506  	if (isSecured)
507  	{
508  		HMODULE hLib = NULL;
509  		hLib = ::LoadLibraryEx(_pluginListFullPath.c_str(), 0, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE);
510  		if (!hLib)
511  		{
512  			return false;
513  		}
514  		HRSRC rc = ::FindResource(hLib, MAKEINTRESOURCE(IDR_PLUGINLISTJSONFILE), MAKEINTRESOURCE(TEXTFILE));
515  		if (!rc)
516  		{
517  			::FreeLibrary(hLib);
518  			return false;
519  		}
520  		HGLOBAL rcData = ::LoadResource(hLib, rc);
521  		if (!rcData)
522  		{
523  			::FreeLibrary(hLib);
524  			return false;
525  		}
526  		auto size = ::SizeofResource(hLib, rc);
527  		auto data = static_cast<const char*>(::LockResource(rcData));
528  		char* buffer = new char[size + 1];
529  		::memcpy(buffer, data, size);
530  		buffer[size] = '\0';
531  		j = j.parse(buffer);
532  		delete[] buffer;
533  		::FreeLibrary(hLib);
534  	}
535  #endif
536  	return loadFromJson(_availableList._list, _pluginListVersion, j);
537  }
538  bool PluginsAdminDlg::updateList()
539  {
540  	initAvailablePluginsViewFromList();
541  	checkUpdates();
542  	initIncompatiblePluginList();
543  	loadFromPluginInfos();
544  	return true;
545  }
546  bool PluginsAdminDlg::initAvailablePluginsViewFromList()
547  {
548  	TCHAR nppFullPathName[MAX_PATH]{};
549  	GetModuleFileName(NULL, nppFullPathName, MAX_PATH);
550  	Version nppVer;
551  	nppVer.setVersionFrom(nppFullPathName);
552  	for (const auto& i : _availableList._list)
553  	{
554  		bool isCompatible = nppVer.isCompatibleTo(i->_nppCompatibleVersions.first, i->_nppCompatibleVersions.second);
555  		if (isCompatible)
556  		{
557  			vector<generic_string> values2Add;
558  			values2Add.push_back(i->_displayName);
559  			Version v = i->_version;
560  			values2Add.push_back(v.toString());
561  			size_t j = _availableList._ui.findAlphabeticalOrderPos(i->_displayName, _availableList._sortType == DISPLAY_NAME_ALPHABET_ENCREASE ? ListView::sortEncrease : ListView::sortDecrease);
562  			_availableList._ui.addLine(values2Add, reinterpret_cast<LPARAM>(i), static_cast<int>(j));
563  		}
564  	}
565  	return true;
566  }
567  bool PluginsAdminDlg::initIncompatiblePluginList()
568  {
569  	TCHAR nppFullPathName[MAX_PATH]{};
570  	GetModuleFileName(NULL, nppFullPathName, MAX_PATH);
571  	Version nppVer;
572  	nppVer.setVersionFrom(nppFullPathName);
573  	for (const auto& i : _incompatibleList._list)
574  	{
575  		vector<generic_string> values2Add;
576  		values2Add.push_back(i->_displayName);
577  		Version v = i->_version;
578  		values2Add.push_back(v.toString());
579  		size_t j = _incompatibleList._ui.findAlphabeticalOrderPos(i->_displayName, _incompatibleList._sortType == DISPLAY_NAME_ALPHABET_ENCREASE ? ListView::sortEncrease : ListView::sortDecrease);
580  		_incompatibleList._ui.addLine(values2Add, reinterpret_cast<LPARAM>(i), static_cast<int>(j));
581  	}
582  	return true;
583  }
584  bool PluginsAdminDlg::loadFromPluginInfos()
585  {
586  	if (!_pPluginsManager)
587  		return false;
588  	for (const auto& i : _pPluginsManager->_loadedDlls)
589  	{
590  		if (i._fileName.length() >= MAX_PATH)
591  			continue;
592  		TCHAR fnNoExt[MAX_PATH]{};
593  		wcscpy_s(fnNoExt, i._fileName.c_str());
594  		::PathRemoveExtension(fnNoExt);
595  		int listIndex;
596  		PluginUpdateInfo* foundInfo = _availableList.findPluginInfoFromFolderName(fnNoExt, listIndex);
597  		if (!foundInfo)
598  		{
599  			PluginUpdateInfo* pui = new PluginUpdateInfo(i._fullFilePath, i._fileName);
600  			_installedList.pushBack(pui);
601  		}
602  		else
603  		{
604  			PluginUpdateInfo* pui = new PluginUpdateInfo(*foundInfo);
605  			pui->_fullFilePath = i._fullFilePath;
606  			pui->_version.setVersionFrom(i._fullFilePath);
607  			_installedList.pushBack(pui);
608  			_availableList.hideFromListIndex(listIndex);
609  			if (pui->_version < foundInfo->_version)
610  			{
611  				PluginUpdateInfo* pui2 = new PluginUpdateInfo(*foundInfo);
612  				_updateList.pushBack(pui2);
613  			}
614  		}
615  	}
616  	for (size_t j = 0, nb = _incompatibleList.nbItem(); j < nb; j++)
617  	{
618  		PluginUpdateInfo* incompatiblePluginInfo = _incompatibleList.getPluginInfoFromUiIndex(j);
619  		int listIndex;
620  		PluginUpdateInfo* foundInfoOfAvailable = _availableList.findPluginInfoFromFolderName(incompatiblePluginInfo->_folderName, listIndex);
621  		if (foundInfoOfAvailable)
622  		{
623  			if (foundInfoOfAvailable->_version > incompatiblePluginInfo->_version)
624  			{
625  				_availableList.hideFromListIndex(listIndex);
626  				PluginUpdateInfo* pui = new PluginUpdateInfo(*foundInfoOfAvailable);
627  				_updateList.pushBack(pui);
628  			}
629  		}
630  	}
631  	return true;
632  }
633  PluginUpdateInfo* PluginViewList::findPluginInfoFromFolderName(const generic_string& folderName, int& index) const
634  {
635  	index = 0;
636  	for (const auto& i : _list)
637  	{
638  		if (lstrcmpi(i->_folderName.c_str(), folderName.c_str()) == 0)
639  			return i;
640  		++index;
641  	}
642  	index = -1;
643  	return nullptr;
644  }
645  bool PluginViewList::removeFromUiIndex(size_t index2remove)
646  {
647  	if (index2remove >= _ui.nbItem())
648  		return false;
649  	return _ui.removeFromIndex(index2remove);
650  }
651  bool PluginViewList::removeFromListIndex(size_t index2remove)
652  {
653  	if (index2remove >= _list.size())
654  		return false;
655  	for (size_t i = 0; i < _ui.nbItem(); ++i)
656  	{
657  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(_list[index2remove]))
658  		{
659  			if (!_ui.removeFromIndex(i))
660  				return false;
661  		}
662  	}
663  	_list.erase(_list.begin() + index2remove);
664  	return true;
665  }
666  bool PluginViewList::removeFromPluginInfoPtr(PluginUpdateInfo* pluginInfo2hide)
667  {
668  	for (size_t i = 0; i < _ui.nbItem(); ++i)
669  	{
670  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(pluginInfo2hide))
671  		{
672  			if (!_ui.removeFromIndex(static_cast<int>(i)))
673  			{
674  				return false;
675  			}
676  		}
677  	}
678  	for (size_t j = 0; j < _list.size(); ++j)
679  	{
680  		if (_list[j] == pluginInfo2hide)
681  		{
682  			_list.erase(_list.begin() + j);
683  			return true;
684  		}
685  	}
686  	return false;
687  }
688  bool PluginViewList::hideFromPluginInfoPtr(PluginUpdateInfo* pluginInfo2hide)
689  {
690  	for (size_t i = 0; i < _ui.nbItem(); ++i)
691  	{
692  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(pluginInfo2hide))
693  		{
694  			if (!_ui.removeFromIndex(static_cast<int>(i)))
695  			{
696  				return false;
697  			}
698  			else
699  			{
700  				pluginInfo2hide->_isVisible = false;
701  				return true;
702  			}
703  		}
704  	}
705  	return false;
706  }
707  bool PluginViewList::restore(const generic_string& folderName)
708  {
709  	for (const auto &i : _list)
710  	{
711  		if (i->_folderName == folderName)
712  		{
713  			vector<generic_string> values2Add;
714  			values2Add.push_back(i->_displayName);
715  			Version v = i->_version;
716  			values2Add.push_back(v.toString());
717  			values2Add.push_back(TEXT("Yes"));
718  			_ui.addLine(values2Add, reinterpret_cast<LPARAM>(i));
719  			i->_isVisible = true;
720  			return true;
721  		}
722  	}
723  	return false;
724  }
725  bool PluginViewList::hideFromListIndex(size_t index2hide)
726  {
727  	if (index2hide >= _list.size())
728  		return false;
729  	for (size_t i = 0; i < _ui.nbItem(); ++i)
730  	{
731  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(_list[index2hide]))
732  		{
733  			if (!_ui.removeFromIndex(static_cast<int>(i)))
734  				return false;
735  		}
736  	}
737  	_list[index2hide]->_isVisible = false;
738  	return true;
739  }
740  bool PluginsAdminDlg::checkUpdates()
741  {
742  	return true;
743  }
744  bool PluginsAdminDlg::searchInPlugins(bool isNextMode) const
745  {
746  	constexpr int maxLen = 256;
747  	TCHAR txt2search[maxLen]{};
748  	::GetDlgItemText(_hSelf, IDC_PLUGINADM_SEARCH_EDIT, txt2search, maxLen);
749  	if (lstrlen(txt2search) < 2)
750  		return false;
751  	HWND tabHandle = _tab.getHSelf();
752  	int inWhichTab = int(::SendMessage(tabHandle, TCM_GETCURSEL, 0, 0));
753  	const PluginViewList* inWhichList = nullptr;
754  	switch (inWhichTab)
755  	{
756  	case 3:
757  		inWhichList = &_incompatibleList;
758  		break;
759  	case 2:
760  		inWhichList = &_installedList;
761  		break;
762  	case 1:
763  		inWhichList = &_updateList;
764  		break;
765  	case 0:
766  	default:
767  		inWhichList = &_availableList;
768  		break;
769  	}
770  	long foundIndex = searchInNamesFromCurrentSel(*inWhichList, txt2search, isNextMode);
771  	if (foundIndex == -1)
772  		foundIndex = searchInDescsFromCurrentSel(*inWhichList, txt2search, isNextMode);
773  	if (foundIndex == -1)
774  		return false;
775  	inWhichList->setSelection(foundIndex);
776  	return true;
777  }
778  void PluginsAdminDlg::switchDialog(int indexToSwitch)
779  {
780  	generic_string desc;
781  	bool showAvailable, showUpdate, showInstalled, showIncompatibile;
782  	switch (indexToSwitch)
783  	{
784  		case 0: 
785  		{
786  			showAvailable = true;
787  			showUpdate = false;
788  			showInstalled = false;
789  			showIncompatibile = false;
790  			long infoIndex = _availableList.getSelectedIndex();
791  			if (infoIndex != -1 && infoIndex < static_cast<long>(_availableList.nbItem()))
792  				desc = _availableList.getPluginInfoFromUiIndex(infoIndex)->describe();
793  		}
794  		break;
795  		case 1: 
796  		{
797  			showAvailable = false;
798  			showUpdate = true;
799  			showInstalled = false;
800  			showIncompatibile = false;
801  			long infoIndex = _updateList.getSelectedIndex();
802  			if (infoIndex != -1 && infoIndex < static_cast<long>(_updateList.nbItem()))
803  				desc = _updateList.getPluginInfoFromUiIndex(infoIndex)->describe();
804  		}
805  		break;
806  		case 2: 
807  		{
808  			showAvailable = false;
809  			showUpdate = false;
810  			showInstalled = true;
811  			showIncompatibile = false;
812  			long infoIndex = _installedList.getSelectedIndex();
813  			if (infoIndex != -1 && infoIndex < static_cast<long>(_installedList.nbItem()))
814  				desc = _installedList.getPluginInfoFromUiIndex(infoIndex)->describe();
815  		}
816  		break;
817  		case 3: 
818  		{
819  			showAvailable = false;
820  			showUpdate = false;
821  			showInstalled = false;
822  			showIncompatibile = true;
823  			long infoIndex = _incompatibleList.getSelectedIndex();
824  			if (infoIndex != -1 && infoIndex < static_cast<long>(_incompatibleList.nbItem()))
825  				desc = _incompatibleList.getPluginInfoFromUiIndex(infoIndex)->_description;
826  		}
827  		break;
828  		default:
829  			return;
830  	}
831  	_availableList.displayView(showAvailable);
832  	_updateList.displayView(showUpdate);
833  	_installedList.displayView(showInstalled);
834  	_incompatibleList.displayView(showIncompatibile);
835  	::SetDlgItemText(_hSelf, IDC_PLUGINADM_EDIT, desc.c_str());
836  	HWND hInstallButton = ::GetDlgItem(_hSelf, IDC_PLUGINADM_INSTALL);
837  	HWND hUpdateButton = ::GetDlgItem(_hSelf, IDC_PLUGINADM_UPDATE);
838  	HWND hRemoveButton = ::GetDlgItem(_hSelf, IDC_PLUGINADM_REMOVE);
839  	::ShowWindow(hInstallButton, showAvailable ? SW_SHOW : SW_HIDE);
840  	if (showAvailable)
841  	{
842  		vector<size_t> checkedArray = _availableList.getCheckedIndexes();
843  		showAvailable = checkedArray.size() > 0;
844  	}
845  	::EnableWindow(hInstallButton, showAvailable);
846  	::ShowWindow(hUpdateButton, showUpdate ? SW_SHOW : SW_HIDE);
847  	if (showUpdate)
848  	{
849  		vector<size_t> checkedArray = _updateList.getCheckedIndexes();
850  		showUpdate = checkedArray.size() > 0;
851  	}
852  	::EnableWindow(hUpdateButton, showUpdate);
853  	::ShowWindow(hRemoveButton, showInstalled ? SW_SHOW : SW_HIDE);
854  	if (showInstalled)
855  	{
856  		vector<size_t> checkedArray = _installedList.getCheckedIndexes();
857  		showInstalled = checkedArray.size() > 0;
858  	}
859  	::EnableWindow(hRemoveButton, showInstalled);
860  }
861  intptr_t CALLBACK PluginsAdminDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
862  {
863  	switch (message)
864  	{
865  		case WM_CTLCOLOREDIT:
866  		{
867  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
868  		}
869  		case WM_CTLCOLORDLG:
870  		{
871  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
872  		}
873  		case WM_CTLCOLORSTATIC:
874  		{
875  			if (NppDarkMode::isEnabled())
876  			{
877  				const int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
878  				if (dlgCtrlID == IDC_PLUGINADM_EDIT)
879  				{
880  					return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
881  				}
882  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
883  			}
884  			break;
885  		}
886  		case WM_PRINTCLIENT:
887  		{
888  			if (NppDarkMode::isEnabled())
889  			{
890  				return TRUE;
891  			}
892  			break;
893  		}
894  		case NPPM_INTERNAL_REFRESHDARKMODE:
895  		{
896  			NppDarkMode::autoThemeChildControls(_hSelf);
897  			return TRUE;
898  		}
899  		case WM_COMMAND :
900  		{
901  			if (HIWORD(wParam) == EN_CHANGE)
902  			{
903  				switch (LOWORD(wParam))
904  				{
905  					case  IDC_PLUGINADM_SEARCH_EDIT:
906  					{
907  						searchInPlugins(false);
908  						return TRUE;
909  					}
910  				}
911  			}
912  			switch (wParam)
913  			{
914  				case IDOK:
915  					if (::GetFocus() == ::GetDlgItem(_hSelf, IDC_PLUGINADM_SEARCH_EDIT))
916  						::PostMessage(_hSelf, WM_NEXTDLGCTL, 0, 0L);
917  					return TRUE;
918  				case IDCANCEL:
919  					display(false);
920  					return TRUE;
921  				case IDC_PLUGINADM_RESEARCH_NEXT:
922  					searchInPlugins(true);
923  					return true;
924  				case IDC_PLUGINADM_INSTALL:
925  					installPlugins();
926  					return true;
927  				case IDC_PLUGINADM_UPDATE:
928  					updatePlugins();
929  					return true;
930  				case IDC_PLUGINADM_REMOVE:
931  				{
932  					removePlugins();
933  					return true;
934  				}
935  				default :
936  					break;
937  			}
938  			return FALSE;
939  		}
940  		case WM_NOTIFY :
941  		{
942  			LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
943  			if (pnmh->code == TCN_SELCHANGE)
944  			{
945  				HWND tabHandle = _tab.getHSelf();
946  				if (pnmh->hwndFrom == tabHandle)
947  				{
948  					int indexClicked = int(::SendMessage(tabHandle, TCM_GETCURSEL, 0, 0));
949  					switchDialog(indexClicked);
950  				}
951  			}
952  			else if (pnmh->hwndFrom == _availableList.getViewHwnd() ||
953                       pnmh->hwndFrom == _updateList.getViewHwnd() ||
954                       pnmh->hwndFrom == _installedList.getViewHwnd() ||
955                       pnmh->hwndFrom == _incompatibleList.getViewHwnd())
956  			{
957  				PluginViewList* pViewList = nullptr;
958  				int buttonID = 0;
959  				if (pnmh->hwndFrom == _availableList.getViewHwnd())
960  				{
961  					pViewList = &_availableList;
962  					buttonID = IDC_PLUGINADM_INSTALL;
963  				}
964  				else if (pnmh->hwndFrom == _updateList.getViewHwnd())
965  				{
966  					pViewList = &_updateList;
967  					buttonID = IDC_PLUGINADM_UPDATE;
968  				}
969  				else if (pnmh->hwndFrom == _installedList.getViewHwnd())
970  				{
971  					pViewList = &_installedList;
972  					buttonID = IDC_PLUGINADM_REMOVE;
973  				}
974  				else 
975  				{
976  					pViewList = &_incompatibleList;
977  					buttonID = 0;
978  				}
979  				LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;
980  				if (pnmh->code == LVN_ITEMCHANGED)
981  				{
982  					if (pnmv->uChanged & LVIF_STATE)
983  					{
984  						if ((pnmv->uNewState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(2) || 
985  							(pnmv->uNewState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(1))   
986  						{
987  							if (buttonID)
988  							{
989  								HWND hButton = ::GetDlgItem(_hSelf, buttonID);
990  								vector<size_t> checkedArray = pViewList->getCheckedIndexes();
991  								bool showButton = checkedArray.size() > 0;
992  								::EnableWindow(hButton, showButton);
993  							}
994  						}
995  						else if (pnmv->uNewState & LVIS_SELECTED)
996  						{
997  							PluginUpdateInfo* pui = pViewList->getPluginInfoFromUiIndex(pnmv->iItem);
998  							generic_string desc = buttonID ? pui->describe() : pui->_description;
999  							::SetDlgItemText(_hSelf, IDC_PLUGINADM_EDIT, desc.c_str());
1000  						}
1001  					}
1002  				}
1003  			}
1004  			return TRUE;
1005  		}
1006  		case WM_DESTROY :
1007  		{
1008  			return TRUE;
1009  		}
1010  	}
1011  	return FALSE;
1012  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WindowsDlg.cpp</h3>
            <pre><code>1  #include <functional>
2  #include <algorithm>
3  #include "WindowsDlg.h"
4  #include "WindowsDlgRc.h"
5  #include "DocTabView.h"
6  #include "EncodingMapper.h"
7  #include "localization.h"
8  using namespace std;
9  #ifndef _countof
10  #define _countof(x) (sizeof(x)/sizeof((x)[0]))
11  #endif
12  #ifndef LVS_EX_DOUBLEBUFFER
13  #define LVS_EX_DOUBLEBUFFER     0x00010000
14  #endif
15  #define WD_ROOTNODE					"WindowsDlg"
16  #define WD_CLMNNAME					"ColumnName"
17  #define WD_CLMNPATH					"ColumnPath"
18  #define WD_CLMNTYPE					"ColumnType"
19  #define WD_CLMNSIZE					"ColumnSize"
20  #define WD_NBDOCSTOTAL				"NbDocsTotal"
21  #define WD_MENUCOPYNAME				"MenuCopyName"
22  #define WD_MENUCOPYPATH				"MenuCopyPath"
23  static const TCHAR *readonlyString = TEXT(" [Read Only]");
24  const UINT WDN_NOTIFY = RegisterWindowMessage(TEXT("WDN_NOTIFY"));
25  struct NumericStringEquivalence
26  {
27  	int operator()(const TCHAR* s1, const TCHAR* s2) const
28  	{
29  		return numstrcmp(s1, s2);
30  	}
31  	static inline int numstrcmp_get(const TCHAR **str, int *length)
32  	{
33  		const TCHAR *p = *str;
34  		int value = 0;
35  		for (*length = 0; isdigit(*p); ++(*length))
36  			value = value * 10 + *p++ - '0';
37  		*str = p;
38  		return (value);
39  	}
40  	static int numstrcmp(const TCHAR *str1, const TCHAR *str2)
41  	{
42  		TCHAR *p1 = nullptr, *p2 = nullptr;
43  		int c1 = 0, c2 = 0, lcmp = 0;
44  		for (;;)
45  		{
46  			if (*str1 == 0 || *str2 == 0)
47  			{
48  				if (*str1 != *str2)
49  					lcmp = *str1 - *str2;
50  				break;
51  			}
52  			if (_istdigit(*str1) && _istdigit(*str2))
53  			{
54  				lcmp = wcstol(str1, &p1, 10) - wcstol(str2, &p2, 10);
55  				if ( lcmp == 0 )
56  					lcmp = static_cast<int32_t>((p2 - str2) - (p1 - str1));
57  				if ( lcmp != 0 )
58  					break;
59  				str1 = p1, str2 = p2;
60  			}
61  			else
62  			{
63  				if (_istascii(*str1) && _istupper(*str1))
64  					c1 = towlower(*str1);
65  				else
66  					c1 = *str1;
67  				if (_istascii(*str2) && _istupper(*str2))
68  					c2 = towlower(*str2);
69  				else
70  					c2 = *str2;
71  				lcmp = (c1 - c2);
72  				if (lcmp != 0)
73  					break;
74  				++str1, ++str2;
75  			}
76  		}
77  		return ( lcmp < 0 ) ? -1 : (lcmp > 0 ? 1 : 0);
78  	}
79  };
80  struct BufferEquivalent
81  {
82  	NumericStringEquivalence _strequiv{};
83  	DocTabView* _pTab = nullptr;
84  	int _iColumn = 0;
85  	bool _reverse = false;
86  	BufferEquivalent(DocTabView* pTab, int iColumn, bool reverse)
87  		: _pTab(pTab), _iColumn(iColumn), _reverse(reverse)
88  	{}
89  	bool operator()(int i1, int i2) const
90  	{
91  		if (i1 == i2) return false; 
92  		if (_reverse) std::swap(i1, i2);
93  		return compare(i1, i2);
94  	}
95  	bool compare(int i1, int i2) const
96  	{
97  		if (_iColumn >= 0 && _iColumn <= 3)
98  		{
99  			BufferID bid1 = _pTab->getBufferByIndex(i1);
100  			BufferID bid2 = _pTab->getBufferByIndex(i2);
101  			Buffer * b1 = MainFileManager.getBufferByID(bid1);
102  			Buffer * b2 = MainFileManager.getBufferByID(bid2);
103  			if (_iColumn == 0)
104  			{
105  				const TCHAR *s1 = b1->getFileName();
106  				const TCHAR *s2 = b2->getFileName();
107  				int result = _strequiv(s1, s2);
108  				if (result != 0) 
109  					return result < 0;
110  			}
111  			else if (_iColumn == 2)
112  			{
113  				NppParameters & nppParameters = NppParameters::getInstance();
114  				const TCHAR *s1;
115  				const TCHAR *s2;
116  				Lang *lang1 = nppParameters.getLangFromID(b1->getLangType());
117  				if (lang1)
118  				{
119  					s1 = lang1->getLangName();
120  				}
121  				else
122  					s1 = TEXT("");
123  				Lang *lang2 = nppParameters.getLangFromID(b2->getLangType());
124  				if (lang2)
125  				{
126  					s2 = lang2->getLangName();
127  				}
128  				else
129  					s2 = TEXT("");
130  				int result = _strequiv(s1, s2);
131  				if (result != 0) 
132  					return result < 0;
133  			}
134  			else if (_iColumn == 3)
135  			{
136  				auto t1 = b1->docLength();
137  				auto t2 = b2->docLength();
138  				if (t1 != t2) 
139  					return (t1 < t2);
140  			}
141  			const TCHAR *s1 = b1->getFullPathName();
142  			const TCHAR *s2 = b2->getFullPathName();
143  			return _strequiv(s1, s2) < 0;	
144  		}
145  		return false;
146  	}
147  };
148  BEGIN_WINDOW_MAP(WindowsDlgMap)
149  	BEGINROWS(WRCT_REST,0,RCMARGINS(8,8))
150  		BEGINCOLS(WRCT_REST,0,0)                       
151  			BEGINROWS(WRCT_REST,0,0)
152  				RCREST(IDC_WINDOWS_LIST)
153  			ENDGROUP()
154  			RCSPACE(12)
155  			BEGINROWS(WRCT_TOFIT,0,0)
156  			RCSPACE(12)
157  			RCTOFIT(IDOK)
158  			RCSPACE(-12)
159  			RCTOFIT(IDC_WINDOWS_SAVE)
160  			RCSPACE(-12)
161  			RCTOFIT(IDC_WINDOWS_CLOSE)
162  			RCSPACE(-12)
163  			RCTOFIT(IDC_WINDOWS_SORT)
164  			RCREST(-1)
165  			RCTOFIT(IDCANCEL)
166  			ENDGROUP()
167  		ENDGROUP()
168  	ENDGROUP()
169  END_WINDOW_MAP()
170  RECT WindowsDlg::_lastKnownLocation;
171  WindowsDlg::WindowsDlg() : MyBaseClass(WindowsDlgMap)
172  {
173  	_szMinButton = SIZEZERO;
174  	_szMinListCtrl = SIZEZERO;
175  }
176  void WindowsDlg::init(HINSTANCE hInst, HWND parent, DocTabView *pTab)
177  {
178  	MyBaseClass::init(hInst, parent);
179  	_pTab = pTab;
180  }
181  void WindowsDlg::init(HINSTANCE hInst, HWND parent)
182  {
183  	assert(!"Call other initialize method");
184  	MyBaseClass::init(hInst, parent);
185  	_pTab = NULL;
186  }
187  intptr_t CALLBACK WindowsDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
188  {
189  	switch (message)
190  	{
191  		case WM_INITDIALOG :
192  		{
193  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
194  			pNativeSpeaker->changeDlgLang(_hSelf, "Window");
195  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
196  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
197  			return MyBaseClass::run_dlgProc(message, wParam, lParam);
198  		}
199  		case WM_CTLCOLORDLG:
200  		case WM_CTLCOLORSTATIC:
201  		{
202  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
203  		}
204  		case WM_PRINTCLIENT:
205  		{
206  			if (NppDarkMode::isEnabled())
207  			{
208  				return TRUE;
209  			}
210  			break;
211  		}
212  		case NPPM_INTERNAL_REFRESHDARKMODE:
213  		{
214  			NppDarkMode::autoThemeChildControls(_hSelf);
215  			return TRUE;
216  		}
217  		case WM_COMMAND :
218  		{
219  			switch (wParam)
220  			{
221  				case IDOK:
222  				{
223  					activateCurrent();
224  					return TRUE;
225  				}
226  				case IDCANCEL:
227  				{
228  					::GetWindowRect(_hSelf, &_lastKnownLocation);
229  					EndDialog(_hSelf, IDCANCEL);
230  					return TRUE;
231  				}
232  				case IDC_WINDOWS_SAVE:
233  				{
234  					doSave();
235  					return TRUE;
236  				}
237  				case IDC_WINDOWS_CLOSE:
238  				{
239  					doClose();
240  					return TRUE;
241  				}
242  				case IDC_WINDOWS_SORT:
243  				{
244  					if (_currentColumn == -1)
245  					{
246  						_currentColumn = 0;
247  						_reverseSort = false;
248  						_lastSort = _currentColumn;
249  						updateColumnNames();
250  						doColumnSort();
251  					}
252  					doSortToTabs();
253  					doColumnSort();
254  					break;
255  				}
256  				default:
257  					if (HIWORD(wParam) == 0)
258  					{
259  						switch (LOWORD(wParam))
260  						{
261  						case IDM_WINDOW_COPY_NAME:
262  							putItemsToClipboard(false);
263  							break;
264  						case IDM_WINDOW_COPY_PATH:
265  							putItemsToClipboard(true);
266  							break;
267  						}
268  					}
269  					break;
270  			}
271  			break;
272  		}
273  		case WM_DESTROY:
274  		{
275  			return TRUE;
276  		}
277  		case WM_NOTIFY :
278  		{
279  			if (wParam == IDC_WINDOWS_LIST)
280  			{
281  				NMHDR* pNMHDR = reinterpret_cast<NMHDR*>(lParam);
282  				if (pNMHDR->code == LVN_GETDISPINFO)
283  				{
284  					NMLVDISPINFO *pLvdi = (NMLVDISPINFO *)pNMHDR;
285  					if (pLvdi->item.mask & LVIF_TEXT)
286  					{
287  						pLvdi->item.pszText[0] = 0;
288  						Buffer* buf = getBuffer(pLvdi->item.iItem);
289  						if (!buf)
290  							return FALSE;
291  						generic_string text;
292  						if (pLvdi->item.iSubItem == 0) 
293  						{
294  							text = buf->getFileName();
<span onclick='openModal()' class='match'>295  							if (buf->isDirty())
296  							{
297  								text += '*';
298  							}
299  							else if (buf->isReadOnly())
300  							{
301  								text += readonlyString;
302  							}
303  						}
</span>304  						else if (pLvdi->item.iSubItem == 1) 
305  						{
306  							const TCHAR *fullName = buf->getFullPathName();
307  							const TCHAR *fileName = buf->getFileName();
308  							int len = lstrlen(fullName)-lstrlen(fileName);
309  							if (!len) {
310  								len = 1;
311  								fullName = TEXT("");
312  							}
313  							text.assign(fullName, len);
314  						}
315  						else if (pLvdi->item.iSubItem == 2) 
316  						{
317  							NppParameters& nppParameters = NppParameters::getInstance();
318  							Lang *lang = nppParameters.getLangFromID(buf->getLangType());
319  							if (NULL != lang)
320  							{
321  								text = lang->getLangName();
322  							}
323  						}
324  						else if (pLvdi->item.iSubItem == 3) 
325  						{
326  							size_t docSize = buf->docLength();
327  							string docSizeText = to_string(docSize);
328  							text = wstring(docSizeText.begin(), docSizeText.end());
329  						}
330  						if (static_cast<int>(text.length()) < pLvdi->item.cchTextMax)
331  						{
332  							wcscpy_s(pLvdi->item.pszText, text.length() + 1, text.c_str());
333  						}
334  					}
335  					return TRUE;
336  				}
337  				else if (pNMHDR->code == LVN_COLUMNCLICK) 
338  				{
339  					NMLISTVIEW *pNMLV = (NMLISTVIEW *)pNMHDR;
340  					if (pNMLV->iItem == -1)
341  					{
342  						_currentColumn = pNMLV->iSubItem;
343  						if (_lastSort == _currentColumn)
344  						{
345  							_reverseSort = true;
346  							_lastSort = -1;
347  						}
348  						else
349  						{
350  							_reverseSort = false;
351  							_lastSort = _currentColumn;
352  						}
353  						updateColumnNames();
354  						doColumnSort();
355  					}
356  					return TRUE;
357  				}
358  				else if (pNMHDR->code == LVN_ITEMACTIVATE || pNMHDR->code == LVN_ITEMCHANGED || pNMHDR->code == LVN_ODSTATECHANGED)
359  				{
360  					updateButtonState();
361  					return TRUE;
362  				}
363  				else if (pNMHDR->code == NM_DBLCLK)
364  				{
365  					::PostMessage(_hSelf, WM_COMMAND, IDOK, 0);
366  					return TRUE;
367  				}
368  				else if (pNMHDR->code == LVN_KEYDOWN)
369  				{
370  					NMLVKEYDOWN *lvkd = (NMLVKEYDOWN *)pNMHDR;
371  					short ctrl = GetKeyState(VK_CONTROL);
372  					short alt = GetKeyState(VK_MENU);
373  					short shift = GetKeyState(VK_SHIFT);
374  					if (lvkd->wVKey == 'A' && ctrl<0 && alt>=0 && shift>=0)
375  					{
376  						for (int i=0, n=ListView_GetItemCount(_hList); i<n; ++i)
377  							ListView_SetItemState(_hList, i, LVIS_SELECTED, LVIS_SELECTED);
378  					}
379  					else if (lvkd->wVKey == 'C' && ctrl & 0x80)
380  					{
381  						if (ListView_GetSelectedCount(_hList) != 0)
382  							putItemsToClipboard(true);
383  					}
384  					return TRUE;
385  				}
386  			}
387  			break;
388  		}
389  		case WM_CONTEXTMENU:
390  			{
391  				if (!_listMenu.isCreated())
392  				{
393  					NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
394  					const std::vector<MenuItemUnit> itemUnitArray
395  					{
396  						{IDM_WINDOW_COPY_NAME, pNativeSpeaker->getAttrNameStr(TEXT("Copy Name(s)"), WD_ROOTNODE, WD_MENUCOPYNAME)},
397  						{IDM_WINDOW_COPY_PATH, pNativeSpeaker->getAttrNameStr(TEXT("Copy Pathname(s)"), WD_ROOTNODE, WD_MENUCOPYPATH)}
398  					};
399  					_listMenu.create(_hSelf, itemUnitArray);
400  				}
401  				const bool enableMenu = ListView_GetSelectedCount(_hList) != 0;
402  				_listMenu.enableItem(IDM_WINDOW_COPY_NAME, enableMenu);
403  				_listMenu.enableItem(IDM_WINDOW_COPY_PATH, enableMenu);
404  				POINT p{};
405  				::GetCursorPos(&p);
406  				_listMenu.display(p);
407  			}
408  			return TRUE;
409  	}
410  	return MyBaseClass::run_dlgProc(message, wParam, lParam);
411  }
412  void WindowsDlg::doColumnSort()
413  {
414  	if (_currentColumn == -1)
415  		return;
416  	size_t i = 0;
417  	size_t n = _idxMap.size();
418  	vector<int> sortMap;
419  	sortMap.resize(n);
420  	for (; i < n; ++i)
421  		sortMap[_idxMap[i]] = ListView_GetItemState(_hList, i, LVIS_SELECTED);
422  	stable_sort(_idxMap.begin(), _idxMap.end(), BufferEquivalent(_pTab, _currentColumn, _reverseSort));
423  	for (i = 0; i < n; ++i)
424  		ListView_SetItemState(_hList, i, sortMap[_idxMap[i]] ? LVIS_SELECTED : 0, LVIS_SELECTED);
425  	::InvalidateRect(_hList, &_rc, FALSE);
426  	updateButtonState();
427  }
428  void WindowsDlg::updateButtonState()
429  {
430  	int nSelection = ListView_GetSelectedCount(_hList);
431  	if (nSelection == 0)
432  	{
433  		EnableWindow(GetDlgItem(_hSelf, IDOK), FALSE);
434  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SAVE), FALSE);
435  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_CLOSE), FALSE);
436  	}
437  	else
438  	{
439  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SAVE), TRUE);
440  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_CLOSE), TRUE);
441  		if (nSelection == 1)
442  			EnableWindow(GetDlgItem(_hSelf, IDOK), TRUE);
443  		else
444  			EnableWindow(GetDlgItem(_hSelf, IDOK), FALSE);
445  	}
446  	EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SORT), TRUE);
447  }
448  int WindowsDlg::doDialog()
449  {
450  	return static_cast<int>(DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_WINDOWS), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
451  }
452  BOOL WindowsDlg::onInitDialog()
453  {
454  	_winMgr.InitToFitSizeFromCurrent(_hSelf);
455  	_szMinButton = RectToSize(_winMgr.GetRect(IDOK));
456  	_szMinListCtrl = RectToSize(_winMgr.GetRect(IDC_WINDOWS_LIST));
457  	_currentColumn = -1;
458  	_lastSort = -1;
459  	_reverseSort = false;
460  	_winMgr.CalcLayout(_hSelf);
461  	_winMgr.SetWindowPositions(_hSelf);
462  	getClientRect(_rc);
463  	_hList = ::GetDlgItem(_hSelf, IDC_WINDOWS_LIST);
464  	DWORD exStyle = ListView_GetExtendedListViewStyle(_hList);
465  	exStyle |= LVS_EX_HEADERDRAGDROP|LVS_EX_FULLROWSELECT|LVS_EX_DOUBLEBUFFER;
466  	ListView_SetExtendedListViewStyle(_hList, exStyle);
467  	COLORREF fgColor = (NppParameters::getInstance()).getCurrentDefaultFgColor();
468  	COLORREF bgColor = (NppParameters::getInstance()).getCurrentDefaultBgColor();
469  	ListView_SetBkColor(_hList, bgColor);
470  	ListView_SetTextBkColor(_hList, bgColor);
471  	ListView_SetTextColor(_hList, fgColor);
472  	RECT rc{};
473  	GetClientRect(_hList, &rc);
474  	LONG width = rc.right - rc.left;
475  	LVCOLUMN lvColumn{};
476  	lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
477  	lvColumn.fmt = LVCFMT_LEFT;
478  	generic_string columnText;
479  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
480  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Name"), WD_ROOTNODE, WD_CLMNNAME);
481  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
482  	lvColumn.cx = width / 4;
483  	SendMessage(_hList, LVM_INSERTCOLUMN, 0, LPARAM(&lvColumn));
484  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Path"), WD_ROOTNODE, WD_CLMNPATH);
485  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
486  	lvColumn.cx = 300;
487  	SendMessage(_hList, LVM_INSERTCOLUMN, 1, LPARAM(&lvColumn));
488  	lvColumn.fmt = LVCFMT_CENTER;
489  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Type"), WD_ROOTNODE, WD_CLMNTYPE);
490  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
491  	lvColumn.cx = 100;
492  	SendMessage(_hList, LVM_INSERTCOLUMN, 2, LPARAM(&lvColumn));
493  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Size"), WD_ROOTNODE, WD_CLMNSIZE);
494  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
495  	lvColumn.cx = 100;
496  	SendMessage(_hList, LVM_INSERTCOLUMN, 3, LPARAM(&lvColumn));
497  	fitColumnsToSize();
498  	if (_lastKnownLocation.bottom > 0 && _lastKnownLocation.right > 0)
499  	{
500  		SetWindowPos(_hSelf, NULL, _lastKnownLocation.left, _lastKnownLocation.top,
501  			_lastKnownLocation.right-_lastKnownLocation.left, _lastKnownLocation.bottom-_lastKnownLocation.top, SWP_SHOWWINDOW);
502  	}
503  	else
504  	{
505  		goToCenter();
506  	}
507  	doRefresh(true);
508  	return TRUE;
509  }
510  void WindowsDlg::updateColumnNames()
511  {
512  	LVCOLUMN lvColumn{};
513  	lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
514  	lvColumn.fmt = LVCFMT_LEFT;
515  	generic_string columnText;
516  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
517  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Name"), WD_ROOTNODE, WD_CLMNNAME);
518  	if (_currentColumn != 0)
519  	{
520  		columnText = TEXT("⇵ ") + columnText;
521  	}
522  	else if (_reverseSort)
523  	{
524  		columnText = TEXT("△ ") + columnText;
525  	}
526  	else
527  	{
528  		columnText = TEXT("▽ ") + columnText;
529  	}
530  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
531  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 0, 0));
532  	SendMessage(_hList, LVM_SETCOLUMN, 0, LPARAM(&lvColumn));
533  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Path"), WD_ROOTNODE, WD_CLMNPATH);
534  	if (_currentColumn != 1)
535  	{
536  		columnText = TEXT("⇵ ") + columnText;
537  	}
538  	else if (_reverseSort)
539  	{
540  		columnText = TEXT("△ ") + columnText;
541  	}
542  	else
543  	{
544  		columnText = TEXT("▽ ") + columnText;
545  	}
546  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
547  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 1, 0));
548  	SendMessage(_hList, LVM_SETCOLUMN, 1, LPARAM(&lvColumn));
549  	lvColumn.fmt = LVCFMT_CENTER;
550  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Type"), WD_ROOTNODE, WD_CLMNTYPE);
551  	if (_currentColumn != 2)
552  	{
553  		columnText = TEXT("⇵ ") + columnText;
554  	}
555  	else if (_reverseSort)
556  	{
557  		columnText = TEXT("△ ") + columnText;
558  	}
559  	else
560  	{
561  		columnText = TEXT("▽ ") + columnText;
562  	}
563  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
564  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 2, 0));
565  	SendMessage(_hList, LVM_SETCOLUMN, 2, LPARAM(&lvColumn));
566  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Size"), WD_ROOTNODE, WD_CLMNSIZE);
567  	if (_currentColumn != 3)
568  	{
569  		columnText = TEXT("⇵ ") + columnText;
570  	}
571  	else if (_reverseSort)
572  	{
573  		columnText = TEXT("△ ") + columnText;
574  	}
575  	else
576  	{
577  		columnText = TEXT("▽ ") + columnText;
578  	}
579  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
580  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 3, 0));
581  	SendMessage(_hList, LVM_SETCOLUMN, 3, LPARAM(&lvColumn));
582  }
583  void WindowsDlg::onSize(UINT nType, int cx, int cy)
584  {
585  	MyBaseClass::onSize(nType, cx, cy);
586  	fitColumnsToSize();
587  }
588  void WindowsDlg::onGetMinMaxInfo(MINMAXINFO* lpMMI)
589  {
590  	MyBaseClass::onGetMinMaxInfo(lpMMI);
591  }
592  LRESULT WindowsDlg::onWinMgr(WPARAM wp, LPARAM lp)
593  {
594  	NMWINMGR &nmw = *reinterpret_cast<NMWINMGR *>(lp);
595  	if (nmw.code==NMWINMGR::GET_SIZEINFO) {
596  		switch(wp)
597  		{
598  		case IDOK:
599  		case IDCANCEL:
600  		case IDC_WINDOWS_SAVE:
601  		case IDC_WINDOWS_CLOSE:
602  		case IDC_WINDOWS_SORT:
603  			nmw.sizeinfo.szMin = _szMinButton;
604  			nmw.processed = TRUE;
605  			return TRUE;
606  		case IDC_WINDOWS_LIST:
607  			nmw.sizeinfo.szMin = _szMinListCtrl;
608  			nmw.processed = TRUE;
609  			return TRUE;
610  		}
611  	}
612  	return MyBaseClass::onWinMgr(wp, lp);
613  }
614  void WindowsDlg::doRefresh(bool invalidate &bsol;*= false*/)
615  {
616  	if (_hSelf != NULL && isVisible())
617  	{
618  		if (_hList != NULL)
619  		{
620  			size_t count = (_pTab != NULL) ? _pTab->nbItem() : 0;
621  			size_t oldSize = _idxMap.size();
622  			if (!invalidate && count == oldSize)
623  				return;
624  			if (count != oldSize)
625  			{
626  				size_t lo = 0;
627  				_idxMap.resize(count);
628  				if (oldSize < count)
629  					lo = oldSize;
630  				for (size_t i = lo; i < count; ++i)
631  					_idxMap[i] = int(i);
632  			}
633  			LPARAM lp = invalidate ? LVSICF_NOSCROLL|LVSICF_NOINVALIDATEALL : LVSICF_NOSCROLL;
634  			::SendMessage(_hList, LVM_SETITEMCOUNT, count, lp);
635  			::InvalidateRect(_hList, &_rc, FALSE);
636  			resetSelection();
637  			updateButtonState();
638  			doCount();
639  		}
640  	}
641  }
642  void WindowsDlg::fitColumnsToSize()
643  {
644  	RECT rc{};
645  	if (GetClientRect(_hList, &rc))
646  	{
647  		int len = (rc.right - rc.left);
648  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 0, 0));
649  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 2, 0));
650  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 3, 0));
651  		len -= GetSystemMetrics(SM_CXVSCROLL);
652  		len -= 1;
653  		SendMessage(_hList, LVM_SETCOLUMNWIDTH, 1, len);
654  	}
655  }
656  void WindowsDlg::resetSelection()
657  {
658  	assert(_pTab != nullptr);
659  	auto curSel = _pTab->getCurrentTabIndex();
660  	int pos = 0;
661  	for (vector<int>::iterator itr = _idxMap.begin(), end = _idxMap.end(); itr != end; ++itr, ++pos)
662  	{
663  		if (*itr == curSel)
664  		{
665  			ListView_SetItemState(_hList, pos, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
666  		}
667  		else
668  		{
669  			ListView_SetItemState(_hList, pos, 0, LVIS_SELECTED);
670  		}
671  	}
672  }
673  void WindowsDlg::doSave()
674  {
675  	NMWINDLG nmdlg{};
676  	nmdlg.type = WDT_SAVE;
677  	nmdlg.curSel = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
678  	nmdlg.hwndFrom = _hSelf;
679  	nmdlg.code = WDN_NOTIFY;
680  	nmdlg.nItems = ListView_GetSelectedCount(_hList);
681  	nmdlg.Items = new UINT[nmdlg.nItems];
682  	int i = -1;
683  	for (UINT j = 0; j < nmdlg.nItems; ++j)
684  	{
685  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
686  		if (i == -1) break;
687  		nmdlg.Items[j] = _idxMap[i];
688  	}
689  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
690  	delete[] nmdlg.Items;
691  	::InvalidateRect(_hList, &_rc, FALSE);
692  	ListView_RedrawItems(_hList, 0, ListView_GetSelectedCount(_hList));
693  }
694  void WindowsDlg::destroy()
695  {
696  	::GetWindowRect(_hSelf, &_lastKnownLocation);
697  	HWND hSelf = _hSelf;
698  	_hSelf = NULL;
699  	::DestroyWindow(hSelf);
700  }
701  void WindowsDlg::activateCurrent()
702  {
703  	if (ListView_GetSelectedCount(_hList) == 1)
704  	{
705  		NMWINDLG nmdlg{};
706  		nmdlg.type = WDT_ACTIVATE;
707  		nmdlg.curSel = _idxMap[ListView_GetNextItem(_hList, -1, LVNI_ALL|LVNI_SELECTED)];
708  		nmdlg.hwndFrom = _hSelf;
709  		nmdlg.code = WDN_NOTIFY;
710  		SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
711  		::GetWindowRect(_hSelf, &_lastKnownLocation);
712  		EndDialog(_hSelf, IDOK);
713  	}
714  }
715  void WindowsDlg::doClose()
716  {
717  	NMWINDLG nmdlg{};
718  	nmdlg.type = WDT_CLOSE;
719  	int index = ListView_GetNextItem(_hList, -1, LVNI_ALL|LVNI_SELECTED);
720  	if (index == -1) return;
721  	nmdlg.curSel = _idxMap[index];
722  	nmdlg.hwndFrom = _hSelf;
723  	nmdlg.code = WDN_NOTIFY;
724  	UINT n = nmdlg.nItems = ListView_GetSelectedCount(_hList);
725  	nmdlg.Items = new UINT[nmdlg.nItems];
726  	vector<int> key;
727  	key.resize(n, 0x7fffffff);
728  	int i = -1;
729  	for (UINT j = 0; j < n; ++j)
730  	{
731  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
732  		if (i == -1) break;
733  		ListView_SetItemState(_hList, i, 0, LVIS_SELECTED); 
734  		nmdlg.Items[j] = _idxMap[i];
735  		key[j] = i;
736  	}
737  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
738  	if (nmdlg.processed)
739  	{
740  		vector<int>::iterator kitr = key.begin();
741  		for (UINT i = 0; i < n; ++i, ++kitr)
742  		{
743  			if (nmdlg.Items[i] == ((UINT)-1))
744  			{
745  				int oldVal = _idxMap[*kitr];
746  				_idxMap[*kitr] = -1;
747  				for (vector<int>::iterator itr = _idxMap.begin(), end = _idxMap.end(); itr != end; ++itr)
748  					if (*itr > oldVal)
749  						--(*itr);
750  			}
751  		}
752  		_idxMap.erase(remove_if(_idxMap.begin(), _idxMap.end(), bind(equal_to<int>(), placeholders::_1, -1)), _idxMap.end());
753  	}
754  	delete[] nmdlg.Items;
755  	if (_idxMap.size() < 1)
756  		::SendMessage(_hSelf, WM_CLOSE, 0, 0);
757  	else if (_pTab->nbItem() != _idxMap.size())
758  		doRefresh(true);
759  	else
760  	{
761  		if (index == static_cast<int>(_idxMap.size()))
762  			index -= 1;
763  		if (index >= 0)
764  		{
765  			ListView_SetItemState(_hList, index, LVIS_SELECTED, LVIS_SELECTED);
766  			ListView_RedrawItems(_hList, 0, _idxMap.size() - 1);
767  		}
768  		ListView_SetItemCount(_hList, _idxMap.size());
769  	}
770  	doCount();
771  }
772  void WindowsDlg::doCount()
773  {
774  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
775  	generic_string msg = pNativeSpeaker->getAttrNameStr(TEXT("Windows"), "Dialog", "Window", "title");
776  	msg += TEXT(" - ");
777  	msg += pNativeSpeaker->getAttrNameStr(TEXT("Total documents: "), WD_ROOTNODE, WD_NBDOCSTOTAL);
778  	msg += TEXT(" ");
779  	msg += to_wstring(_idxMap.size());
780  	SetWindowText(_hSelf,msg.c_str());
781  }
782  void WindowsDlg::doSort()
783  {
784  	if (_pTab == NULL)
785  		return;
786  	size_t count =  _pTab->nbItem();
787  	std::vector<UINT> items(count);
788  	auto currrentTabIndex = _pTab->getCurrentTabIndex();
789  	NMWINDLG nmdlg{};
790  	nmdlg.type = WDT_SORT;
791  	nmdlg.hwndFrom = _hSelf;
792  	nmdlg.curSel = currrentTabIndex;
793  	nmdlg.code = WDN_NOTIFY;
794  	nmdlg.nItems = static_cast<UINT>(count);
795  	nmdlg.Items = items.data();
796  	for (size_t i=0; i < count; ++i)
797  	{
798  		nmdlg.Items[i] = _idxMap[i];
799  	}
800  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
801  	if (nmdlg.processed)
802  	{
803  		_idxMap.clear();
804  		refreshMap();
805  	}
806  	__int64 newPosition = -1;
807  	std::vector<int>::iterator it = std::find(_idxMap.begin(), _idxMap.end(), currrentTabIndex);
808  	if (it != _idxMap.end())
809  	{
810  		newPosition = it - _idxMap.begin();
811  	}
812  	nmdlg.type = WDT_ACTIVATE;
813  	nmdlg.curSel = static_cast<UINT>(newPosition);
814  	nmdlg.hwndFrom = _hSelf;
815  	nmdlg.code = WDN_NOTIFY;	
816  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
817  }
818  void WindowsDlg::sort(int columnID, bool reverseSort)
819  {
820  	refreshMap();
821  	_currentColumn = columnID;
822  	_reverseSort = reverseSort;
823  	stable_sort(_idxMap.begin(), _idxMap.end(), BufferEquivalent(_pTab, _currentColumn, _reverseSort));
824  }
825  void WindowsDlg::sortFileNameASC()
826  {
827  	sort(0, false);
828  }
829  void WindowsDlg::sortFileNameDSC()
830  {
831  	sort(0, true);
832  }
833  void WindowsDlg::sortFilePathASC()
834  {
835  	sort(1, false);
836  }
837  void WindowsDlg::sortFilePathDSC()
838  {
839  	sort(1, true);
840  }
841  void WindowsDlg::sortFileTypeASC()
842  {
843  	sort(2, false);
844  }
845  void WindowsDlg::sortFileTypeDSC()
846  {
847  	sort(2, true);
848  }
849  void WindowsDlg::sortFileSizeASC()
850  {
851  	sort(3, false);
852  }
853  void WindowsDlg::sortFileSizeDSC()
854  {
855  	sort(3, true);
856  }
857  void WindowsDlg::refreshMap()
858  {
859  	size_t count = (_pTab != NULL) ? _pTab->nbItem() : 0;
860  	size_t oldSize = _idxMap.size();
861  	if (count == oldSize)
862  		return;
863  	if (count != oldSize)
864  	{
865  		size_t lo = 0;
866  		_idxMap.resize(count);
867  		if (oldSize < count)
868  			lo = oldSize;
869  		for (size_t i = lo; i < count; ++i)
870  			_idxMap[i] = int(i);
871  	}
872  }
873  void WindowsDlg::doSortToTabs()
874  {
875  	int curSel = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
876  	if (curSel == -1)
877  		curSel = 0;
878  	NMWINDLG nmdlg{};
879  	nmdlg.type = WDT_SORT;
880  	nmdlg.hwndFrom = _hSelf;
881  	nmdlg.curSel = _idxMap[curSel];
882  	nmdlg.code = WDN_NOTIFY;
883  	nmdlg.nItems = ListView_GetItemCount(_hList);
884  	nmdlg.Items = new UINT[nmdlg.nItems];
885  	int i = -1;
886  	for (UINT j = 0; j < nmdlg.nItems; ++j)
887  	{
888  		i = ListView_GetNextItem(_hList, i, LVNI_ALL);
889  		if (i == -1)
890  			break;
891  		nmdlg.Items[j] = _idxMap[i];
892  		if (i == curSel)
893  			nmdlg.curSel = j;
894  	}
895  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
896  	if (nmdlg.processed)
897  	{
898  		_idxMap.clear();
899  		doRefresh(true);
900  	}
901  	delete[] nmdlg.Items;
902  }
903  void WindowsDlg::putItemsToClipboard(bool isFullPath)
904  {
905  	std::vector<Buffer*> buffers;
906  	int i = -1;
907  	do
908  	{
909  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
910  		buffers.push_back(getBuffer(i));
911  	}
912  	while (i >= 0);
913  	buf2Clipborad(buffers, isFullPath, _hList);
914  }
915  Buffer* WindowsDlg::getBuffer(int index) const
916  {
917  	if (index < 0 || index >= static_cast<int>(_idxMap.size()))
918  		return nullptr;
919  	index = _idxMap[index];
920  	if (index < 0 || !_pTab || index >= static_cast<int>(_pTab->nbItem()))
921  		return nullptr;
922  	BufferID bufID = _pTab->getBufferByIndex(index);
923  	return MainFileManager.getBufferByID(bufID);
924  }
925  void WindowsMenu::init(HMENU hMainMenu)
926  {
927  	_hMenu = ::GetSubMenu(hMainMenu, MENUINDEX_WINDOW);
928  	_hMenuList = ::GetSubMenu(hMainMenu, MENUINDEX_LIST);
929  }
930  void WindowsMenu::initPopupMenu(HMENU hMenu, DocTabView* pTab)
931  {
932  	bool isDropListMenu = false;
933  	UINT firstId = 0;
934  	UINT limitId = 0;
935  	UINT menuPosId = 0;
936  	if (hMenu == _hMenu)
937  	{
938  		firstId = IDM_WINDOW_MRU_FIRST;
939  		limitId = IDM_WINDOW_MRU_LIMIT;
940  		menuPosId = IDM_WINDOW_WINDOWS;
941  	}
942  	else if (hMenu == _hMenuList)
943  	{
944  		isDropListMenu = true;
945  		if (_limitPrev < pTab->nbItem())
946  		{
947  			_limitPrev = static_cast<UINT>(pTab->nbItem());
948  		}
949  		firstId = IDM_DROPLIST_MRU_FIRST;
950  		limitId = IDM_DROPLIST_MRU_FIRST + _limitPrev - 1;
951  		menuPosId = IDM_DROPLIST_LIST;
952  	}
953  	if (firstId > 0 && limitId > 0 && menuPosId > 0)
954  	{
955  		auto curDoc = pTab->getCurrentTabIndex();
956  		size_t nMaxDoc = static_cast<size_t>(limitId) - firstId + 1;
957  		size_t nDoc = pTab->nbItem();
958  		nDoc = std::min<size_t>(nDoc, nMaxDoc);
959  		UINT id = firstId;
960  		UINT guard = firstId + static_cast<int32_t>(nDoc);
961  		size_t pos = 0;
962  		for (; id < guard; ++id, ++pos)
963  		{
964  			BufferID bufID = pTab->getBufferByIndex(pos);
965  			Buffer* buf = MainFileManager.getBufferByID(bufID);
966  			MENUITEMINFO mii{};
967  			mii.cbSize = sizeof(mii);
968  			mii.fMask = MIIM_STRING | MIIM_STATE | MIIM_ID;
969  			generic_string strBuffer(BuildMenuFileName(60, static_cast<int32_t>(pos), buf->getFileName(), !isDropListMenu));
970  			std::vector<TCHAR> vBuffer(strBuffer.begin(), strBuffer.end());
971  			vBuffer.push_back('\0');
972  			mii.dwTypeData = (&vBuffer[0]);
973  			mii.fState &= ~(MF_GRAYED | MF_DISABLED | MF_CHECKED);
974  			if (static_cast<int32_t>(pos) == curDoc)
975  			{
976  				mii.fState |= MF_CHECKED;
977  			}
978  			mii.wID = id;
979  			UINT state = GetMenuState(hMenu, id, MF_BYCOMMAND);
980  			if (state == static_cast<UINT>(-1))
981  			{
982  				InsertMenuItem(hMenu, menuPosId, TRUE, &mii);
983  				if (isDropListMenu)
984  				{
985  					DeleteMenu(hMenu, menuPosId, FALSE);
986  				}
987  			}
988  			else
989  			{
990  				SetMenuItemInfo(hMenu, id, FALSE, &mii);
991  			}
992  		}
993  		for (; id <= limitId; ++id)
994  		{
995  			DeleteMenu(hMenu, id, FALSE);
996  		}
997  		if (isDropListMenu)
998  		{
999  			_limitPrev = static_cast<UINT>(pTab->nbItem());
1000  		}
1001  	}
1002  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-pluginsAdmin.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WindowsDlg.cpp</div>
                </div>
                <div class="column column_space"><pre><code>352  			else if (!versionVect[0].empty() && versionVect[1].empty()) 
353  			{
354  				result.first = Version(versionVect[0]);
355  			}
356  			else if (versionVect[0].empty() && !versionVect[1].empty()) 
357  			{
358  				result.second = Version(versionVect[1]);
359  			}
360  		}
</pre></code></div>
                <div class="column column_space"><pre><code>295  							if (buf->isDirty())
296  							{
297  								text += '*';
298  							}
299  							else if (buf->isReadOnly())
300  							{
301  								text += readonlyString;
302  							}
303  						}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    