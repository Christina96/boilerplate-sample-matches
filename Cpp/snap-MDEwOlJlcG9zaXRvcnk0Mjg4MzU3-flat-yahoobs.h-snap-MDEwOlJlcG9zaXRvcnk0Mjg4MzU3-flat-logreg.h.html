
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.h</h3>
            <pre><code>1  #ifndef YahooBs_h
2  #define YahooBs_h
3  #include "base.h"
4  #include "dmdata.h"
5  #include "stopword.h"
6  #include "webold.h"
7  #include "webmb.h"
8  #include "hldoc.h"
9  class TYBs;
10  class TYWord{
11  private:
12    TYBs* YBs;
13    TInt FirstChN;
14  public:
15    TYWord(): YBs(NULL), FirstChN(-1){}
16    TYWord(const TYWord& YWord): YBs(YWord.YBs), FirstChN(YWord.FirstChN){}
17    TYWord(TYBs* _YBs, const TStr& Str);
18    ~TYWord(){}
19    TYWord(TSIn& SIn): YBs(NULL), FirstChN(SIn){}
20    void Save(TSOut& SOut){FirstChN.Save(SOut);}
21    TYWord& operator=(const TYWord& YWord){
22      if (this!=&YWord){YBs=YWord.YBs; FirstChN=YWord.FirstChN;}
23      return *this;}
24    bool operator==(const TYWord& YWord) const {
25      return (GetStr()==YWord.GetStr());}
26    bool operator<(const TYWord& YWord) const {
27      return GetStr()<YWord.GetStr();}
28    TStr GetStr() const;
29    int GetSegs() const;
30    int GetPrimHashCd() const {return GetStr().GetPrimHashCd();}
31    int GetSecHashCd() const {return GetStr().GetSecHashCd();}
32    friend TYBs;
33  };
34  class TYDoc{
35  private:
36    TCRef CRef;
37  private:
38    TInt FirstPathCtgIdN;
39    TInt FirstCtgIdN;
40    TInt FirstReftoDocIdN;
41    TInt FirstRefbyDocIdN;
42    TInt FirstWordIdN;
43    TInt Sects;
44    TInt AbsSects;
45  public:
46    TYDoc():
47      FirstPathCtgIdN(-1), FirstCtgIdN(-1),
48      FirstReftoDocIdN(-1), FirstRefbyDocIdN(-1),
49      FirstWordIdN(-1), Sects(-1), AbsSects(-1){}
50    ~TYDoc(){}
51    TYDoc(TSIn& SIn):
52      FirstPathCtgIdN(SIn), FirstCtgIdN(SIn),
53      FirstReftoDocIdN(SIn), FirstRefbyDocIdN(SIn),
54      FirstWordIdN(SIn), Sects(SIn), AbsSects(SIn){}
55    static TPt<TYDoc> Load(TSIn& SIn){return new TYDoc(SIn);}
56    void Save(TSOut& SOut){
57      FirstPathCtgIdN.Save(SOut); FirstCtgIdN.Save(SOut);
58      FirstReftoDocIdN.Save(SOut); FirstRefbyDocIdN.Save(SOut);
59      FirstWordIdN.Save(SOut); Sects.Save(SOut); AbsSects.Save(SOut);}
60    TYDoc& operator=(const TYDoc&){Fail; return *this;}
61    friend TYBs;
62    friend TPt<TYDoc>;
63  };
64  typedef TPt<TYDoc> PYDoc;
65  class TYWordDs;
66  typedef TPt<TYWordDs> PYWordDs;
67  class TYWordDs{
68  private:
69    TCRef CRef;
70  public:
71    TInt Docs;
72    TInt Sects;
73    TFlt SumWordFq;
74    TIntFltKdV WordIdFqKdV;
75  public:
76    TYWordDs(const int& _Docs=0, const int& _Sects=0, const int& MxWordIds=100):
77      Docs(_Docs), Sects(_Sects), SumWordFq(0), WordIdFqKdV(MxWordIds, 0){}
78    ~TYWordDs(){}
79    TYWordDs(TSIn& SIn):
80      Docs(SIn),
81      Sects(SIn),
82      SumWordFq(SIn),
83      WordIdFqKdV(SIn){}
84    static PYWordDs Load(TSIn& SIn){return new TYWordDs(SIn);}
85    void Save(TSOut& SOut){
86      Docs.Save(SOut); Sects.Save(SOut); SumWordFq.Save(SOut);
87      WordIdFqKdV.Save(SOut);}
88    TYWordDs& operator=(const TYWordDs& YWordDs){
89      if (this!=&YWordDs){
90        Docs=YWordDs.Docs; Sects=YWordDs.Sects; SumWordFq=YWordDs.SumWordFq;
91        WordIdFqKdV=YWordDs.WordIdFqKdV;}
92      return *this;}
93    int GetDocs() const {return Docs;}
94    void AddSect(){Sects++;}
95    void PutSects(const int& _Sects){Sects=_Sects;}
96    int GetSects() const {return Sects;}
97    void AddWordIdFq(const TIntFltKd& WordIdFqKd);
98    void AddWordIdFq(const int& WordId, const double& WordFq){
99      AddWordIdFq(TIntFltKd(WordId, WordFq));}
100    bool IsWordId(const int& WordId, double& WordFq) const {
101      int WordIdFqKdN=WordIdFqKdV.SearchBin(TInt(WordId));
102      if (WordIdFqKdN==-1){return false;}
103      else {WordFq=WordIdFqKdV[WordIdFqKdN].Dat; return true;}}
104    bool IsWordId(const int& WordId) const {double WordFq;
105      return IsWordId(WordId, WordFq);}
106    double GetWordFq(const int& WordId) const {
107      return WordIdFqKdV[WordIdFqKdV.SearchBin(TInt(WordId))].Dat;}
108    double GetWordPrb(const int& WordId) const {double WordFq;
109      if (IsWordId(WordId, WordFq)){return WordFq/SumWordFq;} else {return 0;}}
110    int GetWordIds() const {return WordIdFqKdV.Len();}
111    double GetSumWordFq(){return SumWordFq;}
112    int FFirstWordId() const {return 0-1;}
113    bool FNextWordId(
114     int& WordIdN, int& WordId, double& WordFq, double& WordPrb) const;
115    bool FNextWordId(int& WordIdN, int& WordId, double& WordFq) const {
116      double WordPrb; return FNextWordId(WordIdN, WordId, WordFq, WordPrb);}
117    bool FNextWordId(int& WordIdN, int& WordId) const {
118      double WordFq; double WordPrb;
119      return FNextWordId(WordIdN, WordId, WordFq, WordPrb);}
120    void NrToSumWordFq(const double& NrSumWordFq);
121    void PowWordFq(const double& Exp);
122    void SaveTxt(const PSOut& SOut, const TYBs* YBs=NULL, const int& DocId=-1);
123    static PYWordDs GetMerged(const PYWordDs& LWordDs,
124     const PYWordDs& RWordDs, const double& LWgt, const double& RWgt);
125    static PYWordDs GetTruncByMnWordPrb(
126     const PYWordDs& WordDs, const double& MnWordPrb);
127    static PYWordDs GetTruncBySumWordPrb(
128     const PYWordDs& WordDs, const double& SumWordPrb);
129    friend PYWordDs;
130  };
131  class TYSect;
132  typedef TPt<TYSect> PYSect;
133  typedef TVec<PYSect> TYSectV;
134  class TYSect{
135  private:
136    TCRef CRef;
137  private:
138    TStr RefUrlStr;
139    TStr UrlStr;
<span onclick='openModal()' class='match'>140    PYWordDs WordDs;
141    TStr TxtStr;
142  public:
143    TYSect(const TStr& _RefUrlStr, const TStr& _UrlStr,
144     const PYWordDs& _WordDs, const TStr& _TxtStr):
</span>145      RefUrlStr(_RefUrlStr), UrlStr(_UrlStr),
146      WordDs(_WordDs), TxtStr(_TxtStr){}
147    ~TYSect(){}
148    TYSect(TSIn& SIn):
149      RefUrlStr(SIn), UrlStr(SIn), WordDs(SIn), TxtStr(SIn){}
150    static PYSect Load(TSIn& SIn){return new TYSect(SIn);}
151    void Save(TSOut& SOut){
152      RefUrlStr.Save(SOut); UrlStr.Save(SOut);
153      WordDs.Save(SOut); TxtStr.Save(SOut);}
154    TYSect& operator=(const TYSect&){Fail; return *this;}
155    TStr GetRefUrlStr(){return RefUrlStr;}
156    TStr GetUrlStr(){return UrlStr;}
157    PYWordDs GetWordDs(){return WordDs;}
158    TStr GetTxtStr(){return TxtStr;}
159    friend PYSect;
160  };
161  class TYBs{
162  private:
163    TCRef CRef;
164  private:
165    static const TStr ParWordStr;
166    PNotify Notify;
167    TInt MxNGram;
168    TInt MnWordFq;
169    TInt ParWordId;
170    TInt RootDocId;
171    TStr RootUrlStr;
172    TInt Sects;
173    TInt AbsSects;
174    PSwSet SwSet;
175    TStrIntH CtgStrToFqH;
176    THash<TYWord, TInt> WordToFqH;
177    TChA WordChAHeap;
178    THash<TStr, PYDoc> UrlStrToDocH;
179    TIntV PathCtgIdVHeap;
180    TIntV CtgIdVHeap;
181    TIntV ReftoDocIdVHeap;
182    TIntV RefbyDocIdVHeap;
183    TIntV WordIdVHeap;
184    void PutThisToWord();
185    TStr GetStrQStr(const TStrQ& StrQ, const int& Strs=-1);
186  public:
187    TYBs(const PXWebBs& WebBs,
188     const int& _MxNGram=1, const int& _MnWordFq=4,
189     const TSwSetTy& SwSetTy=swstNone, const TStrV& ExclUrlStrV=TStrV(),
190     const PNotify& _Notify=NULL);
191    ~TYBs(){}
192    TYBs(TSIn& SIn, const PNotify& _Notify=NULL):
193      Notify(_Notify),
194      MxNGram(SIn), MnWordFq(SIn), ParWordId(SIn),
195      RootDocId(SIn), RootUrlStr(SIn),
196      Sects(SIn), AbsSects(SIn),
197      SwSet(SIn), CtgStrToFqH(SIn),
198      WordToFqH(SIn), WordChAHeap(SIn),
199      UrlStrToDocH(SIn),
200      PathCtgIdVHeap(SIn), CtgIdVHeap(SIn),
201      ReftoDocIdVHeap(SIn), RefbyDocIdVHeap(SIn),
202      WordIdVHeap(SIn){SIn.LoadCs(); PutThisToWord();}
203    static TPt<TYBs> Load(TSIn& SIn){return new TYBs(SIn);}
204    void Save(TSOut& SOut){
205      MxNGram.Save(SOut); MnWordFq.Save(SOut); ParWordId.Save(SOut);
206      RootDocId.Save(SOut); RootUrlStr.Save(SOut);
207      Sects.Save(SOut); AbsSects.Save(SOut);
208      SwSet.Save(SOut); CtgStrToFqH.Save(SOut);
209      WordToFqH.Save(SOut); WordChAHeap.Save(SOut);
210      UrlStrToDocH.Save(SOut);
211      PathCtgIdVHeap.Save(SOut); CtgIdVHeap.Save(SOut);
212      ReftoDocIdVHeap.Save(SOut); RefbyDocIdVHeap.Save(SOut);
213      WordIdVHeap.Save(SOut); SOut.SaveCs();}
214    void Save(const TStr& FNm){PSOut SOut=TFOut::New(FNm); Save(*SOut);}
215    TYBs& operator=(const TYBs&){Fail; return *this;}
216    bool IsIdEqN(){
217      return CtgStrToFqH.IsKeyIdEqKeyN()&&
218       WordToFqH.IsKeyIdEqKeyN()&&
219       UrlStrToDocH.IsKeyIdEqKeyN();}
220    void AddCtgStrWords(const TStr& CtgStr, TIntV& DocWordIdV);
221    void AddDoc(
222     const PXWebPg& WebPg, const bool& DoGenDoc,
223     const int& NGram, const TStrV& ExclUrlStrV,
224     TIntPrV& DocIdRefbyDocIdPrV);
225    int GetCtgs(){return CtgStrToFqH.Len();}
226    int GetCtgId(const TStr& CtgStr){return CtgStrToFqH.GetKeyId(CtgStr);}
227    TStr GetCtgStr(const int& CtgId){return CtgStrToFqH.GetKey(CtgId);}
228    int GetCtgFq(const int& CtgId){return CtgStrToFqH[CtgId];}
229    TStr GetCtgIdVStr(const TIntV& CtgIdV);
230    void GetCtgStrV(const TIntV& CtgIdV, TStrV& CtgStrV);
231    TStr GetCtgIdToWFqHStr(const TIntFltH& CtgIdToWFqH, const double& SumPrb=1);
232    int FFirstCtg(){return CtgStrToFqH.FFirstKeyId();}
233    bool FNextCtg(int& CtgId){return CtgStrToFqH.FNextKeyId(CtgId);}
234    int GetWords(){return WordToFqH.Len();}
235    int GetMxWordIds(){return WordToFqH.GetMxKeyIds();}
236    TInt& AddWord(const TStr& WordStr);
237    int GetWordId(const TStr& WordStr);
238    TStr GetWordStr(const int& WordId) const {
239      return WordToFqH.GetKey(WordId).GetStr();}
240    int GetWordFq(const int& WordId){return WordToFqH[WordId];}
241    int GetWordSegs(const int& WordId){return WordToFqH.GetKey(WordId).GetSegs();}
242    int GetParWordId(){return ParWordId;}
243    int FFirstWordId(){return WordToFqH.FFirstKeyId();}
244    bool FNextWordId(int& WordId){return WordToFqH.FNextKeyId(WordId);}
245    int GetDocs(){return UrlStrToDocH.Len();}
246    int GetMxDocIds(){return UrlStrToDocH.GetMxKeyIds();}
247    int GetDocId(const TStr& UrlStr){return UrlStrToDocH.GetKeyId(UrlStr);}
248    TStr GetDocUrlStr(const int& DocId) const {return UrlStrToDocH.GetKey(DocId);}
249    PYDoc GetDoc(const int& DocId){return UrlStrToDocH[DocId];}
250    int GetSects(){return Sects;}
251    int GetAbsSects(){return AbsSects;}
252    int GetDocSects(const int& DocId){return UrlStrToDocH[DocId]->Sects;}
253    int GetDocAbsSects(const int& DocId){return UrlStrToDocH[DocId]->AbsSects;}
254    int GetRootDocId(){return RootDocId;}
255    TStr GetRootUrlStr(){return RootUrlStr;}
256    void GetLevDocIdV(const int& Lev, TIntV& DocIdV);
257    void GetCtgIdV(const int& DocId, TIntV& CtgIdV);
258    void GetParentDocIdV(const int& DocId, TIntV& DocIdV);
259    int GetDocDist(const int& LDocId, const int& RDocId);
260    int FFirstDocId(){return UrlStrToDocH.FFirstKeyId();}
261    bool FNextDocId(int& DocId){return UrlStrToDocH.FNextKeyId(DocId);}
262    int FFirstDocPathCtgId(const int& DocId){
263      return GetDoc(DocId)->FirstPathCtgIdN;}
264    bool FNextDocPathCtgId(int& CtgIdN, int& CtgId){
265      if (CtgIdN==-1){return false;}
266      else {CtgId=PathCtgIdVHeap[CtgIdN++]; return CtgId!=-1;}}
267    int FFirstDocCtgId(const int& DocId){
268      return GetDoc(DocId)->FirstCtgIdN;}
269    bool FNextDocCtgId(int& CtgIdN, int& CtgId){
270      if (CtgIdN==-1){return false;}
271      else {CtgId=CtgIdVHeap[CtgIdN++]; return CtgId!=-1;}}
272    int FFirstDocWordId(const int& DocId){
273      return GetDoc(DocId)->FirstWordIdN;}
274    bool FNextDocWordId(int& WordIdN, int& WordId){
275      if (WordIdN==-1){return false;}
276      else {WordId=WordIdVHeap[WordIdN++]; return WordId!=-1;}}
277    int GetDocReftos(const int& DocId);
278    int FFirstDocReftoDocId(const int& DocId){
279      return GetDoc(DocId)->FirstReftoDocIdN;}
280    bool FNextDocReftoDocId(int& ReftoDocIdN, int& ReftoDocId){
281      if (ReftoDocIdN==-1){return false;}
282      else {ReftoDocId=ReftoDocIdVHeap[ReftoDocIdN++]; return ReftoDocId!=-1;}}
283    int GetDocRefbys(const int& DocId);
284    int FFirstDocRefbyDocId(const int& DocId){
285      return GetDoc(DocId)->FirstRefbyDocIdN;}
286    bool FNextDocRefbyDocId(int& RefbyDocIdN, int& RefbyDocId){
287      if (RefbyDocIdN==-1){return false;}
288      else {RefbyDocId=RefbyDocIdVHeap[RefbyDocIdN++]; return RefbyDocId!=-1;}}
289    PYWordDs GetWordDs(const PSIn& SIn);
290    PYWordDs GetWordDs(const TStr& Str){
291      PSIn SIn=TStrIn::New(Str);
292      return GetWordDs(SIn);}
293    PYWordDs GetWordDs(const PXWebPg& WebPg){
294      PSIn SIn=TStrIn::New(WebPg->GetHttpResp()->GetBodyAsStr());
295      return GetWordDs(SIn);}
296    void GetAbsSectV(
297     const TStr& RefUrlStr, const PXWebPg& WebPg, TYSectV& YSectV);
298    static void GetAbsSectUrlStrV(const PXWebPg& WebPg, TStrV& UrlStrV);
299    void SaveTxt(const PSOut& SOut);
300    void SaveTxt(const TStr& FNm){SaveTxt(PSOut(new TFOut(FNm)));}
301    void SaveTxtWords(const TStr& FNm);
302    void SaveTxtCtgs(const TStr& FNm);
303    friend TYWord;
304    friend TYDoc;
305    friend TPt<TYBs>;
306  };
307  typedef TPt<TYBs> PYBs;
308  typedef enum {ydnConst, ydnWords, ydnLnWords, ydnSects, ydnLnSects,
309   ydnDocs, ydnLnDocs} TYDsBsNrType;
310  class TYDsBs{
311  private:
312    TCRef CRef;
313  private:
314    PYWordDs AllWordDs;
315    THash<TInt, PYWordDs> DocIdToWordDsH;
316    PNotify Notify;
317    int GetMissDss(const PYBs& YBs, const int& DocId);
318    double GetNrWgt(const TYDsBsNrType& NrType, const PYWordDs& WordDs);
319  public:
320    TYDsBs(const TYDsBsNrType& NrType, const double& WordFqExp,
321     const double& MnWordPrb, const double& MnAllWordPrb,
322     const PYBs& YBs, const PNotify& _Notify);
323    ~TYDsBs(){}
324    TYDsBs(TSIn& SIn, const PNotify& _Notify=NULL):
325      AllWordDs(SIn), DocIdToWordDsH(SIn), Notify(_Notify){SIn.LoadCs();}
326    static TPt<TYDsBs> Load(TSIn& SIn){return new TYDsBs(SIn);}
327    void Save(TSOut& SOut){
328      AllWordDs.Save(SOut); DocIdToWordDsH.Save(SOut); SOut.SaveCs();}
329    void Save(const TStr& FNm){PSOut SOut=TFOut::New(FNm); Save(*SOut);}
330    TYDsBs& operator=(const TYDsBs&){Fail; return *this;}
331    PYWordDs GetAllWordDs(){return AllWordDs;}
332    PYWordDs GetWordDs(const int& DocId){return DocIdToWordDsH.GetDat(DocId);}
333    void SaveTxt(const PSOut& SOut, const PYBs& YBs);
334    static TStr GetNrTypeStr(const TYDsBsNrType& NrType);
335    friend TPt<TYDsBs>;
336  };
337  typedef TPt<TYDsBs> PYDsBs;
338  class TYTsBs{
339  private:
340    TCRef CRef;
341  private:
342    TStrStrH TsRefUrlStrH;
343    PXWebBs WebBs;
344    PXWebTravel WebTravel;
345  public:
346    TYTsBs(
347     const double& AllDocsPrb, const double& SectPrb, const TStr& TsWebBsFPath,
348     const PXWebBs& RefWebBs, const PYBs& RefYBs,
349     const PXWebTravelEvent& WebTravelEvent, const PNotify& Notify);
350    ~TYTsBs();
351    TYTsBs(TSIn& SIn){SIn.LoadCs();}
352    static TPt<TYTsBs> Load(TSIn& SIn){return new TYTsBs(SIn);}
353    void Save(TSOut& SOut){SOut.SaveCs();}
354    TYTsBs& operator=(const TYTsBs&){Fail; return *this;}
355    void SaveTxt(const PSOut& SOut, const PYBs& YBs);
356    friend TPt<TYTsBs>;
357  };
358  typedef TPt<TYTsBs> PYTsBs;
359  class TYHlCtx{
360  private:
361    TCRef CRef;
362  private:
363    TStrV HlCtxStrV;
364  public:
365    TYHlCtx(
366     const PXWebBs& RefWebBs, const PYBs& RefYBs, const PXWebBs& DocWebBs,
367     const PNotify& Notify);
368    ~TYHlCtx(){}
369    TYHlCtx(TSIn& SIn){SIn.LoadCs();}
370    static TPt<TYHlCtx> Load(TSIn& SIn){return new TYHlCtx(SIn);}
371    void Save(TSOut& SOut){SOut.SaveCs();}
372    TYHlCtx& operator=(const TYHlCtx&){Fail; return *this;}
373    TStrV& GetHlCtxStrV(){return HlCtxStrV;}
374    friend TPt<TYHlCtx>;
375  };
376  typedef TPt<TYHlCtx> PYHlCtx;
377  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-logreg.h</h3>
            <pre><code>1  class TLogRegMd;
2  typedef TPt<TLogRegMd> PLogRegMd;
3  class TLogReg {
4  private:
5      static void CG(const TMatrix& Matrix, const TFltV& w, const TFltV& b, 
6          TFltV& x, const int& MaxStep, const int& verb);
7      static void IRLS(const TMatrix& Matrix, TFltV& y, TFltV& bb, 
8          const double& ChangeEps, const int& MaxStep, const int& verb);
9  public:
10      static PLogRegMd CalcLogReg(PSVMTrainSet Set, const double& ChangeEps = 0.01, const int& MaxStep = 200);
11      static PLogRegMd CalcLogReg(TMatrix& Set, TFltV& y, const double& ChangeEps = 0.01, const int& MaxStep = 200);
12      static PBowMd CalcLogReg(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& DIdV, 
13          const double& Treshold, const double& ChangeEps = 0.01, const int& MaxStep = 200, const int& Verbosity = 0);
14  };
15  class TLogRegMd {
16  private: 
17      TCRef CRef;
18  private:
19      TFltV bb;
20  public:
21      TLogRegMd(const TFltV& _bb): bb(_bb) { };
22      TLogRegMd(TSIn& SIn) { bb.Load(SIn); };
23      static PLogRegMd Load(TSIn& SIn) { return new TLogRegMd(SIn); };
24      void Save(TSOut& SOut) const { bb.Save(SOut); };
25      UndefDefaultCopyAssign(TLogRegMd);
26  public:    
27      double GetCfy(const TIntFltKdV& AttrV);
28      TCfyRes Test(PSVMTrainSet Set, const double& threshold);
29      friend class TPt<TLogRegMd>;
30  };
31  class TBowLogRegMd: public TBowMd {
32  private:
33      static bool IsReg;
34      static bool MkReg(){return TBowMd::Reg(TTypeNm<TBowLogRegMd>(), &Load);}
35  private:
36  	TStr CatNm;
<span onclick='openModal()' class='match'>37  	TFlt Treshold;
38  	TFltV WeightV;
39  public:
40  	TBowLogRegMd(const PBowDocBs& BowDocBs, const TStr& _CatNm,
41  		const double& _Treshold, const TFltV& _WeightV):
</span>42  		TBowMd(BowDocBs), CatNm(_CatNm), Treshold(_Treshold), WeightV(_WeightV) { }
43  	TBowLogRegMd(TSIn& SIn): TBowMd(SIn) { Treshold.Load(SIn); CatNm.Load(SIn); WeightV.Load(SIn); }
44    	static PBowMd Load(TSIn& SIn) { return PBowMd(new TBowLogRegMd(SIn)); }
45  	void Save(TSOut& SOut) { TBowMd::Save(SOut); Treshold.Save(SOut); CatNm.Save(SOut); WeightV.Save(SOut); }
46      static PBowMd New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
47      	const TStr& _CatNm, const TIntV& _DIdV, const double& _Treshold = 0.8,
48          const double& ChangeEps = 0.01, const int& MaxStep = 100, const int& Verbosity = 0) {
49  			return TLogReg::CalcLogReg(BowDocBs, BowDocWgtBs, _CatNm, _DIdV, _Treshold, ChangeEps, MaxStep, Verbosity); }
50      void GetCfy(const PBowSpV& QueryBowSpV, TFltStrPrV& WgtCatNmPrV);
51  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-logreg.h</div>
                </div>
                <div class="column column_space"><pre><code>140    PYWordDs WordDs;
141    TStr TxtStr;
142  public:
143    TYSect(const TStr& _RefUrlStr, const TStr& _UrlStr,
144     const PYWordDs& _WordDs, const TStr& _TxtStr):
</pre></code></div>
                <div class="column column_space"><pre><code>37  	TFlt Treshold;
38  	TFltV WeightV;
39  public:
40  	TBowLogRegMd(const PBowDocBs& BowDocBs, const TStr& _CatNm,
41  		const double& _Treshold, const TFltV& _WeightV):
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    