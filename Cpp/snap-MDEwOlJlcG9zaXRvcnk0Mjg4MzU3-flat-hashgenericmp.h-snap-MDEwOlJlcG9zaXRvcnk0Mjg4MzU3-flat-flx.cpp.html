
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.266855066612838%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashgenericmp.h</h3>
            <pre><code>1  #include "bd.h"
2  #ifdef GLib_GLIBC
3  inline unsigned int __sync_fetch_and_add_2(volatile unsigned int* p, unsigned int incr)
4  {
5      unsigned int result;
6      asm volatile("lock; xadd %0, %1" :
7              "=r"(result), "=m"(*p):
8              "0"(incr), "m"(*p) :
9              "memory");
10      return result + 1;
11  }
12  #endif
13  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
14  class THashGenericMP{
15  public:
16    enum {HashPrimes=32};
17    static const unsigned int HashPrimeT[HashPrimes];
18  public:
19    typedef THashKeyDatI<TKey, TDat> TIter;
20  private:
21    typedef THashKeyDat<TKey, TDat> THKeyDat;
22    typedef TPair<TKey, TDat> TKeyDatP;
23    TIntV PortV;
24    TIntV PortLockV;
25    TVec<THKeyDat> KeyDatV;
26    TBool AutoSizeP;
27    TInt FFreeKeyId, FreeKeys;
28  private:
29    class THashKeyDatCmp {
30    public:
31      const THash<TKey, TDat, THashFunc>& Hash;
32      bool CmpKey, Asc;
33      THashKeyDatCmp(THash<TKey, TDat, THashFunc>& _Hash, const bool& _CmpKey, const bool& _Asc) :
34        Hash(_Hash), CmpKey(_CmpKey), Asc(_Asc) { }
35      bool operator () (const int& KeyId1, const int& KeyId2) const {
36        if (CmpKey) {
37          if (Asc) { return Hash.GetKey(KeyId1) < Hash.GetKey(KeyId2); }
38          else { return Hash.GetKey(KeyId2) < Hash.GetKey(KeyId1); } }
39        else {
40          if (Asc) { return Hash[KeyId1] < Hash[KeyId2]; }
41          else { return Hash[KeyId2] < Hash[KeyId1]; } } }
42    };
43  private:
44    THKeyDat& GetHashKeyDat(const int& KeyId){
45      THKeyDat& KeyDat=KeyDatV[KeyId];
46      Assert(KeyDat.HashCd!=-1); return KeyDat;}
47    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
48      const THKeyDat& KeyDat=KeyDatV[KeyId];
49      Assert(KeyDat.HashCd!=-1); return KeyDat;}
50    uint GetNextPrime(const uint& Val) const;
51    void Resize();
52  public:
53    THashGenericMP():
54      PortV(), KeyDatV(),
55      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0){
56      }
57    THashGenericMP(const THashGenericMP& Hash):
58      PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
59      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys) {
60      }
61    explicit THashGenericMP(const int& ExpectVals, const bool& _AutoSizeP=false);
62    explicit THashGenericMP(TSIn& SIn):
63      PortV(SIn), KeyDatV(SIn),
64      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){
65      SIn.LoadCs();
66    }
67    void Load(TSIn& SIn){
68      PortV.Load(SIn); KeyDatV.Load(SIn);
69      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
70      SIn.LoadCs();
71    }
72    void Save(TSOut& SOut) const {
73      PortV.Save(SOut); KeyDatV.Save(SOut);
74      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
75      SOut.SaveCs();
76    }
77    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
78    void SaveXml(TSOut& SOut, const TStr& Nm);
79    void ResizePar(int);
80    THashGenericMP& operator=(const THashGenericMP& Hash){
81      if (this!=&Hash){
82        PortV=Hash.PortV; KeyDatV=Hash.KeyDatV; AutoSizeP=Hash.AutoSizeP;
83        FFreeKeyId=Hash.FFreeKeyId; FreeKeys=Hash.FreeKeys;}
84      return *this;}
85    bool operator==(const THashGenericMP& Hash) const; 
86    bool operator < (const THashGenericMP& Hash) const { Fail; return true; }
87    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
88    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
89    TDat& operator()(const TKey& Key){return AddDat(Key);}
90    ::TSize GetMemUsed() const {
91        int64 MemUsed = sizeof(bool)+2*sizeof(int);
92        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
93        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
94            MemUsed += int64(2 * sizeof(TInt));
95            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
96            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
97        }
98        return ::TSize(MemUsed);
99    }
100    TIter BegI() const {
101      if (Len() == 0){return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
102      if (IsKeyIdEqKeyN()) { return TIter(KeyDatV.BegI(), KeyDatV.EndI());}
103      int FKeyId=-1;  FNextKeyId(FKeyId);
104      return TIter(KeyDatV.BegI()+FKeyId, KeyDatV.EndI()); }
105    TIter EndI() const {return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
106    TIter GetI(const TKey& Key) const {return TIter(&KeyDatV[GetKeyId(Key)], KeyDatV.EndI());}
107    void Gen(const int& ExpectVals){
108      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyDatV.Gen(ExpectVals, 0);
109      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1));}
110    void Clr(const bool& DoDel=true, const int& NoDelLim=-1, const bool& ResetDat=true);
111    bool Empty() const {return Len()==0;}
112    int Len() const {return KeyDatV.Len()-FreeKeys;}
113    int GetPorts() const {return PortV.Len();}
114    bool IsAutoSize() const {return AutoSizeP;}
115    int GetMxKeyIds() const {return KeyDatV.Len();}
116    int GetReservedKeyIds() const {return KeyDatV.Reserved();}
117    bool IsKeyIdEqKeyN() const {return FreeKeys==0;}
118    int AddKey(const TKey& Key);
119    int AddKeyPar(const TKey& Key);
120    TDat& AddDatId(const TKey& Key){
121      int KeyId=AddKey(Key); return KeyDatV[KeyId].Dat=KeyId;}
122    TDat& AddDat(const TKey& Key){return KeyDatV[AddKey(Key)].Dat;}
123    TDat& AddDat(const TKey& Key, const TDat& Dat){
124      return KeyDatV[AddKey(Key)].Dat=Dat;}
125    bool AddDatIfNotExist(const TKey& Key, const TDat& Dat);
126    int AddDatPar(const TKey& Key, const TInt& Dat) {
127      const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
128      const int HashCd=abs(THashFunc::GetSecHashCd(Key));
129      int PrevKeyId=-1;
130      int KeyId;
131      int Ret;
132      bool done = false;
133      while(!done) {
134        bool port_lock = false;
135        int old;
136        int *ptr = &PortLockV[PortN].Val;
137        old = PortLockV[PortN];
138        if (old == -2) {
139          port_lock = false;
140        }
141        else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
142          port_lock = true;
143        }
144        KeyId = PortV[PortN];
145        while ((KeyId!=-1) &&
146            !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
147          PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
148        if (KeyId==-1) {
149          if (port_lock == false) continue;
150          volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
151          KeyId = __sync_fetch_and_add(p, 1);
152          KeyDatV[KeyId].Next=-1;
153          KeyDatV[KeyId].HashCd=HashCd;
154          KeyDatV[KeyId].Key=Key;
155          int temp;
156          int* pt = &KeyDatV[KeyId].Next.Val;
157          while(true) {
158            temp = KeyDatV[KeyId].Next;
159            if (temp == -2) continue;
160            if (__sync_bool_compare_and_swap(pt, temp, -2)) {
161              KeyDatV[KeyId].Dat.Val1 = 0;
162              KeyDatV[KeyId].Dat.Val2.Add(Dat);
163              *pt = temp;
164              done = true;
165  	          Ret = 0;
166              break;
167            }
168          }
169          if (PrevKeyId==-1){
170            PortV[PortN] = KeyId;
171          } else {
172            KeyDatV[PrevKeyId].Next=KeyId;
173          }
174          *ptr = old;
175        }
176        else {
177          int temp, temp1;
178          int* pt = &KeyDatV[KeyId].Next.Val;
179          while(true) {
180            temp = KeyDatV[KeyId].Next;
181            temp1 = __sync_val_compare_and_swap(pt, temp, -2);
182            if (temp1 == temp && temp1 != -2) {
183              KeyDatV[KeyId].Dat.Val2.Add(Dat);
184              *pt = temp;
185              if (port_lock) *ptr = old;
186              done = true;
187  	          Ret = KeyDatV[KeyId].Dat.Val1;
188              break;
189            }
190            else {
191              usleep(20);
192            }
193          }
194        }
195      }
196      return Ret;
197    }
198    void DelKey(const TKey& Key);
199    bool DelIfKey(const TKey& Key){
200      int KeyId; if (IsKey(Key, KeyId)){DelKeyId(KeyId); return true;} return false;}
201    void DelKeyId(const int& KeyId){DelKey(GetKey(KeyId));}
202    void DelKeyIdV(const TIntV& KeyIdV){
203      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++){DelKeyId(KeyIdV[KeyIdN]);}}
204    void MarkDelKey(const TKey& Key); 
205    void MarkDelKeyId(const int& KeyId){MarkDelKey(GetKey(KeyId));}
206    const TKey& GetKey(const int& KeyId) const { return GetHashKeyDat(KeyId).Key;}
207    int GetKeyId(const TKey& Key) const;
208    int GetRndKeyId(TRnd& Rnd) const;
209    int GetRndKeyId(TRnd& Rnd, const double& EmptyFrac);
210    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1;}
211    bool IsKey(const TKey& Key, int& KeyId) const { KeyId=GetKeyId(Key); return KeyId!=-1;}
212    bool IsKeyId(const int& KeyId) const {
213      return (0<=KeyId)&&(KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd!=-1);}
214    const TDat& GetDat(const TKey& Key) const {return KeyDatV[GetKeyId(Key)].Dat;}
215    TDat& GetDat(const TKey& Key){return KeyDatV[GetKeyId(Key)].Dat;}
216    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
217      const THKeyDat& KeyDat=GetHashKeyDat(KeyId);
218      Key=KeyDat.Key; Dat=KeyDat.Dat;}
219    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const {int KeyId;
220      if (IsKey(Key, KeyId)){Dat=GetHashKeyDat(KeyId).Dat; return true;}
221      else {return false;}}
222    int FFirstKeyId() const {return 0-1;}
223    bool FNextKeyId(int& KeyId) const;
224    void GetKeyV(TVec<TKey>& KeyV) const;
225    void GetDatV(TVec<TDat>& DatV) const;
226    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
227    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
228    void GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const;
229    void GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const;
230    void Swap(THashGenericMP& Hash);
231    void Defrag();
232    void Pack(){KeyDatV.Pack();}
233    void Sort(const bool& CmpKey, const bool& Asc);
234    void SortByKey(const bool& Asc=true) { Sort(true, Asc); }
235    void SortByDat(const bool& Asc=true) { Sort(false, Asc); }
236  };
237  template<class TKey, class TDat, class THashFunc>
238  const unsigned int THashGenericMP<TKey, TDat, THashFunc>::HashPrimeT[HashPrimes]={
239    3ul, 5ul, 11ul, 23ul,
240    53ul,         97ul,         193ul,       389ul,       769ul,
241    1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
242    49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
243    1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
244    50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
245    1610612741ul, 3221225473ul, 4294967291ul
246  };
247  template<class TKey, class TDat, class THashFunc>
248  uint THashGenericMP<TKey, TDat, THashFunc>::GetNextPrime(const uint& Val) const {
249    const uint* f=(const uint*)HashPrimeT, *m, *l=(const uint*)HashPrimeT + (int)HashPrimes;
250    int h, len = (int)HashPrimes;
251    while (len > 0) {
252      h = len >> 1;  m = f + h;
253      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
254      else len = h;
255    }
256    return f == l ? *(l - 1) : *f;
257  }
258  template<class TKey, class TDat, class THashFunc>
259  void THashGenericMP<TKey, TDat, THashFunc>::ResizePar(int sz){
260    if (PortV.Len()==0){
261      PortV.Gen(sz);
262      KeyDatV.Gen(sz);
263      PortLockV.Gen(sz);
264    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
265      PortV.Gen(GetNextPrime(PortV.Len()+1));
266    } else {
267      return;
268    }
269    PortV.PutAll(TInt(-1));
270    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
271      THKeyDat& KeyDat=KeyDatV[KeyId];
272      if (KeyDat.HashCd!=-1){
273        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
274        KeyDat.Next=PortV[PortN];
275        PortV[PortN]=KeyId;
276      }
277    }
278  }
279  template<class TKey, class TDat, class THashFunc>
280  void THashGenericMP<TKey, TDat, THashFunc>::Resize(){
281    if (PortV.Len()==0){
282      PortV.Gen(17);
283    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
284      PortV.Gen(GetNextPrime(PortV.Len()+1));
285    } else {
286      return;
287    }
288    PortV.PutAll(TInt(-1));
289    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
290      THKeyDat& KeyDat=KeyDatV[KeyId];
291      if (KeyDat.HashCd!=-1){
292        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
293        KeyDat.Next=PortV[PortN];
294        PortV[PortN]=KeyId;
295      }
296    }
297  }
298  template<class TKey, class TDat, class THashFunc>
299  THashGenericMP<TKey, TDat, THashFunc>::THashGenericMP(const int& ExpectVals, const bool& _AutoSizeP):
300    PortV(GetNextPrime(ExpectVals/2)), KeyDatV(ExpectVals, 0),
301    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0){
302    PortV.PutAll(TInt(-1));
303  }
304  template<class TKey, class TDat, class THashFunc>
305  bool THashGenericMP<TKey, TDat, THashFunc>::operator==(const THashGenericMP& Hash) const {
306    if (Len() != Hash.Len()) { return false; }
307    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
308      const TKey& Key = GetKey(i);
309      if (! Hash.IsKey(Key)) { return false; }
310      if (GetDat(Key) != Hash.GetDat(Key)) { return false; }
311    }
312    return true;
313  }
314  template<class TKey, class TDat, class THashFunc>
315  void THashGenericMP<TKey, TDat, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim, const bool& ResetDat){
316    if (DoDel){
317      PortV.Clr(); KeyDatV.Clr();
318    } else {
319      PortV.PutAll(TInt(-1));
320      KeyDatV.Clr(DoDel, NoDelLim);
321      if (ResetDat){KeyDatV.PutAll(THKeyDat());}
322    }
323    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
324  }
325  template<class TKey, class TDat, class THashFunc>
<span onclick='openModal()' class='match'>326  int THashGenericMP<TKey, TDat, THashFunc>::AddKey(const TKey& Key){
327    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
328    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
</span>329    int PrevKeyId=-1;
330    int KeyId=PortV[PortN];
331    while ((KeyId!=-1) &&
332     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
333      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
334    if (KeyId==-1){
335      if (FFreeKeyId==-1){
336        KeyId=KeyDatV.Add(THKeyDat(-1, HashCd, Key));
337      } else {
338        KeyId=FFreeKeyId; FFreeKeyId=KeyDatV[FFreeKeyId].Next; FreeKeys--;
339        KeyDatV[KeyId].Next=-1;
340        KeyDatV[KeyId].HashCd=HashCd;
341        KeyDatV[KeyId].Key=Key;
342      }
343      if (PrevKeyId==-1){
344        PortV[PortN]=KeyId;
345      } else {
346        KeyDatV[PrevKeyId].Next=KeyId;
347      }
348    }
349    return KeyId;
350  }
351  template<class TKey, class TDat, class THashFunc>
352  int THashGenericMP<TKey, TDat, THashFunc>::AddKeyPar(const TKey& Key){
353      const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
354      const int HashCd=abs(THashFunc::GetSecHashCd(Key));
355      int PrevKeyId=-1;
356      int KeyId;
357      bool done = false;
358      while(!done) {
359        bool port_lock = false;
360        int old;
361        int *ptr = &PortLockV[PortN].Val;
362        old = PortLockV[PortN];
363        if (old == -2) {
364          port_lock = false;
365        }
366        else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
367          port_lock = true;
368        }
369        KeyId = PortV[PortN];
370        while ((KeyId!=-1) &&
371            !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
372          PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
373        if (KeyId==-1) {
374          if (port_lock == false) continue;
375          volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
376          KeyId = __sync_fetch_and_add(p, 1);
377          KeyDatV[KeyId].Next=-1;
378          KeyDatV[KeyId].HashCd=HashCd;
379          KeyDatV[KeyId].Key=Key;
380          if (PrevKeyId==-1){
381            PortV[PortN] = KeyId;
382          } else {
383            KeyDatV[PrevKeyId].Next=KeyId;
384          }
385          *ptr = old;
386          done = true;
387        }
388        else {
389          done = true;
390        }
391      }
392      return KeyId;
393  }
394  template<class TKey, class TDat, class THashFunc>
395  void THashGenericMP<TKey, TDat, THashFunc>::DelKey(const TKey& Key){
396    IAssert(!PortV.Empty());
397    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
398    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
399    int PrevKeyId=-1;
400    int KeyId=PortV[PortN];
401    while ((KeyId!=-1) &&
402     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
403      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
404    IAssert(KeyId!=-1); 
405    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
406    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
407    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
408    KeyDatV[KeyId].HashCd=TInt(-1);
409    KeyDatV[KeyId].Key=TKey();
410    KeyDatV[KeyId].Dat=TDat();
411  }
412  template<class TKey, class TDat, class THashFunc>
413  void THashGenericMP<TKey, TDat, THashFunc>::MarkDelKey(const TKey& Key){
414    IAssert(!PortV.Empty());
415    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
416    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
417    int PrevKeyId=-1;
418    int KeyId=PortV[PortN];
419    while ((KeyId!=-1) &&
420     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
421      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
422    IAssertR(KeyId!=-1, Key.GetStr());
423    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
424    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
425    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
426    KeyDatV[KeyId].HashCd=TInt(-1);
427  }
428  template<class TKey, class TDat, class THashFunc>
429  int THashGenericMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd) const  {
430    IAssert(! Empty());
431    int KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len()));
432    while (KeyDatV[KeyId].HashCd == -1) { 
433      KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len())); }
434    return KeyId; 
435  }
436  template<class TKey, class TDat, class THashFunc>
437  int THashGenericMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd, const double& EmptyFrac) {
438    IAssert(! Empty());
439    if (FreeKeys/double(Len()+FreeKeys) > EmptyFrac) { Defrag(); }
440    int KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
441    while (KeyDatV[KeyId].HashCd == -1) { 
442      KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
443    }
444    return KeyId;
445  }
446  template<class TKey, class TDat, class THashFunc>
447  int THashGenericMP<TKey, TDat, THashFunc>::GetKeyId(const TKey& Key) const {
448    if (PortV.Empty()){return -1;}
449    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
450    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
451    int KeyId=PortV[PortN];
452    while ((KeyId!=-1) &&
453     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
454      KeyId=KeyDatV[KeyId].Next;}
455    return KeyId;
456  }
457  template<class TKey, class TDat, class THashFunc>
458  bool THashGenericMP<TKey, TDat, THashFunc>::FNextKeyId(int& KeyId) const {
459    do {KeyId++;} while ((KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd==-1));
460    return KeyId<KeyDatV.Len();
461  }
462  template<class TKey, class TDat, class THashFunc>
463  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
464    KeyV.Gen(Len(), 0);
465    int KeyId=FFirstKeyId();
466    while (FNextKeyId(KeyId)){
467      KeyV.Add(GetKey(KeyId));}
468  }
469  template<class TKey, class TDat, class THashFunc>
470  void THashGenericMP<TKey, TDat, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
471    DatV.Gen(Len(), 0);
472    int KeyId=FFirstKeyId();
473    while (FNextKeyId(KeyId)){
474      DatV.Add(GetHashKeyDat(KeyId).Dat);}
475  }
476  template<class TKey, class TDat, class THashFunc>
477  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
478    KeyDatPrV.Gen(Len(), 0);
479    TKey Key; TDat Dat;
480    int KeyId=FFirstKeyId();
481    while (FNextKeyId(KeyId)){
482      GetKeyDat(KeyId, Key, Dat);
483      KeyDatPrV.Add(TPair<TKey, TDat>(Key, Dat));
484    }
485  }
486  template<class TKey, class TDat, class THashFunc>
487  void THashGenericMP<TKey, TDat, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
488    DatKeyPrV.Gen(Len(), 0);
489    TKey Key; TDat Dat;
490    int KeyId=FFirstKeyId();
491    while (FNextKeyId(KeyId)){
492      GetKeyDat(KeyId, Key, Dat);
493      DatKeyPrV.Add(TPair<TDat, TKey>(Dat, Key));
494    }
495  }
496  template<class TKey, class TDat, class THashFunc>
497  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const {
498    KeyDatKdV.Gen(Len(), 0);
499    TKey Key; TDat Dat;
500    int KeyId=FFirstKeyId();
501    while (FNextKeyId(KeyId)){
502      GetKeyDat(KeyId, Key, Dat);
503      KeyDatKdV.Add(TKeyDat<TKey, TDat>(Key, Dat));
504    }
505  }
506  template<class TKey, class TDat, class THashFunc>
507  void THashGenericMP<TKey, TDat, THashFunc>::GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const {
508    DatKeyKdV.Gen(Len(), 0);
509    TKey Key; TDat Dat;
510    int KeyId=FFirstKeyId();
511    while (FNextKeyId(KeyId)){
512      GetKeyDat(KeyId, Key, Dat);
513      DatKeyKdV.Add(TKeyDat<TDat, TKey>(Dat, Key));
514    }
515  }
516  template<class TKey, class TDat, class THashFunc>
517  void THashGenericMP<TKey, TDat, THashFunc>::Swap(THashGenericMP& Hash) {
518    if (this!=&Hash){
519      PortV.Swap(Hash.PortV);
520      KeyDatV.Swap(Hash.KeyDatV);
521      ::Swap(AutoSizeP, Hash.AutoSizeP);
522      ::Swap(FFreeKeyId, Hash.FFreeKeyId);
523      ::Swap(FreeKeys, Hash.FreeKeys);
524    }
525  }
526  template<class TKey, class TDat, class THashFunc>
527  void THashGenericMP<TKey, TDat, THashFunc>::Defrag(){
528    if (!IsKeyIdEqKeyN()){
529      THashGenericMP<TKey, TDat, THashFunc> Hash(PortV.Len());
530      int KeyId=FFirstKeyId(); TKey Key; TDat Dat;
531      while (FNextKeyId(KeyId)){
532        GetKeyDat(KeyId, Key, Dat);
533        Hash.AddDat(Key, Dat);
534      }
535      Pack();
536      operator=(Hash);
537      IAssert(IsKeyIdEqKeyN());
538    }
539  }
540  template<class TKey, class TDat, class THashFunc>
541  void THashGenericMP<TKey, TDat, THashFunc>::Sort(const bool& CmpKey, const bool& Asc) {
542    IAssertR(IsKeyIdEqKeyN(), "THash::Sort only works when table has no deleted keys.");
543    TIntV TargV(Len()), MapV(Len()), StateV(Len());
544    for (int i = 0; i < TargV.Len(); i++) {
545      TargV[i] = i; MapV[i] = i; StateV[i] = i;
546    }
547    THashKeyDatCmp HashCmp(*this, CmpKey, Asc);
548    TargV.SortCmp(HashCmp);
549    THashKeyDat<TKey, TDat> Tmp;
550    for (int i = 0; i < TargV.Len()-1; i++) {
551      const int SrcPos = MapV[TargV[i]];
552      const int Loc = i;
553      Tmp = KeyDatV[SrcPos];
554      KeyDatV[SrcPos] = KeyDatV[Loc];
555      KeyDatV[Loc] = Tmp;
556      MapV[StateV[i]] = SrcPos;
557      StateV.Swap(Loc, SrcPos);
558    }
559    for (int i = 0; i < TargV.Len(); i++) {
560      MapV[TargV[i]] = i; }
561    for (int p = 0; p < PortV.Len(); p++) {
562      if (PortV[p] != -1) {
563        PortV[p] = MapV[PortV[p]]; } }
564    for (int i = 0; i < KeyDatV.Len(); i++) {
565      if (KeyDatV[i].Next != -1) {
566        KeyDatV[i].Next = MapV[KeyDatV[i].Next]; }
567    }
568  }
569  template<class TKey, class TDat, class THashFunc>
570  bool THashGenericMP<TKey, TDat, THashFunc>::AddDatIfNotExist(const TKey& Key, const TDat& Dat) {
571    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
572    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
573    int PrevKeyId=-1;
574    int KeyId;
575    bool done = false;
576    while(!done) {
577      bool port_lock = false;
578      int old;
579      int *ptr = &PortLockV[PortN].Val;
580      old = PortLockV[PortN];
581      if (old == -2) {
582        port_lock = false;
583      }
584      else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
585        port_lock = true;
586      }
587      KeyId = PortV[PortN];
588      while ((KeyId!=-1) &&
589          !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
590        PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
591      if (KeyId==-1) {
592        if (port_lock == false) continue;
593        volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
594        KeyId = __sync_fetch_and_add(p, 1);
595        KeyDatV[KeyId].Next=-1;
596        KeyDatV[KeyId].HashCd=HashCd;
597        KeyDatV[KeyId].Key=Key;
598        int temp;
599        int* pt = &KeyDatV[KeyId].Next.Val;
600        while(true) {
601          temp = KeyDatV[KeyId].Next;
602          if (temp == -2) continue;
603          if (__sync_bool_compare_and_swap(pt, temp, -2)) {
604            KeyDatV[KeyId].Dat = Dat;
605            *pt = temp;
606            done = true;
607            break;
608          }
609        }
610        if (PrevKeyId==-1){
611          PortV[PortN] = KeyId;
612        } else {
613          KeyDatV[PrevKeyId].Next=KeyId;
614        }
615        *ptr = old;
616      }
617      else {
618        if (port_lock) *ptr = old;
619        break;
620      }
621    }
622    return done;
623  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.cpp</h3>
            <pre><code>1  const int TCs::MxMask=0x0FFFFFFF;
2  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
3    TCs Cs;
4    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
5    return Cs;
6  }
7  TStr TSBase::GetSNm() const {
8    return TStr(SNm.CStr());
9  }
10  TSIn::TSIn(const TStr& Str):
11    TSBase(Str.CStr()), FastMode(false){}
12  void TSIn::LoadCs(){
13    TCs CurCs=Cs; TCs TestCs;
14    Cs+=GetBf(&TestCs, sizeof(TestCs));
15    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
16  }
17  void TSIn::Load(char*& CStr){
18    char Ch; Load(Ch);
19    int CStrLen=int(Ch);
20    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
21    CStr=new char[CStrLen+1];
22    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
23    CStr[CStrLen]=TCh::NullCh;
24  }
25  const PSIn TSIn::StdIn=PSIn(new TStdIn());
26  TSOut::TSOut(const TStr& Str):
27    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
28  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
29    int Cs=0;
30    if (MxLnLen!=-1){
31      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
32      LnLen+=StrLen;
33    }
34    return Cs;
35  }
36  int TSOut::PutMem(const TMem& Mem){
37    return PutBf(Mem(), Mem.Len());
38  }
39  int TSOut::PutCh(const char& Ch, const int& Chs){
40    int Cs=0;
41    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
42    return Cs;
43  }
44  int TSOut::PutBool(const bool& Bool){
45    return PutStr(TBool::GetStr(Bool));
46  }
47  int TSOut::PutInt(const int& Int){
48    return PutStr(TInt::GetStr(Int));
49  }
50  int TSOut::PutInt(const int& Int, char* FmtStr){
51    return PutStr(TInt::GetStr(Int, FmtStr));
52  }
53  int TSOut::PutUInt(const uint& UInt){
54    return PutStr(TUInt::GetStr(UInt));
55  }
56  int TSOut::PutUInt(const uint& UInt, char* FmtStr){
57    return PutStr(TUInt::GetStr(UInt, FmtStr));
58  }
59  int TSOut::PutFlt(const double& Flt){
60    return PutStr(TFlt::GetStr(Flt));
61  }
62  int TSOut::PutFlt(const double& Flt, char* FmtStr){
63    return PutStr(TFlt::GetStr(Flt, FmtStr));
64  }
65  int TSOut::PutStr(const char* CStr){
66    int Cs=UpdateLnLen(int(strlen(CStr)));
67    return Cs+PutBf(CStr, int(strlen(CStr)));
68  }
69  int TSOut::PutStr(const TChA& ChA){
70    int Cs=UpdateLnLen(ChA.Len());
71    return Cs+PutBf(ChA.CStr(), ChA.Len());
72  }
73  int TSOut::PutStr(const TStr& Str, char* FmtStr){
74    return PutStr(TStr::GetStr(Str, FmtStr));
75  }
76  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
77    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
78    return Cs+PutBf(Str.CStr(), Str.Len());
79  }
80  int TSOut::PutIndent(const int& IndentLev){
81    return PutCh(' ', IndentLev*2);
82  }
83  int TSOut::PutLn(const int& Lns){
84    LnLen=0; int Cs=0;
85    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
86    return Cs;
87  }
88  int TSOut::PutDosLn(const int& Lns){
89    LnLen=0; int Cs=0;
90    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
91    return Cs;
92  }
93  int TSOut::PutSep(const int& NextStrLen){
94    int Cs=0;
95    if (MxLnLen==-1){
96      Cs+=PutCh(' ');
97    } else {
98      if (LnLen>0){
99        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
100      }
101    }
102    return Cs;
103  }
104  int TSOut::PutSepLn(const int& Lns){
105    int Cs=0;
106    if (LnLen>0){Cs+=PutLn();}
107    Cs+=PutLn(Lns);
108    return Cs;
109  }
110  void TSOut::Save(const char* CStr){
111    int CStrLen=int(strlen(CStr));
112    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
113    Save(char(CStrLen));
114    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
115  }
116  void TSOut::Save(TSIn& SIn, const int& BfL){
117    if (BfL==-1){
118      while (!SIn.Eof()){Save(SIn.GetCh());}
119    } else {
120      for (int BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
121    }
122  }
123  TSOut& TSOut::operator<<(TSIn& SIn) {
124    while (!SIn.Eof())
125      operator<<((char)SIn.GetCh());
126    return *this;
127  }
128  const PSOut TSOut::StdOut=PSOut(new TStdOut());
129  int TStdIn::GetBf(const void* LBf, const int& LBfL){
130    int LBfS=0;
131    for (int LBfC=0; LBfC<LBfL; LBfC++){
132      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
133    return LBfS;
134  }
135  int TStdOut::PutBf(const void* LBf, const int& LBfL){
136    int LBfS=0;
137    for (int LBfC=0; LBfC<LBfL; LBfC++){
138      LBfS+=PutCh(((char*)LBf)[LBfC]);}
139    return LBfS;
140  }
141  const int TFIn::MxBfL=16*1024;
142  void TFIn::SetFPos(const int& FPos) const {
143    EAssertR(
144     fseek(FileId, FPos, SEEK_SET)==0,
145     "Error seeking into file '"+GetSNm()+"'.");
146  }
147  int TFIn::GetFPos() const {
148    const int FPos=ftell(FileId);
149    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
150    return FPos;
151  }
<span onclick='openModal()' class='match'>152  int TFIn::GetFLen() const {
153    const int FPos=GetFPos();
154    EAssertR(
155     fseek(FileId, 0, SEEK_END)==0,
156     "Error seeking into file '"+GetSNm()+"'.");
157    const int FLen=GetFPos(); SetFPos(FPos);
</span>158    return FLen;
159  }
160  void TFIn::FillBf(){
161    EAssertR(
162     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
163     "Error reading file '"+GetSNm()+"'.");
164    BfL=int(fread(Bf, 1, MxBfL, FileId));
165    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
166    BfC=0;
167  }
168  TFIn::TFIn(const TStr& FNm):
169    TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
170    EAssertR(!FNm.Empty(), "Empty file-name.");
171    FileId=fopen(FNm.CStr(), "rb");
172    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
173    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
174  }
175  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
176    TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
177    EAssertR(!FNm.Empty(), "Empty file-name.");
178    FileId=fopen(FNm.CStr(), "rb");
179    OpenedP=(FileId!=NULL);
180    if (OpenedP){
181      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
182  }
183  PSIn TFIn::New(const TStr& FNm){
184    return PSIn(new TFIn(FNm));
185  }
186  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
187    return PSIn(new TFIn(FNm, OpenedP));
188  }
189  TFIn::~TFIn(){
190    if (FileId!=NULL){
191      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
192    if (Bf!=NULL){delete[] Bf;}
193  }
194  int TFIn::GetBf(const void* LBf, const int& LBfL){
195    int LBfS=0;
196    if (BfC+LBfL>BfL){
197      for (int LBfC=0; LBfC<LBfL; LBfC++){
198        if (BfC==BfL){FillBf();}
199        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
200    } else {
201      for (int LBfC=0; LBfC<LBfL; LBfC++){
202        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
203    }
204    return LBfS;
205  }
206  const int TFOut::MxBfL=16*1024;;
207  void TFOut::FlushBf(){
208    EAssertR(
209     (int)fwrite(Bf, 1, BfL, FileId)==BfL,
210     "Error writting to the file '"+GetSNm()+"'.");
211    BfL=0;
212  }
213  TFOut::TFOut(const TStr& FNm, const bool& Append):
214    TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
215    if (FNm.GetUc()=="CON"){
216      FileId=stdout;
217    } else {
218      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
219      else {FileId=fopen(FNm.CStr(), "w+b");}
220      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
221      Bf=new char[MxBfL]; BfL=0;
222    }
223  }
224  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
225    TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
226    if (FNm.GetUc()=="CON"){
227      FileId=stdout;
228    } else {
229      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
230      else {FileId=fopen(FNm.CStr(), "w+b");}
231      OpenedP=(FileId!=NULL);
232      if (OpenedP){
233        Bf=new char[MxBfL]; BfL=0;}
234    }
235  }
236  PSOut TFOut::New(const TStr& FNm, const bool& Append){
237    return PSOut(new TFOut(FNm, Append));
238  }
239  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
240    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
241    if (OpenedP){return SOut;} else {return NULL;}
242  }
243  TFOut::~TFOut(){
244    if (FileId!=NULL){FlushBf();}
245    if (Bf!=NULL){delete[] Bf;}
246    if (FileId!=NULL){
247      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
248  }
249  int TFOut::PutCh(const char& Ch){
250    if (BfL==MxBfL){FlushBf();}
251    return Bf[BfL++]=Ch;
252  }
253  int TFOut::PutBf(const void* LBf, const int& LBfL){
254    int LBfS=0;
255    if (BfL+LBfL>MxBfL){
256      for (int LBfC=0; LBfC<LBfL; LBfC++){
257        LBfS+=PutCh(((char*)LBf)[LBfC]);}
258    } else {
259      for (int LBfC=0; LBfC<LBfL; LBfC++){
260        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
261    }
262    return LBfS;
263  }
264  void TFOut::Flush(){
265    FlushBf();
266    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
267  }
268  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
269   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
270    switch (FAccess){
271      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
272      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
273      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
274        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
275      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
276      default: Fail;
277    }
278    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
279    IAssert(FileId!=NULL);
280  }
281  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
282    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
283  }
284  int TFInOut::GetSize() const {
285    const int FPos = GetPos();
286    IAssert(fseek(FileId, 0, SEEK_END) == 0);
287    const int FLen = GetPos();
288    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
289    return FLen;
290  }
291  int TFInOut::PutBf(const void* LBf, const int& LBfL) {
292    int LBfS = 0;
293    for (int i = 0; i < LBfL; i++) {
294      LBfS += ((char *)LBf)[i];
295    }
296    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
297    return LBfS;;
298  }
299  int TFInOut::GetBf(const void* LBf, const int& LBfL) {
300    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
301    int LBfS = 0;
302    for (int i = 0; i < LBfL; i++) {
303      LBfS += ((char *)LBf)[i];
304    }
305    return LBfS;
306  }
307  TStr TFInOut::GetFNm() const {
308    return GetSNm();
309  }
310  TMIn::TMIn(const void* _Bf, const int& _BfL, const bool& TakeBf, const bool& _Free):
311    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), Free(_Free){
312    if (TakeBf){
313      Bf=(char*)_Bf;
314    } else {
315      Bf=new char[BfL]; memmove(Bf, _Bf, BfL);
316    }
317  }
318  TMIn::TMIn(TSIn& SIn):
319    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
320    BfL=SIn.Len(); Bf=new char[BfL];
321    for (int BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
322  }
323  TMIn::TMIn(const char* CStr):
324    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
325    BfL=int(strlen(CStr)); Bf=new char[BfL+1]; strcpy(Bf, CStr);
326  }
327  TMIn::TMIn(const TStr& Str):
328    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
329    BfL=Str.Len(); Bf=new char[BfL]; strncpy(Bf, Str.CStr(), BfL);
330  }
331  TMIn::TMIn(const TChA& ChA):
332    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
333    BfL=ChA.Len(); Bf=new char[BfL]; strncpy(Bf, ChA.CStr(), BfL);
334  }
335  PSIn TMIn::New(const char* CStr){
336    return PSIn(new TMIn(CStr));
337  }
338  PSIn TMIn::New(const TStr& Str){
339    return PSIn(new TMIn(Str));
340  }
341  PSIn TMIn::New(const TChA& ChA){
342    return PSIn(new TMIn(ChA));
343  }
344  char TMIn::GetCh(){
345    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
346    return Bf[BfC++];
347  }
348  char TMIn::PeekCh(){
349    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
350    return Bf[BfC];
351  }
352  int TMIn::GetBf(const void* LBf, const int& LBfL){
353    EAssertR(BfC+LBfL<=BfL, "Reading beyond the end of stream.");
354    int LBfS=0;
355    for (int LBfC=0; LBfC<LBfL; LBfC++){
356      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
357    return LBfS;
358  }
359  void TMOut::Resize(){
360    IAssert(OwnBf&&(BfL==MxBfL));
361    if (Bf==NULL){
362      IAssert(MxBfL==0); Bf=new char[MxBfL=1024];
363    } else {
364      MxBfL*=2; char* NewBf=new char[MxBfL];
365      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
366    }
367  }
368  TMOut::TMOut(const int& _MxBfL):
369    TSOut("Output-Memory"),
370    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
371    MxBfL=_MxBfL>0?_MxBfL:1024;
372    Bf=new char[MxBfL];
373  }
374  TMOut::TMOut(char* _Bf, const int& _MxBfL):
375    TSOut("Output-Memory"),
376    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
377  int TMOut::PutBf(const void* LBf, const int& LBfL){
378    int LBfS=0;
379    if (BfL+LBfL>MxBfL){
380      for (int LBfC=0; LBfC<LBfL; LBfC++){
381        LBfS+=PutCh(((char*)LBf)[LBfC]);}
382    } else {
383      for (int LBfC=0; LBfC<LBfL; LBfC++){
384        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
385    }
386    return LBfS;
387  }
388  TStr TMOut::GetAsStr() const {
389    TChA ChA(BfL);
390    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
391    return ChA;
392  }
393  void TMOut::CutBf(const int& CutBfL){
394    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
395    if (CutBfL==BfL){BfL=0;}
396    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
397  }
398  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
399    IAssert((CutBfL==-1)||((0<=CutBfL)));
400    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
401    PSIn SIn;
402    if (OwnBf&&IsCut&&(SInBfL==BfL)){
403      SIn=PSIn(new TMIn(Bf, SInBfL, true));
404      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
405    } else {
406      SIn=PSIn(new TMIn(Bf, SInBfL, false));
407      if (IsCut){CutBf(SInBfL);}
408    }
409    return SIn;
410  }
411  bool TMOut::IsCrLfLn() const {
412    for (int BfC=0; BfC<BfL; BfC++){
413      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
414    return false;
415  }
416  TStr TMOut::GetCrLfLn(){
417    IAssert(IsCrLfLn());
418    TChA Ln;
419    for (int BfC=0; BfC<BfL; BfC++){
420      char Ch=Bf[BfC];
421      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
422        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
423      } else {
424        Ln+=Ch;
425      }
426    }
427    return Ln;
428  }
429  bool TMOut::IsEolnLn() const {
430    for (int BfC=0; BfC<BfL; BfC++){
431      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
432    }
433    return false;
434  }
435  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
436    IAssert(IsEolnLn());
437    int LnChs=0; TChA Ln;
438    for (int BfC=0; BfC<BfL; BfC++){
439      char Ch=Bf[BfC];
440      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
441        LnChs++; if (DoAddEoln){Ln+=Ch;}
442        if (BfC+1<BfL){
443          char NextCh=Bf[BfC+1];
444          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
445           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
446            LnChs++; if (DoAddEoln){Ln+=NextCh;}
447          }
448        }
449        break;
450      } else {
451        LnChs++; Ln+=Ch;
452      }
453    }
454    if (DoCutBf){
455      CutBf(LnChs);
456    }
457    return Ln;
458  }
459  void TMOut::MkEolnLn(){
460    if (!IsEolnLn()){
461      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
462  }
463  #ifndef SEEK_SET
464  #define SEEK_CUR    1
465  #define SEEK_END    2
466  #define SEEK_SET    0
467  #endif
468  void TFRnd::RefreshFPos(){
469    EAssertR(
470     fseek(FileId, 0, SEEK_CUR)==0,
471     "Error seeking into file '"+FNm+"'.");
472  }
473  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
474   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
475    FileId(NULL), FNm(_FNm.CStr()),
476    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
477    RecAct=(HdLen>=0)&&(RecLen>0);
478    switch (FAccess){
479      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
480      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
481      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
482        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
483      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
484      default: Fail;
485    }
486    if ((FileId==NULL)&&(CreateIfNo)){
487      FileId=fopen(FNm.CStr(), "w+b");}
488    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
489  }
490  TFRnd::~TFRnd(){
491    EAssertR(fclose(FileId)==0, "Can not close file '"+FNm+"'.");
492  }
493  TStr TFRnd::GetFNm() const {
494    return FNm.CStr();
495  }
496  void TFRnd::SetFPos(const int& FPos){
497    EAssertR(
498     fseek(FileId, FPos, SEEK_SET)==0,
499     "Error seeking into file '"+FNm+"'.");
500  }
501  void TFRnd::MoveFPos(const int& DFPos){
502    EAssertR(
503     fseek(FileId, DFPos, SEEK_CUR)==0,
504     "Error seeking into file '"+FNm+"'.");
505  }
506  int TFRnd::GetFPos(){
507    int FPos=ftell(FileId);
508    EAssertR(FPos!=-1, "Error seeking into file '"+FNm+"'.");
509    return FPos;
510  }
511  int TFRnd::GetFLen(){
512    int FPos=GetFPos();
513    EAssertR(
514     fseek(FileId, 0, SEEK_END)==0,
515     "Error seeking into file '"+FNm+"'.");
516    int FLen=GetFPos(); SetFPos(FPos); return FLen;
517  }
518  void TFRnd::SetRecN(const int& RecN){
519    IAssert(RecAct);
520    SetFPos(HdLen+RecN*RecLen);
521  }
522  int TFRnd::GetRecN(){
523    IAssert(RecAct);
524    int FPos=GetFPos()-HdLen;
525    EAssertR(FPos%RecLen==0, "Invalid position in file'"+FNm+"'.");
526    return FPos/RecLen;
527  }
528  int TFRnd::GetRecs(){
529    IAssert(RecAct);
530    int FLen=GetFLen()-HdLen;
531    EAssertR(FLen%RecLen==0, "Invalid length of file'"+FNm+"'.");
532    return FLen/RecLen;
533  }
534  void TFRnd::GetBf(void* Bf, const int& BfL){
535    RefreshFPos();
536    EAssertR(
537     int(fread(Bf, 1, BfL, FileId))==BfL,
538     "Error reading file '"+FNm+"'.");
539  }
540  void TFRnd::PutBf(const void* Bf, const int& BfL){
541    RefreshFPos();
542    EAssertR(
543     int(fwrite(Bf, 1, BfL, FileId))==BfL,
544     "Error writting to the file '"+FNm+"'.");
545  }
546  void TFRnd::Flush(){
547    EAssertR(fflush(FileId)==0, "Can not flush file '"+FNm+"'.");
548  }
549  void TFRnd::PutCh(const char& Ch, const int& Chs){
550    if (Chs>0){
551      char* CStr=new char[Chs];
552      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
553      PutBf(CStr, Chs);
554      delete[] CStr;
555    }
556  }
557  void TFRnd::PutStr(const TStr& Str){
558    PutBf(Str.CStr(), Str.Len()+1);
559  }
560  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
561    IsOk=false; TStr Str;
562    if (GetFPos()+StrLen+1<=GetFLen()){
563      char* CStr=new char[StrLen+1];
564      GetBf(CStr, StrLen+1);
565      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
566      delete[] CStr;
567    }
568    return Str;
569  }
570  TStr TFRnd::GetStr(const int& StrLen){
571    TStr Str;
572    char* CStr=new char[StrLen+1];
573    GetBf(CStr, StrLen+1);
574    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+FNm+"'.");
575    Str=CStr;
576    delete[] CStr;
577    return Str;
578  }
579  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
580    int BfL=SIn->Len();
581    char* Bf=new char[BfL];
582    SIn->GetBf(Bf, BfL);
583    Cs=TCs::GetCsFromBf(Bf, BfL);
584    PutBf(Bf, BfL);
585    delete[] Bf;
586  }
587  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
588    char* Bf=new char[BfL];
589    GetBf(Bf, BfL);
590    Cs=TCs::GetCsFromBf(Bf, BfL);
591    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
592    return SIn;
593  }
594  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
595    switch (FAccess){
596      case faCreate: return "Create";
597      case faUpdate: return "Update";
598      case faAppend: return "Append";
599      case faRdOnly: return "ReadOnly";
600      case faRestore: return "Restore";
601      default: Fail; return TStr();
602    }
603  }
604  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
605    TStr UcStr=Str.GetUc();
606    if (UcStr=="CREATE"){return faCreate;}
607    if (UcStr=="UPDATE"){return faUpdate;}
608    if (UcStr=="APPEND"){return faAppend;}
609    if (UcStr=="READONLY"){return faRdOnly;}
610    if (UcStr=="RESTORE"){return faRestore;}
611    if (UcStr=="NEW"){return faCreate;}
612    if (UcStr=="CONT"){return faUpdate;}
613    if (UcStr=="CONTINUE"){return faUpdate;}
614    if (UcStr=="REST"){return faRestore;}
615    if (UcStr=="RESTORE"){return faRestore;}
616    return faUndef;
617  }
618  const TStr TFile::TxtFExt=".Txt";
619  const TStr TFile::HtmlFExt=".Html";
620  const TStr TFile::HtmFExt=".Htm";
621  const TStr TFile::GifFExt=".Gif";
622  const TStr TFile::JarFExt=".Jar";
623  bool TFile::Exists(const TStr& FNm){
624    bool DoExists;
625    TFIn FIn(FNm, DoExists);
626    return DoExists;
627  }
628  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
629    if (ThrowExceptP){
630      EAssertR(
631       remove(FNm.CStr())==0,
632       "Error removing file '"+FNm+"'.");
633    } else {
634      remove(FNm.CStr());
635    }
636  }
637  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
638    TStrV FNmV;
639    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
640    while (FFile.Next(FNm)){
641      FNmV.Add(FNm);}
642    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
643      Del(FNmV[FNmN], false);}
644  }
645  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
646    EAssertR(
647     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
648     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
649  }
650  TStr TFile::GetUniqueFNm(const TStr& FNm){
651    int Cnt=1; int ch;
652    TStr NewFNm; TStr TmpFNm=FNm;
653    if (FNm.SearchCh('#') == -1) {
654      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
655      if (ch != -1) TmpFNm.InsStr(ch, ".#");
656      else TmpFNm += ".#";
657    }
658    forever{
659      NewFNm=TmpFNm;
660      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
661      if (!TFile::Exists(NewFNm)){break;}
662    }
663    return NewFNm;
664  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashgenericmp.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>326  int THashGenericMP<TKey, TDat, THashFunc>::AddKey(const TKey& Key){
327    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
328    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
</pre></code></div>
                <div class="column column_space"><pre><code>152  int TFIn::GetFLen() const {
153    const int FPos=GetFPos();
154    EAssertR(
155     fseek(FileId, 0, SEEK_END)==0,
156     "Error seeking into file '"+GetSNm()+"'.");
157    const int FLen=GetFPos(); SetFPos(FPos);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    