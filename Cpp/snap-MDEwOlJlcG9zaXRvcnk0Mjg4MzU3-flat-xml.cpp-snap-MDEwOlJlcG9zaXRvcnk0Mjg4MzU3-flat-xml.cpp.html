
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.cpp</h3>
            <pre><code>1  TStrStrH TXmlObjSer::TypeNmToTagNmH;
2  TStr TXmlObjSer::GetTagNm(const TStr& TypeNm){
3    TStr& XmlTagNm=TypeNmToTagNmH.AddDat(TypeNm);
4    if (XmlTagNm.Empty()){
5      TChA XmlTagChA=TypeNm;
6      for (int ChN=0; ChN<XmlTagChA.Len(); ChN++){
7        char Ch=XmlTagChA[ChN];
8        if (!((('A'<=Ch)&&(Ch<='Z'))||(('a'<=Ch)&&(Ch<='z'))||(('0'<=Ch)&&(Ch<='9')))){
9          XmlTagChA.PutCh(ChN, '_');
10        }
11      }
12      while ((XmlTagChA.Len()>0)&&(XmlTagChA.LastCh()=='_')){
13        XmlTagChA.Pop();}
14      XmlTagNm=XmlTagChA;
15    }
16    return XmlTagNm;
17  }
18  void TXmlObjSer::AssertXmlHd(
19   const PXmlTok& XmlTok, const TStr& Nm, const TStr& TypeNm){
20    EAssertR(!XmlTok.Empty(), "Xml-Token Empty");
21    if (!Nm.Empty()){
22      if (!XmlTok->IsTag()){
23        TStr ArgStr1="Expected: Tag";
24        TStr ArgStr2=TStr("Found: ")+XmlTok->GetSymStr();
25        TExcept::Throw("Invalid Xml-Token", ArgStr1, ArgStr2);
26      }
27      if (Nm!="-"){
28        if (!XmlTok->IsTag(Nm)){
29          TStr ArgStr1=TStr("Expected: ")+Nm;
30          TStr ArgStr2=TStr("Found: ")+XmlTok->GetStr();
31          TExcept::Throw("Invalid Xml-Tag", ArgStr1, ArgStr2);
32        }
33        TStr TypeArgVal=XmlTok->GetStrArgVal("Type");
34        if (TypeArgVal!=TypeNm){
35          TStr ArgStr1=TStr("Expected: ")+TypeNm;
36          TStr ArgStr2=TStr("Found: ")+TypeArgVal;
37          TExcept::Throw("Invalid Xml-Type", ArgStr1, ArgStr2);
38        }
39      }
40    } else {
41      if (!XmlTok->IsTag(TypeNm)){
42        TStr ArgStr1=TStr("Expected: ")+TypeNm;
43        TStr ArgStr2=TStr("Found: ")+XmlTok->GetSymStr();
44        TExcept::Throw("Invalid Xml-Type-Tag", ArgStr1, ArgStr2);
45      }
46    }
47  }
48  bool TXmlObjSer::GetBoolArg(const PXmlTok& XmlTok, const TStr& Nm){
49    TStr ValStr;
50    if (XmlTok->IsArg(Nm, ValStr)){
51      bool Val;
52      if (ValStr.IsBool(Val)){
53        return Val;
54      } else {
55        TExcept::Throw("Invalid Xml-Argument Boolean-Value", Nm, ValStr);
56      }
57    } else {
58      TExcept::Throw("Xml-Argument Missing", Nm);
59    }
60    Fail; return 0;
61  }
62  int TXmlObjSer::GetIntArg(const PXmlTok& XmlTok, const TStr& Nm){
63    TStr ValStr;
64    if (XmlTok->IsArg(Nm, ValStr)){
65      int Val;
66      if (ValStr.IsInt(Val)){
67        return Val;
68      } else {
69        TExcept::Throw("Invalid Xml-Argument Integer-Value", Nm, ValStr);
70      }
71    } else {
72      TExcept::Throw("Xml-Argument Missing", Nm);
73    }
74    Fail; return 0;
75  }
76  int64 TXmlObjSer::GetInt64Arg(const PXmlTok& XmlTok, const TStr& Nm){
77    TStr ValStr;
78    if (XmlTok->IsArg(Nm, ValStr)){
79      int64 Val;
80      if (ValStr.IsInt64(Val)){
81        return Val;
82      } else {
83        TExcept::Throw("Invalid Xml-Argument Integer64-Value", Nm, ValStr);
84      }
85    } else {
86      TExcept::Throw("Xml-Argument Missing", Nm);
87    }
88    Fail; return 0;
89  }
90  double TXmlObjSer::GetFltArg(const PXmlTok& XmlTok, const TStr& Nm){
91    TStr ValStr;
92    if (XmlTok->IsArg(Nm, ValStr)){
93      double Val;
94      if (ValStr.IsFlt(Val)){
95        return Val;
96      } else {
97        TExcept::Throw("Invalid Xml-Argument Double-Value", Nm, ValStr);
98      }
99    } else {
100      TExcept::Throw("Xml-Argument Missing", Nm);
101    }
102    Fail; return 0;
103  }
104  TXmlObjSerTagNm::TXmlObjSerTagNm(
105   TSOut& _SOut, const bool& ETagP,
106   const TStr& Nm, const TStr& TypeNm,
107   const TStr& ArgNm, const TStr& ArgVal):
108    TagNm(), SOut(&_SOut){
109    if (Nm!="-"){
110      SOut->PutCh('<');
111      if (Nm.Empty()){
112        SOut->PutStr(TagNm=TypeNm);
113      } else {
114        SOut->PutStr(TagNm=Nm);
115        SOut->PutStr(" Type=\""); SOut->PutStr(TypeNm); SOut->PutCh('"');
116      }
117      if (!ArgNm.Empty()){
118        SOut->PutCh(' '); SOut->PutStr(ArgNm); SOut->PutCh('=');
119        SOut->PutCh('"'); SOut->PutStr(ArgVal); SOut->PutCh('"');
120      }
121      if (ETagP){
122        SOut->PutCh('/'); TagNm="";}
123      SOut->PutCh('>');
124    }
125  }
126  TXmlObjSerTagNm::TXmlObjSerTagNm(
127   TSOut& _SOut, const bool& ETagP,
128   const TStr& Nm, const TStr& TypeNm,
129   const TStr& ArgNm1, const TStr& ArgVal1,
130   const TStr& ArgNm2, const TStr& ArgVal2,
131   const TStr& ArgNm3, const TStr& ArgVal3,
132   const TStr& ArgNm4, const TStr& ArgVal4):
133    TagNm(), SOut(&_SOut){
134    if (Nm!="-"){
135      SOut->PutCh('<');
136      if (Nm.Empty()){
137        SOut->PutStr(TagNm=TypeNm);
138      } else {
139        SOut->PutStr(TagNm=Nm);
140        SOut->PutStr(" Type=\""); SOut->PutStr(TypeNm); SOut->PutCh('"');
141      }
142      if (!ArgNm1.Empty()){
143        SOut->PutCh(' '); SOut->PutStr(ArgNm1); SOut->PutCh('=');
144        SOut->PutCh('"'); SOut->PutStr(ArgVal1); SOut->PutCh('"');
145      }
146      if (!ArgNm2.Empty()){
147        SOut->PutCh(' '); SOut->PutStr(ArgNm2); SOut->PutCh('=');
148        SOut->PutCh('"'); SOut->PutStr(ArgVal2); SOut->PutCh('"');
149      }
150      if (!ArgNm3.Empty()){
151        SOut->PutCh(' '); SOut->PutStr(ArgNm3); SOut->PutCh('=');
152        SOut->PutCh('"'); SOut->PutStr(ArgVal3); SOut->PutCh('"');
153      }
154      if (!ArgNm4.Empty()){
155        SOut->PutCh(' '); SOut->PutStr(ArgNm4); SOut->PutCh('=');
156        SOut->PutCh('"'); SOut->PutStr(ArgVal4); SOut->PutCh('"');
157      }
158      if (ETagP){
159        SOut->PutCh('/'); TagNm="";}
160      SOut->PutCh('>');
161    }
162  }
163  TXmlObjSerTagNm::~TXmlObjSerTagNm(){
164    if (!TagNm.Empty()){
165      SOut->PutCh('<'); SOut->PutCh('/'); SOut->PutStr(TagNm); SOut->PutCh('>');
166    }
167  }
168  void TXmlChDef::SetChTy(TBSet& ChSet, const int& MnCh, const int& MxCh){
169    IAssert((0<=MnCh)&&((MxCh==-1)||((MnCh<=MxCh)&&(MxCh<Chs))));
170    ChSet.Incl(MnCh);
171    for (int Ch=MnCh+1; Ch<=MxCh; Ch++){
172      ChSet.Incl(Ch);}
173  }
174  void TXmlChDef::SetChTy(TBSet& ChSet, const TStr& Str){
175    for (int ChN=0; ChN<Str.Len(); ChN++){
176      uchar Ch=Str[ChN];
177      ChSet.Incl(Ch);
178    }
179  }
180  void TXmlChDef::SetEntityVal(const TStr& Nm, const TStr& Val){
181    EntityNmToValH.AddDat(Nm, Val);
182  }
183  TXmlChDef::TXmlChDef():
184    Chs(TUCh::Vals),
185    CharChSet(), CombChSet(), ExtChSet(),
186    LetterChSet(), DigitChSet(), NameChSet(), PubidChSet(),
187    EntityNmToValH(100){
188    CharChSet.Gen(Chs);
189    SetChTy(CharChSet, 0x1); SetChTy(CharChSet, 0x3); SetChTy(CharChSet, 0x6);
190    SetChTy(CharChSet, 11); SetChTy(CharChSet, 24); SetChTy(CharChSet, 27);
191    SetChTy(CharChSet, 0x9); SetChTy(CharChSet, 0xA); SetChTy(CharChSet, 0xD);
192    SetChTy(CharChSet, 0x20, TUCh::Mx);
193    TBSet BaseChSet(Chs);
194    SetChTy(BaseChSet, 0x41, 0x5A); SetChTy(BaseChSet, 0x61, 0x7A);
195    SetChTy(BaseChSet, 0xC0, 0xD6); SetChTy(BaseChSet, 0xD8, 0xF6);
196    SetChTy(BaseChSet, 0xF8, 0xFF);
197    TBSet IdeoChSet(Chs);
198    CombChSet.Gen(Chs);
199    ExtChSet.Gen(Chs);
200    SetChTy(ExtChSet, 0xB7);
201    LetterChSet=BaseChSet|IdeoChSet;
202    DigitChSet.Gen(Chs);
203    SetChTy(DigitChSet, 0x30, 0x39);
204    NameChSet=LetterChSet|DigitChSet|
205     uchar('.')|uchar('-')|uchar('_')|uchar(':')|CombChSet;
206    PubidChSet.Gen(Chs);
207    SetChTy(PubidChSet, 0x20); SetChTy(PubidChSet, 0xD); SetChTy(PubidChSet, 0xA);
208    SetChTy(PubidChSet, 'a', 'z'); SetChTy(PubidChSet, 'A', 'Z');
209    SetChTy(PubidChSet, '0', '9'); SetChTy(PubidChSet, "-'()+,./:=?;!*#@$_%");
210    SetEntityVal("amp", "&");
211    SetEntityVal("lt", "<"); SetEntityVal("gt", ">");
212    SetEntityVal("apos", "'"); SetEntityVal("quot", "\"");
213  }
214  TXmlChDef TXmlLx::ChDef;
215  uchar TXmlLx::GetCh(){
216    EAssert(Ch!=TCh::EofCh);
217    PrevCh=Ch;
218    if (ChStack.Empty()){Ch=(RSIn.Eof()) ? TCh::EofCh : RSIn.GetCh();}
219    else {Ch=ChStack.Pop();}
220    ChN++; if (Ch==TCh::LfCh){LnN++; LnChN=0;} else {LnChN++;}
221    return Ch;
222  }
223  void TXmlLx::ToNrSpacing(){
224    if (Spacing==xspIntact){
225    } else
226    if (Spacing==xspPreserve){
227      int SrcChN=0; int DstChN=0;
228      while (SrcChN<TxtChA.Len()){
229        if (TxtChA[SrcChN]==TCh::CrCh){
230          TxtChA.PutCh(DstChN, TCh::LfCh); SrcChN++; DstChN++;
231          if ((SrcChN<TxtChA.Len())&&(TxtChA[SrcChN]==TCh::LfCh)){SrcChN++;}
232        } else {
233          if (SrcChN!=DstChN){
234            TxtChA.PutCh(DstChN, TxtChA[SrcChN]);}
235          SrcChN++; DstChN++;
236        }
237      }
238      TxtChA.Trunc(DstChN);
239    } else
240    if (Spacing==xspSeparate){
241      int SrcChN=0; int DstChN=0;
242      while (SrcChN<TxtChA.Len()){
243        if (ChDef.IsWs(TxtChA[SrcChN])){
244          if ((DstChN>0)&&(TxtChA[DstChN-1]==' ')){
245            SrcChN++;
246          } else {
247            TxtChA.PutCh(DstChN, ' ');
248            SrcChN++; DstChN++;
249          }
250        } else {
251          TxtChA.PutCh(DstChN, TxtChA[SrcChN]);
252          SrcChN++; DstChN++;
253        }
254      }
255      TxtChA.Trunc(DstChN);
256    } else
257    if (Spacing==xspTruncate){
258      int SrcChN=0; int DstChN=0;
259      while (SrcChN<TxtChA.Len()){
260        if (ChDef.IsWs(TxtChA[SrcChN])){
261          if ((DstChN>0)&&(TxtChA[DstChN-1]==' ')){
262            SrcChN++;
263          } else {
264            TxtChA.PutCh(DstChN, ' ');
265            SrcChN++; DstChN++;
266          }
267        } else {
268          TxtChA.PutCh(DstChN, TxtChA[SrcChN]);
269          SrcChN++; DstChN++;
270        }
271      }
272      TxtChA.Trunc(DstChN);
273      while ((TxtChA.Len()>0)&&(ChDef.IsWs(TxtChA.LastCh()))){
274        TxtChA.Pop();}
275    } else {
276      Fail;
277    }
278  }
279  void TXmlLx::GetWs(const bool& IsRq){
280    int WSpaces=0; TxtChA.Clr();
281    while (ChDef.IsWs(Ch)){
282      WSpaces++; TxtChA+=Ch; GetCh();}
283    if (IsRq&&(WSpaces==0)){
284      EThrow("White-space required.");}
285  }
286  TStr TXmlLx::GetReference(){
287    if (Ch=='#'){
288      TChA RefChA; int RefCd=0;
289      if (GetCh()=='x'){
290        forever {
291          GetCh();
292          if (TCh::IsHex(Ch)){
293            RefChA+=Ch;
294            RefCd=RefCd*16+TCh::GetHex(Ch);
295          } else {
296            break;
297          }
298        }
299      } else {
300        forever {
301          if (TCh::IsNum(Ch)){
302            RefChA+=Ch;
303            RefCd=RefCd*10+TCh::GetNum(Ch);
304          } else {
305            break;
306          }
307          GetCh();
308        }
309      }
310      if ((!RefChA.Empty())&&(Ch==';')){
311        GetCh();
312  	  if (RefCd < 0x80) {
313  	      uchar RefCh=uchar(RefCd);
314  		  return TStr(RefCh);
315  	  } else {
316  		  TStr ResStr = TUnicode::EncodeUtf8(RefCd);
317  		  return ResStr;
318  	  }
319      } else {
320        EThrow("Invalid Char-Reference."); Fail; return TStr();
321      }
322    } else {
323      TStr EntityNm=GetName();
324      if ((!EntityNm.Empty())&&(Ch==';')){
325        GetCh();
326        TStr EntityVal;
327        if (IsEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
328        else if (ChDef.IsEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
329        else {EThrow(TStr("Entity-Reference (")+EntityNm+") does not exist.");}
330        return EntityVal;
331      } else {
332        EThrow("Invalid Entity-Reference."); Fail; return TStr();
333      }
334    }
335  }
336  TStr TXmlLx::GetPEReference(){
337    TStr EntityNm=GetName();
338    if ((EntityNm.Empty())||(Ch!=';')){EThrow("Invalid PEntity-Reference.");}
339    GetCh();
340    TStr EntityVal;
341    if (IsPEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
342    else {EThrow(TStr("PEntity-Reference (")+EntityNm+") does not exist.");}
343    return EntityVal;
344  }
345  void TXmlLx::GetEq(){
346    GetWs(false);
347    if (Ch=='='){GetCh();}
348    else {EThrow("Equality ('=') character expected.");}
349    GetWs(false);
350  }
351  TStr TXmlLx::GetName(){
352    TChA NmChA;
353    if (ChDef.IsFirstNameCh(Ch)){
354      do {NmChA+=Ch;} while (ChDef.IsName(GetCh()));
355    } else {
356      EThrow("Invalid first name character.");
357    }
358    return NmChA;
359  }
360  TStr TXmlLx::GetName(const TStr& RqNm){
361    TStr Nm=GetName();
362    if (Nm==RqNm){return RqNm;}
363    else {EThrow(TStr("Name '")+RqNm+"' expected."); Fail; return TStr();}
364  }
365  void TXmlLx::GetComment(){
366    if (GetCh()!='-'){EThrow("Invalid comment start.");}
367    TxtChA.Clr();
368    forever {
369      GetCh();
370      if (!ChDef.IsChar(Ch)){EThrow("Invalid comment character.");}
371      if (Ch=='-'){
372        if (GetCh()=='-'){
373          if (GetCh()=='>'){GetCh(); break;} 
374          else {EThrow("Invalid comment end.");}
375        } else {
376          if (!ChDef.IsChar(Ch)){EThrow("Invalid comment character.");}
377          TxtChA+='-'; TxtChA+=Ch; 
378        }
379      } else {
380        TxtChA+=Ch; 
381      }
382    }
383  }
384  TStr TXmlLx::GetAttValue(){
385    uchar QCh=Ch;
386    if ((QCh!='"')&&(QCh!='\'')){EThrow("Invalid attribute-value start.");}
387    TChA ValChA; GetCh();
388    forever {
389      if ((Ch=='<')||(!ChDef.IsChar(Ch))){
390        EThrow("Invalid attribute-value character.");}
391      if (Ch==QCh){GetCh(); break;} 
392      else if (Ch=='&'){GetCh(); ValChA+=GetReference();} 
393      else {ValChA+=Ch; GetCh();} 
394    }
395    return ValChA;
396  }
397  TStr TXmlLx::GetVersionNum(){
398    char QCh=Ch;
399    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
400    TChA VerNumChA;
401    GetCh();
402    do {
403      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))||
404       (('0'<=Ch)&&(Ch<='9'))||(Ch=='_')||(Ch=='.')||(Ch==':')||(Ch=='-')){
405        VerNumChA+=Ch;
406      } else {
407        EThrow("Invalid version-number character.");
408      }
409      GetCh();
410    } while (Ch!=QCh);
411    GetCh();
412    return VerNumChA;
413  }
414  TStr TXmlLx::GetEncName(){
415    char QCh=Ch;
416    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
417    TChA EncNmChA;
418    GetCh();
419    if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))){EncNmChA+=Ch;}
420    else {EThrow("Invalid encoding-name character.");}
421    GetCh();
422    while (Ch!=QCh){
423      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))||
424       (('0'<=Ch)&&(Ch<='9'))||(Ch=='.')||(Ch=='_')||(Ch=='-')){EncNmChA+=Ch;}
425      else {EThrow("Invalid version-number character.");}
426      GetCh();
427    }
428    GetCh();
429    return EncNmChA;
430  }
431  TStr TXmlLx::GetStalVal(){
432    char QCh=Ch;
433    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
434    TChA StalChA;
435    GetCh();
436    while (Ch!=QCh){
437      if (('a'<=Ch)&&(Ch<='z')){StalChA+=Ch;}
438      else {EThrow("Invalid standalone-value character.");}
439      GetCh();
440    }
441    GetCh();
442    TStr StalVal=StalChA;
443    if ((StalVal=="yes")||(StalVal=="no")){return StalVal;}
444    else {EThrow("Invalid standalone-value."); Fail; return TStr();}
445  }
446  void TXmlLx::GetXmlDecl(){
447    GetWs(true);
448    TStr VerNm=GetName("version"); GetEq(); TStr VerVal=GetVersionNum();
449    if (VerVal!="1.0"){EThrow("Invalid XML version.");}
450    AddArg(VerNm, VerVal);
451    GetWs(false);
452    if (Ch!='?'){
453      TStr EncNm=GetName("encoding"); GetEq(); TStr EncVal=GetEncName();
454      AddArg(EncNm, EncVal);
455    }
456    GetWs(false);
457    if (Ch!='?'){
458      TStr StalNm=GetName("standalone"); GetEq(); TStr StalVal=GetStalVal();
459      AddArg(StalNm, StalVal);
460    }
461    GetWs(false);
462    if (Ch=='?'){
463      GetCh();
464      if (Ch=='>'){GetCh();}
465      else {EThrow("Invalid end-of-tag in XML-declaration.");}
466    } else {
467      EThrow("Invalid end-of-tag in XML-declaration.");
468    }
469  }
470  void TXmlLx::GetPI(){
471    GetWs(false);
472    TxtChA.Clr();
473    forever {
474      if (!ChDef.IsChar(Ch)){EThrow("Invalid PI character.");}
475      if (Ch=='?'){
476        if (GetCh()=='>'){
477          GetCh(); break;
478        } else {
479          if (!ChDef.IsChar(Ch)){EThrow("Invalid PI character.");}
480          TxtChA+='?'; TxtChA+=Ch; 
481        }
482      } else {
483        TxtChA+=Ch; 
484      }
485      GetCh();
486    }
487  }
488  TStr TXmlLx::GetSystemLiteral(){
489    char QCh=Ch;
490    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
491    TChA LitChA; GetCh();
492    while (Ch!=QCh){
493      if (!ChDef.IsChar(Ch)){EThrow("Invalid System-Literal character.");}
494      LitChA+=Ch; GetCh();
495    }
496    GetCh();
497    return LitChA;
498  }
499  TStr TXmlLx::GetPubidLiteral(){
500    char QCh=Ch;
501    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
502    TChA LitChA; GetCh();
503    while (Ch!=QCh){
504      if (!ChDef.IsPubid(Ch)){EThrow("Invalid Public-Id-Literal character.");}
505      LitChA+=Ch; GetCh();
506    }
507    GetCh();
508    return LitChA;
509  }
510  void TXmlLx::GetExternalId(){
511    TStr ExtIdNm=GetName();
512    if (ExtIdNm=="SYSTEM"){
513      GetWs(true); GetSystemLiteral();
514    } else if (ExtIdNm=="PUBLIC"){
515      GetWs(true); GetPubidLiteral(); GetWs(true); GetSystemLiteral();
516    } else {
517      EThrow("Invalid external-id ('SYSTEM' or 'PUBLIC' expected).");
518    }
519  }
520  void TXmlLx::GetNData(){
521    GetName("NDATA"); GetWs(true); GetName();
522  }
523  void TXmlLx::GetDocTypeDecl(){
524    GetWs(true);
525    TStr DocTypeDeclNm=GetName();
526    GetWs(false);
527    if (Ch=='>'){GetCh(); return;}
528    if (Ch!='['){GetExternalId();}
529    GetWs(false);
530    if (Ch=='['){
531      GetCh();
532      GetWs(false);
533      while (Ch!=']'){
534        if (ChDef.IsWs(Ch)){GetWs(true);}
535        else if (Ch=='%'){GetPEReference();}
536        else {
537          GetSym();
538        }
539      }
540      GetCh();
541    }
542    GetWs(false);
543    if (Ch=='>'){GetCh();}
544    else {EThrow("Invalid end-of-tag in document-type-declaration.");}
545    TagNm=DocTypeDeclNm;
546  }
547  void TXmlLx::GetElement(){
548    TxtChA.Clr();
549    while (Ch!='>'){
550      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
551      TxtChA+=Ch; GetCh();
552    }
553    GetCh();
554  }
555  void TXmlLx::GetAttList(){
556    TxtChA.Clr();
557    while (Ch!='>'){
558      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
559      TxtChA+=Ch; GetCh();
560    }
561    GetCh();
562  }
563  TStr TXmlLx::GetEntityValue(){
564    uchar QCh=Ch;
565    if ((QCh!='"')&&(QCh!='\'')){EThrow("Invalid entity-value start.");}
566    TChA ValChA; GetCh();
567    forever {
568      if (!ChDef.IsChar(Ch)){EThrow("Invalid entity-value character.");}
569      if (Ch==QCh){GetCh(); break;} 
570      else if (Ch=='&'){GetCh(); ValChA+=GetReference();} 
571      else if (Ch=='%'){GetCh(); ValChA+=GetPEReference();} 
572      else {ValChA+=Ch; GetCh();} 
573    }
574    return ValChA;
575  }
576  void TXmlLx::GetEntity(){
577    GetWs(true); TStr EntityNm;
578    if (Ch=='%'){
579      GetCh(); GetWs(true); EntityNm=GetName(); GetWs(true);
580      if ((Ch=='\"')||(Ch=='\'')){
581        TStr EntityVal=GetEntityValue();
582        PutPEntityVal(EntityNm, EntityVal);
583      } else {
584        GetExternalId();
585        GetWs(false);
586        if (Ch!='>'){GetNData();}
587      }
588    } else {
589      EntityNm=GetName(); GetWs(true);
590      if ((Ch=='\"')||(Ch=='\'')){
591        TStr EntityVal=GetEntityValue();
592        PutEntityVal(EntityNm, EntityVal);
593      } else {
594        GetExternalId();
595      }
596    }
597    GetWs(false);
598    if (Ch=='>'){GetCh();}
599    else {EThrow("Invalid end-of-tag in entity-declaration.");}
600    TagNm=EntityNm;
601  }
602  void TXmlLx::GetNotation(){
603    TxtChA.Clr();
604    while (Ch!='>'){
605      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
606      TxtChA+=Ch; GetCh();
607    }
608    GetCh();
609  }
610  void TXmlLx::GetCDSect(){
611    if (Ch=='['){GetCh();}
612    else {EThrow("Invalid start of CDATA section.");}
613    TxtChA.Clr();
614    forever {
615      if (!ChDef.IsChar(Ch)){EThrow("Invalid CDATA character.");}
616      if ((Ch=='>')&&(TxtChA.Len()>=2)&&
617       (TxtChA.LastLastCh()==']') && (TxtChA.LastCh()==']')){
618        GetCh(); TxtChA.Pop(); TxtChA.Pop(); break;
619      } else {
620        TxtChA+=Ch; GetCh();
621      }
622    }
623  }
624  void TXmlLx::SkipWs(){
625    while (ChDef.IsWs(Ch)){GetCh();}
626  }
627  TXmlLxSym TXmlLx::GetSym(){
628    if (Ch=='<'){
629      GetCh(); ClrArgV();
630      if (Ch=='?'){
631        GetCh(); TagNm=GetName();
632        if (TagNm.GetLc()=="xml"){Sym=xsyXmlDecl; GetXmlDecl();}
633        else {Sym=xsyPI; GetPI();}
634      } else
635      if (Ch=='!'){
636        GetCh();
637        if (Ch=='['){
638          GetCh(); TagNm=GetName();
639          if (TagNm=="CDATA"){Sym=xsyQStr; GetCDSect();}
640          else {EThrow(TStr("Invalid tag after '<![' (")+TagNm+").");}
641        } else
642        if (Ch=='-'){
643          Sym=xsyComment; GetComment();
644        } else {
645          TagNm=GetName();
646          if (TagNm=="DOCTYPE"){GetDocTypeDecl(); Sym=xsyDocTypeDecl;}
647          else if (TagNm=="ELEMENT"){GetElement(); Sym=xsyElement;}
648          else if (TagNm=="ATTLIST"){GetAttList(); Sym=xsyAttList;}
649          else if (TagNm=="ENTITY"){GetEntity(); Sym=xsyEntity;}
650          else if (TagNm=="NOTATION"){GetNotation(); Sym=xsyNotation;}
651          else {EThrow(TStr("Invalid tag (")+TagNm+").");}
652        }
653      } else
654      if (Ch=='/'){
655        GetCh(); Sym=xsyETag; TagNm=GetName(); GetWs(false);
656        if (Ch=='>'){GetCh();}
657        else {EThrow("Invalid End-Tag.");}
658      } else {
659        TagNm=GetName(); GetWs(false);
660        while ((Ch!='>')&&(Ch!='/')){
661          TStr AttrNm=GetName();
662          GetEq();
663          TStr AttrVal=GetAttValue();
664          GetWs(false);
665          AddArg(AttrNm, AttrVal);
666        }
667        if (Ch=='/'){
668          if (GetCh()=='>'){Sym=xsySETag; GetCh();}
669          else {EThrow("Invalid Empty-Element-Tag.");}
670        } else {
671          Sym=xsySTag; GetCh();
672        }
673      }
674      if (Spacing==xspTruncate){SkipWs();}
675    } else
676    if (ChDef.IsWs(Ch)){
677      Sym=xsyWs; GetWs(true); ToNrSpacing();
678      if (Spacing==xspTruncate){GetSym();}
679    } else
680    if (Ch==TCh::EofCh){
681      Sym=xsyEof;
682    } else {
683      Sym=xsyStr; TxtChA.Clr();
684      forever {
685        if (!ChDef.IsChar(Ch)){
686          EThrow(TUInt::GetStr(Ch, "Invalid character (%d)."));}
687        if (Ch=='<'){break;} 
688        if (Ch=='&'){GetCh(); TxtChA+=GetReference();} 
689        else {
690          if ((Ch=='>')&&(TxtChA.Len()>=2)&&
691           (TxtChA.LastLastCh()==']')&&(TxtChA.LastCh()==']')){
692            EThrow("Forbidden substring ']]>' in character data.");}
693          TxtChA+=Ch; GetCh(); 
694        }
695      }
696      ToNrSpacing();
697    }
698    return Sym;
699  }
700  TStr TXmlLx::GetSymStr() const {
701    TChA SymChA;
702    switch (Sym){
703      case xsyUndef:
704        SymChA="{Undef}"; break;
705      case xsyWs:
706        SymChA+="{Space:'"; SymChA+=TStr(TxtChA).GetHex(); SymChA+="'}"; break;
707      case xsyComment:
708        SymChA+="<!--"; SymChA+=TxtChA; SymChA+="-->"; break;
709      case xsyXmlDecl:{
710        SymChA+="<?"; SymChA+=TagNm;
711        for (int ArgN=0; ArgN<GetArgs(); ArgN++){
712          TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
713          char ArgValQCh=GetArgValQCh(ArgVal);
714          SymChA+=' '; SymChA+=ArgNm; SymChA+='=';
715          SymChA+=ArgValQCh; SymChA+=ArgVal; SymChA+=ArgValQCh;
716        }
717        SymChA+="?>"; break;}
718      case xsyPI:
719        SymChA+="<?"; SymChA+=TagNm;
720        if (!TxtChA.Empty()){SymChA+=' '; SymChA+=TxtChA;}
721        SymChA+="?>"; break;
722      case xsyDocTypeDecl:
723        SymChA+="<!DOCTYPE "; SymChA+=TagNm; SymChA+=">"; break;
724      case xsySTag:
725      case xsySETag:{
726        SymChA+="<"; SymChA+=TagNm;
727        for (int ArgN=0; ArgN<GetArgs(); ArgN++){
728          TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
729          char ArgValQCh=GetArgValQCh(ArgVal);
730          SymChA+=' '; SymChA+=ArgNm; SymChA+='=';
731          SymChA+=ArgValQCh; SymChA+=ArgVal; SymChA+=ArgValQCh;
732        }
733        if (Sym==xsySTag){SymChA+=">";}
734        else if (Sym==xsySETag){SymChA+="/>";}
735        else {Fail;}
736        break;}
737      case xsyETag:
738        SymChA+="</"; SymChA+=TagNm; SymChA+=">"; break;
739      case xsyStr:
740        SymChA="{String:'"; SymChA+=TxtChA; SymChA+="'}"; break;
741      case xsyQStr:
742        SymChA="{QString:'"; SymChA+=TxtChA; SymChA+="'}"; break;
743      case xsyEof:
744        SymChA="{Eof}"; break;
745      default: Fail;
746    }
747    return SymChA;
748  }
749  void TXmlLx::EThrow(const TStr& MsgStr) const {
750    TChA FPosChA;
751    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
752    FPosChA+=" Line:"; FPosChA+=TInt::GetStr(LnN);
753    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(LnChN);
754    FPosChA+="]";
755    TStr FullMsgStr=MsgStr+FPosChA;
756    TExcept::Throw(FullMsgStr);
757  }
758  TStr TXmlLx::GetFPosStr() const {
759    TChA FPosChA;
760    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
761    FPosChA+=" Line:"; FPosChA+=TInt::GetStr(LnN);
762    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(LnChN);
763    FPosChA+="]";
764    return FPosChA;
765  }
766  TStr TXmlLx::GetXmlLxSymStr(const TXmlLxSym& XmlLxSym){
767    switch (XmlLxSym){
768      case xsyUndef: return "Undef";
769      case xsyWs: return "White-Space";
770      case xsyComment: return "Comment";
771      case xsyXmlDecl: return "Declaration";
772      case xsyPI: return "PI";
773      case xsyDocTypeDecl: return "Document-Type";
774      case xsyElement: return "Element";
775      case xsyAttList: return "Attribute-List";
776      case xsyEntity: return "Entity";
777      case xsyNotation: return "Notation";
778      case xsyTag: return "Tag";
779      case xsySTag: return "Start-Tag";
780      case xsyETag: return "End-Tag";
781      case xsySETag: return "Start-End-Tag";
782      case xsyStr: return "String";
783      case xsyQStr: return "Quoted-String";
784      case xsyEof: return "Eon-Of-File";
785      default: return "Undef";
786    }
787  }
788  bool TXmlLx::IsTagNm(const TStr& Str){
789    TChA ChA=Str;
790    if (ChA.Len()>0){
791      if (TXmlLx::ChDef.IsFirstNameCh(ChA[0])){
792        for (int ChN=1; ChN<ChA.Len(); ChN++){
793          if (!TXmlLx::ChDef.IsName(ChA[ChN])){
794            return false;
795          }
796        }
797        return true;
798      } else {
799        return false;
800      }
801    } else {
802      return false;
803    }
804  }
805  TStr TXmlLx::GetXmlStrFromPlainMem(const TMem& PlainMem){
806    TChA XmlChA;
807    for (int ChN=0; ChN<PlainMem.Len(); ChN++){
<span onclick='openModal()' class='match'>808      uchar Ch=PlainMem[ChN];
809      if ((' '<=Ch)&&(Ch<='~')){
810        switch (Ch){
</span>811          case '"': XmlChA+="&quot;"; break;
812          case '&': XmlChA+="&amp;"; break;
813          case '\'': XmlChA+="&apos;"; break;
814          case '<': XmlChA+="&lt;"; break;
815          case '>': XmlChA+="&gt;"; break;
816          default: XmlChA+=Ch;
817        }
818      } else
819      if ((Ch=='\r')||(Ch=='\n')){
820        XmlChA+=Ch;
821      } else {
822        XmlChA+='&'; XmlChA+='#'; XmlChA+=TUInt::GetStr(Ch); XmlChA+=';';
823      }
824    }
825    return XmlChA;
826  }
827  TStr TXmlLx::GetXmlStrFromPlainStr(const TChA& PlainChA){
828    TChA XmlChA;
829    for (int ChN=0; ChN<PlainChA.Len(); ChN++){
830      uchar Ch=PlainChA[ChN];
831      if ((' '<=Ch)&&(Ch<='~')){
832        switch (Ch){
833          case '"': XmlChA+="&quot;"; break;
834          case '&': XmlChA+="&amp;"; break;
835          case '\'': XmlChA+="&apos;"; break;
836          case '<': XmlChA+="&lt;"; break;
837          case '>': XmlChA+="&gt;"; break;
838          default: XmlChA+=Ch;
839        }
840      } else
841      if ((Ch=='\r')||(Ch=='\n')){
842        XmlChA+=Ch;
843      } else {
844        XmlChA+='&'; XmlChA+='#'; XmlChA+=TUInt::GetStr(Ch); XmlChA+=';';
845      }
846    }
847    return XmlChA;
848  }
849  TStr TXmlLx::GetPlainStrFromXmlStr(const TStr& XmlStr){
850    TChA PlainChA;
851    TChRet Ch(TStrIn::New(XmlStr));
852    Ch.GetCh();
853    while (!Ch.Eof()){
854      if (Ch()!='&'){
855        PlainChA+=Ch(); Ch.GetCh();
856      } else {
857        if (Ch.GetCh()=='#'){
858          TChA RefChA; int RefCd=0;
859          if (Ch.GetCh()=='x'){
860            forever {
861              Ch.GetCh();
862              if (TCh::IsHex(Ch())){
863                RefChA+=Ch();
864                RefCd=RefCd*16+TCh::GetHex(Ch());
865              } else {
866                break;
867              }
868            }
869          } else {
870            forever {
871              if (TCh::IsNum(Ch())){
872                RefChA+=Ch();
873                RefCd=RefCd*10+TCh::GetNum(Ch());
874              } else {
875                break;
876              }
877              Ch.GetCh();
878            }
879          }
880          if ((!RefChA.Empty())&&(Ch()==';')){
881            Ch.GetCh();
882  		  if (RefCd < 0x80) {
883  			uchar RefCh=uchar(RefCd);
884  			PlainChA+=RefCh;
885  		  } else {
886  			TUnicode::EncodeUtf8(RefCd, PlainChA);
887  		  }
888          }
889        } else {
890          TChA EntityNm;
891          while ((!Ch.Eof())&&(Ch()!=';')){
892            EntityNm+=Ch(); Ch.GetCh();}
893          if ((!EntityNm.Empty())&&(Ch()==';')){
894            Ch.GetCh();
895            if (EntityNm=="quot"){PlainChA+='"';}
896            else if (EntityNm=="amp"){PlainChA+='&';}
897            else if (EntityNm=="apos"){PlainChA+='\'';}
898            else if (EntityNm=="lt"){PlainChA+='<';}
899            else if (EntityNm=="gt"){PlainChA+='>';}
900          }
901        }
902      }
903    }
904    return PlainChA;
905  }
906  TStr TXmlLx::GetUsAsciiStrFromXmlStr(const TStr& XmlStr){
907    TStr UsAsciiStr=XmlStr;
908    UsAsciiStr.ChangeStrAll("&#232;", "c");
909    UsAsciiStr.ChangeStrAll("&#200;", "C");
910    UsAsciiStr.ChangeStrAll("&#154;", "s");
911    UsAsciiStr.ChangeStrAll("&#138;", "S");
912    UsAsciiStr.ChangeStrAll("&#158;", "z");
913    UsAsciiStr.ChangeStrAll("&#142;", "Z");
914    TChA UsAsciiChA=TXmlLx::GetPlainStrFromXmlStr(UsAsciiStr);
915    for (int ChN=0; ChN<UsAsciiChA.Len(); ChN++){
916      char Ch=UsAsciiChA[ChN];
917      if ((Ch<' ')||('~'<Ch)){UsAsciiChA.PutCh(ChN, 'x');}
918    }
919    return UsAsciiChA;
920  }
921  TStr TXmlLx::GetChRefFromYuEntRef(const TStr& YuEntRefStr){
922    TStr ChRefStr=YuEntRefStr;
923    ChRefStr.ChangeStrAll("&ch;", "&#232;");
924    ChRefStr.ChangeStrAll("&Ch;", "&#200;");
925    ChRefStr.ChangeStrAll("&sh;", "&#154;");
926    ChRefStr.ChangeStrAll("&Sh;", "&#138;");
927    ChRefStr.ChangeStrAll("&zh;", "&#158;");
928    ChRefStr.ChangeStrAll("&Zh;", "&#142;");
929    ChRefStr.ChangeStrAll("&cs", "c");
930    ChRefStr.ChangeStrAll("&Cs;", "C");
931    ChRefStr.ChangeStrAll("&dz;", "dz");
932    ChRefStr.ChangeStrAll("&Dz;", "Dz");
933    return ChRefStr;
934  }
935  bool TXmlTok::GetBoolArgVal(const TStr& ArgNm, const bool& DfVal) const {
936    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
937    return (ArgN==-1) ? DfVal : (ArgNmValV[ArgN].Dat==TBool::TrueStr);
938  }
939  bool TXmlTok::GetBoolArgVal(
940   const TStr& ArgNm, const TStr& TrueVal, const bool& DfVal) const {
941    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
942    return (ArgN==-1) ? DfVal : (ArgNmValV[ArgN].Dat==TrueVal);
943  }
944  bool TXmlTok::GetBoolArgVal(const TStr& ArgNm,
945   const TStr& TrueVal, const TStr& FalseVal, const bool& DfVal) const {
946    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
947    if (ArgN==-1){return DfVal;}
948    TStr ArgVal=ArgNmValV[ArgN].Dat;
949    if (ArgVal==TrueVal){return true;}
950    IAssert(ArgVal == FalseVal); return false;
951  }
952  int TXmlTok::GetIntArgVal(const TStr& ArgNm, const int& DfVal) const {
953    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
954    if (ArgN==-1){
955      return DfVal;
956    } else {
957      int Val;
958      if (ArgNmValV[ArgN].Dat.IsInt(Val)){return Val;} else {return DfVal;}
959    }
960  }
961  double TXmlTok::GetFltArgVal(const TStr& ArgNm, const double& DfVal) const {
962    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
963    if (ArgN==-1){
964      return DfVal;
965    } else {
966      double Val;
967      if (ArgNmValV[ArgN].Dat.IsFlt(Val)){return Val;} else {return DfVal;}
968    }
969  }
970  TStr TXmlTok::GetStrArgVal(const TStr& ArgNm, const TStr& DfVal) const {
971    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
972    return (ArgN==-1) ? DfVal : ArgNmValV[ArgN].Dat;
973  }
974  void TXmlTok::PutSubTok(const PXmlTok& Tok, const int& SubTokN){
975    if (SubTokN==-1){
976      ClrSubTok(); AddSubTok(Tok);
977    } else {
978      SubTokV[SubTokN]=Tok;
979    }
980  }
981  PXmlTok TXmlTok::GetTagTok(const TStr& TagPath) const {
982    if (TagPath.Empty()){
983      return (TXmlTok*)this;
984    } else {
985      TStr TagNm; TStr RestTagPath; TagPath.SplitOnCh(TagNm, '|', RestTagPath);
986      PXmlTok SubTok;
987      for (int SubTokN=0; SubTokN<SubTokV.Len(); SubTokN++){
988        SubTok=SubTokV[SubTokN];
989        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){break;}
990        else {SubTok=NULL;}
991      }
992      if ((SubTok.Empty())||(RestTagPath.Empty())){return SubTok;}
993      else {return SubTok->GetTagTok(RestTagPath);}
994    }
995  }
996  void TXmlTok::GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const {
997    XmlTokV.Clr();
998    TStr PreTagPath; TStr TagNm; TagPath.SplitOnLastCh(PreTagPath, '|', TagNm);
999    PXmlTok Tok=GetTagTok(PreTagPath);
1000    if (!Tok.Empty()){
1001      for (int SubTokN=0; SubTokN<Tok->GetSubToks(); SubTokN++){
1002        PXmlTok SubTok=Tok->GetSubTok(SubTokN);
1003        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){
1004          XmlTokV.Add(SubTok);}
1005      }
1006    }
1007  }
1008  void TXmlTok::GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const {
1009    if ((Sym==xsyTag)&&(Str==TagNm)){
1010      ValV.Add(GetTokStr(XmlP));
1011    } else {
1012      for (int SubTokN=0; SubTokN<GetSubToks(); SubTokN++){
1013        GetSubTok(SubTokN)->GetTagValV(TagNm, XmlP, ValV);}
1014    }
1015  }
1016  TStr TXmlTok::GetTagVal(const TStr& TagNm, const bool& XmlP) const {
1017    TStrV ValV; GetTagValV(TagNm, XmlP, ValV);
1018    if (ValV.Len()>0){return ValV[0];} else {return "";}
1019  }
1020  void TXmlTok::AddTokToChA(const bool& XmlP, TChA& ChA) const {
1021    switch (Sym){
1022      case xsyWs:
1023        ChA+=Str; break;
1024      case xsyStr:
1025        if (XmlP){ChA+=TXmlLx::GetXmlStrFromPlainStr(Str);} else {ChA+=Str;} break;
1026      case xsyQStr:
1027        if (XmlP){ChA+="<![CDATA[";}
1028        ChA+=Str;
1029        if (XmlP){ChA+="]]>";} break;
1030      case xsyTag:
1031        if (XmlP){
1032          ChA+='<'; ChA+=Str;
1033          for (int ArgN=0; ArgN<GetArgs(); ArgN++){
1034            TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
1035            if (XmlP){ArgVal=TXmlLx::GetXmlStrFromPlainStr(ArgVal);}
1036            char ArgValQCh=TXmlLx::GetArgValQCh(ArgVal);
1037            ChA+=' '; ChA+=ArgNm; ChA+='=';
1038            ChA+=ArgValQCh; ChA+=ArgVal; ChA+=ArgValQCh;
1039          }
1040        }
1041        if (GetSubToks()==0){
1042          if (XmlP){ChA+="/>";}
1043        } else {
1044          if (XmlP){ChA+=">";}
1045          for (int SubTokN=0; SubTokN<GetSubToks(); SubTokN++){
1046            GetSubTok(SubTokN)->AddTokToChA(XmlP, ChA);}
1047          if (XmlP){ChA+="</"; ChA+=Str; ChA+='>';}
1048        }
1049        break;
1050      default: Fail;
1051    }
1052  }
1053  TStr TXmlTok::GetTokVStr(const TXmlTokV& TokV, const bool& XmlP){
1054    TChA TokVChA;
1055    for (int TokN=0; TokN<TokV.Len(); TokN++){
1056      if (TokN>0){TokVChA+=' ';}
1057      TokVChA+=TokV[TokN]->GetTokStr(XmlP);
1058    }
1059    return TokVChA;
1060  }
1061  PXmlTok TXmlTok::GetTok(TXmlLx& Lx){
1062    switch (Lx.Sym){
1063      case xsyWs:
1064      case xsyStr:
1065      case xsyQStr:
1066        return TXmlTok::New(Lx.Sym, Lx.TxtChA);
1067      case xsySTag:
1068      case xsySETag:
1069        return TXmlTok::New(xsyTag, Lx.TagNm, Lx.ArgNmValKdV);
1070      default: Fail; return NULL;
1071    }
1072  }
1073  void TXmlDoc::LoadTxtMiscStar(TXmlLx& Lx){
1074    while ((Lx.Sym==xsyComment)||(Lx.Sym==xsyPI)||(Lx.Sym==xsyWs)){
1075      Lx.GetSym();}
1076  }
1077  PXmlTok TXmlDoc::LoadTxtElement(TXmlLx& Lx){
1078    PXmlTok Tok;
1079    if (Lx.Sym==xsySETag){
1080      Tok=TXmlTok::GetTok(Lx);
1081    } else
1082    if (Lx.Sym==xsySTag){
1083      Tok=TXmlTok::GetTok(Lx);
1084      forever {
1085        Lx.GetSym();
1086        if (Lx.Sym==xsyETag){
1087          if (Tok->GetStr()==Lx.TagNm){
1088            break;
1089          } else {
1090            TStr MsgStr=TStr("Invalid End-Tag '")+Lx.TagNm+
1091             "' ('"+Tok->GetStr()+"' expected).";
1092            Lx.EThrow(MsgStr);
1093          }
1094        } else {
1095          PXmlTok SubTok;
1096          switch (Lx.Sym){
1097            case xsySTag:
1098              SubTok=LoadTxtElement(Lx); break;
1099            case xsySETag:
1100            case xsyStr:
1101            case xsyQStr:
1102            case xsyWs:
1103              SubTok=TXmlTok::GetTok(Lx); break;
1104            case xsyPI:
1105            case xsyComment:
1106              break;
1107            default: Lx.EThrow("Content or End-Tag expected.");
1108          }
1109          if (!SubTok.Empty()){
1110            Tok->AddSubTok(SubTok);}
1111        }
1112      }
1113    } else
1114    if (Lx.Sym==xsyETag){
1115      TStr MsgStr=
1116       TStr("Xml-Element (Start-Tag or Empty-Element-Tag) required.")+
1117       TStr::GetStr(Lx.TagNm, " End-Tag </%s> encountered.");
1118      Lx.EThrow(MsgStr);
1119    } else {
1120      Lx.EThrow("Xml-Element (Start-Tag or Empty-Element-Tag) required.");
1121    }
1122    return Tok;
1123  }
1124  PXmlTok TXmlDoc::GetTagTok(const TStr& TagPath) const {
1125    if (TagPath.Empty()){
1126      return Tok;
1127    } else {
1128      TStr TagNm; TStr RestTagPath; TagPath.SplitOnCh(TagNm, '|', RestTagPath);
1129      if ((Tok->GetSym()==xsyTag)&&(Tok->GetStr()==TagNm)){
1130        if (RestTagPath.Empty()){return Tok;}
1131        else {return Tok->GetTagTok(RestTagPath);}
1132      } else {
1133        return NULL;
1134      }
1135    }
1136  }
1137  void TXmlDoc::PutTagTokStr(const TStr& TagPath, const TStr& TokStr) const {
1138    PXmlTok Tok=GetTagTok(TagPath);
1139    Tok->ClrSubTok();
1140    PXmlTok StrTok=TXmlTok::New(xsyStr, TokStr);
1141    Tok->AddSubTok(StrTok);
1142  }
1143  void TXmlDoc::GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const {
1144    XmlTokV.Clr();
1145    TStr PreTagPath; TStr TagNm; TagPath.SplitOnLastCh(PreTagPath, '|', TagNm);
1146    PXmlTok Tok=GetTagTok(PreTagPath);
1147    if (!Tok.Empty()){
1148      for (int SubTokN=0; SubTokN<Tok->GetSubToks(); SubTokN++){
1149        PXmlTok SubTok=Tok->GetSubTok(SubTokN);
1150        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){
1151          XmlTokV.Add(SubTok);}
1152      }
1153    }
1154  }
1155  bool TXmlDoc::GetTagTokBoolArgVal(
1156   const TStr& TagPath, const TStr& ArgNm, const bool& DfVal) const {
1157    PXmlTok TagTok;
1158    if (IsTagTok(TagPath, TagTok)){
1159      return TagTok->GetBoolArgVal(ArgNm, DfVal);}
1160    else {return DfVal;}
1161  }
1162  int TXmlDoc::GetTagTokIntArgVal(
1163   const TStr& TagPath, const TStr& ArgNm, const int& DfVal) const {
1164    PXmlTok TagTok;
1165    if (IsTagTok(TagPath, TagTok)){
1166      return TagTok->GetIntArgVal(ArgNm, DfVal);}
1167    else {return DfVal;}
1168  }
1169  double TXmlDoc::GetTagTokFltArgVal(
1170   const TStr& TagPath, const TStr& ArgNm, const double& DfVal) const {
1171    PXmlTok TagTok;
1172    if (IsTagTok(TagPath, TagTok)){
1173      return TagTok->GetFltArgVal(ArgNm, DfVal);}
1174    else {return DfVal;}
1175  }
1176  TStr TXmlDoc::GetTagTokStrArgVal(
1177   const TStr& TagPath, const TStr& ArgNm, const TStr& DfVal) const {
1178    PXmlTok TagTok;
1179    if (IsTagTok(TagPath, TagTok)){
1180      return TagTok->GetStrArgVal(ArgNm, DfVal);}
1181    else {return DfVal;}
1182  }
1183  TStr TXmlDoc::GetXmlStr(const TStr& Str){
1184    TChA ChA=Str;
1185    TChA XmlChA;
1186    for (int ChN=0; ChN<ChA.Len(); ChN++){
1187      uchar Ch=ChA[ChN];
1188      if ((' '<=Ch)&&(Ch<='~')){
1189        if (Ch=='&'){XmlChA+="&amp;";}
1190        else if (Ch=='>'){XmlChA+="&lt;";}
1191        else if (Ch=='<'){XmlChA+="&gt;";}
1192        else if (Ch=='\''){XmlChA+="&apos;";}
1193        else if (Ch=='\"'){XmlChA+="&quot;";}
1194        else {XmlChA+=Ch;}
1195      } else {
1196        XmlChA+="&#"; XmlChA+=TUInt::GetStr(Ch); XmlChA+=";";
1197      }
1198    }
1199    return XmlChA;
1200  }
1201  bool TXmlDoc::SkipTopTag(const PSIn& SIn){
1202    bool Ok=true;
1203    TXmlLx Lx(SIn, xspIntact);
1204    try {
1205      Lx.GetSym();
1206      if (Lx.Sym==xsyXmlDecl){Lx.GetSym();}
1207      LoadTxtMiscStar(Lx);
1208      if (Lx.Sym==xsyDocTypeDecl){Lx.GetSym();}
1209      LoadTxtMiscStar(Lx);
1210      Ok=true;
1211    }
1212    catch (PExcept Except){
1213      Ok=false;
1214    }
1215    return Ok;
1216  }
1217  PXmlDoc TXmlDoc::LoadTxt(TXmlLx& Lx){
1218    PXmlDoc Doc=TXmlDoc::New();
1219    try {
1220      Lx.GetSym();
1221      if (Lx.Sym==xsyXmlDecl){Lx.GetSym();}
1222      LoadTxtMiscStar(Lx);
1223      if (Lx.Sym==xsyDocTypeDecl){Lx.GetSym();}
1224      LoadTxtMiscStar(Lx);
1225      Doc->Tok=LoadTxtElement(Lx);
1226      LoadTxtMiscStar(Lx);
1227      Doc->Ok=true; Doc->MsgStr="Ok";
1228    }
1229    catch (PExcept& Except){
1230      Doc->Ok=false; Doc->MsgStr=Except->GetMsgStr();
1231    }
1232    return Doc;
1233  }
1234  PXmlDoc TXmlDoc::LoadTxt(const PSIn& SIn, const TXmlSpacing& Spacing){
1235    TXmlLx Lx(SIn, Spacing); return LoadTxt(Lx);
1236  }
1237  PXmlDoc TXmlDoc::LoadTxt(const TStr& FNm, const TXmlSpacing& Spacing){
1238    PSIn SIn=TFIn::New(FNm); return LoadTxt(SIn, Spacing);
1239  }
1240  void TXmlDoc::LoadTxt(
1241   const TStr& FNm, TXmlDocV& XmlDocV, const TXmlSpacing& Spacing){
1242    XmlDocV.Clr();
1243    PSIn SIn=TFIn::New(FNm);
1244    TXmlLx Lx(SIn, Spacing);
1245    PXmlDoc XmlDoc;
1246    forever {
1247      Lx.SkipWs();
1248      XmlDoc=LoadTxt(Lx);
1249      if (XmlDoc->IsOk()){XmlDocV.Add(XmlDoc);}
1250      else {break;}
1251    }
1252  }
1253  PXmlDoc TXmlDoc::LoadStr(const TStr& Str){
1254    PSIn SIn=TStrIn::New(Str);
1255    return LoadTxt(SIn);
1256  }
1257  void TXmlDoc::SaveStr(TStr& Str){
1258    PSOut SOut=TMOut::New(); TMOut& MOut=*(TMOut*)SOut();
1259    SaveTxt(SOut);
1260    Str=MOut.GetAsStr();
1261  }
1262  TXmlLxSym TXmlParser::GetSym() {
1263    if (NextSym != xsyUndef) {
1264      Sym = NextSym;  NextSym=xsyUndef;
1265      SymStr=NextSymStr;  NextSymStr.Clr();
1266      return Sym;
1267    }
1268    SymStr.Clr();
1269    char Ch;
1270    while (TCh::IsWs(Ch=GetCh())) { }
1271    if (Ch == TCh::EofCh) { Sym = xsyEof; return xsyEof; }
1272    if (Ch == '<') { 
1273      Ch = GetCh();
1274      if (Ch == '/') { Sym = xsyETag; }
1275      else { Sym = xsySTag;  SymStr.Push(Ch); }
1276      while((Ch=GetCh())!='>' && Ch!=TCh::EofCh) { SymStr.Push(Ch); }
1277      const int StrLen = SymStr.Len();
1278      if (StrLen > 1 && SymStr[StrLen-1] == '/') {
1279        Sym = xsyETag; SymStr[StrLen-1] = 0;
1280        for (char *c = SymStr.CStr()+StrLen-2; TCh::IsWs(*c); c--) { *c=0; }
1281      }
1282    } else { 
1283      _SymStr.Clr();  _SymStr.Push(Ch);
1284      while (! RSIn.Eof() && RSIn.PeekCh() != '<') { _SymStr.Push(GetCh()); }
1285      GetPlainStrFromXmlStr(_SymStr, SymStr);
1286      Sym = xsyStr;
1287    }
1288    if (Ch == TCh::EofCh) { SymStr.Clr(); Sym = xsyEof; return xsyEof; }
1289    return Sym;
1290  }
1291  TXmlLxSym TXmlParser::GetSym(TChA& _SymStr) {
1292    GetSym();
1293    _SymStr = SymStr;
1294    return Sym;
1295  }
1296  TXmlLxSym TXmlParser::PeekSym() {
1297    if (NextSym == xsyUndef) {
1298      const TXmlLxSym TmpSim=Sym;
1299      const TChA TmpSymStr=SymStr;
1300      NextSym=GetSym(NextSymStr);
1301      Sym=TmpSim;
1302      SymStr=TmpSymStr;
1303    }
1304    return NextSym;
1305  }
1306  TXmlLxSym TXmlParser::PeekSym(TChA& _SymStr) {
1307    PeekSym();
1308    _SymStr = NextSymStr;
1309    return NextSym;
1310  }
1311  void TXmlParser::SkipTillTag(const TChA& _SymStr) {
1312    while(PeekSym() != xsyEof) {
1313      if (NextSymStr == _SymStr) { return; }
1314      GetSym();
1315    }
1316  }
1317  void TXmlParser::GetTagVal(const TChA& TagStr, TChA& TagVal) {
1318    EAssertR(GetTag(TagStr) == xsySTag, TStr::Fmt("Expected '<%s>'. Found '%s'", TagStr.CStr(), SymStr.CStr()).CStr());
1319    EAssertR(GetSym(TagVal) == xsyStr, "Expected string tag.");
1320    EAssertR(GetTag(TagStr) == xsyETag, TStr::Fmt("Expected '</%s>'. Found '%s'", TagStr.CStr(), SymStr.CStr()).CStr());
1321  }
1322  TXmlLxSym TXmlParser::GetTag(const TChA& TagStr) {
1323    GetSym();
1324    EAssertR(TagStr==SymStr, TStr::Fmt("Expected xml symbol '%s'. Found '%s'",
1325      TagStr.CStr(), SymStr.CStr()).CStr());
1326    return Sym;
1327  }
1328  void TXmlParser::GetPlainStrFromXmlStr(const TChA& XmlStr, TChA& PlainChA) {
1329    static TChA EntityNm;
1330    PlainChA.Clr();
1331    const char *Ch = XmlStr.CStr();
1332    while (*Ch){
1333      if (*Ch!='&'){ PlainChA+=*Ch; Ch++; }
1334      else {
1335        if (*++Ch=='#'){
1336          TChA RefChA; int RefCd=0;
1337          if (*++Ch=='x'){
1338            forever {  Ch++;
1339              if (TCh::IsHex(*Ch)){ RefChA+=*Ch;  RefCd=RefCd*16+TCh::GetHex(*Ch); }
1340              else { break; } }
1341          } else { 
1342            forever {
1343              if (TCh::IsNum(*Ch)){ RefChA+=*Ch; RefCd=RefCd*10+TCh::GetNum(*Ch); }
1344              else { break; } Ch++; }
1345          }
1346          if ((!RefChA.Empty())&&(*Ch==';')){
1347            Ch++;  const uchar RefCh=uchar(RefCd);  PlainChA+=RefCh; }
1348        } else {
1349          EntityNm.Clr();
1350          while ((*Ch)&&(*Ch!=';')){EntityNm+=*Ch; Ch++;}
1351          if ((!EntityNm.Empty())&&(*Ch==';')){  Ch++;
1352            if (EntityNm=="quot"){PlainChA+='"';}
1353            else if (EntityNm=="amp"){PlainChA+='&';}
1354            else if (EntityNm=="apos"){PlainChA+='\'';}
1355            else if (EntityNm=="lt"){PlainChA+='<';}
1356            else if (EntityNm=="gt"){PlainChA+='>';}
1357          }
1358        }
1359      }
1360    }
1361  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.cpp</h3>
            <pre><code>1  TStrStrH TXmlObjSer::TypeNmToTagNmH;
2  TStr TXmlObjSer::GetTagNm(const TStr& TypeNm){
3    TStr& XmlTagNm=TypeNmToTagNmH.AddDat(TypeNm);
4    if (XmlTagNm.Empty()){
5      TChA XmlTagChA=TypeNm;
6      for (int ChN=0; ChN<XmlTagChA.Len(); ChN++){
7        char Ch=XmlTagChA[ChN];
8        if (!((('A'<=Ch)&&(Ch<='Z'))||(('a'<=Ch)&&(Ch<='z'))||(('0'<=Ch)&&(Ch<='9')))){
9          XmlTagChA.PutCh(ChN, '_');
10        }
11      }
12      while ((XmlTagChA.Len()>0)&&(XmlTagChA.LastCh()=='_')){
13        XmlTagChA.Pop();}
14      XmlTagNm=XmlTagChA;
15    }
16    return XmlTagNm;
17  }
18  void TXmlObjSer::AssertXmlHd(
19   const PXmlTok& XmlTok, const TStr& Nm, const TStr& TypeNm){
20    EAssertR(!XmlTok.Empty(), "Xml-Token Empty");
21    if (!Nm.Empty()){
22      if (!XmlTok->IsTag()){
23        TStr ArgStr1="Expected: Tag";
24        TStr ArgStr2=TStr("Found: ")+XmlTok->GetSymStr();
25        TExcept::Throw("Invalid Xml-Token", ArgStr1, ArgStr2);
26      }
27      if (Nm!="-"){
28        if (!XmlTok->IsTag(Nm)){
29          TStr ArgStr1=TStr("Expected: ")+Nm;
30          TStr ArgStr2=TStr("Found: ")+XmlTok->GetStr();
31          TExcept::Throw("Invalid Xml-Tag", ArgStr1, ArgStr2);
32        }
33        TStr TypeArgVal=XmlTok->GetStrArgVal("Type");
34        if (TypeArgVal!=TypeNm){
35          TStr ArgStr1=TStr("Expected: ")+TypeNm;
36          TStr ArgStr2=TStr("Found: ")+TypeArgVal;
37          TExcept::Throw("Invalid Xml-Type", ArgStr1, ArgStr2);
38        }
39      }
40    } else {
41      if (!XmlTok->IsTag(TypeNm)){
42        TStr ArgStr1=TStr("Expected: ")+TypeNm;
43        TStr ArgStr2=TStr("Found: ")+XmlTok->GetSymStr();
44        TExcept::Throw("Invalid Xml-Type-Tag", ArgStr1, ArgStr2);
45      }
46    }
47  }
48  bool TXmlObjSer::GetBoolArg(const PXmlTok& XmlTok, const TStr& Nm){
49    TStr ValStr;
50    if (XmlTok->IsArg(Nm, ValStr)){
51      bool Val;
52      if (ValStr.IsBool(Val)){
53        return Val;
54      } else {
55        TExcept::Throw("Invalid Xml-Argument Boolean-Value", Nm, ValStr);
56      }
57    } else {
58      TExcept::Throw("Xml-Argument Missing", Nm);
59    }
60    Fail; return 0;
61  }
62  int TXmlObjSer::GetIntArg(const PXmlTok& XmlTok, const TStr& Nm){
63    TStr ValStr;
64    if (XmlTok->IsArg(Nm, ValStr)){
65      int Val;
66      if (ValStr.IsInt(Val)){
67        return Val;
68      } else {
69        TExcept::Throw("Invalid Xml-Argument Integer-Value", Nm, ValStr);
70      }
71    } else {
72      TExcept::Throw("Xml-Argument Missing", Nm);
73    }
74    Fail; return 0;
75  }
76  int64 TXmlObjSer::GetInt64Arg(const PXmlTok& XmlTok, const TStr& Nm){
77    TStr ValStr;
78    if (XmlTok->IsArg(Nm, ValStr)){
79      int64 Val;
80      if (ValStr.IsInt64(Val)){
81        return Val;
82      } else {
83        TExcept::Throw("Invalid Xml-Argument Integer64-Value", Nm, ValStr);
84      }
85    } else {
86      TExcept::Throw("Xml-Argument Missing", Nm);
87    }
88    Fail; return 0;
89  }
90  double TXmlObjSer::GetFltArg(const PXmlTok& XmlTok, const TStr& Nm){
91    TStr ValStr;
92    if (XmlTok->IsArg(Nm, ValStr)){
93      double Val;
94      if (ValStr.IsFlt(Val)){
95        return Val;
96      } else {
97        TExcept::Throw("Invalid Xml-Argument Double-Value", Nm, ValStr);
98      }
99    } else {
100      TExcept::Throw("Xml-Argument Missing", Nm);
101    }
102    Fail; return 0;
103  }
104  TXmlObjSerTagNm::TXmlObjSerTagNm(
105   TSOut& _SOut, const bool& ETagP,
106   const TStr& Nm, const TStr& TypeNm,
107   const TStr& ArgNm, const TStr& ArgVal):
108    TagNm(), SOut(&_SOut){
109    if (Nm!="-"){
110      SOut->PutCh('<');
111      if (Nm.Empty()){
112        SOut->PutStr(TagNm=TypeNm);
113      } else {
114        SOut->PutStr(TagNm=Nm);
115        SOut->PutStr(" Type=\""); SOut->PutStr(TypeNm); SOut->PutCh('"');
116      }
117      if (!ArgNm.Empty()){
118        SOut->PutCh(' '); SOut->PutStr(ArgNm); SOut->PutCh('=');
119        SOut->PutCh('"'); SOut->PutStr(ArgVal); SOut->PutCh('"');
120      }
121      if (ETagP){
122        SOut->PutCh('/'); TagNm="";}
123      SOut->PutCh('>');
124    }
125  }
126  TXmlObjSerTagNm::TXmlObjSerTagNm(
127   TSOut& _SOut, const bool& ETagP,
128   const TStr& Nm, const TStr& TypeNm,
129   const TStr& ArgNm1, const TStr& ArgVal1,
130   const TStr& ArgNm2, const TStr& ArgVal2,
131   const TStr& ArgNm3, const TStr& ArgVal3,
132   const TStr& ArgNm4, const TStr& ArgVal4):
133    TagNm(), SOut(&_SOut){
134    if (Nm!="-"){
135      SOut->PutCh('<');
136      if (Nm.Empty()){
137        SOut->PutStr(TagNm=TypeNm);
138      } else {
139        SOut->PutStr(TagNm=Nm);
140        SOut->PutStr(" Type=\""); SOut->PutStr(TypeNm); SOut->PutCh('"');
141      }
142      if (!ArgNm1.Empty()){
143        SOut->PutCh(' '); SOut->PutStr(ArgNm1); SOut->PutCh('=');
144        SOut->PutCh('"'); SOut->PutStr(ArgVal1); SOut->PutCh('"');
145      }
146      if (!ArgNm2.Empty()){
147        SOut->PutCh(' '); SOut->PutStr(ArgNm2); SOut->PutCh('=');
148        SOut->PutCh('"'); SOut->PutStr(ArgVal2); SOut->PutCh('"');
149      }
150      if (!ArgNm3.Empty()){
151        SOut->PutCh(' '); SOut->PutStr(ArgNm3); SOut->PutCh('=');
152        SOut->PutCh('"'); SOut->PutStr(ArgVal3); SOut->PutCh('"');
153      }
154      if (!ArgNm4.Empty()){
155        SOut->PutCh(' '); SOut->PutStr(ArgNm4); SOut->PutCh('=');
156        SOut->PutCh('"'); SOut->PutStr(ArgVal4); SOut->PutCh('"');
157      }
158      if (ETagP){
159        SOut->PutCh('/'); TagNm="";}
160      SOut->PutCh('>');
161    }
162  }
163  TXmlObjSerTagNm::~TXmlObjSerTagNm(){
164    if (!TagNm.Empty()){
165      SOut->PutCh('<'); SOut->PutCh('/'); SOut->PutStr(TagNm); SOut->PutCh('>');
166    }
167  }
168  void TXmlChDef::SetChTy(TBSet& ChSet, const int& MnCh, const int& MxCh){
169    IAssert((0<=MnCh)&&((MxCh==-1)||((MnCh<=MxCh)&&(MxCh<Chs))));
170    ChSet.Incl(MnCh);
171    for (int Ch=MnCh+1; Ch<=MxCh; Ch++){
172      ChSet.Incl(Ch);}
173  }
174  void TXmlChDef::SetChTy(TBSet& ChSet, const TStr& Str){
175    for (int ChN=0; ChN<Str.Len(); ChN++){
176      uchar Ch=Str[ChN];
177      ChSet.Incl(Ch);
178    }
179  }
180  void TXmlChDef::SetEntityVal(const TStr& Nm, const TStr& Val){
181    EntityNmToValH.AddDat(Nm, Val);
182  }
183  TXmlChDef::TXmlChDef():
184    Chs(TUCh::Vals),
185    CharChSet(), CombChSet(), ExtChSet(),
186    LetterChSet(), DigitChSet(), NameChSet(), PubidChSet(),
187    EntityNmToValH(100){
188    CharChSet.Gen(Chs);
189    SetChTy(CharChSet, 0x1); SetChTy(CharChSet, 0x3); SetChTy(CharChSet, 0x6);
190    SetChTy(CharChSet, 11); SetChTy(CharChSet, 24); SetChTy(CharChSet, 27);
191    SetChTy(CharChSet, 0x9); SetChTy(CharChSet, 0xA); SetChTy(CharChSet, 0xD);
192    SetChTy(CharChSet, 0x20, TUCh::Mx);
193    TBSet BaseChSet(Chs);
194    SetChTy(BaseChSet, 0x41, 0x5A); SetChTy(BaseChSet, 0x61, 0x7A);
195    SetChTy(BaseChSet, 0xC0, 0xD6); SetChTy(BaseChSet, 0xD8, 0xF6);
196    SetChTy(BaseChSet, 0xF8, 0xFF);
197    TBSet IdeoChSet(Chs);
198    CombChSet.Gen(Chs);
199    ExtChSet.Gen(Chs);
200    SetChTy(ExtChSet, 0xB7);
201    LetterChSet=BaseChSet|IdeoChSet;
202    DigitChSet.Gen(Chs);
203    SetChTy(DigitChSet, 0x30, 0x39);
204    NameChSet=LetterChSet|DigitChSet|
205     uchar('.')|uchar('-')|uchar('_')|uchar(':')|CombChSet;
206    PubidChSet.Gen(Chs);
207    SetChTy(PubidChSet, 0x20); SetChTy(PubidChSet, 0xD); SetChTy(PubidChSet, 0xA);
208    SetChTy(PubidChSet, 'a', 'z'); SetChTy(PubidChSet, 'A', 'Z');
209    SetChTy(PubidChSet, '0', '9'); SetChTy(PubidChSet, "-'()+,./:=?;!*#@$_%");
210    SetEntityVal("amp", "&");
211    SetEntityVal("lt", "<"); SetEntityVal("gt", ">");
212    SetEntityVal("apos", "'"); SetEntityVal("quot", "\"");
213  }
214  TXmlChDef TXmlLx::ChDef;
215  uchar TXmlLx::GetCh(){
216    EAssert(Ch!=TCh::EofCh);
217    PrevCh=Ch;
218    if (ChStack.Empty()){Ch=(RSIn.Eof()) ? TCh::EofCh : RSIn.GetCh();}
219    else {Ch=ChStack.Pop();}
220    ChN++; if (Ch==TCh::LfCh){LnN++; LnChN=0;} else {LnChN++;}
221    return Ch;
222  }
223  void TXmlLx::ToNrSpacing(){
224    if (Spacing==xspIntact){
225    } else
226    if (Spacing==xspPreserve){
227      int SrcChN=0; int DstChN=0;
228      while (SrcChN<TxtChA.Len()){
229        if (TxtChA[SrcChN]==TCh::CrCh){
230          TxtChA.PutCh(DstChN, TCh::LfCh); SrcChN++; DstChN++;
231          if ((SrcChN<TxtChA.Len())&&(TxtChA[SrcChN]==TCh::LfCh)){SrcChN++;}
232        } else {
233          if (SrcChN!=DstChN){
234            TxtChA.PutCh(DstChN, TxtChA[SrcChN]);}
235          SrcChN++; DstChN++;
236        }
237      }
238      TxtChA.Trunc(DstChN);
239    } else
240    if (Spacing==xspSeparate){
241      int SrcChN=0; int DstChN=0;
242      while (SrcChN<TxtChA.Len()){
243        if (ChDef.IsWs(TxtChA[SrcChN])){
244          if ((DstChN>0)&&(TxtChA[DstChN-1]==' ')){
245            SrcChN++;
246          } else {
247            TxtChA.PutCh(DstChN, ' ');
248            SrcChN++; DstChN++;
249          }
250        } else {
251          TxtChA.PutCh(DstChN, TxtChA[SrcChN]);
252          SrcChN++; DstChN++;
253        }
254      }
255      TxtChA.Trunc(DstChN);
256    } else
257    if (Spacing==xspTruncate){
258      int SrcChN=0; int DstChN=0;
259      while (SrcChN<TxtChA.Len()){
260        if (ChDef.IsWs(TxtChA[SrcChN])){
261          if ((DstChN>0)&&(TxtChA[DstChN-1]==' ')){
262            SrcChN++;
263          } else {
264            TxtChA.PutCh(DstChN, ' ');
265            SrcChN++; DstChN++;
266          }
267        } else {
268          TxtChA.PutCh(DstChN, TxtChA[SrcChN]);
269          SrcChN++; DstChN++;
270        }
271      }
272      TxtChA.Trunc(DstChN);
273      while ((TxtChA.Len()>0)&&(ChDef.IsWs(TxtChA.LastCh()))){
274        TxtChA.Pop();}
275    } else {
276      Fail;
277    }
278  }
279  void TXmlLx::GetWs(const bool& IsRq){
280    int WSpaces=0; TxtChA.Clr();
281    while (ChDef.IsWs(Ch)){
282      WSpaces++; TxtChA+=Ch; GetCh();}
283    if (IsRq&&(WSpaces==0)){
284      EThrow("White-space required.");}
285  }
286  TStr TXmlLx::GetReference(){
287    if (Ch=='#'){
288      TChA RefChA; int RefCd=0;
289      if (GetCh()=='x'){
290        forever {
291          GetCh();
292          if (TCh::IsHex(Ch)){
293            RefChA+=Ch;
294            RefCd=RefCd*16+TCh::GetHex(Ch);
295          } else {
296            break;
297          }
298        }
299      } else {
300        forever {
301          if (TCh::IsNum(Ch)){
302            RefChA+=Ch;
303            RefCd=RefCd*10+TCh::GetNum(Ch);
304          } else {
305            break;
306          }
307          GetCh();
308        }
309      }
310      if ((!RefChA.Empty())&&(Ch==';')){
311        GetCh();
312  	  if (RefCd < 0x80) {
313  	      uchar RefCh=uchar(RefCd);
314  		  return TStr(RefCh);
315  	  } else {
316  		  TStr ResStr = TUnicode::EncodeUtf8(RefCd);
317  		  return ResStr;
318  	  }
319      } else {
320        EThrow("Invalid Char-Reference."); Fail; return TStr();
321      }
322    } else {
323      TStr EntityNm=GetName();
324      if ((!EntityNm.Empty())&&(Ch==';')){
325        GetCh();
326        TStr EntityVal;
327        if (IsEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
328        else if (ChDef.IsEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
329        else {EThrow(TStr("Entity-Reference (")+EntityNm+") does not exist.");}
330        return EntityVal;
331      } else {
332        EThrow("Invalid Entity-Reference."); Fail; return TStr();
333      }
334    }
335  }
336  TStr TXmlLx::GetPEReference(){
337    TStr EntityNm=GetName();
338    if ((EntityNm.Empty())||(Ch!=';')){EThrow("Invalid PEntity-Reference.");}
339    GetCh();
340    TStr EntityVal;
341    if (IsPEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
342    else {EThrow(TStr("PEntity-Reference (")+EntityNm+") does not exist.");}
343    return EntityVal;
344  }
345  void TXmlLx::GetEq(){
346    GetWs(false);
347    if (Ch=='='){GetCh();}
348    else {EThrow("Equality ('=') character expected.");}
349    GetWs(false);
350  }
351  TStr TXmlLx::GetName(){
352    TChA NmChA;
353    if (ChDef.IsFirstNameCh(Ch)){
354      do {NmChA+=Ch;} while (ChDef.IsName(GetCh()));
355    } else {
356      EThrow("Invalid first name character.");
357    }
358    return NmChA;
359  }
360  TStr TXmlLx::GetName(const TStr& RqNm){
361    TStr Nm=GetName();
362    if (Nm==RqNm){return RqNm;}
363    else {EThrow(TStr("Name '")+RqNm+"' expected."); Fail; return TStr();}
364  }
365  void TXmlLx::GetComment(){
366    if (GetCh()!='-'){EThrow("Invalid comment start.");}
367    TxtChA.Clr();
368    forever {
369      GetCh();
370      if (!ChDef.IsChar(Ch)){EThrow("Invalid comment character.");}
371      if (Ch=='-'){
372        if (GetCh()=='-'){
373          if (GetCh()=='>'){GetCh(); break;} 
374          else {EThrow("Invalid comment end.");}
375        } else {
376          if (!ChDef.IsChar(Ch)){EThrow("Invalid comment character.");}
377          TxtChA+='-'; TxtChA+=Ch; 
378        }
379      } else {
380        TxtChA+=Ch; 
381      }
382    }
383  }
384  TStr TXmlLx::GetAttValue(){
385    uchar QCh=Ch;
386    if ((QCh!='"')&&(QCh!='\'')){EThrow("Invalid attribute-value start.");}
387    TChA ValChA; GetCh();
388    forever {
389      if ((Ch=='<')||(!ChDef.IsChar(Ch))){
390        EThrow("Invalid attribute-value character.");}
391      if (Ch==QCh){GetCh(); break;} 
392      else if (Ch=='&'){GetCh(); ValChA+=GetReference();} 
393      else {ValChA+=Ch; GetCh();} 
394    }
395    return ValChA;
396  }
397  TStr TXmlLx::GetVersionNum(){
398    char QCh=Ch;
399    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
400    TChA VerNumChA;
401    GetCh();
402    do {
403      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))||
404       (('0'<=Ch)&&(Ch<='9'))||(Ch=='_')||(Ch=='.')||(Ch==':')||(Ch=='-')){
405        VerNumChA+=Ch;
406      } else {
407        EThrow("Invalid version-number character.");
408      }
409      GetCh();
410    } while (Ch!=QCh);
411    GetCh();
412    return VerNumChA;
413  }
414  TStr TXmlLx::GetEncName(){
415    char QCh=Ch;
416    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
417    TChA EncNmChA;
418    GetCh();
419    if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))){EncNmChA+=Ch;}
420    else {EThrow("Invalid encoding-name character.");}
421    GetCh();
422    while (Ch!=QCh){
423      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))||
424       (('0'<=Ch)&&(Ch<='9'))||(Ch=='.')||(Ch=='_')||(Ch=='-')){EncNmChA+=Ch;}
425      else {EThrow("Invalid version-number character.");}
426      GetCh();
427    }
428    GetCh();
429    return EncNmChA;
430  }
431  TStr TXmlLx::GetStalVal(){
432    char QCh=Ch;
433    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
434    TChA StalChA;
435    GetCh();
436    while (Ch!=QCh){
437      if (('a'<=Ch)&&(Ch<='z')){StalChA+=Ch;}
438      else {EThrow("Invalid standalone-value character.");}
439      GetCh();
440    }
441    GetCh();
442    TStr StalVal=StalChA;
443    if ((StalVal=="yes")||(StalVal=="no")){return StalVal;}
444    else {EThrow("Invalid standalone-value."); Fail; return TStr();}
445  }
446  void TXmlLx::GetXmlDecl(){
447    GetWs(true);
448    TStr VerNm=GetName("version"); GetEq(); TStr VerVal=GetVersionNum();
449    if (VerVal!="1.0"){EThrow("Invalid XML version.");}
450    AddArg(VerNm, VerVal);
451    GetWs(false);
452    if (Ch!='?'){
453      TStr EncNm=GetName("encoding"); GetEq(); TStr EncVal=GetEncName();
454      AddArg(EncNm, EncVal);
455    }
456    GetWs(false);
457    if (Ch!='?'){
458      TStr StalNm=GetName("standalone"); GetEq(); TStr StalVal=GetStalVal();
459      AddArg(StalNm, StalVal);
460    }
461    GetWs(false);
462    if (Ch=='?'){
463      GetCh();
464      if (Ch=='>'){GetCh();}
465      else {EThrow("Invalid end-of-tag in XML-declaration.");}
466    } else {
467      EThrow("Invalid end-of-tag in XML-declaration.");
468    }
469  }
470  void TXmlLx::GetPI(){
471    GetWs(false);
472    TxtChA.Clr();
473    forever {
474      if (!ChDef.IsChar(Ch)){EThrow("Invalid PI character.");}
475      if (Ch=='?'){
476        if (GetCh()=='>'){
477          GetCh(); break;
478        } else {
479          if (!ChDef.IsChar(Ch)){EThrow("Invalid PI character.");}
480          TxtChA+='?'; TxtChA+=Ch; 
481        }
482      } else {
483        TxtChA+=Ch; 
484      }
485      GetCh();
486    }
487  }
488  TStr TXmlLx::GetSystemLiteral(){
489    char QCh=Ch;
490    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
491    TChA LitChA; GetCh();
492    while (Ch!=QCh){
493      if (!ChDef.IsChar(Ch)){EThrow("Invalid System-Literal character.");}
494      LitChA+=Ch; GetCh();
495    }
496    GetCh();
497    return LitChA;
498  }
499  TStr TXmlLx::GetPubidLiteral(){
500    char QCh=Ch;
501    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
502    TChA LitChA; GetCh();
503    while (Ch!=QCh){
504      if (!ChDef.IsPubid(Ch)){EThrow("Invalid Public-Id-Literal character.");}
505      LitChA+=Ch; GetCh();
506    }
507    GetCh();
508    return LitChA;
509  }
510  void TXmlLx::GetExternalId(){
511    TStr ExtIdNm=GetName();
512    if (ExtIdNm=="SYSTEM"){
513      GetWs(true); GetSystemLiteral();
514    } else if (ExtIdNm=="PUBLIC"){
515      GetWs(true); GetPubidLiteral(); GetWs(true); GetSystemLiteral();
516    } else {
517      EThrow("Invalid external-id ('SYSTEM' or 'PUBLIC' expected).");
518    }
519  }
520  void TXmlLx::GetNData(){
521    GetName("NDATA"); GetWs(true); GetName();
522  }
523  void TXmlLx::GetDocTypeDecl(){
524    GetWs(true);
525    TStr DocTypeDeclNm=GetName();
526    GetWs(false);
527    if (Ch=='>'){GetCh(); return;}
528    if (Ch!='['){GetExternalId();}
529    GetWs(false);
530    if (Ch=='['){
531      GetCh();
532      GetWs(false);
533      while (Ch!=']'){
534        if (ChDef.IsWs(Ch)){GetWs(true);}
535        else if (Ch=='%'){GetPEReference();}
536        else {
537          GetSym();
538        }
539      }
540      GetCh();
541    }
542    GetWs(false);
543    if (Ch=='>'){GetCh();}
544    else {EThrow("Invalid end-of-tag in document-type-declaration.");}
545    TagNm=DocTypeDeclNm;
546  }
547  void TXmlLx::GetElement(){
548    TxtChA.Clr();
549    while (Ch!='>'){
550      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
551      TxtChA+=Ch; GetCh();
552    }
553    GetCh();
554  }
555  void TXmlLx::GetAttList(){
556    TxtChA.Clr();
557    while (Ch!='>'){
558      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
559      TxtChA+=Ch; GetCh();
560    }
561    GetCh();
562  }
563  TStr TXmlLx::GetEntityValue(){
564    uchar QCh=Ch;
565    if ((QCh!='"')&&(QCh!='\'')){EThrow("Invalid entity-value start.");}
566    TChA ValChA; GetCh();
567    forever {
568      if (!ChDef.IsChar(Ch)){EThrow("Invalid entity-value character.");}
569      if (Ch==QCh){GetCh(); break;} 
570      else if (Ch=='&'){GetCh(); ValChA+=GetReference();} 
571      else if (Ch=='%'){GetCh(); ValChA+=GetPEReference();} 
572      else {ValChA+=Ch; GetCh();} 
573    }
574    return ValChA;
575  }
576  void TXmlLx::GetEntity(){
577    GetWs(true); TStr EntityNm;
578    if (Ch=='%'){
579      GetCh(); GetWs(true); EntityNm=GetName(); GetWs(true);
580      if ((Ch=='\"')||(Ch=='\'')){
581        TStr EntityVal=GetEntityValue();
582        PutPEntityVal(EntityNm, EntityVal);
583      } else {
584        GetExternalId();
585        GetWs(false);
586        if (Ch!='>'){GetNData();}
587      }
588    } else {
589      EntityNm=GetName(); GetWs(true);
590      if ((Ch=='\"')||(Ch=='\'')){
591        TStr EntityVal=GetEntityValue();
592        PutEntityVal(EntityNm, EntityVal);
593      } else {
594        GetExternalId();
595      }
596    }
597    GetWs(false);
598    if (Ch=='>'){GetCh();}
599    else {EThrow("Invalid end-of-tag in entity-declaration.");}
600    TagNm=EntityNm;
601  }
602  void TXmlLx::GetNotation(){
603    TxtChA.Clr();
604    while (Ch!='>'){
605      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
606      TxtChA+=Ch; GetCh();
607    }
608    GetCh();
609  }
610  void TXmlLx::GetCDSect(){
611    if (Ch=='['){GetCh();}
612    else {EThrow("Invalid start of CDATA section.");}
613    TxtChA.Clr();
614    forever {
615      if (!ChDef.IsChar(Ch)){EThrow("Invalid CDATA character.");}
616      if ((Ch=='>')&&(TxtChA.Len()>=2)&&
617       (TxtChA.LastLastCh()==']') && (TxtChA.LastCh()==']')){
618        GetCh(); TxtChA.Pop(); TxtChA.Pop(); break;
619      } else {
620        TxtChA+=Ch; GetCh();
621      }
622    }
623  }
624  void TXmlLx::SkipWs(){
625    while (ChDef.IsWs(Ch)){GetCh();}
626  }
627  TXmlLxSym TXmlLx::GetSym(){
628    if (Ch=='<'){
629      GetCh(); ClrArgV();
630      if (Ch=='?'){
631        GetCh(); TagNm=GetName();
632        if (TagNm.GetLc()=="xml"){Sym=xsyXmlDecl; GetXmlDecl();}
633        else {Sym=xsyPI; GetPI();}
634      } else
635      if (Ch=='!'){
636        GetCh();
637        if (Ch=='['){
638          GetCh(); TagNm=GetName();
639          if (TagNm=="CDATA"){Sym=xsyQStr; GetCDSect();}
640          else {EThrow(TStr("Invalid tag after '<![' (")+TagNm+").");}
641        } else
642        if (Ch=='-'){
643          Sym=xsyComment; GetComment();
644        } else {
645          TagNm=GetName();
646          if (TagNm=="DOCTYPE"){GetDocTypeDecl(); Sym=xsyDocTypeDecl;}
647          else if (TagNm=="ELEMENT"){GetElement(); Sym=xsyElement;}
648          else if (TagNm=="ATTLIST"){GetAttList(); Sym=xsyAttList;}
649          else if (TagNm=="ENTITY"){GetEntity(); Sym=xsyEntity;}
650          else if (TagNm=="NOTATION"){GetNotation(); Sym=xsyNotation;}
651          else {EThrow(TStr("Invalid tag (")+TagNm+").");}
652        }
653      } else
654      if (Ch=='/'){
655        GetCh(); Sym=xsyETag; TagNm=GetName(); GetWs(false);
656        if (Ch=='>'){GetCh();}
657        else {EThrow("Invalid End-Tag.");}
658      } else {
659        TagNm=GetName(); GetWs(false);
660        while ((Ch!='>')&&(Ch!='/')){
661          TStr AttrNm=GetName();
662          GetEq();
663          TStr AttrVal=GetAttValue();
664          GetWs(false);
665          AddArg(AttrNm, AttrVal);
666        }
667        if (Ch=='/'){
668          if (GetCh()=='>'){Sym=xsySETag; GetCh();}
669          else {EThrow("Invalid Empty-Element-Tag.");}
670        } else {
671          Sym=xsySTag; GetCh();
672        }
673      }
674      if (Spacing==xspTruncate){SkipWs();}
675    } else
676    if (ChDef.IsWs(Ch)){
677      Sym=xsyWs; GetWs(true); ToNrSpacing();
678      if (Spacing==xspTruncate){GetSym();}
679    } else
680    if (Ch==TCh::EofCh){
681      Sym=xsyEof;
682    } else {
683      Sym=xsyStr; TxtChA.Clr();
684      forever {
685        if (!ChDef.IsChar(Ch)){
686          EThrow(TUInt::GetStr(Ch, "Invalid character (%d)."));}
687        if (Ch=='<'){break;} 
688        if (Ch=='&'){GetCh(); TxtChA+=GetReference();} 
689        else {
690          if ((Ch=='>')&&(TxtChA.Len()>=2)&&
691           (TxtChA.LastLastCh()==']')&&(TxtChA.LastCh()==']')){
692            EThrow("Forbidden substring ']]>' in character data.");}
693          TxtChA+=Ch; GetCh(); 
694        }
695      }
696      ToNrSpacing();
697    }
698    return Sym;
699  }
700  TStr TXmlLx::GetSymStr() const {
701    TChA SymChA;
702    switch (Sym){
703      case xsyUndef:
704        SymChA="{Undef}"; break;
705      case xsyWs:
706        SymChA+="{Space:'"; SymChA+=TStr(TxtChA).GetHex(); SymChA+="'}"; break;
707      case xsyComment:
708        SymChA+="<!--"; SymChA+=TxtChA; SymChA+="-->"; break;
709      case xsyXmlDecl:{
710        SymChA+="<?"; SymChA+=TagNm;
711        for (int ArgN=0; ArgN<GetArgs(); ArgN++){
712          TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
713          char ArgValQCh=GetArgValQCh(ArgVal);
714          SymChA+=' '; SymChA+=ArgNm; SymChA+='=';
715          SymChA+=ArgValQCh; SymChA+=ArgVal; SymChA+=ArgValQCh;
716        }
717        SymChA+="?>"; break;}
718      case xsyPI:
719        SymChA+="<?"; SymChA+=TagNm;
720        if (!TxtChA.Empty()){SymChA+=' '; SymChA+=TxtChA;}
721        SymChA+="?>"; break;
722      case xsyDocTypeDecl:
723        SymChA+="<!DOCTYPE "; SymChA+=TagNm; SymChA+=">"; break;
724      case xsySTag:
725      case xsySETag:{
726        SymChA+="<"; SymChA+=TagNm;
727        for (int ArgN=0; ArgN<GetArgs(); ArgN++){
728          TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
729          char ArgValQCh=GetArgValQCh(ArgVal);
730          SymChA+=' '; SymChA+=ArgNm; SymChA+='=';
731          SymChA+=ArgValQCh; SymChA+=ArgVal; SymChA+=ArgValQCh;
732        }
733        if (Sym==xsySTag){SymChA+=">";}
734        else if (Sym==xsySETag){SymChA+="/>";}
735        else {Fail;}
736        break;}
737      case xsyETag:
738        SymChA+="</"; SymChA+=TagNm; SymChA+=">"; break;
739      case xsyStr:
740        SymChA="{String:'"; SymChA+=TxtChA; SymChA+="'}"; break;
741      case xsyQStr:
742        SymChA="{QString:'"; SymChA+=TxtChA; SymChA+="'}"; break;
743      case xsyEof:
744        SymChA="{Eof}"; break;
745      default: Fail;
746    }
747    return SymChA;
748  }
749  void TXmlLx::EThrow(const TStr& MsgStr) const {
750    TChA FPosChA;
751    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
752    FPosChA+=" Line:"; FPosChA+=TInt::GetStr(LnN);
753    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(LnChN);
754    FPosChA+="]";
755    TStr FullMsgStr=MsgStr+FPosChA;
756    TExcept::Throw(FullMsgStr);
757  }
758  TStr TXmlLx::GetFPosStr() const {
759    TChA FPosChA;
760    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
761    FPosChA+=" Line:"; FPosChA+=TInt::GetStr(LnN);
762    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(LnChN);
763    FPosChA+="]";
764    return FPosChA;
765  }
766  TStr TXmlLx::GetXmlLxSymStr(const TXmlLxSym& XmlLxSym){
767    switch (XmlLxSym){
768      case xsyUndef: return "Undef";
769      case xsyWs: return "White-Space";
770      case xsyComment: return "Comment";
771      case xsyXmlDecl: return "Declaration";
772      case xsyPI: return "PI";
773      case xsyDocTypeDecl: return "Document-Type";
774      case xsyElement: return "Element";
775      case xsyAttList: return "Attribute-List";
776      case xsyEntity: return "Entity";
777      case xsyNotation: return "Notation";
778      case xsyTag: return "Tag";
779      case xsySTag: return "Start-Tag";
780      case xsyETag: return "End-Tag";
781      case xsySETag: return "Start-End-Tag";
782      case xsyStr: return "String";
783      case xsyQStr: return "Quoted-String";
784      case xsyEof: return "Eon-Of-File";
785      default: return "Undef";
786    }
787  }
788  bool TXmlLx::IsTagNm(const TStr& Str){
789    TChA ChA=Str;
790    if (ChA.Len()>0){
791      if (TXmlLx::ChDef.IsFirstNameCh(ChA[0])){
792        for (int ChN=1; ChN<ChA.Len(); ChN++){
793          if (!TXmlLx::ChDef.IsName(ChA[ChN])){
794            return false;
795          }
796        }
797        return true;
798      } else {
799        return false;
800      }
801    } else {
802      return false;
803    }
804  }
805  TStr TXmlLx::GetXmlStrFromPlainMem(const TMem& PlainMem){
806    TChA XmlChA;
807    for (int ChN=0; ChN<PlainMem.Len(); ChN++){
<span onclick='openModal()' class='match'>808      uchar Ch=PlainMem[ChN];
809      if ((' '<=Ch)&&(Ch<='~')){
810        switch (Ch){
</span>811          case '"': XmlChA+="&quot;"; break;
812          case '&': XmlChA+="&amp;"; break;
813          case '\'': XmlChA+="&apos;"; break;
814          case '<': XmlChA+="&lt;"; break;
815          case '>': XmlChA+="&gt;"; break;
816          default: XmlChA+=Ch;
817        }
818      } else
819      if ((Ch=='\r')||(Ch=='\n')){
820        XmlChA+=Ch;
821      } else {
822        XmlChA+='&'; XmlChA+='#'; XmlChA+=TUInt::GetStr(Ch); XmlChA+=';';
823      }
824    }
825    return XmlChA;
826  }
827  TStr TXmlLx::GetXmlStrFromPlainStr(const TChA& PlainChA){
828    TChA XmlChA;
829    for (int ChN=0; ChN<PlainChA.Len(); ChN++){
830      uchar Ch=PlainChA[ChN];
831      if ((' '<=Ch)&&(Ch<='~')){
832        switch (Ch){
833          case '"': XmlChA+="&quot;"; break;
834          case '&': XmlChA+="&amp;"; break;
835          case '\'': XmlChA+="&apos;"; break;
836          case '<': XmlChA+="&lt;"; break;
837          case '>': XmlChA+="&gt;"; break;
838          default: XmlChA+=Ch;
839        }
840      } else
841      if ((Ch=='\r')||(Ch=='\n')){
842        XmlChA+=Ch;
843      } else {
844        XmlChA+='&'; XmlChA+='#'; XmlChA+=TUInt::GetStr(Ch); XmlChA+=';';
845      }
846    }
847    return XmlChA;
848  }
849  TStr TXmlLx::GetPlainStrFromXmlStr(const TStr& XmlStr){
850    TChA PlainChA;
851    TChRet Ch(TStrIn::New(XmlStr));
852    Ch.GetCh();
853    while (!Ch.Eof()){
854      if (Ch()!='&'){
855        PlainChA+=Ch(); Ch.GetCh();
856      } else {
857        if (Ch.GetCh()=='#'){
858          TChA RefChA; int RefCd=0;
859          if (Ch.GetCh()=='x'){
860            forever {
861              Ch.GetCh();
862              if (TCh::IsHex(Ch())){
863                RefChA+=Ch();
864                RefCd=RefCd*16+TCh::GetHex(Ch());
865              } else {
866                break;
867              }
868            }
869          } else {
870            forever {
871              if (TCh::IsNum(Ch())){
872                RefChA+=Ch();
873                RefCd=RefCd*10+TCh::GetNum(Ch());
874              } else {
875                break;
876              }
877              Ch.GetCh();
878            }
879          }
880          if ((!RefChA.Empty())&&(Ch()==';')){
881            Ch.GetCh();
882  		  if (RefCd < 0x80) {
883  			uchar RefCh=uchar(RefCd);
884  			PlainChA+=RefCh;
885  		  } else {
886  			TUnicode::EncodeUtf8(RefCd, PlainChA);
887  		  }
888          }
889        } else {
890          TChA EntityNm;
891          while ((!Ch.Eof())&&(Ch()!=';')){
892            EntityNm+=Ch(); Ch.GetCh();}
893          if ((!EntityNm.Empty())&&(Ch()==';')){
894            Ch.GetCh();
895            if (EntityNm=="quot"){PlainChA+='"';}
896            else if (EntityNm=="amp"){PlainChA+='&';}
897            else if (EntityNm=="apos"){PlainChA+='\'';}
898            else if (EntityNm=="lt"){PlainChA+='<';}
899            else if (EntityNm=="gt"){PlainChA+='>';}
900          }
901        }
902      }
903    }
904    return PlainChA;
905  }
906  TStr TXmlLx::GetUsAsciiStrFromXmlStr(const TStr& XmlStr){
907    TStr UsAsciiStr=XmlStr;
908    UsAsciiStr.ChangeStrAll("&#232;", "c");
909    UsAsciiStr.ChangeStrAll("&#200;", "C");
910    UsAsciiStr.ChangeStrAll("&#154;", "s");
911    UsAsciiStr.ChangeStrAll("&#138;", "S");
912    UsAsciiStr.ChangeStrAll("&#158;", "z");
913    UsAsciiStr.ChangeStrAll("&#142;", "Z");
914    TChA UsAsciiChA=TXmlLx::GetPlainStrFromXmlStr(UsAsciiStr);
915    for (int ChN=0; ChN<UsAsciiChA.Len(); ChN++){
916      char Ch=UsAsciiChA[ChN];
917      if ((Ch<' ')||('~'<Ch)){UsAsciiChA.PutCh(ChN, 'x');}
918    }
919    return UsAsciiChA;
920  }
921  TStr TXmlLx::GetChRefFromYuEntRef(const TStr& YuEntRefStr){
922    TStr ChRefStr=YuEntRefStr;
923    ChRefStr.ChangeStrAll("&ch;", "&#232;");
924    ChRefStr.ChangeStrAll("&Ch;", "&#200;");
925    ChRefStr.ChangeStrAll("&sh;", "&#154;");
926    ChRefStr.ChangeStrAll("&Sh;", "&#138;");
927    ChRefStr.ChangeStrAll("&zh;", "&#158;");
928    ChRefStr.ChangeStrAll("&Zh;", "&#142;");
929    ChRefStr.ChangeStrAll("&cs", "c");
930    ChRefStr.ChangeStrAll("&Cs;", "C");
931    ChRefStr.ChangeStrAll("&dz;", "dz");
932    ChRefStr.ChangeStrAll("&Dz;", "Dz");
933    return ChRefStr;
934  }
935  bool TXmlTok::GetBoolArgVal(const TStr& ArgNm, const bool& DfVal) const {
936    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
937    return (ArgN==-1) ? DfVal : (ArgNmValV[ArgN].Dat==TBool::TrueStr);
938  }
939  bool TXmlTok::GetBoolArgVal(
940   const TStr& ArgNm, const TStr& TrueVal, const bool& DfVal) const {
941    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
942    return (ArgN==-1) ? DfVal : (ArgNmValV[ArgN].Dat==TrueVal);
943  }
944  bool TXmlTok::GetBoolArgVal(const TStr& ArgNm,
945   const TStr& TrueVal, const TStr& FalseVal, const bool& DfVal) const {
946    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
947    if (ArgN==-1){return DfVal;}
948    TStr ArgVal=ArgNmValV[ArgN].Dat;
949    if (ArgVal==TrueVal){return true;}
950    IAssert(ArgVal == FalseVal); return false;
951  }
952  int TXmlTok::GetIntArgVal(const TStr& ArgNm, const int& DfVal) const {
953    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
954    if (ArgN==-1){
955      return DfVal;
956    } else {
957      int Val;
958      if (ArgNmValV[ArgN].Dat.IsInt(Val)){return Val;} else {return DfVal;}
959    }
960  }
961  double TXmlTok::GetFltArgVal(const TStr& ArgNm, const double& DfVal) const {
962    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
963    if (ArgN==-1){
964      return DfVal;
965    } else {
966      double Val;
967      if (ArgNmValV[ArgN].Dat.IsFlt(Val)){return Val;} else {return DfVal;}
968    }
969  }
970  TStr TXmlTok::GetStrArgVal(const TStr& ArgNm, const TStr& DfVal) const {
971    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
972    return (ArgN==-1) ? DfVal : ArgNmValV[ArgN].Dat;
973  }
974  void TXmlTok::PutSubTok(const PXmlTok& Tok, const int& SubTokN){
975    if (SubTokN==-1){
976      ClrSubTok(); AddSubTok(Tok);
977    } else {
978      SubTokV[SubTokN]=Tok;
979    }
980  }
981  PXmlTok TXmlTok::GetTagTok(const TStr& TagPath) const {
982    if (TagPath.Empty()){
983      return (TXmlTok*)this;
984    } else {
985      TStr TagNm; TStr RestTagPath; TagPath.SplitOnCh(TagNm, '|', RestTagPath);
986      PXmlTok SubTok;
987      for (int SubTokN=0; SubTokN<SubTokV.Len(); SubTokN++){
988        SubTok=SubTokV[SubTokN];
989        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){break;}
990        else {SubTok=NULL;}
991      }
992      if ((SubTok.Empty())||(RestTagPath.Empty())){return SubTok;}
993      else {return SubTok->GetTagTok(RestTagPath);}
994    }
995  }
996  void TXmlTok::GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const {
997    XmlTokV.Clr();
998    TStr PreTagPath; TStr TagNm; TagPath.SplitOnLastCh(PreTagPath, '|', TagNm);
999    PXmlTok Tok=GetTagTok(PreTagPath);
1000    if (!Tok.Empty()){
1001      for (int SubTokN=0; SubTokN<Tok->GetSubToks(); SubTokN++){
1002        PXmlTok SubTok=Tok->GetSubTok(SubTokN);
1003        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){
1004          XmlTokV.Add(SubTok);}
1005      }
1006    }
1007  }
1008  void TXmlTok::GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const {
1009    if ((Sym==xsyTag)&&(Str==TagNm)){
1010      ValV.Add(GetTokStr(XmlP));
1011    } else {
1012      for (int SubTokN=0; SubTokN<GetSubToks(); SubTokN++){
1013        GetSubTok(SubTokN)->GetTagValV(TagNm, XmlP, ValV);}
1014    }
1015  }
1016  TStr TXmlTok::GetTagVal(const TStr& TagNm, const bool& XmlP) const {
1017    TStrV ValV; GetTagValV(TagNm, XmlP, ValV);
1018    if (ValV.Len()>0){return ValV[0];} else {return "";}
1019  }
1020  void TXmlTok::AddTokToChA(const bool& XmlP, TChA& ChA) const {
1021    switch (Sym){
1022      case xsyWs:
1023        ChA+=Str; break;
1024      case xsyStr:
1025        if (XmlP){ChA+=TXmlLx::GetXmlStrFromPlainStr(Str);} else {ChA+=Str;} break;
1026      case xsyQStr:
1027        if (XmlP){ChA+="<![CDATA[";}
1028        ChA+=Str;
1029        if (XmlP){ChA+="]]>";} break;
1030      case xsyTag:
1031        if (XmlP){
1032          ChA+='<'; ChA+=Str;
1033          for (int ArgN=0; ArgN<GetArgs(); ArgN++){
1034            TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
1035            if (XmlP){ArgVal=TXmlLx::GetXmlStrFromPlainStr(ArgVal);}
1036            char ArgValQCh=TXmlLx::GetArgValQCh(ArgVal);
1037            ChA+=' '; ChA+=ArgNm; ChA+='=';
1038            ChA+=ArgValQCh; ChA+=ArgVal; ChA+=ArgValQCh;
1039          }
1040        }
1041        if (GetSubToks()==0){
1042          if (XmlP){ChA+="/>";}
1043        } else {
1044          if (XmlP){ChA+=">";}
1045          for (int SubTokN=0; SubTokN<GetSubToks(); SubTokN++){
1046            GetSubTok(SubTokN)->AddTokToChA(XmlP, ChA);}
1047          if (XmlP){ChA+="</"; ChA+=Str; ChA+='>';}
1048        }
1049        break;
1050      default: Fail;
1051    }
1052  }
1053  TStr TXmlTok::GetTokVStr(const TXmlTokV& TokV, const bool& XmlP){
1054    TChA TokVChA;
1055    for (int TokN=0; TokN<TokV.Len(); TokN++){
1056      if (TokN>0){TokVChA+=' ';}
1057      TokVChA+=TokV[TokN]->GetTokStr(XmlP);
1058    }
1059    return TokVChA;
1060  }
1061  PXmlTok TXmlTok::GetTok(TXmlLx& Lx){
1062    switch (Lx.Sym){
1063      case xsyWs:
1064      case xsyStr:
1065      case xsyQStr:
1066        return TXmlTok::New(Lx.Sym, Lx.TxtChA);
1067      case xsySTag:
1068      case xsySETag:
1069        return TXmlTok::New(xsyTag, Lx.TagNm, Lx.ArgNmValKdV);
1070      default: Fail; return NULL;
1071    }
1072  }
1073  void TXmlDoc::LoadTxtMiscStar(TXmlLx& Lx){
1074    while ((Lx.Sym==xsyComment)||(Lx.Sym==xsyPI)||(Lx.Sym==xsyWs)){
1075      Lx.GetSym();}
1076  }
1077  PXmlTok TXmlDoc::LoadTxtElement(TXmlLx& Lx){
1078    PXmlTok Tok;
1079    if (Lx.Sym==xsySETag){
1080      Tok=TXmlTok::GetTok(Lx);
1081    } else
1082    if (Lx.Sym==xsySTag){
1083      Tok=TXmlTok::GetTok(Lx);
1084      forever {
1085        Lx.GetSym();
1086        if (Lx.Sym==xsyETag){
1087          if (Tok->GetStr()==Lx.TagNm){
1088            break;
1089          } else {
1090            TStr MsgStr=TStr("Invalid End-Tag '")+Lx.TagNm+
1091             "' ('"+Tok->GetStr()+"' expected).";
1092            Lx.EThrow(MsgStr);
1093          }
1094        } else {
1095          PXmlTok SubTok;
1096          switch (Lx.Sym){
1097            case xsySTag:
1098              SubTok=LoadTxtElement(Lx); break;
1099            case xsySETag:
1100            case xsyStr:
1101            case xsyQStr:
1102            case xsyWs:
1103              SubTok=TXmlTok::GetTok(Lx); break;
1104            case xsyPI:
1105            case xsyComment:
1106              break;
1107            default: Lx.EThrow("Content or End-Tag expected.");
1108          }
1109          if (!SubTok.Empty()){
1110            Tok->AddSubTok(SubTok);}
1111        }
1112      }
1113    } else
1114    if (Lx.Sym==xsyETag){
1115      TStr MsgStr=
1116       TStr("Xml-Element (Start-Tag or Empty-Element-Tag) required.")+
1117       TStr::GetStr(Lx.TagNm, " End-Tag </%s> encountered.");
1118      Lx.EThrow(MsgStr);
1119    } else {
1120      Lx.EThrow("Xml-Element (Start-Tag or Empty-Element-Tag) required.");
1121    }
1122    return Tok;
1123  }
1124  PXmlTok TXmlDoc::GetTagTok(const TStr& TagPath) const {
1125    if (TagPath.Empty()){
1126      return Tok;
1127    } else {
1128      TStr TagNm; TStr RestTagPath; TagPath.SplitOnCh(TagNm, '|', RestTagPath);
1129      if ((Tok->GetSym()==xsyTag)&&(Tok->GetStr()==TagNm)){
1130        if (RestTagPath.Empty()){return Tok;}
1131        else {return Tok->GetTagTok(RestTagPath);}
1132      } else {
1133        return NULL;
1134      }
1135    }
1136  }
1137  void TXmlDoc::PutTagTokStr(const TStr& TagPath, const TStr& TokStr) const {
1138    PXmlTok Tok=GetTagTok(TagPath);
1139    Tok->ClrSubTok();
1140    PXmlTok StrTok=TXmlTok::New(xsyStr, TokStr);
1141    Tok->AddSubTok(StrTok);
1142  }
1143  void TXmlDoc::GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const {
1144    XmlTokV.Clr();
1145    TStr PreTagPath; TStr TagNm; TagPath.SplitOnLastCh(PreTagPath, '|', TagNm);
1146    PXmlTok Tok=GetTagTok(PreTagPath);
1147    if (!Tok.Empty()){
1148      for (int SubTokN=0; SubTokN<Tok->GetSubToks(); SubTokN++){
1149        PXmlTok SubTok=Tok->GetSubTok(SubTokN);
1150        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){
1151          XmlTokV.Add(SubTok);}
1152      }
1153    }
1154  }
1155  bool TXmlDoc::GetTagTokBoolArgVal(
1156   const TStr& TagPath, const TStr& ArgNm, const bool& DfVal) const {
1157    PXmlTok TagTok;
1158    if (IsTagTok(TagPath, TagTok)){
1159      return TagTok->GetBoolArgVal(ArgNm, DfVal);}
1160    else {return DfVal;}
1161  }
1162  int TXmlDoc::GetTagTokIntArgVal(
1163   const TStr& TagPath, const TStr& ArgNm, const int& DfVal) const {
1164    PXmlTok TagTok;
1165    if (IsTagTok(TagPath, TagTok)){
1166      return TagTok->GetIntArgVal(ArgNm, DfVal);}
1167    else {return DfVal;}
1168  }
1169  double TXmlDoc::GetTagTokFltArgVal(
1170   const TStr& TagPath, const TStr& ArgNm, const double& DfVal) const {
1171    PXmlTok TagTok;
1172    if (IsTagTok(TagPath, TagTok)){
1173      return TagTok->GetFltArgVal(ArgNm, DfVal);}
1174    else {return DfVal;}
1175  }
1176  TStr TXmlDoc::GetTagTokStrArgVal(
1177   const TStr& TagPath, const TStr& ArgNm, const TStr& DfVal) const {
1178    PXmlTok TagTok;
1179    if (IsTagTok(TagPath, TagTok)){
1180      return TagTok->GetStrArgVal(ArgNm, DfVal);}
1181    else {return DfVal;}
1182  }
1183  TStr TXmlDoc::GetXmlStr(const TStr& Str){
1184    TChA ChA=Str;
1185    TChA XmlChA;
1186    for (int ChN=0; ChN<ChA.Len(); ChN++){
1187      uchar Ch=ChA[ChN];
1188      if ((' '<=Ch)&&(Ch<='~')){
1189        if (Ch=='&'){XmlChA+="&amp;";}
1190        else if (Ch=='>'){XmlChA+="&lt;";}
1191        else if (Ch=='<'){XmlChA+="&gt;";}
1192        else if (Ch=='\''){XmlChA+="&apos;";}
1193        else if (Ch=='\"'){XmlChA+="&quot;";}
1194        else {XmlChA+=Ch;}
1195      } else {
1196        XmlChA+="&#"; XmlChA+=TUInt::GetStr(Ch); XmlChA+=";";
1197      }
1198    }
1199    return XmlChA;
1200  }
1201  bool TXmlDoc::SkipTopTag(const PSIn& SIn){
1202    bool Ok=true;
1203    TXmlLx Lx(SIn, xspIntact);
1204    try {
1205      Lx.GetSym();
1206      if (Lx.Sym==xsyXmlDecl){Lx.GetSym();}
1207      LoadTxtMiscStar(Lx);
1208      if (Lx.Sym==xsyDocTypeDecl){Lx.GetSym();}
1209      LoadTxtMiscStar(Lx);
1210      Ok=true;
1211    }
1212    catch (PExcept Except){
1213      Ok=false;
1214    }
1215    return Ok;
1216  }
1217  PXmlDoc TXmlDoc::LoadTxt(TXmlLx& Lx){
1218    PXmlDoc Doc=TXmlDoc::New();
1219    try {
1220      Lx.GetSym();
1221      if (Lx.Sym==xsyXmlDecl){Lx.GetSym();}
1222      LoadTxtMiscStar(Lx);
1223      if (Lx.Sym==xsyDocTypeDecl){Lx.GetSym();}
1224      LoadTxtMiscStar(Lx);
1225      Doc->Tok=LoadTxtElement(Lx);
1226      LoadTxtMiscStar(Lx);
1227      Doc->Ok=true; Doc->MsgStr="Ok";
1228    }
1229    catch (PExcept& Except){
1230      Doc->Ok=false; Doc->MsgStr=Except->GetMsgStr();
1231    }
1232    return Doc;
1233  }
1234  PXmlDoc TXmlDoc::LoadTxt(const PSIn& SIn, const TXmlSpacing& Spacing){
1235    TXmlLx Lx(SIn, Spacing); return LoadTxt(Lx);
1236  }
1237  PXmlDoc TXmlDoc::LoadTxt(const TStr& FNm, const TXmlSpacing& Spacing){
1238    PSIn SIn=TFIn::New(FNm); return LoadTxt(SIn, Spacing);
1239  }
1240  void TXmlDoc::LoadTxt(
1241   const TStr& FNm, TXmlDocV& XmlDocV, const TXmlSpacing& Spacing){
1242    XmlDocV.Clr();
1243    PSIn SIn=TFIn::New(FNm);
1244    TXmlLx Lx(SIn, Spacing);
1245    PXmlDoc XmlDoc;
1246    forever {
1247      Lx.SkipWs();
1248      XmlDoc=LoadTxt(Lx);
1249      if (XmlDoc->IsOk()){XmlDocV.Add(XmlDoc);}
1250      else {break;}
1251    }
1252  }
1253  PXmlDoc TXmlDoc::LoadStr(const TStr& Str){
1254    PSIn SIn=TStrIn::New(Str);
1255    return LoadTxt(SIn);
1256  }
1257  void TXmlDoc::SaveStr(TStr& Str){
1258    PSOut SOut=TMOut::New(); TMOut& MOut=*(TMOut*)SOut();
1259    SaveTxt(SOut);
1260    Str=MOut.GetAsStr();
1261  }
1262  TXmlLxSym TXmlParser::GetSym() {
1263    if (NextSym != xsyUndef) {
1264      Sym = NextSym;  NextSym=xsyUndef;
1265      SymStr=NextSymStr;  NextSymStr.Clr();
1266      return Sym;
1267    }
1268    SymStr.Clr();
1269    char Ch;
1270    while (TCh::IsWs(Ch=GetCh())) { }
1271    if (Ch == TCh::EofCh) { Sym = xsyEof; return xsyEof; }
1272    if (Ch == '<') { 
1273      Ch = GetCh();
1274      if (Ch == '/') { Sym = xsyETag; }
1275      else { Sym = xsySTag;  SymStr.Push(Ch); }
1276      while((Ch=GetCh())!='>' && Ch!=TCh::EofCh) { SymStr.Push(Ch); }
1277      const int StrLen = SymStr.Len();
1278      if (StrLen > 1 && SymStr[StrLen-1] == '/') {
1279        Sym = xsyETag; SymStr[StrLen-1] = 0;
1280        for (char *c = SymStr.CStr()+StrLen-2; TCh::IsWs(*c); c--) { *c=0; }
1281      }
1282    } else { 
1283      _SymStr.Clr();  _SymStr.Push(Ch);
1284      while (! RSIn.Eof() && RSIn.PeekCh() != '<') { _SymStr.Push(GetCh()); }
1285      GetPlainStrFromXmlStr(_SymStr, SymStr);
1286      Sym = xsyStr;
1287    }
1288    if (Ch == TCh::EofCh) { SymStr.Clr(); Sym = xsyEof; return xsyEof; }
1289    return Sym;
1290  }
1291  TXmlLxSym TXmlParser::GetSym(TChA& _SymStr) {
1292    GetSym();
1293    _SymStr = SymStr;
1294    return Sym;
1295  }
1296  TXmlLxSym TXmlParser::PeekSym() {
1297    if (NextSym == xsyUndef) {
1298      const TXmlLxSym TmpSim=Sym;
1299      const TChA TmpSymStr=SymStr;
1300      NextSym=GetSym(NextSymStr);
1301      Sym=TmpSim;
1302      SymStr=TmpSymStr;
1303    }
1304    return NextSym;
1305  }
1306  TXmlLxSym TXmlParser::PeekSym(TChA& _SymStr) {
1307    PeekSym();
1308    _SymStr = NextSymStr;
1309    return NextSym;
1310  }
1311  void TXmlParser::SkipTillTag(const TChA& _SymStr) {
1312    while(PeekSym() != xsyEof) {
1313      if (NextSymStr == _SymStr) { return; }
1314      GetSym();
1315    }
1316  }
1317  void TXmlParser::GetTagVal(const TChA& TagStr, TChA& TagVal) {
1318    EAssertR(GetTag(TagStr) == xsySTag, TStr::Fmt("Expected '<%s>'. Found '%s'", TagStr.CStr(), SymStr.CStr()).CStr());
1319    EAssertR(GetSym(TagVal) == xsyStr, "Expected string tag.");
1320    EAssertR(GetTag(TagStr) == xsyETag, TStr::Fmt("Expected '</%s>'. Found '%s'", TagStr.CStr(), SymStr.CStr()).CStr());
1321  }
1322  TXmlLxSym TXmlParser::GetTag(const TChA& TagStr) {
1323    GetSym();
1324    EAssertR(TagStr==SymStr, TStr::Fmt("Expected xml symbol '%s'. Found '%s'",
1325      TagStr.CStr(), SymStr.CStr()).CStr());
1326    return Sym;
1327  }
1328  void TXmlParser::GetPlainStrFromXmlStr(const TChA& XmlStr, TChA& PlainChA) {
1329    static TChA EntityNm;
1330    PlainChA.Clr();
1331    const char *Ch = XmlStr.CStr();
1332    while (*Ch){
1333      if (*Ch!='&'){ PlainChA+=*Ch; Ch++; }
1334      else {
1335        if (*++Ch=='#'){
1336          TChA RefChA; int RefCd=0;
1337          if (*++Ch=='x'){
1338            forever {  Ch++;
1339              if (TCh::IsHex(*Ch)){ RefChA+=*Ch;  RefCd=RefCd*16+TCh::GetHex(*Ch); }
1340              else { break; } }
1341          } else { 
1342            forever {
1343              if (TCh::IsNum(*Ch)){ RefChA+=*Ch; RefCd=RefCd*10+TCh::GetNum(*Ch); }
1344              else { break; } Ch++; }
1345          }
1346          if ((!RefChA.Empty())&&(*Ch==';')){
1347            Ch++;  const uchar RefCh=uchar(RefCd);  PlainChA+=RefCh; }
1348        } else {
1349          EntityNm.Clr();
1350          while ((*Ch)&&(*Ch!=';')){EntityNm+=*Ch; Ch++;}
1351          if ((!EntityNm.Empty())&&(*Ch==';')){  Ch++;
1352            if (EntityNm=="quot"){PlainChA+='"';}
1353            else if (EntityNm=="amp"){PlainChA+='&';}
1354            else if (EntityNm=="apos"){PlainChA+='\'';}
1355            else if (EntityNm=="lt"){PlainChA+='<';}
1356            else if (EntityNm=="gt"){PlainChA+='>';}
1357          }
1358        }
1359      }
1360    }
1361  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.cpp</div>
                </div>
                <div class="column column_space"><pre><code>808      uchar Ch=PlainMem[ChN];
809      if ((' '<=Ch)&&(Ch<='~')){
810        switch (Ch){
</pre></code></div>
                <div class="column column_space"><pre><code>808      uchar Ch=PlainMem[ChN];
809      if ((' '<=Ch)&&(Ch<='~')){
810        switch (Ch){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    