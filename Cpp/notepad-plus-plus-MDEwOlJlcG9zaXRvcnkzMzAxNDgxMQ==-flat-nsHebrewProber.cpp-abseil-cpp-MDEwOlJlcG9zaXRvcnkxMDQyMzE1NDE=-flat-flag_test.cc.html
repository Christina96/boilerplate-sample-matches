
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.2667876588021776%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-nsHebrewProber.cpp</h3>
            <pre><code>1  #include "nsHebrewProber.h"
2  #include <stdio.h>
3  #define FINAL_KAF ('\xea')
4  #define NORMAL_KAF ('\xeb')
5  #define FINAL_MEM ('\xed')
6  #define NORMAL_MEM ('\xee')
7  #define FINAL_NUN ('\xef')
8  #define NORMAL_NUN ('\xf0')
9  #define FINAL_PE ('\xf3')
10  #define NORMAL_PE ('\xf4')
11  #define FINAL_TSADI ('\xf5')
12  #define NORMAL_TSADI ('\xf6')
13  #define MIN_FINAL_CHAR_DISTANCE (5)
14  #define MIN_MODEL_DISTANCE (0.01)
15  #define VISUAL_HEBREW_NAME ("ISO-8859-8")
16  #define LOGICAL_HEBREW_NAME ("windows-1255")
17  PRBool nsHebrewProber::isFinal(char c)
18  {
19    return ((c == FINAL_KAF) || (c == FINAL_MEM) || (c == FINAL_NUN) || (c == FINAL_PE) || (c == FINAL_TSADI));
20  }
21  PRBool nsHebrewProber::isNonFinal(char c)
22  {
23    return ((c == NORMAL_KAF) || (c == NORMAL_MEM) || (c == NORMAL_NUN) || (c == NORMAL_PE));
24  }
25  nsProbingState nsHebrewProber::HandleData(const char* aBuf, PRUint32 aLen)
26  {
27    if (GetState() == eNotMe)
28      return eNotMe;
29    const char *curPtr, *endPtr = aBuf+aLen;
30    char cur;
31    for (curPtr = (char*)aBuf; curPtr < endPtr; ++curPtr)
32    {
33      cur = *curPtr;
34      if (cur == ' ') 
35      {
36        if (mBeforePrev != ' ') 
37        {
38          if (isFinal(mPrev)) 
39            ++mFinalCharLogicalScore;
40          else if (isNonFinal(mPrev)) 
41            ++mFinalCharVisualScore;
42        }
43      }
44      else  
45      {
46        if ((mBeforePrev == ' ') && (isFinal(mPrev)) && (cur != ' ')) 
47          ++mFinalCharVisualScore;
48      }
49      mBeforePrev = mPrev;
50      mPrev = cur;
51    }
52    return eDetecting;
53  }
54  const char* nsHebrewProber::GetCharSetName()
55  {
56    PRInt32 finalsub = mFinalCharLogicalScore - mFinalCharVisualScore;
57    if (finalsub >= MIN_FINAL_CHAR_DISTANCE) 
58      return LOGICAL_HEBREW_NAME;
59    if (finalsub <= -(MIN_FINAL_CHAR_DISTANCE))
60      return VISUAL_HEBREW_NAME;
<span onclick='openModal()' class='match'>61    float modelsub = mLogicalProb->GetConfidence() - mVisualProb->GetConfidence();
62    if (modelsub > MIN_MODEL_DISTANCE)
63      return LOGICAL_HEBREW_NAME;
64    if (modelsub < -(MIN_MODEL_DISTANCE))
65      return VISUAL_HEBREW_NAME;
66    if (finalsub < 0) 
67      return VISUAL_HEBREW_NAME;
68    return LOGICAL_HEBREW_NAME;
69  }
</span>70  void nsHebrewProber::Reset(void)
71  {
72    mFinalCharLogicalScore = 0;
73    mFinalCharVisualScore = 0;
74    mPrev = ' ';
75    mBeforePrev = ' ';
76  }
77  nsProbingState nsHebrewProber::GetState(void) 
78  {
79    if ((mLogicalProb->GetState() == eNotMe) && (mVisualProb->GetState() == eNotMe))
80      return eNotMe;
81    return eDetecting;
82  }
83  #ifdef DEBUG_chardet
84  void  nsHebrewProber::DumpStatus()
85  {
86    printf("  HEB: %d - %d [Logical-Visual score]\r\n", mFinalCharLogicalScore, mFinalCharVisualScore);
87  }
88  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_test.cc</h3>
            <pre><code>1  #include "absl/flags/flag.h"
2  #include <stddef.h>
3  #include <stdint.h>
4  #include <atomic>
5  #include <cmath>
6  #include <new>
7  #include <string>
8  #include <thread>  
9  #include <vector>
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/macros.h"
13  #include "absl/flags/config.h"
14  #include "absl/flags/declare.h"
15  #include "absl/flags/internal/flag.h"
16  #include "absl/flags/marshalling.h"
17  #include "absl/flags/reflection.h"
18  #include "absl/flags/usage_config.h"
19  #include "absl/strings/match.h"
20  #include "absl/strings/numbers.h"
21  #include "absl/strings/str_cat.h"
22  #include "absl/strings/str_split.h"
23  #include "absl/strings/string_view.h"
24  #include "absl/time/time.h"
25  ABSL_DECLARE_FLAG(int64_t, mistyped_int_flag);
26  ABSL_DECLARE_FLAG(std::vector<std::string>, mistyped_string_flag);
27  namespace {
28  namespace flags = absl::flags_internal;
29  std::string TestHelpMsg() { return "dynamic help"; }
30  #if defined(_MSC_VER) && !defined(__clang__)
31  std::string TestLiteralHelpMsg() { return "literal help"; }
32  #endif
33  template <typename T>
34  void TestMakeDflt(void* dst) {
35    new (dst) T{};
36  }
37  void TestCallback() {}
38  struct UDT {
39    UDT() = default;
40    UDT(const UDT&) = default;
41    UDT& operator=(const UDT&) = default;
42  };
43  bool AbslParseFlag(absl::string_view, UDT*, std::string*) { return true; }
44  std::string AbslUnparseFlag(const UDT&) { return ""; }
45  class FlagTest : public testing::Test {
46   protected:
47    static void SetUpTestSuite() {
48      absl::FlagsUsageConfig default_config;
49      default_config.normalize_filename = &FlagTest::NormalizeFileName;
50      absl::SetFlagsUsageConfig(default_config);
51    }
52   private:
53    static std::string NormalizeFileName(absl::string_view fname) {
54  #ifdef _WIN32
55      std::string normalized(fname);
56      std::replace(normalized.begin(), normalized.end(), '\\', '/');
57      fname = normalized;
58  #endif
59      return std::string(fname);
60    }
61    absl::FlagSaver flag_saver_;
62  };
63  struct S1 {
64    S1() = default;
65    S1(const S1&) = default;
66    int32_t f1;
67    int64_t f2;
68  };
69  struct S2 {
70    S2() = default;
71    S2(const S2&) = default;
72    int64_t f1;
73    double f2;
74  };
75  TEST_F(FlagTest, Traits) {
76    EXPECT_EQ(flags::StorageKind<int>(),
77              flags::FlagValueStorageKind::kValueAndInitBit);
78    EXPECT_EQ(flags::StorageKind<bool>(),
79              flags::FlagValueStorageKind::kValueAndInitBit);
80    EXPECT_EQ(flags::StorageKind<double>(),
81              flags::FlagValueStorageKind::kOneWordAtomic);
82    EXPECT_EQ(flags::StorageKind<int64_t>(),
83              flags::FlagValueStorageKind::kOneWordAtomic);
84    EXPECT_EQ(flags::StorageKind<S1>(),
85              flags::FlagValueStorageKind::kSequenceLocked);
86    EXPECT_EQ(flags::StorageKind<S2>(),
87              flags::FlagValueStorageKind::kSequenceLocked);
88  #ifdef __clang__
89    EXPECT_EQ(flags::StorageKind<absl::Duration>(),
90              flags::FlagValueStorageKind::kSequenceLocked);
91  #endif
92    EXPECT_EQ(flags::StorageKind<std::string>(),
93              flags::FlagValueStorageKind::kAlignedBuffer);
94    EXPECT_EQ(flags::StorageKind<std::vector<std::string>>(),
95              flags::FlagValueStorageKind::kAlignedBuffer);
96  }
97  constexpr flags::FlagHelpArg help_arg{flags::FlagHelpMsg("literal help"),
98                                        flags::FlagHelpKind::kLiteral};
99  using String = std::string;
100  #if !defined(_MSC_VER) || defined(__clang__)
101  #define DEFINE_CONSTRUCTED_FLAG(T, dflt, dflt_kind)                        \
102    constexpr flags::FlagDefaultArg f1default##T{                            \
103        flags::FlagDefaultSrc{dflt}, flags::FlagDefaultKind::dflt_kind};     \
104    constexpr absl::Flag<T> f1##T{"f1", "file", help_arg, f1default##T};     \
105    ABSL_CONST_INIT absl::Flag<T> f2##T {                                    \
106      "f2", "file",                                                          \
107          {flags::FlagHelpMsg(&TestHelpMsg), flags::FlagHelpKind::kGenFunc}, \
108          flags::FlagDefaultArg {                                            \
109        flags::FlagDefaultSrc(&TestMakeDflt<T>),                             \
110            flags::FlagDefaultKind::kGenFunc                                 \
111      }                                                                      \
112    }
113  #else
114  #define DEFINE_CONSTRUCTED_FLAG(T, dflt, dflt_kind)                    \
115    constexpr flags::FlagDefaultArg f1default##T{                        \
116        flags::FlagDefaultSrc{dflt}, flags::FlagDefaultKind::dflt_kind}; \
117    constexpr absl::Flag<T> f1##T{"f1", "file", &TestLiteralHelpMsg,     \
118                                  &TestMakeDflt<T>};                     \
119    ABSL_CONST_INIT absl::Flag<T> f2##T {                                \
120      "f2", "file", &TestHelpMsg, &TestMakeDflt<T>                       \
121    }
122  #endif
123  DEFINE_CONSTRUCTED_FLAG(bool, true, kOneWord);
124  DEFINE_CONSTRUCTED_FLAG(int16_t, 1, kOneWord);
125  DEFINE_CONSTRUCTED_FLAG(uint16_t, 2, kOneWord);
126  DEFINE_CONSTRUCTED_FLAG(int32_t, 3, kOneWord);
127  DEFINE_CONSTRUCTED_FLAG(uint32_t, 4, kOneWord);
128  DEFINE_CONSTRUCTED_FLAG(int64_t, 5, kOneWord);
129  DEFINE_CONSTRUCTED_FLAG(uint64_t, 6, kOneWord);
130  DEFINE_CONSTRUCTED_FLAG(float, 7.8, kOneWord);
131  DEFINE_CONSTRUCTED_FLAG(double, 9.10, kOneWord);
132  DEFINE_CONSTRUCTED_FLAG(String, &TestMakeDflt<String>, kGenFunc);
133  DEFINE_CONSTRUCTED_FLAG(UDT, &TestMakeDflt<UDT>, kGenFunc);
134  template <typename T>
135  bool TestConstructionFor(const absl::Flag<T>& f1, absl::Flag<T>& f2) {
136    EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Name(), "f1");
137    EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Help(), "literal help");
138    EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Filename(), "file");
139    flags::FlagRegistrar<T, false>(ABSL_FLAG_IMPL_FLAG_PTR(f2), nullptr)
140        .OnUpdate(TestCallback);
141    EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Name(), "f2");
142    EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Help(), "dynamic help");
143    EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Filename(), "file");
144    return true;
145  }
146  #define TEST_CONSTRUCTED_FLAG(T) TestConstructionFor(f1##T, f2##T);
147  TEST_F(FlagTest, TestConstruction) {
148    TEST_CONSTRUCTED_FLAG(bool);
149    TEST_CONSTRUCTED_FLAG(int16_t);
150    TEST_CONSTRUCTED_FLAG(uint16_t);
151    TEST_CONSTRUCTED_FLAG(int32_t);
152    TEST_CONSTRUCTED_FLAG(uint32_t);
153    TEST_CONSTRUCTED_FLAG(int64_t);
154    TEST_CONSTRUCTED_FLAG(uint64_t);
155    TEST_CONSTRUCTED_FLAG(float);
156    TEST_CONSTRUCTED_FLAG(double);
157    TEST_CONSTRUCTED_FLAG(String);
158    TEST_CONSTRUCTED_FLAG(UDT);
159  }
160  }  
161  ABSL_DECLARE_FLAG(bool, test_flag_01);
162  ABSL_DECLARE_FLAG(int, test_flag_02);
163  ABSL_DECLARE_FLAG(int16_t, test_flag_03);
164  ABSL_DECLARE_FLAG(uint16_t, test_flag_04);
165  ABSL_DECLARE_FLAG(int32_t, test_flag_05);
166  ABSL_DECLARE_FLAG(uint32_t, test_flag_06);
167  ABSL_DECLARE_FLAG(int64_t, test_flag_07);
168  ABSL_DECLARE_FLAG(uint64_t, test_flag_08);
169  ABSL_DECLARE_FLAG(double, test_flag_09);
170  ABSL_DECLARE_FLAG(float, test_flag_10);
171  ABSL_DECLARE_FLAG(std::string, test_flag_11);
172  ABSL_DECLARE_FLAG(absl::Duration, test_flag_12);
173  namespace {
174  #if !ABSL_FLAGS_STRIP_NAMES
175  TEST_F(FlagTest, TestFlagDeclaration) {
176    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Name(),
177              "test_flag_01");
178    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Name(),
179              "test_flag_02");
180    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Name(),
181              "test_flag_03");
182    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Name(),
183              "test_flag_04");
184    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Name(),
185              "test_flag_05");
186    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Name(),
187              "test_flag_06");
188    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Name(),
189              "test_flag_07");
190    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Name(),
191              "test_flag_08");
192    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Name(),
193              "test_flag_09");
194    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Name(),
195              "test_flag_10");
196    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Name(),
197              "test_flag_11");
198    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Name(),
199              "test_flag_12");
200  }
201  #endif  
202  }  
203  ABSL_FLAG(bool, test_flag_01, true, "test flag 01");
204  ABSL_FLAG(int, test_flag_02, 1234, "test flag 02");
205  ABSL_FLAG(int16_t, test_flag_03, -34, "test flag 03");
206  ABSL_FLAG(uint16_t, test_flag_04, 189, "test flag 04");
207  ABSL_FLAG(int32_t, test_flag_05, 10765, "test flag 05");
208  ABSL_FLAG(uint32_t, test_flag_06, 40000, "test flag 06");
209  ABSL_FLAG(int64_t, test_flag_07, -1234567, "test flag 07");
210  ABSL_FLAG(uint64_t, test_flag_08, 9876543, "test flag 08");
211  ABSL_FLAG(double, test_flag_09, -9.876e-50, "test flag 09");
212  ABSL_FLAG(float, test_flag_10, 1.234e12f, "test flag 10");
213  ABSL_FLAG(std::string, test_flag_11, "", "test flag 11");
214  ABSL_FLAG(absl::Duration, test_flag_12, absl::Minutes(10), "test flag 12");
215  namespace {
216  #if !ABSL_FLAGS_STRIP_NAMES
217  TEST_F(FlagTest, TestFlagDefinition) {
218    absl::string_view expected_file_name = "absl/flags/flag_test.cc";
219    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Name(),
220              "test_flag_01");
221    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Help(),
222              "test flag 01");
223    EXPECT_TRUE(absl::EndsWith(
224        absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Filename(),
225        expected_file_name))
226        << absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Filename();
227    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Name(),
228              "test_flag_02");
229    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Help(),
230              "test flag 02");
231    EXPECT_TRUE(absl::EndsWith(
232        absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Filename(),
233        expected_file_name))
234        << absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Filename();
235    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Name(),
236              "test_flag_03");
237    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Help(),
238              "test flag 03");
239    EXPECT_TRUE(absl::EndsWith(
240        absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Filename(),
241        expected_file_name))
242        << absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Filename();
243    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Name(),
244              "test_flag_04");
245    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Help(),
246              "test flag 04");
247    EXPECT_TRUE(absl::EndsWith(
248        absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Filename(),
249        expected_file_name))
250        << absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Filename();
251    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Name(),
252              "test_flag_05");
253    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Help(),
254              "test flag 05");
255    EXPECT_TRUE(absl::EndsWith(
256        absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Filename(),
257        expected_file_name))
258        << absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Filename();
259    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Name(),
260              "test_flag_06");
261    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Help(),
262              "test flag 06");
263    EXPECT_TRUE(absl::EndsWith(
264        absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Filename(),
265        expected_file_name))
266        << absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Filename();
267    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Name(),
268              "test_flag_07");
269    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Help(),
270              "test flag 07");
271    EXPECT_TRUE(absl::EndsWith(
272        absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Filename(),
273        expected_file_name))
274        << absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Filename();
275    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Name(),
276              "test_flag_08");
277    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Help(),
278              "test flag 08");
279    EXPECT_TRUE(absl::EndsWith(
280        absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Filename(),
281        expected_file_name))
282        << absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Filename();
283    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Name(),
284              "test_flag_09");
285    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Help(),
286              "test flag 09");
287    EXPECT_TRUE(absl::EndsWith(
288        absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Filename(),
289        expected_file_name))
290        << absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Filename();
291    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Name(),
292              "test_flag_10");
293    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Help(),
294              "test flag 10");
295    EXPECT_TRUE(absl::EndsWith(
296        absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Filename(),
297        expected_file_name))
298        << absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Filename();
299    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Name(),
300              "test_flag_11");
301    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Help(),
302              "test flag 11");
303    EXPECT_TRUE(absl::EndsWith(
304        absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Filename(),
305        expected_file_name))
306        << absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Filename();
307    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Name(),
308              "test_flag_12");
309    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Help(),
310              "test flag 12");
311    EXPECT_TRUE(absl::EndsWith(
312        absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Filename(),
313        expected_file_name))
314        << absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Filename();
315  }
316  #endif  
317  TEST_F(FlagTest, TestDefault) {
318    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).DefaultValue(),
319              "true");
320    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).DefaultValue(),
321              "1234");
322    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).DefaultValue(),
323              "-34");
324    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).DefaultValue(),
325              "189");
326    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).DefaultValue(),
327              "10765");
328    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).DefaultValue(),
329              "40000");
330    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).DefaultValue(),
331              "-1234567");
332    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).DefaultValue(),
333              "9876543");
334    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).DefaultValue(),
335              "-9.876e-50");
336    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).DefaultValue(),
337              "1.234e+12");
338    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).DefaultValue(),
339              "");
340    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).DefaultValue(),
341              "10m");
342    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).CurrentValue(),
343              "true");
344    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).CurrentValue(),
345              "1234");
346    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).CurrentValue(),
347              "-34");
348    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).CurrentValue(),
349              "189");
350    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).CurrentValue(),
351              "10765");
352    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).CurrentValue(),
353              "40000");
354    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).CurrentValue(),
355              "-1234567");
356    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).CurrentValue(),
357              "9876543");
358    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).CurrentValue(),
359              "-9.876e-50");
360    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).CurrentValue(),
361              "1.234e+12");
362    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).CurrentValue(),
363              "");
364    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).CurrentValue(),
365              "10m");
366    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
367    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
368    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
369    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
370    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
371    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
372    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
373    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
374    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
375    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
376    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
377    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
378  }
379  struct NonTriviallyCopyableAggregate {
380    NonTriviallyCopyableAggregate() = default;
381    NonTriviallyCopyableAggregate(const NonTriviallyCopyableAggregate& rhs)
382        : value(rhs.value) {}
383    NonTriviallyCopyableAggregate& operator=(
384        const NonTriviallyCopyableAggregate& rhs) {
385      value = rhs.value;
386      return *this;
387    }
388    int value;
389  };
390  bool AbslParseFlag(absl::string_view src, NonTriviallyCopyableAggregate* f,
391                     std::string* e) {
392    return absl::ParseFlag(src, &f->value, e);
393  }
394  std::string AbslUnparseFlag(const NonTriviallyCopyableAggregate& ntc) {
395    return absl::StrCat(ntc.value);
396  }
397  bool operator==(const NonTriviallyCopyableAggregate& ntc1,
398                  const NonTriviallyCopyableAggregate& ntc2) {
399    return ntc1.value == ntc2.value;
400  }
401  }  
402  ABSL_FLAG(bool, test_flag_eb_01, {}, "");
403  ABSL_FLAG(int32_t, test_flag_eb_02, {}, "");
404  ABSL_FLAG(int64_t, test_flag_eb_03, {}, "");
405  ABSL_FLAG(double, test_flag_eb_04, {}, "");
406  ABSL_FLAG(std::string, test_flag_eb_05, {}, "");
407  ABSL_FLAG(NonTriviallyCopyableAggregate, test_flag_eb_06, {}, "");
408  namespace {
409  TEST_F(FlagTest, TestEmptyBracesDefault) {
410    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_01).DefaultValue(),
411              "false");
412    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_02).DefaultValue(),
413              "0");
414    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_03).DefaultValue(),
415              "0");
416    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_04).DefaultValue(),
417              "0");
418    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_05).DefaultValue(),
419              "");
420    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_06).DefaultValue(),
421              "0");
422    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_01), false);
423    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_02), 0);
424    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_03), 0);
425    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_04), 0.0);
426    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_05), "");
427    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_06),
428              NonTriviallyCopyableAggregate{});
429  }
430  TEST_F(FlagTest, TestGetSet) {
431    absl::SetFlag(&FLAGS_test_flag_01, false);
432    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), false);
433    absl::SetFlag(&FLAGS_test_flag_02, 321);
434    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 321);
435    absl::SetFlag(&FLAGS_test_flag_03, 67);
436    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), 67);
437    absl::SetFlag(&FLAGS_test_flag_04, 1);
438    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 1);
439    absl::SetFlag(&FLAGS_test_flag_05, -908);
440    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), -908);
441    absl::SetFlag(&FLAGS_test_flag_06, 4001);
442    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 4001);
443    absl::SetFlag(&FLAGS_test_flag_07, -23456);
444    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -23456);
445    absl::SetFlag(&FLAGS_test_flag_08, 975310);
446    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 975310);
447    absl::SetFlag(&FLAGS_test_flag_09, 1.00001);
448    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), 1.00001, 1e-10);
449    absl::SetFlag(&FLAGS_test_flag_10, -3.54f);
450    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), -3.54f, 1e-6f);
451    absl::SetFlag(&FLAGS_test_flag_11, "asdf");
452    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "asdf");
453    absl::SetFlag(&FLAGS_test_flag_12, absl::Seconds(110));
454    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Seconds(110));
455  }
456  TEST_F(FlagTest, TestGetViaReflection) {
457    auto* handle = absl::FindCommandLineFlag("test_flag_01");
458    EXPECT_EQ(*handle->TryGet<bool>(), true);
459    handle = absl::FindCommandLineFlag("test_flag_02");
460    EXPECT_EQ(*handle->TryGet<int>(), 1234);
461    handle = absl::FindCommandLineFlag("test_flag_03");
462    EXPECT_EQ(*handle->TryGet<int16_t>(), -34);
463    handle = absl::FindCommandLineFlag("test_flag_04");
464    EXPECT_EQ(*handle->TryGet<uint16_t>(), 189);
465    handle = absl::FindCommandLineFlag("test_flag_05");
466    EXPECT_EQ(*handle->TryGet<int32_t>(), 10765);
467    handle = absl::FindCommandLineFlag("test_flag_06");
468    EXPECT_EQ(*handle->TryGet<uint32_t>(), 40000);
469    handle = absl::FindCommandLineFlag("test_flag_07");
470    EXPECT_EQ(*handle->TryGet<int64_t>(), -1234567);
471    handle = absl::FindCommandLineFlag("test_flag_08");
472    EXPECT_EQ(*handle->TryGet<uint64_t>(), 9876543);
473    handle = absl::FindCommandLineFlag("test_flag_09");
474    EXPECT_NEAR(*handle->TryGet<double>(), -9.876e-50, 1e-55);
475    handle = absl::FindCommandLineFlag("test_flag_10");
476    EXPECT_NEAR(*handle->TryGet<float>(), 1.234e12f, 1e5f);
477    handle = absl::FindCommandLineFlag("test_flag_11");
478    EXPECT_EQ(*handle->TryGet<std::string>(), "");
479    handle = absl::FindCommandLineFlag("test_flag_12");
480    EXPECT_EQ(*handle->TryGet<absl::Duration>(), absl::Minutes(10));
481  }
482  TEST_F(FlagTest, ConcurrentSetAndGet) {
483    static constexpr int kNumThreads = 8;
484    static const absl::Duration kValidDurations[] = {
485        absl::Seconds(int64_t{0x6cebf47a9b68c802}) + absl::Nanoseconds(229702057),
486        absl::Seconds(int64_t{0x23fec0307e4e9d3}) + absl::Nanoseconds(44555374)};
487    absl::SetFlag(&FLAGS_test_flag_12, kValidDurations[0]);
488    std::atomic<bool> stop{false};
489    std::vector<std::thread> threads;
490    auto* handle = absl::FindCommandLineFlag("test_flag_12");
491    for (int i = 0; i < kNumThreads; i++) {
492      threads.emplace_back([&]() {
493        while (!stop.load(std::memory_order_relaxed)) {
494          absl::Duration v = absl::GetFlag(FLAGS_test_flag_12);
495          EXPECT_TRUE(v == kValidDurations[0] || v == kValidDurations[1]);
496          v = *handle->TryGet<absl::Duration>();
497          EXPECT_TRUE(v == kValidDurations[0] || v == kValidDurations[1]);
498        }
499      });
500    }
501    absl::Time end_time = absl::Now() + absl::Seconds(1);
502    int i = 0;
503    while (absl::Now() < end_time) {
504      absl::SetFlag(&FLAGS_test_flag_12,
505                    kValidDurations[i++ % ABSL_ARRAYSIZE(kValidDurations)]);
506    }
507    stop.store(true, std::memory_order_relaxed);
508    for (auto& t : threads) t.join();
509  }
510  int GetDflt1() { return 1; }
511  }  
512  ABSL_FLAG(int, test_int_flag_with_non_const_default, GetDflt1(),
513            "test int flag non const default");
514  ABSL_FLAG(std::string, test_string_flag_with_non_const_default,
515            absl::StrCat("AAA", "BBB"), "test string flag non const default");
516  namespace {
517  TEST_F(FlagTest, TestNonConstexprDefault) {
518    EXPECT_EQ(absl::GetFlag(FLAGS_test_int_flag_with_non_const_default), 1);
519    EXPECT_EQ(absl::GetFlag(FLAGS_test_string_flag_with_non_const_default),
520              "AAABBB");
521  }
522  }  
523  ABSL_FLAG(bool, test_flag_with_non_const_help, true,
524            absl::StrCat("test ", "flag ", "non const help"));
525  namespace {
526  #if !ABSL_FLAGS_STRIP_HELP
527  TEST_F(FlagTest, TestNonConstexprHelp) {
528    EXPECT_EQ(
529        absl::GetFlagReflectionHandle(FLAGS_test_flag_with_non_const_help).Help(),
530        "test flag non const help");
531  }
532  #endif  
533  int cb_test_value = -1;
534  void TestFlagCB();
535  }  
536  ABSL_FLAG(int, test_flag_with_cb, 100, "").OnUpdate(TestFlagCB);
537  ABSL_FLAG(int, test_flag_with_lambda_cb, 200, "").OnUpdate([]() {
538    cb_test_value = absl::GetFlag(FLAGS_test_flag_with_lambda_cb) +
539                    absl::GetFlag(FLAGS_test_flag_with_cb);
540  });
541  namespace {
542  void TestFlagCB() { cb_test_value = absl::GetFlag(FLAGS_test_flag_with_cb); }
543  TEST_F(FlagTest, CallbackInvocation) {
544    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_with_cb), 100);
545    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_with_lambda_cb), 200);
546    EXPECT_EQ(cb_test_value, 300);
547    absl::SetFlag(&FLAGS_test_flag_with_cb, 1);
548    EXPECT_EQ(cb_test_value, 1);
549    absl::SetFlag(&FLAGS_test_flag_with_lambda_cb, 3);
550    EXPECT_EQ(cb_test_value, 4);
551  }
552  struct CustomUDT {
553    CustomUDT() : a(1), b(1) {}
554    CustomUDT(int a_, int b_) : a(a_), b(b_) {}
555    friend bool operator==(const CustomUDT& f1, const CustomUDT& f2) {
556      return f1.a == f2.a && f1.b == f2.b;
557    }
558    int a;
559    int b;
560  };
561  bool AbslParseFlag(absl::string_view in, CustomUDT* f, std::string*) {
<span onclick='openModal()' class='match'>562    std::vector<absl::string_view> parts =
563        absl::StrSplit(in, ':', absl::SkipWhitespace());
564    if (parts.size() != 2) return false;
565    if (!absl::SimpleAtoi(parts[0], &f->a)) return false;
566    if (!absl::SimpleAtoi(parts[1], &f->b)) return false;
567    return true;
568  }
</span>569  std::string AbslUnparseFlag(const CustomUDT& f) {
570    return absl::StrCat(f.a, ":", f.b);
571  }
572  }  
573  ABSL_FLAG(CustomUDT, test_flag_custom_udt, CustomUDT(), "test flag custom UDT");
574  namespace {
575  TEST_F(FlagTest, TestCustomUDT) {
576    EXPECT_EQ(flags::StorageKind<CustomUDT>(),
577              flags::FlagValueStorageKind::kOneWordAtomic);
578    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_custom_udt), CustomUDT(1, 1));
579    absl::SetFlag(&FLAGS_test_flag_custom_udt, CustomUDT(2, 3));
580    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_custom_udt), CustomUDT(2, 3));
581  }
582  #if !defined(_WIN32) && GTEST_HAS_DEATH_TEST
583  using FlagDeathTest = FlagTest;
584  TEST_F(FlagDeathTest, TestTypeMismatchValidations) {
585  #if !defined(NDEBUG)
586    EXPECT_DEATH_IF_SUPPORTED(
587        static_cast<void>(absl::GetFlag(FLAGS_mistyped_int_flag)),
588        "Flag 'mistyped_int_flag' is defined as one type and declared "
589        "as another");
590    EXPECT_DEATH_IF_SUPPORTED(
591        static_cast<void>(absl::GetFlag(FLAGS_mistyped_string_flag)),
592        "Flag 'mistyped_string_flag' is defined as one type and "
593        "declared as another");
594  #endif
595    EXPECT_DEATH_IF_SUPPORTED(
596        absl::SetFlag(&FLAGS_mistyped_int_flag, 1),
597        "Flag 'mistyped_int_flag' is defined as one type and declared "
598        "as another");
599    EXPECT_DEATH_IF_SUPPORTED(
600        absl::SetFlag(&FLAGS_mistyped_string_flag, std::vector<std::string>{}),
601        "Flag 'mistyped_string_flag' is defined as one type and declared as "
602        "another");
603  }
604  #endif
605  struct ConversionTestVal {
606    ConversionTestVal() = default;
607    explicit ConversionTestVal(int a_in) : a(a_in) {}
608    enum class ViaImplicitConv { kTen = 10, kEleven };
609    ConversionTestVal(ViaImplicitConv from) : a(static_cast<int>(from)) {}
610    int a;
611  };
612  bool AbslParseFlag(absl::string_view in, ConversionTestVal* val_out,
613                     std::string*) {
614    if (!absl::SimpleAtoi(in, &val_out->a)) {
615      return false;
616    }
617    return true;
618  }
619  std::string AbslUnparseFlag(const ConversionTestVal& val) {
620    return absl::StrCat(val.a);
621  }
622  }  
623  ABSL_FLAG(ConversionTestVal, test_flag_implicit_conv,
624            ConversionTestVal::ViaImplicitConv::kTen,
625            "test flag init via implicit conversion");
626  namespace {
627  TEST_F(FlagTest, CanSetViaImplicitConversion) {
628    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_implicit_conv).a, 10);
629    absl::SetFlag(&FLAGS_test_flag_implicit_conv,
630                  ConversionTestVal::ViaImplicitConv::kEleven);
631    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_implicit_conv).a, 11);
632  }
633  struct NonDfltConstructible {
634   public:
635    NonDfltConstructible(int i) : value(i) {}  
636    explicit NonDfltConstructible(char c) : value(100 + static_cast<int>(c)) {}
637    int value;
638  };
639  bool AbslParseFlag(absl::string_view in, NonDfltConstructible* ndc_out,
640                     std::string*) {
641    return absl::SimpleAtoi(in, &ndc_out->value);
642  }
643  std::string AbslUnparseFlag(const NonDfltConstructible& ndc) {
644    return absl::StrCat(ndc.value);
645  }
646  }  
647  ABSL_FLAG(NonDfltConstructible, ndc_flag1, NonDfltConstructible('1'),
648            "Flag with non default constructible type");
649  ABSL_FLAG(NonDfltConstructible, ndc_flag2, 0,
650            "Flag with non default constructible type");
651  namespace {
652  TEST_F(FlagTest, TestNonDefaultConstructibleType) {
653    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag1).value, '1' + 100);
654    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag2).value, 0);
655    absl::SetFlag(&FLAGS_ndc_flag1, NonDfltConstructible('A'));
656    absl::SetFlag(&FLAGS_ndc_flag2, 25);
657    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag1).value, 'A' + 100);
658    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag2).value, 25);
659  }
660  }  
661  ABSL_RETIRED_FLAG(bool, old_bool_flag, true, "old descr");
662  ABSL_RETIRED_FLAG(int, old_int_flag, (int)std::sqrt(10), "old descr");
663  ABSL_RETIRED_FLAG(std::string, old_str_flag, "", absl::StrCat("old ", "descr"));
664  namespace {
665  bool initialization_order_fiasco_test ABSL_ATTRIBUTE_UNUSED = [] {
666    auto* handle1 = absl::FindCommandLineFlag("flag_on_separate_file");
667    auto* handle2 = absl::FindCommandLineFlag("retired_flag_on_separate_file");
668    if (handle1 != nullptr && handle2 != nullptr) {
669      return handle1->Name() == handle2->Name();
670    }
671    return true;
672  }();
673  TEST_F(FlagTest, TestRetiredFlagRegistration) {
674    auto* handle = absl::FindCommandLineFlag("old_bool_flag");
675    EXPECT_TRUE(handle->IsOfType<bool>());
676    EXPECT_TRUE(handle->IsRetired());
677    handle = absl::FindCommandLineFlag("old_int_flag");
678    EXPECT_TRUE(handle->IsOfType<int>());
679    EXPECT_TRUE(handle->IsRetired());
680    handle = absl::FindCommandLineFlag("old_str_flag");
681    EXPECT_TRUE(handle->IsOfType<std::string>());
682    EXPECT_TRUE(handle->IsRetired());
683  }
684  }  
685  namespace {
686  struct SmallAlignUDT {
687    SmallAlignUDT() : c('A'), s(12) {}
688    char c;
689    int16_t s;
690    char bytes[14];
691  };
692  bool AbslParseFlag(absl::string_view, SmallAlignUDT*, std::string*) {
693    return true;
694  }
695  std::string AbslUnparseFlag(const SmallAlignUDT&) { return ""; }
696  struct NonTriviallyCopyableUDT {
697    NonTriviallyCopyableUDT() : c('A') {}
698    NonTriviallyCopyableUDT(const NonTriviallyCopyableUDT& rhs) : c(rhs.c) {}
699    NonTriviallyCopyableUDT& operator=(const NonTriviallyCopyableUDT& rhs) {
700      c = rhs.c;
701      return *this;
702    }
703    char c;
704  };
705  bool AbslParseFlag(absl::string_view, NonTriviallyCopyableUDT*, std::string*) {
706    return true;
707  }
708  std::string AbslUnparseFlag(const NonTriviallyCopyableUDT&) { return ""; }
709  }  
710  ABSL_FLAG(SmallAlignUDT, test_flag_sa_udt, {}, "help");
711  ABSL_FLAG(NonTriviallyCopyableUDT, test_flag_ntc_udt, {}, "help");
712  namespace {
713  TEST_F(FlagTest, TestSmallAlignUDT) {
714    SmallAlignUDT value = absl::GetFlag(FLAGS_test_flag_sa_udt);
715    EXPECT_EQ(value.c, 'A');
716    EXPECT_EQ(value.s, 12);
717    value.c = 'B';
718    value.s = 45;
719    absl::SetFlag(&FLAGS_test_flag_sa_udt, value);
720    value = absl::GetFlag(FLAGS_test_flag_sa_udt);
721    EXPECT_EQ(value.c, 'B');
722    EXPECT_EQ(value.s, 45);
723  }
724  TEST_F(FlagTest, TestNonTriviallyCopyableUDT) {
725    NonTriviallyCopyableUDT value = absl::GetFlag(FLAGS_test_flag_ntc_udt);
726    EXPECT_EQ(value.c, 'A');
727    value.c = 'B';
728    absl::SetFlag(&FLAGS_test_flag_ntc_udt, value);
729    value = absl::GetFlag(FLAGS_test_flag_ntc_udt);
730    EXPECT_EQ(value.c, 'B');
731  }
732  }  
733  namespace {
734  enum TestE { A = 1, B = 2, C = 3 };
735  struct EnumWrapper {
736    EnumWrapper() : e(A) {}
737    TestE e;
738  };
739  bool AbslParseFlag(absl::string_view, EnumWrapper*, std::string*) {
740    return true;
741  }
742  std::string AbslUnparseFlag(const EnumWrapper&) { return ""; }
743  }  
744  ABSL_FLAG(EnumWrapper, test_enum_wrapper_flag, {}, "help");
745  TEST_F(FlagTest, TesTypeWrappingEnum) {
746    EnumWrapper value = absl::GetFlag(FLAGS_test_enum_wrapper_flag);
747    EXPECT_EQ(value.e, A);
748    value.e = B;
749    absl::SetFlag(&FLAGS_test_enum_wrapper_flag, value);
750    value = absl::GetFlag(FLAGS_test_enum_wrapper_flag);
751    EXPECT_EQ(value.e, B);
752  }
753  #define FLAG_NAME_MACRO(name) prefix_ ## name
754  ABSL_DECLARE_FLAG(int, FLAG_NAME_MACRO(test_macro_named_flag));
755  ABSL_FLAG(int, FLAG_NAME_MACRO(test_macro_named_flag), 0,
756            "Testing macro expansion within ABSL_FLAG");
757  TEST_F(FlagTest, MacroWithinAbslFlag) {
758    EXPECT_EQ(absl::GetFlag(FLAGS_prefix_test_macro_named_flag), 0);
759    absl::SetFlag(&FLAGS_prefix_test_macro_named_flag, 1);
760    EXPECT_EQ(absl::GetFlag(FLAGS_prefix_test_macro_named_flag), 1);
761  }
762  #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
763  #define ABSL_SKIP_OPTIONAL_BOOL_TEST_DUE_TO_GCC_BUG
764  #endif
765  #ifndef ABSL_SKIP_OPTIONAL_BOOL_TEST_DUE_TO_GCC_BUG
766  ABSL_FLAG(absl::optional<bool>, optional_bool, absl::nullopt, "help");
767  #endif
768  ABSL_FLAG(absl::optional<int>, optional_int, {}, "help");
769  ABSL_FLAG(absl::optional<double>, optional_double, 9.3, "help");
770  ABSL_FLAG(absl::optional<std::string>, optional_string, absl::nullopt, "help");
771  ABSL_FLAG(absl::optional<absl::Duration>, optional_duration, absl::nullopt,
772            "help");
773  ABSL_FLAG(absl::optional<absl::optional<int>>, optional_optional_int,
774            absl::nullopt, "help");
775  #if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
776  ABSL_FLAG(std::optional<int64_t>, std_optional_int64, std::nullopt, "help");
777  #endif
778  namespace {
779  #ifndef ABSL_SKIP_OPTIONAL_BOOL_TEST_DUE_TO_GCC_BUG
780  TEST_F(FlagTest, TestOptionalBool) {
781    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_bool).has_value());
782    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), absl::nullopt);
783    absl::SetFlag(&FLAGS_optional_bool, false);
784    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_bool).has_value());
785    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), false);
786    absl::SetFlag(&FLAGS_optional_bool, true);
787    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_bool).has_value());
788    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), true);
789    absl::SetFlag(&FLAGS_optional_bool, absl::nullopt);
790    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_bool).has_value());
791    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), absl::nullopt);
792  }
793  #endif
794  TEST_F(FlagTest, TestOptionalInt) {
795    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_int).has_value());
796    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), absl::nullopt);
797    absl::SetFlag(&FLAGS_optional_int, 0);
798    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_int).has_value());
799    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), 0);
800    absl::SetFlag(&FLAGS_optional_int, 10);
801    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_int).has_value());
802    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), 10);
803    absl::SetFlag(&FLAGS_optional_int, absl::nullopt);
804    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_int).has_value());
805    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), absl::nullopt);
806  }
807  TEST_F(FlagTest, TestOptionalDouble) {
808    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
809    EXPECT_DOUBLE_EQ(*absl::GetFlag(FLAGS_optional_double), 9.3);
810    absl::SetFlag(&FLAGS_optional_double, 0.0);
811    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
812    EXPECT_EQ(absl::GetFlag(FLAGS_optional_double), 0.0);
813    absl::SetFlag(&FLAGS_optional_double, 1.234);
814    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
815    EXPECT_DOUBLE_EQ(*absl::GetFlag(FLAGS_optional_double), 1.234);
816    absl::SetFlag(&FLAGS_optional_double, absl::nullopt);
817    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_double).has_value());
818    EXPECT_EQ(absl::GetFlag(FLAGS_optional_double), absl::nullopt);
819  }
820  TEST_F(FlagTest, TestOptionalString) {
821    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_string).has_value());
822    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), absl::nullopt);
823    absl::SetFlag(&FLAGS_optional_string, " ");
824    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_string).has_value());
825    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), " ");
826    absl::SetFlag(&FLAGS_optional_string, "QWERTY");
827    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_string).has_value());
828    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), "QWERTY");
829    absl::SetFlag(&FLAGS_optional_string, absl::nullopt);
830    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_string).has_value());
831    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), absl::nullopt);
832  }
833  TEST_F(FlagTest, TestOptionalDuration) {
834    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_duration).has_value());
835    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::nullopt);
836    absl::SetFlag(&FLAGS_optional_duration, absl::ZeroDuration());
837    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_duration).has_value());
838    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::Seconds(0));
839    absl::SetFlag(&FLAGS_optional_duration, absl::Hours(3));
840    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_duration).has_value());
841    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::Hours(3));
842    absl::SetFlag(&FLAGS_optional_duration, absl::nullopt);
843    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_duration).has_value());
844    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::nullopt);
845  }
846  TEST_F(FlagTest, TestOptionalOptional) {
847    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
848    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::nullopt);
849    absl::optional<int> nullint{absl::nullopt};
850    absl::SetFlag(&FLAGS_optional_optional_int, nullint);
851    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
852    EXPECT_NE(absl::GetFlag(FLAGS_optional_optional_int), nullint);
853    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int),
854              absl::optional<absl::optional<int>>{nullint});
855    absl::SetFlag(&FLAGS_optional_optional_int, 0);
856    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
857    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), 0);
858    absl::SetFlag(&FLAGS_optional_optional_int, absl::optional<int>{0});
859    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
860    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), 0);
861    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::optional<int>{0});
862    absl::SetFlag(&FLAGS_optional_optional_int, absl::nullopt);
863    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
864    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::nullopt);
865  }
866  #if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
867  TEST_F(FlagTest, TestStdOptional) {
868    EXPECT_FALSE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
869    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), std::nullopt);
870    absl::SetFlag(&FLAGS_std_optional_int64, 0);
871    EXPECT_TRUE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
872    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), 0);
873    absl::SetFlag(&FLAGS_std_optional_int64, 0xFFFFFFFFFF16);
874    EXPECT_TRUE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
875    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), 0xFFFFFFFFFF16);
876    absl::SetFlag(&FLAGS_std_optional_int64, std::nullopt);
877    EXPECT_FALSE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
878    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), std::nullopt);
879  }
880  #endif
881  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-nsHebrewProber.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>61    float modelsub = mLogicalProb->GetConfidence() - mVisualProb->GetConfidence();
62    if (modelsub > MIN_MODEL_DISTANCE)
63      return LOGICAL_HEBREW_NAME;
64    if (modelsub < -(MIN_MODEL_DISTANCE))
65      return VISUAL_HEBREW_NAME;
66    if (finalsub < 0) 
67      return VISUAL_HEBREW_NAME;
68    return LOGICAL_HEBREW_NAME;
69  }
</pre></code></div>
                <div class="column column_space"><pre><code>562    std::vector<absl::string_view> parts =
563        absl::StrSplit(in, ':', absl::SkipWhitespace());
564    if (parts.size() != 2) return false;
565    if (!absl::SimpleAtoi(parts[0], &f->a)) return false;
566    if (!absl::SimpleAtoi(parts[1], &f->b)) return false;
567    return true;
568  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    