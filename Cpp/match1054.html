<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ogg.cpp &amp; test_mp4.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ogg.cpp &amp; test_mp4.cpp
      </h3>
<h1 align="center">
        9.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ogg.cpp (24.509804%)<th>test_mp4.cpp (6.038647%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(56-75)<td><a href="#" name="0">(248-271)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(79-116)<td><a href="#" name="1">(168-191)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ogg.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;string&gt;
2 #include &lt;stdio.h&gt;
3 #include &lt;tag.h&gt;
4 #include &lt;tstringlist.h&gt;
5 #include &lt;tbytevectorlist.h&gt;
6 #include &lt;tpropertymap.h&gt;
7 #include &lt;oggfile.h&gt;
8 #include &lt;vorbisfile.h&gt;
9 #include &lt;oggpageheader.h&gt;
10 #include &lt;cppunit/extensions/HelperMacros.h&gt;
11 #include "utils.h"
12 using namespace std;
13 using namespace TagLib;
14 class TestOGG : public CppUnit::TestFixture
15 {
16   CPPUNIT_TEST_SUITE(TestOGG);
17   CPPUNIT_TEST(testSimple);
18   CPPUNIT_TEST(testSplitPackets1);
19   CPPUNIT_TEST(testSplitPackets2);
20   CPPUNIT_TEST(testDictInterface1);
21   CPPUNIT_TEST(testDictInterface2);
22   CPPUNIT_TEST(testAudioProperties);
23   CPPUNIT_TEST(testPageChecksum);
24   CPPUNIT_TEST(testPageGranulePosition);
25   CPPUNIT_TEST_SUITE_END();
26 <a name="0"></a>
27 public:
28 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  void testSimple()
29   {
30     ScopedFileCopy copy("empty", ".ogg");
31     string newname = copy.fileName();
32     {
33       Vorbis::File f(newname.c_str());
34       f.tag()-&gt;setArtist("The Artist");
35       f.save();
36     }
37     {
38       Vorbis::File f(newname.c_str());
39       CPPUNIT_ASSERT_EQUAL(String("The Artist"), f.tag()-&gt;artist());
40     }
41   }
42   void testSplitPackets1()
43   {
44     ScopedFileCopy copy("empty", ".ogg");
45     string newname = copy.fileName();</b></font>
46 <a name="1"></a>
47     const String text = longText(128 * 1024, true);
48 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    {
49       Vorbis::File f(newname.c_str());
50       f.tag()-&gt;setTitle(text);
51       f.save();
52     }
53     {
54       Vorbis::File f(newname.c_str());
55       CPPUNIT_ASSERT(f.isValid());
56       CPPUNIT_ASSERT_EQUAL(136383L, f.length());
57       CPPUNIT_ASSERT_EQUAL(19, f.lastPageHeader()-&gt;pageSequenceNumber());
58       CPPUNIT_ASSERT_EQUAL(30U, f.packet(0).size());
59       CPPUNIT_ASSERT_EQUAL(131127U, f.packet(1).size());
60       CPPUNIT_ASSERT_EQUAL(3832U, f.packet(2).size());
61       CPPUNIT_ASSERT_EQUAL(text, f.tag()-&gt;title());
62       CPPUNIT_ASSERT(f.audioProperties());
63       CPPUNIT_ASSERT_EQUAL(3685, f.audioProperties()-&gt;lengthInMilliseconds());
64       f.tag()-&gt;setTitle("ABCDE");
65       f.save();
66     }
67     {
68       Vorbis::File f(newname.c_str());
69       CPPUNIT_ASSERT(f.isValid());
70       CPPUNIT_ASSERT_EQUAL(4370L, f.length());
71       CPPUNIT_ASSERT_EQUAL(3, f.lastPageHeader()-&gt;pageSequenceNumber());
72       CPPUNIT_ASSERT_EQUAL(30U, f.packet(0).size());
73       CPPUNIT_ASSERT_EQUAL(60U, f.packet(1).size());
74       CPPUNIT_ASSERT_EQUAL(3832U, f.packet(2).size());
75       CPPUNIT_ASSERT_EQUAL(String("ABCDE"), f.tag()-&gt;title());
76       CPPUNIT_ASSERT(f.audioProperties());
77       CPPUNIT_ASSERT_EQUAL(3685, f.audioProperties()-&gt;lengthInMilliseconds());
78     }
79   }
80   void testSplitPackets2()
81   {</b></font>
82     ScopedFileCopy copy("empty", ".ogg");
83     string newname = copy.fileName();
84     const String text = longText(60890, true);
85     {
86       Vorbis::File f(newname.c_str());
87       f.tag()-&gt;setTitle(text);
88       f.save();
89     }
90     {
91       Vorbis::File f(newname.c_str());
92       CPPUNIT_ASSERT(f.isValid());
93       CPPUNIT_ASSERT_EQUAL(text, f.tag()-&gt;title());
94       f.tag()-&gt;setTitle("ABCDE");
95       f.save();
96     }
97     {
98       Vorbis::File f(newname.c_str());
99       CPPUNIT_ASSERT(f.isValid());
100       CPPUNIT_ASSERT_EQUAL(String("ABCDE"), f.tag()-&gt;title());
101     }
102   }
103   void testDictInterface1()
104   {
105     ScopedFileCopy copy("empty", ".ogg");
106     string newname = copy.fileName();
107     Vorbis::File f(newname.c_str());
108     CPPUNIT_ASSERT_EQUAL((unsigned int)0, f.tag()-&gt;properties().size());
109     PropertyMap newTags;
110     StringList values("value 1");
111     values.append("value 2");
112     newTags["ARTIST"] = values;
113     f.tag()-&gt;setProperties(newTags);
114     PropertyMap map = f.tag()-&gt;properties();
115     CPPUNIT_ASSERT_EQUAL((unsigned int)1, map.size());
116     CPPUNIT_ASSERT_EQUAL((unsigned int)2, map["ARTIST"].size());
117     CPPUNIT_ASSERT_EQUAL(String("value 1"), map["ARTIST"][0]);
118   }
119   void testDictInterface2()
120   {
121     ScopedFileCopy copy("test", ".ogg");
122     string newname = copy.fileName();
123     Vorbis::File f(newname.c_str());
124     PropertyMap tags = f.tag()-&gt;properties();
125     CPPUNIT_ASSERT_EQUAL((unsigned int)2, tags["UNUSUALTAG"].size());
126     CPPUNIT_ASSERT_EQUAL(String("usual value"), tags["UNUSUALTAG"][0]);
127     CPPUNIT_ASSERT_EQUAL(String("another value"), tags["UNUSUALTAG"][1]);
128     CPPUNIT_ASSERT_EQUAL(
129       String("\xC3\xB6\xC3\xA4\xC3\xBC\x6F\xCE\xA3\xC3\xB8", String::UTF8),
130       tags["UNICODETAG"][0]);
131     tags["UNICODETAG"][0] = String(
132       "\xCE\xBD\xCE\xB5\xCF\x89\x20\xCE\xBD\xCE\xB1\xCE\xBB\xCF\x85\xCE\xB5", String::UTF8);
133     tags.erase("UNUSUALTAG");
134     f.tag()-&gt;setProperties(tags);
135     CPPUNIT_ASSERT_EQUAL(
136       String("\xCE\xBD\xCE\xB5\xCF\x89\x20\xCE\xBD\xCE\xB1\xCE\xBB\xCF\x85\xCE\xB5", String::UTF8),
137       f.tag()-&gt;properties()["UNICODETAG"][0]);
138     CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;properties().contains("UNUSUALTAG"));
139   }
140   void testAudioProperties()
141   {
142     Ogg::Vorbis::File f(TEST_FILE_PATH_C("empty.ogg"));
143     CPPUNIT_ASSERT(f.audioProperties());
144     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
145     CPPUNIT_ASSERT_EQUAL(3685, f.audioProperties()-&gt;lengthInMilliseconds());
146     CPPUNIT_ASSERT_EQUAL(1, f.audioProperties()-&gt;bitrate());
147     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
148     CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
149     CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;vorbisVersion());
150     CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;bitrateMaximum());
151     CPPUNIT_ASSERT_EQUAL(112000, f.audioProperties()-&gt;bitrateNominal());
152     CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;bitrateMinimum());
153   }
154   void testPageChecksum()
155   {
156     ScopedFileCopy copy("empty", ".ogg");
157     {
158       Vorbis::File f(copy.fileName().c_str());
159       f.tag()-&gt;setArtist("The Artist");
160       f.save();
161       f.seek(0x50);
162       CPPUNIT_ASSERT_EQUAL((unsigned int)0x3d3bd92d, f.readBlock(4).toUInt(0, true));
163     }
164     {
165       Vorbis::File f(copy.fileName().c_str());
166       f.tag()-&gt;setArtist("The Artist 2");
167       f.save();
168       f.seek(0x50);
169       CPPUNIT_ASSERT_EQUAL((unsigned int)0xd985291c, f.readBlock(4).toUInt(0, true));
170     }
171   }
172   void testPageGranulePosition()
173   {
174     ScopedFileCopy copy("empty", ".ogg");
175     {
176       Vorbis::File f(copy.fileName().c_str());
177       f.tag()-&gt;setComment(String(ByteVector(70000, 'A')));
178       f.save();
179       f.seek(0x3a);
180       CPPUNIT_ASSERT_EQUAL(ByteVector("OggS\0\0", 6), f.readBlock(6));
181       CPPUNIT_ASSERT_EQUAL(static_cast&lt;long long&gt;(-1), f.readBlock(8).toLongLong());
182     }
183     {
184       Vorbis::File f(copy.fileName().c_str());
185       f.tag()-&gt;setComment("A small comment");
186       f.save();
187       f.seek(0x3a);
188       CPPUNIT_ASSERT_EQUAL(ByteVector("OggS\0\0", 6), f.readBlock(6));
189       CPPUNIT_ASSERT_EQUAL(static_cast&lt;long long&gt;(0), f.readBlock(8).toLongLong());
190     }
191   }
192 };
193 CPPUNIT_TEST_SUITE_REGISTRATION(TestOGG);
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mp4.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;string&gt;
2 #include &lt;stdio.h&gt;
3 #include &lt;tag.h&gt;
4 #include &lt;mp4tag.h&gt;
5 #include &lt;tbytevectorlist.h&gt;
6 #include &lt;tbytevectorstream.h&gt;
7 #include &lt;tpropertymap.h&gt;
8 #include &lt;mp4atom.h&gt;
9 #include &lt;mp4file.h&gt;
10 #include &lt;cppunit/extensions/HelperMacros.h&gt;
11 #include "plainfile.h"
12 #include "utils.h"
13 using namespace std;
14 using namespace TagLib;
15 class TestMP4 : public CppUnit::TestFixture
16 {
17   CPPUNIT_TEST_SUITE(TestMP4);
18   CPPUNIT_TEST(testPropertiesAAC);
19   CPPUNIT_TEST(testPropertiesAACWithoutBitrate);
20   CPPUNIT_TEST(testPropertiesALAC);
21   CPPUNIT_TEST(testPropertiesALACWithoutBitrate);
22   CPPUNIT_TEST(testPropertiesM4V);
23   CPPUNIT_TEST(testFreeForm);
24   CPPUNIT_TEST(testCheckValid);
25   CPPUNIT_TEST(testHasTag);
26   CPPUNIT_TEST(testIsEmpty);
27   CPPUNIT_TEST(testUpdateStco);
28   CPPUNIT_TEST(testSaveExisingWhenIlstIsLast);
29   CPPUNIT_TEST(test64BitAtom);
30   CPPUNIT_TEST(testGnre);
31   CPPUNIT_TEST(testCovrRead);
32   CPPUNIT_TEST(testCovrWrite);
33   CPPUNIT_TEST(testCovrRead2);
34   CPPUNIT_TEST(testProperties);
35   CPPUNIT_TEST(testPropertiesAllSupported);
36   CPPUNIT_TEST(testPropertiesMovement);
37   CPPUNIT_TEST(testFuzzedFile);
38   CPPUNIT_TEST(testRepeatedSave);
39   CPPUNIT_TEST(testWithZeroLengthAtom);
40   CPPUNIT_TEST(testEmptyValuesRemoveItems);
41   CPPUNIT_TEST(testRemoveMetadata);
42   CPPUNIT_TEST(testNonFullMetaAtom);
43   CPPUNIT_TEST_SUITE_END();
44 public:
45   void testPropertiesAAC()
46   {
47     MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
48     CPPUNIT_ASSERT(f.audioProperties());
49     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
50     CPPUNIT_ASSERT_EQUAL(3708, f.audioProperties()-&gt;lengthInMilliseconds());
51     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
52     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
53     CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
54     CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
55     CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
56     CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
57   }
58   void testPropertiesAACWithoutBitrate()
59   {
60     ByteVector aacData = PlainFile(TEST_FILE_PATH_C("has-tags.m4a")).readAll();
61     CPPUNIT_ASSERT_GREATER(1960U, aacData.size());
62     CPPUNIT_ASSERT_EQUAL(ByteVector("mp4a"), aacData.mid(1890, 4));
63     for (int offset = 1956; offset &lt; 1960; ++offset) {
64       aacData[offset] = 0;
65     }
66     ByteVectorStream aacStream(aacData);
67     MP4::File f(&amp;aacStream);
68     CPPUNIT_ASSERT(f.audioProperties());
69     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
70     CPPUNIT_ASSERT_EQUAL(3708, f.audioProperties()-&gt;lengthInMilliseconds());
71     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
72     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
73     CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
74     CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
75     CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
76     CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
77   }
78   void testPropertiesALAC()
79   {
80     MP4::File f(TEST_FILE_PATH_C("empty_alac.m4a"));
81     CPPUNIT_ASSERT(f.audioProperties());
82     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
83     CPPUNIT_ASSERT_EQUAL(3705, f.audioProperties()-&gt;lengthInMilliseconds());
84     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
85     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
86     CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
87     CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
88     CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
89     CPPUNIT_ASSERT_EQUAL(MP4::Properties::ALAC, f.audioProperties()-&gt;codec());
90   }
91   void testPropertiesALACWithoutBitrate()
92   {
93     ByteVector alacData = PlainFile(TEST_FILE_PATH_C("empty_alac.m4a")).readAll();
94     CPPUNIT_ASSERT_GREATER(474U, alacData.size());
95     CPPUNIT_ASSERT_EQUAL(ByteVector("alac"), alacData.mid(446, 4));
96     for (int offset = 470; offset &lt; 474; ++offset) {
97       alacData[offset] = 0;
98     }
99     ByteVectorStream alacStream(alacData);
100     MP4::File f(&amp;alacStream);
101     CPPUNIT_ASSERT(f.audioProperties());
102     CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
103     CPPUNIT_ASSERT_EQUAL(3705, f.audioProperties()-&gt;lengthInMilliseconds());
104     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;bitrate());
105     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
106     CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
107     CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
108     CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
109     CPPUNIT_ASSERT_EQUAL(MP4::Properties::ALAC, f.audioProperties()-&gt;codec());
110   }
111   void testPropertiesM4V()
112   {
113     MP4::File f(TEST_FILE_PATH_C("blank_video.m4v"));
114     CPPUNIT_ASSERT(f.audioProperties());
115     CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;lengthInSeconds());
116     CPPUNIT_ASSERT_EQUAL(975, f.audioProperties()-&gt;lengthInMilliseconds());
117     CPPUNIT_ASSERT_EQUAL(96, f.audioProperties()-&gt;bitrate());
118     CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
119     CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
120     CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
121     CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
122     CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
123   }
124   void testCheckValid()
125   {
126     MP4::File f(TEST_FILE_PATH_C("empty.aiff"));
127     CPPUNIT_ASSERT(!f.isValid());
128   }
129 <a name="1"></a>
130   void testHasTag()
131   {
132 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    {
133       MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
134       CPPUNIT_ASSERT(f.isValid());
135       CPPUNIT_ASSERT(f.hasMP4Tag());
136     }
137     ScopedFileCopy copy("no-tags", ".m4a");
138     {
139       MP4::File f(copy.fileName().c_str());
140       CPPUNIT_ASSERT(f.isValid());
141       CPPUNIT_ASSERT(!f.hasMP4Tag());
142       f.tag()-&gt;setTitle("TITLE");
143       f.save();
144     }
145     {
146       MP4::File f(copy.fileName().c_str());
147       CPPUNIT_ASSERT(f.isValid());
148       CPPUNIT_ASSERT(f.hasMP4Tag());
149     }
150   }
151   void testIsEmpty()
152   {</b></font>
153     MP4::Tag t1;
154     CPPUNIT_ASSERT(t1.isEmpty());
155     t1.setArtist("Foo");
156     CPPUNIT_ASSERT(!t1.isEmpty());
157     MP4::Tag t2;
158     t2.setItem("foo", "bar");
159     CPPUNIT_ASSERT(!t2.isEmpty());
160   }
161   void testUpdateStco()
162   {
163     ScopedFileCopy copy("no-tags", ".3g2");
164     string filename = copy.fileName();
165     ByteVectorList data1;
166     {
167       MP4::File f(filename.c_str());
168       f.tag()-&gt;setArtist(ByteVector(3000, 'x'));
169       MP4::Atoms a(&amp;f);
170       MP4::Atom *stco = a.find("moov")-&gt;findall("stco", true)[0];
171       f.seek(stco-&gt;offset + 12);
172       ByteVector data = f.readBlock(stco-&gt;length - 12);
173       unsigned int count = data.mid(0, 4).toUInt();
174       int pos = 4;
175       while (count--) {
176         unsigned int offset = data.mid(pos, 4).toUInt();
177         f.seek(offset);
178         data1.append(f.readBlock(20));
179         pos += 4;
180       }
181       f.save();
182     }
183     {
184       MP4::File f(filename.c_str());
185       MP4::Atoms a(&amp;f);
186       MP4::Atom *stco = a.find("moov")-&gt;findall("stco", true)[0];
187       f.seek(stco-&gt;offset + 12);
188       ByteVector data = f.readBlock(stco-&gt;length - 12);
189       unsigned int count = data.mid(0, 4).toUInt();
190       int pos = 4, i = 0;
191       while (count--) {
192         unsigned int offset = data.mid(pos, 4).toUInt();
193         f.seek(offset);
194         CPPUNIT_ASSERT_EQUAL(data1[i], f.readBlock(20));
195         pos += 4;
196         i++;
197       }
198 <a name="0"></a>    }
199   }
200 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  void testFreeForm()
201   {
202     ScopedFileCopy copy("has-tags", ".m4a");
203     string filename = copy.fileName();
204     {
205       MP4::File f(filename.c_str());
206       CPPUNIT_ASSERT(f.tag()-&gt;contains("----:com.apple.iTunes:iTunNORM"));
207       f.tag()-&gt;setItem("----:org.kde.TagLib:Foo", StringList("Bar"));
208       f.save();
209     }
210     {
211       MP4::File f(filename.c_str());
212       CPPUNIT_ASSERT(f.tag()-&gt;contains("----:org.kde.TagLib:Foo"));
213       CPPUNIT_ASSERT_EQUAL(String("Bar"),
214                            f.tag()-&gt;item("----:org.kde.TagLib:Foo").toStringList().front());
215       f.save();
216     }
217   }
218   void testSaveExisingWhenIlstIsLast()
219   {
220     ScopedFileCopy copy("ilst-is-last", ".m4a");
221     string filename = copy.fileName();</b></font>
222     {
223       MP4::File f(filename.c_str());
224       CPPUNIT_ASSERT_EQUAL(String("82,164"),
225         f.tag()-&gt;item("----:com.apple.iTunes:replaygain_track_minmax").toStringList().front());
226       CPPUNIT_ASSERT_EQUAL(String("Pearl Jam"), f.tag()-&gt;artist());
227       f.tag()-&gt;setComment("foo");
228       f.save();
229     }
230     {
231       MP4::File f(filename.c_str());
232       CPPUNIT_ASSERT_EQUAL(String("82,164"),
233                            f.tag()-&gt;item("----:com.apple.iTunes:replaygain_track_minmax").toStringList().front());
234       CPPUNIT_ASSERT_EQUAL(String("Pearl Jam"), f.tag()-&gt;artist());
235       CPPUNIT_ASSERT_EQUAL(String("foo"), f.tag()-&gt;comment());
236     }
237   }
238   void test64BitAtom()
239   {
240     ScopedFileCopy copy("64bit", ".mp4");
241     string filename = copy.fileName();
242     {
243       MP4::File f(filename.c_str());
244       CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;itemMap()["cpil"].toBool());
245       MP4::Atoms atoms(&amp;f);
246       MP4::Atom *moov = atoms.atoms[0];
247       CPPUNIT_ASSERT_EQUAL(long(77), moov-&gt;length);
248       f.tag()-&gt;setItem("pgap", true);
249       f.save();
250     }
251     {
252       MP4::File f(filename.c_str());
253       CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("cpil").toBool());
254       CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("pgap").toBool());
255       MP4::Atoms atoms(&amp;f);
256       MP4::Atom *moov = atoms.atoms[0];
257       CPPUNIT_ASSERT_EQUAL(long(77 + 25 + 974), moov-&gt;length);
258     }
259   }
260   void testGnre()
261   {
262     MP4::File f(TEST_FILE_PATH_C("gnre.m4a"));
263     CPPUNIT_ASSERT_EQUAL(TagLib::String("Ska"), f.tag()-&gt;genre());
264   }
265   void testCovrRead()
266   {
267     MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
268     CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
269     MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
270     CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
271     CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
272     CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
273     CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
274     CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
275   }
276   void testCovrWrite()
277   {
278     ScopedFileCopy copy("has-tags", ".m4a");
279     string filename = copy.fileName();
280     {
281       MP4::File f(filename.c_str());
282       CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
283       MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
284       l.append(MP4::CoverArt(MP4::CoverArt::PNG, "foo"));
285       f.tag()-&gt;setItem("covr", l);
286       f.save();
287     }
288     {
289       MP4::File f(filename.c_str());
290       CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
291       MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
292       CPPUNIT_ASSERT_EQUAL((unsigned int)3, l.size());
293       CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
294       CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
295       CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
296       CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
297       CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[2].format());
298       CPPUNIT_ASSERT_EQUAL((unsigned int)3, l[2].data().size());
299     }
300   }
301   void testCovrRead2()
302   {
303     MP4::File f(TEST_FILE_PATH_C("covr-junk.m4a"));
304     CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
305     MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
306     CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
307     CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
308     CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
309     CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
310     CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
311   }
312   void testProperties()
313   {
314     MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
315     PropertyMap tags = f.properties();
316     CPPUNIT_ASSERT_EQUAL(StringList("Test Artist"), tags["ARTIST"]);
317     tags["TRACKNUMBER"] = StringList("2/4");
318     tags["DISCNUMBER"] = StringList("3/5");
319     tags["BPM"] = StringList("123");
320     tags["ARTIST"] = StringList("Foo Bar");
321     tags["COMPILATION"] = StringList("1");
322     f.setProperties(tags);
323     tags = f.properties();
324     CPPUNIT_ASSERT(f.tag()-&gt;contains("trkn"));
325     CPPUNIT_ASSERT_EQUAL(2, f.tag()-&gt;item("trkn").toIntPair().first);
326     CPPUNIT_ASSERT_EQUAL(4, f.tag()-&gt;item("trkn").toIntPair().second);
327     CPPUNIT_ASSERT_EQUAL(StringList("2/4"), tags["TRACKNUMBER"]);
328     CPPUNIT_ASSERT(f.tag()-&gt;contains("disk"));
329     CPPUNIT_ASSERT_EQUAL(3, f.tag()-&gt;item("disk").toIntPair().first);
330     CPPUNIT_ASSERT_EQUAL(5, f.tag()-&gt;item("disk").toIntPair().second);
331     CPPUNIT_ASSERT_EQUAL(StringList("3/5"), tags["DISCNUMBER"]);
332     CPPUNIT_ASSERT(f.tag()-&gt;contains("tmpo"));
333     CPPUNIT_ASSERT_EQUAL(123, f.tag()-&gt;item("tmpo").toInt());
334     CPPUNIT_ASSERT_EQUAL(StringList("123"), tags["BPM"]);
335     CPPUNIT_ASSERT(f.tag()-&gt;contains("\251ART"));
336     CPPUNIT_ASSERT_EQUAL(StringList("Foo Bar"), f.tag()-&gt;item("\251ART").toStringList());
337     CPPUNIT_ASSERT_EQUAL(StringList("Foo Bar"), tags["ARTIST"]);
338     CPPUNIT_ASSERT(f.tag()-&gt;contains("cpil"));
339     CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("cpil").toBool());
340     CPPUNIT_ASSERT_EQUAL(StringList("1"), tags["COMPILATION"]);
341     tags["COMPILATION"] = StringList("0");
342     f.setProperties(tags);
343     tags = f.properties();
344     CPPUNIT_ASSERT(f.tag()-&gt;contains("cpil"));
345     CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;item("cpil").toBool());
346     CPPUNIT_ASSERT_EQUAL(StringList("0"), tags["COMPILATION"]);
347     tags["TRACKNUMBER"] = StringList();
348     tags["DISCNUMBER"] = StringList();
349     tags["BPM"] = StringList();
350     tags["COMPILATION"] = StringList();
351     f.setProperties(tags);
352   }
353   void testPropertiesAllSupported()
354   {
355     PropertyMap tags;
356     tags["ALBUM"] = StringList("Album");
357     tags["ALBUMARTIST"] = StringList("Album Artist");
358     tags["ALBUMARTISTSORT"] = StringList("Album Artist Sort");
359     tags["ALBUMSORT"] = StringList("Album Sort");
360     tags["ARTIST"] = StringList("Artist");
361     tags["ARTISTS"] = StringList("Artists");
362     tags["ARTISTSORT"] = StringList("Artist Sort");
363     tags["ASIN"] = StringList("ASIN");
364     tags["BARCODE"] = StringList("Barcode");
365     tags["BPM"] = StringList("123");
366     tags["CATALOGNUMBER"] = StringList("Catalog Number");
367     tags["COMMENT"] = StringList("Comment");
368     tags["COMPILATION"] = StringList("1");
369     tags["COMPOSER"] = StringList("Composer");
370     tags["COMPOSERSORT"] = StringList("Composer Sort");
371     tags["CONDUCTOR"] = StringList("Conductor");
372     tags["COPYRIGHT"] = StringList("2021 Copyright");
373     tags["DATE"] = StringList("2021-01-03 12:29:23");
374     tags["DISCNUMBER"] = StringList("3/5");
375     tags["DISCSUBTITLE"] = StringList("Disc Subtitle");
376     tags["DJMIXER"] = StringList("DJ Mixer");
377     tags["ENCODEDBY"] = StringList("Encoded by");
378     tags["ENGINEER"] = StringList("Engineer");
379     tags["GAPLESSPLAYBACK"] = StringList("1");
380     tags["GENRE"] = StringList("Genre");
381     tags["GROUPING"] = StringList("Grouping");
382     tags["ISRC"] = StringList("UKAAA0500001");
383     tags["LABEL"] = StringList("Label");
384     tags["LANGUAGE"] = StringList("eng");
385     tags["LICENSE"] = StringList("License");
386     tags["LYRICIST"] = StringList("Lyricist");
387     tags["LYRICS"] = StringList("Lyrics");
388     tags["MEDIA"] = StringList("Media");
389     tags["MIXER"] = StringList("Mixer");
390     tags["MOOD"] = StringList("Mood");
391     tags["MOVEMENTCOUNT"] = StringList("3");
392     tags["MOVEMENTNAME"] = StringList("Movement Name");
393     tags["MOVEMENTNUMBER"] = StringList("2");
394     tags["MUSICBRAINZ_ALBUMARTISTID"] = StringList("MusicBrainz_AlbumartistID");
395     tags["MUSICBRAINZ_ALBUMID"] = StringList("MusicBrainz_AlbumID");
396     tags["MUSICBRAINZ_ARTISTID"] = StringList("MusicBrainz_ArtistID");
397     tags["MUSICBRAINZ_RELEASEGROUPID"] = StringList("MusicBrainz_ReleasegroupID");
398     tags["MUSICBRAINZ_RELEASETRACKID"] = StringList("MusicBrainz_ReleasetrackID");
399     tags["MUSICBRAINZ_TRACKID"] = StringList("MusicBrainz_TrackID");
400     tags["MUSICBRAINZ_WORKID"] = StringList("MusicBrainz_WorkID");
401     tags["ORIGINALDATE"] = StringList("2021-01-03 13:52:19");
402     tags["PODCAST"] = StringList("1");
403     tags["PODCASTCATEGORY"] = StringList("Podcast Category");
404     tags["PODCASTDESC"] = StringList("Podcast Description");
405     tags["PODCASTID"] = StringList("Podcast ID");
406     tags["PODCASTURL"] = StringList("Podcast URL");
407     tags["PRODUCER"] = StringList("Producer");
408     tags["RELEASECOUNTRY"] = StringList("Release Country");
409     tags["RELEASESTATUS"] = StringList("Release Status");
410     tags["RELEASETYPE"] = StringList("Release Type");
411     tags["REMIXER"] = StringList("Remixer");
412     tags["SCRIPT"] = StringList("Script");
413     tags["SHOWSORT"] = StringList("Show Sort");
414     tags["SHOWWORKMOVEMENT"] = StringList("1");
415     tags["SUBTITLE"] = StringList("Subtitle");
416     tags["TITLE"] = StringList("Title");
417     tags["TITLESORT"] = StringList("Title Sort");
418     tags["TRACKNUMBER"] = StringList("2/4");
419     tags["TVEPISODE"] = StringList("3");
420     tags["TVEPISODEID"] = StringList("TV Episode ID");
421     tags["TVNETWORK"] = StringList("TV Network");
422     tags["TVSEASON"] = StringList("2");
423     tags["TVSHOW"] = StringList("TV Show");
424     tags["WORK"] = StringList("Work");
425     ScopedFileCopy copy("no-tags", ".m4a");
426     {
427       MP4::File f(copy.fileName().c_str());
428       PropertyMap properties = f.properties();
429       CPPUNIT_ASSERT(properties.isEmpty());
430       f.setProperties(tags);
431       f.save();
432     }
433     {
434       const MP4::File f(copy.fileName().c_str());
435       PropertyMap properties = f.properties();
436       if (tags != properties) {
437         CPPUNIT_ASSERT_EQUAL(tags.toString(), properties.toString());
438       }
439       CPPUNIT_ASSERT(tags == properties);
440     }
441   }
442   void testPropertiesMovement()
443   {
444     MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
445     PropertyMap tags = f.properties();
446     tags["WORK"] = StringList("Foo");
447     tags["MOVEMENTNAME"] = StringList("Bar");
448     tags["MOVEMENTNUMBER"] = StringList("2");
449     tags["MOVEMENTCOUNT"] = StringList("3");
450     tags["SHOWWORKMOVEMENT"] = StringList("1");
451     f.setProperties(tags);
452     tags = f.properties();
453     CPPUNIT_ASSERT(f.tag()-&gt;contains("\251wrk"));
454     CPPUNIT_ASSERT_EQUAL(StringList("Foo"), f.tag()-&gt;item("\251wrk").toStringList());
455     CPPUNIT_ASSERT_EQUAL(StringList("Foo"), tags["WORK"]);
456     CPPUNIT_ASSERT(f.tag()-&gt;contains("\251mvn"));
457     CPPUNIT_ASSERT_EQUAL(StringList("Bar"), f.tag()-&gt;item("\251mvn").toStringList());
458     CPPUNIT_ASSERT_EQUAL(StringList("Bar"), tags["MOVEMENTNAME"]);
459     CPPUNIT_ASSERT(f.tag()-&gt;contains("\251mvi"));
460     CPPUNIT_ASSERT_EQUAL(2, f.tag()-&gt;item("\251mvi").toInt());
461     CPPUNIT_ASSERT_EQUAL(StringList("2"), tags["MOVEMENTNUMBER"]);
462     CPPUNIT_ASSERT(f.tag()-&gt;contains("\251mvc"));
463     CPPUNIT_ASSERT_EQUAL(3, f.tag()-&gt;item("\251mvc").toInt());
464     CPPUNIT_ASSERT_EQUAL(StringList("3"), tags["MOVEMENTCOUNT"]);
465     CPPUNIT_ASSERT(f.tag()-&gt;contains("shwm"));
466     CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("shwm").toBool());
467     CPPUNIT_ASSERT_EQUAL(StringList("1"), tags["SHOWWORKMOVEMENT"]);
468     tags["SHOWWORKMOVEMENT"] = StringList("0");
469     f.setProperties(tags);
470     tags = f.properties();
471     CPPUNIT_ASSERT(f.tag()-&gt;contains("shwm"));
472     CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;item("shwm").toBool());
473     CPPUNIT_ASSERT_EQUAL(StringList("0"), tags["SHOWWORKMOVEMENT"]);
474     tags["WORK"] = StringList();
475     tags["MOVEMENTNAME"] = StringList();
476     tags["MOVEMENTNUMBER"] = StringList();
477     tags["MOVEMENTCOUNT"] = StringList();
478     tags["SHOWWORKMOVEMENT"] = StringList();
479     f.setProperties(tags);
480   }
481   void testFuzzedFile()
482   {
483     MP4::File f(TEST_FILE_PATH_C("infloop.m4a"));
484     CPPUNIT_ASSERT(f.isValid());
485   }
486   void testRepeatedSave()
487   {
488     ScopedFileCopy copy("no-tags", ".m4a");
489     MP4::File f(copy.fileName().c_str());
490     f.tag()-&gt;setTitle("0123456789");
491     f.save();
492     f.save();
493     CPPUNIT_ASSERT_EQUAL(2862L, f.find("0123456789"));
494     CPPUNIT_ASSERT_EQUAL(-1L, f.find("0123456789", 2863));
495   }
496   void testWithZeroLengthAtom()
497   {
498     MP4::File f(TEST_FILE_PATH_C("zero-length-mdat.m4a"));
499     CPPUNIT_ASSERT(f.isValid());
500     CPPUNIT_ASSERT_EQUAL(1115, f.audioProperties()-&gt;lengthInMilliseconds());
501     CPPUNIT_ASSERT_EQUAL(22050, f.audioProperties()-&gt;sampleRate());
502   }
503   void testEmptyValuesRemoveItems()
504   {
505     const MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
506     MP4::Tag *tag = f.tag();
507     const String testTitle("Title");
508     const String testArtist("Artist");
509     const String testAlbum("Album");
510     const String testComment("Comment");
511     const String testGenre("Genre");
512     const String nullString;
513     const unsigned int testYear = 2020;
514     const unsigned int testTrack = 1;
515     const unsigned int zeroUInt = 0;
516     tag-&gt;setTitle(testTitle);
517     CPPUNIT_ASSERT_EQUAL(testTitle, tag-&gt;title());
518     CPPUNIT_ASSERT(tag-&gt;contains("\251nam"));
519     tag-&gt;setArtist(testArtist);
520     CPPUNIT_ASSERT_EQUAL(testArtist, tag-&gt;artist());
521     CPPUNIT_ASSERT(tag-&gt;contains("\251ART"));
522     tag-&gt;setAlbum(testAlbum);
523     CPPUNIT_ASSERT_EQUAL(testAlbum, tag-&gt;album());
524     CPPUNIT_ASSERT(tag-&gt;contains("\251alb"));
525     tag-&gt;setComment(testComment);
526     CPPUNIT_ASSERT_EQUAL(testComment, tag-&gt;comment());
527     CPPUNIT_ASSERT(tag-&gt;contains("\251cmt"));
528     tag-&gt;setGenre(testGenre);
529     CPPUNIT_ASSERT_EQUAL(testGenre, tag-&gt;genre());
530     CPPUNIT_ASSERT(tag-&gt;contains("\251gen"));
531     tag-&gt;setYear(testYear);
532     CPPUNIT_ASSERT_EQUAL(testYear, tag-&gt;year());
533     CPPUNIT_ASSERT(tag-&gt;contains("\251day"));
534     tag-&gt;setTrack(testTrack);
535     CPPUNIT_ASSERT_EQUAL(testTrack, tag-&gt;track());
536     CPPUNIT_ASSERT(tag-&gt;contains("trkn"));
537     tag-&gt;setTitle(nullString);
538     CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;title());
539     CPPUNIT_ASSERT(!tag-&gt;contains("\251nam"));
540     tag-&gt;setArtist(nullString);
541     CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;artist());
542     CPPUNIT_ASSERT(!tag-&gt;contains("\251ART"));
543     tag-&gt;setAlbum(nullString);
544     CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;album());
545     CPPUNIT_ASSERT(!tag-&gt;contains("\251alb"));
546     tag-&gt;setComment(nullString);
547     CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;comment());
548     CPPUNIT_ASSERT(!tag-&gt;contains("\251cmt"));
549     tag-&gt;setGenre(nullString);
550     CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;genre());
551     CPPUNIT_ASSERT(!tag-&gt;contains("\251gen"));
552     tag-&gt;setYear(zeroUInt);
553     CPPUNIT_ASSERT_EQUAL(zeroUInt, tag-&gt;year());
554     CPPUNIT_ASSERT(!tag-&gt;contains("\251day"));
555     tag-&gt;setTrack(zeroUInt);
556     CPPUNIT_ASSERT_EQUAL(zeroUInt, tag-&gt;track());
557     CPPUNIT_ASSERT(!tag-&gt;contains("trkn"));
558   }
559   void testRemoveMetadata()
560   {
561     ScopedFileCopy copy("no-tags", ".m4a");
562     {
563       MP4::File f(copy.fileName().c_str());
564       CPPUNIT_ASSERT(f.isValid());
565       CPPUNIT_ASSERT(!f.hasMP4Tag());
566       MP4::Tag *tag = f.tag();
567       CPPUNIT_ASSERT(tag-&gt;isEmpty());
568       tag-&gt;setTitle("TITLE");
569       f.save();
570     }
571     {
572       MP4::File f(copy.fileName().c_str());
573       CPPUNIT_ASSERT(f.isValid());
574       CPPUNIT_ASSERT(f.hasMP4Tag());
575       CPPUNIT_ASSERT(!f.tag()-&gt;isEmpty());
576       f.strip();
577     }
578     {
579       MP4::File f(copy.fileName().c_str());
580       CPPUNIT_ASSERT(f.isValid());
581       CPPUNIT_ASSERT(!f.hasMP4Tag());
582       CPPUNIT_ASSERT(f.tag()-&gt;isEmpty());
583       CPPUNIT_ASSERT(fileEqual(
584         copy.fileName(),
585         TEST_FILE_PATH_C("no-tags.m4a")));
586     }
587   }
588   void testNonFullMetaAtom()
589   {
590     {
591       MP4::File f(TEST_FILE_PATH_C("non-full-meta.m4a"));
592       CPPUNIT_ASSERT(f.isValid());
593       CPPUNIT_ASSERT(f.hasMP4Tag());
594       CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
595       MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
596       CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
597       CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
598       CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
599       CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
600       CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
601       PropertyMap properties = f.properties();
602       CPPUNIT_ASSERT_EQUAL(StringList("Test Artist!!!!"), properties["ARTIST"]);
603       CPPUNIT_ASSERT_EQUAL(StringList("FAAC 1.24"), properties["ENCODEDBY"]);
604     }
605   }
606 };
607 CPPUNIT_TEST_SUITE_REGISTRATION(TestMP4);
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
