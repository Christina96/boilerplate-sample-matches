
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 54, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree.h"
2  #include <cmath>
3  #include <deque>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/cleanup/cleanup.h"
12  #include "absl/strings/internal/cord_data_edge.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_test_util.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace cord_internal {
20  class CordRepBtreeTestPeer {
21   public:
22    static void SetEdge(CordRepBtree* node, size_t idx, CordRep* edge) {
23      node->edges_[idx] = edge;
24    }
25    static void AddEdge(CordRepBtree* node, CordRep* edge) {
26      node->edges_[node->fetch_add_end(1)] = edge;
27    }
28  };
29  namespace {
30  using ::absl::cordrep_testing::AutoUnref;
31  using ::absl::cordrep_testing::CordCollectRepsIf;
32  using ::absl::cordrep_testing::CordToString;
33  using ::absl::cordrep_testing::CordVisitReps;
34  using ::absl::cordrep_testing::CreateFlatsFromString;
35  using ::absl::cordrep_testing::CreateRandomString;
36  using ::absl::cordrep_testing::MakeExternal;
37  using ::absl::cordrep_testing::MakeFlat;
38  using ::absl::cordrep_testing::MakeSubstring;
39  using ::testing::_;
40  using ::testing::AllOf;
41  using ::testing::AnyOf;
42  using ::testing::Conditional;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::Eq;
46  using ::testing::HasSubstr;
47  using ::testing::Le;
48  using ::testing::Ne;
49  using ::testing::Not;
50  using ::testing::SizeIs;
51  using ::testing::TypedEq;
52  MATCHER_P(EqFlatHolding, data, "Equals flat holding data") {
53    if (arg->tag < FLAT) {
54      *result_listener << "Expected FLAT, got tag " << static_cast<int>(arg->tag);
55      return false;
56    }
57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
60                       << "\", got flat holding \"" << actual << "\"";
61      return false;
62    }
63    return true;
64  }
65  MATCHER_P(IsNode, height, absl::StrCat("Is a valid node of height ", height)) {
66    if (arg == nullptr) {
67      *result_listener << "Expected NODE, got nullptr";
68      return false;
69    }
70    if (arg->tag != BTREE) {
71      *result_listener << "Expected NODE, got " << static_cast<int>(arg->tag);
72      return false;
73    }
74    if (!CordRepBtree::IsValid(arg->btree())) {
75      CordRepBtree::Dump(arg->btree(), "Expected valid NODE, got:", false,
76                         *result_listener->stream());
77      return false;
78    }
79    if (arg->btree()->height() != height) {
80      *result_listener << "Expected NODE of height " << height << ", got "
81                       << arg->btree()->height();
82      return false;
83    }
84    return true;
85  }
86  MATCHER_P2(IsSubstring, start, length,
87             absl::StrCat("Is a substring(start = ", start, ", length = ", length,
88                          ")")) {
89    if (arg == nullptr) {
90      *result_listener << "Expected substring, got nullptr";
91      return false;
92    }
93    if (arg->tag != SUBSTRING) {
94      *result_listener << "Expected SUBSTRING, got "
95                       << static_cast<int>(arg->tag);
96      return false;
97    }
98    const CordRepSubstring* const substr = arg->substring();
99    if (substr->start != start || substr->length != length) {
100      *result_listener << "Expected substring(" << start << ", " << length
101                       << "), got substring(" << substr->start << ", "
102                       << substr->length << ")";
103      return false;
104    }
105    return true;
106  }
107  MATCHER_P2(EqExtractResult, tree, rep, "Equals ExtractResult") {
108    if (arg.tree != tree || arg.extracted != rep) {
109      *result_listener << "Expected {" << static_cast<const void*>(tree) << ", "
110                       << static_cast<const void*>(rep) << "}, got {" << arg.tree
111                       << ", " << arg.extracted << "}";
112      return false;
113    }
114    return true;
115  }
116  class DataConsumer {
117   public:
118    DataConsumer(absl::string_view data, bool forward)
119        : data_(data), forward_(forward) {}
120    absl::string_view Next(size_t n) {
121      assert(n <= data_.size() - consumed_);
122      consumed_ += n;
123      return data_.substr(forward_ ? consumed_ - n : data_.size() - consumed_, n);
124    }
125    absl::string_view Consumed() const {
126      return forward_ ? data_.substr(0, consumed_)
127                      : data_.substr(data_.size() - consumed_);
128    }
129   private:
130    absl::string_view data_;
131    size_t consumed_ = 0;
132    bool forward_;
133  };
134  CordRepBtree* BtreeAdd(CordRepBtree* node, bool append,
135                         absl::string_view data) {
136    return append ? CordRepBtree::Append(node, data)
137                  : CordRepBtree::Prepend(node, data);
138  }
139  void GetLeafEdges(const CordRepBtree* tree, std::vector<CordRep*>& edges) {
140    if (tree->height() == 0) {
141      for (CordRep* edge : tree->Edges()) {
142        edges.push_back(edge);
143      }
144    } else {
145      for (CordRep* edge : tree->Edges()) {
146        GetLeafEdges(edge->btree(), edges);
147      }
148    }
149  }
150  std::vector<CordRep*> GetLeafEdges(const CordRepBtree* tree) {
151    std::vector<CordRep*> edges;
152    GetLeafEdges(tree, edges);
153    return edges;
154  }
155  CordRepFlat* MakeHexFlat(size_t i) {
156    return MakeFlat(absl::StrCat("0x", absl::Hex(i, absl::kZeroPad4)));
157  }
158  CordRepBtree* MakeLeaf(size_t size = CordRepBtree::kMaxCapacity) {
159    assert(size <= CordRepBtree::kMaxCapacity);
160    CordRepBtree* leaf = CordRepBtree::Create(MakeHexFlat(0));
161    for (size_t i = 1; i < size; ++i) {
162      leaf = CordRepBtree::Append(leaf, MakeHexFlat(i));
163    }
164    return leaf;
165  }
166  CordRepBtree* MakeTree(size_t size, bool append = true) {
167    CordRepBtree* tree = CordRepBtree::Create(MakeHexFlat(0));
168    for (size_t i = 1; i < size; ++i) {
169      tree = append ? CordRepBtree::Append(tree, MakeHexFlat(i))
170                    : CordRepBtree::Prepend(tree, MakeHexFlat(i));
171    }
172    return tree;
173  }
174  CordRepBtree* CreateTree(absl::Span<CordRep* const> reps) {
175    auto it = reps.begin();
176    CordRepBtree* tree = CordRepBtree::Create(*it);
177    while (++it != reps.end()) tree = CordRepBtree::Append(tree, *it);
178    return tree;
179  }
180  CordRepBtree* CreateTree(absl::string_view data, size_t chunk_size) {
181    return CreateTree(CreateFlatsFromString(data, chunk_size));
182  }
183  CordRepBtree* CreateTreeReverse(absl::string_view data, size_t chunk_size) {
184    std::vector<CordRep*> flats = CreateFlatsFromString(data, chunk_size);
185    auto rit = flats.rbegin();
186    CordRepBtree* tree = CordRepBtree::Create(*rit);
187    while (++rit != flats.rend()) tree = CordRepBtree::Prepend(tree, *rit);
188    return tree;
189  }
190  class CordRepBtreeTest : public testing::TestWithParam<bool> {
191   public:
192    bool shared() const { return GetParam(); }
193    static std::string ToString(testing::TestParamInfo<bool> param) {
194      return param.param ? "Shared" : "Private";
195    }
196  };
197  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeTest, testing::Bool(),
198                           CordRepBtreeTest::ToString);
199  class CordRepBtreeHeightTest : public testing::TestWithParam<int> {
200   public:
201    int height() const { return GetParam(); }
202    static std::string ToString(testing::TestParamInfo<int> param) {
203      return absl::StrCat(param.param);
204    }
205  };
206  INSTANTIATE_TEST_SUITE_P(WithHeights, CordRepBtreeHeightTest,
207                           testing::Range(0, CordRepBtree::kMaxHeight),
208                           CordRepBtreeHeightTest::ToString);
209  using TwoBools = testing::tuple<bool, bool>;
210  class CordRepBtreeDualTest : public testing::TestWithParam<TwoBools> {
211   public:
212    bool first_shared() const { return std::get<0>(GetParam()); }
213    bool second_shared() const { return std::get<1>(GetParam()); }
214    static std::string ToString(testing::TestParamInfo<TwoBools> param) {
215      if (std::get<0>(param.param)) {
216        return std::get<1>(param.param) ? "BothShared" : "FirstShared";
217      }
218      return std::get<1>(param.param) ? "SecondShared" : "Private";
219    }
220  };
221  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeDualTest,
222                           testing::Combine(testing::Bool(), testing::Bool()),
223                           CordRepBtreeDualTest::ToString);
224  TEST(CordRepBtreeTest, SizeIsMultipleOf64) {
225    if (sizeof(size_t) == 8 && sizeof(void*) == 8) {
226      EXPECT_THAT(sizeof(CordRepBtree) % 64, Eq(0u))
227          << "Should be multiple of 64";
228    }
229  }
230  TEST(CordRepBtreeTest, NewDestroyEmptyTree) {
231    auto* tree = CordRepBtree::New();
232    EXPECT_THAT(tree->size(), Eq(0u));
233    EXPECT_THAT(tree->height(), Eq(0));
234    EXPECT_THAT(tree->Edges(), ElementsAre());
235    CordRepBtree::Destroy(tree);
236  }
237  TEST(CordRepBtreeTest, NewDestroyEmptyTreeAtHeight) {
238    auto* tree = CordRepBtree::New(3);
239    EXPECT_THAT(tree->size(), Eq(0u));
240    EXPECT_THAT(tree->height(), Eq(3));
241    EXPECT_THAT(tree->Edges(), ElementsAre());
242    CordRepBtree::Destroy(tree);
243  }
244  TEST(CordRepBtreeTest, Btree) {
245    CordRep* rep = CordRepBtree::New();
246    EXPECT_THAT(rep->btree(), Eq(rep));
247    EXPECT_THAT(static_cast<const CordRep*>(rep)->btree(), Eq(rep));
248    CordRep::Unref(rep);
249  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
250    rep = MakeFlat("Hello world");
251    EXPECT_DEATH(rep->btree(), ".*");
252    EXPECT_DEATH(static_cast<const CordRep*>(rep)->btree(), ".*");
253    CordRep::Unref(rep);
254  #endif
255  }
256  TEST(CordRepBtreeTest, EdgeData) {
257    CordRepFlat* flat = MakeFlat("Hello world");
258    CordRepExternal* external = MakeExternal("Hello external");
259    CordRep* substr1 = MakeSubstring(1, 6, CordRep::Ref(flat));
260    CordRep* substr2 = MakeSubstring(1, 6, CordRep::Ref(external));
261    CordRep* bad_substr = MakeSubstring(1, 2, CordRep::Ref(substr1));
262    EXPECT_TRUE(IsDataEdge(flat));
263    EXPECT_THAT(EdgeData(flat).data(), TypedEq<const void*>(flat->Data()));
264    EXPECT_THAT(EdgeData(flat), Eq("Hello world"));
265    EXPECT_TRUE(IsDataEdge(external));
266    EXPECT_THAT(EdgeData(external).data(), TypedEq<const void*>(external->base));
267    EXPECT_THAT(EdgeData(external), Eq("Hello external"));
268    EXPECT_TRUE(IsDataEdge(substr1));
269    EXPECT_THAT(EdgeData(substr1).data(), TypedEq<const void*>(flat->Data() + 1));
270    EXPECT_THAT(EdgeData(substr1), Eq("ello w"));
271    EXPECT_TRUE(IsDataEdge(substr2));
272    EXPECT_THAT(EdgeData(substr2).data(),
273                TypedEq<const void*>(external->base + 1));
274    EXPECT_THAT(EdgeData(substr2), Eq("ello e"));
275    EXPECT_FALSE(IsDataEdge(bad_substr));
276  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
277    EXPECT_DEATH(EdgeData(bad_substr), ".*");
278  #endif
279    CordRep::Unref(bad_substr);
280    CordRep::Unref(substr2);
281    CordRep::Unref(substr1);
282    CordRep::Unref(external);
283    CordRep::Unref(flat);
284  }
285  TEST(CordRepBtreeTest, CreateUnrefLeaf) {
286    auto* flat = MakeFlat("a");
287    auto* leaf = CordRepBtree::Create(flat);
288    EXPECT_THAT(leaf->size(), Eq(1u));
289    EXPECT_THAT(leaf->height(), Eq(0));
290    EXPECT_THAT(leaf->Edges(), ElementsAre(flat));
291    CordRepBtree::Unref(leaf);
292  }
293  TEST(CordRepBtreeTest, NewUnrefNode) {
294    auto* leaf = CordRepBtree::Create(MakeFlat("a"));
295    CordRepBtree* tree = CordRepBtree::New(leaf);
296    EXPECT_THAT(tree->size(), Eq(1u));
297    EXPECT_THAT(tree->height(), Eq(1));
298    EXPECT_THAT(tree->Edges(), ElementsAre(leaf));
299    CordRepBtree::Unref(tree);
300  }
301  TEST_P(CordRepBtreeTest, AppendToLeafToCapacity) {
302    AutoUnref refs;
303    std::vector<CordRep*> flats;
304    flats.push_back(MakeHexFlat(0));
305    auto* leaf = CordRepBtree::Create(flats.back());
306    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
307      refs.RefIf(shared(), leaf);
308      flats.push_back(MakeHexFlat(i));
309      auto* result = CordRepBtree::Append(leaf, flats.back());
310      EXPECT_THAT(result->height(), Eq(0));
311      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
312      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
313      leaf = result;
314    }
315    CordRep::Unref(leaf);
316  }
317  TEST_P(CordRepBtreeTest, PrependToLeafToCapacity) {
318    AutoUnref refs;
319    std::deque<CordRep*> flats;
320    flats.push_front(MakeHexFlat(0));
321    auto* leaf = CordRepBtree::Create(flats.front());
322    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
323      refs.RefIf(shared(), leaf);
324      flats.push_front(MakeHexFlat(i));
325      auto* result = CordRepBtree::Prepend(leaf, flats.front());
326      EXPECT_THAT(result->height(), Eq(0));
327      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
328      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
329      leaf = result;
330    }
331    CordRep::Unref(leaf);
332  }
333  TEST_P(CordRepBtreeTest, AppendPrependToLeafToCapacity) {
334    AutoUnref refs;
335    std::deque<CordRep*> flats;
336    flats.push_front(MakeHexFlat(0));
337    auto* leaf = CordRepBtree::Create(flats.front());
338    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
339      refs.RefIf(shared(), leaf);
340      CordRepBtree* result;
341      if (i % 2 != 0) {
342        flats.push_front(MakeHexFlat(i));
343        result = CordRepBtree::Prepend(leaf, flats.front());
344      } else {
345        flats.push_back(MakeHexFlat(i));
346        result = CordRepBtree::Append(leaf, flats.back());
347      }
348      EXPECT_THAT(result->height(), Eq(0));
349      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
350      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
351      leaf = result;
352    }
353    CordRep::Unref(leaf);
354  }
355  TEST_P(CordRepBtreeTest, AppendToLeafBeyondCapacity) {
356    AutoUnref refs;
357    auto* leaf = MakeLeaf();
358    refs.RefIf(shared(), leaf);
359    CordRep* flat = MakeFlat("abc");
360    auto* result = CordRepBtree::Append(leaf, flat);
361    ASSERT_THAT(result, IsNode(1));
362    EXPECT_THAT(result, Ne(leaf));
363    absl::Span<CordRep* const> edges = result->Edges();
364    ASSERT_THAT(edges, ElementsAre(leaf, IsNode(0)));
365    EXPECT_THAT(edges[1]->btree()->Edges(), ElementsAre(flat));
366    CordRep::Unref(result);
367  }
368  TEST_P(CordRepBtreeTest, PrependToLeafBeyondCapacity) {
369    AutoUnref refs;
370    auto* leaf = MakeLeaf();
371    refs.RefIf(shared(), leaf);
372    CordRep* flat = MakeFlat("abc");
373    auto* result = CordRepBtree::Prepend(leaf, flat);
374    ASSERT_THAT(result, IsNode(1));
375    EXPECT_THAT(result, Ne(leaf));
376    absl::Span<CordRep* const> edges = result->Edges();
377    ASSERT_THAT(edges, ElementsAre(IsNode(0), leaf));
378    EXPECT_THAT(edges[0]->btree()->Edges(), ElementsAre(flat));
379    CordRep::Unref(result);
380  }
381  TEST_P(CordRepBtreeTest, AppendToTreeOneDeep) {
382    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
383    AutoUnref refs;
384    std::vector<CordRep*> flats;
385    flats.push_back(MakeHexFlat(0));
386    CordRepBtree* tree = CordRepBtree::Create(flats.back());
387    for (size_t i = 1; i <= max_cap; ++i) {
388      flats.push_back(MakeHexFlat(i));
389      tree = CordRepBtree::Append(tree, flats.back());
390    }
391    ASSERT_THAT(tree, IsNode(1));
392    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
393      refs.RefIf(shared(), tree);
394      refs.RefIf(i % 4 == 0, tree->Edges().back());
395      flats.push_back(MakeHexFlat(i));
396      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
397      ASSERT_THAT(result, IsNode(1));
398      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
399      std::vector<CordRep*> edges = GetLeafEdges(result);
400      ASSERT_THAT(edges, ElementsAreArray(flats));
401      tree = result;
402    }
403    CordRep::Unref(tree);
404  }
405  TEST_P(CordRepBtreeTest, AppendToTreeTwoDeep) {
406    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
407    AutoUnref refs;
408    std::vector<CordRep*> flats;
409    flats.push_back(MakeHexFlat(0));
410    CordRepBtree* tree = CordRepBtree::Create(flats.back());
411    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
412      flats.push_back(MakeHexFlat(i));
413      tree = CordRepBtree::Append(tree, flats.back());
414    }
415    ASSERT_THAT(tree, IsNode(2));
416    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
417      refs.RefIf(shared(), tree);
418      refs.RefIf(i % 16 == 0, tree->Edges().back());
419      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
420      flats.push_back(MakeHexFlat(i));
421      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
422      ASSERT_THAT(result, IsNode(2));
423      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
424      std::vector<CordRep*> edges = GetLeafEdges(result);
425      ASSERT_THAT(edges, ElementsAreArray(flats));
426      tree = result;
427    }
428    CordRep::Unref(tree);
429  }
430  TEST_P(CordRepBtreeTest, PrependToTreeOneDeep) {
431    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
432    AutoUnref refs;
433    std::deque<CordRep*> flats;
434    flats.push_back(MakeHexFlat(0));
435    CordRepBtree* tree = CordRepBtree::Create(flats.back());
436    for (size_t i = 1; i <= max_cap; ++i) {
437      flats.push_front(MakeHexFlat(i));
438      tree = CordRepBtree::Prepend(tree, flats.front());
439    }
440    ASSERT_THAT(tree, IsNode(1));
441    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
442      refs.RefIf(shared(), tree);
443      refs.RefIf(i % 4 == 0, tree->Edges().back());
444      flats.push_front(MakeHexFlat(i));
445      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
446      ASSERT_THAT(result, IsNode(1));
447      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
448      std::vector<CordRep*> edges = GetLeafEdges(result);
449      ASSERT_THAT(edges, ElementsAreArray(flats));
450      tree = result;
451    }
452    CordRep::Unref(tree);
453  }
454  TEST_P(CordRepBtreeTest, PrependToTreeTwoDeep) {
455    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
456    AutoUnref refs;
457    std::deque<CordRep*> flats;
458    flats.push_back(MakeHexFlat(0));
459    CordRepBtree* tree = CordRepBtree::Create(flats.back());
460    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
461      flats.push_front(MakeHexFlat(i));
462      tree = CordRepBtree::Prepend(tree, flats.front());
463    }
464    ASSERT_THAT(tree, IsNode(2));
465    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
466      refs.RefIf(shared(), tree);
467      refs.RefIf(i % 16 == 0, tree->Edges().back());
468      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
469      flats.push_front(MakeHexFlat(i));
470      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
471      ASSERT_THAT(result, IsNode(2));
472      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
473      std::vector<CordRep*> edges = GetLeafEdges(result);
474      ASSERT_THAT(edges, ElementsAreArray(flats));
475      tree = result;
476    }
477    CordRep::Unref(tree);
478  }
479  TEST_P(CordRepBtreeDualTest, MergeLeafsNotExceedingCapacity) {
480    for (bool use_append : {false, true}) {
481      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
482      AutoUnref refs;
483      std::vector<CordRep*> flats;
484      CordRepBtree* left = MakeLeaf(3);
485      GetLeafEdges(left, flats);
486      refs.RefIf(first_shared(), left);
487      CordRepBtree* right = MakeLeaf(2);
488      GetLeafEdges(right, flats);
489      refs.RefIf(second_shared(), right);
490      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
491                                      : CordRepBtree::Prepend(right, left);
492      EXPECT_THAT(tree, IsNode(0));
493      EXPECT_THAT(tree->Edges(), ElementsAreArray(flats));
494      CordRepBtree::Unref(tree);
495    }
496  }
497  TEST_P(CordRepBtreeDualTest, MergeLeafsExceedingCapacity) {
498    for (bool use_append : {false, true}) {
499      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
500      AutoUnref refs;
501      CordRepBtree* left = MakeLeaf(CordRepBtree::kMaxCapacity - 2);
502      refs.RefIf(first_shared(), left);
503      CordRepBtree* right = MakeLeaf(CordRepBtree::kMaxCapacity - 1);
504      refs.RefIf(second_shared(), right);
505      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
506                                      : CordRepBtree::Prepend(right, left);
507      EXPECT_THAT(tree, IsNode(1));
508      EXPECT_THAT(tree->Edges(), ElementsAre(left, right));
509      CordRepBtree::Unref(tree);
510    }
511  }
512  TEST_P(CordRepBtreeDualTest, MergeEqualHeightTrees) {
513    for (bool use_append : {false, true}) {
514      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
515      AutoUnref refs;
516      std::vector<CordRep*> flats;
517      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3);
518      GetLeafEdges(left, flats);
519      refs.RefIf(first_shared(), left);
520      CordRepBtree* right = MakeTree(CordRepBtree::kMaxCapacity * 2);
521      GetLeafEdges(right, flats);
522      refs.RefIf(second_shared(), right);
523      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
524                                      : CordRepBtree::Prepend(right, left);
525      EXPECT_THAT(tree, IsNode(1));
526      EXPECT_THAT(tree->Edges(), SizeIs(5u));
527      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
528      CordRepBtree::Unref(tree);
529    }
530  }
531  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeNotExceedingLeafCapacity) {
532    for (bool use_append : {false, true}) {
533      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
534      AutoUnref refs;
535      std::vector<CordRep*> flats;
536      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 2 + 2);
537      GetLeafEdges(left, flats);
538      refs.RefIf(first_shared(), left);
539      CordRepBtree* right = MakeTree(3);
540      GetLeafEdges(right, flats);
541      refs.RefIf(second_shared(), right);
542      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
543                                      : CordRepBtree::Prepend(right, left);
544      EXPECT_THAT(tree, IsNode(1));
545      EXPECT_THAT(tree->Edges(), SizeIs(3u));
546      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
547      CordRepBtree::Unref(tree);
548    }
549  }
550  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeExceedingLeafCapacity) {
551    for (bool use_append : {false, true}) {
552      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
553      AutoUnref refs;
554      std::vector<CordRep*> flats;
555      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3 - 2);
556      GetLeafEdges(left, flats);
557      refs.RefIf(first_shared(), left);
558      CordRepBtree* right = MakeTree(3);
559      GetLeafEdges(right, flats);
560      refs.RefIf(second_shared(), right);
561      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
562                                      : CordRepBtree::Prepend(right, left);
563      EXPECT_THAT(tree, IsNode(1));
564      EXPECT_THAT(tree->Edges(), SizeIs(4u));
565      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
566      CordRepBtree::Unref(tree);
567    }
568  }
569  void RefEdgesAt(size_t depth, AutoUnref& refs, CordRepBtree* tree) {
570    absl::Span<CordRep* const> edges = tree->Edges();
571    if (depth == 0) {
572      refs.Ref(edges.front());
573      refs.Ref(edges.back());
574    } else {
575      assert(tree->height() > 0);
576      RefEdgesAt(depth - 1, refs, edges.front()->btree());
577      RefEdgesAt(depth - 1, refs, edges.back()->btree());
578    }
579  }
580  TEST(CordRepBtreeTest, MergeFuzzTest) {
581    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
582    std::minstd_rand rnd;
583    std::uniform_int_distribution<int> coin_flip(0, 1);
584    std::uniform_int_distribution<int> dice_throw(1, 6);
585    auto random_leaf_count = [&]() {
586      std::uniform_int_distribution<int> dist_height(0, 3);
587      std::uniform_int_distribution<int> dist_leaf(0, max_cap - 1);
588      const int height = dist_height(rnd);
589      return (height ? pow(max_cap, height) : 0) + dist_leaf(rnd);
590    };
591    for (int i = 0; i < 10000; ++i) {
592      AutoUnref refs;
593      std::vector<CordRep*> flats;
594      CordRepBtree* left = MakeTree(random_leaf_count(), coin_flip(rnd));
595      GetLeafEdges(left, flats);
596      if (dice_throw(rnd) == 1) {
597        std::uniform_int_distribution<size_t> dist(
598            0, static_cast<size_t>(left->height()));
599        RefEdgesAt(dist(rnd), refs, left);
600      }
601      CordRepBtree* right = MakeTree(random_leaf_count(), coin_flip(rnd));
602      GetLeafEdges(right, flats);
603      if (dice_throw(rnd) == 1) {
604        std::uniform_int_distribution<size_t> dist(
605            0, static_cast<size_t>(right->height()));
606        RefEdgesAt(dist(rnd), refs, right);
607      }
608      CordRepBtree* tree = CordRepBtree::Append(left, right);
609      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
610      CordRepBtree::Unref(tree);
611    }
612  }
613  TEST_P(CordRepBtreeTest, RemoveSuffix) {
614    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
615    for (size_t cap : {max_cap - 1, max_cap * 2, max_cap * max_cap * 2}) {
616      const std::string data = CreateRandomString(cap * 512);
617      {
618        AutoUnref refs;
619        CordRepBtree* node = refs.RefIf(shared(), CreateTree(data, 512));
620        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, data.length()), Eq(nullptr));
621        node = refs.RefIf(shared(), CreateTree(data, 512));
622        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, 0), Eq(node));
623        CordRep::Unref(node);
624      }
625      for (size_t n = 1; n < data.length(); ++n) {
626        AutoUnref refs;
627        auto flats = CreateFlatsFromString(data, 512);
628        CordRepBtree* node = refs.RefIf(shared(), CreateTree(flats));
629        CordRep* rep = refs.Add(CordRepBtree::RemoveSuffix(node, n));
630        EXPECT_THAT(CordToString(rep), Eq(data.substr(0, data.length() - n)));
631        auto is_flat = [](CordRep* rep) { return rep->tag >= FLAT; };
632        std::vector<CordRep*> edges = CordCollectRepsIf(is_flat, rep);
633        ASSERT_THAT(edges.size(), Le(flats.size()));
634        CordRep* last_edge = edges.back();
635        edges.pop_back();
636        const size_t last_length = rep->length - edges.size() * 512;
637        size_t index = 0;
638        for (CordRep* edge : edges) {
639          ASSERT_THAT(edge, Eq(flats[index++]));
640          ASSERT_THAT(edge->length, Eq(512u));
641        }
642        if (last_length >= 500) {
643          EXPECT_THAT(last_edge, Eq(flats[index++]));
644          if (shared()) {
645            EXPECT_THAT(last_edge->length, Eq(512u));
646          } else {
647            EXPECT_TRUE(last_edge->refcount.IsOne());
648            EXPECT_THAT(last_edge->length, Eq(last_length));
649          }
650        }
651      }
652    }
653  }
654  TEST(CordRepBtreeTest, SubTree) {
655    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
656    const size_t n = max_cap * max_cap * 2;
657    const std::string data = CreateRandomString(n * 3);
658    std::vector<CordRep*> flats;
659    for (absl::string_view s = data; !s.empty(); s.remove_prefix(3)) {
660      flats.push_back(MakeFlat(s.substr(0, 3)));
661    }
662    CordRepBtree* node = CordRepBtree::Create(CordRep::Ref(flats[0]));
663    for (size_t i = 1; i < flats.size(); ++i) {
664      node = CordRepBtree::Append(node, CordRep::Ref(flats[i]));
665    }
666    for (size_t offset = 0; offset < data.length(); ++offset) {
667      for (size_t length = 1; length <= data.length() - offset; ++length) {
668        CordRep* rep = node->SubTree(offset, length);
669        EXPECT_THAT(CordToString(rep), Eq(data.substr(offset, length)));
670        CordRep::Unref(rep);
671      }
672    }
673    CordRepBtree::Unref(node);
674    for (CordRep* rep : flats) {
675      CordRep::Unref(rep);
676    }
677  }
678  TEST(CordRepBtreeTest, SubTreeOnExistingSubstring) {
679    AutoUnref refs;
680    std::string data = CreateRandomString(1000);
681    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
682    CordRep* flat = MakeFlat(data);
683    leaf = CordRepBtree::Append(leaf, flat);
684    CordRep* result = leaf->SubTree(0, 3 + 990);
685    ASSERT_THAT(result->tag, Eq(BTREE));
686    CordRep::Unref(leaf);
687    leaf = result->btree();
688    ASSERT_THAT(leaf->Edges(), ElementsAre(_, IsSubstring(0u, 990u)));
689    EXPECT_THAT(leaf->Edges()[1]->substring()->child, Eq(flat));
690    result = leaf->SubTree(3 + 5, 970);
691    ASSERT_THAT(result, IsSubstring(5u, 970u));
692    EXPECT_THAT(result->substring()->child, Eq(flat));
693    CordRep::Unref(result);
694    CordRep::Unref(leaf);
695  }
696  TEST_P(CordRepBtreeTest, AddDataToLeaf) {
697    const size_t n = CordRepBtree::kMaxCapacity;
698    const std::string data = CreateRandomString(n * 3);
699    for (bool append : {true, false}) {
<span onclick='openModal()' class='match'>700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
</span>706        CordRepBtree* result = BtreeAdd(leaf, append, consumer.Next(3));
707        EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
708        EXPECT_THAT(CordToString(result), Eq(consumer.Consumed()));
709        leaf = result;
710      }
711      CordRep::Unref(leaf);
712    }
713  }
714  TEST_P(CordRepBtreeTest, AppendDataToTree) {
715    AutoUnref refs;
716    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
717    std::string data = CreateRandomString(n * 3);
718    CordRepBtree* tree = refs.RefIf(shared(), CreateTree(data, 3));
719    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
720    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
721    CordRepBtree* result = CordRepBtree::Append(tree, "123456789");
722    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
723    EXPECT_THAT(result->Edges(),
724                ElementsAre(leaf0, Conditional(shared(), Ne(leaf1), Eq(leaf1))));
725    EXPECT_THAT(CordToString(result), Eq(data + "123456789"));
726    CordRep::Unref(result);
727  }
728  TEST_P(CordRepBtreeTest, PrependDataToTree) {
729    AutoUnref refs;
730    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
731    std::string data = CreateRandomString(n * 3);
732    CordRepBtree* tree = refs.RefIf(shared(), CreateTreeReverse(data, 3));
733    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
734    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
735    CordRepBtree* result = CordRepBtree::Prepend(tree, "123456789");
736    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
737    EXPECT_THAT(result->Edges(),
738                ElementsAre(Conditional(shared(), Ne(leaf0), Eq(leaf0)), leaf1));
739    EXPECT_THAT(CordToString(result), Eq("123456789" + data));
740    CordRep::Unref(result);
741  }
742  TEST_P(CordRepBtreeTest, AddDataToTreeThreeLevelsDeep) {
743    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
744    const size_t n = max_cap * max_cap * max_cap;
745    const std::string data = CreateRandomString(n * 3);
746    for (bool append : {true, false}) {
747      AutoUnref refs;
748      DataConsumer consumer(data, append);
749      SCOPED_TRACE(append ? "Append" : "Prepend");
750      CordRepBtree* tree = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
751      for (size_t i = 1; i < max_cap; ++i) {
752        tree = BtreeAdd(tree, append, consumer.Next(3));
753      }
754      ASSERT_THAT(CordToString(tree), Eq(consumer.Consumed()));
755      refs.RefIf(shared(), tree);
756      CordRepBtree* result = BtreeAdd(tree, append, consumer.Next(3));
757      ASSERT_THAT(result, IsNode(1));
758      ASSERT_THAT(result, Ne(tree));
759      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
760      tree = result;
761      for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
762        refs.RefIf(shared(), tree);
763        result = BtreeAdd(tree, append, consumer.Next(3));
764        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
765        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
766        tree = result;
767      }
768      refs.RefIf(shared(), tree);
769      result = BtreeAdd(tree, append, consumer.Next(3));
770      ASSERT_THAT(result, IsNode(2));
771      ASSERT_THAT(result, Ne(tree));
772      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
773      tree = result;
774      for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap;
775           ++i) {
776        refs.RefIf(shared(), tree);
777        result = BtreeAdd(tree, append, consumer.Next(3));
778        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
779        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
780        tree = result;
781      }
782      CordRep::Unref(tree);
783    }
784  }
785  TEST_P(CordRepBtreeTest, AddLargeDataToLeaf) {
786    const size_t max_cap = CordRepBtree::kMaxCapacity;
787    const size_t n = max_cap * max_cap * max_cap * 3 + 2;
788    const std::string data = CreateRandomString(n * kMaxFlatLength);
789    for (bool append : {true, false}) {
790      AutoUnref refs;
791      SCOPED_TRACE(append ? "Append" : "Prepend");
792      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
793      refs.RefIf(shared(), leaf);
794      CordRepBtree* result = BtreeAdd(leaf, append, data);
795      EXPECT_THAT(CordToString(result), Eq(append ? "abc" + data : data + "abc"));
796      CordRep::Unref(result);
797    }
798  }
799  TEST_P(CordRepBtreeTest, CreateFromTreeReturnsTree) {
800    AutoUnref refs;
801    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
802    refs.RefIf(shared(), leaf);
803    CordRepBtree* result = CordRepBtree::Create(leaf);
804    EXPECT_THAT(result, Eq(leaf));
805    CordRep::Unref(result);
806  }
807  TEST(CordRepBtreeTest, GetCharacter) {
808    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
809    std::string data = CreateRandomString(n * 3);
810    CordRepBtree* tree = CreateTree(data, 3);
811    tree = tree->Append(tree, MakeSubstring(4, 5, MakeFlat("abcdefghijklm")));
812    data += "efghi";
813    for (size_t i = 0; i < data.length(); ++i) {
814      ASSERT_THAT(tree->GetCharacter(i), Eq(data[i]));
815    }
816    CordRep::Unref(tree);
817  }
818  TEST_P(CordRepBtreeTest, IsFlatSingleFlat) {
819    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
820    absl::string_view fragment;
821    EXPECT_TRUE(leaf->IsFlat(nullptr));
822    EXPECT_TRUE(leaf->IsFlat(&fragment));
823    EXPECT_THAT(fragment, Eq("Hello world"));
824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
833  }
834  TEST(CordRepBtreeTest, IsFlatMultiFlat) {
835    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
836    std::string data = CreateRandomString(n * 3);
837    CordRepBtree* tree = CreateTree(data, 3);
838    tree = tree->Append(tree, MakeSubstring(4, 3, MakeFlat("abcdefghijklm")));
839    tree = tree->Append(tree, MakeSubstring(8, 3, MakeFlat("abcdefghijklm")));
840    data += "efgijk";
841    EXPECT_FALSE(tree->IsFlat(nullptr));
842    absl::string_view fragment = "Can't touch this";
843    EXPECT_FALSE(tree->IsFlat(&fragment));
844    EXPECT_THAT(fragment, Eq("Can't touch this"));
845    for (size_t offset = 0; offset < data.size(); offset += 3) {
846      EXPECT_TRUE(tree->IsFlat(offset, 3, nullptr));
847      EXPECT_TRUE(tree->IsFlat(offset, 3, &fragment));
848      EXPECT_THAT(fragment, Eq(data.substr(offset, 3)));
849      fragment = "Can't touch this";
850      if (offset > 0) {
851        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, nullptr));
852        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, &fragment));
853        EXPECT_THAT(fragment, Eq("Can't touch this"));
854      }
855      if (offset < data.size() - 4) {
856        EXPECT_FALSE(tree->IsFlat(offset, 4, nullptr));
857        EXPECT_FALSE(tree->IsFlat(offset, 4, &fragment));
858        EXPECT_THAT(fragment, Eq("Can't touch this"));
859      }
860    }
861    CordRep::Unref(tree);
862  }
863  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
864  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotPrivate) {
865    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
866    CordRepBtree::Ref(tree);
867    EXPECT_DEATH(tree->GetAppendBuffer(1), ".*");
868    CordRepBtree::Unref(tree);
869    CordRepBtree::Unref(tree);
870  }
871  #endif  
872  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotFlat) {
873    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
874    for (int i = 1; i <= height(); ++i) {
875      tree = CordRepBtree::New(tree);
876    }
877    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
878    CordRepBtree::Unref(tree);
879  }
880  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNotPrivate) {
881    CordRepFlat* flat = MakeFlat("abc");
882    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
883    for (int i = 1; i <= height(); ++i) {
884      tree = CordRepBtree::New(tree);
885    }
886    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
887    CordRepBtree::Unref(tree);
888    CordRep::Unref(flat);
889  }
890  TEST_P(CordRepBtreeHeightTest, GetAppendBufferTreeNotPrivate) {
891    if (height() == 0) return;
892    AutoUnref refs;
893    CordRepFlat* flat = MakeFlat("abc");
894    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
895    for (int i = 1; i <= height(); ++i) {
896      if (i == (height() + 1) / 2) refs.Ref(tree);
897      tree = CordRepBtree::New(tree);
898    }
899    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
900    CordRepBtree::Unref(tree);
901    CordRep::Unref(flat);
902  }
903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
909    }
910    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
911    CordRepBtree::Unref(tree);
912  }
913  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatWithCapacity) {
914    CordRepFlat* flat = MakeFlat("abc");
915    CordRepBtree* tree = CordRepBtree::Create(flat);
916    for (int i = 1; i <= height(); ++i) {
917      tree = CordRepBtree::New(tree);
918    }
919    absl::Span<char> span = tree->GetAppendBuffer(2);
920    EXPECT_THAT(span, SizeIs(2u));
921    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 3));
922    EXPECT_THAT(tree->length, Eq(5u));
923    size_t avail = flat->Capacity() - 5;
924    span = tree->GetAppendBuffer(avail + 100);
925    EXPECT_THAT(span, SizeIs(avail));
926    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 5));
927    EXPECT_THAT(tree->length, Eq(5 + avail));
928    CordRepBtree::Unref(tree);
929  }
930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
944    while (tree->height() == 0) {
945      tree = CordRepBtree::Append(tree, CordRep::Ref(flat));
946      tree = CordRepBtree::Append(tree, CordRep::Ref(external));
947      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_flat));
948      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_external));
949    }
950    for (int api = 0; api <= 3; ++api) {
951      absl::string_view api_scope;
952      std::stringstream ss;
953      switch (api) {
954        case 0:
955          api_scope = "Bare";
956          CordRepBtree::Dump(tree, ss);
957          break;
958        case 1:
959          api_scope = "Label only";
960          CordRepBtree::Dump(tree, "Once upon a label", ss);
961          break;
962        case 2:
963          api_scope = "Label no content";
964          CordRepBtree::Dump(tree, "Once upon a label", false, ss);
965          break;
966        default:
967          api_scope = "Label and content";
968          CordRepBtree::Dump(tree, "Once upon a label", true, ss);
969          break;
970      }
971      SCOPED_TRACE(api_scope);
972      std::string str = ss.str();
973      EXPECT_THAT(str, AllOf(HasSubstr("Node(1)"), HasSubstr("Leaf"),
974                             HasSubstr("Private"), HasSubstr("Shared")));
975      EXPECT_THAT(str, AllOf(HasSubstr("len = 11"), HasSubstr("len = 14"),
976                             HasSubstr("len = 6"), HasSubstr("len = 7"),
977                             HasSubstr("start = 1"), HasSubstr("start = 2")));
978      EXPECT_THAT(
979          str, AllOf(HasSubstr(absl::StrCat("0x", absl::Hex(flat))),
980                     HasSubstr(absl::StrCat("0x", absl::Hex(external))),
981                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_flat))),
982                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_external)))));
983      if (api != 0) {
984        EXPECT_THAT(str, HasSubstr("Once upon a label"));
985      }
986      if (api != 3) {
987        EXPECT_THAT(str, Not(AnyOf((HasSubstr("data = \"Hello world\""),
988                                    HasSubstr("data = \"Hello external\""),
989                                    HasSubstr("data = \"ello w\""),
990                                    HasSubstr("data = \"llo ext\"")))));
991      } else {
992        EXPECT_THAT(str, AllOf((HasSubstr("data = \"Hello world\""),
993                                HasSubstr("data = \"Hello external\""),
994                                HasSubstr("data = \"ello w\""),
995                                HasSubstr("data = \"llo ext\""))));
996      }
997    }
998    CordRep::Unref(tree);
999  }
1000  TEST(CordRepBtreeTest, IsValid) {
1001    EXPECT_FALSE(CordRepBtree::IsValid(nullptr));
1002    CordRepBtree* empty = CordRepBtree::New(0);
1003    EXPECT_TRUE(CordRepBtree::IsValid(empty));
1004    CordRep::Unref(empty);
1005    for (bool as_tree : {false, true}) {
1006      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
1007      CordRepBtree* tree = as_tree ? CordRepBtree::New(leaf) : nullptr;
1008      CordRepBtree* check = as_tree ? tree : leaf;
1009      ASSERT_TRUE(CordRepBtree::IsValid(check));
1010      leaf->length--;
1011      EXPECT_FALSE(CordRepBtree::IsValid(check));
1012      leaf->length++;
1013      ASSERT_TRUE(CordRepBtree::IsValid(check));
1014      leaf->tag--;
1015      EXPECT_FALSE(CordRepBtree::IsValid(check));
1016      leaf->tag++;
1017      ASSERT_TRUE(CordRepBtree::IsValid(check));
1018      leaf->storage[0] = static_cast<uint8_t>(CordRepBtree::kMaxHeight + 1);
1019      EXPECT_FALSE(CordRepBtree::IsValid(check));
1020      leaf->storage[0] = 1;
1021      EXPECT_FALSE(CordRepBtree::IsValid(check));
1022      leaf->storage[0] = 0;
1023      ASSERT_TRUE(CordRepBtree::IsValid(check));
1024      const uint8_t begin = leaf->storage[1];
1025      leaf->storage[1] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity);
1026      EXPECT_FALSE(CordRepBtree::IsValid(check));
1027      leaf->storage[1] = 2;
1028      EXPECT_FALSE(CordRepBtree::IsValid(check));
1029      leaf->storage[1] = begin;
1030      ASSERT_TRUE(CordRepBtree::IsValid(check));
1031      const uint8_t end = leaf->storage[2];
1032      leaf->storage[2] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity + 1);
1033      EXPECT_FALSE(CordRepBtree::IsValid(check));
1034      leaf->storage[2] = end;
1035      ASSERT_TRUE(CordRepBtree::IsValid(check));
1036      CordRep* const edge = leaf->Edges()[0];
1037      const uint8_t tag = edge->tag;
1038      CordRepBtreeTestPeer::SetEdge(leaf, begin, nullptr);
1039      EXPECT_FALSE(CordRepBtree::IsValid(check));
1040      CordRepBtreeTestPeer::SetEdge(leaf, begin, edge);
1041      edge->tag = BTREE;
1042      EXPECT_FALSE(CordRepBtree::IsValid(check));
1043      edge->tag = tag;
1044      if (as_tree) {
1045        ASSERT_TRUE(CordRepBtree::IsValid(check));
1046        leaf->length--;
1047        EXPECT_FALSE(CordRepBtree::IsValid(check));
1048        leaf->length++;
1049        ASSERT_TRUE(CordRepBtree::IsValid(check));
1050        tree->storage[0] = static_cast<uint8_t>(2);
1051        EXPECT_FALSE(CordRepBtree::IsValid(check));
1052        tree->storage[0] = 1;
1053        ASSERT_TRUE(CordRepBtree::IsValid(check));
1054        CordRep* const edge = tree->Edges()[0];
1055        const uint8_t tag = edge->tag;
1056        edge->tag = FLAT;
1057        EXPECT_FALSE(CordRepBtree::IsValid(check));
1058        edge->tag = tag;
1059      }
1060      ASSERT_TRUE(CordRepBtree::IsValid(check));
1061      CordRep::Unref(check);
1062    }
1063  }
1064  TEST(CordRepBtreeTest, AssertValid) {
1065    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
1066    const CordRepBtree* ctree = tree;
1067    EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree));
1068    EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree));
1069  #if defined(GTEST_HAS_DEATH_TEST)
1070    CordRepBtree* nulltree = nullptr;
1071    const CordRepBtree* cnulltree = nullptr;
1072    EXPECT_DEBUG_DEATH(
1073        EXPECT_THAT(CordRepBtree::AssertValid(nulltree), Eq(nulltree)), ".*");
1074    EXPECT_DEBUG_DEATH(
1075        EXPECT_THAT(CordRepBtree::AssertValid(cnulltree), Eq(cnulltree)), ".*");
1076    tree->length--;
1077    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree)),
1078                       ".*");
1079    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree)),
1080                       ".*");
1081    tree->length++;
1082  #endif
1083    CordRep::Unref(tree);
1084  }
1085  TEST(CordRepBtreeTest, CheckAssertValidShallowVsDeep) {
1086    const bool exhaustive_validation = IsCordBtreeExhaustiveValidationEnabled();
1087    auto cleanup = absl::MakeCleanup([exhaustive_validation] {
1088      SetCordBtreeExhaustiveValidation(exhaustive_validation);
1089    });
1090    CordRep* flat = MakeFlat("abc");
1091    CordRepBtree* tree = CordRepBtree::Create(flat);
1092    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
1093    const size_t n = max_cap * max_cap * 2;
1094    for (size_t i = 0; i < n; ++i) {
1095      tree = CordRepBtree::Append(tree, MakeFlat("Hello world"));
1096    }
1097    flat->length = 100;
1098    SetCordBtreeExhaustiveValidation(false);
1099    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1100    EXPECT_TRUE(CordRepBtree::IsValid(tree, true));
1101    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1102    CordRepBtree::AssertValid(tree);
1103    CordRepBtree::AssertValid(tree, true);
1104  #if defined(GTEST_HAS_DEATH_TEST)
1105    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, false), ".*");
1106  #endif
1107    SetCordBtreeExhaustiveValidation(true);
1108    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1109    EXPECT_FALSE(CordRepBtree::IsValid(tree, true));
1110    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1111  #if defined(GTEST_HAS_DEATH_TEST)
1112    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree), ".*");
1113    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, true), ".*");
1114  #endif
1115    flat->length = 3;
1116    CordRep::Unref(tree);
1117  }
1118  TEST_P(CordRepBtreeTest, Rebuild) {
1119    for (size_t size : {3u, 8u, 100u, 10000u, 1000000u}) {
1120      SCOPED_TRACE(absl::StrCat("Rebuild @", size));
1121      std::vector<CordRepFlat*> flats;
1122      for (size_t i = 0; i < size; ++i) {
1123        flats.push_back(CordRepFlat::New(2));
1124        flats.back()->Data()[0] = 'x';
1125        flats.back()->length = 1;
1126      }
1127      size_t split_count = 0;
1128      size_t split_limit = 3;
1129      auto it = flats.begin();
1130      CordRepBtree* left = nullptr;
1131      CordRepBtree* right = CordRepBtree::New(*it);
1132      while (++it != flats.end()) {
1133        if (++split_count >= split_limit) {
1134          split_limit += split_limit / 16;
1135          left = left ? CordRepBtree::Append(left, right) : right;
1136          right = CordRepBtree::New(*it);
1137        } else {
1138          right = CordRepBtree::Append(right, *it);
1139        }
1140      }
1141      left = left ? CordRepBtree::Append(left, right) : right;
1142      AutoUnref ref;
1143      left = ref.Add(CordRepBtree::Rebuild(ref.RefIf(shared(), left)));
1144      ASSERT_TRUE(CordRepBtree::IsValid(left));
1145      bool ok = true;
1146      it = flats.begin();
1147      CordVisitReps(left, [&](CordRep* edge) {
1148        if (edge->tag < FLAT) return;
1149        ok = ok && (it != flats.end() && *it++ == edge);
1150      });
1151      EXPECT_TRUE(ok && it == flats.end()) << "Rebuild edges mismatch";
1152    }
1153  }
1154  CordRepBtree::ExtractResult ExtractLast(CordRepBtree* input, size_t cap = 1) {
1155    return CordRepBtree::ExtractAppendBuffer(input, cap);
1156  }
1157  TEST(CordRepBtreeTest, ExtractAppendBufferLeafSingleFlat) {
1158    CordRep* flat = MakeFlat("Abc");
1159    CordRepBtree* leaf = CordRepBtree::Create(flat);
1160    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(nullptr, flat));
1161    CordRep::Unref(flat);
1162  }
1163  TEST(CordRepBtreeTest, ExtractAppendBufferNodeSingleFlat) {
1164    CordRep* flat = MakeFlat("Abc");
1165    CordRepBtree* leaf = CordRepBtree::Create(flat);
1166    CordRepBtree* node = CordRepBtree::New(leaf);
1167    EXPECT_THAT(ExtractLast(node), EqExtractResult(nullptr, flat));
1168    CordRep::Unref(flat);
1169  }
1170  TEST(CordRepBtreeTest, ExtractAppendBufferLeafTwoFlats) {
1171    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1172    CordRepBtree* leaf = CreateTree(flats);
1173    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(flats[0], flats[1]));
1174    CordRep::Unref(flats[0]);
1175    CordRep::Unref(flats[1]);
1176  }
1177  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlats) {
1178    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1179    CordRepBtree* leaf = CreateTree(flats);
1180    CordRepBtree* node = CordRepBtree::New(leaf);
1181    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1182    CordRep::Unref(flats[0]);
1183    CordRep::Unref(flats[1]);
1184  }
1185  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlatsInTwoLeafs) {
1186    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1187    CordRepBtree* leaf1 = CordRepBtree::Create(flats[0]);
1188    CordRepBtree* leaf2 = CordRepBtree::Create(flats[1]);
1189    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1190    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1191    CordRep::Unref(flats[0]);
1192    CordRep::Unref(flats[1]);
1193  }
1194  TEST(CordRepBtreeTest, ExtractAppendBufferLeafThreeFlats) {
1195    std::vector<CordRep*> flats = CreateFlatsFromString("abcdefghi", 3);
1196    CordRepBtree* leaf = CreateTree(flats);
1197    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, flats[2]));
1198    CordRep::Unref(flats[2]);
1199    CordRep::Unref(leaf);
1200  }
1201  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightNoFolding) {
1202    CordRep* flat = MakeFlat("Abc");
1203    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1204    CordRepBtree* leaf1 = CordRepBtree::Create(flat);
1205    CordRepBtree* leaf2 = CreateTree(flats);
1206    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1207    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, flats[1]));
1208    EXPECT_THAT(node->Edges(), ElementsAre(leaf1, leaf2));
1209    EXPECT_THAT(leaf1->Edges(), ElementsAre(flat));
1210    EXPECT_THAT(leaf2->Edges(), ElementsAre(flats[0]));
1211    CordRep::Unref(node);
1212    CordRep::Unref(flats[1]);
1213  }
1214  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightLeafFolding) {
1215    CordRep* flat = MakeFlat("Abc");
1216    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1217    CordRepBtree* leaf1 = CreateTree(flats);
1218    CordRepBtree* leaf2 = CordRepBtree::Create(flat);
1219    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1220    EXPECT_THAT(ExtractLast(node), EqExtractResult(leaf1, flat));
1221    EXPECT_THAT(leaf1->Edges(), ElementsAreArray(flats));
1222    CordRep::Unref(leaf1);
1223    CordRep::Unref(flat);
1224  }
1225  TEST(CordRepBtreeTest, ExtractAppendBufferNoCapacity) {
1226    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1227    CordRepBtree* leaf = CreateTree(flats);
1228    size_t avail = flats[1]->flat()->Capacity() - flats[1]->length;
1229    EXPECT_THAT(ExtractLast(leaf, avail + 1), EqExtractResult(leaf, nullptr));
1230    EXPECT_THAT(ExtractLast(leaf, avail), EqExtractResult(flats[0], flats[1]));
1231    CordRep::Unref(flats[0]);
1232    CordRep::Unref(flats[1]);
1233  }
1234  TEST(CordRepBtreeTest, ExtractAppendBufferNotFlat) {
1235    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1236    auto substr = MakeSubstring(1, 2, flats[1]);
1237    CordRepBtree* leaf = CreateTree({flats[0], substr});
1238    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1239    CordRep::Unref(leaf);
1240  }
1241  TEST(CordRepBtreeTest, ExtractAppendBufferShared) {
1242    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1243    CordRepBtree* leaf = CreateTree(flats);
1244    CordRep::Ref(flats[1]);
1245    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1246    CordRep::Unref(flats[1]);
1247    CordRep::Ref(leaf);
1248    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1249    CordRep::Unref(leaf);
1250    CordRepBtree* node = CordRepBtree::New(leaf);
1251    CordRep::Ref(node);
1252    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, nullptr));
1253    CordRep::Unref(node);
1254    CordRep::Unref(node);
1255  }
1256  }  
1257  }  
1258  ABSL_NAMESPACE_END
1259  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree.h"
2  #include <cmath>
3  #include <deque>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/cleanup/cleanup.h"
12  #include "absl/strings/internal/cord_data_edge.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_test_util.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace cord_internal {
20  class CordRepBtreeTestPeer {
21   public:
22    static void SetEdge(CordRepBtree* node, size_t idx, CordRep* edge) {
23      node->edges_[idx] = edge;
24    }
25    static void AddEdge(CordRepBtree* node, CordRep* edge) {
26      node->edges_[node->fetch_add_end(1)] = edge;
27    }
28  };
29  namespace {
30  using ::absl::cordrep_testing::AutoUnref;
31  using ::absl::cordrep_testing::CordCollectRepsIf;
32  using ::absl::cordrep_testing::CordToString;
33  using ::absl::cordrep_testing::CordVisitReps;
34  using ::absl::cordrep_testing::CreateFlatsFromString;
35  using ::absl::cordrep_testing::CreateRandomString;
36  using ::absl::cordrep_testing::MakeExternal;
37  using ::absl::cordrep_testing::MakeFlat;
38  using ::absl::cordrep_testing::MakeSubstring;
39  using ::testing::_;
40  using ::testing::AllOf;
41  using ::testing::AnyOf;
42  using ::testing::Conditional;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::Eq;
46  using ::testing::HasSubstr;
47  using ::testing::Le;
48  using ::testing::Ne;
49  using ::testing::Not;
50  using ::testing::SizeIs;
51  using ::testing::TypedEq;
52  MATCHER_P(EqFlatHolding, data, "Equals flat holding data") {
53    if (arg->tag < FLAT) {
54      *result_listener << "Expected FLAT, got tag " << static_cast<int>(arg->tag);
55      return false;
56    }
57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
60                       << "\", got flat holding \"" << actual << "\"";
61      return false;
62    }
63    return true;
64  }
65  MATCHER_P(IsNode, height, absl::StrCat("Is a valid node of height ", height)) {
66    if (arg == nullptr) {
67      *result_listener << "Expected NODE, got nullptr";
68      return false;
69    }
70    if (arg->tag != BTREE) {
71      *result_listener << "Expected NODE, got " << static_cast<int>(arg->tag);
72      return false;
73    }
74    if (!CordRepBtree::IsValid(arg->btree())) {
75      CordRepBtree::Dump(arg->btree(), "Expected valid NODE, got:", false,
76                         *result_listener->stream());
77      return false;
78    }
79    if (arg->btree()->height() != height) {
80      *result_listener << "Expected NODE of height " << height << ", got "
81                       << arg->btree()->height();
82      return false;
83    }
84    return true;
85  }
86  MATCHER_P2(IsSubstring, start, length,
87             absl::StrCat("Is a substring(start = ", start, ", length = ", length,
88                          ")")) {
89    if (arg == nullptr) {
90      *result_listener << "Expected substring, got nullptr";
91      return false;
92    }
93    if (arg->tag != SUBSTRING) {
94      *result_listener << "Expected SUBSTRING, got "
95                       << static_cast<int>(arg->tag);
96      return false;
97    }
98    const CordRepSubstring* const substr = arg->substring();
99    if (substr->start != start || substr->length != length) {
100      *result_listener << "Expected substring(" << start << ", " << length
101                       << "), got substring(" << substr->start << ", "
102                       << substr->length << ")";
103      return false;
104    }
105    return true;
106  }
107  MATCHER_P2(EqExtractResult, tree, rep, "Equals ExtractResult") {
108    if (arg.tree != tree || arg.extracted != rep) {
109      *result_listener << "Expected {" << static_cast<const void*>(tree) << ", "
110                       << static_cast<const void*>(rep) << "}, got {" << arg.tree
111                       << ", " << arg.extracted << "}";
112      return false;
113    }
114    return true;
115  }
116  class DataConsumer {
117   public:
118    DataConsumer(absl::string_view data, bool forward)
119        : data_(data), forward_(forward) {}
120    absl::string_view Next(size_t n) {
121      assert(n <= data_.size() - consumed_);
122      consumed_ += n;
123      return data_.substr(forward_ ? consumed_ - n : data_.size() - consumed_, n);
124    }
125    absl::string_view Consumed() const {
126      return forward_ ? data_.substr(0, consumed_)
127                      : data_.substr(data_.size() - consumed_);
128    }
129   private:
130    absl::string_view data_;
131    size_t consumed_ = 0;
132    bool forward_;
133  };
134  CordRepBtree* BtreeAdd(CordRepBtree* node, bool append,
135                         absl::string_view data) {
136    return append ? CordRepBtree::Append(node, data)
137                  : CordRepBtree::Prepend(node, data);
138  }
139  void GetLeafEdges(const CordRepBtree* tree, std::vector<CordRep*>& edges) {
140    if (tree->height() == 0) {
141      for (CordRep* edge : tree->Edges()) {
142        edges.push_back(edge);
143      }
144    } else {
145      for (CordRep* edge : tree->Edges()) {
146        GetLeafEdges(edge->btree(), edges);
147      }
148    }
149  }
150  std::vector<CordRep*> GetLeafEdges(const CordRepBtree* tree) {
151    std::vector<CordRep*> edges;
152    GetLeafEdges(tree, edges);
153    return edges;
154  }
155  CordRepFlat* MakeHexFlat(size_t i) {
156    return MakeFlat(absl::StrCat("0x", absl::Hex(i, absl::kZeroPad4)));
157  }
158  CordRepBtree* MakeLeaf(size_t size = CordRepBtree::kMaxCapacity) {
159    assert(size <= CordRepBtree::kMaxCapacity);
160    CordRepBtree* leaf = CordRepBtree::Create(MakeHexFlat(0));
161    for (size_t i = 1; i < size; ++i) {
162      leaf = CordRepBtree::Append(leaf, MakeHexFlat(i));
163    }
164    return leaf;
165  }
166  CordRepBtree* MakeTree(size_t size, bool append = true) {
167    CordRepBtree* tree = CordRepBtree::Create(MakeHexFlat(0));
168    for (size_t i = 1; i < size; ++i) {
169      tree = append ? CordRepBtree::Append(tree, MakeHexFlat(i))
170                    : CordRepBtree::Prepend(tree, MakeHexFlat(i));
171    }
172    return tree;
173  }
174  CordRepBtree* CreateTree(absl::Span<CordRep* const> reps) {
175    auto it = reps.begin();
176    CordRepBtree* tree = CordRepBtree::Create(*it);
177    while (++it != reps.end()) tree = CordRepBtree::Append(tree, *it);
178    return tree;
179  }
180  CordRepBtree* CreateTree(absl::string_view data, size_t chunk_size) {
181    return CreateTree(CreateFlatsFromString(data, chunk_size));
182  }
183  CordRepBtree* CreateTreeReverse(absl::string_view data, size_t chunk_size) {
184    std::vector<CordRep*> flats = CreateFlatsFromString(data, chunk_size);
185    auto rit = flats.rbegin();
186    CordRepBtree* tree = CordRepBtree::Create(*rit);
187    while (++rit != flats.rend()) tree = CordRepBtree::Prepend(tree, *rit);
188    return tree;
189  }
190  class CordRepBtreeTest : public testing::TestWithParam<bool> {
191   public:
192    bool shared() const { return GetParam(); }
193    static std::string ToString(testing::TestParamInfo<bool> param) {
194      return param.param ? "Shared" : "Private";
195    }
196  };
197  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeTest, testing::Bool(),
198                           CordRepBtreeTest::ToString);
199  class CordRepBtreeHeightTest : public testing::TestWithParam<int> {
200   public:
201    int height() const { return GetParam(); }
202    static std::string ToString(testing::TestParamInfo<int> param) {
203      return absl::StrCat(param.param);
204    }
205  };
206  INSTANTIATE_TEST_SUITE_P(WithHeights, CordRepBtreeHeightTest,
207                           testing::Range(0, CordRepBtree::kMaxHeight),
208                           CordRepBtreeHeightTest::ToString);
209  using TwoBools = testing::tuple<bool, bool>;
210  class CordRepBtreeDualTest : public testing::TestWithParam<TwoBools> {
211   public:
212    bool first_shared() const { return std::get<0>(GetParam()); }
213    bool second_shared() const { return std::get<1>(GetParam()); }
214    static std::string ToString(testing::TestParamInfo<TwoBools> param) {
215      if (std::get<0>(param.param)) {
216        return std::get<1>(param.param) ? "BothShared" : "FirstShared";
217      }
218      return std::get<1>(param.param) ? "SecondShared" : "Private";
219    }
220  };
221  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeDualTest,
222                           testing::Combine(testing::Bool(), testing::Bool()),
223                           CordRepBtreeDualTest::ToString);
224  TEST(CordRepBtreeTest, SizeIsMultipleOf64) {
225    if (sizeof(size_t) == 8 && sizeof(void*) == 8) {
226      EXPECT_THAT(sizeof(CordRepBtree) % 64, Eq(0u))
227          << "Should be multiple of 64";
228    }
229  }
230  TEST(CordRepBtreeTest, NewDestroyEmptyTree) {
231    auto* tree = CordRepBtree::New();
232    EXPECT_THAT(tree->size(), Eq(0u));
233    EXPECT_THAT(tree->height(), Eq(0));
234    EXPECT_THAT(tree->Edges(), ElementsAre());
235    CordRepBtree::Destroy(tree);
236  }
237  TEST(CordRepBtreeTest, NewDestroyEmptyTreeAtHeight) {
238    auto* tree = CordRepBtree::New(3);
239    EXPECT_THAT(tree->size(), Eq(0u));
240    EXPECT_THAT(tree->height(), Eq(3));
241    EXPECT_THAT(tree->Edges(), ElementsAre());
242    CordRepBtree::Destroy(tree);
243  }
244  TEST(CordRepBtreeTest, Btree) {
245    CordRep* rep = CordRepBtree::New();
246    EXPECT_THAT(rep->btree(), Eq(rep));
247    EXPECT_THAT(static_cast<const CordRep*>(rep)->btree(), Eq(rep));
248    CordRep::Unref(rep);
249  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
250    rep = MakeFlat("Hello world");
251    EXPECT_DEATH(rep->btree(), ".*");
252    EXPECT_DEATH(static_cast<const CordRep*>(rep)->btree(), ".*");
253    CordRep::Unref(rep);
254  #endif
255  }
256  TEST(CordRepBtreeTest, EdgeData) {
257    CordRepFlat* flat = MakeFlat("Hello world");
258    CordRepExternal* external = MakeExternal("Hello external");
259    CordRep* substr1 = MakeSubstring(1, 6, CordRep::Ref(flat));
260    CordRep* substr2 = MakeSubstring(1, 6, CordRep::Ref(external));
261    CordRep* bad_substr = MakeSubstring(1, 2, CordRep::Ref(substr1));
262    EXPECT_TRUE(IsDataEdge(flat));
263    EXPECT_THAT(EdgeData(flat).data(), TypedEq<const void*>(flat->Data()));
264    EXPECT_THAT(EdgeData(flat), Eq("Hello world"));
265    EXPECT_TRUE(IsDataEdge(external));
266    EXPECT_THAT(EdgeData(external).data(), TypedEq<const void*>(external->base));
267    EXPECT_THAT(EdgeData(external), Eq("Hello external"));
268    EXPECT_TRUE(IsDataEdge(substr1));
269    EXPECT_THAT(EdgeData(substr1).data(), TypedEq<const void*>(flat->Data() + 1));
270    EXPECT_THAT(EdgeData(substr1), Eq("ello w"));
271    EXPECT_TRUE(IsDataEdge(substr2));
272    EXPECT_THAT(EdgeData(substr2).data(),
273                TypedEq<const void*>(external->base + 1));
274    EXPECT_THAT(EdgeData(substr2), Eq("ello e"));
275    EXPECT_FALSE(IsDataEdge(bad_substr));
276  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
277    EXPECT_DEATH(EdgeData(bad_substr), ".*");
278  #endif
279    CordRep::Unref(bad_substr);
280    CordRep::Unref(substr2);
281    CordRep::Unref(substr1);
282    CordRep::Unref(external);
283    CordRep::Unref(flat);
284  }
285  TEST(CordRepBtreeTest, CreateUnrefLeaf) {
286    auto* flat = MakeFlat("a");
287    auto* leaf = CordRepBtree::Create(flat);
288    EXPECT_THAT(leaf->size(), Eq(1u));
289    EXPECT_THAT(leaf->height(), Eq(0));
290    EXPECT_THAT(leaf->Edges(), ElementsAre(flat));
291    CordRepBtree::Unref(leaf);
292  }
293  TEST(CordRepBtreeTest, NewUnrefNode) {
294    auto* leaf = CordRepBtree::Create(MakeFlat("a"));
295    CordRepBtree* tree = CordRepBtree::New(leaf);
296    EXPECT_THAT(tree->size(), Eq(1u));
297    EXPECT_THAT(tree->height(), Eq(1));
298    EXPECT_THAT(tree->Edges(), ElementsAre(leaf));
299    CordRepBtree::Unref(tree);
300  }
301  TEST_P(CordRepBtreeTest, AppendToLeafToCapacity) {
302    AutoUnref refs;
303    std::vector<CordRep*> flats;
304    flats.push_back(MakeHexFlat(0));
305    auto* leaf = CordRepBtree::Create(flats.back());
306    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
307      refs.RefIf(shared(), leaf);
308      flats.push_back(MakeHexFlat(i));
309      auto* result = CordRepBtree::Append(leaf, flats.back());
310      EXPECT_THAT(result->height(), Eq(0));
311      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
312      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
313      leaf = result;
314    }
315    CordRep::Unref(leaf);
316  }
317  TEST_P(CordRepBtreeTest, PrependToLeafToCapacity) {
318    AutoUnref refs;
319    std::deque<CordRep*> flats;
320    flats.push_front(MakeHexFlat(0));
321    auto* leaf = CordRepBtree::Create(flats.front());
322    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
323      refs.RefIf(shared(), leaf);
324      flats.push_front(MakeHexFlat(i));
325      auto* result = CordRepBtree::Prepend(leaf, flats.front());
326      EXPECT_THAT(result->height(), Eq(0));
327      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
328      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
329      leaf = result;
330    }
331    CordRep::Unref(leaf);
332  }
333  TEST_P(CordRepBtreeTest, AppendPrependToLeafToCapacity) {
334    AutoUnref refs;
335    std::deque<CordRep*> flats;
336    flats.push_front(MakeHexFlat(0));
337    auto* leaf = CordRepBtree::Create(flats.front());
338    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
339      refs.RefIf(shared(), leaf);
340      CordRepBtree* result;
341      if (i % 2 != 0) {
342        flats.push_front(MakeHexFlat(i));
343        result = CordRepBtree::Prepend(leaf, flats.front());
344      } else {
345        flats.push_back(MakeHexFlat(i));
346        result = CordRepBtree::Append(leaf, flats.back());
347      }
348      EXPECT_THAT(result->height(), Eq(0));
349      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
350      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
351      leaf = result;
352    }
353    CordRep::Unref(leaf);
354  }
355  TEST_P(CordRepBtreeTest, AppendToLeafBeyondCapacity) {
356    AutoUnref refs;
357    auto* leaf = MakeLeaf();
358    refs.RefIf(shared(), leaf);
359    CordRep* flat = MakeFlat("abc");
360    auto* result = CordRepBtree::Append(leaf, flat);
361    ASSERT_THAT(result, IsNode(1));
362    EXPECT_THAT(result, Ne(leaf));
363    absl::Span<CordRep* const> edges = result->Edges();
364    ASSERT_THAT(edges, ElementsAre(leaf, IsNode(0)));
365    EXPECT_THAT(edges[1]->btree()->Edges(), ElementsAre(flat));
366    CordRep::Unref(result);
367  }
368  TEST_P(CordRepBtreeTest, PrependToLeafBeyondCapacity) {
369    AutoUnref refs;
370    auto* leaf = MakeLeaf();
371    refs.RefIf(shared(), leaf);
372    CordRep* flat = MakeFlat("abc");
373    auto* result = CordRepBtree::Prepend(leaf, flat);
374    ASSERT_THAT(result, IsNode(1));
375    EXPECT_THAT(result, Ne(leaf));
376    absl::Span<CordRep* const> edges = result->Edges();
377    ASSERT_THAT(edges, ElementsAre(IsNode(0), leaf));
378    EXPECT_THAT(edges[0]->btree()->Edges(), ElementsAre(flat));
379    CordRep::Unref(result);
380  }
381  TEST_P(CordRepBtreeTest, AppendToTreeOneDeep) {
382    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
383    AutoUnref refs;
384    std::vector<CordRep*> flats;
385    flats.push_back(MakeHexFlat(0));
386    CordRepBtree* tree = CordRepBtree::Create(flats.back());
387    for (size_t i = 1; i <= max_cap; ++i) {
388      flats.push_back(MakeHexFlat(i));
389      tree = CordRepBtree::Append(tree, flats.back());
390    }
391    ASSERT_THAT(tree, IsNode(1));
392    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
393      refs.RefIf(shared(), tree);
394      refs.RefIf(i % 4 == 0, tree->Edges().back());
395      flats.push_back(MakeHexFlat(i));
396      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
397      ASSERT_THAT(result, IsNode(1));
398      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
399      std::vector<CordRep*> edges = GetLeafEdges(result);
400      ASSERT_THAT(edges, ElementsAreArray(flats));
401      tree = result;
402    }
403    CordRep::Unref(tree);
404  }
405  TEST_P(CordRepBtreeTest, AppendToTreeTwoDeep) {
406    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
407    AutoUnref refs;
408    std::vector<CordRep*> flats;
409    flats.push_back(MakeHexFlat(0));
410    CordRepBtree* tree = CordRepBtree::Create(flats.back());
411    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
412      flats.push_back(MakeHexFlat(i));
413      tree = CordRepBtree::Append(tree, flats.back());
414    }
415    ASSERT_THAT(tree, IsNode(2));
416    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
417      refs.RefIf(shared(), tree);
418      refs.RefIf(i % 16 == 0, tree->Edges().back());
419      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
420      flats.push_back(MakeHexFlat(i));
421      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
422      ASSERT_THAT(result, IsNode(2));
423      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
424      std::vector<CordRep*> edges = GetLeafEdges(result);
425      ASSERT_THAT(edges, ElementsAreArray(flats));
426      tree = result;
427    }
428    CordRep::Unref(tree);
429  }
430  TEST_P(CordRepBtreeTest, PrependToTreeOneDeep) {
431    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
432    AutoUnref refs;
433    std::deque<CordRep*> flats;
434    flats.push_back(MakeHexFlat(0));
435    CordRepBtree* tree = CordRepBtree::Create(flats.back());
436    for (size_t i = 1; i <= max_cap; ++i) {
437      flats.push_front(MakeHexFlat(i));
438      tree = CordRepBtree::Prepend(tree, flats.front());
439    }
440    ASSERT_THAT(tree, IsNode(1));
441    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
442      refs.RefIf(shared(), tree);
443      refs.RefIf(i % 4 == 0, tree->Edges().back());
444      flats.push_front(MakeHexFlat(i));
445      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
446      ASSERT_THAT(result, IsNode(1));
447      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
448      std::vector<CordRep*> edges = GetLeafEdges(result);
449      ASSERT_THAT(edges, ElementsAreArray(flats));
450      tree = result;
451    }
452    CordRep::Unref(tree);
453  }
454  TEST_P(CordRepBtreeTest, PrependToTreeTwoDeep) {
455    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
456    AutoUnref refs;
457    std::deque<CordRep*> flats;
458    flats.push_back(MakeHexFlat(0));
459    CordRepBtree* tree = CordRepBtree::Create(flats.back());
460    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
461      flats.push_front(MakeHexFlat(i));
462      tree = CordRepBtree::Prepend(tree, flats.front());
463    }
464    ASSERT_THAT(tree, IsNode(2));
465    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
466      refs.RefIf(shared(), tree);
467      refs.RefIf(i % 16 == 0, tree->Edges().back());
468      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
469      flats.push_front(MakeHexFlat(i));
470      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
471      ASSERT_THAT(result, IsNode(2));
472      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
473      std::vector<CordRep*> edges = GetLeafEdges(result);
474      ASSERT_THAT(edges, ElementsAreArray(flats));
475      tree = result;
476    }
477    CordRep::Unref(tree);
478  }
479  TEST_P(CordRepBtreeDualTest, MergeLeafsNotExceedingCapacity) {
480    for (bool use_append : {false, true}) {
481      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
482      AutoUnref refs;
483      std::vector<CordRep*> flats;
484      CordRepBtree* left = MakeLeaf(3);
485      GetLeafEdges(left, flats);
486      refs.RefIf(first_shared(), left);
487      CordRepBtree* right = MakeLeaf(2);
488      GetLeafEdges(right, flats);
489      refs.RefIf(second_shared(), right);
490      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
491                                      : CordRepBtree::Prepend(right, left);
492      EXPECT_THAT(tree, IsNode(0));
493      EXPECT_THAT(tree->Edges(), ElementsAreArray(flats));
494      CordRepBtree::Unref(tree);
495    }
496  }
497  TEST_P(CordRepBtreeDualTest, MergeLeafsExceedingCapacity) {
498    for (bool use_append : {false, true}) {
499      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
500      AutoUnref refs;
501      CordRepBtree* left = MakeLeaf(CordRepBtree::kMaxCapacity - 2);
502      refs.RefIf(first_shared(), left);
503      CordRepBtree* right = MakeLeaf(CordRepBtree::kMaxCapacity - 1);
504      refs.RefIf(second_shared(), right);
505      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
506                                      : CordRepBtree::Prepend(right, left);
507      EXPECT_THAT(tree, IsNode(1));
508      EXPECT_THAT(tree->Edges(), ElementsAre(left, right));
509      CordRepBtree::Unref(tree);
510    }
511  }
512  TEST_P(CordRepBtreeDualTest, MergeEqualHeightTrees) {
513    for (bool use_append : {false, true}) {
514      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
515      AutoUnref refs;
516      std::vector<CordRep*> flats;
517      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3);
518      GetLeafEdges(left, flats);
519      refs.RefIf(first_shared(), left);
520      CordRepBtree* right = MakeTree(CordRepBtree::kMaxCapacity * 2);
521      GetLeafEdges(right, flats);
522      refs.RefIf(second_shared(), right);
523      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
524                                      : CordRepBtree::Prepend(right, left);
525      EXPECT_THAT(tree, IsNode(1));
526      EXPECT_THAT(tree->Edges(), SizeIs(5u));
527      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
528      CordRepBtree::Unref(tree);
529    }
530  }
531  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeNotExceedingLeafCapacity) {
532    for (bool use_append : {false, true}) {
533      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
534      AutoUnref refs;
535      std::vector<CordRep*> flats;
536      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 2 + 2);
537      GetLeafEdges(left, flats);
538      refs.RefIf(first_shared(), left);
539      CordRepBtree* right = MakeTree(3);
540      GetLeafEdges(right, flats);
541      refs.RefIf(second_shared(), right);
542      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
543                                      : CordRepBtree::Prepend(right, left);
544      EXPECT_THAT(tree, IsNode(1));
545      EXPECT_THAT(tree->Edges(), SizeIs(3u));
546      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
547      CordRepBtree::Unref(tree);
548    }
549  }
550  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeExceedingLeafCapacity) {
551    for (bool use_append : {false, true}) {
552      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
553      AutoUnref refs;
554      std::vector<CordRep*> flats;
555      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3 - 2);
556      GetLeafEdges(left, flats);
557      refs.RefIf(first_shared(), left);
558      CordRepBtree* right = MakeTree(3);
559      GetLeafEdges(right, flats);
560      refs.RefIf(second_shared(), right);
561      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
562                                      : CordRepBtree::Prepend(right, left);
563      EXPECT_THAT(tree, IsNode(1));
564      EXPECT_THAT(tree->Edges(), SizeIs(4u));
565      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
566      CordRepBtree::Unref(tree);
567    }
568  }
569  void RefEdgesAt(size_t depth, AutoUnref& refs, CordRepBtree* tree) {
570    absl::Span<CordRep* const> edges = tree->Edges();
571    if (depth == 0) {
572      refs.Ref(edges.front());
573      refs.Ref(edges.back());
574    } else {
575      assert(tree->height() > 0);
576      RefEdgesAt(depth - 1, refs, edges.front()->btree());
577      RefEdgesAt(depth - 1, refs, edges.back()->btree());
578    }
579  }
580  TEST(CordRepBtreeTest, MergeFuzzTest) {
581    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
582    std::minstd_rand rnd;
583    std::uniform_int_distribution<int> coin_flip(0, 1);
584    std::uniform_int_distribution<int> dice_throw(1, 6);
585    auto random_leaf_count = [&]() {
586      std::uniform_int_distribution<int> dist_height(0, 3);
587      std::uniform_int_distribution<int> dist_leaf(0, max_cap - 1);
588      const int height = dist_height(rnd);
589      return (height ? pow(max_cap, height) : 0) + dist_leaf(rnd);
590    };
591    for (int i = 0; i < 10000; ++i) {
592      AutoUnref refs;
593      std::vector<CordRep*> flats;
594      CordRepBtree* left = MakeTree(random_leaf_count(), coin_flip(rnd));
595      GetLeafEdges(left, flats);
596      if (dice_throw(rnd) == 1) {
597        std::uniform_int_distribution<size_t> dist(
598            0, static_cast<size_t>(left->height()));
599        RefEdgesAt(dist(rnd), refs, left);
600      }
601      CordRepBtree* right = MakeTree(random_leaf_count(), coin_flip(rnd));
602      GetLeafEdges(right, flats);
603      if (dice_throw(rnd) == 1) {
604        std::uniform_int_distribution<size_t> dist(
605            0, static_cast<size_t>(right->height()));
606        RefEdgesAt(dist(rnd), refs, right);
607      }
608      CordRepBtree* tree = CordRepBtree::Append(left, right);
609      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
610      CordRepBtree::Unref(tree);
611    }
612  }
613  TEST_P(CordRepBtreeTest, RemoveSuffix) {
614    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
615    for (size_t cap : {max_cap - 1, max_cap * 2, max_cap * max_cap * 2}) {
616      const std::string data = CreateRandomString(cap * 512);
617      {
618        AutoUnref refs;
619        CordRepBtree* node = refs.RefIf(shared(), CreateTree(data, 512));
620        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, data.length()), Eq(nullptr));
621        node = refs.RefIf(shared(), CreateTree(data, 512));
622        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, 0), Eq(node));
623        CordRep::Unref(node);
624      }
625      for (size_t n = 1; n < data.length(); ++n) {
626        AutoUnref refs;
627        auto flats = CreateFlatsFromString(data, 512);
628        CordRepBtree* node = refs.RefIf(shared(), CreateTree(flats));
629        CordRep* rep = refs.Add(CordRepBtree::RemoveSuffix(node, n));
630        EXPECT_THAT(CordToString(rep), Eq(data.substr(0, data.length() - n)));
631        auto is_flat = [](CordRep* rep) { return rep->tag >= FLAT; };
632        std::vector<CordRep*> edges = CordCollectRepsIf(is_flat, rep);
633        ASSERT_THAT(edges.size(), Le(flats.size()));
634        CordRep* last_edge = edges.back();
635        edges.pop_back();
636        const size_t last_length = rep->length - edges.size() * 512;
637        size_t index = 0;
638        for (CordRep* edge : edges) {
639          ASSERT_THAT(edge, Eq(flats[index++]));
640          ASSERT_THAT(edge->length, Eq(512u));
641        }
642        if (last_length >= 500) {
643          EXPECT_THAT(last_edge, Eq(flats[index++]));
644          if (shared()) {
645            EXPECT_THAT(last_edge->length, Eq(512u));
646          } else {
647            EXPECT_TRUE(last_edge->refcount.IsOne());
648            EXPECT_THAT(last_edge->length, Eq(last_length));
649          }
650        }
651      }
652    }
653  }
654  TEST(CordRepBtreeTest, SubTree) {
655    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
656    const size_t n = max_cap * max_cap * 2;
657    const std::string data = CreateRandomString(n * 3);
658    std::vector<CordRep*> flats;
659    for (absl::string_view s = data; !s.empty(); s.remove_prefix(3)) {
660      flats.push_back(MakeFlat(s.substr(0, 3)));
661    }
662    CordRepBtree* node = CordRepBtree::Create(CordRep::Ref(flats[0]));
663    for (size_t i = 1; i < flats.size(); ++i) {
664      node = CordRepBtree::Append(node, CordRep::Ref(flats[i]));
665    }
666    for (size_t offset = 0; offset < data.length(); ++offset) {
667      for (size_t length = 1; length <= data.length() - offset; ++length) {
668        CordRep* rep = node->SubTree(offset, length);
669        EXPECT_THAT(CordToString(rep), Eq(data.substr(offset, length)));
670        CordRep::Unref(rep);
671      }
672    }
673    CordRepBtree::Unref(node);
674    for (CordRep* rep : flats) {
675      CordRep::Unref(rep);
676    }
677  }
678  TEST(CordRepBtreeTest, SubTreeOnExistingSubstring) {
679    AutoUnref refs;
680    std::string data = CreateRandomString(1000);
681    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
682    CordRep* flat = MakeFlat(data);
683    leaf = CordRepBtree::Append(leaf, flat);
684    CordRep* result = leaf->SubTree(0, 3 + 990);
685    ASSERT_THAT(result->tag, Eq(BTREE));
686    CordRep::Unref(leaf);
687    leaf = result->btree();
688    ASSERT_THAT(leaf->Edges(), ElementsAre(_, IsSubstring(0u, 990u)));
689    EXPECT_THAT(leaf->Edges()[1]->substring()->child, Eq(flat));
690    result = leaf->SubTree(3 + 5, 970);
691    ASSERT_THAT(result, IsSubstring(5u, 970u));
692    EXPECT_THAT(result->substring()->child, Eq(flat));
693    CordRep::Unref(result);
694    CordRep::Unref(leaf);
695  }
696  TEST_P(CordRepBtreeTest, AddDataToLeaf) {
697    const size_t n = CordRepBtree::kMaxCapacity;
698    const std::string data = CreateRandomString(n * 3);
699    for (bool append : {true, false}) {
<span onclick='openModal()' class='match'>700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
</span>706        CordRepBtree* result = BtreeAdd(leaf, append, consumer.Next(3));
707        EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
708        EXPECT_THAT(CordToString(result), Eq(consumer.Consumed()));
709        leaf = result;
710      }
711      CordRep::Unref(leaf);
712    }
713  }
714  TEST_P(CordRepBtreeTest, AppendDataToTree) {
715    AutoUnref refs;
716    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
717    std::string data = CreateRandomString(n * 3);
718    CordRepBtree* tree = refs.RefIf(shared(), CreateTree(data, 3));
719    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
720    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
721    CordRepBtree* result = CordRepBtree::Append(tree, "123456789");
722    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
723    EXPECT_THAT(result->Edges(),
724                ElementsAre(leaf0, Conditional(shared(), Ne(leaf1), Eq(leaf1))));
725    EXPECT_THAT(CordToString(result), Eq(data + "123456789"));
726    CordRep::Unref(result);
727  }
728  TEST_P(CordRepBtreeTest, PrependDataToTree) {
729    AutoUnref refs;
730    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
731    std::string data = CreateRandomString(n * 3);
732    CordRepBtree* tree = refs.RefIf(shared(), CreateTreeReverse(data, 3));
733    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
734    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
735    CordRepBtree* result = CordRepBtree::Prepend(tree, "123456789");
736    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
737    EXPECT_THAT(result->Edges(),
738                ElementsAre(Conditional(shared(), Ne(leaf0), Eq(leaf0)), leaf1));
739    EXPECT_THAT(CordToString(result), Eq("123456789" + data));
740    CordRep::Unref(result);
741  }
742  TEST_P(CordRepBtreeTest, AddDataToTreeThreeLevelsDeep) {
743    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
744    const size_t n = max_cap * max_cap * max_cap;
745    const std::string data = CreateRandomString(n * 3);
746    for (bool append : {true, false}) {
747      AutoUnref refs;
748      DataConsumer consumer(data, append);
749      SCOPED_TRACE(append ? "Append" : "Prepend");
750      CordRepBtree* tree = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
751      for (size_t i = 1; i < max_cap; ++i) {
752        tree = BtreeAdd(tree, append, consumer.Next(3));
753      }
754      ASSERT_THAT(CordToString(tree), Eq(consumer.Consumed()));
755      refs.RefIf(shared(), tree);
756      CordRepBtree* result = BtreeAdd(tree, append, consumer.Next(3));
757      ASSERT_THAT(result, IsNode(1));
758      ASSERT_THAT(result, Ne(tree));
759      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
760      tree = result;
761      for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
762        refs.RefIf(shared(), tree);
763        result = BtreeAdd(tree, append, consumer.Next(3));
764        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
765        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
766        tree = result;
767      }
768      refs.RefIf(shared(), tree);
769      result = BtreeAdd(tree, append, consumer.Next(3));
770      ASSERT_THAT(result, IsNode(2));
771      ASSERT_THAT(result, Ne(tree));
772      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
773      tree = result;
774      for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap;
775           ++i) {
776        refs.RefIf(shared(), tree);
777        result = BtreeAdd(tree, append, consumer.Next(3));
778        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
779        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
780        tree = result;
781      }
782      CordRep::Unref(tree);
783    }
784  }
785  TEST_P(CordRepBtreeTest, AddLargeDataToLeaf) {
786    const size_t max_cap = CordRepBtree::kMaxCapacity;
787    const size_t n = max_cap * max_cap * max_cap * 3 + 2;
788    const std::string data = CreateRandomString(n * kMaxFlatLength);
789    for (bool append : {true, false}) {
790      AutoUnref refs;
791      SCOPED_TRACE(append ? "Append" : "Prepend");
792      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
793      refs.RefIf(shared(), leaf);
794      CordRepBtree* result = BtreeAdd(leaf, append, data);
795      EXPECT_THAT(CordToString(result), Eq(append ? "abc" + data : data + "abc"));
796      CordRep::Unref(result);
797    }
798  }
799  TEST_P(CordRepBtreeTest, CreateFromTreeReturnsTree) {
800    AutoUnref refs;
801    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
802    refs.RefIf(shared(), leaf);
803    CordRepBtree* result = CordRepBtree::Create(leaf);
804    EXPECT_THAT(result, Eq(leaf));
805    CordRep::Unref(result);
806  }
807  TEST(CordRepBtreeTest, GetCharacter) {
808    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
809    std::string data = CreateRandomString(n * 3);
810    CordRepBtree* tree = CreateTree(data, 3);
811    tree = tree->Append(tree, MakeSubstring(4, 5, MakeFlat("abcdefghijklm")));
812    data += "efghi";
813    for (size_t i = 0; i < data.length(); ++i) {
814      ASSERT_THAT(tree->GetCharacter(i), Eq(data[i]));
815    }
816    CordRep::Unref(tree);
817  }
818  TEST_P(CordRepBtreeTest, IsFlatSingleFlat) {
819    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
820    absl::string_view fragment;
821    EXPECT_TRUE(leaf->IsFlat(nullptr));
822    EXPECT_TRUE(leaf->IsFlat(&fragment));
823    EXPECT_THAT(fragment, Eq("Hello world"));
824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
833  }
834  TEST(CordRepBtreeTest, IsFlatMultiFlat) {
835    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
836    std::string data = CreateRandomString(n * 3);
837    CordRepBtree* tree = CreateTree(data, 3);
838    tree = tree->Append(tree, MakeSubstring(4, 3, MakeFlat("abcdefghijklm")));
839    tree = tree->Append(tree, MakeSubstring(8, 3, MakeFlat("abcdefghijklm")));
840    data += "efgijk";
841    EXPECT_FALSE(tree->IsFlat(nullptr));
842    absl::string_view fragment = "Can't touch this";
843    EXPECT_FALSE(tree->IsFlat(&fragment));
844    EXPECT_THAT(fragment, Eq("Can't touch this"));
845    for (size_t offset = 0; offset < data.size(); offset += 3) {
846      EXPECT_TRUE(tree->IsFlat(offset, 3, nullptr));
847      EXPECT_TRUE(tree->IsFlat(offset, 3, &fragment));
848      EXPECT_THAT(fragment, Eq(data.substr(offset, 3)));
849      fragment = "Can't touch this";
850      if (offset > 0) {
851        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, nullptr));
852        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, &fragment));
853        EXPECT_THAT(fragment, Eq("Can't touch this"));
854      }
855      if (offset < data.size() - 4) {
856        EXPECT_FALSE(tree->IsFlat(offset, 4, nullptr));
857        EXPECT_FALSE(tree->IsFlat(offset, 4, &fragment));
858        EXPECT_THAT(fragment, Eq("Can't touch this"));
859      }
860    }
861    CordRep::Unref(tree);
862  }
863  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
864  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotPrivate) {
865    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
866    CordRepBtree::Ref(tree);
867    EXPECT_DEATH(tree->GetAppendBuffer(1), ".*");
868    CordRepBtree::Unref(tree);
869    CordRepBtree::Unref(tree);
870  }
871  #endif  
872  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotFlat) {
873    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
874    for (int i = 1; i <= height(); ++i) {
875      tree = CordRepBtree::New(tree);
876    }
877    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
878    CordRepBtree::Unref(tree);
879  }
880  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNotPrivate) {
881    CordRepFlat* flat = MakeFlat("abc");
882    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
883    for (int i = 1; i <= height(); ++i) {
884      tree = CordRepBtree::New(tree);
885    }
886    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
887    CordRepBtree::Unref(tree);
888    CordRep::Unref(flat);
889  }
890  TEST_P(CordRepBtreeHeightTest, GetAppendBufferTreeNotPrivate) {
891    if (height() == 0) return;
892    AutoUnref refs;
893    CordRepFlat* flat = MakeFlat("abc");
894    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
895    for (int i = 1; i <= height(); ++i) {
896      if (i == (height() + 1) / 2) refs.Ref(tree);
897      tree = CordRepBtree::New(tree);
898    }
899    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
900    CordRepBtree::Unref(tree);
901    CordRep::Unref(flat);
902  }
903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
909    }
910    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
911    CordRepBtree::Unref(tree);
912  }
913  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatWithCapacity) {
914    CordRepFlat* flat = MakeFlat("abc");
915    CordRepBtree* tree = CordRepBtree::Create(flat);
916    for (int i = 1; i <= height(); ++i) {
917      tree = CordRepBtree::New(tree);
918    }
919    absl::Span<char> span = tree->GetAppendBuffer(2);
920    EXPECT_THAT(span, SizeIs(2u));
921    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 3));
922    EXPECT_THAT(tree->length, Eq(5u));
923    size_t avail = flat->Capacity() - 5;
924    span = tree->GetAppendBuffer(avail + 100);
925    EXPECT_THAT(span, SizeIs(avail));
926    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 5));
927    EXPECT_THAT(tree->length, Eq(5 + avail));
928    CordRepBtree::Unref(tree);
929  }
930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
944    while (tree->height() == 0) {
945      tree = CordRepBtree::Append(tree, CordRep::Ref(flat));
946      tree = CordRepBtree::Append(tree, CordRep::Ref(external));
947      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_flat));
948      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_external));
949    }
950    for (int api = 0; api <= 3; ++api) {
951      absl::string_view api_scope;
952      std::stringstream ss;
953      switch (api) {
954        case 0:
955          api_scope = "Bare";
956          CordRepBtree::Dump(tree, ss);
957          break;
958        case 1:
959          api_scope = "Label only";
960          CordRepBtree::Dump(tree, "Once upon a label", ss);
961          break;
962        case 2:
963          api_scope = "Label no content";
964          CordRepBtree::Dump(tree, "Once upon a label", false, ss);
965          break;
966        default:
967          api_scope = "Label and content";
968          CordRepBtree::Dump(tree, "Once upon a label", true, ss);
969          break;
970      }
971      SCOPED_TRACE(api_scope);
972      std::string str = ss.str();
973      EXPECT_THAT(str, AllOf(HasSubstr("Node(1)"), HasSubstr("Leaf"),
974                             HasSubstr("Private"), HasSubstr("Shared")));
975      EXPECT_THAT(str, AllOf(HasSubstr("len = 11"), HasSubstr("len = 14"),
976                             HasSubstr("len = 6"), HasSubstr("len = 7"),
977                             HasSubstr("start = 1"), HasSubstr("start = 2")));
978      EXPECT_THAT(
979          str, AllOf(HasSubstr(absl::StrCat("0x", absl::Hex(flat))),
980                     HasSubstr(absl::StrCat("0x", absl::Hex(external))),
981                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_flat))),
982                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_external)))));
983      if (api != 0) {
984        EXPECT_THAT(str, HasSubstr("Once upon a label"));
985      }
986      if (api != 3) {
987        EXPECT_THAT(str, Not(AnyOf((HasSubstr("data = \"Hello world\""),
988                                    HasSubstr("data = \"Hello external\""),
989                                    HasSubstr("data = \"ello w\""),
990                                    HasSubstr("data = \"llo ext\"")))));
991      } else {
992        EXPECT_THAT(str, AllOf((HasSubstr("data = \"Hello world\""),
993                                HasSubstr("data = \"Hello external\""),
994                                HasSubstr("data = \"ello w\""),
995                                HasSubstr("data = \"llo ext\""))));
996      }
997    }
998    CordRep::Unref(tree);
999  }
1000  TEST(CordRepBtreeTest, IsValid) {
1001    EXPECT_FALSE(CordRepBtree::IsValid(nullptr));
1002    CordRepBtree* empty = CordRepBtree::New(0);
1003    EXPECT_TRUE(CordRepBtree::IsValid(empty));
1004    CordRep::Unref(empty);
1005    for (bool as_tree : {false, true}) {
1006      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
1007      CordRepBtree* tree = as_tree ? CordRepBtree::New(leaf) : nullptr;
1008      CordRepBtree* check = as_tree ? tree : leaf;
1009      ASSERT_TRUE(CordRepBtree::IsValid(check));
1010      leaf->length--;
1011      EXPECT_FALSE(CordRepBtree::IsValid(check));
1012      leaf->length++;
1013      ASSERT_TRUE(CordRepBtree::IsValid(check));
1014      leaf->tag--;
1015      EXPECT_FALSE(CordRepBtree::IsValid(check));
1016      leaf->tag++;
1017      ASSERT_TRUE(CordRepBtree::IsValid(check));
1018      leaf->storage[0] = static_cast<uint8_t>(CordRepBtree::kMaxHeight + 1);
1019      EXPECT_FALSE(CordRepBtree::IsValid(check));
1020      leaf->storage[0] = 1;
1021      EXPECT_FALSE(CordRepBtree::IsValid(check));
1022      leaf->storage[0] = 0;
1023      ASSERT_TRUE(CordRepBtree::IsValid(check));
1024      const uint8_t begin = leaf->storage[1];
1025      leaf->storage[1] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity);
1026      EXPECT_FALSE(CordRepBtree::IsValid(check));
1027      leaf->storage[1] = 2;
1028      EXPECT_FALSE(CordRepBtree::IsValid(check));
1029      leaf->storage[1] = begin;
1030      ASSERT_TRUE(CordRepBtree::IsValid(check));
1031      const uint8_t end = leaf->storage[2];
1032      leaf->storage[2] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity + 1);
1033      EXPECT_FALSE(CordRepBtree::IsValid(check));
1034      leaf->storage[2] = end;
1035      ASSERT_TRUE(CordRepBtree::IsValid(check));
1036      CordRep* const edge = leaf->Edges()[0];
1037      const uint8_t tag = edge->tag;
1038      CordRepBtreeTestPeer::SetEdge(leaf, begin, nullptr);
1039      EXPECT_FALSE(CordRepBtree::IsValid(check));
1040      CordRepBtreeTestPeer::SetEdge(leaf, begin, edge);
1041      edge->tag = BTREE;
1042      EXPECT_FALSE(CordRepBtree::IsValid(check));
1043      edge->tag = tag;
1044      if (as_tree) {
1045        ASSERT_TRUE(CordRepBtree::IsValid(check));
1046        leaf->length--;
1047        EXPECT_FALSE(CordRepBtree::IsValid(check));
1048        leaf->length++;
1049        ASSERT_TRUE(CordRepBtree::IsValid(check));
1050        tree->storage[0] = static_cast<uint8_t>(2);
1051        EXPECT_FALSE(CordRepBtree::IsValid(check));
1052        tree->storage[0] = 1;
1053        ASSERT_TRUE(CordRepBtree::IsValid(check));
1054        CordRep* const edge = tree->Edges()[0];
1055        const uint8_t tag = edge->tag;
1056        edge->tag = FLAT;
1057        EXPECT_FALSE(CordRepBtree::IsValid(check));
1058        edge->tag = tag;
1059      }
1060      ASSERT_TRUE(CordRepBtree::IsValid(check));
1061      CordRep::Unref(check);
1062    }
1063  }
1064  TEST(CordRepBtreeTest, AssertValid) {
1065    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
1066    const CordRepBtree* ctree = tree;
1067    EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree));
1068    EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree));
1069  #if defined(GTEST_HAS_DEATH_TEST)
1070    CordRepBtree* nulltree = nullptr;
1071    const CordRepBtree* cnulltree = nullptr;
1072    EXPECT_DEBUG_DEATH(
1073        EXPECT_THAT(CordRepBtree::AssertValid(nulltree), Eq(nulltree)), ".*");
1074    EXPECT_DEBUG_DEATH(
1075        EXPECT_THAT(CordRepBtree::AssertValid(cnulltree), Eq(cnulltree)), ".*");
1076    tree->length--;
1077    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree)),
1078                       ".*");
1079    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree)),
1080                       ".*");
1081    tree->length++;
1082  #endif
1083    CordRep::Unref(tree);
1084  }
1085  TEST(CordRepBtreeTest, CheckAssertValidShallowVsDeep) {
1086    const bool exhaustive_validation = IsCordBtreeExhaustiveValidationEnabled();
1087    auto cleanup = absl::MakeCleanup([exhaustive_validation] {
1088      SetCordBtreeExhaustiveValidation(exhaustive_validation);
1089    });
1090    CordRep* flat = MakeFlat("abc");
1091    CordRepBtree* tree = CordRepBtree::Create(flat);
1092    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
1093    const size_t n = max_cap * max_cap * 2;
1094    for (size_t i = 0; i < n; ++i) {
1095      tree = CordRepBtree::Append(tree, MakeFlat("Hello world"));
1096    }
1097    flat->length = 100;
1098    SetCordBtreeExhaustiveValidation(false);
1099    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1100    EXPECT_TRUE(CordRepBtree::IsValid(tree, true));
1101    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1102    CordRepBtree::AssertValid(tree);
1103    CordRepBtree::AssertValid(tree, true);
1104  #if defined(GTEST_HAS_DEATH_TEST)
1105    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, false), ".*");
1106  #endif
1107    SetCordBtreeExhaustiveValidation(true);
1108    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1109    EXPECT_FALSE(CordRepBtree::IsValid(tree, true));
1110    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1111  #if defined(GTEST_HAS_DEATH_TEST)
1112    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree), ".*");
1113    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, true), ".*");
1114  #endif
1115    flat->length = 3;
1116    CordRep::Unref(tree);
1117  }
1118  TEST_P(CordRepBtreeTest, Rebuild) {
1119    for (size_t size : {3u, 8u, 100u, 10000u, 1000000u}) {
1120      SCOPED_TRACE(absl::StrCat("Rebuild @", size));
1121      std::vector<CordRepFlat*> flats;
1122      for (size_t i = 0; i < size; ++i) {
1123        flats.push_back(CordRepFlat::New(2));
1124        flats.back()->Data()[0] = 'x';
1125        flats.back()->length = 1;
1126      }
1127      size_t split_count = 0;
1128      size_t split_limit = 3;
1129      auto it = flats.begin();
1130      CordRepBtree* left = nullptr;
1131      CordRepBtree* right = CordRepBtree::New(*it);
1132      while (++it != flats.end()) {
1133        if (++split_count >= split_limit) {
1134          split_limit += split_limit / 16;
1135          left = left ? CordRepBtree::Append(left, right) : right;
1136          right = CordRepBtree::New(*it);
1137        } else {
1138          right = CordRepBtree::Append(right, *it);
1139        }
1140      }
1141      left = left ? CordRepBtree::Append(left, right) : right;
1142      AutoUnref ref;
1143      left = ref.Add(CordRepBtree::Rebuild(ref.RefIf(shared(), left)));
1144      ASSERT_TRUE(CordRepBtree::IsValid(left));
1145      bool ok = true;
1146      it = flats.begin();
1147      CordVisitReps(left, [&](CordRep* edge) {
1148        if (edge->tag < FLAT) return;
1149        ok = ok && (it != flats.end() && *it++ == edge);
1150      });
1151      EXPECT_TRUE(ok && it == flats.end()) << "Rebuild edges mismatch";
1152    }
1153  }
1154  CordRepBtree::ExtractResult ExtractLast(CordRepBtree* input, size_t cap = 1) {
1155    return CordRepBtree::ExtractAppendBuffer(input, cap);
1156  }
1157  TEST(CordRepBtreeTest, ExtractAppendBufferLeafSingleFlat) {
1158    CordRep* flat = MakeFlat("Abc");
1159    CordRepBtree* leaf = CordRepBtree::Create(flat);
1160    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(nullptr, flat));
1161    CordRep::Unref(flat);
1162  }
1163  TEST(CordRepBtreeTest, ExtractAppendBufferNodeSingleFlat) {
1164    CordRep* flat = MakeFlat("Abc");
1165    CordRepBtree* leaf = CordRepBtree::Create(flat);
1166    CordRepBtree* node = CordRepBtree::New(leaf);
1167    EXPECT_THAT(ExtractLast(node), EqExtractResult(nullptr, flat));
1168    CordRep::Unref(flat);
1169  }
1170  TEST(CordRepBtreeTest, ExtractAppendBufferLeafTwoFlats) {
1171    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1172    CordRepBtree* leaf = CreateTree(flats);
1173    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(flats[0], flats[1]));
1174    CordRep::Unref(flats[0]);
1175    CordRep::Unref(flats[1]);
1176  }
1177  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlats) {
1178    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1179    CordRepBtree* leaf = CreateTree(flats);
1180    CordRepBtree* node = CordRepBtree::New(leaf);
1181    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1182    CordRep::Unref(flats[0]);
1183    CordRep::Unref(flats[1]);
1184  }
1185  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlatsInTwoLeafs) {
1186    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1187    CordRepBtree* leaf1 = CordRepBtree::Create(flats[0]);
1188    CordRepBtree* leaf2 = CordRepBtree::Create(flats[1]);
1189    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1190    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1191    CordRep::Unref(flats[0]);
1192    CordRep::Unref(flats[1]);
1193  }
1194  TEST(CordRepBtreeTest, ExtractAppendBufferLeafThreeFlats) {
1195    std::vector<CordRep*> flats = CreateFlatsFromString("abcdefghi", 3);
1196    CordRepBtree* leaf = CreateTree(flats);
1197    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, flats[2]));
1198    CordRep::Unref(flats[2]);
1199    CordRep::Unref(leaf);
1200  }
1201  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightNoFolding) {
1202    CordRep* flat = MakeFlat("Abc");
1203    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1204    CordRepBtree* leaf1 = CordRepBtree::Create(flat);
1205    CordRepBtree* leaf2 = CreateTree(flats);
1206    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1207    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, flats[1]));
1208    EXPECT_THAT(node->Edges(), ElementsAre(leaf1, leaf2));
1209    EXPECT_THAT(leaf1->Edges(), ElementsAre(flat));
1210    EXPECT_THAT(leaf2->Edges(), ElementsAre(flats[0]));
1211    CordRep::Unref(node);
1212    CordRep::Unref(flats[1]);
1213  }
1214  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightLeafFolding) {
1215    CordRep* flat = MakeFlat("Abc");
1216    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1217    CordRepBtree* leaf1 = CreateTree(flats);
1218    CordRepBtree* leaf2 = CordRepBtree::Create(flat);
1219    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1220    EXPECT_THAT(ExtractLast(node), EqExtractResult(leaf1, flat));
1221    EXPECT_THAT(leaf1->Edges(), ElementsAreArray(flats));
1222    CordRep::Unref(leaf1);
1223    CordRep::Unref(flat);
1224  }
1225  TEST(CordRepBtreeTest, ExtractAppendBufferNoCapacity) {
1226    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1227    CordRepBtree* leaf = CreateTree(flats);
1228    size_t avail = flats[1]->flat()->Capacity() - flats[1]->length;
1229    EXPECT_THAT(ExtractLast(leaf, avail + 1), EqExtractResult(leaf, nullptr));
1230    EXPECT_THAT(ExtractLast(leaf, avail), EqExtractResult(flats[0], flats[1]));
1231    CordRep::Unref(flats[0]);
1232    CordRep::Unref(flats[1]);
1233  }
1234  TEST(CordRepBtreeTest, ExtractAppendBufferNotFlat) {
1235    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1236    auto substr = MakeSubstring(1, 2, flats[1]);
1237    CordRepBtree* leaf = CreateTree({flats[0], substr});
1238    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1239    CordRep::Unref(leaf);
1240  }
1241  TEST(CordRepBtreeTest, ExtractAppendBufferShared) {
1242    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1243    CordRepBtree* leaf = CreateTree(flats);
1244    CordRep::Ref(flats[1]);
1245    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1246    CordRep::Unref(flats[1]);
1247    CordRep::Ref(leaf);
1248    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1249    CordRep::Unref(leaf);
1250    CordRepBtree* node = CordRepBtree::New(leaf);
1251    CordRep::Ref(node);
1252    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, nullptr));
1253    CordRep::Unref(node);
1254    CordRep::Unref(node);
1255  }
1256  }  
1257  }  
1258  ABSL_NAMESPACE_END
1259  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
</pre></code></div>
                <div class="column column_space"><pre><code>700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    