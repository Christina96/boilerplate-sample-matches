
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6049382716049383%, Tokens: 13</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</h3>
            <pre><code>1  const int TRnd::RndSeed=0;
2  const int TRnd::a=16807;
3  const int TRnd::m=2147483647;
4  const int TRnd::q=127773; 
5  const int TRnd::r=2836; 
6  void TRnd::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
7    XLoadHd(Nm);
8    Seed=TXmlObjSer::GetIntArg(XmlTok, "Seed");
9  }
10  void TRnd::SaveXml(TSOut& SOut, const TStr& Nm) const {
11    XSaveBETagArg(Nm, "Seed", TInt::GetStr(Seed));
12  }
13  void TRnd::PutSeed(const int& _Seed){
14    Assert(_Seed>=0);
15    if (_Seed==0){
16      Seed=abs(int(TSysTm::GetPerfTimerTicks()));
17    } else {
18      Seed=_Seed;
19    }
20  }
21  void TRnd::Move(const int& Steps){
22    for (int StepN=0; StepN<Steps; StepN++){GetNextSeed();}
23  }
24  bool TRnd::Check(){
25    int PSeed=Seed; Seed=1;
26    for (int SeedN=0; SeedN<10000; SeedN++){GetNextSeed();}
27    bool Ok=Seed==1043618065; Seed=PSeed; return Ok;
28  }
29  int TRnd::GetUniDevInt(const int& Range){
30    int Seed=GetNextSeed();
31    if (Range==0){return Seed;}
32    else {return Seed%Range;}
33  }
34  uint TRnd::GetUniDevUInt(const uint& Range){
35    uint Seed=uint(GetNextSeed()%0x10000)*0x10000+uint(GetNextSeed()%0x10000);
36    if (Range==0){return Seed;}
37    else {return Seed%Range;}
38  }
39  int64 TRnd::GetUniDevInt64(const int64& Range){
40    const int64 RndVal = int64((uint64(GetUniDevInt())<<32) | uint64(GetUniDevInt()));
41    if (Range==0){return RndVal;}
42    else {return RndVal%Range;}
43  }
44  uint64 TRnd::GetUniDevUInt64(const uint64& Range){
45   const uint64 RndVal = uint64((uint64(GetUniDevInt())<<32) | uint64(GetUniDevInt()));
46   if (Range==0){return RndVal;}
47   else {return RndVal%Range;}
48  }
49  double TRnd::GetNrmDev(){
50    double v1, v2, rsq;
51    do {
52      v1=2.0*GetUniDev()-1.0; 
53      v2=2.0*GetUniDev()-1.0; 
54      rsq=v1*v1+v2*v2; 
55    } while ((rsq>=1.0)||(rsq==0.0)); 
56    double fac=sqrt(-2.0*log(rsq)/rsq); 
57    return v1*fac;
58  }
59  double TRnd::GetNrmDev(
60   const double& Mean, const double& SDev, const double& Mn, const double& Mx){
61    double Val=Mean+GetNrmDev()*SDev;
62    if (Val<Mn){Val=Mn;}
63    if (Val>Mx){Val=Mx;}
64    return Val;
65  }
66  double TRnd::GetExpDev(){
67    double UniDev;
68    do {
69      UniDev=GetUniDev();
70    } while (UniDev==0.0);
71    return -log(UniDev);
72  }
73  double TRnd::GetExpDev(const double& Lambda) {
74    return GetExpDev()/Lambda;
75  }
76  double TRnd::GetGammaDev(const int& Order){
77    int j;
78    double am,e,s,v1,v2,x,y;
79    if (Order<1){Fail;}
80    if (Order<6) {
81      x=1.0;
82      for (j=1;j<=Order;j++) x *=GetUniDev();
83      x = -log(x);
84    } else {
85      do {
86        do {
87          do {
88            v1=2.0*GetUniDev()-1.0;
89            v2=2.0*GetUniDev()-1.0;
90          } while (v1*v1+v2*v2 > 1.0);
91          y=v2/v1;
92          am=Order-1;
93          s=sqrt(2.0*am+1.0);
94          x=s*y+am;
95        } while (x <= 0.0);
96        e=(1.0+y*y)*exp(am*log(x/am)-s*y);
97      } while (GetUniDev()>e);
98    }
99    return x;
100  }
101  double TRnd::GetPoissonDev(const double& Mean){
102    static double sq,alxm,g,oldm=(-1.0);
103    double em,t,y;
104    if (Mean < 12.0) {
105      if (Mean != oldm) {
106        oldm=Mean;
107        g=exp(-Mean);
108      }
109      em = -1;
110      t=1.0;
111      do {
112        ++em;
113        t *= GetUniDev();
114      } while (t>g);
115    } else {
116      if (Mean != oldm) {
117        oldm=Mean;
118        sq=sqrt(2.0*Mean);
119        alxm=log(Mean);
120        g=Mean*alxm-TSpecFunc::LnGamma(Mean+1.0);
121      }
122      do {
123        do {
124          y=tan(TMath::Pi*GetUniDev());
125          em=sq*y+Mean;
126        } while (em < 0.0);
127        em=floor(em);
128        t=0.9*(1.0+y*y)*exp(em*alxm-TSpecFunc::LnGamma(em+1.0)-g);
129      } while (GetUniDev()>t);
130    }
131    return em;
132  }
133  double TRnd::GetBinomialDev(const double& Prb, const int& Trials){
134    int j;
135    static int nold=(-1);
136    double am,em,g,angle,p,bnl,sq,t,y;
137    static double pold=(-1.0),pc,plog,pclog,en,oldg;
138    p=(Prb <= 0.5 ? Prb : 1.0-Prb);
139    am=Trials*p;
140    if (Trials < 25) {
141      bnl=0.0;
142      for (j=1;j<=Trials;j++)
143        if (GetUniDev() < p) ++bnl;
144    } else if (am < 1.0) {
145      g=exp(-am);
146      t=1.0;
147      for (j=0;j<=Trials;j++) {
148        t *= GetUniDev();
149        if (t < g) break;
150      }
151      bnl=(j <= Trials ? j : Trials);
152    } else {
153      if (Trials != nold) {
154        en=Trials;
155        oldg=TSpecFunc::LnGamma(en+1.0);
156        nold=Trials;
157      } if (p != pold) {
158        pc=1.0-p;
159        plog=log(p);
160        pclog=log(pc);
161        pold=p;
162      }
163      sq=sqrt(2.0*am*pc);
164      do {
165        do {
166          angle=TMath::Pi*GetUniDev();
167          y=tan(angle);
168          em=sq*y+am;
169        } while (em < 0.0 || em >= (en+1.0));
170        em=floor(em);
171        t=1.2*sq*(1.0+y*y)*exp(oldg-(em+1.0)
172          -TSpecFunc::LnGamma(en-em+1.0)+em*plog+(en-em)*pclog);
173      } while (GetUniDev() > t);
174      bnl=em;
175    }
176    if (p != Prb) bnl=Trials-bnl;
177    return bnl;
178  }
179  TRnd TRnd::LoadTxt(TILx& Lx){
180    return TRnd(Lx.GetInt());
181  }
182  void TRnd::SaveTxt(TOLx& Lx) const {
183    Lx.PutInt(Seed);
184  }
185  void TMem::Resize(const int& _MxBfL){
186    if (_MxBfL<=MxBfL){return;}
187    else {if (MxBfL*2<_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
188    char* NewBf=new char[MxBfL]; IAssert(NewBf!=NULL);
189    if (BfL>0){memcpy(NewBf, Bf, BfL);}
190    if (Bf!=NULL){delete[] Bf;}
191    Bf=NewBf;
192  }
193  TMem::TMem(const TStr& Str):
194    MxBfL(Str.Len()), BfL(MxBfL), Bf(NULL){
195    if (MxBfL>0){
196      Bf=new char[MxBfL];
197      if (BfL>0){memcpy(Bf, Str.CStr(), BfL);}
198    }
199  }
200  void TMem::SaveXml(TSOut& SOut, const TStr& Nm) const {
201    XSaveHdArg(Nm, "BfL", TInt::GetStr(BfL));
202    SOut.PutStr(TXmlLx::GetXmlStrFromPlainMem(*this));
203  }
204  bool TMem::DoFitStr(const TStr& Str) const {
205    return DoFitLen(Str.Len()+1);
206  }
207  TMem& TMem::operator+=(const char& Ch){
208    if (BfL==MxBfL){Resize(BfL+1);}
209    Bf[BfL]=Ch; BfL++; return *this;
210  }
211  TMem& TMem::operator+=(const TMem& Mem){
212    int LBfL=Mem.Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
213    if (LBfL>0){memcpy(&Bf[BfL], Mem(), LBfL);}
214    BfL+=LBfL; return *this;
215  }
216  TMem& TMem::operator+=(const TStr& Str){
217    int LBfL=Str.Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
218    if (LBfL>0){memcpy(Bf+BfL, Str.CStr(), LBfL);}
219    BfL+=LBfL; return *this;
220  }
221  TMem& TMem::operator+=(const PSIn& SIn){
222    int LBfL=SIn->Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
223    char* LBf=new char[LBfL];
224    SIn->GetBf(LBf, LBfL);
225    if (LBfL>0){memcpy(Bf+BfL, LBf, LBfL);}
226    delete[] LBf;
227    BfL+=LBfL; return *this;
228  }
229  void TMem::Del(const int& BChN, const int& EChN){
230    if (BChN>EChN){return;}
231    if ((BChN==0)&&(EChN==BfL-1)){Clr(); return;}
232    IAssert((0<=BChN)&&(BChN<=EChN)&&(EChN<BfL));
233    memmove(Bf+BChN, Bf+EChN+1, BfL-EChN-1);
234    BfL-=(EChN-BChN+1);
235  }
236  void TMem::AddBf(const void* _Bf, const int& _BfL){
237  	IAssert((_BfL>=0) && (_Bf != NULL));
238    Reserve(Len() + _BfL, false);
239    memcpy(Bf + BfL, _Bf, _BfL);  
240     BfL+=_BfL;
241  }
242  TStr TMem::GetAsStr(const char& NewNullCh) const {
243    if (NewNullCh!='\0'){
244      TChA ChA(*this);
245      ChA.ChangeCh('\0', NewNullCh);
246      return ChA;
247    } else {
248      return TStr(*this);
249    }
250  }
251  TMemIn::TMemIn(const TMem& _Mem, const int& _BfC):
252    TSBase("Input-Memory"), TSIn("Input-Memory"), Mem(), Bf(_Mem()), BfC(_BfC), BfL(_Mem.Len()){}
253  int TMemIn::GetBf(const void* LBf, const TSize& LBfL){
254    Assert(TSize(BfC+LBfL)<=TSize(BfL));
255    int LBfS=0;
256    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
257      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
258    return LBfS;
259  }
260  bool TMemIn::GetNextLnBf(TChA& LnChA){
261    FailR(TStr::Fmt("TMemIn::GetNextLnBf: not implemented").CStr());
262    return false;
263  }
264  TMemOut::TMemOut(const PMem& _Mem): TSBase("Output-Memory"), TSOut("Output-Memory"), Mem(_Mem){}
265  int TMemOut::PutBf(const void* LBf, const TSize& LBfL){
266    int LBfS=0;
267    TMem& _Mem=*Mem;
268    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
269      char Ch=((char*)LBf)[LBfC];
270      LBfS+=Ch; _Mem+=Ch;
271    }
272    return LBfS;
273  }
274  void TChA::Resize(const int& _MxBfL){
275    if (_MxBfL<=MxBfL){return;}
276    else {if (MxBfL*2<_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
277    char* NewBf=new char[MxBfL+1]; IAssert(NewBf!=NULL);
278    strcpy(NewBf, Bf);
279    delete[] Bf; Bf=NewBf;
280  }
281  TChA::TChA(const TStr& Str){
282    Bf=new char[(MxBfL=BfL=Str.Len())+1];
283    strcpy(Bf, Str.CStr());
284  }
285  void TChA::SaveXml(TSOut& SOut, const TStr& Nm) const {
286    XSaveHdArg(Nm, "BfL", TInt::GetStr(BfL));
287    SOut.PutStr(TXmlLx::GetXmlStrFromPlainStr(*this));
288  }
289  TChA& TChA::operator=(const TChA& ChA){
290    if (this!=&ChA){
291      if (ChA.BfL>MxBfL){delete[] Bf; Bf=new char[(MxBfL=ChA.BfL)+1];}
292      BfL=ChA.BfL; strcpy(Bf, ChA.CStr());
293    }
294    return *this;
295  }
296  TChA& TChA::operator=(const TStr& Str){
297    if (Str.Len()>MxBfL){delete[] Bf; Bf=new char[(MxBfL=Str.Len())+1];}
298    BfL=Str.Len(); strcpy(Bf, Str.CStr());
299    return *this;
300  }
301  TChA& TChA::operator=(const char* CStr){
302    int CStrLen=int(strlen(CStr));
303    if (CStrLen>MxBfL){delete[] Bf; Bf=new char[(MxBfL=CStrLen)+1];}
304    BfL=CStrLen; strcpy(Bf, CStr);
305    return *this;
306  }
307  TChA& TChA::operator+=(const TMem& Mem) {
308    Resize(BfL+Mem.Len());
309    strcpy(Bf+BfL, Mem.GetBf()); BfL+=Mem.Len(); return *this;
310  }
311  TChA& TChA::operator+=(const TChA& ChA){
312    Resize(BfL+ChA.Len());
313    strcpy(Bf+BfL, ChA.CStr()); BfL+=ChA.Len(); return *this;
314  }
315  TChA& TChA::operator+=(const TStr& Str){
316    Resize(BfL+Str.Len());
317    strcpy(Bf+BfL, Str.CStr()); BfL+=Str.Len(); return *this;
318  }
319  TChA& TChA::operator+=(const char* CStr){
320    int CStrLen=(int)strlen(CStr); Resize(BfL+CStrLen);
321    strcpy(Bf+BfL, CStr); BfL+=CStrLen; return *this;
322  }
323  void TChA::Ins(const int& BChN, const char* CStr){
324    Assert((0<=BChN)&&(BChN<=BfL)); /&bsol;** ali je <= v (BChN<=BfL) upravicen?
325    int CStrLen=int(strlen(CStr)); Resize(BfL+CStrLen);
326    memmove(Bf+BChN+CStrLen, Bf+BChN, BfL-BChN+1);
327    memmove(Bf+BChN, CStr, CStrLen); BfL+=CStrLen;
328  }
329  void TChA::Del(const int& ChN){
330    Assert((0<=ChN)&&(ChN<BfL));
331    memmove(Bf+ChN, Bf+ChN+1, BfL-ChN);
332    BfL--;
333  }
334  void TChA::Trunc(){
335    int BChN=0; while ((BChN<BfL)&&(GetCh(BChN)<=' ')){BChN++;}
336    int EChN=BfL-1; while ((0<=EChN)&&(GetCh(EChN)<=' ')){EChN--;}
337    if (BChN<=EChN){
338      for (int ChN=BChN; ChN<=EChN; ChN++){
339        PutCh(ChN-BChN, GetCh(ChN));}
340      Trunc(EChN-BChN+1);
341    } else {
342      Clr();
343    }
344  }
345  void TChA::Reverse(){
346    for (int ChN=0; ChN<BfL/2; ChN++){
347      char Ch=Bf[ChN];
348      Bf[ChN]=Bf[BfL-ChN-1];
349      Bf[BfL-ChN-1]=Ch;
350    }
351  }
352  TChA TChA::GetSubStr(const int& _BChN, const int& _EChN) const {
353    int BChN=TInt::GetMx(_BChN, 0);
354    int EChN=TInt::GetMn(_EChN, Len()-1);
355    int Chs=EChN-BChN+1;
356    if (Chs<=0){return TStr::GetNullStr();}
357    else if (Chs==Len()){return *this;}
358    else {
359      return TChA(CStr()+BChN, Chs);
360    }
361  }
362  int TChA::CountCh(const char& Ch, const int& BChN) const {
363    int ChN=TInt::GetMx(BChN, 0);
364    const int ThisLen=Len();
365    int Cnt = 0;
366    while (ChN<ThisLen){if (Bf[ChN]==Ch){ Cnt++;} ChN++;}
367    return Cnt;
368  }
369  int TChA::SearchCh(const char& Ch, const int& BChN) const {
370    int ChN=TInt::GetMx(BChN, 0);
371    const int ThisLen=Len();
372    while (ChN<ThisLen){if (Bf[ChN]==Ch){return ChN;} ChN++;}
373    return -1;
374  }
375  int TChA::SearchChBack(const char& Ch, int BChN) const {
376    if (BChN >= Len() || BChN < 0) { BChN = Len()-1; }
377    for (int i = BChN; i >= 0; i--) {
378      if (GetCh(i) == Ch) { return i; }
379    }
380    return -1;
381  }
382  int TChA::SearchStr(const TChA& Str, const int& BChN) const {
383    return SearchStr(Str.CStr(), BChN);
384  }
385  int TChA::SearchStr(const TStr& Str, const int& BChN) const {
386    return SearchStr(Str.CStr(), BChN);
387  }
388  int TChA::SearchStr(const char* CStr, const int& BChN) const {
389    const char* BegPos=strstr(Bf+BChN, CStr);
390    if (BegPos==NULL){return -1;}
391    else {return int(BegPos-Bf);}
392  }
393  bool TChA::IsPrefix(const char* CStr, const int& BChN) const {
394    if (BChN+(int)strlen(CStr)>Len()){return false;}
395    const char* B = Bf+BChN;
396    const char* C = CStr;
397    while (*C!=0 && *B==*C) {
398      B++; C++;
399    }
400    if (*C==0){return true;}
401    else {return false;}
402  }
403  bool TChA::IsPrefix(const TStr& Str) const {
404    return IsPrefix(Str.CStr());
405  }
406  bool TChA::IsPrefix(const TChA& Str) const {
407    return IsPrefix(Str.CStr());
408  }
409  bool TChA::IsSuffix(const char* CStr) const {
410    if ((int)strlen(CStr) > Len()) { return false; }
411    const char* E = Bf+Len()-1;
412    const char* C = CStr+strlen(CStr)-1;
413    while (C >= CStr && *E==*C) {
414      E--;  C--;
415    }
416    if (C+1 == CStr) { return true; }
417    else { return false; }
418  }
419  bool TChA::IsSuffix(const TStr& Str) const {
420    return IsSuffix(Str.CStr());
421  }
422  bool TChA::IsSuffix(const TChA& Str) const {
423    return IsSuffix(Str.CStr());
424  }
425  void TChA::ChangeCh(const char& SrcCh, const char& DstCh){
426    int StrLen=Len();
427    for (int ChN=0; ChN<StrLen; ChN++){if (Bf[ChN]==SrcCh){Bf[ChN]=DstCh;}}
428  }
429  TChA& TChA::ToLc() {
430    char *c = Bf;
431    while (*c) {
432      *c = (char) tolower(*c);  c++;
433    }
434    return *this;
435  }
436  TChA& TChA::ToUc() {
437    char *c = Bf;
438    while (*c) {
439      *c = (char) toupper(*c); c++;
440    }
441    return *this;
442  }
443  TChA& TChA::ToTrunc(){
444    int StrLen=Len(); int BChN=0; int EChN=StrLen-1;
445    while ((BChN<StrLen)&&TCh::IsWs(GetCh(BChN))){BChN++;}
446    while ((EChN>=0)&&TCh::IsWs(GetCh(EChN))){EChN--;}
447    if ((BChN!=0)||(EChN!=StrLen-1)){
448      int DstChN=0;
449      for (int SrcChN=BChN; SrcChN<=EChN; SrcChN++){
450        PutCh(DstChN, GetCh(SrcChN)); DstChN++;}
451      Trunc(DstChN);
452    }
453    return *this;
454  }
455  void TChA::CompressWs(){
456    int StrLen=Len(); int SrcChN=0; int DstChN=0;
457    while ((SrcChN<StrLen)&&TCh::IsWs(GetCh(SrcChN))){SrcChN++;}
458    while (SrcChN<StrLen){
459      if ((TCh::IsWs(GetCh(SrcChN)))&&(DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){
460        SrcChN++;
461      } else {
462        PutCh(DstChN, GetCh(SrcChN)); SrcChN++; DstChN++;
463      }
464    }
465    if ((DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){DstChN--;}
466    Trunc(DstChN);
467  }
468  void TChA::Swap(const int& ChN1, const int& ChN2){
469    char Ch=GetCh(ChN1);
470    PutCh(ChN1, GetCh(ChN2));
471    PutCh(ChN2, Ch);
472  }
473  void TChA::Swap(TChA& ChA) {
474    ::Swap(MxBfL, ChA.MxBfL);
475    ::Swap(BfL, ChA.BfL);
476    ::Swap(Bf, ChA.Bf);
477  }
478  int TChA::GetPrimHashCd() const {
479    return TStrHashF_DJB::GetPrimHashCd(CStr());
480  }
481  int TChA::GetSecHashCd() const {
482    return TStrHashF_DJB::GetSecHashCd(CStr());
483  }
484  void TChA::LoadTxt(const PSIn& SIn, TChA& ChA){
485    delete[] ChA.Bf;
486    ChA.Bf=new char[(ChA.MxBfL=ChA.BfL=SIn->Len())+1];
487    SIn->GetBf(ChA.CStr(), SIn->Len()); ChA.Bf[ChA.BfL]=0;
488  }
489  void TChA::SaveTxt(const PSOut& SOut) const {
490    SOut->SaveBf(CStr(), Len());
491  }
492  TChAIn::TChAIn(const TChA& ChA, const int& _BfC):
493    TSBase("Input-Char-Array"), TSIn("Input-Char-Array"), Bf(ChA.CStr()), BfC(_BfC), BfL(ChA.Len()){}
494  int TChAIn::GetBf(const void* LBf, const TSize& LBfL){
495    Assert(TSize(BfC+LBfL)<=TSize(BfL));
496    int LBfS=0;
497    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
498      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
499    return LBfS;
500  }
501  bool TChAIn::GetNextLnBf(TChA& LnChA){
502    FailR(TStr::Fmt("TChAIn::GetNextLnBf: not implemented").CStr());
503    return false;
504  }
505  bool TRStr::IsUc() const {
506    int StrLen=Len();
507    for (int ChN=0; ChN<StrLen; ChN++){
508      if (('a'<=Bf[ChN])&&(Bf[ChN]<='z')){return false;}}
509    return true;
510  }
511  void TRStr::ToUc(){
512    int StrLen=Len();
513    for (int ChN=0; ChN<StrLen; ChN++){
514      Bf[ChN]=(char)toupper(Bf[ChN]);}}
515  bool TRStr::IsLc() const {
516    int StrLen=Len();
517    for (int ChN=0; ChN<StrLen; ChN++){
518      if (('A'<=Bf[ChN])&&(Bf[ChN]<='Z')){return false;}}
519    return true;
520  }
521  void TRStr::ToLc(){
522    int StrLen=Len();
523    for (int ChN=0; ChN<StrLen; ChN++){
524      Bf[ChN]=(char)tolower(Bf[ChN]);}
525  }
526  void TRStr::ToCap(){
527    int StrLen=Len();
528    if (StrLen>0){
529      Bf[0]=(char)toupper(Bf[0]);}
530    for (int ChN=1; ChN<StrLen; ChN++){
531      Bf[ChN]=(char)tolower(Bf[ChN]);}
532  }
533  void TRStr::ConvUsFromYuAscii(){
534    int StrLen=Len();
535    for (int ChN=0; ChN<StrLen; ChN++){
536      Bf[ChN]=TCh::GetUsFromYuAscii(Bf[ChN]);}
537  }
538  int TRStr::CmpI(const char* p, const char* r){
539    if (!p){return r ? (*r ? -1 : 0) : 0;}
540    if (!r){return (*p ? 1 : 0);}
541    while (*p && *r){
542      int i=int(toupper(*p++))-int(toupper(*r++));
543      if (i!=0){return i;}
544    }
545    return int(toupper(*p++))-int(toupper(*r++));
546  }
547  int TRStr::GetPrimHashCd() const {
548    return TStrHashF_DJB::GetPrimHashCd(Bf);
549  }
550  int TRStr::GetSecHashCd() const {
551    return TStrHashF_DJB::GetSecHashCd(Bf);
552  }
553  TRStr* TStr::GetRStr(const char* CStr){
554    int CStrLen;
555    if (CStr==NULL){CStrLen=0;} else {CStrLen=int(strlen(CStr));}
556    if (CStrLen==0){return TRStr::GetNullRStr();}
557    else {return new TRStr(CStr);}
558  }
559  void TStr::Optimize(){
560    char* CStr=RStr->CStr(); int CStrLen=int(strlen(CStr));
561    TRStr* NewRStr;
562    if (CStrLen==0){NewRStr=TRStr::GetNullRStr();}
563    else {NewRStr=RStr;}
564    NewRStr->MkRef(); RStr->UnRef(); RStr=NewRStr;
565  }
566  void TStr::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
567    XLoadHd(Nm);
568    TStr TokStr=XmlTok->GetTokStr(false);
569    operator=(TokStr);
570  }
571  void TStr::SaveXml(TSOut& SOut, const TStr& Nm) const {
572    TStr XmlStr=TXmlLx::GetXmlStrFromPlainStr(*this);
573    if (XmlStr.Empty()){XSaveBETag(Nm);}
574    else {XSaveHd(Nm); SOut.PutStr(XmlStr);}
575  }
576  TStr& TStr::ToUc(){
577    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToUc();
578    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
579    Optimize(); return *this;
580  }
581  TStr& TStr::ToLc(){
582    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToLc();
583    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
584    Optimize(); return *this;
585  }
586  TStr& TStr::ToCap(){
587    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToCap();
588    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
589    Optimize(); return *this;
590  }
591  TStr& TStr::ToTrunc(){
592    int ThisLen=Len(); char* ThisBf=CStr();
593    int BChN=0; int EChN=ThisLen-1;
594    while ((BChN<ThisLen)&&TCh::IsWs(ThisBf[BChN])){BChN++;}
595    while ((EChN>=0)&&TCh::IsWs(ThisBf[EChN])){EChN--;}
596    *this=GetSubStr(BChN, EChN);
597    return *this;
598  }
599  TStr& TStr::ConvUsFromYuAscii(){
600    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ConvUsFromYuAscii();
601    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
602    Optimize(); return *this;
603  }
604  TStr& TStr::ToHex(){
605    TChA ChA;
606    int StrLen=Len();
607    for (int ChN=0; ChN<StrLen; ChN++){
608      uchar Ch=uchar(RStr->Bf[ChN]);
609      char MshCh=TCh::GetHexCh((Ch/16)%16);
610      char LshCh=TCh::GetHexCh(Ch%16);
611      ChA+=MshCh; ChA+=LshCh;
612    }
613    *this=ChA;
614    return *this;
615  }
616  TStr& TStr::FromHex(){
617    int StrLen=Len(); IAssert(StrLen%2==0);
618    TChA ChA; int ChN=0;
619    while (ChN<StrLen){
620      char MshCh=RStr->Bf[ChN]; ChN++;
621      char LshCh=RStr->Bf[ChN]; ChN++;
622      uchar Ch=uchar(TCh::GetHex(MshCh)*16+TCh::GetHex(LshCh));
623      ChA+=Ch;
624    }
625    *this=ChA;
626    return *this;
627  }
628  TStr TStr::GetSubStr(const int& _BChN, const int& _EChN) const {
629    int StrLen=Len();
630    int BChN=TInt::GetMx(_BChN, 0);
631    int EChN=TInt::GetMn(_EChN, StrLen-1);
632    int Chs=EChN-BChN+1;
633    if (Chs<=0){return TStr();}
634    else if (Chs==StrLen){return *this;}
635    else {
636      char* Bf=new char[Chs+1]; strncpy(Bf, CStr()+BChN, Chs); Bf[Chs]=0;
637      TStr Str(Bf); delete[] Bf;
638      return Str;
639    }
640  }
641  void TStr::InsStr(const int& BChN, const TStr& Str){
642    int ThisLen=Len();
643    IAssert((0<=BChN)&&(BChN<=ThisLen));
644    TStr NewStr;
645    if (BChN==0){
646      NewStr=Str+*this;
647    } else
648    if (BChN==ThisLen){
649      NewStr=*this+Str;
650    } else {
651      NewStr=GetSubStr(0, BChN-1)+Str+GetSubStr(BChN, ThisLen-1);
652    }
653    *this=NewStr;
654  }
655  void TStr::DelChAll(const char& Ch){
656    TChA ChA(*this);
657    int ChN=ChA.SearchCh(Ch);
658    while (ChN!=-1){
659      ChA.Del(ChN);
660      ChN=ChA.SearchCh(Ch);
661    }
662    *this=ChA;
663  }
664  void TStr::DelSubStr(const int& _BChN, const int& _EChN){
665    int BChN=TInt::GetMx(_BChN, 0);
666    int EChN=TInt::GetMn(_EChN, Len()-1);
667    int Chs=Len()-(EChN-BChN+1);
668    if (Chs==0){Clr();}
669    else if (Chs<Len()){
670      char* Bf=new char[Chs+1]; strncpy(Bf, CStr(), BChN);
671      strncpy(Bf+BChN, CStr()+EChN+1, Len()-EChN-1); Bf[Chs]=0;
672      TStr Str(Bf); delete[] Bf;
673      *this=Str;
674    }
675  }
676  bool TStr::DelStr(const TStr& Str){
677    int ChN=SearchStr(Str);
678    if (ChN==-1){
679      return false;
680    } else {
681      DelSubStr(ChN, ChN+Str.Len()-1);
682      return true;
683    }
684  }
685  TStr TStr::LeftOf(const char& SplitCh) const {
686    int ThisLen=Len(); const char* ThisBf=CStr();
687    int ChN=0;
688    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
689    return (ChN==ThisLen) ? "" : GetSubStr(0, ChN-1);
690  }
691  TStr TStr::LeftOfLast(const char& SplitCh) const {
692    const char* ThisBf=CStr();
693    int ChN=Len()-1;
694    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
695    return (ChN==-1) ? "" : GetSubStr(0, ChN-1);
696  }
697  TStr TStr::RightOf(const char& SplitCh) const {
698    int ThisLen=Len(); const char* ThisBf=CStr();
699    int ChN=0;
700    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
701    return (ChN==ThisLen) ? "" : GetSubStr(ChN+1, ThisLen-1);
702  }
703  TStr TStr::RightOfLast(const char& SplitCh) const {
704    int ThisLen=Len(); const char* ThisBf=CStr();
705    int ChN=Len()-1;
706    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
707    return (ChN==-1) ? "" : GetSubStr(ChN+1, ThisLen-1);
708  }
709  void TStr::SplitOnCh(TStr& LStr, const char& SplitCh, TStr& RStr) const {
710    int ThisLen=Len(); const char* ThisBf=CStr();
711    int ChN=0;
712    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
713    if (ChN==ThisLen){
714      LStr=GetSubStr(0, ThisLen-1); RStr="";
715    } else {
716      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
717    }
718  }
719  void TStr::SplitOnLastCh(TStr& LStr, const char& SplitCh, TStr& RStr) const {
720    int ThisLen=Len(); const char* ThisBf=CStr();
721    int ChN=Len()-1;
722    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
723    if (ChN==-1){
724      LStr=""; RStr=*this;
725    } else
726    if (ChN==0){
727      LStr=""; RStr=GetSubStr(1, ThisLen-1);
728    } else {
729      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
730    }
731  }
732  void TStr::SplitOnAllCh(
733   const char& SplitCh, TStrV& StrV, const bool& SkipEmpty) const {
734    StrV.Clr();
735    char* Bf=new char[Len()+1];
736    strcpy(Bf, CStr());
737    char* CurStrBf=Bf;
738    forever{
739      char* BfC=CurStrBf;
740      while ((*BfC!=0)&&(*BfC!=SplitCh)){BfC++;}
741      bool IsEnd=(*BfC=='\0');
742      *BfC=0;
743      if ((BfC>CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
744      if (IsEnd){break;}
745      CurStrBf=BfC+1;
746    }
747    delete[] Bf;
748  }
749  void TStr::SplitOnAllAnyCh(
750   const TStr& SplitChStr, TStrV& StrV, const bool& SkipEmpty) const {
751    StrV.Clr();
752    char* Bf=new char[Len()+1];
753    strcpy(Bf, CStr());
754    char* CurStrBf=Bf; 
755    const char* SplitChBf=SplitChStr.CStr();
756    forever{
757      char* BfC=CurStrBf; 
758      while (*BfC!=0){
759        const char* SplitChBfC=SplitChBf; 
760        while ((*SplitChBfC!=0)&&(*SplitChBfC!=*BfC)){SplitChBfC++;}
761        if (*SplitChBfC!=0){break;} 
762        BfC++;
763      }
764      bool IsEnd=(*BfC==0);
765      *BfC=0;
766      if ((BfC>CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
767      if (IsEnd){break;}
768      CurStrBf=BfC+1;
769    }
770    delete[] Bf;
771  }
772  void TStr::SplitOnWs(TStrV& StrV) const {
773    StrV.Clr();
774    char* Bf=new char[Len()+1];
775    strcpy(Bf, CStr());
776    char* StrBf=Bf;
777    forever{
778      while ((*StrBf!=0)&&(TCh::IsWs(*StrBf))){StrBf++;}
779      char* BfC=StrBf;
780      while ((*BfC!=0)&&(!TCh::IsWs(*BfC))){BfC++;}
781      bool IsEnd=(*BfC=='\0');
782      *BfC=0;
783      if (BfC>StrBf){StrV.Add(TStr(StrBf));}
784      if (IsEnd){break;}
785      StrBf=BfC+1;
786    }
787    delete[] Bf;
788  }
789  void TStr::SplitOnNonAlNum(TStrV& StrV) const {
790    StrV.Clr();
791    char* Bf=new char[Len()+1];
792    strcpy(Bf, CStr());
793    char* StrBf=Bf;
794    forever{
795      while ((*StrBf!=0)&&(!TCh::IsAlNum(*StrBf))){StrBf++;}
796      char* BfC=StrBf;
797      while ((*BfC!=0)&&(TCh::IsAlNum(*BfC))){BfC++;}
798      bool IsEnd=(*BfC=='\0');
799      *BfC=0;
800      if (BfC>StrBf){StrV.Add(TStr(StrBf));}
801      if (IsEnd){break;}
802      StrBf=BfC+1;
803    }
804    delete[] Bf;
805  }
806  void TStr::SplitOnStr(const TStr& SplitStr, TStrV& StrV) const {
807    StrV.Clr();
808    int SplitStrLen=SplitStr.Len();
809    int PrevChN=0; int ChN=0;
810    while ((ChN=SearchStr(SplitStr, ChN))!=-1){
811      TStr SubStr=GetSubStr(PrevChN, ChN-1);
812      StrV.Add(SubStr);
813      PrevChN=ChN=ChN+SplitStrLen;
814    }
815    TStr LastSubStr=GetSubStr(PrevChN, Len()-1);
816    StrV.Add(LastSubStr);
817  }
818  void TStr::SplitOnStr(TStr& LeftStr, const TStr& MidStr, TStr& RightStr) const {
819    const int ChN=SearchStr(MidStr);
820    if (ChN==-1){
821      LeftStr=*this; RightStr=GetNullStr();
822    } else {
823      LeftStr=GetSubStr(0, ChN-1);
824      RightStr=GetSubStr(ChN+MidStr.Len(), Len()-1);
825    }
826  }
827  int TStr::CountCh(const char& Ch, const int& BChN) const {
828    const int ThisLen=Len();
829    const char* ThisBf=CStr();
830    int Chs=0;
831    for (int ChN=TInt::GetMx(BChN, 0); ChN<ThisLen; ChN++){
832      if (ThisBf[ChN]==Ch){Chs++;}
833    }
834    return Chs;
835  }
836  int TStr::SearchCh(const char& Ch, const int& BChN) const {
837    int ThisLen=Len(); const char* ThisBf=CStr();
838    int ChN=TInt::GetMx(BChN, 0);
839    while (ChN<ThisLen){
840      if (ThisBf[ChN]==Ch){return ChN;}
841      ChN++;
842    }
843    return -1;
844  }
845  int TStr::SearchChBack(const char& Ch, int BChN) const {
846    const int StrLen=Len();
847    if (BChN==-1||BChN>=StrLen){BChN=StrLen-1;}
848    const char* ThisBf=CStr();
849    const char* Pt=ThisBf + BChN;
850    while (Pt>=ThisBf) {
851      if (*Pt==Ch){return (int)(Pt-ThisBf);}
852      Pt--;
853    }
854    return -1;
855  }
856  int TStr::SearchStr(const TStr& Str, const int& BChN) const {
857    int NrBChN=TInt::GetMx(BChN, 0);
858    const char* StrPt=strstr((const char*)CStr()+NrBChN, Str.CStr());
859    if (StrPt==NULL){return -1;}
860    else {return int(StrPt-CStr());}
861  }
862  bool TStr::IsPrefix(const char *Str) const {
863  	size_t len = strlen(Str);
864  	size_t thisLen = Len();
865  	if (len > thisLen) {
866  		return false;
867  	} else {
868          size_t minLen = MIN(len, thisLen);
869  		int cmp = strncmp(Str, RStr->Bf, minLen);
870  		return cmp == 0;
871  	}
872  }
873  bool TStr::IsSuffix(const char *Str) const {
874  	size_t len = strlen(Str);
875  	size_t thisLen = Len();
876  	if (len > thisLen) {
877  		return false;
878  	} else {
879  		const char *ending = RStr->Bf + thisLen - len;
880  		int cmp = strncmp(Str, ending, len);
881  		return cmp == 0;
882  	}
883  }
884  int TStr::ChangeCh(const char& SrcCh, const char& DstCh, const int& BChN){
885    int ChN=SearchCh(SrcCh, BChN);
886    if (ChN!=-1){PutCh(ChN, DstCh);}
887    return ChN;
888  }
889  int TStr::ChangeChAll(const char& SrcCh, const char& DstCh){
890    int FirstChN=SearchCh(SrcCh);
891    if (FirstChN==-1){
892      return 0;
893    } else {
894      TRStr* NewRStr=new TRStr(RStr->CStr());
895      RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
896      char* ThisBf=CStr(); int StrLen=Len(); int Changes=0;
897      for (int ChN=FirstChN; ChN<StrLen; ChN++){
898        if (ThisBf[ChN]==SrcCh){ThisBf[ChN]=DstCh; Changes++;}
899      }
900      Optimize();
901      return Changes;
902    }
903  }
904  int TStr::ChangeStr(const TStr& SrcStr, const TStr& DstStr, const int& BChN){
905    int ChN=SearchStr(SrcStr, BChN);
906    if (ChN==-1){
907      return -1;
908    } else {
909      DelSubStr(ChN, ChN+SrcStr.Len()-1);
910      InsStr(ChN, DstStr);
911      return ChN;
912    }
913  }
914  int TStr::ChangeStrAll(const TStr& SrcStr, const TStr& DstStr, const bool& FromStartP){
915    const int DstStrLen=DstStr.Len();
916    int Changes=0-1; int BChN=0-DstStrLen;
917    do {
918      Changes++;
919      if (FromStartP){BChN=0-DstStrLen;}
920      BChN+=DstStrLen;
921      BChN=ChangeStr(SrcStr, DstStr, BChN);
922    } while (BChN!=-1);
923    return Changes;
924  }
925  bool TStr::IsBool(bool& Val) const {
926    if (operator==("T")){Val=true; return true;}
927    else if (operator==("F")){Val=false; return true;}
928    else {return false;}
929  }
930  bool TStr::IsInt(
931   const bool& Check, const int& MnVal, const int& MxVal, int& Val) const {
932    int _Val=0;
933    bool Minus=false;
934    TChRet Ch(TStrIn::New(*this));
935    while (TCh::IsWs(Ch.GetCh())){}
936    if (Ch()=='+'){Minus=false; Ch.GetCh();}
937    if (Ch()=='-'){Minus=true; Ch.GetCh();}
938    if (!TCh::IsNum(Ch())){return false;}
939    _Val=TCh::GetNum(Ch());
940    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
941    if (Minus){_Val=-_Val;}
942    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
943    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
944  }
945  bool TStr::IsUInt(
946   const bool& Check, const uint& MnVal, const uint& MxVal, uint& Val) const {
947    uint _Val=0;
948    TChRet Ch(TStrIn::New(*this));
949    while (TCh::IsWs(Ch.GetCh())){}
950    if (Ch()=='+'){Ch.GetCh();}
951    if (!TCh::IsNum(Ch())){return false;}
952    _Val=TCh::GetNum(Ch());
953    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
954    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
955    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
956  }
957  bool TStr::IsHexInt( const bool& Check, const int& MnVal, const int& MxVal, int& Val) const {
958    int _Val=0;
959    bool Minus=false;
960    TChRet Ch(TStrIn::New(*this));
961    while (TCh::IsWs(Ch.GetCh())){}
962    if (Ch()=='+'){Minus=false; Ch.GetCh();}
963    if (Ch()=='-'){Minus=true; Ch.GetCh();}
964    if (Ch()=='0'){
965      Ch.GetCh();
966      if (tolower(Ch())=='x' ){
967        Ch.GetCh(); if (Ch.Eof()){return false;}
968      }
969    }
970    if (!Ch.Eof() && !TCh::IsHex(Ch())){return false;}
971    if (!Ch.Eof()) _Val = TCh::GetHex(Ch());
972    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
973    if (Minus){_Val=-_Val;}
974    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
975    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
976  }
977  bool TStr::IsInt64(
978   const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const {
979    int64 _Val=0;
980    bool Minus=false;
981    TChRet Ch(TStrIn::New(*this));
982    while (TCh::IsWs(Ch.GetCh())){}
983    if (Ch()=='+'){Minus=false; Ch.GetCh();}
984    if (Ch()=='-'){Minus=true; Ch.GetCh();}
985    if (!TCh::IsNum(Ch())){return false;}
986    _Val=TCh::GetNum(Ch());
987    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
988    if (Minus){_Val=-_Val;}
989    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
990    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
991  }
992  bool TStr::IsUInt64(
993   const bool& Check, const uint64& MnVal, const uint64& MxVal, uint64& Val) const {
994    uint64 _Val=0;
995    TChRet Ch(TStrIn::New(*this));
996    while (TCh::IsWs(Ch.GetCh())){}
997    if (Ch()=='+'){Ch.GetCh();}
998    if (!TCh::IsNum(Ch())){return false;}
999    _Val=TCh::GetNum(Ch());
1000    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
1001    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
1002    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1003  }
1004  bool TStr::IsHexInt64(
1005   const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const {
1006    int64 _Val=0;
1007    bool Minus=false;
1008    TChRet Ch(TStrIn::New(*this));
1009    while (TCh::IsWs(Ch.GetCh())){}
1010    if (Ch()=='+'){Minus=false; Ch.GetCh();}
1011    if (Ch()=='-'){Minus=true; Ch.GetCh();}
1012    if (Ch()=='0'){
1013      Ch.GetCh();
1014      if (tolower(Ch())=='x' ){
1015        Ch.GetCh(); if (Ch.Eof()){return false;}
1016      }
1017    }
1018    if (!Ch.Eof()) _Val=TCh::GetHex(Ch());
1019    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
1020    if (Minus){_Val=-_Val;}
1021    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
1022    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1023  }
1024  bool TStr::IsFlt(const bool& Check, const double& MnVal, const double& MxVal,
1025   double& Val, const char& DecDelimCh) const {
1026    TChRet Ch(TStrIn::New(*this));
1027    while (TCh::IsWs(Ch.GetCh())){}
1028    if ((Ch()=='+')||(Ch()=='-')){Ch.GetCh();}
1029    if (!TCh::IsNum(Ch())&&Ch()!=DecDelimCh){return false;}
1030    while (TCh::IsNum(Ch.GetCh())){}
1031    if (Ch()==DecDelimCh){
1032      Ch.GetCh();
1033      while (TCh::IsNum(Ch.GetCh())){}
1034    }
1035    if ((Ch()=='e')||(Ch()=='E')){
1036      Ch.GetCh();
1037      if ((Ch()=='+')||(Ch()=='-')){Ch.GetCh();}
1038      if (!TCh::IsNum(Ch())){return false;}
1039      while (TCh::IsNum(Ch.GetCh())){}
1040    }
1041    if (!Ch.Eof()){return false;}
1042    double _Val=atof(CStr());
1043    if (Check&&((_Val<MnVal)||(_Val>MxVal))){
1044      return false;
1045    } else {
1046      Val=_Val; return true;
1047    }
1048  }
1049  bool TStr::IsWord(const bool& WsPrefixP, const bool& FirstUcAllowedP) const {
1050    TChRet Ch(TStrIn::New(*this));
1051    if (WsPrefixP){while (TCh::IsWs(Ch.GetCh())){}}
1052    else {Ch.GetCh();}
1053    if (!TCh::IsAlpha(Ch())){return false;}
1054    else if (!FirstUcAllowedP&&(TCh::IsUc(Ch()))){return false;}
1055    while (TCh::IsAlNum(Ch.GetCh())){}
1056    if (!Ch.Eof()){return false;}
1057    return true;
1058  }
1059  bool TStr::IsWs() const {
1060    TChRet Ch(TStrIn::New(*this));
1061    while (TCh::IsWs(Ch.GetCh())){}
1062    return Ch.Eof();
1063  }
1064  bool TStr::IsWcMatch(
1065   const int& StrBChN, const TStr& WcStr, const int& WcStrBChN, TStrV& StarStrV,
1066   const char& StarCh, const char& QuestCh) const {
1067    int StrLen=Len(); int WcStrLen=WcStr.Len();
1068    int StrChN=StrBChN; int WcStrChN=WcStrBChN;
1069    while ((StrChN<StrLen)&&(WcStrChN<WcStrLen)){
1070      if ((WcStr[WcStrChN]==QuestCh)||(GetCh(StrChN)==WcStr[WcStrChN])){
1071        StrChN++; WcStrChN++;
1072      } else
1073      if (WcStr[WcStrChN]==StarCh){
1074        TChA StarChA; 
1075        for (int AfterStrChN=StrChN; AfterStrChN<=StrLen; AfterStrChN++){
1076          if (AfterStrChN>StrChN){
1077            StarChA+=GetCh(AfterStrChN-1);}
1078          if (IsWcMatch(AfterStrChN, WcStr, WcStrChN+1, StarStrV, StarCh, QuestCh)){
1079            StarStrV.Add(StarChA); return true;
1080          }
1081        }
1082        return false;
1083      } else {
1084        return false;
1085      }
1086    }
1087    if (StrChN==StrLen){
1088      for (int AfterWcStrChN=WcStrChN; AfterWcStrChN<WcStrLen; AfterWcStrChN++){
1089        if (WcStr[AfterWcStrChN]!=StarCh){return false;}}
1090      return true;
1091    } else {
1092      return false;
1093    }
1094  }
1095  bool TStr::IsWcMatch(
1096   const TStr& WcStr, TStrV& StarStrV, const char& StarCh, const char& QuestCh) const {
1097    bool WcMatch=IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1098    if (WcMatch){
1099      StarStrV.Reverse();
1100      return true;
1101    } else {
1102      return false;
1103    }
1104  }
1105  bool TStr::IsWcMatch(
1106   const TStr& WcStr, const char& StarCh, const char& QuestCh) const {
1107    TStrV StarStrV;
1108    return IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1109  }
1110  bool TStr::IsWcMatch(const TStr& WcStr, const int& StarStrN, TStr& StarStr) const {
1111    TStrV StarStrV;
1112    if (IsWcMatch(WcStr, StarStrV)){
1113      if (StarStrV.Len()>StarStrN){
1114        StarStr=StarStrV[StarStrV.Len()-StarStrN-1];
1115      } else {
1116        StarStr="";
1117      }
1118      return true;
1119    } else {
1120      return false;
1121    }
1122  }
1123  bool TStr::IsWcMatch(const TStr& WcStr) const {
1124    TStrV StarStrV;
1125    return IsWcMatch(0, WcStr, 0, StarStrV);
1126  }
1127  TStr TStr::GetWcMatch(const TStr& WcStr, const int& StarStrN) const {
1128    TStrV StarStrV;
1129    if (IsWcMatch(WcStr, StarStrV)&&(StarStrV.Len()>=StarStrN)){
1130      IAssert(StarStrN>=0);
1131      return StarStrV[StarStrV.Len()-StarStrN-1];
1132    } else {
1133      return "";
1134    }
1135  }
1136  TStr TStr::GetFPath() const {
1137    int ThisLen=Len(); const char* ThisBf=CStr();
1138    int ChN=ThisLen-1;
1139    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1140    return GetSubStr(0, ChN);
1141  }
1142  TStr TStr::GetFBase() const {
1143    int ThisLen=Len(); const char* ThisBf=CStr();
1144    int ChN=ThisLen-1;
1145    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1146    return GetSubStr(ChN+1, ThisLen);
1147  }
1148  TStr TStr::GetFMid() const {
1149    int ThisLen=Len(); const char* ThisBf=CStr();
1150    int ChN=ThisLen-1;
1151    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')&&(ThisBf[ChN]!='.')){
1152      ChN--;}
1153    if (ChN<0){
1154      return *this;
1155    } else {
1156      if (ThisBf[ChN]=='.'){
1157        int EChN= --ChN;
1158        while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1159        return GetSubStr(ChN+1, EChN);
1160      } else {
1161        return GetSubStr(ChN+1, ThisLen);
1162      }
1163    }
1164  }
1165  TStr TStr::GetFExt() const {
1166    int ThisLen=Len(); const char* ThisBf=CStr();
1167    int ChN=ThisLen-1;
1168    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')&&
1169     (ThisBf[ChN]!='.')){ChN--;}
1170    if ((ChN>=0)&&(ThisBf[ChN]=='.')){return GetSubStr(ChN, Len());}
1171    else {return TStr();}
1172  }
1173  TStr TStr::GetNrFPath(const TStr& FPath){
1174    TChA NrFPath(FPath.Len()+4); NrFPath+=FPath;
1175    NrFPath.ChangeCh('\\', '/');
1176    if (NrFPath.Empty()){NrFPath="./";}
1177    if ((NrFPath.Len()>=2)&&isalpha(NrFPath[0])&&(NrFPath[1]==':')){
1178      if (NrFPath.Len()==2){NrFPath+="./";}
1179      if ((NrFPath[2]!='.')&&(NrFPath[2]!='/')){NrFPath.Ins(2, "./");}
1180      if (NrFPath[NrFPath.Len()-1]!='/'){NrFPath+="/";}
1181    } else {
1182      if ((NrFPath[0]!='.')&&(NrFPath[0]!='/')){NrFPath.Ins(0, "./");}
1183      if (NrFPath[NrFPath.Len()-1]!='/'){NrFPath+="/";}
1184    }
1185    return NrFPath;
1186  }
1187  TStr TStr::GetNrFMid(const TStr& FMid){
1188    TChA NrFMid;
1189    int FMidLen=FMid.Len();
1190    for (int ChN=0; ChN<FMidLen; ChN++){
1191      char Ch=FMid[ChN];
1192      if (TCh::IsAlNum(Ch)){NrFMid+=Ch;} else {NrFMid+='_';}
1193    }
1194    return NrFMid;
1195  }
1196  TStr TStr::GetNrFExt(const TStr& FExt){
1197    if (FExt.Empty()||(FExt[0]=='.')){return FExt;}
1198    else {return TStr(".")+FExt;}
1199  }
1200  TStr TStr::GetNrNumFExt(const int& FExtN){
1201    TStr FExtNStr=TInt::GetStr(FExtN);
1202    while (FExtNStr.Len()<3){
1203      FExtNStr=TStr("0")+FExtNStr;}
1204    return FExtNStr;
1205  }
1206  TStr TStr::GetNrFNm(const TStr& FNm){
1207    return GetNrFPath(FNm.GetFPath())+FNm.GetFMid()+GetNrFExt(FNm.GetFExt());
1208  }
1209  TStr TStr::GetNrAbsFPath(const TStr& FPath, const TStr& BaseFPath){
1210    TStr NrBaseFPath;
1211    if (BaseFPath.Empty()){
1212      NrBaseFPath=GetNrFPath(TDir::GetCurDir());
1213    } else {
1214      NrBaseFPath=GetNrFPath(BaseFPath);
1215    }
1216    IAssert(IsAbsFPath(NrBaseFPath));
1217    TStr NrFPath=GetNrFPath(FPath);
1218    TStr NrAbsFPath;
1219    if (IsAbsFPath(NrFPath)){
1220      NrAbsFPath=NrFPath;
1221    } else {
1222      NrAbsFPath=GetNrFPath(NrBaseFPath+NrFPath);
1223    }
1224    NrAbsFPath.ChangeStrAll("/./", "/");
1225    NrAbsFPath.ChangeStrAll("\\.\\", "\\");
1226    return NrAbsFPath;
1227  }
1228  bool TStr::IsAbsFPath(const TStr& FPath){
1229    if ((FPath.Len()>=3)&&isalpha(FPath[0])&&(FPath[1]==':')&&
1230     ((FPath[2]=='/')||(FPath[2]=='\\'))){
1231      return true;
1232    }
1233    return false;
1234  }
1235  TStr TStr::PutFExt(const TStr& FNm, const TStr& FExt){
1236    return FNm.GetFPath()+FNm.GetFMid()+FExt;
1237  }
1238  TStr TStr::PutFExtIfEmpty(const TStr& FNm, const TStr& FExt){
1239    if (FNm.GetFExt().Empty()){
1240      return FNm.GetFPath()+FNm.GetFMid()+FExt;
1241    } else {
1242      return FNm;
1243    }
1244  }
1245  TStr TStr::PutFBase(const TStr& FNm, const TStr& FBase){
1246    return FNm.GetFPath()+FBase;
1247  }
1248  TStr TStr::PutFBaseIfEmpty(const TStr& FNm, const TStr& FBase){
1249    if (FNm.GetFBase().Empty()){
1250      return FNm.GetFPath()+FBase;
1251    } else {
1252      return FNm;
1253    }
1254  }
1255  TStr TStr::AddToFMid(const TStr& FNm, const TStr& ExtFMid){
1256    return FNm.GetFPath()+FNm.GetFMid()+ExtFMid+FNm.GetFExt();
1257  }
1258  TStr TStr::GetNumFNm(const TStr& FNm, const int& Num){
1259    return FNm.GetFPath()+FNm.GetFMid()+TInt::GetStr(Num, "%03d")+FNm.GetFExt();
1260  }
1261  TStr TStr::GetFNmStr(const TStr& Str, const bool& AlNumOnlyP){
1262    TChA FNm=Str;
1263    for (int ChN=0; ChN<FNm.Len(); ChN++){
1264      uchar Ch=FNm[ChN];
1265      if (AlNumOnlyP){
1266        if (
1267         (('0'<=Ch)&&(Ch<='9'))||
1268         (('A'<=Ch)&&(Ch<='Z'))||
1269         (('a'<=Ch)&&(Ch<='z'))||
1270         (Ch=='-')||(Ch=='_')){}
1271        else {Ch='_';}
1272      } else {
1273        if ((Ch<=' ')||(Ch=='/')||(Ch=='\\')||(Ch==':')||(Ch=='.')){
1274          Ch='_';}
1275      }
1276      FNm.PutCh(ChN, Ch);
1277    }
1278    return FNm;
1279  }
1280  TStr& TStr::GetChStr(const char& Ch){
1281    static char MnCh=char(CHAR_MIN);
1282    static char MxCh=char(CHAR_MAX);
1283    static int Chs=int(MxCh)-int(MnCh)+1;
1284    static TStrV ChStrV;
1285    if (ChStrV.Empty()){
1286      ChStrV.Gen(Chs);
1287      for (int ChN=0; ChN<Chs; ChN++){
1288        ChStrV[ChN]=TStr(char(MnCh+ChN), true);}
1289    }
1290    return ChStrV[int(Ch-MnCh)];
1291  }
1292  TStr& TStr::GetDChStr(const char& Ch1, const char& Ch2){
1293    Fail; 
1294    static TStrVV DChStrVV;
1295    if (DChStrVV.Empty()){
1296      DChStrVV.Gen(TCh::Vals, TCh::Vals);
1297      for (int Ch1N=0; Ch1N<TCh::Vals; Ch1N++){
1298        for (int Ch2N=0; Ch2N<TCh::Vals; Ch2N++){
1299          DChStrVV.At(Ch1N, Ch2N)=
1300           TStr(char(TCh::Mn+Ch1N), char(TCh::Mn+Ch2N), true);
1301        }
1302      }
1303    }
1304    return DChStrVV.At(int(Ch1-TCh::Mn), int(Ch2-TCh::Mn));
1305  }
1306  TStr TStr::GetStr(const TStr& Str, const char* FmtStr){
1307    if (FmtStr==NULL){
1308      return Str;
1309    } else {
1310      char Bf[1000];
1311      sprintf(Bf, FmtStr, Str.CStr());
1312      return TStr(Bf);
1313    }
1314  }
1315  TStr TStr::GetStr(const TStrV& StrV, const TStr& DelimiterStr){
1316    if (StrV.Empty()){return TStr();}
1317    TChA ResStr=StrV[0];
1318    for (int StrN=1; StrN<StrV.Len(); StrN++){
1319      ResStr+=DelimiterStr;
1320      ResStr+=StrV[StrN];
1321    }
1322    return ResStr;
1323  }
1324  TStr TStr::Fmt(const char *FmtStr, ...){
1325    char Bf[10*1024];
1326    va_list valist;
1327    va_start(valist, FmtStr);
1328    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
1329    va_end(valist);
1330    return RetVal!=-1 ? TStr(Bf) : TStr::GetNullStr();
1331  }
1332  TStr TStr::GetSpaceStr(const int& Spaces){
1333    static TStrV SpaceStrV;
1334    if (SpaceStrV.Len()==0){
1335      for (int SpaceStrN=0; SpaceStrN<10; SpaceStrN++){
1336        TChA SpaceChA;
1337        for (int ChN=0; ChN<SpaceStrN; ChN++){SpaceChA+=' ';}
1338        SpaceStrV.Add(SpaceChA);
1339      }
1340    }
1341    if ((0<=Spaces)&&(Spaces<SpaceStrV.Len())){
1342      return SpaceStrV[Spaces];
1343    } else {
1344      TChA SpaceChA;
1345      for (int ChN=0; ChN<Spaces; ChN++){SpaceChA+=' ';}
1346      return SpaceChA;
1347    }
1348  }
1349  TStr TStr::GetNullStr(){
1350    static TStr NullStr="";
1351    return NullStr;
1352  }
1353  TStr operator+(const TStr& LStr, const TStr& RStr){
1354    if (LStr.Empty()){return RStr;}
1355    else if (RStr.Empty()){return LStr;}
1356    else {return TStr(LStr)+=RStr;}
1357  }
1358  TStr operator+(const TStr& LStr, const char* RCStr){
1359    return TStr(LStr)+=RCStr;
1360  }
1361  TStrIn::TStrIn(const TStr& _Str):
1362    TSBase("Input-String"), TSIn("Input-String"), Str(_Str), Bf(Str.CStr()), BfC(0), BfL(Str.Len()){}
1363  int TStrIn::GetBf(const void* LBf, const TSize& LBfL){
1364    Assert(TSize(BfC+LBfL)<=TSize(BfL));
1365    int LBfS=0;
1366    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
1367      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
1368    return LBfS;
1369  }
1370  bool TStrIn::GetNextLnBf(TChA& LnChA){
1371    FailR(TStr::Fmt("TStrIn::GetNextLnBf: not implemented").CStr());
1372    return false;
1373  }
1374  void TStrPool::Resize(const uint& _MxBfL) {
1375    uint newSize = MxBfL;
1376    while (newSize < _MxBfL) {
1377      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
1378      else if (newSize > 0) newSize *= 2;
1379      else newSize = TInt::GetMn(GrowBy, 1024);
1380      IAssertR(newSize >= MxBfL, TStr::Fmt("TStrPool::Resize: %u, %u [Size larger than 4Gb, which is not supported by TStrPool]", newSize, MxBfL).CStr());
1381    }
1382    if (newSize > MxBfL) {
1383      Bf = (char *) realloc(Bf, newSize);
1384      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
1385      MxBfL = newSize;
1386    }
1387    IAssertR(MxBfL >= _MxBfL, TStr::Fmt("new size: %u, requested size: %u", MxBfL, _MxBfL).CStr());
1388  }
1389  TStrPool::TStrPool(const uint& MxBfLen, const uint& _GrowBy) : MxBfL(MxBfLen), BfL(0), GrowBy(_GrowBy), Bf(0) {
1390    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); }
1391    AddStr(""); 
1392  }
1393  TStrPool::TStrPool(TSIn& SIn, bool LoadCompact) : MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1394    SIn.Load(MxBfL);  SIn.Load(BfL);  SIn.Load(GrowBy);
1395    if (LoadCompact) MxBfL = BfL;
1396    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL); IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); }
1397    if (BfL > 0) SIn.LoadBf(Bf, BfL);
1398    SIn.LoadCs();
1399  }
1400  void TStrPool::Save(TSOut& SOut) const {
1401    SOut.Save(MxBfL);  SOut.Save(BfL);  SOut.Save(GrowBy);
1402    SOut.SaveBf(Bf, BfL);
1403    SOut.SaveCs();
1404  }
1405  TStrPool& TStrPool::operator = (const TStrPool& Pool) {
1406    if (this != &Pool) {
1407      GrowBy = Pool.GrowBy;  MxBfL = Pool.MxBfL;  BfL = Pool.BfL;
1408      if (Bf) free(Bf); else IAssertR(MxBfL == 0, TStr::Fmt("size: %u, expected size: 0", MxBfL).CStr());
1409      Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr());  memcpy(Bf, Pool.Bf, BfL);
1410    }
1411    return *this;
1412  }
1413  uint TStrPool::AddStr(const char *Str, const uint& Len) {
1414    IAssertR(Len > 0, "String too short (length includes the null character)");  
1415    if (Len == 1 && BfL > 0) { return 0; } 
1416    Assert(Str);  Assert(Len > 0);
1417    if (BfL + Len > MxBfL) Resize(BfL + Len);
1418    memcpy(Bf + BfL, Str, Len);
1419    uint Pos = BfL;  BfL += Len;  return Pos;
1420  }
1421  int TStrPool::GetPrimHashCd(const char *CStr) {
1422    return TStrHashF_DJB::GetPrimHashCd(CStr);
1423  }
1424  int TStrPool::GetSecHashCd(const char *CStr) {
1425    return TStrHashF_DJB::GetSecHashCd(CStr);
1426  }
1427  void TStrPool64::Resize(const ::TSize& _MxBfL) {
1428    ::TSize newSize = MxBfL;
1429    while (newSize < _MxBfL) {
1430      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
1431      else if (newSize > 0) newSize *= 2;
1432      else newSize = (GrowBy > ::TSize(1024)) ? ::TSize(1024) : GrowBy;
1433      IAssert(newSize >= MxBfL); 
1434    }
1435    if (newSize > MxBfL) {
1436      Bf = (char *) realloc(Bf, newSize);
1437      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
1438      MxBfL = newSize;
1439    }
1440    IAssert(MxBfL >= _MxBfL);
1441  }
1442  TStrPool64::TStrPool64(::TSize _MxBfL, ::TSize _GrowBy):
1443      MxBfL(_MxBfL), BfL(0), GrowBy(_GrowBy), Bf(NULL) {
1444    if (MxBfL > 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1445    AddStr("");
1446  }
1447  TStrPool64::TStrPool64(const TStrPool64& StrPool): 
1448    MxBfL(StrPool.MxBfL), BfL(StrPool.BfL), GrowBy(StrPool.GrowBy) {
1449    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1450    Bf = (char*)malloc(StrPool.MxBfL); IAssert(Bf != NULL); 
1451    memcpy(Bf, StrPool.Bf, BfL);
1452  }
1453  TStrPool64::TStrPool64(TSIn& SIn, bool LoadCompact): 
1454    MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1455    uint64 _GrowBy, _MxBfL, _BfL;
1456    SIn.Load(_GrowBy); SIn.Load(_MxBfL); SIn.Load(_BfL);
1457    GrowBy = (::TSize)_GrowBy; MxBfL = (::TSize)_MxBfL; BfL = (::TSize)_BfL;
1458    if (LoadCompact) { MxBfL = BfL; }
1459    if (MxBfL > 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1460    for (::TSize BfN = 0; BfN < _BfL; BfN++) { Bf[BfN] = SIn.GetCh(); }
1461    SIn.LoadCs();
1462  }
1463  void TStrPool64::Save(TSOut& SOut) const {
1464    uint64 _GrowBy = GrowBy, _MxBfL = MxBfL, _BfL = BfL;
1465    SOut.Save(_GrowBy);  SOut.Save(_MxBfL);  SOut.Save(_BfL);
1466    for (::TSize BfN = 0; BfN < _BfL; BfN++) { SOut.PutCh(Bf[BfN]); }
1467    SOut.SaveCs();
1468  }
1469  TStrPool64& TStrPool64::operator=(const TStrPool64& StrPool) {
1470    if (this != &StrPool) {
1471    GrowBy = StrPool.GrowBy;  MxBfL = StrPool.MxBfL;  BfL = StrPool.BfL;
1472    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1473    Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); 
1474    memcpy(Bf, StrPool.Bf, BfL);
1475    }
1476    return *this;
1477  }
1478  void TStrPool64::Clr(bool DoDel) { 
1479    BfL = 0; 
1480    if (DoDel && (Bf!=NULL)) { 
1481      free(Bf); 
1482      Bf = NULL; MxBfL = 0; 
1483    } 
1484  }
1485  uint64 TStrPool64::AddStr(const TStr& Str) {
1486    const int Len = Str.Len() + 1;
1487    if (BfL + Len > MxBfL) { Resize(BfL + Len); }
1488    memcpy(Bf + BfL, Str.CStr(), Len);
1489    ::TSize Offset = BfL;  BfL += Len;
1490    return uint64(Offset);
1491  }
1492  TStr TStrPool64::GetStr(const uint64& StrId) const {
1493    ::TSize Offset = (::TSize)StrId;
1494    return TStr(Bf + Offset);
1495  }
1496  void TVoid::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1497    XLoadHd(Nm);
1498  }
1499  void TVoid::SaveXml(TSOut& SOut, const TStr& Nm) const {
1500    XSaveBETag(Nm);
1501  }
1502  const bool TBool::Mn=0;
1503  const bool TBool::Mx=1;
1504  const int TBool::Vals=TBool::Mx-TBool::Mn+1;
1505  TRnd TBool::Rnd;
1506  const TStr TBool::FalseStr="F";
1507  const TStr TBool::TrueStr="T";
1508  const TStr TBool::NStr="N";
1509  const TStr TBool::YStr="Y";
1510  const TStr TBool::NoStr="No";
1511  const TStr TBool::YesStr="Yes";
1512  void TBool::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1513    XLoadHd(Nm);
1514    Val=TXmlObjSer::GetBoolArg(XmlTok, "Val");
1515  }
1516  void TBool::SaveXml(TSOut& SOut, const TStr& Nm) const {
1517    XSaveBETagArg(Nm, "Val", TBool::GetStr(Val));
1518  }
1519  bool TBool::IsValStr(const TStr& Str){
1520    TStr UcStr=Str.GetUc();
1521    return
1522     (UcStr==FalseStr)||(UcStr==TrueStr)||
1523     (UcStr==YStr)||(UcStr==NStr)||
1524     (UcStr==YesStr)||(UcStr==NoStr);
1525  }
1526  bool TBool::GetValFromStr(const TStr& Str){
1527    return (Str==TrueStr)||(Str==YStr)||(Str==YesStr);
1528  }
1529  bool TBool::GetValFromStr(const TStr& Str, const bool& DfVal){
1530    TStr UcStr=Str.GetUc();
1531    if (IsValStr(UcStr)){
1532      return (UcStr==TrueStr)||(UcStr==YStr)||(UcStr==YesStr);
1533    } else {
1534      return DfVal;
1535    }
1536  }
1537  const char TCh::Mn=CHAR_MIN;
1538  const char TCh::Mx=CHAR_MAX;
1539  const int TCh::Vals=int(TCh::Mx)-int(TCh::Mn)+1;
1540  const char TCh::NullCh=char(0);
1541  const char TCh::TabCh=char(9);
1542  const char TCh::LfCh=char(10);
1543  const char TCh::CrCh=char(13);
1544  const char TCh::EofCh=char(26);
1545  const char TCh::HashCh='#';
1546  void TCh::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1547    XLoadHd(Nm);
1548    Val=char(TXmlObjSer::GetIntArg(XmlTok, "Val"));
1549  }
1550  void TCh::SaveXml(TSOut& SOut, const TStr& Nm) const {
1551    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1552  }
1553  char TCh::GetUsFromYuAscii(const char& Ch){
1554    switch (Ch){
<span onclick='openModal()' class='match'>1555      case '~': return 'c';
1556      case '^': return 'C';
1557      case '{': return 's';
1558      case '[': return 'S';
1559      case '`': return 'z';
1560      case '@': return 'Z';
1561      case '|': return 'd';
</span>1562      case '\\': return 'D';
1563      default: return Ch;
1564    }
1565  }
1566  const uchar TUCh::Mn=0;
1567  const uchar TUCh::Mx=UCHAR_MAX;
1568  const int TUCh::Vals=int(TUCh::Mx)-int(TUCh::Mn)+1;
1569  void TUCh::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1570    XLoadHd(Nm);
1571    Val=uchar(TXmlObjSer::GetIntArg(XmlTok, "Val"));
1572  }
1573  void TUCh::SaveXml(TSOut& SOut, const TStr& Nm) const {
1574    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1575  }
1576  const int TInt::Mn=INT_MIN;
1577  const int TInt::Mx=INT_MAX;
1578  const int TInt::Kilo=1024;
1579  const int TInt::Mega=1024*1024;
1580  const int TInt::Giga=1024*1024*1024;
1581  TRnd TInt::Rnd;
1582  void TInt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1583    XLoadHd(Nm);
1584    Val=TXmlObjSer::GetIntArg(XmlTok, "Val");
1585  }
1586  void TInt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1587    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1588  }
1589  TStr TInt::GetStr(const int& Val, const char* FmtStr){
1590    if (FmtStr==NULL){
1591      return GetStr(Val);
1592    } else {
1593      char Bf[255];
1594      sprintf(Bf, FmtStr, Val);
1595      return TStr(Bf);
1596    }
1597  }
1598  char* TInt::SaveFrugalInt(char *pDest, int i){
1599    i++;
1600    if (i >= 0 && i <= 127) { *pDest++ = char(i); return pDest; }
1601    if (i >= 128 && i < 128 + 8192) { i -= 128; *pDest++ = char(0x80 | (i & 0x7f));
1602      *pDest++ = char((i >> 7) & 0x3f); return pDest; }
1603    if (i <= -1 && i > -1 - 8192) { i = -1 - i;  *pDest++ = char(0x80 | (i & 0x7f));
1604      *pDest++ = char(0x40 | ((i >> 7) & 0x3f)); return pDest; }
1605    if (i >= 128 + 8192 && i < 128 + 8192 + 536870912) { i -= 128 + 8192;
1606      *pDest++ = char(0x80 | (i & 0x7f)); *pDest++ = char(0x80 | ((i >> 7) & 0x7f));
1607      *pDest++ = char((i >> 14) & 0xff); *pDest++ = char((i >> 22) & 0x7f); return pDest; }
1608    if (i <= -1 - 8192 && i > -1 - 8192 - 536870912) { i = (-1 - 8192) - i;
1609      *pDest++ = char(0x80 | (i & 0x7f)); *pDest++ = char(0x80 | ((i >> 7) & 0x7f));
1610      *pDest++ = char((i >> 14) & 0xff); *pDest++ = char(0x80 | ((i >> 22) & 0x7f)); return pDest; }
1611    IAssertR(false, TInt::GetStr(i)); return 0;
1612  }
1613  char* TInt::LoadFrugalInt(char *pSrc, int& i){
1614    i = 0;
1615    int ch = (int) ((unsigned char) (*pSrc++));
1616    if ((ch & 0x80) == 0) { i = ch; i--; return pSrc; }
1617    i = (ch & 0x7f);
1618    ch = (int) ((unsigned char) (*pSrc++));
1619    if ((ch & 0x80) == 0)
1620    {
1621      i |= (ch & 0x3f) << 7;
1622      if ((ch & 0x40) == 0) i += 128; else i = -1 - i;
1623      i--; return pSrc;
1624    }
1625    i |= (ch & 0x7f) << 7;
1626    ch = (int) ((unsigned char) (*pSrc++));
1627    i |= ch << 14;
1628    ch = (int) ((unsigned char) (*pSrc++));
1629    i |= (ch & 0x7f) << 22;
1630    if ((ch & 0x80) == 0) i += 128 + 8192; else i = (-1 - 8192) - i;
1631    i--; return pSrc;
1632  }
1633  void TInt::TestFrugalInt(){
1634    char buf[10], *p = &buf[0], *r, *s;
1635    int i, j;
1636  #define __TEST(from, to, len) \
1637    for (i = (from); i <= (to); i++) \
1638      { if ((i & 0xffff) == 0) printf("%d\r", i); \
1639        r = SaveFrugalInt(p, i); s = LoadFrugalInt(p, j); \
1640        IAssert(r == s); IAssert(i == j); IAssert(r - p == len); }
1641    __TEST(-1, 126, 1);
1642    __TEST(127, 127 + 8191, 2);
1643    __TEST(-2 - 8191, -2, 2);
1644    __TEST(127 + 8192, 127 + 8191 + (1 << 29), 4);
1645    __TEST(-2 - 8191 - (1 << 29), -2 - 8192, 4);
1646  #undef __TEST
1647  }
1648  void TInt::SaveFrugalIntV(TSOut& SOut, const TIntV& v){
1649    int count = v.Len();
1650    char *buf = new char[4 * (count + 1)], *pStart, *pEnd;
1651    pStart = buf + 4; pEnd = pStart;
1652    for (int i = 0; i < count; i++)
1653      pEnd = SaveFrugalInt(pEnd, v[i].Val);
1654    int size = int(pEnd - pStart);
1655    char *pSizeStart = buf;
1656    char *pSizeEnd = SaveFrugalInt(pSizeStart, size);
1657    while (pSizeEnd > pSizeStart) *(--pStart) = *(--pSizeEnd);
1658    SOut.PutBf(pStart, TSize(pEnd - pStart));
1659    delete[] buf;
1660  }
1661  void TInt::LoadFrugalIntV(TSIn& SIn, TIntV& v, bool clearVec){
1662    if (clearVec) v.Clr();
1663    char sizeBuf[4], *p, *pEnd;
1664    sizeBuf[0] = SIn.GetCh(); int count = 1;
1665    if (sizeBuf[0] & 0x80)
1666    {
1667      sizeBuf[1] = SIn.GetCh(); count++;
1668      if (sizeBuf[1] & 0x80) { sizeBuf[2] = SIn.GetCh();
1669        sizeBuf[3] = SIn.GetCh(); count += 2;}
1670    }
1671    int size;
1672    pEnd = LoadFrugalInt(&sizeBuf[0], size);
1673    IAssert(pEnd - &sizeBuf[0] == count);
1674    if (size <= 0) return;
1675    char *buf = new char[size];
1676    SIn.GetBf(buf, size);
1677    p = buf; pEnd = buf + size;
1678    while (p < pEnd)
1679      { int i; p = LoadFrugalInt(p, i); v.Add(i); }
1680    IAssert(p == pEnd);
1681    delete[] buf;
1682  }
1683  const uint TUInt::Mn=0;
1684  const uint TUInt::Mx=UINT_MAX;
1685  TRnd TUInt::Rnd;
1686  void TUInt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1687    XLoadHd(Nm);
1688    Val=TXmlObjSer::GetIntArg(XmlTok, "Val");
1689  }
1690  void TUInt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1691    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1692  }
1693  TStr TUInt::GetStr(const uint& Val, const char* FmtStr){
1694    if (FmtStr==NULL){
1695      return GetStr(Val);
1696    } else {
1697      char Bf[255];
1698      sprintf(Bf, FmtStr, Val);
1699      return TStr(Bf);
1700    }
1701  }
1702  bool TUInt::IsIpStr(const TStr& IpStr, uint& Ip, const char& SplitCh) {
1703  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1704      Ip = 0; int Byte = 0;
1705  	if (IpStrV.Len() != 4) { return false; }
1706  	if (!IpStrV[0].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (uint)Byte;
1707  	if (!IpStrV[1].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1708  	if (!IpStrV[2].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1709  	if (!IpStrV[3].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1710  	return true;
1711  }
1712  uint TUInt::GetUIntFromIpStr(const TStr& IpStr, const char& SplitCh) {
1713  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1714      uint Ip = 0; int Byte = 0;
1715  	EAssertR(IpStrV[0].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (uint)Byte;
1716  	EAssertR(IpStrV[1].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1717  	EAssertR(IpStrV[2].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1718  	EAssertR(IpStrV[3].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1719  	return Ip;
1720  }
1721  TStr TUInt::GetStrFromIpUInt(const uint& Ip) {
1722    return TStr::Fmt("%d.%d.%d.%d", ((Ip>>24) & 0xFF),
1723     ((Ip>>16) & 0xFF), ((Ip>>8) & 0xFF), (Ip & 0xFF));
1724  }
1725  bool TUInt::IsIpv6Str(const TStr& IpStr, const char& SplitCh) {
1726  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV, false);
1727  	if (IpStrV.Len() > 8) { return false; }
1728  	int Group = 0;
1729  	for (int IpStrN = 0; IpStrN < IpStrV.Len(); IpStrN++) {
1730  		if (IpStrV[IpStrN].Empty()) { continue; }
1731  		if (IpStrV[IpStrN].IsHexInt(true, 0x0000, 0xFFFF, Group)) { continue; }
1732  		return false; 
1733  	}
1734  	return true;
1735  }
1736  #if defined (GLib_WIN32)
1737  const TUInt64 TUInt64::Mn(uint64(0x0000000000000000i64));
1738  const TUInt64 TUInt64::Mx(uint64(0xFFFFFFFFFFFFFFFFi64));
1739  #elif defined (GLib_BCB)
1740  const TUInt64 TUInt64::Mn(0x0000000000000000i64);
1741  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFi64);
1742  #else
1743  const TUInt64 TUInt64::Mn((uint64)0x0000000000000000LL);
1744  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFLL);
1745  #endif
1746  void TUInt64::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1747    XLoadHd(Nm);
1748    Val=TXmlObjSer::GetInt64Arg(XmlTok, "Val");
1749  }
1750  void TUInt64::SaveXml(TSOut& SOut, const TStr& Nm) const {
1751    XSaveBETagArg(Nm, "Val", TUInt64::GetStr(Val));
1752  }
1753  const double TFlt::Mn=-DBL_MAX;
1754  const double TFlt::Mx=+DBL_MAX;
1755  const double TFlt::NInf=-DBL_MAX;
1756  const double TFlt::PInf=+DBL_MAX;
1757  const double TFlt::Eps=1e-16;
1758  const double TFlt::EpsHalf  =1e-7;
1759  TRnd TFlt::Rnd;
1760  void TFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1761    XLoadHd(Nm);
1762    Val=TXmlObjSer::GetFltArg(XmlTok, "Val");
1763  }
1764  void TFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1765    XSaveBETagArg(Nm, "Val", TFlt::GetStr(Val));
1766  }
1767  TStr TFlt::GetStr(const double& Val, const int& Width, const int& Prec){
1768    char Bf[255];
1769    if ((Width==-1)&&(Prec==-1)){sprintf(Bf, "%g", Val);}
1770    else {sprintf(Bf, "%*.*f", Width, Prec, Val);}
1771    return TStr(Bf);
1772  }
1773  TStr TFlt::GetStr(const double& Val, const char* FmtStr){
1774    if (FmtStr==NULL){
1775      return GetStr(Val);
1776    } else {
1777      char Bf[255];
1778      sprintf(Bf, FmtStr, Val);
1779      return TStr(Bf);
1780    }
1781  }
1782  const sdouble TSFlt::Mn=-FLT_MIN;
1783  const sdouble TSFlt::Mx=+FLT_MAX;
1784  void TSFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1785    XLoadHd(Nm);
1786    Val=sdouble(TXmlObjSer::GetFltArg(XmlTok, "Val"));
1787  }
1788  void TSFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1789    XSaveBETagArg(Nm, "Val", TFlt::GetStr(Val));
1790  }
1791  const ldouble TLFlt::Mn=-LDBL_MAX;
1792  const ldouble TLFlt::Mx=+LDBL_MAX;
1793  void TLFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1794    XLoadHd(Nm);
1795    Val=TXmlObjSer::GetFltArg(XmlTok, "Val");
1796  }
1797  void TLFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1798    XSaveBETagArg(Nm, "Val", TFlt::GetStr(double(Val)));
1799  }
1800  TStr TLFlt::GetStr(const ldouble& Val, const int& Width, const int& Prec){
1801    char Bf[255];
1802    if ((Width==-1)&&(Prec==-1)){sprintf(Bf, "%Lg", Val);}
1803    else {sprintf(Bf, "%*.*Lf", Width, Prec, Val);}
1804    return TStr(Bf);
1805  }
1806  TStr TLFlt::GetStr(const ldouble& Val, const char* FmtStr){
1807    if (FmtStr==NULL){
1808      return GetStr(Val);
1809    } else {
1810      char Bf[255];
1811      sprintf(Bf, FmtStr, Val);
1812      return TStr(Bf);
1813    }
1814  }
1815  void TFltRect::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1816    XLoadHd(Nm);
1817    MnX=TXmlObjSer::GetFltArg(XmlTok, "MnX");
1818    MnY=TXmlObjSer::GetFltArg(XmlTok, "MnY");
1819    MxX=TXmlObjSer::GetFltArg(XmlTok, "MxX");
1820    MxY=TXmlObjSer::GetFltArg(XmlTok, "MxY");
1821  }
1822  void TFltRect::SaveXml(TSOut& SOut, const TStr& Nm) const {
1823    XSaveBETagArg4(Nm,
1824     "MnX", TFlt::GetStr(double(MnX)), "MnY", TFlt::GetStr(double(MnY)),
1825     "MxX", TFlt::GetStr(double(MxX)), "MxY", TFlt::GetStr(double(MxY)));
1826  }
1827  bool TFltRect::Intersection(const TFltRect& Rect1, const TFltRect& Rect2){
1828    const double MnXX = TFlt::GetMx(Rect1.GetMnX(), Rect2.GetMnX());
1829    const double MnYY = TFlt::GetMx(Rect1.GetMnY(), Rect2.GetMnY());
1830    const double MxXX = TFlt::GetMn(Rect1.GetMxX(), Rect2.GetMxX());
1831    const double MxYY = TFlt::GetMn(Rect1.GetMxY(), Rect2.GetMxY());
1832    return (MnXX < MxXX) && (MnYY < MxYY);
1833  }
1834  TStr TFltRect::GetStr() const {
1835    TChA ChA;
1836    ChA+='(';
1837    ChA+=TFlt::GetStr(MnX, "%0.2f"); ChA+=',';
1838    ChA+=TFlt::GetStr(MnY, "%0.2f"); ChA+=',';
1839    ChA+=TFlt::GetStr(MxX, "%0.2f"); ChA+=',';
1840    ChA+=TFlt::GetStr(MxY, "%0.2f"); ChA+=')';
1841    return ChA;
1842  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.cpp</h3>
            <pre><code>1  #include <shlwapi.h>
2  #include "preferenceDlg.h"
3  #include "lesDlgs.h"
4  #include "EncodingMapper.h"
5  #include "localization.h"
6  #define MyGetGValue(rgb)      (LOBYTE((rgb)>>8))
7  using namespace std;
8  const int BLINKRATE_FASTEST = 50;
9  const int BLINKRATE_SLOWEST = 2500;
10  const int BLINKRATE_INTERVAL = 50;
11  const int CARETLINEFRAME_SMALLEST = 1;
12  const int CARETLINEFRAME_LARGEST = 6;
13  const int CARETLINEFRAME_INTERVAL = 1;
14  const int BORDERWIDTH_SMALLEST = 0;
15  const int BORDERWIDTH_LARGEST = 30;
16  const int BORDERWIDTH_INTERVAL = 1;
17  const int PADDING_SMALLEST = 0;
18  const int PADDING_LARGEST = 30;
19  const int PADDING_INTERVAL = 1;
20  const int DISTRACTIONFREE_SMALLEST = 3;
21  const int DISTRACTIONFREE_LARGEST = 9;
22  const int DISTRACTIONFREE_INTERVAL = 1;
23  constexpr int AUTOCOMPLETEFROMCHAR_SMALLEST = 1;
24  constexpr int AUTOCOMPLETEFROMCHAR_LARGEST = 9;
25  constexpr int AUTOCOMPLETEFROMCHAR_INTERVAL = 1;
26  static int encodings[] = {
27  	1250, 
28  	1251, 
29  	1252, 
30  	1253, 
31  	1254, 
32  	1255, 
33  	1256, 
34  	1257, 
35  	1258, 
36  	28591,
37  	28592,
38  	28593,
39  	28594,
40  	28595,
41  	28596,
42  	28597,
43  	28598,
44  	28599,
45  	28603,
46  	28604,
47  	28605,
48  	437,  
49  	720,  
50  	737,  
51  	775,  
52  	850,  
53  	852,  
54  	855,  
55  	857,  
56  	858,  
57  	860,  
58  	861,  
59  	862,  
60  	863,  
61  	865,  
62  	866,  
63  	869,  
64  	950,  
65  	936,  
66  	932,  
67  	949,  
68  	51949,
69  	874,
70  	10007,
71  	21866,
72  	20866
73  };
74  bool PreferenceDlg::goToSection(size_t iPage, intptr_t ctrlID)
75  {
76  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_SETCURSEL, iPage, 0);
77  	showDialogByIndex(iPage);
78  	getFocus();
79  	if (ctrlID != -1)
80  	{
81  		::SetFocus(::GetDlgItem(_wVector[iPage]._dlg->getHSelf(), int(ctrlID)));
82  	}
83  	return true;
84  }
85  intptr_t CALLBACK PreferenceDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
86  {
87  	switch (message) 
88  	{
89  		case WM_INITDIALOG :
90  		{
91  			_generalSubDlg.init(_hInst, _hSelf);
92  			_generalSubDlg.create(IDD_PREFERENCE_SUB_GENRAL, false, false);
93  			_generalSubDlg.display();
94  			_editingSubDlg.init(_hInst, _hSelf);
95  			_editingSubDlg.create(IDD_PREFERENCE_SUB_EDITING, false, false);
96  			_darkModeSubDlg.init(_hInst, _hSelf);
97  			_darkModeSubDlg.create(IDD_PREFERENCE_SUB_DARKMODE, false, false);
98  			_marginsBorderEdgeSubDlg.init(_hInst, _hSelf);
99  			_marginsBorderEdgeSubDlg.create(IDD_PREFERENCE_SUB_MARGING_BORDER_EDGE, false, false);
100  			_miscSubDlg.init(_hInst, _hSelf);
101  			_miscSubDlg.create(IDD_PREFERENCE_SUB_MISC, false, false);
102  			_newDocumentSubDlg.init(_hInst, _hSelf);
103  			_newDocumentSubDlg.create(IDD_PREFERENCE_SUB_NEWDOCUMENT, false, false);
104  			_defaultDirectorySubDlg.init(_hInst, _hSelf);
105  			_defaultDirectorySubDlg.create(IDD_PREFERENCE_SUB_DEFAULTDIRECTORY, false, false);
106  			_recentFilesHistorySubDlg.init(_hInst, _hSelf);
107  			_recentFilesHistorySubDlg.create(IDD_PREFERENCE_SUB_RECENTFILESHISTORY, false, false);
108  			_fileAssocDlg.init(_hInst, _hSelf);
109  			_fileAssocDlg.create(IDD_REGEXT_BOX, false, false);
110  			_printSubDlg.init(_hInst, _hSelf);
111  			_printSubDlg.create(IDD_PREFERENCE_SUB_PRINT, false, false);
112  			_searchingSubDlg.init(_hInst, _hSelf);
113  			_searchingSubDlg.create(IDD_PREFERENCE_SUB_SEARCHING, false, false);
114  			_languageSubDlg.init(_hInst, _hSelf);
115  			_languageSubDlg.create(IDD_PREFERENCE_SUB_LANGUAGE, false, false);
116  			_highlightingSubDlg.init(_hInst, _hSelf);
117  			_highlightingSubDlg.create(IDD_PREFERENCE_SUB_HIGHLIGHTING, false, false);
118  			_backupSubDlg.init(_hInst, _hSelf);
119  			_backupSubDlg.create(IDD_PREFERENCE_SUB_BACKUP, false, false);
120  			_autoCompletionSubDlg.init(_hInst, _hSelf);
121  			_autoCompletionSubDlg.create(IDD_PREFERENCE_SUB_AUTOCOMPLETION, false, false);
122  			_multiInstanceSubDlg.init(_hInst, _hSelf);
123  			_multiInstanceSubDlg.create(IDD_PREFERENCE_SUB_MULTIINSTANCE, false, false);
124  			_delimiterSubDlg.init(_hInst, _hSelf);
125  			_delimiterSubDlg.create(IDD_PREFERENCE_SUB_DELIMITER, false, false);
126  			_performanceSubDlg.init(_hInst, _hSelf);
127  			_performanceSubDlg.create(IDD_PREFERENCE_SUB_PERFORMANCE, false, false);
128  			_cloudAndLinkSubDlg.init(_hInst, _hSelf);
129  			_cloudAndLinkSubDlg.create(IDD_PREFERENCE_SUB_CLOUD_LINK, false, false);
130  			_searchEngineSubDlg.init(_hInst, _hSelf);
131  			_searchEngineSubDlg.create(IDD_PREFERENCE_SUB_SEARCHENGINE, false, false);			
132  			_wVector.push_back(DlgInfo(&_generalSubDlg, TEXT("General"), TEXT("Global")));
133  			_wVector.push_back(DlgInfo(&_editingSubDlg, TEXT("Editing"), TEXT("Scintillas")));
134  			_wVector.push_back(DlgInfo(&_darkModeSubDlg, TEXT("Dark Mode"), TEXT("DarkMode")));
135  			_wVector.push_back(DlgInfo(&_marginsBorderEdgeSubDlg, TEXT("Margins/Border/Edge"), TEXT("MarginsBorderEdge")));
136  			_wVector.push_back(DlgInfo(&_newDocumentSubDlg, TEXT("New Document"), TEXT("NewDoc")));
137  			_wVector.push_back(DlgInfo(&_defaultDirectorySubDlg, TEXT("Default Directory"), TEXT("DefaultDir")));
138  			_wVector.push_back(DlgInfo(&_recentFilesHistorySubDlg, TEXT("Recent Files History"), TEXT("RecentFilesHistory")));
139  			_wVector.push_back(DlgInfo(&_fileAssocDlg, TEXT("File Association"), TEXT("FileAssoc")));
140  			_wVector.push_back(DlgInfo(&_languageSubDlg, TEXT("Language"), TEXT("Language")));
141  			_wVector.push_back(DlgInfo(&_highlightingSubDlg, TEXT("Highlighting"), TEXT("Highlighting")));
142  			_wVector.push_back(DlgInfo(&_printSubDlg, TEXT("Print"), TEXT("Print")));
143  			_wVector.push_back(DlgInfo(&_searchingSubDlg, TEXT("Searching"), TEXT("Searching")));
144  			_wVector.push_back(DlgInfo(&_backupSubDlg, TEXT("Backup"), TEXT("Backup")));
145  			_wVector.push_back(DlgInfo(&_autoCompletionSubDlg, TEXT("Auto-Completion"), TEXT("AutoCompletion")));
146  			_wVector.push_back(DlgInfo(&_multiInstanceSubDlg, TEXT("Multi-Instance & Date"), TEXT("MultiInstance")));
147  			_wVector.push_back(DlgInfo(&_delimiterSubDlg, TEXT("Delimiter"), TEXT("Delimiter")));
148  			_wVector.push_back(DlgInfo(&_performanceSubDlg, TEXT("Performance"), TEXT("Performance")));
149  			_wVector.push_back(DlgInfo(&_cloudAndLinkSubDlg, TEXT("Cloud & Link"), TEXT("Cloud")));
150  			_wVector.push_back(DlgInfo(&_searchEngineSubDlg, TEXT("Search Engine"), TEXT("SearchEngine")));
151  			_wVector.push_back(DlgInfo(&_miscSubDlg, TEXT("MISC."), TEXT("MISC")));
152  			makeCategoryList();
153  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
154  			return TRUE;
155  		}
156  		case WM_CTLCOLORLISTBOX:
157  		{
158  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
159  		}
160  		case WM_CTLCOLORDLG:
161  		case WM_CTLCOLORSTATIC:
162  		{
163  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
164  		}
165  		case WM_PRINTCLIENT:
166  		{
167  			if (NppDarkMode::isEnabled())
168  			{
169  				return TRUE;
170  			}
171  			break;
172  		}
173  		case NPPM_INTERNAL_REFRESHDARKMODE:
174  		{
175  			NppDarkMode::autoThemeChildControls(_hSelf);
176  			if (_editingSubDlg._tip != nullptr)
177  				NppDarkMode::setDarkTooltips(_editingSubDlg._tip, NppDarkMode::ToolTipsType::tooltip);
178  			for (auto& tip : _editingSubDlg._tips)
179  			{
180  				if (tip != nullptr)
181  				{
182  					NppDarkMode::setDarkTooltips(tip, NppDarkMode::ToolTipsType::tooltip);
183  				}
184  			}
185  			if (_delimiterSubDlg._tip != nullptr)
186  				NppDarkMode::setDarkTooltips(_delimiterSubDlg._tip, NppDarkMode::ToolTipsType::tooltip);
187  			if (_performanceSubDlg._largeFileRestrictionTip != nullptr)
188  				NppDarkMode::setDarkTooltips(_performanceSubDlg._largeFileRestrictionTip, NppDarkMode::ToolTipsType::tooltip);
189  			if (NppDarkMode::isEnabled())
190  			{
191  				const NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
192  				::EnableWindow(::GetDlgItem(_highlightingSubDlg.getHSelf(), IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
193  				const bool noBackup = _backupSubDlg.isCheckedOrNot(IDC_RADIO_BKNONE);
194  				::EnableWindow(::GetDlgItem(_backupSubDlg.getHSelf(), IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC), !noBackup);
195  				const bool isEnableAutoC = _autoCompletionSubDlg.isCheckedOrNot(IDD_AUTOC_ENABLECHECK);
196  				::EnableWindow(::GetDlgItem(_autoCompletionSubDlg.getHSelf(), IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
197  			}
198  			return TRUE;
199  		}
200  		case PREF_MSG_SETGUITOOLICONSSET:
201  		{
202  			const HWND generalSubDlg = _generalSubDlg.getHSelf();
203  			auto checkOrUncheckBtn = [&generalSubDlg](int id, WPARAM check = BST_UNCHECKED) -> void
204  			{
205  				::SendDlgItemMessage(generalSubDlg, id, BM_SETCHECK, check, 0);
206  			};
207  			const int iconState = NppDarkMode::getToolBarIconSet(static_cast<bool>(wParam));
208  			NppParameters& nppParams = NppParameters::getInstance();
209  			NppGUI& nppGUI = nppParams.getNppGUI();
210  			if (iconState != -1)
211  			{
212  				nppGUI._toolBarStatus = static_cast<toolBarStatusType>(iconState);
213  			}
214  			else
215  			{
216  				auto state = TB_STANDARD;
217  				if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_SMALLICON))
218  				{
219  					state = TB_SMALL;
220  				}
221  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_BIGICON))
222  				{
223  					state = TB_LARGE;
224  				}
225  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_SMALLICON2))
226  				{
227  					state = TB_SMALL2;
228  				}
229  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_BIGICON2))
230  				{
231  					state = TB_LARGE2;
232  				}
233  				nppGUI._toolBarStatus = state;
234  			}
235  			checkOrUncheckBtn(IDC_RADIO_STANDARD);
236  			checkOrUncheckBtn(IDC_RADIO_SMALLICON);
237  			checkOrUncheckBtn(IDC_RADIO_BIGICON);
238  			checkOrUncheckBtn(IDC_RADIO_SMALLICON2);
239  			checkOrUncheckBtn(IDC_RADIO_BIGICON2);
240  			switch (nppGUI._toolBarStatus)
241  			{
242  				case TB_LARGE:
243  				{
244  					checkOrUncheckBtn(IDC_RADIO_BIGICON, BST_CHECKED);
245  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE, 0);
246  					break;
247  				}
248  				case TB_SMALL2:
249  				{
250  					checkOrUncheckBtn(IDC_RADIO_SMALLICON2, BST_CHECKED);
251  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE_SET2, 0);
252  					break;
253  				}
254  				case TB_LARGE2:
255  				{
256  					checkOrUncheckBtn(IDC_RADIO_BIGICON2, BST_CHECKED);
257  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE_SET2, 0);
258  					break;
259  				}
260  				case TB_STANDARD:
261  				{
262  					checkOrUncheckBtn(IDC_RADIO_STANDARD, BST_CHECKED);
263  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_STANDARD, 0);
264  					break;
265  				}
266  				default:
267  				{
268  					checkOrUncheckBtn(IDC_RADIO_SMALLICON, BST_CHECKED);
269  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE, 0);
270  				}
271  			}
272  			return TRUE;
273  		}
274  		case PREF_MSG_SETGUITABBARICONS:
275  		{
276  			const int tabIconSet = NppDarkMode::getTabIconSet(static_cast<bool>(wParam));
277  			if (tabIconSet != -1)
278  			{
279  				_generalSubDlg.setTabbarAlternateIcons(tabIconSet == 1);
280  			}
281  			return TRUE;
282  		}
283  		case WM_COMMAND :
284  		{
285  			if (LOWORD(wParam) == IDC_LIST_DLGTITLE)
286  			{
287  				if (HIWORD(wParam) == CBN_SELCHANGE)
288  				{
289  					auto i = ::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETCURSEL, 0, 0);
290  					if (i != LB_ERR)
291  					{
292  						showDialogByIndex(i);
293  					}
294  				}
295  			}
296  			else 
297  			{
298  				switch (wParam)
299  				{
300  					case IDC_BUTTON_CLOSE :
301  					case IDCANCEL :
302  						display(false);
303  						return TRUE;
304  					default :
305  						::SendMessage(_hParent, WM_COMMAND, wParam, lParam);
306  						return TRUE;
307  				}
308  			}
309  		}
310  	}
311  	return FALSE;
312  }
313  void PreferenceDlg::makeCategoryList()
314  {
315  	for (size_t i = 0, len = _wVector.size(); i < len; ++i)
316  	{
317  		::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(_wVector[i]._name.c_str()));
318  	}
319  	setListSelection(0);
320  }
321  int32_t PreferenceDlg::getIndexFromName(const TCHAR *name) const
322  {
323  	if (!name)
324  		return -1;
325  	int32_t i = 0;
326  	for (auto it = _wVector.begin() ; it != _wVector.end(); ++it, ++i)
327  	{
328  		if (it->_internalName == name)
329  			return i;
330  	}
331  	return -1;
332  }
333  bool PreferenceDlg::setListSelection(size_t currentSel) const
334  {
335  	const size_t selStrLenMax = 255;
336  	TCHAR selStr[selStrLenMax + 1] = { '\0' };
337  	auto lbTextLen = ::SendMessage(_hSelf, LB_GETTEXTLEN, currentSel, 0);
338  	if (static_cast<size_t>(lbTextLen) > selStrLenMax)
339  		return false;
340  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXT, currentSel, reinterpret_cast<LPARAM>(selStr));
341  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_SELECTSTRING, currentSel, reinterpret_cast<LPARAM>(selStr));
342  	return true;
343  }
344  bool PreferenceDlg::renameDialogTitle(const TCHAR *internalName, const TCHAR *newName)
345  {
346  	bool foundIt = false;
347  	size_t i = 0;
348  	for (size_t len = _wVector.size(); i < len; ++i)
349  	{
350  		if (_wVector[i]._internalName == internalName)
351  		{
352  			foundIt = true;
353  			break;
354  		}
355  	}
356  	if (!foundIt)
357  		return false;
358  	const size_t lenMax = 256;
359  	TCHAR oldName[lenMax] = { '\0' };
360  	size_t txtLen = ::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXTLEN, i, 0);
361  	if (txtLen >= lenMax)
362  		return false;
363  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXT, i, reinterpret_cast<LPARAM>(oldName));
364  	if (lstrcmp(newName, oldName) == 0)
365  		return true;
366  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_DELETESTRING, i, 0);
367  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_INSERTSTRING, i, reinterpret_cast<LPARAM>(newName));
368  	return true;
369  }
370  void PreferenceDlg::showDialogByName(const TCHAR *name) const
371  {
372  	int32_t i = getIndexFromName(name);
373  	if (i >= 0)
374  	{
375  		showDialogByIndex(i);
376  		setListSelection(i);
377  	}
378  }
379  void PreferenceDlg::showDialogByIndex(size_t index) const
380  {
381  	size_t len = _wVector.size();
382  	for (size_t i = 0; i < len; ++i)
383  	{
384  		_wVector[i]._dlg->display(false);
385  	}
386  	_wVector[index]._dlg->display(true);
387  }
388  void PreferenceDlg::destroy()
389  {
390  	_generalSubDlg.destroy();
391  	_editingSubDlg.destroy();
392  	_darkModeSubDlg.destroy();
393  	_marginsBorderEdgeSubDlg.destroy();
394  	_miscSubDlg.destroy();
395  	_fileAssocDlg.destroy();
396  	_languageSubDlg.destroy();
397  	_highlightingSubDlg.destroy();
398  	_printSubDlg.destroy();
399  	_searchingSubDlg.destroy();
400  	_newDocumentSubDlg.destroy();
401  	_defaultDirectorySubDlg.destroy();
402  	_recentFilesHistorySubDlg.destroy();
403  	_backupSubDlg.destroy();
404  	_autoCompletionSubDlg.destroy();
405  	_multiInstanceSubDlg.destroy();
406  	_delimiterSubDlg.destroy();
407  	_performanceSubDlg.destroy();
408  }
409  void GeneralSubDlg::setTabbarAlternateIcons(bool enable)
410  {
411  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
412  	if (!enable)
413  	{
414  		nppGUI._tabStatus &= ~TAB_ALTICONS;
415  		::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, BST_UNCHECKED, 0);
416  	}
417  	else
418  	{
419  		nppGUI._tabStatus |= TAB_ALTICONS;
420  		::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, BST_CHECKED, 0);
421  	}
422  }
423  intptr_t CALLBACK GeneralSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
424  {
425  	NppParameters& nppParam = NppParameters::getInstance();
426  	switch (message) 
427  	{
428  		case WM_INITDIALOG :
429  		{
430  			const NppGUI & nppGUI = nppParam.getNppGUI();
431  			toolBarStatusType tbStatus = nppGUI._toolBarStatus;
432  			int tabBarStatus = nppGUI._tabStatus;
433  			bool showTool = nppGUI._toolbarShow;
434  			bool showStatus = nppGUI._statusBarShow;
435  			bool showMenu = nppGUI._menuBarShow;
436  			bool hideRightShortcutsFromMenu = nppGUI._hideMenuRightShortcuts;
437  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDE, BM_SETCHECK, showTool?BST_UNCHECKED:BST_CHECKED, 0);
438  			int ID2Check = 0;
439  			switch (tbStatus)
440  			{
441  				case TB_SMALL :
442  					ID2Check = IDC_RADIO_SMALLICON;
443  					break;
444  				case TB_LARGE :
445  					ID2Check = IDC_RADIO_BIGICON;
446  					break;
447  				case TB_SMALL2 :
448  					ID2Check = IDC_RADIO_SMALLICON2;
449  					break;
450  				case TB_LARGE2 :
451  					ID2Check = IDC_RADIO_BIGICON2;
452  					break;
453  				case TB_STANDARD:
454  				default :
455  					ID2Check = IDC_RADIO_STANDARD;
456  			}
457  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
458  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REDUCE, BM_SETCHECK, tabBarStatus & TAB_REDUCE, 0);
459  			::SendDlgItemMessage(_hSelf, IDC_CHECK_LOCK, BM_SETCHECK, !(tabBarStatus & TAB_DRAGNDROP), 0);
460  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ORANGE, BM_SETCHECK, tabBarStatus & TAB_DRAWTOPBAR, 0);
461  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DRAWINACTIVE, BM_SETCHECK, tabBarStatus & TAB_DRAWINACTIVETAB, 0);
462  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLETABCLOSE, BM_SETCHECK, tabBarStatus & TAB_CLOSEBUTTON, 0);
463  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DBCLICK2CLOSE, BM_SETCHECK, tabBarStatus & TAB_DBCLK2CLOSE, 0);
464  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_VERTICAL, BM_SETCHECK, tabBarStatus & TAB_VERTICAL, 0);
465  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_MULTILINE, BM_SETCHECK, tabBarStatus & TAB_MULTILINE, 0);
466  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_LAST_EXIT, BM_SETCHECK, tabBarStatus & TAB_QUITONEMPTY, 0);
467  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, tabBarStatus & TAB_ALTICONS, 0);
468  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_HIDE, BM_SETCHECK, tabBarStatus & TAB_HIDE, 0);
469  			::SendMessage(_hSelf, WM_COMMAND, IDC_CHECK_TAB_HIDE, 0);
470  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDESTATUSBAR, BM_SETCHECK, !showStatus, 0);
471  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDEMENUBAR, BM_SETCHECK, !showMenu, 0);
472  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR, BM_SETCHECK, hideRightShortcutsFromMenu, 0);
473  			LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
474  			for (size_t i = 0, len = localizationSwitcher.size(); i < len ; ++i)
475  			{
476  				pair<wstring, wstring> localizationInfo = localizationSwitcher.getElementFromIndex(i);
477  				::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(localizationInfo.first.c_str()));
478  			}
479  			wstring lang = TEXT("English"); 
480  			if (nppParam.getNativeLangA()) 
481  			{
482  				string fn = localizationSwitcher.getFileName();
483  				wstring fnW = s2ws(fn);
484  				lang = localizationSwitcher.getLangFromXmlFileName(fnW.c_str());
485  			}
486  			auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(lang.c_str()));
487  			if (index != CB_ERR)
488                  ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_SETCURSEL, index, 0);
489  			return TRUE;
490  		}
491  		case WM_CTLCOLORLISTBOX:
492  		{
493  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
494  		}
495  		case WM_CTLCOLORDLG:
496  		case WM_CTLCOLORSTATIC:
497  		{
498  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
499  		}
500  		case WM_PRINTCLIENT:
501  		{
502  			if (NppDarkMode::isEnabled())
503  			{
504  				return TRUE;
505  			}
506  			break;
507  		}
508  		case WM_COMMAND:
509  		{
510  			switch (wParam)
511  			{
512  				case IDC_CHECK_HIDESTATUSBAR:
513  				{
514  					const bool isChecked = isCheckedOrNot(IDC_CHECK_HIDESTATUSBAR);
515  					::SendMessage(::GetParent(_hParent), NPPM_HIDESTATUSBAR, 0, isChecked ? TRUE : FALSE);
516  				}
517  				return TRUE;
518  				case IDC_CHECK_HIDEMENUBAR :
519  				{
520  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDEMENUBAR, BM_GETCHECK, 0, 0));
521  					::SendMessage(::GetParent(_hParent), NPPM_HIDEMENU, 0, isChecked?TRUE:FALSE);
522  				}
523  				return TRUE;
524  				case IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR:
525  				{
526  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR, BM_GETCHECK, 0, 0));
527  					NppGUI& nppGUI = nppParam.getNppGUI();
528  					nppGUI._hideMenuRightShortcuts = isChecked;
529  				}
530  				return TRUE;
531  				case IDC_CHECK_TAB_HIDE :
532  				{
533  					bool toBeHidden = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_TAB_HIDE), BM_GETCHECK, 0, 0));
534  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_MULTILINE), !toBeHidden);
535  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_VERTICAL), !toBeHidden);
536  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REDUCE), !toBeHidden);
537  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_LOCK), !toBeHidden);
538  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ORANGE), !toBeHidden);
539  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_DRAWINACTIVE), !toBeHidden);
540  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLETABCLOSE), !toBeHidden);
541  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_DBCLICK2CLOSE), !toBeHidden);
542  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_LAST_EXIT), !toBeHidden);
543  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_ALTICONS), !toBeHidden);
544  					::SendMessage(::GetParent(_hParent), NPPM_HIDETABBAR, 0, toBeHidden);
545  					return TRUE;
546  				}
547  				case  IDC_CHECK_TAB_VERTICAL:
548  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_VERTICAL, 0);
549  					return TRUE;
550  				case IDC_CHECK_TAB_MULTILINE :
551  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_MULTILINE, 0);
552  					return TRUE;
553  				case IDC_CHECK_TAB_LAST_EXIT:
554  				{
555  					NppGUI & nppGUI = nppParam.getNppGUI();
556  					nppGUI._tabStatus ^= TAB_QUITONEMPTY;
557  				}
558  				return TRUE;
559  				case IDC_CHECK_TAB_ALTICONS:
560  				{
561  					NppGUI& nppGUI = nppParam.getNppGUI();
562  					nppGUI._tabStatus ^= TAB_ALTICONS;
563  					const bool isChecked = isCheckedOrNot(IDC_CHECK_TAB_ALTICONS);
564  					const bool isBtnCmd = true;
565  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(isBtnCmd), isChecked ? 1 : (nppGUI._darkmode._isEnabled ? 2 : 0));
566  					NppDarkMode::setTabIconSet(isChecked, NppDarkMode::isEnabled());
567  					return TRUE;
568  				}
<span onclick='openModal()' class='match'>569  				case IDC_CHECK_REDUCE :
570  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REDUCETABBAR, 0);
571  					return TRUE;
572  				case IDC_CHECK_LOCK :
573  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LOCKTABBAR, 0);
574  					return TRUE;
575  				case IDC_CHECK_ORANGE :
576  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_TOPBAR, 0);
577  					return TRUE;
578  				case IDC_CHECK_DRAWINACTIVE :
579  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_INACIVETAB, 0);
580  					return TRUE;
581  				case IDC_CHECK_ENABLETABCLOSE :
582  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN, 0);
583  					return TRUE;
584  				case IDC_CHECK_DBCLICK2CLOSE :
585  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE, 0);
586  					return TRUE;
587  				case IDC_CHECK_HIDE :
</span>588  				{
589  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDE, BM_GETCHECK, 0, 0));
590  					::SendMessage(::GetParent(_hParent), NPPM_HIDETOOLBAR, 0, isChecked?TRUE:FALSE);
591  				}
592  				return TRUE;
593  				case IDC_RADIO_SMALLICON :
594  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE, 0);
595  					NppDarkMode::setToolBarIconSet(0, NppDarkMode::isEnabled());
596  					return TRUE;
597  				case IDC_RADIO_BIGICON :
598  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE, 0);
599  					NppDarkMode::setToolBarIconSet(1, NppDarkMode::isEnabled());
600  					return TRUE;
601  				case IDC_RADIO_SMALLICON2:
602  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE_SET2, 0);
603  					NppDarkMode::setToolBarIconSet(2, NppDarkMode::isEnabled());
604  					return TRUE;
605  				case IDC_RADIO_BIGICON2:
606  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE_SET2, 0);
607  					NppDarkMode::setToolBarIconSet(3, NppDarkMode::isEnabled());
608  					return TRUE;
609  				case IDC_RADIO_STANDARD :
610  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_STANDARD, 0);
611  					NppDarkMode::setToolBarIconSet(4, NppDarkMode::isEnabled());
612  					return TRUE;
613  				default :
614  					switch (HIWORD(wParam))
615  					{
616  						case CBN_SELCHANGE : 
617  						{
618  							switch (LOWORD(wParam))
619  							{
620  								case IDC_COMBO_LOCALIZATION :
621  								{
622  									LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
623  									auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETCURSEL, 0, 0);
624  									TCHAR langName[MAX_PATH] = { '\0' };
625  									auto cbTextLen = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETLBTEXTLEN, index, 0);
626  									if (cbTextLen > MAX_PATH - 1)
627  										return TRUE;
628  									::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(langName));
629  									if (langName[0])
630  									{
631  										if (localizationSwitcher.switchToLang(TEXT("English")))
632  										{
633  											::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RELOADNATIVELANG, 0, 0);
634  										}
635  										if (localizationSwitcher.switchToLang(langName))
636  										{
637  											::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RELOADNATIVELANG, 0, 0);
638  											::InvalidateRect(_hParent, NULL, TRUE);
639  										}
640  									}
641  								}
642  								return TRUE;
643  								default:
644  									break;
645  							}
646  						}
647  					}
648  			}
649  		}
650  	}
651  	return FALSE;
652  }
653  void EditingSubDlg::initScintParam()
654  {
655  	NppParameters& nppParam = NppParameters::getInstance();
656  	ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
657  	int id = 0;
658  	switch (svp._lineWrapMethod)
659  	{
660  		case LINEWRAP_ALIGNED:
661  			id = IDC_RADIO_LWALIGN;
662  			break;
663  		case LINEWRAP_INDENT:
664  			id = IDC_RADIO_LWINDENT;
665  			break;
666  		default : 
667  			id = IDC_RADIO_LWDEF;
668  	}
669  	::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
670  	::SendDlgItemMessage(_hSelf, IDC_CHECK_SMOOTHFONT, BM_SETCHECK, svp._doSmoothFont, 0);
671  	int lineHilite = 0;
672  	switch (svp._currentLineHiliteMode)
673  	{
674  		case LINEHILITE_NONE:
675  			lineHilite = IDC_RADIO_CLM_NONE;
676  			break;
677  		case LINEHILITE_FRAME:
678  			lineHilite = IDC_RADIO_CLM_FRAME;
679  			break;
680  		default : 
681  			lineHilite = IDC_RADIO_CLM_HILITE;
682  	}
683  	::SendDlgItemMessage(_hSelf, lineHilite, BM_SETCHECK, TRUE, 0);
684  	::EnableWindow(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), (svp._currentLineHiliteMode == LINEHILITE_FRAME));
685  	::SendDlgItemMessage(_hSelf, IDC_CHECK_VIRTUALSPACE, BM_SETCHECK, svp._virtualSpace, 0);
686  	::SendDlgItemMessage(_hSelf, IDC_CHECK_SCROLLBEYONDLASTLINE, BM_SETCHECK, svp._scrollBeyondLastLine, 0);
687  	::SendDlgItemMessage(_hSelf, IDC_CHECK_RIGHTCLICKKEEPSSELECTION, BM_SETCHECK, svp._rightClickKeepsSelection, 0);
688  	::SendDlgItemMessage(_hSelf, IDC_CHECK_DISABLEADVANCEDSCROLL, BM_SETCHECK, svp._disableAdvancedScrolling, 0);
689  }
690  void EditingSubDlg::changeLineHiliteMode(bool enableSlider)
691  {
692  	::EnableWindow(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), enableSlider);
693  	redrawDlgItem(IDC_CARETLINEFRAME_WIDTH_STATIC);
694  	redrawDlgItem(IDC_CARETLINEFRAME_WIDTH_DISPLAY);
695  	::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_CURLINE_HILITING, 0);
696  }
697  static WNDPROC oldFunclstToolbarProc = NULL;
698  static LRESULT CALLBACK editNumSpaceProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
699  {
700  	switch (message)
701  	{
702  		case WM_CHAR:
703  		{
704  			if ((wParam != 8 && wParam != 32 && wParam < 48) || wParam > 57)
705  			{
706  				return TRUE;
707  			}
708  		}
709  	}
710  	return oldFunclstToolbarProc(hwnd, message, wParam, lParam);
711  }
712  intptr_t CALLBACK EditingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
713  {
714  	NppParameters& nppParam = NppParameters::getInstance();
715  	NppGUI & nppGUI = nppParam.getNppGUI();
716  	ScintillaViewParams& svp = (ScintillaViewParams&)nppParam.getSVP();
717  	switch (message)
718  	{
719  		case WM_INITDIALOG :
720  		{
721  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("0")));
722  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("1")));
723  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("2")));
724  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("3")));
725  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Block")));
726  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Block After")));
727  			::SendMessage(::GetDlgItem(_hSelf, IDC_WIDTH_COMBO), CB_SETCURSEL, nppGUI._caretWidth, 0);
728  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FOLDINGTOGGLE, BM_SETCHECK, nppGUI._enableFoldCmdToggable, 0);
729  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MULTISELECTION, BM_SETCHECK, nppGUI._enableMultiSelection, 0);
730  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETRANGEMIN, TRUE, BLINKRATE_FASTEST);
731  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETRANGEMAX, TRUE, BLINKRATE_SLOWEST);
732  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETPAGESIZE, 0, BLINKRATE_INTERVAL);
733  			int blinkRate = (nppGUI._caretBlinkRate == 0) ? BLINKRATE_SLOWEST : nppGUI._caretBlinkRate;
734  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETPOS, TRUE, blinkRate);
735  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETRANGEMIN, TRUE, CARETLINEFRAME_SMALLEST);
736  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETRANGEMAX, TRUE, CARETLINEFRAME_LARGEST);
737  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETPAGESIZE, 0, CARETLINEFRAME_INTERVAL);
738  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETPOS, TRUE, svp._currentLineFrameWidth);
739  			::SetDlgItemInt(_hSelf, IDC_CARETLINEFRAME_WIDTH_DISPLAY, svp._currentLineFrameWidth, FALSE);
740  			bool checkDefaultCRLF = true;
741  			bool checkPlainTextCRLF = false;
742  			bool checkWithColorCRLF = false;
743  			if (svp._eolMode == svp.plainText)
744  			{
745  				checkDefaultCRLF = false;
746  				checkPlainTextCRLF = true;
747  				checkWithColorCRLF = false;
748  			}
749  			else if (svp._eolMode == svp.plainTextCustomColor)
750  			{
751  				checkDefaultCRLF = false;
752  				checkPlainTextCRLF = true;
753  				checkWithColorCRLF = true;
754  			}
755  			else if (svp._eolMode == svp.roundedRectangleTextCustomColor)
756  			{
757  				checkDefaultCRLF = true;
758  				checkPlainTextCRLF = false;
759  				checkWithColorCRLF = true;
760  			}
761  			::SendDlgItemMessage(_hSelf, IDC_RADIO_ROUNDCORNER_CRLF, BM_SETCHECK, checkDefaultCRLF, 0);
762  			::SendDlgItemMessage(_hSelf, IDC_RADIO_PLEINTEXT_CRLF, BM_SETCHECK, checkPlainTextCRLF, 0);
763  			::SendDlgItemMessage(_hSelf, IDC_CHECK_WITHCUSTOMCOLOR_CRLF, BM_SETCHECK, checkWithColorCRLF, 0);
764  			NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
765  			generic_string tip2show = pNativeSpeaker->getLocalizedStrFromID("eol-custom-color-tip", TEXT("Go to Style Configurator to change the default EOL custom color (\"EOL custom color\")."));
766  			_tip = CreateToolTip(IDC_BUTTON_LAUNCHSTYLECONF_CRLF, _hSelf, _hInst, const_cast<PTSTR>(tip2show.c_str()), pNativeSpeaker->isRTL());
767  			const bool isNpcModeAbbrv = svp._npcMode == svp.abbreviation;
768  			setChecked(IDC_RADIO_NPC_ABBREVIATION, isNpcModeAbbrv);
769  			setChecked(IDC_RADIO_NPC_CODEPOINT, !isNpcModeAbbrv);
770  			setChecked(IDC_CHECK_NPC_COLOR, svp._npcCustomColor);
771  			setChecked(IDC_CHECK_NPC_INCLUDECCUNIEOL, svp._npcIncludeCcUniEol);
772  			generic_string tipNote2Show = pNativeSpeaker->getLocalizedStrFromID("npcNote-tip",
773  				L"Representation of selected \"non-ASCII\" whitespace and non-printing (control) characters.\n\n"\
774  				L"NOTE:\n"\
775  				L"Using representation will disable character effects on text.\n\n"\
776  				L"For the full list of selected whitespace and non-printing characters check User Manual.\n\n"\
777  				L"Click on this button to open website with User Manual.");
778  			generic_string tipAb2Show = pNativeSpeaker->getLocalizedStrFromID("npcAbbreviation-tip",
779  				L"Abbreviation : name\n"\
780  				L"NBSP : no-break space\n"\
781  				L"ZWSP : zero-width space\n"\
782  				L"ZWNBSP : zero-width no-break space\n\n"\
783  				L"For the full list check User Manual.\n"\
784  				L"Click on \"?\" button on right to open website with User Manual.");
785  			generic_string tipCp2Show = pNativeSpeaker->getLocalizedStrFromID("npcCodepoint-tip",
786  				L"Codepoint : name\n"\
787  				L"U+00A0 : no-break space\n"\
788  				L"U+200B : zero-width space\n"\
789  				L"U+FEFF : zero-width no-break space\n\n"\
790  				L"For the full list check User Manual.\n"\
791  				L"Click on \"?\" button on right to open website with User Manual.");
792  			generic_string tipNpcCol2show = pNativeSpeaker->getLocalizedStrFromID("npcCustomColor-tip",
793  				L"Go to Style Configurator to change the default custom color for selected whitespace and non-printing characters (\"Non-printing characters custom color\").");
794  			generic_string tipNpcInc2show = pNativeSpeaker->getLocalizedStrFromID("npcIncludeCcUniEol-tip",
795  				L"Apply non-printing characters appearance settings to C0, C1 control and Unicode EOL (next line, line separator and paragraph separator) characters.");
796  			_tipNote = CreateToolTip(IDC_BUTTON_NPC_NOTE, _hSelf, _hInst, const_cast<PTSTR>(tipNote2Show.c_str()), pNativeSpeaker->isRTL());
797  			_tipAbb = CreateToolTip(IDC_RADIO_NPC_ABBREVIATION, _hSelf, _hInst, const_cast<PTSTR>(tipAb2Show.c_str()), pNativeSpeaker->isRTL());
798  			_tipCodepoint = CreateToolTip(IDC_RADIO_NPC_CODEPOINT, _hSelf, _hInst, const_cast<PTSTR>(tipCp2Show.c_str()), pNativeSpeaker->isRTL());
799  			_tipNpcColor = CreateToolTip(IDC_BUTTON_NPC_LAUNCHSTYLECONF, _hSelf, _hInst, const_cast<PTSTR>(tipNpcCol2show.c_str()), pNativeSpeaker->isRTL());
800  			_tipNpcInclude = CreateToolTip(IDC_CHECK_NPC_INCLUDECCUNIEOL, _hSelf, _hInst, const_cast<PTSTR>(tipNpcInc2show.c_str()), pNativeSpeaker->isRTL());
801  			_tips.push_back(_tipNote);
802  			_tips.push_back(_tipAbb);
803  			_tips.push_back(_tipCodepoint);
804  			_tips.push_back(_tipNpcColor);
805  			_tips.push_back(_tipNpcInclude);
806  			for (auto& tip : _tips)
807  			{
808  				if (tip != nullptr)
809  				{
810  					::SendMessage(tip, TTM_SETMAXTIPWIDTH, 0, 260);
811  				}
812  			}
813  			if (_tipNote != nullptr)
814  			{
815  				::SendMessage(_tipNote, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((30000), (0)));
816  			}
817  			initScintParam();
818  			return TRUE;
819  		}
820  		case WM_CTLCOLOREDIT:
821  		{
822  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
823  		}
824  		case WM_CTLCOLORLISTBOX:
825  		{
826  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
827  		}
828  		case WM_CTLCOLORDLG:
829  		{
830  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
831  		}
832  		case WM_CTLCOLORSTATIC:
833  		{
834  			int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
835  			if (dlgCtrlID == IDC_CARETLINEFRAME_WIDTH_STATIC || dlgCtrlID == IDC_CARETLINEFRAME_WIDTH_DISPLAY)
836  			{
837  				return NppDarkMode::onCtlColorDarkerBGStaticText(reinterpret_cast<HDC>(wParam), (svp._currentLineHiliteMode == LINEHILITE_FRAME));
838  			}
839  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
840  		}
841  		case WM_PRINTCLIENT:
842  		{
843  			if (NppDarkMode::isEnabled())
844  			{
845  				return TRUE;
846  			}
847  			break;
848  		}
849  		case WM_HSCROLL:
850  		{
851  			HWND hCaretBlinkRateSlider = ::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER);
852  			HWND hCaretLineFrameSlider = ::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER);
853  			if (reinterpret_cast<HWND>(lParam) == hCaretBlinkRateSlider)
854  			{
855  				auto blinkRate = ::SendMessage(hCaretBlinkRateSlider, TBM_GETPOS, 0, 0);
856  				if (blinkRate == BLINKRATE_SLOWEST)
857  					blinkRate = 0;
858  				nppGUI._caretBlinkRate = static_cast<int>(blinkRate);
859  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETCARETBLINKRATE, 0, 0);
860  			}
861  			else if (reinterpret_cast<HWND>(lParam) == hCaretLineFrameSlider)
862  			{
863  				svp._currentLineFrameWidth = static_cast<unsigned char>(::SendMessage(hCaretLineFrameSlider, TBM_GETPOS, 0, 0));
864  				::SetDlgItemInt(_hSelf, IDC_CARETLINEFRAME_WIDTH_DISPLAY, svp._currentLineFrameWidth, FALSE);
865  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CARETLINEFRAME, 0, svp._currentLineFrameWidth);
866  			}
867  			return 0;	
868  		}
869  		case WM_COMMAND : 
870  		{
871  			ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
872  			switch (wParam)
873  			{
874  				case IDC_CHECK_SMOOTHFONT:
875  					svp._doSmoothFont = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_SMOOTHFONT, BM_GETCHECK, 0, 0));
876  					::SendMessage(::GetParent(_hParent), NPPM_SETSMOOTHFONT, 0, svp._doSmoothFont);
877  					return TRUE;
878  				case IDC_RADIO_CLM_NONE:
879  					svp._currentLineHiliteMode = LINEHILITE_NONE;
880  					changeLineHiliteMode(false);
881  					return TRUE;
882  				case IDC_RADIO_CLM_HILITE:
883  					svp._currentLineHiliteMode = LINEHILITE_HILITE;
884  					changeLineHiliteMode(false);
885  					return TRUE;
886  				case IDC_RADIO_CLM_FRAME:
887  					svp._currentLineHiliteMode = LINEHILITE_FRAME;
888  					changeLineHiliteMode(true);
889  					return TRUE;
890  				case IDC_RADIO_ROUNDCORNER_CRLF:
891  				case IDC_RADIO_PLEINTEXT_CRLF:
892  				case IDC_CHECK_WITHCUSTOMCOLOR_CRLF:
893  				{
894  					bool doCustomColor = isCheckedOrNot(IDC_CHECK_WITHCUSTOMCOLOR_CRLF);
895  					if (wParam == IDC_RADIO_ROUNDCORNER_CRLF)
896  					{
897  						svp._eolMode = doCustomColor ? svp.roundedRectangleTextCustomColor : svp.roundedRectangleText;
898  					}
899  					else if (wParam == IDC_RADIO_PLEINTEXT_CRLF)
900  					{
901  						svp._eolMode = doCustomColor ? svp.plainTextCustomColor : svp.plainText;
902  					}
903  					else 
904  					{
905  						if (isCheckedOrNot(IDC_RADIO_ROUNDCORNER_CRLF))
906  						{
907  							svp._eolMode = doCustomColor ? svp.roundedRectangleTextCustomColor : svp.roundedRectangleText;
908  						}
909  						else 
910  						{
911  							svp._eolMode = doCustomColor ? svp.plainTextCustomColor : svp.plainText;
912  						}
913  					}
914  					HWND grandParent = ::GetParent(_hParent);
915  					::SendMessage(grandParent, NPPM_INTERNAL_CRLFFORMCHANGED, 0, 0);
916  					return TRUE;
917  				}
918  				case IDC_BUTTON_LAUNCHSTYLECONF_CRLF:
919  				{
920  					HWND grandParent = ::GetParent(_hParent);
921  					::SendMessage(grandParent, NPPM_INTERNAL_CRLFLAUNCHSTYLECONF, 0, 0);
922  					return TRUE;
923  				}
924  				case IDC_RADIO_NPC_ABBREVIATION:
925  				case IDC_RADIO_NPC_CODEPOINT:
926  				{
927  					if (wParam == IDC_RADIO_NPC_CODEPOINT)
928  					{
929  						svp._npcMode = svp.codepoint;
930  					}
931  					else 
932  					{
933  						svp._npcMode = svp.abbreviation;
934  					}
935  					HWND grandParent = ::GetParent(_hParent);
936  					::SendMessage(grandParent, NPPM_INTERNAL_SETNPC, 0, 0);
937  					return TRUE;
938  				}
939  				case IDC_BUTTON_NPC_NOTE:
940  				{
941  					::ShellExecute(NULL, L"open", L"https:&bsol;&bsol;npp-user-manual.org/docs/views/#show-symbol", NULL, NULL, SW_SHOWNORMAL);
942  					return TRUE;
943  				}
944  				case IDC_CHECK_NPC_COLOR:
945  				{
946  					svp._npcCustomColor = isCheckedOrNot(IDC_CHECK_NPC_COLOR);
947  					HWND grandParent = ::GetParent(_hParent);
948  					::SendMessage(grandParent, NPPM_INTERNAL_NPCFORMCHANGED, 0, 0);
949  					return TRUE;
950  				}
951  				case IDC_BUTTON_NPC_LAUNCHSTYLECONF:
952  				{
953  					HWND grandParent = ::GetParent(_hParent);
954  					::SendMessage(grandParent, NPPM_INTERNAL_NPCLAUNCHSTYLECONF, 0, 0);
955  					return TRUE;
956  				}
957  				case IDC_CHECK_NPC_INCLUDECCUNIEOL:
958  				{
959  					svp._npcIncludeCcUniEol = isCheckedOrNot(IDC_CHECK_NPC_INCLUDECCUNIEOL);
960  					const HWND grandParent = ::GetParent(_hParent);
961  					::SendMessage(grandParent, NPPM_INTERNAL_SETNPC, IDC_CHECK_NPC_INCLUDECCUNIEOL, 0);
962  					return TRUE;
963  				}
964  				case IDC_CHECK_VIRTUALSPACE:
965  					svp._virtualSpace = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_VIRTUALSPACE, BM_GETCHECK, 0, 0));
966  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_VIRTUALSPACE, 0, 0);
967  					return TRUE;
968  				case IDC_CHECK_SCROLLBEYONDLASTLINE:
969  					svp._scrollBeyondLastLine = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_SCROLLBEYONDLASTLINE, BM_GETCHECK, 0, 0));
970  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SCROLLBEYONDLASTLINE, 0, 0);
971  					return TRUE;
972  				case IDC_CHECK_RIGHTCLICKKEEPSSELECTION:
973  					svp._rightClickKeepsSelection = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_RIGHTCLICKKEEPSSELECTION, BM_GETCHECK, 0, 0));
974  					return TRUE;
975  				case IDC_CHECK_DISABLEADVANCEDSCROLL:
976  					svp._disableAdvancedScrolling = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_DISABLEADVANCEDSCROLL, BM_GETCHECK, 0, 0));
977  					return TRUE;
978                  case IDC_CHECK_MULTISELECTION :
979                      nppGUI._enableMultiSelection = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_MULTISELECTION, BM_GETCHECK, 0, 0));
980                      ::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETMULTISELCTION, 0, 0);
981                      return TRUE;
982  				case IDC_CHECK_FOLDINGTOGGLE:
983  					nppGUI._enableFoldCmdToggable = isCheckedOrNot(IDC_CHECK_FOLDINGTOGGLE);
984  					return TRUE;
985  				case IDC_RADIO_LWDEF:
986  					svp._lineWrapMethod = LINEWRAP_DEFAULT;
987  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWDEF, 0);
988  					return TRUE;
989  				case IDC_RADIO_LWALIGN:
990  					svp._lineWrapMethod = LINEWRAP_ALIGNED;
991  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWALIGN, 0);
992  					return TRUE;
993  				case IDC_RADIO_LWINDENT:
994  					svp._lineWrapMethod = LINEWRAP_INDENT;
995  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWINDENT, 0);
996  					return TRUE;
997  				default :
998  					switch (HIWORD(wParam))
999  					{
1000  						case CBN_SELCHANGE : 
1001  						{
1002  							if (LOWORD(wParam) == IDC_WIDTH_COMBO)
1003  							{
1004  								nppGUI._caretWidth = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_GETCURSEL, 0, 0));
1005  								::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETCARETWIDTH, 0, 0);
1006  								return TRUE;
1007  							}
1008  						}
1009  						break;
1010  					}
1011  			}
1012  		}
1013  	}
1014  	return FALSE;
1015  }
1016  void DarkModeSubDlg::enableCustomizedColorCtrls(bool doEnable)
1017  {
1018  	::EnableWindow(_pBackgroundColorPicker->getHSelf(), doEnable);
1019  	::EnableWindow(_pSofterBackgroundColorPicker->getHSelf(), doEnable);
1020  	::EnableWindow(_pHotBackgroundColorPicker->getHSelf(), doEnable);
1021  	::EnableWindow(_pPureBackgroundColorPicker->getHSelf(), doEnable);
1022  	::EnableWindow(_pErrorBackgroundColorPicker->getHSelf(), doEnable);
1023  	::EnableWindow(_pTextColorPicker->getHSelf(), doEnable);
1024  	::EnableWindow(_pDarkerTextColorPicker->getHSelf(), doEnable);
1025  	::EnableWindow(_pDisabledTextColorPicker->getHSelf(), doEnable);
1026  	::EnableWindow(_pEdgeColorPicker->getHSelf(), doEnable);
1027  	::EnableWindow(_pLinkColorPicker->getHSelf(), doEnable);
1028  	::EnableWindow(_pHotEdgeColorPicker->getHSelf(), doEnable);
1029  	::EnableWindow(_pDisabledEdgeColorPicker->getHSelf(), doEnable);
1030  	::EnableWindow(::GetDlgItem(_hSelf, IDD_CUSTOMIZED_RESET_BUTTON), doEnable);
1031  	if (doEnable)
1032  	{
1033  		_pBackgroundColorPicker->setColour(NppDarkMode::getBackgroundColor());
1034  		_pSofterBackgroundColorPicker->setColour(NppDarkMode::getSofterBackgroundColor());
1035  		_pHotBackgroundColorPicker->setColour(NppDarkMode::getHotBackgroundColor());
1036  		_pPureBackgroundColorPicker->setColour(NppDarkMode::getDarkerBackgroundColor());
1037  		_pErrorBackgroundColorPicker->setColour(NppDarkMode::getErrorBackgroundColor());
1038  		_pTextColorPicker->setColour(NppDarkMode::getTextColor());
1039  		_pDarkerTextColorPicker->setColour(NppDarkMode::getDarkerTextColor());
1040  		_pDisabledTextColorPicker->setColour(NppDarkMode::getDisabledTextColor());
1041  		_pEdgeColorPicker->setColour(NppDarkMode::getEdgeColor());
1042  		_pLinkColorPicker->setColour(NppDarkMode::getLinkTextColor());
1043  		_pHotEdgeColorPicker->setColour(NppDarkMode::getHotEdgeColor());
1044  		_pDisabledEdgeColorPicker->setColour(NppDarkMode::getDisabledEdgeColor());
1045  	}
1046  }
1047  void DarkModeSubDlg::move2CtrlLeft(int ctrlID, HWND handle2Move, int handle2MoveWidth, int handle2MoveHeight)
1048  {
1049  	POINT p{};
1050  	RECT rc{};
1051  	::GetWindowRect(::GetDlgItem(_hSelf, ctrlID), &rc);
1052  	NppParameters& nppParam = NppParameters::getInstance();
1053  	if(nppParam.getNativeLangSpeaker()->isRTL())
1054  		p.x = rc.right + nppParam._dpiManager.scaleX(5) + handle2MoveWidth;
1055  	else
1056  		p.x = rc.left - nppParam._dpiManager.scaleX(5) - handle2MoveWidth;
1057  	p.y = rc.top + ((rc.bottom - rc.top) / 2) - handle2MoveHeight / 2;
1058  	::ScreenToClient(_hSelf, &p);
1059  	::MoveWindow(handle2Move, p.x, p.y, handle2MoveWidth, handle2MoveHeight, TRUE);
1060  }
1061  intptr_t CALLBACK DarkModeSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
1062  {
1063  	UNREFERENCED_PARAMETER(lParam);
1064  	NppParameters& nppParam = NppParameters::getInstance();
1065  	NppGUI& nppGUI = nppParam.getNppGUI();
1066  	switch (message)
1067  	{
1068  		case WM_INITDIALOG:
1069  		{
1070  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_FOLLOWWINDOWS), NppDarkMode::isWindows10());
1071  			const int topControlID = NppDarkMode::isWindowsModeEnabled() && NppDarkMode::isWindows10() ? IDC_RADIO_DARKMODE_FOLLOWWINDOWS : NppDarkMode::isEnabled() ? IDC_RADIO_DARKMODE_DARKMODE : IDC_RADIO_DARKMODE_LIGHTMODE;
1072  			::SendDlgItemMessage(_hSelf, topControlID, BM_SETCHECK, BST_CHECKED, 0);
1073  			int id = IDC_RADIO_DARKMODE_BLACK;
1074  			switch (nppGUI._darkmode._colorTone)
1075  			{
1076  				case NppDarkMode::redTone:
1077  					id = IDC_RADIO_DARKMODE_RED;
1078  					break;
1079  				case NppDarkMode::greenTone:
1080  					id = IDC_RADIO_DARKMODE_GREEN;
1081  					break;
1082  				case NppDarkMode::blueTone:
1083  					id = IDC_RADIO_DARKMODE_BLUE;
1084  					break;
1085  				case NppDarkMode::purpleTone:
1086  					id = IDC_RADIO_DARKMODE_PURPLE;
1087  					break;
1088  				case NppDarkMode::cyanTone:
1089  					id = IDC_RADIO_DARKMODE_CYAN;
1090  					break;
1091  				case NppDarkMode::oliveTone:
1092  					id = IDC_RADIO_DARKMODE_OLIVE;
1093  					break;
1094  				case NppDarkMode::customizedTone:
1095  					id = IDC_RADIO_DARKMODE_CUSTOMIZED;
1096  					break;
1097  				case NppDarkMode::blackTone:
1098  				default:
1099  					break;
1100  			}
1101  			::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
1102  			_pBackgroundColorPicker = new ColourPicker;
1103  			_pSofterBackgroundColorPicker = new ColourPicker;
1104  			_pHotBackgroundColorPicker = new ColourPicker;
1105  			_pPureBackgroundColorPicker = new ColourPicker;
1106  			_pErrorBackgroundColorPicker = new ColourPicker;
1107  			_pTextColorPicker = new ColourPicker;
1108  			_pDarkerTextColorPicker = new ColourPicker;
1109  			_pDisabledTextColorPicker = new ColourPicker;
1110  			_pEdgeColorPicker = new ColourPicker;
1111  			_pLinkColorPicker = new ColourPicker;
1112  			_pHotEdgeColorPicker = new ColourPicker;
1113  			_pDisabledEdgeColorPicker = new ColourPicker;
1114  			_pBackgroundColorPicker->init(_hInst, _hSelf);
1115  			_pSofterBackgroundColorPicker->init(_hInst, _hSelf);
1116  			_pHotBackgroundColorPicker->init(_hInst, _hSelf);
1117  			_pPureBackgroundColorPicker->init(_hInst, _hSelf);
1118  			_pErrorBackgroundColorPicker->init(_hInst, _hSelf);
1119  			_pTextColorPicker->init(_hInst, _hSelf);
1120  			_pDarkerTextColorPicker->init(_hInst, _hSelf);
1121  			_pDisabledTextColorPicker->init(_hInst, _hSelf);
1122  			_pEdgeColorPicker->init(_hInst, _hSelf);
1123  			_pLinkColorPicker->init(_hInst, _hSelf);
1124  			_pHotEdgeColorPicker->init(_hInst, _hSelf);
1125  			_pDisabledEdgeColorPicker->init(_hInst, _hSelf);
1126  			int cpDynamicalWidth = NppParameters::getInstance()._dpiManager.scaleX(25);
1127  			int cpDynamicalHeight = NppParameters::getInstance()._dpiManager.scaleY(25);
1128  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR1_STATIC, _pPureBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1129  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR2_STATIC, _pHotBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1130  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR3_STATIC, _pSofterBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1131  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR4_STATIC, _pBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1132  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR5_STATIC, _pErrorBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1133  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR6_STATIC, _pTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1134  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR7_STATIC, _pDarkerTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1135  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR8_STATIC, _pDisabledTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1136  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR9_STATIC, _pEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1137  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR10_STATIC, _pLinkColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1138  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR11_STATIC, _pHotEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1139  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR12_STATIC, _pDisabledEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1140  			_pBackgroundColorPicker->display();
1141  			_pSofterBackgroundColorPicker->display();
1142  			_pHotBackgroundColorPicker->display();
1143  			_pPureBackgroundColorPicker->display();
1144  			_pErrorBackgroundColorPicker->display();
1145  			_pTextColorPicker->display();
1146  			_pDarkerTextColorPicker->display();
1147  			_pDisabledTextColorPicker->display();
1148  			_pEdgeColorPicker->display();
1149  			_pLinkColorPicker->display();
1150  			_pHotEdgeColorPicker->display();
1151  			_pDisabledEdgeColorPicker->display();
1152  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLACK), nppGUI._darkmode._isEnabled);
1153  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_RED), nppGUI._darkmode._isEnabled);
1154  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_GREEN), nppGUI._darkmode._isEnabled);
1155  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLUE), nppGUI._darkmode._isEnabled);
1156  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_PURPLE), nppGUI._darkmode._isEnabled);
1157  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CYAN), nppGUI._darkmode._isEnabled);
1158  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_OLIVE), nppGUI._darkmode._isEnabled);
1159  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CUSTOMIZED), nppGUI._darkmode._isEnabled);
1160  			enableCustomizedColorCtrls(nppGUI._darkmode._isEnabled && id == IDC_RADIO_DARKMODE_CUSTOMIZED);
1161  			return TRUE;
1162  		}
1163  		case WM_CTLCOLORDLG:
1164  		{
1165  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1166  		}
1167  		case WM_CTLCOLORSTATIC:
1168  		{
1169  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
1170  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
1171  			bool isStaticText = (dlgCtrlID == IDD_CUSTOMIZED_COLOR1_STATIC ||
1172  				dlgCtrlID == IDD_CUSTOMIZED_COLOR2_STATIC ||
1173  				dlgCtrlID == IDD_CUSTOMIZED_COLOR3_STATIC ||
1174  				dlgCtrlID == IDD_CUSTOMIZED_COLOR4_STATIC ||
1175  				dlgCtrlID == IDD_CUSTOMIZED_COLOR5_STATIC ||
1176  				dlgCtrlID == IDD_CUSTOMIZED_COLOR6_STATIC ||
1177  				dlgCtrlID == IDD_CUSTOMIZED_COLOR7_STATIC ||
1178  				dlgCtrlID == IDD_CUSTOMIZED_COLOR8_STATIC ||
1179  				dlgCtrlID == IDD_CUSTOMIZED_COLOR9_STATIC ||
1180  				dlgCtrlID == IDD_CUSTOMIZED_COLOR10_STATIC ||
1181  				dlgCtrlID == IDD_CUSTOMIZED_COLOR11_STATIC ||
1182  				dlgCtrlID == IDD_CUSTOMIZED_COLOR12_STATIC);
1183  			if (isStaticText)
1184  			{
1185  				bool isTextEnabled = nppGUI._darkmode._isEnabled && nppGUI._darkmode._colorTone == NppDarkMode::customizedTone;
1186  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
1187  			}
1188  			return NppDarkMode::onCtlColorDarker(hdcStatic);
1189  		}
1190  		case WM_PRINTCLIENT:
1191  		{
1192  			if (NppDarkMode::isEnabled())
1193  			{
1194  				return TRUE;
1195  			}
1196  			break;
1197  		}
1198  		case WM_DESTROY:
1199  		{
1200  			_pBackgroundColorPicker->destroy();
1201  			_pSofterBackgroundColorPicker->destroy();
1202  			_pHotBackgroundColorPicker->destroy();
1203  			_pPureBackgroundColorPicker->destroy();
1204  			_pErrorBackgroundColorPicker->destroy();
1205  			_pTextColorPicker->destroy();
1206  			_pDarkerTextColorPicker->destroy();
1207  			_pDisabledTextColorPicker->destroy();
1208  			_pEdgeColorPicker->destroy();
1209  			_pLinkColorPicker->destroy();
1210  			_pHotEdgeColorPicker->destroy();
1211  			_pDisabledEdgeColorPicker->destroy();
1212  			delete _pBackgroundColorPicker;
1213  			delete _pSofterBackgroundColorPicker;
1214  			delete _pHotBackgroundColorPicker;
1215  			delete _pPureBackgroundColorPicker;
1216  			delete _pErrorBackgroundColorPicker;
1217  			delete _pTextColorPicker;
1218  			delete _pDarkerTextColorPicker;
1219  			delete _pDisabledTextColorPicker;
1220  			delete _pEdgeColorPicker;
1221  			delete _pLinkColorPicker;
1222  			delete _pHotEdgeColorPicker;
1223  			delete _pDisabledEdgeColorPicker;
1224  			return TRUE;
1225  		}
1226  		case WM_COMMAND:
1227  		{
1228  			bool changed = false;
1229  			bool forceRefresh = false;
1230  			bool doEnableCustomizedColorCtrls = false;
1231  			switch (wParam)
1232  			{
1233  				case IDC_RADIO_DARKMODE_FOLLOWWINDOWS:
1234  				{
1235  					NppDarkMode::handleSettingChange(nullptr, 0, true);
1236  				}
1237  				[[fallthrough]];
1238  				case IDC_RADIO_DARKMODE_LIGHTMODE:
1239  				case IDC_RADIO_DARKMODE_DARKMODE:
1240  				{
1241  					const bool isFollowWindows = isCheckedOrNot(IDC_RADIO_DARKMODE_FOLLOWWINDOWS);
1242  					NppDarkMode::setWindowsMode(isFollowWindows);
1243  					const bool enableDarkMode = isCheckedOrNot(IDC_RADIO_DARKMODE_DARKMODE) || (isFollowWindows && NppDarkMode::isExperimentalActive());
1244  					nppGUI._darkmode._isEnabled = enableDarkMode;
1245  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLACK), enableDarkMode);
1246  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_RED), enableDarkMode);
1247  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_GREEN), enableDarkMode);
1248  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLUE), enableDarkMode);
1249  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_PURPLE), enableDarkMode);
1250  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CYAN), enableDarkMode);
1251  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_OLIVE), enableDarkMode);
1252  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CUSTOMIZED), enableDarkMode);
1253  					doEnableCustomizedColorCtrls = enableDarkMode && nppGUI._darkmode._colorTone == NppDarkMode::customizedTone;
1254  					enableCustomizedColorCtrls(doEnableCustomizedColorCtrls);
1255  					::SendMessage(_hParent, PREF_MSG_SETGUITOOLICONSSET, static_cast<WPARAM>(enableDarkMode), 0);
1256  					::SendMessage(_hParent, PREF_MSG_SETGUITABBARICONS, static_cast<WPARAM>(enableDarkMode), 0);
1257  					changed = true;
1258  				}
1259  				break;
1260  				case IDC_RADIO_DARKMODE_BLACK:
1261  				case IDC_RADIO_DARKMODE_RED:
1262  				case IDC_RADIO_DARKMODE_GREEN:
1263  				case IDC_RADIO_DARKMODE_BLUE:
1264  				case IDC_RADIO_DARKMODE_PURPLE:
1265  				case IDC_RADIO_DARKMODE_CYAN:
1266  				case IDC_RADIO_DARKMODE_OLIVE:
1267  				case IDC_RADIO_DARKMODE_CUSTOMIZED:
1268  				case IDD_CUSTOMIZED_RESET_BUTTON:
1269  				{
1270  					if (wParam == IDC_RADIO_DARKMODE_BLACK)
1271  					{
1272  						if (nppGUI._darkmode._colorTone == NppDarkMode::blackTone)
1273  							return TRUE;
1274  						nppGUI._darkmode._colorTone = NppDarkMode::blackTone;
1275  					}
1276  					else if (wParam == IDC_RADIO_DARKMODE_RED)
1277  					{
1278  						if (nppGUI._darkmode._colorTone == NppDarkMode::redTone)
1279  							return TRUE;
1280  						nppGUI._darkmode._colorTone = NppDarkMode::redTone;
1281  					}
1282  					else if (wParam == IDC_RADIO_DARKMODE_GREEN)
1283  					{
1284  						if (nppGUI._darkmode._colorTone == NppDarkMode::greenTone)
1285  							return TRUE;
1286  						nppGUI._darkmode._colorTone = NppDarkMode::greenTone;
1287  					}
1288  					else if (wParam == IDC_RADIO_DARKMODE_BLUE)
1289  					{
1290  						if (nppGUI._darkmode._colorTone == NppDarkMode::blueTone)
1291  							return TRUE;
1292  						nppGUI._darkmode._colorTone = NppDarkMode::blueTone;
1293  					}
1294  					else if (wParam == IDC_RADIO_DARKMODE_PURPLE)
1295  					{
1296  						if (nppGUI._darkmode._colorTone == NppDarkMode::purpleTone)
1297  							return TRUE;
1298  						nppGUI._darkmode._colorTone = NppDarkMode::purpleTone;
1299  					}
1300  					else if (wParam == IDC_RADIO_DARKMODE_CYAN)
1301  					{
1302  						if (nppGUI._darkmode._colorTone == NppDarkMode::cyanTone)
1303  							return TRUE;
1304  						nppGUI._darkmode._colorTone = NppDarkMode::cyanTone;
1305  					}
1306  					else if (wParam == IDC_RADIO_DARKMODE_OLIVE)
1307  					{
1308  						if (nppGUI._darkmode._colorTone == NppDarkMode::oliveTone)
1309  							return TRUE;
1310  						nppGUI._darkmode._colorTone = NppDarkMode::oliveTone;
1311  					}
1312  					else if (wParam == IDC_RADIO_DARKMODE_CUSTOMIZED)
1313  					{
1314  						if (nppGUI._darkmode._colorTone == NppDarkMode::customizedTone)
1315  							return TRUE;
1316  						nppGUI._darkmode._colorTone = NppDarkMode::customizedTone;
1317  						doEnableCustomizedColorCtrls = true;
1318  					}
1319  					else if (wParam == IDD_CUSTOMIZED_RESET_BUTTON)
1320  					{
1321  						nppGUI._darkmode._customColors = NppDarkMode::getDarkModeDefaultColors();
1322  						NppDarkMode::changeCustomTheme(nppGUI._darkmode._customColors);
1323  						doEnableCustomizedColorCtrls = true;
1324  					}
1325  					nppGUI._darkmode._isEnabled = true;
1326  					NppDarkMode::setDarkTone(nppGUI._darkmode._colorTone);
1327  					changed = true;
1328  					forceRefresh = true;
1329  					enableCustomizedColorCtrls(doEnableCustomizedColorCtrls);
1330  				}
1331  				break;
1332  				default:
1333  					switch (HIWORD(wParam))
1334  					{
1335  						case CPN_COLOURPICKED:
1336  						{
1337  							COLORREF c = 0;
1338  							if (reinterpret_cast<HWND>(lParam) == _pBackgroundColorPicker->getHSelf())
1339  							{
1340  								c = _pBackgroundColorPicker->getColour();
1341  								NppDarkMode::setBackgroundColor(c);
1342  								nppGUI._darkmode._customColors.background = c;
1343  							}
1344  							else if (reinterpret_cast<HWND>(lParam) == _pSofterBackgroundColorPicker->getHSelf())
1345  							{
1346  								c = _pSofterBackgroundColorPicker->getColour();
1347  								NppDarkMode::setSofterBackgroundColor(c);
1348  								nppGUI._darkmode._customColors.softerBackground = c;
1349  							}
1350  							else if (reinterpret_cast<HWND>(lParam) == _pHotBackgroundColorPicker->getHSelf())
1351  							{
1352  								c = _pHotBackgroundColorPicker->getColour();
1353  								NppDarkMode::setHotBackgroundColor(c);
1354  								nppGUI._darkmode._customColors.hotBackground = c;
1355  							}
1356  							else if (reinterpret_cast<HWND>(lParam) == _pPureBackgroundColorPicker->getHSelf())
1357  							{
1358  								c = _pPureBackgroundColorPicker->getColour();
1359  								NppDarkMode::setDarkerBackgroundColor(c);
1360  								nppGUI._darkmode._customColors.pureBackground = c;
1361  							}
1362  							else if (reinterpret_cast<HWND>(lParam) == _pErrorBackgroundColorPicker->getHSelf())
1363  							{
1364  								c = _pErrorBackgroundColorPicker->getColour();
1365  								NppDarkMode::setErrorBackgroundColor(c);
1366  								nppGUI._darkmode._customColors.errorBackground = c;
1367  							}
1368  							else if (reinterpret_cast<HWND>(lParam) == _pTextColorPicker->getHSelf())
1369  							{
1370  								c = _pTextColorPicker->getColour();
1371  								NppDarkMode::setTextColor(c);
1372  								nppGUI._darkmode._customColors.text = c;
1373  							}
1374  							else if (reinterpret_cast<HWND>(lParam) == _pDarkerTextColorPicker->getHSelf())
1375  							{
1376  								c = _pDarkerTextColorPicker->getColour();
1377  								NppDarkMode::setDarkerTextColor(c);
1378  								nppGUI._darkmode._customColors.darkerText = c;
1379  							}
1380  							else if (reinterpret_cast<HWND>(lParam) == _pDisabledTextColorPicker->getHSelf())
1381  							{
1382  								c = _pDisabledTextColorPicker->getColour();
1383  								NppDarkMode::setDisabledTextColor(c);
1384  								nppGUI._darkmode._customColors.disabledText = c;
1385  							}
1386  							else if (reinterpret_cast<HWND>(lParam) == _pEdgeColorPicker->getHSelf())
1387  							{
1388  								c = _pEdgeColorPicker->getColour();
1389  								NppDarkMode::setEdgeColor(c);
1390  								nppGUI._darkmode._customColors.edge = c;
1391  							}
1392  							else if (reinterpret_cast<HWND>(lParam) == _pLinkColorPicker->getHSelf())
1393  							{
1394  								c = _pLinkColorPicker->getColour();
1395  								NppDarkMode::setLinkTextColor(c);
1396  								nppGUI._darkmode._customColors.linkText = c;
1397  							}
1398  							else if (reinterpret_cast<HWND>(lParam) == _pHotEdgeColorPicker->getHSelf())
1399  							{
1400  								c = _pHotEdgeColorPicker->getColour();
1401  								NppDarkMode::setHotEdgeColor(c);
1402  								nppGUI._darkmode._customColors.hotEdge = c;
1403  							}
1404  							else if (reinterpret_cast<HWND>(lParam) == _pDisabledEdgeColorPicker->getHSelf())
1405  							{
1406  								c = _pDisabledEdgeColorPicker->getColour();
1407  								NppDarkMode::setDisabledEdgeColor(c);
1408  								nppGUI._darkmode._customColors.disabledEdge = c;
1409  							}
1410  							else
1411  							{
1412  								return FALSE;
1413  							}
1414  							nppGUI._darkmode._isEnabled = true;
1415  							NppDarkMode::setDarkTone(nppGUI._darkmode._colorTone);
1416  							changed = true;
1417  							forceRefresh = true;
1418  							doEnableCustomizedColorCtrls = true;
1419  						}
1420  						break;
1421  						default:
1422  						{
1423  							return FALSE;
1424  						}
1425  					}
1426  			}
1427  			if (changed)
1428  			{
1429  				if (!doEnableCustomizedColorCtrls)
1430  				{
1431  					COLORREF disabledColor = nppGUI._darkmode._isEnabled ? NppDarkMode::getDarkerBackgroundColor() : ::GetSysColor(COLOR_3DFACE);
1432  					_pBackgroundColorPicker->setColour(disabledColor);
1433  					_pSofterBackgroundColorPicker->setColour(disabledColor);
1434  					_pHotBackgroundColorPicker->setColour(disabledColor);
1435  					_pPureBackgroundColorPicker->setColour(disabledColor);
1436  					_pErrorBackgroundColorPicker->setColour(disabledColor);
1437  					_pTextColorPicker->setColour(disabledColor);
1438  					_pDarkerTextColorPicker->setColour(disabledColor);
1439  					_pDisabledTextColorPicker->setColour(disabledColor);
1440  					_pEdgeColorPicker->setColour(disabledColor);
1441  					_pLinkColorPicker->setColour(disabledColor);
1442  					_pHotEdgeColorPicker->setColour(disabledColor);
1443  					_pDisabledEdgeColorPicker->setColour(disabledColor);
1444  				}
1445  				NppDarkMode::refreshDarkMode(_hSelf, forceRefresh);
1446  				getFocus(); 
1447  				return TRUE;
1448  			}
1449  			return FALSE;
1450  		}
1451  	}
1452  	return FALSE;
1453  }
1454  void MarginsBorderEdgeSubDlg::initScintParam()
1455  {
1456  	NppParameters& nppParam = NppParameters::getInstance();
1457  	ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
1458  	::SendDlgItemMessage(_hSelf, IDC_RADIO_BOX, BM_SETCHECK, FALSE, 0);
1459  	::SendDlgItemMessage(_hSelf, IDC_RADIO_CIRCLE, BM_SETCHECK, FALSE, 0);
1460  	::SendDlgItemMessage(_hSelf, IDC_RADIO_ARROW, BM_SETCHECK, FALSE, 0);
1461  	::SendDlgItemMessage(_hSelf, IDC_RADIO_SIMPLE, BM_SETCHECK, FALSE, 0);
1462  	::SendDlgItemMessage(_hSelf, IDC_RADIO_FOLDMARGENONE, BM_SETCHECK, FALSE, 0);
1463  	int id = 0;
1464  	switch (svp._folderStyle)
1465  	{
1466  		case FOLDER_STYLE_NONE:
1467  			id = IDC_RADIO_FOLDMARGENONE;
1468  			break;
1469  		case FOLDER_STYLE_BOX:
1470  			id = IDC_RADIO_BOX;
1471  			break;
1472  		case FOLDER_STYLE_CIRCLE:
1473  			id = IDC_RADIO_CIRCLE;
1474  			break;
1475  		case FOLDER_STYLE_ARROW:
1476  			id = IDC_RADIO_ARROW;
1477  			break;
1478  		default : 
1479  			id = IDC_RADIO_SIMPLE;
1480  	}
1481  	::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
1482  	::SendDlgItemMessage(_hSelf, IDC_CHECK_LINENUMBERMARGE, BM_SETCHECK, svp._lineNumberMarginShow, 0);
1483  	::SendDlgItemMessage(_hSelf, IDC_RADIO_DYNAMIC, BM_SETCHECK, svp._lineNumberMarginDynamicWidth, 0);
1484  	::SendDlgItemMessage(_hSelf, IDC_RADIO_CONSTANT, BM_SETCHECK, !svp._lineNumberMarginDynamicWidth, 0);
1485  	::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DYNAMIC), svp._lineNumberMarginShow);
1486  	::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_CONSTANT), svp._lineNumberMarginShow);
1487  	::SendDlgItemMessage(_hSelf, IDC_CHECK_BOOKMARKMARGE, BM_SETCHECK, svp._bookMarkMarginShow, 0);
1488  	::SendDlgItemMessage(_hSelf, IDC_CHECK_CHANGHISTORYMARGE, BM_SETCHECK, svp._isChangeHistoryEnabled, 0);
1489  	::SendDlgItemMessage(_hSelf, IDC_CHECK_NOEDGE, BM_SETCHECK, !svp._showBorderEdge, 0);
1490  	bool canBeBg = svp._edgeMultiColumnPos.size() == 1;
1491  	if (!canBeBg)
1492  	{
1493  		svp._isEdgeBgMode = false;
1494  		::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, FALSE, 0);
1495  		::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_EDGEBGMODE), FALSE);
1496  	}
1497  	else
1498  	{
1499  		::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, svp._isEdgeBgMode, 0);
1500  	}
1501  	generic_string edgeColumnPosStr;
1502  	for (auto i : svp._edgeMultiColumnPos)
1503  	{
1504  		std::string s = std::to_string(i);
1505  		edgeColumnPosStr += generic_string(s.begin(), s.end());
1506  		edgeColumnPosStr += TEXT(" ");
1507  	}
1508  	::SendDlgItemMessage(_hSelf, IDC_COLUMNPOS_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(edgeColumnPosStr.c_str()));
1509  	oldFunclstToolbarProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(::GetDlgItem(_hSelf, IDC_COLUMNPOS_EDIT), GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(editNumSpaceProc)));
1510  }
1511  intptr_t CALLBACK MarginsBorderEdgeSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
1512  {
1513  	NppParameters& nppParam = NppParameters::getInstance();
1514  	switch (message) 
1515  	{
1516  		case WM_INITDIALOG :
1517  		{
1518  			const ScintillaViewParams & svp = nppParam.getSVP();
1519  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETRANGEMIN, TRUE, BORDERWIDTH_SMALLEST);
1520  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETRANGEMAX, TRUE, BORDERWIDTH_LARGEST);
1521  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETPAGESIZE, 0, BORDERWIDTH_INTERVAL);
1522  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETPOS, TRUE, svp._borderWidth);
1523  			::SetDlgItemInt(_hSelf, IDC_BORDERWIDTHVAL_STATIC, svp._borderWidth, FALSE);
1524  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETRANGEMIN, TRUE, PADDING_SMALLEST);
1525  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETRANGEMAX, TRUE, PADDING_LARGEST);
1526  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETPAGESIZE, 0, PADDING_INTERVAL);
1527  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETPOS, TRUE, svp._paddingLeft);
1528  			::SetDlgItemInt(_hSelf, IDC_PADDINGLEFTVAL_STATIC, svp._paddingLeft, FALSE);
1529  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETRANGEMIN, TRUE, PADDING_SMALLEST);
1530  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETRANGEMAX, TRUE, PADDING_LARGEST);
1531  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETPAGESIZE, 0, PADDING_INTERVAL);
1532  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETPOS, TRUE, svp._paddingRight);
1533  			::SetDlgItemInt(_hSelf, IDC_PADDINGRIGHTVAL_STATIC, svp._paddingRight, FALSE);
1534  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETRANGEMIN, TRUE, DISTRACTIONFREE_SMALLEST);
1535  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETRANGEMAX, TRUE, DISTRACTIONFREE_LARGEST);
1536  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETPAGESIZE, 0, DISTRACTIONFREE_INTERVAL);
1537  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETPOS, TRUE, svp._distractionFreeDivPart);
1538  			::SetDlgItemInt(_hSelf, IDC_DISTRACTIONFREEVAL_STATIC, svp._distractionFreeDivPart, FALSE);
1539  			initScintParam();
1540  			return TRUE;
1541  		}
1542  		case WM_CTLCOLOREDIT:
1543  		{
1544  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1545  		}
1546  		case WM_CTLCOLORDLG:
1547  		case WM_CTLCOLORSTATIC:
1548  		{
1549  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1550  		}
1551  		case WM_PRINTCLIENT:
1552  		{
1553  			if (NppDarkMode::isEnabled())
1554  			{
1555  				return TRUE;
1556  			}
1557  			break;
1558  		}
1559  		case WM_HSCROLL:
1560  		{
1561  			ScintillaViewParams & svp = (ScintillaViewParams &)nppParam.getSVP();
1562  			HWND hBorderWidthSlider = ::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER);
1563  			HWND hPaddingLeftSlider = ::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER);
1564  			HWND hPaddingRightSlider = ::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER);
1565  			HWND hDistractionFreeSlider = ::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER);
1566  			if (reinterpret_cast<HWND>(lParam) == hBorderWidthSlider)
1567  			{
1568  				auto borderWidth = ::SendMessage(hBorderWidthSlider, TBM_GETPOS, 0, 0);
1569  				svp._borderWidth = static_cast<int>(borderWidth);
1570  				::SetDlgItemInt(_hSelf, IDC_BORDERWIDTHVAL_STATIC, static_cast<UINT>(borderWidth), FALSE);
1571  				::SendMessage(::GetParent(_hParent), WM_SIZE, 0, 0);
1572  			}
1573  			else if (reinterpret_cast<HWND>(lParam) == hPaddingLeftSlider)
1574  			{
1575  				svp._paddingLeft = static_cast<unsigned char>(::SendMessage(hPaddingLeftSlider, TBM_GETPOS, 0, 0));
1576  				::SetDlgItemInt(_hSelf, IDC_PADDINGLEFTVAL_STATIC, static_cast<UINT>(svp._paddingLeft), FALSE);
1577  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1578  			}
1579  			else if (reinterpret_cast<HWND>(lParam) == hPaddingRightSlider)
1580  			{
1581  				svp._paddingRight = static_cast<unsigned char>(::SendMessage(hPaddingRightSlider, TBM_GETPOS, 0, 0));
1582  				::SetDlgItemInt(_hSelf, IDC_PADDINGRIGHTVAL_STATIC, static_cast<UINT>(svp._paddingRight), FALSE);
1583  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1584  			}
1585  			else if (reinterpret_cast<HWND>(lParam) == hDistractionFreeSlider)
1586  			{
1587  				svp._distractionFreeDivPart = static_cast<unsigned char>(::SendMessage(hDistractionFreeSlider, TBM_GETPOS, 0, 0));
1588  				::SetDlgItemInt(_hSelf, IDC_DISTRACTIONFREEVAL_STATIC, static_cast<UINT>(svp._distractionFreeDivPart), FALSE);
1589  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1590  			}
1591  			return 0;	
1592  		}
1593  		case WM_COMMAND : 
1594  		{
1595  			ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
1596  			switch (wParam)
1597  			{
1598  				case IDC_CHECK_LINENUMBERMARGE:
1599  					svp._lineNumberMarginShow = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_LINENUMBERMARGE, BM_GETCHECK, 0, 0));
1600  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DYNAMIC), svp._lineNumberMarginShow);
1601  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_CONSTANT), svp._lineNumberMarginShow);
1602  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1603  					return TRUE;
1604  				case IDC_RADIO_DYNAMIC:
1605  					svp._lineNumberMarginDynamicWidth = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_DYNAMIC, BM_GETCHECK, 0, 0));
1606  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1607  					return TRUE;
1608  				case IDC_RADIO_CONSTANT:
1609  					svp._lineNumberMarginDynamicWidth = !(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_CONSTANT, BM_GETCHECK, 0, 0));
1610  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1611  					return TRUE;
1612  				case IDC_CHECK_BOOKMARKMARGE:
1613  					svp._bookMarkMarginShow = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_BOOKMARKMARGE, BM_GETCHECK, 0, 0));
1614  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_SYMBOLMARGIN, 0);
1615  					return TRUE;
1616  				case IDC_CHECK_CHANGHISTORYMARGE:
1617  				{
1618  					bool isChangeHistoryEnabled = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_CHANGHISTORYMARGE, BM_GETCHECK, 0, 0));
1619  					if (isChangeHistoryEnabled)
1620  					{
1621  						NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1622  						pNativeSpeaker->messageBox("ChangeHistoryEnabledWarning",
1623  							_hSelf,
1624  							TEXT("You have to restart Notepad++ to enable Change History."),
1625  							TEXT("Notepad++ need to be relaunched"),
1626  							MB_OK | MB_APPLMODAL);
1627  						svp._isChangeHistoryEnabled4NextSession = true;
1628  					}
1629  					else
1630  					{
1631  						svp._isChangeHistoryEnabled = false;
1632  						svp._isChangeHistoryEnabled4NextSession = false;
1633  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_ENABLECHANGEHISTORY, 0, 0);
1634  					}
1635  					return TRUE;
1636  				}
1637  				case IDC_CHECK_NOEDGE:
1638  					svp._showBorderEdge = !(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_NOEDGE, BM_GETCHECK, 0, 0));
1639  					::SendMessage(::GetParent(_hParent), NPPM_SETEDITORBORDEREDGE, 0, svp._showBorderEdge ? TRUE : FALSE);
1640  					return TRUE;
1641  				case IDC_RADIO_SIMPLE:
1642  					svp._folderStyle = FOLDER_STYLE_SIMPLE;
1643  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_SIMPLE, 0);
1644  					return TRUE;
1645  				case IDC_RADIO_ARROW:
1646  					svp._folderStyle = FOLDER_STYLE_ARROW;
1647  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_ARROW, 0);
1648  					return TRUE;
1649  				case IDC_RADIO_CIRCLE:
1650  					svp._folderStyle = FOLDER_STYLE_CIRCLE;
1651  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_CIRCLE, 0);
1652  					return TRUE;
1653  				case IDC_RADIO_BOX:
1654  					svp._folderStyle = FOLDER_STYLE_BOX;
1655  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_BOX, 0);
1656  					return TRUE;
1657  				case IDC_RADIO_FOLDMARGENONE:
1658  					svp._folderStyle = FOLDER_STYLE_NONE;
1659  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN, 0);
1660  					return TRUE;
1661  				case IDC_CHECK_EDGEBGMODE:
1662  					svp._isEdgeBgMode = isCheckedOrNot(IDC_CHECK_EDGEBGMODE);
1663  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
1664  					return TRUE;
1665  				default :
1666  					switch (HIWORD(wParam))
1667  					{
1668  						case EN_CHANGE :
1669  						{
1670  							if (LOWORD(wParam) == IDC_COLUMNPOS_EDIT)
1671  							{
1672  								TCHAR text[MAX_PATH] = {'\0'};
1673  								::SendDlgItemMessage(_hSelf, IDC_COLUMNPOS_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text));
1674  								if (str2numberVector(text, svp._edgeMultiColumnPos))
1675  								{
1676  									bool canBeBg = svp._edgeMultiColumnPos.size() == 1;
1677  									if (!canBeBg)
1678  									{
1679  										svp._isEdgeBgMode = false;
1680  										::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, FALSE, 0);
1681  									}
1682  									::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_EDGEBGMODE), canBeBg);
1683  									::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
1684  									return TRUE;
1685  								}
1686  							}
1687  						}
1688  						break;
1689  					}
1690  			}
1691  		}
1692  	}
1693  	return FALSE;
1694  }
1695  const size_t fileUpdateChoiceEnable = 0;
1696  const size_t fileUpdateChoiceEnable4All = 1;
1697  const size_t fileUpdateChoiceDisable = 2;
1698  intptr_t CALLBACK MiscSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
1699  {
1700  	NppParameters& nppParam = NppParameters::getInstance();
1701  	NppGUI & nppGUI = nppParam.getNppGUI();
1702  	switch (message) 
1703  	{
1704  		case WM_INITDIALOG :
1705  		{
1706  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Enable")));
1707  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Enable for all opened files")));
1708  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Disable")));
1709  			int selIndex = -1;
1710  			if (nppGUI._fileAutoDetection & cdEnabledOld)
1711  			{
1712  				selIndex = fileUpdateChoiceEnable4All;
1713  			}
1714  			else if (nppGUI._fileAutoDetection & cdEnabledNew)
1715  			{				
1716  				selIndex = fileUpdateChoiceEnable;
1717  			}
1718  			else 
1719  			{
1720  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1721  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1722  				selIndex = fileUpdateChoiceDisable;
1723  			}
1724  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_SETCURSEL, selIndex, 0);
1725  			bool bCheck = (nppGUI._fileAutoDetection & cdAutoUpdate) ? true : false;
1726  			::SendDlgItemMessage(_hSelf, IDC_CHECK_UPDATESILENTLY, BM_SETCHECK, bCheck? BST_CHECKED: BST_UNCHECKED, 0);
1727  			bCheck = (nppGUI._fileAutoDetection & cdGo2end) ? true : false;
1728  			::SendDlgItemMessage(_hSelf, IDC_CHECK_UPDATEGOTOEOF, BM_SETCHECK, bCheck ? BST_CHECKED : BST_UNCHECKED, 0);
1729  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MIN2SYSTRAY, BM_SETCHECK, nppGUI._isMinimizedToTray, 0);
1730  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DETECTENCODING, BM_SETCHECK, nppGUI._detectEncoding, 0);
1731  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SAVEALLCONFIRM, BM_SETCHECK, nppGUI._saveAllConfirm, 0);
1732  			::SendDlgItemMessage(_hSelf, IDC_CHECK_AUTOUPDATE, BM_SETCHECK, nppGUI._autoUpdateOpt._doAutoUpdate, 0);
1733  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DIRECTWRITE_ENABLE, BM_SETCHECK, nppGUI._writeTechnologyEngine == directWriteTechnology, 0);
1734  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCPEEKER, BM_SETCHECK, nppGUI._isDocPeekOnTab ? BST_CHECKED : BST_UNCHECKED, 0);
1735  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCPEEKONMAP, BM_SETCHECK, nppGUI._isDocPeekOnMap ? BST_CHECKED : BST_UNCHECKED, 0);
1736  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MUTE_SOUNDS, BM_SETCHECK, nppGUI._muteSounds ? BST_CHECKED : BST_UNCHECKED, 0);
1737  			::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_AUTOUPDATE), nppGUI._doesExistUpdater?SW_SHOW:SW_HIDE);
1738  			::SendDlgItemMessage(_hSelf, IDC_EDIT_SESSIONFILEEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._definedSessionExt.c_str()));
1739  			::SendDlgItemMessage(_hSelf, IDC_EDIT_WORKSPACEFILEEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._definedWorkspaceExt.c_str()));
1740  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCSWITCHER, BM_SETCHECK, nppGUI._doTaskList, 0);
1741  			::SendDlgItemMessage(_hSelf, IDC_CHECK_STYLEMRU, BM_SETCHECK, nppGUI._styleMRU, 0);
1742  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SHORTTITLE, BM_SETCHECK, nppGUI._shortTitlebar, 0);
1743  			return TRUE;
1744  		}
1745  		case WM_CTLCOLOREDIT:
1746  		{
1747  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1748  		}
1749  		case WM_CTLCOLORLISTBOX:
1750  		{
1751  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
1752  		}
1753  		case WM_CTLCOLORDLG:
1754  		case WM_CTLCOLORSTATIC:
1755  		{
1756  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1757  		}
1758  		case WM_PRINTCLIENT:
1759  		{
1760  			if (NppDarkMode::isEnabled())
1761  			{
1762  				return TRUE;
1763  			}
1764  			break;
1765  		}
1766  		case WM_COMMAND : 
1767  		{
1768  			if (HIWORD(wParam) == EN_CHANGE)
1769  			{
1770  				switch (LOWORD(wParam))
1771  				{
1772  					case  IDC_EDIT_SESSIONFILEEXT:
1773  					{
1774  						TCHAR sessionExt[MAX_PATH] = { '\0' };
1775  						::SendDlgItemMessage(_hSelf, IDC_EDIT_SESSIONFILEEXT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(sessionExt));
1776  						nppGUI._definedSessionExt = sessionExt;
1777  						return TRUE;
1778  					}
1779  					case  IDC_EDIT_WORKSPACEFILEEXT:
1780  					{
1781  						TCHAR workspaceExt[MAX_PATH] = { '\0' };
1782  						::SendDlgItemMessage(_hSelf, IDC_EDIT_WORKSPACEFILEEXT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(workspaceExt));
1783  						nppGUI._definedWorkspaceExt = workspaceExt;
1784  						return TRUE;
1785  					}
1786  				}
1787  			}
1788  			switch (wParam)
1789  			{
1790  				case IDC_CHECK_UPDATESILENTLY:
1791  				case IDC_CHECK_UPDATEGOTOEOF:
1792  				{
1793  					bool isSilent = isCheckedOrNot(IDC_CHECK_UPDATESILENTLY);
1794  					bool isGo2End = isCheckedOrNot(IDC_CHECK_UPDATEGOTOEOF);
1795  					auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_GETCURSEL, 0, 0);
1796  					int cd = cdDisabled;
1797  					if (index == fileUpdateChoiceEnable || index == fileUpdateChoiceEnable4All)
1798  					{
1799  						if (index == fileUpdateChoiceEnable4All)
1800  							cd |= cdEnabledOld;
1801  						else
1802  							cd |= cdEnabledNew;
1803  						if (isSilent)
1804  							cd |= cdAutoUpdate;
1805  						if (isGo2End)
1806  							cd |= cdGo2end;
1807  					}
1808  					nppGUI._fileAutoDetection = cd;
1809  				}
1810  				return TRUE;
1811  				case IDC_CHECK_AUTOUPDATE:
1812  					nppGUI._autoUpdateOpt._doAutoUpdate = isCheckedOrNot(static_cast<int32_t>(wParam));
1813  					return TRUE;
1814  				case IDC_CHECK_MIN2SYSTRAY:
1815  					nppGUI._isMinimizedToTray = isCheckedOrNot(static_cast<int32_t>(wParam));
1816  					return TRUE;
1817  				case IDC_CHECK_DETECTENCODING:
1818  					nppGUI._detectEncoding = isCheckedOrNot(static_cast<int32_t>(wParam));
1819  					return TRUE;
1820  				case IDC_CHECK_ENABLEDOCSWITCHER :
1821  				{
1822  					nppGUI._doTaskList = !nppGUI._doTaskList;
1823  					if (nppGUI._doTaskList)
1824  					{
1825  						::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_STYLEMRU), TRUE);
1826  					}
1827  					else
1828  					{
1829  						nppGUI._styleMRU = false;
1830  						::SendDlgItemMessage(_hSelf, IDC_CHECK_STYLEMRU, BM_SETCHECK, false, 0);
1831  						::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_STYLEMRU), FALSE);
1832  					}
1833  					return TRUE;
1834  				}
1835  				case IDC_CHECK_STYLEMRU :
1836  				{
1837  					nppGUI._styleMRU = isCheckedOrNot(IDC_CHECK_STYLEMRU);
1838  					return TRUE;
1839  				}
1840  				case IDC_CHECK_SHORTTITLE:
1841  				{
1842  					nppGUI._shortTitlebar = isCheckedOrNot(IDC_CHECK_SHORTTITLE);
1843  					HWND grandParent = ::GetParent(_hParent);
1844  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATETITLEBAR, 0, 0);
1845  					return TRUE;
1846  				}
1847  				case IDC_CHECK_DIRECTWRITE_ENABLE:
1848  				{
1849  					nppGUI._writeTechnologyEngine = isCheckedOrNot(IDC_CHECK_DIRECTWRITE_ENABLE) ? directWriteTechnology : defaultTechnology;
1850  					return TRUE;
1851  				}
1852  				case IDC_CHECK_ENABLEDOCPEEKER:
1853  				{
1854  					nppGUI._isDocPeekOnTab = isCheckedOrNot(IDC_CHECK_ENABLEDOCPEEKER);
1855  					return TRUE;
1856  				}
1857  				case IDC_CHECK_ENABLEDOCPEEKONMAP:
1858  				{
1859  					nppGUI._isDocPeekOnMap = isCheckedOrNot(IDC_CHECK_ENABLEDOCPEEKONMAP);
1860  					return TRUE;
1861  				}
1862  				case IDC_CHECK_MUTE_SOUNDS:
1863  				{
1864  					nppGUI._muteSounds = isCheckedOrNot(IDC_CHECK_MUTE_SOUNDS);
1865  					return TRUE;
1866  				}
1867  				case IDC_CHECK_SAVEALLCONFIRM:
1868  				{
1869  					nppGUI._saveAllConfirm = isCheckedOrNot(IDC_CHECK_SAVEALLCONFIRM);
1870  					return TRUE;
1871  				}
1872  				default:
1873  				{
1874  					if (HIWORD(wParam) == CBN_SELCHANGE)
1875  					{
1876  						if (LOWORD(wParam) == IDC_COMBO_FILEUPDATECHOICE)
1877  						{
1878  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_GETCURSEL, 0, 0);
1879  							if (index == fileUpdateChoiceEnable || index == fileUpdateChoiceEnable4All)
1880  							{
1881  								bool isSilent = isCheckedOrNot(IDC_CHECK_UPDATESILENTLY);
1882  								bool isGo2End = isCheckedOrNot(IDC_CHECK_UPDATEGOTOEOF);
1883  								int cd = cdDisabled;
1884  								if (index == fileUpdateChoiceEnable4All)
1885  									cd |= cdEnabledOld;
1886  								else
1887  									cd |= cdEnabledNew;
1888  								if (isSilent)
1889  									cd |= cdAutoUpdate;
1890  								if (isGo2End)
1891  									cd |= cdGo2end;
1892  								nppGUI._fileAutoDetection = cd;
1893  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), TRUE);
1894  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), TRUE);
1895  							}
1896  							else if (index == fileUpdateChoiceDisable)
1897  							{
1898  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1899  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1900  								nppGUI._fileAutoDetection = cdDisabled;
1901  							}
1902  							return TRUE;
1903  						}
1904  					}
1905  				}
1906  			}
1907  		}
1908  	}
1909  	return FALSE;
1910  }
1911  intptr_t CALLBACK NewDocumentSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
1912  {
1913  	NppParameters& nppParam = NppParameters::getInstance();
1914  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
1915  	NewDocDefaultSettings & ndds = (NewDocDefaultSettings &)nppGUI.getNewDocDefaultSettings();
1916  	switch (message)
1917  	{
1918  		case WM_INITDIALOG:
1919  		{
1920  			int ID2Check = IDC_RADIO_F_WIN;
1921  			switch (ndds._format)
1922  			{
1923  				case EolType::windows:
1924  					ID2Check = IDC_RADIO_F_WIN;
1925  					break;
1926  				case EolType::macos:
1927  					ID2Check = IDC_RADIO_F_MAC;
1928  					break;
1929  				case EolType::unix:
1930  					ID2Check = IDC_RADIO_F_UNIX;
1931  					break;
1932  				case EolType::unknown:
1933  					assert(false);
1934  					break;
1935  			}
1936  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
1937  			switch (ndds._unicodeMode)
1938  			{
1939  				case uni16BE :
1940  					ID2Check = IDC_RADIO_UTF16BIG;
1941  					break;
1942  				case uni16LE :
1943  					ID2Check = IDC_RADIO_UTF16SMALL;
1944  					break;
1945  				case uniUTF8 :
1946  					ID2Check = IDC_RADIO_UTF8;
1947  					break;
1948  				case uniCookie :
1949  					ID2Check = IDC_RADIO_UTF8SANSBOM;
1950  					break;
1951  				default : 
1952  					ID2Check = IDC_RADIO_ANSI;
1953  			}
1954  			int selIndex = -1;
1955  			generic_string str;
1956  			EncodingMapper& em = EncodingMapper::getInstance();
1957  			for (size_t i = 0, encodingArraySize = sizeof(encodings)/sizeof(int) ; i < encodingArraySize ; ++i)
1958  			{
1959  				int cmdID = em.getIndexFromEncoding(encodings[i]);
1960  				if (cmdID != -1)
1961  				{
1962  					cmdID += IDM_FORMAT_ENCODE;
1963  					getNameStrFromCmd(cmdID, str);
1964  					int index = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str())));
1965  					if (ndds._codepage == encodings[i])
1966  						selIndex = index;
1967  					::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_SETITEMDATA, index, encodings[i]);
1968  				}
1969  			}
1970  			if (ndds._codepage == -1 || selIndex == -1)
1971  			{
1972  				::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
1973  			}
1974  			else
1975  			{
1976  				ID2Check = IDC_RADIO_OTHERCP;
1977  				::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_SETCURSEL, selIndex, 0);
1978  			}
1979  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
1980  			::SendDlgItemMessage(_hSelf, IDC_CHECK_OPENANSIASUTF8, BM_SETCHECK, (ID2Check == IDC_RADIO_UTF8SANSBOM && ndds._openAnsiAsUtf8)?BST_CHECKED:BST_UNCHECKED, 0);
1981  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), ID2Check == IDC_RADIO_UTF8SANSBOM);
1982  			for (int i = L_TEXT + 1 ; i < nppParam.L_END ; ++i) 
1983  			{
1984  				LangType lt = static_cast<LangType>(i);
1985  				str.clear();
1986  				if (lt != L_USER && lt != L_JS)
1987  				{
1988  					int cmdID = nppParam.langTypeToCommandID(lt);
1989  					if ((cmdID != -1))
1990  					{
1991  						getNameStrFromCmd(cmdID, str);
1992  						if (str.length() > 0)
1993  						{
1994  							size_t index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
1995  							::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_SETITEMDATA, index, lt);
1996  						}
1997  					}
1998  				}
1999  			}
2000  			int normalTextCmdID = nppParam.langTypeToCommandID(L_TEXT);
2001  			getNameStrFromCmd(normalTextCmdID, str);
2002  			::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
2003  			LangType l = L_TEXT;
2004  			size_t cbCount = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETCOUNT, 0, 0);
2005  			size_t j = 0;
2006  			for (; j < cbCount; ++j)
2007  			{
2008  				l = static_cast<LangType>(::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETITEMDATA, j, 0));
2009  				if (ndds._lang == l)
2010  					break;
2011  			}
2012  			::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_SETCURSEL, j, 0);
2013  			return TRUE;
2014  		}
2015  		case WM_CTLCOLORLISTBOX:
2016  		{
2017  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
2018  		}
2019  		case WM_CTLCOLORDLG:
2020  		case WM_CTLCOLORSTATIC:
2021  		{
2022  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2023  		}
2024  		case WM_PRINTCLIENT:
2025  		{
2026  			if (NppDarkMode::isEnabled())
2027  			{
2028  				return TRUE;
2029  			}
2030  			break;
2031  		}
2032  		case WM_COMMAND:
2033  			switch (wParam)
2034  			{
2035  				case IDC_RADIO_UTF16BIG:
2036  					ndds._unicodeMode = uni16BE;
2037  					ndds._openAnsiAsUtf8 = false;
2038  					makeOpenAnsiAsUtf8(false);
2039  					ndds._codepage = -1;
2040  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2041  					return TRUE;
2042  				case IDC_RADIO_UTF16SMALL:
2043  					ndds._unicodeMode = uni16LE;
2044  					ndds._openAnsiAsUtf8 = false;
2045  					makeOpenAnsiAsUtf8(false);
2046  					ndds._codepage = -1;
2047  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2048  					return TRUE;
2049  				case IDC_RADIO_UTF8:
2050  					ndds._unicodeMode = uniUTF8;
2051  					ndds._openAnsiAsUtf8 = false;
2052  					makeOpenAnsiAsUtf8(false);
2053  					ndds._codepage = -1;
2054  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2055  					return TRUE;
2056  				case IDC_RADIO_UTF8SANSBOM:
2057  					ndds._unicodeMode = uniCookie;
2058  					makeOpenAnsiAsUtf8(true);
2059  					ndds._codepage = -1;
2060  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2061  					return TRUE;
2062  				case IDC_RADIO_ANSI:
2063  					ndds._unicodeMode = uni8Bit;
2064  					ndds._openAnsiAsUtf8 = false;
2065  					makeOpenAnsiAsUtf8(false);
2066  					ndds._codepage = -1;
2067  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2068  					return TRUE;
2069  				case IDC_CHECK_OPENANSIASUTF8 :
2070  					ndds._openAnsiAsUtf8 = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), BM_GETCHECK, 0, 0));
2071  					return TRUE;
2072  				case IDC_RADIO_OTHERCP :
2073  				{
2074  					ndds._openAnsiAsUtf8 = false;
2075  					makeOpenAnsiAsUtf8(false);
2076  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), true);
2077  					auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETCURSEL, 0, 0);
2078  					ndds._codepage = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETITEMDATA, index, 0));
2079  					return TRUE;
2080  				}
2081  				case IDC_RADIO_F_MAC:
2082  				{
2083  					ndds._format = EolType::macos;
2084  					return TRUE;
2085  				}
2086  				case IDC_RADIO_F_UNIX:
2087  				{
2088  					ndds._format = EolType::unix;
2089  					return TRUE;
2090  				}
2091  				case IDC_RADIO_F_WIN:
2092  				{
2093  					ndds._format = EolType::windows;
2094  					return TRUE;
2095  				}
2096  				default:
2097  				{
2098  					if (HIWORD(wParam) == CBN_SELCHANGE)
2099  					{
2100  						if (LOWORD(wParam) == IDC_COMBO_DEFAULTLANG)
2101  						{
2102  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETCURSEL, 0, 0);
2103  							ndds._lang = static_cast<LangType>(::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETITEMDATA, index, 0));
2104  							return TRUE;
2105  						}
2106  						else if (LOWORD(wParam) == IDC_COMBO_OTHERCP)
2107  						{
2108  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETCURSEL, 0, 0);
2109  							ndds._codepage = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETITEMDATA, index, 0));
2110  							return TRUE;
2111  						}
2112  					}
2113  					return FALSE;
2114  				}
2115  			}
2116  	}
2117   	return FALSE;
2118  }
2119  intptr_t CALLBACK DefaultDirectorySubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
2120  {
2121  	NppParameters& nppParam = NppParameters::getInstance();
2122  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
2123  	switch (message) 
2124  	{
2125  		case WM_INITDIALOG :
2126  		{
2127  			int ID2Check = 0;
2128  			bool shouldActivated;
2129  			switch (nppGUI._openSaveDir)
2130  			{
2131  				case dir_last :
2132  					ID2Check = IDC_OPENSAVEDIR_REMEMBERLAST_RADIO;
2133  					shouldActivated = false;
2134  					break;
2135  				case dir_userDef :
2136  					ID2Check = IDC_OPENSAVEDIR_ALWAYSON_RADIO;
2137  					shouldActivated = true;
2138  					break;
2139  				default : 
2140  					ID2Check = IDC_OPENSAVEDIR_FOLLOWCURRENT_RADIO;
2141  					shouldActivated = false;
2142  			}
2143  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
2144  			::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._defaultDir));
2145  			::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), shouldActivated);
2146  			::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), shouldActivated);
2147  			::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES, BM_SETCHECK, nppGUI._isFolderDroppedOpenFiles ? BST_CHECKED : BST_UNCHECKED, 0);
2148  			return TRUE;
2149  		}
2150  		case WM_CTLCOLOREDIT:
2151  		{
2152  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2153  		}
2154  		case WM_CTLCOLORDLG:
2155  		case WM_CTLCOLORSTATIC:
2156  		{
2157  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2158  		}
2159  		case WM_PRINTCLIENT:
2160  		{
2161  			if (NppDarkMode::isEnabled())
2162  			{
2163  				return TRUE;
2164  			}
2165  			break;
2166  		}
2167  		case WM_COMMAND : 
2168  		{
2169  			if (HIWORD(wParam) == EN_CHANGE)
2170  			{
2171  				switch (LOWORD(wParam))
2172  				{
2173  					case  IDC_OPENSAVEDIR_ALWAYSON_EDIT:
2174  					{
2175  						TCHAR inputDir[MAX_PATH] = { '\0' };
2176  						::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
2177  						wcscpy_s(nppGUI._defaultDir, inputDir);
2178  						::ExpandEnvironmentStrings(nppGUI._defaultDir, nppGUI._defaultDirExp, _countof(nppGUI._defaultDirExp));
2179  						nppParam.setWorkingDir(nppGUI._defaultDirExp);
2180  						return TRUE;
2181  					}
2182  				}
2183  			}
2184  			switch (wParam)
2185  			{
2186  				case IDC_OPENSAVEDIR_FOLLOWCURRENT_RADIO:
2187  					nppGUI._openSaveDir = dir_followCurrent;
2188  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_REFRESHWORKDIR, 0, 0);
2189  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), false);
2190  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), false);
2191  					return TRUE;
2192  				case IDC_OPENSAVEDIR_REMEMBERLAST_RADIO:
2193  					nppGUI._openSaveDir = dir_last;
2194  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), false);
2195  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), false);
2196  					return TRUE;
2197  				case IDC_OPENSAVEDIR_ALWAYSON_RADIO:
2198  					nppGUI._openSaveDir = dir_userDef;
2199  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_REFRESHWORKDIR, 0, 0);
2200  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), true);
2201  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), true);
2202  					return TRUE;
2203  				case IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON :
2204  					{
2205  						generic_string title = nppParam.getNativeLangSpeaker()->getLocalizedStrFromID("default-open-save-select-folder",
2206  							TEXT("Select a folder as default directory"));
2207  						folderBrowser(_hSelf, title, IDC_OPENSAVEDIR_ALWAYSON_EDIT);
2208  					}
2209  					return TRUE;
2210  				case IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES:
2211  					nppGUI._isFolderDroppedOpenFiles = isCheckedOrNot(IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES);
2212  					return TRUE;
2213  				default:
2214  					return FALSE;
2215  			}
2216  		}
2217  	}
2218  	return FALSE;
2219  }
2220  void RecentFilesHistorySubDlg::setCustomLen(int val)
2221  {
2222  	::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, val, FALSE);
2223  	::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL), val > 0);
2224  }
2225  intptr_t CALLBACK RecentFilesHistorySubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
2226  {
2227  	NppParameters& nppParam = NppParameters::getInstance();
2228  	NppGUI& nppGUI = nppParam.getNppGUI();
2229  	switch (message) 
2230  	{
2231  		case WM_INITDIALOG:
2232  		{
2233  			::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nppParam.getNbMaxRecentFile(), FALSE);
2234  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DONTCHECKHISTORY, BM_SETCHECK, !nppGUI._checkHistoryFiles, 0);
2235  			::SendDlgItemMessage(_hSelf, IDC_CHECK_INSUBMENU, BM_SETCHECK, nppParam.putRecentFileInSubMenu(), 0);
2236  			int customLength = nppParam.getRecentFileCustomLength();
2237  			int id = IDC_RADIO_CUSTOMIZELENTH;
2238  			int length = customLength;
2239  			if (customLength == RECENTFILES_SHOWONLYFILENAME)
2240  			{
2241  				id = IDC_RADIO_ONLYFILENAME;
2242  				length = 0;
2243  			}
2244  			else if (customLength == RECENTFILES_SHOWFULLPATH || customLength < 0)
2245  			{
2246  				id = IDC_RADIO_FULLFILENAMEPATH;
2247  				length = 0;
2248  			}
2249  			setChecked(id);
2250  			setCustomLen(length);
2251  			return TRUE;
2252  		}
2253  		case WM_CTLCOLOREDIT:
2254  		{
2255  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2256  		}
2257  		case WM_CTLCOLORDLG:
2258  		{
2259  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2260  		}
2261  		case WM_CTLCOLORSTATIC:
2262  		{
2263  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
2264  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
2265  			if (dlgCtrlID == IDC_CUSTOMIZELENGTH_RANGE_STATIC)
2266  			{
2267  				const bool isTextEnabled = isCheckedOrNot(IDC_RADIO_CUSTOMIZELENTH);
2268  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
2269  			}
2270  			if (dlgCtrlID == IDC_EDIT_CUSTOMIZELENGTHVAL)
2271  			{
2272  				return NppDarkMode::onCtlColor(hdcStatic);
2273  			}
2274  			return NppDarkMode::onCtlColorDarker(hdcStatic);
2275  		}
2276  		case WM_PRINTCLIENT:
2277  		{
2278  			if (NppDarkMode::isEnabled())
2279  			{
2280  				return TRUE;
2281  			}
2282  			break;
2283  		}
2284  		case WM_COMMAND:
2285  		{
2286  			switch (LOWORD(wParam))
2287  			{
2288  				case IDC_EDIT_MAXNBFILEVAL:
2289  				{
2290  					switch (HIWORD(wParam))
2291  					{
2292  						case EN_KILLFOCUS:
2293  						{
2294  							constexpr int stringSize = 3;
2295  							wchar_t str[stringSize]{};
2296  							::GetDlgItemText(_hSelf, IDC_EDIT_MAXNBFILEVAL, str, stringSize);
2297  							if (lstrcmp(str, L"") == 0)
2298  							{
2299  								::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nppParam.getNbMaxRecentFile(), FALSE);
2300  								return FALSE;
2301  							}
2302  							UINT nbMaxFile = ::GetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nullptr, FALSE);
2303  							if (nbMaxFile == nppParam.getNbMaxRecentFile())
2304  							{
2305  								return FALSE;
2306  							}
2307  							if (nbMaxFile > NB_MAX_LRF_FILE)
2308  							{
2309  								::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, NB_MAX_LRF_FILE, FALSE);
2310  								nbMaxFile = NB_MAX_LRF_FILE;
2311  							}
2312  							nppParam.setNbMaxRecentFile(nbMaxFile);
2313  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_HISTORY_SIZE, 0, 0);
2314  							return TRUE;
2315  						}
2316  						default:
2317  						{
2318  							break;
2319  						}
2320  					}
2321  					return FALSE;
2322  				}
2323  				case IDC_EDIT_CUSTOMIZELENGTHVAL:
2324  				{
2325  					if (!isCheckedOrNot(IDC_RADIO_CUSTOMIZELENTH))
2326  					{
2327  						return FALSE;
2328  					}
2329  					switch (HIWORD(wParam))
2330  					{
2331  						case EN_KILLFOCUS:
2332  						{
2333  							constexpr int stringSize = 4;
2334  							wchar_t str[stringSize]{};
2335  							::GetDlgItemText(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, str, stringSize);
2336  							if (lstrcmp(str, L"") == 0)
2337  							{
2338  								::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, nppParam.getRecentFileCustomLength(), FALSE);
2339  								return FALSE;
2340  							}
2341  							UINT size = ::GetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, nullptr, FALSE);
2342  							if (size == static_cast<UINT>(nppParam.getRecentFileCustomLength()))
2343  							{
2344  								return FALSE;
2345  							}
2346  							bool change = false;
2347  							if (size == 0)
2348  							{
2349  								size = NB_DEFAULT_LRF_CUSTOMLENGTH;
2350  								change = true;
2351  							}
2352  							else if (size > NB_MAX_LRF_CUSTOMLENGTH)
2353  							{
2354  								size = NB_MAX_LRF_CUSTOMLENGTH;
2355  								change = true;
2356  							}
2357  							if (change)
2358  							{
2359  								::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, size, FALSE);
2360  							}
2361  							nppParam.setRecentFileCustomLength(size);
2362  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2363  							return TRUE;
2364  						}
2365  						default:
2366  						{
2367  							break;
2368  						}
2369  					}
2370  					return FALSE;
2371  				}
2372  				default:
2373  				{
2374  					break;
2375  				}
2376  			}
2377  			switch (wParam)
2378  			{
2379  				case IDC_CHECK_DONTCHECKHISTORY:
2380  					nppGUI._checkHistoryFiles = !isCheckedOrNot(IDC_CHECK_DONTCHECKHISTORY);
2381  					return TRUE;
2382  				case IDC_CHECK_INSUBMENU:
2383  					nppParam.setPutRecentFileInSubMenu(isCheckedOrNot(IDC_CHECK_INSUBMENU));
2384  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_SWITCH, 0, 0);
2385  					return TRUE;
2386  				case IDC_RADIO_ONLYFILENAME:
2387  				{
2388  					setCustomLen(0);
2389  					nppParam.setRecentFileCustomLength(0);
2390  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2391  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2392  					return TRUE;
2393  				}
2394  				case IDC_RADIO_FULLFILENAMEPATH:
2395  				{
2396  					setCustomLen(0);
2397  					nppParam.setRecentFileCustomLength(-1);
2398  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2399  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2400  					return TRUE;
2401  				}
2402  				case IDC_RADIO_CUSTOMIZELENTH:
2403  				{
2404  					int len = nppParam.getRecentFileCustomLength();
2405  					if (len <= 0)
2406  					{
2407  						setCustomLen(NB_DEFAULT_LRF_CUSTOMLENGTH);
2408  						nppParam.setRecentFileCustomLength(NB_DEFAULT_LRF_CUSTOMLENGTH);
2409  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2410  					}
2411  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2412  					return TRUE;
2413  				}
2414  				default:
2415  					return FALSE;
2416  			}
2417  		}
2418  	}
2419  	return FALSE;
2420  }
2421  intptr_t CALLBACK LanguageSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
2422  {
2423  	NppParameters& nppParam = NppParameters::getInstance();
2424  	NppGUI & nppGUI = nppParam.getNppGUI();
2425  	NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
2426  	switch (message) 
2427  	{
2428  		case WM_INITDIALOG :
2429  		{
2430  			for (int i = L_TEXT ; i < nppParam.L_END ; ++i)
2431  			{
2432  				generic_string str;
2433  				if (static_cast<LangType>(i) != L_USER)
2434  				{
2435  					int cmdID = nppParam.langTypeToCommandID(static_cast<LangType>(i));
2436  					if ((cmdID != -1))
2437  					{
2438  						getNameStrFromCmd(cmdID, str);
2439  						if (str.length() > 0)
2440  						{
2441  							_langList.push_back(LangMenuItem(static_cast<LangType>(i), cmdID, str));
2442  							::SendDlgItemMessage(_hSelf, IDC_LIST_ENABLEDLANG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
2443  						}
2444  					}
2445  				}
2446  			}
2447  			for (size_t i = 0, len = nppGUI._excludedLangList.size(); i < len ; ++i)
2448  			{
2449  				::SendDlgItemMessage(_hSelf, IDC_LIST_DISABLEDLANG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(nppGUI._excludedLangList[i]._langName.c_str()));
2450  			}
2451  			::SendDlgItemMessage(_hSelf, IDC_CHECK_LANGMENUCOMPACT, BM_SETCHECK, nppGUI._isLangMenuCompact?BST_CHECKED:BST_UNCHECKED, 0);
2452  			::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_REMOVE), FALSE);
2453  			::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_RESTORE), FALSE);
2454  			::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nppGUI._tabSize, FALSE);
2455  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REPLACEBYSPACE, BM_SETCHECK, nppGUI._tabReplacedBySpace, 0);
2456  			::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("[Default]")));
2457  			const int nbLang = nppParam.getNbLang();
2458  			for (int i = 0; i < nbLang; ++i)
2459  			{
2460  				::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(nppParam.getLangFromIndex(i)->_langName.c_str()));
2461  			}
2462  			const int index2Begin = 0;
2463  			::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_SETCURSEL, index2Begin, 0);
2464  			::ShowWindow(::GetDlgItem(_hSelf, IDC_GR_TABVALUE_STATIC), SW_HIDE);
2465  			::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), SW_HIDE);
2466  			::SendDlgItemMessage(_hSelf, IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL, BM_SETCHECK, nppGUI._backSlashIsEscapeCharacterForSql, 0);
2467  			return TRUE;
2468  		}
2469  		case WM_CTLCOLOREDIT:
2470  		{
2471  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2472  		}
2473  		case WM_CTLCOLORLISTBOX:
2474  		{
2475  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
2476  		}
2477  		case WM_CTLCOLORDLG:
2478  		{
2479  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2480  		}
2481  		case WM_CTLCOLORSTATIC:
2482  		{
2483  			const int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
2484  			const auto& hdcStatic = reinterpret_cast<HDC>(wParam);
2485  			const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2486  			if ((index > 0) && (dlgCtrlID == IDC_TABSIZE_STATIC))
2487  			{
2488  				const Lang* lang = nppParam.getLangFromIndex(index - 1);
2489  				if (lang == nullptr)
2490  				{
2491  					return NppDarkMode::onCtlColorDarker(hdcStatic);
2492  				}
2493  				const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2494  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, !useDefaultTab);
2495  			}
2496  			return NppDarkMode::onCtlColorDarker(hdcStatic);
2497  		}
2498  		case WM_PRINTCLIENT:
2499  		{
2500  			if (NppDarkMode::isEnabled())
2501  			{
2502  				return TRUE;
2503  			}
2504  			break;
2505  		}
2506  		case WM_COMMAND : 
2507  		{
2508  			switch (HIWORD(wParam))
2509  			{
2510  				case LBN_SELCHANGE:
2511  				{
2512  					if (LOWORD(wParam) == IDC_LIST_DISABLEDLANG || LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2513  					{
2514  						int idButton2Enable;
2515  						int idButton2Disable;
2516  						if (LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2517  						{
2518  							idButton2Enable = IDC_BUTTON_REMOVE;
2519  							idButton2Disable = IDC_BUTTON_RESTORE;
2520  						}
2521  						else 
2522  						{
2523  							idButton2Enable = IDC_BUTTON_RESTORE;
2524  							idButton2Disable = IDC_BUTTON_REMOVE;
2525  						}
2526  						auto i = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETCURSEL, 0, 0);
2527  						if (i != LB_ERR)
2528  						{
2529  							::EnableWindow(::GetDlgItem(_hSelf, idButton2Enable), TRUE);
2530  							int idListbox2Disable = (LOWORD(wParam) == IDC_LIST_ENABLEDLANG) ? IDC_LIST_DISABLEDLANG : IDC_LIST_ENABLEDLANG;
2531  							::SendDlgItemMessage(_hSelf, idListbox2Disable, LB_SETCURSEL, static_cast<WPARAM>(-1), 0);
2532  							::EnableWindow(::GetDlgItem(_hSelf, idButton2Disable), FALSE);
2533  						}
2534  						return TRUE;
2535  					}
2536  					else if (LOWORD(wParam) == IDC_LIST_TABSETTNG)
2537  					{
2538  						auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2539  						if (index == LB_ERR)
2540  							return FALSE;
2541  						::ShowWindow(::GetDlgItem(_hSelf, IDC_GR_TABVALUE_STATIC), index > 0 ? SW_SHOW : SW_HIDE);
2542  						::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), index > 0 ? SW_SHOW : SW_HIDE);
2543  						if (index > 0)
2544  						{
2545  							Lang* lang = nppParam.getLangFromIndex(index - 1);
2546  							if (!lang) return FALSE;
2547  							bool useDefaultTab = (lang->_tabSize == -1 || lang->_tabSize == 0);
2548  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), BM_SETCHECK, useDefaultTab, 0);
2549  							int size = useDefaultTab ? nppGUI._tabSize : lang->_tabSize;
2550  							::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, size, FALSE);
2551  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, useDefaultTab ? nppGUI._tabReplacedBySpace : lang->_isTabReplacedBySpace, 0);
2552  							::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), !useDefaultTab);
2553  							::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), !useDefaultTab);
2554  							if (!useDefaultTab)
2555  							{
2556  								::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, lang->_tabSize, FALSE);
2557  								::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, lang->_isTabReplacedBySpace, 0);
2558  							}
2559  						}
2560  						else
2561  						{
2562  							::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nppGUI._tabSize, FALSE);
2563  							::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), TRUE);
2564  							::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), TRUE);
2565  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, nppGUI._tabReplacedBySpace, 0);
2566  						}
2567  						redrawDlgItem(IDC_TABSIZE_STATIC);
2568  						return TRUE;
2569  					}
2570  					break;
2571  				}
2572  				case LBN_DBLCLK:
2573  				{
2574  					if (LOWORD(wParam) == IDC_LIST_DISABLEDLANG || LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2575  					{
2576  						HWND(lParam) == ::GetDlgItem(_hSelf, IDC_LIST_ENABLEDLANG) ?
2577  							::SendMessage(_hSelf, WM_COMMAND, IDC_BUTTON_REMOVE, 0) :
2578  							::SendMessage(_hSelf, WM_COMMAND, IDC_BUTTON_RESTORE, 0);
2579  						return TRUE;
2580  					}
2581  					break;
2582  				}
2583  				case EN_CHANGE:
2584  				{
2585  					switch (LOWORD(wParam))
2586  					{
2587  						case IDC_EDIT_TABSIZEVAL:
2588  						{
2589  							const auto tabSize = ::GetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nullptr, FALSE);
2590  							if (tabSize < 1)
2591  							{
2592  								return FALSE;
2593  							}
2594  							const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2595  							const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2596  							if (!useDefaultTab && index > 0)
2597  							{
2598  								Lang* lang = nppParam.getLangFromIndex(index - 1);
2599  								if (lang == nullptr)
2600  								{
2601  									return FALSE;
2602  								}
2603  								if (lang->_langID == L_JS)
2604  								{
2605  									Lang* ljs = nppParam.getLangFromID(L_JAVASCRIPT);
2606  									ljs->_tabSize = tabSize;
2607  								}
2608  								else if (lang->_langID == L_JAVASCRIPT)
2609  								{
2610  									Lang* ljavascript = nppParam.getLangFromID(L_JS);
2611  									ljavascript->_tabSize = tabSize;
2612  								}
2613  								lang->_tabSize = tabSize;
2614  								nppParam.insertTabInfo(lang->getLangName(), lang->getTabInfo());
2615  							}
2616  							else
2617  							{
2618  								nppGUI._tabSize = tabSize;
2619  							}
2620  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_TAB_SIZE, 0, 0);
2621  							return TRUE;
2622  						}
2623  						default:
2624  						{
2625  							break;
2626  						}
2627  					}
2628  					break;
2629  				}
2630  				case EN_KILLFOCUS:
2631  				{
2632  					switch (LOWORD(wParam))
2633  					{
2634  						case IDC_EDIT_TABSIZEVAL:
2635  						{
2636  							const auto tabSize = ::GetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nullptr, FALSE);
2637  							if (tabSize < 1)
2638  							{
2639  								const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2640  								const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2641  								auto prevSize = nppGUI._tabSize;
2642  								if (!useDefaultTab && index > 0)
2643  								{
2644  									Lang* lang = nppParam.getLangFromIndex(index - 1);
2645  									if (lang != nullptr && lang->_tabSize > 0)
2646  									{
2647  										prevSize = lang->_tabSize;
2648  									}
2649  								}
2650  								::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, prevSize, FALSE);
2651  								return TRUE;
2652  							}
2653  							return FALSE;
2654  						}
2655  						default:
2656  						{
2657  							break;
2658  						}
2659  					}
2660  					break;
2661  				}
2662  				default:
2663  				{
2664  					break;
2665  				}
2666  			}
2667  			switch (wParam)
2668  			{
2669  				case IDC_CHECK_LANGMENUCOMPACT:
2670  				{
2671  					nppGUI._isLangMenuCompact = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_LANGMENUCOMPACT), BM_GETCHECK, 0, 0));
2672  					pNativeSpeaker->messageBox("LanguageMenuCompactWarning",
2673  						_hSelf,
2674  						TEXT("This option will be changed on the next launch."),
2675  						TEXT("Compact Language Menu"),
2676  						MB_OK);
2677  					return TRUE;
2678  				}
2679  				case IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL:
2680  				{
2681  					nppGUI._backSlashIsEscapeCharacterForSql = isCheckedOrNot(IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL);
2682  					return TRUE;
2683  				}
2684  				case IDC_BUTTON_RESTORE :
2685  				case IDC_BUTTON_REMOVE :
2686  				{
2687  					int list2Remove, list2Add, idButton2Enable, idButton2Disable;
2688  					vector<LangMenuItem> *pSrcLst, *pDestLst;
2689  					if (LOWORD(wParam)==IDC_BUTTON_REMOVE)
2690  					{
2691  						list2Remove = IDC_LIST_ENABLEDLANG;
2692  						list2Add = IDC_LIST_DISABLEDLANG;
2693  						idButton2Enable = IDC_BUTTON_RESTORE;
2694  						idButton2Disable = IDC_BUTTON_REMOVE;
2695  						pSrcLst = &_langList;
2696  						pDestLst = &nppGUI._excludedLangList;
2697  					}
2698  					else
2699  					{
2700  						list2Remove = IDC_LIST_DISABLEDLANG;
2701  						list2Add = IDC_LIST_ENABLEDLANG;
2702  						idButton2Enable = IDC_BUTTON_REMOVE;
2703  						idButton2Disable = IDC_BUTTON_RESTORE;
2704  						pSrcLst = &nppGUI._excludedLangList;
2705  						pDestLst = &_langList;
2706  					}
2707  					size_t iRemove = ::SendDlgItemMessage(_hSelf, list2Remove, LB_GETCURSEL, 0, 0);
2708  					if (static_cast<intptr_t>(iRemove) == -1)
2709  						return TRUE;
2710  					const size_t sL = 31;
2711  					TCHAR s[sL + 1] = { '\0' };
2712  					auto lbTextLen = ::SendDlgItemMessage(_hSelf, list2Remove, LB_GETTEXTLEN, iRemove, 0);
2713  					if (static_cast<size_t>(lbTextLen) > sL)
2714  						return TRUE;
2715  					::SendDlgItemMessage(_hSelf, list2Remove, LB_GETTEXT, iRemove, reinterpret_cast<LPARAM>(s));
2716  					LangMenuItem lmi = pSrcLst->at(iRemove);
2717  					vector<LangMenuItem>::iterator lang2Remove = pSrcLst->begin() + iRemove;
2718  					pSrcLst->erase(lang2Remove);
2719  					auto iAdd = ::SendDlgItemMessage(_hSelf, list2Add, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(s));
2720  					::SendDlgItemMessage(_hSelf, list2Remove, LB_DELETESTRING, iRemove, 0);
2721  					pDestLst->push_back(lmi);
2722  					::SendDlgItemMessage(_hSelf, list2Add, LB_SETCURSEL, iAdd, 0);
2723  					::SendDlgItemMessage(_hSelf, list2Remove, LB_SETCURSEL, static_cast<WPARAM>(-1), 0);
2724  					::EnableWindow(::GetDlgItem(_hSelf, idButton2Enable), TRUE);
2725  					::EnableWindow(::GetDlgItem(_hSelf, idButton2Disable), FALSE);
2726  					if ((lmi._langType >= L_EXTERNAL) && (lmi._langType < nppParam.L_END))
2727  					{
2728  						bool found(false);
2729  						for (size_t x = 0; x < nppParam.getExternalLexerDoc()->size() && !found; ++x)
2730  						{
2731  							TiXmlNode *lexersRoot = nppParam.getExternalLexerDoc()->at(x)->FirstChild(TEXT("NotepadPlus"))->FirstChildElement(TEXT("LexerStyles"));
2732  							for (TiXmlNode *childNode = lexersRoot->FirstChildElement(TEXT("LexerType"));
2733  								childNode ;
2734  								childNode = childNode->NextSibling(TEXT("LexerType")))
2735  							{
2736  								TiXmlElement *element = childNode->ToElement();
2737  								if (generic_string(element->Attribute(TEXT("name"))) == lmi._langName)
2738  								{
2739  									element->SetAttribute(TEXT("excluded"), (LOWORD(wParam)==IDC_BUTTON_REMOVE)?TEXT("yes"):TEXT("no"));
2740  									nppParam.getExternalLexerDoc()->at(x)->SaveFile();
2741  									found = true;
2742  									break;
2743  								}
2744  							}
2745  						}
2746  					}
2747  					HWND grandParent = ::GetParent(_hParent);
2748  					if (LOWORD(wParam)==IDC_BUTTON_REMOVE)
2749  					{
2750  						HMENU menu2remove = reinterpret_cast<HMENU>(::SendMessage(grandParent, NPPM_INTERNAL_GETMENU, 0, 0));
2751  						::DeleteMenu(menu2remove, lmi._cmdID, MF_BYCOMMAND);
2752  					}
2753  					else
2754  					{
2755  						HMENU menu = HMENU(::SendMessage(grandParent, NPPM_INTERNAL_GETMENU, 0, 0));
2756  						HMENU subMenu = ::GetSubMenu(menu, MENUINDEX_LANGUAGE);
2757  						int nbItem = ::GetMenuItemCount(subMenu);
2758  						int x = 0;
2759  						MENUITEMINFO menuItemInfo
2760  						{
2761  							.cbSize = sizeof(MENUITEMINFO),
2762  							.fMask = MIIM_FTYPE
2763  						};
2764  						for (; x < nbItem; ++x)
2765  						{
2766  							::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
2767  							if (menuItemInfo.fType & MFT_SEPARATOR)
2768  							{
2769  								break;
2770  							}
2771  						}
2772  						TCHAR firstLetter = lmi._langName.empty() ? TEXT('\0') : towupper(lmi._langName[0]);
2773  						TCHAR buffer[MAX_EXTERNAL_LEXER_NAME_LEN]{TEXT('\0')};
2774  						menuItemInfo.fMask = MIIM_SUBMENU;
2775  						for (++x; x < nbItem; ++x)
2776  						{
2777  							::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
2778  							::GetMenuString(subMenu, x, buffer, MAX_EXTERNAL_LEXER_NAME_LEN, MF_BYPOSITION);
2779  							if (menuItemInfo.hSubMenu && buffer[0] == firstLetter)
2780  							{
2781  								subMenu = menuItemInfo.hSubMenu;
2782  								nbItem = ::GetMenuItemCount(subMenu);
2783  								x = -1;
2784  							}
2785  							else if (lstrcmp(lmi._langName.c_str(), buffer) < 0)
2786  							{
2787  								break;
2788  							}
2789  						}
2790  						::InsertMenu(subMenu, x, MF_BYPOSITION, lmi._cmdID, lmi._langName.c_str());
2791  					}
2792  					::DrawMenuBar(grandParent);
2793  					return TRUE;
2794  				}
2795  				case IDC_CHECK_REPLACEBYSPACE:
2796  				{
2797  					bool isTabReplacedBySpace = BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_GETCHECK, 0, 0);
2798  					auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2799  					if (index == LB_ERR) return FALSE;
2800  					if (index != 0)
2801  					{
2802  						Lang *lang = nppParam.getLangFromIndex(index - 1);
2803  						if (!lang) return FALSE;
2804  						if (!lang->_tabSize || lang->_tabSize == -1)
2805  							lang->_tabSize = nppGUI._tabSize;
2806  						if (lang->_langID == L_JS)
2807  						{
2808  							Lang *ljs = nppParam.getLangFromID(L_JAVASCRIPT);
2809  							ljs->_isTabReplacedBySpace = isTabReplacedBySpace;
2810  						}
2811  						else if (lang->_langID == L_JAVASCRIPT)
2812  						{
2813  							Lang *ljavascript = nppParam.getLangFromID(L_JS);
2814  							ljavascript->_isTabReplacedBySpace = isTabReplacedBySpace;
2815  						}
2816  						lang->_isTabReplacedBySpace = isTabReplacedBySpace;
2817  						nppParam.insertTabInfo(lang->getLangName(), lang->getTabInfo());
2818  					}
2819  					else
2820  					{
2821  						nppGUI._tabReplacedBySpace = isTabReplacedBySpace;
2822  					}
2823  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_TAB_REPLCESPACE, 0, 0);
2824  					return TRUE;
2825  				}
2826  				case IDC_CHECK_DEFAULTTABVALUE:
2827  				{
2828  					const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2829  					const auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2830  					if (index == LB_ERR || index == 0) 
2831  						return FALSE;
2832  					Lang *lang = nppParam.getLangFromIndex(index - 1);
2833  					if (!lang)
2834  						return FALSE;
2835  					lang->_tabSize = useDefaultTab ? 0 : nppGUI._tabSize;
2836  					lang->_isTabReplacedBySpace = useDefaultTab ? false : nppGUI._tabReplacedBySpace;
2837  					::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, useDefaultTab ? nppGUI._tabSize : lang->_tabSize, FALSE);
2838  					setChecked(IDC_CHECK_REPLACEBYSPACE, useDefaultTab ? nppGUI._tabReplacedBySpace : lang->_isTabReplacedBySpace);
2839  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), !useDefaultTab);
2840  					::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), !useDefaultTab);
2841  					if (useDefaultTab)
2842  						nppParam.insertTabInfo(lang->getLangName(), -1);
2843  					redrawDlgItem(IDC_TABSIZE_STATIC);
2844  					return TRUE;
2845  				}
2846  				default:
2847  				{
2848  					break;
2849  				}
2850  			}
2851  		}
2852  		default:
2853  		{
2854  			break;
2855  		}
2856  	}
2857  	return FALSE;
2858  }
2859  intptr_t CALLBACK HighlightingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM&bsol;* lParam*/)
2860  {
2861  	NppParameters& nppParam = NppParameters::getInstance();
2862  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
2863  	switch (message) 
2864  	{
2865  		case WM_INITDIALOG :
2866  		{
2867  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MARKALLCASESENSITIVE, BM_SETCHECK, nppGUI._markAllCaseSensitive, 0);
2868  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MARKALLWHOLEWORDONLY, BM_SETCHECK, nppGUI._markAllWordOnly, 0);
2869  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLSMARTHILITE, BM_SETCHECK, nppGUI._enableSmartHilite, 0);
2870  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE, BM_SETCHECK, nppGUI._smartHiliteCaseSensitive, 0);
2871  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY, BM_SETCHECK, nppGUI._smartHiliteWordOnly, 0);
2872  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, nppGUI._smartHiliteUseFindSettings, 0);
2873  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW, BM_SETCHECK, nppGUI._smartHiliteOnAnotherView, 0);
2874  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLTAGSMATCHHILITE, BM_SETCHECK, nppGUI._enableTagsMatchHilite, 0);
2875  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE, BM_SETCHECK, nppGUI._enableTagAttrsHilite, 0);
2876  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE, BM_SETCHECK, nppGUI._enableHiliteNonHTMLZone, 0);
2877  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE), nppGUI._enableTagsMatchHilite);
2878  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE), nppGUI._enableTagsMatchHilite);
2879  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE), nppGUI._enableSmartHilite);
2880  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY), nppGUI._enableSmartHilite);
2881  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS), nppGUI._enableSmartHilite);
2882  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW), nppGUI._enableSmartHilite);
2883  			if (NppDarkMode::isEnabled())
2884  			{
2885  				::EnableWindow(::GetDlgItem(_hSelf, IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
2886  			}
2887  			return TRUE;
2888  		}
2889  		case WM_CTLCOLORDLG:
2890  		case WM_CTLCOLORSTATIC:
2891  		{
2892  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2893  		}
2894  		case WM_PRINTCLIENT:
2895  		{
2896  			if (NppDarkMode::isEnabled())
2897  			{
2898  				return TRUE;
2899  			}
2900  			break;
2901  		}
2902  		case WM_COMMAND : 
2903  		{
2904  			switch (wParam)
2905  			{
2906  				case IDC_CHECK_MARKALLCASESENSITIVE:
2907  				{
2908  					nppGUI._markAllCaseSensitive = isCheckedOrNot(IDC_CHECK_MARKALLCASESENSITIVE);
2909  					HWND grandParent = ::GetParent(_hParent);
2910  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2911  					return TRUE;
2912  				}
2913  				case IDC_CHECK_MARKALLWHOLEWORDONLY:
2914  				{
2915  					nppGUI._markAllWordOnly = isCheckedOrNot(IDC_CHECK_MARKALLWHOLEWORDONLY);
2916  					HWND grandParent = ::GetParent(_hParent);
2917  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2918  					return TRUE;
2919  				}
2920  				case IDC_CHECK_ENABLSMARTHILITE:
2921  				{
2922  					nppGUI._enableSmartHilite = !nppGUI._enableSmartHilite;
2923  					if (!nppGUI._enableSmartHilite)
2924  					{
2925  					}
2926  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE), nppGUI._enableSmartHilite);
2927  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY), nppGUI._enableSmartHilite);
2928  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS), nppGUI._enableSmartHilite);
2929  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW), nppGUI._enableSmartHilite);
2930  					if (NppDarkMode::isEnabled())
2931  					{
2932  						::EnableWindow(::GetDlgItem(_hSelf, IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
2933  						redrawDlgItem(IDC_SMARTHILITEMATCHING_STATIC);
2934  					}
2935  					HWND grandParent = ::GetParent(_hParent);
2936  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2937  					return TRUE;
2938  				}
2939  				case IDC_CHECK_SMARTHILITECASESENSITIVE:
2940  				{
2941  					nppGUI._smartHiliteCaseSensitive = isCheckedOrNot(IDC_CHECK_SMARTHILITECASESENSITIVE);
2942  					if (nppGUI._smartHiliteCaseSensitive)
2943  					{
2944  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, false, 0);
2945  						nppGUI._smartHiliteUseFindSettings = false;
2946  					}
2947  					HWND grandParent = ::GetParent(_hParent);
2948  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2949  					return TRUE;
2950  				}
2951  				case IDC_CHECK_SMARTHILITEWHOLEWORDONLY:
2952  				{
2953  					nppGUI._smartHiliteWordOnly = isCheckedOrNot(IDC_CHECK_SMARTHILITEWHOLEWORDONLY);
2954  					if (nppGUI._smartHiliteWordOnly)
2955  					{
2956  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, false, 0);
2957  						nppGUI._smartHiliteUseFindSettings = false;
2958  					}
2959  					HWND grandParent = ::GetParent(_hParent);
2960  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2961  					return TRUE;
2962  				}
2963  				case IDC_CHECK_SMARTHILITEUSEFINDSETTINGS:
2964  				{
2965  					nppGUI._smartHiliteUseFindSettings = isCheckedOrNot(IDC_CHECK_SMARTHILITEUSEFINDSETTINGS);
2966  					if (nppGUI._smartHiliteUseFindSettings)
2967  					{
2968  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE, BM_SETCHECK, false, 0);
2969  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY, BM_SETCHECK, false, 0);
2970  						nppGUI._smartHiliteCaseSensitive = false;
2971  						nppGUI._smartHiliteWordOnly = false;
2972  					}
2973  					HWND grandParent = ::GetParent(_hParent);
2974  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2975  					return TRUE;
2976  				}
2977  				case IDC_CHECK_SMARTHILITEANOTHERRVIEW:
2978  				{
2979  					nppGUI._smartHiliteOnAnotherView = isCheckedOrNot(IDC_CHECK_SMARTHILITEANOTHERRVIEW);
2980  					HWND grandParent = ::GetParent(_hParent);
2981  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2982  					return TRUE;
2983  				}
2984  				case IDC_CHECK_ENABLTAGSMATCHHILITE:
2985  				{
2986  					nppGUI._enableTagsMatchHilite = !nppGUI._enableTagsMatchHilite;
2987  					if (!nppGUI._enableTagsMatchHilite)
2988  					{
2989  						HWND grandParent = ::GetParent(_hParent);
2990  						::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATORTAGMATCH, 0, 0);
2991  					}
2992  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE), nppGUI._enableTagsMatchHilite);
2993  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE), nppGUI._enableTagsMatchHilite);
2994  					return TRUE;
2995  				}
2996  				case IDC_CHECK_ENABLTAGATTRHILITE:
2997  				{
2998  					nppGUI._enableTagAttrsHilite = !nppGUI._enableTagAttrsHilite;
2999  					if (!nppGUI._enableTagAttrsHilite)
3000  					{
3001  						HWND grandParent = ::GetParent(_hParent);
3002  						::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATORTAGATTR, 0, 0);
3003  					}
3004  					return TRUE;
3005  				}
3006  				case IDC_CHECK_HIGHLITENONEHTMLZONE:
3007  				{
3008  					nppGUI._enableHiliteNonHTMLZone = !nppGUI._enableHiliteNonHTMLZone;
3009  					return TRUE;
3010  				}
3011  			}
3012  		}
3013  	}
3014  	return FALSE;
3015  }
3016  intptr_t CALLBACK PrintSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3017  {
3018  	NppParameters& nppParam = NppParameters::getInstance();
3019  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
3020  	switch (message) 
3021  	{
3022  		case WM_INITDIALOG :
3023  		{
3024  			bool printLN = nppGUI._printSettings._printLineNumber;
3025  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PRINTLINENUM, BM_SETCHECK, printLN, 0);
3026  			int ID2Check = 0;
3027  			switch (nppGUI._printSettings._printOption)
3028  			{
3029  				case SC_PRINT_NORMAL :
3030  					ID2Check = IDC_RADIO_WYSIWYG;
3031  					break;
3032  				case SC_PRINT_INVERTLIGHT :
3033  					ID2Check = IDC_RADIO_INVERT;
3034  					break;
3035  				case SC_PRINT_BLACKONWHITE :
3036  					ID2Check = IDC_RADIO_BW;
3037  					break;
3038  				case SC_PRINT_COLOURONWHITE :
3039  					ID2Check = IDC_RADIO_NOBG;
3040  					break;
3041  			}
3042  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
3043  			::SetDlgItemInt(_hSelf, IDC_EDIT_ML, nppGUI._printSettings._marge.left, FALSE);
3044  			::SetDlgItemInt(_hSelf, IDC_EDIT_MR, nppGUI._printSettings._marge.right, FALSE);
3045  			::SetDlgItemInt(_hSelf, IDC_EDIT_MT, nppGUI._printSettings._marge.top, FALSE);
3046  			::SetDlgItemInt(_hSelf, IDC_EDIT_MB,  nppGUI._printSettings._marge.bottom, FALSE);
3047  			::SetDlgItemText(_hSelf, IDC_EDIT_HLEFT, nppGUI._printSettings._headerLeft.c_str());
3048  			::SetDlgItemText(_hSelf, IDC_EDIT_HMIDDLE, nppGUI._printSettings._headerMiddle.c_str());
3049  			::SetDlgItemText(_hSelf, IDC_EDIT_HRIGHT, nppGUI._printSettings._headerRight.c_str());
3050  			::SetDlgItemText(_hSelf, IDC_EDIT_FLEFT, nppGUI._printSettings._footerLeft.c_str());
3051  			::SetDlgItemText(_hSelf, IDC_EDIT_FMIDDLE, nppGUI._printSettings._footerMiddle.c_str());
3052  			::SetDlgItemText(_hSelf, IDC_EDIT_FRIGHT, nppGUI._printSettings._footerRight.c_str());
3053  			TCHAR intStr[5]{};
3054  			for (int i = 6 ; i < 15 ; ++i)
3055  			{
3056  				wsprintf(intStr, TEXT("%d"), i);
3057  				::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTSIZE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(intStr));
3058  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTSIZE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(intStr));
3059  			}
3060  			const std::vector<generic_string> & fontlist = nppParam.getFontList();
3061  			for (size_t i = 0, len = fontlist.size() ; i < len ; ++i)
3062  			{
3063  				auto j = ::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3064  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3065  				::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3066  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3067  			}
3068  			auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(nppGUI._printSettings._headerFontName.c_str()));
3069  			if (index == CB_ERR)
3070  				index = 0;
3071  			::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_SETCURSEL, index, 0);
3072  			index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(nppGUI._printSettings._footerFontName.c_str()));
3073  			if (index == CB_ERR)
3074  				index = 0;
3075  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_SETCURSEL, index, 0);
3076  			wsprintf(intStr, TEXT("%d"), nppGUI._printSettings._headerFontSize);
3077  			::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTSIZE, CB_SELECTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(intStr));
3078  			wsprintf(intStr, TEXT("%d"), nppGUI._printSettings._footerFontSize);
3079  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTSIZE, CB_SELECTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(intStr));
3080  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HBOLD, BM_SETCHECK, nppGUI._printSettings._headerFontStyle & FONTSTYLE_BOLD, 0);
3081  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HITALIC, BM_SETCHECK, nppGUI._printSettings._headerFontStyle & FONTSTYLE_ITALIC, 0);
3082  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FBOLD, BM_SETCHECK, nppGUI._printSettings._footerFontStyle & FONTSTYLE_BOLD, 0);
3083  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FITALIC, BM_SETCHECK, nppGUI._printSettings._footerFontStyle & FONTSTYLE_ITALIC, 0);
3084  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Full file name path")));
3085  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("File name")));
3086  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("File directory")));
3087  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Page")));
3088  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Short date format")));
3089  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Long date format")));
3090  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Time")));
3091  			varList.push_back(TEXT("$(FULL_CURRENT_PATH)"));
3092  			varList.push_back(TEXT("$(FILE_NAME)"));
3093  			varList.push_back(TEXT("$(CURRENT_DIRECTORY)"));
3094  			varList.push_back(TEXT("$(CURRENT_PRINTING_PAGE)"));
3095  			varList.push_back(TEXT("$(SHORT_DATE)"));
3096  			varList.push_back(TEXT("$(LONG_DATE)"));
3097  			varList.push_back(TEXT("$(TIME)"));
3098  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_SETCURSEL, 0, 0);
3099  			return TRUE;
3100  		}
3101  		case WM_CTLCOLOREDIT:
3102  		{
3103  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3104  		}
3105  		case WM_CTLCOLORLISTBOX:
3106  		{
3107  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
3108  		}
3109  		case WM_CTLCOLORDLG:
3110  		{
3111  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3112  		}
3113  		case WM_CTLCOLORSTATIC:
3114  		{
3115  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
3116  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3117  			if (dlgCtrlID == IDC_EDIT_VIEWPANEL)
3118  			{
3119  				return NppDarkMode::onCtlColor(hdcStatic);
3120  			}
3121  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3122  		}
3123  		case WM_PRINTCLIENT:
3124  		{
3125  			if (NppDarkMode::isEnabled())
3126  			{
3127  				return TRUE;
3128  			}
3129  			break;
3130  		}
3131  		case WM_COMMAND:
3132  		{
3133  			if (HIWORD(wParam) == EN_CHANGE && LOWORD(wParam) != IDC_EDIT_VIEWPANEL)
3134  			{
3135  				switch (LOWORD(wParam))
3136  				{
3137  					case  IDC_EDIT_ML:
3138  						nppGUI._printSettings._marge.left = ::GetDlgItemInt(_hSelf, IDC_EDIT_ML, NULL, FALSE);
3139  						return TRUE;
3140  					case  IDC_EDIT_MR:
3141  						nppGUI._printSettings._marge.right = ::GetDlgItemInt(_hSelf, IDC_EDIT_MR, NULL, FALSE);
3142  						return TRUE;
3143  					case IDC_EDIT_MT :
3144  						nppGUI._printSettings._marge.top = ::GetDlgItemInt(_hSelf, IDC_EDIT_MT, NULL, FALSE);
3145  						return TRUE;
3146  					case IDC_EDIT_MB :
3147  						nppGUI._printSettings._marge.bottom = ::GetDlgItemInt(_hSelf, IDC_EDIT_MB, NULL, FALSE);
3148  						return TRUE;
3149  					default:
3150  					{
3151  						constexpr int stringSize = 256;
3152  						TCHAR str[stringSize]{};
3153  						_focusedEditCtrl = LOWORD(wParam);
3154  						::GetDlgItemText(_hSelf, _focusedEditCtrl, str, stringSize);
3155  						::SendDlgItemMessage(_hSelf, IDC_EDIT_VIEWPANEL, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(str));
3156  						switch (LOWORD(wParam))
3157  						{
3158  							case  IDC_EDIT_HLEFT:
3159  								nppGUI._printSettings._headerLeft = str;
3160  								trim(nppGUI._printSettings._headerLeft);
3161  								return TRUE;
3162  							case  IDC_EDIT_HMIDDLE:
3163  								nppGUI._printSettings._headerMiddle = str;
3164  								trim(nppGUI._printSettings._headerMiddle);
3165  								return TRUE;
3166  							case IDC_EDIT_HRIGHT :
3167  								nppGUI._printSettings._headerRight = str;
3168  								trim(nppGUI._printSettings._headerRight);
3169  								return TRUE;
3170  							case  IDC_EDIT_FLEFT:
3171  								nppGUI._printSettings._footerLeft = str;
3172  								trim(nppGUI._printSettings._footerLeft);
3173  								return TRUE;
3174  							case  IDC_EDIT_FMIDDLE:
3175  								nppGUI._printSettings._footerMiddle = str;
3176  								trim(nppGUI._printSettings._footerMiddle);
3177  								return TRUE;
3178  							case IDC_EDIT_FRIGHT :
3179  								nppGUI._printSettings._footerRight = str;
3180  								trim(nppGUI._printSettings._footerRight);
3181  								return TRUE;
3182  							default :
3183  								return FALSE;
3184  						}
3185  					}
3186  				}
3187  			}
3188  			else if (HIWORD(wParam) == EN_SETFOCUS && LOWORD(wParam) != IDC_EDIT_VIEWPANEL)
3189  			{
3190  				constexpr int stringSize = 256;
3191  				TCHAR str[stringSize]{};
3192  				_focusedEditCtrl = LOWORD(wParam);
3193  				int focusedEditStatic = 0;
3194  				int groupStatic = 0;
3195  				switch (_focusedEditCtrl)
3196  				{
3197  					case IDC_EDIT_HLEFT : focusedEditStatic = IDC_HL_STATIC; groupStatic = IDC_HGB_STATIC; break;
3198  					case IDC_EDIT_HMIDDLE : focusedEditStatic = IDC_HM_STATIC; groupStatic = IDC_HGB_STATIC; break;
3199  					case IDC_EDIT_HRIGHT : focusedEditStatic = IDC_HR_STATIC; groupStatic = IDC_HGB_STATIC; break;
3200  					case IDC_EDIT_FLEFT : focusedEditStatic = IDC_FL_STATIC; groupStatic = IDC_FGB_STATIC; break;
3201  					case IDC_EDIT_FMIDDLE : focusedEditStatic = IDC_FM_STATIC; groupStatic = IDC_FGB_STATIC; break;
3202  					case IDC_EDIT_FRIGHT : focusedEditStatic = IDC_FR_STATIC; groupStatic = IDC_FGB_STATIC; break;
3203  					default : return TRUE;
3204  				}
3205  				::GetDlgItemText(_hSelf, _focusedEditCtrl, str, stringSize);
3206  				::SendDlgItemMessage(_hSelf, IDC_EDIT_VIEWPANEL, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(str));
3207  				::GetDlgItemText(_hSelf, groupStatic, str, stringSize);
3208  				generic_string title = str;
3209  				title += TEXT(" ");
3210  				::GetDlgItemText(_hSelf, focusedEditStatic, str, stringSize);
3211  				title += str;
3212  				title = purgeMenuItemString(title.c_str()); 
3213  				::SendDlgItemMessage(_hSelf, IDC_WHICHPART_STATIC, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(title.c_str()));
3214  				redrawDlgItem(IDC_WHICHPART_STATIC);
3215  				return TRUE;
3216  			}
3217  			else if (HIWORD(wParam) == CBN_SELCHANGE)
3218  			{
3219  				auto iSel = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETCURSEL, 0, 0);
3220  				switch (LOWORD(wParam))
3221  				{
3222  					case IDC_COMBO_HFONTNAME :
3223  					case IDC_COMBO_FFONTNAME :
3224  					{
3225  						TCHAR *fnStr = (TCHAR *)::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETITEMDATA, iSel, 0);
3226  						if (LOWORD(wParam) == IDC_COMBO_HFONTNAME)
3227  							nppGUI._printSettings._headerFontName = fnStr;
3228  						else
3229  							nppGUI._printSettings._footerFontName = fnStr;
3230  					}
3231  					break;
3232  					case IDC_COMBO_HFONTSIZE :
3233  					case IDC_COMBO_FFONTSIZE :
3234  					{
3235  						constexpr size_t intStrLen = 3;
3236  						TCHAR intStr[intStrLen]{};
3237  						auto lbTextLen = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETLBTEXTLEN, iSel, 0);
3238  						if (static_cast<size_t>(lbTextLen) >= intStrLen)
3239  							return TRUE;
3240  						::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETLBTEXT, iSel, reinterpret_cast<LPARAM>(intStr));
3241  						int *pVal = (LOWORD(wParam) == IDC_COMBO_HFONTSIZE)?&(nppGUI._printSettings._headerFontSize):&(nppGUI._printSettings._footerFontSize);
3242  						if (!intStr[0])
3243  							*pVal = 0;
3244  						else
3245  							*pVal = wcstol(intStr, NULL, 10);
3246  					}
3247  					break;
3248  					case IDC_COMBO_VARLIST:
3249  					{
3250  						break;
3251  					}
3252  					default:
3253  					{
3254  						break;
3255  					}
3256  				}
3257  				return TRUE;
3258  			}
3259  			switch (wParam)
3260  			{
3261  				case IDC_CHECK_PRINTLINENUM:
3262  					nppGUI._printSettings._printLineNumber = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_PRINTLINENUM, BM_GETCHECK, 0, 0));
3263  					break;
3264  				case  IDC_RADIO_WYSIWYG:
3265  					nppGUI._printSettings._printOption = SC_PRINT_NORMAL;
3266  					break;
3267  				case  IDC_RADIO_INVERT:
3268  					nppGUI._printSettings._printOption = SC_PRINT_INVERTLIGHT;
3269  					break;
3270  				case IDC_RADIO_BW :
3271  					nppGUI._printSettings._printOption = SC_PRINT_BLACKONWHITE;
3272  					break;
3273  				case IDC_RADIO_NOBG :
3274  					nppGUI._printSettings._printOption = SC_PRINT_COLOURONWHITE;
3275  					break;
3276  				case IDC_CHECK_HBOLD:
3277  					nppGUI._printSettings._headerFontStyle ^= FONTSTYLE_BOLD;
3278  					break;
3279  				case  IDC_CHECK_HITALIC:
3280  					nppGUI._printSettings._headerFontStyle ^= FONTSTYLE_ITALIC;
3281  					break;
3282  				case  IDC_CHECK_FBOLD:
3283  					nppGUI._printSettings._footerFontStyle ^= FONTSTYLE_BOLD;
3284  					break;
3285  				case  IDC_CHECK_FITALIC:
3286  					nppGUI._printSettings._footerFontStyle ^= FONTSTYLE_ITALIC;
3287  					break;
3288  				case  IDC_BUTTON_ADDVAR:
3289  				{
3290  					try {
3291  						if (!_focusedEditCtrl)
3292  							return TRUE;
3293  						size_t iSel = ::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_GETCURSEL, 0, 0);
3294  						if (iSel >= varList.size())
3295  							return TRUE;
3296  						TCHAR *varStr = (TCHAR*)varList[iSel].c_str();
3297  						size_t selStart = 0;
3298  						size_t selEnd = 0;
3299  						::SendDlgItemMessage(_hSelf, _focusedEditCtrl, EM_GETSEL, reinterpret_cast<WPARAM>(&selStart), reinterpret_cast<LPARAM>(&selEnd));
3300  						constexpr int stringSize = 256;
3301  						TCHAR str[stringSize]{};
3302  						::SendDlgItemMessage(_hSelf, _focusedEditCtrl, WM_GETTEXT, stringSize, reinterpret_cast<LPARAM>(str));
3303  						generic_string str2Set(str);
3304  						size_t strLen = str2Set.length();
3305  						if (selStart > strLen || selEnd > strLen)
3306  							selStart = selEnd = strLen;
3307  						str2Set.replace(selStart, selEnd - selStart, varStr);
3308  						::SetDlgItemText(_hSelf, _focusedEditCtrl, str2Set.c_str());
3309  					}
3310  					catch (...)
3311  					{
3312  					}
3313  				}
3314  				break;
3315  			}
3316  			return TRUE;
3317  		}
3318  	}
3319  	return FALSE;
3320  }
3321  intptr_t CALLBACK BackupSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3322  {
3323  	NppParameters& nppParam = NppParameters::getInstance();
3324  	NppGUI & nppGUI = nppParam.getNppGUI();
3325  	switch (message) 
3326  	{
3327  		case WM_INITDIALOG :
3328  		{
3329  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REMEMBERSESSION, BM_SETCHECK, nppGUI._rememberLastSession, 0);
3330  			bool snapshotCheck = nppGUI._rememberLastSession && nppGUI.isSnapshotMode();
3331  			::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_SETCHECK, snapshotCheck?BST_CHECKED:BST_UNCHECKED, 0);
3332  			auto periodicBackupInSec = static_cast<UINT>(nppGUI._snapshotBackupTiming / 1000);
3333  			::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT,periodicBackupInSec, FALSE);
3334  			generic_string backupFilePath = NppParameters::getInstance().getUserPath();
3335  			backupFilePath += TEXT("\\backup\\");
3336  			::SetDlgItemText(_hSelf, IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT, backupFilePath.c_str());
3337  			int ID2CheckBackupOnSave = 0;
3338  			switch (nppGUI._backup)
3339  			{
3340  				case bak_simple :
3341  					ID2CheckBackupOnSave = IDC_RADIO_BKSIMPLE;
3342  					break;
3343  				case bak_verbose :
3344  					ID2CheckBackupOnSave = IDC_RADIO_BKVERBOSE;
3345  					break;
3346  				default : 
3347  					ID2CheckBackupOnSave = IDC_RADIO_BKNONE;
3348  			}
3349  			::SendDlgItemMessage(_hSelf, ID2CheckBackupOnSave, BM_SETCHECK, BST_CHECKED, 0);
3350  			if (nppGUI._useDir)
3351  				::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_CHECK, BM_SETCHECK, BST_CHECKED, 0);
3352  			::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>((nppGUI._backupDir.c_str())));
3353  			updateBackupSessionGUI();
3354  			updateBackupOnSaveGUI();
3355  			return TRUE;
3356  		}
3357  		case WM_CTLCOLOREDIT:
3358  		{
3359  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3360  		}
3361  		case WM_CTLCOLORDLG:
3362  		{
3363  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3364  		}
3365  		case WM_CTLCOLORSTATIC:
3366  		{
3367  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
3368  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3369  			bool isStaticText = (dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_STATIC1 ||
3370  				dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_STATIC2 ||
3371  				dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_PATHLABEL_STATIC);
3372  			if (isStaticText)
3373  			{
3374  				bool isTextEnabled = isCheckedOrNot(IDC_BACKUPDIR_RESTORESESSION_CHECK);
3375  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3376  			}
3377  			if (dlgCtrlID == IDD_BACKUPDIR_STATIC)
3378  			{
3379  				bool isTextEnabled = !isCheckedOrNot(IDC_RADIO_BKNONE) && isCheckedOrNot(IDC_BACKUPDIR_CHECK);
3380  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3381  			}
3382  			if (dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT)
3383  			{
3384  				return NppDarkMode::onCtlColor(hdcStatic);
3385  			}
3386  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3387  		}
3388  		case WM_PRINTCLIENT:
3389  		{
3390  			if (NppDarkMode::isEnabled())
3391  			{
3392  				return TRUE;
3393  			}
3394  			break;
3395  		}
3396  		case WM_COMMAND : 
3397  		{
3398  			if (HIWORD(wParam) == EN_CHANGE)
3399  			{
3400  				switch (LOWORD(wParam))
3401  				{
3402  					case  IDC_BACKUPDIR_EDIT:
3403  					{
3404  						TCHAR inputDir[MAX_PATH] = {'\0'};
3405  						::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
3406  						nppGUI._backupDir = inputDir;
3407  						return TRUE;
3408  					}
3409  					case IDC_BACKUPDIR_RESTORESESSION_EDIT:
3410  					{
3411  						constexpr int stringSize = 16;
3412  						TCHAR str[stringSize]{};
3413  						::GetDlgItemText(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, str, stringSize);
3414  						if (lstrcmp(str, TEXT("")) == 0)
3415  							return TRUE;
3416  						nppGUI._snapshotBackupTiming = ::GetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, NULL, FALSE) * 1000;
3417  						if (!nppGUI._snapshotBackupTiming)
3418  						{
3419  							nppGUI._snapshotBackupTiming = 1000;
3420  							::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, 1, FALSE);
3421  						}
3422  						return TRUE;
3423  					}
3424  				}
3425  			}
3426  			else if (HIWORD(wParam) == EN_KILLFOCUS)
3427  			{
3428  				switch (LOWORD(wParam))
3429  				{
3430  					case  IDC_BACKUPDIR_RESTORESESSION_EDIT:
3431  					{
3432  						constexpr int stringSize = 16;
3433  						TCHAR str[stringSize]{};
3434  						::GetDlgItemText(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, str, stringSize);
3435  						if (lstrcmp(str, TEXT("")) == 0)
3436  						{
3437  							::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, static_cast<int32_t>(nppGUI._snapshotBackupTiming / 1000), FALSE);
3438  						}
3439  					}
3440  				}
3441  			}
3442  			switch (wParam)
3443  			{
3444  				case IDC_CHECK_REMEMBERSESSION:
3445  				{
3446  					nppGUI._rememberLastSession = isCheckedOrNot(IDC_CHECK_REMEMBERSESSION);
3447  					if (!nppGUI._rememberLastSession)
3448  					{
3449  						::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3450  						::SendMessage(_hSelf, WM_COMMAND, IDC_BACKUPDIR_RESTORESESSION_CHECK, 0);
3451  					}
3452  					updateBackupSessionGUI();
3453  					return TRUE;
3454  				}
3455  				case IDC_BACKUPDIR_RESTORESESSION_CHECK:
3456  				{
3457  					nppGUI._isSnapshotMode = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_GETCHECK, 0, 0);
3458  					updateBackupSessionGUI();
3459  					if (nppGUI._isSnapshotMode)
3460  					{
3461  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_ENABLESNAPSHOT, 0, 0);
3462  					}
3463  					return TRUE;
3464  				}
3465  				case IDC_RADIO_BKSIMPLE:
3466  				{
3467  					nppGUI._backup = bak_simple;
3468  					updateBackupOnSaveGUI();
3469  					return TRUE;
3470  				}
3471  				case IDC_RADIO_BKVERBOSE:
3472  				{
3473  					nppGUI._backup = bak_verbose;
3474  					updateBackupOnSaveGUI();
3475  					return TRUE;
3476  				}
3477  				case IDC_RADIO_BKNONE:
3478  				{
3479  					nppGUI._backup = bak_none;
3480  					updateBackupOnSaveGUI();
3481  					return TRUE;
3482  				}
3483  				case IDC_BACKUPDIR_CHECK:
3484  				{
3485  					nppGUI._useDir = !nppGUI._useDir;
3486  					updateBackupOnSaveGUI();
3487  					return TRUE;
3488  				}
3489  				case IDD_BACKUPDIR_BROWSE_BUTTON :
3490  				{
3491  					generic_string title = nppParam.getNativeLangSpeaker()->getLocalizedStrFromID("backup-select-folder",
3492  						TEXT("Select a folder as backup directory"));
3493  					folderBrowser(_hSelf, title, IDC_BACKUPDIR_EDIT);
3494  					return TRUE;
3495  				}
3496  				default :
3497  					return FALSE;
3498  			}
3499  		}
3500  	}
3501  	return FALSE;
3502  }
3503  void BackupSubDlg::updateBackupSessionGUI()
3504  {
3505  	bool rememberSession = isCheckedOrNot(IDC_CHECK_REMEMBERSESSION);
3506  	bool isSnapshot = isCheckedOrNot(IDC_BACKUPDIR_RESTORESESSION_CHECK);
3507  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK), rememberSession);
3508  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT), isSnapshot);
3509  	::EnableWindow(::GetDlgItem(_hSelf, IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT), isSnapshot);
3510  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_STATIC1);
3511  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_STATIC2);
3512  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_PATHLABEL_STATIC);
3513  }
3514  void BackupSubDlg::updateBackupOnSaveGUI()
3515  {
3516  	bool noBackup = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_BKNONE, BM_GETCHECK, 0, 0);
3517  	bool isEnableGlobableCheck = false;
3518  	bool isEnableLocalCheck = false;
3519  	if (!noBackup)
3520  	{
3521  		isEnableGlobableCheck = true;
3522  		isEnableLocalCheck = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_CHECK, BM_GETCHECK, 0, 0);
3523  	}
3524  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_CHECK), isEnableGlobableCheck);
3525  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_EDIT), isEnableLocalCheck);
3526  	::EnableWindow(::GetDlgItem(_hSelf, IDD_BACKUPDIR_BROWSE_BUTTON), isEnableLocalCheck);
3527  	if (NppDarkMode::isEnabled())
3528  	{
3529  		::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC), !noBackup);
3530  		redrawDlgItem(IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC);
3531  	}
3532  }
3533  intptr_t CALLBACK AutoCompletionSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3534  {
3535  	NppParameters& nppParam = NppParameters::getInstance();
3536  	NppGUI & nppGUI = nppParam.getNppGUI();
3537  	switch (message) 
3538  	{
3539  		case WM_INITDIALOG :
3540  		{
3541  			::SetDlgItemInt(_hSelf, IDD_AUTOC_STATIC_N,  nppGUI._autocFromLen, FALSE);
3542  			const HWND hNbCharSlider = ::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER);
3543  			::SendMessage(hNbCharSlider, TBM_SETRANGEMIN, TRUE, AUTOCOMPLETEFROMCHAR_SMALLEST);
3544  			::SendMessage(hNbCharSlider, TBM_SETRANGEMAX, TRUE, AUTOCOMPLETEFROMCHAR_LARGEST);
3545  			::SendMessage(hNbCharSlider, TBM_SETPAGESIZE, 0, AUTOCOMPLETEFROMCHAR_INTERVAL);
3546  			::SendMessage(hNbCharSlider, TBM_SETPOS, TRUE, nppGUI._autocFromLen);
3547  			bool isEnableAutoC = nppGUI._autocStatus != nppGUI.autoc_none;
3548  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_ENABLECHECK, BM_SETCHECK, isEnableAutoC?BST_CHECKED:BST_UNCHECKED, 0);
3549  			int selectedID = IDD_AUTOC_BOTHRADIO;
3550  			if (nppGUI._autocStatus == nppGUI.autoc_func)
3551  				selectedID = IDD_AUTOC_FUNCRADIO;
3552  			else if (nppGUI._autocStatus == nppGUI.autoc_word)
3553  				selectedID = IDD_AUTOC_WORDRADIO;
3554  			else if (nppGUI._autocStatus == nppGUI.autoc_both)
3555  				selectedID = IDD_AUTOC_BOTHRADIO;
3556  			::SendDlgItemMessage(_hSelf, selectedID, BM_SETCHECK, BST_CHECKED, 0);
3557  			if (nppGUI._autocStatus == nppGUI.autoc_word || nppGUI._autocStatus == nppGUI.autoc_both)
3558  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, nppGUI._autocIgnoreNumbers ? BST_CHECKED : BST_UNCHECKED, 0);
3559  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_USEENTER, BM_SETCHECK, nppGUI._autocInsertSelectedUseENTER ? BST_CHECKED : BST_UNCHECKED, 0);
3560  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_USETAB, BM_SETCHECK, nppGUI._autocInsertSelectedUseTAB ? BST_CHECKED : BST_UNCHECKED, 0);
3561  			if (!isEnableAutoC)
3562  			{
3563  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_FUNCRADIO), FALSE);
3564  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_WORDRADIO), FALSE);
3565  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BRIEF_CHECK), FALSE);
3566  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BOTHRADIO), FALSE);
3567  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEENTER), FALSE);
3568  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USETAB), FALSE);
3569  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), FALSE);
3570  				::EnableWindow(::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER), FALSE);
3571  				if (NppDarkMode::isEnabled())
3572  				{
3573  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), FALSE);
3574  				}
3575  			}
3576  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MAINTAININDENT, BM_SETCHECK, nppGUI._maitainIndent, 0);
3577  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, nppGUI._autocBrief ? BST_CHECKED : BST_UNCHECKED, 0);
3578  			::SendDlgItemMessage(_hSelf, IDD_FUNC_CHECK, BM_SETCHECK, nppGUI._funcParams ? BST_CHECKED : BST_UNCHECKED, 0);
3579  			::SendDlgItemMessage(_hSelf, IDD_AUTOCPARENTHESES_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doParentheses?BST_CHECKED:BST_UNCHECKED, 0);
3580  			if (nppGUI._matchedPairConf._doParentheses)
3581  				::SendDlgItemMessage(_hSelf, IDD_AUTOCPARENTHESES_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" (  )")));
3582  			::SendDlgItemMessage(_hSelf, IDD_AUTOCBRACKET_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doBrackets?BST_CHECKED:BST_UNCHECKED, 0);
3583  			if (nppGUI._matchedPairConf._doBrackets)
3584  				::SendDlgItemMessage(_hSelf, IDD_AUTOCBRACKET_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" [  ]")));
3585  			::SendDlgItemMessage(_hSelf, IDD_AUTOCCURLYBRACKET_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doCurlyBrackets?BST_CHECKED:BST_UNCHECKED, 0);
3586  			if (nppGUI._matchedPairConf._doCurlyBrackets)
3587  				::SendDlgItemMessage(_hSelf, IDD_AUTOCCURLYBRACKET_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" {  }")));
3588  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_QUOTESCHECK, BM_SETCHECK, nppGUI._matchedPairConf._doQuotes?BST_CHECKED:BST_UNCHECKED, 0);
3589  			if (nppGUI._matchedPairConf._doQuotes)
3590  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_QUOTESCHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" '  '")));
3591  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_DOUBLEQUOTESCHECK, BM_SETCHECK, nppGUI._matchedPairConf._doDoubleQuotes?BST_CHECKED:BST_UNCHECKED, 0);
3592  			if (nppGUI._matchedPairConf._doDoubleQuotes)
3593  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_DOUBLEQUOTESCHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" \"  \"")));
3594  			::SendDlgItemMessage(_hSelf, IDD_AUTOCTAG_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doHtmlXmlTag?BST_CHECKED:BST_UNCHECKED, 0);
3595  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, EM_LIMITTEXT, 1, 0);
3596  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, EM_LIMITTEXT, 1, 0);
3597  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, EM_LIMITTEXT, 1, 0);
3598  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, EM_LIMITTEXT, 1, 0);
3599  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, EM_LIMITTEXT, 1, 0);
3600  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, EM_LIMITTEXT, 1, 0);
3601  			size_t nbMatchedPair = nppGUI._matchedPairConf._matchedPairsInit.size();
3602  			if (nbMatchedPair > 3)
3603  				nbMatchedPair = 3;
3604  			for (size_t i = 0; i < nbMatchedPair; ++i)
3605  			{
3606  				TCHAR openChar[2]{};
3607  				openChar[0] = nppGUI._matchedPairConf._matchedPairsInit[i].first;
3608  				openChar[1] = '\0';
3609  				TCHAR closeChar[2]{};
3610  				closeChar[0] = nppGUI._matchedPairConf._matchedPairsInit[i].second;
3611  				closeChar[1] = '\0';
3612  				if (i == 0)
3613  				{
3614  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3615  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3616  				}
3617  				else if (i == 1)
3618  				{
3619  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3620  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3621  				}
3622  				if (i == 2)
3623  				{
3624  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3625  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3626  				}
3627  			}
3628  			return TRUE;
3629  		}
3630  		case WM_CTLCOLOREDIT:
3631  		{
3632  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3633  		}
3634  		case WM_CTLCOLORDLG:
3635  		{
3636  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3637  		}
3638  		case WM_CTLCOLORSTATIC:
3639  		{
3640  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
3641  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3642  			const bool isStaticText = (dlgCtrlID == IDD_AUTOC_STATIC_FROM ||
3643  				dlgCtrlID == IDD_AUTOC_STATIC_CHAR ||
3644  				dlgCtrlID == IDD_AUTOC_STATIC_N ||
3645  				dlgCtrlID == IDD_AUTOC_SLIDER_MIN_STATIC ||
3646  				dlgCtrlID == IDD_AUTOC_SLIDER_MAX_STATIC);
3647  			if (isStaticText)
3648  			{
3649  				const bool isTextEnabled = isCheckedOrNot(IDD_AUTOC_ENABLECHECK);
3650  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3651  			}
3652  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3653  		}
3654  		case WM_PRINTCLIENT:
3655  		{
3656  			if (NppDarkMode::isEnabled())
3657  			{
3658  				return TRUE;
3659  			}
3660  			break;
3661  		}
3662  		case WM_HSCROLL:
3663  		{
3664  			const HWND hNbCharSlider = ::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER);
3665  			if (hNbCharSlider == reinterpret_cast<HWND>(lParam))
3666  			{
3667  				nppGUI._autocFromLen = static_cast<UINT>(::SendMessage(hNbCharSlider, TBM_GETPOS, 0, 0));
3668  				::SetDlgItemInt(_hSelf, IDD_AUTOC_STATIC_N, nppGUI._autocFromLen, FALSE);
3669  			}
3670  			return 0; 
3671  		}
3672  		case WM_COMMAND : 
3673  		{
3674  			if (HIWORD(wParam) == EN_CHANGE)
3675  			{
3676  				switch (LOWORD(wParam))
3677  				{
3678  					case IDC_MACHEDPAIROPEN_EDIT1 :
3679  					case IDC_MACHEDPAIRCLOSE_EDIT1:
3680  					case IDC_MACHEDPAIROPEN_EDIT2 :
3681  					case IDC_MACHEDPAIRCLOSE_EDIT2:
3682  					case IDC_MACHEDPAIROPEN_EDIT3 :
3683  					case IDC_MACHEDPAIRCLOSE_EDIT3:
3684  					{
3685  						nppGUI._matchedPairConf._matchedPairs.clear();
3686  						TCHAR opener[2] = {'\0', '\0'};
3687  						TCHAR closer[2] = {'\0', '\0'};
3688  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3689  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3690  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3691  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3692  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3693  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3694  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3695  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3696  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3697  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3698  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3699  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3700  						return TRUE;
3701  					}
3702  				}
3703  			}
3704  			switch (wParam)
3705  			{
3706  				case IDC_CHECK_MAINTAININDENT:
3707  				{
3708  					nppGUI._maitainIndent = isCheckedOrNot(IDC_CHECK_MAINTAININDENT);
3709  					return TRUE;
3710  				}
3711  				case IDD_AUTOC_ENABLECHECK :
3712  				{
3713  					bool isEnableAutoC = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_AUTOC_ENABLECHECK, BM_GETCHECK, 0, 0);
3714  					if (isEnableAutoC)
3715  					{
3716  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BOTHRADIO, BM_SETCHECK, BST_CHECKED, 0);
3717  						nppGUI._autocStatus = nppGUI.autoc_both;
3718  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3719  						nppGUI._autocIgnoreNumbers = false;
3720  					}
3721  					else 
3722  					{
3723  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_FUNCRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3724  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_WORDRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3725  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BOTHRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3726  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3727  						nppGUI._autocBrief = false;
3728  						nppGUI._autocStatus = nppGUI.autoc_none;
3729  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3730  						nppGUI._autocIgnoreNumbers = false;
3731  					}
3732  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_FUNCRADIO), isEnableAutoC);
3733  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_WORDRADIO), isEnableAutoC);
3734  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BOTHRADIO), isEnableAutoC);
3735  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BRIEF_CHECK), isEnableAutoC);
3736  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
3737  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEENTER), isEnableAutoC);
3738  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USETAB), isEnableAutoC);
3739  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), isEnableAutoC);
3740  					::EnableWindow(::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER), isEnableAutoC);
3741  					redrawDlgItem(IDD_AUTOC_STATIC_FROM);
3742  					redrawDlgItem(IDD_AUTOC_STATIC_N);
3743  					redrawDlgItem(IDD_AUTOC_STATIC_CHAR);
3744  					redrawDlgItem(IDD_AUTOC_SLIDER_MIN_STATIC);
3745  					redrawDlgItem(IDD_AUTOC_SLIDER_MAX_STATIC);
3746  					if (NppDarkMode::isEnabled())
3747  					{
3748  						::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
3749  						redrawDlgItem(IDD_AUTOC_USEKEY_GRP_STATIC);
3750  					}
3751  					return TRUE;
3752  				}
3753  				case IDD_AUTOC_FUNCRADIO :
3754  				{
3755  					nppGUI._autocStatus = nppGUI.autoc_func;
3756  					::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3757  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), FALSE);
3758  					nppGUI._autocIgnoreNumbers = false;
3759  					::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3760  					nppGUI._autocBrief = false;
3761  					return TRUE;
3762  				}
3763  				case IDD_AUTOC_WORDRADIO :
3764  				{
3765  					nppGUI._autocStatus = nppGUI.autoc_word;
3766  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), TRUE);
3767  					return TRUE;
3768  				}
3769  				case IDD_AUTOC_BOTHRADIO :
3770  				{
3771  					nppGUI._autocStatus = nppGUI.autoc_both;
3772  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), TRUE);
3773  					return TRUE;
3774  				}
3775  				case IDD_AUTOC_USEENTER:
3776  				{
3777  					nppGUI._autocInsertSelectedUseENTER = isCheckedOrNot(static_cast<int32_t>(wParam));
3778  					return TRUE;
3779  				}
3780  				case IDD_AUTOC_USETAB:
3781  				{
3782  					nppGUI._autocInsertSelectedUseTAB = isCheckedOrNot(static_cast<int32_t>(wParam));
3783  					return TRUE;
3784  				}
3785  				case IDD_AUTOC_IGNORENUMBERS:
3786  				{
3787  					nppGUI._autocIgnoreNumbers = isCheckedOrNot(static_cast<int32_t>(wParam));
3788  					return TRUE;
3789  				}
3790  				case IDD_AUTOC_BRIEF_CHECK :
3791  				{
3792  					nppGUI._autocBrief = isCheckedOrNot(static_cast<int32_t>(wParam));
3793  					return TRUE;
3794  				}
3795  				case IDD_FUNC_CHECK :
3796  				{
3797  					nppGUI._funcParams = isCheckedOrNot(static_cast<int32_t>(wParam));
3798  					return TRUE;
3799  				}
3800  				case IDD_AUTOCPARENTHESES_CHECK :
3801  				case IDD_AUTOCBRACKET_CHECK :
3802  				case IDD_AUTOCCURLYBRACKET_CHECK :
3803  				case IDD_AUTOC_DOUBLEQUOTESCHECK :
3804  				case IDD_AUTOC_QUOTESCHECK :
3805  				{
3806  					bool isChecked = isCheckedOrNot(static_cast<int32_t>(wParam));
3807  					const TCHAR *label = nullptr;
3808  					if (wParam == IDD_AUTOCPARENTHESES_CHECK)
3809  					{
3810  						nppGUI._matchedPairConf._doParentheses = isChecked;
3811  						label = isChecked?TEXT(" (  )"):TEXT(" (");
3812  					}
3813  					else if (wParam == IDD_AUTOCBRACKET_CHECK)
3814  					{
3815  						nppGUI._matchedPairConf._doBrackets = isChecked;
3816  						label = isChecked?TEXT(" [  ]"):TEXT(" [");
3817  					}
3818  					else if (wParam == IDD_AUTOCCURLYBRACKET_CHECK)
3819  					{
3820  						nppGUI._matchedPairConf._doCurlyBrackets = isChecked;
3821  						label = isChecked?TEXT(" {  }"):TEXT(" {");
3822  					}
3823  					else if (wParam == IDD_AUTOC_DOUBLEQUOTESCHECK)
3824  					{
3825  						nppGUI._matchedPairConf._doDoubleQuotes = isChecked;
3826  						label = isChecked?TEXT(" \"  \""):TEXT(" \"");
3827  					}
3828  					else 
3829  					{
3830  						nppGUI._matchedPairConf._doQuotes = isChecked;
3831  						label = isChecked?TEXT(" '  '"):TEXT(" '");
3832  					}
3833  					::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), WM_SETTEXT, 0, reinterpret_cast<LPARAM>(label));
3834  					return TRUE;
3835  				}
3836  				case IDD_AUTOCTAG_CHECK :
3837  				{
3838  					nppGUI._matchedPairConf._doHtmlXmlTag = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_AUTOCTAG_CHECK, BM_GETCHECK, 0, 0));
3839  					return TRUE;
3840  				}
3841  				default :
3842  					return FALSE;
3843  			}
3844  		}
3845  	}
3846  	return FALSE;
3847  }
3848  intptr_t CALLBACK MultiInstanceSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
3849  {
3850  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3851  	switch (message) 
3852  	{
3853  		case WM_INITDIALOG :
3854  		{
3855  			auto checkOrUncheckBtn = [this](int id, bool check) -> void
3856  			{
3857  				::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, check ? BST_CHECKED : BST_UNCHECKED, 0);
3858  			};
3859  			checkOrUncheckBtn(IDC_CHECK_CLIPBOARDHISTORY, nppGUI._clipboardHistoryPanelKeepState);
3860  			checkOrUncheckBtn(IDC_CHECK_DOCLIST, nppGUI._docListKeepState);
3861  			checkOrUncheckBtn(IDC_CHECK_CHARPANEL, nppGUI._charPanelKeepState);
3862  			checkOrUncheckBtn(IDC_CHECK_FILEBROWSER, nppGUI._fileBrowserKeepState);
3863  			checkOrUncheckBtn(IDC_CHECK_PROJECTPANEL, nppGUI._projectPanelKeepState);
3864  			checkOrUncheckBtn(IDC_CHECK_DOCMAP, nppGUI._docMapKeepState);
3865  			checkOrUncheckBtn(IDC_CHECK_FUNCLIST, nppGUI._funcListKeepState);
3866  			checkOrUncheckBtn(IDC_CHECK_PLUGINPANEL, nppGUI._pluginPanelKeepState);
3867  			MultiInstSetting multiInstSetting = nppGUI._multiInstSetting;
3868  			::SendDlgItemMessage(_hSelf, IDC_SESSIONININST_RADIO, BM_SETCHECK, multiInstSetting == multiInstOnSession?BST_CHECKED:BST_UNCHECKED, 0);
3869  			::SendDlgItemMessage(_hSelf, IDC_MULTIINST_RADIO, BM_SETCHECK, multiInstSetting == multiInst?BST_CHECKED:BST_UNCHECKED, 0);
3870  			::SendDlgItemMessage(_hSelf, IDC_MONOINST_RADIO, BM_SETCHECK, multiInstSetting == monoInst?BST_CHECKED:BST_UNCHECKED, 0);
3871  			::SendDlgItemMessage(_hSelf, IDD_DATETIMEFORMAT_REVERSEORDER_CHECK, BM_SETCHECK, nppGUI._dateTimeReverseDefaultOrder ? BST_CHECKED : BST_UNCHECKED, 0);
3872  			::SetDlgItemText(_hSelf, IDC_DATETIMEFORMAT_EDIT, nppGUI._dateTimeFormat.c_str());
3873  			generic_string datetimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, _BTTF_time);
3874  			::SetDlgItemText(_hSelf, IDD_DATETIMEFORMAT_RESULT_STATIC, datetimeStr.c_str());
3875  			return TRUE;
3876  		}
3877  		case WM_CTLCOLOREDIT:
3878  		{
3879  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3880  		}
3881  		case WM_CTLCOLORDLG:
3882  		case WM_CTLCOLORSTATIC:
3883  		{
3884  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3885  		}
3886  		case WM_PRINTCLIENT:
3887  		{
3888  			if (NppDarkMode::isEnabled())
3889  			{
3890  				return TRUE;
3891  			}
3892  			break;
3893  		}
3894  		case WM_COMMAND : 
3895  		{
3896  			if (HIWORD(wParam) == EN_CHANGE && LOWORD(wParam) == IDC_DATETIMEFORMAT_EDIT)
3897  			{
3898  				constexpr size_t inputLen = 256;
3899  				TCHAR input[inputLen]{};
3900  				::GetDlgItemText(_hSelf, IDC_DATETIMEFORMAT_EDIT, input, inputLen);
3901  				nppGUI._dateTimeFormat = input;
3902  				generic_string datetimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, _BTTF_time);
3903  				::SetDlgItemText(_hSelf, IDD_DATETIMEFORMAT_RESULT_STATIC, datetimeStr.c_str());
3904  				return TRUE;
3905  			}
3906  			switch (wParam)
3907  			{
3908  				case IDC_SESSIONININST_RADIO :
3909  				{
3910  					nppGUI._multiInstSetting = multiInstOnSession;
3911  				}
3912  				break;
3913  				case IDC_MULTIINST_RADIO :
3914  				{
3915  					nppGUI._multiInstSetting = multiInst;
3916  				}
3917  				break;
3918  				case IDC_MONOINST_RADIO :
3919  				{
3920  					nppGUI._multiInstSetting = monoInst;
3921  				}
3922  				break;
3923  				case IDD_DATETIMEFORMAT_REVERSEORDER_CHECK:
3924  				{
3925  					nppGUI._dateTimeReverseDefaultOrder = isCheckedOrNot(IDD_DATETIMEFORMAT_REVERSEORDER_CHECK);
3926  				}
3927  				break;
3928  				case IDC_CHECK_CLIPBOARDHISTORY:
3929  				{
3930  					nppGUI._clipboardHistoryPanelKeepState = isCheckedOrNot(IDC_CHECK_CLIPBOARDHISTORY);
3931  				}
3932  				break;
3933  				case IDC_CHECK_DOCLIST:
3934  				{
3935  					nppGUI._docListKeepState = isCheckedOrNot(IDC_CHECK_DOCLIST);
3936  				}
3937  				break;
3938  				case IDC_CHECK_CHARPANEL:
3939  				{
3940  					nppGUI._charPanelKeepState = isCheckedOrNot(IDC_CHECK_CHARPANEL);
3941  				}
3942  				break;
3943  				case IDC_CHECK_FILEBROWSER:
3944  				{
3945  					nppGUI._fileBrowserKeepState = isCheckedOrNot(IDC_CHECK_FILEBROWSER);
3946  				}
3947  				break;
3948  				case IDC_CHECK_PROJECTPANEL:
3949  				{
3950  					nppGUI._projectPanelKeepState = isCheckedOrNot(IDC_CHECK_PROJECTPANEL);
3951  				}
3952  				break;
3953  				case IDC_CHECK_DOCMAP:
3954  				{
3955  					nppGUI._docMapKeepState = isCheckedOrNot(IDC_CHECK_DOCMAP);
3956  				}
3957  				break;
3958  				case IDC_CHECK_FUNCLIST:
3959  				{
3960  					nppGUI._funcListKeepState = isCheckedOrNot(IDC_CHECK_FUNCLIST);
3961  				}
3962  				break;
3963  				case IDC_CHECK_PLUGINPANEL:
3964  				{
3965  					nppGUI._pluginPanelKeepState = isCheckedOrNot(IDC_CHECK_PLUGINPANEL);
3966  				}
3967  				break;
3968  				default :
3969  					return FALSE;
3970  			}
3971  		}
3972  		break;
3973  	}
3974  	return FALSE;
3975  }
3976  void DelimiterSubDlg::detectSpace(const char *text2Check, int & nbSp, int & nbTab) const
3977  {
3978  	nbSp = nbTab = 0;
3979  	for (size_t i = 0; i < strlen(text2Check); ++i)
3980  	{
3981  		if (text2Check[i] == ' ')
3982  			++nbSp;
3983  		else if (text2Check[i] == '\t')
3984  			++nbTab;
3985  	}
3986  }
3987  generic_string DelimiterSubDlg::getWarningText(size_t nbSp, size_t nbTab) const
3988  {
3989  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
3990  	generic_string msg;
3991  	if (nbSp && nbTab)
3992  	{
3993  		generic_string nbSpStr = std::to_wstring(nbSp);
3994  		generic_string nbTabStr = std::to_wstring(nbTab);
3995  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
3996  		generic_string space = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-space-warning", TEXT(""));
3997  		generic_string tab = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tab-warning", TEXT(""));
3998  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
3999  		if (!warnBegin.empty() && !space.empty() && !tab.empty() && !warnEnd.empty())
4000  		{
4001  			space = stringReplace(space, TEXT("$INT_REPLACE$"), nbSpStr);
4002  			tab = stringReplace(tab, TEXT("$INT_REPLACE$"), nbTabStr);
4003  			msg = warnBegin;
4004  			msg += space;
4005  			msg += TEXT(" && ");
4006  			msg += tab;
4007  			msg += warnEnd;
4008  		}
4009  		else
4010  		{
4011  			msg = TEXT("Be aware: ");
4012  			msg += nbSpStr;
4013  			msg += TEXT(" space(s) && ");
4014  			msg += std::to_wstring(nbTab);
4015  			msg += TEXT(" TAB(s) in your character list.");
4016  		}
4017  	}
4018  	else if (nbSp && !nbTab)
4019  	{
4020  		generic_string nbSpStr = std::to_wstring(nbSp);
4021  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
4022  		generic_string space = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-space-warning", TEXT(""));
4023  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
4024  		if (!warnBegin.empty() && !space.empty() && !warnEnd.empty())
4025  		{
4026  			space = stringReplace(space, TEXT("$INT_REPLACE$"), nbSpStr);
4027  			msg = warnBegin;
4028  			msg += space;
4029  			msg += warnEnd;
4030  		}
4031  		else
4032  		{
4033  			msg = TEXT("Be aware: ");
4034  			msg += std::to_wstring(nbSp);
4035  			msg += TEXT(" space(s) in your character list.");
4036  		}
4037  	}
4038  	else if (!nbSp && nbTab)
4039  	{
4040  		generic_string nbTabStr = std::to_wstring(nbTab);
4041  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
4042  		generic_string tab = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tab-warning", TEXT(""));
4043  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
4044  		if (!warnBegin.empty() && !tab.empty() && !warnEnd.empty())
4045  		{
4046  			tab = stringReplace(tab, TEXT("$INT_REPLACE$"), nbTabStr);
4047  			msg = warnBegin;
4048  			msg += tab;
4049  			msg += warnEnd;
4050  		}
4051  		else
4052  		{
4053  			msg = TEXT("Be aware: ");
4054  			msg += std::to_wstring(nbTab);
4055  			msg += TEXT(" TAB(s) in your character list.");
4056  		}
4057  	}
4058  	else 
4059  	{
4060  	}
4061  	return msg;
4062  }
4063  void DelimiterSubDlg::setWarningIfNeed() const
4064  {
4065  	generic_string msg;
4066  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4067  	if (!nppGUI._isWordCharDefault)
4068  	{
4069  		int nbSp = 0;
4070  		int nbTab = 0;
4071  		detectSpace(nppGUI._customWordChars.c_str(), nbSp, nbTab);
4072  		msg = getWarningText(nbSp, nbTab);
4073  	}
4074  	::SetDlgItemText(_hSelf, IDD_STATIC_WORDCHAR_WARNING, msg.c_str());
4075  }
4076  intptr_t CALLBACK DelimiterSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
4077  {
4078  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4079  	switch (message) 
4080  	{
4081  		case WM_INITDIALOG :
4082  		{
4083  			TCHAR opener[2]{};
4084  			opener[0] = nppGUI._leftmostDelimiter;
4085  			opener[1] = '\0';
4086  			TCHAR closer[2]{};
4087  			closer[0] = nppGUI._rightmostDelimiter;
4088  			closer[1] = '\0';
4089  			bool onSeveralLines = nppGUI._delimiterSelectionOnEntireDocument;
4090  			::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, EM_LIMITTEXT, 1, 0);
4091  			::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, EM_LIMITTEXT, 1, 0);
4092  			::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(opener));
4093  			::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closer));
4094  			::SendDlgItemMessage(_hSelf, IDD_SEVERALLINEMODEON_CHECK, BM_SETCHECK, onSeveralLines?BST_CHECKED:BST_UNCHECKED, 0);
4095  			POINT point = getTopPoint(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA), false);
4096  			_singleLineModePoint.x = point.x + 4;
4097  			_singleLineModePoint.y = point.y - 4;
4098  			point = getTopPoint(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE), false);
4099  			_multiLineModePoint.x = point.x + 4;
4100  			_multiLineModePoint.y = point.y - 4;
4101  			::GetClientRect(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), &_closerRect);
4102  			_closerRect.right = _closerRect.right - _closerRect.left + 4;
4103  			_closerRect.bottom = _closerRect.bottom - _closerRect.top + 4;
4104  			::GetClientRect(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), &_closerLabelRect);
4105  			_closerLabelRect.right = _closerLabelRect.right - _closerLabelRect.left + 4;
4106  			_closerLabelRect.bottom = _closerLabelRect.bottom - _closerLabelRect.top + 4;
4107  			::ShowWindow(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE),onSeveralLines?SW_SHOW:SW_HIDE);
4108  			POINT *p = onSeveralLines?&_multiLineModePoint:&_singleLineModePoint;
4109  			::MoveWindow(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), p->x, p->y, _closerRect.right, _closerRect.bottom, TRUE);
4110  			::MoveWindow(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), p->x + _closerRect.right + 4, p->y + 4, _closerLabelRect.right, _closerLabelRect.bottom, TRUE);
4111  			::SetDlgItemTextA(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT, nppGUI._customWordChars.c_str());
4112  			::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_DEFAULT, BM_SETCHECK, nppGUI._isWordCharDefault ? BST_CHECKED : BST_UNCHECKED, 0);
4113  			::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_CUSTOM, BM_SETCHECK, !nppGUI._isWordCharDefault ? BST_CHECKED : BST_UNCHECKED, 0);
4114  			::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4115  			setWarningIfNeed();
4116  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4117  			generic_string tip2show = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tip", TEXT("This allows you to include additional character into current word characters while double clicking for selection or searching with \"Match whole word only\" option checked."));
4118  			_tip = CreateToolTip(IDD_WORDCHAR_QUESTION_BUTTON, _hSelf, _hInst, const_cast<PTSTR>(tip2show.c_str()), pNativeSpeaker->isRTL());
4119  			if (_tip)
4120  			{
4121  				SendMessage(_tip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((30000), (0)));
4122  			}
4123  			return TRUE;
4124  		}
4125  		case WM_CTLCOLOREDIT:
4126  		{
4127  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4128  		}
4129  		case WM_CTLCOLORDLG:
4130  		{
4131  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4132  		}
4133  		case WM_CTLCOLORSTATIC:
4134  		{
4135  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4136  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4137  			bool isBlabla = (dlgCtrlID == IDD_STATIC_BLABLA) || (dlgCtrlID == IDD_STATIC_BLABLA2NDLINE);
4138  			if (NppDarkMode::isEnabled())
4139  			{
4140  				if (isBlabla)
4141  				{
4142  					return NppDarkMode::onCtlColor(hdcStatic);
4143  				}
4144  				return NppDarkMode::onCtlColorDarker(hdcStatic);
4145  			}
4146  			else if (isBlabla)
4147  			{
4148  				COLORREF bgColor = getCtrlBgColor(_hSelf);
4149  				SetTextColor(hdcStatic, RGB(0, 0, 0));
4150  				BYTE r = GetRValue(bgColor) - 30;
4151  				BYTE g = MyGetGValue(bgColor) - 30;
4152  				BYTE b = GetBValue(bgColor) - 30;
4153  				SetBkColor(hdcStatic, RGB(r, g, b));
4154  				return TRUE;
4155  			}
4156  			break;
4157  		}
4158  		case WM_PRINTCLIENT:
4159  		{
4160  			if (NppDarkMode::isEnabled())
4161  			{
4162  				return TRUE;
4163  			}
4164  			break;
4165  		}
4166  		case WM_COMMAND : 
4167  		{
4168  			if (HIWORD(wParam) == EN_CHANGE)
4169  			{
4170  				switch (LOWORD(wParam))
4171  				{
4172  					case  IDC_EDIT_OPENDELIMITER:
4173  					{
4174  						TCHAR opener[2] = { '\0' };
4175  						::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
4176  						nppGUI._leftmostDelimiter =  static_cast<char>(opener[0]);
4177  						return TRUE;
4178  					}
4179  					case  IDC_EDIT_CLOSEDELIMITER:
4180  					{
4181  						TCHAR closer[2] = { '\0' };
4182  						::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
4183  						nppGUI._rightmostDelimiter =  static_cast<char>(closer[0]);
4184  						return TRUE;
4185  					}
4186  					case  IDC_WORDCHAR_CUSTOM_EDIT:
4187  					{
4188  						char customText[MAX_PATH];
4189  						::GetDlgItemTextA(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT, customText, MAX_PATH-1);
4190  						nppGUI._customWordChars = customText;
4191  						setWarningIfNeed();
4192  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4193  						return TRUE;
4194  					}
4195  					default:
4196  						return FALSE;
4197  				}
4198  			}
4199  			switch (wParam)
4200  			{
4201  				case IDD_SEVERALLINEMODEON_CHECK :
4202  				{
4203  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_SEVERALLINEMODEON_CHECK, BM_GETCHECK, 0, 0));
4204  					nppGUI._delimiterSelectionOnEntireDocument = isChecked;
4205  					::ShowWindow(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE),isChecked?SW_SHOW:SW_HIDE);
4206  					POINT *p = isChecked?&_multiLineModePoint:&_singleLineModePoint;
4207  					::MoveWindow(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), p->x, p->y, _closerRect.right, _closerRect.bottom, TRUE);
4208  					::MoveWindow(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), p->x + _closerRect.right + 4, p->y + 4, _closerLabelRect.right, _closerLabelRect.bottom, TRUE);
4209  					return TRUE;
4210  				}
4211  				case IDC_RADIO_WORDCHAR_DEFAULT:
4212  				{
4213  					::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_CUSTOM, BM_SETCHECK, BST_UNCHECKED, 0);
4214  					nppGUI._isWordCharDefault = true;
4215  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4216  					::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4217  					::SetDlgItemText(_hSelf, IDD_STATIC_WORDCHAR_WARNING, TEXT(""));
4218  					return TRUE;
4219  				}
4220  				case IDC_RADIO_WORDCHAR_CUSTOM:
4221  				{
4222  					::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_DEFAULT, BM_SETCHECK, BST_UNCHECKED, 0);
4223  					nppGUI._isWordCharDefault = false;
4224  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4225  					::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4226  					setWarningIfNeed();
4227  					return TRUE;
4228  				}
4229  				default :
4230  					return FALSE;
4231  			}
4232  		}
4233  		break;
4234  	}
4235  	return FALSE;
4236  }
4237  intptr_t CALLBACK CloudAndLinkSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
4238  {
4239  	NppParameters& nppParams = NppParameters::getInstance();
4240  	NppGUI & nppGUI = nppParams.getNppGUI();
4241  	const size_t uriSchemesMaxLength = 2048;
4242  	if (HIWORD(wParam) == EN_CHANGE)
4243  	{
4244  		switch (LOWORD(wParam))
4245  		{
4246  			case  IDC_CLOUDPATH_EDIT:
4247  			{
4248  				TCHAR inputDir[MAX_PATH] = {'\0'};
4249  				TCHAR inputDirExpanded[MAX_PATH] = {'\0'};
4250  				::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
4251  				::ExpandEnvironmentStrings(inputDir, inputDirExpanded, MAX_PATH);
4252  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4253  				if (::PathFileExists(inputDirExpanded))
4254  				{
4255  					nppGUI._cloudPath = inputDirExpanded;
4256  					nppParams.setCloudChoice(inputDirExpanded);
4257  					generic_string message;
4258  					if (nppParams.isCloudPathChanged())
4259  					{
4260  						message = pNativeSpeaker->getLocalizedStrFromID("cloud-restart-warning", TEXT("Please restart Notepad++ to take effect."));
4261  					}
4262  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4263  				}
4264  				else
4265  				{
4266  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_WITHCLOUD_RADIO, BM_GETCHECK, 0, 0));
4267  					if (isChecked)
4268  					{
4269  						generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-invalid-warning", TEXT("Invalid path."));
4270  						::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4271  						nppParams.removeCloudChoice();
4272  					}
4273  				}
4274  				return TRUE;
4275  			}
4276  			case IDC_URISCHEMES_EDIT:
4277  			{
4278  				TCHAR uriScheme[uriSchemesMaxLength] = { '\0' };
4279  				::SendDlgItemMessage(_hSelf, IDC_URISCHEMES_EDIT, WM_GETTEXT, uriSchemesMaxLength, reinterpret_cast<LPARAM>(uriScheme));
4280  				nppGUI._uriSchemes = uriScheme;
4281  				HWND grandParent = ::GetParent(_hParent);
4282  				::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4283  				return TRUE;
4284  			}
4285  		}
4286  	}
4287  	switch (message)
4288  	{
4289  		case WM_INITDIALOG:
4290  		{
4291  			generic_string message = TEXT("");
4292  			bool withCloud = nppGUI._cloudPath != TEXT("");
4293  			if (withCloud)
4294  			{
4295  				if (!::PathFileExists(nppGUI._cloudPath.c_str()))
4296  					message = TEXT("Invalid path");
4297  			}
4298  			::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4299  			::SendDlgItemMessage(_hSelf, IDC_NOCLOUD_RADIO, BM_SETCHECK, !withCloud ? BST_CHECKED : BST_UNCHECKED, 0);
4300  			::SendDlgItemMessage(_hSelf, IDC_WITHCLOUD_RADIO, BM_SETCHECK, withCloud ? BST_CHECKED : BST_UNCHECKED, 0);
4301  			::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._cloudPath.c_str()));
4302  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), withCloud);
4303  			::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), withCloud);
4304  			BOOL linkEnable = nppGUI._styleURL != urlDisable;
4305  			BOOL dontUnderline = (nppGUI._styleURL == urlNoUnderLineFg) || (nppGUI._styleURL == urlNoUnderLineBg);
4306  			BOOL roundBoxMode = (nppGUI._styleURL == urlNoUnderLineBg) || (nppGUI._styleURL == urlUnderLineBg);
4307  			::SendDlgItemMessage(_hSelf, IDC_URISCHEMES_EDIT, EM_SETLIMITTEXT, uriSchemesMaxLength, 0);
4308  			::SetWindowText(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), nppGUI._uriSchemes.c_str());
4309  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_ENABLE, BM_SETCHECK, linkEnable, 0);
4310  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE, BM_SETCHECK, dontUnderline, 0);
4311  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE, BM_SETCHECK, roundBoxMode, 0);
4312  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE), linkEnable);
4313  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE), linkEnable);
4314  			::EnableWindow(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), linkEnable);
4315  			return TRUE;
4316  		}
4317  		case WM_CTLCOLOREDIT:
4318  		{
4319  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4320  		}
4321  		case WM_CTLCOLORDLG:
4322  		{
4323  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4324  		}
4325  		case WM_CTLCOLORSTATIC:
4326  		{
4327  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4328  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4329  			bool isStaticText = dlgCtrlID == IDC_URISCHEMES_STATIC;
4330  			if (isStaticText)
4331  			{
4332  				bool isTextEnabled = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_ENABLE);
4333  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
4334  			}
4335  			return NppDarkMode::onCtlColorDarker(hdcStatic);
4336  		}
4337  		case WM_PRINTCLIENT:
4338  		{
4339  			if (NppDarkMode::isEnabled())
4340  			{
4341  				return TRUE;
4342  			}
4343  			break;
4344  		}
4345  		case WM_COMMAND:
4346  		{
4347  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4348  			switch (wParam)
4349  			{
4350  				case IDC_NOCLOUD_RADIO:
4351  				{
4352  					nppGUI._cloudPath = TEXT("");
4353  					nppParams.removeCloudChoice();
4354  					generic_string message;
4355  					if (nppParams.isCloudPathChanged())
4356  					{
4357  						message = pNativeSpeaker->getLocalizedStrFromID("cloud-restart-warning", TEXT("Please restart Notepad++ to take effect."));
4358  					}
4359  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4360  					::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._cloudPath.c_str()));
4361  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), false);
4362  					::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), false);
4363  				}
4364  				break;
4365  				case IDC_WITHCLOUD_RADIO:
4366  				{
4367  					generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-invalid-warning", TEXT("Invalid path."));
4368  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4369  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), true);
4370  					::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), true);
4371  				}
4372  				break;
4373  				case IDD_CLOUDPATH_BROWSE_BUTTON:
4374  				{
4375  					generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-select-folder", TEXT("Select a folder from/to where Notepad++ reads/writes its settings"));
4376  					folderBrowser(_hSelf, message, IDC_CLOUDPATH_EDIT);
4377  				}
4378  				break;
4379  				case IDC_CHECK_CLICKABLELINK_ENABLE:
4380  				{
4381  					bool isChecked = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_ENABLE);
4382  					if (!isChecked)
4383  					{
4384  						::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE, BM_SETCHECK, BST_UNCHECKED, 0);
4385  						::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE, BM_SETCHECK, BST_UNCHECKED, 0);
4386  					}
4387  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE), isChecked);
4388  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE), isChecked);
4389  					::EnableWindow(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), isChecked);
4390  					redrawDlgItem(IDC_CLICKABLELINK_STATIC);
4391  					nppGUI._styleURL = isChecked ? urlUnderLineFg : urlDisable;
4392  					HWND grandParent = ::GetParent(_hParent);
4393  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4394  				}
4395  				return TRUE;
4396  				case IDC_CHECK_CLICKABLELINK_NOUNDERLINE:
4397  				case IDC_CHECK_CLICKABLELINK_FULLBOXMODE:
4398  				{
4399  					bool isNoUnderline = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_NOUNDERLINE);
4400  					bool isRoundBoxMode = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_FULLBOXMODE);
4401  					if (isRoundBoxMode)
4402  						nppGUI._styleURL = isNoUnderline ? urlNoUnderLineBg : urlUnderLineBg;
4403  					else
4404  						nppGUI._styleURL = isNoUnderline ? urlNoUnderLineFg : urlUnderLineFg;
4405  					HWND grandParent = ::GetParent(_hParent);
4406  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4407  				}
4408  				return TRUE;
4409  				default:
4410  					return FALSE;
4411  			}
4412  		}																						
4413  	}
4414  	return FALSE;
4415  }
4416  intptr_t CALLBACK PerformanceSubDlg::run_dlgProc(UINT message , WPARAM wParam, LPARAM lParam)
4417  {
4418  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
4419  	if (HIWORD(wParam) == EN_CHANGE)
4420  	{
4421  		switch (LOWORD(wParam))
4422  		{
4423  			case  IDC_EDIT_PERFORMANCE_FILESIZE:
4424  			{
4425  				constexpr int stringSize = 16;
4426  				TCHAR str[stringSize]{};
4427  				::GetDlgItemText(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, str, stringSize);
4428  				if (lstrcmp(str, TEXT("")) == 0)
4429  					return TRUE;
4430  				int64_t fileLenInMB = ::GetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, NULL, FALSE);
4431  				if (fileLenInMB > 4096)
4432  				{
4433  					fileLenInMB = 4096;
4434  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4435  				}
4436  				nppGUI._largeFileRestriction._largeFileSizeDefInByte = fileLenInMB * 1024 * 1024;
4437  			}
4438  			return TRUE;
4439  		}
4440  	}
4441  	else if (HIWORD(wParam) == EN_KILLFOCUS)
4442  	{
4443  		switch (LOWORD(wParam))
4444  		{
4445  			case  IDC_EDIT_PERFORMANCE_FILESIZE:
4446  			{
4447  				constexpr int stringSize = 16;
4448  				TCHAR str[stringSize]{};
4449  				::GetDlgItemText(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, str, stringSize);
4450  				if (lstrcmp(str, TEXT("")) == 0)
4451  				{
4452  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, (NPP_STYLING_FILESIZE_LIMIT_DEFAULT / 1024) / 1024, FALSE);
4453  					return TRUE;
4454  				}
4455  				int64_t fileLenInMB = ::GetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, NULL, FALSE);
4456  				if (fileLenInMB == 0)
4457  				{
4458  					fileLenInMB = (NPP_STYLING_FILESIZE_LIMIT_DEFAULT / 1024) / 1024;
4459  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4460  					return TRUE;
4461  				}
4462  			}
4463  			return TRUE;
4464  		}
4465  	}
4466  	switch (message)
4467  	{
4468  		case WM_INITDIALOG:
4469  		{
4470  			int64_t fileLenInMB = (nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024;
4471  			::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4472  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ENABLE, BM_SETCHECK, nppGUI._largeFileRestriction._isEnabled ? BST_CHECKED : BST_UNCHECKED, 0);
4473  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH, BM_SETCHECK, nppGUI._largeFileRestriction._allowBraceMatch ? BST_CHECKED : BST_UNCHECKED, 0);
4474  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION, BM_SETCHECK, nppGUI._largeFileRestriction._allowAutoCompletion ? BST_CHECKED : BST_UNCHECKED, 0);
4475  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE, BM_SETCHECK, nppGUI._largeFileRestriction._allowSmartHilite ? BST_CHECKED : BST_UNCHECKED, 0);
4476  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK, BM_SETCHECK, nppGUI._largeFileRestriction._allowClickableLink ? BST_CHECKED : BST_UNCHECKED, 0);
4477  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP, BM_SETCHECK, nppGUI._largeFileRestriction._deactivateWordWrap ? BST_CHECKED : BST_UNCHECKED, 0);
4478  			bool largeFileRestrictionEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4479  			::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE), largeFileRestrictionEnabled);
4480  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH), largeFileRestrictionEnabled);
4481  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION), largeFileRestrictionEnabled);
4482  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE), largeFileRestrictionEnabled);
4483  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK), largeFileRestrictionEnabled);
4484  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP), largeFileRestrictionEnabled);
4485  			NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4486  			generic_string enablePerfTip = pNativeSpeaker->getLocalizedStrFromID("largeFileRestriction-tip", TEXT("Some features may slow performance in large files. These features can be auto-disabled on opening a large file. You can customize them here.\n\nNOTE:\n1. Modifying options here requires re-open currently opened large files to get proper behavior.\n\n2. If \"Deactivate Word Wrap globally\" is checked and you open a large file, \"Word Wrap\" will be disabled for all files. You can re-enable it via menu \"View->Word Wrap\""));
4487  			_largeFileRestrictionTip = CreateToolTip(IDD_PERFORMANCE_TIP_QUESTION_BUTTON, _hSelf, _hInst, const_cast<PTSTR>(enablePerfTip.c_str()), false);
4488  			return TRUE;
4489  		}
4490  		case WM_CTLCOLOREDIT:
4491  		{
4492  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4493  		}
4494  		case WM_CTLCOLORDLG:
4495  		{
4496  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4497  		}
4498  		case WM_CTLCOLORSTATIC:
4499  		{
4500  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4501  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4502  			bool isStaticText = (dlgCtrlID == IDC_STATIC_PERFORMANCE_FILESIZE || dlgCtrlID == IDC_STATIC_PERFORMANCE_MB);
4503  			if (isStaticText)
4504  			{
4505  				bool isTextEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4506  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
4507  			}
4508  			if (dlgCtrlID == IDC_EDIT_PERFORMANCE_FILESIZE)
4509  			{
4510  				return NppDarkMode::onCtlColor(hdcStatic);
4511  			}
4512  			return NppDarkMode::onCtlColorDarker(hdcStatic);
4513  		}
4514  		case WM_PRINTCLIENT:
4515  		{
4516  			if (NppDarkMode::isEnabled())
4517  			{
4518  				return TRUE;
4519  			}
4520  			break;
4521  		}
4522  		case WM_COMMAND:
4523  		{
4524  			switch (wParam)
4525  			{
4526  				case IDC_CHECK_PERFORMANCE_ENABLE:
4527  				{
4528  					bool largeFileRestrictionEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4529  					nppGUI._largeFileRestriction._isEnabled = largeFileRestrictionEnabled;
4530  					::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE), largeFileRestrictionEnabled);
4531  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH), largeFileRestrictionEnabled);
4532  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION), largeFileRestrictionEnabled);
4533  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE), largeFileRestrictionEnabled);
4534  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK), largeFileRestrictionEnabled);
4535  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP), largeFileRestrictionEnabled);
4536  					redrawDlgItem(IDC_STATIC_PERFORMANCE_FILESIZE);
4537  					redrawDlgItem(IDC_STATIC_PERFORMANCE_MB);
4538  					if (largeFileRestrictionEnabled)
4539  					{
4540  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANSMARTHILITING, 0, 0);
4541  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANBRACEMATCH, 0, 0);
4542  					}
4543  					else
4544  					{
4545  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4546  					}
4547  				}
4548  				return TRUE;
4549  				case IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH:
4550  				{
4551  					bool isAllowed = isCheckedOrNot(int(wParam));
4552  					nppGUI._largeFileRestriction._allowBraceMatch = isAllowed;
4553  					if (!isAllowed)
4554  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANBRACEMATCH, 0, 0);
4555  				}
4556  				return TRUE;
4557  				case IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION:
4558  				{
4559  					bool isAllowed = isCheckedOrNot(int(wParam));
4560  					nppGUI._largeFileRestriction._allowAutoCompletion = isAllowed;
4561  				}
4562  				return TRUE;
4563  				case IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE:
4564  				{
4565  					bool isAllowed = isCheckedOrNot(int(wParam));
4566  					nppGUI._largeFileRestriction._allowSmartHilite = isAllowed;
4567  					if (!isAllowed)
4568  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANSMARTHILITING, 0, 0);
4569  				}
4570  				return TRUE;
4571  				case IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK:
4572  				{
4573  					bool isAllowed = isCheckedOrNot(int(wParam));
4574  					nppGUI._largeFileRestriction._allowClickableLink = isAllowed;
4575  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4576  				}
4577  				return TRUE;
4578  				case IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP:
4579  				{
4580  					bool isDeactivated = isCheckedOrNot(int(wParam));
4581  					nppGUI._largeFileRestriction._deactivateWordWrap = isDeactivated;
4582  				}
4583  				return TRUE;
4584  				default:
4585  					return FALSE;
4586  			}
4587  		}
4588  		break;
4589  	}
4590  	return FALSE;
4591  }
4592  intptr_t CALLBACK SearchEngineSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
4593  {
4594  	NppParameters& nppParams = NppParameters::getInstance();
4595  	NppGUI & nppGUI = nppParams.getNppGUI();
4596  	if (HIWORD(wParam) == EN_CHANGE)
4597  	{
4598  		switch (LOWORD(wParam))
4599  		{
4600  			case  IDC_SEARCHENGINE_EDIT:
4601  			{
4602  				TCHAR input[MAX_PATH] = { '\0' };
4603  				::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(input));
4604  				nppGUI._searchEngineCustom = input;
4605  				return TRUE;
4606  			}
4607  		}
4608  	}
4609  	switch (message)
4610  	{
4611  		case WM_INITDIALOG:
4612  		{
4613  			if (nppGUI._searchEngineChoice == nppGUI.se_custom)
4614  			{
4615  				if (nppGUI._searchEngineCustom.empty())
4616  				{
4617  					nppGUI._searchEngineChoice = nppGUI.se_google;
4618  				}
4619  			}
4620  			if (nppGUI._searchEngineChoice == nppGUI.se_bing)
4621  				nppGUI._searchEngineChoice = nppGUI.se_duckDuckGo;
4622  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_CUSTOM_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_custom ? BST_CHECKED : BST_UNCHECKED, 0);
4623  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_DUCKDUCKGO_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_duckDuckGo ? BST_CHECKED : BST_UNCHECKED, 0);
4624  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_GOOGLE_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_google ? BST_CHECKED : BST_UNCHECKED, 0);
4625  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_YAHOO_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_yahoo ? BST_CHECKED : BST_UNCHECKED, 0);
4626  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_STACKOVERFLOW_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_stackoverflow ? BST_CHECKED : BST_UNCHECKED, 0);
4627  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._searchEngineCustom.c_str()));
4628  			::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), nppGUI._searchEngineChoice == nppGUI.se_custom);
4629  			return TRUE;
4630  		}
4631  		case WM_CTLCOLOREDIT:
4632  		{
4633  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4634  		}
4635  		case WM_CTLCOLORDLG:
4636  		case WM_CTLCOLORSTATIC:
4637  		{
4638  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4639  		}
4640  		case WM_PRINTCLIENT:
4641  		{
4642  			if (NppDarkMode::isEnabled())
4643  			{
4644  				return TRUE;
4645  			}
4646  			break;
4647  		}
4648  		case WM_COMMAND:
4649  		{
4650  			switch (wParam)
4651  			{
4652  				case IDC_SEARCHENGINE_DUCKDUCKGO_RADIO:
4653  				{
4654  					nppGUI._searchEngineChoice = nppGUI.se_duckDuckGo;
4655  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4656  				}
4657  				break;
4658  				case IDC_SEARCHENGINE_GOOGLE_RADIO:
4659  				{
4660  					nppGUI._searchEngineChoice = nppGUI.se_google;
4661  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4662  				}
4663  				break;
4664  				case IDC_SEARCHENGINE_YAHOO_RADIO:
4665  				{
4666  					nppGUI._searchEngineChoice = nppGUI.se_yahoo;
4667  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4668  				}
4669  				break;
4670  				case IDC_SEARCHENGINE_STACKOVERFLOW_RADIO:
4671  				{
4672  					nppGUI._searchEngineChoice = nppGUI.se_stackoverflow;
4673  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4674  				}
4675  				break;
4676  				case IDC_SEARCHENGINE_CUSTOM_RADIO:
4677  				{
4678  					nppGUI._searchEngineChoice = nppGUI.se_custom;
4679  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), true);
4680  				}
4681  				break;
4682  				default:
4683  					return FALSE;
4684  			}
4685  		}
4686  		break;
4687  	}
4688  	return FALSE;
4689  }
4690  intptr_t CALLBACK SearchingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
4691  {
4692  	NppParameters& nppParams = NppParameters::getInstance();
4693  	NppGUI& nppGUI = nppParams.getNppGUI();
4694  	switch (message)
4695  	{
4696  		case WM_INITDIALOG:
4697  		{
4698  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED, BM_SETCHECK, nppGUI._fillFindFieldWithSelected, 0);
4699  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET, BM_SETCHECK, nppGUI._fillFindFieldSelectCaret, 0);
4700  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MONOSPACEDFONT_FINDDLG, BM_SETCHECK, nppGUI._monospacedFontFindDlg, 0);
4701  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FINDDLG_ALWAYS_VISIBLE, BM_SETCHECK, nppGUI._findDlgAlwaysVisible, 0);
4702  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET), nppGUI._fillFindFieldWithSelected ? TRUE : FALSE);
4703  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CONFIRMREPLOPENDOCS, BM_SETCHECK, nppGUI._confirmReplaceInAllOpenDocs, 0);
4704  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REPLACEANDSTOP, BM_SETCHECK, nppGUI._replaceStopsWithoutFindingNext, 0);
4705  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SHOWONCEPERFOUNDLINE, BM_SETCHECK, nppGUI._finderShowOnlyOneEntryPerFoundLine, 0);
4706  			return TRUE;
4707  		}
4708  		case WM_CTLCOLORDLG:
4709  		case WM_CTLCOLORSTATIC:
4710  		{
4711  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4712  		}
4713  		case WM_PRINTCLIENT:
4714  		{
4715  			if (NppDarkMode::isEnabled())
4716  			{
4717  				return TRUE;
4718  			}
4719  			break;
4720  		}
4721  		case WM_COMMAND:
4722  		{
4723  			switch (wParam)
4724  			{
4725  				case IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED:
4726  				{
4727  					nppGUI._fillFindFieldWithSelected = isCheckedOrNot(IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED);
4728  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET), nppGUI._fillFindFieldWithSelected ? TRUE :FALSE);
4729  					if (!nppGUI._fillFindFieldWithSelected) 
4730  					{
4731  						::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET, BM_SETCHECK, BST_UNCHECKED, 0);
4732  						nppGUI._fillFindFieldSelectCaret = false;
4733  					}
4734  					return TRUE;
4735  				}
4736  				break;
4737  				case IDC_CHECK_MONOSPACEDFONT_FINDDLG:
4738  				{
4739  					nppGUI._monospacedFontFindDlg = isCheckedOrNot(IDC_CHECK_MONOSPACEDFONT_FINDDLG);
4740  					return TRUE;
4741  				}
4742  				break;
4743  				case IDC_CHECK_FINDDLG_ALWAYS_VISIBLE:
4744  				{
4745  					nppGUI._findDlgAlwaysVisible = isCheckedOrNot(IDC_CHECK_FINDDLG_ALWAYS_VISIBLE);
4746  					return TRUE;
4747  				}
4748  				break;
4749  				case IDC_CHECK_CONFIRMREPLOPENDOCS:
4750  				{
4751  					nppGUI._confirmReplaceInAllOpenDocs = isCheckedOrNot(IDC_CHECK_CONFIRMREPLOPENDOCS);
4752  					return TRUE;
4753  				}
4754  				break;
4755  				case IDC_CHECK_REPLACEANDSTOP:
4756  				{
4757  					nppGUI._replaceStopsWithoutFindingNext = isCheckedOrNot(IDC_CHECK_REPLACEANDSTOP);
4758  					return TRUE;
4759  				}
4760  				break;
4761  				case IDC_CHECK_SHOWONCEPERFOUNDLINE:
4762  				{
4763  					nppGUI._finderShowOnlyOneEntryPerFoundLine = isCheckedOrNot(IDC_CHECK_SHOWONCEPERFOUNDLINE);
4764  					return TRUE;
4765  				}
4766  				break;
4767  				case IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET:
4768  				{
4769  					nppGUI._fillFindFieldSelectCaret = isCheckedOrNot(IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET);
4770  					return TRUE;
4771  				}
4772  				break;
4773  				default:
4774  					return FALSE;
4775  			}
4776  		}
4777  		break;
4778  	}
4779  	return FALSE;
4780  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.cpp</div>
                <div class="column column_space"><pre><code>1555      case '~': return 'c';
1556      case '^': return 'C';
1557      case '{': return 's';
1558      case '[': return 'S';
1559      case '`': return 'z';
1560      case '@': return 'Z';
1561      case '|': return 'd';
</pre></code></div>
                <div class="column column_space"><pre><code>569  				case IDC_CHECK_REDUCE :
570  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REDUCETABBAR, 0);
571  					return TRUE;
572  				case IDC_CHECK_LOCK :
573  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LOCKTABBAR, 0);
574  					return TRUE;
575  				case IDC_CHECK_ORANGE :
576  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_TOPBAR, 0);
577  					return TRUE;
578  				case IDC_CHECK_DRAWINACTIVE :
579  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_INACIVETAB, 0);
580  					return TRUE;
581  				case IDC_CHECK_ENABLETABCLOSE :
582  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN, 0);
583  					return TRUE;
584  				case IDC_CHECK_DBCLICK2CLOSE :
585  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE, 0);
586  					return TRUE;
587  				case IDC_CHECK_HIDE :
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    