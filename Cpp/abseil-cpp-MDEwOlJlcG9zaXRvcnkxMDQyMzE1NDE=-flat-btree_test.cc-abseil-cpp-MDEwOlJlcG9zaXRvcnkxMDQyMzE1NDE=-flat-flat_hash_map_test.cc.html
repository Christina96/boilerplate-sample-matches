
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_test.cc</h3>
            <pre><code>1  #include "absl/container/btree_test.h"
2  #include <algorithm>
3  #include <array>
4  #include <cstdint>
5  #include <functional>
6  #include <iostream>
7  #include <iterator>
8  #include <limits>
9  #include <map>
10  #include <memory>
11  #include <numeric>
12  #include <stdexcept>
13  #include <string>
14  #include <type_traits>
15  #include <utility>
16  #include <vector>
17  #include "gmock/gmock.h"
18  #include "gtest/gtest.h"
19  #include "absl/algorithm/container.h"
20  #include "absl/base/internal/raw_logging.h"
21  #include "absl/base/macros.h"
22  #include "absl/container/btree_map.h"
23  #include "absl/container/btree_set.h"
24  #include "absl/container/internal/counting_allocator.h"
25  #include "absl/container/internal/test_instance_tracker.h"
26  #include "absl/flags/flag.h"
27  #include "absl/hash/hash_testing.h"
28  #include "absl/memory/memory.h"
29  #include "absl/random/random.h"
30  #include "absl/strings/str_cat.h"
31  #include "absl/strings/str_split.h"
32  #include "absl/strings/string_view.h"
33  #include "absl/types/compare.h"
34  #include "absl/types/optional.h"
35  ABSL_FLAG(int, test_values, 10000, "The number of values to use for tests");
36  namespace absl {
37  ABSL_NAMESPACE_BEGIN
38  namespace container_internal {
39  namespace {
40  using ::absl::test_internal::CopyableMovableInstance;
41  using ::absl::test_internal::InstanceTracker;
42  using ::absl::test_internal::MovableOnlyInstance;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::IsEmpty;
46  using ::testing::IsNull;
47  using ::testing::Pair;
48  using ::testing::SizeIs;
49  template <typename T, typename U>
50  void CheckPairEquals(const T &x, const U &y) {
51    ABSL_INTERNAL_CHECK(x == y, "Values are unequal.");
52  }
53  template <typename T, typename U, typename V, typename W>
54  void CheckPairEquals(const std::pair<T, U> &x, const std::pair<V, W> &y) {
55    CheckPairEquals(x.first, y.first);
56    CheckPairEquals(x.second, y.second);
57  }
58  bool IsAssertEnabled() {
59    bool assert_enabled = false;
60    assert([&]() {  
61      assert_enabled = true;
62      return true;
63    }());
64    return assert_enabled;
65  }
66  }  
67  template <typename TreeType, typename CheckerType>
68  class base_checker {
69   public:
70    using key_type = typename TreeType::key_type;
71    using value_type = typename TreeType::value_type;
72    using key_compare = typename TreeType::key_compare;
73    using pointer = typename TreeType::pointer;
74    using const_pointer = typename TreeType::const_pointer;
75    using reference = typename TreeType::reference;
76    using const_reference = typename TreeType::const_reference;
77    using size_type = typename TreeType::size_type;
78    using difference_type = typename TreeType::difference_type;
79    using iterator = typename TreeType::iterator;
80    using const_iterator = typename TreeType::const_iterator;
81    using reverse_iterator = typename TreeType::reverse_iterator;
82    using const_reverse_iterator = typename TreeType::const_reverse_iterator;
83   public:
84    base_checker() : const_tree_(tree_) {}
85    base_checker(const base_checker &other)
86        : tree_(other.tree_), const_tree_(tree_), checker_(other.checker_) {}
87    template <typename InputIterator>
88    base_checker(InputIterator b, InputIterator e)
89        : tree_(b, e), const_tree_(tree_), checker_(b, e) {}
90    iterator begin() { return tree_.begin(); }
91    const_iterator begin() const { return tree_.begin(); }
92    iterator end() { return tree_.end(); }
93    const_iterator end() const { return tree_.end(); }
94    reverse_iterator rbegin() { return tree_.rbegin(); }
95    const_reverse_iterator rbegin() const { return tree_.rbegin(); }
96    reverse_iterator rend() { return tree_.rend(); }
97    const_reverse_iterator rend() const { return tree_.rend(); }
98    template <typename IterType, typename CheckerIterType>
99    IterType iter_check(IterType tree_iter, CheckerIterType checker_iter) const {
100      if (tree_iter == tree_.end()) {
101        ABSL_INTERNAL_CHECK(checker_iter == checker_.end(),
102                            "Checker iterator not at end.");
103      } else {
104        CheckPairEquals(*tree_iter, *checker_iter);
105      }
106      return tree_iter;
107    }
108    template <typename IterType, typename CheckerIterType>
109    IterType riter_check(IterType tree_iter, CheckerIterType checker_iter) const {
110      if (tree_iter == tree_.rend()) {
111        ABSL_INTERNAL_CHECK(checker_iter == checker_.rend(),
112                            "Checker iterator not at rend.");
113      } else {
114        CheckPairEquals(*tree_iter, *checker_iter);
115      }
116      return tree_iter;
117    }
118    void value_check(const value_type &v) {
119      typename KeyOfValue<typename TreeType::key_type,
120                          typename TreeType::value_type>::type key_of_value;
121      const key_type &key = key_of_value(v);
122      CheckPairEquals(*find(key), v);
123      lower_bound(key);
124      upper_bound(key);
125      equal_range(key);
126      contains(key);
127      count(key);
128    }
129    void erase_check(const key_type &key) {
130      EXPECT_FALSE(tree_.contains(key));
131      EXPECT_EQ(tree_.find(key), const_tree_.end());
132      EXPECT_FALSE(const_tree_.contains(key));
133      EXPECT_EQ(const_tree_.find(key), tree_.end());
134      EXPECT_EQ(tree_.equal_range(key).first,
135                const_tree_.equal_range(key).second);
136    }
137    iterator lower_bound(const key_type &key) {
138      return iter_check(tree_.lower_bound(key), checker_.lower_bound(key));
139    }
140    const_iterator lower_bound(const key_type &key) const {
141      return iter_check(tree_.lower_bound(key), checker_.lower_bound(key));
142    }
143    iterator upper_bound(const key_type &key) {
144      return iter_check(tree_.upper_bound(key), checker_.upper_bound(key));
145    }
146    const_iterator upper_bound(const key_type &key) const {
147      return iter_check(tree_.upper_bound(key), checker_.upper_bound(key));
148    }
149    std::pair<iterator, iterator> equal_range(const key_type &key) {
150      std::pair<typename CheckerType::iterator, typename CheckerType::iterator>
151          checker_res = checker_.equal_range(key);
152      std::pair<iterator, iterator> tree_res = tree_.equal_range(key);
153      iter_check(tree_res.first, checker_res.first);
154      iter_check(tree_res.second, checker_res.second);
155      return tree_res;
156    }
157    std::pair<const_iterator, const_iterator> equal_range(
158        const key_type &key) const {
159      std::pair<typename CheckerType::const_iterator,
160                typename CheckerType::const_iterator>
161          checker_res = checker_.equal_range(key);
162      std::pair<const_iterator, const_iterator> tree_res = tree_.equal_range(key);
163      iter_check(tree_res.first, checker_res.first);
164      iter_check(tree_res.second, checker_res.second);
165      return tree_res;
166    }
167    iterator find(const key_type &key) {
168      return iter_check(tree_.find(key), checker_.find(key));
169    }
170    const_iterator find(const key_type &key) const {
171      return iter_check(tree_.find(key), checker_.find(key));
172    }
173    bool contains(const key_type &key) const { return find(key) != end(); }
174    size_type count(const key_type &key) const {
175      size_type res = checker_.count(key);
176      EXPECT_EQ(res, tree_.count(key));
177      return res;
178    }
179    base_checker &operator=(const base_checker &other) {
180      tree_ = other.tree_;
181      checker_ = other.checker_;
182      return *this;
183    }
184    int erase(const key_type &key) {
185      int size = tree_.size();
186      int res = checker_.erase(key);
187      EXPECT_EQ(res, tree_.count(key));
188      EXPECT_EQ(res, tree_.erase(key));
189      EXPECT_EQ(tree_.count(key), 0);
190      EXPECT_EQ(tree_.size(), size - res);
191      erase_check(key);
192      return res;
193    }
194    iterator erase(iterator iter) {
195      key_type key = iter.key();
196      int size = tree_.size();
197      int count = tree_.count(key);
198      auto checker_iter = checker_.lower_bound(key);
199      for (iterator tmp(tree_.lower_bound(key)); tmp != iter; ++tmp) {
200        ++checker_iter;
201      }
202      auto checker_next = checker_iter;
203      ++checker_next;
204      checker_.erase(checker_iter);
205      iter = tree_.erase(iter);
206      EXPECT_EQ(tree_.size(), checker_.size());
207      EXPECT_EQ(tree_.size(), size - 1);
208      EXPECT_EQ(tree_.count(key), count - 1);
209      if (count == 1) {
210        erase_check(key);
211      }
212      return iter_check(iter, checker_next);
213    }
214    void erase(iterator begin, iterator end) {
215      int size = tree_.size();
216      int count = std::distance(begin, end);
217      auto checker_begin = checker_.lower_bound(begin.key());
218      for (iterator tmp(tree_.lower_bound(begin.key())); tmp != begin; ++tmp) {
219        ++checker_begin;
220      }
221      auto checker_end =
222          end == tree_.end() ? checker_.end() : checker_.lower_bound(end.key());
223      if (end != tree_.end()) {
224        for (iterator tmp(tree_.lower_bound(end.key())); tmp != end; ++tmp) {
225          ++checker_end;
226        }
227      }
228      const auto checker_ret = checker_.erase(checker_begin, checker_end);
229      const auto tree_ret = tree_.erase(begin, end);
230      EXPECT_EQ(std::distance(checker_.begin(), checker_ret),
231                std::distance(tree_.begin(), tree_ret));
232      EXPECT_EQ(tree_.size(), checker_.size());
233      EXPECT_EQ(tree_.size(), size - count);
234    }
235    void clear() {
236      tree_.clear();
237      checker_.clear();
238    }
239    void swap(base_checker &other) {
240      tree_.swap(other.tree_);
241      checker_.swap(other.checker_);
242    }
243    void verify() const {
244      tree_.verify();
245      EXPECT_EQ(tree_.size(), checker_.size());
246      auto checker_iter = checker_.begin();
247      const_iterator tree_iter(tree_.begin());
248      for (; tree_iter != tree_.end(); ++tree_iter, ++checker_iter) {
249        CheckPairEquals(*tree_iter, *checker_iter);
250      }
251      for (int n = tree_.size() - 1; n >= 0; --n) {
252        iter_check(tree_iter, checker_iter);
253        --tree_iter;
254        --checker_iter;
255      }
256      EXPECT_EQ(tree_iter, tree_.begin());
257      EXPECT_EQ(checker_iter, checker_.begin());
258      auto checker_riter = checker_.rbegin();
259      const_reverse_iterator tree_riter(tree_.rbegin());
260      for (; tree_riter != tree_.rend(); ++tree_riter, ++checker_riter) {
261        CheckPairEquals(*tree_riter, *checker_riter);
262      }
263      for (int n = tree_.size() - 1; n >= 0; --n) {
264        riter_check(tree_riter, checker_riter);
265        --tree_riter;
266        --checker_riter;
267      }
268      EXPECT_EQ(tree_riter, tree_.rbegin());
269      EXPECT_EQ(checker_riter, checker_.rbegin());
270    }
271    const TreeType &tree() const { return tree_; }
272    size_type size() const {
273      EXPECT_EQ(tree_.size(), checker_.size());
274      return tree_.size();
275    }
276    size_type max_size() const { return tree_.max_size(); }
277    bool empty() const {
278      EXPECT_EQ(tree_.empty(), checker_.empty());
279      return tree_.empty();
280    }
281   protected:
282    TreeType tree_;
283    const TreeType &const_tree_;
284    CheckerType checker_;
285  };
286  namespace {
287  template <typename TreeType, typename CheckerType>
288  class unique_checker : public base_checker<TreeType, CheckerType> {
289    using super_type = base_checker<TreeType, CheckerType>;
290   public:
291    using iterator = typename super_type::iterator;
292    using value_type = typename super_type::value_type;
293   public:
294    unique_checker() : super_type() {}
295    unique_checker(const unique_checker &other) : super_type(other) {}
296    template <class InputIterator>
297    unique_checker(InputIterator b, InputIterator e) : super_type(b, e) {}
298    unique_checker &operator=(const unique_checker &) = default;
299    std::pair<iterator, bool> insert(const value_type &v) {
300      int size = this->tree_.size();
301      std::pair<typename CheckerType::iterator, bool> checker_res =
302          this->checker_.insert(v);
303      std::pair<iterator, bool> tree_res = this->tree_.insert(v);
304      CheckPairEquals(*tree_res.first, *checker_res.first);
305      EXPECT_EQ(tree_res.second, checker_res.second);
306      EXPECT_EQ(this->tree_.size(), this->checker_.size());
307      EXPECT_EQ(this->tree_.size(), size + tree_res.second);
308      return tree_res;
309    }
310    iterator insert(iterator position, const value_type &v) {
311      int size = this->tree_.size();
312      std::pair<typename CheckerType::iterator, bool> checker_res =
313          this->checker_.insert(v);
314      iterator tree_res = this->tree_.insert(position, v);
315      CheckPairEquals(*tree_res, *checker_res.first);
316      EXPECT_EQ(this->tree_.size(), this->checker_.size());
317      EXPECT_EQ(this->tree_.size(), size + checker_res.second);
318      return tree_res;
319    }
320    template <typename InputIterator>
321    void insert(InputIterator b, InputIterator e) {
322      for (; b != e; ++b) {
323        insert(*b);
324      }
325    }
326  };
327  template <typename TreeType, typename CheckerType>
328  class multi_checker : public base_checker<TreeType, CheckerType> {
329    using super_type = base_checker<TreeType, CheckerType>;
330   public:
331    using iterator = typename super_type::iterator;
332    using value_type = typename super_type::value_type;
333   public:
334    multi_checker() : super_type() {}
335    multi_checker(const multi_checker &other) : super_type(other) {}
336    template <class InputIterator>
337    multi_checker(InputIterator b, InputIterator e) : super_type(b, e) {}
338    multi_checker &operator=(const multi_checker &) = default;
339    iterator insert(const value_type &v) {
340      int size = this->tree_.size();
341      auto checker_res = this->checker_.insert(v);
342      iterator tree_res = this->tree_.insert(v);
343      CheckPairEquals(*tree_res, *checker_res);
344      EXPECT_EQ(this->tree_.size(), this->checker_.size());
345      EXPECT_EQ(this->tree_.size(), size + 1);
346      return tree_res;
347    }
348    iterator insert(iterator position, const value_type &v) {
349      int size = this->tree_.size();
350      auto checker_res = this->checker_.insert(v);
351      iterator tree_res = this->tree_.insert(position, v);
352      CheckPairEquals(*tree_res, *checker_res);
353      EXPECT_EQ(this->tree_.size(), this->checker_.size());
354      EXPECT_EQ(this->tree_.size(), size + 1);
355      return tree_res;
356    }
357    template <typename InputIterator>
358    void insert(InputIterator b, InputIterator e) {
359      for (; b != e; ++b) {
360        insert(*b);
361      }
362    }
363  };
364  template <typename T, typename V>
365  void DoTest(const char *name, T *b, const std::vector<V> &values) {
366    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
367    T &mutable_b = *b;
368    const T &const_b = *b;
369    for (int i = 0; i < values.size(); ++i) {
370      mutable_b.insert(values[i]);
371      mutable_b.value_check(values[i]);
372    }
373    ASSERT_EQ(mutable_b.size(), values.size());
374    const_b.verify();
375    T b_copy(const_b);
376    EXPECT_EQ(b_copy.size(), const_b.size());
377    for (int i = 0; i < values.size(); ++i) {
378      CheckPairEquals(*b_copy.find(key_of_value(values[i])), values[i]);
379    }
380    T b_range(const_b.begin(), const_b.end());
381    EXPECT_EQ(b_range.size(), const_b.size());
382    for (int i = 0; i < values.size(); ++i) {
383      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
384    }
385    b_range.insert(b_copy.begin(), b_copy.end());
386    b_range.verify();
387    b_range.clear();
388    b_range.insert(b_copy.begin(), b_copy.end());
389    EXPECT_EQ(b_range.size(), b_copy.size());
390    for (int i = 0; i < values.size(); ++i) {
391      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
392    }
393    b_range.operator=(b_range);
394    EXPECT_EQ(b_range.size(), b_copy.size());
395    b_range.clear();
396    b_range = b_copy;
397    EXPECT_EQ(b_range.size(), b_copy.size());
398    b_range.clear();
399    b_range.swap(b_copy);
400    EXPECT_EQ(b_copy.size(), 0);
401    EXPECT_EQ(b_range.size(), const_b.size());
402    for (int i = 0; i < values.size(); ++i) {
403      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
404    }
405    b_range.swap(b_copy);
406    swap(b_range, b_copy);
407    EXPECT_EQ(b_copy.size(), 0);
408    EXPECT_EQ(b_range.size(), const_b.size());
409    for (int i = 0; i < values.size(); ++i) {
410      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
411    }
412    swap(b_range, b_copy);
413    for (int i = 0; i < values.size(); ++i) {
414      mutable_b.erase(key_of_value(values[i]));
415      ASSERT_EQ(mutable_b.erase(key_of_value(values[i])), 0);
416    }
417    const_b.verify();
418    EXPECT_EQ(const_b.size(), 0);
419    mutable_b = b_copy;
420    for (int i = 0; i < values.size(); ++i) {
421      mutable_b.erase(mutable_b.find(key_of_value(values[i])));
422    }
423    const_b.verify();
424    EXPECT_EQ(const_b.size(), 0);
425    for (int i = 0; i < values.size(); i++) {
426      mutable_b.insert(mutable_b.upper_bound(key_of_value(values[i])), values[i]);
427    }
428    const_b.verify();
429    mutable_b.erase(mutable_b.begin(), mutable_b.end());
430    EXPECT_EQ(mutable_b.size(), 0);
431    const_b.verify();
432    mutable_b = b_copy;
433    typename T::iterator mutable_iter_end = mutable_b.begin();
434    for (int i = 0; i < values.size() / 2; ++i) ++mutable_iter_end;
435    mutable_b.erase(mutable_b.begin(), mutable_iter_end);
436    EXPECT_EQ(mutable_b.size(), values.size() - values.size() / 2);
437    const_b.verify();
438    mutable_b = b_copy;
439    typename T::iterator mutable_iter_begin = mutable_b.begin();
440    for (int i = 0; i < values.size() / 2; ++i) ++mutable_iter_begin;
441    mutable_b.erase(mutable_iter_begin, mutable_b.end());
442    EXPECT_EQ(mutable_b.size(), values.size() / 2);
443    const_b.verify();
444    mutable_b = b_copy;
445    mutable_iter_begin = mutable_b.begin();
446    for (int i = 0; i < values.size() / 4; ++i) ++mutable_iter_begin;
447    mutable_iter_end = mutable_iter_begin;
448    for (int i = 0; i < values.size() / 4; ++i) ++mutable_iter_end;
449    mutable_b.erase(mutable_iter_begin, mutable_iter_end);
450    EXPECT_EQ(mutable_b.size(), values.size() - values.size() / 4);
451    const_b.verify();
452    mutable_b.clear();
453  }
454  template <typename T>
455  void ConstTest() {
456    using value_type = typename T::value_type;
457    typename KeyOfValue<typename T::key_type, value_type>::type key_of_value;
458    T mutable_b;
459    const T &const_b = mutable_b;
460    value_type value = Generator<value_type>(2)(2);
461    mutable_b.insert(value);
462    EXPECT_TRUE(mutable_b.contains(key_of_value(value)));
463    EXPECT_NE(mutable_b.find(key_of_value(value)), const_b.end());
464    EXPECT_TRUE(const_b.contains(key_of_value(value)));
465    EXPECT_NE(const_b.find(key_of_value(value)), mutable_b.end());
466    EXPECT_EQ(*const_b.lower_bound(key_of_value(value)), value);
467    EXPECT_EQ(const_b.upper_bound(key_of_value(value)), const_b.end());
468    EXPECT_EQ(*const_b.equal_range(key_of_value(value)).first, value);
469    typename T::iterator mutable_iter(mutable_b.begin());
470    EXPECT_EQ(mutable_iter, const_b.begin());
471    EXPECT_NE(mutable_iter, const_b.end());
472    EXPECT_EQ(const_b.begin(), mutable_iter);
473    EXPECT_NE(const_b.end(), mutable_iter);
474    typename T::reverse_iterator mutable_riter(mutable_b.rbegin());
475    EXPECT_EQ(mutable_riter, const_b.rbegin());
476    EXPECT_NE(mutable_riter, const_b.rend());
477    EXPECT_EQ(const_b.rbegin(), mutable_riter);
478    EXPECT_NE(const_b.rend(), mutable_riter);
479    typename T::const_iterator const_iter(mutable_iter);
480    EXPECT_EQ(const_iter, mutable_b.begin());
481    EXPECT_NE(const_iter, mutable_b.end());
482    EXPECT_EQ(mutable_b.begin(), const_iter);
483    EXPECT_NE(mutable_b.end(), const_iter);
484    typename T::const_reverse_iterator const_riter(mutable_riter);
485    EXPECT_EQ(const_riter, mutable_b.rbegin());
486    EXPECT_NE(const_riter, mutable_b.rend());
487    EXPECT_EQ(mutable_b.rbegin(), const_riter);
488    EXPECT_NE(mutable_b.rend(), const_riter);
489    const_b.verify();
490    ASSERT_TRUE(!const_b.empty());
491    EXPECT_EQ(const_b.size(), 1);
492    EXPECT_GT(const_b.max_size(), 0);
493    EXPECT_TRUE(const_b.contains(key_of_value(value)));
494    EXPECT_EQ(const_b.count(key_of_value(value)), 1);
495  }
496  template <typename T, typename C>
497  void BtreeTest() {
498    ConstTest<T>();
499    using V = typename remove_pair_const<typename T::value_type>::type;
500    const std::vector<V> random_values = GenerateValuesWithSeed<V>(
501        absl::GetFlag(FLAGS_test_values), 4 * absl::GetFlag(FLAGS_test_values),
502        GTEST_FLAG_GET(random_seed));
503    unique_checker<T, C> container;
504    std::vector<V> sorted_values(random_values);
505    std::sort(sorted_values.begin(), sorted_values.end());
506    DoTest("sorted:    ", &container, sorted_values);
507    std::reverse(sorted_values.begin(), sorted_values.end());
508    DoTest("rsorted:   ", &container, sorted_values);
509    DoTest("random:    ", &container, random_values);
510  }
511  template <typename T, typename C>
512  void BtreeMultiTest() {
513    ConstTest<T>();
514    using V = typename remove_pair_const<typename T::value_type>::type;
515    const std::vector<V> random_values = GenerateValuesWithSeed<V>(
516        absl::GetFlag(FLAGS_test_values), 4 * absl::GetFlag(FLAGS_test_values),
517        GTEST_FLAG_GET(random_seed));
518    multi_checker<T, C> container;
519    std::vector<V> sorted_values(random_values);
520    std::sort(sorted_values.begin(), sorted_values.end());
521    DoTest("sorted:    ", &container, sorted_values);
522    std::reverse(sorted_values.begin(), sorted_values.end());
523    DoTest("rsorted:   ", &container, sorted_values);
524    DoTest("random:    ", &container, random_values);
525    std::vector<V> duplicate_values(random_values);
526    duplicate_values.insert(duplicate_values.end(), random_values.begin(),
527                            random_values.end());
528    DoTest("duplicates:", &container, duplicate_values);
529    std::vector<V> identical_values(100);
530    std::fill(identical_values.begin(), identical_values.end(),
531              Generator<V>(2)(2));
532    DoTest("identical: ", &container, identical_values);
533  }
534  template <typename T>
535  struct PropagatingCountingAlloc : public CountingAllocator<T> {
536    using propagate_on_container_copy_assignment = std::true_type;
537    using propagate_on_container_move_assignment = std::true_type;
538    using propagate_on_container_swap = std::true_type;
539    using Base = CountingAllocator<T>;
540    using Base::Base;
541    template <typename U>
542    explicit PropagatingCountingAlloc(const PropagatingCountingAlloc<U> &other)
543        : Base(other.bytes_used_) {}
544    template <typename U>
545    struct rebind {
546      using other = PropagatingCountingAlloc<U>;
547    };
548  };
549  template <typename T>
550  void BtreeAllocatorTest() {
551    using value_type = typename T::value_type;
552    int64_t bytes1 = 0, bytes2 = 0;
553    PropagatingCountingAlloc<T> allocator1(&bytes1);
554    PropagatingCountingAlloc<T> allocator2(&bytes2);
555    Generator<value_type> generator(1000);
556    auto unused1 = allocator1.allocate(1);
557    auto unused2 = allocator2.allocate(1);
558    {
559      T b1(typename T::key_compare(), allocator1);
560      T b2(typename T::key_compare(), allocator2);
561      int64_t original_bytes1 = bytes1;
562      b1.insert(generator(0));
563      EXPECT_GT(bytes1, original_bytes1);
564      b1 = b2;
565      EXPECT_EQ(b1.size(), 0);
566      EXPECT_EQ(b2.size(), 0);
567      EXPECT_EQ(bytes1, original_bytes1);
568      for (int i = 1; i < 1000; i++) {
569        b1.insert(generator(i));
570      }
571      EXPECT_GT(bytes2, bytes1);
572    }
573    {
574      T b1(typename T::key_compare(), allocator1);
575      T b2(typename T::key_compare(), allocator2);
576      int64_t original_bytes1 = bytes1;
577      b1.insert(generator(0));
578      EXPECT_GT(bytes1, original_bytes1);
579      b1 = std::move(b2);
580      EXPECT_EQ(b1.size(), 0);
581      EXPECT_EQ(bytes1, original_bytes1);
582      for (int i = 1; i < 1000; i++) {
583        b1.insert(generator(i));
584      }
585      EXPECT_GT(bytes2, bytes1);
586    }
587    {
588      T b1(typename T::key_compare(), allocator1);
589      T b2(typename T::key_compare(), allocator2);
590      int64_t original_bytes1 = bytes1;
591      b1.insert(generator(0));
592      EXPECT_GT(bytes1, original_bytes1);
593      swap(b1, b2);
594      EXPECT_EQ(b1.size(), 0);
595      EXPECT_EQ(b2.size(), 1);
596      EXPECT_GT(bytes1, original_bytes1);
597      for (int i = 1; i < 1000; i++) {
598        b1.insert(generator(i));
599      }
600      EXPECT_GT(bytes2, bytes1);
601    }
602    allocator1.deallocate(unused1, 1);
603    allocator2.deallocate(unused2, 1);
604  }
605  template <typename T>
606  void BtreeMapTest() {
607    using value_type = typename T::value_type;
608    using mapped_type = typename T::mapped_type;
609    mapped_type m = Generator<mapped_type>(0)(0);
610    (void)m;
611    T b;
612    for (int i = 0; i < 1000; i++) {
613      value_type v = Generator<value_type>(1000)(i);
614      b[v.first] = v.second;
615    }
616    EXPECT_EQ(b.size(), 1000);
617    EXPECT_EQ(b.begin()->first, Generator<value_type>(1000)(0).first);
618    EXPECT_EQ(b.begin()->second, Generator<value_type>(1000)(0).second);
619    EXPECT_EQ(b.rbegin()->first, Generator<value_type>(1000)(999).first);
620    EXPECT_EQ(b.rbegin()->second, Generator<value_type>(1000)(999).second);
621  }
622  template <typename T>
623  void BtreeMultiMapTest() {
624    using mapped_type = typename T::mapped_type;
625    mapped_type m = Generator<mapped_type>(0)(0);
626    (void)m;
627  }
628  template <typename K, int N = 256>
629  void SetTest() {
630    EXPECT_EQ(
631        sizeof(absl::btree_set<K>),
632        2 * sizeof(void *) + sizeof(typename absl::btree_set<K>::size_type));
633    using BtreeSet = absl::btree_set<K>;
634    using CountingBtreeSet =
635        absl::btree_set<K, std::less<K>, PropagatingCountingAlloc<K>>;
636    BtreeTest<BtreeSet, std::set<K>>();
637    BtreeAllocatorTest<CountingBtreeSet>();
638  }
639  template <typename K, int N = 256>
640  void MapTest() {
641    EXPECT_EQ(
642        sizeof(absl::btree_map<K, K>),
643        2 * sizeof(void *) + sizeof(typename absl::btree_map<K, K>::size_type));
644    using BtreeMap = absl::btree_map<K, K>;
645    using CountingBtreeMap =
646        absl::btree_map<K, K, std::less<K>,
647                        PropagatingCountingAlloc<std::pair<const K, K>>>;
648    BtreeTest<BtreeMap, std::map<K, K>>();
649    BtreeAllocatorTest<CountingBtreeMap>();
650    BtreeMapTest<BtreeMap>();
651  }
652  TEST(Btree, set_int32) { SetTest<int32_t>(); }
653  TEST(Btree, set_int64) { SetTest<int64_t>(); }
654  TEST(Btree, set_string) { SetTest<std::string>(); }
655  TEST(Btree, set_cord) { SetTest<absl::Cord>(); }
656  TEST(Btree, set_pair) { SetTest<std::pair<int, int>>(); }
657  TEST(Btree, map_int32) { MapTest<int32_t>(); }
658  TEST(Btree, map_int64) { MapTest<int64_t>(); }
659  TEST(Btree, map_string) { MapTest<std::string>(); }
660  TEST(Btree, map_cord) { MapTest<absl::Cord>(); }
661  TEST(Btree, map_pair) { MapTest<std::pair<int, int>>(); }
662  template <typename K, int N = 256>
663  void MultiSetTest() {
664    EXPECT_EQ(
665        sizeof(absl::btree_multiset<K>),
666        2 * sizeof(void *) + sizeof(typename absl::btree_multiset<K>::size_type));
667    using BtreeMSet = absl::btree_multiset<K>;
668    using CountingBtreeMSet =
669        absl::btree_multiset<K, std::less<K>, PropagatingCountingAlloc<K>>;
670    BtreeMultiTest<BtreeMSet, std::multiset<K>>();
671    BtreeAllocatorTest<CountingBtreeMSet>();
672  }
673  template <typename K, int N = 256>
674  void MultiMapTest() {
675    EXPECT_EQ(sizeof(absl::btree_multimap<K, K>),
676              2 * sizeof(void *) +
677                  sizeof(typename absl::btree_multimap<K, K>::size_type));
678    using BtreeMMap = absl::btree_multimap<K, K>;
679    using CountingBtreeMMap =
680        absl::btree_multimap<K, K, std::less<K>,
681                             PropagatingCountingAlloc<std::pair<const K, K>>>;
682    BtreeMultiTest<BtreeMMap, std::multimap<K, K>>();
683    BtreeMultiMapTest<BtreeMMap>();
684    BtreeAllocatorTest<CountingBtreeMMap>();
685  }
686  TEST(Btree, multiset_int32) { MultiSetTest<int32_t>(); }
687  TEST(Btree, multiset_int64) { MultiSetTest<int64_t>(); }
688  TEST(Btree, multiset_string) { MultiSetTest<std::string>(); }
689  TEST(Btree, multiset_cord) { MultiSetTest<absl::Cord>(); }
690  TEST(Btree, multiset_pair) { MultiSetTest<std::pair<int, int>>(); }
691  TEST(Btree, multimap_int32) { MultiMapTest<int32_t>(); }
692  TEST(Btree, multimap_int64) { MultiMapTest<int64_t>(); }
693  TEST(Btree, multimap_string) { MultiMapTest<std::string>(); }
694  TEST(Btree, multimap_cord) { MultiMapTest<absl::Cord>(); }
695  TEST(Btree, multimap_pair) { MultiMapTest<std::pair<int, int>>(); }
696  struct CompareIntToString {
697    bool operator()(const std::string &a, const std::string &b) const {
698      return a < b;
699    }
700    bool operator()(const std::string &a, int b) const {
701      return a < absl::StrCat(b);
702    }
703    bool operator()(int a, const std::string &b) const {
704      return absl::StrCat(a) < b;
705    }
706    using is_transparent = void;
707  };
708  struct NonTransparentCompare {
709    template <typename T, typename U>
710    bool operator()(const T &t, const U &u) const {
711      EXPECT_TRUE((std::is_same<T, U>()));
712      return t < u;
713    }
714  };
715  template <typename T>
716  bool CanEraseWithEmptyBrace(T t, decltype(t.erase({})) *) {
717    return true;
718  }
719  template <typename T>
720  bool CanEraseWithEmptyBrace(T, ...) {
721    return false;
722  }
723  template <typename T>
724  void TestHeterogeneous(T table) {
725    auto lb = table.lower_bound("3");
726    EXPECT_EQ(lb, table.lower_bound(3));
727    EXPECT_NE(lb, table.lower_bound(4));
728    EXPECT_EQ(lb, table.lower_bound({"3"}));
729    EXPECT_NE(lb, table.lower_bound({}));
730    auto ub = table.upper_bound("3");
731    EXPECT_EQ(ub, table.upper_bound(3));
732    EXPECT_NE(ub, table.upper_bound(5));
733    EXPECT_EQ(ub, table.upper_bound({"3"}));
734    EXPECT_NE(ub, table.upper_bound({}));
735    auto er = table.equal_range("3");
736    EXPECT_EQ(er, table.equal_range(3));
737    EXPECT_NE(er, table.equal_range(4));
738    EXPECT_EQ(er, table.equal_range({"3"}));
739    EXPECT_NE(er, table.equal_range({}));
740    auto it = table.find("3");
741    EXPECT_EQ(it, table.find(3));
742    EXPECT_NE(it, table.find(4));
743    EXPECT_EQ(it, table.find({"3"}));
744    EXPECT_NE(it, table.find({}));
745    EXPECT_TRUE(table.contains(3));
746    EXPECT_FALSE(table.contains(4));
747    EXPECT_TRUE(table.count({"3"}));
748    EXPECT_FALSE(table.contains({}));
749    EXPECT_EQ(1, table.count(3));
750    EXPECT_EQ(0, table.count(4));
751    EXPECT_EQ(1, table.count({"3"}));
752    EXPECT_EQ(0, table.count({}));
753    auto copy = table;
754    copy.erase(3);
755    EXPECT_EQ(table.size() - 1, copy.size());
756    copy.erase(4);
757    EXPECT_EQ(table.size() - 1, copy.size());
758    copy.erase({"5"});
759    EXPECT_EQ(table.size() - 2, copy.size());
760    EXPECT_FALSE(CanEraseWithEmptyBrace(table, nullptr));
761    if (std::is_class<T>()) TestHeterogeneous<const T &>(table);
762  }
763  TEST(Btree, HeterogeneousLookup) {
764    TestHeterogeneous(btree_set<std::string, CompareIntToString>{"1", "3", "5"});
765    TestHeterogeneous(btree_map<std::string, int, CompareIntToString>{
766        {"1", 1}, {"3", 3}, {"5", 5}});
767    TestHeterogeneous(
768        btree_multiset<std::string, CompareIntToString>{"1", "3", "5"});
769    TestHeterogeneous(btree_multimap<std::string, int, CompareIntToString>{
770        {"1", 1}, {"3", 3}, {"5", 5}});
771    btree_map<std::string, int, CompareIntToString> map{
772        {"", -1}, {"1", 1}, {"3", 3}, {"5", 5}};
773    EXPECT_EQ(1, map.at(1));
774    EXPECT_EQ(3, map.at({"3"}));
775    EXPECT_EQ(-1, map.at({}));
776    const auto &cmap = map;
777    EXPECT_EQ(1, cmap.at(1));
778    EXPECT_EQ(3, cmap.at({"3"}));
779    EXPECT_EQ(-1, cmap.at({}));
780  }
781  TEST(Btree, NoHeterogeneousLookupWithoutAlias) {
782    using StringSet = absl::btree_set<std::string, NonTransparentCompare>;
783    StringSet s;
784    ASSERT_TRUE(s.insert("hello").second);
785    ASSERT_TRUE(s.insert("world").second);
786    EXPECT_TRUE(s.end() == s.find("blah"));
787    EXPECT_TRUE(s.begin() == s.lower_bound("hello"));
788    EXPECT_EQ(1, s.count("world"));
789    EXPECT_TRUE(s.contains("hello"));
790    EXPECT_TRUE(s.contains("world"));
791    EXPECT_FALSE(s.contains("blah"));
792    using StringMultiSet =
793        absl::btree_multiset<std::string, NonTransparentCompare>;
794    StringMultiSet ms;
795    ms.insert("hello");
796    ms.insert("world");
797    ms.insert("world");
798    EXPECT_TRUE(ms.end() == ms.find("blah"));
799    EXPECT_TRUE(ms.begin() == ms.lower_bound("hello"));
800    EXPECT_EQ(2, ms.count("world"));
801    EXPECT_TRUE(ms.contains("hello"));
802    EXPECT_TRUE(ms.contains("world"));
803    EXPECT_FALSE(ms.contains("blah"));
804  }
805  TEST(Btree, DefaultTransparent) {
806    {
807      btree_set<int> s = {1};
808      double d = 1.1;
809      EXPECT_EQ(s.begin(), s.find(d));
810      EXPECT_TRUE(s.contains(d));
811    }
812    {
813      btree_set<std::string> s = {"A"};
814      EXPECT_EQ(s.begin(), s.find(absl::string_view("A")));
815      EXPECT_TRUE(s.contains(absl::string_view("A")));
816    }
817  }
818  class StringLike {
819   public:
820    StringLike() = default;
821    StringLike(const char *s) : s_(s) {  
822      ++constructor_calls_;
823    }
824    bool operator<(const StringLike &a) const { return s_ < a.s_; }
825    static void clear_constructor_call_count() { constructor_calls_ = 0; }
826    static int constructor_calls() { return constructor_calls_; }
827   private:
828    static int constructor_calls_;
829    std::string s_;
830  };
831  int StringLike::constructor_calls_ = 0;
832  TEST(Btree, HeterogeneousLookupDoesntDegradePerformance) {
833    using StringSet = absl::btree_set<StringLike>;
834    StringSet s;
835    for (int i = 0; i < 100; ++i) {
836      ASSERT_TRUE(s.insert(absl::StrCat(i).c_str()).second);
837    }
838    StringLike::clear_constructor_call_count();
839    s.find("50");
840    ASSERT_EQ(1, StringLike::constructor_calls());
841    StringLike::clear_constructor_call_count();
842    s.contains("50");
843    ASSERT_EQ(1, StringLike::constructor_calls());
844    StringLike::clear_constructor_call_count();
845    s.count("50");
846    ASSERT_EQ(1, StringLike::constructor_calls());
847    StringLike::clear_constructor_call_count();
848    s.lower_bound("50");
849    ASSERT_EQ(1, StringLike::constructor_calls());
850    StringLike::clear_constructor_call_count();
851    s.upper_bound("50");
852    ASSERT_EQ(1, StringLike::constructor_calls());
853    StringLike::clear_constructor_call_count();
854    s.equal_range("50");
855    ASSERT_EQ(1, StringLike::constructor_calls());
856    StringLike::clear_constructor_call_count();
857    s.erase("50");
858    ASSERT_EQ(1, StringLike::constructor_calls());
859  }
860  struct SubstringLess {
861    SubstringLess() = delete;
862    explicit SubstringLess(int length) : n(length) {}
863    bool operator()(const std::string &a, const std::string &b) const {
864      return absl::string_view(a).substr(0, n) <
865             absl::string_view(b).substr(0, n);
866    }
867    int n;
868  };
869  TEST(Btree, SwapKeyCompare) {
870    using SubstringSet = absl::btree_set<std::string, SubstringLess>;
871    SubstringSet s1(SubstringLess(1), SubstringSet::allocator_type());
872    SubstringSet s2(SubstringLess(2), SubstringSet::allocator_type());
873    ASSERT_TRUE(s1.insert("a").second);
874    ASSERT_FALSE(s1.insert("aa").second);
875    ASSERT_TRUE(s2.insert("a").second);
876    ASSERT_TRUE(s2.insert("aa").second);
877    ASSERT_FALSE(s2.insert("aaa").second);
878    swap(s1, s2);
879    ASSERT_TRUE(s1.insert("b").second);
880    ASSERT_TRUE(s1.insert("bb").second);
881    ASSERT_FALSE(s1.insert("bbb").second);
882    ASSERT_TRUE(s2.insert("b").second);
883    ASSERT_FALSE(s2.insert("bb").second);
884  }
885  TEST(Btree, UpperBoundRegression) {
886    using SubstringSet = absl::btree_set<std::string, SubstringLess>;
887    SubstringSet my_set(SubstringLess(3));
888    my_set.insert("aab");
889    my_set.insert("abb");
890    SubstringSet::iterator it = my_set.upper_bound("aaa");
891    ASSERT_TRUE(it != my_set.end());
892    EXPECT_EQ("aab", *it);
893  }
894  TEST(Btree, Comparison) {
895    const int kSetSize = 1201;
896    absl::btree_set<int64_t> my_set;
897    for (int i = 0; i < kSetSize; ++i) {
898      my_set.insert(i);
899    }
900    absl::btree_set<int64_t> my_set_copy(my_set);
901    EXPECT_TRUE(my_set_copy == my_set);
902    EXPECT_TRUE(my_set == my_set_copy);
903    EXPECT_FALSE(my_set_copy != my_set);
904    EXPECT_FALSE(my_set != my_set_copy);
905    my_set.insert(kSetSize);
906    EXPECT_FALSE(my_set_copy == my_set);
907    EXPECT_FALSE(my_set == my_set_copy);
908    EXPECT_TRUE(my_set_copy != my_set);
909    EXPECT_TRUE(my_set != my_set_copy);
910    my_set.erase(kSetSize - 1);
911    EXPECT_FALSE(my_set_copy == my_set);
912    EXPECT_FALSE(my_set == my_set_copy);
913    EXPECT_TRUE(my_set_copy != my_set);
914    EXPECT_TRUE(my_set != my_set_copy);
915    absl::btree_map<std::string, int64_t> my_map;
916    for (int i = 0; i < kSetSize; ++i) {
917      my_map[std::string(i, 'a')] = i;
918    }
919    absl::btree_map<std::string, int64_t> my_map_copy(my_map);
920    EXPECT_TRUE(my_map_copy == my_map);
921    EXPECT_TRUE(my_map == my_map_copy);
922    EXPECT_FALSE(my_map_copy != my_map);
923    EXPECT_FALSE(my_map != my_map_copy);
924    ++my_map_copy[std::string(7, 'a')];
925    EXPECT_FALSE(my_map_copy == my_map);
926    EXPECT_FALSE(my_map == my_map_copy);
927    EXPECT_TRUE(my_map_copy != my_map);
928    EXPECT_TRUE(my_map != my_map_copy);
929    my_map_copy = my_map;
930    my_map["hello"] = kSetSize;
931    EXPECT_FALSE(my_map_copy == my_map);
932    EXPECT_FALSE(my_map == my_map_copy);
933    EXPECT_TRUE(my_map_copy != my_map);
934    EXPECT_TRUE(my_map != my_map_copy);
935    my_map.erase(std::string(kSetSize - 1, 'a'));
936    EXPECT_FALSE(my_map_copy == my_map);
937    EXPECT_FALSE(my_map == my_map_copy);
938    EXPECT_TRUE(my_map_copy != my_map);
939    EXPECT_TRUE(my_map != my_map_copy);
940  }
941  TEST(Btree, RangeCtorSanity) {
942    std::vector<int> ivec;
943    ivec.push_back(1);
944    std::map<int, int> imap;
945    imap.insert(std::make_pair(1, 2));
946    absl::btree_multiset<int> tmset(ivec.begin(), ivec.end());
947    absl::btree_multimap<int, int> tmmap(imap.begin(), imap.end());
948    absl::btree_set<int> tset(ivec.begin(), ivec.end());
949    absl::btree_map<int, int> tmap(imap.begin(), imap.end());
950    EXPECT_EQ(1, tmset.size());
951    EXPECT_EQ(1, tmmap.size());
952    EXPECT_EQ(1, tset.size());
953    EXPECT_EQ(1, tmap.size());
954  }
955  }  
956  class BtreeNodePeer {
957   public:
958    template <typename ValueType>
959    constexpr static size_t GetTargetNodeSize(size_t target_values_per_node) {
960      return btree_node<
961          set_params<ValueType, std::less<ValueType>, std::allocator<ValueType>,
962                     256,  
963                     false>>::SizeWithNSlots(target_values_per_node);
964    }
965    template <typename Btree>
966    constexpr static size_t GetNumSlotsPerNode() {
967      return btree_node<typename Btree::params_type>::kNodeSlots;
968    }
969    template <typename Btree>
970    constexpr static size_t GetMaxFieldType() {
971      return std::numeric_limits<
972          typename btree_node<typename Btree::params_type>::field_type>::max();
973    }
974    template <typename Btree>
975    constexpr static bool UsesLinearNodeSearch() {
976      return btree_node<typename Btree::params_type>::use_linear_search::value;
977    }
978    template <typename Btree>
979    constexpr static bool FieldTypeEqualsSlotType() {
980      return std::is_same<
981          typename btree_node<typename Btree::params_type>::field_type,
982          typename btree_node<typename Btree::params_type>::slot_type>::value;
983    }
984  };
985  namespace {
986  class BtreeMapTest : public ::testing::Test {
987   public:
988    struct Key {};
989    struct Cmp {
990      template <typename T>
991      bool operator()(T, T) const {
992        return false;
993      }
994    };
995    struct KeyLin {
996      using absl_btree_prefer_linear_node_search = std::true_type;
997    };
998    struct CmpLin : Cmp {
999      using absl_btree_prefer_linear_node_search = std::true_type;
1000    };
1001    struct KeyBin {
1002      using absl_btree_prefer_linear_node_search = std::false_type;
1003    };
1004    struct CmpBin : Cmp {
1005      using absl_btree_prefer_linear_node_search = std::false_type;
1006    };
1007    template <typename K, typename C>
1008    static bool IsLinear() {
1009      return BtreeNodePeer::UsesLinearNodeSearch<absl::btree_map<K, int, C>>();
1010    }
1011  };
1012  TEST_F(BtreeMapTest, TestLinearSearchPreferredForKeyLinearViaAlias) {
1013    EXPECT_FALSE((IsLinear<Key, Cmp>()));
1014    EXPECT_TRUE((IsLinear<KeyLin, Cmp>()));
1015    EXPECT_TRUE((IsLinear<Key, CmpLin>()));
1016    EXPECT_TRUE((IsLinear<KeyLin, CmpLin>()));
1017  }
1018  TEST_F(BtreeMapTest, LinearChoiceTree) {
1019    EXPECT_FALSE((IsLinear<Key, CmpBin>()));
1020    EXPECT_FALSE((IsLinear<KeyLin, CmpBin>()));
1021    EXPECT_FALSE((IsLinear<KeyBin, CmpBin>()));
1022    EXPECT_FALSE((IsLinear<int, CmpBin>()));
1023    EXPECT_FALSE((IsLinear<std::string, CmpBin>()));
1024    EXPECT_TRUE((IsLinear<Key, CmpLin>()));
1025    EXPECT_TRUE((IsLinear<KeyLin, CmpLin>()));
1026    EXPECT_TRUE((IsLinear<KeyBin, CmpLin>()));
1027    EXPECT_TRUE((IsLinear<int, CmpLin>()));
1028    EXPECT_TRUE((IsLinear<std::string, CmpLin>()));
1029    EXPECT_FALSE((IsLinear<Key, Cmp>()));
1030    EXPECT_TRUE((IsLinear<KeyLin, Cmp>()));
1031    EXPECT_FALSE((IsLinear<KeyBin, Cmp>()));
1032    EXPECT_TRUE((IsLinear<int, std::less<int>>()));
1033    EXPECT_TRUE((IsLinear<double, std::greater<double>>()));
1034    EXPECT_FALSE((IsLinear<int, Cmp>()));
1035    EXPECT_FALSE((IsLinear<std::string, std::less<std::string>>()));
1036  }
1037  TEST(Btree, BtreeMapCanHoldMoveOnlyTypes) {
1038    absl::btree_map<std::string, std::unique_ptr<std::string>> m;
1039    std::unique_ptr<std::string> &v = m["A"];
1040    EXPECT_TRUE(v == nullptr);
1041    v = absl::make_unique<std::string>("X");
1042    auto iter = m.find("A");
1043    EXPECT_EQ("X", *iter->second);
1044  }
1045  TEST(Btree, InitializerListConstructor) {
1046    absl::btree_set<std::string> set({"a", "b"});
1047    EXPECT_EQ(set.count("a"), 1);
1048    EXPECT_EQ(set.count("b"), 1);
1049    absl::btree_multiset<int> mset({1, 1, 4});
1050    EXPECT_EQ(mset.count(1), 2);
1051    EXPECT_EQ(mset.count(4), 1);
1052    absl::btree_map<int, int> map({{1, 5}, {2, 10}});
1053    EXPECT_EQ(map[1], 5);
1054    EXPECT_EQ(map[2], 10);
1055    absl::btree_multimap<int, int> mmap({{1, 5}, {1, 10}});
1056    auto range = mmap.equal_range(1);
1057    auto it = range.first;
1058    ASSERT_NE(it, range.second);
1059    EXPECT_EQ(it->second, 5);
1060    ASSERT_NE(++it, range.second);
1061    EXPECT_EQ(it->second, 10);
1062    EXPECT_EQ(++it, range.second);
1063  }
1064  TEST(Btree, InitializerListInsert) {
1065    absl::btree_set<std::string> set;
1066    set.insert({"a", "b"});
1067    EXPECT_EQ(set.count("a"), 1);
1068    EXPECT_EQ(set.count("b"), 1);
1069    absl::btree_multiset<int> mset;
1070    mset.insert({1, 1, 4});
1071    EXPECT_EQ(mset.count(1), 2);
1072    EXPECT_EQ(mset.count(4), 1);
1073    absl::btree_map<int, int> map;
1074    map.insert({{1, 5}, {2, 10}});
1075    map.insert({3, 15});
1076    EXPECT_EQ(map[1], 5);
1077    EXPECT_EQ(map[2], 10);
1078    EXPECT_EQ(map[3], 15);
1079    absl::btree_multimap<int, int> mmap;
1080    mmap.insert({{1, 5}, {1, 10}});
1081    auto range = mmap.equal_range(1);
1082    auto it = range.first;
1083    ASSERT_NE(it, range.second);
1084    EXPECT_EQ(it->second, 5);
1085    ASSERT_NE(++it, range.second);
1086    EXPECT_EQ(it->second, 10);
1087    EXPECT_EQ(++it, range.second);
1088  }
1089  template <typename Compare, typename Key>
1090  void AssertKeyCompareStringAdapted() {
1091    using Adapted = typename key_compare_adapter<Compare, Key>::type;
1092    static_assert(
1093        std::is_same<Adapted, StringBtreeDefaultLess>::value ||
1094            std::is_same<Adapted, StringBtreeDefaultGreater>::value,
1095        "key_compare_adapter should have string-adapted this comparator.");
1096  }
1097  template <typename Compare, typename Key>
1098  void AssertKeyCompareNotStringAdapted() {
1099    using Adapted = typename key_compare_adapter<Compare, Key>::type;
1100    static_assert(
1101        !std::is_same<Adapted, StringBtreeDefaultLess>::value &&
1102            !std::is_same<Adapted, StringBtreeDefaultGreater>::value,
1103        "key_compare_adapter shouldn't have string-adapted this comparator.");
1104  }
1105  TEST(Btree, KeyCompareAdapter) {
1106    AssertKeyCompareStringAdapted<std::less<std::string>, std::string>();
1107    AssertKeyCompareStringAdapted<std::greater<std::string>, std::string>();
1108    AssertKeyCompareStringAdapted<std::less<absl::string_view>,
1109                                  absl::string_view>();
1110    AssertKeyCompareStringAdapted<std::greater<absl::string_view>,
1111                                  absl::string_view>();
1112    AssertKeyCompareStringAdapted<std::less<absl::Cord>, absl::Cord>();
1113    AssertKeyCompareStringAdapted<std::greater<absl::Cord>, absl::Cord>();
1114    AssertKeyCompareNotStringAdapted<std::less<int>, int>();
1115    AssertKeyCompareNotStringAdapted<std::greater<int>, int>();
1116  }
1117  TEST(Btree, RValueInsert) {
1118    InstanceTracker tracker;
1119    absl::btree_set<MovableOnlyInstance> set;
1120    set.insert(MovableOnlyInstance(1));
1121    set.insert(MovableOnlyInstance(3));
1122    MovableOnlyInstance two(2);
1123    set.insert(set.find(MovableOnlyInstance(3)), std::move(two));
1124    auto it = set.find(MovableOnlyInstance(2));
1125    ASSERT_NE(it, set.end());
1126    ASSERT_NE(++it, set.end());
1127    EXPECT_EQ(it->value(), 3);
1128    absl::btree_multiset<MovableOnlyInstance> mset;
1129    MovableOnlyInstance zero(0);
1130    MovableOnlyInstance zero2(0);
1131    mset.insert(std::move(zero));
1132    mset.insert(mset.find(MovableOnlyInstance(0)), std::move(zero2));
1133    EXPECT_EQ(mset.count(MovableOnlyInstance(0)), 2);
1134    absl::btree_map<int, MovableOnlyInstance> map;
1135    std::pair<const int, MovableOnlyInstance> p1 = {1, MovableOnlyInstance(5)};
1136    std::pair<const int, MovableOnlyInstance> p2 = {2, MovableOnlyInstance(10)};
1137    std::pair<const int, MovableOnlyInstance> p3 = {3, MovableOnlyInstance(15)};
1138    map.insert(std::move(p1));
1139    map.insert(std::move(p3));
1140    map.insert(map.find(3), std::move(p2));
1141    ASSERT_NE(map.find(2), map.end());
1142    EXPECT_EQ(map.find(2)->second.value(), 10);
1143    absl::btree_multimap<int, MovableOnlyInstance> mmap;
1144    std::pair<const int, MovableOnlyInstance> p4 = {1, MovableOnlyInstance(5)};
1145    std::pair<const int, MovableOnlyInstance> p5 = {1, MovableOnlyInstance(10)};
1146    mmap.insert(std::move(p4));
1147    mmap.insert(mmap.find(1), std::move(p5));
1148    auto range = mmap.equal_range(1);
1149    auto it1 = range.first;
1150    ASSERT_NE(it1, range.second);
1151    EXPECT_EQ(it1->second.value(), 10);
1152    ASSERT_NE(++it1, range.second);
1153    EXPECT_EQ(it1->second.value(), 5);
1154    EXPECT_EQ(++it1, range.second);
1155    EXPECT_EQ(tracker.copies(), 0);
1156    EXPECT_EQ(tracker.swaps(), 0);
1157  }
1158  template <typename Cmp>
1159  struct CheckedCompareOptedOutCmp : Cmp, BtreeTestOnlyCheckedCompareOptOutBase {
1160    using Cmp::Cmp;
1161    CheckedCompareOptedOutCmp() {}
1162    CheckedCompareOptedOutCmp(Cmp cmp) : Cmp(std::move(cmp)) {}  
1163  };
1164  template <typename Key, int TargetValuesPerNode, typename Cmp = std::less<Key>>
1165  class SizedBtreeSet
1166      : public btree_set_container<btree<
1167            set_params<Key, CheckedCompareOptedOutCmp<Cmp>, std::allocator<Key>,
1168                       BtreeNodePeer::GetTargetNodeSize<Key>(TargetValuesPerNode),
1169                       false>>> {
1170    using Base = typename SizedBtreeSet::btree_set_container;
1171   public:
1172    SizedBtreeSet() = default;
1173    using Base::Base;
1174  };
1175  template <typename Set>
1176  void ExpectOperationCounts(const int expected_moves,
1177                             const int expected_comparisons,
1178                             const std::vector<int> &values,
1179                             InstanceTracker *tracker, Set *set) {
1180    for (const int v : values) set->insert(MovableOnlyInstance(v));
1181    set->clear();
1182    EXPECT_EQ(tracker->moves(), expected_moves);
1183    EXPECT_EQ(tracker->comparisons(), expected_comparisons);
1184    EXPECT_EQ(tracker->copies(), 0);
1185    EXPECT_EQ(tracker->swaps(), 0);
1186    tracker->ResetCopiesMovesSwaps();
1187  }
1188  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
1189  constexpr bool kAsan = true;
1190  #else
1191  constexpr bool kAsan = false;
1192  #endif
1193  TEST(Btree, MovesComparisonsCopiesSwapsTracking) {
1194    if (kAsan) GTEST_SKIP() << "We do extra operations in ASan mode.";
1195    InstanceTracker tracker;
1196    SizedBtreeSet<MovableOnlyInstance, &bsol;*TargetValuesPerNode=*/4> set4;
1197    SizedBtreeSet<MovableOnlyInstance, &bsol;*TargetValuesPerNode=*/61> set61;
1198    SizedBtreeSet<MovableOnlyInstance, &bsol;*TargetValuesPerNode=*/100> set100;
1199    std::vector<int> values =
1200        GenerateValuesWithSeed<int>(10000, 1 << 22, &bsol;*seed=*/23);
1201    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<decltype(set4)>(), 4);
1202    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<decltype(set61)>(), 61);
1203    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<decltype(set100)>(), 100);
1204    if (sizeof(void *) == 8) {
1205      EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<absl::btree_set<int32_t>>(),
1206                BtreeGenerationsEnabled() ? 60 : 61);
1207    }
1208    ExpectOperationCounts(56540, 134212, values, &tracker, &set4);
1209    ExpectOperationCounts(386718, 129807, values, &tracker, &set61);
1210    ExpectOperationCounts(586761, 130310, values, &tracker, &set100);
1211    std::sort(values.begin(), values.end());
1212    ExpectOperationCounts(24972, 85563, values, &tracker, &set4);
1213    ExpectOperationCounts(20208, 87757, values, &tracker, &set61);
1214    ExpectOperationCounts(20124, 96583, values, &tracker, &set100);
1215    std::reverse(values.begin(), values.end());
1216    ExpectOperationCounts(54949, 127531, values, &tracker, &set4);
1217    ExpectOperationCounts(338813, 118266, values, &tracker, &set61);
1218    ExpectOperationCounts(534529, 125279, values, &tracker, &set100);
1219  }
1220  struct MovableOnlyInstanceThreeWayCompare {
1221    absl::weak_ordering operator()(const MovableOnlyInstance &a,
1222                                   const MovableOnlyInstance &b) const {
1223      return a.compare(b);
1224    }
1225  };
1226  TEST(Btree, MovesComparisonsCopiesSwapsTrackingThreeWayCompare) {
1227    if (kAsan) GTEST_SKIP() << "We do extra operations in ASan mode.";
1228    InstanceTracker tracker;
1229    SizedBtreeSet<MovableOnlyInstance, &bsol;*TargetValuesPerNode=*/4,
1230                  MovableOnlyInstanceThreeWayCompare>
1231        set4;
1232    SizedBtreeSet<MovableOnlyInstance, &bsol;*TargetValuesPerNode=*/61,
1233                  MovableOnlyInstanceThreeWayCompare>
1234        set61;
1235    SizedBtreeSet<MovableOnlyInstance, &bsol;*TargetValuesPerNode=*/100,
1236                  MovableOnlyInstanceThreeWayCompare>
1237        set100;
1238    std::vector<int> values =
1239        GenerateValuesWithSeed<int>(10000, 1 << 22, &bsol;*seed=*/23);
1240    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<decltype(set4)>(), 4);
1241    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<decltype(set61)>(), 61);
1242    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<decltype(set100)>(), 100);
1243    if (sizeof(void *) == 8) {
1244      EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode<absl::btree_set<int32_t>>(),
1245                BtreeGenerationsEnabled() ? 60 : 61);
1246    }
1247    ExpectOperationCounts(56540, 124221, values, &tracker, &set4);
1248    ExpectOperationCounts(386718, 119816, values, &tracker, &set61);
1249    ExpectOperationCounts(586761, 120319, values, &tracker, &set100);
1250    std::sort(values.begin(), values.end());
1251    ExpectOperationCounts(24972, 85563, values, &tracker, &set4);
1252    ExpectOperationCounts(20208, 87757, values, &tracker, &set61);
1253    ExpectOperationCounts(20124, 96583, values, &tracker, &set100);
1254    std::reverse(values.begin(), values.end());
1255    ExpectOperationCounts(54949, 117532, values, &tracker, &set4);
1256    ExpectOperationCounts(338813, 108267, values, &tracker, &set61);
1257    ExpectOperationCounts(534529, 115280, values, &tracker, &set100);
1258  }
1259  struct NoDefaultCtor {
1260    int num;
1261    explicit NoDefaultCtor(int i) : num(i) {}
1262    friend bool operator<(const NoDefaultCtor &a, const NoDefaultCtor &b) {
1263      return a.num < b.num;
1264    }
1265  };
1266  TEST(Btree, BtreeMapCanHoldNoDefaultCtorTypes) {
1267    absl::btree_map<NoDefaultCtor, NoDefaultCtor> m;
1268    for (int i = 1; i <= 99; ++i) {
1269      SCOPED_TRACE(i);
1270      EXPECT_TRUE(m.emplace(NoDefaultCtor(i), NoDefaultCtor(100 - i)).second);
1271    }
1272    EXPECT_FALSE(m.emplace(NoDefaultCtor(78), NoDefaultCtor(0)).second);
1273    auto iter99 = m.find(NoDefaultCtor(99));
1274    ASSERT_NE(iter99, m.end());
1275    EXPECT_EQ(iter99->second.num, 1);
1276    auto iter1 = m.find(NoDefaultCtor(1));
1277    ASSERT_NE(iter1, m.end());
1278    EXPECT_EQ(iter1->second.num, 99);
1279    auto iter50 = m.find(NoDefaultCtor(50));
1280    ASSERT_NE(iter50, m.end());
1281    EXPECT_EQ(iter50->second.num, 50);
1282    auto iter25 = m.find(NoDefaultCtor(25));
1283    ASSERT_NE(iter25, m.end());
1284    EXPECT_EQ(iter25->second.num, 75);
1285  }
1286  TEST(Btree, BtreeMultimapCanHoldNoDefaultCtorTypes) {
1287    absl::btree_multimap<NoDefaultCtor, NoDefaultCtor> m;
1288    for (int i = 1; i <= 99; ++i) {
1289      SCOPED_TRACE(i);
1290      m.emplace(NoDefaultCtor(i), NoDefaultCtor(100 - i));
1291    }
1292    auto iter99 = m.find(NoDefaultCtor(99));
1293    ASSERT_NE(iter99, m.end());
1294    EXPECT_EQ(iter99->second.num, 1);
1295    auto iter1 = m.find(NoDefaultCtor(1));
1296    ASSERT_NE(iter1, m.end());
1297    EXPECT_EQ(iter1->second.num, 99);
1298    auto iter50 = m.find(NoDefaultCtor(50));
1299    ASSERT_NE(iter50, m.end());
1300    EXPECT_EQ(iter50->second.num, 50);
1301    auto iter25 = m.find(NoDefaultCtor(25));
1302    ASSERT_NE(iter25, m.end());
1303    EXPECT_EQ(iter25->second.num, 75);
1304  }
1305  TEST(Btree, MapAt) {
1306    absl::btree_map<int, int> map = {{1, 2}, {2, 4}};
1307    EXPECT_EQ(map.at(1), 2);
1308    EXPECT_EQ(map.at(2), 4);
1309    map.at(2) = 8;
1310    const absl::btree_map<int, int> &const_map = map;
1311    EXPECT_EQ(const_map.at(1), 2);
1312    EXPECT_EQ(const_map.at(2), 8);
1313  #ifdef ABSL_HAVE_EXCEPTIONS
1314    EXPECT_THROW(map.at(3), std::out_of_range);
1315  #else
1316    EXPECT_DEATH_IF_SUPPORTED(map.at(3), "absl::btree_map::at");
1317  #endif
1318  }
1319  TEST(Btree, BtreeMultisetEmplace) {
1320    const int value_to_insert = 123456;
1321    absl::btree_multiset<int> s;
1322    auto iter = s.emplace(value_to_insert);
1323    ASSERT_NE(iter, s.end());
1324    EXPECT_EQ(*iter, value_to_insert);
1325    iter = s.emplace(value_to_insert);
1326    ASSERT_NE(iter, s.end());
1327    EXPECT_EQ(*iter, value_to_insert);
1328    auto result = s.equal_range(value_to_insert);
1329    EXPECT_EQ(std::distance(result.first, result.second), 2);
1330  }
1331  TEST(Btree, BtreeMultisetEmplaceHint) {
1332    const int value_to_insert = 123456;
1333    absl::btree_multiset<int> s;
1334    auto iter = s.emplace(value_to_insert);
1335    ASSERT_NE(iter, s.end());
1336    EXPECT_EQ(*iter, value_to_insert);
1337    iter = s.emplace_hint(iter, value_to_insert);
1338    EXPECT_EQ(iter, s.lower_bound(value_to_insert));
1339    ASSERT_NE(iter, s.end());
1340    EXPECT_EQ(*iter, value_to_insert);
1341  }
1342  TEST(Btree, BtreeMultimapEmplace) {
1343    const int key_to_insert = 123456;
1344    const char value0[] = "a";
1345    absl::btree_multimap<int, std::string> m;
1346    auto iter = m.emplace(key_to_insert, value0);
1347    ASSERT_NE(iter, m.end());
1348    EXPECT_EQ(iter->first, key_to_insert);
1349    EXPECT_EQ(iter->second, value0);
1350    const char value1[] = "b";
1351    iter = m.emplace(key_to_insert, value1);
1352    ASSERT_NE(iter, m.end());
1353    EXPECT_EQ(iter->first, key_to_insert);
1354    EXPECT_EQ(iter->second, value1);
1355    auto result = m.equal_range(key_to_insert);
1356    EXPECT_EQ(std::distance(result.first, result.second), 2);
1357  }
1358  TEST(Btree, BtreeMultimapEmplaceHint) {
1359    const int key_to_insert = 123456;
1360    const char value0[] = "a";
1361    absl::btree_multimap<int, std::string> m;
1362    auto iter = m.emplace(key_to_insert, value0);
1363    ASSERT_NE(iter, m.end());
1364    EXPECT_EQ(iter->first, key_to_insert);
1365    EXPECT_EQ(iter->second, value0);
1366    const char value1[] = "b";
1367    iter = m.emplace_hint(iter, key_to_insert, value1);
1368    EXPECT_EQ(iter, m.lower_bound(key_to_insert));
1369    ASSERT_NE(iter, m.end());
1370    EXPECT_EQ(iter->first, key_to_insert);
1371    EXPECT_EQ(iter->second, value1);
1372  }
1373  TEST(Btree, ConstIteratorAccessors) {
1374    absl::btree_set<int> set;
1375    for (int i = 0; i < 100; ++i) {
1376      set.insert(i);
1377    }
1378    auto it = set.cbegin();
1379    auto r_it = set.crbegin();
1380    for (int i = 0; i < 100; ++i, ++it, ++r_it) {
1381      ASSERT_EQ(*it, i);
1382      ASSERT_EQ(*r_it, 99 - i);
1383    }
1384    EXPECT_EQ(it, set.cend());
1385    EXPECT_EQ(r_it, set.crend());
1386  }
1387  TEST(Btree, StrSplitCompatible) {
1388    const absl::btree_set<std::string> split_set = absl::StrSplit("a,b,c", ',');
1389    const absl::btree_set<std::string> expected_set = {"a", "b", "c"};
1390    EXPECT_EQ(split_set, expected_set);
1391  }
1392  TEST(Btree, KeyComp) {
1393    absl::btree_set<int> s;
1394    EXPECT_TRUE(s.key_comp()(1, 2));
1395    EXPECT_FALSE(s.key_comp()(2, 2));
1396    EXPECT_FALSE(s.key_comp()(2, 1));
1397    absl::btree_map<int, int> m1;
1398    EXPECT_TRUE(m1.key_comp()(1, 2));
1399    EXPECT_FALSE(m1.key_comp()(2, 2));
1400    EXPECT_FALSE(m1.key_comp()(2, 1));
1401    absl::btree_map<std::string, int> m2;
1402    EXPECT_TRUE(m2.key_comp()("a", "b"));
1403    EXPECT_FALSE(m2.key_comp()("b", "b"));
1404    EXPECT_FALSE(m2.key_comp()("b", "a"));
1405  }
1406  TEST(Btree, ValueComp) {
1407    absl::btree_set<int> s;
1408    EXPECT_TRUE(s.value_comp()(1, 2));
1409    EXPECT_FALSE(s.value_comp()(2, 2));
1410    EXPECT_FALSE(s.value_comp()(2, 1));
1411    absl::btree_map<int, int> m1;
1412    EXPECT_TRUE(m1.value_comp()(std::make_pair(1, 0), std::make_pair(2, 0)));
1413    EXPECT_FALSE(m1.value_comp()(std::make_pair(2, 0), std::make_pair(2, 0)));
1414    EXPECT_FALSE(m1.value_comp()(std::make_pair(2, 0), std::make_pair(1, 0)));
1415    absl::btree_map<std::string, int> m2;
1416    EXPECT_TRUE(m2.value_comp()(std::make_pair("a", 0), std::make_pair("b", 0)));
1417    EXPECT_FALSE(m2.value_comp()(std::make_pair("b", 0), std::make_pair("b", 0)));
1418    EXPECT_FALSE(m2.value_comp()(std::make_pair("b", 0), std::make_pair("a", 0)));
1419  }
1420  TEST(Btree, MapValueCompProtected) {
1421    struct key_compare {
1422      bool operator()(int l, int r) const { return l < r; }
1423      int id;
1424    };
1425    using value_compare = absl::btree_map<int, int, key_compare>::value_compare;
1426    struct value_comp_child : public value_compare {
1427      explicit value_comp_child(key_compare kc) : value_compare(kc) {}
1428      int GetId() const { return comp.id; }
1429    };
1430    value_comp_child c(key_compare{10});
1431    EXPECT_EQ(c.GetId(), 10);
1432  }
1433  TEST(Btree, DefaultConstruction) {
1434    absl::btree_set<int> s;
1435    absl::btree_map<int, int> m;
1436    absl::btree_multiset<int> ms;
1437    absl::btree_multimap<int, int> mm;
1438    EXPECT_TRUE(s.empty());
1439    EXPECT_TRUE(m.empty());
1440    EXPECT_TRUE(ms.empty());
1441    EXPECT_TRUE(mm.empty());
1442  }
1443  TEST(Btree, SwissTableHashable) {
1444    static constexpr int kValues = 10000;
1445    std::vector<int> values(kValues);
1446    std::iota(values.begin(), values.end(), 0);
1447    std::vector<std::pair<int, int>> map_values;
1448    for (int v : values) map_values.emplace_back(v, -v);
1449    using set = absl::btree_set<int>;
1450    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1451        set{},
1452        set{1},
1453        set{2},
1454        set{1, 2},
1455        set{2, 1},
1456        set(values.begin(), values.end()),
1457        set(values.rbegin(), values.rend()),
1458    }));
1459    using mset = absl::btree_multiset<int>;
1460    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1461        mset{},
1462        mset{1},
1463        mset{1, 1},
1464        mset{2},
1465        mset{2, 2},
1466        mset{1, 2},
1467        mset{1, 1, 2},
1468        mset{1, 2, 2},
1469        mset{1, 1, 2, 2},
1470        mset(values.begin(), values.end()),
1471        mset(values.rbegin(), values.rend()),
1472    }));
1473    using map = absl::btree_map<int, int>;
1474    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1475        map{},
1476        map{{1, 0}},
1477        map{{1, 1}},
1478        map{{2, 0}},
1479        map{{2, 2}},
1480        map{{1, 0}, {2, 1}},
1481        map(map_values.begin(), map_values.end()),
1482        map(map_values.rbegin(), map_values.rend()),
1483    }));
1484    using mmap = absl::btree_multimap<int, int>;
1485    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1486        mmap{},
1487        mmap{{1, 0}},
1488        mmap{{1, 1}},
1489        mmap{{1, 0}, {1, 1}},
1490        mmap{{1, 1}, {1, 0}},
1491        mmap{{2, 0}},
1492        mmap{{2, 2}},
1493        mmap{{1, 0}, {2, 1}},
1494        mmap(map_values.begin(), map_values.end()),
1495        mmap(map_values.rbegin(), map_values.rend()),
1496    }));
1497  }
1498  TEST(Btree, ComparableSet) {
1499    absl::btree_set<int> s1 = {1, 2};
1500    absl::btree_set<int> s2 = {2, 3};
1501    EXPECT_LT(s1, s2);
1502    EXPECT_LE(s1, s2);
1503    EXPECT_LE(s1, s1);
1504    EXPECT_GT(s2, s1);
1505    EXPECT_GE(s2, s1);
1506    EXPECT_GE(s1, s1);
1507  }
1508  TEST(Btree, ComparableSetsDifferentLength) {
1509    absl::btree_set<int> s1 = {1, 2};
1510    absl::btree_set<int> s2 = {1, 2, 3};
1511    EXPECT_LT(s1, s2);
1512    EXPECT_LE(s1, s2);
1513    EXPECT_GT(s2, s1);
1514    EXPECT_GE(s2, s1);
1515  }
1516  TEST(Btree, ComparableMultiset) {
1517    absl::btree_multiset<int> s1 = {1, 2};
1518    absl::btree_multiset<int> s2 = {2, 3};
1519    EXPECT_LT(s1, s2);
1520    EXPECT_LE(s1, s2);
1521    EXPECT_LE(s1, s1);
1522    EXPECT_GT(s2, s1);
1523    EXPECT_GE(s2, s1);
1524    EXPECT_GE(s1, s1);
1525  }
1526  TEST(Btree, ComparableMap) {
1527    absl::btree_map<int, int> s1 = {{1, 2}};
1528    absl::btree_map<int, int> s2 = {{2, 3}};
1529    EXPECT_LT(s1, s2);
1530    EXPECT_LE(s1, s2);
1531    EXPECT_LE(s1, s1);
1532    EXPECT_GT(s2, s1);
1533    EXPECT_GE(s2, s1);
1534    EXPECT_GE(s1, s1);
1535  }
1536  TEST(Btree, ComparableMultimap) {
1537    absl::btree_multimap<int, int> s1 = {{1, 2}};
1538    absl::btree_multimap<int, int> s2 = {{2, 3}};
1539    EXPECT_LT(s1, s2);
1540    EXPECT_LE(s1, s2);
1541    EXPECT_LE(s1, s1);
1542    EXPECT_GT(s2, s1);
1543    EXPECT_GE(s2, s1);
1544    EXPECT_GE(s1, s1);
1545  }
1546  TEST(Btree, ComparableSetWithCustomComparator) {
1547    absl::btree_set<int, std::greater<int>> s1 = {1, 2};
1548    absl::btree_set<int, std::greater<int>> s2 = {2, 3};
1549    EXPECT_LT(s1, s2);
1550    EXPECT_LE(s1, s2);
1551    EXPECT_LE(s1, s1);
1552    EXPECT_GT(s2, s1);
1553    EXPECT_GE(s2, s1);
1554    EXPECT_GE(s1, s1);
1555  }
1556  TEST(Btree, EraseReturnsIterator) {
1557    absl::btree_set<int> set = {1, 2, 3, 4, 5};
1558    auto result_it = set.erase(set.begin(), set.find(3));
1559    EXPECT_EQ(result_it, set.find(3));
1560    result_it = set.erase(set.find(5));
1561    EXPECT_EQ(result_it, set.end());
1562  }
1563  TEST(Btree, ExtractAndInsertNodeHandleSet) {
1564    absl::btree_set<int> src1 = {1, 2, 3, 4, 5};
1565    auto nh = src1.extract(src1.find(3));
1566    EXPECT_THAT(src1, ElementsAre(1, 2, 4, 5));
1567    absl::btree_set<int> other;
1568    absl::btree_set<int>::insert_return_type res = other.insert(std::move(nh));
1569    EXPECT_THAT(other, ElementsAre(3));
1570    EXPECT_EQ(res.position, other.find(3));
1571    EXPECT_TRUE(res.inserted);
1572    EXPECT_TRUE(res.node.empty());
1573    absl::btree_set<int> src2 = {3, 4};
1574    nh = src2.extract(src2.find(3));
1575    EXPECT_THAT(src2, ElementsAre(4));
1576    res = other.insert(std::move(nh));
1577    EXPECT_THAT(other, ElementsAre(3));
1578    EXPECT_EQ(res.position, other.find(3));
1579    EXPECT_FALSE(res.inserted);
1580    ASSERT_FALSE(res.node.empty());
1581    EXPECT_EQ(res.node.value(), 3);
1582  }
1583  template <typename Set>
1584  void TestExtractWithTrackingForSet() {
1585    InstanceTracker tracker;
1586    {
1587      Set s;
1588      const size_t kSize = 1000;
1589      while (s.size() < kSize) {
1590        s.insert(MovableOnlyInstance(s.size()));
1591      }
1592      for (int i = 0; i < kSize; ++i) {
1593        auto nh = s.extract(MovableOnlyInstance(i));
1594        EXPECT_EQ(s.size(), kSize - 1);
1595        EXPECT_EQ(nh.value().value(), i);
1596        s.insert(std::move(nh));
1597        EXPECT_EQ(s.size(), kSize);
1598        auto it = s.find(MovableOnlyInstance(i));
1599        nh = s.extract(it);
1600        EXPECT_EQ(s.size(), kSize - 1);
1601        EXPECT_EQ(nh.value().value(), i);
1602        s.insert(s.begin(), std::move(nh));
1603        EXPECT_EQ(s.size(), kSize);
1604      }
1605    }
1606    EXPECT_EQ(0, tracker.instances());
1607  }
1608  template <typename Map>
1609  void TestExtractWithTrackingForMap() {
1610    InstanceTracker tracker;
1611    {
1612      Map m;
1613      const size_t kSize = 1000;
1614      while (m.size() < kSize) {
1615        m.insert(
1616            {CopyableMovableInstance(m.size()), MovableOnlyInstance(m.size())});
1617      }
1618      for (int i = 0; i < kSize; ++i) {
1619        auto nh = m.extract(CopyableMovableInstance(i));
1620        EXPECT_EQ(m.size(), kSize - 1);
1621        EXPECT_EQ(nh.key().value(), i);
1622        EXPECT_EQ(nh.mapped().value(), i);
1623        m.insert(std::move(nh));
1624        EXPECT_EQ(m.size(), kSize);
1625        auto it = m.find(CopyableMovableInstance(i));
1626        nh = m.extract(it);
1627        EXPECT_EQ(m.size(), kSize - 1);
1628        EXPECT_EQ(nh.key().value(), i);
1629        EXPECT_EQ(nh.mapped().value(), i);
1630        m.insert(m.begin(), std::move(nh));
1631        EXPECT_EQ(m.size(), kSize);
1632      }
1633    }
1634    EXPECT_EQ(0, tracker.instances());
1635  }
1636  TEST(Btree, ExtractTracking) {
1637    TestExtractWithTrackingForSet<absl::btree_set<MovableOnlyInstance>>();
1638    TestExtractWithTrackingForSet<absl::btree_multiset<MovableOnlyInstance>>();
1639    TestExtractWithTrackingForMap<
1640        absl::btree_map<CopyableMovableInstance, MovableOnlyInstance>>();
1641    TestExtractWithTrackingForMap<
1642        absl::btree_multimap<CopyableMovableInstance, MovableOnlyInstance>>();
1643  }
1644  TEST(Btree, ExtractAndInsertNodeHandleMultiSet) {
1645    absl::btree_multiset<int> src1 = {1, 2, 3, 3, 4, 5};
1646    auto nh = src1.extract(src1.find(3));
1647    EXPECT_THAT(src1, ElementsAre(1, 2, 3, 4, 5));
1648    absl::btree_multiset<int> other;
1649    auto res = other.insert(std::move(nh));
1650    EXPECT_THAT(other, ElementsAre(3));
1651    EXPECT_EQ(res, other.find(3));
1652    absl::btree_multiset<int> src2 = {3, 4};
1653    nh = src2.extract(src2.find(3));
1654    EXPECT_THAT(src2, ElementsAre(4));
1655    res = other.insert(std::move(nh));
1656    EXPECT_THAT(other, ElementsAre(3, 3));
1657    EXPECT_EQ(res, ++other.find(3));
1658  }
1659  TEST(Btree, ExtractAndInsertNodeHandleMap) {
1660    absl::btree_map<int, int> src1 = {{1, 2}, {3, 4}, {5, 6}};
1661    auto nh = src1.extract(src1.find(3));
1662    EXPECT_THAT(src1, ElementsAre(Pair(1, 2), Pair(5, 6)));
1663    absl::btree_map<int, int> other;
1664    absl::btree_map<int, int>::insert_return_type res =
1665        other.insert(std::move(nh));
1666    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1667    EXPECT_EQ(res.position, other.find(3));
1668    EXPECT_TRUE(res.inserted);
1669    EXPECT_TRUE(res.node.empty());
1670    absl::btree_map<int, int> src2 = {{3, 6}};
1671    nh = src2.extract(src2.find(3));
1672    EXPECT_TRUE(src2.empty());
1673    res = other.insert(std::move(nh));
1674    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1675    EXPECT_EQ(res.position, other.find(3));
1676    EXPECT_FALSE(res.inserted);
1677    ASSERT_FALSE(res.node.empty());
1678    EXPECT_EQ(res.node.key(), 3);
1679    EXPECT_EQ(res.node.mapped(), 6);
1680  }
1681  TEST(Btree, ExtractAndInsertNodeHandleMultiMap) {
1682    absl::btree_multimap<int, int> src1 = {{1, 2}, {3, 4}, {5, 6}};
1683    auto nh = src1.extract(src1.find(3));
1684    EXPECT_THAT(src1, ElementsAre(Pair(1, 2), Pair(5, 6)));
1685    absl::btree_multimap<int, int> other;
1686    auto res = other.insert(std::move(nh));
1687    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1688    EXPECT_EQ(res, other.find(3));
1689    absl::btree_multimap<int, int> src2 = {{3, 6}};
1690    nh = src2.extract(src2.find(3));
1691    EXPECT_TRUE(src2.empty());
1692    res = other.insert(std::move(nh));
1693    EXPECT_THAT(other, ElementsAre(Pair(3, 4), Pair(3, 6)));
1694    EXPECT_EQ(res, ++other.begin());
1695  }
1696  TEST(Btree, ExtractMultiMapEquivalentKeys) {
1697    absl::btree_multimap<std::string, int> map;
1698    for (int i = 0; i < 100; ++i) {
1699      for (int j = 0; j < 100; ++j) {
1700        map.insert({absl::StrCat(i), j});
1701      }
1702    }
1703    for (int i = 0; i < 100; ++i) {
1704      const std::string key = absl::StrCat(i);
1705      auto node_handle = map.extract(key);
1706      EXPECT_EQ(node_handle.key(), key);
1707      EXPECT_EQ(node_handle.mapped(), 0) << i;
1708    }
1709    for (int i = 0; i < 100; ++i) {
1710      const std::string key = absl::StrCat(i);
1711      auto node_handle = map.extract(key);
1712      EXPECT_EQ(node_handle.key(), key);
1713      EXPECT_EQ(node_handle.mapped(), 1) << i;
1714    }
1715  }
1716  TEST(Btree, ExtractAndGetNextSet) {
1717    absl::btree_set<int> src = {1, 2, 3, 4, 5};
1718    auto it = src.find(3);
1719    auto extracted_and_next = src.extract_and_get_next(it);
1720    EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1721    EXPECT_EQ(extracted_and_next.node.value(), 3);
1722    EXPECT_EQ(*extracted_and_next.next, 4);
1723  }
1724  TEST(Btree, ExtractAndGetNextMultiSet) {
1725    absl::btree_multiset<int> src = {1, 2, 3, 4, 5};
1726    auto it = src.find(3);
1727    auto extracted_and_next = src.extract_and_get_next(it);
1728    EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1729    EXPECT_EQ(extracted_and_next.node.value(), 3);
1730    EXPECT_EQ(*extracted_and_next.next, 4);
1731  }
1732  TEST(Btree, ExtractAndGetNextMap) {
1733    absl::btree_map<int, int> src = {{1, 2}, {3, 4}, {5, 6}};
1734    auto it = src.find(3);
1735    auto extracted_and_next = src.extract_and_get_next(it);
1736    EXPECT_THAT(src, ElementsAre(Pair(1, 2), Pair(5, 6)));
1737    EXPECT_EQ(extracted_and_next.node.key(), 3);
1738    EXPECT_EQ(extracted_and_next.node.mapped(), 4);
1739    EXPECT_THAT(*extracted_and_next.next, Pair(5, 6));
1740  }
1741  TEST(Btree, ExtractAndGetNextMultiMap) {
1742    absl::btree_multimap<int, int> src = {{1, 2}, {3, 4}, {5, 6}};
1743    auto it = src.find(3);
1744    auto extracted_and_next = src.extract_and_get_next(it);
1745    EXPECT_THAT(src, ElementsAre(Pair(1, 2), Pair(5, 6)));
1746    EXPECT_EQ(extracted_and_next.node.key(), 3);
1747    EXPECT_EQ(extracted_and_next.node.mapped(), 4);
1748    EXPECT_THAT(*extracted_and_next.next, Pair(5, 6));
1749  }
1750  TEST(Btree, ExtractAndGetNextEndIter) {
1751    absl::btree_set<int> src = {1, 2, 3, 4, 5};
1752    auto it = src.find(5);
1753    auto extracted_and_next = src.extract_and_get_next(it);
1754    EXPECT_THAT(src, ElementsAre(1, 2, 3, 4));
1755    EXPECT_EQ(extracted_and_next.node.value(), 5);
1756    EXPECT_EQ(extracted_and_next.next, src.end());
1757  }
1758  TEST(Btree, ExtractDoesntCauseExtraMoves) {
1759  #ifdef _MSC_VER
1760    GTEST_SKIP() << "This test fails on MSVC.";
1761  #endif
1762    using Set = absl::btree_set<MovableOnlyInstance>;
1763    std::array<std::function<void(Set &)>, 3> extracters = {
1764        [](Set &s) { auto node = s.extract(s.begin()); },
1765        [](Set &s) { auto ret = s.extract_and_get_next(s.begin()); },
1766        [](Set &s) { auto node = s.extract(MovableOnlyInstance(0)); }};
1767    InstanceTracker tracker;
1768    for (int i = 0; i < 3; ++i) {
1769      Set s;
1770      s.insert(MovableOnlyInstance(0));
1771      tracker.ResetCopiesMovesSwaps();
1772      extracters[i](s);
1773      EXPECT_EQ(tracker.copies(), 0) << i;
1774      EXPECT_EQ(tracker.moves(), 1) << i;
1775      EXPECT_EQ(tracker.swaps(), 0) << i;
1776    }
1777  }
1778  struct InsertMultiHintData {
1779    int key;
1780    int not_key;
1781    bool operator==(const InsertMultiHintData other) const {
1782      return key == other.key && not_key == other.not_key;
1783    }
1784  };
1785  struct InsertMultiHintDataKeyCompare {
1786    using is_transparent = void;
1787    bool operator()(const InsertMultiHintData a,
1788                    const InsertMultiHintData b) const {
1789      return a.key < b.key;
1790    }
1791    bool operator()(const int a, const InsertMultiHintData b) const {
1792      return a < b.key;
1793    }
1794    bool operator()(const InsertMultiHintData a, const int b) const {
1795      return a.key < b;
1796    }
1797  };
1798  TEST(Btree, InsertHintNodeHandle) {
1799    {
1800      absl::btree_set<int> src = {1, 2, 3, 4, 5};
1801      auto nh = src.extract(src.find(3));
1802      EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1803      absl::btree_set<int> other = {0, 100};
1804      auto it = other.insert(other.lower_bound(3), std::move(nh));
1805      EXPECT_THAT(other, ElementsAre(0, 3, 100));
1806      EXPECT_EQ(it, other.find(3));
1807      nh = src.extract(src.find(5));
1808      it = other.insert(other.end(), std::move(nh));
1809      EXPECT_THAT(other, ElementsAre(0, 3, 5, 100));
1810      EXPECT_EQ(it, other.find(5));
1811    }
1812    absl::btree_multiset<InsertMultiHintData, InsertMultiHintDataKeyCompare> src =
1813        {{1, 2}, {3, 4}, {3, 5}};
1814    auto nh = src.extract(src.lower_bound(3));
1815    EXPECT_EQ(nh.value(), (InsertMultiHintData{3, 4}));
1816    absl::btree_multiset<InsertMultiHintData, InsertMultiHintDataKeyCompare>
1817        other = {{3, 1}, {3, 2}, {3, 3}};
1818    auto it = other.insert(--other.end(), std::move(nh));
1819    EXPECT_THAT(
1820        other, ElementsAre(InsertMultiHintData{3, 1}, InsertMultiHintData{3, 2},
1821                           InsertMultiHintData{3, 4}, InsertMultiHintData{3, 3}));
1822    EXPECT_EQ(it, --(--other.end()));
1823    nh = src.extract(src.find(3));
1824    EXPECT_EQ(nh.value(), (InsertMultiHintData{3, 5}));
1825    it = other.insert(other.begin(), std::move(nh));
1826    EXPECT_THAT(other,
1827                ElementsAre(InsertMultiHintData{3, 5}, InsertMultiHintData{3, 1},
1828                            InsertMultiHintData{3, 2}, InsertMultiHintData{3, 4},
1829                            InsertMultiHintData{3, 3}));
1830    EXPECT_EQ(it, other.begin());
1831  }
1832  struct IntCompareToCmp {
1833    absl::weak_ordering operator()(int a, int b) const {
1834      if (a < b) return absl::weak_ordering::less;
1835      if (a > b) return absl::weak_ordering::greater;
1836      return absl::weak_ordering::equivalent;
1837    }
1838  };
1839  TEST(Btree, MergeIntoUniqueContainers) {
1840    absl::btree_set<int, IntCompareToCmp> src1 = {1, 2, 3};
1841    absl::btree_multiset<int> src2 = {3, 4, 4, 5};
1842    absl::btree_set<int> dst;
1843    dst.merge(src1);
1844    EXPECT_TRUE(src1.empty());
1845    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1846    dst.merge(src2);
1847    EXPECT_THAT(src2, ElementsAre(3, 4));
1848    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 4, 5));
1849  }
1850  TEST(Btree, MergeIntoUniqueContainersWithCompareTo) {
1851    absl::btree_set<int, IntCompareToCmp> src1 = {1, 2, 3};
1852    absl::btree_multiset<int> src2 = {3, 4, 4, 5};
1853    absl::btree_set<int, IntCompareToCmp> dst;
1854    dst.merge(src1);
1855    EXPECT_TRUE(src1.empty());
1856    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1857    dst.merge(src2);
1858    EXPECT_THAT(src2, ElementsAre(3, 4));
1859    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 4, 5));
1860  }
1861  TEST(Btree, MergeIntoMultiContainers) {
1862    absl::btree_set<int, IntCompareToCmp> src1 = {1, 2, 3};
1863    absl::btree_multiset<int> src2 = {3, 4, 4, 5};
1864    absl::btree_multiset<int> dst;
1865    dst.merge(src1);
1866    EXPECT_TRUE(src1.empty());
1867    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1868    dst.merge(src2);
1869    EXPECT_TRUE(src2.empty());
1870    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 3, 4, 4, 5));
1871  }
1872  TEST(Btree, MergeIntoMultiContainersWithCompareTo) {
1873    absl::btree_set<int, IntCompareToCmp> src1 = {1, 2, 3};
1874    absl::btree_multiset<int> src2 = {3, 4, 4, 5};
1875    absl::btree_multiset<int, IntCompareToCmp> dst;
1876    dst.merge(src1);
1877    EXPECT_TRUE(src1.empty());
1878    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1879    dst.merge(src2);
1880    EXPECT_TRUE(src2.empty());
1881    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 3, 4, 4, 5));
1882  }
1883  TEST(Btree, MergeIntoMultiMapsWithDifferentComparators) {
1884    absl::btree_map<int, int, IntCompareToCmp> src1 = {{1, 1}, {2, 2}, {3, 3}};
1885    absl::btree_multimap<int, int, std::greater<int>> src2 = {
1886        {5, 5}, {4, 1}, {4, 4}, {3, 2}};
1887    absl::btree_multimap<int, int> dst;
1888    dst.merge(src1);
1889    EXPECT_TRUE(src1.empty());
1890    EXPECT_THAT(dst, ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3)));
1891    dst.merge(src2);
1892    EXPECT_TRUE(src2.empty());
1893    EXPECT_THAT(dst, ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(3, 2),
1894                                 Pair(4, 1), Pair(4, 4), Pair(5, 5)));
1895  }
1896  TEST(Btree, MergeIntoSetMovableOnly) {
1897    absl::btree_set<MovableOnlyInstance> src;
1898    src.insert(MovableOnlyInstance(1));
1899    absl::btree_multiset<MovableOnlyInstance> dst1;
1900    dst1.insert(MovableOnlyInstance(2));
1901    absl::btree_set<MovableOnlyInstance> dst2;
1902    dst1.merge(src);
1903    EXPECT_TRUE(src.empty());
1904    ASSERT_THAT(dst1, SizeIs(2));
1905    EXPECT_EQ(*dst1.begin(), MovableOnlyInstance(1));
1906    EXPECT_EQ(*std::next(dst1.begin()), MovableOnlyInstance(2));
1907    dst2.merge(dst1);
1908    EXPECT_TRUE(dst1.empty());
1909    ASSERT_THAT(dst2, SizeIs(2));
1910    EXPECT_EQ(*dst2.begin(), MovableOnlyInstance(1));
1911    EXPECT_EQ(*std::next(dst2.begin()), MovableOnlyInstance(2));
1912  }
1913  struct KeyCompareToWeakOrdering {
1914    template <typename T>
1915    absl::weak_ordering operator()(const T &a, const T &b) const {
1916      return a < b ? absl::weak_ordering::less
1917                   : a == b ? absl::weak_ordering::equivalent
1918                            : absl::weak_ordering::greater;
1919    }
1920  };
1921  struct KeyCompareToStrongOrdering {
1922    template <typename T>
1923    absl::strong_ordering operator()(const T &a, const T &b) const {
1924      return a < b ? absl::strong_ordering::less
1925                   : a == b ? absl::strong_ordering::equal
1926                            : absl::strong_ordering::greater;
1927    }
1928  };
1929  TEST(Btree, UserProvidedKeyCompareToComparators) {
1930    absl::btree_set<int, KeyCompareToWeakOrdering> weak_set = {1, 2, 3};
1931    EXPECT_TRUE(weak_set.contains(2));
1932    EXPECT_FALSE(weak_set.contains(4));
1933    absl::btree_set<int, KeyCompareToStrongOrdering> strong_set = {1, 2, 3};
1934    EXPECT_TRUE(strong_set.contains(2));
1935    EXPECT_FALSE(strong_set.contains(4));
1936  }
1937  TEST(Btree, TryEmplaceBasicTest) {
1938    absl::btree_map<int, std::string> m;
1939    m.try_emplace(1, "one");
1940    EXPECT_EQ(1, m.size());
1941    const int key(42);
1942    m.try_emplace(key, 3, 'a');
1943    m.try_emplace(2, std::string("two"));
1944    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
1945    EXPECT_THAT(m, ElementsAreArray(std::vector<std::pair<int, std::string>>{
1946                       {1, "one"}, {2, "two"}, {42, "aaa"}}));
1947  }
1948  TEST(Btree, TryEmplaceWithHintWorks) {
1949    int calls = 0;
1950    auto cmp = [&calls](int x, int y) {
1951      ++calls;
1952      return x < y;
1953    };
1954    using Cmp = decltype(cmp);
1955    absl::btree_map<int, int, CheckedCompareOptedOutCmp<Cmp>> m(cmp);
1956    for (int i = 0; i < 128; ++i) {
1957      m.emplace(i, i);
1958    }
1959    calls = 0;
1960    m.emplace(127, 127);
1961    EXPECT_GE(calls, 4);
1962    calls = 0;
1963    auto it = m.try_emplace(m.begin(), -1, -1);
1964    EXPECT_EQ(129, m.size());
1965    EXPECT_EQ(it, m.begin());
1966    EXPECT_LE(calls, 2);
1967    calls = 0;
1968    std::pair<int, int> pair1024 = {1024, 1024};
1969    it = m.try_emplace(m.end(), pair1024.first, pair1024.second);
1970    EXPECT_EQ(130, m.size());
1971    EXPECT_EQ(it, --m.end());
1972    EXPECT_LE(calls, 2);
1973    calls = 0;
1974    it = m.try_emplace(m.end(), 16, 17);
1975    EXPECT_EQ(130, m.size());
1976    EXPECT_GE(calls, 4);
1977    EXPECT_EQ(it, m.find(16));
1978    calls = 0;
1979    it = m.try_emplace(it, 16, 17);
1980    EXPECT_EQ(130, m.size());
1981    EXPECT_LE(calls, 2);
1982    EXPECT_EQ(it, m.find(16));
1983    m.erase(2);
1984    EXPECT_EQ(129, m.size());
1985    auto hint = m.find(3);
1986    calls = 0;
1987    m.try_emplace(hint, 2, 2);
1988    EXPECT_EQ(130, m.size());
1989    EXPECT_LE(calls, 2);
1990    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
1991  }
1992  TEST(Btree, TryEmplaceWithBadHint) {
1993    absl::btree_map<int, int> m = {{1, 1}, {9, 9}};
1994    auto it = m.try_emplace(m.begin(), 2, 2);
1995    EXPECT_EQ(it, ++m.begin());
1996    EXPECT_THAT(m, ElementsAreArray(
1997                       std::vector<std::pair<int, int>>{{1, 1}, {2, 2}, {9, 9}}));
1998    it = m.try_emplace(++(++m.begin()), 0, 0);
1999    EXPECT_EQ(it, m.begin());
2000    EXPECT_THAT(m, ElementsAreArray(std::vector<std::pair<int, int>>{
2001                       {0, 0}, {1, 1}, {2, 2}, {9, 9}}));
2002  }
2003  TEST(Btree, TryEmplaceMaintainsSortedOrder) {
2004    absl::btree_map<int, std::string> m;
2005    std::pair<int, std::string> pair5 = {5, "five"};
2006    m.try_emplace(10, "ten");
2007    m.try_emplace(pair5.first, pair5.second);
2008    EXPECT_EQ(2, m.size());
2009    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
2010    int int100{100};
2011    m.try_emplace(int100, "hundred");
2012    m.try_emplace(1, "one");
2013    EXPECT_EQ(4, m.size());
2014    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
2015  }
2016  TEST(Btree, TryEmplaceWithHintAndNoValueArgsWorks) {
2017    absl::btree_map<int, int> m;
2018    m.try_emplace(m.end(), 1);
2019    EXPECT_EQ(0, m[1]);
2020  }
2021  TEST(Btree, TryEmplaceWithHintAndMultipleValueArgsWorks) {
2022    absl::btree_map<int, std::string> m;
2023    m.try_emplace(m.end(), 1, 10, 'a');
2024    EXPECT_EQ(std::string(10, 'a'), m[1]);
2025  }
2026  TEST(Btree, MoveAssignmentAllocatorPropagation) {
2027    InstanceTracker tracker;
2028    int64_t bytes1 = 0, bytes2 = 0;
2029    PropagatingCountingAlloc<MovableOnlyInstance> allocator1(&bytes1);
2030    PropagatingCountingAlloc<MovableOnlyInstance> allocator2(&bytes2);
2031    std::less<MovableOnlyInstance> cmp;
2032    {
2033      absl::btree_set<MovableOnlyInstance, std::less<MovableOnlyInstance>,
2034                      PropagatingCountingAlloc<MovableOnlyInstance>>
2035          set1(cmp, allocator1), set2(cmp, allocator2);
2036      for (int i = 0; i < 100; ++i) set1.insert(MovableOnlyInstance(i));
2037      tracker.ResetCopiesMovesSwaps();
2038      set2 = std::move(set1);
2039      EXPECT_EQ(tracker.moves(), 0);
2040    }
2041    {
2042      absl::btree_set<MovableOnlyInstance, std::less<MovableOnlyInstance>,
2043                      CountingAllocator<MovableOnlyInstance>>
2044          set1(cmp, allocator1), set2(cmp, allocator1);
2045      for (int i = 0; i < 100; ++i) set1.insert(MovableOnlyInstance(i));
2046      tracker.ResetCopiesMovesSwaps();
2047      set2 = std::move(set1);
2048      EXPECT_EQ(tracker.moves(), 0);
2049    }
2050    {
2051      absl::btree_set<MovableOnlyInstance, std::less<MovableOnlyInstance>,
2052                      CountingAllocator<MovableOnlyInstance>>
2053          set1(cmp, allocator1), set2(cmp, allocator2);
2054      for (int i = 0; i < 100; ++i) set1.insert(MovableOnlyInstance(i));
2055      tracker.ResetCopiesMovesSwaps();
2056      set2 = std::move(set1);
2057      EXPECT_GE(tracker.moves(), 100);
2058    }
2059  }
2060  TEST(Btree, EmptyTree) {
2061    absl::btree_set<int> s;
2062    EXPECT_TRUE(s.empty());
2063    EXPECT_EQ(s.size(), 0);
2064    EXPECT_GT(s.max_size(), 0);
2065  }
2066  bool IsEven(int k) { return k % 2 == 0; }
2067  TEST(Btree, EraseIf) {
2068    {
2069      absl::btree_set<int> s = {1, 3, 5, 6, 100};
2070      EXPECT_EQ(erase_if(s, [](int k) { return k > 3; }), 3);
2071      EXPECT_THAT(s, ElementsAre(1, 3));
2072    }
2073    {
2074      absl::btree_multiset<int> s = {1, 3, 3, 5, 6, 6, 100};
2075      EXPECT_EQ(erase_if(s, [](int k) { return k <= 3; }), 3);
2076      EXPECT_THAT(s, ElementsAre(5, 6, 6, 100));
2077    }
2078    {
2079      absl::btree_map<int, int> m = {{1, 1}, {3, 3}, {6, 6}, {100, 100}};
2080      EXPECT_EQ(
2081          erase_if(m, [](std::pair<const int, int> kv) { return kv.first > 3; }),
2082          2);
2083      EXPECT_THAT(m, ElementsAre(Pair(1, 1), Pair(3, 3)));
2084    }
2085    {
2086      absl::btree_multimap<int, int> m = {{1, 1}, {3, 3}, {3, 6},
2087                                          {6, 6}, {6, 7}, {100, 6}};
2088      EXPECT_EQ(
2089          erase_if(m,
2090                   [](std::pair<const int, int> kv) { return kv.second == 6; }),
2091          3);
2092      EXPECT_THAT(m, ElementsAre(Pair(1, 1), Pair(3, 3), Pair(6, 7)));
2093    }
2094    {
2095      absl::btree_set<int> s;
2096      for (int i = 0; i < 1000; ++i) s.insert(2 * i);
2097      EXPECT_EQ(erase_if(s, IsEven), 1000);
2098      EXPECT_THAT(s, IsEmpty());
2099    }
2100    {
2101      absl::btree_set<int> s = {1, 3, 5, 6, 100};
2102      EXPECT_EQ(erase_if(s, &IsEven), 2);
2103      EXPECT_THAT(s, ElementsAre(1, 3, 5));
2104    }
2105    {
2106      absl::btree_set<int> s;
2107      for (int i = 0; i < 1000; ++i) s.insert(i);
2108      int pred_calls = 0;
2109      EXPECT_EQ(erase_if(s,
2110                         [&pred_calls](int k) {
2111                           ++pred_calls;
2112                           return k % 2;
2113                         }),
2114                500);
2115      EXPECT_THAT(s, SizeIs(500));
2116      EXPECT_EQ(pred_calls, 1000);
2117    }
2118  }
2119  TEST(Btree, InsertOrAssign) {
2120    absl::btree_map<int, int> m = {{1, 1}, {3, 3}};
2121    using value_type = typename decltype(m)::value_type;
2122    auto ret = m.insert_or_assign(4, 4);
2123    EXPECT_EQ(*ret.first, value_type(4, 4));
2124    EXPECT_TRUE(ret.second);
2125    ret = m.insert_or_assign(3, 100);
2126    EXPECT_EQ(*ret.first, value_type(3, 100));
2127    EXPECT_FALSE(ret.second);
2128    auto hint_ret = m.insert_or_assign(ret.first, 3, 200);
2129    EXPECT_EQ(*hint_ret, value_type(3, 200));
2130    hint_ret = m.insert_or_assign(m.find(1), 0, 1);
2131    EXPECT_EQ(*hint_ret, value_type(0, 1));
2132    hint_ret = m.insert_or_assign(m.end(), -1, 1);
2133    EXPECT_EQ(*hint_ret, value_type(-1, 1));
2134    EXPECT_THAT(m, ElementsAre(Pair(-1, 1), Pair(0, 1), Pair(1, 1), Pair(3, 200),
2135                               Pair(4, 4)));
2136  }
2137  TEST(Btree, InsertOrAssignMovableOnly) {
2138    absl::btree_map<int, MovableOnlyInstance> m;
2139    using value_type = typename decltype(m)::value_type;
2140    auto ret = m.insert_or_assign(4, MovableOnlyInstance(4));
2141    EXPECT_EQ(*ret.first, value_type(4, MovableOnlyInstance(4)));
2142    EXPECT_TRUE(ret.second);
2143    ret = m.insert_or_assign(4, MovableOnlyInstance(100));
2144    EXPECT_EQ(*ret.first, value_type(4, MovableOnlyInstance(100)));
2145    EXPECT_FALSE(ret.second);
2146    auto hint_ret = m.insert_or_assign(ret.first, 3, MovableOnlyInstance(200));
2147    EXPECT_EQ(*hint_ret, value_type(3, MovableOnlyInstance(200)));
2148    EXPECT_EQ(m.size(), 2);
2149  }
2150  TEST(Btree, BitfieldArgument) {
2151    union {
2152      int n : 1;
2153    };
2154    n = 0;
2155    absl::btree_map<int, int> m;
2156    m.erase(n);
2157    m.count(n);
2158    m.find(n);
2159    m.contains(n);
2160    m.equal_range(n);
2161    m.insert_or_assign(n, n);
2162    m.insert_or_assign(m.end(), n, n);
2163    m.try_emplace(n);
2164    m.try_emplace(m.end(), n);
<span onclick='openModal()' class='match'>2165    m.at(n);
2166    m[n];
2167  }
2168  TEST(Btree, SetRangeConstructorAndInsertSupportExplicitConversionComparable) {
2169    const absl::string_view names[] = {"n1", "n2"};
</span>2170    absl::btree_set<std::string> name_set1{std::begin(names), std::end(names)};
2171    EXPECT_THAT(name_set1, ElementsAreArray(names));
2172    absl::btree_set<std::string> name_set2;
2173    name_set2.insert(std::begin(names), std::end(names));
2174    EXPECT_THAT(name_set2, ElementsAreArray(names));
2175  }
2176  struct ConstructorCounted {
2177    explicit ConstructorCounted(int i) : i(i) { ++constructor_calls; }
2178    bool operator==(int other) const { return i == other; }
2179    int i;
2180    static int constructor_calls;
2181  };
2182  int ConstructorCounted::constructor_calls = 0;
2183  struct ConstructorCountedCompare {
2184    bool operator()(int a, const ConstructorCounted &b) const { return a < b.i; }
2185    bool operator()(const ConstructorCounted &a, int b) const { return a.i < b; }
2186    bool operator()(const ConstructorCounted &a,
2187                    const ConstructorCounted &b) const {
2188      return a.i < b.i;
2189    }
2190    using is_transparent = void;
2191  };
2192  TEST(Btree,
2193       SetRangeConstructorAndInsertExplicitConvComparableLimitConstruction) {
2194    const int i[] = {0, 1, 1};
2195    ConstructorCounted::constructor_calls = 0;
2196    absl::btree_set<ConstructorCounted, ConstructorCountedCompare> set{
2197        std::begin(i), std::end(i)};
2198    EXPECT_THAT(set, ElementsAre(0, 1));
2199    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2200    set.insert(std::begin(i), std::end(i));
2201    EXPECT_THAT(set, ElementsAre(0, 1));
2202    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2203  }
2204  TEST(Btree,
2205       SetRangeConstructorAndInsertSupportExplicitConversionNonComparable) {
2206    const int i[] = {0, 1};
2207    absl::btree_set<std::vector<void *>> s1{std::begin(i), std::end(i)};
2208    EXPECT_THAT(s1, ElementsAre(IsEmpty(), ElementsAre(IsNull())));
2209    absl::btree_set<std::vector<void *>> s2;
2210    s2.insert(std::begin(i), std::end(i));
2211    EXPECT_THAT(s2, ElementsAre(IsEmpty(), ElementsAre(IsNull())));
2212  }
2213  #if !defined(__GLIBCXX__) || \
2214      (defined(_GLIBCXX_RELEASE) && _GLIBCXX_RELEASE >= 7)
2215  TEST(Btree, MapRangeConstructorAndInsertSupportExplicitConversionComparable) {
2216    const std::pair<absl::string_view, int> names[] = {{"n1", 1}, {"n2", 2}};
2217    absl::btree_map<std::string, int> name_map1{std::begin(names),
2218                                                std::end(names)};
2219    EXPECT_THAT(name_map1, ElementsAre(Pair("n1", 1), Pair("n2", 2)));
2220    absl::btree_map<std::string, int> name_map2;
2221    name_map2.insert(std::begin(names), std::end(names));
2222    EXPECT_THAT(name_map2, ElementsAre(Pair("n1", 1), Pair("n2", 2)));
2223  }
2224  TEST(Btree,
2225       MapRangeConstructorAndInsertExplicitConvComparableLimitConstruction) {
2226    const std::pair<int, int> i[] = {{0, 1}, {1, 2}, {1, 3}};
2227    ConstructorCounted::constructor_calls = 0;
2228    absl::btree_map<ConstructorCounted, int, ConstructorCountedCompare> map{
2229        std::begin(i), std::end(i)};
2230    EXPECT_THAT(map, ElementsAre(Pair(0, 1), Pair(1, 2)));
2231    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2232    map.insert(std::begin(i), std::end(i));
2233    EXPECT_THAT(map, ElementsAre(Pair(0, 1), Pair(1, 2)));
2234    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2235  }
2236  TEST(Btree,
2237       MapRangeConstructorAndInsertSupportExplicitConversionNonComparable) {
2238    const std::pair<int, int> i[] = {{0, 1}, {1, 2}};
2239    absl::btree_map<std::vector<void *>, int> m1{std::begin(i), std::end(i)};
2240    EXPECT_THAT(m1,
2241                ElementsAre(Pair(IsEmpty(), 1), Pair(ElementsAre(IsNull()), 2)));
2242    absl::btree_map<std::vector<void *>, int> m2;
2243    m2.insert(std::begin(i), std::end(i));
2244    EXPECT_THAT(m2,
2245                ElementsAre(Pair(IsEmpty(), 1), Pair(ElementsAre(IsNull()), 2)));
2246  }
2247  TEST(Btree, HeterogeneousTryEmplace) {
2248    absl::btree_map<std::string, int> m;
2249    std::string s = "key";
2250    absl::string_view sv = s;
2251    m.try_emplace(sv, 1);
2252    EXPECT_EQ(m[s], 1);
2253    m.try_emplace(m.end(), sv, 2);
2254    EXPECT_EQ(m[s], 1);
2255  }
2256  TEST(Btree, HeterogeneousOperatorMapped) {
2257    absl::btree_map<std::string, int> m;
2258    std::string s = "key";
2259    absl::string_view sv = s;
2260    m[sv] = 1;
2261    EXPECT_EQ(m[s], 1);
2262    m[sv] = 2;
2263    EXPECT_EQ(m[s], 2);
2264  }
2265  TEST(Btree, HeterogeneousInsertOrAssign) {
2266    absl::btree_map<std::string, int> m;
2267    std::string s = "key";
2268    absl::string_view sv = s;
2269    m.insert_or_assign(sv, 1);
2270    EXPECT_EQ(m[s], 1);
2271    m.insert_or_assign(m.end(), sv, 2);
2272    EXPECT_EQ(m[s], 2);
2273  }
2274  #endif
2275  #if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606
2276  TEST(Btree, NodeHandleMutableKeyAccess) {
2277    {
2278      absl::btree_map<std::string, std::string> map;
2279      map["key1"] = "mapped";
2280      auto nh = map.extract(map.begin());
2281      nh.key().resize(3);
2282      map.insert(std::move(nh));
2283      EXPECT_THAT(map, ElementsAre(Pair("key", "mapped")));
2284    }
2285    {
2286      absl::btree_multimap<std::string, std::string> map;
2287      map.emplace("key1", "mapped");
2288      auto nh = map.extract(map.begin());
2289      nh.key().resize(3);
2290      map.insert(std::move(nh));
2291      EXPECT_THAT(map, ElementsAre(Pair("key", "mapped")));
2292    }
2293  }
2294  #endif
2295  struct MultiKey {
2296    int i1;
2297    int i2;
2298  };
2299  bool operator==(const MultiKey a, const MultiKey b) {
2300    return a.i1 == b.i1 && a.i2 == b.i2;
2301  }
2302  struct MultiKeyComp {
2303    using is_transparent = void;
2304    bool operator()(const MultiKey a, const MultiKey b) const {
2305      if (a.i1 != b.i1) return a.i1 < b.i1;
2306      return a.i2 < b.i2;
2307    }
2308    bool operator()(const int a, const MultiKey b) const { return a < b.i1; }
2309    bool operator()(const MultiKey a, const int b) const { return a.i1 < b; }
2310  };
2311  struct MultiKeyThreeWayComp {
2312    using is_transparent = void;
2313    absl::weak_ordering operator()(const MultiKey a, const MultiKey b) const {
2314      if (a.i1 < b.i1) return absl::weak_ordering::less;
2315      if (a.i1 > b.i1) return absl::weak_ordering::greater;
2316      if (a.i2 < b.i2) return absl::weak_ordering::less;
2317      if (a.i2 > b.i2) return absl::weak_ordering::greater;
2318      return absl::weak_ordering::equivalent;
2319    }
2320    absl::weak_ordering operator()(const int a, const MultiKey b) const {
2321      if (a < b.i1) return absl::weak_ordering::less;
2322      if (a > b.i1) return absl::weak_ordering::greater;
2323      return absl::weak_ordering::equivalent;
2324    }
2325    absl::weak_ordering operator()(const MultiKey a, const int b) const {
2326      if (a.i1 < b) return absl::weak_ordering::less;
2327      if (a.i1 > b) return absl::weak_ordering::greater;
2328      return absl::weak_ordering::equivalent;
2329    }
2330  };
2331  template <typename Compare>
2332  class BtreeMultiKeyTest : public ::testing::Test {};
2333  using MultiKeyComps = ::testing::Types<MultiKeyComp, MultiKeyThreeWayComp>;
2334  TYPED_TEST_SUITE(BtreeMultiKeyTest, MultiKeyComps);
2335  TYPED_TEST(BtreeMultiKeyTest, EqualRange) {
2336    absl::btree_set<MultiKey, TypeParam> set;
2337    for (int i = 0; i < 100; ++i) {
2338      for (int j = 0; j < 100; ++j) {
2339        set.insert({i, j});
2340      }
2341    }
2342    for (int i = 0; i < 100; ++i) {
2343      auto equal_range = set.equal_range(i);
2344      EXPECT_EQ(equal_range.first->i1, i);
2345      EXPECT_EQ(equal_range.first->i2, 0) << i;
2346      EXPECT_EQ(std::distance(equal_range.first, equal_range.second), 100) << i;
2347    }
2348  }
2349  TYPED_TEST(BtreeMultiKeyTest, Extract) {
2350    absl::btree_set<MultiKey, TypeParam> set;
2351    for (int i = 0; i < 100; ++i) {
2352      for (int j = 0; j < 100; ++j) {
2353        set.insert({i, j});
2354      }
2355    }
2356    for (int i = 0; i < 100; ++i) {
2357      auto node_handle = set.extract(i);
2358      EXPECT_EQ(node_handle.value().i1, i);
2359      EXPECT_EQ(node_handle.value().i2, 0) << i;
2360    }
2361    for (int i = 0; i < 100; ++i) {
2362      auto node_handle = set.extract(i);
2363      EXPECT_EQ(node_handle.value().i1, i);
2364      EXPECT_EQ(node_handle.value().i2, 1) << i;
2365    }
2366  }
2367  TYPED_TEST(BtreeMultiKeyTest, Erase) {
2368    absl::btree_set<MultiKey, TypeParam> set = {
2369        {1, 1}, {2, 1}, {2, 2}, {3, 1}};
2370    EXPECT_EQ(set.erase(2), 2);
2371    EXPECT_THAT(set, ElementsAre(MultiKey{1, 1}, MultiKey{3, 1}));
2372  }
2373  TYPED_TEST(BtreeMultiKeyTest, Count) {
2374    const absl::btree_set<MultiKey, TypeParam> set = {
2375        {1, 1}, {2, 1}, {2, 2}, {3, 1}};
2376    EXPECT_EQ(set.count(2), 2);
2377  }
2378  TEST(Btree, AllocConstructor) {
2379    using Alloc = CountingAllocator<int>;
2380    using Set = absl::btree_set<int, std::less<int>, Alloc>;
2381    int64_t bytes_used = 0;
2382    Alloc alloc(&bytes_used);
2383    Set set(alloc);
2384    set.insert({1, 2, 3});
2385    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2386    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2387  }
2388  TEST(Btree, AllocInitializerListConstructor) {
2389    using Alloc = CountingAllocator<int>;
2390    using Set = absl::btree_set<int, std::less<int>, Alloc>;
2391    int64_t bytes_used = 0;
2392    Alloc alloc(&bytes_used);
2393    Set set({1, 2, 3}, alloc);
2394    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2395    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2396  }
2397  TEST(Btree, AllocRangeConstructor) {
2398    using Alloc = CountingAllocator<int>;
2399    using Set = absl::btree_set<int, std::less<int>, Alloc>;
2400    int64_t bytes_used = 0;
2401    Alloc alloc(&bytes_used);
2402    std::vector<int> v = {1, 2, 3};
2403    Set set(v.begin(), v.end(), alloc);
2404    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2405    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2406  }
2407  TEST(Btree, AllocCopyConstructor) {
2408    using Alloc = CountingAllocator<int>;
2409    using Set = absl::btree_set<int, std::less<int>, Alloc>;
2410    int64_t bytes_used1 = 0;
2411    Alloc alloc1(&bytes_used1);
2412    Set set1(alloc1);
2413    set1.insert({1, 2, 3});
2414    int64_t bytes_used2 = 0;
2415    Alloc alloc2(&bytes_used2);
2416    Set set2(set1, alloc2);
2417    EXPECT_THAT(set1, ElementsAre(1, 2, 3));
2418    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2419    EXPECT_GT(bytes_used1, set1.size() * sizeof(int));
2420    EXPECT_EQ(bytes_used1, bytes_used2);
2421  }
2422  TEST(Btree, AllocMoveConstructor_SameAlloc) {
2423    using Alloc = CountingAllocator<int>;
2424    using Set = absl::btree_set<int, std::less<int>, Alloc>;
2425    int64_t bytes_used = 0;
2426    Alloc alloc(&bytes_used);
2427    Set set1(alloc);
2428    set1.insert({1, 2, 3});
2429    const int64_t original_bytes_used = bytes_used;
2430    EXPECT_GT(original_bytes_used, set1.size() * sizeof(int));
2431    Set set2(std::move(set1), alloc);
2432    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2433    EXPECT_EQ(bytes_used, original_bytes_used);
2434  }
2435  TEST(Btree, AllocMoveConstructor_DifferentAlloc) {
2436    using Alloc = CountingAllocator<int>;
2437    using Set = absl::btree_set<int, std::less<int>, Alloc>;
2438    int64_t bytes_used1 = 0;
2439    Alloc alloc1(&bytes_used1);
2440    Set set1(alloc1);
2441    set1.insert({1, 2, 3});
2442    const int64_t original_bytes_used = bytes_used1;
2443    EXPECT_GT(original_bytes_used, set1.size() * sizeof(int));
2444    int64_t bytes_used2 = 0;
2445    Alloc alloc2(&bytes_used2);
2446    Set set2(std::move(set1), alloc2);
2447    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2448    EXPECT_EQ(bytes_used1, original_bytes_used);
2449    EXPECT_EQ(bytes_used2, original_bytes_used);
2450  }
2451  bool IntCmp(const int a, const int b) { return a < b; }
2452  TEST(Btree, SupportsFunctionPtrComparator) {
2453    absl::btree_set<int, decltype(IntCmp) *> set(IntCmp);
2454    set.insert({1, 2, 3});
2455    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2456    EXPECT_TRUE(set.key_comp()(1, 2));
2457    EXPECT_TRUE(set.value_comp()(1, 2));
2458    absl::btree_map<int, int, decltype(IntCmp) *> map(&IntCmp);
2459    map[1] = 1;
2460    EXPECT_THAT(map, ElementsAre(Pair(1, 1)));
2461    EXPECT_TRUE(map.key_comp()(1, 2));
2462    EXPECT_TRUE(map.value_comp()(std::make_pair(1, 1), std::make_pair(2, 2)));
2463  }
2464  template <typename Compare>
2465  struct TransparentPassThroughComp {
2466    using is_transparent = void;
2467    template <typename T, typename U>
2468    bool operator()(const T &lhs, const U &rhs) const {
2469      return Compare()(lhs, rhs);
2470    }
2471  };
2472  TEST(Btree,
2473       SupportsTransparentComparatorThatDoesNotImplementAllVisibleOperators) {
2474    absl::btree_set<MultiKey, TransparentPassThroughComp<MultiKeyComp>> set;
2475    set.insert(MultiKey{1, 2});
2476    EXPECT_TRUE(set.contains(1));
2477  }
2478  TEST(Btree, ConstructImplicitlyWithUnadaptedComparator) {
2479    absl::btree_set<MultiKey, MultiKeyComp> set = {{}, MultiKeyComp{}};
2480  }
2481  TEST(Btree, InvalidComparatorsCaught) {
2482    if (!IsAssertEnabled()) GTEST_SKIP() << "Assertions not enabled.";
2483    {
2484      struct ZeroAlwaysLessCmp {
2485        bool operator()(int lhs, int rhs) const {
2486          if (lhs == 0) return true;
2487          return lhs < rhs;
2488        }
2489      };
2490      absl::btree_set<int, ZeroAlwaysLessCmp> set;
2491      EXPECT_DEATH(set.insert({0, 1, 2}), "is_self_equivalent");
2492    }
2493    {
2494      struct ThreeWayAlwaysLessCmp {
2495        absl::weak_ordering operator()(int, int) const {
2496          return absl::weak_ordering::less;
2497        }
2498      };
2499      absl::btree_set<int, ThreeWayAlwaysLessCmp> set;
2500      EXPECT_DEATH(set.insert({0, 1, 2}), "is_self_equivalent");
2501    }
2502    {
2503      struct SumGreaterZeroCmp {
2504        bool operator()(int lhs, int rhs) const {
2505          if (lhs == rhs) return false;
2506          return lhs + rhs > 0;
2507        }
2508      };
2509      absl::btree_set<int, SumGreaterZeroCmp> set;
2510      EXPECT_DEATH(set.insert({0, 1, 2}),
2511                   R"regex(\!lhs_comp_rhs \|\| !comp\(\)\(rhs, lhs\))regex");
2512    }
2513    {
2514      struct ThreeWaySumGreaterZeroCmp {
2515        absl::weak_ordering operator()(int lhs, int rhs) const {
2516          if (lhs == rhs) return absl::weak_ordering::equivalent;
2517          if (lhs + rhs > 0) return absl::weak_ordering::less;
2518          if (lhs + rhs == 0) return absl::weak_ordering::equivalent;
2519          return absl::weak_ordering::greater;
2520        }
2521      };
2522      absl::btree_set<int, ThreeWaySumGreaterZeroCmp> set;
2523      EXPECT_DEATH(set.insert({0, 1, 2}), "lhs_comp_rhs < 0 -> rhs_comp_lhs > 0");
2524    }
2525    struct ClockTime {
2526      absl::optional<int> hour;
2527      int minute;
2528    };
2529    ClockTime a = {absl::nullopt, 1};
2530    ClockTime b = {2, 5};
2531    ClockTime c = {6, 0};
2532    {
2533      struct NonTransitiveTimeCmp {
2534        bool operator()(ClockTime lhs, ClockTime rhs) const {
2535          if (lhs.hour.has_value() && rhs.hour.has_value() &&
2536              *lhs.hour != *rhs.hour) {
2537            return *lhs.hour < *rhs.hour;
2538          }
2539          return lhs.minute < rhs.minute;
2540        }
2541      };
2542      NonTransitiveTimeCmp cmp;
2543      ASSERT_TRUE(cmp(a, b) && cmp(b, c) && !cmp(a, c));
2544      absl::btree_set<ClockTime, NonTransitiveTimeCmp> set;
2545      EXPECT_DEATH(set.insert({a, b, c}), "is_ordered_correctly");
2546      absl::btree_multiset<ClockTime, NonTransitiveTimeCmp> mset;
2547      EXPECT_DEATH(mset.insert({a, a, b, b, c, c}), "is_ordered_correctly");
2548    }
2549    {
2550      struct ThreeWayNonTransitiveTimeCmp {
2551        absl::weak_ordering operator()(ClockTime lhs, ClockTime rhs) const {
2552          if (lhs.hour.has_value() && rhs.hour.has_value() &&
2553              *lhs.hour != *rhs.hour) {
2554            return *lhs.hour < *rhs.hour ? absl::weak_ordering::less
2555                                         : absl::weak_ordering::greater;
2556          }
2557          return lhs.minute < rhs.minute    ? absl::weak_ordering::less
2558                 : lhs.minute == rhs.minute ? absl::weak_ordering::equivalent
2559                                            : absl::weak_ordering::greater;
2560        }
2561      };
2562      ThreeWayNonTransitiveTimeCmp cmp;
2563      ASSERT_TRUE(cmp(a, b) < 0 && cmp(b, c) < 0 && cmp(a, c) > 0);
2564      absl::btree_set<ClockTime, ThreeWayNonTransitiveTimeCmp> set;
2565      EXPECT_DEATH(set.insert({a, b, c}), "is_ordered_correctly");
2566      absl::btree_multiset<ClockTime, ThreeWayNonTransitiveTimeCmp> mset;
2567      EXPECT_DEATH(mset.insert({a, a, b, b, c, c}), "is_ordered_correctly");
2568    }
2569  }
2570  TEST(Btree, MutatedKeysCaught) {
2571    if (!IsAssertEnabled()) GTEST_SKIP() << "Assertions not enabled.";
2572    struct IntPtrCmp {
2573      bool operator()(int *lhs, int *rhs) const { return *lhs < *rhs; }
2574    };
2575    {
2576      absl::btree_set<int *, IntPtrCmp> set;
2577      int arr[] = {0, 1, 2};
2578      set.insert({&arr[0], &arr[1], &arr[2]});
2579      arr[0] = 100;
2580      EXPECT_DEATH(set.insert(&arr[0]), "is_ordered_correctly");
2581    }
2582    {
2583      absl::btree_multiset<int *, IntPtrCmp> set;
2584      int arr[] = {0, 1, 2};
2585      set.insert({&arr[0], &arr[0], &arr[1], &arr[1], &arr[2], &arr[2]});
2586      arr[0] = 100;
2587      EXPECT_DEATH(set.insert(&arr[0]), "is_ordered_correctly");
2588    }
2589  }
2590  #ifndef _MSC_VER
2591  TEST(Btree, InvalidIteratorUse) {
2592    if (!BtreeGenerationsEnabled())
2593      GTEST_SKIP() << "Generation validation for iterators is disabled.";
2594    constexpr const char *kInvalidMemoryDeathMessage =
2595        "heap-use-after-free|invalidated iterator";
2596    {
2597      absl::btree_set<int> set;
2598      for (int i = 0; i < 10; ++i) set.insert(i);
2599      auto it = set.begin();
2600      set.erase(it++);
2601      EXPECT_DEATH(set.erase(it++), kInvalidMemoryDeathMessage);
2602    }
2603    {
2604      absl::btree_set<int> set;
2605      for (int i = 0; i < 10; ++i) set.insert(i);
2606      auto it = set.insert(20).first;
2607      set.insert(30);
2608      EXPECT_DEATH(*it, kInvalidMemoryDeathMessage);
2609    }
2610    {
2611      absl::btree_set<int> set;
2612      for (int i = 0; i < 10000; ++i) set.insert(i);
2613      auto it = set.find(5000);
2614      ASSERT_NE(it, set.end());
2615      set.erase(1);
2616      EXPECT_DEATH(*it, kInvalidMemoryDeathMessage);
2617    }
2618    {
2619      absl::btree_set<int> set;
2620      for (int i = 0; i < 10; ++i) set.insert(i);
2621      auto it = set.insert(20).first;
2622      set.insert(30);
2623      EXPECT_DEATH(void(it == set.begin()), kInvalidMemoryDeathMessage);
2624      EXPECT_DEATH(void(set.begin() == it), kInvalidMemoryDeathMessage);
2625    }
2626  }
2627  #endif
2628  class OnlyConstructibleByAllocator {
2629    explicit OnlyConstructibleByAllocator(int i) : i_(i) {}
2630   public:
2631    OnlyConstructibleByAllocator(const OnlyConstructibleByAllocator &other)
2632        : i_(other.i_) {}
2633    OnlyConstructibleByAllocator &operator=(
2634        const OnlyConstructibleByAllocator &other) {
2635      i_ = other.i_;
2636      return *this;
2637    }
2638    int Get() const { return i_; }
2639    bool operator==(int i) const { return i_ == i; }
2640   private:
2641    template <typename T>
2642    friend class OnlyConstructibleAllocator;
2643    int i_;
2644  };
2645  template <typename T = OnlyConstructibleByAllocator>
2646  class OnlyConstructibleAllocator : public std::allocator<T> {
2647   public:
2648    OnlyConstructibleAllocator() = default;
2649    template <class U>
2650    explicit OnlyConstructibleAllocator(const OnlyConstructibleAllocator<U> &) {}
2651    void construct(OnlyConstructibleByAllocator *p, int i) {
2652      new (p) OnlyConstructibleByAllocator(i);
2653    }
2654    template <typename Pair>
2655    void construct(Pair *p, const int i) {
2656      OnlyConstructibleByAllocator only(i);
2657      new (p) Pair(std::move(only), i);
2658    }
2659    template <class U>
2660    struct rebind {
2661      using other = OnlyConstructibleAllocator<U>;
2662    };
2663  };
2664  struct OnlyConstructibleByAllocatorComp {
2665    using is_transparent = void;
2666    bool operator()(OnlyConstructibleByAllocator a,
2667                    OnlyConstructibleByAllocator b) const {
2668      return a.Get() < b.Get();
2669    }
2670    bool operator()(int a, OnlyConstructibleByAllocator b) const {
2671      return a < b.Get();
2672    }
2673    bool operator()(OnlyConstructibleByAllocator a, int b) const {
2674      return a.Get() < b;
2675    }
2676  };
2677  TEST(Btree, OnlyConstructibleByAllocatorType) {
2678    const std::array<int, 2> arr = {3, 4};
2679    {
2680      absl::btree_set<OnlyConstructibleByAllocator,
2681                      OnlyConstructibleByAllocatorComp,
2682                      OnlyConstructibleAllocator<>>
2683          set;
2684      set.emplace(1);
2685      set.emplace_hint(set.end(), 2);
2686      set.insert(arr.begin(), arr.end());
2687      EXPECT_THAT(set, ElementsAre(1, 2, 3, 4));
2688    }
2689    {
2690      absl::btree_multiset<OnlyConstructibleByAllocator,
2691                           OnlyConstructibleByAllocatorComp,
2692                           OnlyConstructibleAllocator<>>
2693          set;
2694      set.emplace(1);
2695      set.emplace_hint(set.end(), 2);
2696      EXPECT_THAT(set, ElementsAre(1, 2));
2697    }
2698    {
2699      absl::btree_map<OnlyConstructibleByAllocator, int,
2700                      OnlyConstructibleByAllocatorComp,
2701                      OnlyConstructibleAllocator<>>
2702          map;
2703      map.emplace(1);
2704      map.emplace_hint(map.end(), 2);
2705      map.insert(arr.begin(), arr.end());
2706      EXPECT_THAT(map,
2707                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2708    }
2709    {
2710      absl::btree_multimap<OnlyConstructibleByAllocator, int,
2711                           OnlyConstructibleByAllocatorComp,
2712                           OnlyConstructibleAllocator<>>
2713          map;
2714      map.emplace(1);
2715      map.emplace_hint(map.end(), 2);
2716      EXPECT_THAT(map, ElementsAre(Pair(1, 1), Pair(2, 2)));
2717    }
2718  }
2719  class NotAssignable {
2720   public:
2721    explicit NotAssignable(int i) : i_(i) {}
2722    NotAssignable(const NotAssignable &other) : i_(other.i_) {}
2723    NotAssignable &operator=(NotAssignable &&other) = delete;
2724    int Get() const { return i_; }
2725    bool operator==(int i) const { return i_ == i; }
2726    friend bool operator<(NotAssignable a, NotAssignable b) {
2727      return a.i_ < b.i_;
2728    }
2729   private:
2730    int i_;
2731  };
2732  TEST(Btree, NotAssignableType) {
2733    {
2734      absl::btree_set<NotAssignable> set;
2735      set.emplace(1);
2736      set.emplace_hint(set.end(), 2);
2737      set.insert(NotAssignable(3));
2738      set.insert(set.end(), NotAssignable(4));
2739      EXPECT_THAT(set, ElementsAre(1, 2, 3, 4));
2740      set.erase(set.begin());
2741      EXPECT_THAT(set, ElementsAre(2, 3, 4));
2742    }
2743    {
2744      absl::btree_multiset<NotAssignable> set;
2745      set.emplace(1);
2746      set.emplace_hint(set.end(), 2);
2747      set.insert(NotAssignable(2));
2748      set.insert(set.end(), NotAssignable(3));
2749      EXPECT_THAT(set, ElementsAre(1, 2, 2, 3));
2750      set.erase(set.begin());
2751      EXPECT_THAT(set, ElementsAre(2, 2, 3));
2752    }
2753    {
2754      absl::btree_map<NotAssignable, int> map;
2755      map.emplace(NotAssignable(1), 1);
2756      map.emplace_hint(map.end(), NotAssignable(2), 2);
2757      map.insert({NotAssignable(3), 3});
2758      map.insert(map.end(), {NotAssignable(4), 4});
2759      EXPECT_THAT(map,
2760                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2761      map.erase(map.begin());
2762      EXPECT_THAT(map, ElementsAre(Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2763    }
2764    {
2765      absl::btree_multimap<NotAssignable, int> map;
2766      map.emplace(NotAssignable(1), 1);
2767      map.emplace_hint(map.end(), NotAssignable(2), 2);
2768      map.insert({NotAssignable(2), 3});
2769      map.insert(map.end(), {NotAssignable(3), 3});
2770      EXPECT_THAT(map,
2771                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(2, 3), Pair(3, 3)));
2772      map.erase(map.begin());
2773      EXPECT_THAT(map, ElementsAre(Pair(2, 2), Pair(2, 3), Pair(3, 3)));
2774    }
2775  }
2776  struct ArenaLike {
2777    void* recycled = nullptr;
2778    size_t recycled_size = 0;
2779  };
2780  template <typename T>
2781  class ArenaLikeAllocator : public std::allocator<T> {
2782   public:
2783    template <typename U>
2784    struct rebind {
2785      using other = ArenaLikeAllocator<U>;
2786    };
2787    explicit ArenaLikeAllocator(ArenaLike* arena) noexcept : arena_(arena) {}
2788    ~ArenaLikeAllocator() {
2789      if (arena_->recycled != nullptr) {
2790        delete [] static_cast<T*>(arena_->recycled);
2791        arena_->recycled = nullptr;
2792      }
2793    }
2794    template<typename U>
2795    explicit ArenaLikeAllocator(const ArenaLikeAllocator<U>& other) noexcept
2796        : arena_(other.arena_) {}
2797    T* allocate(size_t num_objects, const void* = nullptr) {
2798      size_t size = num_objects * sizeof(T);
2799      if (arena_->recycled != nullptr && arena_->recycled_size == size) {
2800        T* result = static_cast<T*>(arena_->recycled);
2801        arena_->recycled = nullptr;
2802        return result;
2803      }
2804      return new T[num_objects];
2805    }
2806    void deallocate(T* p, size_t num_objects) {
2807      size_t size = num_objects * sizeof(T);
2808      memset(p, 0xde, size);
2809      if (arena_->recycled == nullptr) {
2810        arena_->recycled = p;
2811        arena_->recycled_size = size;
2812      } else {
2813        delete [] p;
2814      }
2815    }
2816    ArenaLike* arena_;
2817  };
2818  TEST(Btree, ReusePoisonMemory) {
2819    using Alloc = ArenaLikeAllocator<int64_t>;
2820    using Set = absl::btree_set<int64_t, std::less<int64_t>, Alloc>;
2821    ArenaLike arena;
2822    Alloc alloc(&arena);
2823    Set set(alloc);
2824    set.insert(0);
2825    set.erase(0);
2826    set.insert(0);
2827  }
2828  TEST(Btree, IteratorSubtraction) {
2829    absl::BitGen bitgen;
2830    std::vector<int> vec;
2831    for (int i = 0; i < 1000000; ++i) vec.push_back(i);
2832    absl::c_shuffle(vec, bitgen);
2833    absl::btree_set<int> set;
2834    for (int i : vec) set.insert(i);
2835    for (int i = 0; i < 1000; ++i) {
2836      size_t begin = absl::Uniform(bitgen, 0u, set.size());
2837      size_t end = absl::Uniform(bitgen, begin, set.size());
2838      ASSERT_EQ(end - begin, set.find(end) - set.find(begin))
2839          << begin << " " << end;
2840    }
2841  }
2842  TEST(Btree, DereferencingEndIterator) {
2843    if (!IsAssertEnabled()) GTEST_SKIP() << "Assertions not enabled.";
2844    absl::btree_set<int> set;
2845    for (int i = 0; i < 1000; ++i) set.insert(i);
2846    EXPECT_DEATH(*set.end(), R"regex(Dereferencing end\(\) iterator)regex");
2847  }
2848  TEST(Btree, InvalidIteratorComparison) {
2849    if (!IsAssertEnabled()) GTEST_SKIP() << "Assertions not enabled.";
2850    absl::btree_set<int> set1, set2;
2851    for (int i = 0; i < 1000; ++i) {
2852      set1.insert(i);
2853      set2.insert(i);
2854    }
2855    constexpr const char *kValueInitDeathMessage =
2856        "Comparing default-constructed iterator with .*non-default-constructed "
2857        "iterator";
2858    typename absl::btree_set<int>::iterator iter1, iter2;
2859    EXPECT_EQ(iter1, iter2);
2860    EXPECT_DEATH(void(set1.begin() == iter1), kValueInitDeathMessage);
2861    EXPECT_DEATH(void(iter1 == set1.begin()), kValueInitDeathMessage);
2862    constexpr const char *kDifferentContainerDeathMessage =
2863        "Comparing iterators from different containers";
2864    iter1 = set1.begin();
2865    iter2 = set2.begin();
2866    EXPECT_DEATH(void(iter1 == iter2), kDifferentContainerDeathMessage);
2867    EXPECT_DEATH(void(iter2 == iter1), kDifferentContainerDeathMessage);
2868  }
2869  TEST(Btree, InvalidPointerUse) {
2870    if (!kAsan)
2871      GTEST_SKIP() << "We only detect invalid pointer use in ASan mode.";
2872    absl::btree_set<int> set;
2873    set.insert(0);
2874    const int *ptr = &*set.begin();
2875    set.insert(1);
2876    EXPECT_DEATH(std::cout << *ptr, "heap-use-after-free");
2877    size_t slots_per_node = BtreeNodePeer::GetNumSlotsPerNode<decltype(set)>();
2878    for (int i = 2; i < slots_per_node - 1; ++i) set.insert(i);
2879    ptr = &*set.begin();
2880    set.insert(static_cast<int>(slots_per_node));
2881    EXPECT_DEATH(std::cout << *ptr, "heap-use-after-free");
2882  }
2883  template<typename Set>
2884  void TestBasicFunctionality(Set set) {
2885    using value_type = typename Set::value_type;
2886    for (int i = 0; i < 100; ++i) { set.insert(value_type(i)); }
2887    for (int i = 50; i < 100; ++i) { set.erase(value_type(i)); }
2888    auto it = set.begin();
2889    for (int i = 0; i < 50; ++i, ++it) {
2890      ASSERT_EQ(set.find(value_type(i)), it) << i;
2891    }
2892  }
2893  template<size_t align>
2894  struct alignas(align) OveralignedKey {
2895    explicit OveralignedKey(int i) : key(i) {}
2896    bool operator<(const OveralignedKey &other) const { return key < other.key; }
2897    int key = 0;
2898  };
2899  TEST(Btree, OveralignedKey) {
2900    TestBasicFunctionality(
2901        SizedBtreeSet<OveralignedKey<16>, &bsol;*TargetValuesPerNode=*/8>());
2902    TestBasicFunctionality(
2903        SizedBtreeSet<OveralignedKey<16>, &bsol;*TargetValuesPerNode=*/9>());
2904  }
2905  TEST(Btree, FieldTypeEqualsSlotType) {
2906    using set_type = absl::btree_set<uint8_t>;
2907    static_assert(BtreeNodePeer::FieldTypeEqualsSlotType<set_type>(), "");
2908    TestBasicFunctionality(set_type());
2909  }
2910  }  
2911  }  
2912  ABSL_NAMESPACE_END
2913  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flat_hash_map_test.cc</h3>
            <pre><code>1  #include "absl/container/flat_hash_map.h"
2  #include <memory>
3  #include "absl/container/internal/hash_generator_testing.h"
4  #include "absl/container/internal/unordered_map_constructor_test.h"
5  #include "absl/container/internal/unordered_map_lookup_test.h"
6  #include "absl/container/internal/unordered_map_members_test.h"
7  #include "absl/container/internal/unordered_map_modifiers_test.h"
8  #include "absl/log/check.h"
9  #include "absl/types/any.h"
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace container_internal {
13  namespace {
14  using ::absl::container_internal::hash_internal::Enum;
15  using ::absl::container_internal::hash_internal::EnumClass;
16  using ::testing::_;
17  using ::testing::IsEmpty;
18  using ::testing::Pair;
19  using ::testing::UnorderedElementsAre;
20  struct BeforeMain {
21    BeforeMain() {
22      absl::flat_hash_map<int, int> x;
23      x.insert({1, 1});
24      CHECK(x.find(0) == x.end()) << "x should not contain 0";
25      auto it = x.find(1);
26      CHECK(it != x.end()) << "x should contain 1";
27      CHECK(it->second) << "1 should map to 1";
28    }
29  };
30  const BeforeMain before_main;
31  template <class K, class V>
32  using Map = flat_hash_map<K, V, StatefulTestingHash, StatefulTestingEqual,
33                            Alloc<std::pair<const K, V>>>;
34  static_assert(!std::is_standard_layout<NonStandardLayout>(), "");
35  using MapTypes =
36      ::testing::Types<Map<int, int>, Map<std::string, int>,
37                       Map<Enum, std::string>, Map<EnumClass, int>,
38                       Map<int, NonStandardLayout>, Map<NonStandardLayout, int>>;
39  INSTANTIATE_TYPED_TEST_SUITE_P(FlatHashMap, ConstructorTest, MapTypes);
40  INSTANTIATE_TYPED_TEST_SUITE_P(FlatHashMap, LookupTest, MapTypes);
41  INSTANTIATE_TYPED_TEST_SUITE_P(FlatHashMap, MembersTest, MapTypes);
42  INSTANTIATE_TYPED_TEST_SUITE_P(FlatHashMap, ModifiersTest, MapTypes);
43  using UniquePtrMapTypes = ::testing::Types<Map<int, std::unique_ptr<int>>>;
44  INSTANTIATE_TYPED_TEST_SUITE_P(FlatHashMap, UniquePtrModifiersTest,
45                                 UniquePtrMapTypes);
46  TEST(FlatHashMap, StandardLayout) {
47    struct Int {
48      explicit Int(size_t value) : value(value) {}
49      Int() : value(0) { ADD_FAILURE(); }
50      Int(const Int& other) : value(other.value) { ADD_FAILURE(); }
51      Int(Int&&) = default;
52      bool operator==(const Int& other) const { return value == other.value; }
53      size_t value;
54    };
55    static_assert(std::is_standard_layout<Int>(), "");
56    struct Hash {
57      size_t operator()(const Int& obj) const { return obj.value; }
58    };
59    {
60      flat_hash_map<Int, Int, Hash> m;
61      m.try_emplace(Int(1), Int(2));
62      m.try_emplace(Int(3), Int(4));
63      m.erase(Int(1));
64      m.rehash(2 * m.bucket_count());
65    }
66    {
67      flat_hash_map<Int, Int, Hash> m;
68      m.try_emplace(Int(1), Int(2));
69      m.try_emplace(Int(3), Int(4));
70      m.erase(Int(1));
71      m.clear();
72    }
73  }
74  struct balast {};
75  TEST(FlatHashMap, IteratesMsan) {
76    std::vector<absl::flat_hash_map<int, balast>> garbage;
77    for (int i = 0; i < 100; ++i) {
78      absl::flat_hash_map<int, balast> t;
79      for (int j = 0; j < 100; ++j) {
80        t[j];
81        for (const auto& p : t) EXPECT_THAT(p, Pair(_, _));
82      }
83      garbage.push_back(std::move(t));
84    }
85  }
86  struct LazyInt {
87    explicit LazyInt(size_t value, int* tracker)
88        : value(value), tracker(tracker) {}
89    explicit operator size_t() const {
90      ++*tracker;
91      return value;
92    }
93    size_t value;
94    int* tracker;
95  };
96  struct Hash {
97    using is_transparent = void;
98    int* tracker;
99    size_t operator()(size_t obj) const {
100      ++*tracker;
101      return obj;
102    }
103    size_t operator()(const LazyInt& obj) const {
104      ++*tracker;
105      return obj.value;
106    }
107  };
108  struct Eq {
109    using is_transparent = void;
110    bool operator()(size_t lhs, size_t rhs) const {
111      return lhs == rhs;
112    }
113    bool operator()(size_t lhs, const LazyInt& rhs) const {
114      return lhs == rhs.value;
115    }
116  };
117  TEST(FlatHashMap, LazyKeyPattern) {
118    int conversions = 0;
119    int hashes = 0;
120    flat_hash_map<size_t, size_t, Hash, Eq> m(0, Hash{&hashes});
121    m.reserve(3);
122    m[LazyInt(1, &conversions)] = 1;
123    EXPECT_THAT(m, UnorderedElementsAre(Pair(1, 1)));
124    EXPECT_EQ(conversions, 1);
125  #ifdef NDEBUG
126    EXPECT_EQ(hashes, 1);
127  #endif
128    m[LazyInt(1, &conversions)] = 2;
129    EXPECT_THAT(m, UnorderedElementsAre(Pair(1, 2)));
130    EXPECT_EQ(conversions, 1);
131  #ifdef NDEBUG
132    EXPECT_EQ(hashes, 2);
133  #endif
134    m.try_emplace(LazyInt(2, &conversions), 3);
135    EXPECT_THAT(m, UnorderedElementsAre(Pair(1, 2), Pair(2, 3)));
136    EXPECT_EQ(conversions, 2);
137  #ifdef NDEBUG
138    EXPECT_EQ(hashes, 3);
139  #endif
140    m.try_emplace(LazyInt(2, &conversions), 4);
141    EXPECT_THAT(m, UnorderedElementsAre(Pair(1, 2), Pair(2, 3)));
142    EXPECT_EQ(conversions, 2);
143  #ifdef NDEBUG
144    EXPECT_EQ(hashes, 4);
145  #endif
146  }
147  TEST(FlatHashMap, BitfieldArgument) {
148    union {
149      int n : 1;
150    };
151    n = 0;
152    flat_hash_map<int, int> m;
153    m.erase(n);
154    m.count(n);
155    m.prefetch(n);
156    m.find(n);
157    m.contains(n);
158    m.equal_range(n);
159    m.insert_or_assign(n, n);
160    m.insert_or_assign(m.end(), n, n);
161    m.try_emplace(n);
162    m.try_emplace(m.end(), n);
<span onclick='openModal()' class='match'>163    m.at(n);
164    m[n];
165  }
166  TEST(FlatHashMap, MergeExtractInsert) {
167    absl::flat_hash_map<int, int> m = {{1, 7}, {2, 9}};
</span>168    auto node = m.extract(1);
169    EXPECT_TRUE(node);
170    EXPECT_EQ(node.key(), 1);
171    EXPECT_EQ(node.mapped(), 7);
172    EXPECT_THAT(m, UnorderedElementsAre(Pair(2, 9)));
173    node.mapped() = 17;
174    m.insert(std::move(node));
175    EXPECT_THAT(m, UnorderedElementsAre(Pair(1, 17), Pair(2, 9)));
176  }
177  bool FirstIsEven(std::pair<const int, int> p) { return p.first % 2 == 0; }
178  TEST(FlatHashMap, EraseIf) {
179    {
180      flat_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
181      EXPECT_EQ(erase_if(s, [](std::pair<const int, int>) { return true; }), 5);
182      EXPECT_THAT(s, IsEmpty());
183    }
184    {
185      flat_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
186      EXPECT_EQ(erase_if(s, [](std::pair<const int, int>) { return false; }), 0);
187      EXPECT_THAT(s, UnorderedElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3),
188                                          Pair(4, 4), Pair(5, 5)));
189    }
190    {
191      flat_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
192      EXPECT_EQ(erase_if(s,
193                         [](std::pair<const int, int> kvp) {
194                           return kvp.first % 2 == 1;
195                         }),
196                3);
197      EXPECT_THAT(s, UnorderedElementsAre(Pair(2, 2), Pair(4, 4)));
198    }
199    {
200      flat_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
201      EXPECT_EQ(erase_if(s, FirstIsEven), 2);
202      EXPECT_THAT(s, UnorderedElementsAre(Pair(1, 1), Pair(3, 3), Pair(5, 5)));
203    }
204    {
205      flat_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
206      EXPECT_EQ(erase_if(s, &FirstIsEven), 2);
207      EXPECT_THAT(s, UnorderedElementsAre(Pair(1, 1), Pair(3, 3), Pair(5, 5)));
208    }
209  }
210  #if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606
211  TEST(FlatHashMap, NodeHandleMutableKeyAccess) {
212    flat_hash_map<std::string, std::string> map;
213    map["key1"] = "mapped";
214    auto nh = map.extract(map.begin());
215    nh.key().resize(3);
216    map.insert(std::move(nh));
217    EXPECT_THAT(map, testing::ElementsAre(Pair("key", "mapped")));
218  }
219  #endif
220  TEST(FlatHashMap, Reserve) {
221    for (size_t trial = 0; trial < 20; ++trial) {
222      for (size_t initial = 3; initial < 100; ++initial) {
223        flat_hash_map<size_t, size_t> map;
224        for (size_t i = 0; i < initial; ++i) {
225          map[i] = i;
226        }
227        map.erase(0);
228        map.erase(1);
229        map.reserve(map.size() + 2);
230        size_t& a2 = map[2];
231        map[initial] = a2;
232        map[initial + 1] = a2;
233        size_t& a2new = map[2];
234        EXPECT_EQ(&a2, &a2new);
235      }
236    }
237  }
238  TEST(FlatHashMap, RecursiveTypeCompiles) {
239    struct RecursiveType {
240      flat_hash_map<int, RecursiveType> m;
241    };
242    RecursiveType t;
243    t.m[0] = RecursiveType{};
244  }
245  }  
246  }  
247  ABSL_NAMESPACE_END
248  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flat_hash_map_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>2165    m.at(n);
2166    m[n];
2167  }
2168  TEST(Btree, SetRangeConstructorAndInsertSupportExplicitConversionComparable) {
2169    const absl::string_view names[] = {"n1", "n2"};
</pre></code></div>
                <div class="column column_space"><pre><code>163    m.at(n);
164    m[n];
165  }
166  TEST(FlatHashMap, MergeExtractInsert) {
167    absl::flat_hash_map<int, int> m = {{1, 7}, {2, 9}};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    