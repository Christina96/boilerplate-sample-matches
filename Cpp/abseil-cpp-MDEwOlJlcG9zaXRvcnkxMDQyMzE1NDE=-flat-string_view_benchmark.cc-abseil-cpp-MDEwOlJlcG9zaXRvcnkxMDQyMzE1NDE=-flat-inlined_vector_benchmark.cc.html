
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.414662084765177%, Tokens: 10</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-string_view_benchmark.cc</h3>
            <pre><code>1  #include "absl/strings/string_view.h"
2  #include <algorithm>
3  #include <cstdint>
4  #include <map>
5  #include <random>
6  #include <string>
7  #include <unordered_set>
8  #include <vector>
9  #include "benchmark/benchmark.h"
10  #include "absl/base/attributes.h"
11  #include "absl/base/internal/raw_logging.h"
12  #include "absl/base/macros.h"
13  #include "absl/strings/str_cat.h"
14  namespace {
15  void BM_StringViewFromString(benchmark::State& state) {
16    std::string s(state.range(0), 'x');
17    std::string* ps = &s;
18    struct SV {
19      SV() = default;
20      explicit SV(const std::string& s) : sv(s) {}
21      absl::string_view sv;
22    } sv;
23    SV* psv = &sv;
24    benchmark::DoNotOptimize(ps);
25    benchmark::DoNotOptimize(psv);
26    for (auto _ : state) {
27      new (psv) SV(*ps);
28      benchmark::DoNotOptimize(sv);
29    }
30  }
31  BENCHMARK(BM_StringViewFromString)->Arg(12)->Arg(128);
32  ABSL_ATTRIBUTE_NOINLINE
33  bool NonInlinedEq(absl::string_view a, absl::string_view b) { return a == b; }
34  ABSL_ATTRIBUTE_NOINLINE
35  void DoEqualityComparisons(benchmark::State& state, absl::string_view a,
36                             absl::string_view b) {
37    for (auto _ : state) {
38      benchmark::DoNotOptimize(a == b);
39    }
40  }
41  void BM_EqualIdentical(benchmark::State& state) {
42    std::string x(state.range(0), 'a');
43    DoEqualityComparisons(state, x, x);
44  }
45  BENCHMARK(BM_EqualIdentical)->DenseRange(0, 3)->Range(4, 1 << 10);
46  void BM_EqualSame(benchmark::State& state) {
47    std::string x(state.range(0), 'a');
48    std::string y = x;
49    DoEqualityComparisons(state, x, y);
50  }
51  BENCHMARK(BM_EqualSame)
52      ->DenseRange(0, 10)
53      ->Arg(20)
54      ->Arg(40)
55      ->Arg(70)
56      ->Arg(110)
57      ->Range(160, 4096);
58  void BM_EqualDifferent(benchmark::State& state) {
59    const int len = state.range(0);
60    std::string x(len, 'a');
61    std::string y = x;
62    if (len > 0) {
63      y[len - 1] = 'b';
64    }
65    DoEqualityComparisons(state, x, y);
66  }
67  BENCHMARK(BM_EqualDifferent)->DenseRange(0, 3)->Range(4, 1 << 10);
68  ABSL_ATTRIBUTE_NOINLINE
69  void DoConstantSizeInlinedEqualityComparisons(benchmark::State& state,
70                                                absl::string_view a) {
71    for (auto _ : state) {
72      benchmark::DoNotOptimize(a == "aaa");
73      benchmark::DoNotOptimize(a == "bbb");
74      benchmark::DoNotOptimize(a == "ccc");
75      benchmark::DoNotOptimize(a == "ddd");
76      benchmark::DoNotOptimize(a == "eee");
77      benchmark::DoNotOptimize(a == "fff");
78      benchmark::DoNotOptimize(a == "ggg");
79      benchmark::DoNotOptimize(a == "hhh");
80    }
81  }
82  void BM_EqualConstantSizeInlined(benchmark::State& state) {
83    std::string x(state.range(0), 'a');
84    DoConstantSizeInlinedEqualityComparisons(state, x);
85  }
86  BENCHMARK(BM_EqualConstantSizeInlined)->DenseRange(2, 4);
87  ABSL_ATTRIBUTE_NOINLINE
88  void DoConstantSizeNonInlinedEqualityComparisons(benchmark::State& state,
89                                                   absl::string_view a) {
90    for (auto _ : state) {
91      benchmark::DoNotOptimize(NonInlinedEq(a, "aaa"));
92      benchmark::DoNotOptimize(NonInlinedEq(a, "bbb"));
93      benchmark::DoNotOptimize(NonInlinedEq(a, "ccc"));
94      benchmark::DoNotOptimize(NonInlinedEq(a, "ddd"));
95      benchmark::DoNotOptimize(NonInlinedEq(a, "eee"));
96      benchmark::DoNotOptimize(NonInlinedEq(a, "fff"));
97      benchmark::DoNotOptimize(NonInlinedEq(a, "ggg"));
98      benchmark::DoNotOptimize(NonInlinedEq(a, "hhh"));
99    }
100  }
101  void BM_EqualConstantSizeNonInlined(benchmark::State& state) {
102    std::string x(state.range(0), 'a');
103    DoConstantSizeNonInlinedEqualityComparisons(state, x);
104  }
105  BENCHMARK(BM_EqualConstantSizeNonInlined)->DenseRange(2, 4);
106  void BM_CompareSame(benchmark::State& state) {
107    const int len = state.range(0);
108    std::string x;
109    for (int i = 0; i < len; i++) {
110      x += 'a';
111    }
112    std::string y = x;
113    absl::string_view a = x;
<span onclick='openModal()' class='match'>114    absl::string_view b = y;
115    for (auto _ : state) {
116      benchmark::DoNotOptimize(a);
117      benchmark::DoNotOptimize(b);
118      benchmark::DoNotOptimize(a.compare(b));
119    }
120  }
121  BENCHMARK(BM_CompareSame)->DenseRange(0, 3)->Range(4, 1 << 10);
122  void BM_CompareFirstOneLess(benchmark::State& state) {
123    const int len = state.range(0);
</span>124    std::string x(len, 'a');
125    std::string y = x;
126    y.back() = 'b';
127    absl::string_view a = x;
128    absl::string_view b = y;
129    for (auto _ : state) {
130      benchmark::DoNotOptimize(a);
131      benchmark::DoNotOptimize(b);
132      benchmark::DoNotOptimize(a.compare(b));
133    }
134  }
135  BENCHMARK(BM_CompareFirstOneLess)->DenseRange(1, 3)->Range(4, 1 << 10);
136  void BM_CompareSecondOneLess(benchmark::State& state) {
137    const int len = state.range(0);
138    std::string x(len, 'a');
139    std::string y = x;
140    x.back() = 'b';
141    absl::string_view a = x;
142    absl::string_view b = y;
143    for (auto _ : state) {
144      benchmark::DoNotOptimize(a);
145      benchmark::DoNotOptimize(b);
146      benchmark::DoNotOptimize(a.compare(b));
147    }
148  }
149  BENCHMARK(BM_CompareSecondOneLess)->DenseRange(1, 3)->Range(4, 1 << 10);
150  void BM_find_string_view_len_one(benchmark::State& state) {
151    std::string haystack(state.range(0), '0');
152    absl::string_view s(haystack);
153    for (auto _ : state) {
154      benchmark::DoNotOptimize(s.find("x"));  
155    }
156  }
157  BENCHMARK(BM_find_string_view_len_one)->Range(1, 1 << 20);
158  void BM_find_string_view_len_two(benchmark::State& state) {
159    std::string haystack(state.range(0), '0');
160    absl::string_view s(haystack);
161    for (auto _ : state) {
162      benchmark::DoNotOptimize(s.find("xx"));  
163    }
164  }
165  BENCHMARK(BM_find_string_view_len_two)->Range(1, 1 << 20);
166  void BM_find_one_char(benchmark::State& state) {
167    std::string haystack(state.range(0), '0');
168    absl::string_view s(haystack);
169    for (auto _ : state) {
170      benchmark::DoNotOptimize(s.find('x'));  
171    }
172  }
173  BENCHMARK(BM_find_one_char)->Range(1, 1 << 20);
174  void BM_rfind_one_char(benchmark::State& state) {
175    std::string haystack(state.range(0), '0');
176    absl::string_view s(haystack);
177    for (auto _ : state) {
178      benchmark::DoNotOptimize(s.rfind('x'));  
179    }
180  }
181  BENCHMARK(BM_rfind_one_char)->Range(1, 1 << 20);
182  void BM_worst_case_find_first_of(benchmark::State& state, int haystack_len) {
183    const int needle_len = state.range(0);
184    std::string needle;
185    for (int i = 0; i < needle_len; ++i) {
186      needle += 'a' + i;
187    }
188    std::string haystack(haystack_len, '0');  
189    absl::string_view s(haystack);
190    for (auto _ : state) {
191      benchmark::DoNotOptimize(s.find_first_of(needle));
192    }
193  }
194  void BM_find_first_of_short(benchmark::State& state) {
195    BM_worst_case_find_first_of(state, 10);
196  }
197  void BM_find_first_of_medium(benchmark::State& state) {
198    BM_worst_case_find_first_of(state, 100);
199  }
200  void BM_find_first_of_long(benchmark::State& state) {
201    BM_worst_case_find_first_of(state, 1000);
202  }
203  BENCHMARK(BM_find_first_of_short)->DenseRange(0, 4)->Arg(8)->Arg(16)->Arg(32);
204  BENCHMARK(BM_find_first_of_medium)->DenseRange(0, 4)->Arg(8)->Arg(16)->Arg(32);
205  BENCHMARK(BM_find_first_of_long)->DenseRange(0, 4)->Arg(8)->Arg(16)->Arg(32);
206  struct EasyMap : public std::map<absl::string_view, uint64_t> {
207    explicit EasyMap(size_t) {}
208  };
209  template <typename Map, int WordsPerKey>
210  void StringViewMapBenchmark(benchmark::State& state) {
211    const int table_size = state.range(0);
212    const double kFractionOfKeysThatAreHot = 0.2;
213    const int kNumLookupsOfHotKeys = 20;
214    const int kNumLookupsOfColdKeys = 1;
215    const char* words[] = {"the",   "quick",  "brown",    "fox",      "jumped",
216                           "over",  "the",    "lazy",     "dog",      "and",
217                           "found", "a",      "large",    "mushroom", "and",
218                           "a",     "couple", "crickets", "eating",   "pie"};
219    std::random_device r;
220    std::seed_seq seed({r(), r(), r(), r(), r(), r(), r(), r()});
221    std::mt19937 rng(seed);
222    std::vector<std::string> keys(table_size);
223    std::vector<int> all_indices;
224    const int kBlockSize = 1 << 12;
225    std::unordered_set<std::string> t(kBlockSize);
226    std::uniform_int_distribution<int> uniform(0, ABSL_ARRAYSIZE(words) - 1);
227    for (int i = 0; i < table_size; i++) {
228      all_indices.push_back(i);
229      do {
230        keys[i].clear();
231        for (int j = 0; j < WordsPerKey; j++) {
232          absl::StrAppend(&keys[i], j > 0 ? " " : "", words[uniform(rng)]);
233        }
234      } while (!t.insert(keys[i]).second);
235    }
236    std::shuffle(all_indices.begin(), all_indices.end(), rng);
237    const int num_hot = table_size * kFractionOfKeysThatAreHot;
238    const int num_cold = table_size - num_hot;
239    std::vector<int> hot_indices(all_indices.begin(),
240                                 all_indices.begin() + num_hot);
241    std::vector<int> indices;
242    for (int i = 0; i < kNumLookupsOfColdKeys; i++) {
243      indices.insert(indices.end(), all_indices.begin(), all_indices.end());
244    }
245    for (int i = 0; i < kNumLookupsOfHotKeys - kNumLookupsOfColdKeys; i++) {
246      indices.insert(indices.end(), hot_indices.begin(), hot_indices.end());
247    }
248    std::shuffle(indices.begin(), indices.end(), rng);
249    ABSL_RAW_CHECK(
250        num_cold * kNumLookupsOfColdKeys + num_hot * kNumLookupsOfHotKeys ==
251            indices.size(),
252        "");
253    std::vector<std::string> test_strings(indices.size());
254    for (int i = 0; i < indices.size(); i++) {
255      test_strings[i] = keys[indices[i]];
256    }
257    for (auto _ : state) {
258      Map h(table_size);
259      for (int i = 0; i < table_size; i++) {
260        h[keys[i]] = i * 2;
261      }
262      ABSL_RAW_CHECK(h.size() == table_size, "");
263      uint64_t sum = 0;
264      for (int i = 0; i < indices.size(); i++) {
265        sum += h[test_strings[i]];
266      }
267      benchmark::DoNotOptimize(sum);
268    }
269  }
270  void BM_StdMap_4(benchmark::State& state) {
271    StringViewMapBenchmark<EasyMap, 4>(state);
272  }
273  BENCHMARK(BM_StdMap_4)->Range(1 << 10, 1 << 16);
274  void BM_StdMap_8(benchmark::State& state) {
275    StringViewMapBenchmark<EasyMap, 8>(state);
276  }
277  BENCHMARK(BM_StdMap_8)->Range(1 << 10, 1 << 16);
278  void BM_CopyToStringNative(benchmark::State& state) {
279    std::string src(state.range(0), 'x');
280    absl::string_view sv(src);
281    std::string dst;
282    for (auto _ : state) {
283      dst.assign(sv.begin(), sv.end());
284    }
285  }
286  BENCHMARK(BM_CopyToStringNative)->Range(1 << 3, 1 << 12);
287  void BM_AppendToStringNative(benchmark::State& state) {
288    std::string src(state.range(0), 'x');
289    absl::string_view sv(src);
290    std::string dst;
291    for (auto _ : state) {
292      dst.clear();
293      dst.insert(dst.end(), sv.begin(), sv.end());
294    }
295  }
296  BENCHMARK(BM_AppendToStringNative)->Range(1 << 3, 1 << 12);
297  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</h3>
            <pre><code>1  #include <array>
2  #include <string>
3  #include <vector>
4  #include "absl/base/internal/raw_logging.h"
5  #include "absl/base/macros.h"
6  #include "absl/container/inlined_vector.h"
7  #include "absl/strings/str_cat.h"
8  #include "benchmark/benchmark.h"
9  namespace {
10  void BM_InlinedVectorFill(benchmark::State& state) {
11    const int len = state.range(0);
12    absl::InlinedVector<int, 8> v;
13    v.reserve(len);
14    for (auto _ : state) {
15      v.resize(0);  
16      for (int i = 0; i < len; ++i) {
17        v.push_back(i);
18      }
19      benchmark::DoNotOptimize(v);
20    }
21  }
22  BENCHMARK(BM_InlinedVectorFill)->Range(1, 256);
23  void BM_InlinedVectorFillRange(benchmark::State& state) {
24    const int len = state.range(0);
25    const std::vector<int> src(len, len);
26    absl::InlinedVector<int, 8> v;
27    v.reserve(len);
28    for (auto _ : state) {
29      benchmark::DoNotOptimize(src);
30      v.assign(src.begin(), src.end());
31      benchmark::DoNotOptimize(v);
32    }
33  }
34  BENCHMARK(BM_InlinedVectorFillRange)->Range(1, 256);
35  void BM_StdVectorFill(benchmark::State& state) {
36    const int len = state.range(0);
37    std::vector<int> v;
38    v.reserve(len);
39    for (auto _ : state) {
40      v.clear();
41      for (int i = 0; i < len; ++i) {
42        v.push_back(i);
43      }
44      benchmark::DoNotOptimize(v);
45    }
46  }
47  BENCHMARK(BM_StdVectorFill)->Range(1, 256);
48  bool StringRepresentedInline(std::string s) {
49    const char* chars = s.data();
50    std::string s1 = std::move(s);
51    return s1.data() != chars;
52  }
53  int GetNonShortStringOptimizationSize() {
54    for (int i = 24; i <= 192; i *= 2) {
55      if (!StringRepresentedInline(std::string(i, 'A'))) {
56        return i;
57      }
58    }
59    ABSL_RAW_LOG(
60        FATAL,
61        "Failed to find a string larger than the short string optimization");
62    return -1;
63  }
64  void BM_InlinedVectorFillString(benchmark::State& state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
68                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
69    for (auto _ : state) {
70      absl::InlinedVector<std::string, 8> v;
71      for (int i = 0; i < len; i++) {
72        v.push_back(strings[i & 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)->Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State& state) {
79    const int len = state.range(0);
80    const int no_sso = GetNonShortStringOptimizationSize();
81    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
82                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
83    for (auto _ : state) {
84      std::vector<std::string> v;
85      for (int i = 0; i < len; i++) {
86        v.push_back(strings[i & 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)->Range(0, 1024);
92  struct Buffer {  
93    char* base;
94    int length;
95    int capacity;
96    void* user_data;
97  };
98  void BM_InlinedVectorAssignments(benchmark::State& state) {
99    const int len = state.range(0);
100    using BufferVec = absl::InlinedVector<Buffer, 2>;
101    BufferVec src;
102    src.resize(len);
103    BufferVec dst;
104    for (auto _ : state) {
105      benchmark::DoNotOptimize(dst);
106      benchmark::DoNotOptimize(src);
107      dst = src;
108    }
109  }
110  BENCHMARK(BM_InlinedVectorAssignments)
111      ->Arg(0)
112      ->Arg(1)
113      ->Arg(2)
114      ->Arg(3)
115      ->Arg(4)
116      ->Arg(20);
117  void BM_CreateFromContainer(benchmark::State& state) {
118    for (auto _ : state) {
119      absl::InlinedVector<int, 4> src{1, 2, 3};
120      benchmark::DoNotOptimize(src);
121      absl::InlinedVector<int, 4> dst(std::move(src));
122      benchmark::DoNotOptimize(dst);
123    }
124  }
125  BENCHMARK(BM_CreateFromContainer);
126  struct LargeCopyableOnly {
127    LargeCopyableOnly() : d(1024, 17) {}
128    LargeCopyableOnly(const LargeCopyableOnly& o) = default;
129    LargeCopyableOnly& operator=(const LargeCopyableOnly& o) = default;
130    std::vector<int> d;
131  };
132  struct LargeCopyableSwappable {
133    LargeCopyableSwappable() : d(1024, 17) {}
134    LargeCopyableSwappable(const LargeCopyableSwappable& o) = default;
135    LargeCopyableSwappable& operator=(LargeCopyableSwappable o) {
136      using std::swap;
137      swap(*this, o);
138      return *this;
139    }
140    friend void swap(LargeCopyableSwappable& a, LargeCopyableSwappable& b) {
141      using std::swap;
142      swap(a.d, b.d);
143    }
144    std::vector<int> d;
145  };
146  struct LargeCopyableMovable {
147    LargeCopyableMovable() : d(1024, 17) {}
148    std::vector<int> d;
149  };
150  struct LargeCopyableMovableSwappable {
151    LargeCopyableMovableSwappable() : d(1024, 17) {}
152    LargeCopyableMovableSwappable(const LargeCopyableMovableSwappable& o) =
153        default;
154    LargeCopyableMovableSwappable(LargeCopyableMovableSwappable&& o) = default;
155    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable o) {
156      using std::swap;
157      swap(*this, o);
158      return *this;
159    }
160    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable&& o) =
161        default;
162    friend void swap(LargeCopyableMovableSwappable& a,
163                     LargeCopyableMovableSwappable& b) {
164      using std::swap;
165      swap(a.d, b.d);
166    }
167    std::vector<int> d;
168  };
169  template <typename ElementType>
170  void BM_SwapElements(benchmark::State& state) {
171    const int len = state.range(0);
172    using Vec = absl::InlinedVector<ElementType, 32>;
173    Vec a(len);
174    Vec b;
175    for (auto _ : state) {
176      using std::swap;
177      benchmark::DoNotOptimize(a);
178      benchmark::DoNotOptimize(b);
179      swap(a, b);
180    }
181  }
182  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableOnly)->Range(0, 1024);
183  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableSwappable)->Range(0, 1024);
184  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovable)->Range(0, 1024);
185  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovableSwappable)
186      ->Range(0, 1024);
187  template <typename VecType>
188  void BM_Sizeof(benchmark::State& state) {
189    int size = 0;
190    for (auto _ : state) {
191      VecType vec;
192      size = sizeof(vec);
193    }
194    state.SetLabel(absl::StrCat("sz=", size));
195  }
196  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 1>);
197  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 4>);
198  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 7>);
199  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 8>);
200  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 1>);
201  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 4>);
202  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 7>);
203  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 8>);
204  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 1>);
205  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 4>);
206  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 7>);
207  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 8>);
208  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 1>);
209  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 4>);
210  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 7>);
211  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 8>);
212  void BM_InlinedVectorIndexInlined(benchmark::State& state) {
213    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
214    for (auto _ : state) {
215      benchmark::DoNotOptimize(v);
216      benchmark::DoNotOptimize(v[4]);
217    }
218  }
219  BENCHMARK(BM_InlinedVectorIndexInlined);
220  void BM_InlinedVectorIndexExternal(benchmark::State& state) {
221    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
222    for (auto _ : state) {
223      benchmark::DoNotOptimize(v);
224      benchmark::DoNotOptimize(v[4]);
225    }
226  }
227  BENCHMARK(BM_InlinedVectorIndexExternal);
228  void BM_StdVectorIndex(benchmark::State& state) {
229    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
230    for (auto _ : state) {
231      benchmark::DoNotOptimize(v);
232      benchmark::DoNotOptimize(v[4]);
233    }
234  }
235  BENCHMARK(BM_StdVectorIndex);
236  void BM_InlinedVectorDataInlined(benchmark::State& state) {
237    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
238    for (auto _ : state) {
239      benchmark::DoNotOptimize(v);
240      benchmark::DoNotOptimize(v.data());
241    }
242  }
243  BENCHMARK(BM_InlinedVectorDataInlined);
244  void BM_InlinedVectorDataExternal(benchmark::State& state) {
245    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
246    for (auto _ : state) {
247      benchmark::DoNotOptimize(v);
248      benchmark::DoNotOptimize(v.data());
249    }
250    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
251  }
252  BENCHMARK(BM_InlinedVectorDataExternal);
253  void BM_StdVectorData(benchmark::State& state) {
254    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
255    for (auto _ : state) {
256      benchmark::DoNotOptimize(v);
257      benchmark::DoNotOptimize(v.data());
258    }
259    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
260  }
261  BENCHMARK(BM_StdVectorData);
262  void BM_InlinedVectorSizeInlined(benchmark::State& state) {
263    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
264    for (auto _ : state) {
265      benchmark::DoNotOptimize(v);
266      benchmark::DoNotOptimize(v.size());
267    }
268  }
269  BENCHMARK(BM_InlinedVectorSizeInlined);
270  void BM_InlinedVectorSizeExternal(benchmark::State& state) {
271    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
272    for (auto _ : state) {
273      benchmark::DoNotOptimize(v);
274      benchmark::DoNotOptimize(v.size());
275    }
276  }
277  BENCHMARK(BM_InlinedVectorSizeExternal);
278  void BM_StdVectorSize(benchmark::State& state) {
279    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
280    for (auto _ : state) {
281      benchmark::DoNotOptimize(v);
282      benchmark::DoNotOptimize(v.size());
283    }
284  }
285  BENCHMARK(BM_StdVectorSize);
286  void BM_InlinedVectorEmptyInlined(benchmark::State& state) {
287    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
288    for (auto _ : state) {
289      benchmark::DoNotOptimize(v);
290      benchmark::DoNotOptimize(v.empty());
291    }
292  }
293  BENCHMARK(BM_InlinedVectorEmptyInlined);
294  void BM_InlinedVectorEmptyExternal(benchmark::State& state) {
295    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
296    for (auto _ : state) {
297      benchmark::DoNotOptimize(v);
298      benchmark::DoNotOptimize(v.empty());
299    }
300  }
301  BENCHMARK(BM_InlinedVectorEmptyExternal);
302  void BM_StdVectorEmpty(benchmark::State& state) {
303    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
304    for (auto _ : state) {
305      benchmark::DoNotOptimize(v);
306      benchmark::DoNotOptimize(v.empty());
307    }
308  }
309  BENCHMARK(BM_StdVectorEmpty);
310  constexpr size_t kInlinedCapacity = 4;
311  constexpr size_t kLargeSize = kInlinedCapacity * 2;
312  constexpr size_t kSmallSize = kInlinedCapacity / 2;
313  constexpr size_t kBatchSize = 100;
314  #define ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_FunctionTemplate, T) \
315    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize);        \
316    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize)
317  #define ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_FunctionTemplate, T)      \
318    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kLargeSize); \
319    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kSmallSize); \
320    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kLargeSize); \
321    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kSmallSize)
322  template <typename T>
323  using InlVec = absl::InlinedVector<T, kInlinedCapacity>;
324  struct TrivialType {
325    size_t val;
326  };
327  class NontrivialType {
328   public:
329    ABSL_ATTRIBUTE_NOINLINE NontrivialType() : val_() {
330      benchmark::DoNotOptimize(*this);
331    }
332    ABSL_ATTRIBUTE_NOINLINE NontrivialType(const NontrivialType& other)
333        : val_(other.val_) {
334      benchmark::DoNotOptimize(*this);
335    }
336    ABSL_ATTRIBUTE_NOINLINE NontrivialType& operator=(
337        const NontrivialType& other) {
338      val_ = other.val_;
339      benchmark::DoNotOptimize(*this);
340      return *this;
341    }
342    ABSL_ATTRIBUTE_NOINLINE ~NontrivialType() noexcept {
343      benchmark::DoNotOptimize(*this);
344    }
345   private:
346    size_t val_;
347  };
348  template <typename T, typename PrepareVecFn, typename TestVecFn>
349  void BatchedBenchmark(benchmark::State& state, PrepareVecFn prepare_vec,
350                        TestVecFn test_vec) {
351    std::array<InlVec<T>, kBatchSize> vector_batch{};
352    while (state.KeepRunningBatch(kBatchSize)) {
353      state.PauseTiming();
354      for (size_t i = 0; i < kBatchSize; ++i) {
355        prepare_vec(vector_batch.data() + i, i);
356      }
357      benchmark::DoNotOptimize(vector_batch);
358      state.ResumeTiming();
359      for (size_t i = 0; i < kBatchSize; ++i) {
360        test_vec(vector_batch.data() + i, i);
361      }
362    }
363  }
364  template <typename T, size_t ToSize>
365  void BM_ConstructFromSize(benchmark::State& state) {
366    using VecT = InlVec<T>;
367    auto size = ToSize;
368    BatchedBenchmark<T>(
369        state,
370         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
371        [&](void* ptr, size_t) {
372          benchmark::DoNotOptimize(size);
373          ::new (ptr) VecT(size);
374        });
375  }
376  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, TrivialType);
377  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, NontrivialType);
378  template <typename T, size_t ToSize>
379  void BM_ConstructFromSizeRef(benchmark::State& state) {
380    using VecT = InlVec<T>;
381    auto size = ToSize;
382    auto ref = T();
383    BatchedBenchmark<T>(
384        state,
385         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
386        [&](void* ptr, size_t) {
387          benchmark::DoNotOptimize(size);
388          benchmark::DoNotOptimize(ref);
389          ::new (ptr) VecT(size, ref);
390        });
391  }
392  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, TrivialType);
393  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, NontrivialType);
394  template <typename T, size_t ToSize>
395  void BM_ConstructFromRange(benchmark::State& state) {
396    using VecT = InlVec<T>;
397    std::array<T, ToSize> arr{};
398    BatchedBenchmark<T>(
399        state,
400         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
401        [&](void* ptr, size_t) {
402          benchmark::DoNotOptimize(arr);
403          ::new (ptr) VecT(arr.begin(), arr.end());
404        });
405  }
406  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, TrivialType);
407  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, NontrivialType);
408  template <typename T, size_t ToSize>
409  void BM_ConstructFromCopy(benchmark::State& state) {
410    using VecT = InlVec<T>;
411    VecT other_vec(ToSize);
412    BatchedBenchmark<T>(
413        state,
414        [](InlVec<T>* vec, size_t) { vec->~VecT(); },
415        [&](void* ptr, size_t) {
416          benchmark::DoNotOptimize(other_vec);
417          ::new (ptr) VecT(other_vec);
418        });
419  }
420  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, TrivialType);
421  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, NontrivialType);
422  template <typename T, size_t ToSize>
423  void BM_ConstructFromMove(benchmark::State& state) {
424    using VecT = InlVec<T>;
425    std::array<VecT, kBatchSize> vector_batch{};
426    BatchedBenchmark<T>(
427        state,
428        [&](InlVec<T>* vec, size_t i) {
429          vector_batch[i].clear();
430          vector_batch[i].resize(ToSize);
431          vec->~VecT();
432        },
433        [&](void* ptr, size_t i) {
434          benchmark::DoNotOptimize(vector_batch[i]);
435          ::new (ptr) VecT(std::move(vector_batch[i]));
436        });
437  }
438  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, TrivialType);
439  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, NontrivialType);
440  void BM_CopyTrivial(benchmark::State& state) {
<span onclick='openModal()' class='match'>441    const int n = state.range(0);
442    InlVec<int64_t> src(n);
443    for (auto s : state) {
444      InlVec<int64_t> copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State& state) {
450    const int n = state.range(0);
</span>451    InlVec<InlVec<int64_t>> src(n);
452    for (auto s : state) {
453      InlVec<InlVec<int64_t>> copy(src);
454      benchmark::DoNotOptimize(copy);
455    }
456  }
457  BENCHMARK(BM_CopyNonTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
458  template <typename T, size_t FromSize, size_t ToSize>
459  void BM_AssignSizeRef(benchmark::State& state) {
460    auto size = ToSize;
461    auto ref = T();
462    BatchedBenchmark<T>(
463        state,
464         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
465        [&](InlVec<T>* vec, size_t) {
466          benchmark::DoNotOptimize(size);
467          benchmark::DoNotOptimize(ref);
468          vec->assign(size, ref);
469        });
470  }
471  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, TrivialType);
472  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, NontrivialType);
473  template <typename T, size_t FromSize, size_t ToSize>
474  void BM_AssignRange(benchmark::State& state) {
475    std::array<T, ToSize> arr{};
476    BatchedBenchmark<T>(
477        state,
478         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
479        [&](InlVec<T>* vec, size_t) {
480          benchmark::DoNotOptimize(arr);
481          vec->assign(arr.begin(), arr.end());
482        });
483  }
484  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, TrivialType);
485  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, NontrivialType);
486  template <typename T, size_t FromSize, size_t ToSize>
487  void BM_AssignFromCopy(benchmark::State& state) {
488    InlVec<T> other_vec(ToSize);
489    BatchedBenchmark<T>(
490        state,
491         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
492        [&](InlVec<T>* vec, size_t) {
493          benchmark::DoNotOptimize(other_vec);
494          *vec = other_vec;
495        });
496  }
497  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, TrivialType);
498  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, NontrivialType);
499  template <typename T, size_t FromSize, size_t ToSize>
500  void BM_AssignFromMove(benchmark::State& state) {
501    using VecT = InlVec<T>;
502    std::array<VecT, kBatchSize> vector_batch{};
503    BatchedBenchmark<T>(
504        state,
505        [&](InlVec<T>* vec, size_t i) {
506          vector_batch[i].clear();
507          vector_batch[i].resize(ToSize);
508          vec->resize(FromSize);
509        },
510        [&](InlVec<T>* vec, size_t i) {
511          benchmark::DoNotOptimize(vector_batch[i]);
512          *vec = std::move(vector_batch[i]);
513        });
514  }
515  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, TrivialType);
516  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, NontrivialType);
517  template <typename T, size_t FromSize, size_t ToSize>
518  void BM_ResizeSize(benchmark::State& state) {
519    BatchedBenchmark<T>(
520        state,
521        [](InlVec<T>* vec, size_t) {
522          vec->clear();
523          vec->resize(FromSize);
524        },
525        [](InlVec<T>* vec, size_t) { vec->resize(ToSize); });
526  }
527  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, TrivialType);
528  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, NontrivialType);
529  template <typename T, size_t FromSize, size_t ToSize>
530  void BM_ResizeSizeRef(benchmark::State& state) {
531    auto t = T();
532    BatchedBenchmark<T>(
533        state,
534        [](InlVec<T>* vec, size_t) {
535          vec->clear();
536          vec->resize(FromSize);
537        },
538        [&](InlVec<T>* vec, size_t) {
539          benchmark::DoNotOptimize(t);
540          vec->resize(ToSize, t);
541        });
542  }
543  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, TrivialType);
544  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, NontrivialType);
545  template <typename T, size_t FromSize, size_t ToSize>
546  void BM_InsertSizeRef(benchmark::State& state) {
547    auto t = T();
548    BatchedBenchmark<T>(
549        state,
550        [](InlVec<T>* vec, size_t) {
551          vec->clear();
552          vec->resize(FromSize);
553        },
554        [&](InlVec<T>* vec, size_t) {
555          benchmark::DoNotOptimize(t);
556          auto* pos = vec->data() + (vec->size() / 2);
557          vec->insert(pos, t);
558        });
559  }
560  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, TrivialType);
561  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, NontrivialType);
562  template <typename T, size_t FromSize, size_t ToSize>
563  void BM_InsertRange(benchmark::State& state) {
564    InlVec<T> other_vec(ToSize);
565    BatchedBenchmark<T>(
566        state,
567        [](InlVec<T>* vec, size_t) {
568          vec->clear();
569          vec->resize(FromSize);
570        },
571        [&](InlVec<T>* vec, size_t) {
572          benchmark::DoNotOptimize(other_vec);
573          auto* pos = vec->data() + (vec->size() / 2);
574          vec->insert(pos, other_vec.begin(), other_vec.end());
575        });
576  }
577  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, TrivialType);
578  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, NontrivialType);
579  template <typename T, size_t FromSize>
580  void BM_EmplaceBack(benchmark::State& state) {
581    BatchedBenchmark<T>(
582        state,
583        [](InlVec<T>* vec, size_t) {
584          vec->clear();
585          vec->resize(FromSize);
586        },
587        [](InlVec<T>* vec, size_t) { vec->emplace_back(); });
588  }
589  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, TrivialType);
590  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, NontrivialType);
591  template <typename T, size_t FromSize>
592  void BM_PopBack(benchmark::State& state) {
593    BatchedBenchmark<T>(
594        state,
595        [](InlVec<T>* vec, size_t) {
596          vec->clear();
597          vec->resize(FromSize);
598        },
599        [](InlVec<T>* vec, size_t) { vec->pop_back(); });
600  }
601  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, TrivialType);
602  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, NontrivialType);
603  template <typename T, size_t FromSize>
604  void BM_EraseOne(benchmark::State& state) {
605    BatchedBenchmark<T>(
606        state,
607        [](InlVec<T>* vec, size_t) {
608          vec->clear();
609          vec->resize(FromSize);
610        },
611        [](InlVec<T>* vec, size_t) {
612          auto* pos = vec->data() + (vec->size() / 2);
613          vec->erase(pos);
614        });
615  }
616  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, TrivialType);
617  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, NontrivialType);
618  template <typename T, size_t FromSize>
619  void BM_EraseRange(benchmark::State& state) {
620    BatchedBenchmark<T>(
621        state,
622        [](InlVec<T>* vec, size_t) {
623          vec->clear();
624          vec->resize(FromSize);
625        },
626        [](InlVec<T>* vec, size_t) {
627          auto* pos = vec->data() + (vec->size() / 2);
628          vec->erase(pos, pos + 1);
629        });
630  }
631  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, TrivialType);
632  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, NontrivialType);
633  template <typename T, size_t FromSize>
634  void BM_Clear(benchmark::State& state) {
635    BatchedBenchmark<T>(
636        state,
637         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
638         [](InlVec<T>* vec, size_t) { vec->clear(); });
639  }
640  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, TrivialType);
641  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, NontrivialType);
642  template <typename T, size_t FromSize, size_t ToCapacity>
643  void BM_Reserve(benchmark::State& state) {
644    BatchedBenchmark<T>(
645        state,
646        [](InlVec<T>* vec, size_t) {
647          vec->clear();
648          vec->resize(FromSize);
649        },
650        [](InlVec<T>* vec, size_t) { vec->reserve(ToCapacity); });
651  }
652  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, TrivialType);
653  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, NontrivialType);
654  template <typename T, size_t FromCapacity, size_t ToCapacity>
655  void BM_ShrinkToFit(benchmark::State& state) {
656    BatchedBenchmark<T>(
657        state,
658        [](InlVec<T>* vec, size_t) {
659          vec->clear();
660          vec->resize(ToCapacity);
661          vec->reserve(FromCapacity);
662        },
663         [](InlVec<T>* vec, size_t) { vec->shrink_to_fit(); });
664  }
665  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, TrivialType);
666  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, NontrivialType);
667  template <typename T, size_t FromSize, size_t ToSize>
668  void BM_Swap(benchmark::State& state) {
669    using VecT = InlVec<T>;
670    std::array<VecT, kBatchSize> vector_batch{};
671    BatchedBenchmark<T>(
672        state,
673        [&](InlVec<T>* vec, size_t i) {
674          vector_batch[i].clear();
675          vector_batch[i].resize(ToSize);
676          vec->resize(FromSize);
677        },
678        [&](InlVec<T>* vec, size_t i) {
679          using std::swap;
680          benchmark::DoNotOptimize(vector_batch[i]);
681          swap(*vec, vector_batch[i]);
682        });
683  }
684  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, TrivialType);
685  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, NontrivialType);
686  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-string_view_benchmark.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</div>
                <div class="column column_space"><pre><code>114    absl::string_view b = y;
115    for (auto _ : state) {
116      benchmark::DoNotOptimize(a);
117      benchmark::DoNotOptimize(b);
118      benchmark::DoNotOptimize(a.compare(b));
119    }
120  }
121  BENCHMARK(BM_CompareSame)->DenseRange(0, 3)->Range(4, 1 << 10);
122  void BM_CompareFirstOneLess(benchmark::State& state) {
123    const int len = state.range(0);
</pre></code></div>
                <div class="column column_space"><pre><code>441    const int n = state.range(0);
442    InlVec<int64_t> src(n);
443    for (auto s : state) {
444      InlVec<int64_t> copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State& state) {
450    const int n = state.range(0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    