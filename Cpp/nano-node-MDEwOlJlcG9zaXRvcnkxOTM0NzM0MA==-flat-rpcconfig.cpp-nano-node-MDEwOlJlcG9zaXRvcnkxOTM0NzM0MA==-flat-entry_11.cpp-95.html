
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpcconfig.cpp</h3>
            <pre><code>1  #include &lt;nano/boost/asio/ip/address_v6.hpp&gt;
2  #include &lt;nano/lib/config.hpp&gt;
3  #include &lt;nano/lib/rpcconfig.hpp&gt;
4  #include &lt;nano/lib/tomlconfig.hpp&gt;
5  #include &lt;boost/dll/runtime_symbol_info.hpp&gt;
6  nano::error nano::rpc_secure_config::serialize_toml (nano::tomlconfig &amp; toml) const
7  {
8  	toml.put (&quot;enable&quot;, enable, &quot;Enable or disable TLS support.\ntype:bool&quot;);
9  	toml.put (&quot;verbose_logging&quot;, verbose_logging, &quot;Enable or disable verbose logging.\ntype:bool&quot;);
10  	toml.put (&quot;server_key_passphrase&quot;, server_key_passphrase, &quot;Server key passphrase.\ntype:string&quot;);
11  	toml.put (&quot;server_cert_path&quot;, server_cert_path, &quot;Directory containing certificates.\ntype:string,path&quot;);
12  	toml.put (&quot;server_key_path&quot;, server_key_path, &quot;Path to server key PEM file.\ntype:string,path&quot;);
13  	toml.put (&quot;server_dh_path&quot;, server_dh_path, &quot;Path to Diffie-Hellman params file.\ntype:string,path&quot;);
14  	toml.put (&quot;client_certs_path&quot;, client_certs_path, &quot;Directory containing client certificates.\ntype:string&quot;);
15  	return toml.get_error ();
16  }
17  nano::error nano::rpc_secure_config::deserialize_toml (nano::tomlconfig &amp; toml)
18  {
19  	toml.get&lt;bool&gt; (&quot;enable&quot;, enable);
20  	toml.get&lt;bool&gt; (&quot;verbose_logging&quot;, verbose_logging);
21  	toml.get&lt;std::string&gt; (&quot;server_key_passphrase&quot;, server_key_passphrase);
22  	toml.get&lt;std::string&gt; (&quot;server_cert_path&quot;, server_cert_path);
23  	toml.get&lt;std::string&gt; (&quot;server_key_path&quot;, server_key_path);
24  	toml.get&lt;std::string&gt; (&quot;server_dh_path&quot;, server_dh_path);
25  	toml.get&lt;std::string&gt; (&quot;client_certs_path&quot;, client_certs_path);
26  	return toml.get_error ();
27  }
28  nano::rpc_config::rpc_config (nano::network_constants &amp; network_constants) :
29  	rpc_process{ network_constants },
30  	address{ boost::asio::ip::address_v6::loopback ().to_string () }
31  {
32  }
33  nano::rpc_config::rpc_config (nano::network_constants &amp; network_constants, uint16_t port_a, bool enable_control_a) :
34  	rpc_process{ network_constants },
35  	address{ boost::asio::ip::address_v6::loopback ().to_string () },
36  	port{ port_a },
37  	enable_control{ enable_control_a }
38  {
39  }
40  nano::error nano::rpc_config::serialize_toml (nano::tomlconfig &amp; toml) const
41  {
42  	toml.put (&quot;address&quot;, address, &quot;Bind address for the RPC server.\ntype:string,ip&quot;);
43  	toml.put (&quot;port&quot;, port, &quot;Listening port for the RPC server.\ntype:uint16&quot;);
44  	toml.put (&quot;enable_control&quot;, enable_control, &quot;Enable or disable control-level requests.\nWARNING: Enabling this gives anyone with RPC access the ability to stop the node and access wallet funds.\ntype:bool&quot;);
45  	toml.put (&quot;max_json_depth&quot;, max_json_depth, &quot;Maximum number of levels in JSON requests.\ntype:uint8&quot;);
46  	toml.put (&quot;max_request_size&quot;, max_request_size, &quot;Maximum number of bytes allowed in request bodies.\ntype:uint64&quot;);
47  	nano::tomlconfig rpc_process_l;
48  	rpc_process_l.put (&quot;io_threads&quot;, rpc_process.io_threads, &quot;Number of threads used to serve IO.\ntype:uint32&quot;);
49  	rpc_process_l.put (&quot;ipc_address&quot;, rpc_process.ipc_address, &quot;Address of IPC server.\ntype:string,ip&quot;);
50  	rpc_process_l.put (&quot;ipc_port&quot;, rpc_process.ipc_port, &quot;Listening port of IPC server.\ntype:uint16&quot;);
51  	rpc_process_l.put (&quot;num_ipc_connections&quot;, rpc_process.num_ipc_connections, &quot;Number of IPC connections to establish.\ntype:uint32&quot;);
52  	toml.put_child (&quot;process&quot;, rpc_process_l);
53  	nano::tomlconfig rpc_logging_l;
54  	rpc_logging_l.put (&quot;log_rpc&quot;, rpc_logging.log_rpc, &quot;Whether to log RPC calls.\ntype:bool&quot;);
55  	toml.put_child (&quot;logging&quot;, rpc_logging_l);
56  	return toml.get_error ();
57  }
58  nano::error nano::rpc_config::deserialize_toml (nano::tomlconfig &amp; toml)
59  {
60  	if (!toml.empty ())
61  	{
62  		auto rpc_secure_l (toml.get_optional_child (&quot;secure&quot;));
63  		if (rpc_secure_l)
64  		{
65  			return nano::error (&quot;The RPC secure configuration has moved to config-tls.toml. Please update the configuration.&quot;);
66  		}
67  		boost::asio::ip::address_v6 address_l;
68  		toml.get_optional&lt;boost::asio::ip::address_v6&gt; (&quot;address&quot;, address_l, boost::asio::ip::address_v6::loopback ());
69  		address = address_l.to_string ();
70  		toml.get_optional&lt;uint16_t&gt; (&quot;port&quot;, port);
71  		toml.get_optional&lt;bool&gt; (&quot;enable_control&quot;, enable_control);
72  		toml.get_optional&lt;uint8_t&gt; (&quot;max_json_depth&quot;, max_json_depth);
73  		toml.get_optional&lt;uint64_t&gt; (&quot;max_request_size&quot;, max_request_size);
74  		auto rpc_logging_l (toml.get_optional_child (&quot;logging&quot;));
75  		if (rpc_logging_l)
76  		{
77  			rpc_logging_l-&gt;get_optional&lt;bool&gt; (&quot;log_rpc&quot;, rpc_logging.log_rpc);
78  		}
79  		auto rpc_process_l (toml.get_optional_child (&quot;process&quot;));
80  		if (rpc_process_l)
81  		{
82  			rpc_process_l-&gt;get_optional&lt;unsigned&gt; (&quot;io_threads&quot;, rpc_process.io_threads);
83  			rpc_process_l-&gt;get_optional&lt;uint16_t&gt; (&quot;ipc_port&quot;, rpc_process.ipc_port);
84  			boost::asio::ip::address_v6 ipc_address_l;
85  			rpc_process_l-&gt;get_optional&lt;boost::asio::ip::address_v6&gt; (&quot;ipc_address&quot;, ipc_address_l, boost::asio::ip::address_v6::loopback ());
86  			rpc_process.ipc_address = address_l.to_string ();
87  			rpc_process_l-&gt;get_optional&lt;unsigned&gt; (&quot;num_ipc_connections&quot;, rpc_process.num_ipc_connections);
88  		}
89  	}
90  	return toml.get_error ();
91  }
92  nano::rpc_process_config::rpc_process_config (nano::network_constants &amp; network_constants) :
93  	network_constants{ network_constants },
94  	ipc_address{ boost::asio::ip::address_v6::loopback ().to_string () }
95  {
96  }
97  namespace nano
98  {
99  nano::error read_rpc_config_toml (boost::filesystem::path const &amp; data_path_a, nano::rpc_config &amp; config_a, std::vector&lt;std::string&gt; const &amp; config_overrides)
100  {
101  	nano::error error;
102  	auto toml_config_path = nano::get_rpc_toml_config_path (data_path_a);
103  	nano::tomlconfig toml;
104  	std::stringstream config_overrides_stream;
105  	for (auto const &amp; entry : config_overrides)
106  	{
107  		config_overrides_stream &lt;&lt; entry &lt;&lt; std::endl;
108  	}
109  	config_overrides_stream &lt;&lt; std::endl;
110  	if (!error)
111  	{
112  		if (boost::filesystem::exists (toml_config_path))
113  		{
114  			error = toml.read (config_overrides_stream, toml_config_path);
115  		}
116  		else
117  		{
118  			error = toml.read (config_overrides_stream);
119  		}
120  	}
121  	if (!error)
122  	{
123  		error = config_a.deserialize_toml (toml);
124  	}
125  	return error;
126  }
127  std::string get_default_rpc_filepath ()
128  {
<span onclick='openModal()' class='match'>129  	boost::system::error_code err;
130  	auto running_executable_filepath = boost::dll::program_location (err);
131  	auto rpc_filepath = running_executable_filepath.parent_path () / &quot;nano_rpc&quot;;
</span>132  	if (running_executable_filepath.has_extension ())
133  	{
134  		rpc_filepath.replace_extension (running_executable_filepath.extension ());
135  	}
136  	return rpc_filepath.string ();
137  }
138  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_11.cpp</h3>
            <pre><code>1  #include &lt;nano/crypto_lib/random_pool.hpp&gt;
2  #include &lt;nano/lib/cli.hpp&gt;
3  #include &lt;nano/lib/utility.hpp&gt;
4  #include &lt;nano/nano_node/daemon.hpp&gt;
5  #include &lt;nano/node/cli.hpp&gt;
6  #include &lt;nano/node/daemonconfig.hpp&gt;
7  #include &lt;nano/node/ipc/ipc_server.hpp&gt;
8  #include &lt;nano/node/json_handler.hpp&gt;
9  #include &lt;nano/node/node.hpp&gt;
10  #include &lt;nano/node/transport/inproc.hpp&gt;
11  #include &lt;boost/dll/runtime_symbol_info.hpp&gt;
12  #include &lt;boost/filesystem/operations.hpp&gt;
13  #include &lt;boost/format.hpp&gt;
14  #include &lt;boost/lexical_cast.hpp&gt;
15  #include &lt;boost/program_options.hpp&gt;
16  #include &lt;boost/range/adaptor/reversed.hpp&gt;
17  #ifdef _WIN32
18  #ifndef NOMINMAX
19  #define NOMINMAX
20  #endif
21  #endif
22  #include &lt;boost/stacktrace.hpp&gt;
23  #include &lt;boost/unordered_map.hpp&gt;
24  #include &lt;boost/unordered_set.hpp&gt;
25  #include &lt;numeric&gt;
26  #include &lt;sstream&gt;
27  #include &lt;argon2.h&gt;
28  namespace
29  {
30  class uint64_from_hex 
31  {
32  public:
33  	uint64_t value;
34  };
35  std::istream &amp; operator&gt;&gt; (std::istream &amp; in, uint64_from_hex &amp; out_val);
36  class address_library_pair
37  {
38  public:
39  	uint64_t address;
40  	std::string library;
41  	address_library_pair (uint64_t address, std::string library);
42  	bool operator&lt; (const address_library_pair &amp; other) const;
43  	bool operator== (const address_library_pair &amp; other) const;
44  };
45  }
46  int main (int argc, char * const * argv)
47  {
48  	nano::set_umask ();
49  	nano::node_singleton_memory_pool_purge_guard memory_pool_cleanup_guard;
50  	boost::program_options::options_description description (&quot;Command line options&quot;);
51  	description.add_options ()
52  		(&quot;help&quot;, &quot;Print out options&quot;)
53  		(&quot;version&quot;, &quot;Prints out version&quot;)
54  		(&quot;config&quot;, boost::program_options::value&lt;std::vector&lt;nano::config_key_value_pair&gt;&gt;()-&gt;multitoken(), &quot;Pass node configuration values. This takes precedence over any values in the configuration file. This option can be repeated multiple times.&quot;)
55  		(&quot;rpcconfig&quot;, boost::program_options::value&lt;std::vector&lt;nano::config_key_value_pair&gt;&gt;()-&gt;multitoken(), &quot;Pass rpc configuration values. This takes precedence over any values in the configuration file. This option can be repeated multiple times.&quot;)
56  		(&quot;daemon&quot;, &quot;Start node daemon&quot;)
57  		(&quot;compare_rep_weights&quot;, &quot;Display a summarized comparison between the hardcoded bootstrap weights and representative weights from the ledger. Full comparison is output to logs&quot;)
58  		(&quot;debug_block_dump&quot;, &quot;Display all the blocks in the ledger in text format&quot;)
59  		(&quot;debug_block_count&quot;, &quot;Display the number of blocks&quot;)
60  		(&quot;debug_bootstrap_generate&quot;, &quot;Generate bootstrap sequence of blocks&quot;)
61  		(&quot;debug_dump_frontier_unchecked_dependents&quot;, &quot;Dump frontiers which have matching unchecked keys&quot;)
62  		(&quot;debug_dump_trended_weight&quot;, &quot;Dump trended weights table&quot;)
63  		(&quot;debug_dump_representatives&quot;, &quot;List representatives and weights&quot;)
64  		(&quot;debug_account_count&quot;, &quot;Display the number of accounts&quot;)
65  		(&quot;debug_profile_generate&quot;, &quot;Profile work generation&quot;)
66  		(&quot;debug_profile_validate&quot;, &quot;Profile work validation&quot;)
67  		(&quot;debug_opencl&quot;, &quot;OpenCL work generation&quot;)
68  		(&quot;debug_profile_kdf&quot;, &quot;Profile kdf function&quot;)
69  		(&quot;debug_output_last_backtrace_dump&quot;, &quot;Displays the contents of the latest backtrace in the event of a nano_node crash&quot;)
70  		(&quot;debug_generate_crash_report&quot;, &quot;Consolidates the nano_node_backtrace.dump file. Requires addr2line installed on Linux&quot;)
71  		(&quot;debug_sys_logging&quot;, &quot;Test the system logger&quot;)
72  		(&quot;debug_verify_profile&quot;, &quot;Profile signature verification&quot;)
73  		(&quot;debug_verify_profile_batch&quot;, &quot;Profile batch signature verification&quot;)
74  		(&quot;debug_profile_bootstrap&quot;, &quot;Profile bootstrap style blocks processing (at least 10GB of free storage space required)&quot;)
75  		(&quot;debug_profile_sign&quot;, &quot;Profile signature generation&quot;)
76  		(&quot;debug_profile_process&quot;, &quot;Profile active blocks processing (only for nano_dev_network)&quot;)
77  		(&quot;debug_profile_votes&quot;, &quot;Profile votes processing (only for nano_dev_network)&quot;)
78  		(&quot;debug_profile_frontiers_confirmation&quot;, &quot;Profile frontiers confirmation speed (only for nano_dev_network)&quot;)
79  		(&quot;debug_random_feed&quot;, &quot;Generates output to RNG test suites&quot;)
80  		(&quot;debug_rpc&quot;, &quot;Read an RPC command from stdin and invoke it. Network operations will have no effect.&quot;)
81  		(&quot;debug_peers&quot;, &quot;Display peer IPv6:port connections&quot;)
82  		(&quot;debug_cemented_block_count&quot;, &quot;Displays the number of cemented (confirmed) blocks&quot;)
83  		(&quot;debug_stacktrace&quot;, &quot;Display an example stacktrace&quot;)
84  		(&quot;debug_account_versions&quot;, &quot;Display the total counts of each version for all accounts (including unpocketed)&quot;)
85  		(&quot;debug_unconfirmed_frontiers&quot;, &quot;Displays the account, height (sorted), frontier and cemented frontier for all accounts which are not fully confirmed&quot;)
86  		(&quot;validate_blocks,debug_validate_blocks&quot;, &quot;Check all blocks for correct hash, signature, work value&quot;)
87  		(&quot;debug_prune&quot;, &quot;Prune accounts up to last confirmed blocks (EXPERIMENTAL)&quot;)
88  		(&quot;platform&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines the &lt;platform&gt; for OpenCL commands&quot;)
89  		(&quot;device&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines &lt;device&gt; for OpenCL command&quot;)
90  		(&quot;threads&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines &lt;threads&gt; count for various commands&quot;)
91  		(&quot;difficulty&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines &lt;difficulty&gt; for OpenCL command, HEX&quot;)
92  		(&quot;multiplier&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines &lt;multiplier&gt; for work generation. Overrides &lt;difficulty&gt;&quot;)
93  		(&quot;count&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines &lt;count&gt; for various commands&quot;)
94  		(&quot;pow_sleep_interval&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines the amount to sleep inbetween each pow calculation attempt&quot;)
95  		(&quot;address_column&quot;, boost::program_options::value&lt;std::string&gt; (), &quot;Defines which column the addresses are located, 0 indexed (check --debug_output_last_backtrace_dump output)&quot;)
96  		(&quot;silent&quot;, &quot;Silent command execution&quot;);
97  	nano::add_node_options (description);
98  	nano::add_node_flag_options (description);
99  	boost::program_options::variables_map vm;
100  	try
101  	{
102  		boost::program_options::store (boost::program_options::parse_command_line (argc, argv, description), vm);
103  	}
104  	catch (boost::program_options::error const &amp; err)
105  	{
106  		std::cerr &lt;&lt; err.what () &lt;&lt; std::endl;
107  		return 1;
108  	}
109  	boost::program_options::notify (vm);
110  	int result (0);
111  	auto network (vm.find (&quot;network&quot;));
112  	if (network != vm.end ())
113  	{
114  		auto err (nano::network_constants::set_active_network (network-&gt;second.as&lt;std::string&gt; ()));
115  		if (err)
116  		{
117  			std::cerr &lt;&lt; nano::network_constants::active_network_err_msg &lt;&lt; std::endl;
118  			std::exit (1);
119  		}
120  	}
121  	nano::network_params network_params{ nano::network_constants::active_network };
122  	auto data_path_it = vm.find (&quot;data_path&quot;);
123  	boost::filesystem::path data_path ((data_path_it != vm.end ()) ? data_path_it-&gt;second.as&lt;std::string&gt; () : nano::working_path ());
124  	auto ec = nano::handle_node_options (vm);
125  	if (ec == nano::error_cli::unknown_command)
126  	{
127  		if (vm.count (&quot;daemon&quot;) &gt; 0)
128  		{
129  			nano_daemon::daemon daemon;
130  			nano::node_flags flags;
131  			auto flags_ec = nano::update_flags (flags, vm);
132  			if (flags_ec)
133  			{
134  				std::cerr &lt;&lt; flags_ec.message () &lt;&lt; std::endl;
135  				std::exit (1);
136  			}
137  			daemon.run (data_path, flags);
138  		}
139  		else if (vm.count (&quot;compare_rep_weights&quot;))
140  		{
141  			if (nano::network_constants::active_network != nano::networks::nano_dev_network)
142  			{
143  				auto node_flags = nano::inactive_node_flag_defaults ();
144  				nano::update_flags (node_flags, vm);
145  				node_flags.generate_cache.reps = true;
146  				nano::inactive_node inactive_node (data_path, node_flags);
147  				auto node = inactive_node.node;
148  				auto const bootstrap_weights = node-&gt;get_bootstrap_weights ();
149  				auto const &amp; hardcoded = bootstrap_weights.second;
150  				auto const hardcoded_height = bootstrap_weights.first;
151  				auto const ledger_unfiltered = node-&gt;ledger.cache.rep_weights.get_rep_amounts ();
152  				auto const ledger_height = node-&gt;ledger.cache.block_count.load ();
153  				auto get_total = [] (decltype (bootstrap_weights.second) const &amp; reps) -&gt; nano::uint128_union {
154  					return std::accumulate (reps.begin (), reps.end (), nano::uint128_t{ 0 }, [] (auto sum, auto const &amp; rep) { return sum + rep.second; });
155  				};
156  				std::remove_const_t&lt;decltype (ledger_unfiltered)&gt; ledger;
157  				{
158  					std::vector&lt;std::pair&lt;nano::account, nano::uint128_t&gt;&gt; sorted;
159  					sorted.reserve (ledger_unfiltered.size ());
160  					std::copy (ledger_unfiltered.begin (), ledger_unfiltered.end (), std::back_inserter (sorted));
161  					std::sort (sorted.begin (), sorted.end (), [] (auto const &amp; left, auto const &amp; right) { return left.second &gt; right.second; });
162  					auto const total_unfiltered = get_total (ledger_unfiltered);
163  					nano::uint128_t sum{ 0 };
164  					auto target = (total_unfiltered.number () / 100) * 99;
165  					for (auto i (sorted.begin ()), n (sorted.end ()); i != n &amp;&amp; sum &lt;= target; sum += i-&gt;second, ++i)
166  					{
167  						ledger.insert (*i);
168  					}
169  				}
170  				auto const total_ledger = get_total (ledger);
171  				auto const total_hardcoded = get_total (hardcoded);
172  				struct mismatched_t
173  				{
174  					nano::account rep;
175  					nano::uint128_union hardcoded;
176  					nano::uint128_union ledger;
177  					nano::uint128_union diff;
178  					std::string get_entry () const
179  					{
180  						return boost::str (boost::format (&quot;representative %1% hardcoded %2% ledger %3% mismatch %4%&quot;)
181  						% rep.to_account () % hardcoded.format_balance (nano::Mxrb_ratio, 0, true) % ledger.format_balance (nano::Mxrb_ratio, 0, true) % diff.format_balance (nano::Mxrb_ratio, 0, true));
182  					}
183  				};
184  				std::vector&lt;mismatched_t&gt; mismatched;
185  				mismatched.reserve (hardcoded.size ());
186  				std::transform (hardcoded.begin (), hardcoded.end (), std::back_inserter (mismatched), [&amp;ledger] (auto const &amp; rep) {
187  					auto ledger_rep (ledger.find (rep.first));
188  					nano::uint128_t ledger_weight = (ledger_rep == ledger.end () ? 0 : ledger_rep-&gt;second);
189  					auto absolute = ledger_weight &gt; rep.second ? ledger_weight - rep.second : rep.second - ledger_weight;
190  					return mismatched_t{ rep.first, rep.second, ledger_weight, absolute };
191  				});
192  				std::sort (mismatched.begin (), mismatched.end (), [] (mismatched_t const &amp; left, mismatched_t const &amp; right) { return left.diff &gt; right.diff; });
193  				nano::uint128_union const mismatch_total = std::accumulate (mismatched.begin (), mismatched.end (), nano::uint128_t{ 0 }, [] (auto sum, mismatched_t const &amp; sample) { return sum + sample.diff.number (); });
194  				nano::uint128_union const mismatch_mean = mismatch_total.number () / mismatched.size ();
195  				nano::uint512_union mismatch_variance = std::accumulate (mismatched.begin (), mismatched.end (), nano::uint512_t (0), [M = mismatch_mean.number (), N = mismatched.size ()] (nano::uint512_t sum, mismatched_t const &amp; sample) {
196  					auto x = sample.diff.number ();
197  					nano::uint512_t const mean_diff = x &gt; M ? x - M : M - x;
198  					nano::uint512_t const sqr = mean_diff * mean_diff;
199  					return sum + sqr;
200  				})
201  				/ mismatched.size ();
202  				nano::uint128_union const mismatch_stddev = nano::narrow_cast&lt;nano::uint128_t&gt; (boost::multiprecision::sqrt (mismatch_variance.number ()));
203  				auto const outlier_threshold = std::max (nano::Gxrb_ratio, mismatch_mean.number () + 1 * mismatch_stddev.number ());
204  				decltype (mismatched) outliers;
205  				std::copy_if (mismatched.begin (), mismatched.end (), std::back_inserter (outliers), [outlier_threshold] (mismatched_t const &amp; sample) {
206  					return sample.diff &gt; outlier_threshold;
207  				});
208  				auto const newcomer_threshold = std::max (nano::Gxrb_ratio, mismatch_mean.number ());
209  				std::vector&lt;std::pair&lt;nano::account, nano::uint128_t&gt;&gt; newcomers;
210  				std::copy_if (ledger.begin (), ledger.end (), std::back_inserter (newcomers), [&amp;hardcoded] (auto const &amp; rep) {
211  					return !hardcoded.count (rep.first) &amp;&amp; rep.second;
212  				});
213  				std::sort (newcomers.begin (), newcomers.end (), [] (auto const &amp; left, auto const &amp; right) { return left.second &gt; right.second; });
214  				auto newcomer_entry = [] (auto const &amp; rep) {
215  					return boost::str (boost::format (&quot;representative %1% hardcoded --- ledger %2%&quot;) % rep.first.to_account () % nano::uint128_union (rep.second).format_balance (nano::Mxrb_ratio, 0, true));
216  				};
217  				std::cout &lt;&lt; boost::str (boost::format (&quot;hardcoded weight %1% Mnano at %2% blocks\nledger weight %3% Mnano at %4% blocks\nmismatched\n\tsamples %5%\n\ttotal %6% Mnano\n\tmean %7% Mnano\n\tsigma %8% Mnano\n&quot;)
218  				% total_hardcoded.format_balance (nano::Mxrb_ratio, 0, true)
219  				% hardcoded_height
220  				% total_ledger.format_balance (nano::Mxrb_ratio, 0, true)
221  				% ledger_height
222  				% mismatched.size ()
223  				% mismatch_total.format_balance (nano::Mxrb_ratio, 0, true)
224  				% mismatch_mean.format_balance (nano::Mxrb_ratio, 0, true)
225  				% mismatch_stddev.format_balance (nano::Mxrb_ratio, 0, true));
226  				if (!outliers.empty ())
227  				{
228  					std::cout &lt;&lt; &quot;outliers\n&quot;;
229  					for (auto const &amp; outlier : outliers)
230  					{
231  						std::cout &lt;&lt; &#x27;\t&#x27; &lt;&lt; outlier.get_entry () &lt;&lt; &#x27;\n&#x27;;
232  					}
233  				}
234  				if (!newcomers.empty ())
235  				{
236  					std::cout &lt;&lt; &quot;newcomers\n&quot;;
237  					for (auto const &amp; newcomer : newcomers)
238  					{
239  						if (newcomer.second &gt; newcomer_threshold)
240  						{
241  							std::cout &lt;&lt; &#x27;\t&#x27; &lt;&lt; newcomer_entry (newcomer) &lt;&lt; &#x27;\n&#x27;;
242  						}
243  					}
244  				}
245  				auto const log_threshold = nano::Gxrb_ratio;
246  				for (auto const &amp; sample : mismatched)
247  				{
248  					if (sample.diff &gt; log_threshold)
249  					{
250  						node-&gt;logger.always_log (sample.get_entry ());
251  					}
252  				}
253  				for (auto const &amp; newcomer : newcomers)
254  				{
255  					if (newcomer.second &gt; log_threshold)
256  					{
257  						node-&gt;logger.always_log (newcomer_entry (newcomer));
258  					}
259  				}
260  			}
261  			else
262  			{
263  				std::cout &lt;&lt; &quot;Not available for the test network&quot; &lt;&lt; std::endl;
264  				result = -1;
265  			}
266  		}
267  		else if (vm.count (&quot;debug_block_dump&quot;))
268  		{
269  			auto inactive_node = nano::default_inactive_node (data_path, vm);
270  			auto transaction = inactive_node-&gt;node-&gt;store.tx_begin_read ();
271  			auto i = inactive_node-&gt;node-&gt;store.block.begin (transaction);
272  			auto end = inactive_node-&gt;node-&gt;store.block.end ();
273  			for (; i != end; ++i)
274  			{
275  				nano::block_hash hash = i-&gt;first;
276  				nano::block_w_sideband sideband = i-&gt;second;
277  				std::shared_ptr&lt;nano::block&gt; b = sideband.block;
278  				std::cout &lt;&lt; hash.to_string () &lt;&lt; std::endl
279  						  &lt;&lt; b-&gt;to_json ();
280  			}
281  		}
282  		else if (vm.count (&quot;debug_block_count&quot;))
283  		{
284  			auto node_flags = nano::inactive_node_flag_defaults ();
285  			nano::update_flags (node_flags, vm);
286  			node_flags.generate_cache.block_count = true;
287  			nano::inactive_node inactive_node (data_path, node_flags);
288  			auto node = inactive_node.node;
289  			std::cout &lt;&lt; boost::str (boost::format (&quot;Block count: %1%\n&quot;) % node-&gt;ledger.cache.block_count);
290  		}
291  		else if (vm.count (&quot;debug_bootstrap_generate&quot;))
292  		{
293  			auto key_it = vm.find (&quot;key&quot;);
294  			if (key_it != vm.end ())
295  			{
296  				nano::uint256_union key;
297  				if (!key.decode_hex (key_it-&gt;second.as&lt;std::string&gt; ()))
298  				{
299  					nano::keypair genesis (key.to_string ());
300  					nano::work_pool work{ network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
301  					std::cout &lt;&lt; &quot;Genesis: &quot; &lt;&lt; genesis.prv.to_string () &lt;&lt; &quot;\n&quot;
302  							  &lt;&lt; &quot;Public: &quot; &lt;&lt; genesis.pub.to_string () &lt;&lt; &quot;\n&quot;
303  							  &lt;&lt; &quot;Account: &quot; &lt;&lt; genesis.pub.to_account () &lt;&lt; &quot;\n&quot;;
304  					nano::keypair landing;
305  					std::cout &lt;&lt; &quot;Landing: &quot; &lt;&lt; landing.prv.to_string () &lt;&lt; &quot;\n&quot;
306  							  &lt;&lt; &quot;Public: &quot; &lt;&lt; landing.pub.to_string () &lt;&lt; &quot;\n&quot;
307  							  &lt;&lt; &quot;Account: &quot; &lt;&lt; landing.pub.to_account () &lt;&lt; &quot;\n&quot;;
308  					for (auto i (0); i != 32; ++i)
309  					{
310  						nano::keypair rep;
311  						std::cout &lt;&lt; &quot;Rep&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rep.prv.to_string () &lt;&lt; &quot;\n&quot;
312  								  &lt;&lt; &quot;Public: &quot; &lt;&lt; rep.pub.to_string () &lt;&lt; &quot;\n&quot;
313  								  &lt;&lt; &quot;Account: &quot; &lt;&lt; rep.pub.to_account () &lt;&lt; &quot;\n&quot;;
314  					}
315  					nano::uint128_t balance (std::numeric_limits&lt;nano::uint128_t&gt;::max ());
316  					nano::open_block genesis_block (reinterpret_cast&lt;nano::block_hash const &amp;&gt; (genesis.pub), genesis.pub, genesis.pub, genesis.prv, genesis.pub, *work.generate (nano::work_version::work_1, genesis.pub, network_params.work.epoch_1));
317  					std::cout &lt;&lt; genesis_block.to_json ();
318  					std::cout.flush ();
319  					nano::block_hash previous (genesis_block.hash ());
320  					for (auto i (0); i != 8; ++i)
321  					{
322  						nano::uint128_t yearly_distribution (nano::uint128_t (1) &lt;&lt; (127 - (i == 7 ? 6 : i)));
323  						auto weekly_distribution (yearly_distribution / 52);
324  						for (auto j (0); j != 52; ++j)
325  						{
326  							debug_assert (balance &gt; weekly_distribution);
327  							balance = balance &lt; (weekly_distribution * 2) ? 0 : balance - weekly_distribution;
328  							nano::send_block send (previous, landing.pub, balance, genesis.prv, genesis.pub, *work.generate (nano::work_version::work_1, previous, network_params.work.epoch_1));
329  							previous = send.hash ();
330  							std::cout &lt;&lt; send.to_json ();
331  							std::cout.flush ();
332  						}
333  					}
334  				}
335  				else
336  				{
337  					std::cerr &lt;&lt; &quot;Invalid key\n&quot;;
338  					result = -1;
339  				}
340  			}
341  			else
342  			{
343  				std::cerr &lt;&lt; &quot;Bootstrapping requires one &lt;key&gt; option\n&quot;;
344  				result = -1;
345  			}
346  		}
347  		else if (vm.count (&quot;debug_dump_trended_weight&quot;))
348  		{
349  			auto inactive_node = nano::default_inactive_node (data_path, vm);
350  			auto node = inactive_node-&gt;node;
351  			auto current (node-&gt;online_reps.trended ());
352  			std::cout &lt;&lt; boost::str (boost::format (&quot;Trended Weight %1%\n&quot;) % current);
353  			auto transaction (node-&gt;store.tx_begin_read ());
354  			for (auto i (node-&gt;store.online_weight.begin (transaction)), n (node-&gt;store.online_weight.end ()); i != n; ++i)
355  			{
356  				using time_point = std::chrono::system_clock::time_point;
357  				time_point ts (std::chrono::duration_cast&lt;time_point::duration&gt; (std::chrono::nanoseconds (i-&gt;first)));
358  				std::time_t timestamp = std::chrono::system_clock::to_time_t (ts);
359  				std::string weight;
360  				i-&gt;second.encode_dec (weight);
361  				std::cout &lt;&lt; boost::str (boost::format (&quot;Timestamp %1% Weight %2%\n&quot;) % ctime (&amp;timestamp) % weight);
362  			}
363  		}
364  		else if (vm.count (&quot;debug_dump_representatives&quot;))
365  		{
366  			auto node_flags = nano::inactive_node_flag_defaults ();
367  			nano::update_flags (node_flags, vm);
368  			node_flags.generate_cache.reps = true;
369  			nano::inactive_node inactive_node (data_path, node_flags);
370  			auto node = inactive_node.node;
371  			auto transaction (node-&gt;store.tx_begin_read ());
372  			nano::uint128_t total;
373  			auto rep_amounts = node-&gt;ledger.cache.rep_weights.get_rep_amounts ();
374  			std::map&lt;nano::account, nano::uint128_t&gt; ordered_reps (rep_amounts.begin (), rep_amounts.end ());
375  			for (auto const &amp; rep : ordered_reps)
376  			{
377  				total += rep.second;
378  				std::cout &lt;&lt; boost::str (boost::format (&quot;%1% %2% %3%\n&quot;) % rep.first.to_account () % rep.second.convert_to&lt;std::string&gt; () % total.convert_to&lt;std::string&gt; ());
379  			}
380  		}
381  		else if (vm.count (&quot;debug_dump_frontier_unchecked_dependents&quot;))
382  		{
383  			auto inactive_node = nano::default_inactive_node (data_path, vm);
384  			auto node = inactive_node-&gt;node;
385  			std::cout &lt;&lt; &quot;Outputting any frontier hashes which have associated key hashes in the unchecked table (may take some time)...\n&quot;;
386  			auto transaction (node-&gt;store.tx_begin_read ());
387  			std::unordered_set&lt;nano::block_hash&gt; frontier_hashes;
388  			for (auto i (node-&gt;store.account.begin (transaction)), n (node-&gt;store.account.end ()); i != n; ++i)
389  			{
390  				frontier_hashes.insert (i-&gt;second.head);
391  			}
392  			node-&gt;unchecked.for_each ([&amp;frontier_hashes] (nano::unchecked_key const &amp; key, nano::unchecked_info const &amp; info) {
393  				auto it = frontier_hashes.find (key.key ());
394  				if (it != frontier_hashes.cend ())
395  				{
396  					std::cout &lt;&lt; it-&gt;to_string () &lt;&lt; &quot;\n&quot;;
397  				}
398  			});
399  		}
400  		else if (vm.count (&quot;debug_account_count&quot;))
401  		{
402  			auto node_flags = nano::inactive_node_flag_defaults ();
403  			nano::update_flags (node_flags, vm);
404  			node_flags.generate_cache.account_count = true;
405  			nano::inactive_node inactive_node (data_path, node_flags);
406  			std::cout &lt;&lt; boost::str (boost::format (&quot;Frontier count: %1%\n&quot;) % inactive_node.node-&gt;ledger.cache.account_count);
407  		}
408  		else if (vm.count (&quot;debug_profile_kdf&quot;))
409  		{
410  			auto inactive_node = nano::default_inactive_node (data_path, vm);
411  			nano::uint256_union result;
412  			nano::uint256_union salt (0);
413  			std::string password (&quot;&quot;);
414  			while (true)
415  			{
416  				auto begin1 (std::chrono::high_resolution_clock::now ());
417  				auto success (argon2_hash (1, inactive_node-&gt;node-&gt;network_params.kdf_work, 1, password.data (), password.size (), salt.bytes.data (), salt.bytes.size (), result.bytes.data (), result.bytes.size (), NULL, 0, Argon2_d, 0x10));
418  				(void)success;
419  				auto end1 (std::chrono::high_resolution_clock::now ());
420  				std::cerr &lt;&lt; boost::str (boost::format (&quot;Derivation time: %1%us\n&quot;) % std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end1 - begin1).count ());
421  			}
422  		}
423  		else if (vm.count (&quot;debug_profile_generate&quot;))
424  		{
425  			uint64_t difficulty{ nano::work_thresholds::publish_full.base };
426  			auto multiplier_it = vm.find (&quot;multiplier&quot;);
427  			if (multiplier_it != vm.end ())
428  			{
429  				try
430  				{
431  					auto multiplier (boost::lexical_cast&lt;double&gt; (multiplier_it-&gt;second.as&lt;std::string&gt; ()));
432  					difficulty = nano::difficulty::from_multiplier (multiplier, difficulty);
433  				}
434  				catch (boost::bad_lexical_cast &amp;)
435  				{
436  					std::cerr &lt;&lt; &quot;Invalid multiplier\n&quot;;
437  					return -1;
438  				}
439  			}
440  			else
441  			{
442  				auto difficulty_it = vm.find (&quot;difficulty&quot;);
443  				if (difficulty_it != vm.end ())
444  				{
445  					if (nano::from_string_hex (difficulty_it-&gt;second.as&lt;std::string&gt; (), difficulty))
446  					{
447  						std::cerr &lt;&lt; &quot;Invalid difficulty\n&quot;;
448  						return -1;
449  					}
450  				}
451  			}
452  			auto pow_rate_limiter = std::chrono::nanoseconds (0);
453  			auto pow_sleep_interval_it = vm.find (&quot;pow_sleep_interval&quot;);
454  			if (pow_sleep_interval_it != vm.cend ())
455  			{
456  				pow_rate_limiter = std::chrono::nanoseconds (boost::lexical_cast&lt;uint64_t&gt; (pow_sleep_interval_it-&gt;second.as&lt;std::string&gt; ()));
457  			}
458  			nano::work_pool work{ network_params.network, std::numeric_limits&lt;unsigned&gt;::max (), pow_rate_limiter };
459  			nano::change_block block (0, 0, nano::keypair ().prv, 0, 0);
460  			if (!result)
461  			{
462  				std::cerr &lt;&lt; boost::str (boost::format (&quot;Starting generation profiling. Difficulty: %1$#x (%2%x from base difficulty %3$#x)\n&quot;) % difficulty % nano::to_string (nano::difficulty::to_multiplier (difficulty, nano::work_thresholds::publish_full.base), 4) % nano::work_thresholds::publish_full.base);
463  				while (!result)
464  				{
465  					block.hashables.previous.qwords[0] += 1;
466  					auto begin1 (std::chrono::high_resolution_clock::now ());
467  					block.block_work_set (*work.generate (nano::work_version::work_1, block.root (), difficulty));
468  					auto end1 (std::chrono::high_resolution_clock::now ());
469  					std::cerr &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d|\n&quot;) % std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end1 - begin1).count ());
470  				}
471  			}
472  		}
473  		else if (vm.count (&quot;debug_profile_validate&quot;))
474  		{
475  			uint64_t difficulty{ nano::work_thresholds::publish_full.base };
476  			std::cerr &lt;&lt; &quot;Starting validation profile&quot; &lt;&lt; std::endl;
477  			auto start (std::chrono::steady_clock::now ());
478  			bool valid{ false };
479  			nano::block_hash hash{ 0 };
480  			uint64_t count{ 10000000U }; 
481  			for (uint64_t i (0); i &lt; count; ++i)
482  			{
483  				valid = network_params.work.value (hash, i) &gt; difficulty;
484  			}
485  			std::ostringstream oss (valid ? &quot;true&quot; : &quot;false&quot;); 
486  			auto total_time (std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt; (std::chrono::steady_clock::now () - start).count ());
487  			uint64_t average (total_time / count);
488  			std::cout &lt;&lt; &quot;Average validation time: &quot; &lt;&lt; std::to_string (average) &lt;&lt; &quot; ns (&quot; &lt;&lt; std::to_string (static_cast&lt;unsigned&gt; (count * 1e9 / total_time)) &lt;&lt; &quot; validations/s)&quot; &lt;&lt; std::endl;
489  		}
490  		else if (vm.count (&quot;debug_opencl&quot;))
491  		{
492  			bool error (false);
493  			nano::opencl_environment environment (error);
494  			if (!error)
495  			{
496  				unsigned short platform (0);
497  				auto platform_it = vm.find (&quot;platform&quot;);
498  				if (platform_it != vm.end ())
499  				{
500  					try
501  					{
502  						platform = boost::lexical_cast&lt;unsigned short&gt; (platform_it-&gt;second.as&lt;std::string&gt; ());
503  					}
504  					catch (boost::bad_lexical_cast &amp;)
505  					{
506  						std::cerr &lt;&lt; &quot;Invalid platform id\n&quot;;
507  						return -1;
508  					}
509  				}
510  				unsigned short device (0);
511  				auto device_it = vm.find (&quot;device&quot;);
512  				if (device_it != vm.end ())
513  				{
514  					try
515  					{
516  						device = boost::lexical_cast&lt;unsigned short&gt; (device_it-&gt;second.as&lt;std::string&gt; ());
517  					}
518  					catch (boost::bad_lexical_cast &amp;)
519  					{
520  						std::cerr &lt;&lt; &quot;Invalid device id\n&quot;;
521  						return -1;
522  					}
523  				}
524  				unsigned threads (1024 * 1024);
525  				auto threads_it = vm.find (&quot;threads&quot;);
526  				if (threads_it != vm.end ())
527  				{
528  					try
529  					{
530  						threads = boost::lexical_cast&lt;unsigned&gt; (threads_it-&gt;second.as&lt;std::string&gt; ());
531  					}
532  					catch (boost::bad_lexical_cast &amp;)
533  					{
534  						std::cerr &lt;&lt; &quot;Invalid threads count\n&quot;;
535  						return -1;
536  					}
537  				}
538  				uint64_t difficulty (nano::work_thresholds::publish_full.base);
539  				auto multiplier_it = vm.find (&quot;multiplier&quot;);
540  				if (multiplier_it != vm.end ())
541  				{
542  					try
543  					{
544  						auto multiplier (boost::lexical_cast&lt;double&gt; (multiplier_it-&gt;second.as&lt;std::string&gt; ()));
545  						difficulty = nano::difficulty::from_multiplier (multiplier, difficulty);
546  					}
547  					catch (boost::bad_lexical_cast &amp;)
548  					{
549  						std::cerr &lt;&lt; &quot;Invalid multiplier\n&quot;;
550  						return -1;
551  					}
552  				}
553  				else
554  				{
555  					auto difficulty_it = vm.find (&quot;difficulty&quot;);
556  					if (difficulty_it != vm.end ())
557  					{
558  						if (nano::from_string_hex (difficulty_it-&gt;second.as&lt;std::string&gt; (), difficulty))
559  						{
560  							std::cerr &lt;&lt; &quot;Invalid difficulty\n&quot;;
561  							return -1;
562  						}
563  					}
564  				}
565  				if (!result)
566  				{
567  					error |= platform &gt;= environment.platforms.size ();
568  					if (!error)
569  					{
570  						error |= device &gt;= environment.platforms[platform].devices.size ();
571  						if (!error)
572  						{
573  							nano::logger_mt logger;
574  							nano::opencl_config config (platform, device, threads);
575  							auto opencl (nano::opencl_work::create (true, config, logger, network_params.work));
576  							nano::work_pool work_pool{ network_params.network, 0, std::chrono::nanoseconds (0), opencl ? [&amp;opencl] (nano::work_version const version_a, nano::root const &amp; root_a, uint64_t difficulty_a, std::atomic&lt;int&gt; &amp;) {
577  														  return opencl-&gt;generate_work (version_a, root_a, difficulty_a);
578  													  }
579  																													   : std::function&lt;boost::optional&lt;uint64_t&gt; (nano::work_version const, nano::root const &amp;, uint64_t, std::atomic&lt;int&gt; &amp;)&gt; (nullptr) };
580  							nano::change_block block (0, 0, nano::keypair ().prv, 0, 0);
581  							std::cerr &lt;&lt; boost::str (boost::format (&quot;Starting OpenCL generation profiling. Platform: %1%. Device: %2%. Threads: %3%. Difficulty: %4$#x (%5%x from base difficulty %6$#x)\n&quot;) % platform % device % threads % difficulty % nano::to_string (nano::difficulty::to_multiplier (difficulty, nano::work_thresholds::publish_full.base), 4) % nano::work_thresholds::publish_full.base);
582  							for (uint64_t i (0); true; ++i)
583  							{
584  								block.hashables.previous.qwords[0] += 1;
585  								auto begin1 (std::chrono::high_resolution_clock::now ());
586  								block.block_work_set (*work_pool.generate (nano::work_version::work_1, block.root (), difficulty));
587  								auto end1 (std::chrono::high_resolution_clock::now ());
588  								std::cerr &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d|\n&quot;) % std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end1 - begin1).count ());
589  							}
590  						}
591  						else
592  						{
593  							std::cout &lt;&lt; &quot;Not available device id\n&quot;
594  									  &lt;&lt; std::endl;
595  							result = -1;
596  						}
597  					}
598  					else
599  					{
600  						std::cout &lt;&lt; &quot;Not available platform id\n&quot;
601  								  &lt;&lt; std::endl;
602  						result = -1;
603  					}
604  				}
605  			}
606  			else
607  			{
608  				std::cout &lt;&lt; &quot;Error initializing OpenCL&quot; &lt;&lt; std::endl;
609  				result = -1;
610  			}
611  		}
612  		else if (vm.count (&quot;debug_output_last_backtrace_dump&quot;))
613  		{
614  			if (boost::filesystem::exists (&quot;nano_node_backtrace.dump&quot;))
615  			{
616  				std::ifstream ifs (&quot;nano_node_backtrace.dump&quot;);
617  				boost::stacktrace::stacktrace st = boost::stacktrace::stacktrace::from_dump (ifs);
618  				std::cout &lt;&lt; &quot;Latest crash backtrace:\n&quot;
619  						  &lt;&lt; st &lt;&lt; std::endl;
620  			}
621  		}
622  		else if (vm.count (&quot;debug_generate_crash_report&quot;))
623  		{
624  			if (boost::filesystem::exists (&quot;nano_node_backtrace.dump&quot;))
625  			{
626  				std::ifstream ifs (&quot;nano_node_backtrace.dump&quot;);
627  				boost::stacktrace::stacktrace st = boost::stacktrace::stacktrace::from_dump (ifs);
628  				std::string crash_report_filename = &quot;nano_node_crash_report.txt&quot;;
629  #if defined(_WIN32) || defined(__APPLE__)
630  				std::ofstream ofs (crash_report_filename);
631  				ofs &lt;&lt; st;
632  #else
<span onclick='openModal()' class='match'>633  				boost::system::error_code err;
634  				auto running_executable_filepath = boost::dll::program_location (err);
635  				if (!err)
</span>636  				{
637  					auto num = 0;
638  					auto format = boost::format (&quot;nano_node_crash_load_address_dump_%1%.txt&quot;);
639  					std::vector&lt;address_library_pair&gt; base_addresses;
640  					uint64_from_hex base_address;
641  					std::string line;
642  					if (boost::filesystem::exists (boost::str (format % num)))
643  					{
644  						std::getline (std::ifstream (boost::str (format % num)), line);
645  						if (boost::conversion::try_lexical_convert (line, base_address))
646  						{
647  							base_addresses.emplace_back (base_address.value, running_executable_filepath.string ());
648  						}
649  					}
650  					++num;
651  					while (boost::filesystem::exists (boost::str (format % num)))
652  					{
653  						std::ifstream ifs_dump_filename (boost::str (format % num));
654  						std::string dynamic_lib_path;
655  						std::getline (ifs_dump_filename, dynamic_lib_path);
656  						std::getline (ifs_dump_filename, line);
657  						if (boost::conversion::try_lexical_convert (line, base_address))
658  						{
659  							base_addresses.emplace_back (base_address.value, dynamic_lib_path);
660  						}
661  						++num;
662  					}
663  					std::sort (base_addresses.begin (), base_addresses.end ());
664  					auto address_column_it = vm.find (&quot;address_column&quot;);
665  					auto column = -1;
666  					if (address_column_it != vm.end ())
667  					{
668  						if (!boost::conversion::try_lexical_convert (address_column_it-&gt;second.as&lt;std::string&gt; (), column))
669  						{
670  							std::cerr &lt;&lt; &quot;Error: Invalid address column\n&quot;;
671  							result = -1;
672  						}
673  					}
674  					std::stringstream stacktrace_ss;
675  					stacktrace_ss &lt;&lt; st;
676  					std::vector&lt;uint64_t&gt; backtrace_addresses;
677  					while (std::getline (stacktrace_ss, line))
678  					{
679  						std::istringstream iss (line);
680  						std::vector&lt;std::string&gt; results (std::istream_iterator&lt;std::string&gt;{ iss }, std::istream_iterator&lt;std::string&gt; ());
681  						if (column != -1)
682  						{
683  							if (column &lt; results.size ())
684  							{
685  								uint64_from_hex address_hex;
686  								if (boost::conversion::try_lexical_convert (results[column], address_hex))
687  								{
688  									backtrace_addresses.push_back (address_hex.value);
689  								}
690  								else
691  								{
692  									std::cerr &lt;&lt; &quot;Error: Address column does not point to valid addresses\n&quot;;
693  									result = -1;
694  								}
695  							}
696  							else
697  							{
698  								std::cerr &lt;&lt; &quot;Error: Address column too high\n&quot;;
699  								result = -1;
700  							}
701  						}
702  						else
703  						{
704  							for (auto const &amp; text : results)
705  							{
706  								uint64_from_hex address_hex;
707  								if (boost::conversion::try_lexical_convert (text, address_hex))
708  								{
709  									backtrace_addresses.push_back (address_hex.value);
710  									break;
711  								}
712  							}
713  						}
714  					}
715  					boost::filesystem::remove (crash_report_filename);
716  					{
717  						std::ofstream ofs (crash_report_filename);
718  						nano::set_secure_perm_file (crash_report_filename);
719  					}
720  					std::vector&lt;int&gt; system_codes;
721  					auto run_addr2line = [&amp;backtrace_addresses, &amp;base_addresses, &amp;system_codes, &amp;crash_report_filename] (bool use_relative_addresses) {
722  						for (auto backtrace_address : backtrace_addresses)
723  						{
724  							for (auto base_address : boost::adaptors::reverse (base_addresses))
725  							{
726  								if (backtrace_address &gt; base_address.address)
727  								{
728  									auto address = use_relative_addresses ? backtrace_address - base_address.address : backtrace_address;
729  									std::stringstream ss;
730  									ss &lt;&lt; std::uppercase &lt;&lt; std::hex &lt;&lt; address;
731  									auto res = std::system (boost::str (boost::format (&quot;addr2line -fCi %1% -e %2% &gt;&gt; %3%&quot;) % ss.str () % base_address.library % crash_report_filename).c_str ());
732  									system_codes.push_back (res);
733  									break;
734  								}
735  							}
736  						}
737  					};
738  					run_addr2line (false);
739  					{
740  						std::ofstream ofs (crash_report_filename, std::ios_base::out | std::ios_base::app);
741  						ofs &lt;&lt; std::endl
742  							&lt;&lt; &quot;Using relative addresses:&quot; &lt;&lt; std::endl; 
743  					}
744  					run_addr2line (true);
745  					if (std::find (system_codes.begin (), system_codes.end (), 0) == system_codes.end ())
746  					{
747  						std::cerr &lt;&lt; &quot;Error: Check that addr2line is installed and that nano_node_crash_load_address_dump_*.txt files exist.&quot; &lt;&lt; std::endl;
748  						result = -1;
749  					}
750  				}
751  				else
752  				{
753  					std::cerr &lt;&lt; &quot;Error: Could not determine running executable path&quot; &lt;&lt; std::endl;
754  					result = -1;
755  				}
756  #endif
757  				if (result == 0)
758  				{
759  					std::cout &lt;&lt; (boost::format (&quot;%1% created&quot;) % crash_report_filename).str () &lt;&lt; std::endl;
760  				}
761  			}
762  			else
763  			{
764  				std::cerr &lt;&lt; &quot;Error: nano_node_backtrace.dump could not be found&quot;;
765  				result = -1;
766  			}
767  		}
768  		else if (vm.count (&quot;debug_verify_profile&quot;))
769  		{
770  			nano::keypair key;
771  			nano::uint256_union message;
772  			auto signature = nano::sign_message (key.prv, key.pub, message);
773  			auto begin (std::chrono::high_resolution_clock::now ());
774  			for (auto i (0u); i &lt; 1000; ++i)
775  			{
776  				nano::validate_message (key.pub, message, signature);
777  			}
778  			auto end (std::chrono::high_resolution_clock::now ());
779  			std::cerr &lt;&lt; &quot;Signature verifications &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end - begin).count () &lt;&lt; std::endl;
780  		}
781  		else if (vm.count (&quot;debug_verify_profile_batch&quot;))
782  		{
783  			nano::keypair key;
784  			size_t batch_count (1000);
785  			nano::uint256_union message;
786  			nano::uint512_union signature (nano::sign_message (key.prv, key.pub, message));
787  			std::vector&lt;unsigned char const *&gt; messages (batch_count, message.bytes.data ());
788  			std::vector&lt;size_t&gt; lengths (batch_count, sizeof (message));
789  			std::vector&lt;unsigned char const *&gt; pub_keys (batch_count, key.pub.bytes.data ());
790  			std::vector&lt;unsigned char const *&gt; signatures (batch_count, signature.bytes.data ());
791  			std::vector&lt;int&gt; verifications;
792  			verifications.resize (batch_count);
793  			auto begin (std::chrono::high_resolution_clock::now ());
794  			nano::validate_message_batch (messages.data (), lengths.data (), pub_keys.data (), signatures.data (), batch_count, verifications.data ());
795  			auto end (std::chrono::high_resolution_clock::now ());
796  			std::cerr &lt;&lt; &quot;Batch signature verifications &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end - begin).count () &lt;&lt; std::endl;
797  		}
798  		else if (vm.count (&quot;debug_profile_sign&quot;))
799  		{
800  			std::cerr &lt;&lt; &quot;Starting blocks signing profiling\n&quot;;
801  			while (true)
802  			{
803  				nano::keypair key;
804  				nano::block_builder builder;
805  				nano::block_hash latest (0);
806  				auto begin1 (std::chrono::high_resolution_clock::now ());
807  				for (uint64_t balance (0); balance &lt; 1000; ++balance)
808  				{
809  					auto send = builder
810  								.send ()
811  								.previous (latest)
812  								.destination (key.pub)
813  								.balance (balance)
814  								.sign (key.prv, key.pub)
815  								.work (0)
816  								.build ();
817  					latest = send-&gt;hash ();
818  				}
819  				auto end1 (std::chrono::high_resolution_clock::now ());
820  				std::cerr &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d|\n&quot;) % std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end1 - begin1).count ());
821  			}
822  		}
823  		else if (vm.count (&quot;debug_profile_process&quot;))
824  		{
825  			nano::block_builder builder;
826  			size_t num_accounts (100000);
827  			size_t num_iterations (5); 
828  			size_t max_blocks (2 * num_accounts * num_iterations + num_accounts * 2); 
829  			std::cout &lt;&lt; boost::str (boost::format (&quot;Starting pregenerating %1% blocks\n&quot;) % max_blocks);
830  			nano::node_flags node_flags;
831  			nano::update_flags (node_flags, vm);
832  			nano::inactive_node inactive_node (nano::unique_path (), data_path, node_flags);
833  			auto node = inactive_node.node;
834  			nano::block_hash genesis_latest (node-&gt;latest (nano::dev::genesis_key.pub));
835  			nano::uint128_t genesis_balance (std::numeric_limits&lt;nano::uint128_t&gt;::max ());
836  			std::vector&lt;nano::keypair&gt; keys (num_accounts);
837  			std::vector&lt;nano::root&gt; frontiers (num_accounts);
838  			std::vector&lt;nano::uint128_t&gt; balances (num_accounts, 1000000000);
839  			std::deque&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks;
840  			for (auto i (0); i != num_accounts; ++i)
841  			{
842  				genesis_balance = genesis_balance - 1000000000;
843  				auto send = builder.state ()
844  							.account (nano::dev::genesis_key.pub)
845  							.previous (genesis_latest)
846  							.representative (nano::dev::genesis_key.pub)
847  							.balance (genesis_balance)
848  							.link (keys[i].pub)
849  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
850  							.work (*node-&gt;work.generate (nano::work_version::work_1, genesis_latest, node-&gt;network_params.work.epoch_1))
851  							.build ();
852  				genesis_latest = send-&gt;hash ();
853  				blocks.push_back (std::move (send));
854  				auto open = builder.state ()
855  							.account (keys[i].pub)
856  							.previous (0)
857  							.representative (keys[i].pub)
858  							.balance (balances[i])
859  							.link (genesis_latest)
860  							.sign (keys[i].prv, keys[i].pub)
861  							.work (*node-&gt;work.generate (nano::work_version::work_1, keys[i].pub, node-&gt;network_params.work.epoch_1))
862  							.build ();
863  				frontiers[i] = open-&gt;hash ();
864  				blocks.push_back (std::move (open));
865  			}
866  			for (auto i (0); i != num_iterations; ++i)
867  			{
868  				for (auto j (0); j != num_accounts; ++j)
869  				{
870  					size_t other (num_accounts - j - 1);
871  					--balances[j];
872  					auto send = builder.state ()
873  								.account (keys[j].pub)
874  								.previous (frontiers[j].as_block_hash ())
875  								.representative (keys[j].pub)
876  								.balance (balances[j])
877  								.link (keys[other].pub)
878  								.sign (keys[j].prv, keys[j].pub)
879  								.work (*node-&gt;work.generate (nano::work_version::work_1, frontiers[j], node-&gt;network_params.work.epoch_1))
880  								.build ();
881  					frontiers[j] = send-&gt;hash ();
882  					blocks.push_back (std::move (send));
883  					++balances[other];
884  					auto receive = builder.state ()
885  								   .account (keys[other].pub)
886  								   .previous (frontiers[other].as_block_hash ())
887  								   .representative (keys[other].pub)
888  								   .balance (balances[other])
889  								   .link (frontiers[j].as_block_hash ())
890  								   .sign (keys[other].prv, keys[other].pub)
891  								   .work (*node-&gt;work.generate (nano::work_version::work_1, frontiers[other], node-&gt;network_params.work.epoch_1))
892  								   .build ();
893  					frontiers[other] = receive-&gt;hash ();
894  					blocks.push_back (std::move (receive));
895  				}
896  			}
897  			std::cout &lt;&lt; boost::str (boost::format (&quot;Starting processing %1% blocks\n&quot;) % max_blocks);
898  			auto begin (std::chrono::high_resolution_clock::now ());
899  			while (!blocks.empty ())
900  			{
901  				auto block (blocks.front ());
902  				node-&gt;process_active (block);
903  				blocks.pop_front ();
904  			}
905  			nano::timer&lt;std::chrono::seconds&gt; timer_l (nano::timer_state::started);
906  			while (node-&gt;ledger.cache.block_count != max_blocks + 1)
907  			{
908  				std::this_thread::sleep_for (std::chrono::milliseconds (10));
909  				if (timer_l.after_deadline (std::chrono::seconds (15)))
910  				{
911  					timer_l.restart ();
912  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% (%2%) blocks processed (unchecked), %3% remaining&quot;) % node-&gt;ledger.cache.block_count % node-&gt;unchecked.count () % node-&gt;block_processor.size ()) &lt;&lt; std::endl;
913  				}
914  			}
915  			node-&gt;block_processor.flush ();
916  			auto end (std::chrono::high_resolution_clock::now ());
917  			auto time (std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end - begin).count ());
918  			node-&gt;stop ();
919  			std::cout &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d| us \n%2% blocks per second\n&quot;) % time % (max_blocks * 1000000 / time));
920  			release_assert (node-&gt;ledger.cache.block_count == max_blocks + 1);
921  		}
922  		else if (vm.count (&quot;debug_profile_votes&quot;))
923  		{
924  			nano::block_builder builder;
925  			size_t num_elections (40000);
926  			size_t num_representatives (25);
927  			size_t max_votes (num_elections * num_representatives); 
928  			std::cerr &lt;&lt; boost::str (boost::format (&quot;Starting pregenerating %1% votes\n&quot;) % max_votes);
929  			nano::node_flags node_flags;
930  			nano::update_flags (node_flags, vm);
931  			nano::node_wrapper node_wrapper (nano::unique_path (), data_path, node_flags);
932  			auto node = node_wrapper.node;
933  			nano::block_hash genesis_latest (node-&gt;latest (nano::dev::genesis_key.pub));
934  			nano::uint128_t genesis_balance (std::numeric_limits&lt;nano::uint128_t&gt;::max ());
935  			std::vector&lt;nano::keypair&gt; keys (num_representatives);
936  			nano::uint128_t balance ((node-&gt;config.online_weight_minimum.number () / num_representatives) + 1);
937  			for (auto i (0); i != num_representatives; ++i)
938  			{
939  				auto transaction (node-&gt;store.tx_begin_write ());
940  				genesis_balance = genesis_balance - balance;
941  				auto send = builder.state ()
942  							.account (nano::dev::genesis_key.pub)
943  							.previous (genesis_latest)
944  							.representative (nano::dev::genesis_key.pub)
945  							.balance (genesis_balance)
946  							.link (keys[i].pub)
947  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
948  							.work (*node-&gt;work.generate (nano::work_version::work_1, genesis_latest, node-&gt;network_params.work.epoch_1))
949  							.build ();
950  				genesis_latest = send-&gt;hash ();
951  				node-&gt;ledger.process (transaction, *send);
952  				auto open = builder.state ()
953  							.account (keys[i].pub)
954  							.previous (0)
955  							.representative (keys[i].pub)
956  							.balance (balance)
957  							.link (genesis_latest)
958  							.sign (keys[i].prv, keys[i].pub)
959  							.work (*node-&gt;work.generate (nano::work_version::work_1, keys[i].pub, node-&gt;network_params.work.epoch_1))
960  							.build ();
961  				node-&gt;ledger.process (transaction, *open);
962  			}
963  			std::deque&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks;
964  			for (auto i (0); i != num_elections; ++i)
965  			{
966  				genesis_balance = genesis_balance - 1;
967  				nano::keypair destination;
968  				auto send = builder.state ()
969  							.account (nano::dev::genesis_key.pub)
970  							.previous (genesis_latest)
971  							.representative (nano::dev::genesis_key.pub)
972  							.balance (genesis_balance)
973  							.link (destination.pub)
974  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
975  							.work (*node-&gt;work.generate (nano::work_version::work_1, genesis_latest, node-&gt;network_params.work.epoch_1))
976  							.build ();
977  				genesis_latest = send-&gt;hash ();
978  				blocks.push_back (std::move (send));
979  			}
980  			std::deque&lt;std::shared_ptr&lt;nano::vote&gt;&gt; votes;
981  			for (auto j (0); j != num_representatives; ++j)
982  			{
983  				uint64_t sequence (1);
984  				for (auto &amp; i : blocks)
985  				{
986  					auto vote (std::make_shared&lt;nano::vote&gt; (keys[j].pub, keys[j].prv, sequence, 0, std::vector&lt;nano::block_hash&gt; (1, i-&gt;hash ())));
987  					votes.push_back (vote);
988  					sequence++;
989  				}
990  			}
991  			while (!blocks.empty ())
992  			{
993  				auto block (blocks.front ());
994  				node-&gt;process_active (block);
995  				blocks.pop_front ();
996  			}
997  			node-&gt;block_processor.flush ();
998  			std::cerr &lt;&lt; boost::str (boost::format (&quot;Starting processing %1% votes\n&quot;) % max_votes);
999  			auto begin (std::chrono::high_resolution_clock::now ());
1000  			while (!votes.empty ())
1001  			{
1002  				auto vote (votes.front ());
1003  				auto channel (std::make_shared&lt;nano::transport::inproc::channel&gt; (*node, *node));
1004  				node-&gt;vote_processor.vote (vote, channel);
1005  				votes.pop_front ();
1006  			}
1007  			while (!node-&gt;active.empty ())
1008  			{
1009  				std::this_thread::sleep_for (std::chrono::milliseconds (100));
1010  			}
1011  			auto end (std::chrono::high_resolution_clock::now ());
1012  			auto time (std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end - begin).count ());
1013  			node-&gt;stop ();
1014  			std::cerr &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d| us \n%2% votes per second\n&quot;) % time % (max_votes * 1000000 / time));
1015  		}
1016  		else if (vm.count (&quot;debug_profile_frontiers_confirmation&quot;))
1017  		{
1018  			nano::block_builder builder;
1019  			size_t count (32 * 1024);
1020  			auto count_it = vm.find (&quot;count&quot;);
1021  			if (count_it != vm.end ())
1022  			{
1023  				try
1024  				{
1025  					count = boost::lexical_cast&lt;size_t&gt; (count_it-&gt;second.as&lt;std::string&gt; ());
1026  				}
1027  				catch (boost::bad_lexical_cast &amp;)
1028  				{
1029  					std::cerr &lt;&lt; &quot;Invalid count\n&quot;;
1030  					return -1;
1031  				}
1032  			}
1033  			std::cout &lt;&lt; boost::str (boost::format (&quot;Starting generating %1% blocks...\n&quot;) % (count * 2));
1034  			boost::asio::io_context io_ctx1;
1035  			boost::asio::io_context io_ctx2;
1036  			nano::work_pool work{ network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1037  			nano::logging logging;
1038  			auto path1 (nano::unique_path ());
1039  			auto path2 (nano::unique_path ());
1040  			logging.init (path1);
1041  			std::vector&lt;std::string&gt; config_overrides;
1042  			auto config (vm.find (&quot;config&quot;));
1043  			if (config != vm.end ())
1044  			{
1045  				config_overrides = nano::config_overrides (config-&gt;second.as&lt;std::vector&lt;nano::config_key_value_pair&gt;&gt; ());
1046  			}
1047  			nano::daemon_config daemon_config{ data_path, network_params };
1048  			auto error = nano::read_node_config_toml (data_path, daemon_config, config_overrides);
1049  			nano::node_config config1 = daemon_config.node;
1050  			config1.peering_port = 24000;
1051  			nano::node_flags flags;
1052  			nano::update_flags (flags, vm);
1053  			flags.disable_lazy_bootstrap = true;
1054  			flags.disable_legacy_bootstrap = true;
1055  			flags.disable_wallet_bootstrap = true;
1056  			flags.disable_bootstrap_listener = true;
1057  			auto node1 (std::make_shared&lt;nano::node&gt; (io_ctx1, path1, config1, work, flags, 0));
1058  			nano::block_hash genesis_latest (node1-&gt;latest (nano::dev::genesis_key.pub));
1059  			nano::uint128_t genesis_balance (std::numeric_limits&lt;nano::uint128_t&gt;::max ());
1060  			std::deque&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks;
1061  			for (auto i (0); i != count; ++i)
1062  			{
1063  				nano::keypair key;
1064  				genesis_balance = genesis_balance - 1;
1065  				auto send = builder.state ()
1066  							.account (nano::dev::genesis_key.pub)
1067  							.previous (genesis_latest)
1068  							.representative (nano::dev::genesis_key.pub)
1069  							.balance (genesis_balance)
1070  							.link (key.pub)
1071  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1072  							.work (*work.generate (nano::work_version::work_1, genesis_latest, nano::dev::network_params.work.epoch_1))
1073  							.build ();
1074  				genesis_latest = send-&gt;hash ();
1075  				auto open = builder.state ()
1076  							.account (key.pub)
1077  							.previous (0)
1078  							.representative (key.pub)
1079  							.balance (1)
1080  							.link (genesis_latest)
1081  							.sign (key.prv, key.pub)
1082  							.work (*work.generate (nano::work_version::work_1, key.pub, nano::dev::network_params.work.epoch_1))
1083  							.build ();
1084  				blocks.push_back (std::move (send));
1085  				blocks.push_back (std::move (open));
1086  				if (i % 20000 == 0 &amp;&amp; i != 0)
1087  				{
1088  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% blocks generated\n&quot;) % (i * 2));
1089  				}
1090  			}
1091  			node1-&gt;start ();
1092  			nano::thread_runner runner1 (io_ctx1, node1-&gt;config.io_threads);
1093  			std::cout &lt;&lt; boost::str (boost::format (&quot;Processing %1% blocks\n&quot;) % (count * 2));
1094  			for (auto &amp; block : blocks)
1095  			{
1096  				node1-&gt;block_processor.add (block);
1097  			}
1098  			node1-&gt;block_processor.flush ();
1099  			auto iteration (0);
1100  			while (node1-&gt;ledger.cache.block_count != count * 2 + 1)
1101  			{
1102  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1103  				if (++iteration % 60 == 0)
1104  				{
1105  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% blocks processed\n&quot;) % node1-&gt;ledger.cache.block_count);
1106  				}
1107  			}
1108  			for (auto &amp; block : blocks)
1109  			{
1110  				node1-&gt;confirmation_height_processor.add (block);
1111  			}
1112  			while (node1-&gt;ledger.cache.cemented_count != node1-&gt;ledger.cache.block_count)
1113  			{
1114  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1115  				if (++iteration % 60 == 0)
1116  				{
1117  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% blocks cemented\n&quot;) % node1-&gt;ledger.cache.cemented_count);
1118  				}
1119  			}
1120  			nano::node_config config2 = daemon_config.node;
1121  			config1.peering_port = 24001;
1122  			if (error)
1123  			{
1124  				std::cerr &lt;&lt; &quot;\n&quot;
1125  						  &lt;&lt; error.get_message () &lt;&lt; std::endl;
1126  				std::exit (1);
1127  			}
1128  			else
1129  			{
1130  				config2.frontiers_confirmation = daemon_config.node.frontiers_confirmation;
1131  				config2.active_elections_size = daemon_config.node.active_elections_size;
1132  			}
1133  			auto node2 (std::make_shared&lt;nano::node&gt; (io_ctx2, path2, config2, work, flags, 1));
1134  			node2-&gt;start ();
1135  			nano::thread_runner runner2 (io_ctx2, node2-&gt;config.io_threads);
1136  			std::cout &lt;&lt; boost::str (boost::format (&quot;Processing %1% blocks (test node)\n&quot;) % (count * 2));
1137  			while (!blocks.empty ())
1138  			{
1139  				auto block (blocks.front ());
1140  				node2-&gt;block_processor.add (block);
1141  				blocks.pop_front ();
1142  			}
1143  			node2-&gt;block_processor.flush ();
1144  			while (node2-&gt;ledger.cache.block_count != count * 2 + 1)
1145  			{
1146  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1147  				if (++iteration % 60 == 0)
1148  				{
1149  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% blocks processed\n&quot;) % node2-&gt;ledger.cache.block_count);
1150  				}
1151  			}
1152  			std::cout &lt;&lt; &quot;Initializing representative\n&quot;;
1153  			auto wallet (node1-&gt;wallets.create (nano::random_wallet_id ()));
1154  			wallet-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1155  			node2-&gt;network.merge_peer (node1-&gt;network.endpoint ());
1156  			while (node2-&gt;rep_crawler.representative_count () == 0)
1157  			{
1158  				std::this_thread::sleep_for (std::chrono::milliseconds (10));
1159  				if (++iteration % 500 == 0)
1160  				{
1161  					std::cout &lt;&lt; &quot;Representative initialization iteration...\n&quot;;
1162  				}
1163  			}
1164  			auto begin (std::chrono::high_resolution_clock::now ());
1165  			std::cout &lt;&lt; boost::str (boost::format (&quot;Starting confirming %1% frontiers (test node)\n&quot;) % (count + 1));
1166  			while (node2-&gt;ledger.cache.cemented_count != node2-&gt;ledger.cache.block_count)
1167  			{
1168  				std::this_thread::sleep_for (std::chrono::milliseconds (25));
1169  				if (++iteration % 1200 == 0)
1170  				{
1171  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% blocks confirmed\n&quot;) % node2-&gt;ledger.cache.cemented_count);
1172  				}
1173  			}
1174  			auto end (std::chrono::high_resolution_clock::now ());
1175  			auto time (std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end - begin).count ());
1176  			std::cout &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d| us \n%2% frontiers per second\n&quot;) % time % ((count + 1) * 1000000 / time));
1177  			io_ctx1.stop ();
1178  			io_ctx2.stop ();
1179  			runner1.join ();
1180  			runner2.join ();
1181  			node1-&gt;stop ();
1182  			node2-&gt;stop ();
1183  		}
1184  		else if (vm.count (&quot;debug_random_feed&quot;))
1185  		{
1186  			nano::raw_key seed;
1187  			for (;;)
1188  			{
1189  				nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
1190  				std::cout.write (reinterpret_cast&lt;char const *&gt; (seed.bytes.data ()), seed.bytes.size ());
1191  			}
1192  		}
1193  		else if (vm.count (&quot;debug_rpc&quot;))
1194  		{
1195  			std::string rpc_input_l;
1196  			std::ostringstream command_l;
1197  			while (std::cin &gt;&gt; rpc_input_l)
1198  			{
1199  				command_l &lt;&lt; rpc_input_l;
1200  			}
1201  			auto response_handler_l ([] (std::string const &amp; response_a) {
1202  				std::cout &lt;&lt; response_a;
1203  				std::exit (0);
1204  			});
1205  			auto node_flags = nano::inactive_node_flag_defaults ();
1206  			nano::update_flags (node_flags, vm);
1207  			node_flags.generate_cache.enable_all ();
1208  			nano::inactive_node inactive_node_l (data_path, node_flags);
1209  			nano::node_rpc_config config;
1210  			nano::ipc::ipc_server server (*inactive_node_l.node, config);
1211  			auto handler_l (std::make_shared&lt;nano::json_handler&gt; (*inactive_node_l.node, config, command_l.str (), response_handler_l));
1212  			handler_l-&gt;process_request ();
1213  		}
1214  		else if (vm.count (&quot;validate_blocks&quot;) || vm.count (&quot;debug_validate_blocks&quot;))
1215  		{
1216  			nano::timer&lt;std::chrono::seconds&gt; timer;
1217  			timer.start ();
1218  			auto node_flags = nano::inactive_node_flag_defaults ();
1219  			nano::update_flags (node_flags, vm);
1220  			node_flags.generate_cache.block_count = true;
1221  			nano::inactive_node inactive_node (data_path, node_flags);
1222  			auto node = inactive_node.node;
1223  			bool const silent (vm.count (&quot;silent&quot;));
1224  			unsigned threads_count (1);
1225  			auto threads_it = vm.find (&quot;threads&quot;);
1226  			if (threads_it != vm.end ())
1227  			{
1228  				if (!boost::conversion::try_lexical_convert (threads_it-&gt;second.as&lt;std::string&gt; (), threads_count))
1229  				{
1230  					std::cerr &lt;&lt; &quot;Invalid threads count\n&quot;;
1231  					return -1;
1232  				}
1233  			}
1234  			threads_count = std::max (1u, threads_count);
1235  			std::vector&lt;std::thread&gt; threads;
1236  			nano::mutex mutex;
1237  			nano::condition_variable condition;
1238  			std::atomic&lt;bool&gt; finished (false);
1239  			std::deque&lt;std::pair&lt;nano::account, nano::account_info&gt;&gt; accounts;
1240  			std::atomic&lt;size_t&gt; count (0);
1241  			std::atomic&lt;uint64_t&gt; block_count (0);
1242  			std::atomic&lt;uint64_t&gt; errors (0);
1243  			auto print_error_message = [&amp;silent, &amp;errors] (std::string const &amp; error_message_a) {
1244  				if (!silent)
1245  				{
1246  					static nano::mutex cerr_mutex;
1247  					nano::lock_guard&lt;nano::mutex&gt; lock{ cerr_mutex };
1248  					std::cerr &lt;&lt; error_message_a;
1249  				}
1250  				++errors;
1251  			};
1252  			auto start_threads = [node, &amp;threads_count, &amp;threads, &amp;mutex, &amp;condition, &amp;finished] (auto const &amp; function_a, auto &amp; deque_a) {
1253  				for (auto i (0U); i &lt; threads_count; ++i)
1254  				{
1255  					threads.emplace_back ([&amp;function_a, node, &amp;mutex, &amp;condition, &amp;finished, &amp;deque_a] () {
1256  						auto transaction (node-&gt;store.tx_begin_read ());
1257  						nano::unique_lock&lt;nano::mutex&gt; lock{ mutex };
1258  						while (!deque_a.empty () || !finished)
1259  						{
1260  							while (deque_a.empty () &amp;&amp; !finished)
1261  							{
1262  								condition.wait (lock);
1263  							}
1264  							if (!deque_a.empty ())
1265  							{
1266  								auto pair (deque_a.front ());
1267  								deque_a.pop_front ();
1268  								lock.unlock ();
1269  								function_a (node, transaction, pair.first, pair.second);
1270  								lock.lock ();
1271  							}
1272  						}
1273  					});
1274  				}
1275  			};
1276  			auto check_account = [&amp;print_error_message, &amp;silent, &amp;count, &amp;block_count] (std::shared_ptr&lt;nano::node&gt; const &amp; node, nano::read_transaction const &amp; transaction, nano::account const &amp; account, nano::account_info const &amp; info) {
1277  				++count;
1278  				if (!silent &amp;&amp; (count % 20000) == 0)
1279  				{
1280  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% accounts validated\n&quot;) % count);
1281  				}
1282  				nano::confirmation_height_info confirmation_height_info;
1283  				node-&gt;store.confirmation_height.get (transaction, account, confirmation_height_info);
1284  				if (confirmation_height_info.height &gt; info.block_count)
1285  				{
1286  					print_error_message (boost::str (boost::format (&quot;Confirmation height %1% greater than block count %2% for account: %3%\n&quot;) % confirmation_height_info.height % info.block_count % account.to_account ()));
1287  				}
1288  				auto hash (info.open_block);
1289  				nano::block_hash calculated_hash (0);
1290  				auto block (node-&gt;store.block.get (transaction, hash)); 
1291  				uint64_t height (0);
1292  				if (node-&gt;ledger.pruning &amp;&amp; confirmation_height_info.height != 0)
1293  				{
1294  					hash = confirmation_height_info.frontier;
1295  					block = node-&gt;store.block.get (transaction, hash);
1296  					bool pruned_block (false);
1297  					while (!pruned_block &amp;&amp; !block-&gt;previous ().is_zero ())
1298  					{
1299  						auto previous_block (node-&gt;store.block.get (transaction, block-&gt;previous ()));
1300  						if (previous_block != nullptr)
1301  						{
1302  							hash = previous_block-&gt;hash ();
1303  							block = previous_block;
1304  						}
1305  						else
1306  						{
1307  							pruned_block = true;
1308  							if (!node-&gt;store.pruned.exists (transaction, block-&gt;previous ()))
1309  							{
1310  								print_error_message (boost::str (boost::format (&quot;Pruned previous block does not exist %1%\n&quot;) % block-&gt;previous ().to_string ()));
1311  							}
1312  						}
1313  					}
1314  					calculated_hash = block-&gt;previous ();
1315  					height = block-&gt;sideband ().height - 1;
1316  					if (!node-&gt;ledger.block_or_pruned_exists (transaction, info.open_block))
1317  					{
1318  						print_error_message (boost::str (boost::format (&quot;Open block does not exist %1%\n&quot;) % info.open_block.to_string ()));
1319  					}
1320  				}
1321  				uint64_t previous_timestamp (0);
1322  				nano::account calculated_representative{};
1323  				while (!hash.is_zero () &amp;&amp; block != nullptr)
1324  				{
1325  					++block_count;
1326  					auto const &amp; sideband (block-&gt;sideband ());
1327  					if (block-&gt;type () == nano::block_type::open || block-&gt;type () == nano::block_type::state)
1328  					{
1329  						if (block-&gt;account () != account)
1330  						{
1331  							print_error_message (boost::str (boost::format (&quot;Incorrect account field for block %1%\n&quot;) % hash.to_string ()));
1332  						}
1333  					}
1334  					else if (sideband.account != account)
1335  					{
1336  						print_error_message (boost::str (boost::format (&quot;Incorrect sideband account for block %1%\n&quot;) % hash.to_string ()));
1337  					}
1338  					if (calculated_hash != block-&gt;previous ())
1339  					{
1340  						print_error_message (boost::str (boost::format (&quot;Incorrect previous field for block %1%\n&quot;) % hash.to_string ()));
1341  					}
1342  					if (height == 0 &amp;&amp; !block-&gt;previous ().is_zero ())
1343  					{
1344  						print_error_message (boost::str (boost::format (&quot;Incorrect previous for open block %1%\n&quot;) % hash.to_string ()));
1345  					}
1346  					if (height == 0 &amp;&amp; block-&gt;type () != nano::block_type::open &amp;&amp; block-&gt;type () != nano::block_type::state)
1347  					{
1348  						print_error_message (boost::str (boost::format (&quot;Incorrect type for open block %1%\n&quot;) % hash.to_string ()));
1349  					}
1350  					calculated_hash = block-&gt;hash ();
1351  					if (calculated_hash != hash)
1352  					{
1353  						print_error_message (boost::str (boost::format (&quot;Invalid data inside block %1% calculated hash: %2%\n&quot;) % hash.to_string () % calculated_hash.to_string ()));
1354  					}
1355  					if (validate_message (account, hash, block-&gt;block_signature ()))
1356  					{
1357  						bool invalid (true);
1358  						if (block-&gt;type () == nano::block_type::state)
1359  						{
1360  							auto &amp; state_block (static_cast&lt;nano::state_block &amp;&gt; (*block.get ()));
1361  							nano::amount prev_balance (0);
1362  							bool error_or_pruned (false);
1363  							if (!state_block.hashables.previous.is_zero ())
1364  							{
1365  								prev_balance = node-&gt;ledger.balance_safe (transaction, state_block.hashables.previous, error_or_pruned);
1366  							}
1367  							if (node-&gt;ledger.is_epoch_link (state_block.hashables.link))
1368  							{
1369  								if ((state_block.hashables.balance == prev_balance &amp;&amp; !error_or_pruned) || (node-&gt;ledger.pruning &amp;&amp; error_or_pruned &amp;&amp; block-&gt;sideband ().details.is_epoch))
1370  								{
1371  									invalid = validate_message (node-&gt;ledger.epoch_signer (block-&gt;link ()), hash, block-&gt;block_signature ());
1372  								}
1373  							}
1374  						}
1375  						if (invalid)
1376  						{
1377  							print_error_message (boost::str (boost::format (&quot;Invalid signature for block %1%\n&quot;) % hash.to_string ()));
1378  						}
1379  					}
1380  					bool block_details_error = false;
1381  					if (block-&gt;type () != nano::block_type::state)
1382  					{
1383  						block_details_error = sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1384  					}
1385  					else
1386  					{
1387  						bool error_or_pruned (false);
1388  						auto prev_balance (node-&gt;ledger.balance_safe (transaction, block-&gt;previous (), error_or_pruned));
1389  						if (!node-&gt;ledger.pruning || !error_or_pruned)
1390  						{
1391  							if (block-&gt;balance () &lt; prev_balance)
1392  							{
1393  								block_details_error = !sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1394  							}
1395  							else
1396  							{
1397  								if (block-&gt;link ().is_zero ())
1398  								{
1399  									block_details_error = sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1400  								}
1401  								else if (block-&gt;balance () == prev_balance &amp;&amp; node-&gt;ledger.is_epoch_link (block-&gt;link ()))
1402  								{
1403  									block_details_error = !sideband.details.is_epoch || sideband.details.is_send || sideband.details.is_receive;
1404  								}
1405  								else
1406  								{
1407  									block_details_error = !sideband.details.is_receive || sideband.details.is_send || sideband.details.is_epoch;
1408  									block_details_error |= !node-&gt;ledger.block_or_pruned_exists (transaction, block-&gt;link ().as_block_hash ());
1409  								}
1410  							}
1411  						}
1412  						else if (!node-&gt;store.pruned.exists (transaction, block-&gt;previous ()))
1413  						{
1414  							print_error_message (boost::str (boost::format (&quot;Previous pruned block does not exist %1%\n&quot;) % block-&gt;previous ().to_string ()));
1415  						}
1416  					}
1417  					if (block_details_error)
1418  					{
1419  						print_error_message (boost::str (boost::format (&quot;Incorrect sideband block details for block %1%\n&quot;) % hash.to_string ()));
1420  					}
1421  					if (sideband.details.is_receive &amp;&amp; (!node-&gt;ledger.pruning || !node-&gt;store.pruned.exists (transaction, block-&gt;link ().as_block_hash ())))
1422  					{
1423  						if (sideband.source_epoch != node-&gt;store.block.version (transaction, block-&gt;link ().as_block_hash ()))
1424  						{
1425  							print_error_message (boost::str (boost::format (&quot;Incorrect source epoch for block %1%\n&quot;) % hash.to_string ()));
1426  						}
1427  					}
1428  					if (node-&gt;network_params.work.difficulty (*block) &lt; node-&gt;network_params.work.threshold (block-&gt;work_version (), block-&gt;sideband ().details))
1429  					{
1430  						print_error_message (boost::str (boost::format (&quot;Invalid work for block %1% value: %2%\n&quot;) % hash.to_string () % nano::to_string_hex (block-&gt;block_work ())));
1431  					}
1432  					++height;
1433  					if (sideband.height != height)
1434  					{
1435  						print_error_message (boost::str (boost::format (&quot;Incorrect sideband height for block %1%. Sideband: %2%. Expected: %3%\n&quot;) % hash.to_string () % sideband.height % height));
1436  					}
1437  					if (sideband.timestamp &lt; previous_timestamp)
1438  					{
1439  						print_error_message (boost::str (boost::format (&quot;Incorrect sideband timestamp for block %1%\n&quot;) % hash.to_string ()));
1440  					}
1441  					previous_timestamp = sideband.timestamp;
1442  					if (block-&gt;type () == nano::block_type::open || block-&gt;type () == nano::block_type::change || block-&gt;type () == nano::block_type::state)
1443  					{
1444  						calculated_representative = block-&gt;representative ();
1445  					}
1446  					hash = node-&gt;store.block.successor (transaction, hash);
1447  					if (!hash.is_zero ())
1448  					{
1449  						block = node-&gt;store.block.get (transaction, hash);
1450  					}
1451  				}
1452  				if (!hash.is_zero () &amp;&amp; block == nullptr)
1453  				{
1454  					print_error_message (boost::str (boost::format (&quot;Required block in account %1% chain was not found in ledger: %2%\n&quot;) % account.to_account () % hash.to_string ()));
1455  				}
1456  				if (info.block_count != height)
1457  				{
1458  					print_error_message (boost::str (boost::format (&quot;Incorrect block count for account %1%. Actual: %2%. Expected: %3%\n&quot;) % account.to_account () % height % info.block_count));
1459  				}
1460  				if (info.head != calculated_hash)
1461  				{
1462  					print_error_message (boost::str (boost::format (&quot;Incorrect frontier for account %1%. Actual: %2%. Expected: %3%\n&quot;) % account.to_account () % calculated_hash.to_string () % info.head.to_string ()));
1463  				}
1464  				if (info.representative != calculated_representative)
1465  				{
1466  					print_error_message (boost::str (boost::format (&quot;Incorrect representative for account %1%. Actual: %2%. Expected: %3%\n&quot;) % account.to_account () % calculated_representative.to_string () % info.representative.to_string ()));
1467  				}
1468  			};
1469  			start_threads (check_account, accounts);
1470  			if (!silent)
1471  			{
1472  				std::cout &lt;&lt; boost::str (boost::format (&quot;Performing %1% threads blocks hash, signature, work validation...\n&quot;) % threads_count);
1473  			}
1474  			size_t const accounts_deque_overflow (32 * 1024);
1475  			auto transaction (node-&gt;store.tx_begin_read ());
1476  			for (auto i (node-&gt;store.account.begin (transaction)), n (node-&gt;store.account.end ()); i != n; ++i)
1477  			{
1478  				{
1479  					nano::unique_lock&lt;nano::mutex&gt; lock{ mutex };
1480  					if (accounts.size () &gt; accounts_deque_overflow)
1481  					{
1482  						auto wait_ms (250 * accounts.size () / accounts_deque_overflow);
1483  						auto const wakeup (std::chrono::steady_clock::now () + std::chrono::milliseconds (wait_ms));
1484  						condition.wait_until (lock, wakeup);
1485  					}
1486  					accounts.emplace_back (i-&gt;first, i-&gt;second);
1487  				}
1488  				condition.notify_all ();
1489  			}
1490  			{
1491  				nano::lock_guard&lt;nano::mutex&gt; lock{ mutex };
1492  				finished = true;
1493  			}
1494  			condition.notify_all ();
1495  			for (auto &amp; thread : threads)
1496  			{
1497  				thread.join ();
1498  			}
1499  			threads.clear ();
1500  			if (!silent)
1501  			{
1502  				std::cout &lt;&lt; boost::str (boost::format (&quot;%1% accounts validated\n&quot;) % count);
1503  			}
1504  			auto ledger_block_count (node-&gt;store.block.count (transaction));
1505  			if (node-&gt;flags.enable_pruning)
1506  			{
1507  				block_count += 1; 
1508  			}
1509  			if (block_count != ledger_block_count)
1510  			{
1511  				print_error_message (boost::str (boost::format (&quot;Incorrect total block count. Blocks validated %1%. Block count in database: %2%\n&quot;) % block_count % ledger_block_count));
1512  			}
1513  			count = 0;
1514  			finished = false;
1515  			std::deque&lt;std::pair&lt;nano::pending_key, nano::pending_info&gt;&gt; pending;
1516  			auto check_pending = [&amp;print_error_message, &amp;silent, &amp;count] (std::shared_ptr&lt;nano::node&gt; const &amp; node, nano::read_transaction const &amp; transaction, nano::pending_key const &amp; key, nano::pending_info const &amp; info) {
1517  				++count;
1518  				if (!silent &amp;&amp; (count % 500000) == 0)
1519  				{
1520  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% pending blocks validated\n&quot;) % count);
1521  				}
1522  				auto block (node-&gt;store.block.get_no_sideband (transaction, key.hash));
1523  				bool pruned (false);
1524  				if (block == nullptr)
1525  				{
1526  					pruned = node-&gt;ledger.pruning &amp;&amp; node-&gt;store.pruned.exists (transaction, key.hash);
1527  					if (!pruned)
1528  					{
1529  						print_error_message (boost::str (boost::format (&quot;Pending block does not exist %1%\n&quot;) % key.hash.to_string ()));
1530  					}
1531  				}
1532  				else
1533  				{
1534  					nano::account destination{};
1535  					bool previous_pruned = node-&gt;ledger.pruning &amp;&amp; node-&gt;store.pruned.exists (transaction, block-&gt;previous ());
1536  					if (previous_pruned)
1537  					{
1538  						block = node-&gt;store.block.get (transaction, key.hash);
1539  					}
1540  					if (auto state = dynamic_cast&lt;nano::state_block *&gt; (block.get ()))
1541  					{
1542  						if (node-&gt;ledger.is_send (transaction, *state))
1543  						{
1544  							destination = state-&gt;hashables.link.as_account ();
1545  						}
1546  					}
1547  					else if (auto send = dynamic_cast&lt;nano::send_block *&gt; (block.get ()))
1548  					{
1549  						destination = send-&gt;hashables.destination;
1550  					}
1551  					else
1552  					{
1553  						print_error_message (boost::str (boost::format (&quot;Incorrect type for pending block %1%\n&quot;) % key.hash.to_string ()));
1554  					}
1555  					if (key.account != destination)
1556  					{
1557  						print_error_message (boost::str (boost::format (&quot;Incorrect destination for pending block %1%\n&quot;) % key.hash.to_string ()));
1558  					}
1559  					auto account (node-&gt;ledger.account (transaction, key.hash));
1560  					if (info.source != account &amp;&amp; !pruned)
1561  					{
1562  						print_error_message (boost::str (boost::format (&quot;Incorrect source for pending block %1%\n&quot;) % key.hash.to_string ()));
1563  					}
1564  					if (!pruned &amp;&amp; !previous_pruned)
1565  					{
1566  						auto amount (node-&gt;ledger.amount (transaction, key.hash));
1567  						if (info.amount != amount)
1568  						{
1569  							print_error_message (boost::str (boost::format (&quot;Incorrect amount for pending block %1%\n&quot;) % key.hash.to_string ()));
1570  						}
1571  					}
1572  				}
1573  			};
1574  			start_threads (check_pending, pending);
1575  			size_t const pending_deque_overflow (64 * 1024);
1576  			for (auto i (node-&gt;store.pending.begin (transaction)), n (node-&gt;store.pending.end ()); i != n; ++i)
1577  			{
1578  				{
1579  					nano::unique_lock&lt;nano::mutex&gt; lock{ mutex };
1580  					if (pending.size () &gt; pending_deque_overflow)
1581  					{
1582  						auto wait_ms (50 * pending.size () / pending_deque_overflow);
1583  						auto const wakeup (std::chrono::steady_clock::now () + std::chrono::milliseconds (wait_ms));
1584  						condition.wait_until (lock, wakeup);
1585  					}
1586  					pending.emplace_back (i-&gt;first, i-&gt;second);
1587  				}
1588  				condition.notify_all ();
1589  			}
1590  			{
1591  				nano::lock_guard&lt;nano::mutex&gt; lock{ mutex };
1592  				finished = true;
1593  			}
1594  			condition.notify_all ();
1595  			for (auto &amp; thread : threads)
1596  			{
1597  				thread.join ();
1598  			}
1599  			if (!silent)
1600  			{
1601  				std::cout &lt;&lt; boost::str (boost::format (&quot;%1% pending blocks validated\n&quot;) % count);
1602  				timer.stop ();
1603  				std::cout &lt;&lt; boost::str (boost::format (&quot;%1% %2% validation time\n&quot;) % timer.value ().count () % timer.unit ());
1604  			}
1605  			if (errors == 0)
1606  			{
1607  				std::cout &lt;&lt; &quot;Validation status: Ok\n&quot;;
1608  			}
1609  			else
1610  			{
1611  				std::cout &lt;&lt; boost::str (boost::format (&quot;Validation status: Failed\n%1% errors found\n&quot;) % errors);
1612  			}
1613  		}
1614  		else if (vm.count (&quot;debug_profile_bootstrap&quot;))
1615  		{
1616  			auto node_flags = nano::inactive_node_flag_defaults ();
1617  			node_flags.read_only = false;
1618  			nano::update_flags (node_flags, vm);
1619  			nano::inactive_node node (nano::unique_path (), node_flags);
1620  			auto begin (std::chrono::high_resolution_clock::now ());
1621  			uint64_t block_count (0);
1622  			size_t count (0);
1623  			std::deque&lt;std::shared_ptr&lt;nano::block&gt;&gt; epoch_open_blocks;
1624  			{
1625  				auto node_flags = nano::inactive_node_flag_defaults ();
1626  				nano::update_flags (node_flags, vm);
1627  				node_flags.generate_cache.block_count = true;
1628  				nano::inactive_node inactive_node (data_path, node_flags);
1629  				auto source_node = inactive_node.node;
1630  				auto transaction (source_node-&gt;store.tx_begin_read ());
1631  				block_count = source_node-&gt;ledger.cache.block_count;
1632  				std::cout &lt;&lt; boost::str (boost::format (&quot;Performing bootstrap emulation, %1% blocks in ledger...&quot;) % block_count) &lt;&lt; std::endl;
1633  				for (auto i (source_node-&gt;store.account.begin (transaction)), n (source_node-&gt;store.account.end ()); i != n; ++i)
1634  				{
1635  					nano::account const &amp; account (i-&gt;first);
1636  					nano::account_info const &amp; info (i-&gt;second);
1637  					auto hash (info.head);
1638  					while (!hash.is_zero ())
1639  					{
1640  						auto block (source_node-&gt;store.block.get_no_sideband (transaction, hash));
1641  						if (block != nullptr)
1642  						{
1643  							++count;
1644  							if ((count % 500000) == 0)
1645  							{
1646  								std::cout &lt;&lt; boost::str (boost::format (&quot;%1% blocks retrieved&quot;) % count) &lt;&lt; std::endl;
1647  							}
1648  							node.node-&gt;block_processor.add (block);
1649  							if (block-&gt;type () == nano::block_type::state &amp;&amp; block-&gt;previous ().is_zero () &amp;&amp; source_node-&gt;ledger.is_epoch_link (block-&gt;link ()))
1650  							{
1651  								epoch_open_blocks.push_back (block);
1652  							}
1653  							hash = block-&gt;previous ();
1654  						}
1655  					}
1656  				}
1657  			}
1658  			nano::timer&lt;std::chrono::seconds&gt; timer_l (nano::timer_state::started);
1659  			while (node.node-&gt;ledger.cache.block_count != block_count)
1660  			{
1661  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1662  				if (node.node-&gt;block_processor.size () == 0)
1663  				{
1664  					for (auto &amp; block : epoch_open_blocks)
1665  					{
1666  						node.node-&gt;block_processor.add (block);
1667  					}
1668  				}
1669  				if (timer_l.after_deadline (std::chrono::seconds (60)))
1670  				{
1671  					timer_l.restart ();
1672  					std::cout &lt;&lt; boost::str (boost::format (&quot;%1% (%2%) blocks processed (unchecked)&quot;) % node.node-&gt;ledger.cache.block_count % node.node-&gt;unchecked.count ()) &lt;&lt; std::endl;
1673  				}
1674  			}
1675  			node.node-&gt;block_processor.flush ();
1676  			auto end (std::chrono::high_resolution_clock::now ());
1677  			auto time (std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (end - begin).count ());
1678  			auto us_in_second (1000000);
1679  			auto seconds (time / us_in_second);
1680  			nano::remove_temporary_directories ();
1681  			std::cout &lt;&lt; boost::str (boost::format (&quot;%|1$ 12d| seconds \n%2% blocks per second&quot;) % seconds % (block_count * us_in_second / time)) &lt;&lt; std::endl;
1682  			release_assert (node.node-&gt;ledger.cache.block_count == block_count);
1683  		}
1684  		else if (vm.count (&quot;debug_peers&quot;))
1685  		{
1686  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1687  			auto node = inactive_node-&gt;node;
1688  			auto transaction (node-&gt;store.tx_begin_read ());
1689  			for (auto i (node-&gt;store.peer.begin (transaction)), n (node-&gt;store.peer.end ()); i != n; ++i)
1690  			{
1691  				std::cout &lt;&lt; boost::str (boost::format (&quot;%1%\n&quot;) % nano::endpoint (boost::asio::ip::address_v6 (i-&gt;first.address_bytes ()), i-&gt;first.port ()));
1692  			}
1693  		}
1694  		else if (vm.count (&quot;debug_cemented_block_count&quot;))
1695  		{
1696  			auto node_flags = nano::inactive_node_flag_defaults ();
1697  			node_flags.generate_cache.cemented_count = true;
1698  			nano::update_flags (node_flags, vm);
1699  			nano::inactive_node node (data_path, node_flags);
1700  			std::cout &lt;&lt; &quot;Total cemented block count: &quot; &lt;&lt; node.node-&gt;ledger.cache.cemented_count &lt;&lt; std::endl;
1701  		}
1702  		else if (vm.count (&quot;debug_prune&quot;))
1703  		{
1704  			auto node_flags = nano::inactive_node_flag_defaults ();
1705  			node_flags.read_only = false;
1706  			nano::update_flags (node_flags, vm);
1707  			nano::inactive_node inactive_node (data_path, node_flags);
1708  			auto node = inactive_node.node;
1709  			node-&gt;ledger_pruning (node_flags.block_processor_batch_size != 0 ? node_flags.block_processor_batch_size : 16 * 1024, true, true);
1710  		}
1711  		else if (vm.count (&quot;debug_stacktrace&quot;))
1712  		{
1713  			std::cout &lt;&lt; boost::stacktrace::stacktrace ();
1714  		}
1715  		else if (vm.count (&quot;debug_sys_logging&quot;))
1716  		{
1717  #ifdef BOOST_WINDOWS
1718  			if (!nano::event_log_reg_entry_exists () &amp;&amp; !nano::is_windows_elevated ())
1719  			{
1720  				std::cerr &lt;&lt; &quot;The event log requires the HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Nano\\Nano registry entry, run again as administator to create it.\n&quot;;
1721  				return 1;
1722  			}
1723  #endif
1724  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1725  			inactive_node-&gt;node-&gt;logger.always_log (nano::severity_level::error, &quot;Testing system logger&quot;);
1726  		}
1727  		else if (vm.count (&quot;debug_account_versions&quot;))
1728  		{
1729  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1730  			auto node = inactive_node-&gt;node;
1731  			auto const epoch_count = nano::normalized_epoch (nano::epoch::max) + static_cast&lt;std::underlying_type&lt;nano::epoch&gt;::type&gt; (1);
1732  			nano::locked&lt;std::vector&lt;boost::unordered_set&lt;nano::account&gt;&gt;&gt; opened_account_versions_shared (epoch_count);
1733  			using opened_account_versions_t = decltype (opened_account_versions_shared)::value_type;
1734  			node-&gt;store.account.for_each_par (
1735  			[&amp;opened_account_versions_shared, epoch_count] (nano::read_transaction const &amp; &amp;bsol;*unused*/, nano::store_iterator&lt;nano::account, nano::account_info&gt; i, nano::store_iterator&lt;nano::account, nano::account_info&gt; n) {
1736  				opened_account_versions_t opened_account_versions_l (epoch_count);
1737  				for (; i != n; ++i)
1738  				{
1739  					auto const &amp; account (i-&gt;first);
1740  					auto const &amp; account_info (i-&gt;second);
1741  					auto epoch_idx = nano::normalized_epoch (account_info.epoch ());
1742  					opened_account_versions_l[epoch_idx].emplace (account);
1743  				}
1744  				auto opened_account_versions = opened_account_versions_shared.lock ();
1745  				debug_assert (opened_account_versions-&gt;size () == opened_account_versions_l.size ());
1746  				for (auto idx (0); idx &lt; opened_account_versions_l.size (); ++idx)
1747  				{
1748  					auto &amp; accounts = opened_account_versions-&gt;at (idx);
1749  					auto const &amp; accounts_l = opened_account_versions_l.at (idx);
1750  					accounts.insert (accounts_l.begin (), accounts_l.end ());
1751  				}
1752  			});
1753  			boost::unordered_set&lt;nano::account&gt; opened_accounts;
1754  			{
1755  				auto opened_account_versions = opened_account_versions_shared.lock ();
1756  				for (auto const &amp; account_version : *opened_account_versions)
1757  				{
1758  					opened_accounts.insert (account_version.cbegin (), account_version.cend ());
1759  				}
1760  			}
1761  			nano::locked&lt;boost::unordered_map&lt;nano::account, std::underlying_type_t&lt;nano::epoch&gt;&gt;&gt; unopened_highest_pending_shared;
1762  			using unopened_highest_pending_t = decltype (unopened_highest_pending_shared)::value_type;
1763  			node-&gt;store.pending.for_each_par (
1764  			[&amp;unopened_highest_pending_shared, &amp;opened_accounts] (nano::read_transaction const &amp; &amp;bsol;*unused*/, nano::store_iterator&lt;nano::pending_key, nano::pending_info&gt; i, nano::store_iterator&lt;nano::pending_key, nano::pending_info&gt; n) {
1765  				unopened_highest_pending_t unopened_highest_pending_l;
1766  				for (; i != n; ++i)
1767  				{
1768  					nano::pending_key const &amp; key (i-&gt;first);
1769  					nano::pending_info const &amp; info (i-&gt;second);
1770  					auto &amp; account = key.account;
1771  					auto exists = opened_accounts.find (account) != opened_accounts.end ();
1772  					if (!exists)
1773  					{
1774  						auto epoch = nano::normalized_epoch (info.epoch);
1775  						auto &amp; existing_or_new = unopened_highest_pending_l[key.account];
1776  						existing_or_new = std::max (epoch, existing_or_new);
1777  					}
1778  				}
1779  				auto unopened_highest_pending = unopened_highest_pending_shared.lock ();
1780  				for (auto const &amp; [account, epoch] : unopened_highest_pending_l)
1781  				{
1782  					auto &amp; existing_or_new = unopened_highest_pending-&gt;operator[] (account);
1783  					existing_or_new = std::max (epoch, existing_or_new);
1784  				}
1785  			});
1786  			auto output_account_version_number = [] (auto version, auto num_accounts) {
1787  				std::cout &lt;&lt; &quot;Account version &quot; &lt;&lt; version &lt;&lt; &quot; num accounts: &quot; &lt;&lt; num_accounts &lt;&lt; &quot;\n&quot;;
1788  			};
1789  			auto const &amp; opened_account_versions = *opened_account_versions_shared.lock ();
1790  			auto const &amp; unopened_highest_pending = *unopened_highest_pending_shared.lock ();
1791  			std::cout &lt;&lt; &quot;Opened accounts:\n&quot;;
1792  			for (auto i = 0u; i &lt; opened_account_versions.size (); ++i)
1793  			{
1794  				output_account_version_number (i, opened_account_versions[i].size ());
1795  			}
1796  			std::vector&lt;size_t&gt; unopened_account_version_totals (epoch_count);
1797  			for (auto const &amp; [account, epoch] : unopened_highest_pending)
1798  			{
1799  				++unopened_account_version_totals[epoch];
1800  			}
1801  			std::cout &lt;&lt; &quot;\nUnopened accounts:\n&quot;;
1802  			for (auto i = 0u; i &lt; unopened_account_version_totals.size (); ++i)
1803  			{
1804  				output_account_version_number (i, unopened_account_version_totals[i]);
1805  			}
1806  		}
1807  		else if (vm.count (&quot;debug_unconfirmed_frontiers&quot;))
1808  		{
1809  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1810  			auto node = inactive_node-&gt;node;
1811  			auto unconfirmed_frontiers = node-&gt;ledger.unconfirmed_frontiers ();
1812  			std::cout &lt;&lt; &quot;Account: Height delta | Frontier | Confirmed frontier\n&quot;;
1813  			for (auto const &amp; [height_delta, unconfirmed_info] : unconfirmed_frontiers)
1814  			{
1815  				std::cout &lt;&lt; (boost::format (&quot;%1%: %2% %3% %4%\n&quot;) % unconfirmed_info.account.to_account () % height_delta % unconfirmed_info.frontier.to_string () % unconfirmed_info.cemented_frontier.to_string ()).str ();
1816  			}
1817  			std::cout &lt;&lt; &quot;\nNumber of unconfirmed frontiers: &quot; &lt;&lt; unconfirmed_frontiers.size () &lt;&lt; std::endl;
1818  		}
1819  		else if (vm.count (&quot;version&quot;))
1820  		{
1821  			std::cout &lt;&lt; &quot;Version &quot; &lt;&lt; NANO_VERSION_STRING &lt;&lt; &quot;\n&quot;
1822  					  &lt;&lt; &quot;Build Info &quot; &lt;&lt; BUILD_INFO &lt;&lt; std::endl;
1823  		}
1824  		else
1825  		{
1826  			boost::program_options::options_description sorted_description (&quot;Command line options&quot;);
1827  			nano::sort_options_description (description, sorted_description);
1828  			std::cout &lt;&lt; sorted_description &lt;&lt; std::endl;
1829  			result = -1;
1830  		}
1831  	}
1832  	return result;
1833  }
1834  namespace
1835  {
1836  std::istream &amp; operator&gt;&gt; (std::istream &amp; in, uint64_from_hex &amp; out_val)
1837  {
1838  	in &gt;&gt; std::hex &gt;&gt; out_val.value;
1839  	return in;
1840  }
1841  address_library_pair::address_library_pair (uint64_t address, std::string library) :
1842  	address (address), library (library)
1843  {
1844  }
1845  bool address_library_pair::operator&lt; (const address_library_pair &amp; other) const
1846  {
1847  	return address &lt; other.address;
1848  }
1849  bool address_library_pair::operator== (const address_library_pair &amp; other) const
1850  {
1851  	return address == other.address;
1852  }
1853  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpcconfig.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_11.cpp</div>
                </div>
                <div class="column column_space"><pre><code>129  	boost::system::error_code err;
130  	auto running_executable_filepath = boost::dll::program_location (err);
131  	auto rpc_filepath = running_executable_filepath.parent_path () / &quot;nano_rpc&quot;;
</pre></code></div>
                <div class="column column_space"><pre><code>633  				boost::system::error_code err;
634  				auto running_executable_filepath = boost::dll::program_location (err);
635  				if (!err)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    