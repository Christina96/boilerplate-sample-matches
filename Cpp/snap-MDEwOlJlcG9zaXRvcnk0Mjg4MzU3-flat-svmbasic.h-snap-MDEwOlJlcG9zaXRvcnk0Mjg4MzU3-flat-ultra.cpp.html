
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.771804062126643%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmbasic.h</h3>
            <pre><code>1  #define EPSILON 1e-4
2  typedef TVec<double> TVecDbl;
3  typedef TVec<int> TVecInt;
4  typedef TVec<bool> TVecBool;
5  typedef float TFltType;
6  class TSVMCacheVec {
7  public:
8      TFltType *valT;
9      bool *validT;
10      int *idsT;
11      int dim;
12  public:
13      TSVMCacheVec(): valT(NULL), idsT(NULL), dim(0) {};
14      TSVMCacheVec(TFltType *_valT, bool* _validT, int *_idsT, int _dim):
15              valT(_valT), validT(_validT), idsT(_idsT), dim(_dim) {}
16      TSVMCacheVec(const TSVMCacheVec& vec):
17              valT(vec.valT), validT(vec.validT), idsT(vec.idsT), dim(vec.dim) {}
18      TSVMCacheVec& operator=(const TSVMCacheVec& vec) {
19          valT = vec.valT; validT = vec.validT; idsT = vec.idsT; dim = vec.dim;
20          return *this;
21      }
22  };
23  class TSVMCache {
24  private:
25      int verbosity;
26      TFltType *cache;
27      bool *valid;
28      int numRows;
29      int *idsT;
30      struct TListNode {
31          int ID;
32          int position;
33          TFltType *addr;
34          bool *vaddr;
35          TListNode *prev;
36          TListNode *next;
37      };
38      TListNode *top;
39      TListNode *bottom;
40      TVec<TListNode *> vecPt;
41      TVec<TListNode *> vecShrink;
42      TBoolV saved;
43      int size;
44      int maxsize;
45      int dim;
46      void toTop(TListNode *node);
47      UndefCopyAssign(TSVMCache);
48  public:
49      TSVMCache(int verb = 0):
50          verbosity(verb), cache(NULL), valid(NULL),
51          numRows(0), idsT(NULL), top(NULL), bottom(NULL), vecPt(0),
52          vecShrink(0), saved(0), size(0), maxsize(0), dim(0) {}
53      TSVMCache(const int& memory_size, const int& d, int verb):
54          verbosity(verb) { Reset(memory_size, d); }
55      ~TSVMCache() { Clear(); }
56      void Reset(const int& memory_size, const int& d);
57      void Clear();
58      bool Exists(const int& col) const
59          { Assert(col >= 0 && col < dim); return saved[col]; }
60      bool IsRowValid(const int &col, const int &row) const {
61          Assert(0 <= col && col < dim && 0 <= row && row < dim);
62          if (saved[col])
63              return idsT[row] >= 0 ? vecPt[col]->vaddr[idsT[row]] : false;
64          else
65              return false;
66      }
67      int MaxSize() { return maxsize; }
68      int CurrentSize() { return size; }
69      bool Full() { return maxsize == size; }
70      void Shrink(const int& n, int *ids);
71      TSVMCacheVec Get(const int& i);
72      TFltType GetVal(const int& i, const int& j) const;
73      TSVMCacheVec Add(const int& i);
74  };
75  typedef enum {ststSparse, ststDense, ststBow, ststString, ststSimMatrix} TSVMTrainSetType;
76  ClassTP(TSVMTrainSet, PSVMTrainSet) 
77  protected:
78      typedef PSVMTrainSet (*TSVMTrainSetLoad)(TSIn& SIn);
79      typedef TFunc<TSVMTrainSetLoad> TSVMTrainSetLoadF;
80      static THash<TStr, TSVMTrainSetLoadF> TypeToLoadFH;
81      static bool Reg(const TStr& TypeNm, const TSVMTrainSetLoadF& LoadF);
82  private:
83      TInt SVMTrainSetType;
84      UndefDefaultCopyAssign(TSVMTrainSet);
85  private:
86      TIntFltKdV FailReturnIntFltKdV;
87      TFltV FailReturnFltV;
88      TStr FailReturnStr;
89      TIntV FailReturnIntV;
90  public:
91      TSVMTrainSet(const TSVMTrainSetType& _Type): SVMTrainSetType(_Type) { };
92      virtual ~TSVMTrainSet() { };
93      TSVMTrainSet(TSIn& SIn) { SVMTrainSetType.Load(SIn); }
94      static PSVMTrainSet Load(TSIn &SIn);
95      static PSVMTrainSet LoadBin(const TStr& FNm) {
96          TFIn FIn(FNm); return TSVMTrainSet::Load(FIn); }
97      virtual void Save(TSOut& SOut) const {
98          GetTypeNm(*this).Save(SOut); SVMTrainSetType.Save(SOut); }
99      void SaveBin(const TStr& FNm) { TFOut FOut(FNm); Save(FOut); }
100      virtual void SaveTxt(const TStr& OutFNm) const { Fail; }
101      virtual void SaveMatlab(const TStr& OutFNm) const { Fail; }
102      TSVMTrainSetType Type() const { return TSVMTrainSetType(SVMTrainSetType.Val); }
103  public: 
104      virtual int Len() const = 0;
105      virtual int Dim() const = 0;
106      virtual double GetNorm2(const int& VecId) const = 0;
107      virtual double GetVecParam(const int& VecId) const = 0;
108    virtual double DotProduct(const int& VecId1, const int& VecId2) const = 0;
109      virtual double DotProduct(const int& VecId1, double* vec2, const int& n) const = 0;
110      virtual double DotProduct(const int& VecId1, const TFltV& vec2) const = 0;
111    virtual void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const = 0;
112    virtual void AddVec(const int& VecId1, TFltV& vec2, const double& K) const = 0;
113      virtual PSVMTrainSet Clone(const TIntV& VecIdV) const = 0;
114  public: 
115      virtual int AddAttrV(const TIntFltKdV& AttrV, const double& Cls, const bool& Normalize) { Fail; return 0; }
116      virtual int AddAttrV(const TFltV& AttrV, const double& Cls, const bool& Normalize) { Fail; return 0; }
117      virtual int AddAttrV(const int& DId, PBowSpV AttrV, const double& Cls) { Fail; return 0; }
118      virtual int AddAttrV(const TStr& AttrV, const double& Cls) { Fail; return 0; }
119      virtual int AddAttrV(const TIntV& AttrV, const double& Cls) { Fail; return 0; }
120      virtual const TIntFltKdV& GetAttrSparseV(const int& VecId) const { Fail; return FailReturnIntFltKdV; }
121      virtual const TFltV&      GetAttrDenseV(const int& VecId) const { Fail; return FailReturnFltV; }
122      virtual PBowSpV           GetAttrBowV(const int& VecId) const { Fail; return NULL; }
123      virtual int               GetVecDId(const int& VecId) const { Fail; return 0;  }
124      virtual const TIntV&      GetAttrStringV(const int& VecId) const { Fail; return FailReturnIntV; }
125      virtual void RemoveAttrV(const int& VecId) { Fail; }
126      virtual void SetVecParam(const int& VecId, const double& NewCls) { Fail; }
127      virtual double DotProduct(const int& VecId1, const TIntFltKdV& Vec2) const { Fail; return 0.0; }
128      virtual double DotProduct(const int& VecId1, PBowSpV Vec2) const { Fail; return 0.0; }
129      virtual double DotProduct(const int& VecId1, const TStr& Vec2) const { Fail; return 0.0; }
130      virtual double DotProduct(const int& VecId1, const TIntV& Vec2) const { Fail; return 0.0; }
<span onclick='openModal()' class='match'>131      void Shuffle(TRnd& Rnd) { Fail; }
132  public: 
133      void LinComb(const TFltV& AlphV, TFltV& Result);
134      void LinComb(const TIntV& VecIdV, const TFltV& AlphV, TFltV& Result);
135      double EuclDist(const int& VecId1, const int& VecId2) {
</span>136          return GetNorm2(VecId1) - 2*DotProduct(VecId1, VecId2) + GetNorm2(VecId2); }
137      void GetKeywords(const TFltV& NormalV, TIntFltKdV& WIdWgtV,
138          const TIntV& VecIdV = TIntV(), const int& Wd = 10,
139          const double& VecSign = 1.0, const double& WgtSign = 1.0,
140          const bool& AvgOverSet = true);
141      double CalcSvmUnblParam(const double& MxVal = 10, const double& MnVal = 0.1);
142      int GetSignVecs(const double& Sign);
143      bool HasPosNegVecs(const int& MnVec);
144      bool HasPosVecs(const int& MnPosVec);
145      bool HasNegVecs(const int& MnNegVec);
146  };
147  class TSVMTrainSubSet : public TSVMTrainSet {
148  private:
149      PSVMTrainSet TrainSet;
150      TIntV SubSetIdV;
151  public:
152      TSVMTrainSubSet(PSVMTrainSet TrSet, const TIntV& TrVecIdV):
153        TSVMTrainSet(TrSet->Type()), TrainSet(TrSet), SubSetIdV(TrVecIdV) {};
154      static PSVMTrainSet New(PSVMTrainSet TrSet, const TIntV& TrVecIdV) {
155          return new TSVMTrainSubSet(TrSet, TrVecIdV); }
156      int Len() const { return SubSetIdV.Len(); }
157      int Dim() const { return TrainSet->Dim(); }
158      double GetNorm2(const int& VecId) const { return TrainSet->GetNorm2(SubSetIdV[VecId]); }
159      double GetVecParam(const int& VecId) const { return TrainSet->GetVecParam(SubSetIdV[VecId]); }
160      double DotProduct(const int& VecId1, const int& VecId2) const {
161          return TrainSet->DotProduct(SubSetIdV[VecId1], SubSetIdV[VecId2]); }
162      double DotProduct(const int& VecId1, double* vec2, const int& n) const {
163          return TrainSet->DotProduct(SubSetIdV[VecId1], vec2, n); }
164      double DotProduct(const int& VecId1, const TFltV& vec2) const {
165          return TrainSet->DotProduct(SubSetIdV[VecId1], vec2); }
166      void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const {
167          TrainSet->AddVec(SubSetIdV[VecId1], vec2, n, K); }
168    void AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
169          TrainSet->AddVec(SubSetIdV[VecId1], vec2, K); }
170      PSVMTrainSet Clone(const TIntV& VecIdV) const { Fail; return NULL; };
171  };
172  class TSTSetMatrix: public TMatrix {
173  private:
174    PSVMTrainSet ColVV;
175  protected:
176    virtual void PMultiply(const TFltVV& B, int ColId, TFltV& Result) const;
177    virtual void PMultiply(const TFltV& Vec, TFltV& Result) const;
178    virtual void PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const;
179    virtual void PMultiplyT(const TFltV& Vec, TFltV& Result) const;
180    int PGetRows() const { return ColVV->Dim(); }
181    int PGetCols() const { return ColVV->Len(); }
182  public:
183    TSTSetMatrix(PSVMTrainSet Set): TMatrix(), ColVV(Set) {
184      IAssert(Set->Type() == ststSparse); };
185    TSTSetMatrix(PSVMTrainSet Set, TFltV& ClsV);
186    void Load(TSparseColMatrix& Matrix, TFltV& y, PSVMTrainSet TrainSet,
187      const double& PWgt = 0.99, const double& NWgt = -0.99);
188  };
189  ClassTP(TKernel, PKernel)
190  protected:
191    typedef PKernel (*TKernelLoad)(TSIn& SIn);
192    typedef TFunc<TKernelLoad> TKernelLoadF;
193    static THash<TStr, TKernelLoadF> TypeToLoadFH;
194    static bool Reg(const TStr& TypeNm, const TKernelLoadF& LoadF);
195  public:
196    virtual ~TKernel(){}
197    virtual double CalcSet(const PSVMTrainSet& set,
198      const int& VecId1, const int& VecId2) const = 0;
199    virtual double Calc(const double& DotProduct,
200    const double& Norm1, const double& Norm2) const = 0;
201    static PKernel Load(TSIn& SIn);
202    virtual void Save(TSOut& SOut) {
203      GetTypeNm(*this).Save(SOut); }
204  };
205  class TPolynomialKernel: public TKernel {
206  private:
207    static bool IsReg;
208    static bool MkReg(){return TKernel::Reg(TTypeNm<TPolynomialKernel>(), &Load);}
209  private:
210      double s, c, p;
211  public:
212      TPolynomialKernel(double _p = 3.0, double _s = 1.0,
213          double _c = 1.0): s(_s), c(_c), p(_p) {}
214      static PKernel New(double _p = 3.0, double _s = 1.0, double _c = 1.0) {
215          return PKernel(new TPolynomialKernel(_p, _s, _c)); }
216      static PKernel NewLinKernel() {
217          return PKernel(new TPolynomialKernel(1.0, 1.0, 0.0)); }
218      explicit TPolynomialKernel(TSIn& SIn) {
219          SIn.Load(s); SIn.Load(c); SIn.Load(p); }
220      static PKernel Load(TSIn& SIn){
221          return PKernel(new TPolynomialKernel(SIn));}
222      void Save(TSOut& SOut) {
223          TKernel::Save(SOut); SOut.Save(s); SOut.Save(c); SOut.Save(p); }
224      double CalcSet(const PSVMTrainSet& set, const int& VecId1, const int& VecId2) const {
225          return pow(s * set->DotProduct(VecId1, VecId2) + c, p); }
226      double Calc(const double& DotProduct, const double& Norm1, const double& Norm2) const {
227          return pow(s * DotProduct + c, p); }
228  };
229  class TRadialKernel: public TKernel {
230  private:
231    static bool IsReg;
232    static bool MkReg(){return TKernel::Reg(TTypeNm<TRadialKernel>(), &Load);}
233  private:
234      double gama;
235  public:
236      TRadialKernel(double _gama = 1.0): gama(_gama) {}
237      static PKernel New(double _gama = 1.0) {
238          return PKernel(new TRadialKernel(_gama)); }
239      explicit TRadialKernel(TSIn& SIn) { SIn.Load(gama); }
240      static PKernel Load(TSIn& SIn){
241          return PKernel(new TRadialKernel(SIn));}
242      void Save(TSOut& SOut) {
243          TKernel::Save(SOut); SOut.Save(gama); }
244      double CalcSet(const PSVMTrainSet& set, const int& VecId1, const int& VecId2) const {
245          return exp(-gama * (set->GetNorm2(VecId1) + set->GetNorm2(VecId2) -
246                     2*set->DotProduct(VecId1, VecId2)));
247      }
248      double Calc(const double& DotProduct, const double& Norm1, const double& Norm2) const {
249          return exp(-gama * (Norm1 + Norm2 - 2*DotProduct)); }
250  };
251  class TSigmoidKernel: public TKernel {
252  private:
253    static bool IsReg;
254    static bool MkReg(){return TKernel::Reg(TTypeNm<TSigmoidKernel>(), &Load);}
255  private:
256      double s, c;
257  public:
258      TSigmoidKernel(double _s = 1.0, double _c = 1.0): s(_s), c(_c) {}
259      static PKernel New(double _s = 1.0, double _c = 1.0) {
260          return PKernel(new TSigmoidKernel(_s, _c)); }
261      explicit TSigmoidKernel(TSIn& SIn) { SIn.Load(s); SIn.Load(c); }
262      static PKernel Load(TSIn& SIn){
263          return PKernel(new TSigmoidKernel(SIn));}
264      void Save(TSOut& SOut) {
265          TKernel::Save(SOut); SOut.Save(s); SOut.Save(c); }
266      double CalcSet(const PSVMTrainSet& set, const int& VecId1, const int& VecId2) const {
267          return tanh(s * set->DotProduct(VecId1, VecId2) + c); }
268      double Calc(const double& DotProduct, const double& Norm1, const double& Norm2) const {
269          return tanh(s * DotProduct + c); }
270  };
271  class TSVMQP {
272  private:
273      int n;
274      int m;
275      double *c;
276      double *Q;
277      double *A;
278      double *pl;
279      double *primal;
280      double *dual;
281      UndefDefaultCopyAssign(TSVMQP);
282  public:
283      TSVMQP(const int& nn, const int& mm = 1, const double& ll = 0.0);
284      ~TSVMQP();
285      bool solve(const int& size, const double& bb, double *u,
286                 double *Q, double *A, double *c, double *resultV, const int& verbosity);
287  };
288  class TSVMQPSolver {
289  private:
290      struct TShrinkState {
291          TShrinkState(): BSVcount(NULL), NSVcount(NULL), histID(NULL),
292              aOld(NULL), sOld(NULL) {}
293          ~TShrinkState() {
294              if (BSVcount != NULL) delete[] BSVcount;
295              if (NSVcount != NULL) delete[] NSVcount;
296              if (histID != NULL) delete[] histID;
297              if (aOld != NULL) delete[] aOld;
298              if (sOld != NULL) delete[] sOld;
299          }
300          double epsilon;
301          int *BSVcount;
302          int *NSVcount;
303          int count;
304          TVec<PFltV> aHist;
305          int *histID;
306          int hcount;
307          double *aOld;
308          double *sOld;
309      };
310      template <class TVal>
311      class THeap {
312      private:
313          int size;
314          int n;
315          TVal *array;
316      public:
317          THeap(const int& ss): size(ss), n(0) {
318              if (size > 0) array = new TVal[size+1];
319              else array = NULL;
320          }
321          ~THeap() { if (array != NULL) delete[] array; }
322          TVal Top() { Assert(n > 0); return array[1]; }
323          bool Full() { return size == n; }
324          int Size() { return n; }
325          TVal* Array() { return array; }
326          void Add(const TVal& elt);
327          void ChangeTop(const TVal& elt);
328      };
329      struct TMaxHeapVal {
330          int id; double val;
331          bool operator>(const TMaxHeapVal& heapVal) const { return val > heapVal.val; }
332      };
333      struct TMinHeapVal {
334          int id; double val;
335          bool operator>(const TMinHeapVal& heapVal) const { return val < heapVal.val; }
336      };
337      typedef THeap<TMaxHeapVal> TMaxHeap;
338      typedef THeap<TMinHeapVal> TMinHeap;
339  private:
340      int verbosity;
341      double epsilon_ter;
342      bool is_linear;
343      PKernel nonlin_kernel;
344      TRnd rnd;
345      PSVMTrainSet docs;
346      double *p;
347      double *y;
348      double D;
349      double *C;
350      double *alphaV;
351      double base;
352      double *weightV;
353      double *gradV;
354      double *listV;
355      int *workingSet;
356      bool *used;
357      TVec<double *> cols;
358      int iter;
359      bool shrinking;
360      TShrinkState *shrink;
361      int *USV;
362      int *BSV;
363      int *NSV;
364      int numUSV, numBSV, numNSV;
365      int h;
366      int minNumElts;
367      double max_violation;
368      TSVMCache cache;
369      int cache_yes, cache_no;
370      int kernel_count;
371      double kernel(const int& i, const int& j) const;
372      void readColumnRows(const int& i, const int& len, int *ids,
373                          double *result, const bool& store, const bool& sync);
374      void column(const int& i, double *result);
375      void calcColumns(const int& n);
376      void initializeCache(const int& memory_size, int& size);
377      void initialize(const TFltV& _pV, const TFltV& _yV,
378                      const double& _D, const TFltV& _CV, const int& size);
379      void dealocate();
380      void initRelearning(TFltV& alphas);
381      void initNonzeroD(const int& size);
382      int selectWorkingSet(const int& n, const bool& random);
383      void adjustS(const int& n, double* newAlphaV);
384      double checkOptimality(double leq);
385      void shrinkInitialize();
386      double shrinkCheckOptimality(int step, const double& leq);
387      void shrinkReduce();
388      void shrinkReactivate();
389      typedef int64 TSVMTime;
390      TSVMTime GetCurrentTime();
391      double ToSeconds(TSVMTime time);
392      UndefDefaultCopyAssign(TSVMQPSolver);
393  public:
394      TSVMQPSolver(const bool& lin, const PKernel& ker, const int& verb = 0,
395        const double& eps_ter = 1e-3, const bool& _shrinking = true,
396        const int& _h = 10, const int& _minNumElts = 10):
397          verbosity(verb),
398          epsilon_ter(eps_ter), is_linear(lin), nonlin_kernel(ker),
399          shrinking(_shrinking), h(_h), minNumElts(_minNumElts), cache(verbosity) {};
400      void optimize(TFltV& alphas, double& _base, const PSVMTrainSet& _docs,
401              const TFltV& _pV, const TFltV& _yV, const double& _D,
402              const TFltV& _CV, const int& sub_size, const int& memory_size,
403              const int& time);
404  };
405  class TSVMLargeScale {
406  public:
407      static void Solve(PSVMTrainSet TrainSet, const double& SvmCost,
408          const double& AccuracyEps, const int& MxTime, const bool& TillMxIter,
409          const int& ProcN, TFltV& WgtV, PNotify Notify = TStdNotify::New());
410  };
411  class TSVMLearnParam {
412  public:
413      TInt Time;    
414      TInt MemSize; 
415      TInt Verbosity;
416      TInt SubSize; 
417      TFlt EpsTer;  
418      TBool Shrink; 
419  public:
420      TSVMLearnParam(const int& _Time = -1, const int& _MemSize = 50, const int _Verbosity = 0,
421          const int& _SubSize = 10, const double& _EpsTer = 1e-3, const bool& _Shrink = true):
422              Time(_Time), MemSize(_MemSize), Verbosity(_Verbosity),
423              SubSize(_SubSize), EpsTer(_EpsTer), Shrink(_Shrink) { };
424      TSVMLearnParam(TSIn &SIn): Time(SIn), MemSize(SIn), Verbosity(SIn),
425          SubSize(SIn), EpsTer(SIn), Shrink(SIn) { }
426      static TSVMLearnParam Load(TSIn &SIn) { return TSVMLearnParam(SIn); }
427      void Save(TSOut &SOut) const {
428          Time.Save(SOut); MemSize.Save(SOut); Verbosity.Save(SOut);
429          SubSize.Save(SOut); EpsTer.Save(SOut); Shrink.Save(SOut);
430      }
431      static TSVMLearnParam Lin(const int& _Time = -1, const int _Verbosity = 0,
432          const int& _SubSize = 30, const double& _EpsTer = 1e-3, const bool& _Shrink = true) {
433              return TSVMLearnParam(_Time, 1, _Verbosity, _SubSize, _EpsTer, _Shrink); }
434      static TSVMLearnParam NonLin(const int& _Time = -1, const int& _MemSize = 50, const int _Verbosity = 0,
435          const int& _SubSize = 10, const double& _EpsTer = 1e-3, const bool& _Shrink = true) {
436              return TSVMLearnParam(_Time, _MemSize, _Verbosity, _SubSize, _EpsTer, _Shrink); }
437  };
438  typedef enum { smtClassifier, smtOneClass, smtRegression } TSVMModelType;
439  class TSVMModelParam {
440  public:
441      TSVMModelType ModelType;
442      TFlt C; 
443      TFlt j; 
444      TFlt nu; 
445      TFlt E; 
446  public:
447      TSVMModelParam(const TSVMModelType& _ModelType, const double& _CVal,
448        const double& _j, const double& _nu, const double& _E):
449          ModelType(_ModelType), C(_CVal), j(_j), nu(_nu), E(_E) { };
450      static TSVMModelParam Classification(const double& _CVal, const double& _j) {
451          return TSVMModelParam(smtClassifier, _CVal, _j, 0.0, 0.0); }
452      static TSVMModelParam OneClass(const double& _nu) {
453          return TSVMModelParam(smtOneClass, 0.0, 0.0, _nu, 0.0); }
454      static TSVMModelParam Regression(const double& _E, const double& _CVal) {
455          return  TSVMModelParam(smtRegression, _CVal, 0.0, 0.0, _E); }
456  };
457  class TSVMFactory {
458  public:
459      static void trainClassifier(TFltV& alphas, double& threshold,
460          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
461          const double& C, const double& j, const TSVMLearnParam& LearnParam);
462      static void trainOneClass(TFltV& alphas, double& threshold,
463          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
464          const double& nu, const TSVMLearnParam& LearnParam);
465      static void trainRegression(TFltV& alphas, double& threshold,
466          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
467          const double& E, const double& C, const TSVMLearnParam& LearnParam);
468      static void train(TFltV& alphas, double& threshold,
469          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
470          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam);
471  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ultra.cpp</h3>
            <pre><code>1  #include "ultra.h"
2  TGasDef::TGasDef(const bool& DbP):
3    FldNmTyUseTrV(){
4    if (DbP){
5      LocIdFldN=FldNmTyUseTrV.Add(TStrTr("LocationID", "int", "meta"));
6      ProdIdFldN=FldNmTyUseTrV.Add(TStrTr("ProductID", "int", "meta"));
7      DateFldN=FldNmTyUseTrV.Add(TStrTr("Date", "date", "active"));
8      DayNFldN=FldNmTyUseTrV.Add(TStrTr("Day", "int", "active"));
9      MonthNFldN=FldNmTyUseTrV.Add(TStrTr("Month", "int", "active"));
10      YearNFldN=FldNmTyUseTrV.Add(TStrTr("Year", "int", "active"));
11      HourNFldN=FldNmTyUseTrV.Add(TStrTr("HourStart", "int", "active"));
12      FldNmTyUseTrV.Add(TStrTr("HourEnd", "int", "active"));
13      DowNFldN=FldNmTyUseTrV.Add(TStrTr("DayOfWeek", "dow", "active"));
14      IsHolidayFldN=FldNmTyUseTrV.Add(TStrTr("ISHoliday", "int", "active"));
15      IsHolidayStartFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayStart", "int", "active"));
16      IsHolidayEndFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayEnd", "int", "active"));
17      IsDayBeforeHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayBeforeHoliday", "int", "active"));
18      IsDayAfterHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayAfterHoliday", "int", "active"));
19      VolFldN=FldNmTyUseTrV.Add(TStrTr("VolumeStart", "int", "active"));
20      CsptFldN=FldNmTyUseTrV.Add(TStrTr("Cnsmptn", "int", "active"));
21      FldNmTyUseTrV.Add(TStrTr("Interpolation", "int", "active"));
22      CsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1W", "int", "active"));
23      CsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2W", "int", "active"));
24      CsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3W", "int", "active"));
25      SumCsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1W", "int", "active"));
26      SumCsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2W", "int", "active"));
27      SumCsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3W", "int", "active"));
28      CsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1D", "int", "active"));
29      CsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2D", "int", "active"));
30      CsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3D", "int", "active"));
31      CsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast4D", "int", "active"));
32      CsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast5D", "int", "active"));
33      CsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast6D", "int", "active"));
34      SumCsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1D", "int", "active"));
35      SumCsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2D", "int", "active"));
36      SumCsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3D", "int", "active"));
37      SumCsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast4D", "int", "active"));
38      SumCsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast5D", "int", "active"));
39      SumCsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast6D", "int", "active"));
40      PriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("PriceChange", "int", "active"));
41      DaysBeforePriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("DaysBeforePriceChange", "int", "active"));
42    } else {
43      LocIdFldN=FldNmTyUseTrV.Add(TStrTr("LocationID", "int", "meta"));
44      TankIdFldN=FldNmTyUseTrV.Add(TStrTr("TankID", "int", "meta"));
45      ProdIdFldN=FldNmTyUseTrV.Add(TStrTr("ProductID", "int", "meta"));
46      DateFldN=FldNmTyUseTrV.Add(TStrTr("Date", "date", "active"));
47      HourNFldN=FldNmTyUseTrV.Add(TStrTr("HourStart", "int", "active"));
48      FldNmTyUseTrV.Add(TStrTr("HourEnd", "int", "active"));
49      CsptFldN=FldNmTyUseTrV.Add(TStrTr("Cnsmptn", "int", "active"));
50      VolFldN=FldNmTyUseTrV.Add(TStrTr("VolumeStart", "int", "active"));
51      FldNmTyUseTrV.Add(TStrTr("Interpolation", "int", "active"));
52      CsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1W", "int", "active"));
53      CsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2W", "int", "active"));
54      CsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3W", "int", "active"));
55      SumCsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1W", "int", "active"));
56      SumCsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2W", "int", "active"));
57      SumCsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3W", "int", "active"));
58      CsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1D", "int", "active"));
59      CsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2D", "int", "active"));
60      CsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3D", "int", "active"));
61      CsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast4D", "int", "active"));
62      CsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast5D", "int", "active"));
63      CsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast6D", "int", "active"));
64      SumCsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1D", "int", "active"));
65      SumCsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2D", "int", "active"));
66      SumCsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3D", "int", "active"));
67      SumCsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast4D", "int", "active"));
68      SumCsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast5D", "int", "active"));
69      SumCsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast6D", "int", "active"));
70      DayNFldN=FldNmTyUseTrV.Add(TStrTr("Day", "int", "active"));
71      MonthNFldN=FldNmTyUseTrV.Add(TStrTr("Month", "int", "active"));
72      YearNFldN=FldNmTyUseTrV.Add(TStrTr("Year", "int", "active"));
73      DowNFldN=FldNmTyUseTrV.Add(TStrTr("DayOfWeek", "dow", "active"));
74      IsHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsHoliday", "int", "active"));
75      IsHolidayStartFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayStart", "int", "active"));
76      IsHolidayEndFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayEnd", "int", "active"));
77      IsDayBeforeHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayBeforeHoliday", "int", "active"));
78      IsDayAfterHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayAfterHoliday", "int", "active"));
79      PriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("PriceChange", "int", "active"));
80      DaysBeforePriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("DaysBeforePriceChange", "int", "active"));
81      ProdNmFldN=FldNmTyUseTrV.Add(TStrTr("ProductName", "int", "ignore"));
82      LocNmFldN=FldNmTyUseTrV.Add(TStrTr("LocationName", "int", "ignore"));
83    }
84  }
85  bool TGasDef::IsFldNmVOk(const TStrV& FldNmV) const {
86    if (GetFlds()!=FldNmV.Len()){return false;}
87    for (int FldN=0; FldN<FldNmV.Len(); FldN++){
88      if (FldNmTyUseTrV[FldN].Val1!=FldNmV[FldN]){
89        printf("'%s'!='%s'", FldNmTyUseTrV[FldN].Val1.CStr(), FldNmV[FldN].CStr());
90        return false;
91      }
92    }
93    return true;
94  }
95  void TGasDef::GetFldIntValV(const TStrV& FldStrValV, TIntV& FldIntValV) const {
96    int Flds=GetFlds();
97    EAssertR(Flds==FldStrValV.Len(), "Number of data fields doesn't fit.");
98    FldIntValV.Gen(Flds);
99    for (int FldN=0; FldN<Flds; FldN++){
100      TStrTr& FldNmTyUseTr=FldNmTyUseTrV[FldN];
101      if (FldNmTyUseTr.Val3!="ignore"){
102        if (FldNmTyUseTr.Val2=="int"){
103          if (FldStrValV[FldN]=="True"){FldIntValV[FldN]=1;}
104          else if (FldStrValV[FldN]=="False"){FldIntValV[FldN]=0;}
105          else {FldIntValV[FldN]=FldStrValV[FldN].GetInt();}
106        } else
107        if (FldNmTyUseTr.Val2=="date"){
108          TSecTm Date=TSecTm::GetDtTmFromDmyStr(FldStrValV[FldN]);
109          FldIntValV[FldN]=Date.GetAbsSecs();
110        } else
111        if (FldNmTyUseTr.Val2=="dow"){
112          TStr DowNm=FldStrValV[FldN];
113          if (!DowNm.Empty()){DowNm.PutCh(0, TCh::GetUc(DowNm[0]));}
114          int DowN=TTmInfo::GetDayOfWeekN(DowNm, lSi);
115          FldIntValV[FldN]=DowN;
116        }
117      }
118    }
119  }
120  TSecTm TGasDef::GetTm(const TIntV& FldIntValV) const {
121    int HourN=FldIntValV[HourNFldN];
122    int DayN=FldIntValV[DayNFldN];
123    int MonthN=FldIntValV[MonthNFldN];
124    int YearN=FldIntValV[YearNFldN];
125    TSecTm Tm=TSecTm::GetDtTm(YearN, MonthN, DayN);
126    Tm.AddHours(HourN);
127    return Tm;
128  }
129  void TGasDef::GetHdm(
130   const TIntV& FldIntValV, int& HourN, int& DowN, int& MonthN) const {
131    HourN=FldIntValV[HourNFldN];
132    DowN=FldIntValV[DowNFldN]-1;
133    MonthN=FldIntValV[MonthNFldN]-1;
134  }
135  TSecTm TGasLtpBs::GetMnDate() const {
136    TSecTm MnDate;
137    int Recs=GetRecs();
138    for (int RecN=0; RecN<Recs; RecN++){
139      TSecTm Date=GetDate(RecN);
140      if ((RecN==0)||(Date<MnDate)){MnDate=Date;}
141    }
142    return MnDate;
143  }
144  TSecTm TGasLtpBs::GetMxDate() const {
145    TSecTm MxDate;
146    int Recs=GetRecs();
147    for (int RecN=0; RecN<Recs; RecN++){
148      TSecTm Date=GetDate(RecN);
149      if ((RecN==0)||(Date>MxDate)){MxDate=Date;}
150    }
151    return MxDate;
152  }
153  void TGasLtpBs::GenStat(){
154    TMom::NewV(HourMomV, 24);
155    TMom::NewV(DowMomV, 7);
156    TMom::NewV(MonthMomV, 12);
157    TMom::NewVV(DowHourMomVV, 7, 24);
158    int Recs=GetRecs();
159    for (int RecN=0; RecN<Recs; RecN++){
160      int HourN; int DowN; int MonthN;
161      GasDef->GetHdm(GetRec(RecN), HourN, DowN, MonthN);
162      int Cspt=GasDef->GetCspt(GetRec(RecN));
163      HourMomV[HourN]->Add(Cspt);
164      DowMomV[DowN]->Add(Cspt);
165      MonthMomV[MonthN]->Add(Cspt);
166      DowHourMomVV.At(DowN, HourN)->Add(Cspt);
167    }
168    TMom::DefV(HourMomV);
169    TMom::DefV(DowMomV);
170    TMom::DefV(MonthMomV);
171    TMom::DefVV(DowHourMomVV);
172  }
173  bool TGasLtpBs::IsDowHourMomUsable() const {
174    return
175     TMom::IsUsableV(HourMomV)&&
176     TMom::IsUsableV(DowMomV)&&
177     TMom::IsUsableVV(DowHourMomVV);
178  }
179  void TGasLtpBs::RepairUnknowns(){
180    if (!IsDowHourMomUsable()){
181      printf("*** Error: day-of-week & hour statistics cannot be generated (not enough data)!\n");
182      printf("*** Can not repair data!\n");
183      return;
184    }
185    int Recs=GetRecs();
186    for (int RecN=0; RecN<Recs; RecN++){
187      int RecHourN; int RecDowN; int RecMonthN;
188      GetHdm(RecN, RecHourN, RecDowN, RecMonthN);
189      TSecTm RecTm=GetTm(RecN);
190      TSecTm RecDate=GetDate(RecN);
191      TStr Str=RecTm.GetStr();
192      if (RecN>0){
193        int DSecs=TSecTm::GetDSecs(GetTm(RecN-1), RecTm);
194        if (DSecs!=3600){
195          printf("*** Error - records not at hour interval (%s - %s)!\n",
196           GetTm(RecN-1).GetStr().CStr(), RecTm.GetStr().CStr());
197        }
198      }
199      if (GetCspt(RecN)<0){
200        printf("*** Error: consumption is negative (%d)!\n", GetCspt(RecN));
201        printf("*** Can not repair data!\n");
202        return;
203      }
204      if (GetCsptLast1D(RecN)==-1){
205        GetCsptLast1D(RecN)=DowHourMomVV.At((RecDowN+7-1)%7, RecHourN)->GetMedian();}
206      if (GetCsptLast2D(RecN)==-1){
207        GetCsptLast2D(RecN)=DowHourMomVV.At((RecDowN+7-2)%7, RecHourN)->GetMedian();}
208      if (GetCsptLast3D(RecN)==-1){
209        GetCsptLast3D(RecN)=DowHourMomVV.At((RecDowN+7-3)%7, RecHourN)->GetMedian();}
210      if (GetCsptLast4D(RecN)==-1){
211        GetCsptLast4D(RecN)=DowHourMomVV.At((RecDowN+7-4)%7, RecHourN)->GetMedian();}
212      if (GetCsptLast5D(RecN)==-1){
213        GetCsptLast5D(RecN)=DowHourMomVV.At((RecDowN+7-5)%7, RecHourN)->GetMedian();}
214      if (GetCsptLast6D(RecN)==-1){
215        GetCsptLast6D(RecN)=DowHourMomVV.At((RecDowN+7-6)%7, RecHourN)->GetMedian();}
216      if (GetSumCsptLast1D(RecN)==-1){
217        GetSumCsptLast1D(RecN)=DowMomV[(RecDowN+7-1)%7]->GetMedian();}
218      if (GetSumCsptLast2D(RecN)==-1){
219        GetSumCsptLast2D(RecN)=DowMomV[(RecDowN+7-2)%7]->GetMedian();}
220      if (GetSumCsptLast3D(RecN)==-1){
221        GetSumCsptLast3D(RecN)=DowMomV[(RecDowN+7-1)%7]->GetMedian();}
222      if (GetSumCsptLast4D(RecN)==-1){
223        GetSumCsptLast4D(RecN)=DowMomV[(RecDowN+7-4)%7]->GetMedian();}
224      if (GetSumCsptLast5D(RecN)==-1){
225        GetSumCsptLast5D(RecN)=DowMomV[(RecDowN+7-5)%7]->GetMedian();}
226      if (GetSumCsptLast6D(RecN)==-1){
227        GetSumCsptLast6D(RecN)=DowMomV[(RecDowN+7-6)%7]->GetMedian();}
228      if (GetCsptLast1W(RecN)==-1){
229        GetCsptLast1W(RecN)=DowHourMomVV.At(RecDowN, RecHourN)->GetMedian();}
230      if (GetCsptLast2W(RecN)==-1){
231        GetCsptLast2W(RecN)=DowHourMomVV.At(RecDowN, RecHourN)->GetMedian();}
232      if (GetCsptLast3W(RecN)==-1){
233        GetCsptLast3W(RecN)=DowHourMomVV.At(RecDowN, RecHourN)->GetMedian();}
234      if (GetSumCsptLast1W(RecN)==-1){
235        GetSumCsptLast1W(RecN)=DowMomV[RecDowN]->GetMedian();}
236      if (GetSumCsptLast2W(RecN)==-1){
237        GetSumCsptLast2W(RecN)=DowMomV[RecDowN]->GetMedian();}
238      if (GetSumCsptLast3W(RecN)==-1){
239        GetSumCsptLast3W(RecN)=DowMomV[RecDowN]->GetMedian();}
240    }
241  }
242  void TGasLtpBs::SaveStatTxt(const PSOut& SOut) const {
243    SOut->PutStr("==========================================================");
244    SOut->PutLn();
245    SOut->PutStr(LtpNm); SOut->PutStr("  /  ");
246    SOut->PutStr(LocNm); SOut->PutStr("  /  ");
247    SOut->PutStr(ProdNm); SOut->PutLn();
248    SOut->PutStr("Consumption per Hour");
249    SOut->PutLn();
250    for (int HourN=0; HourN<24; HourN++){
251      SOut->PutInt(HourN); SOut->PutStr(": ");
252      SOut->PutStr(HourMomV[HourN]->GetStr(' ', ':', true));
253      SOut->PutLn();
254    }
255    SOut->PutStr("Consumption per Day-Of-Week");
256    SOut->PutLn();
257    for (int DowN=0; DowN<7; DowN++){
258      SOut->PutStr(TTmInfo::GetDayOfWeekNm(DowN+1)); SOut->PutStr(": ");
259      SOut->PutStr(DowMomV[DowN]->GetStr(' ', ':', true));
260      SOut->PutLn();
261    }
262    SOut->PutStr("Consumption per Month");
263    SOut->PutLn();
264    for (int MonthN=0; MonthN<12; MonthN++){
265      SOut->PutStr(TTmInfo::GetMonthNm(MonthN+1)); SOut->PutStr(": ");
266      SOut->PutStr(MonthMomV[MonthN]->GetStr(' ', ':', true));
267      SOut->PutLn();
268    }
269    SOut->PutStr("Consumption per Day-Of-Week&Hour");
270    SOut->PutLn();
271    {for (int DowN=0; DowN<7; DowN++){
272      for (int HourN=0; HourN<24; HourN++){
273        SOut->PutStr(TTmInfo::GetDayOfWeekNm(DowN+1)); SOut->PutStr("/");
274        SOut->PutInt(HourN); SOut->PutStr(": ");
275        SOut->PutStr(DowHourMomVV.At(DowN, HourN)->GetStr(' ', ':', true));
276        SOut->PutLn();
277      }
278    }}
279    SOut->Flush();
280  }
281  void TGasLtpBs::SaveStatBin(const PSOut& SOut) const {
282    PGasLtpBs StatLtpBs=TGasLtpBs::New(LtpNm, LocNm, ProdNm);
283    StatLtpBs->HourMomV=HourMomV;
284    StatLtpBs->DowMomV=DowMomV;
285    StatLtpBs->MonthMomV=MonthMomV;
286    StatLtpBs->DowHourMomVV=DowHourMomVV;
287    StatLtpBs->Save(*SOut);
288    SOut->Flush();
289  }
290  void TGasLtpBs::LoadStatV(const TStr& FNm, TGasLtpBsV& GasLtpBsV){
291    GasLtpBsV.Clr();
292    if (TFile::Exists(FNm)){
293      PSIn SIn=TFIn::New(FNm);
294      while (!SIn->Eof()){
295        PGasLtpBs GasLtpBs=TGasLtpBs::Load(*SIn);
296        GasLtpBsV.Add(GasLtpBs);
297      }
298    }
299  }
300  void TGasLtpBs::ConvTabToLtp(const TStr& InTabFNmWc, const TStr& OutLtpFPath,
301   const bool& RepairUnknownsP){
302    PGasDef GasDef=TGasDef::New();
303    TStr OutLtpNrFPath=TStr::GetNrFPath(OutLtpFPath);
304    PGasLtpBs GasLtpBs; TStr LtpNm; TSecTm PrevLtpTm;
305    PSOut LtpStatTxtSOut=TFOut::New(OutLtpNrFPath+LtpStatTxtFNm);
306    PSOut LtpStatBinSOut=TFOut::New(OutLtpNrFPath+LtpStatBinFNm);
307    TFFile FFile(InTabFNmWc, false); TStr FNm; int Recs=0;
308    while (FFile.Next(FNm)){
309      printf("Processing file '%s'\n", FNm.CStr());
310      PSIn SIn=TFIn::New(FNm);
311      char PrevCh=' '; TStrV FldNmV;
312      TSs::LoadTxtFldV(ssfTabSep, SIn, PrevCh, FldNmV);
313      EAssertR(GasDef->IsFldNmVOk(FldNmV), TStr("Field names don't fit in ")+FNm);
314      int LnN=0;
315      while (!SIn->Eof()){
316        char PrevCh=' '; TStrV FldStrValV;
317        TSs::LoadTxtFldV(ssfTabSep, SIn, PrevCh, FldStrValV); LnN++;
318        if (LtpNm!=GasDef->GetLtpNm(FldStrValV)){
319          if (!GasLtpBs.Empty()){
320            GasLtpBs->GenStat();
321            if (RepairUnknownsP){GasLtpBs->RepairUnknowns();}
322            GasLtpBs->SaveStatTxt(LtpStatTxtSOut);
323            GasLtpBs->SaveStatBin(LtpStatBinSOut);
324            TStr LtpFNm=OutLtpNrFPath+GasDef->GetLtpFNm(LtpNm);
325            {TFOut LtpSOut(LtpFNm); GasLtpBs->Save(LtpSOut);}
326            PGasLtpBs NewGasLtpBs=TGasLtpBs::Load(LtpFNm);
327          }
328          LtpNm=GasDef->GetLtpNm(FldStrValV);
329          TStr LocNm=GasDef->GetLocNm(FldStrValV);
330          TStr ProdNm=GasDef->GetProdNm(FldStrValV);
331          GasLtpBs=TGasLtpBs::New(LtpNm, LocNm, ProdNm, GasDef);
332          PrevLtpTm.Undef();
333          printf("Processing Ltp: '%s' '%s' '%s'\n",
334           LtpNm.CStr(), LocNm.CStr(), ProdNm.CStr());
335        }
336        TIntV& FldIntValV=GasLtpBs->AddRec();
337        GasDef->GetFldIntValV(FldStrValV, FldIntValV);
338        TSecTm LtpTm=GasDef->GetTm(FldIntValV);
339        if (PrevLtpTm.IsDef()){
340          if (PrevLtpTm>=LtpTm){
341            printf("Time is not increasing [Line:%d PrevTime:%s CurTime:%s]\n",
342             LnN, PrevLtpTm.GetStr().CStr(), LtpTm.GetStr().CStr());
343          }
344          if (TSecTm::GetDSecs(PrevLtpTm, LtpTm)!=3600){
345            printf("Not one hour difference between subsequent records "
346             "[Line:%d PrevTime:%s CurTime:%s]\n",
347             LnN, PrevLtpTm.GetStr().CStr(), LtpTm.GetStr().CStr());
348          }
349          EAssertR(PrevLtpTm<LtpTm, "Records not in increased time sequence.");
350        }
351        PrevLtpTm=LtpTm;
352        Recs++; if (Recs%1000==0){printf("%d\r", Recs);}
353      }
354    }
355    if (!GasLtpBs.Empty()){
356      GasLtpBs->GenStat();
357      if (RepairUnknownsP){GasLtpBs->RepairUnknowns();}
358      GasLtpBs->SaveStatTxt(LtpStatTxtSOut);
359      GasLtpBs->SaveStatBin(LtpStatBinSOut);
360      TStr LtpFNm=OutLtpNrFPath+GasDef->GetLtpFNm(LtpNm);
361      {TFOut LtpSOut(LtpFNm); GasLtpBs->Save(LtpSOut);}
362      PGasLtpBs NewGasLtpBs=TGasLtpBs::Load(LtpFNm);
363    }
364  }
365  const TStr TGasLtpBs::LtpStatTxtFNm="LtpStat.Txt";
366  const TStr TGasLtpBs::LtpStatBinFNm="LtpStat.Dat";
367  int TGasDm::AddVar(const TStr& VarNm, const TStr& VarTy){
368    IAssert((!VarNmTyKdV.IsIn(TStrKd(VarNm)))&&(VarValVV.Empty()));
369    int VarN=VarNmTyKdV.Add(TStrKd(VarNm, VarTy));
370    if (VarTy=="class"){IAssert(ClassVarN==-1); ClassVarN=VarN;}
371    if (VarTy=="date"){IAssert(DateVarN==-1); DateVarN=VarN;}
372    if (VarTy=="volume"){IAssert(VolVarN==-1); VolVarN=VarN;}
373    if (VarTy=="attr"){Attrs++;}
374    return VarN;
375  }
376  void TGasDm::GetAttrNmV(TStrV& AttrNmV) const {
377    AttrNmV.Gen(Attrs, 0);
378    for (int VarN=0; VarN<GetVars(); VarN++){
379      if (GetVarTy(VarN)=="attr"){
380        AttrNmV.Add(GetVarNm(VarN));
381      }
382    }
383  }
384  int TGasDm::GetAttrN(const TStr& AttrNm) const {
385    TStrV AttrNmV; GetAttrNmV(AttrNmV);
386    return AttrNmV.SearchForw(AttrNm);
387  }
388  TStr TGasDm::GetClassNm() const {
389    for (int VarN=0; VarN<GetVars(); VarN++){
390      if (GetVarTy(VarN)=="class"){
391        return GetVarNm(VarN);
392      }
393    }
394    Fail;
395    return TStr();
<span onclick='openModal()' class='match'>396  }
397  void TGasDm::GetRecNV(
398   const TSecTm& StartDate, const TSecTm& EndDate,
399   const int& StartRecN, const int& EndRecN, const double& MnCspt, TIntV& RecNV){
</span>400    if ((StartDate.IsDef()&&EndDate.IsDef())){
401      IAssert((StartRecN==-1)&&(EndRecN==-1));
402      RecNV.Clr(); int Recs=GetRecs();
403      for (int RecN=0; RecN<Recs; RecN++){
404        TSecTm RecDate=GetDateVal(RecN);
405        if ((StartDate.IsDef()&&(RecDate<StartDate))||
406         (EndDate.IsDef()&&(EndDate<RecDate))){continue;}
407        if ((MnCspt!=-1)&&(GetClassVal(RecN)<MnCspt)){continue;}
408        RecNV.Add(RecN);
409      }
410    } else
411    if ((StartRecN!=-1)&&(EndRecN!=-1)){
412      IAssert((!StartDate.IsDef())&&(!EndDate.IsDef()));
413      RecNV.Clr();
414      for (int RecN=StartRecN; RecN<=EndRecN; RecN++){
415        RecNV.Add(RecN);
416      }
417    } else {
418      Fail;
419    }
420  }
421  void TGasDm::GetAttrValV(const int& RecN, TFltV& AttrValV) const {
422    AttrValV.Gen(Attrs, 0);
423    for (int VarN=0; VarN<GetVars(); VarN++){
424      if (GetVarTy(VarN)=="attr"){
425        AttrValV.Add(VarValVV[RecN][VarN]);
426      }
427    }
428  }
429  double TGasDm::GetAttrVal(
430   const int& RecN, const int& AttrN, const double& DfVal) const {
431    TFltV AttrValV; GetAttrValV(RecN, AttrValV);
432    if (AttrN==-1){return DfVal;}
433    else {return AttrValV[AttrN];}
434  }
435  double TGasDm::GetAttrVal(
436   const int& RecN, const TStr& AttrNm, const double& DfVal) const {
437    TFltV AttrValV; GetAttrValV(RecN, AttrValV);
438    int AttrN=GetAttrN(AttrNm);
439    if (AttrN==-1){return DfVal;}
440    else {return AttrValV[AttrN];}
441  }
442  TStr TGasDm::GetBitsStr(const int& RecN) const {
443    double IsHolidayVal=GetAttrVal(RecN, "IsHoliday", 0);
444    double IsHolidayStartVal=GetAttrVal(RecN, "IsHolidayStart", 0);
445    double IsHolidayEndVal=GetAttrVal(RecN, "IsHolidayEnd", 0);
446    double IsDayBeforeHolidayVal=GetAttrVal(RecN, "IsDayBeforeHoliday", 0);
447    double IsDayAfterHolidayVal=GetAttrVal(RecN, "IsDayAfterHoliday", 0);
448    double PriceChangeVal=GetAttrVal(RecN, "PriceChange", 0);
449    double DaysBeforePriceChangeVal=GetAttrVal(RecN, "DaysBeforePriceChange", 0);
450    TChA ChA;
451    if (IsHolidayVal!=0){ChA+=" IsHoliday";}
452    if (IsHolidayStartVal!=0){ChA+=" IsHolidayStart";}
453    if (IsHolidayEndVal!=0){ChA+=" IsHolidayEnd";}
454    if (IsDayBeforeHolidayVal!=0){ChA+=" IsDayBeforeHoliday";}
455    if (IsDayAfterHolidayVal!=0){ChA+=" IsDayAfterHoliday";}
456    if (PriceChangeVal!=0){ChA+=" PriceChange:"; ChA+=TFlt::GetStr(PriceChangeVal);}
457    if (DaysBeforePriceChangeVal!=0){
458      ChA+=" DaysBeforePriceChange:"; ChA+=TFlt::GetStr(DaysBeforePriceChangeVal);
459      if (RecN+1<GetRecs()){
460        ChA+=TFlt::GetStr(GetAttrVal(RecN+1, "PriceChange", 0), "(%g%%)");}
461    }
462    return ChA;
463  }
464  PGasDm TGasDm::GetWeekGasDm(const PGasLtpBs& GasLtpBs){
465    TIntIntH DayNToCsptH;
466    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
467      int DayN=GasLtpBs->GetDateInt(RecN);
468      DayNToCsptH.AddDat(DayN)+=GasLtpBs->GetCspt(RecN);
469    }
470    TSecTm MnLtpDate=GasLtpBs->GetMnDate();
471    TSecTm MxLtpDate=GasLtpBs->GetMxDate();
472    typedef TKeyDat<TSecTm, TInt> TDateCsptKd;
473    TVec<TDateCsptKd> DateCsptKdV;
474    for (TSecTm LtpDate=MnLtpDate; LtpDate<MxLtpDate; LtpDate.AddDays(1)){
475      int DayN=LtpDate.GetAbsSecs();
476      if (!DayNToCsptH.IsKey(DayN)){continue;}
477      int Cspt=DayNToCsptH.GetDat(DayN);
478      if (LtpDate.GetDayOfWeekN()==TTmInfo::SunN){
479        DateCsptKdV.Add(TDateCsptKd(LtpDate, 0));}
480      if (DateCsptKdV.Len()>0){
481        DateCsptKdV.Last().Dat+=Cspt;}
482    }
483    PGasDm GasDm=TGasDm::New("Week");
484    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
485    GasDm->PutLocNm(GasLtpBs->GetLocNm());
486    GasDm->PutProdNm(GasLtpBs->GetProdNm());
487    GasDm->AddVar("Date", "date");
488    GasDm->AddVar("Cspt", "class");
489    GasDm->AddVar("Const", "attr");
490    GasDm->AddVar("Month", "attr");
491    GasDm->AddVar("SumCsptLast1W", "attr");
492    GasDm->AddVar("SumCsptLast2W", "attr");
493    GasDm->AddVar("SumCsptLast3W", "attr");
494    GasDm->AddVar("SumCsptLast1D", "attr");
495    GasDm->AddVar("SumCsptLast2D", "attr");
496    GasDm->AddVar("SumCsptLast3D", "attr");
497    GasDm->AddVar("SumCsptLast4D", "attr");
498    GasDm->AddVar("SumCsptLast5D", "attr");
499    GasDm->AddVar("SumCsptLast6D", "attr");
500    GasDm->AddVar("Volume", "volume");
501    {for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
502      TSecTm Date=TSecTm(GasLtpBs->GetDateInt(RecN));
503      int DateCsptKdN=DateCsptKdV.SearchForw(TDateCsptKd(Date));
504      if (DateCsptKdN==-1){continue;}
505      double Cspt=DateCsptKdV[DateCsptKdN].Dat;
506      if (Cspt==-1){continue;}
507      else {DateCsptKdV[DateCsptKdN].Dat=-1;}
508      TFltV VarValV(GasDm->GetVars(), 0);
509      VarValV.Add(GasLtpBs->GetDateInt(RecN));
510      VarValV.Add(Cspt);
511      VarValV.Add(1);
512      VarValV.Add(GasLtpBs->GetMonthN(RecN));
513      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1W(RecN)));
514      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2W(RecN)));
515      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3W(RecN)));
516      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1D(RecN)));
517      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2D(RecN)));
518      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3D(RecN)));
519      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast4D(RecN)));
520      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast5D(RecN)));
521      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast6D(RecN)));
522      if (VarValV.IsIn(-1)){
523        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
524      VarValV.Add(GasLtpBs->GetVol(RecN));
525      GasDm->AddRec(VarValV);
526    }}
527    return GasDm;
528  }
529  PGasDm TGasDm::GetDayGasDm(const PGasLtpBs& GasLtpBs){
530    TIntIntH DayNToCsptH;
531    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
532      int DayN=GasLtpBs->GetDateInt(RecN);
533      DayNToCsptH.AddDat(DayN)+=GasLtpBs->GetCspt(RecN);
534    }
535    PGasDm GasDm=TGasDm::New("Day");
536    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
537    GasDm->PutLocNm(GasLtpBs->GetLocNm());
538    GasDm->PutProdNm(GasLtpBs->GetProdNm());
539    GasDm->AddVar("Date", "date");
540    GasDm->AddVar("Cspt", "class");
541    GasDm->AddVar("Const", "attr");
542    GasDm->AddVar("Dow", "attr");
543    GasDm->AddVar("Month", "attr");
544    GasDm->AddVar("SumCsptLast1W", "attr");
545    GasDm->AddVar("SumCsptLast2W", "attr");
546    GasDm->AddVar("SumCsptLast3W", "attr");
547    GasDm->AddVar("SumCsptLast1D", "attr");
548    GasDm->AddVar("SumCsptLast2D", "attr");
549    GasDm->AddVar("SumCsptLast3D", "attr");
550    GasDm->AddVar("SumCsptLast4D", "attr");
551    GasDm->AddVar("SumCsptLast5D", "attr");
552    GasDm->AddVar("SumCsptLast6D", "attr");
553    GasDm->AddVar("IsHoliday", "attr");
554    GasDm->AddVar("IsHolidayStart", "attr");
555    GasDm->AddVar("IsHolidayEnd", "attr");
556    GasDm->AddVar("IsDayBeforeHoliday", "attr");
557    GasDm->AddVar("IsDayAfterHoliday", "attr");
558    GasDm->AddVar("PriceChange", "attr");
559    GasDm->AddVar("DaysBeforePriceChange", "attr");
560    GasDm->AddVar("Volume", "volume");
561    {for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
562      double Cspt=DayNToCsptH.GetDat(GasLtpBs->GetDateInt(RecN));
563      if (Cspt==-1){continue;}
564      else {DayNToCsptH.GetDat(GasLtpBs->GetDateInt(RecN))=-1;}
565      TFltV VarValV(GasDm->GetVars(), 0);
566      VarValV.Add(GasLtpBs->GetDateInt(RecN));
567      VarValV.Add(Cspt);
568      VarValV.Add(1);
569      VarValV.Add(GasLtpBs->GetDowN(RecN));
570      VarValV.Add(GasLtpBs->GetMonthN(RecN));
571      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1W(RecN)));
572      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2W(RecN)));
573      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3W(RecN)));
574      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1D(RecN)));
575      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2D(RecN)));
576      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3D(RecN)));
577      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast4D(RecN)));
578      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast5D(RecN)));
579      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast6D(RecN)));
580      if (VarValV.IsIn(-1)){
581        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
582      VarValV.Add(GasLtpBs->GetIsHoliday(RecN));
583      VarValV.Add(GasLtpBs->GetIsHolidayStart(RecN));
584      VarValV.Add(GasLtpBs->GetIsHolidayEnd(RecN));
585      VarValV.Add(GasLtpBs->GetIsDayBeforeHoliday(RecN));
586      VarValV.Add(GasLtpBs->GetIsDayAfterHoliday(RecN));
587      VarValV.Add(GasLtpBs->GetPriceChange(RecN));
588      VarValV.Add(GasLtpBs->GetDaysBeforePriceChange(RecN));
589      VarValV.Add(GasLtpBs->GetVol(RecN));
590      GasDm->AddRec(VarValV);
591    }}
592    return GasDm;
593  }
594  void TGasDm::AddCsptBlock(
595   TIntIntH& HourNToCsptH, const int& BlockN, const int& Cspt){
596    if ((!HourNToCsptH.IsKey(BlockN))||(HourNToCsptH.GetDat(BlockN)!=-1)){
597      if (Cspt==-1){
598        HourNToCsptH.AddDat(BlockN)=-1;
599      } else {
600        HourNToCsptH.AddDat(BlockN)=Cspt;
601      }
602    }
603  }
604  PGasDm TGasDm::GetHourBlockGasDm(const PGasLtpBs& GasLtpBs, const int& HourBlockLen){
605    EAssertRA(24%HourBlockLen==0, "Hour resulution not divisible by 24", TInt::GetStr(HourBlockLen));
606    TIntIntH BlockNToCsptH;
607    TIntIntH BlockNToCsptLast1WH;
608    TIntIntH BlockNToCsptLast2WH;
609    TIntIntH BlockNToCsptLast3WH;
610    TIntIntH BlockNToCsptLast1DH;
611    TIntIntH BlockNToCsptLast2DH;
612    TIntIntH BlockNToCsptLast3DH;
613    TIntIntH BlockNToCsptLast4DH;
614    TIntIntH BlockNToCsptLast5DH;
615    TIntIntH BlockNToCsptLast6DH;
616    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
617      int DayN=GasLtpBs->GetDateInt(RecN); IAssert(DayN%100==0);
618      int HourN=GasLtpBs->GetHourN(RecN);
619      IAssert((0<=HourN)&&(HourN<24));
620      int BlockN=DayN+(HourN/HourBlockLen)*HourBlockLen;
621      BlockNToCsptH.AddDat(BlockN)+=GasLtpBs->GetCspt(RecN);
622      AddCsptBlock(BlockNToCsptLast1WH, BlockN, GasLtpBs->GetCsptLast1W(RecN));
623      AddCsptBlock(BlockNToCsptLast2WH, BlockN, GasLtpBs->GetCsptLast2W(RecN));
624      AddCsptBlock(BlockNToCsptLast3WH, BlockN, GasLtpBs->GetCsptLast3W(RecN));
625      AddCsptBlock(BlockNToCsptLast1DH, BlockN, GasLtpBs->GetCsptLast1D(RecN));
626      AddCsptBlock(BlockNToCsptLast2DH, BlockN, GasLtpBs->GetCsptLast2D(RecN));
627      AddCsptBlock(BlockNToCsptLast3DH, BlockN, GasLtpBs->GetCsptLast3D(RecN));
628      AddCsptBlock(BlockNToCsptLast4DH, BlockN, GasLtpBs->GetCsptLast4D(RecN));
629      AddCsptBlock(BlockNToCsptLast5DH, BlockN, GasLtpBs->GetCsptLast5D(RecN));
630      AddCsptBlock(BlockNToCsptLast6DH, BlockN, GasLtpBs->GetCsptLast6D(RecN));
631    }
632    PGasDm GasDm=TGasDm::New(TStr("Hour")+TInt::GetStr(HourBlockLen));
633    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
634    GasDm->PutLocNm(GasLtpBs->GetLocNm());
635    GasDm->PutProdNm(GasLtpBs->GetProdNm());
636    GasDm->AddVar("Date", "date"); 
637    GasDm->AddVar("Cspt", "class"); 
638    GasDm->AddVar("Const", "attr"); 
639    GasDm->AddVar("Hour", "attr"); 
640    GasDm->AddVar("Dow", "attr"); 
641    GasDm->AddVar("Month", "attr"); 
642    GasDm->AddVar("CsptLast1W", "attr");
643    GasDm->AddVar("CsptLast2W", "attr");
644    GasDm->AddVar("CsptLast3W", "attr");
645    GasDm->AddVar("CsptLast1D", "attr");
646    GasDm->AddVar("CsptLast2D", "attr");
647    GasDm->AddVar("CsptLast3D", "attr");
648    GasDm->AddVar("CsptLast4D", "attr");
649    GasDm->AddVar("CsptLast5D", "attr");
650    GasDm->AddVar("CsptLast6D", "attr");
651    GasDm->AddVar("IsHoliday", "attr");
652    GasDm->AddVar("Volume", "volume");
653    {for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
654      int DayN=GasLtpBs->GetDateInt(RecN); IAssert(DayN%100==0);
655      int HourN=GasLtpBs->GetHourN(RecN);
656      IAssert((0<=HourN)&&(HourN<24));
657      int BlockN=DayN+(HourN/HourBlockLen)*HourBlockLen;
658      int BlockHourN=BlockN%100;
659      double Cspt=BlockNToCsptH.GetDat(BlockN);
660      if (Cspt==-1){continue;}
661      else {BlockNToCsptH.GetDat(BlockN)=-1;}
662      TFltV VarValV(GasDm->GetVars(), 0);
663      VarValV.Add(GasLtpBs->GetDateInt(RecN)); 
664      VarValV.Add(Cspt); 
665      VarValV.Add(1); 
666      VarValV.Add(BlockHourN); 
667      VarValV.Add(GasLtpBs->GetDowN(RecN)); 
668      VarValV.Add(GasLtpBs->GetMonthN(RecN)); 
669      VarValV.Add(int(BlockNToCsptLast1WH.GetDat(BlockN))); 
670      VarValV.Add(int(BlockNToCsptLast2WH.GetDat(BlockN))); 
671      VarValV.Add(int(BlockNToCsptLast3WH.GetDat(BlockN))); 
672      VarValV.Add(int(BlockNToCsptLast1DH.GetDat(BlockN))); 
673      VarValV.Add(int(BlockNToCsptLast2DH.GetDat(BlockN))); 
674      VarValV.Add(int(BlockNToCsptLast3DH.GetDat(BlockN))); 
675      VarValV.Add(int(BlockNToCsptLast4DH.GetDat(BlockN))); 
676      VarValV.Add(int(BlockNToCsptLast5DH.GetDat(BlockN))); 
677      VarValV.Add(int(BlockNToCsptLast6DH.GetDat(BlockN))); 
678      VarValV.Add(GasLtpBs->GetIsHoliday(RecN));
679      if (VarValV.IsIn(-1)){
680        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
681      VarValV.Add(GasLtpBs->GetVol(RecN));
682      GasDm->AddRec(VarValV);
683    }}
684    return GasDm;
685  }
686  PGasDm TGasDm::GetHourGasDm(const PGasLtpBs& GasLtpBs){
687    PGasDm GasDm=TGasDm::New();
688    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
689    GasDm->PutLocNm(GasLtpBs->GetLocNm());
690    GasDm->PutProdNm(GasLtpBs->GetProdNm());
691    GasDm->AddVar("Date", "date"); 
692    GasDm->AddVar("Cspt", "class"); 
693    GasDm->AddVar("Const", "attr"); 
694    GasDm->AddVar("Hour", "attr"); 
695    GasDm->AddVar("Dow", "attr"); 
696    GasDm->AddVar("Month", "attr"); 
697    GasDm->AddVar("CsptLast1W", "attr");
698    GasDm->AddVar("CsptLast2W", "attr");
699    GasDm->AddVar("CsptLast3W", "attr");
700    GasDm->AddVar("CsptLast1D", "attr");
701    GasDm->AddVar("CsptLast2D", "attr");
702    GasDm->AddVar("CsptLast3D", "attr");
703    GasDm->AddVar("IsHoliday", "attr");
704    GasDm->AddVar("Volume", "volume");
705    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
706      TFltV VarValV(GasDm->GetVars(), 0);
707      VarValV.Add(GasLtpBs->GetDateInt(RecN)); 
708      VarValV.Add(GasLtpBs->GetCspt(RecN)); 
709      VarValV.Add(1); 
710      VarValV.Add(GasLtpBs->GetHourN(RecN)); 
711      VarValV.Add(GasLtpBs->GetDowN(RecN)); 
712      VarValV.Add(GasLtpBs->GetMonthN(RecN)); 
713      VarValV.Add(TFlt(GasLtpBs->GetCsptLast1W(RecN)));
714      VarValV.Add(TFlt(GasLtpBs->GetCsptLast2W(RecN)));
715      VarValV.Add(TFlt(GasLtpBs->GetCsptLast3W(RecN)));
716      VarValV.Add(TFlt(GasLtpBs->GetCsptLast1D(RecN)));
717      VarValV.Add(TFlt(GasLtpBs->GetCsptLast2D(RecN)));
718      VarValV.Add(TFlt(GasLtpBs->GetCsptLast3D(RecN)));
719      VarValV.Add(GasLtpBs->GetIsHoliday(RecN));
720      if (VarValV.IsIn(-1)){
721        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
722      VarValV.Add(GasLtpBs->GetVol(RecN));
723      GasDm->AddRec(VarValV);
724    }
725    return GasDm;
726  }
727  int TGasDm::AddWeekRec(const double& Cspt){
728    IAssert(TypeNm=="Week");
729    TSecTm PrevDt=GetDateVal(GetRecs()-1);
730    TSecTm TodayDt=TSecTm(PrevDt).AddDays(+7);
731    int TodayRecN=AddRec();
732    if (TodayRecN<=21){
733      TExcept::Throw("Not enough past data - cannot calculate future records.");}
734    PutVarVal(TodayRecN, "Date", TodayDt.GetAbsSecs());
735    PutVarVal(TodayRecN, "Cspt", Cspt);
736    PutVarVal(TodayRecN, "Const", 1);
737    PutVarVal(TodayRecN, "Month", TodayDt.GetMonthN());
738    PutVarVal(TodayRecN, "SumCsptLast1W", GetVarVal(TodayRecN-7, "Cspt"));
739    PutVarVal(TodayRecN, "SumCsptLast2W", GetVarVal(TodayRecN-14, "Cspt"));
740    PutVarVal(TodayRecN, "SumCsptLast3W", GetVarVal(TodayRecN-21, "Cspt"));
741    PutVarVal(TodayRecN, "SumCsptLast1D", GetVarVal(TodayRecN-1, "Cspt"));
742    PutVarVal(TodayRecN, "SumCsptLast2D", GetVarVal(TodayRecN-2, "Cspt"));
743    PutVarVal(TodayRecN, "SumCsptLast3D", GetVarVal(TodayRecN-3, "Cspt"));
744    PutVarVal(TodayRecN, "SumCsptLast4D", GetVarVal(TodayRecN-4, "Cspt"));
745    PutVarVal(TodayRecN, "SumCsptLast5D", GetVarVal(TodayRecN-5, "Cspt"));
746    PutVarVal(TodayRecN, "SumCsptLast6D", GetVarVal(TodayRecN-6, "Cspt"));
747    PutVarVal(TodayRecN, "Volume", -1);
748    return TodayRecN;
749  }
750  int TGasDm::AddDayRec(const double& Cspt){
751    IAssert(TypeNm=="Day");
752    TSecTm PrevDt=GetDateVal(GetRecs()-1);
753    TSecTm TodayDt=TSecTm(PrevDt).AddDays(+1);
754    int TodayRecN=AddRec();
755    if (TodayRecN<=21){
756      TExcept::Throw("Not enough past data - cannot calculate future records.");}
757    PutVarVal(TodayRecN, "Date", TodayDt.GetAbsSecs());
758    PutVarVal(TodayRecN, "Cspt", Cspt);
759    PutVarVal(TodayRecN, "Const", 1);
760    PutVarVal(TodayRecN, "Dow", TodayDt.GetDayOfWeekN());
761    PutVarVal(TodayRecN, "Month", TodayDt.GetMonthN());
762    PutVarVal(TodayRecN, "SumCsptLast1W", GetVarVal(TodayRecN-7, "Cspt"));
763    PutVarVal(TodayRecN, "SumCsptLast2W", GetVarVal(TodayRecN-14, "Cspt"));
764    PutVarVal(TodayRecN, "SumCsptLast3W", GetVarVal(TodayRecN-21, "Cspt"));
765    PutVarVal(TodayRecN, "SumCsptLast1D", GetVarVal(TodayRecN-1, "Cspt"));
766    PutVarVal(TodayRecN, "SumCsptLast2D", GetVarVal(TodayRecN-2, "Cspt"));
767    PutVarVal(TodayRecN, "SumCsptLast3D", GetVarVal(TodayRecN-3, "Cspt"));
768    PutVarVal(TodayRecN, "SumCsptLast4D", GetVarVal(TodayRecN-4, "Cspt"));
769    PutVarVal(TodayRecN, "SumCsptLast5D", GetVarVal(TodayRecN-5, "Cspt"));
770    PutVarVal(TodayRecN, "SumCsptLast6D", GetVarVal(TodayRecN-6, "Cspt"));
771    PutVarVal(TodayRecN, "IsHoliday", 0);
772    PutVarVal(TodayRecN, "IsHolidayStart", 0);
773    PutVarVal(TodayRecN, "IsHolidayEnd", 0);
774    PutVarVal(TodayRecN, "IsDayBeforeHoliday", 0);
775    PutVarVal(TodayRecN, "IsDayAfterHoliday", 0);
776    PutVarVal(TodayRecN, "PriceChange", 0);
777    PutVarVal(TodayRecN, "DaysBeforePriceChange", 0);
778    PutVarVal(TodayRecN, "Volume", -1);
779    return TodayRecN;
780  }
781  int TGasDm::AddHourBlockRec(const double& Cspt){
782    IAssert(TypeNm.IsPrefix("Hour"));
783    TStr HoursResStr=TypeNm.GetSubStr(TStr("Hour").Len(), 999);
784    int HoursRes=HoursResStr.GetInt(1);
785    int RecsPerDay=24/HoursRes;
786    int RecsPerWeek=(7*24)/HoursRes;
787    TSecTm PrevTm=GetDateVal(GetRecs()-1);
788    TSecTm NowTm=TSecTm(PrevTm).AddHours(HoursRes);
789    int NowRecN=AddRec();
790    if (NowRecN<=3*RecsPerWeek){
791      TExcept::Throw("Not enough past data - cannot calculate future records.");}
792    PutVarVal(NowRecN, "Date", NowTm.GetAbsSecs());
793    PutVarVal(NowRecN, "Cspt", Cspt);
794    PutVarVal(NowRecN, "Const", 1);
795    PutVarVal(NowRecN, "Hour", NowTm.GetHourN());
796    PutVarVal(NowRecN, "Dow", NowTm.GetDayOfWeekN());
797    PutVarVal(NowRecN, "Month", NowTm.GetMonthN());
798    PutVarVal(NowRecN, "CsptLast1W", GetVarVal(NowRecN-1*RecsPerWeek, "Cspt"));
799    PutVarVal(NowRecN, "CsptLast2W", GetVarVal(NowRecN-2*RecsPerWeek, "Cspt"));
800    PutVarVal(NowRecN, "CsptLast3W", GetVarVal(NowRecN-3*RecsPerWeek, "Cspt"));
801    PutVarVal(NowRecN, "CsptLast1D", GetVarVal(NowRecN-1*RecsPerDay, "Cspt"));
802    PutVarVal(NowRecN, "CsptLast2D", GetVarVal(NowRecN-2*RecsPerDay, "Cspt"));
803    PutVarVal(NowRecN, "CsptLast3D", GetVarVal(NowRecN-3*RecsPerDay, "Cspt"));
804    PutVarVal(NowRecN, "CsptLast4D", GetVarVal(NowRecN-4*RecsPerDay, "Cspt"));
805    PutVarVal(NowRecN, "CsptLast5D", GetVarVal(NowRecN-5*RecsPerDay, "Cspt"));
806    PutVarVal(NowRecN, "CsptLast6D", GetVarVal(NowRecN-6*RecsPerDay, "Cspt"));
807    PutVarVal(NowRecN, "IsHoliday", 0);
808    PutVarVal(NowRecN, "Volume", -1);
809    return NowRecN;
810  }
811  int TGasDm::AddTmResRec(const double& Cspt){
812    if (TypeNm=="Week"){return AddWeekRec(Cspt);}
813    if (TypeNm=="Day"){return AddDayRec(Cspt);}
814    if (TypeNm.IsPrefix("Hour")){return AddHourBlockRec(Cspt);}
815    else {Fail; return -1;}
816  }
817  void TGasDm::DumpRec(const int& RecN) const {
818    printf("Record[%d]:", RecN);
819    for (int VarN=0; VarN<GetVars(); VarN++){
820      if (GetVarNm(VarN)=="Date"){
821        printf(" [%s:%s]", GetVarNm(VarN).CStr(),
822         TSecTm(int(GetVarVal(RecN, VarN))).GetStr().CStr());
823      } else {
824        printf(" [%s:%g]", GetVarNm(VarN).CStr(), GetVarVal(RecN, VarN));
825      }
826    }
827    printf("\n\n");
828  }
829  void TGasDmHd::GetAttrNmV(TStrV& AttrNmV) const {
830    AttrNmV.Clr();
831    for (int VarN=0; VarN<GetVars(); VarN++){
832      if (GetVarTy(VarN)=="attr"){
833        AttrNmV.Add(GetVarNm(VarN));
834      }
835    }
836  }
837  TStr TGasDmHd::GetClassNm() const {
838    for (int VarN=0; VarN<GetVars(); VarN++){
839      if (GetVarTy(VarN)=="class"){
840        return GetVarNm(VarN);
841      }
842    }
843    Fail;
844    return TStr();
845  }
846  TStr TGasMdMType::GetDescStr() const {
847    if (GetMdTypes()==1){
848      TGasMdType GasMdType=GetMdType(0);
849      return TGasMd::GetGasMdTypeBriefNm(GasMdType);
850    } else {
851      TChA ChA;
852      ChA+="Ensemble(";
853      for (int MdTypeN=0; MdTypeN<GetMdTypes(); MdTypeN++){
854        if (MdTypeN>0){ChA+=' ';}
855        TGasMdType GasMdType=GetMdType(MdTypeN);
856        double Wgt=GetMdWgt(MdTypeN);
857        ChA+=TGasMd::GetGasMdTypeBriefNm(GasMdType);
858        ChA+=":";
859        ChA+=TFlt::GetStr(Wgt, "%.2f");
860      }
861      ChA+=")";
862      return ChA;
863    }
864  }
865  void TGasMdMType::AddMdTypeWgt(const TGasMdType& MdType, const double& MdWgt){
866    if (MdWgt<=0){return;}
867    MdTypeWgtPrV.Add(TIntFltPr(int(MdType), MdWgt));
868  }
869  void TGasMdMType::NrmMdWgt(){
870    double SumMdWgt=0;
871    for (int MdTypeN=0; MdTypeN<GetMdTypes(); MdTypeN++){
872      SumMdWgt+=GetMdWgt(MdTypeN);}
873    {for (int MdTypeN=0; MdTypeN<GetMdTypes(); MdTypeN++){
874      MdTypeWgtPrV[MdTypeN].Val2=MdTypeWgtPrV[MdTypeN].Val2/SumMdWgt;}}
875  }
876  double TGasMd::GetCorPredClassVal(
877   const PGasDm& GasDm, const int& RecN, const double& CorFact) const {
878    double ClassVal=GetPredClassVal(GasDm, RecN);
879    if (GasDm->GetAttrVal(RecN, "DaysBeforePriceChange", 0)==1){
880      ClassVal*=CorFact;}
881    if (ClassVal<0){
882      ClassVal=0;}
883    return ClassVal;
884  }
885  PGasMd TGasMd::New(
886   const TGasMdType& GasMdType,
887   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
888   const PGasDm& GasDm,
889   const TSecTm& StartDate, const TSecTm& EndDate,
890   const int& StartRecN, const int& EndRecN, const double& MnCspt){
891    switch (GasMdType){
892      case gmtCTb: return TGasMdCTb::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
893      case gmtLr: return TGasMdSvd::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
894      case gmtNNbr: return TGasMdNNbr::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
895      case gmtSvm: return TGasMdSvm::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
896      case gmtCubist: return TGasMdCubist::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
897      case gmtRegTree: return TGasMdRegTree::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
898      case gmtEnsemble: return TGasMdEnsemble::New(GasMdMType, GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
899      default: Fail; return NULL;
900    }
901  }
902  TStr TGasMd::GetGasMdTypeNm(const TGasMdType& GasMdType){
903    switch (GasMdType){
904      case gmtCTb: return "Contingency-Table";
905      case gmtLr: return "Singular-Value-Decomposition";
906      case gmtNNbr: return "Nearest-Neigbour";
907      case gmtSvm: return "Support-Vector-Machine";
908      case gmtCubist: return "Cubist";
909      case gmtRegTree: return "Regression-Tree";
910      case gmtEnsemble: return "Ensemble";
911      default: Fail; return TStr();
912    }
913  }
914  TStr TGasMd::GetGasMdTypeBriefNm(const TGasMdType& GasMdType){
915    switch (GasMdType){
916      case gmtCTb: return "ContTb";
917      case gmtLr: return "SVD";
918      case gmtNNbr: return "NNbr";
919      case gmtSvm: return "SVM";
920      case gmtCubist: return "Cubist";
921      case gmtRegTree: return "RTree";
922      case gmtEnsemble: return "Ensemble";
923      default: Fail; return TStr();
924    }
925  }
926  TStr TGasMd::GetMdParamStr(){
927    return
928     "<Model>"
929     "  <ContTable><Moment>Median</Moment></ContTable>"
930     "  <NNbr><K>5</K></NNbr>"
931     "  <Cubist><FileId>CubistData</FileId></Cubist>"
932     "  <Svm><FileId>SvmData</FileId></Svm>"
933     "  <RegTree><MnLeafExs>5</MnLeafExs></RegTree>"
934     "</Model>";
935  }
936  PGasMd TGasMdEnsemble::New(
937   const PGasMdMType& GasMdMType, const TStr& ParamStr, const PGasDm& GasDm,
938   const TSecTm& StartDate, const TSecTm& EndDate,
939   const int& StartRecN, const int& EndRecN, const double& MnCspt){
940    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
941    TGasMdEnsemble* GasMdEnsemble=new TGasMdEnsemble(GasDmHd, GasMdMType);
942    PGasMd GasMd(GasMdEnsemble);
943    for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
944      TGasMdType GasMdType=GasMdMType->GetMdType(MdTypeN);
945      PGasMd SubGasMd=TGasMd::New(GasMdType, NULL, ParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
946      GasMdEnsemble->GasMdV.Add(SubGasMd);
947    }
948    return GasMd;
949  }
950  double TGasMdEnsemble::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
951    IAssert(GetGasDmHd()->IsCompatible(GasDm));
952    double PredClassVal=0;
953    for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
954      double GasMdWgt=GasMdMType->GetMdWgt(MdTypeN);
955      PGasMd SubGasMd=GasMdV[MdTypeN];
956      PredClassVal+=GasMdWgt*SubGasMd->GetPredClassVal(GasDm, RecN);
957    }
958    return PredClassVal;
959  }
960  PMom TGasMdEnsemble::GetClassValMom() const {
961    return GasMdV[0]->GetClassValMom();
962  }
963  void TGasMdEnsemble::Print() const {
964    if (GasMdMType->GetMdTypes()==1){
965      GasMdV[0]->Print();
966    } else {
967      printf("==========================================================\n");
968      printf("ClassVal: %s\n", GetClassValMom()->GetStr(' ', ':', true).CStr());
969      printf("ClassVal =\n");
970      for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
971        TGasMdType GasMdType=GasMdMType->GetMdType(MdTypeN);
972        double GasMdWgt=GasMdMType->GetMdWgt(MdTypeN);
973        printf("    + %g * %s\n", GasMdWgt, TGasMd::GetGasMdTypeNm(GasMdType).CStr());
974      }
975      printf("\n");
976    }
977  }
978  PGasMd TGasMdCTb::New(const TStr& ParamStr, const PGasDm& GasDm,
979   const TSecTm& StartDate, const TSecTm& EndDate,
980   const int& StartRecN, const int& EndRecN, const double& MnCspt){
981    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
982    TGasMdCTb* GasMdCTb=new TGasMdCTb(GasDmHd); PGasMd GasMd(GasMdCTb);
983    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
984    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
985    GasMdCTb->MomNm=ParamXmlDoc->GetTagTokStr("Model|ContTable|Moment");
986    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
987    int Recs=RecNV.Len();
988    GasMdCTb->HourAttrN=GasDm->GetAttrN("Hour");
989    GasMdCTb->DowAttrN=GasDm->GetAttrN("Dow");
990    GasMdCTb->MonthAttrN=GasDm->GetAttrN("Month");
991    GasMdCTb->ClassValMom=TMom::New();
992    TMom::NewV(GasMdCTb->HourMomV, 24);
993    TMom::NewV(GasMdCTb->DowMomV, 7);
994    TMom::NewV(GasMdCTb->MonthMomV, 12);
995    TMom::NewVV(GasMdCTb->DowHourMomVV, 7, 24);
996    for (int RecNN=0; RecNN<Recs; RecNN++){
997      int RecN=RecNV[RecNN];
998      double ClassVal=GasDm->GetClassVal(RecN);
999      int HourN, DowN, MonthN;
1000      if (GasMdCTb->HourAttrN!=-1){HourN=GasDm->GetAttrVal(RecN, GasMdCTb->HourAttrN, 0);}
1001      if (GasMdCTb->DowAttrN!=-1){DowN=GasDm->GetAttrVal(RecN, GasMdCTb->DowAttrN, 0)-1;}
1002      if (GasMdCTb->MonthAttrN!=-1){MonthN=GasDm->GetAttrVal(RecN, GasMdCTb->MonthAttrN, 0)-1;}
1003      GasMdCTb->ClassValMom->Add(ClassVal);
1004      if (GasMdCTb->HourAttrN!=-1){
1005        GasMdCTb->HourMomV[HourN]->Add(ClassVal);}
1006      if (GasMdCTb->DowAttrN!=-1){
1007        GasMdCTb->DowMomV[DowN]->Add(ClassVal);}
1008      if (GasMdCTb->MonthAttrN!=-1){
1009        GasMdCTb->MonthMomV[MonthN]->Add(ClassVal);}
1010      if ((GasMdCTb->DowAttrN!=-1)&&(GasMdCTb->HourAttrN!=-1)){
1011        GasMdCTb->DowHourMomVV.At(DowN, HourN)->Add(ClassVal);}
1012    }
1013    GasMdCTb->ClassValMom->Def();
1014    TMom::DefV(GasMdCTb->HourMomV);
1015    TMom::DefV(GasMdCTb->DowMomV);
1016    TMom::DefV(GasMdCTb->MonthMomV);
1017    TMom::DefVV(GasMdCTb->DowHourMomVV);
1018    return GasMd;
1019  }
1020  double TGasMdCTb::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1021    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1022    int HourN, DowN, MonthN;
1023    if (HourAttrN!=-1){HourN=GasDm->GetAttrVal(RecN, HourAttrN, 0);}
1024    if (DowAttrN!=-1){DowN=GasDm->GetAttrVal(RecN, DowAttrN, 0)-1;}
1025    if (MonthAttrN!=-1){MonthN=GasDm->GetAttrVal(RecN, MonthAttrN, 0)-1;}
1026    PMom Mom1; PMom Mom2;
1027    if ((HourAttrN!=-1)&&(DowAttrN!=-1)){
1028      Mom1=DowHourMomVV.At(DowN, HourN);
1029    } else
1030    if ((DowAttrN!=-1)&&(MonthAttrN!=-1)){
1031      Mom1=DowMomV[DowN];
1032    } else
1033    if (HourAttrN!=-1){
1034      Mom1=HourMomV[HourN];
1035    } else
1036    if (DowAttrN!=-1){
1037      Mom1=DowMomV[DowN];
1038    } else
1039    if (MonthAttrN!=-1){
1040      Mom1=MonthMomV[MonthN];
1041    } else {
1042      Mom1=ClassValMom;
1043    }
1044    double PredClassVal=0;
1045    if (Mom1->IsUsable()){
1046      PredClassVal=Mom1->GetByNm(MomNm);
1047    }
1048    if ((!Mom2.Empty())&&(Mom2->IsUsable())){
1049      PredClassVal=0.5*PredClassVal+0.5*Mom2->GetByNm(MomNm);
1050    }
1051    return PredClassVal;
1052  }
1053  void TGasMdCTb::Print() const {
1054    printf("==========================================================\n");
1055    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1056    printf("per Hour:");
1057    for (int HourN=0; HourN<24; HourN++){
1058      printf(" [%d:%s]", HourN, HourMomV[HourN]->GetStrByNm(MomNm).CStr());}
1059    printf("\n");
1060    printf("per Day-Of-Week:");
1061    for (int DowN=0; DowN<7; DowN++){
1062      printf(" [%s:%s]", TTmInfo::GetDayOfWeekNm(DowN+1).CStr(),
1063       DowMomV[DowN]->GetStrByNm(MomNm).CStr());
1064    }
1065    printf("\n");
1066    printf("per Month:");
1067    for (int MonthN=0; MonthN<12; MonthN++){
1068      printf(" [%s:%s]", TTmInfo::GetMonthNm(MonthN+1).CStr(),
1069       MonthMomV[MonthN]->GetStrByNm(MomNm).CStr());
1070    }
1071    printf("\n");
1072  }
1073  PGasMd TGasMdSvd::New(const TStr& ParamStr, const PGasDm& GasDm,
1074   const TSecTm& StartDate, const TSecTm& EndDate,
1075   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1076    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1077    TGasMdSvd* GasMdSvd=new TGasMdSvd(GasDmHd); PGasMd GasMd(GasMdSvd);
1078    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1079    int Attrs=GasDm->GetAttrs(); int Recs=RecNV.Len();
1080    TFltVV XVV(Recs, Attrs); TFltV YV(Recs); GasMdSvd->ClassValMom=TMom::New();
1081    for (int RecNN=0; RecNN<Recs; RecNN++){
1082      int RecN=RecNV[RecNN];
1083      double ClassVal=GasDm->GetClassVal(RecN);
1084      TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1085      for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1086        XVV.At(RecNN, AttrN)=AttrValV[AttrN];
1087      }
1088      YV[RecNN]=ClassVal;
1089      GasMdSvd->ClassValMom->Add(ClassVal);
1090    }
1091    GasMdSvd->ClassValMom->Def();
1092    PSvd Svd=TSvd::New(XVV, YV);
1093    Svd->GetCfV(GasMdSvd->CfV);
1094    Svd->GetCfUncerV(GasMdSvd->CfUncerV);
1095    GasMdSvd->ChiSq=Svd->GetChiSq();
1096    return GasMd;
1097  }
1098  double TGasMdSvd::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1099    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1100    double PredClassVal=0;
1101    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1102    IAssert(AttrValV.Len()==CfV.Len());
1103    for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1104      PredClassVal+=CfV[AttrN]*AttrValV[AttrN];
1105    }
1106    return PredClassVal;
1107  }
1108  void TGasMdSvd::Print() const {
1109    printf("==========================================================\n");
1110    PGasDmHd GasDmHd=GetGasDmHd();
1111    TStrV AttrNmV; GasDmHd->GetAttrNmV(AttrNmV);
1112    TStr ClassNm=GasDmHd->GetClassNm();
1113    printf("%s = ", ClassNm.CStr());
1114    IAssert((AttrNmV.Len()==CfV.Len())&&(AttrNmV.Len()==CfUncerV.Len()));
1115    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1116      printf("\t%+g * %s\n", CfV[AttrN](), AttrNmV[AttrN].CStr());
1117    }
1118    printf("\n");
1119    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1120  }
1121  PGasMd TGasMdNNbr::New(const TStr& ParamStr, const PGasDm& GasDm,
1122   const TSecTm& StartDate, const TSecTm& EndDate,
1123   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1124    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1125    TGasMdNNbr* GasMdNNbr=new TGasMdNNbr(GasDmHd); PGasMd GasMd(GasMdNNbr);
1126    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1127    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1128    GasMdNNbr->NNbrs=ParamXmlDoc->GetTagTokStr("Model|NNbr|K").GetInt();
1129    IAssert(GasMdNNbr->NNbrs>0);
1130    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1131    int Attrs=GasDm->GetAttrs(); int Recs=RecNV.Len();
1132    GasMdNNbr->AttrValVV.Gen(Recs); TMom::NewV(GasMdNNbr->AttrValMomV, Attrs);
1133    GasMdNNbr->ClassValV.Gen(Recs); GasMdNNbr->ClassValMom=TMom::New();
1134    for (int RecNN=0; RecNN<Recs; RecNN++){
1135      int RecN=RecNV[RecNN];
1136      TFltV& AttrValV=GasMdNNbr->AttrValVV[RecNN];
1137      GasDm->GetAttrValV(RecN, AttrValV);
1138      for (int AttrN=0; AttrN<Attrs; AttrN++){
1139        GasMdNNbr->AttrValMomV[AttrN]->Add(AttrValV[AttrN]);}
1140      double ClassVal=GasDm->GetClassVal(RecN);
1141      GasMdNNbr->ClassValV[RecNN]=ClassVal;
1142      GasMdNNbr->ClassValMom->Add(ClassVal);
1143    }
1144    TMom::DefV(GasMdNNbr->AttrValMomV);
1145    GasMdNNbr->ClassValMom->Def();
1146    return GasMd;
1147  }
1148  double TGasMdNNbr::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1149    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1150    TFltIntKdV DistRecNKdV;
1151    TFltV PredAttrValV; GasDm->GetAttrValV(RecN, PredAttrValV);
1152    for (int AttrValVN=0; AttrValVN<AttrValVV.Len(); AttrValVN++){
1153      TFltV& DmAttrValV=AttrValVV[AttrValVN];
1154      double Dist=0;
1155      for (int AttrN=0; AttrN<PredAttrValV.Len(); AttrN++){
1156        double AttrValDist=PredAttrValV[AttrN]-DmAttrValV[AttrN];
1157        double AttrNrmVal=AttrValMomV[AttrN]->GetMedian();
1158        if (AttrNrmVal!=0){AttrValDist=AttrValDist/AttrNrmVal;}
1159        Dist+=TMath::Sqr(AttrValDist);
1160      }
1161      Dist=sqrt(Dist);
1162      TFltIntKd DistRecNKd(Dist, AttrValVN);
1163      DistRecNKdV.AddSorted(DistRecNKd, true, NNbrs);
1164    }
1165    double PredClassVal=0;
1166    for (int DistRecNKdN=0; DistRecNKdN<DistRecNKdV.Len(); DistRecNKdN++){
1167      int RecN=DistRecNKdV[DistRecNKdN].Dat;
1168      double ClassVal=ClassValV[RecN];
1169      PredClassVal+=ClassVal;
1170    }
1171    if (DistRecNKdV.Len()>0){
1172      PredClassVal=PredClassVal/DistRecNKdV.Len();}
1173    return PredClassVal;
1174  }
1175  TStr TGasMdNNbr::GetPredExpl(const PGasDm& GasDm, const int& RecN) const {
1176    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1177    TFltIntKdV DistRecNKdV;
1178    TFltV PredAttrValV; GasDm->GetAttrValV(RecN, PredAttrValV);
1179    for (int AttrValVN=0; AttrValVN<AttrValVV.Len(); AttrValVN++){
1180      TFltV& DmAttrValV=AttrValVV[AttrValVN];
1181      double Dist=0;
1182      for (int AttrN=0; AttrN<PredAttrValV.Len(); AttrN++){
1183        double AttrValDist=PredAttrValV[AttrN]-DmAttrValV[AttrN];
1184        double AttrNrmVal=AttrValMomV[AttrN]->GetMedian();
1185        if (AttrNrmVal!=0){AttrValDist=AttrValDist/AttrNrmVal;}
1186        Dist+=TMath::Sqr(AttrValDist);
1187      }
1188      Dist=sqrt(Dist);
1189      TFltIntKd DistRecNKd(Dist, AttrValVN);
1190      DistRecNKdV.AddSorted(DistRecNKd, true, NNbrs);
1191    }
1192    TChA PredExplChA;
1193    return PredExplChA;
1194  }
1195  void TGasMdNNbr::Print() const {
1196    printf("==========================================================\n");
1197    printf("Nearest-Neigbours Window-Size: %d\n", NNbrs);
1198    printf("Records: %d\n", AttrValVV.Len());
1199    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1200  }
1201  PGasMd TGasMdCubist::New(
1202   const TStr& ParamStr, const PGasDm& GasDm,
1203   const TSecTm& StartDate, const TSecTm& EndDate,
1204   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1205    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1206    TGasMdCubist* GasMdCubist=new TGasMdCubist(GasDmHd); PGasMd GasMd(GasMdCubist);
1207    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1208    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1209    GasMdCubist->IdFNm=ParamXmlDoc->GetTagTokStr("Model|Cubist|FileId");
1210    TStr IdFNm=GasMdCubist->IdFNm;
1211    PSOut NamesSOut=TFOut::New(IdFNm+".names");
1212    NamesSOut->PutStr(GasDm->GetClassNm()); NamesSOut->PutStr(".\n\n");
1213    NamesSOut->PutStr(GasDm->GetClassNm()); NamesSOut->PutStr(": ");
1214    NamesSOut->PutStr("continuous");
1215    NamesSOut->PutStr(".\n");
1216    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1217    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1218      NamesSOut->PutStr(AttrNmV[AttrN]); NamesSOut->PutStr(": ");
1219      if (AttrNmV[AttrN]=="Dow"){
1220        for (int DowN=0; DowN<7; DowN++){
1221          if (DowN>0){NamesSOut->PutStr(",");}
1222          NamesSOut->PutStr(TTmInfo::GetDayOfWeekNm(DowN+1));
1223        }
1224      } else
1225      if (AttrNmV[AttrN]=="Month"){
1226        for (int MonthN=0; MonthN<12; MonthN++){
1227          if (MonthN>0){NamesSOut->PutStr(",");}
1228          NamesSOut->PutStr(TTmInfo::GetMonthNm(MonthN+1));
1229        }
1230      } else {
1231        NamesSOut->PutStr("continuous");
1232      }
1233      NamesSOut->PutStr(".\n");
1234    }
1235    NamesSOut=NULL;
1236    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1237    int Recs=RecNV.Len();
1238    PSOut DataSOut=TFOut::New(IdFNm+".data");
1239    GasMdCubist->ClassValMom=TMom::New();
1240    for (int RecNN=0; RecNN<Recs; RecNN++){
1241      int RecN=RecNV[RecNN];
1242      double ClassVal=GasDm->GetClassVal(RecN);
1243      TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1244      GasMdCubist->ClassValMom->Add(ClassVal);
1245      DataSOut->PutFlt(ClassVal);
1246      for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1247        DataSOut->PutStr(",");
1248        if (AttrNmV[AttrN]=="Dow"){
1249          DataSOut->PutStr(TTmInfo::GetDayOfWeekNm(AttrValV[AttrN]));
1250        } else
1251        if (AttrNmV[AttrN]=="Month"){
1252          DataSOut->PutStr(TTmInfo::GetMonthNm(AttrValV[AttrN]));
1253        } else {
1254          DataSOut->PutFlt(AttrValV[AttrN]);
1255        }
1256      }
1257      DataSOut->PutStr("\n");
1258    }
1259    GasMdCubist->ClassValMom->Def();
1260    DataSOut=NULL;
1261    TFile::Del(IdFNm+".model", false);
1262    TStr CubistCmLn=TStr("CubistX.exe -f ")+IdFNm&bsol;*+" "+OptStr*/;
1263    system(CubistCmLn.CStr());
1264    {PSIn NamesSIn=TFIn::New(IdFNm+".names");
1265    GasMdCubist->NamesFileStr=TStr(NamesSIn);}
1266    {PSIn DataSIn=TFIn::New(IdFNm+".data");
1267    GasMdCubist->DataFileStr=TStr(DataSIn);}
1268    {PSIn ModelSIn=TFIn::New(IdFNm+".model");
1269    GasMdCubist->ModelFileStr=TStr(ModelSIn);}
1270    TFile::Del(IdFNm+".names", false);
1271    TFile::Del(IdFNm+".data", false);
1272    TFile::Del(IdFNm+".model", false);
1273    return GasMd;
1274  }
1275  double TGasMdCubist::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1276    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1277    {PSOut NamesSOut=TFOut::New(IdFNm+".names");
1278    NamesSOut->PutStr(NamesFileStr);}
1279    {PSOut DataSOut=TFOut::New(IdFNm+".data");
1280    DataSOut->PutStr(DataFileStr);}
1281    {PSOut ModelSOut=TFOut::New(IdFNm+".model");
1282    ModelSOut->PutStr(ModelFileStr);}
1283    PSOut CasesSOut=TFOut::New(IdFNm+".cases");
1284    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1285    double ClassVal=GasDm->GetClassVal(RecN);
1286    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1287    CasesSOut->PutFlt(ClassVal);
1288    for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1289      CasesSOut->PutStr(",");
1290      if (AttrNmV[AttrN]=="Dow"){
1291        CasesSOut->PutStr(TTmInfo::GetDayOfWeekNm(AttrValV[AttrN]));
1292      } else
1293      if (AttrNmV[AttrN]=="Month"){
1294        CasesSOut->PutStr(TTmInfo::GetMonthNm(AttrValV[AttrN]));
1295      } else {
1296        CasesSOut->PutFlt(AttrValV[AttrN]);
1297      }
1298    }
1299    CasesSOut->PutStr("\n");
1300    CasesSOut=NULL;
1301    TFile::Del(IdFNm+".xml", false);
1302    TStr CubistCmLn=TStr("CubistC.exe -f ")+IdFNm;
1303    system(CubistCmLn.CStr());
1304    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(IdFNm+".xml");
1305    TStr PredClassValStr=XmlDoc->GetTagTokStr("Prediction|Predicted");
1306    double PredClassVal=PredClassValStr.GetFlt();
1307    TFile::Del(IdFNm+".names", false);
1308    TFile::Del(IdFNm+".data", false);
1309    TFile::Del(IdFNm+".model", false);
1310    TFile::Del(IdFNm+".cases", false);
1311    TFile::Del(IdFNm+".xml", false);
1312    return PredClassVal;
1313  }
1314  void TGasMdCubist::Print() const {
1315    printf("==========================================================\n");
1316    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1317  }
1318  PGasMd TGasMdSvm::New(const TStr& ParamStr, const PGasDm& GasDm,
1319   const TSecTm& StartDate, const TSecTm& EndDate,
1320   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1321    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1322    TGasMdSvm* GasMdSvm=new TGasMdSvm(GasDmHd); PGasMd GasMd(GasMdSvm);
1323    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1324    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1325    GasMdSvm->IdFNm=ParamXmlDoc->GetTagTokStr("Model|Svm|FileId");
1326    TStr IdFNm=GasMdSvm->IdFNm;
1327    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1328    int Recs=RecNV.Len();
1329    PSOut TrainSOut=TFOut::New(IdFNm+".train");
1330    TrainSOut->PutStr("# ");
1331    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1332    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1333      TrainSOut->PutStr(AttrNmV[AttrN]); TrainSOut->PutStr(" ");}
1334    TrainSOut->PutStr(GasDm->GetClassNm());
1335    TrainSOut->PutStr("\n");
1336    TrainSOut->PutStr("@examples\n");
1337    TrainSOut->PutStr("dimension "); TrainSOut->PutInt(AttrNmV.Len()); TrainSOut->PutStr("\n");
1338    TrainSOut->PutStr("format xy\n");
1339    GasMdSvm->ClassValMom=TMom::New();
1340    for (int RecNN=0; RecNN<Recs; RecNN++){
1341      int RecN=RecNV[RecNN];
1342      double ClassVal=GasDm->GetClassVal(RecN);
1343      TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1344      GasMdSvm->ClassValMom->Add(ClassVal);
1345      for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1346        TrainSOut->PutFlt(AttrValV[AttrN]);
1347        TrainSOut->PutStr(" ");
1348      }
1349      TrainSOut->PutFlt(ClassVal);
1350      TrainSOut->PutStr("\n");
1351    }
1352    GasMdSvm->ClassValMom->Def();
1353    TrainSOut=NULL;
1354    PSOut ParamSOut=TFOut::New(IdFNm+".param");
1355    ParamSOut->PutStr("@kernel\n");
1356    ParamSOut->PutStr("type dot\n");
1357    ParamSOut->PutStr("@parameters\n");
1358    ParamSOut->PutStr("C 1000\n");
1359    ParamSOut->PutStr("epsilon 0.1\n");
1360    ParamSOut=NULL;
1361    TFile::Del(IdFNm+".train.svm", false);
1362    TStr SvmCmLn=TStr("MySvmLearn.exe ")+IdFNm+".train "+IdFNm+".param";
1363    system(SvmCmLn.CStr());
1364    {PSIn ModelSIn=TFIn::New(IdFNm+".train.svm");
1365    GasMdSvm->ModelFileStr=TStr(ModelSIn);}
1366    TFile::Del(IdFNm+".train", false);
1367    TFile::Del(IdFNm+".param", false);
1368    TFile::Del(IdFNm+".train.svm", false);
1369    return GasMd;
1370  }
1371  double TGasMdSvm::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1372    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1373    {PSOut ModelSOut=TFOut::New(IdFNm+".train.svm");
1374    ModelSOut->PutStr(ModelFileStr);}
1375    PSOut TestSOut=TFOut::New(IdFNm+".test");
1376    TestSOut->PutStr("# ");
1377    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1378    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1379      TestSOut->PutStr(AttrNmV[AttrN]); TestSOut->PutStr(" ");}
1380    TestSOut->PutStr(GasDm->GetClassNm());
1381    TestSOut->PutStr("\n");
1382    TestSOut->PutStr("@examples\n");
1383    TestSOut->PutStr("dimension "); TestSOut->PutInt(AttrNmV.Len()); TestSOut->PutStr("\n");
1384    TestSOut->PutStr("format xy\n");
1385    double ClassVal=GasDm->GetClassVal(RecN);
1386    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1387    {for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1388      TestSOut->PutFlt(AttrValV[AttrN]);
1389      TestSOut->PutStr(" ");
1390    }}
1391    TestSOut->PutFlt(ClassVal);
1392    TestSOut->PutStr("\n");
1393    TestSOut=NULL;
1394    PSOut ParamSOut=TFOut::New(IdFNm+".param");
1395    ParamSOut->PutStr("@kernel\n");
1396    ParamSOut->PutStr("type dot\n");
1397    ParamSOut->PutStr("@parameters\n");
1398    ParamSOut->PutStr("C 1000\n");
1399    ParamSOut->PutStr("epsilon 0.1\n");
1400    ParamSOut=NULL;
1401    TFile::Del(IdFNm+"test.pred", false);
1402    TStr SvmCmLn=TStr("MySvmPredict.exe ")+
1403     IdFNm+".train.svm "+IdFNm+".test "+IdFNm+".param";
1404    system(SvmCmLn.CStr());
1405    PSIn PredSIn=TFIn::New(IdFNm+".test.pred");
1406    TILx PredLx(PredSIn, TFSet()|iloRetEoln|iloSigNum);
1407    PredLx.GetSym(syLn);
1408    double PredClassVal=PredLx.GetFlt();
1409    TFile::Del(IdFNm+".train.svm", false);
1410    TFile::Del(IdFNm+".test", false);
1411    TFile::Del(IdFNm+".param", false);
1412    TFile::Del(IdFNm+".test.pred", false);
1413    return PredClassVal;
1414  }
1415  void TGasMdSvm::Print() const {
1416    printf("==========================================================\n");
1417    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1418  }
1419  PGasRegNd TGasRegNd::New(const int& MnLeafExs,
1420   const TVec<TFltV>& AttrValVV, const TFltV& ClassValV, const TIntV& ExNV){
1421    IAssert(ExNV.Len()>0);
1422    PGasRegNd RegNd=PGasRegNd(new TGasRegNd());
1423    RegNd->ClassValMom=TMom::New();
1424    for (int ExNN=0; ExNN<ExNV.Len(); ExNN++){
1425      RegNd->ClassValMom->Add(ClassValV[ExNV[ExNN]]);}
1426    RegNd->ClassValMom->Def();
1427    if (ExNV.Len()<MnLeafExs){
1428      return RegNd;}
1429    int MnSubRegNdExs=TInt::GetMx(ExNV.Len()/10, MnLeafExs);
1430    double BestSplitQual=-1;
1431    int BestSplitAttrN=-1; double BestSplitAttrVal=0;
1432    TIntV BestLExNV; TIntV BestRExNV;
1433    int Attrs=AttrValVV[0].Len();
1434    for (int SplitAttrN=0; SplitAttrN<Attrs; SplitAttrN++){
1435      TFltV SplitValV; PMom SplitValMom=TMom::New();
1436      for (int ExNN=0; ExNN<ExNV.Len(); ExNN++){
1437        double AttrVal=AttrValVV[ExNV[ExNN]][SplitAttrN];
1438        SplitValV.Add(AttrVal); SplitValMom->Add(AttrVal);
1439      }
1440      SplitValV.Sort(); SplitValMom->Def();
1441      double MnSplitValResol=
1442       (SplitValMom->GetQuart3()-SplitValMom->GetQuart1())/100;
1443      double PrevSplitVal;
1444      for (int SplitValN=1; SplitValN<SplitValV.Len()-1; SplitValN++){
1445        double SplitVal=SplitValV[SplitValN];
1446        if ((SplitValN>1)&&(SplitVal-PrevSplitVal<=MnSplitValResol)){continue;}
1447        PrevSplitVal=SplitVal;
1448        PMom LClassValMom=TMom::New(); TIntV LExNV;
1449        PMom RClassValMom=TMom::New(); TIntV RExNV;
1450        for (int ExNN=0; ExNN<ExNV.Len(); ExNN++){
1451          int ExN=ExNV[ExNN];
1452          double AttrVal=AttrValVV[ExN][SplitAttrN];
1453          if (AttrVal<SplitVal){
1454            LClassValMom->Add(ClassValV[ExN]); LExNV.Add(ExN);
1455          } else {
1456            RClassValMom->Add(ClassValV[ExN]); RExNV.Add(ExN);
1457          }
1458        }
1459        LClassValMom->Def(); RClassValMom->Def();
1460        if ((LClassValMom->IsUsable()&&RClassValMom->IsUsable())&&
1461         (LExNV.Len()>MnSubRegNdExs)&&(RExNV.Len()>MnSubRegNdExs)){
1462          double SplitQual=
1463           TMath::Sqr(LClassValMom->GetSDev()*LExNV.Len())+
1464           TMath::Sqr(RClassValMom->GetSDev()*RExNV.Len());
1465          if ((BestSplitQual==-1)||(SplitQual<BestSplitQual)){
1466            BestSplitQual=SplitQual;
1467            BestSplitAttrN=SplitAttrN; BestSplitAttrVal=SplitVal;
1468            BestLExNV=LExNV; BestRExNV=RExNV;
1469          }
1470        }
1471      }
1472    }
1473    if (BestSplitQual!=-1){
1474      RegNd->SplitQual=BestSplitQual;
1475      RegNd->SplitAttrN=BestSplitAttrN;
1476      RegNd->SplitAttrVal=BestSplitAttrVal;
1477      if ((BestLExNV.Len()>0)&&(BestRExNV.Len()>0)){
1478        RegNd->LRegNd=TGasRegNd::New(MnLeafExs, AttrValVV, ClassValV, BestLExNV);
1479        RegNd->RRegNd=TGasRegNd::New(MnLeafExs, AttrValVV, ClassValV, BestRExNV);
1480      }
1481    }
1482    printf(".");
1483    return RegNd;
1484  }
1485  double TGasRegNd::GetPredClassVal(const TFltV& AttrValV) const {
1486    if (IsLeaf()){
1487      return ClassValMom->GetMedian();
1488    } else {
1489      if (AttrValV[SplitAttrN]<SplitAttrVal){
1490        return LRegNd->GetPredClassVal(AttrValV);
1491      } else {
1492        return RRegNd->GetPredClassVal(AttrValV);
1493      }
1494    }
1495  }
1496  void TGasRegNd::Print(const PGasDmHd& GasDmHd, const int& Levs) const {
1497    if (IsLeaf()){
1498      for (int LevN=0; LevN<Levs; LevN++){printf("   ");}
1499      printf("%s=%g(%g) [%d Exs.]\n",
1500       GasDmHd->GetClassNm().CStr(),
1501       ClassValMom->GetMean(), ClassValMom->GetSDev(), ClassValMom->GetVals());
1502    } else {
1503      for (int LevN=0; LevN<Levs; LevN++){printf("   ");}
1504      printf("%s <  %g [%s=%g(%g)] [%d Exs.]\n",
1505       GasDmHd->GetAttrNm(SplitAttrN).CStr(), SplitAttrVal,
1506       GasDmHd->GetClassNm().CStr(),
1507       ClassValMom->GetMean(), ClassValMom->GetSDev(), ClassValMom->GetVals());
1508      LRegNd->Print(GasDmHd, Levs+1);
1509      {for (int LevN=0; LevN<Levs; LevN++){printf("   ");}}
1510      printf("%s >= %g [%s=%g(%g)] [%d Exs.]\n",
1511       GasDmHd->GetAttrNm(SplitAttrN).CStr(), SplitAttrVal,
1512       GasDmHd->GetClassNm().CStr(),
1513       ClassValMom->GetMean(), ClassValMom->GetSDev(), ClassValMom->GetVals());
1514      RRegNd->Print(GasDmHd, Levs+1);
1515    }
1516  }
1517  PGasMd TGasMdRegTree::New(const TStr& ParamStr, const PGasDm& GasDm,
1518   const TSecTm& StartDate, const TSecTm& EndDate,
1519   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1520    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1521    TGasMdRegTree* GasMdRegTree=new TGasMdRegTree(GasDmHd); PGasMd GasMd(GasMdRegTree);
1522    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1523    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1524    int MnLeafExs=ParamXmlDoc->GetTagTokStr("Model|RegTree|MnLeafExs").GetInt();
1525    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1526     int Recs=RecNV.Len();
1527    TVec<TFltV> AttrValVV(Recs);
1528    TFltV ClassValV(Recs); GasMdRegTree->ClassValMom=TMom::New();
1529    for (int RecNN=0; RecNN<Recs; RecNN++){
1530      int RecN=RecNV[RecNN];
1531      TFltV& AttrValV=AttrValVV[RecNN];
1532      GasDm->GetAttrValV(RecN, AttrValV);
1533      double ClassVal=GasDm->GetClassVal(RecN);
1534      ClassValV[RecNN]=ClassVal;
1535      GasMdRegTree->ClassValMom->Add(ClassVal);
1536    }
1537    GasMdRegTree->ClassValMom->Def();
1538    int AllExs=AttrValVV.Len();
1539    TIntV AllExNV(AllExs); for (int ExN=0; ExN<AllExs; ExN++){AllExNV[ExN]=ExN;}
1540    GasMdRegTree->RegNd=TGasRegNd::New(MnLeafExs, AttrValVV, ClassValV, AllExNV);
1541    return GasMd;
1542  }
1543  double TGasMdRegTree::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1544    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1545    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1546    double PredClassVal=RegNd->GetPredClassVal(AttrValV);
1547    return PredClassVal;
1548  }
1549  void TGasMdRegTree::Print() const {
1550    printf("==========================================================\n");
1551    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1552    RegNd->Print(GasDmHd);
1553  }
1554  TGasMdCor::TGasMdCor(const TStr& LtpFPath):
1555    DateProdNmToCorFactMomH(){
1556    TFFile FFile(LtpFPath, ".Ltp", false); TStr FNm;
1557    while (FFile.Next(FNm)){
1558      printf(".");
1559      PGasLtpBs GasLtpBs=TGasLtpBs::Load(FNm);
1560      TStr ProdNm=GasLtpBs->ProdNm;
1561      PGasDm GasDm=TGasDm::GetDayGasDm(GasLtpBs);
1562      TSecTm MnDate=GasLtpBs->GetMnDate();
1563      TSecTm MxDate=GasLtpBs->GetMxDate();
1564      PGasMd GasMd=TGasMd::New(
1565       gmtCTb, NULL, TGasMd::GetMdParamStr(), GasDm, MnDate, MxDate, -1, -1, 100);
1566      for (int RecN=0; RecN<GasDm->GetRecs(); RecN++){
1567        double Cspt=GasDm->GetClassVal(RecN);
1568        double PredCspt=GasMd->GetPredClassVal(GasDm, RecN);
1569        if (PredCspt==0){continue;}
1570        double CorFact=Cspt/PredCspt;
1571        TSecTm Date=GasDm->GetDateVal(RecN);
1572        TDateProdNmPr DateProdNmPr(Date, ProdNm);
1573        if (!DateProdNmToCorFactMomH.IsKey(DateProdNmPr)){
1574          DateProdNmToCorFactMomH.AddDat(DateProdNmPr, TMom::New());}
1575        DateProdNmToCorFactMomH.GetDat(DateProdNmPr)->Add(CorFact);
1576      }
1577    }
1578    for (int DateProdNmP=0; DateProdNmP<DateProdNmToCorFactMomH.Len(); DateProdNmP++){
1579      DateProdNmToCorFactMomH[DateProdNmP]->Def();}
1580  }
1581  double TGasMdCor::GetCorFact(const TSecTm& Date, const TStr& ProdNm) const {
1582    TDateProdNmPr DateProdNmPr(Date, ProdNm);
1583    int DateProdNmP;
1584    if (DateProdNmToCorFactMomH.IsKey(DateProdNmPr, DateProdNmP)){
1585      PMom CorFactMom=DateProdNmToCorFactMomH[DateProdNmP];
1586      if (CorFactMom->IsUsable()){
1587        return CorFactMom->GetMean();
1588      } else {
1589        return 1;
1590      }
1591    } else {
1592      return 1;
1593    }
1594  }
1595  void TGasMdCor::SaveTxt(const TStr& FNm) const {
1596    typedef TTriple<TSecTm, TStr, TInt> TDateProdNmIdTr;
1597    TVec<TDateProdNmIdTr> DateProdNmIdTrV;
1598    for (int DateProdNmP=0; DateProdNmP<DateProdNmToCorFactMomH.Len(); DateProdNmP++){
1599      TSecTm Date=DateProdNmToCorFactMomH.GetKey(DateProdNmP).Val1;
1600      TStr ProdNm=DateProdNmToCorFactMomH.GetKey(DateProdNmP).Val2;
1601      TDateProdNmIdTr DateProdNmIdTr(Date, ProdNm, DateProdNmP);
1602      DateProdNmIdTrV.Add(DateProdNmIdTr);
1603    }
1604    DateProdNmIdTrV.Sort();
1605    TFOut LogFOut(FNm); FILE* fLog=LogFOut.GetFileId();
1606    for (int DpiN=0; DpiN<DateProdNmIdTrV.Len(); DpiN++){
1607      TSecTm Date=DateProdNmIdTrV[DpiN].Val1;
1608      TStr ProdNm=DateProdNmIdTrV[DpiN].Val2;
1609      int DateProdNmP=DateProdNmIdTrV[DpiN].Val3;
1610      PMom CorFactMom=DateProdNmToCorFactMomH[DateProdNmP];
1611      fprintf(fLog, "%s - %-25s - %s\n",
1612       Date.GetDtStr().CStr(), ProdNm.CStr(),
1613       CorFactMom->GetStr(' ', ':', true).CStr());
1614    }
1615  }
1616  double TGasOrder::GetQuantity(const TSecTm& Dt, TGasOrderV& GasOrderV){
1617    double Quantity=0;
1618    for (int GasOrderN=0; GasOrderN<GasOrderV.Len(); GasOrderN++){
1619      if (GasOrderV[GasOrderN]->ReceiveDt==Dt){
1620        Quantity+=GasOrderV[GasOrderN]->Quantity;}
1621    }
1622    return Quantity;
1623  }
1624  double TGasOrder::GetQuantity(
1625   const TSecTm& MnTm, const TSecTm& MxTm, TGasOrderV& GasOrderV){
1626    double Quantity=0;
1627    for (int GasOrderN=0; GasOrderN<GasOrderV.Len(); GasOrderN++){
1628      TSecTm ReceiveDt=GasOrderV[GasOrderN]->ReceiveDt;
1629      if ((MnTm<=ReceiveDt)&&(ReceiveDt<MxTm)){
1630        Quantity+=GasOrderV[GasOrderN]->Quantity;}
1631    }
1632    return Quantity;
1633  }
1634  void TGasOrder::DelOrders(const TSecTm& Dt, TGasOrderV& GasOrderV){
1635    PGasOrder GasOrder=TGasOrder::New(Dt, Dt, 0, false);
1636    GasOrderV.DelAll(GasOrder);
1637  }
1638  void TGasOrder::DelOrders(
1639   const TSecTm& MnTm, const TSecTm& MxTm, TGasOrderV& GasOrderV){
1640    for (int GasOrderN=GasOrderV.Len()-1; GasOrderN>=0; GasOrderN--){
1641      TSecTm ReceiveDt=GasOrderV[GasOrderN]->ReceiveDt;
1642      if ((MnTm<=ReceiveDt)&&(ReceiveDt<MxTm)){
1643        GasOrderV.Del(GasOrderN);
1644      }
1645    }
1646  }
1647  void TGasOrder::DelUnapprovedOrders(
1648   const TSecTm& MnTm, TGasOrderV& GasOrderV, TStrV& MsgStrV){
1649    MsgStrV.Clr();
1650    for (int GasOrderN=GasOrderV.Len()-1; GasOrderN>=0; GasOrderN--){
1651      if (!GasOrderV[GasOrderN]->ApprovedP){
1652        TSecTm ReceiveDt=GasOrderV[GasOrderN]->ReceiveDt;
1653        if (MnTm<=ReceiveDt){
1654          MsgStrV.Add(GasOrderV[GasOrderN]->GetStr());
1655          GasOrderV.Del(GasOrderN);
1656        }
1657      }
1658    }
1659  }
1660  PGasOrder TGasOrder::LoadXml(const PXmlTok& XmlTok){
1661    TStr IssueDtStr=XmlTok->GetTagTokStr("IssueDate");
1662    TSecTm IssueDt=TSecTm::GetDtTmFromDmyStr(IssueDtStr);
1663    TStr ReceiveDtStr=XmlTok->GetTagTokStr("ReceiveDate");
1664    TSecTm ReceiveDt=TSecTm::GetDtTmFromDmyStr(ReceiveDtStr);
1665    TStr QuantityStr=XmlTok->GetTagTokStr("Quantity");
1666    double Quantity=QuantityStr.GetFlt(-1);
1667    PGasOrder GasOrder=TGasOrder::New(IssueDt, ReceiveDt, Quantity, true);
1668    return GasOrder;
1669  }
1670  void TGasOrder::SaveXml(const PSOut& SOut, const TStr& IndentStr) const {
1671    SOut->PutStr(IndentStr); SOut->PutStr("<GasOrder>\n");
1672    SOut->PutStr(IndentStr);
1673    SOut->PutStr(TStr::GetStr(IssueDt.GetDtMdyStr(), "  <IssueDate>%s</IssueDate>\n"));
1674    SOut->PutStr(IndentStr);
1675    SOut->PutStr(TStr::GetStr(ReceiveDt.GetDtMdyStr(), "  <ReceiveDate>%s</ReceiveDate>\n"));
1676    SOut->PutStr(IndentStr);
1677    SOut->PutStr(TFlt::GetStr(Quantity, "  <Quantity>%g</Quantity>\n"));
1678    SOut->PutStr(IndentStr); SOut->PutStr("</GasOrder>\n");
1679  }
1680  PGasStation TGasStation::LoadXml(const PXmlTok& XmlTok){
1681    PGasStation GasStation=TGasStation::New();
1682    GasStation->DescStr=XmlTok->GetTagTokStr("Description");
1683    GasStation->ProdNm=XmlTok->GetTagTokStr("Product");
1684    GasStation->FullVolumeVal=XmlTok->GetTagTokStr("FullVolume").GetFlt(-1);
1685    GasStation->SafetyVolumeVal=XmlTok->GetTagTokStr("SafetyVolume").GetFlt(-1);
1686    GasStation->DeliveryDays=XmlTok->GetTagTokStr("DeliveryDays").GetFlt(-1);
1687    GasStation->StockDurationDays=XmlTok->GetTagTokStr("StockDurationDays").GetFlt(-1);
1688    GasStation->OrderQuantityCorFact=XmlTok->GetTagTokStr("OrderQuantityCorrection").GetFlt(-1);
1689    GasStation->ExceptPredCorFact=XmlTok->GetTagTokStr("ExceptionPredictionCorrection").GetFlt(-1);
1690    GasStation->HistWnDays=XmlTok->GetTagTokStr("HistoryWindowDays").GetFlt(-1);
1691    GasStation->TmGridHours=XmlTok->GetTagTokStr("TimeGridHours").GetFlt(-1);
1692    GasStation->VolumeVal=XmlTok->GetTagTokStr("Volume").GetFlt(-1);
1693    TXmlTokV GasOrderXmlTokV;
1694    XmlTok->GetTagTokV("GasOrderList|GasOrder", GasOrderXmlTokV);
1695    GasStation->GasOrderV.Clr();
1696    for (int GasOrderN=0; GasOrderN<GasOrderXmlTokV.Len(); GasOrderN++){
1697      PGasOrder GasOrder=TGasOrder::LoadXml(GasOrderXmlTokV[GasOrderN]);
1698      GasStation->GasOrderV.Add(GasOrder);
1699    }
1700    return GasStation;
1701  }
1702  PGasStation TGasStation::LoadXml(const TStr& FNm){
1703    PSIn SIn=TFIn::New(FNm);
1704    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
1705    if (!XmlDoc->IsOk()){
1706      TExcept::Throw("Invalid Xml File", SIn->GetSNm());}
1707    return LoadXml(XmlDoc->GetTok());
1708  }
1709  void TGasStation::SaveXml(const PSOut& SOut) const {
1710    SOut->PutStr("<GasStation>\n");
1711    SOut->PutStr(TStr::GetStr(DescStr, "  <Description>%s</Description>\n"));
1712    SOut->PutStr(TStr::GetStr(ProdNm, "  <Product>%s</Product>\n"));
1713    SOut->PutStr(TFlt::GetStr(FullVolumeVal, "  <FullVolume>%g</FullVolume>\n"));
1714    SOut->PutStr(TFlt::GetStr(SafetyVolumeVal, "  <SafetyVolume>%g</SafetyVolume>\n"));
1715    SOut->PutStr(TInt::GetStr(DeliveryDays, "  <DeliveryDays>%d</DeliveryDays>\n"));
1716    SOut->PutStr(TInt::GetStr(StockDurationDays, "  <StockDurationDays>%d</StockDurationDays>\n"));
1717    SOut->PutStr(TFlt::GetStr(OrderQuantityCorFact, "  <OrderQuantityCorrection>%g</OrderQuantityCorrection>\n"));
1718    SOut->PutStr(TFlt::GetStr(ExceptPredCorFact, "  <ExceptionPredictionCorrection>%g</ExceptionPredictionCorrection>\n"));
1719    SOut->PutStr(TInt::GetStr(HistWnDays, "  <HistoryWindowDays>%d</HistoryWindowDays>\n"));
1720    SOut->PutStr(TInt::GetStr(TmGridHours, "  <TimeGridHours>%d</TimeGridHours>\n"));
1721    SOut->PutStr(TFlt::GetStr(VolumeVal, "  <Volume>%g</Volume>\n"));
1722    SOut->PutStr("  <NewGasOrderList>\n");
1723    for (int GasOrderN=0; GasOrderN<NewGasOrderV.Len(); GasOrderN++){
1724      NewGasOrderV[GasOrderN]->SaveXml(SOut, "    ");
1725    }
1726    SOut->PutStr("  </NewGasOrderList>\n");
1727    SOut->PutStr("</GasStation>\n");
1728  }
1729  void TGasStation::DumpDef(FILE* fOut) const {
1730    fprintf(fOut, "===GasStation-Start========\n");
1731    fprintf(fOut, "DescStr: %s\n", DescStr.CStr());
1732    fprintf(fOut, "ProdStr: %s\n", ProdNm.CStr());
1733    fprintf(fOut, "FullVolumeVal: %g\n", FullVolumeVal);
1734    fprintf(fOut, "SafetyVolumeVal: %g\n", SafetyVolumeVal);
1735    fprintf(fOut, "DeliveryDays: %d\n", DeliveryDays);
1736    fprintf(fOut, "StockDurationDays: %d\n", StockDurationDays);
1737    fprintf(fOut, "OrderQuantityCorFact: %g\n", OrderQuantityCorFact);
1738    fprintf(fOut, "ExceptPredCorFact: %g\n", ExceptPredCorFact);
1739    fprintf(fOut, "HistWnDays: %d\n", HistWnDays);
1740    fprintf(fOut, "TmGridHours: %d\n", TmGridHours);
1741    fprintf(fOut, "VolumeVal: %d\n", VolumeVal);
1742    fprintf(fOut, "GasOrderV: (%d)\n", GasOrderV.Len());
1743    for (int GasOrderN=0; GasOrderN<GasOrderV.Len(); GasOrderN++){
1744      fprintf(fOut, "  %s\n", GasOrderV[GasOrderN]->GetStr().CStr());}
1745    fprintf(fOut, "NewGasOrderV: (%d)\n", NewGasOrderV.Len());
1746    {for (int GasOrderN=0; GasOrderN<NewGasOrderV.Len(); GasOrderN++){
1747      fprintf(fOut, "  %s\n", NewGasOrderV[GasOrderN]->GetStr().CStr());}}
1748    fprintf(fOut, "===GasStation-End==========\n");
1749  }
1750  void TGasExe::GenPredEval(
1751   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
1752   const PGasMdCor& GasMdCor, const bool& UseMdCorP,
1753   const PGasDm& GasDm,
1754   const TSecTm& MnDate, const TSecTm& MxDate,
1755   const int& TrainWnLen, const int& TestWnLen, const int& WnStepLen,
1756   const double& MnCspt, const double& MnOutlierRelErr,
1757   const TStr& LogFNm, const int& LogVerbLev, const bool& AppendToLog,
1758   const TStr& TabLogFNm, const bool& AppendToTabLog,
1759   FILE* fOlap, const TStr& OlapPfxLn,
1760   TGasPredV& GasPredV,
1761   PMom& AllPredAbsErrMom, PMom& AllPredRelErrMom,
1762   const bool& PrintToScrP){
1763    TFOut LogFOut(LogFNm, AppendToLog); FILE* fLog=LogFOut.GetFileId();
1764    TFOut TabLogFOut(TabLogFNm, AppendToTabLog); FILE* fTabLog=TabLogFOut.GetFileId();
1765    TSecTm EvalStampTm=TSecTm::GetCurTm();
1766    fprintf(fLog, "===Start-Evaluation======================\n");
1767    fprintf(fLog, "Evaluation (%s)\n", EvalStampTm.GetStr().CStr());
1768    if (GasMdMType->GetMdTypes()==1){
1769      TGasMdType GasMdType=GasMdMType->GetMdType(0);
1770      fprintf(fLog, "Training algorithm '%s'\n", TGasMd::GetGasMdTypeNm(GasMdType).CStr());
1771    } else {
1772      for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
1773        TGasMdType GasMdType=GasMdMType->GetMdType(MdTypeN);
1774        double GasMdWgt=GasMdMType->GetMdWgt(MdTypeN);
1775        fprintf(fLog, "Training algorithm '%s'(%g)\n", TGasMd::GetGasMdTypeNm(GasMdType).CStr(), GasMdWgt);
1776      }
1777    }
1778    fprintf(fLog, "Location/Tank/Product: %s\n", GasDm->GetDescStr().CStr());
1779    fprintf(fLog, "Min. Date: %s   Max. Date: %s\n", MnDate.GetDtStr().CStr(), MxDate.GetDtStr().CStr());
1780    fprintf(fLog, "Train Window: %d   Test Window: %d   Window Step: %d\n", TrainWnLen, TestWnLen, WnStepLen);
1781    fprintf(fLog, "Min. Consumption: %g\n", MnCspt);
1782    if (LogVerbLev>0){
1783      fprintf(fLog, "=========================================\n");}
1784    GasPredV.Clr();
1785    AllPredAbsErrMom=TMom::New();
1786    AllPredRelErrMom=TMom::New();
1787    TStrV OutlierStrV;
1788    for (TSecTm Date=MnDate; Date<MxDate; Date.AddDays(WnStepLen)){
1789      TSecTm StartDate=Date;
1790      TSecTm EndDate=TSecTm(Date).AddDays(TrainWnLen);
1791      TSecTm StartPredDate=TSecTm(Date).AddDays(TrainWnLen+1);
1792      TSecTm EndPredDate=TSecTm(Date).AddDays(TrainWnLen+1+TestWnLen-1);
1793      if (EndPredDate>=MxDate){continue;}
1794      TIntV TrainRecNV; GasDm->GetRecNV(StartDate, EndDate, -1, -1, MnCspt, TrainRecNV);
1795      int TrainRecs=TrainRecNV.Len();
1796      if (LogVerbLev>0){
1797        fprintf(fLog, "---Start-Window--------------------------\n");
1798        fprintf(fLog, "Training From %s   To %s (%d records)\n",
1799         StartDate.GetDtStr().CStr(), EndDate.GetDtStr().CStr(), TrainRecs);
1800        fprintf(fLog, "Testing  From %s   To %s\n",
1801         StartPredDate.GetDtStr().CStr(), EndPredDate.GetDtStr().CStr());
1802      }
1803      if (double(TrainRecs)<double(TrainWnLen)*0.5){continue;}
1804      PGasMd GasMd=TGasMd::New(gmtEnsemble, GasMdMType, GasMdParamStr, GasDm, StartDate, EndDate, -1, -1, MnCspt);
1805      if (PrintToScrP){GasMd->Print();}
1806      if (LogVerbLev>1){
1807        fprintf(fLog, ".........................................\n");}
1808      PMom PredAbsErrMom=TMom::New();
1809      PMom PredRelErrMom=TMom::New();
1810      PMom TestClassValMom=TMom::New();
1811      TIntV PredRecNV;
1812      GasDm->GetRecNV(StartPredDate, EndPredDate, -1, -1, MnCspt, PredRecNV);
1813      for (int PredRecNN=0; PredRecNN<PredRecNV.Len(); PredRecNN++){
1814        int RecN=PredRecNV[PredRecNN];
1815        TSecTm Date=GasDm->GetDateVal(RecN);
1816        TStr DateStr=Date.GetDtStr();
1817        int HourN=GasDm->GetAttrVal(RecN, "Hour", -1);
1818        double ClassVal=GasDm->GetClassVal(RecN);
1819        double PredClassVal=GasMd->GetCorPredClassVal(GasDm, RecN, 1.5);
1820        if (UseMdCorP){
1821          double CorFact=GasMdCor->GetCorFact(Date, GasDm->GetProdNm());
1822          PredClassVal=CorFact*PredClassVal;
1823        }
1824        double RawPredAbsErr=ClassVal-PredClassVal;
1825        double PredAbsErr=fabs(ClassVal-PredClassVal);
1826        double PredRelErr=0; double RawPredRelErr=0;
1827        if (ClassVal!=0){
1828          RawPredRelErr=(ClassVal-PredClassVal)/ClassVal;
1829          PredRelErr=fabs(RawPredRelErr);
1830        }
1831        PredAbsErrMom->Add(PredAbsErr); AllPredAbsErrMom->Add(PredAbsErr);
1832        PredRelErrMom->Add(PredRelErr); AllPredRelErrMom->Add(PredRelErr);
1833        TestClassValMom->Add(ClassVal);
1834        PGasPred GasPred=TGasPred::New();
1835        GasPred->CorrVal=ClassVal;
1836        GasPred->PredVal=PredClassVal;
1837        GasPred->AbsErr=RawPredAbsErr;
1838        GasPred->RelErr=RawPredRelErr;
1839        GasPred->Tm=GasDm->GetDateVal(RecN);
1840        GasPred->OutlierP=(PredRelErr>MnOutlierRelErr);
1841        GasPred->DescStr=GasDm->GetBitsStr(RecN);
1842        GasPredV.Add(GasPred);
1843        if (LogVerbLev>1){
1844          fprintf(fLog,
1845           "Correct: %g   Predicted: %g   Abs-Error: %g   Rel-Error: %g   Date: %s   Hour: %d",
1846           ClassVal, PredClassVal, RawPredAbsErr, PredRelErr, DateStr.CStr(), HourN);
1847          fprintf(fLog, "   Desc: {%s}", GasDm->GetBitsStr(RecN).CStr());
1848          if (PredRelErr>MnOutlierRelErr){fprintf(fLog, "   Outlier");}
1849          fprintf(fLog, "\n");
1850        }
1851        if (fOlap!=NULL){
1852          fprintf(fOlap, "%s%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
1853           OlapPfxLn.CStr(),
1854           Date.GetDtMdyStr().CStr(),
1855           TTmInfo::GetMonthNm(Date.GetMonthN()).CStr(),
1856           TTmInfo::GetDayOfWeekNm(Date.GetDayOfWeekN()).CStr(),
1857           TFlt::GetStr(ClassVal).CStr(),
1858           TFlt::GetStr(PredClassVal).CStr(),
1859           TFlt::GetStr(RawPredAbsErr).CStr(),
1860           TFlt::GetStr(PredRelErr).CStr());
1861        }
1862      }
1863      PredAbsErrMom->Def();
1864      PredRelErrMom->Def();
1865      TestClassValMom->Def();
1866      if (LogVerbLev>1){
1867        fprintf(fLog, ".........................................\n");}
1868      if (LogVerbLev>0){
1869        fprintf(fLog, "Train Class Stat.: %s\n", GasMd->GetClassValMom()->GetStr(' ', ':', true).CStr());
1870        fprintf(fLog, "Test Class Stat.: %s\n", TestClassValMom->GetStr(' ', ':', true).CStr());
1871        fprintf(fLog, ".........................................\n");
1872        fprintf(fLog, "Abs-Error: %s\n", PredAbsErrMom->GetStr(' ', ':', true).CStr());
1873        fprintf(fLog, "Rel-Error: %s\n", PredRelErrMom->GetStr(' ', ':', true).CStr());
1874        fprintf(fLog, "---End-Window----------------------------\n");
1875      }
1876      if (PrintToScrP){
1877        printf("PredAbsErr: %s\n", PredAbsErrMom->GetStr(' ', ':', true).CStr());
1878        printf("PredRelErr: %s\n", PredRelErrMom->GetStr(' ', ':', true).CStr());
1879        printf("Model for: %s - %s ; Predict for: %s - %s\n",
1880         StartDate.GetDtStr().CStr(), EndDate.GetDtStr().CStr(),
1881         StartPredDate.GetDtStr().CStr(), EndPredDate.GetDtStr().CStr());
1882      }
1883    }
1884    AllPredAbsErrMom->Def();
1885    AllPredRelErrMom->Def();
1886    if (LogVerbLev>0){
1887      fprintf(fLog, "=========================================\n");}
1888    fprintf(fLog, "Abs-Error: %s\n", AllPredAbsErrMom->GetStr(' ', ':', true).CStr());
1889    fprintf(fLog, "Rel-Error: %s\n", AllPredRelErrMom->GetStr(' ', ':', true).CStr());
1890    fprintf(fLog, "Evaluation (%s)\n", EvalStampTm.GetStr().CStr());
1891    fprintf(fLog, "===End-Evaluation========================\n");
1892    fprintf(fTabLog, "%s\t", GasDm->GetLtpNm().CStr());
1893    fprintf(fTabLog, "%s\t", GasDm->GetLocNm().CStr());
1894    fprintf(fTabLog, "%s\t", GasDm->GetProdNm().CStr());
1895    fprintf(fTabLog, "%s\t", GasDm->GetTypeNm().CStr());
1896    fprintf(fTabLog, "%d\t", TrainWnLen);
1897    fprintf(fTabLog, "%d\t", TestWnLen);
1898    fprintf(fTabLog, "%s\t", GasMdMType->GetDescStr().CStr());
1899    fprintf(fTabLog, "%s\t", AllPredAbsErrMom->TMom::GetValVStr().CStr());
1900    fprintf(fTabLog, "%s\n", AllPredRelErrMom->TMom::GetValVStr().CStr());
1901  }
1902  void TGasExe::GenDayOrder(
1903   const TStr& LogFNm,
1904   const PGasStation& GasStation, const TStr& OutGasStationFNm,
1905   const TSecTm& StartDt, const int& ProcessDays,
1906   const PGasDm& GasDm,
1907   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
1908   TGasSimRecV& GasSimRecV){
1909    PMom TodayPredVolMom=TMom::New();
1910    PMom TodayRealVolMom=TMom::New();
1911    int UnderSafetyLevWarns=0;
1912    int ReschOrdDtWarns=0;
1913    TFOut LogSOut(LogFNm); FILE* fLog=LogSOut.GetFileId();
1914    GasStation->DumpDef(fLog);
1915    if (!StartDt.IsDef()){
1916      TExcept::Throw("Invalid start date.");}
1917    int FirstRecN=0;
1918    while (FirstRecN<GasDm->GetRecs()){
1919      TSecTm CurRecDt=GasDm->GetDateVal(FirstRecN);
1920      if (CurRecDt==StartDt){break;}
1921      FirstRecN++;
1922    }
1923    if (FirstRecN==GasDm->GetRecs()){
1924      TSecTm CurRecDt=GasDm->GetDateVal(GasDm->GetRecs()-1);
1925      CurRecDt.AddDays(1);
1926      if (CurRecDt!=StartDt){
1927        TExcept::Throw("Invalid start date.", StartDt.GetDtStr());}
1928    }
1929    GasSimRecV.Clr();
1930    for (int TodayRecN=FirstRecN; TodayRecN<FirstRecN+ProcessDays-1; TodayRecN++){
1931      GasDm->AssureDayRec(TodayRecN);
1932      TSecTm TodayDt=GasDm->GetDateVal(TodayRecN);
1933      TStr TodayDtStr=TodayDt.GetDtStr();
1934      fprintf(fLog, "Start day at record [%d] for date [%s]\n", TodayRecN, TodayDtStr.CStr());
1935      fprintf(fLog, "\tDay-Info: [%s]\n", GasDm->GetBitsStr(TodayRecN).CStr());
1936      if (TodayRecN>FirstRecN){
1937        TSecTm PrevDt=GasDm->GetDateVal(TodayRecN-1);
1938        EAssertRA(TodayDt==TSecTm(PrevDt).AddDays(1),
1939         "Invalid time grid", TodayDtStr);
1940      }
1941      PGasSimRec GasSimRec=TGasSimRec::New(GasStation, TodayDtStr);
1942      int MnMdRecN=TodayRecN-GasStation->HistWnDays;
1943      int MxMdRecN=TodayRecN-1;
1944      PGasMd GasMd=TGasMd::New(
1945       gmtEnsemble, GasMdMType, GasMdParamStr,
1946       GasDm,
1947       GasDm->GetDateVal(MnMdRecN), GasDm->GetDateVal(MxMdRecN), -1, -1,
1948       100);
1949      fprintf(fLog, "\tCreate Model for %d records (from %d to %d)\n",
1950       MxMdRecN-MnMdRecN+1, MnMdRecN, MxMdRecN);
1951      double OrderQuantity=TGasOrder::GetQuantity(TodayDt, GasStation->GasOrderV);
1952      fprintf(fLog, "\tExecuted Orders for Quantity: %.0f\n", OrderQuantity);
1953      double TodayPredCspt=GasMd->GetPredClassVal(GasDm, TodayRecN);
1954      GasDm->PutCsptIfEmpty(TodayRecN, TodayPredCspt);
1955      fprintf(fLog, "\tPredicted consumption: %.0f\n", TodayPredCspt);
1956      double TodayRealCspt=GasDm->GetClassVal(TodayRecN);
1957      fprintf(fLog, "\tReal consumption: %.0f\n", TodayRealCspt);
1958      double TodayPredOpenVol=GasStation->VolumeVal+OrderQuantity;
1959      double TodayPredCloseVol=TodayPredOpenVol-TodayRealCspt;
1960      if ((TodayPredOpenVol!=-1)&&(TodayPredCloseVol!=-1)){
1961        TodayPredVolMom->Add((TodayPredOpenVol+TodayPredCloseVol)/2);}
1962      double TodayOpenRealVol=GasDm->GetVolVal(TodayRecN);
1963      double TodayCloseRealVol=-1;
1964      if (TodayRecN+1<GasDm->GetRecs()){
1965        TodayCloseRealVol=GasDm->GetVolVal(TodayRecN+1);}
1966      if ((TodayOpenRealVol!=-1)&&(TodayCloseRealVol!=-1)){
1967        TodayRealVolMom->Add((TodayOpenRealVol+TodayCloseRealVol)/2);}
1968      double SimVolumeVal=GasStation->VolumeVal;
1969      int SimTodayRecN=TodayRecN;
1970      int SimDays=GasStation->StockDurationDays+GasStation->DeliveryDays;
1971      fprintf(fLog, "\tSimulation to generate orders for %d (%d+%d) days.\n",
1972       SimDays, GasStation->StockDurationDays, GasStation->DeliveryDays);
1973      GasSimRec->PutReal(TodayPredOpenVol, TodayRealCspt, OrderQuantity);
1974      while (SimTodayRecN-TodayRecN<SimDays){
1975        GasDm->AssureDayRec(SimTodayRecN);
1976        TSecTm SimTodayDt=GasDm->GetDateVal(SimTodayRecN);
1977        TStr SimTodayDtStr=SimTodayDt.GetDtStr();
1978        double SimOrderQuantity=
1979         TGasOrder::GetQuantity(SimTodayDt, GasStation->GasOrderV);
1980        double SimPredCspt=GasMd->GetCorPredClassVal(
1981         GasDm, SimTodayRecN, GasStation->ExceptPredCorFact);
1982        GasDm->PutCsptIfEmpty(SimTodayRecN, SimPredCspt);
1983        GasSimRec->AddSimStep(SimTodayDtStr,
1984         SimVolumeVal-SimPredCspt+SimOrderQuantity,
1985         SimVolumeVal, SimPredCspt, SimOrderQuantity);
1986        fprintf(fLog, "\t\tSimVolume: %.0f = (v)%.0f - (c)%.0f + (o)%.0f (Date:%s) (Day:%d)\n",
1987         SimVolumeVal-SimPredCspt+SimOrderQuantity,
1988         SimVolumeVal, SimPredCspt, SimOrderQuantity,
1989         SimTodayDtStr.CStr(), SimTodayRecN-TodayRecN);
1990        if (SimVolumeVal-SimPredCspt+SimOrderQuantity>=GasStation->SafetyVolumeVal){
1991          SimVolumeVal=SimVolumeVal+SimOrderQuantity-SimPredCspt;
1992          SimTodayRecN++;
1993        } else {
1994          fprintf(fLog, "\t\tUnder safety level - calculate order quantity for %d days\n",
1995           GasStation->StockDurationDays);
1996          double SubOrderQuantity=0;
1997          for (int DurDayN=0; DurDayN<GasStation->StockDurationDays; DurDayN++){
1998            GasDm->AssureDayRec(SimTodayRecN+DurDayN);
1999            double SubSimPredCspt=0;
2000            if (DurDayN==0){
2001              SubSimPredCspt=GasStation->SafetyVolumeVal-
2002               (SimVolumeVal-SimPredCspt+SimOrderQuantity);
2003            } else {
2004              SubSimPredCspt=GasMd->GetCorPredClassVal(
2005               GasDm, SimTodayRecN+DurDayN, GasStation->ExceptPredCorFact);
2006            }
2007            GasDm->PutCsptIfEmpty(SimTodayRecN+DurDayN, SubSimPredCspt);
2008            GasSimRec->AddOrdStep(
2009             GasDm->GetDateVal(SimTodayRecN+DurDayN).GetDtStr(),
2010             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt);
2011            fprintf(fLog, "\t\t\tOrderQuantity: %.0f = (o)%.0f + (c)%.0f (Date:%s) (Day:%d)\n",
2012             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt,
2013             GasDm->GetDateVal(SimTodayRecN+DurDayN).GetDtStr().CStr(), DurDayN);
2014            SubOrderQuantity+=SubSimPredCspt;
2015          }
2016          GasSimRec->PutCorrQuant(
2017           SubOrderQuantity*GasStation->OrderQuantityCorFact);
2018          fprintf(fLog, "\t\t\tOrderQuantity: %.0f = %.0f * %.2f (Correction)\n",
2019           SubOrderQuantity*GasStation->OrderQuantityCorFact,
2020           SubOrderQuantity, GasStation->OrderQuantityCorFact);
2021          SubOrderQuantity*=GasStation->OrderQuantityCorFact;
2022          int OrderIssueDayRecN=SimTodayRecN-GasStation->DeliveryDays;
2023          if (OrderIssueDayRecN<0){OrderIssueDayRecN=0;}
2024          if (OrderIssueDayRecN<TodayRecN){
2025            fprintf(fLog, "\t\tReschedule Order: [%s] to [%s] !!!\n",
2026             GasDm->GetDateVal(OrderIssueDayRecN).GetDtStr().CStr(),
2027             GasDm->GetDateVal(TodayRecN).GetDtStr().CStr());
2028            OrderIssueDayRecN=TodayRecN;
2029            ReschOrdDtWarns++;
2030          }
2031          TSecTm OrderIssueDt=GasDm->GetDateVal(OrderIssueDayRecN);
2032          TSecTm OrderReceiveDt=
2033           GasDm->GetDateVal(OrderIssueDayRecN+GasStation->DeliveryDays);
2034          TStrV MsgStrV;
2035          TGasOrder::DelUnapprovedOrders(OrderReceiveDt, GasStation->GasOrderV, MsgStrV);
2036          TGasOrder::DelUnapprovedOrders(OrderReceiveDt, GasStation->NewGasOrderV, MsgStrV);
2037          for (int MsgStrN=0; MsgStrN<MsgStrV.Len(); MsgStrN++){
2038            fprintf(fLog, "\t\tDelete-Order: %s\n", MsgStrV[MsgStrN].CStr());}
2039          PGasOrder GasOrder=
2040           TGasOrder::New(OrderIssueDt, OrderReceiveDt, SubOrderQuantity, false);
2041          GasStation->GasOrderV.AddSorted(GasOrder);
2042          GasStation->NewGasOrderV.AddSorted(GasOrder);
2043          fprintf(fLog, "\t\tCreate-Order: %s\n", GasOrder->GetStr().CStr());
2044          break;
2045        }
2046      }
2047      fprintf(fLog, "\tNewVolume: %.0f = (v)%.0f + (o)%.0f - (c)%.0f\n",
2048       GasStation->VolumeVal+OrderQuantity-TodayRealCspt,
2049       GasStation->VolumeVal, OrderQuantity, TodayRealCspt);
2050      GasStation->VolumeVal=GasStation->VolumeVal+OrderQuantity-TodayRealCspt;
2051      if (GasStation->VolumeVal<GasStation->SafetyVolumeVal){
2052        UnderSafetyLevWarns++;
2053        fprintf(fLog, "\tUnder safety level: %.0f<%.0f !!!\n",
2054         GasStation->VolumeVal, GasStation->SafetyVolumeVal);
2055      }
2056      TGasOrder::DelOrders(TodayDt, GasStation->GasOrderV);
2057      GasSimRecV.Add(GasSimRec);
2058      fprintf(fLog, "Close day at record [%d] for date [%s]\n", TodayRecN, TodayDtStr.CStr());
2059    }
2060    GasStation->SaveXml(OutGasStationFNm);
2061    GasStation->DumpDef(fLog);
2062    TodayPredVolMom->Def(); TodayRealVolMom->Def();
2063    fprintf(fLog, "===Statistics-Start======================\n");
2064    fprintf(fLog, "Predicted-Volume-Statistics: %s\n", TodayPredVolMom->GetStr().CStr());
2065    fprintf(fLog, "     Real-Volume-Statistics: %s\n", TodayRealVolMom->GetStr().CStr());
2066    fprintf(fLog, "Under-Safety-Level-Warnings: %d\n", UnderSafetyLevWarns);
2067    fprintf(fLog, "  Reschedule-Order-Warnings: %d\n", ReschOrdDtWarns);
2068    fprintf(fLog, "===Statistics-End========================\n");
2069  }
2070  void TGasExe::GenHourBlockOrder(
2071   const TStr& LogFNm,
2072   const PGasStation& GasStation, const TStr& OutGasStationFNm,
2073   const TSecTm& StartDt, const int& ProcessDays,
2074   const PGasDm& GasDm,
2075   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
2076   TGasSimRecV& GasSimRecV){
2077    int TmGridHours=GasStation->TmGridHours;
2078    PMom NowPredVolMom=TMom::New();
2079    PMom NowRealVolMom=TMom::New();
2080    int UnderSafetyLevWarns=0;
2081    int ReschOrdDtWarns=0;
2082    TFOut LogSOut(LogFNm); FILE* fLog=LogSOut.GetFileId();
2083    GasStation->DumpDef(fLog);
2084    if (!StartDt.IsDef()){
2085      TExcept::Throw("Invalid start date.");}
2086    int FirstRecN=0;
2087    while (FirstRecN<GasDm->GetRecs()){
2088      TSecTm CurRecDt=GasDm->GetDateVal(FirstRecN);
2089      if (CurRecDt==StartDt){break;}
2090      FirstRecN++;
2091    }
2092    if (FirstRecN==GasDm->GetRecs()){
2093      TSecTm CurRecDt=GasDm->GetDateVal(GasDm->GetRecs()-1);
2094      CurRecDt.AddDays(1);
2095      if (CurRecDt!=StartDt){
2096        TExcept::Throw("Invalid start date.", StartDt.GetDtStr());}
2097    }
2098    GasSimRecV.Clr();
2099    int DayRecs=24/TmGridHours;
2100    int ProcessRecs=ProcessDays*DayRecs;
2101    for (int NowRecN=FirstRecN; NowRecN<FirstRecN+ProcessRecs; NowRecN++){
2102      GasDm->AssureDayRec(NowRecN);
2103      TSecTm NowDt=GasDm->GetDateVal(NowRecN);
2104      int NowHourN=GasDm->GetHourN(NowRecN);
2105      TStr NowDtTmStr=NowDt.GetDtStr()+"/"+TInt::GetStr(NowHourN);
2106      TSecTm NowStartTm=TSecTm(NowDt).AddHours(NowHourN);
2107      TSecTm NowEndTm=TSecTm(NowStartTm).AddHours(TmGridHours);
2108      fprintf(fLog, "Start day at record [%d] for date/hour [%s]\n", NowRecN, NowDtTmStr.CStr());
2109      fprintf(fLog, "\tFrom [%s] To [%s]\n", NowStartTm.GetStr().CStr(), NowEndTm.GetStr().CStr());
2110      fprintf(fLog, "\tDay-Info: [%s]\n", GasDm->GetBitsStr(NowRecN).CStr());
2111      if (NowRecN>FirstRecN){
2112        TSecTm PrevDt=GasDm->GetDateVal(NowRecN-1);
2113        int PrevHourN=GasDm->GetHourN(NowRecN-1);
2114        if (NowDt==PrevDt){
2115          EAssertRA(NowHourN-PrevHourN==TmGridHours, "Invalid time grid", NowDtTmStr);
2116        } else
2117        if (NowDt==TSecTm(PrevDt).AddDays(1)){
2118          EAssertRA(NowHourN==0, "Invalid time grid", NowDtTmStr);
2119        }
2120      }
2121      PGasSimRec GasSimRec=TGasSimRec::New(GasStation, NowDtTmStr);
2122      int MnMdRecN=NowRecN-GasStation->HistWnDays*DayRecs;
2123      int MxMdRecN=NowRecN-1;
2124      PGasMd GasMd=TGasMd::New(
2125       gmtEnsemble, GasMdMType, GasMdParamStr,
2126       GasDm,
2127       TSecTm(), TSecTm(), MnMdRecN, MxMdRecN,
2128       100);
2129      fprintf(fLog, "\tCreate Model for %d records (from %d to %d)\n",
2130       MxMdRecN-MnMdRecN+1, MnMdRecN, MxMdRecN);
2131      double OrderQuantity=
2132       TGasOrder::GetQuantity(NowStartTm, NowEndTm, GasStation->GasOrderV);
2133      fprintf(fLog, "\tExecuted Orders for Quantity: %.0f\n", OrderQuantity);
2134      double NowPredCspt=GasMd->GetPredClassVal(GasDm, NowRecN);
2135      if (NowPredCspt<0){NowPredCspt=0;}
2136      GasDm->PutCsptIfEmpty(NowRecN, NowPredCspt);
2137      fprintf(fLog, "\tPredicted consumption: %.0f\n", NowPredCspt);
2138      double NowRealCspt=GasDm->GetClassVal(NowRecN);
2139      fprintf(fLog, "\tReal consumption: %.0f\n", NowRealCspt);
2140      double NowPredOpenVol=GasStation->VolumeVal+OrderQuantity;
2141      double NowPredCloseVol=NowPredOpenVol-NowRealCspt;
2142      if ((NowPredOpenVol!=-1)&&(NowPredCloseVol!=-1)){
2143        NowPredVolMom->Add((NowPredOpenVol+NowPredCloseVol)/2);}
2144      double NowOpenRealVol=GasDm->GetVolVal(NowRecN);
2145      double NowCloseRealVol=-1;
2146      if (NowRecN+1<GasDm->GetRecs()){
2147        NowCloseRealVol=GasDm->GetVolVal(NowRecN+1);}
2148      if ((NowOpenRealVol!=-1)&&(NowCloseRealVol!=-1)){
2149        NowRealVolMom->Add((NowOpenRealVol+NowCloseRealVol)/2);}
2150      double SimVolumeVal=GasStation->VolumeVal;
2151      int SimNowRecN=NowRecN;
2152      int SimDays=GasStation->StockDurationDays+GasStation->DeliveryDays;
2153      int SimRecs=SimDays*DayRecs;
2154      fprintf(fLog, "\tSimulation to generate orders for %d (%d+%d) days (%d records).\n",
2155       SimDays, GasStation->StockDurationDays, GasStation->DeliveryDays, SimRecs);
2156      GasSimRec->PutReal(NowPredOpenVol, NowRealCspt, OrderQuantity);
2157      while (SimNowRecN-NowRecN<SimRecs){
2158        GasDm->AssureDayRec(SimNowRecN);
2159        TSecTm SimNowDt=GasDm->GetDateVal(SimNowRecN);
2160        int SimNowHourN=GasDm->GetHourN(SimNowRecN);
2161        TStr SimNowDtTmStr=SimNowDt.GetDtStr()+"/"+TInt::GetStr(SimNowHourN);
2162        TSecTm SimNowStartTm=TSecTm(SimNowDt).AddHours(SimNowHourN);
2163        TSecTm SimNowEndTm=TSecTm(SimNowStartTm).AddHours(TmGridHours);
2164        double SimOrderQuantity=
2165         TGasOrder::GetQuantity(SimNowStartTm, SimNowEndTm, GasStation->GasOrderV);
2166        double SimPredCspt=GasMd->GetCorPredClassVal(
2167         GasDm, SimNowRecN, GasStation->ExceptPredCorFact);
2168        GasDm->PutCsptIfEmpty(SimNowRecN, SimPredCspt);
2169        GasSimRec->AddSimStep(SimNowDtTmStr,
2170         SimVolumeVal-SimPredCspt+SimOrderQuantity,
2171         SimVolumeVal, SimPredCspt, SimOrderQuantity);
2172        fprintf(fLog, "\t\tSimVolume: %.0f = (v)%.0f - (c)%.0f + (o)%.0f (Date/Hour:%s) (Step:%d)\n",
2173         SimVolumeVal-SimPredCspt+SimOrderQuantity,
2174         SimVolumeVal, SimPredCspt, SimOrderQuantity,
2175         SimNowDtTmStr.CStr(), SimNowRecN-NowRecN);
2176        if (SimVolumeVal-SimPredCspt+SimOrderQuantity>=GasStation->SafetyVolumeVal){
2177          SimVolumeVal=SimVolumeVal+SimOrderQuantity-SimPredCspt;
2178          SimNowRecN++;
2179        } else {
2180          fprintf(fLog, "\t\tUnder safety level - calculate order quantity for %d days\n",
2181           GasStation->StockDurationDays);
2182          double SubOrderQuantity=0;
2183          int DurRecs=GasStation->StockDurationDays*DayRecs;
2184          for (int DurRecN=0; DurRecN<DurRecs; DurRecN++){
2185            GasDm->AssureDayRec(SimNowRecN+DurRecN);
2186            TSecTm DurDt=GasDm->GetDateVal(SimNowRecN+DurRecN);
2187            int DurHourN=GasDm->GetHourN(SimNowRecN+DurRecN);
2188            TStr DurDtTmStr=DurDt.GetDtStr()+"/"+TInt::GetStr(DurHourN);
2189            double SubSimPredCspt=0;
2190            if (DurRecN==0){
2191              SubSimPredCspt=GasStation->SafetyVolumeVal-
2192               (SimVolumeVal-SimPredCspt+SimOrderQuantity);
2193            } else {
2194              SubSimPredCspt=GasMd->GetCorPredClassVal(
2195               GasDm, SimNowRecN+DurRecN, GasStation->ExceptPredCorFact);
2196            }
2197            GasDm->PutCsptIfEmpty(SimNowRecN+DurRecN, SubSimPredCspt);
2198            GasSimRec->AddOrdStep(
2199             DurDtTmStr,
2200             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt);
2201            fprintf(fLog, "\t\t\tOrderQuantity: %.0f = (o)%.0f + (c)%.0f (Date:%s) (Rec:%d)\n",
2202             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt,
2203             DurDtTmStr.CStr(), DurRecN);
2204            SubOrderQuantity+=SubSimPredCspt;
2205          }
2206          GasSimRec->PutCorrQuant(
2207           SubOrderQuantity*GasStation->OrderQuantityCorFact);
2208          fprintf(fLog, "\t\t\tOrderQuantity: %.0f = %.0f * %.2f (Correction)\n",
2209           SubOrderQuantity*GasStation->OrderQuantityCorFact,
2210           SubOrderQuantity, GasStation->OrderQuantityCorFact);
2211          SubOrderQuantity*=GasStation->OrderQuantityCorFact;
2212          int OrderIssueRecN=SimNowRecN-GasStation->DeliveryDays*DayRecs;
2213          if (OrderIssueRecN<0){OrderIssueRecN=0;}
2214          if (OrderIssueRecN<NowRecN){
2215            fprintf(fLog, "\t\tReschedule Order: [%s] to [%s] !!!\n",
2216             GasDm->GetDateVal(OrderIssueRecN).GetDtStr().CStr(),
2217             GasDm->GetDateVal(NowRecN).GetDtStr().CStr());
2218            OrderIssueRecN=NowRecN;
2219            ReschOrdDtWarns++;
2220          }
2221          TSecTm OrderIssueTm=GasDm->GetDateVal(OrderIssueRecN);
2222          int OrderIssueHourN=GasDm->GetHourN(OrderIssueRecN);
2223          OrderIssueTm.AddHours(OrderIssueHourN);
2224          int DeliveryRecs=GasStation->DeliveryDays*DayRecs;
2225          TSecTm OrderReceiveTm=GasDm->GetDateVal(OrderIssueRecN+DeliveryRecs);
2226          int OrderReceiveHourN=GasDm->GetHourN(OrderIssueRecN+DeliveryRecs);
2227          OrderReceiveTm.AddHours(OrderReceiveHourN);
2228          TStrV MsgStrV;
2229          TGasOrder::DelUnapprovedOrders(OrderReceiveTm, GasStation->GasOrderV, MsgStrV);
2230          TGasOrder::DelUnapprovedOrders(OrderReceiveTm, GasStation->NewGasOrderV, MsgStrV);
2231          for (int MsgStrN=0; MsgStrN<MsgStrV.Len(); MsgStrN++){
2232            fprintf(fLog, "\t\tDelete-Order: %s\n", MsgStrV[MsgStrN].CStr());}
2233          PGasOrder GasOrder=
2234           TGasOrder::New(OrderIssueTm, OrderReceiveTm, SubOrderQuantity, false);
2235          GasStation->GasOrderV.AddSorted(GasOrder);
2236          GasStation->NewGasOrderV.AddSorted(GasOrder);
2237          fprintf(fLog, "\t\tCreate-Order: %s\n", GasOrder->GetStr().CStr());
2238          break;
2239        }
2240      }
2241      fprintf(fLog, "\tNewVolume: %.0f = (v)%.0f + (o)%.0f - (c)%.0f\n",
2242       GasStation->VolumeVal+OrderQuantity-NowRealCspt,
2243       GasStation->VolumeVal, OrderQuantity, NowRealCspt);
2244      GasStation->VolumeVal=GasStation->VolumeVal+OrderQuantity-NowRealCspt;
2245      if (GasStation->VolumeVal<GasStation->SafetyVolumeVal){
2246        UnderSafetyLevWarns++;
2247        fprintf(fLog, "\tUnder safety level: %.0f<%.0f !!!\n",
2248         GasStation->VolumeVal, GasStation->SafetyVolumeVal);
2249      }
2250      TGasOrder::DelOrders(NowStartTm, NowEndTm, GasStation->GasOrderV);
2251      GasSimRecV.Add(GasSimRec);
2252      fprintf(fLog, "Close day at record [%d] for date/hour [%s]\n", NowRecN, NowDtTmStr.CStr());
2253    }
2254    GasStation->SaveXml(OutGasStationFNm);
2255    GasStation->DumpDef(fLog);
2256    NowPredVolMom->Def(); NowRealVolMom->Def();
2257    fprintf(fLog, "===Statistics-Start======================\n");
2258    fprintf(fLog, "Predicted-Volume-Statistics: %s\n", NowPredVolMom->GetStr().CStr());
2259    fprintf(fLog, "     Real-Volume-Statistics: %s\n", NowRealVolMom->GetStr().CStr());
2260    fprintf(fLog, "Under-Safety-Level-Warnings: %d\n", UnderSafetyLevWarns);
2261    fprintf(fLog, "  Reschedule-Order-Warnings: %d\n", ReschOrdDtWarns);
2262    fprintf(fLog, "===Statistics-End========================\n");
2263  }
2264  int TGasExe::GenPrediction(
2265   const TStr& TabFNm,
2266   const TStr& _LtpFNm,
2267   const TStr& LtpFPath,
2268   const bool& RepairP,
2269   const TStr& OutLogFNm,
2270   const TStr& OutXmlFNm,
2271   const TStr& MdNm,
2272   const TStr& TmResNm,
2273   const TStr& PredDateStr,
2274   const int& PredDays,
2275   const int& TrainDays,
2276   const double& MnCspt,
2277   const double& ExceptPredCorFact){
2278    Try;
2279    TStr LtpFNm=_LtpFNm;
2280    if ((!TabFNm.Empty())&&(LtpFNm.Empty())){
2281      LtpFNm=TStr::PutFExt(TabFNm, ".Ltp");}
2282    TSecTm PredDate=TSecTm::GetDtTmFromDmyStr(PredDateStr);
2283    TFOut LogFOut(OutLogFNm); FILE* fLog=LogFOut.GetFileId();
2284    if (!TabFNm.Empty()){
2285      TGasLtpBs::ConvTabToLtp(TabFNm, LtpFPath, RepairP);}
2286    PGasLtpBs GasLtpBs=TGasLtpBs::Load(LtpFNm);
2287    PGasMdMType GasMdMType;
2288    if (MdNm=="ctb"){GasMdMType=TGasMdMType::New(gmtCTb);}
2289    else if (MdNm=="svd"){GasMdMType=TGasMdMType::New(gmtLr);}
2290    else if (MdNm=="nnbr"){GasMdMType=TGasMdMType::New(gmtNNbr);}
2291    else if (MdNm=="svm"){GasMdMType=TGasMdMType::New(gmtSvm);}
2292    else if (MdNm=="cubist"){GasMdMType=TGasMdMType::New(gmtCubist);}
2293    else if (MdNm=="rtree"){GasMdMType=TGasMdMType::New(gmtRegTree);}
2294    else if (MdNm=="ens"){
2295      GasMdMType=TGasMdMType::New();
2296      GasMdMType->AddMdTypeWgt(gmtLr, 40);
2297      GasMdMType->AddMdTypeWgt(gmtNNbr, 30);
2298      GasMdMType->AddMdTypeWgt(gmtCTb, 30);
2299      GasMdMType->NrmMdWgt();
2300    } else {
2301      TExcept::Throw("Invalid model type", MdNm);
2302    }
2303    PGasDm GasDm;
2304    if (TmResNm=="w"){GasDm=TGasDm::GetWeekGasDm(GasLtpBs);}
2305    else if (TmResNm=="d"){GasDm=TGasDm::GetDayGasDm(GasLtpBs);}
2306    else if (TmResNm=="24h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 24);}
2307    else if (TmResNm=="12h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 12);}
2308    else if (TmResNm=="6h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 6);}
2309    else if (TmResNm=="4h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 4);}
2310    else if (TmResNm=="3h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 3);}
2311    else if (TmResNm=="2h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 2);}
2312    else if (TmResNm=="1h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 1);}
2313    else {TExcept::Throw("Invalid time resolution", TmResNm);}
2314    TSecTm MnLtpDate=GasLtpBs->GetMnDate();
2315    TSecTm MxLtpDate=GasLtpBs->GetMxDate();
2316    fprintf(fLog, "Minimal-Possible-Train-Date: %s\n", MnLtpDate.GetDtStr().CStr());
2317    fprintf(fLog, "Maximal-Possible-Train-Date: %s\n", MxLtpDate.GetDtStr().CStr());
2318    if (PredDateStr.Empty()){
2319      PredDate=TSecTm(MxLtpDate).AddDays(1);}
2320    TSecTm StartPredDate=PredDate;
2321    TSecTm EndPredDate=TSecTm(StartPredDate).AddDays(PredDays-1);
2322    TSecTm StartTrainDate=TSecTm(StartPredDate).AddDays(-TrainDays);
2323    TSecTm EndTrainDate=TSecTm(StartPredDate).AddDays(-1);
2324    fprintf(fLog, "Start-Train-Date: %s\n", StartTrainDate.GetDtStr().CStr());
2325    fprintf(fLog, "End-Train-Date: %s\n", EndTrainDate.GetDtStr().CStr());
2326    fprintf(fLog, "Start-Prediction-Date: %s\n", StartPredDate.GetDtStr().CStr());
2327    fprintf(fLog, "End-Prediction-Date: %s\n", EndPredDate.GetDtStr().CStr());
2328    if ((StartTrainDate<MnLtpDate)||(MxLtpDate<StartTrainDate)){
2329      TExcept::Throw("Bad Start-Train-Date", StartTrainDate.GetStr());}
2330    if ((EndTrainDate<MnLtpDate)||(MxLtpDate<EndTrainDate)){
2331      TExcept::Throw("Bad End-Train-Date", EndTrainDate.GetStr());}
2332    TIntV TrainRecNV; TIntV SimPredRecNV;
2333    GasDm->GetRecNV(StartTrainDate, EndTrainDate, -1, -1, MnCspt, TrainRecNV);
2334    GasDm->GetRecNV(StartPredDate, EndPredDate, -1, -1, MnCspt, SimPredRecNV);
2335    int TrainRecs=TrainRecNV.Len(); int SimPredRecs=SimPredRecNV.Len();
2336    if (TrainRecs==0){
2337      TExcept::Throw("Empty Train Set");
2338    } else {
2339      fprintf(fLog, "Train Records: %d (from %d to %d)\n",
2340       TrainRecs, TrainRecNV[0], TrainRecNV.Last());
2341    }
2342    fprintf(fLog, "Simulated Prediction Records: %d\n", SimPredRecs);
2343    PGasMd GasMd=TGasMd::New(
2344     gmtEnsemble, GasMdMType,
2345     TGasMd::GetMdParamStr(),
2346     GasDm,
2347     StartTrainDate, EndTrainDate, -1, -1,
2348     MnCspt);
2349    {TFOut SOut(OutXmlFNm); FILE* fOut=SOut.GetFileId();
2350    fprintf(fOut, "<Predictions>\n");
2351    fprintf(fOut, "  <Location>%s</Location>\n",
2352     TXmlLx::GetXmlStrFromPlainStr(GasLtpBs->GetLocNm()).CStr());
2353    fprintf(fOut, "  <Product>%s</Product>\n",
2354     TXmlLx::GetXmlStrFromPlainStr(GasLtpBs->GetProdNm()).CStr());
2355    fprintf(fOut, "  <LtpCode>%s</LtpCode>\n",
2356     TXmlLx::GetXmlStrFromPlainStr(GasLtpBs->GetLtpNm()).CStr());
2357    TSecTm CurPredDate=StartPredDate;
2358    for (int SimPredRecNN=0; SimPredRecNN<SimPredRecs; SimPredRecNN++){
2359      int PredRecN=SimPredRecNV[SimPredRecNN];
2360      CurPredDate=TSecTm::GetDtTm(GasDm->GetDateVal(PredRecN));
2361      TStr PredDateStr=GasDm->GetDateVal(PredRecN).GetDtStr();
2362      int HourN=GasDm->GetAttrVal(PredRecN, "Hour", -1);
2363      TStr PredTmStr;
2364      if (HourN==-1){
2365        fprintf(fLog, "Prediction date: %s (record %d)\n",
2366         PredDateStr.CStr(), PredRecN);
2367         PredTmStr=PredDateStr;
2368      } else {
2369        fprintf(fLog, "Prediction date: %s %d:00 (record %d)\n",
2370         PredDateStr.CStr(), HourN, PredRecN);
2371        PredTmStr=PredDateStr+" "+TInt::GetStr(HourN)+":00";
2372      }
2373      double PredClassVal=GasMd->GetCorPredClassVal(GasDm, PredRecN, ExceptPredCorFact);
2374      double RealClassVal=GasDm->GetClassVal(PredRecN);
2375      fprintf(fLog, "Predicted Consumption: %.0f\n", PredClassVal);
2376      fprintf(fLog, "Real Consumption: %.0f\n", RealClassVal);
2377      fprintf(fOut, "  <Prediction Mode=\"Simulation\">\n");
2378      fprintf(fOut, "    <Time>%s</Time>\n", PredTmStr.CStr());
2379      fprintf(fOut, "    <Predicted>%.0f</Predicted>\n", PredClassVal);
2380      if (RealClassVal!=-1){
2381        fprintf(fOut, "    <Real>%.0f</Real>\n", RealClassVal);}
2382      fprintf(fOut, "  </Prediction>\n");
2383    }
2384    while (CurPredDate<=EndPredDate){
2385      int PredRecN=GasDm->AddTmResRec();
2386      CurPredDate=TSecTm::GetDtTm(GasDm->GetDateVal(PredRecN));
2387      TStr PredDateStr=GasDm->GetDateVal(PredRecN).GetDtStr();
2388      int HourN=GasDm->GetAttrVal(PredRecN, "Hour", -1);
2389      TStr PredTmStr;
2390      if (HourN==-1){
2391        fprintf(fLog, "Prediction date: %s (record %d)\n",
2392         PredDateStr.CStr(), PredRecN);
2393         PredTmStr=PredDateStr;
2394      } else {
2395        fprintf(fLog, "Prediction date: %s %d:00 (record %d)\n",
2396         PredDateStr.CStr(), HourN, PredRecN);
2397        PredTmStr=PredDateStr+" "+TInt::GetStr(HourN)+":00";
2398      }
2399      double PredClassVal=GasMd->GetCorPredClassVal(GasDm, PredRecN, ExceptPredCorFact);
2400      GasDm->PutCsptIfEmpty(PredRecN, PredClassVal);
2401      fprintf(fLog, "Predicted Consumption: %.0f\n", PredClassVal);
2402      fprintf(fOut, "  <Prediction Mode=\"Future\">\n");
2403      fprintf(fOut, "    <Time>%s</Time>\n", PredTmStr.CStr());
2404      fprintf(fOut, "    <Predicted>%.0f</Predicted>\n", PredClassVal);
2405      fprintf(fOut, "  </Prediction>\n");
2406    }
2407    fprintf(fOut, "</Predictions>\n");}
2408    return 0;
2409    Catch;
2410    return 1;
2411  }
2412  int TGasExe::GenOrder(
2413   const TStr& TabFNm,
2414   const TStr& _LtpFNm,
2415   const TStr& InGasStationFNm,
2416   const TStr& OutGasStationFNm,
2417   const TStr& OutLogFNm,
2418   const TStr& OutSimFNm,
2419   const TStr& StartDateStr,
2420   const int& ProcessDays){
2421    Try;
2422    TStr LtpFNm=_LtpFNm;
2423    if ((!TabFNm.Empty())&&(LtpFNm.Empty())){
2424      LtpFNm=TStr::PutFExt(TabFNm, ".Ltp");}
2425    TStr LtpFPath=LtpFNm.GetFPath();
2426    TSecTm StartDt=TSecTm::GetDtTmFromDmyStr(StartDateStr);
2427    PGasMdMType GasMdMType=TGasMdMType::New();
2428    GasMdMType->AddMdTypeWgt(gmtLr, 40);
2429    GasMdMType->AddMdTypeWgt(gmtNNbr, 30);
2430    GasMdMType->AddMdTypeWgt(gmtCTb, 30);
2431    GasMdMType->NrmMdWgt();
2432    if (!TabFNm.Empty()){
2433      TGasLtpBs::ConvTabToLtp(TabFNm, LtpFPath);}
2434    PGasLtpBs GasLtpBs=TGasLtpBs::Load(LtpFNm);
2435    PGasStation GasStation=TGasStation::LoadXml(InGasStationFNm);
2436    if (GasStation->TmGridHours==24){
2437      PGasDm GasDm=TGasDm::GetDayGasDm(GasLtpBs);
2438      TGasSimRecV GasSimRecV;
2439      TGasExe::GenDayOrder(
2440       OutLogFNm,
2441       GasStation, OutGasStationFNm,
2442       StartDt, ProcessDays,
2443       GasDm,
2444       GasMdMType, TGasMd::GetMdParamStr(),
2445       GasSimRecV);
2446      if (!OutSimFNm.Empty()){
2447        TGasSimRec::SaveBin(OutSimFNm, GasSimRecV);}
2448    } else
2449    if ((0<GasStation->TmGridHours)&&(GasStation->TmGridHours<24)){
2450      PGasDm GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, GasStation->TmGridHours);
2451      TGasSimRecV GasSimRecV;
2452      TGasExe::GenHourBlockOrder(
2453       OutLogFNm,
2454       GasStation, OutGasStationFNm,
2455       StartDt, ProcessDays,
2456       GasDm,
2457       GasMdMType, TGasMd::GetMdParamStr(),
2458       GasSimRecV);
2459      if (!OutSimFNm.Empty()){
2460        TGasSimRec::SaveBin(OutSimFNm, GasSimRecV);}
2461    } else {
2462      TExcept::Throw(
2463       "Time-Grid should be 0<tg<=24", TInt::GetStr(GasStation->TmGridHours));
2464    }
2465    return 0;
2466    Catch;
2467    return 1;
2468  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmbasic.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ultra.cpp</div>
                </div>
                <div class="column column_space"><pre><code>131      void Shuffle(TRnd& Rnd) { Fail; }
132  public: 
133      void LinComb(const TFltV& AlphV, TFltV& Result);
134      void LinComb(const TIntV& VecIdV, const TFltV& AlphV, TFltV& Result);
135      double EuclDist(const int& VecId1, const int& VecId2) {
</pre></code></div>
                <div class="column column_space"><pre><code>396  }
397  void TGasDm::GetRecNV(
398   const TSecTm& StartDate, const TSecTm& EndDate,
399   const int& StartRecN, const int& EndRecN, const double& MnCspt, TIntV& RecNV){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    