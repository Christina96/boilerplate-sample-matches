
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.583566238121856%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tordmain.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "tordmain.h"
6  #include "arrayaccess.h" 
7  #include "blobbox.h"     
8  #include "ccstruct.h"    
9  #include "clst.h"        
10  #include "coutln.h"      
11  #include "drawtord.h"    
12  #include "edgblob.h"     
13  #include "errcode.h"     
14  #include "makerow.h"     
15  #include "ocrblock.h"    
16  #include "ocrrow.h"      
17  #include "params.h"      
18  #include "pdblock.h"     
19  #include "points.h"      
20  #include "polyblk.h"     
21  #include "quadratc.h"    
22  #include "quspline.h"    
23  #include "rect.h"        
24  #include "scrollview.h"  
25  #include "statistc.h"    
26  #include "stepblob.h"    
27  #include "textord.h"     
28  #include "tprintf.h"     
29  #include "werd.h"        
30  #include <allheaders.h> 
31  #include <cfloat>  
32  #include <cmath>   
33  #include <cstdint> 
34  #include <memory>
35  namespace tesseract {
36  #define MAX_NEAREST_DIST 600 
37  void SetBlobStrokeWidth(Image pix, BLOBNBOX *blob) {
38    int pix_height = pixGetHeight(pix);
39    const TBOX &box = blob->bounding_box();
40    int width = box.width();
41    int height = box.height();
42    Box *blob_pix_box = boxCreate(box.left(), pix_height - box.top(), width, height);
43    Image pix_blob = pixClipRectangle(pix, blob_pix_box, nullptr);
44    boxDestroy(&blob_pix_box);
45    Image dist_pix = pixDistanceFunction(pix_blob, 4, 8, L_BOUNDARY_BG);
46    pix_blob.destroy();
47    uint32_t *data = pixGetData(dist_pix);
48    int wpl = pixGetWpl(dist_pix);
49    STATS h_stats(0, width);
50    for (int y = 0; y < height; ++y) {
51      uint32_t *pixels = data + y * wpl;
52      int prev_pixel = 0;
53      int pixel = GET_DATA_BYTE(pixels, 0);
54      for (int x = 1; x < width; ++x) {
55        int next_pixel = GET_DATA_BYTE(pixels, x);
56        if (prev_pixel < pixel && (y == 0 || pixel == GET_DATA_BYTE(pixels - wpl, x - 1)) &&
57            (y == height - 1 || pixel == GET_DATA_BYTE(pixels + wpl, x - 1))) {
58          if (pixel > next_pixel) {
59            h_stats.add(pixel * 2 - 1, 1);
60          } else if (pixel == next_pixel && x + 1 < width && pixel > GET_DATA_BYTE(pixels, x + 1)) {
61            h_stats.add(pixel * 2, 1);
62          }
63        }
64        prev_pixel = pixel;
65        pixel = next_pixel;
66      }
67    }
68    STATS v_stats(0, height);
69    for (int x = 0; x < width; ++x) {
70      int prev_pixel = 0;
71      int pixel = GET_DATA_BYTE(data, x);
72      for (int y = 1; y < height; ++y) {
73        uint32_t *pixels = data + y * wpl;
74        int next_pixel = GET_DATA_BYTE(pixels, x);
75        if (prev_pixel < pixel && (x == 0 || pixel == GET_DATA_BYTE(pixels - wpl, x - 1)) &&
76            (x == width - 1 || pixel == GET_DATA_BYTE(pixels - wpl, x + 1))) {
77          if (pixel > next_pixel) {
78            v_stats.add(pixel * 2 - 1, 1);
79          } else if (pixel == next_pixel && y + 1 < height &&
80                     pixel > GET_DATA_BYTE(pixels + wpl, x)) {
81            v_stats.add(pixel * 2, 1);
82          }
83        }
84        prev_pixel = pixel;
85        pixel = next_pixel;
86      }
87    }
88    dist_pix.destroy();
89    if (h_stats.get_total() >= (width + height) / 4) {
90      blob->set_horz_stroke_width(h_stats.ile(0.5f));
91      if (v_stats.get_total() >= (width + height) / 4) {
92        blob->set_vert_stroke_width(v_stats.ile(0.5f));
93      } else {
94        blob->set_vert_stroke_width(0.0f);
95      }
96    } else {
97      if (v_stats.get_total() >= (width + height) / 4 || v_stats.get_total() > h_stats.get_total()) {
98        blob->set_horz_stroke_width(0.0f);
99        blob->set_vert_stroke_width(v_stats.ile(0.5f));
100      } else {
101        blob->set_horz_stroke_width(h_stats.get_total() > 2 ? h_stats.ile(0.5f) : 0.0f);
102        blob->set_vert_stroke_width(0.0f);
103      }
104    }
105  }
106  void assign_blobs_to_blocks2(Image pix,
107                               BLOCK_LIST *blocks,           
108                               TO_BLOCK_LIST *port_blocks) { 
109    BLOCK_IT block_it = blocks;
110    C_BLOB_IT blob_it;       
111    BLOBNBOX_IT port_box_it; 
112    TO_BLOCK_IT port_block_it = port_blocks;
113    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
114      auto block = block_it.data();
115      auto port_block = new TO_BLOCK(block);
116      port_box_it.set_to_list(&port_block->blobs);
117      blob_it.set_to_list(block->blob_list());
118      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
119        auto blob = blob_it.extract();
120        auto newblob = new BLOBNBOX(blob); 
121        newblob->set_owns_cblob(true);
122        SetBlobStrokeWidth(pix, newblob);
123        port_box_it.add_after_then_move(newblob);
124      }
125      port_box_it.set_to_list(&port_block->noise_blobs);
126      blob_it.set_to_list(block->reject_blobs());
127      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
128        auto blob = blob_it.extract();
129        auto newblob = new BLOBNBOX(blob); 
130        newblob->set_owns_cblob(true);
131        SetBlobStrokeWidth(pix, newblob);
132        port_box_it.add_after_then_move(newblob);
133      }
134      port_block_it.add_after_then_move(port_block);
135    }
136  }
137  void Textord::find_components(Image pix, BLOCK_LIST *blocks, TO_BLOCK_LIST *to_blocks) {
138    int width = pixGetWidth(pix);
139    int height = pixGetHeight(pix);
140    if (width > INT16_MAX || height > INT16_MAX) {
141      tprintf("Input image too large! (%d, %d)\n", width, height);
142      return; 
143    }
144    BLOCK_IT block_it(blocks); 
145    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
146      BLOCK *block = block_it.data();
147      if (block->pdblk.poly_block() == nullptr || block->pdblk.poly_block()->IsText()) {
148        extract_edges(pix, block);
149      }
150    }
151    assign_blobs_to_blocks2(pix, blocks, to_blocks);
152    ICOORD page_tr(width, height);
153    filter_blobs(page_tr, to_blocks, !textord_test_landscape);
154  }
155  void Textord::filter_blobs(ICOORD page_tr,        
156                             TO_BLOCK_LIST *blocks, 
157                             bool testing_on) {     
158    TO_BLOCK_IT block_it = blocks;                  
159    TO_BLOCK *block;                                
160  #ifndef GRAPHICS_DISABLED
161    if (to_win != nullptr) {
162      to_win->Clear();
163    }
164  #endif 
165    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
166      block = block_it.data();
167      block->line_size = filter_noise_blobs(&block->blobs, &block->noise_blobs, &block->small_blobs,
168                                            &block->large_blobs);
169      if (block->line_size == 0) {
170        block->line_size = 1;
171      }
172      block->line_spacing =
173          block->line_size *
174          (tesseract::CCStruct::kDescenderFraction + tesseract::CCStruct::kXHeightFraction +
175           2 * tesseract::CCStruct::kAscenderFraction) /
176          tesseract::CCStruct::kXHeightFraction;
177      block->line_size *= textord_min_linesize;
178      block->max_blob_size = block->line_size * textord_excess_blobsize;
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_blobs && testing_on) {
181        if (to_win == nullptr) {
182          create_to_win(page_tr);
183        }
184        block->plot_graded_blobs(to_win);
185      }
186      if (textord_show_boxes && testing_on) {
187        if (to_win == nullptr) {
188          create_to_win(page_tr);
189        }
190        plot_box_list(to_win, &block->noise_blobs, ScrollView::WHITE);
191        plot_box_list(to_win, &block->small_blobs, ScrollView::WHITE);
192        plot_box_list(to_win, &block->large_blobs, ScrollView::WHITE);
193        plot_box_list(to_win, &block->blobs, ScrollView::WHITE);
194      }
195  #endif 
196    }
197  }
198  float Textord::filter_noise_blobs(BLOBNBOX_LIST *src_list,     
199                                    BLOBNBOX_LIST *noise_list,   
200                                    BLOBNBOX_LIST *small_list,   
201                                    BLOBNBOX_LIST *large_list) { 
202    int16_t height;                                              
203    int16_t width;                                               
204    BLOBNBOX *blob;                                              
205    float initial_x;                                             
206    BLOBNBOX_IT src_it = src_list;                               
207    BLOBNBOX_IT noise_it = noise_list;
208    BLOBNBOX_IT small_it = small_list;
209    BLOBNBOX_IT large_it = large_list;
210    STATS size_stats(0, MAX_NEAREST_DIST - 1);
211    float min_y; 
212    float max_y;
213    float max_x;
214    float max_height; 
215    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
216      blob = src_it.data();
217      if (blob->bounding_box().height() < textord_max_noise_size) {
218        noise_it.add_after_then_move(src_it.extract());
219      } else if (blob->enclosed_area() >= blob->bounding_box().height() *
220                                              blob->bounding_box().width() *
221                                              textord_noise_area_ratio) {
222        small_it.add_after_then_move(src_it.extract());
223      }
224    }
225    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
226      size_stats.add(src_it.data()->bounding_box().height(), 1);
227    }
228    initial_x = size_stats.ile(textord_initialx_ile);
229    max_y = ceil(initial_x *
230                 (tesseract::CCStruct::kDescenderFraction + tesseract::CCStruct::kXHeightFraction +
231                  2 * tesseract::CCStruct::kAscenderFraction) /
232                 tesseract::CCStruct::kXHeightFraction);
233    min_y = std::floor(initial_x / 2);
234    max_x = ceil(initial_x * textord_width_limit);
235    small_it.move_to_first();
236    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
237      height = small_it.data()->bounding_box().height();
238      if (height > max_y) {
239        large_it.add_after_then_move(small_it.extract());
240      } else if (height >= min_y) {
241        src_it.add_after_then_move(small_it.extract());
242      }
243    }
244    size_stats.clear();
245    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
246      height = src_it.data()->bounding_box().height();
247      width = src_it.data()->bounding_box().width();
248      if (height < min_y) {
249        small_it.add_after_then_move(src_it.extract());
250      } else if (height > max_y || width > max_x) {
251        large_it.add_after_then_move(src_it.extract());
252      } else {
253        size_stats.add(height, 1);
254      }
255    }
256    max_height = size_stats.ile(textord_initialasc_ile);
257    max_height *= tesseract::CCStruct::kXHeightCapRatio;
258    if (max_height > initial_x) {
259      initial_x = max_height;
260    }
261    return initial_x;
262  }
263  void Textord::cleanup_nontext_block(BLOCK *block) {
264    ROW_IT row_it(block->row_list());
265    if (row_it.empty()) {
266      const TBOX &box = block->pdblk.bounding_box();
267      float height = box.height();
268      int32_t xstarts[2] = {box.left(), box.right()};
269      double coeffs[3] = {0.0, 0.0, static_cast<double>(box.bottom())};
270      ROW *row = new ROW(1, xstarts, coeffs, height / 2.0f, height / 4.0f, height / 4.0f, 0, 1);
271      row_it.add_after_then_move(row);
272    }
273    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
274      ROW *row = row_it.data();
275      WERD_IT w_it(row->word_list());
276      if (w_it.empty()) {
277        TBOX box = block->row_list()->singleton() ? block->pdblk.bounding_box() : row->bounding_box();
278        C_BLOB *blob = C_BLOB::FakeBlob(box);
279        C_BLOB_LIST blobs;
280        C_BLOB_IT blob_it(&blobs);
281        blob_it.add_after_then_move(blob);
282        WERD *word = new WERD(&blobs, 0, nullptr);
283        w_it.add_after_then_move(word);
284      }
285      for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
286        WERD *word = w_it.data();
287        ASSERT_HOST(!word->cblob_list()->empty());
288      }
289      row->recalc_bounding_box();
290    }
291  }
292  void Textord::cleanup_blocks(bool clean_noise, BLOCK_LIST *blocks) {
<span onclick='openModal()' class='match'>293    BLOCK_IT block_it = blocks; 
294    ROW_IT row_it;              
295    int num_rows = 0;
296    int num_rows_all = 0;
297    int num_blocks = 0;
298    int num_blocks_all = 0;
299    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
</span>300      BLOCK *block = block_it.data();
301      if (block->pdblk.poly_block() != nullptr && !block->pdblk.poly_block()->IsText()) {
302        cleanup_nontext_block(block);
303        continue;
304      }
305      num_rows = 0;
306      num_rows_all = 0;
307      if (clean_noise) {
308        row_it.set_to_list(block->row_list());
309        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
310          ROW *row = row_it.data();
311          ++num_rows_all;
312          clean_small_noise_from_words(row);
313          if ((textord_noise_rejrows && !row->word_list()->empty() && clean_noise_from_row(row)) ||
314              row->word_list()->empty()) {
315            delete row_it.extract(); 
316          } else {
317            if (textord_noise_rejwords) {
318              clean_noise_from_words(row_it.data());
319            }
320            if (textord_blshift_maxshift >= 0) {
321              tweak_row_baseline(row, textord_blshift_maxshift, textord_blshift_xfraction);
322            }
323            ++num_rows;
324          }
325        }
326      }
327      if (block->row_list()->empty()) {
328        delete block_it.extract(); 
329      } else {
330        ++num_blocks;
331      }
332      ++num_blocks_all;
333      if (textord_noise_debug) {
334        tprintf("cleanup_blocks: # rows = %d / %d\n", num_rows, num_rows_all);
335      }
336    }
337    if (textord_noise_debug) {
338      tprintf("cleanup_blocks: # blocks = %d / %d\n", num_blocks, num_blocks_all);
339    }
340  }
341  bool Textord::clean_noise_from_row( 
342      ROW *row                        
343  ) {
344    bool testing_on;
345    TBOX blob_box;            
346    C_BLOB *blob;             
347    C_OUTLINE *outline;       
348    WERD *word;               
349    int32_t blob_size;        
350    int32_t trans_count = 0;  
351    int32_t trans_threshold;  
352    int32_t dot_count;        
353    int32_t norm_count;       
354    int32_t super_norm_count; 
355    WERD_IT word_it = row->word_list();
356    C_BLOB_IT blob_it;   
357    C_OUTLINE_IT out_it; 
358    testing_on = textord_test_y > row->base_line(textord_test_x) && textord_show_blobs &&
359                 textord_test_y < row->base_line(textord_test_x) + row->x_height();
360    dot_count = 0;
361    norm_count = 0;
362    super_norm_count = 0;
363    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
364      word = word_it.data(); 
365      blob_it.set_to_list(word->cblob_list());
366      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
367        blob = blob_it.data();
368        if (!word->flag(W_DONT_CHOP)) {
369          out_it.set_to_list(blob->out_list());
370          for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
371            outline = out_it.data();
372            blob_box = outline->bounding_box();
373            blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
374            if (blob_size < textord_noise_sizelimit * row->x_height()) {
375              dot_count++; 
376            }
377            if (!outline->child()->empty() &&
378                blob_box.height() < (1 + textord_noise_syfract) * row->x_height() &&
379                blob_box.height() > (1 - textord_noise_syfract) * row->x_height() &&
380                blob_box.width() < (1 + textord_noise_sxfract) * row->x_height() &&
381                blob_box.width() > (1 - textord_noise_sxfract) * row->x_height()) {
382              super_norm_count++; 
383            }
384          }
385        } else {
386          super_norm_count++;
387        }
388        blob_box = blob->bounding_box();
389        blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
390        if (blob_size >= textord_noise_sizelimit * row->x_height() &&
391            blob_size < row->x_height() * 2) {
392          trans_threshold = blob_size / textord_noise_sizefraction;
393          trans_count = blob->count_transitions(trans_threshold);
394          if (trans_count < textord_noise_translimit) {
395            norm_count++;
396          }
397        } else if (blob_box.height() > row->x_height() * 2 &&
398                   (!word_it.at_first() || !blob_it.at_first())) {
399          dot_count += 2;
400        }
401        if (testing_on) {
402          tprintf("Blob at (%d,%d) -> (%d,%d), ols=%d, tc=%d, bldiff=%g\n", blob_box.left(),
403                  blob_box.bottom(), blob_box.right(), blob_box.top(), blob->out_list()->length(),
404                  trans_count, blob_box.bottom() - row->base_line(blob_box.left()));
405        }
406      }
407    }
408    if (textord_noise_debug) {
409      tprintf("Row ending at (%d,%g):", blob_box.right(), row->base_line(blob_box.right()));
410      tprintf(" R=%g, dc=%d, nc=%d, %s\n",
411              norm_count > 0 ? static_cast<float>(dot_count) / norm_count : 9999, dot_count,
412              norm_count,
413              dot_count > norm_count * textord_noise_normratio && dot_count > 2 ? "REJECTED"
414                                                                                : "ACCEPTED");
415    }
416    return super_norm_count < textord_noise_sncount &&
417           dot_count > norm_count * textord_noise_rowratio && dot_count > 2;
418  }
419  void Textord::clean_noise_from_words( 
420      ROW *row                          
421  ) {
422    TBOX blob_box;           
423    C_BLOB *blob;            
424    C_OUTLINE *outline;      
425    WERD *word;              
426    int32_t blob_size;       
427    int32_t trans_count;     
428    int32_t trans_threshold; 
429    int32_t dot_count;       
430    int32_t norm_count;      
431    int32_t dud_words;       
432    int32_t ok_words;        
433    int32_t word_index;      
434    WERD_IT word_it = row->word_list();
435    C_BLOB_IT blob_it;   
436    C_OUTLINE_IT out_it; 
437    ok_words = word_it.length();
438    if (ok_words == 0 || textord_no_rejects) {
439      return;
440    }
441    std::vector<int8_t> word_dud(ok_words);
442    dud_words = 0;
443    ok_words = 0;
444    word_index = 0;
445    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
446      word = word_it.data(); 
447      dot_count = 0;
448      norm_count = 0;
449      blob_it.set_to_list(word->cblob_list());
450      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
451        blob = blob_it.data();
452        if (!word->flag(W_DONT_CHOP)) {
453          out_it.set_to_list(blob->out_list());
454          for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
455            outline = out_it.data();
456            blob_box = outline->bounding_box();
457            blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
458            if (blob_size < textord_noise_sizelimit * row->x_height()) {
459              dot_count++; 
460            }
461            if (!outline->child()->empty() &&
462                blob_box.height() < (1 + textord_noise_syfract) * row->x_height() &&
463                blob_box.height() > (1 - textord_noise_syfract) * row->x_height() &&
464                blob_box.width() < (1 + textord_noise_sxfract) * row->x_height() &&
465                blob_box.width() > (1 - textord_noise_sxfract) * row->x_height()) {
466              norm_count++; 
467            }
468          }
469        } else {
470          norm_count++;
471        }
472        blob_box = blob->bounding_box();
473        blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
474        if (blob_size >= textord_noise_sizelimit * row->x_height() &&
475            blob_size < row->x_height() * 2) {
476          trans_threshold = blob_size / textord_noise_sizefraction;
477          trans_count = blob->count_transitions(trans_threshold);
478          if (trans_count < textord_noise_translimit) {
479            norm_count++;
480          }
481        } else if (blob_box.height() > row->x_height() * 2 &&
482                   (!word_it.at_first() || !blob_it.at_first())) {
483          dot_count += 2;
484        }
485      }
486      if (dot_count > 2 && !word->flag(W_REP_CHAR)) {
487        if (dot_count > norm_count * textord_noise_normratio * 2) {
488          word_dud[word_index] = 2;
489        } else if (dot_count > norm_count * textord_noise_normratio) {
490          word_dud[word_index] = 1;
491        } else {
492          word_dud[word_index] = 0;
493        }
494      } else {
495        word_dud[word_index] = 0;
496      }
497      if (word_dud[word_index] == 2) {
498        dud_words++;
499      } else {
500        ok_words++;
501      }
502      word_index++;
503    }
504    word_index = 0;
505    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
506      if (word_dud[word_index] == 2 || (word_dud[word_index] == 1 && dud_words > ok_words)) {
507        word = word_it.data(); 
508        word->CleanNoise(textord_noise_sizelimit * row->x_height());
509      }
510      word_index++;
511    }
512  }
513  void Textord::clean_small_noise_from_words(ROW *row) {
514    WERD_IT word_it(row->word_list());
515    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
516      WERD *word = word_it.data();
517      int min_size = static_cast<int>(textord_noise_hfract * word->bounding_box().height() + 0.5);
518      C_BLOB_IT blob_it(word->cblob_list());
519      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
520        C_BLOB *blob = blob_it.data();
521        C_OUTLINE_IT out_it(blob->out_list());
522        for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
523          C_OUTLINE *outline = out_it.data();
524          outline->RemoveSmallRecursive(min_size, &out_it);
525        }
526        if (blob->out_list()->empty()) {
527          delete blob_it.extract();
528        }
529      }
530      if (word->cblob_list()->empty()) {
531        if (!word_it.at_last()) {
532          WERD *next_word = word_it.data_relative(1);
533          if (next_word->flag(W_FUZZY_NON)) {
534            next_word->set_flag(W_FUZZY_NON, false);
535          }
536        }
537        delete word_it.extract();
538      }
539    }
540  }
541  struct BlockGroup {
542    BlockGroup() : rotation(1.0f, 0.0f), angle(0.0f), min_xheight(1.0f) {}
543    explicit BlockGroup(BLOCK *block)
544        : bounding_box(block->pdblk.bounding_box())
545        , rotation(block->re_rotation())
546        , angle(block->re_rotation().angle())
547        , min_xheight(block->x_height()) {
548      blocks.push_back(block);
549    }
550    TBOX bounding_box;
551    FCOORD rotation;
552    float angle;
553    float min_xheight;
554    std::vector<BLOCK *> blocks;
555  };
556  void Textord::TransferDiacriticsToBlockGroups(BLOBNBOX_LIST *diacritic_blobs, BLOCK_LIST *blocks) {
557    const double kMaxAngleDiff = 0.01; 
558    std::vector<std::unique_ptr<BlockGroup>> groups;
559    BLOCK_IT bk_it(blocks);
560    for (bk_it.mark_cycle_pt(); !bk_it.cycled_list(); bk_it.forward()) {
561      BLOCK *block = bk_it.data();
562      if (block->pdblk.poly_block() != nullptr && !block->pdblk.poly_block()->IsText()) {
563        continue;
564      }
565      float block_angle = block->re_rotation().angle();
566      int best_g = 0;
567      float best_angle_diff = FLT_MAX;
568      for (const auto &group : groups) {
569        double angle_diff = std::fabs(block_angle - group->angle);
570        if (angle_diff > M_PI) {
571          angle_diff = fabs(angle_diff - 2.0 * M_PI);
572        }
573        if (angle_diff < best_angle_diff) {
574          best_angle_diff = angle_diff;
575          best_g = &group - &groups[0];
576        }
577      }
578      if (best_angle_diff > kMaxAngleDiff) {
579        groups.push_back(std::make_unique<BlockGroup>(block));
580      } else {
581        groups[best_g]->blocks.push_back(block);
582        groups[best_g]->bounding_box += block->pdblk.bounding_box();
583        float x_height = block->x_height();
584        if (x_height < groups[best_g]->min_xheight) {
585          groups[best_g]->min_xheight = x_height;
586        }
587      }
588    }
589    std::vector<std::unique_ptr<WordWithBox>> word_ptrs;
590    for (const auto &group : groups) {
591      if (group->bounding_box.null_box()) {
592        continue;
593      }
594      WordGrid word_grid(group->min_xheight, group->bounding_box.botleft(),
595                         group->bounding_box.topright());
596      for (auto b : group->blocks) {
597        ROW_IT row_it(b->row_list());
598        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
599          ROW *row = row_it.data();
600          WERD_IT w_it(row->word_list());
601          for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
602            WERD *word = w_it.data();
603            auto box_word = std::make_unique<WordWithBox>(word);
604            word_grid.InsertBBox(true, true, box_word.get());
605            word_ptrs.emplace_back(std::move(box_word));
606          }
607        }
608      }
609      FCOORD rotation = group->rotation;
610      rotation.set_y(-rotation.y());
611      TransferDiacriticsToWords(diacritic_blobs, rotation, &word_grid);
612    }
613  }
614  void Textord::TransferDiacriticsToWords(BLOBNBOX_LIST *diacritic_blobs, const FCOORD &rotation,
615                                          WordGrid *word_grid) {
616    WordSearch ws(word_grid);
617    BLOBNBOX_IT b_it(diacritic_blobs);
618    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
619      BLOBNBOX *blobnbox = b_it.data();
620      TBOX blob_box = blobnbox->bounding_box();
621      blob_box.rotate(rotation);
622      ws.StartRectSearch(blob_box);
623      WordWithBox *best_above_word = nullptr;
624      WordWithBox *best_below_word = nullptr;
625      int best_above_distance = 0;
626      int best_below_distance = 0;
627      for (WordWithBox *word = ws.NextRectSearch(); word != nullptr; word = ws.NextRectSearch()) {
628        if (word->word()->flag(W_REP_CHAR)) {
629          continue;
630        }
631        TBOX word_box = word->true_bounding_box();
632        int x_distance = blob_box.x_gap(word_box);
633        int y_distance = blob_box.y_gap(word_box);
634        if (x_distance > 0) {
635          if (word_box.major_y_overlap(blob_box) && blob_box.left() > word_box.right()) {
636            x_distance /= 2;
637          }
638          y_distance += x_distance;
639        }
640        if (word_box.y_middle() > blob_box.y_middle() &&
641            (best_above_word == nullptr || y_distance < best_above_distance)) {
642          best_above_word = word;
643          best_above_distance = y_distance;
644        }
645        if (word_box.y_middle() <= blob_box.y_middle() &&
646            (best_below_word == nullptr || y_distance < best_below_distance)) {
647          best_below_word = word;
648          best_below_distance = y_distance;
649        }
650      }
651      bool above_good = best_above_word != nullptr &&
652                        (best_below_word == nullptr ||
653                         best_above_distance < best_below_distance + blob_box.height());
654      bool below_good = best_below_word != nullptr && best_below_word != best_above_word &&
655                        (best_above_word == nullptr ||
656                         best_below_distance < best_above_distance + blob_box.height());
657      if (below_good) {
658        C_BLOB *copied_blob = C_BLOB::deep_copy(blobnbox->cblob());
659        copied_blob->rotate(rotation);
660        C_BLOB_IT blob_it(best_below_word->RejBlobs());
661        blob_it.add_to_end(copied_blob);
662      }
663      if (above_good) {
664        C_BLOB *copied_blob = C_BLOB::deep_copy(blobnbox->cblob());
665        copied_blob->rotate(rotation);
666        C_BLOB_IT blob_it(best_above_word->RejBlobs());
667        blob_it.add_to_end(copied_blob);
668      }
669    }
670  }
671  void tweak_row_baseline(ROW *row, double blshift_maxshift, double blshift_xfraction) {
672    TBOX blob_box;      
673    C_BLOB *blob;       
674    WERD *word;         
675    int32_t blob_count; 
676    int32_t src_index;  
677    int32_t dest_index; 
678    float ydiff;        
679    float x_centre;     
680    WERD_IT word_it = row->word_list();
681    C_BLOB_IT blob_it; 
682    blob_count = 0;
683    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
684      word = word_it.data(); 
685      blob_count += word->cblob_list()->length();
686    }
687    if (blob_count == 0) {
688      return;
689    }
690    std::vector<int32_t> xstarts(blob_count + row->baseline.segments + 1);
691    std::vector<double> coeffs((blob_count + row->baseline.segments) * 3);
692    src_index = 0;
693    dest_index = 0;
694    xstarts[0] = row->baseline.xcoords[0];
695    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
696      word = word_it.data(); 
697      blob_it.set_to_list(word->cblob_list());
698      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
699        blob = blob_it.data();
700        blob_box = blob->bounding_box();
701        x_centre = (blob_box.left() + blob_box.right()) / 2.0;
702        ydiff = blob_box.bottom() - row->base_line(x_centre);
703        if (ydiff < 0) {
704          ydiff = -ydiff / row->x_height();
705        } else {
706          ydiff = ydiff / row->x_height();
707        }
708        if (ydiff < blshift_maxshift && blob_box.height() / row->x_height() > blshift_xfraction) {
709          if (xstarts[dest_index] >= x_centre) {
710            xstarts[dest_index] = blob_box.left();
711          }
712          coeffs[dest_index * 3] = 0;
713          coeffs[dest_index * 3 + 1] = 0;
714          coeffs[dest_index * 3 + 2] = blob_box.bottom();
715          dest_index++;
716          xstarts[dest_index] = blob_box.right() + 1;
717        } else {
718          if (xstarts[dest_index] <= x_centre) {
719            while (row->baseline.xcoords[src_index + 1] <= x_centre &&
720                   src_index < row->baseline.segments - 1) {
721              if (row->baseline.xcoords[src_index + 1] > xstarts[dest_index]) {
722                coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
723                coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
724                coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
725                dest_index++;
726                xstarts[dest_index] = row->baseline.xcoords[src_index + 1];
727              }
728              src_index++;
729            }
730            coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
731            coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
732            coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
733            dest_index++;
734            xstarts[dest_index] = row->baseline.xcoords[src_index + 1];
735          }
736        }
737      }
738    }
739    while (src_index < row->baseline.segments &&
740           row->baseline.xcoords[src_index + 1] <= xstarts[dest_index]) {
741      src_index++;
742    }
743    while (src_index < row->baseline.segments) {
744      coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
745      coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
746      coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
747      dest_index++;
748      src_index++;
749      xstarts[dest_index] = row->baseline.xcoords[src_index];
750    }
751    row->baseline = QSPLINE(dest_index, &xstarts[0], &coeffs[0]);
752  }
753  } 
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/util/im2col.hpp"
3  #include "caffe/util/math_functions.hpp"
4  namespace caffe {
5  inline bool is_a_ge_zero_and_a_lt_b(int a, int b) {
6    return static_cast<unsigned>(a) < static_cast<unsigned>(b);
7  }
8  template <typename Dtype>
9  void im2col_cpu(const Dtype* data_im, const int channels,
10      const int height, const int width, const int kernel_h, const int kernel_w,
11      const int pad_h, const int pad_w,
12      const int stride_h, const int stride_w,
13      const int dilation_h, const int dilation_w,
14      Dtype* data_col) {
15  #if 0
16    const int output_h = (height + 2 * pad_h -
17      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
18    const int output_w = (width + 2 * pad_w -
19      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
20    const int channel_size = height * width;
21    for (int channel = channels; channel--; data_im += channel_size) {
22      for (int kernel_row = 0; kernel_row < kernel_h; kernel_row++) {
23        for (int kernel_col = 0; kernel_col < kernel_w; kernel_col++) {
24          int input_row = -pad_h + kernel_row * dilation_h;
25          for (int output_rows = output_h; output_rows; output_rows--) {
26            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
27              for (int output_cols = output_w; output_cols; output_cols--) {
28                *(data_col++) = 0;
29              }
30            } else {
31              int input_col = -pad_w + kernel_col * dilation_w;
32              for (int output_col = output_w; output_col; output_col--) {
33                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
34                  *(data_col++) = data_im[input_row * width + input_col];
35                } else {
36                  *(data_col++) = 0;
37                }
38                input_col += stride_w;
39              }
40            }
41            input_row += stride_h;
42          }
43        }
44      }
45    }
46  #else
47    int dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
48    int dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
49    int height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
50    int width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
51    int channels_col = channels * kernel_h * kernel_w;
52    #ifdef _OPENMP
53    #pragma omp parallel for
54    #endif
55    for (int c = 0; c < channels_col; ++c) {
56      int w_offset = c % kernel_w;
57      int h_offset = (c / kernel_w) % kernel_h;
58      int c_im = c / kernel_h / kernel_w;
59      const int hc0 = h_offset * dilation_h - pad_h;
60      const int wc0 = w_offset * dilation_w - pad_w;
61      for (int h = 0; h < height_col; ++h) {
62        int h_pad = h * stride_h + hc0;
63        const int row_offset = (c * height_col + h) * width_col;
64        const int srow_offset = (c_im * height + h_pad) * width;
65        for (int w = 0; w < width_col; ++w) {
66          int w_pad = w * stride_w + wc0;
67          if ((((unsigned)h_pad) < ((unsigned)height)) && (((unsigned)w_pad) < ((unsigned)width)))
68            data_col[row_offset + w] = data_im[srow_offset + w_pad];
69          else {
70            data_col[row_offset + w] = 0.;
71          }
72        }
73      }
74    }
75  #endif
76  }
77  template <typename Dtype>
78  void im3d2col_cpu(const Dtype* data_im, const int channels,
79      const int depth, const int height, const int width,
80      const int kernel_d, const int kernel_h, const int kernel_w,
81      const int pad_d, const int pad_h, const int pad_w,
82      const int stride_d, const int stride_h, const int stride_w,
83      const int dilation_d, const int dilation_h, const int dilation_w,
84      Dtype* data_col) {
85    long dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
86    long dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
<span onclick='openModal()' class='match'>87    long dil_kernel_d = (kernel_d - 1) * dilation_d + 1;
88    long height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
89    long width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
90    long depth_col = (depth + 2 * pad_d - dil_kernel_d) / stride_d + 1;
91    long channels_col = channels * kernel_h * kernel_w * kernel_d;
92    #ifdef _OPENMP
93    #pragma omp parallel for
94    #endif
95    for (long c = 0; c < channels_col; ++c) {
</span>96      long w_offset = c % kernel_w;
97      long h_offset = (c / kernel_w) % kernel_h;
98      long d_offset = (c / kernel_w / kernel_h) % kernel_d;
99      long c_im = c / kernel_h / kernel_w / kernel_d;
100      for (int d = 0; d < depth_col; ++d) {
101        long d_pad = d * stride_d - pad_d + d_offset * dilation_d;
102        for (long h = 0; h < height_col; ++h) {
103          long h_pad = h * stride_h - pad_h + h_offset * dilation_h;
104          for (long w = 0; w < width_col; ++w) {
105            long w_pad = w * stride_w - pad_w + w_offset * dilation_w;
106            if (((unsigned long)h_pad < (unsigned long)height) &&
107                ((unsigned long)w_pad < (unsigned long)width) &&
108                ((unsigned long)d_pad < (unsigned long)depth)) {
109              data_col[((c * depth_col + d) * height_col + h) * width_col + w] =
110                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad];
111            } else {
112              data_col[((c * depth_col + d) * height_col + h) * width_col + w] = 0.;
113            }
114          }
115        }
116      }
117    }
118  }
119  template void im2col_cpu<float>(const float* data_im, const int channels,
120      const int height, const int width, const int kernel_h, const int kernel_w,
121      const int pad_h, const int pad_w, const int stride_h,
122      const int stride_w, const int dilation_h, const int dilation_w,
123      float* data_col);
124  template void im2col_cpu<double>(const double* data_im, const int channels,
125      const int height, const int width, const int kernel_h, const int kernel_w,
126      const int pad_h, const int pad_w, const int stride_h,
127      const int stride_w, const int dilation_h, const int dilation_w,
128      double* data_col);
129  template void im3d2col_cpu<float>(const float* data_im, const int channels,
130      const int depth, const int height, const int width,
131      const int kernel_d, const int kernel_h, const int kernel_w,
132      const int pad_d, const int pad_h, const int pad_w,
133      const int stride_d, const int stride_h, const int stride_w,
134      const int dilation_d, const int dilation_h, const int dilation_w,
135      float* data_col);
136  template void im3d2col_cpu<double>(const double* data_im, const int channels,
137      const int depth, const int height, const int width,
138      const int kernel_d, const int kernel_h, const int kernel_w,
139      const int pad_d, const int pad_h, const int pad_w,
140      const int stride_d, const int stride_h, const int stride_w,
141      const int dilation_d, const int dilation_h, const int dilation_w,
142      double* data_col);
143  template <typename Dtype>
144  inline void im2col_nd_core_cpu(const Dtype* data_input, const bool im2col,
145      const int num_spatial_axes, const int* im_shape, const int* col_shape,
146      const int* kernel_shape, const int* pad, const int* stride,
147      const int* dilation, Dtype* data_output) {
148    if (!im2col) {
149      size_t im_size = im_shape[0];
150      for (int i = 0; i < num_spatial_axes; ++i) {
151        im_size *= (size_t)im_shape[1 + i];
152      }
153      caffe_set(im_size, Dtype(0), data_output);
154    }
155    int kernel_size = 1;
156    for (int i = 0; i < num_spatial_axes; ++i) {
157      kernel_size *= kernel_shape[i];
158    }
159    const int channels_col = col_shape[0];
160    vector<int> d_offset(num_spatial_axes, 0);
161    vector<int> d_iter(num_spatial_axes, 0);
162    for (int c_col = 0; c_col < channels_col; ++c_col) {
163      int offset = c_col;
164      for (int d_i = num_spatial_axes - 1; d_i >= 0; --d_i) {
165        if (d_i < num_spatial_axes - 1) {
166          offset /= kernel_shape[d_i + 1];
167        }
168        d_offset[d_i] = offset % kernel_shape[d_i];
169      }
170      for (bool incremented = true; incremented; ) {
171        int index_col = c_col;
172        int index_im = c_col / kernel_size;
173        bool is_padding = false;
174        for (int d_i = 0; d_i < num_spatial_axes; ++d_i) {
175          const int d = d_iter[d_i];
176          const int d_im = d * stride[d_i] - pad[d_i] +
177              d_offset[d_i] * dilation[d_i];
178          is_padding |= d_im < 0 || d_im >= im_shape[d_i + 1];
179          index_col *= col_shape[d_i + 1];
180          index_col += d;
181          index_im *= im_shape[d_i + 1];
182          index_im += d_im;
183        }
184        if (im2col) {
185          if (is_padding) {
186            data_output[index_col] = 0;
187          } else {
188            data_output[index_col] = data_input[index_im];
189          }
190        } else if (!is_padding) {  
191          data_output[index_im] += data_input[index_col];
192        }
193        incremented = false;
194        for (int d_i = num_spatial_axes - 1; d_i >= 0; --d_i) {
195          const int d_max = col_shape[d_i + 1];
196          DCHECK_LT(d_iter[d_i], d_max);
197          if (d_iter[d_i] == d_max - 1) {
198            d_iter[d_i] = 0;
199          } else {  
200            ++d_iter[d_i];
201            incremented = true;
202            break;
203          }
204        }
205      }  
206    }  
207  }
208  template <typename Dtype>
209  void im2col_nd_cpu(const Dtype* data_im, const int num_spatial_axes,
210      const int* im_shape, const int* col_shape,
211      const int* kernel_shape, const int* pad, const int* stride,
212      const int* dilation, Dtype* data_col) {
213    const bool kIm2Col = true;
214    im2col_nd_core_cpu(data_im, kIm2Col, num_spatial_axes, im_shape, col_shape,
215                    kernel_shape, pad, stride, dilation, data_col);
216  }
217  template void im2col_nd_cpu<float>(const float* data_im,
218      const int num_spatial_axes,
219      const int* im_shape, const int* col_shape,
220      const int* kernel_shape, const int* pad, const int* stride,
221      const int* dilation, float* data_col);
222  template void im2col_nd_cpu<double>(const double* data_im,
223      const int num_spatial_axes,
224      const int* im_shape, const int* col_shape,
225      const int* kernel_shape, const int* pad, const int* stride,
226      const int* dilation, double* data_col);
227  template <typename Dtype>
228  void col2im_cpu(const Dtype* data_col, const int channels,
229      const int height, const int width, const int kernel_h, const int kernel_w,
230      const int pad_h, const int pad_w,
231      const int stride_h, const int stride_w,
232      const int dilation_h, const int dilation_w,
233      Dtype* data_im) {
234  #if 0
235    caffe_set(height * width * channels, Dtype(0), data_im);
236    const int output_h = (height + 2 * pad_h -
237      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
238    const int output_w = (width + 2 * pad_w -
239      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
240    const int channel_size = height * width;
241    for (int channel = channels; channel--; data_im += channel_size) {
242      for (int kernel_row = 0; kernel_row < kernel_h; kernel_row++) {
243        for (int kernel_col = 0; kernel_col < kernel_w; kernel_col++) {
244          int input_row = -pad_h + kernel_row * dilation_h;
245          for (int output_rows = output_h; output_rows; output_rows--) {
246            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
247              data_col += output_w;
248            } else {
249              int input_col = -pad_w + kernel_col * dilation_w;
250              for (int output_col = output_w; output_col; output_col--) {
251                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
252                  data_im[input_row * width + input_col] += *data_col;
253                }
254                data_col++;
255                input_col += stride_w;
256              }
257            }
258            input_row += stride_h;
259          }
260        }
261      }
262    }
263  #else
264    int dil_patch_h = (kernel_h - 1) * dilation_h + 1;
265    int dil_patch_w = (kernel_w - 1) * dilation_w + 1;
266    int height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
267    int width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
268    long chunk_len = kernel_h * kernel_w;
269    caffe_set((size_t)height * (size_t)width * (size_t)channels, Dtype(0), data_im);
270    #ifdef _OPENMP
271    #pragma omp parallel for if (channels > 1)
272    #endif 
273    for (int idx = 0; idx < channels; ++idx) {
274      for (int inner_idx = 0; inner_idx < chunk_len; ++inner_idx) {
275        int c = idx * chunk_len + inner_idx;
276        int w_offset = c % kernel_w;
277        int h_offset = (c / kernel_w) % kernel_h;
278        int c_im = c / kernel_h / kernel_w;
279        const int hc0 = h_offset * dilation_h - pad_h;
280        const int wc0 = w_offset * dilation_w - pad_w;
281        for (int h = 0; h < height_col; ++h) {
282          for (int w = 0; w < width_col; ++w) {
283            int h_pad = h * stride_h + hc0;
284            const int srow_offset = (c_im * height + h_pad) * width;
285            const int row_offset = (c * height_col + h) * width_col;
286            int w_pad = w * stride_w + wc0;
287            if ((((unsigned)h_pad) < ((unsigned)height)) && (((unsigned)w_pad) < ((unsigned)width))) {
288              data_im[srow_offset + w_pad] += data_col[row_offset + w];
289            }
290          }
291        }
292      }
293    }
294  #endif
295  }
296  template <typename Dtype>
297  void col2im3d_cpu(const Dtype* data_col, const int channels,
298      const int depth, const int height, const int width,
299      const int kernel_d, const int kernel_h, const int kernel_w,
300      const int pad_d, const int pad_h, const int pad_w,
301      const int stride_d, const int stride_h, const int stride_w,
302      const int dilation_d, const int dilation_h, const int dilation_w,
303      Dtype* data_im) {
304    long dil_patch_h = (kernel_h - 1) * dilation_h + 1;
305    long dil_patch_w = (kernel_w - 1) * dilation_w + 1;
306    long dil_patch_d = (kernel_d - 1) * dilation_d + 1;
307    long height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
308    long width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
309    long depth_col = (depth + 2 * pad_d - dil_patch_d) / stride_d + 1;
310    long num_kernels = (size_t)channels * (size_t)height * (size_t)width * (size_t)depth;
311    long chunk_len = kernel_h * kernel_w * kernel_d;
312    caffe_set(num_kernels, Dtype(0), data_im);
313    #ifdef _OPENMP
314    #pragma omp parallel for if (channels > 1)
315    #endif
316    for (long c_im = 0; c_im < channels; ++c_im) {
317      for (long c = c_im * chunk_len; c < chunk_len * (c_im + 1); ++c) {
318        long w_offset = c % kernel_w;
319        long h_offset = (c / kernel_w) % kernel_h;
320        long d_offset = (c / kernel_w / kernel_h) % kernel_d;
321        long dc0 = d_offset * dilation_d - pad_d;
322        long hc0 = h_offset * dilation_h - pad_h;
323        long wc0 = w_offset * dilation_w - pad_w;
324        for (long d = 0; d < depth_col; ++d) {
325          long d_pad = d * stride_d + dc0;
326          for (long h = 0; h < height_col; ++h) {
327            long h_pad = h * stride_h + hc0;
328            for (long w = 0; w < width_col; ++w) {
329              long w_pad = w * stride_w + wc0;
330              if (((unsigned long)h_pad < (unsigned long)height) &&
331                  ((unsigned long)w_pad < (unsigned long)width) &&
332                  ((unsigned long)d_pad < (unsigned long)depth)) {
333                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad] +=
334                  data_col[((c * depth_col + d) * height_col + h) * width_col + w];
335              }
336            }
337          }
338        }
339      }
340    }
341  }
342  template void col2im_cpu<float>(const float* data_col, const int channels,
343      const int height, const int width, const int kernel_h, const int kernel_w,
344      const int pad_h, const int pad_w, const int stride_h,
345      const int stride_w, const int dilation_h, const int dilation_w,
346      float* data_im);
347  template void col2im_cpu<double>(const double* data_col, const int channels,
348      const int height, const int width, const int kernel_h, const int kernel_w,
349      const int pad_h, const int pad_w, const int stride_h,
350      const int stride_w, const int dilation_h, const int dilation_w,
351      double* data_im);
352  template void col2im3d_cpu<float>(const float* data_col, const int channels,
353      const int depth, const int height, const int width,
354      const int kernel_d, const int kernel_h, const int kernel_w,
355      const int pad_d, const int pad_h, const int pad_w,
356      const int stride_d, const int stride_h, const int stride_w,
357      const int dilation_d, const int dilation_h, const int dilation_w,
358      float* data_im);
359  template void col2im3d_cpu<double>(const double* data_col, const int channels,
360      const int depth, const int height, const int width,
361      const int kernel_d, const int kernel_h, const int kernel_w,
362      const int pad_d, const int pad_h, const int pad_w,
363      const int stride_d, const int stride_h, const int stride_w,
364      const int dilation_d, const int dilation_h, const int dilation_w,
365      double* data_im);
366  template <typename Dtype>
367  void col2im_nd_cpu(const Dtype* data_col, const int num_spatial_axes,
368      const int* im_shape, const int* col_shape,
369      const int* kernel_shape, const int* pad, const int* stride,
370      const int* dilation, Dtype* data_im) {
371    const bool kIm2Col = false;
372    im2col_nd_core_cpu(data_col, kIm2Col, num_spatial_axes, im_shape, col_shape,
373                       kernel_shape, pad, stride, dilation, data_im);
374  }
375  template void col2im_nd_cpu<float>(const float* data_col,
376      const int num_spatial_axes,
377      const int* im_shape, const int* col_shape,
378      const int* kernel_shape, const int* pad, const int* stride,
379      const int* dilation, float* data_im);
380  template void col2im_nd_cpu<double>(const double* data_col,
381      const int num_spatial_axes,
382      const int* im_shape, const int* col_shape,
383      const int* kernel_shape, const int* pad, const int* stride,
384      const int* dilation, double* data_im);
385  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tordmain.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</div>
                <div class="column column_space"><pre><code>293    BLOCK_IT block_it = blocks; 
294    ROW_IT row_it;              
295    int num_rows = 0;
296    int num_rows_all = 0;
297    int num_blocks = 0;
298    int num_blocks_all = 0;
299    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
</pre></code></div>
                <div class="column column_space"><pre><code>87    long dil_kernel_d = (kernel_d - 1) * dilation_d + 1;
88    long height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
89    long width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
90    long depth_col = (depth + 2 * pad_d - dil_kernel_d) / stride_d + 1;
91    long channels_col = channels * kernel_h * kernel_w * kernel_d;
92    #ifdef _OPENMP
93    #pragma omp parallel for
94    #endif
95    for (long c = 0; c < channels_col; ++c) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    