
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.55396327810121%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmbasic.cpp</h3>
            <pre><code>1  void TSVMCache::Reset(const int& memory_size, const int& d) {
2      IAssert(memory_size > 0 && d > 0);
3      top = bottom = NULL;
4      size = 0; dim = numRows = d;
5      int vecsize = (sizeof(TFltType) + sizeof(bool)) * dim;
6      int aviable_memory = memory_size*1024*1024
7                           - dim * sizeof(int)    
8                           - dim * sizeof(bool)   
9                           - dim * sizeof(int);   
10      maxsize = aviable_memory / vecsize;
11      maxsize = maxsize < dim ? maxsize : dim;
12      if (verbosity > 0) {
13          printf("cache size = %d (%.3f MB)\n",
14                 maxsize, maxsize * vecsize / (1024.0 * 1024.0));
15      }
16      cache = (maxsize > 0) ? new TFltType[maxsize * dim] : NULL;
17      valid = (maxsize > 0) ? new bool[maxsize * dim] : NULL;
18      idsT = (maxsize > 0) ? new int[dim] : NULL;
19      vecShrink.Reserve(maxsize+1, maxsize+1);
20      int i;
21      saved.Reserve(dim, dim);
22      vecPt.Reserve(dim, dim);
23      for (i = 0; i < dim; i++) {
24          saved[i] = false;
25          idsT[i] = i;
26      }
27      for (i = 0; i < maxsize+1; i++) {
28          vecShrink[i] = NULL;
29      }
30  }
31  void TSVMCache::Clear() {
32      if (cache != NULL) delete[] cache;
33      if (valid != NULL) delete[] valid;
34      if (idsT != NULL) delete[] idsT;
35      cache = NULL; valid = NULL; idsT = NULL;
36      TListNode *node = bottom, *tmp;
37      while (node != NULL) {
38          tmp = node;
39          node = node->next;
40          delete tmp;
41      }
42      bottom = top = NULL;
43      vecPt.Clr(); saved.Clr();
44      numRows = size = maxsize = dim = 0;
45  }
46  void TSVMCache::toTop(TListNode *node) {
47      if (node->prev != NULL && node->next != NULL) {
48          node->prev->next = node->next;
49          node->next->prev = node->prev;
50          node->next = NULL;
51          node->prev = top;
52          top->next = node;
53          top = node;
54      } else if (node == bottom && node->next != NULL) {
55          bottom = bottom->next;
56          bottom->prev = NULL;
57          node->next = NULL;
58          node->prev = top;
59          top->next = node;
60          top = node;
61      } 
62  }
63  TSVMCacheVec TSVMCache::Get(const int& i) {
64      Assert(0 <= i && i < dim && saved[i]);
65      toTop(vecPt[i]);
66      return TSVMCacheVec(vecPt[i]->addr, vecPt[i]->vaddr, idsT, numRows);
67  }
68  TFltType TSVMCache::GetVal(const int& i, const int& j) const {
69      Assert(0 <= i && i < dim && saved[i] && 0 <= j && j < dim && idsT[j] >= 0);
70      return vecPt[i]->addr[idsT[j]];
71  }
72  TSVMCacheVec TSVMCache::Add(const int& i) {
73      Assert(0 <= i && i < dim && cache != NULL);
74      if (saved[i]) {
75          toTop(vecPt[i]);
76          return TSVMCacheVec(vecPt[i]->addr, vecPt[i]->vaddr, idsT, numRows);
77      }
78      TFltType *vecAddr; bool *vecVAddr;
79      TListNode *node = new TListNode();
80      Assert(size >= 0 && size <= maxsize);
81      if (size == 0) {
82          vecAddr = cache;
83          vecVAddr = valid;
84          node->position = 0;
85          node->next = node->prev = NULL;
86          top = bottom = node;
87          size++;
88      } else if (size < maxsize) {
89          vecAddr = &cache[size * numRows];
90          vecVAddr = &valid[size * numRows];
91          node->position = size;
92          node->next = NULL;
93          node->prev = top;
94          top->next = node;
95          top = node;
96          size++;
97      } else {
98          vecAddr = bottom->addr;
99          vecVAddr = bottom->vaddr;
100          node->position = bottom->position;
101          saved[bottom->ID] = false;
102          bottom = bottom->next;
103          delete bottom->prev;
104          bottom->prev = NULL;
105          node->next = NULL;
106          node->prev = top;
107          top->next = node;
108          top = node;
109      }
110      node->ID = i;
111      node->addr = vecAddr;
112      node->vaddr = vecVAddr;
113      saved[i] = true;
114      vecPt[i] = node;
115      vecShrink[node->position] = node;
116      return TSVMCacheVec(vecAddr, vecVAddr, idsT, numRows);
117  }
118  void TSVMCache::Shrink(const int& n, int *ids) {
119      if (n < numRows) {
120          int newMaxSize = (maxsize * numRows) / n;
121          int pos = 0; 
122          int i = 0;   
123          while (vecShrink[i] != NULL) { 
124              TListNode *node = vecShrink[i];
125              Assert(i == node->position);
126              TFltType *newAddr = &cache[pos];
127              int jNew, jOld;
128              for (jNew = 0; jNew < n; jNew++) {
129                  jOld = idsT[ids[jNew]];
130                  Assert(jOld >= 0); 
131                  cache[pos] = node->addr[jOld];
132                  valid[pos] = node->vaddr[jOld];
133                  pos++;
134              }
135              node->addr = newAddr;   
136              i++;                    
137          }
138          numRows = n;
139          for (i = 0; i < dim; i++) idsT[i] = -1;
140          for (i = 0; i < numRows; i++) idsT[ids[i]] = i;
141          vecShrink.Reserve(newMaxSize + 1, newMaxSize + 1);
142          for (i = size; i < newMaxSize+1; i++)
143              vecShrink[i] = NULL;
144          maxsize = newMaxSize;
145          if (verbosity > 1) printf("<%d>", maxsize);
146      }
147  }
148  THash<TStr, TSVMTrainSet::TSVMTrainSetLoadF> TSVMTrainSet::TypeToLoadFH;
149  bool TSVMTrainSet::Reg(const TStr& TypeNm, const TSVMTrainSetLoadF& LoadF){
150    IAssert(!TypeToLoadFH.IsKey(TypeNm));
151    TypeToLoadFH.AddDat(TypeNm, LoadF);
152    return true;
153  }
154  PSVMTrainSet TSVMTrainSet::Load(TSIn& SIn){
155      TStr TypeNm(SIn);
156      int TypeKeyId=-1;
157      if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
158          TSVMTrainSetLoadF LoadF=TypeToLoadFH[TypeKeyId];
159          return (*LoadF())(SIn);
160      } else {
161          return NULL;
162      }
163  }
164  void TSVMTrainSet::LinComb(const TFltV& AlphV, TFltV& Result) {
165      IAssert(AlphV.Len() == Len());
166      int d = Dim(); Result.Gen(d); Result.PutAll(0.0);
167      for (int VecC = 0, VecN = AlphV.Len(); VecC < VecN; VecC++)
168          AddVec(VecC, Result, AlphV[VecC]);
169  }
170  void TSVMTrainSet::LinComb(const TIntV& VecIdV, const TFltV& AlphV, TFltV& Result) {
171      IAssert(VecIdV.Len() == AlphV.Len());
172      Result.Gen(Dim()); Result.PutAll(0.0);
173      for (int VecC = 0, VecN = VecIdV.Len(); VecC < VecN; VecC++)
174          AddVec(VecIdV[VecC], Result, AlphV[VecC]);
175  }
176  void TSVMTrainSet::GetKeywords(const TFltV& NormalV, TIntFltKdV& WIdWgtV,
177          const TIntV& VecIdV, const int& WdN,  const double& VecSign,
178          const double& WgtSign, const bool& AvgOverSet) {
179      TFltV WgtV(NormalV.Len());
180      if (AvgOverSet) {
181          WgtV.PutAll(0.0);
182          if (VecIdV.Empty()) {
183              const int Docs = Len();
184              for (int DId = 0; DId < Docs; DId++) {
185                  if (VecSign*GetVecParam(DId) > 0)
186                      AddVec(DId, WgtV, 1.0);
187              }
188          } else {
189              for (int DocN = 0; DocN < VecIdV.Len(); DocN++) {
190                  const int DId = VecIdV[DocN];
191                  if (VecSign*GetVecParam(DId) > 0)
192                      AddVec(DId, WgtV, 1.0);
193              }
194          }
195      } else {
196          WgtV.PutAll(1.0);
197      }
198      TFltIntKdV WdWgtV(NormalV.Len(), 0);
199      for (int AttrC = 0; AttrC < NormalV.Len(); AttrC++) {
200          WdWgtV.Add(TFltIntKd(WgtSign*NormalV[AttrC]*WgtV[AttrC], AttrC));
201      }
202      if (WdN > 0) {
203          WdWgtV.Sort(false);
204          WIdWgtV.Gen(WdN, 0);
205          IAssert(WdN <= NormalV.Len());
206          for (int WdC = 0; WdC < WdN; WdC++) {
207              const double WdWgt = WdWgtV[WdC].Key;
208              const int WdId = WdWgtV[WdC].Dat;
209              if (WdWgt > 0) {
210                  WIdWgtV.Add(TIntFltKd(WdId, WdWgt));
211              }
212          }
213      } else {
214          WIdWgtV.Clr();
215          for (int WdC = 0; WdC < WdWgtV.Len(); WdC++) {
216              const double WdWgt = WdWgtV[WdC].Key;
217              const int WdId = WdWgtV[WdC].Dat;
218              if (WdWgt > 0.0) {
219                  WIdWgtV.Add(TIntFltKd(WdId, WdWgt));
220              }
221          }
222      }
223  }
224  double TSVMTrainSet::CalcSvmUnblParam(const double& MxVal, const double& MnVal) {
225      int PosVecs = 0;
226      int NegVecs = 0;
227      for (int VecN = 0; VecN < Len(); VecN++) {
228          const double VecParam = GetVecParam(VecN);
229          if (VecParam > 0.0) {
230              PosVecs++;
231          } else if (VecParam < 0.0) {
232              NegVecs++;
233          }
234      }
235      if (PosVecs > 0 && NegVecs > 0) {
236          const double CalcVal = double(NegVecs)/double(PosVecs);
237          return TMath::Median(MnVal, CalcVal, MxVal);
238      } else {
239          return 1.0;
240      }
241  }
242  int TSVMTrainSet::GetSignVecs(const double& Sign) {
243      int SignVecs = 0;
244      for (int VecN = 0; VecN < Len(); VecN++) {
245          if ((Sign*GetVecParam(VecN)) > 0.0) SignVecs++;
246      }
247      return SignVecs;
248  }
249  bool TSVMTrainSet::HasPosNegVecs(const int& MnVec) {
250      int PosVecs = GetSignVecs(1.0);
251      int NegVecs = GetSignVecs(-1.0);
252      return (PosVecs >= MnVec) && (NegVecs >= MnVec);
253  }
254  bool TSVMTrainSet::HasPosVecs(const int& MnPosVec) {
255      int PosVecs = GetSignVecs(1.0);
256      return (PosVecs >= MnPosVec);
257  }
258  bool TSVMTrainSet::HasNegVecs(const int& MnNegVec) {
259      int NegVecs = GetSignVecs(-1.0);
260      return (NegVecs >= MnNegVec);
261  }
262  TSTSetMatrix::TSTSetMatrix(PSVMTrainSet Set, TFltV& ClsV): TMatrix(), ColVV(Set) {
263      IAssert(Set->Type() == ststSparse);
264      ClsV.Gen(Set->Len(), 0);
265      for (int i = 0; i < Set->Len(); i++)
266          ClsV.Add(Set->GetVecParam(i) * 0.99);
267  }
268  void TSTSetMatrix::PMultiply(const TFltVV& B, int ColId, TFltV& Result) const {
269      IAssert(B.GetXDim() >= PGetCols() && Result.Len() >= PGetRows());
270      int RowN = PGetRows(), ColN = PGetCols();
271      int i, j; TFlt *ResV = Result.BegI();
272      for (i = 0; i < RowN; i++) ResV[i] = 0.0;
273      for (j = 0; j < ColN; j++) {
274          const TIntFltKdV& ColV = ColVV->GetAttrSparseV(j); int len = ColV.Len();
275          for (i = 0; i < len; i++) {
276              if (ColV[i].Key < Result.Len())
277                  ResV[ColV[i].Key] += ColV[i].Dat * B(j,ColId);
278          }
279      }
280  }
281  void TSTSetMatrix::PMultiply(const TFltV& Vec, TFltV& Result) const {
282      IAssert(Vec.Len() >= PGetCols() && Result.Len() >= PGetRows());
283      int RowN = PGetRows(), ColN = PGetCols();
284      int i, j; TFlt *ResV = Result.BegI();
285      for (i = 0; i < RowN; i++) ResV[i] = 0.0;
286      for (j = 0; j < ColN; j++) {
287          const TIntFltKdV& ColV = ColVV->GetAttrSparseV(j); int len = ColV.Len();
288          for (i = 0; i < len; i++) {
289              if (ColV[i].Key < Result.Len())
290                  ResV[ColV[i].Key] += ColV[i].Dat * Vec[j];
291          }
292      }
293  }
294  void TSTSetMatrix::PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const {
295      IAssert(B.GetXDim() >= PGetRows() && Result.Len() >= PGetCols());
296      int ColN = PGetCols();
297      int i, j, len; TFlt *ResV = Result.BegI();
298      for (j = 0; j < ColN; j++) {
299          const TIntFltKdV& ColV = ColVV->GetAttrSparseV(j);
300          len = ColV.Len(); ResV[j] = 0.0;
301          for (i = 0; i < len; i++) {
302              if (ColV[i].Key < B.GetXDim())
303                  ResV[j] += ColV[i].Dat * B(ColV[i].Key, ColId);
304          }
305      }
306  }
307  void TSTSetMatrix::PMultiplyT(const TFltV& Vec, TFltV& Result) const {
308      IAssert(Vec.Len() >= PGetRows() && Result.Len() >= PGetCols());
309      int ColN = PGetCols();
310      int i, j, len; TFlt *VecV = Vec.BegI(), *ResV = Result.BegI();
311      for (j = 0; j < ColN; j++) {
312          const TIntFltKdV& ColV = ColVV->GetAttrSparseV(j);
313          len = ColV.Len(); ResV[j] = 0.0;
314          for (i = 0; i < len; i++) {
315              if (ColV[i].Key < Vec.Len())
316                  ResV[j] += ColV[i].Dat * VecV[ColV[i].Key];
317          }
318      }
319  }
320  void TSTSetMatrix::Load(TSparseColMatrix& Matrix, TFltV& y,
321          PSVMTrainSet TrainSet, const double& PWgt, const double& NWgt) {
322      IAssert(TrainSet->Type() == ststSparse);
323      Matrix.ColN = TrainSet->Len();
324      Matrix.RowN = TrainSet->Dim();
325      for (int i = 0; i < Matrix.ColN; i++) {
326          Matrix.DocSpVV.Add(TrainSet->GetAttrSparseV(i));
327          y.Add(TrainSet->GetVecParam(i) > 0.0 ? PWgt : NWgt);
328      }
329      Matrix.DocSpVV.Pack();
330  }
331  THash<TStr, TKernel::TKernelLoadF> TKernel::TypeToLoadFH;
332  bool TKernel::Reg(const TStr& TypeNm, const TKernelLoadF& LoadF){
333    IAssert(!TypeToLoadFH.IsKey(TypeNm));
334    TypeToLoadFH.AddDat(TypeNm, LoadF);
335    return true;
336  }
337  PKernel TKernel::Load(TSIn& SIn){
338      TStr TypeNm(SIn);
339      int TypeKeyId=-1;
340      if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
341          TKernelLoadF LoadF=TypeToLoadFH[TypeKeyId];
342          return (*LoadF())(SIn);
343      } else {
344          return NULL;
345      }
346  }
347  bool TPolynomialKernel::IsReg = TPolynomialKernel::MkReg();
348  bool TRadialKernel::IsReg = TRadialKernel::MkReg();
349  bool TSigmoidKernel::IsReg = TSigmoidKernel::MkReg();
350  TSVMQP::TSVMQP(const int& nn, const int& mm, const double& ll):
351    n(nn), m(mm) {
352      pl = new double[n];
353      for (int i = 0; i < n; i++)
354          pl[i] = ll;
355      primal = new double[3*n];
356      dual = new double[m + 2*n];
357  }
358  TSVMQP::~TSVMQP() {
359      delete[] pl; delete[] primal; delete[] dual;
360  }
361  bool TSVMQP::solve(const int& size, const double& bb, double *u, double *Q,
362                     double *A, double *c, double *resultV, const int& verbosity) {
363      IAssert(size <= n);
364      int i;
365      double b = bb;
366      int verb = 0;
367      double init_margin = 0.15;
368      long init_iter = 500;
369      double sigdig = 8;
370      int result = TPrLoqo::pr_loqo(size, m, c, Q, A, &b, pl, u,
371                           primal, dual, verb, sigdig,
372                           init_iter, init_margin,
373                           u[0] / 4.0, 0);
374      if (!TFlt::IsNum(dual[0]) && verbosity > 0) printf("ERR[nan]");
375      if (result == OPTIMAL_SOLUTION) {
376          for (i = 0; i < size; i++) resultV[i] = primal[i];
377          return true;
378      };
379      if (verbosity > 0) printf("ERR[%d]", result);
380      return false;
381  }
382  inline double TSVMQPSolver::kernel(const int& i1, const int& i2) const {
383      if (is_linear) {
384          return docs->DotProduct(i1, i2);
385      } else {
386          return nonlin_kernel->CalcSet(docs, i1, i2);
387      }
388  }
389  void TSVMQPSolver::readColumnRows(const int& i, const int& len, int *ids,
390                          double *result, const bool& store, const bool& sync) {
391      int j,k;
392      if (cache.Exists(i))  {
393          cache_yes++;
394          TSVMCacheVec vec = cache.Get(i);
395          TFltType *vecVals = vec.valT;
396          bool *vecValid = vec.validT;
397          int *vecIds = vec.idsT;
398          int vecLen = vec.dim;
399          if (sync) {
400              if (len == vecLen) {
401                  for (j = 0; j < len; j++) {
402                      Assert(vecIds[ids[j]] == j);
403                      result[j] = vecVals[j];
404                  }
405              } else {
406                  for (j = 0; j < len; j++)  {
407                      k = vecIds[ids[j]];
408                      Assert(0 <= k && k <= vecLen && vecValid[k]);
409                      result[j] = vecVals[k];
410                  }
411              }
412          } else {
413              for (j = 0; j < len; j++) {
414                  k = vecIds[ids[j]];
415                  if (k >= 0) {
<span onclick='openModal()' class='match'>416                      if (vecValid[k]) {
417                          Assert(k <= vecLen);
418                          result[j] = vecVals[k];
419                      } else {
420                          if (cache.IsRowValid(ids[j], i)) {
421                              result[j] = cache.GetVal(ids[j], i);
422                          } else {
423                              result[j] = kernel(i, ids[j]);
</span>424                              kernel_count++;
425                          }
426                          vecVals[k] = (TFltType)result[j];
427                          vecValid[k] = true;
428                      }
429                  } else {
430                      result[j] = kernel(i, ids[j]);
431                      kernel_count++;
432                  }
433              } 
434          } 
435      } else {
436          cache_no++;
437          for (j = 0; j < len; j++) {
438              k = ids[j];
439              if (cache.IsRowValid(ids[j], i)) {
440                  result[j] = cache.GetVal(k, i);
441              } else {
442                  result[j] = kernel(i, ids[j]);
443                  kernel_count++;
444              }
445          }
446          if (store) {
447              TSVMCacheVec vec = cache.Add(i);
448              TFltType *vecVals = vec.valT;
449              bool *vecValid = vec.validT;
450              int *vecIds = vec.idsT;
451              int vecLen = vec.dim;
452              if (sync) {
453                  if (len == vecLen) {
454                      for (j = 0; j < len; j++) {
455                          Assert(vecIds[ids[j]] != -1);
456                          vecVals[j] = (TFltType)result[j];
457                          vecValid[j] = true;
458                      }
459                  } else {
460                      for (j = 0; j < vecLen; j++) vecValid[j] = false;
461                      for (j = 0; j < len; j++) {
462                          k = vecIds[ids[j]];
463                          Assert(0 <= k && k <= vecLen);
464                          vecVals[k] = (TFltType)result[j];
465                          vecValid[k] = true; 
466                      }
467                  }
468              } else {
469                  int l = docs->Len();
470                  for (j = 0; j < vecLen; j++) vecValid[j] = false;
471                  for (j = k = 0; j < l; j++) {
472                      if (j < ids[k]) {
473                          if (vecIds[j] >= 0) {
474                              Assert(vecIds[j] <= vecLen);
475                              if (cache.IsRowValid(j, i)) {
476                                  vecVals[vecIds[j]] = cache.GetVal(j, i);
477                              } else {
478                                  vecVals[vecIds[j]] = (TFltType)kernel(i, j);
479                                  kernel_count++;
480                              }
481                              vecValid[vecIds[j]] = true;
482                          }
483                      } else {
484                          Assert(j == ids[k]);
485                          if (vecIds[j] >= 0) {
486                              vecVals[vecIds[j]] = (TFltType)result[k];
487                              vecValid[vecIds[j]] = true;
488                          }
489                          k++;
490                      }
491                  }
492              } 
493          } 
494      } 
495  }
496  inline void TSVMQPSolver::column(const int& i, double *result) {
497      readColumnRows(i, numUSV, USV, result, true, shrinking);
498  }
499  void TSVMQPSolver::calcColumns(const int& n) {
500      for (int i = 0; i < n; i++)
501          column(USV[workingSet[i]], cols[i]);
502  }
503  void TSVMQPSolver::optimize(TFltV& alphas, double& _base, const PSVMTrainSet& _docs,
504         const TFltV& _pV, const TFltV& _yV, const double& _D, const TFltV& _CV,
505         const int& sub_size, const int& memory_size, const int& time) {
506      IAssert(_docs->Len() > 0 && _docs->Dim() > 0);
507      IAssert(_pV.Len() == _yV.Len() && _yV.Len() == _CV.Len());
508      docs = _docs;
509      int i, ii, j, jj;       
510      int len = docs->Len();  
511      int size = sub_size + sub_size % 2;
512      size = size < len ? size : len;
513      IAssert(size >= 2);
514      double *QQ = new double[size*size];
515      double *Q = new double[size * size]; 
516      double *A = new double[size]; 
517      double *cc = new double[size]; 
518      double *u = new double[size]; 
519      TSVMQP qp(size);
520      if (!is_linear) initializeCache(memory_size, size);
521      bool old_shrinking = shrinking;
522      shrink = new TShrinkState;
523      shrinkInitialize();
524      initialize(_pV, _yV, _D, _CV, size);
525      int n; 
526      initRelearning(alphas);
527      initNonzeroD(size);
528      TSVMTime time_tmp, time_workingset = 0, time_kernel = 0, time_prepare = 0,
529               time_solve = 0, time_s = 0, time_analize = 0, time_shrink = 0;
530      double leq, res; 
531      double old_violation = 0.0;
532      double absChange = 1.0; 
533      int noChangeCount = 0; 
534      int numUnbnd;   
535      TSVMTime trainingTime = GetCurrentTime();
536      bool overTime = false; iter = 0;
537      do {
538          if (verbosity > 0 && (verbosity > 1 || iter % 100 == 0)) printf(".");
539          iter++;
540          time_tmp = GetCurrentTime();
541          bool DoingRandomStep = false;
542              n = selectWorkingSet(size, false);
543          IAssert(n >= 2 && n <= size);
544          time_workingset += GetCurrentTime() - time_tmp;
545          time_tmp= GetCurrentTime();
546          if (!is_linear) {
547              calcColumns(n);
548          }
549          time_kernel += GetCurrentTime() - time_tmp;
550          time_tmp = GetCurrentTime();
551          double b = 0.0;
552          for (i = 0; i < numUSV; i++) b -= alphaV[USV[i]] * y[USV[i]];
553          for (i = 0; i < numBSV; i++) b -= alphaV[BSV[i]] * y[BSV[i]]; 
554          for (i = 0; i < n; i++) {
555              ii = USV[workingSet[i]];
556              Assert(0 <= ii && ii < len);
557              b += alphaV[ii] * y[ii];  
558              A[i] = y[ii];
559              cc[i] = gradV[ii];
560              u[i] = C[ii];
561              for (j = 0; j < n; j++) {
562                  jj = USV[workingSet[j]];
563                  Assert(0 <= jj && jj < len);
564                  if (is_linear) {
565                      kernel_count++;
566                      if (j >= i) {
567                          QQ[i*n + j] = res = kernel(ii,jj);
568                      } else {
569                          res = QQ[j*n + i];
570                      }
571                  } else {
572                      res = cols[i][workingSet[j]];
573                  }
574                  cc[i] -= alphaV[jj]*y[jj]*res;
575                  Q[i*n + j] = y[ii]*y[jj]*res;
576              }
577              cc[i] = y[ii]*cc[i] + p[ii];
578          }
579          b = D + b;
580          time_prepare += GetCurrentTime() - time_tmp;
581          time_tmp= GetCurrentTime();
582          double *newAlphaV = new double[n];   
583          if (!qp.solve(n, b, u, Q, A, cc, newAlphaV, verbosity)) {
584              for(int i = 0; i < n; i++)
585                  newAlphaV[i] = alphaV[USV[workingSet[i]]];
586          }
587          for (i = 0; i < n; i++) {
588              if (C[USV[workingSet[i]]] - newAlphaV[i] < EPSILON)
589                  newAlphaV[i] = C[USV[workingSet[i]]];
590              else if (newAlphaV[i] < EPSILON)
591                  newAlphaV[i] = 0.0;
592          }
593          time_solve += GetCurrentTime() - time_tmp;
594          time_tmp = GetCurrentTime();
595          adjustS(n, newAlphaV);
596          time_s += GetCurrentTime() - time_tmp;
597          time_tmp= GetCurrentTime();
598          absChange = 0.0;
599          for (i = 0; i < n; i++) {
600              ii = USV[workingSet[i]];
601              used[ii] = false;
602              absChange += fabs(alphaV[ii] - newAlphaV[i]);
603              alphaV[ii] = newAlphaV[i];
604          }
605          delete[] newAlphaV;
606          if (DoingRandomStep) {
607              absChange = 1.0; noChangeCount = 0;
608          } else if (absChange < EPSILON) {
609              noChangeCount++;
610          } else {
611              noChangeCount = 0;
612          }
613          leq = 0.0;
614          numUnbnd = 0;
615          for (i = numUnbnd = 0; i < numUSV; i++) {
616              ii = USV[i];
617              res = gradV[ii] + y[ii] * p[ii];
618              listV[ii] = res;
619              if (EPSILON < alphaV[ii] && alphaV[ii] < C[ii] - EPSILON) {
620                  leq += -res;
621                  numUnbnd++;
622              }
623          }
624          if (numUnbnd > 0) {  
625              base = leq = leq / numUnbnd;
626              old_violation = max_violation;
627              max_violation = shrinking ? shrinkCheckOptimality(1, leq) :
628                                          checkOptimality(leq);
629              if (shrinking) {
630                  if (is_linear && iter > 30 && iter % 3 == 0 && numUSV < len &&
631                      max_violation - old_violation > 0.1) {
632                      if (verbosity > 1) printf("#");
633                      shrinkReactivate();
634                      shrinkCheckOptimality(h, leq);
635                      if (shrink->count >= minNumElts)
636                          shrinkReduce();
637                  } else if (max_violation > epsilon_ter) {
638                      if ((shrink->count >= minNumElts) && (iter % h == 0) &&
639                          (is_linear || shrink->hcount < shrink->aHist.Reserved())) {
640                            shrinkReduce();
641                      }
642                  } else  {
643                      time_analize += GetCurrentTime() - time_tmp;
644                      time_tmp= GetCurrentTime();
645                      if (verbosity > 0) printf("\nchecking unactive variables...");
646                      shrinkReactivate();
647                      time_shrink += GetCurrentTime() - time_tmp;
648                      time_tmp= GetCurrentTime();
649                      old_violation = max_violation;
650                      max_violation = checkOptimality(leq);
651                      if (verbosity > 0 && max_violation > epsilon_ter) printf("\n");
652                      if (!is_linear) shrinking = false;
653                  }
654              }
655              if (verbosity > 2) printf("<%.5f,%.5f>", max_violation, absChange);
656          }
657          time_analize += GetCurrentTime() - time_tmp;
658          if (time != -1) overTime = ToSeconds(GetCurrentTime() - trainingTime) > time;
659      } while ((max_violation > epsilon_ter || numUnbnd == 0) && (!overTime) && (noChangeCount < 30));
660      shrinking = old_shrinking;
661      alphas.Reserve(len,len);
662      for (i = 0; i < len; i++)
663          alphas[i] = alphaV[i];
664      _base = base;
665      if (verbosity > 0) {
666          printf("\n");
667          if (verbosity == 1) {
668              printf("Max-Violation = %.6f\n", max_violation);
669              double time_all = ToSeconds(time_workingset + time_kernel +
670                  time_prepare + time_solve + time_s + time_analize + time_shrink);
671              printf("Iterations = %d, Time=%.3f\n", iter, time_all);
672          } else {
673              printf("Max-Violation = %.6f\n", max_violation);
674              printf("Iterations = %d, Kernel-Count=%d\n", iter, kernel_count);
675              if (verbosity > 1) {
676                  printf("Time: workset=%.3f, kernel=%.3f, prepare=%.3f, solve=%.3f,\n"
677                         "      s=%.3f, analize=%.3f, shrink=%.3f\n",
678                      ToSeconds(time_workingset), ToSeconds(time_kernel), ToSeconds(time_prepare),
679                      ToSeconds(time_solve), ToSeconds(time_s), ToSeconds(time_analize),
680                      ToSeconds(time_shrink));
681              }
682              if (!is_linear)
683                  printf("Cache: yes = %d, no = %d\n", cache_yes, cache_no);
684          }
685      }
686      dealocate();
687      delete[] QQ; delete[] Q; delete[] A; delete[] cc; delete[] u;
688      delete shrink;
689  }
690  void TSVMQPSolver::initializeCache(const int& memory_size, int& size) {
691      cache.Reset(memory_size, docs->Len());
692      if (cache.MaxSize() < size) {
693          if (cache.MaxSize() < 2) {
694              printf("cache size is to small, can't even store two columns!\n");
695          } else {
696              size = cache.MaxSize() - cache.MaxSize() % 2;
697              if (verbosity > 0)
698                  printf("cache size is to small, size of subQP = %d", size);
699          }
700      }
701      cache_yes = cache_no = 0;
702  }
703  void TSVMQPSolver::initialize(const TFltV& _pV, const TFltV& _yV,
704             const double& _D, const TFltV& _CV, const int& size) {
705      int len = docs->Len();
706      int dim = docs->Dim();
707      max_violation = 0.0;       
708      kernel_count = 0;          
709      D = _D;
710      p = new double[len];
711      y = new double[len];
712      C = new double[len];
713      gradV = new double[len];   
714      listV = new double[len];
715      alphaV = new double[len];  
716      used = new bool[len];       
717      workingSet = new int[size]; 
718      for (int i = 0; i < len; i++) {
719          alphaV[i] = gradV[i] = 0.0;
720          used[i] = false;
721          p[i] = _pV[i];
722          y[i] = _yV[i];
723          listV[i] = y[i] * p[i];
724          IAssert(_CV[i] > 0); C[i] = _CV[i];
725      }
726      if (is_linear) {
727          weightV = new double[dim];
728          for (int j = 0; j < dim; j++) weightV[j] = 0.0;
729      }
730      if (!is_linear) {
731          cols.Reserve(size, size);
732          for (int i = 0; i < size; i++) cols[i] = new double[len];
733      }
734  }
735  void TSVMQPSolver::initRelearning(TFltV& alphas) {
736      int len = docs->Len();  
737      int dim = docs->Dim();  
738      int i, ii;
739      if (alphas.Len() != 0 && alphas.Len() == len) {
740          printf("relearning...\n");
741          double res;
742          if (is_linear) {
743              for (i = 0; i < dim; i++) weightV[i] = 0.0;
744              for (i = 0; i < len; i++) {
745                  res = (alphas[i] - alphaV[i]) * y[i];
746                  docs->AddVec(i, weightV, dim, res);
747              }
748              for (i = 0; i < numUSV; i++) {
749                  ii = USV[i];
750                  gradV[ii] += docs->DotProduct(ii, weightV, dim);
751                  listV[ii] += gradV[ii];
752              }
753          } else {
754              printf("relearning not implemented for non-linear svm!\n"); Fail;
755          }
756      }
757  }
758  void TSVMQPSolver::initNonzeroD(const int& size) {
759      int len = docs->Len();  
760      int dim = docs->Dim();  
761      int i, j;
762      if (D > 0.0) {
763          if (is_linear)
764              for (i = 0; i < dim; i++) weightV[i] = 0.0;
765          double minC = C[0];
766          for (i = 0; i < len; i++)
767              minC = TFlt::GetMn(minC, C[i]);
768          int M1 = (int)(2*D/minC) + size, M2 = 0;
769          for (i = 0; i < len; i++) if (y[i] > 0.0) M2++;
770          int M = M1 < M2 ? M1 : M2;
771          double beginningAlpha = D/M;
772          double res;
773          i = 0;
774          while (i < len) {
775              if (y[i] > 0.0) {
776                  alphaV[i] = beginningAlpha;
777                  M--;
778                  if (is_linear) {
779                      docs->AddVec(i, weightV, dim, alphaV[i] * y[i]);
780                  } else {
781                      double *ker = new double[len];
782                      column(i, ker);
783                      res = alphaV[i] * y[i];
784                      for (j = 0; j < len; j++) {
785                          gradV[j] += res * ker[j];
786                      }
787                      delete[] ker;
788                  }
789                  if (M == 0) break;
790              }
791              i++;
792          }
793          IAssert(M == 0);
794          if (is_linear) {
795              for (i = 0; i < len; i++) {
796                  gradV[i] += docs->DotProduct(i, weightV, dim);
797              }
798          }
799          for (i = 0; i < len; i++)
800              listV[i] += gradV[i];
801      }
802  }
803  void TSVMQPSolver::dealocate() {
804      if (!is_linear) {
805          cache.Clear();
806          int size = cols.Len();
807          for (int i = 0; i < size; i++) delete cols[i];
808      }
809      delete[] p, delete[] y; delete[] C;
810      delete[] gradV; delete[] listV;
811      delete[] alphaV;
812      if (is_linear) delete[] weightV;
813      delete[] used; delete[] workingSet;
814      delete[] USV; delete[] BSV; delete[] NSV;
815  }
816  int TSVMQPSolver::selectWorkingSet(const int& n, const bool& random) {
817      int i, j, jj;   
818      int q = n / 2;
819      if (random) {
820          TIntV WorkSetTmpV(numUSV, 0);
821          for (i = 0; i < numUSV; i++) {
822              if (!used[USV[i]])
823                  WorkSetTmpV.Add(i);
824          }
825          WorkSetTmpV.Shuffle(rnd);
826          const int Len = TInt::GetMn(numUSV, n);
827          for (int i = 0; i < Len; i++) {
828              j = WorkSetTmpV[i];
829              jj = USV[j];
830              workingSet[i] = j;
831              used[jj] = true;
832          }
833          return n;
834      }
835      TMaxHeap maxHeap(q); TMaxHeapVal maxElt;
836      TMinHeap minHeap(q); TMinHeapVal minElt; 
837      for (j = 0; j < numUSV; j++) {
838          jj = USV[j];
839          if (EPSILON < alphaV[jj] && alphaV[jj] < C[jj] - EPSILON) {
840              minElt.id = maxElt.id = j;
841              minElt.val = maxElt.val = listV[jj];
842              if (!maxHeap.Full()) { maxHeap.Add(maxElt); }
843              else if (maxElt > maxHeap.Top()) { maxHeap.ChangeTop(maxElt); }
844              if (!minHeap.Full()) { minHeap.Add(minElt);}
845              else if (minElt > minHeap.Top()) { minHeap.ChangeTop(minElt); }
846          } else {
847              if ((alphaV[jj] < EPSILON && y[jj] < 0) ||
848                  (alphaV[jj] > C[jj] - EPSILON && y[jj] > 0)) {
849                      maxElt.id = j; maxElt.val = listV[jj];
850                      if (!maxHeap.Full()) { maxHeap.Add(maxElt); }
851                      else if (maxElt > maxHeap.Top()) { maxHeap.ChangeTop(maxElt); }
852              }
853              if ((alphaV[jj] < EPSILON && y[jj] > 0) ||
854                  (alphaV[jj] > C[jj] - EPSILON && y[jj] < 0)) {
855                      minElt.id = j; minElt.val = listV[jj];
856                      if (!minHeap.Full()) { minHeap.Add(minElt); }
857                      else if (minElt > minHeap.Top()) { minHeap.ChangeTop(minElt); }
858              }
859          }
860      } 
861      int cs = 0;
862      int heapSize = maxHeap.Size();
863      TMaxHeapVal *maxArray = maxHeap.Array();
864      for (i = 1; i <= heapSize; i++) {
865          Assert(0 <= maxArray[i].id && maxArray[i].id < numUSV);
866          workingSet[cs++] = maxArray[i].id;
867          used[USV[maxArray[i].id]] = true;
868      }
869      heapSize = minHeap.Size();
870      TMinHeapVal *minArray = minHeap.Array();
871      for (i = 1; i <= heapSize; i++) {  
872          if (!used[USV[minArray[i].id]]) {
873              Assert(0 <= minArray[i].id && minArray[i].id < numUSV);
874              workingSet[cs++] = minArray[i].id;
875              used[USV[minArray[i].id]] = true;
876          } else {
877          }
878      }
879      return cs;
880  }
881  void TSVMQPSolver::adjustS(const int& n, double *newAlphaV) {
882      int dim = docs->Dim();
883      int i, ii, j ,jj;
884      double res;
885      if (is_linear) {
886          for (i = 0; i < dim; i++) weightV[i] = 0.0;
887          for (i = 0; i < n; i++) {
888              ii = USV[workingSet[i]];
889              res = (newAlphaV[i] - alphaV[ii]) * y[ii];
890              docs->AddVec(ii, weightV, dim, res);
891          }
892          for (i = 0; i < numUSV; i++) {
893              ii = USV[i];
894              gradV[ii] += docs->DotProduct(ii, weightV, dim);
895          }
896      } else {
897          double *ker;
898          for (i = 0; i < n; i++) {
899              ii = USV[workingSet[i]];
900              res = (newAlphaV[i] - alphaV[ii]) * y[ii];
901              ker = cols[i];
902              for (j = 0; j < numUSV; j++) {
903                  jj = USV[j];
904                  gradV[jj] += res * ker[j];
905              }
906          }
907      }
908  }
909  double TSVMQPSolver::checkOptimality(double leq) {
910      int i, ii;
911      double res, max = 0.0;
912      for (i = 0; i < numUSV; i++) {
913          ii = USV[i];
914          if (EPSILON < alphaV[ii] && alphaV[ii] < C[ii] - EPSILON) {
915              res = fabs(leq + listV[ii]);
916              max = TFlt::GetMx(max, res);
917          } else if (alphaV[ii] < EPSILON) {
918              res = y[ii]*(gradV[ii] + leq) + p[ii];  
919              max = TFlt::GetMx(max, -res);
920          } else {
921              Assert(alphaV[ii] > C[ii] - EPSILON);
922              res = y[ii]*(gradV[ii] + leq) + p[ii];
923              max = TFlt::GetMx(max, res);
924          }
925      }
926      return max;
927  }
928  void TSVMQPSolver::shrinkInitialize() {
929      int len = docs->Len();
930      int i;
931      USV = new int[len];     
932      BSV = new int[len];     
933      NSV = new int[len];     
934      numUSV = len;
935      numBSV = numNSV = 0;
936      shrink->BSVcount = new int[len];
937      shrink->NSVcount = new int[len];
938      if (is_linear) {
939          shrink->epsilon = 0.01; 
940          shrink->aOld = new double[len];
941          shrink->sOld = new double[len];
942          for (i = 0; i < len; i++) {
943              USV[i] = i;
944              shrink->BSVcount[i] = shrink->NSVcount[i] = 0;
945              shrink->aOld[i] = shrink->sOld[i] = 0.0;
946          }
947      } else {
948          shrink->epsilon = 2.0;
949          shrink->aHist.Reserve(100,0);
950          shrink->histID = new int[len];
951          shrink->hcount = 0;
952          for (i = 0; i < len; i++) {
953              USV[i] = i;
954              shrink->BSVcount[i] = shrink->NSVcount[i] = 0;
955              shrink->histID[i] = -1;
956          }
957      }
958  }
959  double TSVMQPSolver::shrinkCheckOptimality(int step, const double& leq) {
960      int i, ii; 
961      double res, max = 0.0;
962      if (!is_linear)
963          shrink->epsilon = 0.7*shrink->epsilon + 0.3*max_violation;
964      shrink->count = 0;
965      for (i = 0; i < numUSV; i++) {
966          ii = USV[i];
967          if (EPSILON < alphaV[ii] && alphaV[ii] < C[ii] - EPSILON) {
968              res = fabs(leq + listV[ii]);
969              max = TFlt::GetMx(max, res);
970          } else if (alphaV[ii] < EPSILON) {
971              res = y[ii]*(gradV[ii] + leq) + p[ii];
972              if (res > shrink->epsilon) {
973                  shrink->NSVcount[ii] += step;
974                  if (shrink->NSVcount[ii] >= h) shrink->count++;
975              } else {
976                  shrink->NSVcount[ii] = 0;
977              }
978              max = TFlt::GetMx(max, -res);
979          } else if (alphaV[ii] > C[ii] - EPSILON) {
980              res = y[ii]*(gradV[ii] + leq) + p[ii];
981              if (res < -shrink->epsilon) {
982                  shrink->BSVcount[ii] += step;
983                  if (shrink->BSVcount[ii] >= h) shrink->count++;
984              } else {
985                  shrink->BSVcount[ii] = 0;
986              }
987              max = TFlt::GetMx(max, res);
988          } else {
989              printf("we shouldn't be here... %d\n", __LINE__); Fail;
990          }
991      }
992      return max;
993  }
994  void TSVMQPSolver::shrinkReduce() {
995      int len = docs->Len();
996      int i, ii, j = 0;
997      int newnumUSV = 0;
998      if (!is_linear) {
999          TFltV ha(len);
1000          for (i = 0; i < len; i++) ha[i] = alphaV[i];
1001          shrink->aHist.Add(TFltVP::New(ha));
1002      } else {
1003      }
1004      for (i = 0; i < numUSV; i++) {
1005          ii = USV[i];
1006          if (shrink->NSVcount[ii] >= h) {
1007              NSV[numNSV] = ii;
1008              if (!is_linear) {
1009                  shrink->histID[ii] = shrink->hcount;
1010              }
1011              numNSV++;
1012          } else if (shrink->BSVcount[ii] >= h) {
1013              BSV[numBSV] = ii;
1014              if (!is_linear) {
1015                  shrink->histID[ii] = shrink->hcount;
1016              }
1017              numBSV++;
1018          } else {
1019              USV[j] = ii;
1020              j++; newnumUSV++;
1021          }
1022      }
1023      if (!is_linear) {
1024          if (cache.Full())
1025              cache.Shrink(newnumUSV, USV);
1026          if (verbosity > 1) printf("[%d:%d]", shrink->hcount, len - newnumUSV);
1027          shrink->hcount++;
1028      } else {
1029          if (verbosity > 1) printf("[%d]", len - newnumUSV);
1030      }
1031      numUSV = newnumUSV;
1032  }
1033  void TSVMQPSolver::shrinkReactivate() {
1034      int i, j;
1035      int len = docs->Len();
1036      int dim = docs->Dim();
1037      if (is_linear) {
1038          double res;
1039          for (i = 0; i < dim; i++) weightV[i] = 0.0;
1040          for (i = 0; i < len; i++) {
1041              if (shrink->aOld[i] != alphaV[i]) {
1042                  res = (alphaV[i] - shrink->aOld[i]) * y[i];
1043                  docs->AddVec(i, weightV, dim, res);
1044              }
1045              shrink->aOld[i] = alphaV[i];
1046          }
1047          for (i = 0, j = 0; i < len; i++) {
1048              if (USV[j] > i)
1049                  gradV[i] = shrink->sOld[i] + docs->DotProduct(i, weightV, dim);
1050              else
1051                  j++;
1052              shrink->sOld[i] = gradV[i];
1053          }
1054      } else {
1055          int k, kk;
1056          PFltV a_old;
1057          double res;
1058          int numInactive;    
1059          int *inactiveIds = new int[len];    
1060          double *col = new double[len];      
1061          for (i = shrink->hcount - 1; i >= 0; i--) {
1062              if (verbosity > 1) printf("..%d", i);
1063              a_old = shrink->aHist[i];
1064              numInactive = 0;
1065              for (j = 0; j < len; j++) {
1066                  if (shrink->histID[j] == i) {
1067                      inactiveIds[numInactive] = j;
1068                      numInactive++;
1069                      shrink->histID[j] = -1;
1070                  }
1071              }
1072              for (j = 0; j < len; j++) {
1073                  a_old->Len();
1074                  if (a_old->GetVal(j) != alphaV[j]) {
1075                      readColumnRows(j, numInactive, inactiveIds, col, false, false);
1076                      res = (alphaV[j] - a_old->GetVal(j)) * y[j];
1077                      for (k = 0; k < numInactive; k++) {
1078                          kk = inactiveIds[k];
1079                          gradV[kk] += res * col[k];
1080                      }
1081                  }
1082              }
1083          }
1084          delete[] col;
1085          delete[] inactiveIds;
1086          shrink->hcount = 0;
1087          shrink->aHist.Reserve(100,0);
1088      }
1089      numUSV = len; numBSV = numNSV = 0;
1090      for (i = 0; i < len; i++) {
1091          USV[i] = i;
1092          shrink->BSVcount[i] = shrink->NSVcount[i] = 0;
1093          listV[i] = gradV[i] + y[i] * p[i];;
1094      }
1095  }
1096  TSVMQPSolver::TSVMTime TSVMQPSolver::GetCurrentTime() {
1097  #ifdef GLib_WIN32
1098      FILETIME lpCreationTime; 
1099      FILETIME lpExitTime;     
1100      FILETIME lpKernelTime;   
1101      FILETIME lpUserTime;     
1102      GetProcessTimes(GetCurrentProcess(), &lpCreationTime, &lpExitTime,
1103                                           &lpKernelTime, &lpUserTime);
1104      return lpUserTime.dwLowDateTime +
1105             ((unsigned __int64)lpUserTime.dwHighDateTime << 32);
1106  #elif defined(GLib_UNIX)
1107      return TSysTm::GetCurUniMSecs();            
1108  #endif
1109  }
1110  inline double TSVMQPSolver::ToSeconds(TSVMTime time) {
1111      return time / 1e7;
1112  }
1113  template <class TVal>
1114  void TSVMQPSolver::THeap<TVal>::Add(const TVal& elt) {
1115      n++; int i = n;
1116      while (i > 1 && array[i/2] > elt) {
1117          array[i] = array[i/2]; i = i/2;
1118      }
1119      array[i] = elt;
1120  }
1121  template <class TVal>
1122  void TSVMQPSolver::THeap<TVal>::ChangeTop(const TVal& elt) {
1123      int left, right, smallest, i = 1; TVal tmp; array[1] = elt;
1124      forever {
1125          left = 2*i; right = 2*i + 1;
1126          if (left <= n && elt > array[left])
1127              smallest = left;
1128          else
1129              smallest = i;
1130          if (right <= n && array[smallest] > array[right])
1131              smallest = right;
1132          if (smallest != i) {
1133              tmp = array[i];
1134              array[i] = array[smallest];
1135              array[smallest] = tmp;
1136              i = smallest;
1137          } else break;
1138      }
1139  }
1140  void TSVMLargeScale::Solve(PSVMTrainSet TrainSet, const double& SvmCost,
1141          const double& AccuracyEps, const int& MxTime, const bool& TillMxIter,
1142          const int& ProcN, TFltV& WgtV, PNotify Notify) {
1143      EAssertR(TrainSet->Len() > 0, "Empty training set!");
1144      EAssertR(SvmCost > 0.0, "Cost parameter must be nonzero!");
1145      EAssertR(AccuracyEps > 0.0, "Accuaryc epsilon must be nonzero!");
1146      const int Dims = TrainSet->Dim(); 
1147      const int Vecs = TrainSet->Len(); 
1148      const double InvVecs = 1.0 / double(Vecs); 
1149      WgtV.Gen(Dims); WgtV.PutAll(0.0); 
1150      double Slack = 0.0; 
1151      TIntV ConstrLenV; 
1152      TVec<TFltV> ConstrVecsVV; 
1153      TVVec<double> QPQuad; TVec<double> QPLin, QPConstr;
1154      double MxVecNorm2 = 0.0;
1155      for (int VecId = 0; VecId < Vecs; VecId++) {
1156          MxVecNorm2 = TMath::Mx(MxVecNorm2, TrainSet->GetNorm2(VecId)); }
1157      int MxIters = TFlt::Round(TMath::Mx(2/AccuracyEps, (8*SvmCost*MxVecNorm2)/TMath::Sqr(AccuracyEps)));
1158      Notify->OnStatus(TInt::GetStr(MxIters, "Maximal number of iterations: %d"));
1159      int IterN = 0; TExeTm Timer;
1160      forever {
1161          ConstrVecsVV.Add(TFltV()); TFltV& ConstrVecsV = ConstrVecsVV.Last();
1162          ConstrVecsV.Gen(Vecs); ConstrVecsV.PutAll(0.0);
1163          int ConstrLen = 0; double ConstrSum = 0.0;
1164          for (int VecId = 0; VecId < Vecs; VecId++) {
1165              const double VecParam = TrainSet->GetVecParam(VecId);
1166              const double Val = VecParam * TrainSet->DotProduct(VecId, WgtV);
1167              if (Val < 1.0) {
1168                  TrainSet->AddVec(VecId, ConstrVecsV, VecParam);
1169                  ConstrLen++; ConstrSum += Val;
1170              }
1171          }
1172          ConstrLenV.Add(ConstrLen);
1173          for (int DimN = 0; DimN < Dims; DimN++) {
1174              ConstrVecsV[DimN] = InvVecs * ConstrVecsV[DimN]; }
1175          QPLin.Add(-  InvVecs * double(ConstrLen));
1176          TVVec<double> NewQPQuad(IterN+1, IterN+1);
1177          for (int i = 0; i < IterN; i++) {
1178              for (int j = 0; j < IterN; j++) {
1179                  NewQPQuad(i,j) = QPQuad(i,j); }
1180          }
1181          for (int i = 0; i < IterN; i++) {
1182              const double EltVal = TLinAlg::DotProduct(ConstrVecsVV[i], ConstrVecsV);
1183              NewQPQuad(IterN, i) = EltVal; NewQPQuad(i, IterN) = EltVal;
1184          }
1185          NewQPQuad(IterN, IterN) = TLinAlg::DotProduct(ConstrVecsV, ConstrVecsV);
1186          QPQuad = NewQPQuad;
1187          QPConstr.Add(1.0);
1188          const double StopCrit = InvVecs*ConstrLen - InvVecs*ConstrSum;
1189          if (StopCrit > (Slack + AccuracyEps)) { break; } 
1190          if ((MxTime != -1) && (Timer.GetSecs() > MxTime)) { break; } 
1191          IterN++; if (TillMxIter && (IterN > MxIters)) { break; } 
1192          Notify->OnStatus(TStr::Fmt("[IterN:%5d, Accr:%8.5f, Time:%5d s]\r",
1193              IterN, (StopCrit - Slack), Timer.GetSecs()));
1194      };
1195  }
1196  void TSVMFactory::trainClassifier(TFltV& alphas, double& threshold,
1197          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
1198          const double& C, const double& j, const TSVMLearnParam& LearnParam) {
1199      IAssert(C > 0.0 && j > 0.0);
1200      int len = docs->Len();
1201      TFltV p(len), y(len), CV(len);
1202      for (int i = 0; i < len; i++) {
1203          p[i] = -1;
1204          y[i] = docs->GetVecParam(i);
1205          CV[i] = (y[i] > 0) ? C*j : C;
1206      }
1207      int h = 10, minNumElts = is_linear ? 10 : 100;
1208      TSVMQPSolver solver(is_linear, ker, LearnParam.Verbosity,
1209          LearnParam.EpsTer, LearnParam.Shrink, h, minNumElts);
1210      solver.optimize(alphas, threshold, docs, p, y, 0, CV,
1211          LearnParam.SubSize, LearnParam.MemSize, LearnParam.Time);
1212  }
1213  void TSVMFactory::trainOneClass(TFltV& alphas, double& threshold,
1214          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
1215          const double& nu, const TSVMLearnParam& LearnParam) {
1216      IAssert(0.0 < nu && nu < 1.0);
1217      int len = docs->Len();
1218      double D = nu*len;
1219      TFltV p(len), y(len), C(len);
1220      for (int i = 0; i < len; i++) {
1221          p[i] = 0;
1222          y[i] = 1;
1223          C[i] = 1.0;
1224      }
1225      int h = 10, minNumElts = is_linear ? 10 : 100;
1226      TSVMQPSolver solver(is_linear, ker, LearnParam.Verbosity,
1227          LearnParam.EpsTer, LearnParam.Shrink, h, minNumElts);
1228      solver.optimize(alphas, threshold, docs, p, y, D, C,
1229          LearnParam.SubSize, LearnParam.MemSize, LearnParam.Time);
1230  }
1231  void TSVMFactory::trainRegression(TFltV& alphas, double& threshold,
1232          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
1233          const double& E, const double& C, const TSVMLearnParam& LearnParam) {
1234      IAssert(E > 0.0 && C > 0.0);
1235      int len = docs->Len();
1236      TIntV IdV(2*len, 0);
1237      TFltV p(2*len), y(2*len), CV(2*len);
1238      for (int i = 0; i < len; i++) {
1239          p[i] = E + docs->GetVecParam(i);
1240          y[i] = 1; CV[i] = C; IdV.Add(i);
1241      }
1242      for (int i = len; i < 2*len; i++) {
1243          p[i] = E - docs->GetVecParam(i-len);
1244          y[i] = -1; CV[i] = C; IdV.Add(i-len);
1245      }
1246      PSVMTrainSet docs2 = TSVMTrainSubSet::New(docs, IdV);
1247      int h = 10, minNumElts = is_linear ? 10 : 100;
1248      TSVMQPSolver solver(is_linear, ker, LearnParam.Verbosity,
1249          LearnParam.EpsTer, LearnParam.Shrink, h, minNumElts);
1250      solver.optimize(alphas, threshold, docs2, p, y, 0, CV,
1251          LearnParam.SubSize, LearnParam.MemSize, LearnParam.Time);
1252  }
1253  void TSVMFactory::train(TFltV& alphas, double& threshold,
1254          const bool& is_linear, const PKernel& ker, const PSVMTrainSet& docs,
1255          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam) {
1256      if (ModelParam.ModelType == smtClassifier) {
1257          trainClassifier(alphas, threshold, is_linear, ker, docs, ModelParam.C, ModelParam.j, LearnParam);
1258      } else if (ModelParam.ModelType == smtRegression) {
1259          trainRegression(alphas, threshold, is_linear, ker, docs, ModelParam.E, ModelParam.C, LearnParam);
1260      } else if (ModelParam.ModelType == smtOneClass) {
1261          trainOneClass(alphas, threshold, is_linear, ker, docs, ModelParam.nu, LearnParam);
1262      }
1263  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "graph.h"
3  TStr TVrtx::VIdNm="VId";
4  TStr TVrtx::PpNm="Pp";
5  TStr TVrtx::VNmNm="VNm";
6  TStr TVrtx::DNmNm="DNm";
7  TStr TVrtx::BriefNm="Brief";
8  TStr TVrtx::MarkNm="Mark";
9  TStr TVrtx::WgtNm="Wgt";
10  TStr TVrtx::HitsHubWNm="HitsHubW";
11  TStr TVrtx::HitsAuthWNm="HitsAuthW";
12  TStr TVrtx::PageRankWNm="PageRankW";
13  TStr TVrtx::XNm="X";
14  TStr TVrtx::YNm="Y";
15  TStr TVrtx::ZNm="Z";
16  TStr TVrtx::ColorNm="Color";
17  TStr TVrtx::ShapeNm="Shape";
18  TStr TVrtx::RectNm="Rect";
19  TStr TVrtx::RectX1Nm="Rect|X1"; TStr TVrtx::X1Nm="X1";
20  TStr TVrtx::RectY1Nm="Rect|Y1"; TStr TVrtx::Y1Nm="Y1";
21  TStr TVrtx::RectX2Nm="Rect|X2"; TStr TVrtx::X2Nm="X2";
22  TStr TVrtx::RectY2Nm="Rect|Y2"; TStr TVrtx::Y2Nm="Y2";
23  TStr TVrtx::DmNm="Dm";
24  void TVrtx::PutRect(const TGksRect& Rect){
25    GetPp()->PutValInt(RectX1Nm, Rect.GetX1());
26    GetPp()->PutValInt(RectY1Nm, Rect.GetY1());
27    GetPp()->PutValInt(RectX2Nm, Rect.GetX2());
28    GetPp()->PutValInt(RectY2Nm, Rect.GetY2());
29  }
30  TGksRect TVrtx::GetRect() const {
31    int X1=GetPp()->GetValInt(RectX1Nm);
32    int Y1=GetPp()->GetValInt(RectY1Nm);
33    int X2=GetPp()->GetValInt(RectX2Nm);
34    int Y2=GetPp()->GetValInt(RectY2Nm);
35    return TGksRect(X1, Y1, X2, Y2);
36  }
37  bool TVrtx::IsInRect(const double& X, const double& Y) const {
38    TGksRect Rect=TVrtx::GetRect();
39    return Rect.IsIn(int(X), int(Y));
40  }
41  PPp TVrtx::GetDrawPp(){
42    PPp Pp=TPp::GetSetPp("Draw");
43    Pp->AddPpStr(DNmNm, "", "");
44    Pp->AddPpFlt(XNm, "", TFlt::Mn, TFlt::Mx, 0);
45    Pp->AddPpFlt(YNm, "", TFlt::Mn, TFlt::Mx, 0);
46    Pp->AddPpInt(BriefNm, "", TInt::Mn, TInt::Mx, 0);
47    Pp->AddPpStr(ShapeNm, "", "");
48    PPp RectPp=TPp::GetSetPp(RectNm);
49    RectPp->AddPpInt(X1Nm, "", TInt::Mn, TInt::Mx, 0);
50    RectPp->AddPpInt(Y1Nm, "", TInt::Mn, TInt::Mx, 0);
51    RectPp->AddPpInt(X2Nm, "", TInt::Mn, TInt::Mx, 0);
52    RectPp->AddPpInt(Y2Nm, "", TInt::Mn, TInt::Mx, 0);
53    Pp->AddPp(RectPp);
54    return Pp;
55  }
56  PVrtx TVrtx::LoadXml(const PXmlTok& XmlTok){
57    int VId=XmlTok->GetIntArgVal(VIdNm);
58    TStr VNm=XmlTok->GetStrArgVal(VNmNm, "");
59    int Mark=XmlTok->GetIntArgVal(MarkNm, 0);
60    double Wgt=XmlTok->GetFltArgVal(WgtNm, 0);
61    double HitsHubW=XmlTok->GetFltArgVal(HitsHubWNm, 0);
62    double HitsAuthW=XmlTok->GetFltArgVal(HitsAuthWNm, 0);
63    double PageRankW=XmlTok->GetFltArgVal(PageRankWNm, 0);
64    double X=XmlTok->GetFltArgVal(XNm, 0);
65    double Y=XmlTok->GetFltArgVal(YNm, 0);
66    double Z=XmlTok->GetFltArgVal(ZNm, 0);
67    PPp Pp;
68    PVrtx Vrtx=PVrtx(new TGVrtx(VId, VNm, Pp));
69    Vrtx->PutMark(Mark); Vrtx->PutWgt(Wgt);
70    Vrtx->PutHitsHubW(HitsHubW); Vrtx->PutHitsAuthW(HitsAuthW);
71    Vrtx->PutPageRankW(PageRankW);
72    Vrtx->PutX(X); Vrtx->PutY(Y); Vrtx->PutZ(Z);
73    return Vrtx;
74  }
75  PXmlTok TVrtx::GetXmlTok() const {
76    PXmlTok VrtxTok=TXmlTok::New(TGraph::VrtxNm);
77    VrtxTok->AddArg(VIdNm, GetVId());
78    if (!GetVNm().Empty()){VrtxTok->AddArg(VNmNm, GetVNm());}
79    if (GetMark()!=0){VrtxTok->AddArg(MarkNm, GetMark());}
80    if (GetWgt()!=0){VrtxTok->AddArg(WgtNm, GetWgt());}
81    if (GetHitsHubW()!=0){VrtxTok->AddArg(HitsHubWNm, GetHitsHubW());}
82    if (GetHitsAuthW()!=0){VrtxTok->AddArg(HitsAuthWNm, GetHitsAuthW());}
83    if (GetPageRankW()!=0){VrtxTok->AddArg(PageRankWNm, GetPageRankW());}
84    if (GetX()!=0){VrtxTok->AddArg(XNm, GetX());}
85    if (GetY()!=0){VrtxTok->AddArg(YNm, GetY());}
86    if (GetZ()!=0){VrtxTok->AddArg(ZNm, GetZ());}
87    return VrtxTok;
88  }
89  PVrtx TVrtx::LoadTxt(TILx& Lx){
90    Lx.GetSym(syLBracket);
91    int VId=Lx.GetVarInt(VIdNm, false);
92    TStr VNm; int Mark=0; double Wgt=0;
93    double HitsHubW=0; double HitsAuthW=0; double PageRankW=0;
94    double X=0; double Y=0; double Z=0; PPp Pp;
95    if (Lx.IsVar(VNmNm)){VNm=Lx.GetVarStr(VNmNm, false);}
96    VNm=TXmlLx::GetPlainStrFromXmlStr(VNm);
97    if (Lx.IsVar(MarkNm)){Mark=Lx.GetVarInt(MarkNm, false);}
98    if (Lx.IsVar(WgtNm)){Wgt=Lx.GetVarFlt(WgtNm, false);}
99    if (Lx.IsVar(HitsHubWNm)){HitsHubW=Lx.GetVarFlt(HitsHubWNm, false);}
100    if (Lx.IsVar(HitsAuthWNm)){HitsAuthW=Lx.GetVarFlt(HitsAuthWNm, false);}
101    if (Lx.IsVar(PageRankWNm)){PageRankW=Lx.GetVarFlt(PageRankWNm, false);}
102    if (Lx.IsVar(XNm)){X=Lx.GetVarFlt(XNm, false);}
103    if (Lx.IsVar(YNm)){Y=Lx.GetVarFlt(YNm, false);}
104    if (Lx.IsVar(ZNm)){Z=Lx.GetVarFlt(ZNm, false);}
105    if (Lx.IsVar(PpNm)){
106      Lx.GetIdStr(PpNm); Lx.GetSym(syColon); Pp=TPp::LoadTxt(Lx);}
107    PVrtx Vrtx=PVrtx(new TGVrtx(VId, VNm, Pp));
108    Vrtx->PutMark(Mark); Vrtx->PutWgt(Wgt);
109    Vrtx->PutHitsHubW(HitsHubW); Vrtx->PutHitsAuthW(HitsAuthW);
110    Vrtx->PutPageRankW(PageRankW);
111    Vrtx->PutX(X); Vrtx->PutY(Y); Vrtx->PutZ(Z);
112    Lx.GetSym(syRBracket);
113    return Vrtx;
114  }
115  void TVrtx::SaveTxt(TOLx& Lx) const {
116    Lx.PutSym(syLBracket);
117    Lx.PutVarInt(VIdNm, GetVId(), false);
118    TStr XmlVNm=TXmlLx::GetXmlStrFromPlainStr(GetVNm());
119    if (!GetVNm().Empty()){Lx.PutVarStr(VNmNm, XmlVNm, false);}
120    if (GetMark()!=0){Lx.PutVarInt(MarkNm, GetMark(), false);}
121    if (GetWgt()!=0){Lx.PutVarFlt(WgtNm, GetWgt(), false);}
122    if (GetHitsHubW()!=0){Lx.PutVarFlt(HitsHubWNm, GetHitsHubW(), false);}
123    if (GetHitsAuthW()!=0){Lx.PutVarFlt(HitsAuthWNm, GetHitsAuthW(), false);}
124    if (GetPageRankW()!=0){Lx.PutVarFlt(PageRankWNm, GetPageRankW(), false);}
125    if (GetX()!=0){Lx.PutVarFlt(XNm, GetX(), false);}
126    if (GetY()!=0){Lx.PutVarFlt(YNm, GetY(), false);}
127    if (GetZ()!=0){Lx.PutVarFlt(ZNm, GetZ(), false);}
128    if (!GetPp().Empty()){
129      Lx.PutIdStr(PpNm); Lx.PutSym(syColon); GetPp()->SaveTxt(Lx);}
130    Lx.PutSym(syRBracket);
131  }
132  void TGVrtx::DefVrtx(const PGraph& Graph){
133    if (VId==-1){VId=Graph->GetNewVId();}
134    Graph->DefVId(VId);
135  }
136  TStr TEdge::EIdNm="EId";
137  TStr TEdge::VId1Nm="VId1";
138  TStr TEdge::VId2Nm="VId2";
139  TStr TEdge::PpNm="Pp";
140  TStr TEdge::DirPNm="Dir";
141  TStr TEdge::ENmNm="ENm";
142  TStr TEdge::MarkNm="Mark";
143  TStr TEdge::WgtNm="Wgt";
144  TStr TEdge::WidthNm="Width";
145  TStr TEdge::DNmNm="DNm";
146  TStr TEdge::BriefNm="Brief";
147  TStr TEdge::RectNm="Rect";
148  TStr TEdge::RectX1Nm="Rect|X1"; TStr TEdge::X1Nm="X1";
149  TStr TEdge::RectY1Nm="Rect|Y1"; TStr TEdge::Y1Nm="Y1";
150  TStr TEdge::RectX2Nm="Rect|X2"; TStr TEdge::X2Nm="X2";
151  TStr TEdge::RectY2Nm="Rect|Y2"; TStr TEdge::Y2Nm="Y2";
152  TStr TEdge::DmNm="Dm";
153  void TEdge::PutRect(const TGksRect& Rect){
154    GetPp()->PutValInt(RectX1Nm, Rect.GetX1());
155    GetPp()->PutValInt(RectY1Nm, Rect.GetY1());
156    GetPp()->PutValInt(RectX2Nm, Rect.GetX2());
157    GetPp()->PutValInt(RectY2Nm, Rect.GetY2());
158  }
159  TGksRect TEdge::GetRect() const {
160    int X1=GetPp()->GetValInt(RectX1Nm);
161    int Y1=GetPp()->GetValInt(RectY1Nm);
162    int X2=GetPp()->GetValInt(RectX2Nm);
163    int Y2=GetPp()->GetValInt(RectY2Nm);
164    return TGksRect(X1, Y1, X2, Y2);
165  }
166  bool TEdge::IsInRect(const double& X, const double& Y) const {
167    TGksRect Rect=TEdge::GetRect();
168    return Rect.IsIn(int(X), int(Y));
169  }
170  PPp TEdge::GetDrawPp(){
171    PPp Pp=TPp::GetSetPp("Draw");
172    Pp->AddPpStr(DNmNm, "", "");
173    Pp->AddPpInt(BriefNm, "", TInt::Mn, TInt::Mx, 0);
174    PPp RectPp=TPp::GetSetPp(RectNm);
175    RectPp->AddPpInt(X1Nm, "", TInt::Mn, TInt::Mx, 0);
176    RectPp->AddPpInt(Y1Nm, "", TInt::Mn, TInt::Mx, 0);
177    RectPp->AddPpInt(X2Nm, "", TInt::Mn, TInt::Mx, 0);
178    RectPp->AddPpInt(Y2Nm, "", TInt::Mn, TInt::Mx, 0);
179    Pp->AddPp(RectPp);
180    return Pp;
181  }
182  PEdge TEdge::LoadXml(const PXmlTok& XmlTok){
183    int EId=XmlTok->GetIntArgVal(EIdNm);
184    int VId1=XmlTok->GetIntArgVal(VId1Nm);
185    int VId2=XmlTok->GetIntArgVal(VId2Nm);
186    bool DirP=XmlTok->GetBoolArgVal(DirPNm, true);
187    TStr ENm=XmlTok->GetStrArgVal(ENmNm, "");
188    int Mark=XmlTok->GetIntArgVal(MarkNm, 0);
189    double Wgt=XmlTok->GetFltArgVal(WgtNm, 0);
190    int Width=int(XmlTok->GetFltArgVal(WidthNm, 0));
191    PPp Pp;
192    PEdge Edge=PEdge(new TGEdge(EId, VId1, VId2, DirP, ENm, Pp));
193    Edge->PutMark(Mark);
194    Edge->PutWgt(Wgt);
195    Edge->PutWidth(Width);
196    return Edge;
197  }
198  PXmlTok TEdge::GetXmlTok() const {
199    PXmlTok EdgeTok=TXmlTok::New(TGraph::EdgeNm);
200    EdgeTok->AddArg(EIdNm, GetEId());
201    EdgeTok->AddArg(VId1Nm, GetVId1());
202    EdgeTok->AddArg(VId2Nm, GetVId2());
203    if (!IsDir()){EdgeTok->AddArg(DirPNm, IsDir());}
204    if (!GetENm().Empty()){EdgeTok->AddArg(ENmNm, GetENm());}
205    if (GetMark()!=0){EdgeTok->AddArg(MarkNm, GetMark());}
206    if (GetWgt()!=0){EdgeTok->AddArg(WgtNm, GetWgt());}
207    if (GetWidth()!=0){EdgeTok->AddArg(WidthNm, GetWidth());}
208    return EdgeTok;
209  }
210  PEdge TEdge::LoadTxt(TILx& Lx){
211    Lx.GetSym(syLBracket);
212    int EId=Lx.GetVarInt(EIdNm, false);
213    int VId1=Lx.GetVarInt(VId1Nm, false);
214    int VId2=Lx.GetVarInt(VId2Nm, false);
215    bool DirP=true; TStr ENm; int Mark=0; double Wgt=0; int Width=0; PPp Pp;
216    if (Lx.IsVar(DirPNm)){DirP=Lx.GetVarBool(DirPNm, false);}
217    if (Lx.IsVar(ENmNm)){ENm=Lx.GetVarStr(ENmNm, false);}
218    ENm=TXmlLx::GetPlainStrFromXmlStr(ENm);
219    if (Lx.IsVar(MarkNm)){Mark=Lx.GetVarInt(MarkNm, false);}
220    if (Lx.IsVar(WgtNm)){Wgt=Lx.GetVarFlt(WgtNm, false);}
221    if (Lx.IsVar(WidthNm)){Width=Lx.GetVarInt(WidthNm, false);}
222    if (Lx.IsVar(PpNm)){
223      Lx.GetIdStr(PpNm); Lx.GetSym(syColon); Pp=TPp::LoadTxt(Lx);}
224    PEdge Edge=PEdge(new TGEdge(EId, VId1, VId2, DirP, ENm, Pp));
225    Edge->PutMark(Mark); Edge->PutWgt(Wgt); Edge->PutWidth(Width);
226    Lx.GetSym(syRBracket);
227    return Edge;
228  }
229  void TEdge::SaveTxt(TOLx& Lx) const {
230    Lx.PutSym(syLBracket);
231    Lx.PutVarInt(EIdNm, GetEId(), false);
232    Lx.PutVarInt(VId1Nm, GetVId1(), false);
233    Lx.PutVarInt(VId2Nm, GetVId2(), false);
234    if (!IsDir()){Lx.PutVarBool(DirPNm, IsDir(), false);}
235    TStr XmlENm=TXmlLx::GetXmlStrFromPlainStr(GetENm());
236    if (!GetENm().Empty()){Lx.PutVarStr(ENmNm, XmlENm(), false);}
237    if (GetMark()!=0){Lx.PutVarInt(MarkNm, GetMark(), false);}
238    if (GetWgt()!=0){Lx.PutVarFlt(WgtNm, GetWgt(), false);}
239    if (GetWidth()!=0){Lx.PutVarInt(WidthNm, GetWidth(), false);}
240    if (!GetPp().Empty()){GetPp()->SaveTxt(Lx);}
241    Lx.PutSym(syRBracket);
242  }
243  TGEdge::TGEdge(const int& _EId, const int& _VId1, const int& _VId2,
244   const bool& _DirP, const TStr& _ENm, const PPp& _Pp):
245    TEdge(), EId(_EId), VId1(_VId1), VId2(_VId2),
246    DirP(_DirP), ENm(_ENm), DNm(TStr()), Mark(0), Wgt(0), Width(0), Pp(_Pp){
247  }
248  TGEdge::TGEdge(const PVrtx& Vrtx1, const PVrtx& Vrtx2,
249   const TStr& _ENm, const bool& _DirP, const PPp& _Pp):
250    TEdge(), EId(-1), VId1(Vrtx1->GetVId()), VId2(Vrtx2->GetVId()),
251    DirP(_DirP), ENm(_ENm), DNm(TStr()), Mark(0), Wgt(0), Width(0), Pp(_Pp){
252  }
253  void TGEdge::DefEdge(const PGraph& Graph){
254    if (EId==-1){EId=Graph->GetNewEId();}
255    Graph->DefEId(EId);
256  }
257  TStr TGraph::PpNm="Pp";
258  TStr TGraph::VrtxNm="Vrtx";
259  TStr TGraph::EdgeNm="Edge";
260  TStr TGraph::GNmNm="GNm";
261  TStr TGraph::DNmNm="DNm";
262  TStr TGraph::BriefNm="Brief";
263  const TStr TGraph::FExt=".Graph";
264  const TStr TGraph::HitsFExt=".Hits";
265  const TStr TGraph::PageRankFExt=".PageRank";
266  THash<TStr, TGraph::TGraphNewF> TGraph::TypeToNewFH(10);
267  THash<TStr, TGraph::TGraphLoadF> TGraph::TypeToLoadFH(10);
268  PGraph TGraph::New(const TStr& TypeNm){
269    TStr FinalTypeNm=TypeNm;
270    if (TypeNm.Empty()){FinalTypeNm=TTypeNm<TGGraph>();}
271    TGraphNewF NewF=TypeToNewFH.GetDat(FinalTypeNm);
272    return (*NewF())();
273  }
274  PGraph TGraph::Load(TSIn& SIn){
275    TStr TypeNm(SIn);
276    TGraphLoadF LoadF=TypeToLoadFH.GetDat(TypeNm);
277    return (*LoadF())(SIn);
278  }
279  bool TGraph::Reg(
280   const TStr& TypeNm, const TGraphNewF& NewF, const TGraphLoadF& LoadF){
281    IAssert(!TypeToNewFH.IsKey(TypeNm));
282    IAssert(!TypeToLoadFH.IsKey(TypeNm));
283    TypeToNewFH.AddDat(TypeNm, NewF);
284    TypeToLoadFH.AddDat(TypeNm, LoadF);
285    return true;
286  }
287  void TGraph::_GetMnMxXY(
288   double& MnX, double& MnY, double& MxX, double& MxY) const {
289    MnX=0; MxX=0; MnY=0; MxY=0;
290    int VrtxP=FFirstVrtx(); PVrtx Vrtx; bool First=true;
291    while (FNextVrtx(VrtxP, Vrtx)){
292      if (First){
293        MnX=Vrtx->GetX(); MxX=Vrtx->GetX();
294        MnY=Vrtx->GetY(); MxY=Vrtx->GetY();
295        First=false;
296      } else {
297        if (Vrtx->GetX()<MnX){MnX=Vrtx->GetX();}
298        if (Vrtx->GetX()>MxX){MxX=Vrtx->GetX();}
299        if (Vrtx->GetY()<MnY){MnY=Vrtx->GetY();}
300        if (Vrtx->GetY()>MxY){MxY=Vrtx->GetY();}
301      }
302    }
303  }
304  void TGraph::_AddBorders(const double& BorderFac,
305   double& MnX, double& MnY, double& MxX, double& MxY) const {
306    if (MxX-MnX==0){MnX-=BorderFac; MxX+=BorderFac;}
307    else {MnX-=(MxX-MnX)*BorderFac; MxX+=(MxX-MnX)*BorderFac;}
308    if (MxY-MnY==0){MnY-=BorderFac; MxY+=BorderFac;}
309    else {MnY-=(MxY-MnY)*BorderFac; MxY+=(MxY-MnY)*BorderFac;}
310  }
311  void TGraph::RescaleXY(const double& BorderFac, const PVrtx& CenterVrtx) const {
312    double MnX; double MnY; double MxX; double MxY;
313    _GetMnMxXY(MnX, MnY, MxX, MxY);
314    if (!CenterVrtx.Empty()){
315      double CenterX=CenterVrtx->GetX();
316      double CenterY=CenterVrtx->GetY();
317      if (MxX-CenterX>CenterX-MnX){MnX=CenterX-(MxX-CenterX);}
318      else {MxX=CenterX+(CenterX-MnX);}
319      if (MxY-CenterY>CenterY-MnY){MnY=CenterY-(MxY-CenterY);}
320      else {MxY=CenterY+(CenterY-MnY);}
321    }
322    _AddBorders(BorderFac, MnX, MnY, MxX, MxY);
323    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
324    while (FNextVrtx(VrtxP, Vrtx)){
325      Vrtx->PutX((Vrtx->GetX()-MnX)/(MxX-MnX));
326      Vrtx->PutY((Vrtx->GetY()-MnY)/(MxY-MnY));
327    }
328  }
329  void TGraph::RescaleXY(const double& MnX, const double& MnY,
330   const double& MxX, const double& MxY) const {
331    if ((fabs(MxX-MnX)<0.01)||(fabs(MxY-MnY)<0.01)){return;}
332    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
333    while (FNextVrtx(VrtxP, Vrtx)){
334      Vrtx->PutX((Vrtx->GetX()-MnX)/(MxX-MnX));
335      Vrtx->PutY((Vrtx->GetY()-MnY)/(MxY-MnY));
336    }
337  }
338  int TGraph::_IsEdgeXYInts(
339   const PVrtx& Vrtx0, const PVrtx& Vrtx1, const PVrtx& Vrtx2) const {
340    double dx1=Vrtx1->GetX()-Vrtx0->GetX();
341    double dy1=Vrtx1->GetY()-Vrtx0->GetY();
342    double dx2=Vrtx2->GetX()-Vrtx0->GetX();
343    double dy2=Vrtx2->GetY()-Vrtx0->GetY();
344    if (dx1*dy2>dy1*dx2){return +1;}
345    if (dx1*dy2<dy1*dx2){return -1;}
346    if ((dx1*dx2<0)||(dy1*dy2<0)){return -1;}
347    if ((dx1*dx1+dy1*dy1)<(dx2*dx2+dy2*dy2)){return +1;}
348    return 0;
349  }
350  bool TGraph::IsEdgeXYInts(const PEdge& Edge1, const PEdge& Edge2) const {
351    PVrtx V11=GetVrtx(Edge1->GetVId1());
352    PVrtx V12=GetVrtx(Edge1->GetVId2());
353    PVrtx V21=GetVrtx(Edge2->GetVId1());
354    PVrtx V22=GetVrtx(Edge2->GetVId2());
355    return
356     ((_IsEdgeXYInts(V11, V12, V21)*_IsEdgeXYInts(V11, V12, V22))<=0)&&
357     ((_IsEdgeXYInts(V21, V22, V11)*_IsEdgeXYInts(V21, V22, V12))<=0);
358  }
359  double TGraph::GetVrtxXYLen(const PVrtx& Vrtx1, const PVrtx& Vrtx2) const {
360    double Len=
361     TMath::Sqr(Vrtx2->GetX()-Vrtx1->GetX())+
362     TMath::Sqr(Vrtx2->GetY()-Vrtx1->GetY());
363    Len=sqrt(Len);
364    return Len;
365  }
366  double TGraph::GetEdgeXYLen(const PEdge& Edge) const {
367    PVrtx Vrtx1=GetVrtx(Edge->GetVId1());
368    PVrtx Vrtx2=GetVrtx(Edge->GetVId2());
369    return GetVrtxXYLen(Vrtx1, Vrtx2);
370  }
371  double TGraph::GetSumEdgeXYLen() const {
372    double SumLen=0;
373    int EdgeP=FFirstEdge(); PEdge Edge;
374    while (FNextEdge(EdgeP, Edge)){
375      SumLen+=GetEdgeXYLen(Edge);
376    }
377    return SumLen;
378  }
379  void TGraph::PlaceRndXY(TRnd& Rnd) const {
380    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
381    while (FNextVrtx(VrtxP, Vrtx)){
382      Vrtx->PutX(Rnd.GetUniDev());
383      Vrtx->PutY(Rnd.GetUniDev());
384    }
385  }
386  void TGraph::PlaceBestRndXY(const int& Tries, TRnd& Rnd) const {
387    int BestSeed; double BestLen=-1;
388    for (int TryN=0; TryN<Tries; TryN++){
389      int CurSeed=Rnd.GetSeed();
390      PlaceRndXY(Rnd);
391      double CurLen=GetSumEdgeXYLen();
392      if (TryN==0){
393        BestSeed=CurSeed; BestLen=CurLen;
394      } else
395      if (CurLen<BestLen){
396        BestSeed=CurSeed; BestLen=CurLen;
397      }
398    }
399    Rnd.PutSeed(BestSeed);
400    PlaceRndXY(Rnd);
401  }
402  double TGraph::GetSimAnnXYEnergy(
403   const double& NodeDistrWgt, const double& BorderWgt,
404   const double& EdgeLenWgt, const double& EdgeCrossWgt,
405   const double& NodeEdgeDistWgt, const bool& UseNodeEdgeDist) const {
406    double Energy=0;
407    if (NodeDistrWgt!=0){
408      int Vrtx1P=FFirstVrtx(); PVrtx Vrtx1;
409      while (FNextVrtx(Vrtx1P, Vrtx1)){
410        int Vrtx2P=FFirstVrtx(); PVrtx Vrtx2;
411        while (FNextVrtx(Vrtx2P, Vrtx2)){
412          double EuclDist=
413           sqrt(TMath::Sqr(Vrtx1->GetX()-Vrtx2->GetX())+
414           TMath::Sqr(Vrtx1->GetY()-Vrtx2->GetY()));
415          if (EuclDist>0){
416            Energy+=NodeDistrWgt/TMath::Sqr(EuclDist);}
417        }
418      }
419    }
420    if (BorderWgt!=0){
421      double Vrtxs=GetVrtxs();
422      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
423      while (FNextVrtx(VrtxP, Vrtx)){
424        double Right=1-Vrtx->GetX();
425        double Left=Vrtx->GetX();
426        double Top=Vrtx->GetY();
427        double Bottom=1-Vrtx->GetY();
428        if (Right>0){Energy+=BorderWgt*TMath::Sqr(Right)*TMath::Sqr(Vrtxs);}
429        if (Left>0){Energy+=BorderWgt*TMath::Sqr(Left)*TMath::Sqr(Vrtxs);}
430        if (Top>0){Energy+=BorderWgt*TMath::Sqr(Top)*TMath::Sqr(Vrtxs);}
431        if (Bottom>0){Energy+=BorderWgt*TMath::Sqr(Bottom)*TMath::Sqr(Vrtxs);}
432      }
433    }
434    if (EdgeLenWgt!=0){
435      double Vrtxs=GetVrtxs();
436      int EdgeP=FFirstEdge(); PEdge Edge;
437      while (FNextEdge(EdgeP, Edge)){
438        Energy+=EdgeLenWgt*TMath::Sqr(GetEdgeXYLen(Edge))*TMath::Sqr(Vrtxs);
439      }
440    }
441    if (EdgeCrossWgt!=0){
442      int Edge1P=FFirstEdge(); PEdge Edge1;
443      while (FNextEdge(Edge1P, Edge1)){
444        int Edge2P=Edge1P; PEdge Edge2;
445        while (FNextEdge(Edge2P, Edge2)){
446          if (&Edge1!=&Edge2){
447            if
448             ((Edge1->GetVId1()!=Edge2->GetVId1())&&
449             (Edge1->GetVId1()!=Edge2->GetVId2())&&
450             (Edge1->GetVId2()!=Edge2->GetVId1())&&
451             (Edge1->GetVId2()!=Edge2->GetVId2())){
452              if (IsEdgeXYInts(Edge1, Edge2)){
453                Energy+=EdgeCrossWgt;
454              }
455            }
456          }
457        }
458      }
459    }
460    if ((UseNodeEdgeDist)&&(NodeEdgeDistWgt!=0)){
461      int EdgeP=FFirstEdge(); PEdge Edge;
462      while (FNextEdge(EdgeP, Edge)){
463        double EdgeLen=GetEdgeXYLen(Edge);
464        PVrtx Vrtx1=GetVrtx(Edge->GetVId1());
465        PVrtx Vrtx2=GetVrtx(Edge->GetVId2());
466        int VrtxP=FFirstVrtx(); PVrtx Vrtx;
467        while (FNextVrtx(VrtxP, Vrtx)){
468          if ((&Vrtx!=&Vrtx1)&&(&Vrtx!=&Vrtx2)){
469            double VrtxLen=GetVrtxXYLen(Vrtx, Vrtx1)+GetVrtxXYLen(Vrtx, Vrtx2);
470            if (EdgeLen!=VrtxLen){
471              Energy+=(NodeEdgeDistWgt/fabs(EdgeLen-VrtxLen));
472            }
473          }
474        }
475      }
476    }
477    return Energy;
478  }
479  double TGraph::GetSimAnnXYEnergy(
480   const PXmlDoc& CfgXmlDoc, const bool& UseNodeEdgeDist) const {
481    double NodeDistrWgt=10; 
482    double BorderWgt=20; 
483    double EdgeLenWgt=10; 
484    double EdgeCrossWgt=1000; 
485    double NodeEdgeDistWgt=10; 
486    if (!CfgXmlDoc.Empty()){
487      NodeDistrWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|NodeDistrWgt", "Val", NodeDistrWgt);
488      BorderWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|BorderWgt", "Val", BorderWgt);
489      EdgeLenWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|EdgeLenWgt", "Val", EdgeLenWgt);
490      EdgeCrossWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|EdgeCrossWgt", "Val", EdgeCrossWgt);
491      NodeEdgeDistWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|NodeEdgeDistWgt", "Val", NodeEdgeDistWgt);
492    }
493    return GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt, EdgeCrossWgt,
494     NodeEdgeDistWgt, UseNodeEdgeDist);
495  }
496  void TGraph::PlaceSimAnnXY(
497   TRnd& Rnd, const PGks& Gks, const PXmlDoc& CfgXmlDoc, const PNotify& Notify,
498   const int& _TempStages, const int& _TempStageTrys, const int& Secs) const {
499    int Trys=1; 
500    double StartTemp=1000; 
501    double TempFact=0.95; 
502    int TempStages=_TempStages; 
503    int TempStageTrys=_TempStageTrys; 
504    int FineTuningTrys=3000; 
505    if (!CfgXmlDoc.Empty()){
506      Trys=CfgXmlDoc->GetTagTokIntArgVal("Config|Trys", "Val", Trys);
507      StartTemp=CfgXmlDoc->GetTagTokFltArgVal("Config|StartTemp", "Val", StartTemp);
508      TempFact=CfgXmlDoc->GetTagTokFltArgVal("Config|TempFact", "Val", TempFact);
509      TempStages=CfgXmlDoc->GetTagTokIntArgVal("Config|TempStages", "Val", TempStages);
510      TempStageTrys=CfgXmlDoc->GetTagTokIntArgVal("Config|TempStageTrys", "Val", TempStageTrys);
511      FineTuningTrys=CfgXmlDoc->GetTagTokIntArgVal("Config|FineTuningTrys", "Val", FineTuningTrys);
512    }
513    double NodeDistrWgt=10; 
514    double BorderWgt=25; 
515    double EdgeLenWgt=10; 
516    double EdgeCrossWgt=1000; 
517    double NodeEdgeDistWgt=10; 
518    if (!CfgXmlDoc.Empty()){
519      NodeDistrWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|NodeDistrWgt", "Val", NodeDistrWgt);
520      BorderWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|BorderWgt", "Val", BorderWgt);
521      EdgeLenWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|EdgeLenWgt", "Val", EdgeLenWgt);
522      EdgeCrossWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|EdgeCrossWgt", "Val", EdgeCrossWgt);
523      NodeEdgeDistWgt=CfgXmlDoc->GetTagTokFltArgVal("Config|NodeEdgeDistWgt", "Val", NodeEdgeDistWgt);
524    }
525    TSecTm StartTm=TSecTm::GetCurTm();
526    double MnEnergy=TFlt::Mx; 
527    typedef TPair<PVrtx, TFltPr> TVrtxXYPrPr;
528    TVec<TVrtxXYPrPr> VrtxXYPrPrV;
529    for (int TryN=0; TryN<Trys; TryN++){
530      PlaceRndXY(Rnd); 
531      double Energy=TFlt::Mx; 
532      double Temp=StartTemp; 
533      double PrevEnergy=TFlt::Mx; 
534      for (int TempStageN=0; TempStageN<TempStages; TempStageN++){
535        TNotify::OnStatus(Notify,
536         TInt::GetStr(1+TempStageN)+"/"+TInt::GetStr(TempStages)+"\r");
537        for (int TempStageTryN=0; TempStageTryN<TempStageTrys; TempStageTryN++){
538          PVrtx Vrtx=GetRndVrtx(Rnd); 
539          double PrevX=Vrtx->GetX();
540          double PrevY=Vrtx->GetY();
541          double NewX=Rnd.GetNrmDev(Vrtx->GetX(), Temp/StartTemp, 0, 1);
542          double NewY=Rnd.GetNrmDev(Vrtx->GetY(), Temp/StartTemp, 0, 1);
543          NewX=TFlt::GetInRng(NewX, 0, 1);
544          NewY=TFlt::GetInRng(NewY, 0, 1);
545          Vrtx->PutX(NewX);
546          Vrtx->PutY(NewY);
547          Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
548           EdgeCrossWgt, NodeEdgeDistWgt, false);
549          if (Energy<PrevEnergy){
550            PrevEnergy=Energy;  
551          } else {
552            double MetrPrb=exp((PrevEnergy-Energy)/Temp);
553            double MetrRnd=Rnd.GetUniDev();
554            if (MetrRnd>=MetrPrb){
555              Vrtx->PutX(PrevX); Vrtx->PutY(PrevY); 
556            } else {
557              PrevEnergy=Energy; 
558            }
559          }
560        }
561        Temp*=TempFact; 
562        if (!Gks.Empty()){
563          Gks->Clr();
564          Draw(Gks, true);
565        }
566      }
567      if (Energy<MnEnergy){
568        MnEnergy=Energy;
569        VrtxXYPrPrV.Gen(GetVrtxs(), 0);
570        int VrtxP=FFirstVrtx(); PVrtx Vrtx;
571        while (FNextVrtx(VrtxP, Vrtx)){
572          TFltPr XYPr(Vrtx->GetX(), Vrtx->GetY()); 
573          TVrtxXYPrPr VrtxXYPrPr(Vrtx, XYPr); 
574          VrtxXYPrPrV.Add(VrtxXYPrPr);
575        }
576      }
577      TSecTm CurTm=TSecTm::GetCurTm();
578      if (Secs!=-1){
579        if (TSecTm::GetDSecs(StartTm, CurTm)>uint(Secs)){break;}
580      }
581    }
582    for (int VrtxXYPrPrN=0; VrtxXYPrPrN<VrtxXYPrPrV.Len(); VrtxXYPrPrN++){
583      PVrtx Vrtx=VrtxXYPrPrV[VrtxXYPrPrN].Val1;
584      TFltPr XYPr=VrtxXYPrPrV[VrtxXYPrPrN].Val2;
585      double X=XYPr.Val1; double Y=XYPr.Val2;
586      Vrtx->PutX(X); Vrtx->PutY(Y);
587    }
588    double PrevEnergy=TFlt::Mx; 
589    for (int FineTuningTryN=0; FineTuningTryN<FineTuningTrys; FineTuningTryN++){
590      PVrtx Vrtx=GetRndVrtx(Rnd); 
591      double PrevX=Vrtx->GetX();
592      double PrevY=Vrtx->GetY();
593      double NewX=Rnd.GetNrmDev(Vrtx->GetX(), 0.001, 0, 1);
594      double NewY=Rnd.GetNrmDev(Vrtx->GetY(), 0.001, 0, 1);
595      Vrtx->PutX(NewX);
596      Vrtx->PutY(NewY);
597      double Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
598       EdgeCrossWgt, NodeEdgeDistWgt, true);
599      if (Energy<PrevEnergy){
600        PrevEnergy=Energy;  
601      } else {
602        Vrtx->PutX(PrevX); Vrtx->PutY(PrevY); 
603      }
604      if (FineTuningTryN%100==0){Draw(Gks, true);}
605      TSecTm CurTm=TSecTm::GetCurTm();
606      if (Secs!=-1){
607        if (TSecTm::GetDSecs(StartTm, CurTm)>uint(Secs)){break;}
608      }
609    }
610  }
611  void TGraph::PlaceFineTuning(
612   TRnd& Rnd, const PGks& Gks, const PNotify& Notify, const int& Secs) const {
613    int FineTuningTrys=3000; 
614    double NodeDistrWgt=10; 
615    double BorderWgt=25; 
616    double EdgeLenWgt=10; 
617    double EdgeCrossWgt=1000; 
618    double NodeEdgeDistWgt=10; 
619    TSecTm StartTm=TSecTm::GetCurTm();
620    double PrevEnergy=TFlt::Mx; 
621    for (int FineTuningTryN=0; FineTuningTryN<FineTuningTrys; FineTuningTryN++){
622      PVrtx Vrtx=GetRndVrtx(Rnd); 
623      double PrevX=Vrtx->GetX();
624      double PrevY=Vrtx->GetY();
625      double NewX=Rnd.GetNrmDev(Vrtx->GetX(), 0.001, 0, 1);
626      double NewY=Rnd.GetNrmDev(Vrtx->GetY(), 0.001, 0, 1);
627      Vrtx->PutX(NewX);
628      Vrtx->PutY(NewY);
629      double Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
630       EdgeCrossWgt, NodeEdgeDistWgt, true);
631      if (Energy<PrevEnergy){
632        PrevEnergy=Energy;  
633      } else {
634        Vrtx->PutX(PrevX); Vrtx->PutY(PrevY); 
635      }
636      if (FineTuningTryN%100==0){Draw(Gks, true);}
637      TSecTm CurTm=TSecTm::GetCurTm();
638      if (Secs!=-1){
639        if (TSecTm::GetDSecs(StartTm, CurTm)>uint(Secs)){break;}
640      }
641    }
642  }
643  void TGraph::PlaceCircle() const {
644    double Vrtxs=GetVrtxs();
645    double AngStep=0; if (Vrtxs>0){AngStep=2*TMath::Pi/Vrtxs;}
646    double Ang=0;
647    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
648    while (FNextVrtx(VrtxP, Vrtx)){
649      TGksPPoint PPoint(1, Ang);
650      TGksVPoint VPoint=PPoint.GetVPoint();
651      Vrtx->PutXY(VPoint.X, VPoint.Y);
652      Ang+=AngStep;
653    }
654  }
655  void TGraph::PlaceTreeAsStar(
656   const PVrtx& HomeVrtx, const int& Lev,
657   const double& HomeX, const double& HomeY,
658   const double& MnAng, const double& MxAng) const {
659    HomeVrtx->PutXY(HomeX, HomeY);
660    if (HomeVrtx->GetOutEIds()>0){
661      double HalfAngStep=((MxAng-MnAng)/HomeVrtx->GetOutEIds())/2;
662      double Ang=MnAng;
663      for (int EIdN=0; EIdN<HomeVrtx->GetOutEIds(); EIdN++){
664        PEdge Edge=GetEdge(HomeVrtx->GetOutEId(EIdN));
665        PVrtx NextVrtx=GetVrtx(Edge->GetOtherVId(HomeVrtx));
666        Ang+=HalfAngStep;
667        TGksPPoint PPoint(Lev+1, Ang);
668        TGksVPoint VPoint=PPoint.GetVPoint();
669        PlaceTreeAsStar(NextVrtx, Lev+1,
670         VPoint.X, VPoint.Y, Ang-HalfAngStep, Ang+HalfAngStep);
671        Ang+=HalfAngStep;
672      }
673    }
674  }
675  void TGraph::PlaceTreeAsStar() const {
676    PVrtx RootVrtx;
677    IAssert(IsTree(RootVrtx));
678    PlaceTreeAsStar(RootVrtx, 0, 0, 0, 0, 2*TMath::Pi);
679  }
680  void TGraph::PlaceGraphAsStar(const PVrtx& HomeVrtx, const TStr& DrawENm) const {
681      ClrVrtxMarks();
682      TVec<TPair<PVrtx,TFltPr> > LevVrtxV;
683      LevVrtxV.Add(TPair<PVrtx,TFltPr>(HomeVrtx, TFltPr(0.0, 2*TMath::Pi)));
684      HomeVrtx->SetMark();
685      int Level = 0;
686      while (!LevVrtxV.Empty()) {
687          for (int VrtxN = 0; VrtxN < LevVrtxV.Len(); VrtxN++) {
688              const double MnAng = LevVrtxV[VrtxN].Val2.Val1;
689              const double MxAng = LevVrtxV[VrtxN].Val2.Val2;
690              const double Ang = MnAng + ((MxAng - MnAng)/2);
691              PVrtx Vrtx = LevVrtxV[VrtxN].Val1;
692              TGksPPoint PPoint(Level, Ang);
693              TGksVPoint VPoint=PPoint.GetVPoint();
694              Vrtx->PutXY(VPoint.X, VPoint.Y);
695          }
696          TVec<TPair<PVrtx,TFltPr> > NextLevVrtxV;
697          for (int VrtxN = 0; VrtxN < LevVrtxV.Len(); VrtxN++) {
698              const double MnAng = LevVrtxV[VrtxN].Val2.Val1;
699              const double MxAng = LevVrtxV[VrtxN].Val2.Val2;
700              PVrtx Vrtx = LevVrtxV[VrtxN].Val1;
701              TVec<PVrtx> NextVrtxV;
702              const int EIds = Vrtx->GetInEIds();
703              for (int EIdN = 0; EIdN < EIds; EIdN++) {
704                  PEdge Edge = GetEdge(Vrtx->GetInEId(EIdN));
705                  PVrtx NextVrtx = GetVrtx(Edge->GetOtherVId(Vrtx));
706                  if ((!NextVrtx->IsMark()) && 
707                      (DrawENm.Empty() || (Edge->GetENm() == DrawENm))) {
708                          NextVrtxV.Add(NextVrtx);
709                  }
710              }
711              if (!NextVrtxV.Empty()) {
712                  double AngStep=(MxAng - MnAng)/NextVrtxV.Len();
713                  double Ang=MnAng;
714                  for (int VIdN=0; VIdN < NextVrtxV.Len(); VIdN++){
715                      PVrtx NextVrtx=NextVrtxV[VIdN];
716                      const double NextMnAng = Ang;
717                      const double NextMxAng = Ang + AngStep;
718                      NextLevVrtxV.Add(TPair<PVrtx,TFltPr>(NextVrtx, TFltPr(NextMnAng, NextMxAng)));
719                      NextVrtx->SetMark();
720                      Ang += AngStep;
721                  }
722              }
723          }
724          Level++; LevVrtxV = NextLevVrtxV;
725      }
726  }
727  void TGraph::SetEdgeWidth(const int& Intvs) const {
728    IAssert(Intvs>0);
729    double MnWgt=TFlt::Mx; double MxWgt=TFlt::Mn;
730    {int EdgeP=FFirstEdge(); PEdge Edge;
731    while (FNextEdge(EdgeP, Edge)){
732      double Wgt=Edge->GetWgt();
733      MnWgt=TFlt::GetMn(MnWgt, Wgt);
734      MxWgt=TFlt::GetMx(MxWgt, Wgt);
735    }}
736    {int EdgeP=FFirstEdge(); PEdge Edge;
737    while (FNextEdge(EdgeP, Edge)){
738      double Wgt=Edge->GetWgt();
739      int Width=1;
740      if (MxWgt>MnWgt){
741        Width=int(1+Intvs*((Wgt-MnWgt)/(MxWgt-MnWgt)));}
742      if (Width>Intvs){Width=Intvs;} 
743      Edge->PutWidth(Width);
744    }}
745  }
746  void TGraph::Draw(const PGks& Gks, const bool& SimpleP,
747   const bool& DrawEdgesP, const int& FontSize,
748   const int& EdgeFontSize, const int& MxLnLen) const {
749    if (Gks.Empty()){return;}
750    TGksColor EdgeLineColor=TGksColor(0, 128, 0);
751    TGksColor EdgeBoxColor=TGksColor(0, 128, 0);
752    TGksColor NodeBoxColor=TGksColor(0, 0, 255);
753    TGksColor SelNodeBoxColor=TGksColor(255, 0, 0);
754    Gks->Clr();
755    Gks->SetPen(TGksPen::New(EdgeLineColor, gpmCopy, gpsSolid, 1));
756    Gks->SetBrush(TGksBrush::New(TGksColor::GetWhite(), gbsSolid));
757    Gks->SetFont(TGksFont::New("Tahoma", EdgeFontSize, TGksColor::GetBlack()));
758    if (DrawEdgesP){
759      {int PrevWidth=1;
760      int EdgeP=FFirstEdge(); PEdge Edge;
761      while (FNextEdge(EdgeP, Edge)){
762        PVrtx Vrtx1=GetVrtx(Edge->GetVId1());
763        PVrtx Vrtx2=GetVrtx(Edge->GetVId2());
764        bool DirP=Edge->IsDir();
765        int X1=Gks->GetVToPX(Vrtx1->GetX());
766        int Y1=Gks->GetVToPY(Vrtx1->GetY());
767        int X2=Gks->GetVToPX(Vrtx2->GetX());
768        int Y2=Gks->GetVToPY(Vrtx2->GetY());
769        int Width=TInt::GetMx(1, Edge->GetWidth());
770        if (Width!=PrevWidth){
771          PrevWidth=Width;
772          Gks->SetPen(TGksPen::New(TGksColor::GetGreen(), gpmCopy, gpsSolid, Width+1));
773        }
774        if (IsVrtxsEdge(Vrtx2->GetVId(), Vrtx1->GetVId(), true)){
775          if (DirP){Gks->DirLine(X1, Y1, X2, Y2, true, false, 10, 0.15);}
776          else {Gks->DirLine(X1, Y1, X2, Y2, false, false, 10, 0.15);}
777        } else {
778          if (DirP){Gks->DirLine(X1, Y1, X2, Y2, true, false, 10, 0.25);}
779          else {Gks->DirLine(X1, Y1, X2, Y2, false, false, 10, 0.25);}
780        }
781      }}
782      if (EdgeFontSize>0){
783        Gks->SetPen(TGksPen::New(EdgeBoxColor, gpmCopy, gpsSolid, 2));
784        int EdgeP=FFirstEdge(); PEdge Edge;
785        while (FNextEdge(EdgeP, Edge)){
786          PVrtx Vrtx1=GetVrtx(Edge->GetVId1());
787          PVrtx Vrtx2=GetVrtx(Edge->GetVId2());
788          int X1=Gks->GetVToPX(Vrtx1->GetX());
789          int Y1=Gks->GetVToPY(Vrtx1->GetY());
790          int X2=Gks->GetVToPX(Vrtx2->GetX());
791          int Y2=Gks->GetVToPY(Vrtx2->GetY());
792          TStr Nm=(SimpleP) ? Edge->GetENm() : Edge->GetDNm();
793          if ((!Nm.Empty())&&(Nm[0]!='_')){
794            if (IsVrtxsEdge(Vrtx2->GetVId(), Vrtx1->GetVId(), true)){
795              TGksRect Rect=Gks->TxtBox(gtbtRoundRect, Nm, int(X1+(X2-X1)*0.60), int(Y1+(Y2-Y1)*0.60));
796            } else {
797              TGksRect Rect=Gks->TxtBox(gtbtRoundRect, Nm, int(X1+(X2-X1)*0.5), int(Y1+(Y2-Y1)*0.5));
798            }
799          }
800        }
801      }
802    }
803    TStr BoldVNm;
804    if (GetPp()->IsPp("BoldVNm")){
805      BoldVNm=GetPp()->GetValStr("BoldVNm");}
806    Gks->SetFont(TGksFont::New("Tahoma", FontSize, TGksColor::GetBlack(), TFSet(gfsBold)));
807    Gks->SetPen(TGksPen::New(TGksColor::GetBlue(), gpmCopy, gpsSolid, 1));
808    if (SimpleP){
809      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
810      while (FNextVrtx(VrtxP, Vrtx)){
811        TStr VNm=Vrtx->GetVNm();
812        if ((!VNm.Empty())&&(VNm[0]!='_')){
813          int X=Gks->GetVToPX(Vrtx->GetX());
814          int Y=Gks->GetVToPY(Vrtx->GetY());
815          TGksTxtBoxType TxtBoxType=gtbtRoundRect;
816          TGksColor Color=TGksColor::GetBlue();
817          if (Vrtx->GetColor()!=0){
818            Color.PutArgbVal(Vrtx->GetColor());}
819          if (VNm==BoldVNm){
820            Gks->SetPen(TGksPen::New(Color, gpmCopy, gpsSolid, 5));
821          } else {
822            Gks->SetPen(TGksPen::New(Color, gpmCopy, gpsSolid, 2));
823          }
824          if (MxLnLen!=-1){
825            TChA ChA=VNm; int LnChN=0;
826            for (int ChN=0; ChN<ChA.Len(); ChN++){
827              if ((LnChN>MxLnLen)&&(ChA[ChN]==' ')){ChA[ChN]='\\'; LnChN=0;}
828              LnChN++;
829            }
830            VNm=ChA;
831          }
832          TGksRect Rect=Gks->TxtBox(TxtBoxType, VNm, X, Y);
833          Vrtx->PutRect(Rect);
834        }
835      }
836    } else {
837      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
838      while (FNextVrtx(VrtxP, Vrtx)){
839        TStr DNm=Vrtx->GetDNm();
840        int Brief=Vrtx->GetBrief();
841        int X=Gks->GetVToPX(Vrtx->GetX());
842        int Y=Gks->GetVToPY(Vrtx->GetY());
843        TGksTxtBoxType TxtBoxType=gtbtRect;
844        if (DNm==BoldVNm){
845          Gks->SetPen(TGksPen::New(SelNodeBoxColor, gpmCopy, gpsSolid, 2));
846        } else {
847          Gks->SetPen(TGksPen::New(NodeBoxColor, gpmCopy, gpsSolid, 2));
848        }
<span onclick='openModal()' class='match'>849        if (Brief==0){
850          TGksRect Rect=Gks->TxtBox(TxtBoxType, DNm, X, Y);
851          Vrtx->PutRect(Rect);
852        } else {
853          if (DNm.IsChIn('#')){
854            TStr TxtStr1; TStr TxtStr2;
855            DNm.SplitOnCh(TxtStr1, '#', TxtStr2);
856            TGksRect Rect=Gks->TxtBox(TxtBoxType, TxtStr1, X, Y);
857            Vrtx->PutRect(Rect);
858          } else {
859            TGksRect Rect=Gks->TxtBox(TxtBoxType, DNm, X, Y);
</span>860            Vrtx->PutRect(Rect);
861          }
862        }
863      }
864    }
865  }
866  void TGraph::_DrawTxtTree(const PVrtx& Vrtx, TChAV& LnV) const {
867    TStr VNm=
868     TStr::GetStr(Vrtx->GetVNm(), "[%5s]-")+
869     TFlt::GetStr(Vrtx->GetWgt(), "{%+4.2f}");
870    if (Vrtx->NoOutEIds()){
871      LnV.Add(VNm);
872      LnV.Add();
873    } else {
874      int VrtxLnN=LnV.Len(); TIntV OutLnNV; TStrV OutENmV;
875      for (int OutEIdN=0; OutEIdN<Vrtx->GetOutEIds(); OutEIdN++){
876        PEdge Edge=GetEdge(Vrtx->GetOutEId(OutEIdN));
877        PVrtx OutVrtx=GetVrtx(Edge->GetOutVId());
878        OutENmV.Add();
879        OutLnNV.Add(LnV.Len());
880        _DrawTxtTree(OutVrtx, LnV);
881      }
882      int VrtxLevChN=0;
883      {for (int OutLnNN=0; OutLnNN<OutLnNV.Len(); OutLnNN++){
884        int OutLnN=OutLnNV[OutLnNN];
885        VrtxLevChN=TInt::GetMx(VrtxLevChN, LnV[OutLnN].Len());
886      }}
887      LnV[VrtxLnN].AddChTo('-', VrtxLevChN);
888      LnV[VrtxLnN]+="-"; LnV[VrtxLnN]+=OutENmV[0];
889      LnV[VrtxLnN]+="-+-"; LnV[VrtxLnN]+=VNm;
890      {for (int OutLnNN=1; OutLnNN<OutLnNV.Len(); OutLnNN++){
891        int OutLnN=OutLnNV[OutLnNN];
892        LnV[OutLnN].AddChTo('-', VrtxLevChN);
893        LnV[OutLnN]+="-"; LnV[OutLnN]+=OutENmV[OutLnNN];
894        LnV[OutLnN]+="-+ ";
895        for (int GapLnN=OutLnNV[OutLnNN-1]+1; GapLnN<OutLnN; GapLnN++){
896          LnV[GapLnN].AddChTo(' ', VrtxLevChN+OutENmV[OutLnNN].Len()+1);
897          LnV[GapLnN]+=" | ";
898        }
899      }}
900    }
901  }
902  void TGraph::DrawTxtTree(const PSOut& SOut) const {
903    PVrtx RootVrtx; IAssert(IsTree(RootVrtx));
904    TChAV LnV;
905    _DrawTxtTree(RootVrtx, LnV);
906    for (int LnN=0; LnN<LnV.Len(); LnN++){
907      SOut->PutStr(LnV[LnN]); SOut->PutLn();
908    }
909  }
910  bool TGraph::IsVrtxAt(
911   const PGks& &bsol;*Gks*/, const int& X, const int& Y, PVrtx& Vrtx) const {
912    int VrtxP=FFirstVrtx();
913    while (FNextVrtx(VrtxP, Vrtx)){
914      if (Vrtx->IsInRect(X, Y)){return true;}}
915    return false;
916  }
917  bool TGraph::IsEdgeAt(
918   const PGks& &bsol;*Gks*/, const int& X, const int& Y, PEdge& Edge) const {
919    int EdgeP=FFirstEdge();
920    while (FNextEdge(EdgeP, Edge)){
921      if (Edge->IsInRect(X, Y)){return true;}}
922    return false;
923  }
924  bool TGraph::IsDir() const {
925    int EdgeP=FFirstEdge(); PEdge Edge;
926    while (FNextEdge(EdgeP, Edge)){
927      if (!Edge->IsDir()){return false;}}
928    return true;
929  }
930  bool TGraph::_IsDag(const PVrtx& Vrtx, const int& Mark) const {
931    if (Vrtx->GetMark()==Mark){printf("[Bad:%d]", Vrtx->GetVId()); return false;}
932    if (!Vrtx->IsMark()){
933      Vrtx->PutMark(Mark);
934      for (int EIdN=0; EIdN<Vrtx->GetOutEIds(); EIdN++){
935        PEdge Edge=GetEdge(Vrtx->GetOutEId(EIdN));
936        PVrtx Vrtx=GetVrtx(Edge->GetOutVId());
937        if (!_IsDag(Vrtx, Mark)){return false;}
938      }
939    }
940    return true;
941  }
942  bool TGraph::IsDag() const {
943    if (!IsDir()){return false;}
944    ClrVrtxMarks();
945    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int Mark=0;
946    while (FNextVrtx(VrtxP, Vrtx)){
947      if (!_IsDag(Vrtx, ++Mark)){return false;}
948    }
949    return true;
950  }
951  bool TGraph::IsTree(PVrtx& RootVrtx) const {
952    if (!IsDir()){return false;}
953    if (!IsDag()){return false;}
954    RootVrtx=NULL;
955    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
956    while (FNextVrtx(VrtxP, Vrtx)){
957      if (Vrtx->GetInEIds()==0){
958        if (RootVrtx.Empty()){RootVrtx=Vrtx;} else {return false;}
959      }
960    }
961    return !Vrtx.Empty();
962  }
963  void TGraph::GetLeafVIdV(const int& RootVId, TIntV& VIdV) const {
964    IAssert(IsDag());
965    VIdV.Clr();
966    TIntQ VIdQ; VIdQ.Push(RootVId);
967    do {
968      int VId=VIdQ.Top(); VIdQ.Pop();
969      PVrtx Vrtx=GetVrtx(VId);
970      if (Vrtx->NoOutEIds()){
971        VIdV.Add(VId);
972      } else {
973        for (int OutEIdN=0; OutEIdN<Vrtx->GetOutEIds(); OutEIdN++){
974          PEdge Edge=GetEdge(Vrtx->GetOutEId(OutEIdN));
975          PVrtx OutVrtx=GetVrtx(Edge->GetOutVId());
976          VIdQ.Push(OutVrtx->GetVId());
977        }
978      }
979    } while (!VIdQ.Empty());
980  }
981  void TGraph::GetHitsW() const {
982    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
983    while (FNextVrtx(VrtxP, Vrtx)){
984      Vrtx->PutHitsHubW(1); Vrtx->PutHitsAuthW(1);}}
985    double EpsChange=1/double(GetVrtxs());
986    double MxChange; double SumChange=0;
987    TFltV PrevHubWV(GetVrtxs()); TFltV PrevAuthWV(GetVrtxs());
988    int IterN=0; printf("\n");
989    do {
990      MxChange=0; SumChange=0;
991      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
992      while (FNextVrtx(VrtxP, Vrtx)){
993        double AuthW=0;
994        for (int EIdN=0; EIdN<Vrtx->GetInEIds(); EIdN++){
995          PEdge Edge=GetEdge(Vrtx->GetInEId(EIdN));
996          PVrtx SrcVrtx=GetVrtx(Edge->GetInVId());
997          AuthW+=SrcVrtx->GetHitsHubW();
998        }
999        Vrtx->PutHitsAuthW(AuthW);
1000      }}
1001      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1002      while (FNextVrtx(VrtxP, Vrtx)){
1003        double HubW=0;
1004        for (int EIdN=0; EIdN<Vrtx->GetOutEIds(); EIdN++){
1005          PEdge Edge=GetEdge(Vrtx->GetOutEId(EIdN));
1006          PVrtx DstVrtx=GetVrtx(Edge->GetOutVId());
1007          HubW+=DstVrtx->GetHitsAuthW();
1008        }
1009        Vrtx->PutHitsHubW(HubW);
1010      }}
1011      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1012      while (FNextVrtx(VrtxP, Vrtx)){
1013        Vrtx->PutHitsAuthW(log(1+Vrtx->GetHitsAuthW()));}}
1014      double SumSqrAuthW=0;
1015      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1016      while (FNextVrtx(VrtxP, Vrtx)){
1017        SumSqrAuthW+=TMath::Sqr(Vrtx->GetHitsAuthW());}}
1018      double SqrtSumSqrAuthW=sqrt(SumSqrAuthW);
1019      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1020      while (FNextVrtx(VrtxP, Vrtx)){
1021        double AuthW=Vrtx->GetHitsAuthW()/SqrtSumSqrAuthW;
1022        Vrtx->PutHitsAuthW(AuthW);}}
1023      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1024      while (FNextVrtx(VrtxP, Vrtx)){
1025        Vrtx->PutHitsHubW(log(1+Vrtx->GetHitsHubW()));}}
1026      double SumSqrHubW=0;
1027      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1028      while (FNextVrtx(VrtxP, Vrtx)){
1029        SumSqrHubW+=TMath::Sqr(Vrtx->GetHitsHubW());}}
1030      double SqrtSumSqrHubW=sqrt(SumSqrHubW);
1031      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1032      while (FNextVrtx(VrtxP, Vrtx)){
1033        double HubW=Vrtx->GetHitsHubW()/SqrtSumSqrHubW;
1034        Vrtx->PutHitsHubW(HubW);}}
1035      {int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1036      while (FNextVrtx(VrtxP, Vrtx)){
1037        double HubWChange=fabs(Vrtx->GetHitsHubW()-PrevHubWV[VrtxN]);
1038        double AuthWChange=fabs(Vrtx->GetHitsAuthW()-PrevAuthWV[VrtxN]);
1039        if (HubWChange>MxChange){MxChange=HubWChange;}
1040        if (AuthWChange>MxChange){MxChange=AuthWChange;}
1041        SumChange+=HubWChange; SumChange+=AuthWChange;
1042        PrevHubWV[VrtxN]=Vrtx->GetHitsHubW();
1043        PrevAuthWV[VrtxN]=Vrtx->GetHitsAuthW();
1044        VrtxN++;
1045      }}
1046      IterN++;
1047      printf("Iteration: %d   Max. Change: %g   Eps. Change: %g\n",
1048       IterN, MxChange, EpsChange);
1049    } while (IterN<20); 
1050  }
1051  void TGraph::GetTopHitsVrtxV(
1052   TVrtxV& TopHubVrtxV, TVrtxV& TopAuthVrtxV) const {
1053    typedef TKeyDat<TFlt, PVrtx> TWgtVrtxKd;
1054    TVec<TWgtVrtxKd> WgtVrtxKdV;
1055    TopHubVrtxV.Gen(GetVrtxs(), 0);
1056    TopAuthVrtxV.Gen(GetVrtxs(), 0);
1057    WgtVrtxKdV.Gen(GetVrtxs(), 0);
1058    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1059    while (FNextVrtx(VrtxP, Vrtx)){
1060      WgtVrtxKdV.Add(TWgtVrtxKd(Vrtx->GetHitsHubW(), Vrtx));}}
1061    WgtVrtxKdV.Sort(false);
1062    for (int VrtxN=0; VrtxN<WgtVrtxKdV.Len(); VrtxN++){
1063      TopHubVrtxV.Add(WgtVrtxKdV[VrtxN].Dat);}
1064    WgtVrtxKdV.Gen(GetVrtxs(), 0);
1065    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1066    while (FNextVrtx(VrtxP, Vrtx)){
1067      WgtVrtxKdV.Add(TWgtVrtxKd(Vrtx->GetHitsAuthW(), Vrtx));}}
1068    WgtVrtxKdV.Sort(false);
1069    {for (int VrtxN=0; VrtxN<WgtVrtxKdV.Len(); VrtxN++){
1070      TopAuthVrtxV.Add(WgtVrtxKdV[VrtxN].Dat);}}
1071  }
1072  void TGraph::GetConnVrtxV(PVrtx& RootVrtx, TVrtxV& ConnVrtxV) const {
1073    ConnVrtxV.Clr();
1074    ClrVrtxMarks();
1075    TQQueue<PVrtx> VrtxQ;
1076    VrtxQ.Push(RootVrtx);
1077    while (!VrtxQ.Empty()){
1078      PVrtx Vrtx=VrtxQ.Top(); VrtxQ.Pop();
1079      if (!Vrtx->IsMark()){
1080        ConnVrtxV.Add(Vrtx);
1081        Vrtx->PutMark(true);
1082        for (int EIdN=0; EIdN<Vrtx->GetOutEIds(); EIdN++){
1083          PEdge Edge=GetEdge(Vrtx->GetOutEId(EIdN));
1084          VrtxQ.Push(GetVrtx(Edge->GetVId1()));
1085          VrtxQ.Push(GetVrtx(Edge->GetVId2()));
1086        }
1087      }
1088    }
1089  }
1090  PGraph TGraph::GetRndGraph(
1091   TRnd& Rnd, const int& Vrtxs, const int& Edges,
1092   const bool& DirEdgeP, const int& EdgeToSameVrtxP){
1093    IAssert((Vrtxs>=0)&&(Edges>=0));
1094    PGraph Graph=New();
1095    for (int VrtxN=0; VrtxN<Vrtxs; VrtxN++){
1096      PVrtx Vrtx=PVrtx(new TGVrtx()); Graph->AddVrtx(Vrtx);}
1097    int EdgeN=0;
1098    while (Graph->GetEdges()<Edges){
1099      PVrtx Vrtx1=Graph->GetRndVrtx(Rnd);
1100      PVrtx Vrtx2=Graph->GetRndVrtx(Rnd);
1101      while ((!EdgeToSameVrtxP)&&(Vrtx1==Vrtx2)){
1102        IAssert(Vrtxs>1); Vrtx2=Graph->GetRndVrtx(Rnd);}
1103      PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, TStr::GetNullStr(), DirEdgeP));
1104      Graph->AddEdge(Edge); EdgeN++;
1105    }
1106    return Graph;
1107  }
1108  PGraph TGraph::LoadXml(const PXmlDoc& XmlDoc, const TStr& TypeNm){
1109    PXmlTok GraphTok=XmlDoc->GetTok();
1110    EAssertR(GraphTok->IsTag("Graph"), "Bad root XML tag (<Graph> expected).");
1111    int GraphSubToks=GraphTok->GetSubToks();
1112    TStr FinalTypeNm=TypeNm;
1113    if (FinalTypeNm.Empty()){
1114      FinalTypeNm=XmlDoc->GetTok()->GetArgVal("TypeNm", "");}
1115    PGraph Graph=New(FinalTypeNm);
1116    for (int GraphTokN=0; GraphTokN<GraphSubToks; GraphTokN++){
1117      PXmlTok Tok=GraphTok->GetSubTok(GraphTokN);
1118      if (Tok->IsTag(TGraph::VrtxNm)){
1119        PVrtx Vrtx=TVrtx::LoadXml(Tok);
1120        Graph->AddVrtx(Vrtx);
1121      }
1122    }
1123    {for (int GraphTokN=0; GraphTokN<GraphSubToks; GraphTokN++){
1124      PXmlTok Tok=GraphTok->GetSubTok(GraphTokN);
1125      if (Tok->IsTag(TGraph::EdgeNm)){
1126        PEdge Edge=TEdge::LoadXml(Tok);
1127        Graph->AddEdge(Edge);
1128      }
1129    }}
1130    return Graph;
1131  }
1132  PXmlDoc TGraph::GetXmlDoc() const {
1133    PXmlTok GraphTok=TXmlTok::New("Graph");
1134    GraphTok->AddArg("TypeNm", GetTypeNm());
1135    for (int PpN=0; PpN<GetPps(); PpN++){
1136      GraphTok->AddArg(PpNm, GetPp(PpN)->GetStr());
1137    }
1138    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1139    while (FNextVrtx(VrtxP, Vrtx)){
1140      PXmlTok VrtxTok=Vrtx->GetXmlTok();
1141      GraphTok->AddSubTok(VrtxTok);
1142    }
1143    int EdgeP=FFirstEdge(); PEdge Edge;
1144    while (FNextEdge(EdgeP, Edge)){
1145      PXmlTok EdgeTok=Edge->GetXmlTok();
1146      GraphTok->AddSubTok(EdgeTok);
1147    }
1148    PXmlDoc GraphDoc=TXmlDoc::New(GraphTok);
1149    return GraphDoc;
1150  }
1151  PGraph TGraph::LoadTxt(const PSIn& SIn, const TStr& TypeNm){
1152    TILx Lx(SIn, TFSet()|iloCmtAlw|iloSigNum);
1153    TStr FinalTypeNm=TypeNm;
1154    if (Lx.GetSym(syIdStr, syLBracket)==syIdStr){
1155      if (FinalTypeNm.Empty()){FinalTypeNm=Lx.Str;}
1156      Lx.GetSym(syColon); Lx.GetSym(syLBracket);
1157    }
1158    PGraph Graph=New(FinalTypeNm);
1159    while (Lx.GetSym(syIdStr, syRBracket)==syIdStr){
1160      TStr Tag=Lx.Str;
1161      Lx.GetSym(syColon);
1162      if (Tag==PpNm){
1163        PPp Pp=TPp::LoadTxt(Lx);
1164        Graph->AddPp(Pp);
1165      } else
1166      if (Tag==VrtxNm){
1167        PVrtx Vrtx=TVrtx::LoadTxt(Lx);
1168        Graph->AddVrtx(Vrtx);
1169      } else
1170      if (Tag==EdgeNm){
1171        PEdge Edge=TEdge::LoadTxt(Lx);
1172        Graph->AddEdge(Edge);
1173      } else {
1174        Fail;
1175      }
1176    }
1177    return Graph;
1178  }
1179  void TGraph::SaveTxt(const PSOut& SOut) const {
1180    TOLx Lx(SOut, TFSet()|oloCmtAlw|oloFrcEoln|oloSigNum);
1181    Lx.PutVar(GetTypeNm(), true, true);
1182    for (int PpN=0; PpN<GetPps(); PpN++){
1183      Lx.PutIdStr(PpNm); Lx.PutSym(syColon);
1184      GetPp(PpN)->SaveTxt(Lx); Lx.PutLn();
1185    }
1186    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1187    while (FNextVrtx(VrtxP, Vrtx)){
1188      Lx.PutIdStr(VrtxNm); Lx.PutSym(syColon);
1189      Vrtx->SaveTxt(Lx); Lx.PutLn();
1190    }
1191    int EdgeP=FFirstEdge(); PEdge Edge;
1192    while (FNextEdge(EdgeP, Edge)){
1193      Lx.PutIdStr(EdgeNm); Lx.PutSym(syColon);
1194      Edge->SaveTxt(Lx); Lx.PutLn();
1195    }
1196    Lx.PutVarEnd(true, true);
1197  }
1198  void TGraph::SaveTxtTab(const TStr& FNm) const {
1199    TFOut TabFOut(FNm); FILE* fTab=TabFOut.GetFileId();
1200    fprintf(fTab, "VH\tVId\tName\tX\tY\n");
1201    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1202    while (FNextVrtx(VrtxP, Vrtx)){
1203      fprintf(fTab, "V\t%d\t%s\t%g\t%g\n",
1204       Vrtx->GetVId(), Vrtx->GetVNm().CStr(), Vrtx->GetX(), Vrtx->GetY());
1205    }
1206    fprintf(fTab, "EH\tEId\tVId1\tVId2\tDir\tName\tWidth\n");
1207    int EdgeP=FFirstEdge(); PEdge Edge;
1208    while (FNextEdge(EdgeP, Edge)){
1209      fprintf(fTab, "E\t%d\t%d\t%d\t%s\t%s\t%d\n",
1210       Edge->GetEId(), Edge->GetVId1(), Edge->GetVId2(),
1211       TBool::GetStr(Edge->IsDir()).CStr(), Edge->GetENm().CStr(),
1212       Edge->GetWidth());
1213    }
1214  }
1215  void TGraph::SaveTxtPajek(const TStr& FNm) const {
1216    PSOut SOut=TFOut::New(FNm);
1217    SOut->PutStr("*vertices ");
1218    int Vrtxs=GetVrtxs();
1219    SOut->PutStr(TInt::GetStr(Vrtxs));
1220    SOut->PutDosLn();
1221    TIntIntH VIdToVrtxNH(Vrtxs);
1222    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1223    while (FNextVrtx(VrtxP, Vrtx)){
1224      VrtxN++;
1225      VIdToVrtxNH.AddDat(Vrtx->GetVId(), VrtxN);
1226      SOut->PutStr(TInt::GetStr(VrtxN));
1227      SOut->PutStr(TStr(" \"")+Vrtx->GetVNm()+"\"");
1228      SOut->PutDosLn();
1229    }
1230    SOut->PutStr("*arcs"); SOut->PutDosLn();
1231    int EdgeP=FFirstEdge(); PEdge Edge;
1232    while (FNextEdge(EdgeP, Edge)){
1233      int VId1=Edge->GetVId1(); int VrtxN1=VIdToVrtxNH.GetDat(VId1);
1234      int VId2=Edge->GetVId2(); int VrtxN2=VIdToVrtxNH.GetDat(VId2);
1235      SOut->PutStr(TInt::GetStr(VrtxN1)+" "+TInt::GetStr(VrtxN2));
1236      SOut->PutDosLn();
1237    }
1238  }
1239  void TGraph::SaveTxtMatlab(const TStr& FNm) const {
1240    PSOut VrtxSOut=TFOut::New(TStr::PutFExt(FNm, ".vrtx-names.dat"));
1241    int Vrtxs=GetVrtxs(); TIntIntH VIdToVrtxNH(Vrtxs);
1242    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1243    while (FNextVrtx(VrtxP, Vrtx)){
1244      VrtxN++;
1245      VIdToVrtxNH.AddDat(Vrtx->GetVId(), VrtxN);
1246      VrtxSOut->PutStrLn(Vrtx->GetVNm());
1247    }
1248    PSOut EdgeSOut=TFOut::New(FNm);
1249    int EdgeP=FFirstEdge(); PEdge Edge;
1250    while (FNextEdge(EdgeP, Edge)){
1251      int VId1=Edge->GetVId1(); int VrtxN1=VIdToVrtxNH.GetDat(VId1);
1252      int VId2=Edge->GetVId2(); int VrtxN2=VIdToVrtxNH.GetDat(VId2);
1253      const double Wgt = Edge->GetWgt();
1254      EdgeSOut->PutStrLn(TStr::Fmt("%d %d %g", 
1255          TInt::GetMn(VrtxN1, VrtxN2), TInt::GetMx(VrtxN1, VrtxN2), Wgt));
1256    }
1257  }
1258  void TGraph::SaveTxtHits(const TStr& FNm, const int& TopN) const {
1259    TVrtxV HubVrtxV; TVrtxV AuthVrtxV;
1260    GetTopHitsVrtxV(HubVrtxV, AuthVrtxV);
1261    PSOut SOut=TFOut::New(FNm);
1262    int HubVrtxs=(TopN==-1) ? HubVrtxV.Len() : TInt::GetMn(TopN, HubVrtxV.Len());
1263    SOut->PutStr("---Hubs---------------------------"); SOut->PutLn();
1264    for (int VrtxN=0; VrtxN<HubVrtxs; VrtxN++){
1265      PVrtx Vrtx=HubVrtxV[VrtxN];
1266      TStr RankStr=TInt::GetStr(1+VrtxN, "%d.");
1267      TStr WgtStr=TFlt::GetStr(Vrtx->GetHitsHubW(), "%0.4g");
1268      TStr InStr=TStr("in:")+TInt::GetStr(Vrtx->GetInEIds(), "%2d");
1269      TStr OutStr=TStr("out:")+TInt::GetStr(Vrtx->GetOutEIds(), "%2d");
1270      TStr Str=RankStr+" "+WgtStr+" -> "+InStr+" "+OutStr+" \""+Vrtx->GetVNm()+"\"";
1271      SOut->PutStr(Str); SOut->PutLn();
1272    }
1273    int AuthVrtxs=(TopN==-1) ? AuthVrtxV.Len() : TInt::GetMn(TopN, AuthVrtxV.Len());
1274    SOut->PutStr("---Authorities--------------------"); SOut->PutLn();
1275    {for (int VrtxN=0; VrtxN<AuthVrtxs; VrtxN++){
1276      PVrtx Vrtx=AuthVrtxV[VrtxN];
1277      TStr RankStr=TInt::GetStr(1+VrtxN, "%d. ");
1278      TStr WgtStr=TFlt::GetStr(Vrtx->GetHitsAuthW(), "%0.4g");
1279      TStr InStr=TStr("in:")+TInt::GetStr(Vrtx->GetInEIds(), "%2d");
1280      TStr OutStr=TStr("out:")+TInt::GetStr(Vrtx->GetOutEIds(), "%2d");
1281      TStr Str=RankStr+" "+WgtStr+" -> "+InStr+" "+OutStr+" \""+Vrtx->GetVNm()+"\"";
1282      SOut->PutStr(Str); SOut->PutLn();
1283    }}
1284  }
1285  void TGraph::_SaveTxtSparseNbrs(const int& SrcVId,
1286   const int& Lev, const int& MxLev, TIntFltH& VIdToWgtH) const {
1287    if (Lev<=MxLev){
1288      PVrtx SrcVrtx=GetVrtx(SrcVId);
1289      for (int EIdN=0; EIdN<SrcVrtx->GetOutEIds(); EIdN++){
1290        PEdge Edge=GetEdge(SrcVrtx->GetOutEId(EIdN));
1291        int DstVId=Edge->GetOtherVId(SrcVrtx);
1292        VIdToWgtH.AddDat(DstVId)+=1.0/(Lev+1);
1293        _SaveTxtSparseNbrs(DstVId, Lev+1, MxLev, VIdToWgtH);
1294      }
1295    }
1296  }
1297  void TGraph::SaveTxtSparseNbrs(
1298   const TStr& VarIdFNm, const TStr& TupIdFNm, const TStr& TupVarValFNm,
1299   const int& MxLev) const {
1300    {PSOut VarIdSOut=TFOut::New(VarIdFNm);
1301    PSOut TupIdSOut=TFOut::New(TupIdFNm);
1302    PSOut TupVarValSOut=TFOut::New(TupVarValFNm);
1303    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1304    while (FNextVrtx(VrtxP, Vrtx)){
1305      TStr NrVNm=Vrtx->GetVNm(); NrVNm.ChangeChAll('"', '\'');
1306      TChA ChA;
1307      ChA+=TInt::GetStr(Vrtx->GetVId()); ChA+=':';
1308      ChA+='"'; ChA+=NrVNm; ChA+='"'; ChA+='\n';
1309      TupIdSOut->PutStr(ChA);
1310      VarIdSOut->PutStr(ChA);
1311    }}
1312    {PSOut TupVarValSOut=TFOut::New(TupVarValFNm);
1313    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1314    while (FNextVrtx(VrtxP, Vrtx)){
1315      int VId=Vrtx->GetVId();
1316      TIntFltH VIdToWgtH;
1317      VIdToWgtH.AddDat(VId, 1);
1318      _SaveTxtSparseNbrs(VId, 1, MxLev, VIdToWgtH);
1319      TIntFltPrV VIdWgtPrV; VIdToWgtH.GetKeyDatPrV(VIdWgtPrV);
1320      VIdWgtPrV.Sort();
1321      TChA ChA;
1322      ChA+=TInt::GetStr(VId);
1323      for (int VIdN=0; VIdN<VIdWgtPrV.Len(); VIdN++){
1324        ChA+=' '; ChA+=TInt::GetStr(VIdWgtPrV[VIdN].Val1);
1325        ChA+=':'; ChA+=TFlt::GetStr(VIdWgtPrV[VIdN].Val2, "%.3f");
1326      }
1327      ChA+='\n';
1328      TupVarValSOut->PutStr(ChA);
1329    }}
1330  }
1331  bool TGGraph::IsReg=TGGraph::MkReg();
1332  int TGGraph::AddVrtx(const PVrtx& Vrtx){
1333    Vrtx->DefVrtx(this);
1334    int VId=Vrtx->GetVId();
1335    TStr VNm=Vrtx->GetVNm();
1336    IAssert(!VIdToVrtxH.IsKey(VId));
1337    VIdToVrtxH.AddDat(VId, Vrtx);
1338    if (!VNm.Empty()){VNmToVIdH.AddDat(VNm, VId);}
1339    return VId;
1340  }
1341  void TGGraph::DelVrtx(const PVrtx& Vrtx){
1342    while (Vrtx->GetInEIds()>0){
1343      DelEdge(Vrtx->GetInEId(0));}
1344    while (Vrtx->GetOutEIds()>0){
1345      DelEdge(Vrtx->GetOutEId(0));}
1346    VIdToVrtxH.DelKey(Vrtx->GetVId());
1347    if (!Vrtx->GetVNm().Empty()){VNmToVIdH.DelKey(Vrtx->GetVNm());}
1348  }
1349  bool TGGraph::IsVrtx(const TStr& VNm, PVrtx& Vrtx) const {
1350    int VNmToVIdP;
1351    if (VNmToVIdH.IsKey(VNm, VNmToVIdP)){
1352      Vrtx=GetVrtx(VNmToVIdH[VNmToVIdP]); return true;}
1353    else {return false;}
1354  }
1355  bool TGGraph::FNextVrtx(int& VrtxP, PVrtx& Vrtx) const {
1356    if (VIdToVrtxH.FNextKeyId(VrtxP)){
1357      Vrtx=VIdToVrtxH[VrtxP]; return true;}
1358    else {return false;}
1359  }
1360  void TGGraph::ClrVrtxMarks() const {
1361    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1362    while (FNextVrtx(VrtxP, Vrtx)){
1363      Vrtx->ClrMark();}
1364  }
1365  int TGGraph::AddEdge(const PEdge& Edge){
1366    Edge->DefEdge(this);
1367    int EId=Edge->GetEId();
1368    int VId1=Edge->GetVId1();
1369    int VId2=Edge->GetVId2();
1370    bool DirP=Edge->IsDir();
1371    TStr ENm=Edge->GetENm();
1372    IAssert(!EIdToEdgeH.IsKey(EId));
1373    IAssert(VIdToVrtxH.IsKey(VId1));
1374    IAssert(VIdToVrtxH.IsKey(VId2));
1375    DefEId(EId);
1376    EIdToEdgeH.AddDat(EId, Edge);
1377    if (!ENm.Empty()){ENmToEIdH.AddDat(ENm, EId);}
1378    VIdToVrtxH.GetDat(VId1)->AddOutEId(EId);
1379    VIdToVrtxH.GetDat(VId2)->AddInEId(EId);
1380    if (!DirP){
1381      VIdToVrtxH.GetDat(VId1)->AddInEId(EId);
1382      VIdToVrtxH.GetDat(VId2)->AddOutEId(EId);
1383    }
1384    return EId;
1385  }
1386  void TGGraph::DelEdge(const PEdge& Edge){
1387    int EId=Edge->GetEId();
1388    int VId1=Edge->GetVId1();
1389    int VId2=Edge->GetVId2();
1390    GetVrtx(VId1)->DelEId(EId);
1391    GetVrtx(VId2)->DelEId(EId);
1392    EIdToEdgeH.DelKey(Edge->GetEId());
1393    if (!Edge->GetENm().Empty()){
1394      if (ENmToEIdH.IsKey(Edge->GetENm())){
1395        ENmToEIdH.DelKey(Edge->GetENm());}
1396    }
1397  }
1398  bool TGGraph::IsEdge(const TStr& ENm, PEdge& Edge) const {
1399    int ENmToEIdP;
1400    if (ENmToEIdH.IsKey(ENm, ENmToEIdP)){
1401      Edge=GetEdge(ENmToEIdH[ENmToEIdP]); return true;}
1402    else {return false;}
1403  }
1404  bool TGGraph::FNextEdge(int& EdgeP, PEdge& Edge) const {
1405    if (EIdToEdgeH.FNextKeyId(EdgeP)){
1406      Edge=EIdToEdgeH[EdgeP]; return true;}
1407    else {return false;}
1408  }
1409  bool TGGraph::IsVrtxsEdge(
1410   const int& VId1, const int& VId2, const bool& DirP, PEdge& Edge) const {
1411    PVrtx Vrtx1=GetVrtx(VId1);
1412    PVrtx Vrtx2=GetVrtx(VId2);
1413    for (int EIdN=0; EIdN<Vrtx1->GetOutEIds(); EIdN++){
1414      Edge=GetEdge(Vrtx1->GetOutEId(EIdN));
1415      if (VId2==Edge->GetOtherVId(Vrtx1)){return true;}
1416    }
1417    if (!DirP){
1418      for (int EIdN=0; EIdN<Vrtx2->GetOutEIds(); EIdN++){
1419        Edge=GetEdge(Vrtx2->GetOutEId(EIdN));
1420        if (VId1==Edge->GetOtherVId(Vrtx2)){return true;}
1421      }
1422    }
1423    return false;
1424  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmbasic.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.cpp</div>
                </div>
                <div class="column column_space"><pre><code>416                      if (vecValid[k]) {
417                          Assert(k <= vecLen);
418                          result[j] = vecVals[k];
419                      } else {
420                          if (cache.IsRowValid(ids[j], i)) {
421                              result[j] = cache.GetVal(ids[j], i);
422                          } else {
423                              result[j] = kernel(i, ids[j]);
</pre></code></div>
                <div class="column column_space"><pre><code>849        if (Brief==0){
850          TGksRect Rect=Gks->TxtBox(TxtBoxType, DNm, X, Y);
851          Vrtx->PutRect(Rect);
852        } else {
853          if (DNm.IsChIn('#')){
854            TStr TxtStr1; TStr TxtStr2;
855            DNm.SplitOnCh(TxtStr1, '#', TxtStr2);
856            TGksRect Rect=Gks->TxtBox(TxtBoxType, TxtStr1, X, Y);
857            Vrtx->PutRect(Rect);
858          } else {
859            TGksRect Rect=Gks->TxtBox(TxtBoxType, DNm, X, Y);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    