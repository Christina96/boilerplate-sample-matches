
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-demo-TNodeEdgeNet.cpp</h3>
            <pre><code>1  #include &quot;Snap.h&quot;
2  void PrintNStats(const char s[], TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net) {
3    printf(&quot;network %s, nodes %d, edges %d, empty %s\n&quot;,
4        s, Net-&gt;GetNodes(), Net-&gt;GetEdges(),
5        Net-&gt;Empty() ? &quot;yes&quot; : &quot;no&quot;);
6  }
7  void DefaultConstructor() {
8    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
9    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
10    PrintNStats(&quot;DefaultConstructor:Net&quot;, Net);
11  }
12  void ManipulateNodesEdges() {
13    int NNodes = 10000;
14    int NEdges = 100000;
15    const char *FName = &quot;demo.net.dat&quot;;
16    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
17    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
18    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
19    int i;
20    int n;
21    int NCount;
22    int ECount1;
23    int ECount2;
24    int x,y;
25    bool t;
26    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
27    t = Net-&gt;Empty();
28    for (i = 0; i &lt; NNodes; i++) {
29      Net-&gt;AddNode(i);
30    }
31    t = Net-&gt;Empty();
32    n = Net-&gt;GetNodes();
33    NCount = NEdges;
34    while (NCount &gt; 0) {
35      x = (long) (drand48() * NNodes);
36      y = (long) (drand48() * NNodes);
37      n = Net-&gt;AddEdge(x, y);
38      NCount--;
39    }
40    PrintNStats(&quot;ManipulateNodesEdges:Net&quot;, Net);
41    NCount = 0;
42    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
43      NCount++;
44    }
45    ECount1 = 0;
46    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
47      for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
48        ECount1++;
49      }
50    }
51    ECount2 = 0;
52    NCount = 0;
53    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
54      ECount2++;
55    }
56    printf(&quot;network ManipulateNodesEdges:Net, nodes %d, edges1 %d, edges2 %d\n&quot;,
57        NCount, ECount1, ECount2);
58    Net1 = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
59    *Net1 = *Net;
60    PrintNStats(&quot;ManipulateNodesEdges:Net1&quot;,Net1);
61    {
62      TFOut FOut(FName);
63      Net-&gt;Save(FOut);
64      FOut.Flush();
65    }
66    {
67      TFIn FIn(FName);
68      Net2 = TNodeEdgeNet&lt;TInt, TInt&gt;::Load(FIn);
69    }
70    PrintNStats(&quot;ManipulateNodesEdges:Net2&quot;,Net2);
71    for (i = 0; i &lt; NNodes; i++) {
72      n = Net-&gt;GetRndNId();
73      Net-&gt;DelNode(n);
74    }
75    PrintNStats(&quot;ManipulateNodesEdges:Net&quot;,Net);
76    Net1-&gt;Clr();
77    PrintNStats(&quot;ManipulateNodesEdges:Net1&quot;,Net1);
78  }
79  void SetNodeData() {
80    int NNodes = 10000;
81    int NEdges = 100000;
82    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
83    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
84    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
85    int i;
86    int n;
87    int NCount;
88    int x,y;
89    bool t;
90    int NodeId;
91    int NodeDat;
92    int Value;
93    bool ok;
94    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
95    t = Net-&gt;Empty();
96    for (i = 0; i &lt; NNodes; i++) {
97      Net-&gt;AddNode(i);
98    }
99    t = Net-&gt;Empty();
100    n = Net-&gt;GetNodes();
101    NCount = NEdges;
102    while (NCount &gt; 0) {
103      x = (long) (drand48() * NNodes);
104      y = (long) (drand48() * NNodes);
105      n = Net-&gt;AddEdge(x, y);
106      NCount--;
107    }
108    PrintNStats(&quot;SetNodeData:Net&quot;, Net);
109    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
110      NodeId = NI.GetId();
111      NodeDat = NodeId + 10;
112      Net-&gt;SetNDat(NI.GetId(), NodeDat);
113    }
114    ok = true;
115    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
116      NodeDat = Net-&gt;GetNDat(NI.GetId());
117      Value = NI.GetId() + 10;
118      if (NodeDat != Value) {
119        ok = false;
120      }
121    }
122    printf(&quot;network SetNodeData:Net, status %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
123  }
124  void UpdateNodeData() {
125    int NNodes = 10000;
126    int NEdges = 100000;
127    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
128    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
129    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
130    int i;
131    int n;
132    int NCount;
133    int x,y;
134    bool t;
135    int NodeDat;
136    int Value;
137    bool ok;
138    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
139    t = Net-&gt;Empty();
140    for (i = 0; i &lt; NNodes; i++) {
141      Net-&gt;AddNode(i,i+5);
142    }
143    t = Net-&gt;Empty();
144    n = Net-&gt;GetNodes();
145    NCount = NEdges;
146    while (NCount &gt; 0) {
147      x = (long) (drand48() * NNodes);
148      y = (long) (drand48() * NNodes);
149      n = Net-&gt;AddEdge(x, y);
150      NCount--;
151    }
152    PrintNStats(&quot;UpdateNodeData:Net&quot;, Net);
153    ok = true;
154    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
155      NodeDat = Net-&gt;GetNDat(NI.GetId());
156      Value = NI.GetId()+5;
157      if (NodeDat != Value) {
158        ok = false;
159      }
160    }
161    printf(&quot;network UpdateNodeData:Net, status1 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
162    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
163      Net-&gt;SetNDat(NI.GetId(), NI.GetId()+10);
164    }
165    ok = true;
166    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
167      NodeDat = Net-&gt;GetNDat(NI.GetId());
168      Value = NI.GetId()+10;
169      if (NodeDat != Value) {
170        ok = false;
171      }
172    }
173    printf(&quot;network UpdateNodeData:Net, status2 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
174  }
175  void SetEdgeData() {
176    int NNodes = 10000;
177    int NEdges = 100000;
178    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
179    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
180    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
181    int i;
182    int n;
183    int NCount;
184    int x,y;
185    bool t;
186    int EId;
<span onclick='openModal()' class='match'>187    int SrcNId;
188    int DstNId;
189    int EdgeDat;
190    int Value;
191    bool ok;
192    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
</span>193    t = Net-&gt;Empty();
194    for (i = 0; i &lt; NNodes; i++) {
195      Net-&gt;AddNode(i);
196    }
197    t = Net-&gt;Empty();
198    n = Net-&gt;GetNodes();
199    NCount = NEdges;
200    while (NCount &gt; 0) {
201      x = (long) (drand48() * NNodes);
202      y = (long) (drand48() * NNodes);
203      n = Net-&gt;AddEdge(x, y);
204      NCount--;
205    }
206    PrintNStats(&quot;SetEdgeData:Net&quot;, Net);
207    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
208      Net-&gt;SetEDat(EI.GetId(),EI.GetSrcNId()*EI.GetDstNId());
209    }
210    ok = true;
211    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
212      EId = EI.GetId();
213      SrcNId = EI.GetSrcNId();
214      DstNId = EI.GetDstNId();
215      EdgeDat = Net-&gt;GetEDat(EId);
216      Value = SrcNId*DstNId;
217      if (EdgeDat != Value) {
218        ok = false;
219      }
220    }
221    printf(&quot;network SetEdgeData:Net, status1 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
222    Net-&gt;SetAllEDat(42);
223    ok = true;
224    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
225      EId = EI.GetId();
226      EdgeDat = Net-&gt;GetEDat(EId);
227      if (EdgeDat != 42) {
228        ok = false;
229      }
230    }
231    printf(&quot;network SetEdgeData:Net, status2 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
232  }
233  void UpdateEdgeData() {
234    int NNodes = 10000;
235    int NEdges = 100000;
236    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
237    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
238    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
239    int i;
240    int n;
241    int NCount;
242    int x,y;
243    bool t;
244    int EId;
245    int SrcNId;
246    int DstNId;
247    int EdgeDat;
248    int Value;
249    bool ok;
250    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
251    t = Net-&gt;Empty();
252    for (i = 0; i &lt; NNodes; i++) {
253      Net-&gt;AddNode(i);
254    }
255    t = Net-&gt;Empty();
256    n = Net-&gt;GetNodes();
257    NCount = NEdges;
258    while (NCount &gt; 0) {
259      x = (long) (drand48() * NNodes);
260      y = (long) (drand48() * NNodes);
261      n = Net-&gt;AddEdge(x, y, -1, x+y+10);
262      NCount--;
263    }
264    PrintNStats(&quot;UpdateEdgeData:Net&quot;, Net);
265    ok = true;
266    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
267      EId = EI.GetId();
268      SrcNId = EI.GetSrcNId();
269      DstNId = EI.GetDstNId();
270      EdgeDat = Net-&gt;GetEDat(EId);
271      Value = SrcNId+DstNId+10;
272      if (EdgeDat != Value) {
273        ok = false;
274      }
275    }
276    printf(&quot;network UpdateEdgeData:Net, status1 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
277    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
278      Net-&gt;SetEDat(EI.GetId(),EI.GetSrcNId()+EI.GetDstNId()+5);
279    }
280    ok = true;
281    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
282      EId = EI.GetId();
283      SrcNId = EI.GetSrcNId();
284      DstNId = EI.GetDstNId();
285      EdgeDat = Net-&gt;GetEDat(EId);
286      Value = SrcNId+DstNId+5;
287      if (EdgeDat != Value) {
288        ok = false;
289      }
290    }
291    printf(&quot;network UpdateEdgeData:Net, status1 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
292  }
293  void SortNodeData() {
294    int NNodes = 10000;
295    int NEdges = 100000;
296    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
297    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
298    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
299    int i;
300    int n;
301    int NCount;
302    int x,y;
303    bool t;
304    int NodeId;
305    int NodeDat;
306    bool ok;
307    bool Sorted;
308    int Min;
309    int Value;
310    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
311    t = Net-&gt;Empty();
312    for (i = 0; i &lt; NNodes; i++) {
313      Net-&gt;AddNode((i*13) % NNodes);
314    }
315    t = Net-&gt;Empty();
316    n = Net-&gt;GetNodes();
317    NCount = NEdges;
318    while (NCount &gt; 0) {
319      x = (long) (drand48() * NNodes);
320      y = (long) (drand48() * NNodes);
321      n = Net-&gt;AddEdge(x, y);
322      NCount--;
323    }
324    PrintNStats(&quot;SortNodeData:Net&quot;, Net);
325    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
326      NodeId = NI.GetId();
327      NodeDat = (NI.GetId()*NI.GetId()) % NNodes;
328      Net-&gt;SetNDat(NodeId, NodeDat);
329    }
330    ok = true;
331    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
332      NodeDat = Net-&gt;GetNDat(NI.GetId());
333      Value = (NI.GetId()*NI.GetId()) % NNodes;
334      if (NodeDat != Value) {
335        ok = false;
336      }
337    }
338    printf(&quot;network SortNodeData:Net, status1 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
339    Min = -1;
340    Sorted = true;
341    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
342      Value = NI.GetId();
343      if (Min &gt; Value) {
344        Sorted = false;
345      }
346      Min = Value;
347    }
348    printf(&quot;network SortNodeData:Net, status2 %s\n&quot;, (Sorted == false) ? &quot;ok&quot; : &quot;ERROR&quot;);
349    Net-&gt;SortNIdById();
350    Min = -1;
351    Sorted = true;
352    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
353      Value = NI.GetId();
354      if (Min &gt; Value) {
355        Sorted = false;
356      }
357      Min = Value;
358    }
359    printf(&quot;network SortNodeData:Net, status3 %s\n&quot;, (Sorted == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
360    Min = -1;
361    Sorted = true;
362    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
363      Value = Net-&gt;GetNDat(NI.GetId());
364      if (Min &gt; Value) {
365        Sorted = false;
366      }
367      Min = Value;
368    }
369    printf(&quot;network SortNodeData:Net, status4 %s\n&quot;, (Sorted == false) ? &quot;ok&quot; : &quot;ERROR&quot;);
370    Net-&gt;SortNIdByDat();
371    Min = -1;
372    Sorted = true;
373    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
374      Value = Net-&gt;GetNDat(NI.GetId());
375      if (Min &gt; Value) {
376        Sorted = false;
377      }
378      Min = Value;
379    }
380    printf(&quot;network SortNodeData:Net, status5 %s\n&quot;, (Sorted == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
381    Min = -1;
382    Sorted = true;
383    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
384      Value = NI.GetId();
385      if (Min &gt; Value) {
386        Sorted = false;
387      }
388      Min = Value;
389    }
390    printf(&quot;network SortNodeData:Net, status6 %s\n&quot;, (Sorted == false) ? &quot;ok&quot; : &quot;ERROR&quot;);
391    ok = true;
392    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
393      NodeDat = Net-&gt;GetNDat(NI.GetId());
394      Value = (NI.GetId()*NI.GetId()) % NNodes;
395      if (NodeDat != Value) {
396        ok = false;
397      }
398    }
399    printf(&quot;network SortNodeData:Net, status7 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
400  }
401  void SortEdgeData() {
402    int NNodes = 10000;
403    int NEdges = 100000;
404    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net;
405    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net1;
406    TPt &lt;TNodeEdgeNet&lt;TInt, TInt&gt; &gt; Net2;
407    int i;
408    int n;
409    int x,y;
410    bool t;
411    int NodeDat;
412    int EId;
413    int SrcNId;
414    int DstNId;
415    int EdgeDat;
416    bool Sorted;
417    int Min;
418    int Value;
419    bool ok;
420    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
421    t = Net-&gt;Empty();
422    for (i = 0; i &lt; NNodes; i++) {
423      x = (i*13) % NNodes;
424      Net-&gt;AddNode(x, (x*x) % NNodes);
425    }
426    t = Net-&gt;Empty();
427    n = Net-&gt;GetNodes();
428    for (i = 0; i &lt; NEdges; i++) {
429      x = (long) (drand48() * NNodes);
430      y = (long) (drand48() * NNodes);
431      n = Net-&gt;AddEdge(x, y, (i*37) % NEdges, (x*y) % NEdges);
432    }
433    PrintNStats(&quot;SortEdgeData:Net&quot;, Net);
434    ok = true;
435    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
436      NodeDat = Net-&gt;GetNDat(NI.GetId());
437      Value = (NI.GetId()*NI.GetId()) % NNodes;
438      if (NodeDat != Value) {
439        ok = false;
440      }
441    }
442    printf(&quot;network SortEdgeData:Net, status1 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
443    ok = true;
444    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
445      EId = EI.GetId();
446      SrcNId = EI.GetSrcNId();
447      DstNId = EI.GetDstNId();
448      EdgeDat = Net-&gt;GetEDat(EId);
449      Value = (SrcNId*DstNId) % NEdges;
450      if (EdgeDat != Value) {
451        ok = false;
452      }
453    }
454    printf(&quot;network SortEdgeData:Net, status2 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
455    Min = -1;
456    Sorted = true;
457    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
458      Value = EI.GetId();
459      if (Min &gt; Value) {
460        Sorted = false;
461      }
462      Min = Value;
463    }
464    printf(&quot;network SortEdgeData:Net, status3 %s\n&quot;, (Sorted == false) ? &quot;ok&quot; : &quot;ERROR&quot;);
465    Net-&gt;SortEIdById();
466    Min = -1;
467    Sorted = true;
468    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
469      Value = EI.GetId();
470      if (Min &gt; Value) {
471        Sorted = false;
472      }
473      Min = Value;
474    }
475    printf(&quot;network SortEdgeData:Net, status4 %s\n&quot;, (Sorted == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
476    Min = -1;
477    Sorted = true;
478    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
479      Value = Net-&gt;GetEDat(EI.GetId());
480      if (Min &gt; Value) {
481        Sorted = false;
482      }
483      Min = Value;
484    }
485    printf(&quot;network SortEdgeData:Net, status5 %s\n&quot;, (Sorted == false) ? &quot;ok&quot; : &quot;ERROR&quot;);
486    Net-&gt;SortEIdByDat();
487    Min = -1;
488    Sorted = true;
489    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
490      Value = Net-&gt;GetEDat(EI.GetId());
491      if (Min &gt; Value) {
492        Sorted = false;
493      }
494      Min = Value;
495    }
496    printf(&quot;network SortEdgeData:Net, status6 %s\n&quot;, (Sorted == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
497    Min = -1;
498    Sorted = true;
499    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
500      Value = EI.GetId();
501      if (Min &gt; Value) {
502        Sorted = false;
503      }
504      Min = Value;
505    }
506    printf(&quot;network SortEdgeData:Net, status7 %s\n&quot;, (Sorted == false) ? &quot;ok&quot; : &quot;ERROR&quot;);
507    ok = true;
508    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TEdgeI EI = Net-&gt;BegEI(); EI &lt; Net-&gt;EndEI(); EI++) {
509      EId = EI.GetId();
510      SrcNId = EI.GetSrcNId();
511      DstNId = EI.GetDstNId();
512      EdgeDat = Net-&gt;GetEDat(EId);
513      Value = (SrcNId*DstNId) % NEdges;
514      if (EdgeDat != Value) {
515        ok = false;
516      }
517    }
518    printf(&quot;network SortEdgeData:Net, status8 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
519    ok = true;
520    for (TNodeEdgeNet&lt;TInt, TInt&gt;::TNodeI NI = Net-&gt;BegNI(); NI &lt; Net-&gt;EndNI(); NI++) {
521      NodeDat = Net-&gt;GetNDat(NI.GetId());
522      Value = (NI.GetId()*NI.GetId()) % NNodes;
523      if (NodeDat != Value) {
524        ok = false;
525      }
526    }
527    printf(&quot;network SortEdgeData:Net, status9 %s\n&quot;, (ok == true) ? &quot;ok&quot; : &quot;ERROR&quot;);
528  }
529  int main(int argc, char* argv[]) {
530    DefaultConstructor();
531    ManipulateNodesEdges();
532    SetNodeData();
533    UpdateNodeData();
534    SetEdgeData();
535    UpdateEdgeData();
536    SortNodeData();
537    SortEdgeData();
538  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Document.h</h3>
            <pre><code>1  #ifndef DOCUMENT_H
2  #define DOCUMENT_H
3  namespace Scintilla::Internal {
4  class DocWatcher;
5  class DocModification;
6  class Document;
7  class LineMarkers;
8  class LineLevels;
9  class LineState;
10  class LineAnnotation;
11  enum class EncodingFamily { eightBit, unicode, dbcs };
12  class Range {
13  public:
14  	Sci::Position start;
15  	Sci::Position end;
16  	explicit Range(Sci::Position pos=0) noexcept :
17  		start(pos), end(pos) {
18  	}
19  	Range(Sci::Position start_, Sci::Position end_) noexcept :
20  		start(start_), end(end_) {
21  	}
22  	bool operator==(const Range &amp;other) const noexcept {
23  		return (start == other.start) &amp;&amp; (end == other.end);
24  	}
25  	bool Valid() const noexcept {
26  		return (start != Sci::invalidPosition) &amp;&amp; (end != Sci::invalidPosition);
27  	}
28  	[[nodiscard]] bool Empty() const noexcept {
29  		return start == end;
30  	}
31  	[[nodiscard]] Sci::Position Length() const noexcept {
32  		return (start &lt;= end) ? (end - start) : (start - end);
33  	}
34  	Sci::Position First() const noexcept {
35  		return (start &lt;= end) ? start : end;
36  	}
37  	Sci::Position Last() const noexcept {
38  		return (start &gt; end) ? start : end;
39  	}
40  	bool Contains(Sci::Position pos) const noexcept {
41  		if (start &lt; end) {
42  			return (pos &gt;= start &amp;&amp; pos &lt;= end);
43  		} else {
44  			return (pos &lt;= start &amp;&amp; pos &gt;= end);
45  		}
46  	}
47  	bool ContainsCharacter(Sci::Position pos) const noexcept {
48  		if (start &lt; end) {
49  			return (pos &gt;= start &amp;&amp; pos &lt; end);
50  		} else {
51  			return (pos &lt; start &amp;&amp; pos &gt;= end);
52  		}
53  	}
54  	bool Contains(Range other) const noexcept {
55  		return Contains(other.start) &amp;&amp; Contains(other.end);
56  	}
57  	bool Overlaps(Range other) const noexcept {
58  		return
59  		Contains(other.start) ||
60  		Contains(other.end) ||
61  		other.Contains(start) ||
62  		other.Contains(end);
63  	}
64  };
65  class RegexSearchBase {
66  public:
67  	virtual ~RegexSearchBase() = default;
68  	virtual Sci::Position FindText(Document *doc, Sci::Position minPos, Sci::Position maxPos, const char *s,
69                          bool caseSensitive, bool word, bool wordStart, Scintilla::FindOption flags, Sci::Position *length) = 0;
70  	virtual const char *SubstituteByPosition(Document *doc, const char *text, Sci::Position *length) = 0;
71  };
72  extern RegexSearchBase *CreateRegexSearch(CharClassify *charClassTable);
73  struct StyledText {
74  	size_t length;
75  	const char *text;
76  	bool multipleStyles;
77  	size_t style;
78  	const unsigned char *styles;
79  	StyledText(size_t length_, const char *text_, bool multipleStyles_, int style_, const unsigned char *styles_) noexcept :
80  		length(length_), text(text_), multipleStyles(multipleStyles_), style(style_), styles(styles_) {
81  	}
82  	size_t LineLength(size_t start) const noexcept {
83  		size_t cur = start;
84  		while ((cur &lt; length) &amp;&amp; (text[cur] != &#x27;\n&#x27;))
85  			cur++;
86  		return cur-start;
87  	}
88  	size_t StyleAt(size_t i) const noexcept {
89  		return multipleStyles ? styles[i] : style;
90  	}
91  };
92  class HighlightDelimiter {
93  public:
94  	HighlightDelimiter() noexcept : isEnabled(false) {
95  		Clear();
96  	}
97  	void Clear() noexcept {
98  		beginFoldBlock = -1;
99  		endFoldBlock = -1;
100  		firstChangeableLineBefore = -1;
101  		firstChangeableLineAfter = -1;
102  	}
103  	bool NeedsDrawing(Sci::Line line) const noexcept {
104  		return isEnabled &amp;&amp; (line &lt;= firstChangeableLineBefore || line &gt;= firstChangeableLineAfter);
105  	}
106  	bool IsFoldBlockHighlighted(Sci::Line line) const noexcept {
107  		return isEnabled &amp;&amp; beginFoldBlock != -1 &amp;&amp; beginFoldBlock &lt;= line &amp;&amp; line &lt;= endFoldBlock;
108  	}
109  	bool IsHeadOfFoldBlock(Sci::Line line) const noexcept {
110  		return beginFoldBlock == line &amp;&amp; line &lt; endFoldBlock;
111  	}
112  	bool IsBodyOfFoldBlock(Sci::Line line) const noexcept {
113  		return beginFoldBlock != -1 &amp;&amp; beginFoldBlock &lt; line &amp;&amp; line &lt; endFoldBlock;
114  	}
115  	bool IsTailOfFoldBlock(Sci::Line line) const noexcept {
116  		return beginFoldBlock != -1 &amp;&amp; beginFoldBlock &lt; line &amp;&amp; line == endFoldBlock;
117  	}
118  	Sci::Line beginFoldBlock;	
119  	Sci::Line endFoldBlock;	
120  	Sci::Line firstChangeableLineBefore;	
121  	Sci::Line firstChangeableLineAfter;	
122  	bool isEnabled;
123  };
124  struct LexerReleaser {
125  	void operator()(Scintilla::ILexer5 *pLexer) noexcept {
126  		if (pLexer) {
127  			try {
128  				pLexer-&gt;Release();
129  			} catch (...) {
130  			}
131  		}
132  	}
133  };
134  using LexerInstance = std::unique_ptr&lt;Scintilla::ILexer5, LexerReleaser&gt;;
135  class LexInterface {
136  protected:
137  	Document *pdoc;
138  	LexerInstance instance;
139  	bool performingStyle;	
140  public:
141  	explicit LexInterface(Document *pdoc_) noexcept;
142  	LexInterface(const LexInterface &amp;) = delete;
143  	LexInterface(LexInterface &amp;&amp;) = delete;
144  	LexInterface &amp;operator=(const LexInterface &amp;) = delete;
145  	LexInterface &amp;operator=(LexInterface &amp;&amp;) = delete;
146  	virtual ~LexInterface() noexcept;
147  	void SetInstance(ILexer5 *instance_) noexcept;
148  	void Colourise(Sci::Position start, Sci::Position end);
149  	virtual Scintilla::LineEndType LineEndTypesSupported();
150  	bool UseContainerLexing() const noexcept;
151  };
152  struct RegexError : public std::runtime_error {
153  	RegexError() : std::runtime_error(&quot;regex failure&quot;) {}
154  };
155  class ActionDuration {
156  	double duration;
157  	const double minDuration;
158  	const double maxDuration;
159  public:
160  	ActionDuration(double duration_, double minDuration_, double maxDuration_) noexcept;
161  	void AddSample(size_t numberActions, double durationOfActions) noexcept;
162  	double Duration() const noexcept;
163  	size_t ActionsInAllowedTime(double secondsAllowed) const noexcept;
164  };
165  struct CharacterExtracted {
166  	unsigned int character;
167  	unsigned int widthBytes;
168  	CharacterExtracted(unsigned int character_, unsigned int widthBytes_) noexcept :
169  		character(character_), widthBytes(widthBytes_) {
170  	}
171  	CharacterExtracted(const unsigned char *charBytes, size_t widthCharBytes) noexcept;
172  	static CharacterExtracted DBCS(unsigned char lead, unsigned char trail) noexcept {
173  		return CharacterExtracted((lead &lt;&lt; 8) | trail, 2);
174  	}
175  };
176  class Document : PerLine, public Scintilla::IDocument, public Scintilla::ILoader {
177  public:
178  	struct WatcherWithUserData {
179  		DocWatcher *watcher;
180  		void *userData;
181  		WatcherWithUserData(DocWatcher *watcher_=nullptr, void *userData_=nullptr) noexcept :
182  			watcher(watcher_), userData(userData_) {
183  		}
184  		bool operator==(const WatcherWithUserData &amp;other) const noexcept {
185  			return (watcher == other.watcher) &amp;&amp; (userData == other.userData);
186  		}
187  	};
188  private:
189  	int refCount;
190  	CellBuffer cb;
191  	CharClassify charClass;
192  	CharacterCategoryMap charMap;
193  	std::unique_ptr&lt;CaseFolder&gt; pcf;
194  	Sci::Position endStyled;
<span onclick='openModal()' class='match'>195  	int styleClock;
196  	int enteredModification;
197  	int enteredStyling;
198  	int enteredReadOnlyCount;
199  	bool insertionSet;
200  	std::string insertion;
</span>201  	std::vector&lt;WatcherWithUserData&gt; watchers;
202  	enum lineData { ldMarkers, ldLevels, ldState, ldMargin, ldAnnotation, ldEOLAnnotation, ldSize };
203  	std::unique_ptr&lt;PerLine&gt; perLineData[ldSize];
204  	LineMarkers *Markers() const noexcept;
205  	LineLevels *Levels() const noexcept;
206  	LineState *States() const noexcept;
207  	LineAnnotation *Margins() const noexcept;
208  	LineAnnotation *Annotations() const noexcept;
209  	LineAnnotation *EOLAnnotations() const noexcept;
210  	bool matchesValid;
211  	std::unique_ptr&lt;RegexSearchBase&gt; regex;
212  	std::unique_ptr&lt;LexInterface&gt; pli;
213  public:
214  	Scintilla::EndOfLine eolMode;
215  	int dbcsCodePage;
216  	Scintilla::LineEndType lineEndBitSet;
217  	int tabInChars;
218  	int indentInChars;
219  	int actualIndentInChars;
220  	bool useTabs;
221  	bool tabIndents;
222  	bool backspaceUnindents;
223  	ActionDuration durationStyleOneByte;
224  	std::unique_ptr&lt;IDecorationList&gt; decorations;
225  	Document(Scintilla::DocumentOption options);
226  	Document(const Document &amp;) = delete;
227  	Document(Document &amp;&amp;) = delete;
228  	void operator=(const Document &amp;) = delete;
229  	Document &amp;operator=(Document &amp;&amp;) = delete;
230  	~Document() override;
231  	int AddRef();
232  	int SCI_METHOD Release() override;
233  	void Init() override;
234  	void InsertLine(Sci::Line line) override;
235  	void InsertLines(Sci::Line line, Sci::Line lines) override;
236  	void RemoveLine(Sci::Line line) override;
237  	Scintilla::LineEndType LineEndTypesSupported() const;
238  	bool SetDBCSCodePage(int dbcsCodePage_);
239  	Scintilla::LineEndType GetLineEndTypesAllowed() const noexcept { return cb.GetLineEndTypes(); }
240  	bool SetLineEndTypesAllowed(Scintilla::LineEndType lineEndBitSet_);
241  	Scintilla::LineEndType GetLineEndTypesActive() const noexcept { return cb.GetLineEndTypes(); }
242  	int SCI_METHOD Version() const override {
243  		return Scintilla::dvRelease4;
244  	}
245  	void SCI_METHOD SetErrorStatus(int status) override;
246  	Sci_Position SCI_METHOD LineFromPosition(Sci_Position pos) const override;
247  	Sci::Line SciLineFromPosition(Sci::Position pos) const noexcept;	
248  	Sci::Position ClampPositionIntoDocument(Sci::Position pos) const noexcept;
249  	bool ContainsLineEnd(const char *s, Sci::Position length) const noexcept { return cb.ContainsLineEnd(s, length); }
250  	bool IsCrLf(Sci::Position pos) const noexcept;
251  	int LenChar(Sci::Position pos) const noexcept;
252  	bool InGoodUTF8(Sci::Position pos, Sci::Position &amp;start, Sci::Position &amp;end) const noexcept;
253  	Sci::Position MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd=true) const noexcept;
254  	Sci::Position NextPosition(Sci::Position pos, int moveDir) const noexcept;
255  	bool NextCharacter(Sci::Position &amp;pos, int moveDir) const noexcept;	
256  	CharacterExtracted CharacterAfter(Sci::Position position) const noexcept;
257  	CharacterExtracted CharacterBefore(Sci::Position position) const noexcept;
258  	Sci_Position SCI_METHOD GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const override;
259  	Sci::Position GetRelativePositionUTF16(Sci::Position positionStart, Sci::Position characterOffset) const noexcept;
260  	int SCI_METHOD GetCharacterAndWidth(Sci_Position position, Sci_Position *pWidth) const override;
261  	int SCI_METHOD CodePage() const override;
262  	bool SCI_METHOD IsDBCSLeadByte(char ch) const override;
263  	bool IsDBCSLeadByteNoExcept(char ch) const noexcept;
264  	bool IsDBCSTrailByteNoExcept(char ch) const noexcept;
265  	int DBCSDrawBytes(std::string_view text) const noexcept;
266  	bool IsDBCSDualByteAt(Sci::Position pos) const noexcept;
267  	size_t SafeSegment(std::string_view text) const noexcept;
268  	EncodingFamily CodePageFamily() const noexcept;
269  	void ModifiedAt(Sci::Position pos) noexcept;
270  	void CheckReadOnly();
271  	void TrimReplacement(std::string_view &amp;text, Range &amp;range) const noexcept;
272  	bool DeleteChars(Sci::Position pos, Sci::Position len);
273  	Sci::Position InsertString(Sci::Position position, const char *s, Sci::Position insertLength);
274  	Sci::Position InsertString(Sci::Position position, std::string_view sv);
275  	void ChangeInsertion(const char *s, Sci::Position length);
276  	int SCI_METHOD AddData(const char *data, Sci_Position length) override;
277  	void * SCI_METHOD ConvertToDocument() override;
278  	Sci::Position Undo();
279  	Sci::Position Redo();
280  	bool CanUndo() const noexcept { return cb.CanUndo(); }
281  	bool CanRedo() const noexcept { return cb.CanRedo(); }
282  	void DeleteUndoHistory() { cb.DeleteUndoHistory(); }
283  	bool SetUndoCollection(bool collectUndo) {
284  		return cb.SetUndoCollection(collectUndo);
285  	}
286  	bool IsCollectingUndo() const noexcept { return cb.IsCollectingUndo(); }
287  	void BeginUndoAction() { cb.BeginUndoAction(); }
288  	void EndUndoAction() { cb.EndUndoAction(); }
289  	void AddUndoAction(Sci::Position token, bool mayCoalesce) { cb.AddUndoAction(token, mayCoalesce); }
290  	void SetSavePoint();
291  	bool IsSavePoint() const noexcept { return cb.IsSavePoint(); }
292  	void TentativeStart() { cb.TentativeStart(); }
293  	void TentativeCommit() { cb.TentativeCommit(); }
294  	void TentativeUndo();
295  	bool TentativeActive() const noexcept { return cb.TentativeActive(); }
296  	void ChangeHistorySet(bool set) { cb.ChangeHistorySet(set); }
297  	[[nodiscard]] int EditionAt(Sci::Position pos) const noexcept { return cb.EditionAt(pos); }
298  	[[nodiscard]] Sci::Position EditionEndRun(Sci::Position pos) const noexcept { return cb.EditionEndRun(pos); }
299  	[[nodiscard]] unsigned int EditionDeletesAt(Sci::Position pos) const noexcept { return cb.EditionDeletesAt(pos); }
300  	[[nodiscard]] Sci::Position EditionNextDelete(Sci::Position pos) const noexcept { return cb.EditionNextDelete(pos); }
301  	const char * SCI_METHOD BufferPointer() override { return cb.BufferPointer(); }
302  	const char *RangePointer(Sci::Position position, Sci::Position rangeLength) noexcept { return cb.RangePointer(position, rangeLength); }
303  	Sci::Position GapPosition() const noexcept { return cb.GapPosition(); }
304  	int SCI_METHOD GetLineIndentation(Sci_Position line) override;
305  	Sci::Position SetLineIndentation(Sci::Line line, Sci::Position indent);
306  	Sci::Position GetLineIndentPosition(Sci::Line line) const;
307  	Sci::Position GetColumn(Sci::Position pos) const;
308  	Sci::Position CountCharacters(Sci::Position startPos, Sci::Position endPos) const noexcept;
309  	Sci::Position CountUTF16(Sci::Position startPos, Sci::Position endPos) const noexcept;
310  	Sci::Position FindColumn(Sci::Line line, Sci::Position column);
311  	void Indent(bool forwards, Sci::Line lineBottom, Sci::Line lineTop);
312  	static std::string TransformLineEnds(const char *s, size_t len, Scintilla::EndOfLine eolModeWanted);
313  	void ConvertLineEnds(Scintilla::EndOfLine eolModeSet);
314  	std::string_view EOLString() const noexcept;
315  	void SetReadOnly(bool set) { cb.SetReadOnly(set); }
316  	bool IsReadOnly() const noexcept { return cb.IsReadOnly(); }
317  	bool IsLarge() const noexcept { return cb.IsLarge(); }
318  	Scintilla::DocumentOption Options() const noexcept;
319  	void DelChar(Sci::Position pos);
320  	void DelCharBack(Sci::Position pos);
321  	char CharAt(Sci::Position position) const noexcept { return cb.CharAt(position); }
322  	void SCI_METHOD GetCharRange(char *buffer, Sci_Position position, Sci_Position lengthRetrieve) const override {
323  		cb.GetCharRange(buffer, position, lengthRetrieve);
324  	}
325  	char SCI_METHOD StyleAt(Sci_Position position) const override { return cb.StyleAt(position); }
326  	char StyleAtNoExcept(Sci_Position position) const noexcept { return cb.StyleAt(position); }
327  	int StyleIndexAt(Sci_Position position) const noexcept { return static_cast&lt;unsigned char&gt;(cb.StyleAt(position)); }
328  	void GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
329  		cb.GetStyleRange(buffer, position, lengthRetrieve);
330  	}
331  	int GetMark(Sci::Line line, bool includeChangeHistory) const;
332  	Sci::Line MarkerNext(Sci::Line lineStart, int mask) const noexcept;
333  	int AddMark(Sci::Line line, int markerNum);
334  	void AddMarkSet(Sci::Line line, int valueSet);
335  	void DeleteMark(Sci::Line line, int markerNum);
336  	void DeleteMarkFromHandle(int markerHandle);
337  	void DeleteAllMarks(int markerNum);
338  	Sci::Line LineFromHandle(int markerHandle) const noexcept;
339  	int MarkerNumberFromLine(Sci::Line line, int which) const noexcept;
340  	int MarkerHandleFromLine(Sci::Line line, int which) const noexcept;
341  	Sci_Position SCI_METHOD LineStart(Sci_Position line) const override;
342  	[[nodiscard]] Range LineRange(Sci::Line line) const noexcept;
343  	bool IsLineStartPosition(Sci::Position position) const;
344  	Sci_Position SCI_METHOD LineEnd(Sci_Position line) const override;
345  	Sci::Position LineEndPosition(Sci::Position position) const;
346  	bool IsLineEndPosition(Sci::Position position) const;
347  	bool IsPositionInLineEnd(Sci::Position position) const;
348  	Sci::Position VCHomePosition(Sci::Position position) const;
349  	Sci::Position IndexLineStart(Sci::Line line, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept;
350  	Sci::Line LineFromPositionIndex(Sci::Position pos, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept;
351  	Sci::Line LineFromPositionAfter(Sci::Line line, Sci::Position length) const noexcept;
352  	int SCI_METHOD SetLevel(Sci_Position line, int level) override;
353  	int SCI_METHOD GetLevel(Sci_Position line) const override;
354  	Scintilla::FoldLevel GetFoldLevel(Sci_Position line) const noexcept;
355  	void ClearLevels();
356  	Sci::Line GetLastChild(Sci::Line lineParent, std::optional&lt;Scintilla::FoldLevel&gt; level = {}, Sci::Line lastLine = -1);
357  	Sci::Line GetFoldParent(Sci::Line line) const noexcept;
358  	void GetHighlightDelimiters(HighlightDelimiter &amp;highlightDelimiter, Sci::Line line, Sci::Line lastLine);
359  	Sci::Position ExtendWordSelect(Sci::Position pos, int delta, bool onlyWordCharacters=false) const;
360  	Sci::Position NextWordStart(Sci::Position pos, int delta) const;
361  	Sci::Position NextWordEnd(Sci::Position pos, int delta) const;
362  	Sci_Position SCI_METHOD Length() const override { return cb.Length(); }
363  	Sci::Position LengthNoExcept() const noexcept { return cb.Length(); }
364  	void Allocate(Sci::Position newSize) { cb.Allocate(newSize); }
365  	CharacterExtracted ExtractCharacter(Sci::Position position) const noexcept;
366  	bool IsWordStartAt(Sci::Position pos) const;
367  	bool IsWordEndAt(Sci::Position pos) const;
368  	bool IsWordAt(Sci::Position start, Sci::Position end) const;
369  	bool MatchesWordOptions(bool word, bool wordStart, Sci::Position pos, Sci::Position length) const;
370  	bool HasCaseFolder() const noexcept;
371  	void SetCaseFolder(std::unique_ptr&lt;CaseFolder&gt; pcf_) noexcept;
372  	Sci::Position FindText(Sci::Position minPos, Sci::Position maxPos, const char *search, Scintilla::FindOption flags, Sci::Position *length);
373  	const char *SubstituteByPosition(const char *text, Sci::Position *length);
374  	Scintilla::LineCharacterIndexType LineCharacterIndex() const noexcept;
375  	void AllocateLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
376  	void ReleaseLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
377  	Sci::Line LinesTotal() const noexcept;
378  	void AllocateLines(Sci::Line lines);
379  	void SetDefaultCharClasses(bool includeWordClass);
380  	void SetCharClasses(const unsigned char *chars, CharacterClass newCharClass);
381  	int GetCharsOfClass(CharacterClass characterClass, unsigned char *buffer) const;
382  	void SetCharacterCategoryOptimization(int countCharacters);
383  	int CharacterCategoryOptimization() const noexcept;
384  	void SCI_METHOD StartStyling(Sci_Position position) override;
385  	bool SCI_METHOD SetStyleFor(Sci_Position length, char style) override;
386  	bool SCI_METHOD SetStyles(Sci_Position length, const char *styles) override;
387  	Sci::Position GetEndStyled() const noexcept { return endStyled; }
388  	void EnsureStyledTo(Sci::Position pos);
389  	void StyleToAdjustingLineDuration(Sci::Position pos);
390  	int GetStyleClock() const noexcept { return styleClock; }
391  	void IncrementStyleClock() noexcept;
392  	void SCI_METHOD DecorationSetCurrentIndicator(int indicator) override;
393  	void SCI_METHOD DecorationFillRange(Sci_Position position, int value, Sci_Position fillLength) override;
394  	LexInterface *GetLexInterface() const noexcept;
395  	void SetLexInterface(std::unique_ptr&lt;LexInterface&gt; pLexInterface) noexcept;
396  	int SCI_METHOD SetLineState(Sci_Position line, int state) override;
397  	int SCI_METHOD GetLineState(Sci_Position line) const override;
398  	Sci::Line GetMaxLineState() const noexcept;
399  	void SCI_METHOD ChangeLexerState(Sci_Position start, Sci_Position end) override;
400  	StyledText MarginStyledText(Sci::Line line) const noexcept;
401  	void MarginSetStyle(Sci::Line line, int style);
402  	void MarginSetStyles(Sci::Line line, const unsigned char *styles);
403  	void MarginSetText(Sci::Line line, const char *text);
404  	void MarginClearAll();
405  	StyledText AnnotationStyledText(Sci::Line line) const noexcept;
406  	void AnnotationSetText(Sci::Line line, const char *text);
407  	void AnnotationSetStyle(Sci::Line line, int style);
408  	void AnnotationSetStyles(Sci::Line line, const unsigned char *styles);
409  	int AnnotationLines(Sci::Line line) const noexcept;
410  	void AnnotationClearAll();
411  	StyledText EOLAnnotationStyledText(Sci::Line line) const noexcept;
412  	void EOLAnnotationSetStyle(Sci::Line line, int style);
413  	void EOLAnnotationSetText(Sci::Line line, const char *text);
414  	void EOLAnnotationClearAll();
415  	bool AddWatcher(DocWatcher *watcher, void *userData);
416  	bool RemoveWatcher(DocWatcher *watcher, void *userData) noexcept;
417  	CharacterClass WordCharacterClass(unsigned int ch) const;
418  	bool IsWordPartSeparator(unsigned int ch) const;
419  	Sci::Position WordPartLeft(Sci::Position pos) const;
420  	Sci::Position WordPartRight(Sci::Position pos) const;
421  	Sci::Position ExtendStyleRange(Sci::Position pos, int delta, bool singleLine) noexcept;
422  	bool IsWhiteLine(Sci::Line line) const;
423  	Sci::Position ParaUp(Sci::Position pos) const;
424  	Sci::Position ParaDown(Sci::Position pos) const;
425  	int IndentSize() const noexcept { return actualIndentInChars; }
426  	Sci::Position BraceMatch(Sci::Position position, Sci::Position maxReStyle, Sci::Position startPos, bool useStartPos) noexcept;
427  private:
428  	void NotifyModifyAttempt();
429  	void NotifySavePoint(bool atSavePoint);
430  	void NotifyModified(DocModification mh);
431  };
432  class UndoGroup {
433  	Document *pdoc;
434  	bool groupNeeded;
435  public:
436  	UndoGroup(Document *pdoc_, bool groupNeeded_=true) :
437  		pdoc(pdoc_), groupNeeded(groupNeeded_) {
438  		if (groupNeeded) {
439  			pdoc-&gt;BeginUndoAction();
440  		}
441  	}
442  	UndoGroup(const UndoGroup &amp;) = delete;
443  	UndoGroup(UndoGroup &amp;&amp;) = delete;
444  	void operator=(const UndoGroup &amp;) = delete;
445  	UndoGroup &amp;operator=(UndoGroup &amp;&amp;) = delete;
446  	~UndoGroup() {
447  		if (groupNeeded) {
448  			pdoc-&gt;EndUndoAction();
449  		}
450  	}
451  	bool Needed() const noexcept {
452  		return groupNeeded;
453  	}
454  };
455  class DocModification {
456  public:
457  	Scintilla::ModificationFlags modificationType;
458  	Sci::Position position;
459  	Sci::Position length;
460  	Sci::Line linesAdded;	&amp;bsol;**&lt; Negative if lines deleted. */
461  	const char *text;	&amp;bsol;**&lt; Only valid for changes to text, not for changes to style. */
462  	Sci::Line line;
463  	Scintilla::FoldLevel foldLevelNow;
464  	Scintilla::FoldLevel foldLevelPrev;
465  	Sci::Line annotationLinesAdded;
466  	Sci::Position token;
467  	DocModification(Scintilla::ModificationFlags modificationType_, Sci::Position position_=0, Sci::Position length_=0,
468  		Sci::Line linesAdded_=0, const char *text_=nullptr, Sci::Line line_=0) noexcept :
469  		modificationType(modificationType_),
470  		position(position_),
471  		length(length_),
472  		linesAdded(linesAdded_),
473  		text(text_),
474  		line(line_),
475  		foldLevelNow(Scintilla::FoldLevel::None),
476  		foldLevelPrev(Scintilla::FoldLevel::None),
477  		annotationLinesAdded(0),
478  		token(0) {}
479  	DocModification(Scintilla::ModificationFlags modificationType_, const Action &amp;act, Sci::Line linesAdded_=0) noexcept :
480  		modificationType(modificationType_),
481  		position(act.position),
482  		length(act.lenData),
483  		linesAdded(linesAdded_),
484  		text(act.data.get()),
485  		line(0),
486  		foldLevelNow(Scintilla::FoldLevel::None),
487  		foldLevelPrev(Scintilla::FoldLevel::None),
488  		annotationLinesAdded(0),
489  		token(0) {}
490  };
491  class DocWatcher {
492  public:
493  	virtual ~DocWatcher() {}
494  	virtual void NotifyModifyAttempt(Document *doc, void *userData) = 0;
495  	virtual void NotifySavePoint(Document *doc, void *userData, bool atSavePoint) = 0;
496  	virtual void NotifyModified(Document *doc, DocModification mh, void *userData) = 0;
497  	virtual void NotifyDeleted(Document *doc, void *userData) noexcept = 0;
498  	virtual void NotifyStyleNeeded(Document *doc, void *userData, Sci::Position endPos) = 0;
499  	virtual void NotifyErrorOccurred(Document *doc, void *userData, Scintilla::Status status) = 0;
500  };
501  }
502  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-demo-TNodeEdgeNet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Document.h</div>
                </div>
                <div class="column column_space"><pre><code>187    int SrcNId;
188    int DstNId;
189    int EdgeDat;
190    int Value;
191    bool ok;
192    Net = TNodeEdgeNet&lt;TInt, TInt&gt;::New();
</pre></code></div>
                <div class="column column_space"><pre><code>195  	int styleClock;
196  	int enteredModification;
197  	int enteredStyling;
198  	int enteredReadOnlyCount;
199  	bool insertionSet;
200  	std::string insertion;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    