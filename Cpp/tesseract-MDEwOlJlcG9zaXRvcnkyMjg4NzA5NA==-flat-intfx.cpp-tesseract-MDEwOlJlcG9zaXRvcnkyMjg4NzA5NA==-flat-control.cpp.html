
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.5581287633163505%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intfx.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include "intfx.h"
3  #include "classify.h"
4  #include "intmatcher.h"
5  #include "linlsq.h"
6  #include "normalis.h"
7  #include "statistc.h"
8  #include "trainingsample.h"
9  #include "helpers.h"
10  #include <allheaders.h>
11  #include <cmath> 
12  #include <mutex> 
13  namespace tesseract {
14  static float cos_table[INT_CHAR_NORM_RANGE];
15  static float sin_table[INT_CHAR_NORM_RANGE];
16  void InitIntegerFX() {
17    static std::mutex atan_table_mutex;
18    static bool atan_table_init = false;
19    std::lock_guard<std::mutex> guard(atan_table_mutex);
20    if (!atan_table_init) {
21      for (int i = 0; i < INT_CHAR_NORM_RANGE; ++i) {
22        cos_table[i] = cos(i * 2 * M_PI / INT_CHAR_NORM_RANGE + M_PI);
23        sin_table[i] = sin(i * 2 * M_PI / INT_CHAR_NORM_RANGE + M_PI);
24      }
25      atan_table_init = true;
26    }
27  }
28  FCOORD FeatureDirection(uint8_t theta) {
29    return FCOORD(cos_table[theta], sin_table[theta]);
30  }
31  TrainingSample *BlobToTrainingSample(const TBLOB &blob, bool nonlinear_norm,
32                                       INT_FX_RESULT_STRUCT *fx_info,
33                                       std::vector<INT_FEATURE_STRUCT> *bl_features) {
34    std::vector<INT_FEATURE_STRUCT> cn_features;
35    Classify::ExtractFeatures(blob, nonlinear_norm, bl_features, &cn_features, fx_info, nullptr);
36    TBOX box = blob.bounding_box();
37    TrainingSample *sample = nullptr;
38    int num_features = fx_info->NumCN;
39    if (num_features > 0) {
40      sample = TrainingSample::CopyFromFeatures(*fx_info, box, &cn_features[0], num_features);
41    }
42    if (sample != nullptr) {
43      TPOINT topleft, botright;
44      topleft.x = box.left();
45      topleft.y = box.top();
46      botright.x = box.right();
47      botright.y = box.bottom();
48      TPOINT original_topleft, original_botright;
49      blob.denorm().DenormTransform(nullptr, topleft, &original_topleft);
50      blob.denorm().DenormTransform(nullptr, botright, &original_botright);
51      sample->set_bounding_box(
52          TBOX(original_topleft.x, original_botright.y, original_botright.x, original_topleft.y));
53    }
54    return sample;
55  }
56  void Classify::SetupBLCNDenorms(const TBLOB &blob, bool nonlinear_norm, DENORM *bl_denorm,
57                                  DENORM *cn_denorm, INT_FX_RESULT_STRUCT *fx_info) {
58    FCOORD center, second_moments;
59    int length = blob.ComputeMoments(&center, &second_moments);
60    if (fx_info != nullptr) {
61      fx_info->Length = length;
62      fx_info->Rx = IntCastRounded(second_moments.y());
63      fx_info->Ry = IntCastRounded(second_moments.x());
64      fx_info->Xmean = IntCastRounded(center.x());
65      fx_info->Ymean = IntCastRounded(center.y());
66    }
67    bl_denorm->SetupNormalization(nullptr, nullptr, &blob.denorm(), center.x(), 128.0f, 1.0f, 1.0f,
68                                  128.0f, 128.0f);
69    if (nonlinear_norm) {
70      std::vector<std::vector<int>> x_coords;
71      std::vector<std::vector<int>> y_coords;
72      TBOX box;
73      blob.GetPreciseBoundingBox(&box);
74      box.pad(1, 1);
75      blob.GetEdgeCoords(box, x_coords, y_coords);
76      cn_denorm->SetupNonLinear(&blob.denorm(), box, UINT8_MAX, UINT8_MAX, 0.0f, 0.0f, x_coords,
77                                y_coords);
78    } else {
79      cn_denorm->SetupNormalization(nullptr, nullptr, &blob.denorm(), center.x(), center.y(),
80                                    51.2f / second_moments.x(), 51.2f / second_moments.y(), 128.0f,
81                                    128.0f);
82    }
83  }
84  static uint8_t NormalizeDirection(uint8_t dir, const FCOORD &unnormed_pos, const DENORM &denorm,
85                                    const DENORM *root_denorm) {
86    FCOORD unnormed_end;
87    unnormed_end.from_direction(dir);
88    unnormed_end += unnormed_pos;
89    FCOORD normed_pos, normed_end;
90    denorm.NormTransform(root_denorm, unnormed_pos, &normed_pos);
91    denorm.NormTransform(root_denorm, unnormed_end, &normed_end);
92    normed_end -= normed_pos;
93    return normed_end.to_direction();
94  }
95  static FCOORD MeanDirectionVector(const LLSQ &point_diffs, const LLSQ &dirs, const FCOORD &start_pt,
96                                    const FCOORD &end_pt) {
97    FCOORD fit_vector;
98    if (dirs.count() > 0) {
99      FCOORD mean_pt = dirs.mean_point();
100      double mean_dir = 0.0;
101      if (dirs.x_variance() <= dirs.y_variance()) {
102        mean_dir = mean_pt.x();
103      } else {
104        mean_dir = mean_pt.y() + 128;
105      }
106      fit_vector.from_direction(Modulo(IntCastRounded(mean_dir), 256));
107    } else {
108      FCOORD feature_dir(end_pt - start_pt);
109      fit_vector = point_diffs.vector_fit();
110      if (fit_vector.x() == 0.0f && fit_vector.y() == 0.0f) {
111        fit_vector = feature_dir;
112      } else {
113        FCOORD fit_vector2 = !fit_vector;
114        if (fit_vector % feature_dir < 0.0) {
115          fit_vector = -fit_vector;
116        }
117        if (fit_vector2 % feature_dir < 0.0) {
118          fit_vector2 = -fit_vector2;
119        }
120        if (fit_vector2 % feature_dir > fit_vector % feature_dir) {
121          fit_vector = fit_vector2;
122        }
123      }
124    }
125    return fit_vector;
126  }
127  static int ComputeFeatures(const FCOORD &start_pt, const FCOORD &end_pt, double feature_length,
128                             std::vector<INT_FEATURE_STRUCT> *features) {
129    FCOORD feature_vector(end_pt - start_pt);
130    if (feature_vector.x() == 0.0f && feature_vector.y() == 0.0f) {
131      return 0;
132    }
133    uint8_t theta = feature_vector.to_direction();
134    double target_length = feature_vector.length();
135    int num_features = IntCastRounded(target_length / feature_length);
136    if (num_features == 0) {
137      return 0;
138    }
139    double lambda_step = 1.0 / num_features;
140    double lambda = lambda_step / 2.0;
141    for (int f = 0; f < num_features; ++f, lambda += lambda_step) {
142      FCOORD feature_pt(start_pt);
143      feature_pt += feature_vector * lambda;
144      INT_FEATURE_STRUCT feature(feature_pt, theta);
145      features->push_back(feature);
146    }
147    return num_features;
148  }
149  static int GatherPoints(const C_OUTLINE *outline, double feature_length, const DENORM &denorm,
150                          const DENORM *root_denorm, int start_index, int end_index, ICOORD *pos,
151                          FCOORD *pos_normed, LLSQ *points, LLSQ *dirs) {
152    int step_length = outline->pathlength();
153    ICOORD step = outline->step(start_index % step_length);
154    FCOORD prev_normed;
155    points->clear();
156    dirs->clear();
157    int num_points = 0;
158    int index;
159    for (index = start_index; index <= end_index; ++index, *pos += step) {
160      step = outline->step(index % step_length);
161      int edge_weight = outline->edge_strength_at_index(index % step_length);
162      if (edge_weight == 0) {
163        continue;
164      }
165      FCOORD f_pos = outline->sub_pixel_pos_at_index(*pos, index % step_length);
166      denorm.NormTransform(root_denorm, f_pos, pos_normed);
167      if (num_points == 0) {
168        prev_normed = *pos_normed;
169      } else {
170        FCOORD offset = *pos_normed - prev_normed;
171        float length = offset.length();
172        if (length > feature_length) {
173          return index;
174        }
175      }
176      points->add(pos_normed->x(), pos_normed->y(), edge_weight);
177      int direction = outline->direction_at_index(index % step_length);
178      if (direction >= 0) {
179        direction = NormalizeDirection(direction, f_pos, denorm, root_denorm);
180        dirs->add(direction, Modulo(direction + 128, 256));
181      }
182      ++num_points;
183    }
184    return index;
185  }
186  static void ExtractFeaturesFromRun(const EDGEPT *startpt, const EDGEPT *lastpt,
187                                     const DENORM &denorm, double feature_length, bool force_poly,
188                                     std::vector<INT_FEATURE_STRUCT> *features) {
189    const EDGEPT *endpt = lastpt->next;
190    const C_OUTLINE *outline = startpt->src_outline;
191    if (outline != nullptr && !force_poly) {
192      const DENORM *root_denorm = denorm.RootDenorm();
193      int total_features = 0;
194      int step_length = outline->pathlength();
195      int start_index = startpt->start_step;
196      ICOORD pos = outline->position_at_index(start_index);
197      int end_index = lastpt->start_step + lastpt->step_count;
198      if (end_index <= start_index) {
199        end_index += step_length;
200      }
201      LLSQ prev_points;
202      LLSQ prev_dirs;
203      FCOORD prev_normed_pos = outline->sub_pixel_pos_at_index(pos, start_index);
204      denorm.NormTransform(root_denorm, prev_normed_pos, &prev_normed_pos);
205      LLSQ points;
206      LLSQ dirs;
207      FCOORD normed_pos(0.0f, 0.0f);
<span onclick='openModal()' class='match'>208      int index = GatherPoints(outline, feature_length, denorm, root_denorm, start_index, end_index,
209                               &pos, &normed_pos, &points, &dirs);
210      while (index <= end_index) {
211        LLSQ next_points;
212        LLSQ next_dirs;
213        FCOORD next_normed_pos(0.0f, 0.0f);
214        index = GatherPoints(outline, feature_length, denorm, root_denorm, index, end_index, &pos,
215                             &next_normed_pos, &next_points, &next_dirs);
216        LLSQ sum_points(prev_points);
217        LLSQ sum_dirs(dirs);
218        sum_points.add(points);
219        sum_points.add(next_points);
220        sum_dirs.add(next_dirs);
221        bool made_features = false;
222        if (sum_points.count() > 0) {
223          FCOORD fit_pt = sum_points.mean_point();
224          FCOORD fit_vector = MeanDirectionVector(sum_points, sum_dirs, prev_normed_pos, normed_pos);
</span>225          FCOORD start_pos = prev_normed_pos.nearest_pt_on_line(fit_pt, fit_vector);
226          FCOORD end_pos = normed_pos.nearest_pt_on_line(fit_pt, fit_vector);
227          if (total_features == 0 && startpt != endpt) {
228            FCOORD poly_pos(startpt->pos.x, startpt->pos.y);
229            denorm.LocalNormTransform(poly_pos, &start_pos);
230          }
231          if (index > end_index && startpt != endpt) {
232            FCOORD poly_pos(endpt->pos.x, endpt->pos.y);
233            denorm.LocalNormTransform(poly_pos, &end_pos);
234          }
235          int num_features = ComputeFeatures(start_pos, end_pos, feature_length, features);
236          if (num_features > 0) {
237            prev_points = points;
238            prev_dirs = dirs;
239            prev_normed_pos = normed_pos;
240            points = next_points;
241            dirs = next_dirs;
242            made_features = true;
243            total_features += num_features;
244          }
245          normed_pos = next_normed_pos;
246        }
247        if (!made_features) {
248          points.add(next_points);
249          dirs.add(next_dirs);
250        }
251      }
252    } else {
253      const EDGEPT *pt = startpt;
254      do {
255        FCOORD start_pos(pt->pos.x, pt->pos.y);
256        FCOORD end_pos(pt->next->pos.x, pt->next->pos.y);
257        denorm.LocalNormTransform(start_pos, &start_pos);
258        denorm.LocalNormTransform(end_pos, &end_pos);
259        ComputeFeatures(start_pos, end_pos, feature_length, features);
260      } while ((pt = pt->next) != endpt);
261    }
262  }
263  void Classify::ExtractFeatures(const TBLOB &blob, bool nonlinear_norm,
264                                 std::vector<INT_FEATURE_STRUCT> *bl_features,
265                                 std::vector<INT_FEATURE_STRUCT> *cn_features,
266                                 INT_FX_RESULT_STRUCT *results,
267                                 std::vector<int> *outline_cn_counts) {
268    DENORM bl_denorm, cn_denorm;
269    tesseract::Classify::SetupBLCNDenorms(blob, nonlinear_norm, &bl_denorm, &cn_denorm, results);
270    if (outline_cn_counts != nullptr) {
271      outline_cn_counts->clear();
272    }
273    for (TESSLINE *ol = blob.outlines; ol != nullptr; ol = ol->next) {
274      EDGEPT *loop_pt = ol->FindBestStartPt();
275      EDGEPT *pt = loop_pt;
276      if (pt == nullptr) {
277        continue;
278      }
279      do {
280        if (pt->IsHidden()) {
281          continue;
282        }
283        EDGEPT *last_pt = pt;
284        do {
285          last_pt = last_pt->next;
286        } while (last_pt != loop_pt && !last_pt->IsHidden() &&
287                 last_pt->src_outline == pt->src_outline);
288        last_pt = last_pt->prev;
289        ExtractFeaturesFromRun(pt, last_pt, bl_denorm, kStandardFeatureLength, true, bl_features);
290        ExtractFeaturesFromRun(pt, last_pt, cn_denorm, kStandardFeatureLength, false, cn_features);
291        pt = last_pt;
292      } while ((pt = pt->next) != loop_pt);
293      if (outline_cn_counts != nullptr) {
294        outline_cn_counts->push_back(cn_features->size());
295      }
296    }
297    results->NumBL = bl_features->size();
298    results->NumCN = cn_features->size();
299    results->YBottom = blob.bounding_box().bottom();
300    results->YTop = blob.bounding_box().top();
301    results->Width = blob.bounding_box().width();
302  }
303  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-control.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <cctype>
5  #include <cmath>
6  #include <cstdint> 
7  #include <cstdio>  
8  #include <ctime>   
9  #include "control.h"
10  #ifndef DISABLED_LEGACY_ENGINE
11  #  include "docqual.h"
12  #  include "drawfx.h"
13  #  include "fixspace.h"
14  #endif
15  #include <tesseract/ocrclass.h>
16  #include "lstmrecognizer.h"
17  #include "output.h"
18  #include "pageres.h" 
19  #ifndef DISABLED_LEGACY_ENGINE
20  #  include "reject.h"
21  #endif
22  #include "sorthelper.h"
23  #include "tesseractclass.h"
24  #include "tessvars.h"
25  #include "werdit.h"
26  const char *const kBackUpConfigFile = "tempconfigdata.config";
27  #ifndef DISABLED_LEGACY_ENGINE
28  const double kMinRefitXHeightFraction = 0.5;
29  #endif 
30  namespace tesseract {
31  void Tesseract::recog_pseudo_word(PAGE_RES *page_res, TBOX &selection_box) {
32    PAGE_RES_IT *it = make_pseudo_word(page_res, selection_box);
33    if (it != nullptr) {
34      recog_interactive(it);
35      it->DeleteCurrentWord();
36      delete it;
37    }
38  }
39  bool Tesseract::recog_interactive(PAGE_RES_IT *pr_it) {
40    WordData word_data(*pr_it);
41    SetupWordPassN(2, &word_data);
42    if (lstm_recognizer_ == nullptr) {
43  #ifndef DISABLED_LEGACY_ENGINE
44      classify_word_and_language(2, pr_it, &word_data);
45  #endif 
46    } else {
47      classify_word_and_language(1, pr_it, &word_data);
48    }
49  #ifndef DISABLED_LEGACY_ENGINE
50    if (tessedit_debug_quality_metrics) {
51      int16_t char_qual;
52      int16_t good_char_qual;
53      WERD_RES *word_res = pr_it->word();
54      word_char_quality(word_res, &char_qual, &good_char_qual);
55      tprintf(
56          "\n%d chars;  word_blob_quality: %d;  outline_errs: %d; "
57          "char_quality: %d; good_char_quality: %d\n",
58          word_res->reject_map.length(), word_blob_quality(word_res), word_outline_errs(word_res),
59          char_qual, good_char_qual);
60    }
61  #endif 
62    return true;
63  }
64  bool Tesseract::ProcessTargetWord(const TBOX &word_box, const TBOX &target_word_box,
65                                    const char *word_config, int pass) {
66    if (word_config != nullptr) {
67      if (word_box.major_overlap(target_word_box)) {
68        if (backup_config_file_ == nullptr) {
69          backup_config_file_ = kBackUpConfigFile;
70          FILE *config_fp = fopen(backup_config_file_, "wb");
71          if (config_fp == nullptr) {
72            tprintf("Error, failed to open file \"%s\"\n", backup_config_file_);
73          } else {
74            ParamUtils::PrintParams(config_fp, params());
75            fclose(config_fp);
76          }
77          ParamUtils::ReadParamsFile(word_config, SET_PARAM_CONSTRAINT_DEBUG_ONLY, params());
78        }
79      } else {
80        if (backup_config_file_ != nullptr) {
81          ParamUtils::ReadParamsFile(backup_config_file_, SET_PARAM_CONSTRAINT_DEBUG_ONLY, params());
82          backup_config_file_ = nullptr;
83        }
84      }
85    } else if (pass > 1 && !word_box.major_overlap(target_word_box)) {
86      return false;
87    }
88    return true;
89  }
90  void Tesseract::SetupAllWordsPassN(int pass_n, const TBOX *target_word_box, const char *word_config,
91                                     PAGE_RES *page_res, std::vector<WordData> *words) {
92    PAGE_RES_IT page_res_it(page_res);
93    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
94      if (target_word_box == nullptr || ProcessTargetWord(page_res_it.word()->word->bounding_box(),
95                                                          *target_word_box, word_config, 1)) {
96        words->push_back(WordData(page_res_it));
97      }
98    }
99    for (unsigned w = 0; w < words->size(); ++w) {
100      SetupWordPassN(pass_n, &(*words)[w]);
101      if (w > 0) {
102        (*words)[w].prev_word = &(*words)[w - 1];
103      }
104    }
105  }
106  void Tesseract::SetupWordPassN(int pass_n, WordData *word) {
107    if (pass_n == 1 || !word->word->done) {
108      if (pass_n == 1) {
109        word->word->SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode,
110                                        nullptr, classify_bln_numeric_mode, textord_use_cjk_fp_model,
111                                        poly_allow_detailed_fx, word->row, word->block);
112      } else if (pass_n == 2) {
113        word->word->caps_height = 0.0;
114        if (word->word->x_height == 0.0f) {
115          word->word->x_height = word->row->x_height();
116        }
117      }
118      word->lang_words.truncate(0);
119      for (unsigned s = 0; s <= sub_langs_.size(); ++s) {
120        Tesseract *lang_t = s < sub_langs_.size() ? sub_langs_[s] : this;
121        auto *word_res = new WERD_RES;
122        word_res->InitForRetryRecognition(*word->word);
123        word->lang_words.push_back(word_res);
124        if (pass_n == 1 || lang_t->tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
125          word_res->SetupForRecognition(
126              lang_t->unicharset, lang_t, BestPix(), lang_t->tessedit_ocr_engine_mode, nullptr,
127              lang_t->classify_bln_numeric_mode, lang_t->textord_use_cjk_fp_model,
128              lang_t->poly_allow_detailed_fx, word->row, word->block);
129        }
130      }
131    }
132  }
133  bool Tesseract::RecogAllWordsPassN(int pass_n, ETEXT_DESC *monitor, PAGE_RES_IT *pr_it,
134                                     std::vector<WordData> *words) {
135    pr_it->restart_page();
136    for (unsigned w = 0; w < words->size(); ++w) {
137      WordData *word = &(*words)[w];
138      if (w > 0) {
139        word->prev_word = &(*words)[w - 1];
140      }
141      if (monitor != nullptr) {
142        monitor->ocr_alive = true;
143        if (pass_n == 1) {
144          monitor->progress = 70 * w / words->size();
145        } else {
146          monitor->progress = 70 + 30 * w / words->size();
147        }
148        if (monitor->progress_callback2 != nullptr) {
149          TBOX box = pr_it->word()->word->bounding_box();
150          (*monitor->progress_callback2)(monitor, box.left(), box.right(), box.top(), box.bottom());
151        }
152        if (monitor->deadline_exceeded() ||
153            (monitor->cancel != nullptr && (*monitor->cancel)(monitor->cancel_this, words->size()))) {
154          for (; w < words->size(); ++w) {
155            (*words)[w].word->SetupFake(unicharset);
156          }
157          return false;
158        }
159      }
160      if (word->word->tess_failed) {
161        unsigned s;
162        for (s = 0; s < word->lang_words.size() && word->lang_words[s]->tess_failed; ++s) {
163        }
164        if (s > word->lang_words.size()) {
165          continue;
166        }
167      }
168      while (pr_it->word() != nullptr && pr_it->word() != word->word) {
169        pr_it->forward();
170      }
171      ASSERT_HOST(pr_it->word() != nullptr);
172      bool make_next_word_fuzzy = false;
173  #ifndef DISABLED_LEGACY_ENGINE
174      if (!AnyLSTMLang() && ReassignDiacritics(pass_n, pr_it, &make_next_word_fuzzy)) {
175        SetupWordPassN(pass_n, word);
176      }
177  #endif 
178      classify_word_and_language(pass_n, pr_it, word);
179      if (tessedit_dump_choices || debug_noise_removal) {
180        tprintf("Pass%d: %s [%s]\n", pass_n, word->word->best_choice->unichar_string().c_str(),
181                word->word->best_choice->debug_string().c_str());
182      }
183      pr_it->forward();
184      if (make_next_word_fuzzy && pr_it->word() != nullptr) {
185        pr_it->MakeCurrentWordFuzzy();
186      }
187    }
188    return true;
189  }
190  bool Tesseract::recog_all_words(PAGE_RES *page_res, ETEXT_DESC *monitor,
191                                  const TBOX *target_word_box, const char *word_config,
192                                  int dopasses) {
193    PAGE_RES_IT page_res_it(page_res);
194    if (tessedit_minimal_rej_pass1) {
195      tessedit_test_adaption.set_value(true);
196      tessedit_minimal_rejection.set_value(true);
197    }
198    if (dopasses == 0 || dopasses == 1) {
199      page_res_it.restart_page();
200  #ifndef DISABLED_LEGACY_ENGINE
201      if (AdaptiveClassifierIsFull()) {
202        SwitchAdaptiveClassifier();
203      } else if (!AdaptiveClassifierIsEmpty()) {
204        StartBackupAdaptiveClassifier();
205      }
206      for (auto &lang : sub_langs_) {
207        if (lang->AdaptiveClassifierIsFull()) {
208          lang->SwitchAdaptiveClassifier();
209        } else if (!lang->AdaptiveClassifierIsEmpty()) {
210          lang->StartBackupAdaptiveClassifier();
211        }
212      }
213  #endif 
214      std::vector<WordData> words;
215      SetupAllWordsPassN(1, target_word_box, word_config, page_res, &words);
216  #ifndef DISABLED_LEGACY_ENGINE
217      if (tessedit_parallelize) {
218        PrerecAllWordsPar(words);
219      }
220  #endif 
221      stats_.word_count = words.size();
222      stats_.dict_words = 0;
223      stats_.doc_blob_quality = 0;
224      stats_.doc_outline_errs = 0;
225      stats_.doc_char_quality = 0;
226      stats_.good_char_count = 0;
227      stats_.doc_good_char_quality = 0;
228      most_recently_used_ = this;
229      if (!RecogAllWordsPassN(1, monitor, &page_res_it, &words)) {
230        return false;
231      }
232      for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
233        if (page_res_it.word()->word->flag(W_REP_CHAR)) {
234          fix_rep_char(&page_res_it);
235          continue;
236        }
237        if (page_res_it.word()->best_choice->permuter() == USER_DAWG_PERM) {
238          ++(stats_.dict_words);
239        }
240        if (page_res_it.word()->blamer_bundle != nullptr &&
241            page_res_it.word()->blamer_bundle->misadaption_debug().length() > 0) {
242          page_res->misadaption_log.push_back(page_res_it.word()->blamer_bundle->misadaption_debug());
243        }
244      }
245    }
246    if (dopasses == 1) {
247      return true;
248    }
249  #ifndef DISABLED_LEGACY_ENGINE
250    if (tessedit_tess_adaption_mode != 0x0 && !tessedit_test_adaption && AnyTessLang()) {
251      page_res_it.restart_page();
252      std::vector<WordData> words;
253      SetupAllWordsPassN(2, target_word_box, word_config, page_res, &words);
254      if (tessedit_parallelize) {
255        PrerecAllWordsPar(words);
256      }
257      most_recently_used_ = this;
258      if (!RecogAllWordsPassN(2, monitor, &page_res_it, &words)) {
259        return false;
260      }
261    }
262    if (AnyTessLang() && !AnyLSTMLang()) {
263      if (!tessedit_test_adaption && tessedit_fix_fuzzy_spaces && !tessedit_word_for_word &&
264          !right_to_left()) {
265        fix_fuzzy_spaces(monitor, stats_.word_count, page_res);
266      }
267      if (tessedit_enable_dict_correction) {
268        dictionary_correction_pass(page_res);
269      }
270      if (tessedit_enable_bigram_correction) {
271        bigram_correction_pass(page_res);
272      }
273      rejection_passes(page_res, monitor, target_word_box, word_config);
274      font_recognition_pass(page_res);
275      blamer_pass(page_res);
276      script_pos_pass(page_res);
277    }
278  #endif 
279  #ifndef DISABLED_LEGACY_ENGINE
280    if ((dopasses == 0 || dopasses == 2) && (monitor || tessedit_write_unlv)) {
281      output_pass(page_res_it, target_word_box);
282    }
283  #endif 
284    const auto pageseg_mode = static_cast<PageSegMode>(static_cast<int>(tessedit_pageseg_mode));
285    textord_.CleanupSingleRowResult(pageseg_mode, page_res);
286    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
287      const WERD_RES *word = page_res_it.word();
288      const POLY_BLOCK *pb = page_res_it.block()->block != nullptr
289                                 ? page_res_it.block()->block->pdblk.poly_block()
290                                 : nullptr;
291      if (word->best_choice == nullptr || word->best_choice->empty() ||
292          (word->best_choice->IsAllSpaces() && (pb == nullptr || pb->IsText()))) {
293        page_res_it.DeleteCurrentWord();
294      }
295    }
296    if (monitor != nullptr) {
297      monitor->progress = 100;
298    }
299    return true;
300  }
301  #ifndef DISABLED_LEGACY_ENGINE
302  void Tesseract::bigram_correction_pass(PAGE_RES *page_res) {
303    PAGE_RES_IT word_it(page_res);
304    WERD_RES *w_prev = nullptr;
305    WERD_RES *w = word_it.word();
306    while (true) {
307      w_prev = w;
308      while (word_it.forward() != nullptr && (!word_it.word() || word_it.word()->part_of_combo)) {
309      }
310      if (!word_it.word()) {
311        break;
312      }
313      w = word_it.word();
314      if (!w || !w_prev || w->uch_set != w_prev->uch_set) {
315        continue;
316      }
317      if (w_prev->word->flag(W_REP_CHAR) || w->word->flag(W_REP_CHAR)) {
318        if (tessedit_bigram_debug) {
319          tprintf("Skipping because one of the words is W_REP_CHAR\n");
320        }
321        continue;
322      }
323      std::vector<WERD_CHOICE *> overrides_word1;
324      std::vector<WERD_CHOICE *> overrides_word2;
325      const auto orig_w1_str = w_prev->best_choice->unichar_string();
326      const auto orig_w2_str = w->best_choice->unichar_string();
327      WERD_CHOICE prev_best(w->uch_set);
328      {
329        int w1start, w1end;
330        w_prev->best_choice->GetNonSuperscriptSpan(&w1start, &w1end);
331        prev_best = w_prev->best_choice->shallow_copy(w1start, w1end);
332      }
333      WERD_CHOICE this_best(w->uch_set);
334      {
335        int w2start, w2end;
336        w->best_choice->GetNonSuperscriptSpan(&w2start, &w2end);
337        this_best = w->best_choice->shallow_copy(w2start, w2end);
338      }
339      if (w->tesseract->getDict().valid_bigram(prev_best, this_best)) {
340        if (tessedit_bigram_debug) {
341          tprintf("Top choice \"%s %s\" verified by bigram model.\n", orig_w1_str.c_str(),
342                  orig_w2_str.c_str());
343        }
344        continue;
345      }
346      if (tessedit_bigram_debug > 2) {
347        tprintf("Examining alt choices for \"%s %s\".\n", orig_w1_str.c_str(), orig_w2_str.c_str());
348      }
349      if (tessedit_bigram_debug > 1) {
350        if (!w_prev->best_choices.singleton()) {
351          w_prev->PrintBestChoices();
352        }
353        if (!w->best_choices.singleton()) {
354          w->PrintBestChoices();
355        }
356      }
357      float best_rating = 0.0;
358      int best_idx = 0;
359      WERD_CHOICE_IT prev_it(&w_prev->best_choices);
360      for (prev_it.mark_cycle_pt(); !prev_it.cycled_list(); prev_it.forward()) {
361        WERD_CHOICE *p1 = prev_it.data();
362        WERD_CHOICE strip1(w->uch_set);
363        {
364          int p1start, p1end;
365          p1->GetNonSuperscriptSpan(&p1start, &p1end);
366          strip1 = p1->shallow_copy(p1start, p1end);
367        }
368        WERD_CHOICE_IT w_it(&w->best_choices);
369        for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
370          WERD_CHOICE *p2 = w_it.data();
371          WERD_CHOICE strip2(w->uch_set);
372          {
373            int p2start, p2end;
374            p2->GetNonSuperscriptSpan(&p2start, &p2end);
375            strip2 = p2->shallow_copy(p2start, p2end);
376          }
377          if (w->tesseract->getDict().valid_bigram(strip1, strip2)) {
378            overrides_word1.push_back(p1);
379            overrides_word2.push_back(p2);
380            if (overrides_word1.size() == 1 || p1->rating() + p2->rating() < best_rating) {
381              best_rating = p1->rating() + p2->rating();
382              best_idx = overrides_word1.size() - 1;
383            }
384          }
385        }
386      }
387      if (!overrides_word1.empty()) {
388        if (EqualIgnoringCaseAndTerminalPunct(*w_prev->best_choice, *overrides_word1[best_idx]) &&
389            EqualIgnoringCaseAndTerminalPunct(*w->best_choice, *overrides_word2[best_idx])) {
390          if (tessedit_bigram_debug > 1) {
391            tprintf(
392                "Top choice \"%s %s\" verified (sans case) by bigram "
393                "model.\n",
394                orig_w1_str.c_str(), orig_w2_str.c_str());
395          }
396          continue;
397        }
398        const auto new_w1_str = overrides_word1[best_idx]->unichar_string();
399        const auto new_w2_str = overrides_word2[best_idx]->unichar_string();
400        if (new_w1_str != orig_w1_str) {
401          w_prev->ReplaceBestChoice(overrides_word1[best_idx]);
402        }
403        if (new_w2_str != orig_w2_str) {
404          w->ReplaceBestChoice(overrides_word2[best_idx]);
405        }
406        if (tessedit_bigram_debug > 0) {
407          std::string choices_description;
408          int num_bigram_choices = overrides_word1.size() * overrides_word2.size();
409          if (num_bigram_choices == 1) {
410            choices_description = "This was the unique bigram choice.";
411          } else {
412            if (tessedit_bigram_debug > 1) {
413              std::string bigrams_list;
414              const int kMaxChoicesToPrint = 20;
415              for (unsigned i = 0; i < overrides_word1.size() && i < kMaxChoicesToPrint; i++) {
416                if (i > 0) {
417                  bigrams_list += ", ";
418                }
419                WERD_CHOICE *p1 = overrides_word1[i];
420                WERD_CHOICE *p2 = overrides_word2[i];
421                bigrams_list += p1->unichar_string() + " " + p2->unichar_string();
422              }
423              choices_description = "There were many choices: {";
424              choices_description += bigrams_list;
425              choices_description += "}";
426            } else {
427              choices_description += "There were " + std::to_string(num_bigram_choices);
428              choices_description += " compatible bigrams.";
429            }
430          }
431          tprintf("Replaced \"%s %s\" with \"%s %s\" with bigram model. %s\n", orig_w1_str.c_str(),
432                  orig_w2_str.c_str(), new_w1_str.c_str(), new_w2_str.c_str(),
433                  choices_description.c_str());
434        }
435      }
436    }
437  }
438  void Tesseract::rejection_passes(PAGE_RES *page_res, ETEXT_DESC *monitor,
439                                   const TBOX *target_word_box, const char *word_config) {
440    PAGE_RES_IT page_res_it(page_res);
<span onclick='openModal()' class='match'>441    int word_index = 0;
442    while (!tessedit_test_adaption && page_res_it.word() != nullptr) {
443      WERD_RES *word = page_res_it.word();
444      word_index++;
445      if (monitor != nullptr) {
446        monitor->ocr_alive = true;
447        monitor->progress = 95 + 5 * word_index / stats_.word_count;
</span>448      }
449      if (word->rebuild_word == nullptr) {
450        page_res_it.forward();
451        continue;
452      }
453      check_debug_pt(word, 70);
454      if (target_word_box &&
455          !ProcessTargetWord(word->word->bounding_box(), *target_word_box, word_config, 4)) {
456        page_res_it.forward();
457        continue;
458      }
459      page_res_it.rej_stat_word();
460      const int chars_in_word = word->reject_map.length();
461      const int rejects_in_word = word->reject_map.reject_count();
462      const int blob_quality = word_blob_quality(word);
463      stats_.doc_blob_quality += blob_quality;
464      const int outline_errs = word_outline_errs(word);
465      stats_.doc_outline_errs += outline_errs;
466      int16_t all_char_quality;
467      int16_t accepted_all_char_quality;
468      word_char_quality(word, &all_char_quality, &accepted_all_char_quality);
469      stats_.doc_char_quality += all_char_quality;
470      const uint8_t permuter_type = word->best_choice->permuter();
471      if ((permuter_type == SYSTEM_DAWG_PERM) || (permuter_type == FREQ_DAWG_PERM) ||
472          (permuter_type == USER_DAWG_PERM)) {
473        stats_.good_char_count += chars_in_word - rejects_in_word;
474        stats_.doc_good_char_quality += accepted_all_char_quality;
475      }
476      check_debug_pt(word, 80);
477      if (tessedit_reject_bad_qual_wds && (blob_quality == 0) && (outline_errs >= chars_in_word)) {
478        word->reject_map.rej_word_bad_quality();
479      }
480      check_debug_pt(word, 90);
481      page_res_it.forward();
482    }
483    if (tessedit_debug_quality_metrics) {
484      tprintf(
485          "QUALITY: num_chs= %d  num_rejs= %d %5.3f blob_qual= %d %5.3f"
486          " outline_errs= %d %5.3f char_qual= %d %5.3f good_ch_qual= %d %5.3f\n",
487          page_res->char_count, page_res->rej_count,
488          page_res->rej_count / static_cast<float>(page_res->char_count), stats_.doc_blob_quality,
489          stats_.doc_blob_quality / static_cast<float>(page_res->char_count), stats_.doc_outline_errs,
490          stats_.doc_outline_errs / static_cast<float>(page_res->char_count), stats_.doc_char_quality,
491          stats_.doc_char_quality / static_cast<float>(page_res->char_count),
492          stats_.doc_good_char_quality,
493          (stats_.good_char_count > 0)
494              ? (stats_.doc_good_char_quality / static_cast<float>(stats_.good_char_count))
495              : 0.0);
496    }
497    bool good_quality_doc =
498        ((page_res->rej_count / static_cast<float>(page_res->char_count)) <= quality_rej_pc) &&
499        (stats_.doc_blob_quality / static_cast<float>(page_res->char_count) >= quality_blob_pc) &&
500        (stats_.doc_outline_errs / static_cast<float>(page_res->char_count) <= quality_outline_pc) &&
501        (stats_.doc_char_quality / static_cast<float>(page_res->char_count) >= quality_char_pc);
502    if (!tessedit_test_adaption) {
503      quality_based_rejection(page_res_it, good_quality_doc);
504    }
505  }
506  #endif 
507  void Tesseract::blamer_pass(PAGE_RES *page_res) {
508    if (!wordrec_run_blamer) {
509      return;
510    }
511    PAGE_RES_IT page_res_it(page_res);
512    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
513      WERD_RES *word = page_res_it.word();
514      BlamerBundle::LastChanceBlame(wordrec_debug_blamer, word);
515      page_res->blame_reasons[word->blamer_bundle->incorrect_result_reason()]++;
516    }
517    tprintf("Blame reasons:\n");
518    for (int bl = 0; bl < IRR_NUM_REASONS; ++bl) {
519      tprintf("%s %d\n", BlamerBundle::IncorrectReasonName(static_cast<IncorrectResultReason>(bl)),
520              page_res->blame_reasons[bl]);
521    }
522    if (page_res->misadaption_log.size() > 0) {
523      tprintf("Misadaption log:\n");
524      for (auto &log : page_res->misadaption_log) {
525        tprintf("%s\n", log.c_str());
526      }
527    }
528  }
529  void Tesseract::script_pos_pass(PAGE_RES *page_res) {
530    PAGE_RES_IT page_res_it(page_res);
531    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
532      WERD_RES *word = page_res_it.word();
533      if (word->word->flag(W_REP_CHAR)) {
534        page_res_it.forward();
535        continue;
536      }
537      const float x_height = page_res_it.block()->block->x_height();
538      float word_x_height = word->x_height;
539      if (word_x_height < word->best_choice->min_x_height() ||
540          word_x_height > word->best_choice->max_x_height()) {
541        word_x_height =
542            (word->best_choice->min_x_height() + word->best_choice->max_x_height()) / 2.0f;
543      }
544      const double small_cap_xheight = x_height * kXHeightCapRatio;
545      const double small_cap_delta = (x_height - small_cap_xheight) / 2.0;
546      if (word->uch_set->script_has_xheight() &&
547          small_cap_xheight - small_cap_delta <= word_x_height &&
548          word_x_height <= small_cap_xheight + small_cap_delta) {
549        int num_upper = 0;
550        int num_lower = 0;
551        for (unsigned i = 0; i < word->best_choice->length(); ++i) {
552          if (word->uch_set->get_isupper(word->best_choice->unichar_id(i))) {
553            ++num_upper;
554          } else if (word->uch_set->get_islower(word->best_choice->unichar_id(i))) {
555            ++num_lower;
556          }
557        }
558        if (num_upper > 0 && num_lower == 0) {
559          word->small_caps = true;
560        }
561      }
562      word->SetScriptPositions();
563    }
564  }
565  static void WordGap(const PointerVector<WERD_RES> &words, unsigned index, int *right, int *next_left) {
566    *right = -INT32_MAX;
567    *next_left = INT32_MAX;
568    if (index < words.size()) {
569      *right = words[index]->word->bounding_box().right();
570      if (index + 1 < words.size()) {
571        *next_left = words[index + 1]->word->bounding_box().left();
572      }
573    }
574  }
575  static void EvaluateWordSpan(const PointerVector<WERD_RES> &words, unsigned first_index, unsigned end_index,
576                               float *rating, float *certainty, bool *bad, bool *valid_permuter) {
577    if (end_index <= first_index) {
578      *bad = true;
579      *valid_permuter = false;
580    }
581    for (unsigned index = first_index; index < end_index && index < words.size(); ++index) {
582      WERD_CHOICE *choice = words[index]->best_choice;
583      if (choice == nullptr) {
584        *bad = true;
585      } else {
586        *rating += choice->rating();
587        *certainty = std::min(*certainty, choice->certainty());
588        if (!Dict::valid_word_permuter(choice->permuter(), false)) {
589          *valid_permuter = false;
590        }
591      }
592    }
593  }
594  static int SelectBestWords(double rating_ratio, double certainty_margin, bool debug,
595                             PointerVector<WERD_RES> *new_words,
596                             PointerVector<WERD_RES> *best_words) {
597    std::vector<WERD_RES *> out_words;
598    unsigned b = 0, n = 0;
599    int num_best = 0, num_new = 0;
600    while (b < best_words->size() || n < new_words->size()) {
601      auto start_b = b, start_n = n;
602      while (b < best_words->size() || n < new_words->size()) {
603        int b_right = -INT32_MAX;
604        int next_b_left = INT32_MAX;
605        WordGap(*best_words, b, &b_right, &next_b_left);
606        int n_right = -INT32_MAX;
607        int next_n_left = INT32_MAX;
608        WordGap(*new_words, n, &n_right, &next_n_left);
609        if (std::max(b_right, n_right) < std::min(next_b_left, next_n_left)) {
610          break;
611        }
612        if ((b_right < n_right && b < best_words->size()) || n == new_words->size()) {
613          ++b;
614        } else {
615          ++n;
616        }
617      }
618      float b_rating = 0.0f, n_rating = 0.0f;
619      float b_certainty = 0.0f, n_certainty = 0.0f;
620      bool b_bad = false, n_bad = false;
621      bool b_valid_permuter = true, n_valid_permuter = true;
622      const int end_b = b < best_words->size() ? b + 1 : b;
623      const int end_n = n < new_words->size() ? n + 1 : n;
624      EvaluateWordSpan(*best_words, start_b, end_b, &b_rating, &b_certainty, &b_bad,
625                       &b_valid_permuter);
626      EvaluateWordSpan(*new_words, start_n, end_n, &n_rating, &n_certainty, &n_bad,
627                       &n_valid_permuter);
628      bool new_better = false;
629      if (!n_bad && (b_bad || (n_certainty > b_certainty && n_rating < b_rating) ||
630                     (!b_valid_permuter && n_valid_permuter && n_rating < b_rating * rating_ratio &&
631                      n_certainty > b_certainty - certainty_margin))) {
632        for (int i = start_n; i < end_n; ++i) {
633          out_words.push_back((*new_words)[i]);
634          (*new_words)[i] = nullptr;
635          ++num_new;
636        }
637        new_better = true;
638      } else if (!b_bad) {
639        for (int i = start_b; i < end_b; ++i) {
640          out_words.push_back((*best_words)[i]);
641          (*best_words)[i] = nullptr;
642          ++num_best;
643        }
644      }
645      if (debug) {
646        tprintf(
647            "%d new words %s than %d old words: r: %g v %g c: %g v %g"
648            " valid dict: %d v %d\n",
649            end_n - start_n, new_better ? "better" : "worse", end_b - start_b, n_rating, b_rating,
650            n_certainty, b_certainty, n_valid_permuter, b_valid_permuter);
651      }
652      b = end_b;
653      n = end_n;
654    }
655    best_words->clear();
656    for (auto &out_word : out_words) {
657      best_words->push_back(out_word);
658    }
659    return num_new - num_best;
660  }
661  int Tesseract::RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
662                                   WERD_RES **in_word, PointerVector<WERD_RES> *best_words) {
663    if (debug) {
664      tprintf("Trying word using lang %s, oem %d\n", lang.c_str(),
665              static_cast<int>(tessedit_ocr_engine_mode));
666    }
667    PointerVector<WERD_RES> new_words;
668    (this->*recognizer)(word_data, in_word, &new_words);
669    if (new_words.empty()) {
670      new_words.push_back(*in_word);
671      *in_word = nullptr;
672    }
673    if (debug) {
674      for (unsigned i = 0; i < new_words.size(); ++i) {
675        new_words[i]->DebugTopChoice("Lang result");
676      }
677    }
678    return SelectBestWords(classify_max_rating_ratio, classify_max_certainty_margin, debug,
679                           &new_words, best_words);
680  }
681  static bool WordsAcceptable(const PointerVector<WERD_RES> &words) {
682    for (unsigned w = 0; w < words.size(); ++w) {
683      if (words[w]->tess_failed || !words[w]->tess_accepted) {
684        return false;
685      }
686    }
687    return true;
688  }
689  #ifndef DISABLED_LEGACY_ENGINE
690  bool Tesseract::ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy) {
691    *make_next_word_fuzzy = false;
692    WERD *real_word = pr_it->word()->word;
693    if (real_word->rej_cblob_list()->empty() || real_word->cblob_list()->empty() ||
694        real_word->rej_cblob_list()->length() > noise_maxperword) {
695      return false;
696    }
697    real_word->rej_cblob_list()->sort(&C_BLOB::SortByXMiddle);
698    std::vector<C_OUTLINE *> outlines;
699    real_word->GetNoiseOutlines(&outlines);
700    std::vector<bool> word_wanted;
701    std::vector<bool> overlapped_any_blob;
702    std::vector<C_BLOB *> target_blobs;
703    AssignDiacriticsToOverlappingBlobs(outlines, pass, real_word, pr_it, &word_wanted,
704                                       &overlapped_any_blob, &target_blobs);
705    std::vector<bool> wanted;
706    std::vector<C_BLOB *> wanted_blobs;
707    std::vector<C_OUTLINE *> wanted_outlines;
708    int num_overlapped = 0;
709    int num_overlapped_used = 0;
710    for (unsigned i = 0; i < overlapped_any_blob.size(); ++i) {
711      if (overlapped_any_blob[i]) {
712        ++num_overlapped;
713        if (word_wanted[i]) {
714          ++num_overlapped_used;
715        }
716        wanted.push_back(word_wanted[i]);
717        wanted_blobs.push_back(target_blobs[i]);
718        wanted_outlines.push_back(outlines[i]);
719        outlines[i] = nullptr;
720      }
721    }
722    real_word->AddSelectedOutlines(wanted, wanted_blobs, wanted_outlines, nullptr);
723    AssignDiacriticsToNewBlobs(outlines, pass, real_word, pr_it, &word_wanted, &target_blobs);
724    int non_overlapped = 0;
725    int non_overlapped_used = 0;
726    for (unsigned i = 0; i < word_wanted.size(); ++i) {
727      if (word_wanted[i]) {
728        ++non_overlapped_used;
729      }
730      if (outlines[i] != nullptr) {
731        ++non_overlapped_used;
732      }
733    }
734    if (debug_noise_removal) {
735      tprintf("Used %d/%d overlapped %d/%d non-overlaped diacritics on word:", num_overlapped_used,
736              num_overlapped, non_overlapped_used, non_overlapped);
737      real_word->bounding_box().print();
738    }
739    if (real_word->AddSelectedOutlines(word_wanted, target_blobs, outlines, make_next_word_fuzzy)) {
740      pr_it->MakeCurrentWordFuzzy();
741    }
742    return num_overlapped_used != 0 || non_overlapped_used != 0;
743  }
744  void Tesseract::AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines,
745                                                     int pass, WERD *real_word, PAGE_RES_IT *pr_it,
746                                                     std::vector<bool> *word_wanted,
747                                                     std::vector<bool> *overlapped_any_blob,
748                                                     std::vector<C_BLOB *> *target_blobs) {
749    std::vector<bool> blob_wanted;
750    word_wanted->clear();
751    word_wanted->resize(outlines.size());
752    overlapped_any_blob->clear();
753    overlapped_any_blob->resize(outlines.size());
754    target_blobs->clear();
755    target_blobs->resize(outlines.size());
756    C_BLOB_IT blob_it(real_word->cblob_list());
757    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
758      C_BLOB *blob = blob_it.data();
759      const TBOX blob_box = blob->bounding_box();
760      blob_wanted.clear();
761      blob_wanted.resize(outlines.size());
762      int num_blob_outlines = 0;
763      for (unsigned i = 0; i < outlines.size(); ++i) {
764        if (blob_box.major_x_overlap(outlines[i]->bounding_box()) && !(*word_wanted)[i]) {
765          blob_wanted[i] = true;
766          (*overlapped_any_blob)[i] = true;
767          ++num_blob_outlines;
768        }
769      }
770      if (debug_noise_removal) {
771        tprintf("%d noise outlines overlap blob at:", num_blob_outlines);
772        blob_box.print();
773      }
774      if (0 < num_blob_outlines && num_blob_outlines < noise_maxperblob) {
775        if (SelectGoodDiacriticOutlines(pass, noise_cert_basechar, pr_it, blob, outlines,
776                                        num_blob_outlines, &blob_wanted)) {
777          for (unsigned i = 0; i < blob_wanted.size(); ++i) {
778            if (blob_wanted[i]) {
779              (*word_wanted)[i] = true;
780              (*target_blobs)[i] = blob;
781            }
782          }
783        }
784      }
785    }
786  }
787  void Tesseract::AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
788                                             WERD *real_word, PAGE_RES_IT *pr_it,
789                                             std::vector<bool> *word_wanted,
790                                             std::vector<C_BLOB *> *target_blobs) {
791    std::vector<bool> blob_wanted;
792    word_wanted->clear();
793    word_wanted->resize(outlines.size());
794    target_blobs->clear();
795    target_blobs->resize(outlines.size());
796    for (unsigned i = 0; i < outlines.size(); ++i) {
797      if (outlines[i] == nullptr) {
798        continue;
799      }
800      blob_wanted.clear();
801      blob_wanted.resize(outlines.size());
802      int num_blob_outlines = 0;
803      TBOX total_ol_box(outlines[i]->bounding_box());
804      while (i < outlines.size() && outlines[i] != nullptr) {
805        blob_wanted[i] = true;
806        total_ol_box += outlines[i]->bounding_box();
807        ++i;
808        ++num_blob_outlines;
809      }
810      C_BLOB_IT blob_it(real_word->cblob_list());
811      while (!blob_it.at_last() &&
812             blob_it.data_relative(1)->bounding_box().left() <= total_ol_box.left()) {
813        blob_it.forward();
814      }
815      if (debug_noise_removal) {
816        tprintf("Num blobless outlines = %d\n", num_blob_outlines);
817      }
818      C_BLOB *left_blob = blob_it.data();
819      TBOX left_box = left_blob->bounding_box();
820      C_BLOB *right_blob = blob_it.at_last() ? nullptr : blob_it.data_relative(1);
821      if ((left_box.x_overlap(total_ol_box) || right_blob == nullptr ||
822           !right_blob->bounding_box().x_overlap(total_ol_box)) &&
823          SelectGoodDiacriticOutlines(pass, noise_cert_disjoint, pr_it, left_blob, outlines,
824                                      num_blob_outlines, &blob_wanted)) {
825        if (debug_noise_removal) {
826          tprintf("Added to left blob\n");
827        }
828        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
829          if (blob_wanted[j]) {
830            (*word_wanted)[j] = true;
831            (*target_blobs)[j] = left_blob;
832          }
833        }
834      } else if (right_blob != nullptr &&
835                 (!left_box.x_overlap(total_ol_box) ||
836                  right_blob->bounding_box().x_overlap(total_ol_box)) &&
837                 SelectGoodDiacriticOutlines(pass, noise_cert_disjoint, pr_it, right_blob, outlines,
838                                             num_blob_outlines, &blob_wanted)) {
839        if (debug_noise_removal) {
840          tprintf("Added to right blob\n");
841        }
842        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
843          if (blob_wanted[j]) {
844            (*word_wanted)[j] = true;
845            (*target_blobs)[j] = right_blob;
846          }
847        }
848      } else if (SelectGoodDiacriticOutlines(pass, noise_cert_punc, pr_it, nullptr, outlines,
849                                             num_blob_outlines, &blob_wanted)) {
850        if (debug_noise_removal) {
851          tprintf("Fitted between blobs\n");
852        }
853        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
854          if (blob_wanted[j]) {
855            (*word_wanted)[j] = true;
856            (*target_blobs)[j] = nullptr;
857          }
858        }
859      }
860    }
861  }
862  bool Tesseract::SelectGoodDiacriticOutlines(int pass, float certainty_threshold, PAGE_RES_IT *pr_it,
863                                              C_BLOB *blob,
864                                              const std::vector<C_OUTLINE *> &outlines,
865                                              int num_outlines, std::vector<bool> *ok_outlines) {
866    std::string best_str;
867    float target_cert = certainty_threshold;
868    if (blob != nullptr) {
869      float target_c2;
870      target_cert = ClassifyBlobAsWord(pass, pr_it, blob, best_str, &target_c2);
871      if (debug_noise_removal) {
872        tprintf("No Noise blob classified as %s=%g(%g) at:", best_str.c_str(), target_cert,
873                target_c2);
874        blob->bounding_box().print();
875      }
876      target_cert -= (target_cert - certainty_threshold) * noise_cert_factor;
877    }
878    std::vector<bool> test_outlines = *ok_outlines;
879    std::string all_str;
880    std::vector<bool> best_outlines = *ok_outlines;
881    float best_cert = ClassifyBlobPlusOutlines(test_outlines, outlines, pass, pr_it, blob, all_str);
882    if (debug_noise_removal) {
883      TBOX ol_box;
884      for (unsigned i = 0; i < test_outlines.size(); ++i) {
885        if (test_outlines[i]) {
886          ol_box += outlines[i]->bounding_box();
887        }
888      }
889      tprintf("All Noise blob classified as %s=%g, delta=%g at:", all_str.c_str(), best_cert,
890              best_cert - target_cert);
891      ol_box.print();
892    }
893    int best_index = 0; 
894    while (num_outlines > 1 && best_index >= 0 &&
895           (blob == nullptr || best_cert < target_cert || blob != nullptr)) {
896      best_index = -1;
897      for (unsigned i = 0; i < outlines.size(); ++i) {
898        if (test_outlines[i]) {
899          test_outlines[i] = false;
900          std::string str;
901          float cert = ClassifyBlobPlusOutlines(test_outlines, outlines, pass, pr_it, blob, str);
902          if (debug_noise_removal) {
903            TBOX ol_box;
904            for (unsigned j = 0; j < outlines.size(); ++j) {
905              if (test_outlines[j]) {
906                ol_box += outlines[j]->bounding_box();
907              }
908              tprintf("%c", test_outlines[j] ? 'T' : 'F');
909            }
910            tprintf(" blob classified as %s=%g, delta=%g) at:", str.c_str(), cert,
911                    cert - target_cert);
912            ol_box.print();
913          }
914          if (cert > best_cert) {
915            best_cert = cert;
916            best_index = i;
917            best_outlines = test_outlines;
918          }
919          test_outlines[i] = true;
920        }
921      }
922      if (best_index >= 0) {
923        test_outlines[best_index] = false;
924        --num_outlines;
925      }
926    }
927    if (best_cert >= target_cert) {
928      *ok_outlines = best_outlines;
929      if (debug_noise_removal) {
930        tprintf("%s noise combination ", blob ? "Adding" : "New");
931        for (auto &&best_outline : best_outlines) {
932          tprintf("%c", best_outline ? 'T' : 'F');
933        }
934        tprintf(" yields certainty %g, beating target of %g\n", best_cert, target_cert);
935      }
936      return true;
937    }
938    return false;
939  }
940  float Tesseract::ClassifyBlobPlusOutlines(const std::vector<bool> &ok_outlines,
941                                            const std::vector<C_OUTLINE *> &outlines, int pass_n,
942                                            PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str) {
943    C_OUTLINE_IT ol_it;
944    C_OUTLINE *first_to_keep = nullptr;
945    C_BLOB *local_blob = nullptr;
946    if (blob != nullptr) {
947      ol_it.set_to_list(blob->out_list());
948      first_to_keep = ol_it.data();
949    }
950    for (unsigned i = 0; i < ok_outlines.size(); ++i) {
951      if (ok_outlines[i]) {
952        if (blob == nullptr) {
953          local_blob = new C_BLOB(outlines[i]);
954          blob = local_blob;
955          ol_it.set_to_list(blob->out_list());
956        } else {
957          ol_it.add_before_stay_put(outlines[i]);
958        }
959      }
960    }
961    float c2;
962    float cert = ClassifyBlobAsWord(pass_n, pr_it, blob, best_str, &c2);
963    ol_it.move_to_first();
964    if (first_to_keep == nullptr) {
965      for (; !ol_it.empty(); ol_it.forward()) {
966        ol_it.extract();
967      }
968      delete local_blob;
969      cert = -c2;
970    } else {
971      for (; ol_it.data() != first_to_keep; ol_it.forward()) {
972        ol_it.extract();
973      }
974    }
975    return cert;
976  }
977  float Tesseract::ClassifyBlobAsWord(int pass_n, PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str,
978                                      float *c2) {
979    WERD *real_word = pr_it->word()->word;
980    WERD *word = real_word->ConstructFromSingleBlob(real_word->flag(W_BOL), real_word->flag(W_EOL),
981                                                    C_BLOB::deep_copy(blob));
982    WERD_RES *word_res = pr_it->InsertSimpleCloneWord(*pr_it->word(), word);
983    PAGE_RES_IT it(pr_it->page_res);
984    while (it.word() != word_res && it.word() != nullptr) {
985      it.forward();
986    }
987    ASSERT_HOST(it.word() == word_res);
988    WordData wd(it);
989    SetupWordPassN(1, &wd);
990    classify_word_and_language(pass_n, &it, &wd);
991    if (debug_noise_removal) {
992      if (wd.word->raw_choice != nullptr) {
993        tprintf("word xheight=%g, row=%g, range=[%g,%g]\n", word_res->x_height, wd.row->x_height(),
994                wd.word->raw_choice->min_x_height(), wd.word->raw_choice->max_x_height());
995      } else {
996        tprintf("Got word with null raw choice xheight=%g, row=%g\n", word_res->x_height,
997                wd.row->x_height());
998      }
999    }
1000    float cert = 0.0f;
1001    if (wd.word->raw_choice != nullptr) { 
1002      cert = wd.word->raw_choice->certainty();
1003      float rat = wd.word->raw_choice->rating();
1004      *c2 = rat > 0.0f ? cert * cert / rat : 0.0f;
1005      best_str = wd.word->raw_choice->unichar_string();
1006    } else {
1007      *c2 = 0.0f;
1008      best_str.clear();
1009    }
1010    it.DeleteCurrentWord();
1011    pr_it->ResetWordIterator();
1012    return cert;
1013  }
1014  #endif 
1015  void Tesseract::classify_word_and_language(int pass_n, PAGE_RES_IT *pr_it, WordData *word_data) {
1016  #ifdef DISABLED_LEGACY_ENGINE
1017    WordRecognizer recognizer = &Tesseract::classify_word_pass1;
1018  #else
1019    WordRecognizer recognizer =
1020        pass_n == 1 ? &Tesseract::classify_word_pass1 : &Tesseract::classify_word_pass2;
1021  #endif 
1022    PointerVector<WERD_RES> best_words;
1023    const WERD_RES *word = word_data->word;
1024    clock_t start_t = clock();
1025    const bool debug = classify_debug_level > 0 || multilang_debug_level > 0;
1026    if (debug) {
1027      tprintf("%s word with lang %s at:", word->done ? "Already done" : "Processing",
1028              most_recently_used_->lang.c_str());
1029      word->word->bounding_box().print();
1030    }
1031    if (word->done) {
1032      if (!word->tess_failed) {
1033        most_recently_used_ = word->tesseract;
1034      }
1035      return;
1036    }
1037    auto sub = sub_langs_.size();
1038    if (most_recently_used_ != this) {
1039      for (sub = 0; sub < sub_langs_.size() && most_recently_used_ != sub_langs_[sub]; ++sub) {
1040      }
1041    }
1042    most_recently_used_->RetryWithLanguage(*word_data, recognizer, debug, &word_data->lang_words[sub],
1043                                           &best_words);
1044    Tesseract *best_lang_tess = most_recently_used_;
1045    if (!WordsAcceptable(best_words)) {
1046      if (most_recently_used_ != this &&
1047          this->RetryWithLanguage(*word_data, recognizer, debug,
1048                                  &word_data->lang_words[sub_langs_.size()], &best_words) > 0) {
1049        best_lang_tess = this;
1050      }
1051      for (unsigned i = 0; !WordsAcceptable(best_words) && i < sub_langs_.size(); ++i) {
1052        if (most_recently_used_ != sub_langs_[i] &&
1053            sub_langs_[i]->RetryWithLanguage(*word_data, recognizer, debug, &word_data->lang_words[i],
1054                                             &best_words) > 0) {
1055          best_lang_tess = sub_langs_[i];
1056        }
1057      }
1058    }
1059    most_recently_used_ = best_lang_tess;
1060    if (!best_words.empty()) {
1061      if (best_words.size() == 1 && !best_words[0]->combination) {
1062        word_data->word->ConsumeWordResults(best_words[0]);
1063      } else {
1064        word_data->word = best_words.back();
1065        pr_it->ReplaceCurrentWord(&best_words);
1066      }
1067      ASSERT_HOST(word_data->word->box_word != nullptr);
1068    } else {
1069      tprintf("no best words!!\n");
1070    }
1071    clock_t ocr_t = clock();
1072    if (tessedit_timing_debug) {
1073      tprintf("%s (ocr took %.2f sec)\n", word_data->word->best_choice->unichar_string().c_str(),
1074              static_cast<double>(ocr_t - start_t) / CLOCKS_PER_SEC);
1075    }
1076  }
1077  void Tesseract::classify_word_pass1(const WordData &word_data, WERD_RES **in_word,
1078                                      PointerVector<WERD_RES> *out_words) {
1079    ROW *row = word_data.row;
1080    BLOCK *block = word_data.block;
1081    prev_word_best_choice_ =
1082        word_data.prev_word != nullptr ? word_data.prev_word->word->best_choice : nullptr;
1083  #ifdef DISABLED_LEGACY_ENGINE
1084    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1085  #else
1086    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY ||
1087        tessedit_ocr_engine_mode == OEM_TESSERACT_LSTM_COMBINED) {
1088  #endif 
1089      if (!(*in_word)->odd_size || tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1090        LSTMRecognizeWord(*block, row, *in_word, out_words);
1091        if (!out_words->empty()) {
1092          return; 
1093        }
1094      }
1095      if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1096        (*in_word)->SetupFake(lstm_recognizer_->GetUnicharset());
1097        return;
1098      }
1099  #ifndef DISABLED_LEGACY_ENGINE
1100      (*in_word)->SetupForRecognition(unicharset, this, BestPix(), OEM_TESSERACT_ONLY, nullptr,
1101                                      classify_bln_numeric_mode, textord_use_cjk_fp_model,
1102                                      poly_allow_detailed_fx, row, block);
1103  #endif 
1104    }
1105  #ifndef DISABLED_LEGACY_ENGINE
1106    WERD_RES *word = *in_word;
1107    match_word_pass_n(1, word, row, block);
1108    if (!word->tess_failed && !word->word->flag(W_REP_CHAR)) {
1109      word->tess_would_adapt = AdaptableWord(word);
1110      bool adapt_ok = word_adaptable(word, tessedit_tess_adaption_mode);
1111      if (adapt_ok) {
1112        word->BestChoiceToCorrectText();
1113        LearnWord(nullptr, word);
1114        if (word->blamer_bundle != nullptr) {
1115          word->blamer_bundle->SetMisAdaptionDebug(word->best_choice, wordrec_debug_blamer);
1116        }
1117      }
1118      if (tessedit_enable_doc_dict && !word->IsAmbiguous()) {
1119        tess_add_doc_word(word->best_choice);
1120      }
1121    }
1122  #endif 
1123  }
1124  void Tesseract::ReportXhtFixResult(bool accept_new_word, float new_x_ht, WERD_RES *word,
1125                                     WERD_RES *new_word) {
1126    tprintf("New XHT Match:%s = %s ", word->best_choice->unichar_string().c_str(),
1127            word->best_choice->debug_string().c_str());
1128    word->reject_map.print(debug_fp);
1129    tprintf(" -> %s = %s ", new_word->best_choice->unichar_string().c_str(),
1130            new_word->best_choice->debug_string().c_str());
1131    new_word->reject_map.print(debug_fp);
1132    tprintf(" %s->%s %s %s\n", word->guessed_x_ht ? "GUESS" : "CERT",
1133            new_word->guessed_x_ht ? "GUESS" : "CERT", new_x_ht > 0.1 ? "STILL DOUBT" : "OK",
1134            accept_new_word ? "ACCEPTED" : "");
1135  }
1136  #ifndef DISABLED_LEGACY_ENGINE
1137  bool Tesseract::TrainedXheightFix(WERD_RES *word, BLOCK *block, ROW *row) {
1138    int original_misfits = CountMisfitTops(word);
1139    if (original_misfits == 0) {
1140      return false;
1141    }
1142    float baseline_shift = 0.0f;
1143    float new_x_ht = ComputeCompatibleXheight(word, &baseline_shift);
1144    if (baseline_shift != 0.0f) {
1145      if (!TestNewNormalization(original_misfits, baseline_shift, word->x_height, word, block, row)) {
1146        return false;
1147      }
1148      original_misfits = CountMisfitTops(word);
1149      if (original_misfits > 0) {
1150        float new_baseline_shift;
1151        new_x_ht = ComputeCompatibleXheight(word, &new_baseline_shift);
1152        if (new_x_ht >= kMinRefitXHeightFraction * word->x_height) {
1153          TestNewNormalization(original_misfits, baseline_shift, new_x_ht, word, block, row);
1154        }
1155      }
1156      return true;
1157    } else if (new_x_ht >= kMinRefitXHeightFraction * word->x_height) {
1158      return TestNewNormalization(original_misfits, 0.0f, new_x_ht, word, block, row);
1159    } else {
1160      return false;
1161    }
1162  }
1163  bool Tesseract::TestNewNormalization(int original_misfits, float baseline_shift, float new_x_ht,
1164                                       WERD_RES *word, BLOCK *block, ROW *row) {
1165    bool accept_new_x_ht = false;
1166    WERD_RES new_x_ht_word(word->word);
1167    if (word->blamer_bundle != nullptr) {
1168      new_x_ht_word.blamer_bundle = new BlamerBundle();
1169      new_x_ht_word.blamer_bundle->CopyTruth(*(word->blamer_bundle));
1170    }
1171    new_x_ht_word.x_height = new_x_ht;
1172    new_x_ht_word.baseline_shift = baseline_shift;
1173    new_x_ht_word.caps_height = 0.0;
1174    new_x_ht_word.SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode, nullptr,
1175                                      classify_bln_numeric_mode, textord_use_cjk_fp_model,
1176                                      poly_allow_detailed_fx, row, block);
1177    match_word_pass_n(2, &new_x_ht_word, row, block);
1178    if (!new_x_ht_word.tess_failed) {
1179      int new_misfits = CountMisfitTops(&new_x_ht_word);
1180      if (debug_x_ht_level >= 1) {
1181        tprintf("Old misfits=%d with x-height %f, new=%d with x-height %f\n", original_misfits,
1182                word->x_height, new_misfits, new_x_ht);
1183        tprintf("Old rating= %f, certainty=%f, new=%f, %f\n", word->best_choice->rating(),
1184                word->best_choice->certainty(), new_x_ht_word.best_choice->rating(),
1185                new_x_ht_word.best_choice->certainty());
1186      }
1187      accept_new_x_ht = new_misfits < original_misfits &&
1188                        (new_x_ht_word.best_choice->certainty() > word->best_choice->certainty() ||
1189                         new_x_ht_word.best_choice->rating() < word->best_choice->rating());
1190      if (debug_x_ht_level >= 1) {
1191        ReportXhtFixResult(accept_new_x_ht, new_x_ht, word, &new_x_ht_word);
1192      }
1193    }
1194    if (accept_new_x_ht) {
1195      word->ConsumeWordResults(&new_x_ht_word);
1196      return true;
1197    }
1198    return false;
1199  }
1200  #endif 
1201  void Tesseract::classify_word_pass2(const WordData &word_data, WERD_RES **in_word,
1202                                      PointerVector<WERD_RES> *out_words) {
1203    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1204      return;
1205    }
1206  #ifndef DISABLED_LEGACY_ENGINE
1207    ROW *row = word_data.row;
1208    BLOCK *block = word_data.block;
1209    WERD_RES *word = *in_word;
1210    prev_word_best_choice_ =
1211        word_data.prev_word != nullptr ? word_data.prev_word->word->best_choice : nullptr;
1212    check_debug_pt(word, 30);
1213    if (!word->done) {
1214      word->caps_height = 0.0;
1215      if (word->x_height == 0.0f) {
1216        word->x_height = row->x_height();
1217      }
1218      match_word_pass_n(2, word, row, block);
1219      check_debug_pt(word, 40);
1220    }
1221    SubAndSuperscriptFix(word);
1222    if (!word->tess_failed && !word->word->flag(W_REP_CHAR)) {
1223      if (unicharset.top_bottom_useful() && unicharset.script_has_xheight() &&
1224          block->classify_rotation().y() == 0.0f) {
1225        TrainedXheightFix(word, block, row);
1226      }
1227    }
1228  #  ifndef GRAPHICS_DISABLED
1229    if (tessedit_display_outwords) {
1230      if (fx_win == nullptr) {
1231        create_fx_win();
1232      }
1233      clear_fx_win();
1234      word->rebuild_word->plot(fx_win);
1235      TBOX wbox = word->rebuild_word->bounding_box();
1236      fx_win->ZoomToRectangle(wbox.left(), wbox.top(), wbox.right(), wbox.bottom());
1237      ScrollView::Update();
1238    }
1239  #  endif
1240    check_debug_pt(word, 50);
1241  #endif 
1242  }
1243  #ifndef DISABLED_LEGACY_ENGINE
1244  void Tesseract::match_word_pass_n(int pass_n, WERD_RES *word, ROW *row, BLOCK *block) {
1245    if (word->tess_failed) {
1246      return;
1247    }
1248    tess_segment_pass_n(pass_n, word);
1249    if (!word->tess_failed) {
1250      if (!word->word->flag(W_REP_CHAR)) {
1251        word->fix_quotes();
1252        if (tessedit_fix_hyphens) {
1253          word->fix_hyphens();
1254        }
1255        if (static_cast<unsigned>(word->best_choice->length()) != word->box_word->length()) {
1256          tprintf(
1257              "POST FIX_QUOTES FAIL String:\"%s\"; Strlen=%d;"
1258              " #Blobs=%u\n",
1259              word->best_choice->debug_string().c_str(), word->best_choice->length(),
1260              word->box_word->length());
1261        }
1262        word->tess_accepted = tess_acceptable_word(word);
1263        make_reject_map(word, row, pass_n);
1264      }
1265    }
1266    set_word_fonts(word);
1267    ASSERT_HOST(word->raw_choice != nullptr);
1268  }
1269  #endif 
1270  static BLOB_CHOICE *FindBestMatchingChoice(UNICHAR_ID char_id, WERD_RES *word_res) {
1271    BLOB_CHOICE *best_choice = nullptr;
1272    for (unsigned i = 0; i < word_res->best_choice->length(); ++i) {
1273      BLOB_CHOICE *choice = FindMatchingChoice(char_id, word_res->GetBlobChoices(i));
1274      if (choice != nullptr) {
1275        if (best_choice == nullptr || choice->rating() < best_choice->rating()) {
1276          best_choice = choice;
1277        }
1278      }
1279    }
1280    return best_choice;
1281  }
1282  static void CorrectRepcharChoices(BLOB_CHOICE *blob_choice, WERD_RES *word_res) {
1283    WERD_CHOICE *word = word_res->best_choice;
1284    for (unsigned i = 0; i < word_res->best_choice->length(); ++i) {
1285      BLOB_CHOICE *choice =
1286          FindMatchingChoice(blob_choice->unichar_id(), word_res->GetBlobChoices(i));
1287      if (choice == nullptr) {
1288        BLOB_CHOICE_IT choice_it(word_res->GetBlobChoices(i));
1289        choice_it.add_before_stay_put(new BLOB_CHOICE(*blob_choice));
1290      }
1291    }
1292    for (unsigned i = 0; i < word->length(); ++i) {
1293      if (word->unichar_id(i) != blob_choice->unichar_id()) {
1294        word->set_unichar_id(blob_choice->unichar_id(), i);
1295      }
1296    }
1297  }
1298  void Tesseract::fix_rep_char(PAGE_RES_IT *page_res_it) {
1299    WERD_RES *word_res = page_res_it->word();
1300    const WERD_CHOICE &word = *(word_res->best_choice);
1301    SortHelper<UNICHAR_ID> rep_ch(word.length());
1302    for (unsigned i = 0; i < word.length(); ++i) {
1303      rep_ch.Add(word.unichar_id(i), 1);
1304    }
1305    UNICHAR_ID maxch_id = INVALID_UNICHAR_ID; 
1306    int max_count = rep_ch.MaxCount(&maxch_id);
1307    BLOB_CHOICE *best_choice = FindBestMatchingChoice(maxch_id, word_res);
1308    if (best_choice == nullptr) {
1309      tprintf("Failed to find a choice for %s, occurring %d times\n",
1310              word_res->uch_set->debug_str(maxch_id).c_str(), max_count);
1311      return;
1312    }
1313    word_res->done = true;
1314    CorrectRepcharChoices(best_choice, word_res);
1315    word_res->reject_map.initialise(word.length());
1316  }
1317  ACCEPTABLE_WERD_TYPE Tesseract::acceptable_word_string(const UNICHARSET &char_set, const char *s,
1318                                                         const char *lengths) {
1319    int i = 0;
1320    int offset = 0;
1321    int leading_punct_count;
1322    int upper_count = 0;
1323    int hyphen_pos = -1;
1324    ACCEPTABLE_WERD_TYPE word_type = AC_UNACCEPTABLE;
1325    if (strlen(lengths) > 20) {
1326      return word_type;
1327    }
1328    if (s[offset] != '\0' && chs_leading_punct.contains(s[offset])) {
1329      offset += lengths[i++];
1330    }
1331    leading_punct_count = i;
1332    while (s[offset] != '\0' && char_set.get_isupper(s + offset, lengths[i])) {
1333      offset += lengths[i++];
1334      upper_count++;
1335    }
1336    if (upper_count > 1) {
1337      word_type = AC_UPPER_CASE;
1338    } else {
1339      while (s[offset] != '\0' && char_set.get_islower(s + offset, lengths[i])) {
1340        offset += lengths[i++];
1341      }
1342      if (i - leading_punct_count < quality_min_initial_alphas_reqd) {
1343        goto not_a_word;
1344      }
1345      if (lengths[i] == 1 && s[offset] == '-') {
1346        hyphen_pos = i;
1347        offset += lengths[i++];
1348        if (s[offset] != '\0') {
1349          while ((s[offset] != '\0') && char_set.get_islower(s + offset, lengths[i])) {
1350            offset += lengths[i++];
1351          }
1352          if (i < hyphen_pos + 3) {
1353            goto not_a_word;
1354          }
1355        }
1356      } else {
1357        if (lengths[i] == 1 && (s[offset] == '\'') && lengths[i + 1] == 1 &&
1358            (s[offset + lengths[i]] == 's')) {
1359          offset += lengths[i++];
1360          offset += lengths[i++];
1361        }
1362      }
1363      if (upper_count > 0) {
1364        word_type = AC_INITIAL_CAP;
1365      } else {
1366        word_type = AC_LOWER_CASE;
1367      }
1368    }
1369    if (lengths[i] == 1 && s[offset] != '\0' && chs_trailing_punct1.contains(s[offset])) {
1370      offset += lengths[i++];
1371    }
1372    if (lengths[i] == 1 && s[offset] != '\0' && i > 0 && s[offset - lengths[i - 1]] != s[offset] &&
1373        chs_trailing_punct2.contains(s[offset])) {
1374      offset += lengths[i++];
1375    }
1376    if (s[offset] != '\0') {
1377      word_type = AC_UNACCEPTABLE;
1378    }
1379  not_a_word:
1380    if (word_type == AC_UNACCEPTABLE) {
1381      i = 0;
1382      offset = 0;
1383      if (s[0] != '\0' && char_set.get_isupper(s, lengths[0])) {
1384        word_type = AC_UC_ABBREV;
1385        while (s[offset] != '\0' && char_set.get_isupper(s + offset, lengths[i]) &&
1386               lengths[i + 1] == 1 && s[offset + lengths[i]] == '.') {
1387          offset += lengths[i++];
1388          offset += lengths[i++];
1389        }
1390      } else if (s[0] != '\0' && char_set.get_islower(s, lengths[0])) {
1391        word_type = AC_LC_ABBREV;
1392        while (s[offset] != '\0' && char_set.get_islower(s + offset, lengths[i]) &&
1393               lengths[i + 1] == 1 && s[offset + lengths[i]] == '.') {
1394          offset += lengths[i++];
1395          offset += lengths[i++];
1396        }
1397      }
1398      if (s[offset] != '\0') {
1399        word_type = AC_UNACCEPTABLE;
1400      }
1401    }
1402    return word_type;
1403  }
1404  bool Tesseract::check_debug_pt(WERD_RES *word, int location) {
1405    bool show_map_detail = false;
1406    int16_t i;
1407    if (!test_pt) {
1408      return false;
1409    }
1410    tessedit_rejection_debug.set_value(false);
1411    debug_x_ht_level.set_value(0);
1412    if (word->word->bounding_box().contains(FCOORD(test_pt_x, test_pt_y))) {
1413      if (location < 0) {
1414        return true; 
1415      }
1416      tessedit_rejection_debug.set_value(true);
1417      debug_x_ht_level.set_value(2);
1418      tprintf("\n\nTESTWD::");
1419      switch (location) {
1420        case 0:
1421          tprintf("classify_word_pass1 start\n");
1422          word->word->print();
1423          break;
1424        case 10:
1425          tprintf("make_reject_map: initial map");
1426          break;
1427        case 20:
1428          tprintf("make_reject_map: after NN");
1429          break;
1430        case 30:
1431          tprintf("classify_word_pass2 - START");
1432          break;
1433        case 40:
1434          tprintf("classify_word_pass2 - Pre Xht");
1435          break;
1436        case 50:
1437          tprintf("classify_word_pass2 - END");
1438          show_map_detail = true;
1439          break;
1440        case 60:
1441          tprintf("fixspace");
1442          break;
1443        case 70:
1444          tprintf("MM pass START");
1445          break;
1446        case 80:
1447          tprintf("MM pass END");
1448          break;
1449        case 90:
1450          tprintf("After Poor quality rejection");
1451          break;
1452        case 100:
1453          tprintf("unrej_good_quality_words - START");
1454          break;
1455        case 110:
1456          tprintf("unrej_good_quality_words - END");
1457          break;
1458        case 120:
1459          tprintf("Write results pass");
1460          show_map_detail = true;
1461          break;
1462      }
1463      if (word->best_choice != nullptr) {
1464        tprintf(" \"%s\" ", word->best_choice->unichar_string().c_str());
1465        word->reject_map.print(debug_fp);
1466        tprintf("\n");
1467        if (show_map_detail) {
1468          tprintf("\"%s\"\n", word->best_choice->unichar_string().c_str());
1469          for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++) {
1470            tprintf("**** \"%c\" ****\n", word->best_choice->unichar_string()[i]);
1471            word->reject_map[i].full_print(debug_fp);
1472          }
1473        }
1474      } else {
1475        tprintf("null best choice\n");
1476      }
1477      tprintf("Tess Accepted: %s\n", word->tess_accepted ? "TRUE" : "FALSE");
1478      tprintf("Done flag: %s\n\n", word->done ? "TRUE" : "FALSE");
1479      return true;
1480    } else {
1481      return false;
1482    }
1483  }
1484  #ifndef DISABLED_LEGACY_ENGINE
1485  static void find_modal_font( 
1486      STATS *fonts,            
1487      int16_t *font_out,       
1488      int8_t *font_count       
1489  ) {
1490    int16_t font;  
1491    int32_t count; 
1492    if (fonts->get_total() > 0) {
1493      font = static_cast<int16_t>(fonts->mode());
1494      *font_out = font;
1495      count = fonts->pile_count(font);
1496      *font_count = count < INT8_MAX ? count : INT8_MAX;
1497      fonts->add(font, -*font_count);
1498    } else {
1499      *font_out = -1;
1500      *font_count = 0;
1501    }
1502  }
1503  #endif 
1504  void Tesseract::set_word_fonts(WERD_RES *word) {
1505    if (word->chopped_word == nullptr) {
1506      return;
1507    }
1508    ASSERT_HOST(word->best_choice != nullptr);
1509  #ifndef DISABLED_LEGACY_ENGINE
1510    const int fontinfo_size = fontinfo_table_.size();
1511    if (fontinfo_size == 0) {
1512      return;
1513    }
1514    if (tessedit_font_id > 0) {
1515      if (tessedit_font_id >= fontinfo_size) {
1516        tprintf("Error, invalid font ID provided: must be below %d.\n"
1517                "Falling back to font auto-detection.\n", fontinfo_size);
1518      } else {
1519        word->fontinfo = &fontinfo_table_.at(tessedit_font_id);
1520        word->fontinfo2 = nullptr;
1521        word->fontinfo_id_count = INT8_MAX;
1522        word->fontinfo_id2_count = 0;
1523        return;
1524      }
1525    }
1526    std::vector<int> font_total_score(fontinfo_size);
1527    if (tessedit_debug_fonts) {
1528      tprintf("Examining fonts in %s\n", word->best_choice->debug_string().c_str());
1529    }
1530    for (unsigned b = 0; b < word->best_choice->length(); ++b) {
1531      const BLOB_CHOICE *choice = word->GetBlobChoice(b);
1532      if (choice == nullptr) {
1533        continue;
1534      }
1535      auto &fonts = choice->fonts();
1536      for (auto &f : fonts) {
1537        const int fontinfo_id = f.fontinfo_id;
1538        if (0 <= fontinfo_id && fontinfo_id < fontinfo_size) {
1539          font_total_score[fontinfo_id] += f.score;
1540        }
1541      }
1542    }
1543    int score1 = 0, score2 = 0;
1544    int16_t font_id1 = -1, font_id2 = -1;
1545    for (int f = 0; f < fontinfo_size; ++f) {
1546      if (tessedit_debug_fonts && font_total_score[f] > 0) {
1547        tprintf("Font %s, total score = %d\n", fontinfo_table_.at(f).name, font_total_score[f]);
1548      }
1549      if (font_total_score[f] > score1) {
1550        score2 = score1;
1551        font_id2 = font_id1;
1552        score1 = font_total_score[f];
1553        font_id1 = f;
1554      } else if (font_total_score[f] > score2) {
1555        score2 = font_total_score[f];
1556        font_id2 = f;
1557      }
1558    }
1559    word->fontinfo = font_id1 >= 0 ? &fontinfo_table_.at(font_id1) : nullptr;
1560    word->fontinfo2 = font_id2 >= 0 ? &fontinfo_table_.at(font_id2) : nullptr;
1561    word->fontinfo_id_count = ClipToRange<int>(score1 / UINT16_MAX, 1, INT8_MAX);
1562    word->fontinfo_id2_count = ClipToRange<int>(score2 / UINT16_MAX, 0, INT8_MAX);
1563    if (score1 > 0) {
1564      const FontInfo fi = fontinfo_table_.at(font_id1);
1565      if (tessedit_debug_fonts) {
1566        if (word->fontinfo_id2_count > 0 && font_id2 >= 0) {
1567          tprintf("Word modal font=%s, score=%d, 2nd choice %s/%d\n", fi.name,
1568                  word->fontinfo_id_count, fontinfo_table_.at(font_id2).name,
1569                  word->fontinfo_id2_count);
1570        } else {
1571          tprintf("Word modal font=%s, score=%d. No 2nd choice\n", fi.name, word->fontinfo_id_count);
1572        }
1573      }
1574    }
1575  #endif 
1576  }
1577  #ifndef DISABLED_LEGACY_ENGINE
1578  void Tesseract::font_recognition_pass(PAGE_RES *page_res) {
1579    PAGE_RES_IT page_res_it(page_res);
1580    WERD_RES *word;                       
1581    STATS doc_fonts(0, font_table_size_ - 1); 
1582    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1583      word = page_res_it.word();
1584      if (word->fontinfo != nullptr) {
1585        doc_fonts.add(word->fontinfo->universal_id, word->fontinfo_id_count);
1586      }
1587      if (word->fontinfo2 != nullptr) {
1588        doc_fonts.add(word->fontinfo2->universal_id, word->fontinfo_id2_count);
1589      }
1590    }
1591    int16_t doc_font;      
1592    int8_t doc_font_count; 
1593    find_modal_font(&doc_fonts, &doc_font, &doc_font_count);
1594    if (doc_font_count == 0) {
1595      return;
1596    }
1597    const FontInfo *modal_font = nullptr;
1598    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1599      word = page_res_it.word();
1600      if (word->fontinfo != nullptr && word->fontinfo->universal_id == doc_font) {
1601        modal_font = word->fontinfo;
1602        break;
1603      }
1604      if (word->fontinfo2 != nullptr && word->fontinfo2->universal_id == doc_font) {
1605        modal_font = word->fontinfo2;
1606        break;
1607      }
1608    }
1609    ASSERT_HOST(modal_font != nullptr);
1610    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1611      word = page_res_it.word();
1612      const int length = word->best_choice->length();
1613      const int count = word->fontinfo_id_count;
1614      if (!(count == length || (length > 3 && count >= length * 3 / 4))) {
1615        word->fontinfo = modal_font;
1616        word->fontinfo_id_count = 1;
1617      }
1618    }
1619  }
1620  #endif 
1621  void Tesseract::dictionary_correction_pass(PAGE_RES *page_res) {
1622    PAGE_RES_IT word_it(page_res);
1623    for (WERD_RES *word = word_it.word(); word != nullptr; word = word_it.forward()) {
1624      if (word->best_choices.singleton()) {
1625        continue; 
1626      }
1627      const WERD_CHOICE *best = word->best_choice;
1628      if (word->tesseract->getDict().valid_word(*best) != 0) {
1629        continue; 
1630      }
1631      WERD_CHOICE_IT choice_it(&word->best_choices);
1632      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
1633        WERD_CHOICE *alternate = choice_it.data();
1634        if (word->tesseract->getDict().valid_word(*alternate)) {
1635          if (tessedit_bigram_debug) {
1636            tprintf("Dictionary correction replaces best choice '%s' with '%s'\n",
1637                    best->unichar_string().c_str(), alternate->unichar_string().c_str());
1638          }
1639          word->ReplaceBestChoice(alternate);
1640          break;
1641        }
1642      }
1643    }
1644  }
1645  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intfx.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-control.cpp</div>
                <div class="column column_space"><pre><code>208      int index = GatherPoints(outline, feature_length, denorm, root_denorm, start_index, end_index,
209                               &pos, &normed_pos, &points, &dirs);
210      while (index <= end_index) {
211        LLSQ next_points;
212        LLSQ next_dirs;
213        FCOORD next_normed_pos(0.0f, 0.0f);
214        index = GatherPoints(outline, feature_length, denorm, root_denorm, index, end_index, &pos,
215                             &next_normed_pos, &next_points, &next_dirs);
216        LLSQ sum_points(prev_points);
217        LLSQ sum_dirs(dirs);
218        sum_points.add(points);
219        sum_points.add(next_points);
220        sum_dirs.add(next_dirs);
221        bool made_features = false;
222        if (sum_points.count() > 0) {
223          FCOORD fit_pt = sum_points.mean_point();
224          FCOORD fit_vector = MeanDirectionVector(sum_points, sum_dirs, prev_normed_pos, normed_pos);
</pre></code></div>
                <div class="column column_space"><pre><code>441    int word_index = 0;
442    while (!tessedit_test_adaption && page_res_it.word() != nullptr) {
443      WERD_RES *word = page_res_it.word();
444      word_index++;
445      if (monitor != nullptr) {
446        monitor->ocr_alive = true;
447        monitor->progress = 95 + 5 * word_index / stats_.word_count;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    