
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 74, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</h3>
            <pre><code>1  #include <deque>
2  #include <algorithm>
3  #include <time.h>
4  #include <locale>
5  #include <codecvt>
6  #include <sys/stat.h>
7  #include "Buffer.h"
8  #include "Scintilla.h"
9  #include "ILexer.h"
10  #include "Lexilla.h"
11  #include "Parameters.h"
12  #include "Notepad_plus.h"
13  #include "ScintillaEditView.h"
14  #include "EncodingMapper.h"
15  #include "uchardet.h"
16  #include "FileInterface.h"
17  static const int blockSize = 128 * 1024 + 4;
18  static const int CR = 0x0D;
19  static const int LF = 0x0A;
20  long Buffer::_recentTagCtr = 0;
21  namespace 
22  {
23  	static EolType getEOLFormatForm(const char* const data, size_t length, EolType defvalue = EolType::osdefault)
24  	{
25  		assert(length == 0 || (data != nullptr && "invalid buffer for getEOLFormatForm()"));
26  		for (size_t i = 0; i != length; ++i)
27  		{
28  			if (data[i] == CR)
29  			{
30  				if (i + 1 < length && data[i + 1] == LF)
31  					return EolType::windows;
32  				return EolType::macos;
33  			}
34  			if (data[i] == LF)
35  				return EolType::unix;
36  		}
37  		return defvalue; 
38  	}
39  } 
40  Buffer::Buffer(FileManager * pManager, BufferID id, Document doc, DocFileStatus type, const TCHAR *fileName, bool isLargeFile)
41  	: _pManager(pManager) , _id(id), _doc(doc), _lang(L_TEXT), _isLargeFile(isLargeFile)
42  {
43  	NppParameters& nppParamInst = NppParameters::getInstance();
44  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
45  	_eolFormat = ndds._format;
46  	_unicodeMode = ndds._unicodeMode;
47  	_encoding = ndds._codepage;
48  	if (_encoding != -1)
49  		_unicodeMode = uniCookie;
50  	_currentStatus = type;
51  	setFileName(fileName);
52  	updateTimeStamp();
53  	checkFileState();
54  	_canNotify = true;
55  }
56  void Buffer::doNotify(int mask)
57  {
58  	if (_canNotify)
59  	{
60  		assert(_pManager != nullptr);
61  		_pManager->beNotifiedOfBufferChange(this, mask);
62  	}
63  }
64  void Buffer::setDirty(bool dirty)
65  {
66  	_isDirty = dirty;
67  	doNotify(BufferChangeDirty);
68  }
69  void Buffer::setEncoding(int encoding)
70  {
71  	_encoding = encoding;
72  	doNotify(BufferChangeUnicode | BufferChangeDirty);
73  }
74  void Buffer::setUnicodeMode(UniMode mode)
75  {
76  	_unicodeMode = mode;
77  	doNotify(BufferChangeUnicode | BufferChangeDirty);
78  }
79  void Buffer::setLangType(LangType lang, const TCHAR* userLangName)
80  {
81  	if (lang == _lang && lang != L_USER)
82  		return;
83  	_lang = lang;
84  	if (_lang == L_USER)
85  		_userLangExt = userLangName;
86  	_needLexer = true;	
87  	doNotify(BufferChangeLanguage|BufferChangeLexing);
88  }
89  void Buffer::updateTimeStamp()
90  {
91  	FILETIME timeStampLive = {};
92  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
93  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
94  	{
95  		timeStampLive = attributes.ftLastWriteTime;
96  	}
97  	LONG res = CompareFileTime(&_timeStamp, &timeStampLive);
98  	if (res == -1 || res == 1)
99  	{
100  		if (res == 1)
101  		{
102  			NppParameters& nppParam = NppParameters::getInstance();
103  			if (nppParam.doNppLogNetworkDriveIssue())
104  			{
105  				generic_string issueFn = nppLogNetworkDriveIssue;
106  				issueFn += TEXT(".log");
107  				generic_string nppIssueLog = nppParam.getUserPath();
108  				pathAppend(nppIssueLog, issueFn);
109  				std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
110  				std::string msg = converter.to_bytes(_fullPathName);
111  				char buf[1024];
112  				sprintf(buf, "  in updateTimeStamp(): timeStampLive (%lu/%lu) < _timeStamp (%lu/%lu)", timeStampLive.dwLowDateTime, timeStampLive.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
113  				msg += buf;
114  				writeLog(nppIssueLog.c_str(), msg.c_str());
115  			}
116  		}
117  		_timeStamp = timeStampLive;
118  		doNotify(BufferChangeTimestamp);
119  	}
120  }
121  void Buffer::setFileName(const TCHAR *fn)
122  {
123  	NppParameters& nppParamInst = NppParameters::getInstance();
124  	if (_fullPathName == fn)
125  	{
126  		updateTimeStamp();
127  		doNotify(BufferChangeTimestamp);
128  		return;
129  	}
130  	_fullPathName = fn;
131  	_fileName = PathFindFileName(_fullPathName.c_str());
132  	LangType determinatedLang = L_TEXT;
133  	TCHAR *ext = PathFindExtension(_fullPathName.c_str());
134  	if (*ext == '.') 
135  	{
136  		ext += 1;
137  		const TCHAR* langName = nppParamInst.getUserDefinedLangNameFromExt(ext, _fileName);
138  		if (langName)
139  		{
140  			determinatedLang = L_USER;
141  			_userLangExt = langName;
142  		}
143  		else 
144  		{
145  			_userLangExt.clear();
146  			determinatedLang = nppParamInst.getLangFromExt(ext);
147  		}
148  	}
149  	if (determinatedLang == L_TEXT)	
150  	{
151  		if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("makefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("GNUmakefile")) == 0))
152  			determinatedLang = L_MAKEFILE;
153  		else if (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("CmakeLists.txt")) == 0)
154  			determinatedLang = L_CMAKE;
155  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConstruct")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConscript")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("wscript")) == 0))
156  			determinatedLang = L_PYTHON;
157  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Rakefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Vagrantfile")) == 0))
158  			determinatedLang = L_RUBY;
159  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("crontab")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("PKGBUILD")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("APKBUILD")) == 0))
160  			determinatedLang = L_BASH;
161  	}
162  	updateTimeStamp();
163  	BufferStatusInfo lang2Change = BufferChangeNone;
164  	if (!_hasLangBeenSetFromMenu && (determinatedLang != _lang || _lang == L_USER))
165  	{
166  		if (_isLargeFile)
167  		{
168  			_lang = L_TEXT;
169  		}
170  		else
171  		{
172  			_lang = determinatedLang;
173  			lang2Change = BufferChangeLanguage;
174  		}
175  	}
176  	doNotify(BufferChangeFilename | BufferChangeTimestamp | lang2Change);
177  }
178  bool Buffer::checkFileState() 
179  {
180  	if (_currentStatus == DOC_UNNAMED || isMonitoringOn())
181  		return false;
182  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
183  	bool isWow64Off = false;
184  	NppParameters& nppParam = NppParameters::getInstance();
185  	if (!PathFileExists(_fullPathName.c_str()))
186  	{
187  		nppParam.safeWow64EnableWow64FsRedirection(FALSE);
188  		isWow64Off = true;
189  	}
190  	bool isOK = false;
191  	if (_currentStatus != DOC_DELETED && !PathFileExists(_fullPathName.c_str()))	
192  	{
193  		_currentStatus = DOC_DELETED;
194  		_isFileReadOnly = false;
195  		_isDirty = true;	
196  		_timeStamp = {};
197  		doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
198  		isOK = true;
199  	}
200  	else if (_currentStatus == DOC_DELETED && PathFileExists(_fullPathName.c_str()))
201  	{	
202  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
203  		{
204  			_isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
205  			_currentStatus = DOC_MODIFIED;
206  			_timeStamp = attributes.ftLastWriteTime;
207  			if (_reloadFromDiskRequestGuard.try_lock())
208  			{
209  				doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
210  				_reloadFromDiskRequestGuard.unlock();
211  			}
212  			isOK = true;
213  		}
214  	}
215  	else if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
216  	{
217  		int mask = 0;	
218  		bool isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
219  		if (isFileReadOnly != _isFileReadOnly)
220  		{
221  			_isFileReadOnly = isFileReadOnly;
222  			mask |= BufferChangeReadonly;
223  		}
224  		LONG res = CompareFileTime(&_timeStamp, &attributes.ftLastWriteTime);
225  		if (res == -1 || res == 1)
226  		{
227  			if (res == 1)
228  			{
229  				NppParameters& nppParam = NppParameters::getInstance();
230  				if (nppParam.doNppLogNetworkDriveIssue())
231  				{
232  					generic_string issueFn = nppLogNetworkDriveIssue;
233  					issueFn += TEXT(".log");
234  					generic_string nppIssueLog = nppParam.getUserPath();
235  					pathAppend(nppIssueLog, issueFn);
236  					std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
237  					std::string msg = converter.to_bytes(_fullPathName);
238  					char buf[1024];
239  					sprintf(buf, "  in checkFileState(): attributes.ftLastWriteTime (%lu/%lu) < _timeStamp (%lu/%lu)", attributes.ftLastWriteTime.dwLowDateTime, attributes.ftLastWriteTime.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
240  					msg += buf;
241  					writeLog(nppIssueLog.c_str(), msg.c_str());
242  				}
243  			}
244  			_timeStamp = attributes.ftLastWriteTime;
245  			mask |= BufferChangeTimestamp;
246  			_currentStatus = DOC_MODIFIED;
247  			mask |= BufferChangeStatus;	
248  		}
249  		if (mask != 0)
250  		{
251  			if (_reloadFromDiskRequestGuard.try_lock())
252  			{
253  				doNotify(mask);
254  				_reloadFromDiskRequestGuard.unlock();
255  				return true;
256  			}
257  		}
258  		return false;
259  	}
260  	if (isWow64Off)
261  	{
262  		nppParam.safeWow64EnableWow64FsRedirection(TRUE);
263  	}
264  	return isOK;
265  }
266  void Buffer::reload()
267  {
268  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
269  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
270  	{
271  		_timeStamp = attributes.ftLastWriteTime;
272  		_currentStatus = DOC_NEEDRELOAD;
273  		doNotify(BufferChangeTimestamp | BufferChangeStatus);
274  	}
275  }
276  int64_t Buffer::getFileLength() const
277  {
278  	if (_currentStatus == DOC_UNNAMED)
279  		return -1;
280  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
281  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
282  	{
283  		LARGE_INTEGER size{};
284  		size.LowPart = attributes.nFileSizeLow;
285  		size.HighPart = attributes.nFileSizeHigh;
286  		return size.QuadPart;
287  	}
288  	return -1;
289  }
290  generic_string Buffer::getFileTime(fileTimeType ftt) const
291  {
292  	generic_string result;
293  	if (_currentStatus != DOC_UNNAMED)
294  	{
295  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
296  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
297  		{
298  			FILETIME rawtime;
299  			switch (ftt)
300  			{
301  				case ft_created:
302  					rawtime = attributes.ftCreationTime;
303  					break;
304  				case ft_modified:
305  					rawtime = attributes.ftLastWriteTime;
306  					break;
307  				default:
308  					rawtime = attributes.ftLastAccessTime;
309  					break;
310  			}
311  			SYSTEMTIME utcSystemTime, localSystemTime;
312  			FileTimeToSystemTime(&rawtime, &utcSystemTime);
313  			SystemTimeToTzSpecificLocalTime(nullptr, &utcSystemTime, &localSystemTime);
314  			const size_t dateTimeStrLen = 256;
315  			TCHAR bufDate[dateTimeStrLen] = {'\0'};
316  			GetDateFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufDate, dateTimeStrLen);
317  			result += bufDate;
318  			result += ' ';
319  			TCHAR bufTime[dateTimeStrLen] = {'\0'};
320  			GetTimeFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufTime, dateTimeStrLen);
321  			result += bufTime;
322  		}
323  	}
324  	return result;
325  }
326  void Buffer::setPosition(const Position & pos, ScintillaEditView * identifier)
327  {
328  	int index = indexOfReference(identifier);
329  	if (index == -1)
330  		return;
331  	_positions[index] = pos;
332  }
333  Position& Buffer::getPosition(ScintillaEditView* identifier)
334  {
335  	int index = indexOfReference(identifier);
336  	return _positions.at(index);
337  }
338  void Buffer::setHeaderLineState(const std::vector<size_t> & folds, ScintillaEditView * identifier)
339  {
340  	int index = indexOfReference(identifier);
341  	if (index == -1)
342  		return;
343  	std::vector<size_t> & local = _foldStates[index];
344  	local.clear();
345  	size_t size = folds.size();
346  	for (size_t i = 0; i < size; ++i)
347  		local.push_back(folds[i]);
348  }
349  const std::vector<size_t> & Buffer::getHeaderLineState(const ScintillaEditView * identifier) const
350  {
351  	int index = indexOfReference(identifier);
352  	return _foldStates.at(index);
353  }
354  Lang * Buffer::getCurrentLang() const
355  {
356  	NppParameters& nppParam = NppParameters::getInstance();
357  	int i = 0;
358  	Lang *l = nppParam.getLangFromIndex(i);
359  	++i;
360  	while (l)
361  	{
362  		if (l->_langID == _lang)
363  			return l;
364  		l = nppParam.getLangFromIndex(i);
365  		++i;
366  	}
367  	return nullptr;
368  }
369  int Buffer::indexOfReference(const ScintillaEditView * identifier) const
370  {
371  	size_t size = _referees.size();
372  	for (size_t i = 0; i < size; ++i)
373  	{
374  		if (_referees[i] == identifier)
375  			return static_cast<int>(i);
376  	}
377  	return -1;	
378  }
379  int Buffer::addReference(ScintillaEditView * identifier)
380  {
381  	if (indexOfReference(identifier) != -1)
382  		return _references;
383  	_referees.push_back(identifier);
384  	_positions.push_back(Position());
385  	_foldStates.push_back(std::vector<size_t>());
386  	++_references;
387  	return _references;
388  }
389  int Buffer::removeReference(ScintillaEditView * identifier)
390  {
391  	int indexToPop = indexOfReference(identifier);
392  	if (indexToPop == -1)
393  		return _references;
394  	_referees.erase(_referees.begin() + indexToPop);
395  	_positions.erase(_positions.begin() + indexToPop);
396  	_foldStates.erase(_foldStates.begin() + indexToPop);
397  	_references--;
398  	return _references;
399  }
400  void Buffer::setHideLineChanged(bool isHide, size_t location)
401  {
402  	for (int i = 0; i < _references; ++i)
403  		_referees.at(i)->notifyMarkers(this, isHide, location, false); 
404  	if (!isHide) 
405  	{
406  		for (int i = 0; i < _references; ++i)
407  			_referees.at(i)->notifyMarkers(this, isHide, location, true);
408  	}
409  }
410  void Buffer::setDeferredReload() 
411  {
412  	_isDirty = false;	
413  	_needReloading = true;
414  	doNotify(BufferChangeDirty);
415  }
416  bool Buffer::allowBraceMach() const
417  {
418  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
419  	return (!_isLargeFile || nppGui._largeFileRestriction._allowBraceMatch) || !nppGui._largeFileRestriction._isEnabled;
420  }
421  bool Buffer::allowAutoCompletion() const
422  {
423  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
424  	return (!_isLargeFile || nppGui._largeFileRestriction._allowAutoCompletion) || !nppGui._largeFileRestriction._isEnabled;
425  }
426  bool Buffer::allowSmartHilite() const
427  {
428  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
429  	return (!_isLargeFile || nppGui._largeFileRestriction._allowSmartHilite) || !nppGui._largeFileRestriction._isEnabled;
430  }
431  bool Buffer::allowClickableLink() const
432  {
433  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
434  	return (!_isLargeFile || nppGui._largeFileRestriction._allowClickableLink) || !nppGui._largeFileRestriction._isEnabled;
435  }
436  FileManager::~FileManager()
437  {
438  	for (std::vector<Buffer *>::iterator it = _buffers.begin(), end = _buffers.end(); it != end; ++it)
439  	{
440  		delete *it;
441  	}
442  }
443  void FileManager::init(Notepad_plus * pNotepadPlus, ScintillaEditView * pscratchTilla)
444  {
445  	_pNotepadPlus = pNotepadPlus;
446  	_pscratchTilla = pscratchTilla;
447  	_pscratchTilla->execute(SCI_SETUNDOCOLLECTION, false);	
448  	_scratchDocDefault = (Document)_pscratchTilla->execute(SCI_GETDOCPOINTER);
449  	_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, _scratchDocDefault);
450  }
451  void FileManager::checkFilesystemChanges(bool bCheckOnlyCurrentBuffer)
452  {
453  	if (bCheckOnlyCurrentBuffer)
454  	{
455  		Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
456  		buffer->checkFileState();
457  	}
458  	else
459  	{
460  		for (int i = int(_nbBufs) - 1; i >= 0; i--)
461  		{
462  			if (i >= int(_nbBufs))
463  			{
464  				if (_nbBufs == 0)
465  					return;
466  				i = int(_nbBufs) - 1;
467  			}
468  			_buffers[i]->checkFileState();	
469  		}
470  	}
471  }
472  size_t FileManager::getNbDirtyBuffers() const
473  {
474  	size_t nb_dirtyBufs = 0;
475  	for (size_t i = 0; i < _nbBufs; ++i)
476  	{
477  		if (_buffers[i]->_isDirty)
478  			++nb_dirtyBufs;
479  	}
480  	return nb_dirtyBufs;
481  }
482  int FileManager::getBufferIndexByID(BufferID id)
483  {
484  	for (size_t i = 0; i < _nbBufs; ++i)
485  	{
486  		if (_buffers[i]->_id == id)
487  			return static_cast<int>(i);
488  	}
489  	return -1;
490  }
491  Buffer* FileManager::getBufferByIndex(size_t index)
492  {
493  	if (index >= _buffers.size())
494  		return nullptr;
495  	return _buffers.at(index);
496  }
497  void FileManager::beNotifiedOfBufferChange(Buffer* theBuf, int mask)
498  {
499  	_pNotepadPlus->notifyBufferChanged(theBuf, mask);
500  }
501  void FileManager::addBufferReference(BufferID buffer, ScintillaEditView * identifier)
502  {
503  	Buffer* buf = getBufferByID(buffer);
504  	buf->addReference(identifier);
505  }
506  void FileManager::closeBuffer(BufferID id, ScintillaEditView * identifier)
507  {
508  	int index = getBufferIndexByID(id);
509  	Buffer* buf = getBufferByIndex(index);
510  	int refs = buf->removeReference(identifier);
511  	if (!refs) 
512  	{
513  		_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, buf->_doc);	
514  		_buffers.erase(_buffers.begin() + index);
515  		delete buf;
516  		_nbBufs--;
517  	}
518  }
519  BufferID FileManager::loadFile(const TCHAR* filename, Document doc, int encoding, const TCHAR* backupFileName, FILETIME fileNameTimestamp)
520  {
521  	if (!filename)
522  		return BUFFER_INVALID;
523  	int64_t fileSize = -1;
524  	const TCHAR* pPath = filename;
525  	if (!::PathFileExists(pPath))
526  	{
527  		pPath = backupFileName;
528  	}
529  	if (pPath)
530  	{
531  		FILE* fp = _wfopen(pPath, TEXT("rb"));
532  		if (fp)
533  		{
534  			_fseeki64(fp, 0, SEEK_END);
535  			fileSize = _ftelli64(fp);
536  			fclose(fp);
537  		}
538  	}
539  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
540  	bool isLargeFile = false;
541  	if (nppGui._largeFileRestriction._isEnabled)
542  		isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
543  	if (isLargeFile && nppGui._largeFileRestriction._deactivateWordWrap)
544  	{
545  		bool isWrap = _pNotepadPlus->_pEditView->isWrap();
546  		if (isWrap)
547  		{
548  			_pNotepadPlus->command(IDM_VIEW_WRAP);
549  		}
550  	}
551  	bool ownDoc = false;
552  	if (!doc)
553  	{
554  		doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT, 0, isLargeFile ? SC_DOCUMENTOPTION_STYLES_NONE | SC_DOCUMENTOPTION_TEXT_LARGE : 0);
555  		ownDoc = true;
556  	}
557  	WCHAR fullpath[MAX_PATH] = { 0 };
558  	if (isWin32NamespacePrefixedFileName(filename))
559  	{
560  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
561  	}
562  	else
563  	{
564  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
565  		if (wcschr(fullpath, '~'))
566  		{
567  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
568  		}
569  	}
570  	bool isSnapshotMode = backupFileName != NULL && PathFileExists(backupFileName);
571  	if (isSnapshotMode && !PathFileExists(fullpath)) 
572  	{
573  		wcscpy_s(fullpath, MAX_PATH, filename); 
574  	}
575  	Utf8_16_Read UnicodeConvertor;	
576  	char* data = new char[blockSize + 8]; 
577  	LoadedFileFormat loadedFileFormat;
578  	loadedFileFormat._encoding = encoding;
579  	loadedFileFormat._eolFormat = EolType::unknown;
580  	loadedFileFormat._language = L_TEXT;
581  	bool res = loadFileData(doc, fileSize, backupFileName ? backupFileName : fullpath, data, &UnicodeConvertor, loadedFileFormat);
582  	delete[] data;
583  	if (res)
584  	{
585  		Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_REGULAR, fullpath, isLargeFile);
586  		BufferID id = newBuf;
587  		newBuf->_id = id;
588  		if (backupFileName != NULL)
589  		{
590  			newBuf->_backupFileName = backupFileName;
591  			if (!PathFileExists(fullpath))
592  				newBuf->_currentStatus = DOC_UNNAMED;
593  		}
594  		const FILETIME zeroTimeStamp = {};
595  		LONG res = CompareFileTime(&fileNameTimestamp, &zeroTimeStamp);
596  		if (res != 0) 
597  			newBuf->_timeStamp = fileNameTimestamp;
598  		_buffers.push_back(newBuf);
599  		++_nbBufs;
600  		Buffer* buf = _buffers.at(_nbBufs - 1);
601  		buf->setEncoding(-1);
602  		if (!newBuf->_isLargeFile && ((buf->getLangType() == L_TEXT) && (loadedFileFormat._language != L_TEXT)))
603  			buf->setLangType(loadedFileFormat._language);
604  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
605  		++_nextBufferID;
606  		return id;
607  	}
608  	else 
609  	{
610  		if (ownDoc)
611  			_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, doc);	
612  		return BUFFER_INVALID;
613  	}
614  }
615  bool FileManager::reloadBuffer(BufferID id)
616  {
617  	Buffer* buf = getBufferByID(id);
618  	Document doc = buf->getDocument();
619  	Utf8_16_Read UnicodeConvertor;
620  	LoadedFileFormat loadedFileFormat;
621  	loadedFileFormat._encoding = buf->getEncoding();
622  	loadedFileFormat._eolFormat = EolType::unknown;
623  	loadedFileFormat._language = buf->getLangType();
624  	buf->setLoadedDirty(false);	
625  	FILE* fp = _wfopen(buf->getFullPathName(), TEXT("rb"));
626  	if (!fp)
627  		return false;
628  	_fseeki64(fp, 0, SEEK_END);
629  	int64_t fileSize = _ftelli64(fp);
630  	fclose(fp);
631  	char* data = new char[blockSize + 8]; 
632  	buf->_canNotify = false;	
633  	bool res = loadFileData(doc, fileSize, buf->getFullPathName(), data, &UnicodeConvertor, loadedFileFormat);
634  	buf->_canNotify = true;
635  	delete[] data;
636  	if (res)
637  	{
638  		buf->setUnsync(false);
639  		buf->setDirty(false); 
640  		buf->setSavePointDirty(false);
641  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
642  	}
643  	return res;
644  }
645  void FileManager::setLoadedBufferEncodingAndEol(Buffer* buf, const Utf8_16_Read& UnicodeConvertor, int encoding, EolType bkformat)
646  {
647  	if (encoding == -1)
648  	{
649  		NppParameters& nppParamInst = NppParameters::getInstance();
650  		const NewDocDefaultSettings & ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
651  		UniMode um = UnicodeConvertor.getEncoding();
652  		if (um == uni7Bit)
653  			um = (ndds._openAnsiAsUtf8) ? uniCookie : uni8Bit;
654  		buf->setUnicodeMode(um);
655  	}
656  	else
657  	{
658  		buf->setEncoding((encoding == SC_CP_UTF8)?-1:encoding);
659  		buf->setUnicodeMode(uniCookie);
660  	}
661  	if (bkformat != EolType::unknown)
662  		buf->setEolFormat(bkformat);
663  }
664  bool FileManager::reloadBufferDeferred(BufferID id)
665  {
666  	Buffer* buf = getBufferByID(id);
667  	buf->setDeferredReload();
668  	return true;
669  }
670  bool FileManager::deleteFile(BufferID id)
671  {
672  	Buffer* buf = getBufferByID(id);
673  	generic_string fileNamePath = buf->getFullPathName();
674  	fileNamePath.append(1, '\0');
675  	if (!PathFileExists(fileNamePath.c_str()))
676  		return false;
677  	SHFILEOPSTRUCT fileOpStruct = {};
678  	fileOpStruct.hwnd = NULL;
679  	fileOpStruct.pFrom = fileNamePath.c_str();
680  	fileOpStruct.pTo = NULL;
681  	fileOpStruct.wFunc = FO_DELETE;
682  	fileOpStruct.fFlags = FOF_ALLOWUNDO;
683  	fileOpStruct.fAnyOperationsAborted = false;
684  	fileOpStruct.hNameMappings         = NULL;
685  	fileOpStruct.lpszProgressTitle     = NULL;
686  	return SHFileOperation(&fileOpStruct) == 0;
687  }
688  bool FileManager::moveFile(BufferID id, const TCHAR * newFileName)
689  {
690  	Buffer* buf = getBufferByID(id);
691  	const TCHAR *fileNamePath = buf->getFullPathName();
692  	if (::MoveFileEx(fileNamePath, newFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH) == 0)
693  		return false;
694  	buf->setFileName(newFileName);
695  	return true;
696  }
697  std::mutex backup_mutex;
698  bool FileManager::backupCurrentBuffer()
699  {
700  	Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
701  	if (buffer->isLargeFile())
702  		return false;
703  	std::lock_guard<std::mutex> lock(backup_mutex);
704  	bool result = false;
705  	bool hasModifForSession = false;
706  	if (buffer->isDirty())
707  	{
708  		if (buffer->isModified()) 
709  		{
710  			UniMode mode = buffer->getUnicodeMode();
711  			if (mode == uniCookie)
712  				mode = uni8Bit;	
713  			Utf8_16_Write UnicodeConvertor;
714  			UnicodeConvertor.setEncoding(mode);
715  			int encoding = buffer->getEncoding();
716  			generic_string backupFilePath = buffer->getBackupFileName();
717  			if (backupFilePath.empty())
718  			{
719  				backupFilePath = NppParameters::getInstance().getUserPath();
720  				backupFilePath += TEXT("\\backup\\");
721  				if (!PathFileExists(backupFilePath.c_str()))
722  				{
723  					::CreateDirectory(backupFilePath.c_str(), NULL);
724  				}
725  				backupFilePath += buffer->getFileName();
726  				const int temBufLen = 32;
727  				TCHAR tmpbuf[temBufLen];
728  				time_t ltime = time(0);
729  				struct tm* today = localtime(&ltime);
730  				if (!today)
731  					return false;
732  				wcsftime(tmpbuf, temBufLen, L"%Y-%m-%d_%H%M%S", today);
733  				backupFilePath += L"@";
734  				backupFilePath += tmpbuf;
735  				buffer->setBackupFileName(backupFilePath);
736  				hasModifForSession = true;
737  			}
738  			TCHAR fullpath[MAX_PATH];
739  			::GetFullPathName(backupFilePath.c_str(), MAX_PATH, fullpath, NULL);
740  			if (wcschr(fullpath, '~'))
741  			{
742  				::GetLongPathName(fullpath, fullpath, MAX_PATH);
743  			}
744  			DWORD dwFileAttribs = ::GetFileAttributes(fullpath);
745  			if (dwFileAttribs & FILE_ATTRIBUTE_READONLY) 
746  			{
747  				dwFileAttribs ^= FILE_ATTRIBUTE_READONLY;
748  				::SetFileAttributes(fullpath, dwFileAttribs);
749  			}
750  			if (UnicodeConvertor.openFile(fullpath))
751  			{
752  				size_t lengthDoc = _pNotepadPlus->_pEditView->getCurrentDocLen();
753  				char* buf = (char*)_pNotepadPlus->_pEditView->execute(SCI_GETCHARACTERPOINTER);	
754  				boolean isWrittenSuccessful = false;
755  				if (encoding == -1) 
756  				{
757  					isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
758  					if (lengthDoc == 0)
759  						isWrittenSuccessful = true;
760  				}
761  				else
762  				{
763  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
764  					size_t grabSize;
765  					for (size_t i = 0; i < lengthDoc; i += grabSize)
766  					{
767  						grabSize = lengthDoc - i;
768  						if (grabSize > blockSize)
769  							grabSize = blockSize;
770  						int newDataLen = 0;
771  						int incompleteMultibyteChar = 0;
772  						const char *newData = wmc.encode(SC_CP_UTF8, encoding, buf+i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
773  						grabSize -= incompleteMultibyteChar;
774  						isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
775  					}
776  					if (lengthDoc == 0)
777  						isWrittenSuccessful = true;
778  				}
779  				UnicodeConvertor.closeFile();
780  				if (isWrittenSuccessful) 
781  				{
782  					buffer->setModifiedStatus(false);
783  					result = true;	
784  				}
785  			}
786  		}
787  		else 
788  		{
789  			result = true;
790  		}
791  	}
792  	else 
793  	{
794  		generic_string backupFilePath = buffer->getBackupFileName();
795  		if (!backupFilePath.empty())
796  		{
797  			generic_string file2Delete = buffer->getBackupFileName();
798  			buffer->setBackupFileName(generic_string());
799  			result = (::DeleteFile(file2Delete.c_str()) != 0);
800  			hasModifForSession = true;
801  		}
802  		result = true; 
803  	}
804  	if (result && hasModifForSession)
805  	{
806  		_pNotepadPlus->saveCurrentSession();
807  	}
808  	return result;
809  }
810  bool FileManager::deleteBufferBackup(BufferID id)
811  {
812  	Buffer* buffer = getBufferByID(id);
813  	bool result = true;
814  	generic_string backupFilePath = buffer->getBackupFileName();
815  	if (!backupFilePath.empty())
816  	{
817  		buffer->setBackupFileName(generic_string());
818  		result = (::DeleteFile(backupFilePath.c_str()) != 0);
819  	}
820  	return result;
821  }
822  std::mutex save_mutex;
823  SavingStatus FileManager::saveBuffer(BufferID id, const TCHAR * filename, bool isCopy)
824  {
825  	std::lock_guard<std::mutex> lock(save_mutex);
826  	Buffer* buffer = getBufferByID(id);
827  	bool isHiddenOrSys = false;
828  	DWORD attrib = 0;
829  	WCHAR fullpath[MAX_PATH] = { 0 };
830  	if (isWin32NamespacePrefixedFileName(filename))
831  	{
832  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
833  	}
834  	else
835  	{
836  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
837  		if (wcschr(fullpath, '~'))
838  		{
839  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
840  		}
841  	}
842  	if (PathFileExists(fullpath))
843  	{
844  		attrib = ::GetFileAttributes(fullpath);
845  		if (attrib != INVALID_FILE_ATTRIBUTES)
846  		{
847  			isHiddenOrSys = (attrib & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != 0;
848  			if (isHiddenOrSys)
849  				::SetFileAttributes(filename, attrib & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));
850  		}
851  	}
852  	UniMode mode = buffer->getUnicodeMode();
853  	if (mode == uniCookie)
854  		mode = uni8Bit;	
855  	Utf8_16_Write UnicodeConvertor;
856  	UnicodeConvertor.setEncoding(mode);
857  	int encoding = buffer->getEncoding();
858  	if (UnicodeConvertor.openFile(fullpath))
859  	{
860  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);	
861  		size_t lengthDoc = _pscratchTilla->getCurrentDocLen();
862  		char* buf = (char*)_pscratchTilla->execute(SCI_GETCHARACTERPOINTER);	
863  		boolean isWrittenSuccessful = false;
864  		if (encoding == -1) 
865  		{
866  			isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
867  			if (lengthDoc == 0)
868  				isWrittenSuccessful = true;
869  		}
870  		else
871  		{
872  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
873  			if (lengthDoc == 0)
874  			{
875  				isWrittenSuccessful = UnicodeConvertor.writeFile(buf, 0);
876  			}
877  			else
878  			{
879  				size_t grabSize;
880  				for (size_t i = 0; i < lengthDoc; i += grabSize)
881  				{
<span onclick='openModal()' class='match'>882  					grabSize = lengthDoc - i;
883  					if (grabSize > blockSize)
884  						grabSize = blockSize;
885  					int newDataLen = 0;
886  					int incompleteMultibyteChar = 0;
887  					const char* newData = wmc.encode(SC_CP_UTF8, encoding, buf + i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
888  					grabSize -= incompleteMultibyteChar;
889  					isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
890  				}
891  			}
</span>892  		}
893  		UnicodeConvertor.closeFile();
894  		if (!isWrittenSuccessful)
895  		{
896  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
897  			return SavingStatus::SaveWritingFailed;
898  		}
899  		if (isHiddenOrSys)
900  			::SetFileAttributes(fullpath, attrib);
901  		if (isCopy) 
902  		{
903  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
904  			return SavingStatus::SaveOK;	
905  		}
906  		buffer->setFileName(fullpath);
907  		if (!buffer->isLargeFile() && buffer->_lang == L_TEXT)
908  		{
909  			LangType detectedLang = detectLanguageFromTextBegining((unsigned char*)buf, lengthDoc);
910  			if (detectedLang != L_TEXT)
911  			{
912  				buffer->_lang = detectedLang;
913  				buffer->doNotify(BufferChangeFilename | BufferChangeTimestamp | BufferChangeLanguage);
914  			}
915  		}
916  		buffer->setDirty(false);
917  		buffer->setUnsync(false);
918  		buffer->setSavePointDirty(false);
919  		buffer->setStatus(DOC_REGULAR);
920  		buffer->checkFileState();
921  		_pscratchTilla->execute(SCI_SETSAVEPOINT);
922  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
923  		generic_string backupFilePath = buffer->getBackupFileName();
924  		if (!backupFilePath.empty())
925  		{
926  			buffer->setBackupFileName(generic_string());
927  			::DeleteFile(backupFilePath.c_str());
928  		}
929  		return SavingStatus::SaveOK;
930  	}
931  	else
932  	{
933  		return SavingStatus::SaveOpenFailed;
934  	}
935  }
936  size_t FileManager::nextUntitledNewNumber() const
937  {
938  	std::vector<size_t> usedNumbers;
939  	for (size_t i = 0; i < _buffers.size(); i++)
940  	{
941  		Buffer *buf = _buffers.at(i);
942  		if (buf->isUntitled())
943  		{
944  			bool isVisible = false;
945  			for (size_t k = 0; k < buf->_referees.size(); k++)
946  			{
947  				if (buf->_referees[k]->isVisible())
948  				{
949  					isVisible = true;
950  					break;
951  				}
952  			}
953  			if (isVisible)
954  			{
955  				if (buf->indexOfReference(_pNotepadPlus->_pEditView) > -1 || buf->indexOfReference(_pNotepadPlus->_pNonEditView) > -1)
956  				{
957  					generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
958  					TCHAR* numberStr = buf->_fileName + newTitle.length();
959  					int usedNumber = _wtoi(numberStr);
960  					usedNumbers.push_back(usedNumber);
961  				}
962  			}
963  		}
964  	}
965  	size_t newNumber = 1;
966  	bool numberAvailable = true;
967  	bool found = false;
968  	do
969  	{
970  		for (size_t j = 0; j < usedNumbers.size(); j++)
971  		{
972  			numberAvailable = true;
973  			found = false;
974  			if (usedNumbers[j] == newNumber)
975  			{
976  				numberAvailable = false;
977  				found = true;
978  				break;
979  			}
980  		}
981  		if (!numberAvailable)
982  			newNumber++;
983  		if (!found)
984  			break;
985  	} while (!numberAvailable);
986  	return newNumber;
987  }
988  BufferID FileManager::newEmptyDocument()
989  {
990  	generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
991  	TCHAR nb[10];
992  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
993  	newTitle += nb;
994  	Document doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT);	
995  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
996  	NppParameters& nppParamInst = NppParameters::getInstance();
997  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
998  	newBuf->_lang = ndds._lang;
999  	BufferID id = newBuf;
1000  	newBuf->_id = id;
1001  	_buffers.push_back(newBuf);
1002  	++_nbBufs;
1003  	++_nextBufferID;
1004  	return id;
1005  }
1006  BufferID FileManager::bufferFromDocument(Document doc, bool dontIncrease, bool dontRef)
1007  {
1008  	NppParameters& nppParamInst = NppParameters::getInstance();
1009  	generic_string newTitle = (nppParamInst.getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
1010  	TCHAR nb[10];
1011  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
1012  	newTitle += nb;
1013  	if (!dontRef)
1014  		_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, doc);	
1015  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
1016  	BufferID id = newBuf;
1017  	newBuf->_id = id;
1018  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
1019  	newBuf->_lang = ndds._lang;
1020  	_buffers.push_back(newBuf);
1021  	++_nbBufs;
1022  	if (!dontIncrease)
1023  		++_nextBufferID;
1024  	return id;
1025  }
1026  int FileManager::detectCodepage(char* buf, size_t len)
1027  {
1028  	int codepage = -1;
1029  	uchardet_t ud = uchardet_new();
1030  	uchardet_handle_data(ud, buf, len);
1031  	uchardet_data_end(ud);
1032  	const char* cs = uchardet_get_charset(ud);
1033  	if (stricmp(cs, "TIS-620") != 0) 
1034  		codepage = EncodingMapper::getInstance().getEncodingFromString(cs);
1035  	uchardet_delete(ud);
1036  	return codepage;
1037  }
1038  LangType FileManager::detectLanguageFromTextBegining(const unsigned char *data, size_t dataLen)
1039  {
1040  	struct FirstLineLanguages
1041  	{
1042  		std::string pattern;
1043  		LangType lang;
1044  	};
1045  	if (dataLen <= 3)
1046  		return L_TEXT;
1047  	size_t i = 0;
1048  	if ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) || 
1049  		(data[0] == 0xFE && data[1] == 0xFF && data[2] == 0x00) || 
1050  		(data[0] == 0xFF && data[1] == 0xFE && data[2] == 0x00))   
1051  		i += 3;
1052  	for (; i < dataLen; ++i)
1053  	{
1054  		if (data[i] != ' ' && data[i] != '\t' && data[i] != '\n' && data[i] != '\r')
1055  			break;
1056  	}
1057  	const size_t longestLength = 40; 
1058  	std::string buf2Test = std::string((const char *)data + i, longestLength);
1059  	auto cr = buf2Test.find("\r");
1060  	auto nl = buf2Test.find("\n");
1061  	auto crnl = std::min<size_t>(cr, nl);
1062  	if (crnl != std::string::npos && crnl < longestLength)
1063  		buf2Test = std::string((const char *)data + i, crnl);
1064  	std::string shebang = "#!";
1065  	size_t foundPos = buf2Test.find(shebang);
1066  	if (foundPos == 0)
1067  	{
1068  		const size_t NB_SHEBANG_LANGUAGES = 6;
1069  		FirstLineLanguages ShebangLangs[NB_SHEBANG_LANGUAGES] = {
1070  			{ "sh",		L_BASH },
1071  			{ "python", L_PYTHON },
1072  			{ "perl",	L_PERL },
1073  			{ "php",	L_PHP },
1074  			{ "ruby",	L_RUBY },
1075  			{ "node",	L_JAVASCRIPT }
1076  		};
1077  		for (i = 0; i < NB_SHEBANG_LANGUAGES; ++i)
1078  		{
1079  			if (buf2Test.find(ShebangLangs[i].pattern) != std::string::npos)
1080  			{
1081  				return ShebangLangs[i].lang;
1082  			}
1083  		}
1084  		return L_TEXT;
1085  	}
1086  	const size_t NB_FIRST_LINE_LANGUAGES = 5;
1087  	FirstLineLanguages languages[NB_FIRST_LINE_LANGUAGES] = {
1088  		{ "<?xml",			L_XML },
1089  		{ "<?php",			L_PHP },
1090  		{ "<html",			L_HTML },
1091  		{ "<!DOCTYPE html",	L_HTML },
1092  		{ "<?",				L_PHP } 
1093  	};
1094  	for (i = 0; i < NB_FIRST_LINE_LANGUAGES; ++i)
1095  	{
1096  		foundPos = buf2Test.find(languages[i].pattern);
1097  		if (foundPos == 0)
1098  		{
1099  			return languages[i].lang;
1100  		}
1101  	}
1102  	return L_TEXT;
1103  }
1104  bool FileManager::loadFileData(Document doc, int64_t fileSize, const TCHAR * filename, char* data, Utf8_16_Read * unicodeConvertor, LoadedFileFormat& fileFormat)
1105  {
1106  	FILE *fp = _wfopen(filename, TEXT("rb"));
1107  	if (!fp)
1108  		return false;
1109  	int64_t bufferSizeRequested = fileSize + std::min<int64_t>(1LL << 20, fileSize / 6);
1110  	NppParameters& nppParam = NppParameters::getInstance();
1111  	NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1112  	if (bufferSizeRequested > INT_MAX)
1113  	{
1114  		if (nppParam.archType() == IMAGE_FILE_MACHINE_I386)
1115  		{
1116  			pNativeSpeaker->messageBox("FileTooBigToOpen",
1117  				_pNotepadPlus->_pEditView->getHSelf(),
1118  				TEXT("File is too big to be opened by Notepad++"),
1119  				TEXT("File size problem"),
1120  				MB_OK | MB_APPLMODAL);
1121  			fclose(fp);
1122  			return false;
1123  		}
1124  		else 
1125  		{
1126  			int res = pNativeSpeaker->messageBox("WantToOpenHugeFile",
1127  				_pNotepadPlus->_pEditView->getHSelf(),
1128  				TEXT("Opening a huge file of 2GB+ could take several minutes.\nDo you want to open it?"),
1129  				TEXT("Opening huge file warning"),
1130  				MB_YESNO | MB_APPLMODAL);
1131  			if (res == IDYES)
1132  			{
1133  			}
1134  			else
1135  			{
1136  				fclose(fp);
1137  				return false;
1138  			}
1139  		}
1140  	}
1141  	_pscratchTilla->execute(SCI_SETSTATUS, SC_STATUS_OK); 
1142  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, doc);
1143  	bool ro = _pscratchTilla->execute(SCI_GETREADONLY) != 0;
1144  	if (ro)
1145  	{
1146  		_pscratchTilla->execute(SCI_SETREADONLY, false);
1147  	}
1148  	_pscratchTilla->execute(SCI_CLEARALL);
1149  	if (fileFormat._language < L_EXTERNAL)
1150  	{
1151  		const char* lexerNameID = ScintillaEditView::_langNameInfoArray[fileFormat._language]._lexerID;
1152  		_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(CreateLexer(lexerNameID)));
1153  	}
1154  	else
1155  	{
1156  		int id = fileFormat._language - L_EXTERNAL;
1157  		ExternalLangContainer& externalLexer = nppParam.getELCFromIndex(id);
1158  		const char* lexerName = externalLexer._name.c_str();
1159  		if (externalLexer.fnCL)
1160  			_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(externalLexer.fnCL(lexerName)));
1161  	}
1162  	if (fileFormat._encoding != -1)
1163  		_pscratchTilla->execute(SCI_SETCODEPAGE, SC_CP_UTF8);
1164  	bool success = true;
1165  	EolType format = EolType::unknown;
1166  	int sciStatus = SC_STATUS_OK;
1167  	TCHAR szException[64] = { '\0' };
1168  	__try
1169  	{
1170  		_pscratchTilla->execute(SCI_ALLOCATE, WPARAM(bufferSizeRequested));
1171  		sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1172  		if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1173  			throw std::runtime_error("Scintilla error");
1174  		size_t lenFile = 0;
1175  		size_t lenConvert = 0;	
1176  		bool isFirstTime = true;
1177  		int incompleteMultibyteChar = 0;
1178  		do
1179  		{
1180  			lenFile = fread(data + incompleteMultibyteChar, 1, blockSize - incompleteMultibyteChar, fp) + incompleteMultibyteChar;
1181  			if (ferror(fp) != 0)
1182  			{
1183  				success = false;
1184  				break;
1185  			}
1186  			if (lenFile == 0) break;
1187              if (isFirstTime)
1188              {
1189  				NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
1190                  if (Utf8_16_Read::determineEncoding((unsigned char *)data, lenFile) != uni8Bit)
1191                  {
1192  					fileFormat._encoding = -1;
1193  				}
1194  				else if (fileFormat._encoding == -1)
1195  				{
1196  					if (nppGui._detectEncoding)
1197  						fileFormat._encoding = detectCodepage(data, lenFile);
1198                  }
1199  				bool isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
1200  				if (!isLargeFile && fileFormat._language == L_TEXT)
1201  				{
1202  					fileFormat._language = detectLanguageFromTextBegining((unsigned char *)data, lenFile);
1203  				}
1204                  isFirstTime = false;
1205              }
1206  			if (fileFormat._encoding != -1)
1207  			{
1208  				if (fileFormat._encoding == SC_CP_UTF8)
1209  				{
1210  					_pscratchTilla->execute(SCI_APPENDTEXT, lenFile, reinterpret_cast<LPARAM>(data));
1211  				}
1212  				else
1213  				{
1214  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1215  					int newDataLen = 0;
1216  					const char *newData = wmc.encode(fileFormat._encoding, SC_CP_UTF8, data, static_cast<int32_t>(lenFile), &newDataLen, &incompleteMultibyteChar);
1217  					_pscratchTilla->execute(SCI_APPENDTEXT, newDataLen, reinterpret_cast<LPARAM>(newData));
1218  				}
1219  				if (format == EolType::unknown)
1220  					format = getEOLFormatForm(data, lenFile, EolType::unknown);
1221  			}
1222  			else
1223  			{
1224  				lenConvert = unicodeConvertor->convert(data, lenFile);
1225  				_pscratchTilla->execute(SCI_APPENDTEXT, lenConvert, reinterpret_cast<LPARAM>(unicodeConvertor->getNewBuf()));
1226  				if (format == EolType::unknown)
1227  					format = getEOLFormatForm(unicodeConvertor->getNewBuf(), unicodeConvertor->getNewSize(), EolType::unknown);
1228  			}
1229  			sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1230  			if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1231  				throw std::runtime_error("Scintilla error");
1232  			if (incompleteMultibyteChar != 0)
1233  			{
1234  				memcpy(data, data + blockSize - incompleteMultibyteChar, incompleteMultibyteChar);
1235  			}
1236  		}
1237  		while (lenFile > 0);
1238  	}
1239  	__except(EXCEPTION_EXECUTE_HANDLER)
1240  	{
1241  		switch (sciStatus)
1242  		{
1243  			case SC_STATUS_OK:
1244  #if defined(__GNUC__)
1245  				_stprintf_s(szException, _countof(szException), TEXT("unknown exception"));
1246  #else
1247  				_stprintf_s(szException, _countof(szException), TEXT("0x%X (SEH)"), ::GetExceptionCode());
1248  #endif
1249  				break;
1250  			case SC_STATUS_BADALLOC:
1251  			{
1252  				pNativeSpeaker->messageBox("FileTooBigToOpen",
1253  					_pNotepadPlus->_pEditView->getHSelf(),
1254  					TEXT("File is too big to be opened by Notepad++"),
1255  					TEXT("Exception: File size problem"),
1256  					MB_OK | MB_APPLMODAL);
1257  			}
1258  			[[fallthrough]];
1259  			case SC_STATUS_FAILURE:
1260  			default:
1261  				_stprintf_s(szException, _countof(szException), TEXT("%d (Scintilla)"), sciStatus);
1262  				break;
1263  		}
1264  		if (sciStatus != SC_STATUS_BADALLOC)
1265  		{
1266  			pNativeSpeaker->messageBox("FileLoadingException",
1267  				_pNotepadPlus->_pEditView->getHSelf(),
1268  				TEXT("An error occurred while loading the file!"),
1269  				TEXT("Exception code: $STR_REPLACE$"),
1270  				MB_OK | MB_APPLMODAL,
1271  				0,
1272  				szException);
1273  		}
1274  		success = false;
1275  	}
1276  	fclose(fp);
1277  	if (format == EolType::unknown)
1278  	{
1279  		const NewDocDefaultSettings & ndds = (nppParam.getNppGUI()).getNewDocDefaultSettings(); 
1280  		fileFormat._eolFormat = ndds._format;
1281  		if ((fileSize == 0) && (fileFormat._encoding < 1))
1282  		{
1283  			if (ndds._unicodeMode == uniCookie && ndds._openAnsiAsUtf8)
1284  				fileFormat._encoding = SC_CP_UTF8;
1285  		}
1286  	}
1287  	else
1288  	{
1289  		fileFormat._eolFormat = format;
1290  	}
1291  	_pscratchTilla->execute(SCI_EMPTYUNDOBUFFER);
1292  	_pscratchTilla->execute(SCI_SETSAVEPOINT);
1293  	if (ro)
1294  		_pscratchTilla->execute(SCI_SETREADONLY, true);
1295  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
1296  	return success;
1297  }
1298  BufferID FileManager::getBufferFromName(const TCHAR* name)
1299  {
1300  	for (auto buf : _buffers)
1301  	{
1302  		if (OrdinalIgnoreCaseCompareStrings(name, buf->getFullPathName()) == 0)
1303  		{
1304  			if (buf->_referees[0]->isVisible())
1305  			{
1306  				return buf->getID();
1307  			}
1308  		}
1309  	}
1310  	return BUFFER_INVALID;
1311  }
1312  BufferID FileManager::getBufferFromDocument(Document doc)
1313  {
1314  	for (size_t i = 0; i < _nbBufs; ++i)
1315  	{
1316  		if (_buffers[i]->_doc == doc)
1317  			return _buffers[i]->_id;
1318  	}
1319  	return BUFFER_INVALID;
1320  }
1321  bool FileManager::createEmptyFile(const TCHAR * path)
1322  {
1323  	Win32_IO_File file(path);
1324  	return file.isOpened();
1325  }
1326  int FileManager::getFileNameFromBuffer(BufferID id, TCHAR * fn2copy)
1327  {
1328  	if (getBufferIndexByID(id) == -1)
1329  		return -1;
1330  	Buffer* buf = getBufferByID(id);
1331  	if (fn2copy)
1332  		lstrcpy(fn2copy, buf->getFullPathName());
1333  	return lstrlen(buf->getFullPathName());
1334  }
1335  size_t FileManager::docLength(Buffer* buffer) const
1336  {
1337  	Document curDoc = _pscratchTilla->execute(SCI_GETDOCPOINTER);
1338  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);
1339  	size_t docLen = _pscratchTilla->getCurrentDocLen();
1340  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, curDoc);
1341  	return docLen;
1342  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</h3>
            <pre><code>1  #include <deque>
2  #include <algorithm>
3  #include <time.h>
4  #include <locale>
5  #include <codecvt>
6  #include <sys/stat.h>
7  #include "Buffer.h"
8  #include "Scintilla.h"
9  #include "ILexer.h"
10  #include "Lexilla.h"
11  #include "Parameters.h"
12  #include "Notepad_plus.h"
13  #include "ScintillaEditView.h"
14  #include "EncodingMapper.h"
15  #include "uchardet.h"
16  #include "FileInterface.h"
17  static const int blockSize = 128 * 1024 + 4;
18  static const int CR = 0x0D;
19  static const int LF = 0x0A;
20  long Buffer::_recentTagCtr = 0;
21  namespace 
22  {
23  	static EolType getEOLFormatForm(const char* const data, size_t length, EolType defvalue = EolType::osdefault)
24  	{
25  		assert(length == 0 || (data != nullptr && "invalid buffer for getEOLFormatForm()"));
26  		for (size_t i = 0; i != length; ++i)
27  		{
28  			if (data[i] == CR)
29  			{
30  				if (i + 1 < length && data[i + 1] == LF)
31  					return EolType::windows;
32  				return EolType::macos;
33  			}
34  			if (data[i] == LF)
35  				return EolType::unix;
36  		}
37  		return defvalue; 
38  	}
39  } 
40  Buffer::Buffer(FileManager * pManager, BufferID id, Document doc, DocFileStatus type, const TCHAR *fileName, bool isLargeFile)
41  	: _pManager(pManager) , _id(id), _doc(doc), _lang(L_TEXT), _isLargeFile(isLargeFile)
42  {
43  	NppParameters& nppParamInst = NppParameters::getInstance();
44  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
45  	_eolFormat = ndds._format;
46  	_unicodeMode = ndds._unicodeMode;
47  	_encoding = ndds._codepage;
48  	if (_encoding != -1)
49  		_unicodeMode = uniCookie;
50  	_currentStatus = type;
51  	setFileName(fileName);
52  	updateTimeStamp();
53  	checkFileState();
54  	_canNotify = true;
55  }
56  void Buffer::doNotify(int mask)
57  {
58  	if (_canNotify)
59  	{
60  		assert(_pManager != nullptr);
61  		_pManager->beNotifiedOfBufferChange(this, mask);
62  	}
63  }
64  void Buffer::setDirty(bool dirty)
65  {
66  	_isDirty = dirty;
67  	doNotify(BufferChangeDirty);
68  }
69  void Buffer::setEncoding(int encoding)
70  {
71  	_encoding = encoding;
72  	doNotify(BufferChangeUnicode | BufferChangeDirty);
73  }
74  void Buffer::setUnicodeMode(UniMode mode)
75  {
76  	_unicodeMode = mode;
77  	doNotify(BufferChangeUnicode | BufferChangeDirty);
78  }
79  void Buffer::setLangType(LangType lang, const TCHAR* userLangName)
80  {
81  	if (lang == _lang && lang != L_USER)
82  		return;
83  	_lang = lang;
84  	if (_lang == L_USER)
85  		_userLangExt = userLangName;
86  	_needLexer = true;	
87  	doNotify(BufferChangeLanguage|BufferChangeLexing);
88  }
89  void Buffer::updateTimeStamp()
90  {
91  	FILETIME timeStampLive = {};
92  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
93  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
94  	{
95  		timeStampLive = attributes.ftLastWriteTime;
96  	}
97  	LONG res = CompareFileTime(&_timeStamp, &timeStampLive);
98  	if (res == -1 || res == 1)
99  	{
100  		if (res == 1)
101  		{
102  			NppParameters& nppParam = NppParameters::getInstance();
103  			if (nppParam.doNppLogNetworkDriveIssue())
104  			{
105  				generic_string issueFn = nppLogNetworkDriveIssue;
106  				issueFn += TEXT(".log");
107  				generic_string nppIssueLog = nppParam.getUserPath();
108  				pathAppend(nppIssueLog, issueFn);
109  				std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
110  				std::string msg = converter.to_bytes(_fullPathName);
111  				char buf[1024];
112  				sprintf(buf, "  in updateTimeStamp(): timeStampLive (%lu/%lu) < _timeStamp (%lu/%lu)", timeStampLive.dwLowDateTime, timeStampLive.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
113  				msg += buf;
114  				writeLog(nppIssueLog.c_str(), msg.c_str());
115  			}
116  		}
117  		_timeStamp = timeStampLive;
118  		doNotify(BufferChangeTimestamp);
119  	}
120  }
121  void Buffer::setFileName(const TCHAR *fn)
122  {
123  	NppParameters& nppParamInst = NppParameters::getInstance();
124  	if (_fullPathName == fn)
125  	{
126  		updateTimeStamp();
127  		doNotify(BufferChangeTimestamp);
128  		return;
129  	}
130  	_fullPathName = fn;
131  	_fileName = PathFindFileName(_fullPathName.c_str());
132  	LangType determinatedLang = L_TEXT;
133  	TCHAR *ext = PathFindExtension(_fullPathName.c_str());
134  	if (*ext == '.') 
135  	{
136  		ext += 1;
137  		const TCHAR* langName = nppParamInst.getUserDefinedLangNameFromExt(ext, _fileName);
138  		if (langName)
139  		{
140  			determinatedLang = L_USER;
141  			_userLangExt = langName;
142  		}
143  		else 
144  		{
145  			_userLangExt.clear();
146  			determinatedLang = nppParamInst.getLangFromExt(ext);
147  		}
148  	}
149  	if (determinatedLang == L_TEXT)	
150  	{
151  		if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("makefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("GNUmakefile")) == 0))
152  			determinatedLang = L_MAKEFILE;
153  		else if (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("CmakeLists.txt")) == 0)
154  			determinatedLang = L_CMAKE;
155  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConstruct")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConscript")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("wscript")) == 0))
156  			determinatedLang = L_PYTHON;
157  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Rakefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Vagrantfile")) == 0))
158  			determinatedLang = L_RUBY;
159  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("crontab")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("PKGBUILD")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("APKBUILD")) == 0))
160  			determinatedLang = L_BASH;
161  	}
162  	updateTimeStamp();
163  	BufferStatusInfo lang2Change = BufferChangeNone;
164  	if (!_hasLangBeenSetFromMenu && (determinatedLang != _lang || _lang == L_USER))
165  	{
166  		if (_isLargeFile)
167  		{
168  			_lang = L_TEXT;
169  		}
170  		else
171  		{
172  			_lang = determinatedLang;
173  			lang2Change = BufferChangeLanguage;
174  		}
175  	}
176  	doNotify(BufferChangeFilename | BufferChangeTimestamp | lang2Change);
177  }
178  bool Buffer::checkFileState() 
179  {
180  	if (_currentStatus == DOC_UNNAMED || isMonitoringOn())
181  		return false;
182  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
183  	bool isWow64Off = false;
184  	NppParameters& nppParam = NppParameters::getInstance();
185  	if (!PathFileExists(_fullPathName.c_str()))
186  	{
187  		nppParam.safeWow64EnableWow64FsRedirection(FALSE);
188  		isWow64Off = true;
189  	}
190  	bool isOK = false;
191  	if (_currentStatus != DOC_DELETED && !PathFileExists(_fullPathName.c_str()))	
192  	{
193  		_currentStatus = DOC_DELETED;
194  		_isFileReadOnly = false;
195  		_isDirty = true;	
196  		_timeStamp = {};
197  		doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
198  		isOK = true;
199  	}
200  	else if (_currentStatus == DOC_DELETED && PathFileExists(_fullPathName.c_str()))
201  	{	
202  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
203  		{
204  			_isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
205  			_currentStatus = DOC_MODIFIED;
206  			_timeStamp = attributes.ftLastWriteTime;
207  			if (_reloadFromDiskRequestGuard.try_lock())
208  			{
209  				doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
210  				_reloadFromDiskRequestGuard.unlock();
211  			}
212  			isOK = true;
213  		}
214  	}
215  	else if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
216  	{
217  		int mask = 0;	
218  		bool isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
219  		if (isFileReadOnly != _isFileReadOnly)
220  		{
221  			_isFileReadOnly = isFileReadOnly;
222  			mask |= BufferChangeReadonly;
223  		}
224  		LONG res = CompareFileTime(&_timeStamp, &attributes.ftLastWriteTime);
225  		if (res == -1 || res == 1)
226  		{
227  			if (res == 1)
228  			{
229  				NppParameters& nppParam = NppParameters::getInstance();
230  				if (nppParam.doNppLogNetworkDriveIssue())
231  				{
232  					generic_string issueFn = nppLogNetworkDriveIssue;
233  					issueFn += TEXT(".log");
234  					generic_string nppIssueLog = nppParam.getUserPath();
235  					pathAppend(nppIssueLog, issueFn);
236  					std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
237  					std::string msg = converter.to_bytes(_fullPathName);
238  					char buf[1024];
239  					sprintf(buf, "  in checkFileState(): attributes.ftLastWriteTime (%lu/%lu) < _timeStamp (%lu/%lu)", attributes.ftLastWriteTime.dwLowDateTime, attributes.ftLastWriteTime.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
240  					msg += buf;
241  					writeLog(nppIssueLog.c_str(), msg.c_str());
242  				}
243  			}
244  			_timeStamp = attributes.ftLastWriteTime;
245  			mask |= BufferChangeTimestamp;
246  			_currentStatus = DOC_MODIFIED;
247  			mask |= BufferChangeStatus;	
248  		}
249  		if (mask != 0)
250  		{
251  			if (_reloadFromDiskRequestGuard.try_lock())
252  			{
253  				doNotify(mask);
254  				_reloadFromDiskRequestGuard.unlock();
255  				return true;
256  			}
257  		}
258  		return false;
259  	}
260  	if (isWow64Off)
261  	{
262  		nppParam.safeWow64EnableWow64FsRedirection(TRUE);
263  	}
264  	return isOK;
265  }
266  void Buffer::reload()
267  {
268  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
269  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
270  	{
271  		_timeStamp = attributes.ftLastWriteTime;
272  		_currentStatus = DOC_NEEDRELOAD;
273  		doNotify(BufferChangeTimestamp | BufferChangeStatus);
274  	}
275  }
276  int64_t Buffer::getFileLength() const
277  {
278  	if (_currentStatus == DOC_UNNAMED)
279  		return -1;
280  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
281  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
282  	{
283  		LARGE_INTEGER size{};
284  		size.LowPart = attributes.nFileSizeLow;
285  		size.HighPart = attributes.nFileSizeHigh;
286  		return size.QuadPart;
287  	}
288  	return -1;
289  }
290  generic_string Buffer::getFileTime(fileTimeType ftt) const
291  {
292  	generic_string result;
293  	if (_currentStatus != DOC_UNNAMED)
294  	{
295  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
296  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
297  		{
298  			FILETIME rawtime;
299  			switch (ftt)
300  			{
301  				case ft_created:
302  					rawtime = attributes.ftCreationTime;
303  					break;
304  				case ft_modified:
305  					rawtime = attributes.ftLastWriteTime;
306  					break;
307  				default:
308  					rawtime = attributes.ftLastAccessTime;
309  					break;
310  			}
311  			SYSTEMTIME utcSystemTime, localSystemTime;
312  			FileTimeToSystemTime(&rawtime, &utcSystemTime);
313  			SystemTimeToTzSpecificLocalTime(nullptr, &utcSystemTime, &localSystemTime);
314  			const size_t dateTimeStrLen = 256;
315  			TCHAR bufDate[dateTimeStrLen] = {'\0'};
316  			GetDateFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufDate, dateTimeStrLen);
317  			result += bufDate;
318  			result += ' ';
319  			TCHAR bufTime[dateTimeStrLen] = {'\0'};
320  			GetTimeFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufTime, dateTimeStrLen);
321  			result += bufTime;
322  		}
323  	}
324  	return result;
325  }
326  void Buffer::setPosition(const Position & pos, ScintillaEditView * identifier)
327  {
328  	int index = indexOfReference(identifier);
329  	if (index == -1)
330  		return;
331  	_positions[index] = pos;
332  }
333  Position& Buffer::getPosition(ScintillaEditView* identifier)
334  {
335  	int index = indexOfReference(identifier);
336  	return _positions.at(index);
337  }
338  void Buffer::setHeaderLineState(const std::vector<size_t> & folds, ScintillaEditView * identifier)
339  {
340  	int index = indexOfReference(identifier);
341  	if (index == -1)
342  		return;
343  	std::vector<size_t> & local = _foldStates[index];
344  	local.clear();
345  	size_t size = folds.size();
346  	for (size_t i = 0; i < size; ++i)
347  		local.push_back(folds[i]);
348  }
349  const std::vector<size_t> & Buffer::getHeaderLineState(const ScintillaEditView * identifier) const
350  {
351  	int index = indexOfReference(identifier);
352  	return _foldStates.at(index);
353  }
354  Lang * Buffer::getCurrentLang() const
355  {
356  	NppParameters& nppParam = NppParameters::getInstance();
357  	int i = 0;
358  	Lang *l = nppParam.getLangFromIndex(i);
359  	++i;
360  	while (l)
361  	{
362  		if (l->_langID == _lang)
363  			return l;
364  		l = nppParam.getLangFromIndex(i);
365  		++i;
366  	}
367  	return nullptr;
368  }
369  int Buffer::indexOfReference(const ScintillaEditView * identifier) const
370  {
371  	size_t size = _referees.size();
372  	for (size_t i = 0; i < size; ++i)
373  	{
374  		if (_referees[i] == identifier)
375  			return static_cast<int>(i);
376  	}
377  	return -1;	
378  }
379  int Buffer::addReference(ScintillaEditView * identifier)
380  {
381  	if (indexOfReference(identifier) != -1)
382  		return _references;
383  	_referees.push_back(identifier);
384  	_positions.push_back(Position());
385  	_foldStates.push_back(std::vector<size_t>());
386  	++_references;
387  	return _references;
388  }
389  int Buffer::removeReference(ScintillaEditView * identifier)
390  {
391  	int indexToPop = indexOfReference(identifier);
392  	if (indexToPop == -1)
393  		return _references;
394  	_referees.erase(_referees.begin() + indexToPop);
395  	_positions.erase(_positions.begin() + indexToPop);
396  	_foldStates.erase(_foldStates.begin() + indexToPop);
397  	_references--;
398  	return _references;
399  }
400  void Buffer::setHideLineChanged(bool isHide, size_t location)
401  {
402  	for (int i = 0; i < _references; ++i)
403  		_referees.at(i)->notifyMarkers(this, isHide, location, false); 
404  	if (!isHide) 
405  	{
406  		for (int i = 0; i < _references; ++i)
407  			_referees.at(i)->notifyMarkers(this, isHide, location, true);
408  	}
409  }
410  void Buffer::setDeferredReload() 
411  {
412  	_isDirty = false;	
413  	_needReloading = true;
414  	doNotify(BufferChangeDirty);
415  }
416  bool Buffer::allowBraceMach() const
417  {
418  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
419  	return (!_isLargeFile || nppGui._largeFileRestriction._allowBraceMatch) || !nppGui._largeFileRestriction._isEnabled;
420  }
421  bool Buffer::allowAutoCompletion() const
422  {
423  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
424  	return (!_isLargeFile || nppGui._largeFileRestriction._allowAutoCompletion) || !nppGui._largeFileRestriction._isEnabled;
425  }
426  bool Buffer::allowSmartHilite() const
427  {
428  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
429  	return (!_isLargeFile || nppGui._largeFileRestriction._allowSmartHilite) || !nppGui._largeFileRestriction._isEnabled;
430  }
431  bool Buffer::allowClickableLink() const
432  {
433  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
434  	return (!_isLargeFile || nppGui._largeFileRestriction._allowClickableLink) || !nppGui._largeFileRestriction._isEnabled;
435  }
436  FileManager::~FileManager()
437  {
438  	for (std::vector<Buffer *>::iterator it = _buffers.begin(), end = _buffers.end(); it != end; ++it)
439  	{
440  		delete *it;
441  	}
442  }
443  void FileManager::init(Notepad_plus * pNotepadPlus, ScintillaEditView * pscratchTilla)
444  {
445  	_pNotepadPlus = pNotepadPlus;
446  	_pscratchTilla = pscratchTilla;
447  	_pscratchTilla->execute(SCI_SETUNDOCOLLECTION, false);	
448  	_scratchDocDefault = (Document)_pscratchTilla->execute(SCI_GETDOCPOINTER);
449  	_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, _scratchDocDefault);
450  }
451  void FileManager::checkFilesystemChanges(bool bCheckOnlyCurrentBuffer)
452  {
453  	if (bCheckOnlyCurrentBuffer)
454  	{
455  		Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
456  		buffer->checkFileState();
457  	}
458  	else
459  	{
460  		for (int i = int(_nbBufs) - 1; i >= 0; i--)
461  		{
462  			if (i >= int(_nbBufs))
463  			{
464  				if (_nbBufs == 0)
465  					return;
466  				i = int(_nbBufs) - 1;
467  			}
468  			_buffers[i]->checkFileState();	
469  		}
470  	}
471  }
472  size_t FileManager::getNbDirtyBuffers() const
473  {
474  	size_t nb_dirtyBufs = 0;
475  	for (size_t i = 0; i < _nbBufs; ++i)
476  	{
477  		if (_buffers[i]->_isDirty)
478  			++nb_dirtyBufs;
479  	}
480  	return nb_dirtyBufs;
481  }
482  int FileManager::getBufferIndexByID(BufferID id)
483  {
484  	for (size_t i = 0; i < _nbBufs; ++i)
485  	{
486  		if (_buffers[i]->_id == id)
487  			return static_cast<int>(i);
488  	}
489  	return -1;
490  }
491  Buffer* FileManager::getBufferByIndex(size_t index)
492  {
493  	if (index >= _buffers.size())
494  		return nullptr;
495  	return _buffers.at(index);
496  }
497  void FileManager::beNotifiedOfBufferChange(Buffer* theBuf, int mask)
498  {
499  	_pNotepadPlus->notifyBufferChanged(theBuf, mask);
500  }
501  void FileManager::addBufferReference(BufferID buffer, ScintillaEditView * identifier)
502  {
503  	Buffer* buf = getBufferByID(buffer);
504  	buf->addReference(identifier);
505  }
506  void FileManager::closeBuffer(BufferID id, ScintillaEditView * identifier)
507  {
508  	int index = getBufferIndexByID(id);
509  	Buffer* buf = getBufferByIndex(index);
510  	int refs = buf->removeReference(identifier);
511  	if (!refs) 
512  	{
513  		_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, buf->_doc);	
514  		_buffers.erase(_buffers.begin() + index);
515  		delete buf;
516  		_nbBufs--;
517  	}
518  }
519  BufferID FileManager::loadFile(const TCHAR* filename, Document doc, int encoding, const TCHAR* backupFileName, FILETIME fileNameTimestamp)
520  {
521  	if (!filename)
522  		return BUFFER_INVALID;
523  	int64_t fileSize = -1;
524  	const TCHAR* pPath = filename;
525  	if (!::PathFileExists(pPath))
526  	{
527  		pPath = backupFileName;
528  	}
529  	if (pPath)
530  	{
531  		FILE* fp = _wfopen(pPath, TEXT("rb"));
532  		if (fp)
533  		{
534  			_fseeki64(fp, 0, SEEK_END);
535  			fileSize = _ftelli64(fp);
536  			fclose(fp);
537  		}
538  	}
539  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
540  	bool isLargeFile = false;
541  	if (nppGui._largeFileRestriction._isEnabled)
542  		isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
543  	if (isLargeFile && nppGui._largeFileRestriction._deactivateWordWrap)
544  	{
545  		bool isWrap = _pNotepadPlus->_pEditView->isWrap();
546  		if (isWrap)
547  		{
548  			_pNotepadPlus->command(IDM_VIEW_WRAP);
549  		}
550  	}
551  	bool ownDoc = false;
552  	if (!doc)
553  	{
554  		doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT, 0, isLargeFile ? SC_DOCUMENTOPTION_STYLES_NONE | SC_DOCUMENTOPTION_TEXT_LARGE : 0);
555  		ownDoc = true;
556  	}
557  	WCHAR fullpath[MAX_PATH] = { 0 };
558  	if (isWin32NamespacePrefixedFileName(filename))
559  	{
560  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
561  	}
562  	else
563  	{
564  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
565  		if (wcschr(fullpath, '~'))
566  		{
567  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
568  		}
569  	}
570  	bool isSnapshotMode = backupFileName != NULL && PathFileExists(backupFileName);
571  	if (isSnapshotMode && !PathFileExists(fullpath)) 
572  	{
573  		wcscpy_s(fullpath, MAX_PATH, filename); 
574  	}
575  	Utf8_16_Read UnicodeConvertor;	
576  	char* data = new char[blockSize + 8]; 
577  	LoadedFileFormat loadedFileFormat;
578  	loadedFileFormat._encoding = encoding;
579  	loadedFileFormat._eolFormat = EolType::unknown;
580  	loadedFileFormat._language = L_TEXT;
581  	bool res = loadFileData(doc, fileSize, backupFileName ? backupFileName : fullpath, data, &UnicodeConvertor, loadedFileFormat);
582  	delete[] data;
583  	if (res)
584  	{
585  		Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_REGULAR, fullpath, isLargeFile);
586  		BufferID id = newBuf;
587  		newBuf->_id = id;
588  		if (backupFileName != NULL)
589  		{
590  			newBuf->_backupFileName = backupFileName;
591  			if (!PathFileExists(fullpath))
592  				newBuf->_currentStatus = DOC_UNNAMED;
593  		}
594  		const FILETIME zeroTimeStamp = {};
595  		LONG res = CompareFileTime(&fileNameTimestamp, &zeroTimeStamp);
596  		if (res != 0) 
597  			newBuf->_timeStamp = fileNameTimestamp;
598  		_buffers.push_back(newBuf);
599  		++_nbBufs;
600  		Buffer* buf = _buffers.at(_nbBufs - 1);
601  		buf->setEncoding(-1);
602  		if (!newBuf->_isLargeFile && ((buf->getLangType() == L_TEXT) && (loadedFileFormat._language != L_TEXT)))
603  			buf->setLangType(loadedFileFormat._language);
604  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
605  		++_nextBufferID;
606  		return id;
607  	}
608  	else 
609  	{
610  		if (ownDoc)
611  			_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, doc);	
612  		return BUFFER_INVALID;
613  	}
614  }
615  bool FileManager::reloadBuffer(BufferID id)
616  {
617  	Buffer* buf = getBufferByID(id);
618  	Document doc = buf->getDocument();
619  	Utf8_16_Read UnicodeConvertor;
620  	LoadedFileFormat loadedFileFormat;
621  	loadedFileFormat._encoding = buf->getEncoding();
622  	loadedFileFormat._eolFormat = EolType::unknown;
623  	loadedFileFormat._language = buf->getLangType();
624  	buf->setLoadedDirty(false);	
625  	FILE* fp = _wfopen(buf->getFullPathName(), TEXT("rb"));
626  	if (!fp)
627  		return false;
628  	_fseeki64(fp, 0, SEEK_END);
629  	int64_t fileSize = _ftelli64(fp);
630  	fclose(fp);
631  	char* data = new char[blockSize + 8]; 
632  	buf->_canNotify = false;	
633  	bool res = loadFileData(doc, fileSize, buf->getFullPathName(), data, &UnicodeConvertor, loadedFileFormat);
634  	buf->_canNotify = true;
635  	delete[] data;
636  	if (res)
637  	{
638  		buf->setUnsync(false);
639  		buf->setDirty(false); 
640  		buf->setSavePointDirty(false);
641  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
642  	}
643  	return res;
644  }
645  void FileManager::setLoadedBufferEncodingAndEol(Buffer* buf, const Utf8_16_Read& UnicodeConvertor, int encoding, EolType bkformat)
646  {
647  	if (encoding == -1)
648  	{
649  		NppParameters& nppParamInst = NppParameters::getInstance();
650  		const NewDocDefaultSettings & ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
651  		UniMode um = UnicodeConvertor.getEncoding();
652  		if (um == uni7Bit)
653  			um = (ndds._openAnsiAsUtf8) ? uniCookie : uni8Bit;
654  		buf->setUnicodeMode(um);
655  	}
656  	else
657  	{
658  		buf->setEncoding((encoding == SC_CP_UTF8)?-1:encoding);
659  		buf->setUnicodeMode(uniCookie);
660  	}
661  	if (bkformat != EolType::unknown)
662  		buf->setEolFormat(bkformat);
663  }
664  bool FileManager::reloadBufferDeferred(BufferID id)
665  {
666  	Buffer* buf = getBufferByID(id);
667  	buf->setDeferredReload();
668  	return true;
669  }
670  bool FileManager::deleteFile(BufferID id)
671  {
672  	Buffer* buf = getBufferByID(id);
673  	generic_string fileNamePath = buf->getFullPathName();
674  	fileNamePath.append(1, '\0');
675  	if (!PathFileExists(fileNamePath.c_str()))
676  		return false;
677  	SHFILEOPSTRUCT fileOpStruct = {};
678  	fileOpStruct.hwnd = NULL;
679  	fileOpStruct.pFrom = fileNamePath.c_str();
680  	fileOpStruct.pTo = NULL;
681  	fileOpStruct.wFunc = FO_DELETE;
682  	fileOpStruct.fFlags = FOF_ALLOWUNDO;
683  	fileOpStruct.fAnyOperationsAborted = false;
684  	fileOpStruct.hNameMappings         = NULL;
685  	fileOpStruct.lpszProgressTitle     = NULL;
686  	return SHFileOperation(&fileOpStruct) == 0;
687  }
688  bool FileManager::moveFile(BufferID id, const TCHAR * newFileName)
689  {
690  	Buffer* buf = getBufferByID(id);
691  	const TCHAR *fileNamePath = buf->getFullPathName();
692  	if (::MoveFileEx(fileNamePath, newFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH) == 0)
693  		return false;
694  	buf->setFileName(newFileName);
695  	return true;
696  }
697  std::mutex backup_mutex;
698  bool FileManager::backupCurrentBuffer()
699  {
700  	Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
701  	if (buffer->isLargeFile())
702  		return false;
703  	std::lock_guard<std::mutex> lock(backup_mutex);
704  	bool result = false;
705  	bool hasModifForSession = false;
706  	if (buffer->isDirty())
707  	{
708  		if (buffer->isModified()) 
709  		{
710  			UniMode mode = buffer->getUnicodeMode();
711  			if (mode == uniCookie)
712  				mode = uni8Bit;	
713  			Utf8_16_Write UnicodeConvertor;
714  			UnicodeConvertor.setEncoding(mode);
715  			int encoding = buffer->getEncoding();
716  			generic_string backupFilePath = buffer->getBackupFileName();
717  			if (backupFilePath.empty())
718  			{
719  				backupFilePath = NppParameters::getInstance().getUserPath();
720  				backupFilePath += TEXT("\\backup\\");
721  				if (!PathFileExists(backupFilePath.c_str()))
722  				{
723  					::CreateDirectory(backupFilePath.c_str(), NULL);
724  				}
725  				backupFilePath += buffer->getFileName();
726  				const int temBufLen = 32;
727  				TCHAR tmpbuf[temBufLen];
728  				time_t ltime = time(0);
729  				struct tm* today = localtime(&ltime);
730  				if (!today)
731  					return false;
732  				wcsftime(tmpbuf, temBufLen, L"%Y-%m-%d_%H%M%S", today);
733  				backupFilePath += L"@";
734  				backupFilePath += tmpbuf;
735  				buffer->setBackupFileName(backupFilePath);
736  				hasModifForSession = true;
737  			}
738  			TCHAR fullpath[MAX_PATH];
739  			::GetFullPathName(backupFilePath.c_str(), MAX_PATH, fullpath, NULL);
740  			if (wcschr(fullpath, '~'))
741  			{
742  				::GetLongPathName(fullpath, fullpath, MAX_PATH);
743  			}
744  			DWORD dwFileAttribs = ::GetFileAttributes(fullpath);
745  			if (dwFileAttribs & FILE_ATTRIBUTE_READONLY) 
746  			{
747  				dwFileAttribs ^= FILE_ATTRIBUTE_READONLY;
748  				::SetFileAttributes(fullpath, dwFileAttribs);
749  			}
750  			if (UnicodeConvertor.openFile(fullpath))
751  			{
752  				size_t lengthDoc = _pNotepadPlus->_pEditView->getCurrentDocLen();
753  				char* buf = (char*)_pNotepadPlus->_pEditView->execute(SCI_GETCHARACTERPOINTER);	
754  				boolean isWrittenSuccessful = false;
755  				if (encoding == -1) 
756  				{
757  					isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
758  					if (lengthDoc == 0)
759  						isWrittenSuccessful = true;
760  				}
761  				else
762  				{
763  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
764  					size_t grabSize;
765  					for (size_t i = 0; i < lengthDoc; i += grabSize)
766  					{
767  						grabSize = lengthDoc - i;
768  						if (grabSize > blockSize)
769  							grabSize = blockSize;
770  						int newDataLen = 0;
771  						int incompleteMultibyteChar = 0;
772  						const char *newData = wmc.encode(SC_CP_UTF8, encoding, buf+i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
773  						grabSize -= incompleteMultibyteChar;
774  						isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
775  					}
776  					if (lengthDoc == 0)
777  						isWrittenSuccessful = true;
778  				}
779  				UnicodeConvertor.closeFile();
780  				if (isWrittenSuccessful) 
781  				{
782  					buffer->setModifiedStatus(false);
783  					result = true;	
784  				}
785  			}
786  		}
787  		else 
788  		{
789  			result = true;
790  		}
791  	}
792  	else 
793  	{
794  		generic_string backupFilePath = buffer->getBackupFileName();
795  		if (!backupFilePath.empty())
796  		{
797  			generic_string file2Delete = buffer->getBackupFileName();
798  			buffer->setBackupFileName(generic_string());
799  			result = (::DeleteFile(file2Delete.c_str()) != 0);
800  			hasModifForSession = true;
801  		}
802  		result = true; 
803  	}
804  	if (result && hasModifForSession)
805  	{
806  		_pNotepadPlus->saveCurrentSession();
807  	}
808  	return result;
809  }
810  bool FileManager::deleteBufferBackup(BufferID id)
811  {
812  	Buffer* buffer = getBufferByID(id);
813  	bool result = true;
814  	generic_string backupFilePath = buffer->getBackupFileName();
815  	if (!backupFilePath.empty())
816  	{
817  		buffer->setBackupFileName(generic_string());
818  		result = (::DeleteFile(backupFilePath.c_str()) != 0);
819  	}
820  	return result;
821  }
822  std::mutex save_mutex;
823  SavingStatus FileManager::saveBuffer(BufferID id, const TCHAR * filename, bool isCopy)
824  {
825  	std::lock_guard<std::mutex> lock(save_mutex);
826  	Buffer* buffer = getBufferByID(id);
827  	bool isHiddenOrSys = false;
828  	DWORD attrib = 0;
829  	WCHAR fullpath[MAX_PATH] = { 0 };
830  	if (isWin32NamespacePrefixedFileName(filename))
831  	{
832  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
833  	}
834  	else
835  	{
836  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
837  		if (wcschr(fullpath, '~'))
838  		{
839  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
840  		}
841  	}
842  	if (PathFileExists(fullpath))
843  	{
844  		attrib = ::GetFileAttributes(fullpath);
845  		if (attrib != INVALID_FILE_ATTRIBUTES)
846  		{
847  			isHiddenOrSys = (attrib & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != 0;
848  			if (isHiddenOrSys)
849  				::SetFileAttributes(filename, attrib & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));
850  		}
851  	}
852  	UniMode mode = buffer->getUnicodeMode();
853  	if (mode == uniCookie)
854  		mode = uni8Bit;	
855  	Utf8_16_Write UnicodeConvertor;
856  	UnicodeConvertor.setEncoding(mode);
857  	int encoding = buffer->getEncoding();
858  	if (UnicodeConvertor.openFile(fullpath))
859  	{
860  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);	
861  		size_t lengthDoc = _pscratchTilla->getCurrentDocLen();
862  		char* buf = (char*)_pscratchTilla->execute(SCI_GETCHARACTERPOINTER);	
863  		boolean isWrittenSuccessful = false;
864  		if (encoding == -1) 
865  		{
866  			isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
867  			if (lengthDoc == 0)
868  				isWrittenSuccessful = true;
869  		}
870  		else
871  		{
872  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
873  			if (lengthDoc == 0)
874  			{
875  				isWrittenSuccessful = UnicodeConvertor.writeFile(buf, 0);
876  			}
877  			else
878  			{
879  				size_t grabSize;
880  				for (size_t i = 0; i < lengthDoc; i += grabSize)
881  				{
<span onclick='openModal()' class='match'>882  					grabSize = lengthDoc - i;
883  					if (grabSize > blockSize)
884  						grabSize = blockSize;
885  					int newDataLen = 0;
886  					int incompleteMultibyteChar = 0;
887  					const char* newData = wmc.encode(SC_CP_UTF8, encoding, buf + i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
888  					grabSize -= incompleteMultibyteChar;
889  					isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
890  				}
891  			}
</span>892  		}
893  		UnicodeConvertor.closeFile();
894  		if (!isWrittenSuccessful)
895  		{
896  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
897  			return SavingStatus::SaveWritingFailed;
898  		}
899  		if (isHiddenOrSys)
900  			::SetFileAttributes(fullpath, attrib);
901  		if (isCopy) 
902  		{
903  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
904  			return SavingStatus::SaveOK;	
905  		}
906  		buffer->setFileName(fullpath);
907  		if (!buffer->isLargeFile() && buffer->_lang == L_TEXT)
908  		{
909  			LangType detectedLang = detectLanguageFromTextBegining((unsigned char*)buf, lengthDoc);
910  			if (detectedLang != L_TEXT)
911  			{
912  				buffer->_lang = detectedLang;
913  				buffer->doNotify(BufferChangeFilename | BufferChangeTimestamp | BufferChangeLanguage);
914  			}
915  		}
916  		buffer->setDirty(false);
917  		buffer->setUnsync(false);
918  		buffer->setSavePointDirty(false);
919  		buffer->setStatus(DOC_REGULAR);
920  		buffer->checkFileState();
921  		_pscratchTilla->execute(SCI_SETSAVEPOINT);
922  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
923  		generic_string backupFilePath = buffer->getBackupFileName();
924  		if (!backupFilePath.empty())
925  		{
926  			buffer->setBackupFileName(generic_string());
927  			::DeleteFile(backupFilePath.c_str());
928  		}
929  		return SavingStatus::SaveOK;
930  	}
931  	else
932  	{
933  		return SavingStatus::SaveOpenFailed;
934  	}
935  }
936  size_t FileManager::nextUntitledNewNumber() const
937  {
938  	std::vector<size_t> usedNumbers;
939  	for (size_t i = 0; i < _buffers.size(); i++)
940  	{
941  		Buffer *buf = _buffers.at(i);
942  		if (buf->isUntitled())
943  		{
944  			bool isVisible = false;
945  			for (size_t k = 0; k < buf->_referees.size(); k++)
946  			{
947  				if (buf->_referees[k]->isVisible())
948  				{
949  					isVisible = true;
950  					break;
951  				}
952  			}
953  			if (isVisible)
954  			{
955  				if (buf->indexOfReference(_pNotepadPlus->_pEditView) > -1 || buf->indexOfReference(_pNotepadPlus->_pNonEditView) > -1)
956  				{
957  					generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
958  					TCHAR* numberStr = buf->_fileName + newTitle.length();
959  					int usedNumber = _wtoi(numberStr);
960  					usedNumbers.push_back(usedNumber);
961  				}
962  			}
963  		}
964  	}
965  	size_t newNumber = 1;
966  	bool numberAvailable = true;
967  	bool found = false;
968  	do
969  	{
970  		for (size_t j = 0; j < usedNumbers.size(); j++)
971  		{
972  			numberAvailable = true;
973  			found = false;
974  			if (usedNumbers[j] == newNumber)
975  			{
976  				numberAvailable = false;
977  				found = true;
978  				break;
979  			}
980  		}
981  		if (!numberAvailable)
982  			newNumber++;
983  		if (!found)
984  			break;
985  	} while (!numberAvailable);
986  	return newNumber;
987  }
988  BufferID FileManager::newEmptyDocument()
989  {
990  	generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
991  	TCHAR nb[10];
992  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
993  	newTitle += nb;
994  	Document doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT);	
995  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
996  	NppParameters& nppParamInst = NppParameters::getInstance();
997  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
998  	newBuf->_lang = ndds._lang;
999  	BufferID id = newBuf;
1000  	newBuf->_id = id;
1001  	_buffers.push_back(newBuf);
1002  	++_nbBufs;
1003  	++_nextBufferID;
1004  	return id;
1005  }
1006  BufferID FileManager::bufferFromDocument(Document doc, bool dontIncrease, bool dontRef)
1007  {
1008  	NppParameters& nppParamInst = NppParameters::getInstance();
1009  	generic_string newTitle = (nppParamInst.getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
1010  	TCHAR nb[10];
1011  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
1012  	newTitle += nb;
1013  	if (!dontRef)
1014  		_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, doc);	
1015  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
1016  	BufferID id = newBuf;
1017  	newBuf->_id = id;
1018  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
1019  	newBuf->_lang = ndds._lang;
1020  	_buffers.push_back(newBuf);
1021  	++_nbBufs;
1022  	if (!dontIncrease)
1023  		++_nextBufferID;
1024  	return id;
1025  }
1026  int FileManager::detectCodepage(char* buf, size_t len)
1027  {
1028  	int codepage = -1;
1029  	uchardet_t ud = uchardet_new();
1030  	uchardet_handle_data(ud, buf, len);
1031  	uchardet_data_end(ud);
1032  	const char* cs = uchardet_get_charset(ud);
1033  	if (stricmp(cs, "TIS-620") != 0) 
1034  		codepage = EncodingMapper::getInstance().getEncodingFromString(cs);
1035  	uchardet_delete(ud);
1036  	return codepage;
1037  }
1038  LangType FileManager::detectLanguageFromTextBegining(const unsigned char *data, size_t dataLen)
1039  {
1040  	struct FirstLineLanguages
1041  	{
1042  		std::string pattern;
1043  		LangType lang;
1044  	};
1045  	if (dataLen <= 3)
1046  		return L_TEXT;
1047  	size_t i = 0;
1048  	if ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) || 
1049  		(data[0] == 0xFE && data[1] == 0xFF && data[2] == 0x00) || 
1050  		(data[0] == 0xFF && data[1] == 0xFE && data[2] == 0x00))   
1051  		i += 3;
1052  	for (; i < dataLen; ++i)
1053  	{
1054  		if (data[i] != ' ' && data[i] != '\t' && data[i] != '\n' && data[i] != '\r')
1055  			break;
1056  	}
1057  	const size_t longestLength = 40; 
1058  	std::string buf2Test = std::string((const char *)data + i, longestLength);
1059  	auto cr = buf2Test.find("\r");
1060  	auto nl = buf2Test.find("\n");
1061  	auto crnl = std::min<size_t>(cr, nl);
1062  	if (crnl != std::string::npos && crnl < longestLength)
1063  		buf2Test = std::string((const char *)data + i, crnl);
1064  	std::string shebang = "#!";
1065  	size_t foundPos = buf2Test.find(shebang);
1066  	if (foundPos == 0)
1067  	{
1068  		const size_t NB_SHEBANG_LANGUAGES = 6;
1069  		FirstLineLanguages ShebangLangs[NB_SHEBANG_LANGUAGES] = {
1070  			{ "sh",		L_BASH },
1071  			{ "python", L_PYTHON },
1072  			{ "perl",	L_PERL },
1073  			{ "php",	L_PHP },
1074  			{ "ruby",	L_RUBY },
1075  			{ "node",	L_JAVASCRIPT }
1076  		};
1077  		for (i = 0; i < NB_SHEBANG_LANGUAGES; ++i)
1078  		{
1079  			if (buf2Test.find(ShebangLangs[i].pattern) != std::string::npos)
1080  			{
1081  				return ShebangLangs[i].lang;
1082  			}
1083  		}
1084  		return L_TEXT;
1085  	}
1086  	const size_t NB_FIRST_LINE_LANGUAGES = 5;
1087  	FirstLineLanguages languages[NB_FIRST_LINE_LANGUAGES] = {
1088  		{ "<?xml",			L_XML },
1089  		{ "<?php",			L_PHP },
1090  		{ "<html",			L_HTML },
1091  		{ "<!DOCTYPE html",	L_HTML },
1092  		{ "<?",				L_PHP } 
1093  	};
1094  	for (i = 0; i < NB_FIRST_LINE_LANGUAGES; ++i)
1095  	{
1096  		foundPos = buf2Test.find(languages[i].pattern);
1097  		if (foundPos == 0)
1098  		{
1099  			return languages[i].lang;
1100  		}
1101  	}
1102  	return L_TEXT;
1103  }
1104  bool FileManager::loadFileData(Document doc, int64_t fileSize, const TCHAR * filename, char* data, Utf8_16_Read * unicodeConvertor, LoadedFileFormat& fileFormat)
1105  {
1106  	FILE *fp = _wfopen(filename, TEXT("rb"));
1107  	if (!fp)
1108  		return false;
1109  	int64_t bufferSizeRequested = fileSize + std::min<int64_t>(1LL << 20, fileSize / 6);
1110  	NppParameters& nppParam = NppParameters::getInstance();
1111  	NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1112  	if (bufferSizeRequested > INT_MAX)
1113  	{
1114  		if (nppParam.archType() == IMAGE_FILE_MACHINE_I386)
1115  		{
1116  			pNativeSpeaker->messageBox("FileTooBigToOpen",
1117  				_pNotepadPlus->_pEditView->getHSelf(),
1118  				TEXT("File is too big to be opened by Notepad++"),
1119  				TEXT("File size problem"),
1120  				MB_OK | MB_APPLMODAL);
1121  			fclose(fp);
1122  			return false;
1123  		}
1124  		else 
1125  		{
1126  			int res = pNativeSpeaker->messageBox("WantToOpenHugeFile",
1127  				_pNotepadPlus->_pEditView->getHSelf(),
1128  				TEXT("Opening a huge file of 2GB+ could take several minutes.\nDo you want to open it?"),
1129  				TEXT("Opening huge file warning"),
1130  				MB_YESNO | MB_APPLMODAL);
1131  			if (res == IDYES)
1132  			{
1133  			}
1134  			else
1135  			{
1136  				fclose(fp);
1137  				return false;
1138  			}
1139  		}
1140  	}
1141  	_pscratchTilla->execute(SCI_SETSTATUS, SC_STATUS_OK); 
1142  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, doc);
1143  	bool ro = _pscratchTilla->execute(SCI_GETREADONLY) != 0;
1144  	if (ro)
1145  	{
1146  		_pscratchTilla->execute(SCI_SETREADONLY, false);
1147  	}
1148  	_pscratchTilla->execute(SCI_CLEARALL);
1149  	if (fileFormat._language < L_EXTERNAL)
1150  	{
1151  		const char* lexerNameID = ScintillaEditView::_langNameInfoArray[fileFormat._language]._lexerID;
1152  		_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(CreateLexer(lexerNameID)));
1153  	}
1154  	else
1155  	{
1156  		int id = fileFormat._language - L_EXTERNAL;
1157  		ExternalLangContainer& externalLexer = nppParam.getELCFromIndex(id);
1158  		const char* lexerName = externalLexer._name.c_str();
1159  		if (externalLexer.fnCL)
1160  			_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(externalLexer.fnCL(lexerName)));
1161  	}
1162  	if (fileFormat._encoding != -1)
1163  		_pscratchTilla->execute(SCI_SETCODEPAGE, SC_CP_UTF8);
1164  	bool success = true;
1165  	EolType format = EolType::unknown;
1166  	int sciStatus = SC_STATUS_OK;
1167  	TCHAR szException[64] = { '\0' };
1168  	__try
1169  	{
1170  		_pscratchTilla->execute(SCI_ALLOCATE, WPARAM(bufferSizeRequested));
1171  		sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1172  		if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1173  			throw std::runtime_error("Scintilla error");
1174  		size_t lenFile = 0;
1175  		size_t lenConvert = 0;	
1176  		bool isFirstTime = true;
1177  		int incompleteMultibyteChar = 0;
1178  		do
1179  		{
1180  			lenFile = fread(data + incompleteMultibyteChar, 1, blockSize - incompleteMultibyteChar, fp) + incompleteMultibyteChar;
1181  			if (ferror(fp) != 0)
1182  			{
1183  				success = false;
1184  				break;
1185  			}
1186  			if (lenFile == 0) break;
1187              if (isFirstTime)
1188              {
1189  				NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
1190                  if (Utf8_16_Read::determineEncoding((unsigned char *)data, lenFile) != uni8Bit)
1191                  {
1192  					fileFormat._encoding = -1;
1193  				}
1194  				else if (fileFormat._encoding == -1)
1195  				{
1196  					if (nppGui._detectEncoding)
1197  						fileFormat._encoding = detectCodepage(data, lenFile);
1198                  }
1199  				bool isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
1200  				if (!isLargeFile && fileFormat._language == L_TEXT)
1201  				{
1202  					fileFormat._language = detectLanguageFromTextBegining((unsigned char *)data, lenFile);
1203  				}
1204                  isFirstTime = false;
1205              }
1206  			if (fileFormat._encoding != -1)
1207  			{
1208  				if (fileFormat._encoding == SC_CP_UTF8)
1209  				{
1210  					_pscratchTilla->execute(SCI_APPENDTEXT, lenFile, reinterpret_cast<LPARAM>(data));
1211  				}
1212  				else
1213  				{
1214  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1215  					int newDataLen = 0;
1216  					const char *newData = wmc.encode(fileFormat._encoding, SC_CP_UTF8, data, static_cast<int32_t>(lenFile), &newDataLen, &incompleteMultibyteChar);
1217  					_pscratchTilla->execute(SCI_APPENDTEXT, newDataLen, reinterpret_cast<LPARAM>(newData));
1218  				}
1219  				if (format == EolType::unknown)
1220  					format = getEOLFormatForm(data, lenFile, EolType::unknown);
1221  			}
1222  			else
1223  			{
1224  				lenConvert = unicodeConvertor->convert(data, lenFile);
1225  				_pscratchTilla->execute(SCI_APPENDTEXT, lenConvert, reinterpret_cast<LPARAM>(unicodeConvertor->getNewBuf()));
1226  				if (format == EolType::unknown)
1227  					format = getEOLFormatForm(unicodeConvertor->getNewBuf(), unicodeConvertor->getNewSize(), EolType::unknown);
1228  			}
1229  			sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1230  			if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1231  				throw std::runtime_error("Scintilla error");
1232  			if (incompleteMultibyteChar != 0)
1233  			{
1234  				memcpy(data, data + blockSize - incompleteMultibyteChar, incompleteMultibyteChar);
1235  			}
1236  		}
1237  		while (lenFile > 0);
1238  	}
1239  	__except(EXCEPTION_EXECUTE_HANDLER)
1240  	{
1241  		switch (sciStatus)
1242  		{
1243  			case SC_STATUS_OK:
1244  #if defined(__GNUC__)
1245  				_stprintf_s(szException, _countof(szException), TEXT("unknown exception"));
1246  #else
1247  				_stprintf_s(szException, _countof(szException), TEXT("0x%X (SEH)"), ::GetExceptionCode());
1248  #endif
1249  				break;
1250  			case SC_STATUS_BADALLOC:
1251  			{
1252  				pNativeSpeaker->messageBox("FileTooBigToOpen",
1253  					_pNotepadPlus->_pEditView->getHSelf(),
1254  					TEXT("File is too big to be opened by Notepad++"),
1255  					TEXT("Exception: File size problem"),
1256  					MB_OK | MB_APPLMODAL);
1257  			}
1258  			[[fallthrough]];
1259  			case SC_STATUS_FAILURE:
1260  			default:
1261  				_stprintf_s(szException, _countof(szException), TEXT("%d (Scintilla)"), sciStatus);
1262  				break;
1263  		}
1264  		if (sciStatus != SC_STATUS_BADALLOC)
1265  		{
1266  			pNativeSpeaker->messageBox("FileLoadingException",
1267  				_pNotepadPlus->_pEditView->getHSelf(),
1268  				TEXT("An error occurred while loading the file!"),
1269  				TEXT("Exception code: $STR_REPLACE$"),
1270  				MB_OK | MB_APPLMODAL,
1271  				0,
1272  				szException);
1273  		}
1274  		success = false;
1275  	}
1276  	fclose(fp);
1277  	if (format == EolType::unknown)
1278  	{
1279  		const NewDocDefaultSettings & ndds = (nppParam.getNppGUI()).getNewDocDefaultSettings(); 
1280  		fileFormat._eolFormat = ndds._format;
1281  		if ((fileSize == 0) && (fileFormat._encoding < 1))
1282  		{
1283  			if (ndds._unicodeMode == uniCookie && ndds._openAnsiAsUtf8)
1284  				fileFormat._encoding = SC_CP_UTF8;
1285  		}
1286  	}
1287  	else
1288  	{
1289  		fileFormat._eolFormat = format;
1290  	}
1291  	_pscratchTilla->execute(SCI_EMPTYUNDOBUFFER);
1292  	_pscratchTilla->execute(SCI_SETSAVEPOINT);
1293  	if (ro)
1294  		_pscratchTilla->execute(SCI_SETREADONLY, true);
1295  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
1296  	return success;
1297  }
1298  BufferID FileManager::getBufferFromName(const TCHAR* name)
1299  {
1300  	for (auto buf : _buffers)
1301  	{
1302  		if (OrdinalIgnoreCaseCompareStrings(name, buf->getFullPathName()) == 0)
1303  		{
1304  			if (buf->_referees[0]->isVisible())
1305  			{
1306  				return buf->getID();
1307  			}
1308  		}
1309  	}
1310  	return BUFFER_INVALID;
1311  }
1312  BufferID FileManager::getBufferFromDocument(Document doc)
1313  {
1314  	for (size_t i = 0; i < _nbBufs; ++i)
1315  	{
1316  		if (_buffers[i]->_doc == doc)
1317  			return _buffers[i]->_id;
1318  	}
1319  	return BUFFER_INVALID;
1320  }
1321  bool FileManager::createEmptyFile(const TCHAR * path)
1322  {
1323  	Win32_IO_File file(path);
1324  	return file.isOpened();
1325  }
1326  int FileManager::getFileNameFromBuffer(BufferID id, TCHAR * fn2copy)
1327  {
1328  	if (getBufferIndexByID(id) == -1)
1329  		return -1;
1330  	Buffer* buf = getBufferByID(id);
1331  	if (fn2copy)
1332  		lstrcpy(fn2copy, buf->getFullPathName());
1333  	return lstrlen(buf->getFullPathName());
1334  }
1335  size_t FileManager::docLength(Buffer* buffer) const
1336  {
1337  	Document curDoc = _pscratchTilla->execute(SCI_GETDOCPOINTER);
1338  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);
1339  	size_t docLen = _pscratchTilla->getCurrentDocLen();
1340  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, curDoc);
1341  	return docLen;
1342  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>882  					grabSize = lengthDoc - i;
883  					if (grabSize > blockSize)
884  						grabSize = blockSize;
885  					int newDataLen = 0;
886  					int incompleteMultibyteChar = 0;
887  					const char* newData = wmc.encode(SC_CP_UTF8, encoding, buf + i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
888  					grabSize -= incompleteMultibyteChar;
889  					isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
890  				}
891  			}
</pre></code></div>
                <div class="column column_space"><pre><code>882  					grabSize = lengthDoc - i;
883  					if (grabSize > blockSize)
884  						grabSize = blockSize;
885  					int newDataLen = 0;
886  					int incompleteMultibyteChar = 0;
887  					const char* newData = wmc.encode(SC_CP_UTF8, encoding, buf + i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
888  					grabSize -= incompleteMultibyteChar;
889  					isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
890  				}
891  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    