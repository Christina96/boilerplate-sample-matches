
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.7094017094017095%, Tokens: 10</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_store_81.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/secure/store.hpp>
3  #include <lmdb/libraries/liblmdb/lmdb.h>
4  namespace nano
5  {
6  namespace lmdb
7  {
8  	class store;
9  	class confirmation_height_store : public nano::confirmation_height_store
10  	{
11  		nano::lmdb::store & store;
12  	public:
13  		explicit confirmation_height_store (nano::lmdb::store & store_a);
14  		void put (nano::write_transaction const & transaction_a, nano::account const & account_a, nano::confirmation_height_info const & confirmation_height_info_a) override;
15  		bool get (nano::transaction const & transaction_a, nano::account const & account_a, nano::confirmation_height_info & confirmation_height_info_a) override;
16  		bool exists (nano::transaction const & transaction_a, nano::account const & account_a) const override;
17  		void del (nano::write_transaction const & transaction_a, nano::account const & account_a) override;
18  		uint64_t count (nano::transaction const & transaction_a) override;
19  		void clear (nano::write_transaction const & transaction_a, nano::account const & account_a) override;
20  		void clear (nano::write_transaction const & transaction_a) override;
<span onclick='openModal()' class='match'>21  		nano::store_iterator<nano::account, nano::confirmation_height_info> begin (nano::transaction const & transaction_a, nano::account const & account_a) const override;
22  		nano::store_iterator<nano::account, nano::confirmation_height_info> begin (nano::transaction const & transaction_a) const override;
23  		nano::store_iterator<nano::account, nano::confirmation_height_info> end () const override;
24  		void for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::account, nano::confirmation_height_info>, nano::store_iterator<nano::account, nano::confirmation_height_info>)> const & action_a) const override;
25  		MDB_dbi confirmation_height_handle{ 0 };
</span>26  	};
27  }
28  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_CORD_H_
2  #define ABSL_STRINGS_CORD_H_
3  #include <algorithm>
4  #include <cstddef>
5  #include <cstdint>
6  #include <cstring>
7  #include <iosfwd>
8  #include <iterator>
9  #include <string>
10  #include <type_traits>
11  #include "absl/base/attributes.h"
12  #include "absl/base/config.h"
13  #include "absl/base/internal/endian.h"
14  #include "absl/base/internal/per_thread_tls.h"
15  #include "absl/base/macros.h"
16  #include "absl/base/port.h"
17  #include "absl/container/inlined_vector.h"
18  #include "absl/crc/internal/crc_cord_state.h"
19  #include "absl/functional/function_ref.h"
20  #include "absl/meta/type_traits.h"
21  #include "absl/strings/cord_analysis.h"
22  #include "absl/strings/cord_buffer.h"
23  #include "absl/strings/internal/cord_data_edge.h"
24  #include "absl/strings/internal/cord_internal.h"
25  #include "absl/strings/internal/cord_rep_btree.h"
26  #include "absl/strings/internal/cord_rep_btree_reader.h"
27  #include "absl/strings/internal/cord_rep_crc.h"
28  #include "absl/strings/internal/cord_rep_ring.h"
29  #include "absl/strings/internal/cordz_functions.h"
30  #include "absl/strings/internal/cordz_info.h"
31  #include "absl/strings/internal/cordz_statistics.h"
32  #include "absl/strings/internal/cordz_update_scope.h"
33  #include "absl/strings/internal/cordz_update_tracker.h"
34  #include "absl/strings/internal/resize_uninitialized.h"
35  #include "absl/strings/internal/string_constant.h"
36  #include "absl/strings/string_view.h"
37  #include "absl/types/optional.h"
38  namespace absl {
39  ABSL_NAMESPACE_BEGIN
40  class Cord;
41  class CordTestPeer;
42  template <typename Releaser>
43  Cord MakeCordFromExternal(absl::string_view, Releaser&&);
44  void CopyCordToString(const Cord& src, std::string* dst);
45  enum class CordMemoryAccounting {
46    kTotal,
47    kFairShare,
48  };
49  class Cord {
50   private:
51    template <typename T>
52    using EnableIfString =
53        absl::enable_if_t<std::is_same<T, std::string>::value, int>;
54   public:
55    constexpr Cord() noexcept;
56    Cord(const Cord& src);
57    Cord(Cord&& src) noexcept;
58    Cord& operator=(const Cord& x);
59    Cord& operator=(Cord&& x) noexcept;
60    explicit Cord(absl::string_view src);
61    Cord& operator=(absl::string_view src);
62    template <typename T, EnableIfString<T> = 0>
63    explicit Cord(T&& src);
64    template <typename T, EnableIfString<T> = 0>
65    Cord& operator=(T&& src);
66    ~Cord() {
67      if (contents_.is_tree()) DestroyCordSlow();
68    }
69    template <typename Releaser>
70    friend Cord MakeCordFromExternal(absl::string_view data, Releaser&& releaser);
71    ABSL_ATTRIBUTE_REINITIALIZES void Clear();
72    void Append(const Cord& src);
73    void Append(Cord&& src);
74    void Append(absl::string_view src);
75    template <typename T, EnableIfString<T> = 0>
76    void Append(T&& src);
77    void Append(CordBuffer buffer);
78    CordBuffer GetAppendBuffer(size_t capacity, size_t min_capacity = 16);
79    CordBuffer GetCustomAppendBuffer(size_t block_size, size_t capacity,
80                                     size_t min_capacity = 16);
81    void Prepend(const Cord& src);
82    void Prepend(absl::string_view src);
83    template <typename T, EnableIfString<T> = 0>
84    void Prepend(T&& src);
85    void Prepend(CordBuffer buffer);
86    void RemovePrefix(size_t n);
87    void RemoveSuffix(size_t n);
88    Cord Subcord(size_t pos, size_t new_size) const;
89    void swap(Cord& other) noexcept;
90    friend void swap(Cord& x, Cord& y) noexcept { x.swap(y); }
91    size_t size() const;
92    bool empty() const;
93    size_t EstimatedMemoryUsage(CordMemoryAccounting accounting_method =
94                                    CordMemoryAccounting::kTotal) const;
95    int Compare(absl::string_view rhs) const;
96    int Compare(const Cord& rhs) const;
97    bool StartsWith(const Cord& rhs) const;
98    bool StartsWith(absl::string_view rhs) const;
99    bool EndsWith(absl::string_view rhs) const;
100    bool EndsWith(const Cord& rhs) const;
101    explicit operator std::string() const;
102    friend void CopyCordToString(const Cord& src, std::string* dst);
103    class CharIterator;
104    class ChunkIterator {
105     public:
106      using iterator_category = std::input_iterator_tag;
107      using value_type = absl::string_view;
108      using difference_type = ptrdiff_t;
109      using pointer = const value_type*;
110      using reference = value_type;
111      ChunkIterator() = default;
112      ChunkIterator& operator++();
113      ChunkIterator operator++(int);
114      bool operator==(const ChunkIterator& other) const;
115      bool operator!=(const ChunkIterator& other) const;
116      reference operator*() const;
117      pointer operator->() const;
118      friend class Cord;
119      friend class CharIterator;
120     private:
121      using CordRep = absl::cord_internal::CordRep;
122      using CordRepBtree = absl::cord_internal::CordRepBtree;
123      using CordRepBtreeReader = absl::cord_internal::CordRepBtreeReader;
124      explicit ChunkIterator(cord_internal::CordRep* tree);
125      explicit ChunkIterator(const Cord* cord);
126      void InitTree(cord_internal::CordRep* tree);
127      void RemoveChunkPrefix(size_t n);
128      Cord AdvanceAndReadBytes(size_t n);
129      void AdvanceBytes(size_t n);
130      ChunkIterator& AdvanceBtree();
131      void AdvanceBytesBtree(size_t n);
132      absl::string_view current_chunk_;
133      absl::cord_internal::CordRep* current_leaf_ = nullptr;
134      size_t bytes_remaining_ = 0;
135      CordRepBtreeReader btree_reader_;
136    };
137    ChunkIterator chunk_begin() const;
138    ChunkIterator chunk_end() const;
139    class ChunkRange {
140     public:
141      using value_type = absl::string_view;
142      using reference = value_type&;
143      using const_reference = const value_type&;
144      using iterator = ChunkIterator;
145      using const_iterator = ChunkIterator;
146      explicit ChunkRange(const Cord* cord) : cord_(cord) {}
147      ChunkIterator begin() const;
148      ChunkIterator end() const;
149     private:
150      const Cord* cord_;
151    };
152    ChunkRange Chunks() const;
153    class CharIterator {
154     public:
155      using iterator_category = std::input_iterator_tag;
156      using value_type = char;
157      using difference_type = ptrdiff_t;
158      using pointer = const char*;
159      using reference = const char&;
160      CharIterator() = default;
161      CharIterator& operator++();
162      CharIterator operator++(int);
163      bool operator==(const CharIterator& other) const;
164      bool operator!=(const CharIterator& other) const;
165      reference operator*() const;
166      pointer operator->() const;
167      friend Cord;
168     private:
169      explicit CharIterator(const Cord* cord) : chunk_iterator_(cord) {}
170      ChunkIterator chunk_iterator_;
171    };
172    static Cord AdvanceAndRead(CharIterator* it, size_t n_bytes);
173    static void Advance(CharIterator* it, size_t n_bytes);
174    static absl::string_view ChunkRemaining(const CharIterator& it);
175    CharIterator char_begin() const;
176    CharIterator char_end() const;
177    class CharRange {
178     public:
179      using value_type = char;
180      using reference = value_type&;
181      using const_reference = const value_type&;
182      using iterator = CharIterator;
183      using const_iterator = CharIterator;
184      explicit CharRange(const Cord* cord) : cord_(cord) {}
185      CharIterator begin() const;
186      CharIterator end() const;
187     private:
188      const Cord* cord_;
189    };
190    CharRange Chars() const;
191    char operator[](size_t i) const;
192    absl::optional<absl::string_view> TryFlat() const;
193    absl::string_view Flatten();
194    friend void AbslFormatFlush(absl::Cord* cord, absl::string_view part) {
195      cord->Append(part);
196    }
197    void SetExpectedChecksum(uint32_t crc);
198    absl::optional<uint32_t> ExpectedChecksum() const;
199    template <typename H>
200    friend H AbslHashValue(H hash_state, const absl::Cord& c) {
201      absl::optional<absl::string_view> maybe_flat = c.TryFlat();
202      if (maybe_flat.has_value()) {
203        return H::combine(std::move(hash_state), *maybe_flat);
204      }
205      return c.HashFragmented(std::move(hash_state));
206    }
207    template <typename T>
208    constexpr Cord(strings_internal::StringConstant<T>);
209   private:
210    using CordRep = absl::cord_internal::CordRep;
211    using CordRepFlat = absl::cord_internal::CordRepFlat;
212    using CordzInfo = cord_internal::CordzInfo;
213    using CordzUpdateScope = cord_internal::CordzUpdateScope;
214    using CordzUpdateTracker = cord_internal::CordzUpdateTracker;
215    using InlineData = cord_internal::InlineData;
216    using MethodIdentifier = CordzUpdateTracker::MethodIdentifier;
217    explicit Cord(absl::string_view src, MethodIdentifier method);
218    friend class CordTestPeer;
219    friend bool operator==(const Cord& lhs, const Cord& rhs);
220    friend bool operator==(const Cord& lhs, absl::string_view rhs);
221    friend const CordzInfo* GetCordzInfoForTesting(const Cord& cord);
222    void ForEachChunk(absl::FunctionRef<void(absl::string_view)>) const;
223    absl::string_view FlattenSlowPath();
224    class InlineRep {
225     public:
226      static constexpr unsigned char kMaxInline = cord_internal::kMaxInline;
227      static_assert(kMaxInline >= sizeof(absl::cord_internal::CordRep*), "");
228      constexpr InlineRep() : data_() {}
229      explicit InlineRep(InlineData::DefaultInitType init) : data_(init) {}
230      InlineRep(const InlineRep& src);
231      InlineRep(InlineRep&& src);
232      InlineRep& operator=(const InlineRep& src);
233      InlineRep& operator=(InlineRep&& src) noexcept;
234      explicit constexpr InlineRep(absl::string_view sv, CordRep* rep);
235      void Swap(InlineRep* rhs);
236      bool empty() const;
237      size_t size() const;
238      const char* data() const;  
239      void set_data(const char* data, size_t n);  
240      char* set_data(size_t n);                   
241      absl::cord_internal::CordRep* tree() const;
242      absl::cord_internal::CordRep* as_tree() const;
<span onclick='openModal()' class='match'>243      const char* as_chars() const;
244      absl::cord_internal::CordRep* clear();
245      void reduce_size(size_t n);    
246      void remove_prefix(size_t n);  
247      void AppendArray(absl::string_view src, MethodIdentifier method);
248      absl::string_view FindFlatStartPiece() const;
249      CordRepFlat* MakeFlatWithExtraCapacity(size_t extra);
250      void SetTree(CordRep* rep, const CordzUpdateScope& scope);
251      void SetTreeOrEmpty(CordRep* rep, const CordzUpdateScope& scope);
252      void EmplaceTree(CordRep* rep, MethodIdentifier method);
253      void EmplaceTree(CordRep* rep, const InlineData& parent,
254                       MethodIdentifier method);
255      void CommitTree(const CordRep* old_rep, CordRep* rep,
256                      const CordzUpdateScope& scope, MethodIdentifier method);
257      void AppendTreeToInlined(CordRep* tree, MethodIdentifier method);
258      void AppendTreeToTree(CordRep* tree, MethodIdentifier method);
259      void AppendTree(CordRep* tree, MethodIdentifier method);
260      void PrependTreeToInlined(CordRep* tree, MethodIdentifier method);
261      void PrependTreeToTree(CordRep* tree, MethodIdentifier method);
262      void PrependTree(CordRep* tree, MethodIdentifier method);
263      bool IsSame(const InlineRep& other) const { return data_ == other.data_; }
</span>264      void CopyTo(std::string* dst) const {
265        absl::strings_internal::STLStringResizeUninitialized(dst, kMaxInline);
266        data_.copy_max_inline_to(&(*dst)[0]);
267        dst->erase(inline_size());
268      }
269      void CopyToArray(char* dst) const;
270      bool is_tree() const { return data_.is_tree(); }
271      bool is_profiled() const { return data_.is_tree() && data_.is_profiled(); }
272      size_t remaining_inline_capacity() const {
273        return data_.is_tree() ? 0 : kMaxInline - data_.inline_size();
274      }
275      absl::cord_internal::CordzInfo* cordz_info() const {
276        return data_.cordz_info();
277      }
278      void set_cordz_info(cord_internal::CordzInfo* cordz_info) {
279        assert(cordz_info != nullptr);
280        data_.set_cordz_info(cordz_info);
281      }
282      void clear_cordz_info() { data_.clear_cordz_info(); }
283     private:
284      friend class Cord;
285      void AssignSlow(const InlineRep& src);
286      void UnrefTree();
287      void ResetToEmpty() { data_ = {}; }
288      void set_inline_size(size_t size) { data_.set_inline_size(size); }
289      size_t inline_size() const { return data_.inline_size(); }
290      void MaybeRemoveEmptyCrcNode();
291      cord_internal::InlineData data_;
292    };
293    InlineRep contents_;
294    static bool GetFlatAux(absl::cord_internal::CordRep* rep,
295                           absl::string_view* fragment);
296    static void ForEachChunkAux(
297        absl::cord_internal::CordRep* rep,
298        absl::FunctionRef<void(absl::string_view)> callback);
299    void DestroyCordSlow();
300    void CopyToArraySlowPath(char* dst) const;
301    int CompareSlowPath(absl::string_view rhs, size_t compared_size,
302                        size_t size_to_compare) const;
303    int CompareSlowPath(const Cord& rhs, size_t compared_size,
304                        size_t size_to_compare) const;
305    bool EqualsImpl(absl::string_view rhs, size_t size_to_compare) const;
306    bool EqualsImpl(const Cord& rhs, size_t size_to_compare) const;
307    int CompareImpl(const Cord& rhs) const;
308    template <typename ResultType, typename RHS>
309    friend ResultType GenericCompare(const Cord& lhs, const RHS& rhs,
310                                     size_t size_to_compare);
311    static absl::string_view GetFirstChunk(const Cord& c);
312    static absl::string_view GetFirstChunk(absl::string_view sv);
313    absl::cord_internal::CordRep* TakeRep() const&;
314    absl::cord_internal::CordRep* TakeRep() &&;
315    template <typename C>
316    void AppendImpl(C&& src);
317    void AppendPrecise(absl::string_view src, MethodIdentifier method);
318    void PrependPrecise(absl::string_view src, MethodIdentifier method);
319    CordBuffer GetAppendBufferSlowPath(size_t block_size, size_t capacity,
320                                       size_t min_capacity);
321    void PrependArray(absl::string_view src, MethodIdentifier method);
322    Cord& AssignLargeString(std::string&& src);
323    template <typename H>
324    H HashFragmented(H hash_state) const {
325      typename H::AbslInternalPiecewiseCombiner combiner;
326      ForEachChunk([&combiner, &hash_state](absl::string_view chunk) {
327        hash_state = combiner.add_buffer(std::move(hash_state), chunk.data(),
328                                         chunk.size());
329      });
330      return H::combine(combiner.finalize(std::move(hash_state)), size());
331    }
332    friend class CrcCord;
333    void SetCrcCordState(crc_internal::CrcCordState state);
334    const crc_internal::CrcCordState* MaybeGetCrcCordState() const;
335  };
336  ABSL_NAMESPACE_END
337  }  
338  namespace absl {
339  ABSL_NAMESPACE_BEGIN
340  extern std::ostream& operator<<(std::ostream& out, const Cord& cord);
341  namespace cord_internal {
342  void InitializeCordRepExternal(absl::string_view data, CordRepExternal* rep);
343  template <typename Releaser>
344  CordRep* NewExternalRep(absl::string_view data, Releaser&& releaser) {
345    assert(!data.empty());
346    using ReleaserType = absl::decay_t<Releaser>;
347    CordRepExternal* rep = new CordRepExternalImpl<ReleaserType>(
348        std::forward<Releaser>(releaser), 0);
349    InitializeCordRepExternal(data, rep);
350    return rep;
351  }
352  inline CordRep* NewExternalRep(absl::string_view data,
353                                 void (&releaser)(absl::string_view)) {
354    return NewExternalRep(data, &releaser);
355  }
356  }  
357  template <typename Releaser>
358  Cord MakeCordFromExternal(absl::string_view data, Releaser&& releaser) {
359    Cord cord;
360    if (ABSL_PREDICT_TRUE(!data.empty())) {
361      cord.contents_.EmplaceTree(::absl::cord_internal::NewExternalRep(
362                                     data, std::forward<Releaser>(releaser)),
363                                 Cord::MethodIdentifier::kMakeCordFromExternal);
364    } else {
365      using ReleaserType = absl::decay_t<Releaser>;
366      cord_internal::InvokeReleaser(
367          cord_internal::Rank0{}, ReleaserType(std::forward<Releaser>(releaser)),
368          data);
369    }
370    return cord;
371  }
372  constexpr Cord::InlineRep::InlineRep(absl::string_view sv, CordRep* rep)
373      : data_(sv, rep) {}
374  inline Cord::InlineRep::InlineRep(const Cord::InlineRep& src)
375      : data_(InlineData::kDefaultInit) {
376    if (CordRep* tree = src.tree()) {
377      EmplaceTree(CordRep::Ref(tree), src.data_,
378                  CordzUpdateTracker::kConstructorCord);
379    } else {
380      data_ = src.data_;
381    }
382  }
383  inline Cord::InlineRep::InlineRep(Cord::InlineRep&& src) : data_(src.data_) {
384    src.ResetToEmpty();
385  }
386  inline Cord::InlineRep& Cord::InlineRep::operator=(const Cord::InlineRep& src) {
387    if (this == &src) {
388      return *this;
389    }
390    if (!is_tree() && !src.is_tree()) {
391      data_ = src.data_;
392      return *this;
393    }
394    AssignSlow(src);
395    return *this;
396  }
397  inline Cord::InlineRep& Cord::InlineRep::operator=(
398      Cord::InlineRep&& src) noexcept {
399    if (is_tree()) {
400      UnrefTree();
401    }
402    data_ = src.data_;
403    src.ResetToEmpty();
404    return *this;
405  }
406  inline void Cord::InlineRep::Swap(Cord::InlineRep* rhs) {
407    if (rhs == this) {
408      return;
409    }
410    std::swap(data_, rhs->data_);
411  }
412  inline const char* Cord::InlineRep::data() const {
413    return is_tree() ? nullptr : data_.as_chars();
414  }
415  inline const char* Cord::InlineRep::as_chars() const {
416    assert(!data_.is_tree());
417    return data_.as_chars();
418  }
419  inline absl::cord_internal::CordRep* Cord::InlineRep::as_tree() const {
420    assert(data_.is_tree());
421    return data_.as_tree();
422  }
423  inline absl::cord_internal::CordRep* Cord::InlineRep::tree() const {
424    if (is_tree()) {
425      return as_tree();
426    } else {
427      return nullptr;
428    }
429  }
430  inline bool Cord::InlineRep::empty() const { return data_.is_empty(); }
431  inline size_t Cord::InlineRep::size() const {
432    return is_tree() ? as_tree()->length : inline_size();
433  }
434  inline cord_internal::CordRepFlat* Cord::InlineRep::MakeFlatWithExtraCapacity(
435      size_t extra) {
436    static_assert(cord_internal::kMinFlatLength >= sizeof(data_), "");
437    size_t len = data_.inline_size();
438    auto* result = CordRepFlat::New(len + extra);
439    result->length = len;
440    data_.copy_max_inline_to(result->Data());
441    return result;
442  }
443  inline void Cord::InlineRep::EmplaceTree(CordRep* rep,
444                                           MethodIdentifier method) {
445    assert(rep);
446    data_.make_tree(rep);
447    CordzInfo::MaybeTrackCord(data_, method);
448  }
449  inline void Cord::InlineRep::EmplaceTree(CordRep* rep, const InlineData& parent,
450                                           MethodIdentifier method) {
451    data_.make_tree(rep);
452    CordzInfo::MaybeTrackCord(data_, parent, method);
453  }
454  inline void Cord::InlineRep::SetTree(CordRep* rep,
455                                       const CordzUpdateScope& scope) {
456    assert(rep);
457    assert(data_.is_tree());
458    data_.set_tree(rep);
459    scope.SetCordRep(rep);
460  }
461  inline void Cord::InlineRep::SetTreeOrEmpty(CordRep* rep,
462                                              const CordzUpdateScope& scope) {
463    assert(data_.is_tree());
464    if (rep) {
465      data_.set_tree(rep);
466    } else {
467      data_ = {};
468    }
469    scope.SetCordRep(rep);
470  }
471  inline void Cord::InlineRep::CommitTree(const CordRep* old_rep, CordRep* rep,
472                                          const CordzUpdateScope& scope,
473                                          MethodIdentifier method) {
474    if (old_rep) {
475      SetTree(rep, scope);
476    } else {
477      EmplaceTree(rep, method);
478    }
479  }
480  inline absl::cord_internal::CordRep* Cord::InlineRep::clear() {
481    if (is_tree()) {
482      CordzInfo::MaybeUntrackCord(cordz_info());
483    }
484    absl::cord_internal::CordRep* result = tree();
485    ResetToEmpty();
486    return result;
487  }
488  inline void Cord::InlineRep::CopyToArray(char* dst) const {
489    assert(!is_tree());
490    size_t n = inline_size();
491    assert(n != 0);
492    cord_internal::SmallMemmove(dst, data_.as_chars(), n);
493  }
494  inline void Cord::InlineRep::MaybeRemoveEmptyCrcNode() {
495    CordRep* rep = tree();
496    if (rep == nullptr || ABSL_PREDICT_TRUE(rep->length > 0)) {
497      return;
498    }
499    assert(rep->IsCrc());
500    assert(rep->crc()->child == nullptr);
501    CordzInfo::MaybeUntrackCord(cordz_info());
502    CordRep::Unref(rep);
503    ResetToEmpty();
504  }
505  constexpr inline Cord::Cord() noexcept {}
506  inline Cord::Cord(absl::string_view src)
507      : Cord(src, CordzUpdateTracker::kConstructorString) {}
508  template <typename T>
509  constexpr Cord::Cord(strings_internal::StringConstant<T>)
510      : contents_(strings_internal::StringConstant<T>::value,
511                  strings_internal::StringConstant<T>::value.size() <=
512                          cord_internal::kMaxInline
513                      ? nullptr
514                      : &cord_internal::ConstInitExternalStorage<
515                            strings_internal::StringConstant<T>>::value) {}
516  inline Cord& Cord::operator=(const Cord& x) {
517    contents_ = x.contents_;
518    return *this;
519  }
520  template <typename T, Cord::EnableIfString<T>>
521  Cord& Cord::operator=(T&& src) {
522    if (src.size() <= cord_internal::kMaxBytesToCopy) {
523      return operator=(absl::string_view(src));
524    } else {
525      return AssignLargeString(std::forward<T>(src));
526    }
527  }
528  inline Cord::Cord(const Cord& src) : contents_(src.contents_) {}
529  inline Cord::Cord(Cord&& src) noexcept : contents_(std::move(src.contents_)) {}
530  inline void Cord::swap(Cord& other) noexcept {
531    contents_.Swap(&other.contents_);
532  }
533  inline Cord& Cord::operator=(Cord&& x) noexcept {
534    contents_ = std::move(x.contents_);
535    return *this;
536  }
537  extern template Cord::Cord(std::string&& src);
538  inline size_t Cord::size() const {
539    return contents_.size();
540  }
541  inline bool Cord::empty() const { return size() == 0; }
542  inline size_t Cord::EstimatedMemoryUsage(
543      CordMemoryAccounting accounting_method) const {
544    size_t result = sizeof(Cord);
545    if (const absl::cord_internal::CordRep* rep = contents_.tree()) {
546      if (accounting_method == CordMemoryAccounting::kFairShare) {
547        result += cord_internal::GetEstimatedFairShareMemoryUsage(rep);
548      } else {
549        result += cord_internal::GetEstimatedMemoryUsage(rep);
550      }
551    }
552    return result;
553  }
554  inline absl::optional<absl::string_view> Cord::TryFlat() const {
555    absl::cord_internal::CordRep* rep = contents_.tree();
556    if (rep == nullptr) {
557      return absl::string_view(contents_.data(), contents_.size());
558    }
559    absl::string_view fragment;
560    if (GetFlatAux(rep, &fragment)) {
561      return fragment;
562    }
563    return absl::nullopt;
564  }
565  inline absl::string_view Cord::Flatten() {
566    absl::cord_internal::CordRep* rep = contents_.tree();
567    if (rep == nullptr) {
568      return absl::string_view(contents_.data(), contents_.size());
569    } else {
570      absl::string_view already_flat_contents;
571      if (GetFlatAux(rep, &already_flat_contents)) {
572        return already_flat_contents;
573      }
574    }
575    return FlattenSlowPath();
576  }
577  inline void Cord::Append(absl::string_view src) {
578    contents_.AppendArray(src, CordzUpdateTracker::kAppendString);
579  }
580  inline void Cord::Prepend(absl::string_view src) {
581    PrependArray(src, CordzUpdateTracker::kPrependString);
582  }
583  inline void Cord::Append(CordBuffer buffer) {
584    if (ABSL_PREDICT_FALSE(buffer.length() == 0)) return;
585    absl::string_view short_value;
586    if (CordRep* rep = buffer.ConsumeValue(short_value)) {
587      contents_.AppendTree(rep, CordzUpdateTracker::kAppendCordBuffer);
588    } else {
589      AppendPrecise(short_value, CordzUpdateTracker::kAppendCordBuffer);
590    }
591  }
592  inline void Cord::Prepend(CordBuffer buffer) {
593    if (ABSL_PREDICT_FALSE(buffer.length() == 0)) return;
594    absl::string_view short_value;
595    if (CordRep* rep = buffer.ConsumeValue(short_value)) {
596      contents_.PrependTree(rep, CordzUpdateTracker::kPrependCordBuffer);
597    } else {
598      PrependPrecise(short_value, CordzUpdateTracker::kPrependCordBuffer);
599    }
600  }
601  inline CordBuffer Cord::GetAppendBuffer(size_t capacity, size_t min_capacity) {
602    if (empty()) return CordBuffer::CreateWithDefaultLimit(capacity);
603    return GetAppendBufferSlowPath(0, capacity, min_capacity);
604  }
605  inline CordBuffer Cord::GetCustomAppendBuffer(size_t block_size,
606                                                size_t capacity,
607                                                size_t min_capacity) {
608    if (empty()) {
609      return block_size ? CordBuffer::CreateWithCustomLimit(block_size, capacity)
610                        : CordBuffer::CreateWithDefaultLimit(capacity);
611    }
612    return GetAppendBufferSlowPath(block_size, capacity, min_capacity);
613  }
614  extern template void Cord::Append(std::string&& src);
615  extern template void Cord::Prepend(std::string&& src);
616  inline int Cord::Compare(const Cord& rhs) const {
617    if (!contents_.is_tree() && !rhs.contents_.is_tree()) {
618      return contents_.data_.Compare(rhs.contents_.data_);
619    }
620    return CompareImpl(rhs);
621  }
622  inline bool Cord::StartsWith(const Cord& rhs) const {
623    if (contents_.IsSame(rhs.contents_)) return true;
624    size_t rhs_size = rhs.size();
625    if (size() < rhs_size) return false;
626    return EqualsImpl(rhs, rhs_size);
627  }
628  inline bool Cord::StartsWith(absl::string_view rhs) const {
629    size_t rhs_size = rhs.size();
630    if (size() < rhs_size) return false;
631    return EqualsImpl(rhs, rhs_size);
632  }
633  inline void Cord::ChunkIterator::InitTree(cord_internal::CordRep* tree) {
634    tree = cord_internal::SkipCrcNode(tree);
635    if (tree->tag == cord_internal::BTREE) {
636      current_chunk_ = btree_reader_.Init(tree->btree());
637    } else {
638      current_leaf_ = tree;
639      current_chunk_ = cord_internal::EdgeData(tree);
640    }
641  }
642  inline Cord::ChunkIterator::ChunkIterator(cord_internal::CordRep* tree) {
643    bytes_remaining_ = tree->length;
644    InitTree(tree);
645  }
646  inline Cord::ChunkIterator::ChunkIterator(const Cord* cord) {
647    if (CordRep* tree = cord->contents_.tree()) {
648      bytes_remaining_ = tree->length;
649      if (ABSL_PREDICT_TRUE(bytes_remaining_ != 0)) {
650        InitTree(tree);
651      } else {
652        current_chunk_ = {};
653      }
654    } else {
655      bytes_remaining_ = cord->contents_.inline_size();
656      current_chunk_ = {cord->contents_.data(), bytes_remaining_};
657    }
658  }
659  inline Cord::ChunkIterator& Cord::ChunkIterator::AdvanceBtree() {
660    current_chunk_ = btree_reader_.Next();
661    return *this;
662  }
663  inline void Cord::ChunkIterator::AdvanceBytesBtree(size_t n) {
664    assert(n >= current_chunk_.size());
665    bytes_remaining_ -= n;
666    if (bytes_remaining_) {
667      if (n == current_chunk_.size()) {
668        current_chunk_ = btree_reader_.Next();
669      } else {
670        size_t offset = btree_reader_.length() - bytes_remaining_;
671        current_chunk_ = btree_reader_.Seek(offset);
672      }
673    } else {
674      current_chunk_ = {};
675    }
676  }
677  inline Cord::ChunkIterator& Cord::ChunkIterator::operator++() {
678    ABSL_HARDENING_ASSERT(bytes_remaining_ > 0 &&
679                          "Attempted to iterate past `end()`");
680    assert(bytes_remaining_ >= current_chunk_.size());
681    bytes_remaining_ -= current_chunk_.size();
682    if (bytes_remaining_ > 0) {
683      if (btree_reader_) {
684        return AdvanceBtree();
685      } else {
686        assert(!current_chunk_.empty());  
687      }
688      current_chunk_ = {};
689    }
690    return *this;
691  }
692  inline Cord::ChunkIterator Cord::ChunkIterator::operator++(int) {
693    ChunkIterator tmp(*this);
694    operator++();
695    return tmp;
696  }
697  inline bool Cord::ChunkIterator::operator==(const ChunkIterator& other) const {
698    return bytes_remaining_ == other.bytes_remaining_;
699  }
700  inline bool Cord::ChunkIterator::operator!=(const ChunkIterator& other) const {
701    return !(*this == other);
702  }
703  inline Cord::ChunkIterator::reference Cord::ChunkIterator::operator*() const {
704    ABSL_HARDENING_ASSERT(bytes_remaining_ != 0);
705    return current_chunk_;
706  }
707  inline Cord::ChunkIterator::pointer Cord::ChunkIterator::operator->() const {
708    ABSL_HARDENING_ASSERT(bytes_remaining_ != 0);
709    return &current_chunk_;
710  }
711  inline void Cord::ChunkIterator::RemoveChunkPrefix(size_t n) {
712    assert(n < current_chunk_.size());
713    current_chunk_.remove_prefix(n);
714    bytes_remaining_ -= n;
715  }
716  inline void Cord::ChunkIterator::AdvanceBytes(size_t n) {
717    assert(bytes_remaining_ >= n);
718    if (ABSL_PREDICT_TRUE(n < current_chunk_.size())) {
719      RemoveChunkPrefix(n);
720    } else if (n != 0) {
721      if (btree_reader_) {
722        AdvanceBytesBtree(n);
723      } else {
724        bytes_remaining_ = 0;
725      }
726    }
727  }
728  inline Cord::ChunkIterator Cord::chunk_begin() const {
729    return ChunkIterator(this);
730  }
731  inline Cord::ChunkIterator Cord::chunk_end() const { return ChunkIterator(); }
732  inline Cord::ChunkIterator Cord::ChunkRange::begin() const {
733    return cord_->chunk_begin();
734  }
735  inline Cord::ChunkIterator Cord::ChunkRange::end() const {
736    return cord_->chunk_end();
737  }
738  inline Cord::ChunkRange Cord::Chunks() const { return ChunkRange(this); }
739  inline Cord::CharIterator& Cord::CharIterator::operator++() {
740    if (ABSL_PREDICT_TRUE(chunk_iterator_->size() > 1)) {
741      chunk_iterator_.RemoveChunkPrefix(1);
742    } else {
743      ++chunk_iterator_;
744    }
745    return *this;
746  }
747  inline Cord::CharIterator Cord::CharIterator::operator++(int) {
748    CharIterator tmp(*this);
749    operator++();
750    return tmp;
751  }
752  inline bool Cord::CharIterator::operator==(const CharIterator& other) const {
753    return chunk_iterator_ == other.chunk_iterator_;
754  }
755  inline bool Cord::CharIterator::operator!=(const CharIterator& other) const {
756    return !(*this == other);
757  }
758  inline Cord::CharIterator::reference Cord::CharIterator::operator*() const {
759    return *chunk_iterator_->data();
760  }
761  inline Cord::CharIterator::pointer Cord::CharIterator::operator->() const {
762    return chunk_iterator_->data();
763  }
764  inline Cord Cord::AdvanceAndRead(CharIterator* it, size_t n_bytes) {
765    assert(it != nullptr);
766    return it->chunk_iterator_.AdvanceAndReadBytes(n_bytes);
767  }
768  inline void Cord::Advance(CharIterator* it, size_t n_bytes) {
769    assert(it != nullptr);
770    it->chunk_iterator_.AdvanceBytes(n_bytes);
771  }
772  inline absl::string_view Cord::ChunkRemaining(const CharIterator& it) {
773    return *it.chunk_iterator_;
774  }
775  inline Cord::CharIterator Cord::char_begin() const {
776    return CharIterator(this);
777  }
778  inline Cord::CharIterator Cord::char_end() const { return CharIterator(); }
779  inline Cord::CharIterator Cord::CharRange::begin() const {
780    return cord_->char_begin();
781  }
782  inline Cord::CharIterator Cord::CharRange::end() const {
783    return cord_->char_end();
784  }
785  inline Cord::CharRange Cord::Chars() const { return CharRange(this); }
786  inline void Cord::ForEachChunk(
787      absl::FunctionRef<void(absl::string_view)> callback) const {
788    absl::cord_internal::CordRep* rep = contents_.tree();
789    if (rep == nullptr) {
790      callback(absl::string_view(contents_.data(), contents_.size()));
791    } else {
792      ForEachChunkAux(rep, callback);
793    }
794  }
795  inline bool operator==(const Cord& lhs, const Cord& rhs) {
796    if (lhs.contents_.IsSame(rhs.contents_)) return true;
797    size_t rhs_size = rhs.size();
798    if (lhs.size() != rhs_size) return false;
799    return lhs.EqualsImpl(rhs, rhs_size);
800  }
801  inline bool operator!=(const Cord& x, const Cord& y) { return !(x == y); }
802  inline bool operator<(const Cord& x, const Cord& y) { return x.Compare(y) < 0; }
803  inline bool operator>(const Cord& x, const Cord& y) { return x.Compare(y) > 0; }
804  inline bool operator<=(const Cord& x, const Cord& y) {
805    return x.Compare(y) <= 0;
806  }
807  inline bool operator>=(const Cord& x, const Cord& y) {
808    return x.Compare(y) >= 0;
809  }
810  inline bool operator==(const Cord& lhs, absl::string_view rhs) {
811    size_t lhs_size = lhs.size();
812    size_t rhs_size = rhs.size();
813    if (lhs_size != rhs_size) return false;
814    return lhs.EqualsImpl(rhs, rhs_size);
815  }
816  inline bool operator==(absl::string_view x, const Cord& y) { return y == x; }
817  inline bool operator!=(const Cord& x, absl::string_view y) { return !(x == y); }
818  inline bool operator!=(absl::string_view x, const Cord& y) { return !(x == y); }
819  inline bool operator<(const Cord& x, absl::string_view y) {
820    return x.Compare(y) < 0;
821  }
822  inline bool operator<(absl::string_view x, const Cord& y) {
823    return y.Compare(x) > 0;
824  }
825  inline bool operator>(const Cord& x, absl::string_view y) { return y < x; }
826  inline bool operator>(absl::string_view x, const Cord& y) { return y < x; }
827  inline bool operator<=(const Cord& x, absl::string_view y) { return !(y < x); }
828  inline bool operator<=(absl::string_view x, const Cord& y) { return !(y < x); }
829  inline bool operator>=(const Cord& x, absl::string_view y) { return !(x < y); }
830  inline bool operator>=(absl::string_view x, const Cord& y) { return !(x < y); }
831  namespace strings_internal {
832  class CordTestAccess {
833   public:
834    static size_t FlatOverhead();
835    static size_t MaxFlatLength();
836    static size_t SizeofCordRepExternal();
837    static size_t SizeofCordRepSubstring();
838    static size_t FlatTagToLength(uint8_t tag);
839    static uint8_t LengthToTag(size_t s);
840  };
841  }  
842  ABSL_NAMESPACE_END
843  }  
844  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_store_81.hpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord.h</div>
                <div class="column column_space"><pre><code>21  		nano::store_iterator<nano::account, nano::confirmation_height_info> begin (nano::transaction const & transaction_a, nano::account const & account_a) const override;
22  		nano::store_iterator<nano::account, nano::confirmation_height_info> begin (nano::transaction const & transaction_a) const override;
23  		nano::store_iterator<nano::account, nano::confirmation_height_info> end () const override;
24  		void for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::account, nano::confirmation_height_info>, nano::store_iterator<nano::account, nano::confirmation_height_info>)> const & action_a) const override;
25  		MDB_dbi confirmation_height_handle{ 0 };
</pre></code></div>
                <div class="column column_space"><pre><code>243      const char* as_chars() const;
244      absl::cord_internal::CordRep* clear();
245      void reduce_size(size_t n);    
246      void remove_prefix(size_t n);  
247      void AppendArray(absl::string_view src, MethodIdentifier method);
248      absl::string_view FindFlatStartPiece() const;
249      CordRepFlat* MakeFlatWithExtraCapacity(size_t extra);
250      void SetTree(CordRep* rep, const CordzUpdateScope& scope);
251      void SetTreeOrEmpty(CordRep* rep, const CordzUpdateScope& scope);
252      void EmplaceTree(CordRep* rep, MethodIdentifier method);
253      void EmplaceTree(CordRep* rep, const InlineData& parent,
254                       MethodIdentifier method);
255      void CommitTree(const CordRep* old_rep, CordRep* rep,
256                      const CordzUpdateScope& scope, MethodIdentifier method);
257      void AppendTreeToInlined(CordRep* tree, MethodIdentifier method);
258      void AppendTreeToTree(CordRep* tree, MethodIdentifier method);
259      void AppendTree(CordRep* tree, MethodIdentifier method);
260      void PrependTreeToInlined(CordRep* tree, MethodIdentifier method);
261      void PrependTreeToTree(CordRep* tree, MethodIdentifier method);
262      void PrependTree(CordRep* tree, MethodIdentifier method);
263      bool IsSame(const InlineRep& other) const { return data_ == other.data_; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    