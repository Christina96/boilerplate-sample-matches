
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
3  #include <map>
4  #include <set>
5  #include <sstream>
6  #include <string>
7  #include <vector>
8  #if GTEST_HAS_EXCEPTIONS
9  # include <stdexcept>  
10  #endif
11  #include "gmock/gmock-actions.h"
12  #include "gmock/gmock-cardinalities.h"
13  #include "gmock/gmock-matchers.h"
14  #include "gmock/internal/gmock-internal-utils.h"
15  #include "gmock/internal/gmock-port.h"
16  #include "gtest/gtest.h"
17  namespace testing {
18  class Expectation;
19  class ExpectationSet;
20  namespace internal {
21  template <typename F> class FunctionMocker;
22  class ExpectationBase;
23  template <typename F> class TypedExpectation;
24  class ExpectationTester;
25  template <typename F> class FunctionMockerBase;
26  GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);
27  class UntypedActionResultHolderBase;
28  class GTEST_API_ UntypedFunctionMockerBase {
29   public:
30    UntypedFunctionMockerBase();
31    virtual ~UntypedFunctionMockerBase();
32    bool VerifyAndClearExpectationsLocked()
33        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
34    virtual void ClearDefaultActionsLocked()
35        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;
36    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
37        const void* untyped_args,
38        const string& call_description) const = 0;
39    virtual UntypedActionResultHolderBase* UntypedPerformAction(
40        const void* untyped_action,
41        const void* untyped_args) const = 0;
42    virtual void UntypedDescribeUninterestingCall(
43        const void* untyped_args,
44        ::std::ostream* os) const
45            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
46    virtual const ExpectationBase* UntypedFindMatchingExpectation(
47        const void* untyped_args,
48        const void** untyped_action, bool* is_excessive,
49        ::std::ostream* what, ::std::ostream* why)
50            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
51    virtual void UntypedPrintArgs(const void* untyped_args,
52                                  ::std::ostream* os) const = 0;
53    void RegisterOwner(const void* mock_obj)
54        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
55    void SetOwnerAndName(const void* mock_obj, const char* name)
56        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
57    const void* MockObject() const
58        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
59    const char* Name() const
60        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
61    const UntypedActionResultHolderBase* UntypedInvokeWith(
62        const void* untyped_args)
63            GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
64   protected:
65    typedef std::vector<const void*> UntypedOnCallSpecs;
66    typedef std::vector<internal::linked_ptr<ExpectationBase> >
67    UntypedExpectations;
68    Expectation GetHandleOf(ExpectationBase* exp);
69    const void* mock_obj_;  
70    const char* name_;  
71    UntypedOnCallSpecs untyped_on_call_specs_;
72    UntypedExpectations untyped_expectations_;
73  };  
74  class UntypedOnCallSpecBase {
75   public:
76    UntypedOnCallSpecBase(const char* a_file, int a_line)
77        : file_(a_file), line_(a_line), last_clause_(kNone) {}
78    const char* file() const { return file_; }
79    int line() const { return line_; }
80   protected:
81    enum Clause {
82      kNone,
83      kWith,
84      kWillByDefault
85    };
86    void AssertSpecProperty(bool property, const string& failure_message) const {
87      Assert(property, file_, line_, failure_message);
88    }
89    void ExpectSpecProperty(bool property, const string& failure_message) const {
90      Expect(property, file_, line_, failure_message);
91    }
92    const char* file_;
93    int line_;
94    Clause last_clause_;
95  };  
96  template <typename F>
97  class OnCallSpec : public UntypedOnCallSpecBase {
98   public:
99    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
100    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
101    OnCallSpec(const char* a_file, int a_line,
102               const ArgumentMatcherTuple& matchers)
103        : UntypedOnCallSpecBase(a_file, a_line),
104          matchers_(matchers),
105          extra_matcher_(A<const ArgumentTuple&>()) {
106    }
107    OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {
108      ExpectSpecProperty(last_clause_ < kWith,
109                         ".With() cannot appear "
110                         "more than once in an ON_CALL().");
111      last_clause_ = kWith;
112      extra_matcher_ = m;
113      return *this;
114    }
115    OnCallSpec& WillByDefault(const Action<F>& action) {
116      ExpectSpecProperty(last_clause_ < kWillByDefault,
117                         ".WillByDefault() must appear "
118                         "exactly once in an ON_CALL().");
119      last_clause_ = kWillByDefault;
120      ExpectSpecProperty(!action.IsDoDefault(),
121                         "DoDefault() cannot be used in ON_CALL().");
122      action_ = action;
123      return *this;
124    }
125    bool Matches(const ArgumentTuple& args) const {
126      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
127    }
128    const Action<F>& GetAction() const {
129      AssertSpecProperty(last_clause_ == kWillByDefault,
130                         ".WillByDefault() must appear exactly "
131                         "once in an ON_CALL().");
132      return action_;
133    }
134   private:
135    ArgumentMatcherTuple matchers_;
136    Matcher<const ArgumentTuple&> extra_matcher_;
137    Action<F> action_;
138  };  
139  enum CallReaction {
140    kAllow,
141    kWarn,
142    kFail,
143    kDefault = kWarn  
144  };
145  }  
146  class GTEST_API_ Mock {
147   public:
148    static void AllowLeak(const void* mock_obj)
149        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
150    static bool VerifyAndClearExpectations(void* mock_obj)
151        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
152    static bool VerifyAndClear(void* mock_obj)
153        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
154   private:
155    friend class internal::UntypedFunctionMockerBase;
156    template <typename F>
157    friend class internal::FunctionMockerBase;
158    template <typename M>
159    friend class NiceMock;
160    template <typename M>
161    friend class NaggyMock;
162    template <typename M>
163    friend class StrictMock;
164    static void AllowUninterestingCalls(const void* mock_obj)
165        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
166    static void WarnUninterestingCalls(const void* mock_obj)
167        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
168    static void FailUninterestingCalls(const void* mock_obj)
169        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
170    static void UnregisterCallReaction(const void* mock_obj)
171        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
172    static internal::CallReaction GetReactionOnUninterestingCalls(
173        const void* mock_obj)
174            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
175    static bool VerifyAndClearExpectationsLocked(void* mock_obj)
176        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
177    static void ClearDefaultActionsLocked(void* mock_obj)
178        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
179    static void Register(
180        const void* mock_obj,
181        internal::UntypedFunctionMockerBase* mocker)
182            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
183    static void RegisterUseByOnCallOrExpectCall(
184        const void* mock_obj, const char* file, int line)
185            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
186    static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
187        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
188  };  
189  class GTEST_API_ Expectation {
190   public:
191    Expectation();
192    ~Expectation();
193    Expectation(internal::ExpectationBase& exp);  
194    bool operator==(const Expectation& rhs) const {
195      return expectation_base_ == rhs.expectation_base_;
196    }
197    bool operator!=(const Expectation& rhs) const { return !(*this == rhs); }
198   private:
199    friend class ExpectationSet;
200    friend class Sequence;
201    friend class ::testing::internal::ExpectationBase;
202    friend class ::testing::internal::UntypedFunctionMockerBase;
203    template <typename F>
204    friend class ::testing::internal::FunctionMockerBase;
205    template <typename F>
206    friend class ::testing::internal::TypedExpectation;
207    class Less {
208     public:
209      bool operator()(const Expectation& lhs, const Expectation& rhs) const {
210        return lhs.expectation_base_.get() < rhs.expectation_base_.get();
211      }
212    };
213    typedef ::std::set<Expectation, Less> Set;
214    Expectation(
215        const internal::linked_ptr<internal::ExpectationBase>& expectation_base);
216    const internal::linked_ptr<internal::ExpectationBase>&
217    expectation_base() const {
218      return expectation_base_;
219    }
220    internal::linked_ptr<internal::ExpectationBase> expectation_base_;
221  };
222  class ExpectationSet {
223   public:
224    typedef Expectation::Set::const_iterator const_iterator;
225    typedef Expectation::Set::value_type value_type;
226    ExpectationSet() {}
227    ExpectationSet(internal::ExpectationBase& exp) {  
228      *this += Expectation(exp);
229    }
230    ExpectationSet(const Expectation& e) {  
231      *this += e;
232    }
233    bool operator==(const ExpectationSet& rhs) const {
234      return expectations_ == rhs.expectations_;
235    }
236    bool operator!=(const ExpectationSet& rhs) const { return !(*this == rhs); }
237    ExpectationSet& operator+=(const Expectation& e) {
238      expectations_.insert(e);
239      return *this;
240    }
241    int size() const { return static_cast<int>(expectations_.size()); }
242    const_iterator begin() const { return expectations_.begin(); }
243    const_iterator end() const { return expectations_.end(); }
244   private:
245    Expectation::Set expectations_;
246  };
247  class GTEST_API_ Sequence {
248   public:
249    Sequence() : last_expectation_(new Expectation) {}
250    void AddExpectation(const Expectation& expectation) const;
251   private:
252    internal::linked_ptr<Expectation> last_expectation_;
253  };  
254  class GTEST_API_ InSequence {
255   public:
256    InSequence();
257    ~InSequence();
258   private:
259    bool sequence_created_;
260    GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  
261  } GTEST_ATTRIBUTE_UNUSED_;
262  namespace internal {
263  GTEST_API_ extern ThreadLocal<Sequence*> g_gmock_implicit_sequence;
264  class GTEST_API_ ExpectationBase {
265   public:
266    ExpectationBase(const char* file, int line, const string& source_text);
267    virtual ~ExpectationBase();
268    const char* file() const { return file_; }
269    int line() const { return line_; }
270    const char* source_text() const { return source_text_.c_str(); }
271    const Cardinality& cardinality() const { return cardinality_; }
272    void DescribeLocationTo(::std::ostream* os) const {
273      *os << FormatFileLocation(file(), line()) << " ";
274    }
275    void DescribeCallCountTo(::std::ostream* os) const
276        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
277    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;
278   protected:
279    friend class ::testing::Expectation;
280    friend class UntypedFunctionMockerBase;
281    enum Clause {
282      kNone,
283      kWith,
284      kTimes,
285      kInSequence,
286      kAfter,
287      kWillOnce,
288      kWillRepeatedly,
289      kRetiresOnSaturation
290    };
291    typedef std::vector<const void*> UntypedActions;
292    virtual Expectation GetHandle() = 0;
293    void AssertSpecProperty(bool property, const string& failure_message) const {
294      Assert(property, file_, line_, failure_message);
295    }
296    void ExpectSpecProperty(bool property, const string& failure_message) const {
297      Expect(property, file_, line_, failure_message);
298    }
299    void SpecifyCardinality(const Cardinality& cardinality);
300    bool cardinality_specified() const { return cardinality_specified_; }
301    void set_cardinality(const Cardinality& a_cardinality) {
302      cardinality_ = a_cardinality;
303    }
304    void RetireAllPreRequisites()
305        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
306    bool is_retired() const
307        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
308      g_gmock_mutex.AssertHeld();
309      return retired_;
310    }
311    void Retire()
312        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
313      g_gmock_mutex.AssertHeld();
314      retired_ = true;
315    }
316    bool IsSatisfied() const
317        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
318      g_gmock_mutex.AssertHeld();
319      return cardinality().IsSatisfiedByCallCount(call_count_);
320    }
321    bool IsSaturated() const
322        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
323      g_gmock_mutex.AssertHeld();
324      return cardinality().IsSaturatedByCallCount(call_count_);
325    }
326    bool IsOverSaturated() const
327        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
328      g_gmock_mutex.AssertHeld();
329      return cardinality().IsOverSaturatedByCallCount(call_count_);
330    }
331    bool AllPrerequisitesAreSatisfied() const
332        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
333    void FindUnsatisfiedPrerequisites(ExpectationSet* result) const
334        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
335    int call_count() const
336        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
337      g_gmock_mutex.AssertHeld();
338      return call_count_;
339    }
340    void IncrementCallCount()
341        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
342      g_gmock_mutex.AssertHeld();
343      call_count_++;
344    }
345    void CheckActionCountIfNotDone() const
346        GTEST_LOCK_EXCLUDED_(mutex_);
347    friend class ::testing::Sequence;
348    friend class ::testing::internal::ExpectationTester;
349    template <typename Function>
350    friend class TypedExpectation;
351    void UntypedTimes(const Cardinality& a_cardinality);
352    const char* file_;          
353    int line_;                  
354    const string source_text_;  
355    bool cardinality_specified_;
356    Cardinality cardinality_;            
357    ExpectationSet immediate_prerequisites_;
358    int call_count_;  
359    bool retired_;    
360    UntypedActions untyped_actions_;
361    bool extra_matcher_specified_;
362    bool repeated_action_specified_;  
363    bool retires_on_saturation_;
364    Clause last_clause_;
365    mutable bool action_count_checked_;  
366    mutable Mutex mutex_;  
367    GTEST_DISALLOW_ASSIGN_(ExpectationBase);
368  };  
369  template <typename F>
370  class TypedExpectation : public ExpectationBase {
371   public:
372    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
373    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
374    typedef typename Function<F>::Result Result;
375    TypedExpectation(FunctionMockerBase<F>* owner,
376                     const char* a_file, int a_line, const string& a_source_text,
377                     const ArgumentMatcherTuple& m)
378        : ExpectationBase(a_file, a_line, a_source_text),
379          owner_(owner),
380          matchers_(m),
381          extra_matcher_(A<const ArgumentTuple&>()),
382          repeated_action_(DoDefault()) {}
383    virtual ~TypedExpectation() {
384      CheckActionCountIfNotDone();
385      for (UntypedActions::const_iterator it = untyped_actions_.begin();
386           it != untyped_actions_.end(); ++it) {
387        delete static_cast<const Action<F>*>(*it);
388      }
389    }
390    TypedExpectation& With(const Matcher<const ArgumentTuple&>& m) {
391      if (last_clause_ == kWith) {
392        ExpectSpecProperty(false,
393                           ".With() cannot appear "
394                           "more than once in an EXPECT_CALL().");
395      } else {
396        ExpectSpecProperty(last_clause_ < kWith,
397                           ".With() must be the first "
398                           "clause in an EXPECT_CALL().");
399      }
400      last_clause_ = kWith;
401      extra_matcher_ = m;
402      extra_matcher_specified_ = true;
403      return *this;
404    }
405    TypedExpectation& Times(const Cardinality& a_cardinality) {
406      ExpectationBase::UntypedTimes(a_cardinality);
407      return *this;
408    }
409    TypedExpectation& Times(int n) {
410      return Times(Exactly(n));
411    }
412    TypedExpectation& InSequence(const Sequence& s) {
413      ExpectSpecProperty(last_clause_ <= kInSequence,
414                         ".InSequence() cannot appear after .After(),"
415                         " .WillOnce(), .WillRepeatedly(), or "
416                         ".RetiresOnSaturation().");
417      last_clause_ = kInSequence;
418      s.AddExpectation(GetHandle());
419      return *this;
420    }
421    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2) {
422      return InSequence(s1).InSequence(s2);
423    }
424    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
425                                 const Sequence& s3) {
426      return InSequence(s1, s2).InSequence(s3);
427    }
428    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
429                                 const Sequence& s3, const Sequence& s4) {
430      return InSequence(s1, s2, s3).InSequence(s4);
431    }
432    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
433                                 const Sequence& s3, const Sequence& s4,
434                                 const Sequence& s5) {
435      return InSequence(s1, s2, s3, s4).InSequence(s5);
436    }
437    TypedExpectation& After(const ExpectationSet& s) {
438      ExpectSpecProperty(last_clause_ <= kAfter,
439                         ".After() cannot appear after .WillOnce(),"
440                         " .WillRepeatedly(), or "
441                         ".RetiresOnSaturation().");
442      last_clause_ = kAfter;
443      for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {
444        immediate_prerequisites_ += *it;
445      }
446      return *this;
447    }
448    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2) {
449      return After(s1).After(s2);
450    }
451    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
452                            const ExpectationSet& s3) {
453      return After(s1, s2).After(s3);
454    }
455    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
456                            const ExpectationSet& s3, const ExpectationSet& s4) {
457      return After(s1, s2, s3).After(s4);
458    }
459    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
460                            const ExpectationSet& s3, const ExpectationSet& s4,
461                            const ExpectationSet& s5) {
462      return After(s1, s2, s3, s4).After(s5);
463    }
464    TypedExpectation& WillOnce(const Action<F>& action) {
465      ExpectSpecProperty(last_clause_ <= kWillOnce,
466                         ".WillOnce() cannot appear after "
467                         ".WillRepeatedly() or .RetiresOnSaturation().");
468      last_clause_ = kWillOnce;
469      untyped_actions_.push_back(new Action<F>(action));
470      if (!cardinality_specified()) {
471        set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())));
472      }
473      return *this;
474    }
475    TypedExpectation& WillRepeatedly(const Action<F>& action) {
476      if (last_clause_ == kWillRepeatedly) {
477        ExpectSpecProperty(false,
478                           ".WillRepeatedly() cannot appear "
479                           "more than once in an EXPECT_CALL().");
480      } else {
481        ExpectSpecProperty(last_clause_ < kWillRepeatedly,
482                           ".WillRepeatedly() cannot appear "
483                           "after .RetiresOnSaturation().");
484      }
485      last_clause_ = kWillRepeatedly;
486      repeated_action_specified_ = true;
487      repeated_action_ = action;
488      if (!cardinality_specified()) {
489        set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())));
490      }
491      CheckActionCountIfNotDone();
492      return *this;
493    }
494    TypedExpectation& RetiresOnSaturation() {
495      ExpectSpecProperty(last_clause_ < kRetiresOnSaturation,
496                         ".RetiresOnSaturation() cannot appear "
497                         "more than once.");
498      last_clause_ = kRetiresOnSaturation;
499      retires_on_saturation_ = true;
500      CheckActionCountIfNotDone();
501      return *this;
502    }
503    const ArgumentMatcherTuple& matchers() const {
504      return matchers_;
505    }
506    const Matcher<const ArgumentTuple&>& extra_matcher() const {
507      return extra_matcher_;
508    }
509    const Action<F>& repeated_action() const { return repeated_action_; }
510    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {
511      if (extra_matcher_specified_) {
512        *os << "    Expected args: ";
513        extra_matcher_.DescribeTo(os);
514        *os << "\n";
515      }
516    }
517   private:
518    template <typename Function>
519    friend class FunctionMockerBase;
520    virtual Expectation GetHandle() {
521      return owner_->GetHandleOf(this);
522    }
<span onclick='openModal()' class='match'>523    bool Matches(const ArgumentTuple& args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
</span>527    }
528    bool ShouldHandleArguments(const ArgumentTuple& args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
532      return !is_retired() && AllPrerequisitesAreSatisfied() && Matches(args);
533    }
534    void ExplainMatchResultTo(
535        const ArgumentTuple& args,
536        ::std::ostream* os) const
537            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
538      g_gmock_mutex.AssertHeld();
539      if (is_retired()) {
540        *os << "         Expected: the expectation is active\n"
541            << "           Actual: it is retired\n";
542      } else if (!Matches(args)) {
543        if (!TupleMatches(matchers_, args)) {
544          ExplainMatchFailureTupleTo(matchers_, args, os);
545        }
546        StringMatchResultListener listener;
547        if (!extra_matcher_.MatchAndExplain(args, &listener)) {
548          *os << "    Expected args: ";
549          extra_matcher_.DescribeTo(os);
550          *os << "\n           Actual: don't match";
551          internal::PrintIfNotEmpty(listener.str(), os);
552          *os << "\n";
553        }
554      } else if (!AllPrerequisitesAreSatisfied()) {
555        *os << "         Expected: all pre-requisites are satisfied\n"
556            << "           Actual: the following immediate pre-requisites "
557            << "are not satisfied:\n";
558        ExpectationSet unsatisfied_prereqs;
559        FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);
560        int i = 0;
561        for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();
562             it != unsatisfied_prereqs.end(); ++it) {
563          it->expectation_base()->DescribeLocationTo(os);
564          *os << "pre-requisite #" << i++ << "\n";
565        }
566        *os << "                   (end of pre-requisites)\n";
567      } else {
568        *os << "The call matches the expectation.\n";
569      }
570    }
571    const Action<F>& GetCurrentAction(
572        const FunctionMockerBase<F>* mocker,
573        const ArgumentTuple& args) const
574            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
575      g_gmock_mutex.AssertHeld();
576      const int count = call_count();
577      Assert(count >= 1, __FILE__, __LINE__,
578             "call_count() is <= 0 when GetCurrentAction() is "
579             "called - this should never happen.");
580      const int action_count = static_cast<int>(untyped_actions_.size());
581      if (action_count > 0 && !repeated_action_specified_ &&
582          count > action_count) {
583        ::std::stringstream ss;
584        DescribeLocationTo(&ss);
585        ss << "Actions ran out in " << source_text() << "...\n"
586           << "Called " << count << " times, but only "
587           << action_count << " WillOnce()"
588           << (action_count == 1 ? " is" : "s are") << " specified - ";
589        mocker->DescribeDefaultActionTo(args, &ss);
590        Log(kWarning, ss.str(), 1);
591      }
592      return count <= action_count ?
593          *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :
594          repeated_action();
595    }
596    const Action<F>* GetActionForArguments(
597        const FunctionMockerBase<F>* mocker,
598        const ArgumentTuple& args,
599        ::std::ostream* what,
600        ::std::ostream* why)
601            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
602      g_gmock_mutex.AssertHeld();
603      if (IsSaturated()) {
604        IncrementCallCount();
605        *what << "Mock function called more times than expected - ";
606        mocker->DescribeDefaultActionTo(args, what);
607        DescribeCallCountTo(why);
608        return NULL;
609      }
610      IncrementCallCount();
611      RetireAllPreRequisites();
612      if (retires_on_saturation_ && IsSaturated()) {
613        Retire();
614      }
615      *what << "Mock function call matches " << source_text() <<"...\n";
616      return &(GetCurrentAction(mocker, args));
617    }
618    FunctionMockerBase<F>* const owner_;
619    ArgumentMatcherTuple matchers_;
620    Matcher<const ArgumentTuple&> extra_matcher_;
621    Action<F> repeated_action_;
622    GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);
623  };  
624  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
625                                  const char* file, int line,
626                                  const string& message);
627  template <typename F>
628  class MockSpec {
629   public:
630    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
631    typedef typename internal::Function<F>::ArgumentMatcherTuple
632        ArgumentMatcherTuple;
633    explicit MockSpec(internal::FunctionMockerBase<F>* function_mocker)
634        : function_mocker_(function_mocker) {}
635    internal::OnCallSpec<F>& InternalDefaultActionSetAt(
636        const char* file, int line, const char* obj, const char* call) {
637      LogWithLocation(internal::kInfo, file, line,
638          string("ON_CALL(") + obj + ", " + call + ") invoked");
639      return function_mocker_->AddNewOnCallSpec(file, line, matchers_);
640    }
641    internal::TypedExpectation<F>& InternalExpectedAt(
642        const char* file, int line, const char* obj, const char* call) {
643      const string source_text(string("EXPECT_CALL(") + obj + ", " + call + ")");
644      LogWithLocation(internal::kInfo, file, line, source_text + " invoked");
645      return function_mocker_->AddNewExpectation(
646          file, line, source_text, matchers_);
647    }
648   private:
649    template <typename Function>
650    friend class internal::FunctionMocker;
651    void SetMatchers(const ArgumentMatcherTuple& matchers) {
652      matchers_ = matchers;
653    }
654    internal::FunctionMockerBase<F>* const function_mocker_;
655    ArgumentMatcherTuple matchers_;
656    GTEST_DISALLOW_ASSIGN_(MockSpec);
657  };  
658  #ifdef _MSC_VER
659  # pragma warning(push)          
660  # pragma warning(disable:4355)  
661  #endif  
662  class UntypedActionResultHolderBase {
663   public:
664    virtual ~UntypedActionResultHolderBase() {}
665    virtual void PrintAsActionResult(::std::ostream* os) const = 0;
666  };
667  template <typename T>
668  class ActionResultHolder : public UntypedActionResultHolderBase {
669   public:
670    explicit ActionResultHolder(T a_value) : value_(a_value) {}
671    T GetValueAndDelete() const {
672      T retval(value_);
673      delete this;
674      return retval;
675    }
676    virtual void PrintAsActionResult(::std::ostream* os) const {
677      *os << "\n          Returns: ";
678      UniversalPrinter<T>::Print(value_, os);
679    }
680    template <typename F>
681    static ActionResultHolder* PerformDefaultAction(
682        const FunctionMockerBase<F>* func_mocker,
683        const typename Function<F>::ArgumentTuple& args,
684        const string& call_description) {
685      return new ActionResultHolder(
686          func_mocker->PerformDefaultAction(args, call_description));
687    }
688    template <typename F>
689    static ActionResultHolder*
690    PerformAction(const Action<F>& action,
691                  const typename Function<F>::ArgumentTuple& args) {
692      return new ActionResultHolder(action.Perform(args));
693    }
694   private:
695    T value_;
696    GTEST_DISALLOW_ASSIGN_(ActionResultHolder);
697  };
698  template <>
699  class ActionResultHolder<void> : public UntypedActionResultHolderBase {
700   public:
701    void GetValueAndDelete() const { delete this; }
702    virtual void PrintAsActionResult(::std::ostream* &bsol;* os */) const {}
703    template <typename F>
704    static ActionResultHolder* PerformDefaultAction(
705        const FunctionMockerBase<F>* func_mocker,
706        const typename Function<F>::ArgumentTuple& args,
707        const string& call_description) {
708      func_mocker->PerformDefaultAction(args, call_description);
709      return NULL;
710    }
711    template <typename F>
712    static ActionResultHolder* PerformAction(
713        const Action<F>& action,
714        const typename Function<F>::ArgumentTuple& args) {
715      action.Perform(args);
716      return NULL;
717    }
718  };
719  template <typename F>
720  class FunctionMockerBase : public UntypedFunctionMockerBase {
721   public:
722    typedef typename Function<F>::Result Result;
723    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
724    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
725    FunctionMockerBase() : current_spec_(this) {}
726    virtual ~FunctionMockerBase()
727          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
728      MutexLock l(&g_gmock_mutex);
729      VerifyAndClearExpectationsLocked();
730      Mock::UnregisterLocked(this);
731      ClearDefaultActionsLocked();
732    }
733    const OnCallSpec<F>* FindOnCallSpec(
734        const ArgumentTuple& args) const {
735      for (UntypedOnCallSpecs::const_reverse_iterator it
736               = untyped_on_call_specs_.rbegin();
737           it != untyped_on_call_specs_.rend(); ++it) {
738        const OnCallSpec<F>* spec = static_cast<const OnCallSpec<F>*>(*it);
739        if (spec->Matches(args))
740          return spec;
741      }
742      return NULL;
743    }
744    Result PerformDefaultAction(const ArgumentTuple& args,
745                                const string& call_description) const {
746      const OnCallSpec<F>* const spec =
747          this->FindOnCallSpec(args);
748      if (spec != NULL) {
749        return spec->GetAction().Perform(args);
750      }
751      const string message = call_description +
752          "\n    The mock function has no default action "
753          "set, and its return type has no default value set.";
754  #if GTEST_HAS_EXCEPTIONS
755      if (!DefaultValue<Result>::Exists()) {
756        throw std::runtime_error(message);
757      }
758  #else
759      Assert(DefaultValue<Result>::Exists(), "", -1, message);
760  #endif
761      return DefaultValue<Result>::Get();
762    }
763    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
764        const void* untyped_args,  
765        const string& call_description) const {
766      const ArgumentTuple& args =
767          *static_cast<const ArgumentTuple*>(untyped_args);
768      return ResultHolder::PerformDefaultAction(this, args, call_description);
769    }
770    virtual UntypedActionResultHolderBase* UntypedPerformAction(
771        const void* untyped_action, const void* untyped_args) const {
772      const Action<F> action = *static_cast<const Action<F>*>(untyped_action);
773      const ArgumentTuple& args =
774          *static_cast<const ArgumentTuple*>(untyped_args);
775      return ResultHolder::PerformAction(action, args);
776    }
777    virtual void ClearDefaultActionsLocked()
778        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
779      g_gmock_mutex.AssertHeld();
780      UntypedOnCallSpecs specs_to_delete;
781      untyped_on_call_specs_.swap(specs_to_delete);
782      g_gmock_mutex.Unlock();
783      for (UntypedOnCallSpecs::const_iterator it =
784               specs_to_delete.begin();
785           it != specs_to_delete.end(); ++it) {
786        delete static_cast<const OnCallSpec<F>*>(*it);
787      }
788      g_gmock_mutex.Lock();
789    }
790   protected:
791    template <typename Function>
792    friend class MockSpec;
793    typedef ActionResultHolder<Result> ResultHolder;
794    Result InvokeWith(const ArgumentTuple& args)
795          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
796      return static_cast<const ResultHolder*>(
797          this->UntypedInvokeWith(&args))->GetValueAndDelete();
798    }
799    OnCallSpec<F>& AddNewOnCallSpec(
800        const char* file, int line,
801        const ArgumentMatcherTuple& m)
802            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
803      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
804      OnCallSpec<F>* const on_call_spec = new OnCallSpec<F>(file, line, m);
805      untyped_on_call_specs_.push_back(on_call_spec);
806      return *on_call_spec;
807    }
808    TypedExpectation<F>& AddNewExpectation(
809        const char* file,
810        int line,
811        const string& source_text,
812        const ArgumentMatcherTuple& m)
813            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
814      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
815      TypedExpectation<F>* const expectation =
816          new TypedExpectation<F>(this, file, line, source_text, m);
817      const linked_ptr<ExpectationBase> untyped_expectation(expectation);
818      untyped_expectations_.push_back(untyped_expectation);
819      Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();
820      if (implicit_sequence != NULL) {
821        implicit_sequence->AddExpectation(Expectation(untyped_expectation));
822      }
823      return *expectation;
824    }
825    MockSpec<F>& current_spec() { return current_spec_; }
826   private:
827    template <typename Func> friend class TypedExpectation;
828    void DescribeDefaultActionTo(const ArgumentTuple& args,
829                                 ::std::ostream* os) const {
830      const OnCallSpec<F>* const spec = FindOnCallSpec(args);
831      if (spec == NULL) {
832        *os << (internal::type_equals<Result, void>::value ?
833                "returning directly.\n" :
834                "returning default value.\n");
835      } else {
836        *os << "taking default action specified at:\n"
837            << FormatFileLocation(spec->file(), spec->line()) << "\n";
838      }
839    }
840    virtual void UntypedDescribeUninterestingCall(
841        const void* untyped_args,
842        ::std::ostream* os) const
843            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
844      const ArgumentTuple& args =
845          *static_cast<const ArgumentTuple*>(untyped_args);
846      *os << "Uninteresting mock function call - ";
847      DescribeDefaultActionTo(args, os);
848      *os << "    Function call: " << Name();
849      UniversalPrint(args, os);
850    }
851    virtual const ExpectationBase* UntypedFindMatchingExpectation(
852        const void* untyped_args,
853        const void** untyped_action, bool* is_excessive,
854        ::std::ostream* what, ::std::ostream* why)
855            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
856      const ArgumentTuple& args =
857          *static_cast<const ArgumentTuple*>(untyped_args);
858      MutexLock l(&g_gmock_mutex);
859      TypedExpectation<F>* exp = this->FindMatchingExpectationLocked(args);
860      if (exp == NULL) {  
861        this->FormatUnexpectedCallMessageLocked(args, what, why);
862        return NULL;
863      }
864      *is_excessive = exp->IsSaturated();
865      const Action<F>* action = exp->GetActionForArguments(this, args, what, why);
866      if (action != NULL && action->IsDoDefault())
867        action = NULL;  
868      *untyped_action = action;
869      return exp;
870    }
871    virtual void UntypedPrintArgs(const void* untyped_args,
872                                  ::std::ostream* os) const {
873      const ArgumentTuple& args =
874          *static_cast<const ArgumentTuple*>(untyped_args);
875      UniversalPrint(args, os);
876    }
877    TypedExpectation<F>* FindMatchingExpectationLocked(
878        const ArgumentTuple& args) const
879            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
880      g_gmock_mutex.AssertHeld();
881      for (typename UntypedExpectations::const_reverse_iterator it =
882               untyped_expectations_.rbegin();
883           it != untyped_expectations_.rend(); ++it) {
884        TypedExpectation<F>* const exp =
885            static_cast<TypedExpectation<F>*>(it->get());
886        if (exp->ShouldHandleArguments(args)) {
887          return exp;
888        }
889      }
890      return NULL;
891    }
892    void FormatUnexpectedCallMessageLocked(
893        const ArgumentTuple& args,
894        ::std::ostream* os,
895        ::std::ostream* why) const
896            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
897      g_gmock_mutex.AssertHeld();
898      *os << "\nUnexpected mock function call - ";
899      DescribeDefaultActionTo(args, os);
900      PrintTriedExpectationsLocked(args, why);
901    }
902    void PrintTriedExpectationsLocked(
903        const ArgumentTuple& args,
904        ::std::ostream* why) const
905            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
906      g_gmock_mutex.AssertHeld();
907      const int count = static_cast<int>(untyped_expectations_.size());
908      *why << "Google Mock tried the following " << count << " "
909           << (count == 1 ? "expectation, but it didn't match" :
910               "expectations, but none matched")
911           << ":\n";
912      for (int i = 0; i < count; i++) {
913        TypedExpectation<F>* const expectation =
914            static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());
915        *why << "\n";
916        expectation->DescribeLocationTo(why);
917        if (count > 1) {
918          *why << "tried expectation #" << i << ": ";
919        }
920        *why << expectation->source_text() << "...\n";
921        expectation->ExplainMatchResultTo(args, why);
922        expectation->DescribeCallCountTo(why);
923      }
924    }
925    MockSpec<F> current_spec_;
926    GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);
927  };  
928  #ifdef _MSC_VER
929  # pragma warning(pop)  
930  #endif  
931  void ReportUninterestingCall(CallReaction reaction, const string& msg);
932  }  
933  using internal::MockSpec;
934  template <typename T>
935  inline const T& Const(const T& x) { return x; }
936  inline Expectation::Expectation(internal::ExpectationBase& exp)  
937      : expectation_base_(exp.GetHandle().expectation_base()) {}
938  }  
939  #define GMOCK_ON_CALL_IMPL_(obj, call) \
940      ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \
941                                                      #obj, #call)
942  #define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)
943  #define GMOCK_EXPECT_CALL_IMPL_(obj, call) \
944      ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)
945  #define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)
946  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
3  #include <map>
4  #include <set>
5  #include <sstream>
6  #include <string>
7  #include <vector>
8  #if GTEST_HAS_EXCEPTIONS
9  # include <stdexcept>  
10  #endif
11  #include "gmock/gmock-actions.h"
12  #include "gmock/gmock-cardinalities.h"
13  #include "gmock/gmock-matchers.h"
14  #include "gmock/internal/gmock-internal-utils.h"
15  #include "gmock/internal/gmock-port.h"
16  #include "gtest/gtest.h"
17  namespace testing {
18  class Expectation;
19  class ExpectationSet;
20  namespace internal {
21  template <typename F> class FunctionMocker;
22  class ExpectationBase;
23  template <typename F> class TypedExpectation;
24  class ExpectationTester;
25  template <typename F> class FunctionMockerBase;
26  GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);
27  class UntypedActionResultHolderBase;
28  class GTEST_API_ UntypedFunctionMockerBase {
29   public:
30    UntypedFunctionMockerBase();
31    virtual ~UntypedFunctionMockerBase();
32    bool VerifyAndClearExpectationsLocked()
33        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
34    virtual void ClearDefaultActionsLocked()
35        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;
36    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
37        const void* untyped_args,
38        const string& call_description) const = 0;
39    virtual UntypedActionResultHolderBase* UntypedPerformAction(
40        const void* untyped_action,
41        const void* untyped_args) const = 0;
42    virtual void UntypedDescribeUninterestingCall(
43        const void* untyped_args,
44        ::std::ostream* os) const
45            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
46    virtual const ExpectationBase* UntypedFindMatchingExpectation(
47        const void* untyped_args,
48        const void** untyped_action, bool* is_excessive,
49        ::std::ostream* what, ::std::ostream* why)
50            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
51    virtual void UntypedPrintArgs(const void* untyped_args,
52                                  ::std::ostream* os) const = 0;
53    void RegisterOwner(const void* mock_obj)
54        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
55    void SetOwnerAndName(const void* mock_obj, const char* name)
56        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
57    const void* MockObject() const
58        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
59    const char* Name() const
60        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
61    const UntypedActionResultHolderBase* UntypedInvokeWith(
62        const void* untyped_args)
63            GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
64   protected:
65    typedef std::vector<const void*> UntypedOnCallSpecs;
66    typedef std::vector<internal::linked_ptr<ExpectationBase> >
67    UntypedExpectations;
68    Expectation GetHandleOf(ExpectationBase* exp);
69    const void* mock_obj_;  
70    const char* name_;  
71    UntypedOnCallSpecs untyped_on_call_specs_;
72    UntypedExpectations untyped_expectations_;
73  };  
74  class UntypedOnCallSpecBase {
75   public:
76    UntypedOnCallSpecBase(const char* a_file, int a_line)
77        : file_(a_file), line_(a_line), last_clause_(kNone) {}
78    const char* file() const { return file_; }
79    int line() const { return line_; }
80   protected:
81    enum Clause {
82      kNone,
83      kWith,
84      kWillByDefault
85    };
86    void AssertSpecProperty(bool property, const string& failure_message) const {
87      Assert(property, file_, line_, failure_message);
88    }
89    void ExpectSpecProperty(bool property, const string& failure_message) const {
90      Expect(property, file_, line_, failure_message);
91    }
92    const char* file_;
93    int line_;
94    Clause last_clause_;
95  };  
96  template <typename F>
97  class OnCallSpec : public UntypedOnCallSpecBase {
98   public:
99    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
100    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
101    OnCallSpec(const char* a_file, int a_line,
102               const ArgumentMatcherTuple& matchers)
103        : UntypedOnCallSpecBase(a_file, a_line),
104          matchers_(matchers),
105          extra_matcher_(A<const ArgumentTuple&>()) {
106    }
107    OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {
108      ExpectSpecProperty(last_clause_ < kWith,
109                         ".With() cannot appear "
110                         "more than once in an ON_CALL().");
111      last_clause_ = kWith;
112      extra_matcher_ = m;
113      return *this;
114    }
115    OnCallSpec& WillByDefault(const Action<F>& action) {
116      ExpectSpecProperty(last_clause_ < kWillByDefault,
117                         ".WillByDefault() must appear "
118                         "exactly once in an ON_CALL().");
119      last_clause_ = kWillByDefault;
120      ExpectSpecProperty(!action.IsDoDefault(),
121                         "DoDefault() cannot be used in ON_CALL().");
122      action_ = action;
123      return *this;
124    }
125    bool Matches(const ArgumentTuple& args) const {
126      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
127    }
128    const Action<F>& GetAction() const {
129      AssertSpecProperty(last_clause_ == kWillByDefault,
130                         ".WillByDefault() must appear exactly "
131                         "once in an ON_CALL().");
132      return action_;
133    }
134   private:
135    ArgumentMatcherTuple matchers_;
136    Matcher<const ArgumentTuple&> extra_matcher_;
137    Action<F> action_;
138  };  
139  enum CallReaction {
140    kAllow,
141    kWarn,
142    kFail,
143    kDefault = kWarn  
144  };
145  }  
146  class GTEST_API_ Mock {
147   public:
148    static void AllowLeak(const void* mock_obj)
149        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
150    static bool VerifyAndClearExpectations(void* mock_obj)
151        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
152    static bool VerifyAndClear(void* mock_obj)
153        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
154   private:
155    friend class internal::UntypedFunctionMockerBase;
156    template <typename F>
157    friend class internal::FunctionMockerBase;
158    template <typename M>
159    friend class NiceMock;
160    template <typename M>
161    friend class NaggyMock;
162    template <typename M>
163    friend class StrictMock;
164    static void AllowUninterestingCalls(const void* mock_obj)
165        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
166    static void WarnUninterestingCalls(const void* mock_obj)
167        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
168    static void FailUninterestingCalls(const void* mock_obj)
169        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
170    static void UnregisterCallReaction(const void* mock_obj)
171        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
172    static internal::CallReaction GetReactionOnUninterestingCalls(
173        const void* mock_obj)
174            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
175    static bool VerifyAndClearExpectationsLocked(void* mock_obj)
176        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
177    static void ClearDefaultActionsLocked(void* mock_obj)
178        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
179    static void Register(
180        const void* mock_obj,
181        internal::UntypedFunctionMockerBase* mocker)
182            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
183    static void RegisterUseByOnCallOrExpectCall(
184        const void* mock_obj, const char* file, int line)
185            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
186    static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
187        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
188  };  
189  class GTEST_API_ Expectation {
190   public:
191    Expectation();
192    ~Expectation();
193    Expectation(internal::ExpectationBase& exp);  
194    bool operator==(const Expectation& rhs) const {
195      return expectation_base_ == rhs.expectation_base_;
196    }
197    bool operator!=(const Expectation& rhs) const { return !(*this == rhs); }
198   private:
199    friend class ExpectationSet;
200    friend class Sequence;
201    friend class ::testing::internal::ExpectationBase;
202    friend class ::testing::internal::UntypedFunctionMockerBase;
203    template <typename F>
204    friend class ::testing::internal::FunctionMockerBase;
205    template <typename F>
206    friend class ::testing::internal::TypedExpectation;
207    class Less {
208     public:
209      bool operator()(const Expectation& lhs, const Expectation& rhs) const {
210        return lhs.expectation_base_.get() < rhs.expectation_base_.get();
211      }
212    };
213    typedef ::std::set<Expectation, Less> Set;
214    Expectation(
215        const internal::linked_ptr<internal::ExpectationBase>& expectation_base);
216    const internal::linked_ptr<internal::ExpectationBase>&
217    expectation_base() const {
218      return expectation_base_;
219    }
220    internal::linked_ptr<internal::ExpectationBase> expectation_base_;
221  };
222  class ExpectationSet {
223   public:
224    typedef Expectation::Set::const_iterator const_iterator;
225    typedef Expectation::Set::value_type value_type;
226    ExpectationSet() {}
227    ExpectationSet(internal::ExpectationBase& exp) {  
228      *this += Expectation(exp);
229    }
230    ExpectationSet(const Expectation& e) {  
231      *this += e;
232    }
233    bool operator==(const ExpectationSet& rhs) const {
234      return expectations_ == rhs.expectations_;
235    }
236    bool operator!=(const ExpectationSet& rhs) const { return !(*this == rhs); }
237    ExpectationSet& operator+=(const Expectation& e) {
238      expectations_.insert(e);
239      return *this;
240    }
241    int size() const { return static_cast<int>(expectations_.size()); }
242    const_iterator begin() const { return expectations_.begin(); }
243    const_iterator end() const { return expectations_.end(); }
244   private:
245    Expectation::Set expectations_;
246  };
247  class GTEST_API_ Sequence {
248   public:
249    Sequence() : last_expectation_(new Expectation) {}
250    void AddExpectation(const Expectation& expectation) const;
251   private:
252    internal::linked_ptr<Expectation> last_expectation_;
253  };  
254  class GTEST_API_ InSequence {
255   public:
256    InSequence();
257    ~InSequence();
258   private:
259    bool sequence_created_;
260    GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  
261  } GTEST_ATTRIBUTE_UNUSED_;
262  namespace internal {
263  GTEST_API_ extern ThreadLocal<Sequence*> g_gmock_implicit_sequence;
264  class GTEST_API_ ExpectationBase {
265   public:
266    ExpectationBase(const char* file, int line, const string& source_text);
267    virtual ~ExpectationBase();
268    const char* file() const { return file_; }
269    int line() const { return line_; }
270    const char* source_text() const { return source_text_.c_str(); }
271    const Cardinality& cardinality() const { return cardinality_; }
272    void DescribeLocationTo(::std::ostream* os) const {
273      *os << FormatFileLocation(file(), line()) << " ";
274    }
275    void DescribeCallCountTo(::std::ostream* os) const
276        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
277    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;
278   protected:
279    friend class ::testing::Expectation;
280    friend class UntypedFunctionMockerBase;
281    enum Clause {
282      kNone,
283      kWith,
284      kTimes,
285      kInSequence,
286      kAfter,
287      kWillOnce,
288      kWillRepeatedly,
289      kRetiresOnSaturation
290    };
291    typedef std::vector<const void*> UntypedActions;
292    virtual Expectation GetHandle() = 0;
293    void AssertSpecProperty(bool property, const string& failure_message) const {
294      Assert(property, file_, line_, failure_message);
295    }
296    void ExpectSpecProperty(bool property, const string& failure_message) const {
297      Expect(property, file_, line_, failure_message);
298    }
299    void SpecifyCardinality(const Cardinality& cardinality);
300    bool cardinality_specified() const { return cardinality_specified_; }
301    void set_cardinality(const Cardinality& a_cardinality) {
302      cardinality_ = a_cardinality;
303    }
304    void RetireAllPreRequisites()
305        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
306    bool is_retired() const
307        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
308      g_gmock_mutex.AssertHeld();
309      return retired_;
310    }
311    void Retire()
312        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
313      g_gmock_mutex.AssertHeld();
314      retired_ = true;
315    }
316    bool IsSatisfied() const
317        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
318      g_gmock_mutex.AssertHeld();
319      return cardinality().IsSatisfiedByCallCount(call_count_);
320    }
321    bool IsSaturated() const
322        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
323      g_gmock_mutex.AssertHeld();
324      return cardinality().IsSaturatedByCallCount(call_count_);
325    }
326    bool IsOverSaturated() const
327        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
328      g_gmock_mutex.AssertHeld();
329      return cardinality().IsOverSaturatedByCallCount(call_count_);
330    }
331    bool AllPrerequisitesAreSatisfied() const
332        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
333    void FindUnsatisfiedPrerequisites(ExpectationSet* result) const
334        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
335    int call_count() const
336        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
337      g_gmock_mutex.AssertHeld();
338      return call_count_;
339    }
340    void IncrementCallCount()
341        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
342      g_gmock_mutex.AssertHeld();
343      call_count_++;
344    }
345    void CheckActionCountIfNotDone() const
346        GTEST_LOCK_EXCLUDED_(mutex_);
347    friend class ::testing::Sequence;
348    friend class ::testing::internal::ExpectationTester;
349    template <typename Function>
350    friend class TypedExpectation;
351    void UntypedTimes(const Cardinality& a_cardinality);
352    const char* file_;          
353    int line_;                  
354    const string source_text_;  
355    bool cardinality_specified_;
356    Cardinality cardinality_;            
357    ExpectationSet immediate_prerequisites_;
358    int call_count_;  
359    bool retired_;    
360    UntypedActions untyped_actions_;
361    bool extra_matcher_specified_;
362    bool repeated_action_specified_;  
363    bool retires_on_saturation_;
364    Clause last_clause_;
365    mutable bool action_count_checked_;  
366    mutable Mutex mutex_;  
367    GTEST_DISALLOW_ASSIGN_(ExpectationBase);
368  };  
369  template <typename F>
370  class TypedExpectation : public ExpectationBase {
371   public:
372    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
373    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
374    typedef typename Function<F>::Result Result;
375    TypedExpectation(FunctionMockerBase<F>* owner,
376                     const char* a_file, int a_line, const string& a_source_text,
377                     const ArgumentMatcherTuple& m)
378        : ExpectationBase(a_file, a_line, a_source_text),
379          owner_(owner),
380          matchers_(m),
381          extra_matcher_(A<const ArgumentTuple&>()),
382          repeated_action_(DoDefault()) {}
383    virtual ~TypedExpectation() {
384      CheckActionCountIfNotDone();
385      for (UntypedActions::const_iterator it = untyped_actions_.begin();
386           it != untyped_actions_.end(); ++it) {
387        delete static_cast<const Action<F>*>(*it);
388      }
389    }
390    TypedExpectation& With(const Matcher<const ArgumentTuple&>& m) {
391      if (last_clause_ == kWith) {
392        ExpectSpecProperty(false,
393                           ".With() cannot appear "
394                           "more than once in an EXPECT_CALL().");
395      } else {
396        ExpectSpecProperty(last_clause_ < kWith,
397                           ".With() must be the first "
398                           "clause in an EXPECT_CALL().");
399      }
400      last_clause_ = kWith;
401      extra_matcher_ = m;
402      extra_matcher_specified_ = true;
403      return *this;
404    }
405    TypedExpectation& Times(const Cardinality& a_cardinality) {
406      ExpectationBase::UntypedTimes(a_cardinality);
407      return *this;
408    }
409    TypedExpectation& Times(int n) {
410      return Times(Exactly(n));
411    }
412    TypedExpectation& InSequence(const Sequence& s) {
413      ExpectSpecProperty(last_clause_ <= kInSequence,
414                         ".InSequence() cannot appear after .After(),"
415                         " .WillOnce(), .WillRepeatedly(), or "
416                         ".RetiresOnSaturation().");
417      last_clause_ = kInSequence;
418      s.AddExpectation(GetHandle());
419      return *this;
420    }
421    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2) {
422      return InSequence(s1).InSequence(s2);
423    }
424    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
425                                 const Sequence& s3) {
426      return InSequence(s1, s2).InSequence(s3);
427    }
428    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
429                                 const Sequence& s3, const Sequence& s4) {
430      return InSequence(s1, s2, s3).InSequence(s4);
431    }
432    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
433                                 const Sequence& s3, const Sequence& s4,
434                                 const Sequence& s5) {
435      return InSequence(s1, s2, s3, s4).InSequence(s5);
436    }
437    TypedExpectation& After(const ExpectationSet& s) {
438      ExpectSpecProperty(last_clause_ <= kAfter,
439                         ".After() cannot appear after .WillOnce(),"
440                         " .WillRepeatedly(), or "
441                         ".RetiresOnSaturation().");
442      last_clause_ = kAfter;
443      for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {
444        immediate_prerequisites_ += *it;
445      }
446      return *this;
447    }
448    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2) {
449      return After(s1).After(s2);
450    }
451    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
452                            const ExpectationSet& s3) {
453      return After(s1, s2).After(s3);
454    }
455    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
456                            const ExpectationSet& s3, const ExpectationSet& s4) {
457      return After(s1, s2, s3).After(s4);
458    }
459    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
460                            const ExpectationSet& s3, const ExpectationSet& s4,
461                            const ExpectationSet& s5) {
462      return After(s1, s2, s3, s4).After(s5);
463    }
464    TypedExpectation& WillOnce(const Action<F>& action) {
465      ExpectSpecProperty(last_clause_ <= kWillOnce,
466                         ".WillOnce() cannot appear after "
467                         ".WillRepeatedly() or .RetiresOnSaturation().");
468      last_clause_ = kWillOnce;
469      untyped_actions_.push_back(new Action<F>(action));
470      if (!cardinality_specified()) {
471        set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())));
472      }
473      return *this;
474    }
475    TypedExpectation& WillRepeatedly(const Action<F>& action) {
476      if (last_clause_ == kWillRepeatedly) {
477        ExpectSpecProperty(false,
478                           ".WillRepeatedly() cannot appear "
479                           "more than once in an EXPECT_CALL().");
480      } else {
481        ExpectSpecProperty(last_clause_ < kWillRepeatedly,
482                           ".WillRepeatedly() cannot appear "
483                           "after .RetiresOnSaturation().");
484      }
485      last_clause_ = kWillRepeatedly;
486      repeated_action_specified_ = true;
487      repeated_action_ = action;
488      if (!cardinality_specified()) {
489        set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())));
490      }
491      CheckActionCountIfNotDone();
492      return *this;
493    }
494    TypedExpectation& RetiresOnSaturation() {
495      ExpectSpecProperty(last_clause_ < kRetiresOnSaturation,
496                         ".RetiresOnSaturation() cannot appear "
497                         "more than once.");
498      last_clause_ = kRetiresOnSaturation;
499      retires_on_saturation_ = true;
500      CheckActionCountIfNotDone();
501      return *this;
502    }
503    const ArgumentMatcherTuple& matchers() const {
504      return matchers_;
505    }
506    const Matcher<const ArgumentTuple&>& extra_matcher() const {
507      return extra_matcher_;
508    }
509    const Action<F>& repeated_action() const { return repeated_action_; }
510    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {
511      if (extra_matcher_specified_) {
512        *os << "    Expected args: ";
513        extra_matcher_.DescribeTo(os);
514        *os << "\n";
515      }
516    }
517   private:
518    template <typename Function>
519    friend class FunctionMockerBase;
520    virtual Expectation GetHandle() {
521      return owner_->GetHandleOf(this);
522    }
523    bool Matches(const ArgumentTuple& args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
527    }
<span onclick='openModal()' class='match'>528    bool ShouldHandleArguments(const ArgumentTuple& args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
</span>532      return !is_retired() && AllPrerequisitesAreSatisfied() && Matches(args);
533    }
534    void ExplainMatchResultTo(
535        const ArgumentTuple& args,
536        ::std::ostream* os) const
537            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
538      g_gmock_mutex.AssertHeld();
539      if (is_retired()) {
540        *os << "         Expected: the expectation is active\n"
541            << "           Actual: it is retired\n";
542      } else if (!Matches(args)) {
543        if (!TupleMatches(matchers_, args)) {
544          ExplainMatchFailureTupleTo(matchers_, args, os);
545        }
546        StringMatchResultListener listener;
547        if (!extra_matcher_.MatchAndExplain(args, &listener)) {
548          *os << "    Expected args: ";
549          extra_matcher_.DescribeTo(os);
550          *os << "\n           Actual: don't match";
551          internal::PrintIfNotEmpty(listener.str(), os);
552          *os << "\n";
553        }
554      } else if (!AllPrerequisitesAreSatisfied()) {
555        *os << "         Expected: all pre-requisites are satisfied\n"
556            << "           Actual: the following immediate pre-requisites "
557            << "are not satisfied:\n";
558        ExpectationSet unsatisfied_prereqs;
559        FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);
560        int i = 0;
561        for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();
562             it != unsatisfied_prereqs.end(); ++it) {
563          it->expectation_base()->DescribeLocationTo(os);
564          *os << "pre-requisite #" << i++ << "\n";
565        }
566        *os << "                   (end of pre-requisites)\n";
567      } else {
568        *os << "The call matches the expectation.\n";
569      }
570    }
571    const Action<F>& GetCurrentAction(
572        const FunctionMockerBase<F>* mocker,
573        const ArgumentTuple& args) const
574            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
575      g_gmock_mutex.AssertHeld();
576      const int count = call_count();
577      Assert(count >= 1, __FILE__, __LINE__,
578             "call_count() is <= 0 when GetCurrentAction() is "
579             "called - this should never happen.");
580      const int action_count = static_cast<int>(untyped_actions_.size());
581      if (action_count > 0 && !repeated_action_specified_ &&
582          count > action_count) {
583        ::std::stringstream ss;
584        DescribeLocationTo(&ss);
585        ss << "Actions ran out in " << source_text() << "...\n"
586           << "Called " << count << " times, but only "
587           << action_count << " WillOnce()"
588           << (action_count == 1 ? " is" : "s are") << " specified - ";
589        mocker->DescribeDefaultActionTo(args, &ss);
590        Log(kWarning, ss.str(), 1);
591      }
592      return count <= action_count ?
593          *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :
594          repeated_action();
595    }
596    const Action<F>* GetActionForArguments(
597        const FunctionMockerBase<F>* mocker,
598        const ArgumentTuple& args,
599        ::std::ostream* what,
600        ::std::ostream* why)
601            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
602      g_gmock_mutex.AssertHeld();
603      if (IsSaturated()) {
604        IncrementCallCount();
605        *what << "Mock function called more times than expected - ";
606        mocker->DescribeDefaultActionTo(args, what);
607        DescribeCallCountTo(why);
608        return NULL;
609      }
610      IncrementCallCount();
611      RetireAllPreRequisites();
612      if (retires_on_saturation_ && IsSaturated()) {
613        Retire();
614      }
615      *what << "Mock function call matches " << source_text() <<"...\n";
616      return &(GetCurrentAction(mocker, args));
617    }
618    FunctionMockerBase<F>* const owner_;
619    ArgumentMatcherTuple matchers_;
620    Matcher<const ArgumentTuple&> extra_matcher_;
621    Action<F> repeated_action_;
622    GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);
623  };  
624  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
625                                  const char* file, int line,
626                                  const string& message);
627  template <typename F>
628  class MockSpec {
629   public:
630    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
631    typedef typename internal::Function<F>::ArgumentMatcherTuple
632        ArgumentMatcherTuple;
633    explicit MockSpec(internal::FunctionMockerBase<F>* function_mocker)
634        : function_mocker_(function_mocker) {}
635    internal::OnCallSpec<F>& InternalDefaultActionSetAt(
636        const char* file, int line, const char* obj, const char* call) {
637      LogWithLocation(internal::kInfo, file, line,
638          string("ON_CALL(") + obj + ", " + call + ") invoked");
639      return function_mocker_->AddNewOnCallSpec(file, line, matchers_);
640    }
641    internal::TypedExpectation<F>& InternalExpectedAt(
642        const char* file, int line, const char* obj, const char* call) {
643      const string source_text(string("EXPECT_CALL(") + obj + ", " + call + ")");
644      LogWithLocation(internal::kInfo, file, line, source_text + " invoked");
645      return function_mocker_->AddNewExpectation(
646          file, line, source_text, matchers_);
647    }
648   private:
649    template <typename Function>
650    friend class internal::FunctionMocker;
651    void SetMatchers(const ArgumentMatcherTuple& matchers) {
652      matchers_ = matchers;
653    }
654    internal::FunctionMockerBase<F>* const function_mocker_;
655    ArgumentMatcherTuple matchers_;
656    GTEST_DISALLOW_ASSIGN_(MockSpec);
657  };  
658  #ifdef _MSC_VER
659  # pragma warning(push)          
660  # pragma warning(disable:4355)  
661  #endif  
662  class UntypedActionResultHolderBase {
663   public:
664    virtual ~UntypedActionResultHolderBase() {}
665    virtual void PrintAsActionResult(::std::ostream* os) const = 0;
666  };
667  template <typename T>
668  class ActionResultHolder : public UntypedActionResultHolderBase {
669   public:
670    explicit ActionResultHolder(T a_value) : value_(a_value) {}
671    T GetValueAndDelete() const {
672      T retval(value_);
673      delete this;
674      return retval;
675    }
676    virtual void PrintAsActionResult(::std::ostream* os) const {
677      *os << "\n          Returns: ";
678      UniversalPrinter<T>::Print(value_, os);
679    }
680    template <typename F>
681    static ActionResultHolder* PerformDefaultAction(
682        const FunctionMockerBase<F>* func_mocker,
683        const typename Function<F>::ArgumentTuple& args,
684        const string& call_description) {
685      return new ActionResultHolder(
686          func_mocker->PerformDefaultAction(args, call_description));
687    }
688    template <typename F>
689    static ActionResultHolder*
690    PerformAction(const Action<F>& action,
691                  const typename Function<F>::ArgumentTuple& args) {
692      return new ActionResultHolder(action.Perform(args));
693    }
694   private:
695    T value_;
696    GTEST_DISALLOW_ASSIGN_(ActionResultHolder);
697  };
698  template <>
699  class ActionResultHolder<void> : public UntypedActionResultHolderBase {
700   public:
701    void GetValueAndDelete() const { delete this; }
702    virtual void PrintAsActionResult(::std::ostream* &bsol;* os */) const {}
703    template <typename F>
704    static ActionResultHolder* PerformDefaultAction(
705        const FunctionMockerBase<F>* func_mocker,
706        const typename Function<F>::ArgumentTuple& args,
707        const string& call_description) {
708      func_mocker->PerformDefaultAction(args, call_description);
709      return NULL;
710    }
711    template <typename F>
712    static ActionResultHolder* PerformAction(
713        const Action<F>& action,
714        const typename Function<F>::ArgumentTuple& args) {
715      action.Perform(args);
716      return NULL;
717    }
718  };
719  template <typename F>
720  class FunctionMockerBase : public UntypedFunctionMockerBase {
721   public:
722    typedef typename Function<F>::Result Result;
723    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
724    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
725    FunctionMockerBase() : current_spec_(this) {}
726    virtual ~FunctionMockerBase()
727          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
728      MutexLock l(&g_gmock_mutex);
729      VerifyAndClearExpectationsLocked();
730      Mock::UnregisterLocked(this);
731      ClearDefaultActionsLocked();
732    }
733    const OnCallSpec<F>* FindOnCallSpec(
734        const ArgumentTuple& args) const {
735      for (UntypedOnCallSpecs::const_reverse_iterator it
736               = untyped_on_call_specs_.rbegin();
737           it != untyped_on_call_specs_.rend(); ++it) {
738        const OnCallSpec<F>* spec = static_cast<const OnCallSpec<F>*>(*it);
739        if (spec->Matches(args))
740          return spec;
741      }
742      return NULL;
743    }
744    Result PerformDefaultAction(const ArgumentTuple& args,
745                                const string& call_description) const {
746      const OnCallSpec<F>* const spec =
747          this->FindOnCallSpec(args);
748      if (spec != NULL) {
749        return spec->GetAction().Perform(args);
750      }
751      const string message = call_description +
752          "\n    The mock function has no default action "
753          "set, and its return type has no default value set.";
754  #if GTEST_HAS_EXCEPTIONS
755      if (!DefaultValue<Result>::Exists()) {
756        throw std::runtime_error(message);
757      }
758  #else
759      Assert(DefaultValue<Result>::Exists(), "", -1, message);
760  #endif
761      return DefaultValue<Result>::Get();
762    }
763    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
764        const void* untyped_args,  
765        const string& call_description) const {
766      const ArgumentTuple& args =
767          *static_cast<const ArgumentTuple*>(untyped_args);
768      return ResultHolder::PerformDefaultAction(this, args, call_description);
769    }
770    virtual UntypedActionResultHolderBase* UntypedPerformAction(
771        const void* untyped_action, const void* untyped_args) const {
772      const Action<F> action = *static_cast<const Action<F>*>(untyped_action);
773      const ArgumentTuple& args =
774          *static_cast<const ArgumentTuple*>(untyped_args);
775      return ResultHolder::PerformAction(action, args);
776    }
777    virtual void ClearDefaultActionsLocked()
778        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
779      g_gmock_mutex.AssertHeld();
780      UntypedOnCallSpecs specs_to_delete;
781      untyped_on_call_specs_.swap(specs_to_delete);
782      g_gmock_mutex.Unlock();
783      for (UntypedOnCallSpecs::const_iterator it =
784               specs_to_delete.begin();
785           it != specs_to_delete.end(); ++it) {
786        delete static_cast<const OnCallSpec<F>*>(*it);
787      }
788      g_gmock_mutex.Lock();
789    }
790   protected:
791    template <typename Function>
792    friend class MockSpec;
793    typedef ActionResultHolder<Result> ResultHolder;
794    Result InvokeWith(const ArgumentTuple& args)
795          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
796      return static_cast<const ResultHolder*>(
797          this->UntypedInvokeWith(&args))->GetValueAndDelete();
798    }
799    OnCallSpec<F>& AddNewOnCallSpec(
800        const char* file, int line,
801        const ArgumentMatcherTuple& m)
802            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
803      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
804      OnCallSpec<F>* const on_call_spec = new OnCallSpec<F>(file, line, m);
805      untyped_on_call_specs_.push_back(on_call_spec);
806      return *on_call_spec;
807    }
808    TypedExpectation<F>& AddNewExpectation(
809        const char* file,
810        int line,
811        const string& source_text,
812        const ArgumentMatcherTuple& m)
813            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
814      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
815      TypedExpectation<F>* const expectation =
816          new TypedExpectation<F>(this, file, line, source_text, m);
817      const linked_ptr<ExpectationBase> untyped_expectation(expectation);
818      untyped_expectations_.push_back(untyped_expectation);
819      Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();
820      if (implicit_sequence != NULL) {
821        implicit_sequence->AddExpectation(Expectation(untyped_expectation));
822      }
823      return *expectation;
824    }
825    MockSpec<F>& current_spec() { return current_spec_; }
826   private:
827    template <typename Func> friend class TypedExpectation;
828    void DescribeDefaultActionTo(const ArgumentTuple& args,
829                                 ::std::ostream* os) const {
830      const OnCallSpec<F>* const spec = FindOnCallSpec(args);
831      if (spec == NULL) {
832        *os << (internal::type_equals<Result, void>::value ?
833                "returning directly.\n" :
834                "returning default value.\n");
835      } else {
836        *os << "taking default action specified at:\n"
837            << FormatFileLocation(spec->file(), spec->line()) << "\n";
838      }
839    }
840    virtual void UntypedDescribeUninterestingCall(
841        const void* untyped_args,
842        ::std::ostream* os) const
843            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
844      const ArgumentTuple& args =
845          *static_cast<const ArgumentTuple*>(untyped_args);
846      *os << "Uninteresting mock function call - ";
847      DescribeDefaultActionTo(args, os);
848      *os << "    Function call: " << Name();
849      UniversalPrint(args, os);
850    }
851    virtual const ExpectationBase* UntypedFindMatchingExpectation(
852        const void* untyped_args,
853        const void** untyped_action, bool* is_excessive,
854        ::std::ostream* what, ::std::ostream* why)
855            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
856      const ArgumentTuple& args =
857          *static_cast<const ArgumentTuple*>(untyped_args);
858      MutexLock l(&g_gmock_mutex);
859      TypedExpectation<F>* exp = this->FindMatchingExpectationLocked(args);
860      if (exp == NULL) {  
861        this->FormatUnexpectedCallMessageLocked(args, what, why);
862        return NULL;
863      }
864      *is_excessive = exp->IsSaturated();
865      const Action<F>* action = exp->GetActionForArguments(this, args, what, why);
866      if (action != NULL && action->IsDoDefault())
867        action = NULL;  
868      *untyped_action = action;
869      return exp;
870    }
871    virtual void UntypedPrintArgs(const void* untyped_args,
872                                  ::std::ostream* os) const {
873      const ArgumentTuple& args =
874          *static_cast<const ArgumentTuple*>(untyped_args);
875      UniversalPrint(args, os);
876    }
877    TypedExpectation<F>* FindMatchingExpectationLocked(
878        const ArgumentTuple& args) const
879            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
880      g_gmock_mutex.AssertHeld();
881      for (typename UntypedExpectations::const_reverse_iterator it =
882               untyped_expectations_.rbegin();
883           it != untyped_expectations_.rend(); ++it) {
884        TypedExpectation<F>* const exp =
885            static_cast<TypedExpectation<F>*>(it->get());
886        if (exp->ShouldHandleArguments(args)) {
887          return exp;
888        }
889      }
890      return NULL;
891    }
892    void FormatUnexpectedCallMessageLocked(
893        const ArgumentTuple& args,
894        ::std::ostream* os,
895        ::std::ostream* why) const
896            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
897      g_gmock_mutex.AssertHeld();
898      *os << "\nUnexpected mock function call - ";
899      DescribeDefaultActionTo(args, os);
900      PrintTriedExpectationsLocked(args, why);
901    }
902    void PrintTriedExpectationsLocked(
903        const ArgumentTuple& args,
904        ::std::ostream* why) const
905            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
906      g_gmock_mutex.AssertHeld();
907      const int count = static_cast<int>(untyped_expectations_.size());
908      *why << "Google Mock tried the following " << count << " "
909           << (count == 1 ? "expectation, but it didn't match" :
910               "expectations, but none matched")
911           << ":\n";
912      for (int i = 0; i < count; i++) {
913        TypedExpectation<F>* const expectation =
914            static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());
915        *why << "\n";
916        expectation->DescribeLocationTo(why);
917        if (count > 1) {
918          *why << "tried expectation #" << i << ": ";
919        }
920        *why << expectation->source_text() << "...\n";
921        expectation->ExplainMatchResultTo(args, why);
922        expectation->DescribeCallCountTo(why);
923      }
924    }
925    MockSpec<F> current_spec_;
926    GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);
927  };  
928  #ifdef _MSC_VER
929  # pragma warning(pop)  
930  #endif  
931  void ReportUninterestingCall(CallReaction reaction, const string& msg);
932  }  
933  using internal::MockSpec;
934  template <typename T>
935  inline const T& Const(const T& x) { return x; }
936  inline Expectation::Expectation(internal::ExpectationBase& exp)  
937      : expectation_base_(exp.GetHandle().expectation_base()) {}
938  }  
939  #define GMOCK_ON_CALL_IMPL_(obj, call) \
940      ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \
941                                                      #obj, #call)
942  #define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)
943  #define GMOCK_EXPECT_CALL_IMPL_(obj, call) \
944      ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)
945  #define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)
946  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</div>
                </div>
                <div class="column column_space"><pre><code>523    bool Matches(const ArgumentTuple& args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
</pre></code></div>
                <div class="column column_space"><pre><code>528    bool ShouldHandleArguments(const ArgumentTuple& args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    