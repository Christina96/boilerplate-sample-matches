
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5488312060805964%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.h</h3>
            <pre><code>1  #ifndef vizmap_H
2  #define vizmap_H
3  class TVizMapFrame;
4  ClassHdTP(TVizMapXmlDocBs, PVizMapXmlDocBs);
5  ClassTPV(TVizMapLink, PVizMapLink, TVizMapLinkV) 
6  private:
7      TBool DirP;
8      TInt SrcPointN;
9      TInt DstPointN;
10      TFlt Wgt; 
11      TStr LinkNmStr; 
12      TInt DocId; 
13  public:
14      TVizMapLink(const int& _SrcPointN, const int& _DstPointN,
15          const bool& _DirP): DirP(_DirP), SrcPointN(_SrcPointN),
16          DstPointN(_DstPointN), Wgt(1.0), LinkNmStr(""), DocId(-1) { }
17      static PVizMapLink New(const int& SrcPointN, const int& DstPointN,
18          const bool& DirP) { return new TVizMapLink(SrcPointN, DstPointN, DirP); }
19      TVizMapLink(TSIn& SIn): DirP(SIn), SrcPointN(SIn), DstPointN(SIn),
20          Wgt(SIn), LinkNmStr(SIn), DocId(SIn) { }
21      static PVizMapLink Load(TSIn& SIn) { return new TVizMapLink(SIn); }
22      void Save(TSOut& SOut) const {
23          DirP.Save(SOut); SrcPointN.Save(SOut); DstPointN.Save(SOut);
24          Wgt.Save(SOut); LinkNmStr.Save(SOut); DocId.Save(SOut); }
25      bool IsDir() const { return DirP; }
26      bool IsSrcPointN(const int& PointN) const { return (PointN==SrcPointN); }
27      bool IsDstPointN(const int& PointN) const { return (PointN==DstPointN); }
28      int GetPointN(const int& PointN) const;
29      int GetSrcPointN() const { return SrcPointN; }
30      int GetDstPointN() const { return DstPointN; }
31      double GetWgt() const { return Wgt; }
32      void PutWgt(const double& _Wgt) { Wgt = _Wgt; }
33      bool IsLinkNm() const { return !LinkNmStr.Empty(); }
34      const TStr& GetLinkNm() const { return LinkNmStr; }
35      void PutLinkNm(const TStr& _LinkNmStr) { LinkNmStr = _LinkNmStr; }
36      bool IsDocId() const { return (DocId != -1); }
37      int GetDocId() const { return DocId; }
38      void PutDocId(const int& _DocId) { EAssert(_DocId != -1); DocId = _DocId; }
39  };
40  ClassTPV(TVizMapPoint, PVizMapPoint, TVizMapPointV) 
41  private:
42      TFltV CoordV; 
43      TFlt Wgt; 
44      TStr PointNmStr; 
45      TInt DocId; 
46      TIntV LinkNV; 
47      TIntV CatIdV; 
48  private:
49      void AddCat(const int& CatId) {
50          if (!CatIdV.IsInBin(CatId)) { CatIdV.AddSorted(CatId); } }
51  public:
52      TVizMapPoint(const TFltV& _CoordV): CoordV(_CoordV),
53          Wgt(1.0), PointNmStr(""), DocId(-1), LinkNV(), CatIdV() { };
54      static PVizMapPoint New(const TFltV& CoordV) {
55          return new TVizMapPoint(CoordV); }
56      TVizMapPoint(TSIn& SIn) {
57          CoordV.Load(SIn); Wgt.Load(SIn); PointNmStr.Load(SIn);
58          DocId.Load(SIn); LinkNV.Load(SIn); CatIdV.Load(SIn); }
59      static PVizMapPoint Load(TSIn& SIn) { return new TVizMapPoint(SIn); }
60      void Save(TSOut& SOut) const {
61          CoordV.Save(SOut); Wgt.Save(SOut); PointNmStr.Save(SOut);
62          DocId.Save(SOut); LinkNV.Save(SOut); CatIdV.Save(SOut); }
63      const TFltV& GetCoordV() const { return CoordV; }
64      int GetPointDim() const { return CoordV.Len(); }
65      double GetPointX() const { Assert(CoordV.Len() >= 1); return CoordV[0]; }
66      double GetPointY() const { Assert(CoordV.Len() >= 2); return CoordV[1]; }
67      double GetWgt() const { return Wgt; }
68      void PutWgt(const double& _Wgt) { Wgt = _Wgt; }
69      bool IsPointNm() const { return !PointNmStr.Empty(); }
70      const TStr& GetPointNm() const { return PointNmStr; }
71      void PutPointNm(const TStr& _PointNmStr) { PointNmStr = _PointNmStr; }
72      bool IsDocId() const { return (DocId != -1); }
73      int GetDocId() const { return DocId; }
74      void PutDocId(const int& _DocId) { EAssert(_DocId != -1); DocId = _DocId; }
75      bool IsLinks() const { return !LinkNV.Empty(); }
76      int GetLinks() const { return LinkNV.Len(); }
77      int GetLinkN(const int& LinkNN) const { return LinkNV[LinkNN]; };
78      void PutLinkN(const int& LinkN) { LinkNV.Add(LinkN); }
79      bool IsCats() const { return !CatIdV.Empty(); }
80      int GetCats() const { return CatIdV.Len(); }
81      int GetCatId(const int& CatIdN) const { return CatIdV[CatIdN]; }
82      bool IsCatId(const int& CatId) const { return CatIdV.IsIn(CatId); }
83      friend class TVizMapFrame;
84  };
85  ClassTPV(TVizMapLandscape, PVizMapLandscape, TVizMapLandscapeV) 
86  private:
87      TSFltVV HeightMatrixVV; 
88      TFltV LevelV;
89      TStr LandscapeNmStr; 
90      TIntVV CatMatrixVV; 
91      TIntFltPrH CatIdToCenterH; 
92      TFltVV CalcMatrixVV; 
93      TFltVV CalcStampVV; 
94  public:
95      TVizMapLandscape() { };
96      static PVizMapLandscape New() { return new TVizMapLandscape; }
97      TVizMapLandscape(const TVizMapLandscapeV& CatLandscapeV,
98          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH,
99          const double& MxCover, const double& MnCover, const int& MnCats);
100      static PVizMapLandscape New(const TVizMapLandscapeV& CatLandscapeV,
101          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH, const double& MxCover,
102          const double& MnCover, const int& MnCats) { return new TVizMapLandscape(
103              CatLandscapeV, FullLandscape, CatIdH, MxCover, MnCover, MnCats); }
104      TVizMapLandscape(TSIn& SIn) { HeightMatrixVV.Load(SIn);  LevelV.Load(SIn);
105          LandscapeNmStr.Load(SIn); CatMatrixVV.Load(SIn); CatIdToCenterH.Load(SIn); }
106      static PVizMapLandscape Load(TSIn& SIn) { return new TVizMapLandscape(SIn); }
107      void Save(TSOut& SOut) const { HeightMatrixVV.Save(SOut); LevelV.Save(SOut);
108          LandscapeNmStr.Save(SOut); CatMatrixVV.Save(SOut); CatIdToCenterH.Save(SOut); }
109      int GetXDim() const { return HeightMatrixVV.GetXDim(); }
110      int GetYDim() const { return HeightMatrixVV.GetYDim(); }
111      double GetHeight(const int& XPos, const int& YPos) const {
112          return HeightMatrixVV(XPos, YPos); }
113      const TSFltVV& HeightVV() const { return HeightMatrixVV; }
114      int GetLevels() const { return LevelV.Len(); }
115      double GetLevel(const int& LevelN) const { return LevelV[LevelN]; }
<span onclick='openModal()' class='match'>116      const TFltV& GetLevelV() const { return LevelV; }
117      bool IsLandscapeNm() const { return !LandscapeNmStr.Empty(); }
</span>118      const TStr& GetLandscapeNm() const { return LandscapeNmStr; }
119      void PutLandscapeNm(const TStr& _LandscapeNmStr) { LandscapeNmStr = _LandscapeNmStr; }
120      bool IsCatVV() const { return !CatMatrixVV.Empty(); }
121      int GetCat(const int& XPos, const int& YPos) const { return CatMatrixVV(XPos, YPos); }
122      const TIntVV& CatVV() const { return CatMatrixVV; }
123      void PutCatVV(const TIntVV& _CatMatrixVV);
124      int GetCatFromCoord(const double& X, const double& Y);
125      bool IsCat(const int& CatId) const { return CatIdToCenterH.IsKey(CatId); }
126      int GetCats() const { return CatIdToCenterH.Len(); }
127      int GetCatFFirstKeyId() const { return CatIdToCenterH.FFirstKeyId(); }
128      bool GetCatFNextKeyId(int& KeyId) const { return CatIdToCenterH.FNextKeyId(KeyId); }
129      int GetCatId(const int& KeyId) const { return CatIdToCenterH.GetKey(KeyId); }
130      double GetCatX(const int& CatId) const { return CatIdToCenterH.GetDat(CatId).Val1; }
131      double GetCatY(const int& CatId) const { return CatIdToCenterH.GetDat(CatId).Val2; }
132      void CalcStart(const int& XDim, const int& YDim, const double& Sigma);
133      void CalcPutStamp(const double& PointX, const double& PointY, const double& PointWgt);
134      void CalcFinish(const double& MxVal, const int& Levels);
135      friend class TVizMapFrame;
136  };
137  ClassTPV(TVizMapKeyWd, PVizMapKeyWd, TVizMapKeyWdV) 
138  private:
139      TFltV CoordV; 
140      TStr KeyWdStr; 
141  public:
142      TVizMapKeyWd() { };
143      TVizMapKeyWd(const TFltV& _CoordV, const TStr& _KeyWdStr):
144          CoordV(_CoordV), KeyWdStr(_KeyWdStr) {}
145      TVizMapKeyWd(TSIn& SIn) { CoordV.Load(SIn); KeyWdStr.Load(SIn); }
146      static PVizMapKeyWd Load(TSIn& SIn) { return new TVizMapKeyWd(SIn); }
147      void Save(TSOut& SOut) const { CoordV.Save(SOut); KeyWdStr.Save(SOut); }
148      static PVizMapKeyWd New(const TFltV& CoordV, const TStr& KeyWdStr) {
149          return new TVizMapKeyWd(CoordV, KeyWdStr); }
150      const TFltV& GetCoordV() const { return CoordV; }
151      double GetKeyWdX() const { Assert(CoordV.Len() >= 1); return CoordV[0]; }
152      double GetKeyWdY() const { Assert(CoordV.Len() >= 2); return CoordV[1]; }
153      TStr GetKeyWdStr() const { return KeyWdStr; }
154  };
155  ClassTPV(TVizMapFrame, PVizMapFrame, TVizMapFrameV) 
156  private:
157      TVizMapPointV PointV; 
158      TVizMapLinkV LinkV; 
159      TStr FrameNmStr; 
160      TInt FrameSortN; 
161      TVizMapLandscapeV LandscapeV; 
162      PVizMapLandscape QueryLandscape; 
163      PBowDocBs PointBowDocBs;
164      PBowDocBs KeyWdBowDocBs;
165      TBowSpVV KeyWdSpVV;
166      PBowDocBs LinkBowDocBs;
167      TBowSpVV LinkSpVV;
168      TVizMapPointV KeyWdPointV;
169      TVizMapKeyWdV KeyWdV; 
170      TStrH CatNmH;
171      TIntH DId2PointNMap; 
172  private:
173      bool IsPointN(const int& PointN) const { return (0 <= PointN) && (PointN < PointV.Len());}
174  public:
175      TVizMapFrame();
176      static PVizMapFrame New() { return new TVizMapFrame(); }
177      TVizMapFrame(TSIn& SIn);
178      static PVizMapFrame Load(TSIn& SIn) { return new TVizMapFrame(SIn); }
179      TVizMapFrame(TSIn& SIn, PBowDocBs _PointBowDocBs,
180          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs);
181      static PVizMapFrame Load(TSIn& SIn, PBowDocBs _PointBowDocBs,
182          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs) {
183              return new TVizMapFrame(SIn, _PointBowDocBs,
184                  _KeyWdBowDocBs, _LinkBowDocBs); }
185      void Save(TSOut& SOut, const bool& SaveBows = true) const;
186      bool operator<(const TVizMapFrame& VizMapFrame) const {
187          return FrameSortN < VizMapFrame.FrameSortN; }
188      int GetPoints() const { return PointV.Len(); }
189      PVizMapPoint GetPoint(const int& PointN) const { return PointV[PointN]; }
190      int AddPoint(PVizMapPoint VizMapPoint) { return PointV.Add(VizMapPoint); }
191      int GetPointN(const TFltV& CoordV, const double& Radius) const;
192      int GetRectPointV(const TFltRect& Rect, TIntV& RectPointV) const;
193      int GetLinks() const { return LinkV.Len(); }
194      PVizMapLink GetLink(const int LinkN) const { return LinkV[LinkN]; }
195      int AddLink(PVizMapLink VizMapLink);
196      bool IsFrameNm() const { return !FrameNmStr.Empty(); }
197      const TStr& GetFrameNm() const { return FrameNmStr; }
198      void PutFrameNm(const TStr& _FrameNmStr) { FrameNmStr = _FrameNmStr; }
199      bool IsFrameSortN() const { return FrameSortN != -1; }
200      int GetFrameSortN() const { return FrameSortN; }
201      void PutFrameSortN(const int& _FrameSortN) {
202          IAssert(FrameSortN != -1); FrameSortN = _FrameSortN; }
203      int GetLandscapes() const { return LandscapeV.Len(); }
204      PVizMapLandscape GetLandscape(const int& LandscapeN) const {
205          return LandscapeV[LandscapeN]; }
206      void AddLandscape(const int& XDim, const int& YDim,
207          const double& Sigma, const bool& PointWgtP);
208      void AddLandscapeFromLndMrk(const int& XDim, const int& YDim,
209          const double& Sigma, const TVec<TFltV>& LndMrkPointV);
210      void AddLandscapeWithCats(const int& XDim, const int& YDim,
211          const double& Sigma, const bool& PointWgtP);
212      void PutPointBow(PBowDocBs _PointBowDocBs) {
213          PointBowDocBs = _PointBowDocBs;}
214      PBowDocBs GetPointBow() { return PointBowDocBs; }
215      void PutKeyWdBow(PBowDocBs _KeyWdBowDocBs, const TBowSpVV& _KeyWdSpVV) {
216          KeyWdBowDocBs = _KeyWdBowDocBs; KeyWdSpVV = _KeyWdSpVV; }
217      PBowDocBs GetKeyWdBow() { return KeyWdBowDocBs; }
218      const TBowSpVV& GetKeyWdSpVV() const { return KeyWdSpVV; }
219      void PutLinkBow(PBowDocBs _LinkBowDocBs, const TBowSpVV& _LinkSpVV) {
220          LinkBowDocBs = _LinkBowDocBs; LinkSpVV = _LinkSpVV; }
221      PBowDocBs GetLinkBow() { return LinkBowDocBs; }
222      const TBowSpVV& GetLinkSpVV() const { return LinkSpVV; }
223      int GetDocId(const int& PointN) const;
224      TStr GetDocNm(const int& PointN) const;
225      TStr GetDocBody(const int& PointN) const;
226      TStr GetDocUrl(const int& PointN) const;
227      int AddKeyWdPoint(PVizMapPoint VizMapPoint) { return KeyWdPointV.Add(VizMapPoint); }
228      int GenKeyWd(const TFltV& CoordV, const double& Radius,
229          const int& MxKeyWd, TStrV& KeyWdStrV, const bool& DistWgtP = false,
230          const bool& PointWgtP = false, const bool& BackKeyWdP = false) const;
231      void GenKeyWds(const int& KeyWds, const double& Radius,
232          const int& Candidantes, const int& RndSeed, const TFltRect& Rect);
233      int GetKeyWds() const { return KeyWdV.Len(); }
234      PVizMapKeyWd GetKeyWd(const int& KeyWdN) const { return KeyWdV[KeyWdN]; }
235      int AddCatNm(const TStr& CatNm) { return CatNmH.AddKey(CatNm); }
236      bool IsCatId(const TStr& CatNm) const { return CatNmH.IsKey(CatNm); }
237      int GetCatId(const TStr& CatNm) const { return CatNmH.GetKeyId(CatNm); }
238      int GetCats() const { return CatNmH.Len(); }
239      TStr GetCatNm(const int& CatId) const { return CatNmH.GetKey(CatId); }
240      void AddCat(const int& PointN, const int& CatId);
241      void CalcDId2PointNMap();
242      bool IsDId2PointNMap() const { return !DId2PointNMap.Empty(); }
243      bool IsInDId(const int& DId) const { return DId2PointNMap.IsKey(DId); }
244      int GetPointN(const int& DId) const { return DId2PointNMap.GetDat(DId); }
245      void SaveVrml(const TStr& VrmlFNm, PVizMapLandscape Landscape,
246        const bool& ShowDocNmP = true, const bool& ShowDocPtP = true,
247        const bool& ShowKeyWdP = true, const double& FontSize = 2.0,
248        const TStr& SkyColor = "0.4 0.4 1.0", const TStr& TerrainColor = "0.1 0.5 0.1",
249        const TStr& KeywordColor = "0.9 0.9 0.2", const TStr& DocNmColor = "1.0 0.4 0");
250      void SaveLegend(const TStr& TxtFNm, const int& LegendGridWidth,
251          const int& LegendGridHeight);
252  };
253  ClassTP(TVizMap, PVizMap)
254  private:
255      TVizMapFrameV VizMapFrameV;
256  public:
257      TVizMap() { };
258      static PVizMap New() { return new TVizMap; }
259      TVizMap(const PVizMapFrame& VizMapFrame) { VizMapFrameV.Add(VizMapFrame); };
260      static PVizMap New(const PVizMapFrame& VizMapFrame) {
261          return new TVizMap(VizMapFrame); }
262      TVizMap(TSIn& SIn);
263      static PVizMap Load(TSIn& SIn) { return new TVizMap(SIn); }
264      void Save(TSOut& SOut) const;
265      void AddVizMapFrame(const PVizMapFrame& VizMapFrame, const bool& SortedP);
266      int GetVizMapFrames() const { return VizMapFrameV.Len(); }
267      PVizMapFrame GetVizMapFrame(const int& VizMapFrameN) const {
268          return VizMapFrameV[VizMapFrameN]; }
269      PVizMapFrame GetFirst() const { return VizMapFrameV[0]; }
270      bool Empty() const { return VizMapFrameV.Empty(); }
271      static PVizMap LoadBin(const TStr& FNm) {
272          TFIn FIn(FNm); return TVizMap::Load(FIn); }
273      void SaveBin(const TStr& FNm) { TFOut FOut(FNm); Save(FOut); }
274      static void SaveXmlStart(TSOut& SOut) { SOut.PutStrLn("<docatlas>"); }
275      static void SaveXmlEnd(TSOut& SOut) { SOut.PutStrLn("</docatlas>"); }
276      static void SaveXmlDoc(TSOut& SOut, const TStr& Nm, const TStr& Body,
277          const TStr& DisplayBody = TStr(), const TStrV& CatNmV = TStrV(),
278          const TStrV& AuthorV = TStrV(), const TStr& FrameNm = TStr(),
279          const int& FrameSortN = -1);
280  };
281  ClassTP(TVizMapLndMrk, PVizMapLndMrk)
282  private:
283      PBowDocBs BowDocBs;
284      PBowDocWgtBs BowDocWgtBs;
285      TBowSpVV LndMrkSpVV;
286      TVec<TFltV> LndMrkPointVV;
287  public:
288      TVizMapLndMrk(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs,
289          const TBowSpVV& _LndMrkSpVV, const TVec<TFltV>& _LndMrkPointVV):
290              BowDocBs(_BowDocBs), BowDocWgtBs(_BowDocWgtBs),
291              LndMrkSpVV(_LndMrkSpVV), LndMrkPointVV(_LndMrkPointVV) { }
292      static PVizMapLndMrk New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
293          const TBowSpVV& LndMrkSpVV, const TVec<TFltV>& LndMrkPointVV) {
294              return new TVizMapLndMrk(BowDocBs, BowDocWgtBs, LndMrkSpVV, LndMrkPointVV); }
295      TVizMapLndMrk(TSIn& SIn) {
296          BowDocBs = TBowDocBs::Load(SIn); BowDocWgtBs = TBowDocWgtBs::Load(SIn);
297          LndMrkSpVV.Load(SIn); LndMrkPointVV.Load(SIn); }
298      static PVizMapLndMrk Load(TSIn& SIn) { return new TVizMapLndMrk(SIn); }
299      void Save(TSOut& SOut) const {
300          BowDocBs->Save(SOut); BowDocWgtBs->Save(SOut);
301          LndMrkSpVV.Save(SOut); LndMrkPointVV.Save(SOut); }
302      PBowDocBs GetBowDocBs() const { return BowDocBs; }
303      PBowDocWgtBs GetBowDocWgtBs() const { return BowDocWgtBs; }
304      const TBowSpVV& GetLndMrkSpVV() const { return LndMrkSpVV; }
305      const TVec<TFltV>& GetLndMrkPointVV() const { return LndMrkPointVV; }
306      int GetLndMrks() const { return LndMrkSpVV.Len(); }
307      int GetLndMrkDId(const int& LndMrkN) const { return BowDocWgtBs->GetDId(LndMrkN); }
308      const TFltV& GetLndMrkPointV(const int& LndMrkN) const { return LndMrkPointVV[LndMrkN]; }
309      PBowSpV GetLndMrkSpV(const int& LndMrkN) const { return LndMrkSpVV[LndMrkN]; }
310      static PVizMapLndMrk LoadBin(const TStr& FNm) {
311          PSIn SIn = TFIn::New(FNm); return TVizMapLndMrk::Load(*SIn); }
312      void SaveBin(const TStr& FNm) { PSOut SOut = TFOut::New(FNm); Save(*SOut); }
313  };
314  ClassTV(TVizMapXmlDoc, TVizMapXmlDocV)
315  public:
316      TStr Nm;
317      TStr Body;
318      TStr DisplayBody;
319      TIntV CatIdV;
320      TIntV AuthorIdV;
321      TStr FrameNm;
322      TInt FrameSortN;
323  public:
324      TVizMapXmlDoc(): FrameNm(), FrameSortN(-1) { }
325      TVizMapXmlDoc(const TStr& _Nm, const TStr& _Body, const TStr& _DisplayBody,
326          const TIntV& _CatIdV, const TIntV& _AuthorIdV, const TStr& _FrameNm,
327          const int& _FrameSortN): Nm(_Nm), Body(_Body), DisplayBody(_DisplayBody),
328              CatIdV(_CatIdV), AuthorIdV(_AuthorIdV), FrameNm(_FrameNm),
329              FrameSortN(_FrameSortN) { }
330      int AddToBowDocBs(PVizMapXmlDocBs VizMapXmlDocBs, PBowDocBs BowDocBs) const;
331  };
332  typedef enum { vmxdgNone, vmxdgDay, vmxdgMonth, vmxdgYear } TVizMapXmlDocGrouping;
333  ClassTP(TVizMapXmlDocBs, PVizMapXmlDocBs)
334  public:
335      TVizMapXmlDocV XmlDocV;
336      TStrH CatNmH;
337      TStrH AuthorNmH;
338      TStrH FrameNmToSortN;
339      TIntIntVH FrameSortNToDocId;
340  public:
341      TVizMapXmlDocBs(const TStr& XmlFNm,
342          const PNotify& Notify = TStdNotify::New());
343      static PVizMapXmlDocBs New(const TStr& XmlFNm,
344          const PNotify& Notify = TStdNotify::New()) {
345              return new TVizMapXmlDocBs(XmlFNm, Notify); }
346      TVizMapXmlDocBs(const PWdGixRSet& RSet,
347          const TVizMapXmlDocGrouping& Grouping,
348          const PNotify& Notify = TStdNotify::New());
349      static PVizMapXmlDocBs New(const PWdGixRSet& RSet,
350          const TVizMapXmlDocGrouping& Grouping,
351          const PNotify& Notify = TStdNotify::New()) {
352              return new TVizMapXmlDocBs(RSet, Grouping, Notify); }
353      static PBowDocBs LoadBowDocBs(const TStr& XmlFNm, PSwSet SwSet,
354          PStemmer Stemmer, const int& MxNGramLen = 3, const int& MnNGramFq = 5);
355  };
356  typedef enum {vxmtStaticDoc, vxmtDynamicDoc,
357      vxmtStaticAuthor, vxmtDynamicAuthor } TVizXmlMapType;
358  typedef enum {vdtEucl, vdtCos, vdtSqrtCos} TVizDistType;
359  class TVizMapFactory {
360  private:
361      static void CG(const TMatrix& Matrix, const TFltV& b, TFltV& x,
362          PNotify Notify, const int& MaxStep = 200, const double& EpsTer = 1e-7);
363  private:
364      static void MakeFlat(PSVMTrainSet Set, const TVizDistType& DistType,
365          TVec<TFltV>& DocPointV, const int& MxStep, const int& MxSecs,
366          const double& MnDiff, const bool& RndStartPos, PNotify Notify);
367      static void NormalizePoints(TVec<TFltV>& PointV);
368      static void LsiMds(TVec<PBowSpV> DocSpV, PSemSpace SemSpace, TVec<TFltV>& DocPointV,
369          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
370          const double& MnDiff, PNotify Notify);
371      static PVizMapFrame DocLsiMds(PBowDocWgtBs BowDocWgtBs, PSemSpace SemSpace,
372          const TVec<TFltV>& _DocPointV, const double& SemSpaceThresh,
373          const int& MxStep, const int& MxSecs, const double& MnDiff, PNotify Notify);
374      static void AddDocMetadata(PVizMapFrame VizMapFrame, PBowDocBs PointBowDocBs,
375          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs,
376          PVizMapLndMrk VizMapLndMrk = NULL);
377      static void LndMrk(PBowDocWgtBs BowDocWgtBs, PBowSim BowSim,
378          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
379          TVec<TFltV>& DocPointV, const int& LinCombNum, PNotify Notify);
380      static PVizMapFrame DocLndMrk(PBowDocWgtBs BowDocWgtBs,
381          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
382          const int& LinCombNum = 3, PNotify Notify = TNullNotify::New());
383      static PVizMapFrame ClustLsiMdsDocLndMrk(PBowDocWgtBs BowDocWgtBs,
384          PBowDocPart BowDocPart, PSemSpace SemSpace, const int& LinCombNum,
385          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
386          const double& MnDiff, PNotify Notify);
387      static PVizMapFrame NewVizMapFrame(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
388          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
389          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
390          const bool& LndPointWgt, const bool& CalcLandscapeP);
391      static PVizMapFrame NewVizMapFrame(PBowDocBs BowDocBs, const int& ThDocs,
392          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
393          const bool& LndPointWgt, const bool& CalcLandscapeP);
394      static PVizMapFrame NewVizMapFrameFromLndMrk(PBowDocBs BowDocBs,
395          PBowDocWgtBs BowDocWgtBs, PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP,
396          const bool& LndMrkKeyWdP, const PNotify& Notify);
397  public:
398      static PVizMap NewVizMap(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
399          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs = 300,
400          const int& Clusts = 200, const double& SvdThreshold = 0.8,
401          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgtP = false,
402          const bool& CalcLandscapeP = true);
403      static PVizMap NewVizMap(PBowDocBs BowDocBs, const int& ThDocs = 300,
404          const int& Clusts = 200, const double& SvdThreshold = 0.8,
405          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgtP = false,
406          const bool& CalcLandscapeP = true);
407      static PVizMap NewVizMapStaticDoc(
408          const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
409          PStemmer Stemmer = TStemmer::New(stmtPorter, true),
410          const int& ThDocs = 300, const int& Clusts = 200, const double& SvdThreshold = 0.8,
411          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
412          const bool& CalcLandscapeP = true);
413      static PVizMap NewVizMapDynamicDoc(const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
414          PStemmer Stemmer = TStemmer::New(stmtPorter, true),
415          const int& ThDocs = 300, const int& Clusts = 200, const double& SvdThreshold = 0.8,
416          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
417          const bool& CalcLandscapeP = true);
418      static PVizMap NewVizMapStaticAuthor(const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
419          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& MxAuthors = 100,
420          const int& ThDocs = 300, const int& Clusts = 200, const double& SvdThreshold = 0.8,
421          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
422          const bool& CalcLandscapeP = true);
423      static PVizMap NewVizMapDynamicAuthor(const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
424          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& MxFrames = 5,
425          const int& MxAuthors = 10, const int& ThDocs = 300, const int& Clusts = 200,
426          const double& SvdThreshold = 0.8, const PNotify& Notify = TStdNotify::New(),
427          const bool& LndPointWgt = false, const bool& CalcLandscapeP = true);
428      static PVizMap NewVizMap(const PVizMapXmlDocBs& XmlDocBs,
429          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet = TSwSet::New(swstEn523),
430          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& ThDocs = 300,
431          const int& Clusts = 200, const double& SvdThreshold = 0.8,
432          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
433          const bool& CalcLandscapeP = true);
434      static PVizMap NewVizMap(const TStr& XmlFNm,
435          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet = TSwSet::New(swstEn523),
436          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& ThDocs = 300,
437          const int& Clusts = 200, const double& SvdThreshold = 0.8,
438          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
439          const bool& CalcLandscapeP = true);
440      static PVizMapLndMrk NewVizMapLndMrk(PBowDocBs BowDocBs,
441          PBowDocWgtBs BowDocWgtBs, const int& ThDocs = 600, const int& Clusts = 400,
442          const double& SvdThreshold = 0.8, const PNotify& Notify = TStdNotify::New());
443      static PVizMapLndMrk NewVizMapLndMrk(PBowDocBs BowDocBs,
444          const TIntV& DIdV = TIntV(), const int& ThDocs = 600, const int& Clusts = 400,
445          const double& SvdThreshold = 0.8, const PNotify& Notify = TStdNotify::New());
446      static PVizMap NewVizMapFromLndMrk(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
447          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP = false,
448          const bool& LndMrkKeyWdP = false, const PNotify& Notify = TStdNotify::New());
449      static PVizMap NewVizMapFromLndMrk(PBowDocBs BowDocBs, const TIntV& DIdV,
450          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP = false,
451          const bool& LndMrkKeyWdP = false,
452          const TBowWordWgtType& WgtType = bwwtLogDFNrmTFIDF,
453          const PNotify& Notify = TStdNotify::New());
454  };
455  class TVrml {
456  public:
457      static void InsertHeader(PSOut SOut, const TStr& SkyColor);
458      static double InsertEvelationGrid(PSOut SOut, const TSFltVV& Rlf,
459          TFltVV& NewRlf, const TStr& TerrainColor, const int& N = 5,
460          const double& Height = 20.0, const double& Spacing = 0.7);
461      static void InsertBillboard(PSOut SOut, const TFltVV& Rlf,
462          const TStr& Text, const TStr& Color, const TStr& Size,
463          const double& x, const double& y, const double& Height,
464          const double& Scale, bool DoText = true, bool DoPoint = false);
465  };
466  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl.hpp</h3>
            <pre><code>1  #ifndef CL_HPP_
2  #define CL_HPP_
3  #ifdef _WIN32
4  #include <malloc.h>
5  #if defined(USE_DX_INTEROP)
6  #include <CL/cl_d3d10.h>
7  #include <CL/cl_dx9_media_sharing.h>
8  #endif
9  #endif 
10  #if defined(_MSC_VER)
11  #include <intrin.h>
12  #endif 
13  #if defined(USE_CL_DEVICE_FISSION)
14  #include <CL/cl_ext.h>
15  #endif
16  #if defined(__APPLE__) || defined(__MACOSX)
17  #include <OpenCL/opencl.h>
18  #else
19  #include <CL/opencl.h>
20  #endif 
21  #if (_MSC_VER >= 1700) || (__cplusplus >= 201103L)
22  #define CL_HPP_RVALUE_REFERENCES_SUPPORTED
23  #define CL_HPP_CPP11_ATOMICS_SUPPORTED
24  #include <atomic>
25  #endif
26  #if (__cplusplus >= 201103L)
27  #define CL_HPP_NOEXCEPT noexcept
28  #else
29  #define CL_HPP_NOEXCEPT
30  #endif
31  #if defined(CL_VERSION_1_2) && !defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
32  #define __CL_EXPLICIT_CONSTRUCTORS explicit
33  #else 
34  #define __CL_EXPLICIT_CONSTRUCTORS 
35  #endif 
36  #if !defined(CL_EXT_PREFIX__VERSION_1_1_DEPRECATED)
37  #define CL_EXT_PREFIX__VERSION_1_1_DEPRECATED  
38  #endif 
39  #if !defined(CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED)
40  #define CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
41  #endif 
42  #if !defined(CL_CALLBACK)
43  #define CL_CALLBACK
44  #endif 
45  #include <utility>
46  #include <limits>
47  #include <iterator>
48  #if defined(__CL_ENABLE_EXCEPTIONS)
49  #include <exception>
50  #endif 
51  #if !defined(__NO_STD_VECTOR)
52  #include <vector>
53  #endif
54  #if !defined(__NO_STD_STRING)
55  #include <string>
56  #endif 
57  #if defined(__ANDROID__) || defined(linux) || defined(__APPLE__) || defined(__MACOSX)
58  #include <alloca.h>
59  #endif 
60  #include <cstring>
61  namespace cl {
62  class Memory;
63  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) && !defined(CL_VERSION_1_2)) 
64  #define __INIT_CL_EXT_FCN_PTR(name) \
65      if(!pfn_##name) { \
66          pfn_##name = (PFN_##name) \
67              clGetExtensionFunctionAddress(#name); \
68          if(!pfn_##name) { \
69          } \
70      }
71  #endif 
72  #if defined(CL_VERSION_1_2)
73  #define __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, name) \
74      if(!pfn_##name) { \
75          pfn_##name = (PFN_##name) \
76              clGetExtensionFunctionAddressForPlatform(platform, #name); \
77          if(!pfn_##name) { \
78          } \
79      }
80  #endif 
81  class Program;
82  class Device;
83  class Context;
84  class CommandQueue;
85  class Memory;
86  class Buffer;
87  #if defined(__CL_ENABLE_EXCEPTIONS)
88  class Error : public std::exception
89  {
90  private:
91      cl_int err_;
92      const char * errStr_;
93  public:
94      Error(cl_int err, const char * errStr = NULL) : err_(err), errStr_(errStr)
95      {}
96      ~Error() throw() {}
97      virtual const char * what() const throw ()
98      {
99          if (errStr_ == NULL) {
100              return "empty";
101          }
102          else {
103              return errStr_;
104          }
105      }
106      cl_int err(void) const { return err_; }
107  };
108  #define __ERR_STR(x) #x
109  #else
110  #define __ERR_STR(x) NULL
111  #endif 
112  namespace detail
113  {
114  #if defined(__CL_ENABLE_EXCEPTIONS)
115  static inline cl_int errHandler (
116      cl_int err,
117      const char * errStr = NULL)
118  {
119      if (err != CL_SUCCESS) {
120          throw Error(err, errStr);
121      }
122      return err;
123  }
124  #else
125  static inline cl_int errHandler (cl_int err, const char * errStr = NULL)
126  {
127      (void) errStr; 
128      return err;
129  }
130  #endif 
131  }
132  #if !defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
133  #define __GET_DEVICE_INFO_ERR               __ERR_STR(clGetDeviceInfo)
134  #define __GET_PLATFORM_INFO_ERR             __ERR_STR(clGetPlatformInfo)
135  #define __GET_DEVICE_IDS_ERR                __ERR_STR(clGetDeviceIDs)
136  #define __GET_PLATFORM_IDS_ERR              __ERR_STR(clGetPlatformIDs)
137  #define __GET_CONTEXT_INFO_ERR              __ERR_STR(clGetContextInfo)
138  #define __GET_EVENT_INFO_ERR                __ERR_STR(clGetEventInfo)
139  #define __GET_EVENT_PROFILE_INFO_ERR        __ERR_STR(clGetEventProfileInfo)
140  #define __GET_MEM_OBJECT_INFO_ERR           __ERR_STR(clGetMemObjectInfo)
141  #define __GET_IMAGE_INFO_ERR                __ERR_STR(clGetImageInfo)
142  #define __GET_SAMPLER_INFO_ERR              __ERR_STR(clGetSamplerInfo)
143  #define __GET_KERNEL_INFO_ERR               __ERR_STR(clGetKernelInfo)
144  #if defined(CL_VERSION_1_2)
145  #define __GET_KERNEL_ARG_INFO_ERR               __ERR_STR(clGetKernelArgInfo)
146  #endif 
147  #define __GET_KERNEL_WORK_GROUP_INFO_ERR    __ERR_STR(clGetKernelWorkGroupInfo)
148  #define __GET_PROGRAM_INFO_ERR              __ERR_STR(clGetProgramInfo)
149  #define __GET_PROGRAM_BUILD_INFO_ERR        __ERR_STR(clGetProgramBuildInfo)
150  #define __GET_COMMAND_QUEUE_INFO_ERR        __ERR_STR(clGetCommandQueueInfo)
151  #define __CREATE_CONTEXT_ERR                __ERR_STR(clCreateContext)
152  #define __CREATE_CONTEXT_FROM_TYPE_ERR      __ERR_STR(clCreateContextFromType)
153  #define __GET_SUPPORTED_IMAGE_FORMATS_ERR   __ERR_STR(clGetSupportedImageFormats)
154  #define __CREATE_BUFFER_ERR                 __ERR_STR(clCreateBuffer)
155  #define __COPY_ERR                          __ERR_STR(cl::copy)
156  #define __CREATE_SUBBUFFER_ERR              __ERR_STR(clCreateSubBuffer)
157  #define __CREATE_GL_BUFFER_ERR              __ERR_STR(clCreateFromGLBuffer)
158  #define __CREATE_GL_RENDER_BUFFER_ERR       __ERR_STR(clCreateFromGLBuffer)
159  #define __GET_GL_OBJECT_INFO_ERR            __ERR_STR(clGetGLObjectInfo)
160  #if defined(CL_VERSION_1_2)
161  #define __CREATE_IMAGE_ERR                  __ERR_STR(clCreateImage)
162  #define __CREATE_GL_TEXTURE_ERR             __ERR_STR(clCreateFromGLTexture)
163  #define __IMAGE_DIMENSION_ERR               __ERR_STR(Incorrect image dimensions)
164  #endif 
165  #define __CREATE_SAMPLER_ERR                __ERR_STR(clCreateSampler)
166  #define __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR __ERR_STR(clSetMemObjectDestructorCallback)
167  #define __CREATE_USER_EVENT_ERR             __ERR_STR(clCreateUserEvent)
168  #define __SET_USER_EVENT_STATUS_ERR         __ERR_STR(clSetUserEventStatus)
169  #define __SET_EVENT_CALLBACK_ERR            __ERR_STR(clSetEventCallback)
170  #define __WAIT_FOR_EVENTS_ERR               __ERR_STR(clWaitForEvents)
171  #define __CREATE_KERNEL_ERR                 __ERR_STR(clCreateKernel)
172  #define __SET_KERNEL_ARGS_ERR               __ERR_STR(clSetKernelArg)
173  #define __CREATE_PROGRAM_WITH_SOURCE_ERR    __ERR_STR(clCreateProgramWithSource)
174  #define __CREATE_PROGRAM_WITH_BINARY_ERR    __ERR_STR(clCreateProgramWithBinary)
175  #if defined(CL_VERSION_1_2)
176  #define __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR    __ERR_STR(clCreateProgramWithBuiltInKernels)
177  #endif 
178  #define __BUILD_PROGRAM_ERR                 __ERR_STR(clBuildProgram)
179  #if defined(CL_VERSION_1_2)
180  #define __COMPILE_PROGRAM_ERR                  __ERR_STR(clCompileProgram)
181  #define __LINK_PROGRAM_ERR                  __ERR_STR(clLinkProgram)
182  #endif 
183  #define __CREATE_KERNELS_IN_PROGRAM_ERR     __ERR_STR(clCreateKernelsInProgram)
184  #define __CREATE_COMMAND_QUEUE_ERR          __ERR_STR(clCreateCommandQueue)
185  #define __SET_COMMAND_QUEUE_PROPERTY_ERR    __ERR_STR(clSetCommandQueueProperty)
186  #define __ENQUEUE_READ_BUFFER_ERR           __ERR_STR(clEnqueueReadBuffer)
187  #define __ENQUEUE_READ_BUFFER_RECT_ERR      __ERR_STR(clEnqueueReadBufferRect)
188  #define __ENQUEUE_WRITE_BUFFER_ERR          __ERR_STR(clEnqueueWriteBuffer)
189  #define __ENQUEUE_WRITE_BUFFER_RECT_ERR     __ERR_STR(clEnqueueWriteBufferRect)
190  #define __ENQEUE_COPY_BUFFER_ERR            __ERR_STR(clEnqueueCopyBuffer)
191  #define __ENQEUE_COPY_BUFFER_RECT_ERR       __ERR_STR(clEnqueueCopyBufferRect)
192  #define __ENQUEUE_FILL_BUFFER_ERR           __ERR_STR(clEnqueueFillBuffer)
193  #define __ENQUEUE_READ_IMAGE_ERR            __ERR_STR(clEnqueueReadImage)
194  #define __ENQUEUE_WRITE_IMAGE_ERR           __ERR_STR(clEnqueueWriteImage)
195  #define __ENQUEUE_COPY_IMAGE_ERR            __ERR_STR(clEnqueueCopyImage)
196  #define __ENQUEUE_FILL_IMAGE_ERR           __ERR_STR(clEnqueueFillImage)
197  #define __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR  __ERR_STR(clEnqueueCopyImageToBuffer)
198  #define __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR  __ERR_STR(clEnqueueCopyBufferToImage)
199  #define __ENQUEUE_MAP_BUFFER_ERR            __ERR_STR(clEnqueueMapBuffer)
200  #define __ENQUEUE_MAP_IMAGE_ERR             __ERR_STR(clEnqueueMapImage)
201  #define __ENQUEUE_UNMAP_MEM_OBJECT_ERR      __ERR_STR(clEnqueueUnMapMemObject)
202  #define __ENQUEUE_NDRANGE_KERNEL_ERR        __ERR_STR(clEnqueueNDRangeKernel)
203  #define __ENQUEUE_TASK_ERR                  __ERR_STR(clEnqueueTask)
204  #define __ENQUEUE_NATIVE_KERNEL             __ERR_STR(clEnqueueNativeKernel)
205  #if defined(CL_VERSION_1_2)
206  #define __ENQUEUE_MIGRATE_MEM_OBJECTS_ERR   __ERR_STR(clEnqueueMigrateMemObjects)
207  #endif 
208  #define __ENQUEUE_ACQUIRE_GL_ERR            __ERR_STR(clEnqueueAcquireGLObjects)
209  #define __ENQUEUE_RELEASE_GL_ERR            __ERR_STR(clEnqueueReleaseGLObjects)
210  #define __RETAIN_ERR                        __ERR_STR(Retain Object)
211  #define __RELEASE_ERR                       __ERR_STR(Release Object)
212  #define __FLUSH_ERR                         __ERR_STR(clFlush)
213  #define __FINISH_ERR                        __ERR_STR(clFinish)
214  #define __VECTOR_CAPACITY_ERR               __ERR_STR(Vector capacity error)
215  #if defined(CL_VERSION_1_2)
216  #define __CREATE_SUB_DEVICES                __ERR_STR(clCreateSubDevices)
217  #else
218  #define __CREATE_SUB_DEVICES                __ERR_STR(clCreateSubDevicesEXT)
219  #endif 
220  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) && !defined(CL_VERSION_1_2)) 
221  #define __ENQUEUE_MARKER_ERR                __ERR_STR(clEnqueueMarker)
222  #define __ENQUEUE_WAIT_FOR_EVENTS_ERR       __ERR_STR(clEnqueueWaitForEvents)
223  #define __ENQUEUE_BARRIER_ERR               __ERR_STR(clEnqueueBarrier)
224  #define __UNLOAD_COMPILER_ERR               __ERR_STR(clUnloadCompiler)
225  #define __CREATE_GL_TEXTURE_2D_ERR          __ERR_STR(clCreateFromGLTexture2D)
226  #define __CREATE_GL_TEXTURE_3D_ERR          __ERR_STR(clCreateFromGLTexture3D)
227  #define __CREATE_IMAGE2D_ERR                __ERR_STR(clCreateImage2D)
228  #define __CREATE_IMAGE3D_ERR                __ERR_STR(clCreateImage3D)
229  #endif 
230  #endif 
231  #if defined(CL_VERSION_1_2)
232  #define __ENQUEUE_MARKER_WAIT_LIST_ERR                __ERR_STR(clEnqueueMarkerWithWaitList)
233  #define __ENQUEUE_BARRIER_WAIT_LIST_ERR               __ERR_STR(clEnqueueBarrierWithWaitList)
234  #endif 
235  #if !defined(__USE_DEV_STRING) && !defined(__NO_STD_STRING)
236  typedef std::string STRING_CLASS;
237  #elif !defined(__USE_DEV_STRING) 
238  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED string CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
239  {
240  private:
241      ::size_t size_;
242      char * str_;
243  public:
244      string(void) : size_(0), str_(NULL)
245      {
246      }
247      string(const char * str, ::size_t size) :
248          size_(size),
249          str_(NULL)
250      {
251          if( size > 0 ) {
252              str_ = new char[size_+1];
253              if (str_ != NULL) {
254                  memcpy(str_, str, size_  * sizeof(char));
255                  str_[size_] = '\0';
256              }
257              else {
258                  size_ = 0;
259              }
260          }
261      }
262      string(const char * str) :
263          size_(0),
264          str_(NULL)
265      {
266          if( str ) {
267              size_= ::strlen(str);
268          }
269          if( size_ > 0 ) {
270              str_ = new char[size_ + 1];
271              if (str_ != NULL) {
272                  memcpy(str_, str, (size_ + 1) * sizeof(char));
273              }
274          }
275      }
276      void resize( ::size_t n )
277      {
278          if( size_ == n ) {
279              return;
280          }
281          if (n == 0) {
282              if( str_ ) {
283                  delete [] str_;
284              }
285              str_ = NULL;
286              size_ = 0;
287          } 
288          else {
289              char *newString = new char[n + 1];
290              ::size_t copySize = n;
291              if( size_ < n ) {
292                  copySize = size_;
293              }
294              size_ = n;
295              if(str_) {
296                  memcpy(newString, str_, (copySize + 1) * sizeof(char));
297              }
298              if( copySize < size_ ) {
299                  memset(newString + copySize, 0, size_ - copySize);
300              }
301              newString[size_] = '\0';
302              delete [] str_;
303              str_ = newString;
304          }
305      }
306      const char& operator[] ( ::size_t pos ) const
307      {
308          return str_[pos];
309      }
310      char& operator[] ( ::size_t pos )
311      {
312          return str_[pos];
313      }
314      string& operator=(const string& rhs)
315      {
316          if (this == &rhs) {
317              return *this;
318          }
319          if( str_ != NULL ) {
320              delete [] str_;
321              str_ = NULL;
322              size_ = 0;
323          }
324          if (rhs.size_ == 0 || rhs.str_ == NULL) {
325              str_ = NULL;
326              size_ = 0;
327          } 
328          else {
329              str_ = new char[rhs.size_ + 1];
330              size_ = rhs.size_;
331              if (str_ != NULL) {
332                  memcpy(str_, rhs.str_, (size_ + 1) * sizeof(char));
333              }
334              else {
335                  size_ = 0;
336              }
337          }
338          return *this;
339      }
340      string(const string& rhs) :
341          size_(0),
342          str_(NULL)
343      {
344          *this = rhs;
345      }
346      ~string()
347      {
348          delete[] str_;
349          str_ = NULL;
350      }
351      ::size_t size(void) const   { return size_; }
352      ::size_t length(void) const { return size(); }
353      const char * c_str(void) const { return (str_) ? str_ : "";}
354  };
355  typedef cl::string STRING_CLASS;
356  #endif 
357  #if !defined(__USE_DEV_VECTOR) && !defined(__NO_STD_VECTOR)
358  #define VECTOR_CLASS std::vector
359  #elif !defined(__USE_DEV_VECTOR) 
360  #define VECTOR_CLASS cl::vector 
361  #if !defined(__MAX_DEFAULT_VECTOR_SIZE)
362  #define __MAX_DEFAULT_VECTOR_SIZE 10
363  #endif
364  template <typename T, unsigned int N = __MAX_DEFAULT_VECTOR_SIZE>
365  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED vector
366  {
367  private:
368      T data_[N];
369      unsigned int size_;
370  public:
371      vector() :  
372          size_(static_cast<unsigned int>(0))
373      {}
374      ~vector() 
375      {
376          clear();
377      }
378      unsigned int size(void) const
379      {
380          return size_;
381      }
382      void clear()
383      {
384          while(!empty()) {
385              pop_back();
386          }
387      }
388      void push_back (const T& x)
389      { 
390          if (size() < N) {
391              new (&data_[size_]) T(x);
392              size_++;
393          } else {
394              detail::errHandler(CL_MEM_OBJECT_ALLOCATION_FAILURE, __VECTOR_CAPACITY_ERR);
395          }
396      }
397      void pop_back(void)
398      {
399          if (size_ != 0) {
400              --size_;
401              data_[size_].~T();
402          } else {
403              detail::errHandler(CL_MEM_OBJECT_ALLOCATION_FAILURE, __VECTOR_CAPACITY_ERR);
404          }
405      }
406      vector(const vector<T, N>& vec) : 
407          size_(vec.size_)
408      {
409          if (size_ != 0) {
410              assign(vec.begin(), vec.end());
411          }
412      } 
413      vector(unsigned int size, const T& val = T()) :
414          size_(0)
415      {
416          for (unsigned int i = 0; i < size; i++) {
417              push_back(val);
418          }
419      }
420      vector<T, N>& operator=(const vector<T, N>& rhs)
421      {
422          if (this == &rhs) {
423              return *this;
424          }
425          if (rhs.size_ != 0) {	
426              assign(rhs.begin(), rhs.end());
427          } else {
428              clear();
429          }
430          return *this;
431      }
432      bool operator==(vector<T,N> &vec)
433      {
434          if (size() != vec.size()) {
435              return false;
436          }
437          for( unsigned int i = 0; i < size(); ++i ) {
438              if( operator[](i) != vec[i] ) {
439                  return false;
440              }
441          }
442          return true;
443      }
444      operator T* ()             { return data_; }
<span onclick='openModal()' class='match'>445      operator const T* () const { return data_; }
446      bool empty (void) const
447      {
448          return size_==0;
449      }
</span>450      unsigned int max_size (void) const
451      {
452          return N;
453      }
454      unsigned int capacity () const
455      {
456          return N;
457      }
458      void resize(unsigned int newSize, T fill = T())
459      {
460          if (newSize > N)
461          {
462              detail::errHandler(CL_MEM_OBJECT_ALLOCATION_FAILURE, __VECTOR_CAPACITY_ERR);
463          }
464          else
465          {
466              while (size_ < newSize)
467              {
468                  new (&data_[size_]) T(fill);
469                  size_++;
470              }
471              while (size_ > newSize)
472              {
473                  --size_;
474                  data_[size_].~T();
475              }
476          }
477      }
478      T& operator[](int index)
479      {
480          return data_[index];
481      }
482      const T& operator[](int index) const
483      {
484          return data_[index];
485      }
486      template<class I>
487      void assign(I start, I end)
488      {
489          clear();   
490          while(start != end) {
491              push_back(*start);
492              start++;
493          }
494      }
495      class iterator
496      {
497      private:
498          const vector<T,N> *vec_;
499          int index_;
500          iterator (const vector<T,N> &vec, int index) :
501              vec_(&vec)
502          {            
503              if( !vec.empty() ) {
504                  index_ = index;
505              } else {
506                  index_ = -1;
507              }
508          }
509      public:
510          iterator(void) : 
511              index_(-1),
512              vec_(NULL)
513          {
514          }
515          iterator(const iterator& rhs) :
516              vec_(rhs.vec_),
517              index_(rhs.index_)
518          {
519          }
520          ~iterator(void) {}
521          static iterator begin(const cl::vector<T,N> &vec)
522          {
523              iterator i(vec, 0);
524              return i;
525          }
526          static iterator end(const cl::vector<T,N> &vec)
527          {
528              iterator i(vec, vec.size());
529              return i;
530          }
531          bool operator==(iterator i)
532          {
533              return ((vec_ == i.vec_) && 
534                      (index_ == i.index_));
535          }
536          bool operator!=(iterator i)
537          {
538              return (!(*this==i));
539          }
540          iterator& operator++()
541          {
542              ++index_;
543              return *this;
544          }
545          iterator operator++(int)
546          {
547              iterator retVal(*this);
548              ++index_;
549              return retVal;
550          }
551          iterator& operator--()
552          {
553              --index_;
554              return *this;
555          }
556          iterator operator--(int)
557          {
558              iterator retVal(*this);
559              --index_;
560              return retVal;
561          }
562          const T& operator *() const
563          {
564              return (*vec_)[index_];
565          }
566      };
567      iterator begin(void)
568      {
569          return iterator::begin(*this);
570      }
571      iterator begin(void) const
572      {
573          return iterator::begin(*this);
574      }
575      iterator end(void)
576      {
577          return iterator::end(*this);
578      }
579      iterator end(void) const
580      {
581          return iterator::end(*this);
582      }
583      T& front(void)
584      {
585          return data_[0];
586      }
587      T& back(void)
588      {
589          return data_[size_];
590      }
591      const T& front(void) const
592      {
593          return data_[0];
594      }
595      const T& back(void) const
596      {
597          return data_[size_-1];
598      }
599  } CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
600  #endif 
601  namespace detail {
602  #define __DEFAULT_NOT_INITIALIZED 1 
603  #define __DEFAULT_BEING_INITIALIZED 2
604  #define __DEFAULT_INITIALIZED 4
605  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
606      inline int compare_exchange(std::atomic<int> * dest, int exchange, int comparand)
607  #else 
608      inline int compare_exchange(volatile int * dest, int exchange, int comparand)
609  #endif 
610      {
611  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
612          std::atomic_compare_exchange_strong(dest, &comparand, exchange);
613          return comparand;
614  #elif _MSC_VER
615          return (int)(_InterlockedCompareExchange(
616              (volatile long*)dest,
617              (long)exchange,
618              (long)comparand));
619  #else 
620          return (__sync_val_compare_and_swap(
621              dest,
622              comparand,
623              exchange));
624  #endif 
625      }
626      inline void fence() {
627  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
628          std::atomic_thread_fence(std::memory_order_seq_cst);
629  #elif _MSC_VER 
630          _ReadWriteBarrier();
631  #else 
632          __sync_synchronize();
633  #endif 
634      }
635  } 
636  template <int N>
637  class size_t
638  { 
639  private:
640      ::size_t data_[N];
641  public:
642      size_t()
643      {
644          for( int i = 0; i < N; ++i ) {
645              data_[i] = 0;
646          }
647      }
648      ::size_t& operator[](int index)
649      {
650          return data_[index];
651      }
652      const ::size_t& operator[](int index) const
653      {
654          return data_[index];
655      }
656      operator ::size_t* ()             { return data_; }
657      operator const ::size_t* () const { return data_; }
658  };
659  namespace detail {
660  template<typename Functor, typename T>
661  inline cl_int getInfoHelper(Functor f, cl_uint name, T* param, long)
662  {
663      return f(name, sizeof(T), param, NULL);
664  }
665  template <typename Func, typename T>
666  inline cl_int getInfoHelper(Func f, cl_uint name, VECTOR_CLASS<T>* param, long)
667  {
668      ::size_t required;
669      cl_int err = f(name, 0, NULL, &required);
670      if (err != CL_SUCCESS) {
671          return err;
672      }
673      T* value = (T*) alloca(required);
674      err = f(name, required, value, NULL);
675      if (err != CL_SUCCESS) {
676          return err;
677      }
678      param->assign(&value[0], &value[required/sizeof(T)]);
679      return CL_SUCCESS;
680  }
681  template <typename Func, typename T>
682  inline cl_int getInfoHelper(Func f, cl_uint name, VECTOR_CLASS<T>* param, int, typename T::cl_type = 0)
683  {
684      ::size_t required;
685      cl_int err = f(name, 0, NULL, &required);
686      if (err != CL_SUCCESS) {
687          return err;
688      }
689      typename T::cl_type * value = (typename T::cl_type *) alloca(required);
690      err = f(name, required, value, NULL);
691      if (err != CL_SUCCESS) {
692          return err;
693      }
694      ::size_t elements = required / sizeof(typename T::cl_type);
695      param->assign(&value[0], &value[elements]);
696      for (::size_t i = 0; i < elements; i++)
697      {
698          if (value[i] != NULL)
699          {
700              err = (*param)[i].retain();
701              if (err != CL_SUCCESS) {
702                  return err;
703              }
704          }
705      }
706      return CL_SUCCESS;
707  }
708  template <typename Func>
709  inline cl_int getInfoHelper(Func f, cl_uint name, VECTOR_CLASS<char *>* param, int)
710  {
711      cl_int err = f(name, param->size() * sizeof(char *), &(*param)[0], NULL);
712      if (err != CL_SUCCESS) {
713          return err;
714      }
715      return CL_SUCCESS;
716  }
717  template <typename Func>
718  inline cl_int getInfoHelper(Func f, cl_uint name, STRING_CLASS* param, long)
719  {
720  #if defined(__NO_STD_VECTOR) || defined(__NO_STD_STRING)
721      ::size_t required;
722      cl_int err = f(name, 0, NULL, &required);
723      if (err != CL_SUCCESS) {
724          return err;
725      }
726      char* value = (char*)alloca(required);
727      err = f(name, required, value, NULL);
728      if (err != CL_SUCCESS) {
729          return err;
730      }
731      *param = value;
732      return CL_SUCCESS;
733  #else 
734      ::size_t required;
735      cl_int err = f(name, 0, NULL, &required);
736      if (err != CL_SUCCESS) {
737          return err;
738      }
739      VECTOR_CLASS<char> value(required);
740      err = f(name, required, value.data(), NULL);
741      if (err != CL_SUCCESS) {
742          return err;
743      }
744      if (param) {
745          param->assign(value.begin(), value.end());
746      }
747  #endif
748      return CL_SUCCESS;
749  }
750  template <typename Func, ::size_t N>
751  inline cl_int getInfoHelper(Func f, cl_uint name, size_t<N>* param, long)
752  {
753      ::size_t required;
754      cl_int err = f(name, 0, NULL, &required);
755      if (err != CL_SUCCESS) {
756          return err;
757      }
758      ::size_t* value = (::size_t*) alloca(required);
759      err = f(name, required, value, NULL);
760      if (err != CL_SUCCESS) {
761          return err;
762      }
763      for(int i = 0; i < N; ++i) {
764          (*param)[i] = value[i];
765      }
766      return CL_SUCCESS;
767  }
768  template<typename T> struct ReferenceHandler;
769  template<typename Func, typename T>
770  inline cl_int getInfoHelper(Func f, cl_uint name, T* param, int, typename T::cl_type = 0)
771  {
772      typename T::cl_type value;
773      cl_int err = f(name, sizeof(value), &value, NULL);
774      if (err != CL_SUCCESS) {
775          return err;
776      }
777      *param = value;
778      if (value != NULL)
779      {
780          err = param->retain();
781          if (err != CL_SUCCESS) {
782              return err;
783          }
784      }
785      return CL_SUCCESS;
786  }
787  #define __PARAM_NAME_INFO_1_0(F) \
788      F(cl_platform_info, CL_PLATFORM_PROFILE, STRING_CLASS) \
789      F(cl_platform_info, CL_PLATFORM_VERSION, STRING_CLASS) \
790      F(cl_platform_info, CL_PLATFORM_NAME, STRING_CLASS) \
791      F(cl_platform_info, CL_PLATFORM_VENDOR, STRING_CLASS) \
792      F(cl_platform_info, CL_PLATFORM_EXTENSIONS, STRING_CLASS) \
793      \
794      F(cl_device_info, CL_DEVICE_TYPE, cl_device_type) \
795      F(cl_device_info, CL_DEVICE_VENDOR_ID, cl_uint) \
796      F(cl_device_info, CL_DEVICE_MAX_COMPUTE_UNITS, cl_uint) \
797      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, cl_uint) \
798      F(cl_device_info, CL_DEVICE_MAX_WORK_GROUP_SIZE, ::size_t) \
799      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_SIZES, VECTOR_CLASS< ::size_t>) \
800      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, cl_uint) \
801      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, cl_uint) \
802      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, cl_uint) \
803      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, cl_uint) \
804      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, cl_uint) \
805      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, cl_uint) \
806      F(cl_device_info, CL_DEVICE_MAX_CLOCK_FREQUENCY, cl_uint) \
807      F(cl_device_info, CL_DEVICE_ADDRESS_BITS, cl_uint) \
808      F(cl_device_info, CL_DEVICE_MAX_READ_IMAGE_ARGS, cl_uint) \
809      F(cl_device_info, CL_DEVICE_MAX_WRITE_IMAGE_ARGS, cl_uint) \
810      F(cl_device_info, CL_DEVICE_MAX_MEM_ALLOC_SIZE, cl_ulong) \
811      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_WIDTH, ::size_t) \
812      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_HEIGHT, ::size_t) \
813      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_WIDTH, ::size_t) \
814      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_HEIGHT, ::size_t) \
815      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_DEPTH, ::size_t) \
816      F(cl_device_info, CL_DEVICE_IMAGE_SUPPORT, cl_bool) \
817      F(cl_device_info, CL_DEVICE_MAX_PARAMETER_SIZE, ::size_t) \
818      F(cl_device_info, CL_DEVICE_MAX_SAMPLERS, cl_uint) \
819      F(cl_device_info, CL_DEVICE_MEM_BASE_ADDR_ALIGN, cl_uint) \
820      F(cl_device_info, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, cl_uint) \
821      F(cl_device_info, CL_DEVICE_SINGLE_FP_CONFIG, cl_device_fp_config) \
822      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, cl_device_mem_cache_type) \
823      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, cl_uint)\
824      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, cl_ulong) \
825      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_SIZE, cl_ulong) \
826      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, cl_ulong) \
827      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_ARGS, cl_uint) \
828      F(cl_device_info, CL_DEVICE_LOCAL_MEM_TYPE, cl_device_local_mem_type) \
829      F(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE, cl_ulong) \
830      F(cl_device_info, CL_DEVICE_ERROR_CORRECTION_SUPPORT, cl_bool) \
831      F(cl_device_info, CL_DEVICE_PROFILING_TIMER_RESOLUTION, ::size_t) \
832      F(cl_device_info, CL_DEVICE_ENDIAN_LITTLE, cl_bool) \
833      F(cl_device_info, CL_DEVICE_AVAILABLE, cl_bool) \
834      F(cl_device_info, CL_DEVICE_COMPILER_AVAILABLE, cl_bool) \
835      F(cl_device_info, CL_DEVICE_EXECUTION_CAPABILITIES, cl_device_exec_capabilities) \
836      F(cl_device_info, CL_DEVICE_QUEUE_PROPERTIES, cl_command_queue_properties) \
837      F(cl_device_info, CL_DEVICE_PLATFORM, cl_platform_id) \
838      F(cl_device_info, CL_DEVICE_NAME, STRING_CLASS) \
839      F(cl_device_info, CL_DEVICE_VENDOR, STRING_CLASS) \
840      F(cl_device_info, CL_DRIVER_VERSION, STRING_CLASS) \
841      F(cl_device_info, CL_DEVICE_PROFILE, STRING_CLASS) \
842      F(cl_device_info, CL_DEVICE_VERSION, STRING_CLASS) \
843      F(cl_device_info, CL_DEVICE_EXTENSIONS, STRING_CLASS) \
844      \
845      F(cl_context_info, CL_CONTEXT_REFERENCE_COUNT, cl_uint) \
846      F(cl_context_info, CL_CONTEXT_DEVICES, VECTOR_CLASS<Device>) \
847      F(cl_context_info, CL_CONTEXT_PROPERTIES, VECTOR_CLASS<cl_context_properties>) \
848      \
849      F(cl_event_info, CL_EVENT_COMMAND_QUEUE, cl::CommandQueue) \
850      F(cl_event_info, CL_EVENT_COMMAND_TYPE, cl_command_type) \
851      F(cl_event_info, CL_EVENT_REFERENCE_COUNT, cl_uint) \
852      F(cl_event_info, CL_EVENT_COMMAND_EXECUTION_STATUS, cl_int) \
853      \
854      F(cl_profiling_info, CL_PROFILING_COMMAND_QUEUED, cl_ulong) \
855      F(cl_profiling_info, CL_PROFILING_COMMAND_SUBMIT, cl_ulong) \
856      F(cl_profiling_info, CL_PROFILING_COMMAND_START, cl_ulong) \
857      F(cl_profiling_info, CL_PROFILING_COMMAND_END, cl_ulong) \
858      \
859      F(cl_mem_info, CL_MEM_TYPE, cl_mem_object_type) \
860      F(cl_mem_info, CL_MEM_FLAGS, cl_mem_flags) \
861      F(cl_mem_info, CL_MEM_SIZE, ::size_t) \
862      F(cl_mem_info, CL_MEM_HOST_PTR, void*) \
863      F(cl_mem_info, CL_MEM_MAP_COUNT, cl_uint) \
864      F(cl_mem_info, CL_MEM_REFERENCE_COUNT, cl_uint) \
865      F(cl_mem_info, CL_MEM_CONTEXT, cl::Context) \
866      \
867      F(cl_image_info, CL_IMAGE_FORMAT, cl_image_format) \
868      F(cl_image_info, CL_IMAGE_ELEMENT_SIZE, ::size_t) \
869      F(cl_image_info, CL_IMAGE_ROW_PITCH, ::size_t) \
870      F(cl_image_info, CL_IMAGE_SLICE_PITCH, ::size_t) \
871      F(cl_image_info, CL_IMAGE_WIDTH, ::size_t) \
872      F(cl_image_info, CL_IMAGE_HEIGHT, ::size_t) \
873      F(cl_image_info, CL_IMAGE_DEPTH, ::size_t) \
874      \
875      F(cl_sampler_info, CL_SAMPLER_REFERENCE_COUNT, cl_uint) \
876      F(cl_sampler_info, CL_SAMPLER_CONTEXT, cl::Context) \
877      F(cl_sampler_info, CL_SAMPLER_NORMALIZED_COORDS, cl_bool) \
878      F(cl_sampler_info, CL_SAMPLER_ADDRESSING_MODE, cl_addressing_mode) \
879      F(cl_sampler_info, CL_SAMPLER_FILTER_MODE, cl_filter_mode) \
880      \
881      F(cl_program_info, CL_PROGRAM_REFERENCE_COUNT, cl_uint) \
882      F(cl_program_info, CL_PROGRAM_CONTEXT, cl::Context) \
883      F(cl_program_info, CL_PROGRAM_NUM_DEVICES, cl_uint) \
884      F(cl_program_info, CL_PROGRAM_DEVICES, VECTOR_CLASS<Device>) \
885      F(cl_program_info, CL_PROGRAM_SOURCE, STRING_CLASS) \
886      F(cl_program_info, CL_PROGRAM_BINARY_SIZES, VECTOR_CLASS< ::size_t>) \
887      F(cl_program_info, CL_PROGRAM_BINARIES, VECTOR_CLASS<char *>) \
888      \
889      F(cl_program_build_info, CL_PROGRAM_BUILD_STATUS, cl_build_status) \
890      F(cl_program_build_info, CL_PROGRAM_BUILD_OPTIONS, STRING_CLASS) \
891      F(cl_program_build_info, CL_PROGRAM_BUILD_LOG, STRING_CLASS) \
892      \
893      F(cl_kernel_info, CL_KERNEL_FUNCTION_NAME, STRING_CLASS) \
894      F(cl_kernel_info, CL_KERNEL_NUM_ARGS, cl_uint) \
895      F(cl_kernel_info, CL_KERNEL_REFERENCE_COUNT, cl_uint) \
896      F(cl_kernel_info, CL_KERNEL_CONTEXT, cl::Context) \
897      F(cl_kernel_info, CL_KERNEL_PROGRAM, cl::Program) \
898      \
899      F(cl_kernel_work_group_info, CL_KERNEL_WORK_GROUP_SIZE, ::size_t) \
900      F(cl_kernel_work_group_info, CL_KERNEL_COMPILE_WORK_GROUP_SIZE, cl::size_t<3>) \
901      F(cl_kernel_work_group_info, CL_KERNEL_LOCAL_MEM_SIZE, cl_ulong) \
902      \
903      F(cl_command_queue_info, CL_QUEUE_CONTEXT, cl::Context) \
904      F(cl_command_queue_info, CL_QUEUE_DEVICE, cl::Device) \
905      F(cl_command_queue_info, CL_QUEUE_REFERENCE_COUNT, cl_uint) \
906      F(cl_command_queue_info, CL_QUEUE_PROPERTIES, cl_command_queue_properties)
907  #if defined(CL_VERSION_1_1)
908  #define __PARAM_NAME_INFO_1_1(F) \
909      F(cl_context_info, CL_CONTEXT_NUM_DEVICES, cl_uint)\
910      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, cl_uint) \
911      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, cl_uint) \
912      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, cl_uint) \
913      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, cl_uint) \
914      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, cl_uint) \
915      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, cl_uint) \
916      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, cl_uint) \
917      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, cl_uint) \
918      F(cl_device_info, CL_DEVICE_DOUBLE_FP_CONFIG, cl_device_fp_config) \
919      F(cl_device_info, CL_DEVICE_HALF_FP_CONFIG, cl_device_fp_config) \
920      F(cl_device_info, CL_DEVICE_HOST_UNIFIED_MEMORY, cl_bool) \
921      F(cl_device_info, CL_DEVICE_OPENCL_C_VERSION, STRING_CLASS) \
922      \
923      F(cl_mem_info, CL_MEM_ASSOCIATED_MEMOBJECT, cl::Memory) \
924      F(cl_mem_info, CL_MEM_OFFSET, ::size_t) \
925      \
926      F(cl_kernel_work_group_info, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, ::size_t) \
927      F(cl_kernel_work_group_info, CL_KERNEL_PRIVATE_MEM_SIZE, cl_ulong) \
928      \
929      F(cl_event_info, CL_EVENT_CONTEXT, cl::Context)
930  #endif 
931  #if defined(CL_VERSION_1_2)
932  #define __PARAM_NAME_INFO_1_2(F) \
933      F(cl_image_info, CL_IMAGE_BUFFER, cl::Buffer) \
934      \
935      F(cl_program_info, CL_PROGRAM_NUM_KERNELS, ::size_t) \
936      F(cl_program_info, CL_PROGRAM_KERNEL_NAMES, STRING_CLASS) \
937      \
938      F(cl_program_build_info, CL_PROGRAM_BINARY_TYPE, cl_program_binary_type) \
939      \
940      F(cl_kernel_info, CL_KERNEL_ATTRIBUTES, STRING_CLASS) \
941      \
942      F(cl_kernel_arg_info, CL_KERNEL_ARG_ADDRESS_QUALIFIER, cl_kernel_arg_address_qualifier) \
943      F(cl_kernel_arg_info, CL_KERNEL_ARG_ACCESS_QUALIFIER, cl_kernel_arg_access_qualifier) \
944      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_NAME, STRING_CLASS) \
945      F(cl_kernel_arg_info, CL_KERNEL_ARG_NAME, STRING_CLASS) \
946      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_QUALIFIER, cl_kernel_arg_type_qualifier) \
947      \
948      F(cl_device_info, CL_DEVICE_PARENT_DEVICE, cl_device_id) \
949      F(cl_device_info, CL_DEVICE_PARTITION_PROPERTIES, VECTOR_CLASS<cl_device_partition_property>) \
950      F(cl_device_info, CL_DEVICE_PARTITION_TYPE, VECTOR_CLASS<cl_device_partition_property>)  \
951      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT, cl_uint) \
952      F(cl_device_info, CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, ::size_t) \
953      F(cl_device_info, CL_DEVICE_PARTITION_AFFINITY_DOMAIN, cl_device_affinity_domain) \
954      F(cl_device_info, CL_DEVICE_BUILT_IN_KERNELS, STRING_CLASS)
955  #endif 
956  #if defined(USE_CL_DEVICE_FISSION)
957  #define __PARAM_NAME_DEVICE_FISSION(F) \
958      F(cl_device_info, CL_DEVICE_PARENT_DEVICE_EXT, cl_device_id) \
959      F(cl_device_info, CL_DEVICE_PARTITION_TYPES_EXT, VECTOR_CLASS<cl_device_partition_property_ext>) \
960      F(cl_device_info, CL_DEVICE_AFFINITY_DOMAINS_EXT, VECTOR_CLASS<cl_device_partition_property_ext>) \
961      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT_EXT , cl_uint) \
962      F(cl_device_info, CL_DEVICE_PARTITION_STYLE_EXT, VECTOR_CLASS<cl_device_partition_property_ext>)
963  #endif 
964  template <typename enum_type, cl_int Name>
965  struct param_traits {};
966  #define __CL_DECLARE_PARAM_TRAITS(token, param_name, T) \
967  struct token;                                        \
968  template<>                                           \
969  struct param_traits<detail:: token,param_name>       \
970  {                                                    \
971      enum { value = param_name };                     \
972      typedef T param_type;                            \
973  };
974  __PARAM_NAME_INFO_1_0(__CL_DECLARE_PARAM_TRAITS)
975  #if defined(CL_VERSION_1_1)
976  __PARAM_NAME_INFO_1_1(__CL_DECLARE_PARAM_TRAITS)
977  #endif 
978  #if defined(CL_VERSION_1_2)
979  __PARAM_NAME_INFO_1_2(__CL_DECLARE_PARAM_TRAITS)
980  #endif 
981  #if defined(USE_CL_DEVICE_FISSION)
982  __PARAM_NAME_DEVICE_FISSION(__CL_DECLARE_PARAM_TRAITS);
983  #endif 
984  #ifdef CL_PLATFORM_ICD_SUFFIX_KHR
985  __CL_DECLARE_PARAM_TRAITS(cl_platform_info, CL_PLATFORM_ICD_SUFFIX_KHR, STRING_CLASS)
986  #endif
987  #ifdef CL_DEVICE_PROFILING_TIMER_OFFSET_AMD
988  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, cl_ulong)
989  #endif
990  #ifdef CL_DEVICE_GLOBAL_FREE_MEMORY_AMD
991  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_FREE_MEMORY_AMD, VECTOR_CLASS< ::size_t>)
992  #endif
993  #ifdef CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD
994  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD, cl_uint)
995  #endif
996  #ifdef CL_DEVICE_SIMD_WIDTH_AMD
997  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_SIMD_WIDTH_AMD, cl_uint)
998  #endif
999  #ifdef CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD
1000  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD, cl_uint)
1001  #endif
1002  #ifdef CL_DEVICE_WAVEFRONT_WIDTH_AMD
1003  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_WAVEFRONT_WIDTH_AMD, cl_uint)
1004  #endif
1005  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD
1006  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD, cl_uint)
1007  #endif
1008  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD
1009  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD, cl_uint)
1010  #endif
1011  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD
1012  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD, cl_uint)
1013  #endif
1014  #ifdef CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD
1015  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD, cl_uint)
1016  #endif
1017  #ifdef CL_DEVICE_LOCAL_MEM_BANKS_AMD
1018  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_LOCAL_MEM_BANKS_AMD, cl_uint)
1019  #endif
1020  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV
1021  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, cl_uint)
1022  #endif
1023  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV
1024  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV, cl_uint)
1025  #endif
1026  #ifdef CL_DEVICE_REGISTERS_PER_BLOCK_NV
1027  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_REGISTERS_PER_BLOCK_NV, cl_uint)
1028  #endif
1029  #ifdef CL_DEVICE_WARP_SIZE_NV
1030  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_WARP_SIZE_NV, cl_uint)
1031  #endif
1032  #ifdef CL_DEVICE_GPU_OVERLAP_NV
1033  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GPU_OVERLAP_NV, cl_bool)
1034  #endif
1035  #ifdef CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV
1036  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV, cl_bool)
1037  #endif
1038  #ifdef CL_DEVICE_INTEGRATED_MEMORY_NV
1039  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_INTEGRATED_MEMORY_NV, cl_bool)
1040  #endif
1041  template <typename Func, typename T>
1042  inline cl_int
1043  getInfo(Func f, cl_uint name, T* param)
1044  {
1045      return getInfoHelper(f, name, param, 0);
1046  }
1047  template <typename Func, typename Arg0>
1048  struct GetInfoFunctor0
1049  {
1050      Func f_; const Arg0& arg0_;
1051      cl_int operator ()(
1052          cl_uint param, ::size_t size, void* value, ::size_t* size_ret)
1053      { return f_(arg0_, param, size, value, size_ret); }
1054  };
1055  template <typename Func, typename Arg0, typename Arg1>
1056  struct GetInfoFunctor1
1057  {
1058      Func f_; const Arg0& arg0_; const Arg1& arg1_;
1059      cl_int operator ()(
1060          cl_uint param, ::size_t size, void* value, ::size_t* size_ret)
1061      { return f_(arg0_, arg1_, param, size, value, size_ret); }
1062  };
1063  template <typename Func, typename Arg0, typename T>
1064  inline cl_int
1065  getInfo(Func f, const Arg0& arg0, cl_uint name, T* param)
1066  {
1067      GetInfoFunctor0<Func, Arg0> f0 = { f, arg0 };
1068      return getInfoHelper(f0, name, param, 0);
1069  }
1070  template <typename Func, typename Arg0, typename Arg1, typename T>
1071  inline cl_int
1072  getInfo(Func f, const Arg0& arg0, const Arg1& arg1, cl_uint name, T* param)
1073  {
1074      GetInfoFunctor1<Func, Arg0, Arg1> f0 = { f, arg0, arg1 };
1075      return getInfoHelper(f0, name, param, 0);
1076  }
1077  template<typename T>
1078  struct ReferenceHandler
1079  { };
1080  #if defined(CL_VERSION_1_2)
1081  template <>
1082  struct ReferenceHandler<cl_device_id>
1083  {
1084      static cl_int retain(cl_device_id device)
1085      { return ::clRetainDevice(device); }
1086      static cl_int release(cl_device_id device)
1087      { return ::clReleaseDevice(device); }
1088  };
1089  #else 
1090  template <>
1091  struct ReferenceHandler<cl_device_id>
1092  {
1093      static cl_int retain(cl_device_id)
1094      { return CL_SUCCESS; }
1095      static cl_int release(cl_device_id)
1096      { return CL_SUCCESS; }
1097  };
1098  #endif 
1099  template <>
1100  struct ReferenceHandler<cl_platform_id>
1101  {
1102      static cl_int retain(cl_platform_id)
1103      { return CL_SUCCESS; }
1104      static cl_int release(cl_platform_id)
1105      { return CL_SUCCESS; }
1106  };
1107  template <>
1108  struct ReferenceHandler<cl_context>
1109  {
1110      static cl_int retain(cl_context context)
1111      { return ::clRetainContext(context); }
1112      static cl_int release(cl_context context)
1113      { return ::clReleaseContext(context); }
1114  };
1115  template <>
1116  struct ReferenceHandler<cl_command_queue>
1117  {
1118      static cl_int retain(cl_command_queue queue)
1119      { return ::clRetainCommandQueue(queue); }
1120      static cl_int release(cl_command_queue queue)
1121      { return ::clReleaseCommandQueue(queue); }
1122  };
1123  template <>
1124  struct ReferenceHandler<cl_mem>
1125  {
1126      static cl_int retain(cl_mem memory)
1127      { return ::clRetainMemObject(memory); }
1128      static cl_int release(cl_mem memory)
1129      { return ::clReleaseMemObject(memory); }
1130  };
1131  template <>
1132  struct ReferenceHandler<cl_sampler>
1133  {
1134      static cl_int retain(cl_sampler sampler)
1135      { return ::clRetainSampler(sampler); }
1136      static cl_int release(cl_sampler sampler)
1137      { return ::clReleaseSampler(sampler); }
1138  };
1139  template <>
1140  struct ReferenceHandler<cl_program>
1141  {
1142      static cl_int retain(cl_program program)
1143      { return ::clRetainProgram(program); }
1144      static cl_int release(cl_program program)
1145      { return ::clReleaseProgram(program); }
1146  };
1147  template <>
1148  struct ReferenceHandler<cl_kernel>
1149  {
1150      static cl_int retain(cl_kernel kernel)
1151      { return ::clRetainKernel(kernel); }
1152      static cl_int release(cl_kernel kernel)
1153      { return ::clReleaseKernel(kernel); }
1154  };
1155  template <>
1156  struct ReferenceHandler<cl_event>
1157  {
1158      static cl_int retain(cl_event event)
1159      { return ::clRetainEvent(event); }
1160      static cl_int release(cl_event event)
1161      { return ::clReleaseEvent(event); }
1162  };
1163  static cl_uint getVersion(const char *versionInfo)
1164  {
1165      int highVersion = 0;
1166      int lowVersion = 0;
1167      int index = 7;
1168      while(versionInfo[index] != '.' ) {
1169          highVersion *= 10;
1170          highVersion += versionInfo[index]-'0';
1171          ++index;
1172      }
1173      ++index;
1174      while(versionInfo[index] != ' ' &&  versionInfo[index] != '\0') {
1175          lowVersion *= 10;
1176          lowVersion += versionInfo[index]-'0';
1177          ++index;
1178      }
1179      return (highVersion << 16) | lowVersion;
1180  }
1181  static cl_uint getPlatformVersion(cl_platform_id platform)
1182  {
1183      ::size_t size = 0;
1184      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, 0, NULL, &size);
1185      char *versionInfo = (char *) alloca(size);
1186      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, size, &versionInfo[0], &size);
1187      return getVersion(versionInfo);
1188  }
1189  static cl_uint getDevicePlatformVersion(cl_device_id device)
1190  {
1191      cl_platform_id platform;
1192      clGetDeviceInfo(device, CL_DEVICE_PLATFORM, sizeof(platform), &platform, NULL);
1193      return getPlatformVersion(platform);
1194  }
1195  #if defined(CL_VERSION_1_2) && defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
1196  static cl_uint getContextPlatformVersion(cl_context context)
1197  {
1198      ::size_t size = 0;
1199      clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &size);
1200      if (size == 0)
1201          return 0;
1202      cl_device_id *devices = (cl_device_id *) alloca(size);
1203      clGetContextInfo(context, CL_CONTEXT_DEVICES, size, devices, NULL);
1204      return getDevicePlatformVersion(devices[0]);
1205  }
1206  #endif 
1207  template <typename T>
1208  class Wrapper
1209  {
1210  public:
1211      typedef T cl_type;
1212  protected:
1213      cl_type object_;
1214  public:
1215      Wrapper() : object_(NULL) { }
1216      Wrapper(const cl_type &obj) : object_(obj) { }
1217      ~Wrapper()
1218      {
1219          if (object_ != NULL) { release(); }
1220      }
1221      Wrapper(const Wrapper<cl_type>& rhs)
1222      {
1223          object_ = rhs.object_;
1224          if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1225      }
1226  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1227      Wrapper(Wrapper<cl_type>&& rhs) CL_HPP_NOEXCEPT
1228      {
1229          object_ = rhs.object_;
1230          rhs.object_ = NULL;
1231      }
1232  #endif
1233      Wrapper<cl_type>& operator = (const Wrapper<cl_type>& rhs)
1234      {
1235          if (this != &rhs) {
1236              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1237              object_ = rhs.object_;
1238              if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1239          }
1240          return *this;
1241      }
1242  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1243      Wrapper<cl_type>& operator = (Wrapper<cl_type>&& rhs)
1244      {
1245          if (this != &rhs) {
1246              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1247              object_ = rhs.object_;
1248              rhs.object_ = NULL;
1249          }
1250          return *this;
1251      }
1252  #endif
1253      Wrapper<cl_type>& operator = (const cl_type &rhs)
1254      {
1255          if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1256          object_ = rhs;
1257          return *this;
1258      }
1259      cl_type operator ()() const { return object_; }
1260      cl_type& operator ()() { return object_; }
1261  protected:
1262      template<typename Func, typename U>
1263      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1264      cl_int retain() const
1265      {
1266          return ReferenceHandler<cl_type>::retain(object_);
1267      }
1268      cl_int release() const
1269      {
1270          return ReferenceHandler<cl_type>::release(object_);
1271      }
1272  };
1273  template <>
1274  class Wrapper<cl_device_id>
1275  {
1276  public:
1277      typedef cl_device_id cl_type;
1278  protected:
1279      cl_type object_;
1280      bool referenceCountable_;
1281      static bool isReferenceCountable(cl_device_id device)
1282      {
1283          bool retVal = false;
1284          if (device != NULL) {
1285              int version = getDevicePlatformVersion(device);
1286              if(version > ((1 << 16) + 1)) {
1287                  retVal = true;
1288              }
1289          }
1290          return retVal;
1291      }
1292  public:
1293      Wrapper() : object_(NULL), referenceCountable_(false) 
1294      { 
1295      }
1296      Wrapper(const cl_type &obj) : object_(obj), referenceCountable_(false) 
1297      {
1298          referenceCountable_ = isReferenceCountable(obj); 
1299      }
1300      ~Wrapper()
1301      {
1302          if (object_ != NULL) { release(); }
1303      }
1304      Wrapper(const Wrapper<cl_type>& rhs)
1305      {
1306          object_ = rhs.object_;
1307          referenceCountable_ = isReferenceCountable(object_); 
1308          if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1309      }
1310  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1311      Wrapper(Wrapper<cl_type>&& rhs) CL_HPP_NOEXCEPT
1312      {
1313          object_ = rhs.object_;
1314          referenceCountable_ = rhs.referenceCountable_;
1315          rhs.object_ = NULL;
1316          rhs.referenceCountable_ = false;
1317      }
1318  #endif
1319      Wrapper<cl_type>& operator = (const Wrapper<cl_type>& rhs)
1320      {
1321          if (this != &rhs) {
1322              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1323              object_ = rhs.object_;
1324              referenceCountable_ = rhs.referenceCountable_;
1325              if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1326          }
1327          return *this;
1328      }
1329  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1330      Wrapper<cl_type>& operator = (Wrapper<cl_type>&& rhs)
1331      {
1332          if (this != &rhs) {
1333              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1334              object_ = rhs.object_;
1335              referenceCountable_ = rhs.referenceCountable_;
1336              rhs.object_ = NULL;
1337              rhs.referenceCountable_ = false;
1338          }
1339          return *this;
1340      }
1341  #endif
1342      Wrapper<cl_type>& operator = (const cl_type &rhs)
1343      {
1344          if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1345          object_ = rhs;
1346          referenceCountable_ = isReferenceCountable(object_); 
1347          return *this;
1348      }
1349      cl_type operator ()() const { return object_; }
1350      cl_type& operator ()() { return object_; }
1351  protected:
1352      template<typename Func, typename U>
1353      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1354      template<typename Func, typename U>
1355      friend inline cl_int getInfoHelper(Func, cl_uint, VECTOR_CLASS<U>*, int, typename U::cl_type);
1356      cl_int retain() const
1357      {
1358          if( referenceCountable_ ) {
1359              return ReferenceHandler<cl_type>::retain(object_);
1360          }
1361          else {
1362              return CL_SUCCESS;
1363          }
1364      }
1365      cl_int release() const
1366      {
1367          if( referenceCountable_ ) {
1368              return ReferenceHandler<cl_type>::release(object_);
1369          }
1370          else {
1371              return CL_SUCCESS;
1372          }
1373      }
1374  };
1375  } 
1376  struct ImageFormat : public cl_image_format
1377  {
1378      ImageFormat(){}
1379      ImageFormat(cl_channel_order order, cl_channel_type type)
1380      {
1381          image_channel_order = order;
1382          image_channel_data_type = type;
1383      }
1384      ImageFormat& operator = (const ImageFormat& rhs)
1385      {
1386          if (this != &rhs) {
1387              this->image_channel_data_type = rhs.image_channel_data_type;
1388              this->image_channel_order     = rhs.image_channel_order;
1389          }
1390          return *this;
1391      }
1392  };
1393  class Device : public detail::Wrapper<cl_device_id>
1394  {
1395  public:
1396      Device() : detail::Wrapper<cl_type>() { }
1397      __CL_EXPLICIT_CONSTRUCTORS Device(const cl_device_id &device) : detail::Wrapper<cl_type>(device) { }
1398      static Device getDefault(cl_int * err = NULL);
1399      Device& operator = (const cl_device_id& rhs)
1400      {
1401          detail::Wrapper<cl_type>::operator=(rhs);
1402          return *this;
1403      }
1404      Device(const Device& dev) : detail::Wrapper<cl_type>(dev) {}
1405      Device& operator = (const Device &dev)
1406      {
1407          detail::Wrapper<cl_type>::operator=(dev);
1408          return *this;
1409      }
1410  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1411      Device(Device&& dev) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(dev)) {}
1412      Device& operator = (Device &&dev)
1413      {
1414          detail::Wrapper<cl_type>::operator=(std::move(dev));
1415          return *this;
1416      }
1417  #endif 
1418      template <typename T>
1419      cl_int getInfo(cl_device_info name, T* param) const
1420      {
1421          return detail::errHandler(
1422              detail::getInfo(&::clGetDeviceInfo, object_, name, param),
1423              __GET_DEVICE_INFO_ERR);
1424      }
1425      template <cl_int name> typename
1426      detail::param_traits<detail::cl_device_info, name>::param_type
1427      getInfo(cl_int* err = NULL) const
1428      {
1429          typename detail::param_traits<
1430              detail::cl_device_info, name>::param_type param;
1431          cl_int result = getInfo(name, &param);
1432          if (err != NULL) {
1433              *err = result;
1434          }
1435          return param;
1436      }
1437  #if defined(CL_VERSION_1_2)
1438      cl_int createSubDevices(
1439          const cl_device_partition_property * properties,
1440          VECTOR_CLASS<Device>* devices)
1441      {
1442          cl_uint n = 0;
1443          cl_int err = clCreateSubDevices(object_, properties, 0, NULL, &n);
1444          if (err != CL_SUCCESS) {
1445              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1446          }
1447          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1448          err = clCreateSubDevices(object_, properties, n, ids, NULL);
1449          if (err != CL_SUCCESS) {
1450              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1451          }
1452          devices->assign(&ids[0], &ids[n]);
1453          return CL_SUCCESS;
1454      }
1455  #endif 
1456  #if defined(CL_VERSION_1_1)
1457  #if defined(USE_CL_DEVICE_FISSION)
1458      cl_int createSubDevices(
1459          const cl_device_partition_property_ext * properties,
1460          VECTOR_CLASS<Device>* devices)
1461      {
1462          typedef CL_API_ENTRY cl_int 
1463              ( CL_API_CALL * PFN_clCreateSubDevicesEXT)(
1464                  cl_device_id &bsol;*in_device*/,
1465                  const cl_device_partition_property_ext * &bsol;* properties */,
1466                  cl_uint &bsol;*num_entries*/,
1467                  cl_device_id * &bsol;*out_devices*/,
1468                  cl_uint * &bsol;*num_devices*/ ) CL_EXT_SUFFIX__VERSION_1_1;
1469          static PFN_clCreateSubDevicesEXT pfn_clCreateSubDevicesEXT = NULL;
1470          __INIT_CL_EXT_FCN_PTR(clCreateSubDevicesEXT);
1471          cl_uint n = 0;
1472          cl_int err = pfn_clCreateSubDevicesEXT(object_, properties, 0, NULL, &n);
1473          if (err != CL_SUCCESS) {
1474              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1475          }
1476          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1477          err = pfn_clCreateSubDevicesEXT(object_, properties, n, ids, NULL);
1478          if (err != CL_SUCCESS) {
1479              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1480          }
1481          devices->assign(&ids[0], &ids[n]);
1482          return CL_SUCCESS;
1483      }
1484  #endif 
1485  #endif 
1486  };
1487  class Platform : public detail::Wrapper<cl_platform_id>
1488  {
1489  public:
1490      Platform() : detail::Wrapper<cl_type>()  { }
1491      __CL_EXPLICIT_CONSTRUCTORS Platform(const cl_platform_id &platform) : detail::Wrapper<cl_type>(platform) { }
1492      Platform& operator = (const cl_platform_id& rhs)
1493      {
1494          detail::Wrapper<cl_type>::operator=(rhs);
1495          return *this;
1496      }
1497      cl_int getInfo(cl_platform_info name, STRING_CLASS* param) const
1498      {
1499          return detail::errHandler(
1500              detail::getInfo(&::clGetPlatformInfo, object_, name, param),
1501              __GET_PLATFORM_INFO_ERR);
1502      }
1503      template <cl_int name> typename
1504      detail::param_traits<detail::cl_platform_info, name>::param_type
1505      getInfo(cl_int* err = NULL) const
1506      {
1507          typename detail::param_traits<
1508              detail::cl_platform_info, name>::param_type param;
1509          cl_int result = getInfo(name, &param);
1510          if (err != NULL) {
1511              *err = result;
1512          }
1513          return param;
1514      }
1515      cl_int getDevices(
1516          cl_device_type type,
1517          VECTOR_CLASS<Device>* devices) const
1518      {
1519          cl_uint n = 0;
1520          if( devices == NULL ) {
1521              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1522          }
1523          cl_int err = ::clGetDeviceIDs(object_, type, 0, NULL, &n);
1524          if (err != CL_SUCCESS) {
1525              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1526          }
1527          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1528          err = ::clGetDeviceIDs(object_, type, n, ids, NULL);
1529          if (err != CL_SUCCESS) {
1530              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1531          }
1532          devices->assign(&ids[0], &ids[n]);
1533          return CL_SUCCESS;
1534      }
1535  #if defined(USE_DX_INTEROP)
1536      cl_int getDevices(
1537          cl_d3d10_device_source_khr d3d_device_source,
1538          void *                     d3d_object,
1539          cl_d3d10_device_set_khr    d3d_device_set,
1540          VECTOR_CLASS<Device>* devices) const
1541      {
1542          typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clGetDeviceIDsFromD3D10KHR)(
1543              cl_platform_id platform, 
1544              cl_d3d10_device_source_khr d3d_device_source, 
1545              void * d3d_object,
1546              cl_d3d10_device_set_khr d3d_device_set,
1547              cl_uint num_entries,
1548              cl_device_id * devices,
1549              cl_uint* num_devices);
1550          if( devices == NULL ) {
1551              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1552          }
1553          static PFN_clGetDeviceIDsFromD3D10KHR pfn_clGetDeviceIDsFromD3D10KHR = NULL;
1554          __INIT_CL_EXT_FCN_PTR_PLATFORM(object_, clGetDeviceIDsFromD3D10KHR);
1555          cl_uint n = 0;
1556          cl_int err = pfn_clGetDeviceIDsFromD3D10KHR(
1557              object_, 
1558              d3d_device_source, 
1559              d3d_object,
1560              d3d_device_set, 
1561              0, 
1562              NULL, 
1563              &n);
1564          if (err != CL_SUCCESS) {
1565              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1566          }
1567          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1568          err = pfn_clGetDeviceIDsFromD3D10KHR(
1569              object_, 
1570              d3d_device_source, 
1571              d3d_object,
1572              d3d_device_set,
1573              n, 
1574              ids, 
1575              NULL);
1576          if (err != CL_SUCCESS) {
1577              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1578          }
1579          devices->assign(&ids[0], &ids[n]);
1580          return CL_SUCCESS;
1581      }
1582  #endif
1583      static cl_int get(
1584          VECTOR_CLASS<Platform>* platforms)
1585      {
1586          cl_uint n = 0;
1587          if( platforms == NULL ) {
1588              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1589          }
1590          cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1591          if (err != CL_SUCCESS) {
1592              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1593          }
1594          cl_platform_id* ids = (cl_platform_id*) alloca(
1595              n * sizeof(cl_platform_id));
1596          err = ::clGetPlatformIDs(n, ids, NULL);
1597          if (err != CL_SUCCESS) {
1598              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1599          }
1600          platforms->assign(&ids[0], &ids[n]);
1601          return CL_SUCCESS;
1602      }
1603      static cl_int get(
1604          Platform * platform)
1605      {
1606          cl_uint n = 0;
1607          if( platform == NULL ) {
1608              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1609          }
1610          cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1611          if (err != CL_SUCCESS) {
1612              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1613          }
1614          cl_platform_id* ids = (cl_platform_id*) alloca(
1615              n * sizeof(cl_platform_id));
1616          err = ::clGetPlatformIDs(n, ids, NULL);
1617          if (err != CL_SUCCESS) {
1618              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1619          }
1620          *platform = ids[0];
1621          return CL_SUCCESS;
1622      }
1623      static Platform get(
1624          cl_int * errResult = NULL)
1625      {
1626          Platform platform;
1627          cl_uint n = 0;
1628          cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1629          if (err != CL_SUCCESS) {
1630              detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1631              if (errResult != NULL) {
1632                  *errResult = err;
1633              }
1634              return Platform();
1635          }
1636          cl_platform_id* ids = (cl_platform_id*) alloca(
1637              n * sizeof(cl_platform_id));
1638          err = ::clGetPlatformIDs(n, ids, NULL);
1639          if (err != CL_SUCCESS) {
1640              detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1641              if (errResult != NULL) {
1642                  *errResult = err;
1643              }
1644              return Platform();
1645          }
1646          return Platform(ids[0]);
1647      }
1648      static Platform getDefault( 
1649          cl_int *errResult = NULL )
1650      {
1651          return get(errResult);
1652      }
1653  #if defined(CL_VERSION_1_2)
1654      cl_int
1655      unloadCompiler()
1656      {
1657          return ::clUnloadPlatformCompiler(object_);
1658      }
1659  #endif 
1660  }; 
1661  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) && !defined(CL_VERSION_1_2))
1662  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int
1663  UnloadCompiler() CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1664  inline cl_int
1665  UnloadCompiler()
1666  {
1667      return ::clUnloadCompiler();
1668  }
1669  #endif 
1670  class Context 
1671      : public detail::Wrapper<cl_context>
1672  {
1673  private:
1674  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
1675      static std::atomic<int> default_initialized_;
1676  #else 
1677      static volatile int default_initialized_;
1678  #endif 
1679      static Context default_;
1680      static volatile cl_int default_error_;
1681  public:
1682      Context(
1683          const VECTOR_CLASS<Device>& devices,
1684          cl_context_properties* properties = NULL,
1685          void (CL_CALLBACK * notifyFptr)(
1686              const char *,
1687              const void *,
1688              ::size_t,
1689              void *) = NULL,
1690          void* data = NULL,
1691          cl_int* err = NULL)
1692      {
1693          cl_int error;
1694          ::size_t numDevices = devices.size();
1695          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
1696          for( ::size_t deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
1697              deviceIDs[deviceIndex] = (devices[deviceIndex])();
1698          }
1699          object_ = ::clCreateContext(
1700              properties, (cl_uint) numDevices,
1701              deviceIDs,
1702              notifyFptr, data, &error);
1703          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1704          if (err != NULL) {
1705              *err = error;
1706          }
1707      }
1708      Context(
1709          const Device& device,
1710          cl_context_properties* properties = NULL,
1711          void (CL_CALLBACK * notifyFptr)(
1712              const char *,
1713              const void *,
1714              ::size_t,
1715              void *) = NULL,
1716          void* data = NULL,
1717          cl_int* err = NULL)
1718      {
1719          cl_int error;
1720          cl_device_id deviceID = device();
1721          object_ = ::clCreateContext(
1722              properties, 1,
1723              &deviceID,
1724              notifyFptr, data, &error);
1725          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1726          if (err != NULL) {
1727              *err = error;
1728          }
1729      }
1730      Context(
1731          cl_device_type type,
1732          cl_context_properties* properties = NULL,
1733          void (CL_CALLBACK * notifyFptr)(
1734              const char *,
1735              const void *,
1736              ::size_t,
1737              void *) = NULL,
1738          void* data = NULL,
1739          cl_int* err = NULL)
1740      {
1741          cl_int error;
1742  #if !defined(__APPLE__) && !defined(__MACOS)
1743          cl_context_properties prop[4] = {CL_CONTEXT_PLATFORM, 0, 0, 0 };
1744          if (properties == NULL) {
1745              VECTOR_CLASS<Platform> platforms;
1746              error = Platform::get(&platforms);
1747              if (error != CL_SUCCESS) {
1748                  detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1749                  if (err != NULL) {
1750                      *err = error;
1751                  }
1752                  return;
1753              }
1754              cl_context_properties platform_id = 0;
1755              for (unsigned int i = 0; i < platforms.size(); i++) {
1756                  VECTOR_CLASS<Device> devices;
1757  #if defined(__CL_ENABLE_EXCEPTIONS)
1758                  try {
1759  #endif
1760                      error = platforms[i].getDevices(type, &devices);
1761  #if defined(__CL_ENABLE_EXCEPTIONS)
1762                  } catch (Error) {}
1763  #endif
1764                  if (error != CL_SUCCESS && error != CL_DEVICE_NOT_FOUND) {
1765                      detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1766                      if (err != NULL) {
1767                          *err = error;
1768                      }
1769                  }
1770                  if (devices.size() > 0) {
1771                      platform_id = (cl_context_properties)platforms[i]();
1772                      break;
1773                  }
1774              }
1775              if (platform_id == 0) {
1776                  detail::errHandler(CL_DEVICE_NOT_FOUND, __CREATE_CONTEXT_FROM_TYPE_ERR);
1777                  if (err != NULL) {
1778                      *err = CL_DEVICE_NOT_FOUND;
1779                  }
1780                  return;
1781              }
1782              prop[1] = platform_id;
1783              properties = &prop[0];
1784          }
1785  #endif
1786          object_ = ::clCreateContextFromType(
1787              properties, type, notifyFptr, data, &error);
1788          detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1789          if (err != NULL) {
1790              *err = error;
1791          }
1792      }
1793      Context(const Context& ctx) : detail::Wrapper<cl_type>(ctx) {}
1794      Context& operator = (const Context &ctx)
1795      {
1796          detail::Wrapper<cl_type>::operator=(ctx);
1797          return *this;
1798      }
1799  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1800      Context(Context&& ctx) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(ctx)) {}
1801      Context& operator = (Context &&ctx)
1802      {
1803          detail::Wrapper<cl_type>::operator=(std::move(ctx));
1804          return *this;
1805      }
1806  #endif 
1807      static Context getDefault(cl_int * err = NULL) 
1808      {
1809          int state = detail::compare_exchange(
1810              &default_initialized_, 
1811              __DEFAULT_BEING_INITIALIZED, __DEFAULT_NOT_INITIALIZED);
1812          if (state & __DEFAULT_INITIALIZED) {
1813              if (err != NULL) {
1814                  *err = default_error_;
1815              }
1816              return default_;
1817          }
1818          if (state & __DEFAULT_BEING_INITIALIZED) {
1819                while(default_initialized_ != __DEFAULT_INITIALIZED) {
1820                    detail::fence();
1821                }
1822              if (err != NULL) {
1823                  *err = default_error_;
1824              }
1825              return default_;
1826          }
1827          cl_int error;
1828          default_ = Context(
1829              CL_DEVICE_TYPE_DEFAULT,
1830              NULL,
1831              NULL,
1832              NULL,
1833              &error);
1834          detail::fence();
1835          default_error_ = error;
1836          default_initialized_ = __DEFAULT_INITIALIZED;
1837          detail::fence();
1838          if (err != NULL) {
1839              *err = default_error_;
1840          }
1841          return default_;
1842      }
1843      Context() : detail::Wrapper<cl_type>() { }
1844      __CL_EXPLICIT_CONSTRUCTORS Context(const cl_context& context) : detail::Wrapper<cl_type>(context) { }
1845      Context& operator = (const cl_context& rhs)
1846      {
1847          detail::Wrapper<cl_type>::operator=(rhs);
1848          return *this;
1849      }
1850      template <typename T>
1851      cl_int getInfo(cl_context_info name, T* param) const
1852      {
1853          return detail::errHandler(
1854              detail::getInfo(&::clGetContextInfo, object_, name, param),
1855              __GET_CONTEXT_INFO_ERR);
1856      }
1857      template <cl_int name> typename
1858      detail::param_traits<detail::cl_context_info, name>::param_type
1859      getInfo(cl_int* err = NULL) const
1860      {
1861          typename detail::param_traits<
1862              detail::cl_context_info, name>::param_type param;
1863          cl_int result = getInfo(name, &param);
1864          if (err != NULL) {
1865              *err = result;
1866          }
1867          return param;
1868      }
1869      cl_int getSupportedImageFormats(
1870          cl_mem_flags flags,
1871          cl_mem_object_type type,
1872          VECTOR_CLASS<ImageFormat>* formats) const
1873      {
1874          cl_uint numEntries;
1875          if (!formats) {
1876              return CL_SUCCESS;
1877          }
1878          cl_int err = ::clGetSupportedImageFormats(
1879              object_,
1880              flags,
1881              type,
1882              0,
1883              NULL,
1884              &numEntries);
1885          if (err != CL_SUCCESS) {
1886              return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1887          }
1888          if (numEntries > 0) {
1889              ImageFormat* value = (ImageFormat*)
1890                  alloca(numEntries * sizeof(ImageFormat));
1891              err = ::clGetSupportedImageFormats(
1892                  object_,
1893                  flags,
1894                  type,
1895                  numEntries,
1896                  (cl_image_format*)value,
1897                  NULL);
1898              if (err != CL_SUCCESS) {
1899                  return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1900              }
1901              formats->assign(&value[0], &value[numEntries]);
1902          }
1903          else {
1904              formats->clear();
1905          }
1906          return CL_SUCCESS;
1907      }
1908  };
1909  inline Device Device::getDefault(cl_int * err)
1910  {
1911      cl_int error;
1912      Device device;
1913      Context context = Context::getDefault(&error);
1914      detail::errHandler(error, __CREATE_CONTEXT_ERR);
1915      if (error != CL_SUCCESS) {
1916          if (err != NULL) {
1917              *err = error;
1918          }
1919      }
1920      else {
1921          device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
1922          if (err != NULL) {
1923              *err = CL_SUCCESS;
1924          }
1925      }
1926      return device;
1927  }
1928  #ifdef _WIN32
1929  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
1930  __declspec(selectany) std::atomic<int> Context::default_initialized_;
1931  #else 
1932  __declspec(selectany) volatile int Context::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
1933  #endif 
1934  __declspec(selectany) Context Context::default_;
1935  __declspec(selectany) volatile cl_int Context::default_error_ = CL_SUCCESS;
1936  #else 
1937  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
1938  __attribute__((weak)) std::atomic<int> Context::default_initialized_;
1939  #else 
1940  __attribute__((weak)) volatile int Context::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
1941  #endif 
1942  __attribute__((weak)) Context Context::default_;
1943  __attribute__((weak)) volatile cl_int Context::default_error_ = CL_SUCCESS;
1944  #endif 
1945  class Event : public detail::Wrapper<cl_event>
1946  {
1947  public:
1948      Event() : detail::Wrapper<cl_type>() { }
1949      __CL_EXPLICIT_CONSTRUCTORS Event(const cl_event& event) : detail::Wrapper<cl_type>(event) { }
1950      Event& operator = (const cl_event& rhs)
1951      {
1952          detail::Wrapper<cl_type>::operator=(rhs);
1953          return *this;
1954      }
1955      template <typename T>
1956      cl_int getInfo(cl_event_info name, T* param) const
1957      {
1958          return detail::errHandler(
1959              detail::getInfo(&::clGetEventInfo, object_, name, param),
1960              __GET_EVENT_INFO_ERR);
1961      }
1962      template <cl_int name> typename
1963      detail::param_traits<detail::cl_event_info, name>::param_type
1964      getInfo(cl_int* err = NULL) const
1965      {
1966          typename detail::param_traits<
1967              detail::cl_event_info, name>::param_type param;
1968          cl_int result = getInfo(name, &param);
1969          if (err != NULL) {
1970              *err = result;
1971          }
1972          return param;
1973      }
1974      template <typename T>
1975      cl_int getProfilingInfo(cl_profiling_info name, T* param) const
1976      {
1977          return detail::errHandler(detail::getInfo(
1978              &::clGetEventProfilingInfo, object_, name, param),
1979              __GET_EVENT_PROFILE_INFO_ERR);
1980      }
1981      template <cl_int name> typename
1982      detail::param_traits<detail::cl_profiling_info, name>::param_type
1983      getProfilingInfo(cl_int* err = NULL) const
1984      {
1985          typename detail::param_traits<
1986              detail::cl_profiling_info, name>::param_type param;
1987          cl_int result = getProfilingInfo(name, &param);
1988          if (err != NULL) {
1989              *err = result;
1990          }
1991          return param;
1992      }
1993      cl_int wait() const
1994      {
1995          return detail::errHandler(
1996              ::clWaitForEvents(1, &object_),
1997              __WAIT_FOR_EVENTS_ERR);
1998      }
1999  #if defined(CL_VERSION_1_1)
2000      cl_int setCallback(
2001          cl_int type,
2002          void (CL_CALLBACK * pfn_notify)(cl_event, cl_int, void *),		
2003          void * user_data = NULL)
2004      {
2005          return detail::errHandler(
2006              ::clSetEventCallback(
2007                  object_,
2008                  type,
2009                  pfn_notify,
2010                  user_data), 
2011              __SET_EVENT_CALLBACK_ERR);
2012      }
2013  #endif
2014      static cl_int
2015      waitForEvents(const VECTOR_CLASS<Event>& events)
2016      {
2017          return detail::errHandler(
2018              ::clWaitForEvents(
2019                  (cl_uint) events.size(), (events.size() > 0) ? (cl_event*)&events.front() : NULL),
2020              __WAIT_FOR_EVENTS_ERR);
2021      }
2022  };
2023  #if defined(CL_VERSION_1_1)
2024  class UserEvent : public Event
2025  {
2026  public:
2027      UserEvent(
2028          const Context& context,
2029          cl_int * err = NULL)
2030      {
2031          cl_int error;
2032          object_ = ::clCreateUserEvent(
2033              context(),
2034              &error);
2035          detail::errHandler(error, __CREATE_USER_EVENT_ERR);
2036          if (err != NULL) {
2037              *err = error;
2038          }
2039      }
2040      UserEvent() : Event() { }
2041      cl_int setStatus(cl_int status)
2042      {
2043          return detail::errHandler(
2044              ::clSetUserEventStatus(object_,status), 
2045              __SET_USER_EVENT_STATUS_ERR);
2046      }
2047  };
2048  #endif
2049  inline static cl_int
2050  WaitForEvents(const VECTOR_CLASS<Event>& events)
2051  {
2052      return detail::errHandler(
2053          ::clWaitForEvents(
2054              (cl_uint) events.size(), (events.size() > 0) ? (cl_event*)&events.front() : NULL),
2055          __WAIT_FOR_EVENTS_ERR);
2056  }
2057  class Memory : public detail::Wrapper<cl_mem>
2058  {
2059  public:
2060      Memory() : detail::Wrapper<cl_type>() { }
2061      __CL_EXPLICIT_CONSTRUCTORS Memory(const cl_mem& memory) : detail::Wrapper<cl_type>(memory) { }
2062      Memory& operator = (const cl_mem& rhs)
2063      {
2064          detail::Wrapper<cl_type>::operator=(rhs);
2065          return *this;
2066      }
2067      Memory(const Memory& mem) : detail::Wrapper<cl_type>(mem) {}
2068      Memory& operator = (const Memory &mem)
2069      {
2070          detail::Wrapper<cl_type>::operator=(mem);
2071          return *this;
2072      }
2073  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2074      Memory(Memory&& mem) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(mem)) {}
2075      Memory& operator = (Memory &&mem)
2076      {
2077          detail::Wrapper<cl_type>::operator=(std::move(mem));
2078          return *this;
2079      }
2080  #endif 
2081      template <typename T>
2082      cl_int getInfo(cl_mem_info name, T* param) const
2083      {
2084          return detail::errHandler(
2085              detail::getInfo(&::clGetMemObjectInfo, object_, name, param),
2086              __GET_MEM_OBJECT_INFO_ERR);
2087      }
2088      template <cl_int name> typename
2089      detail::param_traits<detail::cl_mem_info, name>::param_type
2090      getInfo(cl_int* err = NULL) const
2091      {
2092          typename detail::param_traits<
2093              detail::cl_mem_info, name>::param_type param;
2094          cl_int result = getInfo(name, &param);
2095          if (err != NULL) {
2096              *err = result;
2097          }
2098          return param;
2099      }
2100  #if defined(CL_VERSION_1_1)
2101      cl_int setDestructorCallback(
2102          void (CL_CALLBACK * pfn_notify)(cl_mem, void *),		
2103          void * user_data = NULL)
2104      {
2105          return detail::errHandler(
2106              ::clSetMemObjectDestructorCallback(
2107                  object_,
2108                  pfn_notify,
2109                  user_data), 
2110              __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR);
2111      }
2112  #endif
2113  };
2114  class Buffer;
2115  template< typename IteratorType >
2116  cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer );
2117  template< typename IteratorType >
2118  cl_int copy( const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator );
2119  template< typename IteratorType >
2120  cl_int copy( const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer );
2121  template< typename IteratorType >
2122  cl_int copy( const CommandQueue &queue, const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator );
2123  class Buffer : public Memory
2124  {
2125  public:
2126      Buffer(
2127          const Context& context,
2128          cl_mem_flags flags,
2129          ::size_t size,
2130          void* host_ptr = NULL,
2131          cl_int* err = NULL)
2132      {
2133          cl_int error;
2134          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &error);
2135          detail::errHandler(error, __CREATE_BUFFER_ERR);
2136          if (err != NULL) {
2137              *err = error;
2138          }
2139      }
2140      Buffer(
2141           cl_mem_flags flags,
2142          ::size_t size,
2143          void* host_ptr = NULL,
2144          cl_int* err = NULL)
2145      {
2146          cl_int error;
2147          Context context = Context::getDefault(err);
2148          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &error);
2149          detail::errHandler(error, __CREATE_BUFFER_ERR);
2150          if (err != NULL) {
2151              *err = error;
2152          }
2153      }
2154      template< typename IteratorType >
2155      Buffer(
2156          IteratorType startIterator,
2157          IteratorType endIterator,
2158          bool readOnly,
2159          bool useHostPtr = false,
2160          cl_int* err = NULL)
2161      {
2162          typedef typename std::iterator_traits<IteratorType>::value_type DataType;
2163          cl_int error;
2164          cl_mem_flags flags = 0;
2165          if( readOnly ) {
2166              flags |= CL_MEM_READ_ONLY;
2167          }
2168          else {
2169              flags |= CL_MEM_READ_WRITE;
2170          }
2171          if( useHostPtr ) {
2172              flags |= CL_MEM_USE_HOST_PTR;
2173          }
2174          ::size_t size = sizeof(DataType)*(endIterator - startIterator);
2175          Context context = Context::getDefault(err);
2176          if( useHostPtr ) {
2177              object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
2178          } else {
2179              object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
2180          }
2181          detail::errHandler(error, __CREATE_BUFFER_ERR);
2182          if (err != NULL) {
2183              *err = error;
2184          }
2185          if( !useHostPtr ) {
2186              error = cl::copy(startIterator, endIterator, *this);
2187              detail::errHandler(error, __CREATE_BUFFER_ERR);
2188              if (err != NULL) {
2189                  *err = error;
2190              }
2191          }
2192      }
2193      template< typename IteratorType >
2194      Buffer(const Context &context, IteratorType startIterator, IteratorType endIterator,
2195          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2196      template< typename IteratorType >
2197      Buffer(const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator,
2198          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2199      Buffer() : Memory() { }
2200      __CL_EXPLICIT_CONSTRUCTORS Buffer(const cl_mem& buffer) : Memory(buffer) { }
2201      Buffer& operator = (const cl_mem& rhs)
2202      {
2203          Memory::operator=(rhs);
2204          return *this;
2205      }
2206      Buffer(const Buffer& buf) : Memory(buf) {}
2207      Buffer& operator = (const Buffer &buf)
2208      {
2209          Memory::operator=(buf);
2210          return *this;
2211      }
2212  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2213      Buffer(Buffer&& buf) CL_HPP_NOEXCEPT : Memory(std::move(buf)) {}
2214      Buffer& operator = (Buffer &&buf)
2215      {
2216          Memory::operator=(std::move(buf));
2217          return *this;
2218      }
2219  #endif 
2220  #if defined(CL_VERSION_1_1)
2221      Buffer createSubBuffer(
2222          cl_mem_flags flags,
2223          cl_buffer_create_type buffer_create_type,
2224          const void * buffer_create_info,
2225          cl_int * err = NULL)
2226      {
2227          Buffer result;
2228          cl_int error;
2229          result.object_ = ::clCreateSubBuffer(
2230              object_, 
2231              flags, 
2232              buffer_create_type, 
2233              buffer_create_info, 
2234              &error);
2235          detail::errHandler(error, __CREATE_SUBBUFFER_ERR);
2236          if (err != NULL) {
2237              *err = error;
2238          }
2239          return result;
2240      }		
2241  #endif
2242  };
2243  #if defined (USE_DX_INTEROP)
2244  class BufferD3D10 : public Buffer
2245  {
2246  public:
2247      typedef CL_API_ENTRY cl_mem (CL_API_CALL *PFN_clCreateFromD3D10BufferKHR)(
2248      cl_context context, cl_mem_flags flags, ID3D10Buffer*  buffer,
2249      cl_int* errcode_ret);
2250      BufferD3D10(
2251          const Context& context,
2252          cl_mem_flags flags,
2253          ID3D10Buffer* bufobj,
2254          cl_int * err = NULL)
2255      {
2256          static PFN_clCreateFromD3D10BufferKHR pfn_clCreateFromD3D10BufferKHR = NULL;
2257  #if defined(CL_VERSION_1_2)
2258          vector<cl_context_properties> props = context.getInfo<CL_CONTEXT_PROPERTIES>();
2259          cl_platform platform = -1;
2260          for( int i = 0; i < props.size(); ++i ) {
2261              if( props[i] == CL_CONTEXT_PLATFORM ) {
2262                  platform = props[i+1];
2263              }
2264          }
2265          __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, clCreateFromD3D10BufferKHR);
2266  #endif
2267  #if defined(CL_VERSION_1_1)
2268          __INIT_CL_EXT_FCN_PTR(clCreateFromD3D10BufferKHR);
2269  #endif
2270          cl_int error;
2271          object_ = pfn_clCreateFromD3D10BufferKHR(
2272              context(),
2273              flags,
2274              bufobj,
2275              &error);
2276          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2277          if (err != NULL) {
2278              *err = error;
2279          }
2280      }
2281      BufferD3D10() : Buffer() { }
2282      __CL_EXPLICIT_CONSTRUCTORS BufferD3D10(const cl_mem& buffer) : Buffer(buffer) { }
2283      BufferD3D10& operator = (const cl_mem& rhs)
2284      {
2285          Buffer::operator=(rhs);
2286          return *this;
2287      }
2288      BufferD3D10(const BufferD3D10& buf) : Buffer(buf) {}
2289      BufferD3D10& operator = (const BufferD3D10 &buf)
2290      {
2291          Buffer::operator=(buf);
2292          return *this;
2293      }
2294  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2295      BufferD3D10(BufferD3D10&& buf) CL_HPP_NOEXCEPT : Buffer(std::move(buf)) {}
2296      BufferD3D10& operator = (BufferD3D10 &&buf)
2297      {
2298          Buffer::operator=(std::move(buf));
2299          return *this;
2300      }
2301  #endif 
2302  };
2303  #endif
2304  class BufferGL : public Buffer
2305  {
2306  public:
2307      BufferGL(
2308          const Context& context,
2309          cl_mem_flags flags,
2310          cl_GLuint bufobj,
2311          cl_int * err = NULL)
2312      {
2313          cl_int error;
2314          object_ = ::clCreateFromGLBuffer(
2315              context(),
2316              flags,
2317              bufobj,
2318              &error);
2319          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2320          if (err != NULL) {
2321              *err = error;
2322          }
2323      }
2324      BufferGL() : Buffer() { }
2325      __CL_EXPLICIT_CONSTRUCTORS BufferGL(const cl_mem& buffer) : Buffer(buffer) { }
2326      BufferGL& operator = (const cl_mem& rhs)
2327      {
2328          Buffer::operator=(rhs);
2329          return *this;
2330      }
2331      BufferGL(const BufferGL& buf) : Buffer(buf) {}
2332      BufferGL& operator = (const BufferGL &buf)
2333      {
2334          Buffer::operator=(buf);
2335          return *this;
2336      }
2337  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2338      BufferGL(BufferGL&& buf) CL_HPP_NOEXCEPT : Buffer(std::move(buf)) {}
2339      BufferGL& operator = (BufferGL &&buf)
2340      {
2341          Buffer::operator=(std::move(buf));
2342          return *this;
2343      }
2344  #endif 
2345      cl_int getObjectInfo(
2346          cl_gl_object_type *type,
2347          cl_GLuint * gl_object_name)
2348      {
2349          return detail::errHandler(
2350              ::clGetGLObjectInfo(object_,type,gl_object_name),
2351              __GET_GL_OBJECT_INFO_ERR);
2352      }
2353  };
2354  class Image : public Memory
2355  {
2356  protected:
2357      Image() : Memory() { }
2358      __CL_EXPLICIT_CONSTRUCTORS Image(const cl_mem& image) : Memory(image) { }
2359      Image& operator = (const cl_mem& rhs)
2360      {
2361          Memory::operator=(rhs);
2362          return *this;
2363      }
2364      Image(const Image& img) : Memory(img) {}
2365      Image& operator = (const Image &img)
2366      {
2367          Memory::operator=(img);
2368          return *this;
2369      }
2370  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2371      Image(Image&& img) CL_HPP_NOEXCEPT : Memory(std::move(img)) {}
2372      Image& operator = (Image &&img)
2373      {
2374          Memory::operator=(std::move(img));
2375          return *this;
2376      }
2377  #endif 
2378  public:
2379      template <typename T>
2380      cl_int getImageInfo(cl_image_info name, T* param) const
2381      {
2382          return detail::errHandler(
2383              detail::getInfo(&::clGetImageInfo, object_, name, param),
2384              __GET_IMAGE_INFO_ERR);
2385      }
2386      template <cl_int name> typename
2387      detail::param_traits<detail::cl_image_info, name>::param_type
2388      getImageInfo(cl_int* err = NULL) const
2389      {
2390          typename detail::param_traits<
2391              detail::cl_image_info, name>::param_type param;
2392          cl_int result = getImageInfo(name, &param);
2393          if (err != NULL) {
2394              *err = result;
2395          }
2396          return param;
2397      }
2398  };
2399  #if defined(CL_VERSION_1_2)
2400  class Image1D : public Image
2401  {
2402  public:
2403      Image1D(
2404          const Context& context,
2405          cl_mem_flags flags,
2406          ImageFormat format,
2407          ::size_t width,
2408          void* host_ptr = NULL,
2409          cl_int* err = NULL)
2410      {
2411          cl_int error;
2412          cl_image_desc desc =
2413          {
2414              CL_MEM_OBJECT_IMAGE1D,
2415              width,
2416              0, 0, 0, 0, 0, 0, 0, 0
2417          };
2418          object_ = ::clCreateImage(
2419              context(), 
2420              flags, 
2421              &format, 
2422              &desc, 
2423              host_ptr, 
2424              &error);
2425          detail::errHandler(error, __CREATE_IMAGE_ERR);
2426          if (err != NULL) {
2427              *err = error;
2428          }
2429      }
2430      Image1D() { }
2431      __CL_EXPLICIT_CONSTRUCTORS Image1D(const cl_mem& image1D) : Image(image1D) { }
2432      Image1D& operator = (const cl_mem& rhs)
2433      {
2434          Image::operator=(rhs);
2435          return *this;
2436      }
2437      Image1D(const Image1D& img) : Image(img) {}
2438      Image1D& operator = (const Image1D &img)
2439      {
2440          Image::operator=(img);
2441          return *this;
2442      }
2443  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2444      Image1D(Image1D&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2445      Image1D& operator = (Image1D &&img)
2446      {
2447          Image::operator=(std::move(img));
2448          return *this;
2449      }
2450  #endif 
2451  };
2452  class Image1DBuffer : public Image
2453  {
2454  public:
2455      Image1DBuffer(
2456          const Context& context,
2457          cl_mem_flags flags,
2458          ImageFormat format,
2459          ::size_t width,
2460          const Buffer &buffer,
2461          cl_int* err = NULL)
2462      {
2463          cl_int error;
2464          cl_image_desc desc =
2465          {
2466              CL_MEM_OBJECT_IMAGE1D_BUFFER,
2467              width,
2468              0, 0, 0, 0, 0, 0, 0,
2469              buffer()
2470          };
2471          object_ = ::clCreateImage(
2472              context(), 
2473              flags, 
2474              &format, 
2475              &desc, 
2476              NULL, 
2477              &error);
2478          detail::errHandler(error, __CREATE_IMAGE_ERR);
2479          if (err != NULL) {
2480              *err = error;
2481          }
2482      }
2483      Image1DBuffer() { }
2484      __CL_EXPLICIT_CONSTRUCTORS Image1DBuffer(const cl_mem& image1D) : Image(image1D) { }
2485      Image1DBuffer& operator = (const cl_mem& rhs)
2486      {
2487          Image::operator=(rhs);
2488          return *this;
2489      }
2490      Image1DBuffer(const Image1DBuffer& img) : Image(img) {}
2491      Image1DBuffer& operator = (const Image1DBuffer &img)
2492      {
2493          Image::operator=(img);
2494          return *this;
2495      }
2496  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2497      Image1DBuffer(Image1DBuffer&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2498      Image1DBuffer& operator = (Image1DBuffer &&img)
2499      {
2500          Image::operator=(std::move(img));
2501          return *this;
2502      }
2503  #endif 
2504  };
2505  class Image1DArray : public Image
2506  {
2507  public:
2508      Image1DArray(
2509          const Context& context,
2510          cl_mem_flags flags,
2511          ImageFormat format,
2512          ::size_t arraySize,
2513          ::size_t width,
2514          ::size_t rowPitch,
2515          void* host_ptr = NULL,
2516          cl_int* err = NULL)
2517      {
2518          cl_int error;
2519          cl_image_desc desc =
2520          {
2521              CL_MEM_OBJECT_IMAGE1D_ARRAY,
2522              width,
2523              0, 0,  
2524              arraySize,
2525              rowPitch,
2526              0, 0, 0, 0
2527          };
2528          object_ = ::clCreateImage(
2529              context(), 
2530              flags, 
2531              &format, 
2532              &desc, 
2533              host_ptr, 
2534              &error);
2535          detail::errHandler(error, __CREATE_IMAGE_ERR);
2536          if (err != NULL) {
2537              *err = error;
2538          }
2539      }
2540      Image1DArray() { }
2541      __CL_EXPLICIT_CONSTRUCTORS Image1DArray(const cl_mem& imageArray) : Image(imageArray) { }
2542      Image1DArray& operator = (const cl_mem& rhs)
2543      {
2544          Image::operator=(rhs);
2545          return *this;
2546      }
2547      Image1DArray(const Image1DArray& img) : Image(img) {}
2548      Image1DArray& operator = (const Image1DArray &img)
2549      {
2550          Image::operator=(img);
2551          return *this;
2552      }
2553  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2554      Image1DArray(Image1DArray&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2555      Image1DArray& operator = (Image1DArray &&img)
2556      {
2557          Image::operator=(std::move(img));
2558          return *this;
2559      }
2560  #endif 
2561  };
2562  #endif 
2563  class Image2D : public Image
2564  {
2565  public:
2566      Image2D(
2567          const Context& context,
2568          cl_mem_flags flags,
2569          ImageFormat format,
2570          ::size_t width,
2571          ::size_t height,
2572          ::size_t row_pitch = 0,
2573          void* host_ptr = NULL,
2574          cl_int* err = NULL)
2575      {
2576          cl_int error;
2577          bool useCreateImage;
2578  #if defined(CL_VERSION_1_2) && defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2579          {
2580              cl_uint version = detail::getContextPlatformVersion(context());
2581              useCreateImage = (version >= 0x10002); 
2582          }
2583  #elif defined(CL_VERSION_1_2)
2584          useCreateImage = true;
2585  #else
2586          useCreateImage = false;
2587  #endif
2588  #if defined(CL_VERSION_1_2)
2589          if (useCreateImage)
2590          {
2591              cl_image_desc desc =
2592              {
2593                  CL_MEM_OBJECT_IMAGE2D,
2594                  width,
2595                  height,
2596                  0, 0, 
2597                  row_pitch,
2598                  0, 0, 0, 0
2599              };
2600              object_ = ::clCreateImage(
2601                  context(),
2602                  flags,
2603                  &format,
2604                  &desc,
2605                  host_ptr,
2606                  &error);
2607              detail::errHandler(error, __CREATE_IMAGE_ERR);
2608              if (err != NULL) {
2609                  *err = error;
2610              }
2611          }
2612  #endif 
2613  #if !defined(CL_VERSION_1_2) || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2614          if (!useCreateImage)
2615          {
2616              object_ = ::clCreateImage2D(
2617                  context(), flags,&format, width, height, row_pitch, host_ptr, &error);
2618              detail::errHandler(error, __CREATE_IMAGE2D_ERR);
2619              if (err != NULL) {
2620                  *err = error;
2621              }
2622          }
2623  #endif 
2624      }
2625      Image2D() { }
2626      __CL_EXPLICIT_CONSTRUCTORS Image2D(const cl_mem& image2D) : Image(image2D) { }
2627      Image2D& operator = (const cl_mem& rhs)
2628      {
2629          Image::operator=(rhs);
2630          return *this;
2631      }
2632      Image2D(const Image2D& img) : Image(img) {}
2633      Image2D& operator = (const Image2D &img)
2634      {
2635          Image::operator=(img);
2636          return *this;
2637      }
2638  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2639      Image2D(Image2D&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2640      Image2D& operator = (Image2D &&img)
2641      {
2642          Image::operator=(std::move(img));
2643          return *this;
2644      }
2645  #endif 
2646  };
2647  #if !defined(CL_VERSION_1_2)
2648  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED Image2DGL CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED : public Image2D
2649  {
2650  public:
2651      Image2DGL(
2652          const Context& context,
2653          cl_mem_flags flags,
2654          cl_GLenum target,
2655          cl_GLint  miplevel,
2656          cl_GLuint texobj,
2657          cl_int * err = NULL)
2658      {
2659          cl_int error;
2660          object_ = ::clCreateFromGLTexture2D(
2661              context(),
2662              flags,
2663              target,
2664              miplevel,
2665              texobj,
2666              &error);
2667          detail::errHandler(error, __CREATE_GL_TEXTURE_2D_ERR);
2668          if (err != NULL) {
2669              *err = error;
2670          }
2671      }
2672      Image2DGL() : Image2D() { }
2673      __CL_EXPLICIT_CONSTRUCTORS Image2DGL(const cl_mem& image) : Image2D(image) { }
2674      Image2DGL& operator = (const cl_mem& rhs)
2675      {
2676          Image2D::operator=(rhs);
2677          return *this;
2678      }
2679      Image2DGL(const Image2DGL& img) : Image2D(img) {}
2680      Image2DGL& operator = (const Image2DGL &img)
2681      {
2682          Image2D::operator=(img);
2683          return *this;
2684      }
2685  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2686      Image2DGL(Image2DGL&& img) CL_HPP_NOEXCEPT : Image2D(std::move(img)) {}
2687      Image2DGL& operator = (Image2DGL &&img)
2688      {
2689          Image2D::operator=(std::move(img));
2690          return *this;
2691      }
2692  #endif 
2693  };
2694  #endif 
2695  #if defined(CL_VERSION_1_2)
2696  class Image2DArray : public Image
2697  {
2698  public:
2699      Image2DArray(
2700          const Context& context,
2701          cl_mem_flags flags,
2702          ImageFormat format,
2703          ::size_t arraySize,
2704          ::size_t width,
2705          ::size_t height,
2706          ::size_t rowPitch,
2707          ::size_t slicePitch,
2708          void* host_ptr = NULL,
2709          cl_int* err = NULL)
2710      {
2711          cl_int error;
2712          cl_image_desc desc =
2713          {
2714              CL_MEM_OBJECT_IMAGE2D_ARRAY,
2715              width,
2716              height,
2717              0,       
2718              arraySize,
2719              rowPitch,
2720              slicePitch,
2721              0, 0, 0
2722          };
2723          object_ = ::clCreateImage(
2724              context(), 
2725              flags, 
2726              &format, 
2727              &desc, 
2728              host_ptr, 
2729              &error);
2730          detail::errHandler(error, __CREATE_IMAGE_ERR);
2731          if (err != NULL) {
2732              *err = error;
2733          }
2734      }
2735      Image2DArray() { }
2736      __CL_EXPLICIT_CONSTRUCTORS Image2DArray(const cl_mem& imageArray) : Image(imageArray) { }
2737      Image2DArray& operator = (const cl_mem& rhs)
2738      {
2739          Image::operator=(rhs);
2740          return *this;
2741      }
2742      Image2DArray(const Image2DArray& img) : Image(img) {}
2743      Image2DArray& operator = (const Image2DArray &img)
2744      {
2745          Image::operator=(img);
2746          return *this;
2747      }
2748  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2749      Image2DArray(Image2DArray&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2750      Image2DArray& operator = (Image2DArray &&img)
2751      {
2752          Image::operator=(std::move(img));
2753          return *this;
2754      }
2755  #endif 
2756  };
2757  #endif 
2758  class Image3D : public Image
2759  {
2760  public:
2761      Image3D(
2762          const Context& context,
2763          cl_mem_flags flags,
2764          ImageFormat format,
2765          ::size_t width,
2766          ::size_t height,
2767          ::size_t depth,
2768          ::size_t row_pitch = 0,
2769          ::size_t slice_pitch = 0,
2770          void* host_ptr = NULL,
2771          cl_int* err = NULL)
2772      {
2773          cl_int error;
2774          bool useCreateImage;
2775  #if defined(CL_VERSION_1_2) && defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2776          {
2777              cl_uint version = detail::getContextPlatformVersion(context());
2778              useCreateImage = (version >= 0x10002); 
2779          }
2780  #elif defined(CL_VERSION_1_2)
2781          useCreateImage = true;
2782  #else
2783          useCreateImage = false;
2784  #endif
2785  #if defined(CL_VERSION_1_2)
2786          if (useCreateImage)
2787          {
2788              cl_image_desc desc =
2789              {
2790                  CL_MEM_OBJECT_IMAGE3D,
2791                  width,
2792                  height,
2793                  depth,
2794                  0,      
2795                  row_pitch,
2796                  slice_pitch,
2797                  0, 0, 0
2798              };
2799              object_ = ::clCreateImage(
2800                  context(), 
2801                  flags, 
2802                  &format, 
2803                  &desc, 
2804                  host_ptr, 
2805                  &error);
2806              detail::errHandler(error, __CREATE_IMAGE_ERR);
2807              if (err != NULL) {
2808                  *err = error;
2809              }
2810          }
2811  #endif  
2812  #if !defined(CL_VERSION_1_2) || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2813          if (!useCreateImage)
2814          {
2815              object_ = ::clCreateImage3D(
2816                  context(), flags, &format, width, height, depth, row_pitch,
2817                  slice_pitch, host_ptr, &error);
2818              detail::errHandler(error, __CREATE_IMAGE3D_ERR);
2819              if (err != NULL) {
2820                  *err = error;
2821              }
2822          }
2823  #endif 
2824      }
2825      Image3D() : Image() { }
2826      __CL_EXPLICIT_CONSTRUCTORS Image3D(const cl_mem& image3D) : Image(image3D) { }
2827      Image3D& operator = (const cl_mem& rhs)
2828      {
2829          Image::operator=(rhs);
2830          return *this;
2831      }
2832      Image3D(const Image3D& img) : Image(img) {}
2833      Image3D& operator = (const Image3D &img)
2834      {
2835          Image::operator=(img);
2836          return *this;
2837      }
2838  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2839      Image3D(Image3D&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2840      Image3D& operator = (Image3D &&img)
2841      {
2842          Image::operator=(std::move(img));
2843          return *this;
2844      }
2845  #endif 
2846  };
2847  #if !defined(CL_VERSION_1_2)
2848  class Image3DGL : public Image3D
2849  {
2850  public:
2851      Image3DGL(
2852          const Context& context,
2853          cl_mem_flags flags,
2854          cl_GLenum target,
2855          cl_GLint  miplevel,
2856          cl_GLuint texobj,
2857          cl_int * err = NULL)
2858      {
2859          cl_int error;
2860          object_ = ::clCreateFromGLTexture3D(
2861              context(),
2862              flags,
2863              target,
2864              miplevel,
2865              texobj,
2866              &error);
2867          detail::errHandler(error, __CREATE_GL_TEXTURE_3D_ERR);
2868          if (err != NULL) {
2869              *err = error;
2870          }
2871      }
2872      Image3DGL() : Image3D() { }
2873      __CL_EXPLICIT_CONSTRUCTORS Image3DGL(const cl_mem& image) : Image3D(image) { }
2874      Image3DGL& operator = (const cl_mem& rhs)
2875      {
2876          Image3D::operator=(rhs);
2877          return *this;
2878      }
2879      Image3DGL(const Image3DGL& img) : Image3D(img) {}
2880      Image3DGL& operator = (const Image3DGL &img)
2881      {
2882          Image3D::operator=(img);
2883          return *this;
2884      }
2885  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2886      Image3DGL(Image3DGL&& img) CL_HPP_NOEXCEPT : Image3D(std::move(img)) {}
2887      Image3DGL& operator = (Image3DGL &&img)
2888      {
2889          Image3D::operator=(std::move(img));
2890          return *this;
2891      }
2892  #endif 
2893  };
2894  #endif 
2895  #if defined(CL_VERSION_1_2)
2896  class ImageGL : public Image
2897  {
2898  public:
2899      ImageGL(
2900          const Context& context,
2901          cl_mem_flags flags,
2902          cl_GLenum target,
2903          cl_GLint  miplevel,
2904          cl_GLuint texobj,
2905          cl_int * err = NULL)
2906      {
2907          cl_int error;
2908          object_ = ::clCreateFromGLTexture(
2909              context(), 
2910              flags, 
2911              target,
2912              miplevel,
2913              texobj,
2914              &error);
2915          detail::errHandler(error, __CREATE_GL_TEXTURE_ERR);
2916          if (err != NULL) {
2917              *err = error;
2918          }
2919      }
2920      ImageGL() : Image() { }
2921      __CL_EXPLICIT_CONSTRUCTORS ImageGL(const cl_mem& image) : Image(image) { }
2922      ImageGL& operator = (const cl_mem& rhs)
2923      {
2924          Image::operator=(rhs);
2925          return *this;
2926      }
2927      ImageGL(const ImageGL& img) : Image(img) {}
2928      ImageGL& operator = (const ImageGL &img)
2929      {
2930          Image::operator=(img);
2931          return *this;
2932      }
2933  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2934      ImageGL(ImageGL&& img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2935      ImageGL& operator = (ImageGL &&img)
2936      {
2937          Image::operator=(std::move(img));
2938          return *this;
2939      }
2940  #endif 
2941  };
2942  #endif 
2943  class BufferRenderGL : 
2944  #if defined(CL_VERSION_1_2)
2945      public ImageGL
2946  #else 
2947      public Image2DGL
2948  #endif 
2949  {
2950  public:
2951      BufferRenderGL(
2952          const Context& context,
2953          cl_mem_flags flags,
2954          cl_GLuint bufobj,
2955          cl_int * err = NULL)
2956      {
2957          cl_int error;
2958          object_ = ::clCreateFromGLRenderbuffer(
2959              context(),
2960              flags,
2961              bufobj,
2962              &error);
2963          detail::errHandler(error, __CREATE_GL_RENDER_BUFFER_ERR);
2964          if (err != NULL) {
2965              *err = error;
2966          }
2967      }
2968  #if defined(CL_VERSION_1_2)
2969      BufferRenderGL() : ImageGL() {};
2970  #else 
2971      BufferRenderGL() : Image2DGL() {};
2972  #endif 
2973  #if defined(CL_VERSION_1_2)
2974      __CL_EXPLICIT_CONSTRUCTORS BufferRenderGL(const cl_mem& buffer) : ImageGL(buffer) { }
2975  #else 
2976      __CL_EXPLICIT_CONSTRUCTORS BufferRenderGL(const cl_mem& buffer) : Image2DGL(buffer) { }
2977  #endif 
2978      BufferRenderGL& operator = (const cl_mem& rhs)
2979      {
2980  #if defined(CL_VERSION_1_2)
2981          ImageGL::operator=(rhs);
2982  #else 
2983          Image2DGL::operator=(rhs);
2984  #endif 
2985          return *this;
2986      }
2987  #if defined(CL_VERSION_1_2)
2988      BufferRenderGL(const BufferRenderGL& buf) : ImageGL(buf) {}
2989  #else 
2990      BufferRenderGL(const BufferRenderGL& buf) : Image2DGL(buf) {}
2991  #endif 
2992      BufferRenderGL& operator = (const BufferRenderGL &rhs)
2993      {
2994  #if defined(CL_VERSION_1_2)
2995          ImageGL::operator=(rhs);
2996  #else 
2997          Image2DGL::operator=(rhs);
2998  #endif 
2999          return *this;
3000      }
3001  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3002  #if defined(CL_VERSION_1_2)
3003      BufferRenderGL(BufferRenderGL&& buf) CL_HPP_NOEXCEPT : ImageGL(std::move(buf)) {}
3004  #else 
3005      BufferRenderGL(BufferRenderGL&& buf) CL_HPP_NOEXCEPT : Image2DGL(std::move(buf)) {}
3006  #endif 
3007      BufferRenderGL& operator = (BufferRenderGL &&buf)
3008      {
3009  #if defined(CL_VERSION_1_2)
3010          ImageGL::operator=(std::move(buf));
3011  #else 
3012          Image2DGL::operator=(std::move(buf));
3013  #endif 
3014          return *this;
3015      }
3016  #endif 
3017      cl_int getObjectInfo(
3018          cl_gl_object_type *type,
3019          cl_GLuint * gl_object_name)
3020      {
3021          return detail::errHandler(
3022              ::clGetGLObjectInfo(object_, type, gl_object_name),
3023              __GET_GL_OBJECT_INFO_ERR);
3024      }
3025  };
3026  class Sampler : public detail::Wrapper<cl_sampler>
3027  {
3028  public:
3029      Sampler() { }
3030      Sampler(
3031          const Context& context,
3032          cl_bool normalized_coords,
3033          cl_addressing_mode addressing_mode,
3034          cl_filter_mode filter_mode,
3035          cl_int* err = NULL)
3036      {
3037          cl_int error;
3038          object_ = ::clCreateSampler(
3039              context(), 
3040              normalized_coords,
3041              addressing_mode,
3042              filter_mode,
3043              &error);
3044          detail::errHandler(error, __CREATE_SAMPLER_ERR);
3045          if (err != NULL) {
3046              *err = error;
3047          }
3048      }
3049      __CL_EXPLICIT_CONSTRUCTORS Sampler(const cl_sampler& sampler) : detail::Wrapper<cl_type>(sampler) { }
3050      Sampler& operator = (const cl_sampler& rhs)
3051      {
3052          detail::Wrapper<cl_type>::operator=(rhs);
3053          return *this;
3054      }
3055      Sampler(const Sampler& sam) : detail::Wrapper<cl_type>(sam) {}
3056      Sampler& operator = (const Sampler &sam)
3057      {
3058          detail::Wrapper<cl_type>::operator=(sam);
3059          return *this;
3060      }
3061  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3062      Sampler(Sampler&& sam) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(sam)) {}
3063      Sampler& operator = (Sampler &&sam)
3064      {
3065          detail::Wrapper<cl_type>::operator=(std::move(sam));
3066          return *this;
3067      }
3068  #endif 
3069      template <typename T>
3070      cl_int getInfo(cl_sampler_info name, T* param) const
3071      {
3072          return detail::errHandler(
3073              detail::getInfo(&::clGetSamplerInfo, object_, name, param),
3074              __GET_SAMPLER_INFO_ERR);
3075      }
3076      template <cl_int name> typename
3077      detail::param_traits<detail::cl_sampler_info, name>::param_type
3078      getInfo(cl_int* err = NULL) const
3079      {
3080          typename detail::param_traits<
3081              detail::cl_sampler_info, name>::param_type param;
3082          cl_int result = getInfo(name, &param);
3083          if (err != NULL) {
3084              *err = result;
3085          }
3086          return param;
3087      }
3088  };
3089  class Program;
3090  class CommandQueue;
3091  class Kernel;
3092  class NDRange
3093  {
3094  private:
3095      size_t<3> sizes_;
3096      cl_uint dimensions_;
3097  public:
3098      NDRange()
3099          : dimensions_(0)
3100      { }
3101      NDRange(::size_t size0)
3102          : dimensions_(1)
3103      {
3104          sizes_[0] = size0;
3105      }
3106      NDRange(::size_t size0, ::size_t size1)
3107          : dimensions_(2)
3108      {
3109          sizes_[0] = size0;
3110          sizes_[1] = size1;
3111      }
3112      NDRange(::size_t size0, ::size_t size1, ::size_t size2)
3113          : dimensions_(3)
3114      {
3115          sizes_[0] = size0;
3116          sizes_[1] = size1;
3117          sizes_[2] = size2;
3118      }
3119      operator const ::size_t*() const { 
3120          return (const ::size_t*) sizes_; 
3121      }
3122      ::size_t dimensions() const { return dimensions_; }
3123  };
3124  static const NDRange NullRange;
3125  struct LocalSpaceArg
3126  {
3127      ::size_t size_;
3128  };
3129  namespace detail {
3130  template <typename T>
3131  struct KernelArgumentHandler
3132  {
3133      static ::size_t size(const T&) { return sizeof(T); }
3134      static const T* ptr(const T& value) { return &value; }
3135  };
3136  template <>
3137  struct KernelArgumentHandler<LocalSpaceArg>
3138  {
3139      static ::size_t size(const LocalSpaceArg& value) { return value.size_; }
3140      static const void* ptr(const LocalSpaceArg&) { return NULL; }
3141  };
3142  } 
3143  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED LocalSpaceArg
3144  __local(::size_t size) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
3145  inline LocalSpaceArg
3146  __local(::size_t size)
3147  {
3148      LocalSpaceArg ret = { size };
3149      return ret;
3150  }
3151  inline LocalSpaceArg
3152  Local(::size_t size)
3153  {
3154      LocalSpaceArg ret = { size };
3155      return ret;
3156  }
3157  class Kernel : public detail::Wrapper<cl_kernel>
3158  {
3159  public:
3160      inline Kernel(const Program& program, const char* name, cl_int* err = NULL);
3161      Kernel() { }
3162      __CL_EXPLICIT_CONSTRUCTORS Kernel(const cl_kernel& kernel) : detail::Wrapper<cl_type>(kernel) { }
3163      Kernel& operator = (const cl_kernel& rhs)
3164      {
3165          detail::Wrapper<cl_type>::operator=(rhs);
3166          return *this;
3167      }
3168      Kernel(const Kernel& kernel) : detail::Wrapper<cl_type>(kernel) {}
3169      Kernel& operator = (const Kernel &kernel)
3170      {
3171          detail::Wrapper<cl_type>::operator=(kernel);
3172          return *this;
3173      }
3174  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3175      Kernel(Kernel&& kernel) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(kernel)) {}
3176      Kernel& operator = (Kernel &&kernel)
3177      {
3178          detail::Wrapper<cl_type>::operator=(std::move(kernel));
3179          return *this;
3180      }
3181  #endif 
3182      template <typename T>
3183      cl_int getInfo(cl_kernel_info name, T* param) const
3184      {
3185          return detail::errHandler(
3186              detail::getInfo(&::clGetKernelInfo, object_, name, param),
3187              __GET_KERNEL_INFO_ERR);
3188      }
3189      template <cl_int name> typename
3190      detail::param_traits<detail::cl_kernel_info, name>::param_type
3191      getInfo(cl_int* err = NULL) const
3192      {
3193          typename detail::param_traits<
3194              detail::cl_kernel_info, name>::param_type param;
3195          cl_int result = getInfo(name, &param);
3196          if (err != NULL) {
3197              *err = result;
3198          }
3199          return param;
3200      }
3201  #if defined(CL_VERSION_1_2)
3202      template <typename T>
3203      cl_int getArgInfo(cl_uint argIndex, cl_kernel_arg_info name, T* param) const
3204      {
3205          return detail::errHandler(
3206              detail::getInfo(&::clGetKernelArgInfo, object_, argIndex, name, param),
3207              __GET_KERNEL_ARG_INFO_ERR);
3208      }
3209      template <cl_int name> typename
3210      detail::param_traits<detail::cl_kernel_arg_info, name>::param_type
3211      getArgInfo(cl_uint argIndex, cl_int* err = NULL) const
3212      {
3213          typename detail::param_traits<
3214              detail::cl_kernel_arg_info, name>::param_type param;
3215          cl_int result = getArgInfo(argIndex, name, &param);
3216          if (err != NULL) {
3217              *err = result;
3218          }
3219          return param;
3220      }
3221  #endif 
3222      template <typename T>
3223      cl_int getWorkGroupInfo(
3224          const Device& device, cl_kernel_work_group_info name, T* param) const
3225      {
3226          return detail::errHandler(
3227              detail::getInfo(
3228                  &::clGetKernelWorkGroupInfo, object_, device(), name, param),
3229                  __GET_KERNEL_WORK_GROUP_INFO_ERR);
3230      }
3231      template <cl_int name> typename
3232      detail::param_traits<detail::cl_kernel_work_group_info, name>::param_type
3233          getWorkGroupInfo(const Device& device, cl_int* err = NULL) const
3234      {
3235          typename detail::param_traits<
3236          detail::cl_kernel_work_group_info, name>::param_type param;
3237          cl_int result = getWorkGroupInfo(device, name, &param);
3238          if (err != NULL) {
3239              *err = result;
3240          }
3241          return param;
3242      }
3243      template <typename T>
3244      cl_int setArg(cl_uint index, const T &value)
3245      {
3246          return detail::errHandler(
3247              ::clSetKernelArg(
3248                  object_,
3249                  index,
3250                  detail::KernelArgumentHandler<T>::size(value),
3251                  detail::KernelArgumentHandler<T>::ptr(value)),
3252              __SET_KERNEL_ARGS_ERR);
3253      }
3254      cl_int setArg(cl_uint index, ::size_t size, const void* argPtr)
3255      {
3256          return detail::errHandler(
3257              ::clSetKernelArg(object_, index, size, argPtr),
3258              __SET_KERNEL_ARGS_ERR);
3259      }
3260  };
3261  class Program : public detail::Wrapper<cl_program>
3262  {
3263  public:
3264      typedef VECTOR_CLASS<std::pair<const void*, ::size_t> > Binaries;
3265      typedef VECTOR_CLASS<std::pair<const char*, ::size_t> > Sources;
3266      Program(
3267          const STRING_CLASS& source,
3268          bool build = false,
3269          cl_int* err = NULL)
3270      {
3271          cl_int error;
3272          const char * strings = source.c_str();
3273          const ::size_t length  = source.size();
3274          Context context = Context::getDefault(err);
3275          object_ = ::clCreateProgramWithSource(
3276              context(), (cl_uint)1, &strings, &length, &error);
3277          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3278          if (error == CL_SUCCESS && build) {
3279              error = ::clBuildProgram(
3280                  object_,
3281                  0,
3282                  NULL,
3283                  "",
3284                  NULL,
3285                  NULL);
3286              detail::errHandler(error, __BUILD_PROGRAM_ERR);
3287          }
3288          if (err != NULL) {
3289              *err = error;
3290          }
3291      }
3292      Program(
3293          const Context& context,
3294          const STRING_CLASS& source,
3295          bool build = false,
3296          cl_int* err = NULL)
3297      {
3298          cl_int error;
3299          const char * strings = source.c_str();
3300          const ::size_t length  = source.size();
3301          object_ = ::clCreateProgramWithSource(
3302              context(), (cl_uint)1, &strings, &length, &error);
3303          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3304          if (error == CL_SUCCESS && build) {
3305              error = ::clBuildProgram(
3306                  object_,
3307                  0,
3308                  NULL,
3309                  "",
3310                  NULL,
3311                  NULL);
3312              detail::errHandler(error, __BUILD_PROGRAM_ERR);
3313          }
3314          if (err != NULL) {
3315              *err = error;
3316          }
3317      }
3318      Program(
3319          const Context& context,
3320          const Sources& sources,
3321          cl_int* err = NULL)
3322      {
3323          cl_int error;
3324          const ::size_t n = (::size_t)sources.size();
3325          ::size_t* lengths = (::size_t*) alloca(n * sizeof(::size_t));
3326          const char** strings = (const char**) alloca(n * sizeof(const char*));
3327          for (::size_t i = 0; i < n; ++i) {
3328              strings[i] = sources[(int)i].first;
3329              lengths[i] = sources[(int)i].second;
3330          }
3331          object_ = ::clCreateProgramWithSource(
3332              context(), (cl_uint)n, strings, lengths, &error);
3333          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3334          if (err != NULL) {
3335              *err = error;
3336          }
3337      }
3338      Program(
3339          const Context& context,
3340          const VECTOR_CLASS<Device>& devices,
3341          const Binaries& binaries,
3342          VECTOR_CLASS<cl_int>* binaryStatus = NULL,
3343          cl_int* err = NULL)
3344      {
3345          cl_int error;
3346          const ::size_t numDevices = devices.size();
3347          if(binaries.size() != numDevices) {
3348              error = CL_INVALID_VALUE;
3349              detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3350              if (err != NULL) {
3351                  *err = error;
3352              }
3353              return;
3354          }
3355          ::size_t* lengths = (::size_t*) alloca(numDevices * sizeof(::size_t));
3356          const unsigned char** images = (const unsigned char**) alloca(numDevices * sizeof(const unsigned char**));
3357          for (::size_t i = 0; i < numDevices; ++i) {
3358              images[i] = (const unsigned char*)binaries[i].first;
3359              lengths[i] = binaries[(int)i].second;
3360          }
3361          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
3362          for( ::size_t deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3363              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3364          }
3365          if(binaryStatus) {
3366              binaryStatus->resize(numDevices);
3367          }
3368          object_ = ::clCreateProgramWithBinary(
3369              context(), (cl_uint) devices.size(),
3370              deviceIDs,
3371              lengths, images, (binaryStatus != NULL && numDevices > 0)
3372                 ? &binaryStatus->front()
3373                 : NULL, &error);
3374          detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3375          if (err != NULL) {
3376              *err = error;
3377          }
3378      }
3379  #if defined(CL_VERSION_1_2)
3380      Program(
3381          const Context& context,
3382          const VECTOR_CLASS<Device>& devices,
3383          const STRING_CLASS& kernelNames,
3384          cl_int* err = NULL)
3385      {
3386          cl_int error;
3387          ::size_t numDevices = devices.size();
3388          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
3389          for( ::size_t deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3390              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3391          }
3392          object_ = ::clCreateProgramWithBuiltInKernels(
3393              context(), 
3394              (cl_uint) devices.size(),
3395              deviceIDs,
3396              kernelNames.c_str(), 
3397              &error);
3398          detail::errHandler(error, __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR);
3399          if (err != NULL) {
3400              *err = error;
3401          }
3402      }
3403  #endif 
3404      Program() { }
3405      __CL_EXPLICIT_CONSTRUCTORS Program(const cl_program& program) : detail::Wrapper<cl_type>(program) { }
3406      Program& operator = (const cl_program& rhs)
3407      {
3408          detail::Wrapper<cl_type>::operator=(rhs);
3409          return *this;
3410      }
3411      Program(const Program& program) : detail::Wrapper<cl_type>(program) {}
3412      Program& operator = (const Program &program)
3413      {
3414          detail::Wrapper<cl_type>::operator=(program);
3415          return *this;
3416      }
3417  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3418      Program(Program&& program) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(program)) {}
3419      Program& operator = (Program &&program)
3420      {
3421          detail::Wrapper<cl_type>::operator=(std::move(program));
3422          return *this;
3423      }
3424  #endif 
3425      cl_int build(
3426          const VECTOR_CLASS<Device>& devices,
3427          const char* options = NULL,
3428          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3429          void* data = NULL) const
3430      {
3431          ::size_t numDevices = devices.size();
3432          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
3433          for( ::size_t deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3434              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3435          }
3436          return detail::errHandler(
3437              ::clBuildProgram(
3438                  object_,
3439                  (cl_uint)
3440                  devices.size(),
3441                  deviceIDs,
3442                  options,
3443                  notifyFptr,
3444                  data),
3445                  __BUILD_PROGRAM_ERR);
3446      }
3447      cl_int build(
3448          const char* options = NULL,
3449          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3450          void* data = NULL) const
3451      {
3452          return detail::errHandler(
3453              ::clBuildProgram(
3454                  object_,
3455                  0,
3456                  NULL,
3457                  options,
3458                  notifyFptr,
3459                  data),
3460                  __BUILD_PROGRAM_ERR);
3461      }
3462  #if defined(CL_VERSION_1_2)
3463      cl_int compile(
3464          const char* options = NULL,
3465          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3466          void* data = NULL) const
3467      {
3468          return detail::errHandler(
3469              ::clCompileProgram(
3470                  object_,
3471                  0,
3472                  NULL,
3473                  options,
3474                  0,
3475                  NULL,
3476                  NULL,
3477                  notifyFptr,
3478                  data),
3479                  __COMPILE_PROGRAM_ERR);
3480      }
3481  #endif
3482      template <typename T>
3483      cl_int getInfo(cl_program_info name, T* param) const
3484      {
3485          return detail::errHandler(
3486              detail::getInfo(&::clGetProgramInfo, object_, name, param),
3487              __GET_PROGRAM_INFO_ERR);
3488      }
3489      template <cl_int name> typename
3490      detail::param_traits<detail::cl_program_info, name>::param_type
3491      getInfo(cl_int* err = NULL) const
3492      {
3493          typename detail::param_traits<
3494              detail::cl_program_info, name>::param_type param;
3495          cl_int result = getInfo(name, &param);
3496          if (err != NULL) {
3497              *err = result;
3498          }
3499          return param;
3500      }
3501      template <typename T>
3502      cl_int getBuildInfo(
3503          const Device& device, cl_program_build_info name, T* param) const
3504      {
3505          return detail::errHandler(
3506              detail::getInfo(
3507                  &::clGetProgramBuildInfo, object_, device(), name, param),
3508                  __GET_PROGRAM_BUILD_INFO_ERR);
3509      }
3510      template <cl_int name> typename
3511      detail::param_traits<detail::cl_program_build_info, name>::param_type
3512      getBuildInfo(const Device& device, cl_int* err = NULL) const
3513      {
3514          typename detail::param_traits<
3515              detail::cl_program_build_info, name>::param_type param;
3516          cl_int result = getBuildInfo(device, name, &param);
3517          if (err != NULL) {
3518              *err = result;
3519          }
3520          return param;
3521      }
3522      cl_int createKernels(VECTOR_CLASS<Kernel>* kernels)
3523      {
3524          cl_uint numKernels;
3525          cl_int err = ::clCreateKernelsInProgram(object_, 0, NULL, &numKernels);
3526          if (err != CL_SUCCESS) {
3527              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
3528          }
3529          Kernel* value = (Kernel*) alloca(numKernels * sizeof(Kernel));
3530          err = ::clCreateKernelsInProgram(
3531              object_, numKernels, (cl_kernel*) value, NULL);
3532          if (err != CL_SUCCESS) {
3533              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
3534          }
3535          kernels->assign(&value[0], &value[numKernels]);
3536          return CL_SUCCESS;
3537      }
3538  };
3539  #if defined(CL_VERSION_1_2)
3540  inline Program linkProgram(
3541      Program input1,
3542      Program input2,
3543      const char* options = NULL,
3544      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3545      void* data = NULL,
3546      cl_int* err = NULL) 
3547  {
3548      cl_int error_local = CL_SUCCESS;
3549      cl_program programs[2] = { input1(), input2() };
3550      Context ctx = input1.getInfo<CL_PROGRAM_CONTEXT>(&error_local);
3551      if(error_local!=CL_SUCCESS) {
3552          detail::errHandler(error_local, __LINK_PROGRAM_ERR);
3553      }
3554      cl_program prog = ::clLinkProgram(
3555          ctx(),
3556          0,
3557          NULL,
3558          options,
3559          2,
3560          programs,
3561          notifyFptr,
3562          data,
3563          &error_local);
3564      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
3565      if (err != NULL) {
3566          *err = error_local;
3567      }
3568      return Program(prog);
3569  }
3570  inline Program linkProgram(
3571      VECTOR_CLASS<Program> inputPrograms,
3572      const char* options = NULL,
3573      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3574      void* data = NULL,
3575      cl_int* err = NULL) 
3576  {
3577      cl_int error_local = CL_SUCCESS;
3578      cl_program * programs = (cl_program*) alloca(inputPrograms.size() * sizeof(cl_program));
3579      if (programs != NULL) {
3580          for (unsigned int i = 0; i < inputPrograms.size(); i++) {
3581            programs[i] = inputPrograms[i]();
3582          }
3583      } 
3584      Context ctx;
3585      if(inputPrograms.size() > 0) {
3586          ctx = inputPrograms[0].getInfo<CL_PROGRAM_CONTEXT>(&error_local);
3587          if(error_local!=CL_SUCCESS) {
3588              detail::errHandler(error_local, __LINK_PROGRAM_ERR);
3589          }
3590      }
3591      cl_program prog = ::clLinkProgram(
3592          ctx(),
3593          0,
3594          NULL,
3595          options,
3596          (cl_uint)inputPrograms.size(),
3597          programs,
3598          notifyFptr,
3599          data,
3600          &error_local);
3601      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
3602      if (err != NULL) {
3603          *err = error_local;
3604      }
3605      return Program(prog);
3606  }
3607  #endif
3608  template<>
3609  inline VECTOR_CLASS<char *> cl::Program::getInfo<CL_PROGRAM_BINARIES>(cl_int* err) const
3610  {
3611      VECTOR_CLASS< ::size_t> sizes = getInfo<CL_PROGRAM_BINARY_SIZES>();
3612      VECTOR_CLASS<char *> binaries;
3613      for (VECTOR_CLASS< ::size_t>::iterator s = sizes.begin(); s != sizes.end(); ++s) 
3614      {
3615          char *ptr = NULL;
3616          if (*s != 0) 
3617              ptr = new char[*s];
3618          binaries.push_back(ptr);
3619      }
3620      cl_int result = getInfo(CL_PROGRAM_BINARIES, &binaries);
3621      if (err != NULL) {
3622          *err = result;
3623      }
3624      return binaries;
3625  }
3626  inline Kernel::Kernel(const Program& program, const char* name, cl_int* err)
3627  {
3628      cl_int error;
3629      object_ = ::clCreateKernel(program(), name, &error);
3630      detail::errHandler(error, __CREATE_KERNEL_ERR);
3631      if (err != NULL) {
3632          *err = error;
3633      }
3634  }
3635  class CommandQueue : public detail::Wrapper<cl_command_queue>
3636  {
3637  private:
3638  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
3639      static std::atomic<int> default_initialized_;
3640  #else 
3641      static volatile int default_initialized_;
3642  #endif 
3643      static CommandQueue default_;
3644      static volatile cl_int default_error_;
3645  public:
3646     CommandQueue(
3647          cl_command_queue_properties properties,
3648          cl_int* err = NULL)
3649      {
3650          cl_int error;
3651          Context context = Context::getDefault(&error);
3652          detail::errHandler(error, __CREATE_CONTEXT_ERR);
3653          if (error != CL_SUCCESS) {
3654              if (err != NULL) {
3655                  *err = error;
3656              }
3657          }
3658          else {
3659              Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
3660              object_ = ::clCreateCommandQueue(
3661                  context(), device(), properties, &error);
3662              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3663              if (err != NULL) {
3664                  *err = error;
3665              }
3666          }
3667      }
3668      explicit CommandQueue(
3669          const Context& context,
3670          cl_command_queue_properties properties = 0,
3671          cl_int* err = NULL)
3672      {
3673          cl_int error;
3674          VECTOR_CLASS<cl::Device> devices;
3675          error = context.getInfo(CL_CONTEXT_DEVICES, &devices);
3676          detail::errHandler(error, __CREATE_CONTEXT_ERR);
3677          if (error != CL_SUCCESS)
3678          {
3679              if (err != NULL) {
3680                  *err = error;
3681              }
3682              return;
3683          }
3684          object_ = ::clCreateCommandQueue(context(), devices[0](), properties, &error);
3685          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3686          if (err != NULL) {
3687              *err = error;
3688          }
3689      }
3690      CommandQueue(
3691          const Context& context,
3692          const Device& device,
3693          cl_command_queue_properties properties = 0,
3694          cl_int* err = NULL)
3695      {
3696          cl_int error;
3697          object_ = ::clCreateCommandQueue(
3698              context(), device(), properties, &error);
3699          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3700          if (err != NULL) {
3701              *err = error;
3702          }
3703      }
3704      CommandQueue(const CommandQueue& queue) : detail::Wrapper<cl_type>(queue) {}
3705      CommandQueue& operator = (const CommandQueue &queue)
3706      {
3707          detail::Wrapper<cl_type>::operator=(queue);
3708          return *this;
3709      }
3710  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3711      CommandQueue(CommandQueue&& queue) CL_HPP_NOEXCEPT : detail::Wrapper<cl_type>(std::move(queue)) {}
3712      CommandQueue& operator = (CommandQueue &&queue)
3713      {
3714          detail::Wrapper<cl_type>::operator=(std::move(queue));
3715          return *this;
3716      }
3717  #endif 
3718      static CommandQueue getDefault(cl_int * err = NULL) 
3719      {
3720          int state = detail::compare_exchange(
3721              &default_initialized_, 
3722              __DEFAULT_BEING_INITIALIZED, __DEFAULT_NOT_INITIALIZED);
3723          if (state & __DEFAULT_INITIALIZED) {
3724              if (err != NULL) {
3725                  *err = default_error_;
3726              }
3727              return default_;
3728          }
3729          if (state & __DEFAULT_BEING_INITIALIZED) {
3730                while(default_initialized_ != __DEFAULT_INITIALIZED) {
3731                    detail::fence();
3732                }
3733              if (err != NULL) {
3734                  *err = default_error_;
3735              }
3736              return default_;
3737          }
3738          cl_int error;
3739          Context context = Context::getDefault(&error);
3740          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3741          if (error != CL_SUCCESS) {
3742              if (err != NULL) {
3743                  *err = error;
3744              }
3745          }
3746          else {
3747              Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
3748              default_ = CommandQueue(context, device, 0, &error);
3749              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3750              if (err != NULL) {
3751                  *err = error;
3752              }
3753          }
3754          detail::fence();
3755          default_error_ = error;
3756          default_initialized_ = __DEFAULT_INITIALIZED;
3757          detail::fence();
3758          if (err != NULL) {
3759              *err = default_error_;
3760          }
3761          return default_;
3762      }
3763      CommandQueue() { }
3764      __CL_EXPLICIT_CONSTRUCTORS CommandQueue(const cl_command_queue& commandQueue) : detail::Wrapper<cl_type>(commandQueue) { }
3765      CommandQueue& operator = (const cl_command_queue& rhs)
3766      {
3767          detail::Wrapper<cl_type>::operator=(rhs);
3768          return *this;
3769      }
3770      template <typename T>
3771      cl_int getInfo(cl_command_queue_info name, T* param) const
3772      {
3773          return detail::errHandler(
3774              detail::getInfo(
3775                  &::clGetCommandQueueInfo, object_, name, param),
3776                  __GET_COMMAND_QUEUE_INFO_ERR);
3777      }
3778      template <cl_int name> typename
3779      detail::param_traits<detail::cl_command_queue_info, name>::param_type
3780      getInfo(cl_int* err = NULL) const
3781      {
3782          typename detail::param_traits<
3783              detail::cl_command_queue_info, name>::param_type param;
3784          cl_int result = getInfo(name, &param);
3785          if (err != NULL) {
3786              *err = result;
3787          }
3788          return param;
3789      }
3790      cl_int enqueueReadBuffer(
3791          const Buffer& buffer,
3792          cl_bool blocking,
3793          ::size_t offset,
3794          ::size_t size,
3795          void* ptr,
3796          const VECTOR_CLASS<Event>* events = NULL,
3797          Event* event = NULL) const
3798      {
3799          cl_event tmp;
3800          cl_int err = detail::errHandler(
3801              ::clEnqueueReadBuffer(
3802                  object_, buffer(), blocking, offset, size,
3803                  ptr,
3804                  (events != NULL) ? (cl_uint) events->size() : 0,
3805                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3806                  (event != NULL) ? &tmp : NULL),
3807              __ENQUEUE_READ_BUFFER_ERR);
3808          if (event != NULL && err == CL_SUCCESS)
3809              *event = tmp;
3810          return err;
3811      }
3812      cl_int enqueueWriteBuffer(
3813          const Buffer& buffer,
3814          cl_bool blocking,
3815          ::size_t offset,
3816          ::size_t size,
3817          const void* ptr,
3818          const VECTOR_CLASS<Event>* events = NULL,
3819          Event* event = NULL) const
3820      {
3821          cl_event tmp;
3822          cl_int err = detail::errHandler(
3823              ::clEnqueueWriteBuffer(
3824                  object_, buffer(), blocking, offset, size,
3825                  ptr,
3826                  (events != NULL) ? (cl_uint) events->size() : 0,
3827                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3828                  (event != NULL) ? &tmp : NULL),
3829                  __ENQUEUE_WRITE_BUFFER_ERR);
3830          if (event != NULL && err == CL_SUCCESS)
3831              *event = tmp;
3832          return err;
3833      }
3834      cl_int enqueueCopyBuffer(
3835          const Buffer& src,
3836          const Buffer& dst,
3837          ::size_t src_offset,
3838          ::size_t dst_offset,
3839          ::size_t size,
3840          const VECTOR_CLASS<Event>* events = NULL,
3841          Event* event = NULL) const
3842      {
3843          cl_event tmp;
3844          cl_int err = detail::errHandler(
3845              ::clEnqueueCopyBuffer(
3846                  object_, src(), dst(), src_offset, dst_offset, size,
3847                  (events != NULL) ? (cl_uint) events->size() : 0,
3848                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3849                  (event != NULL) ? &tmp : NULL),
3850              __ENQEUE_COPY_BUFFER_ERR);
3851          if (event != NULL && err == CL_SUCCESS)
3852              *event = tmp;
3853          return err;
3854      }
3855      cl_int enqueueReadBufferRect(
3856          const Buffer& buffer,
3857          cl_bool blocking,
3858          const size_t<3>& buffer_offset,
3859          const size_t<3>& host_offset,
3860          const size_t<3>& region,
3861          ::size_t buffer_row_pitch,
3862          ::size_t buffer_slice_pitch,
3863          ::size_t host_row_pitch,
3864          ::size_t host_slice_pitch,
3865          void *ptr,
3866          const VECTOR_CLASS<Event>* events = NULL,
3867          Event* event = NULL) const
3868      {
3869          cl_event tmp;
3870          cl_int err = detail::errHandler(
3871              ::clEnqueueReadBufferRect(
3872                  object_, 
3873                  buffer(), 
3874                  blocking, 
3875                  (const ::size_t *)buffer_offset,
3876                  (const ::size_t *)host_offset,
3877                  (const ::size_t *)region,
3878                  buffer_row_pitch,
3879                  buffer_slice_pitch,
3880                  host_row_pitch,
3881                  host_slice_pitch,
3882                  ptr,
3883                  (events != NULL) ? (cl_uint) events->size() : 0,
3884                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3885                  (event != NULL) ? &tmp : NULL),
3886                  __ENQUEUE_READ_BUFFER_RECT_ERR);
3887          if (event != NULL && err == CL_SUCCESS)
3888              *event = tmp;
3889          return err;
3890      }
3891      cl_int enqueueWriteBufferRect(
3892          const Buffer& buffer,
3893          cl_bool blocking,
3894          const size_t<3>& buffer_offset,
3895          const size_t<3>& host_offset,
3896          const size_t<3>& region,
3897          ::size_t buffer_row_pitch,
3898          ::size_t buffer_slice_pitch,
3899          ::size_t host_row_pitch,
3900          ::size_t host_slice_pitch,
3901          void *ptr,
3902          const VECTOR_CLASS<Event>* events = NULL,
3903          Event* event = NULL) const
3904      {
3905          cl_event tmp;
3906          cl_int err = detail::errHandler(
3907              ::clEnqueueWriteBufferRect(
3908                  object_, 
3909                  buffer(), 
3910                  blocking, 
3911                  (const ::size_t *)buffer_offset,
3912                  (const ::size_t *)host_offset,
3913                  (const ::size_t *)region,
3914                  buffer_row_pitch,
3915                  buffer_slice_pitch,
3916                  host_row_pitch,
3917                  host_slice_pitch,
3918                  ptr,
3919                  (events != NULL) ? (cl_uint) events->size() : 0,
3920                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3921                  (event != NULL) ? &tmp : NULL),
3922                  __ENQUEUE_WRITE_BUFFER_RECT_ERR);
3923          if (event != NULL && err == CL_SUCCESS)
3924              *event = tmp;
3925          return err;
3926      }
3927      cl_int enqueueCopyBufferRect(
3928          const Buffer& src,
3929          const Buffer& dst,
3930          const size_t<3>& src_origin,
3931          const size_t<3>& dst_origin,
3932          const size_t<3>& region,
3933          ::size_t src_row_pitch,
3934          ::size_t src_slice_pitch,
3935          ::size_t dst_row_pitch,
3936          ::size_t dst_slice_pitch,
3937          const VECTOR_CLASS<Event>* events = NULL,
3938          Event* event = NULL) const
3939      {
3940          cl_event tmp;
3941          cl_int err = detail::errHandler(
3942              ::clEnqueueCopyBufferRect(
3943                  object_, 
3944                  src(), 
3945                  dst(), 
3946                  (const ::size_t *)src_origin, 
3947                  (const ::size_t *)dst_origin, 
3948                  (const ::size_t *)region,
3949                  src_row_pitch,
3950                  src_slice_pitch,
3951                  dst_row_pitch,
3952                  dst_slice_pitch,
3953                  (events != NULL) ? (cl_uint) events->size() : 0,
3954                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3955                  (event != NULL) ? &tmp : NULL),
3956              __ENQEUE_COPY_BUFFER_RECT_ERR);
3957          if (event != NULL && err == CL_SUCCESS)
3958              *event = tmp;
3959          return err;
3960      }
3961  #if defined(CL_VERSION_1_2)
3962      template<typename PatternType>
3963      cl_int enqueueFillBuffer(
3964          const Buffer& buffer,
3965          PatternType pattern,
3966          ::size_t offset,
3967          ::size_t size,
3968          const VECTOR_CLASS<Event>* events = NULL,
3969          Event* event = NULL) const
3970      {
3971          cl_event tmp;
3972          cl_int err = detail::errHandler(
3973              ::clEnqueueFillBuffer(
3974                  object_, 
3975                  buffer(),
3976                  static_cast<void*>(&pattern),
3977                  sizeof(PatternType), 
3978                  offset, 
3979                  size,
3980                  (events != NULL) ? (cl_uint) events->size() : 0,
3981                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
3982                  (event != NULL) ? &tmp : NULL),
3983                  __ENQUEUE_FILL_BUFFER_ERR);
3984          if (event != NULL && err == CL_SUCCESS)
3985              *event = tmp;
3986          return err;
3987      }
3988  #endif 
3989      cl_int enqueueReadImage(
3990          const Image& image,
3991          cl_bool blocking,
3992          const size_t<3>& origin,
3993          const size_t<3>& region,
3994          ::size_t row_pitch,
3995          ::size_t slice_pitch,
3996          void* ptr,
3997          const VECTOR_CLASS<Event>* events = NULL,
3998          Event* event = NULL) const
3999      {
4000          cl_event tmp;
4001          cl_int err = detail::errHandler(
4002              ::clEnqueueReadImage(
4003                  object_, image(), blocking, (const ::size_t *) origin,
4004                  (const ::size_t *) region, row_pitch, slice_pitch, ptr,
4005                  (events != NULL) ? (cl_uint) events->size() : 0,
4006                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4007                  (event != NULL) ? &tmp : NULL),
4008              __ENQUEUE_READ_IMAGE_ERR);
4009          if (event != NULL && err == CL_SUCCESS)
4010              *event = tmp;
4011          return err;
4012      }
4013      cl_int enqueueWriteImage(
4014          const Image& image,
4015          cl_bool blocking,
4016          const size_t<3>& origin,
4017          const size_t<3>& region,
4018          ::size_t row_pitch,
4019          ::size_t slice_pitch,
4020          void* ptr,
4021          const VECTOR_CLASS<Event>* events = NULL,
4022          Event* event = NULL) const
4023      {
4024          cl_event tmp;
4025          cl_int err = detail::errHandler(
4026              ::clEnqueueWriteImage(
4027                  object_, image(), blocking, (const ::size_t *) origin,
4028                  (const ::size_t *) region, row_pitch, slice_pitch, ptr,
4029                  (events != NULL) ? (cl_uint) events->size() : 0,
4030                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4031                  (event != NULL) ? &tmp : NULL),
4032              __ENQUEUE_WRITE_IMAGE_ERR);
4033          if (event != NULL && err == CL_SUCCESS)
4034              *event = tmp;
4035          return err;
4036      }
4037      cl_int enqueueCopyImage(
4038          const Image& src,
4039          const Image& dst,
4040          const size_t<3>& src_origin,
4041          const size_t<3>& dst_origin,
4042          const size_t<3>& region,
4043          const VECTOR_CLASS<Event>* events = NULL,
4044          Event* event = NULL) const
4045      {
4046          cl_event tmp;
4047          cl_int err = detail::errHandler(
4048              ::clEnqueueCopyImage(
4049                  object_, src(), dst(), (const ::size_t *) src_origin,
4050                  (const ::size_t *)dst_origin, (const ::size_t *) region,
4051                  (events != NULL) ? (cl_uint) events->size() : 0,
4052                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4053                  (event != NULL) ? &tmp : NULL),
4054              __ENQUEUE_COPY_IMAGE_ERR);
4055          if (event != NULL && err == CL_SUCCESS)
4056              *event = tmp;
4057          return err;
4058      }
4059  #if defined(CL_VERSION_1_2)
4060      cl_int enqueueFillImage(
4061          const Image& image,
4062          cl_float4 fillColor,
4063          const size_t<3>& origin,
4064          const size_t<3>& region,
4065          const VECTOR_CLASS<Event>* events = NULL,
4066          Event* event = NULL) const
4067      {
4068          cl_event tmp;
4069          cl_int err = detail::errHandler(
4070              ::clEnqueueFillImage(
4071                  object_, 
4072                  image(),
4073                  static_cast<void*>(&fillColor), 
4074                  (const ::size_t *) origin, 
4075                  (const ::size_t *) region,
4076                  (events != NULL) ? (cl_uint) events->size() : 0,
4077                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4078                  (event != NULL) ? &tmp : NULL),
4079                  __ENQUEUE_FILL_IMAGE_ERR);
4080          if (event != NULL && err == CL_SUCCESS)
4081              *event = tmp;
4082          return err;
4083      }
4084      cl_int enqueueFillImage(
4085          const Image& image,
4086          cl_int4 fillColor,
4087          const size_t<3>& origin,
4088          const size_t<3>& region,
4089          const VECTOR_CLASS<Event>* events = NULL,
4090          Event* event = NULL) const
4091      {
4092          cl_event tmp;
4093          cl_int err = detail::errHandler(
4094              ::clEnqueueFillImage(
4095                  object_, 
4096                  image(),
4097                  static_cast<void*>(&fillColor), 
4098                  (const ::size_t *) origin, 
4099                  (const ::size_t *) region,
4100                  (events != NULL) ? (cl_uint) events->size() : 0,
4101                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4102                  (event != NULL) ? &tmp : NULL),
4103                  __ENQUEUE_FILL_IMAGE_ERR);
4104          if (event != NULL && err == CL_SUCCESS)
4105              *event = tmp;
4106          return err;
4107      }
4108      cl_int enqueueFillImage(
4109          const Image& image,
4110          cl_uint4 fillColor,
4111          const size_t<3>& origin,
4112          const size_t<3>& region,
4113          const VECTOR_CLASS<Event>* events = NULL,
4114          Event* event = NULL) const
4115      {
4116          cl_event tmp;
4117          cl_int err = detail::errHandler(
4118              ::clEnqueueFillImage(
4119                  object_, 
4120                  image(),
4121                  static_cast<void*>(&fillColor), 
4122                  (const ::size_t *) origin, 
4123                  (const ::size_t *) region,
4124                  (events != NULL) ? (cl_uint) events->size() : 0,
4125                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4126                  (event != NULL) ? &tmp : NULL),
4127                  __ENQUEUE_FILL_IMAGE_ERR);
4128          if (event != NULL && err == CL_SUCCESS)
4129              *event = tmp;
4130          return err;
4131      }
4132  #endif 
4133      cl_int enqueueCopyImageToBuffer(
4134          const Image& src,
4135          const Buffer& dst,
4136          const size_t<3>& src_origin,
4137          const size_t<3>& region,
4138          ::size_t dst_offset,
4139          const VECTOR_CLASS<Event>* events = NULL,
4140          Event* event = NULL) const
4141      {
4142          cl_event tmp;
4143          cl_int err = detail::errHandler(
4144              ::clEnqueueCopyImageToBuffer(
4145                  object_, src(), dst(), (const ::size_t *) src_origin,
4146                  (const ::size_t *) region, dst_offset,
4147                  (events != NULL) ? (cl_uint) events->size() : 0,
4148                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4149                  (event != NULL) ? &tmp : NULL),
4150              __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR);
4151          if (event != NULL && err == CL_SUCCESS)
4152              *event = tmp;
4153          return err;
4154      }
4155      cl_int enqueueCopyBufferToImage(
4156          const Buffer& src,
4157          const Image& dst,
4158          ::size_t src_offset,
4159          const size_t<3>& dst_origin,
4160          const size_t<3>& region,
4161          const VECTOR_CLASS<Event>* events = NULL,
4162          Event* event = NULL) const
4163      {
4164          cl_event tmp;
4165          cl_int err = detail::errHandler(
4166              ::clEnqueueCopyBufferToImage(
4167                  object_, src(), dst(), src_offset,
4168                  (const ::size_t *) dst_origin, (const ::size_t *) region,
4169                  (events != NULL) ? (cl_uint) events->size() : 0,
4170                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4171                  (event != NULL) ? &tmp : NULL),
4172              __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR);
4173          if (event != NULL && err == CL_SUCCESS)
4174              *event = tmp;
4175          return err;
4176      }
4177      void* enqueueMapBuffer(
4178          const Buffer& buffer,
4179          cl_bool blocking,
4180          cl_map_flags flags,
4181          ::size_t offset,
4182          ::size_t size,
4183          const VECTOR_CLASS<Event>* events = NULL,
4184          Event* event = NULL,
4185          cl_int* err = NULL) const
4186      {
4187          cl_event tmp;
4188          cl_int error;
4189          void * result = ::clEnqueueMapBuffer(
4190              object_, buffer(), blocking, flags, offset, size,
4191              (events != NULL) ? (cl_uint) events->size() : 0,
4192              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4193              (event != NULL) ? &tmp : NULL,
4194              &error);
4195          detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4196          if (err != NULL) {
4197              *err = error;
4198          }
4199          if (event != NULL && error == CL_SUCCESS)
4200              *event = tmp;
4201          return result;
4202      }
4203      void* enqueueMapImage(
4204          const Image& buffer,
4205          cl_bool blocking,
4206          cl_map_flags flags,
4207          const size_t<3>& origin,
4208          const size_t<3>& region,
4209          ::size_t * row_pitch,
4210          ::size_t * slice_pitch,
4211          const VECTOR_CLASS<Event>* events = NULL,
4212          Event* event = NULL,
4213          cl_int* err = NULL) const
4214      {
4215          cl_event tmp;
4216          cl_int error;
4217          void * result = ::clEnqueueMapImage(
4218              object_, buffer(), blocking, flags,
4219              (const ::size_t *) origin, (const ::size_t *) region,
4220              row_pitch, slice_pitch,
4221              (events != NULL) ? (cl_uint) events->size() : 0,
4222              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4223              (event != NULL) ? &tmp : NULL,
4224              &error);
4225          detail::errHandler(error, __ENQUEUE_MAP_IMAGE_ERR);
4226          if (err != NULL) {
4227                *err = error;
4228          }
4229          if (event != NULL && error == CL_SUCCESS)
4230              *event = tmp;
4231          return result;
4232      }
4233      cl_int enqueueUnmapMemObject(
4234          const Memory& memory,
4235          void* mapped_ptr,
4236          const VECTOR_CLASS<Event>* events = NULL,
4237          Event* event = NULL) const
4238      {
4239          cl_event tmp;
4240          cl_int err = detail::errHandler(
4241              ::clEnqueueUnmapMemObject(
4242                  object_, memory(), mapped_ptr,
4243                  (events != NULL) ? (cl_uint) events->size() : 0,
4244                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4245                  (event != NULL) ? &tmp : NULL),
4246              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
4247          if (event != NULL && err == CL_SUCCESS)
4248              *event = tmp;
4249          return err;
4250      }
4251  #if defined(CL_VERSION_1_2)
4252      cl_int enqueueMarkerWithWaitList(
4253          const VECTOR_CLASS<Event> *events = 0,
4254          Event *event = 0)
4255      {
4256          cl_event tmp;
4257          cl_int err = detail::errHandler(
4258              ::clEnqueueMarkerWithWaitList(
4259                  object_,
4260                  (events != NULL) ? (cl_uint) events->size() : 0,
4261                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4262                  (event != NULL) ? &tmp : NULL),
4263              __ENQUEUE_MARKER_WAIT_LIST_ERR);
4264          if (event != NULL && err == CL_SUCCESS)
4265              *event = tmp;
4266          return err;
4267      }
4268      cl_int enqueueBarrierWithWaitList(
4269          const VECTOR_CLASS<Event> *events = 0,
4270          Event *event = 0)
4271      {
4272          cl_event tmp;
4273          cl_int err = detail::errHandler(
4274              ::clEnqueueBarrierWithWaitList(
4275                  object_,
4276                  (events != NULL) ? (cl_uint) events->size() : 0,
4277                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4278                  (event != NULL) ? &tmp : NULL),
4279              __ENQUEUE_BARRIER_WAIT_LIST_ERR);
4280          if (event != NULL && err == CL_SUCCESS)
4281              *event = tmp;
4282          return err;
4283      }
4284      cl_int enqueueMigrateMemObjects(
4285          const VECTOR_CLASS<Memory> &memObjects,
4286          cl_mem_migration_flags flags,
4287          const VECTOR_CLASS<Event>* events = NULL,
4288          Event* event = NULL
4289          )
4290      {
4291          cl_event tmp;
4292          cl_mem* localMemObjects = static_cast<cl_mem*>(alloca(memObjects.size() * sizeof(cl_mem)));
4293          for( int i = 0; i < (int)memObjects.size(); ++i ) {
4294              localMemObjects[i] = memObjects[i]();
4295          }
4296          cl_int err = detail::errHandler(
4297              ::clEnqueueMigrateMemObjects(
4298                  object_, 
4299                  (cl_uint)memObjects.size(), 
4300                  static_cast<const cl_mem*>(localMemObjects),
4301                  flags,
4302                  (events != NULL) ? (cl_uint) events->size() : 0,
4303                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4304                  (event != NULL) ? &tmp : NULL),
4305              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
4306          if (event != NULL && err == CL_SUCCESS)
4307              *event = tmp;
4308          return err;
4309      }
4310  #endif 
4311      cl_int enqueueNDRangeKernel(
4312          const Kernel& kernel,
4313          const NDRange& offset,
4314          const NDRange& global,
4315          const NDRange& local = NullRange,
4316          const VECTOR_CLASS<Event>* events = NULL,
4317          Event* event = NULL) const
4318      {
4319          cl_event tmp;
4320          cl_int err = detail::errHandler(
4321              ::clEnqueueNDRangeKernel(
4322                  object_, kernel(), (cl_uint) global.dimensions(),
4323                  offset.dimensions() != 0 ? (const ::size_t*) offset : NULL,
4324                  (const ::size_t*) global,
4325                  local.dimensions() != 0 ? (const ::size_t*) local : NULL,
4326                  (events != NULL) ? (cl_uint) events->size() : 0,
4327                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4328                  (event != NULL) ? &tmp : NULL),
4329              __ENQUEUE_NDRANGE_KERNEL_ERR);
4330          if (event != NULL && err == CL_SUCCESS)
4331              *event = tmp;
4332          return err;
4333      }
4334      cl_int enqueueTask(
4335          const Kernel& kernel,
4336          const VECTOR_CLASS<Event>* events = NULL,
4337          Event* event = NULL) const
4338      {
4339          cl_event tmp;
4340          cl_int err = detail::errHandler(
4341              ::clEnqueueTask(
4342                  object_, kernel(),
4343                  (events != NULL) ? (cl_uint) events->size() : 0,
4344                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4345                  (event != NULL) ? &tmp : NULL),
4346              __ENQUEUE_TASK_ERR);
4347          if (event != NULL && err == CL_SUCCESS)
4348              *event = tmp;
4349          return err;
4350      }
4351      cl_int enqueueNativeKernel(
4352          void (CL_CALLBACK *userFptr)(void *),
4353          std::pair<void*, ::size_t> args,
4354          const VECTOR_CLASS<Memory>* mem_objects = NULL,
4355          const VECTOR_CLASS<const void*>* mem_locs = NULL,
4356          const VECTOR_CLASS<Event>* events = NULL,
4357          Event* event = NULL) const
4358      {
4359          cl_mem * mems = (mem_objects != NULL && mem_objects->size() > 0) 
4360              ? (cl_mem*) alloca(mem_objects->size() * sizeof(cl_mem))
4361              : NULL;
4362          if (mems != NULL) {
4363              for (unsigned int i = 0; i < mem_objects->size(); i++) {
4364                  mems[i] = ((*mem_objects)[i])();
4365              }
4366          }
4367          cl_event tmp;
4368          cl_int err = detail::errHandler(
4369              ::clEnqueueNativeKernel(
4370                  object_, userFptr, args.first, args.second,
4371                  (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
4372                  mems,
4373                  (mem_locs != NULL && mem_locs->size() > 0) ? (const void **) &mem_locs->front() : NULL,
4374                  (events != NULL) ? (cl_uint) events->size() : 0,
4375                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4376                  (event != NULL) ? &tmp : NULL),
4377              __ENQUEUE_NATIVE_KERNEL);
4378          if (event != NULL && err == CL_SUCCESS)
4379              *event = tmp;
4380          return err;
4381      }
4382  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) && !defined(CL_VERSION_1_2)) 
4383      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED 
4384      cl_int enqueueMarker(Event* event = NULL) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
4385      {
4386          cl_event tmp;
4387          cl_int err = detail::errHandler(
4388              ::clEnqueueMarker(
4389                  object_, 
4390                  (event != NULL) ? &tmp : NULL),
4391              __ENQUEUE_MARKER_ERR);
4392          if (event != NULL && err == CL_SUCCESS)
4393              *event = tmp;
4394          return err;
4395      }
4396      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
4397      cl_int enqueueWaitForEvents(const VECTOR_CLASS<Event>& events) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
4398      {
4399          return detail::errHandler(
4400              ::clEnqueueWaitForEvents(
4401                  object_,
4402                  (cl_uint) events.size(),
4403                  events.size() > 0 ? (const cl_event*) &events.front() : NULL),
4404              __ENQUEUE_WAIT_FOR_EVENTS_ERR);
4405      }
4406  #endif 
4407      cl_int enqueueAcquireGLObjects(
4408           const VECTOR_CLASS<Memory>* mem_objects = NULL,
4409           const VECTOR_CLASS<Event>* events = NULL,
4410           Event* event = NULL) const
4411       {
4412          cl_event tmp;
4413          cl_int err = detail::errHandler(
4414               ::clEnqueueAcquireGLObjects(
4415                   object_,
4416                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
4417                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
4418                   (events != NULL) ? (cl_uint) events->size() : 0,
4419                   (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4420                   (event != NULL) ? &tmp : NULL),
4421               __ENQUEUE_ACQUIRE_GL_ERR);
4422          if (event != NULL && err == CL_SUCCESS)
4423              *event = tmp;
4424          return err;
4425       }
4426      cl_int enqueueReleaseGLObjects(
4427           const VECTOR_CLASS<Memory>* mem_objects = NULL,
4428           const VECTOR_CLASS<Event>* events = NULL,
4429           Event* event = NULL) const
4430       {
4431          cl_event tmp;
4432          cl_int err = detail::errHandler(
4433               ::clEnqueueReleaseGLObjects(
4434                   object_,
4435                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
4436                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
4437                   (events != NULL) ? (cl_uint) events->size() : 0,
4438                   (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4439                   (event != NULL) ? &tmp : NULL),
4440               __ENQUEUE_RELEASE_GL_ERR);
4441          if (event != NULL && err == CL_SUCCESS)
4442              *event = tmp;
4443          return err;
4444       }
4445  #if defined (USE_DX_INTEROP)
4446  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueAcquireD3D10ObjectsKHR)(
4447      cl_command_queue command_queue, cl_uint num_objects,
4448      const cl_mem* mem_objects, cl_uint num_events_in_wait_list,
4449      const cl_event* event_wait_list, cl_event* event);
4450  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueReleaseD3D10ObjectsKHR)(
4451      cl_command_queue command_queue, cl_uint num_objects,
4452      const cl_mem* mem_objects,  cl_uint num_events_in_wait_list,
4453      const cl_event* event_wait_list, cl_event* event);
4454      cl_int enqueueAcquireD3D10Objects(
4455           const VECTOR_CLASS<Memory>* mem_objects = NULL,
4456           const VECTOR_CLASS<Event>* events = NULL,
4457           Event* event = NULL) const
4458      {
4459          static PFN_clEnqueueAcquireD3D10ObjectsKHR pfn_clEnqueueAcquireD3D10ObjectsKHR = NULL;
4460  #if defined(CL_VERSION_1_2)
4461          cl_context context = getInfo<CL_QUEUE_CONTEXT>();
4462          cl::Device device(getInfo<CL_QUEUE_DEVICE>());
4463          cl_platform_id platform = device.getInfo<CL_DEVICE_PLATFORM>();
4464          __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, clEnqueueAcquireD3D10ObjectsKHR);
4465  #endif
4466  #if defined(CL_VERSION_1_1)
4467          __INIT_CL_EXT_FCN_PTR(clEnqueueAcquireD3D10ObjectsKHR);
4468  #endif
4469          cl_event tmp;
4470          cl_int err = detail::errHandler(
4471               pfn_clEnqueueAcquireD3D10ObjectsKHR(
4472                   object_,
4473                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
4474                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
4475                   (events != NULL) ? (cl_uint) events->size() : 0,
4476                   (events != NULL) ? (cl_event*) &events->front() : NULL,
4477                   (event != NULL) ? &tmp : NULL),
4478               __ENQUEUE_ACQUIRE_GL_ERR);
4479          if (event != NULL && err == CL_SUCCESS)
4480              *event = tmp;
4481          return err;
4482       }
4483      cl_int enqueueReleaseD3D10Objects(
4484           const VECTOR_CLASS<Memory>* mem_objects = NULL,
4485           const VECTOR_CLASS<Event>* events = NULL,
4486           Event* event = NULL) const
4487      {
4488          static PFN_clEnqueueReleaseD3D10ObjectsKHR pfn_clEnqueueReleaseD3D10ObjectsKHR = NULL;
4489  #if defined(CL_VERSION_1_2)
4490          cl_context context = getInfo<CL_QUEUE_CONTEXT>();
4491          cl::Device device(getInfo<CL_QUEUE_DEVICE>());
4492          cl_platform_id platform = device.getInfo<CL_DEVICE_PLATFORM>();
4493          __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, clEnqueueReleaseD3D10ObjectsKHR);
4494  #endif 
4495  #if defined(CL_VERSION_1_1)
4496          __INIT_CL_EXT_FCN_PTR(clEnqueueReleaseD3D10ObjectsKHR);
4497  #endif 
4498          cl_event tmp;
4499          cl_int err = detail::errHandler(
4500              pfn_clEnqueueReleaseD3D10ObjectsKHR(
4501                  object_,
4502                  (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
4503                  (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
4504                  (events != NULL) ? (cl_uint) events->size() : 0,
4505                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4506                  (event != NULL) ? &tmp : NULL),
4507              __ENQUEUE_RELEASE_GL_ERR);
4508          if (event != NULL && err == CL_SUCCESS)
4509              *event = tmp;
4510          return err;
4511      }
4512  #endif
4513  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) && !defined(CL_VERSION_1_2)) 
4514      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
4515      cl_int enqueueBarrier() const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
4516      {
4517          return detail::errHandler(
4518              ::clEnqueueBarrier(object_),
4519              __ENQUEUE_BARRIER_ERR);
4520      }
4521  #endif 
4522      cl_int flush() const
4523      {
4524          return detail::errHandler(::clFlush(object_), __FLUSH_ERR);
4525      }
4526      cl_int finish() const
4527      {
4528          return detail::errHandler(::clFinish(object_), __FINISH_ERR);
4529      }
4530  };
4531  #ifdef _WIN32
4532  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
4533  __declspec(selectany) std::atomic<int> CommandQueue::default_initialized_;
4534  #else 
4535  __declspec(selectany) volatile int CommandQueue::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
4536  #endif 
4537  __declspec(selectany) CommandQueue CommandQueue::default_;
4538  __declspec(selectany) volatile cl_int CommandQueue::default_error_ = CL_SUCCESS;
4539  #else 
4540  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
4541  __attribute__((weak)) std::atomic<int> CommandQueue::default_initialized_;
4542  #else 
4543  __attribute__((weak)) volatile int CommandQueue::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
4544  #endif 
4545  __attribute__((weak)) CommandQueue CommandQueue::default_;
4546  __attribute__((weak)) volatile cl_int CommandQueue::default_error_ = CL_SUCCESS;
4547  #endif 
4548  template< typename IteratorType >
4549  Buffer::Buffer(
4550      const Context &context,
4551      IteratorType startIterator,
4552      IteratorType endIterator,
4553      bool readOnly,
4554      bool useHostPtr,
4555      cl_int* err)
4556  {
4557      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
4558      cl_int error;
4559      cl_mem_flags flags = 0;
4560      if( readOnly ) {
4561          flags |= CL_MEM_READ_ONLY;
4562      }
4563      else {
4564          flags |= CL_MEM_READ_WRITE;
4565      }
4566      if( useHostPtr ) {
4567          flags |= CL_MEM_USE_HOST_PTR;
4568      }
4569      ::size_t size = sizeof(DataType)*(endIterator - startIterator);
4570      if( useHostPtr ) {
4571          object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
4572      } else {
4573          object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
4574      }
4575      detail::errHandler(error, __CREATE_BUFFER_ERR);
4576      if (err != NULL) {
4577          *err = error;
4578      }
4579      if( !useHostPtr ) {
4580          CommandQueue queue(context, 0, &error);
4581          detail::errHandler(error, __CREATE_BUFFER_ERR);
4582          if (err != NULL) {
4583              *err = error;
4584          }
4585          error = cl::copy(queue, startIterator, endIterator, *this);
4586          detail::errHandler(error, __CREATE_BUFFER_ERR);
4587          if (err != NULL) {
4588              *err = error;
4589          }
4590      }
4591  }
4592  template< typename IteratorType >
4593  Buffer::Buffer(
4594      const CommandQueue &queue,
4595      IteratorType startIterator,
4596      IteratorType endIterator,
4597      bool readOnly,
4598      bool useHostPtr,
4599      cl_int* err)
4600  {
4601      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
4602      cl_int error;
4603      cl_mem_flags flags = 0;
4604      if (readOnly) {
4605          flags |= CL_MEM_READ_ONLY;
4606      }
4607      else {
4608          flags |= CL_MEM_READ_WRITE;
4609      }
4610      if (useHostPtr) {
4611          flags |= CL_MEM_USE_HOST_PTR;
4612      }
4613      ::size_t size = sizeof(DataType)*(endIterator - startIterator);
4614      Context context = queue.getInfo<CL_QUEUE_CONTEXT>();
4615      if (useHostPtr) {
4616          object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
4617      }
4618      else {
4619          object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
4620      }
4621      detail::errHandler(error, __CREATE_BUFFER_ERR);
4622      if (err != NULL) {
4623          *err = error;
4624      }
4625      if (!useHostPtr) {
4626          error = cl::copy(queue, startIterator, endIterator, *this);
4627          detail::errHandler(error, __CREATE_BUFFER_ERR);
4628          if (err != NULL) {
4629              *err = error;
4630          }
4631      }
4632  }
4633  inline cl_int enqueueReadBuffer(
4634      const Buffer& buffer,
4635      cl_bool blocking,
4636      ::size_t offset,
4637      ::size_t size,
4638      void* ptr,
4639      const VECTOR_CLASS<Event>* events = NULL,
4640      Event* event = NULL)
4641  {
4642      cl_int error;
4643      CommandQueue queue = CommandQueue::getDefault(&error);
4644      if (error != CL_SUCCESS) {
4645          return error;
4646      }
4647      return queue.enqueueReadBuffer(buffer, blocking, offset, size, ptr, events, event);
4648  }
4649  inline cl_int enqueueWriteBuffer(
4650          const Buffer& buffer,
4651          cl_bool blocking,
4652          ::size_t offset,
4653          ::size_t size,
4654          const void* ptr,
4655          const VECTOR_CLASS<Event>* events = NULL,
4656          Event* event = NULL)
4657  {
4658      cl_int error;
4659      CommandQueue queue = CommandQueue::getDefault(&error);
4660      if (error != CL_SUCCESS) {
4661          return error;
4662      }
4663      return queue.enqueueWriteBuffer(buffer, blocking, offset, size, ptr, events, event);
4664  }
4665  inline void* enqueueMapBuffer(
4666          const Buffer& buffer,
4667          cl_bool blocking,
4668          cl_map_flags flags,
4669          ::size_t offset,
4670          ::size_t size,
4671          const VECTOR_CLASS<Event>* events = NULL,
4672          Event* event = NULL,
4673          cl_int* err = NULL)
4674  {
4675      cl_int error;
4676      CommandQueue queue = CommandQueue::getDefault(&error);
4677      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4678      if (err != NULL) {
4679          *err = error;
4680      }
4681      void * result = ::clEnqueueMapBuffer(
4682              queue(), buffer(), blocking, flags, offset, size,
4683              (events != NULL) ? (cl_uint) events->size() : 0,
4684              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4685              (cl_event*) event,
4686              &error);
4687      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4688      if (err != NULL) {
4689          *err = error;
4690      }
4691      return result;
4692  }
4693  inline cl_int enqueueUnmapMemObject(
4694      const Memory& memory,
4695      void* mapped_ptr,
4696      const VECTOR_CLASS<Event>* events = NULL,
4697      Event* event = NULL)
4698  {
4699      cl_int error;
4700      CommandQueue queue = CommandQueue::getDefault(&error);
4701      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4702      if (error != CL_SUCCESS) {
4703          return error;
4704      }
4705      cl_event tmp;
4706      cl_int err = detail::errHandler(
4707          ::clEnqueueUnmapMemObject(
4708              queue(), memory(), mapped_ptr,
4709              (events != NULL) ? (cl_uint) events->size() : 0,
4710              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4711              (event != NULL) ? &tmp : NULL),
4712          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
4713      if (event != NULL && err == CL_SUCCESS)
4714          *event = tmp;
4715      return err;
4716  }
4717  inline cl_int enqueueCopyBuffer(
4718          const Buffer& src,
4719          const Buffer& dst,
4720          ::size_t src_offset,
4721          ::size_t dst_offset,
4722          ::size_t size,
4723          const VECTOR_CLASS<Event>* events = NULL,
4724          Event* event = NULL)
4725  {
4726      cl_int error;
4727      CommandQueue queue = CommandQueue::getDefault(&error);
4728      if (error != CL_SUCCESS) {
4729          return error;
4730      }
4731      return queue.enqueueCopyBuffer(src, dst, src_offset, dst_offset, size, events, event);
4732  }
4733  template< typename IteratorType >
4734  inline cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer )
4735  {
4736      cl_int error;
4737      CommandQueue queue = CommandQueue::getDefault(&error);
4738      if (error != CL_SUCCESS)
4739          return error;
4740      return cl::copy(queue, startIterator, endIterator, buffer);
4741  }
4742  template< typename IteratorType >
4743  inline cl_int copy( const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator )
4744  {
4745      cl_int error;
4746      CommandQueue queue = CommandQueue::getDefault(&error);
4747      if (error != CL_SUCCESS)
4748          return error;
4749      return cl::copy(queue, buffer, startIterator, endIterator);
4750  }
4751  template< typename IteratorType >
4752  inline cl_int copy( const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer )
4753  {
4754      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
4755      cl_int error;
4756      ::size_t length = endIterator-startIterator;
4757      ::size_t byteLength = length*sizeof(DataType);
4758      DataType *pointer = 
4759          static_cast<DataType*>(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_WRITE, 0, byteLength, 0, 0, &error));
4760      if( error != CL_SUCCESS ) {
4761          return error;
4762      }
4763  #if defined(_MSC_VER)
4764      std::copy(
4765          startIterator, 
4766          endIterator, 
4767          stdext::checked_array_iterator<DataType*>(
4768              pointer, length));
4769  #else
4770      std::copy(startIterator, endIterator, pointer);
4771  #endif
4772      Event endEvent;
4773      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &endEvent);
4774      if( error != CL_SUCCESS ) { 
4775          return error;
4776      }
4777      endEvent.wait();
4778      return CL_SUCCESS;
4779  }
4780  template< typename IteratorType >
4781  inline cl_int copy( const CommandQueue &queue, const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator )
4782  {
4783      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
4784      cl_int error;
4785      ::size_t length = endIterator-startIterator;
4786      ::size_t byteLength = length*sizeof(DataType);
4787      DataType *pointer = 
4788          static_cast<DataType*>(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_READ, 0, byteLength, 0, 0, &error));
4789      if( error != CL_SUCCESS ) {
4790          return error;
4791      }
4792      std::copy(pointer, pointer + length, startIterator);
4793      Event endEvent;
4794      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &endEvent);
4795      if( error != CL_SUCCESS ) { 
4796          return error;
4797      }
4798      endEvent.wait();
4799      return CL_SUCCESS;
4800  }
4801  #if defined(CL_VERSION_1_1)
4802  inline cl_int enqueueReadBufferRect(
4803      const Buffer& buffer,
4804      cl_bool blocking,
4805      const size_t<3>& buffer_offset,
4806      const size_t<3>& host_offset,
4807      const size_t<3>& region,
4808      ::size_t buffer_row_pitch,
4809      ::size_t buffer_slice_pitch,
4810      ::size_t host_row_pitch,
4811      ::size_t host_slice_pitch,
4812      void *ptr,
4813      const VECTOR_CLASS<Event>* events = NULL,
4814      Event* event = NULL)
4815  {
4816      cl_int error;
4817      CommandQueue queue = CommandQueue::getDefault(&error);
4818      if (error != CL_SUCCESS) {
4819          return error;
4820      }
4821      return queue.enqueueReadBufferRect(
4822          buffer, 
4823          blocking, 
4824          buffer_offset, 
4825          host_offset,
4826          region,
4827          buffer_row_pitch,
4828          buffer_slice_pitch,
4829          host_row_pitch,
4830          host_slice_pitch,
4831          ptr, 
4832          events, 
4833          event);
4834  }
4835  inline cl_int enqueueWriteBufferRect(
4836      const Buffer& buffer,
4837      cl_bool blocking,
4838      const size_t<3>& buffer_offset,
4839      const size_t<3>& host_offset,
4840      const size_t<3>& region,
4841      ::size_t buffer_row_pitch,
4842      ::size_t buffer_slice_pitch,
4843      ::size_t host_row_pitch,
4844      ::size_t host_slice_pitch,
4845      void *ptr,
4846      const VECTOR_CLASS<Event>* events = NULL,
4847      Event* event = NULL)
4848  {
4849      cl_int error;
4850      CommandQueue queue = CommandQueue::getDefault(&error);
4851      if (error != CL_SUCCESS) {
4852          return error;
4853      }
4854      return queue.enqueueWriteBufferRect(
4855          buffer, 
4856          blocking, 
4857          buffer_offset, 
4858          host_offset,
4859          region,
4860          buffer_row_pitch,
4861          buffer_slice_pitch,
4862          host_row_pitch,
4863          host_slice_pitch,
4864          ptr, 
4865          events, 
4866          event);
4867  }
4868  inline cl_int enqueueCopyBufferRect(
4869      const Buffer& src,
4870      const Buffer& dst,
4871      const size_t<3>& src_origin,
4872      const size_t<3>& dst_origin,
4873      const size_t<3>& region,
4874      ::size_t src_row_pitch,
4875      ::size_t src_slice_pitch,
4876      ::size_t dst_row_pitch,
4877      ::size_t dst_slice_pitch,
4878      const VECTOR_CLASS<Event>* events = NULL,
4879      Event* event = NULL)
4880  {
4881      cl_int error;
4882      CommandQueue queue = CommandQueue::getDefault(&error);
4883      if (error != CL_SUCCESS) {
4884          return error;
4885      }
4886      return queue.enqueueCopyBufferRect(
4887          src,
4888          dst,
4889          src_origin,
4890          dst_origin,
4891          region,
4892          src_row_pitch,
4893          src_slice_pitch,
4894          dst_row_pitch,
4895          dst_slice_pitch,
4896          events, 
4897          event);
4898  }
4899  #endif
4900  inline cl_int enqueueReadImage(
4901      const Image& image,
4902      cl_bool blocking,
4903      const size_t<3>& origin,
4904      const size_t<3>& region,
4905      ::size_t row_pitch,
4906      ::size_t slice_pitch,
4907      void* ptr,
4908      const VECTOR_CLASS<Event>* events = NULL,
4909      Event* event = NULL) 
4910  {
4911      cl_int error;
4912      CommandQueue queue = CommandQueue::getDefault(&error);
4913      if (error != CL_SUCCESS) {
4914          return error;
4915      }
4916      return queue.enqueueReadImage(
4917          image,
4918          blocking,
4919          origin,
4920          region,
4921          row_pitch,
4922          slice_pitch,
4923          ptr,
4924          events, 
4925          event);
4926  }
4927  inline cl_int enqueueWriteImage(
4928      const Image& image,
4929      cl_bool blocking,
4930      const size_t<3>& origin,
4931      const size_t<3>& region,
4932      ::size_t row_pitch,
4933      ::size_t slice_pitch,
4934      void* ptr,
4935      const VECTOR_CLASS<Event>* events = NULL,
4936      Event* event = NULL)
4937  {
4938      cl_int error;
4939      CommandQueue queue = CommandQueue::getDefault(&error);
4940      if (error != CL_SUCCESS) {
4941          return error;
4942      }
4943      return queue.enqueueWriteImage(
4944          image,
4945          blocking,
4946          origin,
4947          region,
4948          row_pitch,
4949          slice_pitch,
4950          ptr,
4951          events, 
4952          event);
4953  }
4954  inline cl_int enqueueCopyImage(
4955      const Image& src,
4956      const Image& dst,
4957      const size_t<3>& src_origin,
4958      const size_t<3>& dst_origin,
4959      const size_t<3>& region,
4960      const VECTOR_CLASS<Event>* events = NULL,
4961      Event* event = NULL)
4962  {
4963      cl_int error;
4964      CommandQueue queue = CommandQueue::getDefault(&error);
4965      if (error != CL_SUCCESS) {
4966          return error;
4967      }
4968      return queue.enqueueCopyImage(
4969          src,
4970          dst,
4971          src_origin,
4972          dst_origin,
4973          region,
4974          events,
4975          event);
4976  }
4977  inline cl_int enqueueCopyImageToBuffer(
4978      const Image& src,
4979      const Buffer& dst,
4980      const size_t<3>& src_origin,
4981      const size_t<3>& region,
4982      ::size_t dst_offset,
4983      const VECTOR_CLASS<Event>* events = NULL,
4984      Event* event = NULL)
4985  {
4986      cl_int error;
4987      CommandQueue queue = CommandQueue::getDefault(&error);
4988      if (error != CL_SUCCESS) {
4989          return error;
4990      }
4991      return queue.enqueueCopyImageToBuffer(
4992          src,
4993          dst,
4994          src_origin,
4995          region,
4996          dst_offset,
4997          events,
4998          event);
4999  }
5000  inline cl_int enqueueCopyBufferToImage(
5001      const Buffer& src,
5002      const Image& dst,
5003      ::size_t src_offset,
5004      const size_t<3>& dst_origin,
5005      const size_t<3>& region,
5006      const VECTOR_CLASS<Event>* events = NULL,
5007      Event* event = NULL)
5008  {
5009      cl_int error;
5010      CommandQueue queue = CommandQueue::getDefault(&error);
5011      if (error != CL_SUCCESS) {
5012          return error;
5013      }
5014      return queue.enqueueCopyBufferToImage(
5015          src,
5016          dst,
5017          src_offset,
5018          dst_origin,
5019          region,
5020          events,
5021          event);
5022  }
5023  inline cl_int flush(void)
5024  {
5025      cl_int error;
5026      CommandQueue queue = CommandQueue::getDefault(&error);
5027      if (error != CL_SUCCESS) {
5028          return error;
5029      }
5030      return queue.flush();
5031  }
5032  inline cl_int finish(void)
5033  {
5034      cl_int error;
5035      CommandQueue queue = CommandQueue::getDefault(&error);
5036      if (error != CL_SUCCESS) {
5037          return error;
5038      } 
5039      return queue.finish();
5040  }
5041  struct EnqueueArgs
5042  {
5043      CommandQueue queue_;
5044      const NDRange offset_;
5045      const NDRange global_;
5046      const NDRange local_;
5047      VECTOR_CLASS<Event> events_;
5048      EnqueueArgs(NDRange global) : 
5049        queue_(CommandQueue::getDefault()),
5050        offset_(NullRange), 
5051        global_(global),
5052        local_(NullRange)
5053      {
5054      }
5055      EnqueueArgs(NDRange global, NDRange local) : 
5056        queue_(CommandQueue::getDefault()),
5057        offset_(NullRange), 
5058        global_(global),
5059        local_(local)
5060      {
5061      }
5062      EnqueueArgs(NDRange offset, NDRange global, NDRange local) : 
5063        queue_(CommandQueue::getDefault()),
5064        offset_(offset), 
5065        global_(global),
5066        local_(local)
5067      {
5068      }
5069      EnqueueArgs(Event e, NDRange global) : 
5070        queue_(CommandQueue::getDefault()),
5071        offset_(NullRange), 
5072        global_(global),
5073        local_(NullRange)
5074      {
5075          events_.push_back(e);
5076      }
5077      EnqueueArgs(Event e, NDRange global, NDRange local) : 
5078        queue_(CommandQueue::getDefault()),
5079        offset_(NullRange), 
5080        global_(global),
5081        local_(local)
5082      {
5083          events_.push_back(e);
5084      }
5085      EnqueueArgs(Event e, NDRange offset, NDRange global, NDRange local) : 
5086        queue_(CommandQueue::getDefault()),
5087        offset_(offset), 
5088        global_(global),
5089        local_(local)
5090      {
5091          events_.push_back(e);
5092      }
5093      EnqueueArgs(const VECTOR_CLASS<Event> &events, NDRange global) : 
5094        queue_(CommandQueue::getDefault()),
5095        offset_(NullRange), 
5096        global_(global),
5097        local_(NullRange),
5098        events_(events)
5099      {
5100      }
5101      EnqueueArgs(const VECTOR_CLASS<Event> &events, NDRange global, NDRange local) : 
5102        queue_(CommandQueue::getDefault()),
5103        offset_(NullRange), 
5104        global_(global),
5105        local_(local),
5106        events_(events)
5107      {
5108      }
5109      EnqueueArgs(const VECTOR_CLASS<Event> &events, NDRange offset, NDRange global, NDRange local) : 
5110        queue_(CommandQueue::getDefault()),
5111        offset_(offset), 
5112        global_(global),
5113        local_(local),
5114        events_(events)
5115      {
5116      }
5117      EnqueueArgs(CommandQueue &queue, NDRange global) : 
5118        queue_(queue),
5119        offset_(NullRange), 
5120        global_(global),
5121        local_(NullRange)
5122      {
5123      }
5124      EnqueueArgs(CommandQueue &queue, NDRange global, NDRange local) : 
5125        queue_(queue),
5126        offset_(NullRange), 
5127        global_(global),
5128        local_(local)
5129      {
5130      }
5131      EnqueueArgs(CommandQueue &queue, NDRange offset, NDRange global, NDRange local) : 
5132        queue_(queue),
5133        offset_(offset), 
5134        global_(global),
5135        local_(local)
5136      {
5137      }
5138      EnqueueArgs(CommandQueue &queue, Event e, NDRange global) : 
5139        queue_(queue),
5140        offset_(NullRange), 
5141        global_(global),
5142        local_(NullRange)
5143      {
5144          events_.push_back(e);
5145      }
5146      EnqueueArgs(CommandQueue &queue, Event e, NDRange global, NDRange local) : 
5147        queue_(queue),
5148        offset_(NullRange), 
5149        global_(global),
5150        local_(local)
5151      {
5152          events_.push_back(e);
5153      }
5154      EnqueueArgs(CommandQueue &queue, Event e, NDRange offset, NDRange global, NDRange local) : 
5155        queue_(queue),
5156        offset_(offset), 
5157        global_(global),
5158        local_(local)
5159      {
5160          events_.push_back(e);
5161      }
5162      EnqueueArgs(CommandQueue &queue, const VECTOR_CLASS<Event> &events, NDRange global) : 
5163        queue_(queue),
5164        offset_(NullRange), 
5165        global_(global),
5166        local_(NullRange),
5167        events_(events)
5168      {
5169      }
5170      EnqueueArgs(CommandQueue &queue, const VECTOR_CLASS<Event> &events, NDRange global, NDRange local) : 
5171        queue_(queue),
5172        offset_(NullRange), 
5173        global_(global),
5174        local_(local),
5175        events_(events)
5176      {
5177      }
5178      EnqueueArgs(CommandQueue &queue, const VECTOR_CLASS<Event> &events, NDRange offset, NDRange global, NDRange local) : 
5179        queue_(queue),
5180        offset_(offset), 
5181        global_(global),
5182        local_(local),
5183        events_(events)
5184      {
5185      }
5186  };
5187  namespace detail {
5188  class NullType {};
5189  template<int index, typename T0>
5190  struct SetArg
5191  {
5192      static void set (Kernel kernel, T0 arg)
5193      {
5194          kernel.setArg(index, arg);
5195      }
5196  };  
5197  template<int index>
5198  struct SetArg<index, NullType>
5199  {
5200      static void set (Kernel, NullType)
5201      { 
5202      }
5203  };
5204  template <
5205     typename T0,   typename T1,   typename T2,   typename T3,
5206     typename T4,   typename T5,   typename T6,   typename T7,
5207     typename T8,   typename T9,   typename T10,   typename T11,
5208     typename T12,   typename T13,   typename T14,   typename T15,
5209     typename T16,   typename T17,   typename T18,   typename T19,
5210     typename T20,   typename T21,   typename T22,   typename T23,
5211     typename T24,   typename T25,   typename T26,   typename T27,
5212     typename T28,   typename T29,   typename T30,   typename T31
5213  >
5214  class KernelFunctorGlobal
5215  {
5216  private:
5217      Kernel kernel_;
5218  public:
5219     KernelFunctorGlobal(
5220          Kernel kernel) :
5221              kernel_(kernel)
5222      {}
5223     KernelFunctorGlobal(
5224          const Program& program,
5225          const STRING_CLASS name,
5226          cl_int * err = NULL) :
5227              kernel_(program, name.c_str(), err)
5228      {}
5229      Event operator() (
5230          const EnqueueArgs& args,
5231          T0 t0,
5232          T1 t1 = NullType(),
5233          T2 t2 = NullType(),
5234          T3 t3 = NullType(),
5235          T4 t4 = NullType(),
5236          T5 t5 = NullType(),
5237          T6 t6 = NullType(),
5238          T7 t7 = NullType(),
5239          T8 t8 = NullType(),
5240          T9 t9 = NullType(),
5241          T10 t10 = NullType(),
5242          T11 t11 = NullType(),
5243          T12 t12 = NullType(),
5244          T13 t13 = NullType(),
5245          T14 t14 = NullType(),
5246          T15 t15 = NullType(),
5247          T16 t16 = NullType(),
5248          T17 t17 = NullType(),
5249          T18 t18 = NullType(),
5250          T19 t19 = NullType(),
5251          T20 t20 = NullType(),
5252          T21 t21 = NullType(),
5253          T22 t22 = NullType(),
5254          T23 t23 = NullType(),
5255          T24 t24 = NullType(),
5256          T25 t25 = NullType(),
5257          T26 t26 = NullType(),
5258          T27 t27 = NullType(),
5259          T28 t28 = NullType(),
5260          T29 t29 = NullType(),
5261          T30 t30 = NullType(),
5262          T31 t31 = NullType()
5263          )
5264      {
5265          Event event;
5266          SetArg<0, T0>::set(kernel_, t0);
5267          SetArg<1, T1>::set(kernel_, t1);
5268          SetArg<2, T2>::set(kernel_, t2);
5269          SetArg<3, T3>::set(kernel_, t3);
5270          SetArg<4, T4>::set(kernel_, t4);
5271          SetArg<5, T5>::set(kernel_, t5);
5272          SetArg<6, T6>::set(kernel_, t6);
5273          SetArg<7, T7>::set(kernel_, t7);
5274          SetArg<8, T8>::set(kernel_, t8);
5275          SetArg<9, T9>::set(kernel_, t9);
5276          SetArg<10, T10>::set(kernel_, t10);
5277          SetArg<11, T11>::set(kernel_, t11);
5278          SetArg<12, T12>::set(kernel_, t12);
5279          SetArg<13, T13>::set(kernel_, t13);
5280          SetArg<14, T14>::set(kernel_, t14);
5281          SetArg<15, T15>::set(kernel_, t15);
5282          SetArg<16, T16>::set(kernel_, t16);
5283          SetArg<17, T17>::set(kernel_, t17);
5284          SetArg<18, T18>::set(kernel_, t18);
5285          SetArg<19, T19>::set(kernel_, t19);
5286          SetArg<20, T20>::set(kernel_, t20);
5287          SetArg<21, T21>::set(kernel_, t21);
5288          SetArg<22, T22>::set(kernel_, t22);
5289          SetArg<23, T23>::set(kernel_, t23);
5290          SetArg<24, T24>::set(kernel_, t24);
5291          SetArg<25, T25>::set(kernel_, t25);
5292          SetArg<26, T26>::set(kernel_, t26);
5293          SetArg<27, T27>::set(kernel_, t27);
5294          SetArg<28, T28>::set(kernel_, t28);
5295          SetArg<29, T29>::set(kernel_, t29);
5296          SetArg<30, T30>::set(kernel_, t30);
5297          SetArg<31, T31>::set(kernel_, t31);
5298          args.queue_.enqueueNDRangeKernel(
5299              kernel_,
5300              args.offset_,
5301              args.global_,
5302              args.local_,
5303              &args.events_,
5304              &event);
5305          return event;
5306      }
5307  };
5308  template<
5309  	typename T0,
5310  	typename T1,
5311  	typename T2,
5312  	typename T3,
5313  	typename T4,
5314  	typename T5,
5315  	typename T6,
5316  	typename T7,
5317  	typename T8,
5318  	typename T9,
5319  	typename T10,
5320  	typename T11,
5321  	typename T12,
5322  	typename T13,
5323  	typename T14,
5324  	typename T15,
5325  	typename T16,
5326  	typename T17,
5327  	typename T18,
5328  	typename T19,
5329  	typename T20,
5330  	typename T21,
5331  	typename T22,
5332  	typename T23,
5333  	typename T24,
5334  	typename T25,
5335  	typename T26,
5336  	typename T27,
5337  	typename T28,
5338  	typename T29,
5339  	typename T30,
5340  	typename T31>
5341  struct functionImplementation_
5342  {
5343  	typedef detail::KernelFunctorGlobal<
5344  		T0,
5345  		T1,
5346  		T2,
5347  		T3,
5348  		T4,
5349  		T5,
5350  		T6,
5351  		T7,
5352  		T8,
5353  		T9,
5354  		T10,
5355  		T11,
5356  		T12,
5357  		T13,
5358  		T14,
5359  		T15,
5360  		T16,
5361  		T17,
5362  		T18,
5363  		T19,
5364  		T20,
5365  		T21,
5366  		T22,
5367  		T23,
5368  		T24,
5369  		T25,
5370  		T26,
5371  		T27,
5372  		T28,
5373  		T29,
5374  		T30,
5375  		T31> FunctorType;
5376      FunctorType functor_;
5377      functionImplementation_(const FunctorType &functor) :
5378          functor_(functor)
5379      {
5380          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 32))
5381          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
5382          #endif
5383      }
5384  	typedef Event result_type;
5385  	typedef Event type_(
5386  		const EnqueueArgs&,
5387  		T0,
5388  		T1,
5389  		T2,
5390  		T3,
5391  		T4,
5392  		T5,
5393  		T6,
5394  		T7,
5395  		T8,
5396  		T9,
5397  		T10,
5398  		T11,
5399  		T12,
5400  		T13,
5401  		T14,
5402  		T15,
5403  		T16,
5404  		T17,
5405  		T18,
5406  		T19,
5407  		T20,
5408  		T21,
5409  		T22,
5410  		T23,
5411  		T24,
5412  		T25,
5413  		T26,
5414  		T27,
5415  		T28,
5416  		T29,
5417  		T30,
5418  		T31);
5419  	Event operator()(
5420  		const EnqueueArgs& enqueueArgs,
5421  		T0 arg0,
5422  		T1 arg1,
5423  		T2 arg2,
5424  		T3 arg3,
5425  		T4 arg4,
5426  		T5 arg5,
5427  		T6 arg6,
5428  		T7 arg7,
5429  		T8 arg8,
5430  		T9 arg9,
5431  		T10 arg10,
5432  		T11 arg11,
5433  		T12 arg12,
5434  		T13 arg13,
5435  		T14 arg14,
5436  		T15 arg15,
5437  		T16 arg16,
5438  		T17 arg17,
5439  		T18 arg18,
5440  		T19 arg19,
5441  		T20 arg20,
5442  		T21 arg21,
5443  		T22 arg22,
5444  		T23 arg23,
5445  		T24 arg24,
5446  		T25 arg25,
5447  		T26 arg26,
5448  		T27 arg27,
5449  		T28 arg28,
5450  		T29 arg29,
5451  		T30 arg30,
5452  		T31 arg31)
5453  	{
5454  		return functor_(
5455  			enqueueArgs,
5456  			arg0,
5457  			arg1,
5458  			arg2,
5459  			arg3,
5460  			arg4,
5461  			arg5,
5462  			arg6,
5463  			arg7,
5464  			arg8,
5465  			arg9,
5466  			arg10,
5467  			arg11,
5468  			arg12,
5469  			arg13,
5470  			arg14,
5471  			arg15,
5472  			arg16,
5473  			arg17,
5474  			arg18,
5475  			arg19,
5476  			arg20,
5477  			arg21,
5478  			arg22,
5479  			arg23,
5480  			arg24,
5481  			arg25,
5482  			arg26,
5483  			arg27,
5484  			arg28,
5485  			arg29,
5486  			arg30,
5487  			arg31);
5488  	}
5489  };
5490  template<
5491  	typename T0,
5492  	typename T1,
5493  	typename T2,
5494  	typename T3,
5495  	typename T4,
5496  	typename T5,
5497  	typename T6,
5498  	typename T7,
5499  	typename T8,
5500  	typename T9,
5501  	typename T10,
5502  	typename T11,
5503  	typename T12,
5504  	typename T13,
5505  	typename T14,
5506  	typename T15,
5507  	typename T16,
5508  	typename T17,
5509  	typename T18,
5510  	typename T19,
5511  	typename T20,
5512  	typename T21,
5513  	typename T22,
5514  	typename T23,
5515  	typename T24,
5516  	typename T25,
5517  	typename T26,
5518  	typename T27,
5519  	typename T28,
5520  	typename T29,
5521  	typename T30>
5522  struct functionImplementation_
5523  <	T0,
5524  	T1,
5525  	T2,
5526  	T3,
5527  	T4,
5528  	T5,
5529  	T6,
5530  	T7,
5531  	T8,
5532  	T9,
5533  	T10,
5534  	T11,
5535  	T12,
5536  	T13,
5537  	T14,
5538  	T15,
5539  	T16,
5540  	T17,
5541  	T18,
5542  	T19,
5543  	T20,
5544  	T21,
5545  	T22,
5546  	T23,
5547  	T24,
5548  	T25,
5549  	T26,
5550  	T27,
5551  	T28,
5552  	T29,
5553  	T30,
5554  	NullType>
5555  {
5556  	typedef detail::KernelFunctorGlobal<
5557  		T0,
5558  		T1,
5559  		T2,
5560  		T3,
5561  		T4,
5562  		T5,
5563  		T6,
5564  		T7,
5565  		T8,
5566  		T9,
5567  		T10,
5568  		T11,
5569  		T12,
5570  		T13,
5571  		T14,
5572  		T15,
5573  		T16,
5574  		T17,
5575  		T18,
5576  		T19,
5577  		T20,
5578  		T21,
5579  		T22,
5580  		T23,
5581  		T24,
5582  		T25,
5583  		T26,
5584  		T27,
5585  		T28,
5586  		T29,
5587  		T30,
5588  		NullType> FunctorType;
5589      FunctorType functor_;
5590      functionImplementation_(const FunctorType &functor) :
5591          functor_(functor)
5592      {
5593          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 31))
5594          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
5595          #endif
5596      }
5597  	typedef Event result_type;
5598  	typedef Event type_(
5599  		const EnqueueArgs&,
5600  		T0,
5601  		T1,
5602  		T2,
5603  		T3,
5604  		T4,
5605  		T5,
5606  		T6,
5607  		T7,
5608  		T8,
5609  		T9,
5610  		T10,
5611  		T11,
5612  		T12,
5613  		T13,
5614  		T14,
5615  		T15,
5616  		T16,
5617  		T17,
5618  		T18,
5619  		T19,
5620  		T20,
5621  		T21,
5622  		T22,
5623  		T23,
5624  		T24,
5625  		T25,
5626  		T26,
5627  		T27,
5628  		T28,
5629  		T29,
5630  		T30);
5631  	Event operator()(
5632  		const EnqueueArgs& enqueueArgs,
5633  		T0 arg0,
5634  		T1 arg1,
5635  		T2 arg2,
5636  		T3 arg3,
5637  		T4 arg4,
5638  		T5 arg5,
5639  		T6 arg6,
5640  		T7 arg7,
5641  		T8 arg8,
5642  		T9 arg9,
5643  		T10 arg10,
5644  		T11 arg11,
5645  		T12 arg12,
5646  		T13 arg13,
5647  		T14 arg14,
5648  		T15 arg15,
5649  		T16 arg16,
5650  		T17 arg17,
5651  		T18 arg18,
5652  		T19 arg19,
5653  		T20 arg20,
5654  		T21 arg21,
5655  		T22 arg22,
5656  		T23 arg23,
5657  		T24 arg24,
5658  		T25 arg25,
5659  		T26 arg26,
5660  		T27 arg27,
5661  		T28 arg28,
5662  		T29 arg29,
5663  		T30 arg30)
5664  	{
5665  		return functor_(
5666  			enqueueArgs,
5667  			arg0,
5668  			arg1,
5669  			arg2,
5670  			arg3,
5671  			arg4,
5672  			arg5,
5673  			arg6,
5674  			arg7,
5675  			arg8,
5676  			arg9,
5677  			arg10,
5678  			arg11,
5679  			arg12,
5680  			arg13,
5681  			arg14,
5682  			arg15,
5683  			arg16,
5684  			arg17,
5685  			arg18,
5686  			arg19,
5687  			arg20,
5688  			arg21,
5689  			arg22,
5690  			arg23,
5691  			arg24,
5692  			arg25,
5693  			arg26,
5694  			arg27,
5695  			arg28,
5696  			arg29,
5697  			arg30);
5698  	}
5699  };
5700  template<
5701  	typename T0,
5702  	typename T1,
5703  	typename T2,
5704  	typename T3,
5705  	typename T4,
5706  	typename T5,
5707  	typename T6,
5708  	typename T7,
5709  	typename T8,
5710  	typename T9,
5711  	typename T10,
5712  	typename T11,
5713  	typename T12,
5714  	typename T13,
5715  	typename T14,
5716  	typename T15,
5717  	typename T16,
5718  	typename T17,
5719  	typename T18,
5720  	typename T19,
5721  	typename T20,
5722  	typename T21,
5723  	typename T22,
5724  	typename T23,
5725  	typename T24,
5726  	typename T25,
5727  	typename T26,
5728  	typename T27,
5729  	typename T28,
5730  	typename T29>
5731  struct functionImplementation_
5732  <	T0,
5733  	T1,
5734  	T2,
5735  	T3,
5736  	T4,
5737  	T5,
5738  	T6,
5739  	T7,
5740  	T8,
5741  	T9,
5742  	T10,
5743  	T11,
5744  	T12,
5745  	T13,
5746  	T14,
5747  	T15,
5748  	T16,
5749  	T17,
5750  	T18,
5751  	T19,
5752  	T20,
5753  	T21,
5754  	T22,
5755  	T23,
5756  	T24,
5757  	T25,
5758  	T26,
5759  	T27,
5760  	T28,
5761  	T29,
5762  	NullType,
5763  	NullType>
5764  {
5765  	typedef detail::KernelFunctorGlobal<
5766  		T0,
5767  		T1,
5768  		T2,
5769  		T3,
5770  		T4,
5771  		T5,
5772  		T6,
5773  		T7,
5774  		T8,
5775  		T9,
5776  		T10,
5777  		T11,
5778  		T12,
5779  		T13,
5780  		T14,
5781  		T15,
5782  		T16,
5783  		T17,
5784  		T18,
5785  		T19,
5786  		T20,
5787  		T21,
5788  		T22,
5789  		T23,
5790  		T24,
5791  		T25,
5792  		T26,
5793  		T27,
5794  		T28,
5795  		T29,
5796  		NullType,
5797  		NullType> FunctorType;
5798      FunctorType functor_;
5799      functionImplementation_(const FunctorType &functor) :
5800          functor_(functor)
5801      {
5802          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 30))
5803          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
5804          #endif
5805      }
5806  	typedef Event result_type;
5807  	typedef Event type_(
5808  		const EnqueueArgs&,
5809  		T0,
5810  		T1,
5811  		T2,
5812  		T3,
5813  		T4,
5814  		T5,
5815  		T6,
5816  		T7,
5817  		T8,
5818  		T9,
5819  		T10,
5820  		T11,
5821  		T12,
5822  		T13,
5823  		T14,
5824  		T15,
5825  		T16,
5826  		T17,
5827  		T18,
5828  		T19,
5829  		T20,
5830  		T21,
5831  		T22,
5832  		T23,
5833  		T24,
5834  		T25,
5835  		T26,
5836  		T27,
5837  		T28,
5838  		T29);
5839  	Event operator()(
5840  		const EnqueueArgs& enqueueArgs,
5841  		T0 arg0,
5842  		T1 arg1,
5843  		T2 arg2,
5844  		T3 arg3,
5845  		T4 arg4,
5846  		T5 arg5,
5847  		T6 arg6,
5848  		T7 arg7,
5849  		T8 arg8,
5850  		T9 arg9,
5851  		T10 arg10,
5852  		T11 arg11,
5853  		T12 arg12,
5854  		T13 arg13,
5855  		T14 arg14,
5856  		T15 arg15,
5857  		T16 arg16,
5858  		T17 arg17,
5859  		T18 arg18,
5860  		T19 arg19,
5861  		T20 arg20,
5862  		T21 arg21,
5863  		T22 arg22,
5864  		T23 arg23,
5865  		T24 arg24,
5866  		T25 arg25,
5867  		T26 arg26,
5868  		T27 arg27,
5869  		T28 arg28,
5870  		T29 arg29)
5871  	{
5872  		return functor_(
5873  			enqueueArgs,
5874  			arg0,
5875  			arg1,
5876  			arg2,
5877  			arg3,
5878  			arg4,
5879  			arg5,
5880  			arg6,
5881  			arg7,
5882  			arg8,
5883  			arg9,
5884  			arg10,
5885  			arg11,
5886  			arg12,
5887  			arg13,
5888  			arg14,
5889  			arg15,
5890  			arg16,
5891  			arg17,
5892  			arg18,
5893  			arg19,
5894  			arg20,
5895  			arg21,
5896  			arg22,
5897  			arg23,
5898  			arg24,
5899  			arg25,
5900  			arg26,
5901  			arg27,
5902  			arg28,
5903  			arg29);
5904  	}
5905  };
5906  template<
5907  	typename T0,
5908  	typename T1,
5909  	typename T2,
5910  	typename T3,
5911  	typename T4,
5912  	typename T5,
5913  	typename T6,
5914  	typename T7,
5915  	typename T8,
5916  	typename T9,
5917  	typename T10,
5918  	typename T11,
5919  	typename T12,
5920  	typename T13,
5921  	typename T14,
5922  	typename T15,
5923  	typename T16,
5924  	typename T17,
5925  	typename T18,
5926  	typename T19,
5927  	typename T20,
5928  	typename T21,
5929  	typename T22,
5930  	typename T23,
5931  	typename T24,
5932  	typename T25,
5933  	typename T26,
5934  	typename T27,
5935  	typename T28>
5936  struct functionImplementation_
5937  <	T0,
5938  	T1,
5939  	T2,
5940  	T3,
5941  	T4,
5942  	T5,
5943  	T6,
5944  	T7,
5945  	T8,
5946  	T9,
5947  	T10,
5948  	T11,
5949  	T12,
5950  	T13,
5951  	T14,
5952  	T15,
5953  	T16,
5954  	T17,
5955  	T18,
5956  	T19,
5957  	T20,
5958  	T21,
5959  	T22,
5960  	T23,
5961  	T24,
5962  	T25,
5963  	T26,
5964  	T27,
5965  	T28,
5966  	NullType,
5967  	NullType,
5968  	NullType>
5969  {
5970  	typedef detail::KernelFunctorGlobal<
5971  		T0,
5972  		T1,
5973  		T2,
5974  		T3,
5975  		T4,
5976  		T5,
5977  		T6,
5978  		T7,
5979  		T8,
5980  		T9,
5981  		T10,
5982  		T11,
5983  		T12,
5984  		T13,
5985  		T14,
5986  		T15,
5987  		T16,
5988  		T17,
5989  		T18,
5990  		T19,
5991  		T20,
5992  		T21,
5993  		T22,
5994  		T23,
5995  		T24,
5996  		T25,
5997  		T26,
5998  		T27,
5999  		T28,
6000  		NullType,
6001  		NullType,
6002  		NullType> FunctorType;
6003      FunctorType functor_;
6004      functionImplementation_(const FunctorType &functor) :
6005          functor_(functor)
6006      {
6007          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 29))
6008          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
6009          #endif
6010      }
6011  	typedef Event result_type;
6012  	typedef Event type_(
6013  		const EnqueueArgs&,
6014  		T0,
6015  		T1,
6016  		T2,
6017  		T3,
6018  		T4,
6019  		T5,
6020  		T6,
6021  		T7,
6022  		T8,
6023  		T9,
6024  		T10,
6025  		T11,
6026  		T12,
6027  		T13,
6028  		T14,
6029  		T15,
6030  		T16,
6031  		T17,
6032  		T18,
6033  		T19,
6034  		T20,
6035  		T21,
6036  		T22,
6037  		T23,
6038  		T24,
6039  		T25,
6040  		T26,
6041  		T27,
6042  		T28);
6043  	Event operator()(
6044  		const EnqueueArgs& enqueueArgs,
6045  		T0 arg0,
6046  		T1 arg1,
6047  		T2 arg2,
6048  		T3 arg3,
6049  		T4 arg4,
6050  		T5 arg5,
6051  		T6 arg6,
6052  		T7 arg7,
6053  		T8 arg8,
6054  		T9 arg9,
6055  		T10 arg10,
6056  		T11 arg11,
6057  		T12 arg12,
6058  		T13 arg13,
6059  		T14 arg14,
6060  		T15 arg15,
6061  		T16 arg16,
6062  		T17 arg17,
6063  		T18 arg18,
6064  		T19 arg19,
6065  		T20 arg20,
6066  		T21 arg21,
6067  		T22 arg22,
6068  		T23 arg23,
6069  		T24 arg24,
6070  		T25 arg25,
6071  		T26 arg26,
6072  		T27 arg27,
6073  		T28 arg28)
6074  	{
6075  		return functor_(
6076  			enqueueArgs,
6077  			arg0,
6078  			arg1,
6079  			arg2,
6080  			arg3,
6081  			arg4,
6082  			arg5,
6083  			arg6,
6084  			arg7,
6085  			arg8,
6086  			arg9,
6087  			arg10,
6088  			arg11,
6089  			arg12,
6090  			arg13,
6091  			arg14,
6092  			arg15,
6093  			arg16,
6094  			arg17,
6095  			arg18,
6096  			arg19,
6097  			arg20,
6098  			arg21,
6099  			arg22,
6100  			arg23,
6101  			arg24,
6102  			arg25,
6103  			arg26,
6104  			arg27,
6105  			arg28);
6106  	}
6107  };
6108  template<
6109  	typename T0,
6110  	typename T1,
6111  	typename T2,
6112  	typename T3,
6113  	typename T4,
6114  	typename T5,
6115  	typename T6,
6116  	typename T7,
6117  	typename T8,
6118  	typename T9,
6119  	typename T10,
6120  	typename T11,
6121  	typename T12,
6122  	typename T13,
6123  	typename T14,
6124  	typename T15,
6125  	typename T16,
6126  	typename T17,
6127  	typename T18,
6128  	typename T19,
6129  	typename T20,
6130  	typename T21,
6131  	typename T22,
6132  	typename T23,
6133  	typename T24,
6134  	typename T25,
6135  	typename T26,
6136  	typename T27>
6137  struct functionImplementation_
6138  <	T0,
6139  	T1,
6140  	T2,
6141  	T3,
6142  	T4,
6143  	T5,
6144  	T6,
6145  	T7,
6146  	T8,
6147  	T9,
6148  	T10,
6149  	T11,
6150  	T12,
6151  	T13,
6152  	T14,
6153  	T15,
6154  	T16,
6155  	T17,
6156  	T18,
6157  	T19,
6158  	T20,
6159  	T21,
6160  	T22,
6161  	T23,
6162  	T24,
6163  	T25,
6164  	T26,
6165  	T27,
6166  	NullType,
6167  	NullType,
6168  	NullType,
6169  	NullType>
6170  {
6171  	typedef detail::KernelFunctorGlobal<
6172  		T0,
6173  		T1,
6174  		T2,
6175  		T3,
6176  		T4,
6177  		T5,
6178  		T6,
6179  		T7,
6180  		T8,
6181  		T9,
6182  		T10,
6183  		T11,
6184  		T12,
6185  		T13,
6186  		T14,
6187  		T15,
6188  		T16,
6189  		T17,
6190  		T18,
6191  		T19,
6192  		T20,
6193  		T21,
6194  		T22,
6195  		T23,
6196  		T24,
6197  		T25,
6198  		T26,
6199  		T27,
6200  		NullType,
6201  		NullType,
6202  		NullType,
6203  		NullType> FunctorType;
6204      FunctorType functor_;
6205      functionImplementation_(const FunctorType &functor) :
6206          functor_(functor)
6207      {
6208          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 28))
6209          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
6210          #endif
6211      }
6212  	typedef Event result_type;
6213  	typedef Event type_(
6214  		const EnqueueArgs&,
6215  		T0,
6216  		T1,
6217  		T2,
6218  		T3,
6219  		T4,
6220  		T5,
6221  		T6,
6222  		T7,
6223  		T8,
6224  		T9,
6225  		T10,
6226  		T11,
6227  		T12,
6228  		T13,
6229  		T14,
6230  		T15,
6231  		T16,
6232  		T17,
6233  		T18,
6234  		T19,
6235  		T20,
6236  		T21,
6237  		T22,
6238  		T23,
6239  		T24,
6240  		T25,
6241  		T26,
6242  		T27);
6243  	Event operator()(
6244  		const EnqueueArgs& enqueueArgs,
6245  		T0 arg0,
6246  		T1 arg1,
6247  		T2 arg2,
6248  		T3 arg3,
6249  		T4 arg4,
6250  		T5 arg5,
6251  		T6 arg6,
6252  		T7 arg7,
6253  		T8 arg8,
6254  		T9 arg9,
6255  		T10 arg10,
6256  		T11 arg11,
6257  		T12 arg12,
6258  		T13 arg13,
6259  		T14 arg14,
6260  		T15 arg15,
6261  		T16 arg16,
6262  		T17 arg17,
6263  		T18 arg18,
6264  		T19 arg19,
6265  		T20 arg20,
6266  		T21 arg21,
6267  		T22 arg22,
6268  		T23 arg23,
6269  		T24 arg24,
6270  		T25 arg25,
6271  		T26 arg26,
6272  		T27 arg27)
6273  	{
6274  		return functor_(
6275  			enqueueArgs,
6276  			arg0,
6277  			arg1,
6278  			arg2,
6279  			arg3,
6280  			arg4,
6281  			arg5,
6282  			arg6,
6283  			arg7,
6284  			arg8,
6285  			arg9,
6286  			arg10,
6287  			arg11,
6288  			arg12,
6289  			arg13,
6290  			arg14,
6291  			arg15,
6292  			arg16,
6293  			arg17,
6294  			arg18,
6295  			arg19,
6296  			arg20,
6297  			arg21,
6298  			arg22,
6299  			arg23,
6300  			arg24,
6301  			arg25,
6302  			arg26,
6303  			arg27);
6304  	}
6305  };
6306  template<
6307  	typename T0,
6308  	typename T1,
6309  	typename T2,
6310  	typename T3,
6311  	typename T4,
6312  	typename T5,
6313  	typename T6,
6314  	typename T7,
6315  	typename T8,
6316  	typename T9,
6317  	typename T10,
6318  	typename T11,
6319  	typename T12,
6320  	typename T13,
6321  	typename T14,
6322  	typename T15,
6323  	typename T16,
6324  	typename T17,
6325  	typename T18,
6326  	typename T19,
6327  	typename T20,
6328  	typename T21,
6329  	typename T22,
6330  	typename T23,
6331  	typename T24,
6332  	typename T25,
6333  	typename T26>
6334  struct functionImplementation_
6335  <	T0,
6336  	T1,
6337  	T2,
6338  	T3,
6339  	T4,
6340  	T5,
6341  	T6,
6342  	T7,
6343  	T8,
6344  	T9,
6345  	T10,
6346  	T11,
6347  	T12,
6348  	T13,
6349  	T14,
6350  	T15,
6351  	T16,
6352  	T17,
6353  	T18,
6354  	T19,
6355  	T20,
6356  	T21,
6357  	T22,
6358  	T23,
6359  	T24,
6360  	T25,
6361  	T26,
6362  	NullType,
6363  	NullType,
6364  	NullType,
6365  	NullType,
6366  	NullType>
6367  {
6368  	typedef detail::KernelFunctorGlobal<
6369  		T0,
6370  		T1,
6371  		T2,
6372  		T3,
6373  		T4,
6374  		T5,
6375  		T6,
6376  		T7,
6377  		T8,
6378  		T9,
6379  		T10,
6380  		T11,
6381  		T12,
6382  		T13,
6383  		T14,
6384  		T15,
6385  		T16,
6386  		T17,
6387  		T18,
6388  		T19,
6389  		T20,
6390  		T21,
6391  		T22,
6392  		T23,
6393  		T24,
6394  		T25,
6395  		T26,
6396  		NullType,
6397  		NullType,
6398  		NullType,
6399  		NullType,
6400  		NullType> FunctorType;
6401      FunctorType functor_;
6402      functionImplementation_(const FunctorType &functor) :
6403          functor_(functor)
6404      {
6405          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 27))
6406          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
6407          #endif
6408      }
6409  	typedef Event result_type;
6410  	typedef Event type_(
6411  		const EnqueueArgs&,
6412  		T0,
6413  		T1,
6414  		T2,
6415  		T3,
6416  		T4,
6417  		T5,
6418  		T6,
6419  		T7,
6420  		T8,
6421  		T9,
6422  		T10,
6423  		T11,
6424  		T12,
6425  		T13,
6426  		T14,
6427  		T15,
6428  		T16,
6429  		T17,
6430  		T18,
6431  		T19,
6432  		T20,
6433  		T21,
6434  		T22,
6435  		T23,
6436  		T24,
6437  		T25,
6438  		T26);
6439  	Event operator()(
6440  		const EnqueueArgs& enqueueArgs,
6441  		T0 arg0,
6442  		T1 arg1,
6443  		T2 arg2,
6444  		T3 arg3,
6445  		T4 arg4,
6446  		T5 arg5,
6447  		T6 arg6,
6448  		T7 arg7,
6449  		T8 arg8,
6450  		T9 arg9,
6451  		T10 arg10,
6452  		T11 arg11,
6453  		T12 arg12,
6454  		T13 arg13,
6455  		T14 arg14,
6456  		T15 arg15,
6457  		T16 arg16,
6458  		T17 arg17,
6459  		T18 arg18,
6460  		T19 arg19,
6461  		T20 arg20,
6462  		T21 arg21,
6463  		T22 arg22,
6464  		T23 arg23,
6465  		T24 arg24,
6466  		T25 arg25,
6467  		T26 arg26)
6468  	{
6469  		return functor_(
6470  			enqueueArgs,
6471  			arg0,
6472  			arg1,
6473  			arg2,
6474  			arg3,
6475  			arg4,
6476  			arg5,
6477  			arg6,
6478  			arg7,
6479  			arg8,
6480  			arg9,
6481  			arg10,
6482  			arg11,
6483  			arg12,
6484  			arg13,
6485  			arg14,
6486  			arg15,
6487  			arg16,
6488  			arg17,
6489  			arg18,
6490  			arg19,
6491  			arg20,
6492  			arg21,
6493  			arg22,
6494  			arg23,
6495  			arg24,
6496  			arg25,
6497  			arg26);
6498  	}
6499  };
6500  template<
6501  	typename T0,
6502  	typename T1,
6503  	typename T2,
6504  	typename T3,
6505  	typename T4,
6506  	typename T5,
6507  	typename T6,
6508  	typename T7,
6509  	typename T8,
6510  	typename T9,
6511  	typename T10,
6512  	typename T11,
6513  	typename T12,
6514  	typename T13,
6515  	typename T14,
6516  	typename T15,
6517  	typename T16,
6518  	typename T17,
6519  	typename T18,
6520  	typename T19,
6521  	typename T20,
6522  	typename T21,
6523  	typename T22,
6524  	typename T23,
6525  	typename T24,
6526  	typename T25>
6527  struct functionImplementation_
6528  <	T0,
6529  	T1,
6530  	T2,
6531  	T3,
6532  	T4,
6533  	T5,
6534  	T6,
6535  	T7,
6536  	T8,
6537  	T9,
6538  	T10,
6539  	T11,
6540  	T12,
6541  	T13,
6542  	T14,
6543  	T15,
6544  	T16,
6545  	T17,
6546  	T18,
6547  	T19,
6548  	T20,
6549  	T21,
6550  	T22,
6551  	T23,
6552  	T24,
6553  	T25,
6554  	NullType,
6555  	NullType,
6556  	NullType,
6557  	NullType,
6558  	NullType,
6559  	NullType>
6560  {
6561  	typedef detail::KernelFunctorGlobal<
6562  		T0,
6563  		T1,
6564  		T2,
6565  		T3,
6566  		T4,
6567  		T5,
6568  		T6,
6569  		T7,
6570  		T8,
6571  		T9,
6572  		T10,
6573  		T11,
6574  		T12,
6575  		T13,
6576  		T14,
6577  		T15,
6578  		T16,
6579  		T17,
6580  		T18,
6581  		T19,
6582  		T20,
6583  		T21,
6584  		T22,
6585  		T23,
6586  		T24,
6587  		T25,
6588  		NullType,
6589  		NullType,
6590  		NullType,
6591  		NullType,
6592  		NullType,
6593  		NullType> FunctorType;
6594      FunctorType functor_;
6595      functionImplementation_(const FunctorType &functor) :
6596          functor_(functor)
6597      {
6598          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 26))
6599          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
6600          #endif
6601      }
6602  	typedef Event result_type;
6603  	typedef Event type_(
6604  		const EnqueueArgs&,
6605  		T0,
6606  		T1,
6607  		T2,
6608  		T3,
6609  		T4,
6610  		T5,
6611  		T6,
6612  		T7,
6613  		T8,
6614  		T9,
6615  		T10,
6616  		T11,
6617  		T12,
6618  		T13,
6619  		T14,
6620  		T15,
6621  		T16,
6622  		T17,
6623  		T18,
6624  		T19,
6625  		T20,
6626  		T21,
6627  		T22,
6628  		T23,
6629  		T24,
6630  		T25);
6631  	Event operator()(
6632  		const EnqueueArgs& enqueueArgs,
6633  		T0 arg0,
6634  		T1 arg1,
6635  		T2 arg2,
6636  		T3 arg3,
6637  		T4 arg4,
6638  		T5 arg5,
6639  		T6 arg6,
6640  		T7 arg7,
6641  		T8 arg8,
6642  		T9 arg9,
6643  		T10 arg10,
6644  		T11 arg11,
6645  		T12 arg12,
6646  		T13 arg13,
6647  		T14 arg14,
6648  		T15 arg15,
6649  		T16 arg16,
6650  		T17 arg17,
6651  		T18 arg18,
6652  		T19 arg19,
6653  		T20 arg20,
6654  		T21 arg21,
6655  		T22 arg22,
6656  		T23 arg23,
6657  		T24 arg24,
6658  		T25 arg25)
6659  	{
6660  		return functor_(
6661  			enqueueArgs,
6662  			arg0,
6663  			arg1,
6664  			arg2,
6665  			arg3,
6666  			arg4,
6667  			arg5,
6668  			arg6,
6669  			arg7,
6670  			arg8,
6671  			arg9,
6672  			arg10,
6673  			arg11,
6674  			arg12,
6675  			arg13,
6676  			arg14,
6677  			arg15,
6678  			arg16,
6679  			arg17,
6680  			arg18,
6681  			arg19,
6682  			arg20,
6683  			arg21,
6684  			arg22,
6685  			arg23,
6686  			arg24,
6687  			arg25);
6688  	}
6689  };
6690  template<
6691  	typename T0,
6692  	typename T1,
6693  	typename T2,
6694  	typename T3,
6695  	typename T4,
6696  	typename T5,
6697  	typename T6,
6698  	typename T7,
6699  	typename T8,
6700  	typename T9,
6701  	typename T10,
6702  	typename T11,
6703  	typename T12,
6704  	typename T13,
6705  	typename T14,
6706  	typename T15,
6707  	typename T16,
6708  	typename T17,
6709  	typename T18,
6710  	typename T19,
6711  	typename T20,
6712  	typename T21,
6713  	typename T22,
6714  	typename T23,
6715  	typename T24>
6716  struct functionImplementation_
6717  <	T0,
6718  	T1,
6719  	T2,
6720  	T3,
6721  	T4,
6722  	T5,
6723  	T6,
6724  	T7,
6725  	T8,
6726  	T9,
6727  	T10,
6728  	T11,
6729  	T12,
6730  	T13,
6731  	T14,
6732  	T15,
6733  	T16,
6734  	T17,
6735  	T18,
6736  	T19,
6737  	T20,
6738  	T21,
6739  	T22,
6740  	T23,
6741  	T24,
6742  	NullType,
6743  	NullType,
6744  	NullType,
6745  	NullType,
6746  	NullType,
6747  	NullType,
6748  	NullType>
6749  {
6750  	typedef detail::KernelFunctorGlobal<
6751  		T0,
6752  		T1,
6753  		T2,
6754  		T3,
6755  		T4,
6756  		T5,
6757  		T6,
6758  		T7,
6759  		T8,
6760  		T9,
6761  		T10,
6762  		T11,
6763  		T12,
6764  		T13,
6765  		T14,
6766  		T15,
6767  		T16,
6768  		T17,
6769  		T18,
6770  		T19,
6771  		T20,
6772  		T21,
6773  		T22,
6774  		T23,
6775  		T24,
6776  		NullType,
6777  		NullType,
6778  		NullType,
6779  		NullType,
6780  		NullType,
6781  		NullType,
6782  		NullType> FunctorType;
6783      FunctorType functor_;
6784      functionImplementation_(const FunctorType &functor) :
6785          functor_(functor)
6786      {
6787          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 25))
6788          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
6789          #endif
6790      }
6791  	typedef Event result_type;
6792  	typedef Event type_(
6793  		const EnqueueArgs&,
6794  		T0,
6795  		T1,
6796  		T2,
6797  		T3,
6798  		T4,
6799  		T5,
6800  		T6,
6801  		T7,
6802  		T8,
6803  		T9,
6804  		T10,
6805  		T11,
6806  		T12,
6807  		T13,
6808  		T14,
6809  		T15,
6810  		T16,
6811  		T17,
6812  		T18,
6813  		T19,
6814  		T20,
6815  		T21,
6816  		T22,
6817  		T23,
6818  		T24);
6819  	Event operator()(
6820  		const EnqueueArgs& enqueueArgs,
6821  		T0 arg0,
6822  		T1 arg1,
6823  		T2 arg2,
6824  		T3 arg3,
6825  		T4 arg4,
6826  		T5 arg5,
6827  		T6 arg6,
6828  		T7 arg7,
6829  		T8 arg8,
6830  		T9 arg9,
6831  		T10 arg10,
6832  		T11 arg11,
6833  		T12 arg12,
6834  		T13 arg13,
6835  		T14 arg14,
6836  		T15 arg15,
6837  		T16 arg16,
6838  		T17 arg17,
6839  		T18 arg18,
6840  		T19 arg19,
6841  		T20 arg20,
6842  		T21 arg21,
6843  		T22 arg22,
6844  		T23 arg23,
6845  		T24 arg24)
6846  	{
6847  		return functor_(
6848  			enqueueArgs,
6849  			arg0,
6850  			arg1,
6851  			arg2,
6852  			arg3,
6853  			arg4,
6854  			arg5,
6855  			arg6,
6856  			arg7,
6857  			arg8,
6858  			arg9,
6859  			arg10,
6860  			arg11,
6861  			arg12,
6862  			arg13,
6863  			arg14,
6864  			arg15,
6865  			arg16,
6866  			arg17,
6867  			arg18,
6868  			arg19,
6869  			arg20,
6870  			arg21,
6871  			arg22,
6872  			arg23,
6873  			arg24);
6874  	}
6875  };
6876  template<
6877  	typename T0,
6878  	typename T1,
6879  	typename T2,
6880  	typename T3,
6881  	typename T4,
6882  	typename T5,
6883  	typename T6,
6884  	typename T7,
6885  	typename T8,
6886  	typename T9,
6887  	typename T10,
6888  	typename T11,
6889  	typename T12,
6890  	typename T13,
6891  	typename T14,
6892  	typename T15,
6893  	typename T16,
6894  	typename T17,
6895  	typename T18,
6896  	typename T19,
6897  	typename T20,
6898  	typename T21,
6899  	typename T22,
6900  	typename T23>
6901  struct functionImplementation_
6902  <	T0,
6903  	T1,
6904  	T2,
6905  	T3,
6906  	T4,
6907  	T5,
6908  	T6,
6909  	T7,
6910  	T8,
6911  	T9,
6912  	T10,
6913  	T11,
6914  	T12,
6915  	T13,
6916  	T14,
6917  	T15,
6918  	T16,
6919  	T17,
6920  	T18,
6921  	T19,
6922  	T20,
6923  	T21,
6924  	T22,
6925  	T23,
6926  	NullType,
6927  	NullType,
6928  	NullType,
6929  	NullType,
6930  	NullType,
6931  	NullType,
6932  	NullType,
6933  	NullType>
6934  {
6935  	typedef detail::KernelFunctorGlobal<
6936  		T0,
6937  		T1,
6938  		T2,
6939  		T3,
6940  		T4,
6941  		T5,
6942  		T6,
6943  		T7,
6944  		T8,
6945  		T9,
6946  		T10,
6947  		T11,
6948  		T12,
6949  		T13,
6950  		T14,
6951  		T15,
6952  		T16,
6953  		T17,
6954  		T18,
6955  		T19,
6956  		T20,
6957  		T21,
6958  		T22,
6959  		T23,
6960  		NullType,
6961  		NullType,
6962  		NullType,
6963  		NullType,
6964  		NullType,
6965  		NullType,
6966  		NullType,
6967  		NullType> FunctorType;
6968      FunctorType functor_;
6969      functionImplementation_(const FunctorType &functor) :
6970          functor_(functor)
6971      {
6972          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 24))
6973          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
6974          #endif
6975      }
6976  	typedef Event result_type;
6977  	typedef Event type_(
6978  		const EnqueueArgs&,
6979  		T0,
6980  		T1,
6981  		T2,
6982  		T3,
6983  		T4,
6984  		T5,
6985  		T6,
6986  		T7,
6987  		T8,
6988  		T9,
6989  		T10,
6990  		T11,
6991  		T12,
6992  		T13,
6993  		T14,
6994  		T15,
6995  		T16,
6996  		T17,
6997  		T18,
6998  		T19,
6999  		T20,
7000  		T21,
7001  		T22,
7002  		T23);
7003  	Event operator()(
7004  		const EnqueueArgs& enqueueArgs,
7005  		T0 arg0,
7006  		T1 arg1,
7007  		T2 arg2,
7008  		T3 arg3,
7009  		T4 arg4,
7010  		T5 arg5,
7011  		T6 arg6,
7012  		T7 arg7,
7013  		T8 arg8,
7014  		T9 arg9,
7015  		T10 arg10,
7016  		T11 arg11,
7017  		T12 arg12,
7018  		T13 arg13,
7019  		T14 arg14,
7020  		T15 arg15,
7021  		T16 arg16,
7022  		T17 arg17,
7023  		T18 arg18,
7024  		T19 arg19,
7025  		T20 arg20,
7026  		T21 arg21,
7027  		T22 arg22,
7028  		T23 arg23)
7029  	{
7030  		return functor_(
7031  			enqueueArgs,
7032  			arg0,
7033  			arg1,
7034  			arg2,
7035  			arg3,
7036  			arg4,
7037  			arg5,
7038  			arg6,
7039  			arg7,
7040  			arg8,
7041  			arg9,
7042  			arg10,
7043  			arg11,
7044  			arg12,
7045  			arg13,
7046  			arg14,
7047  			arg15,
7048  			arg16,
7049  			arg17,
7050  			arg18,
7051  			arg19,
7052  			arg20,
7053  			arg21,
7054  			arg22,
7055  			arg23);
7056  	}
7057  };
7058  template<
7059  	typename T0,
7060  	typename T1,
7061  	typename T2,
7062  	typename T3,
7063  	typename T4,
7064  	typename T5,
7065  	typename T6,
7066  	typename T7,
7067  	typename T8,
7068  	typename T9,
7069  	typename T10,
7070  	typename T11,
7071  	typename T12,
7072  	typename T13,
7073  	typename T14,
7074  	typename T15,
7075  	typename T16,
7076  	typename T17,
7077  	typename T18,
7078  	typename T19,
7079  	typename T20,
7080  	typename T21,
7081  	typename T22>
7082  struct functionImplementation_
7083  <	T0,
7084  	T1,
7085  	T2,
7086  	T3,
7087  	T4,
7088  	T5,
7089  	T6,
7090  	T7,
7091  	T8,
7092  	T9,
7093  	T10,
7094  	T11,
7095  	T12,
7096  	T13,
7097  	T14,
7098  	T15,
7099  	T16,
7100  	T17,
7101  	T18,
7102  	T19,
7103  	T20,
7104  	T21,
7105  	T22,
7106  	NullType,
7107  	NullType,
7108  	NullType,
7109  	NullType,
7110  	NullType,
7111  	NullType,
7112  	NullType,
7113  	NullType,
7114  	NullType>
7115  {
7116  	typedef detail::KernelFunctorGlobal<
7117  		T0,
7118  		T1,
7119  		T2,
7120  		T3,
7121  		T4,
7122  		T5,
7123  		T6,
7124  		T7,
7125  		T8,
7126  		T9,
7127  		T10,
7128  		T11,
7129  		T12,
7130  		T13,
7131  		T14,
7132  		T15,
7133  		T16,
7134  		T17,
7135  		T18,
7136  		T19,
7137  		T20,
7138  		T21,
7139  		T22,
7140  		NullType,
7141  		NullType,
7142  		NullType,
7143  		NullType,
7144  		NullType,
7145  		NullType,
7146  		NullType,
7147  		NullType,
7148  		NullType> FunctorType;
7149      FunctorType functor_;
7150      functionImplementation_(const FunctorType &functor) :
7151          functor_(functor)
7152      {
7153          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 23))
7154          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
7155          #endif
7156      }
7157  	typedef Event result_type;
7158  	typedef Event type_(
7159  		const EnqueueArgs&,
7160  		T0,
7161  		T1,
7162  		T2,
7163  		T3,
7164  		T4,
7165  		T5,
7166  		T6,
7167  		T7,
7168  		T8,
7169  		T9,
7170  		T10,
7171  		T11,
7172  		T12,
7173  		T13,
7174  		T14,
7175  		T15,
7176  		T16,
7177  		T17,
7178  		T18,
7179  		T19,
7180  		T20,
7181  		T21,
7182  		T22);
7183  	Event operator()(
7184  		const EnqueueArgs& enqueueArgs,
7185  		T0 arg0,
7186  		T1 arg1,
7187  		T2 arg2,
7188  		T3 arg3,
7189  		T4 arg4,
7190  		T5 arg5,
7191  		T6 arg6,
7192  		T7 arg7,
7193  		T8 arg8,
7194  		T9 arg9,
7195  		T10 arg10,
7196  		T11 arg11,
7197  		T12 arg12,
7198  		T13 arg13,
7199  		T14 arg14,
7200  		T15 arg15,
7201  		T16 arg16,
7202  		T17 arg17,
7203  		T18 arg18,
7204  		T19 arg19,
7205  		T20 arg20,
7206  		T21 arg21,
7207  		T22 arg22)
7208  	{
7209  		return functor_(
7210  			enqueueArgs,
7211  			arg0,
7212  			arg1,
7213  			arg2,
7214  			arg3,
7215  			arg4,
7216  			arg5,
7217  			arg6,
7218  			arg7,
7219  			arg8,
7220  			arg9,
7221  			arg10,
7222  			arg11,
7223  			arg12,
7224  			arg13,
7225  			arg14,
7226  			arg15,
7227  			arg16,
7228  			arg17,
7229  			arg18,
7230  			arg19,
7231  			arg20,
7232  			arg21,
7233  			arg22);
7234  	}
7235  };
7236  template<
7237  	typename T0,
7238  	typename T1,
7239  	typename T2,
7240  	typename T3,
7241  	typename T4,
7242  	typename T5,
7243  	typename T6,
7244  	typename T7,
7245  	typename T8,
7246  	typename T9,
7247  	typename T10,
7248  	typename T11,
7249  	typename T12,
7250  	typename T13,
7251  	typename T14,
7252  	typename T15,
7253  	typename T16,
7254  	typename T17,
7255  	typename T18,
7256  	typename T19,
7257  	typename T20,
7258  	typename T21>
7259  struct functionImplementation_
7260  <	T0,
7261  	T1,
7262  	T2,
7263  	T3,
7264  	T4,
7265  	T5,
7266  	T6,
7267  	T7,
7268  	T8,
7269  	T9,
7270  	T10,
7271  	T11,
7272  	T12,
7273  	T13,
7274  	T14,
7275  	T15,
7276  	T16,
7277  	T17,
7278  	T18,
7279  	T19,
7280  	T20,
7281  	T21,
7282  	NullType,
7283  	NullType,
7284  	NullType,
7285  	NullType,
7286  	NullType,
7287  	NullType,
7288  	NullType,
7289  	NullType,
7290  	NullType,
7291  	NullType>
7292  {
7293  	typedef detail::KernelFunctorGlobal<
7294  		T0,
7295  		T1,
7296  		T2,
7297  		T3,
7298  		T4,
7299  		T5,
7300  		T6,
7301  		T7,
7302  		T8,
7303  		T9,
7304  		T10,
7305  		T11,
7306  		T12,
7307  		T13,
7308  		T14,
7309  		T15,
7310  		T16,
7311  		T17,
7312  		T18,
7313  		T19,
7314  		T20,
7315  		T21,
7316  		NullType,
7317  		NullType,
7318  		NullType,
7319  		NullType,
7320  		NullType,
7321  		NullType,
7322  		NullType,
7323  		NullType,
7324  		NullType,
7325  		NullType> FunctorType;
7326      FunctorType functor_;
7327      functionImplementation_(const FunctorType &functor) :
7328          functor_(functor)
7329      {
7330          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 22))
7331          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
7332          #endif
7333      }
7334  	typedef Event result_type;
7335  	typedef Event type_(
7336  		const EnqueueArgs&,
7337  		T0,
7338  		T1,
7339  		T2,
7340  		T3,
7341  		T4,
7342  		T5,
7343  		T6,
7344  		T7,
7345  		T8,
7346  		T9,
7347  		T10,
7348  		T11,
7349  		T12,
7350  		T13,
7351  		T14,
7352  		T15,
7353  		T16,
7354  		T17,
7355  		T18,
7356  		T19,
7357  		T20,
7358  		T21);
7359  	Event operator()(
7360  		const EnqueueArgs& enqueueArgs,
7361  		T0 arg0,
7362  		T1 arg1,
7363  		T2 arg2,
7364  		T3 arg3,
7365  		T4 arg4,
7366  		T5 arg5,
7367  		T6 arg6,
7368  		T7 arg7,
7369  		T8 arg8,
7370  		T9 arg9,
7371  		T10 arg10,
7372  		T11 arg11,
7373  		T12 arg12,
7374  		T13 arg13,
7375  		T14 arg14,
7376  		T15 arg15,
7377  		T16 arg16,
7378  		T17 arg17,
7379  		T18 arg18,
7380  		T19 arg19,
7381  		T20 arg20,
7382  		T21 arg21)
7383  	{
7384  		return functor_(
7385  			enqueueArgs,
7386  			arg0,
7387  			arg1,
7388  			arg2,
7389  			arg3,
7390  			arg4,
7391  			arg5,
7392  			arg6,
7393  			arg7,
7394  			arg8,
7395  			arg9,
7396  			arg10,
7397  			arg11,
7398  			arg12,
7399  			arg13,
7400  			arg14,
7401  			arg15,
7402  			arg16,
7403  			arg17,
7404  			arg18,
7405  			arg19,
7406  			arg20,
7407  			arg21);
7408  	}
7409  };
7410  template<
7411  	typename T0,
7412  	typename T1,
7413  	typename T2,
7414  	typename T3,
7415  	typename T4,
7416  	typename T5,
7417  	typename T6,
7418  	typename T7,
7419  	typename T8,
7420  	typename T9,
7421  	typename T10,
7422  	typename T11,
7423  	typename T12,
7424  	typename T13,
7425  	typename T14,
7426  	typename T15,
7427  	typename T16,
7428  	typename T17,
7429  	typename T18,
7430  	typename T19,
7431  	typename T20>
7432  struct functionImplementation_
7433  <	T0,
7434  	T1,
7435  	T2,
7436  	T3,
7437  	T4,
7438  	T5,
7439  	T6,
7440  	T7,
7441  	T8,
7442  	T9,
7443  	T10,
7444  	T11,
7445  	T12,
7446  	T13,
7447  	T14,
7448  	T15,
7449  	T16,
7450  	T17,
7451  	T18,
7452  	T19,
7453  	T20,
7454  	NullType,
7455  	NullType,
7456  	NullType,
7457  	NullType,
7458  	NullType,
7459  	NullType,
7460  	NullType,
7461  	NullType,
7462  	NullType,
7463  	NullType,
7464  	NullType>
7465  {
7466  	typedef detail::KernelFunctorGlobal<
7467  		T0,
7468  		T1,
7469  		T2,
7470  		T3,
7471  		T4,
7472  		T5,
7473  		T6,
7474  		T7,
7475  		T8,
7476  		T9,
7477  		T10,
7478  		T11,
7479  		T12,
7480  		T13,
7481  		T14,
7482  		T15,
7483  		T16,
7484  		T17,
7485  		T18,
7486  		T19,
7487  		T20,
7488  		NullType,
7489  		NullType,
7490  		NullType,
7491  		NullType,
7492  		NullType,
7493  		NullType,
7494  		NullType,
7495  		NullType,
7496  		NullType,
7497  		NullType,
7498  		NullType> FunctorType;
7499      FunctorType functor_;
7500      functionImplementation_(const FunctorType &functor) :
7501          functor_(functor)
7502      {
7503          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 21))
7504          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
7505          #endif
7506      }
7507  	typedef Event result_type;
7508  	typedef Event type_(
7509  		const EnqueueArgs&,
7510  		T0,
7511  		T1,
7512  		T2,
7513  		T3,
7514  		T4,
7515  		T5,
7516  		T6,
7517  		T7,
7518  		T8,
7519  		T9,
7520  		T10,
7521  		T11,
7522  		T12,
7523  		T13,
7524  		T14,
7525  		T15,
7526  		T16,
7527  		T17,
7528  		T18,
7529  		T19,
7530  		T20);
7531  	Event operator()(
7532  		const EnqueueArgs& enqueueArgs,
7533  		T0 arg0,
7534  		T1 arg1,
7535  		T2 arg2,
7536  		T3 arg3,
7537  		T4 arg4,
7538  		T5 arg5,
7539  		T6 arg6,
7540  		T7 arg7,
7541  		T8 arg8,
7542  		T9 arg9,
7543  		T10 arg10,
7544  		T11 arg11,
7545  		T12 arg12,
7546  		T13 arg13,
7547  		T14 arg14,
7548  		T15 arg15,
7549  		T16 arg16,
7550  		T17 arg17,
7551  		T18 arg18,
7552  		T19 arg19,
7553  		T20 arg20)
7554  	{
7555  		return functor_(
7556  			enqueueArgs,
7557  			arg0,
7558  			arg1,
7559  			arg2,
7560  			arg3,
7561  			arg4,
7562  			arg5,
7563  			arg6,
7564  			arg7,
7565  			arg8,
7566  			arg9,
7567  			arg10,
7568  			arg11,
7569  			arg12,
7570  			arg13,
7571  			arg14,
7572  			arg15,
7573  			arg16,
7574  			arg17,
7575  			arg18,
7576  			arg19,
7577  			arg20);
7578  	}
7579  };
7580  template<
7581  	typename T0,
7582  	typename T1,
7583  	typename T2,
7584  	typename T3,
7585  	typename T4,
7586  	typename T5,
7587  	typename T6,
7588  	typename T7,
7589  	typename T8,
7590  	typename T9,
7591  	typename T10,
7592  	typename T11,
7593  	typename T12,
7594  	typename T13,
7595  	typename T14,
7596  	typename T15,
7597  	typename T16,
7598  	typename T17,
7599  	typename T18,
7600  	typename T19>
7601  struct functionImplementation_
7602  <	T0,
7603  	T1,
7604  	T2,
7605  	T3,
7606  	T4,
7607  	T5,
7608  	T6,
7609  	T7,
7610  	T8,
7611  	T9,
7612  	T10,
7613  	T11,
7614  	T12,
7615  	T13,
7616  	T14,
7617  	T15,
7618  	T16,
7619  	T17,
7620  	T18,
7621  	T19,
7622  	NullType,
7623  	NullType,
7624  	NullType,
7625  	NullType,
7626  	NullType,
7627  	NullType,
7628  	NullType,
7629  	NullType,
7630  	NullType,
7631  	NullType,
7632  	NullType,
7633  	NullType>
7634  {
7635  	typedef detail::KernelFunctorGlobal<
7636  		T0,
7637  		T1,
7638  		T2,
7639  		T3,
7640  		T4,
7641  		T5,
7642  		T6,
7643  		T7,
7644  		T8,
7645  		T9,
7646  		T10,
7647  		T11,
7648  		T12,
7649  		T13,
7650  		T14,
7651  		T15,
7652  		T16,
7653  		T17,
7654  		T18,
7655  		T19,
7656  		NullType,
7657  		NullType,
7658  		NullType,
7659  		NullType,
7660  		NullType,
7661  		NullType,
7662  		NullType,
7663  		NullType,
7664  		NullType,
7665  		NullType,
7666  		NullType,
7667  		NullType> FunctorType;
7668      FunctorType functor_;
7669      functionImplementation_(const FunctorType &functor) :
7670          functor_(functor)
7671      {
7672          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 20))
7673          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
7674          #endif
7675      }
7676  	typedef Event result_type;
7677  	typedef Event type_(
7678  		const EnqueueArgs&,
7679  		T0,
7680  		T1,
7681  		T2,
7682  		T3,
7683  		T4,
7684  		T5,
7685  		T6,
7686  		T7,
7687  		T8,
7688  		T9,
7689  		T10,
7690  		T11,
7691  		T12,
7692  		T13,
7693  		T14,
7694  		T15,
7695  		T16,
7696  		T17,
7697  		T18,
7698  		T19);
7699  	Event operator()(
7700  		const EnqueueArgs& enqueueArgs,
7701  		T0 arg0,
7702  		T1 arg1,
7703  		T2 arg2,
7704  		T3 arg3,
7705  		T4 arg4,
7706  		T5 arg5,
7707  		T6 arg6,
7708  		T7 arg7,
7709  		T8 arg8,
7710  		T9 arg9,
7711  		T10 arg10,
7712  		T11 arg11,
7713  		T12 arg12,
7714  		T13 arg13,
7715  		T14 arg14,
7716  		T15 arg15,
7717  		T16 arg16,
7718  		T17 arg17,
7719  		T18 arg18,
7720  		T19 arg19)
7721  	{
7722  		return functor_(
7723  			enqueueArgs,
7724  			arg0,
7725  			arg1,
7726  			arg2,
7727  			arg3,
7728  			arg4,
7729  			arg5,
7730  			arg6,
7731  			arg7,
7732  			arg8,
7733  			arg9,
7734  			arg10,
7735  			arg11,
7736  			arg12,
7737  			arg13,
7738  			arg14,
7739  			arg15,
7740  			arg16,
7741  			arg17,
7742  			arg18,
7743  			arg19);
7744  	}
7745  };
7746  template<
7747  	typename T0,
7748  	typename T1,
7749  	typename T2,
7750  	typename T3,
7751  	typename T4,
7752  	typename T5,
7753  	typename T6,
7754  	typename T7,
7755  	typename T8,
7756  	typename T9,
7757  	typename T10,
7758  	typename T11,
7759  	typename T12,
7760  	typename T13,
7761  	typename T14,
7762  	typename T15,
7763  	typename T16,
7764  	typename T17,
7765  	typename T18>
7766  struct functionImplementation_
7767  <	T0,
7768  	T1,
7769  	T2,
7770  	T3,
7771  	T4,
7772  	T5,
7773  	T6,
7774  	T7,
7775  	T8,
7776  	T9,
7777  	T10,
7778  	T11,
7779  	T12,
7780  	T13,
7781  	T14,
7782  	T15,
7783  	T16,
7784  	T17,
7785  	T18,
7786  	NullType,
7787  	NullType,
7788  	NullType,
7789  	NullType,
7790  	NullType,
7791  	NullType,
7792  	NullType,
7793  	NullType,
7794  	NullType,
7795  	NullType,
7796  	NullType,
7797  	NullType,
7798  	NullType>
7799  {
7800  	typedef detail::KernelFunctorGlobal<
7801  		T0,
7802  		T1,
7803  		T2,
7804  		T3,
7805  		T4,
7806  		T5,
7807  		T6,
7808  		T7,
7809  		T8,
7810  		T9,
7811  		T10,
7812  		T11,
7813  		T12,
7814  		T13,
7815  		T14,
7816  		T15,
7817  		T16,
7818  		T17,
7819  		T18,
7820  		NullType,
7821  		NullType,
7822  		NullType,
7823  		NullType,
7824  		NullType,
7825  		NullType,
7826  		NullType,
7827  		NullType,
7828  		NullType,
7829  		NullType,
7830  		NullType,
7831  		NullType,
7832  		NullType> FunctorType;
7833      FunctorType functor_;
7834      functionImplementation_(const FunctorType &functor) :
7835          functor_(functor)
7836      {
7837          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 19))
7838          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
7839          #endif
7840      }
7841  	typedef Event result_type;
7842  	typedef Event type_(
7843  		const EnqueueArgs&,
7844  		T0,
7845  		T1,
7846  		T2,
7847  		T3,
7848  		T4,
7849  		T5,
7850  		T6,
7851  		T7,
7852  		T8,
7853  		T9,
7854  		T10,
7855  		T11,
7856  		T12,
7857  		T13,
7858  		T14,
7859  		T15,
7860  		T16,
7861  		T17,
7862  		T18);
7863  	Event operator()(
7864  		const EnqueueArgs& enqueueArgs,
7865  		T0 arg0,
7866  		T1 arg1,
7867  		T2 arg2,
7868  		T3 arg3,
7869  		T4 arg4,
7870  		T5 arg5,
7871  		T6 arg6,
7872  		T7 arg7,
7873  		T8 arg8,
7874  		T9 arg9,
7875  		T10 arg10,
7876  		T11 arg11,
7877  		T12 arg12,
7878  		T13 arg13,
7879  		T14 arg14,
7880  		T15 arg15,
7881  		T16 arg16,
7882  		T17 arg17,
7883  		T18 arg18)
7884  	{
7885  		return functor_(
7886  			enqueueArgs,
7887  			arg0,
7888  			arg1,
7889  			arg2,
7890  			arg3,
7891  			arg4,
7892  			arg5,
7893  			arg6,
7894  			arg7,
7895  			arg8,
7896  			arg9,
7897  			arg10,
7898  			arg11,
7899  			arg12,
7900  			arg13,
7901  			arg14,
7902  			arg15,
7903  			arg16,
7904  			arg17,
7905  			arg18);
7906  	}
7907  };
7908  template<
7909  	typename T0,
7910  	typename T1,
7911  	typename T2,
7912  	typename T3,
7913  	typename T4,
7914  	typename T5,
7915  	typename T6,
7916  	typename T7,
7917  	typename T8,
7918  	typename T9,
7919  	typename T10,
7920  	typename T11,
7921  	typename T12,
7922  	typename T13,
7923  	typename T14,
7924  	typename T15,
7925  	typename T16,
7926  	typename T17>
7927  struct functionImplementation_
7928  <	T0,
7929  	T1,
7930  	T2,
7931  	T3,
7932  	T4,
7933  	T5,
7934  	T6,
7935  	T7,
7936  	T8,
7937  	T9,
7938  	T10,
7939  	T11,
7940  	T12,
7941  	T13,
7942  	T14,
7943  	T15,
7944  	T16,
7945  	T17,
7946  	NullType,
7947  	NullType,
7948  	NullType,
7949  	NullType,
7950  	NullType,
7951  	NullType,
7952  	NullType,
7953  	NullType,
7954  	NullType,
7955  	NullType,
7956  	NullType,
7957  	NullType,
7958  	NullType,
7959  	NullType>
7960  {
7961  	typedef detail::KernelFunctorGlobal<
7962  		T0,
7963  		T1,
7964  		T2,
7965  		T3,
7966  		T4,
7967  		T5,
7968  		T6,
7969  		T7,
7970  		T8,
7971  		T9,
7972  		T10,
7973  		T11,
7974  		T12,
7975  		T13,
7976  		T14,
7977  		T15,
7978  		T16,
7979  		T17,
7980  		NullType,
7981  		NullType,
7982  		NullType,
7983  		NullType,
7984  		NullType,
7985  		NullType,
7986  		NullType,
7987  		NullType,
7988  		NullType,
7989  		NullType,
7990  		NullType,
7991  		NullType,
7992  		NullType,
7993  		NullType> FunctorType;
7994      FunctorType functor_;
7995      functionImplementation_(const FunctorType &functor) :
7996          functor_(functor)
7997      {
7998          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 18))
7999          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8000          #endif
8001      }
8002  	typedef Event result_type;
8003  	typedef Event type_(
8004  		const EnqueueArgs&,
8005  		T0,
8006  		T1,
8007  		T2,
8008  		T3,
8009  		T4,
8010  		T5,
8011  		T6,
8012  		T7,
8013  		T8,
8014  		T9,
8015  		T10,
8016  		T11,
8017  		T12,
8018  		T13,
8019  		T14,
8020  		T15,
8021  		T16,
8022  		T17);
8023  	Event operator()(
8024  		const EnqueueArgs& enqueueArgs,
8025  		T0 arg0,
8026  		T1 arg1,
8027  		T2 arg2,
8028  		T3 arg3,
8029  		T4 arg4,
8030  		T5 arg5,
8031  		T6 arg6,
8032  		T7 arg7,
8033  		T8 arg8,
8034  		T9 arg9,
8035  		T10 arg10,
8036  		T11 arg11,
8037  		T12 arg12,
8038  		T13 arg13,
8039  		T14 arg14,
8040  		T15 arg15,
8041  		T16 arg16,
8042  		T17 arg17)
8043  	{
8044  		return functor_(
8045  			enqueueArgs,
8046  			arg0,
8047  			arg1,
8048  			arg2,
8049  			arg3,
8050  			arg4,
8051  			arg5,
8052  			arg6,
8053  			arg7,
8054  			arg8,
8055  			arg9,
8056  			arg10,
8057  			arg11,
8058  			arg12,
8059  			arg13,
8060  			arg14,
8061  			arg15,
8062  			arg16,
8063  			arg17);
8064  	}
8065  };
8066  template<
8067  	typename T0,
8068  	typename T1,
8069  	typename T2,
8070  	typename T3,
8071  	typename T4,
8072  	typename T5,
8073  	typename T6,
8074  	typename T7,
8075  	typename T8,
8076  	typename T9,
8077  	typename T10,
8078  	typename T11,
8079  	typename T12,
8080  	typename T13,
8081  	typename T14,
8082  	typename T15,
8083  	typename T16>
8084  struct functionImplementation_
8085  <	T0,
8086  	T1,
8087  	T2,
8088  	T3,
8089  	T4,
8090  	T5,
8091  	T6,
8092  	T7,
8093  	T8,
8094  	T9,
8095  	T10,
8096  	T11,
8097  	T12,
8098  	T13,
8099  	T14,
8100  	T15,
8101  	T16,
8102  	NullType,
8103  	NullType,
8104  	NullType,
8105  	NullType,
8106  	NullType,
8107  	NullType,
8108  	NullType,
8109  	NullType,
8110  	NullType,
8111  	NullType,
8112  	NullType,
8113  	NullType,
8114  	NullType,
8115  	NullType,
8116  	NullType>
8117  {
8118  	typedef detail::KernelFunctorGlobal<
8119  		T0,
8120  		T1,
8121  		T2,
8122  		T3,
8123  		T4,
8124  		T5,
8125  		T6,
8126  		T7,
8127  		T8,
8128  		T9,
8129  		T10,
8130  		T11,
8131  		T12,
8132  		T13,
8133  		T14,
8134  		T15,
8135  		T16,
8136  		NullType,
8137  		NullType,
8138  		NullType,
8139  		NullType,
8140  		NullType,
8141  		NullType,
8142  		NullType,
8143  		NullType,
8144  		NullType,
8145  		NullType,
8146  		NullType,
8147  		NullType,
8148  		NullType,
8149  		NullType,
8150  		NullType> FunctorType;
8151      FunctorType functor_;
8152      functionImplementation_(const FunctorType &functor) :
8153          functor_(functor)
8154      {
8155          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 17))
8156          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8157          #endif
8158      }
8159  	typedef Event result_type;
8160  	typedef Event type_(
8161  		const EnqueueArgs&,
8162  		T0,
8163  		T1,
8164  		T2,
8165  		T3,
8166  		T4,
8167  		T5,
8168  		T6,
8169  		T7,
8170  		T8,
8171  		T9,
8172  		T10,
8173  		T11,
8174  		T12,
8175  		T13,
8176  		T14,
8177  		T15,
8178  		T16);
8179  	Event operator()(
8180  		const EnqueueArgs& enqueueArgs,
8181  		T0 arg0,
8182  		T1 arg1,
8183  		T2 arg2,
8184  		T3 arg3,
8185  		T4 arg4,
8186  		T5 arg5,
8187  		T6 arg6,
8188  		T7 arg7,
8189  		T8 arg8,
8190  		T9 arg9,
8191  		T10 arg10,
8192  		T11 arg11,
8193  		T12 arg12,
8194  		T13 arg13,
8195  		T14 arg14,
8196  		T15 arg15,
8197  		T16 arg16)
8198  	{
8199  		return functor_(
8200  			enqueueArgs,
8201  			arg0,
8202  			arg1,
8203  			arg2,
8204  			arg3,
8205  			arg4,
8206  			arg5,
8207  			arg6,
8208  			arg7,
8209  			arg8,
8210  			arg9,
8211  			arg10,
8212  			arg11,
8213  			arg12,
8214  			arg13,
8215  			arg14,
8216  			arg15,
8217  			arg16);
8218  	}
8219  };
8220  template<
8221  	typename T0,
8222  	typename T1,
8223  	typename T2,
8224  	typename T3,
8225  	typename T4,
8226  	typename T5,
8227  	typename T6,
8228  	typename T7,
8229  	typename T8,
8230  	typename T9,
8231  	typename T10,
8232  	typename T11,
8233  	typename T12,
8234  	typename T13,
8235  	typename T14,
8236  	typename T15>
8237  struct functionImplementation_
8238  <	T0,
8239  	T1,
8240  	T2,
8241  	T3,
8242  	T4,
8243  	T5,
8244  	T6,
8245  	T7,
8246  	T8,
8247  	T9,
8248  	T10,
8249  	T11,
8250  	T12,
8251  	T13,
8252  	T14,
8253  	T15,
8254  	NullType,
8255  	NullType,
8256  	NullType,
8257  	NullType,
8258  	NullType,
8259  	NullType,
8260  	NullType,
8261  	NullType,
8262  	NullType,
8263  	NullType,
8264  	NullType,
8265  	NullType,
8266  	NullType,
8267  	NullType,
8268  	NullType,
8269  	NullType>
8270  {
8271  	typedef detail::KernelFunctorGlobal<
8272  		T0,
8273  		T1,
8274  		T2,
8275  		T3,
8276  		T4,
8277  		T5,
8278  		T6,
8279  		T7,
8280  		T8,
8281  		T9,
8282  		T10,
8283  		T11,
8284  		T12,
8285  		T13,
8286  		T14,
8287  		T15,
8288  		NullType,
8289  		NullType,
8290  		NullType,
8291  		NullType,
8292  		NullType,
8293  		NullType,
8294  		NullType,
8295  		NullType,
8296  		NullType,
8297  		NullType,
8298  		NullType,
8299  		NullType,
8300  		NullType,
8301  		NullType,
8302  		NullType,
8303  		NullType> FunctorType;
8304      FunctorType functor_;
8305      functionImplementation_(const FunctorType &functor) :
8306          functor_(functor)
8307      {
8308          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 16))
8309          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8310          #endif
8311      }
8312  	typedef Event result_type;
8313  	typedef Event type_(
8314  		const EnqueueArgs&,
8315  		T0,
8316  		T1,
8317  		T2,
8318  		T3,
8319  		T4,
8320  		T5,
8321  		T6,
8322  		T7,
8323  		T8,
8324  		T9,
8325  		T10,
8326  		T11,
8327  		T12,
8328  		T13,
8329  		T14,
8330  		T15);
8331  	Event operator()(
8332  		const EnqueueArgs& enqueueArgs,
8333  		T0 arg0,
8334  		T1 arg1,
8335  		T2 arg2,
8336  		T3 arg3,
8337  		T4 arg4,
8338  		T5 arg5,
8339  		T6 arg6,
8340  		T7 arg7,
8341  		T8 arg8,
8342  		T9 arg9,
8343  		T10 arg10,
8344  		T11 arg11,
8345  		T12 arg12,
8346  		T13 arg13,
8347  		T14 arg14,
8348  		T15 arg15)
8349  	{
8350  		return functor_(
8351  			enqueueArgs,
8352  			arg0,
8353  			arg1,
8354  			arg2,
8355  			arg3,
8356  			arg4,
8357  			arg5,
8358  			arg6,
8359  			arg7,
8360  			arg8,
8361  			arg9,
8362  			arg10,
8363  			arg11,
8364  			arg12,
8365  			arg13,
8366  			arg14,
8367  			arg15);
8368  	}
8369  };
8370  template<
8371  	typename T0,
8372  	typename T1,
8373  	typename T2,
8374  	typename T3,
8375  	typename T4,
8376  	typename T5,
8377  	typename T6,
8378  	typename T7,
8379  	typename T8,
8380  	typename T9,
8381  	typename T10,
8382  	typename T11,
8383  	typename T12,
8384  	typename T13,
8385  	typename T14>
8386  struct functionImplementation_
8387  <	T0,
8388  	T1,
8389  	T2,
8390  	T3,
8391  	T4,
8392  	T5,
8393  	T6,
8394  	T7,
8395  	T8,
8396  	T9,
8397  	T10,
8398  	T11,
8399  	T12,
8400  	T13,
8401  	T14,
8402  	NullType,
8403  	NullType,
8404  	NullType,
8405  	NullType,
8406  	NullType,
8407  	NullType,
8408  	NullType,
8409  	NullType,
8410  	NullType,
8411  	NullType,
8412  	NullType,
8413  	NullType,
8414  	NullType,
8415  	NullType,
8416  	NullType,
8417  	NullType,
8418  	NullType>
8419  {
8420  	typedef detail::KernelFunctorGlobal<
8421  		T0,
8422  		T1,
8423  		T2,
8424  		T3,
8425  		T4,
8426  		T5,
8427  		T6,
8428  		T7,
8429  		T8,
8430  		T9,
8431  		T10,
8432  		T11,
8433  		T12,
8434  		T13,
8435  		T14,
8436  		NullType,
8437  		NullType,
8438  		NullType,
8439  		NullType,
8440  		NullType,
8441  		NullType,
8442  		NullType,
8443  		NullType,
8444  		NullType,
8445  		NullType,
8446  		NullType,
8447  		NullType,
8448  		NullType,
8449  		NullType,
8450  		NullType,
8451  		NullType,
8452  		NullType> FunctorType;
8453      FunctorType functor_;
8454      functionImplementation_(const FunctorType &functor) :
8455          functor_(functor)
8456      {
8457          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 15))
8458          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8459          #endif
8460      }
8461  	typedef Event result_type;
8462  	typedef Event type_(
8463  		const EnqueueArgs&,
8464  		T0,
8465  		T1,
8466  		T2,
8467  		T3,
8468  		T4,
8469  		T5,
8470  		T6,
8471  		T7,
8472  		T8,
8473  		T9,
8474  		T10,
8475  		T11,
8476  		T12,
8477  		T13,
8478  		T14);
8479  	Event operator()(
8480  		const EnqueueArgs& enqueueArgs,
8481  		T0 arg0,
8482  		T1 arg1,
8483  		T2 arg2,
8484  		T3 arg3,
8485  		T4 arg4,
8486  		T5 arg5,
8487  		T6 arg6,
8488  		T7 arg7,
8489  		T8 arg8,
8490  		T9 arg9,
8491  		T10 arg10,
8492  		T11 arg11,
8493  		T12 arg12,
8494  		T13 arg13,
8495  		T14 arg14)
8496  	{
8497  		return functor_(
8498  			enqueueArgs,
8499  			arg0,
8500  			arg1,
8501  			arg2,
8502  			arg3,
8503  			arg4,
8504  			arg5,
8505  			arg6,
8506  			arg7,
8507  			arg8,
8508  			arg9,
8509  			arg10,
8510  			arg11,
8511  			arg12,
8512  			arg13,
8513  			arg14);
8514  	}
8515  };
8516  template<
8517  	typename T0,
8518  	typename T1,
8519  	typename T2,
8520  	typename T3,
8521  	typename T4,
8522  	typename T5,
8523  	typename T6,
8524  	typename T7,
8525  	typename T8,
8526  	typename T9,
8527  	typename T10,
8528  	typename T11,
8529  	typename T12,
8530  	typename T13>
8531  struct functionImplementation_
8532  <	T0,
8533  	T1,
8534  	T2,
8535  	T3,
8536  	T4,
8537  	T5,
8538  	T6,
8539  	T7,
8540  	T8,
8541  	T9,
8542  	T10,
8543  	T11,
8544  	T12,
8545  	T13,
8546  	NullType,
8547  	NullType,
8548  	NullType,
8549  	NullType,
8550  	NullType,
8551  	NullType,
8552  	NullType,
8553  	NullType,
8554  	NullType,
8555  	NullType,
8556  	NullType,
8557  	NullType,
8558  	NullType,
8559  	NullType,
8560  	NullType,
8561  	NullType,
8562  	NullType,
8563  	NullType>
8564  {
8565  	typedef detail::KernelFunctorGlobal<
8566  		T0,
8567  		T1,
8568  		T2,
8569  		T3,
8570  		T4,
8571  		T5,
8572  		T6,
8573  		T7,
8574  		T8,
8575  		T9,
8576  		T10,
8577  		T11,
8578  		T12,
8579  		T13,
8580  		NullType,
8581  		NullType,
8582  		NullType,
8583  		NullType,
8584  		NullType,
8585  		NullType,
8586  		NullType,
8587  		NullType,
8588  		NullType,
8589  		NullType,
8590  		NullType,
8591  		NullType,
8592  		NullType,
8593  		NullType,
8594  		NullType,
8595  		NullType,
8596  		NullType,
8597  		NullType> FunctorType;
8598      FunctorType functor_;
8599      functionImplementation_(const FunctorType &functor) :
8600          functor_(functor)
8601      {
8602          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 14))
8603          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8604          #endif
8605      }
8606  	typedef Event result_type;
8607  	typedef Event type_(
8608  		const EnqueueArgs&,
8609  		T0,
8610  		T1,
8611  		T2,
8612  		T3,
8613  		T4,
8614  		T5,
8615  		T6,
8616  		T7,
8617  		T8,
8618  		T9,
8619  		T10,
8620  		T11,
8621  		T12,
8622  		T13);
8623  	Event operator()(
8624  		const EnqueueArgs& enqueueArgs,
8625  		T0 arg0,
8626  		T1 arg1,
8627  		T2 arg2,
8628  		T3 arg3,
8629  		T4 arg4,
8630  		T5 arg5,
8631  		T6 arg6,
8632  		T7 arg7,
8633  		T8 arg8,
8634  		T9 arg9,
8635  		T10 arg10,
8636  		T11 arg11,
8637  		T12 arg12,
8638  		T13 arg13)
8639  	{
8640  		return functor_(
8641  			enqueueArgs,
8642  			arg0,
8643  			arg1,
8644  			arg2,
8645  			arg3,
8646  			arg4,
8647  			arg5,
8648  			arg6,
8649  			arg7,
8650  			arg8,
8651  			arg9,
8652  			arg10,
8653  			arg11,
8654  			arg12,
8655  			arg13);
8656  	}
8657  };
8658  template<
8659  	typename T0,
8660  	typename T1,
8661  	typename T2,
8662  	typename T3,
8663  	typename T4,
8664  	typename T5,
8665  	typename T6,
8666  	typename T7,
8667  	typename T8,
8668  	typename T9,
8669  	typename T10,
8670  	typename T11,
8671  	typename T12>
8672  struct functionImplementation_
8673  <	T0,
8674  	T1,
8675  	T2,
8676  	T3,
8677  	T4,
8678  	T5,
8679  	T6,
8680  	T7,
8681  	T8,
8682  	T9,
8683  	T10,
8684  	T11,
8685  	T12,
8686  	NullType,
8687  	NullType,
8688  	NullType,
8689  	NullType,
8690  	NullType,
8691  	NullType,
8692  	NullType,
8693  	NullType,
8694  	NullType,
8695  	NullType,
8696  	NullType,
8697  	NullType,
8698  	NullType,
8699  	NullType,
8700  	NullType,
8701  	NullType,
8702  	NullType,
8703  	NullType,
8704  	NullType>
8705  {
8706  	typedef detail::KernelFunctorGlobal<
8707  		T0,
8708  		T1,
8709  		T2,
8710  		T3,
8711  		T4,
8712  		T5,
8713  		T6,
8714  		T7,
8715  		T8,
8716  		T9,
8717  		T10,
8718  		T11,
8719  		T12,
8720  		NullType,
8721  		NullType,
8722  		NullType,
8723  		NullType,
8724  		NullType,
8725  		NullType,
8726  		NullType,
8727  		NullType,
8728  		NullType,
8729  		NullType,
8730  		NullType,
8731  		NullType,
8732  		NullType,
8733  		NullType,
8734  		NullType,
8735  		NullType,
8736  		NullType,
8737  		NullType,
8738  		NullType> FunctorType;
8739      FunctorType functor_;
8740      functionImplementation_(const FunctorType &functor) :
8741          functor_(functor)
8742      {
8743          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 13))
8744          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8745          #endif
8746      }
8747  	typedef Event result_type;
8748  	typedef Event type_(
8749  		const EnqueueArgs&,
8750  		T0,
8751  		T1,
8752  		T2,
8753  		T3,
8754  		T4,
8755  		T5,
8756  		T6,
8757  		T7,
8758  		T8,
8759  		T9,
8760  		T10,
8761  		T11,
8762  		T12);
8763  	Event operator()(
8764  		const EnqueueArgs& enqueueArgs,
8765  		T0 arg0,
8766  		T1 arg1,
8767  		T2 arg2,
8768  		T3 arg3,
8769  		T4 arg4,
8770  		T5 arg5,
8771  		T6 arg6,
8772  		T7 arg7,
8773  		T8 arg8,
8774  		T9 arg9,
8775  		T10 arg10,
8776  		T11 arg11,
8777  		T12 arg12)
8778  	{
8779  		return functor_(
8780  			enqueueArgs,
8781  			arg0,
8782  			arg1,
8783  			arg2,
8784  			arg3,
8785  			arg4,
8786  			arg5,
8787  			arg6,
8788  			arg7,
8789  			arg8,
8790  			arg9,
8791  			arg10,
8792  			arg11,
8793  			arg12);
8794  	}
8795  };
8796  template<
8797  	typename T0,
8798  	typename T1,
8799  	typename T2,
8800  	typename T3,
8801  	typename T4,
8802  	typename T5,
8803  	typename T6,
8804  	typename T7,
8805  	typename T8,
8806  	typename T9,
8807  	typename T10,
8808  	typename T11>
8809  struct functionImplementation_
8810  <	T0,
8811  	T1,
8812  	T2,
8813  	T3,
8814  	T4,
8815  	T5,
8816  	T6,
8817  	T7,
8818  	T8,
8819  	T9,
8820  	T10,
8821  	T11,
8822  	NullType,
8823  	NullType,
8824  	NullType,
8825  	NullType,
8826  	NullType,
8827  	NullType,
8828  	NullType,
8829  	NullType,
8830  	NullType,
8831  	NullType,
8832  	NullType,
8833  	NullType,
8834  	NullType,
8835  	NullType,
8836  	NullType,
8837  	NullType,
8838  	NullType,
8839  	NullType,
8840  	NullType,
8841  	NullType>
8842  {
8843  	typedef detail::KernelFunctorGlobal<
8844  		T0,
8845  		T1,
8846  		T2,
8847  		T3,
8848  		T4,
8849  		T5,
8850  		T6,
8851  		T7,
8852  		T8,
8853  		T9,
8854  		T10,
8855  		T11,
8856  		NullType,
8857  		NullType,
8858  		NullType,
8859  		NullType,
8860  		NullType,
8861  		NullType,
8862  		NullType,
8863  		NullType,
8864  		NullType,
8865  		NullType,
8866  		NullType,
8867  		NullType,
8868  		NullType,
8869  		NullType,
8870  		NullType,
8871  		NullType,
8872  		NullType,
8873  		NullType,
8874  		NullType,
8875  		NullType> FunctorType;
8876      FunctorType functor_;
8877      functionImplementation_(const FunctorType &functor) :
8878          functor_(functor)
8879      {
8880          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 12))
8881          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
8882          #endif
8883      }
8884  	typedef Event result_type;
8885  	typedef Event type_(
8886  		const EnqueueArgs&,
8887  		T0,
8888  		T1,
8889  		T2,
8890  		T3,
8891  		T4,
8892  		T5,
8893  		T6,
8894  		T7,
8895  		T8,
8896  		T9,
8897  		T10,
8898  		T11);
8899  	Event operator()(
8900  		const EnqueueArgs& enqueueArgs,
8901  		T0 arg0,
8902  		T1 arg1,
8903  		T2 arg2,
8904  		T3 arg3,
8905  		T4 arg4,
8906  		T5 arg5,
8907  		T6 arg6,
8908  		T7 arg7,
8909  		T8 arg8,
8910  		T9 arg9,
8911  		T10 arg10,
8912  		T11 arg11)
8913  	{
8914  		return functor_(
8915  			enqueueArgs,
8916  			arg0,
8917  			arg1,
8918  			arg2,
8919  			arg3,
8920  			arg4,
8921  			arg5,
8922  			arg6,
8923  			arg7,
8924  			arg8,
8925  			arg9,
8926  			arg10,
8927  			arg11);
8928  	}
8929  };
8930  template<
8931  	typename T0,
8932  	typename T1,
8933  	typename T2,
8934  	typename T3,
8935  	typename T4,
8936  	typename T5,
8937  	typename T6,
8938  	typename T7,
8939  	typename T8,
8940  	typename T9,
8941  	typename T10>
8942  struct functionImplementation_
8943  <	T0,
8944  	T1,
8945  	T2,
8946  	T3,
8947  	T4,
8948  	T5,
8949  	T6,
8950  	T7,
8951  	T8,
8952  	T9,
8953  	T10,
8954  	NullType,
8955  	NullType,
8956  	NullType,
8957  	NullType,
8958  	NullType,
8959  	NullType,
8960  	NullType,
8961  	NullType,
8962  	NullType,
8963  	NullType,
8964  	NullType,
8965  	NullType,
8966  	NullType,
8967  	NullType,
8968  	NullType,
8969  	NullType,
8970  	NullType,
8971  	NullType,
8972  	NullType,
8973  	NullType,
8974  	NullType>
8975  {
8976  	typedef detail::KernelFunctorGlobal<
8977  		T0,
8978  		T1,
8979  		T2,
8980  		T3,
8981  		T4,
8982  		T5,
8983  		T6,
8984  		T7,
8985  		T8,
8986  		T9,
8987  		T10,
8988  		NullType,
8989  		NullType,
8990  		NullType,
8991  		NullType,
8992  		NullType,
8993  		NullType,
8994  		NullType,
8995  		NullType,
8996  		NullType,
8997  		NullType,
8998  		NullType,
8999  		NullType,
9000  		NullType,
9001  		NullType,
9002  		NullType,
9003  		NullType,
9004  		NullType,
9005  		NullType,
9006  		NullType,
9007  		NullType,
9008  		NullType> FunctorType;
9009      FunctorType functor_;
9010      functionImplementation_(const FunctorType &functor) :
9011          functor_(functor)
9012      {
9013          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 11))
9014          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9015          #endif
9016      }
9017  	typedef Event result_type;
9018  	typedef Event type_(
9019  		const EnqueueArgs&,
9020  		T0,
9021  		T1,
9022  		T2,
9023  		T3,
9024  		T4,
9025  		T5,
9026  		T6,
9027  		T7,
9028  		T8,
9029  		T9,
9030  		T10);
9031  	Event operator()(
9032  		const EnqueueArgs& enqueueArgs,
9033  		T0 arg0,
9034  		T1 arg1,
9035  		T2 arg2,
9036  		T3 arg3,
9037  		T4 arg4,
9038  		T5 arg5,
9039  		T6 arg6,
9040  		T7 arg7,
9041  		T8 arg8,
9042  		T9 arg9,
9043  		T10 arg10)
9044  	{
9045  		return functor_(
9046  			enqueueArgs,
9047  			arg0,
9048  			arg1,
9049  			arg2,
9050  			arg3,
9051  			arg4,
9052  			arg5,
9053  			arg6,
9054  			arg7,
9055  			arg8,
9056  			arg9,
9057  			arg10);
9058  	}
9059  };
9060  template<
9061  	typename T0,
9062  	typename T1,
9063  	typename T2,
9064  	typename T3,
9065  	typename T4,
9066  	typename T5,
9067  	typename T6,
9068  	typename T7,
9069  	typename T8,
9070  	typename T9>
9071  struct functionImplementation_
9072  <	T0,
9073  	T1,
9074  	T2,
9075  	T3,
9076  	T4,
9077  	T5,
9078  	T6,
9079  	T7,
9080  	T8,
9081  	T9,
9082  	NullType,
9083  	NullType,
9084  	NullType,
9085  	NullType,
9086  	NullType,
9087  	NullType,
9088  	NullType,
9089  	NullType,
9090  	NullType,
9091  	NullType,
9092  	NullType,
9093  	NullType,
9094  	NullType,
9095  	NullType,
9096  	NullType,
9097  	NullType,
9098  	NullType,
9099  	NullType,
9100  	NullType,
9101  	NullType,
9102  	NullType,
9103  	NullType>
9104  {
9105  	typedef detail::KernelFunctorGlobal<
9106  		T0,
9107  		T1,
9108  		T2,
9109  		T3,
9110  		T4,
9111  		T5,
9112  		T6,
9113  		T7,
9114  		T8,
9115  		T9,
9116  		NullType,
9117  		NullType,
9118  		NullType,
9119  		NullType,
9120  		NullType,
9121  		NullType,
9122  		NullType,
9123  		NullType,
9124  		NullType,
9125  		NullType,
9126  		NullType,
9127  		NullType,
9128  		NullType,
9129  		NullType,
9130  		NullType,
9131  		NullType,
9132  		NullType,
9133  		NullType,
9134  		NullType,
9135  		NullType,
9136  		NullType,
9137  		NullType> FunctorType;
9138      FunctorType functor_;
9139      functionImplementation_(const FunctorType &functor) :
9140          functor_(functor)
9141      {
9142          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 10))
9143          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9144          #endif
9145      }
9146  	typedef Event result_type;
9147  	typedef Event type_(
9148  		const EnqueueArgs&,
9149  		T0,
9150  		T1,
9151  		T2,
9152  		T3,
9153  		T4,
9154  		T5,
9155  		T6,
9156  		T7,
9157  		T8,
9158  		T9);
9159  	Event operator()(
9160  		const EnqueueArgs& enqueueArgs,
9161  		T0 arg0,
9162  		T1 arg1,
9163  		T2 arg2,
9164  		T3 arg3,
9165  		T4 arg4,
9166  		T5 arg5,
9167  		T6 arg6,
9168  		T7 arg7,
9169  		T8 arg8,
9170  		T9 arg9)
9171  	{
9172  		return functor_(
9173  			enqueueArgs,
9174  			arg0,
9175  			arg1,
9176  			arg2,
9177  			arg3,
9178  			arg4,
9179  			arg5,
9180  			arg6,
9181  			arg7,
9182  			arg8,
9183  			arg9);
9184  	}
9185  };
9186  template<
9187  	typename T0,
9188  	typename T1,
9189  	typename T2,
9190  	typename T3,
9191  	typename T4,
9192  	typename T5,
9193  	typename T6,
9194  	typename T7,
9195  	typename T8>
9196  struct functionImplementation_
9197  <	T0,
9198  	T1,
9199  	T2,
9200  	T3,
9201  	T4,
9202  	T5,
9203  	T6,
9204  	T7,
9205  	T8,
9206  	NullType,
9207  	NullType,
9208  	NullType,
9209  	NullType,
9210  	NullType,
9211  	NullType,
9212  	NullType,
9213  	NullType,
9214  	NullType,
9215  	NullType,
9216  	NullType,
9217  	NullType,
9218  	NullType,
9219  	NullType,
9220  	NullType,
9221  	NullType,
9222  	NullType,
9223  	NullType,
9224  	NullType,
9225  	NullType,
9226  	NullType,
9227  	NullType,
9228  	NullType>
9229  {
9230  	typedef detail::KernelFunctorGlobal<
9231  		T0,
9232  		T1,
9233  		T2,
9234  		T3,
9235  		T4,
9236  		T5,
9237  		T6,
9238  		T7,
9239  		T8,
9240  		NullType,
9241  		NullType,
9242  		NullType,
9243  		NullType,
9244  		NullType,
9245  		NullType,
9246  		NullType,
9247  		NullType,
9248  		NullType,
9249  		NullType,
9250  		NullType,
9251  		NullType,
9252  		NullType,
9253  		NullType,
9254  		NullType,
9255  		NullType,
9256  		NullType,
9257  		NullType,
9258  		NullType,
9259  		NullType,
9260  		NullType,
9261  		NullType,
9262  		NullType> FunctorType;
9263      FunctorType functor_;
9264      functionImplementation_(const FunctorType &functor) :
9265          functor_(functor)
9266      {
9267          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 9))
9268          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9269          #endif
9270      }
9271  	typedef Event result_type;
9272  	typedef Event type_(
9273  		const EnqueueArgs&,
9274  		T0,
9275  		T1,
9276  		T2,
9277  		T3,
9278  		T4,
9279  		T5,
9280  		T6,
9281  		T7,
9282  		T8);
9283  	Event operator()(
9284  		const EnqueueArgs& enqueueArgs,
9285  		T0 arg0,
9286  		T1 arg1,
9287  		T2 arg2,
9288  		T3 arg3,
9289  		T4 arg4,
9290  		T5 arg5,
9291  		T6 arg6,
9292  		T7 arg7,
9293  		T8 arg8)
9294  	{
9295  		return functor_(
9296  			enqueueArgs,
9297  			arg0,
9298  			arg1,
9299  			arg2,
9300  			arg3,
9301  			arg4,
9302  			arg5,
9303  			arg6,
9304  			arg7,
9305  			arg8);
9306  	}
9307  };
9308  template<
9309  	typename T0,
9310  	typename T1,
9311  	typename T2,
9312  	typename T3,
9313  	typename T4,
9314  	typename T5,
9315  	typename T6,
9316  	typename T7>
9317  struct functionImplementation_
9318  <	T0,
9319  	T1,
9320  	T2,
9321  	T3,
9322  	T4,
9323  	T5,
9324  	T6,
9325  	T7,
9326  	NullType,
9327  	NullType,
9328  	NullType,
9329  	NullType,
9330  	NullType,
9331  	NullType,
9332  	NullType,
9333  	NullType,
9334  	NullType,
9335  	NullType,
9336  	NullType,
9337  	NullType,
9338  	NullType,
9339  	NullType,
9340  	NullType,
9341  	NullType,
9342  	NullType,
9343  	NullType,
9344  	NullType,
9345  	NullType,
9346  	NullType,
9347  	NullType,
9348  	NullType,
9349  	NullType>
9350  {
9351  	typedef detail::KernelFunctorGlobal<
9352  		T0,
9353  		T1,
9354  		T2,
9355  		T3,
9356  		T4,
9357  		T5,
9358  		T6,
9359  		T7,
9360  		NullType,
9361  		NullType,
9362  		NullType,
9363  		NullType,
9364  		NullType,
9365  		NullType,
9366  		NullType,
9367  		NullType,
9368  		NullType,
9369  		NullType,
9370  		NullType,
9371  		NullType,
9372  		NullType,
9373  		NullType,
9374  		NullType,
9375  		NullType,
9376  		NullType,
9377  		NullType,
9378  		NullType,
9379  		NullType,
9380  		NullType,
9381  		NullType,
9382  		NullType,
9383  		NullType> FunctorType;
9384      FunctorType functor_;
9385      functionImplementation_(const FunctorType &functor) :
9386          functor_(functor)
9387      {
9388          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 8))
9389          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9390          #endif
9391      }
9392  	typedef Event result_type;
9393  	typedef Event type_(
9394  		const EnqueueArgs&,
9395  		T0,
9396  		T1,
9397  		T2,
9398  		T3,
9399  		T4,
9400  		T5,
9401  		T6,
9402  		T7);
9403  	Event operator()(
9404  		const EnqueueArgs& enqueueArgs,
9405  		T0 arg0,
9406  		T1 arg1,
9407  		T2 arg2,
9408  		T3 arg3,
9409  		T4 arg4,
9410  		T5 arg5,
9411  		T6 arg6,
9412  		T7 arg7)
9413  	{
9414  		return functor_(
9415  			enqueueArgs,
9416  			arg0,
9417  			arg1,
9418  			arg2,
9419  			arg3,
9420  			arg4,
9421  			arg5,
9422  			arg6,
9423  			arg7);
9424  	}
9425  };
9426  template<
9427  	typename T0,
9428  	typename T1,
9429  	typename T2,
9430  	typename T3,
9431  	typename T4,
9432  	typename T5,
9433  	typename T6>
9434  struct functionImplementation_
9435  <	T0,
9436  	T1,
9437  	T2,
9438  	T3,
9439  	T4,
9440  	T5,
9441  	T6,
9442  	NullType,
9443  	NullType,
9444  	NullType,
9445  	NullType,
9446  	NullType,
9447  	NullType,
9448  	NullType,
9449  	NullType,
9450  	NullType,
9451  	NullType,
9452  	NullType,
9453  	NullType,
9454  	NullType,
9455  	NullType,
9456  	NullType,
9457  	NullType,
9458  	NullType,
9459  	NullType,
9460  	NullType,
9461  	NullType,
9462  	NullType,
9463  	NullType,
9464  	NullType,
9465  	NullType,
9466  	NullType>
9467  {
9468  	typedef detail::KernelFunctorGlobal<
9469  		T0,
9470  		T1,
9471  		T2,
9472  		T3,
9473  		T4,
9474  		T5,
9475  		T6,
9476  		NullType,
9477  		NullType,
9478  		NullType,
9479  		NullType,
9480  		NullType,
9481  		NullType,
9482  		NullType,
9483  		NullType,
9484  		NullType,
9485  		NullType,
9486  		NullType,
9487  		NullType,
9488  		NullType,
9489  		NullType,
9490  		NullType,
9491  		NullType,
9492  		NullType,
9493  		NullType,
9494  		NullType,
9495  		NullType,
9496  		NullType,
9497  		NullType,
9498  		NullType,
9499  		NullType,
9500  		NullType> FunctorType;
9501      FunctorType functor_;
9502      functionImplementation_(const FunctorType &functor) :
9503          functor_(functor)
9504      {
9505          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 7))
9506          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9507          #endif
9508      }
9509  	typedef Event result_type;
9510  	typedef Event type_(
9511  		const EnqueueArgs&,
9512  		T0,
9513  		T1,
9514  		T2,
9515  		T3,
9516  		T4,
9517  		T5,
9518  		T6);
9519  	Event operator()(
9520  		const EnqueueArgs& enqueueArgs,
9521  		T0 arg0,
9522  		T1 arg1,
9523  		T2 arg2,
9524  		T3 arg3,
9525  		T4 arg4,
9526  		T5 arg5,
9527  		T6 arg6)
9528  	{
9529  		return functor_(
9530  			enqueueArgs,
9531  			arg0,
9532  			arg1,
9533  			arg2,
9534  			arg3,
9535  			arg4,
9536  			arg5,
9537  			arg6);
9538  	}
9539  };
9540  template<
9541  	typename T0,
9542  	typename T1,
9543  	typename T2,
9544  	typename T3,
9545  	typename T4,
9546  	typename T5>
9547  struct functionImplementation_
9548  <	T0,
9549  	T1,
9550  	T2,
9551  	T3,
9552  	T4,
9553  	T5,
9554  	NullType,
9555  	NullType,
9556  	NullType,
9557  	NullType,
9558  	NullType,
9559  	NullType,
9560  	NullType,
9561  	NullType,
9562  	NullType,
9563  	NullType,
9564  	NullType,
9565  	NullType,
9566  	NullType,
9567  	NullType,
9568  	NullType,
9569  	NullType,
9570  	NullType,
9571  	NullType,
9572  	NullType,
9573  	NullType,
9574  	NullType,
9575  	NullType,
9576  	NullType,
9577  	NullType,
9578  	NullType,
9579  	NullType>
9580  {
9581  	typedef detail::KernelFunctorGlobal<
9582  		T0,
9583  		T1,
9584  		T2,
9585  		T3,
9586  		T4,
9587  		T5,
9588  		NullType,
9589  		NullType,
9590  		NullType,
9591  		NullType,
9592  		NullType,
9593  		NullType,
9594  		NullType,
9595  		NullType,
9596  		NullType,
9597  		NullType,
9598  		NullType,
9599  		NullType,
9600  		NullType,
9601  		NullType,
9602  		NullType,
9603  		NullType,
9604  		NullType,
9605  		NullType,
9606  		NullType,
9607  		NullType,
9608  		NullType,
9609  		NullType,
9610  		NullType,
9611  		NullType,
9612  		NullType,
9613  		NullType> FunctorType;
9614      FunctorType functor_;
9615      functionImplementation_(const FunctorType &functor) :
9616          functor_(functor)
9617      {
9618          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 6))
9619          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9620          #endif
9621      }
9622  	typedef Event result_type;
9623  	typedef Event type_(
9624  		const EnqueueArgs&,
9625  		T0,
9626  		T1,
9627  		T2,
9628  		T3,
9629  		T4,
9630  		T5);
9631  	Event operator()(
9632  		const EnqueueArgs& enqueueArgs,
9633  		T0 arg0,
9634  		T1 arg1,
9635  		T2 arg2,
9636  		T3 arg3,
9637  		T4 arg4,
9638  		T5 arg5)
9639  	{
9640  		return functor_(
9641  			enqueueArgs,
9642  			arg0,
9643  			arg1,
9644  			arg2,
9645  			arg3,
9646  			arg4,
9647  			arg5);
9648  	}
9649  };
9650  template<
9651  	typename T0,
9652  	typename T1,
9653  	typename T2,
9654  	typename T3,
9655  	typename T4>
9656  struct functionImplementation_
9657  <	T0,
9658  	T1,
9659  	T2,
9660  	T3,
9661  	T4,
9662  	NullType,
9663  	NullType,
9664  	NullType,
9665  	NullType,
9666  	NullType,
9667  	NullType,
9668  	NullType,
9669  	NullType,
9670  	NullType,
9671  	NullType,
9672  	NullType,
9673  	NullType,
9674  	NullType,
9675  	NullType,
9676  	NullType,
9677  	NullType,
9678  	NullType,
9679  	NullType,
9680  	NullType,
9681  	NullType,
9682  	NullType,
9683  	NullType,
9684  	NullType,
9685  	NullType,
9686  	NullType,
9687  	NullType,
9688  	NullType>
9689  {
9690  	typedef detail::KernelFunctorGlobal<
9691  		T0,
9692  		T1,
9693  		T2,
9694  		T3,
9695  		T4,
9696  		NullType,
9697  		NullType,
9698  		NullType,
9699  		NullType,
9700  		NullType,
9701  		NullType,
9702  		NullType,
9703  		NullType,
9704  		NullType,
9705  		NullType,
9706  		NullType,
9707  		NullType,
9708  		NullType,
9709  		NullType,
9710  		NullType,
9711  		NullType,
9712  		NullType,
9713  		NullType,
9714  		NullType,
9715  		NullType,
9716  		NullType,
9717  		NullType,
9718  		NullType,
9719  		NullType,
9720  		NullType,
9721  		NullType,
9722  		NullType> FunctorType;
9723      FunctorType functor_;
9724      functionImplementation_(const FunctorType &functor) :
9725          functor_(functor)
9726      {
9727          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 5))
9728          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9729          #endif
9730      }
9731  	typedef Event result_type;
9732  	typedef Event type_(
9733  		const EnqueueArgs&,
9734  		T0,
9735  		T1,
9736  		T2,
9737  		T3,
9738  		T4);
9739  	Event operator()(
9740  		const EnqueueArgs& enqueueArgs,
9741  		T0 arg0,
9742  		T1 arg1,
9743  		T2 arg2,
9744  		T3 arg3,
9745  		T4 arg4)
9746  	{
9747  		return functor_(
9748  			enqueueArgs,
9749  			arg0,
9750  			arg1,
9751  			arg2,
9752  			arg3,
9753  			arg4);
9754  	}
9755  };
9756  template<
9757  	typename T0,
9758  	typename T1,
9759  	typename T2,
9760  	typename T3>
9761  struct functionImplementation_
9762  <	T0,
9763  	T1,
9764  	T2,
9765  	T3,
9766  	NullType,
9767  	NullType,
9768  	NullType,
9769  	NullType,
9770  	NullType,
9771  	NullType,
9772  	NullType,
9773  	NullType,
9774  	NullType,
9775  	NullType,
9776  	NullType,
9777  	NullType,
9778  	NullType,
9779  	NullType,
9780  	NullType,
9781  	NullType,
9782  	NullType,
9783  	NullType,
9784  	NullType,
9785  	NullType,
9786  	NullType,
9787  	NullType,
9788  	NullType,
9789  	NullType,
9790  	NullType,
9791  	NullType,
9792  	NullType,
9793  	NullType>
9794  {
9795  	typedef detail::KernelFunctorGlobal<
9796  		T0,
9797  		T1,
9798  		T2,
9799  		T3,
9800  		NullType,
9801  		NullType,
9802  		NullType,
9803  		NullType,
9804  		NullType,
9805  		NullType,
9806  		NullType,
9807  		NullType,
9808  		NullType,
9809  		NullType,
9810  		NullType,
9811  		NullType,
9812  		NullType,
9813  		NullType,
9814  		NullType,
9815  		NullType,
9816  		NullType,
9817  		NullType,
9818  		NullType,
9819  		NullType,
9820  		NullType,
9821  		NullType,
9822  		NullType,
9823  		NullType,
9824  		NullType,
9825  		NullType,
9826  		NullType,
9827  		NullType> FunctorType;
9828      FunctorType functor_;
9829      functionImplementation_(const FunctorType &functor) :
9830          functor_(functor)
9831      {
9832          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 4))
9833          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9834          #endif
9835      }
9836  	typedef Event result_type;
9837  	typedef Event type_(
9838  		const EnqueueArgs&,
9839  		T0,
9840  		T1,
9841  		T2,
9842  		T3);
9843  	Event operator()(
9844  		const EnqueueArgs& enqueueArgs,
9845  		T0 arg0,
9846  		T1 arg1,
9847  		T2 arg2,
9848  		T3 arg3)
9849  	{
9850  		return functor_(
9851  			enqueueArgs,
9852  			arg0,
9853  			arg1,
9854  			arg2,
9855  			arg3);
9856  	}
9857  };
9858  template<
9859  	typename T0,
9860  	typename T1,
9861  	typename T2>
9862  struct functionImplementation_
9863  <	T0,
9864  	T1,
9865  	T2,
9866  	NullType,
9867  	NullType,
9868  	NullType,
9869  	NullType,
9870  	NullType,
9871  	NullType,
9872  	NullType,
9873  	NullType,
9874  	NullType,
9875  	NullType,
9876  	NullType,
9877  	NullType,
9878  	NullType,
9879  	NullType,
9880  	NullType,
9881  	NullType,
9882  	NullType,
9883  	NullType,
9884  	NullType,
9885  	NullType,
9886  	NullType,
9887  	NullType,
9888  	NullType,
9889  	NullType,
9890  	NullType,
9891  	NullType,
9892  	NullType,
9893  	NullType,
9894  	NullType>
9895  {
9896  	typedef detail::KernelFunctorGlobal<
9897  		T0,
9898  		T1,
9899  		T2,
9900  		NullType,
9901  		NullType,
9902  		NullType,
9903  		NullType,
9904  		NullType,
9905  		NullType,
9906  		NullType,
9907  		NullType,
9908  		NullType,
9909  		NullType,
9910  		NullType,
9911  		NullType,
9912  		NullType,
9913  		NullType,
9914  		NullType,
9915  		NullType,
9916  		NullType,
9917  		NullType,
9918  		NullType,
9919  		NullType,
9920  		NullType,
9921  		NullType,
9922  		NullType,
9923  		NullType,
9924  		NullType,
9925  		NullType,
9926  		NullType,
9927  		NullType,
9928  		NullType> FunctorType;
9929      FunctorType functor_;
9930      functionImplementation_(const FunctorType &functor) :
9931          functor_(functor)
9932      {
9933          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 3))
9934          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
9935          #endif
9936      }
9937  	typedef Event result_type;
9938  	typedef Event type_(
9939  		const EnqueueArgs&,
9940  		T0,
9941  		T1,
9942  		T2);
9943  	Event operator()(
9944  		const EnqueueArgs& enqueueArgs,
9945  		T0 arg0,
9946  		T1 arg1,
9947  		T2 arg2)
9948  	{
9949  		return functor_(
9950  			enqueueArgs,
9951  			arg0,
9952  			arg1,
9953  			arg2);
9954  	}
9955  };
9956  template<
9957  	typename T0,
9958  	typename T1>
9959  struct functionImplementation_
9960  <	T0,
9961  	T1,
9962  	NullType,
9963  	NullType,
9964  	NullType,
9965  	NullType,
9966  	NullType,
9967  	NullType,
9968  	NullType,
9969  	NullType,
9970  	NullType,
9971  	NullType,
9972  	NullType,
9973  	NullType,
9974  	NullType,
9975  	NullType,
9976  	NullType,
9977  	NullType,
9978  	NullType,
9979  	NullType,
9980  	NullType,
9981  	NullType,
9982  	NullType,
9983  	NullType,
9984  	NullType,
9985  	NullType,
9986  	NullType,
9987  	NullType,
9988  	NullType,
9989  	NullType,
9990  	NullType,
9991  	NullType>
9992  {
9993  	typedef detail::KernelFunctorGlobal<
9994  		T0,
9995  		T1,
9996  		NullType,
9997  		NullType,
9998  		NullType,
9999  		NullType,
10000  		NullType,
10001  		NullType,
10002  		NullType,
10003  		NullType,
10004  		NullType,
10005  		NullType,
10006  		NullType,
10007  		NullType,
10008  		NullType,
10009  		NullType,
10010  		NullType,
10011  		NullType,
10012  		NullType,
10013  		NullType,
10014  		NullType,
10015  		NullType,
10016  		NullType,
10017  		NullType,
10018  		NullType,
10019  		NullType,
10020  		NullType,
10021  		NullType,
10022  		NullType,
10023  		NullType,
10024  		NullType,
10025  		NullType> FunctorType;
10026      FunctorType functor_;
10027      functionImplementation_(const FunctorType &functor) :
10028          functor_(functor)
10029      {
10030          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 2))
10031          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
10032          #endif
10033      }
10034  	typedef Event result_type;
10035  	typedef Event type_(
10036  		const EnqueueArgs&,
10037  		T0,
10038  		T1);
10039  	Event operator()(
10040  		const EnqueueArgs& enqueueArgs,
10041  		T0 arg0,
10042  		T1 arg1)
10043  	{
10044  		return functor_(
10045  			enqueueArgs,
10046  			arg0,
10047  			arg1);
10048  	}
10049  };
10050  template<
10051  	typename T0>
10052  struct functionImplementation_
10053  <	T0,
10054  	NullType,
10055  	NullType,
10056  	NullType,
10057  	NullType,
10058  	NullType,
10059  	NullType,
10060  	NullType,
10061  	NullType,
10062  	NullType,
10063  	NullType,
10064  	NullType,
10065  	NullType,
10066  	NullType,
10067  	NullType,
10068  	NullType,
10069  	NullType,
10070  	NullType,
10071  	NullType,
10072  	NullType,
10073  	NullType,
10074  	NullType,
10075  	NullType,
10076  	NullType,
10077  	NullType,
10078  	NullType,
10079  	NullType,
10080  	NullType,
10081  	NullType,
10082  	NullType,
10083  	NullType,
10084  	NullType>
10085  {
10086  	typedef detail::KernelFunctorGlobal<
10087  		T0,
10088  		NullType,
10089  		NullType,
10090  		NullType,
10091  		NullType,
10092  		NullType,
10093  		NullType,
10094  		NullType,
10095  		NullType,
10096  		NullType,
10097  		NullType,
10098  		NullType,
10099  		NullType,
10100  		NullType,
10101  		NullType,
10102  		NullType,
10103  		NullType,
10104  		NullType,
10105  		NullType,
10106  		NullType,
10107  		NullType,
10108  		NullType,
10109  		NullType,
10110  		NullType,
10111  		NullType,
10112  		NullType,
10113  		NullType,
10114  		NullType,
10115  		NullType,
10116  		NullType,
10117  		NullType,
10118  		NullType> FunctorType;
10119      FunctorType functor_;
10120      functionImplementation_(const FunctorType &functor) :
10121          functor_(functor)
10122      {
10123          #if (defined(_WIN32) && defined(_VARIADIC_MAX) && (_VARIADIC_MAX < 1))
10124          static_assert(0, "Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.");
10125          #endif
10126      }
10127  	typedef Event result_type;
10128  	typedef Event type_(
10129  		const EnqueueArgs&,
10130  		T0);
10131  	Event operator()(
10132  		const EnqueueArgs& enqueueArgs,
10133  		T0 arg0)
10134  	{
10135  		return functor_(
10136  			enqueueArgs,
10137  			arg0);
10138  	}
10139  };
10140  } 
10141  template <
10142     typename T0,   typename T1 = detail::NullType,   typename T2 = detail::NullType,
10143     typename T3 = detail::NullType,   typename T4 = detail::NullType,
10144     typename T5 = detail::NullType,   typename T6 = detail::NullType,
10145     typename T7 = detail::NullType,   typename T8 = detail::NullType,
10146     typename T9 = detail::NullType,   typename T10 = detail::NullType,
10147     typename T11 = detail::NullType,   typename T12 = detail::NullType,
10148     typename T13 = detail::NullType,   typename T14 = detail::NullType,
10149     typename T15 = detail::NullType,   typename T16 = detail::NullType,
10150     typename T17 = detail::NullType,   typename T18 = detail::NullType,
10151     typename T19 = detail::NullType,   typename T20 = detail::NullType,
10152     typename T21 = detail::NullType,   typename T22 = detail::NullType,
10153     typename T23 = detail::NullType,   typename T24 = detail::NullType,
10154     typename T25 = detail::NullType,   typename T26 = detail::NullType,
10155     typename T27 = detail::NullType,   typename T28 = detail::NullType,
10156     typename T29 = detail::NullType,   typename T30 = detail::NullType,
10157     typename T31 = detail::NullType
10158  >
10159  struct make_kernel :
10160      public detail::functionImplementation_<
10161                 T0,   T1,   T2,   T3,
10162                 T4,   T5,   T6,   T7,
10163                 T8,   T9,   T10,   T11,
10164                 T12,   T13,   T14,   T15,
10165                 T16,   T17,   T18,   T19,
10166                 T20,   T21,   T22,   T23,
10167                 T24,   T25,   T26,   T27,
10168                 T28,   T29,   T30,   T31
10169      >
10170  {
10171  public:
10172      typedef detail::KernelFunctorGlobal<             
10173                 T0,   T1,   T2,   T3,
10174                 T4,   T5,   T6,   T7,
10175                 T8,   T9,   T10,   T11,
10176                 T12,   T13,   T14,   T15,
10177                 T16,   T17,   T18,   T19,
10178                 T20,   T21,   T22,   T23,
10179                 T24,   T25,   T26,   T27,
10180                 T28,   T29,   T30,   T31
10181      > FunctorType;
10182      make_kernel(
10183          const Program& program,
10184          const STRING_CLASS name,
10185          cl_int * err = NULL) :
10186             detail::functionImplementation_<
10187                      T0,   T1,   T2,   T3,
10188                         T4,   T5,   T6,   T7,
10189                         T8,   T9,   T10,   T11,
10190                         T12,   T13,   T14,   T15,
10191                         T16,   T17,   T18,   T19,
10192                         T20,   T21,   T22,   T23,
10193                         T24,   T25,   T26,   T27,
10194                         T28,   T29,   T30,   T31
10195             >(
10196              FunctorType(program, name, err)) 
10197      {}
10198      make_kernel(
10199          const Kernel kernel) :
10200             detail::functionImplementation_<
10201                      T0,   T1,   T2,   T3,
10202                         T4,   T5,   T6,   T7,
10203                         T8,   T9,   T10,   T11,
10204                         T12,   T13,   T14,   T15,
10205                         T16,   T17,   T18,   T19,
10206                         T20,   T21,   T22,   T23,
10207                         T24,   T25,   T26,   T27,
10208                         T28,   T29,   T30,   T31
10209             >(
10210              FunctorType(kernel)) 
10211      {}    
10212  };
10213  #undef __ERR_STR
10214  #if !defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
10215  #undef __GET_DEVICE_INFO_ERR
10216  #undef __GET_PLATFORM_INFO_ERR
10217  #undef __GET_DEVICE_IDS_ERR
10218  #undef __GET_CONTEXT_INFO_ERR
10219  #undef __GET_EVENT_INFO_ERR
10220  #undef __GET_EVENT_PROFILE_INFO_ERR
10221  #undef __GET_MEM_OBJECT_INFO_ERR
10222  #undef __GET_IMAGE_INFO_ERR
10223  #undef __GET_SAMPLER_INFO_ERR
10224  #undef __GET_KERNEL_INFO_ERR
10225  #undef __GET_KERNEL_ARG_INFO_ERR
10226  #undef __GET_KERNEL_WORK_GROUP_INFO_ERR
10227  #undef __GET_PROGRAM_INFO_ERR
10228  #undef __GET_PROGRAM_BUILD_INFO_ERR
10229  #undef __GET_COMMAND_QUEUE_INFO_ERR
10230  #undef __CREATE_CONTEXT_ERR
10231  #undef __CREATE_CONTEXT_FROM_TYPE_ERR
10232  #undef __GET_SUPPORTED_IMAGE_FORMATS_ERR
10233  #undef __CREATE_BUFFER_ERR
10234  #undef __CREATE_SUBBUFFER_ERR
10235  #undef __CREATE_IMAGE2D_ERR
10236  #undef __CREATE_IMAGE3D_ERR
10237  #undef __CREATE_SAMPLER_ERR
10238  #undef __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR
10239  #undef __CREATE_USER_EVENT_ERR
10240  #undef __SET_USER_EVENT_STATUS_ERR
10241  #undef __SET_EVENT_CALLBACK_ERR
10242  #undef __SET_PRINTF_CALLBACK_ERR
10243  #undef __WAIT_FOR_EVENTS_ERR
10244  #undef __CREATE_KERNEL_ERR
10245  #undef __SET_KERNEL_ARGS_ERR
10246  #undef __CREATE_PROGRAM_WITH_SOURCE_ERR
10247  #undef __CREATE_PROGRAM_WITH_BINARY_ERR
10248  #undef __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR
10249  #undef __BUILD_PROGRAM_ERR
10250  #undef __CREATE_KERNELS_IN_PROGRAM_ERR
10251  #undef __CREATE_COMMAND_QUEUE_ERR
10252  #undef __SET_COMMAND_QUEUE_PROPERTY_ERR
10253  #undef __ENQUEUE_READ_BUFFER_ERR
10254  #undef __ENQUEUE_WRITE_BUFFER_ERR
10255  #undef __ENQUEUE_READ_BUFFER_RECT_ERR
10256  #undef __ENQUEUE_WRITE_BUFFER_RECT_ERR
10257  #undef __ENQEUE_COPY_BUFFER_ERR
10258  #undef __ENQEUE_COPY_BUFFER_RECT_ERR
10259  #undef __ENQUEUE_READ_IMAGE_ERR
10260  #undef __ENQUEUE_WRITE_IMAGE_ERR
10261  #undef __ENQUEUE_COPY_IMAGE_ERR
10262  #undef __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR
10263  #undef __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR
10264  #undef __ENQUEUE_MAP_BUFFER_ERR
10265  #undef __ENQUEUE_MAP_IMAGE_ERR
10266  #undef __ENQUEUE_UNMAP_MEM_OBJECT_ERR
10267  #undef __ENQUEUE_NDRANGE_KERNEL_ERR
10268  #undef __ENQUEUE_TASK_ERR
10269  #undef __ENQUEUE_NATIVE_KERNEL
10270  #undef __CL_EXPLICIT_CONSTRUCTORS
10271  #undef __UNLOAD_COMPILER_ERR
10272  #endif 
10273  #undef __CL_FUNCTION_TYPE
10274  #if defined(CL_VERSION_1_1)
10275  #undef __INIT_CL_EXT_FCN_PTR
10276  #endif 
10277  #undef __CREATE_SUB_DEVICES
10278  #if defined(USE_CL_DEVICE_FISSION)
10279  #undef __PARAM_NAME_DEVICE_FISSION
10280  #endif 
10281  #undef __DEFAULT_NOT_INITIALIZED 
10282  #undef __DEFAULT_BEING_INITIALIZED 
10283  #undef __DEFAULT_INITIALIZED
10284  #undef CL_HPP_RVALUE_REFERENCES_SUPPORTED
10285  #undef CL_HPP_NOEXCEPT
10286  } 
10287  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl.hpp</div>
                </div>
                <div class="column column_space"><pre><code>116      const TFltV& GetLevelV() const { return LevelV; }
117      bool IsLandscapeNm() const { return !LandscapeNmStr.Empty(); }
</pre></code></div>
                <div class="column column_space"><pre><code>445      operator const T* () const { return data_; }
446      bool empty (void) const
447      {
448          return size_==0;
449      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    