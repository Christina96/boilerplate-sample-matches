
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1198686371100166%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paramsd.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #ifndef GRAPHICS_DISABLED
5  #  include "params.h" 
6  #  include "paramsd.h"
7  #  include "scrollview.h"     
8  #  include "svmnode.h"        
9  #  include "tesseractclass.h" 
10  #  include <cstdio>  
11  #  include <cstdlib> 
12  #  include <cstring> 
13  #  include <locale>  
14  #  include <map>     
15  #  include <memory>  
16  #  include <sstream> 
17  #  include <utility> 
18  namespace tesseract {
19  #  define VARDIR "configs/" &bsol;*parameters files */
20  #  define MAX_ITEMS_IN_SUBMENU 30
21  static std::map<int, ParamContent *> vcMap;
22  static int nrParams = 0;
23  static int writeCommands[2];
24  ParamContent::ParamContent(tesseract::StringParam *it) {
25    my_id_ = nrParams;
26    nrParams++;
27    param_type_ = VT_STRING;
28    sIt = it;
29    vcMap[my_id_] = this;
30  }
31  ParamContent::ParamContent(tesseract::IntParam *it) {
32    my_id_ = nrParams;
33    nrParams++;
34    param_type_ = VT_INTEGER;
35    iIt = it;
36    vcMap[my_id_] = this;
37  }
38  ParamContent::ParamContent(tesseract::BoolParam *it) {
39    my_id_ = nrParams;
40    nrParams++;
41    param_type_ = VT_BOOLEAN;
42    bIt = it;
43    vcMap[my_id_] = this;
44  }
45  ParamContent::ParamContent(tesseract::DoubleParam *it) {
46    my_id_ = nrParams;
47    nrParams++;
48    param_type_ = VT_DOUBLE;
49    dIt = it;
50    vcMap[my_id_] = this;
51  }
52  ParamContent *ParamContent::GetParamContentById(int id) {
53    return vcMap[id];
54  }
55  void ParamsEditor::GetFirstWords(const char *s, 
56                                   int n,         
57                                   char *t        
58  ) {
59    int full_length = strlen(s);
60    int reqd_len = 0; 
61    const char *next_word = s;
62    while ((n > 0) && reqd_len < full_length) {
63      reqd_len += strcspn(next_word, "_") + 1;
64      next_word += reqd_len;
65      n--;
66    }
67    strncpy(t, s, reqd_len);
68    t[reqd_len] = '\0'; 
69  }
70  const char *ParamContent::GetName() const {
71    if (param_type_ == VT_INTEGER) {
72      return iIt->name_str();
73    } else if (param_type_ == VT_BOOLEAN) {
74      return bIt->name_str();
75    } else if (param_type_ == VT_DOUBLE) {
76      return dIt->name_str();
77    } else if (param_type_ == VT_STRING) {
78      return sIt->name_str();
79    } else {
80      return "ERROR: ParamContent::GetName()";
81    }
82  }
83  const char *ParamContent::GetDescription() const {
84    if (param_type_ == VT_INTEGER) {
85      return iIt->info_str();
86    } else if (param_type_ == VT_BOOLEAN) {
87      return bIt->info_str();
88    } else if (param_type_ == VT_DOUBLE) {
89      return dIt->info_str();
90    } else if (param_type_ == VT_STRING) {
91      return sIt->info_str();
92    } else {
93      return nullptr;
94    }
95  }
96  std::string ParamContent::GetValue() const {
97    std::string result;
98    if (param_type_ == VT_INTEGER) {
99      result += std::to_string(*iIt);
100    } else if (param_type_ == VT_BOOLEAN) {
101      result += std::to_string(*bIt);
102    } else if (param_type_ == VT_DOUBLE) {
103      result += std::to_string(*dIt);
104    } else if (param_type_ == VT_STRING) {
105      result = sIt->c_str();
106    }
107    return result;
108  }
109  void ParamContent::SetValue(const char *val) {
110    changed_ = true;
111    if (param_type_ == VT_INTEGER) {
112      iIt->set_value(atoi(val));
113    } else if (param_type_ == VT_BOOLEAN) {
114      bIt->set_value(atoi(val));
115    } else if (param_type_ == VT_DOUBLE) {
116      std::stringstream stream(val);
117      stream.imbue(std::locale::classic());
118      double d = 0;
119      stream >> d;
120      dIt->set_value(d);
121    } else if (param_type_ == VT_STRING) {
122      sIt->set_value(val);
123    }
124  }
125  void ParamsEditor::GetPrefixes(const char *s, std::string *level_one, std::string *level_two,
126                                 std::string *level_three) {
127    std::unique_ptr<char[]> p(new char[1024]);
128    GetFirstWords(s, 1, p.get());
129    *level_one = p.get();
130    GetFirstWords(s, 2, p.get());
131    *level_two = p.get();
132    GetFirstWords(s, 3, p.get());
133    *level_three = p.get();
134  }
135  int ParamContent::Compare(const void *v1, const void *v2) {
136    const ParamContent *one = *static_cast<const ParamContent *const *>(v1);
137    const ParamContent *two = *static_cast<const ParamContent *const *>(v2);
138    return strcmp(one->GetName(), two->GetName());
139  }
140  SVMenuNode *ParamsEditor::BuildListOfAllLeaves(tesseract::Tesseract *tess) {
141    auto *mr = new SVMenuNode();
142    ParamContent_LIST vclist;
143    ParamContent_IT vc_it(&vclist);
144    std::map<const char *, int> amount;
145    int num_iterations = (tess->params() == nullptr) ? 1 : 2;
146    for (int v = 0; v < num_iterations; ++v) {
147      tesseract::ParamsVectors *vec = (v == 0) ? GlobalParams() : tess->params();
148      for (auto &param : vec->int_params) {
149        vc_it.add_after_then_move(new ParamContent(param));
150      }
151      for (auto &param : vec->bool_params) {
152        vc_it.add_after_then_move(new ParamContent(param));
153      }
154      for (auto &param : vec->string_params) {
155        vc_it.add_after_then_move(new ParamContent(param));
156      }
157      for (auto &param : vec->double_params) {
158        vc_it.add_after_then_move(new ParamContent(param));
159      }
160    }
161    for (vc_it.mark_cycle_pt(); !vc_it.cycled_list(); vc_it.forward()) {
162      ParamContent *vc = vc_it.data();
163      std::string tag;
164      std::string tag2;
165      std::string tag3;
166      GetPrefixes(vc->GetName(), &tag, &tag2, &tag3);
167      amount[tag.c_str()]++;
168      amount[tag2.c_str()]++;
169      amount[tag3.c_str()]++;
170    }
171    vclist.sort(ParamContent::Compare); 
172    SVMenuNode *other = mr->AddChild("OTHER");
173    vc_it.move_to_first();
174    for (vc_it.mark_cycle_pt(); !vc_it.cycled_list(); vc_it.forward()) {
175      ParamContent *vc = vc_it.data();
176      std::string tag;
177      std::string tag2;
178      std::string tag3;
179      GetPrefixes(vc->GetName(), &tag, &tag2, &tag3);
180      if (amount[tag.c_str()] == 1) {
181        other->AddChild(vc->GetName(), vc->GetId(), vc->GetValue().c_str(), vc->GetDescription());
182      } else { 
183        SVMenuNode *sv = mr->AddChild(tag.c_str());
184        if ((amount[tag.c_str()] <= MAX_ITEMS_IN_SUBMENU) || (amount[tag2.c_str()] <= 1)) {
185          sv->AddChild(vc->GetName(), vc->GetId(), vc->GetValue().c_str(), vc->GetDescription());
186        } else { 
187          SVMenuNode *sv2 = sv->AddChild(tag2.c_str());
188          sv2->AddChild(vc->GetName(), vc->GetId(), vc->GetValue().c_str(), vc->GetDescription());
189        }
190      }
191    }
192    return mr;
193  }
194  void ParamsEditor::Notify(const SVEvent *sve) {
195    if (sve->type == SVET_POPUP) { 
196      char *param = sve->parameter;
<span onclick='openModal()' class='match'>197      if (sve->command_id == writeCommands[0]) {
198        WriteParams(param, false);
199      } else if (sve->command_id == writeCommands[1]) {
200        WriteParams(param, true);
201      } else {
</span>202        ParamContent *vc = ParamContent::GetParamContentById(sve->command_id);
203        vc->SetValue(param);
204        sv_window_->AddMessageF("Setting %s to %s", vc->GetName(), vc->GetValue().c_str());
205      }
206    }
207  }
208  ParamsEditor::ParamsEditor(tesseract::Tesseract *tess, ScrollView *sv) {
209    if (sv == nullptr) {
210      const char *name = "ParamEditorMAIN";
211      sv = new ScrollView(name, 1, 1, 200, 200, 300, 200);
212    }
213    sv_window_ = sv;
214    SVMenuNode *svMenuRoot = BuildListOfAllLeaves(tess);
215    std::string paramfile;
216    paramfile = tess->datadir;
217    paramfile += VARDIR;   
218    paramfile += "edited"; 
219    SVMenuNode *std_menu = svMenuRoot->AddChild("Build Config File");
220    writeCommands[0] = nrParams + 1;
221    std_menu->AddChild("All Parameters", writeCommands[0], paramfile.c_str(), "Config file name?");
222    writeCommands[1] = nrParams + 2;
223    std_menu->AddChild("changed_ Parameters Only", writeCommands[1], paramfile.c_str(),
224                       "Config file name?");
225    svMenuRoot->BuildMenu(sv, false);
226  }
227  void ParamsEditor::WriteParams(char *filename, bool changes_only) {
228    FILE *fp; 
229    if ((fp = fopen(filename, "rb")) != nullptr) {
230      fclose(fp);
231      std::stringstream msg;
232      msg << "Overwrite file " << filename << "? (Y/N)";
233      int a = sv_window_->ShowYesNoDialog(msg.str().c_str());
234      if (a == 'n') {
235        return;
236      } 
237    }
238    fp = fopen(filename, "wb"); 
239    if (fp == nullptr) {
240      sv_window_->AddMessageF("Can't write to file %s", filename);
241      return;
242    }
243    for (auto &iter : vcMap) {
244      ParamContent *cur = iter.second;
245      if (!changes_only || cur->HasChanged()) {
246        fprintf(fp, "%-25s   %-12s   # %s\n", cur->GetName(), cur->GetValue().c_str(),
247                cur->GetDescription());
248      }
249    }
250    fclose(fp);
251  }
252  } 
253  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tabvector.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "blobbox.h"
5  #include "colfind.h"
6  #include "colpartitionset.h"
7  #include "detlinefit.h"
8  #include "helpers.h" 
9  #include "statistc.h"
10  #include "tabvector.h"
11  #include <algorithm>
12  namespace tesseract {
13  const int kGutterMultiple = 4;
14  const int kGutterToNeighbourRatio = 3;
15  const int kSimilarVectorDist = 10;
16  const int kSimilarRaggedDist = 50;
17  const int kMaxFillinMultiple = 11;
18  const double kMinGutterFraction = 0.5;
19  const double kLineCountReciprocal = 4.0;
20  const double kMinAlignedGutter = 0.25;
21  const double kMinRaggedGutter = 1.5;
22  double_VAR(textord_tabvector_vertical_gap_fraction, 0.5,
23             "max fraction of mean blob width allowed for vertical gaps in "
24             "vertical text");
25  double_VAR(textord_tabvector_vertical_box_ratio, 0.5,
26             "Fraction of box matches required to declare a line vertical");
27  void TabConstraint::CreateConstraint(TabVector *vector, bool is_top) {
28    auto *constraint = new TabConstraint(vector, is_top);
29    auto *constraints = new TabConstraint_LIST;
30    TabConstraint_IT it(constraints);
31    it.add_to_end(constraint);
32    if (is_top) {
33      vector->set_top_constraints(constraints);
34    } else {
35      vector->set_bottom_constraints(constraints);
36    }
37  }
38  bool TabConstraint::CompatibleConstraints(TabConstraint_LIST *list1, TabConstraint_LIST *list2) {
39    if (list1 == list2) {
40      return false;
41    }
42    int y_min = -INT32_MAX;
43    int y_max = INT32_MAX;
44    if (textord_debug_tabfind > 3) {
45      tprintf("Testing constraint compatibility\n");
46    }
47    GetConstraints(list1, &y_min, &y_max);
48    GetConstraints(list2, &y_min, &y_max);
49    if (textord_debug_tabfind > 3) {
50      tprintf("Resulting range = [%d,%d]\n", y_min, y_max);
51    }
52    return y_max >= y_min;
53  }
54  void TabConstraint::MergeConstraints(TabConstraint_LIST *list1, TabConstraint_LIST *list2) {
55    if (list1 == list2) {
56      return;
57    }
58    TabConstraint_IT it(list2);
59    if (textord_debug_tabfind > 3) {
60      tprintf("Merging constraints\n");
61    }
62    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
63      TabConstraint *constraint = it.data();
64      if (textord_debug_tabfind > 3) {
65        constraint->vector_->Print("Merge");
66      }
67      if (constraint->is_top_) {
68        constraint->vector_->set_top_constraints(list1);
69      } else {
70        constraint->vector_->set_bottom_constraints(list1);
71      }
72    }
73    it = list1;
74    it.add_list_before(list2);
75    delete list2;
76  }
77  void TabConstraint::ApplyConstraints(TabConstraint_LIST *constraints) {
78    int y_min = -INT32_MAX;
79    int y_max = INT32_MAX;
80    GetConstraints(constraints, &y_min, &y_max);
81    int y = (y_min + y_max) / 2;
82    TabConstraint_IT it(constraints);
83    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
84      TabConstraint *constraint = it.data();
85      TabVector *v = constraint->vector_;
86      if (constraint->is_top_) {
87        v->SetYEnd(y);
88        v->set_top_constraints(nullptr);
89      } else {
90        v->SetYStart(y);
91        v->set_bottom_constraints(nullptr);
92      }
93    }
94    delete constraints;
95  }
96  TabConstraint::TabConstraint(TabVector *vector, bool is_top) : vector_(vector), is_top_(is_top) {
97    if (is_top) {
98      y_min_ = vector->endpt().y();
99      y_max_ = vector->extended_ymax();
100    } else {
101      y_max_ = vector->startpt().y();
102      y_min_ = vector->extended_ymin();
103    }
104  }
105  void TabConstraint::GetConstraints(TabConstraint_LIST *constraints, int *y_min, int *y_max) {
106    TabConstraint_IT it(constraints);
107    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
108      TabConstraint *constraint = it.data();
109      if (textord_debug_tabfind > 3) {
110        tprintf("Constraint is [%d,%d]", constraint->y_min_, constraint->y_max_);
111        constraint->vector_->Print(" for");
112      }
113      *y_min = std::max(*y_min, constraint->y_min_);
114      *y_max = std::min(*y_max, constraint->y_max_);
115    }
116  }
117  TabVector *TabVector::FitVector(TabAlignment alignment, ICOORD vertical, int extended_start_y,
118                                  int extended_end_y, BLOBNBOX_CLIST *good_points, int *vertical_x,
119                                  int *vertical_y) {
120    auto *vector = new TabVector(extended_start_y, extended_end_y, alignment, good_points);
121    if (!vector->Fit(vertical, false)) {
122      delete vector;
123      return nullptr;
124    }
125    if (!vector->IsRagged()) {
126      vertical = vector->endpt_ - vector->startpt_;
127      int weight = vector->BoxCount();
128      *vertical_x += vertical.x() * weight;
129      *vertical_y += vertical.y() * weight;
130    }
131    return vector;
132  }
133  TabVector::TabVector(const TabVector &src, TabAlignment alignment, const ICOORD &vertical_skew,
134                       BLOBNBOX *blob)
135      : extended_ymin_(src.extended_ymin_)
136      , extended_ymax_(src.extended_ymax_)
137      , needs_refit_(true)
138      , needs_evaluation_(true)
139      , alignment_(alignment) {
140    BLOBNBOX_C_IT it(&boxes_);
141    it.add_to_end(blob);
142    TBOX box = blob->bounding_box();
143    if (IsLeftTab()) {
144      startpt_ = box.botleft();
145      endpt_ = box.topleft();
146    } else {
147      startpt_ = box.botright();
148      endpt_ = box.topright();
149    }
150    sort_key_ =
151        SortKey(vertical_skew, (startpt_.x() + endpt_.x()) / 2, (startpt_.y() + endpt_.y()) / 2);
152    if (textord_debug_tabfind > 3) {
153      Print("Constructed a new tab vector:");
154    }
155  }
156  TabVector *TabVector::ShallowCopy() const {
157    auto *copy = new TabVector();
158    copy->startpt_ = startpt_;
159    copy->endpt_ = endpt_;
160    copy->alignment_ = alignment_;
161    copy->extended_ymax_ = extended_ymax_;
162    copy->extended_ymin_ = extended_ymin_;
163    copy->intersects_other_lines_ = intersects_other_lines_;
164    return copy;
165  }
166  void TabVector::ExtendToBox(BLOBNBOX *new_blob) {
167    TBOX new_box = new_blob->bounding_box();
168    BLOBNBOX_C_IT it(&boxes_);
169    if (!it.empty()) {
170      BLOBNBOX *blob = it.data();
171      TBOX box = blob->bounding_box();
172      while (!it.at_last() && box.top() <= new_box.top()) {
173        if (blob == new_blob) {
174          return; 
175        }
176        it.forward();
177        blob = it.data();
178        box = blob->bounding_box();
179      }
180      if (box.top() >= new_box.top()) {
181        it.add_before_stay_put(new_blob);
182        needs_refit_ = true;
183        return;
184      }
185    }
186    needs_refit_ = true;
187    it.add_after_stay_put(new_blob);
188  }
189  void TabVector::SetYStart(int start_y) {
190    startpt_.set_x(XAtY(start_y));
191    startpt_.set_y(start_y);
192  }
193  void TabVector::SetYEnd(int end_y) {
194    endpt_.set_x(XAtY(end_y));
195    endpt_.set_y(end_y);
196  }
197  void TabVector::Rotate(const FCOORD &rotation) {
198    startpt_.rotate(rotation);
199    endpt_.rotate(rotation);
200    int dx = endpt_.x() - startpt_.x();
201    int dy = endpt_.y() - startpt_.y();
202    if ((dy < 0 && abs(dy) > abs(dx)) || (dx < 0 && abs(dx) > abs(dy))) {
203      ICOORD tmp = startpt_;
204      startpt_ = endpt_;
205      endpt_ = tmp;
206    }
207  }
208  void TabVector::SetupConstraints() {
209    TabConstraint::CreateConstraint(this, false);
210    TabConstraint::CreateConstraint(this, true);
211  }
212  void TabVector::SetupPartnerConstraints() {
213    TabVector_C_IT it(&partners_);
214    TabVector *prev_partner = nullptr;
215    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
216      TabVector *partner = it.data();
217      if (partner->top_constraints_ == nullptr || partner->bottom_constraints_ == nullptr) {
218        partner->Print("Impossible: has no constraints");
219        Print("This vector has it as a partner");
220        continue;
221      }
222      if (prev_partner == nullptr) {
223        if (TabConstraint::CompatibleConstraints(bottom_constraints_, partner->bottom_constraints_)) {
224          TabConstraint::MergeConstraints(bottom_constraints_, partner->bottom_constraints_);
225        }
226      } else {
227        if (TabConstraint::CompatibleConstraints(prev_partner->top_constraints_,
228                                                 partner->bottom_constraints_)) {
229          TabConstraint::MergeConstraints(prev_partner->top_constraints_,
230                                          partner->bottom_constraints_);
231        }
232      }
233      prev_partner = partner;
234      if (it.at_last()) {
235        if (TabConstraint::CompatibleConstraints(top_constraints_, partner->top_constraints_)) {
236          TabConstraint::MergeConstraints(top_constraints_, partner->top_constraints_);
237        }
238      }
239    }
240  }
241  void TabVector::SetupPartnerConstraints(TabVector *partner) {
242    if (TabConstraint::CompatibleConstraints(bottom_constraints_, partner->bottom_constraints_)) {
243      TabConstraint::MergeConstraints(bottom_constraints_, partner->bottom_constraints_);
244    }
245    if (TabConstraint::CompatibleConstraints(top_constraints_, partner->top_constraints_)) {
246      TabConstraint::MergeConstraints(top_constraints_, partner->top_constraints_);
247    }
248  }
249  void TabVector::ApplyConstraints() {
250    if (top_constraints_ != nullptr) {
251      TabConstraint::ApplyConstraints(top_constraints_);
252    }
253    if (bottom_constraints_ != nullptr) {
254      TabConstraint::ApplyConstraints(bottom_constraints_);
255    }
256  }
257  void TabVector::MergeSimilarTabVectors(const ICOORD &vertical, TabVector_LIST *vectors,
258                                         BlobGrid *grid) {
259    TabVector_IT it1(vectors);
260    for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
261      TabVector *v1 = it1.data();
262      TabVector_IT it2(it1);
263      for (it2.forward(); !it2.at_first(); it2.forward()) {
264        TabVector *v2 = it2.data();
265        if (v2->SimilarTo(vertical, *v1, grid)) {
266          if (textord_debug_tabfind) {
267            v2->Print("Merging");
268            v1->Print("by deleting");
269          }
270          v2->MergeWith(vertical, it1.extract());
271          if (textord_debug_tabfind) {
272            v2->Print("Producing");
273          }
274          ICOORD merged_vector = v2->endpt();
275          merged_vector -= v2->startpt();
276          if (textord_debug_tabfind && abs(merged_vector.x()) > 100) {
277            v2->Print("Garbage result of merge?");
278          }
279          break;
280        }
281      }
282    }
283  }
284  bool TabVector::SimilarTo(const ICOORD &vertical, const TabVector &other, BlobGrid *grid) const {
285    if ((IsRightTab() && other.IsRightTab()) || (IsLeftTab() && other.IsLeftTab())) {
286      if (ExtendedOverlap(other.extended_ymax_, other.extended_ymin_) < 0) {
287        return false;
288      }
289      int v_scale = abs(vertical.y());
290      if (v_scale == 0) {
291        v_scale = 1;
292      }
293      if (sort_key_ + kSimilarVectorDist * v_scale >= other.sort_key_ &&
294          sort_key_ - kSimilarVectorDist * v_scale <= other.sort_key_) {
295        return true;
296      }
297      if (!IsRagged() || !other.IsRagged() ||
298          sort_key_ + kSimilarRaggedDist * v_scale < other.sort_key_ ||
299          sort_key_ - kSimilarRaggedDist * v_scale > other.sort_key_) {
300        return false;
301      }
302      if (grid == nullptr) {
303        return true;
304      }
305      const TabVector *mover = (IsRightTab() && sort_key_ < other.sort_key_) ? this : &other;
306      int top_y = mover->endpt_.y();
307      int bottom_y = mover->startpt_.y();
308      int left = std::min(mover->XAtY(top_y), mover->XAtY(bottom_y));
309      int right = std::max(mover->XAtY(top_y), mover->XAtY(bottom_y));
310      int shift = abs(sort_key_ - other.sort_key_) / v_scale;
311      if (IsRightTab()) {
312        right += shift;
313      } else {
314        left -= shift;
315      }
316      GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> vsearch(grid);
317      vsearch.StartVerticalSearch(left, right, top_y);
318      BLOBNBOX *blob;
319      while ((blob = vsearch.NextVerticalSearch(true)) != nullptr) {
320        const TBOX &box = blob->bounding_box();
321        if (box.top() > bottom_y) {
322          return true; 
323        }
324        if (box.bottom() < top_y) {
325          continue; 
326        }
327        int left_at_box = XAtY(box.bottom());
328        int right_at_box = left_at_box;
329        if (IsRightTab()) {
330          right_at_box += shift;
331        } else {
332          left_at_box -= shift;
333        }
334        if (std::min(right_at_box, static_cast<int>(box.right())) >
335            std::max(left_at_box, static_cast<int>(box.left()))) {
336          return false;
337        }
338      }
339      return true; 
340    }
341    return false;
342  }
343  void TabVector::MergeWith(const ICOORD &vertical, TabVector *other) {
344    extended_ymin_ = std::min(extended_ymin_, other->extended_ymin_);
345    extended_ymax_ = std::max(extended_ymax_, other->extended_ymax_);
346    if (other->IsRagged()) {
347      alignment_ = other->alignment_;
348    }
349    BLOBNBOX_C_IT it1(&boxes_);
350    BLOBNBOX_C_IT it2(&other->boxes_);
351    while (!it2.empty()) {
352      BLOBNBOX *bbox2 = it2.extract();
353      it2.forward();
354      TBOX box2 = bbox2->bounding_box();
355      BLOBNBOX *bbox1 = it1.data();
356      TBOX box1 = bbox1->bounding_box();
357      while (box1.bottom() < box2.bottom() && !it1.at_last()) {
358        it1.forward();
359        bbox1 = it1.data();
360        box1 = bbox1->bounding_box();
361      }
362      if (box1.bottom() < box2.bottom()) {
363        it1.add_to_end(bbox2);
364      } else if (bbox1 != bbox2) {
365        it1.add_before_stay_put(bbox2);
366      }
367    }
368    Fit(vertical, true);
369    other->Delete(this);
370  }
371  void TabVector::AddPartner(TabVector *partner) {
372    if (IsSeparator() || partner->IsSeparator()) {
373      return;
374    }
375    TabVector_C_IT it(&partners_);
376    if (!it.empty()) {
377      it.move_to_last();
378      if (it.data() == partner) {
379        return;
380      }
381    }
382    it.add_after_then_move(partner);
383  }
384  bool TabVector::IsAPartner(const TabVector *other) {
385    TabVector_C_IT it(&partners_);
386    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
387      if (it.data() == other) {
388        return true;
389      }
390    }
391    return false;
392  }
393  static const char *const kAlignmentNames[] = {"Left Aligned",  "Left Ragged",  "Center",
394                                                "Right Aligned", "Right Ragged", "Separator"};
395  void TabVector::Print(const char *prefix) {
396    tprintf(
397        "%s %s (%d,%d)->(%d,%d) w=%d s=%d, sort key=%d, boxes=%d,"
398        " partners=%d\n",
399        prefix, kAlignmentNames[alignment_], startpt_.x(), startpt_.y(), endpt_.x(), endpt_.y(),
400        mean_width_, percent_score_, sort_key_, boxes_.length(), partners_.length());
401  }
402  void TabVector::Debug(const char *prefix) {
403    Print(prefix);
404    BLOBNBOX_C_IT it(&boxes_);
405    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
406      BLOBNBOX *bbox = it.data();
407      const TBOX &box = bbox->bounding_box();
408      tprintf("Box at (%d,%d)->(%d,%d)\n", box.left(), box.bottom(), box.right(), box.top());
409    }
410  }
411  #ifndef GRAPHICS_DISABLED
412  void TabVector::Display(ScrollView *tab_win) {
413    if (textord_debug_printable) {
414      tab_win->Pen(ScrollView::BLUE);
415    } else if (alignment_ == TA_LEFT_ALIGNED) {
416      tab_win->Pen(ScrollView::LIME_GREEN);
417    } else if (alignment_ == TA_LEFT_RAGGED) {
418      tab_win->Pen(ScrollView::DARK_GREEN);
<span onclick='openModal()' class='match'>419    } else if (alignment_ == TA_RIGHT_ALIGNED) {
420      tab_win->Pen(ScrollView::PINK);
421    } else if (alignment_ == TA_RIGHT_RAGGED) {
422      tab_win->Pen(ScrollView::CORAL);
423    } else {
</span>424      tab_win->Pen(ScrollView::WHITE);
425    }
426    tab_win->Line(startpt_.x(), startpt_.y(), endpt_.x(), endpt_.y());
427    tab_win->Pen(ScrollView::GREY);
428    tab_win->Line(startpt_.x(), startpt_.y(), startpt_.x(), extended_ymin_);
429    tab_win->Line(endpt_.x(), extended_ymax_, endpt_.x(), endpt_.y());
430    auto score_string = std::to_string(percent_score_);
431    tab_win->TextAttributes("Times", 50, false, false, false);
432    tab_win->Text(startpt_.x(), startpt_.y(), score_string.c_str());
433  }
434  #endif
435  void TabVector::FitAndEvaluateIfNeeded(const ICOORD &vertical, TabFind *finder) {
436    if (needs_refit_) {
437      Fit(vertical, true);
438    }
439    if (needs_evaluation_) {
440      Evaluate(vertical, finder);
441    }
442  }
443  void TabVector::Evaluate(const ICOORD &vertical, TabFind *finder) {
444    bool debug = false;
445    needs_evaluation_ = false;
446    int length = endpt_.y() - startpt_.y();
447    if (length == 0 || boxes_.empty()) {
448      percent_score_ = 0;
449      Print("Zero length in evaluate");
450      return;
451    }
452    BLOBNBOX_C_IT it(&boxes_);
453    int mean_height = 0;
454    int height_count = 0;
455    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
456      BLOBNBOX *bbox = it.data();
457      const TBOX &box = bbox->bounding_box();
458      int height = box.height();
459      mean_height += height;
460      ++height_count;
461    }
462    if (height_count > 0) {
463      mean_height /= height_count;
464    }
465    int max_gutter = kGutterMultiple * mean_height;
466    if (IsRagged()) {
467      max_gutter = kGutterToNeighbourRatio * mean_height;
468    }
469    STATS gutters(0, max_gutter);
470    int num_deleted_boxes = 0;
471    bool text_on_image = false;
472    int good_length = 0;
473    const TBOX *prev_good_box = nullptr;
474    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
475      BLOBNBOX *bbox = it.data();
476      const TBOX &box = bbox->bounding_box();
477      int mid_y = (box.top() + box.bottom()) / 2;
478      if (TabFind::WithinTestRegion(2, XAtY(box.bottom()), box.bottom())) {
479        if (!debug) {
480          tprintf("After already deleting %d boxes, ", num_deleted_boxes);
481          Print("Starting evaluation");
482        }
483        debug = true;
484      }
485      bool left = IsLeftTab();
486      int tab_x = XAtY(mid_y);
487      int gutter_width;
488      int neighbour_gap;
489      finder->GutterWidthAndNeighbourGap(tab_x, mean_height, max_gutter, left, bbox, &gutter_width,
490                                         &neighbour_gap);
491      if (debug) {
492        tprintf("Box (%d,%d)->(%d,%d) has gutter %d, ndist %d\n", box.left(), box.bottom(),
493                box.right(), box.top(), gutter_width, neighbour_gap);
494      }
495      if (neighbour_gap * kGutterToNeighbourRatio <= gutter_width) {
496        good_length += box.top() - box.bottom();
497        gutters.add(gutter_width, 1);
498        if (prev_good_box != nullptr) {
499          int vertical_gap = box.bottom() - prev_good_box->top();
500          double size1 = sqrt(static_cast<double>(prev_good_box->area()));
501          double size2 = sqrt(static_cast<double>(box.area()));
502          if (vertical_gap < kMaxFillinMultiple * std::min(size1, size2)) {
503            good_length += vertical_gap;
504          }
505          if (debug) {
506            tprintf("Box and prev good, gap=%d, target %g, goodlength=%d\n", vertical_gap,
507                    kMaxFillinMultiple * std::min(size1, size2), good_length);
508          }
509        } else {
510          SetYStart(box.bottom());
511        }
512        prev_good_box = &box;
513        if (bbox->flow() == BTFT_TEXT_ON_IMAGE) {
514          text_on_image = true;
515        }
516      } else {
517        if (debug) {
518          tprintf("Bad Box (%d,%d)->(%d,%d) with gutter %d, ndist %d\n", box.left(), box.bottom(),
519                  box.right(), box.top(), gutter_width, neighbour_gap);
520        }
521        it.extract();
522        ++num_deleted_boxes;
523      }
524    }
525    if (debug) {
526      Print("Evaluating:");
527    }
528    int search_top = endpt_.y();
529    int search_bottom = startpt_.y();
530    int median_gutter = IntCastRounded(gutters.median());
531    if (gutters.get_total() > 0) {
532      prev_good_box = nullptr;
533      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
534        BLOBNBOX *bbox = it.data();
535        const TBOX &box = bbox->bounding_box();
536        int mid_y = (box.top() + box.bottom()) / 2;
537        bool left = IsLeftTab();
538        int tab_x = XAtY(mid_y);
539        int max_gutter = kGutterMultiple * mean_height;
540        if (IsRagged()) {
541          max_gutter = kGutterToNeighbourRatio * mean_height;
542        }
543        int gutter_width;
544        int neighbour_gap;
545        finder->GutterWidthAndNeighbourGap(tab_x, mean_height, max_gutter, left, bbox, &gutter_width,
546                                           &neighbour_gap);
547        if (gutter_width >= median_gutter * kMinGutterFraction) {
548          if (prev_good_box == nullptr) {
549            SetYStart(box.bottom());
550            search_bottom = box.top();
551          }
552          prev_good_box = &box;
553          search_top = box.bottom();
554        } else {
555          if (debug) {
556            tprintf("Bad Box (%d,%d)->(%d,%d) with gutter %d, mean gutter %d\n", box.left(),
557                    box.bottom(), box.right(), box.top(), gutter_width, median_gutter);
558          }
559          it.extract();
560          ++num_deleted_boxes;
561        }
562      }
563    }
564    if (prev_good_box != nullptr) {
565      SetYEnd(prev_good_box->top());
566      int length = endpt_.y() - startpt_.y();
567      percent_score_ = 100 * good_length / length;
568      if (num_deleted_boxes > 0) {
569        needs_refit_ = true;
570        FitAndEvaluateIfNeeded(vertical, finder);
571        if (boxes_.empty()) {
572          return;
573        }
574      }
575      int required_shift;
576      if (search_bottom > search_top) {
577        search_bottom = startpt_.y();
578        search_top = endpt_.y();
579      }
580      double min_gutter_width = kLineCountReciprocal / boxes_.length();
581      min_gutter_width += IsRagged() ? kMinRaggedGutter : kMinAlignedGutter;
582      min_gutter_width *= mean_height;
583      int max_gutter_width = IntCastRounded(min_gutter_width) + 1;
584      if (median_gutter > max_gutter_width) {
585        max_gutter_width = median_gutter;
586      }
587      int gutter_width = finder->GutterWidth(search_bottom, search_top, *this, text_on_image,
588                                             max_gutter_width, &required_shift);
589      if (gutter_width < min_gutter_width) {
590        if (debug) {
591          tprintf("Rejecting bad tab Vector with %d gutter vs %g min\n", gutter_width,
592                  min_gutter_width);
593        }
594        boxes_.shallow_clear();
595        percent_score_ = 0;
596      } else if (debug) {
597        tprintf("Final gutter %d, vs limit of %g, required shift = %d\n", gutter_width,
598                min_gutter_width, required_shift);
599      }
600    } else {
601      percent_score_ = 0;
602    }
603    if (debug) {
604      Print("Evaluation complete:");
605    }
606  }
607  bool TabVector::Fit(ICOORD vertical, bool force_parallel) {
608    needs_refit_ = false;
609    if (boxes_.empty()) {
610      if (!force_parallel) {
611        return false;
612      }
613      ICOORD midpt = startpt_;
614      midpt += endpt_;
615      midpt /= 2;
616      sort_key_ = SortKey(vertical, midpt.x(), midpt.y());
617      return startpt_.y() != endpt_.y();
618    }
619    if (!force_parallel && !IsRagged()) {
620      DetLineFit linepoints;
621      BLOBNBOX_C_IT it(&boxes_);
622      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623        BLOBNBOX *bbox = it.data();
624        const TBOX &box = bbox->bounding_box();
625        int x1 = IsRightTab() ? box.right() : box.left();
626        ICOORD boxpt(x1, box.bottom());
627        linepoints.Add(boxpt);
628        if (it.at_last()) {
629          ICOORD top_pt(x1, box.top());
630          linepoints.Add(top_pt);
631        }
632      }
633      linepoints.Fit(&startpt_, &endpt_);
634      if (startpt_.y() != endpt_.y()) {
635        vertical = endpt_;
636        vertical -= startpt_;
637      }
638    }
639    int start_y = startpt_.y();
640    int end_y = endpt_.y();
641    sort_key_ = IsLeftTab() ? INT32_MAX : -INT32_MAX;
642    BLOBNBOX_C_IT it(&boxes_);
643    mean_width_ = 0;
644    int width_count = 0;
645    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
646      BLOBNBOX *bbox = it.data();
647      const TBOX &box = bbox->bounding_box();
648      mean_width_ += box.width();
649      ++width_count;
650      int x1 = IsRightTab() ? box.right() : box.left();
651      int bottom_y = box.bottom();
652      int top_y = box.top();
653      int key = SortKey(vertical, x1, bottom_y);
654      if (IsLeftTab() == (key < sort_key_)) {
655        sort_key_ = key;
656        startpt_ = ICOORD(x1, bottom_y);
657      }
658      key = SortKey(vertical, x1, top_y);
659      if (IsLeftTab() == (key < sort_key_)) {
660        sort_key_ = key;
661        startpt_ = ICOORD(x1, top_y);
662      }
663      if (it.at_first()) {
664        start_y = bottom_y;
665      }
666      if (it.at_last()) {
667        end_y = top_y;
668      }
669    }
670    if (width_count > 0) {
671      mean_width_ = (mean_width_ + width_count - 1) / width_count;
672    }
673    endpt_ = startpt_ + vertical;
674    needs_evaluation_ = true;
675    if (start_y != end_y) {
676      startpt_.set_x(XAtY(vertical, sort_key_, start_y));
677      startpt_.set_y(start_y);
678      endpt_.set_x(XAtY(vertical, sort_key_, end_y));
679      endpt_.set_y(end_y);
680      return true;
681    }
682    return false;
683  }
684  TabVector *TabVector::GetSinglePartner() {
685    if (!partners_.singleton()) {
686      return nullptr;
687    }
688    TabVector_C_IT partner_it(&partners_);
689    TabVector *partner = partner_it.data();
690    return partner;
691  }
692  TabVector *TabVector::VerticalTextlinePartner() {
693    if (!partners_.singleton()) {
694      return nullptr;
695    }
696    TabVector_C_IT partner_it(&partners_);
697    TabVector *partner = partner_it.data();
698    BLOBNBOX_C_IT box_it1(&boxes_);
699    BLOBNBOX_C_IT box_it2(&partner->boxes_);
700    if (textord_debug_tabfind > 1) {
701      Print("Testing for vertical text");
702      partner->Print("           partner");
703    }
704    int num_matched = 0;
705    int num_unmatched = 0;
706    int total_widths = 0;
707    int width = startpt().x() - partner->startpt().x();
708    if (width < 0) {
709      width = -width;
710    }
711    STATS gaps(0, width * 2 - 1);
712    BLOBNBOX *prev_bbox = nullptr;
713    box_it2.mark_cycle_pt();
714    for (box_it1.mark_cycle_pt(); !box_it1.cycled_list(); box_it1.forward()) {
715      BLOBNBOX *bbox = box_it1.data();
716      TBOX box = bbox->bounding_box();
717      if (prev_bbox != nullptr) {
718        gaps.add(box.bottom() - prev_bbox->bounding_box().top(), 1);
719      }
720      while (!box_it2.cycled_list() && box_it2.data() != bbox &&
721             box_it2.data()->bounding_box().bottom() < box.bottom()) {
722        box_it2.forward();
723      }
724      if (!box_it2.cycled_list() && box_it2.data() == bbox && bbox->region_type() >= BRT_UNKNOWN &&
725          (prev_bbox == nullptr || prev_bbox->region_type() >= BRT_UNKNOWN)) {
726        ++num_matched;
727      } else {
728        ++num_unmatched;
729      }
730      total_widths += box.width();
731      prev_bbox = bbox;
732    }
733    if (num_unmatched + num_matched == 0) {
734      return nullptr;
735    }
736    double avg_width = total_widths * 1.0 / (num_unmatched + num_matched);
737    double max_gap = textord_tabvector_vertical_gap_fraction * avg_width;
738    int min_box_match =
739        static_cast<int>((num_matched + num_unmatched) * textord_tabvector_vertical_box_ratio);
740    bool is_vertical =
741        (gaps.get_total() > 0 && num_matched >= min_box_match && gaps.median() <= max_gap);
742    if (textord_debug_tabfind > 1) {
743      tprintf(
744          "gaps=%d, matched=%d, unmatched=%d, min_match=%d "
745          "median gap=%.2f, width=%.2f max_gap=%.2f Vertical=%s\n",
746          gaps.get_total(), num_matched, num_unmatched, min_box_match, gaps.median(), avg_width,
747          max_gap, is_vertical ? "Yes" : "No");
748    }
749    return (is_vertical) ? partner : nullptr;
750  }
751  TabVector::TabVector(int extended_ymin, int extended_ymax, TabAlignment alignment,
752                       BLOBNBOX_CLIST *boxes)
753      : extended_ymin_(extended_ymin)
754      , extended_ymax_(extended_ymax)
755      , sort_key_(0)
756      , percent_score_(0)
757      , mean_width_(0)
758      , needs_refit_(true)
759      , needs_evaluation_(true)
760      , alignment_(alignment)
761      , top_constraints_(nullptr)
762      , bottom_constraints_(nullptr) {
763    BLOBNBOX_C_IT it(&boxes_);
764    it.add_list_after(boxes);
765  }
766  void TabVector::Delete(TabVector *replacement) {
767    TabVector_C_IT it(&partners_);
768    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
769      TabVector *partner = it.data();
770      TabVector_C_IT p_it(&partner->partners_);
771      TabVector *partner_replacement = replacement;
772      for (p_it.mark_cycle_pt(); !p_it.cycled_list(); p_it.forward()) {
773        TabVector *p_partner = p_it.data();
774        if (p_partner == partner_replacement) {
775          partner_replacement = nullptr;
776          break;
777        }
778      }
779      for (p_it.mark_cycle_pt(); !p_it.cycled_list(); p_it.forward()) {
780        TabVector *p_partner = p_it.data();
781        if (p_partner == this) {
782          p_it.extract();
783          if (partner_replacement != nullptr) {
784            p_it.add_before_stay_put(partner_replacement);
785          }
786        }
787      }
788      if (partner_replacement != nullptr) {
789        partner_replacement->AddPartner(partner);
790      }
791    }
792    delete this;
793  }
794  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paramsd.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tabvector.cpp</div>
                </div>
                <div class="column column_space"><pre><code>197      if (sve->command_id == writeCommands[0]) {
198        WriteParams(param, false);
199      } else if (sve->command_id == writeCommands[1]) {
200        WriteParams(param, true);
201      } else {
</pre></code></div>
                <div class="column column_space"><pre><code>419    } else if (alignment_ == TA_RIGHT_ALIGNED) {
420      tab_win->Pen(ScrollView::PINK);
421    } else if (alignment_ == TA_RIGHT_RAGGED) {
422      tab_win->Pen(ScrollView::CORAL);
423    } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    