
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CellBuffer.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cassert>
4  #include <cstring>
5  #include <cstdio>
6  #include <cstdarg>
7  #include <stdexcept>
8  #include <string>
9  #include <string_view>
10  #include <vector>
11  #include <optional>
12  #include <algorithm>
13  #include <memory>
14  #include "ScintillaTypes.h"
15  #include "Debugging.h"
16  #include "Position.h"
17  #include "SplitVector.h"
18  #include "Partitioning.h"
19  #include "RunStyles.h"
20  #include "SparseVector.h"
21  #include "ChangeHistory.h"
22  #include "CellBuffer.h"
23  #include "UniConversion.h"
24  namespace Scintilla::Internal {
25  struct CountWidths {
26  	Sci::Position countBasePlane;
27  	Sci::Position countOtherPlanes;
28  	explicit CountWidths(Sci::Position countBasePlane_=0, Sci::Position countOtherPlanes_=0) noexcept :
29  		countBasePlane(countBasePlane_),
30  		countOtherPlanes(countOtherPlanes_) {
31  	}
32  	CountWidths operator-() const noexcept {
33  		return CountWidths(-countBasePlane , -countOtherPlanes);
34  	}
35  	Sci::Position WidthUTF32() const noexcept {
36  		return countBasePlane + countOtherPlanes;
37  	}
38  	Sci::Position WidthUTF16() const noexcept {
39  		return countBasePlane + 2 * countOtherPlanes;
40  	}
41  	void CountChar(int lenChar) noexcept {
42  		if (lenChar == 4) {
43  			countOtherPlanes++;
44  		} else {
45  			countBasePlane++;
46  		}
47  	}
48  };
49  class ILineVector {
50  public:
51  	virtual void Init() = 0;
52  	virtual void SetPerLine(PerLine *pl) noexcept = 0;
53  	virtual void InsertText(Sci::Line line, Sci::Position delta) noexcept = 0;
54  	virtual void InsertLine(Sci::Line line, Sci::Position position, bool lineStart) = 0;
55  	virtual void InsertLines(Sci::Line line, const Sci::Position *positions, size_t lines, bool lineStart) = 0;
56  	virtual void SetLineStart(Sci::Line line, Sci::Position position) noexcept = 0;
57  	virtual void RemoveLine(Sci::Line line) = 0;
58  	virtual Sci::Line Lines() const noexcept = 0;
59  	virtual void AllocateLines(Sci::Line lines) = 0;
60  	virtual Sci::Line LineFromPosition(Sci::Position pos) const noexcept = 0;
61  	virtual Sci::Position LineStart(Sci::Line line) const noexcept = 0;
62  	virtual void InsertCharacters(Sci::Line line, CountWidths delta) noexcept = 0;
63  	virtual void SetLineCharactersWidth(Sci::Line line, CountWidths width) noexcept = 0;
64  	virtual Scintilla::LineCharacterIndexType LineCharacterIndex() const noexcept = 0;
65  	virtual bool AllocateLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex, Sci::Line lines) = 0;
66  	virtual bool ReleaseLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex) = 0;
67  	virtual Sci::Position IndexLineStart(Sci::Line line, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept = 0;
68  	virtual Sci::Line LineFromPositionIndex(Sci::Position pos, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept = 0;
69  	virtual ~ILineVector() {}
70  };
71  }
72  using namespace Scintilla;
73  using namespace Scintilla::Internal;
74  template <typename POS>
75  class LineStartIndex {
76  	static constexpr POS line_cast(Sci::Line pos) noexcept {
77  		return static_cast<POS>(pos);
78  	}
79  public:
80  	int refCount;
81  	Partitioning<POS> starts;
82  	LineStartIndex() : refCount(0), starts(4) {
83  	}
84  	bool Allocate(Sci::Line lines) {
85  		refCount++;
86  		Sci::Position length = starts.PositionFromPartition(starts.Partitions());
87  		for (Sci::Line line = starts.Partitions(); line < lines; line++) {
88  			length++;
89  			starts.InsertPartition(line_cast(line), line_cast(length));
90  		}
91  		return refCount == 1;
92  	}
93  	bool Release() {
94  		if (refCount == 1) {
95  			starts.DeleteAll();
96  		}
97  		refCount--;
98  		return refCount == 0;
99  	}
100  	bool Active() const noexcept {
101  		return refCount > 0;
102  	}
103  	Sci::Position LineWidth(Sci::Line line) const noexcept {
104  		return starts.PositionFromPartition(line_cast(line) + 1) -
105  			starts.PositionFromPartition(line_cast(line));
106  	}
107  	void SetLineWidth(Sci::Line line, Sci::Position width) noexcept {
108  		const Sci::Position widthCurrent = LineWidth(line);
109  		starts.InsertText(line_cast(line), line_cast(width - widthCurrent));
110  	}
111  	void AllocateLines(Sci::Line lines) {
112  		if (lines > starts.Partitions()) {
113  			starts.ReAllocate(lines);
114  		}
115  	}
116  	void InsertLines(Sci::Line line, Sci::Line lines) {
117  		const POS lineAsPos = line_cast(line);
118  		const POS lineStart = starts.PositionFromPartition(lineAsPos - 1) + 1;
119  		for (POS l = 0; l < line_cast(lines); l++) {
120  			starts.InsertPartition(lineAsPos + l, lineStart + l);
121  		}
122  	}
123  };
124  template <typename POS>
125  class LineVector : public ILineVector {
126  	Partitioning<POS> starts;
127  	PerLine *perLine;
128  	LineStartIndex<POS> startsUTF16;
129  	LineStartIndex<POS> startsUTF32;
130  	LineCharacterIndexType activeIndices;
131  	void SetActiveIndices() noexcept {
132  		activeIndices =
133  			  (startsUTF32.Active() ? LineCharacterIndexType::Utf32 : LineCharacterIndexType::None)
134  			| (startsUTF16.Active() ? LineCharacterIndexType::Utf16 : LineCharacterIndexType::None);
135  	}
136  	static constexpr POS pos_cast(Sci::Position pos) noexcept {
137  		return static_cast<POS>(pos);
138  	}
139  	static constexpr Sci::Line line_from_pos_cast(POS line) noexcept {
140  		return static_cast<Sci::Line>(line);
141  	}
142  public:
143  	LineVector() : starts(256), perLine(nullptr), activeIndices(LineCharacterIndexType::None) {
144  	}
145  	void Init() override {
146  		starts.DeleteAll();
147  		if (perLine) {
148  			perLine->Init();
149  		}
150  		startsUTF32.starts.DeleteAll();
151  		startsUTF16.starts.DeleteAll();
152  	}
153  	void SetPerLine(PerLine *pl) noexcept override {
154  		perLine = pl;
155  	}
156  	void InsertText(Sci::Line line, Sci::Position delta) noexcept override {
157  		starts.InsertText(pos_cast(line), pos_cast(delta));
158  	}
159  	void InsertLine(Sci::Line line, Sci::Position position, bool lineStart) override {
160  		const POS lineAsPos = pos_cast(line);
161  		starts.InsertPartition(lineAsPos, pos_cast(position));
162  		if (activeIndices != LineCharacterIndexType::None) {
163  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
164  				startsUTF32.InsertLines(line, 1);
165  			}
166  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
167  				startsUTF16.InsertLines(line, 1);
168  			}
169  		}
170  		if (perLine) {
171  			if ((line > 0) && lineStart)
172  				line--;
173  			perLine->InsertLine(line);
174  		}
175  	}
176  	void InsertLines(Sci::Line line, const Sci::Position *positions, size_t lines, bool lineStart) override {
177  		const POS lineAsPos = pos_cast(line);
178  		if constexpr (sizeof(Sci::Position) == sizeof(POS)) {
179  			starts.InsertPartitions(lineAsPos, positions, lines);
180  		} else {
181  			starts.InsertPartitionsWithCast(lineAsPos, positions, lines);
182  		}
183  		if (activeIndices != LineCharacterIndexType::None) {
184  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
185  				startsUTF32.InsertLines(line, lines);
186  			}
187  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
188  				startsUTF16.InsertLines(line, lines);
189  			}
190  		}
191  		if (perLine) {
192  			if ((line > 0) && lineStart)
193  				line--;
194  			perLine->InsertLines(line, lines);
195  		}
196  	}
197  	void SetLineStart(Sci::Line line, Sci::Position position) noexcept override {
198  		starts.SetPartitionStartPosition(pos_cast(line), pos_cast(position));
199  	}
200  	void RemoveLine(Sci::Line line) override {
201  		starts.RemovePartition(pos_cast(line));
202  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
203  			startsUTF32.starts.RemovePartition(pos_cast(line));
204  		}
205  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
206  			startsUTF16.starts.RemovePartition(pos_cast(line));
207  		}
208  		if (perLine) {
209  			perLine->RemoveLine(line);
210  		}
211  	}
212  	Sci::Line Lines() const noexcept override {
213  		return line_from_pos_cast(starts.Partitions());
214  	}
215  	void AllocateLines(Sci::Line lines) override {
216  		if (lines > Lines()) {
217  			starts.ReAllocate(lines);
218  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
219  				startsUTF32.AllocateLines(lines);
220  			}
221  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
222  				startsUTF16.AllocateLines(lines);
223  			}
224  		}
225  	}
226  	Sci::Line LineFromPosition(Sci::Position pos) const noexcept override {
227  		return line_from_pos_cast(starts.PartitionFromPosition(pos_cast(pos)));
228  	}
229  	Sci::Position LineStart(Sci::Line line) const noexcept override {
230  		return starts.PositionFromPartition(pos_cast(line));
231  	}
232  	void InsertCharacters(Sci::Line line, CountWidths delta) noexcept override {
233  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
234  			startsUTF32.starts.InsertText(pos_cast(line), pos_cast(delta.WidthUTF32()));
235  		}
236  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
237  			startsUTF16.starts.InsertText(pos_cast(line), pos_cast(delta.WidthUTF16()));
238  		}
239  	}
240  	void SetLineCharactersWidth(Sci::Line line, CountWidths width) noexcept override {
241  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
242  			assert(startsUTF32.starts.Partitions() == starts.Partitions());
243  			startsUTF32.SetLineWidth(line, width.WidthUTF32());
244  		}
245  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
246  			assert(startsUTF16.starts.Partitions() == starts.Partitions());
247  			startsUTF16.SetLineWidth(line, width.WidthUTF16());
248  		}
249  	}
250  	LineCharacterIndexType LineCharacterIndex() const noexcept override {
251  		return activeIndices;
252  	}
253  	bool AllocateLineCharacterIndex(LineCharacterIndexType lineCharacterIndex, Sci::Line lines) override {
254  		const LineCharacterIndexType activeIndicesStart = activeIndices;
255  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf32)) {
256  			startsUTF32.Allocate(lines);
257  			assert(startsUTF32.starts.Partitions() == starts.Partitions());
258  		}
259  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf16)) {
260  			startsUTF16.Allocate(lines);
261  			assert(startsUTF16.starts.Partitions() == starts.Partitions());
262  		}
263  		SetActiveIndices();
264  		return activeIndicesStart != activeIndices;
265  	}
266  	bool ReleaseLineCharacterIndex(LineCharacterIndexType lineCharacterIndex) override {
267  		const LineCharacterIndexType activeIndicesStart = activeIndices;
268  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf32)) {
269  			startsUTF32.Release();
270  		}
271  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf16)) {
272  			startsUTF16.Release();
273  		}
274  		SetActiveIndices();
275  		return activeIndicesStart != activeIndices;
276  	}
277  	Sci::Position IndexLineStart(Sci::Line line, LineCharacterIndexType lineCharacterIndex) const noexcept override {
278  		if (lineCharacterIndex == LineCharacterIndexType::Utf32) {
279  			return startsUTF32.starts.PositionFromPartition(pos_cast(line));
280  		} else {
281  			return startsUTF16.starts.PositionFromPartition(pos_cast(line));
282  		}
283  	}
284  	Sci::Line LineFromPositionIndex(Sci::Position pos, LineCharacterIndexType lineCharacterIndex) const noexcept override {
285  		if (lineCharacterIndex == LineCharacterIndexType::Utf32) {
286  			return line_from_pos_cast(startsUTF32.starts.PartitionFromPosition(pos_cast(pos)));
287  		} else {
288  			return line_from_pos_cast(startsUTF16.starts.PartitionFromPosition(pos_cast(pos)));
289  		}
290  	}
291  };
292  Action::Action() noexcept {
293  	at = ActionType::start;
294  	position = 0;
295  	lenData = 0;
296  	mayCoalesce = false;
297  }
298  void Action::Create(ActionType at_, Sci::Position position_, const char *data_, Sci::Position lenData_, bool mayCoalesce_) {
299  	data = nullptr;
300  	position = position_;
301  	at = at_;
302  	if (lenData_) {
303  		data = std::make_unique<char[]>(lenData_);
304  		memcpy(&data[0], data_, lenData_);
305  	}
306  	lenData = lenData_;
307  	mayCoalesce = mayCoalesce_;
308  }
309  void Action::Clear() noexcept {
310  	data = nullptr;
311  	lenData = 0;
312  }
313  UndoHistory::UndoHistory() {
314  	actions.resize(3);
315  	maxAction = 0;
316  	currentAction = 0;
317  	undoSequenceDepth = 0;
318  	savePoint = 0;
319  	tentativePoint = -1;
320  	actions[currentAction].Create(ActionType::start);
321  }
322  void UndoHistory::EnsureUndoRoom() {
323  	if (static_cast<size_t>(currentAction) >= (actions.size() - 2)) {
324  		actions.resize(actions.size() * 2);
325  	}
326  }
327  const char *UndoHistory::AppendAction(ActionType at, Sci::Position position, const char *data, Sci::Position lengthData,
328  	bool &startSequence, bool mayCoalesce) {
329  	EnsureUndoRoom();
330  	if (currentAction < savePoint) {
331  		savePoint = -1;
332  		if (!detach) {
333  			detach = currentAction;
334  		}
335  	} else if (detach && (*detach > currentAction)) {
336  		detach = currentAction;
337  	}
338  	int oldCurrentAction = currentAction;
339  	if (currentAction >= 1) {
340  		if (0 == undoSequenceDepth) {
341  			ptrdiff_t targetAct = -1;
342  			const Action *actPrevious = &(actions[currentAction + targetAct]);
343  			while ((actPrevious->at == ActionType::container) && actPrevious->mayCoalesce) {
344  				targetAct--;
345  				actPrevious = &(actions[currentAction + targetAct]);
346  			}
347  			if ((currentAction == savePoint) || (currentAction == tentativePoint)) {
348  				currentAction++;
349  			} else if (!actions[currentAction].mayCoalesce) {
350  				currentAction++;
351  			} else if (!mayCoalesce || !actPrevious->mayCoalesce) {
352  				currentAction++;
353  			} else if (at == ActionType::container || actions[currentAction].at == ActionType::container) {
354  				;	
355  			} else if ((at != actPrevious->at) && (actPrevious->at != ActionType::start)) {
356  				currentAction++;
357  			} else if ((at == ActionType::insert) &&
358  			           (position != (actPrevious->position + actPrevious->lenData))) {
359  				currentAction++;
360  			} else if (at == ActionType::remove) {
361  				if ((lengthData == 1) || (lengthData == 2)) {
362  					if ((position + lengthData) == actPrevious->position) {
363  						; 
364  					} else if (position == actPrevious->position) {
365  						; 
366  					} else {
367  						currentAction++;
368  					}
369  				} else {
370  					currentAction++;
371  				}
372  			} else {
373  			}
374  		} else {
375  			if (!actions[currentAction].mayCoalesce)
376  				currentAction++;
377  		}
378  	} else {
379  		currentAction++;
380  	}
381  	startSequence = oldCurrentAction != currentAction;
382  	const int actionWithData = currentAction;
383  	actions[currentAction].Create(at, position, data, lengthData, mayCoalesce);
384  	currentAction++;
385  	actions[currentAction].Create(ActionType::start);
386  	maxAction = currentAction;
387  	return actions[actionWithData].data.get();
388  }
389  void UndoHistory::BeginUndoAction() {
390  	EnsureUndoRoom();
391  	if (undoSequenceDepth == 0) {
392  		if (actions[currentAction].at != ActionType::start) {
393  			currentAction++;
394  			actions[currentAction].Create(ActionType::start);
395  			maxAction = currentAction;
396  		}
397  		actions[currentAction].mayCoalesce = false;
398  	}
399  	undoSequenceDepth++;
400  }
401  void UndoHistory::EndUndoAction() {
402  	PLATFORM_ASSERT(undoSequenceDepth > 0);
403  	EnsureUndoRoom();
404  	undoSequenceDepth--;
405  	if (0 == undoSequenceDepth) {
406  		if (actions[currentAction].at != ActionType::start) {
<span onclick='openModal()' class='match'>407  			currentAction++;
408  			actions[currentAction].Create(ActionType::start);
409  			maxAction = currentAction;
410  		}
</span>411  		actions[currentAction].mayCoalesce = false;
412  	}
413  }
414  void UndoHistory::DropUndoSequence() {
415  	undoSequenceDepth = 0;
416  }
417  void UndoHistory::DeleteUndoHistory() {
418  	for (int i = 1; i < maxAction; i++)
419  		actions[i].Clear();
420  	maxAction = 0;
421  	currentAction = 0;
422  	actions[currentAction].Create(ActionType::start);
423  	savePoint = 0;
424  	tentativePoint = -1;
425  }
426  void UndoHistory::SetSavePoint() noexcept {
427  	savePoint = currentAction;
428  	detach.reset();
429  }
430  bool UndoHistory::IsSavePoint() const noexcept {
431  	return savePoint == currentAction;
432  }
433  bool UndoHistory::BeforeSavePoint() const noexcept {
434  	return (savePoint < 0) || (savePoint > currentAction);
435  }
436  bool UndoHistory::BeforeReachableSavePoint() const noexcept {
437  	return (savePoint >= 0) && !detach && (savePoint > currentAction);
438  }
439  bool UndoHistory::AfterSavePoint() const noexcept {
440  	return (savePoint >= 0) && (savePoint <= currentAction);
441  }
442  bool UndoHistory::AfterDetachPoint() const noexcept {
443  	return detach && (*detach < currentAction);
444  }
445  void UndoHistory::TentativeStart() {
446  	tentativePoint = currentAction;
447  }
448  void UndoHistory::TentativeCommit() {
449  	tentativePoint = -1;
450  	maxAction = currentAction;
451  }
452  bool UndoHistory::TentativeActive() const noexcept {
453  	return tentativePoint >= 0;
454  }
455  int UndoHistory::TentativeSteps() noexcept {
456  	if (actions[currentAction].at == ActionType::start && currentAction > 0)
457  		currentAction--;
458  	if (tentativePoint >= 0)
459  		return currentAction - tentativePoint;
460  	else
461  		return -1;
462  }
463  bool UndoHistory::CanUndo() const noexcept {
464  	return (currentAction > 0) && (maxAction > 0);
465  }
466  int UndoHistory::StartUndo() {
467  	if (actions[currentAction].at == ActionType::start && currentAction > 0)
468  		currentAction--;
469  	int act = currentAction;
470  	while (actions[act].at != ActionType::start && act > 0) {
471  		act--;
472  	}
473  	return currentAction - act;
474  }
475  const Action &UndoHistory::GetUndoStep() const {
476  	return actions[currentAction];
477  }
478  void UndoHistory::CompletedUndoStep() {
479  	currentAction--;
480  }
481  bool UndoHistory::CanRedo() const noexcept {
482  	return maxAction > currentAction;
483  }
484  int UndoHistory::StartRedo() {
485  	if (currentAction < maxAction && actions[currentAction].at == ActionType::start)
486  		currentAction++;
487  	int act = currentAction;
488  	while (act < maxAction && actions[act].at != ActionType::start) {
489  		act++;
490  	}
491  	return act - currentAction;
492  }
493  const Action &UndoHistory::GetRedoStep() const {
494  	return actions[currentAction];
495  }
496  void UndoHistory::CompletedRedoStep() {
497  	currentAction++;
498  }
499  CellBuffer::CellBuffer(bool hasStyles_, bool largeDocument_) :
500  	hasStyles(hasStyles_), largeDocument(largeDocument_) {
501  	readOnly = false;
502  	utf8Substance = false;
503  	utf8LineEnds = LineEndType::Default;
504  	collectingUndo = true;
505  	if (largeDocument)
506  		plv = std::make_unique<LineVector<Sci::Position>>();
507  	else
508  		plv = std::make_unique<LineVector<int>>();
509  }
510  CellBuffer::~CellBuffer() noexcept = default;
511  char CellBuffer::CharAt(Sci::Position position) const noexcept {
512  	return substance.ValueAt(position);
513  }
514  unsigned char CellBuffer::UCharAt(Sci::Position position) const noexcept {
515  	return substance.ValueAt(position);
516  }
517  void CellBuffer::GetCharRange(char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
518  	if (lengthRetrieve <= 0)
519  		return;
520  	if (position < 0)
521  		return;
522  	if ((position + lengthRetrieve) > substance.Length()) {
523  		Platform::DebugPrintf("Bad GetCharRange %.0f for %.0f of %.0f\n",
524  				      static_cast<double>(position),
525  				      static_cast<double>(lengthRetrieve),
526  				      static_cast<double>(substance.Length()));
527  		return;
528  	}
529  	substance.GetRange(buffer, position, lengthRetrieve);
530  }
531  char CellBuffer::StyleAt(Sci::Position position) const noexcept {
532  	return hasStyles ? style.ValueAt(position) : 0;
533  }
534  void CellBuffer::GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
535  	if (lengthRetrieve < 0)
536  		return;
537  	if (position < 0)
538  		return;
539  	if (!hasStyles) {
540  		std::fill(buffer, buffer + lengthRetrieve, static_cast<unsigned char>(0));
541  		return;
542  	}
543  	if ((position + lengthRetrieve) > style.Length()) {
544  		Platform::DebugPrintf("Bad GetStyleRange %.0f for %.0f of %.0f\n",
545  				      static_cast<double>(position),
546  				      static_cast<double>(lengthRetrieve),
547  				      static_cast<double>(style.Length()));
548  		return;
549  	}
550  	style.GetRange(reinterpret_cast<char *>(buffer), position, lengthRetrieve);
551  }
552  const char *CellBuffer::BufferPointer() {
553  	return substance.BufferPointer();
554  }
555  const char *CellBuffer::RangePointer(Sci::Position position, Sci::Position rangeLength) noexcept {
556  	return substance.RangePointer(position, rangeLength);
557  }
558  Sci::Position CellBuffer::GapPosition() const noexcept {
559  	return substance.GapPosition();
560  }
561  SplitView CellBuffer::AllView() const noexcept {
562  	const size_t length = substance.Length();
563  	size_t length1 = substance.GapPosition();
564  	if (length1 == 0) {
565  		length1 = length;
566  	}
567  	return SplitView {
568  		substance.ElementPointer(0),
569  		length1,
570  		substance.ElementPointer(length1) - length1,
571  		length
572  	};
573  }
574  const char *CellBuffer::InsertString(Sci::Position position, const char *s, Sci::Position insertLength, bool &startSequence) {
575  	const char *data = s;
576  	if (!readOnly) {
577  		if (collectingUndo) {
578  			data = uh.AppendAction(ActionType::insert, position, s, insertLength, startSequence);
579  		}
580  		BasicInsertString(position, s, insertLength);
581  		if (changeHistory) {
582  			changeHistory->Insert(position, insertLength, collectingUndo, uh.BeforeReachableSavePoint());
583  		}
584  	}
585  	return data;
586  }
587  bool CellBuffer::SetStyleAt(Sci::Position position, char styleValue) noexcept {
588  	if (!hasStyles) {
589  		return false;
590  	}
591  	const char curVal = style.ValueAt(position);
592  	if (curVal != styleValue) {
593  		style.SetValueAt(position, styleValue);
594  		return true;
595  	} else {
596  		return false;
597  	}
598  }
599  bool CellBuffer::SetStyleFor(Sci::Position position, Sci::Position lengthStyle, char styleValue) noexcept {
600  	if (!hasStyles) {
601  		return false;
602  	}
603  	bool changed = false;
604  	PLATFORM_ASSERT(lengthStyle == 0 ||
605  		(lengthStyle > 0 && lengthStyle + position <= style.Length()));
606  	while (lengthStyle--) {
607  		const char curVal = style.ValueAt(position);
608  		if (curVal != styleValue) {
609  			style.SetValueAt(position, styleValue);
610  			changed = true;
611  		}
612  		position++;
613  	}
614  	return changed;
615  }
616  const char *CellBuffer::DeleteChars(Sci::Position position, Sci::Position deleteLength, bool &startSequence) {
617  	PLATFORM_ASSERT(deleteLength > 0);
618  	const char *data = nullptr;
619  	if (!readOnly) {
620  		if (collectingUndo) {
621  			data = substance.RangePointer(position, deleteLength);
622  			data = uh.AppendAction(ActionType::remove, position, data, deleteLength, startSequence);
623  		}
624  		if (changeHistory) {
625  			changeHistory->DeleteRangeSavingHistory(position, deleteLength,
626  				uh.BeforeReachableSavePoint(), uh.AfterDetachPoint());
627  		}
628  		BasicDeleteChars(position, deleteLength);
629  	}
630  	return data;
631  }
632  Sci::Position CellBuffer::Length() const noexcept {
633  	return substance.Length();
634  }
635  void CellBuffer::Allocate(Sci::Position newSize) {
636  	substance.ReAllocate(newSize);
637  	if (hasStyles) {
638  		style.ReAllocate(newSize);
639  	}
640  }
641  void CellBuffer::SetUTF8Substance(bool utf8Substance_) noexcept {
642  	utf8Substance = utf8Substance_;
643  }
644  void CellBuffer::SetLineEndTypes(LineEndType utf8LineEnds_) {
645  	if (utf8LineEnds != utf8LineEnds_) {
646  		const LineCharacterIndexType indexes = plv->LineCharacterIndex();
647  		utf8LineEnds = utf8LineEnds_;
648  		ResetLineEnds();
649  		AllocateLineCharacterIndex(indexes);
650  	}
651  }
652  bool CellBuffer::ContainsLineEnd(const char *s, Sci::Position length) const noexcept {
653  	unsigned char chBeforePrev = 0;
654  	unsigned char chPrev = 0;
655  	for (Sci::Position i = 0; i < length; i++) {
656  		const unsigned char ch = s[i];
657  		if ((ch == '\r') || (ch == '\n')) {
658  			return true;
659  		} else if (utf8LineEnds == LineEndType::Unicode) {
660  			if (UTF8IsMultibyteLineEnd(chBeforePrev, chPrev, ch)) {
661  				return true;
662  			}
663  		}
664  		chBeforePrev = chPrev;
665  		chPrev = ch;
666  	}
667  	return false;
668  }
669  void CellBuffer::SetPerLine(PerLine *pl) noexcept {
670  	plv->SetPerLine(pl);
671  }
672  LineCharacterIndexType CellBuffer::LineCharacterIndex() const noexcept {
673  	return plv->LineCharacterIndex();
674  }
675  void CellBuffer::AllocateLineCharacterIndex(LineCharacterIndexType lineCharacterIndex) {
676  	if (utf8Substance) {
677  		if (plv->AllocateLineCharacterIndex(lineCharacterIndex, Lines())) {
678  			RecalculateIndexLineStarts(0, Lines() - 1);
679  		}
680  	}
681  }
682  void CellBuffer::ReleaseLineCharacterIndex(LineCharacterIndexType lineCharacterIndex) {
683  	plv->ReleaseLineCharacterIndex(lineCharacterIndex);
684  }
685  Sci::Line CellBuffer::Lines() const noexcept {
686  	return plv->Lines();
687  }
688  void CellBuffer::AllocateLines(Sci::Line lines) {
689  	plv->AllocateLines(lines);
690  }
691  Sci::Position CellBuffer::LineStart(Sci::Line line) const noexcept {
692  	if (line < 0)
693  		return 0;
694  	else if (line >= Lines())
695  		return Length();
696  	else
697  		return plv->LineStart(line);
698  }
699  Sci::Line CellBuffer::LineFromPosition(Sci::Position pos) const noexcept {
700  	return plv->LineFromPosition(pos);
701  }
702  Sci::Position CellBuffer::IndexLineStart(Sci::Line line, LineCharacterIndexType lineCharacterIndex) const noexcept {
703  	return plv->IndexLineStart(line, lineCharacterIndex);
704  }
705  Sci::Line CellBuffer::LineFromPositionIndex(Sci::Position pos, LineCharacterIndexType lineCharacterIndex) const noexcept {
706  	return plv->LineFromPositionIndex(pos, lineCharacterIndex);
707  }
708  bool CellBuffer::IsReadOnly() const noexcept {
709  	return readOnly;
710  }
711  void CellBuffer::SetReadOnly(bool set) noexcept {
712  	readOnly = set;
713  }
714  bool CellBuffer::IsLarge() const noexcept {
715  	return largeDocument;
716  }
717  bool CellBuffer::HasStyles() const noexcept {
718  	return hasStyles;
719  }
720  void CellBuffer::SetSavePoint() {
721  	uh.SetSavePoint();
722  	if (changeHistory) {
723  		changeHistory->SetSavePoint();
724  	}
725  }
726  bool CellBuffer::IsSavePoint() const noexcept {
727  	return uh.IsSavePoint();
728  }
729  void CellBuffer::TentativeStart() {
730  	uh.TentativeStart();
731  }
732  void CellBuffer::TentativeCommit() {
733  	uh.TentativeCommit();
734  }
735  int CellBuffer::TentativeSteps() noexcept {
736  	return uh.TentativeSteps();
737  }
738  bool CellBuffer::TentativeActive() const noexcept {
739  	return uh.TentativeActive();
740  }
741  void CellBuffer::InsertLine(Sci::Line line, Sci::Position position, bool lineStart) {
742  	plv->InsertLine(line, position, lineStart);
743  }
744  void CellBuffer::RemoveLine(Sci::Line line) {
745  	plv->RemoveLine(line);
746  }
747  bool CellBuffer::UTF8LineEndOverlaps(Sci::Position position) const noexcept {
748  	const unsigned char bytes[] = {
749  		static_cast<unsigned char>(substance.ValueAt(position-2)),
750  		static_cast<unsigned char>(substance.ValueAt(position-1)),
751  		static_cast<unsigned char>(substance.ValueAt(position)),
752  		static_cast<unsigned char>(substance.ValueAt(position+1)),
753  	};
754  	return UTF8IsSeparator(bytes) || UTF8IsSeparator(bytes+1) || UTF8IsNEL(bytes+1);
755  }
756  bool CellBuffer::UTF8IsCharacterBoundary(Sci::Position position) const {
757  	assert(position >= 0 && position <= Length());
758  	if (position > 0) {
759  		std::string back;
760  		for (int i = 0; i < UTF8MaxBytes; i++) {
761  			const Sci::Position posBack = position - i;
762  			if (posBack < 0) {
763  				return false;
764  			}
765  			back.insert(0, 1, substance.ValueAt(posBack));
766  			if (!UTF8IsTrailByte(back.front())) {
767  				if (i > 0) {
768  					const int cla = UTF8Classify(back);
769  					if ((cla & UTF8MaskInvalid) || (cla != i)) {
770  						return false;
771  					}
772  				}
773  				break;
774  			}
775  		}
776  	}
777  	if (position < Length()) {
778  		const unsigned char fore = substance.ValueAt(position);
779  		if (UTF8IsTrailByte(fore)) {
780  			return false;
781  		}
782  	}
783  	return true;
784  }
785  void CellBuffer::ResetLineEnds() {
786  	const Sci::Line lines = plv->Lines();
787  	plv->Init();
788  	plv->AllocateLines(lines);
789  	constexpr Sci::Position position = 0;
790  	const Sci::Position length = Length();
791  	plv->InsertText(0, length);
792  	Sci::Line lineInsert = 1;
793  	constexpr bool atLineStart = true;
794  	unsigned char chBeforePrev = 0;
795  	unsigned char chPrev = 0;
796  	for (Sci::Position i = 0; i < length; i++) {
797  		const unsigned char ch = substance.ValueAt(position + i);
798  		if (ch == '\r') {
799  			InsertLine(lineInsert, (position + i) + 1, atLineStart);
800  			lineInsert++;
801  		} else if (ch == '\n') {
802  			if (chPrev == '\r') {
803  				plv->SetLineStart(lineInsert - 1, (position + i) + 1);
804  			} else {
805  				InsertLine(lineInsert, (position + i) + 1, atLineStart);
806  				lineInsert++;
807  			}
808  		} else if (utf8LineEnds == LineEndType::Unicode) {
809  			if (UTF8IsMultibyteLineEnd(chBeforePrev, chPrev, ch)) {
810  				InsertLine(lineInsert, (position + i) + 1, atLineStart);
811  				lineInsert++;
812  			}
813  		}
814  		chBeforePrev = chPrev;
815  		chPrev = ch;
816  	}
817  }
818  namespace {
819  CountWidths CountCharacterWidthsUTF8(std::string_view sv) noexcept {
820  	CountWidths cw;
821  	size_t remaining = sv.length();
822  	while (remaining > 0) {
823  		const int utf8Status = UTF8Classify(sv);
824  		const int lenChar = utf8Status & UTF8MaskWidth;
825  		cw.CountChar(lenChar);
826  		sv.remove_prefix(lenChar);
827  		remaining -= lenChar;
828  	}
829  	return cw;
830  }
831  }
832  bool CellBuffer::MaintainingLineCharacterIndex() const noexcept {
833  	return plv->LineCharacterIndex() != LineCharacterIndexType::None;
834  }
835  void CellBuffer::RecalculateIndexLineStarts(Sci::Line lineFirst, Sci::Line lineLast) {
836  	std::string text;
837  	Sci::Position posLineEnd = LineStart(lineFirst);
838  	for (Sci::Line line = lineFirst; line <= lineLast; line++) {
839  		const Sci::Position posLineStart = posLineEnd;
840  		posLineEnd = LineStart(line+1);
841  		const Sci::Position width = posLineEnd - posLineStart;
842  		text.resize(width);
843  		GetCharRange(text.data(), posLineStart, width);
844  		const CountWidths cw = CountCharacterWidthsUTF8(text);
845  		plv->SetLineCharactersWidth(line, cw);
846  	}
847  }
848  void CellBuffer::BasicInsertString(Sci::Position position, const char *s, Sci::Position insertLength) {
849  	if (insertLength == 0)
850  		return;
851  	PLATFORM_ASSERT(insertLength > 0);
852  	const unsigned char chAfter = substance.ValueAt(position);
853  	bool breakingUTF8LineEnd = false;
854  	if (utf8LineEnds == LineEndType::Unicode && UTF8IsTrailByte(chAfter)) {
855  		breakingUTF8LineEnd = UTF8LineEndOverlaps(position);
856  	}
857  	const Sci::Line linePosition = plv->LineFromPosition(position);
858  	Sci::Line lineInsert = linePosition + 1;
859  	bool simpleInsertion = false;
860  	const bool maintainingIndex = MaintainingLineCharacterIndex();
861  	if (utf8Substance && maintainingIndex) {
862  		simpleInsertion = UTF8IsCharacterBoundary(position) &&
863  			UTF8IsValid(std::string_view(s, insertLength));
864  	}
865  	substance.InsertFromArray(position, s, 0, insertLength);
866  	if (hasStyles) {
867  		style.InsertValue(position, insertLength, 0);
868  	}
869  	const bool atLineStart = plv->LineStart(lineInsert-1) == position;
870  	plv->InsertText(lineInsert-1, insertLength);
871  	unsigned char chBeforePrev = substance.ValueAt(position - 2);
872  	unsigned char chPrev = substance.ValueAt(position - 1);
873  	if (chPrev == '\r' && chAfter == '\n') {
874  		InsertLine(lineInsert, position, false);
875  		lineInsert++;
876  	}
877  	if (breakingUTF8LineEnd) {
878  		RemoveLine(lineInsert);
879  	}
880  	constexpr size_t PositionBlockSize = 128;
881  	Sci::Position positions[PositionBlockSize]{};
882  	size_t nPositions = 0;
883  	const Sci::Line lineStart = lineInsert;
884  	const char * const end = s + insertLength - 1;
885  	const char *ptr = s;
886  	unsigned char ch = 0;
887  	if (chPrev == '\r' && *ptr == '\n') {
888  		++ptr;
889  		plv->SetLineStart(lineInsert - 1, (position + ptr - s));
890  		simpleInsertion = false;
891  	}
892  	if (ptr < end) {
893  		uint8_t eolTable[256]{};
894  		eolTable[static_cast<uint8_t>('\n')] = 1;
895  		eolTable[static_cast<uint8_t>('\r')] = 2;
896  		if (utf8LineEnds == LineEndType::Unicode) {
897  			eolTable[0x85] = 4;
898  			eolTable[0xa8] = 3;
899  			eolTable[0xa9] = 3;
900  		}
901  		do {
902  			ch = *ptr++;
903  			uint8_t type;
904  			while ((type = eolTable[ch]) == 0 && ptr < end) {
905  				chBeforePrev = chPrev;
906  				chPrev = ch;
907  				ch = *ptr++;
908  			}
909  			switch (type) {
910  			case 2: 
911  				if (*ptr == '\n') {
912  					++ptr;
913  				}
914  				[[fallthrough]];
915  			case 1: 
916  				positions[nPositions++] = position + ptr - s;
917  				if (nPositions == PositionBlockSize) {
918  					plv->InsertLines(lineInsert, positions, nPositions, atLineStart);
919  					lineInsert += nPositions;
920  					nPositions = 0;
921  				}
922  				break;
923  			case 3:
924  			case 4:
925  				if ((type == 3 && chPrev == 0x80 && chBeforePrev == 0xe2) || (type == 4 && chPrev == 0xc2)) {
926  					positions[nPositions++] = position + ptr - s;
927  					if (nPositions == PositionBlockSize) {
928  						plv->InsertLines(lineInsert, positions, nPositions, atLineStart);
929  						lineInsert += nPositions;
930  						nPositions = 0;
931  					}
932  				}
933  				break;
934  			}
935  			chBeforePrev = chPrev;
936  			chPrev = ch;
937  		} while (ptr < end);
938  	}
939  	if (nPositions != 0) {
940  		plv->InsertLines(lineInsert, positions, nPositions, atLineStart);
941  		lineInsert += nPositions;
942  	}
943  	ch = *end;
944  	if (ptr == end) {
945  		++ptr;
946  		if (ch == '\r' || ch == '\n') {
947  			InsertLine(lineInsert, (position + ptr - s), atLineStart);
948  			lineInsert++;
949  		} else if (utf8LineEnds == LineEndType::Unicode && !UTF8IsAscii(ch)) {
950  			if (UTF8IsMultibyteLineEnd(chBeforePrev, chPrev, ch)) {
951  				InsertLine(lineInsert, (position + ptr - s), atLineStart);
952  				lineInsert++;
953  			}
954  		}
955  	}
956  	if (chAfter == '\n') {
957  		if (ch == '\r') {
958  			RemoveLine(lineInsert - 1);
959  			simpleInsertion = false;
960  		}
961  	} else if (utf8LineEnds == LineEndType::Unicode && !UTF8IsAscii(chAfter)) {
962  		chBeforePrev = chPrev;
963  		chPrev = ch;
964  		for (int j = 0; j < UTF8SeparatorLength-1; j++) {
965  			const unsigned char chAt = substance.ValueAt(position + insertLength + j);
966  			const unsigned char back3[3] = {chBeforePrev, chPrev, chAt};
967  			if (UTF8IsSeparator(back3)) {
968  				InsertLine(lineInsert, (position + insertLength + j) + 1, atLineStart);
969  				lineInsert++;
970  			}
971  			if ((j == 0) && UTF8IsNEL(back3+1)) {
972  				InsertLine(lineInsert, (position + insertLength + j) + 1, atLineStart);
973  				lineInsert++;
974  			}
975  			chBeforePrev = chPrev;
976  			chPrev = chAt;
977  		}
978  	}
979  	if (maintainingIndex) {
980  		if (simpleInsertion && (lineInsert == lineStart)) {
981  			const CountWidths cw = CountCharacterWidthsUTF8(std::string_view(s, insertLength));
982  			plv->InsertCharacters(linePosition, cw);
983  		} else {
984  			RecalculateIndexLineStarts(linePosition, lineInsert - 1);
985  		}
986  	}
987  }
988  void CellBuffer::BasicDeleteChars(Sci::Position position, Sci::Position deleteLength) {
989  	if (deleteLength == 0)
990  		return;
991  	Sci::Line lineRecalculateStart = Sci::invalidPosition;
992  	if ((position == 0) && (deleteLength == substance.Length())) {
993  		plv->Init();
994  	} else {
995  		const Sci::Line linePosition = plv->LineFromPosition(position);
996  		Sci::Line lineRemove = linePosition + 1;
997  		plv->InsertText(lineRemove-1, - (deleteLength));
998  		const unsigned char chPrev = substance.ValueAt(position - 1);
999  		const unsigned char chBefore = chPrev;
1000  		unsigned char chNext = substance.ValueAt(position);
1001  		if (utf8Substance && MaintainingLineCharacterIndex()) {
1002  			const Sci::Position posEnd = position + deleteLength;
1003  			const Sci::Line lineEndRemove = plv->LineFromPosition(posEnd);
1004  			const bool simpleDeletion =
1005  				(linePosition == lineEndRemove) &&
1006  				UTF8IsCharacterBoundary(position) && UTF8IsCharacterBoundary(posEnd);
1007  			if (simpleDeletion) {
1008  				std::string text(deleteLength, '\0');
1009  				GetCharRange(text.data(), position, deleteLength);
1010  				if (UTF8IsValid(text)) {
1011  					const CountWidths cw = CountCharacterWidthsUTF8(text);
1012  					plv->InsertCharacters(linePosition, -cw);
1013  				} else {
1014  					lineRecalculateStart = linePosition;
1015  				}
1016  			} else {
1017  				lineRecalculateStart = linePosition;
1018  			}
1019  		}
1020  		bool ignoreNL = false;
1021  		if (chPrev == '\r' && chNext == '\n') {
1022  			plv->SetLineStart(lineRemove, position);
1023  			lineRemove++;
1024  			ignoreNL = true; 	
1025  		}
1026  		if (utf8LineEnds == LineEndType::Unicode && UTF8IsTrailByte(chNext)) {
1027  			if (UTF8LineEndOverlaps(position)) {
1028  				RemoveLine(lineRemove);
1029  			}
1030  		}
1031  		unsigned char ch = chNext;
1032  		for (Sci::Position i = 0; i < deleteLength; i++) {
1033  			chNext = substance.ValueAt(position + i + 1);
1034  			if (ch == '\r') {
1035  				if (chNext != '\n') {
1036  					RemoveLine(lineRemove);
1037  				}
1038  			} else if (ch == '\n') {
1039  				if (ignoreNL) {
1040  					ignoreNL = false; 	
1041  				} else {
1042  					RemoveLine(lineRemove);
1043  				}
1044  			} else if (utf8LineEnds == LineEndType::Unicode) {
1045  				if (!UTF8IsAscii(ch)) {
1046  					const unsigned char next3[3] = {ch, chNext,
1047  						static_cast<unsigned char>(substance.ValueAt(position + i + 2))};
1048  					if (UTF8IsSeparator(next3) || UTF8IsNEL(next3)) {
1049  						RemoveLine(lineRemove);
1050  					}
1051  				}
1052  			}
1053  			ch = chNext;
1054  		}
1055  		const char chAfter = substance.ValueAt(position + deleteLength);
1056  		if (chBefore == '\r' && chAfter == '\n') {
1057  			RemoveLine(lineRemove - 1);
1058  			plv->SetLineStart(lineRemove - 1, position + 1);
1059  		}
1060  	}
1061  	substance.DeleteRange(position, deleteLength);
1062  	if (lineRecalculateStart >= 0) {
1063  		RecalculateIndexLineStarts(lineRecalculateStart, lineRecalculateStart);
1064  	}
1065  	if (hasStyles) {
1066  		style.DeleteRange(position, deleteLength);
1067  	}
1068  }
1069  bool CellBuffer::SetUndoCollection(bool collectUndo) {
1070  	collectingUndo = collectUndo;
1071  	uh.DropUndoSequence();
1072  	return collectingUndo;
1073  }
1074  bool CellBuffer::IsCollectingUndo() const noexcept {
1075  	return collectingUndo;
1076  }
1077  void CellBuffer::BeginUndoAction() {
1078  	uh.BeginUndoAction();
1079  }
1080  void CellBuffer::EndUndoAction() {
1081  	uh.EndUndoAction();
1082  }
1083  void CellBuffer::AddUndoAction(Sci::Position token, bool mayCoalesce) {
1084  	bool startSequence = false;
1085  	uh.AppendAction(ActionType::container, token, nullptr, 0, startSequence, mayCoalesce);
1086  }
1087  void CellBuffer::DeleteUndoHistory() {
1088  	uh.DeleteUndoHistory();
1089  }
1090  bool CellBuffer::CanUndo() const noexcept {
1091  	return uh.CanUndo();
1092  }
1093  int CellBuffer::StartUndo() {
1094  	return uh.StartUndo();
1095  }
1096  const Action &CellBuffer::GetUndoStep() const {
1097  	return uh.GetUndoStep();
1098  }
1099  void CellBuffer::PerformUndoStep() {
1100  	const Action &actionStep = uh.GetUndoStep();
1101  	if (changeHistory && uh.BeforeSavePoint()) {
1102  		changeHistory->StartReversion();
1103  	}
1104  	if (actionStep.at == ActionType::insert) {
1105  		if (substance.Length() < actionStep.lenData) {
1106  			throw std::runtime_error(
1107  				"CellBuffer::PerformUndoStep: deletion must be less than document length.");
1108  		}
1109  		if (changeHistory) {
1110  			changeHistory->DeleteRange(actionStep.position, actionStep.lenData,
1111  				uh.BeforeSavePoint() && !uh.AfterDetachPoint());
1112  		}
1113  		BasicDeleteChars(actionStep.position, actionStep.lenData);
1114  	} else if (actionStep.at == ActionType::remove) {
1115  		BasicInsertString(actionStep.position, actionStep.data.get(), actionStep.lenData);
1116  		if (changeHistory) {
1117  			changeHistory->UndoDeleteStep(actionStep.position, actionStep.lenData, uh.AfterDetachPoint());
1118  		}
1119  	}
1120  	uh.CompletedUndoStep();
1121  }
1122  bool CellBuffer::CanRedo() const noexcept {
1123  	return uh.CanRedo();
1124  }
1125  int CellBuffer::StartRedo() {
1126  	return uh.StartRedo();
1127  }
1128  const Action &CellBuffer::GetRedoStep() const {
1129  	return uh.GetRedoStep();
1130  }
1131  void CellBuffer::PerformRedoStep() {
1132  	const Action &actionStep = uh.GetRedoStep();
1133  	if (actionStep.at == ActionType::insert) {
1134  		BasicInsertString(actionStep.position, actionStep.data.get(), actionStep.lenData);
1135  		if (changeHistory) {
1136  			changeHistory->Insert(actionStep.position, actionStep.lenData, collectingUndo,
1137  				uh.BeforeSavePoint() && !uh.AfterDetachPoint());
1138  		}
1139  	} else if (actionStep.at == ActionType::remove) {
1140  		if (changeHistory) {
1141  			changeHistory->DeleteRangeSavingHistory(actionStep.position, actionStep.lenData,
1142  				uh.BeforeReachableSavePoint(), uh.AfterDetachPoint());
1143  		}
1144  		BasicDeleteChars(actionStep.position, actionStep.lenData);
1145  	}
1146  	if (changeHistory && uh.AfterSavePoint()) {
1147  		changeHistory->EndReversion();
1148  	}
1149  	uh.CompletedRedoStep();
1150  }
1151  void CellBuffer::ChangeHistorySet(bool set) {
1152  	if (set) {
1153  		if (!changeHistory && !uh.CanUndo()) {
1154  			changeHistory = std::make_unique<ChangeHistory>(Length());
1155  		}
1156  	} else {
1157  		changeHistory.reset();
1158  	}
1159  }
1160  int CellBuffer::EditionAt(Sci::Position pos) const noexcept {
1161  	if (changeHistory) {
1162  		return changeHistory->EditionAt(pos);
1163  	}
1164  	return 0;
1165  }
1166  Sci::Position CellBuffer::EditionEndRun(Sci::Position pos) const noexcept {
1167  	if (changeHistory) {
1168  		return changeHistory->EditionEndRun(pos);
1169  	}
1170  	return Length();
1171  }
1172  unsigned int CellBuffer::EditionDeletesAt(Sci::Position pos) const noexcept {
1173  	if (changeHistory) {
1174  		return changeHistory->EditionDeletesAt(pos);
1175  	}
1176  	return 0;
1177  }
1178  Sci::Position CellBuffer::EditionNextDelete(Sci::Position pos) const noexcept {
1179  	if (changeHistory) {
1180  		return changeHistory->EditionNextDelete(pos);
1181  	}
1182  	return Length() + 1;
1183  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CellBuffer.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cassert>
4  #include <cstring>
5  #include <cstdio>
6  #include <cstdarg>
7  #include <stdexcept>
8  #include <string>
9  #include <string_view>
10  #include <vector>
11  #include <optional>
12  #include <algorithm>
13  #include <memory>
14  #include "ScintillaTypes.h"
15  #include "Debugging.h"
16  #include "Position.h"
17  #include "SplitVector.h"
18  #include "Partitioning.h"
19  #include "RunStyles.h"
20  #include "SparseVector.h"
21  #include "ChangeHistory.h"
22  #include "CellBuffer.h"
23  #include "UniConversion.h"
24  namespace Scintilla::Internal {
25  struct CountWidths {
26  	Sci::Position countBasePlane;
27  	Sci::Position countOtherPlanes;
28  	explicit CountWidths(Sci::Position countBasePlane_=0, Sci::Position countOtherPlanes_=0) noexcept :
29  		countBasePlane(countBasePlane_),
30  		countOtherPlanes(countOtherPlanes_) {
31  	}
32  	CountWidths operator-() const noexcept {
33  		return CountWidths(-countBasePlane , -countOtherPlanes);
34  	}
35  	Sci::Position WidthUTF32() const noexcept {
36  		return countBasePlane + countOtherPlanes;
37  	}
38  	Sci::Position WidthUTF16() const noexcept {
39  		return countBasePlane + 2 * countOtherPlanes;
40  	}
41  	void CountChar(int lenChar) noexcept {
42  		if (lenChar == 4) {
43  			countOtherPlanes++;
44  		} else {
45  			countBasePlane++;
46  		}
47  	}
48  };
49  class ILineVector {
50  public:
51  	virtual void Init() = 0;
52  	virtual void SetPerLine(PerLine *pl) noexcept = 0;
53  	virtual void InsertText(Sci::Line line, Sci::Position delta) noexcept = 0;
54  	virtual void InsertLine(Sci::Line line, Sci::Position position, bool lineStart) = 0;
55  	virtual void InsertLines(Sci::Line line, const Sci::Position *positions, size_t lines, bool lineStart) = 0;
56  	virtual void SetLineStart(Sci::Line line, Sci::Position position) noexcept = 0;
57  	virtual void RemoveLine(Sci::Line line) = 0;
58  	virtual Sci::Line Lines() const noexcept = 0;
59  	virtual void AllocateLines(Sci::Line lines) = 0;
60  	virtual Sci::Line LineFromPosition(Sci::Position pos) const noexcept = 0;
61  	virtual Sci::Position LineStart(Sci::Line line) const noexcept = 0;
62  	virtual void InsertCharacters(Sci::Line line, CountWidths delta) noexcept = 0;
63  	virtual void SetLineCharactersWidth(Sci::Line line, CountWidths width) noexcept = 0;
64  	virtual Scintilla::LineCharacterIndexType LineCharacterIndex() const noexcept = 0;
65  	virtual bool AllocateLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex, Sci::Line lines) = 0;
66  	virtual bool ReleaseLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex) = 0;
67  	virtual Sci::Position IndexLineStart(Sci::Line line, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept = 0;
68  	virtual Sci::Line LineFromPositionIndex(Sci::Position pos, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept = 0;
69  	virtual ~ILineVector() {}
70  };
71  }
72  using namespace Scintilla;
73  using namespace Scintilla::Internal;
74  template <typename POS>
75  class LineStartIndex {
76  	static constexpr POS line_cast(Sci::Line pos) noexcept {
77  		return static_cast<POS>(pos);
78  	}
79  public:
80  	int refCount;
81  	Partitioning<POS> starts;
82  	LineStartIndex() : refCount(0), starts(4) {
83  	}
84  	bool Allocate(Sci::Line lines) {
85  		refCount++;
86  		Sci::Position length = starts.PositionFromPartition(starts.Partitions());
87  		for (Sci::Line line = starts.Partitions(); line < lines; line++) {
88  			length++;
89  			starts.InsertPartition(line_cast(line), line_cast(length));
90  		}
91  		return refCount == 1;
92  	}
93  	bool Release() {
94  		if (refCount == 1) {
95  			starts.DeleteAll();
96  		}
97  		refCount--;
98  		return refCount == 0;
99  	}
100  	bool Active() const noexcept {
101  		return refCount > 0;
102  	}
103  	Sci::Position LineWidth(Sci::Line line) const noexcept {
104  		return starts.PositionFromPartition(line_cast(line) + 1) -
105  			starts.PositionFromPartition(line_cast(line));
106  	}
107  	void SetLineWidth(Sci::Line line, Sci::Position width) noexcept {
108  		const Sci::Position widthCurrent = LineWidth(line);
109  		starts.InsertText(line_cast(line), line_cast(width - widthCurrent));
110  	}
111  	void AllocateLines(Sci::Line lines) {
112  		if (lines > starts.Partitions()) {
113  			starts.ReAllocate(lines);
114  		}
115  	}
116  	void InsertLines(Sci::Line line, Sci::Line lines) {
117  		const POS lineAsPos = line_cast(line);
118  		const POS lineStart = starts.PositionFromPartition(lineAsPos - 1) + 1;
119  		for (POS l = 0; l < line_cast(lines); l++) {
120  			starts.InsertPartition(lineAsPos + l, lineStart + l);
121  		}
122  	}
123  };
124  template <typename POS>
125  class LineVector : public ILineVector {
126  	Partitioning<POS> starts;
127  	PerLine *perLine;
128  	LineStartIndex<POS> startsUTF16;
129  	LineStartIndex<POS> startsUTF32;
130  	LineCharacterIndexType activeIndices;
131  	void SetActiveIndices() noexcept {
132  		activeIndices =
133  			  (startsUTF32.Active() ? LineCharacterIndexType::Utf32 : LineCharacterIndexType::None)
134  			| (startsUTF16.Active() ? LineCharacterIndexType::Utf16 : LineCharacterIndexType::None);
135  	}
136  	static constexpr POS pos_cast(Sci::Position pos) noexcept {
137  		return static_cast<POS>(pos);
138  	}
139  	static constexpr Sci::Line line_from_pos_cast(POS line) noexcept {
140  		return static_cast<Sci::Line>(line);
141  	}
142  public:
143  	LineVector() : starts(256), perLine(nullptr), activeIndices(LineCharacterIndexType::None) {
144  	}
145  	void Init() override {
146  		starts.DeleteAll();
147  		if (perLine) {
148  			perLine->Init();
149  		}
150  		startsUTF32.starts.DeleteAll();
151  		startsUTF16.starts.DeleteAll();
152  	}
153  	void SetPerLine(PerLine *pl) noexcept override {
154  		perLine = pl;
155  	}
156  	void InsertText(Sci::Line line, Sci::Position delta) noexcept override {
157  		starts.InsertText(pos_cast(line), pos_cast(delta));
158  	}
159  	void InsertLine(Sci::Line line, Sci::Position position, bool lineStart) override {
160  		const POS lineAsPos = pos_cast(line);
161  		starts.InsertPartition(lineAsPos, pos_cast(position));
162  		if (activeIndices != LineCharacterIndexType::None) {
163  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
164  				startsUTF32.InsertLines(line, 1);
165  			}
166  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
167  				startsUTF16.InsertLines(line, 1);
168  			}
169  		}
170  		if (perLine) {
171  			if ((line > 0) && lineStart)
172  				line--;
173  			perLine->InsertLine(line);
174  		}
175  	}
176  	void InsertLines(Sci::Line line, const Sci::Position *positions, size_t lines, bool lineStart) override {
177  		const POS lineAsPos = pos_cast(line);
178  		if constexpr (sizeof(Sci::Position) == sizeof(POS)) {
179  			starts.InsertPartitions(lineAsPos, positions, lines);
180  		} else {
181  			starts.InsertPartitionsWithCast(lineAsPos, positions, lines);
182  		}
183  		if (activeIndices != LineCharacterIndexType::None) {
184  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
185  				startsUTF32.InsertLines(line, lines);
186  			}
187  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
188  				startsUTF16.InsertLines(line, lines);
189  			}
190  		}
191  		if (perLine) {
192  			if ((line > 0) && lineStart)
193  				line--;
194  			perLine->InsertLines(line, lines);
195  		}
196  	}
197  	void SetLineStart(Sci::Line line, Sci::Position position) noexcept override {
198  		starts.SetPartitionStartPosition(pos_cast(line), pos_cast(position));
199  	}
200  	void RemoveLine(Sci::Line line) override {
201  		starts.RemovePartition(pos_cast(line));
202  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
203  			startsUTF32.starts.RemovePartition(pos_cast(line));
204  		}
205  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
206  			startsUTF16.starts.RemovePartition(pos_cast(line));
207  		}
208  		if (perLine) {
209  			perLine->RemoveLine(line);
210  		}
211  	}
212  	Sci::Line Lines() const noexcept override {
213  		return line_from_pos_cast(starts.Partitions());
214  	}
215  	void AllocateLines(Sci::Line lines) override {
216  		if (lines > Lines()) {
217  			starts.ReAllocate(lines);
218  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
219  				startsUTF32.AllocateLines(lines);
220  			}
221  			if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
222  				startsUTF16.AllocateLines(lines);
223  			}
224  		}
225  	}
226  	Sci::Line LineFromPosition(Sci::Position pos) const noexcept override {
227  		return line_from_pos_cast(starts.PartitionFromPosition(pos_cast(pos)));
228  	}
229  	Sci::Position LineStart(Sci::Line line) const noexcept override {
230  		return starts.PositionFromPartition(pos_cast(line));
231  	}
232  	void InsertCharacters(Sci::Line line, CountWidths delta) noexcept override {
233  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
234  			startsUTF32.starts.InsertText(pos_cast(line), pos_cast(delta.WidthUTF32()));
235  		}
236  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
237  			startsUTF16.starts.InsertText(pos_cast(line), pos_cast(delta.WidthUTF16()));
238  		}
239  	}
240  	void SetLineCharactersWidth(Sci::Line line, CountWidths width) noexcept override {
241  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf32)) {
242  			assert(startsUTF32.starts.Partitions() == starts.Partitions());
243  			startsUTF32.SetLineWidth(line, width.WidthUTF32());
244  		}
245  		if (FlagSet(activeIndices, LineCharacterIndexType::Utf16)) {
246  			assert(startsUTF16.starts.Partitions() == starts.Partitions());
247  			startsUTF16.SetLineWidth(line, width.WidthUTF16());
248  		}
249  	}
250  	LineCharacterIndexType LineCharacterIndex() const noexcept override {
251  		return activeIndices;
252  	}
253  	bool AllocateLineCharacterIndex(LineCharacterIndexType lineCharacterIndex, Sci::Line lines) override {
254  		const LineCharacterIndexType activeIndicesStart = activeIndices;
255  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf32)) {
256  			startsUTF32.Allocate(lines);
257  			assert(startsUTF32.starts.Partitions() == starts.Partitions());
258  		}
259  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf16)) {
260  			startsUTF16.Allocate(lines);
261  			assert(startsUTF16.starts.Partitions() == starts.Partitions());
262  		}
263  		SetActiveIndices();
264  		return activeIndicesStart != activeIndices;
265  	}
266  	bool ReleaseLineCharacterIndex(LineCharacterIndexType lineCharacterIndex) override {
267  		const LineCharacterIndexType activeIndicesStart = activeIndices;
268  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf32)) {
269  			startsUTF32.Release();
270  		}
271  		if (FlagSet(lineCharacterIndex, LineCharacterIndexType::Utf16)) {
272  			startsUTF16.Release();
273  		}
274  		SetActiveIndices();
275  		return activeIndicesStart != activeIndices;
276  	}
277  	Sci::Position IndexLineStart(Sci::Line line, LineCharacterIndexType lineCharacterIndex) const noexcept override {
278  		if (lineCharacterIndex == LineCharacterIndexType::Utf32) {
279  			return startsUTF32.starts.PositionFromPartition(pos_cast(line));
280  		} else {
281  			return startsUTF16.starts.PositionFromPartition(pos_cast(line));
282  		}
283  	}
284  	Sci::Line LineFromPositionIndex(Sci::Position pos, LineCharacterIndexType lineCharacterIndex) const noexcept override {
285  		if (lineCharacterIndex == LineCharacterIndexType::Utf32) {
286  			return line_from_pos_cast(startsUTF32.starts.PartitionFromPosition(pos_cast(pos)));
287  		} else {
288  			return line_from_pos_cast(startsUTF16.starts.PartitionFromPosition(pos_cast(pos)));
289  		}
290  	}
291  };
292  Action::Action() noexcept {
293  	at = ActionType::start;
294  	position = 0;
295  	lenData = 0;
296  	mayCoalesce = false;
297  }
298  void Action::Create(ActionType at_, Sci::Position position_, const char *data_, Sci::Position lenData_, bool mayCoalesce_) {
299  	data = nullptr;
300  	position = position_;
301  	at = at_;
302  	if (lenData_) {
303  		data = std::make_unique<char[]>(lenData_);
304  		memcpy(&data[0], data_, lenData_);
305  	}
306  	lenData = lenData_;
307  	mayCoalesce = mayCoalesce_;
308  }
309  void Action::Clear() noexcept {
310  	data = nullptr;
311  	lenData = 0;
312  }
313  UndoHistory::UndoHistory() {
314  	actions.resize(3);
315  	maxAction = 0;
316  	currentAction = 0;
317  	undoSequenceDepth = 0;
318  	savePoint = 0;
319  	tentativePoint = -1;
320  	actions[currentAction].Create(ActionType::start);
321  }
322  void UndoHistory::EnsureUndoRoom() {
323  	if (static_cast<size_t>(currentAction) >= (actions.size() - 2)) {
324  		actions.resize(actions.size() * 2);
325  	}
326  }
327  const char *UndoHistory::AppendAction(ActionType at, Sci::Position position, const char *data, Sci::Position lengthData,
328  	bool &startSequence, bool mayCoalesce) {
329  	EnsureUndoRoom();
330  	if (currentAction < savePoint) {
331  		savePoint = -1;
332  		if (!detach) {
333  			detach = currentAction;
334  		}
335  	} else if (detach && (*detach > currentAction)) {
336  		detach = currentAction;
337  	}
338  	int oldCurrentAction = currentAction;
339  	if (currentAction >= 1) {
340  		if (0 == undoSequenceDepth) {
341  			ptrdiff_t targetAct = -1;
342  			const Action *actPrevious = &(actions[currentAction + targetAct]);
343  			while ((actPrevious->at == ActionType::container) && actPrevious->mayCoalesce) {
344  				targetAct--;
345  				actPrevious = &(actions[currentAction + targetAct]);
346  			}
347  			if ((currentAction == savePoint) || (currentAction == tentativePoint)) {
348  				currentAction++;
349  			} else if (!actions[currentAction].mayCoalesce) {
350  				currentAction++;
351  			} else if (!mayCoalesce || !actPrevious->mayCoalesce) {
352  				currentAction++;
353  			} else if (at == ActionType::container || actions[currentAction].at == ActionType::container) {
354  				;	
355  			} else if ((at != actPrevious->at) && (actPrevious->at != ActionType::start)) {
356  				currentAction++;
357  			} else if ((at == ActionType::insert) &&
358  			           (position != (actPrevious->position + actPrevious->lenData))) {
359  				currentAction++;
360  			} else if (at == ActionType::remove) {
361  				if ((lengthData == 1) || (lengthData == 2)) {
362  					if ((position + lengthData) == actPrevious->position) {
363  						; 
364  					} else if (position == actPrevious->position) {
365  						; 
366  					} else {
367  						currentAction++;
368  					}
369  				} else {
370  					currentAction++;
371  				}
372  			} else {
373  			}
374  		} else {
375  			if (!actions[currentAction].mayCoalesce)
376  				currentAction++;
377  		}
378  	} else {
379  		currentAction++;
380  	}
381  	startSequence = oldCurrentAction != currentAction;
382  	const int actionWithData = currentAction;
383  	actions[currentAction].Create(at, position, data, lengthData, mayCoalesce);
<span onclick='openModal()' class='match'>384  	currentAction++;
385  	actions[currentAction].Create(ActionType::start);
386  	maxAction = currentAction;
387  	return actions[actionWithData].data.get();
</span>388  }
389  void UndoHistory::BeginUndoAction() {
390  	EnsureUndoRoom();
391  	if (undoSequenceDepth == 0) {
392  		if (actions[currentAction].at != ActionType::start) {
393  			currentAction++;
394  			actions[currentAction].Create(ActionType::start);
395  			maxAction = currentAction;
396  		}
397  		actions[currentAction].mayCoalesce = false;
398  	}
399  	undoSequenceDepth++;
400  }
401  void UndoHistory::EndUndoAction() {
402  	PLATFORM_ASSERT(undoSequenceDepth > 0);
403  	EnsureUndoRoom();
404  	undoSequenceDepth--;
405  	if (0 == undoSequenceDepth) {
406  		if (actions[currentAction].at != ActionType::start) {
407  			currentAction++;
408  			actions[currentAction].Create(ActionType::start);
409  			maxAction = currentAction;
410  		}
411  		actions[currentAction].mayCoalesce = false;
412  	}
413  }
414  void UndoHistory::DropUndoSequence() {
415  	undoSequenceDepth = 0;
416  }
417  void UndoHistory::DeleteUndoHistory() {
418  	for (int i = 1; i < maxAction; i++)
419  		actions[i].Clear();
420  	maxAction = 0;
421  	currentAction = 0;
422  	actions[currentAction].Create(ActionType::start);
423  	savePoint = 0;
424  	tentativePoint = -1;
425  }
426  void UndoHistory::SetSavePoint() noexcept {
427  	savePoint = currentAction;
428  	detach.reset();
429  }
430  bool UndoHistory::IsSavePoint() const noexcept {
431  	return savePoint == currentAction;
432  }
433  bool UndoHistory::BeforeSavePoint() const noexcept {
434  	return (savePoint < 0) || (savePoint > currentAction);
435  }
436  bool UndoHistory::BeforeReachableSavePoint() const noexcept {
437  	return (savePoint >= 0) && !detach && (savePoint > currentAction);
438  }
439  bool UndoHistory::AfterSavePoint() const noexcept {
440  	return (savePoint >= 0) && (savePoint <= currentAction);
441  }
442  bool UndoHistory::AfterDetachPoint() const noexcept {
443  	return detach && (*detach < currentAction);
444  }
445  void UndoHistory::TentativeStart() {
446  	tentativePoint = currentAction;
447  }
448  void UndoHistory::TentativeCommit() {
449  	tentativePoint = -1;
450  	maxAction = currentAction;
451  }
452  bool UndoHistory::TentativeActive() const noexcept {
453  	return tentativePoint >= 0;
454  }
455  int UndoHistory::TentativeSteps() noexcept {
456  	if (actions[currentAction].at == ActionType::start && currentAction > 0)
457  		currentAction--;
458  	if (tentativePoint >= 0)
459  		return currentAction - tentativePoint;
460  	else
461  		return -1;
462  }
463  bool UndoHistory::CanUndo() const noexcept {
464  	return (currentAction > 0) && (maxAction > 0);
465  }
466  int UndoHistory::StartUndo() {
467  	if (actions[currentAction].at == ActionType::start && currentAction > 0)
468  		currentAction--;
469  	int act = currentAction;
470  	while (actions[act].at != ActionType::start && act > 0) {
471  		act--;
472  	}
473  	return currentAction - act;
474  }
475  const Action &UndoHistory::GetUndoStep() const {
476  	return actions[currentAction];
477  }
478  void UndoHistory::CompletedUndoStep() {
479  	currentAction--;
480  }
481  bool UndoHistory::CanRedo() const noexcept {
482  	return maxAction > currentAction;
483  }
484  int UndoHistory::StartRedo() {
485  	if (currentAction < maxAction && actions[currentAction].at == ActionType::start)
486  		currentAction++;
487  	int act = currentAction;
488  	while (act < maxAction && actions[act].at != ActionType::start) {
489  		act++;
490  	}
491  	return act - currentAction;
492  }
493  const Action &UndoHistory::GetRedoStep() const {
494  	return actions[currentAction];
495  }
496  void UndoHistory::CompletedRedoStep() {
497  	currentAction++;
498  }
499  CellBuffer::CellBuffer(bool hasStyles_, bool largeDocument_) :
500  	hasStyles(hasStyles_), largeDocument(largeDocument_) {
501  	readOnly = false;
502  	utf8Substance = false;
503  	utf8LineEnds = LineEndType::Default;
504  	collectingUndo = true;
505  	if (largeDocument)
506  		plv = std::make_unique<LineVector<Sci::Position>>();
507  	else
508  		plv = std::make_unique<LineVector<int>>();
509  }
510  CellBuffer::~CellBuffer() noexcept = default;
511  char CellBuffer::CharAt(Sci::Position position) const noexcept {
512  	return substance.ValueAt(position);
513  }
514  unsigned char CellBuffer::UCharAt(Sci::Position position) const noexcept {
515  	return substance.ValueAt(position);
516  }
517  void CellBuffer::GetCharRange(char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
518  	if (lengthRetrieve <= 0)
519  		return;
520  	if (position < 0)
521  		return;
522  	if ((position + lengthRetrieve) > substance.Length()) {
523  		Platform::DebugPrintf("Bad GetCharRange %.0f for %.0f of %.0f\n",
524  				      static_cast<double>(position),
525  				      static_cast<double>(lengthRetrieve),
526  				      static_cast<double>(substance.Length()));
527  		return;
528  	}
529  	substance.GetRange(buffer, position, lengthRetrieve);
530  }
531  char CellBuffer::StyleAt(Sci::Position position) const noexcept {
532  	return hasStyles ? style.ValueAt(position) : 0;
533  }
534  void CellBuffer::GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
535  	if (lengthRetrieve < 0)
536  		return;
537  	if (position < 0)
538  		return;
539  	if (!hasStyles) {
540  		std::fill(buffer, buffer + lengthRetrieve, static_cast<unsigned char>(0));
541  		return;
542  	}
543  	if ((position + lengthRetrieve) > style.Length()) {
544  		Platform::DebugPrintf("Bad GetStyleRange %.0f for %.0f of %.0f\n",
545  				      static_cast<double>(position),
546  				      static_cast<double>(lengthRetrieve),
547  				      static_cast<double>(style.Length()));
548  		return;
549  	}
550  	style.GetRange(reinterpret_cast<char *>(buffer), position, lengthRetrieve);
551  }
552  const char *CellBuffer::BufferPointer() {
553  	return substance.BufferPointer();
554  }
555  const char *CellBuffer::RangePointer(Sci::Position position, Sci::Position rangeLength) noexcept {
556  	return substance.RangePointer(position, rangeLength);
557  }
558  Sci::Position CellBuffer::GapPosition() const noexcept {
559  	return substance.GapPosition();
560  }
561  SplitView CellBuffer::AllView() const noexcept {
562  	const size_t length = substance.Length();
563  	size_t length1 = substance.GapPosition();
564  	if (length1 == 0) {
565  		length1 = length;
566  	}
567  	return SplitView {
568  		substance.ElementPointer(0),
569  		length1,
570  		substance.ElementPointer(length1) - length1,
571  		length
572  	};
573  }
574  const char *CellBuffer::InsertString(Sci::Position position, const char *s, Sci::Position insertLength, bool &startSequence) {
575  	const char *data = s;
576  	if (!readOnly) {
577  		if (collectingUndo) {
578  			data = uh.AppendAction(ActionType::insert, position, s, insertLength, startSequence);
579  		}
580  		BasicInsertString(position, s, insertLength);
581  		if (changeHistory) {
582  			changeHistory->Insert(position, insertLength, collectingUndo, uh.BeforeReachableSavePoint());
583  		}
584  	}
585  	return data;
586  }
587  bool CellBuffer::SetStyleAt(Sci::Position position, char styleValue) noexcept {
588  	if (!hasStyles) {
589  		return false;
590  	}
591  	const char curVal = style.ValueAt(position);
592  	if (curVal != styleValue) {
593  		style.SetValueAt(position, styleValue);
594  		return true;
595  	} else {
596  		return false;
597  	}
598  }
599  bool CellBuffer::SetStyleFor(Sci::Position position, Sci::Position lengthStyle, char styleValue) noexcept {
600  	if (!hasStyles) {
601  		return false;
602  	}
603  	bool changed = false;
604  	PLATFORM_ASSERT(lengthStyle == 0 ||
605  		(lengthStyle > 0 && lengthStyle + position <= style.Length()));
606  	while (lengthStyle--) {
607  		const char curVal = style.ValueAt(position);
608  		if (curVal != styleValue) {
609  			style.SetValueAt(position, styleValue);
610  			changed = true;
611  		}
612  		position++;
613  	}
614  	return changed;
615  }
616  const char *CellBuffer::DeleteChars(Sci::Position position, Sci::Position deleteLength, bool &startSequence) {
617  	PLATFORM_ASSERT(deleteLength > 0);
618  	const char *data = nullptr;
619  	if (!readOnly) {
620  		if (collectingUndo) {
621  			data = substance.RangePointer(position, deleteLength);
622  			data = uh.AppendAction(ActionType::remove, position, data, deleteLength, startSequence);
623  		}
624  		if (changeHistory) {
625  			changeHistory->DeleteRangeSavingHistory(position, deleteLength,
626  				uh.BeforeReachableSavePoint(), uh.AfterDetachPoint());
627  		}
628  		BasicDeleteChars(position, deleteLength);
629  	}
630  	return data;
631  }
632  Sci::Position CellBuffer::Length() const noexcept {
633  	return substance.Length();
634  }
635  void CellBuffer::Allocate(Sci::Position newSize) {
636  	substance.ReAllocate(newSize);
637  	if (hasStyles) {
638  		style.ReAllocate(newSize);
639  	}
640  }
641  void CellBuffer::SetUTF8Substance(bool utf8Substance_) noexcept {
642  	utf8Substance = utf8Substance_;
643  }
644  void CellBuffer::SetLineEndTypes(LineEndType utf8LineEnds_) {
645  	if (utf8LineEnds != utf8LineEnds_) {
646  		const LineCharacterIndexType indexes = plv->LineCharacterIndex();
647  		utf8LineEnds = utf8LineEnds_;
648  		ResetLineEnds();
649  		AllocateLineCharacterIndex(indexes);
650  	}
651  }
652  bool CellBuffer::ContainsLineEnd(const char *s, Sci::Position length) const noexcept {
653  	unsigned char chBeforePrev = 0;
654  	unsigned char chPrev = 0;
655  	for (Sci::Position i = 0; i < length; i++) {
656  		const unsigned char ch = s[i];
657  		if ((ch == '\r') || (ch == '\n')) {
658  			return true;
659  		} else if (utf8LineEnds == LineEndType::Unicode) {
660  			if (UTF8IsMultibyteLineEnd(chBeforePrev, chPrev, ch)) {
661  				return true;
662  			}
663  		}
664  		chBeforePrev = chPrev;
665  		chPrev = ch;
666  	}
667  	return false;
668  }
669  void CellBuffer::SetPerLine(PerLine *pl) noexcept {
670  	plv->SetPerLine(pl);
671  }
672  LineCharacterIndexType CellBuffer::LineCharacterIndex() const noexcept {
673  	return plv->LineCharacterIndex();
674  }
675  void CellBuffer::AllocateLineCharacterIndex(LineCharacterIndexType lineCharacterIndex) {
676  	if (utf8Substance) {
677  		if (plv->AllocateLineCharacterIndex(lineCharacterIndex, Lines())) {
678  			RecalculateIndexLineStarts(0, Lines() - 1);
679  		}
680  	}
681  }
682  void CellBuffer::ReleaseLineCharacterIndex(LineCharacterIndexType lineCharacterIndex) {
683  	plv->ReleaseLineCharacterIndex(lineCharacterIndex);
684  }
685  Sci::Line CellBuffer::Lines() const noexcept {
686  	return plv->Lines();
687  }
688  void CellBuffer::AllocateLines(Sci::Line lines) {
689  	plv->AllocateLines(lines);
690  }
691  Sci::Position CellBuffer::LineStart(Sci::Line line) const noexcept {
692  	if (line < 0)
693  		return 0;
694  	else if (line >= Lines())
695  		return Length();
696  	else
697  		return plv->LineStart(line);
698  }
699  Sci::Line CellBuffer::LineFromPosition(Sci::Position pos) const noexcept {
700  	return plv->LineFromPosition(pos);
701  }
702  Sci::Position CellBuffer::IndexLineStart(Sci::Line line, LineCharacterIndexType lineCharacterIndex) const noexcept {
703  	return plv->IndexLineStart(line, lineCharacterIndex);
704  }
705  Sci::Line CellBuffer::LineFromPositionIndex(Sci::Position pos, LineCharacterIndexType lineCharacterIndex) const noexcept {
706  	return plv->LineFromPositionIndex(pos, lineCharacterIndex);
707  }
708  bool CellBuffer::IsReadOnly() const noexcept {
709  	return readOnly;
710  }
711  void CellBuffer::SetReadOnly(bool set) noexcept {
712  	readOnly = set;
713  }
714  bool CellBuffer::IsLarge() const noexcept {
715  	return largeDocument;
716  }
717  bool CellBuffer::HasStyles() const noexcept {
718  	return hasStyles;
719  }
720  void CellBuffer::SetSavePoint() {
721  	uh.SetSavePoint();
722  	if (changeHistory) {
723  		changeHistory->SetSavePoint();
724  	}
725  }
726  bool CellBuffer::IsSavePoint() const noexcept {
727  	return uh.IsSavePoint();
728  }
729  void CellBuffer::TentativeStart() {
730  	uh.TentativeStart();
731  }
732  void CellBuffer::TentativeCommit() {
733  	uh.TentativeCommit();
734  }
735  int CellBuffer::TentativeSteps() noexcept {
736  	return uh.TentativeSteps();
737  }
738  bool CellBuffer::TentativeActive() const noexcept {
739  	return uh.TentativeActive();
740  }
741  void CellBuffer::InsertLine(Sci::Line line, Sci::Position position, bool lineStart) {
742  	plv->InsertLine(line, position, lineStart);
743  }
744  void CellBuffer::RemoveLine(Sci::Line line) {
745  	plv->RemoveLine(line);
746  }
747  bool CellBuffer::UTF8LineEndOverlaps(Sci::Position position) const noexcept {
748  	const unsigned char bytes[] = {
749  		static_cast<unsigned char>(substance.ValueAt(position-2)),
750  		static_cast<unsigned char>(substance.ValueAt(position-1)),
751  		static_cast<unsigned char>(substance.ValueAt(position)),
752  		static_cast<unsigned char>(substance.ValueAt(position+1)),
753  	};
754  	return UTF8IsSeparator(bytes) || UTF8IsSeparator(bytes+1) || UTF8IsNEL(bytes+1);
755  }
756  bool CellBuffer::UTF8IsCharacterBoundary(Sci::Position position) const {
757  	assert(position >= 0 && position <= Length());
758  	if (position > 0) {
759  		std::string back;
760  		for (int i = 0; i < UTF8MaxBytes; i++) {
761  			const Sci::Position posBack = position - i;
762  			if (posBack < 0) {
763  				return false;
764  			}
765  			back.insert(0, 1, substance.ValueAt(posBack));
766  			if (!UTF8IsTrailByte(back.front())) {
767  				if (i > 0) {
768  					const int cla = UTF8Classify(back);
769  					if ((cla & UTF8MaskInvalid) || (cla != i)) {
770  						return false;
771  					}
772  				}
773  				break;
774  			}
775  		}
776  	}
777  	if (position < Length()) {
778  		const unsigned char fore = substance.ValueAt(position);
779  		if (UTF8IsTrailByte(fore)) {
780  			return false;
781  		}
782  	}
783  	return true;
784  }
785  void CellBuffer::ResetLineEnds() {
786  	const Sci::Line lines = plv->Lines();
787  	plv->Init();
788  	plv->AllocateLines(lines);
789  	constexpr Sci::Position position = 0;
790  	const Sci::Position length = Length();
791  	plv->InsertText(0, length);
792  	Sci::Line lineInsert = 1;
793  	constexpr bool atLineStart = true;
794  	unsigned char chBeforePrev = 0;
795  	unsigned char chPrev = 0;
796  	for (Sci::Position i = 0; i < length; i++) {
797  		const unsigned char ch = substance.ValueAt(position + i);
798  		if (ch == '\r') {
799  			InsertLine(lineInsert, (position + i) + 1, atLineStart);
800  			lineInsert++;
801  		} else if (ch == '\n') {
802  			if (chPrev == '\r') {
803  				plv->SetLineStart(lineInsert - 1, (position + i) + 1);
804  			} else {
805  				InsertLine(lineInsert, (position + i) + 1, atLineStart);
806  				lineInsert++;
807  			}
808  		} else if (utf8LineEnds == LineEndType::Unicode) {
809  			if (UTF8IsMultibyteLineEnd(chBeforePrev, chPrev, ch)) {
810  				InsertLine(lineInsert, (position + i) + 1, atLineStart);
811  				lineInsert++;
812  			}
813  		}
814  		chBeforePrev = chPrev;
815  		chPrev = ch;
816  	}
817  }
818  namespace {
819  CountWidths CountCharacterWidthsUTF8(std::string_view sv) noexcept {
820  	CountWidths cw;
821  	size_t remaining = sv.length();
822  	while (remaining > 0) {
823  		const int utf8Status = UTF8Classify(sv);
824  		const int lenChar = utf8Status & UTF8MaskWidth;
825  		cw.CountChar(lenChar);
826  		sv.remove_prefix(lenChar);
827  		remaining -= lenChar;
828  	}
829  	return cw;
830  }
831  }
832  bool CellBuffer::MaintainingLineCharacterIndex() const noexcept {
833  	return plv->LineCharacterIndex() != LineCharacterIndexType::None;
834  }
835  void CellBuffer::RecalculateIndexLineStarts(Sci::Line lineFirst, Sci::Line lineLast) {
836  	std::string text;
837  	Sci::Position posLineEnd = LineStart(lineFirst);
838  	for (Sci::Line line = lineFirst; line <= lineLast; line++) {
839  		const Sci::Position posLineStart = posLineEnd;
840  		posLineEnd = LineStart(line+1);
841  		const Sci::Position width = posLineEnd - posLineStart;
842  		text.resize(width);
843  		GetCharRange(text.data(), posLineStart, width);
844  		const CountWidths cw = CountCharacterWidthsUTF8(text);
845  		plv->SetLineCharactersWidth(line, cw);
846  	}
847  }
848  void CellBuffer::BasicInsertString(Sci::Position position, const char *s, Sci::Position insertLength) {
849  	if (insertLength == 0)
850  		return;
851  	PLATFORM_ASSERT(insertLength > 0);
852  	const unsigned char chAfter = substance.ValueAt(position);
853  	bool breakingUTF8LineEnd = false;
854  	if (utf8LineEnds == LineEndType::Unicode && UTF8IsTrailByte(chAfter)) {
855  		breakingUTF8LineEnd = UTF8LineEndOverlaps(position);
856  	}
857  	const Sci::Line linePosition = plv->LineFromPosition(position);
858  	Sci::Line lineInsert = linePosition + 1;
859  	bool simpleInsertion = false;
860  	const bool maintainingIndex = MaintainingLineCharacterIndex();
861  	if (utf8Substance && maintainingIndex) {
862  		simpleInsertion = UTF8IsCharacterBoundary(position) &&
863  			UTF8IsValid(std::string_view(s, insertLength));
864  	}
865  	substance.InsertFromArray(position, s, 0, insertLength);
866  	if (hasStyles) {
867  		style.InsertValue(position, insertLength, 0);
868  	}
869  	const bool atLineStart = plv->LineStart(lineInsert-1) == position;
870  	plv->InsertText(lineInsert-1, insertLength);
871  	unsigned char chBeforePrev = substance.ValueAt(position - 2);
872  	unsigned char chPrev = substance.ValueAt(position - 1);
873  	if (chPrev == '\r' && chAfter == '\n') {
874  		InsertLine(lineInsert, position, false);
875  		lineInsert++;
876  	}
877  	if (breakingUTF8LineEnd) {
878  		RemoveLine(lineInsert);
879  	}
880  	constexpr size_t PositionBlockSize = 128;
881  	Sci::Position positions[PositionBlockSize]{};
882  	size_t nPositions = 0;
883  	const Sci::Line lineStart = lineInsert;
884  	const char * const end = s + insertLength - 1;
885  	const char *ptr = s;
886  	unsigned char ch = 0;
887  	if (chPrev == '\r' && *ptr == '\n') {
888  		++ptr;
889  		plv->SetLineStart(lineInsert - 1, (position + ptr - s));
890  		simpleInsertion = false;
891  	}
892  	if (ptr < end) {
893  		uint8_t eolTable[256]{};
894  		eolTable[static_cast<uint8_t>('\n')] = 1;
895  		eolTable[static_cast<uint8_t>('\r')] = 2;
896  		if (utf8LineEnds == LineEndType::Unicode) {
897  			eolTable[0x85] = 4;
898  			eolTable[0xa8] = 3;
899  			eolTable[0xa9] = 3;
900  		}
901  		do {
902  			ch = *ptr++;
903  			uint8_t type;
904  			while ((type = eolTable[ch]) == 0 && ptr < end) {
905  				chBeforePrev = chPrev;
906  				chPrev = ch;
907  				ch = *ptr++;
908  			}
909  			switch (type) {
910  			case 2: 
911  				if (*ptr == '\n') {
912  					++ptr;
913  				}
914  				[[fallthrough]];
915  			case 1: 
916  				positions[nPositions++] = position + ptr - s;
917  				if (nPositions == PositionBlockSize) {
918  					plv->InsertLines(lineInsert, positions, nPositions, atLineStart);
919  					lineInsert += nPositions;
920  					nPositions = 0;
921  				}
922  				break;
923  			case 3:
924  			case 4:
925  				if ((type == 3 && chPrev == 0x80 && chBeforePrev == 0xe2) || (type == 4 && chPrev == 0xc2)) {
926  					positions[nPositions++] = position + ptr - s;
927  					if (nPositions == PositionBlockSize) {
928  						plv->InsertLines(lineInsert, positions, nPositions, atLineStart);
929  						lineInsert += nPositions;
930  						nPositions = 0;
931  					}
932  				}
933  				break;
934  			}
935  			chBeforePrev = chPrev;
936  			chPrev = ch;
937  		} while (ptr < end);
938  	}
939  	if (nPositions != 0) {
940  		plv->InsertLines(lineInsert, positions, nPositions, atLineStart);
941  		lineInsert += nPositions;
942  	}
943  	ch = *end;
944  	if (ptr == end) {
945  		++ptr;
946  		if (ch == '\r' || ch == '\n') {
947  			InsertLine(lineInsert, (position + ptr - s), atLineStart);
948  			lineInsert++;
949  		} else if (utf8LineEnds == LineEndType::Unicode && !UTF8IsAscii(ch)) {
950  			if (UTF8IsMultibyteLineEnd(chBeforePrev, chPrev, ch)) {
951  				InsertLine(lineInsert, (position + ptr - s), atLineStart);
952  				lineInsert++;
953  			}
954  		}
955  	}
956  	if (chAfter == '\n') {
957  		if (ch == '\r') {
958  			RemoveLine(lineInsert - 1);
959  			simpleInsertion = false;
960  		}
961  	} else if (utf8LineEnds == LineEndType::Unicode && !UTF8IsAscii(chAfter)) {
962  		chBeforePrev = chPrev;
963  		chPrev = ch;
964  		for (int j = 0; j < UTF8SeparatorLength-1; j++) {
965  			const unsigned char chAt = substance.ValueAt(position + insertLength + j);
966  			const unsigned char back3[3] = {chBeforePrev, chPrev, chAt};
967  			if (UTF8IsSeparator(back3)) {
968  				InsertLine(lineInsert, (position + insertLength + j) + 1, atLineStart);
969  				lineInsert++;
970  			}
971  			if ((j == 0) && UTF8IsNEL(back3+1)) {
972  				InsertLine(lineInsert, (position + insertLength + j) + 1, atLineStart);
973  				lineInsert++;
974  			}
975  			chBeforePrev = chPrev;
976  			chPrev = chAt;
977  		}
978  	}
979  	if (maintainingIndex) {
980  		if (simpleInsertion && (lineInsert == lineStart)) {
981  			const CountWidths cw = CountCharacterWidthsUTF8(std::string_view(s, insertLength));
982  			plv->InsertCharacters(linePosition, cw);
983  		} else {
984  			RecalculateIndexLineStarts(linePosition, lineInsert - 1);
985  		}
986  	}
987  }
988  void CellBuffer::BasicDeleteChars(Sci::Position position, Sci::Position deleteLength) {
989  	if (deleteLength == 0)
990  		return;
991  	Sci::Line lineRecalculateStart = Sci::invalidPosition;
992  	if ((position == 0) && (deleteLength == substance.Length())) {
993  		plv->Init();
994  	} else {
995  		const Sci::Line linePosition = plv->LineFromPosition(position);
996  		Sci::Line lineRemove = linePosition + 1;
997  		plv->InsertText(lineRemove-1, - (deleteLength));
998  		const unsigned char chPrev = substance.ValueAt(position - 1);
999  		const unsigned char chBefore = chPrev;
1000  		unsigned char chNext = substance.ValueAt(position);
1001  		if (utf8Substance && MaintainingLineCharacterIndex()) {
1002  			const Sci::Position posEnd = position + deleteLength;
1003  			const Sci::Line lineEndRemove = plv->LineFromPosition(posEnd);
1004  			const bool simpleDeletion =
1005  				(linePosition == lineEndRemove) &&
1006  				UTF8IsCharacterBoundary(position) && UTF8IsCharacterBoundary(posEnd);
1007  			if (simpleDeletion) {
1008  				std::string text(deleteLength, '\0');
1009  				GetCharRange(text.data(), position, deleteLength);
1010  				if (UTF8IsValid(text)) {
1011  					const CountWidths cw = CountCharacterWidthsUTF8(text);
1012  					plv->InsertCharacters(linePosition, -cw);
1013  				} else {
1014  					lineRecalculateStart = linePosition;
1015  				}
1016  			} else {
1017  				lineRecalculateStart = linePosition;
1018  			}
1019  		}
1020  		bool ignoreNL = false;
1021  		if (chPrev == '\r' && chNext == '\n') {
1022  			plv->SetLineStart(lineRemove, position);
1023  			lineRemove++;
1024  			ignoreNL = true; 	
1025  		}
1026  		if (utf8LineEnds == LineEndType::Unicode && UTF8IsTrailByte(chNext)) {
1027  			if (UTF8LineEndOverlaps(position)) {
1028  				RemoveLine(lineRemove);
1029  			}
1030  		}
1031  		unsigned char ch = chNext;
1032  		for (Sci::Position i = 0; i < deleteLength; i++) {
1033  			chNext = substance.ValueAt(position + i + 1);
1034  			if (ch == '\r') {
1035  				if (chNext != '\n') {
1036  					RemoveLine(lineRemove);
1037  				}
1038  			} else if (ch == '\n') {
1039  				if (ignoreNL) {
1040  					ignoreNL = false; 	
1041  				} else {
1042  					RemoveLine(lineRemove);
1043  				}
1044  			} else if (utf8LineEnds == LineEndType::Unicode) {
1045  				if (!UTF8IsAscii(ch)) {
1046  					const unsigned char next3[3] = {ch, chNext,
1047  						static_cast<unsigned char>(substance.ValueAt(position + i + 2))};
1048  					if (UTF8IsSeparator(next3) || UTF8IsNEL(next3)) {
1049  						RemoveLine(lineRemove);
1050  					}
1051  				}
1052  			}
1053  			ch = chNext;
1054  		}
1055  		const char chAfter = substance.ValueAt(position + deleteLength);
1056  		if (chBefore == '\r' && chAfter == '\n') {
1057  			RemoveLine(lineRemove - 1);
1058  			plv->SetLineStart(lineRemove - 1, position + 1);
1059  		}
1060  	}
1061  	substance.DeleteRange(position, deleteLength);
1062  	if (lineRecalculateStart >= 0) {
1063  		RecalculateIndexLineStarts(lineRecalculateStart, lineRecalculateStart);
1064  	}
1065  	if (hasStyles) {
1066  		style.DeleteRange(position, deleteLength);
1067  	}
1068  }
1069  bool CellBuffer::SetUndoCollection(bool collectUndo) {
1070  	collectingUndo = collectUndo;
1071  	uh.DropUndoSequence();
1072  	return collectingUndo;
1073  }
1074  bool CellBuffer::IsCollectingUndo() const noexcept {
1075  	return collectingUndo;
1076  }
1077  void CellBuffer::BeginUndoAction() {
1078  	uh.BeginUndoAction();
1079  }
1080  void CellBuffer::EndUndoAction() {
1081  	uh.EndUndoAction();
1082  }
1083  void CellBuffer::AddUndoAction(Sci::Position token, bool mayCoalesce) {
1084  	bool startSequence = false;
1085  	uh.AppendAction(ActionType::container, token, nullptr, 0, startSequence, mayCoalesce);
1086  }
1087  void CellBuffer::DeleteUndoHistory() {
1088  	uh.DeleteUndoHistory();
1089  }
1090  bool CellBuffer::CanUndo() const noexcept {
1091  	return uh.CanUndo();
1092  }
1093  int CellBuffer::StartUndo() {
1094  	return uh.StartUndo();
1095  }
1096  const Action &CellBuffer::GetUndoStep() const {
1097  	return uh.GetUndoStep();
1098  }
1099  void CellBuffer::PerformUndoStep() {
1100  	const Action &actionStep = uh.GetUndoStep();
1101  	if (changeHistory && uh.BeforeSavePoint()) {
1102  		changeHistory->StartReversion();
1103  	}
1104  	if (actionStep.at == ActionType::insert) {
1105  		if (substance.Length() < actionStep.lenData) {
1106  			throw std::runtime_error(
1107  				"CellBuffer::PerformUndoStep: deletion must be less than document length.");
1108  		}
1109  		if (changeHistory) {
1110  			changeHistory->DeleteRange(actionStep.position, actionStep.lenData,
1111  				uh.BeforeSavePoint() && !uh.AfterDetachPoint());
1112  		}
1113  		BasicDeleteChars(actionStep.position, actionStep.lenData);
1114  	} else if (actionStep.at == ActionType::remove) {
1115  		BasicInsertString(actionStep.position, actionStep.data.get(), actionStep.lenData);
1116  		if (changeHistory) {
1117  			changeHistory->UndoDeleteStep(actionStep.position, actionStep.lenData, uh.AfterDetachPoint());
1118  		}
1119  	}
1120  	uh.CompletedUndoStep();
1121  }
1122  bool CellBuffer::CanRedo() const noexcept {
1123  	return uh.CanRedo();
1124  }
1125  int CellBuffer::StartRedo() {
1126  	return uh.StartRedo();
1127  }
1128  const Action &CellBuffer::GetRedoStep() const {
1129  	return uh.GetRedoStep();
1130  }
1131  void CellBuffer::PerformRedoStep() {
1132  	const Action &actionStep = uh.GetRedoStep();
1133  	if (actionStep.at == ActionType::insert) {
1134  		BasicInsertString(actionStep.position, actionStep.data.get(), actionStep.lenData);
1135  		if (changeHistory) {
1136  			changeHistory->Insert(actionStep.position, actionStep.lenData, collectingUndo,
1137  				uh.BeforeSavePoint() && !uh.AfterDetachPoint());
1138  		}
1139  	} else if (actionStep.at == ActionType::remove) {
1140  		if (changeHistory) {
1141  			changeHistory->DeleteRangeSavingHistory(actionStep.position, actionStep.lenData,
1142  				uh.BeforeReachableSavePoint(), uh.AfterDetachPoint());
1143  		}
1144  		BasicDeleteChars(actionStep.position, actionStep.lenData);
1145  	}
1146  	if (changeHistory && uh.AfterSavePoint()) {
1147  		changeHistory->EndReversion();
1148  	}
1149  	uh.CompletedRedoStep();
1150  }
1151  void CellBuffer::ChangeHistorySet(bool set) {
1152  	if (set) {
1153  		if (!changeHistory && !uh.CanUndo()) {
1154  			changeHistory = std::make_unique<ChangeHistory>(Length());
1155  		}
1156  	} else {
1157  		changeHistory.reset();
1158  	}
1159  }
1160  int CellBuffer::EditionAt(Sci::Position pos) const noexcept {
1161  	if (changeHistory) {
1162  		return changeHistory->EditionAt(pos);
1163  	}
1164  	return 0;
1165  }
1166  Sci::Position CellBuffer::EditionEndRun(Sci::Position pos) const noexcept {
1167  	if (changeHistory) {
1168  		return changeHistory->EditionEndRun(pos);
1169  	}
1170  	return Length();
1171  }
1172  unsigned int CellBuffer::EditionDeletesAt(Sci::Position pos) const noexcept {
1173  	if (changeHistory) {
1174  		return changeHistory->EditionDeletesAt(pos);
1175  	}
1176  	return 0;
1177  }
1178  Sci::Position CellBuffer::EditionNextDelete(Sci::Position pos) const noexcept {
1179  	if (changeHistory) {
1180  		return changeHistory->EditionNextDelete(pos);
1181  	}
1182  	return Length() + 1;
1183  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CellBuffer.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CellBuffer.cxx</div>
                </div>
                <div class="column column_space"><pre><code>407  			currentAction++;
408  			actions[currentAction].Create(ActionType::start);
409  			maxAction = currentAction;
410  		}
</pre></code></div>
                <div class="column column_space"><pre><code>384  	currentAction++;
385  	actions[currentAction].Create(ActionType::start);
386  	maxAction = currentAction;
387  	return actions[actionWithData].data.get();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    