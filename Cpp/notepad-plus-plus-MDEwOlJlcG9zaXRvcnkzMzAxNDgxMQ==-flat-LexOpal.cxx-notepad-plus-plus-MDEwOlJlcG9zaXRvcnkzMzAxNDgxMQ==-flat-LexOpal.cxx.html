
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 29, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexOpal.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  inline static void getRange( Sci_PositionU start, Sci_PositionU end, Accessor & styler, char * s, Sci_PositionU len )
20  {
21  	Sci_PositionU i = 0;
22  	while( ( i < end - start + 1 ) && ( i < len - 1 ) )
23  	{
24  		s[i] = static_cast<char>( styler[ start + i ] );
25  		i++;
26  	}
27  	s[ i ] = '\0';
28  }
29  inline bool HandleString( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
30  {
31  	char ch;
32  	bool even_backslash_count = true; 
33  	cur++; 
34  	for( ; ; )
35  	{
36  		if( cur >= one_too_much )
37  		{
38  			styler.ColourTo( cur - 1, SCE_OPAL_STRING );
39  			return false; 
40  		}
41  		ch = styler.SafeGetCharAt( cur );
42  		if( ( ch == '\015' ) || ( ch == '\012' ) ) 
43  		{
44  			styler.ColourTo( cur - 1, SCE_OPAL_STRING );
45  			styler.StartSegment( cur );
46  			return true;
47  		}
48  		else
49  		{
50  			if( even_backslash_count )
51  			{
52  				if( ch == '"' )
53  				{
54  					styler.ColourTo( cur, SCE_OPAL_STRING );
55  					cur++;
56  					if( cur >= one_too_much )
57  					{
58  						return false; 
59  					}
60  					else
61  					{
62  						styler.StartSegment( cur );
63  						return true;
64  					}
65  				}
66  				else if( ch == '\\' )
67  				{
68  					even_backslash_count = false;
69  				}
70  			}
71  			else
72  			{
73  				even_backslash_count = true;
74  			}
75  		}
76  		cur++;
77  	}
78  }
79  inline bool HandleCommentBlock( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler, bool could_fail )
80  {
81  	char ch;
82  	if( could_fail )
83  	{
84  		cur++;
85  		if( cur >= one_too_much )
86  		{
87  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
88  			return false; 
89  		}
90  		ch = styler.SafeGetCharAt( cur );
91  		if( ch != '*' )
92  		{
93  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
94  			styler.StartSegment( cur );
95  			return true;
96  		}
97  	}
98  	cur++;
99  	bool star_found = false;
100  	for( ; ; )
101  	{
102  		if( cur >= one_too_much )
103  		{
104  			styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_BLOCK );
105  			return false; 
106  		}
107  		ch = styler.SafeGetCharAt( cur );
108  		if( star_found )
109  		{
110  			if( ch == '/' )
111  			{
112  				styler.ColourTo( cur, SCE_OPAL_COMMENT_BLOCK );
113  				cur++;
114  				if( cur >= one_too_much )
115  				{
116  					return false; 
117  				}
118  				else
119  				{
120  					styler.StartSegment( cur );
121  					return true;
122  				}
123  			}
124  			else if( ch != '*' )
125  			{
126  				star_found = false;
127  			}
128  		}
129  		else if( ch == '*' )
130  		{
131  			star_found = true;
132  		}
133  		cur++;
134  	}
135  }
136  inline bool HandleCommentLine( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler, bool could_fail )
137  {
138  	char ch;
139  	if( could_fail )
140  	{
141  		cur++;
142  		if( cur >= one_too_much )
143  		{
144  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
145  			return false; 
146  		}
147  		ch = styler.SafeGetCharAt( cur );
148  		if( ch != '-' )
149  		{
150  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
151  			styler.StartSegment( cur );
152  			return true;
153  		}
154  		cur++;
155  		if( cur >= one_too_much )
156  		{
157  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
158  			return false; 
159  		}
160  		ch = styler.SafeGetCharAt( cur );
161  		if( ( ch != ' ' ) && ( ch != '\t' ) )
162  		{
163  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
164  			styler.StartSegment( cur );
165  			return true;
166  		}
167  	}
168  	bool fifteen_found = false;
169  	for( ; ; )
170  	{
171  		cur++;
172  		if( cur >= one_too_much )
173  		{
174  			styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_LINE );
175  			return false; 
176  		}
177  		ch = styler.SafeGetCharAt( cur );
178  		if( fifteen_found )
179  		{
180  			cur--;
181  			styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_LINE );
182  			styler.StartSegment( cur );
183  			return true;
184  		}
185  		else
186  		{
187  			if( ch == '\015' )
188  			{
189  				fifteen_found = true;
190  			}
191  			else if( ch == '\012' )
192  			{
193  				styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_LINE );
194  				styler.StartSegment( cur );
195  				return true;
196  			}
197  		}
198  	}
199  }
200  inline bool HandlePar( Sci_PositionU & cur, Accessor & styler )
201  {
202  	styler.ColourTo( cur, SCE_OPAL_PAR );
203  	cur++;
204  	styler.StartSegment( cur );
205  	return true;
206  }
207  inline bool HandleSpace( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
208  {
209  	char ch;
210  	cur++;
211  	for( ; ; )
212  	{
213  		if( cur >= one_too_much )
214  		{
215  			styler.ColourTo( cur - 1, SCE_OPAL_SPACE );
216  			return false;
217  		}
218  		ch = styler.SafeGetCharAt( cur );
219  		switch( ch )
220  		{
221  		case ' ':
222  		case '\t':
223  		case '\015':
224  		case '\012':
225  			cur++;
226  			break;
227  		default:
228  			styler.ColourTo( cur - 1, SCE_OPAL_SPACE );
<span onclick='openModal()' class='match'>229  			styler.StartSegment( cur );
230  			return true;
231  		}
232  	}
233  }
234  inline bool HandleInteger( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
235  {
236  	char ch;
</span>237  	for( ; ; )
238  	{
239  		cur++;
240  		if( cur >= one_too_much )
241  		{
242  			styler.ColourTo( cur - 1, SCE_OPAL_INTEGER );
243  			return false; 
244  		}
245  		ch = styler.SafeGetCharAt( cur );
246  		if( !( IsASCII( ch ) && isdigit( ch ) ) )
247  		{
248  			styler.ColourTo( cur - 1, SCE_OPAL_INTEGER );
249  			styler.StartSegment( cur );
250  			return true;
251  		}
252  	}
253  }
254  inline bool HandleWord( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler, WordList * keywordlists[] )
255  {
256  	char ch;
257  	const Sci_PositionU beg = cur;
258  	cur++;
259  	for( ; ; )
260  	{
261  		ch = styler.SafeGetCharAt( cur );
262  		if( ( ch != '_' ) && ( ch != '-' ) &&
263  			!( IsASCII( ch ) && ( islower( ch ) || isupper( ch ) || isdigit( ch ) ) ) ) break;
264  		cur++;
265  		if( cur >= one_too_much )
266  		{
267  			break;
268  		}
269  	}
270  	const Sci_Position ide_len = cur - beg + 1;
271  	char * ide = new char[ ide_len ];
272  	getRange( beg, cur, styler, ide, ide_len );
273  	WordList & keywords    = *keywordlists[ 0 ];
274  	WordList & classwords  = *keywordlists[ 1 ];
275  	if( keywords.InList( ide ) ) 
276  	{
277  		delete [] ide;
278  		styler.ColourTo( cur - 1, SCE_OPAL_KEYWORD );
279  		if( cur >= one_too_much )
280  		{
281  			return false; 
282  		}
283  		else
284  		{
285  			styler.StartSegment( cur );
286  			return true;
287  		}
288  	}
289  	else if( classwords.InList( ide ) ) 
290  	{
291  		delete [] ide;
292  		styler.ColourTo( cur - 1, SCE_OPAL_SORT );
293  		if( cur >= one_too_much )
294  		{
295  			return false; 
296  		}
297  		else
298  		{
299  			styler.StartSegment( cur );
300  			return true;
301  		}
302  	}
303  	else if( !strcmp( ide, "true" ) || !strcmp( ide, "false" ) ) 
304  	{
305  		delete [] ide;
306  		styler.ColourTo( cur - 1, SCE_OPAL_BOOL_CONST );
307  		if( cur >= one_too_much )
308  		{
309  			return false; 
310  		}
311  		else
312  		{
313  			styler.StartSegment( cur );
314  			return true;
315  		}
316  	}
317  	else 
318  	{
319  		delete [] ide;
320  		styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
321  		if( cur >= one_too_much )
322  		{
323  			return false; 
324  		}
325  		else
326  		{
327  			styler.StartSegment( cur );
328  			return true;
329  		}
330  	}
331  }
332  inline bool HandleSkip( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
333  {
334  	cur++;
335  	styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
336  	if( cur >= one_too_much )
337  	{
338  		return false; 
339  	}
340  	else
341  	{
342  		styler.StartSegment( cur );
343  		return true;
344  	}
345  }
346  static void ColouriseOpalDoc( Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[], Accessor & styler )
347  {
348  	styler.StartAt( startPos );
349  	styler.StartSegment( startPos );
350  	Sci_PositionU & cur = startPos;
351  	const Sci_PositionU one_too_much = startPos + length;
352  	int state = initStyle;
353  	for( ; ; )
354  	{
355  		switch( state )
356  		{
357  		case SCE_OPAL_KEYWORD:
358  		case SCE_OPAL_SORT:
359  			if( !HandleWord( cur, one_too_much, styler, keywordlists ) ) return;
360  			state = SCE_OPAL_DEFAULT;
361  			break;
362  		case SCE_OPAL_INTEGER:
363  			if( !HandleInteger( cur, one_too_much, styler ) ) return;
364  			state = SCE_OPAL_DEFAULT;
365  			break;
366  		case SCE_OPAL_COMMENT_BLOCK:
367  			if( !HandleCommentBlock( cur, one_too_much, styler, false ) ) return;
368  			state = SCE_OPAL_DEFAULT;
369  			break;
370  		case SCE_OPAL_COMMENT_LINE:
371  			if( !HandleCommentLine( cur, one_too_much, styler, false ) ) return;
372  			state = SCE_OPAL_DEFAULT;
373  			break;
374  		case SCE_OPAL_STRING:
375  			if( !HandleString( cur, one_too_much, styler ) ) return;
376  			state = SCE_OPAL_DEFAULT;
377  			break;
378  		default: 
379  			{
380  				char ch = styler.SafeGetCharAt( cur );
381  				switch( ch )
382  				{
383  				case '"':
384  					if( !HandleString( cur, one_too_much, styler ) ) return;
385  					break;
386  				case '/':
387  					if( !HandleCommentBlock( cur, one_too_much, styler, true ) ) return;
388  					break;
389  				case '-':
390  					if( !HandleCommentLine( cur, one_too_much, styler, true ) ) return;
391  					break;
392  				case '(':
393  				case ')':
394  				case '[':
395  				case ']':
396  				case '{':
397  				case '}':
398  					if( !HandlePar( cur, styler ) ) return;
399  					break;
400  				case ' ':
401  				case '\t':
402  				case '\015':
403  				case '\012':
404  					if( !HandleSpace( cur, one_too_much, styler ) ) return;
405  					break;
406  				default:
407  					{
408  						if( IsASCII( ch ) && isdigit( ch ) )
409  						{
410  							if( !HandleInteger( cur, one_too_much, styler ) ) return;
411  						}
412  						else if( IsASCII( ch ) && ( islower( ch ) || isupper( ch ) ) )
413  						{
414  							if( !HandleWord( cur, one_too_much, styler, keywordlists ) ) return;
415  						}
416  						else
417  						{
418  							if( !HandleSkip( cur, one_too_much, styler ) ) return;
419  						}
420  					}
421  				}
422  				break;
423  			}
424  		}
425  	}
426  }
427  static const char * const opalWordListDesc[] = {
428  	"Keywords",
429  	"Sorts",
430  	0
431  };
432  LexerModule lmOpal(SCLEX_OPAL, ColouriseOpalDoc, "opal", NULL, opalWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexOpal.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  inline static void getRange( Sci_PositionU start, Sci_PositionU end, Accessor & styler, char * s, Sci_PositionU len )
20  {
21  	Sci_PositionU i = 0;
22  	while( ( i < end - start + 1 ) && ( i < len - 1 ) )
23  	{
24  		s[i] = static_cast<char>( styler[ start + i ] );
25  		i++;
26  	}
27  	s[ i ] = '\0';
28  }
29  inline bool HandleString( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
30  {
31  	char ch;
32  	bool even_backslash_count = true; 
33  	cur++; 
34  	for( ; ; )
35  	{
36  		if( cur >= one_too_much )
37  		{
38  			styler.ColourTo( cur - 1, SCE_OPAL_STRING );
39  			return false; 
40  		}
41  		ch = styler.SafeGetCharAt( cur );
42  		if( ( ch == '\015' ) || ( ch == '\012' ) ) 
43  		{
44  			styler.ColourTo( cur - 1, SCE_OPAL_STRING );
45  			styler.StartSegment( cur );
46  			return true;
47  		}
48  		else
49  		{
50  			if( even_backslash_count )
51  			{
52  				if( ch == '"' )
53  				{
54  					styler.ColourTo( cur, SCE_OPAL_STRING );
55  					cur++;
56  					if( cur >= one_too_much )
57  					{
58  						return false; 
59  					}
60  					else
61  					{
62  						styler.StartSegment( cur );
63  						return true;
64  					}
65  				}
66  				else if( ch == '\\' )
67  				{
68  					even_backslash_count = false;
69  				}
70  			}
71  			else
72  			{
73  				even_backslash_count = true;
74  			}
75  		}
76  		cur++;
77  	}
78  }
79  inline bool HandleCommentBlock( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler, bool could_fail )
80  {
81  	char ch;
82  	if( could_fail )
83  	{
84  		cur++;
85  		if( cur >= one_too_much )
86  		{
87  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
88  			return false; 
89  		}
90  		ch = styler.SafeGetCharAt( cur );
91  		if( ch != '*' )
92  		{
93  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
94  			styler.StartSegment( cur );
95  			return true;
96  		}
97  	}
98  	cur++;
99  	bool star_found = false;
100  	for( ; ; )
101  	{
102  		if( cur >= one_too_much )
103  		{
104  			styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_BLOCK );
105  			return false; 
106  		}
107  		ch = styler.SafeGetCharAt( cur );
108  		if( star_found )
109  		{
110  			if( ch == '/' )
111  			{
112  				styler.ColourTo( cur, SCE_OPAL_COMMENT_BLOCK );
113  				cur++;
114  				if( cur >= one_too_much )
115  				{
116  					return false; 
117  				}
118  				else
119  				{
120  					styler.StartSegment( cur );
121  					return true;
122  				}
123  			}
124  			else if( ch != '*' )
125  			{
126  				star_found = false;
127  			}
128  		}
129  		else if( ch == '*' )
130  		{
131  			star_found = true;
132  		}
133  		cur++;
134  	}
135  }
136  inline bool HandleCommentLine( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler, bool could_fail )
137  {
138  	char ch;
139  	if( could_fail )
140  	{
141  		cur++;
142  		if( cur >= one_too_much )
143  		{
144  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
145  			return false; 
146  		}
147  		ch = styler.SafeGetCharAt( cur );
148  		if( ch != '-' )
149  		{
150  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
151  			styler.StartSegment( cur );
152  			return true;
153  		}
154  		cur++;
155  		if( cur >= one_too_much )
156  		{
157  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
158  			return false; 
159  		}
160  		ch = styler.SafeGetCharAt( cur );
161  		if( ( ch != ' ' ) && ( ch != '\t' ) )
162  		{
163  			styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
164  			styler.StartSegment( cur );
165  			return true;
166  		}
167  	}
168  	bool fifteen_found = false;
169  	for( ; ; )
170  	{
171  		cur++;
172  		if( cur >= one_too_much )
173  		{
174  			styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_LINE );
175  			return false; 
176  		}
177  		ch = styler.SafeGetCharAt( cur );
178  		if( fifteen_found )
179  		{
180  			cur--;
181  			styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_LINE );
182  			styler.StartSegment( cur );
183  			return true;
184  		}
185  		else
186  		{
187  			if( ch == '\015' )
188  			{
189  				fifteen_found = true;
190  			}
191  			else if( ch == '\012' )
192  			{
193  				styler.ColourTo( cur - 1, SCE_OPAL_COMMENT_LINE );
194  				styler.StartSegment( cur );
195  				return true;
196  			}
197  		}
198  	}
199  }
200  inline bool HandlePar( Sci_PositionU & cur, Accessor & styler )
201  {
202  	styler.ColourTo( cur, SCE_OPAL_PAR );
203  	cur++;
204  	styler.StartSegment( cur );
205  	return true;
206  }
207  inline bool HandleSpace( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
208  {
209  	char ch;
210  	cur++;
211  	for( ; ; )
212  	{
213  		if( cur >= one_too_much )
214  		{
215  			styler.ColourTo( cur - 1, SCE_OPAL_SPACE );
216  			return false;
217  		}
218  		ch = styler.SafeGetCharAt( cur );
219  		switch( ch )
220  		{
221  		case ' ':
222  		case '\t':
223  		case '\015':
224  		case '\012':
225  			cur++;
226  			break;
227  		default:
228  			styler.ColourTo( cur - 1, SCE_OPAL_SPACE );
229  			styler.StartSegment( cur );
230  			return true;
231  		}
232  	}
233  }
234  inline bool HandleInteger( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
235  {
236  	char ch;
237  	for( ; ; )
238  	{
239  		cur++;
240  		if( cur >= one_too_much )
241  		{
242  			styler.ColourTo( cur - 1, SCE_OPAL_INTEGER );
243  			return false; 
244  		}
245  		ch = styler.SafeGetCharAt( cur );
246  		if( !( IsASCII( ch ) && isdigit( ch ) ) )
247  		{
248  			styler.ColourTo( cur - 1, SCE_OPAL_INTEGER );
249  			styler.StartSegment( cur );
250  			return true;
251  		}
252  	}
253  }
254  inline bool HandleWord( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler, WordList * keywordlists[] )
255  {
256  	char ch;
257  	const Sci_PositionU beg = cur;
258  	cur++;
259  	for( ; ; )
260  	{
261  		ch = styler.SafeGetCharAt( cur );
262  		if( ( ch != '_' ) && ( ch != '-' ) &&
263  			!( IsASCII( ch ) && ( islower( ch ) || isupper( ch ) || isdigit( ch ) ) ) ) break;
264  		cur++;
265  		if( cur >= one_too_much )
266  		{
267  			break;
268  		}
269  	}
270  	const Sci_Position ide_len = cur - beg + 1;
271  	char * ide = new char[ ide_len ];
272  	getRange( beg, cur, styler, ide, ide_len );
273  	WordList & keywords    = *keywordlists[ 0 ];
274  	WordList & classwords  = *keywordlists[ 1 ];
275  	if( keywords.InList( ide ) ) 
276  	{
277  		delete [] ide;
278  		styler.ColourTo( cur - 1, SCE_OPAL_KEYWORD );
279  		if( cur >= one_too_much )
280  		{
281  			return false; 
282  		}
283  		else
284  		{
285  			styler.StartSegment( cur );
286  			return true;
287  		}
288  	}
289  	else if( classwords.InList( ide ) ) 
290  	{
291  		delete [] ide;
292  		styler.ColourTo( cur - 1, SCE_OPAL_SORT );
293  		if( cur >= one_too_much )
294  		{
295  			return false; 
296  		}
297  		else
298  		{
299  			styler.StartSegment( cur );
300  			return true;
301  		}
302  	}
303  	else if( !strcmp( ide, "true" ) || !strcmp( ide, "false" ) ) 
304  	{
305  		delete [] ide;
306  		styler.ColourTo( cur - 1, SCE_OPAL_BOOL_CONST );
307  		if( cur >= one_too_much )
308  		{
309  			return false; 
310  		}
311  		else
312  		{
313  			styler.StartSegment( cur );
314  			return true;
315  		}
316  	}
317  	else 
318  	{
319  		delete [] ide;
320  		styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
321  		if( cur >= one_too_much )
322  		{
323  			return false; 
324  		}
325  		else
326  		{
<span onclick='openModal()' class='match'>327  			styler.StartSegment( cur );
328  			return true;
329  		}
330  	}
331  }
332  inline bool HandleSkip( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
333  {
334  	cur++;
</span>335  	styler.ColourTo( cur - 1, SCE_OPAL_DEFAULT );
336  	if( cur >= one_too_much )
337  	{
338  		return false; 
339  	}
340  	else
341  	{
342  		styler.StartSegment( cur );
343  		return true;
344  	}
345  }
346  static void ColouriseOpalDoc( Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[], Accessor & styler )
347  {
348  	styler.StartAt( startPos );
349  	styler.StartSegment( startPos );
350  	Sci_PositionU & cur = startPos;
351  	const Sci_PositionU one_too_much = startPos + length;
352  	int state = initStyle;
353  	for( ; ; )
354  	{
355  		switch( state )
356  		{
357  		case SCE_OPAL_KEYWORD:
358  		case SCE_OPAL_SORT:
359  			if( !HandleWord( cur, one_too_much, styler, keywordlists ) ) return;
360  			state = SCE_OPAL_DEFAULT;
361  			break;
362  		case SCE_OPAL_INTEGER:
363  			if( !HandleInteger( cur, one_too_much, styler ) ) return;
364  			state = SCE_OPAL_DEFAULT;
365  			break;
366  		case SCE_OPAL_COMMENT_BLOCK:
367  			if( !HandleCommentBlock( cur, one_too_much, styler, false ) ) return;
368  			state = SCE_OPAL_DEFAULT;
369  			break;
370  		case SCE_OPAL_COMMENT_LINE:
371  			if( !HandleCommentLine( cur, one_too_much, styler, false ) ) return;
372  			state = SCE_OPAL_DEFAULT;
373  			break;
374  		case SCE_OPAL_STRING:
375  			if( !HandleString( cur, one_too_much, styler ) ) return;
376  			state = SCE_OPAL_DEFAULT;
377  			break;
378  		default: 
379  			{
380  				char ch = styler.SafeGetCharAt( cur );
381  				switch( ch )
382  				{
383  				case '"':
384  					if( !HandleString( cur, one_too_much, styler ) ) return;
385  					break;
386  				case '/':
387  					if( !HandleCommentBlock( cur, one_too_much, styler, true ) ) return;
388  					break;
389  				case '-':
390  					if( !HandleCommentLine( cur, one_too_much, styler, true ) ) return;
391  					break;
392  				case '(':
393  				case ')':
394  				case '[':
395  				case ']':
396  				case '{':
397  				case '}':
398  					if( !HandlePar( cur, styler ) ) return;
399  					break;
400  				case ' ':
401  				case '\t':
402  				case '\015':
403  				case '\012':
404  					if( !HandleSpace( cur, one_too_much, styler ) ) return;
405  					break;
406  				default:
407  					{
408  						if( IsASCII( ch ) && isdigit( ch ) )
409  						{
410  							if( !HandleInteger( cur, one_too_much, styler ) ) return;
411  						}
412  						else if( IsASCII( ch ) && ( islower( ch ) || isupper( ch ) ) )
413  						{
414  							if( !HandleWord( cur, one_too_much, styler, keywordlists ) ) return;
415  						}
416  						else
417  						{
418  							if( !HandleSkip( cur, one_too_much, styler ) ) return;
419  						}
420  					}
421  				}
422  				break;
423  			}
424  		}
425  	}
426  }
427  static const char * const opalWordListDesc[] = {
428  	"Keywords",
429  	"Sorts",
430  	0
431  };
432  LexerModule lmOpal(SCLEX_OPAL, ColouriseOpalDoc, "opal", NULL, opalWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexOpal.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexOpal.cxx</div>
                </div>
                <div class="column column_space"><pre><code>229  			styler.StartSegment( cur );
230  			return true;
231  		}
232  	}
233  }
234  inline bool HandleInteger( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
235  {
236  	char ch;
</pre></code></div>
                <div class="column column_space"><pre><code>327  			styler.StartSegment( cur );
328  			return true;
329  		}
330  	}
331  }
332  inline bool HandleSkip( Sci_PositionU & cur, Sci_PositionU one_too_much, Accessor & styler )
333  {
334  	cur++;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    