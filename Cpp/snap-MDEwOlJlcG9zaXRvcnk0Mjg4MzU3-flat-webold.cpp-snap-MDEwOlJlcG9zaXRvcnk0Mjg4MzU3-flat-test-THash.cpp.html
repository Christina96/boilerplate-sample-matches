
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webold.cpp</h3>
            <pre><code>1  #include "webold.h"
2  #include "webmb.h"
3  const char TXWebPg::SepCh='#';
4  TXWebPg::TXWebPg(const PSIn& SIn):
5    UrlStrV(), RefUrlStrV(), HttpResp(){
6    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum);
7    Lx.GetSym(syQStr, syEoln);
8    while (Lx.Sym==syQStr){UrlStrV.Add(Lx.Str); Lx.GetSym(syQStr, syEoln);}
9    Lx.GetSym(syQStr, syEoln);
10    while (Lx.Sym==syQStr){RefUrlStrV.Add(Lx.Str); Lx.GetSym(syQStr, syEoln);}
11    PSIn HttpRespSIn=Lx.GetSIn(SepCh);
12    HttpResp=THttpResp::LoadTxt(HttpRespSIn);
13  }
14  bool TXWebPg::IsText(){
15    if ((!HttpResp->IsContType())||HttpResp->IsContType("text/")){
16      TStr Str=HttpResp->GetBodyAsStr();
17      int StrLen=Str.Len(); int ChN=0; int PrintChs=0;
18      while ((ChN<100)&&(ChN<StrLen)){
19        char Ch=Str[ChN++];
20        if (((' '<=Ch)&&(Ch<='~'))||(Ch==TCh::TabCh)||(Ch==TCh::LfCh)||(Ch==TCh::CrCh)){
21          PrintChs++;}
22      }
23      double PrintPrc=double(PrintChs)/double(ChN+1);
24      return PrintPrc>0.9;
25    } else {
26      return false;
27    }
28  }
29  PXWebPg TXWebPg::LoadTxt(const PSIn& SIn, const TStrV& UrlStrV,
30   const TStrV& RefUrlStrV){
31    PXWebPg WebPg=PXWebPg(new TXWebPg(SIn));
32    WebPg->UrlStrV=UrlStrV; WebPg->RefUrlStrV=RefUrlStrV;
33    return WebPg;
34  }
35  void TXWebPg::SaveTxt(const PSOut& SOut){
36    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
37    for (int UrlStrN=0; UrlStrN<UrlStrV.Len(); UrlStrN++){
38      Lx.PutQStr(UrlStrV[UrlStrN]);}
39    Lx.PutLn();
40    for (int RefUrlStrN=0; RefUrlStrN<RefUrlStrV.Len(); RefUrlStrN++){
41      Lx.PutQStr(RefUrlStrV[RefUrlStrN]);}
42    Lx.PutLn();
43    HttpResp->SaveTxt(Lx.GetSOut(SepCh));
44  }
45  class TXWebFetchSockEvent: public TSockEvent{
46  private:
47    static const int MxGetHostTrys;
48    static const int MxFetchTrys;
49    TXWebFetch* Fetch;
50    TInt WebPgId;
51    PUrl WebPgUrl;
52    TUrlV WebPgUrlV;
53    int MxSize;
54    int GetHostTrys;
<span onclick='openModal()' class='match'>55    int FetchTrys;
56    PSockHost SockHost;
57    PSock Sock;
58    TBool OppSockClosed;
59    TMOut SockMOut;
60  public:
</span>61    TXWebFetchSockEvent(TXWebFetch* _Fetch, const int& _WebPgId,
62     const PUrl& _WebPgUrl, const int& _MxSize=-1):
63      TSockEvent(),
64      Fetch(_Fetch), WebPgId(_WebPgId),
65      WebPgUrl(_WebPgUrl), WebPgUrlV(),
66      MxSize(_MxSize), GetHostTrys(0), FetchTrys(0),
67      SockHost(NULL), Sock(NULL),
68      OppSockClosed(true), SockMOut(10000){}
69    void PreDelete(){SockHost=NULL; Sock=NULL;}
70    ~TXWebFetchSockEvent(){}
71    TSockEvent& operator=(const TSockEvent&){Fail; return *this;}
72    void OnWebFetchError(const TStr& ErrStr);
73    void OnWebFetchEnd(const PHttpResp& HttpResp);
74    void OnRead(const int& SockId, const PSIn& SIn);
75    void OnWrite(const int&){}
76    void OnOob(const int&){Fail;}
77    void OnAccept(const int&, const PSock&){Fail;}
78    void OnConnect(const int&);
79    void OnClose(const int&);
80    void OnTimeOut(const int&);
81    void OnError(const int&, const int&, const TStr&);
82    void OnGetHost(const PSockHost& _SockHost);
83    TStr GetMsg(){
84      return TInt::GetStr(WebPgId)+" "+WebPgUrlV[0]->GetUrlStr();}
85  };
86  const int TXWebFetchSockEvent::MxGetHostTrys=3;
87  const int TXWebFetchSockEvent::MxFetchTrys=3;
88  void TXWebFetchSockEvent::OnWebFetchError(const TStr& ErrStr){
89    TStr UrlStr=WebPgUrl->GetUrlStr();
90    Fetch->UnconnWebPg(WebPgId);
91    Fetch->OnError(WebPgId, ErrStr+" ["+UrlStr+"]");
92    PreDelete();
93  }
94  void TXWebFetchSockEvent::OnWebFetchEnd(const PHttpResp& HttpResp){
95    IAssert(HttpResp->IsOk());
96    int StatusCd=HttpResp->GetStatusCd();
97    if (StatusCd/100==2){
98      TStrV UrlStrV; TStrV RefUrlStrV;
99      for (int UrlN=0; UrlN<WebPgUrlV.Len(); UrlN++){
100        UrlStrV.Add(WebPgUrlV[UrlN]->GetUrlStr());
101        if (WebPgUrlV[UrlN]->IsBaseUrl()){
102          RefUrlStrV.AddMerged(WebPgUrlV[UrlN]->GetBaseUrlStr());}
103      }
104      PXWebPg WebPg=new TXWebPg(UrlStrV, RefUrlStrV, HttpResp);
105      Fetch->UnconnWebPg(WebPgId);
106      Fetch->OnFetch(WebPgId, WebPg);
107      Fetch->OnStatus(Fetch->GetStatusStr());
108      PreDelete();
109    } else
110    if (StatusCd/100==3){
111      if (WebPgUrlV.Len()<5){
112        TStr RedirUrlStr=HttpResp->GetFldVal("Location");
113        PUrl RedirUrl=new TUrl(RedirUrlStr);
114        if (RedirUrl->IsOk(usHttp)){
115          WebPgUrl=RedirUrl; GetHostTrys=0; FetchTrys=0;
116          SockHost=NULL; Sock=NULL;
117          if (Fetch->DoFetchRedirUrl(WebPgUrl, WebPgUrlV)){
118            TSockHost::GetAsyncSockHost(WebPgUrl->GetHostNm(), this);
119          } else {
120            Fetch->OnNotify(WebPgId,
121             TStr("Redirection already fetched [")+WebPgUrl->GetUrlStr()+"]");
122            Fetch->UnconnWebPg(WebPgId);
123          }
124        } else {
125          OnWebFetchError(TStr("Invalid Redirection URL (")+RedirUrlStr+")");
126        }
127      } else {
128        OnWebFetchError("Cycling Redirection");
129      }
130    } else {
131      OnWebFetchError(TStr("Http Error (")+HttpResp->GetReasonPhrase()+")");
132    }
133  }
134  void TXWebFetchSockEvent::OnRead(const int&, const PSIn& SIn){
135    SockMOut.Save(*SIn);
136    if ((MxSize!=-1)&&(SockMOut.Len()>MxSize)){
137      OnWebFetchError(TStr("Page too big (max. ")+TInt::GetStr(MxSize)+")");
138    }
139  }
140  void TXWebFetchSockEvent::OnConnect(const int&){
141    TStr AbsPath=WebPgUrl->GetPathStr()+WebPgUrl->GetSearchStr();
142    TStr RqStr=TStr("GET ")+AbsPath+" HTTP/1.0\r\n\r\n";
143    Sock->Send(TStrIn::New(RqStr));
144    Sock->PutTimeOut(10000);
145  }
146  void TXWebFetchSockEvent::OnClose(const int&){
147    OppSockClosed=true;
148    Sock->PutTimeOut(1);
149  }
150  void TXWebFetchSockEvent::OnTimeOut(const int&){
151    if (OppSockClosed){
152      PSIn SIn=SockMOut.GetSIn();
153      PHttpResp HttpResp=THttpResp::LoadTxt(SIn);
154      if (HttpResp->IsOk()){
155        OnWebFetchEnd(HttpResp);
156      } else {
157        OnWebFetchError("Invalid Http Response");
158      }
159    } else {
160      FetchTrys++;
161      if (FetchTrys<MxFetchTrys){
162        OnGetHost(SockHost);
163      } else {
164        OnWebFetchError("Timeout");
165      }
166    }
167  }
168  void TXWebFetchSockEvent::OnError(const int&, const int&, const TStr& SockErrStr){
169    FetchTrys++;
170    if (FetchTrys<MxFetchTrys){
171      OnGetHost(SockHost);
172    } else {
173      OnWebFetchError(TStr("Socket Error (")+SockErrStr+")");
174    }
175  }
176  void TXWebFetchSockEvent::OnGetHost(const PSockHost& _SockHost){
177    if (_SockHost->IsOk()){
178      SockHost=_SockHost;
179      WebPgUrlV.Add(WebPgUrl);
180      OppSockClosed=false;
181      SockMOut.Clr();
182      Sock=PSock(new TSock(this));
183      Sock->Connect(SockHost, WebPgUrl->GetPortN());
184      Sock->PutTimeOut(10000);
185    } else
186    if (_SockHost->GetStatus()==shsTryAgain){
187      GetHostTrys++;
188      if (GetHostTrys<MxGetHostTrys){
189        TSockHost::GetAsyncSockHost(WebPgUrl->GetHostNm(), this);
190      } else {
191        OnWebFetchError("Can't get host info");
192      }
193    } else {
194      OnWebFetchError("Invalid Host");
195    }
196  }
197  class TXWebFetchReportEvent: public TReportEvent{
198  private:
199    TXWebFetch* Fetch;
200    int WebPgId;
201    PUrl WebPgUrl;
202  public:
203    TXWebFetchReportEvent(TXWebFetch* _WebFetch, const int& _WebPgId,
204     const PUrl& _WebPgUrl):
205      TReportEvent(),
206      Fetch(_WebFetch), WebPgId(_WebPgId), WebPgUrl(_WebPgUrl){}
207    ~TXWebFetchReportEvent(){}
208    TXWebFetchReportEvent& operator=(const TXWebFetchReportEvent&){
209      Fail; return *this;}
210    void OnReport(){
211      PXWebPg WebPg=Fetch->GetWebPg(WebPgUrl->GetUrlStr());
212      Fetch->UnconnWebPg(WebPgId);
213      Fetch->OnFetch(WebPgId, WebPg);
214      Fetch->OnStatus(Fetch->GetStatusStr());
215      Fetch->Continue();
216    }
217  };
218  const TStr TXWebFetch::WebFetchFNm="WebFetch.Txt";
219  const int TXWebFetch::ExpectedUnconns=10000;
220  const int TXWebFetch::ExpectedConns=1000;
221  TXWebFetch::TXWebFetch(const TStr& FPath):
222    MxConns(), MxSize(), LastWebPgId(),
223    UnconnWebPgIdToUrlStrQ(ExpectedUnconns),
224    ConnWebPgIdToUrlStrH(ExpectedConns),
225    ConnWebPgUrlStrToIdH(ExpectedConns),
226    ConnWebPgIdToSockEventH(ExpectedConns){
227    PSIn SIn=new TFIn(TStr::GetNrFPath(FPath)+WebFetchFNm);
228    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum);
229    MxConns=Lx.GetVarInt("MxConns");
230    MxSize=Lx.GetVarInt("MxSize");
231    LastWebPgId=Lx.GetVarInt("LastWebPageId");
232    int Unconns=Lx.GetVarInt("UnconnWebPageIdToUrlStrQ");
233    for (int UnconnN=0; UnconnN<Unconns; UnconnN++){
234      int WebPgId=Lx.GetInt(); TStr UrlStr=Lx.GetQStr(); Lx.GetEoln();
235      UnconnWebPgIdToUrlStrQ.Push(TIntStrPr(WebPgId, UrlStr));
236    }
237  }
238  void TXWebFetch::SaveTxt(const TStr& FPath){
239    PSOut SOut=new TFOut(TStr::GetNrFPath(FPath)+WebFetchFNm);
240    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
241    Lx.PutVarInt("MxConns", MxConns);
242    Lx.PutVarInt("MxSize", MxSize);
243    Lx.PutVarInt("LastWebPageId", LastWebPgId);
244    Lx.PutVarInt("UnconnWebPageIdToUrlStrQ",
245      ConnWebPgIdToUrlStrH.Len()+UnconnWebPgIdToUrlStrQ.Len());
246    {TIntStrH& H=ConnWebPgIdToUrlStrH;
247    int P=H.FFirstKeyId();
248    while (H.FNextKeyId(P)){
249      int WebPgId=H.GetKey(P); TStr UrlStr=H[P];
250      Lx.PutInt(WebPgId); Lx.PutQStr(UrlStr); Lx.PutLn();
251    }}
252    {TQQueue<TIntStrPr>& Q=UnconnWebPgIdToUrlStrQ;
253    for (int UnconnN=0; UnconnN<Q.Len(); UnconnN++){
254      int WebPgId=Q[UnconnN].Val1; TStr UrlStr=Q[UnconnN].Val2;
255      Lx.PutInt(WebPgId); Lx.PutQStr(UrlStr); Lx.PutLn();
256    }}
257  }
258  TXWebFetch::~TXWebFetch(){
259    THash<TInt, PSockEvent>& H=ConnWebPgIdToSockEventH;
260    int P=H.FFirstKeyId();
261    while (H.FNextKeyId(P)){
262      int WebPgId=H.GetKey(P);
263      PSockEvent SockEvent=H.GetDat(WebPgId);
264      H.GetDat(WebPgId)=NULL;
265    }
266  }
267  void TXWebFetch::ConnWebPg(const int& WebPgId, const TStr& UrlStr){
268    if (WebPgId!=-1){
269      UnconnWebPgIdToUrlStrQ.Push(TIntStrPr(WebPgId, UrlStr));}
270    while ((ConnWebPgIdToUrlStrH.Len()<MxConns)&&
271     (UnconnWebPgIdToUrlStrQ.Len()>0)){
272      int WebPgId=UnconnWebPgIdToUrlStrQ.Top().Val1;
273      TStr WebPgUrlStr=UnconnWebPgIdToUrlStrQ.Top().Val2;
274      UnconnWebPgIdToUrlStrQ.Pop();
275      if ((!ConnWebPgUrlStrToIdH.IsKey(WebPgUrlStr))&&
276       DoStillFetchUrl(WebPgUrlStr)){
277        ConnWebPgIdToUrlStrH.AddDat(WebPgId, WebPgUrlStr);
278        ConnWebPgUrlStrToIdH.AddDat(WebPgUrlStr, WebPgId);
279        PUrl WebPgUrl=new TUrl(WebPgUrlStr);
280        IAssert(WebPgUrl->IsOk());
281        if (IsCheckMode()&&IsWebPg(WebPgUrl->GetUrlStr())){
282          PReportEvent WebFetchReportEvent=
283           new TXWebFetchReportEvent(this, WebPgId, WebPgUrl);
284          WebFetchReportEvent->SendReport();
285        } else {
286          PSockEvent SockEvent=PSockEvent(new
287           TXWebFetchSockEvent(this, WebPgId, WebPgUrl, MxSize));
288          ConnWebPgIdToSockEventH.AddDat(WebPgId, SockEvent);
289          TSockHost::GetAsyncSockHost(WebPgUrl->GetHostNm(), SockEvent);
290        }
291      }
292    }
293  }
294  void TXWebFetch::UnconnWebPg(const int& WebPgId){
295    if (WebPgId!=-1){
296      TStr WebPgUrlStr=ConnWebPgIdToUrlStrH.GetDat(WebPgId);
297      ConnWebPgIdToUrlStrH.DelKey(WebPgId);
298      ConnWebPgUrlStrToIdH.DelKey(WebPgUrlStr);
299      if (!IsCheckMode()){
300        ConnWebPgIdToSockEventH.DelKey(WebPgId);}
301    }
302    ConnWebPg();
303  }
304  int TXWebFetch::FetchWebPg(const TStr& RelUrlStr, const TStr& BaseUrlStr){
305    int WebPgId=-1;
306    PUrl Url=new TUrl(RelUrlStr, BaseUrlStr);
307    if (Url->IsOk(usHttp)){
308      WebPgId=GetNextWebPgId();
309      ConnWebPg(WebPgId, Url->GetUrlStr());
310    } else {
311      TStr ErrStr=TStr("Invalid URL [")+RelUrlStr+"] + ["+BaseUrlStr+"]";
312      OnError(WebPgId, ErrStr);
313    }
314    return WebPgId;
315  }
316  class TXWebTravelBaseEvent: public TXWebBsEvent{
317  private:
318    TXWebTravel* WebTravel;
319  public:
320    TXWebTravelBaseEvent(TXWebTravel* _WebTravel): WebTravel(_WebTravel){}
321    ~TXWebTravelBaseEvent(){}
322    void OnWebPg(const int& WebPgId, const PXWebPg& WebPg, bool& DoSave){
323      WebTravel->OnWebPg(WebPgId, WebPg, DoSave);}
324    void OnNotify(const int& WebPgId, const TStr& MsgStr){
325      WebTravel->OnNotify(WebPgId, MsgStr);}
326    void OnError(const int& WebPgId, const TStr& ErrStr){
327      WebTravel->OnError(WebPgId, ErrStr);}
328    void OnStatus(const TStr& StatusStr){
329      WebTravel->OnStatus(StatusStr);}
330  };
331  const TStr TXWebBs::WebBsFNm="WebBs.Txt";
332  TXWebBs::TXWebBs(const TStr& _FPath, const bool& _CheckMode):
333    TXWebFetch(_FPath),
334    FPath(TStr::GetNrFPath(_FPath)),
335    CheckMode(_CheckMode), GenRef(){
336    PSIn SIn=new TFIn(FPath+WebBsFNm);
337    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum);
338    TStr OldFPath=Lx.GetVarStr("FPath");
339    GenRef=Lx.GetVarBool("GenRef");
340  }
341  void TXWebBs::SaveTxt(){
342    TXWebFetch::SaveTxt(FPath);
343    PSOut SOut=new TFOut(FPath+WebBsFNm);
344    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
345    Lx.PutVarStr("FPath", FPath);
346    Lx.PutVarBool("GenRef", GenRef);
347  }
348  TStr TXWebBs::GetStatusStr(){
349    static const TStr ActiveStr="Active:";
350    static const TStr QueueStr=" Queue:";
351    static const TStr PgsStr=" Pages:";
352    static const TStr CheckedStr=" Checked-Urls:";
353    if (IsCheckMode()){
354      return
355       ActiveStr+TInt::GetStr(GetConns())+
356       QueueStr+TInt::GetStr(GetUnconns())+
357       PgsStr+TInt::GetStr(GetWebPgs())+
358       CheckedStr+TInt::GetStr(GetCheckedUrls());
359    } else {
360      return
361       ActiveStr+TInt::GetStr(GetConns())+
362       QueueStr+TInt::GetStr(GetUnconns())+
363       PgsStr+TInt::GetStr(GetWebPgs());
364    }
365  }
366  void TXWebTravel::GenBadFExtH(){
367    AddBadFExt(".AIFF");
368    AddBadFExt(".AU");
369    AddBadFExt(".AVI");
370    AddBadFExt(".MP2");
371    AddBadFExt(".MP3");
372    AddBadFExt(".MPG");
373    AddBadFExt(".MPEG");
374    AddBadFExt(".RA");
375    AddBadFExt(".WAV");
376    AddBadFExt(".BMP");
377    AddBadFExt(".EPS");
378    AddBadFExt(".GIF");
379    AddBadFExt(".JPEG");
380    AddBadFExt(".JPG");
381    AddBadFExt(".TIF");
382    AddBadFExt(".TIFF");
383    AddBadFExt(".DVI");
384    AddBadFExt(".PS");
385    AddBadFExt(".PDF");
386    AddBadFExt(".ARJ");
387    AddBadFExt(".GZ");
388    AddBadFExt(".RAR");
389    AddBadFExt(".TAR");
390    AddBadFExt(".TGZ");
391    AddBadFExt(".UU");
392    AddBadFExt(".UUE");
393    AddBadFExt(".Z");
394    AddBadFExt(".ZIP");
395    AddBadFExt(".COM");
396    AddBadFExt(".EXE");
397    AddBadFExt(".H");
398    AddBadFExt(".C");
399    AddBadFExt(".CC");
400    AddBadFExt(".CPP");
401    AddBadFExt(".PAS");
402    AddBadFExt(".LGO");
403    AddBadFExt(".BAS");
404    AddBadFExt(".JAVA");
405    AddBadFExt(".CLASS");
406    AddBadFExt(".BIN"); 
407    AddBadFExt(".HQX"); 
408  }
409  void TXWebTravel::OnWebPg(const int&, const PXWebPg& WebPg, bool& DoSave){
410    TStr UrlStr=WebPg->GetUrlStr();
411    DoSave=(!WebBs->IsWebPg(UrlStr))&&(WebPg->IsText());
412    bool DoParse=(!SingleFetch)&&
413     (DoSave||!WebBs->IsWebPg(UrlStr, WebBs->IsCheckMode()));
414    OnBusy(WebPg, DoSave);
415    if (DoParse){
416      PSIn SIn=TStrIn::New(WebPg->GetBodyStr());
417      PHtmlDoc HtmlDoc=THtmlDoc::New(SIn, hdtHRef);
418      TStr BaseUrlStr=WebPg->GetLastUrlStr(); TStr RelUrlStr;
419      for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
420        if (IsUrlTok(HtmlDoc->GetTok(TokN), RelUrlStr)){
421          if (IsUrlOk(RelUrlStr, BaseUrlStr)){
422            WebBs->AddWebPg(RelUrlStr, BaseUrlStr);
423          }
424        }
425      }
426    }
427    OnFree();
428  }
429  TXWebTravel::TXWebTravel(const PXWebBs& _WebBs, const PXWebTravelEvent& _Event):
430    BadFExtH(50), SingleFetch(true), HostPathStrV(),
431    WebBsEvent(), WebBs(_WebBs), Event(_Event){
432    GenBadFExtH();
433    WebBsEvent=PXWebBsEvent(new TXWebTravelBaseEvent(this));
434    if (!WebBs.Empty()){WebBs->PutWebBsEvent(WebBsEvent);}
435  }
436  bool TXWebTravel::IsUrlTok(const PHtmlTok& Tok, TStr& RelUrlStr){
437    if (Tok->GetSym()==hsyBTag){
438      TStr TagNm=Tok->GetStr();
439      if ((TagNm==THtmlTok::ATagNm)&&(Tok->IsArg(THtmlTok::HRefArgNm))){
440        RelUrlStr=Tok->GetArg(THtmlTok::HRefArgNm); return true;}
441      else if ((TagNm==THtmlTok::AreaTagNm)&&(Tok->IsArg(THtmlTok::HRefArgNm))){
442        RelUrlStr=Tok->GetArg(THtmlTok::HRefArgNm); return true;}
443      else if ((TagNm==THtmlTok::FrameTagNm)&&(Tok->IsArg(THtmlTok::SrcArgNm))){
444        RelUrlStr=Tok->GetArg(THtmlTok::SrcArgNm); return true;
445      }
446    }
447    return false;
448  }
449  bool TXWebTravel::IsUrlOk(const TStr& RelUrlStr, const TStr& BaseUrlStr){
450    PUrl Url=new TUrl(RelUrlStr, BaseUrlStr);
451    if (!Url->IsOk(usHttp)){
452      OnNotify(TStr("Invalid URL [")+RelUrlStr+"] + ["+BaseUrlStr+"]");
453      return false;
454    }
455    TStr FExt=Url->GetPathStr().GetFExt().GetUc();
456    if (BadFExtH.IsKey(FExt)){return false;}
457    if (HostPathStrV.Len()==0){return true;}
458    for (int HostPathStrN=0; HostPathStrN<HostPathStrV.Len(); HostPathStrN++){
459      TStr HostStr=HostPathStrV[HostPathStrN].Val1;
460      TStr PathStr=HostPathStrV[HostPathStrN].Val2;
461      if ((Url->IsInHost(HostStr))&&(Url->IsInPath(PathStr))){return true;}
462    }
463    return false;
464  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-THash.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  int Prime(const int& n);
4  bool IsPrime(const int& d);
5  TEST(TIntIntH, DefaultConstructor) {
6    TIntIntH TableInt;
7    EXPECT_EQ(1,TableInt.Empty());
8    EXPECT_EQ(0,TableInt.Len());
9    EXPECT_EQ(0,TableInt.GetMxKeyIds());
10  }
11  TEST(TIntIntH, ManipulateTable) {
12    const int64 NElems = 1000000;
13    int DDist = 10;
14    const char *FName = "test.hashint.dat";
15    TIntIntH TableInt;
16    TIntIntH TableInt1;
17    TIntIntH TableInt2;
18    int i;
19    int d;
20    int n;
21    int Id;
22    int Key;
23    int64 KeySumVal;
24    int64 DatSumVal;
25    int64 KeySum;
26    int64 DatSum;
27    int64 KeySumDel;
28    int64 DatSumDel;
29    int DelCount;
30    int Count;
31    d = Prime(NElems);
32    n = d;
33    KeySumVal = 0;
34    DatSumVal = 0;
35    for (i = 0; i < NElems; i++) {
36      TableInt.AddDat(n,n+1);
37      KeySumVal += n;
38      DatSumVal += (n+1);
39      n = (n + d) % NElems;
40    }
41    EXPECT_EQ(0,TableInt.Empty());
42    EXPECT_EQ(NElems,TableInt.Len());
43    EXPECT_EQ(0,(NElems-1)*(NElems)/2 - KeySumVal);
44    EXPECT_EQ(0,(NElems)*(NElems+1)/2 - DatSumVal);
45    KeySum = 0;
46    DatSum = 0;
47    for (i = 0; i < NElems; i++) {
48      Id = TableInt.GetKeyId(i);
49      EXPECT_EQ(1,Id >= 0);
50      Key = TableInt.GetKey(Id);
51      EXPECT_EQ(0,TableInt.GetDat(Key)-Key-1);
52      KeySum += Key;
53      DatSum += TableInt.GetDat(Key);
54    }
55    EXPECT_EQ(0,KeySumVal - KeySum);
56    EXPECT_EQ(0,DatSumVal - DatSum);
57    KeySum = 0;
58    DatSum = 0;
59    n = Prime(d);
60    for (i = 0; i < NElems; i++) {
61      Id = TableInt.GetKeyId(n);
62      EXPECT_EQ(1,Id >= 0);
63      Key = TableInt.GetKey(Id);
64      EXPECT_EQ(0,TableInt.GetDat(Key)-Key-1);
65      KeySum += Key;
66      DatSum += TableInt.GetDat(Key);
67      n = (n + d) % NElems;
68    }
69    EXPECT_EQ(0,KeySumVal - KeySum);
70    EXPECT_EQ(0,DatSumVal - DatSum);
71    KeySum = 0;
72    DatSum = 0;
73    for (TIntIntH::TIter It = TableInt.BegI(); It < TableInt.EndI(); It++) {
74      EXPECT_EQ(0,It.GetDat()-It.GetKey()-1);
75      KeySum += It.GetKey();
76      DatSum += It.GetDat();
77    }
78    EXPECT_EQ(0,KeySumVal - KeySum);
79    EXPECT_EQ(0,DatSumVal - DatSum);
80    KeySum = 0;
81    DatSum = 0;
82    Id = TableInt.FFirstKeyId();
83    while (TableInt.FNextKeyId(Id)) {
84      EXPECT_EQ(1,Id >= 0);
85      Key = TableInt.GetKey(Id);
86      EXPECT_EQ(0,TableInt.GetDat(Key)-Key-1);
87      KeySum += Key;
88      DatSum += TableInt.GetDat(Key);
89    }
90    EXPECT_EQ(0,KeySumVal - KeySum);
91    EXPECT_EQ(0,DatSumVal - DatSum);
92    DelCount = 0;
93    KeySumDel = 0;
94    DatSumDel = 0;
95    for (n = 0; n < NElems; n += DDist) {
96      Id = TableInt.GetKeyId(n);
97      KeySumDel += n;
98      DatSumDel += TableInt[Id];
99      TableInt.DelKeyId(Id);
100      DelCount++;
101    }
102    EXPECT_EQ(0,TableInt.Empty());
103    EXPECT_EQ(NElems-DelCount,TableInt.Len());
104    KeySum = 0;
105    DatSum = 0;
106    Count = 0;
107    for (TIntIntH::TIter It = TableInt.BegI(); It < TableInt.EndI(); It++) {
108      EXPECT_EQ(0,It.GetDat()-It.GetKey()-1);
109      KeySum += It.GetKey();
110      DatSum += It.GetDat();
111      Count++;
112    }
113    EXPECT_EQ(NElems-DelCount,Count);
114    EXPECT_EQ(0,KeySumVal - KeySumDel - KeySum);
115    EXPECT_EQ(0,DatSumVal - DatSumDel - DatSum);
116    TableInt1 = TableInt;
117    EXPECT_EQ(0,TableInt1.Empty());
118    EXPECT_EQ(NElems-DelCount,TableInt1.Len());
119    KeySum = 0;
120    DatSum = 0;
121    Count = 0;
122    for (TIntIntH::TIter It = TableInt1.BegI(); It < TableInt1.EndI(); It++) {
123      EXPECT_EQ(0,It.GetDat()-It.GetKey()-1);
124      KeySum += It.GetKey();
125      DatSum += It.GetDat();
126      Count++;
127    }
128    EXPECT_EQ(NElems-DelCount,Count);
129    EXPECT_EQ(0,KeySumVal - KeySumDel - KeySum);
130    EXPECT_EQ(0,DatSumVal - DatSumDel - DatSum);
131    {
132      TFOut FOut(FName);
133      TableInt.Save(FOut);
134      FOut.Flush();
135    }
136    {
137      TFIn FIn(FName);
138      TableInt2.Load(FIn);
139    }
140    EXPECT_EQ(NElems-DelCount,TableInt2.Len());
141    KeySum = 0;
142    DatSum = 0;
143    Count = 0;
144    for (TIntIntH::TIter It = TableInt2.BegI(); It < TableInt2.EndI(); It++) {
145      EXPECT_EQ(0,It.GetDat()-It.GetKey()-1);
146      KeySum += It.GetKey();
147      DatSum += It.GetDat();
148      Count++;
149    }
150    EXPECT_EQ(NElems-DelCount,Count);
151    EXPECT_EQ(0,KeySumVal - KeySumDel - KeySum);
152    EXPECT_EQ(0,DatSumVal - DatSumDel - DatSum);
153    for (i = 0; i < Count; i++) {
154      Id = TableInt.GetRndKeyId(TInt::Rnd, 0.5);
155      TableInt.DelKeyId(Id);
156    }
157    EXPECT_EQ(0,TableInt.Len());
158    EXPECT_EQ(1,TableInt.Empty());
159    KeySum = 0;
160    DatSum = 0;
161    Count = 0;
162    for (TIntIntH::TIter It = TableInt.BegI(); It < TableInt.EndI(); It++) {
163      EXPECT_EQ(0,It.GetDat()-It.GetKey()-1);
164      KeySum += It.GetKey();
165      DatSum += It.GetDat();
166      Count++;
167    }
168    EXPECT_EQ(0,Count);
169    EXPECT_EQ(0,KeySum);
170    EXPECT_EQ(0,DatSum);
171    TableInt1.Clr();
172    EXPECT_EQ(0,TableInt1.Len());
173    EXPECT_EQ(1,TableInt1.Empty());
174    KeySum = 0;
175    DatSum = 0;
176    Count = 0;
177    for (TIntIntH::TIter It = TableInt1.BegI(); It < TableInt1.EndI(); It++) {
178      EXPECT_EQ(0,It.GetDat()-It.GetKey()-1);
179      KeySum += It.GetKey();
180      DatSum += It.GetDat();
181      Count++;
182    }
183    EXPECT_EQ(0,Count);
184    EXPECT_EQ(0,KeySum);
185    EXPECT_EQ(0,DatSum);
186  }
187  TEST(TStrIntH, DefaultConstructor) {
188    TStrIntH TableStr;
189    EXPECT_EQ(1,TableStr.Empty());
190    EXPECT_EQ(0,TableStr.Len());
191    EXPECT_EQ(0,TableStr.GetMxKeyIds());
192  }
193  TEST(TStrIntH, ManipulateTable) {
194    const int64 NElems = 1000000;
195    int DDist = 10;
196    const char *FName = "test.hashstr.dat";
197    TStrIntH TableStr;
198    TStrIntH TableStr1;
199    TStrIntH TableStr2;
200    int i;
201    int d;
202    int n;
203    int Id;
<span onclick='openModal()' class='match'>204    int Key;
205    TStr KeyStr;
206    int64 KeySumVal;
207    int64 DatSumVal;
208    int64 KeySum;
209    int64 DatSum;
</span>210    int64 KeySumDel;
211    int64 DatSumDel;
212    int DelCount;
213    int Count;
214    char s[32];
215    d = Prime(NElems);
216    n = d;
217    KeySumVal = 0;
218    DatSumVal = 0;
219    for (i = 0; i < NElems; i++) {
220      sprintf(s,"%d",n);
221      TStr Str = TStr(s);
222      TableStr.AddDat(Str,n+1);
223      KeySumVal += n;
224      DatSumVal += (n+1);
225      n = (n + d) % NElems;
226    }
227    EXPECT_EQ(0,TableStr.Empty());
228    EXPECT_EQ(NElems,TableStr.Len());
229    EXPECT_EQ(0,(NElems-1)*(NElems)/2 - KeySumVal);
230    EXPECT_EQ(0,(NElems)*(NElems+1)/2 - DatSumVal);
231    KeySum = 0;
232    DatSum = 0;
233    for (i = 0; i < NElems; i++) {
234      sprintf(s,"%d",i);
235      TStr Str = TStr(s);
236      Id = TableStr.GetKeyId(s);
237      EXPECT_EQ(1,Id >= 0);
238      KeyStr = TableStr.GetKey(Id);
239      Key = atoi(KeyStr.CStr());
240      EXPECT_EQ(0,TableStr.GetDat(KeyStr)-Key-1);
241      KeySum += Key;
242      DatSum += TableStr.GetDat(KeyStr);
243    }
244    EXPECT_EQ(0,KeySumVal - KeySum);
245    EXPECT_EQ(0,DatSumVal - DatSum);
246    KeySum = 0;
247    DatSum = 0;
248    n = Prime(d);
249    for (i = 0; i < NElems; i++) {
250      sprintf(s,"%d",i);
251      TStr Str = TStr(s);
252      Id = TableStr.GetKeyId(s);
253      EXPECT_EQ(1,Id >= 0);
254      KeyStr = TableStr.GetKey(Id);
255      Key = atoi(KeyStr.CStr());
256      EXPECT_EQ(0,TableStr.GetDat(KeyStr)-Key-1);
257      KeySum += Key;
258      DatSum += TableStr.GetDat(KeyStr);
259      n = (n + d) % NElems;
260    }
261    EXPECT_EQ(0,KeySumVal - KeySum);
262    EXPECT_EQ(0,DatSumVal - DatSum);
263    KeySum = 0;
264    DatSum = 0;
265    for (TStrIntH::TIter It = TableStr.BegI(); It < TableStr.EndI(); It++) {
266      KeyStr = It.GetKey();
267      Key = atoi(KeyStr.CStr());
268      EXPECT_EQ(0,It.GetDat()-Key-1);
269      KeySum += Key;
270      DatSum += It.GetDat();
271    }
272    EXPECT_EQ(0,KeySumVal - KeySum);
273    EXPECT_EQ(0,DatSumVal - DatSum);
274    KeySum = 0;
275    DatSum = 0;
276    Id = TableStr.FFirstKeyId();
277    while (TableStr.FNextKeyId(Id)) {
278      EXPECT_EQ(1,Id >= 0);
279      KeyStr = TableStr.GetKey(Id);
280      Key = atoi(KeyStr.CStr());
281      EXPECT_EQ(0,TableStr.GetDat(KeyStr)-Key-1);
282      KeySum += Key;
283      DatSum += TableStr.GetDat(KeyStr);
284    }
285    EXPECT_EQ(0,KeySumVal - KeySum);
286    EXPECT_EQ(0,DatSumVal - DatSum);
287    DelCount = 0;
288    KeySumDel = 0;
289    DatSumDel = 0;
290    for (n = 0; n < NElems; n += DDist) {
291      sprintf(s,"%d",n);
292      TStr Str = TStr(s);
293      Id = TableStr.GetKeyId(Str);
294      KeySumDel += n;
295      DatSumDel += TableStr[Id];
296      TableStr.DelKeyId(Id);
297      DelCount++;
298    }
299    EXPECT_EQ(0,TableStr.Empty());
300    EXPECT_EQ(NElems-DelCount,TableStr.Len());
301    KeySum = 0;
302    DatSum = 0;
303    Count = 0;
304    for (TStrIntH::TIter It = TableStr.BegI(); It < TableStr.EndI(); It++) {
305      KeyStr = It.GetKey();
306      Key = atoi(KeyStr.CStr());
307      EXPECT_EQ(0,It.GetDat()-Key-1);
308      KeySum += Key;
309      DatSum += It.GetDat();
310      Count++;
311    }
312    EXPECT_EQ(NElems-DelCount,Count);
313    EXPECT_EQ(0,KeySumVal - KeySumDel - KeySum);
314    EXPECT_EQ(0,DatSumVal - DatSumDel - DatSum);
315    TableStr1 = TableStr;
316    EXPECT_EQ(0,TableStr1.Empty());
317    EXPECT_EQ(NElems-DelCount,TableStr1.Len());
318    KeySum = 0;
319    DatSum = 0;
320    Count = 0;
321    for (TStrIntH::TIter It = TableStr1.BegI(); It < TableStr1.EndI(); It++) {
322      KeyStr = It.GetKey();
323      Key = atoi(KeyStr.CStr());
324      EXPECT_EQ(0,It.GetDat()-Key-1);
325      KeySum += Key;
326      DatSum += It.GetDat();
327      Count++;
328    }
329    EXPECT_EQ(NElems-DelCount,Count);
330    EXPECT_EQ(0,KeySumVal - KeySumDel - KeySum);
331    EXPECT_EQ(0,DatSumVal - DatSumDel - DatSum);
332    {
333      TFOut FOut(FName);
334      TableStr.Save(FOut);
335      FOut.Flush();
336    }
337    {
338      TFIn FIn(FName);
339      TableStr2.Load(FIn);
340    }
341    EXPECT_EQ(NElems-DelCount,TableStr2.Len());
342    KeySum = 0;
343    DatSum = 0;
344    Count = 0;
345    for (TStrIntH::TIter It = TableStr2.BegI(); It < TableStr2.EndI(); It++) {
346      KeyStr = It.GetKey();
347      Key = atoi(KeyStr.CStr());
348      EXPECT_EQ(0,It.GetDat()-Key-1);
349      KeySum += Key;
350      DatSum += It.GetDat();
351      Count++;
352    }
353    EXPECT_EQ(NElems-DelCount,Count);
354    EXPECT_EQ(0,KeySumVal - KeySumDel - KeySum);
355    EXPECT_EQ(0,DatSumVal - DatSumDel - DatSum);
356    for (i = 0; i < Count; i++) {
357      Id = TableStr.GetRndKeyId(TInt::Rnd, 0.5);
358      TableStr.DelKeyId(Id);
359    }
360    EXPECT_EQ(0,TableStr.Len());
361    EXPECT_EQ(1,TableStr.Empty());
362    KeySum = 0;
363    DatSum = 0;
364    Count = 0;
365    for (TStrIntH::TIter It = TableStr.BegI(); It < TableStr.EndI(); It++) {
366      KeyStr = It.GetKey();
367      Key = atoi(KeyStr.CStr());
368      EXPECT_EQ(0,It.GetDat()-Key-1);
369      KeySum += Key;
370      DatSum += It.GetDat();
371      Count++;
372    }
373    EXPECT_EQ(0,Count);
374    EXPECT_EQ(0,KeySum);
375    EXPECT_EQ(0,DatSum);
376    TableStr1.Clr();
377    EXPECT_EQ(0,TableStr1.Len());
378    EXPECT_EQ(1,TableStr1.Empty());
379    KeySum = 0;
380    DatSum = 0;
381    Count = 0;
382    for (TStrIntH::TIter It = TableStr1.BegI(); It < TableStr1.EndI(); It++) {
383      KeyStr = It.GetKey();
384      Key = atoi(KeyStr.CStr());
385      EXPECT_EQ(0,It.GetDat()-Key-1);
386      KeySum += Key;
387      DatSum += It.GetDat();
388      Count++;
389    }
390    EXPECT_EQ(0,Count);
391    EXPECT_EQ(0,KeySum);
392    EXPECT_EQ(0,DatSum);
393  }
394  int Prime(const int& n) {
395    int d;
396    d = (int) ((float) n * 0.61803398875);    
397    d |= 0x01;                                
398    while (!IsPrime(d)) {
399      d += 2;
400    }
401    return d;
402  }
403  bool IsPrime(const int& d) {
404    int i;
405    int j;
406    if (d < 4  ||  (d & 0x01) == 0) {
407      return true;
408    }
409    if (d < 4  ||  (d & 0x01) == 0) {
410      return true;
411    }
412    for (i = 2; i*i <= d; i++) {
413      j = d/i;
414      if (j*i == d) {
415        return false;
416      }
417    }
418    return true;
419  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webold.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-THash.cpp</div>
                </div>
                <div class="column column_space"><pre><code>55    int FetchTrys;
56    PSockHost SockHost;
57    PSock Sock;
58    TBool OppSockClosed;
59    TMOut SockMOut;
60  public:
</pre></code></div>
                <div class="column column_space"><pre><code>204    int Key;
205    TStr KeyStr;
206    int64 KeySumVal;
207    int64 DatSumVal;
208    int64 KeySum;
209    int64 DatSum;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    