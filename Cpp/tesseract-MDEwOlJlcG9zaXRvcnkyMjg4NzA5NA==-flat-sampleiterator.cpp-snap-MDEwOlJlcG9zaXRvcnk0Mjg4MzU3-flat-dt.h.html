
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.2318696602424002%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-sampleiterator.cpp</h3>
            <pre><code>1  #include "sampleiterator.h"
2  #include "intfeaturemap.h"
3  #include "indexmapbidi.h"
4  #include "shapetable.h"
5  #include "trainingsample.h"
6  #include "trainingsampleset.h"
7  namespace tesseract {
8  SampleIterator::SampleIterator()
9      : charset_map_(nullptr)
10      , shape_table_(nullptr)
11      , sample_set_(nullptr)
12      , randomize_(false)
13      , owned_shape_table_(nullptr) {
14    num_shapes_ = 0;
15    Begin();
16  }
17  SampleIterator::~SampleIterator() {
18    Clear();
19  }
20  void SampleIterator::Clear() {
21    delete owned_shape_table_;
22    owned_shape_table_ = nullptr;
23  }
24  void SampleIterator::Init(const IndexMapBiDi *charset_map, const ShapeTable *shape_table,
25                            bool randomize, TrainingSampleSet *sample_set) {
26    Clear();
27    charset_map_ = charset_map;
28    shape_table_ = shape_table;
29    sample_set_ = sample_set;
30    randomize_ = randomize;
31    if (shape_table_ == nullptr && charset_map_ != nullptr) {
32      int num_fonts = sample_set_->NumFonts();
33      owned_shape_table_ = new ShapeTable(sample_set_->unicharset());
34      int charsetsize = sample_set_->unicharset().size();
35      for (int c = 0; c < charsetsize; ++c) {
36        int shape_id = owned_shape_table_->AddShape(c, 0);
37        for (int f = 1; f < num_fonts; ++f) {
38          if (sample_set_->NumClassSamples(f, c, true) > 0) {
39            owned_shape_table_->AddToShape(shape_id, c, f);
40          }
41        }
42      }
43      shape_table_ = owned_shape_table_;
44    }
45    if (shape_table_ != nullptr) {
46      num_shapes_ = shape_table_->NumShapes();
47    } else {
48      num_shapes_ = randomize ? sample_set_->num_samples() : sample_set_->num_raw_samples();
49    }
50    Begin();
51  }
52  void SampleIterator::Begin() {
53    shape_index_ = -1;
54    shape_char_index_ = 0;
55    num_shape_chars_ = 0;
56    shape_font_index_ = 0;
57    num_shape_fonts_ = 0;
58    sample_index_ = 0;
59    num_samples_ = 0;
60    Next();
61  }
62  bool SampleIterator::AtEnd() const {
63    return shape_index_ >= num_shapes_;
64  }
65  const TrainingSample &SampleIterator::GetSample() const {
66    if (shape_table_ != nullptr) {
67      const UnicharAndFonts *shape_entry = GetShapeEntry();
68      int char_id = shape_entry->unichar_id;
69      int font_id = shape_entry->font_ids[shape_font_index_];
70      return *sample_set_->GetSample(font_id, char_id, sample_index_);
71    } else {
72      return *sample_set_->GetSample(shape_index_);
73    }
74  }
75  TrainingSample *SampleIterator::MutableSample() const {
76    if (shape_table_ != nullptr) {
77      const UnicharAndFonts *shape_entry = GetShapeEntry();
78      int char_id = shape_entry->unichar_id;
79      int font_id = shape_entry->font_ids[shape_font_index_];
80      return sample_set_->MutableSample(font_id, char_id, sample_index_);
81    } else {
82      return sample_set_->mutable_sample(shape_index_);
83    }
84  }
85  int SampleIterator::GlobalSampleIndex() const {
86    if (shape_table_ != nullptr) {
87      const UnicharAndFonts *shape_entry = GetShapeEntry();
88      int char_id = shape_entry->unichar_id;
89      int font_id = shape_entry->font_ids[shape_font_index_];
<span onclick='openModal()' class='match'>90      return sample_set_->GlobalSampleIndex(font_id, char_id, sample_index_);
91    } else {
92      return shape_index_;
93    }
94  }
95  int SampleIterator::GetCompactClassID() const {
96    return charset_map_ != nullptr ? charset_map_->SparseToCompact(shape_index_) : GetSparseClassID();
</span>97  }
98  int SampleIterator::GetSparseClassID() const {
99    return shape_table_ != nullptr ? shape_index_ : GetSample().class_id();
100  }
101  void SampleIterator::Next() {
102    if (shape_table_ != nullptr) {
103      ++sample_index_;
104      if (sample_index_ < num_samples_) {
105        return;
106      }
107      sample_index_ = 0;
108      do {
109        ++shape_font_index_;
110        if (shape_font_index_ >= num_shape_fonts_) {
111          shape_font_index_ = 0;
112          ++shape_char_index_;
113          if (shape_char_index_ >= num_shape_chars_) {
114            shape_char_index_ = 0;
115            do {
116              ++shape_index_;
117            } while (shape_index_ < num_shapes_ && charset_map_ != nullptr &&
118                     charset_map_->SparseToCompact(shape_index_) < 0);
119            if (shape_index_ >= num_shapes_) {
120              return; 
121            }
122            num_shape_chars_ = shape_table_->GetShape(shape_index_).size();
123          }
124        }
125        const UnicharAndFonts *shape_entry = GetShapeEntry();
126        num_shape_fonts_ = shape_entry->font_ids.size();
127        int char_id = shape_entry->unichar_id;
128        int font_id = shape_entry->font_ids[shape_font_index_];
129        num_samples_ = sample_set_->NumClassSamples(font_id, char_id, randomize_);
130      } while (num_samples_ == 0);
131    } else {
132      ++shape_index_;
133    }
134  }
135  int SampleIterator::CompactCharsetSize() const {
136    return charset_map_ != nullptr ? charset_map_->CompactSize() : SparseCharsetSize();
137  }
138  int SampleIterator::SparseCharsetSize() const {
139    return charset_map_ != nullptr
140               ? charset_map_->SparseSize()
141               : (shape_table_ != nullptr ? shape_table_->NumShapes() : sample_set_->charsetsize());
142  }
143  static void MapFeatures(TrainingSample &s, const IntFeatureMap &feature_map) {
144    std::vector<int> indexed_features;
145    feature_map.feature_space().IndexAndSortFeatures(s.features(), s.num_features(),
146                                                     &indexed_features);
147    feature_map.MapIndexedFeatures(indexed_features, &s.mapped_features_);
148    s.features_are_indexed_ = false;
149    s.features_are_mapped_ = true;
150  }
151  void SampleIterator::MapSampleFeatures(const IntFeatureMap &feature_map) {
152    for (Begin(); !AtEnd(); Next()) {
153      TrainingSample *sample = MutableSample();
154      MapFeatures(*sample, feature_map);
155    }
156  }
157  int SampleIterator::UniformSamples() {
158    int num_good_samples = 0;
159    for (Begin(); !AtEnd(); Next()) {
160      TrainingSample *sample = MutableSample();
161      sample->set_weight(1.0);
162      ++num_good_samples;
163    }
164    NormalizeSamples();
165    return num_good_samples;
166  }
167  double SampleIterator::NormalizeSamples() {
168    double total_weight = 0.0;
169    int sample_count = 0;
170    for (Begin(); !AtEnd(); Next()) {
171      const TrainingSample &sample = GetSample();
172      total_weight += sample.weight();
173      ++sample_count;
174    }
175    double min_assigned_sample_weight = 1.0;
176    if (total_weight > 0.0) {
177      for (Begin(); !AtEnd(); Next()) {
178        TrainingSample *sample = MutableSample();
179        double weight = sample->weight() / total_weight;
180        if (weight < min_assigned_sample_weight) {
181          min_assigned_sample_weight = weight;
182        }
183        sample->set_weight(weight);
184      }
185    }
186    return min_assigned_sample_weight;
187  }
188  const UnicharAndFonts *SampleIterator::GetShapeEntry() const {
189    const Shape &shape = shape_table_->GetShape(shape_index_);
190    return &shape[shape_char_index_];
191  }
192  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.h</h3>
            <pre><code>1  #include "bd.h"
2  class TILx;
3  class TOLx;
4  ClassHdTP(TXmlTok, PXmlTok);
5  class TRnd{
6  public:
7    static const int RndSeed;
8  private:
9    static const int a, m, q, r;
10    int Seed;
11    int GetNextSeed(){
12      if ((Seed=a*(Seed%q)-r*(Seed/q))>0){return Seed;} else {return Seed+=m;}}
13  public:
14    TRnd(const int& _Seed=1, const int& Steps=0){
15      PutSeed(_Seed); Move(Steps);}
16    explicit TRnd(TSIn& SIn){SIn.Load(Seed);}
17    void Save(TSOut& SOut) const {SOut.Save(Seed);}
18    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
19    void SaveXml(TSOut& SOut, const TStr& Nm) const;
20    TRnd& operator=(const TRnd& Rnd){Seed=Rnd.Seed; return *this;}
21    bool operator==(const TRnd&) const {Fail; return false;}
22    double GetUniDev(){return GetNextSeed()/double(m);}
23    int GetUniDevInt(const int& Range=0);
24    int GetUniDevInt(const int& MnVal, const int& MxVal){
25      IAssert(MnVal<=MxVal); return MnVal+GetUniDevInt(MxVal-MnVal+1);}
26    uint GetUniDevUInt(const uint& Range=0);
27    int64 GetUniDevInt64(const int64& Range=0);
28    uint64 GetUniDevUInt64(const uint64& Range=0);
29    double GetNrmDev();
30    double GetNrmDev(
31     const double& Mean, const double& SDev, const double& Mn, const double& Mx);
32    double GetExpDev();
33    double GetExpDev(const double& Lambda); 
34    double GetGammaDev(const int& Order);
35    double GetPoissonDev(const double& Mean);
36    double GetBinomialDev(const double& Prb, const int& Trials);
37    int GetGeoDev(const double& Prb){
38      return 1+(int)floor(log(1.0-GetUniDev())/log(1.0-Prb));}
39    double GetPowerDev(const double& AlphaSlope){ 
40      IAssert(AlphaSlope>1.0);
41      return pow(1.0-GetUniDev(), -1.0/(AlphaSlope-1.0));}
42    double GetRayleigh(const double& Sigma) { 
43      IAssert(Sigma>0.0);
44      return Sigma*sqrt(-2*log(1-GetUniDev()));}
45    double GetWeibull(const double& K, const double& Lambda) { 
46      IAssert(Lambda>0.0 && K>0.0);
47      return Lambda*pow(-log(1-GetUniDev()), 1.0/K);}
48    void PutSeed(const int& _Seed);
49    int GetSeed() const {return Seed;}
50    void Randomize(){PutSeed(RndSeed);}
51    void Move(const int& Steps);
52    bool Check();
53    static double GetUniDevStep(const int& Seed, const int& Steps){
54      TRnd Rnd(Seed); Rnd.Move(Steps); return Rnd.GetUniDev();}
55    static double GetNrmDevStep(const int& Seed, const int& Steps){
56      TRnd Rnd(Seed); Rnd.Move(Steps); return Rnd.GetNrmDev();}
57    static double GetExpDevStep(const int& Seed, const int& Steps){
58      TRnd Rnd(Seed); Rnd.Move(Steps); return Rnd.GetExpDev();}
59    static TRnd LoadTxt(TILx& Lx);
60    void SaveTxt(TOLx& Lx) const;
61  };
62  ClassTP(TMem, PMem)
63  private:
64    int MxBfL, BfL;
65    char* Bf;
66    void Resize(const int& _MxBfL);
67    bool DoFitLen(const int& LBfL) const {return BfL+LBfL<=MxBfL;}
68  public:
69    TMem(const int& _MxBfL=0):
70      MxBfL(_MxBfL), BfL(0), Bf(NULL){ IAssert(BfL>=0);
71      if (MxBfL>0){Bf=new char[MxBfL]; IAssert(Bf!=NULL);}}
72    static PMem New(const int& MxBfL=0){return new TMem(MxBfL);}
73    TMem(const void* _Bf, const int& _BfL):
74      MxBfL(_BfL), BfL(_BfL), Bf(NULL){ IAssert(BfL>=0);
75      if (BfL>0){Bf=new char[BfL]; IAssert(Bf!=NULL); memcpy(Bf, _Bf, BfL);}}
76    static PMem New(const void* Bf, const int& BfL){return new TMem(Bf, BfL);}
77    TMem(const TMem& Mem):
78      MxBfL(Mem.MxBfL), BfL(Mem.BfL), Bf(NULL){
79      if (MxBfL>0){Bf=new char[MxBfL]; memcpy(Bf, Mem.Bf, BfL);}}
80    static PMem New(const TMem& Mem){return new TMem(Mem);}
81    static PMem New(const PMem& Mem){return new TMem(*Mem);}
82    TMem(const TStr& Str);
83    static PMem New(const TStr& Str){return new TMem(Str);}
84    ~TMem(){if (Bf!=NULL){delete[] Bf;}}
85    explicit TMem(TSIn& SIn){
86      SIn.Load(MxBfL); SIn.Load(BfL);
87      Bf=new char[MxBfL=BfL]; SIn.LoadBf(Bf, BfL);}
88    void Save(TSOut& SOut) const {
89      SOut.Save(MxBfL); SOut.Save(BfL); SOut.SaveBf(Bf, BfL);}
90    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
91    void SaveXml(TSOut& SOut, const TStr& Nm) const;
92    TMem& operator=(const TMem& Mem){
93      if (this!=&Mem){
94        if (Bf!=NULL){delete[] Bf;}
95        MxBfL=Mem.MxBfL; BfL=Mem.BfL; Bf=NULL;
96        if (MxBfL>0){Bf=new char[MxBfL]; memcpy(Bf, Mem.Bf, BfL);}}
97      return *this;}
98    char* operator()() const {return Bf;}
99    TMem& operator+=(const char& Ch);
100    TMem& operator+=(const TMem& Mem);
101    TMem& operator+=(const TStr& Str);
102    TMem& operator+=(const PSIn& SIn);
103    char& operator[](const int& ChN) const {
104      Assert((0<=ChN)&&(ChN<BfL)); return Bf[ChN];}
105    int GetMemUsed() const {return int(2*sizeof(int)+sizeof(char*)+MxBfL);}
106    void Gen(const int& _BfL){
107      Clr(); Resize(_BfL); BfL=_BfL;}
108    void GenZeros(const int& _BfL){
109      Clr(false); Resize(_BfL); BfL=_BfL;
110      if (BfL > 0) memset(Bf, 0, BfL);}
111    void Reserve(const int& _MxBfL, const bool& DoClr = true){
112      if (DoClr){ Clr(); } Resize(_MxBfL);}
113    void Del(const int& BChN, const int& EChN);
114    void Clr(const bool& DoDel=true){
115      if (DoDel){if (Bf!=NULL){delete[] Bf;} MxBfL=0; BfL=0; Bf=NULL;}
116      else {BfL=0;}}
117    int Len() const {return BfL;}
118    bool Empty() const {return BfL==0;}
119    void Trunc(const int& _BfL){
120      if ((0<=_BfL)&&(_BfL<=BfL)){BfL=_BfL;}}
121    void Push(const char& Ch){operator+=(Ch);}
122    char Pop(){IAssert(BfL>0); BfL--; return Bf[BfL];}
123    bool DoFitStr(const TStr& Str) const;
124    void AddBf(const void* Bf, const int& BfL);
125    char* GetBf() const {return Bf;}
126    TStr GetAsStr(const char& NewNullCh='\0') const;
127    PSIn GetSIn() const {
128      TMOut MOut(BfL); MOut.SaveBf(Bf, BfL); return MOut.GetSIn();}
129    static void LoadMem(const PSIn& SIn, TMem& Mem){
130      Mem.Clr(); Mem.Gen(SIn->Len()); SIn->GetBf(Mem.Bf, SIn->Len());}
131    static void LoadMem(const PSIn& SIn, const PMem& Mem){
132      Mem->Clr(); Mem->Gen(SIn->Len()); SIn->GetBf(Mem->Bf, SIn->Len());}
133    void SaveMem(const PSOut& SOut) const {SOut->SaveBf(Bf, Len());}
134  };
135  class TMemIn: public TSIn{
136  private:
137    PMem Mem;
138    const char* Bf;
139    int BfC, BfL;
140  public:
141    TMemIn(const TMem& _Mem, const int& _BfC=0);
142    static PSIn New(const TMem& Mem){
143      return PSIn(new TMemIn(Mem));}
144    static PSIn New(const PMem& Mem){
145      TMemIn* MemIn=new TMemIn(*Mem); MemIn->Mem=Mem; return PSIn(MemIn);}
146    ~TMemIn(){}
147    bool Eof(){return BfC==BfL;}
148    int Len() const {return BfL-BfC;}
149    char GetCh(){Assert(BfC<BfL); return Bf[BfC++];}
150    char PeekCh(){Assert(BfC<BfL); return Bf[BfC];}
151    int GetBf(const void* LBf, const TSize& LBfL);
152    void Reset(){Cs=TCs(); BfC=0;}
153    bool GetNextLnBf(TChA& LnChA);
154  };
155  class TMemOut: public TSOut{
156  private:
157    PMem Mem;
158  private:
159    void FlushBf();
160  public:
161    TMemOut(const PMem& _Mem);
162    static PSOut New(const PMem& Mem){
163      return new TMemOut(Mem);}
164    ~TMemOut(){}
165    int PutCh(const char& Ch){
166      Mem->operator+=(Ch); return Ch;}
167    int PutBf(const void* LBf, const TSize& LBfL);
168    void Flush(){}
169  };
170  class TChA{
171  private:
172    int MxBfL, BfL;
173    char* Bf;
174    void Resize(const int& _MxBfL);
175  public:
176    explicit TChA(const int& _MxBfL=256){
177      Bf=new char[(MxBfL=_MxBfL)+1]; Bf[BfL=0]=0;}
178    TChA(const char* CStr){
179      Bf=new char[(MxBfL=BfL=int(strlen(CStr)))+1]; strcpy(Bf, CStr);}
180    TChA(const char* CStr, const int& StrLen) : MxBfL(StrLen), BfL(StrLen) {
181      Bf=new char[StrLen+1]; strncpy(Bf, CStr, StrLen); Bf[StrLen]=0;}
182    TChA(const TChA& ChA){
183      Bf=new char[(MxBfL=ChA.MxBfL)+1]; BfL=ChA.BfL; strcpy(Bf, ChA.CStr());}
184    TChA(const TStr& Str);
185    TChA(const TMem& Mem){
186      Bf=new char[(MxBfL=BfL=Mem.Len())+1]; Bf[MxBfL]=0;
187      memcpy(CStr(), Mem(), Mem.Len());}
188    ~TChA(){delete[] Bf;}
189    explicit TChA(TSIn& SIn){
190      SIn.Load(MxBfL); SIn.Load(BfL); SIn.Load(Bf, MxBfL, BfL);}
191    void Load(TSIn& SIn){ delete[] Bf;
192      SIn.Load(MxBfL); SIn.Load(BfL); SIn.Load(Bf, MxBfL, BfL);}
193    void Save(TSOut& SOut, const bool& SaveCompact=true) const { 
194      SOut.Save(SaveCompact?BfL:MxBfL); SOut.Save(BfL); SOut.Save(Bf, BfL);}
195    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
196    void SaveXml(TSOut& SOut, const TStr& Nm) const;
197    TChA& operator=(const TChA& ChA);
198    TChA& operator=(const TStr& Str);
199    TChA& operator=(const char* CStr);
200    bool operator==(const TChA& ChA) const {return strcmp(CStr(), ChA.CStr())==0;}
201    bool operator==(const char* _CStr) const {return strcmp(CStr(), _CStr)==0;}
202    bool operator==(const char& Ch) const {return (BfL==1)&&(Bf[0]==Ch);}
203    bool operator!=(const TChA& ChA) const {return strcmp(CStr(), ChA.CStr())!=0;}
204    bool operator!=(const char* _CStr) const {return strcmp(CStr(), _CStr)!=0;}
205    bool operator!=(const char& Ch) const {return !((BfL==1)&&(Bf[0]==Ch));}
206    bool operator<(const TChA& ChA) const {return strcmp(CStr(), ChA.CStr())<0;}
207    TChA& operator+=(const TMem& Mem);
208    TChA& operator+=(const TChA& ChA);
209    TChA& operator+=(const TStr& Str);
210    TChA& operator+=(const char* CStr);
211    TChA& operator+=(const char& Ch){
212      if (BfL==MxBfL){Resize(BfL+1);}
213      Bf[BfL]=Ch; BfL++; Bf[BfL]=0; return *this;}
214    char operator[](const int& ChN) const {
215      Assert((0<=ChN)&&(ChN<BfL)); return Bf[ChN];}
216    char& operator[](const int& ChN){
217      Assert((0<=ChN)&&(ChN<BfL)); return Bf[ChN];}
218    int GetMemUsed() const {return int(2*sizeof(int)+sizeof(char*)+sizeof(char)*MxBfL);}
219    char* operator ()(){return Bf;}
220    const char* operator ()() const {return Bf;}
221    char* CStr() {return Bf;}
222    const char* CStr() const {return Bf;}
223    void Clr(){Bf[BfL=0]=0;}
224    int Len() const {return BfL;}
225    bool Empty() const {return BfL==0;}
226    void Ins(const int& BChN, const char* CStr);
227    void Del(const int& ChN);
228    void DelLastCh(){Pop();}
229    void Push(const char& Ch){operator+=(Ch);}
230    char Pop(){IAssert(BfL>0); BfL--; char Ch=Bf[BfL]; Bf[BfL]=0; return Ch;}
231    void Trunc();
232    void Trunc(const int& _BfL){
233      if ((0<=_BfL)&&(_BfL<=BfL)){Bf[BfL=_BfL]=0;}}
234    void Reverse();
235    void AddCh(const char& Ch, const int& MxLen=-1){
236      if ((MxLen==-1)||(BfL<MxLen)){operator+=(Ch);}}
237    void AddChTo(const char& Ch, const int& ToChN){
238      while (Len()<ToChN){AddCh(Ch);}}
239    void AddBf(char *NewBf, const int& BfS){
240      if ((BfL+BfS+1)>MxBfL){Resize(BfL+BfS+1);}
241      strncpy(Bf+BfL,NewBf,BfS); BfL+=BfS; Bf[BfL]=0;}
242    void PutCh(const int& ChN, const char& Ch){
243      Assert((0<=ChN)&&(ChN<BfL)); Bf[ChN]=Ch;}
244    char GetCh(const int& ChN) const {return operator[](ChN);}
245    char LastCh() const { Assert(1<=BfL); return Bf[BfL-1]; }
246    char LastLastCh() const { Assert(2<=BfL); return Bf[BfL-2]; }
247    TChA GetSubStr(const int& BChN, const int& EChN) const;
248    int CountCh(const char& Ch, const int& BChN=0) const;
249    int SearchCh(const char& Ch, const int& BChN=0) const;
250    int SearchChBack(const char& Ch, int BChN=-1) const;
251    int SearchStr(const TChA& Str, const int& BChN=0) const;
252    int SearchStr(const TStr& Str, const int& BChN=0) const;
253    int SearchStr(const char* CStr, const int& BChN=0) const;
254    bool IsStrIn(const TStr& Str) const {return SearchStr(Str)!=-1;}
255    bool IsPrefix(const char* CStr, const int& BChN=0) const;
256    bool IsPrefix(const TStr& Str) const;
257    bool IsPrefix(const TChA& Str) const;
258    bool IsSuffix(const char* CStr) const;
259    bool IsSuffix(const TStr& Str) const;
260    bool IsSuffix(const TChA& Str) const;
261    bool IsChIn(const char& Ch) const {return SearchCh(Ch)!=-1;}
262    void ChangeCh(const char& SrcCh, const char& DstCh);
263    TChA& ToUc();
264    TChA& ToLc();
265    TChA& ToTrunc();
266    void CompressWs();
267    void Swap(const int& ChN1, const int& ChN2);
268    void Swap(TChA& ChA);
269    int GetPrimHashCd() const;
270    int GetSecHashCd() const;
271    static void LoadTxt(const PSIn& SIn, TChA& ChA);
272    void SaveTxt(const PSOut& SOut) const;
273  };
274  class TChAIn: public TSIn{
275  private:
276    const char* Bf;
277    int BfC, BfL;
278  private:
279    TChAIn();
280    TChAIn(const TChAIn&);
281    TChAIn& operator=(const TChAIn&);
282  public:
283    TChAIn(const TChA& ChA, const int& _BfC=0);
284    static PSIn New(const TChA& ChA){return PSIn(new TChAIn(ChA));}
285    ~TChAIn(){}
286    bool Eof(){return BfC==BfL;}
287    int Len() const {return BfL-BfC;}
288    char GetCh(){Assert(BfC<BfL); return Bf[BfC++];}
289    char PeekCh(){Assert(BfC<BfL); return Bf[BfC];}
290    int GetBf(const void* LBf, const TSize& LBfL);
291    void Reset(){Cs=TCs(); BfC=0;}
292    bool GetNextLnBf(TChA& LnChA);
293  };
294  class TRStr{
295  public:
296    char* Bf;
297    int Refs;
298  public:
299    TRStr(){Refs=1; Bf=new char[0+1]; Bf[0]=0;}
300    TRStr(const int& Len){
301      IAssert(Len>=0); Refs=0; Bf=new char[Len+1]; Bf[Len]=0;}
302    TRStr(const char* CStr){
303      Refs=0; Bf=new char[strlen(CStr)+1]; strcpy(Bf, CStr);}
304    TRStr(const char* CStr, const int& MxLen){
305      Refs=0; Bf=new char[MxLen+1]; strncpy(Bf, CStr, MxLen); Bf[MxLen]=0;}
306    TRStr(const char* CStr1, const char* CStr2){
307      Refs=0; int CStr1Len=int(strlen(CStr1)); Bf=new char[CStr1Len+int(strlen(CStr2))+1];
308      strcpy(Bf, CStr1); strcpy(Bf+CStr1Len, CStr2);}
309    TRStr(const char& Ch){
310      Refs=0; Bf=new char[1+1]; Bf[0]=Ch; Bf[1]=0;}
311    TRStr(const char& Ch1, const char& Ch2){
312      Refs=0; Bf=new char[2+1]; Bf[0]=Ch1; Bf[1]=Ch2; Bf[2]=0;}
313    ~TRStr(){
314      Assert(((this!=GetNullRStr())&&(Refs==0))||((this==GetNullRStr())&&(Refs==1)));
315      delete[] Bf;}
316    explicit TRStr(TSIn& SIn, const bool& IsSmall){
317      if (IsSmall){Refs=0; SIn.Load(Bf);}
318      else {Refs=0; int BfL; SIn.Load(BfL); SIn.Load(Bf, BfL, BfL);}}
319    void Save(TSOut& SOut, const bool& IsSmall) const {
320      if (IsSmall){SOut.Save(Bf);}
321      else {int BfL=int(strlen(Bf)); SOut.Save(BfL); SOut.Save(Bf, BfL);}}
322    TRStr& operator=(const TRStr&){Fail; return *this;}
323    int GetMemUsed() const {return int(sizeof(int))+int(strlen(Bf));}
324    void MkRef(){Refs++;}
325    void UnRef(){Assert(Refs>0); if (--Refs==0){delete this;}}
326    const char* CStr() const {return Bf;}
327    char* CStr() {return Bf;}
328    bool Empty() const {return Bf[0]==0;}
329    int Len() const {return int(strlen(Bf));}
330    void PutCh(const int& ChN, const char& Ch){
331      Assert((0<=ChN)&&(ChN<Len())); Bf[ChN]=Ch;}
332    char GetCh(const int& ChN) const {
333      Assert((0<=ChN)&&(ChN<Len())); return Bf[ChN];}
334    bool IsUc() const;
335    void ToUc();
336    bool IsLc() const;
337    void ToLc();
338    void ToCap();
339    void ConvUsFromYuAscii();
340    static int CmpI(const char* CStr1, const char* CStr2);
341    int GetPrimHashCd() const;
342    int GetSecHashCd() const;
343    static TRStr* GetNullRStr(){
344      static TRStr NullRStr; Assert(NullRStr.Bf!=NULL); return &NullRStr;}
345  };
346  class TStr;
347  template <class TVal, class TSizeTy> class TVec;
348  typedef TVec<TStr, int> TStrV;
349  class TStr{
350  private:
351    TRStr* RStr;
352  private:
353    TStr(const char& Ch, bool){
354      RStr=new TRStr(Ch); RStr->MkRef();}
355    TStr(const char& Ch1, const char& Ch2, bool){
356      RStr=new TRStr(Ch1, Ch2); RStr->MkRef();}
357    static TRStr* GetRStr(const char* CStr);
358    void Optimize();
359  public:
360    TStr(){RStr=TRStr::GetNullRStr(); RStr->MkRef();}
361    TStr(const TStr& Str){RStr=Str.RStr; RStr->MkRef();}
362    TStr(const TChA& ChA){RStr=GetRStr(ChA.CStr()); RStr->MkRef();}
363    TStr(const TSStr& SStr){RStr=GetRStr(SStr.CStr()); RStr->MkRef();}
364    TStr(const char* CStr){RStr=GetRStr(CStr); RStr->MkRef();}
365    explicit TStr(const char& Ch){RStr=GetChStr(Ch).RStr; RStr->MkRef();}
366    TStr(const TMem& Mem){
367      RStr=new TRStr(Mem.Len()); RStr->MkRef();
368      memcpy(CStr(), Mem(), Mem.Len()); Optimize();}
369    explicit TStr(const PSIn& SIn){
370      int SInLen=SIn->Len(); RStr=new TRStr(SInLen); RStr->MkRef();
371      SIn->GetBf(CStr(), SInLen); Optimize();}
372    ~TStr(){RStr->UnRef();}
373    explicit TStr(TSIn& SIn, const bool& IsSmall=false):
374      RStr(new TRStr(SIn, IsSmall)){RStr->MkRef(); Optimize();}
375    void Load(TSIn& SIn, const bool& IsSmall=false){
376      *this=TStr(SIn, IsSmall);}
377    void Save(TSOut& SOut, const bool& IsSmall=false) const {
378      RStr->Save(SOut, IsSmall);}
379    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
380    void SaveXml(TSOut& SOut, const TStr& Nm) const;
381    TStr& operator=(const TStr& Str){
382      if (this!=&Str){RStr->UnRef(); RStr=Str.RStr; RStr->MkRef();} return *this;}
383    TStr& operator=(const TChA& ChA){
384      RStr->UnRef(); RStr=GetRStr(ChA.CStr()); RStr->MkRef(); return *this;}
385    TStr& operator=(const char* CStr){
386      RStr->UnRef(); RStr=GetRStr(CStr); RStr->MkRef(); return *this;}
387    TStr& operator=(const char& Ch){
388      RStr->UnRef(); RStr=GetChStr(Ch).RStr; RStr->MkRef(); return *this;}
389    TStr& operator+=(const TStr& Str){
390      TRStr* NewRStr=new TRStr(RStr->CStr(), Str.RStr->CStr());
391      RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
392      Optimize(); return *this;}
393    TStr& operator+=(const char* CStr){
394      TRStr* NewRStr=new TRStr(RStr->CStr(), CStr);
395      RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
396      Optimize(); return *this;}
397    TStr& operator/(const int& N){
398      return *this;}
399    bool operator==(const TStr& Str) const {
400      return (RStr==Str.RStr)||(strcmp(RStr->CStr(), Str.RStr->CStr())==0);}
401    bool operator==(const char* CStr) const {
402      return strcmp(RStr->CStr(), CStr)==0;}
403    bool operator!=(const char* CStr) const {
404      return strcmp(RStr->CStr(), CStr)!=0;}
405    bool operator<(const TStr& Str) const {
406      return strcmp(RStr->CStr(), Str.RStr->CStr())<0;}
407    char operator[](const int& ChN) const {return RStr->GetCh(ChN);}
408    int GetMemUsed() const {return int(sizeof(TRStr*)+RStr->GetMemUsed());}
409    char* operator()(){return RStr->CStr();}
410    const char* operator()() const {return RStr->CStr();}
411    char* CStr() {return RStr->CStr();}
412    const char* CStr() const {return RStr->CStr();}
413    void PutCh(const int& ChN, const char& Ch){
414      TRStr* NewRStr=new TRStr(RStr->CStr());
415      RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
416      RStr->PutCh(ChN, Ch); Optimize();}
417    char GetCh(const int& ChN) const {return RStr->GetCh(ChN);}
418    char LastCh() const {return GetCh(Len()-1);}
419    void Clr(){RStr->UnRef(); RStr=TRStr::GetNullRStr(); RStr->MkRef();}
420    int Len() const {return RStr->Len();}
421    bool Empty() const {return RStr->Empty();}
422    bool IsUc() const {return RStr->IsUc();}
423    TStr& ToUc();
424    TStr GetUc() const {return TStr(*this).ToUc();}
425    int CmpI(const TStr& Str) const {return TRStr::CmpI(CStr(), Str.CStr());}
426    bool EqI(const TStr& Str) const {return TRStr::CmpI(CStr(), Str.CStr())==0;}
427    bool IsLc() const {return RStr->IsLc();}
428    TStr& ToLc();
429    TStr GetLc() const {return TStr(*this).ToLc();}
430    TStr& ToCap();
431    TStr GetCap() const {return TStr(*this).ToCap();}
432    TStr& ToTrunc();
433    TStr GetTrunc() const {return TStr(*this).ToTrunc();}
434    TStr& ConvUsFromYuAscii();
435    TStr GetUsFromYuAscii() const {return TStr(*this).ConvUsFromYuAscii();}
436    TStr& ToHex();
437    TStr GetHex() const {return TStr(*this).ToHex();}
438    TStr& FromHex();
439    TStr GetFromHex() const {return TStr(*this).FromHex();}
440    TStr GetSubStr(const int& BChN, const int& EChN) const;
441    TStr GetSubStr(const int& BChN) const { return GetSubStr(BChN, Len()-1); }
442    void InsStr(const int& BChN, const TStr& Str);
443    void DelChAll(const char& Ch);
444    void DelSubStr(const int& BChN, const int& EChN);
445    bool DelStr(const TStr& Str);
446    TStr LeftOf(const char& SplitCh) const;
447    TStr LeftOfLast(const char& SplitCh) const;
448    TStr RightOf(const char& SplitCh) const;
449    TStr RightOfLast(const char& SplitCh) const;
450    void SplitOnCh(TStr& LStr, const char& SplitCh, TStr& RStr) const;
451    void SplitOnLastCh(TStr& LStr, const char& SplitCh, TStr& RStr) const;
452    void SplitOnAllCh(
453     const char& SplitCh, TStrV& StrV, const bool& SkipEmpty=true) const;
454    void SplitOnAllAnyCh(
455     const TStr& SplitChStr, TStrV& StrV, const bool& SkipEmpty=true) const;
456    void SplitOnWs(TStrV& StrV) const;
457    void SplitOnNonAlNum(TStrV& StrV) const;
458    void SplitOnStr(const TStr& SplitStr, TStrV& StrV) const;
459    void SplitOnStr(TStr& LeftStr, const TStr& MidStr, TStr& RightStr) const;
460    TStr Mid(const int& BChN, const int& Chs) const { return GetSubStr(BChN, BChN+Chs-1); }
461    TStr Mid(const int& BChN) const {return GetSubStr(BChN, Len()-1); }
462    TStr Left(const int& EChN) const { return EChN>0 ? GetSubStr(0, EChN-1) : GetSubStr(0, Len()+EChN-1);}
463    TStr Right(const int& BChN) const {return BChN>=0 ? GetSubStr(BChN, Len()-1) : GetSubStr(Len()+BChN, Len()-1);}
464    TStr Slice(int BChN, int EChNP1) const { if(BChN<0){BChN=Len()+BChN;} if(EChNP1<=0){EChNP1=Len()+EChNP1;} return GetSubStr(BChN, EChNP1-1); }
465    TStr operator()(const int& BChN, const int& EChNP1) const {return Slice(BChN, EChNP1);}
466    int CountCh(const char& Ch, const int& BChN=0) const;
467    int SearchCh(const char& Ch, const int& BChN=0) const;
468    int SearchChBack(const char& Ch, int BChN=-1) const;
469    int SearchStr(const TStr& Str, const int& BChN=0) const;
470    bool IsChIn(const char& Ch) const {return SearchCh(Ch)!=-1;}
471    bool IsStrIn(const TStr& Str) const {return SearchStr(Str)!=-1;}
472    bool IsPrefix(const char *Str) const;
473    bool IsPrefix(const TStr& Str) const {
474      return IsPrefix(Str.CStr());}
475    bool IsSuffix(const char *Str) const;
476    bool IsSuffix(const TStr& Str) const {
477      return IsSuffix(Str.CStr());}
478    int ChangeCh(const char& SrcCh, const char& DstCh, const int& BChN=0);
479    int ChangeChAll(const char& SrcCh, const char& DstCh);
480    int ChangeStr(const TStr& SrcStr, const TStr& DstStr, const int& BChN=0);
481    int ChangeStrAll(const TStr& SrcStr, const TStr& DstStr, const bool& FromStartP=false);
482    TStr Reverse() const {
483      TChA ChA(*this); ChA.Reverse(); return ChA;}
484    int GetPrimHashCd() const {return RStr->GetPrimHashCd();}
485    int GetSecHashCd() const {return RStr->GetSecHashCd();}
486    bool IsBool(bool& Val) const;
487    bool IsInt(
488     const bool& Check, const int& MnVal, const int& MxVal, int& Val) const;
489    bool IsInt(int& Val) const {return IsInt(false, 0, 0, Val);}
490    bool IsInt() const {int Val; return IsInt(false, 0, 0, Val);}
491    int GetInt() const {int Val; IAssertR(IsInt(false, 0, 0, Val), *this); return Val;}
492    int GetInt(const int& DfVal) const {
493      int Val; if (IsInt(false, 0, 0, Val)){return Val;} else {return DfVal;}}
494    bool IsUInt(
495     const bool& Check, const uint& MnVal, const uint& MxVal, uint& Val) const;
496    bool IsUInt(uint& Val) const {return IsUInt(false, 0, 0, Val);}
497    bool IsUInt() const {uint Val; return IsUInt(false, 0, 0, Val);}
498    uint GetUInt() const {uint Val; IAssert(IsUInt(false, 0, 0, Val)); return Val;}
499    uint GetUInt(const uint& DfVal) const {
500      uint Val; if (IsUInt(false, 0, 0, Val)){return Val;} else {return DfVal;}}
501    bool IsInt64(
502     const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const;
503    bool IsInt64(int64& Val) const {return IsInt64(false, 0, 0, Val);}
504    bool IsInt64() const {int64 Val; return IsInt64(false, 0, 0, Val);}
505    int64 GetInt64() const {
506      int64 Val; IAssert(IsInt64(false, 0, 0, Val)); return Val;}
507    int64 GetInt64(const int64& DfVal) const {
508      int64 Val; if (IsInt64(false, 0, 0, Val)){return Val;} else {return DfVal;}}
509    bool IsUInt64(
510     const bool& Check, const uint64& MnVal, const uint64& MxVal, uint64& Val) const;
511    bool IsUInt64(uint64& Val) const {return IsUInt64(false, 0, 0, Val);}
512    bool IsUInt64() const {uint64 Val; return IsUInt64(false, 0, 0, Val);}
513    uint64 GetUInt64() const {
514      uint64 Val; IAssert(IsUInt64(false, 0, 0, Val)); return Val;}
515    uint64 GetUInt64(const uint64& DfVal) const {
516      uint64 Val; if (IsUInt64(false, 0, 0, Val)){return Val;} else {return DfVal;}}
517    bool IsHexInt(const bool& Check, const int& MnVal, const int& MxVal, int& Val) const;
518    bool IsHexInt(int& Val) const {return IsHexInt(false, 0, 0, Val);}
519    bool IsHexInt() const {int Val; return IsHexInt(false, 0, 0, Val);}
520    int GetHexInt() const {
521      int Val; IAssert(IsHexInt(false, 0, 0, Val)); return Val;}
522    int GetHexInt(const int& DfVal) const {
523      int Val; if (IsHexInt(false, 0, 0, Val)){return Val;} else {return DfVal;}}
524    bool IsHexInt64(const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const;
525    bool IsHexInt64(int64& Val) const {return IsHexInt64(false, 0, 0, Val);}
526    bool IsHexInt64() const {int64 Val; return IsHexInt64(false, 0, 0, Val);}
527    int64 GetHexInt64() const {
528      int64 Val; IAssert(IsHexInt64(false, 0, 0, Val)); return Val;}
529    int64 GetHexInt64(const int64& DfVal) const {
530      int64 Val; if (IsHexInt64(false, 0, 0, Val)){return Val;} else {return DfVal;}}
531    bool IsFlt(const bool& Check, const double& MnVal, const double& MxVal,
532     double& Val, const char& DecDelimCh='.') const;
533    bool IsFlt(double& Val) const {return IsFlt(false, 0, 0, Val);}
534    bool IsFlt() const {double Val; return IsFlt(false, 0, 0, Val);}
535    double GetFlt() const {
536      double Val; IAssert(IsFlt(false, 0, 0, Val)); return Val;}
537    double GetFlt(const double& DfVal) const {
538      double Val; if (IsFlt(false, 0, 0, Val)){return Val;} else {return DfVal;}}
539    bool IsWord(const bool& WsPrefixP=true, const bool& FirstUcAllowedP=true) const;
540    bool IsWs() const;
541    bool IsWcMatch(
542     const int& StrBChN, const TStr& WcStr, const int& WcStrBChN, TStrV& StarStrV,
543     const char& StarCh='*', const char& QuestCh='?') const;
544    bool IsWcMatch(
545     const TStr& WcStr, TStrV& StarStrV,
546     const char& StarCh='*', const char& QuestCh='?') const;
547    bool IsWcMatch(const TStr& WcStr, const char& StarCh, const char& QuestCh) const;
548    bool IsWcMatch(const TStr& WcStr, const int& StarStrN, TStr& StarStr) const;
549    bool IsWcMatch(const TStr& WcStr) const;
550    TStr GetWcMatch(const TStr& WcStr, const int& StarStrN=0) const;
551    TStr GetFPath() const;
552    TStr GetFBase() const;
553    TStr GetFMid() const;
554    TStr GetFExt() const;
555    static TStr GetNrFPath(const TStr& FPath);
556    static TStr GetNrFMid(const TStr& FMid);
557    static TStr GetNrFExt(const TStr& FExt);
558    static TStr GetNrNumFExt(const int& FExtN);
559    static TStr GetNrFNm(const TStr& FNm);
560    static TStr GetNrAbsFPath(const TStr& FPath, const TStr& BaseFPath=TStr());
561    static bool IsAbsFPath(const TStr& FPath);
562    static TStr PutFExt(const TStr& FNm, const TStr& FExt);
563    static TStr PutFExtIfEmpty(const TStr& FNm, const TStr& FExt);
564    static TStr PutFBase(const TStr& FNm, const TStr& FBase);
565    static TStr PutFBaseIfEmpty(const TStr& FNm, const TStr& FBase);
566    static TStr AddToFMid(const TStr& FNm, const TStr& ExtFMid);
567    static TStr GetNumFNm(const TStr& FNm, const int& Num);
568    static TStr GetFNmStr(const TStr& Str, const bool& AlNumOnlyP=true);
569    static TStr LoadTxt(const PSIn& SIn){
570      return TStr(SIn);}
571    static TStr LoadTxt(const TStr& FNm){
572      PSIn SIn=TFIn::New(FNm); return LoadTxt(SIn);}
573    void SaveTxt(const PSOut& SOut) const {
574      SOut->SaveBf(CStr(), Len());}
575    void SaveTxt(const TStr& FNm) const {
576      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
577    static TStr& GetChStr(const char& Ch);
578    static TStr& GetDChStr(const char& Ch1, const char& Ch2);
579    TStr GetStr() const {return *this;}
580    static TStr GetStr(const TStr& Str, const char* FmtStr);
581    static TStr GetStr(const TStr& Str, const TStr& FmtStr){
582      return GetStr(Str, FmtStr.CStr());}
583    static TStr GetStr(const TStrV& StrV, const TStr& DelimiterStr);
584    static TStr Fmt(const char *FmtStr, ...);
585    static TStr GetSpaceStr(const int& Spaces);
586    char* GetCStr() const {
587      char* Bf=new char[Len()+1]; strcpy(Bf, CStr()); return Bf;}
588    static TStr MkClone(const TStr& Str){return TStr(Str.CStr());}
589    static TStr GetNullStr();
590    friend TStr operator+(const TStr& LStr, const TStr& RStr);
591    friend TStr operator+(const TStr& LStr, const char* RCStr);
592  };
593  class TStrIn: public TSIn{
594  private:
595    TStr Str;
596    char* Bf;
597    int BfC, BfL;
598  private:
599    TStrIn();
600    TStrIn(const TStrIn&);
601    TStrIn& operator = (const TStrIn&);
602  public:
603    TStrIn(const TStr& _Str);
604    static PSIn New(const TStr& Str){return PSIn(new TStrIn(Str));}
605    ~TStrIn(){}
606    bool Eof(){return BfC==BfL;}
607    int Len() const {return BfL-BfC;}
608    char GetCh(){Assert(BfC<BfL); return Bf[BfC++];}
609    char PeekCh(){Assert(BfC<BfL); return Bf[BfC];}
610    int GetBf(const void* LBf, const TSize& LBfL);
611    void Reset(){Cs=TCs(); BfC=0;}
612    bool GetNextLnBf(TChA& LnChA);
613  };
614  class TDbStr{
615  public:
616    TStr Str1;
617    TStr Str2;
618  public:
619    TDbStr(): Str1(), Str2(){}
620    TDbStr(const TDbStr& DbStr): Str1(DbStr.Str1), Str2(DbStr.Str2){}
621    TDbStr(const TStr& _Str1): Str1(_Str1), Str2(){}
622    TDbStr(const TStr& _Str1, const TStr& _Str2): Str1(_Str1), Str2(_Str2){}
623    explicit TDbStr(TSIn& SIn): Str1(SIn), Str2(SIn){}
624    void Save(TSOut& SOut) const {Str1.Save(SOut); Str2.Save(SOut);}
625    TDbStr& operator=(const TDbStr& DbStr){
626      if (this!=&DbStr){Str1=DbStr.Str1; Str2=DbStr.Str2;} return *this;}
627    bool operator==(const TDbStr& DbStr) const {
628      return (Str1==DbStr.Str1)&&(Str2==DbStr.Str2);}
629    bool operator<(const TDbStr& DbStr) const {
630      return (Str1<DbStr.Str1)||((Str1==DbStr.Str1)&&(Str2<DbStr.Str2));}
631    TStr GetStr(const TStr& MidStr=TStr()) const {
<span onclick='openModal()' class='match'>632      if (Filled()){return Str1+MidStr+Str2;} else {return Str1+Str2;}}
633    int GetPrimHashCd() const {
634      return Str1.GetPrimHashCd()+Str2.GetPrimHashCd();}
</span>635    int GetSecHashCd() const {
636      return Str1.GetSecHashCd()+Str2.GetSecHashCd();}
637    bool Empty() const {return (Str1.Empty())&&(Str2.Empty());}
638    bool Filled() const {return (!Str2.Empty())&&(!Str1.Empty());}
639  };
640  ClassTP(TStrPool, PStrPool)
641  private:
642    uint MxBfL, BfL, GrowBy;
643    char *Bf;
644  private:
645    void Resize(const uint& _MxBfL);
646  public:
647    TStrPool(const uint& MxBfLen = 0, const uint& _GrowBy = 16*1024*1024);
648    TStrPool(TSIn& SIn, bool LoadCompact = true);
649    TStrPool(const TStrPool& Pool) : MxBfL(Pool.MxBfL), BfL(Pool.BfL), GrowBy(Pool.GrowBy) {
650      Bf = (char *) malloc(Pool.MxBfL); IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); memcpy(Bf, Pool.Bf, Pool.BfL); }
651    ~TStrPool() { if (Bf) free(Bf); else IAssertR(MxBfL == 0, TStr::Fmt("size: %u, expected size: 0", MxBfL).CStr());  Bf = 0; MxBfL = 0; BfL = 0; }
652    static PStrPool New(const uint& _MxBfLen = 0, const uint& _GrowBy = 16*1024*1024) { return PStrPool(new TStrPool(_MxBfLen, _GrowBy)); }
653    static PStrPool New(TSIn& SIn) { return new TStrPool(SIn); }
654    static PStrPool New(const TStr& fileName) { PSIn SIn = TFIn::New(fileName); return new TStrPool(*SIn); }
655    static PStrPool Load(TSIn& SIn, bool LoadCompacted = true) { return PStrPool(new TStrPool(SIn, LoadCompacted)); }
656    void Save(TSOut& SOut) const;
657    void Save(const TStr& FNm){PSOut SOut=TFOut::New(FNm); Save(*SOut);}
658    uint Len() const { return BfL; }
659    uint Size() const { return MxBfL; }
660    bool Empty() const { return ! Len(); }
661    char* operator () () const { return Bf; }
662    TStrPool& operator = (const TStrPool& Pool);
663    ::TSize GetMemUsed(){ return 4 * sizeof(int) + MxBfL;}
664    uint AddStr(const char *Str, const uint& Len);
665    uint AddStr(const char *Str) { return AddStr(Str, uint(strlen(Str)) + 1); }
666    uint AddStr(const TStr& Str) { return AddStr(Str.CStr(), Str.Len() + 1); }
667    TStr GetStr(const uint& Offset) const { Assert(Offset < BfL);
668      if (Offset == 0) return TStr::GetNullStr(); else return TStr(Bf + Offset); }
669    const char *GetCStr(const uint& Offset) const { Assert(Offset < BfL);
670      if (Offset == 0) return TStr::GetNullStr().CStr(); else return Bf + Offset; }
671    void Clr(bool DoDel = false) { BfL = 0; if (DoDel && Bf) { free(Bf); Bf = 0; MxBfL = 0; } }
672    int Cmp(const uint& Offset, const char *Str) const { Assert(Offset < BfL);
673      if (Offset != 0) return strcmp(Bf + Offset, Str); else return strcmp("", Str); }
674    static int GetPrimHashCd(const char *CStr);
675    static int GetSecHashCd(const char *CStr);
676    int GetPrimHashCd(const uint& Offset) { Assert(Offset < BfL);
677      if (Offset != 0) return GetPrimHashCd(Bf + Offset); else return GetPrimHashCd(""); }
678    int GetSecHashCd(const uint& Offset) { Assert(Offset < BfL);
679      if (Offset != 0) return GetSecHashCd(Bf + Offset); else return GetSecHashCd(""); }
680    static PStrPool LoadShM(TSIn& SIn){ return new TStrPool(SIn); }
681  };
682  ClassTP(TStrPool64, PStrPool64)
683  private:
684    ::TSize MxBfL, BfL, GrowBy;
685    char *Bf;
686  private:
687    void Resize(const ::TSize& _MxBfL);
688  public:
689    TStrPool64(::TSize _MxBfL = 0, ::TSize _GrowBy = 16*1024*1024);
690    TStrPool64(const TStrPool64& StrPool);
691    TStrPool64(TSIn& SIn, bool LoadCompact = true);
692    ~TStrPool64() { Clr(true); }
693    void Save(TSOut& SOut) const;
694    static PStrPool64 New(::TSize MxBfL = 0, ::TSize GrowBy = 16*1024*1024) { 
695        return PStrPool64(new TStrPool64(MxBfL, GrowBy)); }
696    static PStrPool64 Load(TSIn& SIn, bool LoadCompact = true) { 
697        return PStrPool64(new TStrPool64(SIn, LoadCompact)); }
698    TStrPool64& operator=(const TStrPool64& StrPool);
699    uint64 GetMemUsed() const { return 3*sizeof(::TSize) + uint64(MxBfL); }
700    bool Empty() const { return (BfL == 0); }
701    uint64 Len() const {return BfL;}
702    uint64 Reserved() const { return MxBfL; }
703    void Clr(bool DoDel = false);
704    int Cmp(uint64 Offset, const char *Str) const { Assert(Offset < BfL);
705      if (Offset != 0) return strcmp(Bf + Offset, Str); else return strcmp("", Str); }
706    uint64 AddStr(const TStr& Str);
707    TStr GetStr(const uint64& StrId) const;
708  };
709  template <class Base> class TNum{
710  public:
711    Base Val;
712    TNum() : Val(0){}
713    TNum(const Base& _Val) : Val(_Val){}
714    operator Base() const { return Val; }
715    explicit TNum(TSIn& SIn){ SIn.Load(Val); }
716    void Load(TSIn& SIn){ SIn.Load(Val); }
717    void Save(TSOut& SOut) const { SOut.Save(Val); }
718    TNum& operator=(const TNum& Other){ Val = Other.Val; return *this; }
719    TNum& operator=(const Base& _Val){ Val = _Val; return *this; }
720    TNum& operator++(){ ++Val; return *this; } 
721    TNum& operator--(){ --Val; return *this; } 
722    TNum operator++(int){ TNum oldVal = Val; Val++; return oldVal; } 
723    TNum operator--(int){ TNum oldVal = Val; Val--; return oldVal; } 
724    Base& operator()() { return Val; }
725    int GetMemUsed() const { return sizeof(TNum); }
726  };
727  typedef TNum<int64> TInt64;
728  template<>
729  class TNum<int64>{
730  public:
731    int64 Val;
732  public:
733    static const int64 Mn;
734    static const int64 Mx;
735    TNum() : Val(0){}
736    TNum(const TNum& Int) : Val(Int.Val){}
737    TNum(const int64& Int) : Val(Int){}
738    operator int64() const { return Val; }
739    explicit TNum(TSIn& SIn){ SIn.Load(Val); }
740    void Load(TSIn& SIn){ SIn.Load(Val); }
741    void Save(TSOut& SOut) const { SOut.Save(Val); }
742    TNum& operator=(const TNum& Int){ Val = Int.Val; return *this; }
743    TNum& operator+=(const TNum& Int){ Val += Int.Val; return *this; }
744    TNum& operator-=(const TNum& Int){ Val -= Int.Val; return *this; }
745    TNum& operator++(){ ++Val; return *this; } 
746    TNum& operator--(){ --Val; return *this; } 
747    TNum operator++(int){ TNum oldVal = Val; Val++; return oldVal; } 
748    TNum operator--(int){ TNum oldVal = Val; Val--; return oldVal; } 
749    int GetMemUsed() const { return sizeof(TNum); }
750  #ifdef GLib_WIN
751    TStr GetStr() const { return TStr::Fmt("%I64", Val); }
752    static TStr GetStr(const TNum& Int){ return TStr::Fmt("%I64", Int.Val); }
753    static TStr GetHexStr(const TNum& Int){ return TStr::Fmt("%I64X", Int.Val); }
754  #else
755    TStr GetStr() const { return TStr::Fmt("%ll", Val); }
756    static TStr GetStr(const TNum& Int){ return TStr::Fmt("%ll", Int.Val); }
757    static TStr GetHexStr(const TNum& Int){ return TStr::Fmt("%ll", Int.Val); }
758  #endif
759    static TStr GetKiloStr(const int64& Val){
760      if (Val>100 * 1000){ return GetStr(Val / 1000) + "K"; }
761      else if (Val>1000){ return GetStr(Val / 1000) + "." + GetStr((Val % 1000) / 100) + "K"; }
762      else { return GetStr(Val); }
763    }
764    static TStr GetMegaStr(const int64& Val){
765      if (Val>100 * 1000000){ return GetStr(Val / 1000000) + "M"; }
766      else if (Val>1000000){
767        return GetStr(Val / 1000000) + "." + GetStr((Val % 1000000) / 100000) + "M";
768      }
769      else { return GetKiloStr(Val); }
770    }
771    static int64 GetFromBufSafe(const char * Bf) {
772  #ifdef ARM
773      int64 Val;
774      memcpy(&Val, Bf, sizeof(int64)); 
775      return Val;
776  #else
777      return *((int64*)Bf);
778  #endif
779    }
780  };
781  class TVoid{
782  public:
783    TVoid(){}
784    TVoid(TSIn&){}
785    void Save(TSOut&) const {}
786    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
787    void SaveXml(TSOut& SOut, const TStr& Nm) const;
788    TVoid& operator=(const TVoid&){return *this;}
789    bool operator==(const TVoid&) const {return true;}
790    bool operator<(const TVoid&) const {Fail; return false;}
791    int GetMemUsed() const {return sizeof(TVoid);}
792  };
793  class TBool{
794  public:
795    bool Val;
796  public:
797    static const bool Mn;
798    static const bool Mx;
799    static const int Vals;
800    static TRnd Rnd;
801    static const TStr FalseStr;
802    static const TStr TrueStr;
803    static const TStr NStr;
804    static const TStr YStr;
805    static const TStr NoStr;
806    static const TStr YesStr;
807    TBool(): Val(false){}
808    TBool(const bool& _Val): Val(_Val){}
809    operator bool() const {return Val;}
810    explicit TBool(TSIn& SIn){SIn.Load(Val);}
811    void Load(TSIn& SIn){SIn.Load(Val);}
812    void Save(TSOut& SOut) const {SOut.Save(Val);}
813    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
814    void SaveXml(TSOut& SOut, const TStr& Nm) const;
815    TBool& operator=(const TBool& Bool){Val=Bool.Val; return *this;}
816    bool operator==(const TBool& Bool) const {return Val==Bool.Val;}
817    bool operator<(const TBool& Bool) const {
818      return (Val==false)&&(Bool.Val==true);}
819    bool operator()() const {return Val;}
820    int GetMemUsed() const {return sizeof(TBool);}
821    int GetPrimHashCd() const {return Val;}
822    int GetSecHashCd() const {return Val;}
823    static bool GetRnd(){return Rnd.GetUniDevInt(2)==1;}
824    static TStr GetStr(const bool& Val){
825      if (Val){return TrueStr;} else {return FalseStr;}}
826    static TStr GetStr(const TBool& Bool){
827      return GetStr(Bool.Val);}
828    static TStr GetYNStr(const bool& Val){
829      if (Val){return YStr;} else {return NStr;}}
830    static TStr GetYesNoStr(const bool& Val){
831      if (Val){return YesStr;} else {return NoStr;}}
832    static TStr Get01Str(const bool& Val){
833      if (Val){return "1";} else {return "0";}}
834    static bool IsValStr(const TStr& Str);
835    static bool GetValFromStr(const TStr& Str);
836    static bool GetValFromStr(const TStr& Str, const bool& DfVal);
837  };
838  class TCh{
839  public:
840    char Val;
841  public:
842    static const char Mn;
843    static const char Mx;
844    static const int Vals;
845    static const char NullCh;
846    static const char TabCh;
847    static const char LfCh;
848    static const char CrCh;
849    static const char EofCh;
850    static const char HashCh;
851    TCh(): Val(TCh::NullCh){}
852    TCh(const char& _Val): Val(_Val){}
853    operator char() const {return Val;}
854    explicit TCh(TSIn& SIn){SIn.Load(Val);}
855    void Load(TSIn& SIn) {SIn.Load(Val);}
856    void Save(TSOut& SOut) const {SOut.Save(Val);}
857    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
858    void SaveXml(TSOut& SOut, const TStr& Nm) const;
859    TCh& operator=(const TCh& Ch){Val=Ch.Val; return *this;}
860    bool operator==(const TCh& Ch) const {return Val==Ch.Val;}
861    bool operator<(const TCh& Ch) const {return Val<Ch.Val;}
862    char operator()() const {return Val;}
863    int GetMemUsed() const {return sizeof(TCh);}
864    int GetPrimHashCd() const {return Val;}
865    int GetSecHashCd() const {return Val;}
866    static bool IsHashCh(const char& Ch){
867      return (Ch==HashCh);}
868    static bool IsWs(const char& Ch){
869      return (Ch==' ')||(Ch==TabCh)||(Ch==CrCh)||(Ch==LfCh);}
870    static bool IsAlpha(const char& Ch){
871      return (('A'<=Ch)&&(Ch<='Z'))||(('a'<=Ch)&&(Ch<='z'));}
872    static bool IsNum(const char& Ch){return ('0'<=Ch)&&(Ch<='9');}
873    static bool IsAlNum(const char& Ch){return IsAlpha(Ch)||IsNum(Ch);}
874    static int GetNum(const char& Ch){Assert(IsNum(Ch)); return Ch-'0';}
875    static bool IsHex(const char& Ch){return
876      (('0'<=Ch)&&(Ch<='9'))||(('A'<=Ch)&&(Ch<='F'))||(('a'<=Ch)&&(Ch<='f'));}
877    static int GetHex(const char& Ch){
878      if (('0'<=Ch)&&(Ch<='9')){return Ch-'0';}
879      else if (('A'<=Ch)&&(Ch<='F')){return Ch-'A'+10;}
880      else if (('a'<=Ch)&&(Ch<='f')){return Ch-'a'+10;}
881      else Fail; return 0;}
882    static char GetHexCh(const int& Val){
883      if ((0<=Val)&&(Val<=9)){return char('0'+char(Val));}
884      else if ((10<=Val)&&(Val<=15)){return char('A'+char(Val-10));}
885      else Fail; return 0;}
886    static char IsUc(const char& Ch){
887      return ('A'<=Ch)&&(Ch<='Z');}
888    static char GetUc(const char& Ch){
889      if (('a'<=Ch)&&(Ch<='z')){return Ch-'a'+'A';} else {return Ch;}}
890    static char GetUsFromYuAscii(const char& Ch);
891    static TStr GetStr(const TCh& Ch){
892      return TStr(Ch.Val);}
893  };
894  class TUCh{
895  public:
896    uchar Val;
897  public:
898    static const uchar Mn;
899    static const uchar Mx;
900    static const int Vals;
901    TUCh(): Val(TCh::NullCh){}
902    TUCh(const uchar& _Val): Val(_Val){}
903    operator uchar() const {return Val;}
904    explicit TUCh(TSIn& SIn){SIn.Load(Val);}
905    void Save(TSOut& SOut) const {SOut.Save(Val);}
906    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
907    void SaveXml(TSOut& SOut, const TStr& Nm) const;
908    TUCh& operator=(const TUCh& UCh){Val=UCh.Val; return *this;}
909    bool operator==(const TUCh& UCh) const {return Val==UCh.Val;}
910    bool operator<(const TUCh& UCh) const {return Val<UCh.Val;}
911    uchar operator()() const {return Val;}
912    int GetMemUsed() const {return sizeof(TUCh);}
913    int GetPrimHashCd() const {return Val;}
914    int GetSecHashCd() const {return Val;}
915  };
916  class TSInt{
917  public:
918    int16 Val;
919  public:
920    TSInt(): Val(0){}
921    TSInt(const int16& _Val): Val(_Val){}
922    operator int16() const {return Val;}
923    explicit TSInt(TSIn& SIn){SIn.Load(Val);}
924    void Load(TSIn& SIn){SIn.Load(Val);}
925    void Save(TSOut& SOut) const {SOut.Save(Val);}
926    int GetPrimHashCd() const {return Val;}
927    int GetSecHashCd() const {return Val/0x10;}
928  };
929  class TInt{
930  public:
931    int Val;
932  public:
933    static const int Mn;
934    static const int Mx;
935    static const int Kilo;
936    static const int Mega;
937    static const int Giga;
938    static TRnd Rnd;
939    TInt(): Val(0){}
940    TInt(const int& _Val): Val(_Val){}
941    operator int() const {return Val;}
942    explicit TInt(TSIn& SIn){SIn.Load(Val);}
943    void Load(TSIn& SIn){SIn.Load(Val);}
944    void Save(TSOut& SOut) const {SOut.Save(Val);}
945    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
946    void SaveXml(TSOut& SOut, const TStr& Nm) const;
947    TInt& operator=(const TInt& Int){Val=Int.Val; return *this;}
948    TInt& operator=(const int& Int){Val=Int; return *this;}
949    bool operator==(const TInt& Int) const {return Val==Int.Val;}
950    bool operator==(const int& Int) const {return Val==Int;}
951    bool operator!=(const int& Int) const {return Val!=Int;}
952    bool operator<(const TInt& Int) const {return Val<Int.Val;}
953    bool operator<(const int& Int) const {return Val<Int;}
954    int operator()() const {return Val;}
955    TInt& operator+=(const int& Int){Val+=Int; return *this;}
956    TInt& operator-=(const int& Int){Val-=Int; return *this;}
957    TInt operator++(int){Val++; return *this;}
958    TInt operator--(int){Val--; return *this;}
959    int GetMemUsed() const {return sizeof(TInt);}
960    int GetPrimHashCd() const {return Val;}
961    int GetSecHashCd() const {return Val/0x10;}
962    static int Abs(const int& Int){return Int<0?-Int:Int;}
963    static int Sign(const int& Int){return Int<0?-1:(Int>0?1:0);}
964    static void Swap(int& Int1, int& Int2){
965      int SwapInt1=Int1; Int1=Int2; Int2=SwapInt1;}
966    static int GetRnd(const int& Range=0){return Rnd.GetUniDevInt(Range);}
967    static bool IsOdd(const int& Int){return ((Int%2)==1);}
968    static bool IsEven(const int& Int){return ((Int%2)==0);}
969    static int GetMn(const int& Int1, const int& Int2){
970      return Int1<Int2?Int1:Int2;}
971    static int GetMx(const int& Int1, const int& Int2){
972      return Int1>Int2?Int1:Int2;}
973    static int GetMn(const int& Int1, const int& Int2, const int& Int3){
974      return GetMn(Int1, GetMn(Int2, Int3));}
975    static int GetMn(const int& Int1, const int& Int2,
976     const int& Int3, const int& Int4){
977      return GetMn(GetMn(Int1, Int2), GetMn(Int3, Int4));}
978    static int GetMx(const int& Int1, const int& Int2, const int& Int3){
979      return GetMx(Int1, GetMx(Int2, Int3));}
980    static int GetMx(const int& Int1, const int& Int2,
981     const int& Int3, const int& Int4){
982      return GetMx(GetMx(Int1, Int2), GetMx(Int3, Int4));}
983    static int GetInRng(const int& Val, const int& Mn, const int& Mx){
984      IAssert(Mn<=Mx); return Val<Mn?Mn:(Val>Mx?Mx:Val);}
985    TStr GetStr() const {return TInt::GetStr(Val);}
986    static TStr GetStr(const int& Val){ return TStr::Fmt("%d", Val); }
987    static TStr GetStr(const TInt& Int){ return GetStr(Int.Val);}
988    static TStr GetStr(const int& Val, const char* FmtStr);
989    static TStr GetStr(const int& Val, const TStr& FmtStr){ return GetStr(Val, FmtStr.CStr());}
990    static TStr GetStr(const uint& Val){ return TStr::Fmt("%u", Val); }
991    #ifdef GLib_WIN
992    static TStr GetStr(const int64& Val) {return TStr::Fmt("%I64d", Val);}
993    static TStr GetStr(const uint64& Val) {return TStr::Fmt("%I64u", Val);}
994    #else
995    static TStr GetStr(const int64& Val) {return TStr::Fmt("%lld", Val);}
996    static TStr GetStr(const uint64& Val) {return TStr::Fmt("%llu", Val);}
997    #endif
998    static TStr GetHexStr(const int& Val){
999      char Bf[255]; sprintf(Bf, "%X", Val); return TStr(Bf);}
1000    static TStr GetHexStr(const TInt& Int){
1001      return GetHexStr(Int.Val);}
1002    static TStr GetKiloStr(const int& Val){
1003      if (Val>=100*1000){return GetStr(Val/1000)+"K";}
1004      else if (Val>=1000){return GetStr(Val/1000)+"."+GetStr((Val%1000)/100)+"K";}
1005      else {return GetStr(Val);}}
1006    static TStr GetMegaStr(const int& Val){
1007      if (Val>=100*1000000){return GetStr(Val/1000000)+"M";}
1008      else if (Val>=1000000){
1009        return GetStr(Val/1000000)+"."+GetStr((Val%1000000)/100000)+"M";}
1010      else {return GetKiloStr(Val);}}
1011    static char* SaveFrugalInt(char *pDest, int i);
1012    static char* LoadFrugalInt(char *pSrc, int& i);
1013    static void TestFrugalInt();
1014    static void SaveFrugalIntV(TSOut& SOut, const TVec<TInt, int>& IntV);
1015    static void LoadFrugalIntV(TSIn& SIn, TVec<TInt, int>& IntV, bool ClrP=true);
1016  };
1017  class TUInt{
1018  public:
1019    uint Val;
1020  public:
1021    static const uint Mn;
1022    static const uint Mx;
1023    static TRnd Rnd;
1024    TUInt(): Val(0){}
1025    TUInt(const uint& _Val): Val(_Val){}
1026    operator uint() const {return Val;}
1027    explicit TUInt(TSIn& SIn){SIn.Load(Val);}
1028    void Load(TSIn& SIn){SIn.Load(Val);}
1029    void Save(TSOut& SOut) const {SOut.Save(Val);}
1030    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
1031    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1032    TUInt& operator=(const TUInt& UInt){Val=UInt.Val; return *this;}
1033    TUInt& operator=(const uint& _Val){Val=_Val; return *this;}
1034    TUInt operator++(int){Val++; return *this;}
1035    TUInt operator--(int){Val--; return *this;}
1036    uint operator()() const {return Val;}
1037    uint& operator()() {return Val;}
1038    TUInt& operator~(){Val=~Val; return *this;}
1039    TUInt& operator&=(const TUInt& UInt){Val&=UInt.Val; return *this;}
1040    TUInt& operator|=(const TUInt& UInt){Val|=UInt.Val; return *this;}
1041    TUInt& operator^=(const TUInt& UInt){Val^=UInt.Val; return *this;}
1042    TUInt& operator>>=(const int& ShiftBits){Val>>=ShiftBits; return *this;}
1043    TUInt& operator<<=(const int& ShiftBits){Val<<=ShiftBits; return *this;}
1044    int GetMemUsed() const {return sizeof(TUInt);}
1045    int GetPrimHashCd() const {return int(Val);}
1046    int GetSecHashCd() const {return Val/0x10;}
1047    static uint GetRnd(const uint& Range=0){return Rnd.GetUniDevUInt(Range);}
1048    TStr GetStr() const {return TUInt::GetStr(Val);}
1049    static TStr GetStr(const uint& Val){
1050      char Bf[255]; sprintf(Bf, "%u", Val); return TStr(Bf);}
1051    static TStr GetStr(const TUInt& UInt){
1052      return GetStr(UInt.Val);}
1053    static TStr GetStr(const uint& Val, const char* FmtStr);
1054    static TStr GetStr(const uint& Val, const TStr& FmtStr){
1055      return GetStr(Val, FmtStr.CStr());}
1056    static TStr GetKiloStr(const uint& Val){
1057      if (Val>100*1000){return GetStr(Val/1000)+"K";}
1058      else if (Val>1000){return GetStr(Val/1000)+"."+GetStr((Val%1000)/100)+"K";}
1059      else {return GetStr(Val);}}
1060    static TStr GetMegaStr(const uint& Val){
1061      if (Val>100*1000000){return GetStr(Val/1000000)+"M";}
1062      else if (Val>1000000){
1063        return GetStr(Val/1000000)+"."+GetStr((Val%1000000)/100000)+"M";}
1064      else {return GetKiloStr(Val);}}
1065    static uint JavaUIntToCppUInt(const uint& JavaUInt){
1066      uint B1=(JavaUInt & 0xFF000000) >> 24;
1067      uint B2=(JavaUInt & 0x00FF0000) >> 16;
1068      uint B3=(JavaUInt & 0x0000FF00) >> 8;
1069      uint B4=(JavaUInt & 0x000000FF) >> 0;
1070      uint CppUInt=(B4<<24)+(B3<<16)+(B2<<8)+(B1<<0);
1071      return CppUInt;}
1072    static bool IsIpStr(const TStr& IpStr, uint& Ip, const char& SplitCh = '.');
1073    static bool IsIpStr(const TStr& IpStr, const char& SplitCh = '.') { uint Ip; return IsIpStr(IpStr, Ip, SplitCh); }
1074    static uint GetUIntFromIpStr(const TStr& IpStr, const char& SplitCh = '.');
1075    static TStr GetStrFromIpUInt(const uint& Ip);
1076    static bool IsIpv6Str(const TStr& IpStr, const char& SplitCh = ':');
1077  };
1078  class TUInt64{
1079  public:
1080    uint64 Val;
1081  public:
1082    static const TUInt64 Mn;
1083    static const TUInt64 Mx;
1084    TUInt64(): Val(0){}
1085    TUInt64(const TUInt64& Int): Val(Int.Val){}
1086    TUInt64(const uint64& Int): Val(Int){}
1087    TUInt64(const uint& MsVal, const uint& LsVal): Val(0){
1088      Val=(((uint64)MsVal) << 32) | ((uint64)LsVal);}
1089    explicit TUInt64(void* Pt): Val(0){
1090       TConv_Pt64Ints32 Conv(Pt); Val=Conv.GetUInt64();}
1091    operator uint64() const {return Val;}
1092    explicit TUInt64(TSIn& SIn){SIn.Load(Val);}
1093    void Load(TSIn& SIn){SIn.Load(Val);}
1094    void Save(TSOut& SOut) const {SOut.Save(Val);}
1095    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
1096    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1097    TUInt64& operator=(const TUInt64& Int){Val=Int.Val; return *this;}
1098    TUInt64& operator+=(const TUInt64& Int){Val+=Int.Val; return *this;}
1099    TUInt64& operator-=(const TUInt64& Int){Val-=Int.Val; return *this;}
1100    TUInt64& operator*=(const TUInt64& Int){Val*=Int.Val; return *this;}
1101    TUInt64 operator++(int){Val++; return *this;}
1102    TUInt64 operator--(int){Val--; return *this;}
1103    int GetMemUsed() const {return sizeof(TUInt64);}
1104    int GetPrimHashCd() const { return (int)GetMsVal() + (int)GetLsVal(); } 
1105    int GetSecHashCd() const { return ((int)GetMsVal() + (int)GetLsVal()) / 0x10; } 
1106    uint GetMsVal() const {
1107      return (uint)(Val >> 32);}
1108    uint GetLsVal() const {
1109      return (uint)(Val & 0xffffffff);}
1110    #ifdef GLib_WIN
1111    TStr GetStr() const {return TStr::Fmt("%I64u", Val);}
1112    static TStr GetStr(const TUInt64& Int){return TStr::Fmt("%I64u", Int.Val);}
1113    static TStr GetHexStr(const TUInt64& Int){return TStr::Fmt("%I64X", Int.Val);}
1114    #else
1115    TStr GetStr() const {return TStr::Fmt("%llu", Val);}
1116    static TStr GetStr(const TUInt64& Int){return TStr::Fmt("%llu", Int.Val);}
1117    static TStr GetHexStr(const TUInt64& Int){return TStr::Fmt("%llX", Int.Val);}
1118    #endif
1119    static TStr GetKiloStr(const uint64& Val){
1120      if (Val>100*1000){return GetStr(Val/1000)+"K";}
1121      else if (Val>1000){return GetStr(Val/1000)+"."+GetStr((Val%1000)/100)+"K";}
1122      else {return GetStr(Val);}}
1123    static TStr GetMegaStr(const uint64& Val){
1124      if (Val>100*1000000){return GetStr(Val/1000000)+"M";}
1125      else if (Val>1000000){
1126        return GetStr(Val/1000000)+"."+GetStr((Val%1000000)/100000)+"M";}
1127      else {return GetKiloStr(Val);}}
1128  };
1129  class TFlt{
1130  public:
1131    double Val;
1132  public:
1133    static const double Mn;
1134    static const double Mx;
1135    static const double NInf;
1136    static const double PInf;
1137    static const double Eps;
1138    static const double EpsHalf;
1139    static TRnd Rnd;
1140    TFlt(): Val(0){}
1141    TFlt(const double& _Val): Val(_Val){}
1142    operator double() const {return Val;}
1143    explicit TFlt(TSIn& SIn){SIn.Load(Val);}
1144    void Save(TSOut& SOut) const {SOut.Save(Val);}
1145    explicit TFlt(TSIn& SIn, const bool& IsTxt){
1146      if (IsTxt){TStr Str(SIn, true); Val=Str.GetFlt(0);} else {SIn.Load(Val);}}
1147    void Load(TSIn& SIn){SIn.Load(Val);}
1148    void Save(TSOut& SOut, const bool& IsTxt) const {
1149      if (IsTxt){GetStr(Val).Save(SOut, true);} else {SOut.Save(Val);}}
1150    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
1151    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1152    TFlt& operator=(const TFlt& Flt){Val=Flt.Val; return *this;}
1153    TFlt& operator=(const double& Flt){Val=Flt; return *this;}
1154    bool operator==(const TFlt& Flt) const _CMPWARN {return Val==Flt.Val;}
1155    bool operator==(const double& Flt) const _CMPWARN {return Val==Flt;}
1156    bool operator!=(const double& Flt) const _CMPWARN {return Val!=Flt;}
1157    double operator()() const {return Val;}
1158    TFlt& operator+=(const double& Flt){Val+=Flt; return *this;}
1159    TFlt& operator-=(const double& Flt){Val-=Flt; return *this;}
1160    TFlt& operator*=(const double& Flt){Val*=Flt; return *this;}
1161    TFlt& operator/=(const double& Flt){Val/=Flt; return *this;}
1162    TFlt operator++(int){Val++; return *this;}
1163    TFlt operator--(int){Val--; return *this;}
1164    int GetMemUsed() const {return sizeof(TFlt);}
1165    int GetPrimHashCd() const {
1166      int Expn; return int((frexp(Val, &Expn)-0.5)*double(TInt::Mx));}
1167    int GetSecHashCd() const {
1168      int Expn; frexp(Val, &Expn); return Expn;}
1169    static double Abs(const double& Flt){return Flt<0?-Flt:Flt;}
1170    static int Sign(const double& Flt){return Flt<0?-1:(Flt>0?1:0);}
1171    static int Round(const double& Flt){return int(floor(Flt+0.5));}
1172    static double GetRnd(){return Rnd.GetUniDev();}
1173    static bool Eq6(const double& LFlt, const double& RFlt){
1174      return fabs(LFlt-RFlt)<0.000001;}
1175    static double GetMn(const double& Flt1, const double& Flt2){
1176      return Flt1<Flt2?Flt1:Flt2;}
1177    static double GetMn(const double& Flt1, const double& Flt2, const double& Flt3){
1178      return GetMn(GetMn(Flt1, Flt2), Flt3); }
1179    static double GetMn(const double& Flt1, const double& Flt2, const double& Flt3, const double& Flt4){
1180      return GetMn(GetMn(Flt1, Flt2), GetMn(Flt3, Flt4)); }
1181    static double GetMx(const double& Flt1, const double& Flt2){
1182      return Flt1>Flt2?Flt1:Flt2;}
1183    static double GetMx(const double& Flt1, const double& Flt2, const double Flt3){
1184      return GetMx(GetMx(Flt1, Flt2), Flt3); }
1185    static double GetMx(const double& Flt1, const double& Flt2, const double Flt3, const double& Flt4){
1186      return GetMx(GetMx(Flt1, Flt2), GetMx(Flt3, Flt4)); }
1187    static double GetInRng(const double& Val, const double& Mn, const double& Mx){
1188      IAssert(Mn<=Mx); return Val<Mn?Mn:(Val>Mx?Mx:Val);}
1189    static bool IsNum(const double& Val){
1190      return (Mn<=Val)&&(Val<=Mx);}
1191    static bool IsNan(const double& Val){
1192      return (Val!=Val);}
1193    bool IsNum() const { return IsNum(Val); }
1194    bool IsNan() const { return IsNan(Val); }
1195    TStr GetStr() const {return TFlt::GetStr(Val);}
1196    static TStr GetStr(const double& Val, const int& Width=-1, const int& Prec=-1);
1197    static TStr GetStr(const TFlt& Flt, const int& Width=-1, const int& Prec=-1){
1198      return GetStr(Flt.Val, Width, Prec);}
1199    static TStr GetStr(const double& Val, const char* FmtStr);
1200    static TStr GetStr(const double& Val, const TStr& FmtStr){
1201      return GetStr(Val, FmtStr.CStr());}
1202    static TStr GetPrcStr(const double& RelVal, const double& FullVal){
1203      return GetStr(100*RelVal/FullVal, "%3.0f%%");}
1204    static TStr GetKiloStr(const double& Val){
1205      if (fabs(Val)>100*1000){return TStr::Fmt("%.0fK", Val/1000);}
1206      else if (fabs(Val)>1000){return TStr::Fmt("%.1fK", Val/1000);}
1207      else {return TStr::Fmt("%.0f", Val);}}
1208    static TStr GetMegaStr(const double& Val){
1209      if (fabs(Val)>100*1000000){return TStr::Fmt("%.0fM", Val/1000000);}
1210      else if (fabs(Val)>1000000){return TStr::Fmt("%.1fM", Val/1000000);}
1211      else {return GetKiloStr(Val);}}
1212    static TStr GetGigaStr(const double& Val){
1213      if (fabs(Val)>100*1000000000.0){return TStr::Fmt("%.0fG", Val/1000000000.0);}
1214      else if (fabs(Val)>1000000000.0){return TStr::Fmt("%.1fG", Val/1000000000.0);}
1215      else {return GetMegaStr(Val);}}
1216  };
1217  class TAscFlt: public TFlt{
1218  public:
1219    TAscFlt(): TFlt(){}
1220    TAscFlt(const double& Val): TFlt(Val){}
1221    explicit TAscFlt(TSIn& SIn): TFlt(SIn, true){}
1222    void Save(TSOut& SOut) const {TFlt::Save(SOut, true);}
1223  };
1224  class TSFlt{
1225  public:
1226    sdouble Val;
1227  public:
1228    static const sdouble Mn;
1229    static const sdouble Mx;
1230    TSFlt(): Val(0){}
1231    TSFlt(const sdouble& _Val): Val(sdouble(_Val)){}
1232    operator sdouble() const {return Val;}
1233    explicit TSFlt(TSIn& SIn){SIn.Load(Val);}
1234    void Save(TSOut& SOut) const {SOut.Save(Val);}
1235    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
1236    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1237    TSFlt& operator=(const TSFlt& SFlt){Val=SFlt.Val; return *this;}
1238    bool operator==(const TSFlt& SFlt) const _CMPWARN {return Val==SFlt.Val;}
1239    bool operator==(const double& Flt) const _CMPWARN {return Val==Flt;}
1240    bool operator!=(const double& Flt) const _CMPWARN {return Val!=Flt;}
1241    bool operator<(const TSFlt& SFlt) const {return Val<SFlt.Val;}
1242    sdouble operator()() const {return Val;}
1243    TSFlt& operator+=(const double& SFlt){Val+=sdouble(SFlt); return *this;}
1244    TSFlt& operator-=(const double& SFlt){Val-=sdouble(SFlt); return *this;}
1245    TSFlt& operator*=(const double& SFlt){Val*=sdouble(SFlt); return *this;}
1246    TSFlt& operator/=(const double& SFlt){Val/=sdouble(SFlt); return *this;}
1247    TSFlt operator++(int){Val++; return *this;}
1248    TSFlt operator--(int){Val--; return *this;}
1249    int GetMemUsed() const {return sizeof(TSFlt);}
1250    int GetPrimHashCd() const {
1251      int Expn; return int((frexp(Val, &Expn)-0.5)*double(TInt::Mx));}
1252    int GetSecHashCd() const {
1253      int Expn; frexp(Val, &Expn); return Expn;}
1254  };
1255  class TLFlt{
1256  public:
1257    ldouble Val;
1258  public:
1259    static const ldouble Mn;
1260    static const ldouble Mx;
1261    TLFlt(): Val(0){}
1262    TLFlt(const ldouble& _Val): Val(_Val){}
1263    operator ldouble() const {return Val;}
1264    explicit TLFlt(TSIn& SIn){SIn.Load(Val);}
1265    void Save(TSOut& SOut) const {SOut.Save(Val);}
1266    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
1267    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1268    TLFlt& operator=(const TLFlt& LFlt){Val=LFlt.Val; return *this;}
1269    bool operator==(const TLFlt& LFlt) const _CMPWARN {return Val==LFlt.Val;}
1270    bool operator==(const ldouble& LFlt) const _CMPWARN {return Val==LFlt;}
1271    bool operator!=(const ldouble& LFlt) const _CMPWARN {return Val!=LFlt;}
1272    bool operator<(const TLFlt& LFlt) const {return Val<LFlt.Val;}
1273    ldouble operator()() const {return Val;}
1274    TLFlt& operator+=(const ldouble& LFlt){Val+=LFlt; return *this;}
1275    TLFlt& operator-=(const ldouble& LFlt){Val-=LFlt; return *this;}
1276    int GetMemUsed() const {return sizeof(TLFlt);}
1277    int GetPrimHashCd() const {Fail; return 0;}
1278    int GetSecHashCd() const {Fail; return 0;}
1279    static TStr GetStr(const ldouble& Val, const int& Width=-1, const int& Prec=-1);
1280    static TStr GetStr(const TLFlt& LFlt, const int& Width=-1, const int& Prec=-1){
1281      return GetStr(LFlt.Val, Width, Prec);}
1282    static TStr GetStr(const ldouble& Val, const char* FmtStr);
1283    static TStr GetStr(const ldouble& Val, const TStr& FmtStr){
1284      return GetStr(Val, FmtStr.CStr());}
1285  };
1286  class TFltRect{
1287  public:
1288    TFlt MnX, MnY, MxX, MxY;
1289  public:
1290    TFltRect():
1291      MnX(), MnY(), MxX(), MxY(){}
1292    TFltRect(const TFltRect& FltRect):
1293      MnX(FltRect.MnX), MnY(FltRect.MnY), MxX(FltRect.MxX), MxY(FltRect.MxY){}
1294    TFltRect(
1295     const double& _MnX, const double& _MnY,
1296     const double& _MxX, const double& _MxY):
1297      MnX(_MnX), MnY(_MnY), MxX(_MxX), MxY(_MxY){}
1298    TFltRect(TSIn& SIn):
1299      MnX(SIn), MnY(SIn), MxX(SIn), MxY(SIn){}
1300    void Save(TSOut& SOut) const {
1301      MnX.Save(SOut); MnY.Save(SOut); MxX.Save(SOut); MxY.Save(SOut);}
1302    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm);
1303    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1304    TFltRect& operator=(const TFltRect& FltRect){
1305      MnX=FltRect.MnX; MnY=FltRect.MnY; MxX=FltRect.MxX; MxY=FltRect.MxY;
1306      return *this;}
1307    double GetMnX() const {return MnX;}
1308    double GetMnY() const {return MnY;}
1309    double GetMxX() const {return MxX;}
1310    double GetMxY() const {return MxY;}
1311    double GetXLen() const {return MxX-MnX;}
1312    double GetYLen() const {return MxY-MnY;}
1313    double GetXCenter() const {return MnX+(MxX-MnX)/2;}
1314    double GetYCenter() const {return MnY+(MxY-MnY)/2;}
1315    bool IsXYIn(const double& X, const double& Y) const {
1316      return (MnX<=X)&&(X<=MxX)&&(MnY<=Y)&&(Y<=MxY);}
1317    static bool Intersection(const TFltRect& Rect1, const TFltRect& Rect2);
1318    TStr GetStr() const;
1319  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-sampleiterator.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.h</div>
                </div>
                <div class="column column_space"><pre><code>90      return sample_set_->GlobalSampleIndex(font_id, char_id, sample_index_);
91    } else {
92      return shape_index_;
93    }
94  }
95  int SampleIterator::GetCompactClassID() const {
96    return charset_map_ != nullptr ? charset_map_->SparseToCompact(shape_index_) : GetSparseClassID();
</pre></code></div>
                <div class="column column_space"><pre><code>632      if (Filled()){return Str1+MidStr+Str2;} else {return Str1+Str2;}}
633    int GetPrimHashCd() const {
634      return Str1.GetPrimHashCd()+Str2.GetPrimHashCd();}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    