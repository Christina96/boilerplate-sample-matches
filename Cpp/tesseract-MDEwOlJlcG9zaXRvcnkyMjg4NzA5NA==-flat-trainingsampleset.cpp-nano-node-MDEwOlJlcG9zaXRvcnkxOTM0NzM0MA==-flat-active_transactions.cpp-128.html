
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trainingsampleset.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &lt;algorithm&gt;
5  #include &lt;allheaders.h&gt;
6  #include &quot;boxread.h&quot;
7  #include &quot;fontinfo.h&quot;
8  #include &quot;indexmapbidi.h&quot;
9  #include &quot;intfeaturedist.h&quot;
10  #include &quot;intfeaturemap.h&quot;
11  #include &quot;intfeaturespace.h&quot;
12  #include &quot;shapetable.h&quot;
13  #include &quot;trainingsample.h&quot;
14  #include &quot;trainingsampleset.h&quot;
15  #include &quot;unicity_table.h&quot;
16  namespace tesseract {
17  const int kTestChar = -1; 
18  const int kSquareLimit = 25;
19  const int kPrime1 = 17;
20  const int kPrime2 = 13;
21  TrainingSampleSet::FontClassInfo::FontClassInfo()
22      : num_raw_samples(0), canonical_sample(-1), canonical_dist(0.0f) {}
23  bool TrainingSampleSet::FontClassInfo::Serialize(FILE *fp) const {
24    if (fwrite(&amp;num_raw_samples, sizeof(num_raw_samples), 1, fp) != 1) {
25      return false;
26    }
27    if (fwrite(&amp;canonical_sample, sizeof(canonical_sample), 1, fp) != 1) {
28      return false;
29    }
30    if (fwrite(&amp;canonical_dist, sizeof(canonical_dist), 1, fp) != 1) {
31      return false;
32    }
33    if (!::tesseract::Serialize(fp, samples)) {
34      return false;
35    }
36    return true;
37  }
38  bool TrainingSampleSet::FontClassInfo::DeSerialize(bool swap, FILE *fp) {
39    if (fread(&amp;num_raw_samples, sizeof(num_raw_samples), 1, fp) != 1) {
40      return false;
41    }
42    if (fread(&amp;canonical_sample, sizeof(canonical_sample), 1, fp) != 1) {
43      return false;
44    }
45    if (fread(&amp;canonical_dist, sizeof(canonical_dist), 1, fp) != 1) {
46      return false;
47    }
48    if (!::tesseract::DeSerialize(swap, fp, samples)) {
49      return false;
50    }
51    if (swap) {
52      ReverseN(&amp;num_raw_samples, sizeof(num_raw_samples));
53      ReverseN(&amp;canonical_sample, sizeof(canonical_sample));
54      ReverseN(&amp;canonical_dist, sizeof(canonical_dist));
55    }
56    return true;
57  }
58  TrainingSampleSet::TrainingSampleSet(const FontInfoTable &amp;font_table)
59      : num_raw_samples_(0)
60      , unicharset_size_(0)
61      , font_class_array_(nullptr)
62      , fontinfo_table_(font_table) {}
63  TrainingSampleSet::~TrainingSampleSet() {
64    for (auto sample : samples_) {
65      delete sample;
66    }
67    delete font_class_array_;
68  }
69  bool TrainingSampleSet::Serialize(FILE *fp) const {
70    if (!tesseract::Serialize(fp, samples_)) {
71      return false;
72    }
73    if (!unicharset_.save_to_file(fp)) {
74      return false;
75    }
76    if (!font_id_map_.Serialize(fp)) {
77      return false;
78    }
79    int8_t not_null = font_class_array_ != nullptr;
80    if (fwrite(&amp;not_null, sizeof(not_null), 1, fp) != 1) {
81      return false;
82    }
83    if (not_null) {
84      if (!font_class_array_-&gt;SerializeClasses(fp)) {
85        return false;
86      }
87    }
88    return true;
89  }
90  bool TrainingSampleSet::DeSerialize(bool swap, FILE *fp) {
91    if (!tesseract::DeSerialize(swap, fp, samples_)) {
92      return false;
93    }
94    num_raw_samples_ = samples_.size();
95    if (!unicharset_.load_from_file(fp)) {
96      return false;
97    }
98    if (!font_id_map_.DeSerialize(swap, fp)) {
99      return false;
100    }
101    delete font_class_array_;
102    font_class_array_ = nullptr;
103    int8_t not_null;
104    if (fread(&amp;not_null, sizeof(not_null), 1, fp) != 1) {
105      return false;
106    }
107    if (not_null) {
108      FontClassInfo empty;
109      font_class_array_ = new GENERIC_2D_ARRAY&lt;FontClassInfo&gt;(1, 1, empty);
110      if (!font_class_array_-&gt;DeSerializeClasses(swap, fp)) {
111        return false;
112      }
113    }
114    unicharset_size_ = unicharset_.size();
115    return true;
116  }
117  void TrainingSampleSet::LoadUnicharset(const char *filename) {
118    if (!unicharset_.load_from_file(filename)) {
119      tprintf(
120          &quot;Failed to load unicharset from file %s\n&quot;
121          &quot;Building unicharset from scratch...\n&quot;,
122          filename);
123      unicharset_.clear();
124      UNICHARSET empty;
125      unicharset_.AppendOtherUnicharset(empty);
126    }
127    unicharset_size_ = unicharset_.size();
128  }
129  int TrainingSampleSet::AddSample(const char *unichar, TrainingSample *sample) {
130    if (!unicharset_.contains_unichar(unichar)) {
131      unicharset_.unichar_insert(unichar);
132      if (unicharset_.size() &gt; MAX_NUM_CLASSES) {
133        tprintf(
134            &quot;Error: Size of unicharset in TrainingSampleSet::AddSample is &quot;
135            &quot;greater than MAX_NUM_CLASSES\n&quot;);
136        return -1;
137      }
138    }
139    UNICHAR_ID char_id = unicharset_.unichar_to_id(unichar);
140    AddSample(char_id, sample);
141    return char_id;
142  }
143  void TrainingSampleSet::AddSample(int unichar_id, TrainingSample *sample) {
144    sample-&gt;set_class_id(unichar_id);
145    samples_.push_back(sample);
146    num_raw_samples_ = samples_.size();
147    unicharset_size_ = unicharset_.size();
148  }
149  int TrainingSampleSet::NumClassSamples(int font_id, int class_id, bool randomize) const {
150    ASSERT_HOST(font_class_array_ != nullptr);
151    if (font_id &lt; 0 || class_id &lt; 0 || font_id &gt;= font_id_map_.SparseSize() ||
152        class_id &gt;= unicharset_size_) {
153      return 0;
154    }
155    int font_index = font_id_map_.SparseToCompact(font_id);
156    if (font_index &lt; 0) {
157      return 0; 
158    }
159    if (randomize) {
160      return (*font_class_array_)(font_index, class_id).samples.size();
161    } else {
162      return (*font_class_array_)(font_index, class_id).num_raw_samples;
163    }
164  }
165  const TrainingSample *TrainingSampleSet::GetSample(int index) const {
166    return samples_[index];
167  }
168  const TrainingSample *TrainingSampleSet::GetSample(int font_id, int class_id, int index) const {
169    ASSERT_HOST(font_class_array_ != nullptr);
170    int font_index = font_id_map_.SparseToCompact(font_id);
171    if (font_index &lt; 0) {
172      return nullptr;
173    }
174    int sample_index = (*font_class_array_)(font_index, class_id).samples[index];
175    return samples_[sample_index];
176  }
177  TrainingSample *TrainingSampleSet::MutableSample(int font_id, int class_id, int index) {
178    ASSERT_HOST(font_class_array_ != nullptr);
179    int font_index = font_id_map_.SparseToCompact(font_id);
180    if (font_index &lt; 0) {
181      return nullptr;
182    }
183    int sample_index = (*font_class_array_)(font_index, class_id).samples[index];
184    return samples_[sample_index];
185  }
186  std::string TrainingSampleSet::SampleToString(const TrainingSample &amp;sample) const {
187    std::string boxfile_str;
188    MakeBoxFileStr(unicharset_.id_to_unichar(sample.class_id()), sample.bounding_box(),
189                   sample.page_num(), boxfile_str);
190    return std::string(fontinfo_table_.at(sample.font_id()).name) + &quot; &quot; + boxfile_str;
191  }
192  const BitVector &amp;TrainingSampleSet::GetCloudFeatures(int font_id, int class_id) const {
193    int font_index = font_id_map_.SparseToCompact(font_id);
194    ASSERT_HOST(font_index &gt;= 0);
195    return (*font_class_array_)(font_index, class_id).cloud_features;
196  }
197  const std::vector&lt;int&gt; &amp;TrainingSampleSet::GetCanonicalFeatures(int font_id, int class_id) const {
198    int font_index = font_id_map_.SparseToCompact(font_id);
199    ASSERT_HOST(font_index &gt;= 0);
200    return (*font_class_array_)(font_index, class_id).canonical_features;
201  }
202  float TrainingSampleSet::UnicharDistance(const UnicharAndFonts &amp;uf1, const UnicharAndFonts &amp;uf2,
203                                           bool matched_fonts, const IntFeatureMap &amp;feature_map) {
204    int num_fonts1 = uf1.font_ids.size();
205    int c1 = uf1.unichar_id;
206    int num_fonts2 = uf2.font_ids.size();
207    int c2 = uf2.unichar_id;
208    double dist_sum = 0.0;
209    int dist_count = 0;
210    const bool debug = false;
211    if (matched_fonts) {
212      for (int i = 0; i &lt; num_fonts1; ++i) {
213        int f1 = uf1.font_ids[i];
214        for (int j = 0; j &lt; num_fonts2; ++j) {
215          int f2 = uf2.font_ids[j];
216          if (f1 == f2) {
217            dist_sum += ClusterDistance(f1, c1, f2, c2, feature_map);
218            ++dist_count;
219          }
220        }
221      }
222    } else if (num_fonts1 * num_fonts2 &lt;= kSquareLimit) {
223      for (int i = 0; i &lt; num_fonts1; ++i) {
224        int f1 = uf1.font_ids[i];
225        for (int j = 0; j &lt; num_fonts2; ++j) {
226          int f2 = uf2.font_ids[j];
227          dist_sum += ClusterDistance(f1, c1, f2, c2, feature_map);
228          if (debug) {
229            tprintf(&quot;Cluster dist %d %d %d %d = %g\n&quot;, f1, c1, f2, c2,
230                    ClusterDistance(f1, c1, f2, c2, feature_map));
231          }
232          ++dist_count;
233        }
234      }
235    } else {
236      int increment = kPrime1 != num_fonts2 ? kPrime1 : kPrime2;
237      int index = 0;
238      int num_samples = std::max(num_fonts1, num_fonts2);
239      for (int i = 0; i &lt; num_samples; ++i, index += increment) {
240        int f1 = uf1.font_ids[i % num_fonts1];
241        int f2 = uf2.font_ids[index % num_fonts2];
242        if (debug) {
243          tprintf(&quot;Cluster dist %d %d %d %d = %g\n&quot;, f1, c1, f2, c2,
244                  ClusterDistance(f1, c1, f2, c2, feature_map));
245        }
246        dist_sum += ClusterDistance(f1, c1, f2, c2, feature_map);
247        ++dist_count;
248      }
249    }
250    if (dist_count == 0) {
251      if (matched_fonts) {
252        return UnicharDistance(uf1, uf2, false, feature_map);
253      }
254      return 0.0f;
255    }
256    return dist_sum / dist_count;
257  }
258  float TrainingSampleSet::ClusterDistance(int font_id1, int class_id1, int font_id2, int class_id2,
259                                           const IntFeatureMap &amp;feature_map) {
260    ASSERT_HOST(font_class_array_ != nullptr);
261    int font_index1 = font_id_map_.SparseToCompact(font_id1);
262    int font_index2 = font_id_map_.SparseToCompact(font_id2);
263    if (font_index1 &lt; 0 || font_index2 &lt; 0) {
264      return 0.0f;
265    }
266    FontClassInfo &amp;fc_info = (*font_class_array_)(font_index1, class_id1);
267    if (font_id1 == font_id2) {
268      if (fc_info.unichar_distance_cache.empty()) {
269        fc_info.unichar_distance_cache.resize(unicharset_size_, -1.0f);
270      }
271      if (fc_info.unichar_distance_cache[class_id2] &lt; 0) {
272        float result = ComputeClusterDistance(font_id1, class_id1, font_id2, class_id2, feature_map);
273        fc_info.unichar_distance_cache[class_id2] = result;
274        FontClassInfo &amp;fc_info2 = (*font_class_array_)(font_index2, class_id2);
275        if (fc_info2.unichar_distance_cache.empty()) {
276          fc_info2.unichar_distance_cache.resize(unicharset_size_, -1.0f);
277        }
278        fc_info2.unichar_distance_cache[class_id1] = result;
279      }
280      return fc_info.unichar_distance_cache[class_id2];
281    } else if (class_id1 == class_id2) {
282      if (fc_info.font_distance_cache.empty()) {
283        fc_info.font_distance_cache.resize(font_id_map_.CompactSize(), -1.0f);
284      }
285      if (fc_info.font_distance_cache[font_index2] &lt; 0) {
286        float result = ComputeClusterDistance(font_id1, class_id1, font_id2, class_id2, feature_map);
287        fc_info.font_distance_cache[font_index2] = result;
288        FontClassInfo &amp;fc_info2 = (*font_class_array_)(font_index2, class_id2);
289        if (fc_info2.font_distance_cache.empty()) {
290          fc_info2.font_distance_cache.resize(font_id_map_.CompactSize(), -1.0f);
291        }
292        fc_info2.font_distance_cache[font_index1] = result;
293      }
294      return fc_info.font_distance_cache[font_index2];
295    }
296    size_t cache_index = 0;
297    while (cache_index &lt; fc_info.distance_cache.size() &amp;&amp;
298           (fc_info.distance_cache[cache_index].unichar_id != class_id2 ||
299            fc_info.distance_cache[cache_index].font_id != font_id2)) {
300      ++cache_index;
301    }
302    if (cache_index == fc_info.distance_cache.size()) {
303      float result = ComputeClusterDistance(font_id1, class_id1, font_id2, class_id2, feature_map);
304      FontClassDistance fc_dist = {class_id2, font_id2, result};
305      fc_info.distance_cache.push_back(fc_dist);
306      FontClassInfo &amp;fc_info2 = (*font_class_array_)(font_index2, class_id2);
307      fc_dist.unichar_id = class_id1;
308      fc_dist.font_id = font_id1;
309      fc_info2.distance_cache.push_back(fc_dist);
310    }
311    return fc_info.distance_cache[cache_index].distance;
312  }
313  float TrainingSampleSet::ComputeClusterDistance(int font_id1, int class_id1, int font_id2,
314                                                  int class_id2,
315                                                  const IntFeatureMap &amp;feature_map) const {
316    int dist = ReliablySeparable(font_id1, class_id1, font_id2, class_id2, feature_map, false);
317    dist += ReliablySeparable(font_id2, class_id2, font_id1, class_id1, feature_map, false);
318    int denominator = GetCanonicalFeatures(font_id1, class_id1).size();
319    denominator += GetCanonicalFeatures(font_id2, class_id2).size();
320    return static_cast&lt;float&gt;(dist) / denominator;
321  }
322  static void AddNearFeatures(const IntFeatureMap &amp;feature_map, int f, int levels,
323                              std::vector&lt;int&gt; *good_features) {
324    int prev_num_features = 0;
325    good_features-&gt;push_back(f);
326    int num_features = 1;
327    for (int level = 0; level &lt; levels; ++level) {
328      for (int i = prev_num_features; i &lt; num_features; ++i) {
329        int feature = (*good_features)[i];
330        for (int dir = -kNumOffsetMaps; dir &lt;= kNumOffsetMaps; ++dir) {
331          if (dir == 0) {
332            continue;
333          }
334          int f1 = feature_map.OffsetFeature(feature, dir);
335          if (f1 &gt;= 0) {
336            good_features-&gt;push_back(f1);
337          }
338        }
339      }
340      prev_num_features = num_features;
341      num_features = good_features-&gt;size();
342    }
343  }
344  int TrainingSampleSet::ReliablySeparable(int font_id1, int class_id1, int font_id2, int class_id2,
345                                           const IntFeatureMap &amp;feature_map, bool thorough) const {
346    int result = 0;
347    const TrainingSample *sample2 = GetCanonicalSample(font_id2, class_id2);
348    if (sample2 == nullptr) {
349      return 0; 
350    }
351    const std::vector&lt;int&gt; &amp;canonical2 = GetCanonicalFeatures(font_id2, class_id2);
352    const BitVector &amp;cloud1 = GetCloudFeatures(font_id1, class_id1);
353    if (cloud1.empty()) {
354      return canonical2.size(); 
355    }
356    for (int feature : canonical2) {
357      if (cloud1[feature]) {
358        continue;
359      }
360      std::vector&lt;int&gt; good_features;
361      AddNearFeatures(feature_map, feature, 1, &amp;good_features);
362      bool found = false;
363      for (auto good_f : good_features) {
364        if (cloud1[good_f]) {
365          found = true;
366          break;
367        }
368      }
369      if (found) {
370        continue; 
371      }
372      ++result;
373    }
374    return result;
375  }
376  int TrainingSampleSet::GlobalSampleIndex(int font_id, int class_id, int index) const {
377    ASSERT_HOST(font_class_array_ != nullptr);
378    int font_index = font_id_map_.SparseToCompact(font_id);
379    if (font_index &lt; 0) {
380      return -1;
381    }
382    return (*font_class_array_)(font_index, class_id).samples[index];
383  }
384  const TrainingSample *TrainingSampleSet::GetCanonicalSample(int font_id, int class_id) const {
385    ASSERT_HOST(font_class_array_ != nullptr);
386    int font_index = font_id_map_.SparseToCompact(font_id);
387    if (font_index &lt; 0) {
388      return nullptr;
389    }
390    const int sample_index = (*font_class_array_)(font_index, class_id).canonical_sample;
391    return sample_index &gt;= 0 ? samples_[sample_index] : nullptr;
392  }
393  float TrainingSampleSet::GetCanonicalDist(int font_id, int class_id) const {
394    ASSERT_HOST(font_class_array_ != nullptr);
395    int font_index = font_id_map_.SparseToCompact(font_id);
396    if (font_index &lt; 0) {
397      return 0.0f;
398    }
399    if ((*font_class_array_)(font_index, class_id).canonical_sample &gt;= 0) {
400      return (*font_class_array_)(font_index, class_id).canonical_dist;
401    } else {
402      return 0.0f;
403    }
404  }
405  void TrainingSampleSet::IndexFeatures(const IntFeatureSpace &amp;feature_space) {
406    for (auto &amp;sample : samples_) {
407      sample-&gt;IndexFeatures(feature_space);
408    }
409  }
410  void TrainingSampleSet::KillSample(TrainingSample *sample) {
411    sample-&gt;set_sample_index(-1);
412  }
413  void TrainingSampleSet::DeleteDeadSamples() {
414    using namespace std::placeholders; 
415    for (auto &amp;&amp;it = samples_.begin(); it &lt; samples_.end();) {
416      if (*it == nullptr || (*it)-&gt;class_id() &lt; 0) {
417        samples_.erase(it);
418        delete *it;
419      } else {
420        ++it;
421      }
422    }
423    num_raw_samples_ = samples_.size();
424  }
425  void TrainingSampleSet::OrganizeByFontAndClass() {
426    SetupFontIdMap();
427    int compact_font_size = font_id_map_.CompactSize();
428    delete font_class_array_;
429    FontClassInfo empty;
430    font_class_array_ =
431        new GENERIC_2D_ARRAY&lt;FontClassInfo&gt;(compact_font_size, unicharset_size_, empty);
432    for (size_t s = 0; s &lt; samples_.size(); ++s) {
433      int font_id = samples_[s]-&gt;font_id();
434      int class_id = samples_[s]-&gt;class_id();
435      if (font_id &lt; 0 || font_id &gt;= font_id_map_.SparseSize()) {
436        tprintf(&quot;Font id = %d/%d, class id = %d/%d on sample %zu\n&quot;, font_id,
437                font_id_map_.SparseSize(), class_id, unicharset_size_, s);
438      }
439      ASSERT_HOST(font_id &gt;= 0 &amp;&amp; font_id &lt; font_id_map_.SparseSize());
440      ASSERT_HOST(class_id &gt;= 0 &amp;&amp; class_id &lt; unicharset_size_);
441      int font_index = font_id_map_.SparseToCompact(font_id);
442      (*font_class_array_)(font_index, class_id).samples.push_back(s);
443    }
444    for (int f = 0; f &lt; compact_font_size; ++f) {
445      for (int c = 0; c &lt; unicharset_size_; ++c) {
446        (*font_class_array_)(f, c).num_raw_samples = (*font_class_array_)(f, c).samples.size();
447      }
448    }
449    num_raw_samples_ = samples_.size();
450  }
451  void TrainingSampleSet::SetupFontIdMap() {
452    std::vector&lt;int&gt; font_counts;
453    for (auto &amp;sample : samples_) {
454      const int font_id = sample-&gt;font_id();
455      while (font_id &gt;= font_counts.size()) {
456        font_counts.push_back(0);
457      }
458      ++font_counts[font_id];
459    }
460    font_id_map_.Init(font_counts.size(), false);
461    for (size_t f = 0; f &lt; font_counts.size(); ++f) {
462      font_id_map_.SetMap(f, font_counts[f] &gt; 0);
463    }
464    font_id_map_.Setup();
465  }
466  void TrainingSampleSet::ComputeCanonicalSamples(const IntFeatureMap &amp;map, bool debug) {
467    ASSERT_HOST(font_class_array_ != nullptr);
468    IntFeatureDist f_table;
469    if (debug) {
470      tprintf(&quot;feature table size %d\n&quot;, map.sparse_size());
471    }
472    f_table.Init(&amp;map);
473    int worst_s1 = 0;
474    int worst_s2 = 0;
475    double global_worst_dist = 0.0;
476    int font_size = font_id_map_.CompactSize();
477    for (int font_index = 0; font_index &lt; font_size; ++font_index) {
478      int font_id = font_id_map_.CompactToSparse(font_index);
479      for (int c = 0; c &lt; unicharset_size_; ++c) {
480        int samples_found = 0;
481        FontClassInfo &amp;fcinfo = (*font_class_array_)(font_index, c);
482        if (fcinfo.samples.empty() || (kTestChar &gt;= 0 &amp;&amp; c != kTestChar)) {
483          fcinfo.canonical_sample = -1;
484          fcinfo.canonical_dist = 0.0f;
485          if (debug) {
486            tprintf(&quot;Skipping class %d\n&quot;, c);
487          }
488          continue;
489        }
490        double min_max_dist = 2.0;
491        double max_max_dist = 0.0;
492        int max_s1 = 0;
493        int max_s2 = 0;
494        fcinfo.canonical_sample = fcinfo.samples[0];
495        fcinfo.canonical_dist = 0.0f;
496        for (auto s1 : fcinfo.samples) {
497          const std::vector&lt;int&gt; &amp;features1 = samples_[s1]-&gt;indexed_features();
498          f_table.Set(features1, features1.size(), true);
499          double max_dist = 0.0;
500          for (int s2 : fcinfo.samples) {
501            if (samples_[s2]-&gt;class_id() != c || samples_[s2]-&gt;font_id() != font_id || s2 == s1) {
502              continue;
503            }
504            std::vector&lt;int&gt; features2 = samples_[s2]-&gt;indexed_features();
505            double dist = f_table.FeatureDistance(features2);
506            if (dist &gt; max_dist) {
507              max_dist = dist;
508              if (dist &gt; max_max_dist) {
509                max_max_dist = dist;
510                max_s1 = s1;
511                max_s2 = s2;
512              }
513            }
514          }
515          f_table.Set(features1, features1.size(), false);
516          samples_[s1]-&gt;set_max_dist(max_dist);
517          ++samples_found;
518          if (max_dist &lt; min_max_dist) {
519            fcinfo.canonical_sample = s1;
520            fcinfo.canonical_dist = max_dist;
521          }
522          UpdateRange(max_dist, &amp;min_max_dist, &amp;max_max_dist);
523        }
524        if (max_max_dist &gt; global_worst_dist) {
525          global_worst_dist = max_max_dist;
526          worst_s1 = max_s1;
527          worst_s2 = max_s2;
528        }
529        if (debug) {
530          tprintf(
531              &quot;Found %d samples of class %d=%s, font %d, &quot;
532              &quot;dist range [%g, %g], worst pair= %s, %s\n&quot;,
533              samples_found, c, unicharset_.debug_str(c).c_str(), font_index, min_max_dist,
534              max_max_dist, SampleToString(*samples_[max_s1]).c_str(),
535              SampleToString(*samples_[max_s2]).c_str());
536        }
537      }
538    }
539    if (debug) {
540      tprintf(&quot;Global worst dist = %g, between sample %d and %d\n&quot;, global_worst_dist, worst_s1,
541              worst_s2);
542    }
543  }
544  void TrainingSampleSet::ReplicateAndRandomizeSamples() {
545    ASSERT_HOST(font_class_array_ != nullptr);
546    int font_size = font_id_map_.CompactSize();
547    for (int font_index = 0; font_index &lt; font_size; ++font_index) {
548      for (int c = 0; c &lt; unicharset_size_; ++c) {
549        FontClassInfo &amp;fcinfo = (*font_class_array_)(font_index, c);
550        int sample_count = fcinfo.samples.size();
551        int min_samples = 2 * std::max(kSampleRandomSize, sample_count);
552        if (sample_count &gt; 0 &amp;&amp; sample_count &lt; min_samples) {
553          int base_count = sample_count;
554          for (int base_index = 0; sample_count &lt; min_samples; ++sample_count) {
555            int src_index = fcinfo.samples[base_index++];
556            if (base_index &gt;= base_count) {
557              base_index = 0;
558            }
559            TrainingSample *sample =
560                samples_[src_index]-&gt;RandomizedCopy(sample_count % kSampleRandomSize);
561            int sample_index = samples_.size();
562            sample-&gt;set_sample_index(sample_index);
<span onclick='openModal()' class='match'>563            samples_.push_back(sample);
564            fcinfo.samples.push_back(sample_index);
565          }
</span>566        }
567      }
568    }
569  }
570  void TrainingSampleSet::ComputeCanonicalFeatures() {
571    ASSERT_HOST(font_class_array_ != nullptr);
572    const int font_size = font_id_map_.CompactSize();
573    for (int font_index = 0; font_index &lt; font_size; ++font_index) {
574      const int font_id = font_id_map_.CompactToSparse(font_index);
575      for (int c = 0; c &lt; unicharset_size_; ++c) {
576        int num_samples = NumClassSamples(font_id, c, false);
577        if (num_samples == 0) {
578          continue;
579        }
580        const TrainingSample *sample = GetCanonicalSample(font_id, c);
581        FontClassInfo &amp;fcinfo = (*font_class_array_)(font_index, c);
582        fcinfo.canonical_features = sample-&gt;indexed_features();
583      }
584    }
585  }
586  void TrainingSampleSet::ComputeCloudFeatures(int feature_space_size) {
587    ASSERT_HOST(font_class_array_ != nullptr);
588    int font_size = font_id_map_.CompactSize();
589    for (int font_index = 0; font_index &lt; font_size; ++font_index) {
590      int font_id = font_id_map_.CompactToSparse(font_index);
591      for (int c = 0; c &lt; unicharset_size_; ++c) {
592        int num_samples = NumClassSamples(font_id, c, false);
593        if (num_samples == 0) {
594          continue;
595        }
596        FontClassInfo &amp;fcinfo = (*font_class_array_)(font_index, c);
597        fcinfo.cloud_features.Init(feature_space_size);
598        for (int s = 0; s &lt; num_samples; ++s) {
599          const TrainingSample *sample = GetSample(font_id, c, s);
600          const std::vector&lt;int&gt; &amp;sample_features = sample-&gt;indexed_features();
601          for (int sample_feature : sample_features) {
602            fcinfo.cloud_features.SetBit(sample_feature);
603          }
604        }
605      }
606    }
607  }
608  void TrainingSampleSet::AddAllFontsForClass(int class_id, Shape *shape) const {
609    for (int f = 0; f &lt; font_id_map_.CompactSize(); ++f) {
610      const int font_id = font_id_map_.CompactToSparse(f);
611      shape-&gt;AddToShape(class_id, font_id);
612    }
613  }
614  #ifndef GRAPHICS_DISABLED
615  void TrainingSampleSet::DisplaySamplesWithFeature(int f_index, const Shape &amp;shape,
616                                                    const IntFeatureSpace &amp;space,
617                                                    ScrollView::Color color,
618                                                    ScrollView *window) const {
619    for (int s = 0; s &lt; num_raw_samples(); ++s) {
620      const TrainingSample *sample = GetSample(s);
621      if (shape.ContainsUnichar(sample-&gt;class_id())) {
622        std::vector&lt;int&gt; indexed_features;
623        space.IndexAndSortFeatures(sample-&gt;features(), sample-&gt;num_features(), &amp;indexed_features);
624        for (int indexed_feature : indexed_features) {
625          if (indexed_feature == f_index) {
626            sample-&gt;DisplayFeatures(color, window);
627          }
628        }
629      }
630    }
631  }
632  #endif 
633  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.cpp</h3>
            <pre><code>1  #include &lt;nano/lib/jsonconfig.hpp&gt;
2  #include &lt;nano/node/election.hpp&gt;
3  #include &lt;nano/node/scheduler/buckets.hpp&gt;
4  #include &lt;nano/node/scheduler/component.hpp&gt;
5  #include &lt;nano/node/transport/inproc.hpp&gt;
6  #include &lt;nano/test_common/chains.hpp&gt;
7  #include &lt;nano/test_common/system.hpp&gt;
8  #include &lt;nano/test_common/testutil.hpp&gt;
9  #include &lt;gtest/gtest.h&gt;
10  #include &lt;numeric&gt;
11  using namespace std::chrono_literals;
12  namespace nano
13  {
14  TEST (active_transactions, confirm_election_by_request)
15  {
16  	nano::test::system system{};
17  	auto &amp; node1 = *system.add_node ();
18  	nano::state_block_builder builder{};
19  	auto send1 = builder
20  				 .account (nano::dev::genesis_key.pub)
21  				 .representative (nano::dev::genesis_key.pub)
22  				 .previous (nano::dev::genesis-&gt;hash ())
23  				 .link (nano::public_key ())
24  				 .balance (nano::dev::constants.genesis_amount - 100)
25  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
26  				 .work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
27  				 .build_shared ();
28  	ASSERT_TRUE (nano::test::process (node1, { send1 }));
29  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
30  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { send1 }));
31  	ASSERT_TIMELY (5s, node1.active.empty ());
32  	WAIT (1s);
33  	nano::node_flags node_flags2{};
34  	node_flags2.disable_rep_crawler = true;
35  	auto &amp; node2 = *system.add_node (node_flags2);
36  	node2.process_active (send1);
37  	std::shared_ptr&lt;nano::election&gt; election{};
38  	ASSERT_TIMELY (5s, (election = node2.active.election (send1-&gt;qualified_root ())) != nullptr);
39  	WAIT (1s);
40  	ASSERT_FALSE (election-&gt;confirmed ());
41  	ASSERT_EQ (0, election-&gt;confirmation_request_count);
42  	auto const peers = node2.network.random_set (1);
43  	ASSERT_FALSE (peers.empty ());
44  	{
45  		nano::lock_guard&lt;nano::mutex&gt; guard (node2.rep_crawler.probable_reps_mutex);
46  		node2.rep_crawler.probable_reps.emplace (nano::dev::genesis_key.pub, *peers.cbegin ());
47  	}
48  	ASSERT_TIMELY (5s, election-&gt;votes ().size () &gt;= 1);
49  	ASSERT_TIMELY (5s, election-&gt;confirmation_request_count &gt;= 1);
50  	ASSERT_TIMELY (5s, election-&gt;confirmed ());
51  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { send1 }));
52  	ASSERT_TIMELY (5s, nano::test::confirmed (node2, { send1 }));
53  }
54  }
55  namespace nano
56  {
57  TEST (active_transactions, confirm_frontier)
58  {
59  	nano::test::system system;
60  	nano::node_flags node_flags;
61  	node_flags.disable_request_loop = true;
62  	auto &amp; node1 = *system.add_node (node_flags);
63  	nano::node_flags node_flags2;
64  	node_flags2.disable_rep_crawler = true;
65  	auto &amp; node2 = *system.add_node (node_flags2);
66  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
67  	auto peers (node2.network.random_set (1));
68  	ASSERT_FALSE (peers.empty ());
69  	{
70  		nano::lock_guard&lt;nano::mutex&gt; guard (node2.rep_crawler.probable_reps_mutex);
71  		node2.rep_crawler.probable_reps.emplace (nano::dev::genesis_key.pub, *peers.begin ());
72  	}
73  	nano::state_block_builder builder;
74  	auto send = builder
75  				.account (nano::dev::genesis_key.pub)
76  				.previous (nano::dev::genesis-&gt;hash ())
77  				.representative (nano::dev::genesis_key.pub)
78  				.balance (nano::dev::constants.genesis_amount - 100)
79  				.link (nano::public_key ())
80  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
81  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
82  				.build_shared ();
83  	auto send_copy = builder.make_block ().from (*send).build_shared ();
84  	ASSERT_EQ (nano::process_result::progress, node1.process (*send).code);
85  	node1.confirmation_height_processor.add (send);
86  	ASSERT_TIMELY (5s, node1.ledger.block_confirmed (node1.store.tx_begin_read (), send-&gt;hash ()));
87  	ASSERT_EQ (nano::process_result::progress, node2.process (*send_copy).code);
88  	ASSERT_TIMELY (5s, !node2.active.empty ());
89  	auto election2 = node2.active.election (send-&gt;qualified_root ());
90  	ASSERT_NE (nullptr, election2);
91  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 2 &amp;&amp; node2.active.empty ());
92  	ASSERT_GT (election2-&gt;confirmation_request_count, 0u);
93  }
94  }
95  TEST (active_transactions, keep_local)
96  {
97  	nano::test::system system{};
98  	nano::node_config node_config = system.default_config ();
99  	node_config.enable_voting = false;
100  	node_config.active_elections_size = 2;
101  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
102  	auto &amp; node = *system.add_node (node_config);
103  	auto &amp; wallet (*system.wallet (0));
104  	nano::keypair key1{};
105  	nano::keypair key2{};
106  	nano::keypair key3{};
107  	nano::keypair key4{};
108  	nano::keypair key5{};
109  	nano::keypair key6{};
110  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
111  	auto const send1 = wallet.send_action (nano::dev::genesis_key.pub, key1.pub, node.config.receive_minimum.number ());
112  	auto const send2 = wallet.send_action (nano::dev::genesis_key.pub, key2.pub, node.config.receive_minimum.number ());
113  	auto const send3 = wallet.send_action (nano::dev::genesis_key.pub, key3.pub, node.config.receive_minimum.number ());
114  	auto const send4 = wallet.send_action (nano::dev::genesis_key.pub, key4.pub, node.config.receive_minimum.number ());
115  	auto const send5 = wallet.send_action (nano::dev::genesis_key.pub, key5.pub, node.config.receive_minimum.number ());
116  	auto const send6 = wallet.send_action (nano::dev::genesis_key.pub, key6.pub, node.config.receive_minimum.number ());
117  	for (auto const &amp; block : { send1, send2, send3, send4, send5, send6 })
118  	{
119  		std::shared_ptr&lt;nano::election&gt; election{};
120  		ASSERT_TIMELY (5s, (election = node.active.election (block-&gt;qualified_root ())) != nullptr);
121  		node.process_confirmed (nano::election_status{ block });
122  		election-&gt;force_confirm ();
123  		ASSERT_TIMELY (5s, node.block_confirmed (block-&gt;hash ()));
124  	}
125  	nano::state_block_builder builder{};
126  	const auto receive1 = builder.make_block ()
127  						  .account (key1.pub)
128  						  .previous (0)
129  						  .representative (key1.pub)
130  						  .balance (node.config.receive_minimum.number ())
131  						  .link (send1-&gt;hash ())
132  						  .sign (key1.prv, key1.pub)
133  						  .work (*system.work.generate (key1.pub))
134  						  .build_shared ();
135  	const auto receive2 = builder.make_block ()
136  						  .account (key2.pub)
137  						  .previous (0)
138  						  .representative (key2.pub)
139  						  .balance (node.config.receive_minimum.number ())
140  						  .link (send2-&gt;hash ())
141  						  .sign (key2.prv, key2.pub)
142  						  .work (*system.work.generate (key2.pub))
143  						  .build_shared ();
144  	const auto receive3 = builder.make_block ()
145  						  .account (key3.pub)
146  						  .previous (0)
147  						  .representative (key3.pub)
148  						  .balance (node.config.receive_minimum.number ())
149  						  .link (send3-&gt;hash ())
150  						  .sign (key3.prv, key3.pub)
151  						  .work (*system.work.generate (key3.pub))
152  						  .build_shared ();
153  	node.process_active (receive1);
154  	node.process_active (receive2);
155  	node.process_active (receive3);
156  	ASSERT_TIMELY (5s, node.active.size () == node_config.active_elections_size);
157  }
158  TEST (active_transactions, inactive_votes_cache)
159  {
160  	nano::test::system system (1);
161  	auto &amp; node = *system.nodes[0];
162  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
163  	nano::keypair key;
164  	auto send = nano::send_block_builder ()
165  				.previous (latest)
166  				.destination (key.pub)
167  				.balance (nano::dev::constants.genesis_amount - 100)
168  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
169  				.work (*system.work.generate (latest))
170  				.build_shared ();
171  	auto vote (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt; (1, send-&gt;hash ())));
172  	node.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
173  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
174  	node.process_active (send);
175  	node.block_processor.flush ();
176  	ASSERT_TIMELY (5s, node.ledger.block_confirmed (node.store.tx_begin_read (), send-&gt;hash ()));
177  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
178  }
179  TEST (active_transactions, inactive_votes_cache_non_final)
180  {
181  	nano::test::system system (1);
182  	auto &amp; node = *system.nodes[0];
183  	auto send = nano::send_block_builder ()
184  				.previous (nano::dev::genesis-&gt;hash ())
185  				.destination (nano::keypair{}.pub)
186  				.balance (nano::dev::constants.genesis_amount - 100)
187  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
188  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
189  				.build_shared ();
190  	auto vote = std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector&lt;nano::block_hash&gt; (1, send-&gt;hash ()));
191  	node.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
192  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
193  	node.process_active (send);
194  	std::shared_ptr&lt;nano::election&gt; election;
195  	ASSERT_TIMELY (5s, election = node.active.election (send-&gt;qualified_root ()));
196  	ASSERT_TIMELY_EQ (5s, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached), 1);
197  	ASSERT_TIMELY_EQ (5s, nano::dev::constants.genesis_amount - 100, election-&gt;tally ().begin ()-&gt;first);
198  	ASSERT_FALSE (election-&gt;confirmed ());
199  }
200  TEST (active_transactions, inactive_votes_cache_fork)
201  {
202  	nano::test::system system{ 1 };
203  	auto &amp; node = *system.nodes[0];
204  	auto const latest = node.latest (nano::dev::genesis_key.pub);
205  	nano::keypair key{};
206  	nano::send_block_builder builder{};
207  	auto send1 = builder.make_block ()
208  				 .previous (latest)
209  				 .destination (key.pub)
210  				 .balance (nano::dev::constants.genesis_amount - 100)
211  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
212  				 .work (*system.work.generate (latest))
213  				 .build_shared ();
214  	auto send2 = builder.make_block ()
215  				 .previous (latest)
216  				 .destination (key.pub)
217  				 .balance (nano::dev::constants.genesis_amount - 200)
218  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
219  				 .work (*system.work.generate (latest))
220  				 .build_shared ();
221  	auto const vote = std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt; (1, send1-&gt;hash ()));
222  	node.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
223  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
224  	node.process_active (send2);
225  	std::shared_ptr&lt;nano::election&gt; election{};
226  	ASSERT_TIMELY (5s, (election = node.active.election (send1-&gt;qualified_root ())) != nullptr);
227  	node.process_active (send1);
228  	ASSERT_TIMELY (5s, election-&gt;blocks ().size () == 2);
229  	ASSERT_TIMELY (5s, node.block_confirmed (send1-&gt;hash ()));
230  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
231  }
232  TEST (active_transactions, inactive_votes_cache_existing_vote)
233  {
234  	nano::test::system system;
235  	nano::node_config node_config = system.default_config ();
236  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
237  	auto &amp; node = *system.add_node (node_config);
238  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
239  	nano::keypair key;
240  	nano::block_builder builder;
241  	auto send = builder.send ()
242  				.previous (latest)
243  				.destination (key.pub)
244  				.balance (nano::dev::constants.genesis_amount - 100 * nano::Gxrb_ratio)
245  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
246  				.work (*system.work.generate (latest))
247  				.build_shared ();
248  	auto open = builder.state ()
249  				.account (key.pub)
250  				.previous (0)
251  				.representative (key.pub)
252  				.balance (100 * nano::Gxrb_ratio)
253  				.link (send-&gt;hash ())
254  				.sign (key.prv, key.pub)
255  				.work (*system.work.generate (key.pub))
256  				.build_shared ();
<span onclick='openModal()' class='match'>257  	node.process_active (send);
258  	node.block_processor.add (open);
259  	node.block_processor.flush ();
</span>260  	ASSERT_TIMELY (5s, node.active.size () == 1);
261  	auto election (node.active.election (send-&gt;qualified_root ()));
262  	ASSERT_NE (nullptr, election);
263  	ASSERT_GT (node.weight (key.pub), node.minimum_principal_weight ());
264  	auto vote1 (std::make_shared&lt;nano::vote&gt; (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector&lt;nano::block_hash&gt; (1, send-&gt;hash ())));
265  	node.vote_processor.vote (vote1, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
266  	ASSERT_TIMELY (5s, election-&gt;votes ().size () == 2);
267  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_new));
268  	auto last_vote1 (election-&gt;votes ()[key.pub]);
269  	ASSERT_EQ (send-&gt;hash (), last_vote1.hash);
270  	ASSERT_EQ (nano::vote::timestamp_min * 1, last_vote1.timestamp);
271  	nano::unique_lock&lt;nano::mutex&gt; active_lock (node.active.mutex);
272  	node.inactive_vote_cache.vote (send-&gt;hash (), vote1);
273  	auto cache = node.inactive_vote_cache.find (send-&gt;hash ());
274  	ASSERT_TRUE (cache);
275  	ASSERT_EQ (1, cache-&gt;voters.size ());
276  	cache-&gt;fill (election);
277  	ASSERT_EQ (2, election-&gt;votes ().size ());
278  	auto last_vote2 (election-&gt;votes ()[key.pub]);
279  	ASSERT_EQ (last_vote1.hash, last_vote2.hash);
280  	ASSERT_EQ (last_vote1.timestamp, last_vote2.timestamp);
281  	ASSERT_EQ (last_vote1.time, last_vote2.time);
282  	ASSERT_EQ (0, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
283  }
284  TEST (active_transactions, inactive_votes_cache_multiple_votes)
285  {
286  	nano::test::system system;
287  	nano::node_config node_config = system.default_config ();
288  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
289  	auto &amp; node = *system.add_node (node_config);
290  	nano::keypair key1;
291  	nano::block_builder builder;
292  	auto send1 = builder.send ()
293  				 .previous (nano::dev::genesis-&gt;hash ())
294  				 .destination (key1.pub)
295  				 .balance (nano::dev::constants.genesis_amount - 100 * nano::Gxrb_ratio)
296  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
297  				 .work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
298  				 .build_shared ();
299  	auto send2 = builder.send ()
300  				 .previous (send1-&gt;hash ())
301  				 .destination (key1.pub)
302  				 .balance (100 * nano::Gxrb_ratio)
303  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
304  				 .work (*system.work.generate (send1-&gt;hash ()))
305  				 .build_shared ();
306  	auto open = builder.state ()
307  				.account (key1.pub)
308  				.previous (0)
309  				.representative (key1.pub)
310  				.balance (100 * nano::Gxrb_ratio)
311  				.link (send1-&gt;hash ())
312  				.sign (key1.prv, key1.pub)
313  				.work (*system.work.generate (key1.pub))
314  				.build_shared ();
315  	ASSERT_TRUE (nano::test::process (node, { send1, send2, open }));
316  	ASSERT_TIMELY (5s, nano::test::exists (node, { send1, send2, open }));
317  	auto vote1 (std::make_shared&lt;nano::vote&gt; (key1.pub, key1.prv, 0, 0, std::vector&lt;nano::block_hash&gt; (1, send1-&gt;hash ())));
318  	node.vote_processor.vote (vote1, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
319  	auto vote2 (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector&lt;nano::block_hash&gt; (1, send1-&gt;hash ())));
320  	node.vote_processor.vote (vote2, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
321  	ASSERT_TIMELY (5s, node.inactive_vote_cache.find (send1-&gt;hash ()));
322  	ASSERT_TIMELY (5s, node.inactive_vote_cache.find (send1-&gt;hash ())-&gt;voters.size () == 2);
323  	ASSERT_EQ (1, node.inactive_vote_cache.cache_size ());
324  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
325  	std::shared_ptr&lt;nano::election&gt; election;
326  	ASSERT_TIMELY (5s, election = node.active.election (send1-&gt;qualified_root ()));
327  	ASSERT_EQ (3, election-&gt;votes ().size ()); 
328  	ASSERT_EQ (2, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
329  }
330  TEST (active_transactions, inactive_votes_cache_election_start)
331  {
332  	nano::test::system system;
333  	nano::node_config node_config = system.default_config ();
334  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
335  	node_config.optimistic_scheduler.enabled = false;
336  	auto &amp; node = *system.add_node (node_config);
337  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
338  	nano::keypair key1, key2;
339  	nano::send_block_builder send_block_builder;
340  	nano::state_block_builder state_block_builder;
341  	auto amount = ((node.online_reps.trended () / 100) * node.config.election_hint_weight_percent) / 2 + 1000 * nano::Gxrb_ratio;
342  	auto send1 = send_block_builder.make_block ()
343  				 .previous (latest)
344  				 .destination (key1.pub)
345  				 .balance (nano::dev::constants.genesis_amount - amount)
346  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
347  				 .work (*system.work.generate (latest))
348  				 .build_shared ();
349  	auto send2 = send_block_builder.make_block ()
350  				 .previous (send1-&gt;hash ())
351  				 .destination (key2.pub)
352  				 .balance (nano::dev::constants.genesis_amount - 2 * amount)
353  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
354  				 .work (*system.work.generate (send1-&gt;hash ()))
355  				 .build_shared ();
356  	auto open1 = state_block_builder.make_block ()
357  				 .account (key1.pub)
358  				 .previous (0)
359  				 .representative (key1.pub)
360  				 .balance (amount)
361  				 .link (send1-&gt;hash ())
362  				 .sign (key1.prv, key1.pub)
363  				 .work (*system.work.generate (key1.pub))
364  				 .build_shared ();
365  	auto open2 = state_block_builder.make_block ()
366  				 .account (key2.pub)
367  				 .previous (0)
368  				 .representative (key2.pub)
369  				 .balance (amount)
370  				 .link (send2-&gt;hash ())
371  				 .sign (key2.prv, key2.pub)
372  				 .work (*system.work.generate (key2.pub))
373  				 .build_shared ();
374  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
375  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
376  	ASSERT_EQ (nano::process_result::progress, node.process (*open1).code);
377  	ASSERT_EQ (nano::process_result::progress, node.process (*open2).code);
378  	ASSERT_TIMELY (5s, 5 == node.ledger.cache.block_count);
379  	ASSERT_TRUE (node.active.empty ());
380  	ASSERT_EQ (1, node.ledger.cache.cemented_count);
381  	auto send3 = send_block_builder.make_block ()
382  				 .previous (send2-&gt;hash ())
383  				 .destination (nano::keypair ().pub)
384  				 .balance (send2-&gt;balance ().number () - 1)
385  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
386  				 .work (*system.work.generate (send2-&gt;hash ()))
387  				 .build_shared ();
388  	auto send4 = send_block_builder.make_block ()
389  				 .previous (send3-&gt;hash ())
390  				 .destination (nano::keypair ().pub)
391  				 .balance (send3-&gt;balance ().number () - 1)
392  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
393  				 .work (*system.work.generate (send3-&gt;hash ()))
394  				 .build_shared ();
395  	std::vector&lt;nano::block_hash&gt; hashes{ open1-&gt;hash (), open2-&gt;hash (), send4-&gt;hash () };
396  	auto vote1 (std::make_shared&lt;nano::vote&gt; (key1.pub, key1.prv, 0, 0, hashes));
397  	node.vote_processor.vote (vote1, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
398  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 3);
399  	ASSERT_TRUE (node.active.empty ());
400  	ASSERT_EQ (1, node.ledger.cache.cemented_count);
401  	auto vote2 (std::make_shared&lt;nano::vote&gt; (key2.pub, key2.prv, 0, 0, hashes));
402  	node.vote_processor.vote (vote2, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
403  	ASSERT_TIMELY (5s, 2 == node.active.size ());
404  	auto vote0 (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, hashes)); 
405  	node.vote_processor.vote (vote0, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
406  	ASSERT_TIMELY (5s, node.active.empty ());
407  	ASSERT_TIMELY (5s, 5 == node.ledger.cache.cemented_count);
408  	ASSERT_TRUE (node.active.empty ());
409  	auto send4_cache (node.inactive_vote_cache.find (send4-&gt;hash ()));
410  	ASSERT_TRUE (send4_cache);
411  	ASSERT_EQ (3, send4_cache-&gt;voters.size ());
412  	node.process_active (send3);
413  	ASSERT_FALSE (node.block_confirmed_or_being_confirmed (send3-&gt;hash ()));
414  	ASSERT_FALSE (node.ledger.dependents_confirmed (node.store.tx_begin_read (), *send4));
415  	node.process_active (send4);
416  	ASSERT_TIMELY (5s, 7 == node.ledger.cache.cemented_count);
417  }
418  namespace nano
419  {
420  TEST (active_transactions, vote_replays)
421  {
422  	nano::test::system system;
423  	nano::node_config node_config = system.default_config ();
424  	node_config.enable_voting = false;
425  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
426  	auto &amp; node = *system.add_node (node_config);
427  	nano::keypair key;
428  	nano::state_block_builder builder;
429  	auto send1 = builder.make_block ()
430  				 .account (nano::dev::genesis_key.pub)
431  				 .previous (nano::dev::genesis-&gt;hash ())
432  				 .representative (nano::dev::genesis_key.pub)
433  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
434  				 .link (key.pub)
435  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
436  				 .work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
437  				 .build_shared ();
438  	ASSERT_NE (nullptr, send1);
439  	auto open1 = builder.make_block ()
440  				 .account (key.pub)
441  				 .previous (0)
442  				 .representative (key.pub)
443  				 .balance (nano::Gxrb_ratio)
444  				 .link (send1-&gt;hash ())
445  				 .sign (key.prv, key.pub)
446  				 .work (*system.work.generate (key.pub))
447  				 .build_shared ();
448  	ASSERT_NE (nullptr, open1);
449  	node.process_active (send1);
450  	node.process_active (open1);
451  	nano::test::start_elections (system, node, { send1, open1 });
452  	ASSERT_EQ (2, node.active.size ());
453  	auto vote_send1 (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt;{ send1-&gt;hash () }));
454  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote_send1));
455  	ASSERT_EQ (2, node.active.size ());
456  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_send1));
457  	ASSERT_TIMELY (3s, node.active.size () == 1);
458  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_send1));
459  	auto vote_open1 (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt;{ open1-&gt;hash () }));
460  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote_open1));
461  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_open1));
462  	ASSERT_TIMELY (3s, node.active.empty ());
463  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_open1));
464  	ASSERT_EQ (nano::Gxrb_ratio, node.ledger.weight (key.pub));
465  	auto send2 = builder.make_block ()
466  				 .account (key.pub)
467  				 .previous (open1-&gt;hash ())
468  				 .representative (key.pub)
469  				 .balance (nano::Gxrb_ratio - 1)
470  				 .link (key.pub)
471  				 .sign (key.prv, key.pub)
472  				 .work (*system.work.generate (open1-&gt;hash ()))
473  				 .build_shared ();
474  	ASSERT_NE (nullptr, send2);
475  	node.process_active (send2);
476  	nano::test::start_elections (system, node, { send2 });
477  	ASSERT_EQ (1, node.active.size ());
478  	auto vote1_send2 (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt;{ send2-&gt;hash () }));
479  	auto vote2_send2 (std::make_shared&lt;nano::vote&gt; (key.pub, key.prv, 0, 0, std::vector&lt;nano::block_hash&gt;{ send2-&gt;hash () }));
480  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote2_send2));
481  	ASSERT_EQ (1, node.active.size ());
482  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
483  	ASSERT_EQ (1, node.active.size ());
484  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote1_send2));
485  	ASSERT_EQ (1, node.active.size ());
486  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote1_send2));
487  	ASSERT_TIMELY (3s, node.active.empty ());
488  	ASSERT_EQ (0, node.active.size ());
489  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote1_send2));
490  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
491  	{
492  		nano::lock_guard&lt;nano::mutex&gt; guard (node.active.mutex);
493  		node.active.recently_confirmed.clear ();
494  	}
495  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_send1));
496  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_open1));
497  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote1_send2));
498  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote2_send2));
499  }
500  }
501  TEST (active_transactions, dropped_cleanup)
502  {
503  	nano::test::system system;
504  	nano::node_flags flags;
505  	flags.disable_request_loop = true;
506  	auto &amp; node (*system.add_node (flags));
507  	auto chain = nano::test::setup_chain (system, node, 1, nano::dev::genesis_key, false);
508  	auto hash = chain[0]-&gt;hash ();
509  	std::vector&lt;uint8_t&gt; block_bytes;
510  	{
511  		nano::vectorstream stream (block_bytes);
512  		chain[0]-&gt;serialize (stream);
513  	}
514  	ASSERT_FALSE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
515  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
516  	auto election = nano::test::start_election (system, node, hash);
517  	ASSERT_NE (nullptr, election);
518  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
519  	ASSERT_TRUE (node.active.active (hash));
520  	ASSERT_FALSE (election-&gt;confirmed ());
521  	node.active.erase (*chain[0]);
522  	ASSERT_FALSE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
523  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
524  	ASSERT_FALSE (node.active.active (hash));
525  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
526  	election = nano::test::start_election (system, node, hash);
527  	ASSERT_NE (nullptr, election);
528  	election-&gt;force_confirm ();
529  	ASSERT_TIMELY (5s, election-&gt;confirmed ());
530  	node.active.erase (*chain[0]);
531  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
532  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
533  	ASSERT_FALSE (node.active.active (hash));
534  }
535  TEST (active_transactions, republish_winner)
536  {
537  	nano::test::system system;
538  	nano::node_config node_config = system.default_config ();
539  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
540  	auto &amp; node1 = *system.add_node (node_config);
541  	node_config.peering_port = system.get_available_port ();
542  	auto &amp; node2 = *system.add_node (node_config);
543  	nano::keypair key;
544  	nano::state_block_builder builder;
545  	auto send1 = builder.make_block ()
546  				 .account (nano::dev::genesis_key.pub)
547  				 .previous (nano::dev::genesis-&gt;hash ())
548  				 .representative (nano::dev::genesis_key.pub)
549  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
550  				 .link (key.pub)
551  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  				 .work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
553  				 .build_shared ();
554  	node1.process_active (send1);
555  	node1.block_processor.flush ();
556  	ASSERT_TIMELY (3s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) == 1);
557  	for (auto i (0); i &lt; 5; i++)
558  	{
559  		auto fork = builder.make_block ()
560  					.account (nano::dev::genesis_key.pub)
561  					.previous (nano::dev::genesis-&gt;hash ())
562  					.representative (nano::dev::genesis_key.pub)
563  					.balance (nano::dev::constants.genesis_amount - 1 - i)
564  					.link (key.pub)
565  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
566  					.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
567  					.build_shared ();
568  		node1.process_active (fork);
569  	}
570  	node1.block_processor.flush ();
571  	ASSERT_TIMELY (3s, !node1.active.empty ());
572  	ASSERT_EQ (1, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in));
573  	auto fork = builder.make_block ()
574  				.account (nano::dev::genesis_key.pub)
575  				.previous (nano::dev::genesis-&gt;hash ())
576  				.representative (nano::dev::genesis_key.pub)
577  				.balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
578  				.link (key.pub)
579  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
580  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
581  				.build_shared ();
582  	node1.process_active (fork);
583  	node1.block_processor.flush ();
584  	auto election = node1.active.election (fork-&gt;qualified_root ());
585  	ASSERT_NE (nullptr, election);
586  	auto vote = std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt;{ fork-&gt;hash () });
587  	node1.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node1, node1));
588  	node1.vote_processor.flush ();
589  	node1.block_processor.flush ();
590  	ASSERT_TIMELY (5s, election-&gt;confirmed ());
591  	ASSERT_EQ (fork-&gt;hash (), election-&gt;status.winner-&gt;hash ());
592  	ASSERT_TIMELY (5s, node2.block_confirmed (fork-&gt;hash ()));
593  }
594  TEST (active_transactions, fork_filter_cleanup)
595  {
596  	nano::test::system system{};
597  	nano::node_config node_config = system.default_config ();
598  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
599  	auto &amp; node1 = *system.add_node (node_config);
600  	nano::keypair key{};
601  	nano::state_block_builder builder{};
602  	auto const latest_hash = nano::dev::genesis-&gt;hash ();
603  	auto send1 = builder.make_block ()
604  				 .previous (latest_hash)
605  				 .account (nano::dev::genesis_key.pub)
606  				 .representative (nano::dev::genesis_key.pub)
607  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
608  				 .link (key.pub)
609  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
610  				 .work (*system.work.generate (latest_hash))
611  				 .build_shared ();
612  	std::vector&lt;uint8_t&gt; send_block_bytes{};
613  	{
614  		nano::vectorstream stream{ send_block_bytes };
615  		send1-&gt;serialize (stream);
616  	}
617  	for (auto i = 0; i &lt; 10; ++i)
618  	{
619  		auto fork = builder.make_block ()
620  					.previous (latest_hash)
621  					.account (nano::dev::genesis_key.pub)
622  					.representative (nano::dev::genesis_key.pub)
623  					.balance (nano::dev::constants.genesis_amount - 1 - i)
624  					.link (key.pub)
625  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
626  					.work (*system.work.generate (latest_hash))
627  					.build_shared ();
628  		node1.process_active (fork);
629  		ASSERT_TIMELY (5s, node1.active.election (fork-&gt;qualified_root ()) != nullptr);
630  	}
631  	std::shared_ptr&lt;nano::election&gt; election{};
632  	ASSERT_TIMELY (5s, (election = node1.active.election (send1-&gt;qualified_root ())) != nullptr);
633  	ASSERT_TIMELY (5s, election-&gt;blocks ().size () == 10);
634  	ASSERT_EQ (1, node1.active.size ());
635  	node_config.peering_port = system.get_available_port ();
636  	auto &amp; node2 = *system.add_node (node_config);
637  	node2.process_active (send1);
638  	ASSERT_TIMELY (5s, node2.active.election (send1-&gt;qualified_root ()) != nullptr);
639  	ASSERT_TIMELY (5s, node2.ledger.cache.block_count == 2);
640  	ASSERT_TIMELY (5s, node1.ledger.cache.block_count == 2);
641  	ASSERT_TIMELY (5s, node1.network.publish_filter.apply (send_block_bytes.data (), send_block_bytes.size ()));
642  }
643  TEST (active_transactions, fork_replacement_tally)
644  {
645  	nano::test::system system;
646  	nano::node_config node_config = system.default_config ();
647  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
648  	auto &amp; node1 (*system.add_node (node_config));
649  	size_t const reps_count = 20;
650  	size_t const max_blocks = 10;
651  	std::vector&lt;nano::keypair&gt; keys (reps_count);
652  	auto latest (nano::dev::genesis-&gt;hash ());
653  	auto balance (nano::dev::constants.genesis_amount);
654  	auto amount (node1.minimum_principal_weight ());
655  	nano::state_block_builder builder;
656  	for (auto i (0); i &lt; reps_count; i++)
657  	{
658  		balance -= amount + i;
659  		auto send = builder.make_block ()
660  					.account (nano::dev::genesis_key.pub)
661  					.previous (latest)
662  					.representative (nano::dev::genesis_key.pub)
663  					.balance (balance)
664  					.link (keys[i].pub)
665  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
666  					.work (*system.work.generate (latest))
667  					.build_shared ();
668  		node1.process_active (send);
669  		latest = send-&gt;hash ();
670  		auto open = builder.make_block ()
671  					.account (keys[i].pub)
672  					.previous (0)
673  					.representative (keys[i].pub)
674  					.balance (amount + i)
675  					.link (send-&gt;hash ())
676  					.sign (keys[i].prv, keys[i].pub)
677  					.work (*system.work.generate (keys[i].pub))
678  					.build_shared ();
679  		node1.process_active (open);
680  		auto vote (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt;{ send-&gt;hash (), open-&gt;hash () }));
681  		node1.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node1, node1));
682  	}
683  	ASSERT_TIMELY (5s, node1.ledger.cache.cemented_count == 1 + 2 * reps_count);
684  	nano::keypair key;
685  	auto send_last = builder.make_block ()
686  					 .account (nano::dev::genesis_key.pub)
687  					 .previous (latest)
688  					 .representative (nano::dev::genesis_key.pub)
689  					 .balance (balance - 2 * nano::Gxrb_ratio)
690  					 .link (key.pub)
691  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
692  					 .work (*system.work.generate (latest))
693  					 .build_shared ();
694  	for (auto i (0); i &lt; reps_count; i++)
695  	{
696  		auto fork = builder.make_block ()
697  					.account (nano::dev::genesis_key.pub)
698  					.previous (latest)
699  					.representative (nano::dev::genesis_key.pub)
700  					.balance (balance - nano::Gxrb_ratio - i)
701  					.link (key.pub)
702  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
703  					.work (*system.work.generate (latest))
704  					.build_shared ();
705  		node1.process_active (fork);
706  	}
707  	ASSERT_TIMELY (5s, !node1.active.empty ());
708  	auto election = node1.active.election (send_last-&gt;qualified_root ());
709  	ASSERT_NE (nullptr, election);
710  	ASSERT_TIMELY (5s, max_blocks == election-&gt;blocks ().size ());
711  	for (auto i (0); i &lt; reps_count; i++)
712  	{
713  		auto fork = builder.make_block ()
714  					.account (nano::dev::genesis_key.pub)
715  					.previous (latest)
716  					.representative (nano::dev::genesis_key.pub)
717  					.balance (balance - 1 - i)
718  					.link (key.pub)
719  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
720  					.work (*system.work.generate (latest))
721  					.build_shared ();
722  		auto vote (std::make_shared&lt;nano::vote&gt; (keys[i].pub, keys[i].prv, 0, 0, std::vector&lt;nano::block_hash&gt;{ fork-&gt;hash () }));
723  		node1.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node1, node1));
724  		node1.vote_processor.flush ();
725  		node1.process_active (fork);
726  	}
727  	auto count_rep_votes_in_election = [&amp;max_blocks, &amp;reps_count, &amp;election, &amp;keys] () {
728  		auto votes_l = election-&gt;votes ();
729  		if (max_blocks != votes_l.size ())
730  		{
731  			return -1;
732  		}
733  		int vote_count = 0;
734  		for (auto i = 0; i &lt; reps_count; i++)
735  		{
736  			if (votes_l.find (keys[i].pub) != votes_l.end ())
737  			{
738  				vote_count++;
739  			}
740  		}
741  		return vote_count;
742  	};
743  	ASSERT_TIMELY (10s, count_rep_votes_in_election () == 9);
744  	ASSERT_EQ (max_blocks, election-&gt;blocks ().size ());
745  	node_config.peering_port = system.get_available_port ();
746  	auto &amp; node2 (*system.add_node (node_config));
747  	node1.network.publish_filter.clear ();
748  	node2.network.flood_block (send_last);
749  	ASSERT_TIMELY (3s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) &gt; 0);
750  	node1.block_processor.flush ();
751  	system.delay_ms (50ms);
752  	auto blocks1 (election-&gt;blocks ());
753  	ASSERT_EQ (max_blocks, blocks1.size ());
754  	ASSERT_FALSE (blocks1.find (send_last-&gt;hash ()) != blocks1.end ());
755  	auto vote (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector&lt;nano::block_hash&gt;{ send_last-&gt;hash () }));
756  	node1.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node1, node1));
757  	node1.vote_processor.flush ();
758  	ASSERT_TIMELY (5s, node1.inactive_vote_cache.find (send_last-&gt;hash ()));
759  	ASSERT_TIMELY (5s, 1 == node1.inactive_vote_cache.find (send_last-&gt;hash ())-&gt;size ());
760  	node1.network.publish_filter.clear ();
761  	node2.network.flood_block (send_last);
762  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) &gt; 1);
763  	auto find_send_last_block = [&amp;election, &amp;send_last] () {
764  		auto blocks2 = election-&gt;blocks ();
765  		return blocks2.find (send_last-&gt;hash ()) != blocks2.end ();
766  	};
767  	ASSERT_TIMELY (5s, find_send_last_block ())
768  	ASSERT_EQ (max_blocks, election-&gt;blocks ().size ());
769  	ASSERT_TIMELY (5s, count_rep_votes_in_election () == 8);
770  	auto votes2 (election-&gt;votes ());
771  	ASSERT_TRUE (votes2.find (nano::dev::genesis_key.pub) != votes2.end ());
772  }
773  namespace nano
774  {
775  TEST (active_transactions, confirmation_consistency)
776  {
777  	nano::test::system system;
778  	nano::node_config node_config = system.default_config ();
779  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
780  	auto &amp; node = *system.add_node (node_config);
781  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
782  	for (unsigned i = 0; i &lt; 10; ++i)
783  	{
784  		auto block (system.wallet (0)-&gt;send_action (nano::dev::genesis_key.pub, nano::public_key (), node.config.receive_minimum.number ()));
785  		ASSERT_NE (nullptr, block);
786  		system.deadline_set (5s);
787  		while (!node.ledger.block_confirmed (node.store.tx_begin_read (), block-&gt;hash ()))
788  		{
789  			node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
790  			ASSERT_NO_ERROR (system.poll (5ms));
791  		}
792  		ASSERT_NO_ERROR (system.poll_until_true (1s, [&amp;node, &amp;block, i] {
793  			nano::lock_guard&lt;nano::mutex&gt; guard (node.active.mutex);
794  			EXPECT_EQ (i + 1, node.active.recently_confirmed.size ());
795  			EXPECT_EQ (block-&gt;qualified_root (), node.active.recently_confirmed.back ().first);
796  			return i + 1 == node.active.recently_cemented.size (); 
797  		}));
798  	}
799  }
800  }
801  TEST (active_transactions, DISABLED_confirm_new)
802  {
803  	nano::test::system system (1);
804  	auto &amp; node1 = *system.nodes[0];
805  	auto send = nano::send_block_builder ()
806  				.previous (nano::dev::genesis-&gt;hash ())
807  				.destination (nano::public_key ())
808  				.balance (nano::dev::constants.genesis_amount - 100)
809  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
810  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
811  				.build_shared ();
812  	node1.process_active (send);
813  	node1.block_processor.flush ();
814  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
815  	auto &amp; node2 = *system.add_node ();
816  	system.wallet (1)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
817  	ASSERT_TIMELY (5s, node2.block (send-&gt;hash ()));
818  	ASSERT_TIMELY (5s, node1.ledger.cache.cemented_count == 2 &amp;&amp; node2.ledger.cache.cemented_count == 2);
819  }
820  TEST (active_transactions, conflicting_block_vote_existing_election)
821  {
822  	nano::test::system system;
823  	nano::node_flags node_flags;
824  	node_flags.disable_request_loop = true;
825  	auto &amp; node = *system.add_node (node_flags);
826  	nano::keypair key;
827  	nano::state_block_builder builder;
828  	auto send = builder.make_block ()
829  				.account (nano::dev::genesis_key.pub)
830  				.previous (nano::dev::genesis-&gt;hash ())
831  				.representative (nano::dev::genesis_key.pub)
832  				.balance (nano::dev::constants.genesis_amount - 100)
833  				.link (key.pub)
834  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
835  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
836  				.build_shared ();
837  	auto fork = builder.make_block ()
838  				.account (nano::dev::genesis_key.pub)
839  				.previous (nano::dev::genesis-&gt;hash ())
840  				.representative (nano::dev::genesis_key.pub)
841  				.balance (nano::dev::constants.genesis_amount - 200)
842  				.link (key.pub)
843  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
844  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
845  				.build_shared ();
846  	auto vote_fork (std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector&lt;nano::block_hash&gt;{ fork-&gt;hash () }));
847  	ASSERT_EQ (nano::process_result::progress, node.process_local (send).value ().code);
848  	ASSERT_TIMELY_EQ (5s, 1, node.active.size ());
849  	node.active.vote (vote_fork);
850  	ASSERT_EQ (nano::process_result::fork, node.process_local (fork).value ().code);
851  	auto election (node.active.election (fork-&gt;qualified_root ()));
852  	ASSERT_NE (nullptr, election);
853  	ASSERT_TIMELY (3s, election-&gt;confirmed ());
854  }
855  TEST (active_transactions, activate_account_chain)
856  {
857  	nano::test::system system;
858  	nano::node_flags flags;
859  	nano::node_config config = system.default_config ();
860  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
861  	auto &amp; node = *system.add_node (config, flags);
862  	nano::keypair key;
863  	nano::state_block_builder builder;
864  	auto send = builder.make_block ()
865  				.account (nano::dev::genesis_key.pub)
866  				.previous (nano::dev::genesis-&gt;hash ())
867  				.representative (nano::dev::genesis_key.pub)
868  				.link (nano::dev::genesis_key.pub)
869  				.balance (nano::dev::constants.genesis_amount - 1)
870  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
871  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
872  				.build ();
873  	auto send2 = builder.make_block ()
874  				 .account (nano::dev::genesis_key.pub)
875  				 .previous (send-&gt;hash ())
876  				 .representative (nano::dev::genesis_key.pub)
877  				 .link (key.pub)
878  				 .balance (nano::dev::constants.genesis_amount - 2)
879  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
880  				 .work (*system.work.generate (send-&gt;hash ()))
881  				 .build ();
882  	auto send3 = builder.make_block ()
883  				 .account (nano::dev::genesis_key.pub)
884  				 .previous (send2-&gt;hash ())
885  				 .representative (nano::dev::genesis_key.pub)
886  				 .link (key.pub)
887  				 .balance (nano::dev::constants.genesis_amount - 3)
888  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
889  				 .work (*system.work.generate (send2-&gt;hash ()))
890  				 .build ();
891  	auto open = builder.make_block ()
892  				.account (key.pub)
893  				.previous (0)
894  				.representative (key.pub)
895  				.link (send2-&gt;hash ())
896  				.balance (1)
897  				.sign (key.prv, key.pub)
898  				.work (*system.work.generate (key.pub))
899  				.build ();
900  	auto receive = builder.make_block ()
901  				   .account (key.pub)
902  				   .previous (open-&gt;hash ())
903  				   .representative (key.pub)
904  				   .link (send3-&gt;hash ())
905  				   .balance (2)
906  				   .sign (key.prv, key.pub)
907  				   .work (*system.work.generate (open-&gt;hash ()))
908  				   .build ();
909  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
910  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
911  	ASSERT_EQ (nano::process_result::progress, node.process (*send3).code);
912  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
913  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
914  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
915  	ASSERT_TIMELY (5s, node.active.election (send-&gt;qualified_root ()));
916  	auto election1 = node.active.election (send-&gt;qualified_root ());
917  	ASSERT_EQ (1, node.active.size ());
918  	ASSERT_EQ (1, election1-&gt;blocks ().count (send-&gt;hash ()));
919  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
920  	auto election2 = node.active.election (send-&gt;qualified_root ());
921  	ASSERT_EQ (election2, election1);
922  	election1-&gt;force_confirm ();
923  	ASSERT_TIMELY (3s, node.block_confirmed (send-&gt;hash ()));
924  	ASSERT_TIMELY (3s, node.active.active (send2-&gt;qualified_root ()));
925  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
926  	auto election3 = node.active.election (send2-&gt;qualified_root ());
927  	ASSERT_NE (nullptr, election3);
928  	ASSERT_EQ (1, election3-&gt;blocks ().count (send2-&gt;hash ()));
929  	election3-&gt;force_confirm ();
930  	ASSERT_TIMELY (3s, node.block_confirmed (send2-&gt;hash ()));
931  	ASSERT_TIMELY (3s, node.active.active (open-&gt;qualified_root ()));
932  	ASSERT_TIMELY (3s, node.active.active (send3-&gt;qualified_root ()));
933  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
934  	auto election4 = node.active.election (send3-&gt;qualified_root ());
935  	ASSERT_NE (nullptr, election4);
936  	ASSERT_EQ (1, election4-&gt;blocks ().count (send3-&gt;hash ()));
937  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
938  	auto election5 = node.active.election (open-&gt;qualified_root ());
939  	ASSERT_NE (nullptr, election5);
940  	ASSERT_EQ (1, election5-&gt;blocks ().count (open-&gt;hash ()));
941  	election5-&gt;force_confirm ();
942  	ASSERT_TIMELY (3s, node.block_confirmed (open-&gt;hash ()));
943  	std::this_thread::sleep_for (200ms);
944  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
945  	election4-&gt;force_confirm ();
946  	ASSERT_TIMELY (3s, node.block_confirmed (send3-&gt;hash ()));
947  	ASSERT_TIMELY (3s, node.active.active (receive-&gt;qualified_root ()));
948  }
949  TEST (active_transactions, activate_inactive)
950  {
951  	nano::test::system system;
952  	nano::node_flags flags;
953  	nano::node_config config = system.default_config ();
954  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
955  	auto &amp; node = *system.add_node (config, flags);
956  	nano::keypair key;
957  	nano::state_block_builder builder;
958  	auto send = builder.make_block ()
959  				.account (nano::dev::genesis_key.pub)
960  				.previous (nano::dev::genesis-&gt;hash ())
961  				.representative (nano::dev::genesis_key.pub)
962  				.link (key.pub)
963  				.balance (nano::dev::constants.genesis_amount - 1)
964  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
965  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
966  				.build_shared ();
967  	auto send2 = builder.make_block ()
968  				 .account (nano::dev::genesis_key.pub)
969  				 .previous (send-&gt;hash ())
970  				 .representative (nano::dev::genesis_key.pub)
971  				 .link (nano::keypair ().pub)
972  				 .balance (nano::dev::constants.genesis_amount - 2)
973  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
974  				 .work (*system.work.generate (send-&gt;hash ()))
975  				 .build_shared ();
976  	auto open = builder.make_block ()
977  				.account (key.pub)
978  				.previous (0)
979  				.representative (key.pub)
980  				.link (send-&gt;hash ())
981  				.balance (1)
982  				.sign (key.prv, key.pub)
983  				.work (*system.work.generate (key.pub))
984  				.build_shared ();
985  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
986  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
987  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
988  	auto election = nano::test::start_election (system, node, send2-&gt;hash ());
989  	ASSERT_NE (nullptr, election);
990  	election-&gt;force_confirm ();
991  	ASSERT_TIMELY (5s, !node.confirmation_height_processor.is_processing_added_block (send2-&gt;hash ()));
992  	ASSERT_TIMELY (5s, node.block_confirmed (send2-&gt;hash ()));
993  	ASSERT_TIMELY (5s, node.block_confirmed (send-&gt;hash ()));
994  	ASSERT_EQ (1, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out));
995  	ASSERT_EQ (1, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::active_quorum, nano::stat::dir::out));
996  	ASSERT_EQ (0, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::active_conf_height, nano::stat::dir::out));
997  	ASSERT_FALSE (node.active.active (open-&gt;qualified_root ()) || node.block_confirmed_or_being_confirmed (open-&gt;hash ()));
998  }
999  TEST (active_transactions, list_active)
1000  {
1001  	nano::test::system system (1);
1002  	auto &amp; node = *system.nodes[0];
1003  	nano::keypair key;
1004  	nano::state_block_builder builder;
1005  	auto send = builder.make_block ()
1006  				.account (nano::dev::genesis_key.pub)
1007  				.previous (nano::dev::genesis-&gt;hash ())
1008  				.representative (nano::dev::genesis_key.pub)
1009  				.link (nano::dev::genesis_key.pub)
1010  				.balance (nano::dev::constants.genesis_amount - 1)
1011  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1012  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
1013  				.build_shared ();
1014  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1015  	auto send2 = builder.make_block ()
1016  				 .account (nano::dev::genesis_key.pub)
1017  				 .previous (send-&gt;hash ())
1018  				 .representative (nano::dev::genesis_key.pub)
1019  				 .link (key.pub)
1020  				 .balance (nano::dev::constants.genesis_amount - 2)
1021  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1022  				 .work (*system.work.generate (send-&gt;hash ()))
1023  				 .build_shared ();
1024  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
1025  	auto open = builder.make_block ()
1026  				.account (key.pub)
1027  				.previous (0)
1028  				.representative (key.pub)
1029  				.link (send2-&gt;hash ())
1030  				.balance (1)
1031  				.sign (key.prv, key.pub)
1032  				.work (*system.work.generate (key.pub))
1033  				.build_shared ();
1034  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
1035  	nano::test::start_elections (system, node, { send, send2, open });
1036  	ASSERT_EQ (3, node.active.size ());
1037  	ASSERT_EQ (1, node.active.list_active (1).size ());
1038  	ASSERT_EQ (2, node.active.list_active (2).size ());
1039  	ASSERT_EQ (3, node.active.list_active (3).size ());
1040  	ASSERT_EQ (3, node.active.list_active (4).size ());
1041  	ASSERT_EQ (3, node.active.list_active (99999).size ());
1042  	ASSERT_EQ (3, node.active.list_active ().size ());
1043  	auto active = node.active.list_active ();
1044  }
1045  TEST (active_transactions, vacancy)
1046  {
1047  	std::atomic&lt;bool&gt; updated = false;
1048  	{
1049  		nano::test::system system;
1050  		nano::node_config config = system.default_config ();
1051  		config.active_elections_size = 1;
1052  		auto &amp; node = *system.add_node (config);
1053  		nano::state_block_builder builder;
1054  		auto send = builder.make_block ()
1055  					.account (nano::dev::genesis_key.pub)
1056  					.previous (nano::dev::genesis-&gt;hash ())
1057  					.representative (nano::dev::genesis_key.pub)
1058  					.link (nano::dev::genesis_key.pub)
1059  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1060  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1061  					.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
1062  					.build_shared ();
1063  		node.active.vacancy_update = [&amp;updated] () { updated = true; };
1064  		ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1065  		ASSERT_EQ (1, node.active.vacancy ());
1066  		ASSERT_EQ (0, node.active.size ());
1067  		node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
1068  		ASSERT_TIMELY (1s, updated);
1069  		updated = false;
1070  		ASSERT_EQ (0, node.active.vacancy ());
1071  		ASSERT_EQ (1, node.active.size ());
1072  		auto election1 = node.active.election (send-&gt;qualified_root ());
1073  		ASSERT_NE (nullptr, election1);
1074  		election1-&gt;force_confirm ();
1075  		ASSERT_TIMELY (1s, updated);
1076  		ASSERT_EQ (1, node.active.vacancy ());
1077  		ASSERT_EQ (0, node.active.size ());
1078  	}
1079  }
1080  TEST (active_transactions, fifo)
1081  {
1082  	nano::test::system system{};
1083  	nano::node_config config = system.default_config ();
1084  	config.active_elections_size = 1;
1085  	auto &amp; node = *system.add_node (config);
1086  	auto latest_hash = nano::dev::genesis-&gt;hash ();
1087  	nano::keypair key0{};
1088  	nano::state_block_builder builder{};
1089  	auto send1 = builder.make_block ()
1090  				 .previous (latest_hash)
1091  				 .account (nano::dev::genesis_key.pub)
1092  				 .representative (nano::dev::genesis_key.pub)
1093  				 .link (key0.pub)
1094  				 .balance (nano::dev::constants.genesis_amount - 1)
1095  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1096  				 .work (*system.work.generate (latest_hash))
1097  				 .build_shared ();
1098  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
1099  	node.process_confirmed (nano::election_status{ send1 });
1100  	ASSERT_TIMELY (5s, node.block_confirmed (send1-&gt;hash ()));
1101  	nano::keypair key1{};
1102  	latest_hash = send1-&gt;hash ();
1103  	auto send2 = builder.make_block ()
1104  				 .previous (latest_hash)
1105  				 .account (nano::dev::genesis_key.pub)
1106  				 .representative (nano::dev::genesis_key.pub)
1107  				 .link (key1.pub)
1108  				 .balance (nano::dev::constants.genesis_amount - 2)
1109  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1110  				 .work (*system.work.generate (latest_hash))
1111  				 .build_shared ();
1112  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
1113  	node.process_confirmed (nano::election_status{ send2 });
1114  	ASSERT_TIMELY (5s, node.block_confirmed (send2-&gt;hash ()));
1115  	auto receive1 = builder.make_block ()
1116  					.previous (0)
1117  					.account (key0.pub)
1118  					.representative (nano::dev::genesis_key.pub)
1119  					.link (send1-&gt;hash ())
1120  					.balance (1)
1121  					.sign (key0.prv, key0.pub)
1122  					.work (*system.work.generate (key0.pub))
1123  					.build_shared ();
1124  	ASSERT_EQ (nano::process_result::progress, node.process (*receive1).code);
1125  	auto receive2 = builder.make_block ()
1126  					.previous (0)
1127  					.account (key1.pub)
1128  					.representative (nano::dev::genesis_key.pub)
1129  					.link (send2-&gt;hash ())
1130  					.balance (1)
1131  					.sign (key1.prv, key1.pub)
1132  					.work (*system.work.generate (key1.pub))
1133  					.build_shared ();
1134  	ASSERT_EQ (nano::process_result::progress, node.process (*receive2).code);
1135  	node.scheduler.buckets.manual (receive1);
1136  	ASSERT_TIMELY (5s, node.active.election (receive1-&gt;qualified_root ()) != nullptr);
1137  	node.scheduler.buckets.manual (receive2);
1138  	ASSERT_TIMELY (5s, node.active.election (receive2-&gt;qualified_root ()) != nullptr);
1139  	ASSERT_TIMELY (5s, node.active.size () == 1);
1140  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
1141  	ASSERT_TIMELY (1s, node.active.election (receive2-&gt;qualified_root ()) != nullptr);
1142  }
1143  TEST (active_transactions, limit_vote_hinted_elections)
1144  {
1145  	nano::test::system system;
1146  	nano::node_config config = system.default_config ();
1147  	const int aec_limit = 10;
1148  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1149  	config.optimistic_scheduler.enabled = false;
1150  	config.active_elections_size = aec_limit;
1151  	config.active_elections_hinted_limit_percentage = 10; 
1152  	auto &amp; node = *system.add_node (config);
1153  	const auto amount = ((node.online_reps.trended () / 100) * node.config.election_hint_weight_percent) + 1000 * nano::Gxrb_ratio;
1154  	nano::keypair rep1 = nano::test::setup_rep (system, node, amount / 2);
1155  	nano::keypair rep2 = nano::test::setup_rep (system, node, amount / 2);
1156  	auto blocks = nano::test::setup_independent_blocks (system, node, 2);
1157  	auto open0 = blocks[0];
1158  	auto open1 = blocks[1];
1159  	WAIT (1s);
1160  	node.active.clear ();
1161  	ASSERT_TRUE (node.active.empty ());
1162  	auto vote1 = nano::test::make_vote (rep1, { open0, open1 });
1163  	node.vote_processor.vote (vote1, nano::test::fake_channel (node));
1164  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 2);
1165  	ASSERT_ALWAYS (1s, node.active.empty ());
1166  	ASSERT_FALSE (nano::test::confirmed (node, { open0, open1 }));
1167  	auto vote2 = nano::test::make_vote (rep2, { open0 });
1168  	node.vote_processor.vote (vote2, nano::test::fake_channel (node));
1169  	ASSERT_TIMELY (5s, node.active.size () == 1);
1170  	ASSERT_TIMELY (5s, nano::test::active (node, { open0 }));
1171  	auto vote3 = nano::test::make_vote (rep2, { open1 });
1172  	node.vote_processor.vote (vote3, nano::test::fake_channel (node));
1173  	ASSERT_NEVER (1s, nano::test::active (node, { open1 }));
1174  	ASSERT_EQ (node.active.size (), 1);
1175  	auto vote4 = nano::test::make_final_vote (nano::dev::genesis_key, { open0 });
1176  	node.vote_processor.vote (vote4, nano::test::fake_channel (node));
1177  	ASSERT_TIMELY (5s, nano::test::confirmed (node, { open0 }));
1178  	ASSERT_TIMELY (5s, nano::test::active (node, { open1 }));
1179  	ASSERT_EQ (0, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
1180  }
1181  TEST (active_transactions, allow_limited_overflow)
1182  {
1183  	nano::test::system system;
1184  	nano::node_config config = system.default_config ();
1185  	const int aec_limit = 20;
1186  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1187  	config.active_elections_size = aec_limit;
1188  	config.active_elections_hinted_limit_percentage = 20; 
1189  	auto &amp; node = *system.add_node (config);
1190  	auto blocks = nano::test::setup_independent_blocks (system, node, aec_limit * 4);
1191  	std::vector&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks1 (blocks.begin (), blocks.begin () + blocks.size () / 2);
1192  	std::vector&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks2 (blocks.begin () + blocks.size () / 2, blocks.end ());
1193  	WAIT (1s);
1194  	node.active.clear ();
1195  	ASSERT_TRUE (node.active.empty ());
1196  	for (auto const &amp; block : blocks1)
1197  	{
1198  		node.scheduler.buckets.activate (block-&gt;account (), node.store.tx_begin_read ());
1199  	}
1200  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit ());
1201  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit ());
1202  	for (auto const &amp; block : blocks2)
1203  	{
1204  		auto vote = nano::test::make_vote (nano::dev::genesis_key, { block });
1205  		node.inactive_vote_cache.vote (block-&gt;hash (), vote);
1206  	}
1207  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit () + node.active.limit (nano::election_behavior::hinted));
1208  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit () + node.active.limit (nano::election_behavior::hinted));
1209  }
1210  TEST (active_transactions, allow_limited_overflow_adapt)
1211  {
1212  	nano::test::system system;
1213  	nano::node_config config = system.default_config ();
1214  	const int aec_limit = 20;
1215  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1216  	config.active_elections_size = aec_limit;
1217  	config.active_elections_hinted_limit_percentage = 20; 
1218  	auto &amp; node = *system.add_node (config);
1219  	auto blocks = nano::test::setup_independent_blocks (system, node, aec_limit * 4);
1220  	std::vector&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks1 (blocks.begin (), blocks.begin () + blocks.size () / 2);
1221  	std::vector&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks2 (blocks.begin () + blocks.size () / 2, blocks.end ());
1222  	WAIT (1s);
1223  	node.active.clear ();
1224  	ASSERT_TRUE (node.active.empty ());
1225  	for (auto const &amp; block : blocks2)
1226  	{
1227  		auto vote = nano::test::make_vote (nano::dev::genesis_key, { block });
1228  		node.inactive_vote_cache.vote (block-&gt;hash (), vote);
1229  	}
1230  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit (nano::election_behavior::hinted));
1231  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit (nano::election_behavior::hinted));
1232  	for (auto const &amp; block : blocks1)
1233  	{
1234  		node.scheduler.buckets.activate (block-&gt;account (), node.store.tx_begin_read ());
1235  	}
1236  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit ());
1237  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit ());
1238  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trainingsampleset.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.cpp</div>
                </div>
                <div class="column column_space"><pre><code>563            samples_.push_back(sample);
564            fcinfo.samples.push_back(sample_index);
565          }
</pre></code></div>
                <div class="column column_space"><pre><code>257  	node.process_active (send);
258  	node.block_processor.add (open);
259  	node.block_processor.flush ();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    