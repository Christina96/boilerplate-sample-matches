
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.323193916349809%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dict.cpp</h3>
            <pre><code>1  #include "dict.h"
2  #include "tprintf.h"
3  #include <cstdio>
4  namespace tesseract {
5  class Image;
6  Dict::Dict(CCUtil *ccutil)
7      : letter_is_okay_(&tesseract::Dict::def_letter_is_okay)
8      , probability_in_context_(&tesseract::Dict::def_probability_in_context)
9      , ccutil_(ccutil)
10      , wildcard_unichar_id_(INVALID_UNICHAR_ID)
11      , apostrophe_unichar_id_(INVALID_UNICHAR_ID)
12      , question_unichar_id_(INVALID_UNICHAR_ID)
13      , slash_unichar_id_(INVALID_UNICHAR_ID)
14      , hyphen_unichar_id_(INVALID_UNICHAR_ID)
15      , STRING_MEMBER(user_words_file, "", "A filename of user-provided words.",
16                      getCCUtil()->params())
17      , STRING_INIT_MEMBER(user_words_suffix, "",
18                           "A suffix of user-provided words located in tessdata.",
19                           getCCUtil()->params())
20      , STRING_MEMBER(user_patterns_file, "", "A filename of user-provided patterns.",
21                      getCCUtil()->params())
22      , STRING_INIT_MEMBER(user_patterns_suffix, "",
23                           "A suffix of user-provided patterns located in "
24                           "tessdata.",
25                           getCCUtil()->params())
26      , BOOL_INIT_MEMBER(load_system_dawg, true, "Load system word dawg.", getCCUtil()->params())
27      , BOOL_INIT_MEMBER(load_freq_dawg, true, "Load frequent word dawg.", getCCUtil()->params())
28      , BOOL_INIT_MEMBER(load_unambig_dawg, true, "Load unambiguous word dawg.",
29                         getCCUtil()->params())
30      , BOOL_INIT_MEMBER(load_punc_dawg, true,
31                         "Load dawg with punctuation"
32                         " patterns.",
33                         getCCUtil()->params())
34      , BOOL_INIT_MEMBER(load_number_dawg, true,
35                         "Load dawg with number"
36                         " patterns.",
37                         getCCUtil()->params())
38      , BOOL_INIT_MEMBER(load_bigram_dawg, true,
39                         "Load dawg with special word "
40                         "bigrams.",
41                         getCCUtil()->params())
42      , double_MEMBER(xheight_penalty_subscripts, 0.125,
43                      "Score penalty (0.1 = 10%) added if there are subscripts "
44                      "or superscripts in a word, but it is otherwise OK.",
45                      getCCUtil()->params())
46      , double_MEMBER(xheight_penalty_inconsistent, 0.25,
47                      "Score penalty (0.1 = 10%) added if an xheight is "
48                      "inconsistent.",
49                      getCCUtil()->params())
50      , double_MEMBER(segment_penalty_dict_frequent_word, 1.0,
51                      "Score multiplier for word matches which have good case and"
52                      " are frequent in the given language (lower is better).",
53                      getCCUtil()->params())
54      , double_MEMBER(segment_penalty_dict_case_ok, 1.1,
55                      "Score multiplier for word matches that have good case "
56                      "(lower is better).",
57                      getCCUtil()->params())
58      , double_MEMBER(segment_penalty_dict_case_bad, 1.3125,
59                      "Default score multiplier for word matches, which may have "
60                      "case issues (lower is better).",
61                      getCCUtil()->params())
62      , double_MEMBER(segment_penalty_dict_nonword, 1.25,
63                      "Score multiplier for glyph fragment segmentations which "
64                      "do not match a dictionary word (lower is better).",
65                      getCCUtil()->params())
66      , double_MEMBER(segment_penalty_garbage, 1.50,
67                      "Score multiplier for poorly cased strings that are not in"
68                      " the dictionary and generally look like garbage (lower is"
69                      " better).",
70                      getCCUtil()->params())
71      , STRING_MEMBER(output_ambig_words_file, "",
72                      "Output file for ambiguities found in the dictionary", getCCUtil()->params())
73      , INT_MEMBER(dawg_debug_level, 0,
74                   "Set to 1 for general debug info"
75                   ", to 2 for more details, to 3 to see all the debug messages",
76                   getCCUtil()->params())
77      , INT_MEMBER(hyphen_debug_level, 0, "Debug level for hyphenated words.", getCCUtil()->params())
78      , BOOL_MEMBER(use_only_first_uft8_step, false,
79                    "Use only the first UTF8 step of the given string"
80                    " when computing log probabilities.",
81                    getCCUtil()->params())
82      , double_MEMBER(certainty_scale, 20.0, "Certainty scaling factor", getCCUtil()->params())
83      , double_MEMBER(stopper_nondict_certainty_base, -2.50, "Certainty threshold for non-dict words",
84                      getCCUtil()->params())
85      , double_MEMBER(stopper_phase2_certainty_rejection_offset, 1.0, "Reject certainty offset",
86                      getCCUtil()->params())
87      , INT_MEMBER(stopper_smallword_size, 2, "Size of dict word to be treated as non-dict word",
88                   getCCUtil()->params())
89      , double_MEMBER(stopper_certainty_per_char, -0.50,
90                      "Certainty to add"
91                      " for each dict char above small word size.",
92                      getCCUtil()->params())
93      , double_MEMBER(stopper_allowable_character_badness, 3.0,
94                      "Max certainty variation allowed in a word (in sigma)", getCCUtil()->params())
95      , INT_MEMBER(stopper_debug_level, 0, "Stopper debug level", getCCUtil()->params())
96      , BOOL_MEMBER(stopper_no_acceptable_choices, false,
97                    "Make AcceptableChoice() always return false. Useful"
98                    " when there is a need to explore all segmentations",
99                    getCCUtil()->params())
100      , INT_MEMBER(tessedit_truncate_wordchoice_log, 10, "Max words to keep in list",
101                   getCCUtil()->params())
102      , STRING_MEMBER(word_to_debug, "",
103                      "Word for which stopper debug"
104                      " information should be printed to stdout",
105                      getCCUtil()->params())
106      , BOOL_MEMBER(segment_nonalphabetic_script, false,
107                    "Don't use any alphabetic-specific tricks."
108                    " Set to true in the traineddata config file for"
109                    " scripts that are cursive or inherently fixed-pitch",
110                    getCCUtil()->params())
111      , BOOL_MEMBER(save_doc_words, 0, "Save Document Words", getCCUtil()->params())
112      , double_MEMBER(doc_dict_pending_threshold, 0.0, "Worst certainty for using pending dictionary",
113                      getCCUtil()->params())
114      , double_MEMBER(doc_dict_certainty_threshold, -2.25,
115                      "Worst certainty for words that can be inserted into the"
116                      " document dictionary",
117                      getCCUtil()->params())
118      , INT_MEMBER(max_permuter_attempts, 10000,
119                   "Maximum number of different"
120                   " character choices to consider during permutation."
121                   " This limit is especially useful when user patterns"
122                   " are specified, since overly generic patterns can result in"
123                   " dawg search exploring an overly large number of options.",
124                   getCCUtil()->params()) {
125    reject_offset_ = 0.0;
126    go_deeper_fxn_ = nullptr;
127    hyphen_word_ = nullptr;
128    last_word_on_line_ = false;
129    document_words_ = nullptr;
130    dawg_cache_ = nullptr;
131    dawg_cache_is_ours_ = false;
132    pending_words_ = nullptr;
133    bigram_dawg_ = nullptr;
134    freq_dawg_ = nullptr;
135    punc_dawg_ = nullptr;
136    unambig_dawg_ = nullptr;
137    wordseg_rating_adjust_factor_ = -1.0f;
138    output_ambig_words_file_ = nullptr;
139  }
140  Dict::~Dict() {
141    End();
142    delete hyphen_word_;
143    if (output_ambig_words_file_ != nullptr) {
144      fclose(output_ambig_words_file_);
145    }
146  }
147  DawgCache *Dict::GlobalDawgCache() {
148    static DawgCache cache;
149    return &cache;
150  }
151  void Dict::SetupForLoad(DawgCache *dawg_cache) {
152    if (dawgs_.size() != 0) {
153      this->End();
154    }
155    apostrophe_unichar_id_ = getUnicharset().unichar_to_id(kApostropheSymbol);
156    question_unichar_id_ = getUnicharset().unichar_to_id(kQuestionSymbol);
157    slash_unichar_id_ = getUnicharset().unichar_to_id(kSlashSymbol);
158    hyphen_unichar_id_ = getUnicharset().unichar_to_id(kHyphenSymbol);
159    if (dawg_cache != nullptr) {
160      dawg_cache_ = dawg_cache;
161      dawg_cache_is_ours_ = false;
162    } else {
163      dawg_cache_ = new DawgCache();
164      dawg_cache_is_ours_ = true;
165    }
166  }
167  void Dict::Load(const std::string &lang, TessdataManager *data_file) {
168    if (load_punc_dawg) {
169      punc_dawg_ =
170          dawg_cache_->GetSquishedDawg(lang, TESSDATA_PUNC_DAWG, dawg_debug_level, data_file);
171      if (punc_dawg_) {
172        dawgs_.push_back(punc_dawg_);
173      }
174    }
175    if (load_system_dawg) {
176      Dawg *system_dawg =
177          dawg_cache_->GetSquishedDawg(lang, TESSDATA_SYSTEM_DAWG, dawg_debug_level, data_file);
178      if (system_dawg) {
179        dawgs_.push_back(system_dawg);
180      }
181    }
182    if (load_number_dawg) {
183      Dawg *number_dawg =
184          dawg_cache_->GetSquishedDawg(lang, TESSDATA_NUMBER_DAWG, dawg_debug_level, data_file);
185      if (number_dawg) {
186        dawgs_.push_back(number_dawg);
187      }
188    }
189    if (load_bigram_dawg) {
190      bigram_dawg_ =
191          dawg_cache_->GetSquishedDawg(lang, TESSDATA_BIGRAM_DAWG, dawg_debug_level, data_file);
192    }
193    if (load_freq_dawg) {
194      freq_dawg_ =
195          dawg_cache_->GetSquishedDawg(lang, TESSDATA_FREQ_DAWG, dawg_debug_level, data_file);
196      if (freq_dawg_) {
197        dawgs_.push_back(freq_dawg_);
198      }
199    }
200    if (load_unambig_dawg) {
201      unambig_dawg_ =
202          dawg_cache_->GetSquishedDawg(lang, TESSDATA_UNAMBIG_DAWG, dawg_debug_level, data_file);
203      if (unambig_dawg_) {
204        dawgs_.push_back(unambig_dawg_);
205      }
206    }
207    std::string name;
208    if (!user_words_suffix.empty() || !user_words_file.empty()) {
209      Trie *trie_ptr =
210          new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM, getUnicharset().size(), dawg_debug_level);
211      if (!user_words_file.empty()) {
212        name = user_words_file;
213      } else {
214        name = getCCUtil()->language_data_path_prefix;
215        name += user_words_suffix;
216      }
217      if (!trie_ptr->read_and_add_word_list(name.c_str(), getUnicharset(),
218                                            Trie::RRP_REVERSE_IF_HAS_RTL)) {
219        tprintf("Error: failed to load %s\n", name.c_str());
220        delete trie_ptr;
221      } else {
222        dawgs_.push_back(trie_ptr);
223      }
224    }
225    if (!user_patterns_suffix.empty() || !user_patterns_file.empty()) {
226      Trie *trie_ptr = new Trie(DAWG_TYPE_PATTERN, lang, USER_PATTERN_PERM, getUnicharset().size(),
227                                dawg_debug_level);
228      trie_ptr->initialize_patterns(&(getUnicharset()));
229      if (!user_patterns_file.empty()) {
230        name = user_patterns_file;
231      } else {
232        name = getCCUtil()->language_data_path_prefix;
233        name += user_patterns_suffix;
234      }
235      if (!trie_ptr->read_pattern_list(name.c_str(), getUnicharset())) {
236        tprintf("Error: failed to load %s\n", name.c_str());
237        delete trie_ptr;
238      } else {
239        dawgs_.push_back(trie_ptr);
240      }
241    }
242    document_words_ =
243        new Trie(DAWG_TYPE_WORD, lang, DOC_DAWG_PERM, getUnicharset().size(), dawg_debug_level);
244    dawgs_.push_back(document_words_);
245    pending_words_ =
246        new Trie(DAWG_TYPE_WORD, lang, NO_PERM, getUnicharset().size(), dawg_debug_level);
247  }
248  void Dict::LoadLSTM(const std::string &lang, TessdataManager *data_file) {
249    if (load_punc_dawg) {
250      punc_dawg_ =
251          dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_PUNC_DAWG, dawg_debug_level, data_file);
252      if (punc_dawg_) {
253        dawgs_.push_back(punc_dawg_);
254      }
255    }
256    if (load_system_dawg) {
257      Dawg *system_dawg =
258          dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_SYSTEM_DAWG, dawg_debug_level, data_file);
259      if (system_dawg) {
260        dawgs_.push_back(system_dawg);
261      }
262    }
263    if (load_number_dawg) {
264      Dawg *number_dawg =
265          dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_NUMBER_DAWG, dawg_debug_level, data_file);
266      if (number_dawg) {
267        dawgs_.push_back(number_dawg);
268      }
269    }
270    std::string name;
271    if (!user_words_suffix.empty() || !user_words_file.empty()) {
272      Trie *trie_ptr =
273          new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM, getUnicharset().size(), dawg_debug_level);
274      if (!user_words_file.empty()) {
275        name = user_words_file;
276      } else {
277        name = getCCUtil()->language_data_path_prefix;
278        name += user_words_suffix;
279      }
280      if (!trie_ptr->read_and_add_word_list(name.c_str(), getUnicharset(),
281                                            Trie::RRP_REVERSE_IF_HAS_RTL)) {
282        tprintf("Error: failed to load %s\n", name.c_str());
283        delete trie_ptr;
284      } else {
285        dawgs_.push_back(trie_ptr);
286      }
287    }
288    if (!user_patterns_suffix.empty() || !user_patterns_file.empty()) {
289      Trie *trie_ptr = new Trie(DAWG_TYPE_PATTERN, lang, USER_PATTERN_PERM, getUnicharset().size(),
290                                dawg_debug_level);
291      trie_ptr->initialize_patterns(&(getUnicharset()));
292      if (!user_patterns_file.empty()) {
293        name = user_patterns_file;
294      } else {
295        name = getCCUtil()->language_data_path_prefix;
296        name += user_patterns_suffix;
297      }
298      if (!trie_ptr->read_pattern_list(name.c_str(), getUnicharset())) {
299        tprintf("Error: failed to load %s\n", name.c_str());
300        delete trie_ptr;
301      } else {
302        dawgs_.push_back(trie_ptr);
303      }
304    }
305  }
306  bool Dict::FinishLoad() {
307    if (dawgs_.empty()) {
308      return false;
309    }
310    successors_.reserve(dawgs_.size());
311    for (auto dawg : dawgs_) {
312      auto *lst = new SuccessorList();
313      for (unsigned j = 0; j < dawgs_.size(); ++j) {
314        const Dawg *other = dawgs_[j];
315        if (dawg != nullptr && other != nullptr && (dawg->lang() == other->lang()) &&
316            kDawgSuccessors[dawg->type()][other->type()]) {
317          lst->push_back(j);
318        }
319      }
320      successors_.push_back(lst);
321    }
322    return true;
323  }
324  void Dict::End() {
325    if (dawgs_.empty()) {
326      return; 
327    }
328    for (auto &dawg : dawgs_) {
329      if (!dawg_cache_->FreeDawg(dawg)) {
330        delete dawg;
331      }
332    }
333    dawg_cache_->FreeDawg(bigram_dawg_);
334    if (dawg_cache_is_ours_) {
335      delete dawg_cache_;
336      dawg_cache_ = nullptr;
337    }
338    for (auto successor : successors_) {
339      delete successor;
340    }
341    dawgs_.clear();
342    successors_.clear();
343    document_words_ = nullptr;
344    delete pending_words_;
345    pending_words_ = nullptr;
346  }
347  int Dict::def_letter_is_okay(void *void_dawg_args, const UNICHARSET &unicharset,
348                               UNICHAR_ID unichar_id, bool word_end) const {
349    auto *dawg_args = static_cast<DawgArgs *>(void_dawg_args);
350    ASSERT_HOST(unicharset.contains_unichar_id(unichar_id));
351    if (dawg_debug_level >= 3) {
352      tprintf(
353          "def_letter_is_okay: current unichar=%s word_end=%d"
354          " num active dawgs=%zu\n",
355          getUnicharset().debug_str(unichar_id).c_str(), word_end, dawg_args->active_dawgs->size());
356    }
357    if (unichar_id == Dawg::kPatternUnicharID || unichar_id == INVALID_UNICHAR_ID) {
358      dawg_args->permuter = NO_PERM;
359      return NO_PERM;
360    }
361    PermuterType curr_perm = NO_PERM;
362    dawg_args->updated_dawgs->clear();
363    dawg_args->valid_end = false;
364    for (unsigned a = 0; a < dawg_args->active_dawgs->size(); ++a) {
365      const DawgPosition &pos = (*dawg_args->active_dawgs)[a];
366      const Dawg *punc_dawg = pos.punc_index >= 0 ? dawgs_[pos.punc_index] : nullptr;
367      const Dawg *dawg = pos.dawg_index >= 0 ? dawgs_[pos.dawg_index] : nullptr;
368      if (!dawg && !punc_dawg) {
369        tprintf("Received DawgPosition with no dawg or punc_dawg.  wth?\n");
370        continue;
371      }
372      if (!dawg) {
373        NODE_REF punc_node = GetStartingNode(punc_dawg, pos.punc_ref);
374        EDGE_REF punc_transition_edge =
375            punc_dawg->edge_char_of(punc_node, Dawg::kPatternUnicharID, word_end);
376        if (punc_transition_edge != NO_EDGE) {
377          const SuccessorList &slist = *(successors_[pos.punc_index]);
378          for (int sdawg_index : slist) {
379            const Dawg *sdawg = dawgs_[sdawg_index];
380            UNICHAR_ID ch = char_for_dawg(unicharset, unichar_id, sdawg);
381            EDGE_REF dawg_edge = sdawg->edge_char_of(0, ch, word_end);
382            if (dawg_edge != NO_EDGE) {
383              if (dawg_debug_level >= 3) {
384                tprintf("Letter found in dawg %d\n", sdawg_index);
385              }
386              dawg_args->updated_dawgs->add_unique(
387                  DawgPosition(sdawg_index, dawg_edge, pos.punc_index, punc_transition_edge, false),
388                  dawg_debug_level > 0, "Append transition from punc dawg to current dawgs: ");
389              if (sdawg->permuter() > curr_perm) {
390                curr_perm = sdawg->permuter();
391              }
392              if (sdawg->end_of_word(dawg_edge) && punc_dawg->end_of_word(punc_transition_edge)) {
393                dawg_args->valid_end = true;
394              }
395            }
396          }
397        }
398        EDGE_REF punc_edge = punc_dawg->edge_char_of(punc_node, unichar_id, word_end);
399        if (punc_edge != NO_EDGE) {
400          if (dawg_debug_level >= 3) {
401            tprintf("Letter found in punctuation dawg\n");
402          }
403          dawg_args->updated_dawgs->add_unique(
404              DawgPosition(-1, NO_EDGE, pos.punc_index, punc_edge, false), dawg_debug_level > 0,
405              "Extend punctuation dawg: ");
406          if (PUNC_PERM > curr_perm) {
407            curr_perm = PUNC_PERM;
408          }
409          if (punc_dawg->end_of_word(punc_edge)) {
410            dawg_args->valid_end = true;
411          }
412        }
413        continue;
414      }
415      if (punc_dawg && dawg->end_of_word(pos.dawg_ref)) {
416        NODE_REF punc_node = GetStartingNode(punc_dawg, pos.punc_ref);
417        EDGE_REF punc_edge =
418            punc_node == NO_EDGE ? NO_EDGE : punc_dawg->edge_char_of(punc_node, unichar_id, word_end);
419        if (punc_edge != NO_EDGE) {
420          dawg_args->updated_dawgs->add_unique(
421              DawgPosition(pos.dawg_index, pos.dawg_ref, pos.punc_index, punc_edge, true),
422              dawg_debug_level > 0, "Return to punctuation dawg: ");
423          if (dawg->permuter() > curr_perm) {
424            curr_perm = dawg->permuter();
425          }
426          if (punc_dawg->end_of_word(punc_edge)) {
427            dawg_args->valid_end = true;
428          }
429        }
430      }
431      if (pos.back_to_punc) {
432        continue;
433      }
434      if (dawg->type() == DAWG_TYPE_PATTERN) {
435        ProcessPatternEdges(dawg, pos, unichar_id, word_end, dawg_args, &curr_perm);
436        continue;
437      }
438      NODE_REF node = GetStartingNode(dawg, pos.dawg_ref);
439      EDGE_REF edge =
440          (node == NO_EDGE)
441              ? NO_EDGE
442              : dawg->edge_char_of(node, char_for_dawg(unicharset, unichar_id, dawg), word_end);
443      if (dawg_debug_level >= 3) {
444        tprintf("Active dawg: [%d, " REFFORMAT "] edge=" REFFORMAT "\n", pos.dawg_index, node, edge);
445      }
446      if (edge != NO_EDGE) { 
447        if (dawg_debug_level >= 3) {
448          tprintf("Letter found in dawg %d\n", pos.dawg_index);
449        }
450        if (word_end && punc_dawg && !punc_dawg->end_of_word(pos.punc_ref)) {
451          if (dawg_debug_level >= 3) {
452            tprintf("Punctuation constraint not satisfied at end of word.\n");
453          }
454          continue;
455        }
456        if (dawg->permuter() > curr_perm) {
457          curr_perm = dawg->permuter();
458        }
459        if (dawg->end_of_word(edge) &&
460            (punc_dawg == nullptr || punc_dawg->end_of_word(pos.punc_ref))) {
461          dawg_args->valid_end = true;
462        }
463        dawg_args->updated_dawgs->add_unique(
464            DawgPosition(pos.dawg_index, edge, pos.punc_index, pos.punc_ref, false),
465            dawg_debug_level > 0, "Append current dawg to updated active dawgs: ");
466      }
467    } 
468    if (dawg_args->permuter == NO_PERM || curr_perm == NO_PERM ||
469        (curr_perm != PUNC_PERM && dawg_args->permuter != COMPOUND_PERM)) {
470      dawg_args->permuter = curr_perm;
471    }
472    if (dawg_debug_level >= 2) {
473      tprintf("Returning %d for permuter code for this character.\n", dawg_args->permuter);
474    }
475    return dawg_args->permuter;
476  }
477  void Dict::ProcessPatternEdges(const Dawg *dawg, const DawgPosition &pos, UNICHAR_ID unichar_id,
478                                 bool word_end, DawgArgs *dawg_args, PermuterType *curr_perm) const {
479    NODE_REF node = GetStartingNode(dawg, pos.dawg_ref);
480    std::vector<UNICHAR_ID> unichar_id_patterns;
481    unichar_id_patterns.push_back(unichar_id);
482    dawg->unichar_id_to_patterns(unichar_id, getUnicharset(), &unichar_id_patterns);
483    for (int unichar_id_pattern : unichar_id_patterns) {
484      for (int k = 0; k < 2; ++k) {
485        EDGE_REF edge = (k == 0)
486                            ? dawg->edge_char_of(node, unichar_id_pattern, word_end)
487                            : dawg->pattern_loop_edge(pos.dawg_ref, unichar_id_pattern, word_end);
488        if (edge == NO_EDGE) {
489          continue;
490        }
491        if (dawg_debug_level >= 3) {
492          tprintf("Pattern dawg: [%d, " REFFORMAT "] edge=" REFFORMAT "\n", pos.dawg_index, node,
493                  edge);
494          tprintf("Letter found in pattern dawg %d\n", pos.dawg_index);
495        }
496        if (dawg->permuter() > *curr_perm) {
497          *curr_perm = dawg->permuter();
498        }
499        if (dawg->end_of_word(edge)) {
500          dawg_args->valid_end = true;
501        }
502        dawg_args->updated_dawgs->add_unique(
503            DawgPosition(pos.dawg_index, edge, pos.punc_index, pos.punc_ref, pos.back_to_punc),
504            dawg_debug_level > 0, "Append current dawg to updated active dawgs: ");
505      }
506    }
507  }
508  void Dict::init_active_dawgs(DawgPositionVector *active_dawgs, bool ambigs_mode) const {
509    if (hyphenated()) {
510      *active_dawgs = hyphen_active_dawgs_;
511      if (dawg_debug_level >= 3) {
512        for (unsigned i = 0; i < hyphen_active_dawgs_.size(); ++i) {
513          tprintf("Adding hyphen beginning dawg [%d, " REFFORMAT "]\n",
514                  hyphen_active_dawgs_[i].dawg_index, hyphen_active_dawgs_[i].dawg_ref);
515        }
516      }
517    } else {
518      default_dawgs(active_dawgs, ambigs_mode);
519    }
520  }
521  void Dict::default_dawgs(DawgPositionVector *dawg_pos_vec, bool suppress_patterns) const {
522    bool punc_dawg_available = (punc_dawg_ != nullptr) &&
523                               punc_dawg_->edge_char_of(0, Dawg::kPatternUnicharID, true) != NO_EDGE;
524    for (unsigned i = 0; i < dawgs_.size(); i++) {
525      if (dawgs_[i] != nullptr && !(suppress_patterns && (dawgs_[i])->type() == DAWG_TYPE_PATTERN)) {
526        int dawg_ty = dawgs_[i]->type();
527        bool subsumed_by_punc = kDawgSuccessors[DAWG_TYPE_PUNCTUATION][dawg_ty];
528        if (dawg_ty == DAWG_TYPE_PUNCTUATION) {
529          dawg_pos_vec->push_back(DawgPosition(-1, NO_EDGE, i, NO_EDGE, false));
530          if (dawg_debug_level >= 3) {
531            tprintf("Adding beginning punc dawg [%d, " REFFORMAT "]\n", i, NO_EDGE);
532          }
533        } else if (!punc_dawg_available || !subsumed_by_punc) {
534          dawg_pos_vec->push_back(DawgPosition(i, NO_EDGE, -1, NO_EDGE, false));
535          if (dawg_debug_level >= 3) {
536            tprintf("Adding beginning dawg [%d, " REFFORMAT "]\n", i, NO_EDGE);
537          }
538        }
539      }
540    }
541  }
542  void Dict::add_document_word(const WERD_CHOICE &best_choice) {
543    if (hyphen_word_) {
544      return;
545    }
546    int stringlen = best_choice.length();
547    if (valid_word(best_choice) || stringlen < 2) {
548      return;
549    }
550    if (best_choice.length() >= kDocDictMaxRepChars) {
551      int num_rep_chars = 1;
552      UNICHAR_ID uch_id = best_choice.unichar_id(0);
553      for (unsigned i = 1; i < best_choice.length(); ++i) {
554        if (best_choice.unichar_id(i) != uch_id) {
555          num_rep_chars = 1;
556          uch_id = best_choice.unichar_id(i);
557        } else {
558          ++num_rep_chars;
559          if (num_rep_chars == kDocDictMaxRepChars) {
560            return;
561          }
562        }
563      }
564    }
565    if (best_choice.certainty() < doc_dict_certainty_threshold || stringlen == 2) {
566      if (best_choice.certainty() < doc_dict_pending_threshold) {
567        return;
568      }
569      if (!pending_words_->word_in_dawg(best_choice)) {
570        if (stringlen > 2 ||
571            (stringlen == 2 && getUnicharset().get_isupper(best_choice.unichar_id(0)) &&
572             getUnicharset().get_isupper(best_choice.unichar_id(1)))) {
573          pending_words_->add_word_to_dawg(best_choice);
574        }
575        return;
576      }
577    }
578    if (save_doc_words) {
579      std::string filename(getCCUtil()->imagefile);
580      filename += ".doc";
581      FILE *doc_word_file = fopen(filename.c_str(), "a");
582      if (doc_word_file == nullptr) {
583        tprintf("Error: Could not open file %s\n", filename.c_str());
584        ASSERT_HOST(doc_word_file);
585      }
586      fprintf(doc_word_file, "%s\n", best_choice.debug_string().c_str());
587      fclose(doc_word_file);
588    }
589    document_words_->add_word_to_dawg(best_choice);
590  }
591  void Dict::adjust_word(WERD_CHOICE *word, bool nonword, XHeightConsistencyEnum xheight_consistency,
592                         float additional_adjust, bool modify_rating, bool debug) {
593    bool is_han = (getUnicharset().han_sid() != getUnicharset().null_sid() &&
594                   word->GetTopScriptID() == getUnicharset().han_sid());
595    bool case_is_ok = (is_han || case_ok(*word));
596    bool punc_is_ok = (is_han || !nonword || valid_punctuation(*word));
597    float adjust_factor = additional_adjust;
598    float new_rating = word->rating();
599    new_rating += kRatingPad;
600    const char *xheight_triggered = "";
601    if (word->length() > 1) {
602      switch (xheight_consistency) {
603        case XH_INCONSISTENT:
604          adjust_factor += xheight_penalty_inconsistent;
605          xheight_triggered = ", xhtBAD";
606          break;
607        case XH_SUBNORMAL:
608          adjust_factor += xheight_penalty_subscripts;
609          xheight_triggered = ", xhtSUB";
610          break;
611        case XH_GOOD:
612          break;
613      }
614    } else {
615      if (debug) {
616        tprintf("Consistency could not be calculated.\n");
617      }
618    }
619    if (debug) {
620      tprintf("%sWord: %s %4.2f%s", nonword ? "Non-" : "", word->unichar_string().c_str(),
621              word->rating(), xheight_triggered);
622    }
623    if (nonword) { 
624      if (case_is_ok && punc_is_ok) {
625        adjust_factor += segment_penalty_dict_nonword;
626        new_rating *= adjust_factor;
627        if (debug) {
628          tprintf(", W");
629        }
630      } else {
631        adjust_factor += segment_penalty_garbage;
632        new_rating *= adjust_factor;
633        if (debug) {
634          if (!case_is_ok) {
635            tprintf(", C");
636          }
637          if (!punc_is_ok) {
638            tprintf(", P");
639          }
640        }
641      }
642    } else { 
643      if (case_is_ok) {
644        if (!is_han && freq_dawg_ != nullptr && freq_dawg_->word_in_dawg(*word)) {
645          word->set_permuter(FREQ_DAWG_PERM);
646          adjust_factor += segment_penalty_dict_frequent_word;
647          new_rating *= adjust_factor;
648          if (debug) {
649            tprintf(", F");
650          }
651        } else {
652          adjust_factor += segment_penalty_dict_case_ok;
653          new_rating *= adjust_factor;
654          if (debug) {
655            tprintf(", ");
656          }
657        }
658      } else {
659        adjust_factor += segment_penalty_dict_case_bad;
660        new_rating *= adjust_factor;
661        if (debug) {
662          tprintf(", C");
663        }
664      }
665    }
666    new_rating -= kRatingPad;
667    if (modify_rating) {
668      word->set_rating(new_rating);
669    }
670    if (debug) {
671      tprintf(" %4.2f --> %4.2f\n", adjust_factor, new_rating);
672    }
673    word->set_adjust_factor(adjust_factor);
674  }
675  int Dict::valid_word(const WERD_CHOICE &word, bool numbers_ok) const {
676    const WERD_CHOICE *word_ptr = &word;
677    WERD_CHOICE temp_word(word.unicharset());
678    if (hyphenated() && hyphen_word_->unicharset() == word.unicharset()) {
679      copy_hyphen_info(&temp_word);
680      temp_word += word;
681      word_ptr = &temp_word;
682    }
683    if (word_ptr->empty()) {
684      return NO_PERM;
685    }
686    DawgPositionVector active_dawgs[2];
687    init_active_dawgs(&(active_dawgs[0]), false);
688    DawgArgs dawg_args(&(active_dawgs[0]), &(active_dawgs[1]), NO_PERM);
689    int last_index = word_ptr->length() - 1;
690    for (int i = hyphen_base_size(); i <= last_index; ++i) {
691      if (!((this->*letter_is_okay_)(&dawg_args, *word_ptr->unicharset(), word_ptr->unichar_id(i),
692                                     i == last_index))) {
693        break;
694      }
<span onclick='openModal()' class='match'>695      if (dawg_args.updated_dawgs == &(active_dawgs[1])) {
696        dawg_args.updated_dawgs = &(active_dawgs[0]);
697        ++(dawg_args.active_dawgs);
698      } else {
699        ++(dawg_args.updated_dawgs);
700        dawg_args.active_dawgs = &(active_dawgs[0]);
701      }
702    }
</span>703    return valid_word_permuter(dawg_args.permuter, numbers_ok) ? dawg_args.permuter : NO_PERM;
704  }
705  bool Dict::valid_bigram(const WERD_CHOICE &word1, const WERD_CHOICE &word2) const {
706    if (bigram_dawg_ == nullptr) {
707      return false;
708    }
709    unsigned w1start, w1end, w2start, w2end;
710    word1.punct_stripped(&w1start, &w1end);
711    word2.punct_stripped(&w2start, &w2end);
712    if (w1start >= w1end) {
713      return word1.length() < 3;
714    }
715    if (w2start >= w2end) {
716      return word2.length() < 3;
717    }
718    const UNICHARSET &uchset = getUnicharset();
719    std::vector<UNICHAR_ID> bigram_string;
720    bigram_string.reserve(w1end + w2end + 1);
721    for (auto i = w1start; i < w1end; i++) {
722      const auto &normed_ids = getUnicharset().normed_ids(word1.unichar_id(i));
723      if (normed_ids.size() == 1 && uchset.get_isdigit(normed_ids[0])) {
724        bigram_string.push_back(question_unichar_id_);
725      } else {
726        bigram_string.insert(bigram_string.end(), normed_ids.begin(), normed_ids.end());
727      }
728    }
729    bigram_string.push_back(UNICHAR_SPACE);
730    for (auto i = w2start; i < w2end; i++) {
731      const auto &normed_ids = getUnicharset().normed_ids(word2.unichar_id(i));
732      if (normed_ids.size() == 1 && uchset.get_isdigit(normed_ids[0])) {
733        bigram_string.push_back(question_unichar_id_);
734      } else {
735        bigram_string.insert(bigram_string.end(), normed_ids.begin(), normed_ids.end());
736      }
737    }
738    WERD_CHOICE normalized_word(&uchset, bigram_string.size());
739    for (int i : bigram_string) {
740      normalized_word.append_unichar_id_space_allocated(i, 1, 0.0f, 0.0f);
741    }
742    return bigram_dawg_->word_in_dawg(normalized_word);
743  }
744  bool Dict::valid_punctuation(const WERD_CHOICE &word) {
745    if (word.empty()) {
746      return NO_PERM;
747    }
748    WERD_CHOICE new_word(word.unicharset());
749    auto last_index = word.length() - 1;
750    int new_len = 0;
751    for (unsigned i = 0; i <= last_index; ++i) {
752      UNICHAR_ID unichar_id = (word.unichar_id(i));
753      if (getUnicharset().get_ispunctuation(unichar_id)) {
754        new_word.append_unichar_id(unichar_id, 1, 0.0, 0.0);
755      } else if (!getUnicharset().get_isalpha(unichar_id) &&
756                 !getUnicharset().get_isdigit(unichar_id)) {
757        return false; 
758      } else if ((new_len = new_word.length()) == 0 ||
759                 new_word.unichar_id(new_len - 1) != Dawg::kPatternUnicharID) {
760        new_word.append_unichar_id(Dawg::kPatternUnicharID, 1, 0.0, 0.0);
761      }
762    }
763    for (unsigned i = 0; i < dawgs_.size(); ++i) {
764      if (dawgs_[i] != nullptr && dawgs_[i]->type() == DAWG_TYPE_PUNCTUATION &&
765          dawgs_[i]->word_in_dawg(new_word)) {
766        return true;
767      }
768    }
769    return false;
770  }
771  bool Dict::IsSpaceDelimitedLang() const {
772    const UNICHARSET &u_set = getUnicharset();
773    if (u_set.han_sid() > 0) {
774      return false;
775    }
776    if (u_set.katakana_sid() > 0) {
777      return false;
778    }
779    if (u_set.thai_sid() > 0) {
780      return false;
781    }
782    return true;
783  }
784  } 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</h3>
            <pre><code>1  #include <windowsx.h>
2  #include "ProjectPanel.h"
3  #include "resource.h"
4  #include "CustomFileDialog.h"
5  #include "localization.h"
6  #include "Parameters.h"
7  #define INDEX_CLEAN_ROOT     0
8  #define INDEX_DIRTY_ROOT     1
9  #define INDEX_PROJECT        2
10  #define INDEX_OPEN_NODE	     3
11  #define INDEX_CLOSED_NODE    4
12  #define INDEX_LEAF           5
13  #define INDEX_LEAF_INVALID   6
14  ProjectPanel::~ProjectPanel()
15  {
16  	for (const auto& s : fullPathStrs)
17  	{
18  		delete s;
19  	}
20  }
21  intptr_t CALLBACK ProjectPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
22  {
23  	switch (message)
24  	{
25  		case WM_INITDIALOG :
26  		{
27  			ProjectPanel::initMenus();
28  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST;
29  			_hToolbarMenu = CreateWindowEx(0,TOOLBARCLASSNAME,NULL, style,
30  								   0,0,0,0,_hSelf, nullptr, _hInst, nullptr);
31  			TBBUTTON tbButtons[2]{};
32  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
33  			generic_string workspace_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 0, PM_WORKSPACEMENUENTRY);
34  			generic_string edit_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 1, PM_EDITMENUENTRY);
35  			tbButtons[0].idCommand = IDB_PROJECT_BTN;
36  			tbButtons[0].iBitmap = I_IMAGENONE;
37  			tbButtons[0].fsState = TBSTATE_ENABLED;
38  			tbButtons[0].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
39  			tbButtons[0].iString = (intptr_t)workspace_entry.c_str();
40  			tbButtons[1].idCommand = IDB_EDIT_BTN;
41  			tbButtons[1].iBitmap = I_IMAGENONE;
42  			tbButtons[1].fsState = TBSTATE_ENABLED;
43  			tbButtons[1].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
44  			tbButtons[1].iString = (intptr_t)edit_entry.c_str();
45  			SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
46  			SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
47  			SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0); 
48  			ShowWindow(_hToolbarMenu, SW_SHOW);
49  			_treeView.init(_hInst, _hSelf, ID_PROJECTTREEVIEW);
50  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 7, IDI_PROJECT_WORKSPACE, IDI_PROJECT_WORKSPACEDIRTY, IDI_PROJECT_PROJECT, IDI_PROJECT_FOLDEROPEN, IDI_PROJECT_FOLDERCLOSE, IDI_PROJECT_FILE, IDI_PROJECT_FILEINVALID);
51  			_treeView.addCanNotDropInList(INDEX_LEAF);
52  			_treeView.addCanNotDropInList(INDEX_LEAF_INVALID);
53  			_treeView.addCanNotDragOutList(INDEX_CLEAN_ROOT);
54  			_treeView.addCanNotDragOutList(INDEX_DIRTY_ROOT);
55  			_treeView.addCanNotDragOutList(INDEX_PROJECT);
56  			_treeView.display();
57  			if (!openWorkSpace(_workSpaceFilePath.c_str(), true))
58  				newWorkSpace();
59  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
60  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
61  			return TRUE;
62  		}
63  		case NPPM_INTERNAL_REFRESHDARKMODE:
64  		{
65  			if (static_cast<BOOL>(lParam) != TRUE)
66  			{
67  				NppDarkMode::autoThemeChildControls(_hSelf);
68  			}
69  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
70  			return TRUE;
71  		}
72  		case WM_MOUSEMOVE:
73  			if (_treeView.isDragging())
74  				_treeView.dragItem(_hSelf, LOWORD(lParam), HIWORD(lParam));
75  			break;
76  		case WM_LBUTTONUP:
77  			if (_treeView.isDragging())
78  				if (_treeView.dropItem())
79  					setWorkSpaceDirty(true);
80  			break;
81  		case WM_NOTIFY:
82  		{
83  			notified((LPNMHDR)lParam);
84  		}
85  		return TRUE;
86  		case WM_SIZE:
87  		{
88  			int width = LOWORD(lParam);
89  			int height = HIWORD(lParam);
90  			RECT toolbarMenuRect{};
91  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
92  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
93  			HWND hwnd = _treeView.getHSelf();
94  			if (hwnd)
95  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + 2, width, height - toolbarMenuRect.bottom - 2, TRUE);
96  			break;
97  		}
98  		case WM_CONTEXTMENU:
99  			if (!_treeView.isDragging())
100  			{
101  				int xPos = GET_X_LPARAM(lParam);
102  				int yPos = GET_Y_LPARAM(lParam);
103  				if (xPos == -1 && yPos == -1)
104  				{
105  					HTREEITEM selectedItem = _treeView.getSelection();
106  					if (selectedItem)
107  					{
108  						RECT selectedItemRect{};
109  						if (TreeView_GetItemRect(_treeView.getHSelf(), selectedItem, &selectedItemRect, TRUE))
110  						{
111  							showContextMenuFromMenuKey(selectedItem, (selectedItemRect.left + selectedItemRect.right) / 2, (selectedItemRect.top + selectedItemRect.bottom) / 2);
112  						}
113  					}
114  				}
115  				else
116  				{
117  					showContextMenu(xPos, yPos);
118  				}
119  			}
120  		return TRUE;
121  		case WM_COMMAND:
122  		{
123  			popupMenuCmd(LOWORD(wParam));
124  			break;
125  		}
126  		case WM_DESTROY:
127  		{
128  			_treeView.destroy();
129  			destroyMenus();
130  			::DestroyWindow(_hToolbarMenu);
131  			break;
132  		}
133  		default :
134  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
135  	}
136  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
137  }
138  bool ProjectPanel::checkIfNeedSave()
139  {
140  	if (_isDirty)
141  	{
142  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
143  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
144  		int res = pNativeSpeaker->messageBox("ProjectPanelChanged",
145  			_hSelf,
146  			TEXT("The workspace was modified. Do you want to save it?"),
147  			TEXT("$STR_REPLACE$"),
148  			MB_YESNOCANCEL | MB_ICONQUESTION,
149  			0,
150  			title);
151  		if (res == IDYES)
152  		{
153  			if (!saveWorkSpace())
154  				return false;
155  		}
156  		else if (res == IDNO)
157  		{
158  		}
159  		else
160  		{
161  			return false;
162  		}
163  	}
164  	return true;
165  }
166  void ProjectPanel::initMenus()
167  {
168  	_hWorkSpaceMenu = ::CreatePopupMenu();
169  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
170  	generic_string new_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWWS, PM_NEWWORKSPACE);
171  	generic_string open_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_OPENWS, PM_OPENWORKSPACE);
172  	generic_string reload_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_RELOADWS, PM_RELOADWORKSPACE);
173  	generic_string save_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEWS, PM_SAVEWORKSPACE);
174  	generic_string saveas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEASWS, PM_SAVEASWORKSPACE);
175  	generic_string saveacopyas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEACOPYASWS, PM_SAVEACOPYASWORKSPACE);
176  	generic_string newproject_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWPROJECT, PM_NEWPROJECTWORKSPACE);
177  	generic_string findinprojects_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_FINDINPROJECTSWS, PM_FINDINFILESWORKSPACE);
178  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWWS, new_workspace.c_str());
179  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_OPENWS, open_workspace.c_str());
180  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RELOADWS, reload_workspace.c_str());
181  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEWS, save_workspace.c_str());
182  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEASWS, saveas_workspace.c_str());
183  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEACOPYASWS, saveacopyas_workspace.c_str());
184  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
185  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWPROJECT, newproject_workspace.c_str());
186  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
187  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_FINDINPROJECTSWS, findinprojects_workspace.c_str());
188  	generic_string edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
189  	generic_string edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
190  	generic_string edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
191  	generic_string edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
192  	generic_string edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
193  	generic_string edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
194  	generic_string edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
195  	_hProjectMenu = ::CreatePopupMenu();
196  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
197  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
198  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
199  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
200  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER, edit_addfolder.c_str());
201  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES, edit_addfiles.c_str());
202  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
203  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER, edit_remove.c_str());
204  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
205  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
206  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
207  	edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
208  	edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
209  	edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
210  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
211  	_hFolderMenu = ::CreatePopupMenu();
212  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP,        edit_moveup.c_str());
213  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN,      edit_movedown.c_str());
214  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
215  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME,        edit_rename.c_str());
216  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER,     edit_addfolder.c_str());
217  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES,      edit_addfiles.c_str());
218  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
219  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER,  edit_remove.c_str());
220  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
221  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
222  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
223  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_DELETEFILE, PM_EDITREMOVE);
224  	generic_string edit_modifyfile = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MODIFYFILEPATH, PM_EDITMODIFYFILE);
225  	_hFileMenu = ::CreatePopupMenu();
226  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
227  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
228  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
229  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
230  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFILE, edit_remove.c_str());
231  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MODIFYFILEPATH, edit_modifyfile.c_str());
232  }
233  void ProjectPanel::destroyMenus() 
234  {
235  	::DestroyMenu(_hWorkSpaceMenu);
236  	::DestroyMenu(_hProjectMenu);
237  	::DestroyMenu(_hFolderMenu);
238  	::DestroyMenu(_hFileMenu);
239  }
240  bool ProjectPanel::openWorkSpace(const TCHAR *projectFileName, bool force)
241  {
242  	if ((!force) && (_workSpaceFilePath.length() > 0))
243  	{ 
244  		generic_string newWorkspace = projectFileName;
245  		if (newWorkspace == _workSpaceFilePath)
246  			return true;
247  		if (!saveWorkspaceRequest())
248  			return true;
249  	}
250  	TiXmlDocument *pXmlDocProject = new TiXmlDocument(projectFileName);
251  	bool loadOkay = pXmlDocProject->LoadFile();
252  	if (!loadOkay)
253  	{
254  		delete pXmlDocProject;
255  		return false;
256  	}
257  	TiXmlNode *root = pXmlDocProject->FirstChild(TEXT("NotepadPlus"));
258  	if (!root) 
259  	{
260  		delete pXmlDocProject;
261  		return false;
262  	}
263  	TiXmlNode *childNode = root->FirstChildElement(TEXT("Project"));
264  	if (!childNode) 
265  	{
266  		delete pXmlDocProject;
267  		return false;
268  	}
269  	if (!::PathFileExists(projectFileName))
270  	{
271  		delete pXmlDocProject;
272  		return false;
273  	}
274  	_treeView.removeAllItems();
275  	_workSpaceFilePath = projectFileName;
276  	TCHAR * fileName = PathFindFileName(projectFileName);
277  	HTREEITEM rootItem = _treeView.addItem(fileName, TVI_ROOT, INDEX_CLEAN_ROOT);
278  	for ( ; childNode ; childNode = childNode->NextSibling(TEXT("Project")))
279  	{
280  		HTREEITEM projectItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), rootItem, INDEX_PROJECT);
281  		buildTreeFrom(childNode, projectItem);
282  	}
283  	setWorkSpaceDirty(false);
284  	_treeView.expand(rootItem);
285  	delete pXmlDocProject;
286  	return loadOkay;
287  }
288  void ProjectPanel::newWorkSpace()
289  {
290  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
291  	generic_string workspace = pNativeSpeaker->getAttrNameStr(PM_WORKSPACEROOTNAME, "ProjectManager", "WorkspaceRootName");
292  	_treeView.addItem(workspace.c_str(), TVI_ROOT, INDEX_CLEAN_ROOT);
293  	setWorkSpaceDirty(false);
294  	_workSpaceFilePath = TEXT("");
295  }
296  bool ProjectPanel::saveWorkSpace()
297  {
298  	if (_workSpaceFilePath == TEXT(""))
299  	{
300  		return saveWorkSpaceAs(false);
301  	}
302  	else
303  	{
304  		if (!writeWorkSpace())
305  			return false;
306  		setWorkSpaceDirty(false);
307  		return true;
308  	} 
309  }
310  bool ProjectPanel::writeWorkSpace(const TCHAR *projectFileName, bool doUpdateGUI)
311  {
312  	const TCHAR * fn2write = projectFileName?projectFileName:_workSpaceFilePath.c_str();
313  	TiXmlDocument projDoc(fn2write);
314  	TiXmlNode *root = projDoc.InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
315  	TCHAR textBuffer[MAX_PATH] = { '\0' };
316  	TVITEM tvItem{};
317  	tvItem.mask = TVIF_TEXT;
318  	tvItem.pszText = textBuffer;
319  	tvItem.cchTextMax = MAX_PATH;
320  	HTREEITEM tvRoot = _treeView.getRoot();
321  	if (!tvRoot)
322  		return false;
323  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
324  		tvProj != NULL;
325  		tvProj = _treeView.getNextSibling(tvProj))
326  	{
327  		tvItem.hItem = tvProj;
328  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
329  		TiXmlNode *projRoot = root->InsertEndChild(TiXmlElement(TEXT("Project")));
330  		projRoot->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
331  		buildProjectXml(projRoot, tvProj, fn2write);
332  	}
333  	if (!projDoc.SaveFile())
334  	{
335  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
336  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
337  		pNativeSpeaker->messageBox("ProjectPanelSaveError",
338  		_hSelf,
339  		TEXT("An error occurred while writing your workspace file.\nYour workspace has not been saved."),
340  		TEXT("$STR_REPLACE$"),
341  		MB_OK | MB_ICONERROR,
342  		0,
343  		title);
344  		return false;
345  	}
346  	TCHAR * fileName = PathFindFileName(fn2write);
347  	if (doUpdateGUI)
348  	{
349  		_treeView.renameItem(tvRoot, fileName);
350  	}
351  	return true;
352  }
353  void ProjectPanel::buildProjectXml(TiXmlNode *node, HTREEITEM hItem, const TCHAR* fn2write)
354  {
355  	TCHAR textBuffer[MAX_PATH] = { '\0' };
356  	TVITEM tvItem{};
357  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
358  	tvItem.pszText = textBuffer;
359  	tvItem.cchTextMax = MAX_PATH;
360  	for (HTREEITEM hItemNode = _treeView.getChildFrom(hItem);
361  		hItemNode != NULL;
362  		hItemNode = _treeView.getNextSibling(hItemNode))
363  	{
364  		tvItem.hItem = hItemNode;
365  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
366  		if (tvItem.lParam)
367  		{
368  			generic_string *fn = (generic_string *)tvItem.lParam;
369  			generic_string newFn = getRelativePath(*fn, fn2write);
370  			TiXmlNode *fileLeaf = node->InsertEndChild(TiXmlElement(TEXT("File")));
371  			fileLeaf->ToElement()->SetAttribute(TEXT("name"), newFn.c_str());
372  		}
373  		else
374  		{
375  			TiXmlNode *folderNode = node->InsertEndChild(TiXmlElement(TEXT("Folder")));
376  			folderNode->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
377  			buildProjectXml(folderNode, hItemNode, fn2write);
378  		}
379  	}
380  }
381  bool ProjectPanel::enumWorkSpaceFiles(HTREEITEM tvFrom, const std::vector<generic_string> & patterns, std::vector<generic_string> & fileNames)
382  {
383  	TCHAR textBuffer[MAX_PATH] = { '\0' };
384  	TVITEM tvItem{};
385  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
386  	tvItem.pszText = textBuffer;
387  	tvItem.cchTextMax = MAX_PATH;
388  	HTREEITEM tvRoot = tvFrom ? tvFrom : _treeView.getRoot();
389  	if (!tvRoot) return false;
390  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
391  		tvProj != NULL;
392  		tvProj = _treeView.getNextSibling(tvProj))
393  	{
394  		tvItem.hItem = tvProj;
395  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
396  		if (tvItem.lParam)
397  		{
398  			if (matchInList(tvItem.pszText, patterns))
399  			{
400  				generic_string *fn = (generic_string *)tvItem.lParam;
401  				fileNames.push_back (*fn);
402  			}
403  		}
404  		else
405  		{
406  			if (!enumWorkSpaceFiles (tvProj, patterns, fileNames)) return false;
407  		}
408  	}
409  	return true;
410  }
411  generic_string ProjectPanel::getRelativePath(const generic_string & filePath, const TCHAR *workSpaceFileName)
412  {
413  	TCHAR wsfn[MAX_PATH] = { '\0' };
414  	wcscpy_s(wsfn, workSpaceFileName);
415  	::PathRemoveFileSpec(wsfn);
416  	size_t pos_found = filePath.find(wsfn);
417  	if (pos_found == generic_string::npos)
418  		return filePath;
419  	const TCHAR *relativeFile = filePath.c_str() + lstrlen(wsfn);
420  	if (relativeFile[0] == '\\')
421  		++relativeFile;
422  	return relativeFile;
423  }
424  bool ProjectPanel::buildTreeFrom(TiXmlNode *projectRoot, HTREEITEM hParentItem)
425  {
426  	for (TiXmlNode *childNode = projectRoot->FirstChildElement();
427  		childNode ;
428  		childNode = childNode->NextSibling())
429  	{
430  		const TCHAR *v = childNode->Value();
431  		if (lstrcmp(TEXT("Folder"), v) == 0)
432  		{
433  			HTREEITEM addedItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), hParentItem, INDEX_CLOSED_NODE);
434  			if (!childNode->NoChildren())
435  			{
436  				bool isOK = buildTreeFrom(childNode, addedItem);
437  				if (!isOK)
438  					return false;
439  			}
440  		}
441  		else if (lstrcmp(TEXT("File"), v) == 0)
442  		{
443  			const TCHAR *strValue = (childNode->ToElement())->Attribute(TEXT("name"));
444  			generic_string fullPath = getAbsoluteFilePath(strValue);
445  			TCHAR *strValueLabel = ::PathFindFileName(strValue);
446  			int iImage = ::PathFileExists(fullPath.c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
447  			generic_string* fullPathStr = new generic_string(fullPath);
448  			fullPathStrs.push_back(fullPathStr);
449  			LPARAM lParamFullPathStr = reinterpret_cast<LPARAM>(fullPathStr);
450  			_treeView.addItem(strValueLabel, hParentItem, iImage, lParamFullPathStr);
451  		}
452  	}
453  	return true;
454  }
455  generic_string ProjectPanel::getAbsoluteFilePath(const TCHAR * relativePath)
456  {
457  	if (!::PathIsRelative(relativePath))
458  		return relativePath;
459  	TCHAR absolutePath[MAX_PATH] = { '\0' };
460  	wcscpy_s(absolutePath, _workSpaceFilePath.c_str());
461  	::PathRemoveFileSpec(absolutePath);
462  	::PathAppend(absolutePath, relativePath);
463  	return absolutePath;
464  }
465  void ProjectPanel::openSelectFile()
466  {
467  	TVITEM tvItem{};
468  	tvItem.mask = TVIF_PARAM;
469  	tvItem.hItem = _treeView.getSelection();
470  	::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
471  	NodeType nType = getNodeType(tvItem.hItem);
472  	generic_string *fn = (generic_string *)tvItem.lParam;
473  	if (nType == nodeType_file && fn)
474  	{
475  		tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
<span onclick='openModal()' class='match'>476  		if (::PathFileExists(fn->c_str()))
477  		{
478  			::PostMessage(_hParent, NPPM_DOOPEN, 0, reinterpret_cast<LPARAM>(fn->c_str()));
479  			tvItem.iImage = INDEX_LEAF;
480  			tvItem.iSelectedImage = INDEX_LEAF;
481  		}
482  		else
483  		{
484  			tvItem.iImage = INDEX_LEAF_INVALID;
485  			tvItem.iSelectedImage = INDEX_LEAF_INVALID;
486  		}
487  		TreeView_SetItem(_treeView.getHSelf(), &tvItem);
488  	}
</span>489  }
490  void ProjectPanel::notified(LPNMHDR notification)
491  {
492  	if (notification->code == DMN_CLOSE)
493  	{
494  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_PROJECT_PANEL_1 + _panelID, 0);
495  		SetWindowLongPtr (getHSelf(), DWLP_MSGRESULT, _isClosed ? 0 : 1);
496  	}
497  	else if (notification->hwndFrom == _treeView.getHSelf())
498  	{
499  		TCHAR textBuffer[MAX_PATH] = { '\0' };
500  		TVITEM tvItem{};
501  		tvItem.mask = TVIF_TEXT | TVIF_PARAM;
502  		tvItem.pszText = textBuffer;
503  		tvItem.cchTextMax = MAX_PATH;
504  		switch (notification->code)
505  		{
506  			case NM_DBLCLK:
507  			{
508  				openSelectFile();
509  			}
510  			break;
511  			case NM_RETURN:
512  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1);
513  			break;
514  			case TVN_ENDLABELEDIT:
515  			{
516  				LPNMTVDISPINFO tvnotif = (LPNMTVDISPINFO)notification;
517  				if (!tvnotif->item.pszText)
518  					return;
519  				if (getNodeType(tvnotif->item.hItem) == nodeType_root)
520  					return;
521  				if (tvnotif->item.lParam) 
522  				{
523  					tvItem.hItem = _treeView.getSelection();
524  					::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
525  					size_t len = lstrlen(tvItem.pszText);
526  					generic_string *filePath = (generic_string *)tvnotif->item.lParam;
527  					size_t found = filePath->rfind(tvItem.pszText);
528  					if (found != generic_string::npos)
529  						filePath->replace(found, len, tvnotif->item.pszText);
530  					tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
531  					if (::PathFileExists(filePath->c_str()))
532  					{
533  						tvItem.iImage = INDEX_LEAF;
534  						tvItem.iSelectedImage = INDEX_LEAF;
535  					}
536  					else
537  					{
538  						tvItem.iImage = INDEX_LEAF_INVALID;
539  						tvItem.iSelectedImage = INDEX_LEAF_INVALID;
540  					}
541  					TreeView_SetItem(_treeView.getHSelf(), &tvItem);
542  				}
543  				::SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&(tvnotif->item)));
544  				setWorkSpaceDirty(true);
545  			}
546  			break;
547  			case TVN_GETINFOTIP:
548  			{
549  				LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)notification;
550  				generic_string *str = NULL ;
551  				if (_treeView.getRoot() == lpGetInfoTip->hItem)
552  				{
553  					str = &_workSpaceFilePath;
554  				}
555  				else
556  				{
557  					str = (generic_string *)lpGetInfoTip->lParam;
558  					if (!str)
559  						return;
560  				}
561  				lpGetInfoTip->pszText = (LPTSTR)str->c_str();
562  				lpGetInfoTip->cchTextMax = static_cast<int32_t>(str->size());
563  			}
564  			break;
565  			case TVN_KEYDOWN:
566  			{
567  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
568  				if (ptvkd->wVKey == VK_DELETE)
569  				{
570  					HTREEITEM hItem = _treeView.getSelection();
571  					NodeType nType = getNodeType(hItem);
572  					if (nType == nodeType_project || nType == nodeType_folder)
573  						popupMenuCmd(IDM_PROJECT_DELETEFOLDER);
574  					else if (nType == nodeType_file)
575  						popupMenuCmd(IDM_PROJECT_DELETEFILE);
576  				}
577  				else if (ptvkd->wVKey == VK_RETURN)
578  				{
579  					HTREEITEM hItem = _treeView.getSelection();
580  					NodeType nType = getNodeType(hItem);
581  					if (nType == nodeType_file)
582  						openSelectFile();
583  					else
584  						_treeView.toggleExpandCollapse(hItem);
585  				}
586  				else if (ptvkd->wVKey == VK_UP)
587  				{
588  					if (0x80 & GetKeyState(VK_CONTROL))
589  					{
590  						popupMenuCmd(IDM_PROJECT_MOVEUP);
591  					}
592  				}
593  				else if (ptvkd->wVKey == VK_DOWN)
594  				{
595  					if (0x80 & GetKeyState(VK_CONTROL))
596  					{
597  						popupMenuCmd(IDM_PROJECT_MOVEDOWN);
598  					}
599  				}
600  				else if (ptvkd->wVKey == VK_F2)
601  					popupMenuCmd(IDM_PROJECT_RENAME);
602  			}
603  			break;
604  			case TVN_ITEMEXPANDED:
605  			{
606  				LPNMTREEVIEW nmtv = (LPNMTREEVIEW)notification;
607  				tvItem.hItem = nmtv->itemNew.hItem;
608  				tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
609  				if (getNodeType(nmtv->itemNew.hItem) == nodeType_folder)
610  				{
611  					if (nmtv->action == TVE_COLLAPSE)
612  					{
613  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
614  					}
615  					else if (nmtv->action == TVE_EXPAND)
616  					{
617  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
618  					}
619  				}
620  			}
621  			break;
622  			case TVN_BEGINDRAG:
623  			{
624  				_treeView.beginDrag((LPNMTREEVIEW)notification);
625  			}
626  			break;
627  		}
628  	}
629  }
630  void ProjectPanel::setWorkSpaceDirty(bool isDirty)
631  {
632  	_isDirty = isDirty;
633  	int iImg = _isDirty?INDEX_DIRTY_ROOT:INDEX_CLEAN_ROOT;
634  	_treeView.setItemImage(_treeView.getRoot(), iImg, iImg);
635  }
636  NodeType ProjectPanel::getNodeType(HTREEITEM hItem)
637  {
638  	TVITEM tvItem{};
639  	tvItem.hItem = hItem;
640  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
641  	SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
642  	if (tvItem.iImage == INDEX_CLEAN_ROOT || tvItem.iImage == INDEX_DIRTY_ROOT)
643  	{
644  		return nodeType_root;
645  	}
646  	else if (tvItem.iImage == INDEX_PROJECT)
647  	{
648  		return nodeType_project;
649  	}
650  	else if (!tvItem.lParam)
651  	{
652  		return nodeType_folder;
653  	}
654  	else
655  	{
656  		return nodeType_file;
657  	}
658  }
659  void ProjectPanel::showContextMenu(int x, int y)
660  {
661  	TVHITTESTINFO tvHitInfo{};
662  	tvHitInfo.pt.x = x;
663  	tvHitInfo.pt.y = y;
664  	tvHitInfo.flags = 0;
665  	ScreenToClient(_treeView.getHSelf(), &(tvHitInfo.pt));
666  	TreeView_HitTest(_treeView.getHSelf(), &tvHitInfo);
667  	if (tvHitInfo.hItem != NULL)
668  	{
669  		_treeView.selectItem(tvHitInfo.hItem);
670  		HMENU hMenu = getMenuHandler(tvHitInfo.hItem);
671  		TrackPopupMenu(hMenu,
672  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
673  			x, y, 0, _hSelf, NULL);
674  	}
675  }
676  void ProjectPanel::showContextMenuFromMenuKey(HTREEITEM selectedItem, int x, int y)
677  {
678  	POINT p{};
679  	p.x = x;
680  	p.y = y;
681  	ClientToScreen(_treeView.getHSelf(), &p);
682  	if (selectedItem != NULL)
683  	{
684  		HMENU hMenu = getMenuHandler(selectedItem);
685  		TrackPopupMenu(hMenu,
686  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
687  			x, y, 0, _hSelf, NULL);
688  	}
689  }
690  HMENU ProjectPanel::getMenuHandler(HTREEITEM selectedItem)
691  {
692  	NodeType nodeType = getNodeType(selectedItem);
693  	HMENU hMenu = NULL;
694  	if (nodeType == nodeType_root)
695  		hMenu = _hWorkSpaceMenu;
696  	else if (nodeType == nodeType_project)
697  		hMenu = _hProjectMenu;
698  	else if (nodeType == nodeType_folder)
699  		hMenu = _hFolderMenu;
700  	else 
701  		hMenu = _hFileMenu;
702  	return hMenu;
703  }
704  POINT ProjectPanel::getMenuDisplayPoint(int iButton)
705  {
706  	POINT p{};
707  	RECT btnRect{};
708  	SendMessage(_hToolbarMenu, TB_GETITEMRECT, iButton, reinterpret_cast<LPARAM>(&btnRect));
709  	p.x = btnRect.left;
710  	p.y = btnRect.top + btnRect.bottom;
711  	ClientToScreen(_hToolbarMenu, &p);
712  	return p;
713  }
714  HTREEITEM ProjectPanel::addFolder(HTREEITEM hTreeItem, const TCHAR *folderName)
715  {
716  	HTREEITEM addedItem = _treeView.addItem(folderName, hTreeItem, INDEX_CLOSED_NODE);
717  	TreeView_Expand(_treeView.getHSelf(), hTreeItem, TVE_EXPAND);
718  	TreeView_EditLabel(_treeView.getHSelf(), addedItem);
719  	if (getNodeType(hTreeItem) == nodeType_folder)
720  		_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
721  	return addedItem;
722  }
723  bool ProjectPanel::saveWorkspaceRequest()
724  { 
725  	if (_isDirty)
726  	{
727  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
728  		int res = pNativeSpeaker->messageBox("ProjectPanelOpenDoSaveDirtyWsOrNot",
729  					_hSelf,
730  					TEXT("The current workspace was modified. Do you want to save the current project?"),
731  					TEXT("Open Workspace"),
732  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
733  		if (res == IDYES)
734  		{
735  			if (!saveWorkSpace())
736  				return false;
737  		}
738  		else if (res == IDNO)
739  		{
740  		}
741  		else if (res == IDCANCEL) 
742  		{
743  			return false;
744  		}
745  	}
746  	return true;
747  }
748  void ProjectPanel::popupMenuCmd(int cmdID)
749  {
750  	HTREEITEM hTreeItem = _treeView.getSelection();
751  	if (!hTreeItem)
752  		return;
753  	switch (cmdID)
754  	{
755  		case IDB_PROJECT_BTN:
756  		{
757  		  POINT p = getMenuDisplayPoint(0);
758  		  TrackPopupMenu(_hWorkSpaceMenu,
759  			  NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
760  			  p.x, p.y, 0, _hSelf, NULL);
761  		}
762  		break;
763  		case IDB_EDIT_BTN:
764  		{
765  			POINT p = getMenuDisplayPoint(1);
766  			HMENU hMenu = NULL;
767  			NodeType nodeType = getNodeType(hTreeItem);
768  			if (nodeType == nodeType_project)
769  				hMenu = _hProjectMenu;
770  			else if (nodeType == nodeType_folder)
771  				hMenu = _hFolderMenu;
772  			else if (nodeType == nodeType_file)
773  				hMenu = _hFileMenu;
774  			if (hMenu)
775  				TrackPopupMenu(hMenu,
776  					NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
777  					p.x, p.y, 0, _hSelf, NULL);
778  		}
779  		break;
780  		case IDM_PROJECT_NEWPROJECT :
781  		{
782  			HTREEITEM root = _treeView.getRoot();
783  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
784  			generic_string newProjectLabel = pNativeSpeaker->getAttrNameStr(PM_NEWPROJECTNAME, "ProjectManager", "NewProjectName");
785  			HTREEITEM addedItem = _treeView.addItem(newProjectLabel.c_str(),  root, INDEX_PROJECT);
786  			setWorkSpaceDirty(true);
787  			_treeView.expand(hTreeItem);
788  			TreeView_EditLabel(_treeView.getHSelf(), addedItem);
789  		}
790  		break;
791  		case IDM_PROJECT_NEWWS :
792  		{
793  			if (_isDirty)
794  			{
795  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
796  				int res = pNativeSpeaker->messageBox("ProjectPanelNewDoSaveDirtyWsOrNot",
797  					_hSelf,
798  					TEXT("The current workspace was modified. Do you want to save the current project?"),
799  					TEXT("New Workspace"),
800  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
801  				if (res == IDYES)
802  				{
803  					if (!saveWorkSpace())
804  						return;
805  				}
806  				else if (res == IDNO)
807  				{
808  				}
809  				else if (res == IDCANCEL) 
810  				{
811  					return;
812  				}
813  			}
814  			_treeView.removeAllItems();
815  			newWorkSpace();
816  		}
817  		break;
818  		case IDM_PROJECT_RENAME :
819  			TreeView_EditLabel(_treeView.getHSelf(), hTreeItem);
820  		break;
821  		case IDM_PROJECT_NEWFOLDER :
822  		{
823  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
824  			generic_string newFolderLabel = pNativeSpeaker->getAttrNameStr(PM_NEWFOLDERNAME, "ProjectManager", "NewFolderName");
825  			addFolder(hTreeItem, newFolderLabel.c_str());
826  			setWorkSpaceDirty(true);
827  		}
828  		break;
829  		case IDM_PROJECT_MOVEDOWN :
830  		{
831  			if (_treeView.moveDown(hTreeItem))
832  				setWorkSpaceDirty(true);
833  		}
834  		break;
835  		case IDM_PROJECT_MOVEUP :
836  		{
837  			if (_treeView.moveUp(hTreeItem))
838  				setWorkSpaceDirty(true);
839  		}
840  		break;
841  		case IDM_PROJECT_ADDFILES :
842  		{
843  			addFiles(hTreeItem);
844  			if (getNodeType(hTreeItem) == nodeType_folder)
845  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
846  		}
847  		break;
848  		case IDM_PROJECT_ADDFILESRECUSIVELY :
849  		{
850  			addFilesFromDirectory(hTreeItem);
851  			if (getNodeType(hTreeItem) == nodeType_folder)
852  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
853  		}
854  		break;
855  		case IDM_PROJECT_OPENWS:
856  		{
857  			if (!saveWorkspaceRequest())
858  				break;
859  			CustomFileDialog fDlg(_hSelf);
860  			setFileExtFilter(fDlg);
861  			const generic_string fn = fDlg.doOpenSingleFileDlg();
862  			if (!fn.empty())
863  			{
864  				if (!openWorkSpace(fn.c_str(), true))
865  				{
866  					NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
867  					pNativeSpeaker->messageBox("ProjectPanelOpenFailed",
868  						_hSelf,
869  						TEXT("The workspace could not be opened.\rIt seems the file to open is not a valid project file."),
870  						TEXT("Open Workspace"),
871  						MB_OK);
872  					return;
873  				}
874  			}
875  		}
876  		break;
877  		case IDM_PROJECT_RELOADWS:
878  		{
879  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
880  			bool forceOpen = false;
881  			if (_isDirty)
882  			{
883  				int res = pNativeSpeaker->messageBox("ProjectPanelReloadDirty",
884  					_hSelf,
885  					TEXT("The current workspace was modified. Reloading will discard all modifications.\rDo you want to continue?"),
886  					TEXT("Reload Workspace"),
887  					MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);
888  				if (res == IDYES)
889  				{
890  					forceOpen = true;
891  				}
892  				else if (res == IDNO)
893  				{
894  					return;
895  				}
896  			}
897  			if (::PathFileExists(_workSpaceFilePath.c_str()))
898  			{
899  				openWorkSpace(_workSpaceFilePath.c_str(), forceOpen);
900  			}
901  			else
902  			{
903  				pNativeSpeaker->messageBox("ProjectPanelReloadError",
904  					_hSelf,
905  					TEXT("Cannot find the file to reload."),
906  					TEXT("Reload Workspace"),
907  					MB_OK);
908  			}
909  		}
910  		break;
911  		case IDM_PROJECT_SAVEWS:
912  			saveWorkSpace();
913  		break;
914  		case IDM_PROJECT_SAVEACOPYASWS:
915  		case IDM_PROJECT_SAVEASWS:
916  		{
917  			saveWorkSpaceAs(cmdID == IDM_PROJECT_SAVEACOPYASWS);
918  		}
919  		break;
920  		case IDM_PROJECT_FINDINPROJECTSWS:
921  		{
922  			::SendMessage(_hParent, NPPM_INTERNAL_FINDINPROJECTS, (WPARAM) 1 << _panelID, 0);
923  		}
924  		break;
925  		case IDM_PROJECT_DELETEFOLDER :
926  		{
927  			HTREEITEM parent = _treeView.getParent(hTreeItem);
928  			if (_treeView.getChildFrom(hTreeItem) != NULL)
929  			{
930  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
931  				int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFolderFromProject",
932  					_hSelf,
933  					TEXT("All the sub-items will be removed.\rAre you sure you want to remove this folder from the project?"),
934  					TEXT("Remove folder from project"),
935  					MB_YESNO);
936  				if (res == IDYES)
937  				{
938  					_treeView.removeItem(hTreeItem);
939  					setWorkSpaceDirty(true);
940  				}
941  			}
942  			else
943  			{
944  				_treeView.removeItem(hTreeItem);
945  				setWorkSpaceDirty(true);
946  			}
947  			if (getNodeType(parent) == nodeType_folder)
948  				_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
949  		}
950  		break;
951  		case IDM_PROJECT_DELETEFILE :
952  		{
953  			HTREEITEM parent = _treeView.getParent(hTreeItem);
954  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
955  			int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFileFromProject",
956  				_hSelf,
957  				TEXT("Are you sure you want to remove this file from the project?"),
958  				TEXT("Remove file from project"),
959  				MB_YESNO);
960  			if (res == IDYES)
961  			{
962  				_treeView.removeItem(hTreeItem);
963  				setWorkSpaceDirty(true);
964  				if (getNodeType(parent) == nodeType_folder)
965  					_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
966  			}
967  		}
968  		break;
969  		case IDM_PROJECT_MODIFYFILEPATH :
970  		{
971  			FileRelocalizerDlg fileRelocalizerDlg;
972  			fileRelocalizerDlg.init(_hInst, _hParent);
973  			TCHAR textBuffer[MAX_PATH] = { '\0' };
974  			TVITEM tvItem{};
975  			tvItem.hItem = hTreeItem;
976  			tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
977  			tvItem.pszText = textBuffer;
978  			tvItem.cchTextMax = MAX_PATH;
979  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
980  			if (!tvItem.lParam)
981  				return;
982  			generic_string * fn = (generic_string *)tvItem.lParam;
983  			if (fileRelocalizerDlg.doDialog(fn->c_str()) == 0)
984  			{
985  				generic_string newValue = fileRelocalizerDlg.getFullFilePath();
986  				if (*fn == newValue)
987  					return;
988  				*fn = newValue;
989  				TCHAR *strValueLabel = ::PathFindFileName(fn->c_str());
990  				wcscpy_s(textBuffer, strValueLabel);
991  				int iImage = ::PathFileExists(fn->c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
992  				tvItem.iImage = tvItem.iSelectedImage = iImage;
993  				SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
994  				setWorkSpaceDirty(true);
995  			}
996  		}
997  		break;
998  	}
999  }
1000  bool ProjectPanel::saveWorkSpaceAs(bool saveCopyAs)
1001  {
1002  	CustomFileDialog fDlg(_hSelf);
1003  	setFileExtFilter(fDlg);
1004  	fDlg.setExtIndex(0);		
1005  	const generic_string fn = fDlg.doSaveDlg();
1006  	if (fn.empty())
1007  		return false;
1008  	if (!writeWorkSpace(fn.c_str(), !saveCopyAs))
1009  		return false;
1010  	if (!saveCopyAs)
1011  	{
1012  		_workSpaceFilePath = fn;
1013  		setWorkSpaceDirty(false);
1014  	}
1015  	return true;
1016  }
1017  void ProjectPanel::setFileExtFilter(CustomFileDialog & fDlg)
1018  {
1019  	const TCHAR *ext = NppParameters::getInstance().getNppGUI()._definedWorkspaceExt.c_str();
1020  	generic_string workspaceExt = TEXT("");
1021  	if (*ext != '\0')
1022  	{
1023  		if (*ext != '.')
1024  			workspaceExt += TEXT(".");
1025  		workspaceExt += ext;
1026  		fDlg.setExtFilter(TEXT("Workspace file"), workspaceExt.c_str());
1027  		fDlg.setDefExt(ext);
1028  	}
1029  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1030  }
1031  void ProjectPanel::addFiles(HTREEITEM hTreeItem)
1032  {
1033  	CustomFileDialog fDlg(_hSelf);
1034  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1035  	const auto& fns = fDlg.doOpenMultiFilesDlg();
1036  	if (!fns.empty())
1037  	{
1038  		size_t sz = fns.size();
1039  		for (size_t i = 0 ; i < sz ; ++i)
1040  		{
1041  			TCHAR *strValueLabel = ::PathFindFileName(fns.at(i).c_str());
1042  			generic_string* pathFileStr = new generic_string(fns.at(i));
1043  			fullPathStrs.push_back(pathFileStr);
1044  			LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1045  			_treeView.addItem(strValueLabel, hTreeItem, INDEX_LEAF, lParamPathFileStr);
1046  		}
1047  		_treeView.expand(hTreeItem);
1048  		setWorkSpaceDirty(true);
1049  	}
1050  }
1051  void ProjectPanel::recursiveAddFilesFrom(const TCHAR *folderPath, HTREEITEM hTreeItem)
1052  {
1053  	bool isRecursive = true;
1054  	bool isInHiddenDir = false;
1055  	generic_string dirFilter(folderPath);
1056  	if (folderPath[lstrlen(folderPath)-1] != '\\')
1057  		dirFilter += TEXT("\\");
1058  	dirFilter += TEXT("*.*");
1059  	WIN32_FIND_DATA foundData;
1060  	std::vector<generic_string> files;
1061  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
1062  	do {
1063  		if (hFile == INVALID_HANDLE_VALUE)
1064  			break;
1065  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1066  		{
1067  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1068  			{
1069  			}
1070  			else if (isRecursive)
1071  			{
1072  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0))
1073  				{
1074  					generic_string pathDir(folderPath);
1075  					if (folderPath[lstrlen(folderPath)-1] != '\\')
1076  						pathDir += TEXT("\\");
1077  					pathDir += foundData.cFileName;
1078  					pathDir += TEXT("\\");
1079  					HTREEITEM addedItem = addFolder(hTreeItem, foundData.cFileName);
1080  					recursiveAddFilesFrom(pathDir.c_str(), addedItem);
1081  				}
1082  			}
1083  		}
1084  		else
1085  		{
1086  			files.push_back(foundData.cFileName);
1087  		}
1088  	} while (::FindNextFile(hFile, &foundData));
1089  	for (size_t i = 0, len = files.size() ; i < len ; ++i)
1090  	{
1091  		generic_string pathFile(folderPath);
1092  		if (folderPath[lstrlen(folderPath)-1] != '\\')
1093  			pathFile += TEXT("\\");
1094  		pathFile += files[i];
1095  		generic_string* pathFileStr = new generic_string(pathFile);
1096  		fullPathStrs.push_back(pathFileStr);
1097  		LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1098  		_treeView.addItem(files[i].c_str(), hTreeItem, INDEX_LEAF, lParamPathFileStr);
1099  	}
1100  	::FindClose(hFile);
1101  }
1102  void ProjectPanel::addFilesFromDirectory(HTREEITEM hTreeItem)
1103  {
1104  	if (_selDirOfFilesFromDirDlg == TEXT("") && _workSpaceFilePath != TEXT(""))
1105  	{
1106  		TCHAR dir[MAX_PATH] = { '\0' };
1107  		wcscpy_s(dir, _workSpaceFilePath.c_str());
1108  		::PathRemoveFileSpec(dir);
1109  		_selDirOfFilesFromDirDlg = dir;
1110  	}
1111  	generic_string dirPath;
1112  	if (_selDirOfFilesFromDirDlg != TEXT(""))
1113  		dirPath = getFolderName(_hSelf, _selDirOfFilesFromDirDlg.c_str());
1114  	else
1115  		dirPath = getFolderName(_hSelf);
1116  	if (dirPath != TEXT(""))
1117  	{
1118  		recursiveAddFilesFrom(dirPath.c_str(), hTreeItem);
1119  		_treeView.expand(hTreeItem);
1120  		setWorkSpaceDirty(true);
1121  		_selDirOfFilesFromDirDlg = dirPath;
1122  	}
1123  }
1124  intptr_t CALLBACK FileRelocalizerDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM) 
1125  {
1126  	switch (Message)
1127  	{
1128  		case WM_INITDIALOG:
1129  		{
1130  			::SetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, _fullFilePath.c_str());
1131  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
1132  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
1133  			return TRUE;
1134  		}
1135  		case WM_ERASEBKGND:
1136  		{
1137  			if (NppDarkMode::isEnabled())
1138  			{
1139  				RECT rect{};
1140  				GetClientRect(_hSelf, &rect);
1141  				::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
1142  				return TRUE;
1143  			}
1144  			break;
1145  		}
1146  		case WM_CTLCOLOREDIT:
1147  		{
1148  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1149  		}
1150  		case WM_PRINTCLIENT:
1151  		{
1152  			if (NppDarkMode::isEnabled())
1153  			{
1154  				return TRUE;
1155  			}
1156  			break;
1157  		}
1158  		case WM_COMMAND:
1159  		{
1160  			switch (wParam)
1161  			{
1162  				case IDOK :
1163  				{
1164  					TCHAR textBuf[MAX_PATH] = { '\0' };
1165  					::GetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, textBuf, MAX_PATH);
1166  					_fullFilePath = textBuf;
1167  					::EndDialog(_hSelf, 0);
1168  				}
1169  				return TRUE;
1170  				case IDCANCEL :
1171  					::EndDialog(_hSelf, -1);
1172  				return TRUE;
1173  				default:
1174  					return FALSE;
1175  			}
1176  		}
1177  		default :
1178  			return FALSE;
1179  	}
1180  	return FALSE;
1181  }
1182  int FileRelocalizerDlg::doDialog(const TCHAR *fn, bool isRTL)
1183  {
1184  	_fullFilePath = fn;
1185  	if (isRTL)
1186  	{
1187  		DLGTEMPLATE *pMyDlgTemplate = NULL;
1188  		HGLOBAL hMyDlgTemplate = makeRTLResource(IDD_FILERELOCALIZER_DIALOG, &pMyDlgTemplate);
1189  		int result = static_cast<int32_t>(::DialogBoxIndirectParam(_hInst, pMyDlgTemplate, _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1190  		::GlobalFree(hMyDlgTemplate);
1191  		return result;
1192  	}
1193  	return static_cast<int32_t>(::DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_FILERELOCALIZER_DIALOG), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dict.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>695      if (dawg_args.updated_dawgs == &(active_dawgs[1])) {
696        dawg_args.updated_dawgs = &(active_dawgs[0]);
697        ++(dawg_args.active_dawgs);
698      } else {
699        ++(dawg_args.updated_dawgs);
700        dawg_args.active_dawgs = &(active_dawgs[0]);
701      }
702    }
</pre></code></div>
                <div class="column column_space"><pre><code>476  		if (::PathFileExists(fn->c_str()))
477  		{
478  			::PostMessage(_hParent, NPPM_DOOPEN, 0, reinterpret_cast<LPARAM>(fn->c_str()));
479  			tvItem.iImage = INDEX_LEAF;
480  			tvItem.iSelectedImage = INDEX_LEAF;
481  		}
482  		else
483  		{
484  			tvItem.iImage = INDEX_LEAF_INVALID;
485  			tvItem.iSelectedImage = INDEX_LEAF_INVALID;
486  		}
487  		TreeView_SetItem(_treeView.getHSelf(), &tvItem);
488  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    