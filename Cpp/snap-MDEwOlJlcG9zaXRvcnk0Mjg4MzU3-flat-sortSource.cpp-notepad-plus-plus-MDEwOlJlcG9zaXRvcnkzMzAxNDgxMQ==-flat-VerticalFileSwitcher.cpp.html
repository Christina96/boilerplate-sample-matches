
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.4055727554179565%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sortSource.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  int main(int argc,char* argv[]) {
3    TTableContext Context;
4    Schema TimeS;
5    TimeS.Add(TPair<TStr,TAttrType>("Source",atInt));
6    TimeS.Add(TPair<TStr,TAttrType>("Dest",atInt));
7    TimeS.Add(TPair<TStr,TAttrType>("Start",atInt));
8    TimeS.Add(TPair<TStr,TAttrType>("Duration",atInt));
9    PTable P1 = TTable::LoadSS(TimeS,"./../../../../datasets/temporal/yemen_call_201001.txt",&Context,' ');
10    TIntV MapV;
11    TStrV SortBy;
12    SortBy.Add("Source");
13    P1->Order(SortBy);
14    TIntV Source; 
15    P1->ReadIntCol("Source",Source);
16    for (TRowIterator RI = P1->BegRI(); RI < P1->EndRI(); RI++) {
17      MapV.Add(RI.GetRowIdx());
18    }
19    TInt SIdx = P1->GetColIdx("Source");
20    TInt DIdx = P1->GetColIdx("Dest");
21    TInt StIdx = P1->GetColIdx("Start");
22    TInt DuIdx = P1->GetColIdx("Duration");
23    int W = atoi(argv[1]);
24    int len = 0;
25    int TSource = atoi(argv[2]);
26    int TDest = atoi(argv[3]);
27    int TStart = atoi(argv[4]);
28    int TDur = atoi(argv[5]);
29    TInt RIdx;
30    for (TRowIterator RI = P1->BegRI(); RI < P1->EndRI(); RI++) {
31      RIdx = RI.GetRowIdx();
32      int RSource = P1->GetIntValAtRowIdx(SIdx,RIdx).Val;
33      int RDest = P1->GetIntValAtRowIdx(DIdx,RIdx).Val;
34      int RStart = P1->GetIntValAtRowIdx(StIdx,RIdx).Val;
35      int RDur = P1->GetIntValAtRowIdx(DuIdx,RIdx).Val;
36      if (TSource == RSource && TDest == RDest && TStart == RStart && TDur == RDur) break;
37    }
38    clock_t st,et;
39    st = clock();
40    for (int i = 0; i < 1; i++) {
41      THashSet<TInt> VisitedH;
42      TSnapQueue<TInt> EventQ;
43      EventQ.Push(RIdx);
44      VisitedH.AddKey(RIdx);
45      while (!EventQ.Empty()) {
46        TInt CIdx = EventQ.Top();
47        EventQ.Pop();
48        int CDest = P1->GetIntValAtRowIdx(DIdx,CIdx).Val;
49        int CStart = P1->GetIntValAtRowIdx(StIdx,CIdx).Val;
50        int CDur = P1->GetIntValAtRowIdx(DuIdx,CIdx).Val;
51        int val = CDest;
52        int lo = 0;
53        int hi = Source.Len() - 1;
54        int index = -1;
55        while (hi >= lo) {
<span onclick='openModal()' class='match'>56          int mid = lo + (hi - lo)/2;
57          if (Source.GetVal(mid) > val) { hi = mid - 1;}
58          else if (Source.GetVal(mid) < val) { lo = mid + 1;}
59          else { index = mid; hi = mid - 1;}
</span>60        } 
61        int BIdx = index;
62        for(int i = BIdx; i < Source.Len(); i++) {
63          int PId = MapV.GetVal(i).Val;
64          if (! VisitedH.IsKey(PId)) {
65            int TSource = P1->GetIntValAtRowIdx(SIdx,PId).Val;
66            int TStart = P1->GetIntValAtRowIdx(StIdx,PId).Val;
67            if (TSource != CDest) {
68              break;
69            }
70            if (TStart >= (CDur + CStart) && TStart - (CDur + CStart) <= W) {
71              VisitedH.AddKey(PId);
72              EventQ.Push(PId);
73            }
74          }
75        }
76      }
77      len = VisitedH.Len();
78    }
79    et = clock();
80    float diff = ((float) et - (float) st)/CLOCKS_PER_SEC;
81    printf("Size %d,Time %f\n",len,diff);
82    return 0;
83  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-VerticalFileSwitcher.cpp</h3>
            <pre><code>1  #include "VerticalFileSwitcher.h"
2  #include "menuCmdID.h"
3  #include "Parameters.h"
4  #include "resource.h"
5  #include "localization.h"
6  #define GET_X_LPARAM(lp) static_cast<short>(LOWORD(lp))
7  #define GET_Y_LPARAM(lp) static_cast<short>(HIWORD(lp))
8  #define CLMNEXT_ID     1
9  #define CLMNPATH_ID    2
10  #define SEP_POS        3
11  #define LVGROUPS_ID    4
12  COLORREF VerticalFileSwitcher::_bgColor = 0xFFFFFF;
13  int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
14  {
15  	sortCompareData* sortData = (sortCompareData*)lParamSort;
16  	TCHAR str1[MAX_PATH] = { '\0' };
17  	TCHAR str2[MAX_PATH] = { '\0' };
18  	ListView_GetItemText(sortData->hListView, lParam1, sortData->columnIndex, str1, sizeof(str1));
19  	ListView_GetItemText(sortData->hListView, lParam2, sortData->columnIndex, str2, sizeof(str2));
20  	int result = lstrcmp(str1, str2);
21  	if (sortData->sortDirection == SORT_DIRECTION_UP)
22  		return result;
23  	return (0 - result);
24  }
25  LRESULT run_listViewProc(WNDPROC oldEditProc, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
26  {
27  	switch (message)
28  	{
29  		case WM_MBUTTONUP:
30  		{
31  			::SendMessage(::GetParent(hwnd), WM_PARENTNOTIFY, WM_MBUTTONUP, lParam);
32  			return TRUE;
33  		}
34  		default:
35  			break;
36  	}
37  	return ::CallWindowProc(oldEditProc, hwnd, message, wParam, lParam);
38  }
39  void VerticalFileSwitcher::startColumnSort()
40  {
41  	HWND colHeader = reinterpret_cast<HWND>(SendMessage(_fileListView.getHSelf(), LVM_GETHEADER, 0, 0));
42  	int columnCount = static_cast<int32_t>(SendMessage(colHeader, HDM_GETITEMCOUNT, 0, 0));
43  	if (_lastSortingColumn >= columnCount)
44  	{
45  		_lastSortingColumn = 0;
46  		_lastSortingDirection = SORT_DIRECTION_NONE;
47  	}
48  	if (_lastSortingDirection != SORT_DIRECTION_NONE)
49  	{
50  		sortCompareData sortData = {_fileListView.getHSelf(), _lastSortingColumn, _lastSortingDirection};
51  		ListView_SortItemsEx(_fileListView.getHSelf(), ListViewCompareProc, reinterpret_cast<LPARAM>(&sortData));
52  	}
53  	updateHeaderArrow();
54  }
55  LRESULT VerticalFileSwitcher::listViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
56  {
57  	auto lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
58  	switch (lplvcd->nmcd.dwDrawStage)
59  	{
60  		case CDDS_PREPAINT:
61  		{
62  			if ((lplvcd->dwItemType == LVCDI_GROUP) && NppDarkMode::isThemeDark())
63  			{
64  				RECT rcHeader{};
65  				ListView_GetGroupRect(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVGGR_HEADER, &rcHeader);
66  				HBRUSH hBrush = ::CreateSolidBrush(VerticalFileSwitcher::_bgColor);
67  				::FillRect(lplvcd->nmcd.hdc, &rcHeader, hBrush);
68  				::DeleteObject(hBrush);
69  				hBrush = nullptr;
70  			}
71  			return CDRF_NOTIFYITEMDRAW;
72  		}
73  		case CDDS_ITEMPREPAINT:
74  		{
75  			const RECT& rcRow = lplvcd->nmcd.rc;
76  			const bool isThemeDark = NppDarkMode::isThemeDark();
77  			const auto hHeader = ListView_GetHeader(lplvcd->nmcd.hdr.hwndFrom);
78  			const auto colCount = Header_GetItemCount(hHeader);
79  			const LONG paddingLeft = isThemeDark ? 1 : 0;
80  			const LONG paddingRight = isThemeDark ? 2 : 1;
81  			RECT rcSubItem{ rcRow };
82  			RECT rcSubItem2{};
83  			RECT rcSubItem3{};
84  			rcSubItem.right -= paddingRight;
85  			auto setRectForSubItem = [hHeader, paddingLeft, paddingRight](RECT& first, RECT& second, int idxSecond) -> void {
86  				Header_GetItemRect(hHeader, idxSecond, &second);
87  				first.right = second.left - paddingRight;
88  				second.left -= paddingLeft;
89  				second.right -= paddingRight;
90  				second.top = first.top;
91  				second.bottom = first.bottom;
92  			};
93  			if (colCount >= 2)
94  			{
95  				setRectForSubItem(rcSubItem, rcSubItem2, 1);
96  			}
97  			if (colCount == 3)
98  			{
99  				setRectForSubItem(rcSubItem2, rcSubItem3, 2);
100  			}
101  			const auto isSelected = ListView_GetItemState(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
102  			const bool isHot = (lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT;
103  			const int colorID = reinterpret_cast<TaskLstFnStatus*>(lplvcd->nmcd.lItemlParam)->_docColor;
104  			COLORREF bgColor{0xFFFFFF};
105  			bool applyColor = false;
106  			if (colorID != -1)
107  			{
108  				bgColor = NppDarkMode::getIndividualTabColour(colorID, isThemeDark, false);
109  				applyColor = true;
110  			}
111  			else if (isThemeDark)
112  			{
113  				if (isSelected)
114  				{
115  					bgColor = NppDarkMode::getSofterBackgroundColor();
116  					applyColor = true;
117  				}
118  				else if (isHot)
119  				{
120  					bgColor = NppDarkMode::getHotBackgroundColor();
121  					applyColor = true;
122  				}
123  			}
124  			if (applyColor)
125  			{
126  				if (isThemeDark)
127  				{
128  					lplvcd->clrText = NppDarkMode::getTextColor();
129  				}
130  				lplvcd->clrTextBk = bgColor;
131  				HBRUSH hBrush = ::CreateSolidBrush(bgColor);
132  				::FillRect(lplvcd->nmcd.hdc, &rcSubItem, hBrush);
133  				if (colCount >= 2)
134  				{
135  					::FillRect(lplvcd->nmcd.hdc, &rcSubItem2, hBrush);
136  				}
137  				if (colCount == 3)
138  				{
139  					::FillRect(lplvcd->nmcd.hdc, &rcSubItem3, hBrush);
140  				}
141  				::DeleteObject(hBrush);
142  				hBrush = nullptr;
143  			}
144  			if (isSelected)
145  			{
146  				::DrawFocusRect(lplvcd->nmcd.hdc, &rcRow);
147  			} 
148  			else if (isHot)
149  			{
150  				::FrameRect(lplvcd->nmcd.hdc, &rcRow, isThemeDark ? NppDarkMode::getHotEdgeBrush() : ::GetSysColorBrush(COLOR_WINDOWTEXT));
151  			}
152  			return CDRF_NEWFONT;
153  		}
154  		default:
155  			break;
156  	}
157  	return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
158  }
159  LRESULT CALLBACK VerticalFileSwitcher::FileSwitcherNotifySubclass(
160  	HWND hWnd,
161  	UINT uMsg,
162  	WPARAM wParam,
163  	LPARAM lParam,
164  	UINT_PTR uIdSubclass,
165  	DWORD_PTR &bsol;*dwRefData*/
166  )
167  {
168  	switch (uMsg)
169  	{
170  		case WM_NCDESTROY:
171  		{
172  			::RemoveWindowSubclass(hWnd, VerticalFileSwitcher::FileSwitcherNotifySubclass, uIdSubclass);
173  			break;
174  		}
175  		case WM_NOTIFY:
176  		{
177  			auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
178  			switch (nmhdr->code)
179  			{
180  				case NM_CUSTOMDRAW:
181  				{
182  					constexpr size_t classNameLen = 16;
183  					wchar_t className[classNameLen]{};
184  					GetClassName(nmhdr->hwndFrom, className, classNameLen);
185  					if (wcscmp(className, WC_LISTVIEW) == 0)
186  					{
187  						return VerticalFileSwitcher::listViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
188  					}
189  					break;
190  				}
191  			}
192  			break;
193  		}
194  	}
195  	return DefSubclassProc(hWnd, uMsg, wParam, lParam);
196  }
197  void VerticalFileSwitcher::autoSubclassWindowNotify(HWND hParent)
198  {
199  	::SetWindowSubclass(hParent, VerticalFileSwitcher::FileSwitcherNotifySubclass, _fileSwitcherNotifySubclassID, 0);
200  }
201  intptr_t CALLBACK VerticalFileSwitcher::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
202  {
203  	switch (message)
204  	{
205  		case WM_INITDIALOG :
206  		{
207  			VerticalFileSwitcher::initPopupMenus();
208  			_fileListView.init(_hInst, _hSelf, _hImaLst);
209  			_fileListView.initList();
210  			_fileListView.display();
211  			::SetWindowLongPtr(_fileListView.getHSelf(), GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
212  			_defaultListViewProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_fileListView.getHSelf(), GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(listViewStaticProc)));
213  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
214  			VerticalFileSwitcher::autoSubclassWindowNotify(_hSelf);
215  			return TRUE;
216  		}
217  		case NPPM_INTERNAL_REFRESHDARKMODE:
218  		{
219  			NppDarkMode::autoThemeChildControls(_hSelf);
220  			return TRUE;
221  		}
222  		case WM_PARENTNOTIFY:
223  		{
224  			switch ( wParam )
225  			{
226  				case WM_MBUTTONUP:
227  				{
228  					LVHITTESTINFO hitInfo{};
229  					hitInfo.pt.x = GET_X_LPARAM(lParam);
230  					hitInfo.pt.y = GET_Y_LPARAM(lParam);
231  					::ClientToScreen(getHSelf(), &hitInfo.pt);
232  					::ScreenToClient(_fileListView.getHSelf(), &hitInfo.pt);
233  					ListView_HitTest(_fileListView.getHSelf(), &hitInfo);
234  					if (hitInfo.iItem != -1)
235  					{
236  						LVITEM item{};
237  						item.mask = LVIF_PARAM;
238  						item.iItem = hitInfo.iItem;	
239  						ListView_GetItem(_fileListView.getHSelf(), &item);
240  						TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
241  						closeDoc(tlfs);
242  						return TRUE;
243  					}
244  				}
245  			}
246  			break;
247  		}
248  		case WM_NOTIFY:
249  		{
250  			switch (reinterpret_cast<LPNMHDR>(lParam)->code)
251  			{
252  				case DMN_CLOSE:
253  				{
254  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DOCLIST, 0);
255  					return TRUE;
256  				}
257  				case NM_DBLCLK:
258  				{
259  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
260  					int i = lpnmitem->iItem;
261  					if (i == -1)
262  					{
263  						::SendMessage(_hParent, WM_COMMAND, IDM_FILE_NEW, 0);
264  					}
265  					return TRUE;
266  				}
267  				case NM_CLICK:
268  				{
269  					if ((0x80 & GetKeyState(VK_CONTROL)) || (0x80 & GetKeyState(VK_SHIFT)))
270  						return TRUE;
271  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
272  					int nbItem = ListView_GetItemCount(_fileListView.getHSelf());
273  					int i = lpnmitem->iItem;
274  					if (i == -1 || i >= nbItem)
275  						return TRUE;
276  					LVITEM item{};
277  					item.mask = LVIF_PARAM;
278  					item.iItem = i;
279  					ListView_GetItem(((LPNMHDR)lParam)->hwndFrom, &item);
280  					TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
281  					activateDoc(tlfs);
282  					return TRUE;
283  				}
284  				case NM_RCLICK :
285  				{
286  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
287  					if (lpnmitem->hdr.hwndFrom != _fileListView.getHSelf())
288  					{
289  						colHeaderRClick = true;
290  						return TRUE;
291  					}
292  					int nbItem = ListView_GetItemCount(_fileListView.getHSelf());
293  					if (nbSelectedFiles() == 1)
294  					{
295  						int i = lpnmitem->iItem;
296  						if (i == -1 || i >= nbItem)
297   							return TRUE;
298  						LVITEM item{};
299  						item.mask = LVIF_PARAM;
300  						item.iItem = i;
301  						ListView_GetItem(((LPNMHDR)lParam)->hwndFrom, &item);
302  						TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
303  						activateDoc(tlfs);
304  					}
305  					if (nbSelectedFiles() >= 1)
306  					{
307  						NMHDR nmhdr{};
308  						nmhdr.code = reinterpret_cast<LPNMHDR>(lParam)->code; 
309  						nmhdr.hwndFrom = _hSelf;
310  						nmhdr.idFrom = ::GetDlgCtrlID(nmhdr.hwndFrom);
311  						::SendMessage(_hParent, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
312  					}
313  					return TRUE;
314  				}
315  				case LVN_GETINFOTIP:
316  				{
317  					LPNMLVGETINFOTIP pGetInfoTip = (LPNMLVGETINFOTIP)lParam;
318  					int i = pGetInfoTip->iItem;
319  					if (i == -1)
320  						return TRUE;
321  					generic_string fn = getFullFilePath((size_t)i);
322  					lstrcpyn(pGetInfoTip->pszText, fn.c_str(), pGetInfoTip->cchTextMax);
323  					return TRUE;
324  				}
325  				case LVN_COLUMNCLICK:
326  				{
327  					LPNMLISTVIEW pnmLV = (LPNMLISTVIEW)lParam;
328  					_lastSortingDirection = setHeaderOrder(pnmLV->iSubItem);
329  					_lastSortingColumn = pnmLV->iSubItem;
330  					if (_lastSortingDirection != SORT_DIRECTION_NONE)
331  					{
332  						startColumnSort();
333  					}
334  					else
335  					{
336  						_fileListView.reload();
337  						updateHeaderArrow();
338  					}
339  					return TRUE;
340  				}
341  				case HDN_DIVIDERDBLCLICK:
342  				case HDN_ENDTRACK:
343  				{
344  					NppParameters& nppParams = NppParameters::getInstance();
345  					NativeLangSpeaker* pNativeSpeaker = nppParams.getNativeLangSpeaker();
346  					LPNMHEADER test = (LPNMHEADER)lParam;
347  					HWND hwndHD = ListView_GetHeader(_fileListView.getHSelf());
348  					TCHAR HDtext[MAX_PATH] = { '\0' };
349  					HDITEM hdi = {};
350  					hdi.mask = HDI_TEXT | HDI_WIDTH;
351  					hdi.pszText = HDtext;
352  					hdi.cchTextMax = MAX_PATH;
353  					Header_GetItem(hwndHD, test->iItem, &hdi);
354  					if (hdi.pszText == pNativeSpeaker->getAttrNameStr(TEXT("Ext."), FS_ROOTNODE, FS_CLMNEXT))
355  						nppParams.getNppGUI()._fileSwitcherExtWidth = hdi.cxy;
356  					else if (hdi.pszText == pNativeSpeaker->getAttrNameStr(TEXT("Path"), FS_ROOTNODE, FS_CLMNPATH))
357  						nppParams.getNppGUI()._fileSwitcherPathWidth = hdi.cxy;
358  					return TRUE;
359  				}
360  				case LVN_KEYDOWN:
361  				{
362  					switch (((LPNMLVKEYDOWN)lParam)->wVKey)
363  					{
364  						case VK_RETURN:
365  						{
366  							int i = ListView_GetSelectionMark(_fileListView.getHSelf());
367  							if (i == -1)
368  								return TRUE;
369  							LVITEM item{};
370  							item.mask = LVIF_PARAM;
371  							item.iItem = i;	
372  							ListView_GetItem(((LPNMHDR)lParam)->hwndFrom, &item);
373  							TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
374  							activateDoc(tlfs);
375  							return TRUE;
376  						}
377  						default:
378  							break;
379  					}
380  				}
381  				break;
382  				default:
383  					break;
384  			}
385  		}
386  		return TRUE;
387          case WM_SIZE:
388          {
389  			int width = LOWORD(lParam);
390              int height = HIWORD(lParam);
391  			::MoveWindow(_fileListView.getHSelf(), 0, 0, width, height, TRUE);
392  			_fileListView.resizeColumns(width);
393              break;
394          }
395  		case WM_CONTEXTMENU:
396  		{
397  			if (nbSelectedFiles() == 0 || colHeaderRClick)
398  			{
399  				::TrackPopupMenu(_hGlobalMenu, 
400  					NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
401  					GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0, _hSelf, NULL);
402  				colHeaderRClick = false;
403  			}
404  			return TRUE;
405  		}
406  		case WM_COMMAND:
407  		{
408  			popupMenuCmd(LOWORD(wParam));
409  			break;
410  		}
411  		case WM_DESTROY:
412          {
413  			_fileListView.destroy();
414  			::DestroyMenu(_hGlobalMenu);
415              break;
416          }
417          default :
418              return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
419      }
420  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
421  }
422  void VerticalFileSwitcher::initPopupMenus()
423  {
424  	NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
425  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
426  	generic_string extStr = pNativeSpeaker->getAttrNameStr(TEXT("Ext."), FS_ROOTNODE, FS_CLMNEXT);
427  	generic_string pathStr = pNativeSpeaker->getAttrNameStr(TEXT("Path"), FS_ROOTNODE, FS_CLMNPATH);
428  	generic_string groupStr = pNativeSpeaker->getAttrNameStr(TEXT("Group by View"), FS_ROOTNODE, FS_LVGROUPS);
429  	_hGlobalMenu = ::CreatePopupMenu();
430  	::InsertMenu(_hGlobalMenu, CLMNEXT_ID, MF_BYCOMMAND | MF_STRING, CLMNEXT_ID, extStr.c_str());
431  	::InsertMenu(_hGlobalMenu, CLMNPATH_ID, MF_BYCOMMAND | MF_STRING, CLMNPATH_ID, pathStr.c_str());
432  	::InsertMenu(_hGlobalMenu, SEP_POS, MF_BYCOMMAND | MF_SEPARATOR, 0, nullptr);
433  	::InsertMenu(_hGlobalMenu, LVGROUPS_ID, MF_BYCOMMAND | MF_STRING, LVGROUPS_ID, groupStr.c_str());
434  	bool isExtColumn = nppGUI._fileSwitcherWithoutExtColumn;
435  	::CheckMenuItem(_hGlobalMenu, CLMNEXT_ID, MF_BYCOMMAND | (isExtColumn ? MF_UNCHECKED : MF_CHECKED));
436  	bool isPathColumn = nppGUI._fileSwitcherWithoutPathColumn;
437  	::CheckMenuItem(_hGlobalMenu, CLMNPATH_ID, MF_BYCOMMAND | (isPathColumn ? MF_UNCHECKED : MF_CHECKED));
438  	bool isListViewGroups = nppGUI._fileSwitcherDisableListViewGroups;
439  	::CheckMenuItem(_hGlobalMenu, LVGROUPS_ID, MF_BYCOMMAND | (isListViewGroups ? MF_UNCHECKED : MF_CHECKED));
440  }
441  void VerticalFileSwitcher::popupMenuCmd(int cmdID)
442  {
443  	switch (cmdID)
444  	{
445  		case CLMNEXT_ID:
446  		{
447  			bool& isExtColumn = NppParameters::getInstance().getNppGUI()._fileSwitcherWithoutExtColumn;
448  			isExtColumn = !isExtColumn;
449  			::CheckMenuItem(_hGlobalMenu, CLMNEXT_ID, MF_BYCOMMAND | (isExtColumn ? MF_UNCHECKED : MF_CHECKED));
450  			reload();
451  		}
452  		break;
453  		case CLMNPATH_ID:
454  		{
455  			bool& isPathColumn = NppParameters::getInstance().getNppGUI()._fileSwitcherWithoutPathColumn;
456  			isPathColumn = !isPathColumn;
457  			::CheckMenuItem(_hGlobalMenu, CLMNPATH_ID, MF_BYCOMMAND | (isPathColumn ? MF_UNCHECKED : MF_CHECKED));
458  			reload();
459  		}
460  		break;
461  		case LVGROUPS_ID:
462  		{
463  			bool& isListViewGroups = NppParameters::getInstance().getNppGUI()._fileSwitcherDisableListViewGroups;
464  			isListViewGroups = !isListViewGroups;
465  			::CheckMenuItem(_hGlobalMenu, LVGROUPS_ID, MF_BYCOMMAND | (isListViewGroups ? MF_UNCHECKED : MF_CHECKED));
466  			reload();
467  		}
468  		break;
469  	}
470  }
471  void VerticalFileSwitcher::display(bool toShow) const
472  {
473  	DockingDlgInterface::display(toShow);
474  	_fileListView.ensureVisibleCurrentItem();	
475  }
476  void VerticalFileSwitcher::activateDoc(TaskLstFnStatus *tlfs) const
477  {
478  	int view = tlfs->_iView;
479  	BufferID bufferID = static_cast<BufferID>(tlfs->_bufID);
480  	auto currentView = ::SendMessage(_hParent, NPPM_GETCURRENTVIEW, 0, 0);
481  	BufferID currentBufID = reinterpret_cast<BufferID>(::SendMessage(_hParent, NPPM_GETCURRENTBUFFERID, 0, 0));
482  	if (bufferID == currentBufID && view == currentView)
483  		return;
484  	int docPosInfo = static_cast<int32_t>(::SendMessage(_hParent, NPPM_GETPOSFROMBUFFERID, reinterpret_cast<WPARAM>(bufferID), view));
485  	int view2set = docPosInfo >> 30;
486  	int index2Switch = (docPosInfo << 2) >> 2;
487  	::SendMessage(_hParent, NPPM_ACTIVATEDOC, view2set, index2Switch);
488  }
489  void VerticalFileSwitcher::closeDoc(TaskLstFnStatus *tlfs) const
490  {
491  	int view = tlfs->_iView;
492  	BufferID bufferID = static_cast<BufferID>(tlfs->_bufID);
493  	int docPosInfo = static_cast<int32_t>(::SendMessage(_hParent, NPPM_GETPOSFROMBUFFERID, reinterpret_cast<WPARAM>(bufferID), view));
494  	int view2set = docPosInfo >> 30;
495  	int index2Switch = (docPosInfo << 2) >> 2;
496  	::SendMessage(_hParent, NPPM_INTERNAL_CLOSEDOC, view2set, index2Switch);
497  }
498  int VerticalFileSwitcher::setHeaderOrder(int columnIndex)
499  {
500  	HWND hListView = _fileListView.getHSelf();
501  	LVCOLUMN lvc{};
502  	lvc.mask = LVCF_FMT;
503  	if (_lastSortingColumn != columnIndex && _lastSortingDirection != SORT_DIRECTION_NONE)
504  	{
505  		HWND colHeader = reinterpret_cast<HWND>(SendMessage(hListView, LVM_GETHEADER, 0, 0));
506  		int columnCount = static_cast<int32_t>(SendMessage(colHeader, HDM_GETITEMCOUNT, 0, 0));
507  		if (_lastSortingColumn < columnCount)
508  		{
509  			SendMessage(hListView, LVM_GETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
510  			lvc.fmt = lvc.fmt & (~HDF_SORTUP) & (~HDF_SORTDOWN);
511  			SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
512  		}
513  		_lastSortingDirection = SORT_DIRECTION_NONE;
514  	}
515  	if (_lastSortingDirection == SORT_DIRECTION_NONE)
516  	{
517  		return SORT_DIRECTION_UP;
518  	}
519  	if (_lastSortingDirection == SORT_DIRECTION_UP)
520  	{
521  		return SORT_DIRECTION_DOWN;
522  	}
523  	return SORT_DIRECTION_NONE;
524  }
525  void VerticalFileSwitcher::updateHeaderArrow()
526  {
527  	HWND hListView = _fileListView.getHSelf();
528  	LVCOLUMN lvc{};
<span onclick='openModal()' class='match'>529  	lvc.mask = LVCF_FMT;
530  	SendMessage(hListView, LVM_GETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
531  	if (_lastSortingDirection == SORT_DIRECTION_UP)
532  	{
533  		lvc.fmt = (lvc.fmt | HDF_SORTUP) & ~HDF_SORTDOWN;
534  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
535  	}
536  	else if (_lastSortingDirection == SORT_DIRECTION_DOWN)
537  	{
538  		lvc.fmt = (lvc.fmt & ~HDF_SORTUP) | HDF_SORTDOWN;
539  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
540  	}
541  	else if (_lastSortingDirection == SORT_DIRECTION_NONE)
</span>542  	{
543  		lvc.fmt = lvc.fmt & (~HDF_SORTUP) & (~HDF_SORTDOWN);
544  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
545  	}
546  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sortSource.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-VerticalFileSwitcher.cpp</div>
                </div>
                <div class="column column_space"><pre><code>56          int mid = lo + (hi - lo)/2;
57          if (Source.GetVal(mid) > val) { hi = mid - 1;}
58          else if (Source.GetVal(mid) < val) { lo = mid + 1;}
59          else { index = mid; hi = mid - 1;}
</pre></code></div>
                <div class="column column_space"><pre><code>529  	lvc.mask = LVCF_FMT;
530  	SendMessage(hListView, LVM_GETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
531  	if (_lastSortingDirection == SORT_DIRECTION_UP)
532  	{
533  		lvc.fmt = (lvc.fmt | HDF_SORTUP) & ~HDF_SORTDOWN;
534  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
535  	}
536  	else if (_lastSortingDirection == SORT_DIRECTION_DOWN)
537  	{
538  		lvc.fmt = (lvc.fmt & ~HDF_SORTUP) | HDF_SORTDOWN;
539  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
540  	}
541  	else if (_lastSortingDirection == SORT_DIRECTION_NONE)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    