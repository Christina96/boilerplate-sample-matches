
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.143695014662756%, Tokens: 24</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mpio.h</h3>
            <pre><code>1  #ifndef MPIO_INCLUDE
2  #define MPIO_INCLUDE
3  #include "mpi.h"
4  #if defined(__cplusplus)
5  extern "C" {
6  #endif
7  #define ROMIO_VERSION 126 &bsol;* version 1.2.6 */
8  #ifndef MPI_FILE_DEFINED
9  typedef struct ADIOI_FileD *MPI_File;
10  #endif
11  #define HAVE_MPI_GREQUEST 1
12  #ifndef HAVE_MPI_GREQUEST
13  typedef struct ADIOI_RequestD *MPIO_Request;  
14  #else
15  #define MPIO_Request MPI_Request
16  #define MPIO_USES_MPI_REQUEST
17  #define MPIO_Wait MPI_Wait
18  #define MPIO_Test MPI_Test
19  #define PMPIO_Wait PMPI_Wait
20  #define PMPIO_Test PMPI_Test
21  #endif
22  #define MPIO_REQUEST_DEFINED
23  #ifndef HAVE_MPI_OFFSET
24  typedef long long MPI_Offset;
25  #ifndef HAVE_MPI_DATAREP_FUNCTIONS
26  #define HAVE_MPI_DATAREP_FUNCTIONS
27  typedef int (MPI_Datarep_conversion_function)(void *, MPI_Datatype, int, 
28               void *, MPI_Offset, void *);
29  typedef int (MPI_Datarep_extent_function)(MPI_Datatype datatype, MPI_Aint *,
30  					  void *);
31  #endif
32  #endif
33  #ifndef NEEDS_MPI_FINT
34  #endif
35  #ifdef NEEDS_MPI_FINT
36  typedef int MPI_Fint; 
37  #endif
38  #ifndef HAVE_MPI_INFO
39  #define HAVE_MPI_INFO
40  #endif
41  #ifndef HAVE_MPI_INFO
42    typedef struct MPIR_Info *MPI_Info;
43  # define MPI_INFO_NULL         ((MPI_Info) 0)
44  # define MPI_MAX_INFO_KEY       255
45  # define MPI_MAX_INFO_VAL      1024
46  #endif
47  #define MPI_MODE_RDONLY              2  &bsol;* ADIO_RDONLY */
48  #define MPI_MODE_RDWR                8  &bsol;* ADIO_RDWR  */
49  #define MPI_MODE_WRONLY              4  &bsol;* ADIO_WRONLY  */
50  #define MPI_MODE_CREATE              1  &bsol;* ADIO_CREATE */ 
51  #define MPI_MODE_EXCL               64  &bsol;* ADIO_EXCL */
52  #define MPI_MODE_DELETE_ON_CLOSE    16  &bsol;* ADIO_DELETE_ON_CLOSE */
53  #define MPI_MODE_UNIQUE_OPEN        32  &bsol;* ADIO_UNIQUE_OPEN */
54  #define MPI_MODE_APPEND            128  &bsol;* ADIO_APPEND */
55  #define MPI_MODE_SEQUENTIAL        256  &bsol;* ADIO_SEQUENTIAL */
56  #define MPI_DISPLACEMENT_CURRENT   -54278278
57  #ifndef MPICH
58  #define MPI_FILE_NULL           ((MPI_File) 0)
59  #endif
60  #define MPIO_REQUEST_NULL       ((MPIO_Request) 0)
61  #define MPI_SEEK_SET            600
62  #define MPI_SEEK_CUR            602
63  #define MPI_SEEK_END            604
64  #ifndef OPEN_MPI
65  #define MPI_MAX_DATAREP_STRING  128
66  #endif
67  #ifndef HAVE_MPI_DARRAY_SUBARRAY
68  #define HAVE_MPI_DARRAY_SUBARRAY
69  #endif
70  #ifndef HAVE_MPI_DARRAY_SUBARRAY
71  #  define MPI_ORDER_C             56
72  #  define MPI_ORDER_FORTRAN       57
73  #  define MPI_DISTRIBUTE_BLOCK    121
74  #  define MPI_DISTRIBUTE_CYCLIC   122
75  #  define MPI_DISTRIBUTE_NONE     123
76  #  define MPI_DISTRIBUTE_DFLT_DARG -49767
77  #endif
78  #ifndef HAVE_PRAGMA_HP_SEC_DEF
79  int MPI_File_open(MPI_Comm comm, const char *filename, int amode, MPI_Info info, MPI_File *fh);
80  int MPI_File_close(MPI_File *fh);
81  int MPI_File_delete(const char *filename, MPI_Info info);
82  int MPI_File_set_size(MPI_File fh, MPI_Offset size);
83  int MPI_File_preallocate(MPI_File fh, MPI_Offset size);
84  int MPI_File_get_size(MPI_File fh, MPI_Offset *size);
85  int MPI_File_get_group(MPI_File fh, MPI_Group *group);
86  int MPI_File_get_amode(MPI_File fh, int *amode);
87  int MPI_File_set_info(MPI_File fh, MPI_Info info);
88  int MPI_File_get_info(MPI_File fh, MPI_Info *info_used);
89  int MPI_File_set_view(MPI_File fh, MPI_Offset disp, MPI_Datatype etype, MPI_Datatype filetype,
90                        const char *datarep, MPI_Info info);
91  int MPI_File_get_view(MPI_File fh, MPI_Offset *disp, MPI_Datatype *etype, MPI_Datatype *filetype,
92                        char *datarep);
93  int MPI_File_read_at(MPI_File fh, MPI_Offset offset, void *buf, int count, MPI_Datatype datatype,
94                       MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
95  int MPI_File_read_at_all(MPI_File fh, MPI_Offset offset, void * buf, int count,
96                           MPI_Datatype datatype, MPI_Status *status)
97      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
98  int MPI_File_write_at(MPI_File fh, MPI_Offset offset, const void * buf, int count,
99                        MPI_Datatype datatype, MPI_Status *status)
100      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
101  int MPI_File_write_at_all(MPI_File fh, MPI_Offset offset, const void *buf, int count,
102                            MPI_Datatype datatype, MPI_Status *status)
103      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
104  int MPI_File_iread_at(MPI_File fh, MPI_Offset offset, void *buf, int count, MPI_Datatype datatype,
105                        MPIO_Request *request) MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
106  int MPI_File_iwrite_at(MPI_File fh, MPI_Offset offset, const void *buf, int count,
107                         MPI_Datatype datatype, MPIO_Request *request)
108      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
109  int MPI_File_read(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status)
110      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
111  int MPI_File_read_all(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status)
112      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
113  int MPI_File_write(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
114                     MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
115  int MPI_File_write_all(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
116                         MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
117  int MPI_File_iread(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPIO_Request *request)
118      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
119  int MPI_File_iwrite(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
120                      MPIO_Request *request) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
121  int MPI_File_seek(MPI_File fh, MPI_Offset offset, int whence);
122  int MPI_File_get_position(MPI_File fh, MPI_Offset *offset);
123  int MPI_File_get_byte_offset(MPI_File fh, MPI_Offset offset, MPI_Offset *disp);
124  int MPI_File_read_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype,
125                           MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
126  int MPI_File_write_shared(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
127                            MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
128  int MPI_File_iread_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype,
129                            MPIO_Request *request) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
130  int MPI_File_iwrite_shared(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
131                             MPIO_Request *request) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
132  int MPI_File_read_ordered(MPI_File fh, void *buf, int count, MPI_Datatype datatype,
133                            MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
134  int MPI_File_write_ordered(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
135                             MPI_Status *status) MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
136  int MPI_File_seek_shared(MPI_File fh, MPI_Offset offset, int whence);
137  int MPI_File_get_position_shared(MPI_File fh, MPI_Offset *offset);
138  int MPI_File_read_at_all_begin(MPI_File fh, MPI_Offset offset, void *buf, int count,
139                                 MPI_Datatype datatype) MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
140  int MPI_File_read_at_all_end(MPI_File fh, void *buf, MPI_Status *status);
141  int MPI_File_write_at_all_begin(MPI_File fh, MPI_Offset offset, const void *buf, int count,
142                                  MPI_Datatype datatype) MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
143  int MPI_File_write_at_all_end(MPI_File fh, const void *buf, MPI_Status *status);
144  int MPI_File_read_all_begin(MPI_File fh, void *buf, int count, MPI_Datatype datatype)
145      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
146  int MPI_File_read_all_end(MPI_File fh, void *buf, MPI_Status *status);
147  int MPI_File_write_all_begin(MPI_File fh, const void *buf, int count, MPI_Datatype datatype)
148      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
149  int MPI_File_write_all_end(MPI_File fh, const void *buf, MPI_Status *status);
150  int MPI_File_read_ordered_begin(MPI_File fh, void *buf, int count, MPI_Datatype datatype)
151      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
152  int MPI_File_read_ordered_end(MPI_File fh, void *buf, MPI_Status *status);
153  int MPI_File_write_ordered_begin(MPI_File fh, const void *buf, int count, MPI_Datatype datatype)
154      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
155  int MPI_File_write_ordered_end(MPI_File fh, const void *buf, MPI_Status *status);
156  int MPI_File_get_type_extent(MPI_File fh, MPI_Datatype datatype, MPI_Aint *extent);
157  int MPI_Register_datarep(const char *datarep, MPI_Datarep_conversion_function *read_conversion_fn,
158  			 MPI_Datarep_conversion_function *write_conversion_fn,
159  			 MPI_Datarep_extent_function *dtype_file_extent_fn, void *extra_state);
160  int MPI_File_set_atomicity(MPI_File fh, int flag);
161  int MPI_File_get_atomicity(MPI_File fh, int *flag);
162  int MPI_File_sync(MPI_File fh);
163  #ifndef MPICH
164  int MPI_File_set_errhandler(MPI_File file, MPI_Errhandler errhandler);
165  int MPI_File_get_errhandler(MPI_File file, MPI_Errhandler *errhandler);
166  #endif
167  int MPI_File_iread_at_all(MPI_File fh, MPI_Offset offset, void *buf, int count,
168                             MPI_Datatype datatype, MPI_Request *request)
169      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
170  int MPI_File_iwrite_at_all(MPI_File fh, MPI_Offset offset, const void *buf, int count,
171                              MPI_Datatype datatype, MPI_Request *request)
172      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
173  int MPI_File_iread_all(MPI_File fh, void *buf, int count, MPI_Datatype datatype,
174                          MPI_Request *request)
175      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
176  int MPI_File_iwrite_all(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
177                           MPI_Request *request)
178      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
179  #ifndef HAVE_MPI_DARRAY_SUBARRAY
180  int MPI_Type_create_subarray(int ndims, const int array_of_sizes[], const int array_of_subsizes[],
181                               const int array_of_starts[], int order, MPI_Datatype oldtype,
182                               MPI_Datatype *newtype);
183  int MPI_Type_create_darray(int size, int rank, int ndims, const int array_of_gsizes[],
184                             const int array_of_distribs[], const int array_of_dargs[],
185                             const int array_of_psizes, int order, MPI_Datatype oldtype,
186                             MPI_Datatype *newtype);
187  #endif
188  #if !defined(MPICH_RENAMING_MPI_FUNCS)
189  #ifdef MPI_File_f2c
190  #undef MPI_File_f2c
191  #endif
192  #ifdef MPI_File_c2f
193  #undef MPI_File_c2f
194  #endif
195  #endif
196  MPI_File MPI_File_f2c(MPI_Fint file);
197  MPI_Fint MPI_File_c2f(MPI_File file);
198  #ifndef HAVE_MPI_GREQUEST
199  int MPIO_Test(MPIO_Request *request, int *flag, MPI_Status *status);
200  int MPIO_Wait(MPIO_Request *request, MPI_Status *status);
201  int MPIO_Testall(int count, MPIO_Request array_of_requests[], int *flag,
202                   MPI_Status array_of_statuses[]);
203  int MPIO_Waitall(int count, MPIO_Request array_of_requests[], MPI_Status array_of_statuses[]);
204  int MPIO_Testany(int count, MPIO_Request array_of_requests[], int *indx, int *flag,
205                   MPI_Status *status);
206  int MPIO_Waitany(int count, MPIO_Request array_of_requests[], int *indx, MPI_Status *status);
207  int MPIO_Waitsome(int incount, MPIO_Request array_of_requests[], int *outcount,
208                    int array_of_indices[], MPI_Status array_of_statuses[]);
209  int MPIO_Testsome(int incount, MPIO_Request array_of_requests[], int *outcount,
210                    int array_of_indices[], MPI_Status array_of_statuses[]);
211  MPI_Fint MPIO_Request_c2f(MPIO_Request request);
212  MPIO_Request MPIO_Request_f2c(MPI_Fint request);
213  #endif &bsol;* HAVE_MPI_GREQUEST */
214  #ifndef HAVE_MPI_INFO
215  int MPI_Info_create(MPI_Info *info);
216  int MPI_Info_set(MPI_Info info, const char *key, const char *value);
217  int MPI_Info_delete(MPI_Info info, const char *key);
218  int MPI_Info_get(MPI_Info info, const char *key, int valuelen, char *value, int *flag);
219  int MPI_Info_get_valuelen(MPI_Info info, const char *key, int *valuelen, int *flag);
220  int MPI_Info_get_nkeys(MPI_Info info, int *nkeys);
221  int MPI_Info_get_nthkey(MPI_Info info, int n, char *key);
222  int MPI_Info_dup(MPI_Info info, MPI_Info *newinfo);
223  int MPI_Info_free(MPI_Info *info);
224  #if !defined(MPICH_RENAMING_MPI_FUNCS)
225  #ifdef MPI_Info_f2c
226  #undef MPI_Info_f2c
227  #endif
228  #ifdef MPI_Info_c2f
229  #undef MPI_Info_c2f
230  #endif
231  #endif
232  MPI_Fint MPI_Info_c2f(MPI_Info info);
233  MPI_Info MPI_Info_f2c(MPI_Fint info);
234  #endif
235  #endif   &bsol;* HAVE_PRAGMA_HP_SEC_DEF */
236  int PMPI_File_open(MPI_Comm, const char *, int, MPI_Info, MPI_File *);
237  int PMPI_File_close(MPI_File *);
238  int PMPI_File_delete(const char *, MPI_Info);
239  int PMPI_File_set_size(MPI_File, MPI_Offset);
240  int PMPI_File_preallocate(MPI_File, MPI_Offset);
241  int PMPI_File_get_size(MPI_File, MPI_Offset *);
242  int PMPI_File_get_group(MPI_File, MPI_Group *);
243  int PMPI_File_get_amode(MPI_File, int *);
244  int PMPI_File_set_info(MPI_File, MPI_Info);
245  int PMPI_File_get_info(MPI_File, MPI_Info *);
246  int PMPI_File_set_view(MPI_File, MPI_Offset, 
247      MPI_Datatype, MPI_Datatype, const char *, MPI_Info);
248  int PMPI_File_get_view(MPI_File, MPI_Offset *, 
249        MPI_Datatype *, MPI_Datatype *, char *);
250  int PMPI_File_read_at(MPI_File, MPI_Offset, void *,
251  	      int, MPI_Datatype, MPI_Status *)
252                MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
253  int PMPI_File_read_at_all(MPI_File, MPI_Offset, void *,
254  	      int, MPI_Datatype, MPI_Status *)
255                MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
256  int PMPI_File_write_at(MPI_File, MPI_Offset, const void *,
257  	      int, MPI_Datatype, MPI_Status *)
258                MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
259  int PMPI_File_write_at_all(MPI_File, MPI_Offset, const void *,
260  	      int, MPI_Datatype, MPI_Status *)
261                MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
262  int PMPI_File_iread_at(MPI_File, MPI_Offset, void *,
263  	      int, MPI_Datatype, MPIO_Request *)
264                MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
265  int PMPI_File_iwrite_at(MPI_File, MPI_Offset, const void *,
266  	      int, MPI_Datatype, MPIO_Request *)
267                MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
268  int PMPI_File_read(MPI_File, void *, int, MPI_Datatype, MPI_Status *)
269                     MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
270  int PMPI_File_read_all(MPI_File, void *, int, MPI_Datatype, MPI_Status *)
271                         MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
272  int PMPI_File_write(MPI_File, const void *, int, MPI_Datatype, MPI_Status *)
273                      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
274  int PMPI_File_write_all(MPI_File, const void *, int, MPI_Datatype, MPI_Status *)
275                          MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
276  int PMPI_File_iread(MPI_File, void *, int, MPI_Datatype, MPIO_Request *)
277                      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
278  int PMPI_File_iwrite(MPI_File, const void *, int, MPI_Datatype, MPIO_Request *)
279                       MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
280  int PMPI_File_seek(MPI_File, MPI_Offset, int);
281  int PMPI_File_get_position(MPI_File, MPI_Offset *);
282  int PMPI_File_get_byte_offset(MPI_File, MPI_Offset, MPI_Offset *);
283  int PMPI_File_read_shared(MPI_File, void *, int, MPI_Datatype, MPI_Status *)
284                            MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
285  int PMPI_File_write_shared(MPI_File, const void *, int, MPI_Datatype, MPI_Status *)
286                             MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
287  int PMPI_File_iread_shared(MPI_File, void *, int, 
288  			   MPI_Datatype, MPIO_Request *)
289                             MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
290  int PMPI_File_iwrite_shared(MPI_File, const void *, int,
291  			    MPI_Datatype, MPIO_Request *)
292                              MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
293  int PMPI_File_read_ordered(MPI_File, void *, int, MPI_Datatype, MPI_Status *)
294                             MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
295  int PMPI_File_write_ordered(MPI_File, const void *, int, MPI_Datatype, MPI_Status *)
296                              MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
297  int PMPI_File_seek_shared(MPI_File, MPI_Offset, int);
298  int PMPI_File_get_position_shared(MPI_File, MPI_Offset *);
299  int PMPI_File_read_at_all_begin(MPI_File, MPI_Offset, void *,
300                                 int, MPI_Datatype)
301                                 MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
302  int PMPI_File_read_at_all_end(MPI_File, void *, MPI_Status *);
303  int PMPI_File_write_at_all_begin(MPI_File, MPI_Offset, const void *,
304                                   int, MPI_Datatype)
305                                   MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
306  int PMPI_File_write_at_all_end(MPI_File, const void *, MPI_Status *);
307  int PMPI_File_read_all_begin(MPI_File, void *, int, MPI_Datatype)
308                               MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
309  int PMPI_File_read_all_end(MPI_File, void *, MPI_Status *);
310  int PMPI_File_write_all_begin(MPI_File, const void *, int, MPI_Datatype)
311                                MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
312  int PMPI_File_write_all_end(MPI_File, const void *, MPI_Status *);
313  int PMPI_File_read_ordered_begin(MPI_File, void *, int, MPI_Datatype)
314                                   MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
315  int PMPI_File_read_ordered_end(MPI_File, void *, MPI_Status *);
316  int PMPI_File_write_ordered_begin(MPI_File, const void *, int, MPI_Datatype)
317                                    MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
318  int PMPI_File_write_ordered_end(MPI_File, const void *, MPI_Status *);
319  int PMPI_File_get_type_extent(MPI_File, MPI_Datatype, MPI_Aint *);
320  int PMPI_Register_datarep(const char *,
321  			 MPI_Datarep_conversion_function *,
322  			 MPI_Datarep_conversion_function *,
323  			 MPI_Datarep_extent_function *,
324  			 void *);
325  int PMPI_File_set_atomicity(MPI_File, int);
326  int PMPI_File_get_atomicity(MPI_File, int *);
327  int PMPI_File_sync(MPI_File);
328  #ifndef MPICH
329  int PMPI_File_set_errhandler( MPI_File, MPI_Errhandler );
330  int PMPI_File_get_errhandler( MPI_File, MPI_Errhandler * );
331  #endif
332  int PMPI_File_iread_at_all(MPI_File fh, MPI_Offset offset, void *buf, int count,
333                              MPI_Datatype datatype, MPI_Request *request)
334      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
335  int PMPI_File_iwrite_at_all(MPI_File fh, MPI_Offset offset, const void *buf, int count,
336                               MPI_Datatype datatype, MPI_Request *request)
337      MPICH_ATTR_POINTER_WITH_TYPE_TAG(3,5);
338  int PMPI_File_iread_all(MPI_File fh, void *buf, int count, MPI_Datatype datatype,
339                           MPI_Request *request)
340      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
341  int PMPI_File_iwrite_all(MPI_File fh, const void *buf, int count, MPI_Datatype datatype,
342                            MPI_Request *request)
343      MPICH_ATTR_POINTER_WITH_TYPE_TAG(2,4);
344  #ifndef HAVE_MPI_DARRAY_SUBARRAY
345  int PMPI_Type_create_subarray(int, int *, int *, int *, int, 
346                        MPI_Datatype, MPI_Datatype *);
347  int PMPI_Type_create_darray(int, int, int, int *, int *, 
348                      int *, int *, int, MPI_Datatype, MPI_Datatype *);
349  #endif
350  MPI_File PMPI_File_f2c(MPI_Fint);
351  MPI_Fint PMPI_File_c2f(MPI_File);
352  #ifndef HAVE_MPI_GREQUEST
353  int PMPIO_Test(MPIO_Request *, int *, MPI_Status *);
354  int PMPIO_Wait(MPIO_Request *, MPI_Status *);
355  int PMPIO_Testall(int, MPIO_Request *, int *, MPI_Status *);
356  int PMPIO_Waitall(int, MPIO_Request *, MPI_Status *);
357  int PMPIO_Testany(int, MPIO_Request *, int *, int *, MPI_Status *);
358  int PMPIO_Waitany(int, MPIO_Request *, int *, MPI_Status *);
359  int PMPIO_Waitsome(int, MPIO_Request *, int *, int *, MPI_Status *);
<span onclick='openModal()' class='match'>360  int PMPIO_Testsome(int, MPIO_Request *, int *, int *, MPI_Status *);
361  MPI_Fint PMPIO_Request_c2f(MPIO_Request);
362  MPIO_Request PMPIO_Request_f2c(MPI_Fint);
363  #endif &bsol;* HAVE_MPI_GREQUEST */
364  #ifndef HAVE_MPI_INFO
365  int PMPI_Info_create(MPI_Info *);
366  int PMPI_Info_set(MPI_Info, char *, char *);
367  int PMPI_Info_delete(MPI_Info, char *);
368  int PMPI_Info_get(MPI_Info, char *, int, char *, int *);
369  int PMPI_Info_get_valuelen(MPI_Info, char *, int *, int *);
370  int PMPI_Info_get_nkeys(MPI_Info, int *);
371  int PMPI_Info_get_nthkey(MPI_Info, int, char *);
372  int PMPI_Info_dup(MPI_Info, MPI_Info *);
373  int PMPI_Info_free(MPI_Info *);
374  MPI_Fint PMPI_Info_c2f(MPI_Info);
375  MPI_Info PMPI_Info_f2c(MPI_Fint);
376  #endif
377  #if defined(__cplusplus)
378  }
</span>379  #endif
380  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobbox.h</h3>
            <pre><code>1  #ifndef BLOBBOX_H
2  #define BLOBBOX_H
3  #include "elst.h"       
4  #include "elst2.h"      
5  #include "errcode.h"    
6  #include "ocrblock.h"   
7  #include "params.h"     
8  #include "pdblock.h"    
9  #include "points.h"     
10  #include "quspline.h"   
11  #include "rect.h"       
12  #include "scrollview.h" 
13  #include "statistc.h"   
14  #include "stepblob.h"   
15  #include "tprintf.h"    
16  #include "werd.h"       
17  #include <cinttypes> 
18  #include <cmath>     
19  #include <cstdint>   
20  struct Pix;
21  namespace tesseract {
22  class C_OUTLINE;
23  enum PITCH_TYPE {
24    PITCH_DUNNO,       
25    PITCH_DEF_FIXED,   
26    PITCH_MAYBE_FIXED, 
27    PITCH_DEF_PROP,
28    PITCH_MAYBE_PROP,
29    PITCH_CORR_FIXED,
30    PITCH_CORR_PROP
31  };
32  enum TabType {
33    TT_NONE,          
34    TT_DELETED,       
35    TT_MAYBE_RAGGED,  
36    TT_MAYBE_ALIGNED, 
37    TT_CONFIRMED,     
38    TT_VLINE          
39  };
40  enum BlobRegionType {
41    BRT_NOISE,     
42    BRT_HLINE,     
43    BRT_VLINE,     
44    BRT_RECTIMAGE, 
45    BRT_POLYIMAGE, 
46    BRT_UNKNOWN,   
47    BRT_VERT_TEXT, 
48    BRT_TEXT,      
49    BRT_COUNT 
50  };
51  enum BlobNeighbourDir { BND_LEFT, BND_BELOW, BND_RIGHT, BND_ABOVE, BND_COUNT };
52  enum BlobSpecialTextType {
53    BSTT_NONE,    
54    BSTT_ITALIC,  
55    BSTT_DIGIT,   
56    BSTT_MATH,    
57    BSTT_UNCLEAR, 
58    BSTT_SKIP,    
59    BSTT_COUNT
60  };
61  inline BlobNeighbourDir DirOtherWay(BlobNeighbourDir dir) {
62    return static_cast<BlobNeighbourDir>(dir ^ 2);
63  }
64  enum BlobTextFlowType {
65    BTFT_NONE,          
66    BTFT_NONTEXT,       
67    BTFT_NEIGHBOURS,    
68    BTFT_CHAIN,         
69    BTFT_STRONG_CHAIN,  
70    BTFT_TEXT_ON_IMAGE, 
71    BTFT_LEADER,        
72    BTFT_COUNT
73  };
74  inline bool DominatesInMerge(BlobTextFlowType type1, BlobTextFlowType type2) {
75    if (type1 == BTFT_LEADER) {
76      return false;
77    }
78    if (type2 == BTFT_LEADER) {
79      return true;
80    }
81    return type1 >= type2;
82  }
83  class ColPartition;
84  class BLOBNBOX;
85  ELISTIZEH(BLOBNBOX)
86  class BLOBNBOX : public ELIST_LINK {
87  public:
88    BLOBNBOX() {
89      ReInit();
90    }
91    explicit BLOBNBOX(C_BLOB *srcblob) {
92      box = srcblob->bounding_box();
93      ReInit();
94      cblob_ptr = srcblob;
95      area = static_cast<int>(srcblob->area());
96    }
97    ~BLOBNBOX() {
98      if (owns_cblob_) {
99        delete cblob_ptr;
100      }
101    }
102    static void clear_blobnboxes(BLOBNBOX_LIST *boxes) {
103      BLOBNBOX_IT it = boxes;
104      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
105        BLOBNBOX *box = it.data();
106        delete box->remove_cblob();
107      }
108    }
109    static BLOBNBOX *RealBlob(C_OUTLINE *outline) {
110      auto *blob = new C_BLOB(outline);
111      return new BLOBNBOX(blob);
112    }
113    void rotate(FCOORD rotation);
114    void reflect_box_in_y_axis();
115    void rotate_box(FCOORD rotation);
116    void translate_box(ICOORD v) {
117      if (IsDiacritic()) {
118        box.move(v);
119        base_char_top_ += v.y();
120        base_char_bottom_ += v.y();
121      } else {
122        box.move(v);
123        set_diacritic_box(box);
124      }
125    }
126    void merge(BLOBNBOX *nextblob);
127    void really_merge(BLOBNBOX *other);
128    void chop(                 
129        BLOBNBOX_IT *start_it, 
130        BLOBNBOX_IT *blob_it,  
131        FCOORD rotation,       
132        float xheight);        
133    void NeighbourGaps(int gaps[BND_COUNT]) const;
134    void MinMaxGapsClipped(int *h_min, int *h_max, int *v_min, int *v_max) const;
135    void CleanNeighbours();
136    int GoodTextBlob() const;
137    int NoisyNeighbours() const;
138    bool DeletableNoise() const {
139      return owner() == nullptr && region_type() == BRT_NOISE;
140    }
141    bool DefiniteIndividualFlow();
142    bool ConfirmNoTabViolation(const BLOBNBOX &other) const;
143    bool MatchingStrokeWidth(const BLOBNBOX &other, double fractional_tolerance,
144                             double constant_tolerance) const;
145    TBOX BoundsWithinLimits(int left, int right);
146    void EstimateBaselinePosition();
147    const TBOX &bounding_box() const {
148      return box;
149    }
150    void set_bounding_box(const TBOX &new_box) {
151      box = new_box;
152      base_char_top_ = box.top();
153      base_char_bottom_ = box.bottom();
154    }
155    void compute_bounding_box() {
156      box = cblob_ptr->bounding_box();
157      base_char_top_ = box.top();
158      base_char_bottom_ = box.bottom();
159      baseline_y_ = box.bottom();
160    }
161    const TBOX &reduced_box() const {
162      return red_box;
163    }
164    void set_reduced_box(TBOX new_box) {
165      red_box = new_box;
166      reduced = true;
167    }
168    int32_t enclosed_area() const {
169      return area;
170    }
171    bool joined_to_prev() const {
172      return joined;
173    }
174    bool red_box_set() const {
175      return reduced;
176    }
177    int repeated_set() const {
178      return repeated_set_;
179    }
180    void set_repeated_set(int set_id) {
181      repeated_set_ = set_id;
182    }
183    C_BLOB *cblob() const {
184      return cblob_ptr;
185    }
186    C_BLOB *remove_cblob() {
187      auto blob = cblob_ptr;
188      cblob_ptr = nullptr;
189      owns_cblob_ = false;
190      return blob;
191    }
192    TabType left_tab_type() const {
193      return left_tab_type_;
194    }
195    void set_left_tab_type(TabType new_type) {
196      left_tab_type_ = new_type;
197    }
198    TabType right_tab_type() const {
199      return right_tab_type_;
200    }
201    void set_right_tab_type(TabType new_type) {
202      right_tab_type_ = new_type;
203    }
204    BlobRegionType region_type() const {
205      return region_type_;
206    }
207    void set_region_type(BlobRegionType new_type) {
208      region_type_ = new_type;
209    }
210    BlobSpecialTextType special_text_type() const {
211      return spt_type_;
212    }
213    void set_special_text_type(BlobSpecialTextType new_type) {
214      spt_type_ = new_type;
215    }
216    BlobTextFlowType flow() const {
217      return flow_;
218    }
219    void set_flow(BlobTextFlowType value) {
220      flow_ = value;
221    }
222    bool vert_possible() const {
223      return vert_possible_;
224    }
225    void set_vert_possible(bool value) {
226      vert_possible_ = value;
227    }
228    bool horz_possible() const {
229      return horz_possible_;
230    }
231    void set_horz_possible(bool value) {
232      horz_possible_ = value;
233    }
234    int left_rule() const {
235      return left_rule_;
236    }
237    void set_left_rule(int new_left) {
238      left_rule_ = new_left;
239    }
240    int right_rule() const {
241      return right_rule_;
242    }
243    void set_right_rule(int new_right) {
244      right_rule_ = new_right;
245    }
246    int left_crossing_rule() const {
247      return left_crossing_rule_;
248    }
249    void set_left_crossing_rule(int new_left) {
250      left_crossing_rule_ = new_left;
251    }
252    int right_crossing_rule() const {
253      return right_crossing_rule_;
254    }
255    void set_right_crossing_rule(int new_right) {
256      right_crossing_rule_ = new_right;
257    }
258    float horz_stroke_width() const {
259      return horz_stroke_width_;
260    }
261    void set_horz_stroke_width(float width) {
262      horz_stroke_width_ = width;
263    }
264    float vert_stroke_width() const {
265      return vert_stroke_width_;
266    }
267    void set_vert_stroke_width(float width) {
268      vert_stroke_width_ = width;
269    }
270    float area_stroke_width() const {
271      return area_stroke_width_;
272    }
273    tesseract::ColPartition *owner() const {
274      return owner_;
275    }
276    void set_owner(tesseract::ColPartition *new_owner) {
277      owner_ = new_owner;
278    }
279    bool leader_on_left() const {
280      return leader_on_left_;
281    }
282    void set_leader_on_left(bool flag) {
283      leader_on_left_ = flag;
284    }
285    bool leader_on_right() const {
286      return leader_on_right_;
287    }
288    void set_leader_on_right(bool flag) {
289      leader_on_right_ = flag;
290    }
291    BLOBNBOX *neighbour(BlobNeighbourDir n) const {
292      return neighbours_[n];
293    }
294    bool good_stroke_neighbour(BlobNeighbourDir n) const {
295      return good_stroke_neighbours_[n];
296    }
297    void set_neighbour(BlobNeighbourDir n, BLOBNBOX *neighbour, bool good) {
298      neighbours_[n] = neighbour;
299      good_stroke_neighbours_[n] = good;
300    }
301    bool IsDiacritic() const {
302      return base_char_top_ != box.top() || base_char_bottom_ != box.bottom();
303    }
304    int base_char_top() const {
305      return base_char_top_;
306    }
307    int base_char_bottom() const {
308      return base_char_bottom_;
309    }
310    int baseline_position() const {
311      return baseline_y_;
312    }
313    int line_crossings() const {
314      return line_crossings_;
315    }
316    void set_line_crossings(int value) {
317      line_crossings_ = value;
318    }
319    void set_diacritic_box(const TBOX &diacritic_box) {
320      base_char_top_ = diacritic_box.top();
321      base_char_bottom_ = diacritic_box.bottom();
322    }
323    BLOBNBOX *base_char_blob() const {
324      return base_char_blob_;
325    }
326    void set_base_char_blob(BLOBNBOX *blob) {
327      base_char_blob_ = blob;
328    }
329    void set_owns_cblob(bool value) {
330      owns_cblob_ = value;
331    }
332    bool UniquelyVertical() const {
333      return vert_possible_ && !horz_possible_;
334    }
335    bool UniquelyHorizontal() const {
336      return horz_possible_ && !vert_possible_;
337    }
338    static bool IsTextType(BlobRegionType type) {
339      return type == BRT_TEXT || type == BRT_VERT_TEXT;
340    }
341    static bool IsImageType(BlobRegionType type) {
342      return type == BRT_RECTIMAGE || type == BRT_POLYIMAGE;
343    }
344    static bool IsLineType(BlobRegionType type) {
345      return type == BRT_HLINE || type == BRT_VLINE;
346    }
347    static bool UnMergeableType(BlobRegionType type) {
348      return IsLineType(type) || IsImageType(type);
349    }
350    static void CleanNeighbours(BLOBNBOX_LIST *blobs);
351    static void DeleteNoiseBlobs(BLOBNBOX_LIST *blobs);
352    static void ComputeEdgeOffsets(Image thresholds, Image grey, BLOBNBOX_LIST *blobs);
353  #ifndef GRAPHICS_DISABLED
354    static void PlotBlobs(BLOBNBOX_LIST *list, ScrollView::Color body_colour,
355                          ScrollView::Color child_colour, ScrollView *win);
356    static void PlotNoiseBlobs(BLOBNBOX_LIST *list, ScrollView::Color body_colour,
357                               ScrollView::Color child_colour, ScrollView *win);
358    static ScrollView::Color TextlineColor(BlobRegionType region_type, BlobTextFlowType flow_type);
359    ScrollView::Color BoxColor() const;
360    void plot(ScrollView *window,              
361              ScrollView::Color blob_colour,   
362              ScrollView::Color child_colour); 
363  #endif
364    void ReInit() {
365      joined = false;
366      reduced = false;
367      repeated_set_ = 0;
368      left_tab_type_ = TT_NONE;
369      right_tab_type_ = TT_NONE;
370      region_type_ = BRT_UNKNOWN;
371      flow_ = BTFT_NONE;
372      spt_type_ = BSTT_SKIP;
373      left_rule_ = 0;
374      right_rule_ = 0;
375      left_crossing_rule_ = 0;
376      right_crossing_rule_ = 0;
377      if (area_stroke_width_ == 0.0f && area > 0 && cblob() != nullptr && cblob()->perimeter() != 0) {
378        area_stroke_width_ = 2.0f * area / cblob()->perimeter();
379      }
380      owner_ = nullptr;
381      base_char_top_ = box.top();
382      base_char_bottom_ = box.bottom();
383      baseline_y_ = box.bottom();
384      line_crossings_ = 0;
385      base_char_blob_ = nullptr;
386      horz_possible_ = false;
387      vert_possible_ = false;
388      leader_on_left_ = false;
389      leader_on_right_ = false;
390      ClearNeighbours();
391    }
392    void ClearNeighbours() {
393      for (int n = 0; n < BND_COUNT; ++n) {
394        neighbours_[n] = nullptr;
395        good_stroke_neighbours_[n] = false;
396      }
397    }
398  private:
399    C_BLOB *cblob_ptr = nullptr;               
400    TBOX box;                                  
401    TBOX red_box;                              
402    int32_t area = 0;                          
403    int32_t repeated_set_ = 0;                 
404    TabType left_tab_type_ = TT_NONE;          
405    TabType right_tab_type_ = TT_NONE;         
406    BlobRegionType region_type_ = BRT_UNKNOWN; 
407    BlobTextFlowType flow_ = BTFT_NONE;        
408    BlobSpecialTextType spt_type_;             
409    bool joined = false;                       
410    bool reduced = false;                      
411    int16_t left_rule_ = 0;                    
412    int16_t right_rule_ = 0;                   
413    int16_t left_crossing_rule_;               
414    int16_t right_crossing_rule_;              
415    int16_t base_char_top_;                    
416    int16_t base_char_bottom_;                 
417    int16_t baseline_y_;                       
418    int32_t line_crossings_;                   
419    BLOBNBOX *base_char_blob_;                 
420    tesseract::ColPartition *owner_;           
421    BLOBNBOX *neighbours_[BND_COUNT];
422    float horz_stroke_width_ = 0.0f; 
423    float vert_stroke_width_ = 0.0f; 
424    float area_stroke_width_ = 0.0f; 
425    bool good_stroke_neighbours_[BND_COUNT];
426    bool horz_possible_;   
427    bool vert_possible_;   
428    bool leader_on_left_;  
429    bool leader_on_right_; 
430    bool owns_cblob_ = false;
431  };
432  class TO_ROW : public ELIST2_LINK {
433  public:
434    static const int kErrorWeight = 3;
435    TO_ROW() {
436      clear();
437    }                   
438    TO_ROW(             
439        BLOBNBOX *blob, 
440        float top,      
441        float bottom, float row_size);
442    void print() const;
443    float max_y() const { 
444      return y_max;
445    }
446    float min_y() const {
447      return y_min;
448    }
449    float mean_y() const {
450      return (y_min + y_max) / 2.0f;
451    }
452    float initial_min_y() const {
453      return initial_y_min;
454    }
455    float line_m() const { 
456      return m;
457    }
458    float line_c() const {
459      return c;
460    }
461    float line_error() const {
462      return error;
463    }
464    float parallel_c() const {
465      return para_c;
466    }
467    float parallel_error() const {
468      return para_error;
469    }
470    float believability() const { 
471      return credibility;
472    }
473    float intercept() const { 
474      return y_origin;
475    }
476    void add_blob(      
477        BLOBNBOX *blob, 
478        float top,      
479        float bottom, float row_size);
480    void insert_blob( 
481        BLOBNBOX *blob);
482    BLOBNBOX_LIST *blob_list() { 
483      return &blobs;
484    }
485    void set_line(   
486        float new_m, 
487        float new_c, float new_error) {
488      m = new_m;
489      c = new_c;
490      error = new_error;
491    }
492    void set_parallel_line( 
493        float gradient,     
494        float new_c, float new_error) {
495      para_c = new_c;
496      para_error = new_error;
497      credibility = blobs.length() - kErrorWeight * new_error;
498      y_origin = new_c / std::sqrt(1 + gradient * gradient);
499    }
500    void set_limits(     
501        float new_min,   
502        float new_max) { 
503      y_min = new_min;
504      y_max = new_max;
505    }
506    void compute_vertical_projection();
507    bool rep_chars_marked() const {
508      return num_repeated_sets_ != -1;
509    }
510    void clear_rep_chars_marked() {
511      num_repeated_sets_ = -1;
512    }
513    int num_repeated_sets() const {
514      return num_repeated_sets_;
515    }
516    void set_num_repeated_sets(int num_sets) {
517      num_repeated_sets_ = num_sets;
518    }
519    bool merged = false;
520    bool all_caps;             
521    bool used_dm_model;        
522    int16_t projection_left;   
523    int16_t projection_right;  
524    PITCH_TYPE pitch_decision; 
<span onclick='openModal()' class='match'>525    float fixed_pitch;         
526    float fp_space;            
527    float fp_nonsp;            
528    float pr_space;            
529    float pr_nonsp;            
530    float spacing;             
531    float xheight;             
532    int xheight_evidence;      
533    float ascrise;             
534    float descdrop;            
535    float body_size;           
536    int32_t min_space;         
537    int32_t max_nonspace;      
538    int32_t space_threshold;   
539    float kern_size;           
540    float space_size;          
541    WERD_LIST rep_words;       
542    ICOORDELT_LIST char_cells; 
543    QSPLINE baseline;          
544    STATS projection;          
545  private:
546    void clear(); 
547    BLOBNBOX_LIST blobs; 
548    float y_min;         
549    float y_max;
550    float initial_y_min;
551    float m, c;   
552    float error;  
553    float para_c; 
554    float para_error;
555    float y_origin;         
556    float credibility;      
557    int num_repeated_sets_; 
558  };
</span>559  ELIST2IZEH(TO_ROW)
560  class TESS_API TO_BLOCK : public ELIST_LINK {
561  public:
562    TO_BLOCK() : pitch_decision(PITCH_DUNNO) {
563      clear();
564    }                      
565    TO_BLOCK(              
566        BLOCK *src_block); 
567    ~TO_BLOCK();
568    void clear(); 
569    TO_ROW_LIST *get_rows() { 
570      return &row_list;
571    }
572    void rotate(const FCOORD &rotation) {
573      BLOBNBOX_LIST *blobnbox_list[] = {&blobs,       &underlines,  &noise_blobs,
574                                        &small_blobs, &large_blobs, nullptr};
575      for (BLOBNBOX_LIST **list = blobnbox_list; *list != nullptr; ++list) {
576        BLOBNBOX_IT it(*list);
577        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
578          it.data()->rotate(rotation);
579        }
580      }
581      ASSERT_HOST(block->pdblk.poly_block() != nullptr);
582      block->rotate(rotation);
583      STATS widths(0, block->pdblk.bounding_box().width() - 1);
584      STATS heights(0, block->pdblk.bounding_box().height() - 1);
585      BLOBNBOX_IT blob_it(&blobs);
586      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
587        widths.add(blob_it.data()->bounding_box().width(), 1);
588        heights.add(blob_it.data()->bounding_box().height(), 1);
589      }
590      block->set_median_size(static_cast<int>(widths.median() + 0.5),
591                             static_cast<int>(heights.median() + 0.5));
592    }
593    void print_rows() { 
594      TO_ROW_IT row_it = &row_list;
595      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
596        auto row = row_it.data();
597        tprintf("Row range (%g,%g), para_c=%g, blobcount=%" PRId32 "\n",
598                static_cast<double>(row->min_y()),
599                static_cast<double>(row->max_y()),
600                static_cast<double>(row->parallel_c()),
601                row->blob_list()->length());
602      }
603    }
604    void ReSetAndReFilterBlobs();
605    void DeleteUnownedNoise();
606    void ComputeEdgeOffsets(Image thresholds, Image grey);
607  #ifndef GRAPHICS_DISABLED
608    void plot_noise_blobs(ScrollView *to_win);
609    void plot_graded_blobs(ScrollView *to_win);
610  #endif
611    BLOBNBOX_LIST blobs;       
612    BLOBNBOX_LIST underlines;  
613    BLOBNBOX_LIST noise_blobs; 
614    BLOBNBOX_LIST small_blobs; 
615    BLOBNBOX_LIST large_blobs; 
616    BLOCK *block;              
617    PITCH_TYPE pitch_decision; 
618    float line_spacing;        
619    float line_size;       
620    float max_blob_size;   
621    float baseline_offset; 
622    float xheight;         
623    float fixed_pitch;     
624    float kern_size;       
625    float space_size;      
626    int32_t min_space;     
627    int32_t max_nonspace;  
628    float fp_space;        
629    float fp_nonsp;        
630    float pr_space;        
631    float pr_nonsp;        
632    TO_ROW *key_row;       
633  private:
634    TO_ROW_LIST row_list; 
635  };
636  ELISTIZEH(TO_BLOCK)
637  void find_cblob_limits( 
638      C_BLOB *blob,       
639      float leftx,        
640      float rightx,
641      FCOORD rotation, 
642      float &ymin,     
643      float &ymax);
644  void find_cblob_vlimits( 
645      C_BLOB *blob,        
646      float leftx,         
647      float rightx,
648      float &ymin, 
649      float &ymax);
650  void find_cblob_hlimits( 
651      C_BLOB *blob,        
652      float bottomy,       
653      float topy,
654      float &xmin, 
655      float &xymax);
656  C_BLOB *crotate_cblob( 
657      C_BLOB *blob,      
658      FCOORD rotation    
659  );
660  TBOX box_next(      
661      BLOBNBOX_IT *it 
662  );
663  TBOX box_next_pre_chopped( 
664      BLOBNBOX_IT *it        
665  );
666  void vertical_cblob_projection( 
667      C_BLOB *blob,               
668      STATS *stats                
669  );
670  void vertical_coutline_projection( 
671      C_OUTLINE *outline,            
672      STATS *stats                   
673  );
674  #ifndef GRAPHICS_DISABLED
675  void plot_blob_list(ScrollView *win,                 
676                      BLOBNBOX_LIST *list,             
677                      ScrollView::Color body_colour,   
678                      ScrollView::Color child_colour); 
679  #endif                                               
680  } 
681  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mpio.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobbox.h</div>
                <div class="column column_space"><pre><code>360  int PMPIO_Testsome(int, MPIO_Request *, int *, int *, MPI_Status *);
361  MPI_Fint PMPIO_Request_c2f(MPIO_Request);
362  MPIO_Request PMPIO_Request_f2c(MPI_Fint);
363  #endif &bsol;* HAVE_MPI_GREQUEST */
364  #ifndef HAVE_MPI_INFO
365  int PMPI_Info_create(MPI_Info *);
366  int PMPI_Info_set(MPI_Info, char *, char *);
367  int PMPI_Info_delete(MPI_Info, char *);
368  int PMPI_Info_get(MPI_Info, char *, int, char *, int *);
369  int PMPI_Info_get_valuelen(MPI_Info, char *, int *, int *);
370  int PMPI_Info_get_nkeys(MPI_Info, int *);
371  int PMPI_Info_get_nthkey(MPI_Info, int, char *);
372  int PMPI_Info_dup(MPI_Info, MPI_Info *);
373  int PMPI_Info_free(MPI_Info *);
374  MPI_Fint PMPI_Info_c2f(MPI_Info);
375  MPI_Info PMPI_Info_f2c(MPI_Fint);
376  #endif
377  #if defined(__cplusplus)
378  }
</pre></code></div>
                <div class="column column_space"><pre><code>525    float fixed_pitch;         
526    float fp_space;            
527    float fp_nonsp;            
528    float pr_space;            
529    float pr_nonsp;            
530    float spacing;             
531    float xheight;             
532    int xheight_evidence;      
533    float ascrise;             
534    float descdrop;            
535    float body_size;           
536    int32_t min_space;         
537    int32_t max_nonspace;      
538    int32_t space_threshold;   
539    float kern_size;           
540    float space_size;          
541    WERD_LIST rep_words;       
542    ICOORDELT_LIST char_cells; 
543    QSPLINE baseline;          
544    STATS projection;          
545  private:
546    void clear(); 
547    BLOBNBOX_LIST blobs; 
548    float y_min;         
549    float y_max;
550    float initial_y_min;
551    float m, c;   
552    float error;  
553    float para_c; 
554    float para_error;
555    float y_origin;         
556    float credibility;      
557    int num_repeated_sets_; 
558  };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    