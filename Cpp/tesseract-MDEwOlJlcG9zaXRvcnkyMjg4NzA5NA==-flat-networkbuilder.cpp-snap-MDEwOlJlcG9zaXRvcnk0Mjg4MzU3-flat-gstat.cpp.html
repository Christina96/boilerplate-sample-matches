
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.7064083457526085%, Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-networkbuilder.cpp</h3>
            <pre><code>1  #include "networkbuilder.h"
2  #include "convolve.h"
3  #include "fullyconnected.h"
4  #include "input.h"
5  #include "lstm.h"
6  #include "maxpool.h"
7  #include "network.h"
8  #include "parallel.h"
9  #include "reconfig.h"
10  #include "reversed.h"
11  #include "series.h"
12  #include "unicharset.h"
13  namespace tesseract {
14  bool NetworkBuilder::InitNetwork(int num_outputs, const char *network_spec, int append_index,
15                                   int net_flags, float weight_range, TRand *randomizer,
16                                   Network **network) {
17    NetworkBuilder builder(num_outputs);
18    Series *bottom_series = nullptr;
19    StaticShape input_shape;
20    if (append_index >= 0) {
21      ASSERT_HOST(*network != nullptr && (*network)->type() == NT_SERIES);
22      auto *series = static_cast<Series *>(*network);
23      Series *top_series = nullptr;
24      series->SplitAt(append_index, &bottom_series, &top_series);
25      if (bottom_series == nullptr || top_series == nullptr) {
26        tprintf("Yikes! Splitting current network failed!!\n");
27        return false;
28      }
29      input_shape = bottom_series->OutputShape(input_shape);
30      delete top_series;
31    }
32    *network = builder.BuildFromString(input_shape, &network_spec);
33    if (*network == nullptr) {
34      return false;
35    }
36    (*network)->SetNetworkFlags(net_flags);
37    (*network)->InitWeights(weight_range, randomizer);
38    (*network)->SetupNeedsBackprop(false);
39    if (bottom_series != nullptr) {
40      bottom_series->AppendSeries(*network);
41      *network = bottom_series;
42    }
43    (*network)->CacheXScaleFactor((*network)->XScaleFactor());
44    return true;
45  }
46  static void SkipWhitespace(const char **str) {
47    while (**str == ' ' || **str == '\t' || **str == '\n') {
48      ++*str;
49    }
50  }
51  Network *NetworkBuilder::BuildFromString(const StaticShape &input_shape, const char **str) {
52    SkipWhitespace(str);
53    char code_ch = **str;
54    if (code_ch == '[') {
55      return ParseSeries(input_shape, nullptr, str);
56    }
57    if (input_shape.depth() == 0) {
58      return ParseInput(str);
59    }
60    switch (code_ch) {
61      case '(':
62        return ParseParallel(input_shape, str);
63      case 'R':
64        return ParseR(input_shape, str);
65      case 'S':
66        return ParseS(input_shape, str);
67      case 'C':
68        return ParseC(input_shape, str);
69      case 'M':
70        return ParseM(input_shape, str);
71      case 'L':
72        return ParseLSTM(input_shape, str);
73      case 'F':
74        return ParseFullyConnected(input_shape, str);
75      case 'O':
76        return ParseOutput(input_shape, str);
77      default:
78        tprintf("Invalid network spec:%s\n", *str);
79        return nullptr;
80    }
81    return nullptr;
82  }
83  Network *NetworkBuilder::ParseInput(const char **str) {
84    int length = 0;
85    int batch, height, width, depth;
86    int num_converted = sscanf(*str, "%d,%d,%d,%d%n", &batch, &height, &width, &depth, &length);
87    StaticShape shape;
88    shape.SetShape(batch, height, width, depth);
89    if (num_converted != 4 && num_converted != 5) {
90      tprintf("Must specify an input layer as the first layer, not %s!!\n", *str);
91      return nullptr;
92    }
93    *str += length;
94    auto *input = new Input("Input", shape);
95    SkipWhitespace(str);
96    if (**str == '[') {
97      return ParseSeries(shape, input, str);
98    }
99    return input;
100  }
101  Network *NetworkBuilder::ParseSeries(const StaticShape &input_shape, Input *input_layer,
102                                       const char **str) {
103    StaticShape shape = input_shape;
104    auto *series = new Series("Series");
105    ++*str;
106    if (input_layer != nullptr) {
107      series->AddToStack(input_layer);
108      shape = input_layer->OutputShape(shape);
109    }
110    Network *network = nullptr;
111    while (**str != '\0' && **str != ']' && (network = BuildFromString(shape, str)) != nullptr) {
112      shape = network->OutputShape(shape);
113      series->AddToStack(network);
114    }
115    if (**str != ']') {
116      tprintf("Missing ] at end of [Series]!\n");
117      delete series;
118      return nullptr;
119    }
120    ++*str;
121    return series;
122  }
123  Network *NetworkBuilder::ParseParallel(const StaticShape &input_shape, const char **str) {
124    auto *parallel = new Parallel("Parallel", NT_PARALLEL);
125    ++*str;
126    Network *network = nullptr;
127    while (**str != '\0' && **str != ')' &&
128           (network = BuildFromString(input_shape, str)) != nullptr) {
129      parallel->AddToStack(network);
130    }
131    if (**str != ')') {
132      tprintf("Missing ) at end of (Parallel)!\n");
133      delete parallel;
134      return nullptr;
135    }
136    ++*str;
137    return parallel;
138  }
139  Network *NetworkBuilder::ParseR(const StaticShape &input_shape, const char **str) {
140    char dir = (*str)[1];
141    if (dir == 'x' || dir == 'y') {
142      std::string name = "Reverse";
143      name += dir;
144      *str += 2;
145      Network *network = BuildFromString(input_shape, str);
146      if (network == nullptr) {
147        return nullptr;
148      }
149      auto *rev = new Reversed(name, dir == 'y' ? NT_YREVERSED : NT_XREVERSED);
150      rev->SetNetwork(network);
151      return rev;
152    }
153    char *end;
154    int replicas = strtol(*str + 1, &end, 10);
155    *str = end;
156    if (replicas <= 0) {
157      tprintf("Invalid R spec!:%s\n", end);
158      return nullptr;
159    }
160    auto *parallel = new Parallel("Replicated", NT_REPLICATED);
161    const char *str_copy = *str;
162    for (int i = 0; i < replicas; ++i) {
163      str_copy = *str;
164      Network *network = BuildFromString(input_shape, &str_copy);
165      if (network == nullptr) {
166        tprintf("Invalid replicated network!\n");
167        delete parallel;
168        return nullptr;
169      }
170      parallel->AddToStack(network);
171    }
172    *str = str_copy;
173    return parallel;
174  }
175  Network *NetworkBuilder::ParseS(const StaticShape &input_shape, const char **str) {
176    char *end;
177    int y = strtol(*str + 1, &end, 10);
178    *str = end;
179    if (**str == ',') {
180      int x = strtol(*str + 1, &end, 10);
181      *str = end;
182      if (y <= 0 || x <= 0) {
183        tprintf("Invalid S spec!:%s\n", *str);
184        return nullptr;
185      }
186      return new Reconfig("Reconfig", input_shape.depth(), x, y);
187    } else if (**str == '(') {
188      tprintf("Generic reshape not yet implemented!!\n");
189      return nullptr;
190    }
191    tprintf("Invalid S spec!:%s\n", *str);
192    return nullptr;
193  }
<span onclick='openModal()' class='match'>194  static NetworkType NonLinearity(char func) {
195    switch (func) {
196      case 's':
197        return NT_LOGISTIC;
198      case 't':
199        return NT_TANH;
200      case 'r':
201        return NT_RELU;
202      case 'l':
203        return NT_LINEAR;
204      case 'm':
205        return NT_SOFTMAX;
206      case 'p':
207        return NT_POSCLIP;
208      case 'n':
209        return NT_SYMCLIP;
</span>210      default:
211        return NT_NONE;
212    }
213  }
214  Network *NetworkBuilder::ParseC(const StaticShape &input_shape, const char **str) {
215    NetworkType type = NonLinearity((*str)[1]);
216    if (type == NT_NONE) {
217      tprintf("Invalid nonlinearity on C-spec!: %s\n", *str);
218      return nullptr;
219    }
220    int y = 0, x = 0, d = 0;
221    char *end;
222    if ((y = strtol(*str + 2, &end, 10)) <= 0 || *end != ',' ||
223        (x = strtol(end + 1, &end, 10)) <= 0 || *end != ',' || (d = strtol(end + 1, &end, 10)) <= 0) {
224      tprintf("Invalid C spec!:%s\n", end);
225      return nullptr;
226    }
227    *str = end;
228    if (x == 1 && y == 1) {
229      return new FullyConnected("Conv1x1", input_shape.depth(), d, type);
230    }
231    auto *series = new Series("ConvSeries");
232    auto *convolve = new Convolve("Convolve", input_shape.depth(), x / 2, y / 2);
233    series->AddToStack(convolve);
234    StaticShape fc_input = convolve->OutputShape(input_shape);
235    series->AddToStack(new FullyConnected("ConvNL", fc_input.depth(), d, type));
236    return series;
237  }
238  Network *NetworkBuilder::ParseM(const StaticShape &input_shape, const char **str) {
239    int y = 0, x = 0;
240    char *end;
241    if ((*str)[1] != 'p' || (y = strtol(*str + 2, &end, 10)) <= 0 || *end != ',' ||
242        (x = strtol(end + 1, &end, 10)) <= 0) {
243      tprintf("Invalid Mp spec!:%s\n", *str);
244      return nullptr;
245    }
246    *str = end;
247    return new Maxpool("Maxpool", input_shape.depth(), x, y);
248  }
249  Network *NetworkBuilder::ParseLSTM(const StaticShape &input_shape, const char **str) {
250    bool two_d = false;
251    NetworkType type = NT_LSTM;
252    const char *spec_start = *str;
253    int chars_consumed = 1;
254    int num_outputs = 0;
255    char key = (*str)[chars_consumed], dir = 'f', dim = 'x';
256    if (key == 'S') {
257      type = NT_LSTM_SOFTMAX;
258      num_outputs = num_softmax_outputs_;
259      ++chars_consumed;
260    } else if (key == 'E') {
261      type = NT_LSTM_SOFTMAX_ENCODED;
262      num_outputs = num_softmax_outputs_;
263      ++chars_consumed;
264    } else if (key == '2' &&
265               (((*str)[2] == 'x' && (*str)[3] == 'y') || ((*str)[2] == 'y' && (*str)[3] == 'x'))) {
266      chars_consumed = 4;
267      dim = (*str)[3];
268      two_d = true;
269    } else if (key == 'f' || key == 'r' || key == 'b') {
270      dir = key;
271      dim = (*str)[2];
272      if (dim != 'x' && dim != 'y') {
273        tprintf("Invalid dimension (x|y) in L Spec!:%s\n", *str);
274        return nullptr;
275      }
276      chars_consumed = 3;
277      if ((*str)[chars_consumed] == 's') {
278        ++chars_consumed;
279        type = NT_LSTM_SUMMARY;
280      }
281    } else {
282      tprintf("Invalid direction (f|r|b) in L Spec!:%s\n", *str);
283      return nullptr;
284    }
285    char *end;
286    int num_states = strtol(*str + chars_consumed, &end, 10);
287    if (num_states <= 0) {
288      tprintf("Invalid number of states in L Spec!:%s\n", *str);
289      return nullptr;
290    }
291    *str = end;
292    Network *lstm = nullptr;
293    if (two_d) {
294      lstm = BuildLSTMXYQuad(input_shape.depth(), num_states);
295    } else {
296      if (num_outputs == 0) {
297        num_outputs = num_states;
298      }
299      std::string name(spec_start, *str - spec_start);
300      lstm = new LSTM(name, input_shape.depth(), num_states, num_outputs, false, type);
301      if (dir != 'f') {
302        auto *rev = new Reversed("RevLSTM", NT_XREVERSED);
303        rev->SetNetwork(lstm);
304        lstm = rev;
305      }
306      if (dir == 'b') {
307        name += "LTR";
308        auto *parallel = new Parallel("BidiLSTM", NT_PAR_RL_LSTM);
309        parallel->AddToStack(
310            new LSTM(name, input_shape.depth(), num_states, num_outputs, false, type));
311        parallel->AddToStack(lstm);
312        lstm = parallel;
313      }
314    }
315    if (dim == 'y') {
316      auto *rev = new Reversed("XYTransLSTM", NT_XYTRANSPOSE);
317      rev->SetNetwork(lstm);
318      lstm = rev;
319    }
320    return lstm;
321  }
322  Network *NetworkBuilder::BuildLSTMXYQuad(int num_inputs, int num_states) {
323    auto *parallel = new Parallel("2DLSTMQuad", NT_PAR_2D_LSTM);
324    parallel->AddToStack(new LSTM("L2DLTRDown", num_inputs, num_states, num_states, true, NT_LSTM));
325    auto *rev = new Reversed("L2DLTRXRev", NT_XREVERSED);
326    rev->SetNetwork(new LSTM("L2DRTLDown", num_inputs, num_states, num_states, true, NT_LSTM));
327    parallel->AddToStack(rev);
328    rev = new Reversed("L2DRTLYRev", NT_YREVERSED);
329    rev->SetNetwork(new LSTM("L2DRTLUp", num_inputs, num_states, num_states, true, NT_LSTM));
330    auto *rev2 = new Reversed("L2DXRevU", NT_XREVERSED);
331    rev2->SetNetwork(rev);
332    parallel->AddToStack(rev2);
333    rev = new Reversed("L2DXRevY", NT_YREVERSED);
334    rev->SetNetwork(new LSTM("L2DLTRDown", num_inputs, num_states, num_states, true, NT_LSTM));
335    parallel->AddToStack(rev);
336    return parallel;
337  }
338  static Network *BuildFullyConnected(const StaticShape &input_shape, NetworkType type,
339                                      const std::string &name, int depth) {
340    if (input_shape.height() == 0 || input_shape.width() == 0) {
341      tprintf("Fully connected requires positive height and width, had %d,%d\n", input_shape.height(),
342              input_shape.width());
343      return nullptr;
344    }
345    int input_size = input_shape.height() * input_shape.width();
346    int input_depth = input_size * input_shape.depth();
347    Network *fc = new FullyConnected(name, input_depth, depth, type);
348    if (input_size > 1) {
349      auto *series = new Series("FCSeries");
350      series->AddToStack(
351          new Reconfig("FCReconfig", input_shape.depth(), input_shape.width(), input_shape.height()));
352      series->AddToStack(fc);
353      fc = series;
354    }
355    return fc;
356  }
357  Network *NetworkBuilder::ParseFullyConnected(const StaticShape &input_shape, const char **str) {
358    const char *spec_start = *str;
359    NetworkType type = NonLinearity((*str)[1]);
360    if (type == NT_NONE) {
361      tprintf("Invalid nonlinearity on F-spec!: %s\n", *str);
362      return nullptr;
363    }
364    char *end;
365    int depth = strtol(*str + 2, &end, 10);
366    if (depth <= 0) {
367      tprintf("Invalid F spec!:%s\n", *str);
368      return nullptr;
369    }
370    *str = end;
371    std::string name(spec_start, *str - spec_start);
372    return BuildFullyConnected(input_shape, type, name, depth);
373  }
374  Network *NetworkBuilder::ParseOutput(const StaticShape &input_shape, const char **str) {
375    char dims_ch = (*str)[1];
376    if (dims_ch != '0' && dims_ch != '1' && dims_ch != '2') {
377      tprintf("Invalid dims (2|1|0) in output spec!:%s\n", *str);
378      return nullptr;
379    }
380    char type_ch = (*str)[2];
381    if (type_ch != 'l' && type_ch != 's' && type_ch != 'c') {
382      tprintf("Invalid output type (l|s|c) in output spec!:%s\n", *str);
383      return nullptr;
384    }
385    char *end;
386    int depth = strtol(*str + 3, &end, 10);
387    if (depth != num_softmax_outputs_) {
388      tprintf("Warning: given outputs %d not equal to unicharset of %d.\n", depth,
389              num_softmax_outputs_);
390      depth = num_softmax_outputs_;
391    }
392    *str = end;
393    NetworkType type = NT_SOFTMAX;
394    if (type_ch == 'l') {
395      type = NT_LOGISTIC;
396    } else if (type_ch == 's') {
397      type = NT_SOFTMAX_NO_CTC;
398    }
399    if (dims_ch == '0') {
400      return BuildFullyConnected(input_shape, type, "Output", depth);
401    } else if (dims_ch == '2') {
402      return new FullyConnected("Output2d", input_shape.depth(), depth, type);
403    }
404    if (input_shape.height() == 0) {
405      tprintf("Fully connected requires fixed height!\n");
406      return nullptr;
407    }
408    int input_size = input_shape.height();
409    int input_depth = input_size * input_shape.depth();
410    Network *fc = new FullyConnected("Output", input_depth, depth, type);
411    if (input_size > 1) {
412      auto *series = new Series("FCSeries");
413      series->AddToStack(new Reconfig("FCReconfig", input_shape.depth(), 1, input_shape.height()));
414      series->AddToStack(fc);
415      fc = series;
416    }
417    return fc;
418  }
419  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gstat.cpp</h3>
            <pre><code>1  int TGStat::NDiamRuns = 10;
2  int TGStat::TakeSngVals = 100;
3  const TFltPrV TGStat::EmptyV = TFltPrV();
4  bool TGStat::TCmpByVal::operator () (const TGStat& GS1, const TGStat& GS2) const {
5    IAssertR(GS1.HasVal(ValCmp) && GS2.HasVal(ValCmp), TStr::Fmt("CmpVal: %d (%s)", 
6      int(ValCmp), TGStat::GetValStr(ValCmp).CStr()).CStr());
7    bool Res;
8    if (ValCmp == gsvTime) { Res = GS1.Time < GS2.Time; }
9    else { Res = GS1.GetVal(ValCmp) < GS2.GetVal(ValCmp); }
10    if (SortAsc) { return Res; }
11    else { return ! Res; }
12  }
13  bool TGStat::TCmpByVal::operator () (const PGStat& GS1, const PGStat& GS2) const {
14    return operator()(*GS1, *GS2);
15  }
16  TGStat::TGStat(const TSecTm& GraphTm, const TStr& GraphName) :
17    Time(GraphTm), GraphNm(GraphName), ValStatH(), DistrStatH() {
18  }
19  TGStat::TGStat(const PNGraph& Graph, const TSecTm& GraphTm, TFSet StatFSet, const TStr& GraphName) {
20    TakeStat(Graph, GraphTm, StatFSet, GraphName);
21  }
22  TGStat::TGStat(const PUNGraph& Graph, const TSecTm& GraphTm, TFSet StatFSet, const TStr& GraphName) {
23    TakeStat(Graph, GraphTm, StatFSet, GraphName);
24  }
25  TGStat::TGStat(const PNEGraph& Graph, const TSecTm& GraphTm, TFSet StatFSet, const TStr& GraphName) {
26    TakeStat(Graph, GraphTm, StatFSet, GraphName);
27  }
28  TGStat::TGStat(const TGStat& GStat) : Time(GStat.Time), GraphNm(GStat.GraphNm),
29    ValStatH(GStat.ValStatH), DistrStatH(GStat.DistrStatH) {
30  }
31  TGStat::TGStat(TSIn& SIn) : Time(SIn), GraphNm(SIn), ValStatH(SIn), DistrStatH(SIn) { }
32  void TGStat::Save(TSOut& SOut) const {
33    Time.Save(SOut);  GraphNm.Save(SOut);
34    ValStatH.Save(SOut);  DistrStatH.Save(SOut);
35  }
36  TGStat& TGStat::operator = (const TGStat& GStat) {
37    if (this != &GStat) {
38      Time = GStat.Time;
39      GraphNm = GStat.GraphNm;
40      ValStatH = GStat.ValStatH;
41      DistrStatH = GStat.DistrStatH;
42    }
43    return *this;
44  }
45  bool TGStat::operator == (const TGStat& GStat) const {
46    return Time==GStat.Time && ValStatH==GStat.ValStatH && DistrStatH==GStat.DistrStatH;
47  }
48  bool TGStat::operator < (const TGStat& GStat) const {
49    if (Time<GStat.Time) { return true; }
50    if (Time>GStat.Time) { return false; }
51    if (ValStatH.Empty() && ! GStat.ValStatH.Empty()) { return true; }
52    if (GStat.ValStatH.Empty()) { return false; }
53    for (int v = gsvTime; v < gsvMx; v++) {
54      if (! ValStatH.IsKey(v) && ! GStat.ValStatH.IsKey(v)) { continue; }
55      if (ValStatH.IsKey(v) && ! GStat.ValStatH.IsKey(v)) { return false; }
56      if (! ValStatH.IsKey(v)) { return true; }
57      if (ValStatH.GetDat(v) < GStat.ValStatH.GetDat(v)) { return true; }
58    }
59    return false;
60  }
61  bool TGStat::HasVal(const TGStatVal& StatVal) const {
62    if (StatVal == gsvIndex) { return true; }
63    if (StatVal == gsvTime) { return Time.IsDef(); }
64    return ValStatH.IsKey(int(StatVal));
65  }
66  double TGStat::GetVal(const TGStatVal& StatVal) const {
67    if (StatVal == gsvIndex) { return -1; }
68    if (StatVal == gsvTime) { return Time.GetAbsSecs(); }
69    if (! ValStatH.IsKey(int(StatVal))) { return -1.0; }
70    return ValStatH.GetDat(int(StatVal));
71  }
72  void TGStat::SetVal(const TGStatVal& StatVal, const double& Val) {
73    ValStatH.AddDat(int(StatVal), Val);
74  }
75  const TFltPrV& TGStat::GetDistr(const TGStatDistr& Distr) const {
76    if (! DistrStatH.IsKey(int(Distr))) { return EmptyV; }
77    return DistrStatH.GetDat(int(Distr));
78  }
79  void TGStat::SetDistr(const TGStatDistr& Distr, const TFltPrV& FltPrV) {
80    DistrStatH.AddDat(Distr, FltPrV);
81  }
82  void TGStat::GetDistr(const TGStatDistr& Distr, TFltPrV& FltPrV) const {
83    FltPrV = GetDistr(Distr);
84  }
85  void TGStat::TakeStat(const PNGraph& Graph, const TSecTm& _Time, TFSet StatFSet, const TStr& GraphName) {
86    printf("\n===TakeStat:  G(%u, %u) at %s\n", Graph->GetNodes(), Graph->GetEdges(), _Time.IsDef()?_Time.GetStr().CStr():"");
87    TExeTm ExeTm, FullTm;
88    Time = _Time;
89    GraphNm = GraphName;
90    if (StatFSet.In(gsvNone)) { return; }
91    TakeBasicStat(Graph, false);
92    TakeDiam(Graph, StatFSet, false);
93    if (StatFSet.In(gsdWcc) || StatFSet.In(gsdWccHops) || StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsvWccNodes) || StatFSet.In(gsvWccSrcNodes) || StatFSet.In(gsvWccDstNodes) || StatFSet.In(gsvWccEdges) || StatFSet.In(gsvWccUniqEdges) || StatFSet.In(gsvWccBiDirEdges)) {
94      PNGraph WccGraph = TSnap::GetMxWcc(Graph);
95      TakeBasicStat(WccGraph, true);
96      TakeDiam(WccGraph, StatFSet, true);
97      SetVal(gsvWccSize, WccGraph->GetNodes()/double(Graph->GetNodes()));
98    }
99    TakeSccStat(Graph, StatFSet);
100    TakeBccStat(Graph, StatFSet);
101    TakeDegDistr(Graph, StatFSet);
102    TakeConnComp(Graph, StatFSet);
103    TakeSpectral(Graph, StatFSet, -1);
104    if (StatFSet.In(gsdClustCf) || StatFSet.In(gsvClustCf)) {
105      TakeClustCf(Graph); }
106    if (StatFSet.In(gsdTriadPart)) {
107      TakeTriadPart(Graph); }
108    printf("**[%s]\n", FullTm.GetTmStr());
109  }
110  void TGStat::TakeStat(const PUNGraph& Graph, const TSecTm& _Time, TFSet StatFSet, const TStr& GraphName) {
111    printf("\n===TakeStat:  UG(%u, %u) at %s\n", Graph->GetNodes(), Graph->GetEdges(), _Time.IsDef()?_Time.GetStr().CStr():"");
112    TExeTm ExeTm, FullTm;
113    Time = _Time;
114    GraphNm = GraphName;
115    if (StatFSet.In(gsvNone)) { return; }
116    TakeBasicStat(Graph, false);
117    TakeDiam(Graph, StatFSet, false);
118    if (StatFSet.In(gsdWcc) || StatFSet.In(gsdWccHops) || StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsvWccNodes) || StatFSet.In(gsvWccSrcNodes) || StatFSet.In(gsvWccDstNodes) || StatFSet.In(gsvWccEdges) || StatFSet.In(gsvWccUniqEdges) || StatFSet.In(gsvWccBiDirEdges)) {
119      PUNGraph WccGraph = TSnap::GetMxWcc(Graph);
120      TakeBasicStat(WccGraph, true);
121      TakeDiam(WccGraph, StatFSet, true);
122      SetVal(gsvWccSize, WccGraph->GetNodes()/double(Graph->GetNodes()));
123    }
124    TakeBccStat(Graph, StatFSet);
125    TakeDegDistr(Graph, StatFSet);
126    TakeConnComp(Graph, StatFSet);
127    if (StatFSet.In(gsdClustCf) || StatFSet.In(gsvClustCf)) {
128      TakeClustCf(Graph); }
129    if (StatFSet.In(gsdTriadPart)) {
130      TakeTriadPart(Graph); }
131    printf("**[%s]\n", FullTm.GetTmStr());
132  }
133  void TGStat::TakeSpectral(const PNGraph& Graph, const int _TakeSngVals) {
134    TakeSpectral(Graph, TFSet() | gsdSngVal | gsdSngVec, _TakeSngVals);
135  }
136  void TGStat::TakeSpectral(const PNGraph& Graph, TFSet StatFSet, int _TakeSngVals) {
137    TExeTm ExeTm;
138    if (_TakeSngVals == -1) { _TakeSngVals = TakeSngVals; }
139    if (StatFSet.In(gsdSngVal)) {
140      printf("sing-vals...");  
141      const int SngVals = TMath::Mn(_TakeSngVals, Graph->GetNodes()/2);
142      TFltV SngValV1;
143      TSnap::GetSngVals(Graph, SngVals, SngValV1);
144      SngValV1.Sort(false);
145      TFltPrV& SngValV = DistrStatH.AddDat(gsdSngVal);
146      SngValV.Gen(SngValV1.Len(), 0);
147      for (int i = 0; i < SngValV1.Len(); i++) {
148        SngValV.Add(TFltPr(i+1, SngValV1[i]));
149      }
150      printf("[%s]  ", ExeTm.GetTmStr());
151    }
152    if (StatFSet.In(gsdSngVec)) {
153      printf("sing-vec...");  
154      TFltV LeftV, RightV;
155      TSnap::GetSngVec(Graph, LeftV, RightV);
156      LeftV.Sort(false);
157      TFltPrV& SngVec = DistrStatH.AddDat(gsdSngVec);
158      SngVec.Gen(LeftV.Len(), 0);
159      for (int i = 0; i < TMath::Mn(Kilo(10), LeftV.Len()/2); i++) {
160        if (LeftV[i] > 0) { SngVec.Add(TFltPr(i+1, LeftV[i])); }
161      }
162      printf("[%s]  ", ExeTm.GetTmStr());
163    }
164  }
165  void TGStat::Plot(const TGStatDistr& Distr, const TStr& FNmPref, TStr Desc, bool PowerFit) const {
166    if (Desc.Empty()) Desc = FNmPref.GetUc();
167    if (! HasDistr(Distr) || Distr==gsdUndef || Distr==gsdMx) { return; }
168    TPlotInfo Info = GetPlotInfo(Distr);
169    TGnuPlot GnuPlot(Info.Val1+TStr(".")+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(),GetEdges()));
170    GnuPlot.SetXYLabel(Info.Val2, Info.Val3);
171    GnuPlot.SetScale(Info.Val4);
172    const int plotId = GnuPlot.AddPlot(GetDistr(Distr), gpwLinesPoints, "");
173    if (PowerFit) { GnuPlot.AddPwrFit(plotId, gpwLines); }
174    #ifdef GLib_MACOSX
175    GnuPlot.SaveEps();
176    #else
177    GnuPlot.SavePng();
178    #endif
179  }
180  void TGStat::Plot(const TFSet& FSet, const TStr& FNmPref, const TStr& Desc, bool PowerFit) const {
181    for (int d = gsdUndef; d < gsdMx; d++) {
182      const TGStatDistr Distr = TGStatDistr(d);
183      if (! FSet.In(Distr)) { continue; }
184      Plot(Distr, FNmPref, Desc, PowerFit);
185    }
186  }
187  void TGStat::PlotAll(const TStr& FNmPref, TStr Desc, bool PowerFit) const {
188    for (int d = gsdUndef; d < gsdMx; d++) {
189      const TGStatDistr Distr = TGStatDistr(d);
190      Plot(Distr, FNmPref, Desc, PowerFit);
191    }
192  }
193  void TGStat::DumpValStat() {
194    for (int val = gsvNone; val < gsvMx; val++) {
195      const TGStatVal Val = TGStatVal(val);
196      if (! HasVal(Val)) { continue; }
197      printf("  %s\t%g\n", GetValStr(Val).CStr(), GetVal(Val));
198    }
199  }
200  void TGStat::AvgGStat(const PGStatVec& GStatVec, const bool& ClipAt1) {
201    AvgGStat(GStatVec->GetGStatV(), ClipAt1);
202  }
203  void TGStat::AvgGStat(const TGStatV& GStatV, const bool& ClipAt1) {
204    if (GStatV.Empty()) return;
205    Time = GStatV[0]->Time;
206    GraphNm = GStatV[0]->GraphNm;
207    for (int statVal = 0; statVal > gsvMx; statVal++) {
208      const TGStatVal GStatVal = TGStatVal(statVal);
209      TMom Mom;
210      for (int i = 0; i < GStatV.Len(); i++) {
211        if (GStatV[i]->HasVal(GStatVal)) {
212          Mom.Add(GStatV[i]->GetVal(GStatVal)); }
213      }
214      Mom.Def();
215      if (Mom.IsUsable()) {
216        IAssert(Mom.GetVals() == GStatV.Len()); 
217        SetVal(GStatVal, Mom.GetMean());
218      }
219    }
220    for (int distr = gsdUndef; distr < gsdMx; distr++) {
221      const TGStatDistr GStatDistr = TGStatDistr(distr);
222      THash<TFlt, TFlt> ValToSumH;
223      int DistrCnt = 0;
224      for (int i = 0; i < GStatV.Len(); i++) {
225        if (GStatV[i]->HasDistr(GStatDistr)) {
226          const TFltPrV& D = GStatV[i]->GetDistr(GStatDistr);
227          for (int d = 0; d < D.Len(); d++) {
228            ValToSumH.AddDat(D[d].Val1) += D[d].Val2; }
229          DistrCnt++;
230        }
231      }
232      IAssert(DistrCnt==0 || DistrCnt==GStatV.Len()); 
233      TFltPrV AvgStatV;
234      ValToSumH.GetKeyDatPrV(AvgStatV);  AvgStatV.Sort();
235      for (int i = 0; i < AvgStatV.Len(); i++) {
236        AvgStatV[i].Val2 /= double(DistrCnt);
237        if (ClipAt1 && AvgStatV[i].Val2 < 1) { AvgStatV[i].Val2 = 1; }
238      }
239      SetDistr(GStatDistr, AvgStatV);
240    }
241  }
242  TStr TGStat::GetDistrStr(const TGStatDistr& Distr) {
243    switch (Distr) {
244      case gsdUndef : return TStr("Undef");
245      case gsdInDeg : return "InDeg";
246      case gsdOutDeg : return "OutDeg";
247      case gsdWcc : return "WccDist";
248      case gsdScc : return "SccDist";
249      case gsdHops : return "Hops";
250      case gsdWccHops : return "WccHops";
251      case gsdSngVal : return "SngVal";
252      case gsdSngVec : return "SngVec";
253      case gsdClustCf : return "ClustCf";
254      case gsdTriadPart : return "TriadPart";
255      case gsdMx: return TStr("Mx");
256      default: Fail; return TStr();
257    };
258  }
259  TStr TGStat::GetValStr(const TGStatVal& Val) {
260    static TIntStrH ValTyStrH;
261    if (ValTyStrH.Empty()) {
262      ValTyStrH.AddDat(gsvNone, "None");
263      ValTyStrH.AddDat(gsvIndex, "Index");
264      ValTyStrH.AddDat(gsvTime, "Time");
265      ValTyStrH.AddDat(gsvNodes, "Nodes");
266      ValTyStrH.AddDat(gsvZeroNodes, "ZeroNodes");
267      ValTyStrH.AddDat(gsvNonZNodes, "NonZNodes");
268      ValTyStrH.AddDat(gsvSrcNodes, "SrcNodes");
269      ValTyStrH.AddDat(gsvDstNodes, "DstNodes");
270      ValTyStrH.AddDat(gsvEdges, "Edges");
271      ValTyStrH.AddDat(gsvUniqEdges, "UniqEdges");
272      ValTyStrH.AddDat(gsvBiDirEdges, "BiDirEdges");
273      ValTyStrH.AddDat(gsvWccNodes, "WccNodes");
274      ValTyStrH.AddDat(gsvWccSrcNodes, "WccSrcNodes");
275      ValTyStrH.AddDat(gsvWccDstNodes, "WccDstNodes");
276      ValTyStrH.AddDat(gsvWccEdges, "WccEdges");
277      ValTyStrH.AddDat(gsvWccUniqEdges, "WccUniqEdges");
278      ValTyStrH.AddDat(gsvWccBiDirEdges, "WccBiDirEdges");
279      ValTyStrH.AddDat(gsvSccNodes, "SccNodes");
280      ValTyStrH.AddDat(gsvSccEdges, "SccEdges");
281      ValTyStrH.AddDat(gsvBccNodes, "BccNodes");
282      ValTyStrH.AddDat(gsvBccEdges, "BccEdges");
283      ValTyStrH.AddDat(gsvFullDiam, "FullDiam");
284      ValTyStrH.AddDat(gsvEffDiam, "EffDiam");
285      ValTyStrH.AddDat(gsvEffWccDiam, "EffWccDiam");
286      ValTyStrH.AddDat(gsvFullWccDiam, "FullWccDiam");
287      ValTyStrH.AddDat(gsvFullDiamDev, "FullDiamDev");
288      ValTyStrH.AddDat(gsvEffDiamDev, "EffDiamDev");
289      ValTyStrH.AddDat(gsvEffWccDiamDev, "EffWccDiamDev");
290      ValTyStrH.AddDat(gsvFullWccDiamDev, "FullWccDiamDev");
291      ValTyStrH.AddDat(gsvClustCf, "ClustCf");
292      ValTyStrH.AddDat(gsvOpenTriads, "OpenTr");
293      ValTyStrH.AddDat(gsvClosedTriads, "ClosedTr");
294      ValTyStrH.AddDat(gsvWccSize, "WccSize");
295      ValTyStrH.AddDat(gsvSccSize, "SccSize");
296      ValTyStrH.AddDat(gsvBccSize, "BccSize");
297      ValTyStrH.AddDat(gsvMx, "Mx");
298    }
299    IAssert(ValTyStrH.IsKey(int(Val)));
300    return ValTyStrH.GetDat(int(Val));
301  }
302  TGStat::TPlotInfo TGStat::GetPlotInfo(const TGStatVal& Val) {
303    Fail;
304    return TPlotInfo();
305  }
<span onclick='openModal()' class='match'>306  TGStat::TPlotInfo TGStat::GetPlotInfo(const TGStatDistr& Distr) {
307    switch (Distr) {
308      case gsdUndef : Fail; return TPlotInfo();
309      case gsdInDeg : return TPlotInfo("inDeg", "In-degree, k", "Count", gpsLog10XY);
310      case gsdOutDeg : return TPlotInfo("outDeg", "Out-degree, k", "Count", gpsLog10XY);
311      case gsdWcc : return TPlotInfo("wcc", "WCC size", "Count", gpsLog10XY);
312      case gsdScc : return TPlotInfo("scc", "SCC size", "Count", gpsLog10XY);
313      case gsdHops : return TPlotInfo("hop", "Number of hops, h", "Reachable pairs of nodes inside h hops", gpsLog10Y);
314      case gsdWccHops : return TPlotInfo("wccHop", "Number of hops, h", "Reachable pairs of nodes inside h hops in WCC", gpsLog10Y);
</span>315      case gsdSngVal : return TPlotInfo("sval", "Rank", "Singular value", gpsLog10XY);
316      case gsdSngVec : return TPlotInfo("svec", "Rank", "Left singular vector", gpsLog10XY);
317      case gsdClustCf : return TPlotInfo("ccf", "Degree, k", "Clustering coefficient, <C(k)>", gpsLog10XY);
318      case gsdTriadPart : return TPlotInfo("triad", "Number of triads adjacent to a node", "Number of such nodes", gpsLog10XY);
319      case gsdMx : Fail;
320      default: Fail; return TPlotInfo();
321    };
322  }
323  TFSet TGStat::NoStat() {
324    return TFSet() | gsvNone;
325  }
326  TFSet TGStat::BasicStat() {
327    return TFSet();
328  }
329  TFSet TGStat::DegDStat() {
330    return TFSet() | gsdInDeg |  gsdOutDeg;
331  }
332  TFSet TGStat::NoDiamStat() {
333    return TFSet() | gsdInDeg |  gsdOutDeg |  gsdWcc |  gsdScc;
334  }
335  TFSet TGStat::NoDistrStat() {
336    return TFSet() | gsdHops | gsdWccHops;
337  }
338  TFSet TGStat::NoSvdStat() {
339    return TFSet() | gsdInDeg |  gsdOutDeg |  gsdWcc |  gsdScc |
340      gsdHops |  gsdWccHops | gsdClustCf | gsdTriadPart;
341  }
342  TFSet TGStat::AllStat() {
343    return TFSet() | gsdInDeg |  gsdOutDeg |  gsdWcc |  gsdScc
344      | gsdHops |  gsdWccHops | gsdClustCf | gsdTriadPart 
345      | gsdSngVec | gsdSngVal | gsvFullDiam;
346  }
347  uint TGStatVec::MinNodesEdges = 10;
348  TGStatVec::TGStatVec(const TTmUnit& _TmUnit) : TmUnit(_TmUnit), StatFSet(), GStatV() {
349    StatFSet = TGStat::AllStat();
350  }
351  TGStatVec::TGStatVec(const TTmUnit& _TmUnit, const TFSet& TakeGrowthStat) :
352     TmUnit(_TmUnit), StatFSet(TakeGrowthStat), GStatV() {
353  }
354  TGStatVec::TGStatVec(const TGStatVec& GStat) :
355    TmUnit(GStat.TmUnit), StatFSet(GStat.StatFSet), GStatV(GStat.GStatV) {
356  }
357  TGStatVec::TGStatVec(TSIn& SIn) : TmUnit((TTmUnit) TInt(SIn).Val), StatFSet(SIn), GStatV(SIn) {
358  }
359  PGStatVec TGStatVec::New(const TTmUnit& _TmUnit) {
360    return new TGStatVec(_TmUnit);
361  }
362  PGStatVec TGStatVec::New(const TTmUnit& _TmUnit, const TFSet& TakeGrowthStat) {
363    return new TGStatVec(_TmUnit, TakeGrowthStat);
364  }
365  void TGStatVec::Save(TSOut& SOut) const {
366    TInt(TmUnit).Save(SOut);
367    StatFSet.Save(SOut);
368    GStatV.Save(SOut);
369  }
370  TGStatVec& TGStatVec::operator = (const TGStatVec& GStat) {
371    if (this != &GStat) {
372      TmUnit = GStat.TmUnit;
373      StatFSet = GStat.StatFSet;
374      GStatV = GStat.GStatV;
375    }
376    return *this;
377  }
378  PGStat TGStatVec::Add() {
379    GStatV.Add(TGStat::New());
380    return GStatV.Last();
381  }
382  PGStat TGStatVec::Add(const TSecTm& Time, const TStr& GraphNm) {
383    GStatV.Add(TGStat::New(Time, GraphNm));
384    return GStatV.Last();
385  }
386  void TGStatVec::Add(const PNGraph& Graph, const TSecTm& Time, const TStr& GraphNm) {
387    if (Graph->GetNodes() < (int) TGStatVec::MinNodesEdges) {
388      printf(" ** TGStatVec::Add: graph too small (%d nodes).SKIP\n", Graph->GetNodes());
389      return;
390    }
391    Add(TGStat::New(Graph, Time, StatFSet, GraphNm));
392  }
393  void TGStatVec::Add(const PUNGraph& Graph, const TSecTm& Time, const TStr& GraphNm) {
394    if (Graph->GetNodes() < (int) TGStatVec::MinNodesEdges) {
395      printf(" ** TGStatVec::Add: graph too small (%d nodes).SKIP\n", Graph->GetNodes());
396      return;
397    }
398    Add(TGStat::New(Graph, Time, StatFSet, GraphNm));
399  }
400  void TGStatVec::Add(const PNEGraph& Graph, const TSecTm& Time, const TStr& GraphNm) {
401    if (Graph->GetNodes() < (int) TGStatVec::MinNodesEdges) {
402      printf(" ** TGStatVec::Add: graph too small (%d nodes).SKIP\n", Graph->GetNodes());
403      return;
404    }
405    Add(TGStat::New(Graph, Time, StatFSet, GraphNm));
406  }
407  void TGStatVec::Sort(const TGStatVal& SortBy, const bool& Asc) {
408    GStatV.SortCmp(TGStat::TCmpByVal(SortBy, Asc));
409  }
410  void TGStatVec::DelBefore(const TSecTm& Tm) {
411    TGStatV NewTickV;
412    for (int i = 0; i < Len(); i++) {
413      if (At(i)->Time >= Tm) { NewTickV.Add(At(i)); }
414    }
415    GStatV.Swap(NewTickV);
416  }
417  void TGStatVec::DelAfter(const TSecTm& Tm) {
418    TGStatV NewTickV;
419    for (int i = 0; i < Len(); i++) {
420      if (At(i)->Time <= Tm) { NewTickV.Add(At(i)); }
421    }
422    GStatV.Swap(NewTickV);
423  }
424  void TGStatVec::DelSmallNodes(const int& MinNodes) {
425    TGStatV NewTickV;
426    for (int i = 0; i < Len(); i++) {
427      if (At(i)->GetNodes() >= MinNodes) { NewTickV.Add(At(i)); }
428    }
429    GStatV.Swap(NewTickV);
430  }
431  void TGStatVec::GetValV(const TGStatVal& XVal, const TGStatVal& YVal, TFltPrV& ValV) const {
432    ValV.Gen(Len(), 0);
433    double x;
434    for (int t = 0; t < Len(); t++) {
435      if (XVal == gsvIndex) { x = t+1; }
436      else if (XVal == gsvTime) { x = GetTime(t); }
437      else { x = At(t)->GetVal(XVal); }
438      ValV.Add(TFltPr(x, At(t)->GetVal(YVal)));
439    }
440    ValV.Sort(true); 
441  }
442  PGStat TGStatVec::GetAvgGStat(const bool& ClipAt1) {
443    PGStat Stat = TGStat::New();
444    Stat->AvgGStat(GStatV, ClipAt1);
445    return Stat;
446  }
447  void TGStatVec::Plot(const TGStatVal& XVal, const TGStatVal& YVal, const TStr& OutFNm, TStr& Desc, const TGpScaleTy& Scale,const bool& PowerFit) const {
448    if (! Last()->HasVal(XVal) || ! Last()->HasVal(YVal)) {
449      if (! Last()->HasVal(XVal)) { printf("** Does not have %s statistic\n", TGStat::GetValStr(XVal).CStr()); }
450      if (! Last()->HasVal(YVal)) { printf("** Does not have %s statistic\n", TGStat::GetValStr(YVal).CStr()); }
451      return;
452    }
453    if (Desc.Empty()) { Desc = OutFNm; }
454    TFltPrV ValV;
455    TGStatVec::GetValV(XVal, YVal, ValV);
456    TGnuPlot GP(TStr::Fmt("%s-%s.%s", TGStat::GetValStr(XVal).CStr(), TGStat::GetValStr(YVal).CStr(), OutFNm.CStr()),
457      TStr::Fmt("%s. %s vs. %s. G(%d,%d)", Desc.CStr(), TGStat::GetValStr(XVal).CStr(), TGStat::GetValStr(YVal).CStr(),
458      Last()->GetNodes(), Last()->GetEdges()));
459    GP.SetScale(Scale);
460    GP.SetXYLabel(TGStat::GetValStr(XVal), TGStat::GetValStr(YVal));
461    const int Id = GP.AddPlot(ValV, gpwLinesPoints);
462    if (PowerFit) { GP.AddPwrFit(Id); }
463    GP.SavePng();
464  }
465  void TGStatVec::PlotAllVsX(const TGStatVal& XVal, const TStr& OutFNm, TStr Desc, const TGpScaleTy& Scale, const bool& PowerFit) const {
466    const TFSet SkipStat = TFSet() | gsvFullDiamDev | gsvEffDiamDev | gsvEffWccDiamDev | gsvFullWccDiamDev;
467    for (int stat = gsvNone; stat < gsvMx; stat++) {
468      const TGStatVal Stat = TGStatVal(stat);
469      if (SkipStat.In(Stat)) { continue; }
470      if (Last()->HasVal(Stat) && Last()->HasVal(XVal) && Stat!=XVal) {
471        Plot(XVal, Stat, OutFNm, Desc, Scale, PowerFit);
472      }
473    }
474  }
475  void TGStatVec::ImposeDistr(const TGStatDistr& Distr, const TStr& FNmPref, TStr Desc, const bool& ExpBin, 
476      const bool& PowerFit, const TGpSeriesTy& PlotWith, const TStr& Style) const {
477    if (Desc.Empty()) Desc = FNmPref.GetUc();
478    if (! At(0)->HasDistr(Distr) || Distr==gsdUndef || Distr==gsdMx) { return; }
479    TGStat::TPlotInfo Info = At(0)->GetPlotInfo(Distr);
480    TGnuPlot GnuPlot(Info.Val1+TStr(".")+FNmPref, TStr::Fmt("%s. G(%d, %d) --> G(%d, %d)", Desc.CStr(),
481      At(0)->GetNodes(), At(0)->GetEdges(), Last()->GetNodes(), Last()->GetEdges()));
482    GnuPlot.SetXYLabel(Info.Val2, Info.Val3);
483    GnuPlot.SetScale(Info.Val4);
484    int plotId;
485    for (int at = 0; at < Len(); at++) {
486      TStr Legend = At(at)->GetNm();
487      if (Legend.Empty()) { Legend = At(at)->GetTmStr(); }
488      if (! ExpBin) { 
489        plotId = GnuPlot.AddPlot(At(at)->GetDistr(Distr), PlotWith, Legend, Style); }
490      else { 
491        TFltPrV ExpBinV; 
492        TGnuPlot::MakeExpBins(At(at)->GetDistr(Distr), ExpBinV, 2, 0);
493        plotId = GnuPlot.AddPlot(ExpBinV, PlotWith, Legend, Style);
494      }
495      if (PowerFit) { GnuPlot.AddPwrFit(plotId, gpwLines); }
496    }
497    GnuPlot.SavePng();
498  }
499  void TGStatVec::SaveTxt(const TStr& FNmPref, const TStr& Desc) const {
500    FILE *F = fopen(TStr::Fmt("growth.%s.tab", FNmPref.CStr()).CStr(), "wt");
501    fprintf(F, "# %s\n", Desc.CStr());
502    fprintf(F, "# %s", TTmInfo::GetTmUnitStr(TmUnit).CStr());
503    TIntSet StatValSet;
504    for (int i = 0; i < Len(); i++) {
505      for (int v = gsvNone; v < gsvMx; v++) {
506        if (At(i)->HasVal(TGStatVal(v))) { StatValSet.AddKey(v); }
507      }
508    }
509    TIntV StatValV;  StatValSet.GetKeyV(StatValV);  StatValV.Sort();
510    for (int sv = 0; sv < StatValV.Len(); sv++) {
511      fprintf(F, "\t%s", TGStat::GetValStr(TGStatVal(StatValV[sv].Val)).CStr()); }
512    fprintf(F, "Time\n");
513    for (int i = 0; i < Len(); i++) {
514      const TGStat& G = *At(i);
515      for (int sv = 0; sv < StatValV.Len(); sv++) {
516        fprintf(F, "%g\t", G.GetVal(TGStatVal(StatValV[sv].Val))); }
517      fprintf(F, "%s\n", G.GetTmStr().CStr());
518    }
519    fclose(F);
520  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-networkbuilder.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gstat.cpp</div>
                </div>
                <div class="column column_space"><pre><code>194  static NetworkType NonLinearity(char func) {
195    switch (func) {
196      case 's':
197        return NT_LOGISTIC;
198      case 't':
199        return NT_TANH;
200      case 'r':
201        return NT_RELU;
202      case 'l':
203        return NT_LINEAR;
204      case 'm':
205        return NT_SOFTMAX;
206      case 'p':
207        return NT_POSCLIP;
208      case 'n':
209        return NT_SYMCLIP;
</pre></code></div>
                <div class="column column_space"><pre><code>306  TGStat::TPlotInfo TGStat::GetPlotInfo(const TGStatDistr& Distr) {
307    switch (Distr) {
308      case gsdUndef : Fail; return TPlotInfo();
309      case gsdInDeg : return TPlotInfo("inDeg", "In-degree, k", "Count", gpsLog10XY);
310      case gsdOutDeg : return TPlotInfo("outDeg", "Out-degree, k", "Count", gpsLog10XY);
311      case gsdWcc : return TPlotInfo("wcc", "WCC size", "Count", gpsLog10XY);
312      case gsdScc : return TPlotInfo("scc", "SCC size", "Count", gpsLog10XY);
313      case gsdHops : return TPlotInfo("hop", "Number of hops, h", "Reachable pairs of nodes inside h hops", gpsLog10Y);
314      case gsdWccHops : return TPlotInfo("wccHop", "Number of hops, h", "Reachable pairs of nodes inside h hops in WCC", gpsLog10Y);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    