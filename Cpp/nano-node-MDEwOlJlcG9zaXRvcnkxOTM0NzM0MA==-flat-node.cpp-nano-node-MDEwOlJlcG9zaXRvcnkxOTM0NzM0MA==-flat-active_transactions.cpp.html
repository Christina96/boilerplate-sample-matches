
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/node/election.hpp>
3  #include <nano/node/scheduler/buckets.hpp>
4  #include <nano/node/scheduler/component.hpp>
5  #include <nano/node/transport/fake.hpp>
6  #include <nano/node/transport/inproc.hpp>
7  #include <nano/test_common/network.hpp>
8  #include <nano/test_common/system.hpp>
9  #include <nano/test_common/testutil.hpp>
10  #include <gtest/gtest.h>
11  #include <boost/filesystem.hpp>
12  #include <boost/make_shared.hpp>
13  #include <boost/optional.hpp>
14  #include <fstream>
15  #include <numeric>
16  using namespace std::chrono_literals;
17  TEST (node, null_account)
18  {
19  	auto const & null_account = nano::account::null ();
20  	ASSERT_TRUE (null_account == nullptr);
21  	ASSERT_FALSE (null_account != nullptr);
22  	nano::account default_account{};
23  	ASSERT_FALSE (default_account == nullptr);
24  	ASSERT_TRUE (default_account != nullptr);
25  }
26  TEST (node, stop)
27  {
28  	nano::test::system system (1);
29  	ASSERT_NE (system.nodes[0]->wallets.items.end (), system.nodes[0]->wallets.items.begin ());
30  	system.nodes[0]->stop ();
31  	system.io_ctx.run ();
32  	ASSERT_TRUE (true);
33  }
34  TEST (node, work_generate)
35  {
36  	nano::test::system system (1);
37  	auto & node (*system.nodes[0]);
38  	nano::block_hash root{ 1 };
39  	nano::work_version version{ nano::work_version::work_1 };
40  	{
41  		auto difficulty = nano::difficulty::from_multiplier (1.5, node.network_params.work.base);
42  		auto work = node.work_generate_blocking (version, root, difficulty);
43  		ASSERT_TRUE (work.is_initialized ());
44  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
45  	}
46  	{
47  		auto difficulty = nano::difficulty::from_multiplier (0.5, node.network_params.work.base);
48  		boost::optional<uint64_t> work;
49  		do
50  		{
51  			work = node.work_generate_blocking (version, root, difficulty);
52  		} while (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
53  		ASSERT_TRUE (work.is_initialized ());
54  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
55  		ASSERT_FALSE (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
56  	}
57  }
58  TEST (node, block_store_path_failure)
59  {
60  	nano::test::system system;
61  	auto service (boost::make_shared<boost::asio::io_context> ());
62  	auto path (nano::unique_path ());
63  	nano::logging logging;
64  	logging.init (path);
65  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
66  	auto node (std::make_shared<nano::node> (*service, system.get_available_port (), path, logging, pool));
67  	ASSERT_TRUE (node->wallets.items.empty ());
68  	node->stop ();
69  }
70  #if defined(__clang__) && defined(__linux__) && CI
71  TEST (node_DeathTest, DISABLED_readonly_block_store_not_exist)
72  #else
73  TEST (node_DeathTest, readonly_block_store_not_exist)
74  #endif
75  {
76  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
77  	{
78  		nano::inactive_node node (nano::unique_path (), nano::inactive_node_flag_defaults ());
79  		ASSERT_TRUE (node.node->init_error ());
80  	}
81  	else
82  	{
83  		ASSERT_EXIT (nano::inactive_node node (nano::unique_path (), nano::inactive_node_flag_defaults ()), ::testing::ExitedWithCode (1), "");
84  	}
85  }
86  TEST (node, password_fanout)
87  {
88  	nano::test::system system;
89  	boost::asio::io_context io_ctx;
90  	auto path (nano::unique_path ());
91  	nano::node_config config;
92  	config.peering_port = system.get_available_port ();
93  	config.logging.init (path);
94  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
95  	config.password_fanout = 10;
96  	nano::node node (io_ctx, path, config, pool);
97  	auto wallet (node.wallets.create (100));
98  	ASSERT_EQ (10, wallet->store.password.values.size ());
99  	node.stop ();
100  }
101  TEST (node, balance)
102  {
103  	nano::test::system system (1);
104  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
105  	auto transaction (system.nodes[0]->store.tx_begin_write ());
106  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max (), system.nodes[0]->ledger.account_balance (transaction, nano::dev::genesis_key.pub));
107  }
108  TEST (node, representative)
109  {
110  	nano::test::system system (1);
111  	auto block1 (system.nodes[0]->rep_block (nano::dev::genesis_key.pub));
112  	{
113  		auto transaction (system.nodes[0]->store.tx_begin_read ());
114  		ASSERT_TRUE (system.nodes[0]->ledger.store.block.exists (transaction, block1));
115  	}
116  	nano::keypair key;
117  	ASSERT_TRUE (system.nodes[0]->rep_block (key.pub).is_zero ());
118  }
119  TEST (node, send_unkeyed)
120  {
121  	nano::test::system system (1);
122  	nano::keypair key2;
123  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
124  	system.wallet (0)->store.password.value_set (nano::keypair ().prv);
125  	ASSERT_EQ (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
126  }
127  TEST (node, send_self)
128  {
129  	nano::test::system system (1);
130  	nano::keypair key2;
131  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
132  	system.wallet (0)->insert_adhoc (key2.prv);
133  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
134  	ASSERT_TIMELY (10s, !system.nodes[0]->balance (key2.pub).is_zero ());
135  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
136  }
137  TEST (node, send_single)
138  {
139  	nano::test::system system (2);
140  	nano::keypair key2;
141  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
142  	system.wallet (1)->insert_adhoc (key2.prv);
143  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
144  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
145  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
146  	ASSERT_TIMELY (10s, !system.nodes[0]->balance (key2.pub).is_zero ());
147  }
148  TEST (node, send_single_observing_peer)
149  {
150  	nano::test::system system (3);
151  	nano::keypair key2;
152  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
153  	system.wallet (1)->insert_adhoc (key2.prv);
154  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
155  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
156  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
157  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return !node_a->balance (key2.pub).is_zero (); }));
158  }
159  TEST (node, send_out_of_order)
160  {
161  	nano::test::system system (2);
162  	auto & node1 (*system.nodes[0]);
163  	nano::keypair key2;
164  	nano::send_block_builder builder;
165  	auto send1 = builder.make_block ()
166  				 .previous (nano::dev::genesis->hash ())
167  				 .destination (key2.pub)
168  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
169  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
170  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
171  				 .build_shared ();
172  	auto send2 = builder.make_block ()
173  				 .previous (send1->hash ())
174  				 .destination (key2.pub)
175  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 2 * node1.config.receive_minimum.number ())
176  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
177  				 .work (*system.work.generate (send1->hash ()))
178  				 .build_shared ();
179  	auto send3 = builder.make_block ()
180  				 .previous (send2->hash ())
181  				 .destination (key2.pub)
182  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 3 * node1.config.receive_minimum.number ())
183  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
184  				 .work (*system.work.generate (send2->hash ()))
185  				 .build_shared ();
186  	node1.process_active (send3);
187  	node1.process_active (send2);
188  	node1.process_active (send1);
189  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return node_a->balance (nano::dev::genesis_key.pub) == nano::dev::constants.genesis_amount - node1.config.receive_minimum.number () * 3; }));
190  }
191  TEST (node, quick_confirm)
192  {
193  	nano::test::system system (1);
194  	auto & node1 (*system.nodes[0]);
195  	nano::keypair key;
196  	nano::block_hash previous (node1.latest (nano::dev::genesis_key.pub));
197  	auto genesis_start_balance (node1.balance (nano::dev::genesis_key.pub));
198  	system.wallet (0)->insert_adhoc (key.prv);
199  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
200  	auto send = nano::send_block_builder ()
201  				.previous (previous)
202  				.destination (key.pub)
203  				.balance (node1.online_reps.delta () + 1)
204  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
205  				.work (*system.work.generate (previous))
206  				.build_shared ();
207  	node1.process_active (send);
208  	ASSERT_TIMELY (10s, !node1.balance (key.pub).is_zero ());
209  	ASSERT_EQ (node1.balance (nano::dev::genesis_key.pub), node1.online_reps.delta () + 1);
210  	ASSERT_EQ (node1.balance (key.pub), genesis_start_balance - (node1.online_reps.delta () + 1));
211  }
212  TEST (node, node_receive_quorum)
213  {
214  	nano::test::system system (1);
215  	auto & node1 = *system.nodes[0];
216  	nano::keypair key;
217  	nano::block_hash previous (node1.latest (nano::dev::genesis_key.pub));
218  	system.wallet (0)->insert_adhoc (key.prv);
219  	auto send = nano::send_block_builder ()
220  				.previous (previous)
221  				.destination (key.pub)
222  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
223  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
224  				.work (*system.work.generate (previous))
225  				.build_shared ();
226  	node1.process_active (send);
227  	ASSERT_TIMELY (10s, node1.ledger.block_or_pruned_exists (send->hash ()));
228  	ASSERT_TIMELY (10s, node1.active.election (nano::qualified_root (previous, previous)) != nullptr);
229  	auto election (node1.active.election (nano::qualified_root (previous, previous)));
230  	ASSERT_NE (nullptr, election);
231  	ASSERT_FALSE (election->confirmed ());
232  	ASSERT_EQ (1, election->votes ().size ());
233  	nano::test::system system2;
234  	system2.add_node ();
235  	system2.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
236  	ASSERT_TRUE (node1.balance (key.pub).is_zero ());
237  	node1.network.tcp_channels.start_tcp (system2.nodes[0]->network.endpoint ());
238  	while (node1.balance (key.pub).is_zero ())
239  	{
240  		ASSERT_NO_ERROR (system.poll ());
241  		ASSERT_NO_ERROR (system2.poll ());
242  	}
243  }
244  TEST (node, auto_bootstrap)
245  {
246  	nano::test::system system;
247  	nano::node_config config (system.get_available_port (), system.logging);
248  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
249  	nano::node_flags node_flags;
250  	node_flags.disable_bootstrap_bulk_push_client = true;
251  	node_flags.disable_lazy_bootstrap = true;
252  	auto node0 = system.add_node (config, node_flags);
253  	nano::keypair key2;
254  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
255  	system.wallet (0)->insert_adhoc (key2.prv);
256  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0->config.receive_minimum.number ()));
257  	ASSERT_NE (nullptr, send1);
258  	ASSERT_TIMELY (10s, node0->balance (key2.pub) == node0->config.receive_minimum.number ());
259  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
260  	ASSERT_FALSE (node1->init_error ());
261  	node1->start ();
262  	system.nodes.push_back (node1);
263  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
264  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
265  	ASSERT_TIMELY (10s, node1->balance (key2.pub) == node0->config.receive_minimum.number ());
266  	ASSERT_TIMELY (10s, !node1->bootstrap_initiator.in_progress ());
267  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send1->hash ()));
268  	ASSERT_TIMELY (5s, node1->ledger.cache.block_count == 3);
269  	ASSERT_TIMELY (5s, node1->ledger.cache.cemented_count == 3);
270  	node1->stop ();
271  }
272  TEST (node, auto_bootstrap_reverse)
273  {
274  	nano::test::system system;
275  	nano::node_config config (system.get_available_port (), system.logging);
276  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
277  	nano::node_flags node_flags;
278  	node_flags.disable_bootstrap_bulk_push_client = true;
279  	node_flags.disable_lazy_bootstrap = true;
280  	auto node0 = system.add_node (config, node_flags);
281  	nano::keypair key2;
282  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
283  	system.wallet (0)->insert_adhoc (key2.prv);
284  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
285  	ASSERT_FALSE (node1->init_error ());
286  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0->config.receive_minimum.number ()));
287  	node1->start ();
288  	system.nodes.push_back (node1);
289  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node0, node1->network.endpoint ()));
290  	ASSERT_TIMELY (10s, node1->balance (key2.pub) == node0->config.receive_minimum.number ());
291  }
292  TEST (node, auto_bootstrap_age)
293  {
294  	nano::test::system system;
295  	nano::node_config config (system.get_available_port (), system.logging);
296  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
297  	nano::node_flags node_flags;
298  	node_flags.disable_bootstrap_bulk_push_client = true;
299  	node_flags.disable_lazy_bootstrap = true;
300  	node_flags.bootstrap_interval = 1;
301  	auto node0 = system.add_node (config, node_flags);
302  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
303  	ASSERT_FALSE (node1->init_error ());
304  	node1->start ();
305  	system.nodes.push_back (node1);
306  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
307  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
308  	ASSERT_TIMELY (10s, node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out) >= 3);
309  	ASSERT_GE (node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out), node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate, nano::stat::dir::out));
310  	node1->stop ();
311  }
312  TEST (node, receive_gap)
313  {
314  	nano::test::system system (1);
315  	auto & node1 (*system.nodes[0]);
316  	ASSERT_EQ (0, node1.gap_cache.size ());
317  	auto block = nano::send_block_builder ()
318  				 .previous (5)
319  				 .destination (1)
320  				 .balance (2)
321  				 .sign (nano::keypair ().prv, 4)
322  				 .work (0)
323  				 .build_shared ();
324  	node1.work_generate_blocking (*block);
325  	nano::publish message{ nano::dev::network_params.network, block };
326  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
327  	node1.network.inbound (message, channel1);
328  	node1.block_processor.flush ();
329  	ASSERT_EQ (1, node1.gap_cache.size ());
330  }
331  TEST (node, merge_peers)
332  {
333  	nano::test::system system (1);
334  	std::array<nano::endpoint, 8> endpoints;
335  	endpoints.fill (nano::endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ()));
336  	endpoints[0] = nano::endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
337  	system.nodes[0]->network.merge_peers (endpoints);
338  	ASSERT_EQ (0, system.nodes[0]->network.size ());
339  }
340  TEST (node, search_receivable)
341  {
342  	nano::test::system system (1);
343  	auto node (system.nodes[0]);
344  	nano::keypair key2;
345  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
346  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
347  	system.wallet (0)->insert_adhoc (key2.prv);
348  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
349  	ASSERT_TIMELY (10s, !node->balance (key2.pub).is_zero ());
350  }
351  TEST (node, search_receivable_same)
352  {
353  	nano::test::system system (1);
354  	auto node (system.nodes[0]);
355  	nano::keypair key2;
356  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
357  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
358  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
359  	system.wallet (0)->insert_adhoc (key2.prv);
360  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
361  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
362  }
363  TEST (node, search_receivable_multiple)
364  {
365  	nano::test::system system (1);
366  	auto node (system.nodes[0]);
367  	nano::keypair key2;
368  	nano::keypair key3;
369  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
370  	system.wallet (0)->insert_adhoc (key3.prv);
371  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key3.pub, node->config.receive_minimum.number ()));
372  	ASSERT_TIMELY (10s, !node->balance (key3.pub).is_zero ());
373  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
374  	ASSERT_NE (nullptr, system.wallet (0)->send_action (key3.pub, key2.pub, node->config.receive_minimum.number ()));
375  	system.wallet (0)->insert_adhoc (key2.prv);
376  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
377  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
378  }
379  TEST (node, search_receivable_confirmed)
380  {
381  	nano::test::system system;
382  	nano::node_config node_config (system.get_available_port (), system.logging);
383  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
384  	auto node = system.add_node (node_config);
385  	nano::keypair key2;
386  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
387  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
388  	ASSERT_NE (nullptr, send1);
389  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
390  	ASSERT_NE (nullptr, send2);
391  	ASSERT_TIMELY (10s, node->active.empty ());
392  	bool confirmed (false);
393  	system.deadline_set (5s);
394  	while (!confirmed)
395  	{
396  		auto transaction (node->store.tx_begin_read ());
397  		confirmed = node->ledger.block_confirmed (transaction, send2->hash ());
398  		ASSERT_NO_ERROR (system.poll ());
399  	}
400  	{
401  		auto transaction (node->wallets.tx_begin_write ());
402  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
403  	}
404  	system.wallet (0)->insert_adhoc (key2.prv);
405  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
406  	{
407  		ASSERT_FALSE (node->active.active (send1->hash ()));
408  		ASSERT_FALSE (node->active.active (send2->hash ()));
409  	}
410  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
411  }
412  TEST (node, search_receivable_pruned)
413  {
414  	nano::test::system system;
415  	nano::node_config node_config (system.get_available_port (), system.logging);
416  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
417  	auto node1 = system.add_node (node_config);
418  	nano::node_flags node_flags;
419  	node_flags.enable_pruning = true;
420  	nano::node_config config (system.get_available_port (), system.logging);
421  	config.enable_voting = false; 
422  	auto node2 = system.add_node (config, node_flags);
423  	nano::keypair key2;
424  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
425  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node2->config.receive_minimum.number ()));
426  	ASSERT_NE (nullptr, send1);
427  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node2->config.receive_minimum.number ()));
428  	ASSERT_NE (nullptr, send2);
429  	ASSERT_TIMELY (10s, node1->active.empty () && node2->active.empty ());
430  	ASSERT_TIMELY (5s, node1->ledger.block_confirmed (node1->store.tx_begin_read (), send2->hash ()));
431  	ASSERT_TIMELY (5s, node2->ledger.cache.cemented_count == 3);
432  	system.wallet (0)->store.erase (node1->wallets.tx_begin_write (), nano::dev::genesis_key.pub);
433  	{
434  		auto transaction (node2->store.tx_begin_write ());
435  		ASSERT_EQ (1, node2->ledger.pruning_action (transaction, send1->hash (), 1));
436  	}
437  	ASSERT_EQ (1, node2->ledger.cache.pruned_count);
438  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ())); 
439  	system.wallet (1)->insert_adhoc (key2.prv);
440  	ASSERT_FALSE (system.wallet (1)->search_receivable (system.wallet (1)->wallets.tx_begin_read ()));
441  	ASSERT_TIMELY (10s, node2->balance (key2.pub) == 2 * node2->config.receive_minimum.number ());
442  }
443  TEST (node, unlock_search)
444  {
445  	nano::test::system system (1);
446  	auto node (system.nodes[0]);
447  	nano::keypair key2;
448  	nano::uint128_t balance (node->balance (nano::dev::genesis_key.pub));
449  	{
450  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
451  		system.wallet (0)->store.rekey (transaction, "");
452  	}
453  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
454  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
455  	ASSERT_TIMELY (10s, node->balance (nano::dev::genesis_key.pub) != balance);
456  	ASSERT_TIMELY (10s, node->active.empty ());
457  	system.wallet (0)->insert_adhoc (key2.prv);
458  	{
459  		nano::lock_guard<std::recursive_mutex> lock{ system.wallet (0)->store.mutex };
460  		system.wallet (0)->store.password.value_set (nano::keypair ().prv);
461  	}
462  	{
463  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
464  		ASSERT_FALSE (system.wallet (0)->enter_password (transaction, ""));
465  	}
466  	ASSERT_TIMELY (10s, !node->balance (key2.pub).is_zero ());
467  }
468  TEST (node, working)
469  {
470  	auto path (nano::working_path ());
471  	ASSERT_FALSE (path.empty ());
472  }
473  TEST (node, price)
474  {
475  	nano::test::system system (1);
476  	auto price1 (system.nodes[0]->price (nano::Gxrb_ratio, 1));
477  	ASSERT_EQ (nano::node::price_max * 100.0, price1);
478  	auto price2 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff + 1), 1));
479  	ASSERT_EQ (0, price2);
480  	auto price3 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff + 2) / 2, 1));
481  	ASSERT_EQ (nano::node::price_max * 100.0 / 2, price3);
482  	auto price4 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff) * 2, 1));
483  	ASSERT_EQ (0, price4);
484  }
485  TEST (node, confirm_locked)
486  {
487  	nano::test::system system (1);
488  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
489  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
490  	system.wallet (0)->enter_password (transaction, "1");
491  	auto block = nano::send_block_builder ()
492  				 .previous (0)
493  				 .destination (0)
494  				 .balance (0)
495  				 .sign (nano::keypair ().prv, 0)
496  				 .work (0)
497  				 .build_shared ();
498  	system.nodes[0]->network.flood_block (block);
499  }
500  TEST (node_config, random_rep)
501  {
502  	auto path (nano::unique_path ());
503  	nano::logging logging1;
504  	logging1.init (path);
505  	nano::node_config config1 (100, logging1);
506  	auto rep (config1.random_representative ());
507  	ASSERT_NE (config1.preconfigured_representatives.end (), std::find (config1.preconfigured_representatives.begin (), config1.preconfigured_representatives.end (), rep));
508  }
509  TEST (node, fork_publish)
510  {
511  	std::weak_ptr<nano::node> node0;
512  	{
513  		nano::test::system system (1);
514  		node0 = system.nodes[0];
515  		auto & node1 (*system.nodes[0]);
516  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
517  		nano::keypair key1;
518  		nano::send_block_builder builder;
519  		auto send1 = builder.make_block ()
520  					 .previous (nano::dev::genesis->hash ())
521  					 .destination (key1.pub)
522  					 .balance (nano::dev::constants.genesis_amount - 100)
523  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
524  					 .work (0)
525  					 .build_shared ();
526  		node1.work_generate_blocking (*send1);
527  		nano::keypair key2;
528  		auto send2 = builder.make_block ()
529  					 .previous (nano::dev::genesis->hash ())
530  					 .destination (key2.pub)
531  					 .balance (nano::dev::constants.genesis_amount - 100)
532  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
533  					 .work (0)
534  					 .build_shared ();
535  		node1.work_generate_blocking (*send2);
536  		node1.process_active (send1);
537  		node1.block_processor.flush ();
538  		ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
539  		auto election (node1.active.election (send1->qualified_root ()));
540  		ASSERT_NE (nullptr, election);
541  		ASSERT_TIMELY (1s, election->votes ().size () == 2);
542  		node1.process_active (send2);
543  		node1.block_processor.flush ();
544  		auto votes1 (election->votes ());
545  		auto existing1 (votes1.find (nano::dev::genesis_key.pub));
546  		ASSERT_NE (votes1.end (), existing1);
547  		ASSERT_EQ (send1->hash (), existing1->second.hash);
548  		auto winner (*election->tally ().begin ());
549  		ASSERT_EQ (*send1, *winner.second);
550  		ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
551  	}
552  	ASSERT_TRUE (node0.expired ());
553  }
554  TEST (node, fork_publish_inactive)
555  {
556  	nano::test::system system (1);
557  	auto & node = *system.nodes[0];
558  	nano::keypair key1;
559  	nano::keypair key2;
560  	nano::send_block_builder builder;
561  	auto send1 = builder.make_block ()
562  				 .previous (nano::dev::genesis->hash ())
563  				 .destination (key1.pub)
564  				 .balance (nano::dev::constants.genesis_amount - 100)
565  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
566  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
567  				 .build_shared ();
568  	auto send2 = builder.make_block ()
569  				 .previous (nano::dev::genesis->hash ())
570  				 .destination (key2.pub)
571  				 .balance (nano::dev::constants.genesis_amount - 100)
572  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
573  				 .work (send1->block_work ())
574  				 .build_shared ();
575  	node.process_active (send1);
576  	ASSERT_TIMELY (5s, node.block (send1->hash ()));
577  	std::shared_ptr<nano::election> election;
578  	ASSERT_TIMELY (5s, election = node.active.election (send1->qualified_root ()));
579  	ASSERT_EQ (nano::process_result::fork, node.process_local (send2).value ().code);
580  	auto blocks = election->blocks ();
581  	ASSERT_TIMELY_EQ (5s, blocks.size (), 2);
582  	ASSERT_NE (blocks.end (), blocks.find (send1->hash ()));
583  	ASSERT_NE (blocks.end (), blocks.find (send2->hash ()));
584  	ASSERT_EQ (election->winner ()->hash (), send1->hash ());
585  	ASSERT_NE (election->winner ()->hash (), send2->hash ());
586  }
587  TEST (node, fork_keep)
588  {
589  	nano::test::system system (2);
590  	auto & node1 (*system.nodes[0]);
591  	auto & node2 (*system.nodes[1]);
592  	ASSERT_EQ (1, node1.network.size ());
593  	nano::keypair key1;
594  	nano::keypair key2;
595  	nano::send_block_builder builder;
596  	auto send1 = builder.make_block ()
597  				 .previous (nano::dev::genesis->hash ())
598  				 .destination (key1.pub)
599  				 .balance (nano::dev::constants.genesis_amount - 100)
600  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
601  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
602  				 .build_shared ();
603  	auto send2 = builder.make_block ()
604  				 .previous (nano::dev::genesis->hash ())
605  				 .destination (key2.pub)
606  				 .balance (nano::dev::constants.genesis_amount - 100)
607  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
608  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
609  				 .build_shared ();
610  	node1.process_active (send1);
611  	node1.block_processor.flush ();
612  	node2.process_active (send1);
613  	node2.block_processor.flush ();
614  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
615  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
616  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
617  	node1.process_active (send2);
618  	node1.block_processor.flush ();
619  	node2.process_active (send2);
620  	node2.block_processor.flush ();
621  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
622  	ASSERT_NE (nullptr, election1);
623  	ASSERT_EQ (1, election1->votes ().size ());
624  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
625  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1->hash ()));
626  	ASSERT_TIMELY (1.5min, election1->votes ().size () != 1);
627  	auto transaction0 (node1.store.tx_begin_read ());
628  	auto transaction1 (node2.store.tx_begin_read ());
629  	auto winner (*election1->tally ().begin ());
630  	ASSERT_EQ (*send1, *winner.second);
631  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
632  	ASSERT_TRUE (node1.store.block.exists (transaction0, send1->hash ()));
633  	ASSERT_TRUE (node2.store.block.exists (transaction1, send1->hash ()));
634  }
635  TEST (node, fork_flip)
636  {
637  	nano::test::system system (2);
638  	auto & node1 (*system.nodes[0]);
639  	auto & node2 (*system.nodes[1]);
640  	ASSERT_EQ (1, node1.network.size ());
641  	nano::keypair key1;
642  	nano::send_block_builder builder;
643  	auto send1 = builder.make_block ()
644  				 .previous (nano::dev::genesis->hash ())
645  				 .destination (key1.pub)
646  				 .balance (nano::dev::constants.genesis_amount - 100)
647  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
648  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
649  				 .build_shared ();
650  	nano::publish publish1{ nano::dev::network_params.network, send1 };
651  	nano::keypair key2;
652  	auto send2 = builder.make_block ()
653  				 .previous (nano::dev::genesis->hash ())
654  				 .destination (key2.pub)
655  				 .balance (nano::dev::constants.genesis_amount - 100)
656  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
657  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
658  				 .build_shared ();
659  	nano::publish publish2{ nano::dev::network_params.network, send2 };
660  	auto ignored_channel{ std::make_shared<nano::transport::channel_tcp> (node1, std::weak_ptr<nano::transport::socket> ()) };
661  	node1.network.inbound (publish1, ignored_channel);
662  	node1.block_processor.flush ();
663  	node2.network.inbound (publish2, ignored_channel);
664  	node2.block_processor.flush ();
665  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
666  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
667  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
668  	node1.network.inbound (publish2, ignored_channel);
669  	node1.block_processor.flush ();
670  	node2.network.inbound (publish1, ignored_channel);
671  	node2.block_processor.flush ();
672  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
673  	ASSERT_NE (nullptr, election1);
674  	ASSERT_EQ (1, election1->votes ().size ());
675  	ASSERT_NE (nullptr, node1.block (publish1.block->hash ()));
676  	ASSERT_NE (nullptr, node2.block (publish2.block->hash ()));
677  	ASSERT_TIMELY (10s, node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
678  	auto winner (*election1->tally ().begin ());
679  	ASSERT_EQ (*publish1.block, *winner.second);
680  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
681  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
682  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
683  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
684  }
685  TEST (node, fork_multi_flip)
686  {
687  	auto type = nano::transport::transport_type::tcp;
688  	nano::test::system system;
689  	nano::node_flags node_flags;
690  	nano::node_config node_config (system.get_available_port (), system.logging);
691  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
692  	auto & node1 (*system.add_node (node_config, node_flags, type));
693  	node_config.peering_port = system.get_available_port ();
694  	auto & node2 (*system.add_node (node_config, node_flags, type));
695  	ASSERT_EQ (1, node1.network.size ());
696  	nano::keypair key1;
697  	nano::send_block_builder builder;
698  	auto send1 = builder.make_block ()
699  				 .previous (nano::dev::genesis->hash ())
700  				 .destination (key1.pub)
701  				 .balance (nano::dev::constants.genesis_amount - 100)
702  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
703  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
704  				 .build_shared ();
705  	nano::publish publish1{ nano::dev::network_params.network, send1 };
706  	nano::keypair key2;
707  	auto send2 = builder.make_block ()
708  				 .previous (nano::dev::genesis->hash ())
709  				 .destination (key2.pub)
710  				 .balance (nano::dev::constants.genesis_amount - 100)
711  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
712  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
713  				 .build_shared ();
714  	nano::publish publish2{ nano::dev::network_params.network, send2 };
715  	auto send3 = builder.make_block ()
716  				 .previous (publish2.block->hash ())
717  				 .destination (key2.pub)
718  				 .balance (nano::dev::constants.genesis_amount - 100)
719  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
720  				 .work (*system.work.generate (publish2.block->hash ()))
721  				 .build_shared ();
722  	nano::publish publish3{ nano::dev::network_params.network, send3 };
723  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
724  	auto channel2 = std::make_shared<nano::transport::fake::channel> (node2);
725  	node1.network.inbound (publish1, channel1);
726  	node2.network.inbound (publish2, channel2);
727  	node2.network.inbound (publish3, channel2);
728  	node1.block_processor.flush ();
729  	node2.block_processor.flush ();
730  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
731  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
732  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
733  	node1.network.inbound (publish2, channel1);
734  	node1.network.inbound (publish3, channel1);
735  	node1.block_processor.flush ();
736  	node2.network.inbound (publish1, channel2);
737  	node2.block_processor.flush ();
738  	ASSERT_TIMELY (5s, node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
739  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
740  	ASSERT_NE (nullptr, election1);
741  	ASSERT_EQ (1, election1->votes ().size ());
742  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
743  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
744  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish3.block->hash ()));
745  	ASSERT_TIMELY (10s, node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
746  	auto winner (*election1->tally ().begin ());
747  	ASSERT_EQ (*publish1.block, *winner.second);
748  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
749  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
750  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
751  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
752  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish3.block->hash ()));
753  }
754  TEST (node, fork_bootstrap_flip)
755  {
756  	nano::test::system system;
757  	nano::test::system system0;
758  	nano::test::system system1;
759  	nano::node_config config0{ system.get_available_port (), system0.logging };
760  	config0.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
761  	nano::node_flags node_flags;
762  	node_flags.disable_bootstrap_bulk_push_client = true;
763  	node_flags.disable_lazy_bootstrap = true;
764  	auto & node1 = *system0.add_node (config0, node_flags);
765  	nano::node_config config1 (system.get_available_port (), system1.logging);
766  	auto & node2 = *system1.add_node (config1, node_flags);
767  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
768  	nano::block_hash latest = node1.latest (nano::dev::genesis_key.pub);
769  	nano::keypair key1;
770  	nano::send_block_builder builder;
771  	auto send1 = builder.make_block ()
772  				 .previous (latest)
773  				 .destination (key1.pub)
774  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
775  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
776  				 .work (*system0.work.generate (latest))
777  				 .build_shared ();
778  	nano::keypair key2;
779  	auto send2 = builder.make_block ()
780  				 .previous (latest)
781  				 .destination (key2.pub)
782  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
783  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
784  				 .work (*system0.work.generate (latest))
785  				 .build_shared ();
786  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (node1.store.tx_begin_write (), *send1).code);
787  	ASSERT_EQ (nano::process_result::progress, node2.ledger.process (node2.store.tx_begin_write (), *send2).code);
788  	ASSERT_TRUE (node2.store.block.exists (node2.store.tx_begin_read (), send2->hash ()));
789  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint ()); 
790  	auto again (true);
791  	system0.deadline_set (50s);
792  	system1.deadline_set (50s);
793  	while (again)
794  	{
795  		ASSERT_NO_ERROR (system0.poll ());
796  		ASSERT_NO_ERROR (system1.poll ());
797  		again = !node2.store.block.exists (node2.store.tx_begin_read (), send1->hash ());
798  	}
799  }
800  TEST (node, fork_open)
801  {
802  	nano::test::system system (1);
803  	auto & node = *system.nodes[0];
804  	std::shared_ptr<nano::election> election;
805  	nano::keypair key1;
806  	auto send1 = nano::send_block_builder ()
807  				 .previous (nano::dev::genesis->hash ())
808  				 .destination (key1.pub)
809  				 .balance (0)
810  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
811  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
812  				 .build_shared ();
813  	nano::publish publish1{ nano::dev::network_params.network, send1 };
814  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node);
815  	node.network.inbound (publish1, channel1);
816  	ASSERT_TIMELY (5s, (election = node.active.election (publish1.block->qualified_root ())) != nullptr);
817  	election->force_confirm ();
818  	ASSERT_TIMELY (5s, node.active.empty () && node.block_confirmed (publish1.block->hash ()));
819  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
820  	nano::open_block_builder builder;
821  	auto open1 = builder.make_block ()
822  				 .source (publish1.block->hash ())
823  				 .representative (1)
824  				 .account (key1.pub)
825  				 .sign (key1.prv, key1.pub)
826  				 .work (*system.work.generate (key1.pub))
827  				 .build_shared ();
828  	nano::publish publish2{ nano::dev::network_params.network, open1 };
829  	node.network.inbound (publish2, channel1);
830  	ASSERT_TIMELY (5s, 1 == node.active.size ());
831  	auto open2 = builder.make_block ()
832  				 .source (publish1.block->hash ())
833  				 .representative (2)
834  				 .account (key1.pub)
835  				 .sign (key1.prv, key1.pub)
836  				 .work (*system.work.generate (key1.pub))
837  				 .build_shared ();
838  	nano::publish publish3{ nano::dev::network_params.network, open2 };
839  	node.network.inbound (publish3, channel1);
840  	ASSERT_TIMELY (5s, (election = node.active.election (publish3.block->qualified_root ())) != nullptr);
841  	ASSERT_TIMELY (5s, 2 == election->blocks ().size ());
842  	ASSERT_EQ (publish2.block->hash (), election->winner ()->hash ());
843  	system.delay_ms (1000ms);
844  	ASSERT_FALSE (election->confirmed ());
845  	ASSERT_TIMELY (5s, node.block (publish2.block->hash ()));
846  	ASSERT_FALSE (node.block (publish3.block->hash ()));
847  }
848  TEST (node, fork_open_flip)
849  {
850  	nano::test::system system (1);
851  	auto & node1 = *system.nodes[0];
852  	std::shared_ptr<nano::election> election;
853  	nano::keypair key1;
854  	nano::keypair rep1;
855  	nano::keypair rep2;
856  	auto send1 = nano::send_block_builder ()
857  				 .previous (nano::dev::genesis->hash ())
858  				 .destination (key1.pub)
859  				 .balance (nano::dev::constants.genesis_amount - 1)
860  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
861  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
862  				 .build_shared ();
863  	node1.process_active (send1);
864  	nano::open_block_builder builder;
865  	auto open1 = builder.make_block ()
866  				 .source (send1->hash ())
867  				 .representative (rep1.pub)
868  				 .account (key1.pub)
869  				 .sign (key1.prv, key1.pub)
870  				 .work (*system.work.generate (key1.pub))
871  				 .build_shared ();
872  	auto open2 = builder.make_block ()
873  				 .source (send1->hash ())
874  				 .representative (rep2.pub)
875  				 .account (key1.pub)
876  				 .sign (key1.prv, key1.pub)
877  				 .work (*system.work.generate (key1.pub))
878  				 .build_shared ();
879  	ASSERT_FALSE (*open1 == *open2);
880  	node1.process_active (open1);
881  	ASSERT_TIMELY (5s, node1.block (open1->hash ()) != nullptr);
882  	node1.scheduler.buckets.manual (open1);
883  	ASSERT_TIMELY (5s, (election = node1.active.election (open1->qualified_root ())) != nullptr);
884  	election->transition_active ();
885  	system.initialization_blocks.push_back (send1);
886  	system.initialization_blocks.push_back (open2);
887  	auto & node2 = *system.add_node ();
888  	system.initialization_blocks.clear ();
889  	ASSERT_TIMELY (5s, node2.block (open2->hash ()) != nullptr);
890  	node2.scheduler.buckets.manual (open2);
891  	ASSERT_TIMELY (5s, (election = node2.active.election (open2->qualified_root ())) != nullptr);
892  	election->transition_active ();
893  	ASSERT_TIMELY (5s, 2 == node1.active.size ());
894  	ASSERT_TIMELY (5s, 2 == node2.active.size ());
895  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
896  	ASSERT_TIMELY (5s, node1.block_confirmed (open1->hash ()));
897  	node1.process_active (open2);
898  	node2.process_active (open1);
899  	ASSERT_TIMELY (5s, 2 == election->votes ().size ()); 
900  	ASSERT_TIMELY (10s, node2.block (open1->hash ()));
901  	ASSERT_TIMELY (5s, node1.block_confirmed (open1->hash ()));
902  	auto winner = *election->tally ().begin ();
903  	ASSERT_EQ (*open1, *winner.second);
904  	ASSERT_EQ (nano::dev::constants.genesis_amount - 1, winner.first);
905  	auto transaction1 (node1.store.tx_begin_read ());
906  	auto transaction2 (node2.store.tx_begin_read ());
907  	ASSERT_TRUE (node1.store.block.exists (transaction1, open1->hash ()));
908  	ASSERT_TRUE (node2.store.block.exists (transaction2, open1->hash ()));
909  	ASSERT_FALSE (node2.store.block.exists (transaction2, open2->hash ()));
910  }
911  TEST (node, coherent_observer)
912  {
913  	nano::test::system system (1);
914  	auto & node1 (*system.nodes[0]);
915  	node1.observers.blocks.add ([&node1] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const &, nano::account const &, nano::uint128_t const &, bool, bool) {
916  		auto transaction (node1.store.tx_begin_read ());
917  		ASSERT_TRUE (node1.store.block.exists (transaction, status_a.winner->hash ()));
918  	});
919  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
920  	nano::keypair key;
921  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1);
922  }
923  TEST (node, fork_no_vote_quorum)
924  {
925  	nano::test::system system (3);
926  	auto & node1 (*system.nodes[0]);
927  	auto & node2 (*system.nodes[1]);
928  	auto & node3 (*system.nodes[2]);
929  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
930  	auto key4 (system.wallet (0)->deterministic_insert ());
931  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key4, nano::dev::constants.genesis_amount / 4);
932  	auto key1 (system.wallet (1)->deterministic_insert ());
933  	{
934  		auto transaction (system.wallet (1)->wallets.tx_begin_write ());
935  		system.wallet (1)->store.representative_set (transaction, key1);
936  	}
937  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1, node1.config.receive_minimum.number ()));
938  	ASSERT_NE (nullptr, block);
939  	ASSERT_TIMELY (30s, node3.balance (key1) == node1.config.receive_minimum.number () && node2.balance (key1) == node1.config.receive_minimum.number () && node1.balance (key1) == node1.config.receive_minimum.number ());
940  	ASSERT_EQ (node1.config.receive_minimum.number (), node1.weight (key1));
941  	ASSERT_EQ (node1.config.receive_minimum.number (), node2.weight (key1));
942  	ASSERT_EQ (node1.config.receive_minimum.number (), node3.weight (key1));
943  	nano::block_builder builder;
944  	auto send1 = builder
945  				 .state ()
946  				 .account (nano::dev::genesis_key.pub)
947  				 .previous (block->hash ())
948  				 .representative (nano::dev::genesis_key.pub)
949  				 .balance ((nano::dev::constants.genesis_amount / 4) - (node1.config.receive_minimum.number () * 2))
950  				 .link (key1)
951  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
952  				 .work (*system.work.generate (block->hash ()))
953  				 .build ();
954  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
955  	ASSERT_EQ (nano::process_result::progress, node2.process (*send1).code);
956  	ASSERT_EQ (nano::process_result::progress, node3.process (*send1).code);
957  	auto key2 (system.wallet (2)->deterministic_insert ());
958  	auto send2 = nano::send_block_builder ()
959  				 .previous (block->hash ())
960  				 .destination (key2)
961  				 .balance ((nano::dev::constants.genesis_amount / 4) - (node1.config.receive_minimum.number () * 2))
962  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
963  				 .work (*system.work.generate (block->hash ()))
964  				 .build_shared ();
965  	nano::raw_key key3;
966  	auto transaction (system.wallet (1)->wallets.tx_begin_read ());
967  	ASSERT_FALSE (system.wallet (1)->store.fetch (transaction, key1, key3));
968  	auto vote = std::make_shared<nano::vote> (key1, key3, 0, 0, std::vector<nano::block_hash>{ send2->hash () });
969  	nano::confirm_ack confirm{ nano::dev::network_params.network, vote };
970  	std::vector<uint8_t> buffer;
971  	{
972  		nano::vectorstream stream (buffer);
973  		confirm.serialize (stream);
974  	}
975  	auto channel = node2.network.find_node_id (node3.node_id.pub);
976  	ASSERT_NE (nullptr, channel);
977  	channel->send_buffer (nano::shared_const_buffer (std::move (buffer)));
978  	ASSERT_TIMELY (10s, node3.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::in) >= 3);
979  	ASSERT_TRUE (node1.latest (nano::dev::genesis_key.pub) == send1->hash ());
980  	ASSERT_TRUE (node2.latest (nano::dev::genesis_key.pub) == send1->hash ());
981  	ASSERT_TRUE (node3.latest (nano::dev::genesis_key.pub) == send1->hash ());
982  }
983  TEST (node, DISABLED_fork_pre_confirm)
984  {
985  	nano::test::system system (3);
986  	auto & node0 (*system.nodes[0]);
987  	auto & node1 (*system.nodes[1]);
988  	auto & node2 (*system.nodes[2]);
989  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
990  	nano::keypair key1;
991  	system.wallet (1)->insert_adhoc (key1.prv);
992  	{
993  		auto transaction (system.wallet (1)->wallets.tx_begin_write ());
994  		system.wallet (1)->store.representative_set (transaction, key1.pub);
995  	}
996  	nano::keypair key2;
997  	system.wallet (2)->insert_adhoc (key2.prv);
998  	{
999  		auto transaction (system.wallet (2)->wallets.tx_begin_write ());
1000  		system.wallet (2)->store.representative_set (transaction, key2.pub);
1001  	}
1002  	auto block0 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, nano::dev::constants.genesis_amount / 3));
1003  	ASSERT_NE (nullptr, block0);
1004  	ASSERT_TIMELY (30s, node0.balance (key1.pub) != 0);
1005  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, nano::dev::constants.genesis_amount / 3));
1006  	ASSERT_NE (nullptr, block1);
1007  	ASSERT_TIMELY (30s, node0.balance (key2.pub) != 0);
1008  	nano::keypair key3;
1009  	nano::keypair key4;
1010  	nano::state_block_builder builder;
1011  	auto block2 = builder.make_block ()
1012  				  .account (nano::dev::genesis_key.pub)
1013  				  .previous (node0.latest (nano::dev::genesis_key.pub))
1014  				  .representative (key3.pub)
1015  				  .balance (node0.balance (nano::dev::genesis_key.pub))
1016  				  .link (0)
1017  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1018  				  .work (0)
1019  				  .build_shared ();
1020  	auto block3 = builder.make_block ()
1021  				  .account (nano::dev::genesis_key.pub)
1022  				  .previous (node0.latest (nano::dev::genesis_key.pub))
1023  				  .representative (key4.pub)
1024  				  .balance (node0.balance (nano::dev::genesis_key.pub))
1025  				  .link (0)
1026  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1027  				  .work (0)
1028  				  .build_shared ();
1029  	node0.work_generate_blocking (*block2);
1030  	node0.work_generate_blocking (*block3);
1031  	node0.process_active (block2);
1032  	node1.process_active (block2);
1033  	node2.process_active (block3);
1034  	auto done (false);
1035  	system.deadline_set (70s);
1036  	while (!done)
1037  	{
1038  		done |= node0.latest (nano::dev::genesis_key.pub) == block2->hash () && node1.latest (nano::dev::genesis_key.pub) == block2->hash () && node2.latest (nano::dev::genesis_key.pub) == block2->hash ();
1039  		done |= node0.latest (nano::dev::genesis_key.pub) == block3->hash () && node1.latest (nano::dev::genesis_key.pub) == block3->hash () && node2.latest (nano::dev::genesis_key.pub) == block3->hash ();
1040  		ASSERT_NO_ERROR (system.poll ());
1041  	}
1042  }
1043  TEST (node, DISABLED_fork_stale)
1044  {
1045  	nano::test::system system1 (1);
1046  	system1.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1047  	nano::test::system system2 (1);
1048  	auto & node1 (*system1.nodes[0]);
1049  	auto & node2 (*system2.nodes[0]);
1050  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint (), false);
1051  	auto channel = nano::test::establish_tcp (system1, node2, node1.network.endpoint ());
1052  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> ());
1053  	node2.rep_crawler.response (channel, vote);
1054  	nano::keypair key1;
1055  	nano::keypair key2;
1056  	nano::state_block_builder builder;
1057  	auto send3 = builder.make_block ()
1058  				 .account (nano::dev::genesis_key.pub)
1059  				 .previous (nano::dev::genesis->hash ())
1060  				 .representative (nano::dev::genesis_key.pub)
1061  				 .balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1062  				 .link (key1.pub)
1063  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1064  				 .work (0)
1065  				 .build_shared ();
1066  	node1.work_generate_blocking (*send3);
1067  	node1.process_active (send3);
1068  	system2.deadline_set (10s);
1069  	while (node2.block (send3->hash ()) == nullptr)
1070  	{
1071  		system1.poll ();
1072  		ASSERT_NO_ERROR (system2.poll ());
1073  	}
1074  	auto send1 = builder.make_block ()
1075  				 .account (nano::dev::genesis_key.pub)
1076  				 .previous (send3->hash ())
1077  				 .representative (nano::dev::genesis_key.pub)
1078  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Mxrb_ratio)
1079  				 .link (key1.pub)
1080  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1081  				 .work (0)
1082  				 .build_shared ();
1083  	node1.work_generate_blocking (*send1);
1084  	auto send2 = builder.make_block ()
1085  				 .account (nano::dev::genesis_key.pub)
1086  				 .previous (send3->hash ())
1087  				 .representative (nano::dev::genesis_key.pub)
1088  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Mxrb_ratio)
1089  				 .link (key2.pub)
1090  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1091  				 .work (0)
1092  				 .build_shared ();
1093  	node1.work_generate_blocking (*send2);
1094  	{
1095  		auto transaction1 (node1.store.tx_begin_write ());
1096  		ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction1, *send1).code);
1097  		auto transaction2 (node2.store.tx_begin_write ());
1098  		ASSERT_EQ (nano::process_result::progress, node2.ledger.process (transaction2, *send2).code);
1099  	}
1100  	node1.process_active (send1);
1101  	node1.process_active (send2);
1102  	node2.process_active (send1);
1103  	node2.process_active (send2);
1104  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint (), false);
1105  	while (node2.block (send1->hash ()) == nullptr)
1106  	{
1107  		system1.poll ();
1108  		ASSERT_NO_ERROR (system2.poll ());
1109  	}
1110  }
1111  TEST (node, DISABLED_broadcast_elected)
1112  {
1113  	auto type = nano::transport::transport_type::tcp;
1114  	nano::node_flags node_flags;
1115  	nano::test::system system;
1116  	nano::node_config node_config (system.get_available_port (), system.logging);
1117  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1118  	auto node0 = system.add_node (node_config, node_flags, type);
1119  	node_config.peering_port = system.get_available_port ();
1120  	auto node1 = system.add_node (node_config, node_flags, type);
1121  	node_config.peering_port = system.get_available_port ();
1122  	auto node2 = system.add_node (node_config, node_flags, type);
1123  	nano::keypair rep_big;
1124  	nano::keypair rep_small;
1125  	nano::keypair rep_other;
1126  	nano::block_builder builder;
1127  	{
1128  		auto transaction0 (node0->store.tx_begin_write ());
1129  		auto transaction1 (node1->store.tx_begin_write ());
1130  		auto transaction2 (node2->store.tx_begin_write ());
1131  		auto fund_big = *builder.send ()
1132  						 .previous (nano::dev::genesis->hash ())
1133  						 .destination (rep_big.pub)
1134  						 .balance (nano::Gxrb_ratio * 5)
1135  						 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1136  						 .work (*system.work.generate (nano::dev::genesis->hash ()))
1137  						 .build ();
1138  		auto open_big = *builder.open ()
1139  						 .source (fund_big.hash ())
1140  						 .representative (rep_big.pub)
1141  						 .account (rep_big.pub)
1142  						 .sign (rep_big.prv, rep_big.pub)
1143  						 .work (*system.work.generate (rep_big.pub))
1144  						 .build ();
1145  		auto fund_small = *builder.send ()
1146  						   .previous (fund_big.hash ())
1147  						   .destination (rep_small.pub)
1148  						   .balance (nano::Gxrb_ratio * 2)
1149  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1150  						   .work (*system.work.generate (fund_big.hash ()))
1151  						   .build ();
1152  		auto open_small = *builder.open ()
1153  						   .source (fund_small.hash ())
1154  						   .representative (rep_small.pub)
1155  						   .account (rep_small.pub)
1156  						   .sign (rep_small.prv, rep_small.pub)
1157  						   .work (*system.work.generate (rep_small.pub))
1158  						   .build ();
1159  		auto fund_other = *builder.send ()
1160  						   .previous (fund_small.hash ())
1161  						   .destination (rep_other.pub)
1162  						   .balance (nano::Gxrb_ratio)
1163  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1164  						   .work (*system.work.generate (fund_small.hash ()))
1165  						   .build ();
1166  		auto open_other = *builder.open ()
1167  						   .source (fund_other.hash ())
1168  						   .representative (rep_other.pub)
1169  						   .account (rep_other.pub)
1170  						   .sign (rep_other.prv, rep_other.pub)
1171  						   .work (*system.work.generate (rep_other.pub))
1172  						   .build ();
1173  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_big).code);
1174  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_big).code);
1175  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_big).code);
1176  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_big).code);
1177  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_big).code);
1178  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_big).code);
1179  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_small).code);
1180  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_small).code);
1181  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_small).code);
1182  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_small).code);
1183  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_small).code);
1184  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_small).code);
1185  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_other).code);
1186  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_other).code);
1187  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_other).code);
1188  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_other).code);
1189  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_other).code);
1190  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_other).code);
1191  	}
1192  	for (auto & node : system.nodes)
1193  	{
1194  		auto block (node->block (node->latest (nano::dev::genesis_key.pub)));
1195  		ASSERT_NE (nullptr, block);
1196  		node->block_confirm (block);
1197  		auto election (node->active.election (block->qualified_root ()));
1198  		ASSERT_NE (nullptr, election);
1199  		election->force_confirm ();
1200  		ASSERT_TIMELY (5s, 4 == node->ledger.cache.cemented_count)
1201  	}
1202  	system.wallet (0)->insert_adhoc (rep_big.prv);
1203  	system.wallet (1)->insert_adhoc (rep_small.prv);
1204  	system.wallet (2)->insert_adhoc (rep_other.prv);
1205  	auto fork0 = builder.send ()
1206  				 .previous (node2->latest (nano::dev::genesis_key.pub))
1207  				 .destination (rep_small.pub)
1208  				 .balance (0)
1209  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1210  				 .work (*node0->work_generate_blocking (node2->latest (nano::dev::genesis_key.pub)))
1211  				 .build_shared ();
1212  	auto fork0_copy (std::make_shared<nano::send_block> (*fork0));
1213  	node0->process_active (fork0);
1214  	node1->process_active (fork0_copy);
1215  	auto fork1 = builder.send ()
1216  				 .previous (node2->latest (nano::dev::genesis_key.pub))
1217  				 .destination (rep_big.pub)
1218  				 .balance (0)
1219  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1220  				 .work (*node0->work_generate_blocking (node2->latest (nano::dev::genesis_key.pub)))
1221  				 .build_shared ();
1222  	system.wallet (2)->insert_adhoc (rep_small.prv);
1223  	node2->process_active (fork1);
1224  	ASSERT_TIMELY (10s, node0->ledger.block_or_pruned_exists (fork0->hash ()) && node1->ledger.block_or_pruned_exists (fork0->hash ()));
1225  	system.deadline_set (50s);
1226  	while (!node2->ledger.block_or_pruned_exists (fork0->hash ()))
1227  	{
1228  		auto ec = system.poll ();
1229  		ASSERT_TRUE (node0->ledger.block_or_pruned_exists (fork0->hash ()));
1230  		ASSERT_TRUE (node1->ledger.block_or_pruned_exists (fork0->hash ()));
1231  		ASSERT_NO_ERROR (ec);
1232  	}
1233  	ASSERT_TIMELY (5s, node1->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out) != 0);
1234  }
1235  TEST (node, rep_self_vote)
1236  {
1237  	nano::test::system system;
1238  	nano::node_config node_config (system.get_available_port (), system.logging);
1239  	node_config.online_weight_minimum = std::numeric_limits<nano::uint128_t>::max ();
1240  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1241  	auto node0 = system.add_node (node_config);
1242  	nano::keypair rep_big;
1243  	nano::block_builder builder;
1244  	auto fund_big = *builder.send ()
1245  					 .previous (nano::dev::genesis->hash ())
1246  					 .destination (rep_big.pub)
1247  					 .balance (nano::uint128_t{ "0xb0000000000000000000000000000000" })
1248  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1249  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
1250  					 .build ();
1251  	auto open_big = *builder.open ()
1252  					 .source (fund_big.hash ())
1253  					 .representative (rep_big.pub)
1254  					 .account (rep_big.pub)
1255  					 .sign (rep_big.prv, rep_big.pub)
1256  					 .work (*system.work.generate (rep_big.pub))
1257  					 .build ();
1258  	ASSERT_EQ (nano::process_result::progress, node0->process (fund_big).code);
1259  	ASSERT_EQ (nano::process_result::progress, node0->process (open_big).code);
1260  	node0->block_confirm (node0->block (open_big.hash ()));
1261  	auto election = node0->active.election (open_big.qualified_root ());
1262  	ASSERT_NE (nullptr, election);
1263  	election->force_confirm ();
1264  	system.wallet (0)->insert_adhoc (rep_big.prv);
1265  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1266  	ASSERT_EQ (system.wallet (0)->wallets.reps ().voting, 2);
1267  	auto block0 = builder.send ()
1268  				  .previous (fund_big.hash ())
1269  				  .destination (rep_big.pub)
1270  				  .balance (nano::uint128_t ("0x60000000000000000000000000000000"))
1271  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1272  				  .work (*system.work.generate (fund_big.hash ()))
1273  				  .build_shared ();
1274  	ASSERT_EQ (nano::process_result::progress, node0->process (*block0).code);
1275  	auto & active = node0->active;
1276  	auto & scheduler = node0->scheduler;
1277  	scheduler.buckets.activate (nano::dev::genesis_key.pub, node0->store.tx_begin_read ());
1278  	ASSERT_TIMELY (5s, active.election (block0->qualified_root ()));
1279  	auto election1 = active.election (block0->qualified_root ());
1280  	ASSERT_NE (nullptr, election1);
1281  	ASSERT_TIMELY (1s, election1->votes ().size () == 3);
1282  	auto rep_votes (election1->votes ());
1283  	ASSERT_NE (rep_votes.end (), rep_votes.find (nano::dev::genesis_key.pub));
1284  	ASSERT_NE (rep_votes.end (), rep_votes.find (rep_big.pub));
1285  }
1286  TEST (node, DISABLED_bootstrap_no_publish)
1287  {
1288  	nano::test::system system0 (1);
1289  	nano::test::system system1 (1);
1290  	auto node0 (system0.nodes[0]);
1291  	auto node1 (system1.nodes[0]);
1292  	nano::keypair key0;
1293  	nano::block_builder builder;
1294  	auto send0 = builder
1295  				 .send ()
1296  				 .previous (node0->latest (nano::dev::genesis_key.pub))
1297  				 .destination (key0.pub)
1298  				 .balance (500)
1299  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1300  				 .work (0)
1301  				 .build ();
1302  	{
1303  		auto transaction (node0->store.tx_begin_write ());
1304  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *send0).code);
1305  	}
1306  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1307  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
1308  	ASSERT_TRUE (node1->active.empty ());
1309  	system1.deadline_set (10s);
1310  	while (node1->block (send0->hash ()) == nullptr)
1311  	{
1312  		system0.poll ();
1313  		auto ec = system1.poll ();
1314  		ASSERT_TRUE (node1->active.empty ());
1315  		ASSERT_NO_ERROR (ec);
1316  	}
1317  }
1318  TEST (node, DISABLED_bootstrap_bulk_push)
1319  {
1320  	nano::test::system system;
1321  	nano::test::system system0;
1322  	nano::test::system system1;
1323  	nano::node_config config0 (system.get_available_port (), system0.logging);
1324  	config0.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1325  	auto node0 (system0.add_node (config0));
1326  	nano::node_config config1 (system.get_available_port (), system1.logging);
1327  	config1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1328  	auto node1 (system1.add_node (config1));
1329  	nano::keypair key0;
1330  	auto send0 = nano::send_block_builder ()
1331  				 .previous (nano::dev::genesis->hash ())
1332  				 .destination (key0.pub)
1333  				 .balance (500)
1334  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1335  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1336  				 .build_shared ();
1337  	ASSERT_EQ (nano::process_result::progress, node0->process (*send0).code);
1338  	ASSERT_FALSE (node0->bootstrap_initiator.in_progress ());
1339  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1340  	ASSERT_TRUE (node1->active.empty ());
1341  	node0->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
1342  	system1.deadline_set (10s);
1343  	while (node1->block (send0->hash ()) == nullptr)
1344  	{
1345  		ASSERT_NO_ERROR (system0.poll ());
1346  		ASSERT_NO_ERROR (system1.poll ());
1347  	}
1348  	system1.deadline_set (10s);
1349  	while (node1->active.empty ())
1350  	{
1351  		ASSERT_NO_ERROR (system0.poll ());
1352  		ASSERT_NO_ERROR (system1.poll ());
1353  	}
1354  }
1355  TEST (node, bootstrap_fork_open)
1356  {
1357  	nano::test::system system;
1358  	nano::node_config node_config (system.get_available_port (), system.logging);
1359  	auto node0 = system.add_node (node_config);
1360  	node_config.peering_port = system.get_available_port ();
1361  	auto node1 = system.add_node (node_config);
1362  	nano::keypair key0;
1363  	nano::block_builder builder;
1364  	auto send0 = *builder.send ()
1365  				  .previous (nano::dev::genesis->hash ())
1366  				  .destination (key0.pub)
1367  				  .balance (nano::dev::constants.genesis_amount - 500)
1368  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1369  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
1370  				  .build ();
1371  	auto open0 = *builder.open ()
1372  				  .source (send0.hash ())
1373  				  .representative (1)
1374  				  .account (key0.pub)
1375  				  .sign (key0.prv, key0.pub)
1376  				  .work (*system.work.generate (key0.pub))
1377  				  .build ();
1378  	auto open1 = *builder.open ()
1379  				  .source (send0.hash ())
1380  				  .representative (2)
1381  				  .account (key0.pub)
1382  				  .sign (key0.prv, key0.pub)
1383  				  .work (*system.work.generate (key0.pub))
1384  				  .build ();
1385  	ASSERT_EQ (nano::process_result::progress, node0->process (send0).code);
1386  	ASSERT_EQ (nano::process_result::progress, node1->process (send0).code);
1387  	for (auto node : system.nodes)
1388  	{
1389  		node->block_confirm (node->block (node->latest (nano::dev::genesis_key.pub)));
1390  		ASSERT_TIMELY (1s, node->active.election (send0.qualified_root ()));
1391  		auto election = node->active.election (send0.qualified_root ());
1392  		ASSERT_NE (nullptr, election);
1393  		election->force_confirm ();
1394  		ASSERT_TIMELY (2s, node->active.empty ());
1395  	}
1396  	ASSERT_TIMELY (3s, node0->block_confirmed (send0.hash ()));
1397  	ASSERT_EQ (nano::process_result::progress, node0->process (open0).code);
1398  	ASSERT_EQ (nano::process_result::progress, node1->process (open1).code);
1399  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1400  	ASSERT_FALSE (node1->ledger.block_or_pruned_exists (open0.hash ()));
1401  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1402  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
1403  	ASSERT_TIMELY (1s, node1->active.empty ());
1404  	ASSERT_TIMELY (10s, !node1->ledger.block_or_pruned_exists (open1.hash ()) && node1->ledger.block_or_pruned_exists (open0.hash ()));
1405  }
1406  TEST (node, bootstrap_confirm_frontiers)
1407  {
1408  	nano::test::system system0 (1);
1409  	nano::test::system system1 (1);
1410  	auto node0 = system0.nodes[0];
1411  	auto node1 = system1.nodes[0];
1412  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1413  	nano::keypair key0;
1414  	auto send0 = nano::send_block_builder ()
1415  				 .previous (nano::dev::genesis->hash ())
1416  				 .destination (key0.pub)
1417  				 .balance (nano::dev::constants.genesis_amount - 500)
1418  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1419  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1420  				 .build_shared ();
1421  	ASSERT_EQ (nano::process_result::progress, node0->process (*send0).code);
1422  	ASSERT_FALSE (node0->bootstrap_initiator.in_progress ());
1423  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1424  	ASSERT_TRUE (node1->active.empty ());
1425  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint ());
1426  	system0.deadline_set (10s);
1427  	system1.deadline_set (10s);
1428  	while (!node1->ledger.block_confirmed (node1->store.tx_begin_read (), send0->hash ()))
1429  	{
1430  		ASSERT_NO_ERROR (system0.poll (std::chrono::milliseconds (1)));
1431  		ASSERT_NO_ERROR (system1.poll (std::chrono::milliseconds (1)));
1432  	}
1433  }
1434  TEST (node, unconfirmed_send)
1435  {
1436  	nano::test::system system{};
1437  	auto & node1 = *system.add_node ();
1438  	auto wallet1 = system.wallet (0);
1439  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
1440  	nano::keypair key2{};
1441  	auto & node2 = *system.add_node ();
1442  	auto wallet2 = system.wallet (1);
1443  	wallet2->insert_adhoc (key2.prv);
1444  	auto send1 = wallet1->send_action (nano::dev::genesis->account (), key2.pub, 2 * nano::Mxrb_ratio);
1445  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
1446  	ASSERT_TIMELY (5s, node2.block_confirmed (send1->hash ()));
1447  	ASSERT_TIMELY (5s, node2.get_confirmation_height (node2.store.tx_begin_read (), key2.pub) == 1);
1448  	ASSERT_EQ (node2.balance (key2.pub), 2 * nano::Mxrb_ratio);
1449  	auto recv1 = node2.ledger.find_receive_block_by_send_hash (node2.store.tx_begin_read (), key2.pub, send1->hash ());
1450  	auto send2 = nano::state_block_builder{}
1451  				 .make_block ()
1452  				 .account (key2.pub)
1453  				 .previous (recv1->hash ())
1454  				 .representative (nano::dev::genesis_key.pub)
1455  				 .balance (nano::Mxrb_ratio)
1456  				 .link (nano::dev::genesis->account ())
1457  				 .sign (key2.prv, key2.pub)
1458  				 .work (*system.work.generate (recv1->hash ()))
1459  				 .build_shared ();
1460  	ASSERT_EQ (nano::process_result::progress, node2.process (*send2).code);
1461  	auto send3 = wallet2->send_action (key2.pub, nano::dev::genesis->account (), nano::Mxrb_ratio);
1462  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
1463  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
1464  	ASSERT_TIMELY (5s, node2.block_confirmed (send3->hash ()));
1465  	ASSERT_TIMELY (5s, node1.block_confirmed (send3->hash ()));
1466  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 7);
1467  	ASSERT_TIMELY (5s, node1.balance (nano::dev::genesis->account ()) == nano::dev::constants.genesis_amount);
1468  }
1469  TEST (node, rep_list)
1470  {
1471  	nano::test::system system (2);
1472  	auto & node1 (*system.nodes[1]);
1473  	auto wallet0 (system.wallet (0));
1474  	auto wallet1 (system.wallet (1));
1475  	wallet0->insert_adhoc (nano::dev::genesis_key.prv);
1476  	nano::keypair key1;
1477  	wallet0->send_action (nano::dev::genesis_key.pub, key1.pub, nano::Mxrb_ratio);
1478  	ASSERT_EQ (0, node1.rep_crawler.representatives (1).size ());
1479  	system.deadline_set (10s);
1480  	auto done (false);
1481  	while (!done)
1482  	{
1483  		auto reps = node1.rep_crawler.representatives (1);
1484  		if (!reps.empty ())
1485  		{
1486  			if (!node1.ledger.weight (reps[0].account).is_zero ())
1487  			{
1488  				done = true;
1489  			}
1490  		}
1491  		ASSERT_NO_ERROR (system.poll ());
1492  	}
1493  }
1494  TEST (node, rep_weight)
1495  {
1496  	nano::test::system system;
1497  	auto add_node = [&system] {
1498  		auto node = std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work);
1499  		node->start ();
1500  		system.nodes.push_back (node);
1501  		return node;
1502  	};
1503  	auto & node = *add_node ();
1504  	auto & node1 = *add_node ();
1505  	auto & node2 = *add_node ();
1506  	auto & node3 = *add_node ();
1507  	nano::keypair keypair1;
1508  	nano::keypair keypair2;
1509  	nano::block_builder builder;
1510  	auto amount_pr (node.minimum_principal_weight () + 100);
1511  	auto amount_not_pr (node.minimum_principal_weight () - 100);
1512  	std::shared_ptr<nano::block> block1 = builder
1513  										  .state ()
1514  										  .account (nano::dev::genesis_key.pub)
1515  										  .previous (nano::dev::genesis->hash ())
1516  										  .representative (nano::dev::genesis_key.pub)
1517  										  .balance (nano::dev::constants.genesis_amount - amount_not_pr)
1518  										  .link (keypair1.pub)
1519  										  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1520  										  .work (*system.work.generate (nano::dev::genesis->hash ()))
1521  										  .build ();
1522  	std::shared_ptr<nano::block> block2 = builder
1523  										  .state ()
1524  										  .account (keypair1.pub)
1525  										  .previous (0)
1526  										  .representative (keypair1.pub)
1527  										  .balance (amount_not_pr)
1528  										  .link (block1->hash ())
1529  										  .sign (keypair1.prv, keypair1.pub)
1530  										  .work (*system.work.generate (keypair1.pub))
1531  										  .build ();
1532  	std::shared_ptr<nano::block> block3 = builder
1533  										  .state ()
1534  										  .account (nano::dev::genesis_key.pub)
1535  										  .previous (block1->hash ())
1536  										  .representative (nano::dev::genesis_key.pub)
1537  										  .balance (nano::dev::constants.genesis_amount - amount_not_pr - amount_pr)
1538  										  .link (keypair2.pub)
1539  										  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1540  										  .work (*system.work.generate (block1->hash ()))
1541  										  .build ();
1542  	std::shared_ptr<nano::block> block4 = builder
1543  										  .state ()
1544  										  .account (keypair2.pub)
1545  										  .previous (0)
1546  										  .representative (keypair2.pub)
1547  										  .balance (amount_pr)
1548  										  .link (block3->hash ())
1549  										  .sign (keypair2.prv, keypair2.pub)
1550  										  .work (*system.work.generate (keypair2.pub))
1551  										  .build ();
1552  	{
1553  		auto transaction = node.store.tx_begin_write ();
1554  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block1).code);
1555  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block2).code);
1556  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block3).code);
1557  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block4).code);
1558  	}
1559  	ASSERT_TRUE (node.rep_crawler.representatives (1).empty ());
1560  	std::shared_ptr<nano::transport::channel> channel1 = nano::test::establish_tcp (system, node, node1.network.endpoint ());
1561  	ASSERT_NE (nullptr, channel1);
1562  	std::shared_ptr<nano::transport::channel> channel2 = nano::test::establish_tcp (system, node, node2.network.endpoint ());
1563  	ASSERT_NE (nullptr, channel2);
1564  	std::shared_ptr<nano::transport::channel> channel3 = nano::test::establish_tcp (system, node, node3.network.endpoint ());
1565  	ASSERT_NE (nullptr, channel3);
1566  	auto vote0 = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1567  	auto vote1 = std::make_shared<nano::vote> (keypair1.pub, keypair1.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1568  	auto vote2 = std::make_shared<nano::vote> (keypair2.pub, keypair2.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1569  	node.rep_crawler.response (channel1, vote0);
1570  	node.rep_crawler.response (channel2, vote1);
1571  	node.rep_crawler.response (channel3, vote2);
1572  	ASSERT_TIMELY (5s, node.rep_crawler.representative_count () == 2);
1573  	auto reps = node.rep_crawler.representatives (1);
1574  	ASSERT_EQ (1, reps.size ());
1575  	ASSERT_EQ (node.balance (nano::dev::genesis_key.pub), node.ledger.weight (reps[0].account));
1576  	ASSERT_EQ (nano::dev::genesis_key.pub, reps[0].account);
1577  	ASSERT_EQ (*channel1, reps[0].channel_ref ());
1578  	ASSERT_TRUE (node.rep_crawler.is_pr (*channel1));
1579  	ASSERT_FALSE (node.rep_crawler.is_pr (*channel2));
1580  	ASSERT_TRUE (node.rep_crawler.is_pr (*channel3));
1581  }
1582  TEST (node, rep_remove)
1583  {
1584  	nano::test::system system;
1585  	auto & searching_node = *system.add_node (); 
1586  	nano::keypair keys_rep1; 
1587  	nano::keypair keys_rep2; 
1588  	nano::block_builder builder;
1589  	std::shared_ptr<nano::block> send_to_rep1 = builder
1590  												.state ()
1591  												.account (nano::dev::genesis_key.pub)
1592  												.previous (nano::dev::genesis->hash ())
1593  												.representative (nano::dev::genesis_key.pub)
1594  												.balance (nano::dev::constants.genesis_amount - searching_node.minimum_principal_weight () * 2)
1595  												.link (keys_rep1.pub)
1596  												.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1597  												.work (*system.work.generate (nano::dev::genesis->hash ()))
1598  												.build ();
1599  	std::shared_ptr<nano::block> receive_rep1 = builder
1600  												.state ()
1601  												.account (keys_rep1.pub)
1602  												.previous (0)
1603  												.representative (keys_rep1.pub)
1604  												.balance (searching_node.minimum_principal_weight () * 2)
1605  												.link (send_to_rep1->hash ())
1606  												.sign (keys_rep1.prv, keys_rep1.pub)
1607  												.work (*system.work.generate (keys_rep1.pub))
1608  												.build ();
1609  	std::shared_ptr<nano::block> send_to_rep2 = builder
1610  												.state ()
1611  												.account (nano::dev::genesis_key.pub)
1612  												.previous (send_to_rep1->hash ())
1613  												.representative (nano::dev::genesis_key.pub)
1614  												.balance (nano::dev::constants.genesis_amount - searching_node.minimum_principal_weight () * 4)
1615  												.link (keys_rep2.pub)
1616  												.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1617  												.work (*system.work.generate (send_to_rep1->hash ()))
1618  												.build ();
1619  	std::shared_ptr<nano::block> receive_rep2 = builder
1620  												.state ()
1621  												.account (keys_rep2.pub)
1622  												.previous (0)
1623  												.representative (keys_rep2.pub)
1624  												.balance (searching_node.minimum_principal_weight () * 2)
1625  												.link (send_to_rep2->hash ())
1626  												.sign (keys_rep2.prv, keys_rep2.pub)
1627  												.work (*system.work.generate (keys_rep2.pub))
1628  												.build ();
1629  	{
1630  		auto transaction = searching_node.store.tx_begin_write ();
1631  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *send_to_rep1).code);
1632  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *receive_rep1).code);
1633  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *send_to_rep2).code);
1634  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *receive_rep2).code);
1635  	}
1636  	auto channel_rep1 (std::make_shared<nano::transport::fake::channel> (searching_node));
1637  	auto vote_rep1 = std::make_shared<nano::vote> (keys_rep1.pub, keys_rep1.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1638  	ASSERT_FALSE (searching_node.rep_crawler.response (channel_rep1, vote_rep1, true));
1639  	ASSERT_TIMELY (5s, searching_node.rep_crawler.representative_count () == 1);
1640  	auto reps (searching_node.rep_crawler.representatives (1));
1641  	ASSERT_EQ (1, reps.size ());
1642  	ASSERT_EQ (searching_node.minimum_principal_weight () * 2, searching_node.ledger.weight (reps[0].account));
1643  	ASSERT_EQ (keys_rep1.pub, reps[0].account);
1644  	ASSERT_EQ (*channel_rep1, reps[0].channel_ref ());
1645  	channel_rep1->close ();
1646  	ASSERT_TIMELY (5s, searching_node.rep_crawler.representative_count () == 0);
1647  	auto node_genesis_rep = system.add_node (nano::node_config (system.get_available_port (), system.logging));
1648  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1649  	auto channel_genesis_rep (searching_node.network.find_node_id (node_genesis_rep->get_node_id ()));
1650  	ASSERT_NE (nullptr, channel_genesis_rep);
1651  	auto vote_genesis_rep = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1652  	searching_node.rep_crawler.response (channel_genesis_rep, vote_genesis_rep, true);
1653  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 1);
1654  	auto node_rep2 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), nano::node_config (system.get_available_port (), system.logging), system.work));
1655  	node_rep2->start ();
1656  	searching_node.network.tcp_channels.start_tcp (node_rep2->network.endpoint ());
1657  	std::shared_ptr<nano::transport::channel> channel_rep2;
1658  	ASSERT_TIMELY (10s, (channel_rep2 = searching_node.network.tcp_channels.find_node_id (node_rep2->get_node_id ())) != nullptr);
1659  	auto vote_rep2 = std::make_shared<nano::vote> (keys_rep2.pub, keys_rep2.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1660  	ASSERT_FALSE (searching_node.rep_crawler.response (channel_rep2, vote_rep2, true));
1661  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 2);
1662  	node_rep2->stop ();
1663  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 1);
1664  	reps = searching_node.rep_crawler.representatives (1);
1665  	ASSERT_EQ (nano::dev::genesis_key.pub, reps[0].account);
1666  	ASSERT_TIMELY_EQ (5s, searching_node.network.size (), 1);
1667  	auto list (searching_node.network.list (1));
1668  	ASSERT_EQ (node_genesis_rep->network.endpoint (), list[0]->get_endpoint ());
1669  }
1670  TEST (node, rep_connection_close)
1671  {
1672  	nano::test::system system (2);
1673  	auto & node1 (*system.nodes[0]);
1674  	auto & node2 (*system.nodes[1]);
1675  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1676  	ASSERT_TIMELY (10s, node1.rep_crawler.representative_count () == 1);
1677  	node2.stop ();
1678  	ASSERT_TIMELY (10s, node1.rep_crawler.representative_count () == 0);
1679  }
1680  TEST (node, no_voting)
1681  {
1682  	nano::test::system system (1);
1683  	auto & node0 (*system.nodes[0]);
1684  	nano::node_config node_config (system.get_available_port (), system.logging);
1685  	node_config.enable_voting = false;
1686  	system.add_node (node_config);
1687  	auto wallet0 (system.wallet (0));
1688  	auto wallet1 (system.wallet (1));
1689  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
1690  	nano::keypair key1;
1691  	wallet1->insert_adhoc (key1.prv);
1692  	wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, nano::Mxrb_ratio);
1693  	ASSERT_TIMELY (10s, node0.active.empty ());
1694  	ASSERT_EQ (0, node0.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::in));
1695  }
1696  TEST (node, send_callback)
1697  {
1698  	nano::test::system system (1);
1699  	auto & node0 (*system.nodes[0]);
1700  	nano::keypair key2;
1701  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1702  	system.wallet (0)->insert_adhoc (key2.prv);
1703  	node0.config.callback_address = "localhost";
1704  	node0.config.callback_port = 8010;
1705  	node0.config.callback_target = "/";
1706  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0.config.receive_minimum.number ()));
1707  	ASSERT_TIMELY (10s, node0.balance (key2.pub).is_zero ());
1708  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - node0.config.receive_minimum.number (), node0.balance (nano::dev::genesis_key.pub));
1709  }
1710  TEST (node, balance_observer)
1711  {
1712  	nano::test::system system (1);
1713  	auto & node1 (*system.nodes[0]);
1714  	std::atomic<int> balances (0);
1715  	nano::keypair key;
1716  	node1.observers.account_balance.add ([&key, &balances] (nano::account const & account_a, bool is_pending) {
1717  		if (key.pub == account_a && is_pending)
1718  		{
1719  			balances++;
1720  		}
1721  		else if (nano::dev::genesis_key.pub == account_a && !is_pending)
1722  		{
1723  			balances++;
1724  		}
1725  	});
1726  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1727  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1);
1728  	system.deadline_set (10s);
1729  	auto done (false);
1730  	while (!done)
1731  	{
1732  		auto ec = system.poll ();
1733  		done = balances.load () == 2;
1734  		ASSERT_NO_ERROR (ec);
1735  	}
1736  }
1737  TEST (node, bootstrap_connection_scaling)
1738  {
1739  	nano::test::system system (1);
1740  	auto & node1 (*system.nodes[0]);
1741  	ASSERT_EQ (34, node1.bootstrap_initiator.connections->target_connections (5000, 1));
1742  	ASSERT_EQ (4, node1.bootstrap_initiator.connections->target_connections (0, 1));
1743  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1744  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 1));
1745  	ASSERT_EQ (32, node1.bootstrap_initiator.connections->target_connections (5000, 0));
1746  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (0, 0));
1747  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 0));
1748  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 0));
1749  	ASSERT_EQ (36, node1.bootstrap_initiator.connections->target_connections (5000, 2));
1750  	ASSERT_EQ (8, node1.bootstrap_initiator.connections->target_connections (0, 2));
1751  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1752  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 2));
1753  	node1.config.bootstrap_connections = 128;
1754  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (0, 1));
1755  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1756  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (0, 2));
1757  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1758  	node1.config.bootstrap_connections_max = 256;
1759  	ASSERT_EQ (128, node1.bootstrap_initiator.connections->target_connections (0, 1));
1760  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1761  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (0, 2));
1762  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1763  	node1.config.bootstrap_connections_max = 0;
1764  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (0, 1));
1765  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1766  }
1767  TEST (node, stat_counting)
1768  {
1769  	nano::test::system system (1);
1770  	auto & node1 (*system.nodes[0]);
1771  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 1);
1772  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 5);
1773  	node1.stats.inc (nano::stat::type::ledger, nano::stat::dir::in);
1774  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in);
1775  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in);
1776  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::receive, nano::stat::dir::in);
1777  	ASSERT_EQ (10, node1.stats.count (nano::stat::type::ledger, nano::stat::dir::in));
1778  	ASSERT_EQ (2, node1.stats.count (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in));
1779  	ASSERT_EQ (1, node1.stats.count (nano::stat::type::ledger, nano::stat::detail::receive, nano::stat::dir::in));
1780  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 0);
1781  	ASSERT_EQ (10, node1.stats.count (nano::stat::type::ledger, nano::stat::dir::in));
1782  }
1783  TEST (node, stat_histogram)
1784  {
1785  	nano::test::system system (1);
1786  	auto & node1 (*system.nodes[0]);
1787  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in, { 1, 6, 10, 16 });
1788  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in, 1, 50);
1789  	auto histogram_req (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in));
1790  	ASSERT_EQ (histogram_req->get_bins ()[0].value, 50);
1791  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, { 1, 13 }, 12);
1792  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 1);
1793  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 8, 10);
1794  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 100);
1795  	auto histogram_ack (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in));
1796  	ASSERT_EQ (histogram_ack->get_bins ()[0].value, 1);
1797  	ASSERT_EQ (histogram_ack->get_bins ()[7].value, 10);
1798  	ASSERT_EQ (histogram_ack->get_bins ()[11].value, 1);
1799  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, { 1, 11 }, 2);
1800  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, 1, 1);
1801  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, 6, 1);
1802  	auto histogram_ack_out (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out));
1803  	ASSERT_EQ (histogram_ack_out->get_bins ()[0].value, 1);
1804  	ASSERT_EQ (histogram_ack_out->get_bins ()[1].value, 1);
1805  }
1806  TEST (node, online_reps)
1807  {
1808  	nano::test::system system (1);
1809  	auto & node1 (*system.nodes[0]);
1810  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1811  	auto vote (std::make_shared<nano::vote> ());
1812  	ASSERT_EQ (0, node1.online_reps.online ());
1813  	node1.online_reps.observe (nano::dev::genesis_key.pub);
1814  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.online ());
1815  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1816  	node1.online_reps.sample ();
1817  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.trended ());
1818  	node1.online_reps.clear ();
1819  	node1.online_reps.sample ();
1820  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1821  }
1822  namespace nano
1823  {
1824  TEST (node, online_reps_rep_crawler)
1825  {
1826  	nano::test::system system;
1827  	nano::node_flags flags;
1828  	flags.disable_rep_crawler = true;
1829  	auto & node1 = *system.add_node (flags);
1830  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1831  	ASSERT_EQ (0, node1.online_reps.online ());
1832  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1833  	ASSERT_EQ (0, node1.online_reps.online ());
1834  	{
1835  		nano::lock_guard<nano::mutex> guard{ node1.rep_crawler.probable_reps_mutex };
1836  		node1.rep_crawler.active.insert (nano::dev::genesis->hash ());
1837  	}
1838  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1839  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.online ());
1840  }
1841  }
1842  TEST (node, online_reps_election)
1843  {
1844  	nano::test::system system;
1845  	nano::node_flags flags;
1846  	flags.disable_rep_crawler = true;
1847  	auto & node1 = *system.add_node (flags);
1848  	nano::keypair key;
1849  	nano::state_block_builder builder;
1850  	auto send1 = builder.make_block ()
1851  				 .account (nano::dev::genesis_key.pub)
1852  				 .previous (nano::dev::genesis->hash ())
1853  				 .representative (nano::dev::genesis_key.pub)
1854  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1855  				 .link (key.pub)
1856  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1857  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1858  				 .build_shared ();
1859  	node1.process_active (send1);
1860  	node1.block_processor.flush ();
1861  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
1862  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), 0, std::vector<nano::block_hash>{ send1->hash () });
1863  	ASSERT_EQ (0, node1.online_reps.online ());
1864  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1865  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, node1.online_reps.online ());
1866  }
1867  TEST (node, block_confirm)
1868  {
1869  	auto type = nano::transport::transport_type::tcp;
1870  	nano::node_flags node_flags;
1871  	nano::test::system system (2, type, node_flags);
1872  	auto & node1 (*system.nodes[0]);
1873  	auto & node2 (*system.nodes[1]);
1874  	nano::keypair key;
1875  	nano::state_block_builder builder;
1876  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1877  	auto send1 = builder.make_block ()
1878  				 .account (nano::dev::genesis_key.pub)
1879  				 .previous (nano::dev::genesis->hash ())
1880  				 .representative (nano::dev::genesis_key.pub)
1881  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1882  				 .link (key.pub)
1883  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1884  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1885  				 .build_shared ();
1886  	auto send1_copy = builder.make_block ()
1887  					  .from (*send1)
1888  					  .build_shared ();
1889  	node1.block_processor.add (send1);
1890  	node2.block_processor.add (send1_copy);
1891  	ASSERT_TIMELY (5s, node1.ledger.block_or_pruned_exists (send1->hash ()) && node2.ledger.block_or_pruned_exists (send1_copy->hash ()));
1892  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
1893  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1_copy->hash ()));
1894  	node2.block_confirm (send1_copy);
1895  	auto election = node2.active.election (send1_copy->qualified_root ());
1896  	ASSERT_NE (nullptr, election);
1897  	ASSERT_TIMELY (10s, node1.active.recently_cemented.list ().size () == 1);
1898  }
1899  TEST (node, block_arrival)
1900  {
1901  	nano::test::system system (1);
1902  	auto & node (*system.nodes[0]);
1903  	ASSERT_EQ (0, node.block_arrival.arrival.size ());
1904  	nano::block_hash hash1 (1);
1905  	node.block_arrival.add (hash1);
1906  	ASSERT_EQ (1, node.block_arrival.arrival.size ());
1907  	node.block_arrival.add (hash1);
1908  	ASSERT_EQ (1, node.block_arrival.arrival.size ());
1909  	nano::block_hash hash2 (2);
1910  	node.block_arrival.add (hash2);
1911  	ASSERT_EQ (2, node.block_arrival.arrival.size ());
1912  }
1913  TEST (node, block_arrival_size)
1914  {
1915  	nano::test::system system (1);
1916  	auto & node (*system.nodes[0]);
1917  	auto time (std::chrono::steady_clock::now () - nano::block_arrival::arrival_time_min - std::chrono::seconds (5));
1918  	nano::block_hash hash (0);
1919  	for (auto i (0); i < nano::block_arrival::arrival_size_min * 2; ++i)
1920  	{
1921  		node.block_arrival.arrival.push_back (nano::block_arrival_info{ time, hash });
1922  		++hash.qwords[0];
1923  	}
1924  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1925  	node.block_arrival.recent (0);
1926  	ASSERT_EQ (nano::block_arrival::arrival_size_min, node.block_arrival.arrival.size ());
1927  }
1928  TEST (node, block_arrival_time)
1929  {
1930  	nano::test::system system (1);
1931  	auto & node (*system.nodes[0]);
1932  	auto time (std::chrono::steady_clock::now ());
1933  	nano::block_hash hash (0);
1934  	for (auto i (0); i < nano::block_arrival::arrival_size_min * 2; ++i)
1935  	{
1936  		node.block_arrival.arrival.push_back (nano::block_arrival_info{ time, hash });
1937  		++hash.qwords[0];
1938  	}
1939  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1940  	node.block_arrival.recent (0);
1941  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1942  }
1943  TEST (node, confirm_quorum)
1944  {
1945  	nano::test::system system (1);
1946  	auto & node1 = *system.nodes[0];
1947  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1948  	nano::amount new_balance = node1.online_reps.delta () - nano::Gxrb_ratio;
1949  	auto send1 = nano::state_block_builder ()
1950  				 .account (nano::dev::genesis_key.pub)
1951  				 .previous (nano::dev::genesis->hash ())
1952  				 .representative (nano::dev::genesis_key.pub)
1953  				 .balance (new_balance)
1954  				 .link (nano::dev::genesis_key.pub)
1955  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1956  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1957  				 .build_shared ();
1958  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
1959  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, new_balance.number ());
1960  	ASSERT_TIMELY (2s, node1.active.election (send1->qualified_root ()));
1961  	auto election = node1.active.election (send1->qualified_root ());
1962  	ASSERT_NE (nullptr, election);
1963  	ASSERT_FALSE (election->confirmed ());
1964  	ASSERT_EQ (1, election->votes ().size ());
1965  	ASSERT_EQ (0, node1.balance (nano::dev::genesis_key.pub));
1966  }
1967  TEST (node, local_votes_cache)
1968  {
1969  	nano::test::system system;
1970  	nano::node_config node_config (system.get_available_port (), system.logging);
1971  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1972  	node_config.receive_minimum = nano::dev::constants.genesis_amount;
1973  	auto & node (*system.add_node (node_config));
1974  	nano::state_block_builder builder;
1975  	auto send1 = builder.make_block ()
1976  				 .account (nano::dev::genesis_key.pub)
1977  				 .previous (nano::dev::genesis->hash ())
1978  				 .representative (nano::dev::genesis_key.pub)
1979  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1980  				 .link (nano::dev::genesis_key.pub)
1981  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1982  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
1983  				 .build_shared ();
1984  	auto send2 = builder.make_block ()
1985  				 .account (nano::dev::genesis_key.pub)
1986  				 .previous (send1->hash ())
1987  				 .representative (nano::dev::genesis_key.pub)
1988  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
1989  				 .link (nano::dev::genesis_key.pub)
1990  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1991  				 .work (*node.work_generate_blocking (send1->hash ()))
1992  				 .build_shared ();
1993  	auto send3 = builder.make_block ()
1994  				 .account (nano::dev::genesis_key.pub)
1995  				 .previous (send2->hash ())
1996  				 .representative (nano::dev::genesis_key.pub)
1997  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
1998  				 .link (nano::dev::genesis_key.pub)
1999  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2000  				 .work (*node.work_generate_blocking (send2->hash ()))
2001  				 .build_shared ();
2002  	{
2003  		auto transaction (node.store.tx_begin_write ());
2004  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send1).code);
2005  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send2).code);
2006  	}
2007  	node.block_confirm (send2);
2008  	auto election = node.active.election (send2->qualified_root ());
2009  	ASSERT_NE (nullptr, election);
2010  	election->force_confirm ();
2011  	ASSERT_TIMELY (3s, node.ledger.cache.cemented_count == 3);
2012  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2013  	nano::confirm_req message1{ nano::dev::network_params.network, send1 };
2014  	nano::confirm_req message2{ nano::dev::network_params.network, send2 };
2015  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2016  	node.network.inbound (message1, channel);
2017  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 1);
2018  	node.network.inbound (message2, channel);
2019  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2020  	for (auto i (0); i < 100; ++i)
2021  	{
2022  		node.network.inbound (message1, channel);
2023  		node.network.inbound (message2, channel);
2024  	}
2025  	for (int i = 0; i < 4; ++i)
2026  	{
2027  		ASSERT_NO_ERROR (system.poll (node.aggregator.max_delay));
2028  	}
2029  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2030  	{
2031  		auto transaction (node.store.tx_begin_write ());
2032  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send3).code);
2033  	}
2034  	nano::confirm_req message3{ nano::dev::network_params.network, send3 };
2035  	for (auto i (0); i < 100; ++i)
2036  	{
2037  		node.network.inbound (message3, channel);
2038  	}
2039  	for (int i = 0; i < 4; ++i)
2040  	{
2041  		ASSERT_NO_ERROR (system.poll (node.aggregator.max_delay));
2042  	}
2043  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 3);
2044  	ASSERT_TIMELY (3s, !node.history.votes (send1->root (), send1->hash ()).empty ());
2045  	ASSERT_TIMELY (3s, !node.history.votes (send2->root (), send2->hash ()).empty ());
2046  	ASSERT_TIMELY (3s, !node.history.votes (send3->root (), send3->hash ()).empty ());
2047  }
2048  TEST (node, DISABLED_local_votes_cache_batch)
2049  {
2050  	nano::test::system system;
2051  	nano::node_config node_config (system.get_available_port (), system.logging);
2052  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2053  	auto & node (*system.add_node (node_config));
2054  	ASSERT_GE (node.network_params.voting.max_cache, 2);
2055  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2056  	nano::keypair key1;
2057  	auto send1 = nano::state_block_builder ()
2058  				 .account (nano::dev::genesis_key.pub)
2059  				 .previous (nano::dev::genesis->hash ())
2060  				 .representative (nano::dev::genesis_key.pub)
2061  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2062  				 .link (key1.pub)
2063  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2064  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2065  				 .build_shared ();
2066  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send1).code);
2067  	node.confirmation_height_processor.add (send1);
2068  	ASSERT_TIMELY (5s, node.ledger.block_confirmed (node.store.tx_begin_read (), send1->hash ()));
2069  	auto send2 = nano::state_block_builder ()
2070  				 .account (nano::dev::genesis_key.pub)
2071  				 .previous (send1->hash ())
2072  				 .representative (nano::dev::genesis_key.pub)
2073  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2074  				 .link (nano::dev::genesis_key.pub)
2075  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2076  				 .work (*node.work_generate_blocking (send1->hash ()))
2077  				 .build_shared ();
2078  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send2).code);
2079  	auto receive1 = nano::state_block_builder ()
2080  					.account (key1.pub)
2081  					.previous (0)
2082  					.representative (nano::dev::genesis_key.pub)
2083  					.balance (nano::Gxrb_ratio)
2084  					.link (send1->hash ())
2085  					.sign (key1.prv, key1.pub)
2086  					.work (*node.work_generate_blocking (key1.pub))
2087  					.build_shared ();
2088  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *receive1).code);
2089  	std::vector<std::pair<nano::block_hash, nano::root>> batch{ { send2->hash (), send2->root () }, { receive1->hash (), receive1->root () } };
2090  	nano::confirm_req message{ nano::dev::network_params.network, batch };
2091  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2092  	node.network.inbound (message, channel);
2093  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 1);
2094  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2095  	ASSERT_FALSE (node.history.votes (send2->root (), send2->hash ()).empty ());
2096  	ASSERT_FALSE (node.history.votes (receive1->root (), receive1->hash ()).empty ());
2097  	node.network.inbound (message, channel);
2098  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 2);
2099  	ASSERT_EQ (2, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2100  	node.history.erase (send2->root ());
2101  	node.history.erase (receive1->root ());
2102  	node.network.inbound (nano::confirm_req{ nano::dev::network_params.network, send2->hash (), send2->root () }, channel);
2103  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 3);
2104  	ASSERT_EQ (3, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2105  	node.network.inbound (nano::confirm_req{ nano::dev::network_params.network, receive1->hash (), receive1->root () }, channel);
2106  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 4);
2107  	ASSERT_EQ (4, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2108  	node.network.inbound (message, channel);
2109  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 6);
2110  	ASSERT_EQ (6, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2111  }
2112  TEST (node, local_votes_cache_generate_new_vote)
2113  {
2114  	nano::test::system system;
2115  	nano::node_config node_config (system.get_available_port (), system.logging);
2116  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2117  	auto & node (*system.add_node (node_config));
2118  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2119  	nano::confirm_req message1{ nano::dev::network_params.network, nano::dev::genesis };
2120  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2121  	node.network.inbound (message1, channel);
2122  	ASSERT_TIMELY (5s, !node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ()).empty ());
2123  	auto votes1 = node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ());
2124  	ASSERT_EQ (1, votes1.size ());
2125  	ASSERT_EQ (1, votes1[0]->hashes.size ());
2126  	ASSERT_EQ (nano::dev::genesis->hash (), votes1[0]->hashes[0]);
2127  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 1);
2128  	auto send1 = nano::state_block_builder ()
2129  				 .account (nano::dev::genesis_key.pub)
2130  				 .previous (nano::dev::genesis->hash ())
2131  				 .representative (nano::dev::genesis_key.pub)
2132  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2133  				 .link (nano::dev::genesis_key.pub)
2134  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2135  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2136  				 .build_shared ();
2137  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
2138  	std::vector<std::pair<nano::block_hash, nano::root>> roots_hashes{ std::make_pair (nano::dev::genesis->hash (), nano::dev::genesis->root ()), std::make_pair (send1->hash (), send1->root ()) };
2139  	nano::confirm_req message2{ nano::dev::network_params.network, roots_hashes };
2140  	node.network.inbound (message2, channel);
2141  	ASSERT_TIMELY (3s, !node.history.votes (send1->root (), send1->hash ()).empty ());
2142  	auto votes2 (node.history.votes (send1->root (), send1->hash ()));
2143  	ASSERT_EQ (1, votes2.size ());
2144  	ASSERT_EQ (1, votes2[0]->hashes.size ());
2145  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2146  	ASSERT_FALSE (node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ()).empty ());
2147  	ASSERT_FALSE (node.history.votes (send1->root (), send1->hash ()).empty ());
2148  	ASSERT_TIMELY (3s, 3 == node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2149  }
2150  TEST (node, local_votes_cache_fork)
2151  {
2152  	nano::test::system system;
2153  	nano::node_flags node_flags;
2154  	node_flags.disable_bootstrap_bulk_push_client = true;
2155  	node_flags.disable_bootstrap_bulk_pull_server = true;
2156  	node_flags.disable_bootstrap_listener = true;
2157  	node_flags.disable_lazy_bootstrap = true;
2158  	node_flags.disable_legacy_bootstrap = true;
2159  	node_flags.disable_wallet_bootstrap = true;
2160  	nano::node_config node_config (system.get_available_port (), system.logging);
2161  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2162  	auto & node1 (*system.add_node (node_config, node_flags));
2163  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2164  	auto send1 = nano::state_block_builder ()
2165  				 .account (nano::dev::genesis_key.pub)
2166  				 .previous (nano::dev::genesis->hash ())
2167  				 .representative (nano::dev::genesis_key.pub)
2168  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2169  				 .link (nano::dev::genesis_key.pub)
2170  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2171  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
2172  				 .build_shared ();
2173  	auto send1_fork = nano::state_block_builder ()
2174  					  .account (nano::dev::genesis_key.pub)
2175  					  .previous (nano::dev::genesis->hash ())
2176  					  .representative (nano::dev::genesis_key.pub)
2177  					  .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2178  					  .link (nano::dev::genesis_key.pub)
2179  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2180  					  .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
2181  					  .build_shared ();
2182  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
2183  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
2184  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2185  	node1.history.add (send1->root (), send1->hash (), vote);
2186  	auto votes2 (node1.history.votes (send1->root (), send1->hash ()));
2187  	ASSERT_EQ (1, votes2.size ());
2188  	ASSERT_EQ (1, votes2[0]->hashes.size ());
2189  	node_config.peering_port = system.get_available_port ();
2190  	auto & node2 (*system.add_node (node_config, node_flags));
2191  	node2.process_active (send1_fork);
2192  	node2.block_processor.flush ();
2193  	ASSERT_TIMELY (5s, node2.ledger.block_or_pruned_exists (send1->hash ()));
2194  }
2195  TEST (node, vote_republish)
2196  {
2197  	nano::test::system system (2);
2198  	auto & node1 = *system.nodes[0];
2199  	auto & node2 = *system.nodes[1];
2200  	nano::keypair key2;
2201  	system.wallet (1)->insert_adhoc (key2.prv);
2202  	nano::send_block_builder builder;
2203  	auto send1 = builder.make_block ()
2204  				 .previous (nano::dev::genesis->hash ())
2205  				 .destination (key2.pub)
2206  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2207  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2208  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2209  				 .build_shared ();
2210  	auto send2 = builder.make_block ()
2211  				 .previous (nano::dev::genesis->hash ())
2212  				 .destination (key2.pub)
2213  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2214  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2215  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2216  				 .build_shared ();
2217  	node1.process_active (send1);
2218  	ASSERT_TIMELY (5s, node2.block (send1->hash ()));
2219  	ASSERT_TIMELY (5s, node1.active.active (*send1));
2220  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2221  	node1.process_active (send2);
2222  	ASSERT_TIMELY (5s, node1.active.active (*send2));
2223  	ASSERT_FALSE (node1.block (send2->hash ()));
2224  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send2->hash () }));
2225  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2226  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
2227  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
2228  	ASSERT_FALSE (node1.block (send1->hash ()));
2229  	ASSERT_FALSE (node2.block (send1->hash ()));
2230  	ASSERT_TIMELY (5s, node2.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2231  	ASSERT_TIMELY (5s, node1.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2232  }
2233  TEST (node, vote_by_hash_bundle)
2234  {
2235  	std::atomic<size_t> max_hashes{ 0 };
2236  	nano::test::system system (1);
2237  	auto & node = *system.nodes[0];
2238  	nano::state_block_builder builder;
2239  	std::vector<std::shared_ptr<nano::state_block>> blocks;
2240  	auto block = builder.make_block ()
2241  				 .account (nano::dev::genesis_key.pub)
2242  				 .previous (nano::dev::genesis->hash ())
2243  				 .representative (nano::dev::genesis_key.pub)
2244  				 .balance (nano::dev::constants.genesis_amount - 1)
2245  				 .link (nano::dev::genesis_key.pub)
2246  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2247  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2248  				 .build_shared ();
2249  	blocks.push_back (block);
2250  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *blocks.back ()).code);
2251  	for (auto i = 2; i < 200; ++i)
2252  	{
2253  		auto block = builder.make_block ()
2254  					 .from (*blocks.back ())
2255  					 .previous (blocks.back ()->hash ())
2256  					 .balance (nano::dev::constants.genesis_amount - i)
2257  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2258  					 .work (*system.work.generate (blocks.back ()->hash ()))
2259  					 .build_shared ();
2260  		blocks.push_back (block);
2261  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *blocks.back ()).code);
2262  	}
2263  	ASSERT_TIMELY (5s, nano::test::confirm (node, { blocks.back () }));
2264  	ASSERT_TIMELY (5s, nano::test::confirmed (node, { blocks.back () }));
2265  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2266  	nano::keypair key1;
2267  	system.wallet (0)->insert_adhoc (key1.prv);
2268  	system.nodes[0]->observers.vote.add ([&max_hashes] (std::shared_ptr<nano::vote> const & vote_a, std::shared_ptr<nano::transport::channel> const &, nano::vote_code) {
2269  		if (vote_a->hashes.size () > max_hashes)
2270  		{
2271  			max_hashes = vote_a->hashes.size ();
2272  		}
2273  	});
2274  	for (auto const & block : blocks)
2275  	{
2276  		system.nodes[0]->generator.add (block->root (), block->hash ());
2277  	}
2278  	ASSERT_TIMELY (20s, max_hashes.load () >= 3);
2279  }
2280  TEST (node, vote_by_hash_republish)
2281  {
2282  	nano::test::system system{ 2 };
2283  	auto & node1 = *system.nodes[0];
2284  	auto & node2 = *system.nodes[1];
2285  	nano::keypair key2;
2286  	system.wallet (1)->insert_adhoc (key2.prv);
2287  	nano::send_block_builder builder;
2288  	auto send1 = builder.make_block ()
2289  				 .previous (nano::dev::genesis->hash ())
2290  				 .destination (key2.pub)
2291  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2292  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2293  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2294  				 .build_shared ();
2295  	auto send2 = builder.make_block ()
2296  				 .previous (nano::dev::genesis->hash ())
2297  				 .destination (key2.pub)
2298  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2299  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2300  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2301  				 .build_shared ();
2302  	node1.process_active (send1);
2303  	ASSERT_TIMELY (5s, node1.active.active (*send1));
2304  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2305  	node1.network.publish_filter.clear ();
2306  	node1.process_active (send2);
2307  	ASSERT_TIMELY (5s, node1.active.active (*send2));
2308  	std::vector<nano::block_hash> vote_blocks;
2309  	vote_blocks.push_back (send2->hash ());
2310  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, vote_blocks);
2311  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2312  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
2313  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
2314  	ASSERT_FALSE (node1.block (send1->hash ()));
2315  	ASSERT_FALSE (node2.block (send1->hash ()));
2316  	ASSERT_TIMELY (5s, node2.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2317  	ASSERT_TIMELY (5s, node1.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2318  }
2319  TEST (node, DISABLED_vote_by_hash_epoch_block_republish)
2320  {
2321  	nano::test::system system (2);
2322  	auto & node1 (*system.nodes[0]);
2323  	auto & node2 (*system.nodes[1]);
2324  	nano::keypair key2;
2325  	system.wallet (1)->insert_adhoc (key2.prv);
2326  	auto send1 = nano::send_block_builder ()
2327  				 .previous (nano::dev::genesis->hash ())
2328  				 .destination (key2.pub)
2329  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2330  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2331  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2332  				 .build_shared ();
2333  	auto epoch1 = nano::state_block_builder ()
2334  				  .account (nano::dev::genesis->account ())
2335  				  .previous (nano::dev::genesis->hash ())
2336  				  .representative (nano::dev::genesis->account ())
2337  				  .balance (nano::dev::constants.genesis_amount)
2338  				  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
2339  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2340  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
2341  				  .build_shared ();
2342  	node1.process_active (send1);
2343  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2344  	node1.active.publish (epoch1);
2345  	std::vector<nano::block_hash> vote_blocks;
2346  	vote_blocks.push_back (epoch1->hash ());
2347  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, vote_blocks));
2348  	ASSERT_TRUE (node1.active.active (*send1));
2349  	ASSERT_TRUE (node2.active.active (*send1));
2350  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2351  	ASSERT_TIMELY (10s, node1.block (epoch1->hash ()));
2352  	ASSERT_TIMELY (10s, node2.block (epoch1->hash ()));
2353  	ASSERT_FALSE (node1.block (send1->hash ()));
2354  	ASSERT_FALSE (node2.block (send1->hash ()));
2355  }
2356  TEST (node, epoch_conflict_confirm)
2357  {
2358  	nano::test::system system;
2359  	nano::node_config node_config (system.get_available_port (), system.logging);
2360  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2361  	auto & node0 = *system.add_node (node_config);
2362  	node_config.peering_port = system.get_available_port ();
2363  	auto & node1 = *system.add_node (node_config);
2364  	nano::keypair key;
2365  	nano::keypair epoch_signer (nano::dev::genesis_key);
2366  	nano::state_block_builder builder;
2367  	auto send = builder.make_block ()
2368  				.account (nano::dev::genesis_key.pub)
2369  				.previous (nano::dev::genesis->hash ())
2370  				.representative (nano::dev::genesis_key.pub)
2371  				.balance (nano::dev::constants.genesis_amount - 1)
2372  				.link (key.pub)
2373  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2374  				.work (*system.work.generate (nano::dev::genesis->hash ()))
2375  				.build_shared ();
2376  	auto open = builder.make_block ()
2377  				.account (key.pub)
2378  				.previous (0)
2379  				.representative (key.pub)
2380  				.balance (1)
2381  				.link (send->hash ())
2382  				.sign (key.prv, key.pub)
2383  				.work (*system.work.generate (key.pub))
2384  				.build_shared ();
2385  	auto change = builder.make_block ()
2386  				  .account (key.pub)
2387  				  .previous (open->hash ())
2388  				  .representative (key.pub)
2389  				  .balance (1)
2390  				  .link (0)
2391  				  .sign (key.prv, key.pub)
2392  				  .work (*system.work.generate (open->hash ()))
2393  				  .build_shared ();
2394  	auto send2 = builder.make_block ()
2395  				 .account (nano::dev::genesis_key.pub)
2396  				 .previous (send->hash ())
2397  				 .representative (nano::dev::genesis_key.pub)
2398  				 .balance (nano::dev::constants.genesis_amount - 2)
2399  				 .link (open->hash ())
2400  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2401  				 .work (*system.work.generate (send->hash ()))
2402  				 .build_shared ();
2403  	auto epoch_open = builder.make_block ()
2404  					  .account (change->root ().as_account ())
2405  					  .previous (0)
2406  					  .representative (0)
2407  					  .balance (0)
2408  					  .link (node0.ledger.epoch_link (nano::epoch::epoch_1))
2409  					  .sign (epoch_signer.prv, epoch_signer.pub)
2410  					  .work (*system.work.generate (open->hash ()))
2411  					  .build_shared ();
2412  	ASSERT_TRUE (nano::test::process (node1, { send, send2, open }));
2413  	ASSERT_TIMELY (5s, nano::test::confirm (node1, { open }));
2414  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { open }));
2415  	ASSERT_TRUE (nano::test::process (node0, { send, send2, open }));
2416  	ASSERT_TRUE (nano::test::process_live (node0, { change, epoch_open }));
2417  	ASSERT_TIMELY (5s, nano::test::exists (node0, { change, epoch_open }));
2418  	ASSERT_TIMELY (5s, nano::test::exists (node1, { change, epoch_open }));
2419  	ASSERT_TIMELY (5s, nano::test::confirm (node1, { change, epoch_open, send2 }));
2420  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { change, epoch_open, send2 }));
2421  	ASSERT_TRUE (nano::test::activate (node0, { change, epoch_open }));
2422  	ASSERT_TIMELY (5s, nano::test::active (node0, { change, epoch_open }));
2423  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
2424  	ASSERT_TIMELY (5s, nano::test::active (node0, { change, epoch_open }));
2425  	ASSERT_TIMELY (5s, nano::test::confirmed (node0, { change, epoch_open }));
2426  }
2427  TEST (node, DISABLED_fork_invalid_block_signature)
2428  {
2429  	nano::test::system system;
2430  	nano::node_flags node_flags;
2431  	node_flags.disable_block_processor_republishing = true;
2432  	auto & node1 (*system.add_node (node_flags));
2433  	auto & node2 (*system.add_node (node_flags));
2434  	nano::keypair key2;
2435  	nano::send_block_builder builder;
2436  	auto send1 = builder.make_block ()
2437  				 .previous (nano::dev::genesis->hash ())
2438  				 .destination (key2.pub)
2439  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2440  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2441  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2442  				 .build_shared ();
2443  	auto send2 = builder.make_block ()
2444  				 .previous (nano::dev::genesis->hash ())
2445  				 .destination (key2.pub)
2446  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2447  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2448  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2449  				 .build_shared ();
2450  	auto send2_corrupt (std::make_shared<nano::send_block> (*send2));
2451  	send2_corrupt->signature = nano::signature (123);
2452  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send2->hash () }));
2453  	auto vote_corrupt (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send2_corrupt->hash () }));
2454  	node1.process_active (send1);
2455  	ASSERT_TIMELY (5s, node1.block (send1->hash ()));
2456  	node2.network.flood_vote (vote_corrupt, 1.0f);
2457  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::rollback, nano::stat::detail::all));
2458  	node2.network.flood_vote (vote, 1.0f);
2459  	ASSERT_TIMELY (10s, !node1.block (send1->hash ()));
2460  	ASSERT_TIMELY (10s, node1.block (send2->hash ()));
2461  	ASSERT_EQ (node1.block (send2->hash ())->block_signature (), send2->block_signature ());
2462  }
2463  TEST (node, fork_election_invalid_block_signature)
2464  {
2465  	nano::test::system system (1);
2466  	auto & node1 (*system.nodes[0]);
2467  	nano::block_builder builder;
2468  	auto send1 = builder.state ()
2469  				 .account (nano::dev::genesis_key.pub)
2470  				 .previous (nano::dev::genesis->hash ())
2471  				 .representative (nano::dev::genesis_key.pub)
2472  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2473  				 .link (nano::dev::genesis_key.pub)
2474  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2475  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2476  				 .build_shared ();
2477  	auto send2 = builder.state ()
2478  				 .account (nano::dev::genesis_key.pub)
2479  				 .previous (nano::dev::genesis->hash ())
2480  				 .representative (nano::dev::genesis_key.pub)
2481  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2482  				 .link (nano::dev::genesis_key.pub)
2483  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2484  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2485  				 .build_shared ();
2486  	auto send3 = builder.state ()
2487  				 .account (nano::dev::genesis_key.pub)
2488  				 .previous (nano::dev::genesis->hash ())
2489  				 .representative (nano::dev::genesis_key.pub)
2490  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2491  				 .link (nano::dev::genesis_key.pub)
2492  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2493  				 .sign (nano::dev::genesis_key.prv, 0) 
2494  				 .build_shared ();
2495  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
2496  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send1 }, channel1);
2497  	ASSERT_TIMELY (5s, node1.active.active (send1->qualified_root ()));
2498  	auto election (node1.active.election (send1->qualified_root ()));
2499  	ASSERT_NE (nullptr, election);
2500  	ASSERT_EQ (1, election->blocks ().size ());
2501  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send3 }, channel1);
2502  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send2 }, channel1);
2503  	ASSERT_TIMELY (3s, election->blocks ().size () > 1);
2504  	ASSERT_EQ (election->blocks ()[send2->hash ()]->block_signature (), send2->block_signature ());
2505  }
2506  TEST (node, block_processor_signatures)
2507  {
2508  	nano::test::system system{ 1 };
2509  	auto & node1 = *system.nodes[0];
2510  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2511  	nano::block_hash latest = system.nodes[0]->latest (nano::dev::genesis_key.pub);
2512  	nano::state_block_builder builder;
2513  	nano::keypair key1;
2514  	nano::keypair key2;
2515  	nano::keypair key3;
2516  	auto send1 = builder.make_block ()
2517  				 .account (nano::dev::genesis_key.pub)
2518  				 .previous (latest)
2519  				 .representative (nano::dev::genesis_key.pub)
2520  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2521  				 .link (key1.pub)
2522  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2523  				 .work (*node1.work_generate_blocking (latest))
2524  				 .build_shared ();
2525  	auto send2 = builder.make_block ()
2526  				 .account (nano::dev::genesis_key.pub)
2527  				 .previous (send1->hash ())
2528  				 .representative (nano::dev::genesis_key.pub)
2529  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2530  				 .link (key2.pub)
2531  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2532  				 .work (*node1.work_generate_blocking (send1->hash ()))
2533  				 .build_shared ();
2534  	auto send3 = builder.make_block ()
2535  				 .account (nano::dev::genesis_key.pub)
2536  				 .previous (send2->hash ())
2537  				 .representative (nano::dev::genesis_key.pub)
2538  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2539  				 .link (key3.pub)
2540  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2541  				 .work (*node1.work_generate_blocking (send2->hash ()))
2542  				 .build_shared ();
2543  	auto send4 = builder.make_block ()
2544  				 .account (nano::dev::genesis_key.pub)
2545  				 .previous (send3->hash ())
2546  				 .representative (nano::dev::genesis_key.pub)
2547  				 .balance (nano::dev::constants.genesis_amount - 4 * nano::Gxrb_ratio)
2548  				 .link (key3.pub)
2549  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2550  				 .work (*node1.work_generate_blocking (send3->hash ()))
2551  				 .build_shared ();
2552  	send4->signature.bytes[32] ^= 0x1;
2553  	auto send5 = builder.make_block ()
2554  				 .account (nano::dev::genesis_key.pub)
2555  				 .previous (send3->hash ())
2556  				 .representative (nano::dev::genesis_key.pub)
2557  				 .balance (nano::dev::constants.genesis_amount - 5 * nano::Gxrb_ratio)
2558  				 .link (key3.pub)
2559  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2560  				 .work (*node1.work_generate_blocking (send3->hash ()))
2561  				 .build_shared ();
2562  	send5->signature.bytes[32] ^= 0x1;
2563  	node1.unchecked.put (send5->previous (), nano::unchecked_info{ send5 });
2564  	auto receive1 = builder.make_block ()
2565  					.account (key1.pub)
2566  					.previous (0)
2567  					.representative (nano::dev::genesis_key.pub)
2568  					.balance (nano::Gxrb_ratio)
2569  					.link (send1->hash ())
2570  					.sign (key1.prv, key1.pub)
2571  					.work (*node1.work_generate_blocking (key1.pub))
2572  					.build_shared ();
2573  	auto receive2 = builder.make_block ()
2574  					.account (key2.pub)
2575  					.previous (0)
2576  					.representative (nano::dev::genesis_key.pub)
2577  					.balance (nano::Gxrb_ratio)
2578  					.link (send2->hash ())
2579  					.sign (key2.prv, key2.pub)
2580  					.work (*node1.work_generate_blocking (key2.pub))
2581  					.build_shared ();
2582  	auto receive3 = builder.make_block ()
2583  					.account (key3.pub)
2584  					.previous (0)
2585  					.representative (nano::dev::genesis_key.pub)
2586  					.balance (nano::Gxrb_ratio)
2587  					.link (send3->hash ())
2588  					.sign (key2.prv, key3.pub)
2589  					.work (*node1.work_generate_blocking (key3.pub))
2590  					.build_shared ();
2591  	node1.process_active (send1);
2592  	node1.process_active (send2);
2593  	node1.process_active (send3);
2594  	node1.process_active (send4);
2595  	node1.process_active (receive1);
2596  	node1.process_active (receive2);
2597  	node1.process_active (receive3);
2598  	ASSERT_TIMELY (5s, node1.block (receive2->hash ()) != nullptr); 
2599  	ASSERT_TIMELY (5s, node1.unchecked.count () == 0);
2600  	ASSERT_EQ (nullptr, node1.block (receive3->hash ())); 
2601  	ASSERT_EQ (nullptr, node1.block (send4->hash ())); 
2602  	ASSERT_EQ (nullptr, node1.block (send5->hash ())); 
2603  }
2604  TEST (node, block_processor_reject_state)
2605  {
2606  	nano::test::system system (1);
2607  	auto & node (*system.nodes[0]);
2608  	nano::state_block_builder builder;
2609  	auto send1 = builder.make_block ()
2610  				 .account (nano::dev::genesis_key.pub)
2611  				 .previous (nano::dev::genesis->hash ())
2612  				 .representative (nano::dev::genesis_key.pub)
2613  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2614  				 .link (nano::dev::genesis_key.pub)
2615  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2616  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2617  				 .build_shared ();
2618  	send1->signature.bytes[0] ^= 1;
2619  	ASSERT_FALSE (node.ledger.block_or_pruned_exists (send1->hash ()));
2620  	node.process_active (send1);
2621  	auto flushed = std::async (std::launch::async, [&node] { node.block_processor.flush (); });
2622  	ASSERT_NE (std::future_status::timeout, flushed.wait_for (5s));
2623  	ASSERT_FALSE (node.ledger.block_or_pruned_exists (send1->hash ()));
2624  	auto send2 = builder.make_block ()
2625  				 .account (nano::dev::genesis_key.pub)
2626  				 .previous (nano::dev::genesis->hash ())
2627  				 .representative (nano::dev::genesis_key.pub)
2628  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2629  				 .link (nano::dev::genesis_key.pub)
2630  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2631  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2632  				 .build_shared ();
2633  	node.process_active (send2);
2634  	auto flushed2 = std::async (std::launch::async, [&node] { node.block_processor.flush (); });
2635  	ASSERT_NE (std::future_status::timeout, flushed2.wait_for (5s));
2636  	ASSERT_TRUE (node.ledger.block_or_pruned_exists (send2->hash ()));
2637  }
2638  TEST (node, block_processor_full)
2639  {
2640  	nano::test::system system;
2641  	nano::node_flags node_flags;
2642  	node_flags.force_use_write_database_queue = true;
2643  	node_flags.block_processor_full_size = 3;
2644  	auto & node = *system.add_node (nano::node_config (system.get_available_port (), system.logging), node_flags);
2645  	nano::state_block_builder builder;
2646  	auto send1 = builder.make_block ()
2647  				 .account (nano::dev::genesis_key.pub)
2648  				 .previous (nano::dev::genesis->hash ())
2649  				 .representative (nano::dev::genesis_key.pub)
2650  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2651  				 .link (nano::dev::genesis_key.pub)
2652  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2653  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2654  				 .build_shared ();
2655  	auto send2 = builder.make_block ()
2656  				 .account (nano::dev::genesis_key.pub)
2657  				 .previous (nano::dev::genesis->hash ())
2658  				 .representative (nano::dev::genesis_key.pub)
2659  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2660  				 .link (nano::dev::genesis_key.pub)
2661  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2662  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2663  				 .build_shared ();
2664  	auto send3 = builder.make_block ()
2665  				 .account (nano::dev::genesis_key.pub)
2666  				 .previous (nano::dev::genesis->hash ())
2667  				 .representative (nano::dev::genesis_key.pub)
2668  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2669  				 .link (nano::dev::genesis_key.pub)
2670  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2671  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2672  				 .build_shared ();
2673  	node.block_processor.stop (); 
2674  	node.block_processor.add (send1);
2675  	ASSERT_FALSE (node.block_processor.full ());
2676  	node.block_processor.add (send2);
2677  	ASSERT_FALSE (node.block_processor.full ());
2678  	node.block_processor.add (send3);
2679  	ASSERT_TIMELY (5s, node.block_processor.full ());
2680  }
2681  TEST (node, block_processor_half_full)
2682  {
2683  	nano::test::system system;
2684  	nano::node_flags node_flags;
2685  	node_flags.block_processor_full_size = 6;
2686  	node_flags.force_use_write_database_queue = true;
2687  	auto & node = *system.add_node (nano::node_config (system.get_available_port (), system.logging), node_flags);
2688  	nano::state_block_builder builder;
2689  	auto send1 = builder.make_block ()
2690  				 .account (nano::dev::genesis_key.pub)
2691  				 .previous (nano::dev::genesis->hash ())
2692  				 .representative (nano::dev::genesis_key.pub)
2693  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2694  				 .link (nano::dev::genesis_key.pub)
2695  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2696  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2697  				 .build_shared ();
2698  	auto send2 = builder.make_block ()
2699  				 .account (nano::dev::genesis_key.pub)
2700  				 .previous (send1->hash ())
2701  				 .representative (nano::dev::genesis_key.pub)
2702  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2703  				 .link (nano::dev::genesis_key.pub)
2704  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2705  				 .work (*node.work_generate_blocking (send1->hash ()))
2706  				 .build_shared ();
2707  	auto send3 = builder.make_block ()
2708  				 .account (nano::dev::genesis_key.pub)
2709  				 .previous (send2->hash ())
2710  				 .representative (nano::dev::genesis_key.pub)
2711  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2712  				 .link (nano::dev::genesis_key.pub)
2713  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2714  				 .work (*node.work_generate_blocking (send2->hash ()))
2715  				 .build_shared ();
2716  	auto write_guard = node.write_database_queue.wait (nano::writer::testing);
2717  	node.block_processor.add (send1);
2718  	ASSERT_FALSE (node.block_processor.half_full ());
2719  	node.block_processor.add (send2);
2720  	ASSERT_FALSE (node.block_processor.half_full ());
2721  	node.block_processor.add (send3);
2722  	ASSERT_TIMELY (2s, node.block_processor.half_full ());
2723  	ASSERT_FALSE (node.block_processor.full ());
2724  }
2725  TEST (node, confirm_back)
2726  {
2727  	nano::test::system system (1);
2728  	nano::keypair key;
2729  	auto & node (*system.nodes[0]);
2730  	auto genesis_start_balance (node.balance (nano::dev::genesis_key.pub));
2731  	auto send1 = nano::send_block_builder ()
2732  				 .previous (nano::dev::genesis->hash ())
2733  				 .destination (key.pub)
2734  				 .balance (genesis_start_balance - 1)
2735  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2736  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2737  				 .build_shared ();
2738  	nano::state_block_builder builder;
2739  	auto open = builder.make_block ()
2740  				.account (key.pub)
2741  				.previous (0)
2742  				.representative (key.pub)
2743  				.balance (1)
2744  				.link (send1->hash ())
2745  				.sign (key.prv, key.pub)
2746  				.work (*system.work.generate (key.pub))
2747  				.build_shared ();
2748  	auto send2 = builder.make_block ()
2749  				 .account (key.pub)
2750  				 .previous (open->hash ())
2751  				 .representative (key.pub)
2752  				 .balance (0)
2753  				 .link (nano::dev::genesis_key.pub)
2754  				 .sign (key.prv, key.pub)
2755  				 .work (*system.work.generate (open->hash ()))
2756  				 .build_shared ();
2757  	node.process_active (send1);
2758  	node.process_active (open);
2759  	node.process_active (send2);
2760  	ASSERT_TIMELY (5s, node.block (send2->hash ()) != nullptr);
2761  	nano::test::start_elections (system, node, { send1, open, send2 });
2762  	ASSERT_EQ (3, node.active.size ());
2763  	std::vector<nano::block_hash> vote_blocks;
2764  	vote_blocks.push_back (send2->hash ());
2765  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, vote_blocks));
2766  	node.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node));
2767  	ASSERT_TIMELY (10s, node.active.empty ());
2768  }
2769  TEST (node, peers)
2770  {
2771  	nano::test::system system (1);
2772  	auto node1 (system.nodes[0]);
2773  	ASSERT_TRUE (node1->network.empty ());
2774  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
2775  	system.nodes.push_back (node2);
2776  	auto endpoint = node1->network.endpoint ();
2777  	nano::endpoint_key endpoint_key{ endpoint.address ().to_v6 ().to_bytes (), endpoint.port () };
2778  	auto & store = node2->store;
2779  	{
2780  		auto transaction (store.tx_begin_write ());
2781  		store.peer.put (transaction, endpoint_key);
2782  		store.peer.put (transaction, nano::endpoint_key{ boost::asio::ip::address_v6::any ().to_bytes (), 55555 });
2783  	}
2784  	node2->start ();
2785  	ASSERT_TIMELY (10s, !node2->network.empty () && !node1->network.empty ())
2786  	ASSERT_TIMELY (10s, node1->tcp_listener.realtime_count != 0 && node2->tcp_listener.realtime_count != 0);
2787  	ASSERT_EQ (1, node1->network.size ());
2788  	auto list1 (node1->network.list (2));
2789  	ASSERT_EQ (node2->get_node_id (), list1[0]->get_node_id ());
2790  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
2791  	ASSERT_EQ (1, node2->network.size ());
2792  	auto list2 (node2->network.list (2));
2793  	ASSERT_EQ (node1->get_node_id (), list2[0]->get_node_id ());
2794  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
2795  	ASSERT_TIMELY_EQ (5s, store.peer.count (store.tx_begin_read ()), 1);
2796  	ASSERT_TRUE (store.peer.exists (store.tx_begin_read (), endpoint_key));
2797  	node1->stop ();
2798  	ASSERT_TIMELY (10s, node2->network.empty ());
2799  }
2800  TEST (node, peer_cache_restart)
2801  {
2802  	nano::test::system system (1);
2803  	auto node1 (system.nodes[0]);
2804  	ASSERT_TRUE (node1->network.empty ());
2805  	auto endpoint = node1->network.endpoint ();
2806  	nano::endpoint_key endpoint_key{ endpoint.address ().to_v6 ().to_bytes (), endpoint.port () };
2807  	auto path (nano::unique_path ());
2808  	{
2809  		auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), path, system.logging, system.work));
2810  		system.nodes.push_back (node2);
2811  		auto & store = node2->store;
2812  		{
2813  			auto transaction (store.tx_begin_write ());
2814  			store.peer.put (transaction, endpoint_key);
2815  		}
2816  		node2->start ();
2817  		ASSERT_TIMELY (10s, !node2->network.empty ());
2818  		auto list (node2->network.list (2));
2819  		ASSERT_EQ (node1->network.endpoint (), list[0]->get_endpoint ());
2820  		ASSERT_EQ (1, node2->network.size ());
2821  		node2->stop ();
2822  	}
2823  	{
2824  		nano::node_flags node_flags;
2825  		node_flags.read_only = true;
2826  		auto node3 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), path, system.logging, system.work, node_flags));
2827  		system.nodes.push_back (node3);
2828  		node3->network.start ();
2829  		node3->add_initial_peers ();
2830  		auto & store = node3->store;
2831  		{
2832  			auto transaction (store.tx_begin_read ());
2833  			ASSERT_EQ (store.peer.count (transaction), 1);
2834  			ASSERT_TRUE (store.peer.exists (transaction, endpoint_key));
2835  		}
2836  		ASSERT_TIMELY (10s, !node3->network.empty ());
2837  		auto list (node3->network.list (2));
2838  		ASSERT_EQ (node1->network.endpoint (), list[0]->get_endpoint ());
2839  		ASSERT_EQ (1, node3->network.size ());
2840  		node3->stop ();
2841  	}
2842  }
2843  TEST (node, unchecked_cleanup)
2844  {
2845  	nano::test::system system{};
2846  	nano::node_flags node_flags{};
2847  	node_flags.disable_unchecked_cleanup = true;
2848  	nano::keypair key{};
2849  	auto & node = *system.add_node (node_flags);
2850  	auto open = nano::state_block_builder ()
2851  				.account (key.pub)
2852  				.previous (0)
2853  				.representative (key.pub)
2854  				.balance (1)
2855  				.link (key.pub)
2856  				.sign (key.prv, key.pub)
2857  				.work (*system.work.generate (key.pub))
2858  				.build_shared ();
2859  	std::vector<uint8_t> bytes;
2860  	{
2861  		nano::vectorstream stream (bytes);
2862  		open->serialize (stream);
2863  	}
2864  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2865  	node.process_active (open);
2866  	ASSERT_TIMELY (15s, 1 == node.unchecked.count ());
2867  	node.config.unchecked_cutoff_time = std::chrono::seconds (2);
2868  	ASSERT_EQ (1, node.unchecked.count ());
2869  	std::this_thread::sleep_for (std::chrono::seconds (1));
2870  	node.unchecked_cleanup ();
2871  	ASSERT_TRUE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2872  	ASSERT_EQ (1, node.unchecked.count ());
2873  	std::this_thread::sleep_for (std::chrono::seconds (2));
2874  	node.unchecked_cleanup ();
2875  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2876  	ASSERT_EQ (0, node.unchecked.count ());
2877  }
2878  TEST (node, dont_write_lock_node)
2879  {
2880  	auto path = nano::unique_path ();
2881  	std::promise<void> write_lock_held_promise;
2882  	std::promise<void> finished_promise;
2883  	std::thread ([&path, &write_lock_held_promise, &finished_promise] () {
2884  		nano::logger_mt logger;
2885  		auto store = nano::make_store (logger, path, nano::dev::constants, false, true);
2886  		{
2887  			nano::ledger_cache ledger_cache;
2888  			auto transaction (store->tx_begin_write ());
2889  			store->initialize (transaction, ledger_cache, nano::dev::constants);
2890  		}
2891  		auto transaction (store->tx_begin_write ());
2892  		write_lock_held_promise.set_value ();
2893  		finished_promise.get_future ().wait ();
2894  	})
2895  	.detach ();
2896  	write_lock_held_promise.get_future ().wait ();
2897  	nano::inactive_node node (path, nano::inactive_node_flag_defaults ());
2898  	finished_promise.set_value ();
2899  }
2900  TEST (node, bidirectional_tcp)
2901  {
2902  #ifdef _WIN32
2903  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2904  	{
2905  		GTEST_SKIP ();
2906  	}
2907  #endif
2908  	nano::test::system system;
2909  	nano::node_flags node_flags;
2910  	node_flags.disable_legacy_bootstrap = true;
2911  	node_flags.disable_lazy_bootstrap = true;
2912  	node_flags.disable_wallet_bootstrap = true;
2913  	nano::node_config node_config (system.get_available_port (), system.logging);
2914  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2915  	auto node1 = system.add_node (node_config, node_flags);
2916  	node_config.peering_port = system.get_available_port ();
2917  	node_config.tcp_incoming_connections_max = 0; 
2918  	auto node2 = system.add_node (node_config, node_flags);
2919  	ASSERT_EQ (1, node1->network.size ());
2920  	ASSERT_EQ (1, node2->network.size ());
2921  	auto list1 (node1->network.list (1));
2922  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
2923  	ASSERT_NE (node2->network.endpoint (), list1[0]->get_endpoint ()); 
2924  	ASSERT_EQ (node2->node_id.pub, list1[0]->get_node_id ());
2925  	auto list2 (node2->network.list (1));
2926  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
2927  	ASSERT_EQ (node1->network.endpoint (), list2[0]->get_endpoint ());
2928  	ASSERT_EQ (node1->node_id.pub, list2[0]->get_node_id ());
2929  	nano::keypair key;
2930  	nano::state_block_builder builder;
2931  	auto send1 = builder.make_block ()
2932  				 .account (nano::dev::genesis_key.pub)
2933  				 .previous (nano::dev::genesis->hash ())
2934  				 .representative (nano::dev::genesis_key.pub)
2935  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2936  				 .link (key.pub)
2937  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2938  				 .work (*node1->work_generate_blocking (nano::dev::genesis->hash ()))
2939  				 .build_shared ();
2940  	node1->process_active (send1);
2941  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send1->hash ()) && node2->ledger.block_or_pruned_exists (send1->hash ()));
2942  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2943  	ASSERT_TIMELY (10s, node2->rep_crawler.representative_count () != 0);
2944  	bool confirmed (false);
2945  	system.deadline_set (10s);
2946  	while (!confirmed)
2947  	{
2948  		auto transaction2 (node2->store.tx_begin_read ());
2949  		confirmed = node2->ledger.block_confirmed (transaction2, send1->hash ());
2950  		ASSERT_NO_ERROR (system.poll ());
2951  	}
2952  	{
2953  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
2954  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
2955  	}
2956  	auto send2 = builder.make_block ()
2957  				 .account (nano::dev::genesis_key.pub)
2958  				 .previous (send1->hash ())
2959  				 .representative (nano::dev::genesis_key.pub)
2960  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2961  				 .link (key.pub)
2962  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2963  				 .work (*node1->work_generate_blocking (send1->hash ()))
2964  				 .build_shared ();
2965  	node2->process_active (send2);
2966  	node2->block_processor.flush ();
2967  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send2->hash ()) && node2->ledger.block_or_pruned_exists (send2->hash ()));
2968  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
2969  	ASSERT_TIMELY (10s, node1->rep_crawler.representative_count () != 0);
2970  	confirmed = false;
2971  	system.deadline_set (20s);
2972  	while (!confirmed)
2973  	{
2974  		auto transaction1 (node1->store.tx_begin_read ());
2975  		confirmed = node1->ledger.block_confirmed (transaction1, send2->hash ());
2976  		ASSERT_NO_ERROR (system.poll ());
2977  	}
2978  }
2979  TEST (node, node_sequence)
2980  {
2981  	nano::test::system system (3);
2982  	ASSERT_EQ (0, system.nodes[0]->node_seq);
2983  	ASSERT_EQ (0, system.nodes[0]->node_seq);
2984  	ASSERT_EQ (1, system.nodes[1]->node_seq);
2985  	ASSERT_EQ (2, system.nodes[2]->node_seq);
2986  }
2987  TEST (node, rollback_vote_self)
2988  {
2989  	nano::test::system system;
2990  	nano::node_flags flags;
2991  	flags.disable_request_loop = true;
2992  	auto & node = *system.add_node (flags);
2993  	nano::state_block_builder builder;
2994  	nano::keypair key;
2995  	auto send1 = builder.make_block ()
2996  				 .account (nano::dev::genesis_key.pub)
2997  				 .previous (nano::dev::genesis->hash ())
2998  				 .representative (nano::dev::genesis_key.pub)
2999  				 .link (key.pub)
3000  				 .balance (nano::dev::constants.genesis_amount - (nano::dev::constants.genesis_amount / 2))
3001  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3002  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3003  				 .build_shared ();
3004  	auto open = builder.make_block ()
3005  				.account (key.pub)
3006  				.previous (0)
3007  				.representative (key.pub)
3008  				.link (send1->hash ())
3009  				.balance (nano::dev::constants.genesis_amount / 2)
3010  				.sign (key.prv, key.pub)
3011  				.work (*system.work.generate (key.pub))
3012  				.build_shared ();
3013  	auto send2 = builder.make_block ()
3014  				 .from (*send1)
3015  				 .previous (send1->hash ())
3016  				 .balance (send1->balance ().number () - 1)
3017  				 .link (nano::dev::genesis_key.pub)
3018  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3019  				 .work (*system.work.generate (send1->hash ()))
3020  				 .build_shared ();
3021  	auto fork = builder.make_block ()
3022  				.from (*send2)
3023  				.balance (send1->balance ().number () - 2)
3024  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3025  				.build_shared ();
3026  	ASSERT_TRUE (nano::test::process (node, { send1, open }));
3027  	ASSERT_TIMELY (5s, nano::test::confirm (node, { send1, open }));
3028  	ASSERT_TIMELY (5s, node.ledger.cache.cemented_count == 3);
3029  	ASSERT_TIMELY_EQ (5s, nano::dev::constants.genesis_amount / 2, node.weight (key.pub));
3030  	node.process_active (send2);
3031  	std::shared_ptr<nano::election> election;
3032  	ASSERT_TIMELY (5s, election = node.active.election (send2->qualified_root ()));
3033  	node.process_active (fork);
3034  	ASSERT_TIMELY_EQ (5s, 2, election->blocks ().size ());
3035  	ASSERT_EQ (election->winner ()->hash (), send2->hash ());
3036  	{
3037  		auto write_guard = node.write_database_queue.wait (nano::writer::testing);
3038  		ASSERT_EQ (0, election->votes_with_weight ().size ());
3039  		election->vote (key.pub, 0, fork->hash ());
3040  		ASSERT_EQ (1, election->votes_with_weight ().size ());
3041  		ASSERT_EQ (election->winner ()->hash (), fork->hash ());
3042  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3043  		ASSERT_TRUE (node.history.votes (send2->root (), send2->hash ()).empty ());
3044  		ASSERT_TRUE (node.history.votes (fork->root (), fork->hash ()).empty ());
3045  		auto channel = std::make_shared<nano::transport::fake::channel> (node);
3046  		node.aggregator.add (channel, { { send2->hash (), send2->root () } });
3047  		ASSERT_TIMELY (5s, !node.history.votes (fork->root (), fork->hash ()).empty ());
3048  		ASSERT_TRUE (node.history.votes (send2->root (), send2->hash ()).empty ());
3049  	}
3050  	auto is_genesis_vote = [] (nano::vote_with_weight_info info) {
3051  		return info.representative == nano::dev::genesis_key.pub;
3052  	};
3053  	ASSERT_TIMELY_EQ (5s, 2, election->votes_with_weight ().size ());
3054  	auto votes_with_weight = election->votes_with_weight ();
3055  	ASSERT_EQ (1, std::count_if (votes_with_weight.begin (), votes_with_weight.end (), is_genesis_vote));
3056  	auto vote = std::find_if (votes_with_weight.begin (), votes_with_weight.end (), is_genesis_vote);
3057  	ASSERT_NE (votes_with_weight.end (), vote);
3058  	ASSERT_EQ (fork->hash (), vote->hash);
3059  }
3060  TEST (node, rollback_gap_source)
3061  {
3062  	nano::test::system system;
3063  	nano::node_config node_config (system.get_available_port (), system.logging);
3064  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3065  	auto & node = *system.add_node (node_config);
3066  	nano::state_block_builder builder;
3067  	nano::keypair key;
3068  	auto send1 = builder.make_block ()
3069  				 .account (nano::dev::genesis_key.pub)
3070  				 .previous (nano::dev::genesis->hash ())
3071  				 .representative (nano::dev::genesis_key.pub)
3072  				 .link (key.pub)
3073  				 .balance (nano::dev::constants.genesis_amount - 1)
3074  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3075  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3076  				 .build_shared ();
3077  	auto fork1a = builder.make_block ()
3078  				  .account (key.pub)
3079  				  .previous (0)
3080  				  .representative (key.pub)
3081  				  .link (send1->hash ())
3082  				  .balance (1)
3083  				  .sign (key.prv, key.pub)
3084  				  .work (*system.work.generate (key.pub))
3085  				  .build_shared ();
3086  	auto send2 = builder.make_block ()
3087  				 .from (*send1)
3088  				 .previous (send1->hash ())
3089  				 .balance (send1->balance ().number () - 1)
3090  				 .link (key.pub)
3091  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3092  				 .work (*system.work.generate (send1->hash ()))
3093  				 .build_shared ();
3094  	auto fork1b = builder.make_block ()
3095  				  .from (*fork1a)
3096  				  .link (send2->hash ())
3097  				  .sign (key.prv, key.pub)
3098  				  .build_shared ();
3099  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
3100  	ASSERT_EQ (nano::process_result::progress, node.process (*fork1a).code);
3101  	ASSERT_EQ (nullptr, node.block (send2->hash ()));
3102  	node.block_processor.force (fork1b);
3103  	ASSERT_TIMELY (5s, node.block (fork1a->hash ()) == nullptr);
3104  	ASSERT_TIMELY (5s, node.stats.count (nano::stat::type::rollback, nano::stat::detail::open) == 1);
3105  	ASSERT_EQ (nullptr, node.block (fork1b->hash ()));
3106  	node.process_active (fork1a);
3107  	ASSERT_TIMELY (5s, node.block (fork1a->hash ()) != nullptr);
3108  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
3109  	node.block_processor.force (fork1b);
3110  	ASSERT_TIMELY (5s, node.stats.count (nano::stat::type::rollback, nano::stat::detail::open) == 2);
3111  	ASSERT_TIMELY (5s, node.block (fork1b->hash ()) != nullptr);
3112  	ASSERT_EQ (nullptr, node.block (fork1a->hash ()));
3113  }
3114  TEST (node, dependency_graph)
3115  {
3116  	nano::test::system system;
3117  	nano::node_config config (system.get_available_port (), system.logging);
3118  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3119  	auto & node = *system.add_node (config);
3120  	nano::state_block_builder builder;
3121  	nano::keypair key1, key2, key3;
3122  	auto gen_send1 = builder.make_block ()
3123  					 .account (nano::dev::genesis_key.pub)
3124  					 .previous (nano::dev::genesis->hash ())
3125  					 .representative (nano::dev::genesis_key.pub)
3126  					 .link (key1.pub)
3127  					 .balance (nano::dev::constants.genesis_amount - 1)
3128  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3129  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
3130  					 .build_shared ();
3131  	auto key1_open = builder.make_block ()
3132  					 .account (key1.pub)
3133  					 .previous (0)
3134  					 .representative (key1.pub)
3135  					 .link (gen_send1->hash ())
3136  					 .balance (1)
3137  					 .sign (key1.prv, key1.pub)
3138  					 .work (*system.work.generate (key1.pub))
3139  					 .build ();
3140  	auto key1_send1 = builder.make_block ()
3141  					  .account (key1.pub)
3142  					  .previous (key1_open->hash ())
3143  					  .representative (key1.pub)
3144  					  .link (nano::dev::genesis_key.pub)
3145  					  .balance (0)
3146  					  .sign (key1.prv, key1.pub)
3147  					  .work (*system.work.generate (key1_open->hash ()))
3148  					  .build ();
3149  	auto gen_receive = builder.make_block ()
3150  					   .from (*gen_send1)
3151  					   .previous (gen_send1->hash ())
3152  					   .link (key1_send1->hash ())
3153  					   .balance (nano::dev::constants.genesis_amount)
3154  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3155  					   .work (*system.work.generate (gen_send1->hash ()))
3156  					   .build ();
3157  	auto gen_send2 = builder.make_block ()
3158  					 .from (*gen_receive)
3159  					 .previous (gen_receive->hash ())
3160  					 .link (key2.pub)
3161  					 .balance (gen_receive->balance ().number () - 2)
3162  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3163  					 .work (*system.work.generate (gen_receive->hash ()))
3164  					 .build ();
3165  	auto key2_open = builder.make_block ()
3166  					 .account (key2.pub)
3167  					 .previous (0)
3168  					 .representative (key2.pub)
3169  					 .link (gen_send2->hash ())
3170  					 .balance (2)
3171  					 .sign (key2.prv, key2.pub)
3172  					 .work (*system.work.generate (key2.pub))
3173  					 .build ();
3174  	auto key2_send1 = builder.make_block ()
3175  					  .account (key2.pub)
3176  					  .previous (key2_open->hash ())
3177  					  .representative (key2.pub)
3178  					  .link (key3.pub)
3179  					  .balance (1)
3180  					  .sign (key2.prv, key2.pub)
3181  					  .work (*system.work.generate (key2_open->hash ()))
3182  					  .build ();
3183  	auto key3_open = builder.make_block ()
3184  					 .account (key3.pub)
3185  					 .previous (0)
3186  					 .representative (key3.pub)
3187  					 .link (key2_send1->hash ())
3188  					 .balance (1)
3189  					 .sign (key3.prv, key3.pub)
3190  					 .work (*system.work.generate (key3.pub))
3191  					 .build ();
3192  	auto key2_send2 = builder.make_block ()
3193  					  .from (*key2_send1)
3194  					  .previous (key2_send1->hash ())
3195  					  .link (key1.pub)
3196  					  .balance (key2_send1->balance ().number () - 1)
3197  					  .sign (key2.prv, key2.pub)
3198  					  .work (*system.work.generate (key2_send1->hash ()))
3199  					  .build ();
3200  	auto key1_receive = builder.make_block ()
3201  						.from (*key1_send1)
3202  						.previous (key1_send1->hash ())
3203  						.link (key2_send2->hash ())
3204  						.balance (key1_send1->balance ().number () + 1)
3205  						.sign (key1.prv, key1.pub)
3206  						.work (*system.work.generate (key1_send1->hash ()))
3207  						.build ();
3208  	auto key1_send2 = builder.make_block ()
3209  					  .from (*key1_receive)
3210  					  .previous (key1_receive->hash ())
3211  					  .link (key3.pub)
3212  					  .balance (key1_receive->balance ().number () - 1)
3213  					  .sign (key1.prv, key1.pub)
3214  					  .work (*system.work.generate (key1_receive->hash ()))
3215  					  .build ();
3216  	auto key3_receive = builder.make_block ()
3217  						.from (*key3_open)
3218  						.previous (key3_open->hash ())
3219  						.link (key1_send2->hash ())
3220  						.balance (key3_open->balance ().number () + 1)
3221  						.sign (key3.prv, key3.pub)
3222  						.work (*system.work.generate (key3_open->hash ()))
3223  						.build ();
3224  	auto key3_epoch = builder.make_block ()
3225  					  .from (*key3_receive)
3226  					  .previous (key3_receive->hash ())
3227  					  .link (node.ledger.epoch_link (nano::epoch::epoch_1))
3228  					  .balance (key3_receive->balance ())
3229  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3230  					  .work (*system.work.generate (key3_receive->hash ()))
3231  					  .build ();
3232  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_send1).code);
3233  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_open).code);
3234  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_send1).code);
3235  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_receive).code);
3236  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_send2).code);
3237  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_open).code);
3238  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_send1).code);
3239  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_open).code);
3240  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_send2).code);
3241  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_receive).code);
3242  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_send2).code);
3243  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_receive).code);
3244  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_epoch).code);
3245  	ASSERT_TRUE (node.active.empty ());
3246  	std::unordered_map<nano::block_hash, std::vector<nano::block_hash>> dependency_graph{
3247  		{ key1_open->hash (), { gen_send1->hash () } },
3248  		{ key1_send1->hash (), { key1_open->hash () } },
3249  		{ gen_receive->hash (), { gen_send1->hash (), key1_open->hash () } },
3250  		{ gen_send2->hash (), { gen_receive->hash () } },
3251  		{ key2_open->hash (), { gen_send2->hash () } },
3252  		{ key2_send1->hash (), { key2_open->hash () } },
3253  		{ key3_open->hash (), { key2_send1->hash () } },
3254  		{ key2_send2->hash (), { key2_send1->hash () } },
3255  		{ key1_receive->hash (), { key1_send1->hash (), key2_send2->hash () } },
3256  		{ key1_send2->hash (), { key1_send1->hash () } },
3257  		{ key3_receive->hash (), { key3_open->hash (), key1_send2->hash () } },
3258  		{ key3_epoch->hash (), { key3_receive->hash () } },
3259  	};
3260  	ASSERT_EQ (node.ledger.cache.block_count - 2, dependency_graph.size ());
3261  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3262  	node.block_confirm (gen_send1);
3263  	ASSERT_NO_ERROR (system.poll_until_true (15s, [&] {
3264  		EXPECT_LT (node.active.size (), 6);
3265  		auto error = std::any_of (dependency_graph.cbegin (), dependency_graph.cend (), [&] (auto entry) {
3266  			if (node.active.active (entry.first))
3267  			{
3268  				for (auto ancestor : entry.second)
3269  				{
3270  					if (!node.block_confirmed (ancestor))
3271  					{
3272  						return true;
3273  					}
3274  				}
3275  			}
3276  			return false;
3277  		});
3278  		EXPECT_FALSE (error);
3279  		return error || node.ledger.cache.cemented_count == node.ledger.cache.block_count;
3280  	}));
3281  	ASSERT_EQ (node.ledger.cache.cemented_count, node.ledger.cache.block_count);
3282  	ASSERT_TIMELY (5s, node.active.empty ());
3283  }
3284  TEST (node, dependency_graph_frontier)
3285  {
3286  	nano::test::system system;
3287  	nano::node_config config (system.get_available_port (), system.logging);
3288  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3289  	auto & node1 = *system.add_node (config);
3290  	config.peering_port = system.get_available_port ();
3291  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::always;
3292  	auto & node2 = *system.add_node (config);
3293  	nano::state_block_builder builder;
3294  	nano::keypair key1, key2, key3;
3295  	auto gen_send1 = builder.make_block ()
3296  					 .account (nano::dev::genesis_key.pub)
3297  					 .previous (nano::dev::genesis->hash ())
3298  					 .representative (nano::dev::genesis_key.pub)
3299  					 .link (key1.pub)
3300  					 .balance (nano::dev::constants.genesis_amount - 1)
3301  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3302  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
3303  					 .build_shared ();
3304  	auto key1_open = builder.make_block ()
3305  					 .account (key1.pub)
3306  					 .previous (0)
3307  					 .representative (key1.pub)
3308  					 .link (gen_send1->hash ())
3309  					 .balance (1)
3310  					 .sign (key1.prv, key1.pub)
3311  					 .work (*system.work.generate (key1.pub))
3312  					 .build ();
3313  	auto key1_send1 = builder.make_block ()
3314  					  .account (key1.pub)
3315  					  .previous (key1_open->hash ())
3316  					  .representative (key1.pub)
3317  					  .link (nano::dev::genesis_key.pub)
3318  					  .balance (0)
3319  					  .sign (key1.prv, key1.pub)
3320  					  .work (*system.work.generate (key1_open->hash ()))
3321  					  .build ();
3322  	auto gen_receive = builder.make_block ()
3323  					   .from (*gen_send1)
3324  					   .previous (gen_send1->hash ())
3325  					   .link (key1_send1->hash ())
3326  					   .balance (nano::dev::constants.genesis_amount)
3327  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3328  					   .work (*system.work.generate (gen_send1->hash ()))
3329  					   .build ();
3330  	auto gen_send2 = builder.make_block ()
3331  					 .from (*gen_receive)
3332  					 .previous (gen_receive->hash ())
3333  					 .link (key2.pub)
3334  					 .balance (gen_receive->balance ().number () - 2)
3335  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3336  					 .work (*system.work.generate (gen_receive->hash ()))
3337  					 .build ();
3338  	auto key2_open = builder.make_block ()
3339  					 .account (key2.pub)
3340  					 .previous (0)
3341  					 .representative (key2.pub)
3342  					 .link (gen_send2->hash ())
3343  					 .balance (2)
3344  					 .sign (key2.prv, key2.pub)
3345  					 .work (*system.work.generate (key2.pub))
3346  					 .build ();
3347  	auto key2_send1 = builder.make_block ()
3348  					  .account (key2.pub)
3349  					  .previous (key2_open->hash ())
3350  					  .representative (key2.pub)
3351  					  .link (key3.pub)
3352  					  .balance (1)
3353  					  .sign (key2.prv, key2.pub)
3354  					  .work (*system.work.generate (key2_open->hash ()))
3355  					  .build ();
3356  	auto key3_open = builder.make_block ()
3357  					 .account (key3.pub)
3358  					 .previous (0)
3359  					 .representative (key3.pub)
3360  					 .link (key2_send1->hash ())
3361  					 .balance (1)
3362  					 .sign (key3.prv, key3.pub)
3363  					 .work (*system.work.generate (key3.pub))
3364  					 .build ();
3365  	auto key2_send2 = builder.make_block ()
3366  					  .from (*key2_send1)
3367  					  .previous (key2_send1->hash ())
3368  					  .link (key1.pub)
3369  					  .balance (key2_send1->balance ().number () - 1)
3370  					  .sign (key2.prv, key2.pub)
3371  					  .work (*system.work.generate (key2_send1->hash ()))
3372  					  .build ();
3373  	auto key1_receive = builder.make_block ()
3374  						.from (*key1_send1)
3375  						.previous (key1_send1->hash ())
3376  						.link (key2_send2->hash ())
3377  						.balance (key1_send1->balance ().number () + 1)
3378  						.sign (key1.prv, key1.pub)
3379  						.work (*system.work.generate (key1_send1->hash ()))
3380  						.build ();
3381  	auto key1_send2 = builder.make_block ()
3382  					  .from (*key1_receive)
3383  					  .previous (key1_receive->hash ())
3384  					  .link (key3.pub)
3385  					  .balance (key1_receive->balance ().number () - 1)
3386  					  .sign (key1.prv, key1.pub)
3387  					  .work (*system.work.generate (key1_receive->hash ()))
3388  					  .build ();
3389  	auto key3_receive = builder.make_block ()
3390  						.from (*key3_open)
3391  						.previous (key3_open->hash ())
3392  						.link (key1_send2->hash ())
3393  						.balance (key3_open->balance ().number () + 1)
3394  						.sign (key3.prv, key3.pub)
3395  						.work (*system.work.generate (key3_open->hash ()))
3396  						.build ();
3397  	auto key3_epoch = builder.make_block ()
3398  					  .from (*key3_receive)
3399  					  .previous (key3_receive->hash ())
3400  					  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
3401  					  .balance (key3_receive->balance ())
3402  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3403  					  .work (*system.work.generate (key3_receive->hash ()))
3404  					  .build ();
3405  	for (auto const & node : system.nodes)
3406  	{
3407  		auto transaction (node->store.tx_begin_write ());
3408  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_send1).code);
3409  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_open).code);
3410  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_send1).code);
3411  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_receive).code);
3412  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_send2).code);
3413  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_open).code);
3414  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_send1).code);
3415  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_open).code);
3416  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_send2).code);
3417  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_receive).code);
3418  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_send2).code);
3419  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_receive).code);
3420  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_epoch).code);
3421  	}
3422  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3423  	ASSERT_TIMELY (10s, node2.active.active (gen_send1->qualified_root ()));
3424  	node1.block_confirm (gen_send1);
3425  	ASSERT_TIMELY (15s, node1.ledger.cache.cemented_count == node1.ledger.cache.block_count);
3426  	ASSERT_TIMELY (15s, node2.ledger.cache.cemented_count == node2.ledger.cache.block_count);
3427  }
3428  namespace nano
3429  {
3430  TEST (node, deferred_dependent_elections)
3431  {
3432  	nano::test::system system;
3433  	nano::node_config node_config_1{ system.get_available_port (), system.logging };
3434  	node_config_1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3435  	nano::node_config node_config_2{ system.get_available_port (), system.logging };
3436  	node_config_2.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3437  	nano::node_flags flags;
3438  	flags.disable_request_loop = true;
3439  	auto & node = *system.add_node (node_config_1, flags);
3440  	auto & node2 = *system.add_node (node_config_2, flags); 
3441  	nano::state_block_builder builder;
3442  	nano::keypair key;
3443  	auto send1 = builder.make_block ()
3444  				 .account (nano::dev::genesis_key.pub)
3445  				 .previous (nano::dev::genesis->hash ())
3446  				 .representative (nano::dev::genesis_key.pub)
3447  				 .link (key.pub)
3448  				 .balance (nano::dev::constants.genesis_amount - 1)
3449  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3450  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3451  				 .build_shared ();
3452  	auto open = builder.make_block ()
3453  				.account (key.pub)
3454  				.previous (0)
3455  				.representative (key.pub)
3456  				.link (send1->hash ())
3457  				.balance (1)
3458  				.sign (key.prv, key.pub)
3459  				.work (*system.work.generate (key.pub))
3460  				.build_shared ();
3461  	auto send2 = builder.make_block ()
3462  				 .from (*send1)
3463  				 .previous (send1->hash ())
3464  				 .balance (send1->balance ().number () - 1)
3465  				 .link (key.pub)
3466  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3467  				 .work (*system.work.generate (send1->hash ()))
3468  				 .build_shared ();
3469  	auto receive = builder.make_block ()
3470  				   .from (*open)
3471  				   .previous (open->hash ())
3472  				   .link (send2->hash ())
3473  				   .balance (2)
3474  				   .sign (key.prv, key.pub)
3475  				   .work (*system.work.generate (open->hash ()))
3476  				   .build_shared ();
3477  	auto fork = builder.make_block ()
3478  				.from (*receive)
3479  				.representative (nano::dev::genesis_key.pub) 
3480  				.sign (key.prv, key.pub)
3481  				.build_shared ();
3482  	nano::test::process (node, { send1 });
3483  	auto election_send1 = nano::test::start_election (system, node, send1->hash ());
3484  	ASSERT_NE (nullptr, election_send1);
3485  	nano::test::process (node, { open, send2 });
3486  	ASSERT_TIMELY (5s, node.block (open->hash ()));
3487  	ASSERT_TIMELY (5s, node.block (send2->hash ()));
3488  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()) || node.active.active (send2->qualified_root ()));
3489  	ASSERT_TIMELY (5s, node2.block (open->hash ()));
3490  	ASSERT_TIMELY (5s, node2.block (send2->hash ()));
3491  	node.work_generate_blocking (*open, nano::dev::network_params.work.difficulty (*open) + 1);
3492  	node.process_local (open);
3493  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()));
3494  	ASSERT_TRUE (nano::test::start_election (system, node, open->hash ()));
3495  	node.active.erase (*open);
3496  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3497  	node.work_generate_blocking (*open, nano::dev::network_params.work.difficulty (*open) + 1);
3498  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3499  	node.process_local (open);
3500  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()));
3501  	node.active.erase (*open);
3502  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3503  	node.active.erase (*send2);
3504  	ASSERT_FALSE (node.active.active (send2->qualified_root ()));
3505  	election_send1->force_confirm ();
3506  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
3507  	ASSERT_TIMELY (5s, node.active.active (open->qualified_root ()));
3508  	ASSERT_TIMELY (5s, node.active.active (send2->qualified_root ()));
3509  	auto election_open = node.active.election (open->qualified_root ());
3510  	ASSERT_NE (nullptr, election_open);
3511  	auto election_send2 = node.active.election (send2->qualified_root ());
3512  	ASSERT_NE (nullptr, election_open);
3513  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
3514  	ASSERT_FALSE (node.active.active (receive->qualified_root ()));
3515  	election_open->force_confirm ();
3516  	ASSERT_TIMELY (5s, node.block_confirmed (open->hash ()));
3517  	ASSERT_FALSE (node.ledger.dependents_confirmed (node.store.tx_begin_read (), *receive));
3518  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3519  	ASSERT_FALSE (node.ledger.rollback (node.store.tx_begin_write (), receive->hash ()));
3520  	ASSERT_FALSE (node.block (receive->hash ()));
3521  	node.process_local (receive);
3522  	ASSERT_TIMELY (5s, node.block (receive->hash ()));
<span onclick='openModal()' class='match'>3523  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3524  	ASSERT_EQ (nano::process_result::fork, node.process (*fork).code);
</span>3525  	node.process_local (fork);
3526  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3527  	election_send2->force_confirm ();
3528  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
3529  	ASSERT_TIMELY (5s, node.active.active (receive->qualified_root ()));
3530  }
3531  }
3532  TEST (rep_crawler, recently_confirmed)
3533  {
3534  	nano::test::system system (1);
3535  	auto & node1 (*system.nodes[0]);
3536  	ASSERT_EQ (1, node1.ledger.cache.block_count);
3537  	auto const block = nano::dev::genesis;
3538  	node1.active.recently_confirmed.put (block->qualified_root (), block->hash ());
3539  	auto & node2 (*system.add_node ());
3540  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
3541  	auto channel = node1.network.find_node_id (node2.get_node_id ());
3542  	ASSERT_NE (nullptr, channel);
3543  	node1.rep_crawler.query (channel);
3544  	ASSERT_TIMELY (3s, node1.rep_crawler.representative_count () == 1);
3545  }
3546  namespace nano
3547  {
3548  TEST (rep_crawler, local)
3549  {
3550  	nano::test::system system;
3551  	nano::node_flags flags;
3552  	flags.disable_rep_crawler = true;
3553  	auto & node = *system.add_node (flags);
3554  	auto loopback = std::make_shared<nano::transport::inproc::channel> (node, node);
3555  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector{ nano::dev::genesis->hash () });
3556  	{
3557  		nano::lock_guard<nano::mutex> guard{ node.rep_crawler.probable_reps_mutex };
3558  		node.rep_crawler.active.insert (nano::dev::genesis->hash ());
3559  		node.rep_crawler.responses.emplace_back (loopback, vote);
3560  	}
3561  	node.rep_crawler.validate ();
3562  	ASSERT_EQ (0, node.rep_crawler.representative_count ());
3563  }
3564  }
3565  TEST (node, pruning_automatic)
3566  {
3567  	nano::test::system system{};
3568  	nano::node_config node_config{ system.get_available_port (), system.logging };
3569  	node_config.enable_voting = false;
3570  	node_config.max_pruning_age = std::chrono::seconds (1);
3571  	nano::node_flags node_flags{};
3572  	node_flags.enable_pruning = true;
3573  	auto & node1 = *system.add_node (node_config, node_flags);
3574  	nano::keypair key1{};
3575  	nano::send_block_builder builder{};
3576  	auto latest_hash = nano::dev::genesis->hash ();
3577  	auto send1 = builder.make_block ()
3578  				 .previous (latest_hash)
3579  				 .destination (key1.pub)
3580  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3581  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3582  				 .work (*system.work.generate (latest_hash))
3583  				 .build_shared ();
3584  	node1.process_active (send1);
3585  	latest_hash = send1->hash ();
3586  	auto send2 = builder.make_block ()
3587  				 .previous (latest_hash)
3588  				 .destination (key1.pub)
3589  				 .balance (0)
3590  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3591  				 .work (*system.work.generate (latest_hash))
3592  				 .build_shared ();
3593  	node1.process_active (send2);
3594  	ASSERT_TIMELY (5s, node1.block (send2->hash ()) != nullptr);
3595  	node1.process_confirmed (nano::election_status{ send1 });
3596  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3597  	node1.process_confirmed (nano::election_status{ send2 });
3598  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3599  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3600  	ASSERT_TIMELY (5s, node1.ledger.cache.pruned_count == 1);
3601  	ASSERT_TIMELY (5s, node1.store.pruned.count (node1.store.tx_begin_read ()) == 1);
3602  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3603  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3604  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3605  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3606  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3607  }
3608  TEST (node, pruning_age)
3609  {
3610  	nano::test::system system{};
3611  	nano::node_config node_config{ system.get_available_port (), system.logging };
3612  	node_config.enable_voting = false;
3613  	nano::node_flags node_flags{};
3614  	node_flags.enable_pruning = true;
3615  	auto & node1 = *system.add_node (node_config, node_flags);
3616  	nano::keypair key1{};
3617  	nano::send_block_builder builder{};
3618  	auto latest_hash = nano::dev::genesis->hash ();
3619  	auto send1 = builder.make_block ()
3620  				 .previous (latest_hash)
3621  				 .destination (key1.pub)
3622  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3623  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3624  				 .work (*system.work.generate (latest_hash))
3625  				 .build_shared ();
3626  	node1.process_active (send1);
3627  	latest_hash = send1->hash ();
3628  	auto send2 = builder.make_block ()
3629  				 .previous (latest_hash)
3630  				 .destination (key1.pub)
3631  				 .balance (0)
3632  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3633  				 .work (*system.work.generate (latest_hash))
3634  				 .build_shared ();
3635  	node1.process_active (send2);
3636  	node1.process_confirmed (nano::election_status{ send1 });
3637  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3638  	node1.process_confirmed (nano::election_status{ send2 });
3639  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3640  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3641  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3642  	node1.ledger_pruning (1, true, false);
3643  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3644  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3645  	node1.config.max_pruning_age = std::chrono::seconds{ 0 };
3646  	node1.ledger_pruning (1, true, false);
3647  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3648  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3649  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3650  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3651  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3652  }
3653  TEST (node, pruning_depth)
3654  {
3655  	nano::test::system system{};
3656  	nano::node_config node_config{ system.get_available_port (), system.logging };
3657  	node_config.enable_voting = false;
3658  	nano::node_flags node_flags{};
3659  	node_flags.enable_pruning = true;
3660  	auto & node1 = *system.add_node (node_config, node_flags);
3661  	nano::keypair key1{};
3662  	nano::send_block_builder builder{};
3663  	auto latest_hash = nano::dev::genesis->hash ();
3664  	auto send1 = builder.make_block ()
3665  				 .previous (latest_hash)
3666  				 .destination (key1.pub)
3667  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3668  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3669  				 .work (*system.work.generate (latest_hash))
3670  				 .build_shared ();
3671  	node1.process_active (send1);
3672  	latest_hash = send1->hash ();
3673  	auto send2 = builder.make_block ()
3674  				 .previous (latest_hash)
3675  				 .destination (key1.pub)
3676  				 .balance (0)
3677  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3678  				 .work (*system.work.generate (latest_hash))
3679  				 .build_shared ();
3680  	node1.process_active (send2);
3681  	node1.process_confirmed (nano::election_status{ send1 });
3682  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3683  	node1.process_confirmed (nano::election_status{ send2 });
3684  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3685  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3686  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3687  	node1.ledger_pruning (1, true, false);
3688  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3689  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3690  	node1.config.max_pruning_depth = 1;
3691  	node1.ledger_pruning (1, true, false);
3692  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3693  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3694  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3695  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3696  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3697  }
3698  TEST (node_config, node_id_private_key_persistence)
3699  {
3700  	nano::logger_mt logger;
3701  	auto path = nano::unique_path ();
3702  	ASSERT_TRUE (boost::filesystem::create_directories (path));
3703  	auto priv_key_filename = path / "node_id_private.key";
3704  	nano::keypair kp1 = nano::load_or_create_node_id (path, logger);
3705  	boost::filesystem::remove (priv_key_filename);
3706  	nano::keypair kp2 = nano::load_or_create_node_id (path, logger);
3707  	ASSERT_NE (kp1.prv, kp2.prv);
3708  	nano::keypair kp3 = nano::load_or_create_node_id (path, logger);
3709  	ASSERT_EQ (kp2.prv, kp3.prv);
3710  	std::ofstream ofs (priv_key_filename.string (), std::ofstream::out | std::ofstream::trunc);
3711  	ofs << "3F28D035B8AA75EA53DF753BFD065CF6138E742971B2C99B84FD8FE328FED2D9" << std::flush;
3712  	ofs.close ();
3713  	nano::keypair kp4 = nano::load_or_create_node_id (path, logger);
3714  	ASSERT_EQ (kp4.prv, nano::keypair ("3F28D035B8AA75EA53DF753BFD065CF6138E742971B2C99B84FD8FE328FED2D9").prv);
3715  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.cpp</h3>
            <pre><code>1  #include <nano/lib/jsonconfig.hpp>
2  #include <nano/node/election.hpp>
3  #include <nano/node/scheduler/buckets.hpp>
4  #include <nano/node/scheduler/component.hpp>
5  #include <nano/node/transport/inproc.hpp>
6  #include <nano/test_common/chains.hpp>
7  #include <nano/test_common/system.hpp>
8  #include <nano/test_common/testutil.hpp>
9  #include <gtest/gtest.h>
10  #include <numeric>
11  using namespace std::chrono_literals;
12  namespace nano
13  {
14  TEST (active_transactions, confirm_election_by_request)
15  {
16  	nano::test::system system{};
17  	auto & node1 = *system.add_node ();
18  	nano::state_block_builder builder{};
19  	auto send1 = builder
20  				 .account (nano::dev::genesis_key.pub)
21  				 .representative (nano::dev::genesis_key.pub)
22  				 .previous (nano::dev::genesis->hash ())
23  				 .link (nano::public_key ())
24  				 .balance (nano::dev::constants.genesis_amount - 100)
25  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
26  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
27  				 .build_shared ();
28  	ASSERT_TRUE (nano::test::process (node1, { send1 }));
29  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
30  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { send1 }));
31  	ASSERT_TIMELY (5s, node1.active.empty ());
32  	WAIT (1s);
33  	nano::node_flags node_flags2{};
34  	node_flags2.disable_rep_crawler = true;
35  	auto & node2 = *system.add_node (node_flags2);
36  	node2.process_active (send1);
37  	std::shared_ptr<nano::election> election{};
38  	ASSERT_TIMELY (5s, (election = node2.active.election (send1->qualified_root ())) != nullptr);
39  	WAIT (1s);
40  	ASSERT_FALSE (election->confirmed ());
41  	ASSERT_EQ (0, election->confirmation_request_count);
42  	auto const peers = node2.network.random_set (1);
43  	ASSERT_FALSE (peers.empty ());
44  	{
45  		nano::lock_guard<nano::mutex> guard (node2.rep_crawler.probable_reps_mutex);
46  		node2.rep_crawler.probable_reps.emplace (nano::dev::genesis_key.pub, *peers.cbegin ());
47  	}
48  	ASSERT_TIMELY (5s, election->votes ().size () >= 1);
49  	ASSERT_TIMELY (5s, election->confirmation_request_count >= 1);
50  	ASSERT_TIMELY (5s, election->confirmed ());
51  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { send1 }));
52  	ASSERT_TIMELY (5s, nano::test::confirmed (node2, { send1 }));
53  }
54  }
55  namespace nano
56  {
57  TEST (active_transactions, confirm_frontier)
58  {
59  	nano::test::system system;
60  	nano::node_flags node_flags;
61  	node_flags.disable_request_loop = true;
62  	auto & node1 = *system.add_node (node_flags);
63  	nano::node_flags node_flags2;
64  	node_flags2.disable_rep_crawler = true;
65  	auto & node2 = *system.add_node (node_flags2);
66  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
67  	auto peers (node2.network.random_set (1));
68  	ASSERT_FALSE (peers.empty ());
69  	{
70  		nano::lock_guard<nano::mutex> guard (node2.rep_crawler.probable_reps_mutex);
71  		node2.rep_crawler.probable_reps.emplace (nano::dev::genesis_key.pub, *peers.begin ());
72  	}
73  	nano::state_block_builder builder;
74  	auto send = builder
75  				.account (nano::dev::genesis_key.pub)
76  				.previous (nano::dev::genesis->hash ())
77  				.representative (nano::dev::genesis_key.pub)
78  				.balance (nano::dev::constants.genesis_amount - 100)
79  				.link (nano::public_key ())
80  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
81  				.work (*system.work.generate (nano::dev::genesis->hash ()))
82  				.build_shared ();
83  	auto send_copy = builder.make_block ().from (*send).build_shared ();
84  	ASSERT_EQ (nano::process_result::progress, node1.process (*send).code);
85  	node1.confirmation_height_processor.add (send);
86  	ASSERT_TIMELY (5s, node1.ledger.block_confirmed (node1.store.tx_begin_read (), send->hash ()));
87  	ASSERT_EQ (nano::process_result::progress, node2.process (*send_copy).code);
88  	ASSERT_TIMELY (5s, !node2.active.empty ());
89  	auto election2 = node2.active.election (send->qualified_root ());
90  	ASSERT_NE (nullptr, election2);
91  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 2 && node2.active.empty ());
92  	ASSERT_GT (election2->confirmation_request_count, 0u);
93  }
94  }
95  TEST (active_transactions, keep_local)
96  {
97  	nano::test::system system{};
98  	nano::node_config node_config = system.default_config ();
99  	node_config.enable_voting = false;
100  	node_config.active_elections_size = 2;
101  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
102  	auto & node = *system.add_node (node_config);
103  	auto & wallet (*system.wallet (0));
104  	nano::keypair key1{};
105  	nano::keypair key2{};
106  	nano::keypair key3{};
107  	nano::keypair key4{};
108  	nano::keypair key5{};
109  	nano::keypair key6{};
110  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
111  	auto const send1 = wallet.send_action (nano::dev::genesis_key.pub, key1.pub, node.config.receive_minimum.number ());
112  	auto const send2 = wallet.send_action (nano::dev::genesis_key.pub, key2.pub, node.config.receive_minimum.number ());
113  	auto const send3 = wallet.send_action (nano::dev::genesis_key.pub, key3.pub, node.config.receive_minimum.number ());
114  	auto const send4 = wallet.send_action (nano::dev::genesis_key.pub, key4.pub, node.config.receive_minimum.number ());
115  	auto const send5 = wallet.send_action (nano::dev::genesis_key.pub, key5.pub, node.config.receive_minimum.number ());
116  	auto const send6 = wallet.send_action (nano::dev::genesis_key.pub, key6.pub, node.config.receive_minimum.number ());
117  	for (auto const & block : { send1, send2, send3, send4, send5, send6 })
118  	{
119  		std::shared_ptr<nano::election> election{};
120  		ASSERT_TIMELY (5s, (election = node.active.election (block->qualified_root ())) != nullptr);
121  		node.process_confirmed (nano::election_status{ block });
122  		election->force_confirm ();
123  		ASSERT_TIMELY (5s, node.block_confirmed (block->hash ()));
124  	}
125  	nano::state_block_builder builder{};
126  	const auto receive1 = builder.make_block ()
127  						  .account (key1.pub)
128  						  .previous (0)
129  						  .representative (key1.pub)
130  						  .balance (node.config.receive_minimum.number ())
131  						  .link (send1->hash ())
132  						  .sign (key1.prv, key1.pub)
133  						  .work (*system.work.generate (key1.pub))
134  						  .build_shared ();
135  	const auto receive2 = builder.make_block ()
136  						  .account (key2.pub)
137  						  .previous (0)
138  						  .representative (key2.pub)
139  						  .balance (node.config.receive_minimum.number ())
140  						  .link (send2->hash ())
141  						  .sign (key2.prv, key2.pub)
142  						  .work (*system.work.generate (key2.pub))
143  						  .build_shared ();
144  	const auto receive3 = builder.make_block ()
145  						  .account (key3.pub)
146  						  .previous (0)
147  						  .representative (key3.pub)
148  						  .balance (node.config.receive_minimum.number ())
149  						  .link (send3->hash ())
150  						  .sign (key3.prv, key3.pub)
151  						  .work (*system.work.generate (key3.pub))
152  						  .build_shared ();
153  	node.process_active (receive1);
154  	node.process_active (receive2);
155  	node.process_active (receive3);
156  	ASSERT_TIMELY (5s, node.active.size () == node_config.active_elections_size);
157  }
158  TEST (active_transactions, inactive_votes_cache)
159  {
160  	nano::test::system system (1);
161  	auto & node = *system.nodes[0];
162  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
163  	nano::keypair key;
164  	auto send = nano::send_block_builder ()
165  				.previous (latest)
166  				.destination (key.pub)
167  				.balance (nano::dev::constants.genesis_amount - 100)
168  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
169  				.work (*system.work.generate (latest))
170  				.build_shared ();
171  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash> (1, send->hash ())));
172  	node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
173  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
174  	node.process_active (send);
175  	node.block_processor.flush ();
176  	ASSERT_TIMELY (5s, node.ledger.block_confirmed (node.store.tx_begin_read (), send->hash ()));
177  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
178  }
179  TEST (active_transactions, inactive_votes_cache_non_final)
180  {
181  	nano::test::system system (1);
182  	auto & node = *system.nodes[0];
183  	auto send = nano::send_block_builder ()
184  				.previous (nano::dev::genesis->hash ())
185  				.destination (nano::keypair{}.pub)
186  				.balance (nano::dev::constants.genesis_amount - 100)
187  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
188  				.work (*system.work.generate (nano::dev::genesis->hash ()))
189  				.build_shared ();
190  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send->hash ()));
191  	node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
192  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
193  	node.process_active (send);
194  	std::shared_ptr<nano::election> election;
195  	ASSERT_TIMELY (5s, election = node.active.election (send->qualified_root ()));
196  	ASSERT_TIMELY_EQ (5s, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached), 1);
197  	ASSERT_TIMELY_EQ (5s, nano::dev::constants.genesis_amount - 100, election->tally ().begin ()->first);
198  	ASSERT_FALSE (election->confirmed ());
199  }
200  TEST (active_transactions, inactive_votes_cache_fork)
201  {
202  	nano::test::system system{ 1 };
203  	auto & node = *system.nodes[0];
204  	auto const latest = node.latest (nano::dev::genesis_key.pub);
205  	nano::keypair key{};
206  	nano::send_block_builder builder{};
207  	auto send1 = builder.make_block ()
208  				 .previous (latest)
209  				 .destination (key.pub)
210  				 .balance (nano::dev::constants.genesis_amount - 100)
211  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
212  				 .work (*system.work.generate (latest))
213  				 .build_shared ();
214  	auto send2 = builder.make_block ()
215  				 .previous (latest)
216  				 .destination (key.pub)
217  				 .balance (nano::dev::constants.genesis_amount - 200)
218  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
219  				 .work (*system.work.generate (latest))
220  				 .build_shared ();
221  	auto const vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash> (1, send1->hash ()));
222  	node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
223  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
224  	node.process_active (send2);
225  	std::shared_ptr<nano::election> election{};
226  	ASSERT_TIMELY (5s, (election = node.active.election (send1->qualified_root ())) != nullptr);
227  	node.process_active (send1);
228  	ASSERT_TIMELY (5s, election->blocks ().size () == 2);
229  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
230  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
231  }
232  TEST (active_transactions, inactive_votes_cache_existing_vote)
233  {
234  	nano::test::system system;
235  	nano::node_config node_config = system.default_config ();
236  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
237  	auto & node = *system.add_node (node_config);
238  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
239  	nano::keypair key;
240  	nano::block_builder builder;
241  	auto send = builder.send ()
242  				.previous (latest)
243  				.destination (key.pub)
244  				.balance (nano::dev::constants.genesis_amount - 100 * nano::Gxrb_ratio)
245  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
246  				.work (*system.work.generate (latest))
247  				.build_shared ();
248  	auto open = builder.state ()
249  				.account (key.pub)
250  				.previous (0)
251  				.representative (key.pub)
252  				.balance (100 * nano::Gxrb_ratio)
253  				.link (send->hash ())
254  				.sign (key.prv, key.pub)
255  				.work (*system.work.generate (key.pub))
256  				.build_shared ();
257  	node.process_active (send);
258  	node.block_processor.add (open);
259  	node.block_processor.flush ();
260  	ASSERT_TIMELY (5s, node.active.size () == 1);
261  	auto election (node.active.election (send->qualified_root ()));
262  	ASSERT_NE (nullptr, election);
263  	ASSERT_GT (node.weight (key.pub), node.minimum_principal_weight ());
264  	auto vote1 (std::make_shared<nano::vote> (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash> (1, send->hash ())));
265  	node.vote_processor.vote (vote1, std::make_shared<nano::transport::inproc::channel> (node, node));
266  	ASSERT_TIMELY (5s, election->votes ().size () == 2);
267  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_new));
268  	auto last_vote1 (election->votes ()[key.pub]);
269  	ASSERT_EQ (send->hash (), last_vote1.hash);
270  	ASSERT_EQ (nano::vote::timestamp_min * 1, last_vote1.timestamp);
271  	nano::unique_lock<nano::mutex> active_lock (node.active.mutex);
272  	node.inactive_vote_cache.vote (send->hash (), vote1);
273  	auto cache = node.inactive_vote_cache.find (send->hash ());
274  	ASSERT_TRUE (cache);
275  	ASSERT_EQ (1, cache->voters.size ());
276  	cache->fill (election);
277  	ASSERT_EQ (2, election->votes ().size ());
278  	auto last_vote2 (election->votes ()[key.pub]);
279  	ASSERT_EQ (last_vote1.hash, last_vote2.hash);
280  	ASSERT_EQ (last_vote1.timestamp, last_vote2.timestamp);
281  	ASSERT_EQ (last_vote1.time, last_vote2.time);
282  	ASSERT_EQ (0, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
283  }
284  TEST (active_transactions, inactive_votes_cache_multiple_votes)
285  {
286  	nano::test::system system;
287  	nano::node_config node_config = system.default_config ();
288  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
289  	auto & node = *system.add_node (node_config);
290  	nano::keypair key1;
291  	nano::block_builder builder;
292  	auto send1 = builder.send ()
293  				 .previous (nano::dev::genesis->hash ())
294  				 .destination (key1.pub)
295  				 .balance (nano::dev::constants.genesis_amount - 100 * nano::Gxrb_ratio)
296  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
297  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
298  				 .build_shared ();
299  	auto send2 = builder.send ()
300  				 .previous (send1->hash ())
301  				 .destination (key1.pub)
302  				 .balance (100 * nano::Gxrb_ratio)
303  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
304  				 .work (*system.work.generate (send1->hash ()))
305  				 .build_shared ();
306  	auto open = builder.state ()
307  				.account (key1.pub)
308  				.previous (0)
309  				.representative (key1.pub)
310  				.balance (100 * nano::Gxrb_ratio)
311  				.link (send1->hash ())
312  				.sign (key1.prv, key1.pub)
313  				.work (*system.work.generate (key1.pub))
314  				.build_shared ();
315  	ASSERT_TRUE (nano::test::process (node, { send1, send2, open }));
316  	ASSERT_TIMELY (5s, nano::test::exists (node, { send1, send2, open }));
317  	auto vote1 (std::make_shared<nano::vote> (key1.pub, key1.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
318  	node.vote_processor.vote (vote1, std::make_shared<nano::transport::inproc::channel> (node, node));
319  	auto vote2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
320  	node.vote_processor.vote (vote2, std::make_shared<nano::transport::inproc::channel> (node, node));
321  	ASSERT_TIMELY (5s, node.inactive_vote_cache.find (send1->hash ()));
322  	ASSERT_TIMELY (5s, node.inactive_vote_cache.find (send1->hash ())->voters.size () == 2);
323  	ASSERT_EQ (1, node.inactive_vote_cache.cache_size ());
324  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
325  	std::shared_ptr<nano::election> election;
326  	ASSERT_TIMELY (5s, election = node.active.election (send1->qualified_root ()));
327  	ASSERT_EQ (3, election->votes ().size ()); 
328  	ASSERT_EQ (2, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
329  }
330  TEST (active_transactions, inactive_votes_cache_election_start)
331  {
332  	nano::test::system system;
333  	nano::node_config node_config = system.default_config ();
334  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
335  	node_config.optimistic_scheduler.enabled = false;
336  	auto & node = *system.add_node (node_config);
337  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
338  	nano::keypair key1, key2;
339  	nano::send_block_builder send_block_builder;
340  	nano::state_block_builder state_block_builder;
341  	auto amount = ((node.online_reps.trended () / 100) * node.config.election_hint_weight_percent) / 2 + 1000 * nano::Gxrb_ratio;
342  	auto send1 = send_block_builder.make_block ()
343  				 .previous (latest)
344  				 .destination (key1.pub)
345  				 .balance (nano::dev::constants.genesis_amount - amount)
346  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
347  				 .work (*system.work.generate (latest))
348  				 .build_shared ();
349  	auto send2 = send_block_builder.make_block ()
350  				 .previous (send1->hash ())
351  				 .destination (key2.pub)
352  				 .balance (nano::dev::constants.genesis_amount - 2 * amount)
353  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
354  				 .work (*system.work.generate (send1->hash ()))
355  				 .build_shared ();
356  	auto open1 = state_block_builder.make_block ()
357  				 .account (key1.pub)
358  				 .previous (0)
359  				 .representative (key1.pub)
360  				 .balance (amount)
361  				 .link (send1->hash ())
362  				 .sign (key1.prv, key1.pub)
363  				 .work (*system.work.generate (key1.pub))
364  				 .build_shared ();
365  	auto open2 = state_block_builder.make_block ()
366  				 .account (key2.pub)
367  				 .previous (0)
368  				 .representative (key2.pub)
369  				 .balance (amount)
370  				 .link (send2->hash ())
371  				 .sign (key2.prv, key2.pub)
372  				 .work (*system.work.generate (key2.pub))
373  				 .build_shared ();
374  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
375  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
376  	ASSERT_EQ (nano::process_result::progress, node.process (*open1).code);
377  	ASSERT_EQ (nano::process_result::progress, node.process (*open2).code);
378  	ASSERT_TIMELY (5s, 5 == node.ledger.cache.block_count);
379  	ASSERT_TRUE (node.active.empty ());
380  	ASSERT_EQ (1, node.ledger.cache.cemented_count);
381  	auto send3 = send_block_builder.make_block ()
382  				 .previous (send2->hash ())
383  				 .destination (nano::keypair ().pub)
384  				 .balance (send2->balance ().number () - 1)
385  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
386  				 .work (*system.work.generate (send2->hash ()))
387  				 .build_shared ();
388  	auto send4 = send_block_builder.make_block ()
389  				 .previous (send3->hash ())
390  				 .destination (nano::keypair ().pub)
391  				 .balance (send3->balance ().number () - 1)
392  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
393  				 .work (*system.work.generate (send3->hash ()))
394  				 .build_shared ();
395  	std::vector<nano::block_hash> hashes{ open1->hash (), open2->hash (), send4->hash () };
396  	auto vote1 (std::make_shared<nano::vote> (key1.pub, key1.prv, 0, 0, hashes));
397  	node.vote_processor.vote (vote1, std::make_shared<nano::transport::inproc::channel> (node, node));
398  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 3);
399  	ASSERT_TRUE (node.active.empty ());
400  	ASSERT_EQ (1, node.ledger.cache.cemented_count);
401  	auto vote2 (std::make_shared<nano::vote> (key2.pub, key2.prv, 0, 0, hashes));
402  	node.vote_processor.vote (vote2, std::make_shared<nano::transport::inproc::channel> (node, node));
403  	ASSERT_TIMELY (5s, 2 == node.active.size ());
404  	auto vote0 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, hashes)); 
405  	node.vote_processor.vote (vote0, std::make_shared<nano::transport::inproc::channel> (node, node));
406  	ASSERT_TIMELY (5s, node.active.empty ());
407  	ASSERT_TIMELY (5s, 5 == node.ledger.cache.cemented_count);
408  	ASSERT_TRUE (node.active.empty ());
409  	auto send4_cache (node.inactive_vote_cache.find (send4->hash ()));
410  	ASSERT_TRUE (send4_cache);
411  	ASSERT_EQ (3, send4_cache->voters.size ());
412  	node.process_active (send3);
413  	ASSERT_FALSE (node.block_confirmed_or_being_confirmed (send3->hash ()));
414  	ASSERT_FALSE (node.ledger.dependents_confirmed (node.store.tx_begin_read (), *send4));
415  	node.process_active (send4);
416  	ASSERT_TIMELY (5s, 7 == node.ledger.cache.cemented_count);
417  }
418  namespace nano
419  {
420  TEST (active_transactions, vote_replays)
421  {
422  	nano::test::system system;
423  	nano::node_config node_config = system.default_config ();
424  	node_config.enable_voting = false;
425  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
426  	auto & node = *system.add_node (node_config);
427  	nano::keypair key;
428  	nano::state_block_builder builder;
429  	auto send1 = builder.make_block ()
430  				 .account (nano::dev::genesis_key.pub)
431  				 .previous (nano::dev::genesis->hash ())
432  				 .representative (nano::dev::genesis_key.pub)
433  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
434  				 .link (key.pub)
435  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
436  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
437  				 .build_shared ();
438  	ASSERT_NE (nullptr, send1);
439  	auto open1 = builder.make_block ()
440  				 .account (key.pub)
441  				 .previous (0)
442  				 .representative (key.pub)
443  				 .balance (nano::Gxrb_ratio)
444  				 .link (send1->hash ())
445  				 .sign (key.prv, key.pub)
446  				 .work (*system.work.generate (key.pub))
447  				 .build_shared ();
448  	ASSERT_NE (nullptr, open1);
449  	node.process_active (send1);
450  	node.process_active (open1);
451  	nano::test::start_elections (system, node, { send1, open1 });
452  	ASSERT_EQ (2, node.active.size ());
453  	auto vote_send1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send1->hash () }));
454  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote_send1));
455  	ASSERT_EQ (2, node.active.size ());
456  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_send1));
457  	ASSERT_TIMELY (3s, node.active.size () == 1);
458  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_send1));
459  	auto vote_open1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ open1->hash () }));
460  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote_open1));
461  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_open1));
462  	ASSERT_TIMELY (3s, node.active.empty ());
463  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_open1));
464  	ASSERT_EQ (nano::Gxrb_ratio, node.ledger.weight (key.pub));
465  	auto send2 = builder.make_block ()
466  				 .account (key.pub)
467  				 .previous (open1->hash ())
468  				 .representative (key.pub)
469  				 .balance (nano::Gxrb_ratio - 1)
470  				 .link (key.pub)
471  				 .sign (key.prv, key.pub)
472  				 .work (*system.work.generate (open1->hash ()))
473  				 .build_shared ();
474  	ASSERT_NE (nullptr, send2);
475  	node.process_active (send2);
476  	nano::test::start_elections (system, node, { send2 });
477  	ASSERT_EQ (1, node.active.size ());
478  	auto vote1_send2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send2->hash () }));
479  	auto vote2_send2 (std::make_shared<nano::vote> (key.pub, key.prv, 0, 0, std::vector<nano::block_hash>{ send2->hash () }));
480  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote2_send2));
481  	ASSERT_EQ (1, node.active.size ());
482  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
483  	ASSERT_EQ (1, node.active.size ());
484  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote1_send2));
485  	ASSERT_EQ (1, node.active.size ());
486  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote1_send2));
487  	ASSERT_TIMELY (3s, node.active.empty ());
488  	ASSERT_EQ (0, node.active.size ());
489  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote1_send2));
490  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
491  	{
492  		nano::lock_guard<nano::mutex> guard (node.active.mutex);
493  		node.active.recently_confirmed.clear ();
494  	}
495  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_send1));
496  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_open1));
497  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote1_send2));
498  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote2_send2));
499  }
500  }
501  TEST (active_transactions, dropped_cleanup)
502  {
503  	nano::test::system system;
504  	nano::node_flags flags;
505  	flags.disable_request_loop = true;
506  	auto & node (*system.add_node (flags));
507  	auto chain = nano::test::setup_chain (system, node, 1, nano::dev::genesis_key, false);
508  	auto hash = chain[0]->hash ();
509  	std::vector<uint8_t> block_bytes;
510  	{
511  		nano::vectorstream stream (block_bytes);
512  		chain[0]->serialize (stream);
513  	}
514  	ASSERT_FALSE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
515  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
516  	auto election = nano::test::start_election (system, node, hash);
517  	ASSERT_NE (nullptr, election);
518  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
519  	ASSERT_TRUE (node.active.active (hash));
520  	ASSERT_FALSE (election->confirmed ());
521  	node.active.erase (*chain[0]);
522  	ASSERT_FALSE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
523  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
524  	ASSERT_FALSE (node.active.active (hash));
525  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
526  	election = nano::test::start_election (system, node, hash);
527  	ASSERT_NE (nullptr, election);
528  	election->force_confirm ();
529  	ASSERT_TIMELY (5s, election->confirmed ());
530  	node.active.erase (*chain[0]);
531  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
532  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
533  	ASSERT_FALSE (node.active.active (hash));
534  }
535  TEST (active_transactions, republish_winner)
536  {
537  	nano::test::system system;
538  	nano::node_config node_config = system.default_config ();
539  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
540  	auto & node1 = *system.add_node (node_config);
541  	node_config.peering_port = system.get_available_port ();
542  	auto & node2 = *system.add_node (node_config);
543  	nano::keypair key;
544  	nano::state_block_builder builder;
545  	auto send1 = builder.make_block ()
546  				 .account (nano::dev::genesis_key.pub)
547  				 .previous (nano::dev::genesis->hash ())
548  				 .representative (nano::dev::genesis_key.pub)
549  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
550  				 .link (key.pub)
551  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
553  				 .build_shared ();
554  	node1.process_active (send1);
555  	node1.block_processor.flush ();
556  	ASSERT_TIMELY (3s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) == 1);
557  	for (auto i (0); i < 5; i++)
558  	{
559  		auto fork = builder.make_block ()
560  					.account (nano::dev::genesis_key.pub)
561  					.previous (nano::dev::genesis->hash ())
562  					.representative (nano::dev::genesis_key.pub)
563  					.balance (nano::dev::constants.genesis_amount - 1 - i)
564  					.link (key.pub)
565  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
566  					.work (*system.work.generate (nano::dev::genesis->hash ()))
567  					.build_shared ();
568  		node1.process_active (fork);
569  	}
570  	node1.block_processor.flush ();
571  	ASSERT_TIMELY (3s, !node1.active.empty ());
572  	ASSERT_EQ (1, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in));
573  	auto fork = builder.make_block ()
574  				.account (nano::dev::genesis_key.pub)
575  				.previous (nano::dev::genesis->hash ())
576  				.representative (nano::dev::genesis_key.pub)
577  				.balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
578  				.link (key.pub)
579  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
580  				.work (*system.work.generate (nano::dev::genesis->hash ()))
581  				.build_shared ();
582  	node1.process_active (fork);
583  	node1.block_processor.flush ();
584  	auto election = node1.active.election (fork->qualified_root ());
585  	ASSERT_NE (nullptr, election);
586  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ fork->hash () });
587  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
588  	node1.vote_processor.flush ();
589  	node1.block_processor.flush ();
590  	ASSERT_TIMELY (5s, election->confirmed ());
591  	ASSERT_EQ (fork->hash (), election->status.winner->hash ());
592  	ASSERT_TIMELY (5s, node2.block_confirmed (fork->hash ()));
593  }
594  TEST (active_transactions, fork_filter_cleanup)
595  {
596  	nano::test::system system{};
597  	nano::node_config node_config = system.default_config ();
598  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
599  	auto & node1 = *system.add_node (node_config);
600  	nano::keypair key{};
601  	nano::state_block_builder builder{};
602  	auto const latest_hash = nano::dev::genesis->hash ();
603  	auto send1 = builder.make_block ()
604  				 .previous (latest_hash)
605  				 .account (nano::dev::genesis_key.pub)
606  				 .representative (nano::dev::genesis_key.pub)
607  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
608  				 .link (key.pub)
609  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
610  				 .work (*system.work.generate (latest_hash))
611  				 .build_shared ();
612  	std::vector<uint8_t> send_block_bytes{};
613  	{
614  		nano::vectorstream stream{ send_block_bytes };
615  		send1->serialize (stream);
616  	}
617  	for (auto i = 0; i < 10; ++i)
618  	{
619  		auto fork = builder.make_block ()
620  					.previous (latest_hash)
621  					.account (nano::dev::genesis_key.pub)
622  					.representative (nano::dev::genesis_key.pub)
623  					.balance (nano::dev::constants.genesis_amount - 1 - i)
624  					.link (key.pub)
625  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
626  					.work (*system.work.generate (latest_hash))
627  					.build_shared ();
628  		node1.process_active (fork);
629  		ASSERT_TIMELY (5s, node1.active.election (fork->qualified_root ()) != nullptr);
630  	}
631  	std::shared_ptr<nano::election> election{};
632  	ASSERT_TIMELY (5s, (election = node1.active.election (send1->qualified_root ())) != nullptr);
633  	ASSERT_TIMELY (5s, election->blocks ().size () == 10);
634  	ASSERT_EQ (1, node1.active.size ());
635  	node_config.peering_port = system.get_available_port ();
636  	auto & node2 = *system.add_node (node_config);
637  	node2.process_active (send1);
638  	ASSERT_TIMELY (5s, node2.active.election (send1->qualified_root ()) != nullptr);
639  	ASSERT_TIMELY (5s, node2.ledger.cache.block_count == 2);
640  	ASSERT_TIMELY (5s, node1.ledger.cache.block_count == 2);
641  	ASSERT_TIMELY (5s, node1.network.publish_filter.apply (send_block_bytes.data (), send_block_bytes.size ()));
642  }
643  TEST (active_transactions, fork_replacement_tally)
644  {
645  	nano::test::system system;
646  	nano::node_config node_config = system.default_config ();
647  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
648  	auto & node1 (*system.add_node (node_config));
649  	size_t const reps_count = 20;
650  	size_t const max_blocks = 10;
651  	std::vector<nano::keypair> keys (reps_count);
652  	auto latest (nano::dev::genesis->hash ());
653  	auto balance (nano::dev::constants.genesis_amount);
654  	auto amount (node1.minimum_principal_weight ());
655  	nano::state_block_builder builder;
656  	for (auto i (0); i < reps_count; i++)
657  	{
658  		balance -= amount + i;
659  		auto send = builder.make_block ()
660  					.account (nano::dev::genesis_key.pub)
661  					.previous (latest)
662  					.representative (nano::dev::genesis_key.pub)
663  					.balance (balance)
664  					.link (keys[i].pub)
665  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
666  					.work (*system.work.generate (latest))
667  					.build_shared ();
668  		node1.process_active (send);
669  		latest = send->hash ();
670  		auto open = builder.make_block ()
671  					.account (keys[i].pub)
672  					.previous (0)
673  					.representative (keys[i].pub)
674  					.balance (amount + i)
675  					.link (send->hash ())
676  					.sign (keys[i].prv, keys[i].pub)
677  					.work (*system.work.generate (keys[i].pub))
678  					.build_shared ();
679  		node1.process_active (open);
680  		auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send->hash (), open->hash () }));
681  		node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
682  	}
683  	ASSERT_TIMELY (5s, node1.ledger.cache.cemented_count == 1 + 2 * reps_count);
684  	nano::keypair key;
685  	auto send_last = builder.make_block ()
686  					 .account (nano::dev::genesis_key.pub)
687  					 .previous (latest)
688  					 .representative (nano::dev::genesis_key.pub)
689  					 .balance (balance - 2 * nano::Gxrb_ratio)
690  					 .link (key.pub)
691  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
692  					 .work (*system.work.generate (latest))
693  					 .build_shared ();
694  	for (auto i (0); i < reps_count; i++)
695  	{
696  		auto fork = builder.make_block ()
697  					.account (nano::dev::genesis_key.pub)
698  					.previous (latest)
699  					.representative (nano::dev::genesis_key.pub)
700  					.balance (balance - nano::Gxrb_ratio - i)
701  					.link (key.pub)
702  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
703  					.work (*system.work.generate (latest))
704  					.build_shared ();
705  		node1.process_active (fork);
706  	}
707  	ASSERT_TIMELY (5s, !node1.active.empty ());
708  	auto election = node1.active.election (send_last->qualified_root ());
709  	ASSERT_NE (nullptr, election);
710  	ASSERT_TIMELY (5s, max_blocks == election->blocks ().size ());
711  	for (auto i (0); i < reps_count; i++)
712  	{
713  		auto fork = builder.make_block ()
714  					.account (nano::dev::genesis_key.pub)
715  					.previous (latest)
716  					.representative (nano::dev::genesis_key.pub)
717  					.balance (balance - 1 - i)
718  					.link (key.pub)
719  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
720  					.work (*system.work.generate (latest))
721  					.build_shared ();
722  		auto vote (std::make_shared<nano::vote> (keys[i].pub, keys[i].prv, 0, 0, std::vector<nano::block_hash>{ fork->hash () }));
723  		node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
724  		node1.vote_processor.flush ();
725  		node1.process_active (fork);
726  	}
727  	auto count_rep_votes_in_election = [&max_blocks, &reps_count, &election, &keys] () {
728  		auto votes_l = election->votes ();
729  		if (max_blocks != votes_l.size ())
730  		{
731  			return -1;
732  		}
733  		int vote_count = 0;
734  		for (auto i = 0; i < reps_count; i++)
735  		{
736  			if (votes_l.find (keys[i].pub) != votes_l.end ())
737  			{
738  				vote_count++;
739  			}
740  		}
741  		return vote_count;
742  	};
743  	ASSERT_TIMELY (10s, count_rep_votes_in_election () == 9);
744  	ASSERT_EQ (max_blocks, election->blocks ().size ());
745  	node_config.peering_port = system.get_available_port ();
746  	auto & node2 (*system.add_node (node_config));
747  	node1.network.publish_filter.clear ();
748  	node2.network.flood_block (send_last);
749  	ASSERT_TIMELY (3s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) > 0);
750  	node1.block_processor.flush ();
751  	system.delay_ms (50ms);
752  	auto blocks1 (election->blocks ());
753  	ASSERT_EQ (max_blocks, blocks1.size ());
754  	ASSERT_FALSE (blocks1.find (send_last->hash ()) != blocks1.end ());
755  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send_last->hash () }));
756  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
757  	node1.vote_processor.flush ();
758  	ASSERT_TIMELY (5s, node1.inactive_vote_cache.find (send_last->hash ()));
759  	ASSERT_TIMELY (5s, 1 == node1.inactive_vote_cache.find (send_last->hash ())->size ());
760  	node1.network.publish_filter.clear ();
761  	node2.network.flood_block (send_last);
762  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) > 1);
763  	auto find_send_last_block = [&election, &send_last] () {
764  		auto blocks2 = election->blocks ();
765  		return blocks2.find (send_last->hash ()) != blocks2.end ();
766  	};
767  	ASSERT_TIMELY (5s, find_send_last_block ())
768  	ASSERT_EQ (max_blocks, election->blocks ().size ());
769  	ASSERT_TIMELY (5s, count_rep_votes_in_election () == 8);
770  	auto votes2 (election->votes ());
771  	ASSERT_TRUE (votes2.find (nano::dev::genesis_key.pub) != votes2.end ());
772  }
773  namespace nano
774  {
775  TEST (active_transactions, confirmation_consistency)
776  {
777  	nano::test::system system;
778  	nano::node_config node_config = system.default_config ();
779  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
780  	auto & node = *system.add_node (node_config);
781  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
782  	for (unsigned i = 0; i < 10; ++i)
783  	{
784  		auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::public_key (), node.config.receive_minimum.number ()));
785  		ASSERT_NE (nullptr, block);
786  		system.deadline_set (5s);
787  		while (!node.ledger.block_confirmed (node.store.tx_begin_read (), block->hash ()))
788  		{
789  			node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
790  			ASSERT_NO_ERROR (system.poll (5ms));
791  		}
792  		ASSERT_NO_ERROR (system.poll_until_true (1s, [&node, &block, i] {
793  			nano::lock_guard<nano::mutex> guard (node.active.mutex);
794  			EXPECT_EQ (i + 1, node.active.recently_confirmed.size ());
795  			EXPECT_EQ (block->qualified_root (), node.active.recently_confirmed.back ().first);
796  			return i + 1 == node.active.recently_cemented.size (); 
797  		}));
798  	}
799  }
800  }
801  TEST (active_transactions, DISABLED_confirm_new)
802  {
803  	nano::test::system system (1);
804  	auto & node1 = *system.nodes[0];
805  	auto send = nano::send_block_builder ()
806  				.previous (nano::dev::genesis->hash ())
807  				.destination (nano::public_key ())
808  				.balance (nano::dev::constants.genesis_amount - 100)
809  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
810  				.work (*system.work.generate (nano::dev::genesis->hash ()))
811  				.build_shared ();
812  	node1.process_active (send);
813  	node1.block_processor.flush ();
814  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
815  	auto & node2 = *system.add_node ();
816  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
817  	ASSERT_TIMELY (5s, node2.block (send->hash ()));
818  	ASSERT_TIMELY (5s, node1.ledger.cache.cemented_count == 2 && node2.ledger.cache.cemented_count == 2);
819  }
820  TEST (active_transactions, conflicting_block_vote_existing_election)
821  {
822  	nano::test::system system;
823  	nano::node_flags node_flags;
824  	node_flags.disable_request_loop = true;
825  	auto & node = *system.add_node (node_flags);
826  	nano::keypair key;
827  	nano::state_block_builder builder;
828  	auto send = builder.make_block ()
829  				.account (nano::dev::genesis_key.pub)
830  				.previous (nano::dev::genesis->hash ())
831  				.representative (nano::dev::genesis_key.pub)
832  				.balance (nano::dev::constants.genesis_amount - 100)
833  				.link (key.pub)
834  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
835  				.work (*system.work.generate (nano::dev::genesis->hash ()))
836  				.build_shared ();
837  	auto fork = builder.make_block ()
838  				.account (nano::dev::genesis_key.pub)
839  				.previous (nano::dev::genesis->hash ())
840  				.representative (nano::dev::genesis_key.pub)
841  				.balance (nano::dev::constants.genesis_amount - 200)
842  				.link (key.pub)
843  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
844  				.work (*system.work.generate (nano::dev::genesis->hash ()))
845  				.build_shared ();
846  	auto vote_fork (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ fork->hash () }));
847  	ASSERT_EQ (nano::process_result::progress, node.process_local (send).value ().code);
848  	ASSERT_TIMELY_EQ (5s, 1, node.active.size ());
849  	node.active.vote (vote_fork);
850  	ASSERT_EQ (nano::process_result::fork, node.process_local (fork).value ().code);
851  	auto election (node.active.election (fork->qualified_root ()));
852  	ASSERT_NE (nullptr, election);
853  	ASSERT_TIMELY (3s, election->confirmed ());
854  }
855  TEST (active_transactions, activate_account_chain)
856  {
857  	nano::test::system system;
858  	nano::node_flags flags;
859  	nano::node_config config = system.default_config ();
860  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
861  	auto & node = *system.add_node (config, flags);
862  	nano::keypair key;
863  	nano::state_block_builder builder;
864  	auto send = builder.make_block ()
865  				.account (nano::dev::genesis_key.pub)
866  				.previous (nano::dev::genesis->hash ())
867  				.representative (nano::dev::genesis_key.pub)
868  				.link (nano::dev::genesis_key.pub)
869  				.balance (nano::dev::constants.genesis_amount - 1)
870  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
871  				.work (*system.work.generate (nano::dev::genesis->hash ()))
872  				.build ();
873  	auto send2 = builder.make_block ()
874  				 .account (nano::dev::genesis_key.pub)
875  				 .previous (send->hash ())
876  				 .representative (nano::dev::genesis_key.pub)
877  				 .link (key.pub)
878  				 .balance (nano::dev::constants.genesis_amount - 2)
879  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
880  				 .work (*system.work.generate (send->hash ()))
881  				 .build ();
882  	auto send3 = builder.make_block ()
883  				 .account (nano::dev::genesis_key.pub)
884  				 .previous (send2->hash ())
885  				 .representative (nano::dev::genesis_key.pub)
886  				 .link (key.pub)
887  				 .balance (nano::dev::constants.genesis_amount - 3)
888  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
889  				 .work (*system.work.generate (send2->hash ()))
890  				 .build ();
891  	auto open = builder.make_block ()
892  				.account (key.pub)
893  				.previous (0)
894  				.representative (key.pub)
895  				.link (send2->hash ())
896  				.balance (1)
897  				.sign (key.prv, key.pub)
898  				.work (*system.work.generate (key.pub))
899  				.build ();
900  	auto receive = builder.make_block ()
901  				   .account (key.pub)
902  				   .previous (open->hash ())
903  				   .representative (key.pub)
904  				   .link (send3->hash ())
905  				   .balance (2)
906  				   .sign (key.prv, key.pub)
907  				   .work (*system.work.generate (open->hash ()))
908  				   .build ();
909  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
910  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
911  	ASSERT_EQ (nano::process_result::progress, node.process (*send3).code);
912  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
913  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
914  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
915  	ASSERT_TIMELY (5s, node.active.election (send->qualified_root ()));
916  	auto election1 = node.active.election (send->qualified_root ());
917  	ASSERT_EQ (1, node.active.size ());
918  	ASSERT_EQ (1, election1->blocks ().count (send->hash ()));
919  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
920  	auto election2 = node.active.election (send->qualified_root ());
921  	ASSERT_EQ (election2, election1);
922  	election1->force_confirm ();
923  	ASSERT_TIMELY (3s, node.block_confirmed (send->hash ()));
924  	ASSERT_TIMELY (3s, node.active.active (send2->qualified_root ()));
925  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
926  	auto election3 = node.active.election (send2->qualified_root ());
927  	ASSERT_NE (nullptr, election3);
928  	ASSERT_EQ (1, election3->blocks ().count (send2->hash ()));
929  	election3->force_confirm ();
930  	ASSERT_TIMELY (3s, node.block_confirmed (send2->hash ()));
931  	ASSERT_TIMELY (3s, node.active.active (open->qualified_root ()));
932  	ASSERT_TIMELY (3s, node.active.active (send3->qualified_root ()));
933  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
934  	auto election4 = node.active.election (send3->qualified_root ());
935  	ASSERT_NE (nullptr, election4);
936  	ASSERT_EQ (1, election4->blocks ().count (send3->hash ()));
937  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
938  	auto election5 = node.active.election (open->qualified_root ());
939  	ASSERT_NE (nullptr, election5);
940  	ASSERT_EQ (1, election5->blocks ().count (open->hash ()));
941  	election5->force_confirm ();
942  	ASSERT_TIMELY (3s, node.block_confirmed (open->hash ()));
943  	std::this_thread::sleep_for (200ms);
944  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
945  	election4->force_confirm ();
946  	ASSERT_TIMELY (3s, node.block_confirmed (send3->hash ()));
<span onclick='openModal()' class='match'>947  	ASSERT_TIMELY (3s, node.active.active (receive->qualified_root ()));
948  }
</span>949  TEST (active_transactions, activate_inactive)
950  {
951  	nano::test::system system;
952  	nano::node_flags flags;
953  	nano::node_config config = system.default_config ();
954  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
955  	auto & node = *system.add_node (config, flags);
956  	nano::keypair key;
957  	nano::state_block_builder builder;
958  	auto send = builder.make_block ()
959  				.account (nano::dev::genesis_key.pub)
960  				.previous (nano::dev::genesis->hash ())
961  				.representative (nano::dev::genesis_key.pub)
962  				.link (key.pub)
963  				.balance (nano::dev::constants.genesis_amount - 1)
964  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
965  				.work (*system.work.generate (nano::dev::genesis->hash ()))
966  				.build_shared ();
967  	auto send2 = builder.make_block ()
968  				 .account (nano::dev::genesis_key.pub)
969  				 .previous (send->hash ())
970  				 .representative (nano::dev::genesis_key.pub)
971  				 .link (nano::keypair ().pub)
972  				 .balance (nano::dev::constants.genesis_amount - 2)
973  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
974  				 .work (*system.work.generate (send->hash ()))
975  				 .build_shared ();
976  	auto open = builder.make_block ()
977  				.account (key.pub)
978  				.previous (0)
979  				.representative (key.pub)
980  				.link (send->hash ())
981  				.balance (1)
982  				.sign (key.prv, key.pub)
983  				.work (*system.work.generate (key.pub))
984  				.build_shared ();
985  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
986  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
987  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
988  	auto election = nano::test::start_election (system, node, send2->hash ());
989  	ASSERT_NE (nullptr, election);
990  	election->force_confirm ();
991  	ASSERT_TIMELY (5s, !node.confirmation_height_processor.is_processing_added_block (send2->hash ()));
992  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
993  	ASSERT_TIMELY (5s, node.block_confirmed (send->hash ()));
994  	ASSERT_EQ (1, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out));
995  	ASSERT_EQ (1, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::active_quorum, nano::stat::dir::out));
996  	ASSERT_EQ (0, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::active_conf_height, nano::stat::dir::out));
997  	ASSERT_FALSE (node.active.active (open->qualified_root ()) || node.block_confirmed_or_being_confirmed (open->hash ()));
998  }
999  TEST (active_transactions, list_active)
1000  {
1001  	nano::test::system system (1);
1002  	auto & node = *system.nodes[0];
1003  	nano::keypair key;
1004  	nano::state_block_builder builder;
1005  	auto send = builder.make_block ()
1006  				.account (nano::dev::genesis_key.pub)
1007  				.previous (nano::dev::genesis->hash ())
1008  				.representative (nano::dev::genesis_key.pub)
1009  				.link (nano::dev::genesis_key.pub)
1010  				.balance (nano::dev::constants.genesis_amount - 1)
1011  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1012  				.work (*system.work.generate (nano::dev::genesis->hash ()))
1013  				.build_shared ();
1014  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1015  	auto send2 = builder.make_block ()
1016  				 .account (nano::dev::genesis_key.pub)
1017  				 .previous (send->hash ())
1018  				 .representative (nano::dev::genesis_key.pub)
1019  				 .link (key.pub)
1020  				 .balance (nano::dev::constants.genesis_amount - 2)
1021  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1022  				 .work (*system.work.generate (send->hash ()))
1023  				 .build_shared ();
1024  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
1025  	auto open = builder.make_block ()
1026  				.account (key.pub)
1027  				.previous (0)
1028  				.representative (key.pub)
1029  				.link (send2->hash ())
1030  				.balance (1)
1031  				.sign (key.prv, key.pub)
1032  				.work (*system.work.generate (key.pub))
1033  				.build_shared ();
1034  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
1035  	nano::test::start_elections (system, node, { send, send2, open });
1036  	ASSERT_EQ (3, node.active.size ());
1037  	ASSERT_EQ (1, node.active.list_active (1).size ());
1038  	ASSERT_EQ (2, node.active.list_active (2).size ());
1039  	ASSERT_EQ (3, node.active.list_active (3).size ());
1040  	ASSERT_EQ (3, node.active.list_active (4).size ());
1041  	ASSERT_EQ (3, node.active.list_active (99999).size ());
1042  	ASSERT_EQ (3, node.active.list_active ().size ());
1043  	auto active = node.active.list_active ();
1044  }
1045  TEST (active_transactions, vacancy)
1046  {
1047  	std::atomic<bool> updated = false;
1048  	{
1049  		nano::test::system system;
1050  		nano::node_config config = system.default_config ();
1051  		config.active_elections_size = 1;
1052  		auto & node = *system.add_node (config);
1053  		nano::state_block_builder builder;
1054  		auto send = builder.make_block ()
1055  					.account (nano::dev::genesis_key.pub)
1056  					.previous (nano::dev::genesis->hash ())
1057  					.representative (nano::dev::genesis_key.pub)
1058  					.link (nano::dev::genesis_key.pub)
1059  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1060  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1061  					.work (*system.work.generate (nano::dev::genesis->hash ()))
1062  					.build_shared ();
1063  		node.active.vacancy_update = [&updated] () { updated = true; };
1064  		ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1065  		ASSERT_EQ (1, node.active.vacancy ());
1066  		ASSERT_EQ (0, node.active.size ());
1067  		node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
1068  		ASSERT_TIMELY (1s, updated);
1069  		updated = false;
1070  		ASSERT_EQ (0, node.active.vacancy ());
1071  		ASSERT_EQ (1, node.active.size ());
1072  		auto election1 = node.active.election (send->qualified_root ());
1073  		ASSERT_NE (nullptr, election1);
1074  		election1->force_confirm ();
1075  		ASSERT_TIMELY (1s, updated);
1076  		ASSERT_EQ (1, node.active.vacancy ());
1077  		ASSERT_EQ (0, node.active.size ());
1078  	}
1079  }
1080  TEST (active_transactions, fifo)
1081  {
1082  	nano::test::system system{};
1083  	nano::node_config config = system.default_config ();
1084  	config.active_elections_size = 1;
1085  	auto & node = *system.add_node (config);
1086  	auto latest_hash = nano::dev::genesis->hash ();
1087  	nano::keypair key0{};
1088  	nano::state_block_builder builder{};
1089  	auto send1 = builder.make_block ()
1090  				 .previous (latest_hash)
1091  				 .account (nano::dev::genesis_key.pub)
1092  				 .representative (nano::dev::genesis_key.pub)
1093  				 .link (key0.pub)
1094  				 .balance (nano::dev::constants.genesis_amount - 1)
1095  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1096  				 .work (*system.work.generate (latest_hash))
1097  				 .build_shared ();
1098  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
1099  	node.process_confirmed (nano::election_status{ send1 });
1100  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
1101  	nano::keypair key1{};
1102  	latest_hash = send1->hash ();
1103  	auto send2 = builder.make_block ()
1104  				 .previous (latest_hash)
1105  				 .account (nano::dev::genesis_key.pub)
1106  				 .representative (nano::dev::genesis_key.pub)
1107  				 .link (key1.pub)
1108  				 .balance (nano::dev::constants.genesis_amount - 2)
1109  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1110  				 .work (*system.work.generate (latest_hash))
1111  				 .build_shared ();
1112  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
1113  	node.process_confirmed (nano::election_status{ send2 });
1114  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
1115  	auto receive1 = builder.make_block ()
1116  					.previous (0)
1117  					.account (key0.pub)
1118  					.representative (nano::dev::genesis_key.pub)
1119  					.link (send1->hash ())
1120  					.balance (1)
1121  					.sign (key0.prv, key0.pub)
1122  					.work (*system.work.generate (key0.pub))
1123  					.build_shared ();
1124  	ASSERT_EQ (nano::process_result::progress, node.process (*receive1).code);
1125  	auto receive2 = builder.make_block ()
1126  					.previous (0)
1127  					.account (key1.pub)
1128  					.representative (nano::dev::genesis_key.pub)
1129  					.link (send2->hash ())
1130  					.balance (1)
1131  					.sign (key1.prv, key1.pub)
1132  					.work (*system.work.generate (key1.pub))
1133  					.build_shared ();
1134  	ASSERT_EQ (nano::process_result::progress, node.process (*receive2).code);
1135  	node.scheduler.buckets.manual (receive1);
1136  	ASSERT_TIMELY (5s, node.active.election (receive1->qualified_root ()) != nullptr);
1137  	node.scheduler.buckets.manual (receive2);
1138  	ASSERT_TIMELY (5s, node.active.election (receive2->qualified_root ()) != nullptr);
1139  	ASSERT_TIMELY (5s, node.active.size () == 1);
1140  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
1141  	ASSERT_TIMELY (1s, node.active.election (receive2->qualified_root ()) != nullptr);
1142  }
1143  TEST (active_transactions, limit_vote_hinted_elections)
1144  {
1145  	nano::test::system system;
1146  	nano::node_config config = system.default_config ();
1147  	const int aec_limit = 10;
1148  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1149  	config.optimistic_scheduler.enabled = false;
1150  	config.active_elections_size = aec_limit;
1151  	config.active_elections_hinted_limit_percentage = 10; 
1152  	auto & node = *system.add_node (config);
1153  	const auto amount = ((node.online_reps.trended () / 100) * node.config.election_hint_weight_percent) + 1000 * nano::Gxrb_ratio;
1154  	nano::keypair rep1 = nano::test::setup_rep (system, node, amount / 2);
1155  	nano::keypair rep2 = nano::test::setup_rep (system, node, amount / 2);
1156  	auto blocks = nano::test::setup_independent_blocks (system, node, 2);
1157  	auto open0 = blocks[0];
1158  	auto open1 = blocks[1];
1159  	WAIT (1s);
1160  	node.active.clear ();
1161  	ASSERT_TRUE (node.active.empty ());
1162  	auto vote1 = nano::test::make_vote (rep1, { open0, open1 });
1163  	node.vote_processor.vote (vote1, nano::test::fake_channel (node));
1164  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 2);
1165  	ASSERT_ALWAYS (1s, node.active.empty ());
1166  	ASSERT_FALSE (nano::test::confirmed (node, { open0, open1 }));
1167  	auto vote2 = nano::test::make_vote (rep2, { open0 });
1168  	node.vote_processor.vote (vote2, nano::test::fake_channel (node));
1169  	ASSERT_TIMELY (5s, node.active.size () == 1);
1170  	ASSERT_TIMELY (5s, nano::test::active (node, { open0 }));
1171  	auto vote3 = nano::test::make_vote (rep2, { open1 });
1172  	node.vote_processor.vote (vote3, nano::test::fake_channel (node));
1173  	ASSERT_NEVER (1s, nano::test::active (node, { open1 }));
1174  	ASSERT_EQ (node.active.size (), 1);
1175  	auto vote4 = nano::test::make_final_vote (nano::dev::genesis_key, { open0 });
1176  	node.vote_processor.vote (vote4, nano::test::fake_channel (node));
1177  	ASSERT_TIMELY (5s, nano::test::confirmed (node, { open0 }));
1178  	ASSERT_TIMELY (5s, nano::test::active (node, { open1 }));
1179  	ASSERT_EQ (0, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
1180  }
1181  TEST (active_transactions, allow_limited_overflow)
1182  {
1183  	nano::test::system system;
1184  	nano::node_config config = system.default_config ();
1185  	const int aec_limit = 20;
1186  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1187  	config.active_elections_size = aec_limit;
1188  	config.active_elections_hinted_limit_percentage = 20; 
1189  	auto & node = *system.add_node (config);
1190  	auto blocks = nano::test::setup_independent_blocks (system, node, aec_limit * 4);
1191  	std::vector<std::shared_ptr<nano::block>> blocks1 (blocks.begin (), blocks.begin () + blocks.size () / 2);
1192  	std::vector<std::shared_ptr<nano::block>> blocks2 (blocks.begin () + blocks.size () / 2, blocks.end ());
1193  	WAIT (1s);
1194  	node.active.clear ();
1195  	ASSERT_TRUE (node.active.empty ());
1196  	for (auto const & block : blocks1)
1197  	{
1198  		node.scheduler.buckets.activate (block->account (), node.store.tx_begin_read ());
1199  	}
1200  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit ());
1201  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit ());
1202  	for (auto const & block : blocks2)
1203  	{
1204  		auto vote = nano::test::make_vote (nano::dev::genesis_key, { block });
1205  		node.inactive_vote_cache.vote (block->hash (), vote);
1206  	}
1207  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit () + node.active.limit (nano::election_behavior::hinted));
1208  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit () + node.active.limit (nano::election_behavior::hinted));
1209  }
1210  TEST (active_transactions, allow_limited_overflow_adapt)
1211  {
1212  	nano::test::system system;
1213  	nano::node_config config = system.default_config ();
1214  	const int aec_limit = 20;
1215  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1216  	config.active_elections_size = aec_limit;
1217  	config.active_elections_hinted_limit_percentage = 20; 
1218  	auto & node = *system.add_node (config);
1219  	auto blocks = nano::test::setup_independent_blocks (system, node, aec_limit * 4);
1220  	std::vector<std::shared_ptr<nano::block>> blocks1 (blocks.begin (), blocks.begin () + blocks.size () / 2);
1221  	std::vector<std::shared_ptr<nano::block>> blocks2 (blocks.begin () + blocks.size () / 2, blocks.end ());
1222  	WAIT (1s);
1223  	node.active.clear ();
1224  	ASSERT_TRUE (node.active.empty ());
1225  	for (auto const & block : blocks2)
1226  	{
1227  		auto vote = nano::test::make_vote (nano::dev::genesis_key, { block });
1228  		node.inactive_vote_cache.vote (block->hash (), vote);
1229  	}
1230  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit (nano::election_behavior::hinted));
1231  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit (nano::election_behavior::hinted));
1232  	for (auto const & block : blocks1)
1233  	{
1234  		node.scheduler.buckets.activate (block->account (), node.store.tx_begin_read ());
1235  	}
1236  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit ());
1237  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit ());
1238  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.cpp</div>
                </div>
                <div class="column column_space"><pre><code>3523  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3524  	ASSERT_EQ (nano::process_result::fork, node.process (*fork).code);
</pre></code></div>
                <div class="column column_space"><pre><code>947  	ASSERT_TIMELY (3s, node.active.active (receive->qualified_root ()));
948  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    