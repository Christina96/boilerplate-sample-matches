
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.79571173317451%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.h</h3>
            <pre><code>1  #ifndef LSIONTO_H
2  #define LSIONTO_H
3  #include "mine.h"
4  #include "graph.h"
5  ClassTPV(TOntoConcept, POntoConcept, TOntoConceptV) 
6  private:
7      TInt Id;
8      TStr CptNm;
9      TIntV DIdV;
10      TBool IsValid;
11      PBowSpV ConceptSpV;
12      PBowSpV SvmKeyWdSpV;
13      TIntFltKdV MedoidDIdWgtV;
14      PSVMModel CptMd;
15      TFlt Compactness;
16      TFlt Clarity;
17  private:
18      void GenMedoid(PBowDocWgtBs BowDocWgtBs);
19      UndefCopyAssign(TOntoConcept);
20  public:
21      TOntoConcept(): Id(-1), CptNm("New Concept") { }
22      TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
23          const int _Id, const TIntV& _DIdV);
24      static POntoConcept New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
25          const int _Id, const TIntV& _DIdV) { 
26              return new TOntoConcept(BowDocBs, BowDocWgtBs, _Id, _DIdV); }
27      TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
28          const int _Id, const TStr& _CptNm, const TIntV& _DIdV);
29      static POntoConcept New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
30          const int _Id, const TStr& _CptNm, const TIntV& _DIdV) { 
31              return new TOntoConcept(BowDocBs, BowDocWgtBs, _Id, _CptNm, _DIdV); }
32      int GetId() const { return Id; }
33      TStr GetName() const { return CptNm; }
34      void SetName(const TStr& NewCptNm) { CptNm = NewCptNm; }
35      bool IsCentroidValid() const { return IsValid; }
36      PBowSpV GetCentroidSpV() const { return ConceptSpV; }
37      void ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs);
38      PBowSpV GetSvmSpV() const { return SvmKeyWdSpV; }
39      void SetSvmSpV(PBowSpV NewSvmSpV) { SvmKeyWdSpV = NewSvmSpV; }
40      int GetDocs() const { return DIdV.Len(); }
41      int GetDId(const int& DIdN) const { return DIdV[DIdN]; }
42      void GetDIdV(TIntV& _DIdV) const { _DIdV=DIdV; }
43      TIntV& GetDIdVRef() { return DIdV; }
44      void SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& _DIdV);
45      void AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV);
46      void AddDId(PBowDocWgtBs BowDocWgtBs, const int& DId);
47      void DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV);
48      bool DelDId(PBowDocWgtBs BowDocWgtBs, const int& DId);
49      TStr GetKeyWdStr(PBowDocBs BowDocBs, const int& TopWords = 3,
50        const double& TopWordsWgtPrc = 1.0, const TStr& SepStr = ", ",
51        const bool& ShowWeights = false, const bool& UseMedoidP = false) const;
52      TStr GetSvmKeyWdStr(PBowDocBs BowDocBs, const int& TopWords = 3,
53        const double& TopWordsWgtPrc = 1.0, const TStr& SepStr = ", ",
54        const bool& ShowWeights = false) const;
55      void CalcCptMd(PBowDocBs BowDocBs, const TIntV& ContextDIdV,
56          const double& SvmC = 1.0, const double& SvmJ = 5.0, 
57          const int& SvmTime = -1);
58      bool IsCptMd() const { return !CptMd.Empty(); }
59      void CfyDocSpV(PBowSpV DocSpV, bool& IsDocInCpt, double& Prob) { 
60          IsDocInCpt = CptMd->GetCfyBool(DocSpV); Prob = CptMd->GetProbCfy(DocSpV); }
61      void SetCompactness(const double& NewVal) { Compactness = NewVal; }
62      double GetCompactness() const { return Compactness; }
63      void SetClarity(const double& NewVal) { Clarity = NewVal; }
64      double GetClarity() const { return Clarity; }
65  };
66  ClassTV(TOntoRltType, TOntoRltTypeV) 
67  private:
68      TStr TypeNm;
69      TBool Directed;
70      TBool Transitive;
71  public:
72      static TStr SubCptOfRltStr;
73      static TStr SimilarRltStr;
74  public:
75      TOntoRltType(): TypeNm("") {}
76      TOntoRltType(const TStr& _TypeNm, const bool& _Directed, const bool& _Transitive):
77          TypeNm(_TypeNm), Directed(_Directed), Transitive(_Transitive) { }
78      const TStr& GetName() const { return TypeNm; }
79      bool IsType(const TStr& RltTypeNm) const { return (RltTypeNm == TypeNm); }
80      bool IsDir() const { return Directed; }
81      bool IsTransitive() const { return Transitive; }
82  };
83  ClassTP(TUniqueId, PUniqueId)
84  private:
85      TInt IdCounter;
86  public:
87      TUniqueId(const int& StartId = 0): IdCounter(StartId) { };
88      static PUniqueId New(const int& StartId = 0) { return new TUniqueId(StartId); }
89      TUniqueId(TSIn& SIn): IdCounter(SIn) { }
90      static PUniqueId Load(TSIn &SIn) { return new TUniqueId(SIn); }
91      void Save(TSOut& SOut) const { IdCounter.Save(SOut); }
92      int GetNextId() { const int NextId = IdCounter; IdCounter++; return NextId; }
93  };
94  typedef enum { osatKMeans, osatCat, osatLwOntoCfier } TOntoSuggestAlgType;
95  class TOntoAlg {
96  public:
97      static void SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
98          const TIntV& DIdV, const int& _NewConceptN, PUniqueId UniqueId, 
99          TOntoConceptV& NewConceptV); 
100      static void SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
101          const TIntV& DIdV, PUniqueId UniqueId, TOntoConceptV& NewConceptV);
102      static void SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
103          const TIntV& DIdV, PLwOntoCfier LwOntoCfier, const int& _NewConcepts, 
104          PUniqueId UniqueId, TOntoConceptV& NewConceptV);
105  };
106  ClassTP(TOntoExport, POntoExport)
107  public:
108      virtual void StartExport() {};
109      virtual void EndExport() {};
110      virtual void PutCpt(const int& CptId, const TStr CptNm, 
111          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
112          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
113          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {};
114      virtual bool IsCptSubCptLink() { return false; }
115      virtual bool IsCptSuperCptLink() { return false; }
116      virtual bool IsCptDocLink() { return false; }
117      virtual bool IsCptAlwaysSvm() { return false; }
118      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
119          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {};
120      virtual bool IsDocCptLink() { return false; }
121      virtual void PutRltType(const TStr& RltNm, const bool& DirectedP,
122          const bool& TransitiveP) {};
123      virtual void PutRlt(const TStr& RltNm, const int& SrcCptId, 
124          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm) {};
125      virtual bool IsRlt() { return false; }
126  };
127  class TOntoExportPTO: TOntoExport {
128  private:
129      PSOut SOut;
130      bool DigLibP; 
131      TStr BowFNmStr;
132      TStr GetUri(const int& Id, const TStr& Nm);
133  public:
134      TOntoExportPTO(PSOut _SOut, const bool& _DigLibP, const TStr& _BowFNmStr):
135          SOut(_SOut), DigLibP(_DigLibP), BowFNmStr(_BowFNmStr) { }
136      static POntoExport New(PSOut SOut, const bool& DigLibP, const TStr& BowFNmStr) { 
137          return new TOntoExportPTO(SOut, DigLibP, BowFNmStr); }
138      virtual void StartExport();
139      virtual void EndExport();
140      virtual void PutCpt(const int& CptId, const TStr CptNm, 
141          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
142          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
143          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
144      virtual bool IsCptSubCptLink() { return false; }
145      virtual bool IsCptSuperCptLink() { return true; }
146      virtual bool IsCptDocLink() { return DigLibP; }
147      virtual bool IsCptAlwaysSvm() { return false; }
148      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
149          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
150      virtual bool IsDocCptLink() { return true; }
151  };
152  class TOntoExportProlog: TOntoExport {
153  private:
154      PSOut SOut;
155      TStr GetCptLabel(const int& CptId) { return TStr::Fmt("c%d", CptId); }
156      TStr GetInstLabel(const int& InstId) { return TStr::Fmt("id%d", InstId); }
157  public:
158      TOntoExportProlog(PSOut _SOut): SOut(_SOut) { }
159      static POntoExport New(PSOut SOut) { return new TOntoExportProlog(SOut); }
160      virtual void StartExport();
161      virtual void EndExport();
162      virtual void PutCpt(const int& CptId, const TStr CptNm, 
163          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
164          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
165          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
166      virtual bool IsCptSubCptLink() { return false; }
167      virtual bool IsCptSuperCptLink() { return true; }
168      virtual bool IsCptDocLink() { return false; }
169      virtual bool IsCptAlwaysSvm() { return false; }
170      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
171          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
172      virtual bool IsDocCptLink() { return true; }
173  };
174  class TOntoExportOWL: TOntoExport {
175  private:
176      PSOut SOut;
177      TBool StoreDocsP;
178      TBool StoreAbstractsP;
179      TStr GetUri(const int& Id, const TStr& Nm);
180  public:
181      TOntoExportOWL(PSOut _SOut, const bool& _StoreDocsP, const bool& _StoreAbstractsP): 
182        SOut(_SOut), StoreDocsP(_StoreDocsP), StoreAbstractsP(_StoreAbstractsP) { }
183      static POntoExport New(PSOut SOut, const bool& StoreDocsP, const bool& StoreAbstractsP) { 
184          return new TOntoExportOWL(SOut, StoreDocsP, StoreAbstractsP); }
185      virtual void StartExport();
186      virtual void EndExport();
187      virtual void PutCpt(const int& CptId, const TStr CptNm, 
188          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
189          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
190          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
191      virtual bool IsCptSubCptLink() { return false; }
192      virtual bool IsCptSuperCptLink() { return true; }
193      virtual bool IsCptDocLink() { return false; }
194      virtual bool IsCptAlwaysSvm() { return false; }
195      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
196          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
197      virtual bool IsDocCptLink() { return true; }
198      virtual void PutRltType(const TStr& RltNm, const bool& DirectedP,
199          const bool& TransitiveP);
200      virtual void PutRlt(const TStr& RltNm, const int& SrcCptId, 
201          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm);
202      virtual bool IsRlt() { return true; }
203  };
204  ClassTP(TOntology, POntology)
205  private:
206      PBowDocBs BowDocBs;
207      PBowDocWgtBs BowDocWgtBs;
208      PBowSim BowSim;
209      TOntoConceptV ConceptV;
210      TOntoRltTypeV RltTypeV;
211      PGraph OntoGraph;
212      PUniqueId UniqueId;
213  private:
214      void GenerateEmptyOnto();
215      TIntH CptIdPosH;
216      void RefreshCptIdPosH();
217      void ReconnectToRoot();
218      void AddRltsFromList(TIntStrPrV& InRltV, 
219          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV);
220      void AddSonDIdV(const int& CptId, TIntV& SonDIdV);
221      void CfyDIdR(const int& DId, const TIntV& CptIdV, TIntFltKdV& CfyResV);
222      void Export(POntoExport OntoExport);
223      UndefDefaultCopyAssign(TOntology);
224  public:
225      TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs,
226          const TBowSimType& BowSimType);
227      static POntology New(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
228          const TBowSimType& BowSimType) { 
229              return new TOntology(_BowDocBs, _BowDocWgtBs, BowSimType); }
230      PBowDocBs GetBowDocBs() const { return BowDocBs; }
231      PBowDocWgtBs GetBowDocWgtBs() const { return BowDocWgtBs; }
232      int GetConcepts() const { return ConceptV.Len(); }
233      int GetCptId(const int& CptIdN) const { return ConceptV[CptIdN]->GetId(); }
234      POntoConcept GetConcept(const int& CptId) const {
235          IAssertR(IsCptId(CptId), "There is no such concept!"); 
236          return ConceptV[CptIdPosH.GetDat(CptId)]; }
237      void GetCptIdV(TIntV& CptIdV);
238      bool IsCptId(const int& CptId) const { return CptIdPosH.IsKey(CptId); }
239      bool IsRootCpt(const int& CptId) const { return CptId == 0; }
240      POntoConcept GetRootCpt() const { return GetConcept(0); }
241      TStr GetCptName(const int& CptId) const { return GetConcept(CptId)->GetName(); }
242      void SetCptName(const int& CptId, const TStr& NewName);
243      int GetCptDocs(const int& CptId) const { return GetConcept(CptId)->GetDocs(); }
244      void GetCptDIdV(const int& CptId, TIntV& DIdV) const {
245          GetConcept(CptId)->GetDIdV(DIdV); }
246      void SetCptDIdV(const int& CptId, const TIntV& _NewDIdV, const bool& PropagateP);
247      TStr GetCptKeyWdStr(const int& CptId, const int WordN, const bool& UseMedoidP) const {
248          return GetConcept(CptId)->GetKeyWdStr(BowDocBs, WordN, 1.0, ", ", false, UseMedoidP); }
249      TStr GetCptSvmKeyWdStr(const int& CptId, const int WordN) const {
250          return GetConcept(CptId)->GetSvmKeyWdStr(BowDocBs, WordN); }
251      void GetCptSimV(const int& CptId, TFltIntKdV& SimCptIdV);
252      double GetCptCompactness(const int& CptId) const {
253          return GetConcept(CptId)->GetCompactness(); }
254      double GetCptClarity(const int& CptId) const {
255          return GetConcept(CptId)->GetClarity(); }
256      void CalcCptMd(const int& CptId, const double& SvmC, 
257          const double& SvmJ, const int& SvmTime);
258      void CfyDId(const int& DId, TIntFltKdV& CfyResV);
259      void IncludeLnDocs(const TStr& LnDocFNm, TIntV& NewDIdV);
260      void IncludeFolder(const TStr& FPath, TIntV& NewDIdV, const bool& RecurseDirP);
261      void AddDocToCptV(const int& DId, const TIntV& CptIdV, const bool& UpdateCentroidP);
262      void ReCalcWgtBs() { BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF); }
263      void ResetAllCptKeyWd();
264      void GetSubCptIdV(const int& CptId, TIntV& SubCptIdV);
265      void GetSuperCptIdV(const int& CptId, TIntV& SuperCptIdV);
266      bool HasSuperCpt(const int& CptId) { TIntV SuperCptIdV; 
267          GetSuperCptIdV(CptId, SuperCptIdV); return (SuperCptIdV.Len() > 0); }
268      int GetCptUnusedDocs(const int& CptId) {
269          TIntV DIdV; GetCptUnusedDIdV(CptId, DIdV); return DIdV.Len(); }
270      void GetCptUnusedDIdV(const int& CptId, TIntV& UnusedDIdV);
271      void GetCptContextDIdV(const int& CptId, TIntV& ContextDIdV, 
272          const bool& AddSonDIdP = true);
273      void GetInconsistDIdV(const int& CptId, TIntV& InconsistDIdV);
274      void GetCptDocSimV(const int& CptId, const TIntV& DIdV, TFltV& CptDocSimV);
275      void AddUpDIdV(const int& CptId, const TIntV& SubDIdV);
276      void DelUpDIdV(const int& CptId, const TIntV& SubDIdV);
277      void DelDownDIdV(const int& CptId, const TIntV& SubDIdV);
278      void DelDownDId(const int& CptId, const int& DId);
279      void GetCptInRltV(const int& CptId, TIntStrPrV& InRltV);
280      void GetCptOutRltV(const int& CptId, TIntStrPrV& OutRltV);
281      void GetCptUndirRltV(const int& CptId, TIntStrPrV& UndirRltV);
282      void GetCptRltV(const int& CptId, TIntStrPrV& InRltV, 
283          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV);
284      int GetRltTypes() const { return RltTypeV.Len(); }
285      int GetRltTypeN(const TStr& RltTypeNm) const;
286      bool IsRltType(const TStr& RltTypeNm) const { 
287          return GetRltTypeN(RltTypeNm) != -1; }
288      const TStr& GetRltTypeNm(const int& RltTypeN) const { 
289          return RltTypeV[RltTypeN].GetName(); }
290      bool IsRltDir(const TStr& RltTypeNm) const {
291          IAssertR(IsRltType(RltTypeNm), "There is no such relation!"); 
292          return RltTypeV[GetRltTypeN(RltTypeNm)].IsDir(); }
293      bool IsRltTransitive(const TStr& RltTypeNm) const  {
294          IAssertR(IsRltType(RltTypeNm), "There is no such relation!"); 
295          return RltTypeV[GetRltTypeN(RltTypeNm)].IsTransitive(); }
296      bool IsRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
297      void AddRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
298      bool DelRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
299      void SuggestConcepts(const TIntV& DIdV, const TOntoSuggestAlgType& AlgType,
300          const int& NewConceptN, TOntoConceptV& NewConceptV);
301      void SuggestSubconcepts(const int& CptId, const TOntoSuggestAlgType& AlgType,
302          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV);
303      void SuggestSubconcepts(const int& CptId, const PLwOntoCfier& LwOntoCfier,
304          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV);
305      POntoConcept GenSubconcept(const TStr& NewCptNm, const TIntV& NewCptDIdV);
306      POntoConcept GenSubconcept(const TIntV& NewCptDIdV);
307      void SuggestConceptNm(const int& CptId, const TVec<PLwOntoCfier>& LwOntoCfierV, 
308          const int& MxSuggestNms, TStrV& SuggestNmV, TIntV& SuggestSuppV,
309          TIntV& SuggestVocNV);
310      void AddConcept(const POntoConcept& NewCpt, const int& FatherCptId);
311      void BreakConcept(const int& OldCptId, const TOntoConceptV& NewCptV);
<span onclick='openModal()' class='match'>312      void DeleteConcept(const int& CptId, const bool& DoRedirect);
313      void PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId); 
314      void UniteConcepts(const int& CptId1, const int& CptId2);
315      void CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP);
</span>316      void NewConcept();
317      void ExtractKeywords(const int& CptId);
318      void CalcCptCompactness(const int& CptId);
319      void CalcCptClarity(const int& CptId);
320      PGraph GetGraph() const { return OntoGraph; }
321      void PrepareGraph(const int& SelectedCptId);
322      void PlaceGraph();
323      void SaveTxtStat(const TStr& FNm) { }
324      void ExportPTO(const TStr& FNm, const bool& DigLibP);
325      void ExportProlog(const TStr& FNm);
326      void ExportOwl(const TStr& FNm, const bool& StoreDocsP, const bool& StoreAbstractsP);
327      static POntology ImportPTO(const TStr& RdfFNm, const TStr& BowFNm);
328  };
329  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCUTIL_UNICHARSET_H_
2  #define TESSERACT_CCUTIL_UNICHARSET_H_
3  #include "errcode.h"
4  #include "unicharmap.h"
5  #include <tesseract/unichar.h>
6  #include "helpers.h"
7  #include "serialis.h"
8  #include <functional> 
9  namespace tesseract {
10  enum SpecialUnicharCodes {
11    UNICHAR_SPACE,
12    UNICHAR_JOINED,
13    UNICHAR_BROKEN,
14    SPECIAL_UNICHAR_CODES_COUNT
15  };
16  enum class OldUncleanUnichars {
17    kFalse,
18    kTrue,
19  };
20  class TESS_API CHAR_FRAGMENT {
21  public:
22    static const int kMinLen = 6;
23    static const int kMaxLen = 3 + UNICHAR_LEN + 2;
24    static const int kMaxChunks = 5;
25    inline void set_all(const char *unichar, int pos, int total, bool natural) {
26      set_unichar(unichar);
27      set_pos(pos);
28      set_total(total);
29      set_natural(natural);
30    }
31    inline void set_unichar(const char *uch) {
32      strncpy(this->unichar, uch, sizeof(this->unichar));
33      this->unichar[UNICHAR_LEN] = '\0';
34    }
35    inline void set_pos(int p) {
36      this->pos = p;
37    }
38    inline void set_total(int t) {
39      this->total = t;
40    }
41    inline const char *get_unichar() const {
42      return this->unichar;
43    }
44    inline int get_pos() const {
45      return this->pos;
46    }
47    inline int get_total() const {
48      return this->total;
49    }
50    static std::string to_string(const char *unichar, int pos, int total,
51                                 bool natural);
52    std::string to_string() const {
53      return to_string(unichar, pos, total, natural);
54    }
55    inline bool equals(const char *other_unichar, int other_pos,
56                       int other_total) const {
57      return (strcmp(this->unichar, other_unichar) == 0 &&
58              this->pos == other_pos && this->total == other_total);
59    }
60    inline bool equals(const CHAR_FRAGMENT *other) const {
61      return this->equals(other->get_unichar(), other->get_pos(),
62                          other->get_total());
63    }
64    inline bool is_continuation_of(const CHAR_FRAGMENT *fragment) const {
65      return (strcmp(this->unichar, fragment->get_unichar()) == 0 &&
66              this->total == fragment->get_total() &&
67              this->pos == fragment->get_pos() + 1);
68    }
69    inline bool is_beginning() const {
70      return this->pos == 0;
71    }
72    inline bool is_ending() const {
73      return this->pos == this->total - 1;
74    }
75    inline bool is_natural() const {
76      return natural;
77    }
78    void set_natural(bool value) {
79      natural = value;
80    }
81    static CHAR_FRAGMENT *parse_from_string(const char *str);
82  private:
83    char unichar[UNICHAR_LEN + 1];
84    bool natural;
85    int16_t pos;   
86    int16_t total; 
87  };
88  class TESS_API UNICHARSET {
89  public:
90    static const char *kCustomLigatures[][2];
91    static const char *kSpecialUnicharCodes[SPECIAL_UNICHAR_CODES_COUNT];
92    enum Direction {
93      U_LEFT_TO_RIGHT = 0,
94      U_RIGHT_TO_LEFT = 1,
95      U_EUROPEAN_NUMBER = 2,
96      U_EUROPEAN_NUMBER_SEPARATOR = 3,
97      U_EUROPEAN_NUMBER_TERMINATOR = 4,
98      U_ARABIC_NUMBER = 5,
99      U_COMMON_NUMBER_SEPARATOR = 6,
100      U_BLOCK_SEPARATOR = 7,
101      U_SEGMENT_SEPARATOR = 8,
102      U_WHITE_SPACE_NEUTRAL = 9,
103      U_OTHER_NEUTRAL = 10,
104      U_LEFT_TO_RIGHT_EMBEDDING = 11,
105      U_LEFT_TO_RIGHT_OVERRIDE = 12,
106      U_RIGHT_TO_LEFT_ARABIC = 13,
107      U_RIGHT_TO_LEFT_EMBEDDING = 14,
108      U_RIGHT_TO_LEFT_OVERRIDE = 15,
109      U_POP_DIRECTIONAL_FORMAT = 16,
110      U_DIR_NON_SPACING_MARK = 17,
111      U_BOUNDARY_NEUTRAL = 18,
112      U_FIRST_STRONG_ISOLATE = 19,
113      U_LEFT_TO_RIGHT_ISOLATE = 20,
114      U_RIGHT_TO_LEFT_ISOLATE = 21,
115      U_POP_DIRECTIONAL_ISOLATE = 22,
116  #ifndef U_HIDE_DEPRECATED_API
117      U_CHAR_DIRECTION_COUNT
118  #endif 
119    };
120    UNICHARSET();
121    ~UNICHARSET();
<span onclick='openModal()' class='match'>122    UNICHAR_ID unichar_to_id(const char *const unichar_repr) const;
123    UNICHAR_ID unichar_to_id(const char *const unichar_repr, int length) const;
124    int step(const char *str) const;
</span>125    bool encodable_string(const char *str, unsigned *first_bad_position) const;
126    bool encode_string(const char *str, bool give_up_on_failure,
127                       std::vector<UNICHAR_ID> *encoding,
128                       std::vector<char> *lengths,
129                       unsigned *encoded_length) const;
130    const char *id_to_unichar(UNICHAR_ID id) const;
131    const char *id_to_unichar_ext(UNICHAR_ID id) const;
132    static std::string debug_utf8_str(const char *str);
133    static std::string CleanupString(const char *utf8_str) {
134      return CleanupString(utf8_str, strlen(utf8_str));
135    }
136    static std::string CleanupString(const char *utf8_str, size_t length);
137    std::string debug_str(UNICHAR_ID id) const;
138    std::string debug_str(const char *unichar_repr) const {
139      return debug_str(unichar_to_id(unichar_repr));
140    }
141    void unichar_insert(const char *const unichar_repr,
142                        OldUncleanUnichars old_style);
143    void unichar_insert(const char *const unichar_repr) {
144      unichar_insert(unichar_repr, OldUncleanUnichars::kFalse);
145    }
146    void unichar_insert_backwards_compatible(const char *const unichar_repr) {
147      std::string cleaned = CleanupString(unichar_repr);
148      if (cleaned != unichar_repr) {
149        unichar_insert(unichar_repr, OldUncleanUnichars::kTrue);
150      } else {
151        auto old_size = size();
152        unichar_insert(unichar_repr, OldUncleanUnichars::kFalse);
153        if (size() == old_size) {
154          unichar_insert(unichar_repr, OldUncleanUnichars::kTrue);
155        }
156      }
157    }
158    bool contains_unichar_id(UNICHAR_ID unichar_id) const {
159      return static_cast<size_t>(unichar_id) < unichars.size();
160    }
161    bool contains_unichar(const char *const unichar_repr) const;
162    bool contains_unichar(const char *const unichar_repr, int length) const;
163    bool eq(UNICHAR_ID unichar_id, const char *const unichar_repr) const;
164    void delete_pointers_in_unichars() {
165      for (auto &unichar : unichars) {
166        delete unichar.properties.fragment;
167        unichar.properties.fragment = nullptr;
168      }
169    }
170    void clear() {
171      if (script_table != nullptr) {
172        for (int i = 0; i < script_table_size_used; ++i) {
173          delete[] script_table[i];
174        }
175        delete[] script_table;
176        script_table = nullptr;
177        script_table_size_used = 0;
178      }
179      script_table_size_reserved = 0;
180      delete_pointers_in_unichars();
181      unichars.clear();
182      ids.clear();
183      top_bottom_set_ = false;
184      script_has_upper_lower_ = false;
185      script_has_xheight_ = false;
186      old_style_included_ = false;
187      null_sid_ = 0;
188      common_sid_ = 0;
189      latin_sid_ = 0;
190      cyrillic_sid_ = 0;
191      greek_sid_ = 0;
192      han_sid_ = 0;
193      hiragana_sid_ = 0;
194      katakana_sid_ = 0;
195      thai_sid_ = 0;
196      hangul_sid_ = 0;
197      default_sid_ = 0;
198    }
199    size_t size() const {
200      return unichars.size();
201    }
202    bool save_to_file(const char *const filename) const {
203      FILE *file = fopen(filename, "w+b");
204      if (file == nullptr) {
205        return false;
206      }
207      bool result = save_to_file(file);
208      fclose(file);
209      return result;
210    }
211    bool save_to_file(FILE *file) const {
212      std::string str;
213      return save_to_string(str) &&
214             tesseract::Serialize(file, &str[0], str.length());
215    }
216    bool save_to_file(tesseract::TFile *file) const {
217      std::string str;
218      return save_to_string(str) && file->Serialize(&str[0], str.length());
219    }
220    bool save_to_string(std::string &str) const;
221    bool load_from_file(const char *const filename, bool skip_fragments) {
222      FILE *file = fopen(filename, "rb");
223      if (file == nullptr) {
224        return false;
225      }
226      bool result = load_from_file(file, skip_fragments);
227      fclose(file);
228      return result;
229    }
230    bool load_from_file(const char *const filename) {
231      return load_from_file(filename, false);
232    }
233    bool load_from_file(FILE *file, bool skip_fragments);
234    bool load_from_file(FILE *file) {
235      return load_from_file(file, false);
236    }
237    bool load_from_file(tesseract::TFile *file, bool skip_fragments);
238    void post_load_setup();
239    bool major_right_to_left() const;
240    void set_black_and_whitelist(const char *blacklist, const char *whitelist,
241                                 const char *unblacklist);
242    void set_isalpha(UNICHAR_ID unichar_id, bool value) {
243      unichars[unichar_id].properties.isalpha = value;
244    }
245    void set_islower(UNICHAR_ID unichar_id, bool value) {
246      unichars[unichar_id].properties.islower = value;
247    }
248    void set_isupper(UNICHAR_ID unichar_id, bool value) {
249      unichars[unichar_id].properties.isupper = value;
250    }
251    void set_isdigit(UNICHAR_ID unichar_id, bool value) {
252      unichars[unichar_id].properties.isdigit = value;
253    }
254    void set_ispunctuation(UNICHAR_ID unichar_id, bool value) {
255      unichars[unichar_id].properties.ispunctuation = value;
256    }
257    void set_isngram(UNICHAR_ID unichar_id, bool value) {
258      unichars[unichar_id].properties.isngram = value;
259    }
260    void set_script(UNICHAR_ID unichar_id, const char *value) {
261      unichars[unichar_id].properties.script_id = add_script(value);
262    }
263    void set_other_case(UNICHAR_ID unichar_id, UNICHAR_ID other_case) {
264      unichars[unichar_id].properties.other_case = other_case;
265    }
266    void set_direction(UNICHAR_ID unichar_id, UNICHARSET::Direction value) {
267      unichars[unichar_id].properties.direction = value;
268    }
269    void set_mirror(UNICHAR_ID unichar_id, UNICHAR_ID mirror) {
270      unichars[unichar_id].properties.mirror = mirror;
271    }
272    void set_normed(UNICHAR_ID unichar_id, const char *normed) {
273      unichars[unichar_id].properties.normed = normed;
274      unichars[unichar_id].properties.normed_ids.clear();
275    }
276    void set_normed_ids(UNICHAR_ID unichar_id);
277    bool get_isalpha(UNICHAR_ID unichar_id) const {
278      if (INVALID_UNICHAR_ID == unichar_id) {
279        return false;
280      }
281      ASSERT_HOST(contains_unichar_id(unichar_id));
282      return unichars[unichar_id].properties.isalpha;
283    }
284    bool get_islower(UNICHAR_ID unichar_id) const {
285      if (INVALID_UNICHAR_ID == unichar_id) {
286        return false;
287      }
288      ASSERT_HOST(contains_unichar_id(unichar_id));
289      return unichars[unichar_id].properties.islower;
290    }
291    bool get_isupper(UNICHAR_ID unichar_id) const {
292      if (INVALID_UNICHAR_ID == unichar_id) {
293        return false;
294      }
295      ASSERT_HOST(contains_unichar_id(unichar_id));
296      return unichars[unichar_id].properties.isupper;
297    }
298    bool get_isdigit(UNICHAR_ID unichar_id) const {
299      if (INVALID_UNICHAR_ID == unichar_id) {
300        return false;
301      }
302      ASSERT_HOST(contains_unichar_id(unichar_id));
303      return unichars[unichar_id].properties.isdigit;
304    }
305    bool get_ispunctuation(UNICHAR_ID unichar_id) const {
306      if (INVALID_UNICHAR_ID == unichar_id) {
307        return false;
308      }
309      ASSERT_HOST(contains_unichar_id(unichar_id));
310      return unichars[unichar_id].properties.ispunctuation;
311    }
312    bool get_isngram(UNICHAR_ID unichar_id) const {
313      if (INVALID_UNICHAR_ID == unichar_id) {
314        return false;
315      }
316      ASSERT_HOST(contains_unichar_id(unichar_id));
317      return unichars[unichar_id].properties.isngram;
318    }
319    bool get_isprivate(UNICHAR_ID unichar_id) const;
320    bool top_bottom_useful() const {
321      return top_bottom_set_;
322    }
323    void set_ranges_empty();
324    void SetPropertiesFromOther(const UNICHARSET &src) {
325      PartialSetPropertiesFromOther(0, src);
326    }
327    void PartialSetPropertiesFromOther(int start_index, const UNICHARSET &src);
328    void ExpandRangesFromOther(const UNICHARSET &src);
329    void CopyFrom(const UNICHARSET &src);
330    void AppendOtherUnicharset(const UNICHARSET &src);
331    bool SizesDistinct(UNICHAR_ID id1, UNICHAR_ID id2) const;
332    void get_top_bottom(UNICHAR_ID unichar_id, int *min_bottom, int *max_bottom,
333                        int *min_top, int *max_top) const {
334      if (INVALID_UNICHAR_ID == unichar_id) {
335        *min_bottom = *min_top = 0;
336        *max_bottom = *max_top = 256; 
337        return;
338      }
339      ASSERT_HOST(contains_unichar_id(unichar_id));
340      *min_bottom = unichars[unichar_id].properties.min_bottom;
341      *max_bottom = unichars[unichar_id].properties.max_bottom;
342      *min_top = unichars[unichar_id].properties.min_top;
343      *max_top = unichars[unichar_id].properties.max_top;
344    }
345    void set_top_bottom(UNICHAR_ID unichar_id, int min_bottom, int max_bottom,
346                        int min_top, int max_top) {
347      unichars[unichar_id].properties.min_bottom =
348          ClipToRange<int>(min_bottom, 0, UINT8_MAX);
349      unichars[unichar_id].properties.max_bottom =
350          ClipToRange<int>(max_bottom, 0, UINT8_MAX);
351      unichars[unichar_id].properties.min_top =
352          ClipToRange<int>(min_top, 0, UINT8_MAX);
353      unichars[unichar_id].properties.max_top =
354          ClipToRange<int>(max_top, 0, UINT8_MAX);
355    }
356    void get_width_stats(UNICHAR_ID unichar_id, float *width,
357                         float *width_sd) const {
358      if (INVALID_UNICHAR_ID == unichar_id) {
359        *width = 0.0f;
360        *width_sd = 0.0f;
361        return;
362      }
363      ASSERT_HOST(contains_unichar_id(unichar_id));
364      *width = unichars[unichar_id].properties.width;
365      *width_sd = unichars[unichar_id].properties.width_sd;
366    }
367    void set_width_stats(UNICHAR_ID unichar_id, float width, float width_sd) {
368      unichars[unichar_id].properties.width = width;
369      unichars[unichar_id].properties.width_sd = width_sd;
370    }
371    void get_bearing_stats(UNICHAR_ID unichar_id, float *bearing,
372                           float *bearing_sd) const {
373      if (INVALID_UNICHAR_ID == unichar_id) {
374        *bearing = *bearing_sd = 0.0f;
375        return;
376      }
377      ASSERT_HOST(contains_unichar_id(unichar_id));
378      *bearing = unichars[unichar_id].properties.bearing;
379      *bearing_sd = unichars[unichar_id].properties.bearing_sd;
380    }
381    void set_bearing_stats(UNICHAR_ID unichar_id, float bearing,
382                           float bearing_sd) {
383      unichars[unichar_id].properties.bearing = bearing;
384      unichars[unichar_id].properties.bearing_sd = bearing_sd;
385    }
386    void get_advance_stats(UNICHAR_ID unichar_id, float *advance,
387                           float *advance_sd) const {
388      if (INVALID_UNICHAR_ID == unichar_id) {
389        *advance = *advance_sd = 0;
390        return;
391      }
392      ASSERT_HOST(contains_unichar_id(unichar_id));
393      *advance = unichars[unichar_id].properties.advance;
394      *advance_sd = unichars[unichar_id].properties.advance_sd;
395    }
396    void set_advance_stats(UNICHAR_ID unichar_id, float advance,
397                           float advance_sd) {
398      unichars[unichar_id].properties.advance = advance;
399      unichars[unichar_id].properties.advance_sd = advance_sd;
400    }
401    bool PropertiesIncomplete(UNICHAR_ID unichar_id) const {
402      return unichars[unichar_id].properties.AnyRangeEmpty();
403    }
404    bool IsSpaceDelimited(UNICHAR_ID unichar_id) const {
405      if (INVALID_UNICHAR_ID == unichar_id) {
406        return true;
407      }
408      int script_id = get_script(unichar_id);
409      return script_id != han_sid_ && script_id != thai_sid_ &&
410             script_id != hangul_sid_ && script_id != hiragana_sid_ &&
411             script_id != katakana_sid_;
412    }
413    int get_script(UNICHAR_ID unichar_id) const {
414      if (INVALID_UNICHAR_ID == unichar_id) {
415        return null_sid_;
416      }
417      ASSERT_HOST(contains_unichar_id(unichar_id));
418      return unichars[unichar_id].properties.script_id;
419    }
420    unsigned int get_properties(UNICHAR_ID unichar_id) const;
421    char get_chartype(UNICHAR_ID unichar_id) const;
422    UNICHAR_ID get_other_case(UNICHAR_ID unichar_id) const {
423      if (INVALID_UNICHAR_ID == unichar_id) {
424        return INVALID_UNICHAR_ID;
425      }
426      ASSERT_HOST(contains_unichar_id(unichar_id));
427      return unichars[unichar_id].properties.other_case;
428    }
429    Direction get_direction(UNICHAR_ID unichar_id) const {
430      if (INVALID_UNICHAR_ID == unichar_id) {
431        return UNICHARSET::U_OTHER_NEUTRAL;
432      }
433      ASSERT_HOST(contains_unichar_id(unichar_id));
434      return unichars[unichar_id].properties.direction;
435    }
436    UNICHAR_ID get_mirror(UNICHAR_ID unichar_id) const {
437      if (INVALID_UNICHAR_ID == unichar_id) {
438        return INVALID_UNICHAR_ID;
439      }
440      ASSERT_HOST(contains_unichar_id(unichar_id));
441      return unichars[unichar_id].properties.mirror;
442    }
443    UNICHAR_ID to_lower(UNICHAR_ID unichar_id) const {
444      if (INVALID_UNICHAR_ID == unichar_id) {
445        return INVALID_UNICHAR_ID;
446      }
447      ASSERT_HOST(contains_unichar_id(unichar_id));
448      if (unichars[unichar_id].properties.islower) {
449        return unichar_id;
450      }
451      return unichars[unichar_id].properties.other_case;
452    }
453    UNICHAR_ID to_upper(UNICHAR_ID unichar_id) const {
454      if (INVALID_UNICHAR_ID == unichar_id) {
455        return INVALID_UNICHAR_ID;
456      }
457      ASSERT_HOST(contains_unichar_id(unichar_id));
458      if (unichars[unichar_id].properties.isupper) {
459        return unichar_id;
460      }
461      return unichars[unichar_id].properties.other_case;
462    }
463    bool has_special_codes() const {
464      return get_fragment(UNICHAR_BROKEN) != nullptr &&
465             strcmp(id_to_unichar(UNICHAR_BROKEN),
466                    kSpecialUnicharCodes[UNICHAR_BROKEN]) == 0;
467    }
468    bool AnyRepeatedUnicodes() const;
469    const CHAR_FRAGMENT *get_fragment(UNICHAR_ID unichar_id) const {
470      if (INVALID_UNICHAR_ID == unichar_id) {
471        return nullptr;
472      }
473      ASSERT_HOST(contains_unichar_id(unichar_id));
474      return unichars[unichar_id].properties.fragment;
475    }
476    bool get_isalpha(const char *const unichar_repr) const {
477      return get_isalpha(unichar_to_id(unichar_repr));
478    }
479    bool get_islower(const char *const unichar_repr) const {
480      return get_islower(unichar_to_id(unichar_repr));
481    }
482    bool get_isupper(const char *const unichar_repr) const {
483      return get_isupper(unichar_to_id(unichar_repr));
484    }
485    bool get_isdigit(const char *const unichar_repr) const {
486      return get_isdigit(unichar_to_id(unichar_repr));
487    }
488    bool get_ispunctuation(const char *const unichar_repr) const {
489      return get_ispunctuation(unichar_to_id(unichar_repr));
490    }
491    unsigned int get_properties(const char *const unichar_repr) const {
492      return get_properties(unichar_to_id(unichar_repr));
493    }
494    char get_chartype(const char *const unichar_repr) const {
495      return get_chartype(unichar_to_id(unichar_repr));
496    }
497    int get_script(const char *const unichar_repr) const {
498      return get_script(unichar_to_id(unichar_repr));
499    }
500    const CHAR_FRAGMENT *get_fragment(const char *const unichar_repr) const {
501      if (unichar_repr == nullptr || unichar_repr[0] == '\0' ||
502          !ids.contains(unichar_repr, false)) {
503        return nullptr;
504      }
505      return get_fragment(unichar_to_id(unichar_repr));
506    }
507    bool get_isalpha(const char *const unichar_repr, int length) const {
508      return get_isalpha(unichar_to_id(unichar_repr, length));
509    }
510    bool get_islower(const char *const unichar_repr, int length) const {
511      return get_islower(unichar_to_id(unichar_repr, length));
512    }
513    bool get_isupper(const char *const unichar_repr, int length) const {
514      return get_isupper(unichar_to_id(unichar_repr, length));
515    }
516    bool get_isdigit(const char *const unichar_repr, int length) const {
517      return get_isdigit(unichar_to_id(unichar_repr, length));
518    }
519    bool get_ispunctuation(const char *const unichar_repr, int length) const {
520      return get_ispunctuation(unichar_to_id(unichar_repr, length));
521    }
522    const char *get_normed_unichar(UNICHAR_ID unichar_id) const {
523      if (unichar_id == UNICHAR_SPACE) {
524        return " ";
525      }
526      return unichars[unichar_id].properties.normed.c_str();
527    }
528    const std::vector<UNICHAR_ID> &normed_ids(UNICHAR_ID unichar_id) const {
529      return unichars[unichar_id].properties.normed_ids;
530    }
531    int get_script(const char *const unichar_repr, int length) const {
532      return get_script(unichar_to_id(unichar_repr, length));
533    }
534    int get_script_table_size() const {
535      return script_table_size_used;
536    }
537    const char *get_script_from_script_id(int id) const {
538      if (id >= script_table_size_used || id < 0) {
539        return null_script;
540      }
541      return script_table[id];
542    }
543    int get_script_id_from_name(const char *script_name) const;
544    bool is_null_script(const char *script) const {
545      return script == null_script;
546    }
547    int add_script(const char *script);
548    bool get_enabled(UNICHAR_ID unichar_id) const {
549      ASSERT_HOST(contains_unichar_id(unichar_id));
550      return unichars[unichar_id].properties.enabled;
551    }
552    int null_sid() const {
553      return null_sid_;
554    }
555    int common_sid() const {
556      return common_sid_;
557    }
558    int latin_sid() const {
559      return latin_sid_;
560    }
561    int cyrillic_sid() const {
562      return cyrillic_sid_;
563    }
564    int greek_sid() const {
565      return greek_sid_;
566    }
567    int han_sid() const {
568      return han_sid_;
569    }
570    int hiragana_sid() const {
571      return hiragana_sid_;
572    }
573    int katakana_sid() const {
574      return katakana_sid_;
575    }
576    int thai_sid() const {
577      return thai_sid_;
578    }
579    int hangul_sid() const {
580      return hangul_sid_;
581    }
582    int default_sid() const {
583      return default_sid_;
584    }
585    bool script_has_upper_lower() const {
586      return script_has_upper_lower_;
587    }
588    bool script_has_xheight() const {
589      return script_has_xheight_;
590    }
591  private:
592    struct TESS_API UNICHAR_PROPERTIES {
593      UNICHAR_PROPERTIES();
594      void Init();
595      void SetRangesOpen();
596      void SetRangesEmpty();
597      bool AnyRangeEmpty() const;
598      void ExpandRangesFrom(const UNICHAR_PROPERTIES &src);
599      void CopyFrom(const UNICHAR_PROPERTIES &src);
600      bool isalpha;
601      bool islower;
602      bool isupper;
603      bool isdigit;
604      bool ispunctuation;
605      bool isngram;
606      bool enabled;
607      uint8_t min_bottom;
608      uint8_t max_bottom;
609      uint8_t min_top;
610      uint8_t max_top;
611      float width;
612      float width_sd;
613      float bearing;
614      float bearing_sd;
615      float advance;
616      float advance_sd;
617      int script_id;
618      UNICHAR_ID other_case; 
619      Direction direction;   
620      UNICHAR_ID mirror;
621      std::vector<UNICHAR_ID> normed_ids;
622      std::string normed; 
623      CHAR_FRAGMENT *fragment;
624    };
625    struct UNICHAR_SLOT {
626      char representation[UNICHAR_LEN + 1];
627      UNICHAR_PROPERTIES properties;
628    };
629    void encode_string(const char *str, int str_index, int str_length,
630                       std::vector<UNICHAR_ID> *encoding,
631                       std::vector<char> *lengths, unsigned *best_total_length,
632                       std::vector<UNICHAR_ID> *best_encoding,
633                       std::vector<char> *best_lengths) const;
634    bool GetStrProperties(const char *utf8_str, UNICHAR_PROPERTIES *props) const;
635    bool load_via_fgets(const std::function<char *(char *, int)> &fgets_cb,
636                        bool skip_fragments);
637    static const char *kCleanupMaps[][2];
638    static const char *null_script;
639    std::vector<UNICHAR_SLOT> unichars;
640    UNICHARMAP ids;
641    char **script_table;
642    int script_table_size_used;
643    int script_table_size_reserved;
644    bool top_bottom_set_;
645    bool script_has_upper_lower_;
646    bool script_has_xheight_;
647    bool old_style_included_;
648    int null_sid_;
649    int common_sid_;
650    int latin_sid_;
651    int cyrillic_sid_;
652    int greek_sid_;
653    int han_sid_;
654    int hiragana_sid_;
655    int katakana_sid_;
656    int thai_sid_;
657    int hangul_sid_;
658    int default_sid_;
659  };
660  } 
661  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.h</div>
                </div>
                <div class="column column_space"><pre><code>312      void DeleteConcept(const int& CptId, const bool& DoRedirect);
313      void PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId); 
314      void UniteConcepts(const int& CptId1, const int& CptId2);
315      void CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP);
</pre></code></div>
                <div class="column column_space"><pre><code>122    UNICHAR_ID unichar_to_id(const char *const unichar_repr) const;
123    UNICHAR_ID unichar_to_id(const char *const unichar_repr, int length) const;
124    int step(const char *str) const;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    