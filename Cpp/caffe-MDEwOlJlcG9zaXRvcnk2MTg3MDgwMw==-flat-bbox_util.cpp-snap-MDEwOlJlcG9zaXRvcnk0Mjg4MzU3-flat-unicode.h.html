
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.743927125506073%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-bbox_util.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <csignal>
3  #include <ctime>
4  #include <functional>
5  #include <map>
6  #include <set>
7  #include <string>
8  #include <utility>
9  #include <vector>
10  #include "boost/iterator/counting_iterator.hpp"
11  #include "caffe/util/bbox_util.hpp"
12  #ifdef ENABLE_NMS_OPTIMIZATION
13  #include <immintrin.h>
14  #include "omp.h"
15  #endif
16  namespace caffe {
17  bool SortBBoxAscend(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
18    return bbox1.score() < bbox2.score();
19  }
20  bool SortBBoxDescend(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
21    return bbox1.score() > bbox2.score();
22  }
23  template <typename T>
24  bool SortScorePairAscend(const pair<float, T>& pair1,
25                           const pair<float, T>& pair2) {
26    return pair1.first < pair2.first;
27  }
28  template bool SortScorePairAscend(const pair<float, int>& pair1,
29                                    const pair<float, int>& pair2);
30  template bool SortScorePairAscend(const pair<float, pair<int, int> >& pair1,
31                                    const pair<float, pair<int, int> >& pair2);
32  template <typename T>
33  bool SortScorePairDescend(const pair<float, T>& pair1,
34                            const pair<float, T>& pair2) {
35    return pair1.first > pair2.first;
36  }
37  template bool SortScorePairDescend(const pair<float, int>& pair1,
38                                     const pair<float, int>& pair2);
39  template bool SortScorePairDescend(const pair<float, pair<int, int> >& pair1,
40                                     const pair<float, pair<int, int> >& pair2);
41  #ifdef ENABLE_NMS_OPTIMIZATION
42  #define DIVUP(m, n)((m) / (n) + ((m) % (n) > 0))
43  typedef unsigned long long int uint64_t;
44  static inline float max(float a, float b) { return (a) > (b) ? (a) : (b); }
45  static inline float min(float a, float b) { return (a) < (b) ? (a) : (b); }
46  #define MASK_ELEM(x, y) \
47    ((uint64_t*)((char*)mask_tbl + x * blocks * sizeof(uint64_t)) + y)
48  void cpu_nms_avx512_parallize_inner(int* __restrict keep_out, 
49                                      int* __restrict num_out, 
50                                      const float* __restrict x1,
51                                      const float* __restrict y1,
52                                      const float* __restrict x2, 
53                                      const float* __restrict y2,
54                                      int64_t boxes_num, 
55                                      float thresh_f)
56  {
57      const int blocks = DIVUP(boxes_num, 64);
58      uint64_t *mask_tbl = (uint64_t *)aligned_alloc(64, blocks * sizeof(uint64_t));
59      memset(mask_tbl, 0, sizeof(uint64_t) * blocks);
60      uint64_t i = 0, j = 0;
61      uint64_t num_to_keep = 0;
62      for (i = 0; i < boxes_num; i++) {
63          if (mask_tbl[i/64] & (1ull << (i % 64))) {
64              continue;
65          }
66          keep_out[num_to_keep++] = i;
67          __m512 x1_a = _mm512_set1_ps(x1[i]);
68          __m512 x2_a = _mm512_set1_ps(x2[i]);
69          __m512 y1_a = _mm512_set1_ps(y1[i]);
70          __m512 y2_a = _mm512_set1_ps(y2[i]);
71          __m512 zero = _mm512_setzero_ps();
72          __m512 Sa_w = _mm512_sub_ps(x2_a, x1_a);
73          __m512 Sa_h = _mm512_sub_ps(y2_a, y1_a);
74          __m512 Sa = _mm512_mul_ps(Sa_w, Sa_h);
75          __m512 thresh = _mm512_set1_ps(thresh_f);
76          for (j = i + 1; (j & 0xf) && (j < boxes_num); j ++) {
77              if (mask_tbl[j/64] & (1ull << (j % 64))) {
78                  continue;
79              }
80              float xx1 = max(x1[i], x1[j]);
81              float yy1 = max(y1[i], y1[j]);
82              float xx2 = min(x2[i], x2[j]);
83              float yy2 = min(y2[i], y2[j]);
84              float w = max(0.0f, xx2 - xx1 );
85              float h = max(0.0f, yy2 - yy1 );
86              float interS = w * h;
87              float Sa = (x2[i] - x1[i] ) * (y2[i] - y1[i] );
88              float Sb = (x2[j] - x1[j] ) * (y2[j] - y1[j] );
89              if (interS > thresh_f * (Sa + Sb - interS)) {
90                  mask_tbl[j/64] |= 1ull << (j % 64);
91              }
92          }
93          if (!(j & 0xf) && (j & 0x1f) && (j + 16 <= boxes_num)) {
94              __m512 x1_b = _mm512_load_ps(x1 + j);
95              __m512 y1_b = _mm512_load_ps(y1 + j);
96              __m512 x2_b = _mm512_load_ps(x2 + j);
97              __m512 y2_b = _mm512_load_ps(y2 + j);
98              __m512 xx1 = _mm512_max_ps(x1_a, x1_b);
99              __m512 yy1 = _mm512_max_ps(y1_a, y1_b);
100              __m512 xx2 = _mm512_min_ps(x2_a, x2_b);
101              __m512 yy2 = _mm512_min_ps(y2_a, y2_b);
102              __m512 w = _mm512_sub_ps(xx2, xx1);
103              __m512 h = _mm512_sub_ps(yy2, yy1);
104              w = _mm512_max_ps(w, zero);
105              h = _mm512_max_ps(h, zero);
106              __m512 interS = _mm512_mul_ps(w, h);
107              __m512 Sb_w = _mm512_sub_ps(x2_b, x1_b);
108              __m512 Sb_h = _mm512_sub_ps(y2_b, y1_b);
109              __m512 Sb = _mm512_mul_ps(Sb_w, Sb_h);
110              __m512 ovr = _mm512_add_ps(Sa, Sb);
111              ovr = _mm512_sub_ps(ovr, interS);
112              ovr = _mm512_mul_ps(ovr, thresh);
113              __mmask16 gt = _mm512_cmp_ps_mask(interS, ovr, _CMP_GT_OS);
114              uint64_t mask = gt;
115              mask_tbl[j/64] |= (mask) << (j % 64);
116              j += 16;
117          }
118          if (!(j & 0x1f) && (j & 0x3f) && (j + 32 <= boxes_num)) {
119              __m512 x1_b0 = _mm512_load_ps(x1 + j);
120              __m512 y1_b0 = _mm512_load_ps(y1 + j);
121              __m512 x2_b0 = _mm512_load_ps(x2 + j);
122              __m512 y2_b0 = _mm512_load_ps(y2 + j);
123              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
124              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
125              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
126              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
127              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
128              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
129              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
130              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
131              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
132              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
133              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
134              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
135              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
136              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
137              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
138              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
139              w0 = _mm512_max_ps(w0, zero);
140              h0 = _mm512_max_ps(h0, zero);
141              w1 = _mm512_max_ps(w1, zero);
142              h1 = _mm512_max_ps(h1, zero);
143              __m512 interS_0 = _mm512_mul_ps(w0, h0);
144              __m512 interS_1 = _mm512_mul_ps(w1, h1);
145              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
146              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
147              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
148              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
149              __m512 ovr0 = _mm512_fmadd_ps(Sb_w0, Sb_h0, Sa);
150              __m512 ovr1 = _mm512_fmadd_ps(Sb_w1, Sb_h1, Sa);
151              ovr0 = _mm512_sub_ps(ovr0, interS_0);
152              ovr1 = _mm512_sub_ps(ovr1, interS_1);
153              ovr0 = _mm512_mul_ps(ovr0, thresh);
154              ovr1 = _mm512_mul_ps(ovr1, thresh);
155              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
156              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
157              uint64_t mask = (gt0) | ((uint64_t)gt1 << 16);
158              mask_tbl[j/64] |= (mask) << (j % 64);
159              j += 32;
160          }
161          for (; (j + 64) <= boxes_num; j += 64) {
162              __m512 x1_b0 = _mm512_load_ps(x1 + j);
163              __m512 y1_b0 = _mm512_load_ps(y1 + j);
164              __m512 x2_b0 = _mm512_load_ps(x2 + j);
165              __m512 y2_b0 = _mm512_load_ps(y2 + j);
166              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
167              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
168              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
169              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
170              __m512 x1_b2 = _mm512_load_ps(x1 + j + 32);
171              __m512 y1_b2 = _mm512_load_ps(y1 + j + 32);
172              __m512 x2_b2 = _mm512_load_ps(x2 + j + 32);
173              __m512 y2_b2 = _mm512_load_ps(y2 + j + 32);
174              __m512 x1_b3 = _mm512_load_ps(x1 + j + 48);
175              __m512 y1_b3 = _mm512_load_ps(y1 + j + 48);
176              __m512 x2_b3 = _mm512_load_ps(x2 + j + 48);
177              __m512 y2_b3 = _mm512_load_ps(y2 + j + 48);
178              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
179              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
180              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
181              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
182              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
183              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
184              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
185              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
186              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
187              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
188              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
189              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
190              __m512 Sb_w2 = _mm512_sub_ps(x2_b2, x1_b2);
191              __m512 Sb_h2 = _mm512_sub_ps(y2_b2, y1_b2);
192              __m512 Sb_w3 = _mm512_sub_ps(x2_b3, x1_b3);
193              __m512 Sb_h3 = _mm512_sub_ps(y2_b3, y1_b3);
194              __m512 xx1_2 = _mm512_max_ps(x1_a, x1_b2);
195              __m512 yy1_2 = _mm512_max_ps(y1_a, y1_b2);
196              __m512 xx2_2 = _mm512_min_ps(x2_a, x2_b2);
197              __m512 yy2_2 = _mm512_min_ps(y2_a, y2_b2);
198              __m512 xx1_3 = _mm512_max_ps(x1_a, x1_b3);
199              __m512 yy1_3 = _mm512_max_ps(y1_a, y1_b3);
200              __m512 xx2_3 = _mm512_min_ps(x2_a, x2_b3);
201              __m512 yy2_3 = _mm512_min_ps(y2_a, y2_b3);
202              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
203              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
204              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
205              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
206              __m512 w2 = _mm512_sub_ps(xx2_2, xx1_2);
207              __m512 h2 = _mm512_sub_ps(yy2_2, yy1_2);
208              __m512 w3 = _mm512_sub_ps(xx2_3, xx1_3);
209              __m512 h3 = _mm512_sub_ps(yy2_3, yy1_3);
210              w0 = _mm512_max_ps(w0, zero);
211              h0 = _mm512_max_ps(h0, zero);
212              w1 = _mm512_max_ps(w1, zero);
213              h1 = _mm512_max_ps(h1, zero);
214              w2 = _mm512_max_ps(w2, zero);
215              h2 = _mm512_max_ps(h2, zero);
216              w3 = _mm512_max_ps(w3, zero);
217              h3 = _mm512_max_ps(h3, zero);
218              __m512 interS_0 = _mm512_mul_ps(w0, h0);
219              __m512 interS_1 = _mm512_mul_ps(w1, h1);
220              __m512 interS_2 = _mm512_mul_ps(w2, h2);
221              __m512 interS_3 = _mm512_mul_ps(w3, h3);
222              __m512 ovr0 = _mm512_fmadd_ps(Sb_w0, Sb_h0, Sa);
223              __m512 ovr1 = _mm512_fmadd_ps(Sb_w1, Sb_h1, Sa);
224              __m512 ovr2 = _mm512_fmadd_ps(Sb_w2, Sb_h2, Sa);
225              __m512 ovr3 = _mm512_fmadd_ps(Sb_w3, Sb_h3, Sa);
226              ovr0 = _mm512_sub_ps(ovr0, interS_0);
227              ovr1 = _mm512_sub_ps(ovr1, interS_1);
228              ovr2 = _mm512_sub_ps(ovr2, interS_2);
229              ovr3 = _mm512_sub_ps(ovr3, interS_3);
230              ovr0 = _mm512_mul_ps(ovr0, thresh);
231              ovr1 = _mm512_mul_ps(ovr1, thresh);
232              ovr2 = _mm512_mul_ps(ovr2, thresh);
233              ovr3 = _mm512_mul_ps(ovr3, thresh);
234              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
235              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
236              __mmask16 gt2 = _mm512_cmp_ps_mask(interS_2, ovr2, _CMP_GT_OS);
237              __mmask16 gt3 = _mm512_cmp_ps_mask(interS_3, ovr3, _CMP_GT_OS);
238              uint64_t mask = ((uint64_t)(gt0)) | (((uint64_t)gt1) << 16) | (((uint64_t)gt2) << 32) | (((uint64_t)gt3) << 48);
239              mask_tbl[j / 64] |= mask;
240          }
241          if ((j + 32) <= boxes_num) {
242              __m512 x1_b0 = _mm512_load_ps(x1 + j);
243              __m512 y1_b0 = _mm512_load_ps(y1 + j);
244              __m512 x2_b0 = _mm512_load_ps(x2 + j);
245              __m512 y2_b0 = _mm512_load_ps(y2 + j);
246              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
247              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
248              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
249              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
250              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
251              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
252              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
253              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
254              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
255              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
256              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
257              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
258              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
259              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
260              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
261              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
262              w0 = _mm512_max_ps(w0, zero);
263              h0 = _mm512_max_ps(h0, zero);
264              w1 = _mm512_max_ps(w1, zero);
265              h1 = _mm512_max_ps(h1, zero);
266              __m512 interS_0 = _mm512_mul_ps(w0, h0);
267              __m512 interS_1 = _mm512_mul_ps(w1, h1);
268              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
269              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
270              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
271              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
272              __m512 Sb0 = _mm512_mul_ps(Sb_w0, Sb_h0);
273              __m512 Sb1 = _mm512_mul_ps(Sb_w1, Sb_h1);
274              __m512 ovr0 = _mm512_add_ps(Sa, Sb0);
275              __m512 ovr1 = _mm512_add_ps(Sa, Sb1);
276              ovr0 = _mm512_sub_ps(ovr0, interS_0);
277              ovr1 = _mm512_sub_ps(ovr1, interS_1);
278              ovr0 = _mm512_mul_ps(ovr0, thresh);
279              ovr1 = _mm512_mul_ps(ovr1, thresh);
280              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
281              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
282              uint64_t mask = (gt0) | ((uint64_t)gt1 << 16);
283              mask_tbl[(j +  0) / 64] |= (mask) << (j % 64);
284              mask_tbl[(j + 32) / 64] |= (mask) >> (64-(j % 64));
285              j += 32;
286          }
287          if ((j + 16) <= boxes_num) {
288              __m512 x1_b = _mm512_load_ps(x1 + j);
289              __m512 y1_b = _mm512_load_ps(y1 + j);
290              __m512 x2_b = _mm512_load_ps(x2 + j);
291              __m512 y2_b = _mm512_load_ps(y2 + j);
292              __m512 xx1 = _mm512_max_ps(x1_a, x1_b);
293              __m512 yy1 = _mm512_max_ps(y1_a, y1_b);
294              __m512 xx2 = _mm512_min_ps(x2_a, x2_b);
295              __m512 yy2 = _mm512_min_ps(y2_a, y2_b);
296              __m512 w = _mm512_sub_ps(xx2, xx1);
297              __m512 h = _mm512_sub_ps(yy2, yy1);
298              w = _mm512_max_ps(w, zero);
299              h = _mm512_max_ps(h, zero);
300              __m512 interS = _mm512_mul_ps(w, h);
301              __m512 Sb_w = _mm512_sub_ps(x2_b, x1_b);
302              __m512 Sb_h = _mm512_sub_ps(y2_b, y1_b);
303              __m512 Sb = _mm512_mul_ps(Sb_w, Sb_h);
304              __m512 ovr = _mm512_add_ps(Sa, Sb);
305              ovr = _mm512_sub_ps(ovr, interS);
306              ovr = _mm512_mul_ps(ovr, thresh);
307              __mmask16 gt = _mm512_cmp_ps_mask(interS, ovr, _CMP_GT_OS);
308              uint64_t mask = gt;
309              mask_tbl[(j +  0) / 64] |= (mask) << (j % 64);
310              mask_tbl[(j + 16) / 64] |= (mask) >> (64-(j % 64));
311              j += 16;
312          }
313          for (; j < boxes_num; j ++) {
314              if (mask_tbl[j/64] & (1ull << (j % 64))) {
315                  continue;
316              }
317              float xx1 = max(x1[i], x1[j]);
318              float yy1 = max(y1[i], y1[j]);
319              float xx2 = min(x2[i], x2[j]);
320              float yy2 = min(y2[i], y2[j]);
321              float w = max(0.0f, xx2 - xx1 );
322              float h = max(0.0f, yy2 - yy1 );
323              float interS = w * h;
324              float Sa = (x2[i] - x1[i] ) * (y2[i] - y1[i] );
325              float Sb = (x2[j] - x1[j] ) * (y2[j] - y1[j] );
326              if (interS > thresh_f * (Sa + Sb - interS)) {
327                  mask_tbl[j/64] |= 1ull << (j % 64);
328              }
329          }
330      }
331      free(mask_tbl);
332      *num_out = num_to_keep;
333  }
334  void cpu_nms_avx512_caffe(int* __restrict keep_out, int* __restrict num_out,
335                            const vector<NormalizedBBox>& bboxes,
336                            vector<pair<float, int> >& score_index_vec,
337                            float thresh) {
338    uint64_t boxes_num = score_index_vec.size();
339    float* x1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
340    float* y1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
341    float* x2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
342    float* y2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
343    uint64_t i = 0;
344  #pragma omp parallel for
345    for (i = 0; i < boxes_num; ++i) {
346      x1[i] = bboxes[score_index_vec[i].second].xmin();
347      y1[i] = bboxes[score_index_vec[i].second].ymin();
348      x2[i] = bboxes[score_index_vec[i].second].xmax();
349      y2[i] = bboxes[score_index_vec[i].second].ymax();
350    }
351    cpu_nms_avx512_parallize_inner(keep_out, num_out, x1, y1, x2, y2, boxes_num,
352                                     thresh);
353  #pragma omp parallel for
354    for (int i = 0; i < *num_out; i++) {
355      keep_out[i] = score_index_vec[keep_out[i]].second;
356    }
357    free(x1);
358    free(x2);
359    free(y1);
360    free(y2);
361  }
362  #endif
363  NormalizedBBox UnitBBox() {
364    NormalizedBBox unit_bbox;
365    unit_bbox.set_xmin(0.);
366    unit_bbox.set_ymin(0.);
367    unit_bbox.set_xmax(1.);
368    unit_bbox.set_ymax(1.);
369    return unit_bbox;
370  }
371  bool IsCrossBoundaryBBox(const NormalizedBBox& bbox) {
372    return bbox.xmin() < 0 || bbox.xmin() > 1 ||
373        bbox.ymin() < 0 || bbox.ymin() > 1 ||
374        bbox.xmax() < 0 || bbox.xmax() > 1 ||
375        bbox.ymax() < 0 || bbox.ymax() > 1;
376  }
377  void IntersectBBox(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2,
378                     NormalizedBBox* intersect_bbox) {
379    if (bbox2.xmin() > bbox1.xmax() || bbox2.xmax() < bbox1.xmin() ||
380        bbox2.ymin() > bbox1.ymax() || bbox2.ymax() < bbox1.ymin()) {
381      intersect_bbox->set_xmin(0);
382      intersect_bbox->set_ymin(0);
383      intersect_bbox->set_xmax(0);
384      intersect_bbox->set_ymax(0);
385    } else {
386      intersect_bbox->set_xmin(std::max(bbox1.xmin(), bbox2.xmin()));
387      intersect_bbox->set_ymin(std::max(bbox1.ymin(), bbox2.ymin()));
388      intersect_bbox->set_xmax(std::min(bbox1.xmax(), bbox2.xmax()));
389      intersect_bbox->set_ymax(std::min(bbox1.ymax(), bbox2.ymax()));
390    }
391  }
392  float BBoxSize(const NormalizedBBox& bbox, const bool normalized) {
393    if (bbox.xmax() < bbox.xmin() || bbox.ymax() < bbox.ymin()) {
394      return 0;
395    } else {
396      if (bbox.has_size()) {
397        return bbox.size();
398      } else {
399        float width = bbox.xmax() - bbox.xmin();
400        float height = bbox.ymax() - bbox.ymin();
401        if (normalized) {
402          return width * height;
403        } else {
404          return (width + 1) * (height + 1);
405        }
406      }
407    }
408  }
409  template <typename Dtype>
410  Dtype BBoxSize(const Dtype* bbox, const bool normalized) {
411    if (bbox[2] < bbox[0] || bbox[3] < bbox[1]) {
412      return Dtype(0.);
413    } else {
414      const Dtype width = bbox[2] - bbox[0];
415      const Dtype height = bbox[3] - bbox[1];
416      if (normalized) {
417        return width * height;
418      } else {
419        return (width + 1) * (height + 1);
420      }
421    }
422  }
423  template float BBoxSize(const float* bbox, const bool normalized);
424  template double BBoxSize(const double* bbox, const bool normalized);
425  void ClipBBox(const NormalizedBBox& bbox, NormalizedBBox* clip_bbox) {
426    clip_bbox->set_xmin(std::max(std::min(bbox.xmin(), 1.f), 0.f));
427    clip_bbox->set_ymin(std::max(std::min(bbox.ymin(), 1.f), 0.f));
428    clip_bbox->set_xmax(std::max(std::min(bbox.xmax(), 1.f), 0.f));
429    clip_bbox->set_ymax(std::max(std::min(bbox.ymax(), 1.f), 0.f));
430    clip_bbox->clear_size();
431    clip_bbox->set_size(BBoxSize(*clip_bbox));
432    clip_bbox->set_difficult(bbox.difficult());
433  }
434  void ClipBBox(const NormalizedBBox& bbox, const float height, const float width,
435                NormalizedBBox* clip_bbox) {
436    clip_bbox->set_xmin(std::max(std::min(bbox.xmin(), width), 0.f));
437    clip_bbox->set_ymin(std::max(std::min(bbox.ymin(), height), 0.f));
438    clip_bbox->set_xmax(std::max(std::min(bbox.xmax(), width), 0.f));
439    clip_bbox->set_ymax(std::max(std::min(bbox.ymax(), height), 0.f));
440    clip_bbox->clear_size();
441    clip_bbox->set_size(BBoxSize(*clip_bbox));
442    clip_bbox->set_difficult(bbox.difficult());
443  }
444  void ScaleBBox(const NormalizedBBox& bbox, const int height, const int width,
445                 NormalizedBBox* scale_bbox) {
446    scale_bbox->set_xmin(bbox.xmin() * width);
447    scale_bbox->set_ymin(bbox.ymin() * height);
448    scale_bbox->set_xmax(bbox.xmax() * width);
449    scale_bbox->set_ymax(bbox.ymax() * height);
450    scale_bbox->clear_size();
451    bool normalized = !(width > 1 || height > 1);
452    scale_bbox->set_size(BBoxSize(*scale_bbox, normalized));
453    scale_bbox->set_difficult(bbox.difficult());
454  }
455  void OutputBBox(const NormalizedBBox& bbox, const pair<int, int>& img_size,
456                  const bool has_resize, const ResizeParameter& resize_param,
457                  NormalizedBBox* out_bbox) {
458    const int height = img_size.first;
459    const int width = img_size.second;
460    NormalizedBBox temp_bbox = bbox;
461    if (has_resize && resize_param.resize_mode()) {
462      float resize_height = resize_param.height();
463      CHECK_GT(resize_height, 0);
464      float resize_width = resize_param.width();
465      CHECK_GT(resize_width, 0);
466      float resize_aspect = resize_width / resize_height;
467      int height_scale = resize_param.height_scale();
468      int width_scale = resize_param.width_scale();
469      float aspect = static_cast<float>(width) / height;
470      float padding;
471      NormalizedBBox source_bbox;
472      switch (resize_param.resize_mode()) {
473        case ResizeParameter_Resize_mode_WARP:
474          ClipBBox(temp_bbox, &temp_bbox);
475          ScaleBBox(temp_bbox, height, width, out_bbox);
476          break;
477        case ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD:
478          if (aspect > resize_aspect) {
479            padding = (resize_height - resize_width / aspect) / 2;
480            source_bbox.set_xmin(0.);
481            source_bbox.set_ymin(padding / resize_height);
482            source_bbox.set_xmax(1.);
483            source_bbox.set_ymax(1. - padding / resize_height);
484          } else {
485            padding = (resize_width - resize_height * aspect) / 2;
486            source_bbox.set_xmin(padding / resize_width);
487            source_bbox.set_ymin(0.);
488            source_bbox.set_xmax(1. - padding / resize_width);
489            source_bbox.set_ymax(1.);
490          }
491          ProjectBBox(source_bbox, bbox, &temp_bbox);
492          ClipBBox(temp_bbox, &temp_bbox);
493          ScaleBBox(temp_bbox, height, width, out_bbox);
494          break;
495        case ResizeParameter_Resize_mode_FIT_SMALL_SIZE:
496          if (height_scale == 0 || width_scale == 0) {
497            ClipBBox(temp_bbox, &temp_bbox);
498            ScaleBBox(temp_bbox, height, width, out_bbox);
499          } else {
500            ScaleBBox(temp_bbox, height_scale, width_scale, out_bbox);
501            ClipBBox(*out_bbox, height, width, out_bbox);
502          }
503          break;
504        default:
505          LOG(FATAL) << "Unknown resize mode.";
506      }
507    } else {
508      ClipBBox(temp_bbox, &temp_bbox);
509      ScaleBBox(temp_bbox, height, width, out_bbox);
510    }
511  }
512  void LocateBBox(const NormalizedBBox& src_bbox, const NormalizedBBox& bbox,
513                  NormalizedBBox* loc_bbox) {
514    float src_width = src_bbox.xmax() - src_bbox.xmin();
515    float src_height = src_bbox.ymax() - src_bbox.ymin();
516    loc_bbox->set_xmin(src_bbox.xmin() + bbox.xmin() * src_width);
517    loc_bbox->set_ymin(src_bbox.ymin() + bbox.ymin() * src_height);
518    loc_bbox->set_xmax(src_bbox.xmin() + bbox.xmax() * src_width);
519    loc_bbox->set_ymax(src_bbox.ymin() + bbox.ymax() * src_height);
520    loc_bbox->set_difficult(bbox.difficult());
521  }
522  bool ProjectBBox(const NormalizedBBox& src_bbox, const NormalizedBBox& bbox,
523                   NormalizedBBox* proj_bbox) {
524    if (bbox.xmin() >= src_bbox.xmax() || bbox.xmax() <= src_bbox.xmin() ||
525        bbox.ymin() >= src_bbox.ymax() || bbox.ymax() <= src_bbox.ymin()) {
526      return false;
527    }
528    float src_width = src_bbox.xmax() - src_bbox.xmin();
529    float src_height = src_bbox.ymax() - src_bbox.ymin();
530    proj_bbox->set_xmin((bbox.xmin() - src_bbox.xmin()) / src_width);
531    proj_bbox->set_ymin((bbox.ymin() - src_bbox.ymin()) / src_height);
532    proj_bbox->set_xmax((bbox.xmax() - src_bbox.xmin()) / src_width);
533    proj_bbox->set_ymax((bbox.ymax() - src_bbox.ymin()) / src_height);
534    proj_bbox->set_difficult(bbox.difficult());
535    ClipBBox(*proj_bbox, proj_bbox);
536    if (BBoxSize(*proj_bbox) > 0) {
537      return true;
538    } else {
539      return false;
540    }
541  }
542  void ExtrapolateBBox(const ResizeParameter& param, const int height,
543      const int width, const NormalizedBBox& crop_bbox, NormalizedBBox* bbox) {
544    float height_scale = param.height_scale();
545    float width_scale = param.width_scale();
546    if (height_scale > 0 && width_scale > 0 &&
547        param.resize_mode() == ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
548      float orig_aspect = static_cast<float>(width) / height;
549      float resize_height = param.height();
550      float resize_width = param.width();
551      float resize_aspect = resize_width / resize_height;
552      if (orig_aspect < resize_aspect) {
553        resize_height = resize_width / orig_aspect;
554      } else {
555        resize_width = resize_height * orig_aspect;
556      }
557      float crop_height = resize_height * (crop_bbox.ymax() - crop_bbox.ymin());
558      float crop_width = resize_width * (crop_bbox.xmax() - crop_bbox.xmin());
559      CHECK_GE(crop_width, width_scale);
560      CHECK_GE(crop_height, height_scale);
561      bbox->set_xmin(bbox->xmin() * crop_width / width_scale);
562      bbox->set_xmax(bbox->xmax() * crop_width / width_scale);
563      bbox->set_ymin(bbox->ymin() * crop_height / height_scale);
564      bbox->set_ymax(bbox->ymax() * crop_height / height_scale);
565    }
566  }
567  float JaccardOverlap(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2,
568                       const bool normalized) {
569    NormalizedBBox intersect_bbox;
570    IntersectBBox(bbox1, bbox2, &intersect_bbox);
571    float intersect_width, intersect_height;
572    if (normalized) {
573      intersect_width = intersect_bbox.xmax() - intersect_bbox.xmin();
574      intersect_height = intersect_bbox.ymax() - intersect_bbox.ymin();
575    } else {
576      intersect_width = intersect_bbox.xmax() - intersect_bbox.xmin() + 1;
577      intersect_height = intersect_bbox.ymax() - intersect_bbox.ymin() + 1;
578    }
579    if (intersect_width > 0 && intersect_height > 0) {
580      float intersect_size = intersect_width * intersect_height;
581      float bbox1_size = BBoxSize(bbox1);
582      float bbox2_size = BBoxSize(bbox2);
583      return intersect_size / (bbox1_size + bbox2_size - intersect_size);
584    } else {
585      return 0.;
586    }
587  }
588  template <typename Dtype>
589  Dtype JaccardOverlap(const Dtype* bbox1, const Dtype* bbox2) {
590    if (bbox2[0] > bbox1[2] || bbox2[2] < bbox1[0] ||
591        bbox2[1] > bbox1[3] || bbox2[3] < bbox1[1]) {
592      return Dtype(0.);
593    } else {
594      const Dtype inter_xmin = std::max(bbox1[0], bbox2[0]);
595      const Dtype inter_ymin = std::max(bbox1[1], bbox2[1]);
596      const Dtype inter_xmax = std::min(bbox1[2], bbox2[2]);
597      const Dtype inter_ymax = std::min(bbox1[3], bbox2[3]);
598      const Dtype inter_width = inter_xmax - inter_xmin;
599      const Dtype inter_height = inter_ymax - inter_ymin;
600      const Dtype inter_size = inter_width * inter_height;
601      const Dtype bbox1_size = BBoxSize(bbox1);
602      const Dtype bbox2_size = BBoxSize(bbox2);
603      return inter_size / (bbox1_size + bbox2_size - inter_size);
604    }
605  }
606  template float JaccardOverlap(const float* bbox1, const float* bbox2);
607  template double JaccardOverlap(const double* bbox1, const double* bbox2);
608  float BBoxCoverage(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
609    NormalizedBBox intersect_bbox;
610    IntersectBBox(bbox1, bbox2, &intersect_bbox);
611    float intersect_size = BBoxSize(intersect_bbox);
612    if (intersect_size > 0) {
613      float bbox1_size = BBoxSize(bbox1);
614      CHECK_NE(bbox1_size, 0);
615      return intersect_size / bbox1_size;
616    } else {
617      return 0.;
618    }
619  }
620  bool MeetEmitConstraint(const NormalizedBBox& src_bbox,
621                          const NormalizedBBox& bbox,
622                          const EmitConstraint& emit_constraint) {
623    EmitType emit_type = emit_constraint.emit_type();
624    if (emit_type == EmitConstraint_EmitType_CENTER) {
625      float x_center = (bbox.xmin() + bbox.xmax()) / 2;
626      float y_center = (bbox.ymin() + bbox.ymax()) / 2;
627      if (x_center >= src_bbox.xmin() && x_center <= src_bbox.xmax() &&
628          y_center >= src_bbox.ymin() && y_center <= src_bbox.ymax()) {
629        return true;
630      } else {
631        return false;
632      }
633    } else if (emit_type == EmitConstraint_EmitType_MIN_OVERLAP) {
634      float bbox_coverage = BBoxCoverage(bbox, src_bbox);
635      return bbox_coverage > emit_constraint.emit_overlap();
636    } else {
637      LOG(FATAL) << "Unknown emit type.";
638      return false;
639    }
640  }
641  void EncodeBBox(
642      const NormalizedBBox& prior_bbox, const vector<float>& prior_variance,
643      const CodeType code_type, const bool encode_variance_in_target,
644      const NormalizedBBox& bbox, NormalizedBBox* encode_bbox) {
645    if (code_type == PriorBoxParameter_CodeType_CORNER) {
646      if (encode_variance_in_target) {
647        encode_bbox->set_xmin(bbox.xmin() - prior_bbox.xmin());
648        encode_bbox->set_ymin(bbox.ymin() - prior_bbox.ymin());
649        encode_bbox->set_xmax(bbox.xmax() - prior_bbox.xmax());
650        encode_bbox->set_ymax(bbox.ymax() - prior_bbox.ymax());
651      } else {
652        CHECK_EQ(prior_variance.size(), 4);
653        for (int i = 0; i < prior_variance.size(); ++i) {
654          CHECK_GT(prior_variance[i], 0);
655        }
656        encode_bbox->set_xmin(
657            (bbox.xmin() - prior_bbox.xmin()) / prior_variance[0]);
658        encode_bbox->set_ymin(
659            (bbox.ymin() - prior_bbox.ymin()) / prior_variance[1]);
660        encode_bbox->set_xmax(
661            (bbox.xmax() - prior_bbox.xmax()) / prior_variance[2]);
662        encode_bbox->set_ymax(
663            (bbox.ymax() - prior_bbox.ymax()) / prior_variance[3]);
664      }
665    } else if (code_type == PriorBoxParameter_CodeType_CENTER_SIZE) {
666      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
667      CHECK_GT(prior_width, 0);
668      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
669      CHECK_GT(prior_height, 0);
670      float prior_center_x = (prior_bbox.xmin() + prior_bbox.xmax()) / 2.;
671      float prior_center_y = (prior_bbox.ymin() + prior_bbox.ymax()) / 2.;
672      float bbox_width = bbox.xmax() - bbox.xmin();
673      CHECK_GT(bbox_width, 0);
674      float bbox_height = bbox.ymax() - bbox.ymin();
675      CHECK_GT(bbox_height, 0);
676      float bbox_center_x = (bbox.xmin() + bbox.xmax()) / 2.;
677      float bbox_center_y = (bbox.ymin() + bbox.ymax()) / 2.;
678      if (encode_variance_in_target) {
679        encode_bbox->set_xmin((bbox_center_x - prior_center_x) / prior_width);
680        encode_bbox->set_ymin((bbox_center_y - prior_center_y) / prior_height);
681        encode_bbox->set_xmax(log(bbox_width / prior_width));
682        encode_bbox->set_ymax(log(bbox_height / prior_height));
683      } else {
684        encode_bbox->set_xmin(
685            (bbox_center_x - prior_center_x) / prior_width / prior_variance[0]);
686        encode_bbox->set_ymin(
687            (bbox_center_y - prior_center_y) / prior_height / prior_variance[1]);
688        encode_bbox->set_xmax(
689            log(bbox_width / prior_width) / prior_variance[2]);
690        encode_bbox->set_ymax(
691            log(bbox_height / prior_height) / prior_variance[3]);
692      }
693    } else if (code_type == PriorBoxParameter_CodeType_CORNER_SIZE) {
694      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
695      CHECK_GT(prior_width, 0);
696      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
697      CHECK_GT(prior_height, 0);
698      if (encode_variance_in_target) {
699        encode_bbox->set_xmin((bbox.xmin() - prior_bbox.xmin()) / prior_width);
700        encode_bbox->set_ymin((bbox.ymin() - prior_bbox.ymin()) / prior_height);
701        encode_bbox->set_xmax((bbox.xmax() - prior_bbox.xmax()) / prior_width);
702        encode_bbox->set_ymax((bbox.ymax() - prior_bbox.ymax()) / prior_height);
703      } else {
704        CHECK_EQ(prior_variance.size(), 4);
705        for (int i = 0; i < prior_variance.size(); ++i) {
706          CHECK_GT(prior_variance[i], 0);
707        }
708        encode_bbox->set_xmin(
709            (bbox.xmin() - prior_bbox.xmin()) / prior_width / prior_variance[0]);
710        encode_bbox->set_ymin(
711            (bbox.ymin() - prior_bbox.ymin()) / prior_height / prior_variance[1]);
712        encode_bbox->set_xmax(
713            (bbox.xmax() - prior_bbox.xmax()) / prior_width / prior_variance[2]);
714        encode_bbox->set_ymax(
715            (bbox.ymax() - prior_bbox.ymax()) / prior_height / prior_variance[3]);
716      }
717    } else {
718      LOG(FATAL) << "Unknown LocLossType.";
719    }
720  }
721  void DecodeBBox(
722      const NormalizedBBox& prior_bbox, const vector<float>& prior_variance,
723      const CodeType code_type, const bool variance_encoded_in_target,
724      const bool clip_bbox, const NormalizedBBox& bbox,
725      NormalizedBBox* decode_bbox) {
726    if (code_type == PriorBoxParameter_CodeType_CORNER) {
727      if (variance_encoded_in_target) {
728        decode_bbox->set_xmin(prior_bbox.xmin() + bbox.xmin());
729        decode_bbox->set_ymin(prior_bbox.ymin() + bbox.ymin());
730        decode_bbox->set_xmax(prior_bbox.xmax() + bbox.xmax());
731        decode_bbox->set_ymax(prior_bbox.ymax() + bbox.ymax());
732      } else {
733        decode_bbox->set_xmin(
734            prior_bbox.xmin() + prior_variance[0] * bbox.xmin());
735        decode_bbox->set_ymin(
736            prior_bbox.ymin() + prior_variance[1] * bbox.ymin());
737        decode_bbox->set_xmax(
738            prior_bbox.xmax() + prior_variance[2] * bbox.xmax());
739        decode_bbox->set_ymax(
740            prior_bbox.ymax() + prior_variance[3] * bbox.ymax());
741      }
742    } else if (code_type == PriorBoxParameter_CodeType_CENTER_SIZE) {
743      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
744      CHECK_GT(prior_width, 0);
745      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
746      CHECK_GT(prior_height, 0);
747      float prior_center_x = (prior_bbox.xmin() + prior_bbox.xmax()) / 2.;
748      float prior_center_y = (prior_bbox.ymin() + prior_bbox.ymax()) / 2.;
749      float decode_bbox_center_x, decode_bbox_center_y;
750      float decode_bbox_width, decode_bbox_height;
751      if (variance_encoded_in_target) {
752        decode_bbox_center_x = bbox.xmin() * prior_width + prior_center_x;
753        decode_bbox_center_y = bbox.ymin() * prior_height + prior_center_y;
754        decode_bbox_width = exp(bbox.xmax()) * prior_width;
755        decode_bbox_height = exp(bbox.ymax()) * prior_height;
756      } else {
757        decode_bbox_center_x =
758            prior_variance[0] * bbox.xmin() * prior_width + prior_center_x;
759        decode_bbox_center_y =
760            prior_variance[1] * bbox.ymin() * prior_height + prior_center_y;
761        decode_bbox_width =
762            exp(prior_variance[2] * bbox.xmax()) * prior_width;
763        decode_bbox_height =
764            exp(prior_variance[3] * bbox.ymax()) * prior_height;
765      }
766      decode_bbox->set_xmin(decode_bbox_center_x - decode_bbox_width / 2.);
767      decode_bbox->set_ymin(decode_bbox_center_y - decode_bbox_height / 2.);
768      decode_bbox->set_xmax(decode_bbox_center_x + decode_bbox_width / 2.);
769      decode_bbox->set_ymax(decode_bbox_center_y + decode_bbox_height / 2.);
770    } else if (code_type == PriorBoxParameter_CodeType_CORNER_SIZE) {
771      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
772      CHECK_GT(prior_width, 0);
773      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
774      CHECK_GT(prior_height, 0);
775      if (variance_encoded_in_target) {
776        decode_bbox->set_xmin(prior_bbox.xmin() + bbox.xmin() * prior_width);
777        decode_bbox->set_ymin(prior_bbox.ymin() + bbox.ymin() * prior_height);
778        decode_bbox->set_xmax(prior_bbox.xmax() + bbox.xmax() * prior_width);
779        decode_bbox->set_ymax(prior_bbox.ymax() + bbox.ymax() * prior_height);
780      } else {
781        decode_bbox->set_xmin(
782            prior_bbox.xmin() + prior_variance[0] * bbox.xmin() * prior_width);
783        decode_bbox->set_ymin(
784            prior_bbox.ymin() + prior_variance[1] * bbox.ymin() * prior_height);
785        decode_bbox->set_xmax(
786            prior_bbox.xmax() + prior_variance[2] * bbox.xmax() * prior_width);
787        decode_bbox->set_ymax(
788            prior_bbox.ymax() + prior_variance[3] * bbox.ymax() * prior_height);
789      }
790    } else {
791      LOG(FATAL) << "Unknown LocLossType.";
792    }
793    float bbox_size = BBoxSize(*decode_bbox);
794    decode_bbox->set_size(bbox_size);
795    if (clip_bbox) {
796      ClipBBox(*decode_bbox, decode_bbox);
797    }
798  }
799  void DecodeBBoxes(const vector<NormalizedBBox>& prior_bboxes,
800                    const vector<vector<float> >& prior_variances,
801                    const CodeType code_type,
802                    const bool variance_encoded_in_target, const bool clip_bbox,
803                    const vector<NormalizedBBox>& bboxes,
804                    vector<NormalizedBBox>* decode_bboxes) {
805    CHECK_EQ(prior_bboxes.size(), prior_variances.size());
806    CHECK_EQ(prior_bboxes.size(), bboxes.size());
807    int num_bboxes = prior_bboxes.size();
808    if (num_bboxes >= 1) {
809      CHECK_EQ(prior_variances[0].size(), 4);
810    }
811    decode_bboxes->reserve(num_bboxes);
812    NormalizedBBox* result = new NormalizedBBox[num_bboxes];
813  #ifdef _OPENMP
814    #pragma omp parallel for
815  #endif
816    for (int i = 0; i < num_bboxes; ++i) {
817      DecodeBBox(prior_bboxes[i], prior_variances[i], code_type,
818                 variance_encoded_in_target, clip_bbox, bboxes[i], &result[i]);
819    }
820    decode_bboxes->assign(&result[0], &result[num_bboxes]);
821    delete[] result;
822  }
823  void DecodeBBoxesAll(const vector<LabelBBox>& all_loc_preds,
824      const vector<NormalizedBBox>& prior_bboxes,
825      const vector<vector<float> >& prior_variances,
826      const int num, const bool share_location,
827      const int num_loc_classes, const int background_label_id,
828      const CodeType code_type, const bool variance_encoded_in_target,
829      const bool clip, vector<LabelBBox>* all_decode_bboxes) {
830    CHECK_EQ(all_loc_preds.size(), num);
831    all_decode_bboxes->clear();
832    all_decode_bboxes->resize(num);
833  #ifdef _OPENMP
834    #pragma omp parallel for
835  #endif
836    for (int i = 0; i < num; ++i) {
837      for (int c = 0; c < num_loc_classes; ++c) {
838        int label = share_location ? -1 : c;
839        if (label == background_label_id) {
840          continue;
841        }
842        if (all_loc_preds[i].find(label) == all_loc_preds[i].end()) {
843          LOG(FATAL) << "Could not find location predictions for label " << label;
844        }
845        const vector<NormalizedBBox>& label_loc_preds =
846            all_loc_preds[i].find(label)->second;
847        DecodeBBoxes(prior_bboxes, prior_variances,
848                     code_type, variance_encoded_in_target, clip,
849                     label_loc_preds, &((*all_decode_bboxes)[i][label]));
850      }
851    }
852  }
853  void MatchBBox(const vector<NormalizedBBox>& gt_bboxes,
854      const vector<NormalizedBBox>& pred_bboxes, const int label,
855      const MatchType match_type, const float overlap_threshold,
856      const bool ignore_cross_boundary_bbox,
857      vector<int>* match_indices, vector<float>* match_overlaps) {
858    int num_pred = pred_bboxes.size();
859    match_indices->clear();
860    match_indices->resize(num_pred, -1);
861    match_overlaps->clear();
862    match_overlaps->resize(num_pred, 0.);
863    int num_gt = 0;
864    vector<int> gt_indices;
865    if (label == -1) {
866      num_gt = gt_bboxes.size();
867      for (int i = 0; i < num_gt; ++i) {
868        gt_indices.push_back(i);
869      }
870    } else {
871      for (int i = 0; i < gt_bboxes.size(); ++i) {
872        if (gt_bboxes[i].label() == label) {
873          num_gt++;
874          gt_indices.push_back(i);
875        }
876      }
877    }
878    if (num_gt == 0) {
879      return;
880    }
881    map<int, map<int, float> > overlaps;
882    for (int i = 0; i < num_pred; ++i) {
883      if (ignore_cross_boundary_bbox && IsCrossBoundaryBBox(pred_bboxes[i])) {
884        (*match_indices)[i] = -2;
885        continue;
886      }
887      for (int j = 0; j < num_gt; ++j) {
888        float overlap = JaccardOverlap(pred_bboxes[i], gt_bboxes[gt_indices[j]]);
889        if (overlap > 1e-6) {
890          (*match_overlaps)[i] = std::max((*match_overlaps)[i], overlap);
891          overlaps[i][j] = overlap;
892        }
893      }
894    }
895    vector<int> gt_pool;
896    for (int i = 0; i < num_gt; ++i) {
897      gt_pool.push_back(i);
898    }
899    while (gt_pool.size() > 0) {
900      int max_idx = -1;
901      int max_gt_idx = -1;
902      float max_overlap = -1;
903      for (map<int, map<int, float> >::iterator it = overlaps.begin();
904           it != overlaps.end(); ++it) {
905        int i = it->first;
906        if ((*match_indices)[i] != -1) {
907          continue;
908        }
909        for (int p = 0; p < gt_pool.size(); ++p) {
910          int j = gt_pool[p];
911          if (it->second.find(j) == it->second.end()) {
912            continue;
913          }
914          if (it->second[j] > max_overlap) {
915            max_idx = i;
916            max_gt_idx = j;
917            max_overlap = it->second[j];
918          }
919        }
920      }
921      if (max_idx == -1) {
922        break;
923      } else {
924        CHECK_EQ((*match_indices)[max_idx], -1);
925        (*match_indices)[max_idx] = gt_indices[max_gt_idx];
926        (*match_overlaps)[max_idx] = max_overlap;
927        gt_pool.erase(std::find(gt_pool.begin(), gt_pool.end(), max_gt_idx));
928      }
929    }
930    switch (match_type) {
931      case MultiBoxLossParameter_MatchType_BIPARTITE:
932        break;
933      case MultiBoxLossParameter_MatchType_PER_PREDICTION:
934        for (map<int, map<int, float> >::iterator it = overlaps.begin();
935             it != overlaps.end(); ++it) {
936          int i = it->first;
937          if ((*match_indices)[i] != -1) {
938            continue;
939          }
940          int max_gt_idx = -1;
941          float max_overlap = -1;
942          for (int j = 0; j < num_gt; ++j) {
943            if (it->second.find(j) == it->second.end()) {
944              continue;
945            }
946            float overlap = it->second[j];
947            if (overlap >= overlap_threshold && overlap > max_overlap) {
948              max_gt_idx = j;
949              max_overlap = overlap;
950            }
951          }
952          if (max_gt_idx != -1) {
953            CHECK_EQ((*match_indices)[i], -1);
954            (*match_indices)[i] = gt_indices[max_gt_idx];
955            (*match_overlaps)[i] = max_overlap;
956          }
957        }
958        break;
959      default:
960        LOG(FATAL) << "Unknown matching type.";
961        break;
962    }
963    return;
964  }
965  void FindMatches(const vector<LabelBBox>& all_loc_preds,
966        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
967        const vector<NormalizedBBox>& prior_bboxes,
968        const vector<vector<float> >& prior_variances,
969        const MultiBoxLossParameter& multibox_loss_param,
970        vector<map<int, vector<float> > >* all_match_overlaps,
971        vector<map<int, vector<int> > >* all_match_indices) {
972    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
973    const int num_classes = multibox_loss_param.num_classes();
974    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
975    const bool share_location = multibox_loss_param.share_location();
976    const int loc_classes = share_location ? 1 : num_classes;
977    const MatchType match_type = multibox_loss_param.match_type();
978    const float overlap_threshold = multibox_loss_param.overlap_threshold();
979    const bool use_prior_for_matching =
980        multibox_loss_param.use_prior_for_matching();
981    const int background_label_id = multibox_loss_param.background_label_id();
982    const CodeType code_type = multibox_loss_param.code_type();
983    const bool encode_variance_in_target =
984        multibox_loss_param.encode_variance_in_target();
985    const bool ignore_cross_boundary_bbox =
986        multibox_loss_param.ignore_cross_boundary_bbox();
987    int num = all_loc_preds.size();
988    for (int i = 0; i < num; ++i) {
989      map<int, vector<int> > match_indices;
990      map<int, vector<float> > match_overlaps;
991      if (all_gt_bboxes.find(i) == all_gt_bboxes.end()) {
992        all_match_indices->push_back(match_indices);
993        all_match_overlaps->push_back(match_overlaps);
994        continue;
995      }
996      const vector<NormalizedBBox>& gt_bboxes = all_gt_bboxes.find(i)->second;
997      if (!use_prior_for_matching) {
998        for (int c = 0; c < loc_classes; ++c) {
999          int label = share_location ? -1 : c;
1000          if (!share_location && label == background_label_id) {
1001            continue;
1002          }
1003          vector<NormalizedBBox> loc_bboxes;
1004          bool clip_bbox = false;
1005          DecodeBBoxes(prior_bboxes, prior_variances,
1006                       code_type, encode_variance_in_target, clip_bbox,
1007                       all_loc_preds[i].find(label)->second, &loc_bboxes);
1008          MatchBBox(gt_bboxes, loc_bboxes, label, match_type,
1009                    overlap_threshold, ignore_cross_boundary_bbox,
1010                    &match_indices[label], &match_overlaps[label]);
1011        }
1012      } else {
1013        vector<int> temp_match_indices;
1014        vector<float> temp_match_overlaps;
1015        const int label = -1;
1016        MatchBBox(gt_bboxes, prior_bboxes, label, match_type, overlap_threshold,
1017                  ignore_cross_boundary_bbox, &temp_match_indices,
1018                  &temp_match_overlaps);
1019        if (share_location) {
1020          match_indices[label] = temp_match_indices;
1021          match_overlaps[label] = temp_match_overlaps;
1022        } else {
1023          vector<int> gt_labels;
1024          for (int g = 0; g < gt_bboxes.size(); ++g) {
1025            gt_labels.push_back(gt_bboxes[g].label());
1026          }
1027          for (int c = 0; c < loc_classes; ++c) {
1028            if (c == background_label_id) {
1029              continue;
1030            }
1031            match_indices[c].resize(temp_match_indices.size(), -1);
1032            match_overlaps[c] = temp_match_overlaps;
1033            for (int m = 0; m < temp_match_indices.size(); ++m) {
1034              if (temp_match_indices[m] > -1) {
1035                const int gt_idx = temp_match_indices[m];
1036                CHECK_LT(gt_idx, gt_labels.size());
1037                if (c == gt_labels[gt_idx]) {
1038                  match_indices[c][m] = gt_idx;
1039                }
1040              }
1041            }
1042          }
1043        }
1044      }
1045      all_match_indices->push_back(match_indices);
1046      all_match_overlaps->push_back(match_overlaps);
1047    }
1048  }
1049  int CountNumMatches(const vector<map<int, vector<int> > >& all_match_indices,
1050                      const int num) {
1051    int num_matches = 0;
1052    for (int i = 0; i < num; ++i) {
1053      const map<int, vector<int> >& match_indices = all_match_indices[i];
1054      for (map<int, vector<int> >::const_iterator it = match_indices.begin();
1055           it != match_indices.end(); ++it) {
1056        const vector<int>& match_index = it->second;
1057        for (int m = 0; m < match_index.size(); ++m) {
1058          if (match_index[m] > -1) {
1059            ++num_matches;
1060          }
1061        }
1062      }
1063    }
1064    return num_matches;
1065  }
1066  inline bool IsEligibleMining(const MiningType mining_type, const int match_idx,
1067      const float match_overlap, const float neg_overlap) {
1068    if (mining_type == MultiBoxLossParameter_MiningType_MAX_NEGATIVE) {
1069      return match_idx == -1 && match_overlap < neg_overlap;
1070    } else if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1071      return true;
1072    } else {
1073      return false;
1074    }
1075  }
1076  template <typename Dtype>
1077  void MineHardExamples(const Blob<Dtype>& conf_blob,
1078      const vector<LabelBBox>& all_loc_preds,
1079      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1080      const vector<NormalizedBBox>& prior_bboxes,
1081      const vector<vector<float> >& prior_variances,
1082      const vector<map<int, vector<float> > >& all_match_overlaps,
1083      const MultiBoxLossParameter& multibox_loss_param,
1084      int* num_matches, int* num_negs,
1085      vector<map<int, vector<int> > >* all_match_indices,
1086      vector<vector<int> >* all_neg_indices) {
1087    int num = all_loc_preds.size();
1088    *num_matches = CountNumMatches(*all_match_indices, num);
1089    *num_negs = 0;
1090    int num_priors = prior_bboxes.size();
1091    CHECK_EQ(num_priors, prior_variances.size());
1092    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
1093    const int num_classes = multibox_loss_param.num_classes();
1094    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
1095    const int background_label_id = multibox_loss_param.background_label_id();
1096    const bool use_prior_for_nms = multibox_loss_param.use_prior_for_nms();
1097    const ConfLossType conf_loss_type = multibox_loss_param.conf_loss_type();
1098    const MiningType mining_type = multibox_loss_param.mining_type();
1099    if (mining_type == MultiBoxLossParameter_MiningType_NONE) {
1100      return;
1101    }
1102    const LocLossType loc_loss_type = multibox_loss_param.loc_loss_type();
1103    const float neg_pos_ratio = multibox_loss_param.neg_pos_ratio();
1104    const float neg_overlap = multibox_loss_param.neg_overlap();
1105    const CodeType code_type = multibox_loss_param.code_type();
1106    const bool encode_variance_in_target =
1107        multibox_loss_param.encode_variance_in_target();
1108    const bool has_nms_param = multibox_loss_param.has_nms_param();
1109    float nms_threshold = 0;
1110    int top_k = -1;
1111    if (has_nms_param) {
1112      nms_threshold = multibox_loss_param.nms_param().nms_threshold();
1113      top_k = multibox_loss_param.nms_param().top_k();
1114    }
1115    const int sample_size = multibox_loss_param.sample_size();
1116    vector<vector<float> > all_conf_loss;
1117  #ifdef CPU_ONLY
1118    ComputeConfLoss(conf_blob.cpu_data(), num, num_priors, num_classes,
1119        background_label_id, conf_loss_type, *all_match_indices, all_gt_bboxes,
1120        &all_conf_loss);
1121  #else
1122    ComputeConfLossGPU(conf_blob, num, num_priors, num_classes,
1123        background_label_id, conf_loss_type, *all_match_indices, all_gt_bboxes,
1124        &all_conf_loss);
1125  #endif
1126    vector<vector<float> > all_loc_loss;
1127    if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1128      Blob<Dtype> loc_pred, loc_gt;
1129      if (*num_matches != 0) {
1130        vector<int> loc_shape(2, 1);
1131        loc_shape[1] = *num_matches * 4;
1132        loc_pred.Reshape(loc_shape);
1133        loc_gt.Reshape(loc_shape);
1134        Dtype* loc_pred_data = loc_pred.mutable_cpu_data();
1135        Dtype* loc_gt_data = loc_gt.mutable_cpu_data();
1136        EncodeLocPrediction(all_loc_preds, all_gt_bboxes, *all_match_indices,
1137                            prior_bboxes, prior_variances, multibox_loss_param,
1138                            loc_pred_data, loc_gt_data);
1139      }
1140      ComputeLocLoss(loc_pred, loc_gt, *all_match_indices, num,
1141                     num_priors, loc_loss_type, &all_loc_loss);
1142    } else {
1143      for (int i = 0; i < num; ++i) {
1144        vector<float> loc_loss(num_priors, 0.f);
1145        all_loc_loss.push_back(loc_loss);
1146      }
1147    }
1148    for (int i = 0; i < num; ++i) {
1149      map<int, vector<int> >& match_indices = (*all_match_indices)[i];
1150      const map<int, vector<float> >& match_overlaps = all_match_overlaps[i];
1151      const vector<float>& conf_loss = all_conf_loss[i];
1152      const vector<float>& loc_loss = all_loc_loss[i];
1153      vector<float> loss;
1154      std::transform(conf_loss.begin(), conf_loss.end(), loc_loss.begin(),
1155                     std::back_inserter(loss), std::plus<float>());
1156      set<int> sel_indices;
1157      vector<int> neg_indices;
1158      for (map<int, vector<int> >::iterator it = match_indices.begin();
1159           it != match_indices.end(); ++it) {
1160        const int label = it->first;
1161        int num_sel = 0;
1162        vector<pair<float, int> > loss_indices;
1163        for (int m = 0; m < match_indices[label].size(); ++m) {
1164          if (IsEligibleMining(mining_type, match_indices[label][m],
1165              match_overlaps.find(label)->second[m], neg_overlap)) {
1166            loss_indices.push_back(std::make_pair(loss[m], m));
1167            ++num_sel;
1168          }
1169        }
1170        if (mining_type == MultiBoxLossParameter_MiningType_MAX_NEGATIVE) {
1171          int num_pos = 0;
1172          for (int m = 0; m < match_indices[label].size(); ++m) {
1173            if (match_indices[label][m] > -1) {
1174              ++num_pos;
1175            }
1176          }
1177          num_sel = std::min(static_cast<int>(num_pos * neg_pos_ratio), num_sel);
1178        } else if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1179          CHECK_GT(sample_size, 0);
1180          num_sel = std::min(sample_size, num_sel);
1181        }
1182        if (has_nms_param && nms_threshold > 0) {
1183          vector<float> sel_loss;
1184          vector<NormalizedBBox> sel_bboxes;
1185          if (use_prior_for_nms) {
1186            for (int m = 0; m < match_indices[label].size(); ++m) {
1187              if (IsEligibleMining(mining_type, match_indices[label][m],
1188                  match_overlaps.find(label)->second[m], neg_overlap)) {
1189                sel_loss.push_back(loss[m]);
1190                sel_bboxes.push_back(prior_bboxes[m]);
1191              }
1192            }
1193          } else {
1194            vector<NormalizedBBox> loc_bboxes;
1195            bool clip_bbox = false;
1196            DecodeBBoxes(prior_bboxes, prior_variances,
1197                         code_type, encode_variance_in_target, clip_bbox,
1198                         all_loc_preds[i].find(label)->second, &loc_bboxes);
1199            for (int m = 0; m < match_indices[label].size(); ++m) {
1200              if (IsEligibleMining(mining_type, match_indices[label][m],
1201                  match_overlaps.find(label)->second[m], neg_overlap)) {
1202                sel_loss.push_back(loss[m]);
1203                sel_bboxes.push_back(loc_bboxes[m]);
1204              }
1205            }
1206          }
1207          vector<int> nms_indices;
1208          ApplyNMS(sel_bboxes, sel_loss, nms_threshold, top_k, &nms_indices);
1209          if (nms_indices.size() < num_sel) {
1210            LOG(INFO) << "not enough sample after nms: " << nms_indices.size();
1211          }
1212          num_sel = std::min(static_cast<int>(nms_indices.size()), num_sel);
1213          for (int n = 0; n < num_sel; ++n) {
1214            sel_indices.insert(loss_indices[nms_indices[n]].second);
1215          }
1216        } else {
1217          std::sort(loss_indices.begin(), loss_indices.end(),
1218                    SortScorePairDescend<int>);
1219          for (int n = 0; n < num_sel; ++n) {
1220            sel_indices.insert(loss_indices[n].second);
1221          }
1222        }
1223        for (int m = 0; m < match_indices[label].size(); ++m) {
1224          if (match_indices[label][m] > -1) {
1225            if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE &&
1226                sel_indices.find(m) == sel_indices.end()) {
1227              match_indices[label][m] = -1;
1228              *num_matches -= 1;
1229            }
1230          } else if (match_indices[label][m] == -1) {
1231            if (sel_indices.find(m) != sel_indices.end()) {
1232              neg_indices.push_back(m);
1233              *num_negs += 1;
1234            }
1235          }
1236        }
1237      }
1238      all_neg_indices->push_back(neg_indices);
1239    }
1240  }
1241  template void MineHardExamples(const Blob<float>& conf_blob,
1242      const vector<LabelBBox>& all_loc_preds,
1243      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1244      const vector<NormalizedBBox>& prior_bboxes,
1245      const vector<vector<float> >& prior_variances,
1246      const vector<map<int, vector<float> > >& all_match_overlaps,
1247      const MultiBoxLossParameter& multibox_loss_param,
1248      int* num_matches, int* num_negs,
1249      vector<map<int, vector<int> > >* all_match_indices,
1250      vector<vector<int> >* all_neg_indices);
1251  template void MineHardExamples(const Blob<double>& conf_blob,
1252      const vector<LabelBBox>& all_loc_preds,
1253      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1254      const vector<NormalizedBBox>& prior_bboxes,
1255      const vector<vector<float> >& prior_variances,
1256      const vector<map<int, vector<float> > >& all_match_overlaps,
1257      const MultiBoxLossParameter& multibox_loss_param,
1258      int* num_matches, int* num_negs,
1259      vector<map<int, vector<int> > >* all_match_indices,
1260      vector<vector<int> >* all_neg_indices);
1261  template <typename Dtype>
1262  void GetGroundTruth(const Dtype* gt_data, const int num_gt,
1263        const int background_label_id, const bool use_difficult_gt,
1264        map<int, vector<NormalizedBBox> >* all_gt_bboxes) {
1265    all_gt_bboxes->clear();
1266    for (int i = 0; i < num_gt; ++i) {
1267      int start_idx = i * 8;
1268      int item_id = gt_data[start_idx];
1269      if (item_id == -1) {
1270        continue;
1271      }
1272      int label = gt_data[start_idx + 1];
1273      CHECK_NE(background_label_id, label)
1274          << "Found background label in the dataset.";
1275      bool difficult = static_cast<bool>(gt_data[start_idx + 7]);
1276      if (!use_difficult_gt && difficult) {
1277        continue;
1278      }
1279      NormalizedBBox bbox;
1280      bbox.set_label(label);
1281      bbox.set_xmin(gt_data[start_idx + 3]);
1282      bbox.set_ymin(gt_data[start_idx + 4]);
1283      bbox.set_xmax(gt_data[start_idx + 5]);
1284      bbox.set_ymax(gt_data[start_idx + 6]);
1285      bbox.set_difficult(difficult);
1286      float bbox_size = BBoxSize(bbox);
1287      bbox.set_size(bbox_size);
1288      (*all_gt_bboxes)[item_id].push_back(bbox);
1289    }
1290  }
1291  template void GetGroundTruth(const float* gt_data, const int num_gt,
1292        const int background_label_id, const bool use_difficult_gt,
1293        map<int, vector<NormalizedBBox> >* all_gt_bboxes);
1294  template void GetGroundTruth(const double* gt_data, const int num_gt,
1295        const int background_label_id, const bool use_difficult_gt,
1296        map<int, vector<NormalizedBBox> >* all_gt_bboxes);
1297  template <typename Dtype>
1298  void GetGroundTruth(const Dtype* gt_data, const int num_gt,
1299        const int background_label_id, const bool use_difficult_gt,
1300        map<int, LabelBBox>* all_gt_bboxes) {
1301    all_gt_bboxes->clear();
1302    for (int i = 0; i < num_gt; ++i) {
1303      int start_idx = i * 8;
1304      int item_id = gt_data[start_idx];
1305      if (item_id == -1) {
1306        break;
1307      }
1308      NormalizedBBox bbox;
1309      int label = gt_data[start_idx + 1];
1310      CHECK_NE(background_label_id, label)
1311          << "Found background label in the dataset.";
1312      bool difficult = static_cast<bool>(gt_data[start_idx + 7]);
1313      if (!use_difficult_gt && difficult) {
1314        continue;
1315      }
1316      bbox.set_xmin(gt_data[start_idx + 3]);
1317      bbox.set_ymin(gt_data[start_idx + 4]);
1318      bbox.set_xmax(gt_data[start_idx + 5]);
1319      bbox.set_ymax(gt_data[start_idx + 6]);
1320      bbox.set_difficult(difficult);
1321      float bbox_size = BBoxSize(bbox);
1322      bbox.set_size(bbox_size);
1323      (*all_gt_bboxes)[item_id][label].push_back(bbox);
1324    }
1325  }
1326  template void GetGroundTruth(const float* gt_data, const int num_gt,
1327        const int background_label_id, const bool use_difficult_gt,
1328        map<int, LabelBBox>* all_gt_bboxes);
1329  template void GetGroundTruth(const double* gt_data, const int num_gt,
1330        const int background_label_id, const bool use_difficult_gt,
1331        map<int, LabelBBox>* all_gt_bboxes);
1332  template <typename Dtype>
1333  void GetLocPredictions(const Dtype* loc_data, const int num,
1334        const int num_preds_per_class, const int num_loc_classes,
1335        const bool share_location, vector<LabelBBox>* loc_preds) {
1336    loc_preds->clear();
1337    if (share_location) {
1338      CHECK_EQ(num_loc_classes, 1);
1339    }
1340    loc_preds->resize(num);
1341  #ifdef _OPENMP
1342    #pragma omp parallel for
1343  #endif
1344    for (int i = 0; i < num; ++i) {
1345      for (int c = 0; c < num_loc_classes; ++c) {
1346        int label = share_location ? -1 : c;
1347        if ((*loc_preds)[i].find(label) == (*loc_preds)[i].end()) {
1348          (*loc_preds)[i][label].resize(num_preds_per_class);
1349        } else {
1350          break;
1351        }
1352      }
1353    }
1354  #ifdef _OPENMP
1355    #if defined(_MSC_EXTENSIONS)
1356      #pragma omp parallel for
1357    #else
1358      #pragma omp parallel for collapse(3)
1359    #endif
1360  #endif
1361      for (int i = 0; i < num; ++i) {
1362        for (int p = 0; p < num_preds_per_class; ++p) {
1363          for (int c = 0; c < num_loc_classes; ++c) {
1364            int label = share_location ? -1 : c;
1365            (*loc_preds)[i][label][p].set_xmin(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4]);
1366            (*loc_preds)[i][label][p].set_ymin(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 1]);
1367            (*loc_preds)[i][label][p].set_xmax(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 2]);
1368            (*loc_preds)[i][label][p].set_ymax(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 3]);
1369        }
1370      }
1371    }
1372  }
1373  template void GetLocPredictions(const float* loc_data, const int num,
1374        const int num_preds_per_class, const int num_loc_classes,
1375        const bool share_location, vector<LabelBBox>* loc_preds);
1376  template void GetLocPredictions(const double* loc_data, const int num,
1377        const int num_preds_per_class, const int num_loc_classes,
1378        const bool share_location, vector<LabelBBox>* loc_preds);
1379  template <typename Dtype>
1380  void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1381        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1382        const vector<map<int, vector<int> > >& all_match_indices,
1383        const vector<NormalizedBBox>& prior_bboxes,
1384        const vector<vector<float> >& prior_variances,
1385        const MultiBoxLossParameter& multibox_loss_param,
1386        Dtype* loc_pred_data, Dtype* loc_gt_data) {
1387    int num = all_loc_preds.size();
1388    const CodeType code_type = multibox_loss_param.code_type();
1389    const bool encode_variance_in_target =
1390        multibox_loss_param.encode_variance_in_target();
1391    const bool bp_inside = multibox_loss_param.bp_inside();
1392    const bool use_prior_for_matching =
1393        multibox_loss_param.use_prior_for_matching();
1394    int count = 0;
1395    for (int i = 0; i < num; ++i) {
1396      for (map<int, vector<int> >::const_iterator
1397           it = all_match_indices[i].begin();
1398           it != all_match_indices[i].end(); ++it) {
1399        const int label = it->first;
1400        const vector<int>& match_index = it->second;
1401        CHECK(all_loc_preds[i].find(label) != all_loc_preds[i].end());
1402        const vector<NormalizedBBox>& loc_pred =
1403            all_loc_preds[i].find(label)->second;
1404        for (int j = 0; j < match_index.size(); ++j) {
1405          if (match_index[j] <= -1) {
1406            continue;
1407          }
1408          const int gt_idx = match_index[j];
1409          CHECK(all_gt_bboxes.find(i) != all_gt_bboxes.end());
1410          CHECK_LT(gt_idx, all_gt_bboxes.find(i)->second.size());
1411          const NormalizedBBox& gt_bbox = all_gt_bboxes.find(i)->second[gt_idx];
1412          NormalizedBBox gt_encode;
1413          CHECK_LT(j, prior_bboxes.size());
1414          EncodeBBox(prior_bboxes[j], prior_variances[j], code_type,
1415                     encode_variance_in_target, gt_bbox, &gt_encode);
1416          loc_gt_data[count * 4] = gt_encode.xmin();
1417          loc_gt_data[count * 4 + 1] = gt_encode.ymin();
1418          loc_gt_data[count * 4 + 2] = gt_encode.xmax();
1419          loc_gt_data[count * 4 + 3] = gt_encode.ymax();
1420          CHECK_LT(j, loc_pred.size());
1421          if (bp_inside) {
1422            NormalizedBBox match_bbox = prior_bboxes[j];
1423            if (!use_prior_for_matching) {
1424              const bool clip_bbox = false;
1425              DecodeBBox(prior_bboxes[j], prior_variances[j], code_type,
1426                         encode_variance_in_target, clip_bbox, loc_pred[j],
1427                         &match_bbox);
1428            }
1429            loc_pred_data[count * 4] =
1430                (match_bbox.xmin() < 0 || match_bbox.xmin() > 1) ?
1431                gt_encode.xmin() : loc_pred[j].xmin();
1432            loc_pred_data[count * 4 + 1] =
1433                (match_bbox.ymin() < 0 || match_bbox.ymin() > 1) ?
1434                gt_encode.ymin() : loc_pred[j].ymin();
1435            loc_pred_data[count * 4 + 2] =
1436                (match_bbox.xmax() < 0 || match_bbox.xmax() > 1) ?
1437                gt_encode.xmax() : loc_pred[j].xmax();
1438            loc_pred_data[count * 4 + 3] =
1439                (match_bbox.ymax() < 0 || match_bbox.ymax() > 1) ?
1440                gt_encode.ymax() : loc_pred[j].ymax();
1441          } else {
1442            loc_pred_data[count * 4] = loc_pred[j].xmin();
1443            loc_pred_data[count * 4 + 1] = loc_pred[j].ymin();
1444            loc_pred_data[count * 4 + 2] = loc_pred[j].xmax();
1445            loc_pred_data[count * 4 + 3] = loc_pred[j].ymax();
1446          }
1447          if (encode_variance_in_target) {
1448            for (int k = 0; k < 4; ++k) {
1449              CHECK_GT(prior_variances[j][k], 0);
1450              loc_pred_data[count * 4 + k] /= prior_variances[j][k];
1451              loc_gt_data[count * 4 + k] /= prior_variances[j][k];
1452            }
1453          }
1454          ++count;
1455        }
1456      }
1457    }
1458  }
1459  template void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1460        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1461        const vector<map<int, vector<int> > >& all_match_indices,
1462        const vector<NormalizedBBox>& prior_bboxes,
1463        const vector<vector<float> >& prior_variances,
1464        const MultiBoxLossParameter& multibox_loss_param,
1465        float* loc_pred_data, float* loc_gt_data);
1466  template void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1467        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1468        const vector<map<int, vector<int> > >& all_match_indices,
1469        const vector<NormalizedBBox>& prior_bboxes,
1470        const vector<vector<float> >& prior_variances,
1471        const MultiBoxLossParameter& multibox_loss_param,
1472        double* loc_pred_data, double* loc_gt_data);
1473  template <typename Dtype>
1474  void ComputeLocLoss(const Blob<Dtype>& loc_pred, const Blob<Dtype>& loc_gt,
1475        const vector<map<int, vector<int> > >& all_match_indices,
1476        const int num, const int num_priors, const LocLossType loc_loss_type,
1477        vector<vector<float> >* all_loc_loss) {
1478    int loc_count = loc_pred.count();
1479    CHECK_EQ(loc_count, loc_gt.count());
1480    Blob<Dtype> diff;
1481    const Dtype* diff_data = NULL;
1482    if (loc_count != 0) {
1483      diff.Reshape(loc_pred.shape());
1484      caffe_sub(loc_count, loc_pred.cpu_data(), loc_gt.cpu_data(),
1485                diff.mutable_cpu_data());
1486      diff_data = diff.cpu_data();
1487    }
1488    CHECK_NOTNULL(diff_data);
1489    int count = 0;
1490    for (int i = 0; i < num; ++i) {
1491      vector<float> loc_loss(num_priors, 0.f);
1492      for (map<int, vector<int> >::const_iterator
1493           it = all_match_indices[i].begin();
1494           it != all_match_indices[i].end(); ++it) {
1495        const vector<int>& match_index = it->second;
1496        CHECK_EQ(num_priors, match_index.size());
1497        for (int j = 0; j < match_index.size(); ++j) {
1498          if (match_index[j] <= -1) {
1499            continue;
1500          }
1501          Dtype loss = 0;
1502          for (int k = 0; k < 4; ++k) {
1503            Dtype val = diff_data[count * 4 + k];
1504            if (loc_loss_type == MultiBoxLossParameter_LocLossType_SMOOTH_L1) {
1505              Dtype abs_val = fabs(val);
1506              if (abs_val < 1.) {
1507                loss += 0.5 * val * val;
1508              } else {
1509                loss += abs_val - 0.5;
1510              }
1511            } else if (loc_loss_type == MultiBoxLossParameter_LocLossType_L2) {
1512              loss += 0.5 * val * val;
1513            } else {
1514              LOG(FATAL) << "Unknown loc loss type.";
1515            }
1516          }
1517          loc_loss[j] = loss;
1518          ++count;
1519        }
1520      }
1521      all_loc_loss->push_back(loc_loss);
1522    }
1523  }
1524  template void ComputeLocLoss(const Blob<float>& loc_pred,
1525        const Blob<float>& loc_gt,
1526        const vector<map<int, vector<int> > >& all_match_indices,
1527        const int num, const int num_priors, const LocLossType loc_loss_type,
1528        vector<vector<float> >* all_loc_loss);
1529  template void ComputeLocLoss(const Blob<double>& loc_pred,
1530        const Blob<double>& loc_gt,
1531        const vector<map<int, vector<int> > >& all_match_indices,
1532        const int num, const int num_priors, const LocLossType loc_loss_type,
1533        vector<vector<float> >* all_loc_loss);
1534  template <typename Dtype>
1535  void GetConfidenceScores(const Dtype* conf_data, const int num,
1536                           const int num_preds_per_class, const int num_classes,
1537                           vector<map<int, vector<float> > >* conf_preds) {
1538    conf_preds->clear();
1539    conf_preds->resize(num);
1540    Dtype* buffer = new Dtype[num * num_preds_per_class * num_classes];
1541  #ifdef _OPENMP
1542    #if defined(_MSC_EXTENSIONS)
1543      #pragma omp parallel for
1544    #else
1545      #pragma omp parallel for collapse(3)
1546    #endif
1547  #endif
1548    for (int i = 0; i < num; ++i) {
1549      for (int c = 0; c < num_classes; ++c) {
1550        for (int p = 0; p < num_preds_per_class; ++p) {
1551          buffer[i * num_classes * num_preds_per_class + c * num_preds_per_class +
1552                 p] = conf_data[i * num_classes * num_preds_per_class +
1553                                p * num_classes + c];
1554        }
1555      }
1556    }
1557  #ifdef _OPENMP
1558    #pragma omp parallel for 
1559  #endif
1560    for (int i = 0; i < num; i++) {
1561      for (int c = 0; c < num_classes; ++c) {
1562        (*conf_preds)[i][c].reserve(num_preds_per_class);
1563        (*conf_preds)[i][c].assign(
1564            &buffer[i * num_classes * num_preds_per_class +
1565                    c * num_preds_per_class],
1566            &buffer[i * num_classes * num_preds_per_class +
1567                    c * num_preds_per_class + num_preds_per_class]);
1568      }
1569    }
1570    delete[] buffer;
1571  }
1572  template void GetConfidenceScores(const float* conf_data, const int num,
1573        const int num_preds_per_class, const int num_classes,
1574        vector<map<int, vector<float> > >* conf_preds);
1575  template void GetConfidenceScores(const double* conf_data, const int num,
1576        const int num_preds_per_class, const int num_classes,
1577        vector<map<int, vector<float> > >* conf_preds);
1578  template <typename Dtype>
1579  void GetConfidenceScores(const Dtype* conf_data, const int num,
1580        const int num_preds_per_class, const int num_classes,
1581        const bool class_major, vector<map<int, vector<float> > >* conf_preds) {
1582    conf_preds->clear();
1583    conf_preds->resize(num);
1584    for (int i = 0; i < num; ++i) {
1585      map<int, vector<float> >& label_scores = (*conf_preds)[i];
1586      if (class_major) {
1587        for (int c = 0; c < num_classes; ++c) {
1588          label_scores[c].assign(conf_data, conf_data + num_preds_per_class);
1589          conf_data += num_preds_per_class;
1590        }
1591      } else {
1592        for (int p = 0; p < num_preds_per_class; ++p) {
1593          int start_idx = p * num_classes;
1594          for (int c = 0; c < num_classes; ++c) {
1595            label_scores[c].push_back(conf_data[start_idx + c]);
1596          }
1597        }
1598        conf_data += num_preds_per_class * num_classes;
1599      }
1600    }
1601  }
1602  template void GetConfidenceScores(const float* conf_data, const int num,
1603        const int num_preds_per_class, const int num_classes,
1604        const bool class_major, vector<map<int, vector<float> > >* conf_preds);
1605  template void GetConfidenceScores(const double* conf_data, const int num,
1606        const int num_preds_per_class, const int num_classes,
1607        const bool class_major, vector<map<int, vector<float> > >* conf_preds);
1608  template <typename Dtype>
1609  void ComputeConfLoss(const Dtype* conf_data, const int num,
1610        const int num_preds_per_class, const int num_classes,
1611        const int background_label_id, const ConfLossType loss_type,
1612        vector<vector<float> >* all_conf_loss) {
1613    all_conf_loss->clear();
1614    for (int i = 0; i < num; ++i) {
1615      vector<float> conf_loss;
1616      for (int p = 0; p < num_preds_per_class; ++p) {
1617        int start_idx = p * num_classes;
1618        int label = background_label_id;
1619        Dtype loss = 0;
1620        if (loss_type == MultiBoxLossParameter_ConfLossType_SOFTMAX) {
1621          CHECK_GE(label, 0);
1622          CHECK_LT(label, num_classes);
1623          Dtype maxval = -FLT_MAX;
1624          for (int c = 0; c < num_classes; ++c) {
1625            maxval = std::max<Dtype>(conf_data[start_idx + c], maxval);
1626          }
1627          Dtype sum = 0.;
1628          for (int c = 0; c < num_classes; ++c) {
1629            sum += std::exp(conf_data[start_idx + c] - maxval);
1630          }
1631          Dtype prob = std::exp(conf_data[start_idx + label] - maxval) / sum;
1632          loss = -log(std::max(prob, Dtype(FLT_MIN)));
1633        } else if (loss_type == MultiBoxLossParameter_ConfLossType_LOGISTIC) {
1634          int target = 0;
1635          for (int c = 0; c < num_classes; ++c) {
1636            if (c == label) {
1637              target = 1;
1638            } else {
1639              target = 0;
1640            }
1641            Dtype input = conf_data[start_idx + c];
1642            loss -= input * (target - (input >= 0)) -
1643                log(1 + exp(input - 2 * input * (input >= 0)));
1644          }
1645        } else {
1646          LOG(FATAL) << "Unknown conf loss type.";
1647        }
1648        conf_loss.push_back(loss);
1649      }
1650      conf_data += num_preds_per_class * num_classes;
1651      all_conf_loss->push_back(conf_loss);
1652    }
1653  }
1654  template void ComputeConfLoss(const float* conf_data, const int num,
1655        const int num_preds_per_class, const int num_classes,
1656        const int background_label_id, const ConfLossType loss_type,
1657        vector<vector<float> >* all_conf_loss);
1658  template void ComputeConfLoss(const double* conf_data, const int num,
1659        const int num_preds_per_class, const int num_classes,
1660        const int background_label_id, const ConfLossType loss_type,
1661        vector<vector<float> >* all_conf_loss);
1662  template <typename Dtype>
1663  void ComputeConfLoss(const Dtype* conf_data, const int num,
1664        const int num_preds_per_class, const int num_classes,
1665        const int background_label_id, const ConfLossType loss_type,
1666        const vector<map<int, vector<int> > >& all_match_indices,
1667        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1668        vector<vector<float> >* all_conf_loss) {
1669    CHECK_LT(background_label_id, num_classes);
1670    all_conf_loss->clear();
1671    for (int i = 0; i < num; ++i) {
1672      vector<float> conf_loss;
<span onclick='openModal()' class='match'>1673      const map<int, vector<int> >& match_indices = all_match_indices[i];
1674      for (int p = 0; p < num_preds_per_class; ++p) {
1675        int start_idx = p * num_classes;
</span>1676        int label = background_label_id;
1677        for (map<int, vector<int> >::const_iterator it =
1678             match_indices.begin(); it != match_indices.end(); ++it) {
1679          const vector<int>& match_index = it->second;
1680          CHECK_EQ(match_index.size(), num_preds_per_class);
1681          if (match_index[p] > -1) {
1682            CHECK(all_gt_bboxes.find(i) != all_gt_bboxes.end());
1683            const vector<NormalizedBBox>& gt_bboxes =
1684                all_gt_bboxes.find(i)->second;
1685            CHECK_LT(match_index[p], gt_bboxes.size());
1686            label = gt_bboxes[match_index[p]].label();
1687            CHECK_GE(label, 0);
1688            CHECK_NE(label, background_label_id);
1689            CHECK_LT(label, num_classes);
1690            break;
1691          }
1692        }
1693        Dtype loss = 0;
1694        if (loss_type == MultiBoxLossParameter_ConfLossType_SOFTMAX) {
1695          CHECK_GE(label, 0);
1696          CHECK_LT(label, num_classes);
1697          Dtype maxval = conf_data[start_idx];
1698          for (int c = 1; c < num_classes; ++c) {
1699            maxval = std::max<Dtype>(conf_data[start_idx + c], maxval);
1700          }
1701          Dtype sum = 0.;
1702          for (int c = 0; c < num_classes; ++c) {
1703            sum += std::exp(conf_data[start_idx + c] - maxval);
1704          }
1705          Dtype prob = std::exp(conf_data[start_idx + label] - maxval) / sum;
1706          loss = -log(std::max(prob, Dtype(FLT_MIN)));
1707        } else if (loss_type == MultiBoxLossParameter_ConfLossType_LOGISTIC) {
1708          int target = 0;
1709          for (int c = 0; c < num_classes; ++c) {
1710            if (c == label) {
1711              target = 1;
1712            } else {
1713              target = 0;
1714            }
1715            Dtype input = conf_data[start_idx + c];
1716            loss -= input * (target - (input >= 0)) -
1717                log(1 + exp(input - 2 * input * (input >= 0)));
1718          }
1719        } else {
1720          LOG(FATAL) << "Unknown conf loss type.";
1721        }
1722        conf_loss.push_back(loss);
1723      }
1724      conf_data += num_preds_per_class * num_classes;
1725      all_conf_loss->push_back(conf_loss);
1726    }
1727  }
1728  template void ComputeConfLoss(const float* conf_data, const int num,
1729        const int num_preds_per_class, const int num_classes,
1730        const int background_label_id, const ConfLossType loss_type,
1731        const vector<map<int, vector<int> > >& all_match_indices,
1732        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1733        vector<vector<float> >* all_conf_loss);
1734  template void ComputeConfLoss(const double* conf_data, const int num,
1735        const int num_preds_per_class, const int num_classes,
1736        const int background_label_id, const ConfLossType loss_type,
1737        const vector<map<int, vector<int> > >& all_match_indices,
1738        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1739        vector<vector<float> >* all_conf_loss);
1740  template <typename Dtype>
1741  void EncodeConfPrediction(const Dtype* conf_data, const int num,
1742        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1743        const vector<map<int, vector<int> > >& all_match_indices,
1744        const vector<vector<int> >& all_neg_indices,
1745        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1746        Dtype* conf_pred_data, Dtype* conf_gt_data) {
1747    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
1748    const int num_classes = multibox_loss_param.num_classes();
1749    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
1750    const int background_label_id = multibox_loss_param.background_label_id();
1751    const bool map_object_to_agnostic =
1752        multibox_loss_param.map_object_to_agnostic();
1753    if (map_object_to_agnostic) {
1754      if (background_label_id >= 0) {
1755        CHECK_EQ(num_classes, 2);
1756      } else {
1757        CHECK_EQ(num_classes, 1);
1758      }
1759    }
1760    const MiningType mining_type = multibox_loss_param.mining_type();
1761    bool do_neg_mining;
1762    if (multibox_loss_param.has_do_neg_mining()) {
1763      LOG(WARNING) << "do_neg_mining is deprecated, use mining_type instead.";
1764      do_neg_mining = multibox_loss_param.do_neg_mining();
1765      CHECK_EQ(do_neg_mining,
1766               mining_type != MultiBoxLossParameter_MiningType_NONE);
1767    }
1768    do_neg_mining = mining_type != MultiBoxLossParameter_MiningType_NONE;
1769    const ConfLossType conf_loss_type = multibox_loss_param.conf_loss_type();
1770    int count = 0;
1771    for (int i = 0; i < num; ++i) {
1772      if (all_gt_bboxes.find(i) != all_gt_bboxes.end()) {
1773        const map<int, vector<int> >& match_indices = all_match_indices[i];
1774        for (map<int, vector<int> >::const_iterator it =
1775            match_indices.begin(); it != match_indices.end(); ++it) {
1776          const vector<int>& match_index = it->second;
1777          CHECK_EQ(match_index.size(), num_priors);
1778          for (int j = 0; j < num_priors; ++j) {
1779            if (match_index[j] <= -1) {
1780              continue;
1781            }
1782            const int gt_label = map_object_to_agnostic ?
1783              background_label_id + 1 :
1784              all_gt_bboxes.find(i)->second[match_index[j]].label();
1785            int idx = do_neg_mining ? count : j;
1786            switch (conf_loss_type) {
1787              case MultiBoxLossParameter_ConfLossType_SOFTMAX:
1788                conf_gt_data[idx] = gt_label;
1789                break;
1790              case MultiBoxLossParameter_ConfLossType_LOGISTIC:
1791                conf_gt_data[idx * num_classes + gt_label] = 1;
1792                break;
1793              default:
1794                LOG(FATAL) << "Unknown conf loss type.";
1795            }
1796            if (do_neg_mining) {
1797              caffe_copy<Dtype>(num_classes, conf_data + j * num_classes,
1798                  conf_pred_data + count * num_classes);
1799              ++count;
1800            }
1801          }
1802        }
1803        if (do_neg_mining) {
1804          for (int n = 0; n < all_neg_indices[i].size(); ++n) {
1805            int j = all_neg_indices[i][n];
1806            CHECK_LT(j, num_priors);
1807            caffe_copy<Dtype>(num_classes, conf_data + j * num_classes,
1808                conf_pred_data + count * num_classes);
1809            switch (conf_loss_type) {
1810              case MultiBoxLossParameter_ConfLossType_SOFTMAX:
1811                conf_gt_data[count] = background_label_id;
1812                break;
1813              case MultiBoxLossParameter_ConfLossType_LOGISTIC:
1814                if (background_label_id >= 0 &&
1815                    background_label_id < num_classes) {
1816                  conf_gt_data[count * num_classes + background_label_id] = 1;
1817                }
1818                break;
1819              default:
1820                LOG(FATAL) << "Unknown conf loss type.";
1821            }
1822            ++count;
1823          }
1824        }
1825      }
1826      if (do_neg_mining) {
1827        conf_data += num_priors * num_classes;
1828      } else {
1829        conf_gt_data += num_priors;
1830      }
1831    }
1832  }
1833  template void EncodeConfPrediction(const float* conf_data, const int num,
1834        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1835        const vector<map<int, vector<int> > >& all_match_indices,
1836        const vector<vector<int> >& all_neg_indices,
1837        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1838        float* conf_pred_data, float* conf_gt_data);
1839  template void EncodeConfPrediction(const double* conf_data, const int num,
1840        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1841        const vector<map<int, vector<int> > >& all_match_indices,
1842        const vector<vector<int> >& all_neg_indices,
1843        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1844        double* conf_pred_data, double* conf_gt_data);
1845  template <typename Dtype>
1846  void GetPriorBBoxes(const Dtype* prior_data, const int num_priors,
1847        vector<NormalizedBBox>* prior_bboxes,
1848        vector<vector<float> >* prior_variances) {
1849  #ifdef _OPENMP
1850    #pragma omp parallel for
1851  #endif
1852    for (int i = 0; i < num_priors; ++i) {
1853      NormalizedBBox bbox;
1854      bbox.set_xmin(prior_data[i*4]);
1855      bbox.set_ymin(prior_data[i*4 + 1]);
1856      bbox.set_xmax(prior_data[i*4 + 2]);
1857      bbox.set_ymax(prior_data[i*4 + 3]);
1858      bbox.set_size(BBoxSize(bbox));
1859      prior_bboxes->at(i) = bbox;
1860    }
1861    vector<float> var(4, 0);
1862    for (int i = 0; i < num_priors; ++i) {
1863      for (int j = 0; j < 4; ++j) {
1864        var.at(j) = (prior_data[(num_priors + i) * 4 + j]);
1865      }
1866      prior_variances->at(i) = var;
1867    }
1868  }
1869  template void GetPriorBBoxes(const float* prior_data, const int num_priors,
1870        vector<NormalizedBBox>* prior_bboxes,
1871        vector<vector<float> >* prior_variances);
1872  template void GetPriorBBoxes(const double* prior_data, const int num_priors,
1873        vector<NormalizedBBox>* prior_bboxes,
1874        vector<vector<float> >* prior_variances);
1875  template <typename Dtype>
1876  void GetDetectionResults(const Dtype* det_data, const int num_det,
1877        const int background_label_id,
1878        map<int, map<int, vector<NormalizedBBox> > >* all_detections) {
1879    all_detections->clear();
1880    for (int i = 0; i < num_det; ++i) {
1881      int start_idx = i * 7;
1882      int item_id = det_data[start_idx];
1883      if (item_id == -1) {
1884        continue;
1885      }
1886      int label = det_data[start_idx + 1];
1887      CHECK_NE(background_label_id, label)
1888          << "Found background label in the detection results.";
1889      NormalizedBBox bbox;
1890      bbox.set_score(det_data[start_idx + 2]);
1891      bbox.set_xmin(det_data[start_idx + 3]);
1892      bbox.set_ymin(det_data[start_idx + 4]);
1893      bbox.set_xmax(det_data[start_idx + 5]);
1894      bbox.set_ymax(det_data[start_idx + 6]);
1895      float bbox_size = BBoxSize(bbox);
1896      bbox.set_size(bbox_size);
1897      (*all_detections)[item_id][label].push_back(bbox);
1898    }
1899  }
1900  template void GetDetectionResults(const float* det_data, const int num_det,
1901        const int background_label_id,
1902        map<int, map<int, vector<NormalizedBBox> > >* all_detections);
1903  template void GetDetectionResults(const double* det_data, const int num_det,
1904        const int background_label_id,
1905        map<int, map<int, vector<NormalizedBBox> > >* all_detections);
1906  void GetTopKScoreIndex(const vector<float>& scores, const vector<int>& indices,
1907        const int top_k, vector<pair<float, int> >* score_index_vec) {
1908    CHECK_EQ(scores.size(), indices.size());
1909    for (int i = 0; i < scores.size(); ++i) {
1910      score_index_vec->push_back(std::make_pair(scores[i], indices[i]));
1911    }
1912    std::stable_sort(score_index_vec->begin(), score_index_vec->end(),
1913                     SortScorePairDescend<int>);
1914    if (top_k > -1 && top_k < score_index_vec->size()) {
1915      score_index_vec->resize(top_k);
1916    }
1917  }
1918  void GetMaxScoreIndex(const vector<float>& scores, const float threshold,
1919        const int top_k, vector<pair<float, int> >* score_index_vec) {
1920  #ifdef _OPENMP
1921    #pragma omp parallel for
1922  #endif
1923    for (int i = 0; i < scores.size(); ++i) {
1924      if (scores[i] > threshold) {
1925        score_index_vec->at(i) = std::make_pair(scores[i], i);
1926      }
1927    }
1928    std::stable_sort(score_index_vec->begin(), score_index_vec->end(),
1929                     SortScorePairDescend<int>);
1930    if (top_k > -1 && top_k < score_index_vec->size()) {
1931      score_index_vec->resize(top_k);
1932    }
1933  }
1934  template <typename Dtype>
1935  void GetMaxScoreIndex(const Dtype* scores, const int num, const float threshold,
1936        const int top_k, vector<pair<Dtype, int> >* score_index_vec) {
1937    for (int i = 0; i < num; ++i) {
1938      if (scores[i] > threshold) {
1939        score_index_vec->push_back(std::make_pair(scores[i], i));
1940      }
1941    }
1942    std::sort(score_index_vec->begin(), score_index_vec->end(),
1943              SortScorePairDescend<int>);
1944    if (top_k > -1 && top_k < score_index_vec->size()) {
1945      score_index_vec->resize(top_k);
1946    }
1947  }
1948  template
1949  void GetMaxScoreIndex(const float* scores, const int num, const float threshold,
1950        const int top_k, vector<pair<float, int> >* score_index_vec);
1951  template
1952  void GetMaxScoreIndex(const double* scores, const int num,
1953        const float threshold, const int top_k,
1954        vector<pair<double, int> >* score_index_vec);
1955  void ApplyNMS(const vector<NormalizedBBox>& bboxes, const vector<float>& scores,
1956        const float threshold, const int top_k, const bool reuse_overlaps,
1957        map<int, map<int, float> >* overlaps, vector<int>* indices) {
1958    CHECK_EQ(bboxes.size(), scores.size())
1959        << "bboxes and scores have different size.";
1960    vector<int> idx(boost::counting_iterator<int>(0),
1961                    boost::counting_iterator<int>(scores.size()));
1962    vector<pair<float, int> > score_index_vec;
1963    GetTopKScoreIndex(scores, idx, top_k, &score_index_vec);
1964    indices->clear();
1965    while (score_index_vec.size() != 0) {
1966      int best_idx = score_index_vec.front().second;
1967      const NormalizedBBox& best_bbox = bboxes[best_idx];
1968      if (BBoxSize(best_bbox) < 1e-5) {
1969        score_index_vec.erase(score_index_vec.begin());
1970        continue;
1971      }
1972      indices->push_back(best_idx);
1973      score_index_vec.erase(score_index_vec.begin());
1974      if (top_k > -1 && indices->size() >= top_k) {
1975        break;
1976      }
1977      for (vector<pair<float, int> >::iterator it = score_index_vec.begin();
1978           it != score_index_vec.end(); ) {
1979        int cur_idx = it->second;
1980        const NormalizedBBox& cur_bbox = bboxes[cur_idx];
1981        if (BBoxSize(cur_bbox) < 1e-5) {
1982          it = score_index_vec.erase(it);
1983          continue;
1984        }
1985        float cur_overlap = 0.;
1986        if (reuse_overlaps) {
1987          if (overlaps->find(best_idx) != overlaps->end() &&
1988              overlaps->find(best_idx)->second.find(cur_idx) !=
1989              (*overlaps)[best_idx].end()) {
1990            cur_overlap = (*overlaps)[best_idx][cur_idx];
1991          } else if (overlaps->find(cur_idx) != overlaps->end() &&
1992                     overlaps->find(cur_idx)->second.find(best_idx) !=
1993                     (*overlaps)[cur_idx].end()) {
1994            cur_overlap = (*overlaps)[cur_idx][best_idx];
1995          } else {
1996            cur_overlap = JaccardOverlap(best_bbox, cur_bbox);
1997            (*overlaps)[best_idx][cur_idx] = cur_overlap;
1998          }
1999        } else {
2000          cur_overlap = JaccardOverlap(best_bbox, cur_bbox);
2001        }
2002        if (cur_overlap > threshold) {
2003          it = score_index_vec.erase(it);
2004        } else {
2005          ++it;
2006        }
2007      }
2008    }
2009  }
2010  void ApplyNMS(const vector<NormalizedBBox>& bboxes, const vector<float>& scores,
2011        const float threshold, const int top_k, vector<int>* indices) {
2012    bool reuse_overlap = false;
2013    map<int, map<int, float> > overlaps;
2014    ApplyNMS(bboxes, scores, threshold, top_k, reuse_overlap, &overlaps, indices);
2015  }
2016  void ApplyNMS(const bool* overlapped, const int num, vector<int>* indices) {
2017    vector<int> index_vec(boost::counting_iterator<int>(0),
2018                          boost::counting_iterator<int>(num));
2019    indices->clear();
2020    while (index_vec.size() != 0) {
2021      int best_idx = index_vec.front();
2022      indices->push_back(best_idx);
2023      index_vec.erase(index_vec.begin());
2024      for (vector<int>::iterator it = index_vec.begin(); it != index_vec.end();) {
2025        int cur_idx = *it;
2026        if (overlapped[best_idx * num + cur_idx]) {
2027          it = index_vec.erase(it);
2028        } else {
2029          ++it;
2030        }
2031      }
2032    }
2033  }
2034  inline int clamp(const int v, const int a, const int b) {
2035    return v < a ? a : v > b ? b : v;
2036  }
2037  void ApplyNMSFast(const vector<NormalizedBBox>& bboxes,
2038                    const vector<float>& scores, const float score_threshold,
2039                    const float nms_threshold, const float eta, const int top_k,
2040                    vector<int>* indices) {
2041    CHECK_EQ(bboxes.size(), scores.size())
2042        << "bboxes and scores have different size.";
2043    vector<pair<float, int> > score_index_vec(scores.size());
2044    GetMaxScoreIndex(scores, score_threshold, top_k, &score_index_vec);
2045    float adaptive_threshold = nms_threshold;
2046    indices->clear();
2047  #ifdef ENABLE_NMS_OPTIMIZATION
2048    if (_may_i_use_cpu_feature(_FEATURE_AVX512CD | _FEATURE_AVX512F)) {
2049      if (score_index_vec.size() == 0) return;
2050      indices->resize(score_index_vec.size());
2051      int* p = (int*)malloc(sizeof(int) * score_index_vec.size());
2052      int num_out = 0;
2053      cpu_nms_avx512_caffe(p, &num_out, bboxes, score_index_vec, nms_threshold);
2054      indices->assign(p, p + num_out);
2055      free(p);
2056    } else {
2057  #endif
2058      while (score_index_vec.size() != 0) {
2059        const int idx = score_index_vec.front().second;
2060        bool keep = true;
2061        for (int k = 0; k < indices->size(); ++k) {
2062          if (keep) {
2063            const int kept_idx = (*indices)[k];
2064            float overlap = JaccardOverlap(bboxes[idx], bboxes[kept_idx]);
2065            keep = overlap <= adaptive_threshold;
2066          } else {
2067            break;
2068          }
2069        }
2070        if (keep) {
2071          indices->push_back(idx);
2072        }
2073        score_index_vec.erase(score_index_vec.begin());
2074        if (keep && eta < 1 && adaptive_threshold > 0.5) {
2075          adaptive_threshold *= eta;
2076        }
2077      }
2078  #ifdef ENABLE_NMS_OPTIMIZATION
2079    }
2080  #endif
2081  }
2082  template <typename Dtype>
2083  void ApplyNMSFast(const Dtype* bboxes, const Dtype* scores, const int num,
2084        const float score_threshold, const float nms_threshold,
2085        const float eta, const int top_k, vector<int>* indices) {
2086    vector<pair<Dtype, int> > score_index_vec;
2087    GetMaxScoreIndex(scores, num, score_threshold, top_k, &score_index_vec);
2088    float adaptive_threshold = nms_threshold;
2089    indices->clear();
2090    while (score_index_vec.size() != 0) {
2091      const int idx = score_index_vec.front().second;
2092      bool keep = true;
2093      for (int k = 0; k < indices->size(); ++k) {
2094        if (keep) {
2095          const int kept_idx = (*indices)[k];
2096          float overlap = JaccardOverlap(bboxes + idx * 4, bboxes + kept_idx * 4);
2097          keep = overlap <= adaptive_threshold;
2098        } else {
2099          break;
2100        }
2101      }
2102      if (keep) {
2103        indices->push_back(idx);
2104      }
2105      score_index_vec.erase(score_index_vec.begin());
2106      if (keep && eta < 1 && adaptive_threshold > 0.5) {
2107        adaptive_threshold *= eta;
2108      }
2109    }
2110  }
2111  template
2112  void ApplyNMSFast(const float* bboxes, const float* scores, const int num,
2113        const float score_threshold, const float nms_threshold,
2114        const float eta, const int top_k, vector<int>* indices);
2115  template
2116  void ApplyNMSFast(const double* bboxes, const double* scores, const int num,
2117        const float score_threshold, const float nms_threshold,
2118        const float eta, const int top_k, vector<int>* indices);
2119  void CumSum(const vector<pair<float, int> >& pairs, vector<int>* cumsum) {
2120    vector<pair<float, int> > sort_pairs = pairs;
2121    std::stable_sort(sort_pairs.begin(), sort_pairs.end(),
2122                     SortScorePairDescend<int>);
2123    cumsum->clear();
2124    for (int i = 0; i < sort_pairs.size(); ++i) {
2125      if (i == 0) {
2126        cumsum->push_back(sort_pairs[i].second);
2127      } else {
2128        cumsum->push_back(cumsum->back() + sort_pairs[i].second);
2129      }
2130    }
2131  }
2132  void ComputeAP(const vector<pair<float, int> >& tp, const int num_pos,
2133                 const vector<pair<float, int> >& fp, const string ap_version,
2134                 vector<float>* prec, vector<float>* rec, float* ap) {
2135    const float eps = 1e-6;
2136    CHECK_EQ(tp.size(), fp.size()) << "tp must have same size as fp.";
2137    const int num = tp.size();
2138    for (int i = 0; i < num; ++i) {
2139      CHECK_LE(fabs(tp[i].first - fp[i].first), eps);
2140      CHECK_EQ(tp[i].second, 1 - fp[i].second);
2141    }
2142    prec->clear();
2143    rec->clear();
2144    *ap = 0;
2145    if (tp.size() == 0 || num_pos == 0) {
2146      return;
2147    }
2148    vector<int> tp_cumsum;
2149    CumSum(tp, &tp_cumsum);
2150    CHECK_EQ(tp_cumsum.size(), num);
2151    vector<int> fp_cumsum;
2152    CumSum(fp, &fp_cumsum);
2153    CHECK_EQ(fp_cumsum.size(), num);
2154    for (int i = 0; i < num; ++i) {
2155      prec->push_back(static_cast<float>(tp_cumsum[i]) /
2156                      (tp_cumsum[i] + fp_cumsum[i]));
2157    }
2158    for (int i = 0; i < num; ++i) {
2159      CHECK_LE(tp_cumsum[i], num_pos);
2160      rec->push_back(static_cast<float>(tp_cumsum[i]) / num_pos);
2161    }
2162    if (ap_version == "11point") {
2163      vector<float> max_precs(11, 0.);
2164      int start_idx = num - 1;
2165      for (int j = 10; j >= 0; --j) {
2166        for (int i = start_idx; i >= 0 ; --i) {
2167          if ((*rec)[i] < j / 10.) {
2168            start_idx = i;
2169            if (j > 0) {
2170              max_precs[j-1] = max_precs[j];
2171            }
2172            break;
2173          } else {
2174            if (max_precs[j] < (*prec)[i]) {
2175              max_precs[j] = (*prec)[i];
2176            }
2177          }
2178        }
2179      }
2180      for (int j = 10; j >= 0; --j) {
2181        *ap += max_precs[j] / 11;
2182      }
2183    } else if (ap_version == "MaxIntegral") {
2184      float cur_rec = rec->back();
2185      float cur_prec = prec->back();
2186      for (int i = num - 2; i >= 0; --i) {
2187        cur_prec = std::max<float>((*prec)[i], cur_prec);
2188        if (fabs(cur_rec - (*rec)[i]) > eps) {
2189          *ap += cur_prec * fabs(cur_rec - (*rec)[i]);
2190        }
2191        cur_rec = (*rec)[i];
2192      }
2193      *ap += cur_rec * cur_prec;
2194    } else if (ap_version == "Integral") {
2195      float prev_rec = 0.;
2196      for (int i = 0; i < num; ++i) {
2197        if (fabs((*rec)[i] - prev_rec) > eps) {
2198          *ap += (*prec)[i] * fabs((*rec)[i] - prev_rec);
2199        }
2200        prev_rec = (*rec)[i];
2201      }
2202    } else {
2203      LOG(FATAL) << "Unknown ap_version: " << ap_version;
2204    }
2205  }
2206  #ifdef USE_OPENCV
2207  cv::Scalar HSV2RGB(const float h, const float s, const float v) {
2208    const int h_i = static_cast<int>(h * 6);
2209    const float f = h * 6 - h_i;
2210    const float p = v * (1 - s);
2211    const float q = v * (1 - f*s);
2212    const float t = v * (1 - (1 - f) * s);
2213    float r, g, b;
2214    switch (h_i) {
2215      case 0:
2216        r = v; g = t; b = p;
2217        break;
2218      case 1:
2219        r = q; g = v; b = p;
2220        break;
2221      case 2:
2222        r = p; g = v; b = t;
2223        break;
2224      case 3:
2225        r = p; g = q; b = v;
2226        break;
2227      case 4:
2228        r = t; g = p; b = v;
2229        break;
2230      case 5:
2231        r = v; g = p; b = q;
2232        break;
2233      default:
2234        r = 1; g = 1; b = 1;
2235        break;
2236    }
2237    return cv::Scalar(r * 255, g * 255, b * 255);
2238  }
2239  vector<cv::Scalar> GetColors(const int n) {
2240    vector<cv::Scalar> colors;
2241    cv::RNG rng(12345);
2242    const float golden_ratio_conjugate = 0.618033988749895;
2243    const float s = 0.3;
2244    const float v = 0.99;
2245    for (int i = 0; i < n; ++i) {
2246      const float h = std::fmod(rng.uniform(0.f, 1.f) + golden_ratio_conjugate,
2247                                1.f);
2248      colors.push_back(HSV2RGB(h, s, v));
2249    }
2250    return colors;
2251  }
2252  static clock_t start_clock = clock();
2253  static cv::VideoWriter cap_out;
2254  template <typename Dtype>
2255  void VisualizeBBox(const vector<cv::Mat>& images, const Blob<Dtype>* detections,
2256                     const float threshold, const vector<cv::Scalar>& colors,
2257                     const map<int, string>& label_to_display_name,
2258                     const string& save_file) {
2259    CHECK_EQ(detections->width(), 7);
2260    const int num_det = detections->height();
2261    const int num_img = images.size();
2262    if (num_det == 0 || num_img == 0) {
2263      return;
2264    }
2265    float fps = num_img / (static_cast<double>(clock() - start_clock) /
2266            CLOCKS_PER_SEC);
2267    const Dtype* detections_data = detections->cpu_data();
2268    const int width = images[0].cols;
2269    const int height = images[0].rows;
2270    vector<LabelBBox> all_detections(num_img);
2271    for (int i = 0; i < num_det; ++i) {
2272      const int img_idx = detections_data[i * 7];
2273      CHECK_LT(img_idx, num_img);
2274      const int label = detections_data[i * 7 + 1];
2275      const float score = detections_data[i * 7 + 2];
2276      if (score < threshold) {
2277        continue;
2278      }
2279      NormalizedBBox bbox;
2280      bbox.set_xmin(detections_data[i * 7 + 3] * width);
2281      bbox.set_ymin(detections_data[i * 7 + 4] * height);
2282      bbox.set_xmax(detections_data[i * 7 + 5] * width);
2283      bbox.set_ymax(detections_data[i * 7 + 6] * height);
2284      bbox.set_score(score);
2285      all_detections[img_idx][label].push_back(bbox);
2286    }
2287    int fontface = cv::FONT_HERSHEY_SIMPLEX;
2288    double scale = 1;
2289    int thickness = 2;
2290    int baseline = 0;
2291    char buffer[50];
2292    for (int i = 0; i < num_img; ++i) {
2293      cv::Mat image = images[i];
2294      snprintf(buffer, sizeof(buffer), "FPS: %.2f", fps);
2295      cv::Size text = cv::getTextSize(buffer, fontface, scale, thickness,
2296                                      &baseline);
2297      cv::rectangle(image, cv::Point(0, 0),
2298                    cv::Point(text.width, text.height + baseline),
2299                    CV_RGB(255, 255, 255), CV_FILLED);
2300      cv::putText(image, buffer, cv::Point(0, text.height + baseline / 2.),
2301                  fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
2302      for (map<int, vector<NormalizedBBox> >::iterator it =
2303           all_detections[i].begin(); it != all_detections[i].end(); ++it) {
2304        int label = it->first;
2305        string label_name = "Unknown";
2306        if (label_to_display_name.find(label) != label_to_display_name.end()) {
2307          label_name = label_to_display_name.find(label)->second;
2308        }
2309        CHECK_LT(label, colors.size());
2310        const cv::Scalar& color = colors[label];
2311        const vector<NormalizedBBox>& bboxes = it->second;
2312        for (int j = 0; j < bboxes.size(); ++j) {
2313          cv::Point top_left_pt(bboxes[j].xmin(), bboxes[j].ymin());
2314          cv::Point bottom_right_pt(bboxes[j].xmax(), bboxes[j].ymax());
2315          cv::rectangle(image, top_left_pt, bottom_right_pt, color, 4);
2316          cv::Point bottom_left_pt(bboxes[j].xmin(), bboxes[j].ymax());
2317          snprintf(buffer, sizeof(buffer), "%s: %.2f", label_name.c_str(),
2318                   bboxes[j].score());
2319          cv::Size text = cv::getTextSize(buffer, fontface, scale, thickness,
2320                                          &baseline);
2321          cv::rectangle(
2322              image, bottom_left_pt + cv::Point(0, 0),
2323              bottom_left_pt + cv::Point(text.width, -text.height-baseline),
2324              color, CV_FILLED);
2325          cv::putText(image, buffer, bottom_left_pt - cv::Point(0, baseline),
2326                      fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
2327        }
2328      }
2329      if (!save_file.empty()) {
2330        if (!cap_out.isOpened()) {
2331          cv::Size size(image.size().width, image.size().height);
2332          cv::VideoWriter outputVideo(save_file, CV_FOURCC('D', 'I', 'V', 'X'),
2333              30, size, true);
2334          cap_out = outputVideo;
2335        }
2336        cap_out.write(image);
2337      }
2338      cv::imshow("detections", image);
2339      if (cv::waitKey(1) == 27) {
2340        raise(SIGINT);
2341      }
2342    }
2343    start_clock = clock();
2344  }
2345  template
2346  void VisualizeBBox(const vector<cv::Mat>& images,
2347                     const Blob<float>* detections,
2348                     const float threshold, const vector<cv::Scalar>& colors,
2349                     const map<int, string>& label_to_display_name,
2350                     const string& save_file);
2351  template
2352  void VisualizeBBox(const vector<cv::Mat>& images,
2353                     const Blob<double>* detections,
2354                     const float threshold, const vector<cv::Scalar>& colors,
2355                     const map<int, string>& label_to_display_name,
2356                     const string& save_file);
2357  #endif  
2358  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.h</h3>
            <pre><code>1  #include "bd.h"
2  #include <new>
3  typedef int TUniVecIdx;
4  typedef enum TUnicodeErrorHandling_
5  {
6  	uehIgnore = 0,  
7  	uehThrow = 1,   
8  	uehReplace = 2, 
9  	uehAbort = 3    
10  }
11  TUnicodeErrorHandling;
12  class TUnicodeException
13  {
14  public:
15  	TStr message;  
16  	size_t srcIdx; 
17  	int srcChar;   
18  	TUnicodeException(size_t srcIdx_, int srcChar_, const TStr& message_) :
19  		message(message_), srcIdx(srcIdx_), srcChar(srcChar_) { }
20  };
21  typedef enum TUniByteOrder_
22  {
23  	boMachineEndian = 0,
24  	boLittleEndian = 1,
25  	boBigEndian = 2
26  }
27  TUniByteOrder;
28  typedef enum TUtf16BomHandling_
29  {
30  	bomAllowed = 0,   
31  	bomRequired = 1,  
32  	bomIgnored = 2    
33  }
34  TUtf16BomHandling;
35  class TUniCodec
36  {
37  public:
38  	enum { DefaultReplacementChar = 0xfffd };
39  	int replacementChar;
40  	TUnicodeErrorHandling errorHandling;
41  	bool strict;
42  	bool skipBom;
43  	TUniCodec() : replacementChar(DefaultReplacementChar), errorHandling(uehIgnore), strict(false), skipBom(true)
44  	{
45  	}
46  	TUniCodec(TUnicodeErrorHandling errorHandling_, bool strict_, int replacementChar_, bool skipBom_) :
47  		replacementChar(replacementChar_), errorHandling(errorHandling_), strict(strict_), skipBom(skipBom_)
48  	{
49  	}
50  protected:
51  	enum {
52  #define DefineByte(b7, b6, b5, b4, b3, b2, b1, b0) _ ## b7 ## b6 ## b5 ## b4 ## _ ## b3 ## b2 ## b1 ## b0 = (b7 << 7) | (b6 << 6) | (b5 << 5) | (b4 << 4) | (b3 << 3) | (b2 << 2) | (b1 << 1) | b0
53  		DefineByte(1, 0, 0, 0, 0, 0, 0, 0),
54  		DefineByte(1, 1, 0, 0, 0, 0, 0, 0),
55  		DefineByte(1, 1, 1, 0, 0, 0, 0, 0),
56  		DefineByte(1, 1, 1, 1, 0, 0, 0, 0),
57  		DefineByte(1, 1, 1, 1, 1, 0, 0, 0),
58  		DefineByte(1, 1, 1, 1, 1, 1, 0, 0),
59  		DefineByte(1, 1, 1, 1, 1, 1, 1, 0),
60  		DefineByte(0, 0, 1, 1, 1, 1, 1, 1),
61  		DefineByte(0, 0, 0, 1, 1, 1, 1, 1),
62  		DefineByte(0, 0, 0, 0, 1, 1, 1, 1),
63  		DefineByte(0, 0, 0, 0, 0, 1, 1, 1),
64  		DefineByte(0, 0, 0, 0, 0, 0, 1, 1)
65  #undef DefineByte
66  	};
67  	typedef TUniVecIdx TVecIdx;
68  	friend class TUniCaseFolding;
69  	friend class TUnicode;
70  public:
71  	template<typename TSrcVec, typename TDestCh>
72  	size_t DecodeUtf8(
73  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
74  		TVec<TDestCh>& dest, const bool clrDest = true) const;
75  	template<typename TSrcVec, typename TDestCh>
76  	size_t DecodeUtf8(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { return DecodeUtf8(src, 0, src.Len(), dest, clrDest); }
77  	template<typename TSrcVec, typename TDestCh>
78  	size_t EncodeUtf8(
79  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
80  		TVec<TDestCh>& dest, const bool clrDest = true) const;
81  	template<typename TSrcVec, typename TDestCh>
82  	size_t EncodeUtf8(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { return EncodeUtf8(src, 0, src.Len(), dest, clrDest); }
83  	template<typename TSrcVec> TStr EncodeUtf8Str(const TSrcVec& src, size_t srcIdx, const size_t srcCount) const { TVec<char> temp; EncodeUtf8(src, srcIdx, srcCount, temp); TStr retVal = &(temp[0]); return retVal; }
84  	template<typename TSrcVec> TStr EncodeUtf8Str(const TSrcVec& src) const { TVec<char> temp; EncodeUtf8(src, temp); temp.Add(0); TStr retVal = &(temp[0]); return retVal; }
85  protected:
86  	enum {
87  		Utf16FirstSurrogate = 0xd800,
88  		Utf16SecondSurrogate = 0xdc00
89  	};
90  	static bool IsMachineLittleEndian();
91  public:
92  	template<typename TSrcVec, typename TDestCh>
93  	size_t DecodeUtf16FromBytes(
94  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
95  		TVec<TDestCh>& dest, const bool clrDest,
96  		const TUtf16BomHandling bomHandling = bomAllowed,
97  		const TUniByteOrder defaultByteOrder = boMachineEndian) const;
98  	template<typename TSrcVec, typename TDestCh>
99  	size_t DecodeUtf16FromWords(
100  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
101  		TVec<TDestCh>& dest, bool clrDest,
102  		const TUtf16BomHandling bomHandling = bomAllowed,
103  		const TUniByteOrder defaultByteOrder = boMachineEndian) const;
104  	template<typename TSrcVec, typename TDestCh>
105  	size_t EncodeUtf16ToWords(
106  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
107  		TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
108  		const TUniByteOrder destByteOrder = boMachineEndian) const;
109  	template<typename TSrcVec, typename TDestCh>
110  	size_t EncodeUtf16ToBytes(
111  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
112  		TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
113  		const TUniByteOrder destByteOrder = boMachineEndian) const;
114  protected:
115  	static uint GetRndUint(TRnd& rnd);
116  	static uint GetRndUint(TRnd& rnd, uint minVal, uint maxVal);
117  protected:
118  	void TestUtf8(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest, FILE *f);
119  	void TestDecodeUtf8(TRnd& rnd, const TStr& testCaseDesc);
120  public:
121  	void TestUtf8();
122  protected:
123  	void WordsToBytes(const TIntV& src, TIntV& dest);
124  	void TestUtf16(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest,
125  		const TUtf16BomHandling bomHandling, const TUniByteOrder defaultByteOrder, const bool insertBom,
126  		FILE *f);
127  	static inline int SwapBytes(int x) {
128  		return ((x >> 8) & 0xff) | ((x & 0xff) << 8); }
129  	void TestDecodeUtf16(TRnd& rnd, const TStr& testCaseDesc,
130  		const TUtf16BomHandling bomHandling,
131  		const TUniByteOrder defaultByteOrder,
132  		const bool insertBom);
133  public:
134  	void TestUtf16();
135  };
136  typedef THash<TInt, TIntV> TIntIntVH;
137  class TUniCaseFolding
138  {
139  protected:
140  	TIntH cfCommon, cfSimple, cfTurkic;
141  	TIntIntVH cfFull;
142  	template<typename TSrcDat, typename TDestDat>
143  	inline static void AppendVector(const TVec<TSrcDat>& src, TVec<TDestDat>& dest) {
144  		for (int i = 0; i < src.Len(); i++) dest.Add(src[i]); }
145  	friend class TUniChDb;
146  	typedef TUniVecIdx TVecIdx;
147  public:
148  	TUniCaseFolding() { }
149  	explicit TUniCaseFolding(TSIn& SIn) : cfCommon(SIn), cfSimple(SIn), cfTurkic(SIn), cfFull(SIn) { SIn.LoadCs(); }
150  	void Load(TSIn& SIn) { cfCommon.Load(SIn); cfSimple.Load(SIn); cfFull.Load(SIn); cfTurkic.Load(SIn); SIn.LoadCs(); }
151  	void Save(TSOut& SOut) const { cfCommon.Save(SOut); cfSimple.Save(SOut); cfFull.Save(SOut); cfTurkic.Save(SOut); SOut.SaveCs(); }
152  	void Clr() { cfCommon.Clr(); cfSimple.Clr(); cfFull.Clr(); cfTurkic.Clr(); }
153  	void LoadTxt(const TStr& fileName);
154  	template<typename TSrcVec, typename TDestCh>
155  	void Fold(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
156  		TVec<TDestCh>& dest, const bool clrDest, const bool full, const bool turkic) const
157  	{
158  		for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; )
159  		{
160  			int c = src[TVecIdx(srcIdx)], i; srcIdx++;
161  			if (turkic && ((i = cfTurkic.GetKeyId(c)) >= 0)) { dest.Add(cfTurkic[i]); continue; }
162  			if (full && ((i = cfFull.GetKeyId(c)) >= 0)) { AppendVector(cfFull[i], dest); continue; }
163  			if ((! full) && ((i = cfSimple.GetKeyId(c)) >= 0)) { dest.Add(cfSimple[i]); continue; }
164  			i = cfCommon.GetKeyId(c); if (i >= 0) dest.Add(cfCommon[i]); else dest.Add(c);
165  		}
166  	}
167  	template<typename TSrcVec>
168  	void FoldInPlace(TSrcVec& src, size_t srcIdx, const size_t srcCount, const bool turkic) const
169  	{
170  		for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++)
171  		{
172  			int c = src[TVecIdx(srcIdx)], i;
173  			if (turkic && ((i = cfTurkic.GetKeyId(c)) >= 0)) { src[TVecIdx(srcIdx)] = cfTurkic[i]; continue; }
174  			if ((i = cfSimple.GetKeyId(c)) >= 0) { src[TVecIdx(srcIdx)] = cfSimple[i]; continue; }
175  			i = cfCommon.GetKeyId(c); if (i >= 0) src[TVecIdx(srcIdx)] = cfCommon[i];
176  		}
177  	}
178  protected:
179  	void Test(const TIntV& src, const TIntV& expectedDest, const bool full, const bool turkic, FILE *f);
180  public:
181  	void Test();
182  };
183  class TCodecBase;
184  typedef TPt<TCodecBase> PCodecBase;
185  typedef TVec<PCodecBase> TCodecBaseV;
186  class TCodecBase
187  {
188  protected:
189  	TCRef CRef;
190  	friend class TPt<TCodecBase>;
191  public:
192  	virtual ~TCodecBase() { }
193  	template<class TCodecImpl>
194  	static PCodecBase New(); &bsol;* {
195  		return new TCodecWrapper<TCodecImpl>(); } */
196  	virtual TStr GetName() const = 0;
197  	virtual void Test() const { }
198  	virtual size_t ToUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const = 0;
199  	virtual size_t ToUnicode(const TStr& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const = 0;
200  	size_t ToUnicode(const TIntV& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
201  	size_t ToUnicode(const TStr& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
202  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const = 0;
203  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TChA& dest, const bool clrDest = true) const = 0;
204  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TStr& dest, const bool clrDest = true) const = 0;
205  	size_t FromUnicode(const TIntV& src, TIntV& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
206  	size_t FromUnicode(const TIntV& src, TChA& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
207  	size_t FromUnicode(const TIntV& src, TStr& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
208  };
209  template<class TCodecImpl_>
210  class TCodecWrapper : public TCodecBase
211  {
212  public:
213  	typedef TCodecImpl_ TCodecImpl;
214  	TCodecImpl impl;
215  public:
216  	virtual TStr GetName() const { return impl.GetName(); }
217  	virtual void Test() const { impl.Test(); }
218  	virtual size_t ToUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const {
219  		return impl.ToUnicode(src, srcIdx, srcCount, dest, clrDest); }
220  	virtual size_t ToUnicode(const TStr& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const {
221  		return impl.ToUnicode(src, srcIdx, srcCount, dest, clrDest); }
222  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const {
223  		return impl.FromUnicode(src, srcIdx, srcCount, dest, clrDest); }
224  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TChA& dest, const bool clrDest = true) const {
225  		return impl.FromUnicode(src, srcIdx, srcCount, dest, clrDest); }
226  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TStr& dest, const bool clrDest = true) const {
227  		TChA buf; size_t retVal = impl.FromUnicode(src, srcIdx, srcCount, buf, false);
228  		if (clrDest) dest += buf.CStr(); else dest = buf.CStr();
229  		return retVal; }
230  };
231  template<class TCodecImpl>
232  PCodecBase TCodecBase::New() {
233    return new TCodecWrapper<TCodecImpl>();
234  }
235  template<class TVector_>
236  class TVecElt
237  {
238  };
239  template<class TDat>
240  class TVecElt<TVec<TDat> >
241  {
242  public:
243  	typedef TVec<TDat> TVector;
244  	typedef TDat TElement;
245  	static inline void Add(TVector& vector, const TElement& element) { vector.Add(element); }
246  };
247  template<>
248  class TVecElt<TChA>
249  {
250  public:
251  	typedef TChA TVector;
252  	typedef char TElement;
253  	static inline void Add(TVector& vector, const TElement& element) { vector += element; }
254  };
255  class TEncoding_ISO8859_1
256  {
257  public:
258  	static inline TStr GetName() { return "ISO-8859-1"; }
259  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255); return c; }
260  	static int FromUnicode(int c) { if (0 <= c && c <= 255) return c; else return -1; }
261  };
262  class TEncoding_ISO8859_2 
263  {
264  public:
265  	static inline TStr GetName() { return "ISO-8859-2"; }
266  	static const int toUnicodeTable[6 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16];
267  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
268  		if (c < 0xa0) return c; else return toUnicodeTable[c - 0xa0]; }
269  	static int FromUnicode(int c) {
270  		if (0 <= c && c < 0xa0) return c;
271  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
272  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
273  		else return -1; }
274  };
275  class TEncoding_ISO8859_3
276  {
277  public:
278  	static inline TStr GetName() { return "ISO-8859-3"; }
279  	static const int toUnicodeTable[6 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2];
280  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
281  		if (c < 0xa0) return c; else return toUnicodeTable[c - 0xa0]; }
282  	static int FromUnicode(int c) {
283  		if (0 <= c && c < 0xa0) return c;
284  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
285  		else if (0x2d8 <= c && c < 0x2da) return fromUnicodeTable2[c - 0x2d8];
286  		else return -1; }
287  };
288  class TEncoding_ISO8859_4
289  {
290  public:
291  	static inline TStr GetName() { return "ISO-8859-4"; }
292  	static const int toUnicodeTable[6 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16];
293  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
294  		if (c < 0xa0) return c; else return toUnicodeTable[c - 0xa0]; }
295  	static int FromUnicode(int c) {
296  		if (0 <= c && c < 0xa0) return c;
297  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
298  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
299  		else return -1; }
300  };
301  class TEncoding_YuAscii
302  {
303  public:
304  	static const int uniChars[10], yuAsciiChars[10];
305  	static inline TStr GetName() { return "YU-ASCII"; }
306  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
307  		for (int i = 0; i < int(sizeof(yuAsciiChars) / sizeof(yuAsciiChars[0])); i++)
308  			if (c == yuAsciiChars[i]) return uniChars[i];
309  		return c; }
310  	static int FromUnicode(int c) {
311  		for (int i = 0; i < int(sizeof(uniChars) / sizeof(uniChars[0])); i++)
312  			if (c == uniChars[i]) return yuAsciiChars[i];
313  			else if(c == yuAsciiChars[i]) return -1;
314  		if (0 <= c && c <= 255) return c; else return -1; }
315  };
316  class TEncoding_CP437 
317  {
318  public:
319  	static inline TStr GetName() { return "CP437"; }
320  	static const int toUnicodeTable[8 * 16], fromUnicodeTable1[6 * 16], fromUnicodeTable2[4 * 16], fromUnicodeTable3[6 * 16], fromUnicodeTable4[11 * 16];
321  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
322  		if (c < 0x80) return c; else return toUnicodeTable[c - 0x80]; }
323  	static int FromUnicode(int c) {
324  		if (0 <= c && c < 0x80) return c;
325  		else if (0xa0 <= c && c < 0x100) return fromUnicodeTable1[c - 0xa0];
326  		else if (0x390 <= c && c < 0x3d0) return fromUnicodeTable2[c - 0x390];
327  		else if (0x2210 <= c && c < 0x2270) return fromUnicodeTable3[c - 0x2210];
328  		else if (0x2500 <= c && c < 0x25b0) return fromUnicodeTable4[c - 0x2500];
329  		else if (c == 0x192) return 0x9f;
330  		else if (c == 0x207f) return 0xfc;
331  		else if (c == 0x20a7) return 0x9e;
332  		else if (c == 0x2310) return 0xa9;
333  		else if (c == 0x2320) return 0xf4;
334  		else if (c == 0x2321) return 0xf5;
335  		else return -1; }
336  };
337  class TEncoding_CP852 
338  {
339  public:
340  	static inline TStr GetName() { return "CP852"; }
341  	static const int toUnicodeTable[8 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16], fromUnicodeTable3[11 * 16];
342  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
343  		if (c < 0x80) return c; else return toUnicodeTable[c - 0x80]; }
344  	static int FromUnicode(int c) {
345  		if (0 <= c && c < 0x80) return c;
346  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
347  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
348  		else if (0x2500 <= c && c < 0x25b0) return fromUnicodeTable3[c - 0x2500];
349  		else return -1; }
350  };
351  class TEncoding_CP1250 
352  {
353  public:
354  	static inline TStr GetName() { return "CP1250"; }
355  	static const int toUnicodeTable[8 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16], fromUnicodeTable3[3 * 16];
356  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
357  		if (c < 0x80) return c; else return toUnicodeTable[c - 0x80]; }
358  	static int FromUnicode(int c) {
359  		if (0 <= c && c < 0x80) return c;
360  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
361  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
362  		else if (0x2010 <= c && c < 0x2040) return fromUnicodeTable3[c - 0x2010];
363  		else if (c == 0x20ac) return 0x80;
364  		else if (c == 0x2122) return 0x99;
365  		else return -1; }
366  };
367  template<class TEncoding_>
368  class T8BitCodec
369  {
370  protected:
371  	typedef TUniVecIdx TVecIdx;
372  public:
373  	typedef TEncoding_ TEncoding;
374  	TUnicodeErrorHandling errorHandling;
375  	int replacementChar;
376  	T8BitCodec() : errorHandling(uehIgnore), replacementChar(TUniCodec::DefaultReplacementChar) { }
377  	T8BitCodec(TUnicodeErrorHandling errorHandling_, int replacementChar_ = TUniCodec::DefaultReplacementChar) :
378  		errorHandling(errorHandling_), replacementChar(replacementChar_) { }
379  	static TStr GetName() { return TEncoding::GetName(); }
380  	void Test() const
381  	{
<span onclick='openModal()' class='match'>382  		int nDecoded = 0;
383  		for (int c = 0; c <= 255; c++) {
384  			int cu = TEncoding::ToUnicode(c); if (cu == -1) continue;
</span>385  			nDecoded++;
386  			IAssert(0 <= cu && cu < 0x110000);
387  			int c2 = TEncoding::FromUnicode(cu);
388  			IAssert(c2 == c); }
389  		int nEncoded = 0;
390  		for (int cu = 0; cu < 0x110000; cu++) {
391  			int c = TEncoding::FromUnicode(cu); if (c == -1) continue;
392  			nEncoded++;
393  			IAssert(0 <= c && c <= 255);
394  			int cu2 = TEncoding::ToUnicode(c);
395  			IAssert(cu2 == cu); }
396  		IAssert(nDecoded == nEncoded);
397  	}
398  	template<typename TSrcVec, typename TDestCh>
399  	size_t ToUnicode(
400  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
401  		TVec<TDestCh>& dest, const bool clrDest = true) const
402  	{
403  		if (clrDest) dest.Clr();
404  		size_t toDo = srcCount;
405  		while (toDo-- > 0) {
406  			int chSrc = ((int) src[TVecIdx(srcIdx)]) & 0xff; srcIdx++;
407  			int chDest = TEncoding::ToUnicode(chSrc);
408  			dest.Add(chDest); }
409  		return srcCount;
410  	}
411  	template<typename TSrcVec, typename TDestCh>
412  	size_t ToUnicode(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
413  	size_t ToUnicode(const TIntV& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
414  	size_t ToUnicode(const TStr& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
415  	template<typename TSrcVec, typename TDestVec>
416  	size_t FromUnicode(
417  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
418  		TDestVec& dest, const bool clrDest = true) const
419  	{
420  		typedef typename TVecElt<TDestVec>::TElement TDestCh;
421  		if (clrDest) dest.Clr();
422  		size_t toDo = srcCount, nEncoded = 0;
423  		while (toDo-- > 0) {
424  			int chSrc = (int) src[TVecIdx(srcIdx)]; srcIdx++;
425  			int chDest = TEncoding::FromUnicode(chSrc);
426  			if (chDest < 0) {
427  				switch (errorHandling) {
428  				case uehThrow: throw TUnicodeException(srcIdx - 1, chSrc, "Invalid character for encoding into " + GetName() + ".");
429  				case uehAbort: return nEncoded;
430  				case uehReplace: TVecElt<TDestVec>::Add(dest, TDestCh(replacementChar)); continue;
431  				case uehIgnore: continue;
432  				default: Fail; } }
433  			TVecElt<TDestVec>::Add(dest, TDestCh(chDest)); nEncoded++; }
434  		return nEncoded;
435  	}
436  	template<typename TSrcVec, typename TDestVec>
437  	size_t FromUnicode(const TSrcVec& src, TDestVec& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
438  	size_t UniToStr(const TIntV& src, size_t srcIdx, const size_t srcCount, TStr& dest, const bool clrDest = true) const {
439  		TChA buf; size_t retVal = FromUnicode(src, srcIdx, srcCount, buf, false);
440  		if (clrDest) dest += buf.CStr(); else dest = buf.CStr();
441  		return retVal; }
442  	size_t UniToStr(const TIntV& src, TStr& dest, const bool clrDest = true) const { return UniToStr(src, 0, src.Len(), dest, clrDest); }
443  };
444  typedef T8BitCodec<TEncoding_ISO8859_1> TCodec_ISO8859_1;
445  typedef T8BitCodec<TEncoding_ISO8859_2> TCodec_ISO8859_2;
446  typedef T8BitCodec<TEncoding_ISO8859_3> TCodec_ISO8859_3;
447  typedef T8BitCodec<TEncoding_ISO8859_4> TCodec_ISO8859_4;
448  typedef T8BitCodec<TEncoding_CP852> TCodec_CP852;
449  typedef T8BitCodec<TEncoding_CP437> TCodec_CP437;
450  typedef T8BitCodec<TEncoding_CP1250> TCodec_CP1250;
451  typedef T8BitCodec<TEncoding_YuAscii> TCodec_YuAscii;
452  typedef enum TUniChCategory_
453  {
454  #define DefineUniCat(cat, c) uc ## cat = (int(uchar(c)) & 0xff)
455  	DefineUniCat(Letter, 'L'),             
456  	DefineUniCat(Mark, 'M'),
457  	DefineUniCat(Number, 'N'),
458  	DefineUniCat(Punctuation, 'P'),
459  	DefineUniCat(Symbol, 'S'),
460  	DefineUniCat(Separator, 'Z'),
461  	DefineUniCat(Other, 'C')
462  #undef DefineUniCat
463  }
464  TUniChCategory;
465  typedef enum TUniChSubCategory_
466  {
467  #define DefineUniSubCat(cat, subCat, c) uc ## cat ## subCat = ((uc ## cat) << 8) | (int(uchar(c)) & 0xff)
468  	DefineUniSubCat(Letter, Uppercase, 'u'),            
469  	DefineUniSubCat(Letter, Lowercase, 'l'),
470  	DefineUniSubCat(Letter, Titlecase, 't'),
471  	DefineUniSubCat(Letter, Modifier, 'm'),
472  	DefineUniSubCat(Letter, Other, 'o'),
473  	DefineUniSubCat(Mark, Nonspacing, 'n'),
474  	DefineUniSubCat(Mark, SpacingCombining, 'c'),
475  	DefineUniSubCat(Mark, Enclosing, 'e'),
476  	DefineUniSubCat(Number, DecimalDigit, 'd'),
477  	DefineUniSubCat(Number, Letter, 'l'),
478  	DefineUniSubCat(Number, Other, 'o'),
479  	DefineUniSubCat(Punctuation, Connector, 'c'),
480  	DefineUniSubCat(Punctuation, Dash, 'd'),
481  	DefineUniSubCat(Punctuation, Open, 's'),
482  	DefineUniSubCat(Punctuation, Close, 'e'),
483  	DefineUniSubCat(Punctuation, InitialQuote, 'i'),
484  	DefineUniSubCat(Punctuation, FinalQuote, 'f'),
485  	DefineUniSubCat(Punctuation, Other, 'o'),
486  	DefineUniSubCat(Symbol, Math, 'm'),
487  	DefineUniSubCat(Symbol, Currency, 'c'),
488  	DefineUniSubCat(Symbol, Modifier, 'k'),
489  	DefineUniSubCat(Symbol, Other, 'o'),
490  	DefineUniSubCat(Separator, Space, 's'),
491  	DefineUniSubCat(Separator, Line, 'l'),
492  	DefineUniSubCat(Separator, Paragraph, 'p'),
493  	DefineUniSubCat(Other, Control, 'c'),
494  	DefineUniSubCat(Other, Format, 'f'),
495  	DefineUniSubCat(Other, Surrogate, 's'),
496  	DefineUniSubCat(Other, PrivateUse, 'o'),
497  	DefineUniSubCat(Other, NotAssigned, 'n')
498  }
499  TUniChSubCategory;
500  typedef enum TUniChFlags_
501  {
502  	ucfCompatibilityDecomposition = 1, 
503  	ucfCompositionExclusion = 1 << 1,       
504  	ucfWbFormat = 1 << 2,
505  	ucfWbKatakana = 1 << 3,
506  	ucfWbALetter = 1 << 4,
507  	ucfWbMidLetter = 1 << 5,
508  	ucfWbMidNum = 1 << 6,
509  	ucfWbNumeric = 1 << 7,
510  	ucfWbExtendNumLet = 1 << 8,
511  	ucfSbSep = 1 << 9,
512  	ucfSbFormat = 1 << 10,
513  	ucfSbSp = 1 << 11,
514  	ucfSbLower = 1 << 12,
515  	ucfSbUpper = 1 << 13,
516  	ucfSbOLetter = 1 << 14,
517  	ucfSbNumeric = 1 << 15,
518  	ucfSbATerm = 1 << 16,
519  	ucfSbSTerm = 1 << 17,
520  	ucfSbClose = 1 << 18,
521  	ucfSbMask = ucfSbSep | ucfSbFormat | ucfSbSp | ucfSbLower | ucfSbUpper | ucfSbOLetter | ucfSbNumeric | ucfSbATerm | ucfSbSTerm | ucfSbClose,
522  	ucfWbMask = ucfWbFormat | ucfWbKatakana | ucfWbALetter | ucfWbMidLetter | ucfWbMidNum | ucfWbNumeric | ucfWbExtendNumLet | ucfSbSep,
523  	ucfDcpAlphabetic = 1 << 19,
524  	ucfDcpDefaultIgnorableCodePoint = 1 << 20,
525  	ucfDcpLowercase = 1 << 21,
526  	ucfDcpGraphemeBase = 1 << 22,
527  	ucfDcpGraphemeExtend = 1 << 23,
528  	ucfDcpIdStart = 1 << 24,
529  	ucfDcpIdContinue = 1 << 25,
530  	ucfDcpMath = 1 << 26,
531  	ucfDcpUppercase = 1 << 27,
532  	ucfDcpXidStart = 1 << 28,
533  	ucfDcpXidContinue = 1 << 29,
534  	ucfDcpMask = ucfDcpAlphabetic | ucfDcpDefaultIgnorableCodePoint | ucfDcpLowercase | ucfDcpGraphemeBase | ucfDcpGraphemeExtend |
535  		ucfDcpIdStart | ucfDcpIdContinue | ucfDcpMath | ucfDcpUppercase | ucfDcpXidStart | ucfDcpXidContinue,
536  }
537  TUniChFlags;
538  typedef enum TUniChProperties_
539  {
540  	ucfPrAsciiHexDigit = 1,
541  	ucfPrBidiControl = 2,
542  	ucfPrDash = 4,
543  	ucfPrDeprecated = 8,
544  	ucfPrDiacritic = 0x10,
545  	ucfPrExtender = 0x20,
546  	ucfPrGraphemeLink = 0x40,
547  	ucfPrHexDigit = 0x80,
548  	ucfPrHyphen = 0x100,
549  	ucfPrIdeographic = 0x200,
550  	ucfPrJoinControl = 0x400,
551  	ucfPrLogicalOrderException = 0x800,
552  	ucfPrNoncharacterCodePoint = 0x1000,
553  	ucfPrPatternSyntax = 0x2000,
554  	ucfPrPatternWhiteSpace = 0x4000,
555  	ucfPrQuotationMark = 0x8000,
556  	ucfPrSoftDotted = 0x10000,
557  	ucfPrSTerm = 0x20000,
558  	ucfPrTerminalPunctuation = 0x40000,
559  	ucfPrVariationSelector = 0x80000,
560  	ucfPrWhiteSpace = 0x100000
561  }
562  TUniChProperties;
563  typedef enum TUniChPropertiesX_
564  {
565  	ucfPxOtherAlphabetic = 1,
566  	ucfPxOtherDefaultIgnorableCodePoint = 2,
567  	ucfPxOtherGraphemeExtend = 4,
568  	ucfPxOtherIdContinue = 8,
569  	ucfPxOtherIdStart = 0x10,
570  	ucfPxOtherLowercase = 0x20,
571  	ucfPxOtherMath = 0x40,
572  	ucfPxOtherUppercase = 0x80,
573  	ucfPxIdsBinaryOperator = 0x100,
574  	ucfPxIdsTrinaryOperator = 0x200,
575  	ucfPxRadical = 0x400,
576  	ucfPxUnifiedIdeograph = 0x800
577  }
578  TUniChPropertiesX;
579  class TUniChInfo
580  {
581  public:
582  	enum { 
583  		ccStarter = 0, 
584  		ccOverlaysAndInterior = 1,
585  		ccNuktas = 7,
586  		ccHiraganaKatakanaVoicingMarks = 8,
587  		ccViramas = 9,
588  		ccFixedPositionStart = 10, 
589  		ccFixedPositionEnd = 199, 
590  		ccBelowLeftAttached = 200,
591  		ccBelowAttached = 202,
592  		ccBelowRightAttached = 204,
593  		ccLeftAttached = 208, 
594  		ccRightAttached = 210,
595  		ccAboveLeftAttached = 212,
596  		ccAboveAttached = 214,
597  		ccAboveRightAttached = 216,
598  		ccBelowLeft = 218,
599  		ccBelow = 220,
600  		ccBelowRight = 222,
601  		ccLeft = 224, 
602  		ccRight = 226,
603  		ccAboveLeft = 228,
604  		ccAbove = 230,
605  		ccAboveRight = 232,
606  		ccDoubleBelow = 233,
607  		ccDoubleAbove = 234,
608  		ccBelowIotaSubscript = 240, 
609  		ccInvalid = 255 
610  	};
611  	char chCat, chSubCat; 
612  	uchar combClass; 
613  	TUniChCategory cat; 
614  	TUniChSubCategory subCat; 
615  	signed char script; 
616  	int simpleUpperCaseMapping, simpleLowerCaseMapping, simpleTitleCaseMapping; 
617  	int decompOffset; 
618  	int nameOffset; 
619  	int flags; 
620  	int properties; 
621  	int propertiesX; 
622  	ushort lineBreak; 
623  	static inline ushort GetLineBreakCode(char c1, char c2) { return ((static_cast<ushort>(static_cast<uchar>(c1)) & 0xff) << 8) | ((static_cast<ushort>(static_cast<uchar>(c2)) & 0xff)); }
624  	static const ushort LineBreak_Unknown, LineBreak_ComplexContext, LineBreak_Numeric, LineBreak_InfixNumeric, LineBreak_Quotation;
625  public:
626  	void InitAfterLoad() {
627  		cat = (TUniChCategory) chCat;
628  		subCat = (TUniChSubCategory) (((static_cast<int>(static_cast<uchar>(chCat)) & 0xff) << 8) | (static_cast<int>(static_cast<uchar>(chSubCat)) & 0xff)); }
629  	void SetCatAndSubCat(const TUniChSubCategory catAndSubCat) {
630  		cat = (TUniChCategory) ((int(catAndSubCat) >> 8) & 0xff);
631  		subCat = catAndSubCat;
632  		chCat = (char) cat; chSubCat = (char) (int(subCat) & 0xff); }
633  	friend class TUniChDb;
634  	static inline void LoadUShort(TSIn& SIn, ushort& u) { SIn.LoadBf(&u, sizeof(u)); }
635  	static inline void LoadSChar(TSIn& SIn, signed char& u) { SIn.LoadBf(&u, sizeof(u)); }
636  	static inline void SaveUShort(TSOut& SOut, ushort u) { SOut.SaveBf(&u, sizeof(u)); }
637  	static inline void SaveSChar(TSOut& SOut, signed char u) { SOut.SaveBf(&u, sizeof(u)); }
638  public:
639  	void Save(TSOut& SOut) const {
640  		SOut.Save(chCat); SOut.Save(chSubCat); SOut.Save(combClass); SaveSChar(SOut, script);
641  		SOut.Save(simpleUpperCaseMapping); SOut.Save(simpleLowerCaseMapping); SOut.Save(simpleTitleCaseMapping);
642  		SOut.Save(decompOffset); SOut.Save(nameOffset);
643  		SOut.Save(flags); SOut.Save(properties); SOut.Save(propertiesX); SaveUShort(SOut, lineBreak); }
644  	void Load(TSIn& SIn) {
645  		SIn.Load(chCat); SIn.Load(chSubCat); SIn.Load(combClass); LoadSChar(SIn, script);
646  		SIn.Load(simpleUpperCaseMapping); SIn.Load(simpleLowerCaseMapping); SIn.Load(simpleTitleCaseMapping);
647  		SIn.Load(decompOffset); SIn.Load(nameOffset);
648  		SIn.Load(flags); SIn.Load(properties); SIn.Load(propertiesX); LoadUShort(SIn, lineBreak); InitAfterLoad(); }
649  	explicit TUniChInfo(TSIn& SIn) { Load(SIn); }
650  	TUniChInfo() : chCat(char(ucOther)), chSubCat(char(ucOtherNotAssigned & 0xff)), combClass(ccInvalid),
651  		script(-1),simpleUpperCaseMapping(-1), simpleLowerCaseMapping(-1), simpleTitleCaseMapping(-1),
652  		decompOffset(-1), nameOffset(-1), flags(0), properties(0), propertiesX(0), lineBreak(LineBreak_Unknown) {
653  		InitAfterLoad(); }
654  	bool IsDcpFlag(const TUniChFlags flag) const { Assert((flag & ucfDcpMask) == flag); return (flags & flag) == flag; }
655  	void ClrDcpFlags() { flags = flags & ~ucfDcpMask; }
656  	void SetDcpFlag(const TUniChFlags flag) { Assert((flag & ucfDcpMask) == flag); flags |= flag; }
657  	bool IsAlphabetic() const { return IsDcpFlag(ucfDcpAlphabetic); }
658  	bool IsUppercase() const { return IsDcpFlag(ucfDcpUppercase); }
659  	bool IsLowercase() const { return IsDcpFlag(ucfDcpLowercase); }
660  	bool IsMath() const { return IsDcpFlag(ucfDcpMath); }
661  	bool IsDefaultIgnorable() const { return IsDcpFlag(ucfDcpDefaultIgnorableCodePoint); }
662  	bool IsGraphemeBase() const { return IsDcpFlag(ucfDcpGraphemeBase); }
663  	bool IsGraphemeExtend() const { return IsDcpFlag(ucfDcpGraphemeExtend); }
664  	bool IsIdStart() const { return IsDcpFlag(ucfDcpIdStart); }
665  	bool IsIdContinue() const { return IsDcpFlag(ucfDcpIdContinue); }
666  	bool IsXidStart() const { return IsDcpFlag(ucfDcpXidStart); }
667  	bool IsXidContinue() const { return IsDcpFlag(ucfDcpXidContinue); }
668  	bool IsProperty(const TUniChProperties flag) const { return (properties & flag) == flag; }
669  	void SetProperty(const TUniChProperties flag) { properties |= flag; }
670  	bool IsAsciiHexDigit() const { return IsProperty(ucfPrAsciiHexDigit); }
671  	bool IsBidiControl() const { return IsProperty(ucfPrBidiControl); }
672  	bool IsDash() const { return IsProperty(ucfPrDash); }
673  	bool IsDeprecated() const { return IsProperty(ucfPrDeprecated); }
674  	bool IsDiacritic() const { return IsProperty(ucfPrDiacritic); }
675  	bool IsExtender() const { return IsProperty(ucfPrExtender); }
676  	bool IsGraphemeLink() const { return IsProperty(ucfPrGraphemeLink); }
677  	bool IsHexDigit() const { return IsProperty(ucfPrHexDigit); }
678  	bool IsHyphen() const { return IsProperty(ucfPrHyphen); }
679  	bool IsIdeographic() const { return IsProperty(ucfPrIdeographic); }
680  	bool IsJoinControl() const { return IsProperty(ucfPrJoinControl); }
681  	bool IsLogicalOrderException() const { return IsProperty(ucfPrLogicalOrderException); }
682  	bool IsNoncharacter() const { return IsProperty(ucfPrNoncharacterCodePoint); }
683  	bool IsQuotationMark() const { return IsProperty(ucfPrQuotationMark); }
684  	bool IsSoftDotted() const { return IsProperty(ucfPrSoftDotted); }
685  	bool IsSTerminal() const { return IsProperty(ucfPrSTerm); }
686  	bool IsTerminalPunctuation() const { return IsProperty(ucfPrTerminalPunctuation); }
687  	bool IsVariationSelector() const { return IsProperty(ucfPrVariationSelector); }
688  	bool IsWhiteSpace() const { return IsProperty(ucfPrWhiteSpace); }
689  	bool IsPropertyX(const TUniChPropertiesX flag) const { return (propertiesX & flag) == flag; }
690  	void SetPropertyX(const TUniChPropertiesX flag) { propertiesX |= flag; }
691  	bool IsCompositionExclusion() const { return (flags & ucfCompositionExclusion) == ucfCompositionExclusion; }
692  	bool IsCompatibilityDecomposition() const { return (flags & ucfCompatibilityDecomposition) == ucfCompatibilityDecomposition; }
693  	bool IsWbFlag(const TUniChFlags flag) const { Assert((flag & ucfWbMask) == flag); return (flags & flag) == flag; }
694  	void ClrWbAndSbFlags() { flags = flags & ~(ucfWbMask | ucfSbMask); }
695  	void SetWbFlag(const TUniChFlags flag) { Assert((flag & ucfWbMask) == flag); flags |= flag; }
696  	int GetWbFlags() const { return flags & ucfWbMask; }
697  	bool IsWbFormat() const { return IsWbFlag(ucfWbFormat); }
698  	TStr GetWbFlagsStr() const { return GetWbFlagsStr(GetWbFlags()); }
699  	static TStr GetWbFlagsStr(const int flags) { return TStr("") + (flags & ucfWbALetter ? "A" : "") +
700  		(flags & ucfWbFormat ? "F" : "") + (flags & ucfWbKatakana ? "K" : "") + (flags & ucfWbMidLetter ? "M" : "") +
701  		(flags & ucfWbMidNum ? "m" : "") + (flags & ucfWbNumeric ? "N" : "") + (flags & ucfWbExtendNumLet ? "E" : ""); }
702  	bool IsSbFlag(const TUniChFlags flag) const { Assert((flag & ucfSbMask) == flag); return (flags & flag) == flag; }
703  	void SetSbFlag(const TUniChFlags flag) { Assert((flag & ucfSbMask) == flag); flags |= flag; }
704  	int GetSbFlags() const { return flags & ucfSbMask; }
705  	bool IsSbFormat() const { return IsSbFlag(ucfSbFormat); }
706  	TStr GetSbFlagsStr() const { return GetSbFlagsStr(GetSbFlags()); }
707  	static TStr GetSbFlagsStr(const int flags) { return TStr("") + (flags & ucfSbSep ? "S" : "") +
708  		(flags & ucfSbFormat ? "F" : "") + (flags & ucfSbSp ? "_" : "") + (flags & ucfSbLower ? "L" : "") +
709  		(flags & ucfSbUpper ? "U" : "") + (flags & ucfSbOLetter ? "O" : "") + (flags & ucfSbNumeric ? "N" : "") +
710  		(flags & ucfSbATerm ? "A" : "") + (flags & ucfSbSTerm ? "T" : "") + (flags & ucfSbClose ? "C" : ""); }
711  	bool IsSbSep() const { return (flags & ucfSbSep) == ucfSbSep; }
712  	bool IsGbExtend() const { return IsGraphemeExtend(); }
713  	bool IsCased() const { return IsUppercase() || IsLowercase() || (subCat == ucLetterTitlecase); }
714  	TUniChCategory GetCat() const { return (TUniChCategory) cat; }
715  	TUniChSubCategory GetSubCat() const { return (TUniChSubCategory) subCat; }
716  	bool IsCurrency() const { return subCat == ucSymbolCurrency; }
717  	bool IsPrivateUse() const { return subCat == ucOtherPrivateUse; }
718  	bool IsSurrogate() const { return subCat == ucOtherSurrogate; }
719  	inline static bool IsValidSubCat(const char chCat, const char chSubCat) {
720  		static const char s[] = "LuLlLtLmLoMnMcMeNdNlNoPcPdPsPePiPfPoSmScSkSoZsZlZpCcCfCsCoCn";
721  		for (const char *p = s; *p; p += 2)
722  			if (chCat == p[0] && chSubCat == p[1]) return true;
723  		return false; }
724  };
725  template<typename TItem_>
726  class TUniTrie
727  {
728  public:
729  	typedef TItem_ TItem;
730  protected:
731  	class TNode {
732  	public:
733  		TItem item;
734  		int child, sib;
735  		bool terminal;
736  		TNode() : child(-1), sib(-1), terminal(false) { }
737  		TNode(const TItem& item_, const int child_, const int sib_, const bool terminal_) : item(item_), child(child_), sib(sib_), terminal(terminal_) { }
738  	};
739  	typedef TVec<TNode> TNodeV;
740  	typedef TPair<TItem, TItem> TItemPr;
741  	typedef TTriple<TItem, TItem, TItem> TItemTr;
742  	typedef TUniVecIdx TVecIdx;
743  	THash<TItem, TVoid> singles; 
744  	THash<TItemPr, TVoid> pairs;
745  	THash<TItemTr, TInt> roots;
746  	TNodeV nodes;
747  public:
748  	TUniTrie() { }
749  	void Clr() { singles.Clr(); pairs.Clr(); roots.Clr(); nodes.Clr(); }
750  	bool Empty() const { return singles.Empty() && pairs.Empty() && roots.Empty(); }
751  	bool Has1Gram(const TItem& item) const { return singles.IsKey(item); }
752  	bool Has2Gram(const TItem& last, const TItem& butLast) const { return pairs.IsKey(TItemPr(last, butLast)); }
753  	int Get3GramRoot(const TItem& last, const TItem& butLast, const TItem& butButLast) const {
754  		int keyId = roots.GetKeyId(TItemTr(last, butLast, butButLast));
755  		if (keyId < 0) return 0; else return roots[keyId]; }
756  	int GetChild(const int parentIdx, const TItem& item) const {
757  		for (int childIdx = nodes[parentIdx].child; childIdx >= 0; ) {
758  			const TNode &node = nodes[childIdx];
759  			if (node.item == item) return childIdx;
760  			childIdx = node.sib; }
761  		return -1; }
762  	bool IsNodeTerminal(const int nodeIdx) const { return nodes[nodeIdx].terminal; }
763  	template<typename TSrcVec>
764  	void Add(const TSrcVec& src, const size_t srcIdx, const size_t srcCount)
765  	{
766  		IAssert(srcCount > 0);
767  		if (srcCount == 1) { singles.AddKey(TItem(src[TVecIdx(srcIdx)])); return; }
768  		if (srcCount == 2) { pairs.AddKey(TItemPr(TItem(src[TVecIdx(srcIdx + 1)]), TItem(src[TVecIdx(srcIdx)]))); return; }
769  		size_t srcLast = srcIdx + (srcCount - 1);
770  		TItemTr tr = TItemTr(TItem(src[TVecIdx(srcLast)]), TItem(src[TVecIdx(srcLast - 1)]), TItem(src[TVecIdx(srcLast - 2)]));
771  		int keyId = roots.GetKeyId(tr), curNodeIdx = -1;
772  		if (keyId >= 0) curNodeIdx = roots[keyId];
773  		else { curNodeIdx = nodes.Add(TNode(TItem(0), -1, -1, false)); roots.AddDat(tr, curNodeIdx); }
774  		if (srcCount > 3) for (size_t srcPos = srcLast - 3; ; )
775  		{
776  			const TItem curItem = src[TVecIdx(srcPos)];
777  			int childNodeIdx = nodes[curNodeIdx].child;
778  			while (childNodeIdx >= 0) {
779  				TNode &childNode = nodes[childNodeIdx];
780  				if (childNode.item == curItem) break;
781  				childNodeIdx = childNode.sib; }
782  			if (childNodeIdx < 0) {
783  				childNodeIdx = nodes.Add(TNode(curItem, -1, nodes[curNodeIdx].child, false));
784  				nodes[curNodeIdx].child = childNodeIdx; }
785  			curNodeIdx = childNodeIdx;
786  			if (srcPos == srcIdx) break; else srcPos--;
787  		}
788  		nodes[curNodeIdx].terminal = true;
789  	}
790  	template<typename TSrcVec>
791  	void Add(const TSrcVec& src) { Add(src, 0, (size_t) src.Len()); }
792  };
793  class TUniChDb
794  {
795  protected:
796  	void InitAfterLoad();
797  	typedef TUniVecIdx TVecIdx;
798  public:
799  	THash<TInt, TUniChInfo> h; 
800  	TStrPool charNames;
801  	TStrIntH scripts; 
802  	TIntV decompositions;
803  	THash<TIntPr, TInt> inverseDec;
804  	TUniCaseFolding caseFolding;
805  	TIntIntVH specialCasingLower, specialCasingUpper, specialCasingTitle;
806  	int scriptUnknown; 
807  	TUniChDb() : scriptUnknown(-1) { }
808  	explicit TUniChDb(TSIn& SIn) { Load(SIn); }
809  	void Clr() {
810  		h.Clr(); charNames.Clr(); decompositions.Clr(); inverseDec.Clr(); caseFolding.Clr();
811  		specialCasingLower.Clr(); specialCasingUpper.Clr(); specialCasingTitle.Clr();
812  		scripts.Clr(); }
813  	void Save(TSOut& SOut) const {
814  		h.Save(SOut); charNames.Save(SOut); decompositions.Save(SOut);
815  		inverseDec.Save(SOut); caseFolding.Save(SOut); scripts.Save(SOut);
816  		specialCasingLower.Save(SOut); specialCasingUpper.Save(SOut); specialCasingTitle.Save(SOut);
817  		SOut.SaveCs(); }
818  	void Load(TSIn& SIn) {
819  		h.Load(SIn); charNames.~TStrPool(); new (&charNames) TStrPool(SIn);
820  		decompositions.Load(SIn);
821  		inverseDec.Load(SIn); caseFolding.Load(SIn); scripts.Load(SIn);
822  		specialCasingLower.Load(SIn); specialCasingUpper.Load(SIn); specialCasingTitle.Load(SIn);
823  		SIn.LoadCs(); InitAfterLoad(); }
824  	void LoadBin(const TStr& fnBin) {
825  		PSIn SIn = TFIn::New(fnBin); Load(*SIn); }
826  	void Test(const TStr& basePath);
827  	static TStr GetCaseFoldingFn() { return "CaseFolding.txt"; }
828  	static TStr GetSpecialCasingFn() { return "SpecialCasing.txt"; }
829  	static TStr GetUnicodeDataFn() { return "UnicodeData.txt"; }
830  	static TStr GetCompositionExclusionsFn() { return "CompositionExclusions.txt"; }
831  	static TStr GetScriptsFn() { return "Scripts.txt"; }
832  	static TStr GetDerivedCorePropsFn() { return "DerivedCoreProperties.txt"; }
833  	static TStr GetLineBreakFn() { return "LineBreak.txt"; }
834  	static TStr GetPropListFn() { return "PropList.txt"; }
835  	static TStr GetAuxiliaryDir() { return "auxiliary"; }
836  	static TStr GetWordBreakTestFn() { return "WordBreakTest.txt"; }
837  	static TStr GetWordBreakPropertyFn() { return "WordBreakProperty.txt"; }
838  	static TStr GetSentenceBreakTestFn() { return "SentenceBreakTest.txt"; }
839  	static TStr GetSentenceBreakPropertyFn() { return "SentenceBreakProperty.txt"; }
840  	static TStr GetNormalizationTestFn() { return "NormalizationTest.txt"; }
841  	static TStr GetBinFn() { return "UniChDb.bin"; } 
842  	static TStr GetScriptNameUnknown() { return "Unknown"; }
843  	static TStr GetScriptNameKatakana() { return "Katakana"; }
844  	static TStr GetScriptNameHiragana() { return "Hiragana"; }
845  	const TStr& GetScriptName(const int scriptId) const { return scripts.GetKey(scriptId); }
846  	int GetScriptByName(const TStr& scriptName) const { return scripts.GetKeyId(scriptName); }
847  	int GetScript(const TUniChInfo& ci) const { int s = ci.script; if (s < 0) s = scriptUnknown; return s; }
848  	int GetScript(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return scriptUnknown; else return GetScript(h[i]); }
849  	const char *GetCharName(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return 0; int ofs = h[i].nameOffset; return ofs < 0 ? 0 : charNames.GetCStr(ofs); }
850  	TStr GetCharNameS(const int cp) const {
851  		const char *p = GetCharName(cp); if (p) return p;
852  		char buf[20]; sprintf(buf, "U+%04x", cp); return TStr(buf); }
853  	template<class TSrcVec> void PrintCharNames(FILE *f, const TSrcVec& src, size_t srcIdx, const size_t srcCount, const TStr& prefix) const {
854  		if (! f) f = stdout;
855  		for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++) {
856  			fprintf(f, "%s", prefix.CStr());
857  			int cp = src[TVecIdx(srcIdx)]; fprintf(f, (cp >= 0x10000 ? "U+%05x" : "U+%04x "), cp);
858  			fprintf(f, " %s\n", GetCharNameS(cp).CStr()); }}
859  	template<class TSrcVec> void PrintCharNames(FILE *f, const TSrcVec& src, const TStr& prefix) const { PrintCharNames(f, src, 0, src.Len(), prefix); }
860  	bool IsGetChInfo(const int cp, TUniChInfo& ChInfo) {
861  		int i = h.GetKeyId(cp);
862  		if (i < 0) return false; else { ChInfo=h[i]; return true; }}
863  	TUniChCategory GetCat(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return ucOther; else return h[i].cat; }
864  	TUniChSubCategory GetSubCat(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return ucOtherNotAssigned; else return h[i].subCat; }
865  	bool IsWbFlag(const int cp, const TUniChFlags flag) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return h[i].IsWbFlag(flag); }
866  	int GetWbFlags(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return 0; else return h[i].GetWbFlags(); }
867  	bool IsSbFlag(const int cp, const TUniChFlags flag) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return h[i].IsSbFlag(flag); }
868  	int GetSbFlags(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return 0; else return h[i].GetSbFlags(); }
869  #define ___UniFwd1(name) bool name(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return h[i].name(); }
870  #define ___UniFwd2(name1, name2) ___UniFwd1(name1) ___UniFwd1(name2)
871  #define ___UniFwd3(name1, name2, name3) ___UniFwd2(name1, name2) ___UniFwd1(name3)
872  #define ___UniFwd4(name1, name2, name3, name4) ___UniFwd3(name1, name2, name3) ___UniFwd1(name4)
873  #define ___UniFwd5(name1, name2, name3, name4, name5) ___UniFwd4(name1, name2, name3, name4) ___UniFwd1(name5)
874  #define DECLARE_FORWARDED_PROPERTY_METHODS \
875  	___UniFwd5(IsAsciiHexDigit, IsBidiControl, IsDash, IsDeprecated, IsDiacritic) \
876  	___UniFwd5(IsExtender, IsGraphemeLink, IsHexDigit, IsHyphen, IsIdeographic)  \
877  	___UniFwd5(IsJoinControl, IsLogicalOrderException, IsNoncharacter, IsQuotationMark, IsSoftDotted)  \
878  	___UniFwd4(IsSTerminal, IsTerminalPunctuation, IsVariationSelector, IsWhiteSpace)  \
879  	___UniFwd5(IsAlphabetic, IsUppercase, IsLowercase, IsMath, IsDefaultIgnorable)  \
880  	___UniFwd4(IsGraphemeBase, IsGraphemeExtend, IsIdStart, IsIdContinue)  \
881  	___UniFwd2(IsXidStart, IsXidContinue)  \
882  	___UniFwd3(IsCompositionExclusion, IsCompatibilityDecomposition, IsSbSep)  \
883  	___UniFwd1(IsGbExtend)  \
884  	___UniFwd2(IsCased, IsCurrency)
885  	DECLARE_FORWARDED_PROPERTY_METHODS
886  #undef ___UniFwd1
887  	bool IsPrivateUse(const int cp) const {
888  		int i = h.GetKeyId(cp); if (i >= 0) return h[i].IsPrivateUse();
889  		return (0xe000 <= cp && cp <= 0xf8ff) ||  
890  			(0xf0000 <= cp && cp <= 0xffffd) || (0x100000 <= cp && cp <= 0x10fffd); }
891  	bool IsSurrogate(const int cp) const {
892  		int i = h.GetKeyId(cp); if (i >= 0) return h[i].IsSurrogate();
893  		return 0xd800 <= cp && cp <= 0xdcff; }
894  	int GetCombiningClass(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return TUniChInfo::ccStarter; else return h[i].combClass; }
895  	enum {
896          HangulSBase = 0xAC00, HangulLBase = 0x1100, HangulVBase = 0x1161, HangulTBase = 0x11A7,
897          HangulLCount = 19, HangulVCount = 21, HangulTCount = 28,
898          HangulNCount = HangulVCount * HangulTCount,   
899          HangulSCount = HangulLCount * HangulNCount   
900  	};
901  protected:
902  	static bool IsWbIgnored(const TUniChInfo& ci) { return ci.IsGbExtend() || ci.IsWbFormat(); }
903  	bool IsWbIgnored(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return IsWbIgnored(h[i]); }
904  	template<typename TSrcVec> void WbFindCurOrNextNonIgnored(const TSrcVec& src, size_t& position, const size_t srcEnd) const {
905  		while (position < srcEnd && IsWbIgnored(src[TVecIdx(position)])) position++; }
906  	template<typename TSrcVec> void WbFindNextNonIgnored(const TSrcVec& src, size_t& position, const size_t srcEnd) const {
907  		if (position >= srcEnd) return;
908  		position++; while (position < srcEnd && IsWbIgnored(src[TVecIdx(position)])) position++; }
909  	template<typename TSrcVec> void WbFindNextNonIgnoredS(const TSrcVec& src, size_t& position, const size_t srcEnd) const {
910  		if (position >= srcEnd) return;
911  		if (IsSbSep(src[TVecIdx(position)])) { position++; return; }
912  		position++; while (position < srcEnd && IsWbIgnored(src[TVecIdx(position)])) position++; }
913  	template<typename TSrcVec> bool WbFindPrevNonIgnored(const TSrcVec& src, const size_t srcStart, size_t& position) const {
914  		if (position <= srcStart) return false;
915  		while (position > srcStart) {
916  			position--; if (! IsWbIgnored(src[TVecIdx(position)])) return true; }
917  		return false; }
918  	void TestWbFindNonIgnored(const TIntV& src) const;
919  	void TestWbFindNonIgnored() const;
920  public:
921  	template<typename TSrcVec>
922  	bool FindNextWordBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const;
923  	template<typename TSrcVec>
924  	void FindWordBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const;
925  protected:
926  	void TestFindNextWordOrSentenceBoundary(const TStr& basePath, bool sentence);
927  protected:
928  	TUniTrie<TInt> sbExTrie;
929  	template<typename TSrcVec>
930  	bool CanSentenceEndHere(const TSrcVec& src, const size_t srcIdx, const size_t position) const;
931  public:
932  	template<typename TSrcVec>
933  	bool FindNextSentenceBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const;
934  	template<typename TSrcVec>
935  	void FindSentenceBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const;
936  	void SbEx_Clr() { sbExTrie.Clr(); }
937  	template<class TSrcVec> void SbEx_Add(const TSrcVec& v) { sbExTrie.Add(v); }
938  	void SbEx_Add(const TStr& s) {
939            TIntV v; int n = s.Len(); v.Gen(n); for (int i = 0; i < n; i++) v[i] = int(uchar(s[i])); SbEx_Add(v); }
940  	void SbEx_AddUtf8(const TStr& s) { TUniCodec codec; TIntV v; codec.DecodeUtf8(s, v); SbEx_Add(v); }
941  	int SbEx_AddMulti(const TStr& words, const bool wordsAreUtf8 = true) { TStrV vec; words.SplitOnAllCh('|', vec);
942  		for (int i = 0; i < vec.Len(); i++) if (wordsAreUtf8) SbEx_AddUtf8(vec[i]); else SbEx_Add(vec[i]);
943  		return vec.Len(); }
944  	void SbEx_Set(const TUniTrie<TInt>& newTrie) { sbExTrie = newTrie; }
945  	int SbEx_SetStdEnglish() {
946  		static const TStr data = "Ms|Mrs|Mr|Rev|Dr|Prof|Gov|Sen|Rep|Gen|Brig|Col|Capt|Lieut|Lt|Sgt|Pvt|Cmdr|Adm|Corp|St|Mt|Ft|e.g|e. g.|i.e|i. e|ib|ibid|s.v|s. v|s.vv|s. vv";
947  		SbEx_Clr(); return SbEx_AddMulti(data, false); }
948  protected:
949  	template<typename TDestCh>
950  	void AddDecomposition(const int codePoint, TVec<TDestCh>& dest, const bool compatibility) const;
951  public:
952  	template<typename TSrcVec, typename TDestCh>
953  	void Decompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
954  			TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const;
955  	template<typename TSrcVec, typename TDestCh>
956  	void Decompose(const TSrcVec& src, TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const {
957  		Decompose(src, 0, src.Len(), dest, compatibility, clrDest); }
958  	template<typename TSrcVec, typename TDestCh>
959  	void Compose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
960  			TVec<TDestCh>& dest, bool clrDest = true) const;
961  	template<typename TSrcVec, typename TDestCh>
962  	void Compose(const TSrcVec& src, TVec<TDestCh>& dest, bool clrDest = true) const {
963  		Compose(src, 0, src.Len(), dest, clrDest); }
964  	template<typename TSrcVec, typename TDestCh>
965  	void DecomposeAndCompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
966  			TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const;
967  	template<typename TSrcVec, typename TDestCh>
968  	void DecomposeAndCompose(const TSrcVec& src, TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const {
969  		DecomposeAndCompose(src, 0, src.Len(), dest, compatibility, clrDest); }
970  	template<typename TSrcVec, typename TDestCh>
971  	size_t ExtractStarters(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
972  			TVec<TDestCh>& dest, bool clrDest = true) const;
973  	template<typename TSrcVec, typename TDestCh>
974  	size_t ExtractStarters(const TSrcVec& src, TVec<TDestCh>& dest, bool clrDest = true) const {
975  		return ExtractStarters(src, 0, src.Len(), dest, clrDest); }
976  	template<typename TSrcVec>
977  	size_t ExtractStarters(TSrcVec& src) const {
978  		TIntV temp; size_t retVal = ExtractStarters(src, temp);
979  		src.Clr(); for (int i = 0; i < temp.Len(); i++) src.Add(temp[i]);
980  		return retVal; }
981  protected:
982  	void TestComposition(const TStr& basePath);
983  protected:
984  	void InitWordAndSentenceBoundaryFlags(const TStr& basePath);
985  	void InitScripts(const TStr& basePath);
986  	void InitLineBreaks(const TStr& basePath);
987  	void InitDerivedCoreProperties(const TStr& basePath);
988  	void InitPropList(const TStr& basePath);
989  	void InitSpecialCasing(const TStr& basePath);
990  	void LoadTxt_ProcessDecomposition(TUniChInfo& ci, TStr s);
991  public:
992  	void LoadTxt(const TStr& basePath);
993  	void SaveBin(const TStr& fnBinUcd);
994  public:
995  	typedef enum TCaseConversion_ { ccLower = 0, ccUpper = 1, ccTitle = 2, ccMax = 3 } TCaseConversion;
996  	template<typename TSrcVec, typename TDestCh> void GetCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest, const TCaseConversion how, const bool turkic, const bool lithuanian) const;
997  	template<typename TSrcVec, typename TDestCh> void GetLowerCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccLower, turkic, lithuanian); }
998  	template<typename TSrcVec, typename TDestCh> void GetUpperCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccUpper, turkic, lithuanian); }
999  	template<typename TSrcVec, typename TDestCh> void GetTitleCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccTitle, turkic, lithuanian); }
1000  	template<typename TSrcVec, typename TDestCh> void GetLowerCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetLowerCase(src, 0, src.Len(), dest, clrDest, turkic, lithuanian); }
1001  	template<typename TSrcVec, typename TDestCh> void GetUpperCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetUpperCase(src, 0, src.Len(), dest, clrDest, turkic, lithuanian); }
1002  	template<typename TSrcVec, typename TDestCh> void GetTitleCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetTitleCase(src, 0, src.Len(), dest, clrDest, turkic, lithuanian); }
1003  	template<typename TSrcVec, typename TDestCh> void GetSimpleCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest, const TCaseConversion how) const;
1004  	template<typename TSrcVec, typename TDestCh> void GetSimpleLowerCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccLower); }
1005  	template<typename TSrcVec, typename TDestCh> void GetSimpleUpperCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccUpper); }
1006  	template<typename TSrcVec, typename TDestCh> void GetSimpleTitleCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccTitle); }
1007  	template<typename TSrcVec, typename TDestCh> void GetSimpleLowerCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleLowerCase(src, 0, src.Len(), dest, clrDest); }
1008  	template<typename TSrcVec, typename TDestCh> void GetSimpleUpperCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleUpperCase(src, 0, src.Len(), dest, clrDest); }
1009  	template<typename TSrcVec, typename TDestCh> void GetSimpleTitleCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleTitleCase(src, 0, src.Len(), dest, clrDest); }
1010  	template<typename TSrcVec> void ToSimpleCaseConverted(TSrcVec& src, size_t srcIdx, const size_t srcCount, const TCaseConversion how) const;
1011  	template<typename TSrcVec> void ToSimpleUpperCase(TSrcVec& src, size_t srcIdx, const size_t srcCount) const { ToSimpleCaseConverted(src, srcIdx, srcCount, ccUpper); }
1012  	template<typename TSrcVec> void ToSimpleLowerCase(TSrcVec& src, size_t srcIdx, const size_t srcCount) const { ToSimpleCaseConverted(src, srcIdx, srcCount, ccLower); }
1013  	template<typename TSrcVec> void ToSimpleTitleCase(TSrcVec& src, size_t srcIdx, const size_t srcCount) const { ToSimpleCaseConverted(src, srcIdx, srcCount, ccTitle); }
1014  	template<typename TSrcVec> void ToSimpleUpperCase(TSrcVec& src) const { ToSimpleUpperCase(src, 0, src.Len()); }
1015  	template<typename TSrcVec> void ToSimpleLowerCase(TSrcVec& src) const { ToSimpleLowerCase(src, 0, src.Len()); }
1016  	template<typename TSrcVec> void ToSimpleTitleCase(TSrcVec& src) const { ToSimpleTitleCase(src, 0, src.Len()); }
1017  public:
1018  	friend class TUniCaseFolding;
1019  	template<typename TSrcVec, typename TDestCh>
1020  	void GetCaseFolded(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1021  		TVec<TDestCh>& dest, const bool clrDest, const bool full, const bool turkic = false) const { caseFolding.Fold(src, srcIdx, srcCount, dest, clrDest, full, turkic); }
1022  	template<typename TSrcVec, typename TDestCh>
1023  	void GetCaseFolded(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool full = true, const bool turkic = false) const {
1024  		GetCaseFolded(src, 0, src.Len(), dest, clrDest, full, turkic); }
1025  	template<typename TSrcVec> void ToCaseFolded(TSrcVec& src, size_t srcIdx, const size_t srcCount, const bool turkic = false) const { caseFolding.FoldInPlace(src, srcIdx, srcCount, turkic); }
1026  	template<typename TSrcVec> void ToCaseFolded(TSrcVec& src, const bool turkic = false) const { ToCaseFolded(src, 0, src.Len(), turkic); }
1027  protected:
1028  	void TestCaseConversion(const TStr& source, const TStr& trueLc, const TStr& trueTc, const TStr& trueUc, bool turkic, bool lithuanian);
1029  	void TestCaseConversions();
1030  protected:
1031  	class TUcdFileReader
1032  	{
1033  	protected:
1034  		TChA buf;
1035  	public:
1036  		TChA comment; 
1037  	protected:
1038  		FILE *f;
1039  		int putBackCh;
1040  		int GetCh() {
1041  			if (putBackCh >= 0) { int c = putBackCh; putBackCh = EOF; return c; }
1042  			return fgetc(f); }
1043  		void PutBack(int c) { Assert(putBackCh == EOF); putBackCh = c; }
1044  		bool ReadNextLine() {
1045  			buf.Clr(); comment.Clr();
1046  			bool inComment = false, first = true;
1047  			while (true) {
1048  				int c = GetCh();
1049  				if (c == EOF) return ! first;
1050  				else if (c == 13) {
1051  					c = GetCh(); if (c != 10) PutBack(c);
1052  					return true; }
1053  				else if (c == 10) return true;
1054  				else if (c == '#') inComment = true;
1055  				if (! inComment) buf += char(c);
1056  				else comment += char(c); }
1057  				}
1058  	private:
1059  		TUcdFileReader& operator = (const TUcdFileReader& r) { Fail; return *((TUcdFileReader *) 0); }
1060  		TUcdFileReader(const TUcdFileReader& r) { Fail; }
1061  	public:
1062  		TUcdFileReader() : f(0) { }
1063  		TUcdFileReader(const TStr& fileName) : f(0), putBackCh(EOF) { Open(fileName); }
1064  		void Open(const TStr& fileName) { Close(); f = fopen(fileName.CStr(), "rt"); IAssertR(f, fileName); putBackCh = EOF; }
1065  		void Close() { putBackCh = EOF; if (f) { fclose(f); f = 0; }}
1066  		~TUcdFileReader() { Close(); }
1067  		bool GetNextLine(TStrV& dest) {
1068  			dest.Clr();
1069  			while (true) {
1070  				if (! ReadNextLine()) return false;
1071  				TStr line = buf; line.ToTrunc();
1072  				if (line.Len() <= 0) continue;
1073  				line.SplitOnAllCh(';', dest, false);
1074  				for (int i = 0; i < dest.Len(); i++) dest[i].ToTrunc();
1075  				return true; }}
1076  		static int ParseCodePoint(const TStr& s) {
1077  			int c; bool ok = s.IsHexInt(true, 0, 0x10ffff, c); IAssertR(ok, s); return c; }
1078  		static void ParseCodePointList(const TStr& s, TIntV& dest, bool ClrDestP = true) { 
1079  			if (ClrDestP) dest.Clr();
1080  			TStrV parts; s.SplitOnWs(parts);
1081  			for (int i = 0; i < parts.Len(); i++) {
1082  				int c; bool ok = parts[i].IsHexInt(true, 0, 0x10ffff, c); IAssertR(ok, s);
1083  				dest.Add(c); } }
1084  		static void ParseCodePointRange(const TStr& s, int& from, int &to) { 
1085  			int i = s.SearchStr(".."); if (i < 0) { from = ParseCodePoint(s); to = from; return; }
1086  			from = ParseCodePoint(s.GetSubStr(0, i - 1));
1087  			to = ParseCodePoint(s.GetSubStr(i + 2, s.Len() - 1)); }
1088  	};
1089  	class TSubcatHelper
1090  	{
1091  	public:
1092  		bool hasCat; TUniChSubCategory subCat;
1093  		TStrH invalidCatCodes;
1094  		TUniChDb &owner;
1095  		TSubcatHelper(TUniChDb &owner_) : owner(owner_) { }
1096  		void ProcessComment(TUniChDb::TUcdFileReader &reader)
1097  		{
1098  			hasCat = false; subCat = ucOtherNotAssigned;
1099  			if (reader.comment.Len() > 3)
1100  			{
1101  				IAssert(reader.comment[0] == '#');
1102  				IAssert(reader.comment[1] == ' ');
1103  				char chCat = reader.comment[2], chSubCat = reader.comment[3];
1104  				if (reader.comment.Len() > 4) IAssert(isspace(uchar(reader.comment[4])));
1105  				if (TUniChInfo::IsValidSubCat(chCat, chSubCat)) {
1106  					hasCat = true; subCat = (TUniChSubCategory) ((int(uchar(chCat)) << 8) | (int(uchar(chSubCat)))); }
1107  				else invalidCatCodes.AddKey(TStr(chCat) + TStr(chSubCat));
1108  			}
1109  		}
1110  		void SetCat(const int cp) {
1111  			int i = owner.h.GetKeyId(cp); IAssert(i >= 0);
1112  			IAssert(owner.h[i].subCat == ucOtherNotAssigned);
1113  			IAssert(hasCat);
1114  			owner.h[i].SetCatAndSubCat(subCat); }
1115  		void TestCat(const int cp) {
1116  			if (! hasCat) return;
1117  			int i = owner.h.GetKeyId(cp); IAssert(i >= 0);
1118  			IAssert(owner.h[i].subCat == subCat); }
1119  		~TSubcatHelper()
1120  		{
1121  			if (invalidCatCodes.IsKey("L&")) invalidCatCodes.DelKey("L&");
1122  			if (! invalidCatCodes.Empty()) {
1123  				printf("Invalid cat code(s) in the comments: ");
1124  				for (int i = invalidCatCodes.FFirstKeyId(); invalidCatCodes.FNextKeyId(i); )
1125  					printf(" \"%s\"", invalidCatCodes.GetKey(i).CStr());
1126  				printf("\n"); }
1127  		}
1128  	};
1129  };
1130  class TUnicode
1131  {
1132  public:
1133  	TUniCodec codec;
1134  	TUniChDb ucd;
1135  	TUnicode() { Init(); }
1136  	explicit TUnicode(const TStr& fnBinUcd) { ucd.LoadBin(fnBinUcd); Init(); }
1137  	void Init() { InitCodecs(); }
1138  	int DecodeUtf8(const TIntV& src, TIntV& dest) const { return (int) codec.DecodeUtf8(src, dest); }
1139  	int DecodeUtf8(const TStr& src, TIntV& dest) const { return (int) codec.DecodeUtf8(src, dest); }
1140  	int EncodeUtf8(const TIntV& src, TIntV& dest) const { return (int) codec.EncodeUtf8(src, dest); }
1141  	TStr EncodeUtf8Str(const TIntV& src) const { return codec.EncodeUtf8Str(src); }
1142  	static void EncodeUtf8(const uint& Ch, TChA& Dest);
1143  	static TStr EncodeUtf8(const uint& Ch);
1144  	int DecodeUtf16FromBytes(const TIntV& src, TIntV& dest,
1145  		const TUtf16BomHandling bomHandling = bomAllowed,
1146  		const TUniByteOrder defaultByteOrder = boMachineEndian) const {
1147  			return (int) codec.DecodeUtf16FromBytes(src, 0, src.Len(), dest, true, bomHandling, defaultByteOrder); }
1148  	int DecodeUtf16FromWords(const TIntV& src, TIntV& dest,
1149  		const TUtf16BomHandling bomHandling = bomAllowed,
1150  		const TUniByteOrder defaultByteOrder = boMachineEndian) const {
1151  			return (int) codec.DecodeUtf16FromWords(src, 0, src.Len(), dest, true, bomHandling, defaultByteOrder); }
1152  	int EncodeUtf16ToWords(const TIntV& src, TIntV& dest, const bool insertBom,
1153  		const TUniByteOrder destByteOrder = boMachineEndian) const {
1154  			return (int) codec.EncodeUtf16ToWords(src, 0, src.Len(), dest, true, insertBom, destByteOrder); }
1155  	int EncodeUtf16ToBytes(const TIntV& src, TIntV& dest, const bool insertBom,
1156  		const TUniByteOrder destByteOrder = boMachineEndian) const {
1157  			return (int) codec.EncodeUtf16ToBytes(src, 0, src.Len(), dest, true, insertBom, destByteOrder); }
1158  	T8BitCodec<TEncoding_ISO8859_1> iso8859_1;
1159  	T8BitCodec<TEncoding_ISO8859_2> iso8859_2;
1160  	T8BitCodec<TEncoding_ISO8859_3> iso8859_3;
1161  	T8BitCodec<TEncoding_ISO8859_4> iso8859_4;
1162  	T8BitCodec<TEncoding_YuAscii> yuAscii;
1163  	T8BitCodec<TEncoding_CP1250> cp1250;
1164  	T8BitCodec<TEncoding_CP852> cp852;
1165  	T8BitCodec<TEncoding_CP437> cp437;
1166  protected:
1167  	THash<TStr, PCodecBase> codecs;
1168  	static inline TStr NormalizeCodecName(const TStr& name) {
1169  		TStr s = name.GetLc(); s.ChangeStrAll("_", ""); s.ChangeStrAll("-", ""); return s; }
1170  public:
1171  	void RegisterCodec(const TStr& nameList, const PCodecBase& codec) {
1172  		TStrV names; nameList.SplitOnWs(names);
1173  		for (int i = 0; i < names.Len(); i++)
1174  			codecs.AddDat(NormalizeCodecName(names[i]), codec); }
1175  	void UnregisterCodec(const TStr& nameList) {
1176  		TStrV names; nameList.SplitOnWs(names);
1177  		for (int i = 0; i < names.Len(); i++)
1178  			codecs.DelKey(NormalizeCodecName(names[i])); }
1179  	void ClrCodecs() { codecs.Clr(); }
1180  	void InitCodecs();
1181  	PCodecBase GetCodec(const TStr& name) const {
1182  		TStr s = NormalizeCodecName(name);
1183  		PCodecBase p; if (! codecs.IsKeyGetDat(s, p)) p.Clr();
1184  		return p; }
1185  	void GetAllCodecs(TCodecBaseV& dest) const {
1186  		dest.Clr();
1187  		for (int i = codecs.FFirstKeyId(); codecs.FNextKeyId(i); ) {
1188  			PCodecBase codec = codecs[i]; bool found = false;
1189  			for (int j = 0; j < dest.Len(); j++) if (dest[j]() == codec()) { found = true; break; }
1190  			if (! found) dest.Add(codec); }}
1191  	bool FindNextWordBoundary(const TIntV& src, int &position) const {
1192  		if (position < 0) { position = 0; return true; }
1193  		size_t position_; bool retVal = ucd.FindNextWordBoundary(src, 0, src.Len(), position_); position = int(position_); return retVal; }
1194  	void FindWordBoundaries(const TIntV& src, TBoolV& dest) const { ucd.FindWordBoundaries(src, 0, src.Len(), dest); }
1195  	bool FindNextSentenceBoundary(const TIntV& src, int &position) const {
1196  		if (position < 0) { position = 0; return true; }
1197  		size_t position_; bool retVal = ucd.FindNextSentenceBoundary(src, 0, src.Len(), position_); position = int(position_); return retVal; }
1198  	void FindSentenceBoundaries(const TIntV& src, TBoolV& dest) const { ucd.FindSentenceBoundaries(src, 0, src.Len(), dest); }
1199  	void ClrSentenceBoundaryExceptions() { ucd.SbEx_Clr(); }
1200  	void UseEnglishSentenceBoundaryExceptions() { ucd.SbEx_SetStdEnglish(); }
1201  	void Decompose(const TIntV& src, TIntV& dest, bool compatibility) const { ucd.Decompose(src, dest, compatibility, true); }
1202  	void Compose(const TIntV& src, TIntV& dest) const { return ucd.Compose(src, dest, true); }
1203  	void DecomposeAndCompose(const TIntV& src, TIntV& dest, bool compatibility) const { return ucd.DecomposeAndCompose(src, dest, compatibility); }
1204  	int ExtractStarters(const TIntV& src, TIntV& dest) const { return (int) ucd.ExtractStarters(src, dest); }
1205  	int ExtractStarters(TIntV& src) const { return (int) ucd.ExtractStarters(src); }
1206  public:
1207  	typedef TUniChDb::TCaseConversion TCaseConversion;
1208  	void GetLowerCase(const TIntV& src, TIntV& dest) const { ucd.GetLowerCase(src, dest, true, false, false); }
1209  	void GetUpperCase(const TIntV& src, TIntV& dest) const { ucd.GetUpperCase(src, dest, true, false, false); }
1210  	void GetTitleCase(const TIntV& src, TIntV& dest) const { ucd.GetTitleCase(src, dest, true, false, false); }
1211  	void GetSimpleLowerCase(const TIntV& src, TIntV& dest) const { ucd.GetSimpleLowerCase(src, dest, true); }
1212  	void GetSimpleUpperCase(const TIntV& src, TIntV& dest) const { ucd.GetSimpleUpperCase(src, dest, true); }
1213  	void GetSimpleTitleCase(const TIntV& src, TIntV& dest) const { ucd.GetSimpleTitleCase(src, dest, true); }
1214  	void ToSimpleUpperCase(TIntV& src) const { ucd.ToSimpleUpperCase(src); }
1215  	void ToSimpleLowerCase(TIntV& src) const { ucd.ToSimpleLowerCase(src); }
1216  	void ToSimpleTitleCase(TIntV& src) const { ucd.ToSimpleTitleCase(src); }
1217  	void GetCaseFolded(const TIntV& src, TIntV& dest, const bool full = true) const { return ucd.GetCaseFolded(src, dest, true, full, false); }
1218  	void ToCaseFolded(TIntV& src) const { return ucd.ToCaseFolded(src, false); }
1219  	TStr GetUtf8CaseFolded(const TStr& s) const {
1220  		bool isAscii = true;
1221  		for (int i = 0, n = s.Len(); i < n; i++) if (uchar(s[i]) >= 128) { isAscii = false; break; }
1222  		if (isAscii) return s.GetLc();
1223  		TIntV src; DecodeUtf8(s, src);
1224  		TIntV dest; GetCaseFolded(src, dest);
1225  		return EncodeUtf8Str(dest); }
1226  #define ___UniFwd1(name) bool name(const int cp) const { return ucd.name(cp); }
1227  	DECLARE_FORWARDED_PROPERTY_METHODS
1228  #undef DECLARE_FORWARDED_PROPERTY_METHODS
1229  #undef __UniFwd1
1230  	___UniFwd2(IsPrivateUse, IsSurrogate)
1231  	TUniChCategory GetCat(const int cp) const { return ucd.GetCat(cp); }
1232  	TUniChSubCategory GetSubCat(const int cp) const { return ucd.GetSubCat(cp); }
1233  	const char *GetCharName(const int cp) const { return ucd.GetCharName(cp); }
1234  	TStr GetCharNameS(const int cp) const { return ucd.GetCharNameS(cp); }
1235  };
1236  template<typename TSrcVec, typename TDestCh>
1237  size_t TUniCodec::DecodeUtf8(
1238  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1239  	TVec<TDestCh>& dest, const bool clrDest) const
1240  {
1241  	size_t nDecoded = 0;
1242  	if (clrDest) dest.Clr();
1243  	const size_t origSrcIdx = srcIdx;
1244  	const size_t srcEnd = srcIdx + srcCount;
1245  	while (srcIdx < srcEnd)
1246  	{
1247  		const size_t charSrcIdx = srcIdx;
1248  		uint c = src[TVecIdx(srcIdx)] & 0xff; srcIdx++;
1249  		if ((c & _1000_0000) == 0) {
1250  			dest.Add(TDestCh(c)); nDecoded++; continue; }
1251  		else if ((c & _1100_0000) == _1000_0000) {
1252  			switch (errorHandling) {
1253  			case uehThrow: throw TUnicodeException(charSrcIdx, c, "Invalid character: 10xxxxxx.");
1254  			case uehAbort: return nDecoded;
1255  			case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1256  			case uehIgnore: continue;
1257  			default: Fail; } }
1258  		else
1259  		{
1260  			uint nMoreBytes = 0, nBits = 0, minVal = 0;
1261  			if ((c & _1110_0000) == _1100_0000) nMoreBytes = 1, nBits = 5, minVal = 0x80;
1262  			else if ((c & _1111_0000) == _1110_0000) nMoreBytes = 2, nBits = 4, minVal = 0x800;
1263  			else if ((c & _1111_1000) == _1111_0000) nMoreBytes = 3, nBits = 3, minVal = 0x10000;
1264  			else if ((c & _1111_1100) == _1111_1000) nMoreBytes = 4, nBits = 2, minVal = 0x200000;
1265  			else if ((c & _1111_1110) == _1111_1100) nMoreBytes = 5, nBits = 1, minVal = 0x4000000;
1266  			else {
1267  				if (strict)  {
1268  					switch (errorHandling) {
1269  					case uehThrow: throw TUnicodeException(charSrcIdx, c, "Invalid character: 1111111x.");
1270  					case uehAbort: return nDecoded;
1271  					case uehReplace: break; 
1272  					case uehIgnore: break; 
1273  					default: Fail; } }
1274  				nMoreBytes = 5; nBits = 2; minVal = 0x80000000u; }
1275  			uint cOut = c & ((1 << nBits) - 1); 
1276  			bool cancel = false;
1277  			for (uint i = 0; i < nMoreBytes && ! cancel; i++) {
1278  				if (! (srcIdx < srcEnd)) {
1279  					switch (errorHandling) {
1280  					case uehThrow: throw TUnicodeException(charSrcIdx, c, TInt::GetStr(nMoreBytes) + " more bytes expected, only " + TInt::GetStr(int(srcEnd - charSrcIdx - 1)) + " available.");
1281  					case uehAbort: return nDecoded;
1282  					case uehReplace: dest.Add(TDestCh(replacementChar)); cancel = true; continue;
1283  					case uehIgnore: cancel = true; continue;
1284  					default: Fail; } }
1285  				c = src[TVecIdx(srcIdx)] & 0xff; srcIdx++;
1286  				if ((c & _1100_0000) != _1000_0000) { 
1287  					switch (errorHandling) {
1288  					case uehThrow: throw TUnicodeException(charSrcIdx, c, "Byte " + TInt::GetStr(i) + " of " + TInt::GetStr(nMoreBytes) + " extra bytes should begin with 10xxxxxx.");
1289  					case uehAbort: return nDecoded;
1290  					case uehReplace: dest.Add(TDestCh(replacementChar)); srcIdx--; cancel = true; continue;
1291  					case uehIgnore: srcIdx--; cancel = true; continue;
1292  					default: Fail; } }
1293  				cOut <<= 6; cOut |= (c & _0011_1111); }
1294  			if (cancel) continue;
1295  			if (strict) {
1296  				bool err1 = (cOut < minVal);
1297  				bool err2 = (nMoreBytes > 3 || (nMoreBytes == 3 && cOut > 0x10ffff));
1298  				if (err1 || err2) switch (errorHandling) {
1299  					case uehThrow:
1300  						if (err1) throw TUnicodeException(charSrcIdx, c, "The codepoint 0x" + TInt::GetStr(cOut, "%08x") + " has been represented by too many bytes (" + TInt::GetStr(nMoreBytes + 1) + ").");
1301  						else if (err2) throw TUnicodeException(charSrcIdx, c, "Invalid multibyte sequence: it decodes into 0x" + TInt::GetStr(cOut, "%08x") + ", but only codepoints 0..0x10ffff are valid.");
1302  						else { Fail; break; }
1303  					case uehAbort: return nDecoded;
1304  					case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1305  					case uehIgnore: continue;
1306  					default: Fail; } }
1307  			if (! (skipBom && (cOut == 0xfffe || cOut == 0xfeff) && charSrcIdx == origSrcIdx)) {
1308  				dest.Add(cOut); nDecoded++; }
1309  		} 
1310  	} 
1311  	return nDecoded;
1312  }
1313  template<typename TSrcVec, typename TDestCh>
1314  size_t TUniCodec::EncodeUtf8(
1315  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1316  	TVec<TDestCh>& dest, const bool clrDest) const
1317  {
1318  	size_t nEncoded = 0;
1319  	for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++)
1320  	{
1321  		uint c = uint(src[TVecIdx(srcIdx)]);
1322  		bool err = false;
1323  		if (strict && c > 0x10ffff) {
1324  			err = true;
1325  			switch (errorHandling) {
1326  			case uehThrow: throw TUnicodeException(srcIdx, c, "Invalid character (0x" + TInt::GetStr(c, "%x") + "; only characters in the range 0..0x10ffff are allowed).");
1327  			case uehAbort: return nEncoded;
1328  			case uehReplace: c = replacementChar; break;
1329  			case uehIgnore: continue;
1330  			default: Fail; } }
1331  		if (c < 0x80u)
1332  			dest.Add(TDestCh(c & 0xffu));
1333  		else if (c < 0x800u) {
1334  			dest.Add(TDestCh(_1100_0000 | ((c >> 6) & _0001_1111)));
1335  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1336  		else if (c < 0x10000u) {
1337  			dest.Add(TDestCh(_1110_0000 | ((c >> 12) & _0000_1111)));
1338  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1339  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1340  		else if (c < 0x200000u) {
1341  			dest.Add(TDestCh(_1111_0000 | ((c >> 18) & _0000_0111)));
1342  			dest.Add(TDestCh(_1000_0000 | ((c >> 12) & _0011_1111)));
1343  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1344  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1345  		else if (c < 0x4000000u) {
1346  			dest.Add(TDestCh(_1111_1000 | ((c >> 24) & _0000_0011)));
1347  			dest.Add(TDestCh(_1000_0000 | ((c >> 18) & _0011_1111)));
1348  			dest.Add(TDestCh(_1000_0000 | ((c >> 12) & _0011_1111)));
1349  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1350  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1351  		else {
1352  			dest.Add(TDestCh(_1111_1100 | ((c >> 30) & _0000_0011)));
1353  			dest.Add(TDestCh(_1000_0000 | ((c >> 24) & _0011_1111)));
1354  			dest.Add(TDestCh(_1000_0000 | ((c >> 18) & _0011_1111)));
1355  			dest.Add(TDestCh(_1000_0000 | ((c >> 12) & _0011_1111)));
1356  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1357  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1358  		if (! err) nEncoded++;
1359  	}
1360  	return nEncoded;
1361  }
1362  template<typename TSrcVec, typename TDestCh>
1363  size_t TUniCodec::DecodeUtf16FromBytes(
1364  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1365  	TVec<TDestCh>& dest, const bool clrDest,
1366  	const TUtf16BomHandling bomHandling,
1367  	const TUniByteOrder defaultByteOrder) const
1368  {
1369  	IAssert(srcCount % 2 == 0);
1370  	IAssert(bomHandling == bomAllowed || bomHandling == bomRequired || bomHandling == bomIgnored);
1371  	IAssert(defaultByteOrder == boMachineEndian || defaultByteOrder == boBigEndian || defaultByteOrder == boLittleEndian);
1372  	if (clrDest) dest.Clr();
1373  	size_t nDecoded = 0;
1374  	if (srcCount <= 0) return nDecoded;
1375  	const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount;
1376  	bool littleEndian = false;
1377  	bool leDefault = (defaultByteOrder == boLittleEndian || (defaultByteOrder == boMachineEndian && IsMachineLittleEndian()));
1378  	if (bomHandling == bomIgnored) littleEndian = leDefault;
1379  	else if (bomHandling == bomAllowed || bomHandling == bomRequired)
1380  	{
1381  		int byte1 = uint(src[TVecIdx(srcIdx)]) & 0xff, byte2 = uint(src[TVecIdx(srcIdx + 1)]) & 0xff;
1382  		if (byte1 == 0xfe && byte2 == 0xff) { littleEndian = false; if (skipBom) srcIdx += 2; }
1383  		else if (byte1 == 0xff && byte2 == 0xfe) { littleEndian = true; if (skipBom) srcIdx += 2; }
1384  		else if (bomHandling == bomAllowed) littleEndian = leDefault;
1385  		else { 
1386  			switch (errorHandling) {
1387  			case uehThrow: throw TUnicodeException(srcIdx, byte1, "BOM expected at the beginning of the input vector (" + TInt::GetStr(byte1, "%02x") + " " + TInt::GetStr(byte2, "%02x") + " found instead).");
1388  			case uehAbort: case uehReplace: case uehIgnore: return size_t(-1);
1389  			default: Fail; } }
1390  	}
1391  	else Fail;
1392  	while (srcIdx < srcEnd)
1393  	{
1394  		const size_t charSrcIdx = srcIdx;
1395  		uint byte1 = uint(src[TVecIdx(srcIdx)]) & 0xff, byte2 = uint(src[TVecIdx(srcIdx + 1)]) & 0xff; srcIdx += 2;
1396  		uint c = littleEndian ? (byte1 | (byte2 << 8)) : (byte2 | (byte1 << 8));
1397  		if (Utf16FirstSurrogate <= c && c <= Utf16FirstSurrogate + 1023)
1398  		{
1399  			if (! (srcIdx + 2 <= srcEnd)) {
1400  				switch (errorHandling) {
1401  				case uehThrow: throw TUnicodeException(charSrcIdx, c, "The second character of a surrogate pair is missing.");
1402  				case uehAbort: return nDecoded;
1403  				case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1404  				case uehIgnore: continue;
1405  				default: Fail; } }
1406  			uint byte1 = uint(src[TVecIdx(srcIdx)]) & 0xff, byte2 = uint(src[TVecIdx(srcIdx + 1)]) & 0xff; srcIdx += 2;
1407  			uint c2 = littleEndian ? (byte1 | (byte2 << 8)) : (byte2 | (byte1 << 8));
1408  			if (c2 < Utf16SecondSurrogate || Utf16SecondSurrogate + 1023 < c2) {
1409  				switch (errorHandling) {
1410  				case uehThrow: throw TUnicodeException(charSrcIdx + 2, c2, "The second character of a surrogate pair should be in the range " + TInt::GetStr(Utf16SecondSurrogate, "%04x") + ".." + TInt::GetStr(Utf16SecondSurrogate + 1023, "%04x") + ", not " + TInt::GetStr(c2, "04x") + ".");
1411  				case uehAbort: return nDecoded;
1412  				case uehReplace: dest.Add(TDestCh(replacementChar)); srcIdx -= 2; continue;
1413  				case uehIgnore: srcIdx -= 2; continue;
1414  				default: Fail; } }
1415  			uint cc = ((c - Utf16FirstSurrogate) << 10) | (c2 - Utf16SecondSurrogate);
1416  			cc += 0x10000;
1417  			dest.Add(TDestCh(cc)); nDecoded++; continue;
1418  		}
1419  		else if (strict && Utf16SecondSurrogate <= c && c <= Utf16SecondSurrogate + 1023) {
1420  			switch (errorHandling) {
1421  			case uehThrow: throw TUnicodeException(charSrcIdx, c, "This 16-bit value should be used only as the second character of a surrogate pair.");
1422  			case uehAbort: return nDecoded;
1423  			case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1424  			case uehIgnore: continue;
1425  			default: Fail; } }
1426  		if (charSrcIdx == origSrcIdx && (c == 0xfffeu || c == 0xfeffu) && skipBom) continue;
1427  		dest.Add(TDestCh(c)); nDecoded++;
1428  	}
1429  	return nDecoded;
1430  }
1431  template<typename TSrcVec, typename TDestCh>
1432  size_t TUniCodec::DecodeUtf16FromWords(
1433  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1434  	TVec<TDestCh>& dest, bool clrDest,
1435  	const TUtf16BomHandling bomHandling,
1436  	const TUniByteOrder defaultByteOrder) const
1437  {
1438  	IAssert(bomHandling == bomAllowed || bomHandling == bomRequired || bomHandling == bomIgnored);
1439  	IAssert(defaultByteOrder == boMachineEndian || defaultByteOrder == boBigEndian || defaultByteOrder == boLittleEndian);
1440  	if (clrDest) dest.Clr();
1441  	size_t nDecoded = 0;
1442  	if (srcCount <= 0) return nDecoded;
1443  	const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount;
1444  	bool swap = false;
1445  	bool isMachineLe = IsMachineLittleEndian();
1446  	bool isDefaultLe = (defaultByteOrder == boLittleEndian || (defaultByteOrder == boMachineEndian && isMachineLe));
1447  	if (bomHandling == bomIgnored) swap = (isDefaultLe != isMachineLe);
1448  	else if (bomHandling == bomAllowed || bomHandling == bomRequired)
1449  	{
1450  		int c = uint(src[TVecIdx(srcIdx)]) & 0xffff;
1451  		if (c == 0xfeff) { swap = false; if (skipBom) srcIdx += 1; }
1452  		else if (c == 0xfffe) { swap = true; if (skipBom) srcIdx += 1; }
1453  		else if (bomHandling == bomAllowed) swap = (isMachineLe != isDefaultLe);
1454  		else { 
1455  			switch (errorHandling) {
1456  			case uehThrow: throw TUnicodeException(srcIdx, c, "BOM expected at the beginning of the input vector (" + TInt::GetStr(c, "%04x") + " found instead).");
1457  			case uehAbort: case uehReplace: case uehIgnore: return size_t(-1);
1458  			default: Fail; } }
1459  	}
1460  	else Fail;
1461  	while (srcIdx < srcEnd)
1462  	{
1463  		const size_t charSrcIdx = srcIdx;
1464  		uint c = uint(src[TVecIdx(srcIdx)]) & 0xffffu; srcIdx++;
1465  		if (swap) c = ((c >> 8) & 0xff) | ((c & 0xff) << 8);
1466  		if (Utf16FirstSurrogate <= c && c <= Utf16FirstSurrogate + 1023)
1467  		{
1468  			if (! (srcIdx < srcEnd)) {
1469  				switch (errorHandling) {
1470  				case uehThrow: throw TUnicodeException(charSrcIdx, c, "The second character of a surrogate pair is missing.");
1471  				case uehAbort: return nDecoded;
1472  				case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1473  				case uehIgnore: continue;
1474  				default: Fail; } }
1475  			uint c2 = uint(src[TVecIdx(srcIdx)]) & 0xffffu; srcIdx++;
1476  			if (swap) c2 = ((c2 >> 8) & 0xff) | ((c2 & 0xff) << 8);
1477  			if (c2 < Utf16SecondSurrogate || Utf16SecondSurrogate + 1023 < c2) {
1478  				switch (errorHandling) {
1479  				case uehThrow: throw TUnicodeException(charSrcIdx + 1, c2, "The second character of a surrogate pair should be in the range " + TInt::GetStr(Utf16SecondSurrogate, "%04x") + ".." + TInt::GetStr(Utf16SecondSurrogate + 1023, "%04x") + ", not " + TInt::GetStr(c2, "04x") + ".");
1480  				case uehAbort: return nDecoded;
1481  				case uehReplace: dest.Add(TDestCh(replacementChar)); srcIdx -= 1; continue;
1482  				case uehIgnore: srcIdx -= 1; continue;
1483  				default: Fail; } }
1484  			uint cc = ((c - Utf16FirstSurrogate) << 10) | (c2 - Utf16SecondSurrogate);
1485  			cc += 0x10000;
1486  			dest.Add(TDestCh(cc)); nDecoded++; continue;
1487  		}
1488  		else if (strict && Utf16SecondSurrogate <= c && c <= Utf16SecondSurrogate + 1023) {
1489  			switch (errorHandling) {
1490  			case uehThrow: throw TUnicodeException(charSrcIdx, c, "This 16-bit value should be used only as the second character of a surrogate pair.");
1491  			case uehAbort: return nDecoded;
1492  			case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1493  			case uehIgnore: continue;
1494  			default: Fail; } }
1495  		if (charSrcIdx == origSrcIdx && (c == 0xfffeu || c == 0xfeffu) && skipBom) continue;
1496  		dest.Add(TDestCh(c)); nDecoded++;
1497  	}
1498  	return nDecoded;
1499  }
1500  template<typename TSrcVec, typename TDestCh>
1501  size_t TUniCodec::EncodeUtf16ToWords(
1502  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1503  	TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
1504  	const TUniByteOrder destByteOrder) const
1505  {
1506  	bool isMachineLe = IsMachineLittleEndian();
1507  	bool swap = (destByteOrder == boLittleEndian && ! isMachineLe) || (destByteOrder == boBigEndian && isMachineLe);
1508  	size_t nEncoded = 0, srcEnd = srcIdx + srcCount;
1509  	if (insertBom) { dest.Add(TDestCh(swap ? 0xfffeu : 0xfeffu)); nEncoded++; }
1510  	while (srcIdx < srcEnd)
1511  	{
1512  		uint c = uint(src[TVecIdx(srcIdx)]); srcIdx++;
1513  		if (! (c <= 0x10ffffu)) {
1514  			switch (errorHandling) {
1515  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 only supports characters in the range 0..10ffff (not " + TUInt::GetStr(c, "%08x") + ").");
1516  			case uehAbort: return nEncoded;
1517  			case uehReplace: dest.Add(TDestCh(swap ? SwapBytes(replacementChar) : replacementChar)); continue;
1518  			case uehIgnore: continue;
1519  			default: Fail; } }
1520  		if (Utf16FirstSurrogate <= c && c < Utf16FirstSurrogate + 1023) {
1521  			switch (errorHandling) {
1522  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 cannot encode " + TUInt::GetStr(c, "%04x") + " as it belongs to the first surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + ").");
1523  			case uehAbort: return nEncoded;
1524  			case uehReplace: dest.Add(TDestCh(swap ? SwapBytes(replacementChar) : replacementChar)); continue;
1525  			case uehIgnore: continue;
1526  			default: Fail; } }
1527  		if (Utf16SecondSurrogate <= c && c < Utf16SecondSurrogate + 1023) {
1528  			switch (errorHandling) {
1529  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "The character " + TUInt::GetStr(c, "%04x") + " belongs to the second surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + "), which is not allowed with strict == true.");
1530  			case uehAbort: return nEncoded;
1531  			case uehReplace: dest.Add(TDestCh(swap ? SwapBytes(replacementChar) : replacementChar)); continue;
1532  			case uehIgnore: continue;
1533  			default: Fail; } }
1534  		if (c <= 0xffffu) {
1535  			if (swap) c = ((c >> 8) & 0xff) | ((c & 0xff) << 8);
1536  			dest.Add(TDestCh(c)); nEncoded++; continue; }
1537  		c -= 0x10000u; IAssert(&bsol;*0 <= c &&*/ c <= 0xfffffu);
1538  		uint c1 = (c >> 10) & 1023, c2 = c & 1023;
1539  		c1 += Utf16FirstSurrogate; c2 += Utf16SecondSurrogate;
1540  		if (swap) {
1541  			c1 = ((c1 >> 8) & 0xff) | ((c1 & 0xff) << 8);
1542  			c2 = ((c2 >> 8) & 0xff) | ((c2 & 0xff) << 8); }
1543  		dest.Add(TDestCh(c1));
1544  		dest.Add(TDestCh(c2));
1545  		nEncoded++; continue;
1546  	}
1547  	return nEncoded;
1548  }
1549  template<typename TSrcVec, typename TDestCh>
1550  size_t TUniCodec::EncodeUtf16ToBytes(
1551  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1552  	TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
1553  	const TUniByteOrder destByteOrder) const
1554  {
1555  	bool isDestLe = (destByteOrder == boLittleEndian || (destByteOrder == boMachineEndian && IsMachineLittleEndian()));
1556  	size_t nEncoded = 0, srcEnd = srcIdx + srcCount;
1557  	if (insertBom) { dest.Add(isDestLe ? 0xff : 0xfe); dest.Add(isDestLe ? 0xfe : 0xff); nEncoded++; }
1558  	while (srcIdx < srcEnd)
1559  	{
1560  		uint c = uint(src[TVecIdx(srcIdx)]); srcIdx++;
1561  		if (! (c <= 0x10ffffu)) {
1562  			switch (errorHandling) {
1563  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 only supports characters in the range 0..10ffff (not " + TUInt::GetStr(c, "%08x") + ").");
1564  			case uehAbort: return nEncoded;
1565  #define ___OutRepl if (isDestLe) { dest.Add(replacementChar & 0xff); dest.Add((replacementChar >> 8) & 0xff); } else { dest.Add((replacementChar >> 8) & 0xff); dest.Add(replacementChar & 0xff); }
1566  			case uehReplace: ___OutRepl; continue;
1567  			case uehIgnore: continue;
1568  			default: Fail; } }
1569  		if (Utf16FirstSurrogate <= c && c < Utf16FirstSurrogate + 1023) {
1570  			switch (errorHandling) {
1571  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 cannot encode " + TUInt::GetStr(c, "%04x") + " as it belongs to the first surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + ").");
1572  			case uehAbort: return nEncoded;
1573  			case uehReplace: ___OutRepl; continue;
1574  			case uehIgnore: continue;
1575  			default: Fail; } }
1576  		if (Utf16SecondSurrogate <= c && c < Utf16SecondSurrogate + 1023) {
1577  			switch (errorHandling) {
1578  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "The character " + TUInt::GetStr(c, "%04x") + " belongs to the second surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + "), which is not allowed with strict == true.");
1579  			case uehAbort: return nEncoded;
1580  			case uehReplace: ___OutRepl; continue;
1581  			case uehIgnore: continue;
1582  			default: Fail; } }
1583  #undef ___OutRepl
1584  		if (c <= 0xffffu) {
1585  			if (isDestLe) { dest.Add(c & 0xff); dest.Add((c >> 8) & 0xff); }
1586  			else { dest.Add((c >> 8) & 0xff); dest.Add(c & 0xff); }
1587  			nEncoded++; continue; }
1588  		c -= 0x10000u; IAssert(&bsol;*0 <= c &&*/ c <= 0xfffffu);
1589  		uint c1 = (c >> 10) & 1023, c2 = c & 1023;
1590  		c1 += Utf16FirstSurrogate; c2 += Utf16SecondSurrogate;
1591  		if (isDestLe) { dest.Add(c1 & 0xff); dest.Add((c1 >> 8) & 0xff); dest.Add(c2 & 0xff); dest.Add((c2 >> 8) & 0xff); }
1592  		else { dest.Add((c1 >> 8) & 0xff); dest.Add(c1 & 0xff); dest.Add((c2 >> 8) & 0xff); dest.Add(c2 & 0xff); }
1593  		nEncoded++; continue;
1594  	}
1595  	return nEncoded;
1596  }
1597  template<typename TSrcVec>
1598  bool TUniChDb::FindNextWordBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const
1599  {
1600  	if (position < srcIdx) { position = srcIdx; return true; }
1601  	const size_t srcEnd = srcIdx + srcCount;
1602  	if (position >= srcEnd) return false;
1603  	size_t origPos = position;
1604  	if (IsWbIgnored(src[TVecIdx(position)])) {
1605  		if (! WbFindPrevNonIgnored(src, srcIdx, position))
1606  			position = origPos;
1607  	}
1608  	size_t posPrev = position;
1609  	if (! WbFindPrevNonIgnored(src, srcIdx, posPrev)) posPrev = position;
1610  	if (position == origPos && position + 1 < srcEnd && IsSbSep(src[TVecIdx(position)]) && IsWbIgnored(src[TVecIdx(position + 1)])) { position += 1; return true; }
1611  	size_t posNext = position; WbFindNextNonIgnored(src, posNext, srcEnd);
1612  	size_t posNext2;
1613  	int cPrev = (posPrev < position ? (int) src[TVecIdx(posPrev)] : -1), cCur = (position < srcEnd ? (int) src[TVecIdx(position)] : -1);
1614  	int cNext = (position < posNext && posNext < srcEnd ? (int) src[TVecIdx(posNext)] : -1);
1615  	int wbfPrev = GetWbFlags(cPrev), wbfCur = GetWbFlags(cCur), wbfNext = GetWbFlags(cNext);
1616  	int cNext2, wbfNext2;
1617  	for ( ; position < srcEnd; posPrev = position, position = posNext, posNext = posNext2,
1618  							   cPrev = cCur, cCur = cNext, cNext = cNext2,
1619  							   wbfPrev = wbfCur, wbfCur = wbfNext, wbfNext = wbfNext2)
1620  	{
1621  		posNext2 = posNext; WbFindNextNonIgnored(src, posNext2, srcEnd);
1622  		cNext2 = (posNext < posNext2 && posNext2 < srcEnd ? (int) src[TVecIdx(posNext2)] : -1);
1623  		wbfNext2 = GetWbFlags(cNext2);
1624  #define TestCurNext(curFlag, nextFlag) if ((wbfCur & curFlag) == curFlag && (wbfNext & nextFlag) == nextFlag) continue
1625  #define TestCurNext2(curFlag, nextFlag, next2Flag) if ((wbfCur & curFlag) == curFlag && (wbfNext & nextFlag) == nextFlag && (wbfNext2 & next2Flag) == next2Flag) continue
1626  #define TestPrevCurNext(prevFlag, curFlag, nextFlag) if ((wbfPrev & prevFlag) == prevFlag && (wbfCur & curFlag) == curFlag && (wbfNext & nextFlag) == nextFlag) continue
1627  		if (cCur == 13 && cNext == 10) continue;
1628  		TestCurNext(ucfWbALetter, ucfWbALetter);
1629  		TestCurNext2(ucfWbALetter, ucfWbMidLetter, ucfWbALetter);
1630  		TestPrevCurNext(ucfWbALetter, ucfWbMidLetter, ucfWbALetter);
1631  		TestCurNext(ucfWbNumeric, ucfWbNumeric);
1632  		TestCurNext(ucfWbALetter, ucfWbNumeric);
1633  		TestCurNext(ucfWbNumeric, ucfWbALetter);
1634  		TestPrevCurNext(ucfWbNumeric, ucfWbMidNum, ucfWbNumeric);
1635  		TestCurNext2(ucfWbNumeric, ucfWbMidNum, ucfWbNumeric);
1636  		TestCurNext(ucfWbKatakana, ucfWbKatakana);
1637  		if ((wbfCur & (ucfWbALetter | ucfWbNumeric | ucfWbKatakana | ucfWbExtendNumLet)) != 0 &&
1638  			(wbfNext & ucfWbExtendNumLet) == ucfWbExtendNumLet) continue;
1639  		if ((wbfCur & ucfWbExtendNumLet) == ucfWbExtendNumLet &&
1640  			(wbfNext & (ucfWbALetter | ucfWbNumeric | ucfWbKatakana)) != 0) continue;
1641  		position = posNext; return true;
1642  #undef TestCurNext
1643  #undef TestCurNext2
1644  #undef TestPrevCurNext
1645  	}
1646  	IAssert(position == srcEnd);
1647  	return true;
1648  }
1649  template<typename TSrcVec>
1650  void TUniChDb::FindWordBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const
1651  {
1652  	if (size_t(dest.Len()) != srcCount + 1) dest.Gen(TVecIdx(srcCount + 1));
1653  	dest.PutAll(false);
1654  	size_t position = srcIdx;
1655  	dest[TVecIdx(position - srcIdx)] = true;
1656  	while (position < srcIdx + srcCount)
1657  	{
1658  		size_t oldPos = position;
1659  		FindNextWordBoundary(src, srcIdx, srcCount, position);
1660      if (oldPos >= position) {
1661  		  Assert(oldPos < position);
1662      }
1663      Assert(position <= srcIdx + srcCount);
1664  		dest[TVecIdx(position - srcIdx)] = true;
1665  	}
1666  	Assert(dest[TVecIdx(srcCount)]);
1667  }
1668  template<typename TSrcVec>
1669  bool TUniChDb::CanSentenceEndHere(const TSrcVec& src, const size_t srcIdx, const size_t position) const
1670  {
1671  	if (sbExTrie.Empty()) return true;
1672  	size_t pos = position;
1673  	if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1674  	int c = (int) src[TVecIdx(pos)]; int sfb = GetSbFlags(c);
1675  	if ((c & ucfSbSep) == ucfSbSep) {
1676  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1677  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1678  	while ((sfb & ucfSbSp) == ucfSbSp) {
1679  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1680  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1681  	while ((sfb & ucfSbSp) == ucfSbSp) {
1682  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1683  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1684  	while ((sfb & (ucfSbATerm | ucfSbSTerm)) != 0) {
1685  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1686  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1687  	int cLast = c, cButLast = -1, cButButLast = -1, len = 1, node = -1;
1688  	while (true)
1689  	{
1690  		bool atEnd = (! WbFindPrevNonIgnored(src, srcIdx, pos));
1691  		c = (atEnd ? -1 : (int) src[TVecIdx(pos)]);
1692  		TUniChCategory cat = GetCat(c);
1693  		if (atEnd || ! (cat == ucLetter || cat == ucNumber || cat == ucSymbol)) {
1694  			if (len == 1) return ! sbExTrie.Has1Gram(cLast);
1695  			if (len == 2) return ! sbExTrie.Has2Gram(cLast, cButLast);
1696  			IAssert(len >= 3); IAssert(node >= 0);
1697  			if (sbExTrie.IsNodeTerminal(node)) return false;
1698  			if (atEnd) return true; }
1699  		if (len == 1) { cButLast = c; len++; }
1700  		else if (len == 2) { cButButLast = c; len++;
1701  			node = sbExTrie.Get3GramRoot(cLast, cButLast, cButButLast);
1702  			if (node < 0) return true; }
1703  		else {
1704  			node = sbExTrie.GetChild(node, c);
1705  			if (node < 0) return true; }
1706  	}
1707  }
1708  template<typename TSrcVec>
1709  bool TUniChDb::FindNextSentenceBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const
1710  {
1711  	if (position < srcIdx) { position = srcIdx; return true; }
1712  	const size_t srcEnd = srcIdx + srcCount;
1713  	if (position >= srcEnd) return false;
1714  	size_t origPos = position;
1715  	if (IsWbIgnored(src[TVecIdx(position)])) {
1716  		if (! WbFindPrevNonIgnored(src, srcIdx, position))
1717  			position = origPos;
1718  	}
1719  	size_t posPrev = position;
1720  	if (! WbFindPrevNonIgnored(src, srcIdx, posPrev)) posPrev = position;
1721  	if (position == origPos && position + 1 < srcEnd && IsSbSep(src[TVecIdx(position)]) && IsWbIgnored(src[TVecIdx(position + 1)])) { position += 1; return true; }
1722  	size_t posNext = position; WbFindNextNonIgnored(src, posNext, srcEnd);
1723  	size_t posNext2;
1724  	int cPrev = (posPrev < position ? (int) src[TVecIdx(posPrev)] : -1), cCur = (position < srcEnd ? (int) src[TVecIdx(position)] : -1);
1725  	int cNext = (position < posNext && posNext < srcEnd ? (int) src[TVecIdx(posNext)] : -1);
1726  	int sbfPrev = GetSbFlags(cPrev), sbfCur = GetSbFlags(cCur), sbfNext = GetSbFlags(cNext);
1727  	int cNext2, sbfNext2;
1728  	typedef enum { stInit, stATerm, stATermSp, stATermSep, stSTerm, stSTermSp, stSTermSep } TPeekBackState;
1729  	TPeekBackState backState;
1730  	{
1731  		size_t pos = position;
1732  		bool wasSep = false, wasSp = false, wasATerm = false, wasSTerm = false;
1733  		while (true)
1734  		{
1735  			if (! WbFindPrevNonIgnored(src, srcIdx, pos)) break;
1736  			int cp = (int) src[TVecIdx(pos)]; int sbf = GetSbFlags(cp);
1737  			if ((sbf & ucfSbSep) == ucfSbSep) {
1738  				wasSep = true;
1739  				if (! WbFindPrevNonIgnored(src, srcIdx, pos)) break;
1740  				cp = (int) src[TVecIdx(pos)]; sbf = GetSbFlags(cp); }
1741  			bool stop = false;
1742  			while ((sbf & ucfSbSp) == ucfSbSp) {
1743  				wasSp = true;
1744  				if (! WbFindPrevNonIgnored(src, srcIdx, pos)) { stop = true; break; }
1745  				cp = (int) src[TVecIdx(pos)]; sbf = GetSbFlags(cp); }
1746  			if (stop) break;
1747  			while ((sbf & ucfSbClose) == ucfSbClose) {
1748  				if (! WbFindPrevNonIgnored(src, srcIdx, pos)) { stop = true; break; }
1749  				cp = (int) src[TVecIdx(pos)]; sbf = GetSbFlags(cp); }
1750  			if (stop) break;
1751  			wasATerm = ((sbf & ucfSbATerm) == ucfSbATerm);
1752  			wasSTerm = ((sbf & ucfSbSTerm) == ucfSbSTerm);
1753  			break;
1754  		}
1755  		if (wasATerm) backState = (wasSep ? stATermSep : wasSp ? stATermSp : stATerm);
1756  		else if (wasSTerm) backState = (wasSep ? stSTermSep : wasSp ? stSTermSp : stSTerm);
1757  		else backState = stInit;
1758  	}
1759  	typedef enum { stUnknown, stLower, stNotLower } TPeekAheadState;
1760  	TPeekAheadState aheadState = stUnknown;
1761  	for ( ; position < srcEnd; posPrev = position, position = posNext, posNext = posNext2,
1762  							   cPrev = cCur, cCur = cNext, cNext = cNext2,
1763  							   sbfPrev = sbfCur, sbfCur = sbfNext, sbfNext = sbfNext2)
1764  	{
1765  		posNext2 = posNext; WbFindNextNonIgnored(src, posNext2, srcEnd);
1766  		cNext2 = (posNext < posNext2 && posNext2 < srcEnd ? (int) src[TVecIdx(posNext2)] : -1);
1767  		sbfNext2 = GetSbFlags(cNext2);
1768  #define TestCur(curFlag) ((sbfCur & ucfSb##curFlag) == ucfSb##curFlag)
1769  #define Trans(curFlag, newState) if (TestCur(curFlag)) { backState = st##newState; break; }
1770  		switch (backState) {
1771  			case stInit: Trans(ATerm, ATerm); Trans(STerm, STerm); break;
1772  			case stATerm: Trans(Sp, ATermSp); Trans(Sep, ATermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); Trans(Close, ATerm); backState = stInit; break;
1773  			case stSTerm: Trans(Sp, STermSp); Trans(Sep, STermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); Trans(Close, STerm); backState = stInit; break;
1774  			case stATermSp: Trans(Sp, ATermSp); Trans(Sep, ATermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1775  			case stSTermSp: Trans(Sp, STermSp); Trans(Sep, STermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1776  			case stATermSep: Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1777  			case stSTermSep: Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1778  			default: IAssert(false); }
1779  #undef Trans
1780  #undef TestCur
1781  #define IsPeekAheadSkippable(sbf) ((sbf & (ucfSbOLetter | ucfSbUpper | ucfSbLower | ucfSbSep | ucfSbSTerm | ucfSbATerm)) == 0)
1782  		if (! IsPeekAheadSkippable(sbfCur)) {
1783  			bool isLower = ((sbfCur & ucfSbLower) == ucfSbLower);
1784  			if (aheadState == stLower) IAssert(isLower);
1785  			else if (aheadState == stNotLower) IAssert(! isLower);
1786  			aheadState = stUnknown; }
1787  		if (aheadState == stUnknown)
1788  		{
1789  			size_t pos = posNext;
1790  			while (pos < srcEnd) {
1791  				int cp = (int) src[TVecIdx(pos)]; int sbf = GetSbFlags(cp);
1792  				if (! IsPeekAheadSkippable(sbf)) {
1793  					if ((sbf & ucfSbLower) == ucfSbLower) aheadState = stLower;
1794  					else aheadState = stNotLower;
1795  					break; }
1796  				WbFindNextNonIgnored(src, pos, srcEnd); }
1797  			if (! (pos < srcEnd)) aheadState = stNotLower;
1798  		}
1799  #undef IsPeekAheadSkippable
1800  #define TestCurNext(curFlag, nextFlag) if ((sbfCur & curFlag) == curFlag && (sbfNext & nextFlag) == nextFlag) continue
1801  #define TestCurNext2(curFlag, nextFlag, next2Flag) if ((sbfCur & curFlag) == curFlag && (sbfNext & nextFlag) == nextFlag && (sbfNext2 & next2Flag) == next2Flag) continue
1802  #define TestPrevCurNext(prevFlag, curFlag, nextFlag) if ((sbfPrev & prevFlag) == prevFlag && (sbfCur & curFlag) == curFlag && (sbfNext & nextFlag) == nextFlag) continue
1803  		if (cCur == 13 && cNext == 10) continue;
1804  		if ((sbfCur & ucfSbSep) == ucfSbSep) {
1805  			if (! CanSentenceEndHere(src, srcIdx, position)) continue;
1806  			position = posNext; return true; }
1807  		TestCurNext(ucfSbATerm, ucfSbNumeric); 
1808  		TestPrevCurNext(ucfSbUpper, ucfSbATerm, ucfSbUpper); 
1809  		if ((backState == stATerm || backState == stATermSp || backState == stSTerm || backState == stSTermSp) &&
1810  			(sbfNext & (ucfSbSTerm | ucfSbATerm)) != 0) continue;
1811  		if ((backState == stATerm || backState == stATermSp) && aheadState == stLower) continue;
1812  		if ((backState == stATerm || backState == stSTerm) && (sbfNext & (ucfSbClose | ucfSbSp | ucfSbSep)) != 0) continue;
1813  		if (backState == stATerm || backState == stATermSp || backState == stATermSep || backState == stSTerm || backState == stSTermSp || backState == stSTermSep) {
1814  			if ((sbfNext & (ucfSbSp | ucfSbSep)) != 0) continue; 
1815  			if (! CanSentenceEndHere(src, srcIdx, position)) continue;
1816  			position = posNext; return true; } 
1817  		continue;
1818  #undef TestCurNext
1819  #undef TestCurNext2
1820  #undef TestPrevCurNext
1821  	}
1822  	IAssert(position == srcEnd);
1823  	return true;
1824  }
1825  template<typename TSrcVec>
1826  void TUniChDb::FindSentenceBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const
1827  {
1828  	if (size_t(dest.Len()) != srcCount + 1) dest.Gen(TVecIdx(srcCount + 1));
1829  	dest.PutAll(false);
1830  	size_t position = srcIdx;
1831  	dest[TVecIdx(position - srcIdx)] = true;
1832  	while (position < srcIdx + srcCount)
1833  	{
1834  		size_t oldPos = position;
1835  		FindNextSentenceBoundary(src, srcIdx, srcCount, position);
1836      if (oldPos >= position) {
1837  		  Assert(oldPos < position);
1838      }
1839      Assert(position <= srcIdx + srcCount);
1840  		dest[TVecIdx(position - srcIdx)] = true;
1841  	}
1842  	Assert(dest[TVecIdx(srcCount)]);
1843  }
1844  template<typename TSrcVec, typename TDestCh>
1845  void TUniChDb::GetCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1846  								TVec<TDestCh>& dest, const bool clrDest,
1847  								const TUniChDb::TCaseConversion how,
1848  								const bool turkic, const bool lithuanian) const
1849  {
1850  	const TIntIntVH &specials = (how == ccUpper ? specialCasingUpper : how == ccLower ? specialCasingLower : how == ccTitle ? specialCasingTitle : *((TIntIntVH *) 0));
1851  	if (clrDest) dest.Clr();
1852  	enum {
1853  		GreekCapitalLetterSigma = 0x3a3,
1854  		GreekSmallLetterSigma = 0x3c3,
1855  		GreekSmallLetterFinalSigma = 0x3c2,
1856  		LatinCapitalLetterI = 0x49,
1857  		LatinCapitalLetterJ = 0x4a,
1858  		LatinCapitalLetterIWithOgonek = 0x12e,
1859  		LatinCapitalLetterIWithGrave = 0xcc,
1860  		LatinCapitalLetterIWithAcute = 0xcd,
1861  		LatinCapitalLetterIWithTilde = 0x128,
1862  		LatinCapitalLetterIWithDotAbove = 0x130,
1863  		LatinSmallLetterI = 0x69,
1864  		CombiningDotAbove = 0x307
1865  	};
1866  	bool seenCased = false, seenTwoCased = false; int cpFirstCased = -1;
1867  	size_t nextWordBoundary = srcIdx;
1868  	TBoolV wordBoundaries; bool wbsKnown = false;
1869  	for (const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount; srcIdx < srcEnd; )
1870  	{
1871  		int cp = src[TVecIdx(srcIdx)]; srcIdx++;
1872  		TUniChDb::TCaseConversion howHere;
1873  		if (how != ccTitle) howHere = how;
1874  		else {
1875  			if (srcIdx - 1 == nextWordBoundary) { 
1876  				seenCased = false; seenTwoCased = false; cpFirstCased = -1;
1877  				size_t next = nextWordBoundary; FindNextWordBoundary(src, origSrcIdx, srcCount, next);
1878  				IAssert(next > nextWordBoundary); nextWordBoundary = next; }
1879  			bool isCased = IsCased(cp);
1880  			if (isCased && ! seenCased) { howHere = ccTitle; seenCased = true; cpFirstCased = cp; }
1881  			else { howHere = ccLower;
1882  				if (isCased && seenCased) seenTwoCased = true; }
1883  		}
1884  		if (cp == GreekCapitalLetterSigma && howHere == ccLower)
1885  		{
1886  			if (! wbsKnown) { FindWordBoundaries(src, origSrcIdx, srcCount, wordBoundaries); wbsKnown = true; }
1887  			size_t srcIdx2 = srcIdx; bool casedAfter = false;
1888  			if (how == ccTitle)
1889  				printf("!");
1890  			while (! wordBoundaries[TVecIdx(srcIdx2 - origSrcIdx)])
1891  			{
1892  				int cp2 = src[TVecIdx(srcIdx2)]; srcIdx2++;
1893  				if (IsCased(cp2)) { casedAfter = true; break; }
1894  			}
1895  			if (! casedAfter)
1896  			{
1897  				srcIdx2 = srcIdx - 1; bool casedBefore = false;
1898  				while (! wordBoundaries[TVecIdx(srcIdx2 - origSrcIdx)])
1899  				{
1900  					--srcIdx2; int cp2 = src[TVecIdx(srcIdx2)];
1901  					if (IsCased(cp2)) { casedBefore = true; break; }
1902  				}
1903  				if (casedBefore) {
1904  					dest.Add(GreekSmallLetterFinalSigma); Assert(howHere == ccLower); continue; }
1905  			}
1906  			dest.Add(GreekSmallLetterSigma); continue;
1907  		}
1908  		else if (lithuanian)
1909  		{
1910  			if (howHere == ccLower)
1911  			{
1912  				if (cp == LatinCapitalLetterI || cp == LatinCapitalLetterJ || cp == LatinCapitalLetterIWithOgonek)
1913  				{
1914  					bool moreAbove = false;
1915  					for (size_t srcIdx2 = srcIdx; srcIdx2 < srcEnd; )
1916  					{
1917  						const int cp2 = src[TVecIdx(srcIdx2)]; srcIdx2++;
1918  						const int cc2 = GetCombiningClass(cp2);
1919  						if (cc2 == TUniChInfo::ccStarter) break;
1920  						if (cc2 == TUniChInfo::ccAbove) { moreAbove = true; break; }
1921  					}
1922  					if (moreAbove)
1923  					{
1924  						if (cp == LatinCapitalLetterI) { dest.Add(0x69); dest.Add(0x307); continue; }
1925  						if (cp == LatinCapitalLetterJ) { dest.Add(0x6a); dest.Add(0x307); continue; }
1926  						if (cp == LatinCapitalLetterIWithOgonek) { dest.Add(0x12f); dest.Add(0x307); continue; }
1927  					}
1928  				}
1929  				else if (cp == LatinCapitalLetterIWithGrave) { dest.Add(0x69); dest.Add(0x307); dest.Add(0x300); continue; }
1930  				else if (cp == LatinCapitalLetterIWithAcute) { dest.Add(0x69); dest.Add(0x307); dest.Add(0x301); continue; }
1931  				else if (cp == LatinCapitalLetterIWithTilde) { dest.Add(0x69); dest.Add(0x307); dest.Add(0x303); continue; }
1932  			}
1933  			if (cp == CombiningDotAbove)
1934  			{
1935  				bool afterSoftDotted = false;
1936  				size_t srcIdx2 = srcIdx - 1; 
1937  				while (origSrcIdx < srcIdx2)
1938  				{
1939  					--srcIdx2; int cp2 = src[TVecIdx(srcIdx2)];
1940  					int cc2 = GetCombiningClass(cp2);
1941  					if (cc2 == TUniChInfo::ccAbove) break;
1942  					if (cc2 == TUniChInfo::ccStarter) {
1943  						afterSoftDotted = IsSoftDotted(cp2); break; }
1944  				}
1945  				if (afterSoftDotted)
1946  				{
1947  					Assert(lithuanian);
1948  					if (how == ccLower) { dest.Add(0x307); continue; }
1949  					if (how == ccUpper) continue;
1950  					Assert(how == ccTitle);
1951  					Assert(howHere == ccLower); 
1952  					if (seenCased && ! seenTwoCased) continue; 
1953  					dest.Add(0x307); continue;
1954  				}
1955  			}
1956  		}
1957  		else if (turkic) 
1958  		{
1959  			if (cp == LatinCapitalLetterIWithDotAbove) {
1960  				dest.Add(howHere == ccLower ? 0x69 : 0x130); continue; }
1961  			else if (cp == CombiningDotAbove)
1962  			{
1963  				bool afterI = false;
1964  				size_t srcIdx2 = srcIdx - 1; 
1965  				while (origSrcIdx < srcIdx2)
1966  				{
1967  					--srcIdx2; int cp2 = src[TVecIdx(srcIdx2)];
1968  					if (cp2 == LatinCapitalLetterI) { afterI = true; break; }
1969  					int cc2 = GetCombiningClass(cp2);
1970  					if (cc2 == TUniChInfo::ccAbove || cc2 == TUniChInfo::ccStarter) break;
1971  				}
1972  				if (afterI) {
1973  					if (how == ccTitle && seenCased && ! seenTwoCased) {
1974  						IAssert(cpFirstCased == LatinCapitalLetterI);
1975  						dest.Add(0x307); continue; }
1976  					if (howHere != ccLower) dest.Add(0x307);
1977  					continue; }
1978  			}
1979  			else if (cp == LatinCapitalLetterI)
1980  			{
1981  				bool beforeDot = false;
1982  				for (size_t srcIdx2 = srcIdx; srcIdx2 < srcEnd; )
1983  				{
1984  					const int cp2 = src[TVecIdx(srcIdx2)]; srcIdx2++;
1985  					if (cp2 == 0x307) { beforeDot = true; break; }
1986  					const int cc2 = GetCombiningClass(cp2);
1987  					if (cc2 == TUniChInfo::ccStarter || cc2 == TUniChInfo::ccAbove) break;
1988  				}
1989  				if (! beforeDot) {
1990  					dest.Add(howHere == ccLower ? 0x131 : 0x49); continue; }
1991  			}
1992  			else if (cp == LatinSmallLetterI)
1993  			{
1994  				dest.Add(howHere == ccLower ? 0x69 : 0x130); continue;
1995  			}
1996  		}
1997  		const TIntIntVH &specHere = (
1998  			howHere == how ? specials :
1999  			howHere == ccLower ? specialCasingLower :
2000  			howHere == ccTitle ? specialCasingTitle :
2001  			howHere == ccUpper ? specialCasingUpper : *((TIntIntVH *) 0));
2002  		int i = specHere.GetKeyId(cp);
2003  		if (i >= 0) { TUniCaseFolding::AppendVector(specHere[i], dest); continue; }
2004  		i = h.GetKeyId(cp);
2005  		if (i >= 0) {
2006  			const TUniChInfo &ci = h[i];
2007  			int cpNew = (
2008  				howHere == ccLower ? ci.simpleLowerCaseMapping :
2009  				howHere == ccUpper ? ci.simpleUpperCaseMapping :
2010  									 ci.simpleTitleCaseMapping);
2011  			if (cpNew < 0) cpNew = cp;
2012  			dest.Add(cpNew); continue; }
2013  		dest.Add(cp);
2014  	}
2015  }
2016  template<typename TSrcVec, typename TDestCh>
2017  void TUniChDb::GetSimpleCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2018  	TVec<TDestCh>& dest, const bool clrDest, const TCaseConversion how) const
2019  {
2020  	if (clrDest) dest.Clr();
2021  	bool seenCased = false; size_t nextWordBoundary = srcIdx;
2022  	for (const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount; srcIdx < srcEnd; )
2023  	{
2024  		const int cp = src[TVecIdx(srcIdx)]; srcIdx++;
2025  		int i = h.GetKeyId(cp); if (i < 0) { dest.Add(cp); continue; }
2026  		const TUniChInfo &ci = h[i];
2027  		TUniChDb::TCaseConversion howHere;
2028  		if (how != ccTitle) howHere = how;
2029  		else {
2030  			if (srcIdx - 1 == nextWordBoundary) { 
2031  				seenCased = false;
2032  				size_t next = nextWordBoundary; FindNextWordBoundary(src, origSrcIdx, srcCount, next);
2033  				IAssert(next > nextWordBoundary); nextWordBoundary = next; }
2034  			bool isCased = IsCased(cp);
2035  			if (isCased && ! seenCased) { howHere = ccTitle; seenCased = true; }
2036  			else howHere = ccLower;
2037  		}
2038  		int cpNew = (howHere == ccTitle ? ci.simpleTitleCaseMapping : howHere == ccUpper ? ci.simpleUpperCaseMapping : ci.simpleLowerCaseMapping);
2039  		if (cpNew < 0) cpNew = cp;
2040  		dest.Add(cpNew);
2041  	}
2042  }
2043  template<typename TSrcVec>
2044  void TUniChDb::ToSimpleCaseConverted(TSrcVec& src, size_t srcIdx, const size_t srcCount, const TCaseConversion how) const
2045  {
2046  	bool seenCased = false; size_t nextWordBoundary = srcIdx;
2047  	for (const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++)
2048  	{
2049  		const int cp = src[TVecIdx(srcIdx)];
2050  		int i = h.GetKeyId(cp); if (i < 0) continue;
2051  		const TUniChInfo &ci = h[i];
2052  		TUniChDb::TCaseConversion howHere;
2053  		if (how != ccTitle) howHere = how;
2054  		else {
2055  			if (srcIdx == nextWordBoundary) { 
2056  				seenCased = false;
2057  				size_t next = nextWordBoundary; FindNextWordBoundary(src, origSrcIdx, srcCount, next);
2058  				IAssert(next > nextWordBoundary); nextWordBoundary = next; }
2059  			bool isCased = IsCased(cp);
2060  			if (isCased && ! seenCased) { howHere = ccTitle; seenCased = true; }
2061  			else howHere = ccLower;
2062  		}
2063  		int cpNew = (howHere == ccTitle ? ci.simpleTitleCaseMapping : howHere == ccUpper ? ci.simpleUpperCaseMapping : ci.simpleLowerCaseMapping);
2064  		if (cpNew >= 0) src[TVecIdx(srcIdx)] = cpNew;
2065  	}
2066  }
2067  template<typename TDestCh>
2068  void TUniChDb::AddDecomposition(const int codePoint, TVec<TDestCh>& dest, const bool compatibility) const
2069  {
2070  	if (HangulSBase <= codePoint && codePoint < HangulSBase + HangulSCount)
2071  	{
2072  		const int SIndex = codePoint - HangulSBase;
2073  		const int L = HangulLBase + SIndex / HangulNCount;
2074  		const int V = HangulVBase + (SIndex % HangulNCount) / HangulTCount;
2075  		const int T = HangulTBase + (SIndex % HangulTCount);
2076  		dest.Add(L); dest.Add(V);
2077  		if (T != HangulTBase) dest.Add(T);
2078  		return;
2079  	}
2080  	int i = h.GetKeyId(codePoint); if (i < 0) { dest.Add(codePoint); return; }
2081  	const TUniChInfo &ci = h[i];
2082  	int ofs = ci.decompOffset; if (ofs < 0) { dest.Add(codePoint); return; }
2083  	if ((! compatibility) && ci.IsCompatibilityDecomposition()) { dest.Add(codePoint); return; }
2084  	while (true) {
2085  		int cp = decompositions[ofs++]; if (cp < 0) return;
2086  		AddDecomposition(cp, dest, compatibility); }
2087  }
2088  template<typename TSrcVec, typename TDestCh>
2089  void TUniChDb::Decompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2090  		TVec<TDestCh>& dest, const bool compatibility, bool clrDest) const
2091  {
2092  	if (clrDest) dest.Clr();
2093  	const size_t destStart = dest.Len()&bsol;*, srcEnd = srcIdx + srcCount*/;
2094  	while (srcIdx < srcCount) {
2095  		AddDecomposition(src[TVecIdx(srcIdx)], dest, compatibility); srcIdx++; }
2096  	for (size_t destIdx = destStart, destEnd = dest.Len(); destIdx < destEnd; )
2097  	{
2098  		size_t j = destIdx;
2099  		int cp = dest[TVecIdx(destIdx)]; destIdx++;
2100  		int cpCls = GetCombiningClass(cp);
2101  		if (cpCls == TUniChInfo::ccStarter) continue;
2102  		while (destStart < j && GetCombiningClass(dest[TVecIdx(j - 1)]) > cpCls) {
2103  			dest[TVecIdx(j)] = dest[TVecIdx(j - 1)]; j--; }
2104  		dest[TVecIdx(j)] = cp;
2105  	}
2106  }
2107  template<typename TSrcVec, typename TDestCh>
2108  void TUniChDb::DecomposeAndCompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2109  		TVec<TDestCh>& dest, bool compatibility, bool clrDest) const
2110  {
2111  	if (clrDest) dest.Clr();
2112  	TIntV temp;
2113  	Decompose(src, srcIdx, srcCount, temp, compatibility);
2114  	Compose(temp, 0, temp.Len(), dest, clrDest);
2115  }
2116  template<typename TSrcVec, typename TDestCh>
2117  void TUniChDb::Compose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2118  		TVec<TDestCh>& dest, bool clrDest) const
2119  {
2120  	if (clrDest) dest.Clr();
2121  	bool lastStarterKnown = false; 
2122  	size_t lastStarterPos = size_t(-1);  
2123  	int cpLastStarter = -1; 
2124  	const size_t srcEnd = srcIdx + srcCount;
2125  	int ccMax = -1; 
2126  	while (srcIdx < srcEnd)
2127  	{
2128  		const int cp = src[TVecIdx(srcIdx)]; srcIdx++;
2129  		const int cpClass = GetCombiningClass(cp);
2130  		if (lastStarterKnown && ccMax < cpClass)
2131  		{
2132  			int j = inverseDec.GetKeyId(TIntPr(cpLastStarter, cp));
2133  			int cpCombined = -1;
2134  			do {
2135  				if (j >= 0) { cpCombined = inverseDec[j]; break; }
2136  				const int LIndex = cpLastStarter - HangulLBase;
2137  				if (0 <= LIndex && LIndex < HangulLCount) {
2138  					const int VIndex = cp - HangulVBase;
2139  					if (0 <= VIndex && VIndex < HangulVCount) {
2140  						cpCombined = HangulSBase + (LIndex * HangulVCount + VIndex) * HangulTCount;
2141  						break; } }
2142  				const int SIndex = cpLastStarter - HangulSBase;
2143  				if (0 <= SIndex && SIndex < HangulSCount && (SIndex % HangulTCount) == 0)
2144  				{
2145  					const int TIndex = cp - HangulTBase;
2146  					if (0 <= TIndex && TIndex < HangulTCount) {
2147  						cpCombined = cpLastStarter + TIndex;
2148  						break; }
2149  				}
2150  			} while (false);
2151  			if (cpCombined >= 0) {
2152  				dest[TVecIdx(lastStarterPos)] = cpCombined;
2153  				Assert(GetCombiningClass(cpCombined) == TUniChInfo::ccStarter);
2154  				cpLastStarter = cpCombined; continue; }
2155  		}
2156  		if (cpClass == TUniChInfo::ccStarter) { 
2157  			lastStarterKnown = true; lastStarterPos = dest.Len(); cpLastStarter = cp; ccMax = cpClass - 1; }
2158  		else if (cpClass > ccMax) 
2159  			ccMax = cpClass;
2160  		dest.Add(cp);
2161  	}
2162  }
2163  template<typename TSrcVec, typename TDestCh>
2164  size_t TUniChDb::ExtractStarters(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2165  		TVec<TDestCh>& dest, bool clrDest) const
2166  {
2167  	if (clrDest) dest.Clr();
2168  	size_t retVal = 0;
2169  	for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++) {
2170  		const int cp = src[TVecIdx(srcIdx)];
2171  		if (GetCombiningClass(cp) == TUniChInfo::ccStarter)
2172  			{ dest.Add(cp); retVal++; } }
2173  	return retVal;
2174  }
2175  inline bool AlwaysFalse()
2176  {
2177  	int sum = 0;
2178  	for (int i = 0; i < 5; i++) sum += i;
2179  	return sum > 100;
2180  }
2181  inline bool AlwaysTrue()
2182  {
2183  	int sum = 0;
2184  	for (int i = 0; i < 5; i++) sum += i;
2185  	return sum < 100;
2186  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-bbox_util.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.h</div>
                </div>
                <div class="column column_space"><pre><code>1673      const map<int, vector<int> >& match_indices = all_match_indices[i];
1674      for (int p = 0; p < num_preds_per_class; ++p) {
1675        int start_idx = p * num_classes;
</pre></code></div>
                <div class="column column_space"><pre><code>382  		int nDecoded = 0;
383  		for (int c = 0; c <= 255; c++) {
384  			int cu = TEncoding::ToUnicode(c); if (cu == -1) continue;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    