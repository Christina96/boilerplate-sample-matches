
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.921037124337065%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ontolight.cpp</h3>
            <pre><code>1  void TLwLangBs::SaveTxt(FILE* fOut){
2    fprintf(fOut, "===LwLangBs-Begin====================\n");
3    for (int LangN=0; LangN<GetLangs(); LangN++){
4      int LangId=GetLangId(LangN);
5      fprintf(fOut, "N:%d Id:%d Nm:'%s' Desc:'%s'\n",
6       LangN, LangId, GetLangNm(LangId).CStr(), GetLangDesc(LangId).CStr());
7    }
8    fprintf(fOut, "===LwLangBs-End======================\n");
9  }
10  void TLwTermType::SaveTxt(FILE* fOut){
11    fprintf(fOut, "Id:%d Nm:'%s' LangId:%d Desc:'%s'\n",
12      GetTermTypeId(), GetTermTypeNm().CStr(), GetLangId(), GetDescStr().CStr());
13  }
14  void TLwTerm::SaveTxt(FILE* fOut){
15    fprintf(fOut, "Id:%d Nm:'%s' LangId:%d TermTypeId:%d Desc:'%s'\n",
16     GetTermId(), GetTermNm().CStr(), GetLangId(), GetTermTypeId(), GetDescStr().CStr());
17  }
18  int TLwTermTypeBs::AddTermType(const PLwTermType& LwTermType){
19    IAssert(!IsTermTypeId(LwTermType->GetTermTypeId()));
20    IdToTermTypeVH.AddDat(LwTermType->GetTermTypeId()).Add(LwTermType);
21    TStrIntPr TermTypeNmLangIdPr=
22     TStrIntPr(LwTermType->GetTermTypeNm(), LwTermType->GetLangId());
23    TermTypeNmLangIdToIdH.AddDat(TermTypeNmLangIdPr, LwTermType->GetTermTypeId());
24    return LwTermType->GetTermTypeId();
25  }
26  void TLwTermTypeBs::SaveTxt(FILE* fOut){
27    fprintf(fOut, "===LwTermTypeBs-Begin================\n");
28    for (int TermTypeN=0; TermTypeN<GetTermTypes(); TermTypeN++){
29      fprintf(fOut, "N:%d ", TermTypeN);
30      GetTermType(GetTermTypeId(TermTypeN))->SaveTxt(fOut);
31    }
32    fprintf(fOut, "===LwTermTypeBs-End==================\n");
33  }
34  void TLwTermBs::AddTerm(const PLwTerm& Term){
35    IAssert(Onto->GetLangBs()->IsLangId(Term->GetLangId()));
36    if (Term->GetTermId()>MxTermId){MxTermId=Term->GetTermId();}
37    IdToTermVH.AddDat(Term->GetTermId()).Add(Term);
38    TermNmLangIdToToTermIdH.AddDat(
39     TStrIntPr(Term->GetTermNm(), Term->GetLangId()), Term->GetTermId());
40  }
41  int TLwTermBs::AddTermGetTermId(const PLwTerm& Term){
42    IAssert(Term->GetTermId()==-1);
43    Term->PutTermId(MxTermId+1);
44    AddTerm(Term);
45    return Term->GetTermId();
46  }
47  PLwTerm TLwTermBs::GetTerm(const int& TermId){
48    TLwTermV TermV=IdToTermVH.GetDat(TermId);
49    if (Onto->GetLangBs()->IsLangNm("EN")){
50      int EnLangId=Onto->GetLangBs()->GetLangId("EN");
51      for (int TermN=0; TermN<TermV.Len(); TermN++){
52        if (TermV[TermN]->GetLangId()==EnLangId){return TermV[TermN];}
53      }
54    }
55    return TermV[0];
56  }
57  void TLwTermBs::SaveTxt(FILE* fOut){
58    fprintf(fOut, "===LwTermBs-Begin====================\n");
59    for (int TermN=0; TermN<GetTerms(); TermN++){
60      TLwTermV TermV; GetTermV(GetTermId(TermN), TermV);
61      for (int SubTermN=0; SubTermN<TermV.Len(); SubTermN++){
62        if (TermV.Len()==1){fprintf(fOut, "N:%d ", TermN);}
63        else {fprintf(fOut, "N:%d/%d ", TermN, SubTermN);}
64        TermV[SubTermN]->SaveTxt(fOut);
65      }
66      Onto->GetLinkBs()->SaveTxt(fOut, GetTermId(TermN), "   ");
67    }
68    fprintf(fOut, "===LwTermBs-End======================\n");
69  }
70  void TLwLinkType::SaveTxt(FILE* fOut){
71    fprintf(fOut, "Id:%d Nm:'%s' LangId:%d SDesc:'%s' Desc:'%s' RevLinkTypeId:%d ParentLinkTypeId:%d\n",
72     GetLinkTypeId(), GetLinkTypeNm().CStr(), GetLangId(),
73     GetSDescStr().CStr(), GetDescStr().CStr(),
74     GetReverseLinkTypeId(), GetParentLinkTypeId());
75  }
76  void TLwLinkTypeBs::AddLinkType(const PLwLinkType& LwLinkType){
77    IdToLinkTypeVH.AddDat(LwLinkType->GetLinkTypeId()).Add(LwLinkType);
78    TStrIntPr LinkTypeNmLangIdPr(LwLinkType->GetLinkTypeNm(), LwLinkType->GetLangId());
79    IAssert(!LinkTypeNmLangIdToIdH.IsKey(LinkTypeNmLangIdPr));
80    LinkTypeNmLangIdToIdH.AddDat(LinkTypeNmLangIdPr, LwLinkType->GetLinkTypeId());
81  }
82  void TLwLinkTypeBs::SaveTxt(FILE* fOut){
83    fprintf(fOut, "===LwLinkTypeBs-Begin================\n");
84    for (int LinkTypeN=0; LinkTypeN<GetLinkTypes(); LinkTypeN++){
85      fprintf(fOut, "N:%d ", LinkTypeN);
86      GetLinkType(GetLinkTypeId(LinkTypeN))->SaveTxt(fOut);
87    }
88    fprintf(fOut, "===LwLinkTypeBs-End==================\n");
89  }
90  int TLwLinkBs::GetLinks() const {
91    int Links=0;
92    int TermIds=FromTermIdToLinkTypeIdTermIdPrVH.Len();
93    for (int TermIdN=0; TermIdN<TermIds; TermIdN++){
94      Links+=FromTermIdToLinkTypeIdTermIdPrVH[TermIdN].Len();}
95    return Links;
96  }
97  void TLwLinkBs::AddLink(const int TermId1, int LinkTypeId, int TermId2){
98    IAssert(Onto->GetTermBs()->IsTermId(TermId1));
99    IAssert(Onto->GetLinkTypeBs()->IsLinkTypeId(LinkTypeId));
100    IAssert(Onto->GetTermBs()->IsTermId(TermId2));
101    FromTermIdToLinkTypeIdTermIdPrVH.AddDat(TermId1).Add(TIntPr(LinkTypeId, TermId2));
102    IntoTermIdToLinkTypeIdTermIdPrVH.AddDat(TermId2).Add(TIntPr(LinkTypeId, TermId1));
103  }
104  int TLwLinkBs::GetFromLinks(const int SrcTermId) const {
105    if (FromTermIdToLinkTypeIdTermIdPrVH.IsKey(SrcTermId)){
106      return FromTermIdToLinkTypeIdTermIdPrVH.GetDat(SrcTermId).Len();
107    } else {return 0;}
108  }
109  void TLwLinkBs::GetFromLink(
110   const int SrcTermId, const int& LinkN, int& LinkTypeId, int& DstTermId){
111    TIntPr& LinkTypeIdDstTermIdPr=
112     FromTermIdToLinkTypeIdTermIdPrVH.GetDat(SrcTermId)[LinkN];
113    LinkTypeId=LinkTypeIdDstTermIdPr.Val1;
114    DstTermId=LinkTypeIdDstTermIdPr.Val2;
115  }
116  int TLwLinkBs::GetIntoLinks(const int DstTermId) const {
117    if (IntoTermIdToLinkTypeIdTermIdPrVH.IsKey(DstTermId)){
118      return IntoTermIdToLinkTypeIdTermIdPrVH.GetDat(DstTermId).Len();
119    } else {return 0;}
120  }
121  void TLwLinkBs::GetIntoLink(
122   const int DstTermId, const int& LinkN, int& LinkTypeId, int& SrcTermId){
123    TIntPr& LinkTypeIdSrcTermIdPr=
124     IntoTermIdToLinkTypeIdTermIdPrVH.GetDat(DstTermId)[LinkN];
125    LinkTypeId=LinkTypeIdSrcTermIdPr.Val1;
126    SrcTermId=LinkTypeIdSrcTermIdPr.Val2;
127  }
128  void TLwLinkBs::SaveTxt(FILE* fOut, const int& TermId, const TStr& IndentStr){
129    for (int LinkN=0; LinkN<GetFromLinks(TermId); LinkN++){
130      int LinkTypeId; int DstTermId;
131      GetFromLink(TermId, LinkN, LinkTypeId, DstTermId);
132      TStr LinkTypeNm=Onto->GetLinkTypeBs()->GetLinkType(LinkTypeId)->GetLinkTypeNm();
133      TStr DstTermNm=Onto->GetTermBs()->GetTerm(DstTermId)->GetTermNm();
134      fprintf(fOut, "%s-->%s--> DstTermId:%d DstTermNm:'%s'\n", IndentStr.CStr(),
135       LinkTypeNm.CStr(), DstTermId, DstTermNm.CStr());
136    }
137    for (int LinkN=0; LinkN<GetIntoLinks(TermId); LinkN++){
138      int LinkTypeId; int SrcTermId;
139      GetIntoLink(TermId, LinkN, LinkTypeId, SrcTermId);
140      TStr LinkTypeNm=Onto->GetLinkTypeBs()->GetLinkType(LinkTypeId)->GetLinkTypeNm();
141      TStr SrcTermNm=Onto->GetTermBs()->GetTerm(SrcTermId)->GetTermNm();
142      fprintf(fOut, "%s<--%s<-- SrcTermId:%d SrcTermNm:'%s'\n", IndentStr.CStr(),
143       LinkTypeNm.CStr(), SrcTermId, SrcTermNm.CStr());
144    }
145  }
146  void TLwOnto::SaveTxt(const TStr& FNm){
147    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
148    fprintf(fOut, "===LwOnto-Begin======================\n");
149    GetLangBs()->SaveTxt(fOut);
150    fprintf(fOut, "\n");
151    GetTermTypeBs()->SaveTxt(fOut);
152    fprintf(fOut, "\n");
153    GetLinkTypeBs()->SaveTxt(fOut);
154    fprintf(fOut, "\n");
155    GetTermBs()->SaveTxt(fOut);
156    fprintf(fOut, "===LwOnto-End========================\n");
157  }
158  PLwOnto TLwOnto::LoadAgroVoc(const TStr& FPath){
159    TStr NrFPath=TStr::GetNrFPath(FPath);
160    PLwOnto LwOnto=TLwOnto::New();
161    {TStr AvLangFNm=NrFPath+"language.txt";
162    printf("Loading '%s' ...", AvLangFNm.CStr());
163    PSs AvLangSs=TSs::LoadTxt(ssfCommaSep, AvLangFNm);
164    int AvLangSs_LangNmFldN=AvLangSs->GetFldX("languagecode");
165    int AvLangSs_LangDescFldN=AvLangSs->GetFldX("name");
166    for (int Y=1; Y<AvLangSs->GetYLen(); Y++){
167      TStr LangNm=AvLangSs->GetVal(AvLangSs_LangNmFldN, Y);
168      TStr LangDesc=AvLangSs->GetVal(AvLangSs_LangDescFldN, Y);
169      LwOnto->GetLangBs()->AddLang(LangNm, LangDesc);
170    }
171    printf(" Done. (%d)\n", AvLangSs->GetYLen()-1);}
172    {TStr AvTermFNm=NrFPath+"agrovocterm.txt";
173    printf("Loading '%s' ...", AvTermFNm.CStr());
174    PSs AvTermSs=TSs::LoadTxt(ssfCommaSep, AvTermFNm);
175    int AvTermSs_TermIdFldN=AvTermSs->GetFldX("termcode");
176    int AvTermSs_LangNmFldN=AvTermSs->GetFldX("languagecode");
177    int AvTermSs_TermSpellFldN=AvTermSs->GetFldX("termspell");
178    for (int Y=1; Y<AvTermSs->GetYLen(); Y++){
179      int TermId=AvTermSs->GetVal(AvTermSs_TermIdFldN, Y).GetInt();
180      TStr LangNm=AvTermSs->GetVal(AvTermSs_LangNmFldN, Y);
181      TStr TermNm=AvTermSs->GetVal(AvTermSs_TermSpellFldN, Y);
182      int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
183      PLwTerm Term=TLwTerm::New(TermId, TermNm, LangId);
184      LwOnto->GetTermBs()->AddTerm(Term);
185    }
186    printf(" Done. (%d)\n", AvTermSs->GetYLen()-1);}
187    {TStr AvLinkTypeFNm=NrFPath+"linktype.txt";
188    printf("Loading '%s' ...", AvLinkTypeFNm.CStr());
189    PSs AvLinkTypeSs=TSs::LoadTxt(ssfCommaSep, AvLinkTypeFNm);
190    int AvLinkTypeSs_LinkTypeIdFldN=AvLinkTypeSs->GetFldX("linktypeid");
191    int AvLinkTypeSs_LangIdFldN=AvLinkTypeSs->GetFldX("languagecode");
192    int AvLinkTypeSs_LinkSDescFldN=AvLinkTypeSs->GetFldX("linkdesc");
193    int AvLinkTypeSs_LinkNmFldN=AvLinkTypeSs->GetFldX("linkabr");
194    int AvLinkTypeSs_LinkDescFldN=AvLinkTypeSs->GetFldX("linkdescription");
195    int AvLinkTypeSs_ReverseLinkIdFldN=AvLinkTypeSs->GetFldX("rlinkcode");
196    int AvLinkTypeSs_ParentLinkTypeIdFldN=AvLinkTypeSs->GetFldX("parentlinktypeid");
197    for (int Y=1; Y<AvLinkTypeSs->GetYLen(); Y++){
198      int LinkTypeId=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkTypeIdFldN, Y).GetInt();
199      TStr LinkTypeNm=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkNmFldN, Y);
200      TStr LangNm=AvLinkTypeSs->GetVal(AvLinkTypeSs_LangIdFldN, Y);
201      TStr SDescStr=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkSDescFldN, Y);
202      TStr DescStr=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkDescFldN, Y);
203      int ReverseLinkTypeId=AvLinkTypeSs->GetVal(AvLinkTypeSs_ReverseLinkIdFldN, Y).GetInt(-1);
204      int ParentLinkTypeId=AvLinkTypeSs->GetVal(AvLinkTypeSs_ParentLinkTypeIdFldN, Y).GetInt(-1);
205      int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
206      PLwLinkType LwLinkType=TLwLinkType::New();
207      LwLinkType->PutLinkTypeId(LinkTypeId);
208      LwLinkType->PutLinkTypeNm(LinkTypeNm);
209      LwLinkType->PutLangId(LangId);
210      LwLinkType->PutSDescStr(SDescStr);
211      LwLinkType->PutDescStr(DescStr);
212      LwLinkType->PutReverseLinkTypeId(ReverseLinkTypeId);
213      LwLinkType->PutParentLinkTypeId(ParentLinkTypeId);
214      LwOnto->GetLinkTypeBs()->AddLinkType(LwLinkType);
215    }
216    printf(" Done. (%d)\n", AvLinkTypeSs->GetYLen()-1);}
217    {TStr AvTermLinkFNm=NrFPath+"termlink.txt";
218    printf("Loading '%s' ...", AvTermLinkFNm.CStr());
219    PSs AvTermLinkSs=TSs::LoadTxt(ssfCommaSep, AvTermLinkFNm);
220    int AvTermLinkSs_TermId1FldN=AvTermLinkSs->GetFldX("termcode1");
221    int AvTermLinkSs_TermId2FldN=AvTermLinkSs->GetFldX("termcode2");
222    int AvTermLinkSs_LinkTypeIdFldN=AvTermLinkSs->GetFldX("linktypeid");
223    for (int Y=1; Y<AvTermLinkSs->GetYLen(); Y++){
224      int TermId1=AvTermLinkSs->GetVal(AvTermLinkSs_TermId1FldN, Y).GetInt();
225      int TermId2=AvTermLinkSs->GetVal(AvTermLinkSs_TermId2FldN, Y).GetInt();
226      int LinkTypeId=AvTermLinkSs->GetVal(AvTermLinkSs_LinkTypeIdFldN, Y).GetInt();
227      if (!LwOnto->GetTermBs()->IsTermId(TermId1)){printf("#"); continue;}
228      if (!LwOnto->GetTermBs()->IsTermId(TermId2)){printf("*"); continue;}
229      LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
230    }
231    printf(" Done. (%d)\n", AvTermLinkSs->GetYLen()-1);}
232    return LwOnto;
233  }
234  PLwOnto TLwOnto::LoadEuroVoc(const TStr& FPath){
235    TStr NrFPath=TStr::GetNrFPath(FPath);
236    PLwOnto LwOnto=TLwOnto::New();
<span onclick='openModal()' class='match'>237    TStr EvTermFNm=NrFPath+"listMultiLg_All.txt";
238    printf("Loading '%s' ...\n", EvTermFNm.CStr());
239    PSs EvTermSs=TSs::LoadTxt(ssfTabSep, EvTermFNm);
240    int EvTermSs_TermIdFldN=EvTermSs->GetFldX("ID"); IAssert(EvTermSs_TermIdFldN==0);
241    int XLen=EvTermSs->GetXLen(EvTermSs_TermIdFldN);
242    for (int X=1; X<XLen; X++){
243      TStr LangNm=EvTermSs->GetVal(X, 0); 
</span>244      LwOnto->GetLangBs()->AddLang(LangNm, LangNm); 
245    }
246    int EnLangId=LwOnto->GetLangBs()->GetLangId("EN");
247    PLwTermType D_TermType=TLwTermType::New(0, "Descriptor", EnLangId);
248    PLwTermType ND_TermType=TLwTermType::New(1, "Non-descriptor", EnLangId);
249    LwOnto->GetTermTypeBs()->AddTermType(D_TermType);
250    LwOnto->GetTermTypeBs()->AddTermType(ND_TermType);
251    for (int Y=1; Y<EvTermSs->GetYLen(); Y++){
252      printf("%d/%d\r", Y, EvTermSs->GetYLen());
253      int TermId=EvTermSs->GetVal(EvTermSs_TermIdFldN, Y).GetInt();
254      for (int X=1; X<XLen; X++){
255        TStr LangNm=EvTermSs->GetVal(X, 0);
256        TStr TermNm=EvTermSs->GetVal(X, Y);
257        int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
258        PLwTerm Term=TLwTerm::New(TermId, TermNm, LangId, D_TermType->GetTermTypeId());
259        LwOnto->GetTermBs()->AddTerm(Term);
260      }
261    }
262    printf("\nDone. (%d)\n", EvTermSs->GetYLen()-1);
263    {PLwLinkType BT_LinkType=TLwLinkType::New(0, "BT", EnLangId, "Broader-Term");
264    PLwLinkType NT_LinkType=TLwLinkType::New(1, "NT", EnLangId, "Narrower-Term");
265    PLwLinkType MT_LinkType=TLwLinkType::New(2, "MT", EnLangId, "Micro-Theory");
266    PLwLinkType RT_LinkType=TLwLinkType::New(3, "RT", EnLangId, "Related-Term");
267    PLwLinkType UF_LinkType=TLwLinkType::New(4, "UF", EnLangId, "Used-For");
268    LwOnto->GetLinkTypeBs()->AddLinkType(BT_LinkType);
269    LwOnto->GetLinkTypeBs()->AddLinkType(NT_LinkType);
270    LwOnto->GetLinkTypeBs()->AddLinkType(MT_LinkType);
271    LwOnto->GetLinkTypeBs()->AddLinkType(RT_LinkType);
272    LwOnto->GetLinkTypeBs()->AddLinkType(UF_LinkType);}
273    {TStr EvLinkFNm=NrFPath+"eurovoc.txt";
274    printf("Loading '%s' ...", EvLinkFNm.CStr());
275    PSs EvLinkSs=TSs::LoadTxt(ssfTabSep, EvLinkFNm);
276    int EvLinkSs_TermId1FldN=EvLinkSs->GetFldX("term");
277    int EvLinkSs_LinkTypeNmFldN=EvLinkSs->GetFldX("link");
278    int EvLinkSs_TermId2FldN=EvLinkSs->GetFldX("subterm");
279    int EvLinkSs_TermNmFldN=EvLinkSs->GetFldX("name");
280    int EnLangId=LwOnto->GetLangBs()->GetLangId("EN");
281    for (int Y=1; Y<EvLinkSs->GetYLen(); Y++){
282      int TermId1=EvLinkSs->GetVal(EvLinkSs_TermId1FldN, Y).GetInt();
283      TStr LinkTypeNm=EvLinkSs->GetVal(EvLinkSs_LinkTypeNmFldN, Y);
284      int TermId2=EvLinkSs->GetVal(EvLinkSs_TermId2FldN, Y).GetInt();
285      TStr TermNm=EvLinkSs->GetVal(EvLinkSs_TermNmFldN, Y);
286      if (LinkTypeNm=="UF"){
287        IAssert(TermId2==-1);
288        PLwTerm Term=TLwTerm::New(-1, TermNm, EnLangId, ND_TermType->GetTermTypeId());
289        TermId2=LwOnto->GetTermBs()->AddTermGetTermId(Term);
290        int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(LinkTypeNm, EnLangId);
291        LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
292      } else {
293        if (LinkTypeNm=="NT1"){LinkTypeNm="NT";}
294        if (LinkTypeNm=="BT1"){LinkTypeNm="BT";}
295        if ((LinkTypeNm=="BT")||(LinkTypeNm=="NT")||(LinkTypeNm=="RT")){
296          int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(LinkTypeNm, EnLangId);
297          LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
298        }
299      }
300    }
301    printf(" Done. (%d)\n", EvLinkSs->GetYLen()-1);}
302    return LwOnto;
303  }
304  PLwOnto TLwOnto::LoadAsfaVoc(const TStr& FPath){
305    TStr NrFPath=TStr::GetNrFPath(FPath);
306    PLwOnto LwOnto=TLwOnto::New();
307    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
308    {PLwTermType D_TermType=TLwTermType::New(0, "Descriptor", EnLangId);
309    PLwTermType ND_TermType=TLwTermType::New(1, "Non-descriptor", EnLangId);
310    LwOnto->GetTermTypeBs()->AddTermType(D_TermType);
311    LwOnto->GetTermTypeBs()->AddTermType(ND_TermType);}
312    {PLwLinkType BT_LinkType=TLwLinkType::New(0, "BT", EnLangId, "Broader-Term");
313    PLwLinkType NT_LinkType=TLwLinkType::New(1, "NT", EnLangId, "Narrower-Term");
314    PLwLinkType RT_LinkType=TLwLinkType::New(2, "RT", EnLangId, "Related-Term");
315    PLwLinkType UF_LinkType=TLwLinkType::New(3, "UF", EnLangId, "Used-For");
316    PLwLinkType USE_LinkType=TLwLinkType::New(4, "USE", EnLangId, "Used-By");
317    LwOnto->GetLinkTypeBs()->AddLinkType(BT_LinkType);
318    LwOnto->GetLinkTypeBs()->AddLinkType(NT_LinkType);
319    LwOnto->GetLinkTypeBs()->AddLinkType(RT_LinkType);
320    LwOnto->GetLinkTypeBs()->AddLinkType(UF_LinkType);
321    LwOnto->GetLinkTypeBs()->AddLinkType(USE_LinkType);}
322    TStr AsfaOntoFNm=NrFPath+"asfa_xml_20060522.xml";
323    printf("Loading '%s' ...", AsfaOntoFNm.CStr());
324    PXmlDoc AsfaXmlDoc=TXmlDoc::LoadTxt(AsfaOntoFNm);
325    IAssert(AsfaXmlDoc->IsOk());
326    TXmlTokV ConceptXmlTokV;
327    AsfaXmlDoc->GetTagTokV("THESAURUS|CONCEPT", ConceptXmlTokV);
328    printf(" Done.\n");
329    {printf("Creating terms ...");
330    for (int ConceptN=0; ConceptN<ConceptXmlTokV.Len(); ConceptN++){
331      PXmlTok ConceptXmlTok=ConceptXmlTokV[ConceptN];
332      TStr TermNm;
333      if (ConceptXmlTok->IsSubTag("NON-DESCRIPTOR")){
334        TermNm=ConceptXmlTok->GetTagTokStr("NON-DESCRIPTOR");}
335      else if (ConceptXmlTok->IsSubTag("DESCRIPTOR")){
336        TermNm=ConceptXmlTok->GetTagTokStr("DESCRIPTOR");}
337      TStr TermTypeNm=ConceptXmlTok->GetTagTokStr("TYP");
338      int TermTypeId=LwOnto->GetTermTypeBs()->GetTermTypeId(TermTypeNm, EnLangId);
339      TStr DescStr;
340      if (ConceptXmlTok->IsSubTag("SN")){
341        DescStr=ConceptXmlTok->GetTagTokStr("SN");
342        DescStr.ChangeChAll('\r', ' '); DescStr.ChangeChAll('\n', ' ');
343        DescStr.ChangeStrAll("  ", " "); DescStr.ToTrunc();
344      }
345      PLwTerm Term=TLwTerm::New(-1, TermNm, EnLangId, TermTypeId, DescStr);
346      LwOnto->GetTermBs()->AddTermGetTermId(Term);
347    }
348    printf(" Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
349    {printf("Creating links ...");
350    for (int ConceptN=0; ConceptN<ConceptXmlTokV.Len(); ConceptN++){
351      PXmlTok ConceptXmlTok=ConceptXmlTokV[ConceptN];
352      TStr TermNm1;
353      if (ConceptXmlTok->IsSubTag("NON-DESCRIPTOR")){
354        TermNm1=ConceptXmlTok->GetTagTokStr("NON-DESCRIPTOR");}
355      else if (ConceptXmlTok->IsSubTag("DESCRIPTOR")){
356        TermNm1=ConceptXmlTok->GetTagTokStr("DESCRIPTOR");}
357      int TermId1=LwOnto->GetTermBs()->GetTermId(TermNm1, EnLangId);
358      for (int SubTokN=0; SubTokN<ConceptXmlTok->GetSubToks(); SubTokN++){
359        PXmlTok SubTok=ConceptXmlTok->GetSubTok(SubTokN);
360        if (SubTok->IsTag()){
361          TStr LinkTypeNm=SubTok->GetTagNm();
362          if (LwOnto->GetLinkTypeBs()->IsLinkType(LinkTypeNm, EnLangId)){
363            TStr TermNm2=ConceptXmlTok->GetTagTokStr(LinkTypeNm);
364            int TermId2=LwOnto->GetTermBs()->GetTermId(TermNm2, EnLangId);
365            int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(LinkTypeNm, EnLangId);
366            LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
367          }
368        }
369      }
370    }
371    printf(" Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
372    return LwOnto;
373  }
374  PLwOnto TLwOnto::LoadDMozVoc(const TStr& DMozBinFBase, const TStr& FPath){
375    PDMozBs DMozBs=TDMozBs::LoadBin(DMozBinFBase, FPath);
376    int Cats=DMozBs->GetCats();
377    PLwOnto LwOnto=TLwOnto::New();
378    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
379    PLwTermType Cat_TermType=TLwTermType::New(0, "Category", EnLangId);
380    LwOnto->GetTermTypeBs()->AddTermType(Cat_TermType);
381    PLwLinkType NT_LinkType=TLwLinkType::New(0, "NT", EnLangId, "Narrow");
382    PLwLinkType RT_LinkType=TLwLinkType::New(1, "RT", EnLangId, "Related");
383    PLwLinkType SL_LinkType=TLwLinkType::New(2, "SL", EnLangId, "Symbolic");
384    LwOnto->GetLinkTypeBs()->AddLinkType(NT_LinkType);
385    LwOnto->GetLinkTypeBs()->AddLinkType(RT_LinkType);
386    LwOnto->GetLinkTypeBs()->AddLinkType(SL_LinkType);
387    {printf("Creating terms ...\n");
388    for (int CatId=0; CatId<Cats; CatId++){
389      if (CatId%1000==0){printf("%d/%d\r", CatId, Cats);}
390      TStr TermNm=DMozBs->GetCatNm(CatId);
391      PLwTerm Term=TLwTerm::New(CatId, TermNm, EnLangId, Cat_TermType->GetTermTypeId());
392      LwOnto->GetTermBs()->AddTerm(Term);
393    }
394    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
395    {printf("Creating links ...\n"); 
396    for (int CatId=0; CatId<Cats; CatId++){
397      TStr CatNm=DMozBs->GetCatNm(CatId);
398      if (CatId%1000==0){printf("%d/%d\r", CatId, Cats);}
399      TUIntV SubCatTypeIdPrV; DMozBs->GetSubCatTypeIdPrV(CatId, SubCatTypeIdPrV);
400      for (int SubCatN=0; SubCatN<SubCatTypeIdPrV.Len(); SubCatN++){
401        int SubCatId; TDMozSubCatType SubCatType;
402        TDMozBs::GetSubCatTypeCatId(SubCatTypeIdPrV[SubCatN], SubCatType, SubCatId);
403        TStr SubCatNm=DMozBs->GetCatNm(SubCatId);
404        int LinkTypeId=-1;
405        switch (SubCatType){
406          case dmsctNarrow: LinkTypeId=NT_LinkType->GetLinkTypeId(); break;
407          case dmsctRelated: LinkTypeId=RT_LinkType->GetLinkTypeId(); break;
408          case dmsctSymbolic: LinkTypeId=SL_LinkType->GetLinkTypeId(); break;
409          default: LinkTypeId=-1;
410        }
411        if (LinkTypeId!=-1){
412          LwOnto->GetLinkBs()->AddLink(CatId, LinkTypeId, SubCatId);
413        }
414      }
415    }
416    printf(" Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
417    return LwOnto;
418  }
419  PLwOnto TLwOnto::LoadVoc(const TStr& FNm) {
420    PLwOnto LwOnto = TLwOnto::New();
421    int EnLangId = LwOnto->GetLangBs()->AddLang("EN", "English");
422    PLwTermType TermType = TLwTermType::New(0, "Term", EnLangId);
423    LwOnto->GetTermTypeBs()->AddTermType(TermType);
424    {printf("Creating terms ...\n");
425    TStr VocFileStr = TStr::LoadTxt(FNm); 
426    VocFileStr.DelChAll('\r');
427    TStrV TermNmV; VocFileStr.SplitOnAllCh('\n', TermNmV);
428    const int Terms = TermNmV.Len();
429    for (int TermId = 0; TermId<Terms; TermId++){
430      if (TermId%1000==0){printf("%d/%d\r", TermId, Terms);}
431      TStr TermNm = TermNmV[TermId];
432      PLwTerm Term=TLwTerm::New(TermId, TermNm, EnLangId, TermType->GetTermTypeId());
433      LwOnto->GetTermBs()->AddTerm(Term);
434    }
435    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
436    return LwOnto;
437  }
438  void TLwOntoGround::SaveTxt(const TStr& FNm){
439    PLwTermBs TermBs=LwOnto->GetTermBs();
440    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
441    fprintf(fOut, "===LwOnto-Begin======================\n");
442    for (int TermN=0; TermN<TermBs->GetTerms(); TermN++){
443      int TermId=TermBs->GetTermId(TermN);
444      TStr TermNm=TermBs->GetTerm(TermId)->GetTermNm();
445      fprintf(fOut, "TermId:%d TermNm:'%s'", TermId, TermNm.CStr());
446      if (TermIdToConceptSpVH.IsKey(TermId)){
447        PBowSpV ConceptSpV=TermIdToConceptSpVH.GetDat(TermId);
448        TStr ConceptSpVStr=ConceptSpV->GetStr(BowDocBs, 15, 0.66);
449        fprintf(fOut, " ConceptSpV:%s", ConceptSpVStr.CStr());
450      }
451      fprintf(fOut, "\n");
452    }
453  }
454  PLwOntoGround TLwOntoGround::GetOntoGround(
455   const PLwOnto& LwOnto, const PBowDocBs& BowDocBs,
456   const TStr& LangNm, const bool& DocCatIsTermIdP,
457   const double& CutWordWgtSumPrc){
458    printf("Generating Ontology-Classifier...\n");
459    PLwTermBs TermBs=LwOnto->GetTermBs();
460    int Terms=TermBs->GetTerms();
461    PLwLinkBs LinkBs=LwOnto->GetLinkBs();
462    PLwLinkTypeBs LinkTypeBs=LwOnto->GetLinkTypeBs();
463    int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
464    int Docs=BowDocBs->GetDocs();
465    printf("  Creating BowDocWgtBs ...");
466    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
467    PBowSim BowSim=TBowSim::New(bstCos);
468    printf(" Done.\n");
469    printf("  Collecting documents per ontology-term ...\n");
470    TIntIntVH TermIdToDIdVH; int PosCats=0; int NegCats=0;
471    for (int DId=0; DId<Docs; DId++){
472      printf("    Docs:%d/%d Pos:%d Neg:%d\r", 1+DId, Docs, PosCats, NegCats);
473      for (int DocCIdN=0; DocCIdN<BowDocBs->GetDocCIds(DId); DocCIdN++){
474        int CId=BowDocBs->GetDocCId(DId, DocCIdN);
475        TStr CatNm=BowDocBs->GetCatNm(CId);
476        if (DocCatIsTermIdP){
477          int TermId=CatNm.GetInt();
478          if (TermBs->IsTermId(TermId)){
479            TermIdToDIdVH.AddDat(TermId).Add(DId); PosCats++;
480          } else {NegCats++;}
481        } else {
482          if (TermBs->IsTermId(CatNm, LangId)){
483            int TermId=TermBs->GetTermId(CatNm, LangId);
484            TermIdToDIdVH.AddDat(TermId).Add(DId); PosCats++;
485          } else {NegCats++;}
486        }
487      }
488    }
489    printf("    Docs:%d/%d Pos:%d Neg:%d\n", Docs, Docs, PosCats, NegCats);
490    printf("  Done.\n");
491    printf("  Creating sub-terms & up-terms vectors ...");
492    TIntIntVH Const_TermIdToSubTermIdVH;
493    TIntIntVH TermIdToSubTermIdVH;
494    TIntIntVH TermIdToUpTermIdVH;
495    for (int TermN=0; TermN<Terms; TermN++){
496      int TermId=TermBs->GetTermId(TermN);
497      for (int LinkN=0; LinkN<LinkBs->GetFromLinks(TermId); LinkN++){
498        int LinkTypeId; int DstTermId;
499        LinkBs->GetFromLink(TermId, LinkN, LinkTypeId, DstTermId);
500        TStr LinkTypeNm=LinkTypeBs->GetLinkType(LinkTypeId)->GetLinkTypeNm();
501        if (LinkTypeNm=="NT"){
502          Const_TermIdToSubTermIdVH.AddDat(TermId).Add(DstTermId);
503          TermIdToSubTermIdVH.AddDat(TermId).Add(DstTermId);
504          TermIdToUpTermIdVH.AddDat(DstTermId).Add(TermId);
505        }
506      }
507    }
508    printf("   Done.\n");
509    printf("  Creating centroids ...\n");
510    THash<TInt, PBowSpV> TermIdToConceptSpVH;
511    TIntIntVH TermIdToSubTermDIdVH;
512    TIntH ProcTermIdH;
513    int PrevActiveTerms=-1;
514    forever{
515      int ActiveTerms=0;
516      for (int TermN=0; TermN<Terms; TermN++){
517        int TermId=TermBs->GetTermId(TermN);
518        if ((TermIdToSubTermIdVH.IsKey(TermId))&&
519         (TermIdToSubTermIdVH.GetDat(TermId).Len()>0)){
520          ActiveTerms++;
521        }
522      }
523      printf("    Active-Terms:%d\n", ActiveTerms);
524      if (ActiveTerms==PrevActiveTerms){break;}
525      PrevActiveTerms=ActiveTerms;
526      for (int TermN=0; TermN<Terms; TermN++){
527        int TermId=TermBs->GetTermId(TermN);
528        if (ProcTermIdH.IsKey(TermId)){continue;}
529        if ((!TermIdToSubTermIdVH.IsKey(TermId))||
530         (TermIdToSubTermIdVH.GetDat(TermId).Len()==0)){
531          printf("    %d/%d\r", 1+TermN, Terms);
532          ProcTermIdH.AddKey(TermId);
533          TIntV TermDIdV;
534          if (TermIdToDIdVH.IsKey(TermId)){
535            TermDIdV.AddV(TermIdToDIdVH.GetDat(TermId));}
536          if (TermIdToSubTermDIdVH.IsKey(TermId)){
537            TermDIdV.AddV(TermIdToSubTermDIdVH.GetDat(TermId));}
538          if (TermDIdV.Len()>0){
539            PBowSpV ConceptSpV=
540             TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, TermDIdV, CutWordWgtSumPrc);
541            TermIdToConceptSpVH.AddDat(TermId, ConceptSpV);
542          }
543          if (TermIdToUpTermIdVH.IsKey(TermId)){
544            TIntV& UpTermIdV=TermIdToUpTermIdVH.GetDat(TermId);
545            for (int UpTermIdN=0; UpTermIdN<UpTermIdV.Len(); UpTermIdN++){
546              int UpTermId=UpTermIdV[UpTermIdN];
547              TermIdToSubTermIdVH.GetDat(UpTermId).DelIfIn(TermId);
548              if (TermDIdV.Len()>0){
549                TermIdToSubTermDIdVH.AddDat(UpTermId).AddV(TermDIdV);}
550            }
551          }
552        }
553      }
554    }
555    printf("  Done.\n");
556    PLwOntoGround OntoGround=
557     TLwOntoGround::New(LwOnto, BowDocBs, BowDocWgtBs, TermIdToConceptSpVH);
558    printf("Done.\n");
559    return OntoGround;
560  }
561  PLwOntoGround TLwOntoGround::GetOntoGroundNN(const PLwOnto& LwOnto, 
562          const PBowDocBs& BowDocBs, const TStr& LangNm) {
563      printf("Generating Ontology-Classifier...\n");
564      PLwTermBs TermBs=LwOnto->GetTermBs();
565      const int Terms = TermBs->GetTerms();
566      const int LangId = LwOnto->GetLangBs()->GetLangId(LangNm);
567      const int Words = BowDocBs->GetWords();
568      printf("  Creating BowDocWgtBs ...");
569      PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
570      PBowSim BowSim=TBowSim::New(bstCos);
571      printf(" Done.\n");
572      printf("  Collecting documents per ontology-term ... ");
573      THash<TInt, PBowSpV> TermIdToConceptSpVH;
574      for (int TermN = 0; TermN < Terms; TermN++){
575          int TermId = TermBs->GetTermId(TermN);
576          PLwTerm Term = TermBs->GetTerm(TermId);
577          if (Term->GetLangId() != LangId) { continue; }
578          PBowSpV TermSpV = BowDocBs->GetSpVFromHtmlStr(
579              Term->GetTermNm(), BowDocWgtBs);
580          TFltIntKdV SimDIdKdV;
581          BowDocWgtBs->GetSimDIdV(TermSpV, BowSim, SimDIdKdV, false);
582          TFltV TermV(Words); TermV.PutAll(0.0);
583          for (int SimDIdKdN = 0; SimDIdKdN < SimDIdKdV.Len(); SimDIdKdN++) {
584              PBowSpV DocSpV = BowDocWgtBs->GetSpV(SimDIdKdV[SimDIdKdN].Dat);
585              const double Sim = SimDIdKdV[SimDIdKdN].Key;
586              TBowLinAlg::AddVec(Sim, DocSpV, TermV);
587          }
588          TermIdToConceptSpVH.AddDat(TermId, TBowSpV::New(-1, TermV, TFlt::Eps));
589      }
590      printf("  Done.\n");
591      PLwOntoGround OntoGround = TLwOntoGround::New(LwOnto, 
592          BowDocBs, BowDocWgtBs, TermIdToConceptSpVH);
593      printf("Done.\n");
594      return OntoGround;
595  }
596  void TLwOntoGround::ClassifySpV(
597   const PBowSpV& QueryBowSpV, TSimTermIdPrV& SimTermIdPrV) const {
598    PBowSim BowSim=TBowSim::New(bstCos);
599    SimTermIdPrV.Clr();
600    for (int TermN=0; TermN<TermIdToConceptSpVH.Len(); TermN++){
601      int TermId=TermIdToConceptSpVH.GetKey(TermN);
602      PBowSpV ConceptSpV=TermIdToConceptSpVH[TermN];
603      double Sim=BowSim->GetSim(QueryBowSpV, ConceptSpV);
604      TStr TermNm = GetLwOnto()->GetTermBs()->GetTerm(TermId)->GetTermNm();
605      if (Sim > 0.0) { SimTermIdPrV.Add(TFltIntPr(Sim, TermId)); } 
606    }
607    SimTermIdPrV.Sort(false);
608  }
609  void TLwOntoGround::ClassifyStr(
610   const TStr& QueryStr, TSimTermIdPrV& SimTermIdPrV) const {
611    PBowDocBs BowDocBs=GetBowDocBs();
612    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs();
613    PBowSpV QueryBowSpV=
614     BowDocBs->GetSpVFromHtmlStr(QueryStr, BowDocWgtBs);
615    ClassifySpV(QueryBowSpV, SimTermIdPrV);
616  }
617  void TLwOntoGround::ClassifyHtmlFNm(
618   const TStr& QueryHtmlFNm, TSimTermIdPrV& SimTermIdPrV) const {
619    PBowDocBs BowDocBs=GetBowDocBs();
620    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs();
621    PBowSpV QueryBowSpV=
622     BowDocBs->GetSpVFromHtmlFile(QueryHtmlFNm, BowDocWgtBs);
623    ClassifySpV(QueryBowSpV, SimTermIdPrV);
624  }
625  void TLwOntoGround::SaveCfySetTxt(
626   FILE* fTxt, TSimTermIdPrV& SimTermIdPrV, const int& MxRank){
627    int Terms=(MxRank==-1) ? SimTermIdPrV.Len() : MxRank;
628    for (int TermN=0; TermN<Terms; TermN++){
629      double Sim=SimTermIdPrV[TermN].Val1;
630      int TermId=SimTermIdPrV[TermN].Val2;
631      TStr TermNm=LwOnto->GetTermBs()->GetTerm(TermId)->GetTermNm();
632      fprintf(fTxt, "%2d. %.3f %s\n", 1+TermN, Sim, TermNm.CStr());
633    }
634  }
635  void TLwOntoGround::SaveCfySetXml(
636   FILE* fXml, TSimTermIdPrV& SimTermIdPrV, const int& MxRank){
637    fprintf(fXml, "<OntoClassify>\n");
638    int Terms=(MxRank==-1) ? SimTermIdPrV.Len() : MxRank;
639    for (int TermN=0; TermN<Terms; TermN++){
640      double Sim=SimTermIdPrV[TermN].Val1;
641      int TermId=SimTermIdPrV[TermN].Val2;
642      TStr TermNm=LwOnto->GetTermBs()->GetTerm(TermId)->GetTermNm();
643      fprintf(fXml, "<Term Rank=\"%d\" Sim=\"%.3f\">%s</Term>\n",
644       1+TermN, Sim, TermNm.CStr());
645    }
646    fprintf(fXml, "</OntoClassify>\n");
647  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.cpp</h3>
            <pre><code>1  void TBowKWordSet::GetWordStrV(TStrV& WordStrV) const {
2    WordStrV.Clr(); int KWords=GetKWords();
3    for (int KWordN=0; KWordN<KWords; KWordN++){
4      WordStrV.Add(GetKWordStr(KWordN));
5    }
6  }
7  TStr TBowKWordSet::GetKWordsStr() const {
8    TChA ResChA; int KWords=GetKWords();
9    for (int KWordN=0; KWordN<KWords; KWordN++){
10      if (KWordN>0){ResChA+=", ";}
11      ResChA+=GetKWordStr(KWordN);
12    }
13    return ResChA;
14  }
15  void TBowKWordSet::SortByStr(){
16    TStrFltPrV WStrWWgtPrV;
17    WStrToWWgtH.GetKeyDatPrV(WStrWWgtPrV);
18    WStrWWgtPrV.Sort();
19    WStrToWWgtH.Clr();
20    for (int WordN=0; WordN<WStrWWgtPrV.Len(); WordN++){
21      WStrToWWgtH.AddDat(WStrWWgtPrV[WordN].Val1, WStrWWgtPrV[WordN].Val2);
22    }
23  }
24  void TBowKWordSet::SortByWgt(){
25    TFltStrPrV WWgtWStrPrV;
26    WStrToWWgtH.GetDatKeyPrV(WWgtWStrPrV);
27    WWgtWStrPrV.Sort(false);
28    WStrToWWgtH.Clr();
29    for (int WordN=0; WordN<WWgtWStrPrV.Len(); WordN++){
30      WStrToWWgtH.AddDat(WWgtWStrPrV[WordN].Val2, WWgtWStrPrV[WordN].Val1);
31    }
32  }
33  PBowKWordSet TBowKWordSet::GetTopKWords(const int& MxKWords, const double& WgtSumPrc) const {
34    TFltStrPrV WWgtWStrPrV;
35    WStrToWWgtH.GetDatKeyPrV(WWgtWStrPrV);
36    WWgtWStrPrV.Sort(false);
37    double WgtSum=0;
38    for (int WordN=0; WordN<WWgtWStrPrV.Len(); WordN++){
39      WgtSum+=WWgtWStrPrV[WordN].Val1;
40    }
41    PBowKWordSet KWordSet=TBowKWordSet::New(GetNm());
42    double WgtSumSF=0;
43    for (int WordN=0; WordN<WWgtWStrPrV.Len(); WordN++){
44      KWordSet->AddKWord(WWgtWStrPrV[WordN].Val2, WWgtWStrPrV[WordN].Val1);
45      WgtSumSF+=WWgtWStrPrV[WordN].Val1;
46      if ((MxKWords!=-1)&&(KWordSet->GetKWords()>=MxKWords)){break;}
47      if ((WgtSum>0)&&(WgtSumSF/WgtSum>WgtSumPrc)){break;}
48    }
49    return KWordSet;
50  }
51  void TBowKWordSet::SaveTxt(const PSOut& SOut) const {
52    SOut->PutStr(TStr::Fmt("'%s':", GetNm().CStr()));
53    int KWords=GetKWords();
54    for (int KWordN=0; KWordN<KWords; KWordN++){
55      TStr KWordStr=GetKWordStr(KWordN);
56      double KWordWgt=GetKWordWgt(KWordN);
57      SOut->PutStr(TStr::Fmt(" [%s:%.5f]", KWordStr.CStr(), KWordWgt));
58    }
59  }
60  void TBowKWordSet::SaveXml(const PSOut& SOut) const {
61    int KWords=GetKWords();
62    SOut->PutStr(TStr::Fmt("<KeywordSet Nm=\"%s\">", TXmlLx::GetXmlStrFromPlainStr(GetNm()).CStr()));
63    for (int KWordN=0; KWordN<KWords; KWordN++){
64      TStr KWordStr=GetKWordStr(KWordN);
65      TStr KWordXmlStr=TXmlLx::GetXmlStrFromPlainStr(KWordStr);
66      double KWordWgt=GetKWordWgt(KWordN);
67      SOut->PutStr(TStr::Fmt("<Keyword Str=\"%s\" Wgt=\"%g\"/>", KWordXmlStr.CStr(), KWordWgt));
68    }
69    SOut->PutStr("</KeywordSet>");
70  }
71  void TBowKWordBs::SaveTxt(const PSOut& SOut) const {
72    int KWordSets=GetKWordSets();
73    for (int KWordSetN=0; KWordSetN<KWordSets; KWordSetN++){
74      PBowKWordSet KWordSet=GetKWordSet(KWordSetN);
75      KWordSet->SaveTxt(SOut);
76      SOut->PutLn();
77    }
78  }
79  void TBowKWordBs::SaveXml(const PSOut& SOut) const {
80    SOut->PutStr("<KeywordBase>"); SOut->PutLn();
81    int KWordSets=GetKWordSets();
82    for (int KWordSetN=0; KWordSetN<KWordSets; KWordSetN++){
83      PBowKWordSet KWordSet=GetKWordSet(KWordSetN);
84      KWordSet->SaveXml(SOut);
85      SOut->PutLn();
86    }
87    SOut->PutStr("</KeywordBase>");
88  }
89  TBowSpV::TBowSpV(const int& _DId, const TFltV& FullVec,
90          const double& Eps): DId(_DId) {
91      double SqrSum = 0.0;
92      for (int EltN = 0; EltN < FullVec.Len(); EltN++) {
93          const double EltVal = FullVec[EltN];
94          if (TFlt::Abs(EltVal) > Eps) {
95              SqrSum += TMath::Sqr(EltVal);
96              WIdWgtKdV.Add(TIntSFltKd(EltN, (sdouble)EltVal));
97          }
98      }
99      Norm = sqrt(SqrSum);
100  }
101  TBowSpV::TBowSpV(const int& DId, const TIntFltKdV& SpV) {
102      double SqrSum = 0.0;
103      WIdWgtKdV.Gen(SpV.Len(), 0);
104      for (int WIdN = 0; WIdN < SpV.Len(); WIdN++) {
105          WIdWgtKdV.Add(TIntSFltKd(SpV[WIdN].Key, sdouble(SpV[WIdN].Dat.Val)));
106      }
107      Norm = sqrt(SqrSum);
108  }
109  void TBowSpV::PutUnitNorm(){
110    int WIds=GetWIds();
111    double SqWgtSum=0;
112    for (int WIdN=0; WIdN<WIds; WIdN++){
113      SqWgtSum+=TMath::Sqr(WIdWgtKdV[WIdN].Dat);
114    }
115    if (SqWgtSum>0){
116      for (int WIdN=0; WIdN<WIds; WIdN++){
117        WIdWgtKdV[WIdN].Dat=(sdouble)sqrt(TMath::Sqr(WIdWgtKdV[WIdN].Dat)/SqWgtSum);
118      }
119      Norm=1.0;
120    } else {
121      Norm=0.0;
122    }
123  }
124  double TBowSpV::GetNorm(){
125    if (double(Norm)==-1){
126      double SqWgtSum=0;
127      int WIds=GetWIds();
128      for (int WIdN=0; WIdN<WIds; WIdN++){
129        SqWgtSum+=TMath::Sqr(WIdWgtKdV[WIdN].Dat);}
130      Norm=sqrt(SqWgtSum);
131    }
132    return Norm;
133  }
134  void TBowSpV::GetWordStrWgtPrV(const PBowDocBs& BowDocBs,
135   const int& TopWords, const double& TopWordsWgtPrc,
136   TStrFltPrV& WordStrWgtPrV) const {
137    int WIds=GetWIds(); double WordWgtSum=0;
138    TFltIntKdV WgtWIdKdV(WIds, 0);
139    for (int WIdN=0; WIdN<WIds; WIdN++){
140      int WId; double Wgt; GetWIdWgt(WIdN, WId, Wgt);
141      WgtWIdKdV.Add(TFltIntKd(Wgt, WId));
142      WordWgtSum+=Wgt;
143    }
144    WgtWIdKdV.Sort(false);
145    WordStrWgtPrV.Clr();
146    double WordWgtSumSF=0;
147    {for (int WIdN=0; WIdN<WIds; WIdN++){
148      if ((TopWords!=-1)&&(WIdN>=TopWords)){break;}
149      if ((WordWgtSum>0)&&(WordWgtSumSF/WordWgtSum>TopWordsWgtPrc)){break;}
150      int WId=WgtWIdKdV[WIdN].Dat;
151      double WordWgt=WgtWIdKdV[WIdN].Key;
152      TStr WordStr;
153      if (BowDocBs.Empty()){WordStr=TInt::GetStr(WId);}
154      else {WordStr=BowDocBs->GetWordStr(WId);}
155      WordWgtSumSF+=WordWgt;
156      WordStrWgtPrV.Add(TStrFltPr(WordStr, WordWgt));
157    }}
158  }
159  PBowKWordSet TBowSpV::GetKWordSet(const PBowDocBs& BowDocBs) const {
160    TStrFltPrV WordStrWgtPrV; GetWordStrWgtPrV(BowDocBs, -1, 1.0, WordStrWgtPrV);
161    PBowKWordSet KWordSet=TBowKWordSet::New();
162    for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
163      TStr WStr=WordStrWgtPrV[WordN].Val1;
164      double WWgt=WordStrWgtPrV[WordN].Val2;
165      KWordSet->AddKWord(WStr, WWgt);
166    }
167    return KWordSet;
168  }
169  void TBowSpV::GetIntFltKdV(TIntFltKdV& SpV) const {
170      const int Wds = WIdWgtKdV.Len(); SpV.Gen(Wds, 0);
171      for (int WdN = 0; WdN < Wds; WdN++) {
172          const TBowWIdWgtKd& WIdWgt = WIdWgtKdV[WdN];
173          SpV.Add(TIntFltKd(WIdWgt.Key, WIdWgt.Dat.Val));
174      }
175  }
176  void TBowSpV::CutLowWgtWords(const double& CutWordWgtSumPrc){
177    if (CutWordWgtSumPrc<=0){return;}
178    int WIds=GetWIds();
179    double WgtSum=0; TFltV WgtV(WIds, 0);
180    for (int WIdN=0; WIdN<WIds; WIdN++){
181      double Wgt=WIdWgtKdV[WIdN].Dat;
182      WgtSum+=Wgt; WgtV.Add(Wgt);
183    }
184    WgtV.Sort();
185    double CutWgtSum=CutWordWgtSumPrc*WgtSum;
186    double CutWgt=-1; int NonCutWgts=-1;
187    for (int WgtN=0; WgtN<WIds; WgtN++){
188      CutWgtSum-=WgtV[WgtN];
189      if (CutWgtSum<=0){
190        CutWgt=WgtV[WgtN]; NonCutWgts=WIds-WgtN; break;}
191    }
192    if (NonCutWgts!=-1){
193      TBowWIdWgtKdV NewWIdWgtKdV(NonCutWgts, 0);
194      for (int WIdN=0; WIdN<WIds; WIdN++){
195        double Wgt=WIdWgtKdV[WIdN].Dat;
196        if (Wgt>=CutWgt){
197          NewWIdWgtKdV.Add(WIdWgtKdV[WIdN]);
198        }
199      }
200      Norm=-1;
201      WIdWgtKdV.MoveFrom(NewWIdWgtKdV);
202    }
203  }
204  TStr TBowSpV::GetStr(const PBowDocBs& BowDocBs,
205   const int& TopWords, const double& TopWordsWgtPrc, const TStr& SepStr,
206   const bool& ShowWeightsP, const bool& KeepUndelineP) const {
207    TStrFltPrV WordStrWgtPrV;
208    GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, WordStrWgtPrV);
209    TChA ChA;
210    for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
211      TStr WordStr=WordStrWgtPrV[WordN].Val1;
212      if (!KeepUndelineP){
213        WordStr.ChangeChAll('_', ' ');}
214      double WordWgt=WordStrWgtPrV[WordN].Val2;
215      if (!ShowWeightsP) WordStr.ToLc();
216      if (!ChA.Empty()){ChA+=SepStr;}
217      if (ShowWeightsP){ChA+='[';}
218      ChA+=WordStr;
219      if (ShowWeightsP) ChA+=TFlt::GetStr(WordWgt, ":%g]");
220    }
221    return ChA;
222  }
223  void TBowSpV::SaveTxt(const PSOut& SOut, const PBowDocBs& BowDocBs,
224   const int& TopWords, const double& TopWordsWgtPrc, const char& SepCh) const {
225    TChA SepStr; SepStr += SepCh; 
226    TStr Str=GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr);
227    SOut->PutStr(Str);
228    SOut->PutLn();
229  }
230  void TBowSpV::SaveXml(const PSOut& SOut, const PBowDocBs& BowDocBs) const {
231    int WIds=GetWIds();
232    TFltIntKdV WgtWIdKdV(WIds, 0);
233    for (int WIdN=0; WIdN<WIds; WIdN++){
234      int WId; double Wgt; GetWIdWgt(WIdN, WId, Wgt);
235      WgtWIdKdV.Add(TFltIntKd(Wgt, WId));
236    }
237    WgtWIdKdV.Sort(false);
238    SOut->PutStr("<SparseVec>");
239    {for (int WIdN=0; WIdN<WIds; WIdN++){
240      int WId=WgtWIdKdV[WIdN].Dat;
241      double Wgt=WgtWIdKdV[WIdN].Key;
242      TChA WordChA;
243      WordChA+="<Word";
244      WordChA+=" Id=\""; WordChA+=TInt::GetStr(WId); WordChA+='\"';
245      if (!BowDocBs.Empty()){
246        WordChA+=" Str=\""; WordChA+=BowDocBs->GetWordStr(WId); WordChA+='\"';
247      }
248      WordChA+=" Wgt=\""; WordChA+=TFlt::GetStr(Wgt); WordChA+='\"';
249      WordChA+="/>";
250      SOut->PutStr(WordChA);
251    }}
252    SOut->PutStr("</SparseVec>");
253  }
254  double TBowSimMtx::GetSim(const int& DId1, const int& DId2) const {
255    if ((DId1==-1)||(DId2==-1)){return 0;}
256    int MtxDId1=MtxDIdV[DId1]; int MtxDId2=MtxDIdV[DId2];
257    if (MtxDId1>MtxDId2){TInt::Swap(MtxDId1, MtxDId2);}
258    TFlt Sim=0;
259    DIdPrToSimH.IsKeyGetDat(TIntPr(MtxDId1, MtxDId2), Sim);
260    return Sim;
261  }
262  PBowSimMtx TBowSimMtx::LoadTxt(const TStr& FNm){
263    PBowSimMtx BowSimMtx=TBowSimMtx::New();
264    PSIn SIn=TFIn::New(FNm);
265    TIntH MtxDIdH;
266    TILx Lx(SIn, TFSet()|iloExcept);
267    while (Lx.GetSym(syLBracket, syEof)!=syEof){
268      int MtxDId1=Lx.GetInt(); Lx.GetSym(syColon);
269      int MtxDId2=Lx.GetInt(); Lx.GetSym(syEq);
270      double Sim=Lx.GetFlt(); Lx.GetSym(syRBracket);
271      if (MtxDId1>MtxDId2){TInt::Swap(MtxDId1, MtxDId2);}
272      BowSimMtx->DIdPrToSimH.AddDat(TIntPr(MtxDId1, MtxDId2), Sim);
273      MtxDIdH.AddKey(MtxDId1); MtxDIdH.AddKey(MtxDId2);
274    }
275    int MtxDIds=MtxDIdH.Len();
276    BowSimMtx->MtxDIdV.Gen(MtxDIdH.Len(), 0);
277    for (int MtxDIdN=0; MtxDIdN<MtxDIds; MtxDIdN++){
278      BowSimMtx->MtxDIdV.Add(MtxDIdH.GetKey(MtxDIdN));}
279    BowSimMtx->MtxDIdV.Sort();
280    return BowSimMtx;
281  }
282  double TBowSim::GetSim(const int& DId1, const int& DId2) const {
283    IAssert(SimType==bstMtx);
284    return SimMtx->GetSim(DId1, DId2);
285  }
286  double TBowSim::GetSim(const PBowSpV& SpV1, const PBowSpV& SpV2) const {
287    switch (SimType){
288      case bstBlock: return GetBlockSim(SpV1, SpV2);
289      case bstEucl: return GetEuclSim(SpV1, SpV2);
290      case bstCos: return GetCosSim(SpV1, SpV2);
291      case bstMtx: return SimMtx->GetSim(SpV1->GetDId(), SpV2->GetDId());
292      default: Fail; return 0;
293    }
294  }
295  double TBowSim::GetSim(const TBowSpVV& SpVV1, const TBowSpVV& SpVV2) const {
296    double Sim=0; int Sims=0;
297    PMom SimMom=TMom::New();
298    for (int SpVN1=0; SpVN1<SpVV1.Len(); SpVN1++){
299      for (int SpVN2=0; SpVN2<SpVV2.Len(); SpVN2++){
300        Sim+=GetSim(SpVV1[SpVN1], SpVV2[SpVN2]); Sims++;
301        SimMom->Add(GetSim(SpVV1[SpVN1], SpVV2[SpVN2]));
302      }
303    }
304    if (Sims>0){Sim/=Sims;}
305    SimMom->Def();
306    Sim=SimMom->GetMn();
307    return Sim;
308  }
309  double TBowSim::GetBlockSim(const PBowSpV& SpV1, const PBowSpV& SpV2) {
310    double Sim=0;
311    int WIds1=SpV1->GetWIds();
312    int WIds2=SpV2->GetWIds();
313    int WIdN1=0; int WIdN2=0;
314    while ((WIdN1<WIds1)&&(WIdN2<WIds2)){
315      int WId1=SpV1->GetWId(WIdN1);
316      int WId2=-1;
317      forever {
318        if (WIdN2>=WIds2){break;}
319        WId2=SpV2->GetWId(WIdN2);
320        if (WId2>=WId1){break;}
321        WIdN2++;
322      }
323      if ((WIdN2<WIds2)&&(WId1==WId2)){
324        double WordWgt1=SpV1->GetWgt(WIdN1); WIdN1++;
325        double WordWgt2=SpV2->GetWgt(WIdN2); WIdN2++;
326        if (WordWgt1==WordWgt2){Sim++;}
327      } else {
328        WIdN1++;
329      }
330    }
331    return Sim;
332  }
333  double TBowSim::GetEuclSim(const PBowSpV& SpV1, const PBowSpV& SpV2) {
334    int WIds1=SpV1->GetWIds();
335    int WIds2=SpV2->GetWIds();
336    double SqDifSum=0;
337    int WIdN1=0; int WIdN2=0;
338    while ((WIdN1<WIds1)&&(WIdN2<WIds2)){
339      int WId1=SpV1->GetWId(WIdN1);
340      int WId2=SpV2->GetWId(WIdN2);
341      if (WId1==WId2){
342        double WordWgt1=SpV1->GetWgt(WIdN1); WIdN1++;
343        double WordWgt2=SpV2->GetWgt(WIdN2); WIdN2++;
344        SqDifSum+=TMath::Sqr(WordWgt1-WordWgt2);
345      } else
346      if (WId1<WId2){
347        double WordWgt1=SpV1->GetWgt(WIdN1); WIdN1++;
348        double WordWgt2=0;
349        SqDifSum+=TMath::Sqr(WordWgt1-WordWgt2);
350      } else {
351        double WordWgt1=0;
352        double WordWgt2=SpV2->GetWgt(WIdN2); WIdN2++;
353        SqDifSum+=TMath::Sqr(WordWgt1-WordWgt2);
354      }
355    }
356    for (int RestWIdN1=WIdN1; RestWIdN1<WIds1; RestWIdN1++){
357      double WordWgt1=SpV1->GetWgt(RestWIdN1);
358      SqDifSum+=TMath::Sqr(WordWgt1);
359    }
360    for (int RestWIdN2=WIdN2; RestWIdN2<WIds2; RestWIdN2++){
361      double WordWgt2=SpV2->GetWgt(RestWIdN2);
362      SqDifSum+=TMath::Sqr(WordWgt2);
363    }
364    double Sim=-sqrt(SqDifSum);
365    return Sim;
366  }
367  double TBowSim::GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2) {
368    int WIds1=SpV1->GetWIds();
369    int WIds2=SpV2->GetWIds();
370    double WordWgtProdSum=0; int IntsWords=0;
371    int WIdN1=0; int WIdN2=0;
372    while ((WIdN1<WIds1)&&(WIdN2<WIds2)){
373      int WId1=SpV1->GetWId(WIdN1);
374      int WId2=-1;
375      forever {
376        if (WIdN2>=WIds2){break;}
377        WId2=SpV2->GetWId(WIdN2);
378        if (WId2>=WId1){break;}
379        WIdN2++;
380      }
381      if ((WIdN2<WIds2)&&(WId1==WId2)){
382        double WordWgt1=SpV1->GetWgt(WIdN1); WIdN1++;
383        double WordWgt2=SpV2->GetWgt(WIdN2); WIdN2++;
384        double WordWgtProd=WordWgt1*WordWgt2;
385        WordWgtProdSum+=WordWgtProd; IntsWords++;
386      } else {
387        WIdN1++;
388      }
389    }
390    double Norm1=SpV1->GetNorm();
391    double Norm2=SpV2->GetNorm();
392    double Sim;
393    if (Norm1*Norm2==0){
394      Sim=0;
395    } else {
396      Sim=WordWgtProdSum/(Norm1*Norm2);
397    }
398    return Sim;
399  }
400  double TBowSim::GetCosSim(
401   const PBowSpV& SpV1, const PBowSpV& SpV2, TFltIntPrV& WgtWIdPrV) {
402    int WIds1=SpV1->GetWIds();
403    int WIds2=SpV2->GetWIds();
404    double WordWgtProdSum=0; int IntsWords=0;
405    int WIdN1=0; int WIdN2=0; WgtWIdPrV.Clr();
406    while ((WIdN1<WIds1)&&(WIdN2<WIds2)){
407      int WId1=SpV1->GetWId(WIdN1);
408      int WId2=-1;
409      forever {
410        if (WIdN2>=WIds2){break;}
411        WId2=SpV2->GetWId(WIdN2);
412        if (WId2>=WId1){break;}
413        WIdN2++;
414      }
415      if ((WIdN2<WIds2)&&(WId1==WId2)){
416        double WordWgt1=SpV1->GetWgt(WIdN1); WIdN1++;
417        double WordWgt2=SpV2->GetWgt(WIdN2); WIdN2++;
418        double WordWgtProd=WordWgt1*WordWgt2;
419        WordWgtProdSum+=WordWgtProd; IntsWords++;
420        WgtWIdPrV.Add(TFltIntPr(WordWgtProd, WId1));
421      } else {
422        WIdN1++;
423      }
424    }
425    double Norm1=SpV1->GetNorm();
426    double Norm2=SpV2->GetNorm();
427    double Sim;
428    if (Norm1*Norm2==0){
429      Sim=0;
430    } else {
431      Sim=WordWgtProdSum/(Norm1*Norm2);
432    }
433    return Sim;
434  }
435  TBowSimType TBowSim::GetSimType(const TStr& Nm){
436    TStr UcNm=Nm.GetUc();
437    if (UcNm=="UNDEF"){return bstUndef;}
438    else if (UcNm=="BLOCK"){return bstBlock;}
439    else if (UcNm=="EUCL"){return bstEucl;}
440    else if (UcNm=="COS"){return bstCos;}
441    else if (UcNm=="MTX"){return bstMtx;}
442    else {return bstUndef;}
443  }
444  PBowDocWgtBs TBowDocWgtBs::New(
445   const PBowDocBs& BowDocBs, const TBowWordWgtType& _WordWgtType,
446   const double& _CutWordWgtSumPrc, const int& _MnWordFq,
447   const TIntV& _DIdV, const TIntV& _BaseDIdV, const PNotify& Notify){
448    PBowDocWgtBs DocWgtBs=TBowDocWgtBs::New(BowDocBs->GetSig());
449    DocWgtBs->WordWgtType=_WordWgtType;
450    DocWgtBs->CutWordWgtSumPrc=_CutWordWgtSumPrc;
451    DocWgtBs->MnWordFq=_MnWordFq;
452    if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DocWgtBs->DIdV);}
453    else {DocWgtBs->DIdV=_DIdV;}
454    int Docs=DocWgtBs->GetDocs();
455    int AllDocs=BowDocBs->GetDocs();
456    int AllWords=BowDocBs->GetWords();
457    if ((DocWgtBs->WordWgtType==bwwtEq)||(DocWgtBs->WordWgtType==bwwtNrmEq)){
458      DocWgtBs->WordFqV.Gen(AllWords);
459      DocWgtBs->DocSpVV.Gen(AllDocs);
460      for (int DIdN=0; DIdN<Docs; DIdN++){
461        TNotify::OnNotify(Notify, ntInfo, TStr("Computing weights (")+TInt::GetStr(DIdN+1)+"/"+TInt::GetStr(Docs)+")...");
462        int DId=DocWgtBs->GetDId(DIdN);
463        int DocWIds=BowDocBs->GetDocWIds(DId);
464        DocWgtBs->DocSpVV[DId]=BowDocBs->GetDocSpV(DId);
465        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
466          int DocWId; double DocWordFq;
467          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
468          DocWgtBs->WordFqV[DocWId]+=DocWordFq;
469        }
470        if (DocWgtBs->WordWgtType==bwwtNrmEq) {
471          DocWgtBs->DocSpVV[DId]->PutUnitNorm();
472        }
473      }
474    } else if ((DocWgtBs->WordWgtType==bwwtBin)||(DocWgtBs->WordWgtType==bwwtNrmBin)) {
475      DocWgtBs->WordFqV.Gen(AllWords);
476      DocWgtBs->DocSpVV.Gen(AllDocs);
477      for (int DIdN=0; DIdN<Docs; DIdN++){
478        TNotify::OnNotify(Notify, ntInfo, TStr("Computing weights (")+TInt::GetStr(DIdN+1)+"/"+TInt::GetStr(Docs)+")...");
479        int DId=DocWgtBs->GetDId(DIdN);
480        int DocWIds=BowDocBs->GetDocWIds(DId);
481        DocWgtBs->DocSpVV[DId]=TBowSpV::New(DId, DocWIds);
482        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
483          int DocWId; double DocWordFq;
484          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
485          DocWgtBs->WordFqV[DocWId]+=DocWordFq;
486          DocWgtBs->DocSpVV[DId]->AddWIdWgt(DocWId, 1.0);
487        }
488        if (DocWgtBs->WordWgtType==bwwtNrmBin) {
489          DocWgtBs->DocSpVV[DId]->PutUnitNorm();
490        }
491      }
492    } else if (DocWgtBs->WordWgtType==bwwtNrm01){
493      DocWgtBs->WordFqV.Gen(AllWords);
494      DocWgtBs->DocSpVV.Gen(AllDocs);
495      for (int DIdN=0; DIdN<Docs; DIdN++){
496        TNotify::OnNotify(Notify, ntInfo, TStr("Computing weights (")+TInt::GetStr(DIdN+1)+"/"+TInt::GetStr(Docs)+")...");
497        int DId=DocWgtBs->GetDId(DIdN);
498        int DocWIds=BowDocBs->GetDocWIds(DId);
499        DocWgtBs->DocSpVV[DId]=TBowSpV::New(DId, DocWIds);
500        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
501          int DocWId; double DocWordFq;
502          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
503          DocWgtBs->WordFqV[DocWId]+=DocWordFq;
504          double MnWIdFq=BowDocBs->GetWordMnVal(DocWId);
505          double MxWIdFq=BowDocBs->GetWordMxVal(DocWId);
506          if (MnWIdFq!=MxWIdFq){
507            double DocWordWgt=(DocWordFq-MnWIdFq)/(MxWIdFq-MnWIdFq);
508            DocWgtBs->DocSpVV[DId]->AddWIdWgt(DocWId, DocWordWgt);
509          }
510        }
511      }
512    } else if (
513     (DocWgtBs->WordWgtType==bwwtNrmTFIDF)||
514     (DocWgtBs->WordWgtType==bwwtLogDFNrmTFIDF)){
515      TIntV BaseDIdV;
516      if (_BaseDIdV.Empty()){BaseDIdV=DocWgtBs->DIdV;}
517      else {BaseDIdV=_BaseDIdV;}
518      int BaseDocs=BaseDIdV.Len();
519      int Words=BowDocBs->GetWords();
520      DocWgtBs->WordFqV.Gen(Words);
521      for (int DIdN=0; DIdN<BaseDocs; DIdN++){
522        TNotify::OnNotify(Notify, ntInfo, TStr("Computing weights (")+TInt::GetStr(DIdN+1)+"/"+TInt::GetStr(BaseDocs)+")...");
523        int DId=BaseDIdV[DIdN];
524        int DocWIds=BowDocBs->GetDocWIds(DId);
525        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
526          int DocWId; double DocWordFq;
527          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
528          DocWgtBs->WordFqV[DocWId]++;
529        }
530      }
531      TFltV WordIDFV(Words);
532      for (int WId=0; WId<Words; WId++){
533        if (WId%100==0){
534          TNotify::OnNotify(Notify, ntInfo, TStr("Computing IDF values (")+TInt::GetStr(WId+1)+"/"+TInt::GetStr(Words)+")...");}
535        double WordDf=DocWgtBs->WordFqV[WId];
536        if (WordDf>0){
537          WordIDFV[WId]=log(double(Docs)/WordDf);}
538      }
539      DocWgtBs->DocSpVV.Gen(AllDocs);
540      {for (int DIdN=0; DIdN<Docs; DIdN++){
541        TNotify::OnNotify(Notify, ntInfo, TStr("Computing weights (")+TInt::GetStr(DIdN+1)+"/"+TInt::GetStr(BaseDocs)+")...");
542        int DId=DocWgtBs->GetDId(DIdN);
543        int DocWIds=BowDocBs->GetDocWIds(DId);
544        PBowSpV DocSpV=TBowSpV::New(DId, DocWIds);
545        DocWgtBs->DocSpVV[DId]=DocSpV;
546        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
547          int DocWId; double DocWordFq;
548          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
549          TStr WordStr=BowDocBs->GetWordStr(DocWId); 
550          if (BowDocBs->GetWordFq(DocWId)>=_MnWordFq){
551            double DocWordWgt=DocWordFq*WordIDFV[DocWId];
552            if (DocWgtBs->WordWgtType==bwwtLogDFNrmTFIDF){
553              double WordDf=DocWgtBs->WordFqV[DocWId];
554              DocWordWgt=log(1+WordDf)*DocWordWgt;
555            }
556            DocSpV->AddWIdWgt(DocWId, DocWordWgt);
557          }
558        }
559        DocSpV->CutLowWgtWords(_CutWordWgtSumPrc);
560        DocSpV->PutUnitNorm();
561      }}
562    } else if (DocWgtBs->WordWgtType==bwwtNrmTFICF){
563      TIntV BaseDIdV;
564      if (_BaseDIdV.Empty()){BaseDIdV=DocWgtBs->DIdV;}
565      else {BaseDIdV=_BaseDIdV;}
566      const int BaseDocs=BaseDIdV.Len();
567      const int Words=BowDocBs->GetWords();
568      TVec<TIntH> WordCIdHV(Words, 0);
569      for (int WId = 0; WId < Words; WId++) { WordCIdHV.Add(TIntH()); }
570      for (int DIdN=0; DIdN<BaseDocs; DIdN++){
571        const int DId=BaseDIdV[DIdN];
572        const int DocWIds=BowDocBs->GetDocWIds(DId);
573        const int DocCIds = BowDocBs->GetDocCIds(DId);
574        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
575          int DocWId; double DocWordFq;
576          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
577          for (int DocCIdN = 0; DocCIdN < DocCIds; DocCIdN++) {
578              const int DocCId = BowDocBs->GetDocCId(DId, DocCIdN);
579              if (!WordCIdHV[DocWId].IsKey(DocCId)) {
580                  WordCIdHV[DocWId].AddKey(DocCId);
581              }
582          }
583        }
584      }
585      const int Cats=BowDocBs->GetCats();
586      TFltV WordICFV(Words);
587      for (int WId=0; WId<Words; WId++){
588        double WordCf=WordCIdHV[WId].Len();
589        if (WordCf>0){
590          WordICFV[WId]=log(double(Cats)/WordCf);
591        } else {
592          WordICFV[WId]=0.0;
593        }
594      }
595      DocWgtBs->WordFqV.Gen(Words);
596      DocWgtBs->DocSpVV.Gen(AllDocs);
597      {for (int DIdN=0; DIdN<Docs; DIdN++){
598        int DId=DocWgtBs->GetDId(DIdN);
599        int DocWIds=BowDocBs->GetDocWIds(DId);
600        PBowSpV DocSpV=TBowSpV::New(DId, DocWIds);
601        DocWgtBs->DocSpVV[DId]=DocSpV;
602        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
603          int DocWId; double DocWordFq;
604          BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
605          DocWgtBs->WordFqV[DocWId]+=DocWordFq;
606          TStr WordStr=BowDocBs->GetWordStr(DocWId); 
607          if (BowDocBs->GetWordFq(DocWId)>=_MnWordFq){
608            double DocWordWgt=DocWordFq*WordICFV[DocWId];
609            DocSpV->AddWIdWgt(DocWId, DocWordWgt);
610          }
611        }
612        DocSpV->CutLowWgtWords(_CutWordWgtSumPrc);
613        DocSpV->PutUnitNorm();
614      }}
615    } else {
616      Fail;
617    }
618    return DocWgtBs;
619  }
620  PBowDocWgtBs TBowDocWgtBs::New(const TVec<PBowSpV>& BowSpVV) {
621      PBowDocWgtBs DocWgtBs=TBowDocWgtBs::New(0);
622      DocWgtBs->WordWgtType=bwwtPreCalc;
623      DocWgtBs->CutWordWgtSumPrc=0.0;
624      DocWgtBs->MnWordFq=0;
625      int AllWords=0; DocWgtBs->DIdV.Gen(BowSpVV.Len(), 0);
626      for (int DocN = 0; DocN < BowSpVV.Len(); DocN++) {
627          DocWgtBs->DIdV.Add(BowSpVV[DocN]->GetDId());
628          AllWords = TInt::GetMx(AllWords, BowSpVV[DocN]->GetLastWId());
629      }
630      DocWgtBs->WordFqV.Gen(AllWords); 
631      DocWgtBs->WordFqV.PutAll(0.0);
632      DocWgtBs->DocSpVV = BowSpVV;
633      return DocWgtBs;
634  }
635  PBowDocWgtBs TBowDocWgtBs::NewPreCalcWgt(const PBowDocBs& BowDocBs,
636   const TFltV& WordWgtV, const bool& PutUniteNorm,
637   const double& _CutWordWgtSumPrc, const int& _MnWordFq,
638   const TIntV& _DIdV) {
639      PBowDocWgtBs DocWgtBs=TBowDocWgtBs::New(BowDocBs->GetSig());
640      DocWgtBs->WordWgtType=bwwtPreCalc;
641      DocWgtBs->CutWordWgtSumPrc=_CutWordWgtSumPrc;
642      DocWgtBs->MnWordFq=_MnWordFq;
643      if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DocWgtBs->DIdV);}
644      else {DocWgtBs->DIdV=_DIdV;}
645      int Docs=DocWgtBs->GetDocs();
646      int AllDocs=BowDocBs->GetDocs();
647      int AllWords=BowDocBs->GetWords();
648      EAssert(AllWords == WordWgtV.Len());
649      DocWgtBs->WordFqV.Gen(AllWords);
650      DocWgtBs->DocSpVV.Gen(AllDocs);
651      for (int DIdN=0; DIdN<Docs; DIdN++) {
652          int DId=DocWgtBs->GetDId(DIdN);
653          int DocWIds=BowDocBs->GetDocWIds(DId);
654          PBowSpV DocSpV=TBowSpV::New(DId, DocWIds);
655          DocWgtBs->DocSpVV[DId]=DocSpV;
656          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
657              int DocWId; double DocWordFq;
658              BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
659              TStr WordStr=BowDocBs->GetWordStr(DocWId); 
660              if (BowDocBs->GetWordFq(DocWId)>=_MnWordFq){
661                  DocSpV->AddWIdWgt(DocWId, DocWordFq*WordWgtV[DocWId]);
662              }
663              DocWgtBs->WordFqV[DocWId] += DocWordFq;
664          }
665          DocSpV->CutLowWgtWords(_CutWordWgtSumPrc);
666          if (PutUniteNorm) { DocSpV->PutUnitNorm(); }
667      }
668      return DocWgtBs;
669  }
670  PBowDocWgtBs TBowDocWgtBs::NewSvmWgt(
671     const PBowDocBs& BowDocBs,
672     const PBowDocWgtBs& BowDocWgtBs,
673     const TIntV& _TrainDIdV,
674     const double& SvmCostParam,
675     const int& MxTimePerCat,
676     const bool& NegFeaturesP,
677     const TIntV& _DIdV,
678     const bool& PutUniteNormP,
679     const double& _CutWordWgtSumPrc,
680     const int& _MnWordFq) {
681      PBowDocWgtBs DocWgtBs=TBowDocWgtBs::New(BowDocBs->GetSig());
682      DocWgtBs->WordWgtType=bwwtSvm;
683      DocWgtBs->CutWordWgtSumPrc=_CutWordWgtSumPrc;
684      DocWgtBs->MnWordFq=_MnWordFq;
685      if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DocWgtBs->DIdV);}
686      else {DocWgtBs->DIdV=_DIdV;}
687      const int Docs=DocWgtBs->DIdV.Len();
688      const int AllDocs=BowDocBs->GetDocs();
689      const int AllWords=BowDocBs->GetWords();
690      EAssert(BowDocBs->IsCats());
691      const int Cats = BowDocBs->GetCats();
692      TIntV TrainDIdV;
693      if (_TrainDIdV.Empty()){
694          TrainDIdV.Gen(BowDocWgtBs->GetDocs(), 0);
695          for (int DIdN = 0; DIdN < BowDocWgtBs->GetDocs(); DIdN++) {
696              TrainDIdV.Add(BowDocWgtBs->GetDId(DIdN));
697          }
698      } else { TrainDIdV = TrainDIdV; }
699      TVec<TFltV> CatWgtVV(Cats);
700      for (int CId = 0; CId < Cats; CId++) {
701          printf("Cat %d/%d\r", CId+1, Cats);
702          PSVMTrainSet CatTrainSet = TBowDocBs2TrainSet::NewBowAllCat(
703              BowDocBs, BowDocWgtBs, CId, TrainDIdV);
704          TIntFltKdV PPCatWIdWgtV, NNCatWIdWgtV;
705          if (CatTrainSet->HasPosNegVecs(5)) {
706              const double SvmUnbalanceParam = 5.0;
707              PSVMModel CatSvmModel = TSVMModel::NewClsLinear(
708                  CatTrainSet, SvmCostParam, SvmUnbalanceParam,
709                  TIntV(), TSVMLearnParam::Lin(MxTimePerCat));
710              TFltV NormalV; CatSvmModel->GetWgtV(NormalV);
711              CatTrainSet->GetKeywords(NormalV, PPCatWIdWgtV, TIntV(), -1, 1.0, 1.0, true);
712              CatTrainSet->GetKeywords(NormalV, NNCatWIdWgtV, TIntV(), -1, -1.0, -1.0, true);
713              TLinAlg::NormalizeLinf(PPCatWIdWgtV); TLinAlg::NormalizeLinf(NNCatWIdWgtV);
714          }
715          TFltV& CatWgtV = CatWgtVV[CId];
716          CatWgtV.Gen(AllWords); CatWgtV.PutAll(0.0);
717          for (int WdN = 0; WdN < PPCatWIdWgtV.Len(); WdN++) {
718              const int CatWId = PPCatWIdWgtV[WdN].Key;
719              const double CatWordWgt = pow(2*PPCatWIdWgtV[WdN].Dat+1.0, 1.0/4.0);
720              CatWgtV[CatWId] += CatWordWgt;
721          }
722          if (NegFeaturesP) {
723              for (int WdN = 0; WdN < NNCatWIdWgtV.Len(); WdN++) {
724                  const int CatWId = NNCatWIdWgtV[WdN].Key;
725                  const double CatWordWgt = pow(2*NNCatWIdWgtV[WdN].Dat+1.0, 1.0/4.0);
726                  CatWgtV[CatWId] += CatWordWgt;
727              }
728          }
729          TLinAlg::Normalize(CatWgtV);
730      }
731      printf("\n");
732      DocWgtBs->WordFqV.Gen(AllWords);
733      DocWgtBs->DocSpVV.Gen(AllDocs);
734      for (int DIdN=0; DIdN<Docs; DIdN++) {
735          printf("Doc %d/%d\r", DIdN+1, Docs);
736          const int DId=DocWgtBs->GetDId(DIdN);
737          const int DocWIds=BowDocBs->GetDocWIds(DId);
738          PBowSpV DocSpV=TBowSpV::New(DId, DocWIds);
739          DocWgtBs->DocSpVV[DId]=DocSpV;
740          const int DocCIds = BowDocBs->GetDocCIds(DId);
741          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
742              int DocWId; double DocWordFq;
743              BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
744              TStr WordStr=BowDocBs->GetWordStr(DocWId); 
745              if (BowDocBs->GetWordFq(DocWId)>=_MnWordFq){
746                  double WordWgt = 0.0;
747                  for (int DocCatN = 0; DocCatN < DocCIds; DocCatN++) {
748                      const int DocCatId = BowDocBs->GetDocCId(DId, DocCatN);
749                      WordWgt += CatWgtVV[DocCatId][DocWId];
750                  }
751                  DocSpV->AddWIdWgt(DocWId, DocWordFq*WordWgt);
752              }
753              DocWgtBs->WordFqV[DocWId] += DocWordFq;
754          }
755          DocSpV->CutLowWgtWords(_CutWordWgtSumPrc);
756          if (PutUniteNormP) { DocSpV->PutUnitNorm(); }
757      }
758      printf("\n");
759      return DocWgtBs;
760  }
761  PBowDocWgtBs TBowDocWgtBs::NewBinSvmWgt(
762     const PBowDocBs& BowDocBs,
763     const PBowDocWgtBs& BowDocWgtBs,
764     const TStr& CatNm,
765     const TIntV& TrainDIdV,
766     const double& SvmCostParam,
767     const double& SvmUnbalanceParam,
768     const double& MnWgt,
769     const bool& NegFeaturesP,
770     const bool& PutUniteNormP,
771     const bool& AvgNormalP,
772     const TIntV& _DIdV,
773     const double& _CutWordWgtSumPrc,
774     const int& _MnWordFq) {
775      PBowDocWgtBs DocWgtBs=TBowDocWgtBs::New(BowDocBs->GetSig());
776      DocWgtBs->WordWgtType=bwwtSvm;
777      DocWgtBs->CutWordWgtSumPrc=_CutWordWgtSumPrc;
778      DocWgtBs->MnWordFq=_MnWordFq;
779      if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DocWgtBs->DIdV);}
780      else {DocWgtBs->DIdV=_DIdV;}
781      const int Docs=DocWgtBs->DIdV.Len();
782      const int AllDocs=BowDocBs->GetDocs();
783      const int AllWords=BowDocBs->GetWords();
784      EAssert(BowDocBs->IsCatNm(CatNm));
785      const int CId = BowDocBs->GetCId(CatNm);
786      PSVMTrainSet CatTrainSet = TBowDocBs2TrainSet::NewBowAllCat(
787          BowDocBs, BowDocWgtBs, CId, TrainDIdV);
788      TIntFltKdV PPCatWIdWgtV, NNCatWIdWgtV;
789      EAssert(CatTrainSet->HasPosNegVecs(5));
790      PSVMModel CatSvmModel = TSVMModel::NewClsLinear(
791          CatTrainSet, SvmCostParam, SvmUnbalanceParam);
792      TFltV NormalV; CatSvmModel->GetWgtV(NormalV);
793      CatTrainSet->GetKeywords(NormalV, PPCatWIdWgtV, TIntV(), -1, 1.0, 1.0, AvgNormalP);
794      CatTrainSet->GetKeywords(NormalV, NNCatWIdWgtV, TIntV(), -1, -1.0, -1.0, AvgNormalP);
795      TLinAlg::NormalizeLinf(PPCatWIdWgtV); TLinAlg::NormalizeLinf(NNCatWIdWgtV);
796      TFltV CatWgtV; CatWgtV.Gen(AllWords); CatWgtV.PutAll(MnWgt);
797      for (int WdN = 0; WdN < PPCatWIdWgtV.Len(); WdN++) {
798          const int CatWId = PPCatWIdWgtV[WdN].Key;
799          const double CatWordWgt = pow(2*PPCatWIdWgtV[WdN].Dat+1.0, 1.0/4.0);
800          CatWgtV[CatWId] += CatWordWgt;
801      }
802      if (NegFeaturesP) {
803          for (int WdN = 0; WdN < NNCatWIdWgtV.Len(); WdN++) {
804              const int CatWId = NNCatWIdWgtV[WdN].Key;
805              const double CatWordWgt = pow(2*NNCatWIdWgtV[WdN].Dat+1.0, 1.0/4.0);
806              CatWgtV[CatWId] += CatWordWgt;
807          }
808      }
809      DocWgtBs->WordFqV.Gen(AllWords);
810      DocWgtBs->DocSpVV.Gen(AllDocs);
811      for (int DIdN=0; DIdN<Docs; DIdN++) {
812          const int DId=DocWgtBs->GetDId(DIdN);
813          const int DocWIds=BowDocBs->GetDocWIds(DId);
814          PBowSpV DocSpV=TBowSpV::New(DId, DocWIds);
815          DocWgtBs->DocSpVV[DId]=DocSpV;
816          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
817              int DocWId; double DocWordFq;
818              BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, DocWordFq);
819              TStr WordStr=BowDocBs->GetWordStr(DocWId); 
820              const double WordWgt = CatWgtV[DocWId];
821              DocSpV->AddWIdWgt(DocWId, DocWordFq*WordWgt);
822              DocWgtBs->WordFqV[DocWId] += DocWordFq;
823          }
824          DocSpV->CutLowWgtWords(_CutWordWgtSumPrc);
825          if (PutUniteNormP) { DocSpV->PutUnitNorm(); }
826      }
827      return DocWgtBs;
828  }
829  TBowWordWgtType TBowDocWgtBs::GetWordWgtTypeFromStr(const TStr& Nm){
830    TStr UcNm=Nm.GetUc();
831    if (UcNm=="UNDEF"){return bwwtUndef;}
832    else if (UcNm=="EQ"){return bwwtEq;}
833    else if (UcNm=="NRMEQ"){return bwwtNrmEq;}
834    else if (UcNm=="BIN"){return bwwtNrmBin;}
835    else if (UcNm=="NRM01"){return bwwtNrm01;}
836    else if (UcNm=="NRMTFIDF"){return bwwtNrmTFIDF;}
837    else if (UcNm=="LOGDFNRMTFIDF"){return bwwtLogDFNrmTFIDF;}
838    else if (UcNm=="NRMTFICF"){return bwwtNrmTFICF;}
839    else if (UcNm=="PRECALC"){return bwwtPreCalc;}
840    else if (UcNm=="SVM"){return bwwtSvm;}
841    else {return bwwtUndef;}
842  }
843  void TBowDocWgtBs::GetSimDIdV(
844   const PBowSpV& RefBowSpV, const PBowSim& BowSim,
845   TFltIntKdV& SimDIdKdV, const bool& RefBowSpVInclude) const {
846    int Docs=GetDocs();
847    SimDIdKdV.Gen(Docs, 0);
848    for (int DIdN=0; DIdN<Docs; DIdN++){
849      int DId=GetDId(DIdN);
850      PBowSpV DocBowSpV=GetSpV(DId);
851      if ((RefBowSpVInclude)||(!RefBowSpV->IsDId())||(RefBowSpV->GetDId()!=DocBowSpV->GetDId())){
852        double Sim=BowSim->GetSim(RefBowSpV, DocBowSpV);
853        SimDIdKdV.Add(TFltIntKd(Sim, DId));
854      }
855    }
856    SimDIdKdV.Sort(false);
857  }
858  void TBowDocWgtBs::SaveTxtSimDIdV(
859   const PSOut& SOut, const PBowDocBs& BowDocBs,
860   const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
861   const int& TopHits, const double& MnSim, const int& TopDocWords,
862   const char& SepCh) const {
863    SOut->PutStr("Query Document:\n");
864    if (RefBowSpV->IsDId()){
865      int RefDId=RefBowSpV->GetDId();
866      TStr RefDocNm=BowDocBs->GetDocNm(RefDId);
867      SOut->PutStr(RefDocNm, "   Document '%s'");
868      SOut->PutLn();
869    }
870    RefBowSpV->SaveTxt(SOut, BowDocBs, TopDocWords, SepCh);
871    SOut->PutLn();
872    int OutDocs=TopHits;
873    if ((OutDocs==-1)||(OutDocs>=SimDIdKdV.Len())){OutDocs=SimDIdKdV.Len();}
874    for (int OutDocN=0; OutDocN<OutDocs; OutDocN++){
875      double Sim=SimDIdKdV[OutDocN].Key;
876      int DId=SimDIdKdV[OutDocN].Dat;
877      TStr DocNm=BowDocBs->GetDocNm(DId);
878      PBowSpV DocSpV=GetSpV(DId);
879      if (Sim<MnSim){break;}
880      SOut->PutInt(OutDocN+1, "%d.");
881      SOut->PutStr(DocNm, "   Document '%s'");
882      SOut->PutFlt(Sim, "   Similarity: %g");
883      SOut->PutLn();
884      DocSpV->SaveTxt(SOut, BowDocBs, TopDocWords, SepCh);
885      SOut->PutLn();
886    }
887  }
888  void TBowDocWgtBs::SaveXmlSimDIdV(
889   const PSOut& SOut, const PBowDocBs& BowDocBs,
890   const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
891   const int& TopHits, const double& MnSim) const {
892    SOut->PutStr("<SimilaritySearchResults>");
893    SOut->PutStr("<QueryDocument");
894    if (RefBowSpV->IsDId()){
895      int RefDId=RefBowSpV->GetDId();
896      TStr RefDocNm=BowDocBs->GetDocNm(RefDId);
897      SOut->PutStr(TInt::GetStr(RefDId, "  DocId=\"%d\""));
898      SOut->PutStr(TStr::GetStr(RefDocNm, "  DocNm=\"%s\""));
899    }
900    SOut->PutStr(">"); SOut->PutLn();
901    RefBowSpV->SaveXml(SOut, BowDocBs);
902    SOut->PutStr("</QueryDocument>"); SOut->PutLn();
903    int OutDocs=TopHits;
904    if ((OutDocs==-1)||(OutDocs>=SimDIdKdV.Len())){OutDocs=SimDIdKdV.Len();}
905    for (int OutDocN=0; OutDocN<OutDocs; OutDocN++){
906      double Sim=SimDIdKdV[OutDocN].Key;
907      int DId=SimDIdKdV[OutDocN].Dat;
908      TStr DocNm=BowDocBs->GetDocNm(DId);
909      PBowSpV DocSpV=GetSpV(DId);
910      if (Sim<MnSim){break;}
911      SOut->PutStr("<Hit");
912      SOut->PutStr(TInt::GetStr(OutDocN+1, " Num=\"%d\""));
913      SOut->PutStr(TInt::GetStr(DId, "  DocId=\"%d\""));
914      SOut->PutStr(TStr::GetStr(DocNm, "  DocNm=\"%s\""));
915      SOut->PutStr(TFlt::GetStr(Sim, "  Sim=\"%g\""));
916      SOut->PutStr(">"); SOut->PutLn();
917      DocSpV->SaveXml(SOut, BowDocBs);
918      SOut->PutStr("</Hit>"); SOut->PutLn();
919    }
920    SOut->PutStr("</SimilaritySearchResults>");
921  }
922  void TBowDocWgtBs::SaveTxtStat(
923   const TStr& StatFNm, const PBowDocBs& BowDocBs,
924   const bool& SaveWordsP, const bool& SaveCatsP, const bool& SaveDocsP) const {
925    TFOut StatSOut(StatFNm); FILE* fStat=StatSOut.GetFileId();
926    if (SaveWordsP){
927      int DIds=GetDocs();
928      int WIds=GetWords();
929      TIntIntFltPrH WIdToWFqWWgtPrH(WIds);
930      for (int DIdN=0; DIdN<DIds; DIdN++){
931        int DId=GetDId(DIdN);
932        PBowSpV DocSpV=GetSpV(DId);
933        int DocWIds=DocSpV->GetWIds();
934        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
935          int DocWId; double DocWgt;
936          DocSpV->GetWIdWgt(DocWIdN, DocWId, DocWgt);
937          TIntFltPr& WFqWWgtPr=WIdToWFqWWgtPrH.AddDat(DocWId);
938          WFqWWgtPr.Val1++; WFqWWgtPr.Val2+=DocWgt;
939        }
940      }
941      TFltIntPrV AvgWWgtWIdPrV(WIdToWFqWWgtPrH.Len(), 0);
942      for (int WIdN=0; WIdN<WIdToWFqWWgtPrH.Len(); WIdN++){
943        int WId=WIdToWFqWWgtPrH.GetKey(WIdN);
944        TIntFltPr& WFqWWgtPr=WIdToWFqWWgtPrH.AddDat(WId);
945        double AvgWWgt=0;
946        if (WFqWWgtPr.Val1>0){AvgWWgt=WFqWWgtPr.Val2/WFqWWgtPr.Val1;}
947        AvgWWgtWIdPrV.Add(TFltIntPr(AvgWWgt, WId));
948      }
949      AvgWWgtWIdPrV.Sort(false);
950      fprintf(fStat, "\nRank Word-Weight Document-Frequency Word-String\n\n");
951      {for (int WIdN=0; WIdN<AvgWWgtWIdPrV.Len(); WIdN++){
952        double AvgWWgt=AvgWWgtWIdPrV[WIdN].Val1;
953        int WId=AvgWWgtWIdPrV[WIdN].Val2;
954        TStr WordStr=BowDocBs->GetWordStr(AvgWWgtWIdPrV[WIdN].Val2);
955        double WordDFq=GetWordFq(WId);
956        fprintf(fStat, "%d.\t%.3f\t%g\t'%s'\n",
957         1+WIdN, AvgWWgt, WordDFq, WordStr.CStr());
958      }}
959    }
960    if (SaveCatsP){}
961    if (SaveDocsP){
962      fprintf(fStat, "\n\nDocument-Statistics\n\n");
963      int Docs=GetDocs();
964      for (int DIdN=0; DIdN<Docs; DIdN++){
965        int DId=GetDId(DIdN);
966        TStr DocNm=BowDocBs->GetDocNm(DId);
967        PBowSpV DocSpV=GetSpV(DId);
968        int DocWIds=DocSpV->GetWIds();
969        fprintf(fStat, "DId:%d   Name:'%s' (%d Words):", DId, DocNm.CStr(), DocWIds);
970        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
971          int DocWId; double DocWgt;
972          DocSpV->GetWIdWgt(DocWIdN, DocWId, DocWgt);
973          TStr WordStr=BowDocBs->GetWordStr(DocWId);
974          fprintf(fStat, " '%s':%.3f", WordStr.CStr(), DocWgt);
975        }
976        fprintf(fStat, "\n");
977      }
978    }
979  }
980  const TStr TBowDocWgtBs::BowDocWgtBsFExt=".Boww";
981  PBowDocBs TBowDocBs::New(
982   const PSwSet& SwSet, const PStemmer& Stemmer, const PNGramBs& NGramBs){
983    PBowDocBs BowDocBs=New();
984    if (NGramBs.Empty()){
985      BowDocBs->PutSwSet(SwSet); BowDocBs->PutStemmer(Stemmer);
986    } else {
987      BowDocBs->PutNGramBs(NGramBs);
988    }
989    return BowDocBs;
990  }
991  void TBowDocBs::AddDocs(const PBowDocBs& BowDocBs)
992  {
993    for (int WordN = 0; WordN < BowDocBs->GetWords(); WordN++)
994    {
995      TStr WordStr = BowDocBs->GetWordStr(WordN);
996      int WordId = -1;
997      if (!this->IsWordStr(WordStr, WordId))
998      {
999        this->AddWordStr(WordStr);
1000      }
1001    }
1002    for (int DocId = 0; DocId < BowDocBs->GetDocs(); DocId++)
1003    {
1004      TIntFltPrV NewDoc;
1005      for (int WIdN = 0; WIdN < BowDocBs->GetDocWIds(DocId); WIdN++)
1006      {
1007        int WId = BowDocBs->GetDocWId(DocId, WIdN);
1008        double WFq = BowDocBs->GetDocWFq(DocId, WIdN);
1009        TStr WordStr = BowDocBs->GetWordStr(WId);
1010        int WIdCmn = this->GetWId(WordStr);
1011        NewDoc.Add(TIntFltPr(WIdCmn, WFq));
1012      }
1013      this->AddDoc("", TStrV(), NewDoc);
1014    }
1015  }
1016  void TBowDocBs::AssertOk() const {
1017    int Docs=GetDocs();
1018    for (int DId=0; DId<Docs; DId++){
1019      PBowSpV DocSpV=GetDocSpV(DId);
1020      IAssert(DId==DocSpV->GetDId());
1021      TStr DocNm=GetDocNm(DId);
1022      for (int WIdN=0; WIdN<DocSpV->GetWIds(); WIdN++){
1023        int WId; double Wgt; DocSpV->GetWIdWgt(WIdN, WId, Wgt);
1024        TStr WordStr=GetWordStr(WId);
1025      }
1026      int CIds=GetDocCIds(DId);
1027      for (int CIdN=0; CIdN<CIds; CIdN++){
1028        int CId=GetDocCId(DId, CIdN);
1029        TStr CatNm=GetCatNm(CId);
1030      }
1031    }
1032    int TrainDocs=GetTrainDocs();
1033    for (int TrainDIdN=0; TrainDIdN<TrainDocs; TrainDIdN++){
1034      int TrainDId=GetTrainDId(TrainDIdN);
1035      PBowSpV TrainDocSpV=GetDocSpV(TrainDId);
1036    }
1037    int TestDocs=GetTestDocs();
1038    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
1039      int TestDId=GetTestDId(TestDIdN);
1040      PBowSpV TestDocSpV=GetDocSpV(TestDId);
1041    }
1042  }
1043  void TBowDocBs::GetWordStrVFromHtml(const TStr& HtmlStr, TStrV& WordStrV) const {
1044    WordStrV.Clr();
1045    if (!NGramBs.Empty()){
1046      NGramBs->GetNGramStrV(HtmlStr, WordStrV);
1047    } else {
1048      PSIn HtmlSIn=TStrIn::New(HtmlStr);
1049      THtmlLx HtmlLx(HtmlSIn);
1050      while (HtmlLx.Sym!=hsyEof){
1051        if (HtmlLx.Sym==hsyStr){
1052          TStr WordStr=HtmlLx.UcChA;
1053          if ((SwSet.Empty())||(!SwSet->IsIn(WordStr))){
1054            if (!Stemmer.Empty()){
1055              WordStr=Stemmer->GetStem(WordStr);}
1056            WordStrV.Add(WordStr);
1057          }
1058        }
1059        HtmlLx.GetSym();
1060      }
1061    }
1062  }
1063  int TBowDocBs::AddDoc(const TStr& _DocNm,
1064   const TStrV& CatNmV, const TIntFltPrV& WIdWgtPrV){
1065    TStr DocNm=_DocNm;
1066    if (DocNm.Empty()){DocNm=TInt::GetStr(GetDocs());}
1067    int DId=-1;
1068    if (!DocNmToDescStrH.IsKey(DocNm, DId)){
1069      DId=DocNmToDescStrH.AddKey(DocNm);
1070      DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==DocSpVV.Len()-1);
1071      DocStrV.Add();
1072      DocCIdVV.Add(); IAssert(DId==DocCIdVV.Len()-1);
1073    }
1074    TIntV& DocCIdV=DocCIdVV[DId];
1075    DocCIdV.Gen(CatNmV.Len(), 0);
1076    for (int CatNmN=0; CatNmN<CatNmV.Len(); CatNmN++){
1077      int CId=CatNmToFqH.AddKey(CatNmV[CatNmN]);
1078      CatNmToFqH[CId]++; DocCIdV.Add(CId);
1079    }
1080    DocCIdV.Sort();
1081    TIntFltH DocWIdToWgtH;
1082    for (int WordN=0; WordN<WIdWgtPrV.Len(); WordN++){
1083      int WId=WIdWgtPrV[WordN].Val1;
1084      IAssert(IsWId(WId));
1085      DocWIdToWgtH.AddDat(WId, WIdWgtPrV[WordN].Val2);
1086    }
1087    PBowSpV DocSpV=DocSpVV[DId];
1088    DocSpV->GenMx(DocWIdToWgtH.Len());
1089    for (int DocWordN=0; DocWordN<DocWIdToWgtH.Len(); DocWordN++){
1090      int WId=DocWIdToWgtH.GetKey(DocWordN);
1091      double Wgt=DocWIdToWgtH[DocWordN];
1092      WordStrToDescH[WId].Fq++;
1093      DocSpV->AddWIdWgt(WId, Wgt);
1094    }
1095    DocSpV->Sort();
1096    return DId;
1097  }
1098  int TBowDocBs::AddDoc(const TStr& _DocNm,
1099   const TStrV& CatNmV, const TStrV& WordStrV, const TStr& DocStr){
1100    TStr DocNm=_DocNm;
1101    if (DocNm.Empty()){DocNm=TInt::GetStr(GetDocs());}
1102    int DId=-1;
1103    if (!DocNmToDescStrH.IsKey(DocNm, DId)){
1104      DId=DocNmToDescStrH.AddKey(DocNm);
1105      DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==DocSpVV.Len()-1);
1106      DocStrV.Add(DocStr);
1107      DocCIdVV.Add(); IAssert(DId==DocCIdVV.Len()-1);
1108    }
1109    TIntV& DocCIdV=DocCIdVV[DId];
1110    DocCIdV.Gen(CatNmV.Len(), 0);
1111    for (int CatNmN=0; CatNmN<CatNmV.Len(); CatNmN++){
1112      int CId=CatNmToFqH.AddKey(CatNmV[CatNmN]);
1113      CatNmToFqH[CId]++; DocCIdV.Add(CId);
1114    }
1115    DocCIdV.Sort();
1116    TStrIntH DocWordStrToFqH;
1117    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
1118      DocWordStrToFqH.AddDat(WordStrV[WordStrN])++;}
1119    PBowSpV DocSpV=DocSpVV[DId];
1120    DocSpV->GenMx(DocWordStrToFqH.Len());
1121    for (int DocWordStrN=0; DocWordStrN<DocWordStrToFqH.Len(); DocWordStrN++){
1122      TStr WordStr=DocWordStrToFqH.GetKey(DocWordStrN);
1123      int Fq=DocWordStrToFqH[DocWordStrN];
1124      int WId=WordStrToDescH.AddKey(WordStr);
1125      WordStrToDescH[WId].Fq++;
1126      DocSpV->AddWIdWgt(WId, Fq);
1127    }
1128    DocSpV->Sort();
1129    return DId;
1130  }
1131  int TBowDocBs::AddHtmlDoc(const TStr& DocNm, const TStrV& CatNmV,
1132   const TStr& HtmlDocStr, const bool& SaveDocP){
1133    TStrV WordStrV; GetWordStrVFromHtml(HtmlDocStr, WordStrV);
1134    int DocId;
1135    if (SaveDocP){DocId=AddDoc(DocNm, CatNmV, WordStrV, HtmlDocStr);}
1136    else {DocId=AddDoc(DocNm, CatNmV, WordStrV, "");}
1137    return DocId;
1138  }
1139  void TBowDocBs::GetAllDIdV(TIntV& DIdV) const {
1140    int Docs=GetDocs();
1141    DIdV.Gen(Docs);
1142    for (int DId=0; DId<Docs; DId++){
1143      DIdV[DId]=DId;}
1144  }
1145  bool TBowDocBs::IsDocWordStr(const int& DId, const TStr& WordStr) const {
1146    int WId;
1147    if (IsWordStr(WordStr, WId)){
1148      return DocSpVV[DId]->IsWId(WId);
1149    } else {
1150      return false;
1151    }
1152  }
1153  void TBowDocBs::GetTopCatV(const int& TopCats, TIntStrPrV& FqCatNmPrV) const {
1154    CatNmToFqH.GetDatKeyPrV(FqCatNmPrV);
1155    FqCatNmPrV.Sort(false);
1156    FqCatNmPrV.Trunc(TopCats);
1157  }
1158  void TBowDocBs::SetHOTrainTestDIdV(
1159   const double& TestDocsPrc, TRnd& Rnd){
1160    TIntV AllDIdV; GetAllDIdV(AllDIdV);
1161    AllDIdV.Shuffle(Rnd);
1162    int TestDocs=int(AllDIdV.Len()*TestDocsPrc);
1163    int MxTrainDIdN=AllDIdV.Len()-1-TestDocs;
1164    AllDIdV.GetSubValV(0, MxTrainDIdN, TrainDIdV);
1165    AllDIdV.GetSubValV(MxTrainDIdN+1, AllDIdV.Len()-1, TestDIdV);
1166  }
1167  void TBowDocBs::SetCVTrainTestDIdV(
1168   const int& Folds, const int& FoldN, TRnd& Rnd){
1169    TIntV AllDIdV; GetAllDIdV(AllDIdV);
1170    if (Folds==1){
1171      TrainDIdV=AllDIdV;
1172      TestDIdV=AllDIdV;
1173    } else {
1174      AllDIdV.Shuffle(Rnd);
1175      int MnTestDIdN=(FoldN*AllDIdV.Len())/Folds;
1176      int MxTestDIdN=(((FoldN+1)*AllDIdV.Len())/Folds)-1;
1177      AllDIdV.GetSubValV(0, MnTestDIdN-1, TrainDIdV);
1178      TIntV UpTrainDIdV;
1179      AllDIdV.GetSubValV(MxTestDIdN+1, AllDIdV.Len()-1, UpTrainDIdV);
1180      TrainDIdV.AddV(UpTrainDIdV);
1181      AllDIdV.GetSubValV(MnTestDIdN, MxTestDIdN, TestDIdV);
1182    }
1183  }
1184  PBowDocBs TBowDocBs::GetLimWordRelFqDocBs(
1185   const double& MnWordFqPrc, const double& MxWordFqPrc) const {
1186    PBowDocBs BowDocBs=TBowDocBs::New();
1187    BowDocBs->DocNmToDescStrH=DocNmToDescStrH;
1188    BowDocBs->CatNmToFqH=CatNmToFqH;
1189    BowDocBs->DocCIdVV=DocCIdVV;
1190    BowDocBs->TrainDIdV=TrainDIdV;
1191    BowDocBs->TestDIdV=TestDIdV;
1192    int Docs=GetDocs();
1193    int Words=GetWords();
1194    for (int WId=0; WId<Words; WId++){
1195      TStr WordStr=GetWordStr(WId);
1196      int WordFq=GetWordFq(WId);
1197      double WordFqPrc=double(WordFq)/double(Docs);
1198      if ((MnWordFqPrc<WordFqPrc)&&(WordFqPrc<MxWordFqPrc)){
1199        BowDocBs->WordStrToDescH.AddDat(WordStr).Fq=WordFq;
1200      }
1201    }
1202    for (int DId=0; DId<Docs; DId++){
1203      PBowSpV DocSpV=DocSpVV[DId]; int WIds=DocSpV->GetWIds();
1204      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
1205      for (int WIdN=0; WIdN<WIds; WIdN++){
1206        int WId; double WordFq; DocSpV->GetWIdWgt(WIdN, WId, WordFq);
1207        TStr WordStr=GetWordStr(WId);
1208        int NewWId;
1209        if (BowDocBs->IsWordStr(WordStr, NewWId)){
1210          BowDocBs->DocSpVV.Last()->AddWIdWgt(NewWId, WordFq);
1211        }
1212      }
1213      BowDocBs->DocSpVV.Last()->Trunc();
1214    }
1215    return BowDocBs;
1216  }
1217  PBowDocBs TBowDocBs::GetLimWordAbsFqDocBs(const int& MnWordFq) const {
1218    PBowDocBs BowDocBs=TBowDocBs::New();
1219    BowDocBs->DocNmToDescStrH=DocNmToDescStrH;
1220    BowDocBs->CatNmToFqH=CatNmToFqH;
1221    BowDocBs->DocCIdVV=DocCIdVV;
<span onclick='openModal()' class='match'>1222    BowDocBs->TrainDIdV=TrainDIdV;
1223    BowDocBs->TestDIdV=TestDIdV;
1224    int Docs=GetDocs();
1225    int Words=GetWords();
1226    for (int WId=0; WId<Words; WId++){
1227      TStr WordStr=GetWordStr(WId);
</span>1228      int WordFq=GetWordFq(WId);
1229      if (MnWordFq<=WordFq){
1230        BowDocBs->WordStrToDescH.AddDat(WordStr).Fq=WordFq;
1231      }
1232    }
1233    for (int DId=0; DId<Docs; DId++){
1234      PBowSpV DocSpV=DocSpVV[DId]; int WIds=DocSpV->GetWIds();
1235      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
1236      for (int WIdN=0; WIdN<WIds; WIdN++){
1237        int WId; double WordFq; DocSpV->GetWIdWgt(WIdN, WId, WordFq);
1238        TStr WordStr=GetWordStr(WId);
1239        int NewWId;
1240        if (BowDocBs->IsWordStr(WordStr, NewWId)){
1241          BowDocBs->DocSpVV.Last()->AddWIdWgt(NewWId, WordFq);
1242        }
1243      }
1244      BowDocBs->DocSpVV.Last()->Trunc();
1245    }
1246    return BowDocBs;
1247  }
1248  PBowDocBs TBowDocBs::GetSubDocSet(const TIntV& DIdV) const {
1249    PBowDocBs BowDocBs=TBowDocBs::New();
1250    BowDocBs->DocSpVV.Gen(DIdV.Len(), 0);
1251    BowDocBs->DocCIdVV.Gen(DIdV.Len(), 0);
1252    int Docs=DIdV.Len();
1253    for (int DIdN=0; DIdN<Docs; DIdN++){
1254      int DId=DIdV[DIdN];
1255      TStr DocNm=DocNmToDescStrH.GetKey(DId);
1256      PBowSpV SpV=DocSpVV[DId]; int WIds=SpV->GetWIds();
1257      const TIntV& DocCIdV=DocCIdVV[DId];
1258      int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
1259      PBowSpV NewSpV=TBowSpV::New(NewDId, WIds);
1260      BowDocBs->DocSpVV.Add(NewSpV); IAssert(NewDId==BowDocBs->DocSpVV.Len()-1);
1261      for (int WIdN=0; WIdN<WIds; WIdN++){
1262        int WId; double WordFq; SpV->GetWIdWgt(WIdN, WId, WordFq);
1263        TStr WordStr=GetWordStr(WId);
1264        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
1265        BowDocBs->WordStrToDescH[NewWId].Fq++;
1266        NewSpV->AddWIdWgt(NewWId, WordFq);
1267      }
1268      NewSpV->Sort();
1269      BowDocBs->DocCIdVV.Add(); IAssert(NewDId+1==BowDocBs->DocCIdVV.Len());
1270      BowDocBs->DocCIdVV.Last().Gen(DocCIdV.Len(), 0);
1271      for (int DocCIdN=0; DocCIdN<DocCIdV.Len(); DocCIdN++){
1272        int CId=DocCIdV[DocCIdN];
1273        TStr CatNm=GetCatNm(CId);
1274        const int NewCId=BowDocBs->CatNmToFqH.AddKey(CatNm);
1275        BowDocBs->CatNmToFqH[NewCId]++;
1276        BowDocBs->DocCIdVV.Last().Add(NewCId);
1277      }
1278    }
1279    return BowDocBs;
1280  }
1281  PBowDocBs TBowDocBs::GetInvDocBs() const {
1282    int Docs=GetDocs();
1283    int Words=GetWords();
1284    PBowDocBs InvBowDocBs=TBowDocBs::New();
1285    InvBowDocBs->WordStrToDescH.Gen(Docs);
1286    TIntV WordFqV(Words);
1287    for (int DId=0; DId<Docs; DId++){
1288      TStr DocNm=GetDocNm(DId);
1289      PBowSpV DocSpV=GetDocSpV(DId);
1290      int DocWIds=DocSpV->GetWIds();
1291      InvBowDocBs->WordStrToDescH.AddDat(DocNm)=TBowWordDesc(DocWIds, 1, 1);
1292      for (int WIdN=0; WIdN<DocWIds; WIdN++){
1293        int WId; double Wgt; DocSpV->GetWIdWgt(WIdN, WId, Wgt);
1294        WordFqV[WId]++;
1295      }
1296    }
1297    InvBowDocBs->DocNmToDescStrH.Gen(Words);
1298    InvBowDocBs->DocSpVV.Gen(Words, 0);
1299    InvBowDocBs->DocCIdVV.Gen(Words, 0);
1300    for (int WId=0; WId<Words; WId++){
1301      TStr WordStr=GetWordStr(WId);
1302      int InvDId=InvBowDocBs->DocNmToDescStrH.AddKey(WordStr); IAssert(WId==InvDId);
1303      int InvDocWIds=WordFqV[WId];
1304      PBowSpV BowSpV=TBowSpV::New(InvDId, InvDocWIds);
1305      InvBowDocBs->DocSpVV.Add(BowSpV);
1306    }
1307    {for (int DId=0; DId<Docs; DId++){
1308      PBowSpV DocSpV=GetDocSpV(DId);
1309      int DocWIds=DocSpV->GetWIds();
1310      for (int WIdN=0; WIdN<DocWIds; WIdN++){
1311        int WId; double Wgt; DocSpV->GetWIdWgt(WIdN, WId, Wgt);
1312        InvBowDocBs->DocSpVV[WId]->AddWIdWgt(DId, 1);
1313      }
1314    }}
1315    {for (int WId=0; WId<Words; WId++){
1316      InvBowDocBs->DocSpVV[WId]->Sort();
1317      IAssert(InvBowDocBs->DocSpVV[WId]->Len()==InvBowDocBs->DocSpVV[WId]->Reserved());
1318    }}
1319    InvBowDocBs->AssertOk();
1320    return InvBowDocBs;
1321  }
1322  void TBowDocBs::SaveTxtStat(const TStr& StatFNm,
1323   const bool& SaveWordsP, const bool& SaveCatsP, const bool& SaveDocsP) const {
1324    TFOut StatSOut(StatFNm); FILE* fStat=StatSOut.GetFileId();
1325    if (SaveWordsP){
1326      fprintf(fStat, "\nDocument-Frequency Word-Statistics\n\n");
1327      TBowWordDescStrPrV WordDescStrPrV;
1328      WordStrToDescH.GetDatKeyPrV(WordDescStrPrV);
1329      WordDescStrPrV.Sort(false);
1330      for (int WordN=0; WordN<WordDescStrPrV.Len(); WordN++){
1331        fprintf(fStat, "%d.\t%d\t'%s'\n",
1332         1+WordN, (int)WordDescStrPrV[WordN].Val1.Fq, WordDescStrPrV[WordN].Val2.CStr());
1333      }
1334    }
1335    if (SaveCatsP){
1336      fprintf(fStat, "\nCategory-Statistics\n\n");
1337      TIntStrPrV FqCatNmPrV; CatNmToFqH.GetDatKeyPrV(FqCatNmPrV);
1338      FqCatNmPrV.Sort(false);
1339      for (int FqCatNmPrN=0; FqCatNmPrN<FqCatNmPrV.Len(); FqCatNmPrN++){
1340        fprintf(fStat, "%d\t'%s'\n",
1341         (int)FqCatNmPrV[FqCatNmPrN].Val1, FqCatNmPrV[FqCatNmPrN].Val2.CStr());
1342      }
1343    }
1344    if (SaveDocsP){
1345      fprintf(fStat, "Document-Statistics\n\n");
1346      int Docs=GetDocs();
1347      for (int DId=0; DId<Docs; DId++){
1348        TStr DocNm=GetDocNm(DId);
1349        TStr DescStr=GetDocDescStr(DId);
1350        int DocWIds=GetDocWIds(DId);
1351        fprintf(fStat, "DId:%d   Name:'%s' Desc: '%s' (%d Words):",
1352         DId, DocNm.CStr(), DescStr.CStr(), DocWIds);
1353        int DocCIds=GetDocCIds(DId);
1354        if (DocCIds>0){
1355          fprintf(fStat, "Cats:[");
1356          for (int DocCIdN=0; DocCIdN<DocCIds; DocCIdN++){
1357            int CId=GetDocCId(DId, DocCIdN);
1358            TStr CatNm=GetCatNm(CId);
1359            if (DocCIdN>0){fprintf(fStat, ", ");}
1360            fprintf(fStat, "'%s'", CatNm.CStr());
1361          }
1362          fprintf(fStat, "] ");
1363        }
1364        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
1365          int WId; double WordFq;
1366          GetDocWIdFq(DId, DocWIdN, WId, WordFq);
1367          TStr WordStr=GetWordStr(WId);
1368          fprintf(fStat, " '%s':%g", WordStr.CStr(), WordFq);
1369        }
1370        fprintf(fStat, "\n");
1371      }
1372    }
1373  }
1374  PBowSpV TBowDocBs::GetSpVFromHtmlStr(
1375   const TStr& HtmlStr, const PBowDocWgtBs& BowDocWgtBs) const {
1376    TStrV WordStrV; GetWordStrVFromHtml(HtmlStr, WordStrV);
1377    TIntH DocWIdToFqH(100);
1378    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
1379      int WId;
1380      if (IsWordStr(WordStrV[WordStrN], WId)){
1381        DocWIdToFqH.AddDat(WId)++;
1382      }
1383    }
1384    PBowSpV DocSpV;
1385    if (BowDocWgtBs.Empty()){
1386      int DocWIds=DocWIdToFqH.Len();
1387      DocSpV=TBowSpV::New(-1, DocWIds);
1388      TInt DocWId; TInt DocWordFq;
1389      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
1390        DocWIdToFqH.GetKeyDat(DocWIdN, DocWId, DocWordFq);
1391        DocSpV->AddWIdWgt(DocWId, DocWordFq);
1392      }
1393      DocSpV->Sort();
1394    } else {
1395      int MnWordFq=BowDocWgtBs->GetMnWordFq();
1396      int Docs=BowDocWgtBs->GetDocs();
1397      int DocWIds=DocWIdToFqH.Len();
1398      DocSpV=TBowSpV::New(-1, DocWIds);
1399      TInt DocWId; TInt DocWordFq;
1400      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
1401        DocWIdToFqH.GetKeyDat(DocWIdN, DocWId, DocWordFq);
1402        if (GetWordFq(DocWId)>=MnWordFq){
1403          double WordDf=BowDocWgtBs->GetWordFq(DocWId);
1404          double WordIDf=0;
1405          if (WordDf>0){WordIDf=log(double(Docs)/WordDf);}
1406          double DocWordWgt=DocWordFq*WordIDf;
1407          DocSpV->AddWIdWgt(DocWId, DocWordWgt);
1408        }
1409      }
1410      DocSpV->Sort();
1411      DocSpV->CutLowWgtWords(BowDocWgtBs->GetCutWordWgtSumPrc());
1412      DocSpV->PutUnitNorm();
1413    }
1414    return DocSpV;
1415  }
1416  PBowSpV TBowDocBs::GetSpVFromHtmlFile(
1417   const TStr& HtmlFNm, const PBowDocWgtBs& BowDocWgtBs) const {
1418    PSIn HtmlSIn=TFIn::New(HtmlFNm);
1419    TStr HtmlStr=TStr::LoadTxt(HtmlSIn);
1420    return GetSpVFromHtmlStr(HtmlStr, BowDocWgtBs);
1421  }
1422  PBowSpV TBowDocBs::GetSpVFromWIdWgtPrV(
1423   const TIntFltPrV& WIdWgtPrV, const PBowDocWgtBs& BowDocWgtBs) const {
1424    PBowSpV DocSpV;
1425    if (BowDocWgtBs.Empty()){
1426      int DocWIds=WIdWgtPrV.Len();
1427      DocSpV=TBowSpV::New(-1, DocWIds);
1428      TInt DocWId; TInt DocWordFq;
1429      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
1430        DocSpV->AddWIdWgt(WIdWgtPrV[DocWIdN].Val1, WIdWgtPrV[DocWIdN].Val2);
1431      }
1432      DocSpV->Sort();
1433    } else {
1434      int MnWordFq=BowDocWgtBs->GetMnWordFq();
1435      int Docs=BowDocWgtBs->GetDocs();
1436      int DocWIds=WIdWgtPrV.Len();
1437      DocSpV=TBowSpV::New(-1, DocWIds);
1438      TInt DocWId; double DocWordFq;
1439      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
1440        DocWId=WIdWgtPrV[DocWIdN].Val1;
1441        DocWordFq=WIdWgtPrV[DocWIdN].Val2;
1442        if (GetWordFq(DocWId)>=MnWordFq){
1443          double WordDf=BowDocWgtBs->GetWordFq(DocWId);
1444          double WordIDf=0;
1445          if (WordDf>0){WordIDf=log(double(Docs)/WordDf);}
1446          double DocWordWgt=DocWordFq*WordIDf;
1447          DocSpV->AddWIdWgt(DocWId, DocWordWgt);
1448        }
1449      }
1450      DocSpV->Sort();
1451      DocSpV->CutLowWgtWords(BowDocWgtBs->GetCutWordWgtSumPrc());
1452      DocSpV->PutUnitNorm();
1453    }
1454    return DocSpV;
1455  }
1456  const TStr TBowDocBs::BowDocBsFExt=".Bow";
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ontolight.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>237    TStr EvTermFNm=NrFPath+"listMultiLg_All.txt";
238    printf("Loading '%s' ...\n", EvTermFNm.CStr());
239    PSs EvTermSs=TSs::LoadTxt(ssfTabSep, EvTermFNm);
240    int EvTermSs_TermIdFldN=EvTermSs->GetFldX("ID"); IAssert(EvTermSs_TermIdFldN==0);
241    int XLen=EvTermSs->GetXLen(EvTermSs_TermIdFldN);
242    for (int X=1; X<XLen; X++){
243      TStr LangNm=EvTermSs->GetVal(X, 0); 
</pre></code></div>
                <div class="column column_space"><pre><code>1222    BowDocBs->TrainDIdV=TrainDIdV;
1223    BowDocBs->TestDIdV=TestDIdV;
1224    int Docs=GetDocs();
1225    int Words=GetWords();
1226    for (int WId=0; WId<Words; WId++){
1227      TStr WordStr=GetWordStr(WId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    