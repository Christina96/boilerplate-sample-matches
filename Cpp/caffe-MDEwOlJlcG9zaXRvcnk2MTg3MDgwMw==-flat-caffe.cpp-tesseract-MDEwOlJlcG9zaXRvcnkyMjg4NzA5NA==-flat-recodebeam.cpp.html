
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.428571428571429%, Tokens: 11</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-caffe.cpp</h3>
            <pre><code>1  #ifdef WITH_PYTHON_LAYER
2  #include "boost/python.hpp"
3  namespace bp = boost::python;
4  #endif
5  #include <gflags/gflags.h>
6  #include <glog/logging.h>
7  #include <cstring>
8  #include <map>
9  #include <string>
10  #include <utility>
11  #include <vector>
12  #include "boost/algorithm/string.hpp"
13  #include "boost/make_shared.hpp"
14  #include "caffe/caffe.hpp"
15  #include "caffe/training_utils.hpp"
16  #include "caffe/util/performance.hpp"
17  #include "caffe/util/signal_handler.h"
18  #include "caffe/util/bbox_util.hpp"
19  #ifdef USE_MLSL
20  #include "caffe/multinode/mlsl.hpp"
21  #include "caffe/multinode/multi_sync.hpp"
22  #include "caffe/multinode/async_param_server.hpp"
23  #endif &bsol;* USE_MLSL */
24  using caffe::Blob;
25  using caffe::Caffe;
26  using caffe::Net;
27  using caffe::Layer;
28  using caffe::Solver;
29  using caffe::shared_ptr;
30  using caffe::string;
31  using caffe::Timer;
32  using caffe::vector;
33  using std::ostringstream;
34  DEFINE_string(gpu, "",
35      "Optional; run in GPU mode on given device IDs separated by ','."
36      "Use '-gpu all' to run on all available GPUs. The effective training "
37      "batch size is multiplied by the number of devices.");
38  DEFINE_string(solver, "",
39      "The solver definition protocol buffer text file.");
40  DEFINE_string(model, "",
41      "The model definition protocol buffer text file.");
42  DEFINE_string(phase, "",
43      "Optional; network phase (TRAIN or TEST). Only used for 'time'.");
44  DEFINE_int32(level, 0,
45      "Optional; network level.");
46  DEFINE_string(stage, "",
47      "Optional; network stages (not to be confused with phase), "
48      "separated by ','.");
49  DEFINE_string(snapshot, "",
50      "Optional; the snapshot solver state to resume training.");
51  DEFINE_string(weights, "",
52      "Optional; the pretrained weights to initialize finetuning, "
53      "separated by ','. Cannot be set simultaneously with snapshot.");
54  DEFINE_int32(iterations, 50,
55      "The number of iterations to run.");
56  DEFINE_string(sigint_effect, "stop",
57               "Optional; action to take when a SIGINT signal is received: "
58                "snapshot, stop or none.");
59  DEFINE_string(sighup_effect, "snapshot",
60               "Optional; action to take when a SIGHUP signal is received: "
61               "snapshot, stop or none.");
62  DEFINE_bool(forward_only, false,
63      "Optional; Execute only forward pass");
64  DEFINE_string(engine, "",
65      "Optional; Engine sequence in format: engine:subengine_1,subengine_2,...");
66  DEFINE_string(collect_dir, "collect_out",
67      "Optional; Directory with reference binary files");
68  DEFINE_string(compare_output_dir, "compare_out",
69      "Optional; Directory with output files");
70  DEFINE_double(epsilon, 1e-3, "Optional; Layer output comparison error");
71  DEFINE_bool(detection, false,
72      "Optional; Enables detection for testing. "
73      "By default it is false and classification is on.");
74  DEFINE_bool(fast_compare, false,
75      "Optional; Break layer comparison after fast_compare_max errors found");
76  DEFINE_bool(sampling, false,
77      "Optional; Caffe test with sampling mode");
78  DEFINE_int32(fast_compare_max, 50,
79      "Optional; Max errors for fast_compare");
80  DEFINE_double(buffer_filler, std::nanf(""), "Buffer filler for compare tool");
81  DEFINE_int32(n_group, 1, "Optional; if given, it specifies how many trees"
82               " we want in the async forest");
83  DEFINE_int32(n_server, 0, "Optional; if given, it specifies how many parts"
84               "The model is splited to. I.e. how many process you have for param server");
85  typedef int (*BrewFunction)();
86  typedef std::map<caffe::string, BrewFunction> BrewMap;
87  BrewMap g_brew_map;
88  #define RegisterBrewFunction(func) \
89  namespace { \
90  class __Registerer_##func { \
91   public: &bsol;* NOLINT */ \
92    __Registerer_##func() { \
93      g_brew_map[#func] = &func; \
94    } \
95  }; \
96  __Registerer_##func g_registerer_##func; \
97  }
98  static BrewFunction GetBrewFunction(const caffe::string& name) {
99    if (g_brew_map.count(name)) {
100      return g_brew_map[name];
101    } else {
102      LOG(ERROR) << "Available caffe actions:";
103      for (BrewMap::iterator it = g_brew_map.begin();
104           it != g_brew_map.end(); ++it) {
105        LOG(ERROR) << "\t" << it->first;
106      }
107      LOG(FATAL) << "Unknown action: " << name;
108      return NULL;  
109    }
110  }
111  static void get_gpus(vector<int>* gpus) {
112    if (FLAGS_gpu == "all") {
113      int count = 0;
114  #ifndef CPU_ONLY
115      CUDA_CHECK(cudaGetDeviceCount(&count));
116  #else
117      NO_GPU;
118  #endif
119      for (int i = 0; i < count; ++i) {
120        gpus->push_back(i);
121      }
122    } else if (FLAGS_gpu.size()) {
123      vector<string> strings;
124      boost::split(strings, FLAGS_gpu, boost::is_any_of(","));
125      for (int i = 0; i < strings.size(); ++i) {
126        gpus->push_back(boost::lexical_cast<int>(strings[i]));
127      }
128    } else {
129      CHECK_EQ(gpus->size(), 0);
130    }
131  }
132  caffe::Phase get_phase_from_flags(caffe::Phase default_value) {
133    if (FLAGS_phase == "")
134      return default_value;
135    if (FLAGS_phase == "TRAIN")
136      return caffe::TRAIN;
137    if (FLAGS_phase == "TEST")
138      return caffe::TEST;
139    LOG(FATAL) << "phase must be \"TRAIN\" or \"TEST\"";
140    return caffe::TRAIN;  
141  }
142  int device_query() {
143    LOG(INFO) << "Querying GPUs " << FLAGS_gpu;
144    vector<int> gpus;
145    get_gpus(&gpus);
146    for (int i = 0; i < gpus.size(); ++i) {
147      caffe::Caffe::SetDevice(gpus[i]);
148      caffe::Caffe::DeviceQuery();
149    }
150    return 0;
151  }
152  RegisterBrewFunction(device_query);
153  void CopyLayers(caffe::Solver<float>* solver, const std::string& model_list) {
154    std::vector<std::string> model_names;
155    boost::split(model_names, model_list, boost::is_any_of(",") );
156    for (int i = 0; i < model_names.size(); ++i) {
157      LOG(INFO) << "Finetuning from " << model_names[i];
158      solver->net()->CopyTrainedLayersFrom(model_names[i]);
159      for (int j = 0; j < solver->test_nets().size(); ++j) {
160        solver->test_nets()[j]->CopyTrainedLayersFrom(model_names[i]);
161      }
162    }
163  }
164  caffe::SolverAction::Enum GetRequestedAction(
165      const std::string& flag_value) {
166    if (flag_value == "stop") {
167      return caffe::SolverAction::STOP;
168    }
169    if (flag_value == "snapshot") {
170      return caffe::SolverAction::SNAPSHOT;
171    }
172    if (flag_value == "none") {
173      return caffe::SolverAction::NONE;
174    }
175    LOG(FATAL) << "Invalid signal effect \""<< flag_value << "\" was specified";
176    return caffe::SolverAction::UNKNOWN;
177  }
178  int train() {
179    CHECK_GT(FLAGS_solver.size(), 0) << "Need a solver definition to train.";
180    CHECK(!FLAGS_snapshot.size() || !FLAGS_weights.size())
181        << "Give a snapshot to resume training or weights to finetune "
182        "but not both.";
183    caffe::SolverParameter solver_param;
184    if (!caffe::ReadProtoFromTextFile(FLAGS_solver, &solver_param)) {
185      caffe::MultiPhaseSolverParameter multi_solver_params;
186      CHECK(caffe::ReadProtoFromTextFile(FLAGS_solver, &multi_solver_params))
187        << "Failed to parse SolverParameter file: "  <<  FLAGS_solver;
188      return multiphase_train(
189        &multi_solver_params,
190        FLAGS_solver,
191        FLAGS_engine,
192        FLAGS_level,
193        FLAGS_stage);
194    }
195    use_flags(
196      &solver_param,
197      FLAGS_solver,
198      FLAGS_engine,
199      FLAGS_level,
200      FLAGS_stage);
201    if (FLAGS_gpu.size() == 0
202        && solver_param.solver_mode() == caffe::SolverParameter_SolverMode_GPU) {
203        if (solver_param.has_device_id()) {
204            FLAGS_gpu = "" +
205                boost::lexical_cast<string>(solver_param.device_id());
206        } else {  
207            FLAGS_gpu = "" + boost::lexical_cast<string>(0);
208        }
209    }
210    vector<int> gpus;
211    get_gpus(&gpus);
212    if (gpus.size() == 0) {
213      LOG(INFO) << "Use CPU.";
214      Caffe::set_mode(Caffe::CPU);
215    } else {
216      ostringstream s;
217      for (int i = 0; i < gpus.size(); ++i) {
218        s << (i ? ", " : "") << gpus[i];
219      }
220      LOG(INFO) << "Using GPUs " << s.str();
221  #ifndef CPU_ONLY
222      cudaDeviceProp device_prop;
223      for (int i = 0; i < gpus.size(); ++i) {
224        cudaGetDeviceProperties(&device_prop, gpus[i]);
225        LOG(INFO) << "GPU " << gpus[i] << ": " << device_prop.name;
226      }
227  #endif
228      solver_param.set_device_id(gpus[0]);
229      Caffe::SetDevice(gpus[0]);
230      Caffe::set_mode(Caffe::GPU);
231      Caffe::set_solver_count(gpus.size());
232    }
233    caffe::SignalHandler signal_handler(
234          GetRequestedAction(FLAGS_sigint_effect),
235          GetRequestedAction(FLAGS_sighup_effect));
236    shared_ptr<caffe::Solver<float> >
237        solver(caffe::SolverRegistry<float>::CreateSolver(solver_param));
238    solver->SetActionFunction(signal_handler.GetActionFunction());
239    if (FLAGS_snapshot.size()) {
240      LOG(INFO) << "Resuming from " << FLAGS_snapshot;
241      solver->Restore(FLAGS_snapshot.c_str());
242    } else if (FLAGS_weights.size()) {
243      CopyLayers(solver.get(), FLAGS_weights);
244    }
245  #ifdef USE_MLSL
246    if (caffe::mn::is_multinode()) {
247      caffe::mn::barrier();
248      LOG(INFO) << "Configuring multinode setup";
249      if (!caffe::mn::is_param_server()) {
250        caffe::MultiSync<float> sync(solver);
251        LOG(INFO) << "Starting Multi-node Optimization in MLSL environment";
252        sync.run();
253      } else {
254        caffe::mn::AsyncParamServer<float> aps(solver);
255        LOG(INFO) << "Starting Parameter Server";
256        aps.Run();
257      }
258    } else
259  #endif &bsol;* USE_MLSL */
260    if (gpus.size() > 1) {
261      caffe::P2PSync<float> sync(solver, NULL, solver->param());
262      sync.Run(gpus);
263    } else {
264      LOG(INFO) << "Starting Optimization";
265      solver->Solve();
266    }
267    LOG(INFO) << "Optimization Done.";
268    return 0;
269  }
270  RegisterBrewFunction(train);
271  int test_detection(Net<float>& caffe_net) {
272    std::map<int, std::map<int,
273      std::vector<std::pair<float, int> > > > all_true_pos;
274    std::map<int, std::map<int,
275      std::vector<std::pair<float, int> > > > all_false_pos;
276    std::map<int, std::map<int, int> > all_num_pos;
277    PERFORMANCE_INIT_MONITOR();
278    for (int i = 0; i < FLAGS_iterations; ++i) {
279  #ifdef DEBUG
280      LOG(INFO) << "Iteration: " << i;
281  #endif
282      float iter_loss;
283      const vector<Blob<float>*>& result = caffe_net.Forward(&iter_loss);
284      for (int j = 0; j < result.size(); ++j) {
285        const float* result_vec = result[j]->cpu_data();
286        int num_det = result[j]->height();
287        for (int k = 0; k < num_det; ++k) {
288          int item_id = static_cast<int>(result_vec[k * 5]);
289          int label = static_cast<int>(result_vec[k * 5 + 1]);
290          if (item_id == -1) {
291            if (all_num_pos[j].find(label) == all_num_pos[j].end()) {
292              all_num_pos[j][label] = static_cast<int>(result_vec[k * 5 + 2]);
293            } else {
294              all_num_pos[j][label] += static_cast<int>(result_vec[k * 5 + 2]);
295            }
296          } else {
297            float score = result_vec[k * 5 + 2];
298            int tp = static_cast<int>(result_vec[k * 5 + 3]);
299            int fp = static_cast<int>(result_vec[k * 5 + 4]);
300            if (tp == 0 && fp == 0) {
301              continue;
302            }
303            all_true_pos[j][label].push_back(std::make_pair(score, tp));
304            all_false_pos[j][label].push_back(std::make_pair(score, fp));
305          }
306        }
307      }
308    }
309    for (int i = 0; i < all_true_pos.size(); ++i) {
310      if (all_true_pos.find(i) == all_true_pos.end()) {
311        LOG(FATAL) << "Missing output_blob true_pos: " << i;
312      }
313      const std::map<int, std::vector<std::pair<float, int> > >& true_pos =
314          all_true_pos.find(i)->second;
315      if (all_false_pos.find(i) == all_false_pos.end()) {
316        LOG(FATAL) << "Missing output_blob false_pos: " << i;
317      }
318      const std::map<int, std::vector<std::pair<float, int> > >& false_pos =
319          all_false_pos.find(i)->second;
320      if (all_num_pos.find(i) == all_num_pos.end()) {
321        LOG(FATAL) << "Missing output_blob num_pos: " << i;
322      }
323      const std::map<int, int>& num_pos = all_num_pos.find(i)->second;
324      std::map<int, float> APs;
325      float mAP = 0.;
326      for (std::map<int, int>::const_iterator it = num_pos.begin();
327           it != num_pos.end(); ++it) {
328        int label = it->first;
329        int label_num_pos = it->second;
330        if (true_pos.find(label) == true_pos.end()) {
331          LOG(WARNING) << "Missing true_pos for label: " << label;
332          continue;
333        }
334        const std::vector<std::pair<float, int> >& label_true_pos =
335            true_pos.find(label)->second;
336        if (false_pos.find(label) == false_pos.end()) {
337          LOG(WARNING) << "Missing false_pos for label: " << label;
338          continue;
339        }
340        const std::vector<std::pair<float, int> >& label_false_pos =
341            false_pos.find(label)->second;
342        std::vector<float> prec, rec;
343        caffe::ComputeAP(label_true_pos, label_num_pos, label_false_pos,
344                  "11point", &prec, &rec, &(APs[label]));
345        mAP += APs[label];
346      }
347      mAP /= num_pos.size();
348      const int output_blob_index = caffe_net.output_blob_indices()[i];
349      const string& output_name = caffe_net.blob_names()[output_blob_index];
350      LOG(INFO) << "    Test net output #" << i << ": " << output_name << " = "
351                << mAP;
352    }
353    return 0;
354  }
355  int test() {
356    CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to score.";
357    CHECK_GT(FLAGS_weights.size(), 0) << "Need model weights to score.";
358    vector<string> stages = get_stages_from_flags(FLAGS_stage);
359    vector<int> gpus;
360    get_gpus(&gpus);
361    if (gpus.size() != 0) {
362      LOG(INFO) << "Use GPU with device ID " << gpus[0];
363  #ifndef CPU_ONLY
364      cudaDeviceProp device_prop;
365      cudaGetDeviceProperties(&device_prop, gpus[0]);
366      LOG(INFO) << "GPU device name: " << device_prop.name;
367  #endif
368      Caffe::SetDevice(gpus[0]);
369      Caffe::set_mode(Caffe::GPU);
370    } else {
371      LOG(INFO) << "Use CPU.";
372      Caffe::set_mode(Caffe::CPU);
373    }
374    Net<float> caffe_net(FLAGS_model, caffe::TEST, FLAGS_level, &stages, NULL,
375                         FLAGS_engine);
376    caffe_net.CopyTrainedLayersFrom(FLAGS_weights);
377    if (FLAGS_sampling)
378        return 0;
379    LOG(INFO) << "Running for " << FLAGS_iterations << " iterations.";
380    if (FLAGS_detection) {
381      test_detection(caffe_net);
382      return 0;
383    }
384    vector<int> test_score_output_id;
385    vector<float> test_score;
386    float loss = 0;
387    for (int i = 0; i < FLAGS_iterations; ++i) {
388      float iter_loss;
389      const vector<Blob<float>*>& result =
390          caffe_net.Forward(&iter_loss);
391      loss += iter_loss;
392      int idx = 0;
393      for (int j = 0; j < result.size(); ++j) {
394        const float* result_vec = result[j]->cpu_data();
395        for (int k = 0; k < result[j]->count(); ++k, ++idx) {
396          const float score = result_vec[k];
397          if (i == 0) {
398            test_score.push_back(score);
399            test_score_output_id.push_back(j);
400          } else {
401            test_score[idx] += score;
402          }
403           const std::string& output_name = caffe_net.blob_names()[
404              caffe_net.output_blob_indices()[j]];
405          LOG(INFO) << "Batch " << i << ", " << output_name << " = " << score;
406        }
407      }
408    }
409    loss /= FLAGS_iterations;
410    LOG(INFO) << "Loss: " << loss;
411    for (int i = 0; i < test_score.size(); ++i) {
412      const std::string& output_name = caffe_net.blob_names()[
413          caffe_net.output_blob_indices()[test_score_output_id[i]]];
414      const float loss_weight = caffe_net.blob_loss_weights()[
415          caffe_net.output_blob_indices()[test_score_output_id[i]]];
416      std::ostringstream loss_msg_stream;
417      const float mean_score = test_score[i] / FLAGS_iterations;
418      if (loss_weight) {
419        loss_msg_stream << " (* " << loss_weight
420                        << " = " << loss_weight * mean_score << " loss)";
421      }
422      LOG(INFO) << output_name << " = " << mean_score << loss_msg_stream.str();
423    }
424    return 0;
425  }
426  RegisterBrewFunction(test);
427  int time() {
428    CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to time.";
429    caffe::Phase phase = get_phase_from_flags(caffe::TRAIN);
430    vector<string> stages = get_stages_from_flags(FLAGS_stage);
431    vector<int> gpus;
432    get_gpus(&gpus);
433    if (gpus.size() != 0) {
434      LOG(INFO) << "Use GPU with device ID " << gpus[0];
435      Caffe::SetDevice(gpus[0]);
436      Caffe::set_mode(Caffe::GPU);
437    } else {
438      LOG(INFO) << "Use CPU.";
439      Caffe::set_mode(Caffe::CPU);
440    }
441    Net<float> caffe_net(FLAGS_model, phase, FLAGS_level, &stages, NULL,
442                         FLAGS_engine);
443    PERFORMANCE_INIT_MONITOR();
444    LOG(INFO) << "Performing Forward";
445    float initial_loss;
446    caffe_net.Forward(&initial_loss);
447    LOG(INFO) << "Initial loss: " << initial_loss;
448    if (!FLAGS_forward_only) {
449      LOG(INFO) << "Performing Backward";
450      caffe_net.Backward();
451    }
452    const vector<shared_ptr<Layer<float> > >& layers = caffe_net.layers();
453    const vector<vector<Blob<float>*> >& bottom_vecs = caffe_net.bottom_vecs();
454    const vector<vector<Blob<float>*> >& top_vecs = caffe_net.top_vecs();
455    const vector<vector<bool> >& bottom_need_backward =
456        caffe_net.bottom_need_backward();
457    int warmup_iterations = 5;
458    for (int j = 0; j < warmup_iterations; ++j) {
459      if (j == warmup_iterations - 1)
460        PERFORMANCE_START_RESETTING_MONITOR();
461      for (int i = 0; i < layers.size(); ++i) {
462        layers[i]->Forward(bottom_vecs[i], top_vecs[i]);
463      }
464      if (!FLAGS_forward_only) {
465        for (int i = layers.size() - 1; i >= 0; --i) {
466          layers[i]->Backward(top_vecs[i], bottom_need_backward[i],
467                              bottom_vecs[i]);
468        }
469      }
470    }
471    PERFORMANCE_STOP_RESETTING_MONITOR();
472    LOG(INFO) << "*** Benchmark begins ***";
473    LOG(INFO) << "Testing for " << FLAGS_iterations << " iterations.";
474    Timer total_timer;
475    total_timer.Start();
476    Timer forward_timer;
477    Timer backward_timer;
478    Timer timer;
479    std::vector<double> forward_time_per_layer(layers.size(), 0.0);
480    std::vector<double> backward_time_per_layer(layers.size(), 0.0);
481    double forward_time = 0.0;
482    std::vector<double> forward_time_iteration(FLAGS_iterations, 0.0);
<span onclick='openModal()' class='match'>483    double backward_time = 0.0;
484    for (int j = 0; j < FLAGS_iterations; ++j) {
485      Timer iter_timer;
486      iter_timer.Start();
487      forward_timer.Start();
488      for (int i = 0; i < layers.size(); ++i) {
</span>489        timer.Start();
490        layers[i]->Forward(bottom_vecs[i], top_vecs[i]);
491        forward_time_per_layer[i] += timer.MicroSeconds();
492      }
493      forward_time_iteration[j] = forward_timer.MicroSeconds();
494      forward_time += forward_timer.MicroSeconds();
495      if (!FLAGS_forward_only) {
496        backward_timer.Start();
497        for (int i = layers.size() - 1; i >= 0; --i) {
498          timer.Start();
499          layers[i]->Backward(top_vecs[i], bottom_need_backward[i],
500                              bottom_vecs[i]);
501          backward_time_per_layer[i] += timer.MicroSeconds();
502        }
503        backward_time += backward_timer.MicroSeconds();
504        LOG(INFO) << "Iteration: " << j + 1 << " forward-backward time: "
505          << iter_timer.MilliSeconds() << " ms.";
506      } else {
507        LOG(INFO) << "Iteration: " << j + 1 << " forward time: "
508          << iter_timer.MilliSeconds() << " ms.";
509      }
510    }
511    LOG(INFO) << "Average time per layer: ";
512    for (int i = 0; i < layers.size(); ++i) {
513      const caffe::string& layername = layers[i]->layer_param().name();
514      LOG(INFO) << std::setfill(' ') << std::setw(10) << layername <<
515        "\tforward: " << forward_time_per_layer[i] / 1000 /
516        FLAGS_iterations << " ms.";
517      if (!FLAGS_forward_only) {
518        LOG(INFO) << std::setfill(' ') << std::setw(10) << layername  <<
519          "\tbackward: " << backward_time_per_layer[i] / 1000 /
520          FLAGS_iterations << " ms.";
521      }
522    }
523    total_timer.Stop();
524    for (int j = 0; j < FLAGS_iterations; ++j)
525      LOG(INFO) << "###" << j << ":" << forward_time_iteration[j] / 1000 << " ms.";
526    LOG(INFO) << "Average Forward pass: " << forward_time / 1000 /
527      FLAGS_iterations << " ms.";
528    if (!FLAGS_forward_only) {
529      LOG(INFO) << "Average Backward pass: " << backward_time / 1000 /
530        FLAGS_iterations << " ms.";
531      LOG(INFO) << "Average Forward-Backward: " << total_timer.MilliSeconds() /
532        FLAGS_iterations << " ms.";
533    }
534    LOG(INFO) << "Total Time: " << total_timer.MilliSeconds() << " ms.";
535    LOG(INFO) << "*** Benchmark ends ***";
536    return 0;
537  }
538  RegisterBrewFunction(time);
539  #include <stdio.h>
540  #include "caffe/util/compareToolUtilities.h"
541  int collect() {
542    #ifndef DETERMINISTIC
543      LOG(ERROR) << "Recompile caffe with DETERMINISTIC to run collect tool";
544      return 1;
545    #endif
546    CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition!";
547    vector<int> gpus;
548    get_gpus(&gpus);
549    bool use_gpu = (gpus.size() != 0);
550    if (use_gpu) {
551      LOG(INFO) << "Use GPU with device ID " << gpus[0];
552      Caffe::SetDevice(gpus[0]);
553      Caffe::set_mode(Caffe::GPU);
554    } else {
555      LOG(INFO) << "Use CPU.";
556      Caffe::set_mode(Caffe::CPU);
557    }
558    boost::filesystem::path dir(FLAGS_collect_dir);
559    if (!boost::filesystem::exists(dir)) {
560        if (!boost::filesystem::create_directory(dir)) {
561            LOG(ERROR) << "Could not create directory for output files";
562        }
563    }
564    return collectAndCheckLayerData(true, use_gpu, FLAGS_collect_dir.c_str());
565  }
566  RegisterBrewFunction(collect);
567  int compare() {
568    #ifndef DETERMINISTIC
569      LOG(ERROR) << "Recompile caffe with DETERMINISTIC to run compare tool";
570      return 1;
571    #endif
572    CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition!";
573    vector<int> gpus;
574    get_gpus(&gpus);
575    bool use_gpu = (gpus.size() != 0);
576    if (use_gpu) {
577      LOG(INFO) << "Use GPU with device ID " << gpus[0];
578      Caffe::SetDevice(gpus[0]);
579      Caffe::set_mode(Caffe::GPU);
580    } else {
581      LOG(INFO) << "Use CPU.";
582      Caffe::set_mode(Caffe::CPU);
583    }
584    boost::filesystem::path dir(FLAGS_compare_output_dir);
585    if (!boost::filesystem::exists(dir)) {
586        if (!boost::filesystem::create_directory(dir)) {
587            LOG(ERROR) << "Could not create directory for output files";
588        }
589    }
590    return collectAndCheckLayerData(false,
591      use_gpu, FLAGS_compare_output_dir.c_str());
592  }
593  RegisterBrewFunction(compare);
594  int main(int argc, char** argv) {
595    FLAGS_alsologtostderr = 1;
596    gflags::SetVersionString(AS_STRING(CAFFE_VERSION));
597    gflags::SetUsageMessage("command line brew\n"
598        "usage: caffe <command> <args>\n\n"
599        "commands:\n"
600        "  train           train or finetune a model\n"
601        "  test            score a model\n"
602        "  device_query    show GPU diagnostic information\n"
603        "  time            benchmark model execution time\n"
604        "  collect         collects layer data on specified device\n"
605        "  compare         collects layer data using inputs from other device");
606    caffe::GlobalInit(&argc, &argv);
607  #ifdef USE_MLSL
608    caffe::mn::nGroup = FLAGS_n_group;
609    if (caffe::mn::nGroup <= 0) {
610        LOG(ERROR) << "Invalid number of group: " << caffe::mn::nGroup;
611        return 1;
612    }
613    caffe::mn::nServer = FLAGS_n_server;
614    caffe::mn::init(&argc, &argv);
615    if (caffe::mn::get_group_size() <= 0) {
616        LOG(ERROR) << "Invalid group size: " << caffe::mn::get_group_size();
617        return 1;
618    }
619    CHECK_EQ(caffe::mn::get_world_size(),
620             caffe::mn::nGroup * caffe::mn::get_group_size() + caffe::mn::nServer);
621    if (caffe::mn::nGroup > 1) {
622      CHECK_GE(caffe::mn::nServer, 1)
623        << "Expect there exists parameter server to support multiple groups";
624    }
625    if (caffe::mn::get_node_rank() == 0) {
626      LOG(INFO) << "Number of groups: " << caffe::mn::nGroup
627                << ", group size: " << caffe::mn::get_group_size()
628                << ", number of parameter servers: " << caffe::mn::nServer;
629    }
630  #endif
631    if (argc == 2) {
632  #ifdef WITH_PYTHON_LAYER
633      try {
634  #endif
635        int ret = GetBrewFunction(caffe::string(argv[1]))();
636        return ret;
637  #ifdef WITH_PYTHON_LAYER
638      } catch (bp::error_already_set) {
639        PyErr_Print();
640        return 1;
641      }
642  #endif
643    } else {
644      gflags::ShowUsageWithFlagsRestrict(argv[0], "tools/caffe");
645    }
646    return 0;
647  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam.cpp</h3>
            <pre><code>1  #include "recodebeam.h"
2  #include "networkio.h"
3  #include "pageres.h"
4  #include "unicharcompress.h"
5  #include <algorithm> 
6  namespace tesseract {
7  const int RecodeBeamSearch::kBeamWidths[RecodedCharID::kMaxCodeLen + 1] = {
8      5, 10, 16, 16, 16, 16, 16, 16, 16, 16,
9  };
10  static const char *kNodeContNames[] = {"Anything", "OnlyDup", "NoDup"};
11  void RecodeNode::Print(int null_char, const UNICHARSET &unicharset,
12                         int depth) const {
13    if (code == null_char) {
14      tprintf("null_char");
15    } else {
16      tprintf("label=%d, uid=%d=%s", code, unichar_id,
17              unicharset.debug_str(unichar_id).c_str());
18    }
19    tprintf(" score=%g, c=%g,%s%s%s perm=%d, hash=%" PRIx64, score, certainty,
20            start_of_dawg ? " DawgStart" : "", start_of_word ? " Start" : "",
21            end_of_word ? " End" : "", permuter, code_hash);
22    if (depth > 0 && prev != nullptr) {
23      tprintf(" prev:");
24      prev->Print(null_char, unicharset, depth - 1);
25    } else {
26      tprintf("\n");
27    }
28  }
29  RecodeBeamSearch::RecodeBeamSearch(const UnicharCompress &recoder,
30                                     int null_char, bool simple_text, Dict *dict)
31      : recoder_(recoder),
32        beam_size_(0),
33        top_code_(-1),
34        second_code_(-1),
35        dict_(dict),
36        space_delimited_(true),
37        is_simple_text_(simple_text),
38        null_char_(null_char) {
39    if (dict_ != nullptr && !dict_->IsSpaceDelimitedLang()) {
40      space_delimited_ = false;
41    }
42  }
43  RecodeBeamSearch::~RecodeBeamSearch() {
44    for (auto data : beam_) {
45      delete data;
46    }
47    for (auto data : secondary_beam_) {
48      delete data;
49    }
50  }
51  void RecodeBeamSearch::Decode(const NetworkIO &output, double dict_ratio,
52                                double cert_offset, double worst_dict_cert,
53                                const UNICHARSET *charset, int lstm_choice_mode) {
54    beam_size_ = 0;
55    int width = output.Width();
56    if (lstm_choice_mode) {
57      timesteps.clear();
58    }
59    for (int t = 0; t < width; ++t) {
60      ComputeTopN(output.f(t), output.NumFeatures(), kBeamWidths[0]);
61      DecodeStep(output.f(t), t, dict_ratio, cert_offset, worst_dict_cert,
62                 charset);
63      if (lstm_choice_mode) {
64        SaveMostCertainChoices(output.f(t), output.NumFeatures(), charset, t);
65      }
66    }
67  }
68  void RecodeBeamSearch::Decode(const GENERIC_2D_ARRAY<float> &output,
69                                double dict_ratio, double cert_offset,
70                                double worst_dict_cert,
71                                const UNICHARSET *charset) {
72    beam_size_ = 0;
73    int width = output.dim1();
74    for (int t = 0; t < width; ++t) {
75      ComputeTopN(output[t], output.dim2(), kBeamWidths[0]);
76      DecodeStep(output[t], t, dict_ratio, cert_offset, worst_dict_cert, charset);
77    }
78  }
79  void RecodeBeamSearch::DecodeSecondaryBeams(
80      const NetworkIO &output, double dict_ratio, double cert_offset,
81      double worst_dict_cert, const UNICHARSET *charset, int lstm_choice_mode) {
82    for (auto data : secondary_beam_) {
83      delete data;
84    }
85    secondary_beam_.clear();
86    if (character_boundaries_.size() < 2) {
87      return;
88    }
89    int width = output.Width();
90    unsigned bucketNumber = 0;
91    for (int t = 0; t < width; ++t) {
92      while ((bucketNumber + 1) < character_boundaries_.size() &&
93             t >= character_boundaries_[bucketNumber + 1]) {
94        ++bucketNumber;
95      }
96      ComputeSecTopN(&(excludedUnichars)[bucketNumber], output.f(t),
97                     output.NumFeatures(), kBeamWidths[0]);
98      DecodeSecondaryStep(output.f(t), t, dict_ratio, cert_offset,
99                          worst_dict_cert, charset);
100    }
101  }
102  void RecodeBeamSearch::SaveMostCertainChoices(const float *outputs,
103                                                int num_outputs,
104                                                const UNICHARSET *charset,
105                                                int xCoord) {
106    std::vector<std::pair<const char *, float>> choices;
107    for (int i = 0; i < num_outputs; ++i) {
108      if (outputs[i] >= 0.01f) {
109        const char *character;
110        if (i + 2 >= num_outputs) {
111          character = "";
112        } else if (i > 0) {
113          character = charset->id_to_unichar_ext(i + 2);
114        } else {
115          character = charset->id_to_unichar_ext(i);
116        }
117        size_t pos = 0;
118        while (choices.size() > pos && choices[pos].second > outputs[i]) {
119          pos++;
120        }
121        choices.insert(choices.begin() + pos,
122                       std::pair<const char *, float>(character, outputs[i]));
123      }
124    }
125    timesteps.push_back(choices);
126  }
127  void RecodeBeamSearch::segmentTimestepsByCharacters() {
128    for (unsigned i = 1; i < character_boundaries_.size(); ++i) {
129      std::vector<std::vector<std::pair<const char *, float>>> segment;
130      for (int j = character_boundaries_[i - 1]; j < character_boundaries_[i];
131           ++j) {
132        segment.push_back(timesteps[j]);
133      }
134      segmentedTimesteps.push_back(segment);
135    }
136  }
137  std::vector<std::vector<std::pair<const char *, float>>>
138  RecodeBeamSearch::combineSegmentedTimesteps(
139      std::vector<std::vector<std::vector<std::pair<const char *, float>>>>
140          *segmentedTimesteps) {
141    std::vector<std::vector<std::pair<const char *, float>>> combined_timesteps;
142    for (auto &segmentedTimestep : *segmentedTimesteps) {
143      for (auto &j : segmentedTimestep) {
144        combined_timesteps.push_back(j);
145      }
146    }
147    return combined_timesteps;
148  }
149  void RecodeBeamSearch::calculateCharBoundaries(std::vector<int> *starts,
150                                                 std::vector<int> *ends,
151                                                 std::vector<int> *char_bounds_,
152                                                 int maxWidth) {
153    char_bounds_->push_back(0);
154    for (unsigned i = 0; i < ends->size(); ++i) {
155      int middle = ((*starts)[i + 1] - (*ends)[i]) / 2;
156      char_bounds_->push_back((*ends)[i] + middle);
157    }
158    char_bounds_->pop_back();
159    char_bounds_->push_back(maxWidth);
160  }
161  void RecodeBeamSearch::ExtractBestPathAsLabels(
162      std::vector<int> *labels, std::vector<int> *xcoords) const {
163    labels->clear();
164    xcoords->clear();
165    std::vector<const RecodeNode *> best_nodes;
166    ExtractBestPaths(&best_nodes, nullptr);
167    int t = 0;
168    int width = best_nodes.size();
169    while (t < width) {
170      int label = best_nodes[t]->code;
171      if (label != null_char_) {
172        labels->push_back(label);
173        xcoords->push_back(t);
174      }
175      while (++t < width && !is_simple_text_ && best_nodes[t]->code == label) {
176      }
177    }
178    xcoords->push_back(width);
179  }
180  void RecodeBeamSearch::ExtractBestPathAsUnicharIds(
181      bool debug, const UNICHARSET *unicharset, std::vector<int> *unichar_ids,
182      std::vector<float> *certs, std::vector<float> *ratings,
183      std::vector<int> *xcoords) const {
184    std::vector<const RecodeNode *> best_nodes;
185    ExtractBestPaths(&best_nodes, nullptr);
186    ExtractPathAsUnicharIds(best_nodes, unichar_ids, certs, ratings, xcoords);
187    if (debug) {
188      DebugPath(unicharset, best_nodes);
189      DebugUnicharPath(unicharset, best_nodes, *unichar_ids, *certs, *ratings,
190                       *xcoords);
191    }
192  }
193  void RecodeBeamSearch::ExtractBestPathAsWords(const TBOX &line_box,
194                                                float scale_factor, bool debug,
195                                                const UNICHARSET *unicharset,
196                                                PointerVector<WERD_RES> *words,
197                                                int lstm_choice_mode) {
198    words->truncate(0);
199    std::vector<int> unichar_ids;
200    std::vector<float> certs;
201    std::vector<float> ratings;
202    std::vector<int> xcoords;
203    std::vector<const RecodeNode *> best_nodes;
204    std::vector<const RecodeNode *> second_nodes;
205    character_boundaries_.clear();
206    ExtractBestPaths(&best_nodes, &second_nodes);
207    if (debug) {
208      DebugPath(unicharset, best_nodes);
209      ExtractPathAsUnicharIds(second_nodes, &unichar_ids, &certs, &ratings,
210                              &xcoords);
211      tprintf("\nSecond choice path:\n");
212      DebugUnicharPath(unicharset, second_nodes, unichar_ids, certs, ratings,
213                       xcoords);
214    }
215    ExtractPathAsUnicharIds(best_nodes, &unichar_ids, &certs, &ratings, &xcoords,
216                            &character_boundaries_);
217    int num_ids = unichar_ids.size();
218    if (debug) {
219      DebugUnicharPath(unicharset, best_nodes, unichar_ids, certs, ratings,
220                       xcoords);
221    }
222    int word_end = 0;
223    float prev_space_cert = 0.0f;
224    for (int word_start = 0; word_start < num_ids; word_start = word_end) {
225      for (word_end = word_start + 1; word_end < num_ids; ++word_end) {
226        if (unichar_ids[word_end] == UNICHAR_SPACE) {
227          break;
228        }
229        int index = xcoords[word_end];
230        if (best_nodes[index]->start_of_word) {
231          break;
232        }
233        if (best_nodes[index]->permuter == TOP_CHOICE_PERM &&
234            (!unicharset->IsSpaceDelimited(unichar_ids[word_end]) ||
235             !unicharset->IsSpaceDelimited(unichar_ids[word_end - 1]))) {
236          break;
237        }
238      }
239      float space_cert = 0.0f;
240      if (word_end < num_ids && unichar_ids[word_end] == UNICHAR_SPACE) {
241        space_cert = certs[word_end];
242      }
243      bool leading_space =
244          word_start > 0 && unichar_ids[word_start - 1] == UNICHAR_SPACE;
245      WERD_RES *word_res =
246          InitializeWord(leading_space, line_box, word_start, word_end,
247                         std::min(space_cert, prev_space_cert), unicharset,
248                         xcoords, scale_factor);
249      for (int i = word_start; i < word_end; ++i) {
250        auto *choices = new BLOB_CHOICE_LIST;
251        BLOB_CHOICE_IT bc_it(choices);
252        auto *choice = new BLOB_CHOICE(unichar_ids[i], ratings[i], certs[i], -1,
253                                       1.0f, static_cast<float>(INT16_MAX), 0.0f,
254                                       BCC_STATIC_CLASSIFIER);
255        int col = i - word_start;
256        choice->set_matrix_cell(col, col);
257        bc_it.add_after_then_move(choice);
258        word_res->ratings->put(col, col, choices);
259      }
260      int index = xcoords[word_end - 1];
261      word_res->FakeWordFromRatings(best_nodes[index]->permuter);
262      words->push_back(word_res);
263      prev_space_cert = space_cert;
264      if (word_end < num_ids && unichar_ids[word_end] == UNICHAR_SPACE) {
265        ++word_end;
266      }
267    }
268  }
269  struct greater_than {
270    inline bool operator()(const RecodeNode *&node1, const RecodeNode *&node2) const {
271      return (node1->score > node2->score);
272    }
273  };
274  void RecodeBeamSearch::PrintBeam2(bool uids, int num_outputs,
275                                    const UNICHARSET *charset,
276                                    bool secondary) const {
277    std::vector<std::vector<const RecodeNode *>> topology;
278    std::unordered_set<const RecodeNode *> visited;
279    const std::vector<RecodeBeam *> &beam = !secondary ? beam_ : secondary_beam_;
280    for (int step = beam.size() - 1; step >= 0; --step) {
281      std::vector<const RecodeNode *> layer;
282      topology.push_back(layer);
283    }
284    for (int step = beam.size() - 1; step >= 0; --step) {
285      std::vector<tesseract::RecodePair> &heaps = beam.at(step)->beams_->heap();
286      for (auto &&node : heaps) {
287        int backtracker = 0;
288        const RecodeNode *curr = &node.data();
289        while (curr != nullptr && !visited.count(curr)) {
290          visited.insert(curr);
291          topology[step - backtracker].push_back(curr);
292          curr = curr->prev;
293          ++backtracker;
294        }
295      }
296    }
297    int ct = 0;
298    unsigned cb = 1;
299    for (const std::vector<const RecodeNode *> &layer : topology) {
300      if (cb >= character_boundaries_.size()) {
301        break;
302      }
303      if (ct == character_boundaries_[cb]) {
304        tprintf("***\n");
305        ++cb;
306      }
307      for (const RecodeNode *node : layer) {
308        const char *code;
309        int intCode;
310        if (node->unichar_id != INVALID_UNICHAR_ID) {
311          code = charset->id_to_unichar(node->unichar_id);
312          intCode = node->unichar_id;
313        } else if (node->code == null_char_) {
314          intCode = 0;
315          code = " ";
316        } else {
317          intCode = 666;
318          code = "*";
319        }
320        int intPrevCode = 0;
321        const char *prevCode;
322        float prevScore = 0;
323        if (node->prev != nullptr) {
324          prevScore = node->prev->score;
325          if (node->prev->unichar_id != INVALID_UNICHAR_ID) {
326            prevCode = charset->id_to_unichar(node->prev->unichar_id);
327            intPrevCode = node->prev->unichar_id;
328          } else if (node->code == null_char_) {
329            intPrevCode = 0;
330            prevCode = " ";
331          } else {
332            prevCode = "*";
333            intPrevCode = 666;
334          }
335        } else {
336          prevCode = " ";
337        }
338        if (uids) {
339          tprintf("%x(|)%f(>)%x(|)%f\n", intPrevCode, prevScore, intCode,
340                  node->score);
341        } else {
342          tprintf("%s(|)%f(>)%s(|)%f\n", prevCode, prevScore, code, node->score);
343        }
344      }
345      tprintf("-\n");
346      ++ct;
347    }
348    tprintf("***\n");
349  }
350  void RecodeBeamSearch::extractSymbolChoices(const UNICHARSET *unicharset) {
351    if (character_boundaries_.size() < 2) {
352      return;
353    }
354    std::vector<RecodeBeam *> &currentBeam =
355        secondary_beam_.empty() ? beam_ : secondary_beam_;
356    character_boundaries_[0] = 0;
357    for (unsigned j = 1; j < character_boundaries_.size(); ++j) {
358      std::vector<int> unichar_ids;
359      std::vector<float> certs;
360      std::vector<float> ratings;
361      std::vector<int> xcoords;
362      int backpath = character_boundaries_[j] - character_boundaries_[j - 1];
363      std::vector<tesseract::RecodePair> &heaps =
364          currentBeam.at(character_boundaries_[j] - 1)->beams_->heap();
365      std::vector<const RecodeNode *> best_nodes;
366      std::vector<const RecodeNode *> best;
367      for (auto &&entry : heaps) {
368        bool validChar = false;
369        int backcounter = 0;
370        const RecodeNode *node = &entry.data();
371        while (node != nullptr && backcounter < backpath) {
372          if (node->code != null_char_ &&
373              node->unichar_id != INVALID_UNICHAR_ID) {
374            validChar = true;
375            break;
376          }
377          node = node->prev;
378          ++backcounter;
379        }
380        if (validChar) {
381          best.push_back(&entry.data());
382        }
383      }
384      if (!best.empty()) {
385        std::sort(best.begin(), best.end(), greater_than());
386        ExtractPath(best[0], &best_nodes, backpath);
387        ExtractPathAsUnicharIds(best_nodes, &unichar_ids, &certs, &ratings,
388                                &xcoords);
389      }
390      if (!unichar_ids.empty()) {
391        int bestPos = 0;
392        for (unsigned i = 1; i < unichar_ids.size(); ++i) {
393          if (ratings[i] < ratings[bestPos]) {
394            bestPos = i;
395          }
396        }
397  #if 0 
398        int bestCode = -10;
399        for (auto &node : best_nodes) {
400          if (node->unichar_id == unichar_ids[bestPos]) {
401            bestCode = node->code;
402          }
403        }
404  #endif
405        std::unordered_set<int> excludeCodeList;
406        for (auto &best_node : best_nodes) {
407          if (best_node->code != null_char_) {
408            excludeCodeList.insert(best_node->code);
409          }
410        }
411        if (j - 1 < excludedUnichars.size()) {
412          for (auto elem : excludeCodeList) {
413            excludedUnichars[j - 1].insert(elem);
414          }
415        } else {
416          excludedUnichars.push_back(excludeCodeList);
417        }
418        if (j - 1 < ctc_choices.size()) {
419          int id = unichar_ids[bestPos];
420          const char *result = unicharset->id_to_unichar_ext(id);
421          float rating = ratings[bestPos];
422          ctc_choices[j - 1].push_back(
423              std::pair<const char *, float>(result, rating));
424        } else {
425          std::vector<std::pair<const char *, float>> choice;
426          int id = unichar_ids[bestPos];
427          const char *result = unicharset->id_to_unichar_ext(id);
428          float rating = ratings[bestPos];
429          choice.emplace_back(result, rating);
430          ctc_choices.push_back(choice);
431        }
432      } else {
433        if (j - 1 >= excludedUnichars.size()) {
434          std::unordered_set<int> excludeCodeList;
435          excludedUnichars.push_back(excludeCodeList);
436        }
437        if (j - 1 >= ctc_choices.size()) {
438          std::vector<std::pair<const char *, float>> choice;
439          ctc_choices.push_back(choice);
440        }
441      }
442    }
443    for (auto data : secondary_beam_) {
444      delete data;
445    }
446    secondary_beam_.clear();
447  }
448  void RecodeBeamSearch::DebugBeams(const UNICHARSET &unicharset) const {
449    for (int p = 0; p < beam_size_; ++p) {
450      for (int d = 0; d < 2; ++d) {
451        for (int c = 0; c < NC_COUNT; ++c) {
452          auto cont = static_cast<NodeContinuation>(c);
453          int index = BeamIndex(d, cont, 0);
454          if (beam_[p]->beams_[index].empty()) {
455            continue;
456          }
457          tprintf("Position %d: %s+%s beam\n", p, d ? "Dict" : "Non-Dict",
458                  kNodeContNames[c]);
459          DebugBeamPos(unicharset, beam_[p]->beams_[index]);
460        }
461      }
462    }
463  }
464  void RecodeBeamSearch::DebugBeamPos(const UNICHARSET &unicharset,
465                                      const RecodeHeap &heap) const {
466    std::vector<const RecodeNode *> unichar_bests(unicharset.size());
467    const RecodeNode *null_best = nullptr;
468    int heap_size = heap.size();
469    for (int i = 0; i < heap_size; ++i) {
470      const RecodeNode *node = &heap.get(i).data();
471      if (node->unichar_id == INVALID_UNICHAR_ID) {
472        if (null_best == nullptr || null_best->score < node->score) {
473          null_best = node;
474        }
475      } else {
476        if (unichar_bests[node->unichar_id] == nullptr ||
477            unichar_bests[node->unichar_id]->score < node->score) {
478          unichar_bests[node->unichar_id] = node;
479        }
480      }
481    }
482    for (auto &unichar_best : unichar_bests) {
483      if (unichar_best != nullptr) {
484        const RecodeNode &node = *unichar_best;
485        node.Print(null_char_, unicharset, 1);
486      }
487    }
488    if (null_best != nullptr) {
489      null_best->Print(null_char_, unicharset, 1);
490    }
491  }
492  void RecodeBeamSearch::ExtractPathAsUnicharIds(
493      const std::vector<const RecodeNode *> &best_nodes,
494      std::vector<int> *unichar_ids, std::vector<float> *certs,
495      std::vector<float> *ratings, std::vector<int> *xcoords,
496      std::vector<int> *character_boundaries) {
497    unichar_ids->clear();
498    certs->clear();
499    ratings->clear();
500    xcoords->clear();
501    std::vector<int> starts;
502    std::vector<int> ends;
503    int t = 0;
504    int width = best_nodes.size();
505    while (t < width) {
506      double certainty = 0.0;
507      double rating = 0.0;
508      while (t < width && best_nodes[t]->unichar_id == INVALID_UNICHAR_ID) {
509        double cert = best_nodes[t++]->certainty;
510        if (cert < certainty) {
511          certainty = cert;
512        }
513        rating -= cert;
514      }
515      starts.push_back(t);
516      if (t < width) {
517        int unichar_id = best_nodes[t]->unichar_id;
518        if (unichar_id == UNICHAR_SPACE && !certs->empty() &&
519            best_nodes[t]->permuter != NO_PERM) {
520          if (certainty < certs->back()) {
521            certs->back() = certainty;
522          }
523          ratings->back() += rating;
524          certainty = 0.0;
525          rating = 0.0;
526        }
527        unichar_ids->push_back(unichar_id);
528        xcoords->push_back(t);
529        do {
530          double cert = best_nodes[t++]->certainty;
531          if (cert < certainty || (unichar_id == UNICHAR_SPACE &&
532                                   best_nodes[t - 1]->permuter == NO_PERM)) {
533            certainty = cert;
534          }
535          rating -= cert;
536        } while (t < width && best_nodes[t]->duplicate);
537        ends.push_back(t);
538        certs->push_back(certainty);
539        ratings->push_back(rating);
540      } else if (!certs->empty()) {
541        if (certainty < certs->back()) {
542          certs->back() = certainty;
543        }
544        ratings->back() += rating;
545      }
546    }
547    starts.push_back(width);
548    if (character_boundaries != nullptr) {
549      calculateCharBoundaries(&starts, &ends, character_boundaries, width);
550    }
551    xcoords->push_back(width);
552  }
553  WERD_RES *RecodeBeamSearch::InitializeWord(bool leading_space,
554                                             const TBOX &line_box, int word_start,
555                                             int word_end, float space_certainty,
556                                             const UNICHARSET *unicharset,
557                                             const std::vector<int> &xcoords,
558                                             float scale_factor) {
559    C_BLOB_LIST blobs;
560    C_BLOB_IT b_it(&blobs);
561    for (int i = word_start; i < word_end; ++i) {
562      if (static_cast<unsigned>(i + 1) < character_boundaries_.size()) {
563        TBOX box(static_cast<int16_t>(
564                     std::floor(character_boundaries_[i] * scale_factor)) +
565                     line_box.left(),
566                 line_box.bottom(),
567                 static_cast<int16_t>(
568                     std::ceil(character_boundaries_[i + 1] * scale_factor)) +
569                     line_box.left(),
570                 line_box.top());
571        b_it.add_after_then_move(C_BLOB::FakeBlob(box));
572      }
573    }
574    WERD *word = new WERD(&blobs, leading_space, nullptr);
575    auto *word_res = new WERD_RES(word);
576    word_res->end = word_end - word_start + leading_space;
577    word_res->uch_set = unicharset;
578    word_res->combination = true; 
579    word_res->space_certainty = space_certainty;
580    word_res->ratings = new MATRIX(word_end - word_start, 1);
581    return word_res;
582  }
583  void RecodeBeamSearch::ComputeTopN(const float *outputs, int num_outputs,
584                                     int top_n) {
585    top_n_flags_.clear();
586    top_n_flags_.resize(num_outputs, TN_ALSO_RAN);
587    top_code_ = -1;
588    second_code_ = -1;
589    top_heap_.clear();
590    for (int i = 0; i < num_outputs; ++i) {
591      if (top_heap_.size() < top_n || outputs[i] > top_heap_.PeekTop().key()) {
592        TopPair entry(outputs[i], i);
593        top_heap_.Push(&entry);
594        if (top_heap_.size() > top_n) {
595          top_heap_.Pop(&entry);
596        }
597      }
598    }
599    while (!top_heap_.empty()) {
600      TopPair entry;
601      top_heap_.Pop(&entry);
602      if (top_heap_.size() > 1) {
603        top_n_flags_[entry.data()] = TN_TOPN;
604      } else {
605        top_n_flags_[entry.data()] = TN_TOP2;
606        if (top_heap_.empty()) {
607          top_code_ = entry.data();
608        } else {
609          second_code_ = entry.data();
610        }
611      }
612    }
613    top_n_flags_[null_char_] = TN_TOP2;
614  }
615  void RecodeBeamSearch::ComputeSecTopN(std::unordered_set<int> *exList,
616                                        const float *outputs, int num_outputs,
617                                        int top_n) {
618    top_n_flags_.clear();
619    top_n_flags_.resize(num_outputs, TN_ALSO_RAN);
620    top_code_ = -1;
621    second_code_ = -1;
622    top_heap_.clear();
623    for (int i = 0; i < num_outputs; ++i) {
624      if ((top_heap_.size() < top_n || outputs[i] > top_heap_.PeekTop().key()) &&
625          !exList->count(i)) {
626        TopPair entry(outputs[i], i);
627        top_heap_.Push(&entry);
628        if (top_heap_.size() > top_n) {
629          top_heap_.Pop(&entry);
630        }
631      }
632    }
633    while (!top_heap_.empty()) {
634      TopPair entry;
635      top_heap_.Pop(&entry);
636      if (top_heap_.size() > 1) {
637        top_n_flags_[entry.data()] = TN_TOPN;
638      } else {
639        top_n_flags_[entry.data()] = TN_TOP2;
640        if (top_heap_.empty()) {
641          top_code_ = entry.data();
642        } else {
643          second_code_ = entry.data();
644        }
645      }
646    }
647    top_n_flags_[null_char_] = TN_TOP2;
648  }
649  void RecodeBeamSearch::DecodeStep(const float *outputs, int t,
650                                    double dict_ratio, double cert_offset,
651                                    double worst_dict_cert,
652                                    const UNICHARSET *charset, bool debug) {
653    if (t == static_cast<int>(beam_.size())) {
654      beam_.push_back(new RecodeBeam);
655    }
656    RecodeBeam *step = beam_[t];
657    beam_size_ = t + 1;
658    step->Clear();
659    if (t == 0) {
660      ContinueContext(nullptr, BeamIndex(false, NC_ANYTHING, 0), outputs, TN_TOP2,
661                      charset, dict_ratio, cert_offset, worst_dict_cert, step);
662      if (dict_ != nullptr) {
663        ContinueContext(nullptr, BeamIndex(true, NC_ANYTHING, 0), outputs,
664                        TN_TOP2, charset, dict_ratio, cert_offset,
665                        worst_dict_cert, step);
666      }
667    } else {
668      RecodeBeam *prev = beam_[t - 1];
669      if (debug) {
670        int beam_index = BeamIndex(true, NC_ANYTHING, 0);
671        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
672          std::vector<const RecodeNode *> path;
673          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
674          tprintf("Step %d: Dawg beam %d:\n", t, i);
675          DebugPath(charset, path);
676        }
677        beam_index = BeamIndex(false, NC_ANYTHING, 0);
678        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
679          std::vector<const RecodeNode *> path;
680          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
681          tprintf("Step %d: Non-Dawg beam %d:\n", t, i);
682          DebugPath(charset, path);
683        }
684      }
685      int total_beam = 0;
686      for (int tn = 0; tn < TN_COUNT && total_beam == 0; ++tn) {
<span onclick='openModal()' class='match'>687        auto top_n = static_cast<TopNState>(tn);
688        for (int index = 0; index < kNumBeams; ++index) {
689          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
</span>690            ContinueContext(&prev->beams_[index].get(i).data(), index, outputs,
691                            top_n, charset, dict_ratio, cert_offset,
692                            worst_dict_cert, step);
693          }
694        }
695        for (int index = 0; index < kNumBeams; ++index) {
696          if (ContinuationFromBeamsIndex(index) == NC_ANYTHING) {
697            total_beam += step->beams_[index].size();
698          }
699        }
700      }
701      for (int c = 0; c < NC_COUNT; ++c) {
702        if (step->best_initial_dawgs_[c].code >= 0) {
703          int index = BeamIndex(true, static_cast<NodeContinuation>(c), 0);
704          RecodeHeap *dawg_heap = &step->beams_[index];
705          PushHeapIfBetter(kBeamWidths[0], &step->best_initial_dawgs_[c],
706                           dawg_heap);
707        }
708      }
709    }
710  }
711  void RecodeBeamSearch::DecodeSecondaryStep(
712      const float *outputs, int t, double dict_ratio, double cert_offset,
713      double worst_dict_cert, const UNICHARSET *charset, bool debug) {
714    if (t == static_cast<int>(secondary_beam_.size())) {
715      secondary_beam_.push_back(new RecodeBeam);
716    }
717    RecodeBeam *step = secondary_beam_[t];
718    step->Clear();
719    if (t == 0) {
720      ContinueContext(nullptr, BeamIndex(false, NC_ANYTHING, 0), outputs, TN_TOP2,
721                      charset, dict_ratio, cert_offset, worst_dict_cert, step);
722      if (dict_ != nullptr) {
723        ContinueContext(nullptr, BeamIndex(true, NC_ANYTHING, 0), outputs,
724                        TN_TOP2, charset, dict_ratio, cert_offset,
725                        worst_dict_cert, step);
726      }
727    } else {
728      RecodeBeam *prev = secondary_beam_[t - 1];
729      if (debug) {
730        int beam_index = BeamIndex(true, NC_ANYTHING, 0);
731        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
732          std::vector<const RecodeNode *> path;
733          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
734          tprintf("Step %d: Dawg beam %d:\n", t, i);
735          DebugPath(charset, path);
736        }
737        beam_index = BeamIndex(false, NC_ANYTHING, 0);
738        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
739          std::vector<const RecodeNode *> path;
740          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
741          tprintf("Step %d: Non-Dawg beam %d:\n", t, i);
742          DebugPath(charset, path);
743        }
744      }
745      int total_beam = 0;
746      for (int tn = 0; tn < TN_COUNT && total_beam == 0; ++tn) {
747        auto top_n = static_cast<TopNState>(tn);
748        for (int index = 0; index < kNumBeams; ++index) {
749          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
750            ContinueContext(&prev->beams_[index].get(i).data(), index, outputs,
751                            top_n, charset, dict_ratio, cert_offset,
752                            worst_dict_cert, step);
753          }
754        }
755        for (int index = 0; index < kNumBeams; ++index) {
756          if (ContinuationFromBeamsIndex(index) == NC_ANYTHING) {
757            total_beam += step->beams_[index].size();
758          }
759        }
760      }
761      for (int c = 0; c < NC_COUNT; ++c) {
762        if (step->best_initial_dawgs_[c].code >= 0) {
763          int index = BeamIndex(true, static_cast<NodeContinuation>(c), 0);
764          RecodeHeap *dawg_heap = &step->beams_[index];
765          PushHeapIfBetter(kBeamWidths[0], &step->best_initial_dawgs_[c],
766                           dawg_heap);
767        }
768      }
769    }
770  }
771  void RecodeBeamSearch::ContinueContext(
772      const RecodeNode *prev, int index, const float *outputs,
773      TopNState top_n_flag, const UNICHARSET *charset, double dict_ratio,
774      double cert_offset, double worst_dict_cert, RecodeBeam *step) {
775    RecodedCharID prefix;
776    RecodedCharID full_code;
777    const RecodeNode *previous = prev;
778    int length = LengthFromBeamsIndex(index);
779    bool use_dawgs = IsDawgFromBeamsIndex(index);
780    NodeContinuation prev_cont = ContinuationFromBeamsIndex(index);
781    for (int p = length - 1; p >= 0; --p, previous = previous->prev) {
782      while (previous != nullptr &&
783             (previous->duplicate || previous->code == null_char_)) {
784        previous = previous->prev;
785      }
786      if (previous != nullptr) {
787        prefix.Set(p, previous->code);
788        full_code.Set(p, previous->code);
789      }
790    }
791    if (prev != nullptr && !is_simple_text_) {
792      if (top_n_flags_[prev->code] == top_n_flag) {
793        if (prev_cont != NC_NO_DUP) {
794          float cert =
795              NetworkIO::ProbToCertainty(outputs[prev->code]) + cert_offset;
796          PushDupOrNoDawgIfBetter(length, true, prev->code, prev->unichar_id,
797                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
798                                  NC_ANYTHING, prev, step);
799        }
800        if (prev_cont == NC_ANYTHING && top_n_flag == TN_TOP2 &&
801            prev->code != null_char_) {
802          float cert = NetworkIO::ProbToCertainty(outputs[prev->code] +
803                                                  outputs[null_char_]) +
804                       cert_offset;
805          PushDupOrNoDawgIfBetter(length, true, prev->code, prev->unichar_id,
806                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
807                                  NC_NO_DUP, prev, step);
808        }
809      }
810      if (prev_cont == NC_ONLY_DUP) {
811        return;
812      }
813      if (prev->code != null_char_ && length > 0 &&
814          top_n_flags_[null_char_] == top_n_flag) {
815        float cert =
816            NetworkIO::ProbToCertainty(outputs[null_char_]) + cert_offset;
817        PushDupOrNoDawgIfBetter(length, false, null_char_, INVALID_UNICHAR_ID,
818                                cert, worst_dict_cert, dict_ratio, use_dawgs,
819                                NC_ANYTHING, prev, step);
820      }
821    }
822    const std::vector<int> *final_codes = recoder_.GetFinalCodes(prefix);
823    if (final_codes != nullptr) {
824      for (int code : *final_codes) {
825        if (top_n_flags_[code] != top_n_flag) {
826          continue;
827        }
828        if (prev != nullptr && prev->code == code && !is_simple_text_) {
829          continue;
830        }
831        float cert = NetworkIO::ProbToCertainty(outputs[code]) + cert_offset;
832        if (cert < kMinCertainty && code != null_char_) {
833          continue;
834        }
835        full_code.Set(length, code);
836        int unichar_id = recoder_.DecodeUnichar(full_code);
837        if (length == 0 && code == null_char_) {
838          unichar_id = INVALID_UNICHAR_ID;
839        }
840        if (unichar_id != INVALID_UNICHAR_ID && charset != nullptr &&
841            !charset->get_enabled(unichar_id)) {
842          continue; 
843        }
844        ContinueUnichar(code, unichar_id, cert, worst_dict_cert, dict_ratio,
845                        use_dawgs, NC_ANYTHING, prev, step);
846        if (top_n_flag == TN_TOP2 && code != null_char_) {
847          float prob = outputs[code] + outputs[null_char_];
848          if (prev != nullptr && prev_cont == NC_ANYTHING &&
849              prev->code != null_char_ &&
850              ((prev->code == top_code_ && code == second_code_) ||
851               (code == top_code_ && prev->code == second_code_))) {
852            prob += outputs[prev->code];
853          }
854          cert = NetworkIO::ProbToCertainty(prob) + cert_offset;
855          ContinueUnichar(code, unichar_id, cert, worst_dict_cert, dict_ratio,
856                          use_dawgs, NC_ONLY_DUP, prev, step);
857        }
858      }
859    }
860    const std::vector<int> *next_codes = recoder_.GetNextCodes(prefix);
861    if (next_codes != nullptr) {
862      for (int code : *next_codes) {
863        if (top_n_flags_[code] != top_n_flag) {
864          continue;
865        }
866        if (prev != nullptr && prev->code == code && !is_simple_text_) {
867          continue;
868        }
869        float cert = NetworkIO::ProbToCertainty(outputs[code]) + cert_offset;
870        PushDupOrNoDawgIfBetter(length + 1, false, code, INVALID_UNICHAR_ID, cert,
871                                worst_dict_cert, dict_ratio, use_dawgs,
872                                NC_ANYTHING, prev, step);
873        if (top_n_flag == TN_TOP2 && code != null_char_) {
874          float prob = outputs[code] + outputs[null_char_];
875          if (prev != nullptr && prev_cont == NC_ANYTHING &&
876              prev->code != null_char_ &&
877              ((prev->code == top_code_ && code == second_code_) ||
878               (code == top_code_ && prev->code == second_code_))) {
879            prob += outputs[prev->code];
880          }
881          cert = NetworkIO::ProbToCertainty(prob) + cert_offset;
882          PushDupOrNoDawgIfBetter(length + 1, false, code, INVALID_UNICHAR_ID,
883                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
884                                  NC_ONLY_DUP, prev, step);
885        }
886      }
887    }
888  }
889  void RecodeBeamSearch::ContinueUnichar(int code, int unichar_id, float cert,
890                                         float worst_dict_cert, float dict_ratio,
891                                         bool use_dawgs, NodeContinuation cont,
892                                         const RecodeNode *prev,
893                                         RecodeBeam *step) {
894    if (use_dawgs) {
895      if (cert > worst_dict_cert) {
896        ContinueDawg(code, unichar_id, cert, cont, prev, step);
897      }
898    } else {
899      RecodeHeap *nodawg_heap = &step->beams_[BeamIndex(false, cont, 0)];
900      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, TOP_CHOICE_PERM, false,
901                       false, false, false, cert * dict_ratio, prev, nullptr,
902                       nodawg_heap);
903      if (dict_ != nullptr &&
904          ((unichar_id == UNICHAR_SPACE && cert > worst_dict_cert) ||
905           !dict_->getUnicharset().IsSpaceDelimited(unichar_id))) {
906        float dawg_cert = cert;
907        PermuterType permuter = TOP_CHOICE_PERM;
908        if (unichar_id == UNICHAR_SPACE) {
909          permuter = NO_PERM;
910        } else {
911          dawg_cert *= dict_ratio;
912        }
913        PushInitialDawgIfBetter(code, unichar_id, permuter, false, false,
914                                dawg_cert, cont, prev, step);
915      }
916    }
917  }
918  void RecodeBeamSearch::ContinueDawg(int code, int unichar_id, float cert,
919                                      NodeContinuation cont,
920                                      const RecodeNode *prev, RecodeBeam *step) {
921    RecodeHeap *dawg_heap = &step->beams_[BeamIndex(true, cont, 0)];
922    RecodeHeap *nodawg_heap = &step->beams_[BeamIndex(false, cont, 0)];
923    if (unichar_id == INVALID_UNICHAR_ID) {
924      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, NO_PERM, false, false,
925                       false, false, cert, prev, nullptr, dawg_heap);
926      return;
927    }
928    float score = cert;
929    if (prev != nullptr) {
930      score += prev->score;
931    }
932    if (dawg_heap->size() >= kBeamWidths[0] &&
933        score <= dawg_heap->PeekTop().data().score &&
934        nodawg_heap->size() >= kBeamWidths[0] &&
935        score <= nodawg_heap->PeekTop().data().score) {
936      return;
937    }
938    const RecodeNode *uni_prev = prev;
939    while (uni_prev != nullptr &&
940           (uni_prev->unichar_id == INVALID_UNICHAR_ID || uni_prev->duplicate)) {
941      uni_prev = uni_prev->prev;
942    }
943    if (unichar_id == UNICHAR_SPACE) {
944      if (uni_prev != nullptr && uni_prev->end_of_word) {
945        PushInitialDawgIfBetter(code, unichar_id, uni_prev->permuter, false,
946                                false, cert, cont, prev, step);
947        PushHeapIfBetter(kBeamWidths[0], code, unichar_id, uni_prev->permuter,
948                         false, false, false, false, cert, prev, nullptr,
949                         nodawg_heap);
950      }
951      return;
952    } else if (uni_prev != nullptr && uni_prev->start_of_dawg &&
953               uni_prev->unichar_id != UNICHAR_SPACE &&
954               dict_->getUnicharset().IsSpaceDelimited(uni_prev->unichar_id) &&
955               dict_->getUnicharset().IsSpaceDelimited(unichar_id)) {
956      return; 
957    }
958    DawgPositionVector initial_dawgs;
959    auto *updated_dawgs = new DawgPositionVector;
960    DawgArgs dawg_args(&initial_dawgs, updated_dawgs, NO_PERM);
961    bool word_start = false;
962    if (uni_prev == nullptr) {
963      dict_->default_dawgs(&initial_dawgs, false);
964      word_start = true;
965    } else if (uni_prev->dawgs != nullptr) {
966      dawg_args.active_dawgs = uni_prev->dawgs;
967      word_start = uni_prev->start_of_dawg;
968    } else {
969      return; 
970    }
971    auto permuter = static_cast<PermuterType>(dict_->def_letter_is_okay(
972        &dawg_args, dict_->getUnicharset(), unichar_id, false));
973    if (permuter != NO_PERM) {
974      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, permuter, false,
975                       word_start, dawg_args.valid_end, false, cert, prev,
976                       dawg_args.updated_dawgs, dawg_heap);
977      if (dawg_args.valid_end && !space_delimited_) {
978        PushInitialDawgIfBetter(code, unichar_id, permuter, word_start, true,
979                                cert, cont, prev, step);
980        PushHeapIfBetter(kBeamWidths[0], code, unichar_id, permuter, false,
981                         word_start, true, false, cert, prev, nullptr,
982                         nodawg_heap);
983      }
984    } else {
985      delete updated_dawgs;
986    }
987  }
988  void RecodeBeamSearch::PushInitialDawgIfBetter(int code, int unichar_id,
989                                                 PermuterType permuter,
990                                                 bool start, bool end, float cert,
991                                                 NodeContinuation cont,
992                                                 const RecodeNode *prev,
993                                                 RecodeBeam *step) {
994    RecodeNode *best_initial_dawg = &step->best_initial_dawgs_[cont];
995    float score = cert;
996    if (prev != nullptr) {
997      score += prev->score;
998    }
999    if (best_initial_dawg->code < 0 || score > best_initial_dawg->score) {
1000      auto *initial_dawgs = new DawgPositionVector;
1001      dict_->default_dawgs(initial_dawgs, false);
1002      RecodeNode node(code, unichar_id, permuter, true, start, end, false, cert,
1003                      score, prev, initial_dawgs,
1004                      ComputeCodeHash(code, false, prev));
1005      *best_initial_dawg = node;
1006    }
1007  }
1008  void RecodeBeamSearch::PushDupOrNoDawgIfBetter(
1009      int length, bool dup, int code, int unichar_id, float cert,
1010      float worst_dict_cert, float dict_ratio, bool use_dawgs,
1011      NodeContinuation cont, const RecodeNode *prev, RecodeBeam *step) {
1012    int index = BeamIndex(use_dawgs, cont, length);
1013    if (use_dawgs) {
1014      if (cert > worst_dict_cert) {
1015        PushHeapIfBetter(kBeamWidths[length], code, unichar_id,
1016                         prev ? prev->permuter : NO_PERM, false, false, false,
1017                         dup, cert, prev, nullptr, &step->beams_[index]);
1018      }
1019    } else {
1020      cert *= dict_ratio;
1021      if (cert >= kMinCertainty || code == null_char_) {
1022        PushHeapIfBetter(kBeamWidths[length], code, unichar_id,
1023                         prev ? prev->permuter : TOP_CHOICE_PERM, false, false,
1024                         false, dup, cert, prev, nullptr, &step->beams_[index]);
1025      }
1026    }
1027  }
1028  void RecodeBeamSearch::PushHeapIfBetter(int max_size, int code, int unichar_id,
1029                                          PermuterType permuter, bool dawg_start,
1030                                          bool word_start, bool end, bool dup,
1031                                          float cert, const RecodeNode *prev,
1032                                          DawgPositionVector *d,
1033                                          RecodeHeap *heap) {
1034    float score = cert;
1035    if (prev != nullptr) {
1036      score += prev->score;
1037    }
1038    if (heap->size() < max_size || score > heap->PeekTop().data().score) {
1039      uint64_t hash = ComputeCodeHash(code, dup, prev);
1040      RecodeNode node(code, unichar_id, permuter, dawg_start, word_start, end,
1041                      dup, cert, score, prev, d, hash);
1042      if (UpdateHeapIfMatched(&node, heap)) {
1043        return;
1044      }
1045      RecodePair entry(score, node);
1046      heap->Push(&entry);
1047      ASSERT_HOST(entry.data().dawgs == nullptr);
1048      if (heap->size() > max_size) {
1049        heap->Pop(&entry);
1050      }
1051    } else {
1052      delete d;
1053    }
1054  }
1055  void RecodeBeamSearch::PushHeapIfBetter(int max_size, RecodeNode *node,
1056                                          RecodeHeap *heap) {
1057    if (heap->size() < max_size || node->score > heap->PeekTop().data().score) {
1058      if (UpdateHeapIfMatched(node, heap)) {
1059        return;
1060      }
1061      RecodePair entry(node->score, *node);
1062      heap->Push(&entry);
1063      ASSERT_HOST(entry.data().dawgs == nullptr);
1064      if (heap->size() > max_size) {
1065        heap->Pop(&entry);
1066      }
1067    }
1068  }
1069  bool RecodeBeamSearch::UpdateHeapIfMatched(RecodeNode *new_node,
1070                                             RecodeHeap *heap) {
1071    std::vector<RecodePair> &nodes = heap->heap();
1072    for (auto &i : nodes) {
1073      RecodeNode &node = i.data();
1074      if (node.code == new_node->code && node.code_hash == new_node->code_hash &&
1075          node.permuter == new_node->permuter &&
1076          node.start_of_dawg == new_node->start_of_dawg) {
1077        if (new_node->score > node.score) {
1078          node = *new_node;
1079          i.key() = node.score;
1080          heap->Reshuffle(&i);
1081        }
1082        return true;
1083      }
1084    }
1085    return false;
1086  }
1087  uint64_t RecodeBeamSearch::ComputeCodeHash(int code, bool dup,
1088                                             const RecodeNode *prev) const {
1089    uint64_t hash = prev == nullptr ? 0 : prev->code_hash;
1090    if (!dup && code != null_char_) {
1091      int num_classes = recoder_.code_range();
1092      uint64_t carry = (((hash >> 32) * num_classes) >> 32);
1093      hash *= num_classes;
1094      hash += carry;
1095      hash += code;
1096    }
1097    return hash;
1098  }
1099  void RecodeBeamSearch::ExtractBestPaths(
1100      std::vector<const RecodeNode *> *best_nodes,
1101      std::vector<const RecodeNode *> *second_nodes) const {
1102    const RecodeNode *best_node = nullptr;
1103    const RecodeNode *second_best_node = nullptr;
1104    const RecodeBeam *last_beam = beam_[beam_size_ - 1];
1105    for (int c = 0; c < NC_COUNT; ++c) {
1106      if (c == NC_ONLY_DUP) {
1107        continue;
1108      }
1109      auto cont = static_cast<NodeContinuation>(c);
1110      for (int is_dawg = 0; is_dawg < 2; ++is_dawg) {
1111        int beam_index = BeamIndex(is_dawg, cont, 0);
1112        int heap_size = last_beam->beams_[beam_index].size();
1113        for (int h = 0; h < heap_size; ++h) {
1114          const RecodeNode *node = &last_beam->beams_[beam_index].get(h).data();
1115          if (is_dawg) {
1116            const RecodeNode *dawg_node = node;
1117            while (dawg_node != nullptr &&
1118                   (dawg_node->unichar_id == INVALID_UNICHAR_ID ||
1119                    dawg_node->duplicate)) {
1120              dawg_node = dawg_node->prev;
1121            }
1122            if (dawg_node == nullptr ||
1123                (!dawg_node->end_of_word &&
1124                 dawg_node->unichar_id != UNICHAR_SPACE)) {
1125              continue;
1126            }
1127          }
1128          if (best_node == nullptr || node->score > best_node->score) {
1129            second_best_node = best_node;
1130            best_node = node;
1131          } else if (second_best_node == nullptr ||
1132                     node->score > second_best_node->score) {
1133            second_best_node = node;
1134          }
1135        }
1136      }
1137    }
1138    if (second_nodes != nullptr) {
1139      ExtractPath(second_best_node, second_nodes);
1140    }
1141    ExtractPath(best_node, best_nodes);
1142  }
1143  void RecodeBeamSearch::ExtractPath(
1144      const RecodeNode *node, std::vector<const RecodeNode *> *path) const {
1145    path->clear();
1146    while (node != nullptr) {
1147      path->push_back(node);
1148      node = node->prev;
1149    }
1150    std::reverse(path->begin(), path->end());
1151  }
1152  void RecodeBeamSearch::ExtractPath(const RecodeNode *node,
1153                                     std::vector<const RecodeNode *> *path,
1154                                     int limiter) const {
1155    int pathcounter = 0;
1156    path->clear();
1157    while (node != nullptr && pathcounter < limiter) {
1158      path->push_back(node);
1159      node = node->prev;
1160      ++pathcounter;
1161    }
1162    std::reverse(path->begin(), path->end());
1163  }
1164  void RecodeBeamSearch::DebugPath(
1165      const UNICHARSET *unicharset,
1166      const std::vector<const RecodeNode *> &path) const {
1167    for (unsigned c = 0; c < path.size(); ++c) {
1168      const RecodeNode &node = *path[c];
1169      tprintf("%u ", c);
1170      node.Print(null_char_, *unicharset, 1);
1171    }
1172  }
1173  void RecodeBeamSearch::DebugUnicharPath(
1174      const UNICHARSET *unicharset, const std::vector<const RecodeNode *> &path,
1175      const std::vector<int> &unichar_ids, const std::vector<float> &certs,
1176      const std::vector<float> &ratings, const std::vector<int> &xcoords) const {
1177    auto num_ids = unichar_ids.size();
1178    double total_rating = 0.0;
1179    for (unsigned c = 0; c < num_ids; ++c) {
1180      int coord = xcoords[c];
1181      tprintf("%d %d=%s r=%g, c=%g, s=%d, e=%d, perm=%d\n", coord, unichar_ids[c],
1182              unicharset->debug_str(unichar_ids[c]).c_str(), ratings[c], certs[c],
1183              path[coord]->start_of_word, path[coord]->end_of_word,
1184              path[coord]->permuter);
1185      total_rating += ratings[c];
1186    }
1187    tprintf("Path total rating = %g\n", total_rating);
1188  }
1189  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-caffe.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam.cpp</div>
                <div class="column column_space"><pre><code>483    double backward_time = 0.0;
484    for (int j = 0; j < FLAGS_iterations; ++j) {
485      Timer iter_timer;
486      iter_timer.Start();
487      forward_timer.Start();
488      for (int i = 0; i < layers.size(); ++i) {
</pre></code></div>
                <div class="column column_space"><pre><code>687        auto top_n = static_cast<TopNState>(tn);
688        for (int index = 0; index < kNumBeams; ++index) {
689          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    