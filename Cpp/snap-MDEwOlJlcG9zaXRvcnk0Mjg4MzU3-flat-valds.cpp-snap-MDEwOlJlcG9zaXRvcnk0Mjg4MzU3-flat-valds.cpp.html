
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-valds.cpp</h3>
            <pre><code>1  void TTbValDs::AddVal(const TTbVal& Val, const double& Wgt){
2    Assert(!DefP);
3    SumW+=Wgt;
4    ValTagWV[Val.GetValTag()]+=Wgt;
5    switch (Val.GetValTag()){
6      case tvtDsc: DscWV[Val.GetDsc()]+=Wgt; break;
7      case tvtFlt: FltMom->Add(Val.GetFlt(), Wgt); break;
8      default:;
9    }
10  }
11  void TTbValDs::ExpW(){
12    Assert(!DefP);
13    int MxWDsc=0;
14    for (int Dsc=1; Dsc<DscWV.Len(); Dsc++){
15      if (DscWV[Dsc]>DscWV[MxWDsc]){MxWDsc=Dsc;}}
16    double MxDscW=DscWV[MxWDsc]; SumW=0;
17    {for (int Dsc=0; Dsc<DscWV.Len(); Dsc++){
18      DscWV[Dsc]=exp(DscWV[Dsc]-MxDscW); SumW+=DscWV[Dsc];}}
19  }
20  double TTbValDs::GetValW(const TTbVal& Val) const {
21    Assert(DefP);
22    switch (Val.GetValTag()){
23      case tvtDsc: return DscWV[Val.GetDsc()];
24      case tvtFlt: Fail; return 0;
25      default: return ValTagWV[Val.GetValTag()];
26    }
27  }
28  bool TTbValDs::IsOneVal() const {
29    Assert(DefP);
30    if (IsEmpty()){return false;}
31    if (IsDsc()){
32      for (int Dsc=0; Dsc<DscWV.Len(); Dsc++){
33        if (DscWV[Dsc]==SumW){return true;}}
34      return false;
35    } else
36    if (IsFlt()){
37      return FltMom->GetSDev()==0;
38    } else {
39      return false;
40    }
41  }
42  TTbVal TTbValDs::GetMajorVal() const {
43    IAssert(DefP&&!IsEmpty());
44    if (IsDsc()){
45      int MajorDsc=0;
46      for (int Dsc=1; Dsc<DscWV.Len(); Dsc++){
47        if (DscWV[Dsc]>DscWV[MajorDsc]){MajorDsc=Dsc;}}
48      return TTbVal(MajorDsc);
49    } else
50    if (IsFlt()){
51      return TTbVal(FltMom->GetMean());
52    } else {
53      Fail; return TTbVal();
54    }
55  }
<span onclick='openModal()' class='match'>56  double TTbValDs::GetPrb_RelFq(const TTbVal& Val) const {
57    IAssert(DefP);
58    if (double(SumW)==0){return 0;}
</span>59    return GetValW(Val)/SumW;
60  }
61  double TTbValDs::GetPrb_Laplace(const TTbVal& Val) const {
62    IAssert(DefP);
63    if (SumW+GetDscs()==0){return 0;}
64    return (GetValW(Val)+1)/(SumW+GetDscs());
65  }
66  double TTbValDs::GetPrb_QuinLaplace(
67   const TTbVal& Val, const double& PriorPrb) const {
68    IAssert(DefP);
69    IAssert((0<=PriorPrb)&&(PriorPrb<=1));
70    if (PriorPrb==1){return PriorPrb;}
71    double PriorW=1.0/(1-PriorPrb);
72    if (SumW+PriorW==0){return 0;}
73    return (GetValW(Val)+PriorW*PriorPrb)/(SumW+PriorW);
74  }
75  double TTbValDs::GetPrb_MEst(
76   const TTbVal& Val, const double& MParam, const double& PriorPrb) const {
77    IAssert(DefP);
78    IAssert((0<=PriorPrb)&&(PriorPrb<=1));
79    if (SumW+MParam==0){return 0;}
80    return (GetValW(Val)+MParam*PriorPrb)/(SumW+MParam);
81  }
82  TStr TTbValDs::GetStr(const PTbVarType& VarType) const {
83    TChA ChA;
84    if (IsDsc()){
85      ChA+='[';
86      for (int ValN=0; ValN<GetDscs(); ValN++){
87        if (ValN>0){ChA+=' ';}
88        TTbVal Val(ValN);
89        ChA+=VarType->GetValStr(Val); ChA+=':';
90        ChA+=TFlt::GetStr(GetValW(Val));
91      }
92      ChA+=']';
93    }
94    if (IsFlt()){
95      ChA+=GetFltMom()->GetStr();
96    }
97    return ChA;
98  }
99  PTbValDs TTbValDs::GetCValDs(
100   const int& ClassN, const PDm& Dm, const PExSet& ExSet){
101    PTbVarType CVarType=Dm->GetClass(ClassN)->GetVarType();
102    PTbValDs ValDs=TTbValDs::New(CVarType->GetDscs());
103    int ExP=ExSet->FFirstExP();
104    while (ExSet->FNextExP(ExP)){
105      int ExId=ExSet->GetExId(ExP); double ExWgt=ExSet->GetExWgt(ExP);
106      ValDs->AddVal(Dm->GetClassVal(ExId, ClassN), ExWgt);
107    }
108    ValDs->Def();
109    return ValDs;
110  }
111  PTbValDs TTbValDs::GetBoolValDs(const double& NegValW, const double& PosValW){
112    PTbValDs ValDs=TTbValDs::New(2);
113    if ((NegValW==-1)||(PosValW==-1)){
114      double NegValPrb=(NegValW==-1) ? 1-PosValW : NegValW;
115      double PosValPrb=(PosValW==-1) ? 1-NegValW : PosValW;
116      IAssert((NegValPrb<=1)&&(PosValPrb<=1));
117      ValDs->AddVal(TTbVal::NegVal, NegValPrb);
118      ValDs->AddVal(TTbVal::PosVal, PosValPrb);
119    } else {
120      ValDs->AddVal(TTbVal::NegVal, NegValW);
121      ValDs->AddVal(TTbVal::PosVal, PosValW);
122    }
123    ValDs->Def();
124    return ValDs;
125  }
126  PDmDs TDmDs::Load(TSIn& SIn){
127    TStr TypeNm(SIn);
128    if (TypeNm==TTypeNm<TGDmDs>()){return new TGDmDs(SIn);}
129    else {Fail; return NULL;}
130  }
131  void TGDmDs::AddVal(
132   const TTbVal& CVal, const int& AttrN, const TTbVal& AVal, const double& Wgt){
133    IAssert(CVal.IsDsc());
134    SumW+=Wgt;
135    CDs->AddVal(CVal, Wgt);
136    AVDsV[AttrN]->AddVal(AVal, Wgt);
137    CAVDsVV.At(CVal.GetDsc(), AttrN)->AddVal(AVal, Wgt);
138  }
139  TGDmDs::TGDmDs(const PDm& Dm, const int& ClassN, const PExSet& ExSet):
140    TDmDs(), SumW(), CDs(), AVDsV(), CAVDsVV(){
141    int CDscs=Dm->GetClass(ClassN)->GetVarType()->GetDscs();
142    SumW=0;
143    CDs=TTbValDs::New(CDscs);
144    AVDsV.Gen(Dm->GetAttrs());
145    CAVDsVV.Gen(CDscs, Dm->GetAttrs());
146    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
147      int ADscs=Dm->GetAttr(AttrN)->GetVarType()->GetDscs();
148      AVDsV[AttrN]=TTbValDs::New(ADscs);
149      for (int CDsc=0; CDsc<CDscs; CDsc++){
150        CAVDsVV.At(CDsc, AttrN)=TTbValDs::New(ADscs);}
151    }
152    int ExP=ExSet->FFirstExP();
153    while (ExSet->FNextExP(ExP)){
154      int ExId=ExSet->GetExId(ExP); double ExWgt=ExSet->GetExWgt(ExP);
155      TTbVal CVal=Dm->GetClassVal(ExId, ClassN);
156      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
157        AddVal(CVal, AttrN, Dm->GetAttrVal(ExId, AttrN), ExWgt);}
158    }
159    CDs->Def();
160    {for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
161      AVDsV[AttrN]->Def();
162      for (int CDsc=0; CDsc<CDscs; CDsc++){CAVDsVV.At(CDsc, AttrN)->Def();}
163    }}
164  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-valds.cpp</h3>
            <pre><code>1  void TTbValDs::AddVal(const TTbVal& Val, const double& Wgt){
2    Assert(!DefP);
3    SumW+=Wgt;
4    ValTagWV[Val.GetValTag()]+=Wgt;
5    switch (Val.GetValTag()){
6      case tvtDsc: DscWV[Val.GetDsc()]+=Wgt; break;
7      case tvtFlt: FltMom->Add(Val.GetFlt(), Wgt); break;
8      default:;
9    }
10  }
11  void TTbValDs::ExpW(){
12    Assert(!DefP);
13    int MxWDsc=0;
14    for (int Dsc=1; Dsc<DscWV.Len(); Dsc++){
15      if (DscWV[Dsc]>DscWV[MxWDsc]){MxWDsc=Dsc;}}
16    double MxDscW=DscWV[MxWDsc]; SumW=0;
17    {for (int Dsc=0; Dsc<DscWV.Len(); Dsc++){
18      DscWV[Dsc]=exp(DscWV[Dsc]-MxDscW); SumW+=DscWV[Dsc];}}
19  }
<span onclick='openModal()' class='match'>20  double TTbValDs::GetValW(const TTbVal& Val) const {
21    Assert(DefP);
22    switch (Val.GetValTag()){
</span>23      case tvtDsc: return DscWV[Val.GetDsc()];
24      case tvtFlt: Fail; return 0;
25      default: return ValTagWV[Val.GetValTag()];
26    }
27  }
28  bool TTbValDs::IsOneVal() const {
29    Assert(DefP);
30    if (IsEmpty()){return false;}
31    if (IsDsc()){
32      for (int Dsc=0; Dsc<DscWV.Len(); Dsc++){
33        if (DscWV[Dsc]==SumW){return true;}}
34      return false;
35    } else
36    if (IsFlt()){
37      return FltMom->GetSDev()==0;
38    } else {
39      return false;
40    }
41  }
42  TTbVal TTbValDs::GetMajorVal() const {
43    IAssert(DefP&&!IsEmpty());
44    if (IsDsc()){
45      int MajorDsc=0;
46      for (int Dsc=1; Dsc<DscWV.Len(); Dsc++){
47        if (DscWV[Dsc]>DscWV[MajorDsc]){MajorDsc=Dsc;}}
48      return TTbVal(MajorDsc);
49    } else
50    if (IsFlt()){
51      return TTbVal(FltMom->GetMean());
52    } else {
53      Fail; return TTbVal();
54    }
55  }
56  double TTbValDs::GetPrb_RelFq(const TTbVal& Val) const {
57    IAssert(DefP);
58    if (double(SumW)==0){return 0;}
59    return GetValW(Val)/SumW;
60  }
61  double TTbValDs::GetPrb_Laplace(const TTbVal& Val) const {
62    IAssert(DefP);
63    if (SumW+GetDscs()==0){return 0;}
64    return (GetValW(Val)+1)/(SumW+GetDscs());
65  }
66  double TTbValDs::GetPrb_QuinLaplace(
67   const TTbVal& Val, const double& PriorPrb) const {
68    IAssert(DefP);
69    IAssert((0<=PriorPrb)&&(PriorPrb<=1));
70    if (PriorPrb==1){return PriorPrb;}
71    double PriorW=1.0/(1-PriorPrb);
72    if (SumW+PriorW==0){return 0;}
73    return (GetValW(Val)+PriorW*PriorPrb)/(SumW+PriorW);
74  }
75  double TTbValDs::GetPrb_MEst(
76   const TTbVal& Val, const double& MParam, const double& PriorPrb) const {
77    IAssert(DefP);
78    IAssert((0<=PriorPrb)&&(PriorPrb<=1));
79    if (SumW+MParam==0){return 0;}
80    return (GetValW(Val)+MParam*PriorPrb)/(SumW+MParam);
81  }
82  TStr TTbValDs::GetStr(const PTbVarType& VarType) const {
83    TChA ChA;
84    if (IsDsc()){
85      ChA+='[';
86      for (int ValN=0; ValN<GetDscs(); ValN++){
87        if (ValN>0){ChA+=' ';}
88        TTbVal Val(ValN);
89        ChA+=VarType->GetValStr(Val); ChA+=':';
90        ChA+=TFlt::GetStr(GetValW(Val));
91      }
92      ChA+=']';
93    }
94    if (IsFlt()){
95      ChA+=GetFltMom()->GetStr();
96    }
97    return ChA;
98  }
99  PTbValDs TTbValDs::GetCValDs(
100   const int& ClassN, const PDm& Dm, const PExSet& ExSet){
101    PTbVarType CVarType=Dm->GetClass(ClassN)->GetVarType();
102    PTbValDs ValDs=TTbValDs::New(CVarType->GetDscs());
103    int ExP=ExSet->FFirstExP();
104    while (ExSet->FNextExP(ExP)){
105      int ExId=ExSet->GetExId(ExP); double ExWgt=ExSet->GetExWgt(ExP);
106      ValDs->AddVal(Dm->GetClassVal(ExId, ClassN), ExWgt);
107    }
108    ValDs->Def();
109    return ValDs;
110  }
111  PTbValDs TTbValDs::GetBoolValDs(const double& NegValW, const double& PosValW){
112    PTbValDs ValDs=TTbValDs::New(2);
113    if ((NegValW==-1)||(PosValW==-1)){
114      double NegValPrb=(NegValW==-1) ? 1-PosValW : NegValW;
115      double PosValPrb=(PosValW==-1) ? 1-NegValW : PosValW;
116      IAssert((NegValPrb<=1)&&(PosValPrb<=1));
117      ValDs->AddVal(TTbVal::NegVal, NegValPrb);
118      ValDs->AddVal(TTbVal::PosVal, PosValPrb);
119    } else {
120      ValDs->AddVal(TTbVal::NegVal, NegValW);
121      ValDs->AddVal(TTbVal::PosVal, PosValW);
122    }
123    ValDs->Def();
124    return ValDs;
125  }
126  PDmDs TDmDs::Load(TSIn& SIn){
127    TStr TypeNm(SIn);
128    if (TypeNm==TTypeNm<TGDmDs>()){return new TGDmDs(SIn);}
129    else {Fail; return NULL;}
130  }
131  void TGDmDs::AddVal(
132   const TTbVal& CVal, const int& AttrN, const TTbVal& AVal, const double& Wgt){
133    IAssert(CVal.IsDsc());
134    SumW+=Wgt;
135    CDs->AddVal(CVal, Wgt);
136    AVDsV[AttrN]->AddVal(AVal, Wgt);
137    CAVDsVV.At(CVal.GetDsc(), AttrN)->AddVal(AVal, Wgt);
138  }
139  TGDmDs::TGDmDs(const PDm& Dm, const int& ClassN, const PExSet& ExSet):
140    TDmDs(), SumW(), CDs(), AVDsV(), CAVDsVV(){
141    int CDscs=Dm->GetClass(ClassN)->GetVarType()->GetDscs();
142    SumW=0;
143    CDs=TTbValDs::New(CDscs);
144    AVDsV.Gen(Dm->GetAttrs());
145    CAVDsVV.Gen(CDscs, Dm->GetAttrs());
146    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
147      int ADscs=Dm->GetAttr(AttrN)->GetVarType()->GetDscs();
148      AVDsV[AttrN]=TTbValDs::New(ADscs);
149      for (int CDsc=0; CDsc<CDscs; CDsc++){
150        CAVDsVV.At(CDsc, AttrN)=TTbValDs::New(ADscs);}
151    }
152    int ExP=ExSet->FFirstExP();
153    while (ExSet->FNextExP(ExP)){
154      int ExId=ExSet->GetExId(ExP); double ExWgt=ExSet->GetExWgt(ExP);
155      TTbVal CVal=Dm->GetClassVal(ExId, ClassN);
156      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
157        AddVal(CVal, AttrN, Dm->GetAttrVal(ExId, AttrN), ExWgt);}
158    }
159    CDs->Def();
160    {for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
161      AVDsV[AttrN]->Def();
162      for (int CDsc=0; CDsc<CDscs; CDsc++){CAVDsVV.At(CDsc, AttrN)->Def();}
163    }}
164  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-valds.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-valds.cpp</div>
                </div>
                <div class="column column_space"><pre><code>56  double TTbValDs::GetPrb_RelFq(const TTbVal& Val) const {
57    IAssert(DefP);
58    if (double(SumW)==0){return 0;}
</pre></code></div>
                <div class="column column_space"><pre><code>20  double TTbValDs::GetValW(const TTbVal& Val) const {
21    Assert(DefP);
22    switch (Val.GetValTag()){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    