
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.827763496143959%, Tokens: 11</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Selection.h</h3>
            <pre><code>1  #ifndef SELECTION_H
2  #define SELECTION_H
3  namespace Scintilla::Internal {
4  class SelectionPosition {
5  	Sci::Position position;
6  	Sci::Position virtualSpace;
7  public:
8  	explicit SelectionPosition(Sci::Position position_= Sci::invalidPosition, Sci::Position virtualSpace_=0) noexcept : position(position_), virtualSpace(virtualSpace_) {
9  		PLATFORM_ASSERT(virtualSpace < 800000000);
10  		if (virtualSpace < 0)
11  			virtualSpace = 0;
12  	}
13  	void Reset() noexcept {
14  		position = 0;
15  		virtualSpace = 0;
16  	}
17  	void MoveForInsertDelete(bool insertion, Sci::Position startChange, Sci::Position length, bool moveForEqual) noexcept;
18  	bool operator ==(const SelectionPosition &other) const noexcept {
19  		return position == other.position && virtualSpace == other.virtualSpace;
20  	}
21  	bool operator <(const SelectionPosition &other) const noexcept;
22  	bool operator >(const SelectionPosition &other) const noexcept;
23  	bool operator <=(const SelectionPosition &other) const noexcept;
24  	bool operator >=(const SelectionPosition &other) const noexcept;
25  	Sci::Position Position() const noexcept {
26  		return position;
27  	}
28  	void SetPosition(Sci::Position position_) noexcept {
29  		position = position_;
30  		virtualSpace = 0;
31  	}
32  	Sci::Position VirtualSpace() const noexcept {
33  		return virtualSpace;
34  	}
35  	void SetVirtualSpace(Sci::Position virtualSpace_) noexcept {
36  		PLATFORM_ASSERT(virtualSpace_ < 800000000);
37  		if (virtualSpace_ >= 0)
38  			virtualSpace = virtualSpace_;
39  	}
40  	void Add(Sci::Position increment) noexcept {
41  		position = position + increment;
42  	}
43  	bool IsValid() const noexcept {
44  		return position >= 0;
45  	}
46  };
47  struct SelectionSegment {
48  	SelectionPosition start;
49  	SelectionPosition end;
50  	SelectionSegment() noexcept : start(), end() {
51  	}
52  	SelectionSegment(SelectionPosition a, SelectionPosition b) noexcept {
<span onclick='openModal()' class='match'>53  		if (a < b) {
54  			start = a;
55  			end = b;
56  		} else {
57  			start = b;
58  			end = a;
59  		}
60  	}
</span>61  	bool Empty() const noexcept {
62  		return start == end;
63  	}
64  	Sci::Position Length() const noexcept {
65  		return end.Position() - start.Position();
66  	}
67  	void Extend(SelectionPosition p) noexcept {
68  		if (start > p)
69  			start = p;
70  		if (end < p)
71  			end = p;
72  	}
73  	SelectionSegment Subtract(Sci::Position increment) const noexcept {
74  		SelectionSegment ret(start, end);
75  		ret.start.Add(-increment);
76  		ret.end.Add(-increment);
77  		return ret;
78  	}
79  };
80  struct SelectionRange {
81  	SelectionPosition caret;
82  	SelectionPosition anchor;
83  	SelectionRange() noexcept : caret(), anchor() {
84  	}
85  	explicit SelectionRange(SelectionPosition single) noexcept : caret(single), anchor(single) {
86  	}
87  	explicit SelectionRange(Sci::Position single) noexcept : caret(single), anchor(single) {
88  	}
89  	SelectionRange(SelectionPosition caret_, SelectionPosition anchor_) noexcept : caret(caret_), anchor(anchor_) {
90  	}
91  	SelectionRange(Sci::Position caret_, Sci::Position anchor_) noexcept : caret(caret_), anchor(anchor_) {
92  	}
93  	bool Empty() const noexcept {
94  		return anchor == caret;
95  	}
96  	Sci::Position Length() const noexcept;
97  	bool operator ==(const SelectionRange &other) const noexcept {
98  		return caret == other.caret && anchor == other.anchor;
99  	}
100  	bool operator <(const SelectionRange &other) const noexcept {
101  		return caret < other.caret || ((caret == other.caret) && (anchor < other.anchor));
102  	}
103  	void Reset() noexcept {
104  		anchor.Reset();
105  		caret.Reset();
106  	}
107  	void ClearVirtualSpace() noexcept {
108  		anchor.SetVirtualSpace(0);
109  		caret.SetVirtualSpace(0);
110  	}
111  	void MoveForInsertDelete(bool insertion, Sci::Position startChange, Sci::Position length) noexcept;
112  	bool Contains(Sci::Position pos) const noexcept;
113  	bool Contains(SelectionPosition sp) const noexcept;
114  	bool ContainsCharacter(Sci::Position posCharacter) const noexcept;
115  	SelectionSegment Intersect(SelectionSegment check) const noexcept;
116  	SelectionPosition Start() const noexcept {
117  		return (anchor < caret) ? anchor : caret;
118  	}
119  	SelectionPosition End() const noexcept {
120  		return (anchor < caret) ? caret : anchor;
121  	}
122  	void Swap() noexcept;
123  	bool Trim(SelectionRange range) noexcept;
124  	void MinimizeVirtualSpace() noexcept;
125  };
126  enum InSelection { inNone, inMain, inAdditional };
127  class Selection {
128  	std::vector<SelectionRange> ranges;
129  	std::vector<SelectionRange> rangesSaved;
130  	SelectionRange rangeRectangular;
131  	size_t mainRange;
132  	bool moveExtends;
133  	bool tentativeMain;
134  public:
135  	enum class SelTypes { none, stream, rectangle, lines, thin };
136  	SelTypes selType;
137  	Selection();
138  	bool IsRectangular() const noexcept;
139  	Sci::Position MainCaret() const noexcept;
140  	Sci::Position MainAnchor() const noexcept;
141  	SelectionRange &Rectangular() noexcept;
142  	SelectionSegment Limits() const noexcept;
143  	SelectionSegment LimitsForRectangularElseMain() const;
144  	size_t Count() const noexcept;
145  	size_t Main() const noexcept;
146  	void SetMain(size_t r) noexcept;
147  	SelectionRange &Range(size_t r) noexcept;
148  	const SelectionRange &Range(size_t r) const noexcept;
149  	SelectionRange &RangeMain() noexcept;
150  	const SelectionRange &RangeMain() const noexcept;
151  	SelectionPosition Start() const noexcept;
152  	bool MoveExtends() const noexcept;
153  	void SetMoveExtends(bool moveExtends_) noexcept;
154  	bool Empty() const noexcept;
155  	SelectionPosition Last() const noexcept;
156  	Sci::Position Length() const noexcept;
157  	void MovePositions(bool insertion, Sci::Position startChange, Sci::Position length) noexcept;
158  	void TrimSelection(SelectionRange range) noexcept;
159  	void TrimOtherSelections(size_t r, SelectionRange range) noexcept;
160  	void SetSelection(SelectionRange range);
161  	void AddSelection(SelectionRange range);
162  	void AddSelectionWithoutTrim(SelectionRange range);
163  	void DropSelection(size_t r);
164  	void DropAdditionalRanges();
165  	void TentativeSelection(SelectionRange range);
166  	void CommitTentative() noexcept;
167  	InSelection RangeType(size_t r) const noexcept;
168  	InSelection CharacterInSelection(Sci::Position posCharacter) const noexcept;
169  	InSelection InSelectionForEOL(Sci::Position pos) const noexcept;
170  	Sci::Position VirtualSpaceFor(Sci::Position pos) const noexcept;
171  	void Clear();
172  	void RemoveDuplicates();
173  	void RotateMain() noexcept;
174  	bool Tentative() const noexcept { return tentativeMain; }
175  	std::vector<SelectionRange> RangesCopy() const {
176  		return ranges;
177  	}
178  };
179  }
180  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ghash.cpp</h3>
            <pre><code>1  const int TGraphKey::RoundTo = 4; 
2  TGraphKey::TGraphKey(const TSFltV& GraphSigV) : Nodes(-1), EdgeV(), SigV(), VariantId(0) {
3    SigV.Gen(GraphSigV.Len());
4    for (int i = 0; i < GraphSigV.Len(); i++) {
5      SigV[i] = TFlt(TMath::Round(GraphSigV[i], RoundTo));
6    }
7  }
8  TGraphKey::TGraphKey(const TIntV& GraphSigV) : Nodes(-1), EdgeV(), SigV(), VariantId(0) {
9    SigV.Gen(GraphSigV.Len());
10    for (int i = 0; i < GraphSigV.Len(); i++) {
11      SigV[i] = TFlt(GraphSigV[i]());
12    }
13  }
14  TGraphKey::TGraphKey(const TFltV& GraphSigV) : Nodes(-1), EdgeV(), SigV(), VariantId(0) {
15    SigV.Gen(GraphSigV.Len());
16    for (int i = 0; i < GraphSigV.Len(); i++) {
17      SigV[i] = TFlt(TMath::Round(GraphSigV[i], RoundTo));
18    }
19  }
20  TGraphKey::TGraphKey(const TGraphKey& GraphKey) : Nodes(GraphKey.Nodes),
21    EdgeV(GraphKey.EdgeV), SigV(GraphKey.SigV), VariantId(GraphKey.VariantId) {
22  }
23  TGraphKey::TGraphKey(TSIn& SIn) : Nodes(SIn), EdgeV(SIn), SigV(SIn), VariantId(SIn) { }
24  void TGraphKey::Save(TSOut& SOut) const {
25    Nodes.Save(SOut);  EdgeV.Save(SOut);
26    SigV.Save(SOut);  VariantId.Save(SOut);
27  }
28  TGraphKey& TGraphKey::operator = (const TGraphKey& GraphKey) {
29    if (this != &GraphKey) {
30      Nodes = GraphKey.Nodes;
31      EdgeV = GraphKey.EdgeV;
32      SigV = GraphKey.SigV;
33      VariantId = GraphKey.VariantId;
34    }
35    return *this;
36  }
37  PNGraph TGraphKey::GetNGraph() const {
38    PNGraph G = TNGraph::New();
39    for (int i = 0; i < GetNodes(); i++) G->AddNode(i);
40    for (int e = 0; e < GetEdges(); e++) {
41      G->AddEdge(EdgeV[e].Val1, EdgeV[e].Val2);
42    }
43    G->Defrag();
44    return G;
45  }
46  void TGraphKey::TakeGraph(const PNGraph& Graph) {
47    TIntH NodeIdH;
48    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
49      NodeIdH.AddKey(NI.GetId()); }
50    Nodes = Graph->GetNodes();
51    EdgeV.Gen(Nodes, 0);
52    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
53      const int NewNId = NodeIdH.GetKeyId(NI.GetId());
54      for (int i = 0; i < NI.GetOutDeg(); i++) {
55        EdgeV.Add(TIntPr(NewNId, NodeIdH.GetKeyId(NI.GetOutNId(i))));
56      }
57    }
58    EdgeV.Sort(true);
59    EdgeV.Pack();
60  }
61  void TGraphKey::TakeGraph(const PNGraph& Graph, TIntPrV& NodeMap) {
62    TIntSet NodeIdH;
63    int n = 0;
64    NodeMap.Gen(Graph->GetNodes(), 0);
65    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++, n++) {
66      NodeIdH.AddKey(NI.GetId());
67      NodeMap.Add(TIntPr(NI.GetId(), n));
68    }
69    Nodes = Graph->GetNodes();
70    EdgeV.Gen(Nodes, 0);
71    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
72      const int NewNId = NodeIdH.GetKeyId(NI.GetId());
73      for (int i = 0; i < NI.GetOutDeg(); i++) {
74        EdgeV.Add(TIntPr(NewNId, NodeIdH.GetKeyId(NI.GetOutNId(i))));
75      }
76    }
77    EdgeV.Sort(true);
78    EdgeV.Pack();
79  }
80  void TGraphKey::TakeSig(const PNGraph& Graph, const int& MnSvdGraph, const int& MxSvdGraph) {
81    const int Edges = Graph->GetEdges();
82    Nodes = Graph->GetNodes();
83    VariantId = 0;
84    SigV.Gen(2+Nodes, 0);
85    TIntPrV DegV(Nodes, 0);
86    for (TNGraph::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
87      DegV.Add(TIntPr(NodeI.GetInDeg(), NodeI.GetOutDeg()));
88    }
89    DegV.Sort(false);
90    SigV.Add(TFlt(Nodes));
91    SigV.Add(TFlt(Edges));
92    for (int i = 0; i < DegV.Len(); i++) {
93      SigV.Add(DegV[i].Val1());
94      SigV.Add(DegV[i].Val2());
95    }
96    if (Nodes >= MnSvdGraph && Nodes < MxSvdGraph) {
97      TFltVV AdjMtx(Nodes+1, Nodes+1);
98      TFltV SngValV;
99      TFltVV LSingV, RSingV;
100      TIntH NodeIdH;
101      for (TNGraph::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
102        NodeIdH.AddKey(NodeI.GetId());
103      }
104      for (TNGraph::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
105        const int NodeId = NodeIdH.GetKeyId(NodeI.GetId()) + 1;
106        for (int e = 0; e < NodeI.GetOutDeg(); e++) {
107          const int DstNId = NodeIdH.GetKeyId(NodeI.GetOutNId(e)) + 1;  
108          if (NodeId != DstNId) AdjMtx.At(NodeId, DstNId) = 1;
109        }
110      }
111      try { 
112        TSvd::Svd(AdjMtx, LSingV, SngValV, RSingV);
113      } catch(...) {
114        printf("\n***No SVD convergence: G(%d, %d): SngValV.Len():%d\n", Nodes(), Graph->GetEdges(), SngValV.Len());
115      }
116      SngValV.Sort(false);
117      for (int i = 0; i < SngValV.Len(); i++) {
118        SigV.Add(TMath::Round(SngValV[i], RoundTo));
119      }
120    }
121    SigV.Pack();
122  }
123  void TGraphKey::SaveTxt(FILE *F) const {
124    fprintf(F, "#GraphKey. Nodes: %d.  Edges: %d\n", GetNodes(), GetEdges());
125    for (int i = 0; i < EdgeV.Len(); i++) {
126      fprintf(F,"  %d\t%d\n", EdgeV[i].Val1(), EdgeV[i].Val2());
127    }
128  }
129  void TGraphKey::SaveGViz(const TStr& OutFNm, const TStr& Desc, const TStr& NodeAttrs, const int& Size) const {
130    FILE *F = fopen(OutFNm.CStr(), "wt");
131    fprintf(F, "&bsol;*****\n");
132    fprintf(F, "  Graph (%d, %d)\n", GetNodes(), GetEdges());
133    fprintf(F, "*****/\n\n");
134    fprintf(F, "digraph G {\n");
135    if (Size != -1) fprintf(F, "  size=\"%d,%d\";\n", Size, Size);
136    fprintf(F, "  graph [splines=true overlap=false]\n"); 
137    if (NodeAttrs.Empty()) fprintf(F, "  node  [shape=ellipse, width=0.3, height=0.3]\n");
138    else fprintf(F, "  node  [shape=ellipse, %s]\n", NodeAttrs.CStr());
139    if (! EdgeV.Empty()) {
140      for (int e = 0; e < EdgeV.Len(); e++) {
141        fprintf(F, "  %d -> %d;\n", EdgeV[e].Val1(), EdgeV[e].Val2()); }
142    } else {
143      for (int n = 0; n < Nodes; n++) { fprintf(F, "  %d;\n", n); }
144    }
145    if (! Desc.Empty()) {
146      fprintf(F, "  label = \"\\n%s\\n\";", Desc.CStr());
147      fprintf(F, "  fontsize=24;\n");
148    }
149    fprintf(F, "}\n");
150    fclose(F);
151  }
152  void TGraphKey::DrawGViz(const TStr& OutFNm, const TStr& Desc, const TStr& NodeAttrs, const int& Size) const {
153    const TStr DotFNm = OutFNm.GetFMid()+".dot";
154    SaveGViz(DotFNm, Desc, NodeAttrs, Size);
155    TSnap::TSnapDetail::GVizDoLayout(DotFNm, OutFNm, gvlDot);
156  }
157  bool TGraphKey::IsIsomorph(const TGraphKey& Key1, const TGraphKey& Key2, const TIntV& NodeIdMap) {
158    const TIntPrV& EdgeV1 = Key1.EdgeV;
159    const TIntPrV& EdgeV2 = Key2.EdgeV;
160    if (Key1.Nodes != Key2.Nodes || EdgeV1.Len() != EdgeV2.Len()) { return false; }
161    for (int e1 = 0; e1 < EdgeV1.Len(); e1++) {
162      const TIntPr Edge2(NodeIdMap[EdgeV1[e1].Val1], NodeIdMap[EdgeV1[e1].Val2]);
163      if (EdgeV2.SearchBin(Edge2) == -1) return false;
164    }
165    return true;
166  }
167  bool TGraphKey::IsIsomorph(const TGraphKey& Key1, const TGraphKey& Key2, const TVec<TIntV>& NodeIdMapV) {
168    int IsoPermId;
169    return IsIsomorph(Key1, Key2, NodeIdMapV, IsoPermId);
170  }
171  bool TGraphKey::IsIsomorph(const TGraphKey& Key1, const TGraphKey& Key2, const TVec<TIntV>& NodeIdMapV, int& IsoPermId) {
172    const TIntPrV& EdgeV1 = Key1.EdgeV;
173    const TIntPrV& EdgeV2 = Key2.EdgeV;
174    if (Key1.Nodes != Key2.Nodes || EdgeV1.Len() != EdgeV2.Len()) return false;
175    const int Nodes = NodeIdMapV[0].Len();
176    TIntV AdjMtx2(Nodes*Nodes);
177    for (int i = 0; i < EdgeV2.Len(); i++) {
178      AdjMtx2[EdgeV2[i].Val1*Nodes + EdgeV2[i].Val2] = 1;
179    }
180    for (int perm = 0; perm < NodeIdMapV.Len(); perm++) {
181      const TIntV& NodeIdMap = NodeIdMapV[perm];
182      bool IsIso = true;
183      for (int e1 = 0; e1 < EdgeV1.Len(); e1++) {
184        const int NId1 = NodeIdMap[EdgeV1[e1].Val1];
185        const int NId2 = NodeIdMap[EdgeV1[e1].Val2];
186        if (AdjMtx2[NId1*Nodes + NId2] != 1) {
187          IsIso = false;  break; }
188      }
189      if (IsIso) {
190        IsoPermId = perm;
191        return true; }
192    }
193    IsoPermId = -1;
194    return false;
195  }
196  bool TSimpleGraph::Join(const TSimpleGraph& G1, const TSimpleGraph& G2) {
197    const int Edges1 = G1.GetEdges();
198    const int Edges2 = G2.GetEdges();
199    const TIntPrV& EdgeV1 = G1.EdgeV;
200    const TIntPrV& EdgeV2 = G2.EdgeV;
201    const int MxEdges = Edges1+1;
202    if (GetEdges() != MxEdges) EdgeV.Gen(MxEdges);
203    IAssert(Edges1 == Edges2);
204    int e=0, g1=0, g2=0;
205    while (g1 < Edges1 && g2 < Edges2) {
206      if (e == MxEdges) return false;
207      if (abs(g1 - g2) > 1) return false;
208      if (EdgeV1[g1] == EdgeV2[g2]) { e++;  g1++;  g2++; }
<span onclick='openModal()' class='match'>209      else if (EdgeV1[g1] < EdgeV2[g2]) { e++;  g1++; }
210      else { e++;  g2++; }
211    }
</span>212    e=0; g1=0; g2=0;
213    while (g1 < Edges1 && g2 < Edges2) {
214      if (EdgeV1[g1] == EdgeV2[g2]) {
215        EdgeV[e] = EdgeV1[g1];  e++;  g1++;  g2++; }
216      else if (EdgeV1[g1] < EdgeV2[g2]) {
217        EdgeV[e] = EdgeV1[g1];  e++;  g1++; }
218      else {
219        EdgeV[e] = EdgeV2[g2];  e++;  g2++; }
220    }
221    if (g1 == Edges1 && g2 == Edges2 && e == MxEdges) return true;
222    if (e+1 == MxEdges) {
223      if (g1+1 == Edges1 && g2 == Edges2) {
224        EdgeV[e] = EdgeV1.Last();
225        return true;
226      }
227      if (g1 == Edges1 && g2+1 == Edges2) {
228        EdgeV[e] = EdgeV2.Last();
229        return true;
230      }
231    }
232    return false;
233  }
234  void TSimpleGraph::Dump(const TStr& Desc) const {
235    if (! Desc.Empty()) printf("%s. Edges: %d\n", Desc.CStr(), EdgeV.Len());
236    else printf("Edges: %d\n", EdgeV.Len());
237    for (int i = 0; i < EdgeV.Len(); i++) {
238      printf("\t%d\t%d\n", EdgeV[i].Val1(), EdgeV[i].Val2());
239    }
240  }
241  void TSubGraphsEnum::Gen2Graphs() {
242    SgV.Gen(NGraph->GetEdges(), 0);
243    TSimpleGraph SimpleG;
244    TIntPrV& EdgeV = SimpleG.GetEdgeV();
245    EdgeV.Gen(1);
246    for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
247      for (int e = 0; e < NI.GetOutDeg(); e++) {
248        EdgeV[0] = TIntPr(NI.GetId(), NI.GetOutNId(e));
249        SgV.Add(SimpleG);
250      }
251    }
252    SgV.Sort();
253    EdgeV.Gen(2);
254    for (int g1 = 0; g1 < SgV.Len()-1; g1++) {
255      const TIntPr& E1 = SgV[g1].GetEdgeV()[0];
256      for (int g2 = g1+1; g2 < SgV.Len(); g2++) {
257        const TIntPr& E2 = SgV[g2].GetEdgeV()[0];
258        if (E1.Val2 == E2.Val1 || E1.Val1 == E2.Val2 || E1.Val1 == E2.Val1 || E1.Val2 == E2.Val2) {
259          EdgeV[0] = TMath::Mn(E1, E2);
260          EdgeV[1] = TMath::Mx(E1, E2);
261          SimpleG.Dump();
262          NextSgV.Add(SimpleG);
263        }
264      }
265    }
266    SgV.MoveFrom(NextSgV);
267  }
268  void TSubGraphsEnum::EnumSubGraphs(const int& MaxEdges) {
269    TExeTm ExeTm;
270    Gen2Graphs();
271    printf("  %2d edge graphs:  %d\t[%s]\n", 2, SgV.Len(), ExeTm.GetTmStr());  ExeTm.Tick();
272    TSimpleGraph SimpleG;
273    TIntPrV& EdgeV = SimpleG.GetEdgeV();
274    for (int edges = 3; edges <= MaxEdges; edges++) {
275      EdgeV.Clr();
276      printf("  %2d edge graphs:", edges);
277      for (int g1 = 0; g1 < SgV.Len()-1; g1++) {
278        for (int g2 = g1+1; g2 < SgV.Len(); g2++) {
279          if (SimpleG.Join(SgV[g1], SgV[g2])) { NextSgV.Add(SimpleG); }
280        }
281      }
282      printf("  candidates: %8d [%s]", NextSgV.Len(), ExeTm.GetTmStr());  ExeTm.Tick();
283      NextSgV.Sort();
284      SgV.Gen(NextSgV.Len(), 0);
285      SgV.Add(NextSgV[0]);
286      for (int i = 1; i < NextSgV.Len(); i++) {
287        if (SgV.Last() != NextSgV[i]) {
288          SgV.Add(NextSgV[i]);
289        }
290      }
291      NextSgV.Clr(false);
292      printf("  total: %8d [%s]\n", SgV.Len(), ExeTm.GetTmStr());  ExeTm.Tick();
293    }
294  }
295  void TSubGraphsEnum::RecurBfs(const int& MxDepth) {
296    TExeTm ExeTm;
297    SgV.Clr(true);
298    for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
299      TSimpleGraph SimpleG;
300      RecurBfs(NI.GetId(), MxDepth, SimpleG);
301      printf(".");
302    }
303    printf("\ncandidates: %d\n", SgV.Len());
304    SgV.Sort();
305    int Cnt = 1;
306    for (int i = 1; i < SgV.Len(); i++) {
307      if (SgV[i-1] != SgV[i]) Cnt++;
308    }
309    printf("distinct:   %d\t[%s]\n", Cnt, ExeTm.GetTmStr());
310  }
311  void TSubGraphsEnum::RecurBfs(const int& NId, const int& Depth, TSimpleGraph& PrevG) {
312    if (Depth == 0) {
313      TIntPrV& EdgeV = PrevG();
314      EdgeV.Sort();
315      for (int i = 1; i < EdgeV.Len(); i++) {
316        if (EdgeV[i-1] == EdgeV[i]) { return; }
317      }
318      SgV.Add(PrevG);
319      return;
320    }
321    const TNGraph::TNodeI NI = NGraph ->GetNI(NId);
322    for (int e = 0; e < NI.GetOutDeg(); e++) {
323      TSimpleGraph CurG = PrevG;
324      CurG.AddEdge(NI.GetId(), NI.GetOutNId(e));
325      RecurBfs(NI.GetOutNId(e), Depth-1, CurG);
326    }
327    for (int e = 0; e < NI.GetInDeg(); e++) {
328      TSimpleGraph CurG = PrevG;
329      CurG.AddEdge(NI.GetInNId(e), NI.GetId());
330      RecurBfs(NI.GetInNId(e), Depth-1, CurG);
331    }
332  }
333  void TSubGraphsEnum::RecurBfs1(const int& MxDepth) {
334    TExeTm ExeTm;
335    SgV.Clr(true);
336    for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
337      TSimpleGraph SimpleG;
338      RecurBfs1(NI.GetId(), MxDepth);
339      printf(".");
340    }
341    printf("candidates: %d\n", SgV.Len());
342    SgV.Sort();
343    int Cnt = 1;
344    for (int i = 1; i < SgV.Len(); i++) {
345      if (SgV[i-1]!=SgV[i]) {
346        Cnt++;
347      }
348    }
349    printf("distinct:   %d\t[%s]\n", Cnt, ExeTm.GetTmStr());
350  }
351  void TSubGraphsEnum::RecurBfs1(const int& NId, const int& Depth) {
352    if (Depth == 0) {
353      TIntPrV EdgeV;
354      EdgeH.GetKeyV(EdgeV);
355      EdgeV.Sort();
356      SgV.Add(EdgeV);
357      return;
358    }
359    const TNGraph::TNodeI NI = NGraph ->GetNI(NId);
360    for (int e = 0; e < NI.GetOutDeg(); e++) {
361      const TIntPr Edge(NId, NI.GetOutNId(e));
362      if (! EdgeH.IsKey(Edge)) {
363        EdgeH.AddKey(Edge);
364        RecurBfs1(NI.GetOutNId(e), Depth-1);
365        EdgeH.DelKey(Edge);
366      }
367    }
368    for (int e = 0; e < NI.GetInDeg(); e++) {
369      const TIntPr Edge(NI.GetInNId(e), NId);
370      if (! EdgeH.IsKey(Edge)) {
371        EdgeH.AddKey(Edge);
372        RecurBfs1(NI.GetInNId(e), Depth-1);
373        EdgeH.DelKey(Edge);
374      }
375    }
376  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Selection.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ghash.cpp</div>
                </div>
                <div class="column column_space"><pre><code>53  		if (a < b) {
54  			start = a;
55  			end = b;
56  		} else {
57  			start = b;
58  			end = a;
59  		}
60  	}
</pre></code></div>
                <div class="column column_space"><pre><code>209      else if (EdgeV1[g1] < EdgeV2[g2]) { e++;  g1++; }
210      else { e++;  g2++; }
211    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    