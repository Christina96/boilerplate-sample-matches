
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 42, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trie.cpp</h3>
            <pre><code>1  #include "trie.h"
2  #include "dawg.h"
3  #include "dict.h"
4  #include "helpers.h"
5  #include "kdpair.h"
6  namespace tesseract {
7  const char kDoNotReverse[] = "RRP_DO_NO_REVERSE";
8  const char kReverseIfHasRTL[] = "RRP_REVERSE_IF_HAS_RTL";
9  const char kForceReverse[] = "RRP_FORCE_REVERSE";
10  const char *const RTLReversePolicyNames[] = {kDoNotReverse, kReverseIfHasRTL, kForceReverse};
11  const char Trie::kAlphaPatternUnicode[] = "\u2000";
12  const char Trie::kDigitPatternUnicode[] = "\u2001";
13  const char Trie::kAlphanumPatternUnicode[] = "\u2002";
14  const char Trie::kPuncPatternUnicode[] = "\u2003";
15  const char Trie::kLowerPatternUnicode[] = "\u2004";
16  const char Trie::kUpperPatternUnicode[] = "\u2005";
17  const char *Trie::get_reverse_policy_name(RTLReversePolicy reverse_policy) {
18    return RTLReversePolicyNames[reverse_policy];
19  }
20  void Trie::clear() {
21    for (auto node : nodes_) {
22      delete node;
23    }
24    nodes_.clear();
25    root_back_freelist_.clear();
26    num_edges_ = 0;
27    new_dawg_node(); 
28  }
29  bool Trie::edge_char_of(NODE_REF node_ref, NODE_REF next_node, int direction, bool word_end,
30                          UNICHAR_ID unichar_id, EDGE_RECORD **edge_ptr,
31                          EDGE_INDEX *edge_index) const {
32    if (debug_level_ == 3) {
33      tprintf("edge_char_of() given node_ref " REFFORMAT " next_node " REFFORMAT
34              " direction %d word_end %d unichar_id %d, exploring node:\n",
35              node_ref, next_node, direction, word_end, unichar_id);
36      if (node_ref != NO_EDGE) {
37        print_node(node_ref, nodes_[node_ref]->forward_edges.size());
38      }
39    }
40    if (node_ref == NO_EDGE) {
41      return false;
42    }
43    assert(static_cast<size_t>(node_ref) < nodes_.size());
44    EDGE_VECTOR &vec = (direction == FORWARD_EDGE) ? nodes_[node_ref]->forward_edges
45                                                   : nodes_[node_ref]->backward_edges;
46    int vec_size = vec.size();
47    if (node_ref == 0 && direction == FORWARD_EDGE) { 
48      EDGE_INDEX start = 0;
49      EDGE_INDEX end = vec_size - 1;
50      EDGE_INDEX k;
51      int compare;
52      while (start <= end) {
53        k = (start + end) >> 1; 
54        compare = given_greater_than_edge_rec(next_node, word_end, unichar_id, vec[k]);
55        if (compare == 0) { 
56          *edge_ptr = &(vec[k]);
57          *edge_index = k;
58          return true;
59        } else if (compare == 1) { 
60          start = k + 1;
61        } else { 
62          end = k - 1;
63        }
64      }
65    } else { 
66      for (int i = 0; i < vec_size; ++i) {
67        EDGE_RECORD &edge_rec = vec[i];
68        if (edge_rec_match(next_node, word_end, unichar_id, next_node_from_edge_rec(edge_rec),
69                           end_of_word_from_edge_rec(edge_rec), unichar_id_from_edge_rec(edge_rec))) {
70          *edge_ptr = &(edge_rec);
71          *edge_index = i;
72          return true;
73        }
74      }
75    }
76    return false; 
77  }
78  bool Trie::add_edge_linkage(NODE_REF node1, NODE_REF node2, bool marker_flag, int direction,
79                              bool word_end, UNICHAR_ID unichar_id) {
80    EDGE_VECTOR *vec = (direction == FORWARD_EDGE) ? &(nodes_[node1]->forward_edges)
81                                                   : &(nodes_[node1]->backward_edges);
82    unsigned search_index;
83    if (node1 == 0 && direction == FORWARD_EDGE) {
84      search_index = 0; 
85      while (search_index < vec->size() &&
86             given_greater_than_edge_rec(node2, word_end, unichar_id, (*vec)[search_index]) == 1) {
87        search_index++;
88      }
89    } else {
90      search_index = vec->size(); 
91    }
92    EDGE_RECORD edge_rec;
93    link_edge(&edge_rec, node2, marker_flag, direction, word_end, unichar_id);
94    if (node1 == 0 && direction == BACKWARD_EDGE && !root_back_freelist_.empty()) {
95      EDGE_INDEX edge_index = root_back_freelist_.back();
96      root_back_freelist_.pop_back();
97      (*vec)[edge_index] = edge_rec;
98    } else if (search_index < vec->size()) {
99      vec->insert(vec->begin() + search_index, edge_rec);
100    } else {
101      vec->push_back(edge_rec);
102    }
103    if (debug_level_ > 1) {
104      tprintf("new edge in nodes_[" REFFORMAT "]: ", node1);
105      print_edge_rec(edge_rec);
106      tprintf("\n");
107    }
108    num_edges_++;
109    return true;
110  }
111  void Trie::add_word_ending(EDGE_RECORD *edge_ptr, NODE_REF the_next_node, bool marker_flag,
112                             UNICHAR_ID unichar_id) {
113    EDGE_RECORD *back_edge_ptr;
114    EDGE_INDEX back_edge_index;
115    ASSERT_HOST(edge_char_of(the_next_node, NO_EDGE, BACKWARD_EDGE, false, unichar_id, &back_edge_ptr,
116                             &back_edge_index));
117    if (marker_flag) {
118      *back_edge_ptr |= (MARKER_FLAG << flag_start_bit_);
119      *edge_ptr |= (MARKER_FLAG << flag_start_bit_);
120    }
121    *back_edge_ptr |= (WERD_END_FLAG << flag_start_bit_);
122    *edge_ptr |= (WERD_END_FLAG << flag_start_bit_);
123  }
124  bool Trie::add_word_to_dawg(const WERD_CHOICE &word, const std::vector<bool> *repetitions) {
125    if (word.length() <= 0) {
126      return false; 
127    }
128    if (repetitions != nullptr) {
129      ASSERT_HOST(repetitions->size() == word.length());
130    }
131    for (unsigned i = 0; i < word.length(); ++i) {
132      if (word.unichar_id(i) < 0 || word.unichar_id(i) >= unicharset_size_) {
133        return false;
134      }
135    }
136    EDGE_RECORD *edge_ptr;
137    NODE_REF last_node = 0;
138    NODE_REF the_next_node;
139    bool marker_flag = false;
140    EDGE_INDEX edge_index;
141    int32_t still_finding_chars = true;
142    int32_t word_end = false;
143    bool add_failed = false;
144    bool found;
145    if (debug_level_ > 1) {
146      word.print("\nAdding word: ");
147    }
148    UNICHAR_ID unichar_id;
149    unsigned i;
150    for (i = 0; i < word.length() - 1; ++i) {
151      unichar_id = word.unichar_id(i);
152      marker_flag = (repetitions != nullptr) ? (*repetitions)[i] : false;
153      if (debug_level_ > 1) {
154        tprintf("Adding letter %d\n", unichar_id);
155      }
156      if (still_finding_chars) {
157        found = edge_char_of(last_node, NO_EDGE, FORWARD_EDGE, word_end, unichar_id, &edge_ptr,
158                             &edge_index);
159        if (found && debug_level_ > 1) {
160          tprintf("exploring edge " REFFORMAT " in node " REFFORMAT "\n", edge_index, last_node);
161        }
162        if (!found) {
163          still_finding_chars = false;
164        } else if (next_node_from_edge_rec(*edge_ptr) == 0) {
165          word_end = true;
166          still_finding_chars = false;
167          remove_edge(last_node, 0, word_end, unichar_id);
168        } else {
169          if (marker_flag) {
170            set_marker_flag_in_edge_rec(edge_ptr);
171          }
172          last_node = next_node_from_edge_rec(*edge_ptr);
173        }
174      }
175      if (!still_finding_chars) {
176        the_next_node = new_dawg_node();
177        if (debug_level_ > 1) {
178          tprintf("adding node " REFFORMAT "\n", the_next_node);
179        }
180        if (the_next_node == 0) {
181          add_failed = true;
182          break;
183        }
184        if (!add_new_edge(last_node, the_next_node, marker_flag, word_end, unichar_id)) {
185          add_failed = true;
186          break;
187        }
188        word_end = false;
189        last_node = the_next_node;
190      }
191    }
192    the_next_node = 0;
<span onclick='openModal()' class='match'>193    unichar_id = word.unichar_id(i);
194    marker_flag = (repetitions != nullptr) ? (*repetitions)[i] : false;
195    if (debug_level_ > 1) {
196      tprintf("Adding letter %d\n", unichar_id);
197    }
198    if (still_finding_chars &&
</span>199        edge_char_of(last_node, NO_EDGE, FORWARD_EDGE, false, unichar_id, &edge_ptr, &edge_index)) {
200      add_word_ending(edge_ptr, next_node_from_edge_rec(*edge_ptr), marker_flag, unichar_id);
201    } else {
202      if (!add_failed && !add_new_edge(last_node, the_next_node, marker_flag, true, unichar_id)) {
203        add_failed = true;
204      }
205    }
206    if (add_failed) {
207      tprintf("Re-initializing document dictionary...\n");
208      clear();
209      return false;
210    } else {
211      return true;
212    }
213  }
214  NODE_REF Trie::new_dawg_node() {
215    auto *node = new TRIE_NODE_RECORD();
216    nodes_.push_back(node);
217    return nodes_.size() - 1;
218  }
219  bool Trie::read_and_add_word_list(const char *filename, const UNICHARSET &unicharset,
220                                    Trie::RTLReversePolicy reverse_policy) {
221    std::vector<std::string> word_list;
222    if (!read_word_list(filename, &word_list)) {
223      return false;
224    }
225    std::sort(word_list.begin(), word_list.end(),
226              [](auto &s1, auto &s2) { return s1.size() > s2.size(); });
227    return add_word_list(word_list, unicharset, reverse_policy);
228  }
229  bool Trie::read_word_list(const char *filename, std::vector<std::string> *words) {
230    FILE *word_file;
231    char line_str[CHARS_PER_LINE];
232    int word_count = 0;
233    word_file = fopen(filename, "rb");
234    if (word_file == nullptr) {
235      return false;
236    }
237    while (fgets(line_str, sizeof(line_str), word_file) != nullptr) {
238      chomp_string(line_str); 
239      std::string word_str(line_str);
240      ++word_count;
241      if (debug_level_ && word_count % 10000 == 0) {
242        tprintf("Read %d words so far\n", word_count);
243      }
244      words->push_back(word_str);
245    }
246    if (debug_level_) {
247      tprintf("Read %d words total.\n", word_count);
248    }
249    fclose(word_file);
250    return true;
251  }
252  bool Trie::add_word_list(const std::vector<std::string> &words, const UNICHARSET &unicharset,
253                           Trie::RTLReversePolicy reverse_policy) {
254    for (const auto &i : words) {
255      WERD_CHOICE word(i.c_str(), unicharset);
256      if (word.empty() || word.contains_unichar_id(INVALID_UNICHAR_ID)) {
257        continue;
258      }
259      if ((reverse_policy == RRP_REVERSE_IF_HAS_RTL && word.has_rtl_unichar_id()) ||
260          reverse_policy == RRP_FORCE_REVERSE) {
261        word.reverse_and_mirror_unichar_ids();
262      }
263      if (!word_in_dawg(word)) {
264        add_word_to_dawg(word);
265        if (!word_in_dawg(word)) {
266          tprintf("Error: word '%s' not in DAWG after adding it\n", i.c_str());
267          return false;
268        }
269      }
270    }
271    return true;
272  }
273  void Trie::initialize_patterns(UNICHARSET *unicharset) {
274    unicharset->unichar_insert(kAlphaPatternUnicode);
275    alpha_pattern_ = unicharset->unichar_to_id(kAlphaPatternUnicode);
276    unicharset->unichar_insert(kDigitPatternUnicode);
277    digit_pattern_ = unicharset->unichar_to_id(kDigitPatternUnicode);
278    unicharset->unichar_insert(kAlphanumPatternUnicode);
279    alphanum_pattern_ = unicharset->unichar_to_id(kAlphanumPatternUnicode);
280    unicharset->unichar_insert(kPuncPatternUnicode);
281    punc_pattern_ = unicharset->unichar_to_id(kPuncPatternUnicode);
282    unicharset->unichar_insert(kLowerPatternUnicode);
283    lower_pattern_ = unicharset->unichar_to_id(kLowerPatternUnicode);
284    unicharset->unichar_insert(kUpperPatternUnicode);
285    upper_pattern_ = unicharset->unichar_to_id(kUpperPatternUnicode);
286    initialized_patterns_ = true;
287    unicharset_size_ = unicharset->size();
288  }
289  void Trie::unichar_id_to_patterns(UNICHAR_ID unichar_id, const UNICHARSET &unicharset,
290                                    std::vector<UNICHAR_ID> *vec) const {
291    bool is_alpha = unicharset.get_isalpha(unichar_id);
292    if (is_alpha) {
293      vec->push_back(alpha_pattern_);
294      vec->push_back(alphanum_pattern_);
295      if (unicharset.get_islower(unichar_id)) {
296        vec->push_back(lower_pattern_);
297      } else if (unicharset.get_isupper(unichar_id)) {
298        vec->push_back(upper_pattern_);
299      }
300    }
301    if (unicharset.get_isdigit(unichar_id)) {
302      vec->push_back(digit_pattern_);
303      if (!is_alpha) {
304        vec->push_back(alphanum_pattern_);
305      }
306    }
307    if (unicharset.get_ispunctuation(unichar_id)) {
308      vec->push_back(punc_pattern_);
309    }
310  }
311  UNICHAR_ID Trie::character_class_to_pattern(char ch) {
312    if (ch == 'c') {
313      return alpha_pattern_;
314    } else if (ch == 'd') {
315      return digit_pattern_;
316    } else if (ch == 'n') {
317      return alphanum_pattern_;
318    } else if (ch == 'p') {
319      return punc_pattern_;
320    } else if (ch == 'a') {
321      return lower_pattern_;
322    } else if (ch == 'A') {
323      return upper_pattern_;
324    } else {
325      return INVALID_UNICHAR_ID;
326    }
327  }
328  bool Trie::read_pattern_list(const char *filename, const UNICHARSET &unicharset) {
329    if (!initialized_patterns_) {
330      tprintf("please call initialize_patterns() before read_pattern_list()\n");
331      return false;
332    }
333    FILE *pattern_file = fopen(filename, "rb");
334    if (pattern_file == nullptr) {
335      tprintf("Error opening pattern file %s\n", filename);
336      return false;
337    }
338    int pattern_count = 0;
339    char string[CHARS_PER_LINE];
340    while (fgets(string, CHARS_PER_LINE, pattern_file) != nullptr) {
341      chomp_string(string); 
342      WERD_CHOICE word(&unicharset);
343      std::vector<bool> repetitions_vec;
344      const char *str_ptr = string;
345      int step = unicharset.step(str_ptr);
346      bool failed = false;
347      while (step > 0) {
348        UNICHAR_ID curr_unichar_id = INVALID_UNICHAR_ID;
349        if (step == 1 && *str_ptr == '\\') {
350          ++str_ptr;
351          if (*str_ptr == '\\') { 
352            curr_unichar_id = unicharset.unichar_to_id(str_ptr, step);
353          } else {
354  #if 0 
355            if (word.length() < kSaneNumConcreteChars) {
356              tprintf(
357                  "Please provide at least %d concrete characters at the"
358                  " beginning of the pattern\n",
359                  kSaneNumConcreteChars);
360              failed = true;
361              break;
362            }
363  #endif
364            curr_unichar_id = character_class_to_pattern(*str_ptr);
365          }
366        } else {
367          curr_unichar_id = unicharset.unichar_to_id(str_ptr, step);
368        }
369        if (curr_unichar_id == INVALID_UNICHAR_ID) {
370          failed = true;
371          break; 
372        }
373        word.append_unichar_id(curr_unichar_id, 1, 0.0, 0.0);
374        repetitions_vec.push_back(false);
375        str_ptr += step;
376        step = unicharset.step(str_ptr);
377        if (step == 1 && *str_ptr == '\\' && *(str_ptr + 1) == '*') {
378          repetitions_vec[repetitions_vec.size() - 1] = true;
379          str_ptr += 2;
380          step = unicharset.step(str_ptr);
381        }
382      }
383      if (failed) {
384        tprintf("Invalid user pattern %s\n", string);
385        continue;
386      }
387      if (debug_level_ > 2) {
388        tprintf("Inserting expanded user pattern %s\n", word.debug_string().c_str());
389      }
390      if (!this->word_in_dawg(word)) {
391        this->add_word_to_dawg(word, &repetitions_vec);
392        if (!this->word_in_dawg(word)) {
393          tprintf("Error: failed to insert pattern '%s'\n", string);
394        }
395      }
396      ++pattern_count;
397    }
398    if (debug_level_) {
399      tprintf("Read %d valid patterns from %s\n", pattern_count, filename);
400    }
401    fclose(pattern_file);
402    return true;
403  }
404  void Trie::remove_edge_linkage(NODE_REF node1, NODE_REF node2, int direction, bool word_end,
405                                 UNICHAR_ID unichar_id) {
406    EDGE_RECORD *edge_ptr = nullptr;
407    EDGE_INDEX edge_index = 0;
408    ASSERT_HOST(edge_char_of(node1, node2, direction, word_end, unichar_id, &edge_ptr, &edge_index));
409    if (debug_level_ > 1) {
410      tprintf("removed edge in nodes_[" REFFORMAT "]: ", node1);
411      print_edge_rec(*edge_ptr);
412      tprintf("\n");
413    }
414    if (direction == FORWARD_EDGE) {
415      nodes_[node1]->forward_edges.erase(nodes_[node1]->forward_edges.begin() + edge_index);
416    } else if (node1 == 0) {
417      KillEdge(&nodes_[node1]->backward_edges[edge_index]);
418      root_back_freelist_.push_back(edge_index);
419    } else {
420      nodes_[node1]->backward_edges.erase(nodes_[node1]->backward_edges.begin() + edge_index);
421    }
422    --num_edges_;
423  }
424  SquishedDawg *Trie::trie_to_dawg() {
425    root_back_freelist_.clear(); 
426    if (debug_level_ > 2) {
427      print_all("Before reduction:", MAX_NODE_EDGES_DISPLAY);
428    }
429    std::vector<bool> reduced_nodes(nodes_.size());
430    this->reduce_node_input(0, reduced_nodes);
431    if (debug_level_ > 2) {
432      print_all("After reduction:", MAX_NODE_EDGES_DISPLAY);
433    }
434    std::vector<NODE_REF> node_ref_map(nodes_.size() + 1);
435    unsigned i;
436    for (i = 0; i < nodes_.size(); ++i) {
437      node_ref_map[i + 1] = node_ref_map[i] + nodes_[i]->forward_edges.size();
438    }
439    int num_forward_edges = node_ref_map[i];
440    auto edge_array = new EDGE_RECORD[num_forward_edges];
441    EDGE_ARRAY edge_array_ptr = edge_array;
442    for (i = 0; i < nodes_.size(); ++i) {
443      TRIE_NODE_RECORD *node_ptr = nodes_[i];
444      int end = node_ptr->forward_edges.size();
445      for (int j = 0; j < end; ++j) {
446        EDGE_RECORD &edge_rec = node_ptr->forward_edges[j];
447        NODE_REF node_ref = next_node_from_edge_rec(edge_rec);
448        ASSERT_HOST(static_cast<size_t>(node_ref) < nodes_.size());
449        UNICHAR_ID unichar_id = unichar_id_from_edge_rec(edge_rec);
450        link_edge(edge_array_ptr, node_ref_map[node_ref], false, FORWARD_EDGE,
451                  end_of_word_from_edge_rec(edge_rec), unichar_id);
452        if (j == end - 1) {
453          set_marker_flag_in_edge_rec(edge_array_ptr);
454        }
455        ++edge_array_ptr;
456      }
457    }
458    return new SquishedDawg(edge_array, num_forward_edges, type_, lang_, perm_, unicharset_size_,
459                            debug_level_);
460  }
461  bool Trie::eliminate_redundant_edges(NODE_REF node, const EDGE_RECORD &edge1,
462                                       const EDGE_RECORD &edge2) {
463    if (debug_level_ > 1) {
464      tprintf("\nCollapsing node %" PRIi64 ":\n", node);
465      print_node(node, MAX_NODE_EDGES_DISPLAY);
466      tprintf("Candidate edges: ");
467      print_edge_rec(edge1);
468      tprintf(", ");
469      print_edge_rec(edge2);
470      tprintf("\n\n");
471    }
472    NODE_REF next_node1 = next_node_from_edge_rec(edge1);
473    NODE_REF next_node2 = next_node_from_edge_rec(edge2);
474    TRIE_NODE_RECORD *next_node2_ptr = nodes_[next_node2];
475    EDGE_RECORD *edge_ptr = nullptr;
476    EDGE_INDEX edge_index;
477    for (unsigned i = 0; i < next_node2_ptr->backward_edges.size(); ++i) {
478      const EDGE_RECORD &bkw_edge = next_node2_ptr->backward_edges[i];
479      NODE_REF curr_next_node = next_node_from_edge_rec(bkw_edge);
480      UNICHAR_ID curr_unichar_id = unichar_id_from_edge_rec(bkw_edge);
481      int curr_word_end = end_of_word_from_edge_rec(bkw_edge);
482      bool marker_flag = marker_flag_from_edge_rec(bkw_edge);
483      add_edge_linkage(next_node1, curr_next_node, marker_flag, BACKWARD_EDGE, curr_word_end,
484                       curr_unichar_id);
485      ASSERT_HOST(edge_char_of(curr_next_node, next_node2, FORWARD_EDGE, curr_word_end,
486                               curr_unichar_id, &edge_ptr, &edge_index));
487      set_next_node_in_edge_rec(edge_ptr, next_node1);
488    }
489    int next_node2_num_edges =
490        (next_node2_ptr->forward_edges.size() + next_node2_ptr->backward_edges.size());
491    if (debug_level_ > 1) {
492      tprintf("removed %d edges from node " REFFORMAT "\n", next_node2_num_edges, next_node2);
493    }
494    next_node2_ptr->forward_edges.clear();
495    next_node2_ptr->backward_edges.clear();
496    num_edges_ -= next_node2_num_edges;
497    return true;
498  }
499  bool Trie::reduce_lettered_edges(EDGE_INDEX edge_index, UNICHAR_ID unichar_id, NODE_REF node,
500                                   EDGE_VECTOR *backward_edges, std::vector<bool> &reduced_nodes) {
501    if (debug_level_ > 1) {
502      tprintf("reduce_lettered_edges(edge=" REFFORMAT ")\n", edge_index);
503    }
504    bool did_something = false;
505    for (unsigned i = edge_index; i < backward_edges->size() - 1; ++i) {
506      UNICHAR_ID curr_unichar_id = INVALID_UNICHAR_ID;
507      while (i < backward_edges->size()) {
508        if (!DeadEdge((*backward_edges)[i])) {
509          curr_unichar_id = unichar_id_from_edge_rec((*backward_edges)[i]);
510          if (curr_unichar_id != unichar_id) {
511            return did_something;
512          }
513          if (can_be_eliminated((*backward_edges)[i])) {
514            break;
515          }
516        }
517        ++i;
518      }
519      if (i == backward_edges->size()) {
520        break;
521      }
522      const EDGE_RECORD &edge_rec = (*backward_edges)[i];
523      for (auto j = i + 1; j < backward_edges->size(); ++j) {
524        const EDGE_RECORD &next_edge_rec = (*backward_edges)[j];
525        if (DeadEdge(next_edge_rec)) {
526          continue;
527        }
528        UNICHAR_ID next_id = unichar_id_from_edge_rec(next_edge_rec);
529        if (next_id != unichar_id) {
530          break;
531        }
532        if (end_of_word_from_edge_rec(next_edge_rec) == end_of_word_from_edge_rec(edge_rec) &&
533            can_be_eliminated(next_edge_rec) &&
534            eliminate_redundant_edges(node, edge_rec, next_edge_rec)) {
535          reduced_nodes[next_node_from_edge_rec(edge_rec)] = false;
536          did_something = true;
537          KillEdge(&(*backward_edges)[j]);
538        }
539      }
540    }
541    return did_something;
542  }
543  void Trie::sort_edges(EDGE_VECTOR *edges) {
544    int num_edges = edges->size();
545    if (num_edges <= 1) {
546      return;
547    }
548    std::vector<KDPairInc<UNICHAR_ID, EDGE_RECORD>> sort_vec;
549    sort_vec.reserve(num_edges);
550    for (int i = 0; i < num_edges; ++i) {
551      sort_vec.emplace_back(unichar_id_from_edge_rec((*edges)[i]), (*edges)[i]);
552    }
553    std::sort(sort_vec.begin(), sort_vec.end());
554    for (int i = 0; i < num_edges; ++i) {
555      (*edges)[i] = sort_vec[i].data();
556    }
557  }
558  void Trie::reduce_node_input(NODE_REF node, std::vector<bool> &reduced_nodes) {
559    EDGE_VECTOR &backward_edges = nodes_[node]->backward_edges;
560    sort_edges(&backward_edges);
561    if (debug_level_ > 1) {
562      tprintf("reduce_node_input(node=" REFFORMAT ")\n", node);
563      print_node(node, MAX_NODE_EDGES_DISPLAY);
564    }
565    EDGE_INDEX edge_index = 0;
566    while (static_cast<size_t>(edge_index) < backward_edges.size()) {
567      if (DeadEdge(backward_edges[edge_index])) {
568        continue;
569      }
570      UNICHAR_ID unichar_id = unichar_id_from_edge_rec(backward_edges[edge_index]);
571      while (reduce_lettered_edges(edge_index, unichar_id, node, &backward_edges, reduced_nodes)) {
572        ;
573      }
574      while (static_cast<size_t>(++edge_index) < backward_edges.size()) {
575        UNICHAR_ID id = unichar_id_from_edge_rec(backward_edges[edge_index]);
576        if (!DeadEdge(backward_edges[edge_index]) && id != unichar_id) {
577          break;
578        }
579      }
580    }
581    reduced_nodes[node] = true; 
582    if (debug_level_ > 1) {
583      tprintf("Node " REFFORMAT " after reduction:\n", node);
584      print_node(node, MAX_NODE_EDGES_DISPLAY);
585    }
586    for (auto &backward_edge : backward_edges) {
587      if (DeadEdge(backward_edge)) {
588        continue;
589      }
590      NODE_REF next_node = next_node_from_edge_rec(backward_edge);
591      if (next_node != 0 && !reduced_nodes[next_node]) {
592        reduce_node_input(next_node, reduced_nodes);
593      }
594    }
595  }
596  void Trie::print_node(NODE_REF node, int max_num_edges) const {
597    if (node == NO_EDGE) {
598      return; 
599    }
600    TRIE_NODE_RECORD *node_ptr = nodes_[node];
601    int num_fwd = node_ptr->forward_edges.size();
602    int num_bkw = node_ptr->backward_edges.size();
603    EDGE_VECTOR *vec;
604    for (int dir = 0; dir < 2; ++dir) {
605      if (dir == 0) {
606        vec = &(node_ptr->forward_edges);
607        tprintf(REFFORMAT " (%d %d): ", node, num_fwd, num_bkw);
608      } else {
609        vec = &(node_ptr->backward_edges);
610        tprintf("\t");
611      }
612      int i;
613      for (i = 0; (dir == 0 ? i < num_fwd : i < num_bkw) && i < max_num_edges; ++i) {
614        if (DeadEdge((*vec)[i])) {
615          continue;
616        }
617        print_edge_rec((*vec)[i]);
618        tprintf(" ");
619      }
620      if (dir == 0 ? i < num_fwd : i < num_bkw) {
621        tprintf("...");
622      }
623      tprintf("\n");
624    }
625  }
626  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trie.cpp</h3>
            <pre><code>1  #include "trie.h"
2  #include "dawg.h"
3  #include "dict.h"
4  #include "helpers.h"
5  #include "kdpair.h"
6  namespace tesseract {
7  const char kDoNotReverse[] = "RRP_DO_NO_REVERSE";
8  const char kReverseIfHasRTL[] = "RRP_REVERSE_IF_HAS_RTL";
9  const char kForceReverse[] = "RRP_FORCE_REVERSE";
10  const char *const RTLReversePolicyNames[] = {kDoNotReverse, kReverseIfHasRTL, kForceReverse};
11  const char Trie::kAlphaPatternUnicode[] = "\u2000";
12  const char Trie::kDigitPatternUnicode[] = "\u2001";
13  const char Trie::kAlphanumPatternUnicode[] = "\u2002";
14  const char Trie::kPuncPatternUnicode[] = "\u2003";
15  const char Trie::kLowerPatternUnicode[] = "\u2004";
16  const char Trie::kUpperPatternUnicode[] = "\u2005";
17  const char *Trie::get_reverse_policy_name(RTLReversePolicy reverse_policy) {
18    return RTLReversePolicyNames[reverse_policy];
19  }
20  void Trie::clear() {
21    for (auto node : nodes_) {
22      delete node;
23    }
24    nodes_.clear();
25    root_back_freelist_.clear();
26    num_edges_ = 0;
27    new_dawg_node(); 
28  }
29  bool Trie::edge_char_of(NODE_REF node_ref, NODE_REF next_node, int direction, bool word_end,
30                          UNICHAR_ID unichar_id, EDGE_RECORD **edge_ptr,
31                          EDGE_INDEX *edge_index) const {
32    if (debug_level_ == 3) {
33      tprintf("edge_char_of() given node_ref " REFFORMAT " next_node " REFFORMAT
34              " direction %d word_end %d unichar_id %d, exploring node:\n",
35              node_ref, next_node, direction, word_end, unichar_id);
36      if (node_ref != NO_EDGE) {
37        print_node(node_ref, nodes_[node_ref]->forward_edges.size());
38      }
39    }
40    if (node_ref == NO_EDGE) {
41      return false;
42    }
43    assert(static_cast<size_t>(node_ref) < nodes_.size());
44    EDGE_VECTOR &vec = (direction == FORWARD_EDGE) ? nodes_[node_ref]->forward_edges
45                                                   : nodes_[node_ref]->backward_edges;
46    int vec_size = vec.size();
47    if (node_ref == 0 && direction == FORWARD_EDGE) { 
48      EDGE_INDEX start = 0;
49      EDGE_INDEX end = vec_size - 1;
50      EDGE_INDEX k;
51      int compare;
52      while (start <= end) {
53        k = (start + end) >> 1; 
54        compare = given_greater_than_edge_rec(next_node, word_end, unichar_id, vec[k]);
55        if (compare == 0) { 
56          *edge_ptr = &(vec[k]);
57          *edge_index = k;
58          return true;
59        } else if (compare == 1) { 
60          start = k + 1;
61        } else { 
62          end = k - 1;
63        }
64      }
65    } else { 
66      for (int i = 0; i < vec_size; ++i) {
67        EDGE_RECORD &edge_rec = vec[i];
68        if (edge_rec_match(next_node, word_end, unichar_id, next_node_from_edge_rec(edge_rec),
69                           end_of_word_from_edge_rec(edge_rec), unichar_id_from_edge_rec(edge_rec))) {
70          *edge_ptr = &(edge_rec);
71          *edge_index = i;
72          return true;
73        }
74      }
75    }
76    return false; 
77  }
78  bool Trie::add_edge_linkage(NODE_REF node1, NODE_REF node2, bool marker_flag, int direction,
79                              bool word_end, UNICHAR_ID unichar_id) {
80    EDGE_VECTOR *vec = (direction == FORWARD_EDGE) ? &(nodes_[node1]->forward_edges)
81                                                   : &(nodes_[node1]->backward_edges);
82    unsigned search_index;
83    if (node1 == 0 && direction == FORWARD_EDGE) {
84      search_index = 0; 
85      while (search_index < vec->size() &&
86             given_greater_than_edge_rec(node2, word_end, unichar_id, (*vec)[search_index]) == 1) {
87        search_index++;
88      }
89    } else {
90      search_index = vec->size(); 
91    }
92    EDGE_RECORD edge_rec;
93    link_edge(&edge_rec, node2, marker_flag, direction, word_end, unichar_id);
94    if (node1 == 0 && direction == BACKWARD_EDGE && !root_back_freelist_.empty()) {
95      EDGE_INDEX edge_index = root_back_freelist_.back();
96      root_back_freelist_.pop_back();
97      (*vec)[edge_index] = edge_rec;
98    } else if (search_index < vec->size()) {
99      vec->insert(vec->begin() + search_index, edge_rec);
100    } else {
101      vec->push_back(edge_rec);
102    }
103    if (debug_level_ > 1) {
104      tprintf("new edge in nodes_[" REFFORMAT "]: ", node1);
105      print_edge_rec(edge_rec);
106      tprintf("\n");
107    }
108    num_edges_++;
109    return true;
110  }
111  void Trie::add_word_ending(EDGE_RECORD *edge_ptr, NODE_REF the_next_node, bool marker_flag,
112                             UNICHAR_ID unichar_id) {
113    EDGE_RECORD *back_edge_ptr;
114    EDGE_INDEX back_edge_index;
115    ASSERT_HOST(edge_char_of(the_next_node, NO_EDGE, BACKWARD_EDGE, false, unichar_id, &back_edge_ptr,
116                             &back_edge_index));
117    if (marker_flag) {
118      *back_edge_ptr |= (MARKER_FLAG << flag_start_bit_);
119      *edge_ptr |= (MARKER_FLAG << flag_start_bit_);
120    }
121    *back_edge_ptr |= (WERD_END_FLAG << flag_start_bit_);
122    *edge_ptr |= (WERD_END_FLAG << flag_start_bit_);
123  }
124  bool Trie::add_word_to_dawg(const WERD_CHOICE &word, const std::vector<bool> *repetitions) {
125    if (word.length() <= 0) {
126      return false; 
127    }
128    if (repetitions != nullptr) {
129      ASSERT_HOST(repetitions->size() == word.length());
130    }
131    for (unsigned i = 0; i < word.length(); ++i) {
132      if (word.unichar_id(i) < 0 || word.unichar_id(i) >= unicharset_size_) {
133        return false;
134      }
135    }
136    EDGE_RECORD *edge_ptr;
137    NODE_REF last_node = 0;
138    NODE_REF the_next_node;
139    bool marker_flag = false;
140    EDGE_INDEX edge_index;
141    int32_t still_finding_chars = true;
142    int32_t word_end = false;
143    bool add_failed = false;
144    bool found;
145    if (debug_level_ > 1) {
146      word.print("\nAdding word: ");
147    }
148    UNICHAR_ID unichar_id;
149    unsigned i;
150    for (i = 0; i < word.length() - 1; ++i) {
151      unichar_id = word.unichar_id(i);
152      marker_flag = (repetitions != nullptr) ? (*repetitions)[i] : false;
153      if (debug_level_ > 1) {
154        tprintf("Adding letter %d\n", unichar_id);
155      }
156      if (still_finding_chars) {
157        found = edge_char_of(last_node, NO_EDGE, FORWARD_EDGE, word_end, unichar_id, &edge_ptr,
158                             &edge_index);
159        if (found && debug_level_ > 1) {
160          tprintf("exploring edge " REFFORMAT " in node " REFFORMAT "\n", edge_index, last_node);
161        }
162        if (!found) {
163          still_finding_chars = false;
164        } else if (next_node_from_edge_rec(*edge_ptr) == 0) {
165          word_end = true;
166          still_finding_chars = false;
167          remove_edge(last_node, 0, word_end, unichar_id);
168        } else {
169          if (marker_flag) {
170            set_marker_flag_in_edge_rec(edge_ptr);
171          }
172          last_node = next_node_from_edge_rec(*edge_ptr);
173        }
174      }
175      if (!still_finding_chars) {
176        the_next_node = new_dawg_node();
177        if (debug_level_ > 1) {
178          tprintf("adding node " REFFORMAT "\n", the_next_node);
179        }
180        if (the_next_node == 0) {
181          add_failed = true;
182          break;
183        }
184        if (!add_new_edge(last_node, the_next_node, marker_flag, word_end, unichar_id)) {
185          add_failed = true;
186          break;
187        }
188        word_end = false;
189        last_node = the_next_node;
190      }
191    }
192    the_next_node = 0;
<span onclick='openModal()' class='match'>193    unichar_id = word.unichar_id(i);
194    marker_flag = (repetitions != nullptr) ? (*repetitions)[i] : false;
195    if (debug_level_ > 1) {
196      tprintf("Adding letter %d\n", unichar_id);
197    }
198    if (still_finding_chars &&
</span>199        edge_char_of(last_node, NO_EDGE, FORWARD_EDGE, false, unichar_id, &edge_ptr, &edge_index)) {
200      add_word_ending(edge_ptr, next_node_from_edge_rec(*edge_ptr), marker_flag, unichar_id);
201    } else {
202      if (!add_failed && !add_new_edge(last_node, the_next_node, marker_flag, true, unichar_id)) {
203        add_failed = true;
204      }
205    }
206    if (add_failed) {
207      tprintf("Re-initializing document dictionary...\n");
208      clear();
209      return false;
210    } else {
211      return true;
212    }
213  }
214  NODE_REF Trie::new_dawg_node() {
215    auto *node = new TRIE_NODE_RECORD();
216    nodes_.push_back(node);
217    return nodes_.size() - 1;
218  }
219  bool Trie::read_and_add_word_list(const char *filename, const UNICHARSET &unicharset,
220                                    Trie::RTLReversePolicy reverse_policy) {
221    std::vector<std::string> word_list;
222    if (!read_word_list(filename, &word_list)) {
223      return false;
224    }
225    std::sort(word_list.begin(), word_list.end(),
226              [](auto &s1, auto &s2) { return s1.size() > s2.size(); });
227    return add_word_list(word_list, unicharset, reverse_policy);
228  }
229  bool Trie::read_word_list(const char *filename, std::vector<std::string> *words) {
230    FILE *word_file;
231    char line_str[CHARS_PER_LINE];
232    int word_count = 0;
233    word_file = fopen(filename, "rb");
234    if (word_file == nullptr) {
235      return false;
236    }
237    while (fgets(line_str, sizeof(line_str), word_file) != nullptr) {
238      chomp_string(line_str); 
239      std::string word_str(line_str);
240      ++word_count;
241      if (debug_level_ && word_count % 10000 == 0) {
242        tprintf("Read %d words so far\n", word_count);
243      }
244      words->push_back(word_str);
245    }
246    if (debug_level_) {
247      tprintf("Read %d words total.\n", word_count);
248    }
249    fclose(word_file);
250    return true;
251  }
252  bool Trie::add_word_list(const std::vector<std::string> &words, const UNICHARSET &unicharset,
253                           Trie::RTLReversePolicy reverse_policy) {
254    for (const auto &i : words) {
255      WERD_CHOICE word(i.c_str(), unicharset);
256      if (word.empty() || word.contains_unichar_id(INVALID_UNICHAR_ID)) {
257        continue;
258      }
259      if ((reverse_policy == RRP_REVERSE_IF_HAS_RTL && word.has_rtl_unichar_id()) ||
260          reverse_policy == RRP_FORCE_REVERSE) {
261        word.reverse_and_mirror_unichar_ids();
262      }
263      if (!word_in_dawg(word)) {
264        add_word_to_dawg(word);
265        if (!word_in_dawg(word)) {
266          tprintf("Error: word '%s' not in DAWG after adding it\n", i.c_str());
267          return false;
268        }
269      }
270    }
271    return true;
272  }
273  void Trie::initialize_patterns(UNICHARSET *unicharset) {
274    unicharset->unichar_insert(kAlphaPatternUnicode);
275    alpha_pattern_ = unicharset->unichar_to_id(kAlphaPatternUnicode);
276    unicharset->unichar_insert(kDigitPatternUnicode);
277    digit_pattern_ = unicharset->unichar_to_id(kDigitPatternUnicode);
278    unicharset->unichar_insert(kAlphanumPatternUnicode);
279    alphanum_pattern_ = unicharset->unichar_to_id(kAlphanumPatternUnicode);
280    unicharset->unichar_insert(kPuncPatternUnicode);
281    punc_pattern_ = unicharset->unichar_to_id(kPuncPatternUnicode);
282    unicharset->unichar_insert(kLowerPatternUnicode);
283    lower_pattern_ = unicharset->unichar_to_id(kLowerPatternUnicode);
284    unicharset->unichar_insert(kUpperPatternUnicode);
285    upper_pattern_ = unicharset->unichar_to_id(kUpperPatternUnicode);
286    initialized_patterns_ = true;
287    unicharset_size_ = unicharset->size();
288  }
289  void Trie::unichar_id_to_patterns(UNICHAR_ID unichar_id, const UNICHARSET &unicharset,
290                                    std::vector<UNICHAR_ID> *vec) const {
291    bool is_alpha = unicharset.get_isalpha(unichar_id);
292    if (is_alpha) {
293      vec->push_back(alpha_pattern_);
294      vec->push_back(alphanum_pattern_);
295      if (unicharset.get_islower(unichar_id)) {
296        vec->push_back(lower_pattern_);
297      } else if (unicharset.get_isupper(unichar_id)) {
298        vec->push_back(upper_pattern_);
299      }
300    }
301    if (unicharset.get_isdigit(unichar_id)) {
302      vec->push_back(digit_pattern_);
303      if (!is_alpha) {
304        vec->push_back(alphanum_pattern_);
305      }
306    }
307    if (unicharset.get_ispunctuation(unichar_id)) {
308      vec->push_back(punc_pattern_);
309    }
310  }
311  UNICHAR_ID Trie::character_class_to_pattern(char ch) {
312    if (ch == 'c') {
313      return alpha_pattern_;
314    } else if (ch == 'd') {
315      return digit_pattern_;
316    } else if (ch == 'n') {
317      return alphanum_pattern_;
318    } else if (ch == 'p') {
319      return punc_pattern_;
320    } else if (ch == 'a') {
321      return lower_pattern_;
322    } else if (ch == 'A') {
323      return upper_pattern_;
324    } else {
325      return INVALID_UNICHAR_ID;
326    }
327  }
328  bool Trie::read_pattern_list(const char *filename, const UNICHARSET &unicharset) {
329    if (!initialized_patterns_) {
330      tprintf("please call initialize_patterns() before read_pattern_list()\n");
331      return false;
332    }
333    FILE *pattern_file = fopen(filename, "rb");
334    if (pattern_file == nullptr) {
335      tprintf("Error opening pattern file %s\n", filename);
336      return false;
337    }
338    int pattern_count = 0;
339    char string[CHARS_PER_LINE];
340    while (fgets(string, CHARS_PER_LINE, pattern_file) != nullptr) {
341      chomp_string(string); 
342      WERD_CHOICE word(&unicharset);
343      std::vector<bool> repetitions_vec;
344      const char *str_ptr = string;
345      int step = unicharset.step(str_ptr);
346      bool failed = false;
347      while (step > 0) {
348        UNICHAR_ID curr_unichar_id = INVALID_UNICHAR_ID;
349        if (step == 1 && *str_ptr == '\\') {
350          ++str_ptr;
351          if (*str_ptr == '\\') { 
352            curr_unichar_id = unicharset.unichar_to_id(str_ptr, step);
353          } else {
354  #if 0 
355            if (word.length() < kSaneNumConcreteChars) {
356              tprintf(
357                  "Please provide at least %d concrete characters at the"
358                  " beginning of the pattern\n",
359                  kSaneNumConcreteChars);
360              failed = true;
361              break;
362            }
363  #endif
364            curr_unichar_id = character_class_to_pattern(*str_ptr);
365          }
366        } else {
367          curr_unichar_id = unicharset.unichar_to_id(str_ptr, step);
368        }
369        if (curr_unichar_id == INVALID_UNICHAR_ID) {
370          failed = true;
371          break; 
372        }
373        word.append_unichar_id(curr_unichar_id, 1, 0.0, 0.0);
374        repetitions_vec.push_back(false);
375        str_ptr += step;
376        step = unicharset.step(str_ptr);
377        if (step == 1 && *str_ptr == '\\' && *(str_ptr + 1) == '*') {
378          repetitions_vec[repetitions_vec.size() - 1] = true;
379          str_ptr += 2;
380          step = unicharset.step(str_ptr);
381        }
382      }
383      if (failed) {
384        tprintf("Invalid user pattern %s\n", string);
385        continue;
386      }
387      if (debug_level_ > 2) {
388        tprintf("Inserting expanded user pattern %s\n", word.debug_string().c_str());
389      }
390      if (!this->word_in_dawg(word)) {
391        this->add_word_to_dawg(word, &repetitions_vec);
392        if (!this->word_in_dawg(word)) {
393          tprintf("Error: failed to insert pattern '%s'\n", string);
394        }
395      }
396      ++pattern_count;
397    }
398    if (debug_level_) {
399      tprintf("Read %d valid patterns from %s\n", pattern_count, filename);
400    }
401    fclose(pattern_file);
402    return true;
403  }
404  void Trie::remove_edge_linkage(NODE_REF node1, NODE_REF node2, int direction, bool word_end,
405                                 UNICHAR_ID unichar_id) {
406    EDGE_RECORD *edge_ptr = nullptr;
407    EDGE_INDEX edge_index = 0;
408    ASSERT_HOST(edge_char_of(node1, node2, direction, word_end, unichar_id, &edge_ptr, &edge_index));
409    if (debug_level_ > 1) {
410      tprintf("removed edge in nodes_[" REFFORMAT "]: ", node1);
411      print_edge_rec(*edge_ptr);
412      tprintf("\n");
413    }
414    if (direction == FORWARD_EDGE) {
415      nodes_[node1]->forward_edges.erase(nodes_[node1]->forward_edges.begin() + edge_index);
416    } else if (node1 == 0) {
417      KillEdge(&nodes_[node1]->backward_edges[edge_index]);
418      root_back_freelist_.push_back(edge_index);
419    } else {
420      nodes_[node1]->backward_edges.erase(nodes_[node1]->backward_edges.begin() + edge_index);
421    }
422    --num_edges_;
423  }
424  SquishedDawg *Trie::trie_to_dawg() {
425    root_back_freelist_.clear(); 
426    if (debug_level_ > 2) {
427      print_all("Before reduction:", MAX_NODE_EDGES_DISPLAY);
428    }
429    std::vector<bool> reduced_nodes(nodes_.size());
430    this->reduce_node_input(0, reduced_nodes);
431    if (debug_level_ > 2) {
432      print_all("After reduction:", MAX_NODE_EDGES_DISPLAY);
433    }
434    std::vector<NODE_REF> node_ref_map(nodes_.size() + 1);
435    unsigned i;
436    for (i = 0; i < nodes_.size(); ++i) {
437      node_ref_map[i + 1] = node_ref_map[i] + nodes_[i]->forward_edges.size();
438    }
439    int num_forward_edges = node_ref_map[i];
440    auto edge_array = new EDGE_RECORD[num_forward_edges];
441    EDGE_ARRAY edge_array_ptr = edge_array;
442    for (i = 0; i < nodes_.size(); ++i) {
443      TRIE_NODE_RECORD *node_ptr = nodes_[i];
444      int end = node_ptr->forward_edges.size();
445      for (int j = 0; j < end; ++j) {
446        EDGE_RECORD &edge_rec = node_ptr->forward_edges[j];
447        NODE_REF node_ref = next_node_from_edge_rec(edge_rec);
448        ASSERT_HOST(static_cast<size_t>(node_ref) < nodes_.size());
449        UNICHAR_ID unichar_id = unichar_id_from_edge_rec(edge_rec);
450        link_edge(edge_array_ptr, node_ref_map[node_ref], false, FORWARD_EDGE,
451                  end_of_word_from_edge_rec(edge_rec), unichar_id);
452        if (j == end - 1) {
453          set_marker_flag_in_edge_rec(edge_array_ptr);
454        }
455        ++edge_array_ptr;
456      }
457    }
458    return new SquishedDawg(edge_array, num_forward_edges, type_, lang_, perm_, unicharset_size_,
459                            debug_level_);
460  }
461  bool Trie::eliminate_redundant_edges(NODE_REF node, const EDGE_RECORD &edge1,
462                                       const EDGE_RECORD &edge2) {
463    if (debug_level_ > 1) {
464      tprintf("\nCollapsing node %" PRIi64 ":\n", node);
465      print_node(node, MAX_NODE_EDGES_DISPLAY);
466      tprintf("Candidate edges: ");
467      print_edge_rec(edge1);
468      tprintf(", ");
469      print_edge_rec(edge2);
470      tprintf("\n\n");
471    }
472    NODE_REF next_node1 = next_node_from_edge_rec(edge1);
473    NODE_REF next_node2 = next_node_from_edge_rec(edge2);
474    TRIE_NODE_RECORD *next_node2_ptr = nodes_[next_node2];
475    EDGE_RECORD *edge_ptr = nullptr;
476    EDGE_INDEX edge_index;
477    for (unsigned i = 0; i < next_node2_ptr->backward_edges.size(); ++i) {
478      const EDGE_RECORD &bkw_edge = next_node2_ptr->backward_edges[i];
479      NODE_REF curr_next_node = next_node_from_edge_rec(bkw_edge);
480      UNICHAR_ID curr_unichar_id = unichar_id_from_edge_rec(bkw_edge);
481      int curr_word_end = end_of_word_from_edge_rec(bkw_edge);
482      bool marker_flag = marker_flag_from_edge_rec(bkw_edge);
483      add_edge_linkage(next_node1, curr_next_node, marker_flag, BACKWARD_EDGE, curr_word_end,
484                       curr_unichar_id);
485      ASSERT_HOST(edge_char_of(curr_next_node, next_node2, FORWARD_EDGE, curr_word_end,
486                               curr_unichar_id, &edge_ptr, &edge_index));
487      set_next_node_in_edge_rec(edge_ptr, next_node1);
488    }
489    int next_node2_num_edges =
490        (next_node2_ptr->forward_edges.size() + next_node2_ptr->backward_edges.size());
491    if (debug_level_ > 1) {
492      tprintf("removed %d edges from node " REFFORMAT "\n", next_node2_num_edges, next_node2);
493    }
494    next_node2_ptr->forward_edges.clear();
495    next_node2_ptr->backward_edges.clear();
496    num_edges_ -= next_node2_num_edges;
497    return true;
498  }
499  bool Trie::reduce_lettered_edges(EDGE_INDEX edge_index, UNICHAR_ID unichar_id, NODE_REF node,
500                                   EDGE_VECTOR *backward_edges, std::vector<bool> &reduced_nodes) {
501    if (debug_level_ > 1) {
502      tprintf("reduce_lettered_edges(edge=" REFFORMAT ")\n", edge_index);
503    }
504    bool did_something = false;
505    for (unsigned i = edge_index; i < backward_edges->size() - 1; ++i) {
506      UNICHAR_ID curr_unichar_id = INVALID_UNICHAR_ID;
507      while (i < backward_edges->size()) {
508        if (!DeadEdge((*backward_edges)[i])) {
509          curr_unichar_id = unichar_id_from_edge_rec((*backward_edges)[i]);
510          if (curr_unichar_id != unichar_id) {
511            return did_something;
512          }
513          if (can_be_eliminated((*backward_edges)[i])) {
514            break;
515          }
516        }
517        ++i;
518      }
519      if (i == backward_edges->size()) {
520        break;
521      }
522      const EDGE_RECORD &edge_rec = (*backward_edges)[i];
523      for (auto j = i + 1; j < backward_edges->size(); ++j) {
524        const EDGE_RECORD &next_edge_rec = (*backward_edges)[j];
525        if (DeadEdge(next_edge_rec)) {
526          continue;
527        }
528        UNICHAR_ID next_id = unichar_id_from_edge_rec(next_edge_rec);
529        if (next_id != unichar_id) {
530          break;
531        }
532        if (end_of_word_from_edge_rec(next_edge_rec) == end_of_word_from_edge_rec(edge_rec) &&
533            can_be_eliminated(next_edge_rec) &&
534            eliminate_redundant_edges(node, edge_rec, next_edge_rec)) {
535          reduced_nodes[next_node_from_edge_rec(edge_rec)] = false;
536          did_something = true;
537          KillEdge(&(*backward_edges)[j]);
538        }
539      }
540    }
541    return did_something;
542  }
543  void Trie::sort_edges(EDGE_VECTOR *edges) {
544    int num_edges = edges->size();
545    if (num_edges <= 1) {
546      return;
547    }
548    std::vector<KDPairInc<UNICHAR_ID, EDGE_RECORD>> sort_vec;
549    sort_vec.reserve(num_edges);
550    for (int i = 0; i < num_edges; ++i) {
551      sort_vec.emplace_back(unichar_id_from_edge_rec((*edges)[i]), (*edges)[i]);
552    }
553    std::sort(sort_vec.begin(), sort_vec.end());
554    for (int i = 0; i < num_edges; ++i) {
555      (*edges)[i] = sort_vec[i].data();
556    }
557  }
558  void Trie::reduce_node_input(NODE_REF node, std::vector<bool> &reduced_nodes) {
559    EDGE_VECTOR &backward_edges = nodes_[node]->backward_edges;
560    sort_edges(&backward_edges);
561    if (debug_level_ > 1) {
562      tprintf("reduce_node_input(node=" REFFORMAT ")\n", node);
563      print_node(node, MAX_NODE_EDGES_DISPLAY);
564    }
565    EDGE_INDEX edge_index = 0;
566    while (static_cast<size_t>(edge_index) < backward_edges.size()) {
567      if (DeadEdge(backward_edges[edge_index])) {
568        continue;
569      }
570      UNICHAR_ID unichar_id = unichar_id_from_edge_rec(backward_edges[edge_index]);
571      while (reduce_lettered_edges(edge_index, unichar_id, node, &backward_edges, reduced_nodes)) {
572        ;
573      }
574      while (static_cast<size_t>(++edge_index) < backward_edges.size()) {
575        UNICHAR_ID id = unichar_id_from_edge_rec(backward_edges[edge_index]);
576        if (!DeadEdge(backward_edges[edge_index]) && id != unichar_id) {
577          break;
578        }
579      }
580    }
581    reduced_nodes[node] = true; 
582    if (debug_level_ > 1) {
583      tprintf("Node " REFFORMAT " after reduction:\n", node);
584      print_node(node, MAX_NODE_EDGES_DISPLAY);
585    }
586    for (auto &backward_edge : backward_edges) {
587      if (DeadEdge(backward_edge)) {
588        continue;
589      }
590      NODE_REF next_node = next_node_from_edge_rec(backward_edge);
591      if (next_node != 0 && !reduced_nodes[next_node]) {
592        reduce_node_input(next_node, reduced_nodes);
593      }
594    }
595  }
596  void Trie::print_node(NODE_REF node, int max_num_edges) const {
597    if (node == NO_EDGE) {
598      return; 
599    }
600    TRIE_NODE_RECORD *node_ptr = nodes_[node];
601    int num_fwd = node_ptr->forward_edges.size();
602    int num_bkw = node_ptr->backward_edges.size();
603    EDGE_VECTOR *vec;
604    for (int dir = 0; dir < 2; ++dir) {
605      if (dir == 0) {
606        vec = &(node_ptr->forward_edges);
607        tprintf(REFFORMAT " (%d %d): ", node, num_fwd, num_bkw);
608      } else {
609        vec = &(node_ptr->backward_edges);
610        tprintf("\t");
611      }
612      int i;
613      for (i = 0; (dir == 0 ? i < num_fwd : i < num_bkw) && i < max_num_edges; ++i) {
614        if (DeadEdge((*vec)[i])) {
615          continue;
616        }
617        print_edge_rec((*vec)[i]);
618        tprintf(" ");
619      }
620      if (dir == 0 ? i < num_fwd : i < num_bkw) {
621        tprintf("...");
622      }
623      tprintf("\n");
624    }
625  }
626  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trie.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trie.cpp</div>
                </div>
                <div class="column column_space"><pre><code>193    unichar_id = word.unichar_id(i);
194    marker_flag = (repetitions != nullptr) ? (*repetitions)[i] : false;
195    if (debug_level_ > 1) {
196      tprintf("Adding letter %d\n", unichar_id);
197    }
198    if (still_finding_chars &&
</pre></code></div>
                <div class="column column_space"><pre><code>193    unichar_id = word.unichar_id(i);
194    marker_flag = (repetitions != nullptr) ? (*repetitions)[i] : false;
195    if (debug_level_ > 1) {
196      tprintf("Adding letter %d\n", unichar_id);
197    }
198    if (still_finding_chars &&
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    