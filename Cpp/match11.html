<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for check_symoro_par_import.cpp & check_urdf_import_export.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for check_symoro_par_import.cpp & check_urdf_import_export.cpp
      </h3>
      <h1 align="center">
        16.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>check_symoro_par_import.cpp (31.578947%)<TH>check_urdf_import_export.cpp (11.320755%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match11-0.html#0',2,'match11-1.html#0',3)" NAME="0">(45-50)<TD><A HREF="javascript:ZweiFrames('match11-0.html#0',2,'match11-1.html#0',3)" NAME="0">(54-59)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>check_symoro_par_import.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
* 
*  Copyright (c) 2013 Istituto Italiano di Tecnologia
*  All rights reserved.
* 
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
* 
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
* 
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

/* Author: Silvio Traversaro */

#include &quot;kdl_urdf/symoro_par/symoro_par_model.hpp&quot;
#include &quot;kdl_urdf/symoro_par/symoro_par_import.hpp&quot;


using namespace KDL;
<A NAME="0"></A>using namespace std;
using namespace symoro_par;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match11-1.html#0',3,'match11-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>void printLink(const SegmentMap::const_iterator&amp; link, const std::string&amp; prefix)
{
  cout &lt;&lt; prefix &lt;&lt; &quot;- Segment &quot; &lt;&lt; link-&gt;second.segment.getName() &lt;&lt; &quot; has &quot; &lt;&lt; link-&gt;second.children.size() &lt;&lt; &quot; children&quot; &lt;&lt; endl;
  for (unsigned int i=0; i&lt;link-&gt;second.children.size(); i++)
    printLink(link-&gt;second.children[i], prefix + &quot;  &quot;);
}</B></FONT>



int main(int argc, char** argv)
{
  if (argc &lt; 2){
    std::cerr &lt;&lt; &quot;Expect .par file to parse&quot; &lt;&lt; std::endl;
    return -1;
  }
  
  symoro_par_model mdl;
  
  if( !parModelFromFile(argv[1],mdl) ) {cerr &lt;&lt; &quot;Could not parse SyMoRo par robot model&quot; &lt;&lt; endl; return false;}
  
  std::cout &lt;&lt; &quot;Extracted par file&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; mdl.toString() &lt;&lt; std::endl;

  
  Tree my_tree;
  if (!symoro_par::treeFromFile(argv[1],my_tree)) 
  {cerr &lt;&lt; &quot;Could not generate robot model and extract kdl tree&quot; &lt;&lt; endl; return false;}

  // walk through tree
  cout &lt;&lt; &quot; ======================================&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot; Tree has &quot; &lt;&lt; my_tree.getNrOfSegments() &lt;&lt; &quot; link(s) and a root link&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot; ======================================&quot; &lt;&lt; endl;
  SegmentMap::const_iterator root = my_tree.getRootSegment();
  printLink(root, &quot;&quot;);
 
}


</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>check_urdf_import_export.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
* 
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
* 
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
* 
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
* 
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

/* Author: Silvio Traversaro */

#include &quot;kdl_format_io/urdf_import.hpp&quot;
#include &quot;kdl_format_io/urdf_export.hpp&quot;
#include &lt;kdl/tree.hpp&gt;
#include &lt;kdl_codyco/treeidsolver_recursive_newton_euler.hpp&gt;
#include &lt;urdf_model/model.h&gt;
#include &lt;urdf_parser/urdf_parser.h&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;kdl/jntarray.hpp&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;

using namespace KDL;
using namespace std;
<A NAME="0"></A>using namespace urdf;
using namespace KDL::CoDyCo;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11-0.html#0',2,'match11-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>void printLink(const SegmentMap::const_iterator&amp; link, const std::string&amp; prefix)
{
  cout &lt;&lt; prefix &lt;&lt; &quot;- Segment &quot; &lt;&lt; GetTreeElementSegment(link-&gt;second).getName() &lt;&lt; &quot; has &quot; &lt;&lt; GetTreeElementChildren(link-&gt;second).size() &lt;&lt; &quot; children&quot; &lt;&lt; endl;
  for (unsigned int i=0; i&lt;GetTreeElementChildren(link-&gt;second).size(); i++)
    printLink(GetTreeElementChildren(link-&gt;second)[i], prefix + &quot;  &quot;);
}</B></FONT>


double random_double()
{
    return ((double)rand()-RAND_MAX/2)/((double)RAND_MAX);
}

int main(int argc, char** argv)
{
    srand(time(NULL));
    
    Tree my_tree, my_tree_converted;
    if (!kdl_format_io::treeFromUrdfFile(argv[1],my_tree)) 
    {cerr &lt;&lt; &quot;Could not generate robot model and extract kdl tree&quot; &lt;&lt; endl; return EXIT_FAILURE;}

    // walk through tree
    cout &lt;&lt; &quot; ======================================&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot; Tree has &quot; &lt;&lt; my_tree.getNrOfSegments() &lt;&lt; &quot; link(s) and a root link&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot; ======================================&quot; &lt;&lt; endl;
    SegmentMap::const_iterator root = my_tree.getRootSegment();
    printLink(root, &quot;&quot;);
  
    //Export current tree
    std::string output_name = &quot;test_kdl_format_io.urdf&quot;;
    if( !kdl_format_io::treeToUrdfFile(output_name,my_tree) )
    {cerr &lt;&lt;&quot;Could not generate urdf from kdl tree&quot; &lt;&lt; endl; return EXIT_FAILURE;}
  
    //Re-importing it
    if( !kdl_format_io::treeFromUrdfFile(output_name,my_tree_converted) )
    {cerr &lt;&lt;&quot;Could not re-import back generated urdf file&quot; &lt;&lt; endl; return EXIT_FAILURE;}
  
    //Preliminary test
    if( my_tree.getNrOfJoints() != my_tree_converted.getNrOfJoints() ) { 
        cerr &lt;&lt; &quot;Error in conversion &quot; &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }
  
    //Running inverse dynamics for being sure all went well
    TreeIdSolver_RNE original_slv(my_tree), converted_slv(my_tree_converted);
  
      
    JntArray q,dq,ddq,torques,torques_converted;
    std::vector&lt;Wrench&gt; f,f_ext;
    Wrench base_force, base_force_converted;
    Twist base_vel, base_acc;       
    
    q = dq = ddq = torques = torques_converted = JntArray(my_tree.getNrOfJoints());
    f = f_ext = std::vector&lt;Wrench&gt;(my_tree.getNrOfSegments(),KDL::Wrench::Zero());
    
    for(int i=0; i &lt; my_tree.getNrOfJoints(); i++ )
    {
        q(i) = random_double();
        dq(i) = random_double();
        ddq(i) = random_double();
    }
    
    base_vel = Twist(Vector(random_double(),random_double(),random_double()),Vector(random_double(),random_double(),random_double()));
    base_acc = Twist(Vector(random_double(),random_double(),random_double()),Vector(random_double(),random_double(),random_double()));

    //Inserting the random input data in both solvers, while checking all went well
    if( original_slv.CartToJnt(q,dq,ddq,base_vel,base_acc,f_ext,torques,base_force) != 0 )
    { std::cerr &lt;&lt; &quot;Could not load solver for original tree&quot; &lt;&lt; std::endl; return EXIT_FAILURE; }
    if( converted_slv.CartToJnt(q,dq,ddq,base_vel,base_acc,f_ext,torques_converted,base_force_converted) != 0 )
    { std::cerr &lt;&lt; &quot;Could not load solver for converted tree&quot; &lt;&lt; std::endl; return EXIT_FAILURE; }

    double tol = 1e-4;
    for( int i=0; i &lt; my_tree.getNrOfJoints(); i++ )
    {
        std::cout &lt;&lt; fabs(torques(i)-torques_converted(i)) &lt;&lt; std::endl;
        if( fabs(torques(i)-torques_converted(i)) &gt; tol ) return -1;
    }
    
    for( int i=0; i &lt; 6; i++ ) {
        std::cout &lt;&lt; fabs(base_force(i)-base_force_converted(i)) &lt;&lt; std::endl;
        if( fabs(base_force(i)-base_force_converted(i)) &gt; tol ) return -1;
    }
    
    
    return EXIT_SUCCESS;
  
}


</PRE>
</div>
  </div>
</body>
</html>
