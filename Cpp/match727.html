<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for play.cpp &amp; signal9.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for play.cpp &amp; signal9.h
      </h3>
<h1 align="center">
        3.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>play.cpp (6.030151%)<th>signal9.h (2.1352313%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-67)<td><a href="#" name="0">(207-207)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>play.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "rosbag/player.h"
2 #include "boost/program_options.hpp"
3 namespace po = boost::program_options;
4 rosbag::PlayerOptions parseOptions(int argc, char** argv) {
5     rosbag::PlayerOptions opts;
6     po::options_description desc("Allowed options");
7     desc.add_options()
8       ("help,h", "produce help message")
9       ("prefix,p", po::value&lt;std::string&gt;()-&gt;default_value(""), "prefixes all output topics in replay")
10       ("quiet,q", "suppress console output")
11       ("immediate,i", "play back all messages without waiting")
12       ("pause", "start in paused mode")
13       ("queue", po::value&lt;int&gt;()-&gt;default_value(100), "use an outgoing queue of size SIZE")
14       ("clock", "publish the clock time")
15       ("hz", po::value&lt;float&gt;()-&gt;default_value(100.0f), "use a frequency of HZ when publishing clock time")
16       ("delay,d", po::value&lt;float&gt;()-&gt;default_value(0.2f), "sleep SEC seconds after every advertise call (to allow subscribers to connect)")
17       ("rate,r", po::value&lt;float&gt;()-&gt;default_value(1.0f), "multiply the publish rate by FACTOR")
18       ("start,s", po::value&lt;float&gt;()-&gt;default_value(0.0f), "start SEC seconds into the bag files")
19       ("duration,u", po::value&lt;float&gt;(), "play only SEC seconds from the bag files")
20       ("skip-empty", po::value&lt;float&gt;(), "skip regions in the bag with no messages for more than SEC seconds")
21 <a name="0"></a>      ("loop,l", "loop playback")
22       ("keep-alive,k", "keep alive past end of bag (useful for publishing latched topics)")
23       ("try-future-version", "still try to open a bag file, even if the version is not known to the player")
24 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      ("topics", po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), "topics to play back")
25       ("pause-topics", po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), "topics to pause playback on")
26       ("bags", po::value&lt; std::vector&lt;std::string&gt; &gt;(), "bag files to play back from")
27       ("wait-for-subscribers", "wait for at least one subscriber on each topic before publishing")
28       ("rate-control-topic", po::value&lt;std::string&gt;(), "watch the given topic, and if the last publish was more than &lt;rate-control-max-delay&gt; ago, wait until the topic publishes again to continue playback")
29       ("rate-control-max-delay", po::value&lt;float&gt;()-&gt;default_value(1.0f), "maximum time difference from &lt;rate-control-topic&gt; before pausing")</b></font>
30       ;
31     po::positional_options_description p;
32     p.add("bags", -1);
33     po::variables_map vm;
34     try 
35     {
36       po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
37     } catch (const boost::program_options::invalid_command_line_syntax&amp; e)
38     {
39       throw ros::Exception(e.what());
40     } catch (const boost::program_options::unknown_option&amp; e)
41     {
42       throw ros::Exception(e.what());
43     }
44     if (vm.count("help")) {
45       std::cout &lt;&lt; desc &lt;&lt; std::endl;
46       exit(0);
47     }
48     if (vm.count("prefix"))
49       opts.prefix = vm["prefix"].as&lt;std::string&gt;();
50     if (vm.count("quiet"))
51       opts.quiet = true;
52     if (vm.count("immediate"))
53       opts.at_once = true;
54     if (vm.count("pause"))
55       opts.start_paused = true;
56     if (vm.count("queue"))
57       opts.queue_size = vm["queue"].as&lt;int&gt;();
58     if (vm.count("hz"))
59       opts.bag_time_frequency = vm["hz"].as&lt;float&gt;();
60     if (vm.count("clock"))
61       opts.bag_time = true;
62     if (vm.count("delay"))
63       opts.advertise_sleep = ros::WallDuration(vm["delay"].as&lt;float&gt;());
64     if (vm.count("rate"))
65       opts.time_scale = vm["rate"].as&lt;float&gt;();
66     if (vm.count("start"))
67     {
68       opts.time = vm["start"].as&lt;float&gt;();
69       opts.has_time = true;
70     }
71     if (vm.count("duration"))
72     {
73       opts.duration = vm["duration"].as&lt;float&gt;();
74       opts.has_duration = true;
75     }
76     if (vm.count("skip-empty"))
77       opts.skip_empty = ros::Duration(vm["skip-empty"].as&lt;float&gt;());
78     if (vm.count("loop"))
79       opts.loop = true;
80     if (vm.count("keep-alive"))
81       opts.keep_alive = true;
82     if (vm.count("wait-for-subscribers"))
83       opts.wait_for_subscribers = true;
84     if (vm.count("topics"))
85     {
86       std::vector&lt;std::string&gt; topics = vm["topics"].as&lt; std::vector&lt;std::string&gt; &gt;();
87       for (std::vector&lt;std::string&gt;::iterator i = topics.begin();
88            i != topics.end();
89            i++)
90         opts.topics.push_back(*i);
91     }
92     if (vm.count("pause-topics"))
93     {
94       std::vector&lt;std::string&gt; pause_topics = vm["pause-topics"].as&lt; std::vector&lt;std::string&gt; &gt;();
95       for (std::vector&lt;std::string&gt;::iterator i = pause_topics.begin();
96            i != pause_topics.end();
97            i++)
98         opts.pause_topics.push_back(*i);
99     }
100     if (vm.count("rate-control-topic"))
101       opts.rate_control_topic = vm["rate-control-topic"].as&lt;std::string&gt;();
102     if (vm.count("rate-control-max-delay"))
103       opts.rate_control_max_delay = vm["rate-control-max-delay"].as&lt;float&gt;();
104     if (vm.count("bags"))
105     {
106       std::vector&lt;std::string&gt; bags = vm["bags"].as&lt; std::vector&lt;std::string&gt; &gt;();
107       for (std::vector&lt;std::string&gt;::iterator i = bags.begin();
108            i != bags.end();
109            i++)
110           opts.bags.push_back(*i);
111     } else {
112       if (vm.count("topics") || vm.count("pause-topics"))
113         throw ros::Exception("When using --topics or --pause-topics, --bags "
114           "should be specified to list bags.");
115       throw ros::Exception("You must specify at least one bag to play back.");
116     }
117     return opts;
118 }
119 int main(int argc, char** argv) {
120     ros::init(argc, argv, "play", ros::init_options::AnonymousName);
121     rosbag::PlayerOptions opts;
122     try {
123         opts = parseOptions(argc, argv);
124     }
125     catch (const ros::Exception&amp; ex) {
126         ROS_ERROR("Error reading options: %s", ex.what());
127         return 1;
128     }
129     rosbag::Player player(opts);
130     try {
131       player.publish();
132     }
133     catch (const std::runtime_error&amp; e) {
134       ROS_FATAL("%s", e.what());
135       return 1;
136     }
137     return 0;
138 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>signal9.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef MESSAGE_FILTERS_SIGNAL9_H
2 #define MESSAGE_FILTERS_SIGNAL9_H
3 #include &lt;boost/noncopyable.hpp&gt;
4 #include "connection.h"
5 #include "null_types.h"
6 #include &lt;ros/message_event.h&gt;
7 #include &lt;ros/parameter_adapter.h&gt;
8 #include &lt;boost/bind.hpp&gt;
9 #include &lt;boost/thread/mutex.hpp&gt;
10 namespace message_filters
11 {
12 using ros::ParameterAdapter;
13 template&lt;typename M0, typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8&gt;
14 class CallbackHelper9
15 {
16 public:
17   typedef ros::MessageEvent&lt;M0 const&gt; M0Event;
18   typedef ros::MessageEvent&lt;M1 const&gt; M1Event;
19   typedef ros::MessageEvent&lt;M2 const&gt; M2Event;
20   typedef ros::MessageEvent&lt;M3 const&gt; M3Event;
21   typedef ros::MessageEvent&lt;M4 const&gt; M4Event;
22   typedef ros::MessageEvent&lt;M5 const&gt; M5Event;
23   typedef ros::MessageEvent&lt;M6 const&gt; M6Event;
24   typedef ros::MessageEvent&lt;M7 const&gt; M7Event;
25   typedef ros::MessageEvent&lt;M8 const&gt; M8Event;
26   virtual ~CallbackHelper9() {}
27   virtual void call(bool nonconst_force_copy, const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3,
28                     const M4Event&amp; e4, const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8) = 0;
29   typedef boost::shared_ptr&lt;CallbackHelper9&gt; Ptr;
30 };
31 template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
32 class CallbackHelper9T :
33   public CallbackHelper9&lt;typename ParameterAdapter&lt;P0&gt;::Message,
34                          typename ParameterAdapter&lt;P1&gt;::Message,
35                          typename ParameterAdapter&lt;P2&gt;::Message,
36                          typename ParameterAdapter&lt;P3&gt;::Message,
37                          typename ParameterAdapter&lt;P4&gt;::Message,
38                          typename ParameterAdapter&lt;P5&gt;::Message,
39                          typename ParameterAdapter&lt;P6&gt;::Message,
40                          typename ParameterAdapter&lt;P7&gt;::Message,
41                          typename ParameterAdapter&lt;P8&gt;::Message&gt;
42 {
43 private:
44   typedef ParameterAdapter&lt;P0&gt; A0;
45   typedef ParameterAdapter&lt;P1&gt; A1;
46   typedef ParameterAdapter&lt;P2&gt; A2;
47   typedef ParameterAdapter&lt;P3&gt; A3;
48   typedef ParameterAdapter&lt;P4&gt; A4;
49   typedef ParameterAdapter&lt;P5&gt; A5;
50   typedef ParameterAdapter&lt;P6&gt; A6;
51   typedef ParameterAdapter&lt;P7&gt; A7;
52   typedef ParameterAdapter&lt;P8&gt; A8;
53   typedef typename A0::Event M0Event;
54   typedef typename A1::Event M1Event;
55   typedef typename A2::Event M2Event;
56   typedef typename A3::Event M3Event;
57   typedef typename A4::Event M4Event;
58   typedef typename A5::Event M5Event;
59   typedef typename A6::Event M6Event;
60   typedef typename A7::Event M7Event;
61   typedef typename A8::Event M8Event;
62 public:
63   typedef boost::function&lt;void(typename A0::Parameter, typename A1::Parameter, typename A2::Parameter,
64                                typename A3::Parameter, typename A4::Parameter, typename A5::Parameter,
65                                typename A6::Parameter, typename A7::Parameter, typename A8::Parameter)&gt; Callback;
66   CallbackHelper9T(const Callback&amp; cb)
67   : callback_(cb)
68   {
69   }
70   virtual void call(bool nonconst_force_copy, const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3,
71                     const M4Event&amp; e4, const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8)
72   {
73     M0Event my_e0(e0, nonconst_force_copy || e0.nonConstWillCopy());
74     M1Event my_e1(e1, nonconst_force_copy || e0.nonConstWillCopy());
75     M2Event my_e2(e2, nonconst_force_copy || e0.nonConstWillCopy());
76     M3Event my_e3(e3, nonconst_force_copy || e0.nonConstWillCopy());
77     M4Event my_e4(e4, nonconst_force_copy || e0.nonConstWillCopy());
78     M5Event my_e5(e5, nonconst_force_copy || e0.nonConstWillCopy());
79     M6Event my_e6(e6, nonconst_force_copy || e0.nonConstWillCopy());
80     M7Event my_e7(e7, nonconst_force_copy || e0.nonConstWillCopy());
81     M8Event my_e8(e8, nonconst_force_copy || e0.nonConstWillCopy());
82     callback_(A0::getParameter(e0),
83               A1::getParameter(e1),
84               A2::getParameter(e2),
85               A3::getParameter(e3),
86               A4::getParameter(e4),
87               A5::getParameter(e5),
88               A6::getParameter(e6),
89               A7::getParameter(e7),
90               A8::getParameter(e8));
91   }
92 private:
93   Callback callback_;
94 };
95 template&lt;typename M0, typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8&gt;
96 class Signal9
97 {
98   typedef boost::shared_ptr&lt;CallbackHelper9&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt; &gt; CallbackHelper9Ptr;
99   typedef std::vector&lt;CallbackHelper9Ptr&gt; V_CallbackHelper9;
100 public:
101   typedef ros::MessageEvent&lt;M0 const&gt; M0Event;
102   typedef ros::MessageEvent&lt;M1 const&gt; M1Event;
103   typedef ros::MessageEvent&lt;M2 const&gt; M2Event;
104   typedef ros::MessageEvent&lt;M3 const&gt; M3Event;
105   typedef ros::MessageEvent&lt;M4 const&gt; M4Event;
106   typedef ros::MessageEvent&lt;M5 const&gt; M5Event;
107   typedef ros::MessageEvent&lt;M6 const&gt; M6Event;
108   typedef ros::MessageEvent&lt;M7 const&gt; M7Event;
109   typedef ros::MessageEvent&lt;M8 const&gt; M8Event;
110   typedef boost::shared_ptr&lt;M0 const&gt; M0ConstPtr;
111   typedef boost::shared_ptr&lt;M1 const&gt; M1ConstPtr;
112   typedef boost::shared_ptr&lt;M2 const&gt; M2ConstPtr;
113   typedef boost::shared_ptr&lt;M3 const&gt; M3ConstPtr;
114   typedef boost::shared_ptr&lt;M4 const&gt; M4ConstPtr;
115   typedef boost::shared_ptr&lt;M5 const&gt; M5ConstPtr;
116   typedef boost::shared_ptr&lt;M6 const&gt; M6ConstPtr;
117   typedef boost::shared_ptr&lt;M7 const&gt; M7ConstPtr;
118   typedef boost::shared_ptr&lt;M8 const&gt; M8ConstPtr;
119   typedef const boost::shared_ptr&lt;NullType const&gt;&amp; NullP;
120   template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
121   Connection addCallback(const boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;&amp; callback)
122   {
123     CallbackHelper9T&lt;P0, P1, P2, P3, P4, P5, P6, P7, P8&gt;* helper = new CallbackHelper9T&lt;P0, P1, P2, P3, P4, P5, P6, P7, P8&gt;(callback);
124     boost::mutex::scoped_lock lock(mutex_);
125     callbacks_.push_back(CallbackHelper9Ptr(helper));
126     return Connection(boost::bind(&amp;Signal9::removeCallback, this, callbacks_.back()));
127   }
128   template&lt;typename P0, typename P1&gt;
129   Connection addCallback(void(*callback)(P0, P1))
130   {
131     return addCallback(boost::function&lt;void(P0, P1, NullP, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2)));
132   }
133   template&lt;typename P0, typename P1, typename P2&gt;
134   Connection addCallback(void(*callback)(P0, P1, P2))
135   {
136     return addCallback(boost::function&lt;void(P0, P1, P2, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3)));
137   }
138   template&lt;typename P0, typename P1, typename P2, typename P3&gt;
139   Connection addCallback(void(*callback)(P0, P1, P2, P3))
140   {
141     return addCallback(boost::function&lt;void(P0, P1, P2, P3, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4)));
142   }
143   template&lt;typename P0, typename P1, typename P2, typename P3, typename P4&gt;
144   Connection addCallback(void(*callback)(P0, P1, P2, P3, P4))
145   {
146     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5)));
147   }
148 <a name="0"></a>  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5&gt;
149   Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5))
150   {
151 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6)));</b></font>
152   }
153   template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6&gt;
154   Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6))
155   {
156     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, boost::placeholders::_7)));
157   }
158   template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7&gt;
159   Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6, P7))
160   {
161     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8)));
162   }
163   template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
164   Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6, P7, P8))
165   {
166     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8, boost::placeholders::_9)));
167   }
168   template&lt;typename T, typename P0, typename P1&gt;
169   Connection addCallback(void(T::*callback)(P0, P1), T* t)
170   {
171     return addCallback(boost::function&lt;void(P0, P1, NullP, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2)));
172   }
173   template&lt;typename T, typename P0, typename P1, typename P2&gt;
174   Connection addCallback(void(T::*callback)(P0, P1, P2), T* t)
175   {
176     return addCallback(boost::function&lt;void(P0, P1, P2, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3)));
177   }
178   template&lt;typename T, typename P0, typename P1, typename P2, typename P3&gt;
179   Connection addCallback(void(T::*callback)(P0, P1, P2, P3), T* t)
180   {
181     return addCallback(boost::function&lt;void(P0, P1, P2, P3, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4)));
182   }
183   template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4&gt;
184   Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4), T* t)
185   {
186     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5)));
187   }
188   template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5&gt;
189   Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5), T* t)
190   {
191     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6)));
192   }
193   template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6&gt;
194   Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6), T* t)
195   {
196     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, boost::placeholders::_7)));
197   }
198   template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7&gt;
199   Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6, P7), T* t)
200   {
201     return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8)));
202   }
203   template&lt;typename C&gt;
204   Connection addCallback( C&amp; callback)
205   {
206     return addCallback&lt;const M0ConstPtr&amp;,
207                      const M1ConstPtr&amp;,
208                      const M2ConstPtr&amp;,
209                      const M3ConstPtr&amp;,
210                      const M4ConstPtr&amp;,
211                      const M5ConstPtr&amp;,
212                      const M6ConstPtr&amp;,
213                      const M7ConstPtr&amp;,
214                      const M8ConstPtr&amp;&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8, boost::placeholders::_9));
215   }
216   void removeCallback(const CallbackHelper9Ptr&amp; helper)
217   {
218     boost::mutex::scoped_lock lock(mutex_);
219     typename V_CallbackHelper9::iterator it = std::find(callbacks_.begin(), callbacks_.end(), helper);
220     if (it != callbacks_.end())
221     {
222       callbacks_.erase(it);
223     }
224   }
225   void call(const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3, const M4Event&amp; e4,
226             const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8)
227   {
228     boost::mutex::scoped_lock lock(mutex_);
229     bool nonconst_force_copy = callbacks_.size() &gt; 1;
230     typename V_CallbackHelper9::iterator it = callbacks_.begin();
231     typename V_CallbackHelper9::iterator end = callbacks_.end();
232     for (; it != end; ++it)
233     {
234       const CallbackHelper9Ptr&amp; helper = *it;
235       helper-&gt;call(nonconst_force_copy, e0, e1, e2, e3, e4, e5, e6, e7, e8);
236     }
237   }
238 private:
239   boost::mutex mutex_;
240   V_CallbackHelper9 callbacks_;
241 };
242 } 
243 #endif 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
