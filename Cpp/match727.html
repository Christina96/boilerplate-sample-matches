<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for play.cpp &amp; signal9.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for play.cpp &amp; signal9.h
      </h3>
<h1 align="center">
        3.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>play.cpp (6.030151%)<th>signal9.h (2.1352313%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-67)<td><a href="#" name="0">(207-207)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>play.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Willow Garage, Inc. nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
********************************************************************/

#include "rosbag/player.h"
#include "boost/program_options.hpp"

namespace po = boost::program_options;

rosbag::PlayerOptions parseOptions(int argc, char** argv) {
    rosbag::PlayerOptions opts;

    po::options_description desc("Allowed options");

    desc.add_options()
      ("help,h", "produce help message")
      ("prefix,p", po::value&lt;std::string&gt;()-&gt;default_value(""), "prefixes all output topics in replay")
      ("quiet,q", "suppress console output")
      ("immediate,i", "play back all messages without waiting")
      ("pause", "start in paused mode")
      ("queue", po::value&lt;int&gt;()-&gt;default_value(100), "use an outgoing queue of size SIZE")
      ("clock", "publish the clock time")
      ("hz", po::value&lt;float&gt;()-&gt;default_value(100.0f), "use a frequency of HZ when publishing clock time")
      ("delay,d", po::value&lt;float&gt;()-&gt;default_value(0.2f), "sleep SEC seconds after every advertise call (to allow subscribers to connect)")
      ("rate,r", po::value&lt;float&gt;()-&gt;default_value(1.0f), "multiply the publish rate by FACTOR")
      ("start,s", po::value&lt;float&gt;()-&gt;default_value(0.0f), "start SEC seconds into the bag files")
      ("duration,u", po::value&lt;float&gt;(), "play only SEC seconds from the bag files")
      ("skip-empty", po::value&lt;float&gt;(), "skip regions in the bag with no messages for more than SEC seconds")
<a name="0"></a>      ("loop,l", "loop playback")
      ("keep-alive,k", "keep alive past end of bag (useful for publishing latched topics)")
      ("try-future-version", "still try to open a bag file, even if the version is not known to the player")
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      ("topics", po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), "topics to play back")
      ("pause-topics", po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), "topics to pause playback on")
      ("bags", po::value&lt; std::vector&lt;std::string&gt; &gt;(), "bag files to play back from")
      ("wait-for-subscribers", "wait for at least one subscriber on each topic before publishing")
      ("rate-control-topic", po::value&lt;std::string&gt;(), "watch the given topic, and if the last publish was more than &lt;rate-control-max-delay&gt; ago, wait until the topic publishes again to continue playback")
      ("rate-control-max-delay", po::value&lt;float&gt;()-&gt;default_value(1.0f), "maximum time difference from &lt;rate-control-topic&gt; before pausing")</b></font>
      ;

    po::positional_options_description p;
    p.add("bags", -1);
    
    po::variables_map vm;
    
    try 
    {
      po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
    } catch (const boost::program_options::invalid_command_line_syntax&amp; e)
    {
      throw ros::Exception(e.what());
    } catch (const boost::program_options::unknown_option&amp; e)
    {
      throw ros::Exception(e.what());
    }

    if (vm.count("help")) {
      std::cout &lt;&lt; desc &lt;&lt; std::endl;
      exit(0);
    }

    if (vm.count("prefix"))
      opts.prefix = vm["prefix"].as&lt;std::string&gt;();
    if (vm.count("quiet"))
      opts.quiet = true;
    if (vm.count("immediate"))
      opts.at_once = true;
    if (vm.count("pause"))
      opts.start_paused = true;
    if (vm.count("queue"))
      opts.queue_size = vm["queue"].as&lt;int&gt;();
    if (vm.count("hz"))
      opts.bag_time_frequency = vm["hz"].as&lt;float&gt;();
    if (vm.count("clock"))
      opts.bag_time = true;
    if (vm.count("delay"))
      opts.advertise_sleep = ros::WallDuration(vm["delay"].as&lt;float&gt;());
    if (vm.count("rate"))
      opts.time_scale = vm["rate"].as&lt;float&gt;();
    if (vm.count("start"))
    {
      opts.time = vm["start"].as&lt;float&gt;();
      opts.has_time = true;
    }
    if (vm.count("duration"))
    {
      opts.duration = vm["duration"].as&lt;float&gt;();
      opts.has_duration = true;
    }
    if (vm.count("skip-empty"))
      opts.skip_empty = ros::Duration(vm["skip-empty"].as&lt;float&gt;());
    if (vm.count("loop"))
      opts.loop = true;
    if (vm.count("keep-alive"))
      opts.keep_alive = true;
    if (vm.count("wait-for-subscribers"))
      opts.wait_for_subscribers = true;

    if (vm.count("topics"))
    {
      std::vector&lt;std::string&gt; topics = vm["topics"].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = topics.begin();
           i != topics.end();
           i++)
        opts.topics.push_back(*i);
    }

    if (vm.count("pause-topics"))
    {
      std::vector&lt;std::string&gt; pause_topics = vm["pause-topics"].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = pause_topics.begin();
           i != pause_topics.end();
           i++)
        opts.pause_topics.push_back(*i);
    }

    if (vm.count("rate-control-topic"))
      opts.rate_control_topic = vm["rate-control-topic"].as&lt;std::string&gt;();

    if (vm.count("rate-control-max-delay"))
      opts.rate_control_max_delay = vm["rate-control-max-delay"].as&lt;float&gt;();

    if (vm.count("bags"))
    {
      std::vector&lt;std::string&gt; bags = vm["bags"].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = bags.begin();
           i != bags.end();
           i++)
          opts.bags.push_back(*i);
    } else {
      if (vm.count("topics") || vm.count("pause-topics"))
        throw ros::Exception("When using --topics or --pause-topics, --bags "
          "should be specified to list bags.");
      throw ros::Exception("You must specify at least one bag to play back.");
    }
            
    return opts;
}

int main(int argc, char** argv) {
    ros::init(argc, argv, "play", ros::init_options::AnonymousName);

    // Parse the command-line options
    rosbag::PlayerOptions opts;
    try {
        opts = parseOptions(argc, argv);
    }
    catch (const ros::Exception&amp; ex) {
        ROS_ERROR("Error reading options: %s", ex.what());
        return 1;
    }

    rosbag::Player player(opts);

    try {
      player.publish();
    }
    catch (const std::runtime_error&amp; e) {
      ROS_FATAL("%s", e.what());
      return 1;
    }
    
    return 0;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>signal9.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2010, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

#ifndef MESSAGE_FILTERS_SIGNAL9_H
#define MESSAGE_FILTERS_SIGNAL9_H

#include &lt;boost/noncopyable.hpp&gt;

#include "connection.h"
#include "null_types.h"
#include &lt;ros/message_event.h&gt;
#include &lt;ros/parameter_adapter.h&gt;

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/thread/mutex.hpp&gt;

namespace message_filters
{
using ros::ParameterAdapter;

template&lt;typename M0, typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8&gt;
class CallbackHelper9
{
public:
  typedef ros::MessageEvent&lt;M0 const&gt; M0Event;
  typedef ros::MessageEvent&lt;M1 const&gt; M1Event;
  typedef ros::MessageEvent&lt;M2 const&gt; M2Event;
  typedef ros::MessageEvent&lt;M3 const&gt; M3Event;
  typedef ros::MessageEvent&lt;M4 const&gt; M4Event;
  typedef ros::MessageEvent&lt;M5 const&gt; M5Event;
  typedef ros::MessageEvent&lt;M6 const&gt; M6Event;
  typedef ros::MessageEvent&lt;M7 const&gt; M7Event;
  typedef ros::MessageEvent&lt;M8 const&gt; M8Event;

  virtual ~CallbackHelper9() {}

  virtual void call(bool nonconst_force_copy, const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3,
                    const M4Event&amp; e4, const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8) = 0;

  typedef boost::shared_ptr&lt;CallbackHelper9&gt; Ptr;
};

template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
class CallbackHelper9T :
  public CallbackHelper9&lt;typename ParameterAdapter&lt;P0&gt;::Message,
                         typename ParameterAdapter&lt;P1&gt;::Message,
                         typename ParameterAdapter&lt;P2&gt;::Message,
                         typename ParameterAdapter&lt;P3&gt;::Message,
                         typename ParameterAdapter&lt;P4&gt;::Message,
                         typename ParameterAdapter&lt;P5&gt;::Message,
                         typename ParameterAdapter&lt;P6&gt;::Message,
                         typename ParameterAdapter&lt;P7&gt;::Message,
                         typename ParameterAdapter&lt;P8&gt;::Message&gt;
{
private:
  typedef ParameterAdapter&lt;P0&gt; A0;
  typedef ParameterAdapter&lt;P1&gt; A1;
  typedef ParameterAdapter&lt;P2&gt; A2;
  typedef ParameterAdapter&lt;P3&gt; A3;
  typedef ParameterAdapter&lt;P4&gt; A4;
  typedef ParameterAdapter&lt;P5&gt; A5;
  typedef ParameterAdapter&lt;P6&gt; A6;
  typedef ParameterAdapter&lt;P7&gt; A7;
  typedef ParameterAdapter&lt;P8&gt; A8;
  typedef typename A0::Event M0Event;
  typedef typename A1::Event M1Event;
  typedef typename A2::Event M2Event;
  typedef typename A3::Event M3Event;
  typedef typename A4::Event M4Event;
  typedef typename A5::Event M5Event;
  typedef typename A6::Event M6Event;
  typedef typename A7::Event M7Event;
  typedef typename A8::Event M8Event;

public:
  typedef boost::function&lt;void(typename A0::Parameter, typename A1::Parameter, typename A2::Parameter,
                               typename A3::Parameter, typename A4::Parameter, typename A5::Parameter,
                               typename A6::Parameter, typename A7::Parameter, typename A8::Parameter)&gt; Callback;

  CallbackHelper9T(const Callback&amp; cb)
  : callback_(cb)
  {
  }

  virtual void call(bool nonconst_force_copy, const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3,
                    const M4Event&amp; e4, const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8)
  {
    M0Event my_e0(e0, nonconst_force_copy || e0.nonConstWillCopy());
    M1Event my_e1(e1, nonconst_force_copy || e0.nonConstWillCopy());
    M2Event my_e2(e2, nonconst_force_copy || e0.nonConstWillCopy());
    M3Event my_e3(e3, nonconst_force_copy || e0.nonConstWillCopy());
    M4Event my_e4(e4, nonconst_force_copy || e0.nonConstWillCopy());
    M5Event my_e5(e5, nonconst_force_copy || e0.nonConstWillCopy());
    M6Event my_e6(e6, nonconst_force_copy || e0.nonConstWillCopy());
    M7Event my_e7(e7, nonconst_force_copy || e0.nonConstWillCopy());
    M8Event my_e8(e8, nonconst_force_copy || e0.nonConstWillCopy());
    callback_(A0::getParameter(e0),
              A1::getParameter(e1),
              A2::getParameter(e2),
              A3::getParameter(e3),
              A4::getParameter(e4),
              A5::getParameter(e5),
              A6::getParameter(e6),
              A7::getParameter(e7),
              A8::getParameter(e8));
  }

private:
  Callback callback_;
};

template&lt;typename M0, typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8&gt;
class Signal9
{
  typedef boost::shared_ptr&lt;CallbackHelper9&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt; &gt; CallbackHelper9Ptr;
  typedef std::vector&lt;CallbackHelper9Ptr&gt; V_CallbackHelper9;

public:
  typedef ros::MessageEvent&lt;M0 const&gt; M0Event;
  typedef ros::MessageEvent&lt;M1 const&gt; M1Event;
  typedef ros::MessageEvent&lt;M2 const&gt; M2Event;
  typedef ros::MessageEvent&lt;M3 const&gt; M3Event;
  typedef ros::MessageEvent&lt;M4 const&gt; M4Event;
  typedef ros::MessageEvent&lt;M5 const&gt; M5Event;
  typedef ros::MessageEvent&lt;M6 const&gt; M6Event;
  typedef ros::MessageEvent&lt;M7 const&gt; M7Event;
  typedef ros::MessageEvent&lt;M8 const&gt; M8Event;
  typedef boost::shared_ptr&lt;M0 const&gt; M0ConstPtr;
  typedef boost::shared_ptr&lt;M1 const&gt; M1ConstPtr;
  typedef boost::shared_ptr&lt;M2 const&gt; M2ConstPtr;
  typedef boost::shared_ptr&lt;M3 const&gt; M3ConstPtr;
  typedef boost::shared_ptr&lt;M4 const&gt; M4ConstPtr;
  typedef boost::shared_ptr&lt;M5 const&gt; M5ConstPtr;
  typedef boost::shared_ptr&lt;M6 const&gt; M6ConstPtr;
  typedef boost::shared_ptr&lt;M7 const&gt; M7ConstPtr;
  typedef boost::shared_ptr&lt;M8 const&gt; M8ConstPtr;
  typedef const boost::shared_ptr&lt;NullType const&gt;&amp; NullP;

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
  Connection addCallback(const boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;&amp; callback)
  {
    CallbackHelper9T&lt;P0, P1, P2, P3, P4, P5, P6, P7, P8&gt;* helper = new CallbackHelper9T&lt;P0, P1, P2, P3, P4, P5, P6, P7, P8&gt;(callback);

    boost::mutex::scoped_lock lock(mutex_);
    callbacks_.push_back(CallbackHelper9Ptr(helper));
    return Connection(boost::bind(&amp;Signal9::removeCallback, this, callbacks_.back()));
  }

  template&lt;typename P0, typename P1&gt;
  Connection addCallback(void(*callback)(P0, P1))
  {
    return addCallback(boost::function&lt;void(P0, P1, NullP, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2)));
  }

  template&lt;typename P0, typename P1, typename P2&gt;
  Connection addCallback(void(*callback)(P0, P1, P2))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5)));
  }

<a name="0"></a>  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5))
  {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6)));</b></font>
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, boost::placeholders::_7)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6, P7))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6, P7, P8))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8, boost::placeholders::_9)));
  }

  template&lt;typename T, typename P0, typename P1&gt;
  Connection addCallback(void(T::*callback)(P0, P1), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, NullP, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, boost::placeholders::_7)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6, P7), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8)));
  }

  template&lt;typename C&gt;
  Connection addCallback( C&amp; callback)
  {
    return addCallback&lt;const M0ConstPtr&amp;,
                     const M1ConstPtr&amp;,
                     const M2ConstPtr&amp;,
                     const M3ConstPtr&amp;,
                     const M4ConstPtr&amp;,
                     const M5ConstPtr&amp;,
                     const M6ConstPtr&amp;,
                     const M7ConstPtr&amp;,
                     const M8ConstPtr&amp;&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8, boost::placeholders::_9));
  }

  void removeCallback(const CallbackHelper9Ptr&amp; helper)
  {
    boost::mutex::scoped_lock lock(mutex_);
    typename V_CallbackHelper9::iterator it = std::find(callbacks_.begin(), callbacks_.end(), helper);
    if (it != callbacks_.end())
    {
      callbacks_.erase(it);
    }
  }

  void call(const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3, const M4Event&amp; e4,
            const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8)
  {
    boost::mutex::scoped_lock lock(mutex_);
    bool nonconst_force_copy = callbacks_.size() &gt; 1;
    typename V_CallbackHelper9::iterator it = callbacks_.begin();
    typename V_CallbackHelper9::iterator end = callbacks_.end();
    for (; it != end; ++it)
    {
      const CallbackHelper9Ptr&amp; helper = *it;
      helper-&gt;call(nonconst_force_copy, e0, e1, e2, e3, e4, e5, e6, e7, e8);
    }
  }

private:
  boost::mutex mutex_;
  V_CallbackHelper9 callbacks_;
};

} // message_filters

#endif // MESSAGE_FILTERS_SIGNAL9_H


</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
