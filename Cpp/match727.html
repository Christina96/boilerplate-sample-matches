<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for play.cpp & signal9.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for play.cpp & signal9.h
      </h3>
      <h1 align="center">
        3.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>play.cpp (6.030151%)<TH>signal9.h (2.1352313%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match727-0.html#0',2,'match727-1.html#0',3)" NAME="0">(62-67)<TD><A HREF="javascript:ZweiFrames('match727-0.html#0',2,'match727-1.html#0',3)" NAME="0">(207-207)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>play.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Willow Garage, Inc. nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
********************************************************************/

#include &quot;rosbag/player.h&quot;
#include &quot;boost/program_options.hpp&quot;

namespace po = boost::program_options;

rosbag::PlayerOptions parseOptions(int argc, char** argv) {
    rosbag::PlayerOptions opts;

    po::options_description desc(&quot;Allowed options&quot;);

    desc.add_options()
      (&quot;help,h&quot;, &quot;produce help message&quot;)
      (&quot;prefix,p&quot;, po::value&lt;std::string&gt;()-&gt;default_value(&quot;&quot;), &quot;prefixes all output topics in replay&quot;)
      (&quot;quiet,q&quot;, &quot;suppress console output&quot;)
      (&quot;immediate,i&quot;, &quot;play back all messages without waiting&quot;)
      (&quot;pause&quot;, &quot;start in paused mode&quot;)
      (&quot;queue&quot;, po::value&lt;int&gt;()-&gt;default_value(100), &quot;use an outgoing queue of size SIZE&quot;)
      (&quot;clock&quot;, &quot;publish the clock time&quot;)
      (&quot;hz&quot;, po::value&lt;float&gt;()-&gt;default_value(100.0f), &quot;use a frequency of HZ when publishing clock time&quot;)
      (&quot;delay,d&quot;, po::value&lt;float&gt;()-&gt;default_value(0.2f), &quot;sleep SEC seconds after every advertise call (to allow subscribers to connect)&quot;)
      (&quot;rate,r&quot;, po::value&lt;float&gt;()-&gt;default_value(1.0f), &quot;multiply the publish rate by FACTOR&quot;)
      (&quot;start,s&quot;, po::value&lt;float&gt;()-&gt;default_value(0.0f), &quot;start SEC seconds into the bag files&quot;)
      (&quot;duration,u&quot;, po::value&lt;float&gt;(), &quot;play only SEC seconds from the bag files&quot;)
      (&quot;skip-empty&quot;, po::value&lt;float&gt;(), &quot;skip regions in the bag with no messages for more than SEC seconds&quot;)
<A NAME="0"></A>      (&quot;loop,l&quot;, &quot;loop playback&quot;)
      (&quot;keep-alive,k&quot;, &quot;keep alive past end of bag (useful for publishing latched topics)&quot;)
      (&quot;try-future-version&quot;, &quot;still try to open a bag file, even if the version is not known to the player&quot;)
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match727-1.html#0',3,'match727-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      (&quot;topics&quot;, po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), &quot;topics to play back&quot;)
      (&quot;pause-topics&quot;, po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), &quot;topics to pause playback on&quot;)
      (&quot;bags&quot;, po::value&lt; std::vector&lt;std::string&gt; &gt;(), &quot;bag files to play back from&quot;)
      (&quot;wait-for-subscribers&quot;, &quot;wait for at least one subscriber on each topic before publishing&quot;)
      (&quot;rate-control-topic&quot;, po::value&lt;std::string&gt;(), &quot;watch the given topic, and if the last publish was more than &lt;rate-control-max-delay&gt; ago, wait until the topic publishes again to continue playback&quot;)
      (&quot;rate-control-max-delay&quot;, po::value&lt;float&gt;()-&gt;default_value(1.0f), &quot;maximum time difference from &lt;rate-control-topic&gt; before pausing&quot;)</B></FONT>
      ;

    po::positional_options_description p;
    p.add(&quot;bags&quot;, -1);
    
    po::variables_map vm;
    
    try 
    {
      po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
    } catch (const boost::program_options::invalid_command_line_syntax&amp; e)
    {
      throw ros::Exception(e.what());
    } catch (const boost::program_options::unknown_option&amp; e)
    {
      throw ros::Exception(e.what());
    }

    if (vm.count(&quot;help&quot;)) {
      std::cout &lt;&lt; desc &lt;&lt; std::endl;
      exit(0);
    }

    if (vm.count(&quot;prefix&quot;))
      opts.prefix = vm[&quot;prefix&quot;].as&lt;std::string&gt;();
    if (vm.count(&quot;quiet&quot;))
      opts.quiet = true;
    if (vm.count(&quot;immediate&quot;))
      opts.at_once = true;
    if (vm.count(&quot;pause&quot;))
      opts.start_paused = true;
    if (vm.count(&quot;queue&quot;))
      opts.queue_size = vm[&quot;queue&quot;].as&lt;int&gt;();
    if (vm.count(&quot;hz&quot;))
      opts.bag_time_frequency = vm[&quot;hz&quot;].as&lt;float&gt;();
    if (vm.count(&quot;clock&quot;))
      opts.bag_time = true;
    if (vm.count(&quot;delay&quot;))
      opts.advertise_sleep = ros::WallDuration(vm[&quot;delay&quot;].as&lt;float&gt;());
    if (vm.count(&quot;rate&quot;))
      opts.time_scale = vm[&quot;rate&quot;].as&lt;float&gt;();
    if (vm.count(&quot;start&quot;))
    {
      opts.time = vm[&quot;start&quot;].as&lt;float&gt;();
      opts.has_time = true;
    }
    if (vm.count(&quot;duration&quot;))
    {
      opts.duration = vm[&quot;duration&quot;].as&lt;float&gt;();
      opts.has_duration = true;
    }
    if (vm.count(&quot;skip-empty&quot;))
      opts.skip_empty = ros::Duration(vm[&quot;skip-empty&quot;].as&lt;float&gt;());
    if (vm.count(&quot;loop&quot;))
      opts.loop = true;
    if (vm.count(&quot;keep-alive&quot;))
      opts.keep_alive = true;
    if (vm.count(&quot;wait-for-subscribers&quot;))
      opts.wait_for_subscribers = true;

    if (vm.count(&quot;topics&quot;))
    {
      std::vector&lt;std::string&gt; topics = vm[&quot;topics&quot;].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = topics.begin();
           i != topics.end();
           i++)
        opts.topics.push_back(*i);
    }

    if (vm.count(&quot;pause-topics&quot;))
    {
      std::vector&lt;std::string&gt; pause_topics = vm[&quot;pause-topics&quot;].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = pause_topics.begin();
           i != pause_topics.end();
           i++)
        opts.pause_topics.push_back(*i);
    }

    if (vm.count(&quot;rate-control-topic&quot;))
      opts.rate_control_topic = vm[&quot;rate-control-topic&quot;].as&lt;std::string&gt;();

    if (vm.count(&quot;rate-control-max-delay&quot;))
      opts.rate_control_max_delay = vm[&quot;rate-control-max-delay&quot;].as&lt;float&gt;();

    if (vm.count(&quot;bags&quot;))
    {
      std::vector&lt;std::string&gt; bags = vm[&quot;bags&quot;].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = bags.begin();
           i != bags.end();
           i++)
          opts.bags.push_back(*i);
    } else {
      if (vm.count(&quot;topics&quot;) || vm.count(&quot;pause-topics&quot;))
        throw ros::Exception(&quot;When using --topics or --pause-topics, --bags &quot;
          &quot;should be specified to list bags.&quot;);
      throw ros::Exception(&quot;You must specify at least one bag to play back.&quot;);
    }
            
    return opts;
}

int main(int argc, char** argv) {
    ros::init(argc, argv, &quot;play&quot;, ros::init_options::AnonymousName);

    // Parse the command-line options
    rosbag::PlayerOptions opts;
    try {
        opts = parseOptions(argc, argv);
    }
    catch (const ros::Exception&amp; ex) {
        ROS_ERROR(&quot;Error reading options: %s&quot;, ex.what());
        return 1;
    }

    rosbag::Player player(opts);

    try {
      player.publish();
    }
    catch (const std::runtime_error&amp; e) {
      ROS_FATAL(&quot;%s&quot;, e.what());
      return 1;
    }
    
    return 0;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>signal9.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2010, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

#ifndef MESSAGE_FILTERS_SIGNAL9_H
#define MESSAGE_FILTERS_SIGNAL9_H

#include &lt;boost/noncopyable.hpp&gt;

#include &quot;connection.h&quot;
#include &quot;null_types.h&quot;
#include &lt;ros/message_event.h&gt;
#include &lt;ros/parameter_adapter.h&gt;

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/thread/mutex.hpp&gt;

namespace message_filters
{
using ros::ParameterAdapter;

template&lt;typename M0, typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8&gt;
class CallbackHelper9
{
public:
  typedef ros::MessageEvent&lt;M0 const&gt; M0Event;
  typedef ros::MessageEvent&lt;M1 const&gt; M1Event;
  typedef ros::MessageEvent&lt;M2 const&gt; M2Event;
  typedef ros::MessageEvent&lt;M3 const&gt; M3Event;
  typedef ros::MessageEvent&lt;M4 const&gt; M4Event;
  typedef ros::MessageEvent&lt;M5 const&gt; M5Event;
  typedef ros::MessageEvent&lt;M6 const&gt; M6Event;
  typedef ros::MessageEvent&lt;M7 const&gt; M7Event;
  typedef ros::MessageEvent&lt;M8 const&gt; M8Event;

  virtual ~CallbackHelper9() {}

  virtual void call(bool nonconst_force_copy, const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3,
                    const M4Event&amp; e4, const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8) = 0;

  typedef boost::shared_ptr&lt;CallbackHelper9&gt; Ptr;
};

template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
class CallbackHelper9T :
  public CallbackHelper9&lt;typename ParameterAdapter&lt;P0&gt;::Message,
                         typename ParameterAdapter&lt;P1&gt;::Message,
                         typename ParameterAdapter&lt;P2&gt;::Message,
                         typename ParameterAdapter&lt;P3&gt;::Message,
                         typename ParameterAdapter&lt;P4&gt;::Message,
                         typename ParameterAdapter&lt;P5&gt;::Message,
                         typename ParameterAdapter&lt;P6&gt;::Message,
                         typename ParameterAdapter&lt;P7&gt;::Message,
                         typename ParameterAdapter&lt;P8&gt;::Message&gt;
{
private:
  typedef ParameterAdapter&lt;P0&gt; A0;
  typedef ParameterAdapter&lt;P1&gt; A1;
  typedef ParameterAdapter&lt;P2&gt; A2;
  typedef ParameterAdapter&lt;P3&gt; A3;
  typedef ParameterAdapter&lt;P4&gt; A4;
  typedef ParameterAdapter&lt;P5&gt; A5;
  typedef ParameterAdapter&lt;P6&gt; A6;
  typedef ParameterAdapter&lt;P7&gt; A7;
  typedef ParameterAdapter&lt;P8&gt; A8;
  typedef typename A0::Event M0Event;
  typedef typename A1::Event M1Event;
  typedef typename A2::Event M2Event;
  typedef typename A3::Event M3Event;
  typedef typename A4::Event M4Event;
  typedef typename A5::Event M5Event;
  typedef typename A6::Event M6Event;
  typedef typename A7::Event M7Event;
  typedef typename A8::Event M8Event;

public:
  typedef boost::function&lt;void(typename A0::Parameter, typename A1::Parameter, typename A2::Parameter,
                               typename A3::Parameter, typename A4::Parameter, typename A5::Parameter,
                               typename A6::Parameter, typename A7::Parameter, typename A8::Parameter)&gt; Callback;

  CallbackHelper9T(const Callback&amp; cb)
  : callback_(cb)
  {
  }

  virtual void call(bool nonconst_force_copy, const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3,
                    const M4Event&amp; e4, const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8)
  {
    M0Event my_e0(e0, nonconst_force_copy || e0.nonConstWillCopy());
    M1Event my_e1(e1, nonconst_force_copy || e0.nonConstWillCopy());
    M2Event my_e2(e2, nonconst_force_copy || e0.nonConstWillCopy());
    M3Event my_e3(e3, nonconst_force_copy || e0.nonConstWillCopy());
    M4Event my_e4(e4, nonconst_force_copy || e0.nonConstWillCopy());
    M5Event my_e5(e5, nonconst_force_copy || e0.nonConstWillCopy());
    M6Event my_e6(e6, nonconst_force_copy || e0.nonConstWillCopy());
    M7Event my_e7(e7, nonconst_force_copy || e0.nonConstWillCopy());
    M8Event my_e8(e8, nonconst_force_copy || e0.nonConstWillCopy());
    callback_(A0::getParameter(e0),
              A1::getParameter(e1),
              A2::getParameter(e2),
              A3::getParameter(e3),
              A4::getParameter(e4),
              A5::getParameter(e5),
              A6::getParameter(e6),
              A7::getParameter(e7),
              A8::getParameter(e8));
  }

private:
  Callback callback_;
};

template&lt;typename M0, typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8&gt;
class Signal9
{
  typedef boost::shared_ptr&lt;CallbackHelper9&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt; &gt; CallbackHelper9Ptr;
  typedef std::vector&lt;CallbackHelper9Ptr&gt; V_CallbackHelper9;

public:
  typedef ros::MessageEvent&lt;M0 const&gt; M0Event;
  typedef ros::MessageEvent&lt;M1 const&gt; M1Event;
  typedef ros::MessageEvent&lt;M2 const&gt; M2Event;
  typedef ros::MessageEvent&lt;M3 const&gt; M3Event;
  typedef ros::MessageEvent&lt;M4 const&gt; M4Event;
  typedef ros::MessageEvent&lt;M5 const&gt; M5Event;
  typedef ros::MessageEvent&lt;M6 const&gt; M6Event;
  typedef ros::MessageEvent&lt;M7 const&gt; M7Event;
  typedef ros::MessageEvent&lt;M8 const&gt; M8Event;
  typedef boost::shared_ptr&lt;M0 const&gt; M0ConstPtr;
  typedef boost::shared_ptr&lt;M1 const&gt; M1ConstPtr;
  typedef boost::shared_ptr&lt;M2 const&gt; M2ConstPtr;
  typedef boost::shared_ptr&lt;M3 const&gt; M3ConstPtr;
  typedef boost::shared_ptr&lt;M4 const&gt; M4ConstPtr;
  typedef boost::shared_ptr&lt;M5 const&gt; M5ConstPtr;
  typedef boost::shared_ptr&lt;M6 const&gt; M6ConstPtr;
  typedef boost::shared_ptr&lt;M7 const&gt; M7ConstPtr;
  typedef boost::shared_ptr&lt;M8 const&gt; M8ConstPtr;
  typedef const boost::shared_ptr&lt;NullType const&gt;&amp; NullP;

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
  Connection addCallback(const boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;&amp; callback)
  {
    CallbackHelper9T&lt;P0, P1, P2, P3, P4, P5, P6, P7, P8&gt;* helper = new CallbackHelper9T&lt;P0, P1, P2, P3, P4, P5, P6, P7, P8&gt;(callback);

    boost::mutex::scoped_lock lock(mutex_);
    callbacks_.push_back(CallbackHelper9Ptr(helper));
    return Connection(boost::bind(&amp;Signal9::removeCallback, this, callbacks_.back()));
  }

  template&lt;typename P0, typename P1&gt;
  Connection addCallback(void(*callback)(P0, P1))
  {
    return addCallback(boost::function&lt;void(P0, P1, NullP, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2)));
  }

  template&lt;typename P0, typename P1, typename P2&gt;
  Connection addCallback(void(*callback)(P0, P1, P2))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5)));
  }

<A NAME="0"></A>  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5))
  {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match727-0.html#0',2,'match727-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, NullP, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6)));</B></FONT>
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, NullP, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, boost::placeholders::_7)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6, P7))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, NullP)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8)));
  }

  template&lt;typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8&gt;
  Connection addCallback(void(*callback)(P0, P1, P2, P3, P4, P5, P6, P7, P8))
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8, boost::placeholders::_9)));
  }

  template&lt;typename T, typename P0, typename P1&gt;
  Connection addCallback(void(T::*callback)(P0, P1), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, NullP, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, NullP, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, NullP, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, NullP, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, NullP, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, NullP, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, boost::placeholders::_7)));
  }

  template&lt;typename T, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7&gt;
  Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6, P7), T* t)
  {
    return addCallback(boost::function&lt;void(P0, P1, P2, P3, P4, P5, P6, P7, NullP)&gt;(boost::bind(callback, t, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8)));
  }

  template&lt;typename C&gt;
  Connection addCallback( C&amp; callback)
  {
    return addCallback&lt;const M0ConstPtr&amp;,
                     const M1ConstPtr&amp;,
                     const M2ConstPtr&amp;,
                     const M3ConstPtr&amp;,
                     const M4ConstPtr&amp;,
                     const M5ConstPtr&amp;,
                     const M6ConstPtr&amp;,
                     const M7ConstPtr&amp;,
                     const M8ConstPtr&amp;&gt;(boost::bind(callback, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3, boost::placeholders::_4, boost::placeholders::_5, boost::placeholders::_6, _7, boost::placeholders::_8, boost::placeholders::_9));
  }

  void removeCallback(const CallbackHelper9Ptr&amp; helper)
  {
    boost::mutex::scoped_lock lock(mutex_);
    typename V_CallbackHelper9::iterator it = std::find(callbacks_.begin(), callbacks_.end(), helper);
    if (it != callbacks_.end())
    {
      callbacks_.erase(it);
    }
  }

  void call(const M0Event&amp; e0, const M1Event&amp; e1, const M2Event&amp; e2, const M3Event&amp; e3, const M4Event&amp; e4,
            const M5Event&amp; e5, const M6Event&amp; e6, const M7Event&amp; e7, const M8Event&amp; e8)
  {
    boost::mutex::scoped_lock lock(mutex_);
    bool nonconst_force_copy = callbacks_.size() &gt; 1;
    typename V_CallbackHelper9::iterator it = callbacks_.begin();
    typename V_CallbackHelper9::iterator end = callbacks_.end();
    for (; it != end; ++it)
    {
      const CallbackHelper9Ptr&amp; helper = *it;
      helper-&gt;call(nonconst_force_copy, e0, e1, e2, e3, e4, e5, e6, e7, e8);
    }
  }

private:
  boost::mutex mutex_;
  V_CallbackHelper9 callbacks_;
};

} // message_filters

#endif // MESSAGE_FILTERS_SIGNAL9_H


</PRE>
</div>
  </div>
</body>
</html>
