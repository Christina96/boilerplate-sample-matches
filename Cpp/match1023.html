<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for BaseTestEntity.cpp & BaseTestMultiTag.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for BaseTestEntity.cpp & BaseTestMultiTag.cpp
      </h3>
      <h1 align="center">
        13.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>BaseTestEntity.cpp (56.52174%)<TH>BaseTestMultiTag.cpp (7.6923075%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1023-0.html#0',2,'match1023-1.html#0',3)" NAME="0">(35-47)<TD><A HREF="javascript:ZweiFrames('match1023-0.html#0',2,'match1023-1.html#0',3)" NAME="0">(49-61)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1023-0.html#1',2,'match1023-1.html#1',3)" NAME="1">(51-65)<TD><A HREF="javascript:ZweiFrames('match1023-0.html#1',2,'match1023-1.html#1',3)" NAME="1">(468-487)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestEntity.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

#include &lt;nix/util/util.hpp&gt;
#include &quot;BaseTestEntity.hpp&quot;

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;

using namespace nix;


void BaseTestEntity::testId() {
    CPPUNIT_ASSERT(block.id().size() == 36);
    CPPUNIT_ASSERT(util::toId(block).compare(block.id()) == 0);
}


<A NAME="0"></A>void BaseTestEntity::testName() {
    CPPUNIT_ASSERT(block.name() == &quot;block_one&quot;);
    CPPUNIT_ASSERT(util::toName(block).compare(block.name()) == 0);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1023-1.html#0',3,'match1023-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}


void BaseTestEntity::testType() {
    CPPUNIT_ASSERT(block.type() == &quot;dataset&quot;);
    std::string typ = util::createId();
    block.type(typ);
    CPPUNIT_ASSERT(block.type() == typ);
}


void BaseTestEntity::testDefinition() {
    std::string def = util::createId();</B></FONT>
<A NAME="1"></A>    block.definition(def);
    CPPUNIT_ASSERT(*block.definition() == def);
    block.definition(nix::none);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1023-1.html#1',3,'match1023-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CPPUNIT_ASSERT(block.definition() == nix::none);
}


void BaseTestEntity::testCreatedAt() {
    CPPUNIT_ASSERT(block.createdAt() &gt;= startup_time);
    time_t past_time = time(NULL) - 10000000;
    block.forceCreatedAt(past_time);
    CPPUNIT_ASSERT(block.createdAt() == past_time);
}


void BaseTestEntity::testUpdatedAt() {
    CPPUNIT_ASSERT(block.updatedAt() &gt;= startup_time);
}</B></FONT>


void BaseTestEntity::testIsValidEntity() {
    CPPUNIT_ASSERT(block.isValidEntity());
    Source s  = block.createSource(&quot;test&quot;, &quot;test&quot;);
    CPPUNIT_ASSERT(s.isValidEntity());
    block.deleteSource(s.name());
    CPPUNIT_ASSERT(!s.isValidEntity());
}


void BaseTestEntity::testOperators() {
    CPPUNIT_ASSERT(block_null == false);
    CPPUNIT_ASSERT(block_null == none);

    CPPUNIT_ASSERT(block != false);
    CPPUNIT_ASSERT(block != none);

    CPPUNIT_ASSERT(block == block);
    CPPUNIT_ASSERT(block != block_other);

    block_other = block;
    CPPUNIT_ASSERT(block_other == block);
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestMultiTag.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright Â© 2014 - 2015 German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.
//
// Author: Jan Grewe &lt;jan.grewe@g-node.org&gt;


#include &lt;sstream&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/Exception.hpp&gt;
#include &lt;nix/hydra/multiArray.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;

#include &quot;BaseTestMultiTag.hpp&quot;

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;

using namespace nix;
using namespace valid;


void BaseTestMultiTag::testValidate() {
    valid::Result result = validate(tag);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestMultiTag::testId() {
    CPPUNIT_ASSERT(tag.id().size() == 36);
}

<A NAME="0"></A>
void BaseTestMultiTag::testName() {
    CPPUNIT_ASSERT(tag.name() == &quot;tag_one&quot;);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1023-0.html#0',2,'match1023-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


void BaseTestMultiTag::testType() {
    CPPUNIT_ASSERT(tag.type() == &quot;test_tag&quot;);
    std::string type = util::createId();
    tag.type(type);
    CPPUNIT_ASSERT(tag.type() == type);
}


void BaseTestMultiTag::testDefinition() {
    std::string def = util::createId();</B></FONT>
    tag.definition(def);
    CPPUNIT_ASSERT(*tag.definition() == def);
    tag.definition(none);
    CPPUNIT_ASSERT(tag.definition() == none);
}


void BaseTestMultiTag::testCreateRemove() {
    std::vector&lt;std::string&gt; ids;
    ndsize_t count = block.multiTagCount();
    const char *names[5] = { &quot;tag_a&quot;, &quot;tag_b&quot;, &quot;tag_c&quot;, &quot;tag_d&quot;, &quot;tag_e&quot; };
    for (int i = 0; i &lt; 5; i++) {
        std::string type = &quot;Event&quot;;
        MultiTag dt1 = block.createMultiTag(names[i], type, positions);
        MultiTag dt2 = block.getMultiTag(dt1.id());
        ids.push_back(dt1.id());

        std::stringstream errmsg;
        errmsg &lt;&lt; &quot;Error while accessing multiTag: dt1.id() = &quot; &lt;&lt; dt1.id()
        &lt;&lt; &quot; / dt2.id() = &quot; &lt;&lt; dt2.id();
        CPPUNIT_ASSERT_MESSAGE(errmsg.str(), dt1.id().compare(dt2.id()) == 0);
    }
    std::stringstream errmsg2;
    errmsg2 &lt;&lt; &quot;Error creating MultiTags. Counts do not match!&quot;;
    CPPUNIT_ASSERT_MESSAGE(errmsg2.str(), block.multiTagCount() == (count+5));

    CPPUNIT_ASSERT_THROW(block.createMultiTag(names[4], &quot;test&quot;, positions), DuplicateName);

    for (size_t i = 0; i &lt; ids.size(); i++) {
        block.deleteMultiTag(ids[i]);
    }
    std::stringstream errmsg1;
    errmsg1 &lt;&lt; &quot;Error while removing multiTags!&quot;;
    CPPUNIT_ASSERT_MESSAGE(errmsg1.str(), block.multiTagCount() == count);

    DataArray a;
    MultiTag mtag;
    CPPUNIT_ASSERT_THROW(mtag = block.createMultiTag(&quot;test&quot;, &quot;test&quot;, a), nix::UninitializedEntity);
    mtag = block.createMultiTag(&quot;test&quot;, &quot;test&quot;, positions);
    mtag.extents(positions);
    CPPUNIT_ASSERT_THROW(mtag.positions(a), UninitializedEntity);
    CPPUNIT_ASSERT(mtag.extents().id() == positions.id());
    CPPUNIT_ASSERT_NO_THROW(mtag.extents(a));
    CPPUNIT_ASSERT(!mtag.extents());
}


void BaseTestMultiTag::testUnits() {
    MultiTag dt = block.createMultiTag(&quot;TestMultiTag1&quot;, &quot;Tag&quot;, positions);

    std::vector&lt;std::string&gt; valid_units = {&quot;mV&quot;, &quot;cm&quot;, &quot;m^2&quot;};
    std::vector&lt;std::string&gt; invalid_units = {&quot;mV&quot;, &quot;haha&quot;, &quot;qm^2&quot;};
    std::vector&lt;std::string&gt; insane_units = {&quot;muV &quot;, &quot; muS&quot;};

    CPPUNIT_ASSERT_NO_THROW(dt.units(valid_units));
    CPPUNIT_ASSERT(dt.units().size() == valid_units.size());
    std::vector&lt;std::string&gt; retrieved_units = dt.units();
    for (size_t i = 0; i &lt; retrieved_units.size(); i++) {
        CPPUNIT_ASSERT(retrieved_units[i] == valid_units[i]);
    }

    dt.units(none);
    CPPUNIT_ASSERT(dt.units().size() == 0);
    CPPUNIT_ASSERT_THROW(dt.units(invalid_units), InvalidUnit);
    CPPUNIT_ASSERT(dt.units().size() == 0);

    dt.units(insane_units);
    retrieved_units = dt.units();
    CPPUNIT_ASSERT(retrieved_units.size() == 2);
    CPPUNIT_ASSERT(retrieved_units[0] == &quot;uV&quot;);
    CPPUNIT_ASSERT(retrieved_units[1] == &quot;uS&quot;);

    block.deleteMultiTag(dt.id());
}

//TODO merge this test into TestBaseTag::testReferences

void BaseTestMultiTag::testReferences(){
    DataArray da_1 = block.createDataArray(&quot;TestReference 1&quot;,
                                           &quot;Reference&quot;,
                                           DataType::Double,
                                           NDSize({ 0 }));
    DataArray da_2 = block.createDataArray(&quot;TestReference 2&quot;, &quot;Reference&quot;,
                                           DataType::Double,
                                           NDSize({ 0 }));
    DataArray a;
    MultiTag dt = block.createMultiTag(&quot;TestMultiTag1&quot;, &quot;Tag&quot;, positions);

    CPPUNIT_ASSERT_THROW(dt.getReference(42), OutOfBounds);
    CPPUNIT_ASSERT(!dt.hasReference(a));

    std::stringstream counterrmsg;
    counterrmsg &lt;&lt; &quot;BaseTestMultiTag::testReference: Counts do not match!&quot;;
    CPPUNIT_ASSERT_MESSAGE(counterrmsg.str(), dt.referenceCount() == 0);

    dt.addReference(da_1);
    dt.addReference(da_2);
    CPPUNIT_ASSERT_THROW(dt.addReference(a), UninitializedEntity);
    CPPUNIT_ASSERT_THROW(dt.removeReference(a), UninitializedEntity);

    CPPUNIT_ASSERT_MESSAGE(counterrmsg.str(), dt.referenceCount() == 2);
    CPPUNIT_ASSERT(dt.hasReference(da_1));
    CPPUNIT_ASSERT(dt.hasReference(da_2));

    std::stringstream haserrmsg;
    haserrmsg &lt;&lt; &quot;BaseTestMultiTag::testReference: Has method did not work!&quot;;
    CPPUNIT_ASSERT_MESSAGE(haserrmsg.str(), dt.hasReference(da_1.id()));
    CPPUNIT_ASSERT_MESSAGE(haserrmsg.str(), dt.hasReference(da_1.name()));

    DataArray ref1 = dt.getReference(da_1.id());
    std::stringstream retrieveerrmsg;
    retrieveerrmsg &lt;&lt; &quot;BaseTestMultiTag::testReference: Retrieval did not work!&quot;;
    CPPUNIT_ASSERT_MESSAGE(retrieveerrmsg.str(), ref1.id() == da_1.id());
    DataArray ref2 = dt.getReference(da_1.name());
    retrieveerrmsg &lt;&lt; &quot;BaseTestMultiTag::testReference: Retrieval by name did not work!&quot;;
    CPPUNIT_ASSERT_MESSAGE(retrieveerrmsg.str(), ref2.id() == da_1.id());

    std::vector&lt;DataArray&gt; arrays = dt.references();
    CPPUNIT_ASSERT_MESSAGE(retrieveerrmsg.str(), arrays.size() == 2);

    std::stringstream hasReferrmsg;
    hasReferrmsg &lt;&lt; &quot;BaseTestMultiTag::testReference: hadReference did not work!&quot;;
    CPPUNIT_ASSERT_MESSAGE(hasReferrmsg.str(), dt.hasReference(da_1.id()));
    CPPUNIT_ASSERT_MESSAGE(hasReferrmsg.str(), dt.hasReference(da_2.id()));

    std::stringstream delReferrmsg;
    delReferrmsg &lt;&lt; &quot;BaseTestMultiTag::testReference: removeReference did not work!&quot;;
    dt.removeReference(da_1.id());
    CPPUNIT_ASSERT_MESSAGE(delReferrmsg.str(), dt.referenceCount() == 1);
    dt.removeReference(&quot;NONEXISTENT&quot;);
    CPPUNIT_ASSERT_MESSAGE(delReferrmsg.str(), dt.referenceCount() == 1);
    dt.removeReference(da_2.name());
    CPPUNIT_ASSERT_MESSAGE(delReferrmsg.str(), dt.referenceCount() == 0);
    dt.addReference(da_1);
    CPPUNIT_ASSERT(dt.referenceCount() == 1);
    CPPUNIT_ASSERT_NO_THROW(dt.removeReference(da_1));
    CPPUNIT_ASSERT(dt.referenceCount() == 0);

    // delete data arrays
    std::vector&lt;std::string&gt; ids = {da_1.id(), da_2.id()};
    block.deleteDataArray(da_1.id());
    block.deleteDataArray(da_2.id());
    // check if references are gone too!
    CPPUNIT_ASSERT(dt.referenceCount() == 0);
    CPPUNIT_ASSERT(!dt.hasReference(ids[0]));
    CPPUNIT_ASSERT(!dt.hasReference(ids[1]));
    block.deleteMultiTag(dt.id());
}


void BaseTestMultiTag::testFeatures() {
    DataArray a;
    Feature f;

    CPPUNIT_ASSERT(tag.featureCount() == 0);
    CPPUNIT_ASSERT(!tag.hasFeature(f));
    CPPUNIT_ASSERT(!tag.deleteFeature(f));
    CPPUNIT_ASSERT_THROW(tag.createFeature(a, nix::LinkType::Indexed), nix::UninitializedEntity);

    CPPUNIT_ASSERT_NO_THROW(f = tag.createFeature(positions, nix::LinkType::Indexed));
    CPPUNIT_ASSERT(tag.hasFeature(f));
    CPPUNIT_ASSERT(tag.featureCount() == 1);
    CPPUNIT_ASSERT(tag.deleteFeature(f));
    CPPUNIT_ASSERT(tag.featureCount() == 0);
}


void BaseTestMultiTag::testExtents(){
    CPPUNIT_ASSERT_THROW(tag.extents(&quot;wrong_data_array_id&quot;), std::runtime_error);
    CPPUNIT_ASSERT_THROW(tag.extents(&quot;&quot;), EmptyString);
    CPPUNIT_ASSERT_THROW(tag.extents(wrong_array), std::runtime_error);

    DataArray a = block.createDataArray(&quot;name&quot;, &quot;type&quot;, DataType::Double, {0,0});
    block.deleteDataArray(a);
    CPPUNIT_ASSERT_THROW(tag.extents(a), UninitializedEntity);
    typedef boost::multi_array&lt;double, 2&gt; array_type;
    typedef array_type::index index;
    array_type A(boost::extents[5][5]);
    for(index i = 0; i &lt; 5; ++i){
        A[i][i] = 100.0*i;
    }
    positions.setData(A);
    extents.setData(A);

    tag.positions(positions);
    tag.extents(extents);
    CPPUNIT_ASSERT(tag.extents() == true);
    tag.extents(none);
    CPPUNIT_ASSERT(tag.extents() == false);
}


void BaseTestMultiTag::testPositions() {
    CPPUNIT_ASSERT_THROW(tag.positions(&quot;wrong_data_array_id&quot;), std::runtime_error);
    CPPUNIT_ASSERT_THROW(tag.positions(&quot;&quot;), EmptyString);

    tag.positions(positions);
    CPPUNIT_ASSERT(tag.positionCount() == positions.dataExtent()[0]);
    CPPUNIT_ASSERT(tag.positions().id() == positions.id());
    CPPUNIT_ASSERT(tag.hasPositions());
    block.deleteDataArray(positions.id());
    // make sure link is gone with data array
    CPPUNIT_ASSERT_THROW(tag.positions(), std::runtime_error);
}


void BaseTestMultiTag::testPositionExtents() {
    tag.extents(extents);
    CPPUNIT_ASSERT(tag.extents().id() == extents.id());
    block.deleteDataArray(extents.id());
    // make sure that link is gone with data array
    CPPUNIT_ASSERT(!tag.extents());
    // re-create extents
    extents = block.createDataArray(&quot;extents_DataArray&quot;, &quot;dataArray&quot;,
                                    DataType::Double, {0, 0});
    typedef boost::multi_array&lt;double, 2&gt; array_type;
    typedef array_type::index index;
    array_type B(boost::extents[5][5]);
    for(index i = 0; i &lt; 5; ++i){
        B[i][i] = 100.0*i;
    }
    extents.setData(B);

    array_type A(boost::extents[10][10]);
    for(index i = 0; i &lt; 10; ++i){
        A[i][i] = 100.0*i;
    }
    positions.setData(A);

    tag.positions(positions);
    CPPUNIT_ASSERT_THROW(tag.extents(extents), std::runtime_error);
    tag.extents(none);
    CPPUNIT_ASSERT(tag.extents() == false);
}


void BaseTestMultiTag::testDataAccess() {
    DataArray data_array = block.createDataArray(&quot;dimensionTest&quot;,
                                       &quot;test&quot;,
                                       DataType::Double,
                                       NDSize({0, 0, 0}));
    double samplingInterval = 1.0;
    std::vector&lt;double&gt; ticks {1.2, 2.3, 3.4, 4.5, 6.7};
    std::string unit = &quot;ms&quot;;

    typedef boost::multi_array&lt;double, 3&gt; array_type;
    typedef array_type::index index;
    array_type data(boost::extents[2][10][5]);
    int value;
    for(index i = 0; i != 2; ++i) {
        value = 0;
        for(index j = 0; j != 10; ++j) {
            for(index k = 0; k != 5; ++k) {
                data[i][j][k] = value++;
            }
        }
    }
    data_array.setData(data);

    SetDimension setDim = data_array.appendSetDimension();
    std::vector&lt;std::string&gt; labels = {&quot;label_a&quot;, &quot;label_b&quot;};
    setDim.labels(labels);

    SampledDimension sampledDim = data_array.appendSampledDimension(samplingInterval);
    sampledDim.unit(unit);

    RangeDimension rangeDim = data_array.appendRangeDimension(ticks);
    rangeDim.unit(unit);

    typedef boost::multi_array&lt;double, 2&gt; position_type;
    position_type event_positions(boost::extents[2][3]);
    position_type event_extents(boost::extents[2][3]);
    event_positions[0][0] = 0.0;
    event_positions[0][1] = 3.0;
    event_positions[0][2] = 3.4;

    event_extents[0][0] = 0.0;
    event_extents[0][1] = 6.0;
    event_extents[0][2] = 2.3;

    event_positions[1][0] = 0.0;
    event_positions[1][1] = 8.0;
    event_positions[1][2] = 2.3;

    event_extents[1][0] = 0.0;
    event_extents[1][1] = 3.0;
    event_extents[1][2] = 2.0;

    std::vector&lt;std::string&gt; event_labels = {&quot;event 1&quot;, &quot;event 2&quot;};
    std::vector&lt;std::string&gt; dim_labels = {&quot;dim 0&quot;, &quot;dim 1&quot;, &quot;dim 2&quot;};

    DataArray event_array = block.createDataArray(&quot;positions&quot;, &quot;test&quot;,
                                                  DataType::Double, NDSize({ 0, 0 }));
    event_array.setData(event_positions);
    SetDimension event_set_dim;
    event_set_dim = event_array.appendSetDimension();
    event_set_dim.labels(event_labels);
    event_set_dim = event_array.appendSetDimension();
    event_set_dim.labels(dim_labels);

    DataArray extent_array = block.createDataArray(&quot;extents&quot;, &quot;test&quot;,
                                                   DataType::Double, NDSize({ 0, 0 }));
    extent_array.setData(event_extents);
    SetDimension extent_set_dim;
    extent_set_dim = extent_array.appendSetDimension();
    extent_set_dim.labels(event_labels);
    extent_set_dim = extent_array.appendSetDimension();
    extent_set_dim.labels(dim_labels);

    MultiTag multi_tag = block.createMultiTag(&quot;multi_tag&quot;, &quot;events&quot;, event_array);
    multi_tag.extents(extent_array);
    multi_tag.addReference(data_array);

    CPPUNIT_ASSERT_THROW(multi_tag.taggedData(0, -1), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(multi_tag.taggedData(0, 1), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(multi_tag.taggedData(-1, 0), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(multi_tag.taggedData(10, 0), nix::OutOfBounds);

    DataView ret_data = multi_tag.taggedData(0, 0);
    NDSize data_size = ret_data.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 3);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 6 &amp;&amp; data_size[2] == 2);

    ret_data = multi_tag.taggedData(0, data_array.name());
    data_size = ret_data.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 3);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 6 &amp;&amp; data_size[2] == 2);

    CPPUNIT_ASSERT_THROW(multi_tag.taggedData(1, 0), nix::OutOfBounds);

    block.deleteMultiTag(multi_tag);
    block.deleteDataArray(data_array);
    block.deleteDataArray(event_array);
    block.deleteDataArray(event_array);
}


void BaseTestMultiTag::testMetadataAccess() {
    CPPUNIT_ASSERT(!tag.metadata());
    tag.metadata(section);
    CPPUNIT_ASSERT(tag.metadata());
    CPPUNIT_ASSERT(tag.metadata().id() == section.id());

    // test none-unsetter
    tag.metadata(none);
    CPPUNIT_ASSERT(!tag.metadata());
    // test deleter removing link too
    tag.metadata(section);
    file.deleteSection(section.id());
    CPPUNIT_ASSERT(!tag.metadata());
    // re-create section
    section = file.createSection(&quot;foo_section&quot;, &quot;metadata&quot;);
}


void BaseTestMultiTag::testSourceAccess(){
    std::vector&lt;std::string&gt; names = { &quot;source_a&quot;, &quot;source_b&quot;, &quot;source_c&quot;, &quot;source_d&quot;, &quot;source_e&quot; };
    CPPUNIT_ASSERT(tag.sourceCount() == 0);
    CPPUNIT_ASSERT(tag.sources().size() == 0);

    std::vector&lt;std::string&gt; ids;
    for (auto it = names.begin(); it != names.end(); it++) {
        Source child_source = block.createSource(*it,&quot;channel&quot;);
        tag.addSource(child_source);
        CPPUNIT_ASSERT(child_source.name() == *it);
        ids.push_back(child_source.id());
    }

    CPPUNIT_ASSERT(tag.sourceCount() == names.size());
    CPPUNIT_ASSERT(tag.sources().size() == names.size());

    std::string name = names[0];
    Source source = tag.getSource(name);
    CPPUNIT_ASSERT(source.name() == name);

    for (auto it = ids.begin(); it != ids.end(); it++) {
        Source child_source = tag.getSource(*it);
        CPPUNIT_ASSERT(tag.hasSource(*it) == true);
        CPPUNIT_ASSERT(child_source.id() == *it);

        tag.removeSource(*it);
        block.deleteSource(*it);
    }

    CPPUNIT_ASSERT(tag.sourceCount() == 0);
    CPPUNIT_ASSERT(tag.sources().size() == 0);
}


void BaseTestMultiTag::testOperators() {
    CPPUNIT_ASSERT(tag_null == false);
    CPPUNIT_ASSERT(tag_null == none);

    CPPUNIT_ASSERT(tag != false);
    CPPUNIT_ASSERT(tag != none);

    CPPUNIT_ASSERT(tag == tag);
    CPPUNIT_ASSERT(tag != tag_other);

    tag_other = tag;
    CPPUNIT_ASSERT(tag == tag_other);

    tag_other = none;
<A NAME="1"></A>    CPPUNIT_ASSERT(tag_other == false);
    CPPUNIT_ASSERT(tag_other == none);

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1023-0.html#1',2,'match1023-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    std::stringstream str1, str2;
    str1 &lt;&lt; &quot;MultiTag: {name = &quot; &lt;&lt; tag.name();
    str1 &lt;&lt; &quot;, type = &quot; &lt;&lt; tag.type();
    str1 &lt;&lt; &quot;, id = &quot; &lt;&lt; tag.id() &lt;&lt; &quot;}&quot;;
    str2 &lt;&lt; tag;
    CPPUNIT_ASSERT(str1.str() == str2.str());
}


void BaseTestMultiTag::testCreatedAt() {
    CPPUNIT_ASSERT(tag.createdAt() &gt;= startup_time);
    time_t past_time = time(NULL) - 10000000;
    tag.forceCreatedAt(past_time);
    CPPUNIT_ASSERT(tag.createdAt() == past_time);
}


void BaseTestMultiTag::testUpdatedAt() {
    CPPUNIT_ASSERT(tag.updatedAt() &gt;= startup_time);
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
