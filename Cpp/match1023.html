<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for BaseTestEntity.cpp &amp; BaseTestMultiTag.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for BaseTestEntity.cpp &amp; BaseTestMultiTag.cpp
      </h3>
<h1 align="center">
        13.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>BaseTestEntity.cpp (56.52174%)<th>BaseTestMultiTag.cpp (7.6923075%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(35-47)<td><a href="#" name="0">(49-61)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(51-65)<td><a href="#" name="1">(468-487)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestEntity.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;ctime&gt;
2 #include &lt;iostream&gt;
3 #include &lt;iterator&gt;
4 #include &lt;nix/util/util.hpp&gt;
5 #include "BaseTestEntity.hpp"
6 #include &lt;cppunit/extensions/HelperMacros.h&gt;
7 #include &lt;cppunit/CompilerOutputter.h&gt;
8 #include &lt;cppunit/TestResult.h&gt;
9 #include &lt;cppunit/TestResultCollector.h&gt;
10 #include &lt;cppunit/TestRunner.h&gt;
11 #include &lt;cppunit/BriefTestProgressListener.h&gt;
12 using namespace nix;
13 void BaseTestEntity::testId() {
14     CPPUNIT_ASSERT(block.id().size() == 36);
15     CPPUNIT_ASSERT(util::toId(block).compare(block.id()) == 0);
16 }
17 <a name="0"></a>void BaseTestEntity::testName() {
18     CPPUNIT_ASSERT(block.name() == "block_one");
19     CPPUNIT_ASSERT(util::toName(block).compare(block.name()) == 0);
20 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
21 void BaseTestEntity::testType() {
22     CPPUNIT_ASSERT(block.type() == "dataset");
23     std::string typ = util::createId();
24     block.type(typ);
25     CPPUNIT_ASSERT(block.type() == typ);
26 }
27 void BaseTestEntity::testDefinition() {
28     std::string def = util::createId();</b></font>
29 <a name="1"></a>    block.definition(def);
30     CPPUNIT_ASSERT(*block.definition() == def);
31     block.definition(nix::none);
32 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    CPPUNIT_ASSERT(block.definition() == nix::none);
33 }
34 void BaseTestEntity::testCreatedAt() {
35     CPPUNIT_ASSERT(block.createdAt() &gt;= startup_time);
36     time_t past_time = time(NULL) - 10000000;
37     block.forceCreatedAt(past_time);
38     CPPUNIT_ASSERT(block.createdAt() == past_time);
39 }
40 void BaseTestEntity::testUpdatedAt() {
41     CPPUNIT_ASSERT(block.updatedAt() &gt;= startup_time);
42 }</b></font>
43 void BaseTestEntity::testIsValidEntity() {
44     CPPUNIT_ASSERT(block.isValidEntity());
45     Source s  = block.createSource("test", "test");
46     CPPUNIT_ASSERT(s.isValidEntity());
47     block.deleteSource(s.name());
48     CPPUNIT_ASSERT(!s.isValidEntity());
49 }
50 void BaseTestEntity::testOperators() {
51     CPPUNIT_ASSERT(block_null == false);
52     CPPUNIT_ASSERT(block_null == none);
53     CPPUNIT_ASSERT(block != false);
54     CPPUNIT_ASSERT(block != none);
55     CPPUNIT_ASSERT(block == block);
56     CPPUNIT_ASSERT(block != block_other);
57     block_other = block;
58     CPPUNIT_ASSERT(block_other == block);
59 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestMultiTag.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;sstream&gt;
2 #include &lt;ctime&gt;
3 #include &lt;iostream&gt;
4 #include &lt;iterator&gt;
5 #include &lt;stdexcept&gt;
6 #include &lt;nix/Exception.hpp&gt;
7 #include &lt;nix/hydra/multiArray.hpp&gt;
8 #include &lt;nix/valid/validate.hpp&gt;
9 #include "BaseTestMultiTag.hpp"
10 #include &lt;cppunit/extensions/HelperMacros.h&gt;
11 #include &lt;cppunit/CompilerOutputter.h&gt;
12 #include &lt;cppunit/TestResult.h&gt;
13 #include &lt;cppunit/TestResultCollector.h&gt;
14 #include &lt;cppunit/TestRunner.h&gt;
15 #include &lt;cppunit/BriefTestProgressListener.h&gt;
16 using namespace nix;
17 using namespace valid;
18 void BaseTestMultiTag::testValidate() {
19     valid::Result result = validate(tag);
20     CPPUNIT_ASSERT(result.getErrors().size() == 0);
21     CPPUNIT_ASSERT(result.getWarnings().size() == 0);
22 }
23 void BaseTestMultiTag::testId() {
24     CPPUNIT_ASSERT(tag.id().size() == 36);
25 }
26 <a name="0"></a>
27 void BaseTestMultiTag::testName() {
28     CPPUNIT_ASSERT(tag.name() == "tag_one");
29 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
30 void BaseTestMultiTag::testType() {
31     CPPUNIT_ASSERT(tag.type() == "test_tag");
32     std::string type = util::createId();
33     tag.type(type);
34     CPPUNIT_ASSERT(tag.type() == type);
35 }
36 void BaseTestMultiTag::testDefinition() {
37     std::string def = util::createId();</b></font>
38     tag.definition(def);
39     CPPUNIT_ASSERT(*tag.definition() == def);
40     tag.definition(none);
41     CPPUNIT_ASSERT(tag.definition() == none);
42 }
43 void BaseTestMultiTag::testCreateRemove() {
44     std::vector&lt;std::string&gt; ids;
45     ndsize_t count = block.multiTagCount();
46     const char *names[5] = { "tag_a", "tag_b", "tag_c", "tag_d", "tag_e" };
47     for (int i = 0; i &lt; 5; i++) {
48         std::string type = "Event";
49         MultiTag dt1 = block.createMultiTag(names[i], type, positions);
50         MultiTag dt2 = block.getMultiTag(dt1.id());
51         ids.push_back(dt1.id());
52         std::stringstream errmsg;
53         errmsg &lt;&lt; "Error while accessing multiTag: dt1.id() = " &lt;&lt; dt1.id()
54         &lt;&lt; " / dt2.id() = " &lt;&lt; dt2.id();
55         CPPUNIT_ASSERT_MESSAGE(errmsg.str(), dt1.id().compare(dt2.id()) == 0);
56     }
57     std::stringstream errmsg2;
58     errmsg2 &lt;&lt; "Error creating MultiTags. Counts do not match!";
59     CPPUNIT_ASSERT_MESSAGE(errmsg2.str(), block.multiTagCount() == (count+5));
60     CPPUNIT_ASSERT_THROW(block.createMultiTag(names[4], "test", positions), DuplicateName);
61     for (size_t i = 0; i &lt; ids.size(); i++) {
62         block.deleteMultiTag(ids[i]);
63     }
64     std::stringstream errmsg1;
65     errmsg1 &lt;&lt; "Error while removing multiTags!";
66     CPPUNIT_ASSERT_MESSAGE(errmsg1.str(), block.multiTagCount() == count);
67     DataArray a;
68     MultiTag mtag;
69     CPPUNIT_ASSERT_THROW(mtag = block.createMultiTag("test", "test", a), nix::UninitializedEntity);
70     mtag = block.createMultiTag("test", "test", positions);
71     mtag.extents(positions);
72     CPPUNIT_ASSERT_THROW(mtag.positions(a), UninitializedEntity);
73     CPPUNIT_ASSERT(mtag.extents().id() == positions.id());
74     CPPUNIT_ASSERT_NO_THROW(mtag.extents(a));
75     CPPUNIT_ASSERT(!mtag.extents());
76 }
77 void BaseTestMultiTag::testUnits() {
78     MultiTag dt = block.createMultiTag("TestMultiTag1", "Tag", positions);
79     std::vector&lt;std::string&gt; valid_units = {"mV", "cm", "m^2"};
80     std::vector&lt;std::string&gt; invalid_units = {"mV", "haha", "qm^2"};
81     std::vector&lt;std::string&gt; insane_units = {"muV ", " muS"};
82     CPPUNIT_ASSERT_NO_THROW(dt.units(valid_units));
83     CPPUNIT_ASSERT(dt.units().size() == valid_units.size());
84     std::vector&lt;std::string&gt; retrieved_units = dt.units();
85     for (size_t i = 0; i &lt; retrieved_units.size(); i++) {
86         CPPUNIT_ASSERT(retrieved_units[i] == valid_units[i]);
87     }
88     dt.units(none);
89     CPPUNIT_ASSERT(dt.units().size() == 0);
90     CPPUNIT_ASSERT_THROW(dt.units(invalid_units), InvalidUnit);
91     CPPUNIT_ASSERT(dt.units().size() == 0);
92     dt.units(insane_units);
93     retrieved_units = dt.units();
94     CPPUNIT_ASSERT(retrieved_units.size() == 2);
95     CPPUNIT_ASSERT(retrieved_units[0] == "uV");
96     CPPUNIT_ASSERT(retrieved_units[1] == "uS");
97     block.deleteMultiTag(dt.id());
98 }
99 void BaseTestMultiTag::testReferences(){
100     DataArray da_1 = block.createDataArray("TestReference 1",
101                                            "Reference",
102                                            DataType::Double,
103                                            NDSize({ 0 }));
104     DataArray da_2 = block.createDataArray("TestReference 2", "Reference",
105                                            DataType::Double,
106                                            NDSize({ 0 }));
107     DataArray a;
108     MultiTag dt = block.createMultiTag("TestMultiTag1", "Tag", positions);
109     CPPUNIT_ASSERT_THROW(dt.getReference(42), OutOfBounds);
110     CPPUNIT_ASSERT(!dt.hasReference(a));
111     std::stringstream counterrmsg;
112     counterrmsg &lt;&lt; "BaseTestMultiTag::testReference: Counts do not match!";
113     CPPUNIT_ASSERT_MESSAGE(counterrmsg.str(), dt.referenceCount() == 0);
114     dt.addReference(da_1);
115     dt.addReference(da_2);
116     CPPUNIT_ASSERT_THROW(dt.addReference(a), UninitializedEntity);
117     CPPUNIT_ASSERT_THROW(dt.removeReference(a), UninitializedEntity);
118     CPPUNIT_ASSERT_MESSAGE(counterrmsg.str(), dt.referenceCount() == 2);
119     CPPUNIT_ASSERT(dt.hasReference(da_1));
120     CPPUNIT_ASSERT(dt.hasReference(da_2));
121     std::stringstream haserrmsg;
122     haserrmsg &lt;&lt; "BaseTestMultiTag::testReference: Has method did not work!";
123     CPPUNIT_ASSERT_MESSAGE(haserrmsg.str(), dt.hasReference(da_1.id()));
124     CPPUNIT_ASSERT_MESSAGE(haserrmsg.str(), dt.hasReference(da_1.name()));
125     DataArray ref1 = dt.getReference(da_1.id());
126     std::stringstream retrieveerrmsg;
127     retrieveerrmsg &lt;&lt; "BaseTestMultiTag::testReference: Retrieval did not work!";
128     CPPUNIT_ASSERT_MESSAGE(retrieveerrmsg.str(), ref1.id() == da_1.id());
129     DataArray ref2 = dt.getReference(da_1.name());
130     retrieveerrmsg &lt;&lt; "BaseTestMultiTag::testReference: Retrieval by name did not work!";
131     CPPUNIT_ASSERT_MESSAGE(retrieveerrmsg.str(), ref2.id() == da_1.id());
132     std::vector&lt;DataArray&gt; arrays = dt.references();
133     CPPUNIT_ASSERT_MESSAGE(retrieveerrmsg.str(), arrays.size() == 2);
134     std::stringstream hasReferrmsg;
135     hasReferrmsg &lt;&lt; "BaseTestMultiTag::testReference: hadReference did not work!";
136     CPPUNIT_ASSERT_MESSAGE(hasReferrmsg.str(), dt.hasReference(da_1.id()));
137     CPPUNIT_ASSERT_MESSAGE(hasReferrmsg.str(), dt.hasReference(da_2.id()));
138     std::stringstream delReferrmsg;
139     delReferrmsg &lt;&lt; "BaseTestMultiTag::testReference: removeReference did not work!";
140     dt.removeReference(da_1.id());
141     CPPUNIT_ASSERT_MESSAGE(delReferrmsg.str(), dt.referenceCount() == 1);
142     dt.removeReference("NONEXISTENT");
143     CPPUNIT_ASSERT_MESSAGE(delReferrmsg.str(), dt.referenceCount() == 1);
144     dt.removeReference(da_2.name());
145     CPPUNIT_ASSERT_MESSAGE(delReferrmsg.str(), dt.referenceCount() == 0);
146     dt.addReference(da_1);
147     CPPUNIT_ASSERT(dt.referenceCount() == 1);
148     CPPUNIT_ASSERT_NO_THROW(dt.removeReference(da_1));
149     CPPUNIT_ASSERT(dt.referenceCount() == 0);
150     std::vector&lt;std::string&gt; ids = {da_1.id(), da_2.id()};
151     block.deleteDataArray(da_1.id());
152     block.deleteDataArray(da_2.id());
153     CPPUNIT_ASSERT(dt.referenceCount() == 0);
154     CPPUNIT_ASSERT(!dt.hasReference(ids[0]));
155     CPPUNIT_ASSERT(!dt.hasReference(ids[1]));
156     block.deleteMultiTag(dt.id());
157 }
158 void BaseTestMultiTag::testFeatures() {
159     DataArray a;
160     Feature f;
161     CPPUNIT_ASSERT(tag.featureCount() == 0);
162     CPPUNIT_ASSERT(!tag.hasFeature(f));
163     CPPUNIT_ASSERT(!tag.deleteFeature(f));
164     CPPUNIT_ASSERT_THROW(tag.createFeature(a, nix::LinkType::Indexed), nix::UninitializedEntity);
165     CPPUNIT_ASSERT_NO_THROW(f = tag.createFeature(positions, nix::LinkType::Indexed));
166     CPPUNIT_ASSERT(tag.hasFeature(f));
167     CPPUNIT_ASSERT(tag.featureCount() == 1);
168     CPPUNIT_ASSERT(tag.deleteFeature(f));
169     CPPUNIT_ASSERT(tag.featureCount() == 0);
170 }
171 void BaseTestMultiTag::testExtents(){
172     CPPUNIT_ASSERT_THROW(tag.extents("wrong_data_array_id"), std::runtime_error);
173     CPPUNIT_ASSERT_THROW(tag.extents(""), EmptyString);
174     CPPUNIT_ASSERT_THROW(tag.extents(wrong_array), std::runtime_error);
175     DataArray a = block.createDataArray("name", "type", DataType::Double, {0,0});
176     block.deleteDataArray(a);
177     CPPUNIT_ASSERT_THROW(tag.extents(a), UninitializedEntity);
178     typedef boost::multi_array&lt;double, 2&gt; array_type;
179     typedef array_type::index index;
180     array_type A(boost::extents[5][5]);
181     for(index i = 0; i &lt; 5; ++i){
182         A[i][i] = 100.0*i;
183     }
184     positions.setData(A);
185     extents.setData(A);
186     tag.positions(positions);
187     tag.extents(extents);
188     CPPUNIT_ASSERT(tag.extents() == true);
189     tag.extents(none);
190     CPPUNIT_ASSERT(tag.extents() == false);
191 }
192 void BaseTestMultiTag::testPositions() {
193     CPPUNIT_ASSERT_THROW(tag.positions("wrong_data_array_id"), std::runtime_error);
194     CPPUNIT_ASSERT_THROW(tag.positions(""), EmptyString);
195     tag.positions(positions);
196     CPPUNIT_ASSERT(tag.positionCount() == positions.dataExtent()[0]);
197     CPPUNIT_ASSERT(tag.positions().id() == positions.id());
198     CPPUNIT_ASSERT(tag.hasPositions());
199     block.deleteDataArray(positions.id());
200     CPPUNIT_ASSERT_THROW(tag.positions(), std::runtime_error);
201 }
202 void BaseTestMultiTag::testPositionExtents() {
203     tag.extents(extents);
204     CPPUNIT_ASSERT(tag.extents().id() == extents.id());
205     block.deleteDataArray(extents.id());
206     CPPUNIT_ASSERT(!tag.extents());
207     extents = block.createDataArray("extents_DataArray", "dataArray",
208                                     DataType::Double, {0, 0});
209     typedef boost::multi_array&lt;double, 2&gt; array_type;
210     typedef array_type::index index;
211     array_type B(boost::extents[5][5]);
212     for(index i = 0; i &lt; 5; ++i){
213         B[i][i] = 100.0*i;
214     }
215     extents.setData(B);
216     array_type A(boost::extents[10][10]);
217     for(index i = 0; i &lt; 10; ++i){
218         A[i][i] = 100.0*i;
219     }
220     positions.setData(A);
221     tag.positions(positions);
222     CPPUNIT_ASSERT_THROW(tag.extents(extents), std::runtime_error);
223     tag.extents(none);
224     CPPUNIT_ASSERT(tag.extents() == false);
225 }
226 void BaseTestMultiTag::testDataAccess() {
227     DataArray data_array = block.createDataArray("dimensionTest",
228                                        "test",
229                                        DataType::Double,
230                                        NDSize({0, 0, 0}));
231     double samplingInterval = 1.0;
232     std::vector&lt;double&gt; ticks {1.2, 2.3, 3.4, 4.5, 6.7};
233     std::string unit = "ms";
234     typedef boost::multi_array&lt;double, 3&gt; array_type;
235     typedef array_type::index index;
236     array_type data(boost::extents[2][10][5]);
237     int value;
238     for(index i = 0; i != 2; ++i) {
239         value = 0;
240         for(index j = 0; j != 10; ++j) {
241             for(index k = 0; k != 5; ++k) {
242                 data[i][j][k] = value++;
243             }
244         }
245     }
246     data_array.setData(data);
247     SetDimension setDim = data_array.appendSetDimension();
248     std::vector&lt;std::string&gt; labels = {"label_a", "label_b"};
249     setDim.labels(labels);
250     SampledDimension sampledDim = data_array.appendSampledDimension(samplingInterval);
251     sampledDim.unit(unit);
252     RangeDimension rangeDim = data_array.appendRangeDimension(ticks);
253     rangeDim.unit(unit);
254     typedef boost::multi_array&lt;double, 2&gt; position_type;
255     position_type event_positions(boost::extents[2][3]);
256     position_type event_extents(boost::extents[2][3]);
257     event_positions[0][0] = 0.0;
258     event_positions[0][1] = 3.0;
259     event_positions[0][2] = 3.4;
260     event_extents[0][0] = 0.0;
261     event_extents[0][1] = 6.0;
262     event_extents[0][2] = 2.3;
263     event_positions[1][0] = 0.0;
264     event_positions[1][1] = 8.0;
265     event_positions[1][2] = 2.3;
266     event_extents[1][0] = 0.0;
267     event_extents[1][1] = 3.0;
268     event_extents[1][2] = 2.0;
269     std::vector&lt;std::string&gt; event_labels = {"event 1", "event 2"};
270     std::vector&lt;std::string&gt; dim_labels = {"dim 0", "dim 1", "dim 2"};
271     DataArray event_array = block.createDataArray("positions", "test",
272                                                   DataType::Double, NDSize({ 0, 0 }));
273     event_array.setData(event_positions);
274     SetDimension event_set_dim;
275     event_set_dim = event_array.appendSetDimension();
276     event_set_dim.labels(event_labels);
277     event_set_dim = event_array.appendSetDimension();
278     event_set_dim.labels(dim_labels);
279     DataArray extent_array = block.createDataArray("extents", "test",
280                                                    DataType::Double, NDSize({ 0, 0 }));
281     extent_array.setData(event_extents);
282     SetDimension extent_set_dim;
283     extent_set_dim = extent_array.appendSetDimension();
284     extent_set_dim.labels(event_labels);
285     extent_set_dim = extent_array.appendSetDimension();
286     extent_set_dim.labels(dim_labels);
287     MultiTag multi_tag = block.createMultiTag("multi_tag", "events", event_array);
288     multi_tag.extents(extent_array);
289     multi_tag.addReference(data_array);
290     CPPUNIT_ASSERT_THROW(multi_tag.taggedData(0, -1), nix::OutOfBounds);
291     CPPUNIT_ASSERT_THROW(multi_tag.taggedData(0, 1), nix::OutOfBounds);
292     CPPUNIT_ASSERT_THROW(multi_tag.taggedData(-1, 0), nix::OutOfBounds);
293     CPPUNIT_ASSERT_THROW(multi_tag.taggedData(10, 0), nix::OutOfBounds);
294     DataView ret_data = multi_tag.taggedData(0, 0);
295     NDSize data_size = ret_data.dataExtent();
296     CPPUNIT_ASSERT(data_size.size() == 3);
297     CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 6 &amp;&amp; data_size[2] == 2);
298     ret_data = multi_tag.taggedData(0, data_array.name());
299     data_size = ret_data.dataExtent();
300     CPPUNIT_ASSERT(data_size.size() == 3);
301     CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 6 &amp;&amp; data_size[2] == 2);
302     CPPUNIT_ASSERT_THROW(multi_tag.taggedData(1, 0), nix::OutOfBounds);
303     block.deleteMultiTag(multi_tag);
304     block.deleteDataArray(data_array);
305     block.deleteDataArray(event_array);
306     block.deleteDataArray(event_array);
307 }
308 void BaseTestMultiTag::testMetadataAccess() {
309     CPPUNIT_ASSERT(!tag.metadata());
310     tag.metadata(section);
311     CPPUNIT_ASSERT(tag.metadata());
312     CPPUNIT_ASSERT(tag.metadata().id() == section.id());
313     tag.metadata(none);
314     CPPUNIT_ASSERT(!tag.metadata());
315     tag.metadata(section);
316     file.deleteSection(section.id());
317     CPPUNIT_ASSERT(!tag.metadata());
318     section = file.createSection("foo_section", "metadata");
319 }
320 void BaseTestMultiTag::testSourceAccess(){
321     std::vector&lt;std::string&gt; names = { "source_a", "source_b", "source_c", "source_d", "source_e" };
322     CPPUNIT_ASSERT(tag.sourceCount() == 0);
323     CPPUNIT_ASSERT(tag.sources().size() == 0);
324     std::vector&lt;std::string&gt; ids;
325     for (auto it = names.begin(); it != names.end(); it++) {
326         Source child_source = block.createSource(*it,"channel");
327         tag.addSource(child_source);
328         CPPUNIT_ASSERT(child_source.name() == *it);
329         ids.push_back(child_source.id());
330     }
331     CPPUNIT_ASSERT(tag.sourceCount() == names.size());
332     CPPUNIT_ASSERT(tag.sources().size() == names.size());
333     std::string name = names[0];
334     Source source = tag.getSource(name);
335     CPPUNIT_ASSERT(source.name() == name);
336     for (auto it = ids.begin(); it != ids.end(); it++) {
337         Source child_source = tag.getSource(*it);
338         CPPUNIT_ASSERT(tag.hasSource(*it) == true);
339         CPPUNIT_ASSERT(child_source.id() == *it);
340         tag.removeSource(*it);
341         block.deleteSource(*it);
342     }
343     CPPUNIT_ASSERT(tag.sourceCount() == 0);
344     CPPUNIT_ASSERT(tag.sources().size() == 0);
345 }
346 void BaseTestMultiTag::testOperators() {
347     CPPUNIT_ASSERT(tag_null == false);
348     CPPUNIT_ASSERT(tag_null == none);
349     CPPUNIT_ASSERT(tag != false);
350     CPPUNIT_ASSERT(tag != none);
351     CPPUNIT_ASSERT(tag == tag);
352     CPPUNIT_ASSERT(tag != tag_other);
353     tag_other = tag;
354     CPPUNIT_ASSERT(tag == tag_other);
355     tag_other = none;
356 <a name="1"></a>    CPPUNIT_ASSERT(tag_other == false);
357     CPPUNIT_ASSERT(tag_other == none);
358 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    std::stringstream str1, str2;
359     str1 &lt;&lt; "MultiTag: {name = " &lt;&lt; tag.name();
360     str1 &lt;&lt; ", type = " &lt;&lt; tag.type();
361     str1 &lt;&lt; ", id = " &lt;&lt; tag.id() &lt;&lt; "}";
362     str2 &lt;&lt; tag;
363     CPPUNIT_ASSERT(str1.str() == str2.str());
364 }
365 void BaseTestMultiTag::testCreatedAt() {
366     CPPUNIT_ASSERT(tag.createdAt() &gt;= startup_time);
367     time_t past_time = time(NULL) - 10000000;
368     tag.forceCreatedAt(past_time);
369     CPPUNIT_ASSERT(tag.createdAt() == past_time);
370 }
371 void BaseTestMultiTag::testUpdatedAt() {
372     CPPUNIT_ASSERT(tag.updatedAt() &gt;= startup_time);
373 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
