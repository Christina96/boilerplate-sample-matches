
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.208588957055215%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssqldm.cpp</h3>
            <pre><code>1  #include "sqldm.h"
2  void TSqlDmChDef::SetUcCh(const TStr& Str){
3    for (int CC=1; CC<Str.Len(); CC++){
4      uchar Ch=Str[CC];
5      UcChV[Ch]=Str[0];
6    }
7  }
8  void TSqlDmChDef::SetChTy(const TSqlDmChTy& ChTy, const TStr& Str){
9    for (int CC=0; CC<Str.Len(); CC++){
10      uchar Ch=Str[CC];
11      ChTyV[Ch]=ChTy;
12    }
13  }
14  TSqlDmChDef::TSqlDmChDef():
15    ChTyV(TUCh::Vals), UcChV(TUCh::Vals){
16    ChTyV.PutAll(TInt(dmctUndef));
17    SetChTy(dmctLetter, "ABCDEFGHIJKLMNOPQRSTUVWXYZ_");
18    SetChTy(dmctLetter, "abcdefghijklmnopqrstuvwxyz");
19    SetChTy(dmctDigit, "0123456789");
20    SetChTy(dmctSpace, " \t\r\n");
21    SetChTy(dmctEof, TCh::EofCh);
22    for (int Ch=0; Ch<=TUCh::Mx; Ch++){UcChV[Ch]=uchar(Ch);}
23    SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("Dd"); SetUcCh("Ee");
24    SetUcCh("Ff"); SetUcCh("Gg"); SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj");
25    SetUcCh("Kk"); SetUcCh("Ll"); SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo");
26    SetUcCh("Pp"); SetUcCh("Qq"); SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("Tt");
27    SetUcCh("Uu"); SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy");
28    SetUcCh("Zz");
29  }
30  TStrIntH TSqlDmLxSymStr::RwStrToSymH;
31  void TSqlDmLxSymStr::InitRwStrToSymH(){
32    AddRw("create", dsyRw_Create);
33    AddRw("insert", dsyRw_Insert);
34    AddRw("select", dsyRw_Select);
35    AddRw("delete", dsyRw_Delete);
36    AddRw("drop", dsyRw_Drop);
37    AddRw("rename", dsyRw_Rename);
38    AddRw("mining", dsyRw_Mining);
39    AddRw("model", dsyRw_Model);
40    AddRw("using", dsyRw_Using);
41    AddRw("into", dsyRw_Into);
42    AddRw("column_values", dsyRw_ColumnValues);
43    AddRw("content", dsyRw_Content);
44    AddRw("from", dsyRw_From);
45    AddRw("predict", dsyRw_Predict);
46    AddRw("prediction", dsyRw_Prediction);
47    AddRw("join", dsyRw_Join);
48    AddRw("on", dsyRw_On);
49    AddRw("natural", dsyRw_Natural);
50    AddRw("where", dsyRw_Where);
51    AddRw("flattened", dsyRw_Flattened);
52    AddRw("distinct", dsyRw_Distinct);
53    AddRw("union", dsyRw_Union);
54    AddRw("pmml", dsyRw_Pmml);
55    AddRw("or", dsyRw_Or);
56    AddRw("and", dsyRw_And);
57    AddRw("not", dsyRw_Not);
58    AddRw("long", dsyRw_Long);
59    AddRw("boolean", dsyRw_Boolean);
60    AddRw("text", dsyRw_Text);
61    AddRw("nvarchar", dsyRw_Text);
62    AddRw("ntext", dsyRw_Text);
63    AddRw("double", dsyRw_Double);
64    AddRw("date", dsyRw_Date);
65    AddRw("table", dsyRw_Table);
66    AddRw("normal", dsyRw_Normal);
67    AddRw("uniform", dsyRw_Uniform);
68    AddRw("model_existence_only", dsyRw_Binary);
69    AddRw("null", dsyRw_Null);
70    AddRw("discrete", dsyRw_Discrete);
71    AddRw("continuous", dsyRw_Continuous);
72    AddRw("ordered", dsyRw_Ordered);
73    AddRw("sequence_time", dsyRw_SeqTime);
74    AddRw("cyclical", dsyRw_Cyclical);
75    AddRw("discretized", dsyRw_Discretized);
76    AddRw("automatic", dsyRw_Automatic);
77    AddRw("eqal_areas", dsyRw_EqualAreas);
78    AddRw("tresholds", dsyRw_Thresholds);
79    AddRw("clusters", dsyRw_Clusters);
80    AddRw("key", dsyRw_Key);
81    AddRw("probability", dsyRw_Probability);
82    AddRw("variance", dsyRw_Variance);
83    AddRw("stdev", dsyRw_StDev);
84    AddRw("stddev", dsyRw_StDev);
85    AddRw("probability_variance", dsyRw_ProbabilityVariance);
86    AddRw("probability_stdev", dsyRw_ProbabilityStDev);
87    AddRw("probability_stddev", dsyRw_ProbabilityStDev);
88    AddRw("support", dsyRw_Support);
89    AddRw("skip", dsyRw_Skip);
90    AddRw("predictstdev", dsyRw_PredictStDev);
91    AddRw("predictstddev", dsyRw_PredictStDev);
92    AddRw("predictvariance", dsyRw_PredictVariance);
93    AddRw("predictsupport", dsyRw_PredictSupport);
94    AddRw("predictprobability", dsyRw_PredictProbability);
95    AddRw("predictadjustedprobability", dsyRw_PredictAdjustedProbability);
96    AddRw("predictprobabilitystdev", dsyRw_PredictProbabilityStDev);
97    AddRw("predictprobabilitystddev", dsyRw_PredictProbabilityStDev);
98    AddRw("predictprobabilityvariance", dsyRw_PredictProbabilityVariance);
99    AddRw("predicthistogram", dsyRw_PredictHistogram);
100    AddRw("$support", dsyRw_HSupport);
101    AddRw("$variance", dsyRw_HVariance);
102    AddRw("$stdev", dsyRw_HStDev);
103    AddRw("$probability", dsyRw_HProbability);
104    AddRw("$adjustedprobability", dsyRw_HAdjustedProbability);
105    AddRw("$probabilityvariance", dsyRw_HProbabilityVariance);
106    AddRw("$probabilitystdev", dsyRw_HProbabilityStDev);
107    AddRw("$distance", dsyRw_HDistance);
108    AddRw("predict_only", dsyRw_PredictOnly);
109    AddRw("related", dsyRw_Related);
110    AddRw("to", dsyRw_To);
111    AddRw("of", dsyRw_Of);
112    AddRw("openrowset", dsyRw_OpenQuery);
113    AddRw("cluster", dsyRw_Cluster);
114    AddRw("clusterdistance", dsyRw_ClusterDistance);
115    AddRw("clusterprobability", dsyRw_ClusterProbability);
116    AddRw("as", dsyRw_As);
117    AddRw("shape", dsyRw_Shape);
118    AddRw("append", dsyRw_Append);
119    AddRw("relate", dsyRw_Relate);
120    AddRw("exclude_null", dsyRw_ExcludeNull);
121    AddRw("include_null", dsyRw_IncludeNull);
122    AddRw("exclusive", dsyRw_Exclusive);
123    AddRw("inclusive", dsyRw_Inclusive);
124    AddRw("input_only", dsyRw_InputOnly);
125    AddRw("include_statistics", dsyRw_IncludeStatistics);
126    AddRw("topcount", dsyRw_TopCount);
127    AddRw("topsum", dsyRw_TopSum);
128    AddRw("toppercent", dsyRw_TopPercent);
129    AddRw("bottomcount", dsyRw_BottomCount);
130    AddRw("bottomsum", dsyRw_BottomSum);
131    AddRw("bottompercent", dsyRw_BottomPercent);
132    AddRw("rangemin", dsyRw_RangeMin);
133    AddRw("rangemid", dsyRw_RangeMid);
134    AddRw("rangemax", dsyRw_RangeMax);
135  }
136  TSqlDmLxSym TSqlDmLxSymStr::GetRwSym(const TStr& RwStr){
137    if (RwStrToSymH.Empty()){InitRwStrToSymH();}
138    TInt SymInt;
139    if (RwStrToSymH.IsKeyGetDat(RwStr, SymInt)){
140      TSqlDmLxSym Sym=TSqlDmLxSym(SymInt.Val);
141      return Sym;
142    } else {
143      return dsyUndef;
144    }
145  }
146  TStr TSqlDmLxSymStr::GetRwStr(const TSqlDmLxSym& Sym){
147    for (int RwN=0; RwN<RwStrToSymH.Len(); RwN++){
148      TSqlDmLxSym RwSym=TSqlDmLxSym(int(RwStrToSymH[RwN]));
149      if (Sym==RwSym){
150        TStr RwStr=RwStrToSymH.GetKey(RwN);
151        return RwStr;
152      }
153    }
154    Fail; return TStr::NullStr;
155  }
156  TStr TSqlDmLxSymStr::GetSymStr(const TSqlDmLxSym& Sym){
157    switch (Sym){
158      case dsyUndef: return "<Undef>";
159      case dsyEof: return "<Eof>";
160      case dsyName: return "<Name>";
161      case dsyStr: return "<String>";
162      case dsyInt: return "<Int>";
163      case dsyFlt: return "<Float>";
164      case dsyComma: return ",";
165      case dsyPeriod: return ".";
166      case dsySemicolon: return ";";
167      case dsyLss: return "<";
168      case dsyLEq: return "<=";
169      case dsyEq: return "=";
170      case dsyNEq: return "<>";
171      case dsyGtr: return ">";
172      case dsyGEq: return ">=";
173      case dsyPlus: return "+";
174      case dsyMinus: return "-";
175      case dsyAsterisk: return "*";
176      case dsySlash: return "/";
177      case dsyLParen: return "(";
178      case dsyRParen: return ")";
179      case dsyLBrace: return "{";
180      case dsyRBrace: return "}";
181      default: return GetRwStr(Sym);
182    }
183  }
184  TSqlDmLxSymSt::TSqlDmLxSymSt():
185    Sym(dsyUndef), Str(), UcStr(), Int(0), Flt(0),
186    SymLnN(-1), SymLnChN(-1), SymChN(-1){}
187  TSqlDmLxSymSt::TSqlDmLxSymSt(const TSqlDmLxSymSt& SymSt):
188    Sym(SymSt.Sym),
189    Str(SymSt.Str), UcStr(SymSt.UcStr), Int(SymSt.Int), Flt(SymSt.Flt),
190    SymLnN(SymSt.SymLnN), SymLnChN(SymSt.SymLnChN), SymChN(SymSt.SymChN){Fail;}
191  TSqlDmLxSymSt::TSqlDmLxSymSt(TSqlDmLx& Lx):
192    Sym(Lx.Sym), Str(Lx.Str), UcStr(Lx.UcStr), Int(Lx.Int), Flt(Lx.Flt),
193    SymLnN(Lx.SymLnN), SymLnChN(Lx.SymLnChN), SymChN(Lx.SymChN){}
194  void TSqlDmLxSymSt::Restore(TSqlDmLx& Lx){
195    Lx.Sym=Sym; Lx.Str=Str; Lx.UcStr=UcStr; Lx.Int=Int; Lx.Flt=Flt;
196    Lx.SymLnN=SymLnN; Lx.SymLnChN=SymLnChN; Lx.SymChN=Lx.SymChN;}
197  TSqlDmChDef TSqlDmLx::ChDef;
198  uchar TSqlDmLx::GetCh(){
199    IAssert(Ch!=TCh::EofCh);
200    PrevCh=Ch;
201    if (ChStack.Empty()){Ch=(SIn->Eof()) ? TCh::EofCh : SIn->GetCh();}
202    else {Ch=ChStack.Pop();}
203    ChN++; if (Ch==TCh::LfCh){LnN++; LnChN=0;} else {LnChN++;}
204    printf("%c", Ch);
205    return Ch;
206  }
207  TSqlDmLx::TSqlDmLx(const PSIn& _SIn):
208    SIn(_SIn),
209    ChStack(), PrevCh(' '), Ch(' '),
210    LnN(0), LnChN(0-1), ChN(0-1),
211    PrevSymStStack(),
212    Sym(dsyUndef), Str(), UcStr(), Int(0), Flt(0),
213    SymLnN(-1), SymLnChN(-1), SymChN(-1){
214  }
215  TStr TSqlDmLx::GetFPosStr() const {
216    TChA ChA;
217    ChA+="File:"; ChA+=SIn->GetSNm();
218    ChA+=" Line:"; ChA+=TInt::GetStr(LnN+1);
219    ChA+=" Char:"; ChA+=TInt::GetStr(LnChN);
220    return ChA;
221  }
222  TSqlDmLxSym TSqlDmLx::GetSym(const TFSet& Expect){
223    if (!PrevSymStStack.Empty()){
224      PrevSymStStack.Top().Restore(*this); PrevSymStStack.Pop();
225    } else {
226      while (ChDef.IsSpace(Ch)){GetCh();}
227      SymLnN=LnN; SymLnChN=LnChN; SymChN=ChN;
228      if (ChDef.IsAlpha(Ch)){ 
229        Str.Clr(); UcStr.Clr();
230        do {Str.AddCh(Ch); UcStr.AddCh(ChDef.GetUc(Ch));}
231        while (ChDef.IsAlNum(GetCh()));
232        Sym=TSqlDmLxSymStr::GetRwSym(UcStr);
233        if (Sym==dsyUndef){Sym=dsyName;}
234      } else
235      if (Ch=='['){ 
236        Str.Clr(); UcStr.Clr(); GetCh();
237        while ((Ch!=']')&&(Ch!=TCh::EofCh)){
238          Str.AddCh(Ch); UcStr.AddCh(ChDef.GetUc(Ch)); GetCh();}
239        if (Ch==TCh::EofCh){Sym=dsyUndef;}
240        else {Sym=dsyName; GetCh();}
241      } else
242      if (Ch=='\''){ 
243        Str.Clr(); UcStr.Clr(); GetCh();
244        while ((Ch!='\'')&&(Ch!=TCh::EofCh)){
245          Str.AddCh(Ch); UcStr.AddCh(ChDef.GetUc(Ch)); GetCh();}
246        if (Ch==TCh::EofCh){Sym=dsyUndef;}
247        else {Sym=dsyStr; GetCh();}
248      } else
249      if (ChDef.IsNum(Ch)){ 
250        Str.Clr();
251        do {Str.AddCh(Ch);} while (ChDef.IsNum(GetCh()));
252        if (Ch=='.'){
253          Str.AddCh(Ch);
254          while (ChDef.IsNum(GetCh())){Str.AddCh(Ch);}
255        }
256        if ((Ch=='e')||(Ch=='E')){
257          Str.AddCh(Ch); GetCh();
258          if ((Ch=='+')||(Ch=='-')){Str.AddCh(Ch); GetCh();}
259          while (ChDef.IsNum(Ch)){Str.AddCh(Ch); GetCh();}
260        }
261        UcStr=Str;
262        if (Expect.In(syFlt)){Sym=dsyFlt; Flt=atof(Str.CStr());}
263        else {Sym=dsyInt; Int=atoi(Str.CStr());}
264      } else
265      if (Ch=='/'){ 
266        GetCh();
267        if (Ch=='/'){
268          do {GetCh();} while (!ChDef.IsEof(Ch));
269          if (Ch==TCh::CrCh){
270            if (GetCh()==TCh::LfCh){GetCh();}
271          } else
272          if (Ch==TCh::LfCh){
273            if (GetCh()==TCh::CrCh){GetCh();}
274          }
275          GetSym(Expect);
276        } else
277        if (Ch=='*'){
278          do {while (GetCh()!='*'){}} while (GetCh()!='/');
279          GetCh(); GetSym(Expect);
280        } else {
281          Sym=dsySlash;
282        }
283      } else
284      if (Ch=='-'){ 
285        GetCh();
286        if (Ch=='-'){
287          do {GetCh();} while (!ChDef.IsEof(Ch));
288          if (Ch==TCh::CrCh){
289            if (GetCh()==TCh::LfCh){GetCh();}
290          } else
291          if (Ch==TCh::LfCh){
292            if (GetCh()==TCh::CrCh){GetCh();}
293          }
294          GetSym(Expect);
295        } else {
296          Sym=dsyMinus;
297        }
298      } else
299      if (Ch==TCh::EofCh){ 
300        Sym=dsyEof;
301      } else { 
302        switch (Ch){
303          case ',': Sym=dsyComma; GetCh(); break;
304          case '.':
305            if (ChDef.IsNum(GetCh())){
306              PutCh('.'); PutCh('0'); return GetSym(Expect);}
307            else {Sym=dsyPeriod;}
308            break;
309          case ';': Sym=dsySemicolon; GetCh(); break;
310          case '<':
311            GetCh();
<span onclick='openModal()' class='match'>312            if (Ch=='='){Sym=dsyLEq; GetCh();}
313            else if (Ch=='>'){Sym=dsyNEq; GetCh();}
</span>314            else {Sym=dsyLss;} break;
315          case '=': Sym=dsyEq; GetCh(); break;
316          case '>':
317            if (GetCh()=='='){Sym=dsyGEq; GetCh();}
318            else {Sym=dsyGtr;} break;
319          case '+': Sym=dsyPlus; GetCh(); break;
320          case '-': Sym=dsyMinus; GetCh(); break;
321          case '*': Sym=dsyAsterisk; GetCh(); break;
322          case '/': Sym=dsySlash; GetCh(); break;
323          case '(': Sym=dsyLParen; GetCh(); break;
324          case ')': Sym=dsyRParen; GetCh(); break;
325          case '{': Sym=dsyLBrace; GetCh(); break;
326          case '}': Sym=dsyRBrace; GetCh(); break;
327          default: Sym=dsyUndef; GetCh(); break;
328        }
329      }
330    }
331    if ((!Expect.In(Sym))&&(!Expect.Empty())){
332     TStr MsgStr=
333      TStr("Unexpected symbol (")+Str+") ["+GetFPosStr()+"]";
334     throw TExcept::Throw(MsgStr);
335    }
336    return Sym;
337  }
338  PSqlDmStat_Delete TSqlDmStat_Delete::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
339    PSqlDmStat_Delete Stat=TSqlDmStat_Delete::New();
340    IAssert(Lx.Sym==dsyRw_Delete);
341    Lx.GetSym(dsyAsterisk);
342    Lx.GetSym(dsyRw_From);
343    Stat->MdNm=Lx.GetName();
344    Lx.GetSym(TFSet(Expect)|dsyPeriod);
345    if (Lx.Sym==dsyPeriod){
346      Lx.GetSym(dsyRw_Content); Stat->ContentP=false;
347      Lx.GetSym(Expect);
348    } else {
349      Stat->ContentP=false;
350    }
351    return Stat;
352  }
353  PSqlDmStat_Drop TSqlDmStat_Drop::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
354    PSqlDmStat_Drop Stat=TSqlDmStat_Drop::New();
355    IAssert(Lx.Sym==dsyRw_Drop);
356    Lx.GetSym(dsyRw_Mining);
357    Lx.GetSym(dsyRw_Model);
358    Stat->MdNm=Lx.GetName();
359    Lx.GetSym(Expect);
360    return Stat;
361  }
362  PSqlDmStat_Rename TSqlDmStat_Rename::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
363    PSqlDmStat_Rename Stat=TSqlDmStat_Rename::New();
364    IAssert(Lx.Sym==dsyRw_Rename);
365    Lx.GetSym(dsyRw_Mining);
366    Lx.GetSym(dsyRw_Model);
367    Stat->SrcMdNm=Lx.GetName();
368    Lx.GetSym(dsyRw_To);
369    Stat->DstMdNm=Lx.GetName();
370    Lx.GetSym(Expect);
371    return Stat;
372  }
373  const TFSet TSqlDmStat::StatExpect(
374   dsyRw_Create, dsyRw_Insert, dsyRw_Select,
375   dsyRw_Delete, dsyRw_Drop, dsyRw_Rename);
376  PSqlDmStat TSqlDmStat::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
377    PSqlDmStat Stat=TSqlDmStat::New();
378    switch (Lx.Sym){
379      case dsyRw_Create: break;
380      case dsyRw_Insert: break;
381      case dsyRw_Select: break;
382      case dsyRw_Delete:
383        Stat->Type=dstDelete;
384        Stat->Delete=TSqlDmStat_Delete::LoadTxt(Lx, Expect);
385        break;
386      case dsyRw_Drop:
387        Stat->Type=dstDrop;
388        Stat->Drop=TSqlDmStat_Drop::LoadTxt(Lx, Expect);
389        break;
390      case dsyRw_Rename:
391        Stat->Type=dstRename;
392        Stat->Rename=TSqlDmStat_Rename::LoadTxt(Lx, Expect);
393        break;
394      default: Fail;
395    }
396    return Stat;
397  }
398  PSqlDmProg TSqlDmProg::LoadTxt(PSIn& SIn){
399    PSqlDmProg Prog=TSqlDmProg::New();
400    TSqlDmLx Lx(SIn);
401    Lx.GetSym(TFSet(TSqlDmStat::StatExpect)|dsyEof);
402    while (Lx.Sym!=dsyEof){
403      PSqlDmStat Stat=TSqlDmStat::LoadTxt(Lx, TFSet(dsySemicolon, dsyEof));
404      Prog->StatV.Add(Stat);
405      Lx.GetSym(TFSet(TSqlDmStat::StatExpect)|dsyEof);
406    }
407    return Prog;
408  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</h3>
            <pre><code>1  void TGUtil::GetCdf(const TIntPrV& PdfV, TIntPrV& CdfV) {
2    CdfV = PdfV;
3    for (int i = 1; i < CdfV.Len(); i++) {
4      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
5  }
6  void TGUtil::GetCdf(const TFltPrV& PdfV, TFltPrV& CdfV) {
7    CdfV = PdfV;
8    for (int i = 1; i < CdfV.Len(); i++) {
9      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
10  }
11  void TGUtil::GetCdf(const TIntFltKdV& PdfV, TIntFltKdV& CdfV) {
12    CdfV = PdfV;
13    for (int i = 1; i < CdfV.Len(); i++) {
14      CdfV[i].Dat = CdfV[i-1].Dat + CdfV[i].Dat; }
15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV& PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV& PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV& PdfV, TIntPrV& CCdfV) {
27    CCdfV = PdfV;
28    for (int i = CCdfV.Len()-2; i >= 0; i--) {
29      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
30  }
31  void TGUtil::GetCCdf(const TFltPrV& PdfV, TFltPrV& CCdfV) {
32    CCdfV = PdfV;
33    for (int i = CCdfV.Len()-2; i >= 0; i--) {
34      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
35  }
36  void TGUtil::GetCCdf(const TIntFltKdV& PdfV, TIntFltKdV& CCdfV) {
37    CCdfV = PdfV;
38    for (int i = CCdfV.Len()-2; i >= 0; i--) {
39      CCdfV[i].Dat = CCdfV[i+1].Dat + CCdfV[i].Dat; }
40  }
41  TIntPrV TGUtil::GetCCdf(const TIntPrV& PdfV) {
42    TIntPrV CCdfV;
43    GetCCdf(PdfV, CCdfV);
44    return CCdfV;
45  }
46  TFltPrV TGUtil::GetCCdf(const TFltPrV& PdfV) {
47    TFltPrV CCdfV;
48    GetCCdf(PdfV, CCdfV);
49    return CCdfV;
50  }
51  void TGUtil::GetPdf(const TIntPrV& CdfV, TIntPrV& PdfV) {
52    PdfV = CdfV;
53    for (int i = PdfV.Len()-1; i > 0; i--) {
54      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
55  }
56  void TGUtil::GetPdf(const TFltPrV& CdfV, TFltPrV& PdfV) {
57    PdfV = CdfV;
58    for (int i = PdfV.Len()-1; i > 0; i--) {
59      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
60  }
61  void TGUtil::GetPdf(const TIntFltKdV& CdfV, TIntFltKdV& PdfV) {
62    PdfV = CdfV;
63    for (int i = PdfV.Len()-1; i > 0; i--) {
64      PdfV[i].Dat = PdfV[i].Dat - PdfV[i-1].Dat; }
65  }
66  void TGUtil::Normalize(TFltPrV& PdfV) {
67    double Sum = 0.0;
68    for (int i = 0; i < PdfV.Len(); i++) {
69      Sum += PdfV[i].Val2; }
70    if (Sum <= 0.0) { return; }
71    for (int i = 0; i < PdfV.Len(); i++) {
72      PdfV[i].Val2 /= Sum; }
73  }
74  void TGUtil::Normalize(TIntFltKdV& PdfV) {
75    double Sum = 0.0;
76    for (int i = 0; i < PdfV.Len(); i++) {
77      Sum += PdfV[i].Dat; }
78    if (Sum <= 0.0) { return; }
79    for (int i = 0; i < PdfV.Len(); i++) {
80      PdfV[i].Dat /= Sum; }
81  }
82  void TGUtil::MakeExpBins(const TFltPrV& XYValV, TFltPrV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
83    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
84  }
85  void TGUtil::MakeExpBins(const TFltKdV& XYValV, TFltKdV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
86    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
87  }
88  void TGUtil::MakeExpBins(const TFltV& YValV, TFltV& ExpYValV, const double& BinFactor) {
89    ExpYValV.Clr(true);
90    int prevI=0;
91    for (int i = 0; i < YValV.Len(); ) {
92      ExpYValV.Add(YValV[i]);
93      i = int(i*BinFactor);
94      if (i==prevI) { i++; }
95      prevI = i;
96    }
97  }
98  void TGUtil::MakeExpBins(const TIntV& YValV, TIntV& ExpYValV, const double& BinFactor) {
99    ExpYValV.Clr(true);
100    int prevI=0;
101    for (int i = 0; i < YValV.Len(); ) {
102      ExpYValV.Add(YValV[i]);
103      i = int(i*BinFactor);
104      if (i==prevI) { i++; }
105      prevI = i;
106    }
107  }
108  TChA& TStrUtil::GetXmlTagVal(TXmlLx& XmlLx, const TChA& TagNm) {
109    static TChA TagVal;
110    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
111    EAssertR(TagNm == XmlLx.TagNm.CStr(), TagNm);
112    const TXmlLxSym NextSym = XmlLx.GetSym();
113    TagVal = XmlLx.TxtChA;
114    if (NextSym == xsyStr) {
115      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
116    } else {
117      EAssertR(NextSym == xsyETag, TagNm); 
118    }
119    EAssertR(XmlLx.TagNm == TagNm, TagNm);
120    return TagVal;
121  }
122  void TStrUtil::GetXmlTagNmVal(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal) {
123    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
124    TagNm = XmlLx.TagNm;
125    const TXmlLxSym NextSym = XmlLx.GetSym();
126    TagVal = XmlLx.TxtChA;
127    if (NextSym == xsyStr) {
128      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
129    } else {
130      EAssertR(NextSym == xsyETag, TagNm); 
131    }
132  }
133  bool TStrUtil::GetXmlTagNmVal2(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal, const bool& TakeTagNms) {
134    if (XmlLx.GetSym() != xsySTag) {
135      return false; }
136    TagVal.Clr();
137    TagNm = XmlLx.TagNm;
138    while (XmlLx.Sym != xsyETag || XmlLx.TagNm != TagNm.CStr()) {
<span onclick='openModal()' class='match'>139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
</span>143      XmlLx.GetSym();
144    }
145    return true;
146  }
147  TChA TStrUtil::GetDomNm(const TChA& UrlChA) {
148    int EndSlash = UrlChA.SearchCh('/', 7)-1; 
149    if (EndSlash > 0) {
150      const int BegSlash = UrlChA.SearchChBack('/', EndSlash);
151      if (BegSlash > 0) { return UrlChA.GetSubStr(BegSlash+1, EndSlash).ToLc(); }
152      else { return UrlChA.GetSubStr(0, UrlChA.SearchCh('/', 0)-1).ToLc(); }
153    } else {
154      if (UrlChA.IsPrefix("http:&bsol;&bsol;")) { return UrlChA.GetSubStr(7, UrlChA.Len()-1).ToLc(); }
155      EndSlash = UrlChA.SearchCh('/', 0);
156      if (EndSlash > 0) { return UrlChA.GetSubStr(0, EndSlash-1).ToLc(); }
157      else { return TChA(UrlChA).ToLc(); }
158    }
159  }
160  TChA TStrUtil::GetDomNm2(const TChA& UrlChA) {
161    TChA Dom = GetDomNm(UrlChA);
162    if (Dom.IsPrefix("www.")) { return Dom.GetSubStr(4, TInt::Mx); }
163    else { return Dom; }
164  }
165  int GetNthOccurence(const TChA& Url, const int& Count, const char Ch='/') {
166    const char *c = Url.CStr();
167    int cnt = 0;
168    while (*c && cnt != Count) {
169      if (*c == Ch) { cnt++; }
170      c++;
171    }
172    return int(c-Url.CStr()-1);
173  }
174  TChA TStrUtil::GetWebsiteNm(const TChA& PostUrlStr) {
175    TChA DomNm = TStrUtil::GetDomNm2(PostUrlStr);
176    if (DomNm == "blog.myspace.com") {
177      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 2, '&')-1);
178    }
179    if (DomNm=="blogs.msdn.com" || DomNm=="ameblo.jp" || DomNm=="xfruits.com" || DomNm=="scienceblogs.com" || DomNm=="blogs.sun.com"
180      || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net" || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.co"
181      || DomNm=="blogs.clarin.com" || DomNm=="blogs.sun.com" || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net"
182      || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.com" || DomNm=="blogs.clarin.com" || DomNm=="blogs.zdnet.com"
183      || DomNm=="blogs.citypages.com" || DomNm=="voices.washingtonpost.com" || DomNm=="blog.tv2.dk"
184      || DomNm=="blogs.menomoneefallsnow.com" || DomNm=="weblogs.baltimoresun.com" || DomNm=="eonline.com") {
185        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1);
186    }
187    if (DomNm == "digg.com") {
188      if (PostUrlStr.IsPrefix("http:&bsol;&bsol;digg.com/submit?")) {
189        const int Url = PostUrlStr.SearchStr(";url=");
190        if (Url != -1) {
191          return GetWebsiteNm(PostUrlStr.GetSubStr(Url+5, PostUrlStr.SearchCh('&', Url+5))); }
192      } else {
193        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1); }
194    }
195    if (PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;bbc.co.uk/blogs/")
196      || PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;newsbusters.org/blogs/")) {
197      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
198    }
199    if (DomNm=="feeds.feedburner.com") {
200      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
201    }
202    if (DomNm=="groups.google.com") {
203      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
204    }
205    if (DomNm=="news.google.com") { 
206      const int UrlPos = PostUrlStr.SearchStr("&url=");
207      if (UrlPos != -1) {
208        return GetWebsiteNm(PostUrlStr.GetSubStr(UrlPos+5, PostUrlStr.SearchCh('&', UrlPos+5))); }
209    }
210    if (DomNm == "bloggrevyen.no") { 
211      const int Http2 = PostUrlStr.SearchStr("/http:&bsol;&bsol;");
212      if (Http2!=-1) {
213        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+1, PostUrlStr.Len()-1)); }
214    }
215    if (DomNm.IsSuffix(".rd.yahoo.com")) {
216      const int Http2 = PostUrlStr.SearchStr("&bsol;*");
217      if (Http2!=-1) {
218        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+9, PostUrlStr.Len()-1)); }
219    }
220    return DomNm;
221  }
222  bool TStrUtil::GetNormalizedUrl(const TChA& UrlIn, const TChA& BaseUrl, TChA& UrlOut) {
223    UrlOut = UrlIn;
224    if (StripEnd(UrlIn, "/", UrlOut)) {}
225    else if (StripEnd(UrlIn, "/index.html", UrlOut)) {}
226    else if (StripEnd(UrlIn, "/index.htm", UrlOut)) {}
227    else if (StripEnd(UrlIn, "/index.php", UrlOut)) {}
228    if (! (UrlOut.IsPrefix("http:&bsol;&bsol;") || UrlOut.IsPrefix("ftp:&bsol;&bsol;"))) {
229      if (UrlIn.Empty() || ! (BaseUrl.IsPrefix("http:&bsol;&bsol;") || BaseUrl.IsPrefix("ftp:&bsol;&bsol;"))) {
230        return false; }
231      TChA Out;
232      if (! GetNormalizedUrl(BaseUrl, TChA(), Out)) { return false; }
233      if (UrlIn[0] != '/') { Out.AddCh('/'); }
234      Out += UrlOut;
235      UrlOut = Out;
236    }
237    if (UrlOut.IsPrefix("http:&bsol;&bsol;www.")) {
238      UrlOut = TChA("http:&bsol;&bsol;") + UrlOut.GetSubStr(11, TInt::Mx);
239    }
240    UrlOut.ToLc();
241    return true;
242  }
243  bool TStrUtil::StripEnd(const TChA& Str, const TChA& SearchStr, TChA& NewStr) {
244    const int StrLen = Str.Len();
245    const int SearchStrLen = SearchStr.Len();
246    if (StrLen < SearchStrLen) { return false; }
247    for (int i = 0; i < SearchStrLen; i++) {
248      if (Str[StrLen-i-1] != SearchStr[SearchStrLen-i-1]) { return false; }
249    }
250    NewStr = Str.GetSubStr(0, StrLen-SearchStrLen-1);
251    return true;
252  }
253  TChA TStrUtil::GetShorStr(const TChA& LongStr, const int MaxLen) {
254    if (LongStr.Len() < MaxLen) { return LongStr; }
255    TChA Str = LongStr.GetSubStr(0, MaxLen-1);
256    Str += "...";
257    return Str;
258  }
259  TChA TStrUtil::GetCleanWrdStr(const TChA& ChA) {
260    char *b = (char *) ChA.CStr();
261    while (*b && ! TCh::IsAlNum(*b)) { b++; }
262    if (*b == 0) { return TChA(); }
263    TChA OutChA(ChA.Len());
264    char *e = b, tmp;
265    while (*e) {
266      b = e;
267      while (*e && (TCh::IsAlNum(*e) || ((*e=='\'' || *e=='-') && TCh::IsAlNum(*(e+1))))) { e++; }
268      if (b < e) {
269        tmp = *e; *e=0;
270        OutChA += b;  OutChA.AddCh(' ');
271        *e = tmp;
272      }
273      while (*e && ! TCh::IsAlNum(*e)) { e++; }
274      if (! *e) { break; }
275    }
276    OutChA.DelLastCh();  OutChA.ToLc();
277    return OutChA;
278  }
279  TChA TStrUtil::GetCleanStr(const TChA& ChA) {
280    char *b = (char *) ChA.CStr();
281    while (*b && ! TCh::IsAlNum(*b)) { b++; }
282    if (*b == 0) { return TChA(); }
283    TChA OutChA(ChA.Len());
284    char *e = b;
285    bool ws=false;
286    while (*e) {
287      while (*e && TCh::IsWs(*e)) { e++; ws=true; }
288      if (! *e) { break; }
289      if (ws) { OutChA.AddCh(' '); ws=false; }
290      OutChA.AddCh(*e);
291      e++;
292    }
293    return OutChA;
294  }
295  int TStrUtil::CountWords(const TChA& ChA) {
296    return CountWords(ChA.CStr());
297  }
298  int TStrUtil::CountWords(const char* CStr) {
299    int WrdCnt = 1;
300    for (const char *c = CStr; *c; c++) {
301      if (TCh::IsWs(*c)) { WrdCnt++; }
302    }
303    return WrdCnt;
304  }
305  int TStrUtil::CountWords(const TChA& ChA, const TStrHash<TInt>& StopWordH) {
306    TChA Tmp;
307    TVec<char *> WrdV;
308    SplitWords(Tmp, WrdV);
309    int SWordCnt = 0;
310    for (int w = 0; w < WrdV.Len(); w++) {
311      if (StopWordH.IsKey(WrdV[w])) { SWordCnt++; }
312    }
313    return WrdV.Len() - SWordCnt;
314  }
315  int TStrUtil::SplitWords(TChA& ChA, TVec<char *>& WrdV, const bool& SplitOnWs) {
316    WrdV.Clr(false);
317    WrdV.Add(ChA.CStr());
318    for (char *c = (char *) ChA.CStr(); *c; c++) {
319      if ((SplitOnWs && *c == ' ') || (! SplitOnWs && ! TCh::IsAlNum(*c))) {
320        *c = 0;
321        if (! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
322        WrdV.Add(c+1);
323      }
324    }
325    return WrdV.Len();
326  }
327  int TStrUtil::SplitOnCh(TChA& ChA, TVec<char *>& WrdV, const char& Ch, const bool& SkipEmpty) {
328    WrdV.Clr(false);
329    WrdV.Add(ChA.CStr());
330    for (char *c = (char *) ChA.CStr(); *c; c++) {
331      if (*c == Ch) {
332        *c = 0;
333        if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
334        WrdV.Add(c+1);
335      }
336    }
337    if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
338    return WrdV.Len();
339  }
340  int TStrUtil::SplitLines(TChA& ChA, TVec<char *>& LineV, const bool& SkipEmpty) {
341    LineV.Clr(false);
342    LineV.Add(ChA.CStr());
343    bool IsChs=false;
344    for (char *c = (char *) ChA.CStr(); *c; c++) {
345      if (*c == '\n') {
346        if (c > ChA.CStr() && *(c-1)=='\r') { *(c-1)=0; } 
347        *c=0;
348        if (SkipEmpty) {
349          if (IsChs) { LineV.Add(c+1); }
350        } else {
351          LineV.Add(c+1);
352        }
353        IsChs=false;
354      } else {
355        IsChs=true;
356      }
357    }
358    return LineV.Len();
359  }
360  int TStrUtil::SplitSentences(TChA& ChA, TVec<char *>& SentenceV) {
361    SentenceV.Clr();
362    const char *B = ChA.CStr();
363    const char *E = B+ChA.Len();
364    char *c = (char *) B;
365    while (*c && TCh::IsWs(*c)) { c++; }
366    if (*c) { SentenceV.Add(c); } else { return 0; }
367    for (; c < E; c++) {
368      if (c<E && (*c == '.' || *c == '!' || *c == '?') && ! TCh::IsAlNum(*(c+1))) { 
369        if (c<E && *(c+1)=='"') { *c='"';  c++; } 
370        if (c>=E) { continue; }
371        *c=0;  c++;
372        char *e = c-1;
373        while (e>B && *e!='"' && ! TCh::IsAlNum(*e)) { *e=0; e--; } 
374        while (c<E && ! (TCh::IsAlNum(*c) || (*c=='"' && TCh::IsAlNum(*(c+1))))) { c++; } 
375        if (c<E) { SentenceV.Add(c); }
376      }
377    }
378    return SentenceV.Len();
379  }
380  void TStrUtil::RemoveHtmlTags(const TChA& HtmlStr, TChA& TextStr) {
381    TextStr.Clr();
382    char *StrB, *StrE;
383    StrB = (char *) HtmlStr.CStr();
384    StrE = (char *) StrB+HtmlStr.Len(); 
385    for (char *e = StrB; e < StrE; ) {
386      char* b = e;
387      while (e<StrE && *e != '<') { e++; }
388      char tmp=*e;  *e = 0;
389      TextStr+= b; TextStr.AddCh(' ');  *e = tmp;
390      if (e >= StrE) { return; }
391      if (e[1]=='!' && e[2]=='-' && e[3]=='-') { 
392        e += 3;
393        while(e<StrE && !(*(e-2)=='-' && *(e-1)=='-' && *e=='>')) { e++; }
394        e++;  continue;
395      }
396      if (e[1]=='s' && e[2]=='c' && e[3]=='r' && e[4]=='i' && e[5]=='p' && e[6]=='t') {
397        e += 5;
398        while(e<StrE && !(*(e-6)=='s' && *(e-5)=='c' && *(e-4)=='r' && *(e-3)=='i' && *(e-2)=='p' && *(e-1)=='t' && *e=='>')) { e++; }
399        e++;  continue;
400      }
401      while (e < StrE && *e != '>') { e++; }
402      if (e>=StrE) { return; }
403      e++;
404    }
405  }
406  bool TStrUtil::IsLatinStr(const TChA& Str, const double& MinAlFrac) {
407    int AlNumCnt=0, ChCnt=0;
408    for (const char *c = Str.CStr(); *c; c++) {
409      if (TCh::IsWs(*c)) { continue; }
410      if (*c > 0 && TCh::IsAlNum(*c)) { AlNumCnt++; }
411      ChCnt++;
412    }
413    if (double(AlNumCnt)/double(ChCnt) > MinAlFrac) { return true; }
414    return false;
415  }
416  void TStrUtil::GetWIdV(const TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
417    const int NotWId = -1;
418    TChA ChA(CStr);
419    TVec<char *> WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w < WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
425      else { WIdV.Add(NotWId); }
426    }
427  }
428  void TStrUtil::GetAddWIdV(TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
429    TChA ChA(CStr);
430    TVec<char *> WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w < WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
436    }
437  }
438  bool TStrUtil::GetTmFromStr(const char* TmStr, TSecTm& Tm) {
439    static TStrV MonthV1, MonthV2;
440    if (MonthV1.Empty()) {
441      TStr("january|february|march|april|may|june|july|august|september|october|november|december").SplitOnAllCh('|', MonthV1);
442      TStr("jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec").SplitOnAllCh('|', MonthV2);
443    }
444    TChA Tmp(TmStr);
445    Tmp.ToLc();
446    TVec<char *> WrdV;
447    const char* End = Tmp.CStr()+Tmp.Len();
448    int Col = -1, Cols=0;
449    for (char *b = Tmp.CStr(); b <End; ) {
450      WrdV.Add(b);
451      while (*b && ! (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
452      if (*b==':') { if(Col==-1) { Col=WrdV.Len(); } Cols++;  }
453      *b=0; b++;
454      while (*b && (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
455    }
456    if (Cols == 2) {
457      if (Col+1 >= WrdV.Len()) { return false; }
458      WrdV.Del(Col+1);
459    }
460    if (Col<1) { return false; }
461    const int Hr = atoi(WrdV[Col-1]);
462    const int Min = atoi(WrdV[Col]);
463    WrdV.Del(Col);  WrdV.Del(Col-1);
464    if (WrdV.Len() != 3) { return false; }
465    int y=0,m=1,d=2, Mon=-1;
466    if (TCh::IsAlpha(WrdV[0][0])) {
467      y=2; m=0; d=1;
468    } else if (TCh::IsAlpha(WrdV[1][0])) {
469      y=2; m=1; d=0;
470    } else if (TCh::IsAlpha(WrdV[2][0])) {
471      y=0; m=2; d=1;
472    } else {
473      y=0; m=1; d=2;
474      Mon = atoi(WrdV[m]);
475    }
476    int Day = atoi(WrdV[d]);
477    if (Mon <= 0) { Mon = MonthV1.SearchForw(WrdV[m])+1; }
478    if (Mon <= 0) { Mon = MonthV2.SearchForw(WrdV[m])+1; }
479    if (Mon == 0) { return false; }
480    int Year = atoi(WrdV[y]);
481    if (Day > Year) { ::Swap(Day, Year); }
482    Tm = TSecTm(Year, Mon, Day, Hr, Min, 0);
483    return true;
484  }
485  TStr TStrUtil::GetStdName(TStr AuthorName) {
486    TStr StdName;
487    AuthorName.ToLc();
488    AuthorName.ChangeChAll('\n', ' ');
489    AuthorName.ChangeChAll('.', ' ');
490    int i, pos = 0;
491    while (pos<AuthorName.Len() && (AuthorName[pos]!='#' && !TCh::IsNum(AuthorName[pos]))) {
492      pos++; }
493    if (pos < AuthorName.Len()) {
494      AuthorName = AuthorName.GetSubStr(0, pos-1).ToTrunc(); }
495    if (AuthorName.Empty()) { return TStr::GetNullStr(); }
496    int b = AuthorName.SearchCh('(');
497    if (b != -1) {
498      AuthorName = AuthorName.GetSubStr(0, b-1).ToTrunc(); }
499    if (AuthorName .SearchCh(')')!=-1) { return TStr::GetNullStr(); }
500    if (AuthorName .SearchStr("figures")!=-1 || AuthorName .SearchStr("macros")!=-1
501     || AuthorName .SearchStr("univ")!=-1 || AuthorName .SearchStr("institute")!=-1) {
502      return TStr::GetNullStr();
503    }
504    TChA NewName;
505    for (i = 0; i < AuthorName.Len(); i++) {
506      const char Ch = AuthorName[i];
507      if (TCh::IsAlpha(Ch) || TCh::IsWs(Ch) || Ch=='-') { NewName += Ch; }
508    }
509    StdName = NewName;  StdName.ToTrunc();
510    TStrV AuthNmV; StdName.SplitOnWs(AuthNmV);
511    if (! AuthNmV.Empty() && AuthNmV.Last() == "jr") AuthNmV.DelLast();
512    if (AuthNmV.Len() < 2) return TStr::GetNullStr();
513    const TStr LastNm = AuthNmV.Last();
514    if (! TCh::IsAlpha(LastNm[0]) || LastNm.Len() == 1) return TStr::GetNullStr();
515    IAssert(isalpha(AuthNmV[0][0]));
516    return TStr::Fmt("%s_%c", LastNm.CStr(), AuthNmV[0][0]);
517  }
518  void TStrUtil::GetStdNameV(TStr AuthorNames, TStrV& StdNameV) {
519    AuthorNames.ChangeChAll('\n', ' ');
520    AuthorNames.ToLc();
521    TStrV AuthV, TmpV, Tmp2V;
522    AuthorNames.SplitOnStr(" and ", TmpV);
523    int i;
524    for (i = 0; i < TmpV.Len(); i++) {
525      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
526    TmpV = AuthV;  AuthV.Clr();
527    for (i = 0; i < TmpV.Len(); i++) {
528      TmpV[i].SplitOnAllCh('&', Tmp2V);  AuthV.AddV(Tmp2V); }
529    TmpV = AuthV;  AuthV.Clr();
530    for (i = 0; i < TmpV.Len(); i++) {
531      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
532    TmpV = AuthV;  AuthV.Clr();
533    for (i = 0; i < TmpV.Len(); i++) {
534      TmpV[i].SplitOnAllCh(';', Tmp2V);  AuthV.AddV(Tmp2V); }
535    StdNameV.Clr();
536    for (i = 0; i < AuthV.Len(); i++) {
537      TStr StdName = GetStdName(AuthV[i]);
538      if (! StdName.Empty()) {
539        StdNameV.Add(StdName);
540      }
541    }
542  }
543  double TStopwatch::Tick() {
544  #ifdef USE_OPENMP
545    return omp_get_wtime();
546  #else
547  #ifdef GLib_WIN32
548    return GetTickCount() / 1000.0;
549  #else
550    struct rusage rusage;
551    getrusage(RUSAGE_SELF, &rusage);
552    float cputime =
553    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
554    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
555    return cputime;
556  #endif
557  #endif
558  }
559  void TStopwatch::Start(const TExperiment Exp) {
560    Starts[Exp] = Tick();
561  }
562  void TStopwatch::Stop(const TExperiment Exp) {
563    double Duration = Tick() - Starts[Exp];
564    Sums[Exp] += Duration;
565    Maxs[Exp] = Maxs[Exp] >= Duration ? Maxs[Exp] : Duration;
566    Mins[Exp] = Mins[Exp] <= Duration ? Mins[Exp] : Duration;
567    Cnts[Exp]++;
568  }
569  int TStopwatch::Cnt(const TExperiment Exp) const {
570    return Cnts[Exp];
571  }
572  double TStopwatch::Sum(const TExperiment Exp) const {
573    return Sums[Exp];
574  }
575  double TStopwatch::Avg(const TExperiment Exp) const {
576    return Sums[Exp] / Cnts[Exp];
577  }
578  double TStopwatch::Max(const TExperiment Exp) const {
579    return Maxs[Exp];
580  }
581  double TStopwatch::Min(const TExperiment Exp) const {
582    return Mins[Exp];
583  }
584  #if defined(SW_WRITEN)
585  int WriteN(int fd, char *ptr, int nbytes) {
586    int nleft;
587    int nwritten;
588    nleft = nbytes;
589    while (nleft > 0) {
590      nwritten = (int) write(fd, ptr, nleft);
591      if (nwritten <= 0) {
592        return nwritten;
593      }
594      nleft -= nwritten;
595      ptr += nwritten;
596    }
597    return (nbytes-nleft);
598  }
599  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssqldm.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</div>
                <div class="column column_space"><pre><code>312            if (Ch=='='){Sym=dsyLEq; GetCh();}
313            else if (Ch=='>'){Sym=dsyNEq; GetCh();}
</pre></code></div>
                <div class="column column_space"><pre><code>139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    