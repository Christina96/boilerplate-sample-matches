<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for rib-module.t.cpp & lp-reliability.t.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for rib-module.t.cpp & lp-reliability.t.cpp
      </h3>
      <h1 align="center">
        6.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>rib-module.t.cpp (6.4267354%)<TH>lp-reliability.t.cpp (6.281407%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match638-0.html#0',2,'match638-1.html#0',3)" NAME="0">(47-64)<TD><A HREF="javascript:ZweiFrames('match638-0.html#0',2,'match638-1.html#0',3)" NAME="0">(310-326)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match638-0.html#1',2,'match638-1.html#1',3)" NAME="1">(588-598)<TD><A HREF="javascript:ZweiFrames('match638-0.html#1',2,'match638-1.html#1',3)" NAME="1">(541-627)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-module.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;nfdc/rib-module.hpp&quot;

#include &quot;execute-command-fixture.hpp&quot;
#include &quot;status-fixture.hpp&quot;

namespace nfd {
namespace tools {
namespace nfdc {
namespace tests {

BOOST_AUTO_TEST_SUITE(Nfdc)
BOOST_FIXTURE_TEST_SUITE(TestRibModule, StatusFixture&lt;RibModule&gt;)

class RouteListFixture : public ExecuteCommandFixture
{
protected:
  bool
  respondRibDataset(const Interest&amp; interest)
<A NAME="0"></A>  {
    if (!Name(&quot;/localhost/nfd/rib/list&quot;).isPrefixOf(interest.getName())) {
      return false;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match638-1.html#0',3,'match638-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    }

    RibEntry entry1;
    entry1.setName(&quot;/5BBmTevRJ&quot;);
    entry1.addRoute(Route()
                      .setFaceId(6720)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_CLIENT)
                      .setCost(2956)
                      .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT | ndn::nfd::ROUTE_FLAG_CAPTURE)
                      .setExpirationPeriod(29950035_ms));
    entry1.addRoute(Route()
                      .setFaceId(6720)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                      .setCost(425)
                      .setFlags(ndn::nfd::ROUTE_FLAGS_NONE));
    entry1.addRoute(Route()
                      .setFaceId(8599)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)</B></FONT>
                      .setCost(9140)
                      .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT));

    RibEntry entry2;
    entry2.setName(&quot;/aDPTKCio&quot;);
    entry2.addRoute(Route()
                      .setFaceId(31066)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_CLIENT)
                      .setCost(4617)
                      .setFlags(ndn::nfd::ROUTE_FLAG_CAPTURE));

    this-&gt;sendDataset(interest.getName(), entry1, entry2);
    return true;
  }
};

BOOST_FIXTURE_TEST_SUITE(ListShowCommand, RouteListFixture)

const std::string NOFILTER_OUTPUT = std::string(R&quot;TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=client cost=2956 flags=child-inherit|capture expires=29950s
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/5BBmTevRJ nexthop=8599 origin=static cost=9140 flags=child-inherit expires=never
prefix=/aDPTKCio nexthop=31066 origin=client cost=4617 flags=capture expires=never
)TEXT&quot;).substr(1);

BOOST_AUTO_TEST_CASE(ListNoFilter)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute(&quot;route&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(NOFILTER_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

const std::string NEXTHOP_OUTPUT = std::string(R&quot;TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=client cost=2956 flags=child-inherit|capture expires=29950s
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/aDPTKCio nexthop=31066 origin=client cost=4617 flags=capture expires=never
)TEXT&quot;).substr(1);

BOOST_AUTO_TEST_CASE(ListByNexthop)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest) || this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute(&quot;route list udp4://225.131.75.231:56363&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(NEXTHOP_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

const std::string ORIGIN_OUTPUT = std::string(R&quot;TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/5BBmTevRJ nexthop=8599 origin=static cost=9140 flags=child-inherit expires=never
)TEXT&quot;).substr(1);

BOOST_AUTO_TEST_CASE(ListByOriginNumeric)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute(&quot;route list origin 255&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(ORIGIN_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(ListByOriginString)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute(&quot;route list origin static&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(ORIGIN_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

const std::string PREFIX_OUTPUT = std::string(R&quot;TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=client cost=2956 flags=child-inherit|capture expires=29950s
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/5BBmTevRJ nexthop=8599 origin=static cost=9140 flags=child-inherit expires=never
)TEXT&quot;).substr(1);

BOOST_AUTO_TEST_CASE(ShowByPrefix)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute(&quot;route show 5BBmTevRJ&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(PREFIX_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(FaceNotExist)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute(&quot;route list 23728&quot;);
  BOOST_CHECK_EQUAL(exitCode, 3);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Face not found\n&quot;));
}

BOOST_AUTO_TEST_CASE(RouteNotExist)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest) || this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute(&quot;route list 10156&quot;);
  BOOST_CHECK_EQUAL(exitCode, 6);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Route not found\n&quot;));
}

BOOST_AUTO_TEST_CASE(ErrorDataset)
{
  this-&gt;processInterest = nullptr; // no response to dataset

  this-&gt;execute(&quot;route list&quot;);
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error 10060 when fetching RIB dataset: Timeout exceeded\n&quot;));
}

BOOST_AUTO_TEST_SUITE_END() // ListShowCommand

BOOST_FIXTURE_TEST_SUITE(AddCommand, ExecuteCommandFixture)

BOOST_AUTO_TEST_CASE(NormalByFaceId)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/register&quot;);
    ndn::nfd::RibRegisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), &quot;/vxXoEaWeDB&quot;);
    BOOST_CHECK_EQUAL(req.getFaceId(), 10156);
    BOOST_CHECK_EQUAL(req.getOrigin(), ndn::nfd::ROUTE_ORIGIN_STATIC);
    BOOST_CHECK_EQUAL(req.getCost(), 0);
    BOOST_CHECK_EQUAL(req.getFlags(), ndn::nfd::ROUTE_FLAGS_NONE);
    BOOST_CHECK_EQUAL(req.hasExpirationPeriod(), false);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute(&quot;route add /vxXoEaWeDB 10156 no-inherit&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(&quot;route-add-accepted prefix=/vxXoEaWeDB nexthop=10156 origin=static &quot;
                           &quot;cost=0 flags=none expires=never\n&quot;));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(NormalByFaceUri)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/register&quot;);
    ndn::nfd::RibRegisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), &quot;/FLQAsaYnYf&quot;);
    BOOST_CHECK_EQUAL(req.getFaceId(), 2249);
    BOOST_CHECK_EQUAL(req.getOrigin(), 17591);
    BOOST_CHECK_EQUAL(req.getCost(), 702);
    BOOST_CHECK_EQUAL(req.getFlags(), ndn::nfd::ROUTE_FLAG_CHILD_INHERIT |
                                      ndn::nfd::ROUTE_FLAG_CAPTURE);
    BOOST_REQUIRE_EQUAL(req.hasExpirationPeriod(), true);
    BOOST_REQUIRE_EQUAL(req.getExpirationPeriod(), 727411987_ms);

    ControlParameters resp = req;
    resp.setExpirationPeriod(727411154_ms); // server side may change expiration
    this-&gt;succeedCommand(interest, resp);
  };

  this-&gt;execute(&quot;route add /FLQAsaYnYf tcp4://32.121.182.82:6363 &quot;
                &quot;origin 17591 cost 702 capture expires 727411987&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(&quot;route-add-accepted prefix=/FLQAsaYnYf nexthop=2249 origin=17591 &quot;
                           &quot;cost=702 flags=child-inherit|capture expires=727411154ms\n&quot;));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(FaceNotExistFaceId)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute(&quot;route add /GJiKDus5i 23728&quot;);
  BOOST_CHECK_EQUAL(exitCode, 3);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Face not found\n&quot;));
}

BOOST_AUTO_TEST_CASE(FaceNotExistFaceUri)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (Name(&quot;/localhost/nfd/faces/query&quot;).isPrefixOf(interest.getName())) {
      this-&gt;respondFaceQuery(interest);
    }
    else if (Name(&quot;/localhost/nfd/faces/create&quot;).isPrefixOf(interest.getName())) {
      ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/faces/create&quot;);
      ndn::nfd::FaceCreateCommand cmd;
      cmd.validateRequest(req);
      cmd.applyDefaultsToRequest(req);
      BOOST_CHECK_EQUAL(req.getUri(), &quot;udp4://202.83.168.28:6363&quot;);

      ControlParameters resp = req;
      resp.setFaceId(255);
      resp.setLocalUri(&quot;udp4://32.121.182.82:50000&quot;);
      resp.setFacePersistency(FacePersistency::FACE_PERSISTENCY_PERSISTENT);
      resp.setBaseCongestionMarkingInterval(100_ms);
      resp.setDefaultCongestionThreshold(65536);
      resp.setMtu(8800);
      resp.setFlags(0);
      this-&gt;succeedCommand(interest, resp);
    }
    else if (Name(&quot;/localhost/nfd/rib/register&quot;).isPrefixOf(interest.getName())) {
      ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/register&quot;);
      ndn::nfd::RibRegisterCommand cmd;
      cmd.validateRequest(req);
      cmd.applyDefaultsToRequest(req);
      BOOST_CHECK_EQUAL(req.getName(), &quot;/634jfAfdf&quot;);
      BOOST_CHECK_EQUAL(req.getFaceId(), 255);
      BOOST_CHECK_EQUAL(req.getOrigin(), 17591);
      BOOST_CHECK_EQUAL(req.getCost(), 702);
      BOOST_CHECK_EQUAL(req.getFlags(), ndn::nfd::ROUTE_FLAG_CHILD_INHERIT |
                                        ndn::nfd::ROUTE_FLAG_CAPTURE);
      BOOST_REQUIRE_EQUAL(req.hasExpirationPeriod(), true);
      BOOST_REQUIRE_EQUAL(req.getExpirationPeriod(), 727411987_ms);

      ControlParameters resp = req;
      resp.setExpirationPeriod(727411154_ms); // server side may change expiration
      this-&gt;succeedCommand(interest, resp);
    }
  };

  this-&gt;execute(&quot;route add /634jfAfdf udp4://202.83.168.28:6363 &quot;
                &quot;origin 17591 cost 702 capture expires 727411987&quot;);
  BOOST_CHECK(out.is_equal(&quot;face-created id=255 local=udp4://32.121.182.82:50000 &quot;
                           &quot;remote=udp4://202.83.168.28:6363 persistency=persistent &quot;
                           &quot;reliability=off congestion-marking=off &quot;
                           &quot;congestion-marking-interval=100ms default-congestion-threshold=65536B &quot;
                           &quot;mtu=8800\n&quot;
                           &quot;route-add-accepted prefix=/634jfAfdf nexthop=255 origin=17591 &quot;
                           &quot;cost=702 flags=child-inherit|capture expires=727411154ms\n&quot;));
  BOOST_CHECK(err.is_empty());
  BOOST_CHECK_EQUAL(exitCode, 0);
}

BOOST_AUTO_TEST_CASE(FaceNotExistNotCanonizable)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute(&quot;route add /634jfAfdf udp6://202.83.168.28:6363 &quot;
                &quot;origin 17591 cost 702 capture expires 727411987&quot;);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error during canonization of 'udp6://202.83.168.28:6363': &quot;
                           &quot;IPv4/v6 mismatch\n&quot;));
  BOOST_CHECK_EQUAL(exitCode, 4);
}

BOOST_AUTO_TEST_CASE(Ambiguous)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute(&quot;route add /BQqjjnVsz udp4://225.131.75.231:56363&quot;);
  BOOST_CHECK_EQUAL(exitCode, 5);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Multiple faces match specified remote FaceUri. &quot;
                           &quot;Re-run the command with a FaceId: &quot;
                           &quot;6720 (local=udp4://202.83.168.28:56363), &quot;
                           &quot;31066 (local=udp4://25.90.26.32:56363)\n&quot;));
}

BOOST_AUTO_TEST_CASE(ErrorCanonization)
{
  this-&gt;execute(&quot;route add /bxJfGsVtDt udp6://32.38.164.64:10445&quot;);
  BOOST_CHECK_EQUAL(exitCode, 4);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error during canonization of 'udp6://32.38.164.64:10445': &quot;
                           &quot;IPv4/v6 mismatch\n&quot;));
}

BOOST_AUTO_TEST_CASE(ErrorDataset)
{
  this-&gt;processInterest = nullptr; // no response to dataset or command

  this-&gt;execute(&quot;route add /q1Qf7go7 udp://159.242.33.78&quot;);
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error 10060 when querying face: Timeout exceeded\n&quot;));
}

BOOST_AUTO_TEST_CASE(ErrorCommand)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/register&quot;);
    // no response to command
  };

  this-&gt;execute(&quot;route add /bYiMbEuE 10156&quot;);
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error 10060 when adding route: request timed out\n&quot;));
}

BOOST_AUTO_TEST_SUITE_END() // AddCommand

BOOST_FIXTURE_TEST_SUITE(RemoveCommand, ExecuteCommandFixture)

BOOST_AUTO_TEST_CASE(NormalByFaceId)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/unregister&quot;);
    ndn::nfd::RibUnregisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), &quot;/2B5NUGjpt&quot;);
    BOOST_CHECK_EQUAL(req.getFaceId(), 10156);
    BOOST_CHECK_EQUAL(req.getOrigin(), ndn::nfd::ROUTE_ORIGIN_STATIC);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute(&quot;route remove /2B5NUGjpt 10156&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(&quot;route-removed prefix=/2B5NUGjpt nexthop=10156 origin=static\n&quot;));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(NormalByFaceUri)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/unregister&quot;);
    ndn::nfd::RibUnregisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), &quot;/wHdNn0BtUF&quot;);
    BOOST_CHECK_EQUAL(req.getFaceId(), 2249);
    BOOST_CHECK_EQUAL(req.getOrigin(), 15246);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute(&quot;route remove /wHdNn0BtUF tcp4://32.121.182.82:6363 origin 15246&quot;);
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(&quot;route-removed prefix=/wHdNn0BtUF nexthop=2249 origin=15246\n&quot;));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(MultipleFaces)
{
  std::set&lt;uint64_t&gt; faceIds{6720, 31066};
  this-&gt;processInterest = [this, &amp;faceIds] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/unregister&quot;);
    ndn::nfd::RibUnregisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), &quot;/nm5y8X8b2&quot;);
    BOOST_CHECK_MESSAGE(faceIds.erase(req.getFaceId()), &quot;expected face &quot; + to_string(req.getFaceId()));
    BOOST_CHECK_EQUAL(req.getOrigin(), ndn::nfd::ROUTE_ORIGIN_STATIC);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute(&quot;route remove /nm5y8X8b2 udp4://225.131.75.231:56363&quot;);
  BOOST_CHECK(faceIds.empty());
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(&quot;route-removed prefix=/nm5y8X8b2 nexthop=6720 origin=static\n&quot;
                           &quot;route-removed prefix=/nm5y8X8b2 nexthop=31066 origin=static\n&quot;));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(FaceNotExist)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute(&quot;route remove /HeGRjzwFM 23728&quot;);
  BOOST_CHECK_EQUAL(exitCode, 3);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Face not found\n&quot;));
}

BOOST_AUTO_TEST_CASE(ErrorDataset)
{
  this-&gt;processInterest = nullptr; // no response to dataset or command

  this-&gt;execute(&quot;route remove /YX4xQQN3v5 udp://26.97.248.3&quot;);
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error 10060 when querying face: Timeout exceeded\n&quot;));
}

BOOST_AUTO_TEST_CASE(ErrorCommand)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    MOCK_NFD_MGMT_REQUIRE_COMMAND_IS(&quot;/localhost/nfd/rib/unregister&quot;);
    // no response to command
  };

  this-&gt;execute(&quot;route remove /mvGRoxD2 10156&quot;);
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal(&quot;Error 10060 when removing route: request timed out\n&quot;));
}

BOOST_AUTO_TEST_SUITE_END() // RemoveCommand

const std::string STATUS_XML = stripXmlSpaces(R&quot;XML(
  &lt;rib&gt;
    &lt;ribEntry&gt;
      &lt;prefix&gt;/&lt;/prefix&gt;
      &lt;routes&gt;
        &lt;route&gt;
          &lt;faceId&gt;262&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;9&lt;/cost&gt;
          &lt;flags&gt;
            &lt;ribCapture/&gt;
          &lt;/flags&gt;
        &lt;/route&gt;
        &lt;route&gt;
          &lt;faceId&gt;272&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;50&lt;/cost&gt;
          &lt;flags/&gt;
        &lt;/route&gt;
        &lt;route&gt;
          &lt;faceId&gt;274&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;78&lt;/cost&gt;
          &lt;flags&gt;
            &lt;childInherit/&gt;
            &lt;ribCapture/&gt;
          &lt;/flags&gt;
        &lt;/route&gt;
        &lt;route&gt;
          &lt;faceId&gt;276&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;79&lt;/cost&gt;
          &lt;flags&gt;
            &lt;childInherit/&gt;
          &lt;/flags&gt;
          &lt;expirationPeriod&gt;PT47S&lt;/expirationPeriod&gt;
        &lt;/route&gt;
      &lt;/routes&gt;
    &lt;/ribEntry&gt;
    &lt;ribEntry&gt;
      &lt;prefix&gt;/localhost/nfd&lt;/prefix&gt;
      &lt;routes&gt;
        &lt;route&gt;
          &lt;faceId&gt;258&lt;/faceId&gt;
          &lt;origin&gt;app&lt;/origin&gt;
          &lt;cost&gt;0&lt;/cost&gt;
          &lt;flags&gt;
            &lt;childInherit/&gt;
          &lt;/flags&gt;
        &lt;/route&gt;
      &lt;/routes&gt;
    &lt;/ribEntry&gt;
  &lt;/rib&gt;
)XML&quot;);

const std::string STATUS_TEXT =
  &quot;RIB:\n&quot;
  &quot;  / routes={nexthop=262 origin=static cost=9 flags=capture expires=never, &quot;
              &quot;nexthop=272 origin=static cost=50 flags=none expires=never, &quot;
              &quot;nexthop=274 origin=static cost=78 flags=child-inherit|capture expires=never, &quot;
              &quot;nexthop=276 origin=static cost=79 flags=child-inherit expires=47s}\n&quot;
  &quot;  /localhost/nfd routes={nexthop=258 origin=app cost=0 flags=child-inherit expires=never}\n&quot;;

BOOST_AUTO_TEST_CASE(Status)
{
  this-&gt;fetchStatus();
<A NAME="1"></A>  RibEntry payload1;
  payload1.setName(&quot;/&quot;)
          .addRoute(Route().setFaceId(262)
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match638-1.html#1',3,'match638-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(9)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CAPTURE))
          .addRoute(Route().setFaceId(272)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(50)
                           .setFlags(ndn::nfd::ROUTE_FLAGS_NONE))
          .addRoute(Route().setFaceId(274)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(78)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT | ndn::nfd::ROUTE_FLAG_CAPTURE))</B></FONT>
          .addRoute(Route().setFaceId(276)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(79)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT)
                           .setExpirationPeriod(47292_ms));
  RibEntry payload2;
  payload2.setName(&quot;/localhost/nfd&quot;)
          .addRoute(Route().setFaceId(258)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_APP)
                           .setCost(0)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT));
  this-&gt;sendDataset(&quot;/localhost/nfd/rib/list&quot;, payload1, payload2);
  this-&gt;prepareStatusOutput();

  BOOST_CHECK(statusXml.is_equal(STATUS_XML));
  BOOST_CHECK(statusText.is_equal(STATUS_TEXT));
}

BOOST_AUTO_TEST_SUITE_END() // TestRibModule
BOOST_AUTO_TEST_SUITE_END() // Nfdc

} // namespace tests
} // namespace nfdc
} // namespace tools
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lp-reliability.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2022,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;face/lp-reliability.hpp&quot;
#include &quot;face/face.hpp&quot;
#include &quot;face/generic-link-service.hpp&quot;

#include &quot;tests/test-common.hpp&quot;
#include &quot;tests/daemon/global-io-fixture.hpp&quot;
#include &quot;dummy-face.hpp&quot;
#include &quot;dummy-transport.hpp&quot;

#include &lt;cstring&gt;

namespace nfd {
namespace face {
namespace tests {

using namespace nfd::tests;

class DummyLpReliabilityLinkService : public GenericLinkService
{
public:
  LpReliability*
  getLpReliability()
  {
    return &amp;m_reliability;
  }

  void
  sendLpPackets(std::vector&lt;lp::Packet&gt; frags)
  {
    if (frags.front().has&lt;lp::FragmentField&gt;()) {
      Interest interest(&quot;/test/prefix&quot;);
      lp::Packet pkt;
      pkt.add&lt;lp::FragmentField&gt;({interest.wireEncode().begin(), interest.wireEncode().end()});
      assignSequences(frags);
      m_reliability.handleOutgoing(frags, std::move(pkt), true);
    }

    for (auto frag : frags) {
      this-&gt;sendLpPacket(std::move(frag));
    }
  }

private:
  void
  doSendInterest(const Interest&amp;) final
  {
    BOOST_FAIL(&quot;unexpected doSendInterest&quot;);
  }

  void
  doSendData(const Data&amp;) final
  {
    BOOST_FAIL(&quot;unexpected doSendData&quot;);
  }

  void
  doSendNack(const lp::Nack&amp;) final
  {
    BOOST_FAIL(&quot;unexpected doSendNack&quot;);
  }

  void
  doReceivePacket(const Block&amp;, const EndpointId&amp;) final
  {
    BOOST_FAIL(&quot;unexpected doReceivePacket&quot;);
  }
};

class LpReliabilityFixture : public GlobalIoTimeFixture
{
public:
  LpReliabilityFixture()
    : linkService(make_unique&lt;DummyLpReliabilityLinkService&gt;())
    , transport(make_unique&lt;DummyTransport&gt;())
    , face(make_unique&lt;DummyFace&gt;())
  {
    linkService-&gt;setFaceAndTransport(*face, *transport);
    transport-&gt;setFaceAndLinkService(*face, *linkService);

    GenericLinkService::Options options;
    options.reliabilityOptions.isEnabled = true;
    linkService-&gt;setOptions(options);

    reliability = linkService-&gt;getLpReliability();
    reliability-&gt;m_lastTxSeqNo = 1;
  }

  static bool
  netPktHasUnackedFrag(const shared_ptr&lt;LpReliability::NetPkt&gt;&amp; netPkt, lp::Sequence txSeq)
  {
    return std::any_of(netPkt-&gt;unackedFrags.begin(), netPkt-&gt;unackedFrags.end(),
                       [txSeq] (auto fragIt) { return fragIt-&gt;first == txSeq; });
  }

  /** \brief make an LpPacket with fragment of specified size
   *  \param pktNum packet identifier, which can be extracted with \p getPktNum
   *  \param payloadSize total payload size; must be &gt;= 4 and &lt;= 255
   */
  static lp::Packet
  makeFrag(uint32_t pktNum, size_t payloadSize = 4)
  {
    BOOST_ASSERT(payloadSize &gt;= 4 &amp;&amp; payloadSize &lt;= 255);
    lp::Packet pkt;
    ndn::Buffer buf(payloadSize);
    std::memcpy(buf.data(), &amp;pktNum, sizeof(pktNum));
    pkt.set&lt;lp::FragmentField&gt;({buf.cbegin(), buf.cend()});
    return pkt;
  }

  /** \brief extract packet identifier from LpPacket made with \p makeFrag
   *  \retval 0 packet identifier cannot be extracted
   */
  static uint32_t
  getPktNum(const lp::Packet&amp; pkt)
  {
    BOOST_REQUIRE(pkt.has&lt;lp::FragmentField&gt;());
    ndn::Buffer::const_iterator begin, end;
    std::tie(begin, end) = pkt.get&lt;lp::FragmentField&gt;();
    if (std::distance(begin, end) &lt; 4) {
      return 0;
    }

    uint32_t value = 0;
    std::memcpy(&amp;value, &amp;*begin, sizeof(value));
    return value;
  }

protected:
  unique_ptr&lt;DummyLpReliabilityLinkService&gt; linkService;
  unique_ptr&lt;DummyTransport&gt; transport;
  unique_ptr&lt;DummyFace&gt; face;
  LpReliability* reliability;
};

BOOST_AUTO_TEST_SUITE(Face)
BOOST_FIXTURE_TEST_SUITE(TestLpReliability, LpReliabilityFixture)

BOOST_AUTO_TEST_CASE(SendNoFragmentField)
{
  lp::Packet pkt;

  linkService-&gt;sendLpPackets({pkt});
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(SendUnfragmentedRetx)
{
  lp::Packet pkt1 = makeFrag(1024, 50);
  lp::Packet pkt2 = makeFrag(3000, 30);

  linkService-&gt;sendLpPackets({pkt1});
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);
  lp::Packet cached1(transport-&gt;sentPackets.front());
  BOOST_REQUIRE(cached1.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK(cached1.has&lt;lp::SequenceField&gt;());
  lp::Sequence firstTxSeq = cached1.get&lt;lp::TxSequenceField&gt;();
  BOOST_CHECK_EQUAL(firstTxSeq, 2);
  BOOST_CHECK_EQUAL(getPktNum(cached1), 1024);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+500ms
  // 1024 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  advanceClocks(1_ms, 500);
  linkService-&gt;sendLpPackets({pkt2});
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 2);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 1), 1);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(firstTxSeq).netPkt);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).netPkt);
  BOOST_CHECK_NE(reliability-&gt;m_unackedFrags.at(firstTxSeq).netPkt,
                 reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+1250ms
  // 1024 rto: 1000ms, txSeq: 4, started T+1000ms, retx 1
  // 3000 rto: 1000ms, txSeq: 3, started T+500ms, retx 0
  advanceClocks(1_ms, 750);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 2).retxCount, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 1), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 1);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+2250ms
  // 1024 rto: 1000ms, txSeq: 6, started T+2000ms, retx 2
  // 3000 rto: 1000ms, txSeq: 5, started T+1500ms, retx 1
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 1), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 2), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 4), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 4).retxCount, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 3), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 3).retxCount, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 3);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+3250ms
  // 1024 rto: 1000ms, txSeq: 8, started T+3000ms, retx 3
  // 3000 rto: 1000ms, txSeq: 7, started T+2500ms, retx 2
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 3), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 4), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 6), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 6).retxCount, 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 5), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 5).retxCount, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 5);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 7);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+4250ms
  // 1024 rto: expired, removed
  // 3000 rto: 1000ms, txSeq: 9, started T+3500ms, retx 3
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 5), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 6), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 7), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 7).retxCount, 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 7);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 8);

  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 1);

  // T+4750ms
  // 1024 rto: expired, removed
  // 3000 rto: expired, removed
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 8);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 2);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 2);
}

BOOST_AUTO_TEST_CASE(SendFragmentedRetx)
{
  lp::Packet pkt1 = makeFrag(2048, 30);
<A NAME="0"></A>  lp::Packet pkt2 = makeFrag(2049, 30);
  lp::Packet pkt3 = makeFrag(2050, 10);

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match638-0.html#0',2,'match638-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  linkService-&gt;sendLpPackets({pkt1, pkt2, pkt3});
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 3);

  lp::Packet cached1(transport-&gt;sentPackets.at(0));
  BOOST_REQUIRE(cached1.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(cached1.get&lt;lp::TxSequenceField&gt;(), 2);
  BOOST_CHECK(cached1.has&lt;lp::SequenceField&gt;());
  BOOST_CHECK_EQUAL(getPktNum(cached1), 2048);
  lp::Packet cached2(transport-&gt;sentPackets.at(1));
  BOOST_REQUIRE(cached2.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(cached2.get&lt;lp::TxSequenceField&gt;(), 3);
  BOOST_CHECK(cached2.has&lt;lp::SequenceField&gt;());
  BOOST_CHECK_EQUAL(getPktNum(cached2), 2049);
  lp::Packet cached3(transport-&gt;sentPackets.at(2));
  BOOST_REQUIRE(cached3.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(cached3.get&lt;lp::TxSequenceField&gt;(), 4);
  BOOST_CHECK(cached3.has&lt;lp::SequenceField&gt;());</B></FONT>
  BOOST_CHECK_EQUAL(getPktNum(cached3), 2050);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+0ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 3, started T+0ms, retx 0
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(3).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(3).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(3).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 3));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+250ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 5, started T+250ms, retx 1
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0
  advanceClocks(1_ms, 250);
  reliability-&gt;onLpPacketLost(3, true);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(5), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(5).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(5).retxCount, 1);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(5).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(5).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(!netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 3));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 5));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 4);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+500ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 6, started T+500ms, retx 2
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0
  advanceClocks(1_ms, 250);
  reliability-&gt;onLpPacketLost(5, true);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(5), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(6), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(6).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(6).retxCount, 2);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(6).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(6).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(!netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 5));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 6));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+750ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 7, started T+750ms, retx 3
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0
  advanceClocks(1_ms, 250);
  reliability-&gt;onLpPacketLost(6, true);

  BOOST_REQUIRE_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(6), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(7), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(7).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(7).retxCount, 3);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(7).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(7).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(!netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 6));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 7));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+850ms
  // 2048 rto: expired, removed
  // 2049 rto: expired, removed
  // 2050 rto: expired, removed
  advanceClocks(1_ms, 100);
  reliability-&gt;onLpPacketLost(7, true);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 1);
}

BOOST_AUTO_TEST_CASE(AckUnknownTxSeq)
{
  linkService-&gt;sendLpPackets({makeFrag(1, 50)});

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt;
  ackPkt.add&lt;lp::AckField&gt;(10101010);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(LossByGreaterAcks)
{
  // Detect loss by 3x greater Acks, also tests wraparound

  reliability-&gt;m_lastTxSeqNo = 0xFFFFFFFFFFFFFFFE;

  // Passed to sendLpPackets individually since they are
  // from separate, non-fragmented network packets
  linkService-&gt;sendLpPackets({makeFrag(1, 50)});
  linkService-&gt;sendLpPackets({makeFrag(2, 50)});
  linkService-&gt;sendLpPackets({makeFrag(3, 50)});
  linkService-&gt;sendLpPackets({makeFrag(4, 50)});
  linkService-&gt;sendLpPackets({makeFrag(5, 50)});

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 5);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 1); // pkt1
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 1); // pkt2
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(0).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 1); // pkt3
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(1).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1); // pkt4
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(3).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 0xFFFFFFFFFFFFFFFF);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
<A NAME="1"></A>  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match638-0.html#1',2,'match638-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  lp::Packet ackPkt1;
  ackPkt1.add&lt;lp::AckField&gt;(0);

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt1));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 4);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 1); // pkt1
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).nGreaterSeqAcks, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 1); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 0xFFFFFFFFFFFFFFFF);
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt2;
  ackPkt2.add&lt;lp::AckField&gt;(2);
  ackPkt1.add&lt;lp::AckField&gt;(101010); // Unknown TxSequence number - ignored

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt2));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 1); // pkt1
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).nGreaterSeqAcks, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 1); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).nGreaterSeqAcks, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 0); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(101010), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 0xFFFFFFFFFFFFFFFF);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 2);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt3;
  ackPkt3.add&lt;lp::AckField&gt;(1);

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt3));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 0); // pkt1 old TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 0); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 0); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1); // pkt1 new TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 3);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);
  lp::Packet sentRetxPkt(transport-&gt;sentPackets.back());
  BOOST_REQUIRE(sentRetxPkt.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(sentRetxPkt.get&lt;lp::TxSequenceField&gt;(), 4);
  BOOST_CHECK_EQUAL(getPktNum(sentRetxPkt), 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt4;
  ackPkt4.add&lt;lp::AckField&gt;(4);</B></FONT>

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt4));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 0); // pkt1 old TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 0); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 0); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 0); // pkt1 new TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 3);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(SkipFragmentsRemovedInRtt)
{
  auto opts = linkService-&gt;getOptions();
  opts.reliabilityOptions.maxRetx = 0; // just to make the test case shorter
  opts.reliabilityOptions.seqNumLossThreshold = 3;
  linkService-&gt;setOptions(opts);

  lp::Packet frag1 = makeFrag(5001);
  lp::Packet frag2 = makeFrag(5002);
  linkService-&gt;sendLpPackets({frag1, frag2}); // First packet has 2 fragments
  linkService-&gt;sendLpPackets({makeFrag(5003)});
  linkService-&gt;sendLpPackets({makeFrag(5004)});
  linkService-&gt;sendLpPackets({makeFrag(5005)});

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 5);

  lp::Sequence firstTxSeq = reliability-&gt;m_firstUnackedFrag-&gt;first;

  // Ack the last 2 packets
  lp::Packet ackPkt1;
  ackPkt1.add&lt;lp::AckField&gt;(firstTxSeq + 4);
  ackPkt1.add&lt;lp::AckField&gt;(firstTxSeq + 3);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt1));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq).nGreaterSeqAcks, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).nGreaterSeqAcks, 2);

  // Ack the third packet (5003)
  // This triggers a &quot;loss by greater Acks&quot; for packets 5001 and 5002
  lp::Packet ackPkt2;
  ackPkt2.add&lt;lp::AckField&gt;(firstTxSeq + 2);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt2)); // tests crash/assert reported in bug #4479

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
}

BOOST_AUTO_TEST_CASE(CancelLossNotificationOnAck)
{
  reliability-&gt;onDroppedInterest.connect([] (const Interest&amp;) {
    BOOST_FAIL(&quot;Packet loss timeout should be cancelled when packet acknowledged&quot;);
  });

  reliability-&gt;m_lastTxSeqNo = 0;

  linkService-&gt;sendLpPackets({makeFrag(1, 50)});

  advanceClocks(1_ms, 500);

  lp::Packet ackPkt;
  ackPkt.add&lt;lp::AckField&gt;(1);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt));

  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(ProcessIncomingPacket)
{
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);

  lp::Packet pkt1 = makeFrag(100, 40);
  pkt1.add&lt;lp::SequenceField&gt;(123456);
  pkt1.add&lt;lp::TxSequenceField&gt;(765432);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(pkt1));

  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_REQUIRE_EQUAL(reliability-&gt;m_ackQueue.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 765432);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(123456), 1);

  lp::Packet pkt2 = makeFrag(276, 40);
  pkt2.add&lt;lp::SequenceField&gt;(654321);
  pkt2.add&lt;lp::TxSequenceField&gt;(234567);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(pkt2));

  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_REQUIRE_EQUAL(reliability-&gt;m_ackQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 765432);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.back(), 234567);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(123456), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(654321), 1);

  // T+5ms
  advanceClocks(1_ms, 5);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
}

BOOST_AUTO_TEST_CASE(PiggybackAcks)
{
  reliability-&gt;m_ackQueue.push(256);
  reliability-&gt;m_ackQueue.push(257);
  reliability-&gt;m_ackQueue.push(10);

  lp::Packet pkt;
  linkService-&gt;sendLpPackets({pkt});

  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);
  lp::Packet sentPkt(transport-&gt;sentPackets.front());

  BOOST_REQUIRE_EQUAL(sentPkt.count&lt;lp::AckField&gt;(), 3);
  BOOST_CHECK_EQUAL(sentPkt.get&lt;lp::AckField&gt;(0), 256);
  BOOST_CHECK_EQUAL(sentPkt.get&lt;lp::AckField&gt;(1), 257);
  BOOST_CHECK_EQUAL(sentPkt.get&lt;lp::AckField&gt;(2), 10);
  BOOST_CHECK(!sentPkt.has&lt;lp::TxSequenceField&gt;());

  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
}

BOOST_AUTO_TEST_CASE(PiggybackAcksMtu)
{
  // MTU is 1500, payload has 60 octets plus 6 octets for LpPacket and Fragment TL and 10 octets
  // each for Sequence and TxSequence, leaving 1414 octets for piggybacking. Each Ack header is 12
  // octets, so each LpPacket can carry 117 Acks, and it takes 9 LpPackets for 1000 Acks.

  transport-&gt;setMtu(1500);

  std::unordered_set&lt;lp::Sequence&gt; expectedAcks;
  for (lp::Sequence i = 1000; i &lt; 2000; i++) {
    reliability-&gt;m_ackQueue.push(i);
    expectedAcks.insert(i);
  }

  for (uint32_t i = 1; i &lt;= 9; i++) {
    lp::Packet pkt = makeFrag(i, 60);
    linkService-&gt;sendLpPackets({pkt});

    BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), i);
    lp::Packet sentPkt(transport-&gt;sentPackets.back());
    BOOST_CHECK_EQUAL(getPktNum(sentPkt), i);
    BOOST_CHECK(sentPkt.has&lt;lp::AckField&gt;());

    for (lp::Sequence ack : sentPkt.list&lt;lp::AckField&gt;()) {
      BOOST_CHECK_EQUAL(expectedAcks.erase(ack), 1);
    }
  }

  BOOST_CHECK(reliability-&gt;m_ackQueue.empty());
  BOOST_CHECK(expectedAcks.empty());
}

BOOST_AUTO_TEST_CASE(PiggybackAcksMtuNoSpace)
{
  // MTU is 64, payload has 34 octets plus 4 octets for LpPacket and Fragment TL and 10 octets each
  // for Sequence and TxSequence, leaving 6 octets for piggybacking. Each Ack header is 12 octets,
  // so there's no room to piggyback any Ack in LpPacket.

  transport-&gt;setMtu(MIN_MTU);

  for (lp::Sequence i = 1000; i &lt; 1100; i++) {
    reliability-&gt;m_ackQueue.push(i);
  }

  lp::Packet pkt = makeFrag(1, 34);
  linkService-&gt;sendLpPackets({pkt});

  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);
  lp::Packet sentPkt(transport-&gt;sentPackets.back());
  BOOST_CHECK_EQUAL(getPktNum(sentPkt), 1);
  BOOST_CHECK(!sentPkt.has&lt;lp::AckField&gt;());

  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 100);
}

BOOST_AUTO_TEST_CASE(StartIdleAckTimer)
{
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);

  lp::Packet pkt1 = makeFrag(1, 100);
  pkt1.add&lt;lp::SequenceField&gt;(1);
  pkt1.add&lt;lp::TxSequenceField&gt;(12);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt1}));
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+1ms
  advanceClocks(1_ms, 1);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  lp::Packet pkt2 = makeFrag(2, 100);
  pkt2.add&lt;lp::SequenceField&gt;(2);
  pkt2.add&lt;lp::TxSequenceField&gt;(13);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt2}));
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+5ms
  advanceClocks(1_ms, 4);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);

  lp::Packet pkt3 = makeFrag(3, 100);
  pkt3.add&lt;lp::SequenceField&gt;(3);
  pkt3.add&lt;lp::TxSequenceField&gt;(15);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt3}));
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+9ms
  advanceClocks(1_ms, 4);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+10ms
  advanceClocks(1_ms, 1);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
}

BOOST_AUTO_TEST_CASE(IdleAckTimer)
{
  // T+0ms: populate ack queue and start idle ack timer
  std::unordered_set&lt;lp::Sequence&gt; expectedAcks;
  for (lp::Sequence i = 1000; i &lt; 1500; i++) {
    reliability-&gt;m_ackQueue.push(i);
    expectedAcks.insert(i);
  }
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  reliability-&gt;startIdleAckTimer();
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+4ms: idle ack timer has not yet expired, no IDLE packet generated
  advanceClocks(1_ms, 4);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 500);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 1000);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.back(), 1499);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 0);

  // T+5ms: idle ack timer expires, IDLE packet generated
  advanceClocks(1_ms, 1);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);

  lp::Packet sentPkt(transport-&gt;sentPackets.back());
  BOOST_CHECK(!sentPkt.has&lt;lp::TxSequenceField&gt;());
  for (lp::Sequence ack : sentPkt.list&lt;lp::AckField&gt;()) {
    BOOST_CHECK_EQUAL(expectedAcks.erase(ack), 1);
  }
  BOOST_CHECK(expectedAcks.empty());
}

BOOST_AUTO_TEST_CASE(IdleAckTimerMtu)
{
  transport-&gt;setMtu(1500);

  // T+0ms: populate ack queue and start idle ack timer
  std::unordered_set&lt;lp::Sequence&gt; expectedAcks;
  for (lp::Sequence i = 1000; i &lt; 1500; i++) {
    reliability-&gt;m_ackQueue.push(i);
    expectedAcks.insert(i);
  }
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  reliability-&gt;startIdleAckTimer();
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+4ms: idle ack timer has not yet expired, no IDLE packet generated
  advanceClocks(1_ms, 4);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 500);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 1000);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.back(), 1499);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 0);

  // T+5ms: idle ack timer expires, IDLE packets generated
  advanceClocks(1_ms, 1);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);

  // MTU is 1500. LpPacket TL occupies 4 octets. Each Ack header is 12 octets. There are room for
  // 124 Acks per LpPacket, and it takes 5 LpPackets to carry 500 Acks.
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 5);
  for (size_t i = 0; i &lt; 5; i++) {
    lp::Packet sentPkt(transport-&gt;sentPackets[i]);
    BOOST_CHECK(!sentPkt.has&lt;lp::TxSequenceField&gt;());
    BOOST_CHECK_EQUAL(sentPkt.count&lt;lp::AckField&gt;(), i == 4 ? 4 : 124);
    for (lp::Sequence ack : sentPkt.list&lt;lp::AckField&gt;()) {
      BOOST_CHECK_EQUAL(expectedAcks.erase(ack), 1);
    }
  }

  BOOST_CHECK(expectedAcks.empty());
}

BOOST_AUTO_TEST_CASE(TrackRecentReceivedLpPackets)
{
  lp::Packet pkt1 = makeFrag(1, 100);
  pkt1.add&lt;lp::SequenceField&gt;(7);
  pkt1.add&lt;lp::TxSequenceField&gt;(12);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt1}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 7);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);

  // T+500ms
  // Estimated RTO starts at 1000ms and we are not adding any measurements, so it should remain
  // this value throughout the test case
  advanceClocks(500_ms, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);
  lp::Packet pkt2 = makeFrag(1, 100);
  pkt2.add&lt;lp::SequenceField&gt;(23);
  pkt2.add&lt;lp::TxSequenceField&gt;(13);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt2}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 7);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(23), 1);

  // T+1250ms
  // First received sequence should be removed after next received packet, but second should remain
  advanceClocks(750_ms, 1);
  lp::Packet pkt3 = makeFrag(1, 100);
  pkt3.add&lt;lp::SequenceField&gt;(24);
  pkt3.add&lt;lp::TxSequenceField&gt;(14);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt3}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 23);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(23), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(24), 1);

  // T+1750ms
  // Second received sequence should be removed
  advanceClocks(500_ms, 1);
  lp::Packet pkt4 = makeFrag(1, 100);
  pkt4.add&lt;lp::SequenceField&gt;(25);
  pkt4.add&lt;lp::TxSequenceField&gt;(15);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt4}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 24);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(24), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(25), 1);
}

BOOST_AUTO_TEST_CASE(DropDuplicateReceivedSequence)
{
  Interest interest(&quot;/test/prefix&quot;);
  lp::Packet pkt1;
  pkt1.add&lt;lp::FragmentField&gt;({interest.wireEncode().begin(), interest.wireEncode().end()});
  pkt1.add&lt;lp::SequenceField&gt;(7);
  pkt1.add&lt;lp::TxSequenceField&gt;(12);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt1}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);

  lp::Packet pkt2;
  pkt2.add&lt;lp::FragmentField&gt;({interest.wireEncode().begin(), interest.wireEncode().end()});
  pkt2.add&lt;lp::SequenceField&gt;(7);
  pkt2.add&lt;lp::TxSequenceField&gt;(13);
  BOOST_CHECK(!reliability-&gt;processIncomingPacket({pkt2}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);
}

BOOST_AUTO_TEST_CASE(DropDuplicateAckForRetx)
{
  lp::Packet pkt1 = makeFrag(1024, 50);
  linkService-&gt;sendLpPackets({pkt1});

  // Will send out a single fragment
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  lp::Sequence firstTxSeq = reliability-&gt;m_firstUnackedFrag-&gt;first;

  // RTO is initially 1 second, so will time out and retx
  advanceClocks(1250_ms, 1);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);

  // Acknowledge first transmission (RTO underestimation)
  // Ack will be dropped because unknown
  lp::Packet ackPkt1;
  ackPkt1.add&lt;lp::AckField&gt;(firstTxSeq);
  reliability-&gt;processIncomingPacket(ackPkt1);
  BOOST_REQUIRE_EQUAL(reliability-&gt;m_unackedFrags.size(), 1); // Required because collection used below

  // Acknowledge second transmission
  // Ack will acknowledge retx and remove unacked frag
  lp::Packet ackPkt2;
  ackPkt2.add&lt;lp::AckField&gt;(reliability-&gt;m_firstUnackedFrag-&gt;first);
  reliability-&gt;processIncomingPacket(ackPkt2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
}

BOOST_AUTO_TEST_SUITE_END() // TestLpReliability
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</PRE>
</div>
  </div>
</body>
</html>
