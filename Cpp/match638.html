<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for rib-module.t.cpp &amp; lp-reliability.t.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rib-module.t.cpp &amp; lp-reliability.t.cpp
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rib-module.t.cpp (6.4267354%)<th>lp-reliability.t.cpp (6.281407%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(47-64)<td><a href="#" name="0">(310-326)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(588-598)<td><a href="#" name="1">(541-627)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-module.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "nfdc/rib-module.hpp"

#include "execute-command-fixture.hpp"
#include "status-fixture.hpp"

namespace nfd {
namespace tools {
namespace nfdc {
namespace tests {

BOOST_AUTO_TEST_SUITE(Nfdc)
BOOST_FIXTURE_TEST_SUITE(TestRibModule, StatusFixture&lt;RibModule&gt;)

class RouteListFixture : public ExecuteCommandFixture
{
protected:
  bool
  respondRibDataset(const Interest&amp; interest)
<a name="0"></a>  {
    if (!Name("/localhost/nfd/rib/list").isPrefixOf(interest.getName())) {
      return false;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    }

    RibEntry entry1;
    entry1.setName("/5BBmTevRJ");
    entry1.addRoute(Route()
                      .setFaceId(6720)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_CLIENT)
                      .setCost(2956)
                      .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT | ndn::nfd::ROUTE_FLAG_CAPTURE)
                      .setExpirationPeriod(29950035_ms));
    entry1.addRoute(Route()
                      .setFaceId(6720)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                      .setCost(425)
                      .setFlags(ndn::nfd::ROUTE_FLAGS_NONE));
    entry1.addRoute(Route()
                      .setFaceId(8599)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)</b></font>
                      .setCost(9140)
                      .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT));

    RibEntry entry2;
    entry2.setName("/aDPTKCio");
    entry2.addRoute(Route()
                      .setFaceId(31066)
                      .setOrigin(ndn::nfd::ROUTE_ORIGIN_CLIENT)
                      .setCost(4617)
                      .setFlags(ndn::nfd::ROUTE_FLAG_CAPTURE));

    this-&gt;sendDataset(interest.getName(), entry1, entry2);
    return true;
  }
};

BOOST_FIXTURE_TEST_SUITE(ListShowCommand, RouteListFixture)

const std::string NOFILTER_OUTPUT = std::string(R"TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=client cost=2956 flags=child-inherit|capture expires=29950s
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/5BBmTevRJ nexthop=8599 origin=static cost=9140 flags=child-inherit expires=never
prefix=/aDPTKCio nexthop=31066 origin=client cost=4617 flags=capture expires=never
)TEXT").substr(1);

BOOST_AUTO_TEST_CASE(ListNoFilter)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute("route");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(NOFILTER_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

const std::string NEXTHOP_OUTPUT = std::string(R"TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=client cost=2956 flags=child-inherit|capture expires=29950s
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/aDPTKCio nexthop=31066 origin=client cost=4617 flags=capture expires=never
)TEXT").substr(1);

BOOST_AUTO_TEST_CASE(ListByNexthop)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest) || this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute("route list udp4://225.131.75.231:56363");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(NEXTHOP_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

const std::string ORIGIN_OUTPUT = std::string(R"TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/5BBmTevRJ nexthop=8599 origin=static cost=9140 flags=child-inherit expires=never
)TEXT").substr(1);

BOOST_AUTO_TEST_CASE(ListByOriginNumeric)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute("route list origin 255");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(ORIGIN_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(ListByOriginString)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute("route list origin static");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(ORIGIN_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

const std::string PREFIX_OUTPUT = std::string(R"TEXT(
prefix=/5BBmTevRJ nexthop=6720 origin=client cost=2956 flags=child-inherit|capture expires=29950s
prefix=/5BBmTevRJ nexthop=6720 origin=static cost=425 flags=none expires=never
prefix=/5BBmTevRJ nexthop=8599 origin=static cost=9140 flags=child-inherit expires=never
)TEXT").substr(1);

BOOST_AUTO_TEST_CASE(ShowByPrefix)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute("route show 5BBmTevRJ");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal(PREFIX_OUTPUT));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(FaceNotExist)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute("route list 23728");
  BOOST_CHECK_EQUAL(exitCode, 3);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Face not found\n"));
}

BOOST_AUTO_TEST_CASE(RouteNotExist)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest) || this-&gt;respondRibDataset(interest));
  };

  this-&gt;execute("route list 10156");
  BOOST_CHECK_EQUAL(exitCode, 6);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Route not found\n"));
}

BOOST_AUTO_TEST_CASE(ErrorDataset)
{
  this-&gt;processInterest = nullptr; // no response to dataset

  this-&gt;execute("route list");
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error 10060 when fetching RIB dataset: Timeout exceeded\n"));
}

BOOST_AUTO_TEST_SUITE_END() // ListShowCommand

BOOST_FIXTURE_TEST_SUITE(AddCommand, ExecuteCommandFixture)

BOOST_AUTO_TEST_CASE(NormalByFaceId)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/register");
    ndn::nfd::RibRegisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), "/vxXoEaWeDB");
    BOOST_CHECK_EQUAL(req.getFaceId(), 10156);
    BOOST_CHECK_EQUAL(req.getOrigin(), ndn::nfd::ROUTE_ORIGIN_STATIC);
    BOOST_CHECK_EQUAL(req.getCost(), 0);
    BOOST_CHECK_EQUAL(req.getFlags(), ndn::nfd::ROUTE_FLAGS_NONE);
    BOOST_CHECK_EQUAL(req.hasExpirationPeriod(), false);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute("route add /vxXoEaWeDB 10156 no-inherit");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal("route-add-accepted prefix=/vxXoEaWeDB nexthop=10156 origin=static "
                           "cost=0 flags=none expires=never\n"));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(NormalByFaceUri)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/register");
    ndn::nfd::RibRegisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), "/FLQAsaYnYf");
    BOOST_CHECK_EQUAL(req.getFaceId(), 2249);
    BOOST_CHECK_EQUAL(req.getOrigin(), 17591);
    BOOST_CHECK_EQUAL(req.getCost(), 702);
    BOOST_CHECK_EQUAL(req.getFlags(), ndn::nfd::ROUTE_FLAG_CHILD_INHERIT |
                                      ndn::nfd::ROUTE_FLAG_CAPTURE);
    BOOST_REQUIRE_EQUAL(req.hasExpirationPeriod(), true);
    BOOST_REQUIRE_EQUAL(req.getExpirationPeriod(), 727411987_ms);

    ControlParameters resp = req;
    resp.setExpirationPeriod(727411154_ms); // server side may change expiration
    this-&gt;succeedCommand(interest, resp);
  };

  this-&gt;execute("route add /FLQAsaYnYf tcp4://32.121.182.82:6363 "
                "origin 17591 cost 702 capture expires 727411987");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal("route-add-accepted prefix=/FLQAsaYnYf nexthop=2249 origin=17591 "
                           "cost=702 flags=child-inherit|capture expires=727411154ms\n"));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(FaceNotExistFaceId)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute("route add /GJiKDus5i 23728");
  BOOST_CHECK_EQUAL(exitCode, 3);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Face not found\n"));
}

BOOST_AUTO_TEST_CASE(FaceNotExistFaceUri)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (Name("/localhost/nfd/faces/query").isPrefixOf(interest.getName())) {
      this-&gt;respondFaceQuery(interest);
    }
    else if (Name("/localhost/nfd/faces/create").isPrefixOf(interest.getName())) {
      ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/faces/create");
      ndn::nfd::FaceCreateCommand cmd;
      cmd.validateRequest(req);
      cmd.applyDefaultsToRequest(req);
      BOOST_CHECK_EQUAL(req.getUri(), "udp4://202.83.168.28:6363");

      ControlParameters resp = req;
      resp.setFaceId(255);
      resp.setLocalUri("udp4://32.121.182.82:50000");
      resp.setFacePersistency(FacePersistency::FACE_PERSISTENCY_PERSISTENT);
      resp.setBaseCongestionMarkingInterval(100_ms);
      resp.setDefaultCongestionThreshold(65536);
      resp.setMtu(8800);
      resp.setFlags(0);
      this-&gt;succeedCommand(interest, resp);
    }
    else if (Name("/localhost/nfd/rib/register").isPrefixOf(interest.getName())) {
      ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/register");
      ndn::nfd::RibRegisterCommand cmd;
      cmd.validateRequest(req);
      cmd.applyDefaultsToRequest(req);
      BOOST_CHECK_EQUAL(req.getName(), "/634jfAfdf");
      BOOST_CHECK_EQUAL(req.getFaceId(), 255);
      BOOST_CHECK_EQUAL(req.getOrigin(), 17591);
      BOOST_CHECK_EQUAL(req.getCost(), 702);
      BOOST_CHECK_EQUAL(req.getFlags(), ndn::nfd::ROUTE_FLAG_CHILD_INHERIT |
                                        ndn::nfd::ROUTE_FLAG_CAPTURE);
      BOOST_REQUIRE_EQUAL(req.hasExpirationPeriod(), true);
      BOOST_REQUIRE_EQUAL(req.getExpirationPeriod(), 727411987_ms);

      ControlParameters resp = req;
      resp.setExpirationPeriod(727411154_ms); // server side may change expiration
      this-&gt;succeedCommand(interest, resp);
    }
  };

  this-&gt;execute("route add /634jfAfdf udp4://202.83.168.28:6363 "
                "origin 17591 cost 702 capture expires 727411987");
  BOOST_CHECK(out.is_equal("face-created id=255 local=udp4://32.121.182.82:50000 "
                           "remote=udp4://202.83.168.28:6363 persistency=persistent "
                           "reliability=off congestion-marking=off "
                           "congestion-marking-interval=100ms default-congestion-threshold=65536B "
                           "mtu=8800\n"
                           "route-add-accepted prefix=/634jfAfdf nexthop=255 origin=17591 "
                           "cost=702 flags=child-inherit|capture expires=727411154ms\n"));
  BOOST_CHECK(err.is_empty());
  BOOST_CHECK_EQUAL(exitCode, 0);
}

BOOST_AUTO_TEST_CASE(FaceNotExistNotCanonizable)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute("route add /634jfAfdf udp6://202.83.168.28:6363 "
                "origin 17591 cost 702 capture expires 727411987");
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error during canonization of 'udp6://202.83.168.28:6363': "
                           "IPv4/v6 mismatch\n"));
  BOOST_CHECK_EQUAL(exitCode, 4);
}

BOOST_AUTO_TEST_CASE(Ambiguous)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute("route add /BQqjjnVsz udp4://225.131.75.231:56363");
  BOOST_CHECK_EQUAL(exitCode, 5);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Multiple faces match specified remote FaceUri. "
                           "Re-run the command with a FaceId: "
                           "6720 (local=udp4://202.83.168.28:56363), "
                           "31066 (local=udp4://25.90.26.32:56363)\n"));
}

BOOST_AUTO_TEST_CASE(ErrorCanonization)
{
  this-&gt;execute("route add /bxJfGsVtDt udp6://32.38.164.64:10445");
  BOOST_CHECK_EQUAL(exitCode, 4);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error during canonization of 'udp6://32.38.164.64:10445': "
                           "IPv4/v6 mismatch\n"));
}

BOOST_AUTO_TEST_CASE(ErrorDataset)
{
  this-&gt;processInterest = nullptr; // no response to dataset or command

  this-&gt;execute("route add /q1Qf7go7 udp://159.242.33.78");
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error 10060 when querying face: Timeout exceeded\n"));
}

BOOST_AUTO_TEST_CASE(ErrorCommand)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/register");
    // no response to command
  };

  this-&gt;execute("route add /bYiMbEuE 10156");
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error 10060 when adding route: request timed out\n"));
}

BOOST_AUTO_TEST_SUITE_END() // AddCommand

BOOST_FIXTURE_TEST_SUITE(RemoveCommand, ExecuteCommandFixture)

BOOST_AUTO_TEST_CASE(NormalByFaceId)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/unregister");
    ndn::nfd::RibUnregisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), "/2B5NUGjpt");
    BOOST_CHECK_EQUAL(req.getFaceId(), 10156);
    BOOST_CHECK_EQUAL(req.getOrigin(), ndn::nfd::ROUTE_ORIGIN_STATIC);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute("route remove /2B5NUGjpt 10156");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal("route-removed prefix=/2B5NUGjpt nexthop=10156 origin=static\n"));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(NormalByFaceUri)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/unregister");
    ndn::nfd::RibUnregisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), "/wHdNn0BtUF");
    BOOST_CHECK_EQUAL(req.getFaceId(), 2249);
    BOOST_CHECK_EQUAL(req.getOrigin(), 15246);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute("route remove /wHdNn0BtUF tcp4://32.121.182.82:6363 origin 15246");
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal("route-removed prefix=/wHdNn0BtUF nexthop=2249 origin=15246\n"));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(MultipleFaces)
{
  std::set&lt;uint64_t&gt; faceIds{6720, 31066};
  this-&gt;processInterest = [this, &amp;faceIds] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    ControlParameters req = MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/unregister");
    ndn::nfd::RibUnregisterCommand cmd;
    cmd.validateRequest(req);
    cmd.applyDefaultsToRequest(req);
    BOOST_CHECK_EQUAL(req.getName(), "/nm5y8X8b2");
    BOOST_CHECK_MESSAGE(faceIds.erase(req.getFaceId()), "expected face " + to_string(req.getFaceId()));
    BOOST_CHECK_EQUAL(req.getOrigin(), ndn::nfd::ROUTE_ORIGIN_STATIC);

    this-&gt;succeedCommand(interest, req);
  };

  this-&gt;execute("route remove /nm5y8X8b2 udp4://225.131.75.231:56363");
  BOOST_CHECK(faceIds.empty());
  BOOST_CHECK_EQUAL(exitCode, 0);
  BOOST_CHECK(out.is_equal("route-removed prefix=/nm5y8X8b2 nexthop=6720 origin=static\n"
                           "route-removed prefix=/nm5y8X8b2 nexthop=31066 origin=static\n"));
  BOOST_CHECK(err.is_empty());
}

BOOST_AUTO_TEST_CASE(FaceNotExist)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    BOOST_CHECK(this-&gt;respondFaceQuery(interest));
  };

  this-&gt;execute("route remove /HeGRjzwFM 23728");
  BOOST_CHECK_EQUAL(exitCode, 3);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Face not found\n"));
}

BOOST_AUTO_TEST_CASE(ErrorDataset)
{
  this-&gt;processInterest = nullptr; // no response to dataset or command

  this-&gt;execute("route remove /YX4xQQN3v5 udp://26.97.248.3");
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error 10060 when querying face: Timeout exceeded\n"));
}

BOOST_AUTO_TEST_CASE(ErrorCommand)
{
  this-&gt;processInterest = [this] (const Interest&amp; interest) {
    if (this-&gt;respondFaceQuery(interest)) {
      return;
    }

    MOCK_NFD_MGMT_REQUIRE_COMMAND_IS("/localhost/nfd/rib/unregister");
    // no response to command
  };

  this-&gt;execute("route remove /mvGRoxD2 10156");
  BOOST_CHECK_EQUAL(exitCode, 1);
  BOOST_CHECK(out.is_empty());
  BOOST_CHECK(err.is_equal("Error 10060 when removing route: request timed out\n"));
}

BOOST_AUTO_TEST_SUITE_END() // RemoveCommand

const std::string STATUS_XML = stripXmlSpaces(R"XML(
  &lt;rib&gt;
    &lt;ribEntry&gt;
      &lt;prefix&gt;/&lt;/prefix&gt;
      &lt;routes&gt;
        &lt;route&gt;
          &lt;faceId&gt;262&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;9&lt;/cost&gt;
          &lt;flags&gt;
            &lt;ribCapture/&gt;
          &lt;/flags&gt;
        &lt;/route&gt;
        &lt;route&gt;
          &lt;faceId&gt;272&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;50&lt;/cost&gt;
          &lt;flags/&gt;
        &lt;/route&gt;
        &lt;route&gt;
          &lt;faceId&gt;274&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;78&lt;/cost&gt;
          &lt;flags&gt;
            &lt;childInherit/&gt;
            &lt;ribCapture/&gt;
          &lt;/flags&gt;
        &lt;/route&gt;
        &lt;route&gt;
          &lt;faceId&gt;276&lt;/faceId&gt;
          &lt;origin&gt;static&lt;/origin&gt;
          &lt;cost&gt;79&lt;/cost&gt;
          &lt;flags&gt;
            &lt;childInherit/&gt;
          &lt;/flags&gt;
          &lt;expirationPeriod&gt;PT47S&lt;/expirationPeriod&gt;
        &lt;/route&gt;
      &lt;/routes&gt;
    &lt;/ribEntry&gt;
    &lt;ribEntry&gt;
      &lt;prefix&gt;/localhost/nfd&lt;/prefix&gt;
      &lt;routes&gt;
        &lt;route&gt;
          &lt;faceId&gt;258&lt;/faceId&gt;
          &lt;origin&gt;app&lt;/origin&gt;
          &lt;cost&gt;0&lt;/cost&gt;
          &lt;flags&gt;
            &lt;childInherit/&gt;
          &lt;/flags&gt;
        &lt;/route&gt;
      &lt;/routes&gt;
    &lt;/ribEntry&gt;
  &lt;/rib&gt;
)XML");

const std::string STATUS_TEXT =
  "RIB:\n"
  "  / routes={nexthop=262 origin=static cost=9 flags=capture expires=never, "
              "nexthop=272 origin=static cost=50 flags=none expires=never, "
              "nexthop=274 origin=static cost=78 flags=child-inherit|capture expires=never, "
              "nexthop=276 origin=static cost=79 flags=child-inherit expires=47s}\n"
  "  /localhost/nfd routes={nexthop=258 origin=app cost=0 flags=child-inherit expires=never}\n";

BOOST_AUTO_TEST_CASE(Status)
{
  this-&gt;fetchStatus();
<a name="1"></a>  RibEntry payload1;
  payload1.setName("/")
          .addRoute(Route().setFaceId(262)
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(9)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CAPTURE))
          .addRoute(Route().setFaceId(272)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(50)
                           .setFlags(ndn::nfd::ROUTE_FLAGS_NONE))
          .addRoute(Route().setFaceId(274)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(78)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT | ndn::nfd::ROUTE_FLAG_CAPTURE))</b></font>
          .addRoute(Route().setFaceId(276)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_STATIC)
                           .setCost(79)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT)
                           .setExpirationPeriod(47292_ms));
  RibEntry payload2;
  payload2.setName("/localhost/nfd")
          .addRoute(Route().setFaceId(258)
                           .setOrigin(ndn::nfd::ROUTE_ORIGIN_APP)
                           .setCost(0)
                           .setFlags(ndn::nfd::ROUTE_FLAG_CHILD_INHERIT));
  this-&gt;sendDataset("/localhost/nfd/rib/list", payload1, payload2);
  this-&gt;prepareStatusOutput();

  BOOST_CHECK(statusXml.is_equal(STATUS_XML));
  BOOST_CHECK(statusText.is_equal(STATUS_TEXT));
}

BOOST_AUTO_TEST_SUITE_END() // TestRibModule
BOOST_AUTO_TEST_SUITE_END() // Nfdc

} // namespace tests
} // namespace nfdc
} // namespace tools
} // namespace nfd
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lp-reliability.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2022,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "face/lp-reliability.hpp"
#include "face/face.hpp"
#include "face/generic-link-service.hpp"

#include "tests/test-common.hpp"
#include "tests/daemon/global-io-fixture.hpp"
#include "dummy-face.hpp"
#include "dummy-transport.hpp"

#include &lt;cstring&gt;

namespace nfd {
namespace face {
namespace tests {

using namespace nfd::tests;

class DummyLpReliabilityLinkService : public GenericLinkService
{
public:
  LpReliability*
  getLpReliability()
  {
    return &amp;m_reliability;
  }

  void
  sendLpPackets(std::vector&lt;lp::Packet&gt; frags)
  {
    if (frags.front().has&lt;lp::FragmentField&gt;()) {
      Interest interest("/test/prefix");
      lp::Packet pkt;
      pkt.add&lt;lp::FragmentField&gt;({interest.wireEncode().begin(), interest.wireEncode().end()});
      assignSequences(frags);
      m_reliability.handleOutgoing(frags, std::move(pkt), true);
    }

    for (auto frag : frags) {
      this-&gt;sendLpPacket(std::move(frag));
    }
  }

private:
  void
  doSendInterest(const Interest&amp;) final
  {
    BOOST_FAIL("unexpected doSendInterest");
  }

  void
  doSendData(const Data&amp;) final
  {
    BOOST_FAIL("unexpected doSendData");
  }

  void
  doSendNack(const lp::Nack&amp;) final
  {
    BOOST_FAIL("unexpected doSendNack");
  }

  void
  doReceivePacket(const Block&amp;, const EndpointId&amp;) final
  {
    BOOST_FAIL("unexpected doReceivePacket");
  }
};

class LpReliabilityFixture : public GlobalIoTimeFixture
{
public:
  LpReliabilityFixture()
    : linkService(make_unique&lt;DummyLpReliabilityLinkService&gt;())
    , transport(make_unique&lt;DummyTransport&gt;())
    , face(make_unique&lt;DummyFace&gt;())
  {
    linkService-&gt;setFaceAndTransport(*face, *transport);
    transport-&gt;setFaceAndLinkService(*face, *linkService);

    GenericLinkService::Options options;
    options.reliabilityOptions.isEnabled = true;
    linkService-&gt;setOptions(options);

    reliability = linkService-&gt;getLpReliability();
    reliability-&gt;m_lastTxSeqNo = 1;
  }

  static bool
  netPktHasUnackedFrag(const shared_ptr&lt;LpReliability::NetPkt&gt;&amp; netPkt, lp::Sequence txSeq)
  {
    return std::any_of(netPkt-&gt;unackedFrags.begin(), netPkt-&gt;unackedFrags.end(),
                       [txSeq] (auto fragIt) { return fragIt-&gt;first == txSeq; });
  }

  /** \brief make an LpPacket with fragment of specified size
   *  \param pktNum packet identifier, which can be extracted with \p getPktNum
   *  \param payloadSize total payload size; must be &gt;= 4 and &lt;= 255
   */
  static lp::Packet
  makeFrag(uint32_t pktNum, size_t payloadSize = 4)
  {
    BOOST_ASSERT(payloadSize &gt;= 4 &amp;&amp; payloadSize &lt;= 255);
    lp::Packet pkt;
    ndn::Buffer buf(payloadSize);
    std::memcpy(buf.data(), &amp;pktNum, sizeof(pktNum));
    pkt.set&lt;lp::FragmentField&gt;({buf.cbegin(), buf.cend()});
    return pkt;
  }

  /** \brief extract packet identifier from LpPacket made with \p makeFrag
   *  \retval 0 packet identifier cannot be extracted
   */
  static uint32_t
  getPktNum(const lp::Packet&amp; pkt)
  {
    BOOST_REQUIRE(pkt.has&lt;lp::FragmentField&gt;());
    ndn::Buffer::const_iterator begin, end;
    std::tie(begin, end) = pkt.get&lt;lp::FragmentField&gt;();
    if (std::distance(begin, end) &lt; 4) {
      return 0;
    }

    uint32_t value = 0;
    std::memcpy(&amp;value, &amp;*begin, sizeof(value));
    return value;
  }

protected:
  unique_ptr&lt;DummyLpReliabilityLinkService&gt; linkService;
  unique_ptr&lt;DummyTransport&gt; transport;
  unique_ptr&lt;DummyFace&gt; face;
  LpReliability* reliability;
};

BOOST_AUTO_TEST_SUITE(Face)
BOOST_FIXTURE_TEST_SUITE(TestLpReliability, LpReliabilityFixture)

BOOST_AUTO_TEST_CASE(SendNoFragmentField)
{
  lp::Packet pkt;

  linkService-&gt;sendLpPackets({pkt});
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(SendUnfragmentedRetx)
{
  lp::Packet pkt1 = makeFrag(1024, 50);
  lp::Packet pkt2 = makeFrag(3000, 30);

  linkService-&gt;sendLpPackets({pkt1});
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);
  lp::Packet cached1(transport-&gt;sentPackets.front());
  BOOST_REQUIRE(cached1.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK(cached1.has&lt;lp::SequenceField&gt;());
  lp::Sequence firstTxSeq = cached1.get&lt;lp::TxSequenceField&gt;();
  BOOST_CHECK_EQUAL(firstTxSeq, 2);
  BOOST_CHECK_EQUAL(getPktNum(cached1), 1024);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+500ms
  // 1024 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  advanceClocks(1_ms, 500);
  linkService-&gt;sendLpPackets({pkt2});
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 2);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 1), 1);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(firstTxSeq).netPkt);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).netPkt);
  BOOST_CHECK_NE(reliability-&gt;m_unackedFrags.at(firstTxSeq).netPkt,
                 reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+1250ms
  // 1024 rto: 1000ms, txSeq: 4, started T+1000ms, retx 1
  // 3000 rto: 1000ms, txSeq: 3, started T+500ms, retx 0
  advanceClocks(1_ms, 750);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 2).retxCount, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 1), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 1);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+2250ms
  // 1024 rto: 1000ms, txSeq: 6, started T+2000ms, retx 2
  // 3000 rto: 1000ms, txSeq: 5, started T+1500ms, retx 1
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 1), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 2), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 4), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 4).retxCount, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 3), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 3).retxCount, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 3);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+3250ms
  // 1024 rto: 1000ms, txSeq: 8, started T+3000ms, retx 3
  // 3000 rto: 1000ms, txSeq: 7, started T+2500ms, retx 2
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 3), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 4), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 6), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 6).retxCount, 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 5), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 5).retxCount, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 5);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 7);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+4250ms
  // 1024 rto: expired, removed
  // 3000 rto: 1000ms, txSeq: 9, started T+3500ms, retx 3
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 5), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 6), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(firstTxSeq + 7), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 7).retxCount, 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, firstTxSeq + 7);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 8);

  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 1);

  // T+4750ms
  // 1024 rto: expired, removed
  // 3000 rto: expired, removed
  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 8);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 2);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 2);
}

BOOST_AUTO_TEST_CASE(SendFragmentedRetx)
{
  lp::Packet pkt1 = makeFrag(2048, 30);
<a name="0"></a>  lp::Packet pkt2 = makeFrag(2049, 30);
  lp::Packet pkt3 = makeFrag(2050, 10);

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  linkService-&gt;sendLpPackets({pkt1, pkt2, pkt3});
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 3);

  lp::Packet cached1(transport-&gt;sentPackets.at(0));
  BOOST_REQUIRE(cached1.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(cached1.get&lt;lp::TxSequenceField&gt;(), 2);
  BOOST_CHECK(cached1.has&lt;lp::SequenceField&gt;());
  BOOST_CHECK_EQUAL(getPktNum(cached1), 2048);
  lp::Packet cached2(transport-&gt;sentPackets.at(1));
  BOOST_REQUIRE(cached2.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(cached2.get&lt;lp::TxSequenceField&gt;(), 3);
  BOOST_CHECK(cached2.has&lt;lp::SequenceField&gt;());
  BOOST_CHECK_EQUAL(getPktNum(cached2), 2049);
  lp::Packet cached3(transport-&gt;sentPackets.at(2));
  BOOST_REQUIRE(cached3.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(cached3.get&lt;lp::TxSequenceField&gt;(), 4);
  BOOST_CHECK(cached3.has&lt;lp::SequenceField&gt;());</b></font>
  BOOST_CHECK_EQUAL(getPktNum(cached3), 2050);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+0ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 3, started T+0ms, retx 0
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(3).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(3).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(3).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 3));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+250ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 5, started T+250ms, retx 1
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0
  advanceClocks(1_ms, 250);
  reliability-&gt;onLpPacketLost(3, true);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(5), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(5).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(5).retxCount, 1);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(5).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(5).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(!netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 3));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 5));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 4);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+500ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 6, started T+500ms, retx 2
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0
  advanceClocks(1_ms, 250);
  reliability-&gt;onLpPacketLost(5, true);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(5), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(6), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(6).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(6).retxCount, 2);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(6).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(6).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(!netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 5));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 6));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+750ms
  // 2048 rto: 1000ms, txSeq: 2, started T+0ms, retx 0
  // 2049 rto: 1000ms, txSeq: 7, started T+750ms, retx 3
  // 2050 rto: 1000ms, txSeq: 4, started T+0ms, retx 0
  advanceClocks(1_ms, 250);
  reliability-&gt;onLpPacketLost(6, true);

  BOOST_REQUIRE_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(6), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(7), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(2).pkt), 2048);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(7).pkt), 2049);
  BOOST_CHECK_EQUAL(getPktNum(reliability-&gt;m_unackedFrags.at(4).pkt), 2050);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(7).retxCount, 3);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(7).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 0);
  BOOST_REQUIRE(reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(7).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt, reliability-&gt;m_unackedFrags.at(4).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).netPkt-&gt;unackedFrags.size(), 3);
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 2));
  BOOST_CHECK(!netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 6));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 7));
  BOOST_CHECK(netPktHasUnackedFrag(reliability-&gt;m_unackedFrags.at(2).netPkt, 4));
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  // T+850ms
  // 2048 rto: expired, removed
  // 2049 rto: expired, removed
  // 2050 rto: expired, removed
  advanceClocks(1_ms, 100);
  reliability-&gt;onLpPacketLost(7, true);

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 1);
}

BOOST_AUTO_TEST_CASE(AckUnknownTxSeq)
{
  linkService-&gt;sendLpPackets({makeFrag(1, 50)});

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt;
  ackPkt.add&lt;lp::AckField&gt;(10101010);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1);
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 2);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(LossByGreaterAcks)
{
  // Detect loss by 3x greater Acks, also tests wraparound

  reliability-&gt;m_lastTxSeqNo = 0xFFFFFFFFFFFFFFFE;

  // Passed to sendLpPackets individually since they are
  // from separate, non-fragmented network packets
  linkService-&gt;sendLpPackets({makeFrag(1, 50)});
  linkService-&gt;sendLpPackets({makeFrag(2, 50)});
  linkService-&gt;sendLpPackets({makeFrag(3, 50)});
  linkService-&gt;sendLpPackets({makeFrag(4, 50)});
  linkService-&gt;sendLpPackets({makeFrag(5, 50)});

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 5);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 1); // pkt1
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 1); // pkt2
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(0).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 1); // pkt3
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(1).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1); // pkt4
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(2).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK(reliability-&gt;m_unackedFrags.at(3).netPkt);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 0xFFFFFFFFFFFFFFFF);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
<a name="1"></a>  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  lp::Packet ackPkt1;
  ackPkt1.add&lt;lp::AckField&gt;(0);

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt1));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 4);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 1); // pkt1
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).nGreaterSeqAcks, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 1); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 1); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(2).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 0xFFFFFFFFFFFFFFFF);
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt2;
  ackPkt2.add&lt;lp::AckField&gt;(2);
  ackPkt1.add&lt;lp::AckField&gt;(101010); // Unknown TxSequence number - ignored

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt2));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 1); // pkt1
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(0xFFFFFFFFFFFFFFFF).nGreaterSeqAcks, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 1); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(1).nGreaterSeqAcks, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 0); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(101010), 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 0xFFFFFFFFFFFFFFFF);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 2);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt3;
  ackPkt3.add&lt;lp::AckField&gt;(1);

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt3));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 0); // pkt1 old TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 0); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 0); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 1); // pkt1 new TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).retxCount, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(4).nGreaterSeqAcks, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 3);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);
  lp::Packet sentRetxPkt(transport-&gt;sentPackets.back());
  BOOST_REQUIRE(sentRetxPkt.has&lt;lp::TxSequenceField&gt;());
  BOOST_CHECK_EQUAL(sentRetxPkt.get&lt;lp::TxSequenceField&gt;(), 4);
  BOOST_CHECK_EQUAL(getPktNum(sentRetxPkt), 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);

  lp::Packet ackPkt4;
  ackPkt4.add&lt;lp::AckField&gt;(4);</b></font>

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt4));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0xFFFFFFFFFFFFFFFF), 0); // pkt1 old TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(0), 0); // pkt2
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(1), 0); // pkt3
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(2), 0); // pkt4
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(3), 1); // pkt5
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).retxCount, 0);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(3).nGreaterSeqAcks, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.count(4), 0); // pkt1 new TxSeq
  BOOST_CHECK_EQUAL(reliability-&gt;m_firstUnackedFrag-&gt;first, 3);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 6);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 3);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(SkipFragmentsRemovedInRtt)
{
  auto opts = linkService-&gt;getOptions();
  opts.reliabilityOptions.maxRetx = 0; // just to make the test case shorter
  opts.reliabilityOptions.seqNumLossThreshold = 3;
  linkService-&gt;setOptions(opts);

  lp::Packet frag1 = makeFrag(5001);
  lp::Packet frag2 = makeFrag(5002);
  linkService-&gt;sendLpPackets({frag1, frag2}); // First packet has 2 fragments
  linkService-&gt;sendLpPackets({makeFrag(5003)});
  linkService-&gt;sendLpPackets({makeFrag(5004)});
  linkService-&gt;sendLpPackets({makeFrag(5005)});

  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 5);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 5);

  lp::Sequence firstTxSeq = reliability-&gt;m_firstUnackedFrag-&gt;first;

  // Ack the last 2 packets
  lp::Packet ackPkt1;
  ackPkt1.add&lt;lp::AckField&gt;(firstTxSeq + 4);
  ackPkt1.add&lt;lp::AckField&gt;(firstTxSeq + 3);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt1));

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 3);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq).nGreaterSeqAcks, 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.at(firstTxSeq + 1).nGreaterSeqAcks, 2);

  // Ack the third packet (5003)
  // This triggers a "loss by greater Acks" for packets 5001 and 5002
  lp::Packet ackPkt2;
  ackPkt2.add&lt;lp::AckField&gt;(firstTxSeq + 2);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt2)); // tests crash/assert reported in bug #4479

  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
}

BOOST_AUTO_TEST_CASE(CancelLossNotificationOnAck)
{
  reliability-&gt;onDroppedInterest.connect([] (const Interest&amp;) {
    BOOST_FAIL("Packet loss timeout should be cancelled when packet acknowledged");
  });

  reliability-&gt;m_lastTxSeqNo = 0;

  linkService-&gt;sendLpPackets({makeFrag(1, 50)});

  advanceClocks(1_ms, 500);

  lp::Packet ackPkt;
  ackPkt.add&lt;lp::AckField&gt;(1);
  BOOST_CHECK(reliability-&gt;processIncomingPacket(ackPkt));

  advanceClocks(1_ms, 1000);

  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nAcknowledged, 1);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetransmitted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nRetxExhausted, 0);
  BOOST_CHECK_EQUAL(linkService-&gt;getCounters().nInterestsExceededRetx, 0);
}

BOOST_AUTO_TEST_CASE(ProcessIncomingPacket)
{
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);

  lp::Packet pkt1 = makeFrag(100, 40);
  pkt1.add&lt;lp::SequenceField&gt;(123456);
  pkt1.add&lt;lp::TxSequenceField&gt;(765432);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(pkt1));

  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_REQUIRE_EQUAL(reliability-&gt;m_ackQueue.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 765432);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(123456), 1);

  lp::Packet pkt2 = makeFrag(276, 40);
  pkt2.add&lt;lp::SequenceField&gt;(654321);
  pkt2.add&lt;lp::TxSequenceField&gt;(234567);

  BOOST_CHECK(reliability-&gt;processIncomingPacket(pkt2));

  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_REQUIRE_EQUAL(reliability-&gt;m_ackQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 765432);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.back(), 234567);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(123456), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(654321), 1);

  // T+5ms
  advanceClocks(1_ms, 5);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
}

BOOST_AUTO_TEST_CASE(PiggybackAcks)
{
  reliability-&gt;m_ackQueue.push(256);
  reliability-&gt;m_ackQueue.push(257);
  reliability-&gt;m_ackQueue.push(10);

  lp::Packet pkt;
  linkService-&gt;sendLpPackets({pkt});

  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);
  lp::Packet sentPkt(transport-&gt;sentPackets.front());

  BOOST_REQUIRE_EQUAL(sentPkt.count&lt;lp::AckField&gt;(), 3);
  BOOST_CHECK_EQUAL(sentPkt.get&lt;lp::AckField&gt;(0), 256);
  BOOST_CHECK_EQUAL(sentPkt.get&lt;lp::AckField&gt;(1), 257);
  BOOST_CHECK_EQUAL(sentPkt.get&lt;lp::AckField&gt;(2), 10);
  BOOST_CHECK(!sentPkt.has&lt;lp::TxSequenceField&gt;());

  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
}

BOOST_AUTO_TEST_CASE(PiggybackAcksMtu)
{
  // MTU is 1500, payload has 60 octets plus 6 octets for LpPacket and Fragment TL and 10 octets
  // each for Sequence and TxSequence, leaving 1414 octets for piggybacking. Each Ack header is 12
  // octets, so each LpPacket can carry 117 Acks, and it takes 9 LpPackets for 1000 Acks.

  transport-&gt;setMtu(1500);

  std::unordered_set&lt;lp::Sequence&gt; expectedAcks;
  for (lp::Sequence i = 1000; i &lt; 2000; i++) {
    reliability-&gt;m_ackQueue.push(i);
    expectedAcks.insert(i);
  }

  for (uint32_t i = 1; i &lt;= 9; i++) {
    lp::Packet pkt = makeFrag(i, 60);
    linkService-&gt;sendLpPackets({pkt});

    BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), i);
    lp::Packet sentPkt(transport-&gt;sentPackets.back());
    BOOST_CHECK_EQUAL(getPktNum(sentPkt), i);
    BOOST_CHECK(sentPkt.has&lt;lp::AckField&gt;());

    for (lp::Sequence ack : sentPkt.list&lt;lp::AckField&gt;()) {
      BOOST_CHECK_EQUAL(expectedAcks.erase(ack), 1);
    }
  }

  BOOST_CHECK(reliability-&gt;m_ackQueue.empty());
  BOOST_CHECK(expectedAcks.empty());
}

BOOST_AUTO_TEST_CASE(PiggybackAcksMtuNoSpace)
{
  // MTU is 64, payload has 34 octets plus 4 octets for LpPacket and Fragment TL and 10 octets each
  // for Sequence and TxSequence, leaving 6 octets for piggybacking. Each Ack header is 12 octets,
  // so there's no room to piggyback any Ack in LpPacket.

  transport-&gt;setMtu(MIN_MTU);

  for (lp::Sequence i = 1000; i &lt; 1100; i++) {
    reliability-&gt;m_ackQueue.push(i);
  }

  lp::Packet pkt = makeFrag(1, 34);
  linkService-&gt;sendLpPackets({pkt});

  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);
  lp::Packet sentPkt(transport-&gt;sentPackets.back());
  BOOST_CHECK_EQUAL(getPktNum(sentPkt), 1);
  BOOST_CHECK(!sentPkt.has&lt;lp::AckField&gt;());

  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 100);
}

BOOST_AUTO_TEST_CASE(StartIdleAckTimer)
{
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);

  lp::Packet pkt1 = makeFrag(1, 100);
  pkt1.add&lt;lp::SequenceField&gt;(1);
  pkt1.add&lt;lp::TxSequenceField&gt;(12);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt1}));
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+1ms
  advanceClocks(1_ms, 1);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  lp::Packet pkt2 = makeFrag(2, 100);
  pkt2.add&lt;lp::SequenceField&gt;(2);
  pkt2.add&lt;lp::TxSequenceField&gt;(13);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt2}));
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+5ms
  advanceClocks(1_ms, 4);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);

  lp::Packet pkt3 = makeFrag(3, 100);
  pkt3.add&lt;lp::SequenceField&gt;(3);
  pkt3.add&lt;lp::TxSequenceField&gt;(15);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt3}));
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+9ms
  advanceClocks(1_ms, 4);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+10ms
  advanceClocks(1_ms, 1);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
}

BOOST_AUTO_TEST_CASE(IdleAckTimer)
{
  // T+0ms: populate ack queue and start idle ack timer
  std::unordered_set&lt;lp::Sequence&gt; expectedAcks;
  for (lp::Sequence i = 1000; i &lt; 1500; i++) {
    reliability-&gt;m_ackQueue.push(i);
    expectedAcks.insert(i);
  }
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  reliability-&gt;startIdleAckTimer();
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+4ms: idle ack timer has not yet expired, no IDLE packet generated
  advanceClocks(1_ms, 4);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 500);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 1000);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.back(), 1499);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 0);

  // T+5ms: idle ack timer expires, IDLE packet generated
  advanceClocks(1_ms, 1);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 1);

  lp::Packet sentPkt(transport-&gt;sentPackets.back());
  BOOST_CHECK(!sentPkt.has&lt;lp::TxSequenceField&gt;());
  for (lp::Sequence ack : sentPkt.list&lt;lp::AckField&gt;()) {
    BOOST_CHECK_EQUAL(expectedAcks.erase(ack), 1);
  }
  BOOST_CHECK(expectedAcks.empty());
}

BOOST_AUTO_TEST_CASE(IdleAckTimerMtu)
{
  transport-&gt;setMtu(1500);

  // T+0ms: populate ack queue and start idle ack timer
  std::unordered_set&lt;lp::Sequence&gt; expectedAcks;
  for (lp::Sequence i = 1000; i &lt; 1500; i++) {
    reliability-&gt;m_ackQueue.push(i);
    expectedAcks.insert(i);
  }
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  reliability-&gt;startIdleAckTimer();
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);

  // T+4ms: idle ack timer has not yet expired, no IDLE packet generated
  advanceClocks(1_ms, 4);
  BOOST_CHECK(reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 500);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.front(), 1000);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.back(), 1499);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 0);

  // T+5ms: idle ack timer expires, IDLE packets generated
  advanceClocks(1_ms, 1);
  BOOST_CHECK(!reliability-&gt;m_idleAckTimer);
  BOOST_CHECK_EQUAL(reliability-&gt;m_ackQueue.size(), 0);

  // MTU is 1500. LpPacket TL occupies 4 octets. Each Ack header is 12 octets. There are room for
  // 124 Acks per LpPacket, and it takes 5 LpPackets to carry 500 Acks.
  BOOST_REQUIRE_EQUAL(transport-&gt;sentPackets.size(), 5);
  for (size_t i = 0; i &lt; 5; i++) {
    lp::Packet sentPkt(transport-&gt;sentPackets[i]);
    BOOST_CHECK(!sentPkt.has&lt;lp::TxSequenceField&gt;());
    BOOST_CHECK_EQUAL(sentPkt.count&lt;lp::AckField&gt;(), i == 4 ? 4 : 124);
    for (lp::Sequence ack : sentPkt.list&lt;lp::AckField&gt;()) {
      BOOST_CHECK_EQUAL(expectedAcks.erase(ack), 1);
    }
  }

  BOOST_CHECK(expectedAcks.empty());
}

BOOST_AUTO_TEST_CASE(TrackRecentReceivedLpPackets)
{
  lp::Packet pkt1 = makeFrag(1, 100);
  pkt1.add&lt;lp::SequenceField&gt;(7);
  pkt1.add&lt;lp::TxSequenceField&gt;(12);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt1}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 7);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);

  // T+500ms
  // Estimated RTO starts at 1000ms and we are not adding any measurements, so it should remain
  // this value throughout the test case
  advanceClocks(500_ms, 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);
  lp::Packet pkt2 = makeFrag(1, 100);
  pkt2.add&lt;lp::SequenceField&gt;(23);
  pkt2.add&lt;lp::TxSequenceField&gt;(13);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt2}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 7);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(23), 1);

  // T+1250ms
  // First received sequence should be removed after next received packet, but second should remain
  advanceClocks(750_ms, 1);
  lp::Packet pkt3 = makeFrag(1, 100);
  pkt3.add&lt;lp::SequenceField&gt;(24);
  pkt3.add&lt;lp::TxSequenceField&gt;(14);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt3}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 23);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(23), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(24), 1);

  // T+1750ms
  // Second received sequence should be removed
  advanceClocks(500_ms, 1);
  lp::Packet pkt4 = makeFrag(1, 100);
  pkt4.add&lt;lp::SequenceField&gt;(25);
  pkt4.add&lt;lp::TxSequenceField&gt;(15);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt4}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqsQueue.front(), 24);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(24), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(25), 1);
}

BOOST_AUTO_TEST_CASE(DropDuplicateReceivedSequence)
{
  Interest interest("/test/prefix");
  lp::Packet pkt1;
  pkt1.add&lt;lp::FragmentField&gt;({interest.wireEncode().begin(), interest.wireEncode().end()});
  pkt1.add&lt;lp::SequenceField&gt;(7);
  pkt1.add&lt;lp::TxSequenceField&gt;(12);
  BOOST_CHECK(reliability-&gt;processIncomingPacket({pkt1}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);

  lp::Packet pkt2;
  pkt2.add&lt;lp::FragmentField&gt;({interest.wireEncode().begin(), interest.wireEncode().end()});
  pkt2.add&lt;lp::SequenceField&gt;(7);
  pkt2.add&lt;lp::TxSequenceField&gt;(13);
  BOOST_CHECK(!reliability-&gt;processIncomingPacket({pkt2}));
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_recentRecvSeqs.count(7), 1);
}

BOOST_AUTO_TEST_CASE(DropDuplicateAckForRetx)
{
  lp::Packet pkt1 = makeFrag(1024, 50);
  linkService-&gt;sendLpPackets({pkt1});

  // Will send out a single fragment
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 1);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);
  lp::Sequence firstTxSeq = reliability-&gt;m_firstUnackedFrag-&gt;first;

  // RTO is initially 1 second, so will time out and retx
  advanceClocks(1250_ms, 1);
  BOOST_CHECK_EQUAL(transport-&gt;sentPackets.size(), 2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 1);

  // Acknowledge first transmission (RTO underestimation)
  // Ack will be dropped because unknown
  lp::Packet ackPkt1;
  ackPkt1.add&lt;lp::AckField&gt;(firstTxSeq);
  reliability-&gt;processIncomingPacket(ackPkt1);
  BOOST_REQUIRE_EQUAL(reliability-&gt;m_unackedFrags.size(), 1); // Required because collection used below

  // Acknowledge second transmission
  // Ack will acknowledge retx and remove unacked frag
  lp::Packet ackPkt2;
  ackPkt2.add&lt;lp::AckField&gt;(reliability-&gt;m_firstUnackedFrag-&gt;first);
  reliability-&gt;processIncomingPacket(ackPkt2);
  BOOST_CHECK_EQUAL(reliability-&gt;m_unackedFrags.size(), 0);
}

BOOST_AUTO_TEST_SUITE_END() // TestLpReliability
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
