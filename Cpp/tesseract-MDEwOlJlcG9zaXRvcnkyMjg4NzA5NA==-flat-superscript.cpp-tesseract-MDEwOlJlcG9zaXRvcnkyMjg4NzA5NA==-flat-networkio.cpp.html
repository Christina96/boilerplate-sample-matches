
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.49740932642487%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</h3>
            <pre><code>1  #include "normalis.h"
2  #include "tesseractclass.h"
3  namespace tesseract {
4  static int LeadingUnicharsToChopped(WERD_RES *word, int num_unichars) {
5    int num_chopped = 0;
6    for (int i = 0; i < num_unichars; i++) {
7      num_chopped += word->best_state[i];
8    }
9    return num_chopped;
10  }
11  static int TrailingUnicharsToChopped(WERD_RES *word, int num_unichars) {
12    int num_chopped = 0;
13    for (int i = 0; i < num_unichars; i++) {
14      num_chopped += word->best_state[word->best_state.size() - 1 - i];
15    }
16    return num_chopped;
17  }
18  static void YOutlierPieces(WERD_RES *word, int rebuilt_blob_index, int super_y_bottom,
19                             int sub_y_top, ScriptPos *leading_pos, int *num_leading_outliers,
20                             ScriptPos *trailing_pos, int *num_trailing_outliers) {
21    ScriptPos sp_unused1, sp_unused2;
22    int unused1, unused2;
23    if (!leading_pos) {
24      leading_pos = &sp_unused1;
25    }
26    if (!num_leading_outliers) {
27      num_leading_outliers = &unused1;
28    }
29    if (!trailing_pos) {
30      trailing_pos = &sp_unused2;
31    }
32    if (!num_trailing_outliers) {
33      num_trailing_outliers = &unused2;
34    }
35    *num_leading_outliers = *num_trailing_outliers = 0;
36    *leading_pos = *trailing_pos = SP_NORMAL;
37    int chopped_start = LeadingUnicharsToChopped(word, rebuilt_blob_index);
38    int num_chopped_pieces = word->best_state[rebuilt_blob_index];
39    ScriptPos last_pos = SP_NORMAL;
40    int trailing_outliers = 0;
41    for (int i = 0; i < num_chopped_pieces; i++) {
42      TBOX box = word->chopped_word->blobs[chopped_start + i]->bounding_box();
43      ScriptPos pos = SP_NORMAL;
44      if (box.bottom() >= super_y_bottom) {
45        pos = SP_SUPERSCRIPT;
46      } else if (box.top() <= sub_y_top) {
47        pos = SP_SUBSCRIPT;
48      }
49      if (pos == SP_NORMAL) {
50        if (trailing_outliers == i) {
51          *num_leading_outliers = trailing_outliers;
52          *leading_pos = last_pos;
53        }
54        trailing_outliers = 0;
55      } else {
56        if (pos == last_pos) {
57          trailing_outliers++;
58        } else {
59          trailing_outliers = 1;
60        }
61      }
62      last_pos = pos;
63    }
64    *num_trailing_outliers = trailing_outliers;
65    *trailing_pos = last_pos;
66  }
67  bool Tesseract::SubAndSuperscriptFix(WERD_RES *word) {
68    if (word->tess_failed || word->word->flag(W_REP_CHAR) || !word->best_choice) {
69      return false;
70    }
71    int num_leading, num_trailing;
72    ScriptPos sp_leading, sp_trailing;
73    float leading_certainty, trailing_certainty;
74    float avg_certainty, unlikely_threshold;
75    GetSubAndSuperscriptCandidates(word, &num_leading, &sp_leading, &leading_certainty, &num_trailing,
76                                   &sp_trailing, &trailing_certainty, &avg_certainty,
77                                   &unlikely_threshold);
78    const char *leading_pos = sp_leading == SP_SUBSCRIPT ? "sub" : "super";
79    const char *trailing_pos = sp_trailing == SP_SUBSCRIPT ? "sub" : "super";
80    int num_blobs = word->best_choice->length();
81    int num_remainder_leading = 0, num_remainder_trailing = 0;
82    if (num_leading + num_trailing < num_blobs && unlikely_threshold < 0.0) {
83      int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
84      int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
85      int last_word_char = num_blobs - 1 - num_trailing;
86      float last_char_certainty = word->best_choice->certainty(last_word_char);
87      if (word->best_choice->unichar_id(last_word_char) != 0 &&
88          last_char_certainty <= unlikely_threshold) {
89        ScriptPos rpos;
90        YOutlierPieces(word, last_word_char, super_y_bottom, sub_y_top, nullptr, nullptr, &rpos,
91                       &num_remainder_trailing);
92        if (num_trailing > 0 && rpos != sp_trailing) {
93          num_remainder_trailing = 0;
94        }
95        if (num_remainder_trailing > 0 && last_char_certainty < trailing_certainty) {
96          trailing_certainty = last_char_certainty;
97        }
98      }
99      bool another_blob_available =
100          (num_remainder_trailing == 0) || num_leading + num_trailing + 1 < num_blobs;
101      int first_char_certainty = word->best_choice->certainty(num_leading);
102      if (another_blob_available && word->best_choice->unichar_id(num_leading) != 0 &&
103          first_char_certainty <= unlikely_threshold) {
104        ScriptPos lpos;
105        YOutlierPieces(word, num_leading, super_y_bottom, sub_y_top, &lpos, &num_remainder_leading,
106                       nullptr, nullptr);
107        if (num_leading > 0 && lpos != sp_leading) {
108          num_remainder_leading = 0;
109        }
110        if (num_remainder_leading > 0 && first_char_certainty < leading_certainty) {
111          leading_certainty = first_char_certainty;
112        }
113      }
114    }
115    if (num_leading + num_trailing + num_remainder_leading + num_remainder_trailing == 0) {
116      return false;
117    }
118    if (superscript_debug >= 1) {
119      tprintf("Candidate for superscript detection: %s (",
120              word->best_choice->unichar_string().c_str());
121      if (num_leading || num_remainder_leading) {
122        tprintf("%d.%d %s-leading ", num_leading, num_remainder_leading, leading_pos);
123      }
124      if (num_trailing || num_remainder_trailing) {
125        tprintf("%d.%d %s-trailing ", num_trailing, num_remainder_trailing, trailing_pos);
126      }
127      tprintf(")\n");
128    }
129    if (superscript_debug >= 3) {
130      word->best_choice->print();
131    }
132    if (superscript_debug >= 2) {
133      tprintf(" Certainties -- Average: %.2f  Unlikely thresh: %.2f  ", avg_certainty,
134              unlikely_threshold);
135      if (num_leading) {
136        tprintf("Orig. leading (min): %.2f  ", leading_certainty);
137      }
138      if (num_trailing) {
139        tprintf("Orig. trailing (min): %.2f  ", trailing_certainty);
140      }
141      tprintf("\n");
142    }
143    int num_chopped_leading = LeadingUnicharsToChopped(word, num_leading) + num_remainder_leading;
144    int num_chopped_trailing = TrailingUnicharsToChopped(word, num_trailing) + num_remainder_trailing;
145    int retry_leading = 0;
146    int retry_trailing = 0;
147    bool is_good = false;
148    WERD_RES *revised = TrySuperscriptSplits(num_chopped_leading, leading_certainty, sp_leading,
149                                             num_chopped_trailing, trailing_certainty, sp_trailing,
150                                             word, &is_good, &retry_leading, &retry_trailing);
151    if (is_good) {
152      word->ConsumeWordResults(revised);
153    } else if (retry_leading || retry_trailing) {
154      int retry_chopped_leading = LeadingUnicharsToChopped(revised, retry_leading);
155      int retry_chopped_trailing = TrailingUnicharsToChopped(revised, retry_trailing);
156      WERD_RES *revised2 = TrySuperscriptSplits(
157          retry_chopped_leading, leading_certainty, sp_leading, retry_chopped_trailing,
158          trailing_certainty, sp_trailing, revised, &is_good, &retry_leading, &retry_trailing);
159      if (is_good) {
160        word->ConsumeWordResults(revised2);
161      }
162      delete revised2;
163    }
164    delete revised;
165    return is_good;
166  }
167  void Tesseract::GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
168                                                 ScriptPos *leading_pos, float *leading_certainty,
169                                                 int *num_rebuilt_trailing, ScriptPos *trailing_pos,
170                                                 float *trailing_certainty, float *avg_certainty,
171                                                 float *unlikely_threshold) {
172    *avg_certainty = *unlikely_threshold = 0.0f;
173    *num_rebuilt_leading = *num_rebuilt_trailing = 0;
174    *leading_certainty = *trailing_certainty = 0.0f;
175    int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
176    int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
177    *leading_pos = *trailing_pos = SP_NORMAL;
178    int leading_outliers = 0;
179    int trailing_outliers = 0;
180    int num_normal = 0;
181    float normal_certainty_total = 0.0f;
182    float worst_normal_certainty = 0.0f;
183    ScriptPos last_pos = SP_NORMAL;
184    int num_blobs = word->rebuild_word->NumBlobs();
185    for (int b = 0; b < num_blobs; ++b) {
186      TBOX box = word->rebuild_word->blobs[b]->bounding_box();
187      ScriptPos pos = SP_NORMAL;
188      if (box.bottom() >= super_y_bottom) {
189        pos = SP_SUPERSCRIPT;
190      } else if (box.top() <= sub_y_top) {
191        pos = SP_SUBSCRIPT;
192      }
193      if (pos == SP_NORMAL) {
194        if (word->best_choice->unichar_id(b) != 0) {
195          float char_certainty = word->best_choice->certainty(b);
196          if (char_certainty < worst_normal_certainty) {
197            worst_normal_certainty = char_certainty;
198          }
199          num_normal++;
200          normal_certainty_total += char_certainty;
201        }
202        if (trailing_outliers == b) {
203          leading_outliers = trailing_outliers;
204          *leading_pos = last_pos;
205        }
206        trailing_outliers = 0;
207      } else {
208        if (last_pos == pos) {
209          trailing_outliers++;
210        } else {
211          trailing_outliers = 1;
212        }
213      }
214      last_pos = pos;
215    }
216    *trailing_pos = last_pos;
217    if (num_normal >= 3) { 
218      num_normal--;
219      normal_certainty_total -= worst_normal_certainty;
220    }
221    if (num_normal > 0) {
222      *avg_certainty = normal_certainty_total / num_normal;
223      *unlikely_threshold = superscript_worse_certainty * (*avg_certainty);
224    }
225    if (num_normal == 0 || (leading_outliers == 0 && trailing_outliers == 0)) {
226      return;
227    }
228    for (*leading_certainty = 0.0f, *num_rebuilt_leading = 0; *num_rebuilt_leading < leading_outliers;
229         (*num_rebuilt_leading)++) {
230      float char_certainty = word->best_choice->certainty(*num_rebuilt_leading);
231      if (char_certainty > *unlikely_threshold) {
232        break;
233      }
234      if (char_certainty < *leading_certainty) {
235        *leading_certainty = char_certainty;
236      }
237    }
238    for (*trailing_certainty = 0.0f, *num_rebuilt_trailing = 0;
239         *num_rebuilt_trailing < trailing_outliers; (*num_rebuilt_trailing)++) {
240      int blob_idx = num_blobs - 1 - *num_rebuilt_trailing;
241      float char_certainty = word->best_choice->certainty(blob_idx);
242      if (char_certainty > *unlikely_threshold) {
243        break;
244      }
245      if (char_certainty < *trailing_certainty) {
246        *trailing_certainty = char_certainty;
247      }
248    }
249  }
250  WERD_RES *Tesseract::TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
251                                            ScriptPos leading_pos, int num_chopped_trailing,
252                                            float trailing_certainty, ScriptPos trailing_pos,
253                                            WERD_RES *word, bool *is_good, int *retry_rebuild_leading,
254                                            int *retry_rebuild_trailing) {
255    int num_chopped = word->chopped_word->NumBlobs();
256    *retry_rebuild_leading = *retry_rebuild_trailing = 0;
257    BlamerBundle *bb0 = nullptr;
258    BlamerBundle *bb1 = nullptr;
259    WERD_RES *prefix = nullptr;
260    WERD_RES *core = nullptr;
261    WERD_RES *suffix = nullptr;
262    if (num_chopped_leading > 0) {
263      prefix = new WERD_RES(*word);
264      split_word(prefix, num_chopped_leading, &core, &bb0);
265    } else {
266      core = new WERD_RES(*word);
267    }
268    if (num_chopped_trailing > 0) {
269      int split_pt = num_chopped - num_chopped_trailing - num_chopped_leading;
270      split_word(core, split_pt, &suffix, &bb1);
271    }
272    int saved_cp_multiplier = classify_class_pruner_multiplier;
273    int saved_im_multiplier = classify_integer_matcher_multiplier;
274    if (prefix) {
275      classify_class_pruner_multiplier.set_value(0);
276      classify_integer_matcher_multiplier.set_value(0);
277      if (superscript_debug >= 3) {
278        tprintf(" recognizing first %d chopped blobs\n", num_chopped_leading);
279      }
280      recog_word_recursive(prefix);
281      if (superscript_debug >= 2) {
282        tprintf(" The leading bits look like %s %s\n", ScriptPosToString(leading_pos),
283                prefix->best_choice->unichar_string().c_str());
284      }
285      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
286      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
287    }
288    if (superscript_debug >= 3) {
289      tprintf(" recognizing middle %d chopped blobs\n",
290              num_chopped - num_chopped_leading - num_chopped_trailing);
291    }
292    if (suffix) {
293      classify_class_pruner_multiplier.set_value(0);
294      classify_integer_matcher_multiplier.set_value(0);
295      if (superscript_debug >= 3) {
296        tprintf(" recognizing last %d chopped blobs\n", num_chopped_trailing);
297      }
298      recog_word_recursive(suffix);
299      if (superscript_debug >= 2) {
300        tprintf(" The trailing bits look like %s %s\n", ScriptPosToString(trailing_pos),
301                suffix->best_choice->unichar_string().c_str());
302      }
303      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
304      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
305    }
306    bool good_prefix =
307        !prefix || BelievableSuperscript(superscript_debug >= 1, *prefix,
308                                         superscript_bettered_certainty * leading_certainty,
309                                         retry_rebuild_leading, nullptr);
310    bool good_suffix =
311        !suffix || BelievableSuperscript(superscript_debug >= 1, *suffix,
312                                         superscript_bettered_certainty * trailing_certainty, nullptr,
313                                         retry_rebuild_trailing);
314    *is_good = good_prefix && good_suffix;
315    if (!*is_good && !*retry_rebuild_leading && !*retry_rebuild_trailing) {
316      delete core;
317      delete prefix;
318      delete suffix;
319      delete bb1;
320      return nullptr;
321    }
322    recog_word_recursive(core);
323    if (suffix) {
324      suffix->SetAllScriptPositions(trailing_pos);
325      join_words(core, suffix, bb1);
326    }
327    if (prefix) {
328      prefix->SetAllScriptPositions(leading_pos);
329      join_words(prefix, core, bb0);
330      core = prefix;
331      prefix = nullptr;
332    }
333    if (superscript_debug >= 1) {
334      tprintf("%s superscript fix: %s\n", *is_good ? "ACCEPT" : "REJECT",
335              core->best_choice->unichar_string().c_str());
336    }
337    return core;
338  }
339  bool Tesseract::BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
340                                        int *left_ok, int *right_ok) const {
341    unsigned initial_ok_run_count = 0;
342    unsigned ok_run_count = 0;
343    float worst_certainty = 0.0f;
344    const WERD_CHOICE &wc = *word.best_choice;
345    const UnicityTable<FontInfo> &fontinfo_table = get_fontinfo_table();
346    for (unsigned i = 0; i < wc.length(); i++) {
347      TBLOB *blob = word.rebuild_word->blobs[i];
348      UNICHAR_ID unichar_id = wc.unichar_id(i);
349      float char_certainty = wc.certainty(i);
350      bool bad_certainty = char_certainty < certainty_threshold;
351      bool is_punc = wc.unicharset()->get_ispunctuation(unichar_id);
352      bool is_italic = word.fontinfo && word.fontinfo->is_italic();
353      BLOB_CHOICE *choice = word.GetBlobChoice(i);
354      if (choice && fontinfo_table.size() > 0) {
355        int font_id1 = choice->fontinfo_id();
356        bool font1_is_italic = font_id1 >= 0 ? fontinfo_table.at(font_id1).is_italic() : false;
357        int font_id2 = choice->fontinfo_id2();
358        is_italic = font1_is_italic && (font_id2 < 0 || fontinfo_table.at(font_id2).is_italic());
359      }
360      float height_fraction = 1.0f;
361      float char_height = blob->bounding_box().height();
362      float normal_height = char_height;
363      if (wc.unicharset()->top_bottom_useful()) {
364        int min_bot, max_bot, min_top, max_top;
365        wc.unicharset()->get_top_bottom(unichar_id, &min_bot, &max_bot, &min_top, &max_top);
366        float hi_height = max_top - max_bot;
367        float lo_height = min_top - min_bot;
<span onclick='openModal()' class='match'>368        normal_height = (hi_height + lo_height) / 2;
369        if (normal_height >= kBlnXHeight) {
370          height_fraction = char_height / normal_height;
371        }
372      }
373      bool bad_height = height_fraction < superscript_scaledown_ratio;
374      if (debug) {
</span>375        if (is_italic) {
376          tprintf(" Rejecting: superscript is italic.\n");
377        }
378        if (is_punc) {
379          tprintf(" Rejecting: punctuation present.\n");
380        }
381        const char *char_str = wc.unicharset()->id_to_unichar(unichar_id);
382        if (bad_certainty) {
383          tprintf(
384              " Rejecting: don't believe character %s with certainty %.2f "
385              "which is less than threshold %.2f\n",
386              char_str, char_certainty, certainty_threshold);
387        }
388        if (bad_height) {
389          tprintf(
390              " Rejecting: character %s seems too small @ %.2f versus "
391              "expected %.2f\n",
392              char_str, char_height, normal_height);
393        }
394      }
395      if (bad_certainty || bad_height || is_punc || is_italic) {
396        if (ok_run_count == i) {
397          initial_ok_run_count = ok_run_count;
398        }
399        ok_run_count = 0;
400      } else {
401        ok_run_count++;
402      }
403      if (char_certainty < worst_certainty) {
404        worst_certainty = char_certainty;
405      }
406    }
407    bool all_ok = ok_run_count == wc.length();
408    if (all_ok && debug) {
409      tprintf(" Accept: worst revised certainty is %.2f\n", worst_certainty);
410    }
411    if (!all_ok) {
412      if (left_ok) {
413        *left_ok = initial_ok_run_count;
414      }
415      if (right_ok) {
416        *right_ok = ok_run_count;
417      }
418    }
419    return all_ok;
420  }
421  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-networkio.cpp</h3>
            <pre><code>1  #include "networkio.h"
2  #include <cfloat> 
3  #include <cmath>
4  #include <allheaders.h>
5  #include "functions.h"
6  #include "statistc.h"
7  #include "tprintf.h"
8  namespace tesseract {
9  const float kMinCertainty = -20.0f;
10  const float kMinProb = std::exp(kMinCertainty);
11  void NetworkIO::Resize2d(bool int_mode, int width, int num_features) {
12    stride_map_ = StrideMap();
13    int_mode_ = int_mode;
14    if (int_mode_) {
15      i_.ResizeNoInit(width, num_features, GetPadding(num_features));
16    } else {
17      f_.ResizeNoInit(width, num_features);
18    }
19  }
20  void NetworkIO::ResizeToMap(bool int_mode, const StrideMap &stride_map, int num_features) {
21    stride_map_ = stride_map;
22    int_mode_ = int_mode;
23    if (int_mode_) {
24      i_.ResizeNoInit(stride_map.Width(), num_features, GetPadding(num_features));
25    } else {
26      f_.ResizeNoInit(stride_map.Width(), num_features);
27    }
28    ZeroInvalidElements();
29  }
30  void NetworkIO::ResizeScaled(const NetworkIO &src, int x_scale, int y_scale, int num_features) {
31    StrideMap stride_map = src.stride_map_;
32    stride_map.ScaleXY(x_scale, y_scale);
33    ResizeToMap(src.int_mode_, stride_map, num_features);
34  }
35  void NetworkIO::ResizeXTo1(const NetworkIO &src, int num_features) {
36    StrideMap stride_map = src.stride_map_;
37    stride_map.ReduceWidthTo1();
38    ResizeToMap(src.int_mode_, stride_map, num_features);
39  }
40  void NetworkIO::Zero() {
41    int width = Width();
42    for (int t = 0; t < width; ++t) {
43      ZeroTimeStep(t);
44    }
45  }
46  void NetworkIO::ZeroInvalidElements() {
47    int num_features = NumFeatures();
48    int full_width = stride_map_.Size(FD_WIDTH);
49    int full_height = stride_map_.Size(FD_HEIGHT);
50    StrideMap::Index b_index(stride_map_);
51    do {
52      int end_x = b_index.MaxIndexOfDim(FD_WIDTH) + 1;
53      if (end_x < full_width) {
54        StrideMap::Index y_index(b_index);
55        int fill_size = num_features * (full_width - end_x);
56        do {
57          StrideMap::Index z_index(y_index);
58          z_index.AddOffset(end_x, FD_WIDTH);
59          if (int_mode_) {
60            ZeroVector(fill_size, i_[z_index.t()]);
61          } else {
62            ZeroVector(fill_size, f_[z_index.t()]);
63          }
64        } while (y_index.AddOffset(1, FD_HEIGHT));
65      }
66      int end_y = b_index.MaxIndexOfDim(FD_HEIGHT) + 1;
67      if (end_y < full_height) {
68        StrideMap::Index y_index(b_index);
69        y_index.AddOffset(end_y, FD_HEIGHT);
70        int fill_size = num_features * full_width * (full_height - end_y);
71        if (int_mode_) {
72          ZeroVector(fill_size, i_[y_index.t()]);
73        } else {
74          ZeroVector(fill_size, f_[y_index.t()]);
75        }
76      }
77    } while (b_index.AddOffset(1, FD_BATCH));
78  }
79  static void ComputeBlackWhite(Image pix, float *black, float *white) {
80    int width = pixGetWidth(pix);
81    int height = pixGetHeight(pix);
82    STATS mins(0, 255), maxes(0, 255);
83    if (width >= 3) {
84      int y = height / 2;
85      l_uint32 *line = pixGetData(pix) + pixGetWpl(pix) * y;
86      int prev = GET_DATA_BYTE(line, 0);
87      int curr = GET_DATA_BYTE(line, 1);
88      for (int x = 1; x + 1 < width; ++x) {
89        int next = GET_DATA_BYTE(line, x + 1);
90        if ((curr < prev && curr <= next) || (curr <= prev && curr < next)) {
91          mins.add(curr, 1);
92        }
93        if ((curr > prev && curr >= next) || (curr >= prev && curr > next)) {
94          maxes.add(curr, 1);
95        }
96        prev = curr;
97        curr = next;
98      }
99    }
100    if (mins.get_total() == 0) {
101      mins.add(0, 1);
102    }
103    if (maxes.get_total() == 0) {
104      maxes.add(255, 1);
105    }
106    *black = mins.ile(0.25);
107    *white = maxes.ile(0.75);
108  }
109  void NetworkIO::FromPix(const StaticShape &shape, const Image pix, TRand *randomizer) {
110    std::vector<Image> pixes(1, pix);
111    FromPixes(shape, pixes, randomizer);
112  }
113  void NetworkIO::FromPixes(const StaticShape &shape, const std::vector<Image> &pixes,
114                            TRand *randomizer) {
115    int target_height = shape.height();
116    int target_width = shape.width();
117    std::vector<std::pair<int, int>> h_w_pairs;
118    for (auto &&pix : pixes) {
119      Image var_pix = pix;
120      int width = pixGetWidth(var_pix);
121      if (target_width != 0) {
122        width = target_width;
123      }
124      int height = pixGetHeight(var_pix);
125      if (target_height != 0) {
126        height = target_height;
127      }
128      h_w_pairs.emplace_back(height, width);
129    }
130    stride_map_.SetStride(h_w_pairs);
131    ResizeToMap(int_mode(), stride_map_, shape.depth());
132    for (size_t b = 0; b < pixes.size(); ++b) {
133      Image pix = pixes[b];
134      float black = 0.0f, white = 255.0f;
135      if (shape.depth() != 3) {
136        ComputeBlackWhite(pix, &black, &white);
137      }
138      float contrast = (white - black) / 2.0f;
139      if (contrast <= 0.0f) {
140        contrast = 1.0f;
141      }
142      if (shape.height() == 1) {
143        Copy1DGreyImage(b, pix, black, contrast, randomizer);
144      } else {
145        Copy2DImage(b, pix, black, contrast, randomizer);
146      }
147    }
148  }
149  void NetworkIO::Copy2DImage(int batch, Image pix, float black, float contrast, TRand *randomizer) {
150    int width = pixGetWidth(pix);
151    int height = pixGetHeight(pix);
152    int wpl = pixGetWpl(pix);
153    StrideMap::Index index(stride_map_);
154    index.AddOffset(batch, FD_BATCH);
155    int t = index.t();
156    int target_height = stride_map_.Size(FD_HEIGHT);
157    int target_width = stride_map_.Size(FD_WIDTH);
158    int num_features = NumFeatures();
159    bool color = num_features == 3;
160    if (width > target_width) {
161      width = target_width;
162    }
163    uint32_t *line = pixGetData(pix);
164    for (int y = 0; y < target_height; ++y, line += wpl) {
165      int x = 0;
166      if (y < height) {
167        for (x = 0; x < width; ++x, ++t) {
168          if (color) {
169            int f = 0;
170            for (int c = COLOR_RED; c <= COLOR_BLUE; ++c) {
171              int pixel = GET_DATA_BYTE(line + x, c);
172              SetPixel(t, f++, pixel, black, contrast);
173            }
174          } else {
175            int pixel = GET_DATA_BYTE(line, x);
176            SetPixel(t, 0, pixel, black, contrast);
177          }
178        }
179      }
180      for (; x < target_width; ++x) {
181        Randomize(t++, 0, num_features, randomizer);
182      }
183    }
184  }
185  void NetworkIO::Copy1DGreyImage(int batch, Image pix, float black, float contrast,
186                                  TRand *randomizer) {
187    int width = pixGetWidth(pix);
188    int height = pixGetHeight(pix);
189    ASSERT_HOST(height == NumFeatures());
190    int wpl = pixGetWpl(pix);
191    StrideMap::Index index(stride_map_);
192    index.AddOffset(batch, FD_BATCH);
193    int t = index.t();
194    int target_width = stride_map_.Size(FD_WIDTH);
195    if (width > target_width) {
196      width = target_width;
197    }
198    int x;
199    for (x = 0; x < width; ++x, ++t) {
200      for (int y = 0; y < height; ++y) {
201        uint32_t *line = pixGetData(pix) + wpl * y;
202        int pixel = GET_DATA_BYTE(line, x);
203        SetPixel(t, y, pixel, black, contrast);
204      }
205    }
206    for (; x < target_width; ++x) {
207      Randomize(t++, 0, height, randomizer);
208    }
209  }
210  void NetworkIO::SetPixel(int t, int f, int pixel, float black, float contrast) {
211    float float_pixel = (pixel - black) / contrast - 1.0f;
212    if (int_mode_) {
213      i_[t][f] = ClipToRange<int>(IntCastRounded((INT8_MAX + 1) * float_pixel), -INT8_MAX, INT8_MAX);
214    } else {
215      f_[t][f] = float_pixel;
216    }
217  }
218  Image NetworkIO::ToPix() const {
219    int im_width = stride_map_.Size(FD_WIDTH);
220    int im_height = stride_map_.Size(FD_HEIGHT);
221    int num_features = NumFeatures();
222    int feature_factor = 1;
223    if (num_features == 3) {
224      num_features = 1;
225      feature_factor = 3;
226    }
227    Image pix = pixCreate(im_width, im_height * num_features, 32);
228    StrideMap::Index index(stride_map_);
229    do {
230      int im_x = index.index(FD_WIDTH);
231      int top_im_y = index.index(FD_HEIGHT);
232      int im_y = top_im_y;
233      int t = index.t();
234      if (int_mode_) {
235        const int8_t *features = i_[t];
236        for (int y = 0; y < num_features; ++y, im_y += im_height) {
237          int pixel = features[y * feature_factor];
238          int red = ClipToRange<int>(pixel + 128, 0, 255);
239          int green = red, blue = red;
240          if (feature_factor == 3) {
241            green = ClipToRange<int>(features[y * feature_factor + 1] + 128, 0, 255);
242            blue = ClipToRange<int>(features[y * feature_factor + 2] + 128, 0, 255);
243          } else if (num_features > 3) {
244            red = abs(pixel) * 2;
245            if (pixel >= 0) {
246              green = red;
247              blue = 0;
248            } else {
249              blue = red;
250              green = red = 0;
251            }
252          }
253          pixSetPixel(pix, im_x, im_y,
254                      (red << L_RED_SHIFT) | (green << L_GREEN_SHIFT) | (blue << L_BLUE_SHIFT));
255        }
256      } else {
257        const float *features = f_[t];
258        for (int y = 0; y < num_features; ++y, im_y += im_height) {
259          float pixel = features[y * feature_factor];
260          int red = ClipToRange<int>(IntCastRounded((pixel + 1.0f) * 127.5f), 0, 255);
261          int green = red, blue = red;
262          if (feature_factor == 3) {
263            pixel = features[y * feature_factor + 1];
264            green = ClipToRange<int>(IntCastRounded((pixel + 1.0f) * 127.5f), 0, 255);
265            pixel = features[y * feature_factor + 2];
266            blue = ClipToRange<int>(IntCastRounded((pixel + 1.0f) * 127.5f), 0, 255);
267          } else if (num_features > 3) {
268            red = ClipToRange<int>(IntCastRounded(std::fabs(pixel) * 255), 0, 255);
269            if (pixel >= 0) {
270              green = red;
271              blue = 0;
272            } else {
273              blue = red;
274              green = red = 0;
275            }
276          }
277          pixSetPixel(pix, im_x, im_y,
278                      (red << L_RED_SHIFT) | (green << L_GREEN_SHIFT) | (blue << L_BLUE_SHIFT));
279        }
280      }
281    } while (index.Increment());
282    return pix;
283  }
284  void NetworkIO::Print(int num) const {
285    int num_features = NumFeatures();
286    for (int y = 0; y < num_features; ++y) {
287      for (int t = 0; t < Width(); ++t) {
288        if (num == 0 || t < num || t + num >= Width()) {
289          if (int_mode_) {
290            tprintf(" %g", static_cast<float>(i_[t][y]) / INT8_MAX);
291          } else {
292            tprintf(" %g", f_[t][y]);
293          }
294        }
295      }
296      tprintf("\n");
297    }
298  }
299  void NetworkIO::CopyTimeStepFrom(int dest_t, const NetworkIO &src, int src_t) {
300    ASSERT_HOST(int_mode_ == src.int_mode_);
301    if (int_mode_) {
302      memcpy(i_[dest_t], src.i_[src_t], i_.dim2() * sizeof(i_[0][0]));
303    } else {
304      memcpy(f_[dest_t], src.f_[src_t], f_.dim2() * sizeof(f_[0][0]));
305    }
306  }
307  void NetworkIO::CopyTimeStepGeneral(int dest_t, int dest_offset, int num_features,
308                                      const NetworkIO &src, int src_t, int src_offset) {
309    ASSERT_HOST(int_mode_ == src.int_mode_);
310    if (int_mode_) {
311      memcpy(i_[dest_t] + dest_offset, src.i_[src_t] + src_offset, num_features * sizeof(i_[0][0]));
312    } else {
313      memcpy(f_[dest_t] + dest_offset, src.f_[src_t] + src_offset, num_features * sizeof(f_[0][0]));
314    }
315  }
316  void NetworkIO::Randomize(int t, int offset, int num_features, TRand *randomizer) {
317    if (int_mode_) {
318      int8_t *line = i_[t] + offset;
319      for (int i = 0; i < num_features; ++i) {
320        line[i] = IntCastRounded(randomizer->SignedRand(INT8_MAX));
321      }
322    } else {
323      float *line = f_[t] + offset;
324      for (int i = 0; i < num_features; ++i) {
325        line[i] = randomizer->SignedRand(1.0);
326      }
327    }
328  }
329  int NetworkIO::BestChoiceOverRange(int t_start, int t_end, int not_this, int null_ch, float *rating,
330                                     float *certainty) const {
331    if (t_end <= t_start) {
332      return -1;
333    }
334    int max_char = -1;
335    float min_score = 0.0f;
336    for (int c = 0; c < NumFeatures(); ++c) {
337      if (c == not_this || c == null_ch) {
338        continue;
339      }
340      ScoresOverRange(t_start, t_end, c, null_ch, rating, certainty);
341      if (max_char < 0 || *rating < min_score) {
342        min_score = *rating;
343        max_char = c;
344      }
345    }
346    ScoresOverRange(t_start, t_end, max_char, null_ch, rating, certainty);
347    return max_char;
348  }
349  void NetworkIO::ScoresOverRange(int t_start, int t_end, int choice, int null_ch, float *rating,
350                                  float *certainty) const {
351    ASSERT_HOST(!int_mode_);
352    *rating = 0.0f;
353    *certainty = 0.0f;
354    if (t_end <= t_start || t_end <= 0) {
355      return;
356    }
357    float ratings[3] = {0.0f, 0.0f, 0.0f};
358    float certs[3] = {0.0f, 0.0f, 0.0f};
359    for (int t = t_start; t < t_end; ++t) {
360      const float *line = f_[t];
361      float score = ProbToCertainty(line[choice]);
362      float zero = ProbToCertainty(line[null_ch]);
363      if (t == t_start) {
364        ratings[2] = FLT_MAX;
365        ratings[1] = -score;
366        certs[1] = score;
367      } else {
368        for (int i = 2; i >= 1; --i) {
369          if (ratings[i] > ratings[i - 1]) {
370            ratings[i] = ratings[i - 1];
371            certs[i] = certs[i - 1];
372          }
373        }
374        ratings[2] -= zero;
375        if (zero < certs[2]) {
376          certs[2] = zero;
377        }
<span onclick='openModal()' class='match'>378        ratings[1] -= score;
379        if (score < certs[1]) {
380          certs[1] = score;
381        }
382      }
383      ratings[0] -= zero;
384      if (zero < certs[0]) {
</span>385        certs[0] = zero;
386      }
387    }
388    int best_i = ratings[2] < ratings[1] ? 2 : 1;
389    *rating = ratings[best_i] + t_end - t_start;
390    *certainty = certs[best_i];
391  }
392  int NetworkIO::BestLabel(int t, int not_this, int not_that, float *score) const {
393    ASSERT_HOST(!int_mode_);
394    int best_index = -1;
395    float best_score = -FLT_MAX;
396    const float *line = f_[t];
397    for (int i = 0; i < f_.dim2(); ++i) {
398      if (line[i] > best_score && i != not_this && i != not_that) {
399        best_score = line[i];
400        best_index = i;
401      }
402    }
403    if (score != nullptr) {
404      *score = ProbToCertainty(best_score);
405    }
406    return best_index;
407  }
408  int NetworkIO::PositionOfBestMatch(const std::vector<int> &labels, int start, int end) const {
409    int length = labels.size();
410    int last_start = end - length;
411    int best_start = -1;
412    TFloat best_score = 0;
413    for (int s = start; s <= last_start; ++s) {
414      TFloat score = ScoreOfLabels(labels, s);
415      if (score > best_score || best_start < 0) {
416        best_score = score;
417        best_start = s;
418      }
419    }
420    return best_start;
421  }
422  TFloat NetworkIO::ScoreOfLabels(const std::vector<int> &labels, int start) const {
423    int length = labels.size();
424    TFloat score = 0;
425    for (int i = 0; i < length; ++i) {
426      score += f_(start + i, labels[i]);
427    }
428    return score;
429  }
430  void NetworkIO::SetActivations(int t, int label, float ok_score) {
431    ASSERT_HOST(!int_mode_);
432    int num_classes = NumFeatures();
433    float bad_score = (1.0f - ok_score) / (num_classes - 1);
434    float *targets = f_[t];
435    for (int i = 0; i < num_classes; ++i) {
436      targets[i] = bad_score;
437    }
438    targets[label] = ok_score;
439  }
440  void NetworkIO::EnsureBestLabel(int t, int label) {
441    ASSERT_HOST(!int_mode_);
442    if (BestLabel(t, nullptr) != label) {
443      int num_classes = NumFeatures();
444      float *targets = f_[t];
445      for (int c = 0; c < num_classes; ++c) {
446        if (c == label) {
447          targets[c] += (1.0 - targets[c]) * (2 / 3.0);
448        } else {
449          targets[c] /= 3.0;
450        }
451      }
452    }
453  }
454  float NetworkIO::ProbToCertainty(float prob) {
455    return prob > kMinProb ? std::log(prob) : kMinCertainty;
456  }
457  bool NetworkIO::AnySuspiciousTruth(float confidence_thr) const {
458    int num_features = NumFeatures();
459    for (int t = 0; t < Width(); ++t) {
460      const float *features = f_[t];
461      for (int y = 0; y < num_features; ++y) {
462        float grad = features[y];
463        if (grad < -confidence_thr) {
464          if ((t == 0 || f_[t - 1][y] < confidence_thr / 2) &&
465              (t + 1 == Width() || f_[t + 1][y] < confidence_thr / 2)) {
466            return true; 
467          }
468        }
469      }
470    }
471    return false;
472  }
473  void NetworkIO::ReadTimeStep(int t, TFloat *output) const {
474    if (int_mode_) {
475      const int8_t *line = i_[t];
476      for (int i = 0; i < i_.dim2(); ++i) {
477        output[i] = static_cast<TFloat>(line[i]) / INT8_MAX;
478      }
479    } else {
480      const float *line = f_[t];
481      for (int i = 0; i < f_.dim2(); ++i) {
482        output[i] = static_cast<TFloat>(line[i]);
483      }
484    }
485  }
486  void NetworkIO::AddTimeStep(int t, TFloat *inout) const {
487    int num_features = NumFeatures();
488    if (int_mode_) {
489      const int8_t *line = i_[t];
490      for (int i = 0; i < num_features; ++i) {
491        inout[i] += static_cast<TFloat>(line[i]) / INT8_MAX;
492      }
493    } else {
494      const float *line = f_[t];
495      for (int i = 0; i < num_features; ++i) {
496        inout[i] += line[i];
497      }
498    }
499  }
500  void NetworkIO::AddTimeStepPart(int t, int offset, int num_features, float *inout) const {
501    if (int_mode_) {
502      const int8_t *line = i_[t] + offset;
503      for (int i = 0; i < num_features; ++i) {
504        inout[i] += static_cast<float>(line[i]) / INT8_MAX;
505      }
506    } else {
507      const float *line = f_[t] + offset;
508      for (int i = 0; i < num_features; ++i) {
509        inout[i] += line[i];
510      }
511    }
512  }
513  void NetworkIO::WriteTimeStep(int t, const TFloat *input) {
514    WriteTimeStepPart(t, 0, NumFeatures(), input);
515  }
516  void NetworkIO::WriteTimeStepPart(int t, int offset, int num_features, const TFloat *input) {
517    if (int_mode_) {
518      int8_t *line = i_[t] + offset;
519      for (int i = 0; i < num_features; ++i) {
520        line[i] = ClipToRange<int>(IntCastRounded(input[i] * INT8_MAX), -INT8_MAX, INT8_MAX);
521      }
522    } else {
523      float *line = f_[t] + offset;
524      for (int i = 0; i < num_features; ++i) {
525        line[i] = static_cast<float>(input[i]);
526      }
527    }
528  }
529  void NetworkIO::MaxpoolTimeStep(int dest_t, const NetworkIO &src, int src_t, int *max_line) {
530    ASSERT_HOST(int_mode_ == src.int_mode_);
531    if (int_mode_) {
532      int dim = i_.dim2();
533      int8_t *dest_line = i_[dest_t];
534      const int8_t *src_line = src.i_[src_t];
535      for (int i = 0; i < dim; ++i) {
536        if (dest_line[i] < src_line[i]) {
537          dest_line[i] = src_line[i];
538          max_line[i] = src_t;
539        }
540      }
541    } else {
542      int dim = f_.dim2();
543      float *dest_line = f_[dest_t];
544      const float *src_line = src.f_[src_t];
545      for (int i = 0; i < dim; ++i) {
546        if (dest_line[i] < src_line[i]) {
547          dest_line[i] = src_line[i];
548          max_line[i] = src_t;
549        }
550      }
551    }
552  }
553  void NetworkIO::MaxpoolBackward(const NetworkIO &fwd, const GENERIC_2D_ARRAY<int> &maxes) {
554    ASSERT_HOST(!int_mode_);
555    Zero();
556    StrideMap::Index index(fwd.stride_map_);
557    do {
558      int t = index.t();
559      const int *max_line = maxes[t];
560      const float *fwd_line = fwd.f_[t];
561      int num_features = fwd.f_.dim2();
562      for (int i = 0; i < num_features; ++i) {
563        f_[max_line[i]][i] = fwd_line[i];
564      }
565    } while (index.Increment());
566  }
567  float NetworkIO::MinOfMaxes() const {
568    float min_max = 0.0f;
569    int width = Width();
570    int num_features = NumFeatures();
571    for (int t = 0; t < width; ++t) {
572      float max_value = -FLT_MAX;
573      if (int_mode_) {
574        const int8_t *column = i_[t];
575        for (int i = 0; i < num_features; ++i) {
576          if (column[i] > max_value) {
577            max_value = column[i];
578          }
579        }
580      } else {
581        const float *column = f_[t];
582        for (int i = 0; i < num_features; ++i) {
583          if (column[i] > max_value) {
584            max_value = column[i];
585          }
586        }
587      }
588      if (t == 0 || max_value < min_max) {
589        min_max = max_value;
590      }
591    }
592    return min_max;
593  }
594  void NetworkIO::CombineOutputs(const NetworkIO &base_output, const NetworkIO &combiner_output) {
595    int no = base_output.NumFeatures();
596    ASSERT_HOST(combiner_output.NumFeatures() == no + 1);
597    Resize(base_output, no);
598    int width = Width();
599    if (int_mode_) {
600      for (int t = 0; t < width; ++t) {
601        int8_t *out_line = i_[t];
602        const int8_t *base_line = base_output.i_[t];
603        const int8_t *comb_line = combiner_output.i_[t];
604        float base_weight = static_cast<float>(comb_line[no]) / INT8_MAX;
605        float boost_weight = 1.0f - base_weight;
606        for (int i = 0; i < no; ++i) {
607          out_line[i] = IntCastRounded(base_line[i] * base_weight + comb_line[i] * boost_weight);
608        }
609      }
610    } else {
611      for (int t = 0; t < width; ++t) {
612        float *out_line = f_[t];
613        const float *base_line = base_output.f_[t];
614        const float *comb_line = combiner_output.f_[t];
615        float base_weight = comb_line[no];
616        float boost_weight = 1.0f - base_weight;
617        for (int i = 0; i < no; ++i) {
618          out_line[i] = base_line[i] * base_weight + comb_line[i] * boost_weight;
619        }
620      }
621    }
622  }
623  void NetworkIO::ComputeCombinerDeltas(const NetworkIO &fwd_deltas, const NetworkIO &base_output) {
624    ASSERT_HOST(!int_mode_);
625    int width = Width();
626    int no = NumFeatures() - 1;
627    ASSERT_HOST(fwd_deltas.NumFeatures() == no);
628    ASSERT_HOST(base_output.NumFeatures() == no);
629    for (int t = 0; t < width; ++t) {
630      const float *delta_line = fwd_deltas.f_[t];
631      const float *base_line = base_output.f_[t];
632      float *comb_line = f_[t];
633      float base_weight = comb_line[no];
634      float boost_weight = 1.0f - base_weight;
635      float max_base_delta = 0.0;
636      for (int i = 0; i < no; ++i) {
637        float output = base_line[i] * base_weight + comb_line[i] * boost_weight;
638        float comb_target = delta_line[i] + output;
639        comb_line[i] = comb_target - comb_line[i];
640        float base_delta = std::fabs(comb_target - base_line[i]);
641        if (base_delta > max_base_delta) {
642          max_base_delta = base_delta;
643        }
644      }
645      if (max_base_delta >= 0.5) {
646        comb_line[no] = 0.0 - base_weight;
647      } else {
648        for (int i = 0; i < no; ++i) {
649          if (comb_line[i] > 0.0) {
650            comb_line[i] -= 1.0;
651          }
652        }
653        comb_line[no] = 1.0 - base_weight;
654      }
655    }
656  }
657  void NetworkIO::CopyAll(const NetworkIO &src) {
658    ASSERT_HOST(src.int_mode_ == int_mode_);
659    f_ = src.f_;
660  }
661  void NetworkIO::AddAllToFloat(const NetworkIO &src) {
662    ASSERT_HOST(!int_mode_);
663    ASSERT_HOST(!src.int_mode_);
664    f_ += src.f_;
665  }
666  void NetworkIO::SubtractAllFromFloat(const NetworkIO &src) {
667    ASSERT_HOST(!int_mode_);
668    ASSERT_HOST(!src.int_mode_);
669    f_ -= src.f_;
670  }
671  void NetworkIO::CopyWithNormalization(const NetworkIO &src, const NetworkIO &scale) {
672    ASSERT_HOST(!int_mode_);
673    ASSERT_HOST(!src.int_mode_);
674    ASSERT_HOST(!scale.int_mode_);
675    float src_max = src.f_.MaxAbs();
676    ASSERT_HOST(std::isfinite(src_max));
677    float scale_max = scale.f_.MaxAbs();
678    ASSERT_HOST(std::isfinite(scale_max));
679    if (src_max > 0.0f) {
680      float factor = scale_max / src_max;
681      for (int t = 0; t < src.Width(); ++t) {
682        const float *src_ptr = src.f_[t];
683        float *dest_ptr = f_[t];
684        for (int i = 0; i < src.f_.dim2(); ++i) {
685          dest_ptr[i] = src_ptr[i] * factor;
686        }
687      }
688    } else {
689      f_.Clear();
690    }
691  }
692  void NetworkIO::CopyWithYReversal(const NetworkIO &src) {
693    int num_features = src.NumFeatures();
694    Resize(src, num_features);
695    StrideMap::Index b_index(src.stride_map_);
696    do {
697      int width = b_index.MaxIndexOfDim(FD_WIDTH) + 1;
698      StrideMap::Index fwd_index(b_index);
699      StrideMap::Index rev_index(b_index);
700      rev_index.AddOffset(rev_index.MaxIndexOfDim(FD_HEIGHT), FD_HEIGHT);
701      do {
702        int fwd_t = fwd_index.t();
703        int rev_t = rev_index.t();
704        for (int x = 0; x < width; ++x) {
705          CopyTimeStepFrom(rev_t++, src, fwd_t++);
706        }
707      } while (fwd_index.AddOffset(1, FD_HEIGHT) && rev_index.AddOffset(-1, FD_HEIGHT));
708    } while (b_index.AddOffset(1, FD_BATCH));
709  }
710  void NetworkIO::CopyWithXReversal(const NetworkIO &src) {
711    int num_features = src.NumFeatures();
712    Resize(src, num_features);
713    StrideMap::Index b_index(src.stride_map_);
714    do {
715      StrideMap::Index y_index(b_index);
716      do {
717        StrideMap::Index fwd_index(y_index);
718        StrideMap::Index rev_index(y_index);
719        rev_index.AddOffset(rev_index.MaxIndexOfDim(FD_WIDTH), FD_WIDTH);
720        do {
721          CopyTimeStepFrom(rev_index.t(), src, fwd_index.t());
722        } while (fwd_index.AddOffset(1, FD_WIDTH) && rev_index.AddOffset(-1, FD_WIDTH));
723      } while (y_index.AddOffset(1, FD_HEIGHT));
724    } while (b_index.AddOffset(1, FD_BATCH));
725  }
726  void NetworkIO::CopyWithXYTranspose(const NetworkIO &src) {
727    int num_features = src.NumFeatures();
728    stride_map_ = src.stride_map_;
729    stride_map_.TransposeXY();
730    ResizeToMap(src.int_mode(), stride_map_, num_features);
731    StrideMap::Index src_b_index(src.stride_map_);
732    StrideMap::Index dest_b_index(stride_map_);
733    do {
734      StrideMap::Index src_y_index(src_b_index);
735      StrideMap::Index dest_x_index(dest_b_index);
736      do {
737        StrideMap::Index src_x_index(src_y_index);
738        StrideMap::Index dest_y_index(dest_x_index);
739        do {
740          CopyTimeStepFrom(dest_y_index.t(), src, src_x_index.t());
741        } while (src_x_index.AddOffset(1, FD_WIDTH) && dest_y_index.AddOffset(1, FD_HEIGHT));
742      } while (src_y_index.AddOffset(1, FD_HEIGHT) && dest_x_index.AddOffset(1, FD_WIDTH));
743    } while (src_b_index.AddOffset(1, FD_BATCH) && dest_b_index.AddOffset(1, FD_BATCH));
744  }
745  int NetworkIO::CopyPacking(const NetworkIO &src, int feature_offset) {
746    ASSERT_HOST(int_mode_ == src.int_mode_);
747    int width = src.Width();
748    ASSERT_HOST(width <= Width());
749    int num_features = src.NumFeatures();
750    ASSERT_HOST(num_features + feature_offset <= NumFeatures());
751    if (int_mode_) {
752      for (int t = 0; t < width; ++t) {
753        memcpy(i_[t] + feature_offset, src.i_[t], num_features * sizeof(i_[t][0]));
754      }
755      for (int t = width; t < i_.dim1(); ++t) {
756        memset(i_[t], 0, num_features * sizeof(i_[t][0]));
757      }
758    } else {
759      for (int t = 0; t < width; ++t) {
760        memcpy(f_[t] + feature_offset, src.f_[t], num_features * sizeof(f_[t][0]));
761      }
762      for (int t = width; t < f_.dim1(); ++t) {
763        memset(f_[t], 0, num_features * sizeof(f_[t][0]));
764      }
765    }
766    return num_features + feature_offset;
767  }
768  void NetworkIO::CopyUnpacking(const NetworkIO &src, int feature_offset, int num_features) {
769    Resize(src, num_features);
770    int width = src.Width();
771    ASSERT_HOST(num_features + feature_offset <= src.NumFeatures());
772    if (int_mode_) {
773      for (int t = 0; t < width; ++t) {
774        memcpy(i_[t], src.i_[t] + feature_offset, num_features * sizeof(i_[t][0]));
775      }
776    } else {
777      for (int t = 0; t < width; ++t) {
778        memcpy(f_[t], src.f_[t] + feature_offset, num_features * sizeof(f_[t][0]));
779      }
780    }
781  }
782  void NetworkIO::Transpose(TransposedArray *dest) const {
783    int width = Width();
784    dest->ResizeNoInit(NumFeatures(), width);
785    for (int t = 0; t < width; ++t) {
786      dest->WriteStrided(t, f_[t]);
787    }
788  }
789  void NetworkIO::ClipVector(int t, float range) {
790    ASSERT_HOST(!int_mode_);
791    float *v = f_[t];
792    int dim = f_.dim2();
793    for (int i = 0; i < dim; ++i) {
794      v[i] = ClipToRange<float>(v[i], -range, range);
795    }
796  }
797  int NetworkIO::GetPadding(int num_features) {
798    int padding = 0;
799    if (IntSimdMatrix::intSimdMatrix) {
800      padding = IntSimdMatrix::intSimdMatrix->RoundInputs(num_features) - num_features;
801    }
802    return padding;
803  }
804  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-networkio.cpp</div>
                </div>
                <div class="column column_space"><pre><code>368        normal_height = (hi_height + lo_height) / 2;
369        if (normal_height >= kBlnXHeight) {
370          height_fraction = char_height / normal_height;
371        }
372      }
373      bool bad_height = height_fraction < superscript_scaledown_ratio;
374      if (debug) {
</pre></code></div>
                <div class="column column_space"><pre><code>378        ratings[1] -= score;
379        if (score < certs[1]) {
380          certs[1] = score;
381        }
382      }
383      ratings[0] -= zero;
384      if (zero < certs[0]) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    