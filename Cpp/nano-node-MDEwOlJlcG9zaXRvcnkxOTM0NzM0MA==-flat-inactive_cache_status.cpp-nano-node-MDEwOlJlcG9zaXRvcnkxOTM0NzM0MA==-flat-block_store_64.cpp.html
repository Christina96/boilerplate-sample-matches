
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.8181818181818175%, Tokens: 9</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-inactive_cache_status.cpp</h3>
            <pre><code>1  #include <nano/node/inactive_cache_status.hpp>
<span onclick='openModal()' class='match'>2  bool nano::inactive_cache_status::operator!= (inactive_cache_status const other) const
3  {
4  	return bootstrap_started != other.bootstrap_started
5  	|| election_started != other.election_started
6  	|| confirmed != other.confirmed
7  	|| tally != other.tally;
8  }
9  std::string nano::inactive_cache_status::to_string () const
10  {
11  	std::stringstream ss;
12  	ss << "bootstrap_started=" << bootstrap_started;
13  	ss << ", election_started=" << election_started;
14  	ss << ", confirmed=" << confirmed;
15  	ss << ", tally=" << nano::uint128_union (tally).to_string ();
16  	return ss.str ();
17  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store_64.cpp</h3>
            <pre><code>1  #include <nano/node/rocksdb/block_store.hpp>
2  #include <nano/node/rocksdb/rocksdb.hpp>
3  #include <nano/secure/parallel_traversal.hpp>
4  namespace nano
5  {
6  class block_predecessor_rocksdb_set : public nano::block_visitor
7  {
8  public:
9  	block_predecessor_rocksdb_set (nano::write_transaction const & transaction_a, nano::rocksdb::block_store & block_store_a);
10  	virtual ~block_predecessor_rocksdb_set () = default;
11  	void fill_value (nano::block const & block_a);
12  	void send_block (nano::send_block const & block_a) override;
13  	void receive_block (nano::receive_block const & block_a) override;
14  	void open_block (nano::open_block const & block_a) override;
15  	void change_block (nano::change_block const & block_a) override;
16  	void state_block (nano::state_block const & block_a) override;
17  	nano::write_transaction const & transaction;
18  	nano::rocksdb::block_store & block_store;
19  };
20  }
21  nano::rocksdb::block_store::block_store (nano::rocksdb::store & store_a) :
22  	store{ store_a } {};
23  void nano::rocksdb::block_store::put (nano::write_transaction const & transaction, nano::block_hash const & hash, nano::block const & block)
24  {
25  	debug_assert (block.sideband ().successor.is_zero () || exists (transaction, block.sideband ().successor));
26  	std::vector<uint8_t> vector;
27  	{
28  		nano::vectorstream stream (vector);
29  		nano::serialize_block (stream, block);
30  		block.sideband ().serialize (stream, block.type ());
31  	}
32  	raw_put (transaction, vector, hash);
33  	block_predecessor_rocksdb_set predecessor (transaction, *this);
34  	block.visit (predecessor);
35  	debug_assert (block.previous ().is_zero () || successor (transaction, block.previous ()) == hash);
36  }
37  void nano::rocksdb::block_store::raw_put (nano::write_transaction const & transaction_a, std::vector<uint8_t> const & data, nano::block_hash const & hash_a)
38  {
39  	nano::rocksdb_val value{ data.size (), (void *)data.data () };
40  	auto status = store.put (transaction_a, tables::blocks, hash_a, value);
41  	store.release_assert_success (status);
42  }
43  nano::block_hash nano::rocksdb::block_store::successor (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
44  {
45  	nano::rocksdb_val value;
46  	block_raw_get (transaction_a, hash_a, value);
47  	nano::block_hash result;
48  	if (value.size () != 0)
49  	{
50  		debug_assert (value.size () >= result.bytes.size ());
51  		auto type = block_type_from_raw (value.data ());
52  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()) + block_successor_offset (transaction_a, value.size (), type), result.bytes.size ());
53  		auto error (nano::try_read (stream, result.bytes));
54  		(void)error;
55  		debug_assert (!error);
56  	}
57  	else
58  	{
59  		result.clear ();
60  	}
61  	return result;
62  }
63  void nano::rocksdb::block_store::successor_clear (nano::write_transaction const & transaction, nano::block_hash const & hash)
64  {
65  	nano::rocksdb_val value;
66  	block_raw_get (transaction, hash, value);
67  	debug_assert (value.size () != 0);
68  	auto type = block_type_from_raw (value.data ());
69  	std::vector<uint8_t> data (static_cast<uint8_t *> (value.data ()), static_cast<uint8_t *> (value.data ()) + value.size ());
70  	std::fill_n (data.begin () + block_successor_offset (transaction, value.size (), type), sizeof (nano::block_hash), uint8_t{ 0 });
71  	raw_put (transaction, data, hash);
72  }
73  std::shared_ptr<nano::block> nano::rocksdb::block_store::get (nano::transaction const & transaction, nano::block_hash const & hash) const
74  {
75  	nano::rocksdb_val value;
76  	block_raw_get (transaction, hash, value);
77  	std::shared_ptr<nano::block> result;
78  	if (value.size () != 0)
79  	{
80  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
81  		nano::block_type type;
82  		auto error (try_read (stream, type));
83  		release_assert (!error);
84  		result = nano::deserialize_block (stream, type);
85  		release_assert (result != nullptr);
86  		nano::block_sideband sideband;
87  		error = (sideband.deserialize (stream, type));
88  		release_assert (!error);
89  		result->sideband_set (sideband);
90  	}
91  	return result;
92  }
93  std::shared_ptr<nano::block> nano::rocksdb::block_store::get_no_sideband (nano::transaction const & transaction, nano::block_hash const & hash) const
94  {
95  	nano::rocksdb_val value;
96  	block_raw_get (transaction, hash, value);
97  	std::shared_ptr<nano::block> result;
98  	if (value.size () != 0)
99  	{
100  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
101  		result = nano::deserialize_block (stream);
102  		debug_assert (result != nullptr);
103  	}
104  	return result;
105  }
106  std::shared_ptr<nano::block> nano::rocksdb::block_store::random (nano::transaction const & transaction)
107  {
108  	nano::block_hash hash;
109  	nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
110  	auto existing = begin (transaction, hash);
111  	if (existing == end ())
112  	{
113  		existing = begin (transaction);
114  	}
115  	debug_assert (existing != end ());
116  	return existing->second.block;
117  }
118  void nano::rocksdb::block_store::del (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a)
119  {
120  	auto status = store.del (transaction_a, tables::blocks, hash_a);
121  	store.release_assert_success (status);
122  }
<span onclick='openModal()' class='match'>123  bool nano::rocksdb::block_store::exists (nano::transaction const & transaction, nano::block_hash const & hash)
124  {
125  	nano::rocksdb_val junk;
126  	block_raw_get (transaction, hash, junk);
127  	return junk.size () != 0;
128  }
129  uint64_t nano::rocksdb::block_store::count (nano::transaction const & transaction_a)
130  {
131  	return store.count (transaction_a, tables::blocks);
132  }
</span>133  nano::account nano::rocksdb::block_store::account (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
134  {
135  	auto block (get (transaction_a, hash_a));
136  	debug_assert (block != nullptr);
137  	return account_calculated (*block);
138  }
139  nano::account nano::rocksdb::block_store::account_calculated (nano::block const & block_a) const
140  {
141  	debug_assert (block_a.has_sideband ());
142  	nano::account result (block_a.account ());
143  	if (result.is_zero ())
144  	{
145  		result = block_a.sideband ().account;
146  	}
147  	debug_assert (!result.is_zero ());
148  	return result;
149  }
150  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction) const
151  {
152  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks);
153  }
154  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction, nano::block_hash const & hash) const
155  {
156  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks, hash);
157  }
158  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::end () const
159  {
160  	return nano::store_iterator<nano::block_hash, nano::block_w_sideband> (nullptr);
161  }
162  nano::uint128_t nano::rocksdb::block_store::balance (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
163  {
164  	auto block (get (transaction_a, hash_a));
165  	release_assert (block);
166  	nano::uint128_t result (balance_calculated (block));
167  	return result;
168  }
169  nano::uint128_t nano::rocksdb::block_store::balance_calculated (std::shared_ptr<nano::block> const & block_a) const
170  {
171  	nano::uint128_t result;
172  	switch (block_a->type ())
173  	{
174  		case nano::block_type::open:
175  		case nano::block_type::receive:
176  		case nano::block_type::change:
177  			result = block_a->sideband ().balance.number ();
178  			break;
179  		case nano::block_type::send:
180  			result = boost::polymorphic_downcast<nano::send_block *> (block_a.get ())->hashables.balance.number ();
181  			break;
182  		case nano::block_type::state:
183  			result = boost::polymorphic_downcast<nano::state_block *> (block_a.get ())->hashables.balance.number ();
184  			break;
185  		case nano::block_type::invalid:
186  		case nano::block_type::not_a_block:
187  			release_assert (false);
188  			break;
189  	}
190  	return result;
191  }
192  nano::epoch nano::rocksdb::block_store::version (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
193  {
194  	auto block = get (transaction_a, hash_a);
195  	if (block && block->type () == nano::block_type::state)
196  	{
197  		return block->sideband ().details.epoch;
198  	}
199  	return nano::epoch::epoch_0;
200  }
201  void nano::rocksdb::block_store::for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::block_hash, block_w_sideband>, nano::store_iterator<nano::block_hash, block_w_sideband>)> const & action_a) const
202  {
203  	parallel_traversal<nano::uint256_t> (
204  	[&action_a, this] (nano::uint256_t const & start, nano::uint256_t const & end, bool const is_last) {
205  		auto transaction (this->store.tx_begin_read ());
206  		action_a (transaction, this->begin (transaction, start), !is_last ? this->begin (transaction, end) : this->end ());
207  	});
208  }
209  uint64_t nano::rocksdb::block_store::account_height (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
210  {
211  	auto block = get (transaction_a, hash_a);
212  	return block->sideband ().height;
213  }
214  void nano::rocksdb::block_store::block_raw_get (nano::transaction const & transaction, nano::block_hash const & hash, nano::rocksdb_val & value) const
215  {
216  	auto status = store.get (transaction, tables::blocks, hash, value);
217  	release_assert (store.success (status) || store.not_found (status));
218  }
219  size_t nano::rocksdb::block_store::block_successor_offset (nano::transaction const & transaction_a, size_t entry_size_a, nano::block_type type_a) const
220  {
221  	return entry_size_a - nano::block_sideband::size (type_a);
222  }
223  nano::block_type nano::rocksdb::block_store::block_type_from_raw (void * data_a)
224  {
225  	return static_cast<nano::block_type> ((reinterpret_cast<uint8_t const *> (data_a))[0]);
226  }
227  nano::block_predecessor_rocksdb_set::block_predecessor_rocksdb_set (nano::write_transaction const & transaction_a, nano::rocksdb::block_store & block_store_a) :
228  	transaction{ transaction_a },
229  	block_store{ block_store_a }
230  {
231  }
232  void nano::block_predecessor_rocksdb_set::fill_value (nano::block const & block_a)
233  {
234  	auto hash = block_a.hash ();
235  	nano::rocksdb_val value;
236  	block_store.block_raw_get (transaction, block_a.previous (), value);
237  	debug_assert (value.size () != 0);
238  	auto type = block_store.block_type_from_raw (value.data ());
239  	std::vector<uint8_t> data (static_cast<uint8_t *> (value.data ()), static_cast<uint8_t *> (value.data ()) + value.size ());
240  	std::copy (hash.bytes.begin (), hash.bytes.end (), data.begin () + block_store.block_successor_offset (transaction, value.size (), type));
241  	block_store.raw_put (transaction, data, block_a.previous ());
242  }
243  void nano::block_predecessor_rocksdb_set::send_block (nano::send_block const & block_a)
244  {
245  	fill_value (block_a);
246  }
247  void nano::block_predecessor_rocksdb_set::receive_block (nano::receive_block const & block_a)
248  {
249  	fill_value (block_a);
250  }
251  void nano::block_predecessor_rocksdb_set::open_block (nano::open_block const & block_a)
252  {
253  }
254  void nano::block_predecessor_rocksdb_set::change_block (nano::change_block const & block_a)
255  {
256  	fill_value (block_a);
257  }
258  void nano::block_predecessor_rocksdb_set::state_block (nano::state_block const & block_a)
259  {
260  	if (!block_a.previous ().is_zero ())
261  	{
262  		fill_value (block_a);
263  	}
264  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-inactive_cache_status.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store_64.cpp</div>
                <div class="column column_space"><pre><code>2  bool nano::inactive_cache_status::operator!= (inactive_cache_status const other) const
3  {
4  	return bootstrap_started != other.bootstrap_started
5  	|| election_started != other.election_started
6  	|| confirmed != other.confirmed
7  	|| tally != other.tally;
8  }
9  std::string nano::inactive_cache_status::to_string () const
10  {
11  	std::stringstream ss;
12  	ss << "bootstrap_started=" << bootstrap_started;
13  	ss << ", election_started=" << election_started;
14  	ss << ", confirmed=" << confirmed;
15  	ss << ", tally=" << nano::uint128_union (tally).to_string ();
16  	return ss.str ();
17  }
</pre></code></div>
                <div class="column column_space"><pre><code>123  bool nano::rocksdb::block_store::exists (nano::transaction const & transaction, nano::block_hash const & hash)
124  {
125  	nano::rocksdb_val junk;
126  	block_raw_get (transaction, hash, junk);
127  	return junk.size () != 0;
128  }
129  uint64_t nano::rocksdb::block_store::count (nano::transaction const & transaction_a)
130  {
131  	return store.count (transaction_a, tables::blocks);
132  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    