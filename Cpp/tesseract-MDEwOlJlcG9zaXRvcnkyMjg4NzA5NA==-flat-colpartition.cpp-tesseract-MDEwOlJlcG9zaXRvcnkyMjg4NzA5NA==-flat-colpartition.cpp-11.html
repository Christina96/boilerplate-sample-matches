
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &quot;colpartition.h&quot;
5  #include &quot;colpartitiongrid.h&quot;
6  #include &quot;colpartitionset.h&quot;
7  #include &quot;detlinefit.h&quot;
8  #include &quot;dppoint.h&quot;
9  #include &quot;helpers.h&quot; 
10  #include &quot;host.h&quot;    
11  #include &quot;imagefind.h&quot;
12  #include &quot;workingpartset.h&quot;
13  #include &lt;algorithm&gt;
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &amp;vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &amp;box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part-&gt;set_type(block_type);
57    part-&gt;set_flow(flow);
58    part-&gt;AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part-&gt;set_left_margin(box.left());
60    part-&gt;set_right_margin(box.right());
61    part-&gt;SetBlobTypes();
62    part-&gt;ComputeLimits();
63    part-&gt;ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box-&gt;set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single-&gt;set_flow(BTFT_NONE);
71    single-&gt;AddBox(box);
72    single-&gt;ComputeLimits();
73    single-&gt;ClaimBoxes();
74    single-&gt;SetBlobTypes();
75    single-&gt;set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&amp;upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()-&gt;RemovePartner(false, this);
86    }
87    it.set_to_list(&amp;lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()-&gt;RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &amp;vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
96    part-&gt;bounding_box_ = TBOX(left, bottom, right, top);
97    part-&gt;median_bottom_ = bottom;
98    part-&gt;median_top_ = top;
99    part-&gt;median_height_ = top - bottom;
100    part-&gt;median_left_ = left;
101    part-&gt;median_right_ = right;
102    part-&gt;median_width_ = right - left;
103    part-&gt;left_key_ = part-&gt;BoxLeftKey();
104    part-&gt;right_key_ = part-&gt;BoxRightKey();
105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox-&gt;bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom&lt;BLOBNBOX&gt;);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom&lt;BLOBNBOX&gt;, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft&lt;BLOBNBOX&gt;);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft&lt;BLOBNBOX&gt;, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf(&quot;Added box (%d,%d)-&gt;(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n&quot;,
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&amp;boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&amp;boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox-&gt;bounding_box().width() &gt; biggest-&gt;bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox-&gt;bounding_box().height() &gt; biggest-&gt;bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&amp;boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()-&gt;bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&amp;boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob-&gt;owner();
183      if (other == nullptr) {
184        bblob-&gt;set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&amp;boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob-&gt;owner() == this || bblob-&gt;owner() == nullptr);
195      bblob-&gt;set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&amp;boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob-&gt;owner() == this) {
203        bblob-&gt;set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&amp;boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob-&gt;flow() != BTFT_LEADER) {
212        if (bblob-&gt;owner() == this) {
213          bblob-&gt;set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&amp;boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob-&gt;remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&amp;reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&amp;boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&amp;reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ &amp;&amp; !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() &gt; bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf(&quot;Bounding box invalid\n&quot;);
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ &gt; bounding_box_.left() ||
255        right_margin_ &lt; bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf(&quot;Margins invalid\n&quot;);
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ &gt; BoxLeftKey() || right_key_ &lt; BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf(&quot;Key inside box: %d v %d or %d v %d\n&quot;, left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &amp;other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &amp;other) const {
285    if (color1_[L_ALPHA_CHANNEL] &gt; kMaxRMSColorNoise &amp;&amp;
286        other.color1_[L_ALPHA_CHANNEL] &gt; kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o &lt; kMaxColorDistance &amp;&amp; d_this2_o &lt; kMaxColorDistance &amp;&amp;
298           d_o1_this &lt; kMaxColorDistance &amp;&amp; d_o2_this &lt; kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &amp;other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &amp;other) const {
308    if (bounding_box_.right() &lt; other.bounding_box_.left() &amp;&amp;
309        bounding_box_.right() &lt; other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() &lt; bounding_box_.left() &amp;&amp;
313        other.bounding_box_.right() &lt; LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() &gt; other.bounding_box_.right() &amp;&amp;
317        bounding_box_.left() &gt; other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() &gt; bounding_box_.right() &amp;&amp;
321        other.bounding_box_.left() &gt; RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &amp;other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
332    BLOBNBOX_C_IT other_it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() &amp;&amp; !other_it.cycled_list()) {
336      if (box_it.data()-&gt;MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count &gt; nonmatch_count;
346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &amp;candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob-&gt;IsDiacritic()) {
355        if (debug) {
356          tprintf(&quot;Blob is not a diacritic:&quot;);
357          blob-&gt;bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob-&gt;base_char_top() &lt; min_top) {
362        min_top = blob-&gt;base_char_top();
363      }
364      if (blob-&gt;base_char_bottom() &gt; max_bottom) {
365        max_bottom = blob-&gt;base_char_bottom();
366      }
367    }
368    bool result =
369        min_top &gt; candidate.median_bottom_ &amp;&amp; max_bottom &lt; candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf(&quot;OKDiacritic!\n&quot;);
373      } else {
374        tprintf(&quot;y ranges don\&#x27;t overlap: %d-%d / %d-%d\n&quot;, max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector-&gt;sort_key();
383      left_key_tab_ = left_key_ &lt;= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector-&gt;sort_key();
394      right_key_tab_ = right_key_ &gt;= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &amp;src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ &gt; bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &amp;src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ &lt; bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
428    return it.data()-&gt;left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
432    it.move_to_last();
433    return it.data()-&gt;right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type &lt; BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type &lt; BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&amp;boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob-&gt;special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type &lt; BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&amp;boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob-&gt;special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &amp;special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner-&gt;lower_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true, partner);
477    } else {
478      partner-&gt;upper_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &amp;upper_partners_ : &amp;lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &amp;upper_partners_ : &amp;lower_partners_;
494    if (!partners-&gt;singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &amp;cb) {
501    ASSERT_HOST(owns_blobs() == other-&gt;owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other-&gt;bounding_box_.left(),
505                                  other-&gt;bounding_box_.bottom())) {
506      tprintf(&quot;Merging:&quot;);
507      Print();
508      other-&gt;Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type &lt; BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other-&gt;boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other-&gt;special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) &gt; 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&amp;boxes_);
522    BLOBNBOX_C_IT it2(&amp;other-&gt;boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2-&gt;owner();
526      if (prev_owner != other &amp;&amp; prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2-&gt;set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other-&gt;left_margin_);
536    right_margin_ = std::max(right_margin_, other-&gt;right_margin_);
537    if (other-&gt;left_key_ &lt; left_key_) {
538      left_key_ = other-&gt;left_key_;
539      left_key_tab_ = other-&gt;left_key_tab_;
540    }
541    if (other-&gt;right_key_ &gt; right_key_) {
542      right_key_ = other-&gt;right_key_;
543      right_key_tab_ = other-&gt;right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other-&gt;flow_)) {
546      flow_ = other-&gt;flow_;
547      blob_type_ = other-&gt;blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom&lt;BLOBNBOX&gt;);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft&lt;BLOBNBOX&gt;);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper &lt; 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&amp;partners);
561      part_it.add_list_after(upper ? &amp;other-&gt;upper_partners_
562                                   : &amp;other-&gt;lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner-&gt;RemovePartner(!upper, other);
566        partner-&gt;RemovePartner(!upper, this);
567        partner-&gt;AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &amp;merge1,
576                                    const ColPartition &amp;merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf(&quot;Vertical partition\n&quot;);
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf(&quot;Voverlap %d (%d)\n&quot;, merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() &lt; median_top_ &amp;&amp; merged_box.top() &gt; median_bottom_ &amp;&amp;
594        merged_box.bottom() &lt; bounding_box_.top() - ok_box_overlap &amp;&amp;
595        merged_box.top() &gt; bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf(&quot;Excessive box overlap\n&quot;);
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &amp;box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&amp;boxes_);
608    TBOX left_box(it.data()-&gt;bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox-&gt;bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part-&gt;set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&amp;boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox-&gt;owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part-&gt;boxes_.empty()) {
627        split_part-&gt;AddBox(it.extract());
628        if (owns_blobs() &amp;&amp; prev_owner != nullptr) {
629          bbox-&gt;set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part-&gt;IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part-&gt;left_key_tab_ = false;
640    ComputeLimits();
641    split_part-&gt;ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x &lt;= bounding_box_.left() || split_x &gt;= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part-&gt;set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&amp;boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox-&gt;owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &amp;box = bbox-&gt;bounding_box();
656      if (box.left() &gt;= split_x) {
657        split_part-&gt;AddBox(it.extract());
658        if (owns_blobs() &amp;&amp; prev_owner != nullptr) {
659          bbox-&gt;set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&amp;split_part-&gt;boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part-&gt;IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part-&gt;left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part-&gt;left_margin_ = split_x;
675    ComputeLimits();
676    split_part-&gt;ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&amp;boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox-&gt;bounding_box();
693        if (bbox-&gt;flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ &gt; BoxLeftKey() &amp;&amp; textord_debug_bugs) {
702      tprintf(&quot;Computed left-illegal partition\n&quot;);
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ &lt; BoxRightKey() &amp;&amp; textord_debug_bugs) {
709      tprintf(&quot;Computed right-illegal partition\n&quot;);
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox-&gt;flow() != BTFT_LEADER) {
733          const TBOX &amp;box = bbox-&gt;bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast&lt;int&gt;(top_stats.median() + 0.5);
744      median_bottom_ = static_cast&lt;int&gt;(bottom_stats.median() + 0.5);
745      median_height_ = static_cast&lt;int&gt;(height_stats.median() + 0.5);
746      median_left_ = static_cast&lt;int&gt;(left_stats.median() + 0.5);
747      median_right_ = static_cast&lt;int&gt;(right_stats.median() + 0.5);
748      median_width_ = static_cast&lt;int&gt;(width_stats.median() + 0.5);
749    }
750    if (right_margin_ &lt; bounding_box_.right() &amp;&amp; textord_debug_bugs) {
751      tprintf(&quot;Made partition with bad right coords, %d &lt; %d\n&quot;, right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ &gt; bounding_box_.left() &amp;&amp; textord_debug_bugs) {
756      tprintf(&quot;Made partition with bad left coords, %d &gt; %d\n&quot;, left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper &lt; 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&amp;partners);
763      part_it.add_list_after(upper ? &amp;upper_partners_ : &amp;lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner-&gt;RemovePartner(!upper, this);
767        partner-&gt;AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf(&quot;Recomputed box for partition %p\n&quot;, static_cast&lt;void *&gt;(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &amp;box) {
777    BLOBNBOX_C_IT it(&amp;boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox-&gt;bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns-&gt;SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &amp;first_column_, &amp;last_column_,
793        &amp;first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ &lt; last_column_ &amp;&amp; span_type == CST_PULLOUT &amp;&amp;
796        !IsLineType()) {
797      if (first_spanned_col &gt;= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ &amp; 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ &amp; 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE &amp;&amp; blob_type_ != BRT_VLINE &amp;&amp;
815          blob_type_ != BRT_RECTIMAGE &amp;&amp; blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!&quot;Undefined flow type for image!&quot;);
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!&quot;Undefined flow type for text!&quot;);
854        }
855    }
856    ASSERT_HOST(!&quot;Should never get here!&quot;);
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns-&gt;SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &amp;first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &amp;cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT &amp;&amp; left_key_tab_ &amp;&amp; right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&amp;boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob-&gt;set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob-&gt;bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob-&gt;bounding_box().left();
887      int right = blob-&gt;bounding_box().right();
888      gap_stats.add(left - prev_blob-&gt;bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob-&gt;set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind &gt;= 4) {
900      tprintf(&quot;gap iqr = %g, blob_count=%d, limits=%g,%g\n&quot;, gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr &lt; max_width * kMaxLeaderGapFractionOfMax &amp;&amp;
905        gap_iqr &lt; min_width * kMaxLeaderGapFractionOfMin &amp;&amp;
906        blob_count &gt;= kMinLeaderCount) {
907      int offset = static_cast&lt;int&gt;(ceil(gap_iqr * 2));
908      int min_step = static_cast&lt;int&gt;(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob-&gt;bounding_box().left();
917        int right = blob-&gt;bounding_box().right();
918        int height = blob-&gt;bounding_box().height();
919        for (int x = left; x &lt; right; ++x) {
920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &amp;DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr &amp;&amp; best_end-&gt;total_cost() &lt; blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)-&gt;bounding_box().left() -
933                      blob-&gt;bounding_box().right();
934            if (blob-&gt;bounding_box().width() + gap &gt; max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob-&gt;bounding_box().left() -
942                      it.data_relative(-1)-&gt;bounding_box().right();
943            if (blob-&gt;bounding_box().width() + gap &gt; max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob-&gt;set_region_type(BRT_TEXT);
950          blob-&gt;set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf(&quot;No path\n&quot;);
960        } else {
961          tprintf(&quot;Total cost = %d vs allowed %d\n&quot;, best_end-&gt;total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&amp;boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob-&gt;NoisyNeighbours();
980      good_blob_score_ += blob-&gt;GoodTextBlob();
981      if (blob-&gt;region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob-&gt;region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count &gt; vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count &gt; hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value &lt; -1 || 1 &lt; value) {
997      int long_side;
998      int short_side;
999      if (value &gt; 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count &gt;= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side &gt; kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect &lt; long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) &gt;= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) &gt;= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN &amp;&amp; strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN &amp;&amp; value &lt; 0 &amp;&amp; strong_score &lt; 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count &gt;= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf(&quot;RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,&quot;,
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(&quot; Projection value=%d, flow=%d, blob_type=%d\n&quot;, value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&amp;boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob-&gt;flow() != BTFT_LEADER) {
1053        blob-&gt;set_flow(flow_);
1054      }
1055      blob-&gt;set_region_type(blob_type_);
1056      ASSERT_HOST(blob-&gt;owner() == nullptr || blob-&gt;owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&amp;boxes_);
1066    TBOX box(it.data()-&gt;bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob-&gt;bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()-&gt;bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()-&gt;bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob-&gt;bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()-&gt;bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&amp;start_pt, &amp;end_pt);
1107    return error &lt; max_error &amp;&amp; coverage &gt;= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &amp;bleft, const ICOORD &amp;tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr &amp;&amp; partner-&gt;working_set_ != nullptr) {
1120      working_set_ = partner-&gt;working_set_;
1121      working_set_-&gt;AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr &amp;&amp; textord_debug_bugs) {
1125      tprintf(&quot;Partition with partner has no working set!:&quot;);
1126      Print();
1127      partner-&gt;Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() &amp;&amp; col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind &gt;= 2) {
1137      tprintf(&quot;Match is %s for:&quot;, (col_index &amp; 1) ? &quot;Real&quot; : &quot;Between&quot;);
1138      Print();
1139    }
1140    if (it.cycled_list() &amp;&amp; textord_debug_bugs) {
1141      tprintf(&quot;Target column=%d, only had %d\n&quot;, first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() &amp;&amp; last_column_ != first_column_ &amp;&amp; !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() &amp;&amp; col_index &lt;= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set-&gt;ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &amp;completed_blocks, &amp;to_blocks);
1153      }
1154      work_set-&gt;InsertCompletedBlocks(&amp;completed_blocks, &amp;to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set-&gt;AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &amp;bleft, const ICOORD &amp;tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part-&gt;boxes()-&gt;empty());
1172      STATS side_steps(0, part-&gt;bounding_box().height() - 1);
1173      if (part-&gt;bounding_box().height() &gt; max_line_height) {
1174        max_line_height = part-&gt;bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part-&gt;boxes());
1177      int prev_bottom = blob_it.data()-&gt;bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob-&gt;bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step &lt; 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part-&gt;set_side_step(static_cast&lt;int&gt;(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part-&gt;set_bottom_spacing(part-&gt;median_bottom() -
1192                                 next_part-&gt;median_bottom());
1193        part-&gt;set_top_spacing(part-&gt;median_top() - next_part-&gt;median_top());
1194      } else {
1195        part-&gt;set_bottom_spacing(page_height);
1196        part-&gt;set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part-&gt;Print();
1200        tprintf(&quot;side step = %.2f, top spacing = %d, bottom spacing=%d\n&quot;,
1201                side_steps.median(), part-&gt;top_spacing(), part-&gt;bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&amp;spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part-&gt;bottom_spacing() &gt; same_block_threshold ||
1219          !part-&gt;SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() &amp;&amp; part-&gt;bottom_spacing() &lt;= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                &quot;Spacings unequal: upper:%d/%d, lower:%d/%d,&quot;
1226                &quot; sizes %d %d %d\n&quot;,
1227                part-&gt;top_spacing(), part-&gt;bottom_spacing(),
1228                next_part-&gt;top_spacing(), next_part-&gt;bottom_spacing(),
1229                part-&gt;median_height(), next_part-&gt;median_height(),
1230                third_part != nullptr ? third_part-&gt;median_height() : 0);
1231          }
1232          if (part-&gt;SizesSimilar(*next_part) &amp;&amp;
1233              next_part-&gt;median_height() * kMaxSameBlockLineSpacing &gt;
1234                  part-&gt;bottom_spacing() &amp;&amp;
1235              part-&gt;median_height() * kMaxSameBlockLineSpacing &gt;
1236                  part-&gt;top_spacing()) {
1237            if (third_part == nullptr || !next_part-&gt;SizesSimilar(*third_part) ||
1238                third_part-&gt;median_height() * kMaxSameBlockLineSpacing &lt;=
1239                    next_part-&gt;bottom_spacing() ||
1240                next_part-&gt;median_height() * kMaxSameBlockLineSpacing &lt;=
1241                    next_part-&gt;top_spacing() ||
1242                next_part-&gt;bottom_spacing() &gt; part-&gt;bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf(&quot;Added line to current block.\n&quot;);
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &amp;spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block-&gt;block);
1255        }
1256        sp_block_it.set_to_list(&amp;spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind &amp;&amp; !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf(&quot;Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n&quot;,
1261                  part-&gt;top_spacing(), part-&gt;bottom_spacing(),
1262                  next_part-&gt;top_spacing(), next_part-&gt;bottom_spacing(),
1263                  part-&gt;median_height(), next_part-&gt;median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &amp;bleft, const ICOORD &amp;tright, ICOORD *pos) {
1269    if (pos-&gt;x() &lt; bleft.x()) {
1270      pos-&gt;set_x(bleft.x());
1271    }
1272    if (pos-&gt;x() &gt; tright.x()) {
1273      pos-&gt;set_x(tright.x());
1274    }
1275    if (pos-&gt;y() &lt; bleft.y()) {
1276      pos-&gt;set_y(bleft.y());
1277    }
1278    if (pos-&gt;y() &gt; tright.y()) {
1279      pos-&gt;set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block-&gt;pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block-&gt;pdblk.poly_block()-&gt;IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&amp;to_block-&gt;blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part-&gt;boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob-&gt;owner() != part) {
1297          tprintf(&quot;Ownership incorrect for blob:&quot;);
1298          bblob-&gt;bounding_box().print();
1299          tprintf(&quot;Part=&quot;);
1300          part-&gt;Print();
1301          if (bblob-&gt;owner() == nullptr) {
1302            tprintf(&quot;Not owned\n&quot;);
1303          } else {
1304            tprintf(&quot;Owner part:&quot;);
1305            bblob-&gt;owner()-&gt;Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob-&gt;owner() == part);
1309        ASSERT_HOST(!text_type || bblob-&gt;region_type() &gt;= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob-&gt;cblob()-&gt;out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()-&gt;pathlength() &gt; 0);
1313        if (vertical_text) {
1314          sizes.add(bblob-&gt;bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob-&gt;bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type &amp;&amp; blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block-&gt;line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block-&gt;pdblk.bounding_box().width();
1330      if (block_width &lt; line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block-&gt;line_spacing = static_cast&lt;float&gt;(line_spacing);
1334      to_block-&gt;max_blob_size = static_cast&lt;float&gt;(block_width + 1);
1335    } else {
1336      int block_height = block-&gt;pdblk.bounding_box().height();
1337      if (block_height &lt; line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block-&gt;line_spacing = static_cast&lt;float&gt;(line_spacing);
1341      to_block-&gt;max_blob_size = static_cast&lt;float&gt;(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &amp;bleft, const ICOORD &amp;tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts-&gt;empty()) {
1349      return nullptr; 
1350    }
1351    block_parts-&gt;sort(&amp;ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part-&gt;type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part-&gt;bottom_spacing();
1359    if (line_spacing &lt; part-&gt;median_height()) {
1360      line_spacing = part-&gt;bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&amp;vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&amp;it, &amp;start, &amp;end);
1373      } else {
1374        ColPartition::RightEdgeRun(&amp;it, &amp;start, &amp;end);
1375      }
1376      ClipCoord(bleft, tright, &amp;start);
1377      ClipCoord(bleft, tright, &amp;end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &amp;min_x, &amp;max_x);
1381      UpdateRange(end.x(), &amp;min_x, &amp;max_x);
1382      UpdateRange(start.y(), &amp;min_y, &amp;max_y);
1383      UpdateRange(end.y(), &amp;min_y, &amp;max_y);
1384      if ((iteration == 0 &amp;&amp; it.at_first()) || (iteration == 1 &amp;&amp; it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration &lt; 2);
1389    if (textord_debug_tabfind) {
1390      tprintf(&quot;Making block at (%d,%d)-&gt;(%d,%d)\n&quot;, min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK(&quot;&quot;, true, 0, 0, min_x, min_y, max_x, max_y);
1393    block-&gt;pdblk.set_poly_block(new POLY_BLOCK(&amp;vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &amp;bleft,
1397                                                const ICOORD &amp;tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts-&gt;empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part-&gt;bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()-&gt;type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()-&gt;bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf(&quot;Making block at:&quot;);
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK(&quot;&quot;, true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block-&gt;pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&amp;boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob-&gt;bounding_box().top();
1427      int bottom = blob-&gt;bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast&lt;float&gt;(top), static_cast&lt;float&gt;(bottom),
1431                       static_cast&lt;float&gt;(line_size));
1432      } else {
1433        row-&gt;add_blob(blob, static_cast&lt;float&gt;(top), static_cast&lt;float&gt;(bottom),
1434                      static_cast&lt;float&gt;(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part-&gt;left_margin_ = left_margin_;
1442    part-&gt;right_margin_ = right_margin_;
1443    part-&gt;bounding_box_ = bounding_box_;
1444    memcpy(part-&gt;special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part-&gt;median_bottom_ = median_bottom_;
1447    part-&gt;median_top_ = median_top_;
1448    part-&gt;median_height_ = median_height_;
1449    part-&gt;median_left_ = median_left_;
1450    part-&gt;median_right_ = median_right_;
1451    part-&gt;median_width_ = median_width_;
1452    part-&gt;good_width_ = good_width_;
1453    part-&gt;good_column_ = good_column_;
1454    part-&gt;left_key_tab_ = left_key_tab_;
1455    part-&gt;right_key_tab_ = right_key_tab_;
1456    part-&gt;type_ = type_;
1457    part-&gt;flow_ = flow_;
1458    part-&gt;left_key_ = left_key_;
1459    part-&gt;right_key_ = right_key_;
1460    part-&gt;first_column_ = first_column_;
1461    part-&gt;last_column_ = last_column_;
1462    part-&gt;owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy-&gt;set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy-&gt;boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = &quot;NHSRIUVT&quot;;
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        &quot;ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)-&gt;(%dB-%d%c-%dM/%d,%d/%d)&quot;
1489        &quot; w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d&quot;
1490        &quot; ts=%d bs=%d ls=%d rs=%d\n&quot;,
1491        boxes_.empty() ? &#x27;E&#x27; : &#x27; &#x27;, left_margin_, left_key_tab_ ? &#x27;T&#x27; : &#x27;B&#x27;,
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? &#x27;T&#x27; : &#x27;B&#x27;, right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf(&quot;Colors:(%d, %d, %d)%d -&gt; (%d, %d, %d)\n&quot;, color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner-&gt;SingletonPartner(false)) {
1512      if (partner-&gt;type_ &gt; max_type) {
1513        max_type = partner-&gt;type_;
1514      }
1515      if (column_set_ == partner-&gt;column_set_) {
1516        left_stats.add(partner-&gt;first_column_, 1);
1517        right_stats.add(partner-&gt;last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ &lt; first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner-&gt;SingletonPartner(false)) {
1529      partner-&gt;type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner-&gt;column_set_) {
1532        partner-&gt;first_column_ = first_column_;
1533        partner-&gt;last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &amp;upper_partners_);
1545      RefinePartnersByType(false, &amp;lower_partners_);
1546      if (!upper_partners_.empty() &amp;&amp; !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &amp;upper_partners_);
1548      }
1549      if (!lower_partners_.empty() &amp;&amp; !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &amp;lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &amp;upper_partners_ : &amp;lower_partners_;
1557    if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) &amp;&amp; get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf(&quot;Refining %d %s partners by type for:\n&quot;, partners-&gt;length(),
1581              upper ? &quot;Upper&quot; : &quot;Lower&quot;);
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() &amp;&amp; !IsLineType() &amp;&amp; type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner-&gt;type_)) {
1589          if (debug) {
1590            tprintf(&quot;Removing partner:&quot;);
1591            partner-&gt;Print();
1592          }
1593          partner-&gt;RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf(&quot;Keeping partner:&quot;);
1597          partner-&gt;Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner-&gt;blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf(&quot;Removing partner:&quot;);
1607            partner-&gt;Print();
1608          }
1609          partner-&gt;RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf(&quot;Keeping partner:&quot;);
1613          partner-&gt;Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &amp;a-&gt;upper_partners_ : &amp;a-&gt;lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a-&gt;RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2-&gt;RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any &amp;&amp; !partners-&gt;empty() &amp;&amp; !partners-&gt;singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf(&quot;Refining %d %s partners by merge for:\n&quot;, partners-&gt;length(),
1662              upper ? &quot;Upper&quot; : &quot;Lower&quot;);
1663      Print();
1664    }
1665    while (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&amp;candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part-&gt;first_column_ == candidate-&gt;last_column_ &amp;&amp;
1673            part-&gt;last_column_ == candidate-&gt;first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid-&gt;BestMergeCandidate(
1679          part, &amp;candidates, debug, nullptr, &amp;overlap_increase);
1680      if (candidate != nullptr &amp;&amp; (overlap_increase &lt;= 0 || desperate)) {
1681        if (debug) {
1682          tprintf(&quot;Merging:hoverlap=%d, voverlap=%d, OLI=%d\n&quot;,
1683                  part-&gt;HCoreOverlap(*candidate), part-&gt;VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid-&gt;RemoveBBox(candidate);
1687        grid-&gt;RemoveBBox(part);
1688        part-&gt;Absorb(candidate, nullptr);
1689        grid-&gt;InsertBBox(true, true, part);
1690        if (overlap_increase &gt; 0) {
1691          part-&gt;desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf(&quot;Refining %d %s partners by overlap for:\n&quot;, partners-&gt;length(),
1704              upper ? &quot;Upper&quot; : &quot;Lower&quot;);
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner-&gt;bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner-&gt;bounding_box_.left());
1715      if (overlap &gt; best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf(&quot;Removing partner:&quot;);
1725          partner-&gt;Print();
1726        }
1727        partner-&gt;RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &amp;other) {
1734    const TBOX &amp;box = bbox-&gt;bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left &lt; left_margin_ || right &gt; right_margin_) {
1738      return false;
1739    }
1740    if (left &lt; other.left_margin_ || right &gt; other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf(&quot;Unique on (%d,%d)-&gt;(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n&quot;,
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss &lt; other_miss) {
1758      return true;
1759    }
1760    if (this_miss &gt; other_miss) {
1761      return false;
1762    }
1763    if (this_overlap &gt; other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap &lt; other_overlap) {
1767      return false;
1768    }
1769    return median_top_ &gt;= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part-&gt;bottom_spacing(), 1);
1777      stats.add(part-&gt;top_spacing(), 1);
1778    }
1779    return static_cast&lt;int&gt;(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &amp;part) const {
1782    return (last_column_ &gt;= part.first_column_) &amp;&amp;
1783           (first_column_ &lt;= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i &lt; PN_COUNT; ++i) {
1794      if (i &lt; PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]-&gt;SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &amp;&amp;
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &amp;&amp;
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]-&gt;SpacingEqual(median_space, resolution)) &amp;&amp;
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]-&gt;SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper-&gt;bottom_spacing();
1827          total_top += upper-&gt;top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count &gt; 0) {
1833          int top_spacing = static_cast&lt;int&gt;(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast&lt;int&gt;(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf(&quot;Spacing run ended. Cause:&quot;);
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf(&quot;No more lines\n&quot;);
1839            } else {
1840              tprintf(&quot;Spacing change. Spacings:\n&quot;);
1841              for (int i = 0; i &lt; PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf(&quot;NULL&quot;);
1844                  if (i &gt; 0 &amp;&amp; neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]-&gt;SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(&quot; Lower partner:&quot;);
1848                      neighbourhood[i - 1]-&gt;SingletonPartner(false)-&gt;Print();
1849                    } else {
1850                      tprintf(&quot; nullptr lower partner:\n&quot;);
1851                    }
1852                  } else {
1853                    tprintf(&quot;\n&quot;);
1854                  }
1855                } else {
1856                  tprintf(&quot;Top = %d, bottom = %d\n&quot;,
1857                          neighbourhood[i]-&gt;top_spacing(),
1858                          neighbourhood[i]-&gt;bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf(&quot;Mean spacing = %d/%d\n&quot;, top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper-&gt;set_top_spacing(top_spacing);
1868            upper-&gt;set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf(&quot;Setting mean on:&quot;);
1871              upper-&gt;Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j &lt; PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]-&gt;SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &amp;&amp;
1897           ((parts[PN_ABOVE1] != nullptr &amp;&amp;
1898             parts[PN_ABOVE1]-&gt;SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &amp;&amp;
1900             parts[PN_BELOW1]-&gt;SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &amp;&amp;
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &amp;other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &amp;&amp;
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &amp;other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &amp;&amp;
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &amp;&amp;
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast&lt;int&gt;(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast&lt;int&gt;(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &amp;other) const {
1940    return median_height_ &lt;= other.median_height_ * kMaxSizeRatio &amp;&amp;
1941           other.median_height_ &lt;= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &amp;part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &amp;part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key &lt;= *margin_right &amp;&amp; right_key &gt;= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it-&gt;data();
1964    ColPartition *start_part = part;
1965    int start_y = part-&gt;bounding_box_.top();
1966    if (!part_it-&gt;at_first()) {
1967      int prev_bottom = part_it-&gt;data_relative(-1)-&gt;bounding_box_.bottom();
1968      if (prev_bottom &lt; start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom &gt; start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part-&gt;bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &amp;margin_left, &amp;margin_right);
1978    do {
1979      part_it-&gt;forward();
1980      part = part_it-&gt;data();
1981    } while (!part_it-&gt;at_first() &amp;&amp;
1982             UpdateLeftMargin(*part, &amp;margin_left, &amp;margin_right));
1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right);
1986    if (next_margin_left &gt; margin_right) {
1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &amp;&amp;
1992               UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
1993      do {
1994        part_it-&gt;backward();
1995        part = part_it-&gt;data();
1996      } while (part != start_part &amp;&amp;
1997               UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
1998      part_it-&gt;forward();
1999    }
2000    part = part_it-&gt;data_relative(-1);
2001    end_y = part-&gt;bounding_box_.bottom();
2002    if (!part_it-&gt;at_first() &amp;&amp; part_it-&gt;data()-&gt;bounding_box_.top() &lt; end_y) {
2003      end_y = (end_y + part_it-&gt;data()-&gt;bounding_box_.top()) / 2;
2004    }
2005    start-&gt;set_y(start_y);
2006    start-&gt;set_x(part-&gt;XAtY(margin_right, start_y));
2007    end-&gt;set_y(end_y);
2008    end-&gt;set_x(part-&gt;XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind &amp;&amp; !part_it-&gt;at_first()) {
2010      tprintf(&quot;Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n&quot;,
2011              start_y, end_y, part-&gt;XAtY(margin_left, end_y), end-&gt;x(),
2012              part-&gt;left_margin_, part-&gt;bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &amp;part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &amp;part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key &lt;= *margin_right &amp;&amp; right_key &gt;= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it-&gt;data();
2036    ColPartition *start_part = part;
2037    int start_y = part-&gt;bounding_box_.bottom();
2038    if (!part_it-&gt;at_last()) {
2039      int next_y = part_it-&gt;data_relative(1)-&gt;bounding_box_.top();
2040      if (next_y &gt; start_y) {
2041        start_y = next_y;
2042      } else if (next_y &lt; start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part-&gt;bounding_box_.top();
<span onclick='openModal()' class='match'>2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &amp;margin_left, &amp;margin_right);
2050    do {
</span>2051      part_it-&gt;backward();
2052      part = part_it-&gt;data();
2053    } while (!part_it-&gt;at_last() &amp;&amp;
2054             UpdateRightMargin(*part, &amp;margin_left, &amp;margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &amp;next_margin_left, &amp;next_margin_right);
2058    if (next_margin_right &lt; margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &amp;&amp;
2064               UpdateRightMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
2065      do {
2066        part_it-&gt;forward();
2067        part = part_it-&gt;data();
2068      } while (part != start_part &amp;&amp;
2069               UpdateRightMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
2070      part_it-&gt;backward();
2071    }
2072    part = part_it-&gt;data_relative(1);
2073    end_y = part-&gt;bounding_box().top();
2074    if (!part_it-&gt;at_last() &amp;&amp; part_it-&gt;data()-&gt;bounding_box_.bottom() &gt; end_y) {
2075      end_y = (end_y + part_it-&gt;data()-&gt;bounding_box_.bottom()) / 2;
2076    }
2077    start-&gt;set_y(start_y);
2078    start-&gt;set_x(part-&gt;XAtY(margin_left, start_y));
2079    end-&gt;set_y(end_y);
2080    end-&gt;set_x(part-&gt;XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind &amp;&amp; !part_it-&gt;at_last()) {
2082      tprintf(&quot;Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n&quot;,
2083              start_y, end_y, end-&gt;x(), part-&gt;XAtY(margin_right, end_y),
2084              part-&gt;bounding_box_.right(), part-&gt;right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &quot;colpartition.h&quot;
5  #include &quot;colpartitiongrid.h&quot;
6  #include &quot;colpartitionset.h&quot;
7  #include &quot;detlinefit.h&quot;
8  #include &quot;dppoint.h&quot;
9  #include &quot;helpers.h&quot; 
10  #include &quot;host.h&quot;    
11  #include &quot;imagefind.h&quot;
12  #include &quot;workingpartset.h&quot;
13  #include &lt;algorithm&gt;
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &amp;vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &amp;box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part-&gt;set_type(block_type);
57    part-&gt;set_flow(flow);
58    part-&gt;AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part-&gt;set_left_margin(box.left());
60    part-&gt;set_right_margin(box.right());
61    part-&gt;SetBlobTypes();
62    part-&gt;ComputeLimits();
63    part-&gt;ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box-&gt;set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single-&gt;set_flow(BTFT_NONE);
71    single-&gt;AddBox(box);
72    single-&gt;ComputeLimits();
73    single-&gt;ClaimBoxes();
74    single-&gt;SetBlobTypes();
75    single-&gt;set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&amp;upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()-&gt;RemovePartner(false, this);
86    }
87    it.set_to_list(&amp;lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()-&gt;RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &amp;vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
96    part-&gt;bounding_box_ = TBOX(left, bottom, right, top);
97    part-&gt;median_bottom_ = bottom;
98    part-&gt;median_top_ = top;
99    part-&gt;median_height_ = top - bottom;
100    part-&gt;median_left_ = left;
101    part-&gt;median_right_ = right;
102    part-&gt;median_width_ = right - left;
103    part-&gt;left_key_ = part-&gt;BoxLeftKey();
104    part-&gt;right_key_ = part-&gt;BoxRightKey();
105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox-&gt;bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom&lt;BLOBNBOX&gt;);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom&lt;BLOBNBOX&gt;, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft&lt;BLOBNBOX&gt;);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft&lt;BLOBNBOX&gt;, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf(&quot;Added box (%d,%d)-&gt;(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n&quot;,
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&amp;boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&amp;boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox-&gt;bounding_box().width() &gt; biggest-&gt;bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox-&gt;bounding_box().height() &gt; biggest-&gt;bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&amp;boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()-&gt;bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&amp;boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob-&gt;owner();
183      if (other == nullptr) {
184        bblob-&gt;set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&amp;boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob-&gt;owner() == this || bblob-&gt;owner() == nullptr);
195      bblob-&gt;set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&amp;boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob-&gt;owner() == this) {
203        bblob-&gt;set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&amp;boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob-&gt;flow() != BTFT_LEADER) {
212        if (bblob-&gt;owner() == this) {
213          bblob-&gt;set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&amp;boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob-&gt;remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&amp;reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&amp;boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&amp;reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ &amp;&amp; !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() &gt; bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf(&quot;Bounding box invalid\n&quot;);
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ &gt; bounding_box_.left() ||
255        right_margin_ &lt; bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf(&quot;Margins invalid\n&quot;);
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ &gt; BoxLeftKey() || right_key_ &lt; BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf(&quot;Key inside box: %d v %d or %d v %d\n&quot;, left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &amp;other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &amp;other) const {
285    if (color1_[L_ALPHA_CHANNEL] &gt; kMaxRMSColorNoise &amp;&amp;
286        other.color1_[L_ALPHA_CHANNEL] &gt; kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o &lt; kMaxColorDistance &amp;&amp; d_this2_o &lt; kMaxColorDistance &amp;&amp;
298           d_o1_this &lt; kMaxColorDistance &amp;&amp; d_o2_this &lt; kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &amp;other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &amp;other) const {
308    if (bounding_box_.right() &lt; other.bounding_box_.left() &amp;&amp;
309        bounding_box_.right() &lt; other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() &lt; bounding_box_.left() &amp;&amp;
313        other.bounding_box_.right() &lt; LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() &gt; other.bounding_box_.right() &amp;&amp;
317        bounding_box_.left() &gt; other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() &gt; bounding_box_.right() &amp;&amp;
321        other.bounding_box_.left() &gt; RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &amp;other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
332    BLOBNBOX_C_IT other_it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() &amp;&amp; !other_it.cycled_list()) {
336      if (box_it.data()-&gt;MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count &gt; nonmatch_count;
346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &amp;candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob-&gt;IsDiacritic()) {
355        if (debug) {
356          tprintf(&quot;Blob is not a diacritic:&quot;);
357          blob-&gt;bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob-&gt;base_char_top() &lt; min_top) {
362        min_top = blob-&gt;base_char_top();
363      }
364      if (blob-&gt;base_char_bottom() &gt; max_bottom) {
365        max_bottom = blob-&gt;base_char_bottom();
366      }
367    }
368    bool result =
369        min_top &gt; candidate.median_bottom_ &amp;&amp; max_bottom &lt; candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf(&quot;OKDiacritic!\n&quot;);
373      } else {
374        tprintf(&quot;y ranges don\&#x27;t overlap: %d-%d / %d-%d\n&quot;, max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector-&gt;sort_key();
383      left_key_tab_ = left_key_ &lt;= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector-&gt;sort_key();
394      right_key_tab_ = right_key_ &gt;= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &amp;src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ &gt; bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &amp;src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ &lt; bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
428    return it.data()-&gt;left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast&lt;BLOBNBOX_CLIST *&gt;(&amp;boxes_));
432    it.move_to_last();
433    return it.data()-&gt;right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type &lt; BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type &lt; BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&amp;boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob-&gt;special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type &lt; BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&amp;boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob-&gt;special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &amp;special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner-&gt;lower_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true, partner);
477    } else {
478      partner-&gt;upper_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft&lt;ColPartition&gt;, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &amp;upper_partners_ : &amp;lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &amp;upper_partners_ : &amp;lower_partners_;
494    if (!partners-&gt;singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &amp;cb) {
501    ASSERT_HOST(owns_blobs() == other-&gt;owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other-&gt;bounding_box_.left(),
505                                  other-&gt;bounding_box_.bottom())) {
506      tprintf(&quot;Merging:&quot;);
507      Print();
508      other-&gt;Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type &lt; BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other-&gt;boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other-&gt;special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) &gt; 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&amp;boxes_);
522    BLOBNBOX_C_IT it2(&amp;other-&gt;boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2-&gt;owner();
526      if (prev_owner != other &amp;&amp; prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2-&gt;set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other-&gt;left_margin_);
536    right_margin_ = std::max(right_margin_, other-&gt;right_margin_);
537    if (other-&gt;left_key_ &lt; left_key_) {
538      left_key_ = other-&gt;left_key_;
539      left_key_tab_ = other-&gt;left_key_tab_;
540    }
541    if (other-&gt;right_key_ &gt; right_key_) {
542      right_key_ = other-&gt;right_key_;
543      right_key_tab_ = other-&gt;right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other-&gt;flow_)) {
546      flow_ = other-&gt;flow_;
547      blob_type_ = other-&gt;blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom&lt;BLOBNBOX&gt;);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft&lt;BLOBNBOX&gt;);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper &lt; 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&amp;partners);
561      part_it.add_list_after(upper ? &amp;other-&gt;upper_partners_
562                                   : &amp;other-&gt;lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner-&gt;RemovePartner(!upper, other);
566        partner-&gt;RemovePartner(!upper, this);
567        partner-&gt;AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &amp;merge1,
576                                    const ColPartition &amp;merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf(&quot;Vertical partition\n&quot;);
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf(&quot;Voverlap %d (%d)\n&quot;, merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() &lt; median_top_ &amp;&amp; merged_box.top() &gt; median_bottom_ &amp;&amp;
594        merged_box.bottom() &lt; bounding_box_.top() - ok_box_overlap &amp;&amp;
595        merged_box.top() &gt; bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf(&quot;Excessive box overlap\n&quot;);
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &amp;box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&amp;boxes_);
608    TBOX left_box(it.data()-&gt;bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox-&gt;bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part-&gt;set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&amp;boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox-&gt;owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part-&gt;boxes_.empty()) {
627        split_part-&gt;AddBox(it.extract());
628        if (owns_blobs() &amp;&amp; prev_owner != nullptr) {
629          bbox-&gt;set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part-&gt;IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part-&gt;left_key_tab_ = false;
640    ComputeLimits();
641    split_part-&gt;ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x &lt;= bounding_box_.left() || split_x &gt;= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part-&gt;set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&amp;boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox-&gt;owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &amp;box = bbox-&gt;bounding_box();
656      if (box.left() &gt;= split_x) {
657        split_part-&gt;AddBox(it.extract());
658        if (owns_blobs() &amp;&amp; prev_owner != nullptr) {
659          bbox-&gt;set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&amp;split_part-&gt;boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part-&gt;IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part-&gt;left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part-&gt;left_margin_ = split_x;
675    ComputeLimits();
676    split_part-&gt;ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&amp;boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox-&gt;bounding_box();
693        if (bbox-&gt;flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ &gt; BoxLeftKey() &amp;&amp; textord_debug_bugs) {
702      tprintf(&quot;Computed left-illegal partition\n&quot;);
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ &lt; BoxRightKey() &amp;&amp; textord_debug_bugs) {
709      tprintf(&quot;Computed right-illegal partition\n&quot;);
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox-&gt;flow() != BTFT_LEADER) {
733          const TBOX &amp;box = bbox-&gt;bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast&lt;int&gt;(top_stats.median() + 0.5);
744      median_bottom_ = static_cast&lt;int&gt;(bottom_stats.median() + 0.5);
745      median_height_ = static_cast&lt;int&gt;(height_stats.median() + 0.5);
746      median_left_ = static_cast&lt;int&gt;(left_stats.median() + 0.5);
747      median_right_ = static_cast&lt;int&gt;(right_stats.median() + 0.5);
748      median_width_ = static_cast&lt;int&gt;(width_stats.median() + 0.5);
749    }
750    if (right_margin_ &lt; bounding_box_.right() &amp;&amp; textord_debug_bugs) {
751      tprintf(&quot;Made partition with bad right coords, %d &lt; %d\n&quot;, right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ &gt; bounding_box_.left() &amp;&amp; textord_debug_bugs) {
756      tprintf(&quot;Made partition with bad left coords, %d &gt; %d\n&quot;, left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper &lt; 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&amp;partners);
763      part_it.add_list_after(upper ? &amp;upper_partners_ : &amp;lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner-&gt;RemovePartner(!upper, this);
767        partner-&gt;AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf(&quot;Recomputed box for partition %p\n&quot;, static_cast&lt;void *&gt;(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &amp;box) {
777    BLOBNBOX_C_IT it(&amp;boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox-&gt;bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns-&gt;SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &amp;first_column_, &amp;last_column_,
793        &amp;first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ &lt; last_column_ &amp;&amp; span_type == CST_PULLOUT &amp;&amp;
796        !IsLineType()) {
797      if (first_spanned_col &gt;= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ &amp; 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ &amp; 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE &amp;&amp; blob_type_ != BRT_VLINE &amp;&amp;
815          blob_type_ != BRT_RECTIMAGE &amp;&amp; blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!&quot;Undefined flow type for image!&quot;);
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!&quot;Undefined flow type for text!&quot;);
854        }
855    }
856    ASSERT_HOST(!&quot;Should never get here!&quot;);
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns-&gt;SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &amp;first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &amp;cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT &amp;&amp; left_key_tab_ &amp;&amp; right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&amp;boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob-&gt;set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob-&gt;bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob-&gt;bounding_box().left();
887      int right = blob-&gt;bounding_box().right();
888      gap_stats.add(left - prev_blob-&gt;bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob-&gt;set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind &gt;= 4) {
900      tprintf(&quot;gap iqr = %g, blob_count=%d, limits=%g,%g\n&quot;, gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr &lt; max_width * kMaxLeaderGapFractionOfMax &amp;&amp;
905        gap_iqr &lt; min_width * kMaxLeaderGapFractionOfMin &amp;&amp;
906        blob_count &gt;= kMinLeaderCount) {
907      int offset = static_cast&lt;int&gt;(ceil(gap_iqr * 2));
908      int min_step = static_cast&lt;int&gt;(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob-&gt;bounding_box().left();
917        int right = blob-&gt;bounding_box().right();
918        int height = blob-&gt;bounding_box().height();
919        for (int x = left; x &lt; right; ++x) {
920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &amp;DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr &amp;&amp; best_end-&gt;total_cost() &lt; blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)-&gt;bounding_box().left() -
933                      blob-&gt;bounding_box().right();
934            if (blob-&gt;bounding_box().width() + gap &gt; max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob-&gt;bounding_box().left() -
942                      it.data_relative(-1)-&gt;bounding_box().right();
943            if (blob-&gt;bounding_box().width() + gap &gt; max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob-&gt;set_region_type(BRT_TEXT);
950          blob-&gt;set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf(&quot;No path\n&quot;);
960        } else {
961          tprintf(&quot;Total cost = %d vs allowed %d\n&quot;, best_end-&gt;total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&amp;boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob-&gt;NoisyNeighbours();
980      good_blob_score_ += blob-&gt;GoodTextBlob();
981      if (blob-&gt;region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob-&gt;region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count &gt; vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count &gt; hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value &lt; -1 || 1 &lt; value) {
997      int long_side;
998      int short_side;
999      if (value &gt; 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count &gt;= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side &gt; kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect &lt; long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) &gt;= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) &gt;= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN &amp;&amp; strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN &amp;&amp; value &lt; 0 &amp;&amp; strong_score &lt; 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count &gt;= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf(&quot;RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,&quot;,
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(&quot; Projection value=%d, flow=%d, blob_type=%d\n&quot;, value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&amp;boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob-&gt;flow() != BTFT_LEADER) {
1053        blob-&gt;set_flow(flow_);
1054      }
1055      blob-&gt;set_region_type(blob_type_);
1056      ASSERT_HOST(blob-&gt;owner() == nullptr || blob-&gt;owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&amp;boxes_);
1066    TBOX box(it.data()-&gt;bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob-&gt;bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()-&gt;bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()-&gt;bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob-&gt;bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()-&gt;bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&amp;start_pt, &amp;end_pt);
1107    return error &lt; max_error &amp;&amp; coverage &gt;= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &amp;bleft, const ICOORD &amp;tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr &amp;&amp; partner-&gt;working_set_ != nullptr) {
1120      working_set_ = partner-&gt;working_set_;
1121      working_set_-&gt;AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr &amp;&amp; textord_debug_bugs) {
1125      tprintf(&quot;Partition with partner has no working set!:&quot;);
1126      Print();
1127      partner-&gt;Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() &amp;&amp; col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind &gt;= 2) {
1137      tprintf(&quot;Match is %s for:&quot;, (col_index &amp; 1) ? &quot;Real&quot; : &quot;Between&quot;);
1138      Print();
1139    }
1140    if (it.cycled_list() &amp;&amp; textord_debug_bugs) {
1141      tprintf(&quot;Target column=%d, only had %d\n&quot;, first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() &amp;&amp; last_column_ != first_column_ &amp;&amp; !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() &amp;&amp; col_index &lt;= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set-&gt;ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &amp;completed_blocks, &amp;to_blocks);
1153      }
1154      work_set-&gt;InsertCompletedBlocks(&amp;completed_blocks, &amp;to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set-&gt;AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &amp;bleft, const ICOORD &amp;tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part-&gt;boxes()-&gt;empty());
1172      STATS side_steps(0, part-&gt;bounding_box().height() - 1);
1173      if (part-&gt;bounding_box().height() &gt; max_line_height) {
1174        max_line_height = part-&gt;bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part-&gt;boxes());
1177      int prev_bottom = blob_it.data()-&gt;bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob-&gt;bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step &lt; 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part-&gt;set_side_step(static_cast&lt;int&gt;(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part-&gt;set_bottom_spacing(part-&gt;median_bottom() -
1192                                 next_part-&gt;median_bottom());
1193        part-&gt;set_top_spacing(part-&gt;median_top() - next_part-&gt;median_top());
1194      } else {
1195        part-&gt;set_bottom_spacing(page_height);
1196        part-&gt;set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part-&gt;Print();
1200        tprintf(&quot;side step = %.2f, top spacing = %d, bottom spacing=%d\n&quot;,
1201                side_steps.median(), part-&gt;top_spacing(), part-&gt;bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&amp;spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part-&gt;bottom_spacing() &gt; same_block_threshold ||
1219          !part-&gt;SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() &amp;&amp; part-&gt;bottom_spacing() &lt;= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                &quot;Spacings unequal: upper:%d/%d, lower:%d/%d,&quot;
1226                &quot; sizes %d %d %d\n&quot;,
1227                part-&gt;top_spacing(), part-&gt;bottom_spacing(),
1228                next_part-&gt;top_spacing(), next_part-&gt;bottom_spacing(),
1229                part-&gt;median_height(), next_part-&gt;median_height(),
1230                third_part != nullptr ? third_part-&gt;median_height() : 0);
1231          }
1232          if (part-&gt;SizesSimilar(*next_part) &amp;&amp;
1233              next_part-&gt;median_height() * kMaxSameBlockLineSpacing &gt;
1234                  part-&gt;bottom_spacing() &amp;&amp;
1235              part-&gt;median_height() * kMaxSameBlockLineSpacing &gt;
1236                  part-&gt;top_spacing()) {
1237            if (third_part == nullptr || !next_part-&gt;SizesSimilar(*third_part) ||
1238                third_part-&gt;median_height() * kMaxSameBlockLineSpacing &lt;=
1239                    next_part-&gt;bottom_spacing() ||
1240                next_part-&gt;median_height() * kMaxSameBlockLineSpacing &lt;=
1241                    next_part-&gt;top_spacing() ||
1242                next_part-&gt;bottom_spacing() &gt; part-&gt;bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf(&quot;Added line to current block.\n&quot;);
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &amp;spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block-&gt;block);
1255        }
1256        sp_block_it.set_to_list(&amp;spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind &amp;&amp; !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf(&quot;Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n&quot;,
1261                  part-&gt;top_spacing(), part-&gt;bottom_spacing(),
1262                  next_part-&gt;top_spacing(), next_part-&gt;bottom_spacing(),
1263                  part-&gt;median_height(), next_part-&gt;median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &amp;bleft, const ICOORD &amp;tright, ICOORD *pos) {
1269    if (pos-&gt;x() &lt; bleft.x()) {
1270      pos-&gt;set_x(bleft.x());
1271    }
1272    if (pos-&gt;x() &gt; tright.x()) {
1273      pos-&gt;set_x(tright.x());
1274    }
1275    if (pos-&gt;y() &lt; bleft.y()) {
1276      pos-&gt;set_y(bleft.y());
1277    }
1278    if (pos-&gt;y() &gt; tright.y()) {
1279      pos-&gt;set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block-&gt;pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block-&gt;pdblk.poly_block()-&gt;IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&amp;to_block-&gt;blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part-&gt;boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob-&gt;owner() != part) {
1297          tprintf(&quot;Ownership incorrect for blob:&quot;);
1298          bblob-&gt;bounding_box().print();
1299          tprintf(&quot;Part=&quot;);
1300          part-&gt;Print();
1301          if (bblob-&gt;owner() == nullptr) {
1302            tprintf(&quot;Not owned\n&quot;);
1303          } else {
1304            tprintf(&quot;Owner part:&quot;);
1305            bblob-&gt;owner()-&gt;Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob-&gt;owner() == part);
1309        ASSERT_HOST(!text_type || bblob-&gt;region_type() &gt;= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob-&gt;cblob()-&gt;out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()-&gt;pathlength() &gt; 0);
1313        if (vertical_text) {
1314          sizes.add(bblob-&gt;bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob-&gt;bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type &amp;&amp; blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block-&gt;line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block-&gt;pdblk.bounding_box().width();
1330      if (block_width &lt; line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block-&gt;line_spacing = static_cast&lt;float&gt;(line_spacing);
1334      to_block-&gt;max_blob_size = static_cast&lt;float&gt;(block_width + 1);
1335    } else {
1336      int block_height = block-&gt;pdblk.bounding_box().height();
1337      if (block_height &lt; line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block-&gt;line_spacing = static_cast&lt;float&gt;(line_spacing);
1341      to_block-&gt;max_blob_size = static_cast&lt;float&gt;(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &amp;bleft, const ICOORD &amp;tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts-&gt;empty()) {
1349      return nullptr; 
1350    }
1351    block_parts-&gt;sort(&amp;ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part-&gt;type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part-&gt;bottom_spacing();
1359    if (line_spacing &lt; part-&gt;median_height()) {
1360      line_spacing = part-&gt;bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&amp;vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&amp;it, &amp;start, &amp;end);
1373      } else {
1374        ColPartition::RightEdgeRun(&amp;it, &amp;start, &amp;end);
1375      }
1376      ClipCoord(bleft, tright, &amp;start);
1377      ClipCoord(bleft, tright, &amp;end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &amp;min_x, &amp;max_x);
1381      UpdateRange(end.x(), &amp;min_x, &amp;max_x);
1382      UpdateRange(start.y(), &amp;min_y, &amp;max_y);
1383      UpdateRange(end.y(), &amp;min_y, &amp;max_y);
1384      if ((iteration == 0 &amp;&amp; it.at_first()) || (iteration == 1 &amp;&amp; it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration &lt; 2);
1389    if (textord_debug_tabfind) {
1390      tprintf(&quot;Making block at (%d,%d)-&gt;(%d,%d)\n&quot;, min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK(&quot;&quot;, true, 0, 0, min_x, min_y, max_x, max_y);
1393    block-&gt;pdblk.set_poly_block(new POLY_BLOCK(&amp;vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &amp;bleft,
1397                                                const ICOORD &amp;tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts-&gt;empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part-&gt;bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()-&gt;type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()-&gt;bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf(&quot;Making block at:&quot;);
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK(&quot;&quot;, true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block-&gt;pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&amp;boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob-&gt;bounding_box().top();
1427      int bottom = blob-&gt;bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast&lt;float&gt;(top), static_cast&lt;float&gt;(bottom),
1431                       static_cast&lt;float&gt;(line_size));
1432      } else {
1433        row-&gt;add_blob(blob, static_cast&lt;float&gt;(top), static_cast&lt;float&gt;(bottom),
1434                      static_cast&lt;float&gt;(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part-&gt;left_margin_ = left_margin_;
1442    part-&gt;right_margin_ = right_margin_;
1443    part-&gt;bounding_box_ = bounding_box_;
1444    memcpy(part-&gt;special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part-&gt;median_bottom_ = median_bottom_;
1447    part-&gt;median_top_ = median_top_;
1448    part-&gt;median_height_ = median_height_;
1449    part-&gt;median_left_ = median_left_;
1450    part-&gt;median_right_ = median_right_;
1451    part-&gt;median_width_ = median_width_;
1452    part-&gt;good_width_ = good_width_;
1453    part-&gt;good_column_ = good_column_;
1454    part-&gt;left_key_tab_ = left_key_tab_;
1455    part-&gt;right_key_tab_ = right_key_tab_;
1456    part-&gt;type_ = type_;
1457    part-&gt;flow_ = flow_;
1458    part-&gt;left_key_ = left_key_;
1459    part-&gt;right_key_ = right_key_;
1460    part-&gt;first_column_ = first_column_;
1461    part-&gt;last_column_ = last_column_;
1462    part-&gt;owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy-&gt;set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy-&gt;boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = &quot;NHSRIUVT&quot;;
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        &quot;ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)-&gt;(%dB-%d%c-%dM/%d,%d/%d)&quot;
1489        &quot; w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d&quot;
1490        &quot; ts=%d bs=%d ls=%d rs=%d\n&quot;,
1491        boxes_.empty() ? &#x27;E&#x27; : &#x27; &#x27;, left_margin_, left_key_tab_ ? &#x27;T&#x27; : &#x27;B&#x27;,
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? &#x27;T&#x27; : &#x27;B&#x27;, right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf(&quot;Colors:(%d, %d, %d)%d -&gt; (%d, %d, %d)\n&quot;, color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner-&gt;SingletonPartner(false)) {
1512      if (partner-&gt;type_ &gt; max_type) {
1513        max_type = partner-&gt;type_;
1514      }
1515      if (column_set_ == partner-&gt;column_set_) {
1516        left_stats.add(partner-&gt;first_column_, 1);
1517        right_stats.add(partner-&gt;last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ &lt; first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner-&gt;SingletonPartner(false)) {
1529      partner-&gt;type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner-&gt;column_set_) {
1532        partner-&gt;first_column_ = first_column_;
1533        partner-&gt;last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &amp;upper_partners_);
1545      RefinePartnersByType(false, &amp;lower_partners_);
1546      if (!upper_partners_.empty() &amp;&amp; !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &amp;upper_partners_);
1548      }
1549      if (!lower_partners_.empty() &amp;&amp; !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &amp;lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &amp;upper_partners_ : &amp;lower_partners_;
1557    if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) &amp;&amp; get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf(&quot;Refining %d %s partners by type for:\n&quot;, partners-&gt;length(),
1581              upper ? &quot;Upper&quot; : &quot;Lower&quot;);
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() &amp;&amp; !IsLineType() &amp;&amp; type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner-&gt;type_)) {
1589          if (debug) {
1590            tprintf(&quot;Removing partner:&quot;);
1591            partner-&gt;Print();
1592          }
1593          partner-&gt;RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf(&quot;Keeping partner:&quot;);
1597          partner-&gt;Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner-&gt;blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf(&quot;Removing partner:&quot;);
1607            partner-&gt;Print();
1608          }
1609          partner-&gt;RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf(&quot;Keeping partner:&quot;);
1613          partner-&gt;Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &amp;a-&gt;upper_partners_ : &amp;a-&gt;lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a-&gt;RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2-&gt;RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any &amp;&amp; !partners-&gt;empty() &amp;&amp; !partners-&gt;singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf(&quot;Refining %d %s partners by merge for:\n&quot;, partners-&gt;length(),
1662              upper ? &quot;Upper&quot; : &quot;Lower&quot;);
1663      Print();
1664    }
1665    while (!partners-&gt;empty() &amp;&amp; !partners-&gt;singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&amp;candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part-&gt;first_column_ == candidate-&gt;last_column_ &amp;&amp;
1673            part-&gt;last_column_ == candidate-&gt;first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid-&gt;BestMergeCandidate(
1679          part, &amp;candidates, debug, nullptr, &amp;overlap_increase);
1680      if (candidate != nullptr &amp;&amp; (overlap_increase &lt;= 0 || desperate)) {
1681        if (debug) {
1682          tprintf(&quot;Merging:hoverlap=%d, voverlap=%d, OLI=%d\n&quot;,
1683                  part-&gt;HCoreOverlap(*candidate), part-&gt;VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid-&gt;RemoveBBox(candidate);
1687        grid-&gt;RemoveBBox(part);
1688        part-&gt;Absorb(candidate, nullptr);
1689        grid-&gt;InsertBBox(true, true, part);
1690        if (overlap_increase &gt; 0) {
1691          part-&gt;desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf(&quot;Refining %d %s partners by overlap for:\n&quot;, partners-&gt;length(),
1704              upper ? &quot;Upper&quot; : &quot;Lower&quot;);
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner-&gt;bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner-&gt;bounding_box_.left());
1715      if (overlap &gt; best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf(&quot;Removing partner:&quot;);
1725          partner-&gt;Print();
1726        }
1727        partner-&gt;RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &amp;other) {
1734    const TBOX &amp;box = bbox-&gt;bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left &lt; left_margin_ || right &gt; right_margin_) {
1738      return false;
1739    }
1740    if (left &lt; other.left_margin_ || right &gt; other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf(&quot;Unique on (%d,%d)-&gt;(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n&quot;,
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss &lt; other_miss) {
1758      return true;
1759    }
1760    if (this_miss &gt; other_miss) {
1761      return false;
1762    }
1763    if (this_overlap &gt; other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap &lt; other_overlap) {
1767      return false;
1768    }
1769    return median_top_ &gt;= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part-&gt;bottom_spacing(), 1);
1777      stats.add(part-&gt;top_spacing(), 1);
1778    }
1779    return static_cast&lt;int&gt;(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &amp;part) const {
1782    return (last_column_ &gt;= part.first_column_) &amp;&amp;
1783           (first_column_ &lt;= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i &lt; PN_COUNT; ++i) {
1794      if (i &lt; PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]-&gt;SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &amp;&amp;
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &amp;&amp;
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]-&gt;SpacingEqual(median_space, resolution)) &amp;&amp;
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]-&gt;SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper-&gt;bottom_spacing();
1827          total_top += upper-&gt;top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count &gt; 0) {
1833          int top_spacing = static_cast&lt;int&gt;(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast&lt;int&gt;(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf(&quot;Spacing run ended. Cause:&quot;);
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf(&quot;No more lines\n&quot;);
1839            } else {
1840              tprintf(&quot;Spacing change. Spacings:\n&quot;);
1841              for (int i = 0; i &lt; PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf(&quot;NULL&quot;);
1844                  if (i &gt; 0 &amp;&amp; neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]-&gt;SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(&quot; Lower partner:&quot;);
1848                      neighbourhood[i - 1]-&gt;SingletonPartner(false)-&gt;Print();
1849                    } else {
1850                      tprintf(&quot; nullptr lower partner:\n&quot;);
1851                    }
1852                  } else {
1853                    tprintf(&quot;\n&quot;);
1854                  }
1855                } else {
1856                  tprintf(&quot;Top = %d, bottom = %d\n&quot;,
1857                          neighbourhood[i]-&gt;top_spacing(),
1858                          neighbourhood[i]-&gt;bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf(&quot;Mean spacing = %d/%d\n&quot;, top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper-&gt;set_top_spacing(top_spacing);
1868            upper-&gt;set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf(&quot;Setting mean on:&quot;);
1871              upper-&gt;Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j &lt; PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]-&gt;SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &amp;&amp;
1897           ((parts[PN_ABOVE1] != nullptr &amp;&amp;
1898             parts[PN_ABOVE1]-&gt;SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &amp;&amp;
1900             parts[PN_BELOW1]-&gt;SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &amp;&amp;
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &amp;other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &amp;&amp;
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &amp;other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &amp;&amp;
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &amp;&amp;
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast&lt;int&gt;(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast&lt;int&gt;(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &amp;other) const {
1940    return median_height_ &lt;= other.median_height_ * kMaxSizeRatio &amp;&amp;
1941           other.median_height_ &lt;= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &amp;part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &amp;part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key &lt;= *margin_right &amp;&amp; right_key &gt;= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it-&gt;data();
1964    ColPartition *start_part = part;
1965    int start_y = part-&gt;bounding_box_.top();
1966    if (!part_it-&gt;at_first()) {
1967      int prev_bottom = part_it-&gt;data_relative(-1)-&gt;bounding_box_.bottom();
1968      if (prev_bottom &lt; start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom &gt; start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part-&gt;bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &amp;margin_left, &amp;margin_right);
1978    do {
1979      part_it-&gt;forward();
1980      part = part_it-&gt;data();
1981    } while (!part_it-&gt;at_first() &amp;&amp;
1982             UpdateLeftMargin(*part, &amp;margin_left, &amp;margin_right));
<span onclick='openModal()' class='match'>1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right);
1986    if (next_margin_left &gt; margin_right) {
</span>1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &amp;&amp;
1992               UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
1993      do {
1994        part_it-&gt;backward();
1995        part = part_it-&gt;data();
1996      } while (part != start_part &amp;&amp;
1997               UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
1998      part_it-&gt;forward();
1999    }
2000    part = part_it-&gt;data_relative(-1);
2001    end_y = part-&gt;bounding_box_.bottom();
2002    if (!part_it-&gt;at_first() &amp;&amp; part_it-&gt;data()-&gt;bounding_box_.top() &lt; end_y) {
2003      end_y = (end_y + part_it-&gt;data()-&gt;bounding_box_.top()) / 2;
2004    }
2005    start-&gt;set_y(start_y);
2006    start-&gt;set_x(part-&gt;XAtY(margin_right, start_y));
2007    end-&gt;set_y(end_y);
2008    end-&gt;set_x(part-&gt;XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind &amp;&amp; !part_it-&gt;at_first()) {
2010      tprintf(&quot;Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n&quot;,
2011              start_y, end_y, part-&gt;XAtY(margin_left, end_y), end-&gt;x(),
2012              part-&gt;left_margin_, part-&gt;bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &amp;part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &amp;part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key &lt;= *margin_right &amp;&amp; right_key &gt;= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it-&gt;data();
2036    ColPartition *start_part = part;
2037    int start_y = part-&gt;bounding_box_.bottom();
2038    if (!part_it-&gt;at_last()) {
2039      int next_y = part_it-&gt;data_relative(1)-&gt;bounding_box_.top();
2040      if (next_y &gt; start_y) {
2041        start_y = next_y;
2042      } else if (next_y &lt; start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part-&gt;bounding_box_.top();
2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &amp;margin_left, &amp;margin_right);
2050    do {
2051      part_it-&gt;backward();
2052      part = part_it-&gt;data();
2053    } while (!part_it-&gt;at_last() &amp;&amp;
2054             UpdateRightMargin(*part, &amp;margin_left, &amp;margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &amp;next_margin_left, &amp;next_margin_right);
2058    if (next_margin_right &lt; margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &amp;&amp;
2064               UpdateRightMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
2065      do {
2066        part_it-&gt;forward();
2067        part = part_it-&gt;data();
2068      } while (part != start_part &amp;&amp;
2069               UpdateRightMargin(*part, &amp;next_margin_left, &amp;next_margin_right));
2070      part_it-&gt;backward();
2071    }
2072    part = part_it-&gt;data_relative(1);
2073    end_y = part-&gt;bounding_box().top();
2074    if (!part_it-&gt;at_last() &amp;&amp; part_it-&gt;data()-&gt;bounding_box_.bottom() &gt; end_y) {
2075      end_y = (end_y + part_it-&gt;data()-&gt;bounding_box_.bottom()) / 2;
2076    }
2077    start-&gt;set_y(start_y);
2078    start-&gt;set_x(part-&gt;XAtY(margin_left, start_y));
2079    end-&gt;set_y(end_y);
2080    end-&gt;set_x(part-&gt;XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind &amp;&amp; !part_it-&gt;at_last()) {
2082      tprintf(&quot;Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n&quot;,
2083              start_y, end_y, end-&gt;x(), part-&gt;XAtY(margin_right, end_y),
2084              part-&gt;bounding_box_.right(), part-&gt;right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &amp;margin_left, &amp;margin_right);
2050    do {
</pre></code></div>
                <div class="column column_space"><pre><code>1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &amp;next_margin_left, &amp;next_margin_right);
1986    if (next_margin_left &gt; margin_right) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    