
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.265588914549654%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-genericvector.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCUTIL_GENERICVECTOR_H_
2  #define TESSERACT_CCUTIL_GENERICVECTOR_H_
3  #include "helpers.h"
4  #include "serialis.h"
5  #include <algorithm>
6  #include <cassert>
7  #include <climits> 
8  #include <cstdint> 
9  #include <cstdio>
10  #include <cstdlib>
11  #include <functional> 
12  namespace tesseract {
13  template <typename T>
14  class GenericVector {
15  public:
16    GenericVector() {
17      init(kDefaultVectorSize);
18    }
19    GenericVector(const GenericVector &other) {
20      this->init(other.size());
21      this->operator+=(other);
22    }
23    GenericVector<T> &operator+=(const GenericVector &other);
24    GenericVector<T> &operator=(const GenericVector &other);
25    ~GenericVector();
26    void reserve(int size);
27    void double_the_size();
28    void init_to_size(int size, const T &t);
29    void resize(int size, const T &t);
30    void resize_no_init(int size) {
31      reserve(size);
32      size_used_ = size;
33    }
34    unsigned size() const {
35      return size_used_;
36    }
37    size_t unsigned_size() const {
38      static_assert(sizeof(size_used_) <= sizeof(size_t), "Wow! sizeof(size_t) < sizeof(int32_t)!!");
39      assert(0 <= size_used_);
40      return static_cast<size_t>(size_used_);
41    }
42    int size_reserved() const {
43      return size_reserved_;
44    }
45    bool empty() const {
46      return size_used_ == 0;
47    }
48    T &at(int index) const {
49      assert(index >= 0 && index < size_used_);
50      return data_[index];
51    }
52    T &back() const;
53    T &operator[](int index) const;
54    T pop_back();
55    int get_index(const T &object) const;
56    int push_back(T object);
57    void operator+=(const T &t);
58    void set(const T &t, int index);
59    void insert(const T &t, int index);
60    void remove(int index);
61    void truncate(int size) {
62      if (size < size_used_) {
63        size_used_ = size;
64      }
65    }
66    void set_clear_callback(std::function<void(T)> cb) {
67      clear_cb_ = cb;
68    }
69    void clear();
70    void delete_data_pointers();
71    void move(GenericVector<T> *from);
72    bool write(FILE *f, std::function<bool(FILE *, const T &)> cb) const;
73    bool read(TFile *f, std::function<bool(TFile *, T *)> cb);
74    bool Serialize(FILE *fp) const;
75    bool Serialize(TFile *fp) const;
76    bool DeSerialize(bool swap, FILE *fp);
77    bool DeSerialize(TFile *fp);
78    bool SerializeClasses(FILE *fp) const;
79    bool DeSerializeClasses(TFile *fp);
80    void reverse() {
81      for (int i = 0; i < size_used_ / 2; ++i) {
82        std::swap(data_[i], data_[size_used_ - 1 - i]);
83      }
84    }
85    void sort();
86    void sort(int (*comparator)(const void *, const void *)) {
87      qsort(data_, size_used_, sizeof(*data_), comparator);
88    }
89    void swap(int index1, int index2) {
90      if (index1 != index2) {
91        T tmp = data_[index1];
92        data_[index1] = data_[index2];
93        data_[index2] = tmp;
94      }
95    }
96  protected:
97    void init(int size);
98    static const int kDefaultVectorSize = 4;
99    int32_t size_used_{};
100    int32_t size_reserved_{};
101    T *data_;
102    std::function<void(T)> clear_cb_;
103  };
104  inline bool LoadDataFromFile(const char *filename, GenericVector<char> *data) {
105    bool result = false;
106    FILE *fp = fopen(filename, "rb");
107    if (fp != nullptr) {
108      fseek(fp, 0, SEEK_END);
109      auto size = std::ftell(fp);
110      fseek(fp, 0, SEEK_SET);
111      if (size > 0 && size < LONG_MAX) {
112        data->reserve(size + 1);
113        data->resize_no_init(size);
114        result = static_cast<long>(fread(&(*data)[0], 1, size, fp)) == size;
115      }
116      fclose(fp);
117    }
118    return result;
119  }
120  inline bool SaveDataToFile(const GenericVector<char> &data, const char *filename) {
121    FILE *fp = fopen(filename, "wb");
122    if (fp == nullptr) {
123      return false;
124    }
125    bool result = fwrite(&data[0], 1, data.size(), fp) == data.size();
126    fclose(fp);
127    return result;
128  }
129  template <typename T>
130  int sort_cmp(const void *t1, const void *t2) {
131    const T *a = static_cast<const T *>(t1);
132    const T *b = static_cast<const T *>(t2);
133    if (*a < *b) {
134      return -1;
135    }
136    if (*b < *a) {
137      return 1;
138    }
139    return 0;
140  }
141  template <typename T>
142  int sort_ptr_cmp(const void *t1, const void *t2) {
143    const T *a = *static_cast<T *const *>(t1);
144    const T *b = *static_cast<T *const *>(t2);
145    if (*a < *b) {
146      return -1;
147    }
148    if (*b < *a) {
149      return 1;
150    }
151    return 0;
152  }
153  template <typename T>
154  class PointerVector : public GenericVector<T *> {
155  public:
156    PointerVector() : GenericVector<T *>() {}
157    explicit PointerVector(int size) : GenericVector<T *>(size) {}
158    ~PointerVector() {
159      clear();
160    }
161    PointerVector(const PointerVector &other) : GenericVector<T *>(other) {
162      this->init(other.size());
163      this->operator+=(other);
164    }
165    PointerVector<T> &operator+=(const PointerVector &other) {
166      this->reserve(this->size_used_ + other.size_used_);
167      for (unsigned i = 0; i < other.size(); ++i) {
168        this->push_back(new T(*other.data_[i]));
169      }
170      return *this;
171    }
172    PointerVector<T> &operator=(const PointerVector &other) {
173      if (&other != this) {
174        this->truncate(0);
175        this->operator+=(other);
176      }
177      return *this;
178    }
179    void remove(int index) {
180      delete GenericVector<T *>::data_[index];
181      GenericVector<T *>::remove(index);
182    }
183    void truncate(int size) {
184      for (int i = size; i < GenericVector<T *>::size_used_; ++i) {
185        delete GenericVector<T *>::data_[i];
186      }
187      GenericVector<T *>::truncate(size);
188    }
189    void clear() {
190      GenericVector<T *>::delete_data_pointers();
191      GenericVector<T *>::clear();
192    }
193    bool Serialize(FILE *fp) const {
194      int32_t used = GenericVector<T *>::size_used_;
195      if (fwrite(&used, sizeof(used), 1, fp) != 1) {
196        return false;
197      }
198      for (int i = 0; i < used; ++i) {
199        int8_t non_null = GenericVector<T *>::data_[i] != nullptr;
200        if (fwrite(&non_null, sizeof(non_null), 1, fp) != 1) {
201          return false;
202        }
203        if (non_null && !GenericVector<T *>::data_[i]->Serialize(fp)) {
204          return false;
205        }
206      }
207      return true;
208    }
209    bool Serialize(TFile *fp) const {
210      int32_t used = GenericVector<T *>::size_used_;
211      if (fp->FWrite(&used, sizeof(used), 1) != 1) {
212        return false;
213      }
214      for (int i = 0; i < used; ++i) {
215        int8_t non_null = GenericVector<T *>::data_[i] != nullptr;
216        if (fp->FWrite(&non_null, sizeof(non_null), 1) != 1) {
217          return false;
218        }
219        if (non_null && !GenericVector<T *>::data_[i]->Serialize(fp)) {
220          return false;
221        }
222      }
223      return true;
224    }
225    bool DeSerialize(bool swap, FILE *fp) {
226      uint32_t reserved;
227      if (fread(&reserved, sizeof(reserved), 1, fp) != 1) {
228        return false;
229      }
230      if (swap) {
231        Reverse32(&reserved);
232      }
233      assert(reserved <= UINT16_MAX);
234      if (reserved > UINT16_MAX) {
235        return false;
236      }
237      GenericVector<T *>::reserve(reserved);
238      truncate(0);
239      for (uint32_t i = 0; i < reserved; ++i) {
240        int8_t non_null;
241        if (fread(&non_null, sizeof(non_null), 1, fp) != 1) {
242          return false;
243        }
244        T *item = nullptr;
245        if (non_null != 0) {
246          item = new T;
247          if (!item->DeSerialize(swap, fp)) {
248            delete item;
249            return false;
250          }
251          this->push_back(item);
252        } else {
253          this->push_back(nullptr);
254        }
255      }
256      return true;
257    }
258    void sort() {
259      this->GenericVector<T *>::sort(&sort_ptr_cmp<T>);
260    }
261  };
262  template <typename T>
263  void GenericVector<T>::init(int size) {
264    size_used_ = 0;
265    if (size <= 0) {
266      data_ = nullptr;
267      size_reserved_ = 0;
268    } else {
269      if (size < kDefaultVectorSize) {
270        size = kDefaultVectorSize;
271      }
272      data_ = new T[size];
273      size_reserved_ = size;
274    }
275    clear_cb_ = nullptr;
276  }
277  template <typename T>
278  GenericVector<T>::~GenericVector() {
279    clear();
280  }
281  template <typename T>
282  void GenericVector<T>::reserve(int size) {
283    if (size_reserved_ >= size || size <= 0) {
284      return;
285    }
286    if (size < kDefaultVectorSize) {
287      size = kDefaultVectorSize;
288    }
289    T *new_array = new T[size];
290    for (int i = 0; i < size_used_; ++i) {
291      new_array[i] = data_[i];
292    }
293    delete[] data_;
294    data_ = new_array;
295    size_reserved_ = size;
296  }
297  template <typename T>
298  void GenericVector<T>::double_the_size() {
299    if (size_reserved_ == 0) {
300      reserve(kDefaultVectorSize);
301    } else {
302      reserve(2 * size_reserved_);
303    }
304  }
305  template <typename T>
306  void GenericVector<T>::init_to_size(int size, const T &t) {
307    reserve(size);
308    size_used_ = size;
309    for (int i = 0; i < size; ++i) {
310      data_[i] = t;
311    }
312  }
313  template <typename T>
314  void GenericVector<T>::resize(int size, const T &t) {
315    init_to_size(size, t);
316  }
317  template <typename T>
318  T &GenericVector<T>::operator[](int index) const {
319    assert(index >= 0 && index < size_used_);
320    return data_[index];
321  }
322  template <typename T>
323  T &GenericVector<T>::back() const {
324    assert(size_used_ > 0);
325    return data_[size_used_ - 1];
326  }
327  template <typename T>
328  T GenericVector<T>::pop_back() {
329    assert(size_used_ > 0);
330    return data_[--size_used_];
331  }
332  template <typename T>
333  void GenericVector<T>::set(const T &t, int index) {
334    assert(index >= 0 && index < size_used_);
335    data_[index] = t;
336  }
337  template <typename T>
338  void GenericVector<T>::insert(const T &t, int index) {
339    assert(index >= 0 && index <= size_used_);
<span onclick='openModal()' class='match'>340    if (size_reserved_ == size_used_) {
341      double_the_size();
342    }
343    for (int i = size_used_; i > index; --i) {
344      data_[i] = data_[i - 1];
345    }
</span>346    data_[index] = t;
347    size_used_++;
348  }
349  template <typename T>
350  void GenericVector<T>::remove(int index) {
351    assert(index >= 0 && index < size_used_);
352    for (int i = index; i < size_used_ - 1; ++i) {
353      data_[i] = data_[i + 1];
354    }
355    size_used_--;
356  }
357  template <typename T>
358  int GenericVector<T>::get_index(const T &object) const {
359    for (int i = 0; i < size_used_; ++i) {
360      if (object == data_[i]) {
361        return i;
362      }
363    }
364    return -1;
365  }
366  template <typename T>
367  int GenericVector<T>::push_back(T object) {
368    int index = 0;
369    if (size_used_ == size_reserved_) {
370      double_the_size();
371    }
372    index = size_used_++;
373    data_[index] = object;
374    return index;
375  }
376  template <typename T>
377  void GenericVector<T>::operator+=(const T &t) {
378    push_back(t);
379  }
380  template <typename T>
381  GenericVector<T> &GenericVector<T>::operator+=(const GenericVector &other) {
382    this->reserve(size_used_ + other.size_used_);
383    for (unsigned i = 0; i < other.size(); ++i) {
384      this->operator+=(other.data_[i]);
385    }
386    return *this;
387  }
388  template <typename T>
389  GenericVector<T> &GenericVector<T>::operator=(const GenericVector &other) {
390    if (&other != this) {
391      this->truncate(0);
392      this->operator+=(other);
393    }
394    return *this;
395  }
396  template <typename T>
397  void GenericVector<T>::clear() {
398    if (size_reserved_ > 0 && clear_cb_ != nullptr) {
399      for (int i = 0; i < size_used_; ++i) {
400        clear_cb_(data_[i]);
401      }
402    }
403    delete[] data_;
404    data_ = nullptr;
405    size_used_ = 0;
406    size_reserved_ = 0;
407    clear_cb_ = nullptr;
408  }
409  template <typename T>
410  void GenericVector<T>::delete_data_pointers() {
411    for (int i = 0; i < size_used_; ++i) {
412      delete data_[i];
413    }
414  }
415  template <typename T>
416  bool GenericVector<T>::write(FILE *f, std::function<bool(FILE *, const T &)> cb) const {
417    if (fwrite(&size_reserved_, sizeof(size_reserved_), 1, f) != 1) {
418      return false;
419    }
420    if (fwrite(&size_used_, sizeof(size_used_), 1, f) != 1) {
421      return false;
422    }
423    if (cb != nullptr) {
424      for (int i = 0; i < size_used_; ++i) {
425        if (!cb(f, data_[i])) {
426          return false;
427        }
428      }
429    } else {
430      if (fwrite(data_, sizeof(T), size_used_, f) != unsigned_size()) {
431        return false;
432      }
433    }
434    return true;
435  }
436  template <typename T>
437  bool GenericVector<T>::read(TFile *f, std::function<bool(TFile *, T *)> cb) {
438    int32_t reserved;
439    if (f->FReadEndian(&reserved, sizeof(reserved), 1) != 1) {
440      return false;
441    }
442    reserve(reserved);
443    if (f->FReadEndian(&size_used_, sizeof(size_used_), 1) != 1) {
444      return false;
445    }
446    if (cb != nullptr) {
447      for (int i = 0; i < size_used_; ++i) {
448        if (!cb(f, data_ + i)) {
449          return false;
450        }
451      }
452    } else {
453      if (f->FReadEndian(data_, sizeof(T), size_used_) != static_cast<unsigned>(size_used_)) {
454        return false;
455      }
456    }
457    return true;
458  }
459  template <typename T>
460  bool GenericVector<T>::Serialize(FILE *fp) const {
461    if (fwrite(&size_used_, sizeof(size_used_), 1, fp) != 1) {
462      return false;
463    }
464    if (fwrite(data_, sizeof(*data_), size_used_, fp) != unsigned_size()) {
465      return false;
466    }
467    return true;
468  }
469  template <typename T>
470  bool GenericVector<T>::Serialize(TFile *fp) const {
471    if (fp->FWrite(&size_used_, sizeof(size_used_), 1) != 1) {
472      return false;
473    }
474    if (fp->FWrite(data_, sizeof(*data_), size_used_) != size_used_) {
475      return false;
476    }
477    return true;
478  }
479  template <typename T>
480  bool GenericVector<T>::DeSerialize(bool swap, FILE *fp) {
481    uint32_t reserved;
482    if (fread(&reserved, sizeof(reserved), 1, fp) != 1) {
483      return false;
484    }
485    if (swap) {
486      Reverse32(&reserved);
487    }
488    assert(reserved <= UINT16_MAX);
489    if (reserved > UINT16_MAX) {
490      return false;
491    }
492    reserve(reserved);
493    size_used_ = reserved;
494    if (fread(data_, sizeof(T), size_used_, fp) != unsigned_size()) {
495      return false;
496    }
497    if (swap) {
498      for (int i = 0; i < size_used_; ++i) {
499        ReverseN(&data_[i], sizeof(data_[i]));
500      }
501    }
502    return true;
503  }
504  template <typename T>
505  bool GenericVector<T>::DeSerialize(TFile *fp) {
506    uint32_t reserved;
507    if (fp->FReadEndian(&reserved, sizeof(reserved), 1) != 1) {
508      return false;
509    }
510    const uint32_t limit = 50000000;
511    assert(reserved <= limit);
512    if (reserved > limit) {
513      return false;
514    }
515    reserve(reserved);
516    size_used_ = reserved;
517    return fp->FReadEndian(data_, sizeof(T), size_used_) == size_used_;
518  }
519  template <typename T>
520  bool GenericVector<T>::SerializeClasses(FILE *fp) const {
521    if (fwrite(&size_used_, sizeof(size_used_), 1, fp) != 1) {
522      return false;
523    }
524    for (int i = 0; i < size_used_; ++i) {
525      if (!data_[i].Serialize(fp)) {
526        return false;
527      }
528    }
529    return true;
530  }
531  template <typename T>
532  bool GenericVector<T>::DeSerializeClasses(TFile *fp) {
533    int32_t reserved;
534    if (fp->FReadEndian(&reserved, sizeof(reserved), 1) != 1) {
535      return false;
536    }
537    T empty;
538    init_to_size(reserved, empty);
539    for (int i = 0; i < reserved; ++i) {
540      if (!data_[i].DeSerialize(fp)) {
541        return false;
542      }
543    }
544    return true;
545  }
546  template <typename T>
547  void GenericVector<T>::move(GenericVector<T> *from) {
548    this->clear();
549    this->data_ = from->data_;
550    this->size_reserved_ = from->size_reserved_;
551    this->size_used_ = from->size_used_;
552    this->clear_cb_ = from->clear_cb_;
553    from->data_ = nullptr;
554    from->clear_cb_ = nullptr;
555    from->size_used_ = 0;
556    from->size_reserved_ = 0;
557  }
558  template <typename T>
559  void GenericVector<T>::sort() {
560    sort(&sort_cmp<T>);
561  }
562  } 
563  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-semspace.cpp</h3>
            <pre><code>1  THash<TStr, TSemSpace::TSemSpcLoadF> TSemSpace::TypeToLoadFH;
2  bool TSemSpace::Reg(const TStr& TypeNm, const TSemSpcLoadF& LoadF) {
3    IAssert(!TypeToLoadFH.IsKey(TypeNm));
4    TypeToLoadFH.AddDat(TypeNm, LoadF);
5    return true;
6  }
7  PSemSpace TSemSpace::Load(TSIn& SIn) {
8      TStr TypeNm(SIn);
9      int TypeKeyId=-1;
10      if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
11          TSemSpcLoadF LoadF=TypeToLoadFH[TypeKeyId];
12          return (*LoadF())(SIn);
13      } else {
14          return NULL;
15      }
16  }
17  double TSemSpace::GetAvgApprox(const TVec<PBowSpV>& BowSpV, const int& Dim) const {
18      PMom Mom = TMom::New();
19      for (int DocN = 0; DocN < BowSpV.Len(); DocN++) {
20          PBowSpV ProjSpV = this->ProjectSpV(BowSpV[DocN], Dim, false);
21          Mom->Add(ProjSpV->GetNorm());
22      }
23      Mom->Def();            
24      return Mom->GetMean();
25  }
26  int TSemSpace::GetDimNeededForApprox(const TVec<PBowSpV>& BowSpV, 
27          const double& ApproxThresh, double& ApproxVal, const int& MxDimDiff) const {
28      IAssert(0.0 < ApproxThresh && ApproxThresh < 1.0);
29      int BottomDim = 0, TopDim = this->GetVecs();
30      ApproxVal = GetAvgApprox(BowSpV, TopDim);
31      if (ApproxVal < ApproxThresh) { return TopDim; }
32      forever {
33          if (TopDim - BottomDim < MxDimDiff) {  return TopDim; }
34          IAssert(TopDim > BottomDim);
35          const int SemSpcDim = (TopDim + BottomDim) / 2;
36          ApproxVal = GetAvgApprox(BowSpV, SemSpcDim);
37          if (ApproxVal < ApproxThresh) {
38              IAssert(BottomDim < SemSpcDim);
39              BottomDim = SemSpcDim;
40          } else {
41              IAssert(TopDim > SemSpcDim);
42              TopDim = SemSpcDim;
43          }
44      }
45  }
46  PBowDocPart TSemSpace::GetBowDocPart(const PBowDocBs& BowDocBs,
47          const int& StartVecN, const int _Vecs, const double& Eps) const {
48      PBowDocPart BowDocPart = TBowDocPart::New();
49      const int Vecs = _Vecs == -1 ? this->GetVecs() : _Vecs;
50      IAssert(Vecs < this->GetVecs());
51      for (int VecN = StartVecN; VecN < Vecs; VecN++) {
52          PBowSpV PosSpV, NegSpV; 
53          this->GetVecBowSpV(VecN, PosSpV, NegSpV, Eps);
54          if (PosSpV->Len() > 0) {
55              PBowDocPartClust Clust = TBowDocPartClust::New(
56                  BowDocBs, TStr::Fmt("Vec%dPos", VecN), 0.0, TIntV(), PosSpV, NULL);
57              BowDocPart->AddClust(Clust);
58          }
59          if (NegSpV->Len() > 0) {
60              PBowDocPartClust Clust = TBowDocPartClust::New(
61                  BowDocBs, TStr::Fmt("Vec%dPos", VecN), 0.0, TIntV(), NegSpV, NULL);
62              BowDocPart->AddClust(Clust);
63          }
64      }
65      return BowDocPart;
66  }
67  void TSemSpace::GetVecBowSpV(const int& VecN, PBowSpV& PosSpV, 
68          PBowSpV& NegSpV, const double& Eps) const {
69      IAssert(0.0 <= Eps && Eps <= 1.0);
70      TFltV Vec; GetVec(VecN, Vec);
71      PosSpV = TBowSpV::New(); NegSpV = TBowSpV::New();
72      const int Len = Vec.Len();
73      for (int i = 0; i < Len; i++) {
74          if (Vec[i] > Eps) {
75              PosSpV->AddWIdWgt(i, Vec[i]);
76          } else if (-Vec[i] > Eps) {
77              NegSpV->AddWIdWgt(i, -Vec[i]);
78          }
79      }
80  }
81  void TSemSpace::GetWords(PBowDocBs BowDocBs, const int& VecN, 
82          const int& TopWords, const double& TopWordsWgtPrc, 
83          TStrFltPrV& PosWordStrWgtV, TStrFltPrV& NegWordStrWgtV) const {
84      PBowSpV PosSpV, NegSpV; this->GetVecBowSpV(VecN, PosSpV, NegSpV);
85      PosWordStrWgtV.Clr();
86      if (PosSpV->Len() > 0) {
87          PosSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, PosWordStrWgtV);
88      }
89      NegWordStrWgtV.Clr();
90      if (NegSpV->Len() > 0) {
91          NegSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, NegWordStrWgtV);
92      }
93  }
94  void TSemSpace::SaveTxt(const TStr& FNm, PBowDocBs BowDocBs, const int& TopWords, 
95          const double& TopWordsWgtPrc, const bool& ShowWgt) const {
96      PSOut Out = TFOut::New(FNm);
97      Out->PutStrLn("Semantic Space generation method: " + MethodeType);
98      Out->PutLn();
99      const int Vecs = GetVecs();
100      for (int VecN = 0; VecN < Vecs; VecN++) {
101          Out->PutStrLn(TStr::Fmt("Vector no.\t%d:", VecN));
102          TStrFltPrV PosWordStrWgtV, NegWordStrWgtV;
103          this->GetWords(BowDocBs, VecN, TopWords, TopWordsWgtPrc, 
104              PosWordStrWgtV, NegWordStrWgtV);
105          Out->PutStr("+\t");
106          for (int i = 0; i < PosWordStrWgtV.Len(); i++) {
107              if (ShowWgt) {
108                  Out->PutStr(TStr::Fmt("%s:%g\t", 
109                      PosWordStrWgtV[i].Val1.CStr(), PosWordStrWgtV[i].Val2.Val));
110              } else {
111                  Out->PutStr(TStr::Fmt("%s\t", PosWordStrWgtV[i].Val1.CStr()));
112              }
113          }
114          Out->PutLn(); 
115          Out->PutStr("-\t");
116          for (int i = 0; i < NegWordStrWgtV.Len(); i++) {
117              if (ShowWgt) {
118                  Out->PutStr(TStr::Fmt("%s:%g\t", 
119                      NegWordStrWgtV[i].Val1.CStr(), NegWordStrWgtV[i].Val2.Val));
120              } else {
121                  Out->PutStr(TStr::Fmt("%s\t", NegWordStrWgtV[i].Val1.CStr()));
122              }
123          }
124          Out->PutLn(2);
125      }
126  }
127  void TSemSpace::SaveTxtStat(const TStr& FNm, PSemSpace SemSp1, PBowDocBs BowBs1, 
128          PBowDocWgtBs BowWgt1, PSemSpace SemSp2, PBowDocBs BowBs2, 
129          PBowDocWgtBs BowWgt2, const bool& NormP, const TIntV& DIdV) {
130      printf("project first set...\n");
131      TIntV DIdV1 = DIdV; if (DIdV.Empty()) BowBs1->GetAllDIdV(DIdV1);
132      PBowDocBs Set1 = SemSp1->Project(BowBs1, BowWgt1, DIdV1, SemSp1->GetVecs(), NormP);
133      printf("project second set...\n");
134      TIntV DIdV2 = DIdV; if (DIdV.Empty()) BowBs2->GetAllDIdV(DIdV2);
135      PBowDocBs Set2 = SemSp2->Project(BowBs2, BowWgt2, DIdV2, SemSp2->GetVecs(), NormP);
136      IAssert(Set1->GetDocs() == Set2->GetDocs());
137      PSOut SOut = TFOut::New(FNm);
138      printf("comparing %s vs. %s...\n", 
139          SemSp1->GetMethodeType().CStr(), SemSp2->GetMethodeType().CStr());
140      SOut->PutStrLn("DId, ||Vec1||, ||Vec2||, <Vec1/||Vec1||,Vec2/||Vec2||>");
141      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
142          printf("%d\r", DocC);
143          TStr DocNm1 = BowBs1->GetDocNm(DIdV[DocC]), DocNm2 = BowBs2->GetDocNm(DIdV[DocC]);
144          IAssert(DocNm1.Left(DocNm1.Len() - 3) == DocNm2.Left(DocNm2.Len() - 3));
145          TStr NewDocNm1 = Set1->GetDocNm(DocC), NewDocNm2 = Set2->GetDocNm(DocC);
146          IAssertR(DocNm1 == NewDocNm1, DocNm1 + "!=" + NewDocNm1);
147          IAssertR(DocNm2 == NewDocNm2, DocNm2 + "!=" + NewDocNm2);
148          PBowSpV Vec1 = Set1->GetDocSpV(DocC);
149          PBowSpV Vec2 = Set2->GetDocSpV(DocC);
150          const double n1 = Vec1->GetNorm();
151          const double n2 = Vec2->GetNorm();
152          const double dp = (n1*n2 > 0.0) ? TBowLinAlg::DotProduct(Vec1, Vec2)/(n1*n2) : 0.0;
153          SOut->PutStrLn(TStr::Fmt("%d\t%.5f\t%.5f\t%.5f", DIdV[DocC].Val, n1, n2, dp));
154      }
155      SOut->Flush();
156      printf("\ndone\n");
157  }
158  void TSemSpace::SaveApproxStat(const TStr& FNm, 
159          const TVec<PBowSpV>& BowSpV, const int& Step) const {
160      PSOut SOut = TFOut::New(FNm);
161      SOut->PutStrLn("Testing approximation quality");
162      SOut->PutStrLn(TStr::Fmt("Average of norms should converge to 1.0 as dim->%d", GetVecs()));
163      SOut->PutStrLn("==============================================================");
164      for (int Dims = Step; Dims < GetVecs(); Dims+=Step) {  
165          PMom Mom = TMom::New();
166          for (int DocN = 0; DocN < BowSpV.Len(); DocN++) {
167              PBowSpV ProjSpV = ProjectSpV(BowSpV[DocN], Dims, false);
168              Mom->Add(ProjSpV->GetNorm());
169          }
170          Mom->Def();
171          SOut->PutStrLn(TStr::Fmt("Norm(dim:%d) = [avg: %.3f, sdev: %.3f]", Dims, Mom->GetMean(), Mom->GetSDev()));
172      }
173  }
174  bool TVecSemSpace::IsReg=TVecSemSpace::MkReg();
175  TVecSemSpace::TVecSemSpace(const TFltVV& BasisVV, 
176          const TStr& _MethodeType): TSemSpace(_MethodeType) {
177      const int Len = BasisVV.GetXDim();
178      const int Dim = BasisVV.GetYDim();
179      BasisV.Gen(Dim);
180      for (int VecN = 0; VecN < Dim; VecN++) {
181          BasisV[VecN].Gen(Len,0);
182          for (int i = 0; i < Len; i++) {
183              BasisV[VecN].Add(BasisVV(i, VecN)); }
184      }
185  }
186  TVecSemSpace::TVecSemSpace(PSVMTrainSet Set, PPartialGS R, 
187          const TVec<TFltV>& DrctV, const TStr& _MethodeType): TSemSpace(_MethodeType) { 
188      IAssert(Set->Len() == R->GetCols()); 
189      const int Dim = DrctV.Len();
190      const int DocN = R->GetCols(), AproxN = R->GetRows();
191      const TIntV& IdV = R->GetIdV();
192      BasisV.Gen(Dim, 0); TFltV AlphV(DocN);
193      TVec<TFltV> q(AproxN); R->GetBasisV(q);
194      TFltV ww(AproxN); 
195      for (int i = 0; i < Dim; i++) {
196          printf("\r%d", i);
197          const TFltV& w = DrctV[i];
198          IAssert(w.Len() <= AproxN);
199          ww.PutAll(0.0);
200          for (int j = 0; j < w.Len(); j++)
201              TLinAlg::AddVec(w[j], q[j], ww, ww);
202          AlphV.PutAll(0.0);
203          for (int j = 0; j < AproxN; j++)
204              AlphV[IdV[j]] = ww[j];
205          TFltV Col; Set->LinComb(AlphV, Col); BasisV.Add(Col);
206      }
207      printf("\n");
208  };
209  TVecSemSpace::TVecSemSpace(const TStr& MatlabFName): TSemSpace("Matlab") {
210      TLAMisc::LoadMatlabTFltVV(MatlabFName, BasisV);
211  }
212  TVecSemSpace::TVecSemSpace(const TStr& MatlabFName, 
213          const TStr& MapFName): TSemSpace("Matlab") {
214      TLAMisc::LoadMatlabTFltVV(MatlabFName, BasisV);
215      PSIn SIn = TFIn::New(MapFName);
216      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
217      int Words = BasisV[0].Len(); TIntV WIdV(Words, 0);
218      for (int WdN = 0; WdN < Words; WdN++) {
219          if (WdN % 100 == 0) { printf("%d\r", WdN); }
220          Lx.GetSym(syInt); WIdV.Add(Lx.Int);
221          Lx.GetSym(syInt); IAssertR((Lx.Int-1) == WdN, TStr::Fmt("line %d", WdN));
222          Lx.GetSym(syStr, syIdStr, syQStr);
223          Lx.GetSym(syEof, syEoln);
224      }
225      printf("\n"); IAssert(WIdV.IsSorted());
226      const int NewSize = WIdV.Last()+1;
227      for (int VecN = 0; VecN < BasisV.Len(); VecN++) {
228          TFltV NewVec(NewSize); NewVec.PutAll(0.0);
229          for (int WdN = 0; WdN < Words; WdN++) {
230              NewVec[WIdV[WdN]] = BasisV[VecN][WdN];
231          }
232          BasisV[VecN] = NewVec;
233      }
234  }
235  PBowDocBs TVecSemSpace::Project(const PBowDocBs& BowDocBs, 
236          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
237          const int& Vecs, const bool& NormP) const {
238      IAssert(Vecs <= BasisV.Len());
239      PBowDocBs NewBowDocBs = TBowDocBs::New();
240      for (int i = 0; i < Vecs; i++) {
241          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); }  
242      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
243          const int DId = DIdV[DocC];
244          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
245          for (int i = 0; i < Vecs; i++) {
246              const double Elt = TBowLinAlg::DotProduct(
247                  BasisV[i], BowDocWgtBs->GetSpV(DId));
248              PSpV.Add(TIntFltPr(i, Elt)); 
249              VecNorm += TMath::Sqr(Elt);
250          }
251          if (NormP && VecNorm > 0.0) {
252              VecNorm = sqrt(VecNorm);
253              for (int i = 0; i < Vecs; i++) {
254                  PSpV[i].Val2 = PSpV[i].Val2 / VecNorm;
255              }
256          }
257          const int CatN = BowDocBs->GetDocCIds(DId);
258          TStrV CatNmV(CatN, 0);
259          for (int CatC = 0; CatC < CatN; CatC++) { 
260              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
261          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, PSpV); 
262      }
263      NewBowDocBs->AssertOk();
264      return NewBowDocBs;
265  }
266  PBowSpV TVecSemSpace::ProjectSpV(const PBowSpV& SpV, 
267          const int& Vecs, const bool& NormP) const {
268      PSVMTrainSet Set = TBowTrainSet::New(1); 
269      Set->AddAttrV(0, SpV, 1.0);
270      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
271      for (int i = 0; i < Vecs; i++) {
272          NewSpV->AddWIdWgt(i, TBowLinAlg::DotProduct(BasisV[i], SpV)); }
273      if (NormP) { NewSpV->PutUnitNorm(); }
274      return NewSpV;
275  }
276  void TVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
277          const bool& NormP, TIntFltKdV& ProjSpV) const {
278      ProjSpV.Gen(Vecs, 0);
279      for (int i = 0; i < Vecs; i++) {
280          ProjSpV.Add(TIntFltKd(i, TBowLinAlg::DotProduct(BasisV[i], SpV))); }
281      if (NormP) { TLinAlg::Normalize(ProjSpV); }
282  }
283  void TVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
284          const bool& NormP, TFltV& ProjV) const {
285      ProjV.Gen(Vecs, 0);
286      for (int i = 0; i < Vecs; i++) {
287          ProjV.Add(TBowLinAlg::DotProduct(BasisV[i], SpV)); }
288      if (NormP) { TLinAlg::Normalize(ProjV); }
289  }
290  void TVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
291          const bool& NormP, TIntFltKdV& ProjSpV) const {
292      ProjSpV.Gen(Vecs, 0);
293      for (int i = 0; i < Vecs; i++) {
294          ProjSpV.Add(TIntFltKd(i, TLinAlg::DotProduct(BasisV[i], SpV))); }
295      if (NormP) { TLinAlg::Normalize(ProjSpV); }   
296  }
297  void TVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
298          const bool& NormP, TFltV& ProjV) const {
299      ProjV.Gen(Vecs, 0);
300      for (int i = 0; i < Vecs; i++) {
301          ProjV.Add(TLinAlg::DotProduct(BasisV[i], SpV)); }
302      if (NormP) { TLinAlg::Normalize(ProjV); }   
303  }
304  void TVecSemSpace::ProjectV(const TFltV& FullV, const int& Vecs, 
305          const bool& NormP, TFltV& ProjV) const {
306      ProjV.Gen(Vecs, 0);
307      for (int i = 0; i < Vecs; i++) {
308          ProjV.Add(TLinAlg::DotProduct(BasisV[i], FullV)); }
309      if (NormP) { TLinAlg::Normalize(ProjV); }
310  }
311  bool TSpVecSemSpace::IsReg=TSpVecSemSpace::MkReg();
312  TSpVecSemSpace:: TSpVecSemSpace(const TVec<TIntFltKdV>& _BasisV, const TStr& _MethodeType): 
313        TSemSpace(_MethodeType), BasisV(_BasisV) { 
314      const int Vecs = BasisV.Len();
315      VecDim = 0;
316      for (int VecN = 0; VecN < Vecs; VecN++) {
317          VecDim = TInt::GetMx(VecDim, BasisV.Last().Last().Key);
318      }
319      VecDim++;
320  };
321  PBowDocBs TSpVecSemSpace::Project(const PBowDocBs& BowDocBs, 
322          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
323          const int& Vecs, const bool& NormP) const {
324      IAssert(Vecs <= BasisV.Len());
325      PBowDocBs NewBowDocBs = TBowDocBs::New();
326      for (int i = 0; i < Vecs; i++) {
327          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); } 
328      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
329          const int DId = DIdV[DocC];
330          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
331          for (int i = 0; i < Vecs; i++) {
332              const double Elt = TBowLinAlg::DotProduct(
333                  BasisV[i], BowDocWgtBs->GetSpV(DId));
334              PSpV.Add(TIntFltPr(i, Elt)); 
335              VecNorm += TMath::Sqr(Elt);
336          }
337          if (NormP && VecNorm > 0.0) {
338              VecNorm = sqrt(VecNorm);
339              for (int i = 0; i < Vecs; i++) {
340                  PSpV[i].Val2 = PSpV[i].Val2 / VecNorm;
341              }
342          }
343          const int CatN = BowDocBs->GetDocCIds(DId);
344          TStrV CatNmV(CatN, 0);
345          for (int CatC = 0; CatC < CatN; CatC++) { 
346              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
347          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, PSpV); 
348      }
349      NewBowDocBs->AssertOk();
350      return NewBowDocBs;
351  }
352  PBowSpV TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, 
353          const int& Vecs, const bool& NormP) const {
354      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
355      for (int i = 0; i < Vecs; i++) {
356          NewSpV->AddWIdWgt(i, TBowLinAlg::DotProduct(BasisV[i], SpV)); }
357      if (NormP) { NewSpV->PutUnitNorm(); }
358      return NewSpV;
359  }
360  void TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
361          const bool& NormP, TIntFltKdV& ProjSpV) const {
362      ProjSpV.Gen(Vecs, 0);
363      for (int i = 0; i < Vecs; i++) {
364          ProjSpV.Add(TIntFltKd(i, TBowLinAlg::DotProduct(BasisV[i], SpV))); }
365      if (NormP) { TLinAlg::Normalize(ProjSpV); }
366  }
367  void TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
368          const bool& NormP, TFltV& ProjV) const {
369      ProjV.Gen(Vecs, 0);
370      for (int i = 0; i < Vecs; i++) {
371          ProjV.Add(TBowLinAlg::DotProduct(BasisV[i], SpV)); }
372      if (NormP) { TLinAlg::Normalize(ProjV); }
373  }
374  void TSpVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
375          const bool& NormP, TIntFltKdV& ProjSpV) const {
376      ProjSpV.Gen(Vecs, 0);
377      for (int i = 0; i < Vecs; i++) {
378          ProjSpV.Add(TIntFltKd(i, TLinAlg::DotProduct(BasisV[i], SpV))); }
379      if (NormP) { TLinAlg::Normalize(ProjSpV); }  
380  }
381  void TSpVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
382          const bool& NormP, TFltV& ProjV) const {
383      ProjV.Gen(Vecs, 0);
384      for (int i = 0; i < Vecs; i++) {
385          ProjV.Add(TLinAlg::DotProduct(BasisV[i], SpV)); }
386      if (NormP) { TLinAlg::Normalize(ProjV); }  
387  }
388  void TSpVecSemSpace::ProjectV(const TFltV& FullV, const int& Vecs, 
389          const bool& NormP, TFltV& ProjV) const {
390      ProjV.Gen(Vecs, 0);
391      for (int i = 0; i < Vecs; i++) {
392          ProjV.Add(TLinAlg::DotProduct(FullV, BasisV[i])); }
393      if (NormP) { TLinAlg::Normalize(ProjV); }     
394  }
395  int TSpVecSemSpace::GetVecLen() const {
396      const int Vecs = GetVecs(); int MxDim = 0;
397      for (int i = 0; i < Vecs; i++) {
398          MxDim = TInt::GetMx(BasisV[i].Last().Key, 0); }
399      return MxDim;
400  }
401  bool TKCCASemSpace::IsReg=TKCCASemSpace::MkReg();
402  void TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
403          const bool& NormP, TIntFltPrV& ProjSpV) const {
404      const int N = TrainSet->Len(); TFltV z(N, 0);
405      TFltV DotProdV(N, 0);
406      for (int i = 0; i < N; i++)
407          DotProdV.Add(TrainSet->DotProduct(i, SpV));
408      for (int i = 0; i < N; i++) 
409          z.Add(TLinAlg::DotProduct(GSBasisV[i], DotProdV));
410      ProjSpV.Gen(Vecs, 0); double Norm = 0.0;
411      for (int i = 0; i < Vecs; i++) {
412          const double Wgt = TLinAlg::DotProduct(z, BasisV[i]);
413          ProjSpV.Add(TIntFltPr(i, Wgt));
414          Norm += TMath::Sqr(Wgt);
415      }
416      if (NormP) {
417          Norm = sqrt(Norm);
418          for (int i = 0; i < Vecs; i++) { ProjSpV[i].Val2 /= Norm; }
419      }
420  }
421  TKCCASemSpace::TKCCASemSpace(PSVMTrainSet Set, PPartialGS R, const TVec<TFltV>& DrctV, const TStr& _MethodeType): 
422          TSemSpace(_MethodeType), TrainSet(Set) { 
423      IAssert(Set->Len() == R->GetCols()); 
424      BasisV = DrctV;
425      R->GetBasisV(GSBasisV);
426      const TIntV& DIdV = R->GetIdV();
427      const int Dim = R->GetRows();
428      TrainSet = TBowTrainSet::New(Dim);
429      for (int VecC = 0; VecC < Dim; VecC++) {
430          const int DocId = DIdV[VecC];
431          TrainSet->AddAttrV(Set->GetVecDId(DocId), Set->GetAttrBowV(DocId), Set->GetVecParam(DocId));
432      }
433      IAssert(GSBasisV.Len() == TrainSet->Len() && GSBasisV[0].Len() == TrainSet->Len());
434  }
435  PBowDocBs TKCCASemSpace::Project(const PBowDocBs& BowDocBs, 
436          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
437          const int& Vecs, const bool& NormP) const {
438      IAssert(Vecs <= BasisV.Len());
439      PBowDocBs NewBowDocBs = TBowDocBs::New();
440      for (int i = 0; i < Vecs; i++) {
441          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); } 
442      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
443      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
444          const int DId = DIdV[DocC];
445          TIntFltPrV ProjVec; 
446          ProjectSpV(BowDocWgtBs->GetSpV(DId), Vecs, NormP, ProjVec);
447          const int CatN = BowDocBs->GetDocCIds(DId);
448          TStrV CatNmV(CatN, 0);
449          for (int CatC = 0; CatC < CatN; CatC++) { 
450              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
451          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, ProjVec); 
452      }
453      printf("\n");
454      NewBowDocBs->AssertOk();
455      return NewBowDocBs;
456  }
457  PBowSpV TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, 
458          const int& Vecs, const bool& NormP) const {
459      TIntFltPrV ProjVec; ProjectSpV(SpV, Vecs, NormP, ProjVec);
460      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
461      for (int i = 0; i < Vecs; i++) {
462          const TIntFltPr Wgt = ProjVec[i];
463          NewSpV->AddWIdWgt(Wgt.Val1, Wgt.Val2);
464      }
465      return NewSpV;
466  }
467  void TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
468          const bool& NormP, TIntFltKdV& ProjSpV) const {
469      const int N = TrainSet->Len(); TFltV z(N, 0);
470      TFltV DotProdV(N, 0);
471      for (int i = 0; i < N; i++)
472          DotProdV.Add(TrainSet->DotProduct(i, SpV));
473      for (int i = 0; i < N; i++) 
474          z.Add(TLinAlg::DotProduct(GSBasisV[i], DotProdV));
475      ProjSpV.Gen(Vecs, 0); double Norm = 0.0;
476      for (int i = 0; i < Vecs; i++) {
477          const double Wgt = TLinAlg::DotProduct(z, BasisV[i]);
478          ProjSpV.Add(TIntFltKd(i, Wgt));
479          Norm += TMath::Sqr(Wgt);
480      }
481      if (NormP) {
482          Norm = sqrt(Norm);
483          for (int i = 0; i < Vecs; i++) { ProjSpV[i].Dat /= Norm; }
484      }
485  }
486  void TKCCASemSpace::GetVec(const int& VecN, TFltV& VecV) const {
487      const int GSDim = GSBasisV[0].Len();
488      const TFltV& w = BasisV[VecN];
489      IAssert(w.Len() == GSDim);
490      TFltV AlphV(GSDim); AlphV.PutAll(0.0);
491      for (int j = 0; j < GSDim; j++)
492          TLinAlg::AddVec(w[j], GSBasisV[j], AlphV, AlphV);
493      TrainSet->LinComb(AlphV, VecV);
494  }
495  void TSemSpaceAlg::CalcKCCA(const TFltVV& Ra, const TFltVV& Rb, 
496          const double& ta, const double& tb, const TKCCACorrNrmType& CorrNrmType, 
497          TVec<TFltV>& DrctAV, TVec<TFltV>& DrctBV, TFltV& CorrV) {
498      IAssert(Ra.GetCols() == Rb.GetCols());
499      const int Size = Ra.GetCols();
500      IAssert(Ra.GetRows() >= Rb.GetRows());
501      const int SubSizeA = Ra.GetRows();
502      const int SubSizeB = Rb.GetRows();
503      printf("step (2)...\n");
504      TFltVV R(SubSizeB, SubSizeB); 
505      for (int i = 0; i < SubSizeB; i++) {
506          for (int j = i; j < SubSizeB; j++) {
507              double res = 0.0;
508              for (int k = 0; k < Size; k++) {
509                  res += Rb(i,k) * Rb(j,k);  
510              }
511              R(i,j) = (1-tb)*res;
512          }
513          R(i,i) += tb;
514      }
515      TFltV Rp(SubSizeB);
516      printf("choleksy decomposition...");
517      TNumericalStuff::CholeskyDecomposition(R, Rp);
518      for (int i = 0; i < SubSizeB; i++) {
519          R(i,i) = Rp[i];  
520          for (int j = i+1; j < SubSizeB; j++)
521              R(i,j) = R(j,i); 
522      }
523      printf("invR...\n");
524      TNumericalStuff::InverseTriagonal(R);
525      printf("step (3)...\n");
526      TFltVV A(SubSizeA, SubSizeA);
527      printf("calculating: A...");
528      for (int i = 0; i < SubSizeA; i++) {
529          for (int j = i; j < SubSizeA; j++) {
530              double res = 0.0;
531              for (int k = 0; k < Size; k++) {
532                  res += Ra(i,k) * Ra(j,k);  
533              }
534              A(j,i) = A(i,j) = (1-ta)*res;
535          }
536          A(i,i) += ta;
537      }
538      printf("invA..."); 
539      TNumericalStuff::InverseSymetric(A);
540      TFltVV invA(SubSizeA, SubSizeA); 
541      for (int i = 0; i < SubSizeA; i++) {
542          invA(i,i) = A(i,i);
543          for (int j = i+1; j < SubSizeA; j++)
544              A(j,i) = invA(j,i) = invA(i,j) = A(i,j);
545      }
546      printf("invR'*Rb*Ra'*invA*Ra*Rb'*invR...");
547      printf("1..");
548      TFltVV RbRaT(SubSizeB, SubSizeA);
549      for (int i = 0; i < SubSizeB; i++) {
550          for (int j = 0; j < SubSizeA; j++) {
551              double res = 0.0;
552              for (int k = 0; k < Size; k++)
553                  res += Rb(i,k) * Ra(j,k);
554              RbRaT(i,j) = res;
555          }
556      }
557      printf("2..");
558      TFltVV B(SubSizeB, SubSizeA);
559      TLinAlg::Multiply(RbRaT, A, B);
560      A.Gen(SubSizeB, SubSizeB);
561      for (int i = 0; i < SubSizeB; i++) {
562          for (int j = 0; j < SubSizeB; j++) {
563              double sum = 0.0;
564              for (int k = 0; k < SubSizeA; k++)
565                  sum += B(i,k)*RbRaT(j,k);
566              A(i,j) = sum;
567          }
568      }
569      printf("3..");
570      B.Gen(SubSizeB, SubSizeB);
571      for (int i = 0; i < SubSizeB; i++) {
572          for (int j = 0; j < SubSizeB; j++) {
573              double sum = 0.0;
574              for (int k = 0; k <= i; k++)
575                  sum += R(k,i)*A(k,j);
576              B(i,j) = sum;
577          }
578      }
579      printf("4..");
580      for (int i = 0; i < SubSizeB; i++) {
581          for (int j = 0; j < SubSizeB; j++) {
582              double sum = 0.0;
583              for (int k = 0; k <= j; k++)
584                  sum += B(i,k)*R(k,j);
585              A(i,j) = sum;
586          }
587      }
588      printf("\nsolving eigneproblem...");
589      TFltV d(SubSizeB+1), e(SubSizeB+1);
590      printf("1..");
591      TNumericalStuff::SymetricToTridiag(A, SubSizeB, d, e);
592      TLAMisc::FillIdentity(B);
593      printf("2..");
594      TNumericalStuff::EigSymmetricTridiag(d, e, SubSizeB, B);
595      printf("3..");
596      TFltVV V(SubSizeB, SubSizeB);
597      TLinAlg::Multiply(A, B, V);
598      for (int i = 1; i <= SubSizeB; i++) d[i-1] = d[i];
599      d.DelLast(); 
600      printf("\nstep (4)...\n");
601      printf("Wb...");
602      for (int i = 0; i < SubSizeB; i++) {
603          for (int j = 0; j < SubSizeB; j++) {
604              double sum = 0.0;
605              for (int k = i; k < SubSizeB; k++)
606                  sum += R(i,k)*V(k,j);
607              B(i,j) = sum;
608          }
609      }
610      for (int j = 0; j < SubSizeB; j++) {
611          double norm = 0.0;
612          for (int i = 0; i < SubSizeB; i++)
613              norm += TMath::Sqr(B(i,j));
614          IAssert(norm > 0.0); norm = sqrt(norm);
615          for (int i = 0; i < SubSizeB; i++)
616              B(i,j) /= norm;
617      }
618      printf("Wa...");
619      V.Gen(SubSizeA, SubSizeB);
620      for (int i = 0; i < SubSizeA; i++) {
621          for (int j = 0; j < SubSizeB; j++) {
622              double sum = 0.0;
623              for (int k = 0; k < SubSizeA; k++)
624                  sum += invA(i,k)*RbRaT(j,k);
625              V(i,j) = sum;
626          }
627      }
628      A.Gen(SubSizeA, SubSizeB);
629      TLinAlg::Multiply(V, B, A);
630      for (int j = 0; j < SubSizeB; j++) {
631          double norm = 0.0;
632          for (int i = 0; i < SubSizeA; i++)
633              norm += TMath::Sqr(A(i,j));
634          IAssert(norm > 0.0); norm = sqrt(norm);
635          for (int i = 0; i < SubSizeA; i++)
636              A(i,j) /= norm;
637      }
638      Rp.Clr(); invA.Clr(); e.Clr(); R.Clr(); RbRaT.Clr(); V.Clr();
639      printf("\ndone...\n");
640      TFltIntKdV EigV(SubSizeB, 0);
641      for (int i = 0; i < SubSizeB; i++) EigV.Add(TFltIntKd(d[i], i));
642      EigV.Sort(false);
643      const int DrctN = SubSizeB-1; printf("SubSizeB = %d\n", SubSizeB);
644      DrctAV.Gen(DrctN); DrctBV.Gen(DrctN); CorrV.Gen(DrctN, 0);
645      TFltV RaTwa(Size), RbTwb(Size);
646      for (int i = 0; i < DrctN; i++) {
647          TFltV& wa = DrctAV[i]; wa.Gen(SubSizeA);
648          TFltV& wb = DrctBV[i]; wb.Gen(SubSizeB);
649          const int EigId = EigV[i+1].Dat;
650          CorrV.Add(EigV[i+1].Key);
651          for (int j = 0; j < SubSizeA; j++)
652              wa[j] = A(j, EigId);
653          for (int j = 0; j < SubSizeB; j++)
654              wb[j] = B(j, EigId);
655          if (CorrNrmType != kcntNone) {
656              double Corr = 1.0; 
657              if (CorrNrmType == kcntOne) { Corr = 1.0; }
658              else if (CorrNrmType == kcntEigVal) { Corr = CorrV.Last()/CorrV[0]; }
659              IAssert(Corr > 0.0);
660              TLinAlg::MultiplyT(Ra, wa, RaTwa);
661              const double KoefA = sqrt(Corr/TLinAlg::Norm2(RaTwa));
662              TLinAlg::MultiplyScalar(KoefA, wa, wa);
663              TLinAlg::MultiplyT(Ra, wa, RaTwa); 
664              IAssert(TFlt::Abs(TLinAlg::Norm2(RaTwa) - Corr) < 1e-7);
665              TLinAlg::MultiplyT(Rb, wb, RbTwb);
666              const double KoefB = sqrt(Corr/TLinAlg::Norm2(RbTwb));
667              TLinAlg::MultiplyScalar(KoefB, wb, wb);
668              TLinAlg::MultiplyT(Rb, wb, RbTwb); 
669              IAssert(TFlt::Abs(TLinAlg::Norm2(RbTwb) - Corr) < 1e-7);
670          }
671      }
672  }
673  void TSemSpaceAlg::CalcKCCA(PSVMTrainSet SetA, PSVMTrainSet SetB, const double& t, 
674          const int& SpaceDim, const double& Eps, PPartialGS& Ra, PPartialGS& Rb, 
675          const TKCCACorrNrmType& CorrNrmType, TVec<TFltV>& DrctAV, 
676          TVec<TFltV>& DrctBV, TFltV& EigV) {
677      IAssertR(SetA->Len() == SetB->Len() && SetB->Len() >= SpaceDim, 
678          TStr::Fmt("(SetA->Len() == %d) != (SetB->Len() == %d)", SetA->Len(), SetB->Len()));
679      IAssertR(0.0 <= t && t <= 1.0, TStr::Fmt("t=%d must be between 0.0 and 1.0!", t));
680      IAssertR(0.0 <= Eps && Eps < 1.0, TStr::Fmt("Eps=%d must be between 0.0 and 1.0!", Eps));
681      printf("step (1)...\n");
682      TFltVV RaVV, RbVV; 
683      printf("incomplete Cholesky... SetA\n");
684      Ra = TPartialGS::New(SetA(), SetA->Len(), Eps); Ra->GetDocVV(RaVV);
685      printf("incomplete Cholesky... SetB\n");
686      Rb = TPartialGS::New(SetB(), SetB->Len(), Eps); Rb->GetDocVV(RbVV);
687      const int NewSpaceDim = TInt::GetMn(RaVV.GetRows(), RbVV.GetRows());
688      if (RaVV.GetRows() > RbVV.GetRows()) {
689          CalcKCCA(RaVV, RbVV, t, t, CorrNrmType, DrctAV, DrctBV, EigV);
690      } else {
691          CalcKCCA(RbVV, RaVV, t, t, CorrNrmType, DrctBV, DrctAV, EigV);
692      }
693      IAssertR(DrctAV.Len() == NewSpaceDim-1  && DrctAV.Len() == NewSpaceDim-1,
694          TStr::Fmt("%d, %d != %d", DrctAV.Len(), DrctBV.Len(), NewSpaceDim-1));
695      if (DrctAV.Len() < SpaceDim) {
696          printf("SpaceDim is lowerd to %d!\n", DrctAV.Len());
697      } else {
698          DrctAV.Trunc(SpaceDim); DrctBV.Trunc(SpaceDim);
699      }
700  }
701  void TSemSpaceAlg::CalcKCCA(const TVec<PBowSpV>& BowSpVA, const TVec<PBowSpV>& BowSpVB, 
702          const double& t, const int& SpaceDim, const double& Eps, PSemSpace& SpA, 
703          PSemSpace& SpB, TFltV& EigV, const TKCCACorrNrmType& CorrNrmType) {
704      PSVMTrainSet SetA = TBowDocBs2TrainSet::NewBowNoCat(BowSpVA);
705      PSVMTrainSet SetB = TBowDocBs2TrainSet::NewBowNoCat(BowSpVB);
706      PPartialGS Ra, Rb; TVec<TFltV> DrctAV, DrctBV;
707      CalcKCCA(SetA, SetB, t, SpaceDim, Eps, Ra, Rb, CorrNrmType, DrctAV, DrctBV, EigV);
708      SpA = TKCCASemSpace::New(SetA, Ra, DrctAV, "KCCA");
709      SpB = TKCCASemSpace::New(SetB, Rb, DrctBV, "KCCA");
710  }
711  void TSemSpaceAlg::CalcVecKCCA(const TVec<PBowSpV>& BowSpVA, const TVec<PBowSpV>& BowSpVB, 
712          const double& t, const int& SpaceDim, const double& Eps, PSemSpace& SpA, 
713          PSemSpace& SpB, const TKCCACorrNrmType& CorrNrmType) {
714      PSVMTrainSet SetA = TBowDocBs2TrainSet::NewBowNoCat(BowSpVA);
715      PSVMTrainSet SetB = TBowDocBs2TrainSet::NewBowNoCat(BowSpVB);
716      PPartialGS Ra, Rb; TVec<TFltV> DrctAV, DrctBV; TFltV EigV;
717      CalcKCCA(SetA, SetB, t, SpaceDim, Eps, Ra, Rb, CorrNrmType, DrctAV, DrctBV, EigV);
718      SpA = TVecSemSpace::New(SetA, Ra, DrctAV, "KCCA-Vec");
719      SpB = TVecSemSpace::New(SetB, Rb, DrctBV, "KCCA-Vec");
720  }
721  void TSemSpaceAlg::DecomposeKernelMatrix(PSVMTrainSet Set, const int& Dim, 
722          TVec<TFltV>& CompV, const bool& CenterMatrix) {
723      const int Size = Set->Len();
724      TFltVV K; TKernelUtil::CalcKernelMatrix(Set, K);
<span onclick='openModal()' class='match'>725      if (CenterMatrix) {
726          TKernelUtil::CenterKernelMatrix(K);
727      }
728      TFltV d(Size+1), e(Size+1);
729      TNumericalStuff::SymetricToTridiag(K, Size, d, e);
730      TFltVV V(Size, Size); TLAMisc::FillIdentity(V);
731      TNumericalStuff::EigSymmetricTridiag(d, e, Size, V);
732      TFltIntKdV EigV(Size, 0);
733      for (int i = 1; i <= Size; i++) {
734          EigV.Add(TFltIntKd(d[i], i-1));
735          d[i-1] = sqrt(1.0/d[i]);
736      }
</span>737      EigV.Sort(false); d.DelLast();
738      CompV.Gen(Dim);
739      for (int i = 0; i < Dim; i++) {
740          const int ColId = EigV[i].Dat;
741          TFltV& v = CompV[i]; v.Gen(Size);
742          TLinAlg::Multiply(K, V, ColId, v); 
743          TLinAlg::MultiplyScalar(d[ColId], v, v);
744      }
745  }
746  PSemSpace TSemSpaceAlg::CalcKPCA(PSVMTrainSet Set) {
747      const int Dim = Set->Len(); TVec<TFltV> CompV;
748      DecomposeKernelMatrix(Set, Dim, CompV, true);
749      TVec<TFltV> PrCompV(CompV.Len());
750      for (int i = 0; i < PrCompV.Len(); i++)
751          Set->LinComb(CompV[i], PrCompV[i]);
752      return TVecSemSpace::New(PrCompV, "KPCA");
753  }
754  PSemSpace TSemSpaceAlg::CalcKPCA(const TVec<PBowSpV>& BowSpV) {
755      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowSpV);
756      return CalcKPCA(Set);
757  }
758  PSemSpace TSemSpaceAlg::CalcKPCA(PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV) {
759      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
760      return CalcKPCA(Set);
761  }
762  PSemSpace TSemSpaceAlg::CalcFullLSI(PSVMTrainSet Set, const int& SpaceDim) {
763      const int Dim = Set->Len(); TVec<TFltV> CompV;
764      DecomposeKernelMatrix(Set, Dim, CompV, false);
765      const int CompN = TInt::GetMn(CompV.Len(), SpaceDim+1);
766      TVec<TFltV> PrCompV(CompN-1);
767      for (int i = 1; i < CompN ; i++) {
768          Set->LinComb(CompV[i], PrCompV[i-1]);
769      }
770      return TVecSemSpace::New(PrCompV, "FullLSI");
771  }
772  PSemSpace TSemSpaceAlg::CalcFullLSI(const TVec<PBowSpV>& BowSpV, const int& SpaceDim) {
773      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowSpV);
774      return CalcFullLSI(Set, SpaceDim);
775  }
776  PSemSpace TSemSpaceAlg::CalcFullLSI(PBowDocWgtBs BowDocWgtBs, 
777          const TIntV& DIdV, const int& SpaceDim) {
778      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
779      return CalcFullLSI(Set, SpaceDim);
780  }
781  PSemSpace TSemSpaceAlg::CalcSparseLSI(TMatrix& TermDocM, const int& _SpaceDim, 
782          const int& _MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
783      const int SpaceDim = TInt::GetMn(_SpaceDim, TermDocM.GetCols());
784      const int MaxLanczos = TInt::GetMn(_MaxLanczos, TermDocM.GetCols());
785      IAssertR(SpaceDim <= MaxLanczos, TStr::Fmt("%d <= %d", SpaceDim, MaxLanczos));
786      TFltV SgnV; TFltVV U, V; const int SgnN = SpaceDim;
787      if (TermDocM.GetCols() <= TermDocM.GetRows()) {
788          TSparseSVD::LanczosSVD(TermDocM, SgnN, 
789              TInt::GetMn(SgnN*4, MaxLanczos), ReOrtoType, SgnV, U, V);
790      } else {
791  	    TermDocM.Transpose();
792  	    TSparseSVD::LanczosSVD(TermDocM, SgnN, 
793              TInt::GetMn(SgnN*4, MaxLanczos), ReOrtoType, SgnV, V, U);
794  	    TermDocM.Transpose();
795      }
796      IAssert(U.GetYDim() <= SgnN);
797      return TVecSemSpace::New(U, "SparseLSI");
798  }
799  PSemSpace TSemSpaceAlg::CalcSparseLSI(PSVMTrainSet Set, const int& SpaceDim, 
800          const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
801      TSTSetMatrix TermDocM(Set);
802      return CalcSparseLSI(TermDocM, SpaceDim, 
803          TInt::GetMn(MaxLanczos, Set->Len()), ReOrtoType);
804  }
805  PSemSpace TSemSpaceAlg::CalcSparseLSI(const TVec<PBowSpV>& BowSpV,
806          const int& SpaceDim, const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
807      TBowMatrix TermDocM(BowSpV);
808      return CalcSparseLSI(TermDocM, SpaceDim, 
809          TInt::GetMn(MaxLanczos, BowSpV.Len()), ReOrtoType);
810  }
811  PSemSpace TSemSpaceAlg::CalcSparseLSI(PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV,
812          const int& SpaceDim, const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
813      TBowMatrix TermDocM(BowDocWgtBs, DIdV);
814      return CalcSparseLSI(TermDocM, SpaceDim, 
815          TInt::GetMn(MaxLanczos, DIdV.Len()), ReOrtoType);
816  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-genericvector.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-semspace.cpp</div>
                <div class="column column_space"><pre><code>340    if (size_reserved_ == size_used_) {
341      double_the_size();
342    }
343    for (int i = size_used_; i > index; --i) {
344      data_[i] = data_[i - 1];
345    }
</pre></code></div>
                <div class="column column_space"><pre><code>725      if (CenterMatrix) {
726          TKernelUtil::CenterKernelMatrix(K);
727      }
728      TFltV d(Size+1), e(Size+1);
729      TNumericalStuff::SymetricToTridiag(K, Size, d, e);
730      TFltVV V(Size, Size); TLAMisc::FillIdentity(V);
731      TNumericalStuff::EigSymmetricTridiag(d, e, Size, V);
732      TFltIntKdV EigV(Size, 0);
733      for (int i = 1; i <= Size; i++) {
734          EigV.Add(TFltIntKd(d[i], i-1));
735          d[i-1] = sqrt(1.0/d[i]);
736      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    