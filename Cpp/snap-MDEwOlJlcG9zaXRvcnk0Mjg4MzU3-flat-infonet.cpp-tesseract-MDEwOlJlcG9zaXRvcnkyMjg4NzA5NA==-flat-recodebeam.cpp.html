
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.103825136612022%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-infonet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "infonet.h"
3  TStr TThermalSch::GetFldVal(const PXmlTok& RecXmlTok, const TStr& FldNm) const {
4    PXmlTok FldTagTok;
5    if (RecXmlTok->IsTagTok(FldNm, FldTagTok)){
6      return FldTagTok->GetTokStr(false);}
7    else {return "";}
8  }
9  TStr TThermalSch::GetFldVal(const PXmlDoc& RecXmlDoc, const TStr& FldNm) const {
10    PXmlTok FldTagTok;
11    if (RecXmlDoc->IsTagTok(FldNm, FldTagTok)){
12      return FldTagTok->GetTokStr(false);}
13    else {return "";}
14  }
15  TStr TThermalSch::GetFldDateVal(const PXmlTok& RecXmlTok, const TStr& FldNm) const {
16    TStr DateVal=TThermalSch::GetFldVal(RecXmlTok, FldNm);
17    DateVal.DelChAll('-');
18    return DateVal;
19  }
20  TStr TThermalSch::GetFldDateVal(const PXmlDoc& RecXmlDoc, const TStr& FldNm) const {
21    TStr DateVal=TThermalSch::GetFldVal(RecXmlDoc, FldNm);
22    DateVal.DelChAll('-');
23    return DateVal;
24  }
25  TStrV TThermalSch::GetFldValV(const PXmlTok& RecXmlTok, const TStr& FldNm,
26   const TStr& XFldNm, const TStr& SubFldNm) const {
27    TStrV FldValV;
28    PXmlTok FldTagTok;
29    if (RecXmlTok->IsTagTok(FldNm, FldTagTok)){
30      if (SubFldNm.Empty()){
31        FldTagTok->GetTagValV(XFldNm, false, FldValV);
32      } else {
33        TXmlTokV XmlTokV; FldTagTok->GetTagTokV(XFldNm, XmlTokV);
34        for (int FldN=0; FldN<XmlTokV.Len(); FldN++){
35          TStr FldVal=GetFldVal(XmlTokV[FldN], SubFldNm);
36          FldValV.Add(FldVal);
37        }
38      }
39    }
40    return FldValV;
41  }
42  TStr TThermalSch::GetXmlOut_Ok(const TStr& OpNm){
43    TChA ChA;
44    ChA+="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
45    ChA+="<ParamOut>\n";
46    ChA+="<OperationName>";
47    ChA+=TXmlLx::GetXmlStrFromPlainStr(OpNm);
48    ChA+="</OperationName>\n";
49    ChA+="<Success>Ok</Success>\n";
50    ChA+="</ParamOut>\n";
51    return ChA;
52  }
53  TStr TThermalSch::GetXmlOut_Error(const TStr& OpNm, const TStr& MsgStr){
54    TChA ChA;
55    ChA+="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
56    ChA+="<ParamOut>\n";
57    ChA+="<OperationName>";
58    ChA+=TXmlLx::GetXmlStrFromPlainStr(OpNm);
59    ChA+="</OperationName>\n";
60    ChA+="<Success>Error</Success>\n";
61    ChA+="<ResultMessage>";
62    ChA+=TXmlLx::GetXmlStrFromPlainStr(MsgStr);
63    ChA+="</ResultMessage>\n";
64    ChA+="</ParamOut>\n";
65    return ChA;
66  }
67  TStr TThermalSch::ExeCmFromXml(const PSIn& SIn){
68    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
69    if (XmlDoc->IsOk()){
70      TStr CmTagNm="Operation|OperationName";
71      if (XmlDoc->IsTagTok(CmTagNm)){
72        TStr CmNm=XmlDoc->GetTagTokStr(CmTagNm);
73        if (CmNm=="SetCatalogueTherapyPlaces"){
74          return ExeCm_SetCatalogueTherapyPlaces(XmlDoc);
75        } else if (CmNm=="SetCatalogueActivities"){
76          return ExeCm_SetCatalogueActivities(XmlDoc);
77        } else if (CmNm=="SetCatalogueAvailableTherapyPlaces"){
78          return ExeCm_SetCatalogueAvailableTherapyPlaces(XmlDoc);
79        } else if (CmNm=="SetCatalogueAvailableActivities"){
80          return ExeCm_SetCatalogueAvailableActivities(XmlDoc);
81        } else if (CmNm=="SetScheduledActivities"){
82          return ExeCm_SetScheduledActivities(XmlDoc);
83        } else if (CmNm=="SetCatalogueHolidays"){
84          return ExeCm_SetCatalogueHolidays(XmlDoc);
85        } else if (CmNm=="MakeSchedule"){
86          return ExeCm_MakeSchedule(XmlDoc);
87        } else if (CmNm=="CheckSchedule"){
88          return ExeCm_CheckSchedule(XmlDoc);
89        } else {
90          TStr CmXmlStr=TXmlLx::GetXmlStrFromPlainStr(CmNm);
91          return GetXmlOut_Error(CmXmlStr, TStr("Invalid Command: '")+CmXmlStr+"'.");
92        }
93      } else {
94        TStr CmTagXmlStr=TXmlLx::GetXmlStrFromPlainStr(CmTagNm);
95        return GetXmlOut_Error("NoCommand", TStr("Command tag not found: '")+CmTagXmlStr+"'.");
96      }
97    } else {
98      return GetXmlOut_Error("NoCommand", TStr("Invalid XML Format: '")+XmlDoc->GetMsgStr()+"'.");
99    }
100  }
101  TStr TThermalSch::ExeCmFromXmlFile(const TStr& FNm, const TStr& FPath){
102    TStr FullFNm=TStr::GetNrFPath(FPath)+FNm;
103    bool OpenedP;
104    PSIn SIn=TFIn::New(FullFNm, OpenedP);
105    if (OpenedP){
106      return ExeCmFromXml(SIn);
107    } else {
108      return GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+FNm+"'.");
109    }
110  }
111  TStr TThermalSch::ExeCmFromXmlStr(const TStr& Str){
112    PSIn SIn=TStrIn::New(Str);
113    return ExeCmFromXml(SIn);
114  }
115  TStr TThermalSch::ExeCm_SetCatalogueTherapyPlaces(const PXmlDoc& XmlDoc){
116    TherapyPlacesXmlDoc=XmlDoc;
117    TStr MsgStr;
118    if (IsTherapyPlacesOk(MsgStr)){
119      return TThermalSch::GetXmlOut_Ok("SetCatalogueTherapyPlaces");
120    } else {
121      TherapyPlacesXmlDoc=NULL;
122      return MsgStr;
123    }
124  }
125  TStr TThermalSch::ExeCm_SetCatalogueActivities(const PXmlDoc& XmlDoc){
126    ActivitiesXmlDoc=XmlDoc;
127    TStr MsgStr;
128    if (IsActivitiesOk(MsgStr)){
129      return TThermalSch::GetXmlOut_Ok("SetCatalogueActivities");
130    } else {
131      ActivitiesXmlDoc=NULL;
132      return MsgStr;
133    }
134  }
135  TStr TThermalSch::ExeCm_SetCatalogueAvailableTherapyPlaces(const PXmlDoc& XmlDoc){
136    AvailableTherapyPlacesXmlDoc=XmlDoc;
137    TStr MsgStr;
138    if (IsAvailableTherapyPlacesOk(MsgStr)){
139      return TThermalSch::GetXmlOut_Ok("SetCatalogueAvailableTherapyPlaces");
140    } else {
141      AvailableTherapyPlacesXmlDoc=NULL;
142      return MsgStr;
143    }
144  }
145  TStr TThermalSch::ExeCm_SetCatalogueAvailableActivities(const PXmlDoc& XmlDoc){
146    AvailableActivitiesXmlDoc=XmlDoc;
147    TStr MsgStr;
148    if (IsAvailableActivitiesOk(MsgStr)){
149      return TThermalSch::GetXmlOut_Ok("SetCatalogueAvailableActivities");
150    } else {
151      AvailableActivitiesXmlDoc=NULL;
152      return MsgStr;
153    }
154  }
155  TStr TThermalSch::ExeCm_SetScheduledActivities(const PXmlDoc& XmlDoc){
156    ScheduledActivitiesXmlDoc=XmlDoc;
157    TStr MsgStr;
158    if (IsScheduledActivitiesOk(MsgStr)){
159      return TThermalSch::GetXmlOut_Ok("SetScheduledActivities");
160    } else {
161      ScheduledActivitiesXmlDoc=NULL;
162      return MsgStr;
163    }
164  }
165  TStr TThermalSch::ExeCm_SetCatalogueHolidays(const PXmlDoc& XmlDoc){
166    HolidaysXmlDoc=XmlDoc;
167    TStr MsgStr;
168    if (IsHolidaysOk(MsgStr)){
169      return TThermalSch::GetXmlOut_Ok("SetCatalogueHolidays");
170    } else {
171      HolidaysXmlDoc=NULL;
172      return MsgStr;
173    }
174  }
175  TStr TThermalSch::ExeCm_MakeSchedule(const PXmlDoc& XmlDoc){
176    MakeScheduleXmlDoc=XmlDoc;
177    TStr MsgStr;
178    if (IsMakeScheduleOk(MsgStr)){
179      SaveOldCsv();
180      TChA CmLn;
181      CmLn+="genscher.exe";
182      CmLn+=" -dir"; CmLn+=GetMakeSchedule_PatientATPCode();
183      CmLn+=" -pass";
184      system(CmLn.CStr());
185      TThermalSch::SaveCsvToXml("URNIKXXG.TXT", "URNIKXX0.TXT", "Out.Xml");
186      TThermalSch::SaveCsvToXmlParamOut("URNIKXXG.TXT", "URNIKXX0.TXT", "ParamOut.Xml");
187      TStr XmlStr=TStr::LoadTxt("ParamOut.Xml");
188      return XmlStr;
189    } else {
190      MakeScheduleXmlDoc=NULL;
191      return MsgStr;
192    }
193  }
194  TStr TThermalSch::ExeCm_CheckSchedule(const PXmlDoc& XmlDoc){
195    CheckScheduleXmlDoc=XmlDoc;
196    TStr MsgStr;
197    if (IsCheckScheduleOk(MsgStr)){
198      return TThermalSch::GetXmlOut_Ok("CheckSchedule");
199    } else {
200      CheckScheduleXmlDoc=NULL;
201      return MsgStr;
202    }
203  }
204  bool TThermalSch::IsTherapyPlacesOk(TStr& MsgStr) const {
205    if (TherapyPlacesXmlDoc.Empty()){
206      MsgStr=GetXmlOut_Error("SetCatalogueTherapyPlaces", "TherapyPlaces doesn't exists.");
207    }
208    int TherapyPlaces=TThermalSch::GetTherapyPlaces();
209    for (int TherapyPlaceN=0; TherapyPlaceN<TherapyPlaces; TherapyPlaceN++){
210      PXmlTok TherapyPlace=TThermalSch::GetTherapyPlace(TherapyPlaceN);
211      if (TherapyPlace->IsTag("TherapyPlace")){
212        GetTherapyPlace_Code(TherapyPlace);
213        GetTherapyPlace_Type(TherapyPlace);
214        GetTherapyPlace_Location(TherapyPlace);
215        GetTherapyPlace_Capacity(TherapyPlace);
216        GetTherapyPlace_Distance(TherapyPlace);
217        GetTherapyPlace_Gender(TherapyPlace);
218        GetTherapyPlace_AlternateScheduling(TherapyPlace);
219        GetTherapyPlace_FamilyScheduling(TherapyPlace);
220        GetTherapyPlace_TherapistType(TherapyPlace);
221      } else {
222        MsgStr=GetXmlOut_Error("SetCatalogueTherapyPlaces", "Invalid TherapyPlaces.");
223        return false;
224      }
225    }
226    return true;
227  }
228  int TThermalSch::GetTherapyPlaces() const {
229    if (TherapyPlacesXmlDoc.Empty()){return 0;}
230    TXmlTokV XmlTokV;
231    TherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|TherapyPlaces|TherapyPlace", XmlTokV);
232    return XmlTokV.Len();
233  }
234  PXmlTok TThermalSch::GetTherapyPlace(const int& TherapyPlaceN) const {
235    TXmlTokV XmlTokV;
236    TherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|TherapyPlaces|TherapyPlace", XmlTokV);
237    return XmlTokV[TherapyPlaceN];
238  }
239  bool TThermalSch::IsActivitiesOk(TStr& MsgStr) const {
240    if (ActivitiesXmlDoc.Empty()){
241      MsgStr=GetXmlOut_Error("SetCatalogueActivities", "Activities doesn't exists.");
242    }
243    int Activities=TThermalSch::GetActivities();
244    for (int ActivityN=0; ActivityN<Activities; ActivityN++){
245      PXmlTok Activity=TThermalSch::GetActivity(ActivityN);
246      if (Activity->IsTag("Activity")){
247        GetActivity_Code(Activity);
248        GetActivity_Type(Activity);
249        GetActivity_Name(Activity);
250        GetActivity_Priority(Activity);
251        GetActivity_Duration(Activity);
252        GetActivity_TPDuration(Activity);
253        GetActivity_PatientDuration(Activity);
254        GetActivity_TherapistDurationPreparation(Activity);
255        GetActivity_TherapistDurationExecution(Activity);
256        GetActivity_TherapistDurationAdditionalTime(Activity);
257        GetActivity_Weariness(Activity);
258        GetActivity_Dry(Activity);
259      } else {
260        MsgStr=GetXmlOut_Error("SetCatalogueActivities", "Invalid Activities.");
261        return false;
262      }
263    }
264    return true;
265  }
266  int TThermalSch::GetActivities() const {
267    if (ActivitiesXmlDoc.Empty()){return 0;}
268    TXmlTokV XmlTokV;
269    ActivitiesXmlDoc->GetTagTokV("Operation|Parameter|Activities|Activity", XmlTokV);
270    return XmlTokV.Len();
271  }
272  PXmlTok TThermalSch::GetActivity(const int& ActivityN) const {
273    TXmlTokV XmlTokV;
274    ActivitiesXmlDoc->GetTagTokV("Operation|Parameter|Activities|Activity", XmlTokV);
275    return XmlTokV[ActivityN];
276  }
277  bool TThermalSch::IsAvailableTherapyPlacesOk(TStr& MsgStr) const {
278    if (AvailableTherapyPlacesXmlDoc.Empty()){
279      MsgStr=GetXmlOut_Error("SetCatalogueAvailableTherapyPlaces", "Available-Therapy-Places doesn't exists.");
280      return false;
281    }
282    int AvailableTherapyPlaces=TThermalSch::GetAvailableTherapyPlaces();
283    for (int AvailableTherapyPlaceN=0; AvailableTherapyPlaceN<AvailableTherapyPlaces; AvailableTherapyPlaceN++){
284      PXmlTok AvailableTherapyPlace=TThermalSch::GetAvailableTherapyPlace(AvailableTherapyPlaceN);
285      if (AvailableTherapyPlace->IsTag("AvailableTherapyPlace")){
286        GetAvailableTherapyPlace_Code(AvailableTherapyPlace);
287        int TherapyPlaceSchedules=GetTherapyPlaceSchedules(AvailableTherapyPlace);
288        for (int TherapyPlaceScheduleN=0; TherapyPlaceScheduleN<TherapyPlaceSchedules; TherapyPlaceScheduleN++){
289          PXmlTok TherapyPlaceSchedule=GetTherapyPlaceSchedule(AvailableTherapyPlace, TherapyPlaceScheduleN);
290          if (TherapyPlaceSchedule->IsTag("TherapyPlaceSchedule")){
291            GetTherapyPlaceSchedule_WeekDays(TherapyPlaceSchedule);
292            GetTherapyPlaceSchedule_OpenFrom(TherapyPlaceSchedule);
293            GetTherapyPlaceSchedule_OpenTill(TherapyPlaceSchedule);
294            GetTherapyPlaceSchedule_ValidFrom(TherapyPlaceSchedule);
295            GetTherapyPlaceSchedule_ValidTo(TherapyPlaceSchedule);
296          }
297        }
298      } else {
299        MsgStr=GetXmlOut_Error("SetCatalogueAvailableTherapyPlaces", "Invalid Available-Therapy-Places.");
300        return false;
301      }
302    }
303    return true;
304  }
305  int TThermalSch::GetAvailableTherapyPlaces() const {
306    if (AvailableTherapyPlacesXmlDoc.Empty()){return 0;}
307    TXmlTokV XmlTokV;
308    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace", XmlTokV);
309    return XmlTokV.Len();
310  }
311  PXmlTok TThermalSch::GetAvailableTherapyPlace(const int& AvailableTherapyPlaceN) const {
312    TXmlTokV XmlTokV;
313    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace", XmlTokV);
314    return XmlTokV[AvailableTherapyPlaceN];
315  }
316  int TThermalSch::GetTherapyPlaceSchedules(const PXmlTok& AvailableTherapyPlace) const {
317    TXmlTokV XmlTokV;
318    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace|TherapyPlaceSchedules|TherapyPlaceSchedule", XmlTokV);
319    return XmlTokV.Len();
320  }
321  PXmlTok TThermalSch::GetTherapyPlaceSchedule(const PXmlTok& AvailableTherapyPlace, const int& TherapyPlaceScheduleN) const {
322    TXmlTokV XmlTokV;
323    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace|TherapyPlaceSchedules|TherapyPlaceSchedule", XmlTokV);
324    return XmlTokV[TherapyPlaceScheduleN];
325  }
326  bool TThermalSch::IsAvailableActivitiesOk(TStr& MsgStr) const {
327    if (AvailableActivitiesXmlDoc.Empty()){
328      MsgStr=GetXmlOut_Error("SetCatalogueAvailableActivities", "Available-Activities doesn't exists.");
329      return false;
330    }
331    int AvailableActivities=TThermalSch::GetAvailableActivities();
332    for (int AvailableActivityN=0; AvailableActivityN<AvailableActivities; AvailableActivityN++){
333      PXmlTok AvailableActivity=TThermalSch::GetAvailableActivity(AvailableActivityN);
334      if (AvailableActivity->IsTag("AvailableActivity")){
335        GetAvailableActivity_Code(AvailableActivity);
336        int ActivitySchedules=GetActivitySchedules(AvailableActivity);
337        for (int ActivityScheduleN=0; ActivityScheduleN<ActivitySchedules; ActivityScheduleN++){
338          PXmlTok ActivitySchedule=GetActivitySchedule(AvailableActivity, ActivityScheduleN);
339          if (ActivitySchedule->IsTag("ActivitySchedule")){
340            GetActivitySchedule_WeekDays(ActivitySchedule);
341            GetActivitySchedule_StartTime(ActivitySchedule);
342            GetActivitySchedule_EndTime(ActivitySchedule);
343            GetActivitySchedule_TherapyPlaceType(ActivitySchedule);
344            GetActivitySchedule_ValidFrom(ActivitySchedule);
345            GetActivitySchedule_ValidTo(ActivitySchedule);
346          }
347        }
348      } else {
349        MsgStr=GetXmlOut_Error("SetCatalogueAvailableActivities", "Invalid Available-Activities.");
350        return false;
351      }
352    }
353    return true;
354  }
355  int TThermalSch::GetAvailableActivities() const {
356    if (AvailableActivitiesXmlDoc.Empty()){return 0;}
357    TXmlTokV XmlTokV;
358    AvailableActivitiesXmlDoc->GetTagTokV("Operation|Parameter|AvailableActivities|AvailableActivity", XmlTokV);
359    return XmlTokV.Len();
360  }
361  PXmlTok TThermalSch::GetAvailableActivity(const int& AvailableActivityN) const {
362    TXmlTokV XmlTokV;
363    AvailableActivitiesXmlDoc->GetTagTokV("Operation|Parameter|AvailableActivities|AvailableActivity", XmlTokV);
364    return XmlTokV[AvailableActivityN];
365  }
366  int TThermalSch::GetActivitySchedules(const PXmlTok& AvailableActivity) const {
367    TXmlTokV XmlTokV;
368    AvailableActivity->GetTagTokV("ActivitySchedules|ActivitySchedule", XmlTokV);
369    return XmlTokV.Len();
370  }
371  PXmlTok TThermalSch::GetActivitySchedule(const PXmlTok& AvailableActivity, const int& ActivityScheduleN) const {
372    TXmlTokV XmlTokV;
373    AvailableActivity->GetTagTokV("ActivitySchedules|ActivitySchedule", XmlTokV);
374    return XmlTokV[ActivityScheduleN];
375  }
376  bool TThermalSch::IsScheduledActivitiesOk(TStr& MsgStr) const {
377    if (ScheduledActivitiesXmlDoc.Empty()){
378      MsgStr=GetXmlOut_Error("SetScheduledActivities", "Scheduled-Activities doesn't exists.");
379      return false;
380    }
381    int ScheduledActivities=TThermalSch::GetScheduledActivities();
382    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
383      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
384      if (ScheduledActivity->IsTag("ScheduledActivity")){
385        GetScheduledActivity_Code(ScheduledActivity);
386        GetScheduledActivity_Code(ScheduledActivity);
387        GetScheduledActivity_PatientATPCode(ScheduledActivity);
388        GetScheduledActivity_Patient(ScheduledActivity);
389        GetScheduledActivity_TherapistCode(ScheduledActivity);
390        GetScheduledActivity_TherapyPlaceCode(ScheduledActivity);
391        GetScheduledActivity_ActivityCode(ScheduledActivity);
392        GetScheduledActivity_StartDateTime(ScheduledActivity);
393        GetScheduledActivity_RepetitionNumber(ScheduledActivity);
394        GetScheduledActivity_StartingPoint(ScheduledActivity);
395        GetScheduledActivity_PatientDuration(ScheduledActivity);
396      } else {
397        MsgStr=GetXmlOut_Error("SetScheduledActivities", "Invalid Scheduled-Activities.");
398        return false;
399      }
400    }
401    return true;
402  }
403  int TThermalSch::GetScheduledActivities() const {
404    if (ScheduledActivitiesXmlDoc.Empty()){return 0;}
405    TXmlTokV XmlTokV;
406    ScheduledActivitiesXmlDoc->GetTagTokV("Operation|Parameter|ScheduledActivities|ScheduledActivity", XmlTokV);
407    return XmlTokV.Len();
408  }
409  PXmlTok TThermalSch::GetScheduledActivity(const int& ScheduledActivityN) const {
410    TXmlTokV XmlTokV;
411    ScheduledActivitiesXmlDoc->GetTagTokV("Operation|Parameter|ScheduledActivities|ScheduledActivity", XmlTokV);
412    return XmlTokV[ScheduledActivityN];
413  }
414  bool TThermalSch::IsHolidaysOk(TStr& MsgStr) const {
415    if (HolidaysXmlDoc.Empty()){
416      MsgStr=GetXmlOut_Error("SetCatalogueHolidays", "Holidays doesn't exists.");
417      return false;
418    }
419    int Holidays=TThermalSch::GetHolidays();
420    for (int HolidayN=0; HolidayN<Holidays; HolidayN++){
421      PXmlTok Holiday=TThermalSch::GetHoliday(HolidayN);
422      if (Holiday->IsTag("Holiday")){
423        TStr Str=GetHoliday_Date(Holiday);
424      } else {
425        MsgStr=GetXmlOut_Error("SetCatalogueHolidays", "Invalid Holidays.");
426        return false;
427      }
428    }
429    return true;
430  }
431  int TThermalSch::GetHolidays() const {
432    if (HolidaysXmlDoc.Empty()){return 0;}
433    TXmlTokV XmlTokV;
434    HolidaysXmlDoc->GetTagTokV("Operation|Parameter|Holidays|Holiday", XmlTokV);
435    return XmlTokV.Len();
436  }
437  PXmlTok TThermalSch::GetHoliday(const int& HolidayN) const {
438    TXmlTokV XmlTokV;
439    HolidaysXmlDoc->GetTagTokV("Operation|Parameter|Holidays|Holiday", XmlTokV);
440    return XmlTokV[HolidayN];
441  }
442  bool TThermalSch::IsMakeScheduleOk(TStr& MsgStr) const {
443    if (MakeScheduleXmlDoc.Empty()){
444      MsgStr=GetXmlOut_Error("MakeSchedule", "Make-Schedule doesn't exists.");
445      return false;
446    }
447    GetMakeSchedule_PatientCode();
448    GetMakeSchedule_PatientGender();
449    GetMakeSchedule_PatientATPCode();
450    int PlanRequests=TThermalSch::GetMakeSchedule_PlanRequests();
451    for (int PlanRequestN=0; PlanRequestN<PlanRequests; PlanRequestN++){
452      PXmlTok PlanRequest=TThermalSch::GetMakeSchedule_PlanRequest(PlanRequestN);
453      if (PlanRequest->IsTag("PlanRequest")){
454        GetMakeSchedule_PlanRequest_ActivityCode(PlanRequest);
455        GetMakeSchedule_PlanRequest_Quantity(PlanRequest);
456        GetMakeSchedule_PlanRequest_DayQuantity(PlanRequest);
457        GetMakeSchedule_PlanRequest_Frequency(PlanRequest);
458        GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest);
459        GetMakeSchedule_PlanRequest_ExcludedActivities_ActivityCode(PlanRequest);
460        GetMakeSchedule_PlanRequest_ExcludedActivities_Time(PlanRequest);
461        GetMakeSchedule_PlanRequest_FamilyActivity(PlanRequest);
462        GetMakeSchedule_PlanRequest_TreatmentDate(PlanRequest);
463        GetMakeSchedule_PlanRequest_DesiredStartTime(PlanRequest);
464        GetMakeSchedule_PlanRequest_DesiredFinishTime(PlanRequest);
465      } else {
466        MsgStr=GetXmlOut_Error("MakeSchedule", "Invalid Make-Schedule.");
467        return false;
468      }
469    }
470    return true;
471  }
472  int TThermalSch::GetMakeSchedule_PlanRequests() const {
473    if (MakeScheduleXmlDoc.Empty()){return 0;}
474    TXmlTokV XmlTokV;
475    MakeScheduleXmlDoc->GetTagTokV("Operation|Parameter|PlanRequests|PlanRequest", XmlTokV);
476    return XmlTokV.Len();
477  }
478  PXmlTok TThermalSch::GetMakeSchedule_PlanRequest(const int& PlanRequestN) const {
479    TXmlTokV XmlTokV;
480    MakeScheduleXmlDoc->GetTagTokV("Operation|Parameter|PlanRequests|PlanRequest", XmlTokV);
481    return XmlTokV[PlanRequestN];
482  }
483  bool TThermalSch::IsCheckScheduleOk(TStr& MsgStr) const {
484    if (CheckScheduleXmlDoc.Empty()){
485      MsgStr=GetXmlOut_Error("CheckSchedule", "Check-Schedule doesn't exists.");
486      return false;
487    }
488    GetCheckSchedule_PatientCode();
489    GetCheckSchedule_PatientGender();
490    GetCheckSchedule_PatientATPCode();
491    GetCheckSchedule_IntRequestedActivityActivityCode();
492    GetCheckSchedule_IntRequestedActivityDayQuantity();
493    GetCheckSchedule_IntRequestedActivityTreatmentDate();
494    GetCheckSchedule_IntRequestedActivityDesiredStartTime();
495    GetCheckSchedule_IntRequestedActivityDesiredFinishTime();
496    return true;
497  }
498  void TThermalSch::SaveCsvToXml(
499   const TStr& DefFNm, const TStr& DatFNm, const TStr& XmlFNm){
500    if (!TFile::Exists(DefFNm)){
501      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
502      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DefFNm+"'."));
503      return;
504    }
505    if (!TFile::Exists(DatFNm)){
506      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
507      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DatFNm+"'."));
508      return;
509    }
510    PSs DefSs=TSs::LoadTxt(ssfCommaSep, DefFNm);
511    TStrV FldNmV;
512    for (int Y=0; Y<DefSs->GetYLen(); Y++){
513      FldNmV.Add(DefSs->GetVal(0, Y));}
514    PSs DatSs=TSs::LoadTxt(ssfCommaSep, DatFNm);
515    TVec<TStrV> RecFldValVV;
516    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
517      TStrV FldValV;
518      for (int X=0; X<DatSs->GetXLen(Y); X++){
519        TStr FldVal=DatSs->GetVal(X, Y);
520        FldValV.Add(FldVal);
521      }
522      RecFldValVV.Add(FldValV);
523    }}
524    TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
525    if ((DefFNm=="URNIKXXG.TXT")&&(DatFNm=="URNIKXX0.TXT")){
526      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
527      fprintf(XmlFId, "<!-- edited with DarMar XML v3.14 by Darko Zupanic & Marko Grobelnik -->\n");
528      fprintf(XmlFId, "<Operation xmlns:xsi=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"D:\\App\\zdr\\te\\ParamIN.xsd\">\n");
529      fprintf(XmlFId, "<OperationName>SetScheduledActivities</OperationName>\n");
530      fprintf(XmlFId, "<Parameter xsi:type=\"tParamInSetScheduledActivities\">\n");
531      fprintf(XmlFId, "<ScheduledActivities>\n");
532      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
533        TStrV& FldValV=RecFldValVV[RecN];
534        fprintf(XmlFId, "<ScheduledActivity>\n");
535        for (int FldN=0; FldN<FldValV.Len(); FldN++){
536          TStr FldNm=FldNmV[FldN];
537          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
538          else if (FldNm=="SIFRA060"){FldNm="ActivityCode";}
539          else if (FldNm=="SIFRA052"){FldNm="TherapyPlaceCode";}
540          else if (FldNm=="DATUM060"){FldNm="Date";}
541          else if (FldNm=="START060"){FldNm="StartTime";}
542          else if (FldNm=="NARP_060"){FldNm="PatientDuration";}
543          else if (FldNm=="NARA_060"){FldNm="TPDuration";}
544          else if (FldNm=="UJEMANJE"){FldNm="Accordance";}
545          fprintf(XmlFId, "<%s>%s</%s>\n",
546           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr(),
547           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr(),
548           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr());
549        }
550        fprintf(XmlFId, "</ScheduledActivity>\n");
551      }
552      fprintf(XmlFId, "</ScheduledActivities>\n");
553      fprintf(XmlFId, "</Parameter>\n");
554      fprintf(XmlFId, "</Operation>\n");
555    } else {
556      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
557      fprintf(XmlFId, "<Data>\n");
558      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
559        TStrV& FldValV=RecFldValVV[RecN];
560        fprintf(XmlFId, "<Record>\n");
561        for (int FldN=0; FldN<FldValV.Len(); FldN++){
562          fprintf(XmlFId, "<Field Name=\"%s\" Value=\"%s\"/>\n",
563           TXmlLx::GetXmlStrFromPlainStr(FldNmV[FldN]).CStr(),
564           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr());
565        }
566        fprintf(XmlFId, "</Record>\n");
567      }
568      fprintf(XmlFId, "</Data>\n");
569    }
570  }
571  void TThermalSch::SaveCsvToXmlParamOut(
572   const TStr& DefFNm, const TStr& DatFNm, const TStr& XmlFNm){
573    if (!TFile::Exists(DefFNm)){
574      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
575      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DefFNm+"'."));
576      return;
577    }
578    if (!TFile::Exists(DatFNm)){
579      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
580      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DatFNm+"'."));
581      return;
582    }
583    PSs DefSs=TSs::LoadTxt(ssfCommaSep, DefFNm);
584    TStrV FldNmV;
585    for (int Y=0; Y<DefSs->GetYLen(); Y++){
586      FldNmV.Add(DefSs->GetVal(0, Y));}
587    PSs DatSs=TSs::LoadTxt(ssfCommaSep, DatFNm);
588    TVec<TStrV> RecFldValVV;
<span onclick='openModal()' class='match'>589    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
590      TStrV FldValV;
591      for (int X=0; X<DatSs->GetXLen(Y); X++){
</span>592        TStr FldVal=DatSs->GetVal(X, Y);
593        FldValV.Add(FldVal);
594      }
595      RecFldValVV.Add(FldValV);
596    }}
597    TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
598    if ((DefFNm=="URNIKXXG.TXT")&&(DatFNm=="URNIKXX0.TXT")){
599      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
600      fprintf(XmlFId, "<ParamOut>\n");
601      fprintf(XmlFId, "<OperationName>");
602      fprintf(XmlFId, "MakeSchedule");
603      fprintf(XmlFId, "</OperationName>\n");
604      fprintf(XmlFId, "<Success>Ok</Success>\n");
605      fprintf(XmlFId, "<Data>\n");
606      fprintf(XmlFId, "<Operation xmlns:xsi=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"D:\\App\\zdr\\te\\ParamIN.xsd\">\n");
607      fprintf(XmlFId, "<OperationName>SetScheduledActivities</OperationName>\n");
608      fprintf(XmlFId, "<Parameter xsi:type=\"tParamInSetScheduledActivities\">\n");
609      fprintf(XmlFId, "<ScheduledActivities>\n");
610      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
611        TStrV& FldValV=RecFldValVV[RecN];
612        fprintf(XmlFId, "<ScheduledActivity>\n");
613        for (int FldN=0; FldN<FldValV.Len(); FldN++){
614          TStr FldNm=FldNmV[FldN];
615          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
616          else if (FldNm=="SIFRA060"){FldNm="ActivityCode";}
617          else if (FldNm=="SIFRA052"){FldNm="TherapyPlaceCode";}
618          else if (FldNm=="DATUM060"){FldNm="Date";}
619          else if (FldNm=="START060"){FldNm="StartTime";}
620          else if (FldNm=="NARP_060"){FldNm="PatientDuration";}
621          else if (FldNm=="NARA_060"){FldNm="TPDuration";}
622          else if (FldNm=="UJEMANJE"){FldNm="Accordance";}
623          fprintf(XmlFId, "<%s>%s</%s>\n",
624           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr(),
625           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr(),
626           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr());
627        }
628        fprintf(XmlFId, "</ScheduledActivity>\n");
629      }
630      fprintf(XmlFId, "</ScheduledActivities>\n");
631      fprintf(XmlFId, "</Parameter>\n");
632      fprintf(XmlFId, "</Operation>\n");
633      fprintf(XmlFId, "</Data>\n");
634      fprintf(XmlFId, "</ParamOut>\n");
635    } else {
636      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
637      fprintf(XmlFId, "<Data>\n");
638      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
639        TStrV& FldValV=RecFldValVV[RecN];
640        fprintf(XmlFId, "<Record>\n");
641        for (int FldN=0; FldN<FldValV.Len(); FldN++){
642          fprintf(XmlFId, "<Field Name=\"%s\" Value=\"%s\"/>\n",
643           TXmlLx::GetXmlStrFromPlainStr(FldNmV[FldN]).CStr(),
644           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr());
645        }
646        fprintf(XmlFId, "</Record>\n");
647      }
648      fprintf(XmlFId, "</Data>\n");
649    }
650  }
651  void TThermalSch::SaveOldCsv() const {
652    SaveOldCsv_KatalogZdrDelavcev();
653    SaveOldCsv_KatalogAparatov();
654    SaveOldCsv_KatalogAktivnosti();
655    SaveOldCsv_UrnikZaTerapevte();
656    SaveOldCsv_UrnikZaAparate();
657    SaveOldCsv_UrnikAktivnosti();
658    SaveOldCsv_MozniTerminiVDnevu();
659    SaveOldCsv_Prazniki();
660    SaveOldCsv_PredpisaneTerapije();
661    SaveOldCsv_PlaniraneAktivnosti();
662    SaveOldCsv_UrnikXX();
663  }
664  void TThermalSch::SaveOldCsv_KatalogZdrDelavcev() const {
665    TFOut DefSOut("KA051ZDG.TXT"); FILE* fDef=DefSOut.GetFileId();
666    SaveFldDef(fDef, "PRIM_051");
667    SaveFldDef(fDef, "SSIF_S23");
668    SaveFldDef(fDef, "SIFRA039");
669    SaveFldDef(fDef, "STAT_051");
670    SaveFldDef(fDef, "SIFRA051");
671    SaveFldDef(fDef, "POZ__051");
672    SaveFldDef(fDef, "EMSO_051");
673    SaveFldDef(fDef, "DATUMIPL");
674    SaveFldDef(fDef, "TIP__051");
675    TFOut DatSOut("KA051ZD0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
676  }
677  void TThermalSch::SaveOldCsv_KatalogAparatov() const {
678    TFOut DefSOut("KA052APG.TXT"); FILE* fDef=DefSOut.GetFileId();
679    SaveFldDef(fDef, "SIFRA052"); 
680    SaveFldDef(fDef, "SSIF_T05"); 
681    SaveFldDef(fDef, "OPIS_052"); 
682    SaveFldDef(fDef, "SSIF_NE4"); 
683    SaveFldDef(fDef, "ST_P_052"); 
684    SaveFldDef(fDef, "SIFR1052"); 
685    SaveFldDef(fDef, "PODAL052"); 
686    SaveFldDef(fDef, "TR_DO052"); 
687    SaveFldDef(fDef, "RAZD_052"); 
688    SaveFldDef(fDef, "SPOL_052"); 
689    SaveFldDef(fDef, "ALTERSCH"); 
690    SaveFldDef(fDef, "FAMILSCH"); 
691    TFOut DatSOut("KA052AP0.TXT"); FILE* fDat=DatSOut.GetFileId();
692    int TherapyPlaces=TThermalSch::GetTherapyPlaces();
693    for (int TherapyPlaceN=0; TherapyPlaceN<TherapyPlaces; TherapyPlaceN++){
694      PXmlTok TherapyPlace=TThermalSch::GetTherapyPlace(TherapyPlaceN);
695      SaveFldVal(fDat, GetTherapyPlace_Code(TherapyPlace)); 
696      SaveFldVal(fDat, GetTherapyPlace_Type(TherapyPlace)); 
697      SaveFldVal(fDat, GetTherapyPlace_Location(TherapyPlace)); 
698      SaveFldVal(fDat, GetTherapyPlace_TherapistType(TherapyPlace)); 
699      SaveFldVal(fDat, GetTherapyPlace_Capacity(TherapyPlace)); 
700      SaveFldVal(fDat, ""); 
701      SaveFldVal(fDat, ""); 
702      SaveFldVal(fDat, ""); 
703      SaveFldVal(fDat, GetTherapyPlace_Distance(TherapyPlace)); 
704      SaveFldVal(fDat, GetTherapyPlace_Gender(TherapyPlace)); 
705      SaveFldVal(fDat, GetTherapyPlace_AlternateScheduling(TherapyPlace));
706      SaveFldVal(fDat, GetTherapyPlace_FamilyScheduling(TherapyPlace), true);
707    }
708  }
709  void TThermalSch::SaveOldCsv_KatalogAktivnosti() const {
710    TFOut DefSOut("KA060AOG.TXT"); FILE* fDef=DefSOut.GetFileId();
711    SaveFldDef(fDef, "SIFRA060"); 
712    SaveFldDef(fDef, "SSIF_T05"); 
713    SaveFldDef(fDef, "TRAJ_060"); 
714    SaveFldDef(fDef, "STMAX060"); 
715    SaveFldDef(fDef, "STOPT060"); 
716    SaveFldDef(fDef, "RAZ1_060"); 
717    SaveFldDef(fDef, "RAZ2_060"); 
718    SaveFldDef(fDef, "RAZ3_060"); 
719    SaveFldDef(fDef, "NARP_060"); 
720    SaveFldDef(fDef, "NARA_060"); 
721    SaveFldDef(fDef, "SSIF_T01"); 
722    SaveFldDef(fDef, "SS_T2_T3"); 
723    SaveFldDef(fDef, "TEZA_060"); 
724    SaveFldDef(fDef, "SUHA_060"); 
725    SaveFldDef(fDef, "PRIORITY"); 
726    TFOut DatSOut("KA060AO0.TXT"); FILE* fDat=DatSOut.GetFileId();
727    int Activities=TThermalSch::GetActivities();
728    for (int ActivityN=0; ActivityN<Activities; ActivityN++){
729      PXmlTok Activity=TThermalSch::GetActivity(ActivityN);
730      SaveFldVal(fDat, GetActivity_Code(Activity)); 
731      SaveFldVal(fDat, GetActivity_Type(Activity)); 
732      SaveFldVal(fDat, GetActivity_Duration(Activity)); 
733      SaveFldVal(fDat, ""); 
734      SaveFldVal(fDat, ""); 
735      SaveFldVal(fDat, GetActivity_TherapistDurationPreparation(Activity)); 
736      SaveFldVal(fDat, GetActivity_TherapistDurationExecution(Activity)); 
737      SaveFldVal(fDat, GetActivity_TherapistDurationAdditionalTime(Activity)); 
738      SaveFldVal(fDat, GetActivity_PatientDuration(Activity)); 
739      SaveFldVal(fDat, GetActivity_TPDuration(Activity)); 
740      SaveFldVal(fDat, ""); 
741      SaveFldVal(fDat, ""); 
742      SaveFldVal(fDat, GetActivity_Weariness(Activity)); 
743      SaveFldVal(fDat, GetActivity_Dry(Activity)); 
744      SaveFldVal(fDat, GetActivity_Priority(Activity), true); 
745    }
746  }
747  void TThermalSch::SaveOldCsv_UrnikZaTerapevte() const {
748    TFOut DefSOut("PR350UIG.TXT"); FILE* fDef=DefSOut.GetFileId();
749    SaveFldDef(fDef, "TIP__051");
750    SaveFldDef(fDef, "DAN__350");
751    SaveFldDef(fDef, "STEV_350");
752    SaveFldDef(fDef, "DATOD350");
753    SaveFldDef(fDef, "DATDO350");
754    TFOut DatSOut("PR350UI0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
755  }
756  void TThermalSch::SaveOldCsv_UrnikZaAparate() const {
757    TFOut DefSOut("PR351UPG.TXT"); FILE* fDef=DefSOut.GetFileId();
758    SaveFldDef(fDef, "SIFRA052"); 
759    SaveFldDef(fDef, "AKTIV351"); 
760    SaveFldDef(fDef, "DATOD351"); 
761    SaveFldDef(fDef, "DATDO351"); 
762    SaveFldDef(fDef, "CASOD351"); 
763    SaveFldDef(fDef, "CASDO351"); 
764    SaveFldDef(fDef, "DAN"); 
765    TFOut DatSOut("PR351UP0.TXT"); FILE* fDat=DatSOut.GetFileId();
766    int AvailableTherapyPlaces=TThermalSch::GetAvailableTherapyPlaces();
767    for (int AvailableTherapyPlaceN=0; AvailableTherapyPlaceN<AvailableTherapyPlaces; AvailableTherapyPlaceN++){
768      PXmlTok AvailableTherapyPlace=TThermalSch::GetAvailableTherapyPlace(AvailableTherapyPlaceN);
769      int TherapyPlaceSchedules=GetTherapyPlaceSchedules(AvailableTherapyPlace);
770      for (int TherapyPlaceScheduleN=0; TherapyPlaceScheduleN<TherapyPlaceSchedules; TherapyPlaceScheduleN++){
771        PXmlTok TherapyPlaceSchedule=GetTherapyPlaceSchedule(AvailableTherapyPlace, TherapyPlaceScheduleN);
772        TStrV DayV=GetTherapyPlaceSchedule_WeekDays(TherapyPlaceSchedule);
773        for (int DayN=0; DayN<DayV.Len(); DayN++){
774          SaveFldVal(fDat, GetAvailableTherapyPlace_Code(AvailableTherapyPlace)); 
775          SaveFldVal(fDat, "D"); 
776          SaveFldVal(fDat, GetTherapyPlaceSchedule_ValidFrom(TherapyPlaceSchedule)); 
777          SaveFldVal(fDat, GetTherapyPlaceSchedule_ValidTo(TherapyPlaceSchedule)); 
778          SaveFldVal(fDat, GetTherapyPlaceSchedule_OpenFrom(TherapyPlaceSchedule)); 
779          SaveFldVal(fDat, GetTherapyPlaceSchedule_OpenTill(TherapyPlaceSchedule)); 
780          SaveFldVal(fDat, DayV[DayN], true); 
781        }
782      }
783    }
784  }
785  void TThermalSch::SaveOldCsv_UrnikAktivnosti() const {
786    TFOut DefSOut("PR352UAG.TXT"); FILE* fDef=DefSOut.GetFileId();
787    SaveFldDef(fDef, "SIFRA060"); 
788    SaveFldDef(fDef, "DAN__352"); 
789    SaveFldDef(fDef, "SIFRA352"); 
790    SaveFldDef(fDef, "DATOD352"); 
791    SaveFldDef(fDef, "DATDO352"); 
792    SaveFldDef(fDef, "CASOD352"); 
793    SaveFldDef(fDef, "CASDO352"); 
794    SaveFldDef(fDef, "SIFRA052"); 
795    SaveFldDef(fDef, "SPOL052"); 
796    TFOut DatSOut("PR352UA0.TXT"); FILE* fDat=DatSOut.GetFileId();
797    int AvailableActivities=TThermalSch::GetAvailableActivities();
798    for (int AvailableActivityN=0; AvailableActivityN<AvailableActivities; AvailableActivityN++){
799      PXmlTok AvailableActivity=TThermalSch::GetAvailableActivity(AvailableActivityN);
800      int ActivitySchedules=GetActivitySchedules(AvailableActivity);
801      for (int ActivityScheduleN=0; ActivityScheduleN<ActivitySchedules; ActivityScheduleN++){
802        PXmlTok ActivitySchedule=GetActivitySchedule(AvailableActivity, ActivityScheduleN);
803        TStrV DayV=GetActivitySchedule_WeekDays(ActivitySchedule);
804        for (int DayN=0; DayN<DayV.Len(); DayN++){
805          SaveFldVal(fDat, GetAvailableActivity_Code(AvailableActivity)); 
806          SaveFldVal(fDat, DayV[DayN]); 
807          SaveFldVal(fDat, ""); 
808          SaveFldVal(fDat, GetActivitySchedule_ValidFrom(ActivitySchedule)); 
809          SaveFldVal(fDat, GetActivitySchedule_ValidTo(ActivitySchedule)); 
810          SaveFldVal(fDat, GetActivitySchedule_StartTime(ActivitySchedule)); 
811          SaveFldVal(fDat, GetActivitySchedule_EndTime(ActivitySchedule)); 
812          SaveFldVal(fDat, GetActivitySchedule_TherapyPlaceType(ActivitySchedule)); 
813          SaveFldVal(fDat, GetActivitySchedule_Gender(ActivitySchedule), true);  
814        }
815      }
816    }
817  }
818  void TThermalSch::SaveOldCsv_MozniTerminiVDnevu() const {
819    TFOut DefSOut("PR352URG.TXT"); FILE* fDef=DefSOut.GetFileId();
820    SaveFldDef(fDef, "SIFRA352");
821    SaveFldDef(fDef, "ZAPST352");
822    SaveFldDef(fDef, "URAOD352");
823    SaveFldDef(fDef, "URADO352");
824    TFOut DatSOut("PR352UR0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
825  }
826  void TThermalSch::SaveOldCsv_Prazniki() const {
827    TFOut DefSOut("PRAZNIKG.TXT"); FILE* fDef=DefSOut.GetFileId();
828    SaveFldDef(fDef, "DATUM000");
829    TFOut DatSOut("PRAZNIK0.TXT"); FILE* fDat=DatSOut.GetFileId();
830    int Holidays=TThermalSch::GetHolidays();
831    for (int HolidayN=0; HolidayN<Holidays; HolidayN++){
832      PXmlTok Holiday=TThermalSch::GetHoliday(HolidayN);
833      SaveFldVal(fDat, GetHoliday_Date(Holiday), true); 
834    }
835  }
836  void TThermalSch::SaveOldCsv_PredpisaneTerapije() const {
837    TFOut DefSOut("PR300NSG.TXT"); FILE* fDef=DefSOut.GetFileId();
838    SaveFldDef(fDef, "SIFRA210"); 
839    SaveFldDef(fDef, "SIFRA101"); 
840    SaveFldDef(fDef, "SIFRA060"); 
841    SaveFldDef(fDef, "ZAPST300"); 
842    SaveFldDef(fDef, "STPON300"); 
843    SaveFldDef(fDef, "S_P_D300"); 
844    SaveFldDef(fDef, "SSIF_T11"); 
845    SaveFldDef(fDef, "SIFR1060"); 
846    SaveFldDef(fDef, "SIFR2060"); 
847    SaveFldDef(fDef, "URAOD300"); 
848    SaveFldDef(fDef, "URADO300"); 
849    SaveFldDef(fDef, "DATOD300"); 
850    SaveFldDef(fDef, "STAT_300"); 
851    SaveFldDef(fDef, "PLAN_300"); 
852    SaveFldDef(fDef, "DATUMIPL"); 
853    SaveFldDef(fDef, "OPER_300"); 
854    SaveFldDef(fDef, "SIFRA051"); 
855    SaveFldDef(fDef, "SPOL_300"); 
856    SaveFldDef(fDef, "DRUZINA"); 
857    SaveFldDef(fDef, "ATTRNAME"); 
858    SaveFldDef(fDef, "EXCLACT"); 
859    SaveFldDef(fDef, "EXCLTIME"); 
860    TFOut DatSOut("PR300NS0.TXT"); FILE* fDat=DatSOut.GetFileId();
861    int PlanRequests=TThermalSch::GetMakeSchedule_PlanRequests();
862    for (int PlanRequestN=0; PlanRequestN<PlanRequests; PlanRequestN++){
863      PXmlTok PlanRequest=TThermalSch::GetMakeSchedule_PlanRequest(PlanRequestN);
864      SaveFldVal(fDat, GetMakeSchedule_PatientATPCode()); 
865      SaveFldVal(fDat, GetMakeSchedule_PatientCode()); 
866      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_ActivityCode(PlanRequest)); 
867      SaveFldVal(fDat, ""); 
868      TStr AlternatingActivityCode=GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest);
869      TStr QuantityStr=GetMakeSchedule_PlanRequest_Quantity(PlanRequest);
870      if (AlternatingActivityCode.Empty()){
871        SaveFldVal(fDat, GetMakeSchedule_PlanRequest_Quantity(PlanRequest)); 
872      } else {
873        int Quantity=2*QuantityStr.GetInt(0);
874        SaveFldVal(fDat, TInt::GetStr(Quantity)); 
875      }
876      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DayQuantity(PlanRequest)); 
877      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_Frequency(PlanRequest)); 
878      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest)); 
879      SaveFldVal(fDat, ""); 
880      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DesiredStartTime(PlanRequest)); 
881      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DesiredFinishTime(PlanRequest)); 
882      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_TreatmentDate(PlanRequest)); 
883      SaveFldVal(fDat, ""); 
884      SaveFldVal(fDat, ""); 
885      SaveFldVal(fDat, ""); 
886      SaveFldVal(fDat, ""); 
887      SaveFldVal(fDat, ""); 
888      SaveFldVal(fDat, GetMakeSchedule_PatientGender()); 
889      SaveFldVal(fDat, GetMakeSchedule_PatientFamily()); 
890      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_AttrNm(PlanRequest)); 
891      SaveFldValV(fDat, GetMakeSchedule_PlanRequest_ExcludedActivities_ActivityCode(PlanRequest)); 
892      SaveFldValV(fDat, GetMakeSchedule_PlanRequest_ExcludedActivities_Time(PlanRequest), true); 
893    }
894  }
895  void TThermalSch::SaveOldCsv_PlaniraneAktivnosti() const {
896    TFOut DefSOut("PR360AKG.TXT"); FILE* fDef=DefSOut.GetFileId();
897    SaveFldDef(fDef, "SIFRA360"); 
898    SaveFldDef(fDef, "SIFRA210"); 
899    SaveFldDef(fDef, "SIFRA101"); 
900    SaveFldDef(fDef, "SIFRA051"); 
901    SaveFldDef(fDef, "SIFRA052"); 
902    SaveFldDef(fDef, "SIFRA060"); 
903    SaveFldDef(fDef, "DATUM360"); 
904    SaveFldDef(fDef, "STAT_360"); 
905    SaveFldDef(fDef, "Z_ST_360"); 
906    SaveFldDef(fDef, "C_OD_360"); 
907    SaveFldDef(fDef, "TRAJ_060"); 
908    SaveFldDef(fDef, "URA__360"); 
909    SaveFldDef(fDef, "SSIF_T07"); 
910    TFOut DatSOut("PR360AK0.TXT"); FILE* fDat=DatSOut.GetFileId();
911    int ScheduledActivities=TThermalSch::GetScheduledActivities();
912    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
913      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
914      SaveFldVal(fDat, GetScheduledActivity_Code(ScheduledActivity)); 
915      SaveFldVal(fDat, GetScheduledActivity_PatientATPCode(ScheduledActivity)); 
916      SaveFldVal(fDat, GetScheduledActivity_Patient(ScheduledActivity)); 
917      SaveFldVal(fDat, GetScheduledActivity_TherapistCode(ScheduledActivity)); 
918      SaveFldVal(fDat, GetScheduledActivity_TherapyPlaceCode(ScheduledActivity)); 
919      SaveFldVal(fDat, GetScheduledActivity_ActivityCode(ScheduledActivity)); 
920      SaveFldVal(fDat, GetScheduledActivity_StartDateTime(ScheduledActivity)); 
921      SaveFldVal(fDat, ""); 
922      SaveFldVal(fDat, GetScheduledActivity_RepetitionNumber(ScheduledActivity)); 
923      SaveFldVal(fDat, GetScheduledActivity_StartingPoint(ScheduledActivity)); 
924      SaveFldVal(fDat, GetScheduledActivity_PatientDuration(ScheduledActivity)); 
925      SaveFldVal(fDat, GetScheduledActivity_StartDateTime(ScheduledActivity)); 
926      SaveFldVal(fDat, "", true); 
927    }
928  }
929  void TThermalSch::SaveOldCsv_UrnikXX() const {
930    TFOut DefSOut("URNIKXXG.TXT"); FILE* fDef=DefSOut.GetFileId();
931    SaveFldDef(fDef, "SIFRA101");
932    SaveFldDef(fDef, "SIFRA060");
933    SaveFldDef(fDef, "SIFRA052");
934    SaveFldDef(fDef, "DATUM060");
935    SaveFldDef(fDef, "START060");
936    SaveFldDef(fDef, "NARP_060");
937    SaveFldDef(fDef, "NARA_060");
938    SaveFldDef(fDef, "UJEMANJE");
939    TFOut DatSOut("URNIKXX0.TXT"); FILE* fDat=DatSOut.GetFileId();
940    int ScheduledActivities=TThermalSch::GetScheduledActivities();
941    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
942      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
943      SaveFldVal(fDat, GetScheduledActivity_PatientCode(ScheduledActivity)); 
944      SaveFldVal(fDat, GetScheduledActivity_ActivityCode(ScheduledActivity)); 
945      SaveFldVal(fDat, GetScheduledActivity_TherapyPlaceCode(ScheduledActivity)); 
946      SaveFldVal(fDat, GetScheduledActivity_Date(ScheduledActivity)); 
947      SaveFldVal(fDat, GetScheduledActivity_StartTime(ScheduledActivity)); 
948      SaveFldVal(fDat, GetScheduledActivity_PatientDuration(ScheduledActivity)); 
949      SaveFldVal(fDat, GetScheduledActivity_TPDuration(ScheduledActivity)); 
950      SaveFldVal(fDat, GetScheduledActivity_Accordance(ScheduledActivity), true); 
951    }
952  }
953  PThermalSch TThermalSch::DllThermalSch=TThermalSch::New();
954  char* TThermalSch::DllExeCmFromXmlFile(char* FNm, char* FPath){
955    TStr MsgXmlStr=DllThermalSch->ExeCmFromXmlFile(FNm, FPath);
956    return MsgXmlStr.GetCStr();
957  }
958  char* TThermalSch::DllExeCmFromXmlStr(char* XmlStr){
959    TStr MsgXmlStr=DllThermalSch->ExeCmFromXmlStr(XmlStr);
960    return MsgXmlStr.GetCStr();
961  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam.cpp</h3>
            <pre><code>1  #include "recodebeam.h"
2  #include "networkio.h"
3  #include "pageres.h"
4  #include "unicharcompress.h"
5  #include <algorithm> 
6  namespace tesseract {
7  const int RecodeBeamSearch::kBeamWidths[RecodedCharID::kMaxCodeLen + 1] = {
8      5, 10, 16, 16, 16, 16, 16, 16, 16, 16,
9  };
10  static const char *kNodeContNames[] = {"Anything", "OnlyDup", "NoDup"};
11  void RecodeNode::Print(int null_char, const UNICHARSET &unicharset,
12                         int depth) const {
13    if (code == null_char) {
14      tprintf("null_char");
15    } else {
16      tprintf("label=%d, uid=%d=%s", code, unichar_id,
17              unicharset.debug_str(unichar_id).c_str());
18    }
19    tprintf(" score=%g, c=%g,%s%s%s perm=%d, hash=%" PRIx64, score, certainty,
20            start_of_dawg ? " DawgStart" : "", start_of_word ? " Start" : "",
21            end_of_word ? " End" : "", permuter, code_hash);
22    if (depth > 0 && prev != nullptr) {
23      tprintf(" prev:");
24      prev->Print(null_char, unicharset, depth - 1);
25    } else {
26      tprintf("\n");
27    }
28  }
29  RecodeBeamSearch::RecodeBeamSearch(const UnicharCompress &recoder,
30                                     int null_char, bool simple_text, Dict *dict)
31      : recoder_(recoder),
32        beam_size_(0),
33        top_code_(-1),
34        second_code_(-1),
35        dict_(dict),
36        space_delimited_(true),
37        is_simple_text_(simple_text),
38        null_char_(null_char) {
39    if (dict_ != nullptr && !dict_->IsSpaceDelimitedLang()) {
40      space_delimited_ = false;
41    }
42  }
43  RecodeBeamSearch::~RecodeBeamSearch() {
44    for (auto data : beam_) {
45      delete data;
46    }
47    for (auto data : secondary_beam_) {
48      delete data;
49    }
50  }
51  void RecodeBeamSearch::Decode(const NetworkIO &output, double dict_ratio,
52                                double cert_offset, double worst_dict_cert,
53                                const UNICHARSET *charset, int lstm_choice_mode) {
54    beam_size_ = 0;
55    int width = output.Width();
56    if (lstm_choice_mode) {
57      timesteps.clear();
58    }
59    for (int t = 0; t < width; ++t) {
60      ComputeTopN(output.f(t), output.NumFeatures(), kBeamWidths[0]);
61      DecodeStep(output.f(t), t, dict_ratio, cert_offset, worst_dict_cert,
62                 charset);
63      if (lstm_choice_mode) {
64        SaveMostCertainChoices(output.f(t), output.NumFeatures(), charset, t);
65      }
66    }
67  }
68  void RecodeBeamSearch::Decode(const GENERIC_2D_ARRAY<float> &output,
69                                double dict_ratio, double cert_offset,
70                                double worst_dict_cert,
71                                const UNICHARSET *charset) {
72    beam_size_ = 0;
73    int width = output.dim1();
74    for (int t = 0; t < width; ++t) {
75      ComputeTopN(output[t], output.dim2(), kBeamWidths[0]);
76      DecodeStep(output[t], t, dict_ratio, cert_offset, worst_dict_cert, charset);
77    }
78  }
79  void RecodeBeamSearch::DecodeSecondaryBeams(
80      const NetworkIO &output, double dict_ratio, double cert_offset,
81      double worst_dict_cert, const UNICHARSET *charset, int lstm_choice_mode) {
82    for (auto data : secondary_beam_) {
83      delete data;
84    }
85    secondary_beam_.clear();
86    if (character_boundaries_.size() < 2) {
87      return;
88    }
89    int width = output.Width();
90    unsigned bucketNumber = 0;
91    for (int t = 0; t < width; ++t) {
92      while ((bucketNumber + 1) < character_boundaries_.size() &&
93             t >= character_boundaries_[bucketNumber + 1]) {
94        ++bucketNumber;
95      }
96      ComputeSecTopN(&(excludedUnichars)[bucketNumber], output.f(t),
97                     output.NumFeatures(), kBeamWidths[0]);
98      DecodeSecondaryStep(output.f(t), t, dict_ratio, cert_offset,
99                          worst_dict_cert, charset);
100    }
101  }
102  void RecodeBeamSearch::SaveMostCertainChoices(const float *outputs,
103                                                int num_outputs,
104                                                const UNICHARSET *charset,
105                                                int xCoord) {
106    std::vector<std::pair<const char *, float>> choices;
107    for (int i = 0; i < num_outputs; ++i) {
108      if (outputs[i] >= 0.01f) {
109        const char *character;
110        if (i + 2 >= num_outputs) {
111          character = "";
112        } else if (i > 0) {
113          character = charset->id_to_unichar_ext(i + 2);
114        } else {
115          character = charset->id_to_unichar_ext(i);
116        }
117        size_t pos = 0;
118        while (choices.size() > pos && choices[pos].second > outputs[i]) {
119          pos++;
120        }
121        choices.insert(choices.begin() + pos,
122                       std::pair<const char *, float>(character, outputs[i]));
123      }
124    }
125    timesteps.push_back(choices);
126  }
127  void RecodeBeamSearch::segmentTimestepsByCharacters() {
128    for (unsigned i = 1; i < character_boundaries_.size(); ++i) {
129      std::vector<std::vector<std::pair<const char *, float>>> segment;
130      for (int j = character_boundaries_[i - 1]; j < character_boundaries_[i];
131           ++j) {
132        segment.push_back(timesteps[j]);
133      }
134      segmentedTimesteps.push_back(segment);
135    }
136  }
137  std::vector<std::vector<std::pair<const char *, float>>>
138  RecodeBeamSearch::combineSegmentedTimesteps(
139      std::vector<std::vector<std::vector<std::pair<const char *, float>>>>
140          *segmentedTimesteps) {
141    std::vector<std::vector<std::pair<const char *, float>>> combined_timesteps;
142    for (auto &segmentedTimestep : *segmentedTimesteps) {
143      for (auto &j : segmentedTimestep) {
144        combined_timesteps.push_back(j);
145      }
146    }
147    return combined_timesteps;
148  }
149  void RecodeBeamSearch::calculateCharBoundaries(std::vector<int> *starts,
150                                                 std::vector<int> *ends,
151                                                 std::vector<int> *char_bounds_,
152                                                 int maxWidth) {
153    char_bounds_->push_back(0);
154    for (unsigned i = 0; i < ends->size(); ++i) {
155      int middle = ((*starts)[i + 1] - (*ends)[i]) / 2;
156      char_bounds_->push_back((*ends)[i] + middle);
157    }
158    char_bounds_->pop_back();
159    char_bounds_->push_back(maxWidth);
160  }
161  void RecodeBeamSearch::ExtractBestPathAsLabels(
162      std::vector<int> *labels, std::vector<int> *xcoords) const {
163    labels->clear();
164    xcoords->clear();
165    std::vector<const RecodeNode *> best_nodes;
166    ExtractBestPaths(&best_nodes, nullptr);
167    int t = 0;
168    int width = best_nodes.size();
169    while (t < width) {
170      int label = best_nodes[t]->code;
171      if (label != null_char_) {
172        labels->push_back(label);
173        xcoords->push_back(t);
174      }
175      while (++t < width && !is_simple_text_ && best_nodes[t]->code == label) {
176      }
177    }
178    xcoords->push_back(width);
179  }
180  void RecodeBeamSearch::ExtractBestPathAsUnicharIds(
181      bool debug, const UNICHARSET *unicharset, std::vector<int> *unichar_ids,
182      std::vector<float> *certs, std::vector<float> *ratings,
183      std::vector<int> *xcoords) const {
184    std::vector<const RecodeNode *> best_nodes;
185    ExtractBestPaths(&best_nodes, nullptr);
186    ExtractPathAsUnicharIds(best_nodes, unichar_ids, certs, ratings, xcoords);
187    if (debug) {
188      DebugPath(unicharset, best_nodes);
189      DebugUnicharPath(unicharset, best_nodes, *unichar_ids, *certs, *ratings,
190                       *xcoords);
191    }
192  }
193  void RecodeBeamSearch::ExtractBestPathAsWords(const TBOX &line_box,
194                                                float scale_factor, bool debug,
195                                                const UNICHARSET *unicharset,
196                                                PointerVector<WERD_RES> *words,
197                                                int lstm_choice_mode) {
198    words->truncate(0);
199    std::vector<int> unichar_ids;
200    std::vector<float> certs;
201    std::vector<float> ratings;
202    std::vector<int> xcoords;
203    std::vector<const RecodeNode *> best_nodes;
204    std::vector<const RecodeNode *> second_nodes;
205    character_boundaries_.clear();
206    ExtractBestPaths(&best_nodes, &second_nodes);
207    if (debug) {
208      DebugPath(unicharset, best_nodes);
209      ExtractPathAsUnicharIds(second_nodes, &unichar_ids, &certs, &ratings,
210                              &xcoords);
211      tprintf("\nSecond choice path:\n");
212      DebugUnicharPath(unicharset, second_nodes, unichar_ids, certs, ratings,
213                       xcoords);
214    }
215    ExtractPathAsUnicharIds(best_nodes, &unichar_ids, &certs, &ratings, &xcoords,
216                            &character_boundaries_);
217    int num_ids = unichar_ids.size();
218    if (debug) {
219      DebugUnicharPath(unicharset, best_nodes, unichar_ids, certs, ratings,
220                       xcoords);
221    }
222    int word_end = 0;
223    float prev_space_cert = 0.0f;
224    for (int word_start = 0; word_start < num_ids; word_start = word_end) {
225      for (word_end = word_start + 1; word_end < num_ids; ++word_end) {
226        if (unichar_ids[word_end] == UNICHAR_SPACE) {
227          break;
228        }
229        int index = xcoords[word_end];
230        if (best_nodes[index]->start_of_word) {
231          break;
232        }
233        if (best_nodes[index]->permuter == TOP_CHOICE_PERM &&
234            (!unicharset->IsSpaceDelimited(unichar_ids[word_end]) ||
235             !unicharset->IsSpaceDelimited(unichar_ids[word_end - 1]))) {
236          break;
237        }
238      }
239      float space_cert = 0.0f;
240      if (word_end < num_ids && unichar_ids[word_end] == UNICHAR_SPACE) {
241        space_cert = certs[word_end];
242      }
243      bool leading_space =
244          word_start > 0 && unichar_ids[word_start - 1] == UNICHAR_SPACE;
245      WERD_RES *word_res =
246          InitializeWord(leading_space, line_box, word_start, word_end,
247                         std::min(space_cert, prev_space_cert), unicharset,
248                         xcoords, scale_factor);
249      for (int i = word_start; i < word_end; ++i) {
250        auto *choices = new BLOB_CHOICE_LIST;
251        BLOB_CHOICE_IT bc_it(choices);
252        auto *choice = new BLOB_CHOICE(unichar_ids[i], ratings[i], certs[i], -1,
253                                       1.0f, static_cast<float>(INT16_MAX), 0.0f,
254                                       BCC_STATIC_CLASSIFIER);
255        int col = i - word_start;
256        choice->set_matrix_cell(col, col);
257        bc_it.add_after_then_move(choice);
258        word_res->ratings->put(col, col, choices);
259      }
260      int index = xcoords[word_end - 1];
261      word_res->FakeWordFromRatings(best_nodes[index]->permuter);
262      words->push_back(word_res);
263      prev_space_cert = space_cert;
264      if (word_end < num_ids && unichar_ids[word_end] == UNICHAR_SPACE) {
265        ++word_end;
266      }
267    }
268  }
269  struct greater_than {
270    inline bool operator()(const RecodeNode *&node1, const RecodeNode *&node2) const {
271      return (node1->score > node2->score);
272    }
273  };
274  void RecodeBeamSearch::PrintBeam2(bool uids, int num_outputs,
275                                    const UNICHARSET *charset,
276                                    bool secondary) const {
277    std::vector<std::vector<const RecodeNode *>> topology;
278    std::unordered_set<const RecodeNode *> visited;
279    const std::vector<RecodeBeam *> &beam = !secondary ? beam_ : secondary_beam_;
280    for (int step = beam.size() - 1; step >= 0; --step) {
281      std::vector<const RecodeNode *> layer;
282      topology.push_back(layer);
283    }
284    for (int step = beam.size() - 1; step >= 0; --step) {
285      std::vector<tesseract::RecodePair> &heaps = beam.at(step)->beams_->heap();
286      for (auto &&node : heaps) {
287        int backtracker = 0;
288        const RecodeNode *curr = &node.data();
289        while (curr != nullptr && !visited.count(curr)) {
290          visited.insert(curr);
291          topology[step - backtracker].push_back(curr);
292          curr = curr->prev;
293          ++backtracker;
294        }
295      }
296    }
297    int ct = 0;
298    unsigned cb = 1;
299    for (const std::vector<const RecodeNode *> &layer : topology) {
300      if (cb >= character_boundaries_.size()) {
301        break;
302      }
303      if (ct == character_boundaries_[cb]) {
304        tprintf("***\n");
305        ++cb;
306      }
307      for (const RecodeNode *node : layer) {
308        const char *code;
309        int intCode;
310        if (node->unichar_id != INVALID_UNICHAR_ID) {
311          code = charset->id_to_unichar(node->unichar_id);
312          intCode = node->unichar_id;
313        } else if (node->code == null_char_) {
314          intCode = 0;
315          code = " ";
316        } else {
317          intCode = 666;
318          code = "*";
319        }
320        int intPrevCode = 0;
321        const char *prevCode;
322        float prevScore = 0;
323        if (node->prev != nullptr) {
324          prevScore = node->prev->score;
325          if (node->prev->unichar_id != INVALID_UNICHAR_ID) {
326            prevCode = charset->id_to_unichar(node->prev->unichar_id);
327            intPrevCode = node->prev->unichar_id;
328          } else if (node->code == null_char_) {
329            intPrevCode = 0;
330            prevCode = " ";
331          } else {
332            prevCode = "*";
333            intPrevCode = 666;
334          }
335        } else {
336          prevCode = " ";
337        }
338        if (uids) {
339          tprintf("%x(|)%f(>)%x(|)%f\n", intPrevCode, prevScore, intCode,
340                  node->score);
341        } else {
342          tprintf("%s(|)%f(>)%s(|)%f\n", prevCode, prevScore, code, node->score);
343        }
344      }
345      tprintf("-\n");
346      ++ct;
347    }
348    tprintf("***\n");
349  }
350  void RecodeBeamSearch::extractSymbolChoices(const UNICHARSET *unicharset) {
351    if (character_boundaries_.size() < 2) {
352      return;
353    }
354    std::vector<RecodeBeam *> &currentBeam =
355        secondary_beam_.empty() ? beam_ : secondary_beam_;
356    character_boundaries_[0] = 0;
357    for (unsigned j = 1; j < character_boundaries_.size(); ++j) {
358      std::vector<int> unichar_ids;
359      std::vector<float> certs;
360      std::vector<float> ratings;
361      std::vector<int> xcoords;
362      int backpath = character_boundaries_[j] - character_boundaries_[j - 1];
363      std::vector<tesseract::RecodePair> &heaps =
364          currentBeam.at(character_boundaries_[j] - 1)->beams_->heap();
365      std::vector<const RecodeNode *> best_nodes;
366      std::vector<const RecodeNode *> best;
367      for (auto &&entry : heaps) {
368        bool validChar = false;
369        int backcounter = 0;
370        const RecodeNode *node = &entry.data();
371        while (node != nullptr && backcounter < backpath) {
372          if (node->code != null_char_ &&
373              node->unichar_id != INVALID_UNICHAR_ID) {
374            validChar = true;
375            break;
376          }
377          node = node->prev;
378          ++backcounter;
379        }
380        if (validChar) {
381          best.push_back(&entry.data());
382        }
383      }
384      if (!best.empty()) {
385        std::sort(best.begin(), best.end(), greater_than());
386        ExtractPath(best[0], &best_nodes, backpath);
387        ExtractPathAsUnicharIds(best_nodes, &unichar_ids, &certs, &ratings,
388                                &xcoords);
389      }
390      if (!unichar_ids.empty()) {
391        int bestPos = 0;
392        for (unsigned i = 1; i < unichar_ids.size(); ++i) {
393          if (ratings[i] < ratings[bestPos]) {
394            bestPos = i;
395          }
396        }
397  #if 0 
398        int bestCode = -10;
399        for (auto &node : best_nodes) {
400          if (node->unichar_id == unichar_ids[bestPos]) {
401            bestCode = node->code;
402          }
403        }
404  #endif
405        std::unordered_set<int> excludeCodeList;
406        for (auto &best_node : best_nodes) {
407          if (best_node->code != null_char_) {
408            excludeCodeList.insert(best_node->code);
409          }
410        }
411        if (j - 1 < excludedUnichars.size()) {
412          for (auto elem : excludeCodeList) {
413            excludedUnichars[j - 1].insert(elem);
414          }
415        } else {
416          excludedUnichars.push_back(excludeCodeList);
417        }
418        if (j - 1 < ctc_choices.size()) {
419          int id = unichar_ids[bestPos];
420          const char *result = unicharset->id_to_unichar_ext(id);
421          float rating = ratings[bestPos];
422          ctc_choices[j - 1].push_back(
423              std::pair<const char *, float>(result, rating));
424        } else {
425          std::vector<std::pair<const char *, float>> choice;
426          int id = unichar_ids[bestPos];
427          const char *result = unicharset->id_to_unichar_ext(id);
428          float rating = ratings[bestPos];
429          choice.emplace_back(result, rating);
430          ctc_choices.push_back(choice);
431        }
432      } else {
433        if (j - 1 >= excludedUnichars.size()) {
434          std::unordered_set<int> excludeCodeList;
435          excludedUnichars.push_back(excludeCodeList);
436        }
437        if (j - 1 >= ctc_choices.size()) {
438          std::vector<std::pair<const char *, float>> choice;
439          ctc_choices.push_back(choice);
440        }
441      }
442    }
443    for (auto data : secondary_beam_) {
444      delete data;
445    }
446    secondary_beam_.clear();
447  }
448  void RecodeBeamSearch::DebugBeams(const UNICHARSET &unicharset) const {
449    for (int p = 0; p < beam_size_; ++p) {
450      for (int d = 0; d < 2; ++d) {
451        for (int c = 0; c < NC_COUNT; ++c) {
452          auto cont = static_cast<NodeContinuation>(c);
453          int index = BeamIndex(d, cont, 0);
454          if (beam_[p]->beams_[index].empty()) {
455            continue;
456          }
457          tprintf("Position %d: %s+%s beam\n", p, d ? "Dict" : "Non-Dict",
458                  kNodeContNames[c]);
459          DebugBeamPos(unicharset, beam_[p]->beams_[index]);
460        }
461      }
462    }
463  }
464  void RecodeBeamSearch::DebugBeamPos(const UNICHARSET &unicharset,
465                                      const RecodeHeap &heap) const {
466    std::vector<const RecodeNode *> unichar_bests(unicharset.size());
467    const RecodeNode *null_best = nullptr;
468    int heap_size = heap.size();
469    for (int i = 0; i < heap_size; ++i) {
470      const RecodeNode *node = &heap.get(i).data();
471      if (node->unichar_id == INVALID_UNICHAR_ID) {
472        if (null_best == nullptr || null_best->score < node->score) {
473          null_best = node;
474        }
475      } else {
476        if (unichar_bests[node->unichar_id] == nullptr ||
477            unichar_bests[node->unichar_id]->score < node->score) {
478          unichar_bests[node->unichar_id] = node;
479        }
480      }
481    }
482    for (auto &unichar_best : unichar_bests) {
483      if (unichar_best != nullptr) {
484        const RecodeNode &node = *unichar_best;
485        node.Print(null_char_, unicharset, 1);
486      }
487    }
488    if (null_best != nullptr) {
489      null_best->Print(null_char_, unicharset, 1);
490    }
491  }
492  void RecodeBeamSearch::ExtractPathAsUnicharIds(
493      const std::vector<const RecodeNode *> &best_nodes,
494      std::vector<int> *unichar_ids, std::vector<float> *certs,
495      std::vector<float> *ratings, std::vector<int> *xcoords,
496      std::vector<int> *character_boundaries) {
497    unichar_ids->clear();
498    certs->clear();
499    ratings->clear();
500    xcoords->clear();
501    std::vector<int> starts;
502    std::vector<int> ends;
503    int t = 0;
504    int width = best_nodes.size();
505    while (t < width) {
506      double certainty = 0.0;
507      double rating = 0.0;
508      while (t < width && best_nodes[t]->unichar_id == INVALID_UNICHAR_ID) {
509        double cert = best_nodes[t++]->certainty;
510        if (cert < certainty) {
511          certainty = cert;
512        }
513        rating -= cert;
514      }
515      starts.push_back(t);
516      if (t < width) {
517        int unichar_id = best_nodes[t]->unichar_id;
518        if (unichar_id == UNICHAR_SPACE && !certs->empty() &&
519            best_nodes[t]->permuter != NO_PERM) {
520          if (certainty < certs->back()) {
521            certs->back() = certainty;
522          }
523          ratings->back() += rating;
524          certainty = 0.0;
525          rating = 0.0;
526        }
527        unichar_ids->push_back(unichar_id);
528        xcoords->push_back(t);
529        do {
530          double cert = best_nodes[t++]->certainty;
531          if (cert < certainty || (unichar_id == UNICHAR_SPACE &&
532                                   best_nodes[t - 1]->permuter == NO_PERM)) {
533            certainty = cert;
534          }
535          rating -= cert;
536        } while (t < width && best_nodes[t]->duplicate);
537        ends.push_back(t);
538        certs->push_back(certainty);
539        ratings->push_back(rating);
540      } else if (!certs->empty()) {
541        if (certainty < certs->back()) {
542          certs->back() = certainty;
543        }
544        ratings->back() += rating;
545      }
546    }
547    starts.push_back(width);
548    if (character_boundaries != nullptr) {
549      calculateCharBoundaries(&starts, &ends, character_boundaries, width);
550    }
551    xcoords->push_back(width);
552  }
553  WERD_RES *RecodeBeamSearch::InitializeWord(bool leading_space,
554                                             const TBOX &line_box, int word_start,
555                                             int word_end, float space_certainty,
556                                             const UNICHARSET *unicharset,
557                                             const std::vector<int> &xcoords,
558                                             float scale_factor) {
559    C_BLOB_LIST blobs;
560    C_BLOB_IT b_it(&blobs);
561    for (int i = word_start; i < word_end; ++i) {
562      if (static_cast<unsigned>(i + 1) < character_boundaries_.size()) {
563        TBOX box(static_cast<int16_t>(
564                     std::floor(character_boundaries_[i] * scale_factor)) +
565                     line_box.left(),
566                 line_box.bottom(),
567                 static_cast<int16_t>(
568                     std::ceil(character_boundaries_[i + 1] * scale_factor)) +
569                     line_box.left(),
570                 line_box.top());
571        b_it.add_after_then_move(C_BLOB::FakeBlob(box));
572      }
573    }
574    WERD *word = new WERD(&blobs, leading_space, nullptr);
575    auto *word_res = new WERD_RES(word);
576    word_res->end = word_end - word_start + leading_space;
577    word_res->uch_set = unicharset;
578    word_res->combination = true; 
579    word_res->space_certainty = space_certainty;
580    word_res->ratings = new MATRIX(word_end - word_start, 1);
581    return word_res;
582  }
583  void RecodeBeamSearch::ComputeTopN(const float *outputs, int num_outputs,
584                                     int top_n) {
585    top_n_flags_.clear();
586    top_n_flags_.resize(num_outputs, TN_ALSO_RAN);
587    top_code_ = -1;
588    second_code_ = -1;
589    top_heap_.clear();
590    for (int i = 0; i < num_outputs; ++i) {
591      if (top_heap_.size() < top_n || outputs[i] > top_heap_.PeekTop().key()) {
592        TopPair entry(outputs[i], i);
593        top_heap_.Push(&entry);
594        if (top_heap_.size() > top_n) {
595          top_heap_.Pop(&entry);
596        }
597      }
598    }
599    while (!top_heap_.empty()) {
600      TopPair entry;
601      top_heap_.Pop(&entry);
602      if (top_heap_.size() > 1) {
603        top_n_flags_[entry.data()] = TN_TOPN;
604      } else {
605        top_n_flags_[entry.data()] = TN_TOP2;
606        if (top_heap_.empty()) {
607          top_code_ = entry.data();
608        } else {
609          second_code_ = entry.data();
610        }
611      }
612    }
613    top_n_flags_[null_char_] = TN_TOP2;
614  }
615  void RecodeBeamSearch::ComputeSecTopN(std::unordered_set<int> *exList,
616                                        const float *outputs, int num_outputs,
617                                        int top_n) {
618    top_n_flags_.clear();
619    top_n_flags_.resize(num_outputs, TN_ALSO_RAN);
620    top_code_ = -1;
621    second_code_ = -1;
622    top_heap_.clear();
623    for (int i = 0; i < num_outputs; ++i) {
624      if ((top_heap_.size() < top_n || outputs[i] > top_heap_.PeekTop().key()) &&
625          !exList->count(i)) {
626        TopPair entry(outputs[i], i);
627        top_heap_.Push(&entry);
628        if (top_heap_.size() > top_n) {
629          top_heap_.Pop(&entry);
630        }
631      }
632    }
633    while (!top_heap_.empty()) {
634      TopPair entry;
635      top_heap_.Pop(&entry);
636      if (top_heap_.size() > 1) {
637        top_n_flags_[entry.data()] = TN_TOPN;
638      } else {
639        top_n_flags_[entry.data()] = TN_TOP2;
640        if (top_heap_.empty()) {
641          top_code_ = entry.data();
642        } else {
643          second_code_ = entry.data();
644        }
645      }
646    }
647    top_n_flags_[null_char_] = TN_TOP2;
648  }
649  void RecodeBeamSearch::DecodeStep(const float *outputs, int t,
650                                    double dict_ratio, double cert_offset,
651                                    double worst_dict_cert,
652                                    const UNICHARSET *charset, bool debug) {
653    if (t == static_cast<int>(beam_.size())) {
654      beam_.push_back(new RecodeBeam);
655    }
656    RecodeBeam *step = beam_[t];
657    beam_size_ = t + 1;
658    step->Clear();
659    if (t == 0) {
660      ContinueContext(nullptr, BeamIndex(false, NC_ANYTHING, 0), outputs, TN_TOP2,
661                      charset, dict_ratio, cert_offset, worst_dict_cert, step);
662      if (dict_ != nullptr) {
663        ContinueContext(nullptr, BeamIndex(true, NC_ANYTHING, 0), outputs,
664                        TN_TOP2, charset, dict_ratio, cert_offset,
665                        worst_dict_cert, step);
666      }
667    } else {
668      RecodeBeam *prev = beam_[t - 1];
669      if (debug) {
670        int beam_index = BeamIndex(true, NC_ANYTHING, 0);
671        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
672          std::vector<const RecodeNode *> path;
673          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
674          tprintf("Step %d: Dawg beam %d:\n", t, i);
675          DebugPath(charset, path);
676        }
677        beam_index = BeamIndex(false, NC_ANYTHING, 0);
678        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
679          std::vector<const RecodeNode *> path;
680          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
681          tprintf("Step %d: Non-Dawg beam %d:\n", t, i);
682          DebugPath(charset, path);
683        }
684      }
685      int total_beam = 0;
686      for (int tn = 0; tn < TN_COUNT && total_beam == 0; ++tn) {
687        auto top_n = static_cast<TopNState>(tn);
<span onclick='openModal()' class='match'>688        for (int index = 0; index < kNumBeams; ++index) {
689          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
</span>690            ContinueContext(&prev->beams_[index].get(i).data(), index, outputs,
691                            top_n, charset, dict_ratio, cert_offset,
692                            worst_dict_cert, step);
693          }
694        }
695        for (int index = 0; index < kNumBeams; ++index) {
696          if (ContinuationFromBeamsIndex(index) == NC_ANYTHING) {
697            total_beam += step->beams_[index].size();
698          }
699        }
700      }
701      for (int c = 0; c < NC_COUNT; ++c) {
702        if (step->best_initial_dawgs_[c].code >= 0) {
703          int index = BeamIndex(true, static_cast<NodeContinuation>(c), 0);
704          RecodeHeap *dawg_heap = &step->beams_[index];
705          PushHeapIfBetter(kBeamWidths[0], &step->best_initial_dawgs_[c],
706                           dawg_heap);
707        }
708      }
709    }
710  }
711  void RecodeBeamSearch::DecodeSecondaryStep(
712      const float *outputs, int t, double dict_ratio, double cert_offset,
713      double worst_dict_cert, const UNICHARSET *charset, bool debug) {
714    if (t == static_cast<int>(secondary_beam_.size())) {
715      secondary_beam_.push_back(new RecodeBeam);
716    }
717    RecodeBeam *step = secondary_beam_[t];
718    step->Clear();
719    if (t == 0) {
720      ContinueContext(nullptr, BeamIndex(false, NC_ANYTHING, 0), outputs, TN_TOP2,
721                      charset, dict_ratio, cert_offset, worst_dict_cert, step);
722      if (dict_ != nullptr) {
723        ContinueContext(nullptr, BeamIndex(true, NC_ANYTHING, 0), outputs,
724                        TN_TOP2, charset, dict_ratio, cert_offset,
725                        worst_dict_cert, step);
726      }
727    } else {
728      RecodeBeam *prev = secondary_beam_[t - 1];
729      if (debug) {
730        int beam_index = BeamIndex(true, NC_ANYTHING, 0);
731        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
732          std::vector<const RecodeNode *> path;
733          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
734          tprintf("Step %d: Dawg beam %d:\n", t, i);
735          DebugPath(charset, path);
736        }
737        beam_index = BeamIndex(false, NC_ANYTHING, 0);
738        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
739          std::vector<const RecodeNode *> path;
740          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
741          tprintf("Step %d: Non-Dawg beam %d:\n", t, i);
742          DebugPath(charset, path);
743        }
744      }
745      int total_beam = 0;
746      for (int tn = 0; tn < TN_COUNT && total_beam == 0; ++tn) {
747        auto top_n = static_cast<TopNState>(tn);
748        for (int index = 0; index < kNumBeams; ++index) {
749          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
750            ContinueContext(&prev->beams_[index].get(i).data(), index, outputs,
751                            top_n, charset, dict_ratio, cert_offset,
752                            worst_dict_cert, step);
753          }
754        }
755        for (int index = 0; index < kNumBeams; ++index) {
756          if (ContinuationFromBeamsIndex(index) == NC_ANYTHING) {
757            total_beam += step->beams_[index].size();
758          }
759        }
760      }
761      for (int c = 0; c < NC_COUNT; ++c) {
762        if (step->best_initial_dawgs_[c].code >= 0) {
763          int index = BeamIndex(true, static_cast<NodeContinuation>(c), 0);
764          RecodeHeap *dawg_heap = &step->beams_[index];
765          PushHeapIfBetter(kBeamWidths[0], &step->best_initial_dawgs_[c],
766                           dawg_heap);
767        }
768      }
769    }
770  }
771  void RecodeBeamSearch::ContinueContext(
772      const RecodeNode *prev, int index, const float *outputs,
773      TopNState top_n_flag, const UNICHARSET *charset, double dict_ratio,
774      double cert_offset, double worst_dict_cert, RecodeBeam *step) {
775    RecodedCharID prefix;
776    RecodedCharID full_code;
777    const RecodeNode *previous = prev;
778    int length = LengthFromBeamsIndex(index);
779    bool use_dawgs = IsDawgFromBeamsIndex(index);
780    NodeContinuation prev_cont = ContinuationFromBeamsIndex(index);
781    for (int p = length - 1; p >= 0; --p, previous = previous->prev) {
782      while (previous != nullptr &&
783             (previous->duplicate || previous->code == null_char_)) {
784        previous = previous->prev;
785      }
786      if (previous != nullptr) {
787        prefix.Set(p, previous->code);
788        full_code.Set(p, previous->code);
789      }
790    }
791    if (prev != nullptr && !is_simple_text_) {
792      if (top_n_flags_[prev->code] == top_n_flag) {
793        if (prev_cont != NC_NO_DUP) {
794          float cert =
795              NetworkIO::ProbToCertainty(outputs[prev->code]) + cert_offset;
796          PushDupOrNoDawgIfBetter(length, true, prev->code, prev->unichar_id,
797                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
798                                  NC_ANYTHING, prev, step);
799        }
800        if (prev_cont == NC_ANYTHING && top_n_flag == TN_TOP2 &&
801            prev->code != null_char_) {
802          float cert = NetworkIO::ProbToCertainty(outputs[prev->code] +
803                                                  outputs[null_char_]) +
804                       cert_offset;
805          PushDupOrNoDawgIfBetter(length, true, prev->code, prev->unichar_id,
806                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
807                                  NC_NO_DUP, prev, step);
808        }
809      }
810      if (prev_cont == NC_ONLY_DUP) {
811        return;
812      }
813      if (prev->code != null_char_ && length > 0 &&
814          top_n_flags_[null_char_] == top_n_flag) {
815        float cert =
816            NetworkIO::ProbToCertainty(outputs[null_char_]) + cert_offset;
817        PushDupOrNoDawgIfBetter(length, false, null_char_, INVALID_UNICHAR_ID,
818                                cert, worst_dict_cert, dict_ratio, use_dawgs,
819                                NC_ANYTHING, prev, step);
820      }
821    }
822    const std::vector<int> *final_codes = recoder_.GetFinalCodes(prefix);
823    if (final_codes != nullptr) {
824      for (int code : *final_codes) {
825        if (top_n_flags_[code] != top_n_flag) {
826          continue;
827        }
828        if (prev != nullptr && prev->code == code && !is_simple_text_) {
829          continue;
830        }
831        float cert = NetworkIO::ProbToCertainty(outputs[code]) + cert_offset;
832        if (cert < kMinCertainty && code != null_char_) {
833          continue;
834        }
835        full_code.Set(length, code);
836        int unichar_id = recoder_.DecodeUnichar(full_code);
837        if (length == 0 && code == null_char_) {
838          unichar_id = INVALID_UNICHAR_ID;
839        }
840        if (unichar_id != INVALID_UNICHAR_ID && charset != nullptr &&
841            !charset->get_enabled(unichar_id)) {
842          continue; 
843        }
844        ContinueUnichar(code, unichar_id, cert, worst_dict_cert, dict_ratio,
845                        use_dawgs, NC_ANYTHING, prev, step);
846        if (top_n_flag == TN_TOP2 && code != null_char_) {
847          float prob = outputs[code] + outputs[null_char_];
848          if (prev != nullptr && prev_cont == NC_ANYTHING &&
849              prev->code != null_char_ &&
850              ((prev->code == top_code_ && code == second_code_) ||
851               (code == top_code_ && prev->code == second_code_))) {
852            prob += outputs[prev->code];
853          }
854          cert = NetworkIO::ProbToCertainty(prob) + cert_offset;
855          ContinueUnichar(code, unichar_id, cert, worst_dict_cert, dict_ratio,
856                          use_dawgs, NC_ONLY_DUP, prev, step);
857        }
858      }
859    }
860    const std::vector<int> *next_codes = recoder_.GetNextCodes(prefix);
861    if (next_codes != nullptr) {
862      for (int code : *next_codes) {
863        if (top_n_flags_[code] != top_n_flag) {
864          continue;
865        }
866        if (prev != nullptr && prev->code == code && !is_simple_text_) {
867          continue;
868        }
869        float cert = NetworkIO::ProbToCertainty(outputs[code]) + cert_offset;
870        PushDupOrNoDawgIfBetter(length + 1, false, code, INVALID_UNICHAR_ID, cert,
871                                worst_dict_cert, dict_ratio, use_dawgs,
872                                NC_ANYTHING, prev, step);
873        if (top_n_flag == TN_TOP2 && code != null_char_) {
874          float prob = outputs[code] + outputs[null_char_];
875          if (prev != nullptr && prev_cont == NC_ANYTHING &&
876              prev->code != null_char_ &&
877              ((prev->code == top_code_ && code == second_code_) ||
878               (code == top_code_ && prev->code == second_code_))) {
879            prob += outputs[prev->code];
880          }
881          cert = NetworkIO::ProbToCertainty(prob) + cert_offset;
882          PushDupOrNoDawgIfBetter(length + 1, false, code, INVALID_UNICHAR_ID,
883                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
884                                  NC_ONLY_DUP, prev, step);
885        }
886      }
887    }
888  }
889  void RecodeBeamSearch::ContinueUnichar(int code, int unichar_id, float cert,
890                                         float worst_dict_cert, float dict_ratio,
891                                         bool use_dawgs, NodeContinuation cont,
892                                         const RecodeNode *prev,
893                                         RecodeBeam *step) {
894    if (use_dawgs) {
895      if (cert > worst_dict_cert) {
896        ContinueDawg(code, unichar_id, cert, cont, prev, step);
897      }
898    } else {
899      RecodeHeap *nodawg_heap = &step->beams_[BeamIndex(false, cont, 0)];
900      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, TOP_CHOICE_PERM, false,
901                       false, false, false, cert * dict_ratio, prev, nullptr,
902                       nodawg_heap);
903      if (dict_ != nullptr &&
904          ((unichar_id == UNICHAR_SPACE && cert > worst_dict_cert) ||
905           !dict_->getUnicharset().IsSpaceDelimited(unichar_id))) {
906        float dawg_cert = cert;
907        PermuterType permuter = TOP_CHOICE_PERM;
908        if (unichar_id == UNICHAR_SPACE) {
909          permuter = NO_PERM;
910        } else {
911          dawg_cert *= dict_ratio;
912        }
913        PushInitialDawgIfBetter(code, unichar_id, permuter, false, false,
914                                dawg_cert, cont, prev, step);
915      }
916    }
917  }
918  void RecodeBeamSearch::ContinueDawg(int code, int unichar_id, float cert,
919                                      NodeContinuation cont,
920                                      const RecodeNode *prev, RecodeBeam *step) {
921    RecodeHeap *dawg_heap = &step->beams_[BeamIndex(true, cont, 0)];
922    RecodeHeap *nodawg_heap = &step->beams_[BeamIndex(false, cont, 0)];
923    if (unichar_id == INVALID_UNICHAR_ID) {
924      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, NO_PERM, false, false,
925                       false, false, cert, prev, nullptr, dawg_heap);
926      return;
927    }
928    float score = cert;
929    if (prev != nullptr) {
930      score += prev->score;
931    }
932    if (dawg_heap->size() >= kBeamWidths[0] &&
933        score <= dawg_heap->PeekTop().data().score &&
934        nodawg_heap->size() >= kBeamWidths[0] &&
935        score <= nodawg_heap->PeekTop().data().score) {
936      return;
937    }
938    const RecodeNode *uni_prev = prev;
939    while (uni_prev != nullptr &&
940           (uni_prev->unichar_id == INVALID_UNICHAR_ID || uni_prev->duplicate)) {
941      uni_prev = uni_prev->prev;
942    }
943    if (unichar_id == UNICHAR_SPACE) {
944      if (uni_prev != nullptr && uni_prev->end_of_word) {
945        PushInitialDawgIfBetter(code, unichar_id, uni_prev->permuter, false,
946                                false, cert, cont, prev, step);
947        PushHeapIfBetter(kBeamWidths[0], code, unichar_id, uni_prev->permuter,
948                         false, false, false, false, cert, prev, nullptr,
949                         nodawg_heap);
950      }
951      return;
952    } else if (uni_prev != nullptr && uni_prev->start_of_dawg &&
953               uni_prev->unichar_id != UNICHAR_SPACE &&
954               dict_->getUnicharset().IsSpaceDelimited(uni_prev->unichar_id) &&
955               dict_->getUnicharset().IsSpaceDelimited(unichar_id)) {
956      return; 
957    }
958    DawgPositionVector initial_dawgs;
959    auto *updated_dawgs = new DawgPositionVector;
960    DawgArgs dawg_args(&initial_dawgs, updated_dawgs, NO_PERM);
961    bool word_start = false;
962    if (uni_prev == nullptr) {
963      dict_->default_dawgs(&initial_dawgs, false);
964      word_start = true;
965    } else if (uni_prev->dawgs != nullptr) {
966      dawg_args.active_dawgs = uni_prev->dawgs;
967      word_start = uni_prev->start_of_dawg;
968    } else {
969      return; 
970    }
971    auto permuter = static_cast<PermuterType>(dict_->def_letter_is_okay(
972        &dawg_args, dict_->getUnicharset(), unichar_id, false));
973    if (permuter != NO_PERM) {
974      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, permuter, false,
975                       word_start, dawg_args.valid_end, false, cert, prev,
976                       dawg_args.updated_dawgs, dawg_heap);
977      if (dawg_args.valid_end && !space_delimited_) {
978        PushInitialDawgIfBetter(code, unichar_id, permuter, word_start, true,
979                                cert, cont, prev, step);
980        PushHeapIfBetter(kBeamWidths[0], code, unichar_id, permuter, false,
981                         word_start, true, false, cert, prev, nullptr,
982                         nodawg_heap);
983      }
984    } else {
985      delete updated_dawgs;
986    }
987  }
988  void RecodeBeamSearch::PushInitialDawgIfBetter(int code, int unichar_id,
989                                                 PermuterType permuter,
990                                                 bool start, bool end, float cert,
991                                                 NodeContinuation cont,
992                                                 const RecodeNode *prev,
993                                                 RecodeBeam *step) {
994    RecodeNode *best_initial_dawg = &step->best_initial_dawgs_[cont];
995    float score = cert;
996    if (prev != nullptr) {
997      score += prev->score;
998    }
999    if (best_initial_dawg->code < 0 || score > best_initial_dawg->score) {
1000      auto *initial_dawgs = new DawgPositionVector;
1001      dict_->default_dawgs(initial_dawgs, false);
1002      RecodeNode node(code, unichar_id, permuter, true, start, end, false, cert,
1003                      score, prev, initial_dawgs,
1004                      ComputeCodeHash(code, false, prev));
1005      *best_initial_dawg = node;
1006    }
1007  }
1008  void RecodeBeamSearch::PushDupOrNoDawgIfBetter(
1009      int length, bool dup, int code, int unichar_id, float cert,
1010      float worst_dict_cert, float dict_ratio, bool use_dawgs,
1011      NodeContinuation cont, const RecodeNode *prev, RecodeBeam *step) {
1012    int index = BeamIndex(use_dawgs, cont, length);
1013    if (use_dawgs) {
1014      if (cert > worst_dict_cert) {
1015        PushHeapIfBetter(kBeamWidths[length], code, unichar_id,
1016                         prev ? prev->permuter : NO_PERM, false, false, false,
1017                         dup, cert, prev, nullptr, &step->beams_[index]);
1018      }
1019    } else {
1020      cert *= dict_ratio;
1021      if (cert >= kMinCertainty || code == null_char_) {
1022        PushHeapIfBetter(kBeamWidths[length], code, unichar_id,
1023                         prev ? prev->permuter : TOP_CHOICE_PERM, false, false,
1024                         false, dup, cert, prev, nullptr, &step->beams_[index]);
1025      }
1026    }
1027  }
1028  void RecodeBeamSearch::PushHeapIfBetter(int max_size, int code, int unichar_id,
1029                                          PermuterType permuter, bool dawg_start,
1030                                          bool word_start, bool end, bool dup,
1031                                          float cert, const RecodeNode *prev,
1032                                          DawgPositionVector *d,
1033                                          RecodeHeap *heap) {
1034    float score = cert;
1035    if (prev != nullptr) {
1036      score += prev->score;
1037    }
1038    if (heap->size() < max_size || score > heap->PeekTop().data().score) {
1039      uint64_t hash = ComputeCodeHash(code, dup, prev);
1040      RecodeNode node(code, unichar_id, permuter, dawg_start, word_start, end,
1041                      dup, cert, score, prev, d, hash);
1042      if (UpdateHeapIfMatched(&node, heap)) {
1043        return;
1044      }
1045      RecodePair entry(score, node);
1046      heap->Push(&entry);
1047      ASSERT_HOST(entry.data().dawgs == nullptr);
1048      if (heap->size() > max_size) {
1049        heap->Pop(&entry);
1050      }
1051    } else {
1052      delete d;
1053    }
1054  }
1055  void RecodeBeamSearch::PushHeapIfBetter(int max_size, RecodeNode *node,
1056                                          RecodeHeap *heap) {
1057    if (heap->size() < max_size || node->score > heap->PeekTop().data().score) {
1058      if (UpdateHeapIfMatched(node, heap)) {
1059        return;
1060      }
1061      RecodePair entry(node->score, *node);
1062      heap->Push(&entry);
1063      ASSERT_HOST(entry.data().dawgs == nullptr);
1064      if (heap->size() > max_size) {
1065        heap->Pop(&entry);
1066      }
1067    }
1068  }
1069  bool RecodeBeamSearch::UpdateHeapIfMatched(RecodeNode *new_node,
1070                                             RecodeHeap *heap) {
1071    std::vector<RecodePair> &nodes = heap->heap();
1072    for (auto &i : nodes) {
1073      RecodeNode &node = i.data();
1074      if (node.code == new_node->code && node.code_hash == new_node->code_hash &&
1075          node.permuter == new_node->permuter &&
1076          node.start_of_dawg == new_node->start_of_dawg) {
1077        if (new_node->score > node.score) {
1078          node = *new_node;
1079          i.key() = node.score;
1080          heap->Reshuffle(&i);
1081        }
1082        return true;
1083      }
1084    }
1085    return false;
1086  }
1087  uint64_t RecodeBeamSearch::ComputeCodeHash(int code, bool dup,
1088                                             const RecodeNode *prev) const {
1089    uint64_t hash = prev == nullptr ? 0 : prev->code_hash;
1090    if (!dup && code != null_char_) {
1091      int num_classes = recoder_.code_range();
1092      uint64_t carry = (((hash >> 32) * num_classes) >> 32);
1093      hash *= num_classes;
1094      hash += carry;
1095      hash += code;
1096    }
1097    return hash;
1098  }
1099  void RecodeBeamSearch::ExtractBestPaths(
1100      std::vector<const RecodeNode *> *best_nodes,
1101      std::vector<const RecodeNode *> *second_nodes) const {
1102    const RecodeNode *best_node = nullptr;
1103    const RecodeNode *second_best_node = nullptr;
1104    const RecodeBeam *last_beam = beam_[beam_size_ - 1];
1105    for (int c = 0; c < NC_COUNT; ++c) {
1106      if (c == NC_ONLY_DUP) {
1107        continue;
1108      }
1109      auto cont = static_cast<NodeContinuation>(c);
1110      for (int is_dawg = 0; is_dawg < 2; ++is_dawg) {
1111        int beam_index = BeamIndex(is_dawg, cont, 0);
1112        int heap_size = last_beam->beams_[beam_index].size();
1113        for (int h = 0; h < heap_size; ++h) {
1114          const RecodeNode *node = &last_beam->beams_[beam_index].get(h).data();
1115          if (is_dawg) {
1116            const RecodeNode *dawg_node = node;
1117            while (dawg_node != nullptr &&
1118                   (dawg_node->unichar_id == INVALID_UNICHAR_ID ||
1119                    dawg_node->duplicate)) {
1120              dawg_node = dawg_node->prev;
1121            }
1122            if (dawg_node == nullptr ||
1123                (!dawg_node->end_of_word &&
1124                 dawg_node->unichar_id != UNICHAR_SPACE)) {
1125              continue;
1126            }
1127          }
1128          if (best_node == nullptr || node->score > best_node->score) {
1129            second_best_node = best_node;
1130            best_node = node;
1131          } else if (second_best_node == nullptr ||
1132                     node->score > second_best_node->score) {
1133            second_best_node = node;
1134          }
1135        }
1136      }
1137    }
1138    if (second_nodes != nullptr) {
1139      ExtractPath(second_best_node, second_nodes);
1140    }
1141    ExtractPath(best_node, best_nodes);
1142  }
1143  void RecodeBeamSearch::ExtractPath(
1144      const RecodeNode *node, std::vector<const RecodeNode *> *path) const {
1145    path->clear();
1146    while (node != nullptr) {
1147      path->push_back(node);
1148      node = node->prev;
1149    }
1150    std::reverse(path->begin(), path->end());
1151  }
1152  void RecodeBeamSearch::ExtractPath(const RecodeNode *node,
1153                                     std::vector<const RecodeNode *> *path,
1154                                     int limiter) const {
1155    int pathcounter = 0;
1156    path->clear();
1157    while (node != nullptr && pathcounter < limiter) {
1158      path->push_back(node);
1159      node = node->prev;
1160      ++pathcounter;
1161    }
1162    std::reverse(path->begin(), path->end());
1163  }
1164  void RecodeBeamSearch::DebugPath(
1165      const UNICHARSET *unicharset,
1166      const std::vector<const RecodeNode *> &path) const {
1167    for (unsigned c = 0; c < path.size(); ++c) {
1168      const RecodeNode &node = *path[c];
1169      tprintf("%u ", c);
1170      node.Print(null_char_, *unicharset, 1);
1171    }
1172  }
1173  void RecodeBeamSearch::DebugUnicharPath(
1174      const UNICHARSET *unicharset, const std::vector<const RecodeNode *> &path,
1175      const std::vector<int> &unichar_ids, const std::vector<float> &certs,
1176      const std::vector<float> &ratings, const std::vector<int> &xcoords) const {
1177    auto num_ids = unichar_ids.size();
1178    double total_rating = 0.0;
1179    for (unsigned c = 0; c < num_ids; ++c) {
1180      int coord = xcoords[c];
1181      tprintf("%d %d=%s r=%g, c=%g, s=%d, e=%d, perm=%d\n", coord, unichar_ids[c],
1182              unicharset->debug_str(unichar_ids[c]).c_str(), ratings[c], certs[c],
1183              path[coord]->start_of_word, path[coord]->end_of_word,
1184              path[coord]->permuter);
1185      total_rating += ratings[c];
1186    }
1187    tprintf("Path total rating = %g\n", total_rating);
1188  }
1189  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-infonet.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam.cpp</div>
                <div class="column column_space"><pre><code>589    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
590      TStrV FldValV;
591      for (int X=0; X<DatSs->GetXLen(Y); X++){
</pre></code></div>
                <div class="column column_space"><pre><code>688        for (int index = 0; index < kNumBeams; ++index) {
689          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    