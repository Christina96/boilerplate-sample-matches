
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 51845, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-catch_14.hpp</h3>
            <pre><code>1  #ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
2  #define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
3  #define CATCH_VERSION_MAJOR 2
4  #define CATCH_VERSION_MINOR 13
5  #define CATCH_VERSION_PATCH 7
6  #ifdef __clang__
7  #    pragma clang system_header
8  #elif defined __GNUC__
9  #    pragma GCC system_header
10  #endif
11  #ifdef __clang__
12  #   ifdef __ICC 
13  #       pragma warning(push)
14  #       pragma warning(disable: 161 1682)
15  #   else 
16  #       pragma clang diagnostic push
17  #       pragma clang diagnostic ignored &quot;-Wpadded&quot;
18  #       pragma clang diagnostic ignored &quot;-Wswitch-enum&quot;
19  #       pragma clang diagnostic ignored &quot;-Wcovered-switch-default&quot;
20  #    endif
21  #elif defined __GNUC__
22  #    pragma GCC diagnostic ignored &quot;-Wparentheses&quot; 
23  #    pragma GCC diagnostic push
24  #    pragma GCC diagnostic ignored &quot;-Wunused-variable&quot;
25  #    pragma GCC diagnostic ignored &quot;-Wpadded&quot;
26  #endif
27  #if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
28  #  define CATCH_IMPL
29  #  define CATCH_CONFIG_ALL_PARTS
30  #endif
31  #if defined(CATCH_CONFIG_ALL_PARTS)
32  #  define CATCH_CONFIG_EXTERNAL_INTERFACES
33  #  if defined(CATCH_CONFIG_DISABLE_MATCHERS)
34  #    undef CATCH_CONFIG_DISABLE_MATCHERS
35  #  endif
36  #  if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
37  #    define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
38  #  endif
39  #endif
40  #if !defined(CATCH_CONFIG_IMPL_ONLY)
41  #ifdef __APPLE__
42  #  include &lt;TargetConditionals.h&gt;
43  #  if (defined(TARGET_OS_OSX) &amp;&amp; TARGET_OS_OSX == 1) || \
44        (defined(TARGET_OS_MAC) &amp;&amp; TARGET_OS_MAC == 1)
45  #    define CATCH_PLATFORM_MAC
46  #  elif (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE == 1)
47  #    define CATCH_PLATFORM_IPHONE
48  #  endif
49  #elif defined(linux) || defined(__linux) || defined(__linux__)
50  #  define CATCH_PLATFORM_LINUX
51  #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
52  #  define CATCH_PLATFORM_WINDOWS
53  #endif
54  #ifdef CATCH_IMPL
55  #  ifndef CLARA_CONFIG_MAIN
56  #    define CLARA_CONFIG_MAIN_NOT_DEFINED
57  #    define CLARA_CONFIG_MAIN
58  #  endif
59  #endif
60  namespace Catch {
61      unsigned int rngSeed();
62  }
63  #ifdef __cplusplus
64  #  if (__cplusplus &gt;= 201402L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201402L)
65  #    define CATCH_CPP14_OR_GREATER
66  #  endif
67  #  if (__cplusplus &gt;= 201703L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)
68  #    define CATCH_CPP17_OR_GREATER
69  #  endif
70  #endif
71  #if defined(__GNUC__) &amp;&amp; !defined(__clang__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__CUDACC__) &amp;&amp; !defined(__LCC__)
72  #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( &quot;GCC diagnostic push&quot; )
73  #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( &quot;GCC diagnostic pop&quot; )
74  #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)
75  #endif
76  #if defined(__clang__)
77  #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( &quot;clang diagnostic push&quot; )
78  #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( &quot;clang diagnostic pop&quot; )
79  #  if !defined(__ibmxl__) &amp;&amp; !defined(__CUDACC__)
80  #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) &amp;bsol;* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */
81  #  endif
82  #    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
83           _Pragma( &quot;clang diagnostic ignored \&quot;-Wexit-time-destructors\&quot;&quot; ) \
84           _Pragma( &quot;clang diagnostic ignored \&quot;-Wglobal-constructors\&quot;&quot;)
85  #    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
86           _Pragma( &quot;clang diagnostic ignored \&quot;-Wparentheses\&quot;&quot; )
87  #    define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
88           _Pragma( &quot;clang diagnostic ignored \&quot;-Wunused-variable\&quot;&quot; )
89  #    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
90           _Pragma( &quot;clang diagnostic ignored \&quot;-Wgnu-zero-variadic-macro-arguments\&quot;&quot; )
91  #    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
92           _Pragma( &quot;clang diagnostic ignored \&quot;-Wunused-template\&quot;&quot; )
93  #endif 
94  #if !defined(CATCH_PLATFORM_WINDOWS)
95      #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
96  #endif
97  #if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
98      #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
99  #endif
100  #ifdef __OS400__
101  #       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
102  #       define CATCH_CONFIG_COLOUR_NONE
103  #endif
104  #if defined(__ANDROID__)
105  #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
106  #    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE
107  #endif
108  #if defined(__MINGW32__)
109  #    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
110  #endif
111  #if defined(__ORBIS__)
112  #    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
113  #endif
114  #ifdef __CYGWIN__
115  #   define _BSD_SOURCE
116  # if !((__cplusplus &gt;= 201103L) &amp;&amp; defined(_GLIBCXX_USE_C99) \
117             &amp;&amp; !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))
118  #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
119  # endif
120  #endif 
121  #if defined(_MSC_VER)
122  #  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
123  #  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )
124  #  if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY == WINAPI_FAMILY_APP)
125  #    define CATCH_CONFIG_COLOUR_NONE
126  #  else
127  #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
128  #  endif
129  #  if !defined(__clang__) 
130  #    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) &amp;&amp; _MSVC_TRADITIONAL)
131  #      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
132  #    endif 
133  #  endif 
134  #endif 
135  #if defined(_REENTRANT) || defined(_MSC_VER)
136  # define CATCH_INTERNAL_CONFIG_USE_ASYNC
137  #endif 
138  #if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
139  #  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
140  #endif
141  #ifdef __DJGPP__
142  #  define CATCH_INTERNAL_CONFIG_NO_WCHAR
143  #endif 
144  #if defined(__BORLANDC__)
145      #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
146  #endif
147  #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ &gt;= 20170300L )
148      #define CATCH_INTERNAL_CONFIG_COUNTER
149  #endif
150  #if defined(UNDER_RTSS) || defined(RTX64_BUILD)
151      #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
152      #define CATCH_INTERNAL_CONFIG_NO_ASYNC
153      #define CATCH_CONFIG_COLOUR_NONE
154  #endif
155  #if !defined(_GLIBCXX_USE_C99_MATH_TR1)
156  #define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER
157  #endif
158  #if defined(__has_include)
159    #if __has_include(&lt;string_view&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
160    #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
161    #endif
162    #  if __has_include(&lt;optional&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
163    #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
164    #  endif 
165    #  if __has_include(&lt;cstddef&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
166    #    include &lt;cstddef&gt;
167    #    if defined(__cpp_lib_byte) &amp;&amp; (__cpp_lib_byte &gt; 0)
168    #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE
169    #    endif
170    #  endif 
171    #  if __has_include(&lt;variant&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
172    #    if defined(__clang__) &amp;&amp; (__clang_major__ &lt; 8)
173    #      include &lt;ciso646&gt;
174    #      if defined(__GLIBCXX__) &amp;&amp; defined(_GLIBCXX_RELEASE) &amp;&amp; (_GLIBCXX_RELEASE &lt; 9)
175    #        define CATCH_CONFIG_NO_CPP17_VARIANT
176    #      else
177    #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
178    #      endif 
179    #    else
180    #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
181    #    endif 
182    #  endif 
183  #endif 
184  #if defined(CATCH_INTERNAL_CONFIG_COUNTER) &amp;&amp; !defined(CATCH_CONFIG_NO_COUNTER) &amp;&amp; !defined(CATCH_CONFIG_COUNTER)
185  #   define CATCH_CONFIG_COUNTER
186  #endif
187  #if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) &amp;&amp; !defined(CATCH_CONFIG_NO_WINDOWS_SEH) &amp;&amp; !defined(CATCH_CONFIG_WINDOWS_SEH) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
188  #   define CATCH_CONFIG_WINDOWS_SEH
189  #endif
190  #if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_CONFIG_POSIX_SIGNALS)
191  #   define CATCH_CONFIG_POSIX_SIGNALS
192  #endif
193  #if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) &amp;&amp; !defined(CATCH_CONFIG_NO_WCHAR) &amp;&amp; !defined(CATCH_CONFIG_WCHAR)
194  #   define CATCH_CONFIG_WCHAR
195  #endif
196  #if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) &amp;&amp; !defined(CATCH_CONFIG_CPP11_TO_STRING)
197  #    define CATCH_CONFIG_CPP11_TO_STRING
198  #endif
199  #if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) &amp;&amp; !defined(CATCH_CONFIG_CPP17_OPTIONAL)
200  #  define CATCH_CONFIG_CPP17_OPTIONAL
201  #endif
202  #if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) &amp;&amp; !defined(CATCH_CONFIG_CPP17_STRING_VIEW)
203  #  define CATCH_CONFIG_CPP17_STRING_VIEW
204  #endif
205  #if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_VARIANT) &amp;&amp; !defined(CATCH_CONFIG_CPP17_VARIANT)
206  #  define CATCH_CONFIG_CPP17_VARIANT
207  #endif
208  #if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_BYTE) &amp;&amp; !defined(CATCH_CONFIG_CPP17_BYTE)
209  #  define CATCH_CONFIG_CPP17_BYTE
210  #endif
211  #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
212  #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
213  #endif
214  #if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) &amp;&amp; !defined(CATCH_CONFIG_NO_NEW_CAPTURE) &amp;&amp; !defined(CATCH_CONFIG_NEW_CAPTURE)
215  #  define CATCH_CONFIG_NEW_CAPTURE
216  #endif
217  #if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
218  #  define CATCH_CONFIG_DISABLE_EXCEPTIONS
219  #endif
220  #if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) &amp;&amp; !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) &amp;&amp; !defined(CATCH_CONFIG_POLYFILL_ISNAN)
221  #  define CATCH_CONFIG_POLYFILL_ISNAN
222  #endif
223  #if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) &amp;&amp; !defined(CATCH_CONFIG_NO_USE_ASYNC) &amp;&amp; !defined(CATCH_CONFIG_USE_ASYNC)
224  #  define CATCH_CONFIG_USE_ASYNC
225  #endif
226  #if defined(CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE) &amp;&amp; !defined(CATCH_CONFIG_NO_ANDROID_LOGWRITE) &amp;&amp; !defined(CATCH_CONFIG_ANDROID_LOGWRITE)
227  #  define CATCH_CONFIG_ANDROID_LOGWRITE
228  #endif
229  #if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) &amp;&amp; !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) &amp;&amp; !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
230  #  define CATCH_CONFIG_GLOBAL_NEXTAFTER
231  #endif
232  #if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)
233  #   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
234  #endif
235  #if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)
236  #   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
237  #endif
238  #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
239  #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
240  #endif
241  #if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
242  #   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
243  #endif
244  #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS)
245  #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS
246  #endif
247  #if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)
248  #   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
249  #endif
250  #if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)
251  #   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)
252  #endif
253  #if defined(__APPLE__) &amp;&amp; defined(__apple_build_version__) &amp;&amp; (__clang_major__ &lt; 10)
254  #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
255  #elif defined(__clang__) &amp;&amp; (__clang_major__ &lt; 5)
256  #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
257  #endif
258  #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS)
259  #   define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
260  #endif
261  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
262  #define CATCH_TRY if ((true))
263  #define CATCH_CATCH_ALL if ((false))
264  #define CATCH_CATCH_ANON(type) if ((false))
265  #else
266  #define CATCH_TRY try
267  #define CATCH_CATCH_ALL catch (...)
268  #define CATCH_CATCH_ANON(type) catch (type)
269  #endif
270  #if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) &amp;&amp; !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) &amp;&amp; !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)
271  #define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
272  #endif
273  #define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
274  #define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
275  #ifdef CATCH_CONFIG_COUNTER
276  #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
277  #else
278  #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
279  #endif
280  #include &lt;iosfwd&gt;
281  #include &lt;string&gt;
282  #include &lt;cstdint&gt;
283  struct Catch_global_namespace_dummy {};
284  std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, Catch_global_namespace_dummy);
285  namespace Catch {
286      struct CaseSensitive { enum Choice {
287          Yes,
288          No
289      }; };
290      class NonCopyable {
291          NonCopyable( NonCopyable const&amp; )              = delete;
292          NonCopyable( NonCopyable &amp;&amp; )                  = delete;
293          NonCopyable&amp; operator = ( NonCopyable const&amp; ) = delete;
294          NonCopyable&amp; operator = ( NonCopyable &amp;&amp; )     = delete;
295      protected:
296          NonCopyable();
297          virtual ~NonCopyable();
298      };
299      struct SourceLineInfo {
300          SourceLineInfo() = delete;
301          SourceLineInfo( char const* _file, std::size_t _line ) noexcept
302          :   file( _file ),
303              line( _line )
304          {}
305          SourceLineInfo( SourceLineInfo const&amp; other )            = default;
306          SourceLineInfo&amp; operator = ( SourceLineInfo const&amp; )     = default;
307          SourceLineInfo( SourceLineInfo&amp;&amp; )              noexcept = default;
308          SourceLineInfo&amp; operator = ( SourceLineInfo&amp;&amp; ) noexcept = default;
309          bool empty() const noexcept { return file[0] == &#x27;\0&#x27;; }
310          bool operator == ( SourceLineInfo const&amp; other ) const noexcept;
311          bool operator &lt; ( SourceLineInfo const&amp; other ) const noexcept;
312          char const* file;
313          std::size_t line;
314      };
315      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, SourceLineInfo const&amp; info );
316      using ::operator&lt;&lt;;
317      struct StreamEndStop {
318          std::string operator+() const;
319      };
320      template&lt;typename T&gt;
321      T const&amp; operator + ( T const&amp; value, StreamEndStop ) {
322          return value;
323      }
324  }
325  #define CATCH_INTERNAL_LINEINFO \
326      ::Catch::SourceLineInfo( __FILE__, static_cast&lt;std::size_t&gt;( __LINE__ ) )
327  namespace Catch {
328      struct RegistrarForTagAliases {
329          RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const&amp; lineInfo );
330      };
331  } 
332  #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
333      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
334      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
335      namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
336      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
337  #include &lt;vector&gt;
338  namespace Catch {
339      class TestSpec;
340      struct ITestInvoker {
341          virtual void invoke () const = 0;
342          virtual ~ITestInvoker();
343      };
344      class TestCase;
345      struct IConfig;
346      struct ITestCaseRegistry {
347          virtual ~ITestCaseRegistry();
348          virtual std::vector&lt;TestCase&gt; const&amp; getAllTests() const = 0;
349          virtual std::vector&lt;TestCase&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const = 0;
350      };
351      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config );
352      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config );
353      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );
354      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );
355  }
356  #include &lt;cstddef&gt;
357  #include &lt;string&gt;
358  #include &lt;iosfwd&gt;
359  #include &lt;cassert&gt;
360  namespace Catch {
361      class StringRef {
362      public:
363          using size_type = std::size_t;
364          using const_iterator = const char*;
365      private:
366          static constexpr char const* const s_empty = &quot;&quot;;
367          char const* m_start = s_empty;
368          size_type m_size = 0;
369      public: 
370          constexpr StringRef() noexcept = default;
371          StringRef( char const* rawChars ) noexcept;
372          constexpr StringRef( char const* rawChars, size_type size ) noexcept
373          :   m_start( rawChars ),
374              m_size( size )
375          {}
376          StringRef( std::string const&amp; stdString ) noexcept
377          :   m_start( stdString.c_str() ),
378              m_size( stdString.size() )
379          {}
380          explicit operator std::string() const {
381              return std::string(m_start, m_size);
382          }
383      public: 
384          auto operator == ( StringRef const&amp; other ) const noexcept -&gt; bool;
385          auto operator != (StringRef const&amp; other) const noexcept -&gt; bool {
386              return !(*this == other);
387          }
388          auto operator[] ( size_type index ) const noexcept -&gt; char {
389              assert(index &lt; m_size);
390              return m_start[index];
391          }
392      public: 
393          constexpr auto empty() const noexcept -&gt; bool {
394              return m_size == 0;
395          }
396          constexpr auto size() const noexcept -&gt; size_type {
397              return m_size;
398          }
399          auto c_str() const -&gt; char const*;
400      public: 
401          auto substr( size_type start, size_type length ) const noexcept -&gt; StringRef;
402          auto data() const noexcept -&gt; char const*;
403          constexpr auto isNullTerminated() const noexcept -&gt; bool {
404              return m_start[m_size] == &#x27;\0&#x27;;
405          }
406      public: 
407          constexpr const_iterator begin() const { return m_start; }
408          constexpr const_iterator end() const { return m_start + m_size; }
409      };
410      auto operator += ( std::string&amp; lhs, StringRef const&amp; sr ) -&gt; std::string&amp;;
411      auto operator &lt;&lt; ( std::ostream&amp; os, StringRef const&amp; sr ) -&gt; std::ostream&amp;;
412      constexpr auto operator &quot;&quot; _sr( char const* rawChars, std::size_t size ) noexcept -&gt; StringRef {
413          return StringRef( rawChars, size );
414      }
415  } 
416  constexpr auto operator &quot;&quot; _catch_sr( char const* rawChars, std::size_t size ) noexcept -&gt; Catch::StringRef {
417      return Catch::StringRef( rawChars, size );
418  }
419  #define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__
420  #define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))
421  #define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))
422  #define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))
423  #define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))
424  #define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))
425  #ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
426  #define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__
427  #define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))
428  #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))
429  #else
430  #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)
431  #endif
432  #define CATCH_REC_END(...)
433  #define CATCH_REC_OUT
434  #define CATCH_EMPTY()
435  #define CATCH_DEFER(id) id CATCH_EMPTY()
436  #define CATCH_REC_GET_END2() 0, CATCH_REC_END
437  #define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2
438  #define CATCH_REC_GET_END(...) CATCH_REC_GET_END1
439  #define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT
440  #define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)
441  #define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)
442  #define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
443  #define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )
444  #define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
445  #define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
446  #define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )
447  #define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
448  #define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
449  #define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
450  #define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)
451  #define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__
452  #define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__
453  #define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
454  #define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)
455  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
456  #define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__
457  #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))
458  #else
459  #define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)
460  #define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__
461  #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)
462  #endif
463  #define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__
464  #define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)
465  #define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)
466  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
467  #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)&gt;())
468  #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))
469  #else
470  #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)&gt;()))
471  #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))
472  #endif
473  #define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\
474      CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)
475  #define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)
476  #define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)
477  #define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)
478  #define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)
479  #define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)
480  #define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)
481  #define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)
482  #define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)
483  #define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)
484  #define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)
485  #define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)
486  #define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
487  #define INTERNAL_CATCH_TYPE_GEN\
488      template&lt;typename...&gt; struct TypeList {};\
489      template&lt;typename...Ts&gt;\
490      constexpr auto get_wrapper() noexcept -&gt; TypeList&lt;Ts...&gt; { return {}; }\
491      template&lt;template&lt;typename...&gt; class...&gt; struct TemplateTypeList{};\
492      template&lt;template&lt;typename...&gt; class...Cs&gt;\
493      constexpr auto get_wrapper() noexcept -&gt; TemplateTypeList&lt;Cs...&gt; { return {}; }\
494      template&lt;typename...&gt;\
495      struct append;\
496      template&lt;typename...&gt;\
497      struct rewrap;\
498      template&lt;template&lt;typename...&gt; class, typename...&gt;\
499      struct create;\
500      template&lt;template&lt;typename...&gt; class, typename&gt;\
501      struct convert;\
502      \
503      template&lt;typename T&gt; \
504      struct append&lt;T&gt; { using type = T; };\
505      template&lt; template&lt;typename...&gt; class L1, typename...E1, template&lt;typename...&gt; class L2, typename...E2, typename...Rest&gt;\
506      struct append&lt;L1&lt;E1...&gt;, L2&lt;E2...&gt;, Rest...&gt; { using type = typename append&lt;L1&lt;E1...,E2...&gt;, Rest...&gt;::type; };\
507      template&lt; template&lt;typename...&gt; class L1, typename...E1, typename...Rest&gt;\
508      struct append&lt;L1&lt;E1...&gt;, TypeList&lt;mpl_::na&gt;, Rest...&gt; { using type = L1&lt;E1...&gt;; };\
509      \
510      template&lt; template&lt;typename...&gt; class Container, template&lt;typename...&gt; class List, typename...elems&gt;\
511      struct rewrap&lt;TemplateTypeList&lt;Container&gt;, List&lt;elems...&gt;&gt; { using type = TypeList&lt;Container&lt;elems...&gt;&gt;; };\
512      template&lt; template&lt;typename...&gt; class Container, template&lt;typename...&gt; class List, class...Elems, typename...Elements&gt;\
513      struct rewrap&lt;TemplateTypeList&lt;Container&gt;, List&lt;Elems...&gt;, Elements...&gt; { using type = typename append&lt;TypeList&lt;Container&lt;Elems...&gt;&gt;, typename rewrap&lt;TemplateTypeList&lt;Container&gt;, Elements...&gt;::type&gt;::type; };\
514      \
515      template&lt;template &lt;typename...&gt; class Final, template&lt; typename...&gt; class...Containers, typename...Types&gt;\
516      struct create&lt;Final, TemplateTypeList&lt;Containers...&gt;, TypeList&lt;Types...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;, typename rewrap&lt;TemplateTypeList&lt;Containers&gt;, Types...&gt;::type...&gt;::type; };\
517      template&lt;template &lt;typename...&gt; class Final, template &lt;typename...&gt; class List, typename...Ts&gt;\
518      struct convert&lt;Final, List&lt;Ts...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;,TypeList&lt;Ts&gt;...&gt;::type; };
519  #define INTERNAL_CATCH_NTTP_1(signature, ...)\
520      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; struct Nttp{};\
521      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
522      constexpr auto get_wrapper() noexcept -&gt; Nttp&lt;__VA_ARGS__&gt; { return {}; } \
523      template&lt;template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...&gt; struct NttpTemplateTypeList{};\
524      template&lt;template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...Cs&gt;\
525      constexpr auto get_wrapper() noexcept -&gt; NttpTemplateTypeList&lt;Cs...&gt; { return {}; } \
526      \
527      template&lt; template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class Container, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class List, INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
528      struct rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, List&lt;__VA_ARGS__&gt;&gt; { using type = TypeList&lt;Container&lt;__VA_ARGS__&gt;&gt;; };\
529      template&lt; template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class Container, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements&gt;\
530      struct rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, List&lt;__VA_ARGS__&gt;, Elements...&gt; { using type = typename append&lt;TypeList&lt;Container&lt;__VA_ARGS__&gt;&gt;, typename rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, Elements...&gt;::type&gt;::type; };\
531      template&lt;template &lt;typename...&gt; class Final, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...Containers, typename...Types&gt;\
532      struct create&lt;Final, NttpTemplateTypeList&lt;Containers...&gt;, TypeList&lt;Types...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;, typename rewrap&lt;NttpTemplateTypeList&lt;Containers&gt;, Types...&gt;::type...&gt;::type; };
533  #define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)
534  #define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\
535      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
536      static void TestName()
537  #define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\
538      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
539      static void TestName()
540  #define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)
541  #define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\
542      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
543      static void TestName()
544  #define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\
545      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
546      static void TestName()
547  #define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\
548      template&lt;typename Type&gt;\
549      void reg_test(TypeList&lt;Type&gt;, Catch::NameAndTags nameAndTags)\
550      {\
551          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestFunc&lt;Type&gt;), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
552      }
553  #define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\
554      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
555      void reg_test(Nttp&lt;__VA_ARGS__&gt;, Catch::NameAndTags nameAndTags)\
556      {\
557          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestFunc&lt;__VA_ARGS__&gt;), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
558      }
559  #define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\
560      template&lt;typename Type&gt;\
561      void reg_test(TypeList&lt;Type&gt;, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
562      {\
563          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestName&lt;Type&gt;::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
564      }
565  #define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\
566      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
567      void reg_test(Nttp&lt;__VA_ARGS__&gt;, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
568      {\
569          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestName&lt;__VA_ARGS__&gt;::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
570      }
571  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)
572  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\
573      template&lt;typename TestType&gt; \
574      struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)&lt;TestType&gt; { \
575          void test();\
576      }
577  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\
578      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; \
579      struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)&lt;__VA_ARGS__&gt; { \
580          void test();\
581      }
582  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)
583  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\
584      template&lt;typename TestType&gt; \
585      void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName&lt;TestType&gt;::test()
586  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\
587      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; \
588      void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName&lt;__VA_ARGS__&gt;::test()
589  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
590  #define INTERNAL_CATCH_NTTP_0
591  #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)
592  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)
593  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)
594  #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)
595  #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)
596  #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)
597  #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)
598  #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)
599  #else
600  #define INTERNAL_CATCH_NTTP_0(signature)
601  #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))
602  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))
603  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))
604  #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))
605  #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))
606  #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))
607  #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))
608  #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))
609  #endif
610  #include &lt;type_traits&gt;
611  namespace Catch {
612      template&lt;typename T&gt;
613      struct always_false : std::false_type {};
614      template &lt;typename&gt; struct true_given : std::true_type {};
615      struct is_callable_tester {
616          template &lt;typename Fun, typename... Args&gt;
617          true_given&lt;decltype(std::declval&lt;Fun&gt;()(std::declval&lt;Args&gt;()...))&gt; static test(int);
618          template &lt;typename...&gt;
619          std::false_type static test(...);
620      };
621      template &lt;typename T&gt;
622      struct is_callable;
623      template &lt;typename Fun, typename... Args&gt;
624      struct is_callable&lt;Fun(Args...)&gt; : decltype(is_callable_tester::test&lt;Fun, Args...&gt;(0)) {};
625  #if defined(__cpp_lib_is_invocable) &amp;&amp; __cpp_lib_is_invocable &gt;= 201703
626      template &lt;typename Func, typename... U&gt;
627      using FunctionReturnType = std::remove_reference_t&lt;std::remove_cv_t&lt;std::invoke_result_t&lt;Func, U...&gt;&gt;&gt;;
628  #else
629      template &lt;typename Func, typename... U&gt;
630      using FunctionReturnType = typename std::remove_reference&lt;typename std::remove_cv&lt;typename std::result_of&lt;Func(U...)&gt;::type&gt;::type&gt;::type;
631  #endif
632  } 
633  namespace mpl_{
634      struct na;
635  }
636  namespace Catch {
637  template&lt;typename C&gt;
638  class TestInvokerAsMethod : public ITestInvoker {
639      void (C::*m_testAsMethod)();
640  public:
641      TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
642      void invoke() const override {
643          C obj;
644          (obj.*m_testAsMethod)();
645      }
646  };
647  auto makeTestInvoker( void(*testAsFunction)() ) noexcept -&gt; ITestInvoker*;
648  template&lt;typename C&gt;
649  auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -&gt; ITestInvoker* {
650      return new(std::nothrow) TestInvokerAsMethod&lt;C&gt;( testAsMethod );
651  }
652  struct NameAndTags {
653      NameAndTags( StringRef const&amp; name_ = StringRef(), StringRef const&amp; tags_ = StringRef() ) noexcept;
654      StringRef name;
655      StringRef tags;
656  };
657  struct AutoReg : NonCopyable {
658      AutoReg( ITestInvoker* invoker, SourceLineInfo const&amp; lineInfo, StringRef const&amp; classOrMethod, NameAndTags const&amp; nameAndTags ) noexcept;
659      ~AutoReg();
660  };
661  } 
662  #if defined(CATCH_CONFIG_DISABLE)
663      #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
664          static void TestName()
665      #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
666          namespace{                        \
667              struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
668                  void test();              \
669              };                            \
670          }                                 \
671          void TestName::test()
672      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \
673          INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))
674      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \
675          namespace{                                                                                  \
676              namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \
677              INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
678          }                                                                                           \
679          }                                                                                           \
680          INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
681      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
682          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
683              INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
684      #else
685          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
686              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
687      #endif
688      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
689          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
690              INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
691      #else
692          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
693              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
694      #endif
695      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
696          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
697              INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
698      #else
699          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
700              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
701      #endif
702      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
703          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
704              INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
705      #else
706          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
707              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
708      #endif
709  #endif
710      #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
711          static void TestName(); \
712          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
713          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
714          namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &amp;TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } &amp;bsol;* NOLINT */ \
715          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
716          static void TestName()
717      #define INTERNAL_CATCH_TESTCASE( ... ) \
718          INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
719      #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
720          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
721          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
722          namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &amp;QualifiedMethod ), CATCH_INTERNAL_LINEINFO, &quot;&amp;&quot; #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } &amp;bsol;* NOLINT */ \
723          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
724      #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
725          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
726          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
727          namespace{ \
728              struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
729                  void test(); \
730              }; \
731              Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &amp;TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); &amp;bsol;* NOLINT */ \
732          } \
733          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
734          void TestName::test()
735      #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
736          INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
737      #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
738          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
739          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
740          Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); &amp;bsol;* NOLINT */ \
741          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
742      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
743          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
744          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
745          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
746          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
747          INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
748          namespace {\
749          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
750              INTERNAL_CATCH_TYPE_GEN\
751              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
752              INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\
753              template&lt;typename...Types&gt; \
754              struct TestName{\
755                  TestName(){\
756                      int index = 0;                                    \
757                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
758                      using expander = int[];\
759                      (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index]), Tags } ), index++)... };&amp;bsol;* NOLINT */ \
760                  }\
761              };\
762              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
763              TestName&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)&gt;();\
764              return 0;\
765          }();\
766          }\
767          }\
768          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
769          INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))
770  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
771      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
772          INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
773  #else
774      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
775          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
776  #endif
777  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
778      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
779          INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
780  #else
781      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
782          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
783  #endif
784      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
785          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
786          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
787          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
788          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS              \
789          template&lt;typename TestType&gt; static void TestFuncName();       \
790          namespace {\
791          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \
792              INTERNAL_CATCH_TYPE_GEN                                                  \
793              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \
794              template&lt;typename... Types&gt;                               \
795              struct TestName {                                         \
796                  void reg_tests() {                                          \
797                      int index = 0;                                    \
798                      using expander = int[];                           \
799                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
800                      constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
801                      constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
802                      (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestFuncName&lt;Types&gt; ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index / num_types]) + &quot;&lt;&quot; + std::string(types_list[index % num_types]) + &quot;&gt;&quot;, Tags } ), index++)... };&amp;bsol;* NOLINT */\
803                  }                                                     \
804              };                                                        \
805              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
806                  using TestInit = typename create&lt;TestName, decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)&gt;()), TypeList&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))&gt;&gt;::type; \
807                  TestInit t;                                           \
808                  t.reg_tests();                                        \
809                  return 0;                                             \
810              }();                                                      \
811          }                                                             \
812          }                                                             \
813          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
814          template&lt;typename TestType&gt;                                   \
815          static void TestFuncName()
816  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
817      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
818          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)
819  #else
820      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
821          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )
822  #endif
823  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
824      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
825          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)
826  #else
827      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
828          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
829  #endif
830      #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
831          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
832          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
833          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
834          template&lt;typename TestType&gt; static void TestFunc();       \
835          namespace {\
836          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
837          INTERNAL_CATCH_TYPE_GEN\
838          template&lt;typename... Types&gt;                               \
839          struct TestName {                                         \
840              void reg_tests() {                                          \
841                  int index = 0;                                    \
842                  using expander = int[];                           \
843                  (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestFunc&lt;Types&gt; ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name &quot; - &quot; + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + &quot; - &quot; + std::to_string(index), Tags } ), index++)... };&amp;bsol;* NOLINT */\
844              }                                                     \
845          };\
846          static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
847                  using TestInit = typename convert&lt;TestName, TmplList&gt;::type; \
848                  TestInit t;                                           \
849                  t.reg_tests();                                        \
850                  return 0;                                             \
851              }();                                                      \
852          }}\
853          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
854          template&lt;typename TestType&gt;                                   \
855          static void TestFunc()
856      #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
857          INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )
858      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
859          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
860          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
861          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
862          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
863          namespace {\
864          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
865              INTERNAL_CATCH_TYPE_GEN\
866              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
867              INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
868              INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\
869              template&lt;typename...Types&gt; \
870              struct TestNameClass{\
871                  TestNameClass(){\
872                      int index = 0;                                    \
873                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
874                      using expander = int[];\
875                      (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index]), Tags } ), index++)... };&amp;bsol;* NOLINT */ \
876                  }\
877              };\
878              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
879                  TestNameClass&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)&gt;();\
880                  return 0;\
881          }();\
882          }\
883          }\
884          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
885          INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
886  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
887      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
888          INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
889  #else
890      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
891          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
892  #endif
893  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
894      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
895          INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
896  #else
897      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
898          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
899  #endif
900      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
901          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
902          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
903          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
904          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
905          template&lt;typename TestType&gt; \
906              struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName &lt;TestType&gt;) { \
907                  void test();\
908              };\
909          namespace {\
910          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\
911              INTERNAL_CATCH_TYPE_GEN                  \
912              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
913              template&lt;typename...Types&gt;\
914              struct TestNameClass{\
915                  void reg_tests(){\
916                      int index = 0;\
917                      using expander = int[];\
918                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
919                      constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
920                      constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
921                      (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestName&lt;Types&gt;::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index / num_types]) + &quot;&lt;&quot; + std::string(types_list[index % num_types]) + &quot;&gt;&quot;, Tags } ), index++)... };&amp;bsol;* NOLINT */ \
922                  }\
923              };\
924              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
925                  using TestInit = typename create&lt;TestNameClass, decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)&gt;()), TypeList&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))&gt;&gt;::type;\
926                  TestInit t;\
927                  t.reg_tests();\
928                  return 0;\
929              }(); \
930          }\
931          }\
932          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
933          template&lt;typename TestType&gt; \
934          void TestName&lt;TestType&gt;::test()
935  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
936      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
937          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
938  #else
939      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
940          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
941  #endif
942  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
943      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
944          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
945  #else
946      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
947          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
948  #endif
949      #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
950          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
951          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
952          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
953          template&lt;typename TestType&gt; \
954          struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName &lt;TestType&gt;) { \
955              void test();\
956          };\
957          namespace {\
958          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
959              INTERNAL_CATCH_TYPE_GEN\
960              template&lt;typename...Types&gt;\
961              struct TestNameClass{\
962                  void reg_tests(){\
963                      int index = 0;\
964                      using expander = int[];\
965                      (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestName&lt;Types&gt;::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + &quot; - &quot; + std::to_string(index), Tags } ), index++)... };&amp;bsol;* NOLINT */ \
966                  }\
967              };\
968              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
969                  using TestInit = typename convert&lt;TestNameClass, TmplList&gt;::type;\
970                  TestInit t;\
971                  t.reg_tests();\
972                  return 0;\
973              }(); \
974          }}\
975          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
976          template&lt;typename TestType&gt; \
977          void TestName&lt;TestType&gt;::test()
978  #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
979          INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )
980  namespace Catch {
981      struct ResultWas { enum OfType {
982          Unknown = -1,
983          Ok = 0,
984          Info = 1,
985          Warning = 2,
986          FailureBit = 0x10,
987          ExpressionFailed = FailureBit | 1,
988          ExplicitFailure = FailureBit | 2,
989          Exception = 0x100 | FailureBit,
990          ThrewException = Exception | 1,
991          DidntThrowException = Exception | 2,
992          FatalErrorCondition = 0x200 | FailureBit
993      }; };
994      bool isOk( ResultWas::OfType resultType );
995      bool isJustInfo( int flags );
996      struct ResultDisposition { enum Flags {
997          Normal = 0x01,
998          ContinueOnFailure = 0x02,   
999          FalseTest = 0x04,           
1000          SuppressFail = 0x08         
1001      }; };
1002      ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
1003      bool shouldContinueOnFailure( int flags );
1004      inline bool isFalseTest( int flags ) { return ( flags &amp; ResultDisposition::FalseTest ) != 0; }
1005      bool shouldSuppressFailure( int flags );
1006  } 
1007  namespace Catch {
1008      struct AssertionInfo
1009      {
1010          StringRef macroName;
1011          SourceLineInfo lineInfo;
1012          StringRef capturedExpression;
1013          ResultDisposition::Flags resultDisposition;
1014      };
1015  } 
1016  #include &lt;vector&gt;
1017  #include &lt;cstddef&gt;
1018  #include &lt;type_traits&gt;
1019  #include &lt;string&gt;
1020  #include &lt;iosfwd&gt;
1021  #include &lt;cstddef&gt;
1022  #include &lt;ostream&gt;
1023  namespace Catch {
1024      std::ostream&amp; cout();
1025      std::ostream&amp; cerr();
1026      std::ostream&amp; clog();
1027      class StringRef;
1028      struct IStream {
1029          virtual ~IStream();
1030          virtual std::ostream&amp; stream() const = 0;
1031      };
1032      auto makeStream( StringRef const &amp;filename ) -&gt; IStream const*;
1033      class ReusableStringStream : NonCopyable {
1034          std::size_t m_index;
1035          std::ostream* m_oss;
1036      public:
1037          ReusableStringStream();
1038          ~ReusableStringStream();
1039          auto str() const -&gt; std::string;
1040          template&lt;typename T&gt;
1041          auto operator &lt;&lt; ( T const&amp; value ) -&gt; ReusableStringStream&amp; {
1042              *m_oss &lt;&lt; value;
1043              return *this;
1044          }
1045          auto get() -&gt; std::ostream&amp; { return *m_oss; }
1046      };
1047  }
1048  #include &lt;vector&gt;
1049  namespace Catch {
1050      namespace Detail {
1051          struct EnumInfo {
1052              StringRef m_name;
1053              std::vector&lt;std::pair&lt;int, StringRef&gt;&gt; m_values;
1054              ~EnumInfo();
1055              StringRef lookup( int value ) const;
1056          };
1057      } 
1058      struct IMutableEnumValuesRegistry {
1059          virtual ~IMutableEnumValuesRegistry();
1060          virtual Detail::EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::vector&lt;int&gt; const&amp; values ) = 0;
1061          template&lt;typename E&gt;
1062          Detail::EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list&lt;E&gt; values ) {
1063              static_assert(sizeof(int) &gt;= sizeof(E), &quot;Cannot serialize enum to int&quot;);
1064              std::vector&lt;int&gt; intValues;
1065              intValues.reserve( values.size() );
1066              for( auto enumValue : values )
1067                  intValues.push_back( static_cast&lt;int&gt;( enumValue ) );
1068              return registerEnum( enumName, allEnums, intValues );
1069          }
1070      };
1071  } 
1072  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
1073  #include &lt;string_view&gt;
1074  #endif
1075  #ifdef __OBJC__
1076  #import &lt;Foundation/Foundation.h&gt;
1077  #ifdef __has_feature
1078  #define CATCH_ARC_ENABLED __has_feature(objc_arc)
1079  #else
1080  #define CATCH_ARC_ENABLED 0
1081  #endif
1082  void arcSafeRelease( NSObject* obj );
1083  id performOptionalSelector( id obj, SEL sel );
1084  #if !CATCH_ARC_ENABLED
1085  inline void arcSafeRelease( NSObject* obj ) {
1086      [obj release];
1087  }
1088  inline id performOptionalSelector( id obj, SEL sel ) {
1089      if( [obj respondsToSelector: sel] )
1090          return [obj performSelector: sel];
1091      return nil;
1092  }
1093  #define CATCH_UNSAFE_UNRETAINED
1094  #define CATCH_ARC_STRONG
1095  #else
1096  inline void arcSafeRelease( NSObject* ){}
1097  inline id performOptionalSelector( id obj, SEL sel ) {
1098  #ifdef __clang__
1099  #pragma clang diagnostic push
1100  #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;
1101  #endif
1102      if( [obj respondsToSelector: sel] )
1103          return [obj performSelector: sel];
1104  #ifdef __clang__
1105  #pragma clang diagnostic pop
1106  #endif
1107      return nil;
1108  }
1109  #define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
1110  #define CATCH_ARC_STRONG __strong
1111  #endif
1112  #endif
1113  #ifdef _MSC_VER
1114  #pragma warning(push)
1115  #pragma warning(disable:4180) 
1116  #endif
1117  namespace Catch {
1118      namespace Detail {
1119          extern const std::string unprintableString;
1120          std::string rawMemoryToString( const void *object, std::size_t size );
1121          template&lt;typename T&gt;
1122          std::string rawMemoryToString( const T&amp; object ) {
1123            return rawMemoryToString( &amp;object, sizeof(object) );
1124          }
1125          template&lt;typename T&gt;
1126          class IsStreamInsertable {
1127              template&lt;typename Stream, typename U&gt;
1128              static auto test(int)
1129                  -&gt; decltype(std::declval&lt;Stream&amp;&gt;() &lt;&lt; std::declval&lt;U&gt;(), std::true_type());
1130              template&lt;typename, typename&gt;
1131              static auto test(...)-&gt;std::false_type;
1132          public:
1133              static const bool value = decltype(test&lt;std::ostream, const T&amp;&gt;(0))::value;
1134          };
1135          template&lt;typename E&gt;
1136          std::string convertUnknownEnumToString( E e );
1137          template&lt;typename T&gt;
1138          typename std::enable_if&lt;
1139              !std::is_enum&lt;T&gt;::value &amp;&amp; !std::is_base_of&lt;std::exception, T&gt;::value,
1140          std::string&gt;::type convertUnstreamable( T const&amp; ) {
1141              return Detail::unprintableString;
1142          }
1143          template&lt;typename T&gt;
1144          typename std::enable_if&lt;
1145              !std::is_enum&lt;T&gt;::value &amp;&amp; std::is_base_of&lt;std::exception, T&gt;::value,
1146           std::string&gt;::type convertUnstreamable(T const&amp; ex) {
1147              return ex.what();
1148          }
1149          template&lt;typename T&gt;
1150          typename std::enable_if&lt;
1151              std::is_enum&lt;T&gt;::value
1152          , std::string&gt;::type convertUnstreamable( T const&amp; value ) {
1153              return convertUnknownEnumToString( value );
1154          }
1155  #if defined(_MANAGED)
1156          template&lt;typename T&gt;
1157          std::string clrReferenceToString( T^ ref ) {
1158              if (ref == nullptr)
1159                  return std::string(&quot;null&quot;);
1160              auto bytes = System::Text::Encoding::UTF8-&gt;GetBytes(ref-&gt;ToString());
1161              cli::pin_ptr&lt;System::Byte&gt; p = &amp;bytes[0];
1162              return std::string(reinterpret_cast&lt;char const *&gt;(p), bytes-&gt;Length);
1163          }
1164  #endif
1165      } 
1166      template &lt;typename T, typename = void&gt;
1167      struct StringMaker {
1168          template &lt;typename Fake = T&gt;
1169          static
1170          typename std::enable_if&lt;::Catch::Detail::IsStreamInsertable&lt;Fake&gt;::value, std::string&gt;::type
1171              convert(const Fake&amp; value) {
1172                  ReusableStringStream rss;
1173                  rss.operator&lt;&lt;(value);
1174                  return rss.str();
1175          }
1176          template &lt;typename Fake = T&gt;
1177          static
1178          typename std::enable_if&lt;!::Catch::Detail::IsStreamInsertable&lt;Fake&gt;::value, std::string&gt;::type
1179              convert( const Fake&amp; value ) {
1180  #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
1181              return Detail::convertUnstreamable(value);
1182  #else
1183              return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
1184  #endif
1185          }
1186      };
1187      namespace Detail {
1188          template &lt;typename T&gt;
1189          std::string stringify(const T&amp; e) {
1190              return ::Catch::StringMaker&lt;typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::convert(e);
1191          }
1192          template&lt;typename E&gt;
1193          std::string convertUnknownEnumToString( E e ) {
1194              return ::Catch::Detail::stringify(static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e));
1195          }
1196  #if defined(_MANAGED)
1197          template &lt;typename T&gt;
1198          std::string stringify( T^ e ) {
1199              return ::Catch::StringMaker&lt;T^&gt;::convert(e);
1200          }
1201  #endif
1202      } 
1203      template&lt;&gt;
1204      struct StringMaker&lt;std::string&gt; {
1205          static std::string convert(const std::string&amp; str);
1206      };
1207  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
1208      template&lt;&gt;
1209      struct StringMaker&lt;std::string_view&gt; {
1210          static std::string convert(std::string_view str);
1211      };
1212  #endif
1213      template&lt;&gt;
1214      struct StringMaker&lt;char const *&gt; {
1215          static std::string convert(char const * str);
1216      };
1217      template&lt;&gt;
1218      struct StringMaker&lt;char *&gt; {
1219          static std::string convert(char * str);
1220      };
1221  #ifdef CATCH_CONFIG_WCHAR
1222      template&lt;&gt;
1223      struct StringMaker&lt;std::wstring&gt; {
1224          static std::string convert(const std::wstring&amp; wstr);
1225      };
1226  # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
1227      template&lt;&gt;
1228      struct StringMaker&lt;std::wstring_view&gt; {
1229          static std::string convert(std::wstring_view str);
1230      };
1231  # endif
1232      template&lt;&gt;
1233      struct StringMaker&lt;wchar_t const *&gt; {
1234          static std::string convert(wchar_t const * str);
1235      };
1236      template&lt;&gt;
1237      struct StringMaker&lt;wchar_t *&gt; {
1238          static std::string convert(wchar_t * str);
1239      };
1240  #endif
1241      template&lt;int SZ&gt;
1242      struct StringMaker&lt;char[SZ]&gt; {
1243          static std::string convert(char const* str) {
1244              return ::Catch::Detail::stringify(std::string{ str });
1245          }
1246      };
1247      template&lt;int SZ&gt;
1248      struct StringMaker&lt;signed char[SZ]&gt; {
1249          static std::string convert(signed char const* str) {
1250              return ::Catch::Detail::stringify(std::string{ reinterpret_cast&lt;char const *&gt;(str) });
1251          }
1252      };
1253      template&lt;int SZ&gt;
1254      struct StringMaker&lt;unsigned char[SZ]&gt; {
1255          static std::string convert(unsigned char const* str) {
1256              return ::Catch::Detail::stringify(std::string{ reinterpret_cast&lt;char const *&gt;(str) });
1257          }
1258      };
1259  #if defined(CATCH_CONFIG_CPP17_BYTE)
1260      template&lt;&gt;
1261      struct StringMaker&lt;std::byte&gt; {
1262          static std::string convert(std::byte value);
1263      };
1264  #endif 
1265      template&lt;&gt;
1266      struct StringMaker&lt;int&gt; {
1267          static std::string convert(int value);
1268      };
1269      template&lt;&gt;
1270      struct StringMaker&lt;long&gt; {
1271          static std::string convert(long value);
1272      };
1273      template&lt;&gt;
1274      struct StringMaker&lt;long long&gt; {
1275          static std::string convert(long long value);
1276      };
1277      template&lt;&gt;
1278      struct StringMaker&lt;unsigned int&gt; {
1279          static std::string convert(unsigned int value);
1280      };
1281      template&lt;&gt;
1282      struct StringMaker&lt;unsigned long&gt; {
1283          static std::string convert(unsigned long value);
1284      };
1285      template&lt;&gt;
1286      struct StringMaker&lt;unsigned long long&gt; {
1287          static std::string convert(unsigned long long value);
1288      };
1289      template&lt;&gt;
1290      struct StringMaker&lt;bool&gt; {
1291          static std::string convert(bool b);
1292      };
1293      template&lt;&gt;
1294      struct StringMaker&lt;char&gt; {
1295          static std::string convert(char c);
1296      };
1297      template&lt;&gt;
1298      struct StringMaker&lt;signed char&gt; {
1299          static std::string convert(signed char c);
1300      };
1301      template&lt;&gt;
1302      struct StringMaker&lt;unsigned char&gt; {
1303          static std::string convert(unsigned char c);
1304      };
1305      template&lt;&gt;
1306      struct StringMaker&lt;std::nullptr_t&gt; {
1307          static std::string convert(std::nullptr_t);
1308      };
1309      template&lt;&gt;
1310      struct StringMaker&lt;float&gt; {
1311          static std::string convert(float value);
1312          static int precision;
1313      };
1314      template&lt;&gt;
1315      struct StringMaker&lt;double&gt; {
1316          static std::string convert(double value);
1317          static int precision;
1318      };
1319      template &lt;typename T&gt;
1320      struct StringMaker&lt;T*&gt; {
1321          template &lt;typename U&gt;
1322          static std::string convert(U* p) {
1323              if (p) {
1324                  return ::Catch::Detail::rawMemoryToString(p);
1325              } else {
1326                  return &quot;nullptr&quot;;
1327              }
1328          }
1329      };
1330      template &lt;typename R, typename C&gt;
1331      struct StringMaker&lt;R C::*&gt; {
1332          static std::string convert(R C::* p) {
1333              if (p) {
1334                  return ::Catch::Detail::rawMemoryToString(p);
1335              } else {
1336                  return &quot;nullptr&quot;;
1337              }
1338          }
1339      };
1340  #if defined(_MANAGED)
1341      template &lt;typename T&gt;
1342      struct StringMaker&lt;T^&gt; {
1343          static std::string convert( T^ ref ) {
1344              return ::Catch::Detail::clrReferenceToString(ref);
1345          }
1346      };
1347  #endif
1348      namespace Detail {
1349          template&lt;typename InputIterator, typename Sentinel = InputIterator&gt;
1350          std::string rangeToString(InputIterator first, Sentinel last) {
1351              ReusableStringStream rss;
1352              rss &lt;&lt; &quot;{ &quot;;
1353              if (first != last) {
1354                  rss &lt;&lt; ::Catch::Detail::stringify(*first);
1355                  for (++first; first != last; ++first)
1356                      rss &lt;&lt; &quot;, &quot; &lt;&lt; ::Catch::Detail::stringify(*first);
1357              }
1358              rss &lt;&lt; &quot; }&quot;;
1359              return rss.str();
1360          }
1361      }
1362  #ifdef __OBJC__
1363      template&lt;&gt;
1364      struct StringMaker&lt;NSString*&gt; {
1365          static std::string convert(NSString * nsstring) {
1366              if (!nsstring)
1367                  return &quot;nil&quot;;
1368              return std::string(&quot;@&quot;) + [nsstring UTF8String];
1369          }
1370      };
1371      template&lt;&gt;
1372      struct StringMaker&lt;NSObject*&gt; {
1373          static std::string convert(NSObject* nsObject) {
1374              return ::Catch::Detail::stringify([nsObject description]);
1375          }
1376      };
1377      namespace Detail {
1378          inline std::string stringify( NSString* nsstring ) {
1379              return StringMaker&lt;NSString*&gt;::convert( nsstring );
1380          }
1381      } 
1382  #endif 
1383  } 
1384  #if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
1385  #  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
1386  #  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
1387  #  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
1388  #  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
1389  #  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
1390  #endif
1391  #if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
1392  #include &lt;utility&gt;
1393  namespace Catch {
1394      template&lt;typename T1, typename T2&gt;
1395      struct StringMaker&lt;std::pair&lt;T1, T2&gt; &gt; {
1396          static std::string convert(const std::pair&lt;T1, T2&gt;&amp; pair) {
1397              ReusableStringStream rss;
1398              rss &lt;&lt; &quot;{ &quot;
1399                  &lt;&lt; ::Catch::Detail::stringify(pair.first)
1400                  &lt;&lt; &quot;, &quot;
1401                  &lt;&lt; ::Catch::Detail::stringify(pair.second)
1402                  &lt;&lt; &quot; }&quot;;
1403              return rss.str();
1404          }
1405      };
1406  }
1407  #endif 
1408  #if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) &amp;&amp; defined(CATCH_CONFIG_CPP17_OPTIONAL)
1409  #include &lt;optional&gt;
1410  namespace Catch {
1411      template&lt;typename T&gt;
1412      struct StringMaker&lt;std::optional&lt;T&gt; &gt; {
1413          static std::string convert(const std::optional&lt;T&gt;&amp; optional) {
1414              ReusableStringStream rss;
1415              if (optional.has_value()) {
1416                  rss &lt;&lt; ::Catch::Detail::stringify(*optional);
1417              } else {
1418                  rss &lt;&lt; &quot;{ }&quot;;
1419              }
1420              return rss.str();
1421          }
1422      };
1423  }
1424  #endif 
1425  #if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
1426  #include &lt;tuple&gt;
1427  namespace Catch {
1428      namespace Detail {
1429          template&lt;
1430              typename Tuple,
1431              std::size_t N = 0,
1432              bool = (N &lt; std::tuple_size&lt;Tuple&gt;::value)
1433              &gt;
1434              struct TupleElementPrinter {
1435              static void print(const Tuple&amp; tuple, std::ostream&amp; os) {
1436                  os &lt;&lt; (N ? &quot;, &quot; : &quot; &quot;)
1437                      &lt;&lt; ::Catch::Detail::stringify(std::get&lt;N&gt;(tuple));
1438                  TupleElementPrinter&lt;Tuple, N + 1&gt;::print(tuple, os);
1439              }
1440          };
1441          template&lt;
1442              typename Tuple,
1443              std::size_t N
1444          &gt;
1445              struct TupleElementPrinter&lt;Tuple, N, false&gt; {
1446              static void print(const Tuple&amp;, std::ostream&amp;) {}
1447          };
1448      }
1449      template&lt;typename ...Types&gt;
1450      struct StringMaker&lt;std::tuple&lt;Types...&gt;&gt; {
1451          static std::string convert(const std::tuple&lt;Types...&gt;&amp; tuple) {
1452              ReusableStringStream rss;
1453              rss &lt;&lt; &#x27;{&#x27;;
1454              Detail::TupleElementPrinter&lt;std::tuple&lt;Types...&gt;&gt;::print(tuple, rss.get());
1455              rss &lt;&lt; &quot; }&quot;;
1456              return rss.str();
1457          }
1458      };
1459  }
1460  #endif 
1461  #if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) &amp;&amp; defined(CATCH_CONFIG_CPP17_VARIANT)
1462  #include &lt;variant&gt;
1463  namespace Catch {
1464      template&lt;&gt;
1465      struct StringMaker&lt;std::monostate&gt; {
1466          static std::string convert(const std::monostate&amp;) {
1467              return &quot;{ }&quot;;
1468          }
1469      };
1470      template&lt;typename... Elements&gt;
1471      struct StringMaker&lt;std::variant&lt;Elements...&gt;&gt; {
1472          static std::string convert(const std::variant&lt;Elements...&gt;&amp; variant) {
1473              if (variant.valueless_by_exception()) {
1474                  return &quot;{valueless variant}&quot;;
1475              } else {
1476                  return std::visit(
1477                      [](const auto&amp; value) {
1478                          return ::Catch::Detail::stringify(value);
1479                      },
1480                      variant
1481                  );
1482              }
1483          }
1484      };
1485  }
1486  #endif 
1487  namespace Catch {
1488      using std::begin;
1489      using std::end;
1490      namespace detail {
1491          template &lt;typename...&gt;
1492          struct void_type {
1493              using type = void;
1494          };
1495          template &lt;typename T, typename = void&gt;
1496          struct is_range_impl : std::false_type {
1497          };
1498          template &lt;typename T&gt;
1499          struct is_range_impl&lt;T, typename void_type&lt;decltype(begin(std::declval&lt;T&gt;()))&gt;::type&gt; : std::true_type {
1500          };
1501      } 
1502      template &lt;typename T&gt;
1503      struct is_range : detail::is_range_impl&lt;T&gt; {
1504      };
1505  #if defined(_MANAGED) 
1506      template &lt;typename T&gt;
1507      struct is_range&lt;T^&gt; {
1508          static const bool value = false;
1509      };
1510  #endif
1511      template&lt;typename Range&gt;
1512      std::string rangeToString( Range const&amp; range ) {
1513          return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
1514      }
1515      template&lt;typename Allocator&gt;
1516      std::string rangeToString( std::vector&lt;bool, Allocator&gt; const&amp; v ) {
1517          ReusableStringStream rss;
1518          rss &lt;&lt; &quot;{ &quot;;
1519          bool first = true;
1520          for( bool b : v ) {
1521              if( first )
1522                  first = false;
1523              else
1524                  rss &lt;&lt; &quot;, &quot;;
1525              rss &lt;&lt; ::Catch::Detail::stringify( b );
1526          }
1527          rss &lt;&lt; &quot; }&quot;;
1528          return rss.str();
1529      }
1530      template&lt;typename R&gt;
1531      struct StringMaker&lt;R, typename std::enable_if&lt;is_range&lt;R&gt;::value &amp;&amp; !::Catch::Detail::IsStreamInsertable&lt;R&gt;::value&gt;::type&gt; {
1532          static std::string convert( R const&amp; range ) {
1533              return rangeToString( range );
1534          }
1535      };
1536      template &lt;typename T, int SZ&gt;
1537      struct StringMaker&lt;T[SZ]&gt; {
1538          static std::string convert(T const(&amp;arr)[SZ]) {
1539              return rangeToString(arr);
1540          }
1541      };
1542  } 
1543  #if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
1544  #include &lt;ctime&gt;
1545  #include &lt;ratio&gt;
1546  #include &lt;chrono&gt;
1547  namespace Catch {
1548  template &lt;class Ratio&gt;
1549  struct ratio_string {
1550      static std::string symbol();
1551  };
1552  template &lt;class Ratio&gt;
1553  std::string ratio_string&lt;Ratio&gt;::symbol() {
1554      Catch::ReusableStringStream rss;
1555      rss &lt;&lt; &#x27;[&#x27; &lt;&lt; Ratio::num &lt;&lt; &#x27;/&#x27;
1556          &lt;&lt; Ratio::den &lt;&lt; &#x27;]&#x27;;
1557      return rss.str();
1558  }
1559  template &lt;&gt;
1560  struct ratio_string&lt;std::atto&gt; {
1561      static std::string symbol();
1562  };
1563  template &lt;&gt;
1564  struct ratio_string&lt;std::femto&gt; {
1565      static std::string symbol();
1566  };
1567  template &lt;&gt;
1568  struct ratio_string&lt;std::pico&gt; {
1569      static std::string symbol();
1570  };
1571  template &lt;&gt;
1572  struct ratio_string&lt;std::nano&gt; {
1573      static std::string symbol();
1574  };
1575  template &lt;&gt;
1576  struct ratio_string&lt;std::micro&gt; {
1577      static std::string symbol();
1578  };
1579  template &lt;&gt;
1580  struct ratio_string&lt;std::milli&gt; {
1581      static std::string symbol();
1582  };
1583      template&lt;typename Value, typename Ratio&gt;
1584      struct StringMaker&lt;std::chrono::duration&lt;Value, Ratio&gt;&gt; {
1585          static std::string convert(std::chrono::duration&lt;Value, Ratio&gt; const&amp; duration) {
1586              ReusableStringStream rss;
1587              rss &lt;&lt; duration.count() &lt;&lt; &#x27; &#x27; &lt;&lt; ratio_string&lt;Ratio&gt;::symbol() &lt;&lt; &#x27;s&#x27;;
1588              return rss.str();
1589          }
1590      };
1591      template&lt;typename Value&gt;
1592      struct StringMaker&lt;std::chrono::duration&lt;Value, std::ratio&lt;1&gt;&gt;&gt; {
1593          static std::string convert(std::chrono::duration&lt;Value, std::ratio&lt;1&gt;&gt; const&amp; duration) {
1594              ReusableStringStream rss;
1595              rss &lt;&lt; duration.count() &lt;&lt; &quot; s&quot;;
1596              return rss.str();
1597          }
1598      };
1599      template&lt;typename Value&gt;
1600      struct StringMaker&lt;std::chrono::duration&lt;Value, std::ratio&lt;60&gt;&gt;&gt; {
1601          static std::string convert(std::chrono::duration&lt;Value, std::ratio&lt;60&gt;&gt; const&amp; duration) {
1602              ReusableStringStream rss;
1603              rss &lt;&lt; duration.count() &lt;&lt; &quot; m&quot;;
1604              return rss.str();
1605          }
1606      };
1607      template&lt;typename Value&gt;
1608      struct StringMaker&lt;std::chrono::duration&lt;Value, std::ratio&lt;3600&gt;&gt;&gt; {
1609          static std::string convert(std::chrono::duration&lt;Value, std::ratio&lt;3600&gt;&gt; const&amp; duration) {
1610              ReusableStringStream rss;
1611              rss &lt;&lt; duration.count() &lt;&lt; &quot; h&quot;;
1612              return rss.str();
1613          }
1614      };
1615      template&lt;typename Clock, typename Duration&gt;
1616      struct StringMaker&lt;std::chrono::time_point&lt;Clock, Duration&gt;&gt; {
1617          static std::string convert(std::chrono::time_point&lt;Clock, Duration&gt; const&amp; time_point) {
1618              return ::Catch::Detail::stringify(time_point.time_since_epoch()) + &quot; since epoch&quot;;
1619          }
1620      };
1621      template&lt;typename Duration&gt;
1622      struct StringMaker&lt;std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt;&gt; {
1623          static std::string convert(std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt; const&amp; time_point) {
1624              auto converted = std::chrono::system_clock::to_time_t(time_point);
1625  #ifdef _MSC_VER
1626              std::tm timeInfo = {};
1627              gmtime_s(&amp;timeInfo, &amp;converted);
1628  #else
1629              std::tm* timeInfo = std::gmtime(&amp;converted);
1630  #endif
1631              auto const timeStampSize = sizeof(&quot;2017-01-16T17:06:45Z&quot;);
1632              char timeStamp[timeStampSize];
1633              const char * const fmt = &quot;%Y-%m-%dT%H:%M:%SZ&quot;;
1634  #ifdef _MSC_VER
1635              std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
1636  #else
1637              std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
1638  #endif
1639              return std::string(timeStamp);
1640          }
1641      };
1642  }
1643  #endif 
1644  #define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \
1645  namespace Catch { \
1646      template&lt;&gt; struct StringMaker&lt;enumName&gt; { \
1647          static std::string convert( enumName value ) { \
1648              static const auto&amp; enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \
1649              return static_cast&lt;std::string&gt;(enumInfo.lookup( static_cast&lt;int&gt;( value ) )); \
1650          } \
1651      }; \
1652  }
1653  #define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )
1654  #ifdef _MSC_VER
1655  #pragma warning(pop)
1656  #endif
1657  #include &lt;iosfwd&gt;
1658  #ifdef _MSC_VER
1659  #pragma warning(push)
1660  #pragma warning(disable:4389) 
1661  #pragma warning(disable:4018) 
1662  #pragma warning(disable:4312) 
1663  #pragma warning(disable:4180) 
1664  #pragma warning(disable:4800) 
1665  #endif
1666  namespace Catch {
1667      struct ITransientExpression {
1668          auto isBinaryExpression() const -&gt; bool { return m_isBinaryExpression; }
1669          auto getResult() const -&gt; bool { return m_result; }
1670          virtual void streamReconstructedExpression( std::ostream &amp;os ) const = 0;
1671          ITransientExpression( bool isBinaryExpression, bool result )
1672          :   m_isBinaryExpression( isBinaryExpression ),
1673              m_result( result )
1674          {}
1675          virtual ~ITransientExpression();
1676          bool m_isBinaryExpression;
1677          bool m_result;
1678      };
1679      void formatReconstructedExpression( std::ostream &amp;os, std::string const&amp; lhs, StringRef op, std::string const&amp; rhs );
1680      template&lt;typename LhsT, typename RhsT&gt;
1681      class BinaryExpr  : public ITransientExpression {
1682          LhsT m_lhs;
1683          StringRef m_op;
1684          RhsT m_rhs;
1685          void streamReconstructedExpression( std::ostream &amp;os ) const override {
1686              formatReconstructedExpression
1687                      ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
1688          }
1689      public:
1690          BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
1691          :   ITransientExpression{ true, comparisonResult },
1692              m_lhs( lhs ),
1693              m_op( op ),
1694              m_rhs( rhs )
1695          {}
1696          template&lt;typename T&gt;
1697          auto operator &amp;&amp; ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1698              static_assert(always_false&lt;T&gt;::value,
1699              &quot;chained comparisons are not supported inside assertions, &quot;
1700              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1701          }
1702          template&lt;typename T&gt;
1703          auto operator || ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1704              static_assert(always_false&lt;T&gt;::value,
1705              &quot;chained comparisons are not supported inside assertions, &quot;
1706              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1707          }
1708          template&lt;typename T&gt;
1709          auto operator == ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1710              static_assert(always_false&lt;T&gt;::value,
1711              &quot;chained comparisons are not supported inside assertions, &quot;
1712              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1713          }
1714          template&lt;typename T&gt;
1715          auto operator != ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1716              static_assert(always_false&lt;T&gt;::value,
1717              &quot;chained comparisons are not supported inside assertions, &quot;
1718              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1719          }
1720          template&lt;typename T&gt;
1721          auto operator &gt; ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1722              static_assert(always_false&lt;T&gt;::value,
1723              &quot;chained comparisons are not supported inside assertions, &quot;
1724              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1725          }
1726          template&lt;typename T&gt;
1727          auto operator &lt; ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1728              static_assert(always_false&lt;T&gt;::value,
1729              &quot;chained comparisons are not supported inside assertions, &quot;
1730              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1731          }
1732          template&lt;typename T&gt;
1733          auto operator &gt;= ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1734              static_assert(always_false&lt;T&gt;::value,
1735              &quot;chained comparisons are not supported inside assertions, &quot;
1736              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1737          }
1738          template&lt;typename T&gt;
1739          auto operator &lt;= ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1740              static_assert(always_false&lt;T&gt;::value,
1741              &quot;chained comparisons are not supported inside assertions, &quot;
1742              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1743          }
1744      };
1745      template&lt;typename LhsT&gt;
1746      class UnaryExpr : public ITransientExpression {
1747          LhsT m_lhs;
1748          void streamReconstructedExpression( std::ostream &amp;os ) const override {
1749              os &lt;&lt; Catch::Detail::stringify( m_lhs );
1750          }
1751      public:
1752          explicit UnaryExpr( LhsT lhs )
1753          :   ITransientExpression{ false, static_cast&lt;bool&gt;(lhs) },
1754              m_lhs( lhs )
1755          {}
1756      };
1757      template&lt;typename LhsT, typename RhsT&gt;
1758      auto compareEqual( LhsT const&amp; lhs, RhsT const&amp; rhs ) -&gt; bool { return static_cast&lt;bool&gt;(lhs == rhs); }
1759      template&lt;typename T&gt;
1760      auto compareEqual( T* const&amp; lhs, int rhs ) -&gt; bool { return lhs == reinterpret_cast&lt;void const*&gt;( rhs ); }
1761      template&lt;typename T&gt;
1762      auto compareEqual( T* const&amp; lhs, long rhs ) -&gt; bool { return lhs == reinterpret_cast&lt;void const*&gt;( rhs ); }
1763      template&lt;typename T&gt;
1764      auto compareEqual( int lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) == rhs; }
1765      template&lt;typename T&gt;
1766      auto compareEqual( long lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) == rhs; }
1767      template&lt;typename LhsT, typename RhsT&gt;
1768      auto compareNotEqual( LhsT const&amp; lhs, RhsT&amp;&amp; rhs ) -&gt; bool { return static_cast&lt;bool&gt;(lhs != rhs); }
1769      template&lt;typename T&gt;
1770      auto compareNotEqual( T* const&amp; lhs, int rhs ) -&gt; bool { return lhs != reinterpret_cast&lt;void const*&gt;( rhs ); }
1771      template&lt;typename T&gt;
1772      auto compareNotEqual( T* const&amp; lhs, long rhs ) -&gt; bool { return lhs != reinterpret_cast&lt;void const*&gt;( rhs ); }
1773      template&lt;typename T&gt;
1774      auto compareNotEqual( int lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) != rhs; }
1775      template&lt;typename T&gt;
1776      auto compareNotEqual( long lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) != rhs; }
1777      template&lt;typename LhsT&gt;
1778      class ExprLhs {
1779          LhsT m_lhs;
1780      public:
1781          explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
1782          template&lt;typename RhsT&gt;
1783          auto operator == ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1784              return { compareEqual( m_lhs, rhs ), m_lhs, &quot;==&quot;, rhs };
1785          }
1786          auto operator == ( bool rhs ) -&gt; BinaryExpr&lt;LhsT, bool&gt; const {
1787              return { m_lhs == rhs, m_lhs, &quot;==&quot;, rhs };
1788          }
1789          template&lt;typename RhsT&gt;
1790          auto operator != ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1791              return { compareNotEqual( m_lhs, rhs ), m_lhs, &quot;!=&quot;, rhs };
1792          }
1793          auto operator != ( bool rhs ) -&gt; BinaryExpr&lt;LhsT, bool&gt; const {
1794              return { m_lhs != rhs, m_lhs, &quot;!=&quot;, rhs };
1795          }
1796          template&lt;typename RhsT&gt;
1797          auto operator &gt; ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1798              return { static_cast&lt;bool&gt;(m_lhs &gt; rhs), m_lhs, &quot;&gt;&quot;, rhs };
1799          }
1800          template&lt;typename RhsT&gt;
1801          auto operator &lt; ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1802              return { static_cast&lt;bool&gt;(m_lhs &lt; rhs), m_lhs, &quot;&lt;&quot;, rhs };
1803          }
1804          template&lt;typename RhsT&gt;
1805          auto operator &gt;= ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1806              return { static_cast&lt;bool&gt;(m_lhs &gt;= rhs), m_lhs, &quot;&gt;=&quot;, rhs };
1807          }
1808          template&lt;typename RhsT&gt;
1809          auto operator &lt;= ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1810              return { static_cast&lt;bool&gt;(m_lhs &lt;= rhs), m_lhs, &quot;&lt;=&quot;, rhs };
1811          }
1812          template &lt;typename RhsT&gt;
1813          auto operator | (RhsT const&amp; rhs) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1814              return { static_cast&lt;bool&gt;(m_lhs | rhs), m_lhs, &quot;|&quot;, rhs };
1815          }
1816          template &lt;typename RhsT&gt;
1817          auto operator &amp; (RhsT const&amp; rhs) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1818              return { static_cast&lt;bool&gt;(m_lhs &amp; rhs), m_lhs, &quot;&amp;&quot;, rhs };
1819          }
1820          template &lt;typename RhsT&gt;
1821          auto operator ^ (RhsT const&amp; rhs) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1822              return { static_cast&lt;bool&gt;(m_lhs ^ rhs), m_lhs, &quot;^&quot;, rhs };
1823          }
1824          template&lt;typename RhsT&gt;
1825          auto operator &amp;&amp; ( RhsT const&amp; ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1826              static_assert(always_false&lt;RhsT&gt;::value,
1827              &quot;operator&amp;&amp; is not supported inside assertions, &quot;
1828              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1829          }
1830          template&lt;typename RhsT&gt;
1831          auto operator || ( RhsT const&amp; ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1832              static_assert(always_false&lt;RhsT&gt;::value,
1833              &quot;operator|| is not supported inside assertions, &quot;
1834              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1835          }
1836          auto makeUnaryExpr() const -&gt; UnaryExpr&lt;LhsT&gt; {
1837              return UnaryExpr&lt;LhsT&gt;{ m_lhs };
1838          }
1839      };
1840      void handleExpression( ITransientExpression const&amp; expr );
1841      template&lt;typename T&gt;
1842      void handleExpression( ExprLhs&lt;T&gt; const&amp; expr ) {
1843          handleExpression( expr.makeUnaryExpr() );
1844      }
1845      struct Decomposer {
1846          template&lt;typename T&gt;
1847          auto operator &lt;= ( T const&amp; lhs ) -&gt; ExprLhs&lt;T const&amp;&gt; {
1848              return ExprLhs&lt;T const&amp;&gt;{ lhs };
1849          }
1850          auto operator &lt;=( bool value ) -&gt; ExprLhs&lt;bool&gt; {
1851              return ExprLhs&lt;bool&gt;{ value };
1852          }
1853      };
1854  } 
1855  #ifdef _MSC_VER
1856  #pragma warning(pop)
1857  #endif
1858  #include &lt;string&gt;
1859  #include &lt;chrono&gt;
1860  namespace Catch {
1861      class AssertionResult;
1862      struct AssertionInfo;
1863      struct SectionInfo;
1864      struct SectionEndInfo;
1865      struct MessageInfo;
1866      struct MessageBuilder;
1867      struct Counts;
1868      struct AssertionReaction;
1869      struct SourceLineInfo;
1870      struct ITransientExpression;
1871      struct IGeneratorTracker;
1872  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
1873      struct BenchmarkInfo;
1874      template &lt;typename Duration = std::chrono::duration&lt;double, std::nano&gt;&gt;
1875      struct BenchmarkStats;
1876  #endif 
1877      struct IResultCapture {
1878          virtual ~IResultCapture();
1879          virtual bool sectionStarted(    SectionInfo const&amp; sectionInfo,
1880                                          Counts&amp; assertions ) = 0;
1881          virtual void sectionEnded( SectionEndInfo const&amp; endInfo ) = 0;
1882          virtual void sectionEndedEarly( SectionEndInfo const&amp; endInfo ) = 0;
1883          virtual auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; = 0;
1884  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
1885          virtual void benchmarkPreparing( std::string const&amp; name ) = 0;
1886          virtual void benchmarkStarting( BenchmarkInfo const&amp; info ) = 0;
1887          virtual void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) = 0;
1888          virtual void benchmarkFailed( std::string const&amp; error ) = 0;
1889  #endif 
1890          virtual void pushScopedMessage( MessageInfo const&amp; message ) = 0;
1891          virtual void popScopedMessage( MessageInfo const&amp; message ) = 0;
1892          virtual void emplaceUnscopedMessage( MessageBuilder const&amp; builder ) = 0;
1893          virtual void handleFatalErrorCondition( StringRef message ) = 0;
1894          virtual void handleExpr
1895                  (   AssertionInfo const&amp; info,
1896                      ITransientExpression const&amp; expr,
1897                      AssertionReaction&amp; reaction ) = 0;
1898          virtual void handleMessage
1899                  (   AssertionInfo const&amp; info,
1900                      ResultWas::OfType resultType,
1901                      StringRef const&amp; message,
1902                      AssertionReaction&amp; reaction ) = 0;
1903          virtual void handleUnexpectedExceptionNotThrown
1904                  (   AssertionInfo const&amp; info,
1905                      AssertionReaction&amp; reaction ) = 0;
1906          virtual void handleUnexpectedInflightException
1907                  (   AssertionInfo const&amp; info,
1908                      std::string const&amp; message,
1909                      AssertionReaction&amp; reaction ) = 0;
1910          virtual void handleIncomplete
1911                  (   AssertionInfo const&amp; info ) = 0;
1912          virtual void handleNonExpr
1913                  (   AssertionInfo const &amp;info,
1914                      ResultWas::OfType resultType,
1915                      AssertionReaction &amp;reaction ) = 0;
1916          virtual bool lastAssertionPassed() = 0;
1917          virtual void assertionPassed() = 0;
1918          virtual std::string getCurrentTestName() const = 0;
1919          virtual const AssertionResult* getLastResult() const = 0;
1920          virtual void exceptionEarlyReported() = 0;
1921      };
1922      IResultCapture&amp; getResultCapture();
1923  }
1924  namespace Catch {
1925      struct TestFailureException{};
1926      struct AssertionResultData;
1927      struct IResultCapture;
1928      class RunContext;
1929      class LazyExpression {
1930          friend class AssertionHandler;
1931          friend struct AssertionStats;
1932          friend class RunContext;
1933          ITransientExpression const* m_transientExpression = nullptr;
1934          bool m_isNegated;
1935      public:
1936          LazyExpression( bool isNegated );
1937          LazyExpression( LazyExpression const&amp; other );
1938          LazyExpression&amp; operator = ( LazyExpression const&amp; ) = delete;
1939          explicit operator bool() const;
1940          friend auto operator &lt;&lt; ( std::ostream&amp; os, LazyExpression const&amp; lazyExpr ) -&gt; std::ostream&amp;;
1941      };
1942      struct AssertionReaction {
1943          bool shouldDebugBreak = false;
1944          bool shouldThrow = false;
1945      };
1946      class AssertionHandler {
1947          AssertionInfo m_assertionInfo;
1948          AssertionReaction m_reaction;
1949          bool m_completed = false;
1950          IResultCapture&amp; m_resultCapture;
1951      public:
1952          AssertionHandler
1953              (   StringRef const&amp; macroName,
1954                  SourceLineInfo const&amp; lineInfo,
1955                  StringRef capturedExpression,
1956                  ResultDisposition::Flags resultDisposition );
1957          ~AssertionHandler() {
1958              if ( !m_completed ) {
1959                  m_resultCapture.handleIncomplete( m_assertionInfo );
1960              }
1961          }
1962          template&lt;typename T&gt;
1963          void handleExpr( ExprLhs&lt;T&gt; const&amp; expr ) {
1964              handleExpr( expr.makeUnaryExpr() );
1965          }
1966          void handleExpr( ITransientExpression const&amp; expr );
1967          void handleMessage(ResultWas::OfType resultType, StringRef const&amp; message);
1968          void handleExceptionThrownAsExpected();
1969          void handleUnexpectedExceptionNotThrown();
1970          void handleExceptionNotThrownAsExpected();
1971          void handleThrowingCallSkipped();
1972          void handleUnexpectedInflightException();
1973          void complete();
1974          void setCompleted();
1975          auto allowThrows() const -&gt; bool;
1976      };
1977      void handleExceptionMatchExpr( AssertionHandler&amp; handler, std::string const&amp; str, StringRef const&amp; matcherString );
1978  } 
1979  #include &lt;string&gt;
1980  #include &lt;vector&gt;
1981  namespace Catch {
1982      struct MessageInfo {
1983          MessageInfo(    StringRef const&amp; _macroName,
1984                          SourceLineInfo const&amp; _lineInfo,
1985                          ResultWas::OfType _type );
1986          StringRef macroName;
1987          std::string message;
1988          SourceLineInfo lineInfo;
1989          ResultWas::OfType type;
1990          unsigned int sequence;
1991          bool operator == ( MessageInfo const&amp; other ) const;
1992          bool operator &lt; ( MessageInfo const&amp; other ) const;
1993      private:
1994          static unsigned int globalCount;
1995      };
1996      struct MessageStream {
1997          template&lt;typename T&gt;
1998          MessageStream&amp; operator &lt;&lt; ( T const&amp; value ) {
1999              m_stream &lt;&lt; value;
2000              return *this;
2001          }
2002          ReusableStringStream m_stream;
2003      };
2004      struct MessageBuilder : MessageStream {
2005          MessageBuilder( StringRef const&amp; macroName,
2006                          SourceLineInfo const&amp; lineInfo,
2007                          ResultWas::OfType type );
2008          template&lt;typename T&gt;
2009          MessageBuilder&amp; operator &lt;&lt; ( T const&amp; value ) {
2010              m_stream &lt;&lt; value;
2011              return *this;
2012          }
2013          MessageInfo m_info;
2014      };
2015      class ScopedMessage {
2016      public:
2017          explicit ScopedMessage( MessageBuilder const&amp; builder );
2018          ScopedMessage( ScopedMessage&amp; duplicate ) = delete;
2019          ScopedMessage( ScopedMessage&amp;&amp; old );
2020          ~ScopedMessage();
2021          MessageInfo m_info;
2022          bool m_moved;
2023      };
2024      class Capturer {
2025          std::vector&lt;MessageInfo&gt; m_messages;
2026          IResultCapture&amp; m_resultCapture = getResultCapture();
2027          size_t m_captured = 0;
2028      public:
2029          Capturer( StringRef macroName, SourceLineInfo const&amp; lineInfo, ResultWas::OfType resultType, StringRef names );
2030          ~Capturer();
2031          void captureValue( size_t index, std::string const&amp; value );
2032          template&lt;typename T&gt;
2033          void captureValues( size_t index, T const&amp; value ) {
2034              captureValue( index, Catch::Detail::stringify( value ) );
2035          }
2036          template&lt;typename T, typename... Ts&gt;
2037          void captureValues( size_t index, T const&amp; value, Ts const&amp;... values ) {
2038              captureValue( index, Catch::Detail::stringify(value) );
2039              captureValues( index+1, values... );
2040          }
2041      };
2042  } 
2043  #if !defined(CATCH_CONFIG_DISABLE)
2044  #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
2045    #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
2046  #else
2047    #define CATCH_INTERNAL_STRINGIFY(...) &quot;Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION&quot;
2048  #endif
2049  #if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2050  #define INTERNAL_CATCH_TRY
2051  #define INTERNAL_CATCH_CATCH( capturer )
2052  #else 
2053  #define INTERNAL_CATCH_TRY try
2054  #define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }
2055  #endif
2056  #define INTERNAL_CATCH_REACT( handler ) handler.complete();
2057  #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
2058      do { \
2059          CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \
2060          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
2061          INTERNAL_CATCH_TRY { \
2062              CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2063              CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
2064              catchAssertionHandler.handleExpr( Catch::Decomposer() &lt;= __VA_ARGS__ ); \
2065              CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
2066          } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
2067          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2068      } while( (void)0, (false) &amp;&amp; static_cast&lt;bool&gt;( !!(__VA_ARGS__) ) )
2069  #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
2070      INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
2071      if( Catch::getResultCapture().lastAssertionPassed() )
2072  #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
2073      INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
2074      if( !Catch::getResultCapture().lastAssertionPassed() )
2075  #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
2076      do { \
2077          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
2078          try { \
2079              static_cast&lt;void&gt;(__VA_ARGS__); \
2080              catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
2081          } \
2082          catch( ... ) { \
2083              catchAssertionHandler.handleUnexpectedInflightException(); \
2084          } \
2085          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2086      } while( false )
2087  #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
2088      do { \
2089          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
2090          if( catchAssertionHandler.allowThrows() ) \
2091              try { \
2092                  static_cast&lt;void&gt;(__VA_ARGS__); \
2093                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2094              } \
2095              catch( ... ) { \
2096                  catchAssertionHandler.handleExceptionThrownAsExpected(); \
2097              } \
2098          else \
2099              catchAssertionHandler.handleThrowingCallSkipped(); \
2100          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2101      } while( false )
2102  #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
2103      do { \
2104          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
2105          if( catchAssertionHandler.allowThrows() ) \
2106              try { \
2107                  static_cast&lt;void&gt;(expr); \
2108                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2109              } \
2110              catch( exceptionType const&amp; ) { \
2111                  catchAssertionHandler.handleExceptionThrownAsExpected(); \
2112              } \
2113              catch( ... ) { \
2114                  catchAssertionHandler.handleUnexpectedInflightException(); \
2115              } \
2116          else \
2117              catchAssertionHandler.handleThrowingCallSkipped(); \
2118          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2119      } while( false )
2120  #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
2121      do { \
2122          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
2123          catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() &lt;&lt; __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
2124          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2125      } while( false )
2126  #define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
2127      auto varName = Catch::Capturer( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \
2128      varName.captureValues( 0, __VA_ARGS__ )
2129  #define INTERNAL_CATCH_INFO( macroName, log ) \
2130      Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) &lt;&lt; log );
2131  #define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \
2132      Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) &lt;&lt; log )
2133  #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
2134      do { \
2135          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2136          if( catchAssertionHandler.allowThrows() ) \
2137              try { \
2138                  static_cast&lt;void&gt;(__VA_ARGS__); \
2139                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2140              } \
2141              catch( ... ) { \
2142                  Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \
2143              } \
2144          else \
2145              catchAssertionHandler.handleThrowingCallSkipped(); \
2146          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2147      } while( false )
2148  #endif 
2149  #include &lt;cstddef&gt;
2150  namespace Catch {
2151      struct Counts {
2152          Counts operator - ( Counts const&amp; other ) const;
2153          Counts&amp; operator += ( Counts const&amp; other );
2154          std::size_t total() const;
2155          bool allPassed() const;
2156          bool allOk() const;
2157          std::size_t passed = 0;
2158          std::size_t failed = 0;
2159          std::size_t failedButOk = 0;
2160      };
2161      struct Totals {
2162          Totals operator - ( Totals const&amp; other ) const;
2163          Totals&amp; operator += ( Totals const&amp; other );
2164          Totals delta( Totals const&amp; prevTotals ) const;
2165          int error = 0;
2166          Counts assertions;
2167          Counts testCases;
2168      };
2169  }
2170  #include &lt;string&gt;
2171  namespace Catch {
2172      struct SectionInfo {
2173          SectionInfo
2174              (   SourceLineInfo const&amp; _lineInfo,
2175                  std::string const&amp; _name );
2176          SectionInfo
2177              (   SourceLineInfo const&amp; _lineInfo,
2178                  std::string const&amp; _name,
2179                  std::string const&amp; ) : SectionInfo( _lineInfo, _name ) {}
2180          std::string name;
2181          std::string description; 
2182          SourceLineInfo lineInfo;
2183      };
2184      struct SectionEndInfo {
2185          SectionInfo sectionInfo;
2186          Counts prevAssertions;
2187          double durationInSeconds;
2188      };
2189  } 
2190  #include &lt;cstdint&gt;
2191  namespace Catch {
2192      auto getCurrentNanosecondsSinceEpoch() -&gt; uint64_t;
2193      auto getEstimatedClockResolution() -&gt; uint64_t;
2194      class Timer {
2195          uint64_t m_nanoseconds = 0;
2196      public:
2197          void start();
2198          auto getElapsedNanoseconds() const -&gt; uint64_t;
2199          auto getElapsedMicroseconds() const -&gt; uint64_t;
2200          auto getElapsedMilliseconds() const -&gt; unsigned int;
2201          auto getElapsedSeconds() const -&gt; double;
2202      };
2203  } 
2204  #include &lt;string&gt;
2205  namespace Catch {
2206      class Section : NonCopyable {
2207      public:
2208          Section( SectionInfo const&amp; info );
2209          ~Section();
2210          explicit operator bool() const;
2211      private:
2212          SectionInfo m_info;
2213          std::string m_name;
2214          Counts m_assertions;
2215          bool m_sectionIncluded;
2216          Timer m_timer;
2217      };
2218  } 
2219  #define INTERNAL_CATCH_SECTION( ... ) \
2220      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2221      CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
2222      if( Catch::Section const&amp; INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
2223      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
2224  #define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \
2225      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2226      CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
2227      if( Catch::Section const&amp; INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str() ) ) \
2228      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
2229  #include &lt;string&gt;
2230  #include &lt;memory&gt;
2231  namespace Catch {
2232      class TestCase;
2233      struct ITestCaseRegistry;
2234      struct IExceptionTranslatorRegistry;
2235      struct IExceptionTranslator;
2236      struct IReporterRegistry;
2237      struct IReporterFactory;
2238      struct ITagAliasRegistry;
2239      struct IMutableEnumValuesRegistry;
2240      class StartupExceptionRegistry;
2241      using IReporterFactoryPtr = std::shared_ptr&lt;IReporterFactory&gt;;
2242      struct IRegistryHub {
2243          virtual ~IRegistryHub();
2244          virtual IReporterRegistry const&amp; getReporterRegistry() const = 0;
2245          virtual ITestCaseRegistry const&amp; getTestCaseRegistry() const = 0;
2246          virtual ITagAliasRegistry const&amp; getTagAliasRegistry() const = 0;
2247          virtual IExceptionTranslatorRegistry const&amp; getExceptionTranslatorRegistry() const = 0;
2248          virtual StartupExceptionRegistry const&amp; getStartupExceptionRegistry() const = 0;
2249      };
2250      struct IMutableRegistryHub {
2251          virtual ~IMutableRegistryHub();
2252          virtual void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) = 0;
2253          virtual void registerListener( IReporterFactoryPtr const&amp; factory ) = 0;
2254          virtual void registerTest( TestCase const&amp; testInfo ) = 0;
2255          virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
2256          virtual void registerTagAlias( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) = 0;
2257          virtual void registerStartupException() noexcept = 0;
2258          virtual IMutableEnumValuesRegistry&amp; getMutableEnumValuesRegistry() = 0;
2259      };
2260      IRegistryHub const&amp; getRegistryHub();
2261      IMutableRegistryHub&amp; getMutableRegistryHub();
2262      void cleanUp();
2263      std::string translateActiveException();
2264  }
2265  #if defined(CATCH_CONFIG_DISABLE)
2266      #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
2267          static std::string translatorName( signature )
2268  #endif
2269  #include &lt;exception&gt;
2270  #include &lt;string&gt;
2271  #include &lt;vector&gt;
2272  namespace Catch {
2273      using exceptionTranslateFunction = std::string(*)();
2274      struct IExceptionTranslator;
2275      using ExceptionTranslators = std::vector&lt;std::unique_ptr&lt;IExceptionTranslator const&gt;&gt;;
2276      struct IExceptionTranslator {
2277          virtual ~IExceptionTranslator();
2278          virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
2279      };
2280      struct IExceptionTranslatorRegistry {
2281          virtual ~IExceptionTranslatorRegistry();
2282          virtual std::string translateActiveException() const = 0;
2283      };
2284      class ExceptionTranslatorRegistrar {
2285          template&lt;typename T&gt;
2286          class ExceptionTranslator : public IExceptionTranslator {
2287          public:
2288              ExceptionTranslator( std::string(*translateFunction)( T&amp; ) )
2289              : m_translateFunction( translateFunction )
2290              {}
2291              std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
2292  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2293                  return &quot;&quot;;
2294  #else
2295                  try {
2296                      if( it == itEnd )
2297                          std::rethrow_exception(std::current_exception());
2298                      else
2299                          return (*it)-&gt;translate( it+1, itEnd );
2300                  }
2301                  catch( T&amp; ex ) {
2302                      return m_translateFunction( ex );
2303                  }
2304  #endif
2305              }
2306          protected:
2307              std::string(*m_translateFunction)( T&amp; );
2308          };
2309      public:
2310          template&lt;typename T&gt;
2311          ExceptionTranslatorRegistrar( std::string(*translateFunction)( T&amp; ) ) {
2312              getMutableRegistryHub().registerTranslator
2313                  ( new ExceptionTranslator&lt;T&gt;( translateFunction ) );
2314          }
2315      };
2316  }
2317  #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
2318      static std::string translatorName( signature ); \
2319      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2320      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
2321      namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &amp;translatorName ); } \
2322      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
2323      static std::string translatorName( signature )
2324  #define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
2325  #include &lt;type_traits&gt;
2326  namespace Catch {
2327  namespace Detail {
2328      class Approx {
2329      private:
2330          bool equalityComparisonImpl(double other) const;
2331          void setMargin(double margin);
2332          void setEpsilon(double epsilon);
2333      public:
2334          explicit Approx ( double value );
2335          static Approx custom();
2336          Approx operator-() const;
2337          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2338          Approx operator()( T const&amp; value ) {
2339              Approx approx( static_cast&lt;double&gt;(value) );
2340              approx.m_epsilon = m_epsilon;
2341              approx.m_margin = m_margin;
2342              approx.m_scale = m_scale;
2343              return approx;
2344          }
2345          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2346          explicit Approx( T const&amp; value ): Approx(static_cast&lt;double&gt;(value))
2347          {}
2348          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2349          friend bool operator == ( const T&amp; lhs, Approx const&amp; rhs ) {
2350              auto lhs_v = static_cast&lt;double&gt;(lhs);
2351              return rhs.equalityComparisonImpl(lhs_v);
2352          }
2353          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2354          friend bool operator == ( Approx const&amp; lhs, const T&amp; rhs ) {
2355              return operator==( rhs, lhs );
2356          }
2357          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2358          friend bool operator != ( T const&amp; lhs, Approx const&amp; rhs ) {
2359              return !operator==( lhs, rhs );
2360          }
2361          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2362          friend bool operator != ( Approx const&amp; lhs, T const&amp; rhs ) {
2363              return !operator==( rhs, lhs );
2364          }
2365          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2366          friend bool operator &lt;= ( T const&amp; lhs, Approx const&amp; rhs ) {
2367              return static_cast&lt;double&gt;(lhs) &lt; rhs.m_value || lhs == rhs;
2368          }
2369          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2370          friend bool operator &lt;= ( Approx const&amp; lhs, T const&amp; rhs ) {
2371              return lhs.m_value &lt; static_cast&lt;double&gt;(rhs) || lhs == rhs;
2372          }
2373          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2374          friend bool operator &gt;= ( T const&amp; lhs, Approx const&amp; rhs ) {
2375              return static_cast&lt;double&gt;(lhs) &gt; rhs.m_value || lhs == rhs;
2376          }
2377          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2378          friend bool operator &gt;= ( Approx const&amp; lhs, T const&amp; rhs ) {
2379              return lhs.m_value &gt; static_cast&lt;double&gt;(rhs) || lhs == rhs;
2380          }
2381          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2382          Approx&amp; epsilon( T const&amp; newEpsilon ) {
2383              double epsilonAsDouble = static_cast&lt;double&gt;(newEpsilon);
2384              setEpsilon(epsilonAsDouble);
2385              return *this;
2386          }
2387          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2388          Approx&amp; margin( T const&amp; newMargin ) {
2389              double marginAsDouble = static_cast&lt;double&gt;(newMargin);
2390              setMargin(marginAsDouble);
2391              return *this;
2392          }
2393          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2394          Approx&amp; scale( T const&amp; newScale ) {
2395              m_scale = static_cast&lt;double&gt;(newScale);
2396              return *this;
2397          }
2398          std::string toString() const;
2399      private:
2400          double m_epsilon;
2401          double m_margin;
2402          double m_scale;
2403          double m_value;
2404      };
2405  } 
2406  namespace literals {
2407      Detail::Approx operator &quot;&quot; _a(long double val);
2408      Detail::Approx operator &quot;&quot; _a(unsigned long long val);
2409  } 
2410  template&lt;&gt;
2411  struct StringMaker&lt;Catch::Detail::Approx&gt; {
2412      static std::string convert(Catch::Detail::Approx const&amp; value);
2413  };
2414  } 
2415  #include &lt;string&gt;
2416  #include &lt;iosfwd&gt;
2417  #include &lt;vector&gt;
2418  namespace Catch {
2419      bool startsWith( std::string const&amp; s, std::string const&amp; prefix );
2420      bool startsWith( std::string const&amp; s, char prefix );
2421      bool endsWith( std::string const&amp; s, std::string const&amp; suffix );
2422      bool endsWith( std::string const&amp; s, char suffix );
2423      bool contains( std::string const&amp; s, std::string const&amp; infix );
2424      void toLowerInPlace( std::string&amp; s );
2425      std::string toLower( std::string const&amp; s );
2426      std::string trim( std::string const&amp; str );
2427      StringRef trim(StringRef ref);
2428      std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter );
2429      bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis );
2430      struct pluralise {
2431          pluralise( std::size_t count, std::string const&amp; label );
2432          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser );
2433          std::size_t m_count;
2434          std::string m_label;
2435      };
2436  }
2437  #ifndef CATCH_CONFIG_DISABLE_MATCHERS
2438  #include &lt;string&gt;
2439  #include &lt;vector&gt;
2440  namespace Catch {
2441  namespace Matchers {
2442      namespace Impl {
2443          template&lt;typename ArgT&gt; struct MatchAllOf;
2444          template&lt;typename ArgT&gt; struct MatchAnyOf;
2445          template&lt;typename ArgT&gt; struct MatchNotOf;
2446          class MatcherUntypedBase {
2447          public:
2448              MatcherUntypedBase() = default;
2449              MatcherUntypedBase ( MatcherUntypedBase const&amp; ) = default;
2450              MatcherUntypedBase&amp; operator = ( MatcherUntypedBase const&amp; ) = delete;
2451              std::string toString() const;
2452          protected:
2453              virtual ~MatcherUntypedBase();
2454              virtual std::string describe() const = 0;
2455              mutable std::string m_cachedToString;
2456          };
2457  #ifdef __clang__
2458  #    pragma clang diagnostic push
2459  #    pragma clang diagnostic ignored &quot;-Wnon-virtual-dtor&quot;
2460  #endif
2461          template&lt;typename ObjectT&gt;
2462          struct MatcherMethod {
2463              virtual bool match( ObjectT const&amp; arg ) const = 0;
2464          };
2465  #if defined(__OBJC__)
2466          template&lt;&gt;
2467          struct MatcherMethod&lt;NSString*&gt; {
2468              virtual bool match( NSString* arg ) const = 0;
2469          };
2470  #endif
2471  #ifdef __clang__
2472  #    pragma clang diagnostic pop
2473  #endif
2474          template&lt;typename T&gt;
2475          struct MatcherBase : MatcherUntypedBase, MatcherMethod&lt;T&gt; {
2476              MatchAllOf&lt;T&gt; operator &amp;&amp; ( MatcherBase const&amp; other ) const;
2477              MatchAnyOf&lt;T&gt; operator || ( MatcherBase const&amp; other ) const;
2478              MatchNotOf&lt;T&gt; operator ! () const;
2479          };
2480          template&lt;typename ArgT&gt;
2481          struct MatchAllOf : MatcherBase&lt;ArgT&gt; {
2482              bool match( ArgT const&amp; arg ) const override {
2483                  for( auto matcher : m_matchers ) {
2484                      if (!matcher-&gt;match(arg))
2485                          return false;
2486                  }
2487                  return true;
2488              }
2489              std::string describe() const override {
2490                  std::string description;
2491                  description.reserve( 4 + m_matchers.size()*32 );
2492                  description += &quot;( &quot;;
2493                  bool first = true;
2494                  for( auto matcher : m_matchers ) {
2495                      if( first )
2496                          first = false;
2497                      else
2498                          description += &quot; and &quot;;
2499                      description += matcher-&gt;toString();
2500                  }
2501                  description += &quot; )&quot;;
2502                  return description;
2503              }
2504              MatchAllOf&lt;ArgT&gt; operator &amp;&amp; ( MatcherBase&lt;ArgT&gt; const&amp; other ) {
2505                  auto copy(*this);
2506                  copy.m_matchers.push_back( &amp;other );
2507                  return copy;
2508              }
2509              std::vector&lt;MatcherBase&lt;ArgT&gt; const*&gt; m_matchers;
2510          };
2511          template&lt;typename ArgT&gt;
2512          struct MatchAnyOf : MatcherBase&lt;ArgT&gt; {
2513              bool match( ArgT const&amp; arg ) const override {
2514                  for( auto matcher : m_matchers ) {
2515                      if (matcher-&gt;match(arg))
2516                          return true;
2517                  }
2518                  return false;
2519              }
2520              std::string describe() const override {
2521                  std::string description;
2522                  description.reserve( 4 + m_matchers.size()*32 );
2523                  description += &quot;( &quot;;
2524                  bool first = true;
2525                  for( auto matcher : m_matchers ) {
2526                      if( first )
2527                          first = false;
2528                      else
2529                          description += &quot; or &quot;;
2530                      description += matcher-&gt;toString();
2531                  }
2532                  description += &quot; )&quot;;
2533                  return description;
2534              }
2535              MatchAnyOf&lt;ArgT&gt; operator || ( MatcherBase&lt;ArgT&gt; const&amp; other ) {
2536                  auto copy(*this);
2537                  copy.m_matchers.push_back( &amp;other );
2538                  return copy;
2539              }
2540              std::vector&lt;MatcherBase&lt;ArgT&gt; const*&gt; m_matchers;
2541          };
2542          template&lt;typename ArgT&gt;
2543          struct MatchNotOf : MatcherBase&lt;ArgT&gt; {
2544              MatchNotOf( MatcherBase&lt;ArgT&gt; const&amp; underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
2545              bool match( ArgT const&amp; arg ) const override {
2546                  return !m_underlyingMatcher.match( arg );
2547              }
2548              std::string describe() const override {
2549                  return &quot;not &quot; + m_underlyingMatcher.toString();
2550              }
2551              MatcherBase&lt;ArgT&gt; const&amp; m_underlyingMatcher;
2552          };
2553          template&lt;typename T&gt;
2554          MatchAllOf&lt;T&gt; MatcherBase&lt;T&gt;::operator &amp;&amp; ( MatcherBase const&amp; other ) const {
2555              return MatchAllOf&lt;T&gt;() &amp;&amp; *this &amp;&amp; other;
2556          }
2557          template&lt;typename T&gt;
2558          MatchAnyOf&lt;T&gt; MatcherBase&lt;T&gt;::operator || ( MatcherBase const&amp; other ) const {
2559              return MatchAnyOf&lt;T&gt;() || *this || other;
2560          }
2561          template&lt;typename T&gt;
2562          MatchNotOf&lt;T&gt; MatcherBase&lt;T&gt;::operator ! () const {
2563              return MatchNotOf&lt;T&gt;( *this );
2564          }
2565      } 
2566  } 
2567  using namespace Matchers;
2568  using Matchers::Impl::MatcherBase;
2569  } 
2570  namespace Catch {
2571  namespace Matchers {
2572  namespace Exception {
2573  class ExceptionMessageMatcher : public MatcherBase&lt;std::exception&gt; {
2574      std::string m_message;
2575  public:
2576      ExceptionMessageMatcher(std::string const&amp; message):
2577          m_message(message)
2578      {}
2579      bool match(std::exception const&amp; ex) const override;
2580      std::string describe() const override;
2581  };
2582  } 
2583  Exception::ExceptionMessageMatcher Message(std::string const&amp; message);
2584  } 
2585  } 
2586  namespace Catch {
2587  namespace Matchers {
2588      namespace Floating {
2589          enum class FloatingPointKind : uint8_t;
2590          struct WithinAbsMatcher : MatcherBase&lt;double&gt; {
2591              WithinAbsMatcher(double target, double margin);
2592              bool match(double const&amp; matchee) const override;
2593              std::string describe() const override;
2594          private:
2595              double m_target;
2596              double m_margin;
2597          };
2598          struct WithinUlpsMatcher : MatcherBase&lt;double&gt; {
2599              WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType);
2600              bool match(double const&amp; matchee) const override;
2601              std::string describe() const override;
2602          private:
2603              double m_target;
2604              uint64_t m_ulps;
2605              FloatingPointKind m_type;
2606          };
2607          struct WithinRelMatcher : MatcherBase&lt;double&gt; {
2608              WithinRelMatcher(double target, double epsilon);
2609              bool match(double const&amp; matchee) const override;
2610              std::string describe() const override;
2611          private:
2612              double m_target;
2613              double m_epsilon;
2614          };
2615      } 
2616      Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
2617      Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
2618      Floating::WithinAbsMatcher WithinAbs(double target, double margin);
2619      Floating::WithinRelMatcher WithinRel(double target, double eps);
2620      Floating::WithinRelMatcher WithinRel(double target);
2621      Floating::WithinRelMatcher WithinRel(float target, float eps);
2622      Floating::WithinRelMatcher WithinRel(float target);
2623  } 
2624  } 
2625  #include &lt;functional&gt;
2626  #include &lt;string&gt;
2627  namespace Catch {
2628  namespace Matchers {
2629  namespace Generic {
2630  namespace Detail {
2631      std::string finalizeDescription(const std::string&amp; desc);
2632  }
2633  template &lt;typename T&gt;
2634  class PredicateMatcher : public MatcherBase&lt;T&gt; {
2635      std::function&lt;bool(T const&amp;)&gt; m_predicate;
2636      std::string m_description;
2637  public:
2638      PredicateMatcher(std::function&lt;bool(T const&amp;)&gt; const&amp; elem, std::string const&amp; descr)
2639          :m_predicate(std::move(elem)),
2640          m_description(Detail::finalizeDescription(descr))
2641      {}
2642      bool match( T const&amp; item ) const override {
2643          return m_predicate(item);
2644      }
2645      std::string describe() const override {
2646          return m_description;
2647      }
2648  };
2649  } 
2650      template&lt;typename T&gt;
2651      Generic::PredicateMatcher&lt;T&gt; Predicate(std::function&lt;bool(T const&amp;)&gt; const&amp; predicate, std::string const&amp; description = &quot;&quot;) {
2652          return Generic::PredicateMatcher&lt;T&gt;(predicate, description);
2653      }
2654  } 
2655  } 
2656  #include &lt;string&gt;
2657  namespace Catch {
2658  namespace Matchers {
2659      namespace StdString {
2660          struct CasedString
2661          {
2662              CasedString( std::string const&amp; str, CaseSensitive::Choice caseSensitivity );
2663              std::string adjustString( std::string const&amp; str ) const;
2664              std::string caseSensitivitySuffix() const;
2665              CaseSensitive::Choice m_caseSensitivity;
2666              std::string m_str;
2667          };
2668          struct StringMatcherBase : MatcherBase&lt;std::string&gt; {
2669              StringMatcherBase( std::string const&amp; operation, CasedString const&amp; comparator );
2670              std::string describe() const override;
2671              CasedString m_comparator;
2672              std::string m_operation;
2673          };
2674          struct EqualsMatcher : StringMatcherBase {
2675              EqualsMatcher( CasedString const&amp; comparator );
2676              bool match( std::string const&amp; source ) const override;
2677          };
2678          struct ContainsMatcher : StringMatcherBase {
2679              ContainsMatcher( CasedString const&amp; comparator );
2680              bool match( std::string const&amp; source ) const override;
2681          };
2682          struct StartsWithMatcher : StringMatcherBase {
2683              StartsWithMatcher( CasedString const&amp; comparator );
2684              bool match( std::string const&amp; source ) const override;
2685          };
2686          struct EndsWithMatcher : StringMatcherBase {
2687              EndsWithMatcher( CasedString const&amp; comparator );
2688              bool match( std::string const&amp; source ) const override;
2689          };
2690          struct RegexMatcher : MatcherBase&lt;std::string&gt; {
2691              RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
2692              bool match( std::string const&amp; matchee ) const override;
2693              std::string describe() const override;
2694          private:
2695              std::string m_regex;
2696              CaseSensitive::Choice m_caseSensitivity;
2697          };
2698      } 
2699      StdString::EqualsMatcher Equals( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2700      StdString::ContainsMatcher Contains( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2701      StdString::EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2702      StdString::StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2703      StdString::RegexMatcher Matches( std::string const&amp; regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2704  } 
2705  } 
2706  #include &lt;algorithm&gt;
2707  namespace Catch {
2708  namespace Matchers {
2709      namespace Vector {
2710          template&lt;typename T, typename Alloc&gt;
2711          struct ContainsElementMatcher : MatcherBase&lt;std::vector&lt;T, Alloc&gt;&gt; {
2712              ContainsElementMatcher(T const &amp;comparator) : m_comparator( comparator) {}
2713              bool match(std::vector&lt;T, Alloc&gt; const &amp;v) const override {
2714                  for (auto const&amp; el : v) {
2715                      if (el == m_comparator) {
2716                          return true;
2717                      }
2718                  }
2719                  return false;
2720              }
2721              std::string describe() const override {
2722                  return &quot;Contains: &quot; + ::Catch::Detail::stringify( m_comparator );
2723              }
2724              T const&amp; m_comparator;
2725          };
2726          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2727          struct ContainsMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2728              ContainsMatcher(std::vector&lt;T, AllocComp&gt; const &amp;comparator) : m_comparator( comparator ) {}
2729              bool match(std::vector&lt;T, AllocMatch&gt; const &amp;v) const override {
2730                  if (m_comparator.size() &gt; v.size())
2731                      return false;
2732                  for (auto const&amp; comparator : m_comparator) {
2733                      auto present = false;
2734                      for (const auto&amp; el : v) {
2735                          if (el == comparator) {
2736                              present = true;
2737                              break;
2738                          }
2739                      }
2740                      if (!present) {
2741                          return false;
2742                      }
2743                  }
2744                  return true;
2745              }
2746              std::string describe() const override {
2747                  return &quot;Contains: &quot; + ::Catch::Detail::stringify( m_comparator );
2748              }
2749              std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;
2750          };
2751          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2752          struct EqualsMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2753              EqualsMatcher(std::vector&lt;T, AllocComp&gt; const &amp;comparator) : m_comparator( comparator ) {}
2754              bool match(std::vector&lt;T, AllocMatch&gt; const &amp;v) const override {
2755                  if (m_comparator.size() != v.size())
2756                      return false;
2757                  for (std::size_t i = 0; i &lt; v.size(); ++i)
2758                      if (m_comparator[i] != v[i])
2759                          return false;
2760                  return true;
2761              }
2762              std::string describe() const override {
2763                  return &quot;Equals: &quot; + ::Catch::Detail::stringify( m_comparator );
2764              }
2765              std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;
2766          };
2767          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2768          struct ApproxMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2769              ApproxMatcher(std::vector&lt;T, AllocComp&gt; const&amp; comparator) : m_comparator( comparator ) {}
2770              bool match(std::vector&lt;T, AllocMatch&gt; const &amp;v) const override {
2771                  if (m_comparator.size() != v.size())
2772                      return false;
2773                  for (std::size_t i = 0; i &lt; v.size(); ++i)
2774                      if (m_comparator[i] != approx(v[i]))
2775                          return false;
2776                  return true;
2777              }
2778              std::string describe() const override {
2779                  return &quot;is approx: &quot; + ::Catch::Detail::stringify( m_comparator );
2780              }
2781              template &lt;typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2782              ApproxMatcher&amp; epsilon( T const&amp; newEpsilon ) {
2783                  approx.epsilon(newEpsilon);
2784                  return *this;
2785              }
2786              template &lt;typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2787              ApproxMatcher&amp; margin( T const&amp; newMargin ) {
2788                  approx.margin(newMargin);
2789                  return *this;
2790              }
2791              template &lt;typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2792              ApproxMatcher&amp; scale( T const&amp; newScale ) {
2793                  approx.scale(newScale);
2794                  return *this;
2795              }
2796              std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;
2797              mutable Catch::Detail::Approx approx = Catch::Detail::Approx::custom();
2798          };
2799          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2800          struct UnorderedEqualsMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2801              UnorderedEqualsMatcher(std::vector&lt;T, AllocComp&gt; const&amp; target) : m_target(target) {}
2802              bool match(std::vector&lt;T, AllocMatch&gt; const&amp; vec) const override {
2803                  if (m_target.size() != vec.size()) {
2804                      return false;
2805                  }
2806                  return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
2807              }
2808              std::string describe() const override {
2809                  return &quot;UnorderedEquals: &quot; + ::Catch::Detail::stringify(m_target);
2810              }
2811          private:
2812              std::vector&lt;T, AllocComp&gt; const&amp; m_target;
2813          };
2814      } 
2815      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2816      Vector::ContainsMatcher&lt;T, AllocComp, AllocMatch&gt; Contains( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {
2817          return Vector::ContainsMatcher&lt;T, AllocComp, AllocMatch&gt;( comparator );
2818      }
2819      template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;
2820      Vector::ContainsElementMatcher&lt;T, Alloc&gt; VectorContains( T const&amp; comparator ) {
2821          return Vector::ContainsElementMatcher&lt;T, Alloc&gt;( comparator );
2822      }
2823      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2824      Vector::EqualsMatcher&lt;T, AllocComp, AllocMatch&gt; Equals( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {
2825          return Vector::EqualsMatcher&lt;T, AllocComp, AllocMatch&gt;( comparator );
2826      }
2827      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2828      Vector::ApproxMatcher&lt;T, AllocComp, AllocMatch&gt; Approx( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {
2829          return Vector::ApproxMatcher&lt;T, AllocComp, AllocMatch&gt;( comparator );
2830      }
2831      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2832      Vector::UnorderedEqualsMatcher&lt;T, AllocComp, AllocMatch&gt; UnorderedEquals(std::vector&lt;T, AllocComp&gt; const&amp; target) {
2833          return Vector::UnorderedEqualsMatcher&lt;T, AllocComp, AllocMatch&gt;( target );
2834      }
2835  } 
2836  } 
2837  namespace Catch {
2838      template&lt;typename ArgT, typename MatcherT&gt;
2839      class MatchExpr : public ITransientExpression {
2840          ArgT const&amp; m_arg;
2841          MatcherT m_matcher;
2842          StringRef m_matcherString;
2843      public:
2844          MatchExpr( ArgT const&amp; arg, MatcherT const&amp; matcher, StringRef const&amp; matcherString )
2845          :   ITransientExpression{ true, matcher.match( arg ) },
2846              m_arg( arg ),
2847              m_matcher( matcher ),
2848              m_matcherString( matcherString )
2849          {}
2850          void streamReconstructedExpression( std::ostream &amp;os ) const override {
2851              auto matcherAsString = m_matcher.toString();
2852              os &lt;&lt; Catch::Detail::stringify( m_arg ) &lt;&lt; &#x27; &#x27;;
2853              if( matcherAsString == Detail::unprintableString )
2854                  os &lt;&lt; m_matcherString;
2855              else
2856                  os &lt;&lt; matcherAsString;
2857          }
2858      };
2859      using StringMatcher = Matchers::Impl::MatcherBase&lt;std::string&gt;;
2860      void handleExceptionMatchExpr( AssertionHandler&amp; handler, StringMatcher const&amp; matcher, StringRef const&amp; matcherString  );
2861      template&lt;typename ArgT, typename MatcherT&gt;
2862      auto makeMatchExpr( ArgT const&amp; arg, MatcherT const&amp; matcher, StringRef const&amp; matcherString  ) -&gt; MatchExpr&lt;ArgT, MatcherT&gt; {
2863          return MatchExpr&lt;ArgT, MatcherT&gt;( arg, matcher, matcherString );
2864      }
2865  } 
2866  #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
2867      do { \
2868          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2869          INTERNAL_CATCH_TRY { \
2870              catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \
2871          } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
2872          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2873      } while( false )
2874  #define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
2875      do { \
2876          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2877          if( catchAssertionHandler.allowThrows() ) \
2878              try { \
2879                  static_cast&lt;void&gt;(__VA_ARGS__ ); \
2880                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2881              } \
2882              catch( exceptionType const&amp; ex ) { \
2883                  catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \
2884              } \
2885              catch( ... ) { \
2886                  catchAssertionHandler.handleUnexpectedInflightException(); \
2887              } \
2888          else \
2889              catchAssertionHandler.handleThrowingCallSkipped(); \
2890          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2891      } while( false )
2892  #endif
2893  #include &lt;memory&gt;
2894  namespace Catch {
2895      namespace Generators {
2896          class GeneratorUntypedBase {
2897          public:
2898              GeneratorUntypedBase() = default;
2899              virtual ~GeneratorUntypedBase();
2900              virtual bool next() = 0;
2901          };
2902          using GeneratorBasePtr = std::unique_ptr&lt;GeneratorUntypedBase&gt;;
2903      } 
2904      struct IGeneratorTracker {
2905          virtual ~IGeneratorTracker();
2906          virtual auto hasGenerator() const -&gt; bool = 0;
2907          virtual auto getGenerator() const -&gt; Generators::GeneratorBasePtr const&amp; = 0;
2908          virtual void setGenerator( Generators::GeneratorBasePtr&amp;&amp; generator ) = 0;
2909      };
2910  } 
2911  #include &lt;exception&gt;
2912  namespace Catch {
2913  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2914      template &lt;typename Ex&gt;
2915      [[noreturn]]
2916      void throw_exception(Ex const&amp; e) {
2917          throw e;
2918      }
2919  #else 
2920      [[noreturn]]
2921      void throw_exception(std::exception const&amp; e);
2922  #endif
2923      [[noreturn]]
2924      void throw_logic_error(std::string const&amp; msg);
2925      [[noreturn]]
2926      void throw_domain_error(std::string const&amp; msg);
2927      [[noreturn]]
2928      void throw_runtime_error(std::string const&amp; msg);
2929  } 
2930  #define CATCH_MAKE_MSG(...) \
2931      (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str()
2932  #define CATCH_INTERNAL_ERROR(...) \
2933      Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO &lt;&lt; &quot;: Internal Catch2 error: &quot; &lt;&lt; __VA_ARGS__))
2934  #define CATCH_ERROR(...) \
2935      Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
2936  #define CATCH_RUNTIME_ERROR(...) \
2937      Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
2938  #define CATCH_ENFORCE( condition, ... ) \
2939      do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)
2940  #include &lt;memory&gt;
2941  #include &lt;vector&gt;
2942  #include &lt;cassert&gt;
2943  #include &lt;utility&gt;
2944  #include &lt;exception&gt;
2945  namespace Catch {
2946  class GeneratorException : public std::exception {
2947      const char* const m_msg = &quot;&quot;;
2948  public:
2949      GeneratorException(const char* msg):
2950          m_msg(msg)
2951      {}
2952      const char* what() const noexcept override final;
2953  };
2954  namespace Generators {
2955      namespace pf{
2956          template&lt;typename T, typename... Args&gt;
2957          std::unique_ptr&lt;T&gt; make_unique( Args&amp;&amp;... args ) {
2958              return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
2959          }
2960      }
2961      template&lt;typename T&gt;
2962      struct IGenerator : GeneratorUntypedBase {
2963          virtual ~IGenerator() = default;
2964          virtual T const&amp; get() const = 0;
2965          using type = T;
2966      };
2967      template&lt;typename T&gt;
2968      class SingleValueGenerator final : public IGenerator&lt;T&gt; {
2969          T m_value;
2970      public:
2971          SingleValueGenerator(T&amp;&amp; value) : m_value(std::move(value)) {}
2972          T const&amp; get() const override {
2973              return m_value;
2974          }
2975          bool next() override {
2976              return false;
2977          }
2978      };
2979      template&lt;typename T&gt;
2980      class FixedValuesGenerator final : public IGenerator&lt;T&gt; {
2981          static_assert(!std::is_same&lt;T, bool&gt;::value,
2982              &quot;FixedValuesGenerator does not support bools because of std::vector&lt;bool&gt;&quot;
2983              &quot;specialization, use SingleValue Generator instead.&quot;);
2984          std::vector&lt;T&gt; m_values;
2985          size_t m_idx = 0;
2986      public:
2987          FixedValuesGenerator( std::initializer_list&lt;T&gt; values ) : m_values( values ) {}
2988          T const&amp; get() const override {
2989              return m_values[m_idx];
2990          }
2991          bool next() override {
2992              ++m_idx;
2993              return m_idx &lt; m_values.size();
2994          }
2995      };
2996      template &lt;typename T&gt;
2997      class GeneratorWrapper final {
2998          std::unique_ptr&lt;IGenerator&lt;T&gt;&gt; m_generator;
2999      public:
3000          GeneratorWrapper(std::unique_ptr&lt;IGenerator&lt;T&gt;&gt; generator):
3001              m_generator(std::move(generator))
3002          {}
3003          T const&amp; get() const {
3004              return m_generator-&gt;get();
3005          }
3006          bool next() {
3007              return m_generator-&gt;next();
3008          }
3009      };
3010      template &lt;typename T&gt;
3011      GeneratorWrapper&lt;T&gt; value(T&amp;&amp; value) {
3012          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;SingleValueGenerator&lt;T&gt;&gt;(std::forward&lt;T&gt;(value)));
3013      }
3014      template &lt;typename T&gt;
3015      GeneratorWrapper&lt;T&gt; values(std::initializer_list&lt;T&gt; values) {
3016          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;FixedValuesGenerator&lt;T&gt;&gt;(values));
3017      }
3018      template&lt;typename T&gt;
3019      class Generators : public IGenerator&lt;T&gt; {
3020          std::vector&lt;GeneratorWrapper&lt;T&gt;&gt; m_generators;
3021          size_t m_current = 0;
3022          void populate(GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3023              m_generators.emplace_back(std::move(generator));
3024          }
3025          void populate(T&amp;&amp; val) {
3026              m_generators.emplace_back(value(std::forward&lt;T&gt;(val)));
3027          }
3028          template&lt;typename U&gt;
3029          void populate(U&amp;&amp; val) {
3030              populate(T(std::forward&lt;U&gt;(val)));
3031          }
3032          template&lt;typename U, typename... Gs&gt;
3033          void populate(U&amp;&amp; valueOrGenerator, Gs &amp;&amp;... moreGenerators) {
3034              populate(std::forward&lt;U&gt;(valueOrGenerator));
3035              populate(std::forward&lt;Gs&gt;(moreGenerators)...);
3036          }
3037      public:
3038          template &lt;typename... Gs&gt;
3039          Generators(Gs &amp;&amp;... moreGenerators) {
3040              m_generators.reserve(sizeof...(Gs));
3041              populate(std::forward&lt;Gs&gt;(moreGenerators)...);
3042          }
3043          T const&amp; get() const override {
3044              return m_generators[m_current].get();
3045          }
3046          bool next() override {
3047              if (m_current &gt;= m_generators.size()) {
3048                  return false;
3049              }
3050              const bool current_status = m_generators[m_current].next();
3051              if (!current_status) {
3052                  ++m_current;
3053              }
3054              return m_current &lt; m_generators.size();
3055          }
3056      };
3057      template&lt;typename... Ts&gt;
3058      GeneratorWrapper&lt;std::tuple&lt;Ts...&gt;&gt; table( std::initializer_list&lt;std::tuple&lt;typename std::decay&lt;Ts&gt;::type...&gt;&gt; tuples ) {
3059          return values&lt;std::tuple&lt;Ts...&gt;&gt;( tuples );
3060      }
3061      template &lt;typename T&gt;
3062      struct as {};
3063      template&lt;typename T, typename... Gs&gt;
3064      auto makeGenerators( GeneratorWrapper&lt;T&gt;&amp;&amp; generator, Gs &amp;&amp;... moreGenerators ) -&gt; Generators&lt;T&gt; {
3065          return Generators&lt;T&gt;(std::move(generator), std::forward&lt;Gs&gt;(moreGenerators)...);
3066      }
3067      template&lt;typename T&gt;
3068      auto makeGenerators( GeneratorWrapper&lt;T&gt;&amp;&amp; generator ) -&gt; Generators&lt;T&gt; {
3069          return Generators&lt;T&gt;(std::move(generator));
3070      }
3071      template&lt;typename T, typename... Gs&gt;
3072      auto makeGenerators( T&amp;&amp; val, Gs &amp;&amp;... moreGenerators ) -&gt; Generators&lt;T&gt; {
3073          return makeGenerators( value( std::forward&lt;T&gt;( val ) ), std::forward&lt;Gs&gt;( moreGenerators )... );
3074      }
3075      template&lt;typename T, typename U, typename... Gs&gt;
3076      auto makeGenerators( as&lt;T&gt;, U&amp;&amp; val, Gs &amp;&amp;... moreGenerators ) -&gt; Generators&lt;T&gt; {
3077          return makeGenerators( value( T( std::forward&lt;U&gt;( val ) ) ), std::forward&lt;Gs&gt;( moreGenerators )... );
3078      }
3079      auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp;;
3080      template&lt;typename L&gt;
3081      auto generate( StringRef generatorName, SourceLineInfo const&amp; lineInfo, L const&amp; generatorExpression ) -&gt; decltype(std::declval&lt;decltype(generatorExpression())&gt;().get()) {
3082          using UnderlyingType = typename decltype(generatorExpression())::type;
3083          IGeneratorTracker&amp; tracker = acquireGeneratorTracker( generatorName, lineInfo );
3084          if (!tracker.hasGenerator()) {
3085              tracker.setGenerator(pf::make_unique&lt;Generators&lt;UnderlyingType&gt;&gt;(generatorExpression()));
3086          }
3087          auto const&amp; generator = static_cast&lt;IGenerator&lt;UnderlyingType&gt; const&amp;&gt;( *tracker.getGenerator() );
3088          return generator.get();
3089      }
3090  } 
3091  } 
3092  #define GENERATE( ... ) \
3093      Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
3094                                   CATCH_INTERNAL_LINEINFO, \
3095                                   [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) 
3096  #define GENERATE_COPY( ... ) \
3097      Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
3098                                   CATCH_INTERNAL_LINEINFO, \
3099                                   [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) 
3100  #define GENERATE_REF( ... ) \
3101      Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
3102                                   CATCH_INTERNAL_LINEINFO, \
3103                                   [&amp;]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) 
3104  namespace Catch {
3105  namespace Generators {
3106      template &lt;typename T&gt;
3107      class TakeGenerator : public IGenerator&lt;T&gt; {
3108          GeneratorWrapper&lt;T&gt; m_generator;
3109          size_t m_returned = 0;
3110          size_t m_target;
3111      public:
3112          TakeGenerator(size_t target, GeneratorWrapper&lt;T&gt;&amp;&amp; generator):
3113              m_generator(std::move(generator)),
3114              m_target(target)
3115          {
3116              assert(target != 0 &amp;&amp; &quot;Empty generators are not allowed&quot;);
3117          }
3118          T const&amp; get() const override {
3119              return m_generator.get();
3120          }
3121          bool next() override {
3122              ++m_returned;
3123              if (m_returned &gt;= m_target) {
3124                  return false;
3125              }
3126              const auto success = m_generator.next();
3127              if (!success) {
3128                  m_returned = m_target;
3129              }
3130              return success;
3131          }
3132      };
3133      template &lt;typename T&gt;
3134      GeneratorWrapper&lt;T&gt; take(size_t target, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3135          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;TakeGenerator&lt;T&gt;&gt;(target, std::move(generator)));
3136      }
3137      template &lt;typename T, typename Predicate&gt;
3138      class FilterGenerator : public IGenerator&lt;T&gt; {
3139          GeneratorWrapper&lt;T&gt; m_generator;
3140          Predicate m_predicate;
3141      public:
3142          template &lt;typename P = Predicate&gt;
3143          FilterGenerator(P&amp;&amp; pred, GeneratorWrapper&lt;T&gt;&amp;&amp; generator):
3144              m_generator(std::move(generator)),
3145              m_predicate(std::forward&lt;P&gt;(pred))
3146          {
3147              if (!m_predicate(m_generator.get())) {
3148                  auto has_initial_value = next();
3149                  if (!has_initial_value) {
3150                      Catch::throw_exception(GeneratorException(&quot;No valid value found in filtered generator&quot;));
3151                  }
3152              }
3153          }
3154          T const&amp; get() const override {
3155              return m_generator.get();
3156          }
3157          bool next() override {
3158              bool success = m_generator.next();
3159              if (!success) {
3160                  return false;
3161              }
3162              while (!m_predicate(m_generator.get()) &amp;&amp; (success = m_generator.next()) == true);
3163              return success;
3164          }
3165      };
3166      template &lt;typename T, typename Predicate&gt;
3167      GeneratorWrapper&lt;T&gt; filter(Predicate&amp;&amp; pred, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3168          return GeneratorWrapper&lt;T&gt;(std::unique_ptr&lt;IGenerator&lt;T&gt;&gt;(pf::make_unique&lt;FilterGenerator&lt;T, Predicate&gt;&gt;(std::forward&lt;Predicate&gt;(pred), std::move(generator))));
3169      }
3170      template &lt;typename T&gt;
3171      class RepeatGenerator : public IGenerator&lt;T&gt; {
3172          static_assert(!std::is_same&lt;T, bool&gt;::value,
3173              &quot;RepeatGenerator currently does not support bools&quot;
3174              &quot;because of std::vector&lt;bool&gt; specialization&quot;);
3175          GeneratorWrapper&lt;T&gt; m_generator;
3176          mutable std::vector&lt;T&gt; m_returned;
3177          size_t m_target_repeats;
3178          size_t m_current_repeat = 0;
3179          size_t m_repeat_index = 0;
3180      public:
3181          RepeatGenerator(size_t repeats, GeneratorWrapper&lt;T&gt;&amp;&amp; generator):
3182              m_generator(std::move(generator)),
3183              m_target_repeats(repeats)
3184          {
3185              assert(m_target_repeats &gt; 0 &amp;&amp; &quot;Repeat generator must repeat at least once&quot;);
3186          }
3187          T const&amp; get() const override {
3188              if (m_current_repeat == 0) {
3189                  m_returned.push_back(m_generator.get());
3190                  return m_returned.back();
3191              }
3192              return m_returned[m_repeat_index];
3193          }
3194          bool next() override {
3195              if (m_current_repeat == 0) {
3196                  const auto success = m_generator.next();
3197                  if (!success) {
3198                      ++m_current_repeat;
3199                  }
3200                  return m_current_repeat &lt; m_target_repeats;
3201              }
3202              ++m_repeat_index;
3203              if (m_repeat_index == m_returned.size()) {
3204                  m_repeat_index = 0;
3205                  ++m_current_repeat;
3206              }
3207              return m_current_repeat &lt; m_target_repeats;
3208          }
3209      };
3210      template &lt;typename T&gt;
3211      GeneratorWrapper&lt;T&gt; repeat(size_t repeats, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3212          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;RepeatGenerator&lt;T&gt;&gt;(repeats, std::move(generator)));
3213      }
3214      template &lt;typename T, typename U, typename Func&gt;
3215      class MapGenerator : public IGenerator&lt;T&gt; {
3216          GeneratorWrapper&lt;U&gt; m_generator;
3217          Func m_function;
3218          T m_cache;
3219      public:
3220          template &lt;typename F2 = Func&gt;
3221          MapGenerator(F2&amp;&amp; function, GeneratorWrapper&lt;U&gt;&amp;&amp; generator) :
3222              m_generator(std::move(generator)),
3223              m_function(std::forward&lt;F2&gt;(function)),
3224              m_cache(m_function(m_generator.get()))
3225          {}
3226          T const&amp; get() const override {
3227              return m_cache;
3228          }
3229          bool next() override {
3230              const auto success = m_generator.next();
3231              if (success) {
3232                  m_cache = m_function(m_generator.get());
3233              }
3234              return success;
3235          }
3236      };
3237      template &lt;typename Func, typename U, typename T = FunctionReturnType&lt;Func, U&gt;&gt;
3238      GeneratorWrapper&lt;T&gt; map(Func&amp;&amp; function, GeneratorWrapper&lt;U&gt;&amp;&amp; generator) {
3239          return GeneratorWrapper&lt;T&gt;(
3240              pf::make_unique&lt;MapGenerator&lt;T, U, Func&gt;&gt;(std::forward&lt;Func&gt;(function), std::move(generator))
3241          );
3242      }
3243      template &lt;typename T, typename U, typename Func&gt;
3244      GeneratorWrapper&lt;T&gt; map(Func&amp;&amp; function, GeneratorWrapper&lt;U&gt;&amp;&amp; generator) {
3245          return GeneratorWrapper&lt;T&gt;(
3246              pf::make_unique&lt;MapGenerator&lt;T, U, Func&gt;&gt;(std::forward&lt;Func&gt;(function), std::move(generator))
3247          );
3248      }
3249      template &lt;typename T&gt;
3250      class ChunkGenerator final : public IGenerator&lt;std::vector&lt;T&gt;&gt; {
3251          std::vector&lt;T&gt; m_chunk;
3252          size_t m_chunk_size;
3253          GeneratorWrapper&lt;T&gt; m_generator;
3254          bool m_used_up = false;
3255      public:
3256          ChunkGenerator(size_t size, GeneratorWrapper&lt;T&gt; generator) :
3257              m_chunk_size(size), m_generator(std::move(generator))
3258          {
3259              m_chunk.reserve(m_chunk_size);
3260              if (m_chunk_size != 0) {
3261                  m_chunk.push_back(m_generator.get());
3262                  for (size_t i = 1; i &lt; m_chunk_size; ++i) {
3263                      if (!m_generator.next()) {
3264                          Catch::throw_exception(GeneratorException(&quot;Not enough values to initialize the first chunk&quot;));
3265                      }
3266                      m_chunk.push_back(m_generator.get());
3267                  }
3268              }
3269          }
3270          std::vector&lt;T&gt; const&amp; get() const override {
3271              return m_chunk;
3272          }
3273          bool next() override {
3274              m_chunk.clear();
3275              for (size_t idx = 0; idx &lt; m_chunk_size; ++idx) {
3276                  if (!m_generator.next()) {
3277                      return false;
3278                  }
3279                  m_chunk.push_back(m_generator.get());
3280              }
3281              return true;
3282          }
3283      };
3284      template &lt;typename T&gt;
3285      GeneratorWrapper&lt;std::vector&lt;T&gt;&gt; chunk(size_t size, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3286          return GeneratorWrapper&lt;std::vector&lt;T&gt;&gt;(
3287              pf::make_unique&lt;ChunkGenerator&lt;T&gt;&gt;(size, std::move(generator))
3288          );
3289      }
3290  } 
3291  } 
3292  #include &lt;memory&gt;
3293  namespace Catch {
3294      struct IResultCapture;
3295      struct IRunner;
3296      struct IConfig;
3297      struct IMutableContext;
3298      using IConfigPtr = std::shared_ptr&lt;IConfig const&gt;;
3299      struct IContext
3300      {
3301          virtual ~IContext();
3302          virtual IResultCapture* getResultCapture() = 0;
3303          virtual IRunner* getRunner() = 0;
3304          virtual IConfigPtr const&amp; getConfig() const = 0;
3305      };
3306      struct IMutableContext : IContext
3307      {
3308          virtual ~IMutableContext();
3309          virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
3310          virtual void setRunner( IRunner* runner ) = 0;
3311          virtual void setConfig( IConfigPtr const&amp; config ) = 0;
3312      private:
3313          static IMutableContext *currentContext;
3314          friend IMutableContext&amp; getCurrentMutableContext();
3315          friend void cleanUpContext();
3316          static void createContext();
3317      };
3318      inline IMutableContext&amp; getCurrentMutableContext()
3319      {
3320          if( !IMutableContext::currentContext )
3321              IMutableContext::createContext();
3322          return *IMutableContext::currentContext;
3323      }
3324      inline IContext&amp; getCurrentContext()
3325      {
3326          return getCurrentMutableContext();
3327      }
3328      void cleanUpContext();
3329      class SimplePcg32;
3330      SimplePcg32&amp; rng();
3331  }
3332  namespace Catch {
3333      template&lt;typename T&gt;
3334      class Option {
3335      public:
3336          Option() : nullableValue( nullptr ) {}
3337          Option( T const&amp; _value )
3338          : nullableValue( new( storage ) T( _value ) )
3339          {}
3340          Option( Option const&amp; _other )
3341          : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
3342          {}
3343          ~Option() {
3344              reset();
3345          }
3346          Option&amp; operator= ( Option const&amp; _other ) {
3347              if( &amp;_other != this ) {
3348                  reset();
3349                  if( _other )
3350                      nullableValue = new( storage ) T( *_other );
3351              }
3352              return *this;
3353          }
3354          Option&amp; operator = ( T const&amp; _value ) {
3355              reset();
3356              nullableValue = new( storage ) T( _value );
3357              return *this;
3358          }
3359          void reset() {
3360              if( nullableValue )
3361                  nullableValue-&gt;~T();
3362              nullableValue = nullptr;
3363          }
3364          T&amp; operator*() { return *nullableValue; }
3365          T const&amp; operator*() const { return *nullableValue; }
3366          T* operator-&gt;() { return nullableValue; }
3367          const T* operator-&gt;() const { return nullableValue; }
3368          T valueOr( T const&amp; defaultValue ) const {
3369              return nullableValue ? *nullableValue : defaultValue;
3370          }
3371          bool some() const { return nullableValue != nullptr; }
3372          bool none() const { return nullableValue == nullptr; }
3373          bool operator !() const { return nullableValue == nullptr; }
3374          explicit operator bool() const {
3375              return some();
3376          }
3377      private:
3378          T *nullableValue;
3379          alignas(alignof(T)) char storage[sizeof(T)];
3380      };
3381  } 
3382  #include &lt;chrono&gt;
3383  #include &lt;iosfwd&gt;
3384  #include &lt;string&gt;
3385  #include &lt;vector&gt;
3386  #include &lt;memory&gt;
3387  namespace Catch {
3388      enum class Verbosity {
3389          Quiet = 0,
3390          Normal,
3391          High
3392      };
3393      struct WarnAbout { enum What {
3394          Nothing = 0x00,
3395          NoAssertions = 0x01,
3396          NoTests = 0x02
3397      }; };
3398      struct ShowDurations { enum OrNot {
3399          DefaultForReporter,
3400          Always,
3401          Never
3402      }; };
3403      struct RunTests { enum InWhatOrder {
3404          InDeclarationOrder,
3405          InLexicographicalOrder,
3406          InRandomOrder
3407      }; };
3408      struct UseColour { enum YesOrNo {
3409          Auto,
3410          Yes,
3411          No
3412      }; };
3413      struct WaitForKeypress { enum When {
3414          Never,
3415          BeforeStart = 1,
3416          BeforeExit = 2,
3417          BeforeStartAndExit = BeforeStart | BeforeExit
3418      }; };
3419      class TestSpec;
3420      struct IConfig : NonCopyable {
3421          virtual ~IConfig();
3422          virtual bool allowThrows() const = 0;
3423          virtual std::ostream&amp; stream() const = 0;
3424          virtual std::string name() const = 0;
3425          virtual bool includeSuccessfulResults() const = 0;
3426          virtual bool shouldDebugBreak() const = 0;
3427          virtual bool warnAboutMissingAssertions() const = 0;
3428          virtual bool warnAboutNoTests() const = 0;
3429          virtual int abortAfter() const = 0;
3430          virtual bool showInvisibles() const = 0;
3431          virtual ShowDurations::OrNot showDurations() const = 0;
3432          virtual double minDuration() const = 0;
3433          virtual TestSpec const&amp; testSpec() const = 0;
3434          virtual bool hasTestFilters() const = 0;
3435          virtual std::vector&lt;std::string&gt; const&amp; getTestsOrTags() const = 0;
3436          virtual RunTests::InWhatOrder runOrder() const = 0;
3437          virtual unsigned int rngSeed() const = 0;
3438          virtual UseColour::YesOrNo useColour() const = 0;
3439          virtual std::vector&lt;std::string&gt; const&amp; getSectionsToRun() const = 0;
3440          virtual Verbosity verbosity() const = 0;
3441          virtual bool benchmarkNoAnalysis() const = 0;
3442          virtual int benchmarkSamples() const = 0;
3443          virtual double benchmarkConfidenceInterval() const = 0;
3444          virtual unsigned int benchmarkResamples() const = 0;
3445          virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
3446      };
3447      using IConfigPtr = std::shared_ptr&lt;IConfig const&gt;;
3448  }
3449  #include &lt;cstdint&gt;
3450  namespace Catch {
3451      class SimplePcg32 {
3452          using state_type = std::uint64_t;
3453      public:
3454          using result_type = std::uint32_t;
3455          static constexpr result_type (min)() {
3456              return 0;
3457          }
3458          static constexpr result_type (max)() {
3459              return static_cast&lt;result_type&gt;(-1);
3460          }
3461          SimplePcg32():SimplePcg32(0xed743cc4U) {}
3462          explicit SimplePcg32(result_type seed_);
3463          void seed(result_type seed_);
3464          void discard(uint64_t skip);
3465          result_type operator()();
3466      private:
3467          friend bool operator==(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs);
3468          friend bool operator!=(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs);
3469          std::uint64_t m_state;
3470          static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL &lt;&lt; 1ULL) | 1ULL;
3471      };
3472  } 
3473  #include &lt;random&gt;
3474  namespace Catch {
3475  namespace Generators {
3476  template &lt;typename Float&gt;
3477  class RandomFloatingGenerator final : public IGenerator&lt;Float&gt; {
3478      Catch::SimplePcg32&amp; m_rng;
3479      std::uniform_real_distribution&lt;Float&gt; m_dist;
3480      Float m_current_number;
3481  public:
3482      RandomFloatingGenerator(Float a, Float b):
3483          m_rng(rng()),
3484          m_dist(a, b) {
3485          static_cast&lt;void&gt;(next());
3486      }
3487      Float const&amp; get() const override {
3488          return m_current_number;
3489      }
3490      bool next() override {
3491          m_current_number = m_dist(m_rng);
3492          return true;
3493      }
3494  };
3495  template &lt;typename Integer&gt;
3496  class RandomIntegerGenerator final : public IGenerator&lt;Integer&gt; {
3497      Catch::SimplePcg32&amp; m_rng;
3498      std::uniform_int_distribution&lt;Integer&gt; m_dist;
3499      Integer m_current_number;
3500  public:
3501      RandomIntegerGenerator(Integer a, Integer b):
3502          m_rng(rng()),
3503          m_dist(a, b) {
3504          static_cast&lt;void&gt;(next());
3505      }
3506      Integer const&amp; get() const override {
3507          return m_current_number;
3508      }
3509      bool next() override {
3510          m_current_number = m_dist(m_rng);
3511          return true;
3512      }
3513  };
3514  template &lt;typename T&gt;
3515  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value,
3516  GeneratorWrapper&lt;T&gt;&gt;::type
3517  random(T a, T b) {
3518      return GeneratorWrapper&lt;T&gt;(
3519          pf::make_unique&lt;RandomIntegerGenerator&lt;T&gt;&gt;(a, b)
3520      );
3521  }
3522  template &lt;typename T&gt;
3523  typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value,
3524  GeneratorWrapper&lt;T&gt;&gt;::type
3525  random(T a, T b) {
3526      return GeneratorWrapper&lt;T&gt;(
3527          pf::make_unique&lt;RandomFloatingGenerator&lt;T&gt;&gt;(a, b)
3528      );
3529  }
3530  template &lt;typename T&gt;
3531  class RangeGenerator final : public IGenerator&lt;T&gt; {
3532      T m_current;
3533      T m_end;
3534      T m_step;
3535      bool m_positive;
3536  public:
3537      RangeGenerator(T const&amp; start, T const&amp; end, T const&amp; step):
3538          m_current(start),
3539          m_end(end),
3540          m_step(step),
3541          m_positive(m_step &gt; T(0))
3542      {
3543          assert(m_current != m_end &amp;&amp; &quot;Range start and end cannot be equal&quot;);
3544          assert(m_step != T(0) &amp;&amp; &quot;Step size cannot be zero&quot;);
3545          assert(((m_positive &amp;&amp; m_current &lt;= m_end) || (!m_positive &amp;&amp; m_current &gt;= m_end)) &amp;&amp; &quot;Step moves away from end&quot;);
3546      }
3547      RangeGenerator(T const&amp; start, T const&amp; end):
3548          RangeGenerator(start, end, (start &lt; end) ? T(1) : T(-1))
3549      {}
3550      T const&amp; get() const override {
3551          return m_current;
3552      }
3553      bool next() override {
3554          m_current += m_step;
3555          return (m_positive) ? (m_current &lt; m_end) : (m_current &gt; m_end);
3556      }
3557  };
3558  template &lt;typename T&gt;
3559  GeneratorWrapper&lt;T&gt; range(T const&amp; start, T const&amp; end, T const&amp; step) {
3560      static_assert(std::is_arithmetic&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, &quot;Type must be numeric&quot;);
3561      return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;RangeGenerator&lt;T&gt;&gt;(start, end, step));
3562  }
3563  template &lt;typename T&gt;
3564  GeneratorWrapper&lt;T&gt; range(T const&amp; start, T const&amp; end) {
3565      static_assert(std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, &quot;Type must be an integer&quot;);
3566      return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;RangeGenerator&lt;T&gt;&gt;(start, end));
3567  }
3568  template &lt;typename T&gt;
3569  class IteratorGenerator final : public IGenerator&lt;T&gt; {
3570      static_assert(!std::is_same&lt;T, bool&gt;::value,
3571          &quot;IteratorGenerator currently does not support bools&quot;
3572          &quot;because of std::vector&lt;bool&gt; specialization&quot;);
3573      std::vector&lt;T&gt; m_elems;
3574      size_t m_current = 0;
3575  public:
3576      template &lt;typename InputIterator, typename InputSentinel&gt;
3577      IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
3578          if (m_elems.empty()) {
3579              Catch::throw_exception(GeneratorException(&quot;IteratorGenerator received no valid values&quot;));
3580          }
3581      }
3582      T const&amp; get() const override {
3583          return m_elems[m_current];
3584      }
3585      bool next() override {
3586          ++m_current;
3587          return m_current != m_elems.size();
3588      }
3589  };
3590  template &lt;typename InputIterator,
3591            typename InputSentinel,
3592            typename ResultType = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
3593  GeneratorWrapper&lt;ResultType&gt; from_range(InputIterator from, InputSentinel to) {
3594      return GeneratorWrapper&lt;ResultType&gt;(pf::make_unique&lt;IteratorGenerator&lt;ResultType&gt;&gt;(from, to));
3595  }
3596  template &lt;typename Container,
3597            typename ResultType = typename Container::value_type&gt;
3598  GeneratorWrapper&lt;ResultType&gt; from_range(Container const&amp; cnt) {
3599      return GeneratorWrapper&lt;ResultType&gt;(pf::make_unique&lt;IteratorGenerator&lt;ResultType&gt;&gt;(cnt.begin(), cnt.end()));
3600  }
3601  } 
3602  } 
3603  #include &lt;string&gt;
3604  #include &lt;vector&gt;
3605  #include &lt;memory&gt;
3606  #ifdef __clang__
3607  #pragma clang diagnostic push
3608  #pragma clang diagnostic ignored &quot;-Wpadded&quot;
3609  #endif
3610  namespace Catch {
3611      struct ITestInvoker;
3612      struct TestCaseInfo {
3613          enum SpecialProperties{
3614              None = 0,
3615              IsHidden = 1 &lt;&lt; 1,
3616              ShouldFail = 1 &lt;&lt; 2,
3617              MayFail = 1 &lt;&lt; 3,
3618              Throws = 1 &lt;&lt; 4,
3619              NonPortable = 1 &lt;&lt; 5,
3620              Benchmark = 1 &lt;&lt; 6
3621          };
3622          TestCaseInfo(   std::string const&amp; _name,
3623                          std::string const&amp; _className,
3624                          std::string const&amp; _description,
3625                          std::vector&lt;std::string&gt; const&amp; _tags,
3626                          SourceLineInfo const&amp; _lineInfo );
3627          friend void setTags( TestCaseInfo&amp; testCaseInfo, std::vector&lt;std::string&gt; tags );
3628          bool isHidden() const;
3629          bool throws() const;
3630          bool okToFail() const;
3631          bool expectedToFail() const;
3632          std::string tagsAsString() const;
3633          std::string name;
3634          std::string className;
3635          std::string description;
3636          std::vector&lt;std::string&gt; tags;
3637          std::vector&lt;std::string&gt; lcaseTags;
3638          SourceLineInfo lineInfo;
3639          SpecialProperties properties;
3640      };
3641      class TestCase : public TestCaseInfo {
3642      public:
3643          TestCase( ITestInvoker* testCase, TestCaseInfo&amp;&amp; info );
3644          TestCase withName( std::string const&amp; _newName ) const;
3645          void invoke() const;
3646          TestCaseInfo const&amp; getTestCaseInfo() const;
3647          bool operator == ( TestCase const&amp; other ) const;
3648          bool operator &lt; ( TestCase const&amp; other ) const;
3649      private:
3650          std::shared_ptr&lt;ITestInvoker&gt; test;
3651      };
3652      TestCase makeTestCase(  ITestInvoker* testCase,
3653                              std::string const&amp; className,
3654                              NameAndTags const&amp; nameAndTags,
3655                              SourceLineInfo const&amp; lineInfo );
3656  }
3657  #ifdef __clang__
3658  #pragma clang diagnostic pop
3659  #endif
3660  namespace Catch {
3661      struct IRunner {
3662          virtual ~IRunner();
3663          virtual bool aborting() const = 0;
3664      };
3665  }
3666  #ifdef __OBJC__
3667  #import &lt;objc/runtime.h&gt;
3668  #include &lt;string&gt;
3669  @protocol OcFixture
3670  @optional
3671  -(void) setUp;
3672  -(void) tearDown;
3673  @end
3674  namespace Catch {
3675      class OcMethod : public ITestInvoker {
3676      public:
3677          OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
3678          virtual void invoke() const {
3679              id obj = [[m_cls alloc] init];
3680              performOptionalSelector( obj, @selector(setUp)  );
3681              performOptionalSelector( obj, m_sel );
3682              performOptionalSelector( obj, @selector(tearDown)  );
3683              arcSafeRelease( obj );
3684          }
3685      private:
3686          virtual ~OcMethod() {}
3687          Class m_cls;
3688          SEL m_sel;
3689      };
3690      namespace Detail{
3691          inline std::string getAnnotation(   Class cls,
3692                                              std::string const&amp; annotationName,
3693                                              std::string const&amp; testCaseName ) {
3694              NSString* selStr = [[NSString alloc] initWithFormat:@&quot;Catch_%s_%s&quot;, annotationName.c_str(), testCaseName.c_str()];
3695              SEL sel = NSSelectorFromString( selStr );
3696              arcSafeRelease( selStr );
3697              id value = performOptionalSelector( cls, sel );
3698              if( value )
3699                  return [(NSString*)value UTF8String];
3700              return &quot;&quot;;
3701          }
3702      }
3703      inline std::size_t registerTestMethods() {
3704          std::size_t noTestMethods = 0;
3705          int noClasses = objc_getClassList( nullptr, 0 );
3706          Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
3707          objc_getClassList( classes, noClasses );
3708          for( int c = 0; c &lt; noClasses; c++ ) {
3709              Class cls = classes[c];
3710              {
3711                  u_int count;
3712                  Method* methods = class_copyMethodList( cls, &amp;count );
3713                  for( u_int m = 0; m &lt; count ; m++ ) {
3714                      SEL selector = method_getName(methods[m]);
3715                      std::string methodName = sel_getName(selector);
3716                      if( startsWith( methodName, &quot;Catch_TestCase_&quot; ) ) {
3717                          std::string testCaseName = methodName.substr( 15 );
3718                          std::string name = Detail::getAnnotation( cls, &quot;Name&quot;, testCaseName );
3719                          std::string desc = Detail::getAnnotation( cls, &quot;Description&quot;, testCaseName );
3720                          const char* className = class_getName( cls );
3721                          getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, NameAndTags( name.c_str(), desc.c_str() ), SourceLineInfo(&quot;&quot;,0) ) );
3722                          noTestMethods++;
3723                      }
3724                  }
3725                  free(methods);
3726              }
3727          }
3728          return noTestMethods;
3729      }
3730  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
3731      namespace Matchers {
3732          namespace Impl {
3733          namespace NSStringMatchers {
3734              struct StringHolder : MatcherBase&lt;NSString*&gt;{
3735                  StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
3736                  StringHolder( StringHolder const&amp; other ) : m_substr( [other.m_substr copy] ){}
3737                  StringHolder() {
3738                      arcSafeRelease( m_substr );
3739                  }
3740                  bool match( NSString* str ) const override {
3741                      return false;
3742                  }
3743                  NSString* CATCH_ARC_STRONG m_substr;
3744              };
3745              struct Equals : StringHolder {
3746                  Equals( NSString* substr ) : StringHolder( substr ){}
3747                  bool match( NSString* str ) const override {
3748                      return  (str != nil || m_substr == nil ) &amp;&amp;
3749                              [str isEqualToString:m_substr];
3750                  }
3751                  std::string describe() const override {
3752                      return &quot;equals string: &quot; + Catch::Detail::stringify( m_substr );
3753                  }
3754              };
3755              struct Contains : StringHolder {
3756                  Contains( NSString* substr ) : StringHolder( substr ){}
3757                  bool match( NSString* str ) const override {
3758                      return  (str != nil || m_substr == nil ) &amp;&amp;
3759                              [str rangeOfString:m_substr].location != NSNotFound;
3760                  }
3761                  std::string describe() const override {
3762                      return &quot;contains string: &quot; + Catch::Detail::stringify( m_substr );
3763                  }
3764              };
3765              struct StartsWith : StringHolder {
3766                  StartsWith( NSString* substr ) : StringHolder( substr ){}
3767                  bool match( NSString* str ) const override {
3768                      return  (str != nil || m_substr == nil ) &amp;&amp;
3769                              [str rangeOfString:m_substr].location == 0;
3770                  }
3771                  std::string describe() const override {
3772                      return &quot;starts with: &quot; + Catch::Detail::stringify( m_substr );
3773                  }
3774              };
3775              struct EndsWith : StringHolder {
3776                  EndsWith( NSString* substr ) : StringHolder( substr ){}
3777                  bool match( NSString* str ) const override {
3778                      return  (str != nil || m_substr == nil ) &amp;&amp;
3779                              [str rangeOfString:m_substr].location == [str length] - [m_substr length];
3780                  }
3781                  std::string describe() const override {
3782                      return &quot;ends with: &quot; + Catch::Detail::stringify( m_substr );
3783                  }
3784              };
3785          } 
3786          } 
3787          inline Impl::NSStringMatchers::Equals
3788              Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
3789          inline Impl::NSStringMatchers::Contains
3790              Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
3791          inline Impl::NSStringMatchers::StartsWith
3792              StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
3793          inline Impl::NSStringMatchers::EndsWith
3794              EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
3795      } 
3796      using namespace Matchers;
3797  #endif 
3798  } 
3799  #define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix
3800  #define OC_TEST_CASE2( name, desc, uniqueSuffix ) \
3801  +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \
3802  { \
3803  return @ name; \
3804  } \
3805  +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \
3806  { \
3807  return @ desc; \
3808  } \
3809  -(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )
3810  #define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )
3811  #endif
3812  #if defined(CATCH_CONFIG_EXTERNAL_INTERFACES) || defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
3813  #ifdef __clang__
3814  #pragma clang diagnostic push
3815  #pragma clang diagnostic ignored &quot;-Wpadded&quot;
3816  #endif
3817  #ifdef __clang__
3818  #pragma clang diagnostic push
3819  #pragma clang diagnostic ignored &quot;-Wpadded&quot;
3820  #endif
3821  namespace Catch
3822  {
3823      class WildcardPattern {
3824          enum WildcardPosition {
3825              NoWildcard = 0,
3826              WildcardAtStart = 1,
3827              WildcardAtEnd = 2,
3828              WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
3829          };
3830      public:
3831          WildcardPattern( std::string const&amp; pattern, CaseSensitive::Choice caseSensitivity );
3832          virtual ~WildcardPattern() = default;
3833          virtual bool matches( std::string const&amp; str ) const;
3834      private:
3835          std::string normaliseString( std::string const&amp; str ) const;
3836          CaseSensitive::Choice m_caseSensitivity;
3837          WildcardPosition m_wildcard = NoWildcard;
3838          std::string m_pattern;
3839      };
3840  }
3841  #include &lt;string&gt;
3842  #include &lt;vector&gt;
3843  #include &lt;memory&gt;
3844  namespace Catch {
3845      struct IConfig;
3846      class TestSpec {
3847          class Pattern {
3848          public:
3849              explicit Pattern( std::string const&amp; name );
3850              virtual ~Pattern();
3851              virtual bool matches( TestCaseInfo const&amp; testCase ) const = 0;
3852              std::string const&amp; name() const;
3853          private:
3854              std::string const m_name;
3855          };
3856          using PatternPtr = std::shared_ptr&lt;Pattern&gt;;
3857          class NamePattern : public Pattern {
3858          public:
3859              explicit NamePattern( std::string const&amp; name, std::string const&amp; filterString );
3860              bool matches( TestCaseInfo const&amp; testCase ) const override;
3861          private:
3862              WildcardPattern m_wildcardPattern;
3863          };
3864          class TagPattern : public Pattern {
3865          public:
3866              explicit TagPattern( std::string const&amp; tag, std::string const&amp; filterString );
3867              bool matches( TestCaseInfo const&amp; testCase ) const override;
3868          private:
3869              std::string m_tag;
3870          };
3871          class ExcludedPattern : public Pattern {
3872          public:
3873              explicit ExcludedPattern( PatternPtr const&amp; underlyingPattern );
3874              bool matches( TestCaseInfo const&amp; testCase ) const override;
3875          private:
3876              PatternPtr m_underlyingPattern;
3877          };
3878          struct Filter {
3879              std::vector&lt;PatternPtr&gt; m_patterns;
3880              bool matches( TestCaseInfo const&amp; testCase ) const;
3881              std::string name() const;
3882          };
3883      public:
3884          struct FilterMatch {
3885              std::string name;
3886              std::vector&lt;TestCase const*&gt; tests;
3887          };
3888          using Matches = std::vector&lt;FilterMatch&gt;;
3889          using vectorStrings = std::vector&lt;std::string&gt;;
3890          bool hasFilters() const;
3891          bool matches( TestCaseInfo const&amp; testCase ) const;
3892          Matches matchesByFilter( std::vector&lt;TestCase&gt; const&amp; testCases, IConfig const&amp; config ) const;
3893          const vectorStrings &amp; getInvalidArgs() const;
3894      private:
3895          std::vector&lt;Filter&gt; m_filters;
3896          std::vector&lt;std::string&gt; m_invalidArgs;
3897          friend class TestSpecParser;
3898      };
3899  }
3900  #ifdef __clang__
3901  #pragma clang diagnostic pop
3902  #endif
3903  #include &lt;string&gt;
3904  namespace Catch {
3905      struct TagAlias;
3906      struct ITagAliasRegistry {
3907          virtual ~ITagAliasRegistry();
3908          virtual TagAlias const* find( std::string const&amp; alias ) const = 0;
3909          virtual std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const = 0;
3910          static ITagAliasRegistry const&amp; get();
3911      };
3912  } 
3913  namespace Catch {
3914      class TestSpecParser {
3915          enum Mode{ None, Name, QuotedName, Tag, EscapedName };
3916          Mode m_mode = None;
3917          Mode lastMode = None;
3918          bool m_exclusion = false;
3919          std::size_t m_pos = 0;
3920          std::size_t m_realPatternPos = 0;
3921          std::string m_arg;
3922          std::string m_substring;
3923          std::string m_patternName;
3924          std::vector&lt;std::size_t&gt; m_escapeChars;
3925          TestSpec::Filter m_currentFilter;
3926          TestSpec m_testSpec;
3927          ITagAliasRegistry const* m_tagAliases = nullptr;
3928      public:
3929          TestSpecParser( ITagAliasRegistry const&amp; tagAliases );
3930          TestSpecParser&amp; parse( std::string const&amp; arg );
3931          TestSpec testSpec();
3932      private:
3933          bool visitChar( char c );
3934          void startNewMode( Mode mode );
3935          bool processNoneChar( char c );
3936          void processNameChar( char c );
3937          bool processOtherChar( char c );
3938          void endMode();
3939          void escape();
3940          bool isControlChar( char c ) const;
3941          void saveLastMode();
3942          void revertBackToLastMode();
3943          void addFilter();
3944          bool separate();
3945          std::string preprocessPattern();
3946          void addNamePattern();
3947          void addTagPattern();
3948          inline void addCharToPattern(char c) {
3949              m_substring += c;
3950              m_patternName += c;
3951              m_realPatternPos++;
3952          }
3953      };
3954      TestSpec parseTestSpec( std::string const&amp; arg );
3955  } 
3956  #ifdef __clang__
3957  #pragma clang diagnostic pop
3958  #endif
3959  #include &lt;memory&gt;
3960  #include &lt;vector&gt;
3961  #include &lt;string&gt;
3962  #ifndef CATCH_CONFIG_CONSOLE_WIDTH
3963  #define CATCH_CONFIG_CONSOLE_WIDTH 80
3964  #endif
3965  namespace Catch {
3966      struct IStream;
3967      struct ConfigData {
3968          bool listTests = false;
3969          bool listTags = false;
3970          bool listReporters = false;
3971          bool listTestNamesOnly = false;
3972          bool showSuccessfulTests = false;
3973          bool shouldDebugBreak = false;
3974          bool noThrow = false;
3975          bool showHelp = false;
3976          bool showInvisibles = false;
3977          bool filenamesAsTags = false;
3978          bool libIdentify = false;
3979          int abortAfter = -1;
3980          unsigned int rngSeed = 0;
3981          bool benchmarkNoAnalysis = false;
3982          unsigned int benchmarkSamples = 100;
3983          double benchmarkConfidenceInterval = 0.95;
3984          unsigned int benchmarkResamples = 100000;
3985          std::chrono::milliseconds::rep benchmarkWarmupTime = 100;
3986          Verbosity verbosity = Verbosity::Normal;
3987          WarnAbout::What warnings = WarnAbout::Nothing;
3988          ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;
3989          double minDuration = -1;
3990          RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;
3991          UseColour::YesOrNo useColour = UseColour::Auto;
3992          WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
3993          std::string outputFilename;
3994          std::string name;
3995          std::string processName;
3996  #ifndef CATCH_CONFIG_DEFAULT_REPORTER
3997  #define CATCH_CONFIG_DEFAULT_REPORTER &quot;console&quot;
3998  #endif
3999          std::string reporterName = CATCH_CONFIG_DEFAULT_REPORTER;
4000  #undef CATCH_CONFIG_DEFAULT_REPORTER
4001          std::vector&lt;std::string&gt; testsOrTags;
4002          std::vector&lt;std::string&gt; sectionsToRun;
4003      };
4004      class Config : public IConfig {
4005      public:
4006          Config() = default;
4007          Config( ConfigData const&amp; data );
4008          virtual ~Config() = default;
4009          std::string const&amp; getFilename() const;
4010          bool listTests() const;
4011          bool listTestNamesOnly() const;
4012          bool listTags() const;
4013          bool listReporters() const;
4014          std::string getProcessName() const;
4015          std::string const&amp; getReporterName() const;
4016          std::vector&lt;std::string&gt; const&amp; getTestsOrTags() const override;
4017          std::vector&lt;std::string&gt; const&amp; getSectionsToRun() const override;
4018          TestSpec const&amp; testSpec() const override;
4019          bool hasTestFilters() const override;
4020          bool showHelp() const;
4021          bool allowThrows() const override;
4022          std::ostream&amp; stream() const override;
4023          std::string name() const override;
4024          bool includeSuccessfulResults() const override;
4025          bool warnAboutMissingAssertions() const override;
4026          bool warnAboutNoTests() const override;
4027          ShowDurations::OrNot showDurations() const override;
4028          double minDuration() const override;
4029          RunTests::InWhatOrder runOrder() const override;
4030          unsigned int rngSeed() const override;
4031          UseColour::YesOrNo useColour() const override;
4032          bool shouldDebugBreak() const override;
4033          int abortAfter() const override;
4034          bool showInvisibles() const override;
4035          Verbosity verbosity() const override;
4036          bool benchmarkNoAnalysis() const override;
4037          int benchmarkSamples() const override;
4038          double benchmarkConfidenceInterval() const override;
4039          unsigned int benchmarkResamples() const override;
4040          std::chrono::milliseconds benchmarkWarmupTime() const override;
4041      private:
4042          IStream const* openStream();
4043          ConfigData m_data;
4044          std::unique_ptr&lt;IStream const&gt; m_stream;
4045          TestSpec m_testSpec;
4046          bool m_hasTestFilters = false;
4047      };
4048  } 
4049  #include &lt;string&gt;
4050  namespace Catch {
4051      struct AssertionResultData
4052      {
4053          AssertionResultData() = delete;
4054          AssertionResultData( ResultWas::OfType _resultType, LazyExpression const&amp; _lazyExpression );
4055          std::string message;
4056          mutable std::string reconstructedExpression;
4057          LazyExpression lazyExpression;
4058          ResultWas::OfType resultType;
4059          std::string reconstructExpression() const;
4060      };
4061      class AssertionResult {
4062      public:
4063          AssertionResult() = delete;
4064          AssertionResult( AssertionInfo const&amp; info, AssertionResultData const&amp; data );
4065          bool isOk() const;
4066          bool succeeded() const;
4067          ResultWas::OfType getResultType() const;
4068          bool hasExpression() const;
4069          bool hasMessage() const;
4070          std::string getExpression() const;
4071          std::string getExpressionInMacro() const;
4072          bool hasExpandedExpression() const;
4073          std::string getExpandedExpression() const;
4074          std::string getMessage() const;
4075          SourceLineInfo getSourceInfo() const;
4076          StringRef getTestMacroName() const;
4077          AssertionInfo m_info;
4078          AssertionResultData m_resultData;
4079      };
4080  } 
4081  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4082  namespace Catch {
4083      namespace Benchmark {
4084          template &lt;typename Duration&gt;
4085          struct Estimate {
4086              Duration point;
4087              Duration lower_bound;
4088              Duration upper_bound;
4089              double confidence_interval;
4090              template &lt;typename Duration2&gt;
4091              operator Estimate&lt;Duration2&gt;() const {
4092                  return { point, lower_bound, upper_bound, confidence_interval };
4093              }
4094          };
4095      } 
4096  } 
4097  namespace Catch {
4098      namespace Benchmark {
4099          struct OutlierClassification {
4100              int samples_seen = 0;
4101              int low_severe = 0;     
4102              int low_mild = 0;       
4103              int high_mild = 0;      
4104              int high_severe = 0;    
4105              int total() const {
4106                  return low_severe + low_mild + high_mild + high_severe;
4107              }
4108          };
4109      } 
4110  } 
4111  #include &lt;iterator&gt;
4112  #endif 
4113  #include &lt;string&gt;
4114  #include &lt;iosfwd&gt;
4115  #include &lt;map&gt;
4116  #include &lt;set&gt;
4117  #include &lt;memory&gt;
4118  #include &lt;algorithm&gt;
4119  namespace Catch {
4120      struct ReporterConfig {
4121          explicit ReporterConfig( IConfigPtr const&amp; _fullConfig );
4122          ReporterConfig( IConfigPtr const&amp; _fullConfig, std::ostream&amp; _stream );
4123          std::ostream&amp; stream() const;
4124          IConfigPtr fullConfig() const;
4125      private:
4126          std::ostream* m_stream;
4127          IConfigPtr m_fullConfig;
4128      };
4129      struct ReporterPreferences {
4130          bool shouldRedirectStdOut = false;
4131          bool shouldReportAllAssertions = false;
4132      };
4133      template&lt;typename T&gt;
4134      struct LazyStat : Option&lt;T&gt; {
4135          LazyStat&amp; operator=( T const&amp; _value ) {
4136              Option&lt;T&gt;::operator=( _value );
4137              used = false;
4138              return *this;
4139          }
4140          void reset() {
4141              Option&lt;T&gt;::reset();
4142              used = false;
4143          }
4144          bool used = false;
4145      };
4146      struct TestRunInfo {
4147          TestRunInfo( std::string const&amp; _name );
4148          std::string name;
4149      };
4150      struct GroupInfo {
4151          GroupInfo(  std::string const&amp; _name,
4152                      std::size_t _groupIndex,
4153                      std::size_t _groupsCount );
4154          std::string name;
4155          std::size_t groupIndex;
4156          std::size_t groupsCounts;
4157      };
4158      struct AssertionStats {
4159          AssertionStats( AssertionResult const&amp; _assertionResult,
4160                          std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,
4161                          Totals const&amp; _totals );
4162          AssertionStats( AssertionStats const&amp; )              = default;
4163          AssertionStats( AssertionStats &amp;&amp; )                  = default;
4164          AssertionStats&amp; operator = ( AssertionStats const&amp; ) = delete;
4165          AssertionStats&amp; operator = ( AssertionStats &amp;&amp; )     = delete;
4166          virtual ~AssertionStats();
4167          AssertionResult assertionResult;
4168          std::vector&lt;MessageInfo&gt; infoMessages;
4169          Totals totals;
4170      };
4171      struct SectionStats {
4172          SectionStats(   SectionInfo const&amp; _sectionInfo,
4173                          Counts const&amp; _assertions,
4174                          double _durationInSeconds,
4175                          bool _missingAssertions );
4176          SectionStats( SectionStats const&amp; )              = default;
4177          SectionStats( SectionStats &amp;&amp; )                  = default;
4178          SectionStats&amp; operator = ( SectionStats const&amp; ) = default;
4179          SectionStats&amp; operator = ( SectionStats &amp;&amp; )     = default;
4180          virtual ~SectionStats();
4181          SectionInfo sectionInfo;
4182          Counts assertions;
4183          double durationInSeconds;
4184          bool missingAssertions;
4185      };
4186      struct TestCaseStats {
4187          TestCaseStats(  TestCaseInfo const&amp; _testInfo,
4188                          Totals const&amp; _totals,
4189                          std::string const&amp; _stdOut,
4190                          std::string const&amp; _stdErr,
4191                          bool _aborting );
4192          TestCaseStats( TestCaseStats const&amp; )              = default;
4193          TestCaseStats( TestCaseStats &amp;&amp; )                  = default;
4194          TestCaseStats&amp; operator = ( TestCaseStats const&amp; ) = default;
4195          TestCaseStats&amp; operator = ( TestCaseStats &amp;&amp; )     = default;
4196          virtual ~TestCaseStats();
4197          TestCaseInfo testInfo;
4198          Totals totals;
4199          std::string stdOut;
4200          std::string stdErr;
4201          bool aborting;
4202      };
4203      struct TestGroupStats {
4204          TestGroupStats( GroupInfo const&amp; _groupInfo,
4205                          Totals const&amp; _totals,
4206                          bool _aborting );
4207          TestGroupStats( GroupInfo const&amp; _groupInfo );
4208          TestGroupStats( TestGroupStats const&amp; )              = default;
4209          TestGroupStats( TestGroupStats &amp;&amp; )                  = default;
4210          TestGroupStats&amp; operator = ( TestGroupStats const&amp; ) = default;
4211          TestGroupStats&amp; operator = ( TestGroupStats &amp;&amp; )     = default;
4212          virtual ~TestGroupStats();
4213          GroupInfo groupInfo;
4214          Totals totals;
4215          bool aborting;
4216      };
4217      struct TestRunStats {
4218          TestRunStats(   TestRunInfo const&amp; _runInfo,
4219                          Totals const&amp; _totals,
4220                          bool _aborting );
4221          TestRunStats( TestRunStats const&amp; )              = default;
4222          TestRunStats( TestRunStats &amp;&amp; )                  = default;
4223          TestRunStats&amp; operator = ( TestRunStats const&amp; ) = default;
4224          TestRunStats&amp; operator = ( TestRunStats &amp;&amp; )     = default;
4225          virtual ~TestRunStats();
4226          TestRunInfo runInfo;
4227          Totals totals;
4228          bool aborting;
4229      };
4230  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4231      struct BenchmarkInfo {
4232          std::string name;
4233          double estimatedDuration;
4234          int iterations;
4235          int samples;
4236          unsigned int resamples;
4237          double clockResolution;
4238          double clockCost;
4239      };
4240      template &lt;class Duration&gt;
4241      struct BenchmarkStats {
4242          BenchmarkInfo info;
4243          std::vector&lt;Duration&gt; samples;
4244          Benchmark::Estimate&lt;Duration&gt; mean;
4245          Benchmark::Estimate&lt;Duration&gt; standardDeviation;
4246          Benchmark::OutlierClassification outliers;
4247          double outlierVariance;
4248          template &lt;typename Duration2&gt;
4249          operator BenchmarkStats&lt;Duration2&gt;() const {
4250              std::vector&lt;Duration2&gt; samples2;
4251              samples2.reserve(samples.size());
4252              std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
4253              return {
4254                  info,
4255                  std::move(samples2),
4256                  mean,
4257                  standardDeviation,
4258                  outliers,
4259                  outlierVariance,
4260              };
4261          }
4262      };
4263  #endif 
4264      struct IStreamingReporter {
4265          virtual ~IStreamingReporter() = default;
4266          virtual ReporterPreferences getPreferences() const = 0;
4267          virtual void noMatchingTestCases( std::string const&amp; spec ) = 0;
4268          virtual void reportInvalidArguments(std::string const&amp;) {}
4269          virtual void testRunStarting( TestRunInfo const&amp; testRunInfo ) = 0;
4270          virtual void testGroupStarting( GroupInfo const&amp; groupInfo ) = 0;
4271          virtual void testCaseStarting( TestCaseInfo const&amp; testInfo ) = 0;
4272          virtual void sectionStarting( SectionInfo const&amp; sectionInfo ) = 0;
4273  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4274          virtual void benchmarkPreparing( std::string const&amp; ) {}
4275          virtual void benchmarkStarting( BenchmarkInfo const&amp; ) {}
4276          virtual void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; ) {}
4277          virtual void benchmarkFailed( std::string const&amp; ) {}
4278  #endif 
4279          virtual void assertionStarting( AssertionInfo const&amp; assertionInfo ) = 0;
4280          virtual bool assertionEnded( AssertionStats const&amp; assertionStats ) = 0;
4281          virtual void sectionEnded( SectionStats const&amp; sectionStats ) = 0;
4282          virtual void testCaseEnded( TestCaseStats const&amp; testCaseStats ) = 0;
4283          virtual void testGroupEnded( TestGroupStats const&amp; testGroupStats ) = 0;
4284          virtual void testRunEnded( TestRunStats const&amp; testRunStats ) = 0;
4285          virtual void skipTest( TestCaseInfo const&amp; testInfo ) = 0;
4286          virtual void fatalErrorEncountered( StringRef name );
4287          virtual bool isMulti() const;
4288      };
4289      using IStreamingReporterPtr = std::unique_ptr&lt;IStreamingReporter&gt;;
4290      struct IReporterFactory {
4291          virtual ~IReporterFactory();
4292          virtual IStreamingReporterPtr create( ReporterConfig const&amp; config ) const = 0;
4293          virtual std::string getDescription() const = 0;
4294      };
4295      using IReporterFactoryPtr = std::shared_ptr&lt;IReporterFactory&gt;;
4296      struct IReporterRegistry {
4297          using FactoryMap = std::map&lt;std::string, IReporterFactoryPtr&gt;;
4298          using Listeners = std::vector&lt;IReporterFactoryPtr&gt;;
4299          virtual ~IReporterRegistry();
4300          virtual IStreamingReporterPtr create( std::string const&amp; name, IConfigPtr const&amp; config ) const = 0;
4301          virtual FactoryMap const&amp; getFactories() const = 0;
4302          virtual Listeners const&amp; getListeners() const = 0;
4303      };
4304  } 
4305  #include &lt;algorithm&gt;
4306  #include &lt;cstring&gt;
4307  #include &lt;cfloat&gt;
4308  #include &lt;cstdio&gt;
4309  #include &lt;cassert&gt;
4310  #include &lt;memory&gt;
4311  #include &lt;ostream&gt;
4312  namespace Catch {
4313      void prepareExpandedExpression(AssertionResult&amp; result);
4314      std::string getFormattedDuration( double duration );
4315      bool shouldShowDuration( IConfig const&amp; config, double duration );
4316      std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; container );
4317      template&lt;typename DerivedT&gt;
4318      struct StreamingReporterBase : IStreamingReporter {
4319          StreamingReporterBase( ReporterConfig const&amp; _config )
4320          :   m_config( _config.fullConfig() ),
4321              stream( _config.stream() )
4322          {
4323              m_reporterPrefs.shouldRedirectStdOut = false;
4324              if( !DerivedT::getSupportedVerbosities().count( m_config-&gt;verbosity() ) )
4325                  CATCH_ERROR( &quot;Verbosity level not supported by this reporter&quot; );
4326          }
4327          ReporterPreferences getPreferences() const override {
4328              return m_reporterPrefs;
4329          }
4330          static std::set&lt;Verbosity&gt; getSupportedVerbosities() {
4331              return { Verbosity::Normal };
4332          }
4333          ~StreamingReporterBase() override = default;
4334          void noMatchingTestCases(std::string const&amp;) override {}
4335          void reportInvalidArguments(std::string const&amp;) override {}
4336          void testRunStarting(TestRunInfo const&amp; _testRunInfo) override {
4337              currentTestRunInfo = _testRunInfo;
4338          }
4339          void testGroupStarting(GroupInfo const&amp; _groupInfo) override {
4340              currentGroupInfo = _groupInfo;
4341          }
4342          void testCaseStarting(TestCaseInfo const&amp; _testInfo) override  {
4343              currentTestCaseInfo = _testInfo;
4344          }
4345          void sectionStarting(SectionInfo const&amp; _sectionInfo) override {
4346              m_sectionStack.push_back(_sectionInfo);
4347          }
4348          void sectionEnded(SectionStats const&amp; &amp;bsol;* _sectionStats */) override {
4349              m_sectionStack.pop_back();
4350          }
4351          void testCaseEnded(TestCaseStats const&amp; &amp;bsol;* _testCaseStats */) override {
4352              currentTestCaseInfo.reset();
4353          }
4354          void testGroupEnded(TestGroupStats const&amp; &amp;bsol;* _testGroupStats */) override {
4355              currentGroupInfo.reset();
4356          }
4357          void testRunEnded(TestRunStats const&amp; &amp;bsol;* _testRunStats */) override {
4358              currentTestCaseInfo.reset();
4359              currentGroupInfo.reset();
4360              currentTestRunInfo.reset();
4361          }
4362          void skipTest(TestCaseInfo const&amp;) override {
4363          }
4364          IConfigPtr m_config;
4365          std::ostream&amp; stream;
4366          LazyStat&lt;TestRunInfo&gt; currentTestRunInfo;
4367          LazyStat&lt;GroupInfo&gt; currentGroupInfo;
4368          LazyStat&lt;TestCaseInfo&gt; currentTestCaseInfo;
4369          std::vector&lt;SectionInfo&gt; m_sectionStack;
4370          ReporterPreferences m_reporterPrefs;
4371      };
4372      template&lt;typename DerivedT&gt;
4373      struct CumulativeReporterBase : IStreamingReporter {
4374          template&lt;typename T, typename ChildNodeT&gt;
4375          struct Node {
4376              explicit Node( T const&amp; _value ) : value( _value ) {}
4377              virtual ~Node() {}
4378              using ChildNodes = std::vector&lt;std::shared_ptr&lt;ChildNodeT&gt;&gt;;
4379              T value;
4380              ChildNodes children;
4381          };
4382          struct SectionNode {
4383              explicit SectionNode(SectionStats const&amp; _stats) : stats(_stats) {}
4384              virtual ~SectionNode() = default;
4385              bool operator == (SectionNode const&amp; other) const {
4386                  return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
4387              }
4388              bool operator == (std::shared_ptr&lt;SectionNode&gt; const&amp; other) const {
4389                  return operator==(*other);
4390              }
4391              SectionStats stats;
4392              using ChildSections = std::vector&lt;std::shared_ptr&lt;SectionNode&gt;&gt;;
4393              using Assertions = std::vector&lt;AssertionStats&gt;;
4394              ChildSections childSections;
4395              Assertions assertions;
4396              std::string stdOut;
4397              std::string stdErr;
4398          };
4399          struct BySectionInfo {
4400              BySectionInfo( SectionInfo const&amp; other ) : m_other( other ) {}
4401              BySectionInfo( BySectionInfo const&amp; other ) : m_other( other.m_other ) {}
4402              bool operator() (std::shared_ptr&lt;SectionNode&gt; const&amp; node) const {
4403                  return ((node-&gt;stats.sectionInfo.name == m_other.name) &amp;&amp;
4404                          (node-&gt;stats.sectionInfo.lineInfo == m_other.lineInfo));
4405              }
4406              void operator=(BySectionInfo const&amp;) = delete;
4407          private:
4408              SectionInfo const&amp; m_other;
4409          };
4410          using TestCaseNode = Node&lt;TestCaseStats, SectionNode&gt;;
4411          using TestGroupNode = Node&lt;TestGroupStats, TestCaseNode&gt;;
4412          using TestRunNode = Node&lt;TestRunStats, TestGroupNode&gt;;
4413          CumulativeReporterBase( ReporterConfig const&amp; _config )
4414          :   m_config( _config.fullConfig() ),
4415              stream( _config.stream() )
4416          {
4417              m_reporterPrefs.shouldRedirectStdOut = false;
4418              if( !DerivedT::getSupportedVerbosities().count( m_config-&gt;verbosity() ) )
4419                  CATCH_ERROR( &quot;Verbosity level not supported by this reporter&quot; );
4420          }
4421          ~CumulativeReporterBase() override = default;
4422          ReporterPreferences getPreferences() const override {
4423              return m_reporterPrefs;
4424          }
4425          static std::set&lt;Verbosity&gt; getSupportedVerbosities() {
4426              return { Verbosity::Normal };
4427          }
4428          void testRunStarting( TestRunInfo const&amp; ) override {}
4429          void testGroupStarting( GroupInfo const&amp; ) override {}
4430          void testCaseStarting( TestCaseInfo const&amp; ) override {}
4431          void sectionStarting( SectionInfo const&amp; sectionInfo ) override {
4432              SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
4433              std::shared_ptr&lt;SectionNode&gt; node;
4434              if( m_sectionStack.empty() ) {
4435                  if( !m_rootSection )
4436                      m_rootSection = std::make_shared&lt;SectionNode&gt;( incompleteStats );
4437                  node = m_rootSection;
4438              }
4439              else {
4440                  SectionNode&amp; parentNode = *m_sectionStack.back();
4441                  auto it =
4442                      std::find_if(   parentNode.childSections.begin(),
4443                                      parentNode.childSections.end(),
4444                                      BySectionInfo( sectionInfo ) );
4445                  if( it == parentNode.childSections.end() ) {
4446                      node = std::make_shared&lt;SectionNode&gt;( incompleteStats );
4447                      parentNode.childSections.push_back( node );
4448                  }
4449                  else
4450                      node = *it;
4451              }
4452              m_sectionStack.push_back( node );
4453              m_deepestSection = std::move(node);
4454          }
4455          void assertionStarting(AssertionInfo const&amp;) override {}
4456          bool assertionEnded(AssertionStats const&amp; assertionStats) override {
4457              assert(!m_sectionStack.empty());
4458              prepareExpandedExpression(const_cast&lt;AssertionResult&amp;&gt;( assertionStats.assertionResult ) );
4459              SectionNode&amp; sectionNode = *m_sectionStack.back();
4460              sectionNode.assertions.push_back(assertionStats);
4461              return true;
4462          }
4463          void sectionEnded(SectionStats const&amp; sectionStats) override {
4464              assert(!m_sectionStack.empty());
4465              SectionNode&amp; node = *m_sectionStack.back();
4466              node.stats = sectionStats;
4467              m_sectionStack.pop_back();
4468          }
4469          void testCaseEnded(TestCaseStats const&amp; testCaseStats) override {
4470              auto node = std::make_shared&lt;TestCaseNode&gt;(testCaseStats);
4471              assert(m_sectionStack.size() == 0);
4472              node-&gt;children.push_back(m_rootSection);
4473              m_testCases.push_back(node);
4474              m_rootSection.reset();
4475              assert(m_deepestSection);
4476              m_deepestSection-&gt;stdOut = testCaseStats.stdOut;
4477              m_deepestSection-&gt;stdErr = testCaseStats.stdErr;
4478          }
4479          void testGroupEnded(TestGroupStats const&amp; testGroupStats) override {
4480              auto node = std::make_shared&lt;TestGroupNode&gt;(testGroupStats);
4481              node-&gt;children.swap(m_testCases);
4482              m_testGroups.push_back(node);
4483          }
4484          void testRunEnded(TestRunStats const&amp; testRunStats) override {
4485              auto node = std::make_shared&lt;TestRunNode&gt;(testRunStats);
4486              node-&gt;children.swap(m_testGroups);
4487              m_testRuns.push_back(node);
4488              testRunEndedCumulative();
4489          }
4490          virtual void testRunEndedCumulative() = 0;
4491          void skipTest(TestCaseInfo const&amp;) override {}
4492          IConfigPtr m_config;
4493          std::ostream&amp; stream;
4494          std::vector&lt;AssertionStats&gt; m_assertions;
4495          std::vector&lt;std::vector&lt;std::shared_ptr&lt;SectionNode&gt;&gt;&gt; m_sections;
4496          std::vector&lt;std::shared_ptr&lt;TestCaseNode&gt;&gt; m_testCases;
4497          std::vector&lt;std::shared_ptr&lt;TestGroupNode&gt;&gt; m_testGroups;
4498          std::vector&lt;std::shared_ptr&lt;TestRunNode&gt;&gt; m_testRuns;
4499          std::shared_ptr&lt;SectionNode&gt; m_rootSection;
4500          std::shared_ptr&lt;SectionNode&gt; m_deepestSection;
4501          std::vector&lt;std::shared_ptr&lt;SectionNode&gt;&gt; m_sectionStack;
4502          ReporterPreferences m_reporterPrefs;
4503      };
4504      template&lt;char C&gt;
4505      char const* getLineOfChars() {
4506          static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
4507          if( !*line ) {
4508              std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
4509              line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
4510          }
4511          return line;
4512      }
4513      struct TestEventListenerBase : StreamingReporterBase&lt;TestEventListenerBase&gt; {
4514          TestEventListenerBase( ReporterConfig const&amp; _config );
4515          static std::set&lt;Verbosity&gt; getSupportedVerbosities();
4516          void assertionStarting(AssertionInfo const&amp;) override;
4517          bool assertionEnded(AssertionStats const&amp;) override;
4518      };
4519  } 
4520  namespace Catch {
4521      struct Colour {
4522          enum Code {
4523              None = 0,
4524              White,
4525              Red,
4526              Green,
4527              Blue,
4528              Cyan,
4529              Yellow,
4530              Grey,
4531              Bright = 0x10,
4532              BrightRed = Bright | Red,
4533              BrightGreen = Bright | Green,
4534              LightGrey = Bright | Grey,
4535              BrightWhite = Bright | White,
4536              BrightYellow = Bright | Yellow,
4537              FileName = LightGrey,
4538              Warning = BrightYellow,
4539              ResultError = BrightRed,
4540              ResultSuccess = BrightGreen,
4541              ResultExpectedFailure = Warning,
4542              Error = BrightRed,
4543              Success = Green,
4544              OriginalExpression = Cyan,
4545              ReconstructedExpression = BrightYellow,
4546              SecondaryText = LightGrey,
4547              Headers = White
4548          };
4549          Colour( Code _colourCode );
4550          Colour( Colour&amp;&amp; other ) noexcept;
4551          Colour&amp; operator=( Colour&amp;&amp; other ) noexcept;
4552          ~Colour();
4553          static void use( Code _colourCode );
4554      private:
4555          bool m_moved = false;
4556      };
4557      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Colour const&amp; );
4558  } 
4559  namespace Catch {
4560      template&lt;typename T&gt;
4561      class ReporterRegistrar {
4562          class ReporterFactory : public IReporterFactory {
4563              IStreamingReporterPtr create( ReporterConfig const&amp; config ) const override {
4564                  return std::unique_ptr&lt;T&gt;( new T( config ) );
4565              }
4566              std::string getDescription() const override {
4567                  return T::getDescription();
4568              }
4569          };
4570      public:
4571          explicit ReporterRegistrar( std::string const&amp; name ) {
4572              getMutableRegistryHub().registerReporter( name, std::make_shared&lt;ReporterFactory&gt;() );
4573          }
4574      };
4575      template&lt;typename T&gt;
4576      class ListenerRegistrar {
4577          class ListenerFactory : public IReporterFactory {
4578              IStreamingReporterPtr create( ReporterConfig const&amp; config ) const override {
4579                  return std::unique_ptr&lt;T&gt;( new T( config ) );
4580              }
4581              std::string getDescription() const override {
4582                  return std::string();
4583              }
4584          };
4585      public:
4586          ListenerRegistrar() {
4587              getMutableRegistryHub().registerListener( std::make_shared&lt;ListenerFactory&gt;() );
4588          }
4589      };
4590  }
4591  #if !defined(CATCH_CONFIG_DISABLE)
4592  #define CATCH_REGISTER_REPORTER( name, reporterType ) \
4593      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION         \
4594      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
4595      namespace{ Catch::ReporterRegistrar&lt;reporterType&gt; catch_internal_RegistrarFor##reporterType( name ); } \
4596      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
4597  #define CATCH_REGISTER_LISTENER( listenerType ) \
4598      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION   \
4599      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS    \
4600      namespace{ Catch::ListenerRegistrar&lt;listenerType&gt; catch_internal_RegistrarFor##listenerType; } \
4601      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
4602  #else 
4603  #define CATCH_REGISTER_REPORTER(name, reporterType)
4604  #define CATCH_REGISTER_LISTENER(listenerType)
4605  #endif 
4606  namespace Catch {
4607      struct CompactReporter : StreamingReporterBase&lt;CompactReporter&gt; {
4608          using StreamingReporterBase::StreamingReporterBase;
4609          ~CompactReporter() override;
4610          static std::string getDescription();
4611          void noMatchingTestCases(std::string const&amp; spec) override;
4612          void assertionStarting(AssertionInfo const&amp;) override;
4613          bool assertionEnded(AssertionStats const&amp; _assertionStats) override;
4614          void sectionEnded(SectionStats const&amp; _sectionStats) override;
4615          void testRunEnded(TestRunStats const&amp; _testRunStats) override;
4616      };
4617  } 
4618  #if defined(_MSC_VER)
4619  #pragma warning(push)
4620  #pragma warning(disable:4061) 
4621  #endif
4622  namespace Catch {
4623      struct SummaryColumn;
4624      class TablePrinter;
4625      struct ConsoleReporter : StreamingReporterBase&lt;ConsoleReporter&gt; {
4626          std::unique_ptr&lt;TablePrinter&gt; m_tablePrinter;
4627          ConsoleReporter(ReporterConfig const&amp; config);
4628          ~ConsoleReporter() override;
4629          static std::string getDescription();
4630          void noMatchingTestCases(std::string const&amp; spec) override;
4631          void reportInvalidArguments(std::string const&amp;arg) override;
4632          void assertionStarting(AssertionInfo const&amp;) override;
4633          bool assertionEnded(AssertionStats const&amp; _assertionStats) override;
4634          void sectionStarting(SectionInfo const&amp; _sectionInfo) override;
4635          void sectionEnded(SectionStats const&amp; _sectionStats) override;
4636  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4637          void benchmarkPreparing(std::string const&amp; name) override;
4638          void benchmarkStarting(BenchmarkInfo const&amp; info) override;
4639          void benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) override;
4640          void benchmarkFailed(std::string const&amp; error) override;
4641  #endif 
4642          void testCaseEnded(TestCaseStats const&amp; _testCaseStats) override;
4643          void testGroupEnded(TestGroupStats const&amp; _testGroupStats) override;
4644          void testRunEnded(TestRunStats const&amp; _testRunStats) override;
4645          void testRunStarting(TestRunInfo const&amp; _testRunInfo) override;
4646      private:
4647          void lazyPrint();
4648          void lazyPrintWithoutClosingBenchmarkTable();
4649          void lazyPrintRunInfo();
4650          void lazyPrintGroupInfo();
4651          void printTestCaseAndSectionHeader();
4652          void printClosedHeader(std::string const&amp; _name);
4653          void printOpenHeader(std::string const&amp; _name);
4654          void printHeaderString(std::string const&amp; _string, std::size_t indent = 0);
4655          void printTotals(Totals const&amp; totals);
4656          void printSummaryRow(std::string const&amp; label, std::vector&lt;SummaryColumn&gt; const&amp; cols, std::size_t row);
4657          void printTotalsDivider(Totals const&amp; totals);
4658          void printSummaryDivider();
4659          void printTestFilters();
4660      private:
4661          bool m_headerPrinted = false;
4662      };
4663  } 
4664  #if defined(_MSC_VER)
4665  #pragma warning(pop)
4666  #endif
4667  #include &lt;vector&gt;
4668  namespace Catch {
4669      enum class XmlFormatting {
4670          None = 0x00,
4671          Indent = 0x01,
4672          Newline = 0x02,
4673      };
4674      XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);
4675      XmlFormatting operator &amp; (XmlFormatting lhs, XmlFormatting rhs);
4676      class XmlEncode {
4677      public:
4678          enum ForWhat { ForTextNodes, ForAttributes };
4679          XmlEncode( std::string const&amp; str, ForWhat forWhat = ForTextNodes );
4680          void encodeTo( std::ostream&amp; os ) const;
4681          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode );
4682      private:
4683          std::string m_str;
4684          ForWhat m_forWhat;
4685      };
4686      class XmlWriter {
4687      public:
4688          class ScopedElement {
4689          public:
4690              ScopedElement( XmlWriter* writer, XmlFormatting fmt );
4691              ScopedElement( ScopedElement&amp;&amp; other ) noexcept;
4692              ScopedElement&amp; operator=( ScopedElement&amp;&amp; other ) noexcept;
4693              ~ScopedElement();
4694              ScopedElement&amp; writeText( std::string const&amp; text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );
4695              template&lt;typename T&gt;
4696              ScopedElement&amp; writeAttribute( std::string const&amp; name, T const&amp; attribute ) {
4697                  m_writer-&gt;writeAttribute( name, attribute );
4698                  return *this;
4699              }
4700          private:
4701              mutable XmlWriter* m_writer = nullptr;
4702              XmlFormatting m_fmt;
4703          };
4704          XmlWriter( std::ostream&amp; os = Catch::cout() );
4705          ~XmlWriter();
4706          XmlWriter( XmlWriter const&amp; ) = delete;
4707          XmlWriter&amp; operator=( XmlWriter const&amp; ) = delete;
4708          XmlWriter&amp; startElement( std::string const&amp; name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4709          ScopedElement scopedElement( std::string const&amp; name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4710          XmlWriter&amp; endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4711          XmlWriter&amp; writeAttribute( std::string const&amp; name, std::string const&amp; attribute );
4712          XmlWriter&amp; writeAttribute( std::string const&amp; name, bool attribute );
4713          template&lt;typename T&gt;
4714          XmlWriter&amp; writeAttribute( std::string const&amp; name, T const&amp; attribute ) {
4715              ReusableStringStream rss;
4716              rss &lt;&lt; attribute;
4717              return writeAttribute( name, rss.str() );
4718          }
4719          XmlWriter&amp; writeText( std::string const&amp; text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4720          XmlWriter&amp; writeComment(std::string const&amp; text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4721          void writeStylesheetRef( std::string const&amp; url );
4722          XmlWriter&amp; writeBlankLine();
4723          void ensureTagClosed();
4724      private:
4725          void applyFormatting(XmlFormatting fmt);
4726          void writeDeclaration();
4727          void newlineIfNecessary();
4728          bool m_tagIsOpen = false;
4729          bool m_needsNewline = false;
4730          std::vector&lt;std::string&gt; m_tags;
4731          std::string m_indent;
4732          std::ostream&amp; m_os;
4733      };
4734  }
4735  namespace Catch {
4736      class JunitReporter : public CumulativeReporterBase&lt;JunitReporter&gt; {
4737      public:
4738          JunitReporter(ReporterConfig const&amp; _config);
4739          ~JunitReporter() override;
4740          static std::string getDescription();
4741          void noMatchingTestCases(std::string const&amp; &amp;bsol;*spec*/) override;
4742          void testRunStarting(TestRunInfo const&amp; runInfo) override;
4743          void testGroupStarting(GroupInfo const&amp; groupInfo) override;
4744          void testCaseStarting(TestCaseInfo const&amp; testCaseInfo) override;
4745          bool assertionEnded(AssertionStats const&amp; assertionStats) override;
4746          void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;
4747          void testGroupEnded(TestGroupStats const&amp; testGroupStats) override;
4748          void testRunEndedCumulative() override;
4749          void writeGroup(TestGroupNode const&amp; groupNode, double suiteTime);
4750          void writeTestCase(TestCaseNode const&amp; testCaseNode);
4751          void writeSection( std::string const&amp; className,
4752                             std::string const&amp; rootName,
4753                             SectionNode const&amp; sectionNode,
4754                             bool testOkToFail );
4755          void writeAssertions(SectionNode const&amp; sectionNode);
4756          void writeAssertion(AssertionStats const&amp; stats);
4757          XmlWriter xml;
4758          Timer suiteTimer;
4759          std::string stdOutForSuite;
4760          std::string stdErrForSuite;
4761          unsigned int unexpectedExceptions = 0;
4762          bool m_okToFail = false;
4763      };
4764  } 
4765  namespace Catch {
4766      class XmlReporter : public StreamingReporterBase&lt;XmlReporter&gt; {
4767      public:
4768          XmlReporter(ReporterConfig const&amp; _config);
4769          ~XmlReporter() override;
4770          static std::string getDescription();
4771          virtual std::string getStylesheetRef() const;
4772          void writeSourceInfo(SourceLineInfo const&amp; sourceInfo);
4773      public: 
4774          void noMatchingTestCases(std::string const&amp; s) override;
4775          void testRunStarting(TestRunInfo const&amp; testInfo) override;
4776          void testGroupStarting(GroupInfo const&amp; groupInfo) override;
4777          void testCaseStarting(TestCaseInfo const&amp; testInfo) override;
4778          void sectionStarting(SectionInfo const&amp; sectionInfo) override;
4779          void assertionStarting(AssertionInfo const&amp;) override;
4780          bool assertionEnded(AssertionStats const&amp; assertionStats) override;
4781          void sectionEnded(SectionStats const&amp; sectionStats) override;
4782          void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;
4783          void testGroupEnded(TestGroupStats const&amp; testGroupStats) override;
4784          void testRunEnded(TestRunStats const&amp; testRunStats) override;
4785  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4786          void benchmarkPreparing(std::string const&amp; name) override;
4787          void benchmarkStarting(BenchmarkInfo const&amp;) override;
4788          void benchmarkEnded(BenchmarkStats&lt;&gt; const&amp;) override;
4789          void benchmarkFailed(std::string const&amp;) override;
4790  #endif 
4791      private:
4792          Timer m_testCaseTimer;
4793          XmlWriter m_xml;
4794          int m_sectionDepth = 0;
4795      };
4796  } 
4797  #endif
4798  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4799  #include &lt;chrono&gt;
4800  #include &lt;ratio&gt;
4801  namespace Catch {
4802      namespace Benchmark {
4803          template &lt;typename Clock&gt;
4804          using ClockDuration = typename Clock::duration;
4805          template &lt;typename Clock&gt;
4806          using FloatDuration = std::chrono::duration&lt;double, typename Clock::period&gt;;
4807          template &lt;typename Clock&gt;
4808          using TimePoint = typename Clock::time_point;
4809          using default_clock = std::chrono::steady_clock;
4810          template &lt;typename Clock&gt;
4811          struct now {
4812              TimePoint&lt;Clock&gt; operator()() const {
4813                  return Clock::now();
4814              }
4815          };
4816          using fp_seconds = std::chrono::duration&lt;double, std::ratio&lt;1&gt;&gt;;
4817      } 
4818  } 
4819  #if defined(_MSC_VER)
4820  #   include &lt;atomic&gt; 
4821  #endif
4822  namespace Catch {
4823      namespace Benchmark {
4824  #if defined(__GNUC__) || defined(__clang__)
4825          template &lt;typename T&gt;
4826          inline void keep_memory(T* p) {
4827              asm volatile(&quot;&quot; : : &quot;g&quot;(p) : &quot;memory&quot;);
4828          }
4829          inline void keep_memory() {
4830              asm volatile(&quot;&quot; : : : &quot;memory&quot;);
4831          }
4832          namespace Detail {
4833              inline void optimizer_barrier() { keep_memory(); }
4834          } 
4835  #elif defined(_MSC_VER)
4836  #pragma optimize(&quot;&quot;, off)
4837          template &lt;typename T&gt;
4838          inline void keep_memory(T* p) {
4839              *reinterpret_cast&lt;char volatile*&gt;(p) = *reinterpret_cast&lt;char const volatile*&gt;(p);
4840          }
4841  #pragma optimize(&quot;&quot;, on)
4842          namespace Detail {
4843              inline void optimizer_barrier() {
4844                  std::atomic_thread_fence(std::memory_order_seq_cst);
4845              }
4846          } 
4847  #endif
4848          template &lt;typename T&gt;
4849          inline void deoptimize_value(T&amp;&amp; x) {
4850              keep_memory(&amp;x);
4851          }
4852          template &lt;typename Fn, typename... Args&gt;
4853          inline auto invoke_deoptimized(Fn&amp;&amp; fn, Args&amp;&amp;... args) -&gt; typename std::enable_if&lt;!std::is_same&lt;void, decltype(fn(args...))&gt;::value&gt;::type {
4854              deoptimize_value(std::forward&lt;Fn&gt;(fn) (std::forward&lt;Args...&gt;(args...)));
4855          }
4856          template &lt;typename Fn, typename... Args&gt;
4857          inline auto invoke_deoptimized(Fn&amp;&amp; fn, Args&amp;&amp;... args) -&gt; typename std::enable_if&lt;std::is_same&lt;void, decltype(fn(args...))&gt;::value&gt;::type {
4858              std::forward&lt;Fn&gt;(fn) (std::forward&lt;Args...&gt;(args...));
4859          }
4860      } 
4861  } 
4862  #include &lt;type_traits&gt;
4863  #include &lt;utility&gt;
4864  namespace Catch {
4865      namespace Benchmark {
4866          namespace Detail {
4867              template &lt;typename T&gt;
4868              struct CompleteType { using type = T; };
4869              template &lt;&gt;
4870              struct CompleteType&lt;void&gt; { struct type {}; };
4871              template &lt;typename T&gt;
4872              using CompleteType_t = typename CompleteType&lt;T&gt;::type;
4873              template &lt;typename Result&gt;
4874              struct CompleteInvoker {
4875                  template &lt;typename Fun, typename... Args&gt;
4876                  static Result invoke(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
4877                      return std::forward&lt;Fun&gt;(fun)(std::forward&lt;Args&gt;(args)...);
4878                  }
4879              };
4880              template &lt;&gt;
4881              struct CompleteInvoker&lt;void&gt; {
4882                  template &lt;typename Fun, typename... Args&gt;
4883                  static CompleteType_t&lt;void&gt; invoke(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
4884                      std::forward&lt;Fun&gt;(fun)(std::forward&lt;Args&gt;(args)...);
4885                      return {};
4886                  }
4887              };
4888              template &lt;typename Fun, typename... Args&gt;
4889              CompleteType_t&lt;FunctionReturnType&lt;Fun, Args...&gt;&gt; complete_invoke(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
4890                  return CompleteInvoker&lt;FunctionReturnType&lt;Fun, Args...&gt;&gt;::invoke(std::forward&lt;Fun&gt;(fun), std::forward&lt;Args&gt;(args)...);
4891              }
4892              const std::string benchmarkErrorMsg = &quot;a benchmark failed to run successfully&quot;;
4893          } 
4894          template &lt;typename Fun&gt;
4895          Detail::CompleteType_t&lt;FunctionReturnType&lt;Fun&gt;&gt; user_code(Fun&amp;&amp; fun) {
4896              CATCH_TRY{
4897                  return Detail::complete_invoke(std::forward&lt;Fun&gt;(fun));
4898              } CATCH_CATCH_ALL{
4899                  getResultCapture().benchmarkFailed(translateActiveException());
4900                  CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);
4901              }
4902          }
4903      } 
4904  } 
4905  namespace Catch {
4906      namespace Benchmark {
4907          namespace Detail {
4908              struct ChronometerConcept {
4909                  virtual void start() = 0;
4910                  virtual void finish() = 0;
4911                  virtual ~ChronometerConcept() = default;
4912              };
4913              template &lt;typename Clock&gt;
4914              struct ChronometerModel final : public ChronometerConcept {
4915                  void start() override { started = Clock::now(); }
4916                  void finish() override { finished = Clock::now(); }
4917                  ClockDuration&lt;Clock&gt; elapsed() const { return finished - started; }
4918                  TimePoint&lt;Clock&gt; started;
4919                  TimePoint&lt;Clock&gt; finished;
4920              };
4921          } 
4922          struct Chronometer {
4923          public:
4924              template &lt;typename Fun&gt;
4925              void measure(Fun&amp;&amp; fun) { measure(std::forward&lt;Fun&gt;(fun), is_callable&lt;Fun(int)&gt;()); }
4926              int runs() const { return k; }
4927              Chronometer(Detail::ChronometerConcept&amp; meter, int k)
4928                  : impl(&amp;meter)
4929                  , k(k) {}
4930          private:
4931              template &lt;typename Fun&gt;
4932              void measure(Fun&amp;&amp; fun, std::false_type) {
4933                  measure([&amp;fun](int) { return fun(); }, std::true_type());
4934              }
4935              template &lt;typename Fun&gt;
4936              void measure(Fun&amp;&amp; fun, std::true_type) {
4937                  Detail::optimizer_barrier();
4938                  impl-&gt;start();
4939                  for (int i = 0; i &lt; k; ++i) invoke_deoptimized(fun, i);
4940                  impl-&gt;finish();
4941                  Detail::optimizer_barrier();
4942              }
4943              Detail::ChronometerConcept* impl;
4944              int k;
4945          };
4946      } 
4947  } 
4948  namespace Catch {
4949      namespace Benchmark {
4950          template &lt;typename Duration&gt;
4951          struct EnvironmentEstimate {
4952              Duration mean;
4953              OutlierClassification outliers;
4954              template &lt;typename Duration2&gt;
4955              operator EnvironmentEstimate&lt;Duration2&gt;() const {
4956                  return { mean, outliers };
4957              }
4958          };
4959          template &lt;typename Clock&gt;
4960          struct Environment {
4961              using clock_type = Clock;
4962              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; clock_resolution;
4963              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; clock_cost;
4964          };
4965      } 
4966  } 
4967  #include &lt;cassert&gt;
4968  #include &lt;type_traits&gt;
4969  #include &lt;utility&gt;
4970  #include &lt;memory&gt;
4971  namespace Catch {
4972      namespace Benchmark {
4973          namespace Detail {
4974              template &lt;typename T&gt;
4975              using Decay = typename std::decay&lt;T&gt;::type;
4976              template &lt;typename T, typename U&gt;
4977              struct is_related
4978                  : std::is_same&lt;Decay&lt;T&gt;, Decay&lt;U&gt;&gt; {};
4979              struct BenchmarkFunction {
4980              private:
4981                  struct callable {
4982                      virtual void call(Chronometer meter) const = 0;
4983                      virtual callable* clone() const = 0;
4984                      virtual ~callable() = default;
4985                  };
4986                  template &lt;typename Fun&gt;
4987                  struct model : public callable {
4988                      model(Fun&amp;&amp; fun) : fun(std::move(fun)) {}
4989                      model(Fun const&amp; fun) : fun(fun) {}
4990                      model&lt;Fun&gt;* clone() const override { return new model&lt;Fun&gt;(*this); }
4991                      void call(Chronometer meter) const override {
4992                          call(meter, is_callable&lt;Fun(Chronometer)&gt;());
4993                      }
4994                      void call(Chronometer meter, std::true_type) const {
4995                          fun(meter);
4996                      }
4997                      void call(Chronometer meter, std::false_type) const {
4998                          meter.measure(fun);
4999                      }
5000                      Fun fun;
5001                  };
5002                  struct do_nothing { void operator()() const {} };
5003                  template &lt;typename T&gt;
5004                  BenchmarkFunction(model&lt;T&gt;* c) : f(c) {}
5005              public:
5006                  BenchmarkFunction()
5007                      : f(new model&lt;do_nothing&gt;{ {} }) {}
5008                  template &lt;typename Fun,
5009                      typename std::enable_if&lt;!is_related&lt;Fun, BenchmarkFunction&gt;::value, int&gt;::type = 0&gt;
5010                      BenchmarkFunction(Fun&amp;&amp; fun)
5011                      : f(new model&lt;typename std::decay&lt;Fun&gt;::type&gt;(std::forward&lt;Fun&gt;(fun))) {}
5012                  BenchmarkFunction(BenchmarkFunction&amp;&amp; that)
5013                      : f(std::move(that.f)) {}
5014                  BenchmarkFunction(BenchmarkFunction const&amp; that)
5015                      : f(that.f-&gt;clone()) {}
5016                  BenchmarkFunction&amp; operator=(BenchmarkFunction&amp;&amp; that) {
5017                      f = std::move(that.f);
5018                      return *this;
5019                  }
5020                  BenchmarkFunction&amp; operator=(BenchmarkFunction const&amp; that) {
5021                      f.reset(that.f-&gt;clone());
5022                      return *this;
5023                  }
5024                  void operator()(Chronometer meter) const { f-&gt;call(meter); }
5025              private:
5026                  std::unique_ptr&lt;callable&gt; f;
5027              };
5028          } 
5029      } 
5030  } 
5031  #include &lt;type_traits&gt;
5032  #include &lt;utility&gt;
5033  namespace Catch {
5034      namespace Benchmark {
5035          namespace Detail {
5036              template &lt;typename Fun&gt;
5037              struct repeater {
5038                  void operator()(int k) const {
5039                      for (int i = 0; i &lt; k; ++i) {
5040                          fun();
5041                      }
5042                  }
5043                  Fun fun;
5044              };
5045              template &lt;typename Fun&gt;
5046              repeater&lt;typename std::decay&lt;Fun&gt;::type&gt; repeat(Fun&amp;&amp; fun) {
5047                  return { std::forward&lt;Fun&gt;(fun) };
5048              }
5049          } 
5050      } 
5051  } 
5052  #include &lt;tuple&gt;
5053  #include &lt;type_traits&gt;
5054  namespace Catch {
5055      namespace Benchmark {
5056          template &lt;typename Duration, typename Result&gt;
5057          struct Timing {
5058              Duration elapsed;
5059              Result result;
5060              int iterations;
5061          };
5062          template &lt;typename Clock, typename Func, typename... Args&gt;
5063          using TimingOf = Timing&lt;ClockDuration&lt;Clock&gt;, Detail::CompleteType_t&lt;FunctionReturnType&lt;Func, Args...&gt;&gt;&gt;;
5064      } 
5065  } 
5066  #include &lt;utility&gt;
5067  namespace Catch {
5068      namespace Benchmark {
5069          namespace Detail {
5070              template &lt;typename Clock, typename Fun, typename... Args&gt;
5071              TimingOf&lt;Clock, Fun, Args...&gt; measure(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
5072                  auto start = Clock::now();
5073                  auto&amp;&amp; r = Detail::complete_invoke(fun, std::forward&lt;Args&gt;(args)...);
5074                  auto end = Clock::now();
5075                  auto delta = end - start;
5076                  return { delta, std::forward&lt;decltype(r)&gt;(r), 1 };
5077              }
5078          } 
5079      } 
5080  } 
5081  #include &lt;utility&gt;
5082  #include &lt;type_traits&gt;
5083  namespace Catch {
5084      namespace Benchmark {
5085          namespace Detail {
5086              template &lt;typename Clock, typename Fun&gt;
5087              TimingOf&lt;Clock, Fun, int&gt; measure_one(Fun&amp;&amp; fun, int iters, std::false_type) {
5088                  return Detail::measure&lt;Clock&gt;(fun, iters);
5089              }
5090              template &lt;typename Clock, typename Fun&gt;
5091              TimingOf&lt;Clock, Fun, Chronometer&gt; measure_one(Fun&amp;&amp; fun, int iters, std::true_type) {
5092                  Detail::ChronometerModel&lt;Clock&gt; meter;
5093                  auto&amp;&amp; result = Detail::complete_invoke(fun, Chronometer(meter, iters));
5094                  return { meter.elapsed(), std::move(result), iters };
5095              }
5096              template &lt;typename Clock, typename Fun&gt;
5097              using run_for_at_least_argument_t = typename std::conditional&lt;is_callable&lt;Fun(Chronometer)&gt;::value, Chronometer, int&gt;::type;
5098              struct optimized_away_error : std::exception {
5099                  const char* what() const noexcept override {
5100                      return &quot;could not measure benchmark, maybe it was optimized away&quot;;
5101                  }
5102              };
5103              template &lt;typename Clock, typename Fun&gt;
5104              TimingOf&lt;Clock, Fun, run_for_at_least_argument_t&lt;Clock, Fun&gt;&gt; run_for_at_least(ClockDuration&lt;Clock&gt; how_long, int seed, Fun&amp;&amp; fun) {
5105                  auto iters = seed;
5106                  while (iters &lt; (1 &lt;&lt; 30)) {
5107                      auto&amp;&amp; Timing = measure_one&lt;Clock&gt;(fun, iters, is_callable&lt;Fun(Chronometer)&gt;());
5108                      if (Timing.elapsed &gt;= how_long) {
5109                          return { Timing.elapsed, std::move(Timing.result), iters };
5110                      }
5111                      iters *= 2;
5112                  }
5113                  Catch::throw_exception(optimized_away_error{});
5114              }
5115          } 
5116      } 
5117  } 
5118  #include &lt;algorithm&gt;
5119  #include &lt;iterator&gt;
5120  namespace Catch {
5121      namespace Benchmark {
5122          template &lt;typename Duration&gt;
5123          struct ExecutionPlan {
5124              int iterations_per_sample;
5125              Duration estimated_duration;
5126              Detail::BenchmarkFunction benchmark;
5127              Duration warmup_time;
5128              int warmup_iterations;
5129              template &lt;typename Duration2&gt;
5130              operator ExecutionPlan&lt;Duration2&gt;() const {
5131                  return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };
5132              }
5133              template &lt;typename Clock&gt;
5134              std::vector&lt;FloatDuration&lt;Clock&gt;&gt; run(const IConfig &amp;cfg, Environment&lt;FloatDuration&lt;Clock&gt;&gt; env) const {
5135                  Detail::run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(warmup_time), warmup_iterations, Detail::repeat(now&lt;Clock&gt;{}));
5136                  std::vector&lt;FloatDuration&lt;Clock&gt;&gt; times;
5137                  times.reserve(cfg.benchmarkSamples());
5138                  std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {
5139                      Detail::ChronometerModel&lt;Clock&gt; model;
5140                      this-&gt;benchmark(Chronometer(model, iterations_per_sample));
5141                      auto sample_time = model.elapsed() - env.clock_cost.mean;
5142                      if (sample_time &lt; FloatDuration&lt;Clock&gt;::zero()) sample_time = FloatDuration&lt;Clock&gt;::zero();
5143                      return sample_time / iterations_per_sample;
5144                  });
5145                  return times;
5146              }
5147          };
5148      } 
5149  } 
5150  #include &lt;algorithm&gt;
5151  #include &lt;functional&gt;
5152  #include &lt;vector&gt;
5153  #include &lt;iterator&gt;
5154  #include &lt;numeric&gt;
5155  #include &lt;tuple&gt;
5156  #include &lt;cmath&gt;
5157  #include &lt;utility&gt;
5158  #include &lt;cstddef&gt;
5159  #include &lt;random&gt;
5160  namespace Catch {
5161      namespace Benchmark {
5162          namespace Detail {
5163              using sample = std::vector&lt;double&gt;;
5164              double weighted_average_quantile(int k, int q, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last);
5165              template &lt;typename Iterator&gt;
5166              OutlierClassification classify_outliers(Iterator first, Iterator last) {
5167                  std::vector&lt;double&gt; copy(first, last);
5168                  auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());
5169                  auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());
5170                  auto iqr = q3 - q1;
5171                  auto los = q1 - (iqr * 3.);
5172                  auto lom = q1 - (iqr * 1.5);
5173                  auto him = q3 + (iqr * 1.5);
5174                  auto his = q3 + (iqr * 3.);
5175                  OutlierClassification o;
5176                  for (; first != last; ++first) {
5177                      auto&amp;&amp; t = *first;
5178                      if (t &lt; los) ++o.low_severe;
5179                      else if (t &lt; lom) ++o.low_mild;
5180                      else if (t &gt; his) ++o.high_severe;
5181                      else if (t &gt; him) ++o.high_mild;
5182                      ++o.samples_seen;
5183                  }
5184                  return o;
5185              }
5186              template &lt;typename Iterator&gt;
5187              double mean(Iterator first, Iterator last) {
5188                  auto count = last - first;
5189                  double sum = std::accumulate(first, last, 0.);
5190                  return sum / count;
5191              }
5192              template &lt;typename URng, typename Iterator, typename Estimator&gt;
5193              sample resample(URng&amp; rng, int resamples, Iterator first, Iterator last, Estimator&amp; estimator) {
5194                  auto n = last - first;
5195                  std::uniform_int_distribution&lt;decltype(n)&gt; dist(0, n - 1);
5196                  sample out;
5197                  out.reserve(resamples);
5198                  std::generate_n(std::back_inserter(out), resamples, [n, first, &amp;estimator, &amp;dist, &amp;rng] {
5199                      std::vector&lt;double&gt; resampled;
5200                      resampled.reserve(n);
5201                      std::generate_n(std::back_inserter(resampled), n, [first, &amp;dist, &amp;rng] { return first[dist(rng)]; });
5202                      return estimator(resampled.begin(), resampled.end());
5203                  });
5204                  std::sort(out.begin(), out.end());
5205                  return out;
5206              }
5207              template &lt;typename Estimator, typename Iterator&gt;
5208              sample jackknife(Estimator&amp;&amp; estimator, Iterator first, Iterator last) {
5209                  auto n = last - first;
5210                  auto second = std::next(first);
5211                  sample results;
5212                  results.reserve(n);
5213                  for (auto it = first; it != last; ++it) {
5214                      std::iter_swap(it, first);
5215                      results.push_back(estimator(second, last));
5216                  }
5217                  return results;
5218              }
5219              inline double normal_cdf(double x) {
5220                  return std::erfc(-x / std::sqrt(2.0)) / 2.0;
5221              }
5222              double erfc_inv(double x);
5223              double normal_quantile(double p);
5224              template &lt;typename Iterator, typename Estimator&gt;
5225              Estimate&lt;double&gt; bootstrap(double confidence_level, Iterator first, Iterator last, sample const&amp; resample, Estimator&amp;&amp; estimator) {
5226                  auto n_samples = last - first;
5227                  double point = estimator(first, last);
5228                  if (n_samples == 1) return { point, point, point, confidence_level };
5229                  sample jack = jackknife(estimator, first, last);
5230                  double jack_mean = mean(jack.begin(), jack.end());
5231                  double sum_squares, sum_cubes;
5232                  std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair&lt;double, double&gt; sqcb, double x) -&gt; std::pair&lt;double, double&gt; {
5233                      auto d = jack_mean - x;
5234                      auto d2 = d * d;
5235                      auto d3 = d2 * d;
5236                      return { sqcb.first + d2, sqcb.second + d3 };
5237                  });
5238                  double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));
5239                  int n = static_cast&lt;int&gt;(resample.size());
5240                  double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x &lt; point; }) / (double)n;
5241                  if (prob_n == 0) return { point, point, point, confidence_level };
5242                  double bias = normal_quantile(prob_n);
5243                  double z1 = normal_quantile((1. - confidence_level) / 2.);
5244                  auto cumn = [n](double x) -&gt; int {
5245                      return std::lround(normal_cdf(x) * n); };
5246                  auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };
5247                  double b1 = bias + z1;
5248                  double b2 = bias - z1;
5249                  double a1 = a(b1);
5250                  double a2 = a(b2);
5251                  auto lo = (std::max)(cumn(a1), 0);
5252                  auto hi = (std::min)(cumn(a2), n - 1);
5253                  return { point, resample[lo], resample[hi], confidence_level };
5254              }
5255              double outlier_variance(Estimate&lt;double&gt; mean, Estimate&lt;double&gt; stddev, int n);
5256              struct bootstrap_analysis {
5257                  Estimate&lt;double&gt; mean;
5258                  Estimate&lt;double&gt; standard_deviation;
5259                  double outlier_variance;
5260              };
5261              bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last);
5262          } 
5263      } 
5264  } 
5265  #include &lt;algorithm&gt;
5266  #include &lt;iterator&gt;
5267  #include &lt;tuple&gt;
5268  #include &lt;vector&gt;
5269  #include &lt;cmath&gt;
5270  namespace Catch {
5271      namespace Benchmark {
5272          namespace Detail {
5273              template &lt;typename Clock&gt;
5274              std::vector&lt;double&gt; resolution(int k) {
5275                  std::vector&lt;TimePoint&lt;Clock&gt;&gt; times;
5276                  times.reserve(k + 1);
5277                  std::generate_n(std::back_inserter(times), k + 1, now&lt;Clock&gt;{});
5278                  std::vector&lt;double&gt; deltas;
5279                  deltas.reserve(k);
5280                  std::transform(std::next(times.begin()), times.end(), times.begin(),
5281                      std::back_inserter(deltas),
5282                      [](TimePoint&lt;Clock&gt; a, TimePoint&lt;Clock&gt; b) { return static_cast&lt;double&gt;((a - b).count()); });
5283                  return deltas;
5284              }
5285              const auto warmup_iterations = 10000;
5286              const auto warmup_time = std::chrono::milliseconds(100);
5287              const auto minimum_ticks = 1000;
5288              const auto warmup_seed = 10000;
5289              const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);
5290              const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);
5291              const auto clock_cost_estimation_tick_limit = 100000;
5292              const auto clock_cost_estimation_time = std::chrono::milliseconds(10);
5293              const auto clock_cost_estimation_iterations = 10000;
5294              template &lt;typename Clock&gt;
5295              int warmup() {
5296                  return run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(warmup_time), warmup_seed, &amp;resolution&lt;Clock&gt;)
5297                      .iterations;
5298              }
5299              template &lt;typename Clock&gt;
5300              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; estimate_clock_resolution(int iterations) {
5301                  auto r = run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(clock_resolution_estimation_time), iterations, &amp;resolution&lt;Clock&gt;)
5302                      .result;
5303                  return {
5304                      FloatDuration&lt;Clock&gt;(mean(r.begin(), r.end())),
5305                      classify_outliers(r.begin(), r.end()),
5306                  };
5307              }
5308              template &lt;typename Clock&gt;
5309              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; estimate_clock_cost(FloatDuration&lt;Clock&gt; resolution) {
5310                  auto time_limit = (std::min)(
5311                      resolution * clock_cost_estimation_tick_limit,
5312                      FloatDuration&lt;Clock&gt;(clock_cost_estimation_time_limit));
5313                  auto time_clock = [](int k) {
5314                      return Detail::measure&lt;Clock&gt;([k] {
5315                          for (int i = 0; i &lt; k; ++i) {
5316                              volatile auto ignored = Clock::now();
5317                              (void)ignored;
5318                          }
5319                      }).elapsed;
5320                  };
5321                  time_clock(1);
5322                  int iters = clock_cost_estimation_iterations;
5323                  auto&amp;&amp; r = run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(clock_cost_estimation_time), iters, time_clock);
5324                  std::vector&lt;double&gt; times;
5325                  int nsamples = static_cast&lt;int&gt;(std::ceil(time_limit / r.elapsed));
5326                  times.reserve(nsamples);
5327                  std::generate_n(std::back_inserter(times), nsamples, [time_clock, &amp;r] {
5328                      return static_cast&lt;double&gt;((time_clock(r.iterations) / r.iterations).count());
5329                  });
5330                  return {
5331                      FloatDuration&lt;Clock&gt;(mean(times.begin(), times.end())),
5332                      classify_outliers(times.begin(), times.end()),
5333                  };
5334              }
5335              template &lt;typename Clock&gt;
5336              Environment&lt;FloatDuration&lt;Clock&gt;&gt; measure_environment() {
5337                  static Environment&lt;FloatDuration&lt;Clock&gt;&gt;* env = nullptr;
5338                  if (env) {
5339                      return *env;
5340                  }
5341                  auto iters = Detail::warmup&lt;Clock&gt;();
5342                  auto resolution = Detail::estimate_clock_resolution&lt;Clock&gt;(iters);
5343                  auto cost = Detail::estimate_clock_cost&lt;Clock&gt;(resolution.mean);
5344                  env = new Environment&lt;FloatDuration&lt;Clock&gt;&gt;{ resolution, cost };
5345                  return *env;
5346              }
5347          } 
5348      } 
5349  } 
5350  #include &lt;algorithm&gt;
5351  #include &lt;vector&gt;
5352  #include &lt;string&gt;
5353  #include &lt;iterator&gt;
5354  namespace Catch {
5355      namespace Benchmark {
5356          template &lt;typename Duration&gt;
5357          struct SampleAnalysis {
5358              std::vector&lt;Duration&gt; samples;
5359              Estimate&lt;Duration&gt; mean;
5360              Estimate&lt;Duration&gt; standard_deviation;
5361              OutlierClassification outliers;
5362              double outlier_variance;
5363              template &lt;typename Duration2&gt;
5364              operator SampleAnalysis&lt;Duration2&gt;() const {
5365                  std::vector&lt;Duration2&gt; samples2;
5366                  samples2.reserve(samples.size());
5367                  std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
5368                  return {
5369                      std::move(samples2),
5370                      mean,
5371                      standard_deviation,
5372                      outliers,
5373                      outlier_variance,
5374                  };
5375              }
5376          };
5377      } 
5378  } 
5379  #include &lt;algorithm&gt;
5380  #include &lt;iterator&gt;
5381  #include &lt;vector&gt;
5382  namespace Catch {
5383      namespace Benchmark {
5384          namespace Detail {
5385              template &lt;typename Duration, typename Iterator&gt;
5386              SampleAnalysis&lt;Duration&gt; analyse(const IConfig &amp;cfg, Environment&lt;Duration&gt;, Iterator first, Iterator last) {
5387                  if (!cfg.benchmarkNoAnalysis()) {
5388                      std::vector&lt;double&gt; samples;
5389                      samples.reserve(last - first);
5390                      std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });
5391                      auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());
5392                      auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());
5393                      auto wrap_estimate = [](Estimate&lt;double&gt; e) {
5394                          return Estimate&lt;Duration&gt; {
5395                              Duration(e.point),
5396                                  Duration(e.lower_bound),
5397                                  Duration(e.upper_bound),
5398                                  e.confidence_interval,
5399                          };
5400                      };
5401                      std::vector&lt;Duration&gt; samples2;
5402                      samples2.reserve(samples.size());
5403                      std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });
5404                      return {
5405                          std::move(samples2),
5406                          wrap_estimate(analysis.mean),
5407                          wrap_estimate(analysis.standard_deviation),
5408                          outliers,
5409                          analysis.outlier_variance,
5410                      };
5411                  } else {
5412                      std::vector&lt;Duration&gt; samples;
5413                      samples.reserve(last - first);
5414                      Duration mean = Duration(0);
5415                      int i = 0;
5416                      for (auto it = first; it &lt; last; ++it, ++i) {
5417                          samples.push_back(Duration(*it));
5418                          mean += Duration(*it);
5419                      }
5420                      mean /= i;
5421                      return {
5422                          std::move(samples),
5423                          Estimate&lt;Duration&gt;{mean, mean, mean, 0.0},
5424                          Estimate&lt;Duration&gt;{Duration(0), Duration(0), Duration(0), 0.0},
5425                          OutlierClassification{},
5426                          0.0
5427                      };
5428                  }
5429              }
5430          } 
5431      } 
5432  } 
5433  #include &lt;algorithm&gt;
5434  #include &lt;functional&gt;
5435  #include &lt;string&gt;
5436  #include &lt;vector&gt;
5437  #include &lt;cmath&gt;
5438  namespace Catch {
5439      namespace Benchmark {
5440          struct Benchmark {
5441              Benchmark(std::string &amp;&amp;name)
5442                  : name(std::move(name)) {}
5443              template &lt;class FUN&gt;
5444              Benchmark(std::string &amp;&amp;name, FUN &amp;&amp;func)
5445                  : fun(std::move(func)), name(std::move(name)) {}
5446              template &lt;typename Clock&gt;
5447              ExecutionPlan&lt;FloatDuration&lt;Clock&gt;&gt; prepare(const IConfig &amp;cfg, Environment&lt;FloatDuration&lt;Clock&gt;&gt; env) const {
5448                  auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;
5449                  auto run_time = std::max(min_time, std::chrono::duration_cast&lt;decltype(min_time)&gt;(cfg.benchmarkWarmupTime()));
5450                  auto&amp;&amp; test = Detail::run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(run_time), 1, fun);
5451                  int new_iters = static_cast&lt;int&gt;(std::ceil(min_time * test.iterations / test.elapsed));
5452                  return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast&lt;FloatDuration&lt;Clock&gt;&gt;(cfg.benchmarkWarmupTime()), Detail::warmup_iterations };
5453              }
5454              template &lt;typename Clock = default_clock&gt;
5455              void run() {
5456                  IConfigPtr cfg = getCurrentContext().getConfig();
5457                  auto env = Detail::measure_environment&lt;Clock&gt;();
5458                  getResultCapture().benchmarkPreparing(name);
5459                  CATCH_TRY{
5460                      auto plan = user_code([&amp;] {
5461                          return prepare&lt;Clock&gt;(*cfg, env);
5462                      });
5463                      BenchmarkInfo info {
5464                          name,
5465                          plan.estimated_duration.count(),
5466                          plan.iterations_per_sample,
5467                          cfg-&gt;benchmarkSamples(),
5468                          cfg-&gt;benchmarkResamples(),
5469                          env.clock_resolution.mean.count(),
5470                          env.clock_cost.mean.count()
5471                      };
5472                      getResultCapture().benchmarkStarting(info);
5473                      auto samples = user_code([&amp;] {
5474                          return plan.template run&lt;Clock&gt;(*cfg, env);
5475                      });
5476                      auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());
5477                      BenchmarkStats&lt;FloatDuration&lt;Clock&gt;&gt; stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };
5478                      getResultCapture().benchmarkEnded(stats);
5479                  } CATCH_CATCH_ALL{
5480                      if (translateActiveException() != Detail::benchmarkErrorMsg) 
5481                          std::rethrow_exception(std::current_exception());
5482                  }
5483              }
5484              template &lt;typename Fun,
5485                  typename std::enable_if&lt;!Detail::is_related&lt;Fun, Benchmark&gt;::value, int&gt;::type = 0&gt;
5486                  Benchmark &amp; operator=(Fun func) {
5487                  fun = Detail::BenchmarkFunction(func);
5488                  run();
5489                  return *this;
5490              }
5491              explicit operator bool() {
5492                  return true;
5493              }
5494          private:
5495              Detail::BenchmarkFunction fun;
5496              std::string name;
5497          };
5498      }
5499  } 
5500  #define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1
5501  #define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2
5502  #define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\
5503      if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
5504          BenchmarkName = [&amp;](int benchmarkIndex)
5505  #define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\
5506      if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
5507          BenchmarkName = [&amp;]
5508  #include &lt;type_traits&gt;
5509  namespace Catch {
5510      namespace Benchmark {
5511          namespace Detail {
5512              template &lt;typename T, bool Destruct&gt;
5513              struct ObjectStorage
5514              {
5515                  using TStorage = typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type;
5516                  ObjectStorage() : data() {}
5517                  ObjectStorage(const ObjectStorage&amp; other)
5518                  {
5519                      new(&amp;data) T(other.stored_object());
5520                  }
5521                  ObjectStorage(ObjectStorage&amp;&amp; other)
5522                  {
5523                      new(&amp;data) T(std::move(other.stored_object()));
5524                  }
5525                  ~ObjectStorage() { destruct_on_exit&lt;T&gt;(); }
5526                  template &lt;typename... Args&gt;
5527                  void construct(Args&amp;&amp;... args)
5528                  {
5529                      new (&amp;data) T(std::forward&lt;Args&gt;(args)...);
5530                  }
5531                  template &lt;bool AllowManualDestruction = !Destruct&gt;
5532                  typename std::enable_if&lt;AllowManualDestruction&gt;::type destruct()
5533                  {
5534                      stored_object().~T();
5535                  }
5536              private:
5537                  template &lt;typename U&gt;
5538                  void destruct_on_exit(typename std::enable_if&lt;Destruct, U&gt;::type* = 0) { destruct&lt;true&gt;(); }
5539                  template &lt;typename U&gt;
5540                  void destruct_on_exit(typename std::enable_if&lt;!Destruct, U&gt;::type* = 0) { }
5541                  T&amp; stored_object() {
5542                      return *static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;data));
5543                  }
5544                  T const&amp; stored_object() const {
5545                      return *static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;data));
5546                  }
5547                  TStorage data;
5548              };
5549          }
5550          template &lt;typename T&gt;
5551          using storage_for = Detail::ObjectStorage&lt;T, true&gt;;
5552          template &lt;typename T&gt;
5553          using destructable_object = Detail::ObjectStorage&lt;T, false&gt;;
5554      }
5555  }
5556  #endif
5557  #endif 
5558  #ifdef CATCH_IMPL
5559  #ifdef __clang__
5560  #pragma clang diagnostic push
5561  #pragma clang diagnostic ignored &quot;-Wweak-vtables&quot;
5562  #endif
5563  #include &lt;string&gt;
5564  #include &lt;vector&gt;
5565  #include &lt;memory&gt;
5566  namespace Catch {
5567  namespace TestCaseTracking {
5568      struct NameAndLocation {
5569          std::string name;
5570          SourceLineInfo location;
5571          NameAndLocation( std::string const&amp; _name, SourceLineInfo const&amp; _location );
5572          friend bool operator==(NameAndLocation const&amp; lhs, NameAndLocation const&amp; rhs) {
5573              return lhs.name == rhs.name
5574                  &amp;&amp; lhs.location == rhs.location;
5575          }
5576      };
5577      class ITracker;
5578      using ITrackerPtr = std::shared_ptr&lt;ITracker&gt;;
5579      class  ITracker {
5580          NameAndLocation m_nameAndLocation;
5581      public:
5582          ITracker(NameAndLocation const&amp; nameAndLoc) :
5583              m_nameAndLocation(nameAndLoc)
5584          {}
5585          NameAndLocation const&amp; nameAndLocation() const {
5586              return m_nameAndLocation;
5587          }
5588          virtual ~ITracker();
5589          virtual bool isComplete() const = 0; 
5590          virtual bool isSuccessfullyCompleted() const = 0;
5591          virtual bool isOpen() const = 0; 
5592          virtual bool hasChildren() const = 0;
5593          virtual bool hasStarted() const = 0;
5594          virtual ITracker&amp; parent() = 0;
5595          virtual void close() = 0; 
5596          virtual void fail() = 0;
5597          virtual void markAsNeedingAnotherRun() = 0;
5598          virtual void addChild( ITrackerPtr const&amp; child ) = 0;
5599          virtual ITrackerPtr findChild( NameAndLocation const&amp; nameAndLocation ) = 0;
5600          virtual void openChild() = 0;
5601          virtual bool isSectionTracker() const = 0;
5602          virtual bool isGeneratorTracker() const = 0;
5603      };
5604      class TrackerContext {
5605          enum RunState {
5606              NotStarted,
5607              Executing,
5608              CompletedCycle
5609          };
5610          ITrackerPtr m_rootTracker;
5611          ITracker* m_currentTracker = nullptr;
5612          RunState m_runState = NotStarted;
5613      public:
5614          ITracker&amp; startRun();
5615          void endRun();
5616          void startCycle();
5617          void completeCycle();
5618          bool completedCycle() const;
5619          ITracker&amp; currentTracker();
5620          void setCurrentTracker( ITracker* tracker );
5621      };
5622      class TrackerBase : public ITracker {
5623      protected:
5624          enum CycleState {
5625              NotStarted,
5626              Executing,
5627              ExecutingChildren,
5628              NeedsAnotherRun,
5629              CompletedSuccessfully,
5630              Failed
5631          };
5632          using Children = std::vector&lt;ITrackerPtr&gt;;
5633          TrackerContext&amp; m_ctx;
5634          ITracker* m_parent;
5635          Children m_children;
5636          CycleState m_runState = NotStarted;
5637      public:
5638          TrackerBase( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent );
5639          bool isComplete() const override;
5640          bool isSuccessfullyCompleted() const override;
5641          bool isOpen() const override;
5642          bool hasChildren() const override;
5643          bool hasStarted() const override {
5644              return m_runState != NotStarted;
5645          }
5646          void addChild( ITrackerPtr const&amp; child ) override;
5647          ITrackerPtr findChild( NameAndLocation const&amp; nameAndLocation ) override;
5648          ITracker&amp; parent() override;
5649          void openChild() override;
5650          bool isSectionTracker() const override;
5651          bool isGeneratorTracker() const override;
5652          void open();
5653          void close() override;
5654          void fail() override;
5655          void markAsNeedingAnotherRun() override;
5656      private:
5657          void moveToParent();
5658          void moveToThis();
5659      };
5660      class SectionTracker : public TrackerBase {
5661          std::vector&lt;std::string&gt; m_filters;
5662          std::string m_trimmed_name;
5663      public:
5664          SectionTracker( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent );
5665          bool isSectionTracker() const override;
5666          bool isComplete() const override;
5667          static SectionTracker&amp; acquire( TrackerContext&amp; ctx, NameAndLocation const&amp; nameAndLocation );
5668          void tryOpen();
5669          void addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters );
5670          void addNextFilters( std::vector&lt;std::string&gt; const&amp; filters );
5671          std::vector&lt;std::string&gt; const&amp; getFilters() const;
5672          std::string const&amp; trimmedName() const;
5673      };
5674  } 
5675  using TestCaseTracking::ITracker;
5676  using TestCaseTracking::TrackerContext;
5677  using TestCaseTracking::SectionTracker;
5678  } 
5679  namespace Catch {
5680      struct LeakDetector {
5681          LeakDetector();
5682          ~LeakDetector();
5683      };
5684  }
5685  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
5686  #include &lt;cassert&gt;
5687  #include &lt;random&gt;
5688  #if defined(CATCH_CONFIG_USE_ASYNC)
5689  #include &lt;future&gt;
5690  #endif
5691  namespace {
5692      double erf_inv(double x) {
5693          double w, p;
5694          w = -log((1.0 - x) * (1.0 + x));
5695          if (w &lt; 6.250000) {
5696              w = w - 3.125000;
5697              p = -3.6444120640178196996e-21;
5698              p = -1.685059138182016589e-19 + p * w;
5699              p = 1.2858480715256400167e-18 + p * w;
5700              p = 1.115787767802518096e-17 + p * w;
5701              p = -1.333171662854620906e-16 + p * w;
5702              p = 2.0972767875968561637e-17 + p * w;
5703              p = 6.6376381343583238325e-15 + p * w;
5704              p = -4.0545662729752068639e-14 + p * w;
5705              p = -8.1519341976054721522e-14 + p * w;
5706              p = 2.6335093153082322977e-12 + p * w;
5707              p = -1.2975133253453532498e-11 + p * w;
5708              p = -5.4154120542946279317e-11 + p * w;
5709              p = 1.051212273321532285e-09 + p * w;
5710              p = -4.1126339803469836976e-09 + p * w;
5711              p = -2.9070369957882005086e-08 + p * w;
5712              p = 4.2347877827932403518e-07 + p * w;
5713              p = -1.3654692000834678645e-06 + p * w;
5714              p = -1.3882523362786468719e-05 + p * w;
5715              p = 0.0001867342080340571352 + p * w;
5716              p = -0.00074070253416626697512 + p * w;
5717              p = -0.0060336708714301490533 + p * w;
5718              p = 0.24015818242558961693 + p * w;
5719              p = 1.6536545626831027356 + p * w;
5720          } else if (w &lt; 16.000000) {
5721              w = sqrt(w) - 3.250000;
5722              p = 2.2137376921775787049e-09;
5723              p = 9.0756561938885390979e-08 + p * w;
5724              p = -2.7517406297064545428e-07 + p * w;
5725              p = 1.8239629214389227755e-08 + p * w;
5726              p = 1.5027403968909827627e-06 + p * w;
5727              p = -4.013867526981545969e-06 + p * w;
5728              p = 2.9234449089955446044e-06 + p * w;
5729              p = 1.2475304481671778723e-05 + p * w;
5730              p = -4.7318229009055733981e-05 + p * w;
5731              p = 6.8284851459573175448e-05 + p * w;
5732              p = 2.4031110387097893999e-05 + p * w;
5733              p = -0.0003550375203628474796 + p * w;
5734              p = 0.00095328937973738049703 + p * w;
5735              p = -0.0016882755560235047313 + p * w;
5736              p = 0.0024914420961078508066 + p * w;
5737              p = -0.0037512085075692412107 + p * w;
5738              p = 0.005370914553590063617 + p * w;
5739              p = 1.0052589676941592334 + p * w;
5740              p = 3.0838856104922207635 + p * w;
5741          } else {
5742              w = sqrt(w) - 5.000000;
5743              p = -2.7109920616438573243e-11;
5744              p = -2.5556418169965252055e-10 + p * w;
5745              p = 1.5076572693500548083e-09 + p * w;
5746              p = -3.7894654401267369937e-09 + p * w;
5747              p = 7.6157012080783393804e-09 + p * w;
5748              p = -1.4960026627149240478e-08 + p * w;
5749              p = 2.9147953450901080826e-08 + p * w;
5750              p = -6.7711997758452339498e-08 + p * w;
5751              p = 2.2900482228026654717e-07 + p * w;
5752              p = -9.9298272942317002539e-07 + p * w;
5753              p = 4.5260625972231537039e-06 + p * w;
5754              p = -1.9681778105531670567e-05 + p * w;
5755              p = 7.5995277030017761139e-05 + p * w;
5756              p = -0.00021503011930044477347 + p * w;
5757              p = -0.00013871931833623122026 + p * w;
5758              p = 1.0103004648645343977 + p * w;
5759              p = 4.8499064014085844221 + p * w;
5760          }
5761          return p * x;
5762      }
5763      double standard_deviation(std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last) {
5764          auto m = Catch::Benchmark::Detail::mean(first, last);
5765          double variance = std::accumulate(first, last, 0., [m](double a, double b) {
5766              double diff = b - m;
5767              return a + diff * diff;
5768              }) / (last - first);
5769              return std::sqrt(variance);
5770      }
5771  }
5772  namespace Catch {
5773      namespace Benchmark {
5774          namespace Detail {
5775              double weighted_average_quantile(int k, int q, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last) {
5776                  auto count = last - first;
5777                  double idx = (count - 1) * k / static_cast&lt;double&gt;(q);
5778                  int j = static_cast&lt;int&gt;(idx);
5779                  double g = idx - j;
5780                  std::nth_element(first, first + j, last);
5781                  auto xj = first[j];
5782                  if (g == 0) return xj;
5783                  auto xj1 = *std::min_element(first + (j + 1), last);
5784                  return xj + g * (xj1 - xj);
5785              }
5786              double erfc_inv(double x) {
5787                  return erf_inv(1.0 - x);
5788              }
5789              double normal_quantile(double p) {
5790                  static const double ROOT_TWO = std::sqrt(2.0);
5791                  double result = 0.0;
5792                  assert(p &gt;= 0 &amp;&amp; p &lt;= 1);
5793                  if (p &lt; 0 || p &gt; 1) {
5794                      return result;
5795                  }
5796                  result = -erfc_inv(2.0 * p);
5797                  result *= &amp;bsol;*sd * */ ROOT_TWO;
5798                  return result;
5799              }
5800              double outlier_variance(Estimate&lt;double&gt; mean, Estimate&lt;double&gt; stddev, int n) {
5801                  double sb = stddev.point;
5802                  double mn = mean.point / n;
5803                  double mg_min = mn / 2.;
5804                  double sg = (std::min)(mg_min / 4., sb / std::sqrt(n));
5805                  double sg2 = sg * sg;
5806                  double sb2 = sb * sb;
5807                  auto c_max = [n, mn, sb2, sg2](double x) -&gt; double {
5808                      double k = mn - x;
5809                      double d = k * k;
5810                      double nd = n * d;
5811                      double k0 = -n * nd;
5812                      double k1 = sb2 - n * sg2 + nd;
5813                      double det = k1 * k1 - 4 * sg2 * k0;
5814                      return (int)(-2. * k0 / (k1 + std::sqrt(det)));
5815                  };
5816                  auto var_out = [n, sb2, sg2](double c) {
5817                      double nc = n - c;
5818                      return (nc / n) * (sb2 - nc * sg2);
5819                  };
5820                  return (std::min)(var_out(1), var_out((std::min)(c_max(0.), c_max(mg_min)))) / sb2;
5821              }
5822              bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last) {
5823                  CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
5824                  CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
5825                  static std::random_device entropy;
5826                  CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
5827                  auto n = static_cast&lt;int&gt;(last - first); 
5828                  auto mean = &amp;Detail::mean&lt;std::vector&lt;double&gt;::iterator&gt;;
5829                  auto stddev = &amp;standard_deviation;
5830  #if defined(CATCH_CONFIG_USE_ASYNC)
5831                  auto Estimate = [=](double(*f)(std::vector&lt;double&gt;::iterator, std::vector&lt;double&gt;::iterator)) {
5832                      auto seed = entropy();
5833                      return std::async(std::launch::async, [=] {
5834                          std::mt19937 rng(seed);
5835                          auto resampled = resample(rng, n_resamples, first, last, f);
5836                          return bootstrap(confidence_level, first, last, resampled, f);
5837                      });
5838                  };
5839                  auto mean_future = Estimate(mean);
5840                  auto stddev_future = Estimate(stddev);
5841                  auto mean_estimate = mean_future.get();
5842                  auto stddev_estimate = stddev_future.get();
5843  #else
5844                  auto Estimate = [=](double(*f)(std::vector&lt;double&gt;::iterator, std::vector&lt;double&gt;::iterator)) {
5845                      auto seed = entropy();
5846                      std::mt19937 rng(seed);
5847                      auto resampled = resample(rng, n_resamples, first, last, f);
5848                      return bootstrap(confidence_level, first, last, resampled, f);
5849                  };
5850                  auto mean_estimate = Estimate(mean);
5851                  auto stddev_estimate = Estimate(stddev);
5852  #endif 
5853                  double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);
5854                  return { mean_estimate, stddev_estimate, outlier_variance };
5855              }
5856          } 
5857      } 
5858  } 
5859  #endif 
5860  #include &lt;cmath&gt;
5861  #include &lt;limits&gt;
5862  namespace {
5863  bool marginComparison(double lhs, double rhs, double margin) {
5864      return (lhs + margin &gt;= rhs) &amp;&amp; (rhs + margin &gt;= lhs);
5865  }
5866  }
5867  namespace Catch {
5868  namespace Detail {
5869      Approx::Approx ( double value )
5870      :   m_epsilon( std::numeric_limits&lt;float&gt;::epsilon()*100 ),
5871          m_margin( 0.0 ),
5872          m_scale( 0.0 ),
5873          m_value( value )
5874      {}
5875      Approx Approx::custom() {
5876          return Approx( 0 );
5877      }
5878      Approx Approx::operator-() const {
5879          auto temp(*this);
5880          temp.m_value = -temp.m_value;
5881          return temp;
5882      }
5883      std::string Approx::toString() const {
5884          ReusableStringStream rss;
5885          rss &lt;&lt; &quot;Approx( &quot; &lt;&lt; ::Catch::Detail::stringify( m_value ) &lt;&lt; &quot; )&quot;;
5886          return rss.str();
5887      }
5888      bool Approx::equalityComparisonImpl(const double other) const {
5889          return marginComparison(m_value, other, m_margin)
5890              || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));
5891      }
5892      void Approx::setMargin(double newMargin) {
5893          CATCH_ENFORCE(newMargin &gt;= 0,
5894              &quot;Invalid Approx::margin: &quot; &lt;&lt; newMargin &lt;&lt; &#x27;.&#x27;
5895              &lt;&lt; &quot; Approx::Margin has to be non-negative.&quot;);
5896          m_margin = newMargin;
5897      }
5898      void Approx::setEpsilon(double newEpsilon) {
5899          CATCH_ENFORCE(newEpsilon &gt;= 0 &amp;&amp; newEpsilon &lt;= 1.0,
5900              &quot;Invalid Approx::epsilon: &quot; &lt;&lt; newEpsilon &lt;&lt; &#x27;.&#x27;
5901              &lt;&lt; &quot; Approx::epsilon has to be in [0, 1]&quot;);
5902          m_epsilon = newEpsilon;
5903      }
5904  } 
5905  namespace literals {
5906      Detail::Approx operator &quot;&quot; _a(long double val) {
5907          return Detail::Approx(val);
5908      }
5909      Detail::Approx operator &quot;&quot; _a(unsigned long long val) {
5910          return Detail::Approx(val);
5911      }
5912  } 
5913  std::string StringMaker&lt;Catch::Detail::Approx&gt;::convert(Catch::Detail::Approx const&amp; value) {
5914      return value.toString();
5915  }
5916  } 
5917  namespace Catch {
5918      bool isDebuggerActive();
5919  }
5920  #ifdef CATCH_PLATFORM_MAC
5921      #if defined(__i386__) || defined(__x86_64__)
5922          #define CATCH_TRAP() __asm__(&quot;int $3\n&quot; : : ) &amp;bsol;* NOLINT */
5923      #elif defined(__aarch64__)
5924          #define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)
5925      #endif
5926  #elif defined(CATCH_PLATFORM_IPHONE)
5927      #if defined(__i386__) || defined(__x86_64__)
5928          #define CATCH_TRAP()  __asm__(&quot;int $3&quot;)
5929      #elif defined(__aarch64__)
5930          #define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)
5931      #elif defined(__arm__) &amp;&amp; !defined(__thumb__)
5932          #define CATCH_TRAP()  __asm__(&quot;.inst 0xe7f001f0&quot;)
5933      #elif defined(__arm__) &amp;&amp;  defined(__thumb__)
5934          #define CATCH_TRAP()  __asm__(&quot;.inst 0xde01&quot;)
5935      #endif
5936  #elif defined(CATCH_PLATFORM_LINUX)
5937      #if defined(__GNUC__) &amp;&amp; (defined(__i386) || defined(__x86_64))
5938          #define CATCH_TRAP() asm volatile (&quot;int $3&quot;) &amp;bsol;* NOLINT */
5939      #else 
5940          #include &lt;signal.h&gt;
5941          #define CATCH_TRAP() raise(SIGTRAP)
5942      #endif
5943  #elif defined(_MSC_VER)
5944      #define CATCH_TRAP() __debugbreak()
5945  #elif defined(__MINGW32__)
5946      extern &quot;C&quot; __declspec(dllimport) void __stdcall DebugBreak();
5947      #define CATCH_TRAP() DebugBreak()
5948  #endif
5949  #ifndef CATCH_BREAK_INTO_DEBUGGER
5950      #ifdef CATCH_TRAP
5951          #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()
5952      #else
5953          #define CATCH_BREAK_INTO_DEBUGGER() []{}()
5954      #endif
5955  #endif
5956  #include &lt;cassert&gt;
5957  namespace Catch {
5958      class FatalConditionHandler {
5959          bool m_started = false;
5960          void engage_platform();
5961          void disengage_platform();
5962      public:
5963          FatalConditionHandler();
5964          ~FatalConditionHandler();
5965          void engage() {
5966              assert(!m_started &amp;&amp; &quot;Handler cannot be installed twice.&quot;);
5967              m_started = true;
5968              engage_platform();
5969          }
5970          void disengage() {
5971              assert(m_started &amp;&amp; &quot;Handler cannot be uninstalled without being installed first&quot;);
5972              m_started = false;
5973              disengage_platform();
5974          }
5975      };
5976      class FatalConditionHandlerGuard {
5977          FatalConditionHandler* m_handler;
5978      public:
5979          FatalConditionHandlerGuard(FatalConditionHandler* handler):
5980              m_handler(handler) {
5981              m_handler-&gt;engage();
5982          }
5983          ~FatalConditionHandlerGuard() {
5984              m_handler-&gt;disengage();
5985          }
5986      };
5987  } 
5988  #include &lt;string&gt;
5989  namespace Catch {
5990      struct IMutableContext;
5991      class RunContext : public IResultCapture, public IRunner {
5992      public:
5993          RunContext( RunContext const&amp; ) = delete;
5994          RunContext&amp; operator =( RunContext const&amp; ) = delete;
5995          explicit RunContext( IConfigPtr const&amp; _config, IStreamingReporterPtr&amp;&amp; reporter );
5996          ~RunContext() override;
5997          void testGroupStarting( std::string const&amp; testSpec, std::size_t groupIndex, std::size_t groupsCount );
5998          void testGroupEnded( std::string const&amp; testSpec, Totals const&amp; totals, std::size_t groupIndex, std::size_t groupsCount );
5999          Totals runTest(TestCase const&amp; testCase);
6000          IConfigPtr config() const;
6001          IStreamingReporter&amp; reporter() const;
6002      public: 
6003          void handleExpr
6004                  (   AssertionInfo const&amp; info,
6005                      ITransientExpression const&amp; expr,
6006                      AssertionReaction&amp; reaction ) override;
6007          void handleMessage
6008                  (   AssertionInfo const&amp; info,
6009                      ResultWas::OfType resultType,
6010                      StringRef const&amp; message,
6011                      AssertionReaction&amp; reaction ) override;
6012          void handleUnexpectedExceptionNotThrown
6013                  (   AssertionInfo const&amp; info,
6014                      AssertionReaction&amp; reaction ) override;
6015          void handleUnexpectedInflightException
6016                  (   AssertionInfo const&amp; info,
6017                      std::string const&amp; message,
6018                      AssertionReaction&amp; reaction ) override;
6019          void handleIncomplete
6020                  (   AssertionInfo const&amp; info ) override;
6021          void handleNonExpr
6022                  (   AssertionInfo const &amp;info,
6023                      ResultWas::OfType resultType,
6024                      AssertionReaction &amp;reaction ) override;
6025          bool sectionStarted( SectionInfo const&amp; sectionInfo, Counts&amp; assertions ) override;
6026          void sectionEnded( SectionEndInfo const&amp; endInfo ) override;
6027          void sectionEndedEarly( SectionEndInfo const&amp; endInfo ) override;
6028          auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; override;
6029  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
6030          void benchmarkPreparing( std::string const&amp; name ) override;
6031          void benchmarkStarting( BenchmarkInfo const&amp; info ) override;
6032          void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) override;
6033          void benchmarkFailed( std::string const&amp; error ) override;
6034  #endif 
6035          void pushScopedMessage( MessageInfo const&amp; message ) override;
6036          void popScopedMessage( MessageInfo const&amp; message ) override;
6037          void emplaceUnscopedMessage( MessageBuilder const&amp; builder ) override;
6038          std::string getCurrentTestName() const override;
6039          const AssertionResult* getLastResult() const override;
6040          void exceptionEarlyReported() override;
6041          void handleFatalErrorCondition( StringRef message ) override;
6042          bool lastAssertionPassed() override;
6043          void assertionPassed() override;
6044      public:
6045          bool aborting() const final;
6046      private:
6047          void runCurrentTest( std::string&amp; redirectedCout, std::string&amp; redirectedCerr );
6048          void invokeActiveTestCase();
6049          void resetAssertionInfo();
6050          bool testForMissingAssertions( Counts&amp; assertions );
6051          void assertionEnded( AssertionResult const&amp; result );
6052          void reportExpr
6053                  (   AssertionInfo const &amp;info,
6054                      ResultWas::OfType resultType,
6055                      ITransientExpression const *expr,
6056                      bool negated );
6057          void populateReaction( AssertionReaction&amp; reaction );
6058      private:
6059          void handleUnfinishedSections();
6060          TestRunInfo m_runInfo;
6061          IMutableContext&amp; m_context;
6062          TestCase const* m_activeTestCase = nullptr;
6063          ITracker* m_testCaseTracker = nullptr;
6064          Option&lt;AssertionResult&gt; m_lastResult;
6065          IConfigPtr m_config;
6066          Totals m_totals;
6067          IStreamingReporterPtr m_reporter;
6068          std::vector&lt;MessageInfo&gt; m_messages;
6069          std::vector&lt;ScopedMessage&gt; m_messageScopes; &amp;bsol;* Keeps owners of so-called unscoped messages. */
6070          AssertionInfo m_lastAssertionInfo;
6071          std::vector&lt;SectionEndInfo&gt; m_unfinishedSections;
6072          std::vector&lt;ITracker*&gt; m_activeSections;
6073          TrackerContext m_trackerContext;
6074          FatalConditionHandler m_fatalConditionhandler;
6075          bool m_lastAssertionPassed = false;
6076          bool m_shouldReportUnexpected = true;
6077          bool m_includeSuccessfulResults;
6078      };
6079      void seedRng(IConfig const&amp; config);
6080      unsigned int rngSeed();
6081  } 
6082  namespace Catch {
6083      namespace {
6084          auto operator &lt;&lt;( std::ostream&amp; os, ITransientExpression const&amp; expr ) -&gt; std::ostream&amp; {
6085              expr.streamReconstructedExpression( os );
6086              return os;
6087          }
6088      }
6089      LazyExpression::LazyExpression( bool isNegated )
6090      :   m_isNegated( isNegated )
6091      {}
6092      LazyExpression::LazyExpression( LazyExpression const&amp; other ) : m_isNegated( other.m_isNegated ) {}
6093      LazyExpression::operator bool() const {
6094          return m_transientExpression != nullptr;
6095      }
6096      auto operator &lt;&lt; ( std::ostream&amp; os, LazyExpression const&amp; lazyExpr ) -&gt; std::ostream&amp; {
6097          if( lazyExpr.m_isNegated )
6098              os &lt;&lt; &quot;!&quot;;
6099          if( lazyExpr ) {
6100              if( lazyExpr.m_isNegated &amp;&amp; lazyExpr.m_transientExpression-&gt;isBinaryExpression() )
6101                  os &lt;&lt; &quot;(&quot; &lt;&lt; *lazyExpr.m_transientExpression &lt;&lt; &quot;)&quot;;
6102              else
6103                  os &lt;&lt; *lazyExpr.m_transientExpression;
6104          }
6105          else {
6106              os &lt;&lt; &quot;{** error - unchecked empty expression requested **}&quot;;
6107          }
6108          return os;
6109      }
6110      AssertionHandler::AssertionHandler
6111          (   StringRef const&amp; macroName,
6112              SourceLineInfo const&amp; lineInfo,
6113              StringRef capturedExpression,
6114              ResultDisposition::Flags resultDisposition )
6115      :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
6116          m_resultCapture( getResultCapture() )
6117      {}
6118      void AssertionHandler::handleExpr( ITransientExpression const&amp; expr ) {
6119          m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
6120      }
6121      void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const&amp; message) {
6122          m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
6123      }
6124      auto AssertionHandler::allowThrows() const -&gt; bool {
6125          return getCurrentContext().getConfig()-&gt;allowThrows();
6126      }
6127      void AssertionHandler::complete() {
6128          setCompleted();
6129          if( m_reaction.shouldDebugBreak ) {
6130              CATCH_BREAK_INTO_DEBUGGER();
6131          }
6132          if (m_reaction.shouldThrow) {
6133  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
6134              throw Catch::TestFailureException();
6135  #else
6136              CATCH_ERROR( &quot;Test failure requires aborting test!&quot; );
6137  #endif
6138          }
6139      }
6140      void AssertionHandler::setCompleted() {
6141          m_completed = true;
6142      }
6143      void AssertionHandler::handleUnexpectedInflightException() {
6144          m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
6145      }
6146      void AssertionHandler::handleExceptionThrownAsExpected() {
6147          m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
6148      }
6149      void AssertionHandler::handleExceptionNotThrownAsExpected() {
6150          m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
6151      }
6152      void AssertionHandler::handleUnexpectedExceptionNotThrown() {
6153          m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
6154      }
6155      void AssertionHandler::handleThrowingCallSkipped() {
6156          m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
6157      }
6158      void handleExceptionMatchExpr( AssertionHandler&amp; handler, std::string const&amp; str, StringRef const&amp; matcherString  ) {
6159          handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
6160      }
6161  } 
6162  namespace Catch {
6163      AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const &amp; _lazyExpression):
6164          lazyExpression(_lazyExpression),
6165          resultType(_resultType) {}
6166      std::string AssertionResultData::reconstructExpression() const {
6167          if( reconstructedExpression.empty() ) {
6168              if( lazyExpression ) {
6169                  ReusableStringStream rss;
6170                  rss &lt;&lt; lazyExpression;
6171                  reconstructedExpression = rss.str();
6172              }
6173          }
6174          return reconstructedExpression;
6175      }
6176      AssertionResult::AssertionResult( AssertionInfo const&amp; info, AssertionResultData const&amp; data )
6177      :   m_info( info ),
6178          m_resultData( data )
6179      {}
6180      bool AssertionResult::succeeded() const {
6181          return Catch::isOk( m_resultData.resultType );
6182      }
6183      bool AssertionResult::isOk() const {
6184          return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
6185      }
6186      ResultWas::OfType AssertionResult::getResultType() const {
6187          return m_resultData.resultType;
6188      }
6189      bool AssertionResult::hasExpression() const {
6190          return !m_info.capturedExpression.empty();
6191      }
6192      bool AssertionResult::hasMessage() const {
6193          return !m_resultData.message.empty();
6194      }
6195      std::string AssertionResult::getExpression() const {
6196          std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);
6197          if (isFalseTest(m_info.resultDisposition)) {
6198              expr += &quot;!(&quot;;
6199          }
6200          expr += m_info.capturedExpression;
6201          if (isFalseTest(m_info.resultDisposition)) {
6202              expr += &#x27;)&#x27;;
6203          }
6204          return expr;
6205      }
6206      std::string AssertionResult::getExpressionInMacro() const {
6207          std::string expr;
6208          if( m_info.macroName.empty() )
6209              expr = static_cast&lt;std::string&gt;(m_info.capturedExpression);
6210          else {
6211              expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
6212              expr += m_info.macroName;
6213              expr += &quot;( &quot;;
6214              expr += m_info.capturedExpression;
6215              expr += &quot; )&quot;;
6216          }
6217          return expr;
6218      }
6219      bool AssertionResult::hasExpandedExpression() const {
6220          return hasExpression() &amp;&amp; getExpandedExpression() != getExpression();
6221      }
6222      std::string AssertionResult::getExpandedExpression() const {
6223          std::string expr = m_resultData.reconstructExpression();
6224          return expr.empty()
6225                  ? getExpression()
6226                  : expr;
6227      }
6228      std::string AssertionResult::getMessage() const {
6229          return m_resultData.message;
6230      }
6231      SourceLineInfo AssertionResult::getSourceInfo() const {
6232          return m_info.lineInfo;
6233      }
6234      StringRef AssertionResult::getTestMacroName() const {
6235          return m_info.macroName;
6236      }
6237  } 
6238  namespace Catch {
6239      using StringMatcher = Matchers::Impl::MatcherBase&lt;std::string&gt;;
6240      void handleExceptionMatchExpr( AssertionHandler&amp; handler, StringMatcher const&amp; matcher, StringRef const&amp; matcherString  ) {
6241          std::string exceptionMessage = Catch::translateActiveException();
6242          MatchExpr&lt;std::string, StringMatcher const&amp;&gt; expr( exceptionMessage, matcher, matcherString );
6243          handler.handleExpr( expr );
6244      }
6245  } 
6246  #ifdef CLARA_CONFIG_CONSOLE_WIDTH
6247  #define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6248  #undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6249  #endif
6250  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1
6251  #ifdef __clang__
6252  #pragma clang diagnostic push
6253  #pragma clang diagnostic ignored &quot;-Wweak-vtables&quot;
6254  #pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
6255  #pragma clang diagnostic ignored &quot;-Wshadow&quot;
6256  #endif
6257  #ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH
6258  #define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80
6259  #endif
6260  #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6261  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH
6262  #endif
6263  #ifndef CLARA_CONFIG_OPTIONAL_TYPE
6264  #ifdef __has_include
6265  #if __has_include(&lt;optional&gt;) &amp;&amp; __cplusplus &gt;= 201703L
6266  #include &lt;optional&gt;
6267  #define CLARA_CONFIG_OPTIONAL_TYPE std::optional
6268  #endif
6269  #endif
6270  #endif
6271  #include &lt;cassert&gt;
6272  #include &lt;ostream&gt;
6273  #include &lt;sstream&gt;
6274  #include &lt;vector&gt;
6275  #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6276  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80
6277  #endif
6278  namespace Catch {
6279  namespace clara {
6280  namespace TextFlow {
6281  inline auto isWhitespace(char c) -&gt; bool {
6282  	static std::string chars = &quot; \t\n\r&quot;;
6283  	return chars.find(c) != std::string::npos;
6284  }
6285  inline auto isBreakableBefore(char c) -&gt; bool {
6286  	static std::string chars = &quot;[({&lt;|&quot;;
6287  	return chars.find(c) != std::string::npos;
6288  }
6289  inline auto isBreakableAfter(char c) -&gt; bool {
6290  	static std::string chars = &quot;])}&gt;.,:;*+-=&amp;/\\&quot;;
6291  	return chars.find(c) != std::string::npos;
6292  }
6293  class Columns;
6294  class Column {
6295  	std::vector&lt;std::string&gt; m_strings;
6296  	size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;
6297  	size_t m_indent = 0;
6298  	size_t m_initialIndent = std::string::npos;
6299  public:
6300  	class iterator {
6301  		friend Column;
6302  		Column const&amp; m_column;
6303  		size_t m_stringIndex = 0;
6304  		size_t m_pos = 0;
6305  		size_t m_len = 0;
6306  		size_t m_end = 0;
6307  		bool m_suffix = false;
6308  		iterator(Column const&amp; column, size_t stringIndex)
6309  			: m_column(column),
6310  			m_stringIndex(stringIndex) {}
6311  		auto line() const -&gt; std::string const&amp; { return m_column.m_strings[m_stringIndex]; }
6312  		auto isBoundary(size_t at) const -&gt; bool {
6313  			assert(at &gt; 0);
6314  			assert(at &lt;= line().size());
6315  			return at == line().size() ||
6316  				(isWhitespace(line()[at]) &amp;&amp; !isWhitespace(line()[at - 1])) ||
6317  				isBreakableBefore(line()[at]) ||
6318  				isBreakableAfter(line()[at - 1]);
6319  		}
6320  		void calcLength() {
6321  			assert(m_stringIndex &lt; m_column.m_strings.size());
6322  			m_suffix = false;
6323  			auto width = m_column.m_width - indent();
6324  			m_end = m_pos;
6325  			if (line()[m_pos] == &#x27;\n&#x27;) {
6326  				++m_end;
6327  			}
6328  			while (m_end &lt; line().size() &amp;&amp; line()[m_end] != &#x27;\n&#x27;)
6329  				++m_end;
6330  			if (m_end &lt; m_pos + width) {
6331  				m_len = m_end - m_pos;
6332  			} else {
6333  				size_t len = width;
6334  				while (len &gt; 0 &amp;&amp; !isBoundary(m_pos + len))
6335  					--len;
6336  				while (len &gt; 0 &amp;&amp; isWhitespace(line()[m_pos + len - 1]))
6337  					--len;
6338  				if (len &gt; 0) {
<span onclick='openModal()' class='match'>6339  					m_len = len;
6340  				} else {
6341  					m_suffix = true;
6342  					m_len = width - 1;
6343  				}
6344  			}
6345  		}
6346  		auto indent() const -&gt; size_t {
6347  			auto initial = m_pos == 0 &amp;&amp; m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
6348  			return initial == std::string::npos ? m_column.m_indent : initial;
6349  		}
6350  		auto addIndentAndSuffix(std::string const &amp;plain) const -&gt; std::string {
6351  			return std::string(indent(), &#x27; &#x27;) + (m_suffix ? plain + &quot;-&quot; : plain);
6352  		}
6353  	public:
6354  		using difference_type = std::ptrdiff_t;
6355  		using value_type = std::string;
6356  		using pointer = value_type * ;
6357  		using reference = value_type &amp; ;
6358  		using iterator_category = std::forward_iterator_tag;
6359  		explicit iterator(Column const&amp; column) : m_column(column) {
6360  			assert(m_column.m_width &gt; m_column.m_indent);
6361  			assert(m_column.m_initialIndent == std::string::npos || m_column.m_width &gt; m_column.m_initialIndent);
6362  			calcLength();
6363  			if (m_len == 0)
6364  				m_stringIndex++; 
6365  		}
6366  		auto operator *() const -&gt; std::string {
6367  			assert(m_stringIndex &lt; m_column.m_strings.size());
6368  			assert(m_pos &lt;= m_end);
6369  			return addIndentAndSuffix(line().substr(m_pos, m_len));
6370  		}
6371  		auto operator ++() -&gt; iterator&amp; {
6372  			m_pos += m_len;
6373  			if (m_pos &lt; line().size() &amp;&amp; line()[m_pos] == &#x27;\n&#x27;)
6374  				m_pos += 1;
6375  			else
6376  				while (m_pos &lt; line().size() &amp;&amp; isWhitespace(line()[m_pos]))
6377  					++m_pos;
6378  			if (m_pos == line().size()) {
6379  				m_pos = 0;
6380  				++m_stringIndex;
6381  			}
6382  			if (m_stringIndex &lt; m_column.m_strings.size())
6383  				calcLength();
6384  			return *this;
6385  		}
6386  		auto operator ++(int) -&gt; iterator {
6387  			iterator prev(*this);
6388  			operator++();
6389  			return prev;
6390  		}
6391  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6392  			return
6393  				m_pos == other.m_pos &amp;&amp;
6394  				m_stringIndex == other.m_stringIndex &amp;&amp;
6395  				&amp;m_column == &amp;other.m_column;
6396  		}
6397  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6398  			return !operator==(other);
6399  		}
6400  	};
6401  	using const_iterator = iterator;
6402  	explicit Column(std::string const&amp; text) { m_strings.push_back(text); }
6403  	auto width(size_t newWidth) -&gt; Column&amp; {
6404  		assert(newWidth &gt; 0);
6405  		m_width = newWidth;
6406  		return *this;
6407  	}
6408  	auto indent(size_t newIndent) -&gt; Column&amp; {
6409  		m_indent = newIndent;
6410  		return *this;
6411  	}
6412  	auto initialIndent(size_t newIndent) -&gt; Column&amp; {
6413  		m_initialIndent = newIndent;
6414  		return *this;
6415  	}
6416  	auto width() const -&gt; size_t { return m_width; }
6417  	auto begin() const -&gt; iterator { return iterator(*this); }
6418  	auto end() const -&gt; iterator { return { *this, m_strings.size() }; }
6419  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Column const&amp; col) {
6420  		bool first = true;
6421  		for (auto line : col) {
6422  			if (first)
6423  				first = false;
6424  			else
6425  				os &lt;&lt; &quot;\n&quot;;
6426  			os &lt;&lt; line;
6427  		}
6428  		return os;
6429  	}
6430  	auto operator + (Column const&amp; other)-&gt;Columns;
6431  	auto toString() const -&gt; std::string {
6432  		std::ostringstream oss;
6433  		oss &lt;&lt; *this;
6434  		return oss.str();
6435  	}
6436  };
6437  class Spacer : public Column {
6438  public:
6439  	explicit Spacer(size_t spaceWidth) : Column(&quot;&quot;) {
6440  		width(spaceWidth);
6441  	}
6442  };
6443  class Columns {
6444  	std::vector&lt;Column&gt; m_columns;
6445  public:
6446  	class iterator {
6447  		friend Columns;
6448  		struct EndTag {};
6449  		std::vector&lt;Column&gt; const&amp; m_columns;
6450  		std::vector&lt;Column::iterator&gt; m_iterators;
6451  		size_t m_activeIterators;
6452  		iterator(Columns const&amp; columns, EndTag)
6453  			: m_columns(columns.m_columns),
6454  			m_activeIterators(0) {
6455  			m_iterators.reserve(m_columns.size());
6456  			for (auto const&amp; col : m_columns)
6457  				m_iterators.push_back(col.end());
6458  		}
6459  	public:
6460  		using difference_type = std::ptrdiff_t;
6461  		using value_type = std::string;
6462  		using pointer = value_type * ;
6463  		using reference = value_type &amp; ;
6464  		using iterator_category = std::forward_iterator_tag;
6465  		explicit iterator(Columns const&amp; columns)
6466  			: m_columns(columns.m_columns),
6467  			m_activeIterators(m_columns.size()) {
6468  			m_iterators.reserve(m_columns.size());
6469  			for (auto const&amp; col : m_columns)
6470  				m_iterators.push_back(col.begin());
6471  		}
6472  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6473  			return m_iterators == other.m_iterators;
6474  		}
6475  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6476  			return m_iterators != other.m_iterators;
6477  		}
6478  		auto operator *() const -&gt; std::string {
6479  			std::string row, padding;
6480  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6481  				auto width = m_columns[i].width();
6482  				if (m_iterators[i] != m_columns[i].end()) {
6483  					std::string col = *m_iterators[i];
6484  					row += padding + col;
6485  					if (col.size() &lt; width)
6486  						padding = std::string(width - col.size(), &#x27; &#x27;);
6487  					else
6488  						padding = &quot;&quot;;
6489  				} else {
6490  					padding += std::string(width, &#x27; &#x27;);
6491  				}
6492  			}
6493  			return row;
6494  		}
6495  		auto operator ++() -&gt; iterator&amp; {
6496  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6497  				if (m_iterators[i] != m_columns[i].end())
6498  					++m_iterators[i];
6499  			}
6500  			return *this;
6501  		}
6502  		auto operator ++(int) -&gt; iterator {
6503  			iterator prev(*this);
6504  			operator++();
6505  			return prev;
6506  		}
6507  	};
6508  	using const_iterator = iterator;
6509  	auto begin() const -&gt; iterator { return iterator(*this); }
6510  	auto end() const -&gt; iterator { return { *this, iterator::EndTag() }; }
6511  	auto operator += (Column const&amp; col) -&gt; Columns&amp; {
6512  		m_columns.push_back(col);
6513  		return *this;
6514  	}
6515  	auto operator + (Column const&amp; col) -&gt; Columns {
6516  		Columns combined = *this;
6517  		combined += col;
6518  		return combined;
6519  	}
6520  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Columns const&amp; cols) {
6521  		bool first = true;
6522  		for (auto line : cols) {
6523  			if (first)
6524  				first = false;
6525  			else
6526  				os &lt;&lt; &quot;\n&quot;;
6527  			os &lt;&lt; line;
6528  		}
6529  		return os;
6530  	}
6531  	auto toString() const -&gt; std::string {
6532  		std::ostringstream oss;
6533  		oss &lt;&lt; *this;
6534  		return oss.str();
6535  	}
6536  };
6537  inline auto Column::operator + (Column const&amp; other) -&gt; Columns {
6538  	Columns cols;
6539  	cols += *this;
6540  	cols += other;
6541  	return cols;
6542  }
6543  }
6544  }
6545  }
6546  #include &lt;cctype&gt;
6547  #include &lt;string&gt;
6548  #include &lt;memory&gt;
6549  #include &lt;set&gt;
6550  #include &lt;algorithm&gt;
6551  #if !defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
6552  #define CATCH_PLATFORM_WINDOWS
6553  #endif
6554  namespace Catch { namespace clara {
6555  namespace detail {
6556      template&lt;typename L&gt;
6557      struct UnaryLambdaTraits : UnaryLambdaTraits&lt;decltype( &amp;L::operator() )&gt; {};
6558      template&lt;typename ClassT, typename ReturnT, typename... Args&gt;
6559      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( Args... ) const&gt; {
6560          static const bool isValid = false;
6561      };
6562      template&lt;typename ClassT, typename ReturnT, typename ArgT&gt;
6563      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( ArgT ) const&gt; {
6564          static const bool isValid = true;
6565          using ArgType = typename std::remove_const&lt;typename std::remove_reference&lt;ArgT&gt;::type&gt;::type;
6566          using ReturnType = ReturnT;
6567      };
6568      class TokenStream;
6569      class Args {
6570          friend TokenStream;
6571          std::string m_exeName;
6572          std::vector&lt;std::string&gt; m_args;
6573      public:
6574          Args( int argc, char const* const* argv )
6575              : m_exeName(argv[0]),
6576                m_args(argv + 1, argv + argc) {}
6577          Args( std::initializer_list&lt;std::string&gt; args )
6578          :   m_exeName( *args.begin() ),
6579              m_args( args.begin()+1, args.end() )
6580          {}
6581          auto exeName() const -&gt; std::string {
6582              return m_exeName;
6583          }
6584      };
6585      enum class TokenType {
6586          Option, Argument
6587      };
6588      struct Token {
6589          TokenType type;
6590          std::string token;
6591      };
6592      inline auto isOptPrefix( char c ) -&gt; bool {
6593          return c == &#x27;-&#x27;
6594  #ifdef CATCH_PLATFORM_WINDOWS
6595              || c == &#x27;/&#x27;
6596  #endif
6597          ;
6598      }
6599      class TokenStream {
6600          using Iterator = std::vector&lt;std::string&gt;::const_iterator;
6601          Iterator it;
6602          Iterator itEnd;
6603          std::vector&lt;Token&gt; m_tokenBuffer;
6604          void loadBuffer() {
6605              m_tokenBuffer.resize( 0 );
6606              while( it != itEnd &amp;&amp; it-&gt;empty() )
6607                  ++it;
6608              if( it != itEnd ) {
6609                  auto const &amp;next = *it;
6610                  if( isOptPrefix( next[0] ) ) {
6611                      auto delimiterPos = next.find_first_of( &quot; :=&quot; );
6612                      if( delimiterPos != std::string::npos ) {
6613                          m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
6614                          m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
6615                      } else {
6616                          if( next[1] != &#x27;-&#x27; &amp;&amp; next.size() &gt; 2 ) {
6617                              std::string opt = &quot;- &quot;;
6618                              for( size_t i = 1; i &lt; next.size(); ++i ) {
6619                                  opt[1] = next[i];
6620                                  m_tokenBuffer.push_back( { TokenType::Option, opt } );
6621                              }
6622                          } else {
6623                              m_tokenBuffer.push_back( { TokenType::Option, next } );
6624                          }
6625                      }
6626                  } else {
6627                      m_tokenBuffer.push_back( { TokenType::Argument, next } );
6628                  }
6629              }
6630          }
6631      public:
6632          explicit TokenStream( Args const &amp;args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
6633          TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
6634              loadBuffer();
6635          }
6636          explicit operator bool() const {
6637              return !m_tokenBuffer.empty() || it != itEnd;
6638          }
6639          auto count() const -&gt; size_t { return m_tokenBuffer.size() + (itEnd - it); }
6640          auto operator*() const -&gt; Token {
6641              assert( !m_tokenBuffer.empty() );
6642              return m_tokenBuffer.front();
6643          }
6644          auto operator-&gt;() const -&gt; Token const * {
6645              assert( !m_tokenBuffer.empty() );
6646              return &amp;m_tokenBuffer.front();
6647          }
6648          auto operator++() -&gt; TokenStream &amp; {
6649              if( m_tokenBuffer.size() &gt;= 2 ) {
6650                  m_tokenBuffer.erase( m_tokenBuffer.begin() );
6651              } else {
6652                  if( it != itEnd )
6653                      ++it;
6654                  loadBuffer();
6655              }
6656              return *this;
6657          }
6658      };
6659      class ResultBase {
6660      public:
6661          enum Type {
6662              Ok, LogicError, RuntimeError
6663          };
6664      protected:
6665          ResultBase( Type type ) : m_type( type ) {}
6666          virtual ~ResultBase() = default;
6667          virtual void enforceOk() const = 0;
6668          Type m_type;
6669      };
6670      template&lt;typename T&gt;
6671      class ResultValueBase : public ResultBase {
6672      public:
6673          auto value() const -&gt; T const &amp; {
6674              enforceOk();
6675              return m_value;
6676          }
6677      protected:
6678          ResultValueBase( Type type ) : ResultBase( type ) {}
6679          ResultValueBase( ResultValueBase const &amp;other ) : ResultBase( other ) {
6680              if( m_type == ResultBase::Ok )
6681                  new( &amp;m_value ) T( other.m_value );
6682          }
6683          ResultValueBase( Type, T const &amp;value ) : ResultBase( Ok ) {
6684              new( &amp;m_value ) T( value );
6685          }
6686          auto operator=( ResultValueBase const &amp;other ) -&gt; ResultValueBase &amp; {
6687              if( m_type == ResultBase::Ok )
6688                  m_value.~T();
6689              ResultBase::operator=(other);
6690              if( m_type == ResultBase::Ok )
6691                  new( &amp;m_value ) T( other.m_value );
6692              return *this;
6693          }
6694          ~ResultValueBase() override {
6695              if( m_type == Ok )
6696                  m_value.~T();
6697          }
6698          union {
6699              T m_value;
6700          };
6701      };
6702      template&lt;&gt;
6703      class ResultValueBase&lt;void&gt; : public ResultBase {
6704      protected:
6705          using ResultBase::ResultBase;
6706      };
6707      template&lt;typename T = void&gt;
6708      class BasicResult : public ResultValueBase&lt;T&gt; {
6709      public:
6710          template&lt;typename U&gt;
6711          explicit BasicResult( BasicResult&lt;U&gt; const &amp;other )
6712          :   ResultValueBase&lt;T&gt;( other.type() ),
6713              m_errorMessage( other.errorMessage() )
6714          {
6715              assert( type() != ResultBase::Ok );
6716          }
6717          template&lt;typename U&gt;
6718          static auto ok( U const &amp;value ) -&gt; BasicResult { return { ResultBase::Ok, value }; }
6719          static auto ok() -&gt; BasicResult { return { ResultBase::Ok }; }
6720          static auto logicError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::LogicError, message }; }
6721          static auto runtimeError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::RuntimeError, message }; }
6722          explicit operator bool() const { return m_type == ResultBase::Ok; }
6723          auto type() const -&gt; ResultBase::Type { return m_type; }
6724          auto errorMessage() const -&gt; std::string { return m_errorMessage; }
6725      protected:
6726          void enforceOk() const override {
6727              assert( m_type != ResultBase::LogicError );
6728              assert( m_type != ResultBase::RuntimeError );
6729              if( m_type != ResultBase::Ok )
6730                  std::abort();
6731          }
6732          std::string m_errorMessage; 
6733          BasicResult( ResultBase::Type type, std::string const &amp;message )
6734          :   ResultValueBase&lt;T&gt;(type),
6735              m_errorMessage(message)
6736          {
6737              assert( m_type != ResultBase::Ok );
6738          }
6739          using ResultValueBase&lt;T&gt;::ResultValueBase;
6740          using ResultBase::m_type;
6741      };
6742      enum class ParseResultType {
6743          Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
6744      };
6745      class ParseState {
6746      public:
6747          ParseState( ParseResultType type, TokenStream const &amp;remainingTokens )
6748          : m_type(type),
6749            m_remainingTokens( remainingTokens )
6750          {}
6751          auto type() const -&gt; ParseResultType { return m_type; }
6752          auto remainingTokens() const -&gt; TokenStream { return m_remainingTokens; }
6753      private:
6754          ParseResultType m_type;
6755          TokenStream m_remainingTokens;
6756      };
6757      using Result = BasicResult&lt;void&gt;;
6758      using ParserResult = BasicResult&lt;ParseResultType&gt;;
6759      using InternalParseResult = BasicResult&lt;ParseState&gt;;
6760      struct HelpColumns {
6761          std::string left;
6762          std::string right;
6763      };
6764      template&lt;typename T&gt;
6765      inline auto convertInto( std::string const &amp;source, T&amp; target ) -&gt; ParserResult {
6766          std::stringstream ss;
6767          ss &lt;&lt; source;
6768          ss &gt;&gt; target;
6769          if( ss.fail() )
6770              return ParserResult::runtimeError( &quot;Unable to convert &#x27;&quot; + source + &quot;&#x27; to destination type&quot; );
6771          else
6772              return ParserResult::ok( ParseResultType::Matched );
6773      }
6774      inline auto convertInto( std::string const &amp;source, std::string&amp; target ) -&gt; ParserResult {
6775          target = source;
6776          return ParserResult::ok( ParseResultType::Matched );
6777      }
6778      inline auto convertInto( std::string const &amp;source, bool &amp;target ) -&gt; ParserResult {
6779          std::string srcLC = source;
6780          std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( unsigned char c ) { return static_cast&lt;char&gt;( std::tolower(c) ); } );
6781          if (srcLC == &quot;y&quot; || srcLC == &quot;1&quot; || srcLC == &quot;true&quot; || srcLC == &quot;yes&quot; || srcLC == &quot;on&quot;)
6782              target = true;
6783          else if (srcLC == &quot;n&quot; || srcLC == &quot;0&quot; || srcLC == &quot;false&quot; || srcLC == &quot;no&quot; || srcLC == &quot;off&quot;)
6784              target = false;
6785          else
6786              return ParserResult::runtimeError( &quot;Expected a boolean value but did not recognise: &#x27;&quot; + source + &quot;&#x27;&quot; );
6787          return ParserResult::ok( ParseResultType::Matched );
6788      }
6789  #ifdef CLARA_CONFIG_OPTIONAL_TYPE
6790      template&lt;typename T&gt;
6791      inline auto convertInto( std::string const &amp;source, CLARA_CONFIG_OPTIONAL_TYPE&lt;T&gt;&amp; target ) -&gt; ParserResult {
6792          T temp;
6793          auto result = convertInto( source, temp );
6794          if( result )
6795              target = std::move(temp);
6796          return result;
6797      }
6798  #endif 
6799      struct NonCopyable {
6800          NonCopyable() = default;
6801          NonCopyable( NonCopyable const &amp; ) = delete;
6802          NonCopyable( NonCopyable &amp;&amp; ) = delete;
6803          NonCopyable &amp;operator=( NonCopyable const &amp; ) = delete;
6804          NonCopyable &amp;operator=( NonCopyable &amp;&amp; ) = delete;
6805      };
6806      struct BoundRef : NonCopyable {
6807          virtual ~BoundRef() = default;
6808          virtual auto isContainer() const -&gt; bool { return false; }
6809          virtual auto isFlag() const -&gt; bool { return false; }
6810      };
6811      struct BoundValueRefBase : BoundRef {
6812          virtual auto setValue( std::string const &amp;arg ) -&gt; ParserResult = 0;
6813      };
6814      struct BoundFlagRefBase : BoundRef {
6815          virtual auto setFlag( bool flag ) -&gt; ParserResult = 0;
6816          virtual auto isFlag() const -&gt; bool { return true; }
6817      };
6818      template&lt;typename T&gt;
6819      struct BoundValueRef : BoundValueRefBase {
6820          T &amp;m_ref;
6821          explicit BoundValueRef( T &amp;ref ) : m_ref( ref ) {}
6822          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6823              return convertInto( arg, m_ref );
6824          }
6825      };
6826      template&lt;typename T&gt;
6827      struct BoundValueRef&lt;std::vector&lt;T&gt;&gt; : BoundValueRefBase {
6828          std::vector&lt;T&gt; &amp;m_ref;
6829          explicit BoundValueRef( std::vector&lt;T&gt; &amp;ref ) : m_ref( ref ) {}
6830          auto isContainer() const -&gt; bool override { return true; }
6831          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6832              T temp;
6833              auto result = convertInto( arg, temp );
6834              if( result )
6835                  m_ref.push_back( temp );
6836              return result;
6837          }
6838      };
6839      struct BoundFlagRef : BoundFlagRefBase {
6840          bool &amp;m_ref;
6841          explicit BoundFlagRef( bool &amp;ref ) : m_ref( ref ) {}
6842          auto setFlag( bool flag ) -&gt; ParserResult override {
6843              m_ref = flag;
6844              return ParserResult::ok( ParseResultType::Matched );
6845          }
6846      };
6847      template&lt;typename ReturnType&gt;
6848      struct LambdaInvoker {
6849          static_assert( std::is_same&lt;ReturnType, ParserResult&gt;::value, &quot;Lambda must return void or clara::ParserResult&quot; );
6850          template&lt;typename L, typename ArgType&gt;
6851          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6852              return lambda( arg );
6853          }
6854      };
6855      template&lt;&gt;
6856      struct LambdaInvoker&lt;void&gt; {
6857          template&lt;typename L, typename ArgType&gt;
6858          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6859              lambda( arg );
6860              return ParserResult::ok( ParseResultType::Matched );
6861          }
6862      };
6863      template&lt;typename ArgType, typename L&gt;
6864      inline auto invokeLambda( L const &amp;lambda, std::string const &amp;arg ) -&gt; ParserResult {
6865          ArgType temp{};
6866          auto result = convertInto( arg, temp );
6867          return !result
6868             ? result
6869             : LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( lambda, temp );
6870      }
6871      template&lt;typename L&gt;
6872      struct BoundLambda : BoundValueRefBase {
6873          L m_lambda;
6874          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6875          explicit BoundLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6876          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6877              return invokeLambda&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType&gt;( m_lambda, arg );
6878          }
6879      };
6880      template&lt;typename L&gt;
6881      struct BoundFlagLambda : BoundFlagRefBase {
6882          L m_lambda;
6883          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6884          static_assert( std::is_same&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType, bool&gt;::value, &quot;flags must be boolean&quot; );
6885          explicit BoundFlagLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6886          auto setFlag( bool flag ) -&gt; ParserResult override {
6887              return LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( m_lambda, flag );
6888          }
6889      };
6890      enum class Optionality { Optional, Required };
6891      struct Parser;
6892      class ParserBase {
6893      public:
6894          virtual ~ParserBase() = default;
6895          virtual auto validate() const -&gt; Result { return Result::ok(); }
6896          virtual auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens) const -&gt; InternalParseResult  = 0;
6897          virtual auto cardinality() const -&gt; size_t { return 1; }
6898          auto parse( Args const &amp;args ) const -&gt; InternalParseResult {
6899              return parse( args.exeName(), TokenStream( args ) );
6900          }
6901      };
6902      template&lt;typename DerivedT&gt;
6903      class ComposableParserImpl : public ParserBase {
6904      public:
6905          template&lt;typename T&gt;
6906          auto operator|( T const &amp;other ) const -&gt; Parser;
6907  		template&lt;typename T&gt;
6908          auto operator+( T const &amp;other ) const -&gt; Parser;
6909      };
6910      template&lt;typename DerivedT&gt;
6911      class ParserRefImpl : public ComposableParserImpl&lt;DerivedT&gt; {
6912      protected:
6913          Optionality m_optionality = Optionality::Optional;
6914          std::shared_ptr&lt;BoundRef&gt; m_ref;
6915          std::string m_hint;
6916          std::string m_description;
6917          explicit ParserRefImpl( std::shared_ptr&lt;BoundRef&gt; const &amp;ref ) : m_ref( ref ) {}
6918      public:
6919          template&lt;typename T&gt;
6920          ParserRefImpl( T &amp;ref, std::string const &amp;hint )
6921          :   m_ref( std::make_shared&lt;BoundValueRef&lt;T&gt;&gt;( ref ) ),
6922              m_hint( hint )
6923          {}
6924          template&lt;typename LambdaT&gt;
6925          ParserRefImpl( LambdaT const &amp;ref, std::string const &amp;hint )
6926          :   m_ref( std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( ref ) ),
6927              m_hint(hint)
6928          {}
6929          auto operator()( std::string const &amp;description ) -&gt; DerivedT &amp; {
6930              m_description = description;
6931              return static_cast&lt;DerivedT &amp;&gt;( *this );
6932          }
6933          auto optional() -&gt; DerivedT &amp; {
6934              m_optionality = Optionality::Optional;
6935              return static_cast&lt;DerivedT &amp;&gt;( *this );
6936          };
6937          auto required() -&gt; DerivedT &amp; {
6938              m_optionality = Optionality::Required;
6939              return static_cast&lt;DerivedT &amp;&gt;( *this );
6940          };
6941          auto isOptional() const -&gt; bool {
6942              return m_optionality == Optionality::Optional;
6943          }
6944          auto cardinality() const -&gt; size_t override {
6945              if( m_ref-&gt;isContainer() )
6946                  return 0;
6947              else
6948                  return 1;
6949          }
6950          auto hint() const -&gt; std::string { return m_hint; }
6951      };
6952      class ExeName : public ComposableParserImpl&lt;ExeName&gt; {
6953          std::shared_ptr&lt;std::string&gt; m_name;
6954          std::shared_ptr&lt;BoundValueRefBase&gt; m_ref;
6955          template&lt;typename LambdaT&gt;
6956          static auto makeRef(LambdaT const &amp;lambda) -&gt; std::shared_ptr&lt;BoundValueRefBase&gt; {
6957              return std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda) ;
6958          }
6959      public:
6960          ExeName() : m_name( std::make_shared&lt;std::string&gt;( &quot;&lt;executable&gt;&quot; ) ) {}
6961          explicit ExeName( std::string &amp;ref ) : ExeName() {
6962              m_ref = std::make_shared&lt;BoundValueRef&lt;std::string&gt;&gt;( ref );
6963          }
6964          template&lt;typename LambdaT&gt;
6965          explicit ExeName( LambdaT const&amp; lambda ) : ExeName() {
6966              m_ref = std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda );
6967          }
6968          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6969              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
6970          }
6971          auto name() const -&gt; std::string { return *m_name; }
6972          auto set( std::string const&amp; newName ) -&gt; ParserResult {
6973              auto lastSlash = newName.find_last_of( &quot;\\/&quot; );
6974              auto filename = ( lastSlash == std::string::npos )
6975                      ? newName
6976                      : newName.substr( lastSlash+1 );
6977              *m_name = filename;
6978              if( m_ref )
6979                  return m_ref-&gt;setValue( filename );
6980              else
6981                  return ParserResult::ok( ParseResultType::Matched );
6982          }
6983      };
6984      class Arg : public ParserRefImpl&lt;Arg&gt; {
6985      public:
6986          using ParserRefImpl::ParserRefImpl;
6987          auto parse( std::string const &amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6988              auto validationResult = validate();
6989              if( !validationResult )
6990                  return InternalParseResult( validationResult );
6991              auto remainingTokens = tokens;
6992              auto const &amp;token = *remainingTokens;
6993              if( token.type != TokenType::Argument )
6994                  return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
6995              assert( !m_ref-&gt;isFlag() );
6996              auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
6997              auto result = valueRef-&gt;setValue( remainingTokens-&gt;token );
6998              if( !result )
6999                  return InternalParseResult( result );
7000              else
7001                  return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7002          }
7003      };
7004      inline auto normaliseOpt( std::string const &amp;optName ) -&gt; std::string {
7005  #ifdef CATCH_PLATFORM_WINDOWS
7006          if( optName[0] == &#x27;/&#x27; )
7007              return &quot;-&quot; + optName.substr( 1 );
7008          else
7009  #endif
7010              return optName;
7011      }
7012      class Opt : public ParserRefImpl&lt;Opt&gt; {
7013      protected:
7014          std::vector&lt;std::string&gt; m_optNames;
7015      public:
7016          template&lt;typename LambdaT&gt;
7017          explicit Opt( LambdaT const &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagLambda&lt;LambdaT&gt;&gt;( ref ) ) {}
7018          explicit Opt( bool &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagRef&gt;( ref ) ) {}
7019          template&lt;typename LambdaT&gt;
7020          Opt( LambdaT const &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7021          template&lt;typename T&gt;
7022          Opt( T &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7023          auto operator[]( std::string const &amp;optName ) -&gt; Opt &amp; {
7024              m_optNames.push_back( optName );
7025              return *this;
7026          }
7027          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7028              std::ostringstream oss;
7029              bool first = true;
7030              for( auto const &amp;opt : m_optNames ) {
7031                  if (first)
7032                      first = false;
7033                  else
7034                      oss &lt;&lt; &quot;, &quot;;
7035                  oss &lt;&lt; opt;
7036              }
7037              if( !m_hint.empty() )
7038                  oss &lt;&lt; &quot; &lt;&quot; &lt;&lt; m_hint &lt;&lt; &quot;&gt;&quot;;
7039              return { { oss.str(), m_description } };
7040          }
7041          auto isMatch( std::string const &amp;optToken ) const -&gt; bool {
7042              auto normalisedToken = normaliseOpt( optToken );
7043              for( auto const &amp;name : m_optNames ) {
7044                  if( normaliseOpt( name ) == normalisedToken )
7045                      return true;
7046              }
7047              return false;
7048          }
7049          using ParserBase::parse;
7050          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7051              auto validationResult = validate();
7052              if( !validationResult )
7053                  return InternalParseResult( validationResult );
7054              auto remainingTokens = tokens;
7055              if( remainingTokens &amp;&amp; remainingTokens-&gt;type == TokenType::Option ) {
7056                  auto const &amp;token = *remainingTokens;
7057                  if( isMatch(token.token ) ) {
7058                      if( m_ref-&gt;isFlag() ) {
7059                          auto flagRef = static_cast&lt;detail::BoundFlagRefBase*&gt;( m_ref.get() );
7060                          auto result = flagRef-&gt;setFlag( true );
7061                          if( !result )
7062                              return InternalParseResult( result );
7063                          if( result.value() == ParseResultType::ShortCircuitAll )
7064                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7065                      } else {
7066                          auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
7067                          ++remainingTokens;
7068                          if( !remainingTokens )
7069                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7070                          auto const &amp;argToken = *remainingTokens;
7071                          if( argToken.type != TokenType::Argument )
7072                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7073                          auto result = valueRef-&gt;setValue( argToken.token );
7074                          if( !result )
7075                              return InternalParseResult( result );
7076                          if( result.value() == ParseResultType::ShortCircuitAll )
7077                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7078                      }
7079                      return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7080                  }
7081              }
7082              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
7083          }
7084          auto validate() const -&gt; Result override {
7085              if( m_optNames.empty() )
7086                  return Result::logicError( &quot;No options supplied to Opt&quot; );
7087              for( auto const &amp;name : m_optNames ) {
7088                  if( name.empty() )
7089                      return Result::logicError( &quot;Option name cannot be empty&quot; );
7090  #ifdef CATCH_PLATFORM_WINDOWS
7091                  if( name[0] != &#x27;-&#x27; &amp;&amp; name[0] != &#x27;/&#x27; )
7092                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27; or &#x27;/&#x27;&quot; );
7093  #else
7094                  if( name[0] != &#x27;-&#x27; )
7095                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27;&quot; );
7096  #endif
7097              }
7098              return ParserRefImpl::validate();
7099          }
7100      };
7101      struct Help : Opt {
7102          Help( bool &amp;showHelpFlag )
7103          :   Opt([&amp;]( bool flag ) {
7104                  showHelpFlag = flag;
7105                  return ParserResult::ok( ParseResultType::ShortCircuitAll );
7106              })
7107          {
7108              static_cast&lt;Opt &amp;&gt;( *this )
7109                      (&quot;display usage information&quot;)
7110                      [&quot;-?&quot;][&quot;-h&quot;][&quot;--help&quot;]
7111                      .optional();
7112          }
7113      };
7114      struct Parser : ParserBase {
7115          mutable ExeName m_exeName;
7116          std::vector&lt;Opt&gt; m_options;
7117          std::vector&lt;Arg&gt; m_args;
7118          auto operator|=( ExeName const &amp;exeName ) -&gt; Parser &amp; {
7119              m_exeName = exeName;
7120              return *this;
7121          }
7122          auto operator|=( Arg const &amp;arg ) -&gt; Parser &amp; {
7123              m_args.push_back(arg);
7124              return *this;
7125          }
7126          auto operator|=( Opt const &amp;opt ) -&gt; Parser &amp; {
7127              m_options.push_back(opt);
7128              return *this;
7129          }
7130          auto operator|=( Parser const &amp;other ) -&gt; Parser &amp; {
7131              m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
7132              m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
7133              return *this;
7134          }
7135          template&lt;typename T&gt;
7136          auto operator|( T const &amp;other ) const -&gt; Parser {
7137              return Parser( *this ) |= other;
7138          }
7139          template&lt;typename T&gt;
7140          auto operator+=( T const &amp;other ) -&gt; Parser &amp; { return operator|=( other ); }
7141          template&lt;typename T&gt;
7142          auto operator+( T const &amp;other ) const -&gt; Parser { return operator|( other ); }
7143          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7144              std::vector&lt;HelpColumns&gt; cols;
7145              for (auto const &amp;o : m_options) {
7146                  auto childCols = o.getHelpColumns();
7147                  cols.insert( cols.end(), childCols.begin(), childCols.end() );
7148              }
7149              return cols;
7150          }
7151          void writeToStream( std::ostream &amp;os ) const {
7152              if (!m_exeName.name().empty()) {
7153                  os &lt;&lt; &quot;usage:\n&quot; &lt;&lt; &quot;  &quot; &lt;&lt; m_exeName.name() &lt;&lt; &quot; &quot;;
7154                  bool required = true, first = true;
7155                  for( auto const &amp;arg : m_args ) {
7156                      if (first)
7157                          first = false;
7158                      else
7159                          os &lt;&lt; &quot; &quot;;
7160                      if( arg.isOptional() &amp;&amp; required ) {
7161                          os &lt;&lt; &quot;[&quot;;
7162                          required = false;
7163                      }
7164                      os &lt;&lt; &quot;&lt;&quot; &lt;&lt; arg.hint() &lt;&lt; &quot;&gt;&quot;;
7165                      if( arg.cardinality() == 0 )
7166                          os &lt;&lt; &quot; ... &quot;;
7167                  }
7168                  if( !required )
7169                      os &lt;&lt; &quot;]&quot;;
7170                  if( !m_options.empty() )
7171                      os &lt;&lt; &quot; options&quot;;
7172                  os &lt;&lt; &quot;\n\nwhere options are:&quot; &lt;&lt; std::endl;
7173              }
7174              auto rows = getHelpColumns();
7175              size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
7176              size_t optWidth = 0;
7177              for( auto const &amp;cols : rows )
7178                  optWidth = (std::max)(optWidth, cols.left.size() + 2);
7179              optWidth = (std::min)(optWidth, consoleWidth/2);
7180              for( auto const &amp;cols : rows ) {
7181                  auto row =
7182                          TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
7183                          TextFlow::Spacer(4) +
7184                          TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
7185                  os &lt;&lt; row &lt;&lt; std::endl;
7186              }
7187          }
7188          friend auto operator&lt;&lt;( std::ostream &amp;os, Parser const &amp;parser ) -&gt; std::ostream&amp; {
7189              parser.writeToStream( os );
7190              return os;
7191          }
7192          auto validate() const -&gt; Result override {
7193              for( auto const &amp;opt : m_options ) {
7194                  auto result = opt.validate();
7195                  if( !result )
7196                      return result;
7197              }
7198              for( auto const &amp;arg : m_args ) {
7199                  auto result = arg.validate();
7200                  if( !result )
7201                      return result;
7202              }
7203              return Result::ok();
7204          }
7205          using ParserBase::parse;
7206          auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7207              struct ParserInfo {
7208                  ParserBase const* parser = nullptr;
7209                  size_t count = 0;
7210              };
7211              const size_t totalParsers = m_options.size() + m_args.size();
7212              assert( totalParsers &lt; 512 );
7213              ParserInfo parseInfos[512];
7214              {
7215                  size_t i = 0;
7216                  for (auto const &amp;opt : m_options) parseInfos[i++].parser = &amp;opt;
7217                  for (auto const &amp;arg : m_args) parseInfos[i++].parser = &amp;arg;
7218              }
7219              m_exeName.set( exeName );
7220              auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
7221              while( result.value().remainingTokens() ) {
7222                  bool tokenParsed = false;
7223                  for( size_t i = 0; i &lt; totalParsers; ++i ) {
7224                      auto&amp;  parseInfo = parseInfos[i];
7225                      if( parseInfo.parser-&gt;cardinality() == 0 || parseInfo.count &lt; parseInfo.parser-&gt;cardinality() ) {
7226                          result = parseInfo.parser-&gt;parse(exeName, result.value().remainingTokens());
7227                          if (!result)
7228                              return result;
7229                          if (result.value().type() != ParseResultType::NoMatch) {
7230                              tokenParsed = true;
7231                              ++parseInfo.count;
7232                              break;
7233                          }
7234                      }
7235                  }
7236                  if( result.value().type() == ParseResultType::ShortCircuitAll )
7237                      return result;
7238                  if( !tokenParsed )
7239                      return InternalParseResult::runtimeError( &quot;Unrecognised token: &quot; + result.value().remainingTokens()-&gt;token );
7240              }
7241              return result;
7242          }
7243      };
7244      template&lt;typename DerivedT&gt;
7245      template&lt;typename T&gt;
7246      auto ComposableParserImpl&lt;DerivedT&gt;::operator|( T const &amp;other ) const -&gt; Parser {
7247          return Parser() | static_cast&lt;DerivedT const &amp;&gt;( *this ) | other;
7248      }
7249  } 
7250  using detail::Parser;
7251  using detail::Opt;
7252  using detail::Arg;
7253  using detail::Args;
7254  using detail::ExeName;
7255  using detail::Help;
7256  using detail::ParseResultType;
7257  using detail::ParserResult;
7258  }} 
7259  #ifdef __clang__
7260  #pragma clang diagnostic pop
7261  #endif
7262  #ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7263  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7264  #undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7265  #endif
7266  namespace Catch {
7267      clara::Parser makeCommandLineParser( ConfigData&amp; config );
7268  } 
7269  #include &lt;fstream&gt;
7270  #include &lt;ctime&gt;
7271  namespace Catch {
7272      clara::Parser makeCommandLineParser( ConfigData&amp; config ) {
7273          using namespace clara;
7274          auto const setWarning = [&amp;]( std::string const&amp; warning ) {
7275                  auto warningSet = [&amp;]() {
7276                      if( warning == &quot;NoAssertions&quot; )
7277                          return WarnAbout::NoAssertions;
7278                      if ( warning == &quot;NoTests&quot; )
7279                          return WarnAbout::NoTests;
7280                      return WarnAbout::Nothing;
7281                  }();
7282                  if (warningSet == WarnAbout::Nothing)
7283                      return ParserResult::runtimeError( &quot;Unrecognised warning: &#x27;&quot; + warning + &quot;&#x27;&quot; );
7284                  config.warnings = static_cast&lt;WarnAbout::What&gt;( config.warnings | warningSet );
7285                  return ParserResult::ok( ParseResultType::Matched );
7286              };
7287          auto const loadTestNamesFromFile = [&amp;]( std::string const&amp; filename ) {
7288                  std::ifstream f( filename.c_str() );
7289                  if( !f.is_open() )
7290                      return ParserResult::runtimeError( &quot;Unable to load input file: &#x27;&quot; + filename + &quot;&#x27;&quot; );
7291                  std::string line;
7292                  while( std::getline( f, line ) ) {
7293                      line = trim(line);
7294                      if( !line.empty() &amp;&amp; !startsWith( line, &#x27;#&#x27; ) ) {
7295                          if( !startsWith( line, &#x27;&quot;&#x27; ) )
7296                              line = &#x27;&quot;&#x27; + line + &#x27;&quot;&#x27;;
7297                          config.testsOrTags.push_back( line );
7298                          config.testsOrTags.emplace_back( &quot;,&quot; );
7299                      }
7300                  }
7301                  if(!config.testsOrTags.empty())
7302                      config.testsOrTags.erase( config.testsOrTags.end()-1 );
7303                  return ParserResult::ok( ParseResultType::Matched );
7304              };
7305          auto const setTestOrder = [&amp;]( std::string const&amp; order ) {
7306                  if( startsWith( &quot;declared&quot;, order ) )
7307                      config.runOrder = RunTests::InDeclarationOrder;
7308                  else if( startsWith( &quot;lexical&quot;, order ) )
7309                      config.runOrder = RunTests::InLexicographicalOrder;
7310                  else if( startsWith( &quot;random&quot;, order ) )
7311                      config.runOrder = RunTests::InRandomOrder;
7312                  else
7313                      return clara::ParserResult::runtimeError( &quot;Unrecognised ordering: &#x27;&quot; + order + &quot;&#x27;&quot; );
7314                  return ParserResult::ok( ParseResultType::Matched );
7315              };
7316          auto const setRngSeed = [&amp;]( std::string const&amp; seed ) {
7317                  if( seed != &quot;time&quot; )
7318                      return clara::detail::convertInto( seed, config.rngSeed );
7319                  config.rngSeed = static_cast&lt;unsigned int&gt;( std::time(nullptr) );
7320                  return ParserResult::ok( ParseResultType::Matched );
7321              };
7322          auto const setColourUsage = [&amp;]( std::string const&amp; useColour ) {
7323                      auto mode = toLower( useColour );
7324                      if( mode == &quot;yes&quot; )
7325                          config.useColour = UseColour::Yes;
7326                      else if( mode == &quot;no&quot; )
7327                          config.useColour = UseColour::No;
7328                      else if( mode == &quot;auto&quot; )
7329                          config.useColour = UseColour::Auto;
7330                      else
7331                          return ParserResult::runtimeError( &quot;colour mode must be one of: auto, yes or no. &#x27;&quot; + useColour + &quot;&#x27; not recognised&quot; );
7332                  return ParserResult::ok( ParseResultType::Matched );
7333              };
7334          auto const setWaitForKeypress = [&amp;]( std::string const&amp; keypress ) {
7335                  auto keypressLc = toLower( keypress );
7336                  if (keypressLc == &quot;never&quot;)
7337                      config.waitForKeypress = WaitForKeypress::Never;
7338                  else if( keypressLc == &quot;start&quot; )
7339                      config.waitForKeypress = WaitForKeypress::BeforeStart;
7340                  else if( keypressLc == &quot;exit&quot; )
7341                      config.waitForKeypress = WaitForKeypress::BeforeExit;
7342                  else if( keypressLc == &quot;both&quot; )
7343                      config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
7344                  else
7345                      return ParserResult::runtimeError( &quot;keypress argument must be one of: never, start, exit or both. &#x27;&quot; + keypress + &quot;&#x27; not recognised&quot; );
7346              return ParserResult::ok( ParseResultType::Matched );
7347              };
7348          auto const setVerbosity = [&amp;]( std::string const&amp; verbosity ) {
7349              auto lcVerbosity = toLower( verbosity );
7350              if( lcVerbosity == &quot;quiet&quot; )
7351                  config.verbosity = Verbosity::Quiet;
7352              else if( lcVerbosity == &quot;normal&quot; )
7353                  config.verbosity = Verbosity::Normal;
7354              else if( lcVerbosity == &quot;high&quot; )
7355                  config.verbosity = Verbosity::High;
7356              else
7357                  return ParserResult::runtimeError( &quot;Unrecognised verbosity, &#x27;&quot; + verbosity + &quot;&#x27;&quot; );
7358              return ParserResult::ok( ParseResultType::Matched );
7359          };
7360          auto const setReporter = [&amp;]( std::string const&amp; reporter ) {
7361              IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
7362              auto lcReporter = toLower( reporter );
7363              auto result = factories.find( lcReporter );
7364              if( factories.end() != result )
7365                  config.reporterName = lcReporter;
7366              else
7367                  return ParserResult::runtimeError( &quot;Unrecognized reporter, &#x27;&quot; + reporter + &quot;&#x27;. Check available with --list-reporters&quot; );
7368              return ParserResult::ok( ParseResultType::Matched );
7369          };
7370          auto cli
7371              = ExeName( config.processName )
7372              | Help( config.showHelp )
7373              | Opt( config.listTests )
7374                  [&quot;-l&quot;][&quot;--list-tests&quot;]
7375                  ( &quot;list all/matching test cases&quot; )
7376              | Opt( config.listTags )
7377                  [&quot;-t&quot;][&quot;--list-tags&quot;]
7378                  ( &quot;list all/matching tags&quot; )
7379              | Opt( config.showSuccessfulTests )
7380                  [&quot;-s&quot;][&quot;--success&quot;]
7381                  ( &quot;include successful tests in output&quot; )
7382              | Opt( config.shouldDebugBreak )
7383                  [&quot;-b&quot;][&quot;--break&quot;]
7384                  ( &quot;break into debugger on failure&quot; )
7385              | Opt( config.noThrow )
7386                  [&quot;-e&quot;][&quot;--nothrow&quot;]
7387                  ( &quot;skip exception tests&quot; )
7388              | Opt( config.showInvisibles )
7389                  [&quot;-i&quot;][&quot;--invisibles&quot;]
7390                  ( &quot;show invisibles (tabs, newlines)&quot; )
7391              | Opt( config.outputFilename, &quot;filename&quot; )
7392                  [&quot;-o&quot;][&quot;--out&quot;]
7393                  ( &quot;output filename&quot; )
7394              | Opt( setReporter, &quot;name&quot; )
7395                  [&quot;-r&quot;][&quot;--reporter&quot;]
7396                  ( &quot;reporter to use (defaults to console)&quot; )
7397              | Opt( config.name, &quot;name&quot; )
7398                  [&quot;-n&quot;][&quot;--name&quot;]
7399                  ( &quot;suite name&quot; )
7400              | Opt( [&amp;]( bool ){ config.abortAfter = 1; } )
7401                  [&quot;-a&quot;][&quot;--abort&quot;]
7402                  ( &quot;abort at first failure&quot; )
7403              | Opt( [&amp;]( int x ){ config.abortAfter = x; }, &quot;no. failures&quot; )
7404                  [&quot;-x&quot;][&quot;--abortx&quot;]
7405                  ( &quot;abort after x failures&quot; )
7406              | Opt( setWarning, &quot;warning name&quot; )
7407                  [&quot;-w&quot;][&quot;--warn&quot;]
7408                  ( &quot;enable warnings&quot; )
7409              | Opt( [&amp;]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, &quot;yes|no&quot; )
7410                  [&quot;-d&quot;][&quot;--durations&quot;]
7411                  ( &quot;show test durations&quot; )
7412              | Opt( config.minDuration, &quot;seconds&quot; )
7413                  [&quot;-D&quot;][&quot;--min-duration&quot;]
7414                  ( &quot;show test durations for tests taking at least the given number of seconds&quot; )
7415              | Opt( loadTestNamesFromFile, &quot;filename&quot; )
7416                  [&quot;-f&quot;][&quot;--input-file&quot;]
7417                  ( &quot;load test names to run from a file&quot; )
7418              | Opt( config.filenamesAsTags )
7419                  [&quot;-#&quot;][&quot;--filenames-as-tags&quot;]
7420                  ( &quot;adds a tag for the filename&quot; )
7421              | Opt( config.sectionsToRun, &quot;section name&quot; )
7422                  [&quot;-c&quot;][&quot;--section&quot;]
7423                  ( &quot;specify section to run&quot; )
7424              | Opt( setVerbosity, &quot;quiet|normal|high&quot; )
7425                  [&quot;-v&quot;][&quot;--verbosity&quot;]
7426                  ( &quot;set output verbosity&quot; )
7427              | Opt( config.listTestNamesOnly )
7428                  [&quot;--list-test-names-only&quot;]
7429                  ( &quot;list all/matching test cases names only&quot; )
7430              | Opt( config.listReporters )
7431                  [&quot;--list-reporters&quot;]
7432                  ( &quot;list all reporters&quot; )
7433              | Opt( setTestOrder, &quot;decl|lex|rand&quot; )
7434                  [&quot;--order&quot;]
7435                  ( &quot;test case order (defaults to decl)&quot; )
7436              | Opt( setRngSeed, &quot;&#x27;time&#x27;|number&quot; )
7437                  [&quot;--rng-seed&quot;]
7438                  ( &quot;set a specific seed for random numbers&quot; )
7439              | Opt( setColourUsage, &quot;yes|no&quot; )
7440                  [&quot;--use-colour&quot;]
7441                  ( &quot;should output be colourised&quot; )
7442              | Opt( config.libIdentify )
7443                  [&quot;--libidentify&quot;]
7444                  ( &quot;report name and version according to libidentify standard&quot; )
7445              | Opt( setWaitForKeypress, &quot;never|start|exit|both&quot; )
7446                  [&quot;--wait-for-keypress&quot;]
7447                  ( &quot;waits for a keypress before exiting&quot; )
7448              | Opt( config.benchmarkSamples, &quot;samples&quot; )
7449                  [&quot;--benchmark-samples&quot;]
7450                  ( &quot;number of samples to collect (default: 100)&quot; )
7451              | Opt( config.benchmarkResamples, &quot;resamples&quot; )
7452                  [&quot;--benchmark-resamples&quot;]
7453                  ( &quot;number of resamples for the bootstrap (default: 100000)&quot; )
7454              | Opt( config.benchmarkConfidenceInterval, &quot;confidence interval&quot; )
7455                  [&quot;--benchmark-confidence-interval&quot;]
7456                  ( &quot;confidence interval for the bootstrap (between 0 and 1, default: 0.95)&quot; )
7457              | Opt( config.benchmarkNoAnalysis )
7458                  [&quot;--benchmark-no-analysis&quot;]
7459                  ( &quot;perform only measurements; do not perform any analysis&quot; )
7460              | Opt( config.benchmarkWarmupTime, &quot;benchmarkWarmupTime&quot; )
7461                  [&quot;--benchmark-warmup-time&quot;]
7462                  ( &quot;amount of time in milliseconds spent on warming up each test (default: 100)&quot; )
7463              | Arg( config.testsOrTags, &quot;test name|pattern|tags&quot; )
7464                  ( &quot;which test or tests to use&quot; );
7465          return cli;
7466      }
7467  } 
7468  #include &lt;cstring&gt;
7469  #include &lt;ostream&gt;
7470  namespace Catch {
7471      bool SourceLineInfo::operator == ( SourceLineInfo const&amp; other ) const noexcept {
7472          return line == other.line &amp;&amp; (file == other.file || std::strcmp(file, other.file) == 0);
7473      }
7474      bool SourceLineInfo::operator &lt; ( SourceLineInfo const&amp; other ) const noexcept {
7475          return line &lt; other.line || ( line == other.line &amp;&amp; file != other.file &amp;&amp; (std::strcmp(file, other.file) &lt; 0));
7476      }
7477      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, SourceLineInfo const&amp; info ) {
7478  #ifndef __GNUG__
7479          os &lt;&lt; info.file &lt;&lt; &#x27;(&#x27; &lt;&lt; info.line &lt;&lt; &#x27;)&#x27;;
7480  #else
7481          os &lt;&lt; info.file &lt;&lt; &#x27;:&#x27; &lt;&lt; info.line;
7482  #endif
7483          return os;
7484      }
7485      std::string StreamEndStop::operator+() const {
7486          return std::string();
7487      }
7488      NonCopyable::NonCopyable() = default;
7489      NonCopyable::~NonCopyable() = default;
7490  }
7491  namespace Catch {
7492      Config::Config( ConfigData const&amp; data )
7493      :   m_data( data ),
7494          m_stream( openStream() )
7495      {
7496          for (auto&amp; elem : m_data.testsOrTags) {
7497              elem = trim(elem);
7498          }
7499          for (auto&amp; elem : m_data.sectionsToRun) {
7500              elem = trim(elem);
7501          }
7502          TestSpecParser parser(ITagAliasRegistry::get());
7503          if (!m_data.testsOrTags.empty()) {
7504              m_hasTestFilters = true;
7505              for (auto const&amp; testOrTags : m_data.testsOrTags) {
7506                  parser.parse(testOrTags);
7507              }
7508          }
7509          m_testSpec = parser.testSpec();
7510      }
7511      std::string const&amp; Config::getFilename() const {
7512          return m_data.outputFilename ;
7513      }
7514      bool Config::listTests() const          { return m_data.listTests; }
7515      bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
7516      bool Config::listTags() const           { return m_data.listTags; }
7517      bool Config::listReporters() const      { return m_data.listReporters; }
7518      std::string Config::getProcessName() const { return m_data.processName; }
7519      std::string const&amp; Config::getReporterName() const { return m_data.reporterName; }
7520      std::vector&lt;std::string&gt; const&amp; Config::getTestsOrTags() const { return m_data.testsOrTags; }
7521      std::vector&lt;std::string&gt; const&amp; Config::getSectionsToRun() const { return m_data.sectionsToRun; }
7522      TestSpec const&amp; Config::testSpec() const { return m_testSpec; }
7523      bool Config::hasTestFilters() const { return m_hasTestFilters; }
7524      bool Config::showHelp() const { return m_data.showHelp; }
7525      bool Config::allowThrows() const                   { return !m_data.noThrow; }
7526      std::ostream&amp; Config::stream() const               { return m_stream-&gt;stream(); }
7527      std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
7528      bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
7529      bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings &amp; WarnAbout::NoAssertions); }
7530      bool Config::warnAboutNoTests() const              { return !!(m_data.warnings &amp; WarnAbout::NoTests); }
7531      ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
7532      double Config::minDuration() const                 { return m_data.minDuration; }
7533      RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
7534      unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
7535      UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
7536      bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
7537      int Config::abortAfter() const                     { return m_data.abortAfter; }
7538      bool Config::showInvisibles() const                { return m_data.showInvisibles; }
7539      Verbosity Config::verbosity() const                { return m_data.verbosity; }
7540      bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
7541      int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
7542      double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
7543      unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
7544      std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }
7545      IStream const* Config::openStream() {
7546          return Catch::makeStream(m_data.outputFilename);
7547      }
7548  } 
7549  #if defined(__clang__)
7550  #    pragma clang diagnostic push
7551  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
7552  #endif
7553  namespace Catch {
7554      class ErrnoGuard {
7555      public:
7556          ErrnoGuard();
7557          ~ErrnoGuard();
7558      private:
7559          int m_oldErrno;
7560      };
7561  }
7562  #if defined(CATCH_PLATFORM_WINDOWS)
7563  #if !defined(NOMINMAX) &amp;&amp; !defined(CATCH_CONFIG_NO_NOMINMAX)
7564  #  define CATCH_DEFINED_NOMINMAX
7565  #  define NOMINMAX
7566  #endif
7567  #if !defined(WIN32_LEAN_AND_MEAN) &amp;&amp; !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
7568  #  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7569  #  define WIN32_LEAN_AND_MEAN
7570  #endif
7571  #ifdef __AFXDLL
7572  #include &lt;AfxWin.h&gt;
7573  #else
7574  #include &lt;windows.h&gt;
7575  #endif
7576  #ifdef CATCH_DEFINED_NOMINMAX
7577  #  undef NOMINMAX
7578  #endif
7579  #ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7580  #  undef WIN32_LEAN_AND_MEAN
7581  #endif
7582  #endif 
7583  #include &lt;sstream&gt;
7584  namespace Catch {
7585      namespace {
7586          struct IColourImpl {
7587              virtual ~IColourImpl() = default;
7588              virtual void use( Colour::Code _colourCode ) = 0;
7589          };
7590          struct NoColourImpl : IColourImpl {
7591              void use( Colour::Code ) override {}
7592              static IColourImpl* instance() {
7593                  static NoColourImpl s_instance;
7594                  return &amp;s_instance;
7595              }
7596          };
7597      } 
7598  } 
7599  #if !defined( CATCH_CONFIG_COLOUR_NONE ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_WINDOWS ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_ANSI )
7600  #   ifdef CATCH_PLATFORM_WINDOWS
7601  #       define CATCH_CONFIG_COLOUR_WINDOWS
7602  #   else
7603  #       define CATCH_CONFIG_COLOUR_ANSI
7604  #   endif
7605  #endif
7606  #if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) 
7607  namespace Catch {
7608  namespace {
7609      class Win32ColourImpl : public IColourImpl {
7610      public:
7611          Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
7612          {
7613              CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
7614              GetConsoleScreenBufferInfo( stdoutHandle, &amp;csbiInfo );
7615              originalForegroundAttributes = csbiInfo.wAttributes &amp; ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
7616              originalBackgroundAttributes = csbiInfo.wAttributes &amp; ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
7617          }
7618          void use( Colour::Code _colourCode ) override {
7619              switch( _colourCode ) {
7620                  case Colour::None:      return setTextAttribute( originalForegroundAttributes );
7621                  case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7622                  case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
7623                  case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
7624                  case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
7625                  case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
7626                  case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
7627                  case Colour::Grey:      return setTextAttribute( 0 );
7628                  case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
7629                  case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
7630                  case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
7631                  case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7632                  case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
7633                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7634                  default:
7635                      CATCH_ERROR( &quot;Unknown colour requested&quot; );
7636              }
7637          }
7638      private:
7639          void setTextAttribute( WORD _textAttribute ) {
7640              SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
7641          }
7642          HANDLE stdoutHandle;
7643          WORD originalForegroundAttributes;
7644          WORD originalBackgroundAttributes;
7645      };
7646      IColourImpl* platformColourInstance() {
7647          static Win32ColourImpl s_instance;
7648          IConfigPtr config = getCurrentContext().getConfig();
7649          UseColour::YesOrNo colourMode = config
7650              ? config-&gt;useColour()
7651              : UseColour::Auto;
7652          if( colourMode == UseColour::Auto )
7653              colourMode = UseColour::Yes;
7654          return colourMode == UseColour::Yes
7655              ? &amp;s_instance
7656              : NoColourImpl::instance();
7657      }
7658  } 
7659  } 
7660  #elif defined( CATCH_CONFIG_COLOUR_ANSI ) 
7661  #include &lt;unistd.h&gt;
7662  namespace Catch {
7663  namespace {
7664      class PosixColourImpl : public IColourImpl {
7665      public:
7666          void use( Colour::Code _colourCode ) override {
7667              switch( _colourCode ) {
7668                  case Colour::None:
7669                  case Colour::White:     return setColour( &quot;[0m&quot; );
7670                  case Colour::Red:       return setColour( &quot;[0;31m&quot; );
7671                  case Colour::Green:     return setColour( &quot;[0;32m&quot; );
7672                  case Colour::Blue:      return setColour( &quot;[0;34m&quot; );
7673                  case Colour::Cyan:      return setColour( &quot;[0;36m&quot; );
7674                  case Colour::Yellow:    return setColour( &quot;[0;33m&quot; );
7675                  case Colour::Grey:      return setColour( &quot;[1;30m&quot; );
7676                  case Colour::LightGrey:     return setColour( &quot;[0;37m&quot; );
7677                  case Colour::BrightRed:     return setColour( &quot;[1;31m&quot; );
7678                  case Colour::BrightGreen:   return setColour( &quot;[1;32m&quot; );
7679                  case Colour::BrightWhite:   return setColour( &quot;[1;37m&quot; );
7680                  case Colour::BrightYellow:  return setColour( &quot;[1;33m&quot; );
7681                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7682                  default: CATCH_INTERNAL_ERROR( &quot;Unknown colour requested&quot; );
7683              }
7684          }
7685          static IColourImpl* instance() {
7686              static PosixColourImpl s_instance;
7687              return &amp;s_instance;
7688          }
7689      private:
7690          void setColour( const char* _escapeCode ) {
7691              getCurrentContext().getConfig()-&gt;stream()
7692                  &lt;&lt; &#x27;\033&#x27; &lt;&lt; _escapeCode;
7693          }
7694      };
7695      bool useColourOnPlatform() {
7696          return
7697  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7698              !isDebuggerActive() &amp;&amp;
7699  #endif
7700  #if !(defined(__DJGPP__) &amp;&amp; defined(__STRICT_ANSI__))
7701              isatty(STDOUT_FILENO)
7702  #else
7703              false
7704  #endif
7705              ;
7706      }
7707      IColourImpl* platformColourInstance() {
7708          ErrnoGuard guard;
7709          IConfigPtr config = getCurrentContext().getConfig();
7710          UseColour::YesOrNo colourMode = config
7711              ? config-&gt;useColour()
7712              : UseColour::Auto;
7713          if( colourMode == UseColour::Auto )
7714              colourMode = useColourOnPlatform()
7715                  ? UseColour::Yes
7716                  : UseColour::No;
7717          return colourMode == UseColour::Yes
7718              ? PosixColourImpl::instance()
7719              : NoColourImpl::instance();
7720      }
7721  } 
7722  } 
7723  #else  
7724  namespace Catch {
7725      static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
7726  } 
7727  #endif 
7728  namespace Catch {
7729      Colour::Colour( Code _colourCode ) { use( _colourCode ); }
7730      Colour::Colour( Colour&amp;&amp; other ) noexcept {
7731          m_moved = other.m_moved;
7732          other.m_moved = true;
7733      }
7734      Colour&amp; Colour::operator=( Colour&amp;&amp; other ) noexcept {
7735          m_moved = other.m_moved;
7736          other.m_moved  = true;
7737          return *this;
7738      }
7739      Colour::~Colour(){ if( !m_moved ) use( None ); }
7740      void Colour::use( Code _colourCode ) {
7741          static IColourImpl* impl = platformColourInstance();
7742          if (impl != nullptr) {
7743              impl-&gt;use( _colourCode );
7744          }
7745      }
7746      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Colour const&amp; ) {
7747          return os;
7748      }
7749  } 
7750  #if defined(__clang__)
7751  #    pragma clang diagnostic pop
7752  #endif
7753  namespace Catch {
7754      class Context : public IMutableContext, NonCopyable {
7755      public: 
7756          IResultCapture* getResultCapture() override {
7757              return m_resultCapture;
7758          }
7759          IRunner* getRunner() override {
7760              return m_runner;
7761          }
7762          IConfigPtr const&amp; getConfig() const override {
7763              return m_config;
7764          }
7765          ~Context() override;
7766      public: 
7767          void setResultCapture( IResultCapture* resultCapture ) override {
7768              m_resultCapture = resultCapture;
7769          }
7770          void setRunner( IRunner* runner ) override {
7771              m_runner = runner;
7772          }
7773          void setConfig( IConfigPtr const&amp; config ) override {
7774              m_config = config;
7775          }
7776          friend IMutableContext&amp; getCurrentMutableContext();
7777      private:
7778          IConfigPtr m_config;
7779          IRunner* m_runner = nullptr;
7780          IResultCapture* m_resultCapture = nullptr;
7781      };
7782      IMutableContext *IMutableContext::currentContext = nullptr;
7783      void IMutableContext::createContext()
7784      {
7785          currentContext = new Context();
7786      }
7787      void cleanUpContext() {
7788          delete IMutableContext::currentContext;
7789          IMutableContext::currentContext = nullptr;
7790      }
7791      IContext::~IContext() = default;
7792      IMutableContext::~IMutableContext() = default;
7793      Context::~Context() = default;
7794      SimplePcg32&amp; rng() {
7795          static SimplePcg32 s_rng;
7796          return s_rng;
7797      }
7798  }
7799  #include &lt;string&gt;
7800  namespace Catch {
7801      void writeToDebugConsole( std::string const&amp; text );
7802  }
7803  #if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
7804  #include &lt;android/log.h&gt;
7805      namespace Catch {
7806          void writeToDebugConsole( std::string const&amp; text ) {
7807              __android_log_write( ANDROID_LOG_DEBUG, &quot;Catch&quot;, text.c_str() );
7808          }
7809      }
7810  #elif defined(CATCH_PLATFORM_WINDOWS)
7811      namespace Catch {
7812          void writeToDebugConsole( std::string const&amp; text ) {
7813              ::OutputDebugStringA( text.c_str() );
7814          }
7815      }
7816  #else
7817      namespace Catch {
7818          void writeToDebugConsole( std::string const&amp; text ) {
7819              Catch::cout() &lt;&lt; text;
7820          }
7821      }
7822  #endif 
7823  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7824  #  include &lt;cassert&gt;
7825  #  include &lt;sys/types.h&gt;
7826  #  include &lt;unistd.h&gt;
7827  #  include &lt;cstddef&gt;
7828  #  include &lt;ostream&gt;
7829  #ifdef __apple_build_version__
7830  #  include &lt;sys/sysctl.h&gt;
7831  #endif
7832      namespace Catch {
7833          #ifdef __apple_build_version__
7834          bool isDebuggerActive(){
7835              int                 mib[4];
7836              struct kinfo_proc   info;
7837              std::size_t         size;
7838              info.kp_proc.p_flag = 0;
7839              mib[0] = CTL_KERN;
7840              mib[1] = KERN_PROC;
7841              mib[2] = KERN_PROC_PID;
7842              mib[3] = getpid();
7843              size = sizeof(info);
7844              if( sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, nullptr, 0) != 0 ) {
7845                  Catch::cerr() &lt;&lt; &quot;\n** Call to sysctl failed - unable to determine if debugger is active **\n&quot; &lt;&lt; std::endl;
7846                  return false;
7847              }
7848              return ( (info.kp_proc.p_flag &amp; P_TRACED) != 0 );
7849          }
7850          #else
7851          bool isDebuggerActive() {
7852              return false;
7853          }
7854          #endif
7855      } 
7856  #elif defined(CATCH_PLATFORM_LINUX)
7857      #include &lt;fstream&gt;
7858      #include &lt;string&gt;
7859      namespace Catch{
7860          bool isDebuggerActive(){
7861              ErrnoGuard guard;
7862              std::ifstream in(&quot;/proc/self/status&quot;);
7863              for( std::string line; std::getline(in, line); ) {
7864                  static const int PREFIX_LEN = 11;
7865                  if( line.compare(0, PREFIX_LEN, &quot;TracerPid:\t&quot;) == 0 ) {
7866                      return line.length() &gt; PREFIX_LEN &amp;&amp; line[PREFIX_LEN] != &#x27;0&#x27;;
7867                  }
7868              }
7869              return false;
7870          }
7871      } 
7872  #elif defined(_MSC_VER)
7873      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7874      namespace Catch {
7875          bool isDebuggerActive() {
7876              return IsDebuggerPresent() != 0;
7877          }
7878      }
7879  #elif defined(__MINGW32__)
7880      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7881      namespace Catch {
7882          bool isDebuggerActive() {
7883              return IsDebuggerPresent() != 0;
7884          }
7885      }
7886  #else
7887      namespace Catch {
7888         bool isDebuggerActive() { return false; }
7889      }
7890  #endif 
7891  namespace Catch {
7892      ITransientExpression::~ITransientExpression() = default;
7893      void formatReconstructedExpression( std::ostream &amp;os, std::string const&amp; lhs, StringRef op, std::string const&amp; rhs ) {
7894          if( lhs.size() + rhs.size() &lt; 40 &amp;&amp;
7895                  lhs.find(&#x27;\n&#x27;) == std::string::npos &amp;&amp;
7896                  rhs.find(&#x27;\n&#x27;) == std::string::npos )
7897              os &lt;&lt; lhs &lt;&lt; &quot; &quot; &lt;&lt; op &lt;&lt; &quot; &quot; &lt;&lt; rhs;
7898          else
7899              os &lt;&lt; lhs &lt;&lt; &quot;\n&quot; &lt;&lt; op &lt;&lt; &quot;\n&quot; &lt;&lt; rhs;
7900      }
7901  }
7902  #include &lt;stdexcept&gt;
7903  namespace Catch {
7904  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
7905      [[noreturn]]
7906      void throw_exception(std::exception const&amp; e) {
7907          Catch::cerr() &lt;&lt; &quot;Catch will terminate because it needed to throw an exception.\n&quot;
7908                        &lt;&lt; &quot;The message was: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;
7909          std::terminate();
7910      }
7911  #endif
7912      [[noreturn]]
7913      void throw_logic_error(std::string const&amp; msg) {
7914          throw_exception(std::logic_error(msg));
7915      }
7916      [[noreturn]]
7917      void throw_domain_error(std::string const&amp; msg) {
7918          throw_exception(std::domain_error(msg));
7919      }
7920      [[noreturn]]
7921      void throw_runtime_error(std::string const&amp; msg) {
7922          throw_exception(std::runtime_error(msg));
7923      }
7924  } 
7925  #include &lt;vector&gt;
7926  #include &lt;memory&gt;
7927  namespace Catch {
7928      namespace Detail {
7929          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values );
7930          class EnumValuesRegistry : public IMutableEnumValuesRegistry {
7931              std::vector&lt;std::unique_ptr&lt;EnumInfo&gt;&gt; m_enumInfos;
7932              EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::vector&lt;int&gt; const&amp; values) override;
7933          };
7934          std::vector&lt;StringRef&gt; parseEnums( StringRef enums );
7935      } 
7936  } 
7937  #include &lt;map&gt;
7938  #include &lt;cassert&gt;
7939  namespace Catch {
7940      IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}
7941      namespace Detail {
7942          namespace {
7943              StringRef extractInstanceName(StringRef enumInstance) {
7944                  size_t name_start = enumInstance.size();
7945                  while (name_start &gt; 0 &amp;&amp; enumInstance[name_start - 1] != &#x27;:&#x27;) {
7946                      --name_start;
7947                  }
7948                  return enumInstance.substr(name_start, enumInstance.size() - name_start);
7949              }
7950          }
7951          std::vector&lt;StringRef&gt; parseEnums( StringRef enums ) {
7952              auto enumValues = splitStringRef( enums, &#x27;,&#x27; );
7953              std::vector&lt;StringRef&gt; parsed;
7954              parsed.reserve( enumValues.size() );
7955              for( auto const&amp; enumValue : enumValues ) {
7956                  parsed.push_back(trim(extractInstanceName(enumValue)));
7957              }
7958              return parsed;
7959          }
7960          EnumInfo::~EnumInfo() {}
7961          StringRef EnumInfo::lookup( int value ) const {
7962              for( auto const&amp; valueToName : m_values ) {
7963                  if( valueToName.first == value )
7964                      return valueToName.second;
7965              }
7966              return &quot;{** unexpected enum value **}&quot;_sr;
7967          }
7968          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7969              std::unique_ptr&lt;EnumInfo&gt; enumInfo( new EnumInfo );
7970              enumInfo-&gt;m_name = enumName;
7971              enumInfo-&gt;m_values.reserve( values.size() );
7972              const auto valueNames = Catch::Detail::parseEnums( allValueNames );
7973              assert( valueNames.size() == values.size() );
7974              std::size_t i = 0;
7975              for( auto value : values )
7976                  enumInfo-&gt;m_values.emplace_back(value, valueNames[i++]);
7977              return enumInfo;
7978          }
7979          EnumInfo const&amp; EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7980              m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
7981              return *m_enumInfos.back();
7982          }
7983      } 
7984  } 
7985  #include &lt;cerrno&gt;
7986  namespace Catch {
7987          ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
7988          ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
7989  }
7990  #include &lt;vector&gt;
7991  #include &lt;string&gt;
7992  #include &lt;memory&gt;
7993  namespace Catch {
7994      class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
7995      public:
7996          ~ExceptionTranslatorRegistry();
7997          virtual void registerTranslator( const IExceptionTranslator* translator );
7998          std::string translateActiveException() const override;
7999          std::string tryTranslators() const;
8000      private:
8001          std::vector&lt;std::unique_ptr&lt;IExceptionTranslator const&gt;&gt; m_translators;
8002      };
8003  }
8004  #ifdef __OBJC__
8005  #import &quot;Foundation/Foundation.h&quot;
8006  #endif
8007  namespace Catch {
8008      ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
8009      }
8010      void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
8011          m_translators.push_back( std::unique_ptr&lt;const IExceptionTranslator&gt;( translator ) );
8012      }
8013  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
8014      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8015          try {
8016  #ifdef __OBJC__
8017              @try {
8018                  return tryTranslators();
8019              }
8020              @catch (NSException *exception) {
8021                  return Catch::Detail::stringify( [exception description] );
8022              }
8023  #else
8024              if (std::current_exception() == nullptr) {
8025                  return &quot;Non C++ exception. Possibly a CLR exception.&quot;;
8026              }
8027              return tryTranslators();
8028  #endif
8029          }
8030          catch( TestFailureException&amp; ) {
8031              std::rethrow_exception(std::current_exception());
8032          }
8033          catch( std::exception&amp; ex ) {
8034              return ex.what();
8035          }
8036          catch( std::string&amp; msg ) {
8037              return msg;
8038          }
8039          catch( const char* msg ) {
8040              return msg;
8041          }
8042          catch(...) {
8043              return &quot;Unknown exception&quot;;
8044          }
8045      }
8046      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8047          if (m_translators.empty()) {
8048              std::rethrow_exception(std::current_exception());
8049          } else {
8050              return m_translators[0]-&gt;translate(m_translators.begin() + 1, m_translators.end());
8051          }
8052      }
8053  #else 
8054      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8055          CATCH_INTERNAL_ERROR(&quot;Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8056      }
8057      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8058          CATCH_INTERNAL_ERROR(&quot;Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8059      }
8060  #endif
8061  }
8062  #include &lt;algorithm&gt;
8063  #if !defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; !defined( CATCH_CONFIG_POSIX_SIGNALS )
8064  namespace Catch {
8065      void FatalConditionHandler::engage_platform() {}
8066      void FatalConditionHandler::disengage_platform() {}
8067      FatalConditionHandler::FatalConditionHandler() = default;
8068      FatalConditionHandler::~FatalConditionHandler() = default;
8069  } 
8070  #endif 
8071  #if defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; defined( CATCH_CONFIG_POSIX_SIGNALS )
8072  #error &quot;Inconsistent configuration: Windows&#x27; SEH handling and POSIX signals cannot be enabled at the same time&quot;
8073  #endif 
8074  #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
8075  namespace {
8076      void reportFatal( char const * const message ) {
8077          Catch::getCurrentContext().getResultCapture()-&gt;handleFatalErrorCondition( message );
8078      }
8079      constexpr std::size_t minStackSizeForErrors = 32 * 1024;
8080  } 
8081  #endif 
8082  #if defined( CATCH_CONFIG_WINDOWS_SEH )
8083  namespace Catch {
8084      struct SignalDefs { DWORD id; const char* name; };
8085      static SignalDefs signalDefs[] = {
8086          { static_cast&lt;DWORD&gt;(EXCEPTION_ILLEGAL_INSTRUCTION),  &quot;SIGILL - Illegal instruction signal&quot; },
8087          { static_cast&lt;DWORD&gt;(EXCEPTION_STACK_OVERFLOW), &quot;SIGSEGV - Stack overflow&quot; },
8088          { static_cast&lt;DWORD&gt;(EXCEPTION_ACCESS_VIOLATION), &quot;SIGSEGV - Segmentation violation signal&quot; },
8089          { static_cast&lt;DWORD&gt;(EXCEPTION_INT_DIVIDE_BY_ZERO), &quot;Divide by zero error&quot; },
8090      };
8091      static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
8092          for (auto const&amp; def : signalDefs) {
8093              if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == def.id) {
8094                  reportFatal(def.name);
8095              }
8096          }
8097          return EXCEPTION_CONTINUE_SEARCH;
8098      }
8099      static PVOID exceptionHandlerHandle = nullptr;
8100      FatalConditionHandler::FatalConditionHandler() {
8101          ULONG guaranteeSize = static_cast&lt;ULONG&gt;(minStackSizeForErrors);
8102          if (!SetThreadStackGuarantee(&amp;guaranteeSize)) {
8103              Catch::cerr()
8104                  &lt;&lt; &quot;Failed to reserve piece of stack.&quot;
8105                  &lt;&lt; &quot; Stack overflows will not be reported successfully.&quot;;
8106          }
8107      }
8108      FatalConditionHandler::~FatalConditionHandler() = default;
8109      void FatalConditionHandler::engage_platform() {
8110          exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
8111          if (!exceptionHandlerHandle) {
8112              CATCH_RUNTIME_ERROR(&quot;Could not register vectored exception handler&quot;);
8113          }
8114      }
8115      void FatalConditionHandler::disengage_platform() {
8116          if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {
8117              CATCH_RUNTIME_ERROR(&quot;Could not unregister vectored exception handler&quot;);
8118          }
8119          exceptionHandlerHandle = nullptr;
8120      }
8121  } 
8122  #endif 
8123  #if defined( CATCH_CONFIG_POSIX_SIGNALS )
8124  #include &lt;signal.h&gt;
8125  namespace Catch {
8126      struct SignalDefs {
8127          int id;
8128          const char* name;
8129      };
8130      static SignalDefs signalDefs[] = {
8131          { SIGINT,  &quot;SIGINT - Terminal interrupt signal&quot; },
8132          { SIGILL,  &quot;SIGILL - Illegal instruction signal&quot; },
8133          { SIGFPE,  &quot;SIGFPE - Floating point error signal&quot; },
8134          { SIGSEGV, &quot;SIGSEGV - Segmentation violation signal&quot; },
8135          { SIGTERM, &quot;SIGTERM - Termination request signal&quot; },
8136          { SIGABRT, &quot;SIGABRT - Abort (abnormal termination) signal&quot; }
8137      };
8138  #if defined(__GNUC__)
8139  #    pragma GCC diagnostic push
8140  #    pragma GCC diagnostic ignored &quot;-Wmissing-field-initializers&quot;
8141  #endif
8142      static char* altStackMem = nullptr;
8143      static std::size_t altStackSize = 0;
8144      static stack_t oldSigStack{};
8145      static struct sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]{};
8146      static void restorePreviousSignalHandlers() {
8147          for (std::size_t i = 0; i &lt; sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
8148              sigaction(signalDefs[i].id, &amp;oldSigActions[i], nullptr);
8149          }
8150          sigaltstack(&amp;oldSigStack, nullptr);
8151      }
8152      static void handleSignal( int sig ) {
8153          char const * name = &quot;&lt;unknown signal&gt;&quot;;
8154          for (auto const&amp; def : signalDefs) {
8155              if (sig == def.id) {
8156                  name = def.name;
8157                  break;
8158              }
8159          }
8160          restorePreviousSignalHandlers();
8161          reportFatal( name );
8162          raise( sig );
8163      }
8164      FatalConditionHandler::FatalConditionHandler() {
8165          assert(!altStackMem &amp;&amp; &quot;Cannot initialize POSIX signal handler when one already exists&quot;);
8166          if (altStackSize == 0) {
8167              altStackSize = std::max(static_cast&lt;size_t&gt;(SIGSTKSZ), minStackSizeForErrors);
8168          }
8169          altStackMem = new char[altStackSize]();
8170      }
8171      FatalConditionHandler::~FatalConditionHandler() {
8172          delete[] altStackMem;
8173          altStackMem = nullptr;
8174      }
8175      void FatalConditionHandler::engage_platform() {
8176          stack_t sigStack;
8177          sigStack.ss_sp = altStackMem;
8178          sigStack.ss_size = altStackSize;
8179          sigStack.ss_flags = 0;
8180          sigaltstack(&amp;sigStack, &amp;oldSigStack);
8181          struct sigaction sa = { };
8182          sa.sa_handler = handleSignal;
8183          sa.sa_flags = SA_ONSTACK;
8184          for (std::size_t i = 0; i &lt; sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
8185              sigaction(signalDefs[i].id, &amp;sa, &amp;oldSigActions[i]);
8186          }
8187      }
8188  #if defined(__GNUC__)
8189  #    pragma GCC diagnostic pop
8190  #endif
8191      void FatalConditionHandler::disengage_platform() {
8192          restorePreviousSignalHandlers();
8193      }
8194  } 
8195  #endif 
8196  #include &lt;limits&gt;
8197  #include &lt;set&gt;
8198  namespace Catch {
8199  IGeneratorTracker::~IGeneratorTracker() {}
8200  const char* GeneratorException::what() const noexcept {
8201      return m_msg;
8202  }
8203  namespace Generators {
8204      GeneratorUntypedBase::~GeneratorUntypedBase() {}
8205      auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
8206          return getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );
8207      }
8208  } 
8209  } 
8210  namespace Catch {
8211      IResultCapture::~IResultCapture() = default;
8212  }
8213  namespace Catch {
8214      IConfig::~IConfig() = default;
8215  }
8216  namespace Catch {
8217      IExceptionTranslator::~IExceptionTranslator() = default;
8218      IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
8219  }
8220  namespace Catch {
8221      IRegistryHub::~IRegistryHub() = default;
8222      IMutableRegistryHub::~IMutableRegistryHub() = default;
8223  }
8224  namespace Catch {
8225      class ListeningReporter : public IStreamingReporter {
8226          using Reporters = std::vector&lt;IStreamingReporterPtr&gt;;
8227          Reporters m_listeners;
8228          IStreamingReporterPtr m_reporter = nullptr;
8229          ReporterPreferences m_preferences;
8230      public:
8231          ListeningReporter();
8232          void addListener( IStreamingReporterPtr&amp;&amp; listener );
8233          void addReporter( IStreamingReporterPtr&amp;&amp; reporter );
8234      public: 
8235          ReporterPreferences getPreferences() const override;
8236          void noMatchingTestCases( std::string const&amp; spec ) override;
8237          void reportInvalidArguments(std::string const&amp;arg) override;
8238          static std::set&lt;Verbosity&gt; getSupportedVerbosities();
8239  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
8240          void benchmarkPreparing(std::string const&amp; name) override;
8241          void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;
8242          void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;
8243          void benchmarkFailed(std::string const&amp;) override;
8244  #endif 
8245          void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;
8246          void testGroupStarting( GroupInfo const&amp; groupInfo ) override;
8247          void testCaseStarting( TestCaseInfo const&amp; testInfo ) override;
8248          void sectionStarting( SectionInfo const&amp; sectionInfo ) override;
8249          void assertionStarting( AssertionInfo const&amp; assertionInfo ) override;
8250          bool assertionEnded( AssertionStats const&amp; assertionStats ) override;
8251          void sectionEnded( SectionStats const&amp; sectionStats ) override;
8252          void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;
8253          void testGroupEnded( TestGroupStats const&amp; testGroupStats ) override;
8254          void testRunEnded( TestRunStats const&amp; testRunStats ) override;
8255          void skipTest( TestCaseInfo const&amp; testInfo ) override;
8256          bool isMulti() const override;
8257      };
8258  } 
8259  namespace Catch {
8260      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig )
8261      :   m_stream( &amp;_fullConfig-&gt;stream() ), m_fullConfig( _fullConfig ) {}
8262      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig, std::ostream&amp; _stream )
8263      :   m_stream( &amp;_stream ), m_fullConfig( _fullConfig ) {}
8264      std::ostream&amp; ReporterConfig::stream() const { return *m_stream; }
8265      IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
8266      TestRunInfo::TestRunInfo( std::string const&amp; _name ) : name( _name ) {}
8267      GroupInfo::GroupInfo(  std::string const&amp; _name,
8268                             std::size_t _groupIndex,
8269                             std::size_t _groupsCount )
8270      :   name( _name ),
8271          groupIndex( _groupIndex ),
8272          groupsCounts( _groupsCount )
8273      {}
8274       AssertionStats::AssertionStats( AssertionResult const&amp; _assertionResult,
8275                                       std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,
8276                                       Totals const&amp; _totals )
8277      :   assertionResult( _assertionResult ),
8278          infoMessages( _infoMessages ),
8279          totals( _totals )
8280      {
8281          assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
8282          if( assertionResult.hasMessage() ) {
8283              MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
8284              builder &lt;&lt; assertionResult.getMessage();
8285              builder.m_info.message = builder.m_stream.str();
8286              infoMessages.push_back( builder.m_info );
8287          }
8288      }
8289       AssertionStats::~AssertionStats() = default;
8290      SectionStats::SectionStats(  SectionInfo const&amp; _sectionInfo,
8291                                   Counts const&amp; _assertions,
8292                                   double _durationInSeconds,
8293                                   bool _missingAssertions )
8294      :   sectionInfo( _sectionInfo ),
8295          assertions( _assertions ),
8296          durationInSeconds( _durationInSeconds ),
8297          missingAssertions( _missingAssertions )
8298      {}
8299      SectionStats::~SectionStats() = default;
8300      TestCaseStats::TestCaseStats(  TestCaseInfo const&amp; _testInfo,
8301                                     Totals const&amp; _totals,
8302                                     std::string const&amp; _stdOut,
8303                                     std::string const&amp; _stdErr,
8304                                     bool _aborting )
8305      : testInfo( _testInfo ),
8306          totals( _totals ),
8307          stdOut( _stdOut ),
8308          stdErr( _stdErr ),
8309          aborting( _aborting )
8310      {}
8311      TestCaseStats::~TestCaseStats() = default;
8312      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo,
8313                                      Totals const&amp; _totals,
8314                                      bool _aborting )
8315      :   groupInfo( _groupInfo ),
8316          totals( _totals ),
8317          aborting( _aborting )
8318      {}
8319      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo )
8320      :   groupInfo( _groupInfo ),
8321          aborting( false )
8322      {}
8323      TestGroupStats::~TestGroupStats() = default;
8324      TestRunStats::TestRunStats(   TestRunInfo const&amp; _runInfo,
8325                      Totals const&amp; _totals,
8326                      bool _aborting )
8327      :   runInfo( _runInfo ),
8328          totals( _totals ),
8329          aborting( _aborting )
8330      {}
8331      TestRunStats::~TestRunStats() = default;
8332      void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
8333      bool IStreamingReporter::isMulti() const { return false; }
8334      IReporterFactory::~IReporterFactory() = default;
8335      IReporterRegistry::~IReporterRegistry() = default;
8336  } 
8337  namespace Catch {
8338      IRunner::~IRunner() = default;
8339  }
8340  namespace Catch {
8341      ITestInvoker::~ITestInvoker() = default;
8342      ITestCaseRegistry::~ITestCaseRegistry() = default;
8343  }
8344  #ifdef CATCH_CONFIG_WINDOWS_CRTDBG
8345  #include &lt;crtdbg.h&gt;
8346  namespace Catch {
8347      LeakDetector::LeakDetector() {
8348          int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
8349          flag |= _CRTDBG_LEAK_CHECK_DF;
8350          flag |= _CRTDBG_ALLOC_MEM_DF;
8351          _CrtSetDbgFlag(flag);
8352          _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
8353          _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
8354          _CrtSetBreakAlloc(-1);
8355      }
8356  }
8357  #else
8358      Catch::LeakDetector::LeakDetector() {}
8359  #endif
8360  Catch::LeakDetector::~LeakDetector() {
8361      Catch::cleanUp();
8362  }
8363  #include &lt;set&gt;
8364  namespace Catch {
8365      std::size_t listTests( Config const&amp; config );
8366      std::size_t listTestsNamesOnly( Config const&amp; config );
8367      struct TagInfo {
8368          void add( std::string const&amp; spelling );
8369          std::string all() const;
8370          std::set&lt;std::string&gt; spellings;
8371          std::size_t count = 0;
8372      };
8373      std::size_t listTags( Config const&amp; config );
8374      std::size_t listReporters();
8375      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config );
8376  } 
8377  namespace Catch {
8378      using namespace clara::TextFlow;
8379  }
8380  #include &lt;limits&gt;
8381  #include &lt;algorithm&gt;
8382  #include &lt;iomanip&gt;
8383  namespace Catch {
8384      std::size_t listTests( Config const&amp; config ) {
8385          TestSpec const&amp; testSpec = config.testSpec();
8386          if( config.hasTestFilters() )
8387              Catch::cout() &lt;&lt; &quot;Matching test cases:\n&quot;;
8388          else {
8389              Catch::cout() &lt;&lt; &quot;All available test cases:\n&quot;;
8390          }
8391          auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8392          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8393              Colour::Code colour = testCaseInfo.isHidden()
8394                  ? Colour::SecondaryText
8395                  : Colour::None;
8396              Colour colourGuard( colour );
8397              Catch::cout() &lt;&lt; Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) &lt;&lt; &quot;\n&quot;;
8398              if( config.verbosity() &gt;= Verbosity::High ) {
8399                  Catch::cout() &lt;&lt; Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) &lt;&lt; std::endl;
8400                  std::string description = testCaseInfo.description;
8401                  if( description.empty() )
8402                      description = &quot;(NO DESCRIPTION)&quot;;
8403                  Catch::cout() &lt;&lt; Column( description ).indent(4) &lt;&lt; std::endl;
8404              }
8405              if( !testCaseInfo.tags.empty() )
8406                  Catch::cout() &lt;&lt; Column( testCaseInfo.tagsAsString() ).indent( 6 ) &lt;&lt; &quot;\n&quot;;
8407          }
8408          if( !config.hasTestFilters() )
8409              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8410          else
8411              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;matching test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8412          return matchedTestCases.size();
8413      }
8414      std::size_t listTestsNamesOnly( Config const&amp; config ) {
8415          TestSpec const&amp; testSpec = config.testSpec();
8416          std::size_t matchedTests = 0;
8417          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8418          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8419              matchedTests++;
8420              if( startsWith( testCaseInfo.name, &#x27;#&#x27; ) )
8421                 Catch::cout() &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; testCaseInfo.name &lt;&lt; &#x27;&quot;&#x27;;
8422              else
8423                 Catch::cout() &lt;&lt; testCaseInfo.name;
8424              if ( config.verbosity() &gt;= Verbosity::High )
8425                  Catch::cout() &lt;&lt; &quot;\t@&quot; &lt;&lt; testCaseInfo.lineInfo;
8426              Catch::cout() &lt;&lt; std::endl;
8427          }
8428          return matchedTests;
8429      }
8430      void TagInfo::add( std::string const&amp; spelling ) {
8431          ++count;
8432          spellings.insert( spelling );
8433      }
8434      std::string TagInfo::all() const {
8435          size_t size = 0;
8436          for (auto const&amp; spelling : spellings) {
8437              size += spelling.size() + 2;
8438          }
8439          std::string out; out.reserve(size);
8440          for (auto const&amp; spelling : spellings) {
8441              out += &#x27;[&#x27;;
8442              out += spelling;
8443              out += &#x27;]&#x27;;
8444          }
8445          return out;
8446      }
8447      std::size_t listTags( Config const&amp; config ) {
8448          TestSpec const&amp; testSpec = config.testSpec();
8449          if( config.hasTestFilters() )
8450              Catch::cout() &lt;&lt; &quot;Tags for matching test cases:\n&quot;;
8451          else {
8452              Catch::cout() &lt;&lt; &quot;All available tags:\n&quot;;
8453          }
8454          std::map&lt;std::string, TagInfo&gt; tagCounts;
8455          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8456          for( auto const&amp; testCase : matchedTestCases ) {
8457              for( auto const&amp; tagName : testCase.getTestCaseInfo().tags ) {
8458                  std::string lcaseTagName = toLower( tagName );
8459                  auto countIt = tagCounts.find( lcaseTagName );
8460                  if( countIt == tagCounts.end() )
8461                      countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
8462                  countIt-&gt;second.add( tagName );
8463              }
8464          }
8465          for( auto const&amp; tagCount : tagCounts ) {
8466              ReusableStringStream rss;
8467              rss &lt;&lt; &quot;  &quot; &lt;&lt; std::setw(2) &lt;&lt; tagCount.second.count &lt;&lt; &quot;  &quot;;
8468              auto str = rss.str();
8469              auto wrapper = Column( tagCount.second.all() )
8470                                                      .initialIndent( 0 )
8471                                                      .indent( str.size() )
8472                                                      .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
8473              Catch::cout() &lt;&lt; str &lt;&lt; wrapper &lt;&lt; &#x27;\n&#x27;;
8474          }
8475          Catch::cout() &lt;&lt; pluralise( tagCounts.size(), &quot;tag&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8476          return tagCounts.size();
8477      }
8478      std::size_t listReporters() {
8479          Catch::cout() &lt;&lt; &quot;Available reporters:\n&quot;;
8480          IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
8481          std::size_t maxNameLen = 0;
8482          for( auto const&amp; factoryKvp : factories )
8483              maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
8484          for( auto const&amp; factoryKvp : factories ) {
8485              Catch::cout()
8486                      &lt;&lt; Column( factoryKvp.first + &quot;:&quot; )
8487                              .indent(2)
8488                              .width( 5+maxNameLen )
8489                      +  Column( factoryKvp.second-&gt;getDescription() )
8490                              .initialIndent(0)
8491                              .indent(2)
8492                              .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
8493                      &lt;&lt; &quot;\n&quot;;
8494          }
8495          Catch::cout() &lt;&lt; std::endl;
8496          return factories.size();
8497      }
8498      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config ) {
8499          Option&lt;std::size_t&gt; listedCount;
8500          getCurrentMutableContext().setConfig( config );
8501          if( config-&gt;listTests() )
8502              listedCount = listedCount.valueOr(0) + listTests( *config );
8503          if( config-&gt;listTestNamesOnly() )
8504              listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );
8505          if( config-&gt;listTags() )
8506              listedCount = listedCount.valueOr(0) + listTags( *config );
8507          if( config-&gt;listReporters() )
8508              listedCount = listedCount.valueOr(0) + listReporters();
8509          return listedCount;
8510      }
8511  } 
8512  namespace Catch {
8513  namespace Matchers {
8514      namespace Impl {
8515          std::string MatcherUntypedBase::toString() const {
8516              if( m_cachedToString.empty() )
8517                  m_cachedToString = describe();
8518              return m_cachedToString;
8519          }
8520          MatcherUntypedBase::~MatcherUntypedBase() = default;
8521      } 
8522  } 
8523  using namespace Matchers;
8524  using Matchers::Impl::MatcherBase;
8525  } 
8526  namespace Catch {
8527  namespace Matchers {
8528  namespace Exception {
8529  bool ExceptionMessageMatcher::match(std::exception const&amp; ex) const {
8530      return ex.what() == m_message;
8531  }
8532  std::string ExceptionMessageMatcher::describe() const {
8533      return &quot;exception message matches \&quot;&quot; + m_message + &quot;\&quot;&quot;;
8534  }
8535  }
8536  Exception::ExceptionMessageMatcher Message(std::string const&amp; message) {
8537      return Exception::ExceptionMessageMatcher(message);
8538  }
8539  } 
8540  } 
8541  namespace Catch {
8542      bool isnan(float f);
8543      bool isnan(double d);
8544  }
8545  #include &lt;string&gt;
8546  namespace Catch {
8547      template &lt;typename T&gt;
8548      std::string to_string(T const&amp; t) {
8549  #if defined(CATCH_CONFIG_CPP11_TO_STRING)
8550          return std::to_string(t);
8551  #else
8552          ReusableStringStream rss;
8553          rss &lt;&lt; t;
8554          return rss.str();
8555  #endif
8556      }
8557  } 
8558  #include &lt;algorithm&gt;
8559  #include &lt;cmath&gt;
8560  #include &lt;cstdlib&gt;
8561  #include &lt;cstdint&gt;
8562  #include &lt;cstring&gt;
8563  #include &lt;sstream&gt;
8564  #include &lt;type_traits&gt;
8565  #include &lt;iomanip&gt;
8566  #include &lt;limits&gt;
8567  namespace Catch {
8568  namespace {
8569      int32_t convert(float f) {
8570          static_assert(sizeof(float) == sizeof(int32_t), &quot;Important ULP matcher assumption violated&quot;);
8571          int32_t i;
8572          std::memcpy(&amp;i, &amp;f, sizeof(f));
8573          return i;
8574      }
8575      int64_t convert(double d) {
8576          static_assert(sizeof(double) == sizeof(int64_t), &quot;Important ULP matcher assumption violated&quot;);
8577          int64_t i;
8578          std::memcpy(&amp;i, &amp;d, sizeof(d));
8579          return i;
8580      }
8581      template &lt;typename FP&gt;
8582      bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
8583          if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
8584              return false;
8585          }
8586          auto lc = convert(lhs);
8587          auto rc = convert(rhs);
8588          if ((lc &lt; 0) != (rc &lt; 0)) {
8589              return lhs == rhs;
8590          }
8591          auto ulpDiff = std::abs(static_cast&lt;FP&gt;(lc - rc));
8592          return static_cast&lt;uint64_t&gt;(ulpDiff) &lt;= maxUlpDiff;
8593      }
8594  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8595      float nextafter(float x, float y) {
8596          return ::nextafterf(x, y);
8597      }
8598      double nextafter(double x, double y) {
8599          return ::nextafter(x, y);
8600      }
8601  #endif 
8602  template &lt;typename FP&gt;
8603  FP step(FP start, FP direction, uint64_t steps) {
8604      for (uint64_t i = 0; i &lt; steps; ++i) {
8605  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8606          start = Catch::nextafter(start, direction);
8607  #else
8608          start = std::nextafter(start, direction);
8609  #endif
8610      }
8611      return start;
8612  }
8613  bool marginComparison(double lhs, double rhs, double margin) {
8614      return (lhs + margin &gt;= rhs) &amp;&amp; (rhs + margin &gt;= lhs);
8615  }
8616  template &lt;typename FloatingPoint&gt;
8617  void write(std::ostream&amp; out, FloatingPoint num) {
8618      out &lt;&lt; std::scientific
8619          &lt;&lt; std::setprecision(std::numeric_limits&lt;FloatingPoint&gt;::max_digits10 - 1)
8620          &lt;&lt; num;
8621  }
8622  } 
8623  namespace Matchers {
8624  namespace Floating {
8625      enum class FloatingPointKind : uint8_t {
8626          Float,
8627          Double
8628      };
8629      WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
8630          :m_target{ target }, m_margin{ margin } {
8631          CATCH_ENFORCE(margin &gt;= 0, &quot;Invalid margin: &quot; &lt;&lt; margin &lt;&lt; &#x27;.&#x27;
8632              &lt;&lt; &quot; Margin has to be non-negative.&quot;);
8633      }
8634      bool WithinAbsMatcher::match(double const&amp; matchee) const {
8635          return (matchee + m_margin &gt;= m_target) &amp;&amp; (m_target + m_margin &gt;= matchee);
8636      }
8637      std::string WithinAbsMatcher::describe() const {
8638          return &quot;is within &quot; + ::Catch::Detail::stringify(m_margin) + &quot; of &quot; + ::Catch::Detail::stringify(m_target);
8639      }
8640      WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType)
8641          :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
8642          CATCH_ENFORCE(m_type == FloatingPointKind::Double
8643                     || m_ulps &lt; (std::numeric_limits&lt;uint32_t&gt;::max)(),
8644              &quot;Provided ULP is impossibly large for a float comparison.&quot;);
8645      }
8646  #if defined(__clang__)
8647  #pragma clang diagnostic push
8648  #pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;
8649  #endif
8650      bool WithinUlpsMatcher::match(double const&amp; matchee) const {
8651          switch (m_type) {
8652          case FloatingPointKind::Float:
8653              return almostEqualUlps&lt;float&gt;(static_cast&lt;float&gt;(matchee), static_cast&lt;float&gt;(m_target), m_ulps);
8654          case FloatingPointKind::Double:
8655              return almostEqualUlps&lt;double&gt;(matchee, m_target, m_ulps);
8656          default:
8657              CATCH_INTERNAL_ERROR( &quot;Unknown FloatingPointKind value&quot; );
8658          }
8659      }
8660  #if defined(__clang__)
8661  #pragma clang diagnostic pop
8662  #endif
8663      std::string WithinUlpsMatcher::describe() const {
8664          std::stringstream ret;
8665          ret &lt;&lt; &quot;is within &quot; &lt;&lt; m_ulps &lt;&lt; &quot; ULPs of &quot;;
8666          if (m_type == FloatingPointKind::Float) {
8667              write(ret, static_cast&lt;float&gt;(m_target));
8668              ret &lt;&lt; &#x27;f&#x27;;
8669          } else {
8670              write(ret, m_target);
8671          }
8672          ret &lt;&lt; &quot; ([&quot;;
8673          if (m_type == FloatingPointKind::Double) {
8674              write(ret, step(m_target, static_cast&lt;double&gt;(-INFINITY), m_ulps));
8675              ret &lt;&lt; &quot;, &quot;;
8676              write(ret, step(m_target, static_cast&lt;double&gt;( INFINITY), m_ulps));
8677          } else {
8678              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;(-INFINITY), m_ulps));
8679              ret &lt;&lt; &quot;, &quot;;
8680              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;( INFINITY), m_ulps));
8681          }
8682          ret &lt;&lt; &quot;])&quot;;
8683          return ret.str();
8684      }
8685      WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
8686          m_target(target),
8687          m_epsilon(epsilon){
8688          CATCH_ENFORCE(m_epsilon &gt;= 0., &quot;Relative comparison with epsilon &lt;  0 does not make sense.&quot;);
8689          CATCH_ENFORCE(m_epsilon  &lt; 1., &quot;Relative comparison with epsilon &gt;= 1 does not make sense.&quot;);
8690      }
8691      bool WithinRelMatcher::match(double const&amp; matchee) const {
8692          const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
8693          return marginComparison(matchee, m_target,
8694                                  std::isinf(relMargin)? 0 : relMargin);
8695      }
8696      std::string WithinRelMatcher::describe() const {
8697          Catch::ReusableStringStream sstr;
8698          sstr &lt;&lt; &quot;and &quot; &lt;&lt; m_target &lt;&lt; &quot; are within &quot; &lt;&lt; m_epsilon * 100. &lt;&lt; &quot;% of each other&quot;;
8699          return sstr.str();
8700      }
8701  }
8702  Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
8703      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
8704  }
8705  Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
8706      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
8707  }
8708  Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
8709      return Floating::WithinAbsMatcher(target, margin);
8710  }
8711  Floating::WithinRelMatcher WithinRel(double target, double eps) {
8712      return Floating::WithinRelMatcher(target, eps);
8713  }
8714  Floating::WithinRelMatcher WithinRel(double target) {
8715      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;double&gt;::epsilon() * 100);
8716  }
8717  Floating::WithinRelMatcher WithinRel(float target, float eps) {
8718      return Floating::WithinRelMatcher(target, eps);
8719  }
8720  Floating::WithinRelMatcher WithinRel(float target) {
8721      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;float&gt;::epsilon() * 100);
8722  }
8723  } 
8724  } 
8725  std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string&amp; desc) {
8726      if (desc.empty()) {
8727          return &quot;matches undescribed predicate&quot;;
8728      } else {
8729          return &quot;matches predicate: \&quot;&quot; + desc + &#x27;&quot;&#x27;;
8730      }
8731  }
8732  #include &lt;regex&gt;
8733  namespace Catch {
8734  namespace Matchers {
8735      namespace StdString {
8736          CasedString::CasedString( std::string const&amp; str, CaseSensitive::Choice caseSensitivity )
8737          :   m_caseSensitivity( caseSensitivity ),
8738              m_str( adjustString( str ) )
8739          {}
8740          std::string CasedString::adjustString( std::string const&amp; str ) const {
8741              return m_caseSensitivity == CaseSensitive::No
8742                     ? toLower( str )
8743                     : str;
8744          }
8745          std::string CasedString::caseSensitivitySuffix() const {
8746              return m_caseSensitivity == CaseSensitive::No
8747                     ? &quot; (case insensitive)&quot;
8748                     : std::string();
8749          }
8750          StringMatcherBase::StringMatcherBase( std::string const&amp; operation, CasedString const&amp; comparator )
8751          : m_comparator( comparator ),
8752            m_operation( operation ) {
8753          }
8754          std::string StringMatcherBase::describe() const {
8755              std::string description;
8756              description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
8757                                          m_comparator.caseSensitivitySuffix().size());
8758              description += m_operation;
8759              description += &quot;: \&quot;&quot;;
8760              description += m_comparator.m_str;
8761              description += &quot;\&quot;&quot;;
8762              description += m_comparator.caseSensitivitySuffix();
8763              return description;
8764          }
8765          EqualsMatcher::EqualsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;equals&quot;, comparator ) {}
8766          bool EqualsMatcher::match( std::string const&amp; source ) const {
8767              return m_comparator.adjustString( source ) == m_comparator.m_str;
8768          }
8769          ContainsMatcher::ContainsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;contains&quot;, comparator ) {}
8770          bool ContainsMatcher::match( std::string const&amp; source ) const {
8771              return contains( m_comparator.adjustString( source ), m_comparator.m_str );
8772          }
8773          StartsWithMatcher::StartsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;starts with&quot;, comparator ) {}
8774          bool StartsWithMatcher::match( std::string const&amp; source ) const {
8775              return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8776          }
8777          EndsWithMatcher::EndsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;ends with&quot;, comparator ) {}
8778          bool EndsWithMatcher::match( std::string const&amp; source ) const {
8779              return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8780          }
8781          RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
8782          bool RegexMatcher::match(std::string const&amp; matchee) const {
8783              auto flags = std::regex::ECMAScript; 
8784              if (m_caseSensitivity == CaseSensitive::Choice::No) {
8785                  flags |= std::regex::icase;
8786              }
8787              auto reg = std::regex(m_regex, flags);
8788              return std::regex_match(matchee, reg);
8789          }
8790          std::string RegexMatcher::describe() const {
8791              return &quot;matches &quot; + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? &quot; case sensitively&quot; : &quot; case insensitively&quot;);
8792          }
8793      } 
8794      StdString::EqualsMatcher Equals( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8795          return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
8796      }
8797      StdString::ContainsMatcher Contains( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8798          return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
8799      }
8800      StdString::EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8801          return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8802      }
8803      StdString::StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8804          return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8805      }
8806      StdString::RegexMatcher Matches(std::string const&amp; regex, CaseSensitive::Choice caseSensitivity) {
8807          return StdString::RegexMatcher(regex, caseSensitivity);
8808      }
8809  } 
8810  } 
8811  namespace Catch {
8812      bool uncaught_exceptions();
8813  } 
8814  #include &lt;cassert&gt;
8815  #include &lt;stack&gt;
8816  namespace Catch {
8817      MessageInfo::MessageInfo(   StringRef const&amp; _macroName,
8818                                  SourceLineInfo const&amp; _lineInfo,
8819                                  ResultWas::OfType _type )
8820      :   macroName( _macroName ),
8821          lineInfo( _lineInfo ),
8822          type( _type ),
8823          sequence( ++globalCount )
8824      {}
8825      bool MessageInfo::operator==( MessageInfo const&amp; other ) const {
8826          return sequence == other.sequence;
8827      }
8828      bool MessageInfo::operator&lt;( MessageInfo const&amp; other ) const {
8829          return sequence &lt; other.sequence;
8830      }
8831      unsigned int MessageInfo::globalCount = 0;
8832      Catch::MessageBuilder::MessageBuilder( StringRef const&amp; macroName,
8833                                             SourceLineInfo const&amp; lineInfo,
8834                                             ResultWas::OfType type )
8835          :m_info(macroName, lineInfo, type) {}
8836      ScopedMessage::ScopedMessage( MessageBuilder const&amp; builder )
8837      : m_info( builder.m_info ), m_moved()
8838      {
8839          m_info.message = builder.m_stream.str();
8840          getResultCapture().pushScopedMessage( m_info );
8841      }
8842      ScopedMessage::ScopedMessage( ScopedMessage&amp;&amp; old )
8843      : m_info( old.m_info ), m_moved()
8844      {
8845          old.m_moved = true;
8846      }
8847      ScopedMessage::~ScopedMessage() {
8848          if ( !uncaught_exceptions() &amp;&amp; !m_moved ){
8849              getResultCapture().popScopedMessage(m_info);
8850          }
8851      }
8852      Capturer::Capturer( StringRef macroName, SourceLineInfo const&amp; lineInfo, ResultWas::OfType resultType, StringRef names ) {
8853          auto trimmed = [&amp;] (size_t start, size_t end) {
8854              while (names[start] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[start]))) {
8855                  ++start;
8856              }
8857              while (names[end] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[end]))) {
8858                  --end;
8859              }
8860              return names.substr(start, end - start + 1);
8861          };
8862          auto skipq = [&amp;] (size_t start, char quote) {
8863              for (auto i = start + 1; i &lt; names.size() ; ++i) {
8864                  if (names[i] == quote)
8865                      return i;
8866                  if (names[i] == &#x27;\\&#x27;)
8867                      ++i;
8868              }
8869              CATCH_INTERNAL_ERROR(&quot;CAPTURE parsing encountered unmatched quote&quot;);
8870          };
8871          size_t start = 0;
8872          std::stack&lt;char&gt; openings;
8873          for (size_t pos = 0; pos &lt; names.size(); ++pos) {
8874              char c = names[pos];
8875              switch (c) {
8876              case &#x27;[&#x27;:
8877              case &#x27;{&#x27;:
8878              case &#x27;(&#x27;:
8879                  openings.push(c);
8880                  break;
8881              case &#x27;]&#x27;:
8882              case &#x27;}&#x27;:
8883              case &#x27;)&#x27;:
8884                  openings.pop();
8885                  break;
8886              case &#x27;&quot;&#x27;:
8887              case &#x27;\&#x27;&#x27;:
8888                  pos = skipq(pos, c);
8889                  break;
8890              case &#x27;,&#x27;:
8891                  if (start != pos &amp;&amp; openings.empty()) {
8892                      m_messages.emplace_back(macroName, lineInfo, resultType);
8893                      m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, pos));
8894                      m_messages.back().message += &quot; := &quot;;
8895                      start = pos;
8896                  }
8897              }
8898          }
8899          assert(openings.empty() &amp;&amp; &quot;Mismatched openings&quot;);
8900          m_messages.emplace_back(macroName, lineInfo, resultType);
8901          m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, names.size() - 1));
8902          m_messages.back().message += &quot; := &quot;;
8903      }
8904      Capturer::~Capturer() {
8905          if ( !uncaught_exceptions() ){
8906              assert( m_captured == m_messages.size() );
8907              for( size_t i = 0; i &lt; m_captured; ++i  )
8908                  m_resultCapture.popScopedMessage( m_messages[i] );
8909          }
8910      }
8911      void Capturer::captureValue( size_t index, std::string const&amp; value ) {
8912          assert( index &lt; m_messages.size() );
8913          m_messages[index].message += value;
8914          m_resultCapture.pushScopedMessage( m_messages[index] );
8915          m_captured++;
8916      }
8917  } 
8918  #ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8919  #define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8920  #include &lt;cstdio&gt;
8921  #include &lt;iosfwd&gt;
8922  #include &lt;string&gt;
8923  namespace Catch {
8924      class RedirectedStream {
8925          std::ostream&amp; m_originalStream;
8926          std::ostream&amp; m_redirectionStream;
8927          std::streambuf* m_prevBuf;
8928      public:
8929          RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream );
8930          ~RedirectedStream();
8931      };
8932      class RedirectedStdOut {
8933          ReusableStringStream m_rss;
8934          RedirectedStream m_cout;
8935      public:
8936          RedirectedStdOut();
8937          auto str() const -&gt; std::string;
8938      };
8939      class RedirectedStdErr {
8940          ReusableStringStream m_rss;
8941          RedirectedStream m_cerr;
8942          RedirectedStream m_clog;
8943      public:
8944          RedirectedStdErr();
8945          auto str() const -&gt; std::string;
8946      };
8947      class RedirectedStreams {
8948      public:
8949          RedirectedStreams(RedirectedStreams const&amp;) = delete;
8950          RedirectedStreams&amp; operator=(RedirectedStreams const&amp;) = delete;
8951          RedirectedStreams(RedirectedStreams&amp;&amp;) = delete;
8952          RedirectedStreams&amp; operator=(RedirectedStreams&amp;&amp;) = delete;
8953          RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr);
8954          ~RedirectedStreams();
8955      private:
8956          std::string&amp; m_redirectedCout;
8957          std::string&amp; m_redirectedCerr;
8958          RedirectedStdOut m_redirectedStdOut;
8959          RedirectedStdErr m_redirectedStdErr;
8960      };
8961  #if defined(CATCH_CONFIG_NEW_CAPTURE)
8962      class TempFile {
8963      public:
8964          TempFile(TempFile const&amp;) = delete;
8965          TempFile&amp; operator=(TempFile const&amp;) = delete;
8966          TempFile(TempFile&amp;&amp;) = delete;
8967          TempFile&amp; operator=(TempFile&amp;&amp;) = delete;
8968          TempFile();
8969          ~TempFile();
8970          std::FILE* getFile();
8971          std::string getContents();
8972      private:
8973          std::FILE* m_file = nullptr;
8974      #if defined(_MSC_VER)
8975          char m_buffer[L_tmpnam] = { 0 };
8976      #endif
8977      };
8978      class OutputRedirect {
8979      public:
8980          OutputRedirect(OutputRedirect const&amp;) = delete;
8981          OutputRedirect&amp; operator=(OutputRedirect const&amp;) = delete;
8982          OutputRedirect(OutputRedirect&amp;&amp;) = delete;
8983          OutputRedirect&amp; operator=(OutputRedirect&amp;&amp;) = delete;
8984          OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest);
8985          ~OutputRedirect();
8986      private:
8987          int m_originalStdout = -1;
8988          int m_originalStderr = -1;
8989          TempFile m_stdoutFile;
8990          TempFile m_stderrFile;
8991          std::string&amp; m_stdoutDest;
8992          std::string&amp; m_stderrDest;
8993      };
8994  #endif
8995  } 
8996  #endif 
8997  #include &lt;cstdio&gt;
8998  #include &lt;cstring&gt;
8999  #include &lt;fstream&gt;
9000  #include &lt;sstream&gt;
9001  #include &lt;stdexcept&gt;
9002  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9003      #if defined(_MSC_VER)
9004      #include &lt;io.h&gt;      
9005      #define dup _dup
9006      #define dup2 _dup2
9007      #define fileno _fileno
9008      #else
9009      #include &lt;unistd.h&gt;  
9010      #endif
9011  #endif
9012  namespace Catch {
9013      RedirectedStream::RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream )
9014      :   m_originalStream( originalStream ),
9015          m_redirectionStream( redirectionStream ),
9016          m_prevBuf( m_originalStream.rdbuf() )
9017      {
9018          m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
9019      }
9020      RedirectedStream::~RedirectedStream() {
9021          m_originalStream.rdbuf( m_prevBuf );
9022      }
9023      RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
9024      auto RedirectedStdOut::str() const -&gt; std::string { return m_rss.str(); }
9025      RedirectedStdErr::RedirectedStdErr()
9026      :   m_cerr( Catch::cerr(), m_rss.get() ),
9027          m_clog( Catch::clog(), m_rss.get() )
9028      {}
9029      auto RedirectedStdErr::str() const -&gt; std::string { return m_rss.str(); }
9030      RedirectedStreams::RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr)
9031      :   m_redirectedCout(redirectedCout),
9032          m_redirectedCerr(redirectedCerr)
9033      {}
9034      RedirectedStreams::~RedirectedStreams() {
9035          m_redirectedCout += m_redirectedStdOut.str();
9036          m_redirectedCerr += m_redirectedStdErr.str();
9037      }
9038  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9039  #if defined(_MSC_VER)
9040      TempFile::TempFile() {
9041          if (tmpnam_s(m_buffer)) {
9042              CATCH_RUNTIME_ERROR(&quot;Could not get a temp filename&quot;);
9043          }
9044          if (fopen_s(&amp;m_file, m_buffer, &quot;w+&quot;)) {
9045              char buffer[100];
9046              if (strerror_s(buffer, errno)) {
9047                  CATCH_RUNTIME_ERROR(&quot;Could not translate errno to a string&quot;);
9048              }
9049              CATCH_RUNTIME_ERROR(&quot;Could not open the temp file: &#x27;&quot; &lt;&lt; m_buffer &lt;&lt; &quot;&#x27; because: &quot; &lt;&lt; buffer);
9050          }
9051      }
9052  #else
9053      TempFile::TempFile() {
9054          m_file = std::tmpfile();
9055          if (!m_file) {
9056              CATCH_RUNTIME_ERROR(&quot;Could not create a temp file.&quot;);
9057          }
9058      }
9059  #endif
9060      TempFile::~TempFile() {
9061           std::fclose(m_file);
9062  #if defined(_MSC_VER)
9063           std::remove(m_buffer);
9064  #endif
9065      }
9066      FILE* TempFile::getFile() {
9067          return m_file;
9068      }
9069      std::string TempFile::getContents() {
9070          std::stringstream sstr;
9071          char buffer[100] = {};
9072          std::rewind(m_file);
9073          while (std::fgets(buffer, sizeof(buffer), m_file)) {
9074              sstr &lt;&lt; buffer;
9075          }
9076          return sstr.str();
9077      }
9078      OutputRedirect::OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest) :
9079          m_originalStdout(dup(1)),
9080          m_originalStderr(dup(2)),
9081          m_stdoutDest(stdout_dest),
9082          m_stderrDest(stderr_dest) {
9083          dup2(fileno(m_stdoutFile.getFile()), 1);
9084          dup2(fileno(m_stderrFile.getFile()), 2);
9085      }
9086      OutputRedirect::~OutputRedirect() {
9087          Catch::cout() &lt;&lt; std::flush;
9088          fflush(stdout);
9089          Catch::cerr() &lt;&lt; std::flush;
9090          Catch::clog() &lt;&lt; std::flush;
9091          fflush(stderr);
9092          dup2(m_originalStdout, 1);
9093          dup2(m_originalStderr, 2);
9094          m_stdoutDest += m_stdoutFile.getContents();
9095          m_stderrDest += m_stderrFile.getContents();
9096      }
9097  #endif 
9098  } 
9099  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9100      #if defined(_MSC_VER)
9101      #undef dup
9102      #undef dup2
9103      #undef fileno
9104      #endif
9105  #endif
9106  #include &lt;cmath&gt;
9107  namespace Catch {
9108  #if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
9109      bool isnan(float f) {
9110          return std::isnan(f);
9111      }
9112      bool isnan(double d) {
9113          return std::isnan(d);
9114      }
9115  #else
9116      bool isnan(float f) {
9117          return std::_isnan(f);
9118      }
9119      bool isnan(double d) {
9120          return std::_isnan(d);
9121      }
9122  #endif
9123  } 
9124  namespace Catch {
9125  namespace {
9126  #if defined(_MSC_VER)
9127  #pragma warning(push)
9128  #pragma warning(disable:4146) 
9129  #endif
9130          uint32_t rotate_right(uint32_t val, uint32_t count) {
9131              const uint32_t mask = 31;
9132              count &amp;= mask;
9133              return (val &gt;&gt; count) | (val &lt;&lt; (-count &amp; mask));
9134          }
9135  #if defined(_MSC_VER)
9136  #pragma warning(pop)
9137  #endif
9138  }
9139      SimplePcg32::SimplePcg32(result_type seed_) {
9140          seed(seed_);
9141      }
9142      void SimplePcg32::seed(result_type seed_) {
9143          m_state = 0;
9144          (*this)();
9145          m_state += seed_;
9146          (*this)();
9147      }
9148      void SimplePcg32::discard(uint64_t skip) {
9149          for (uint64_t s = 0; s &lt; skip; ++s) {
9150              static_cast&lt;void&gt;((*this)());
9151          }
9152      }
9153      SimplePcg32::result_type SimplePcg32::operator()() {
9154          const uint32_t xorshifted = static_cast&lt;uint32_t&gt;(((m_state &gt;&gt; 18u) ^ m_state) &gt;&gt; 27u);
9155          const auto output = rotate_right(xorshifted, m_state &gt;&gt; 59u);
9156          m_state = m_state * 6364136223846793005ULL + s_inc;
9157          return output;
9158      }
9159      bool operator==(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9160          return lhs.m_state == rhs.m_state;
9161      }
9162      bool operator!=(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9163          return lhs.m_state != rhs.m_state;
9164      }
9165  }
9166  #include &lt;vector&gt;
9167  #include &lt;set&gt;
9168  #include &lt;algorithm&gt;
9169  #include &lt;ios&gt;
9170  namespace Catch {
9171      class TestCase;
9172      struct IConfig;
9173      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases );
9174      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config );
9175      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config );
9176      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions );
9177      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );
9178      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );
9179      class TestRegistry : public ITestCaseRegistry {
9180      public:
9181          virtual ~TestRegistry() = default;
9182          virtual void registerTest( TestCase const&amp; testCase );
9183          std::vector&lt;TestCase&gt; const&amp; getAllTests() const override;
9184          std::vector&lt;TestCase&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const override;
9185      private:
9186          std::vector&lt;TestCase&gt; m_functions;
9187          mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
9188          mutable std::vector&lt;TestCase&gt; m_sortedFunctions;
9189          std::size_t m_unnamedCount = 0;
9190          std::ios_base::Init m_ostreamInit; 
9191      };
9192      class TestInvokerAsFunction : public ITestInvoker {
9193          void(*m_testAsFunction)();
9194      public:
9195          TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
9196          void invoke() const override;
9197      };
9198      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName );
9199  } 
9200  #include &lt;map&gt;
9201  namespace Catch {
9202      class ReporterRegistry : public IReporterRegistry {
9203      public:
9204          ~ReporterRegistry() override;
9205          IStreamingReporterPtr create( std::string const&amp; name, IConfigPtr const&amp; config ) const override;
9206          void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory );
9207          void registerListener( IReporterFactoryPtr const&amp; factory );
9208          FactoryMap const&amp; getFactories() const override;
9209          Listeners const&amp; getListeners() const override;
9210      private:
9211          FactoryMap m_factories;
9212          Listeners m_listeners;
9213      };
9214  }
9215  #include &lt;string&gt;
9216  namespace Catch {
9217      struct TagAlias {
9218          TagAlias(std::string const&amp; _tag, SourceLineInfo _lineInfo);
9219          std::string tag;
9220          SourceLineInfo lineInfo;
9221      };
9222  } 
9223  #include &lt;map&gt;
9224  namespace Catch {
9225      class TagAliasRegistry : public ITagAliasRegistry {
9226      public:
9227          ~TagAliasRegistry() override;
9228          TagAlias const* find( std::string const&amp; alias ) const override;
9229          std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const override;
9230          void add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo );
9231      private:
9232          std::map&lt;std::string, TagAlias&gt; m_registry;
9233      };
9234  } 
9235  #include &lt;vector&gt;
9236  #include &lt;exception&gt;
9237  namespace Catch {
9238      class StartupExceptionRegistry {
9239  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9240      public:
9241          void add(std::exception_ptr const&amp; exception) noexcept;
9242          std::vector&lt;std::exception_ptr&gt; const&amp; getExceptions() const noexcept;
9243      private:
9244          std::vector&lt;std::exception_ptr&gt; m_exceptions;
9245  #endif
9246      };
9247  } 
9248  namespace Catch {
9249      struct ISingleton {
9250          virtual ~ISingleton();
9251      };
9252      void addSingleton( ISingleton* singleton );
9253      void cleanupSingletons();
9254      template&lt;typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT&gt;
9255      class Singleton : SingletonImplT, public ISingleton {
9256          static auto getInternal() -&gt; Singleton* {
9257              static Singleton* s_instance = nullptr;
9258              if( !s_instance ) {
9259                  s_instance = new Singleton;
9260                  addSingleton( s_instance );
9261              }
9262              return s_instance;
9263          }
9264      public:
9265          static auto get() -&gt; InterfaceT const&amp; {
9266              return *getInternal();
9267          }
9268          static auto getMutable() -&gt; MutableInterfaceT&amp; {
9269              return *getInternal();
9270          }
9271      };
9272  } 
9273  namespace Catch {
9274      namespace {
9275          class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
9276                              private NonCopyable {
9277          public: 
9278              RegistryHub() = default;
9279              IReporterRegistry const&amp; getReporterRegistry() const override {
9280                  return m_reporterRegistry;
9281              }
9282              ITestCaseRegistry const&amp; getTestCaseRegistry() const override {
9283                  return m_testCaseRegistry;
9284              }
9285              IExceptionTranslatorRegistry const&amp; getExceptionTranslatorRegistry() const override {
9286                  return m_exceptionTranslatorRegistry;
9287              }
9288              ITagAliasRegistry const&amp; getTagAliasRegistry() const override {
9289                  return m_tagAliasRegistry;
9290              }
9291              StartupExceptionRegistry const&amp; getStartupExceptionRegistry() const override {
9292                  return m_exceptionRegistry;
9293              }
9294          public: 
9295              void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) override {
9296                  m_reporterRegistry.registerReporter( name, factory );
9297              }
9298              void registerListener( IReporterFactoryPtr const&amp; factory ) override {
9299                  m_reporterRegistry.registerListener( factory );
9300              }
9301              void registerTest( TestCase const&amp; testInfo ) override {
9302                  m_testCaseRegistry.registerTest( testInfo );
9303              }
9304              void registerTranslator( const IExceptionTranslator* translator ) override {
9305                  m_exceptionTranslatorRegistry.registerTranslator( translator );
9306              }
9307              void registerTagAlias( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) override {
9308                  m_tagAliasRegistry.add( alias, tag, lineInfo );
9309              }
9310              void registerStartupException() noexcept override {
9311  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9312                  m_exceptionRegistry.add(std::current_exception());
9313  #else
9314                  CATCH_INTERNAL_ERROR(&quot;Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
9315  #endif
9316              }
9317              IMutableEnumValuesRegistry&amp; getMutableEnumValuesRegistry() override {
9318                  return m_enumValuesRegistry;
9319              }
9320          private:
9321              TestRegistry m_testCaseRegistry;
9322              ReporterRegistry m_reporterRegistry;
9323              ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
9324              TagAliasRegistry m_tagAliasRegistry;
9325              StartupExceptionRegistry m_exceptionRegistry;
9326              Detail::EnumValuesRegistry m_enumValuesRegistry;
9327          };
9328      }
9329      using RegistryHubSingleton = Singleton&lt;RegistryHub, IRegistryHub, IMutableRegistryHub&gt;;
9330      IRegistryHub const&amp; getRegistryHub() {
9331          return RegistryHubSingleton::get();
9332      }
9333      IMutableRegistryHub&amp; getMutableRegistryHub() {
9334          return RegistryHubSingleton::getMutable();
9335      }
9336      void cleanUp() {
9337          cleanupSingletons();
9338          cleanUpContext();
9339      }
9340      std::string translateActiveException() {
9341          return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
9342      }
9343  } 
9344  namespace Catch {
9345      ReporterRegistry::~ReporterRegistry() = default;
9346      IStreamingReporterPtr ReporterRegistry::create( std::string const&amp; name, IConfigPtr const&amp; config ) const {
9347          auto it =  m_factories.find( name );
9348          if( it == m_factories.end() )
9349              return nullptr;
9350          return it-&gt;second-&gt;create( ReporterConfig( config ) );
9351      }
9352      void ReporterRegistry::registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) {
9353          m_factories.emplace(name, factory);
9354      }
9355      void ReporterRegistry::registerListener( IReporterFactoryPtr const&amp; factory ) {
9356          m_listeners.push_back( factory );
9357      }
9358      IReporterRegistry::FactoryMap const&amp; ReporterRegistry::getFactories() const {
9359          return m_factories;
9360      }
9361      IReporterRegistry::Listeners const&amp; ReporterRegistry::getListeners() const {
9362          return m_listeners;
9363      }
9364  }
9365  namespace Catch {
9366      bool isOk( ResultWas::OfType resultType ) {
9367          return ( resultType &amp; ResultWas::FailureBit ) == 0;
9368      }
9369      bool isJustInfo( int flags ) {
9370          return flags == ResultWas::Info;
9371      }
9372      ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
9373          return static_cast&lt;ResultDisposition::Flags&gt;( static_cast&lt;int&gt;( lhs ) | static_cast&lt;int&gt;( rhs ) );
9374      }
9375      bool shouldContinueOnFailure( int flags )    { return ( flags &amp; ResultDisposition::ContinueOnFailure ) != 0; }
9376      bool shouldSuppressFailure( int flags )      { return ( flags &amp; ResultDisposition::SuppressFail ) != 0; }
9377  } 
9378  #include &lt;cassert&gt;
9379  #include &lt;algorithm&gt;
9380  #include &lt;sstream&gt;
9381  namespace Catch {
9382      namespace Generators {
9383          struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
9384              GeneratorBasePtr m_generator;
9385              GeneratorTracker( TestCaseTracking::NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
9386              :   TrackerBase( nameAndLocation, ctx, parent )
9387              {}
9388              ~GeneratorTracker();
9389              static GeneratorTracker&amp; acquire( TrackerContext&amp; ctx, TestCaseTracking::NameAndLocation const&amp; nameAndLocation ) {
9390                  std::shared_ptr&lt;GeneratorTracker&gt; tracker;
9391                  ITracker&amp; currentTracker = ctx.currentTracker();
9392                  if (currentTracker.nameAndLocation() == nameAndLocation) {
9393                      auto thisTracker = currentTracker.parent().findChild(nameAndLocation);
9394                      assert(thisTracker);
9395                      assert(thisTracker-&gt;isGeneratorTracker());
9396                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;(thisTracker);
9397                  } else if ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
9398                      assert( childTracker );
9399                      assert( childTracker-&gt;isGeneratorTracker() );
9400                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;( childTracker );
9401                  } else {
9402                      tracker = std::make_shared&lt;GeneratorTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
9403                      currentTracker.addChild( tracker );
9404                  }
9405                  if( !tracker-&gt;isComplete() ) {
9406                      tracker-&gt;open();
9407                  }
9408                  return *tracker;
9409              }
9410              bool isGeneratorTracker() const override { return true; }
9411              auto hasGenerator() const -&gt; bool override {
9412                  return !!m_generator;
9413              }
9414              void close() override {
9415                  TrackerBase::close();
9416                  const bool should_wait_for_child = [&amp;]() {
9417                      if ( m_children.empty() ) {
9418                          return false;
9419                      }
9420                      if ( std::find_if(
9421                               m_children.begin(),
9422                               m_children.end(),
9423                               []( TestCaseTracking::ITrackerPtr tracker ) {
9424                                   return tracker-&gt;hasStarted();
9425                               } ) != m_children.end() ) {
9426                          return false;
9427                      }
9428                      auto* parent = m_parent;
9429                      while ( !parent-&gt;isSectionTracker() ) {
9430                          parent = &amp;( parent-&gt;parent() );
9431                      }
9432                      assert( parent &amp;&amp;
9433                              &quot;Missing root (test case) level section&quot; );
9434                      auto const&amp; parentSection =
9435                          static_cast&lt;SectionTracker&amp;&gt;( *parent );
9436                      auto const&amp; filters = parentSection.getFilters();
9437                      if ( filters.empty() ) {
9438                          return true;
9439                      }
9440                      for ( auto const&amp; child : m_children ) {
9441                          if ( child-&gt;isSectionTracker() &amp;&amp;
9442                               std::find( filters.begin(),
9443                                          filters.end(),
9444                                          static_cast&lt;SectionTracker&amp;&gt;( *child )
9445                                              .trimmedName() ) !=
9446                                   filters.end() ) {
9447                              return true;
9448                          }
9449                      }
9450                      return false;
9451                  }();
9452                  if ( should_wait_for_child ||
9453                       ( m_runState == CompletedSuccessfully &amp;&amp;
9454                         m_generator-&gt;next() ) ) {
9455                      m_children.clear();
9456                      m_runState = Executing;
9457                  }
9458              }
9459              auto getGenerator() const -&gt; GeneratorBasePtr const&amp; override {
9460                  return m_generator;
9461              }
9462              void setGenerator( GeneratorBasePtr&amp;&amp; generator ) override {
9463                  m_generator = std::move( generator );
9464              }
9465          };
9466          GeneratorTracker::~GeneratorTracker() {}
9467      }
9468      RunContext::RunContext(IConfigPtr const&amp; _config, IStreamingReporterPtr&amp;&amp; reporter)
9469      :   m_runInfo(_config-&gt;name()),
9470          m_context(getCurrentMutableContext()),
9471          m_config(_config),
9472          m_reporter(std::move(reporter)),
9473          m_lastAssertionInfo{ StringRef(), SourceLineInfo(&quot;&quot;,0), StringRef(), ResultDisposition::Normal },
9474          m_includeSuccessfulResults( m_config-&gt;includeSuccessfulResults() || m_reporter-&gt;getPreferences().shouldReportAllAssertions )
9475      {
9476          m_context.setRunner(this);
9477          m_context.setConfig(m_config);
9478          m_context.setResultCapture(this);
9479          m_reporter-&gt;testRunStarting(m_runInfo);
9480      }
9481      RunContext::~RunContext() {
9482          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
9483      }
9484      void RunContext::testGroupStarting(std::string const&amp; testSpec, std::size_t groupIndex, std::size_t groupsCount) {
9485          m_reporter-&gt;testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
9486      }
9487      void RunContext::testGroupEnded(std::string const&amp; testSpec, Totals const&amp; totals, std::size_t groupIndex, std::size_t groupsCount) {
9488          m_reporter-&gt;testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
9489      }
9490      Totals RunContext::runTest(TestCase const&amp; testCase) {
9491          Totals prevTotals = m_totals;
9492          std::string redirectedCout;
9493          std::string redirectedCerr;
9494          auto const&amp; testInfo = testCase.getTestCaseInfo();
9495          m_reporter-&gt;testCaseStarting(testInfo);
9496          m_activeTestCase = &amp;testCase;
9497          ITracker&amp; rootTracker = m_trackerContext.startRun();
9498          assert(rootTracker.isSectionTracker());
9499          static_cast&lt;SectionTracker&amp;&gt;(rootTracker).addInitialFilters(m_config-&gt;getSectionsToRun());
9500          do {
9501              m_trackerContext.startCycle();
9502              m_testCaseTracker = &amp;SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
9503              runCurrentTest(redirectedCout, redirectedCerr);
9504          } while (!m_testCaseTracker-&gt;isSuccessfullyCompleted() &amp;&amp; !aborting());
9505          Totals deltaTotals = m_totals.delta(prevTotals);
9506          if (testInfo.expectedToFail() &amp;&amp; deltaTotals.testCases.passed &gt; 0) {
9507              deltaTotals.assertions.failed++;
9508              deltaTotals.testCases.passed--;
9509              deltaTotals.testCases.failed++;
9510          }
9511          m_totals.testCases += deltaTotals.testCases;
9512          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9513                                    deltaTotals,
9514                                    redirectedCout,
9515                                    redirectedCerr,
9516                                    aborting()));
9517          m_activeTestCase = nullptr;
9518          m_testCaseTracker = nullptr;
9519          return deltaTotals;
9520      }
9521      IConfigPtr RunContext::config() const {
9522          return m_config;
9523      }
9524      IStreamingReporter&amp; RunContext::reporter() const {
9525          return *m_reporter;
9526      }
9527      void RunContext::assertionEnded(AssertionResult const &amp; result) {
9528          if (result.getResultType() == ResultWas::Ok) {
9529              m_totals.assertions.passed++;
9530              m_lastAssertionPassed = true;
9531          } else if (!result.isOk()) {
9532              m_lastAssertionPassed = false;
9533              if( m_activeTestCase-&gt;getTestCaseInfo().okToFail() )
9534                  m_totals.assertions.failedButOk++;
9535              else
9536                  m_totals.assertions.failed++;
9537          }
9538          else {
9539              m_lastAssertionPassed = true;
9540          }
9541          static_cast&lt;void&gt;(m_reporter-&gt;assertionEnded(AssertionStats(result, m_messages, m_totals)));
9542          if (result.getResultType() != ResultWas::Warning)
9543              m_messageScopes.clear();
9544          resetAssertionInfo();
9545          m_lastResult = result;
9546      }
9547      void RunContext::resetAssertionInfo() {
9548          m_lastAssertionInfo.macroName = StringRef();
9549          m_lastAssertionInfo.capturedExpression = &quot;{Unknown expression after the reported line}&quot;_sr;
9550      }
9551      bool RunContext::sectionStarted(SectionInfo const &amp; sectionInfo, Counts &amp; assertions) {
9552          ITracker&amp; sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
9553          if (!sectionTracker.isOpen())
9554              return false;
9555          m_activeSections.push_back(&amp;sectionTracker);
9556          m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
9557          m_reporter-&gt;sectionStarting(sectionInfo);
9558          assertions = m_totals.assertions;
9559          return true;
9560      }
9561      auto RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
9562          using namespace Generators;
9563          GeneratorTracker&amp; tracker = GeneratorTracker::acquire(m_trackerContext,
9564                                                                TestCaseTracking::NameAndLocation( static_cast&lt;std::string&gt;(generatorName), lineInfo ) );
9565          m_lastAssertionInfo.lineInfo = lineInfo;
9566          return tracker;
9567      }
9568      bool RunContext::testForMissingAssertions(Counts&amp; assertions) {
9569          if (assertions.total() != 0)
9570              return false;
9571          if (!m_config-&gt;warnAboutMissingAssertions())
9572              return false;
9573          if (m_trackerContext.currentTracker().hasChildren())
9574              return false;
9575          m_totals.assertions.failed++;
9576          assertions.failed++;
9577          return true;
9578      }
9579      void RunContext::sectionEnded(SectionEndInfo const &amp; endInfo) {
9580          Counts assertions = m_totals.assertions - endInfo.prevAssertions;
9581          bool missingAssertions = testForMissingAssertions(assertions);
9582          if (!m_activeSections.empty()) {
9583              m_activeSections.back()-&gt;close();
9584              m_activeSections.pop_back();
9585          }
9586          m_reporter-&gt;sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
9587          m_messages.clear();
9588          m_messageScopes.clear();
9589      }
9590      void RunContext::sectionEndedEarly(SectionEndInfo const &amp; endInfo) {
9591          if (m_unfinishedSections.empty())
9592              m_activeSections.back()-&gt;fail();
9593          else
9594              m_activeSections.back()-&gt;close();
9595          m_activeSections.pop_back();
9596          m_unfinishedSections.push_back(endInfo);
9597      }
9598  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
9599      void RunContext::benchmarkPreparing(std::string const&amp; name) {
9600          m_reporter-&gt;benchmarkPreparing(name);
9601      }
9602      void RunContext::benchmarkStarting( BenchmarkInfo const&amp; info ) {
9603          m_reporter-&gt;benchmarkStarting( info );
9604      }
9605      void RunContext::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) {
9606          m_reporter-&gt;benchmarkEnded( stats );
9607      }
9608      void RunContext::benchmarkFailed(std::string const &amp; error) {
9609          m_reporter-&gt;benchmarkFailed(error);
9610      }
9611  #endif 
9612      void RunContext::pushScopedMessage(MessageInfo const &amp; message) {
9613          m_messages.push_back(message);
9614      }
9615      void RunContext::popScopedMessage(MessageInfo const &amp; message) {
9616          m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
9617      }
9618      void RunContext::emplaceUnscopedMessage( MessageBuilder const&amp; builder ) {
9619          m_messageScopes.emplace_back( builder );
9620      }
9621      std::string RunContext::getCurrentTestName() const {
9622          return m_activeTestCase
9623              ? m_activeTestCase-&gt;getTestCaseInfo().name
9624              : std::string();
9625      }
9626      const AssertionResult * RunContext::getLastResult() const {
9627          return &amp;(*m_lastResult);
9628      }
9629      void RunContext::exceptionEarlyReported() {
9630          m_shouldReportUnexpected = false;
9631      }
9632      void RunContext::handleFatalErrorCondition( StringRef message ) {
9633          m_reporter-&gt;fatalErrorEncountered(message);
9634          AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
9635          tempResult.message = static_cast&lt;std::string&gt;(message);
9636          AssertionResult result(m_lastAssertionInfo, tempResult);
9637          assertionEnded(result);
9638          handleUnfinishedSections();
9639          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9640          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9641          Counts assertions;
9642          assertions.failed = 1;
9643          SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
9644          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9645          auto const&amp; testInfo = m_activeTestCase-&gt;getTestCaseInfo();
9646          Totals deltaTotals;
9647          deltaTotals.testCases.failed = 1;
9648          deltaTotals.assertions.failed = 1;
9649          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9650                                    deltaTotals,
9651                                    std::string(),
9652                                    std::string(),
9653                                    false));
9654          m_totals.testCases.failed++;
9655          testGroupEnded(std::string(), m_totals, 1, 1);
9656          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, false));
9657      }
9658      bool RunContext::lastAssertionPassed() {
9659           return m_lastAssertionPassed;
9660      }
9661      void RunContext::assertionPassed() {
9662          m_lastAssertionPassed = true;
9663          ++m_totals.assertions.passed;
9664          resetAssertionInfo();
9665          m_messageScopes.clear();
9666      }
9667      bool RunContext::aborting() const {
9668          return m_totals.assertions.failed &gt;= static_cast&lt;std::size_t&gt;(m_config-&gt;abortAfter());
9669      }
9670      void RunContext::runCurrentTest(std::string &amp; redirectedCout, std::string &amp; redirectedCerr) {
9671          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9672          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9673          m_reporter-&gt;sectionStarting(testCaseSection);
9674          Counts prevAssertions = m_totals.assertions;
9675          double duration = 0;
9676          m_shouldReportUnexpected = true;
9677          m_lastAssertionInfo = { &quot;TEST_CASE&quot;_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
9678          seedRng(*m_config);
9679          Timer timer;
9680          CATCH_TRY {
9681              if (m_reporter-&gt;getPreferences().shouldRedirectStdOut) {
9682  #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
9683                  RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);
9684                  timer.start();
9685                  invokeActiveTestCase();
9686  #else
9687                  OutputRedirect r(redirectedCout, redirectedCerr);
9688                  timer.start();
9689                  invokeActiveTestCase();
9690  #endif
9691              } else {
9692                  timer.start();
9693                  invokeActiveTestCase();
9694              }
9695              duration = timer.getElapsedSeconds();
9696          } CATCH_CATCH_ANON (TestFailureException&amp;) {
9697          } CATCH_CATCH_ALL {
9698              if( m_shouldReportUnexpected ) {
9699                  AssertionReaction dummyReaction;
9700                  handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
9701              }
9702          }
9703          Counts assertions = m_totals.assertions - prevAssertions;
9704          bool missingAssertions = testForMissingAssertions(assertions);
9705          m_testCaseTracker-&gt;close();
9706          handleUnfinishedSections();
9707          m_messages.clear();
9708          m_messageScopes.clear();
9709          SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
9710          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9711      }
9712      void RunContext::invokeActiveTestCase() {
9713          FatalConditionHandlerGuard _(&amp;m_fatalConditionhandler);
9714          m_activeTestCase-&gt;invoke();
9715      }
9716      void RunContext::handleUnfinishedSections() {
9717          for (auto it = m_unfinishedSections.rbegin(),
9718               itEnd = m_unfinishedSections.rend();
9719               it != itEnd;
9720               ++it)
9721              sectionEnded(*it);
9722          m_unfinishedSections.clear();
9723      }
9724      void RunContext::handleExpr(
9725          AssertionInfo const&amp; info,
9726          ITransientExpression const&amp; expr,
9727          AssertionReaction&amp; reaction
9728      ) {
9729          m_reporter-&gt;assertionStarting( info );
9730          bool negated = isFalseTest( info.resultDisposition );
9731          bool result = expr.getResult() != negated;
9732          if( result ) {
9733              if (!m_includeSuccessfulResults) {
9734                  assertionPassed();
9735              }
9736              else {
9737                  reportExpr(info, ResultWas::Ok, &amp;expr, negated);
9738              }
9739          }
9740          else {
9741              reportExpr(info, ResultWas::ExpressionFailed, &amp;expr, negated );
9742              populateReaction( reaction );
9743          }
9744      }
9745      void RunContext::reportExpr(
9746              AssertionInfo const &amp;info,
9747              ResultWas::OfType resultType,
9748              ITransientExpression const *expr,
9749              bool negated ) {
9750          m_lastAssertionInfo = info;
9751          AssertionResultData data( resultType, LazyExpression( negated ) );
9752          AssertionResult assertionResult{ info, data };
9753          assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
9754          assertionEnded( assertionResult );
9755      }
9756      void RunContext::handleMessage(
9757              AssertionInfo const&amp; info,
9758              ResultWas::OfType resultType,
9759              StringRef const&amp; message,
9760              AssertionReaction&amp; reaction
9761      ) {
9762          m_reporter-&gt;assertionStarting( info );
9763          m_lastAssertionInfo = info;
9764          AssertionResultData data( resultType, LazyExpression( false ) );
9765          data.message = static_cast&lt;std::string&gt;(message);
9766          AssertionResult assertionResult{ m_lastAssertionInfo, data };
9767          assertionEnded( assertionResult );
9768          if( !assertionResult.isOk() )
9769              populateReaction( reaction );
9770      }
9771      void RunContext::handleUnexpectedExceptionNotThrown(
9772              AssertionInfo const&amp; info,
9773              AssertionReaction&amp; reaction
9774      ) {
9775          handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
9776      }
9777      void RunContext::handleUnexpectedInflightException(
9778              AssertionInfo const&amp; info,
9779              std::string const&amp; message,
9780              AssertionReaction&amp; reaction
9781      ) {
9782          m_lastAssertionInfo = info;
9783          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9784          data.message = message;
9785          AssertionResult assertionResult{ info, data };
9786          assertionEnded( assertionResult );
9787          populateReaction( reaction );
9788      }
9789      void RunContext::populateReaction( AssertionReaction&amp; reaction ) {
9790          reaction.shouldDebugBreak = m_config-&gt;shouldDebugBreak();
9791          reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition &amp; ResultDisposition::Normal);
9792      }
9793      void RunContext::handleIncomplete(
9794              AssertionInfo const&amp; info
9795      ) {
9796          m_lastAssertionInfo = info;
9797          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9798          data.message = &quot;Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE&quot;;
9799          AssertionResult assertionResult{ info, data };
9800          assertionEnded( assertionResult );
9801      }
9802      void RunContext::handleNonExpr(
9803              AssertionInfo const &amp;info,
9804              ResultWas::OfType resultType,
9805              AssertionReaction &amp;reaction
9806      ) {
9807          m_lastAssertionInfo = info;
9808          AssertionResultData data( resultType, LazyExpression( false ) );
9809          AssertionResult assertionResult{ info, data };
9810          assertionEnded( assertionResult );
9811          if( !assertionResult.isOk() )
9812              populateReaction( reaction );
9813      }
9814      IResultCapture&amp; getResultCapture() {
9815          if (auto* capture = getCurrentContext().getResultCapture())
9816              return *capture;
9817          else
9818              CATCH_INTERNAL_ERROR(&quot;No result capture instance&quot;);
9819      }
9820      void seedRng(IConfig const&amp; config) {
9821          if (config.rngSeed() != 0) {
9822              std::srand(config.rngSeed());
9823              rng().seed(config.rngSeed());
9824          }
9825      }
9826      unsigned int rngSeed() {
9827          return getCurrentContext().getConfig()-&gt;rngSeed();
9828      }
9829  }
9830  namespace Catch {
9831      Section::Section( SectionInfo const&amp; info )
9832      :   m_info( info ),
9833          m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
9834      {
9835          m_timer.start();
9836      }
9837      Section::~Section() {
9838          if( m_sectionIncluded ) {
9839              SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
9840              if( uncaught_exceptions() )
9841                  getResultCapture().sectionEndedEarly( endInfo );
9842              else
9843                  getResultCapture().sectionEnded( endInfo );
9844          }
9845      }
9846      Section::operator bool() const {
9847          return m_sectionIncluded;
9848      }
9849  } 
9850  namespace Catch {
9851      SectionInfo::SectionInfo
9852          (   SourceLineInfo const&amp; _lineInfo,
9853              std::string const&amp; _name )
9854      :   name( _name ),
9855          lineInfo( _lineInfo )
9856      {}
9857  } 
9858  #include &lt;memory&gt;
9859  namespace Catch {
9860      class Session : NonCopyable {
9861      public:
9862          Session();
9863          ~Session() override;
9864          void showHelp() const;
9865          void libIdentify();
9866          int applyCommandLine( int argc, char const * const * argv );
9867      #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
9868          int applyCommandLine( int argc, wchar_t const * const * argv );
9869      #endif
9870          void useConfigData( ConfigData const&amp; configData );
9871          template&lt;typename CharT&gt;
9872          int run(int argc, CharT const * const argv[]) {
9873              if (m_startupExceptions)
9874                  return 1;
9875              int returnCode = applyCommandLine(argc, argv);
9876              if (returnCode == 0)
9877                  returnCode = run();
9878              return returnCode;
9879          }
9880          int run();
9881          clara::Parser const&amp; cli() const;
9882          void cli( clara::Parser const&amp; newParser );
9883          ConfigData&amp; configData();
9884          Config&amp; config();
9885      private:
9886          int runInternal();
9887          clara::Parser m_cli;
9888          ConfigData m_configData;
9889          std::shared_ptr&lt;Config&gt; m_config;
9890          bool m_startupExceptions = false;
9891      };
9892  } 
9893  #include &lt;iosfwd&gt;
9894  namespace Catch {
9895      struct Version {
9896          Version( Version const&amp; ) = delete;
9897          Version&amp; operator=( Version const&amp; ) = delete;
9898          Version(    unsigned int _majorVersion,
9899                      unsigned int _minorVersion,
9900                      unsigned int _patchNumber,
9901                      char const * const _branchName,
9902                      unsigned int _buildNumber );
9903          unsigned int const majorVersion;
9904          unsigned int const minorVersion;
9905          unsigned int const patchNumber;
9906          char const * const branchName;
9907          unsigned int const buildNumber;
9908          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version );
9909      };
9910      Version const&amp; libraryVersion();
9911  }
9912  #include &lt;cstdlib&gt;
9913  #include &lt;iomanip&gt;
9914  #include &lt;set&gt;
9915  #include &lt;iterator&gt;
9916  namespace Catch {
9917      namespace {
9918          const int MaxExitCode = 255;
9919          IStreamingReporterPtr createReporter(std::string const&amp; reporterName, IConfigPtr const&amp; config) {
9920              auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
9921              CATCH_ENFORCE(reporter, &quot;No reporter registered with name: &#x27;&quot; &lt;&lt; reporterName &lt;&lt; &quot;&#x27;&quot;);
9922              return reporter;
9923          }
9924          IStreamingReporterPtr makeReporter(std::shared_ptr&lt;Config&gt; const&amp; config) {
9925              if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
9926                  return createReporter(config-&gt;getReporterName(), config);
9927              }
9928              auto ret = std::unique_ptr&lt;IStreamingReporter&gt;(new ListeningReporter);
9929              auto&amp; multi = static_cast&lt;ListeningReporter&amp;&gt;(*ret);
9930              auto const&amp; listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
9931              for (auto const&amp; listener : listeners) {
9932                  multi.addListener(listener-&gt;create(Catch::ReporterConfig(config)));
9933              }
9934              multi.addReporter(createReporter(config-&gt;getReporterName(), config));
9935              return ret;
9936          }
9937          class TestGroup {
9938          public:
9939              explicit TestGroup(std::shared_ptr&lt;Config&gt; const&amp; config)
9940              : m_config{config}
9941              , m_context{config, makeReporter(config)}
9942              {
9943                  auto const&amp; allTestCases = getAllTestCasesSorted(*m_config);
9944                  m_matches = m_config-&gt;testSpec().matchesByFilter(allTestCases, *m_config);
9945                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9946                  if (m_matches.empty() &amp;&amp; invalidArgs.empty()) {
9947                      for (auto const&amp; test : allTestCases)
9948                          if (!test.isHidden())
9949                              m_tests.emplace(&amp;test);
9950                  } else {
9951                      for (auto const&amp; match : m_matches)
9952                          m_tests.insert(match.tests.begin(), match.tests.end());
9953                  }
9954              }
9955              Totals execute() {
9956                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9957                  Totals totals;
9958                  m_context.testGroupStarting(m_config-&gt;name(), 1, 1);
9959                  for (auto const&amp; testCase : m_tests) {
9960                      if (!m_context.aborting())
9961                          totals += m_context.runTest(*testCase);
9962                      else
9963                          m_context.reporter().skipTest(*testCase);
9964                  }
9965                  for (auto const&amp; match : m_matches) {
9966                      if (match.tests.empty()) {
9967                          m_context.reporter().noMatchingTestCases(match.name);
9968                          totals.error = -1;
9969                      }
9970                  }
9971                  if (!invalidArgs.empty()) {
9972                      for (auto const&amp; invalidArg: invalidArgs)
9973                           m_context.reporter().reportInvalidArguments(invalidArg);
9974                  }
9975                  m_context.testGroupEnded(m_config-&gt;name(), totals, 1, 1);
9976                  return totals;
9977              }
9978          private:
9979              using Tests = std::set&lt;TestCase const*&gt;;
9980              std::shared_ptr&lt;Config&gt; m_config;
9981              RunContext m_context;
9982              Tests m_tests;
9983              TestSpec::Matches m_matches;
9984          };
9985          void applyFilenamesAsTags(Catch::IConfig const&amp; config) {
9986              auto&amp; tests = const_cast&lt;std::vector&lt;TestCase&gt;&amp;&gt;(getAllTestCasesSorted(config));
9987              for (auto&amp; testCase : tests) {
9988                  auto tags = testCase.tags;
9989                  std::string filename = testCase.lineInfo.file;
9990                  auto lastSlash = filename.find_last_of(&quot;\\/&quot;);
9991                  if (lastSlash != std::string::npos) {
9992                      filename.erase(0, lastSlash);
9993                      filename[0] = &#x27;#&#x27;;
9994                  }
9995                  auto lastDot = filename.find_last_of(&#x27;.&#x27;);
9996                  if (lastDot != std::string::npos) {
9997                      filename.erase(lastDot);
9998                  }
9999                  tags.push_back(std::move(filename));
10000                  setTags(testCase, tags);
10001              }
10002          }
10003      } 
10004      Session::Session() {
10005          static bool alreadyInstantiated = false;
10006          if( alreadyInstantiated ) {
10007              CATCH_TRY { CATCH_INTERNAL_ERROR( &quot;Only one instance of Catch::Session can ever be used&quot; ); }
10008              CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
10009          }
10010  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10011          const auto&amp; exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
10012          if ( !exceptions.empty() ) {
10013              config();
10014              getCurrentMutableContext().setConfig(m_config);
10015              m_startupExceptions = true;
10016              Colour colourGuard( Colour::Red );
10017              Catch::cerr() &lt;&lt; &quot;Errors occurred during startup!&quot; &lt;&lt; &#x27;\n&#x27;;
10018              for ( const auto&amp; ex_ptr : exceptions ) {
10019                  try {
10020                      std::rethrow_exception(ex_ptr);
10021                  } catch ( std::exception const&amp; ex ) {
10022                      Catch::cerr() &lt;&lt; Column( ex.what() ).indent(2) &lt;&lt; &#x27;\n&#x27;;
10023                  }
10024              }
10025          }
10026  #endif
10027          alreadyInstantiated = true;
10028          m_cli = makeCommandLineParser( m_configData );
10029      }
10030      Session::~Session() {
10031          Catch::cleanUp();
10032      }
10033      void Session::showHelp() const {
10034          Catch::cout()
10035                  &lt;&lt; &quot;\nCatch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot;\n&quot;
10036                  &lt;&lt; m_cli &lt;&lt; std::endl
10037                  &lt;&lt; &quot;For more detailed usage please see the project docs\n&quot; &lt;&lt; std::endl;
10038      }
10039      void Session::libIdentify() {
10040          Catch::cout()
10041                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;description: &quot; &lt;&lt; &quot;A Catch2 test executable\n&quot;
10042                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;category: &quot; &lt;&lt; &quot;testframework\n&quot;
10043                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;framework: &quot; &lt;&lt; &quot;Catch Test\n&quot;
10044                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;version: &quot; &lt;&lt; libraryVersion() &lt;&lt; std::endl;
10045      }
10046      int Session::applyCommandLine( int argc, char const * const * argv ) {
10047          if( m_startupExceptions )
10048              return 1;
10049          auto result = m_cli.parse( clara::Args( argc, argv ) );
10050          if( !result ) {
10051              config();
10052              getCurrentMutableContext().setConfig(m_config);
10053              Catch::cerr()
10054                  &lt;&lt; Colour( Colour::Red )
10055                  &lt;&lt; &quot;\nError(s) in input:\n&quot;
10056                  &lt;&lt; Column( result.errorMessage() ).indent( 2 )
10057                  &lt;&lt; &quot;\n\n&quot;;
10058              Catch::cerr() &lt;&lt; &quot;Run with -? for usage\n&quot; &lt;&lt; std::endl;
10059              return MaxExitCode;
10060          }
10061          if( m_configData.showHelp )
10062              showHelp();
10063          if( m_configData.libIdentify )
10064              libIdentify();
10065          m_config.reset();
10066          return 0;
10067      }
10068  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
10069      int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {
10070          char **utf8Argv = new char *[ argc ];
10071          for ( int i = 0; i &lt; argc; ++i ) {
10072              int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );
10073              utf8Argv[ i ] = new char[ bufSize ];
10074              WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
10075          }
10076          int returnCode = applyCommandLine( argc, utf8Argv );
10077          for ( int i = 0; i &lt; argc; ++i )
10078              delete [] utf8Argv[ i ];
10079          delete [] utf8Argv;
10080          return returnCode;
10081      }
10082  #endif
10083      void Session::useConfigData( ConfigData const&amp; configData ) {
10084          m_configData = configData;
10085          m_config.reset();
10086      }
10087      int Session::run() {
10088          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeStart ) != 0 ) {
10089              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before starting&quot; &lt;&lt; std::endl;
10090              static_cast&lt;void&gt;(std::getchar());
10091          }
10092          int exitCode = runInternal();
10093          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeExit ) != 0 ) {
10094              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before exiting, with code: &quot; &lt;&lt; exitCode &lt;&lt; std::endl;
10095              static_cast&lt;void&gt;(std::getchar());
10096          }
10097          return exitCode;
10098      }
10099      clara::Parser const&amp; Session::cli() const {
10100          return m_cli;
10101      }
10102      void Session::cli( clara::Parser const&amp; newParser ) {
10103          m_cli = newParser;
10104      }
10105      ConfigData&amp; Session::configData() {
10106          return m_configData;
10107      }
10108      Config&amp; Session::config() {
10109          if( !m_config )
10110              m_config = std::make_shared&lt;Config&gt;( m_configData );
10111          return *m_config;
10112      }
10113      int Session::runInternal() {
10114          if( m_startupExceptions )
10115              return 1;
10116          if (m_configData.showHelp || m_configData.libIdentify) {
10117              return 0;
10118          }
10119          CATCH_TRY {
10120              config(); 
10121              seedRng( *m_config );
10122              if( m_configData.filenamesAsTags )
10123                  applyFilenamesAsTags( *m_config );
10124              if( Option&lt;std::size_t&gt; listed = list( m_config ) )
10125                  return static_cast&lt;int&gt;( *listed );
10126              TestGroup tests { m_config };
10127              auto const totals = tests.execute();
10128              if( m_config-&gt;warnAboutNoTests() &amp;&amp; totals.error == -1 )
10129                  return 2;
10130              return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast&lt;int&gt;(totals.assertions.failed)));
10131          }
10132  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10133          catch( std::exception&amp; ex ) {
10134              Catch::cerr() &lt;&lt; ex.what() &lt;&lt; std::endl;
10135              return MaxExitCode;
10136          }
10137  #endif
10138      }
10139  } 
10140  #include &lt;vector&gt;
10141  namespace Catch {
10142      namespace {
10143          static auto getSingletons() -&gt; std::vector&lt;ISingleton*&gt;*&amp; {
10144              static std::vector&lt;ISingleton*&gt;* g_singletons = nullptr;
10145              if( !g_singletons )
10146                  g_singletons = new std::vector&lt;ISingleton*&gt;();
10147              return g_singletons;
10148          }
10149      }
10150      ISingleton::~ISingleton() {}
10151      void addSingleton(ISingleton* singleton ) {
10152          getSingletons()-&gt;push_back( singleton );
10153      }
10154      void cleanupSingletons() {
10155          auto&amp; singletons = getSingletons();
10156          for( auto singleton : *singletons )
10157              delete singleton;
10158          delete singletons;
10159          singletons = nullptr;
10160      }
10161  } 
10162  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10163  namespace Catch {
10164  void StartupExceptionRegistry::add( std::exception_ptr const&amp; exception ) noexcept {
10165          CATCH_TRY {
10166              m_exceptions.push_back(exception);
10167          } CATCH_CATCH_ALL {
10168              std::terminate();
10169          }
10170      }
10171      std::vector&lt;std::exception_ptr&gt; const&amp; StartupExceptionRegistry::getExceptions() const noexcept {
10172          return m_exceptions;
10173      }
10174  } 
10175  #endif
10176  #include &lt;cstdio&gt;
10177  #include &lt;iostream&gt;
10178  #include &lt;fstream&gt;
10179  #include &lt;sstream&gt;
10180  #include &lt;vector&gt;
10181  #include &lt;memory&gt;
10182  namespace Catch {
10183      Catch::IStream::~IStream() = default;
10184      namespace Detail { namespace {
10185          template&lt;typename WriterF, std::size_t bufferSize=256&gt;
10186          class StreamBufImpl : public std::streambuf {
10187              char data[bufferSize];
10188              WriterF m_writer;
10189          public:
10190              StreamBufImpl() {
10191                  setp( data, data + sizeof(data) );
10192              }
10193              ~StreamBufImpl() noexcept {
10194                  StreamBufImpl::sync();
10195              }
10196          private:
10197              int overflow( int c ) override {
10198                  sync();
10199                  if( c != EOF ) {
10200                      if( pbase() == epptr() )
10201                          m_writer( std::string( 1, static_cast&lt;char&gt;( c ) ) );
10202                      else
10203                          sputc( static_cast&lt;char&gt;( c ) );
10204                  }
10205                  return 0;
10206              }
10207              int sync() override {
10208                  if( pbase() != pptr() ) {
10209                      m_writer( std::string( pbase(), static_cast&lt;std::string::size_type&gt;( pptr() - pbase() ) ) );
10210                      setp( pbase(), epptr() );
10211                  }
10212                  return 0;
10213              }
10214          };
10215          struct OutputDebugWriter {
10216              void operator()( std::string const&amp;str ) {
10217                  writeToDebugConsole( str );
10218              }
10219          };
10220          class FileStream : public IStream {
10221              mutable std::ofstream m_ofs;
10222          public:
10223              FileStream( StringRef filename ) {
10224                  m_ofs.open( filename.c_str() );
10225                  CATCH_ENFORCE( !m_ofs.fail(), &quot;Unable to open file: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10226              }
10227              ~FileStream() override = default;
10228          public: 
10229              std::ostream&amp; stream() const override {
10230                  return m_ofs;
10231              }
10232          };
10233          class CoutStream : public IStream {
10234              mutable std::ostream m_os;
10235          public:
10236              CoutStream() : m_os( Catch::cout().rdbuf() ) {}
10237              ~CoutStream() override = default;
10238          public: 
10239              std::ostream&amp; stream() const override { return m_os; }
10240          };
10241          class DebugOutStream : public IStream {
10242              std::unique_ptr&lt;StreamBufImpl&lt;OutputDebugWriter&gt;&gt; m_streamBuf;
10243              mutable std::ostream m_os;
10244          public:
10245              DebugOutStream()
10246              :   m_streamBuf( new StreamBufImpl&lt;OutputDebugWriter&gt;() ),
10247                  m_os( m_streamBuf.get() )
10248              {}
10249              ~DebugOutStream() override = default;
10250          public: 
10251              std::ostream&amp; stream() const override { return m_os; }
10252          };
10253      }} 
10254      auto makeStream( StringRef const &amp;filename ) -&gt; IStream const* {
10255          if( filename.empty() )
10256              return new Detail::CoutStream();
10257          else if( filename[0] == &#x27;%&#x27; ) {
10258              if( filename == &quot;%debug&quot; )
10259                  return new Detail::DebugOutStream();
10260              else
10261                  CATCH_ERROR( &quot;Unrecognised stream: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10262          }
10263          else
10264              return new Detail::FileStream( filename );
10265      }
10266      struct StringStreams {
10267          std::vector&lt;std::unique_ptr&lt;std::ostringstream&gt;&gt; m_streams;
10268          std::vector&lt;std::size_t&gt; m_unused;
10269          std::ostringstream m_referenceStream; 
10270          auto add() -&gt; std::size_t {
10271              if( m_unused.empty() ) {
10272                  m_streams.push_back( std::unique_ptr&lt;std::ostringstream&gt;( new std::ostringstream ) );
10273                  return m_streams.size()-1;
10274              }
10275              else {
10276                  auto index = m_unused.back();
10277                  m_unused.pop_back();
10278                  return index;
10279              }
10280          }
10281          void release( std::size_t index ) {
10282              m_streams[index]-&gt;copyfmt( m_referenceStream ); 
10283              m_unused.push_back(index);
10284          }
10285      };
10286      ReusableStringStream::ReusableStringStream()
10287      :   m_index( Singleton&lt;StringStreams&gt;::getMutable().add() ),
10288          m_oss( Singleton&lt;StringStreams&gt;::getMutable().m_streams[m_index].get() )
10289      {}
10290      ReusableStringStream::~ReusableStringStream() {
10291          static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str(&quot;&quot;);
10292          m_oss-&gt;clear();
10293          Singleton&lt;StringStreams&gt;::getMutable().release( m_index );
10294      }
10295      auto ReusableStringStream::str() const -&gt; std::string {
10296          return static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str();
10297      }
10298  #ifndef CATCH_CONFIG_NOSTDOUT 
10299      std::ostream&amp; cout() { return std::cout; }
10300      std::ostream&amp; cerr() { return std::cerr; }
10301      std::ostream&amp; clog() { return std::clog; }
10302  #endif
10303  }
10304  #include &lt;algorithm&gt;
10305  #include &lt;ostream&gt;
10306  #include &lt;cstring&gt;
10307  #include &lt;cctype&gt;
10308  #include &lt;vector&gt;
10309  namespace Catch {
10310      namespace {
10311          char toLowerCh(char c) {
10312              return static_cast&lt;char&gt;( std::tolower( static_cast&lt;unsigned char&gt;(c) ) );
10313          }
10314      }
10315      bool startsWith( std::string const&amp; s, std::string const&amp; prefix ) {
10316          return s.size() &gt;= prefix.size() &amp;&amp; std::equal(prefix.begin(), prefix.end(), s.begin());
10317      }
10318      bool startsWith( std::string const&amp; s, char prefix ) {
10319          return !s.empty() &amp;&amp; s[0] == prefix;
10320      }
10321      bool endsWith( std::string const&amp; s, std::string const&amp; suffix ) {
10322          return s.size() &gt;= suffix.size() &amp;&amp; std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
10323      }
10324      bool endsWith( std::string const&amp; s, char suffix ) {
10325          return !s.empty() &amp;&amp; s[s.size()-1] == suffix;
10326      }
10327      bool contains( std::string const&amp; s, std::string const&amp; infix ) {
10328          return s.find( infix ) != std::string::npos;
10329      }
10330      void toLowerInPlace( std::string&amp; s ) {
10331          std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
10332      }
10333      std::string toLower( std::string const&amp; s ) {
10334          std::string lc = s;
10335          toLowerInPlace( lc );
10336          return lc;
10337      }
10338      std::string trim( std::string const&amp; str ) {
10339          static char const* whitespaceChars = &quot;\n\r\t &quot;;
10340          std::string::size_type start = str.find_first_not_of( whitespaceChars );
10341          std::string::size_type end = str.find_last_not_of( whitespaceChars );
10342          return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
10343      }
10344      StringRef trim(StringRef ref) {
10345          const auto is_ws = [](char c) {
10346              return c == &#x27; &#x27; || c == &#x27;\t&#x27; || c == &#x27;\n&#x27; || c == &#x27;\r&#x27;;
10347          };
10348          size_t real_begin = 0;
10349          while (real_begin &lt; ref.size() &amp;&amp; is_ws(ref[real_begin])) { ++real_begin; }
10350          size_t real_end = ref.size();
10351          while (real_end &gt; real_begin &amp;&amp; is_ws(ref[real_end - 1])) { --real_end; }
10352          return ref.substr(real_begin, real_end - real_begin);
10353      }
10354      bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis ) {
10355          bool replaced = false;
10356          std::size_t i = str.find( replaceThis );
10357          while( i != std::string::npos ) {
10358              replaced = true;
10359              str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
10360              if( i &lt; str.size()-withThis.size() )
10361                  i = str.find( replaceThis, i+withThis.size() );
10362              else
10363                  i = std::string::npos;
10364          }
10365          return replaced;
10366      }
10367      std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter ) {
10368          std::vector&lt;StringRef&gt; subStrings;
10369          std::size_t start = 0;
10370          for(std::size_t pos = 0; pos &lt; str.size(); ++pos ) {
10371              if( str[pos] == delimiter ) {
10372                  if( pos - start &gt; 1 )
10373                      subStrings.push_back( str.substr( start, pos-start ) );
10374                  start = pos+1;
10375              }
10376          }
10377          if( start &lt; str.size() )
10378              subStrings.push_back( str.substr( start, str.size()-start ) );
10379          return subStrings;
10380      }
10381      pluralise::pluralise( std::size_t count, std::string const&amp; label )
10382      :   m_count( count ),
10383          m_label( label )
10384      {}
10385      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser ) {
10386          os &lt;&lt; pluraliser.m_count &lt;&lt; &#x27; &#x27; &lt;&lt; pluraliser.m_label;
10387          if( pluraliser.m_count != 1 )
10388              os &lt;&lt; &#x27;s&#x27;;
10389          return os;
10390      }
10391  }
10392  #include &lt;algorithm&gt;
10393  #include &lt;ostream&gt;
10394  #include &lt;cstring&gt;
10395  #include &lt;cstdint&gt;
10396  namespace Catch {
10397      StringRef::StringRef( char const* rawChars ) noexcept
10398      : StringRef( rawChars, static_cast&lt;StringRef::size_type&gt;(std::strlen(rawChars) ) )
10399      {}
10400      auto StringRef::c_str() const -&gt; char const* {
10401          CATCH_ENFORCE(isNullTerminated(), &quot;Called StringRef::c_str() on a non-null-terminated instance&quot;);
10402          return m_start;
10403      }
10404      auto StringRef::data() const noexcept -&gt; char const* {
10405          return m_start;
10406      }
10407      auto StringRef::substr( size_type start, size_type size ) const noexcept -&gt; StringRef {
10408          if (start &lt; m_size) {
10409              return StringRef(m_start + start, (std::min)(m_size - start, size));
10410          } else {
10411              return StringRef();
10412          }
10413      }
10414      auto StringRef::operator == ( StringRef const&amp; other ) const noexcept -&gt; bool {
10415          return m_size == other.m_size
10416              &amp;&amp; (std::memcmp( m_start, other.m_start, m_size ) == 0);
10417      }
10418      auto operator &lt;&lt; ( std::ostream&amp; os, StringRef const&amp; str ) -&gt; std::ostream&amp; {
10419          return os.write(str.data(), str.size());
10420      }
10421      auto operator+=( std::string&amp; lhs, StringRef const&amp; rhs ) -&gt; std::string&amp; {
10422          lhs.append(rhs.data(), rhs.size());
10423          return lhs;
10424      }
10425  } 
10426  namespace Catch {
10427      TagAlias::TagAlias(std::string const &amp; _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
10428  }
10429  namespace Catch {
10430      RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const&amp; lineInfo) {
10431          CATCH_TRY {
10432              getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
10433          } CATCH_CATCH_ALL {
10434              getMutableRegistryHub().registerStartupException();
10435          }
10436      }
10437  }
10438  #include &lt;sstream&gt;
10439  namespace Catch {
10440      TagAliasRegistry::~TagAliasRegistry() {}
10441      TagAlias const* TagAliasRegistry::find( std::string const&amp; alias ) const {
10442          auto it = m_registry.find( alias );
10443          if( it != m_registry.end() )
10444              return &amp;(it-&gt;second);
10445          else
10446              return nullptr;
10447      }
10448      std::string TagAliasRegistry::expandAliases( std::string const&amp; unexpandedTestSpec ) const {
10449          std::string expandedTestSpec = unexpandedTestSpec;
10450          for( auto const&amp; registryKvp : m_registry ) {
10451              std::size_t pos = expandedTestSpec.find( registryKvp.first );
10452              if( pos != std::string::npos ) {
10453                  expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
10454                                      registryKvp.second.tag +
10455                                      expandedTestSpec.substr( pos + registryKvp.first.size() );
10456              }
10457          }
10458          return expandedTestSpec;
10459      }
10460      void TagAliasRegistry::add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) {
10461          CATCH_ENFORCE( startsWith(alias, &quot;[@&quot;) &amp;&amp; endsWith(alias, &#x27;]&#x27;),
10462                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; is not of the form [@alias name].\n&quot; &lt;&lt; lineInfo );
10463          CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
10464                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; already registered.\n&quot;
10465                        &lt;&lt; &quot;\tFirst seen at: &quot; &lt;&lt; find(alias)-&gt;lineInfo &lt;&lt; &quot;\n&quot;
10466                        &lt;&lt; &quot;\tRedefined at: &quot; &lt;&lt; lineInfo );
10467      }
10468      ITagAliasRegistry::~ITagAliasRegistry() {}
10469      ITagAliasRegistry const&amp; ITagAliasRegistry::get() {
10470          return getRegistryHub().getTagAliasRegistry();
10471      }
10472  } 
10473  #include &lt;cctype&gt;
10474  #include &lt;exception&gt;
10475  #include &lt;algorithm&gt;
10476  #include &lt;sstream&gt;
10477  namespace Catch {
10478      namespace {
10479          TestCaseInfo::SpecialProperties parseSpecialTag( std::string const&amp; tag ) {
10480              if( startsWith( tag, &#x27;.&#x27; ) ||
10481                  tag == &quot;!hide&quot; )
10482                  return TestCaseInfo::IsHidden;
10483              else if( tag == &quot;!throws&quot; )
10484                  return TestCaseInfo::Throws;
10485              else if( tag == &quot;!shouldfail&quot; )
10486                  return TestCaseInfo::ShouldFail;
10487              else if( tag == &quot;!mayfail&quot; )
10488                  return TestCaseInfo::MayFail;
10489              else if( tag == &quot;!nonportable&quot; )
10490                  return TestCaseInfo::NonPortable;
10491              else if( tag == &quot;!benchmark&quot; )
10492                  return static_cast&lt;TestCaseInfo::SpecialProperties&gt;( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
10493              else
10494                  return TestCaseInfo::None;
10495          }
10496          bool isReservedTag( std::string const&amp; tag ) {
10497              return parseSpecialTag( tag ) == TestCaseInfo::None &amp;&amp; tag.size() &gt; 0 &amp;&amp; !std::isalnum( static_cast&lt;unsigned char&gt;(tag[0]) );
10498          }
10499          void enforceNotReservedTag( std::string const&amp; tag, SourceLineInfo const&amp; _lineInfo ) {
10500              CATCH_ENFORCE( !isReservedTag(tag),
10501                            &quot;Tag name: [&quot; &lt;&lt; tag &lt;&lt; &quot;] is not allowed.\n&quot;
10502                            &lt;&lt; &quot;Tag names starting with non alphanumeric characters are reserved\n&quot;
10503                            &lt;&lt; _lineInfo );
10504          }
10505      }
10506      TestCase makeTestCase(  ITestInvoker* _testCase,
10507                              std::string const&amp; _className,
10508                              NameAndTags const&amp; nameAndTags,
10509                              SourceLineInfo const&amp; _lineInfo )
10510      {
10511          bool isHidden = false;
10512          std::vector&lt;std::string&gt; tags;
10513          std::string desc, tag;
10514          bool inTag = false;
10515          for (char c : nameAndTags.tags) {
10516              if( !inTag ) {
10517                  if( c == &#x27;[&#x27; )
10518                      inTag = true;
10519                  else
10520                      desc += c;
10521              }
10522              else {
10523                  if( c == &#x27;]&#x27; ) {
10524                      TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
10525                      if( ( prop &amp; TestCaseInfo::IsHidden ) != 0 )
10526                          isHidden = true;
10527                      else if( prop == TestCaseInfo::None )
10528                          enforceNotReservedTag( tag, _lineInfo );
10529                      if (startsWith(tag, &#x27;.&#x27;) &amp;&amp; tag.size() &gt; 1) {
10530                          tag.erase(0, 1);
10531                      }
10532                      tags.push_back( tag );
10533                      tag.clear();
10534                      inTag = false;
10535                  }
10536                  else
10537                      tag += c;
10538              }
10539          }
10540          if( isHidden ) {
10541              tags.insert( tags.end(), { &quot;.&quot;, &quot;!hide&quot; } );
10542          }
10543          TestCaseInfo info( static_cast&lt;std::string&gt;(nameAndTags.name), _className, desc, tags, _lineInfo );
10544          return TestCase( _testCase, std::move(info) );
10545      }
10546      void setTags( TestCaseInfo&amp; testCaseInfo, std::vector&lt;std::string&gt; tags ) {
10547          std::sort(begin(tags), end(tags));
10548          tags.erase(std::unique(begin(tags), end(tags)), end(tags));
10549          testCaseInfo.lcaseTags.clear();
10550          for( auto const&amp; tag : tags ) {
10551              std::string lcaseTag = toLower( tag );
10552              testCaseInfo.properties = static_cast&lt;TestCaseInfo::SpecialProperties&gt;( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
10553              testCaseInfo.lcaseTags.push_back( lcaseTag );
10554          }
10555          testCaseInfo.tags = std::move(tags);
10556      }
10557      TestCaseInfo::TestCaseInfo( std::string const&amp; _name,
10558                                  std::string const&amp; _className,
10559                                  std::string const&amp; _description,
10560                                  std::vector&lt;std::string&gt; const&amp; _tags,
10561                                  SourceLineInfo const&amp; _lineInfo )
10562      :   name( _name ),
10563          className( _className ),
10564          description( _description ),
10565          lineInfo( _lineInfo ),
10566          properties( None )
10567      {
10568          setTags( *this, _tags );
10569      }
10570      bool TestCaseInfo::isHidden() const {
10571          return ( properties &amp; IsHidden ) != 0;
10572      }
10573      bool TestCaseInfo::throws() const {
10574          return ( properties &amp; Throws ) != 0;
10575      }
10576      bool TestCaseInfo::okToFail() const {
10577          return ( properties &amp; (ShouldFail | MayFail ) ) != 0;
10578      }
10579      bool TestCaseInfo::expectedToFail() const {
10580          return ( properties &amp; (ShouldFail ) ) != 0;
10581      }
10582      std::string TestCaseInfo::tagsAsString() const {
10583          std::string ret;
10584          std::size_t full_size = 2 * tags.size();
10585          for (const auto&amp; tag : tags) {
10586              full_size += tag.size();
10587          }
10588          ret.reserve(full_size);
10589          for (const auto&amp; tag : tags) {
10590              ret.push_back(&#x27;[&#x27;);
10591              ret.append(tag);
10592              ret.push_back(&#x27;]&#x27;);
10593          }
10594          return ret;
10595      }
10596      TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&amp;&amp; info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
10597      TestCase TestCase::withName( std::string const&amp; _newName ) const {
10598          TestCase other( *this );
10599          other.name = _newName;
10600          return other;
10601      }
10602      void TestCase::invoke() const {
10603          test-&gt;invoke();
10604      }
10605      bool TestCase::operator == ( TestCase const&amp; other ) const {
10606          return  test.get() == other.test.get() &amp;&amp;
10607                  name == other.name &amp;&amp;
10608                  className == other.className;
10609      }
10610      bool TestCase::operator &lt; ( TestCase const&amp; other ) const {
10611          return name &lt; other.name;
10612      }
10613      TestCaseInfo const&amp; TestCase::getTestCaseInfo() const
10614      {
10615          return *this;
10616      }
10617  } 
10618  #include &lt;algorithm&gt;
10619  #include &lt;sstream&gt;
10620  namespace Catch {
10621      namespace {
10622          struct TestHasher {
10623              using hash_t = uint64_t;
10624              explicit TestHasher( hash_t hashSuffix ):
10625                  m_hashSuffix{ hashSuffix } {}
10626              uint32_t operator()( TestCase const&amp; t ) const {
10627                  const hash_t prime = 1099511628211u;
10628                  hash_t hash = 14695981039346656037u;
10629                  for ( const char c : t.name ) {
10630                      hash ^= c;
10631                      hash *= prime;
10632                  }
10633                  hash ^= m_hashSuffix;
10634                  hash *= prime;
10635                  const uint32_t low{ static_cast&lt;uint32_t&gt;( hash ) };
10636                  const uint32_t high{ static_cast&lt;uint32_t&gt;( hash &gt;&gt; 32 ) };
10637                  return low * high;
10638              }
10639          private:
10640              hash_t m_hashSuffix;
10641          };
10642      } 
10643      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases ) {
10644          switch( config.runOrder() ) {
10645              case RunTests::InDeclarationOrder:
10646                  break;
10647              case RunTests::InLexicographicalOrder: {
10648                  std::vector&lt;TestCase&gt; sorted = unsortedTestCases;
10649                  std::sort( sorted.begin(), sorted.end() );
10650                  return sorted;
10651              }
10652              case RunTests::InRandomOrder: {
10653                  seedRng( config );
10654                  TestHasher h{ config.rngSeed() };
10655                  using hashedTest = std::pair&lt;TestHasher::hash_t, TestCase const*&gt;;
10656                  std::vector&lt;hashedTest&gt; indexed_tests;
10657                  indexed_tests.reserve( unsortedTestCases.size() );
10658                  for (auto const&amp; testCase : unsortedTestCases) {
10659                      indexed_tests.emplace_back(h(testCase), &amp;testCase);
10660                  }
10661                  std::sort(indexed_tests.begin(), indexed_tests.end(),
10662                            [](hashedTest const&amp; lhs, hashedTest const&amp; rhs) {
10663                            if (lhs.first == rhs.first) {
10664                                return lhs.second-&gt;name &lt; rhs.second-&gt;name;
10665                            }
10666                            return lhs.first &lt; rhs.first;
10667                  });
10668                  std::vector&lt;TestCase&gt; sorted;
10669                  sorted.reserve( indexed_tests.size() );
10670                  for (auto const&amp; hashed : indexed_tests) {
10671                      sorted.emplace_back(*hashed.second);
10672                  }
10673                  return sorted;
10674              }
10675          }
10676          return unsortedTestCases;
10677      }
10678      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config ) {
10679          return !testCase.throws() || config.allowThrows();
10680      }
10681      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10682          return testSpec.matches( testCase ) &amp;&amp; isThrowSafe( testCase, config );
10683      }
10684      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions ) {
10685          std::set&lt;TestCase&gt; seenFunctions;
10686          for( auto const&amp; function : functions ) {
10687              auto prev = seenFunctions.insert( function );
10688              CATCH_ENFORCE( prev.second,
10689                      &quot;error: TEST_CASE( \&quot;&quot; &lt;&lt; function.name &lt;&lt; &quot;\&quot; ) already defined.\n&quot;
10690                      &lt;&lt; &quot;\tFirst seen at &quot; &lt;&lt; prev.first-&gt;getTestCaseInfo().lineInfo &lt;&lt; &quot;\n&quot;
10691                      &lt;&lt; &quot;\tRedefined at &quot; &lt;&lt; function.getTestCaseInfo().lineInfo );
10692          }
10693      }
10694      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10695          std::vector&lt;TestCase&gt; filtered;
10696          filtered.reserve( testCases.size() );
10697          for (auto const&amp; testCase : testCases) {
10698              if ((!testSpec.hasFilters() &amp;&amp; !testCase.isHidden()) ||
10699                  (testSpec.hasFilters() &amp;&amp; matchTest(testCase, testSpec, config))) {
10700                  filtered.push_back(testCase);
10701              }
10702          }
10703          return filtered;
10704      }
10705      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config ) {
10706          return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
10707      }
10708      void TestRegistry::registerTest( TestCase const&amp; testCase ) {
10709          std::string name = testCase.getTestCaseInfo().name;
10710          if( name.empty() ) {
10711              ReusableStringStream rss;
10712              rss &lt;&lt; &quot;Anonymous test case &quot; &lt;&lt; ++m_unnamedCount;
10713              return registerTest( testCase.withName( rss.str() ) );
10714          }
10715          m_functions.push_back( testCase );
10716      }
10717      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTests() const {
10718          return m_functions;
10719      }
10720      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTestsSorted( IConfig const&amp; config ) const {
10721          if( m_sortedFunctions.empty() )
10722              enforceNoDuplicateTestCases( m_functions );
10723          if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
10724              m_sortedFunctions = sortTests( config, m_functions );
10725              m_currentSortOrder = config.runOrder();
10726          }
10727          return m_sortedFunctions;
10728      }
10729      TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
10730      void TestInvokerAsFunction::invoke() const {
10731          m_testAsFunction();
10732      }
10733      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName ) {
10734          std::string className(classOrQualifiedMethodName);
10735          if( startsWith( className, &#x27;&amp;&#x27; ) )
10736          {
10737              std::size_t lastColons = className.rfind( &quot;::&quot; );
10738              std::size_t penultimateColons = className.rfind( &quot;::&quot;, lastColons-1 );
10739              if( penultimateColons == std::string::npos )
10740                  penultimateColons = 1;
10741              className = className.substr( penultimateColons, lastColons-penultimateColons );
10742          }
10743          return className;
10744      }
10745  } 
10746  #include &lt;algorithm&gt;
10747  #include &lt;cassert&gt;
10748  #include &lt;stdexcept&gt;
10749  #include &lt;memory&gt;
10750  #include &lt;sstream&gt;
10751  #if defined(__clang__)
10752  #    pragma clang diagnostic push
10753  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
10754  #endif
10755  namespace Catch {
10756  namespace TestCaseTracking {
10757      NameAndLocation::NameAndLocation( std::string const&amp; _name, SourceLineInfo const&amp; _location )
10758      :   name( _name ),
10759          location( _location )
10760      {}
10761      ITracker::~ITracker() = default;
10762      ITracker&amp; TrackerContext::startRun() {
10763          m_rootTracker = std::make_shared&lt;SectionTracker&gt;( NameAndLocation( &quot;{root}&quot;, CATCH_INTERNAL_LINEINFO ), *this, nullptr );
10764          m_currentTracker = nullptr;
10765          m_runState = Executing;
10766          return *m_rootTracker;
10767      }
10768      void TrackerContext::endRun() {
10769          m_rootTracker.reset();
10770          m_currentTracker = nullptr;
10771          m_runState = NotStarted;
10772      }
10773      void TrackerContext::startCycle() {
10774          m_currentTracker = m_rootTracker.get();
10775          m_runState = Executing;
10776      }
10777      void TrackerContext::completeCycle() {
10778          m_runState = CompletedCycle;
10779      }
10780      bool TrackerContext::completedCycle() const {
10781          return m_runState == CompletedCycle;
10782      }
10783      ITracker&amp; TrackerContext::currentTracker() {
10784          return *m_currentTracker;
10785      }
10786      void TrackerContext::setCurrentTracker( ITracker* tracker ) {
10787          m_currentTracker = tracker;
10788      }
10789      TrackerBase::TrackerBase( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent ):
10790          ITracker(nameAndLocation),
10791          m_ctx( ctx ),
10792          m_parent( parent )
10793      {}
10794      bool TrackerBase::isComplete() const {
10795          return m_runState == CompletedSuccessfully || m_runState == Failed;
10796      }
10797      bool TrackerBase::isSuccessfullyCompleted() const {
10798          return m_runState == CompletedSuccessfully;
10799      }
10800      bool TrackerBase::isOpen() const {
10801          return m_runState != NotStarted &amp;&amp; !isComplete();
10802      }
10803      bool TrackerBase::hasChildren() const {
10804          return !m_children.empty();
10805      }
10806      void TrackerBase::addChild( ITrackerPtr const&amp; child ) {
10807          m_children.push_back( child );
10808      }
10809      ITrackerPtr TrackerBase::findChild( NameAndLocation const&amp; nameAndLocation ) {
10810          auto it = std::find_if( m_children.begin(), m_children.end(),
10811              [&amp;nameAndLocation]( ITrackerPtr const&amp; tracker ){
10812                  return
10813                      tracker-&gt;nameAndLocation().location == nameAndLocation.location &amp;&amp;
10814                      tracker-&gt;nameAndLocation().name == nameAndLocation.name;
10815              } );
10816          return( it != m_children.end() )
10817              ? *it
10818              : nullptr;
10819      }
10820      ITracker&amp; TrackerBase::parent() {
10821          assert( m_parent ); 
10822          return *m_parent;
10823      }
10824      void TrackerBase::openChild() {
10825          if( m_runState != ExecutingChildren ) {
10826              m_runState = ExecutingChildren;
10827              if( m_parent )
10828                  m_parent-&gt;openChild();
10829          }
10830      }
10831      bool TrackerBase::isSectionTracker() const { return false; }
10832      bool TrackerBase::isGeneratorTracker() const { return false; }
10833      void TrackerBase::open() {
10834          m_runState = Executing;
10835          moveToThis();
10836          if( m_parent )
10837              m_parent-&gt;openChild();
10838      }
10839      void TrackerBase::close() {
10840          while( &amp;m_ctx.currentTracker() != this )
10841              m_ctx.currentTracker().close();
10842          switch( m_runState ) {
10843              case NeedsAnotherRun:
10844                  break;
10845              case Executing:
10846                  m_runState = CompletedSuccessfully;
10847                  break;
10848              case ExecutingChildren:
10849                  if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const&amp; t){ return t-&gt;isComplete(); }) )
10850                      m_runState = CompletedSuccessfully;
10851                  break;
10852              case NotStarted:
10853              case CompletedSuccessfully:
10854              case Failed:
10855                  CATCH_INTERNAL_ERROR( &quot;Illogical state: &quot; &lt;&lt; m_runState );
10856              default:
10857                  CATCH_INTERNAL_ERROR( &quot;Unknown state: &quot; &lt;&lt; m_runState );
10858          }
10859          moveToParent();
10860          m_ctx.completeCycle();
10861      }
10862      void TrackerBase::fail() {
10863          m_runState = Failed;
10864          if( m_parent )
10865              m_parent-&gt;markAsNeedingAnotherRun();
10866          moveToParent();
10867          m_ctx.completeCycle();
10868      }
10869      void TrackerBase::markAsNeedingAnotherRun() {
10870          m_runState = NeedsAnotherRun;
10871      }
10872      void TrackerBase::moveToParent() {
10873          assert( m_parent );
10874          m_ctx.setCurrentTracker( m_parent );
10875      }
10876      void TrackerBase::moveToThis() {
10877          m_ctx.setCurrentTracker( this );
10878      }
10879      SectionTracker::SectionTracker( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
10880      :   TrackerBase( nameAndLocation, ctx, parent ),
10881          m_trimmed_name(trim(nameAndLocation.name))
10882      {
10883          if( parent ) {
10884              while( !parent-&gt;isSectionTracker() )
10885                  parent = &amp;parent-&gt;parent();
10886              SectionTracker&amp; parentSection = static_cast&lt;SectionTracker&amp;&gt;( *parent );
10887              addNextFilters( parentSection.m_filters );
10888          }
10889      }
10890      bool SectionTracker::isComplete() const {
10891          bool complete = true;
10892          if (m_filters.empty()
10893              || m_filters[0] == &quot;&quot;
10894              || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
10895              complete = TrackerBase::isComplete();
10896          }
10897          return complete;
10898      }
10899      bool SectionTracker::isSectionTracker() const { return true; }
10900      SectionTracker&amp; SectionTracker::acquire( TrackerContext&amp; ctx, NameAndLocation const&amp; nameAndLocation ) {
10901          std::shared_ptr&lt;SectionTracker&gt; section;
10902          ITracker&amp; currentTracker = ctx.currentTracker();
10903          if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
10904              assert( childTracker );
10905              assert( childTracker-&gt;isSectionTracker() );
10906              section = std::static_pointer_cast&lt;SectionTracker&gt;( childTracker );
10907          }
10908          else {
10909              section = std::make_shared&lt;SectionTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
10910              currentTracker.addChild( section );
10911          }
10912          if( !ctx.completedCycle() )
10913              section-&gt;tryOpen();
10914          return *section;
10915      }
10916      void SectionTracker::tryOpen() {
10917          if( !isComplete() )
10918              open();
10919      }
10920      void SectionTracker::addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10921          if( !filters.empty() ) {
10922              m_filters.reserve( m_filters.size() + filters.size() + 2 );
10923              m_filters.emplace_back(&quot;&quot;); 
10924              m_filters.emplace_back(&quot;&quot;); 
10925              m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
10926          }
10927      }
10928      void SectionTracker::addNextFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10929          if( filters.size() &gt; 1 )
10930              m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
10931      }
10932      std::vector&lt;std::string&gt; const&amp; SectionTracker::getFilters() const {
10933          return m_filters;
10934      }
10935      std::string const&amp; SectionTracker::trimmedName() const {
10936          return m_trimmed_name;
10937      }
10938  } 
10939  using TestCaseTracking::ITracker;
10940  using TestCaseTracking::TrackerContext;
10941  using TestCaseTracking::SectionTracker;
10942  } 
10943  #if defined(__clang__)
10944  #    pragma clang diagnostic pop
10945  #endif
10946  namespace Catch {
10947      auto makeTestInvoker( void(*testAsFunction)() ) noexcept -&gt; ITestInvoker* {
10948          return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
10949      }
10950      NameAndTags::NameAndTags( StringRef const&amp; name_ , StringRef const&amp; tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
10951      AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const&amp; lineInfo, StringRef const&amp; classOrMethod, NameAndTags const&amp; nameAndTags ) noexcept {
10952          CATCH_TRY {
10953              getMutableRegistryHub()
10954                      .registerTest(
10955                          makeTestCase(
10956                              invoker,
10957                              extractClassName( classOrMethod ),
10958                              nameAndTags,
10959                              lineInfo));
10960          } CATCH_CATCH_ALL {
10961              getMutableRegistryHub().registerStartupException();
10962          }
10963      }
10964      AutoReg::~AutoReg() = default;
10965  }
10966  #include &lt;algorithm&gt;
10967  #include &lt;string&gt;
10968  #include &lt;vector&gt;
10969  #include &lt;memory&gt;
10970  namespace Catch {
10971      TestSpec::Pattern::Pattern( std::string const&amp; name )
10972      : m_name( name )
10973      {}
10974      TestSpec::Pattern::~Pattern() = default;
10975      std::string const&amp; TestSpec::Pattern::name() const {
10976          return m_name;
10977      }
10978      TestSpec::NamePattern::NamePattern( std::string const&amp; name, std::string const&amp; filterString )
10979      : Pattern( filterString )
10980      , m_wildcardPattern( toLower( name ), CaseSensitive::No )
10981      {}
10982      bool TestSpec::NamePattern::matches( TestCaseInfo const&amp; testCase ) const {
10983          return m_wildcardPattern.matches( testCase.name );
10984      }
10985      TestSpec::TagPattern::TagPattern( std::string const&amp; tag, std::string const&amp; filterString )
10986      : Pattern( filterString )
10987      , m_tag( toLower( tag ) )
10988      {}
10989      bool TestSpec::TagPattern::matches( TestCaseInfo const&amp; testCase ) const {
10990          return std::find(begin(testCase.lcaseTags),
10991                           end(testCase.lcaseTags),
10992                           m_tag) != end(testCase.lcaseTags);
10993      }
10994      TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const&amp; underlyingPattern )
10995      : Pattern( underlyingPattern-&gt;name() )
10996      , m_underlyingPattern( underlyingPattern )
10997      {}
10998      bool TestSpec::ExcludedPattern::matches( TestCaseInfo const&amp; testCase ) const {
10999          return !m_underlyingPattern-&gt;matches( testCase );
11000      }
11001      bool TestSpec::Filter::matches( TestCaseInfo const&amp; testCase ) const {
11002          return std::all_of( m_patterns.begin(), m_patterns.end(), [&amp;]( PatternPtr const&amp; p ){ return p-&gt;matches( testCase ); } );
11003      }
11004      std::string TestSpec::Filter::name() const {
11005          std::string name;
11006          for( auto const&amp; p : m_patterns )
11007              name += p-&gt;name();
11008          return name;
11009      }
11010      bool TestSpec::hasFilters() const {
11011          return !m_filters.empty();
11012      }
11013      bool TestSpec::matches( TestCaseInfo const&amp; testCase ) const {
11014          return std::any_of( m_filters.begin(), m_filters.end(), [&amp;]( Filter const&amp; f ){ return f.matches( testCase ); } );
11015      }
11016      TestSpec::Matches TestSpec::matchesByFilter( std::vector&lt;TestCase&gt; const&amp; testCases, IConfig const&amp; config ) const
11017      {
11018          Matches matches( m_filters.size() );
11019          std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&amp;]( Filter const&amp; filter ){
11020              std::vector&lt;TestCase const*&gt; currentMatches;
11021              for( auto const&amp; test : testCases )
11022                  if( isThrowSafe( test, config ) &amp;&amp; filter.matches( test ) )
11023                      currentMatches.emplace_back( &amp;test );
11024              return FilterMatch{ filter.name(), currentMatches };
11025          } );
11026          return matches;
11027      }
11028      const TestSpec::vectorStrings&amp; TestSpec::getInvalidArgs() const{
11029          return  (m_invalidArgs);
11030      }
11031  }
11032  namespace Catch {
11033      TestSpecParser::TestSpecParser( ITagAliasRegistry const&amp; tagAliases ) : m_tagAliases( &amp;tagAliases ) {}
11034      TestSpecParser&amp; TestSpecParser::parse( std::string const&amp; arg ) {
11035          m_mode = None;
11036          m_exclusion = false;
11037          m_arg = m_tagAliases-&gt;expandAliases( arg );
11038          m_escapeChars.clear();
11039          m_substring.reserve(m_arg.size());
11040          m_patternName.reserve(m_arg.size());
11041          m_realPatternPos = 0;
11042          for( m_pos = 0; m_pos &lt; m_arg.size(); ++m_pos )
11043             if( !visitChar( m_arg[m_pos] ) ){
11044                 m_testSpec.m_invalidArgs.push_back(arg);
11045                 break;
11046             }
11047          endMode();
11048          return *this;
11049      }
11050      TestSpec TestSpecParser::testSpec() {
11051          addFilter();
11052          return m_testSpec;
11053      }
11054      bool TestSpecParser::visitChar( char c ) {
11055          if( (m_mode != EscapedName) &amp;&amp; (c == &#x27;\\&#x27;) ) {
11056              escape();
11057              addCharToPattern(c);
11058              return true;
11059          }else if((m_mode != EscapedName) &amp;&amp; (c == &#x27;,&#x27;) )  {
11060              return separate();
11061          }
11062          switch( m_mode ) {
11063          case None:
11064              if( processNoneChar( c ) )
11065                  return true;
11066              break;
11067          case Name:
11068              processNameChar( c );
11069              break;
11070          case EscapedName:
11071              endMode();
11072              addCharToPattern(c);
11073              return true;
11074          default:
11075          case Tag:
11076          case QuotedName:
11077              if( processOtherChar( c ) )
11078                  return true;
11079              break;
11080          }
11081          m_substring += c;
11082          if( !isControlChar( c ) ) {
11083              m_patternName += c;
11084              m_realPatternPos++;
11085          }
11086          return true;
11087      }
11088      bool TestSpecParser::processNoneChar( char c ) {
11089          switch( c ) {
11090          case &#x27; &#x27;:
11091              return true;
11092          case &#x27;~&#x27;:
11093              m_exclusion = true;
11094              return false;
11095          case &#x27;[&#x27;:
11096              startNewMode( Tag );
11097              return false;
11098          case &#x27;&quot;&#x27;:
11099              startNewMode( QuotedName );
11100              return false;
11101          default:
11102              startNewMode( Name );
11103              return false;
11104          }
11105      }
11106      void TestSpecParser::processNameChar( char c ) {
11107          if( c == &#x27;[&#x27; ) {
11108              if( m_substring == &quot;exclude:&quot; )
11109                  m_exclusion = true;
11110              else
11111                  endMode();
11112              startNewMode( Tag );
11113          }
11114      }
11115      bool TestSpecParser::processOtherChar( char c ) {
11116          if( !isControlChar( c ) )
11117              return false;
11118          m_substring += c;
11119          endMode();
11120          return true;
11121      }
11122      void TestSpecParser::startNewMode( Mode mode ) {
11123          m_mode = mode;
11124      }
11125      void TestSpecParser::endMode() {
11126          switch( m_mode ) {
11127          case Name:
11128          case QuotedName:
11129              return addNamePattern();
11130          case Tag:
11131              return addTagPattern();
11132          case EscapedName:
11133              revertBackToLastMode();
11134              return;
11135          case None:
11136          default:
11137              return startNewMode( None );
11138          }
11139      }
11140      void TestSpecParser::escape() {
11141          saveLastMode();
11142          m_mode = EscapedName;
11143          m_escapeChars.push_back(m_realPatternPos);
11144      }
11145      bool TestSpecParser::isControlChar( char c ) const {
11146          switch( m_mode ) {
11147              default:
11148                  return false;
11149              case None:
11150                  return c == &#x27;~&#x27;;
11151              case Name:
11152                  return c == &#x27;[&#x27;;
11153              case EscapedName:
11154                  return true;
11155              case QuotedName:
11156                  return c == &#x27;&quot;&#x27;;
11157              case Tag:
11158                  return c == &#x27;[&#x27; || c == &#x27;]&#x27;;
11159          }
11160      }
11161      void TestSpecParser::addFilter() {
11162          if( !m_currentFilter.m_patterns.empty() ) {
11163              m_testSpec.m_filters.push_back( m_currentFilter );
11164              m_currentFilter = TestSpec::Filter();
11165          }
11166      }
11167      void TestSpecParser::saveLastMode() {
11168        lastMode = m_mode;
11169      }
11170      void TestSpecParser::revertBackToLastMode() {
11171        m_mode = lastMode;
11172      }
11173      bool TestSpecParser::separate() {
11174        if( (m_mode==QuotedName) || (m_mode==Tag) ){
11175           m_mode = None;
11176           m_pos = m_arg.size();
11177           m_substring.clear();
11178           m_patternName.clear();
11179           m_realPatternPos = 0;
11180           return false;
11181        }
11182        endMode();
11183        addFilter();
11184        return true; 
11185      }
11186      std::string TestSpecParser::preprocessPattern() {
11187          std::string token = m_patternName;
11188          for (std::size_t i = 0; i &lt; m_escapeChars.size(); ++i)
11189              token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
11190          m_escapeChars.clear();
11191          if (startsWith(token, &quot;exclude:&quot;)) {
11192              m_exclusion = true;
11193              token = token.substr(8);
11194          }
11195          m_patternName.clear();
11196          m_realPatternPos = 0;
11197          return token;
11198      }
11199      void TestSpecParser::addNamePattern() {
11200          auto token = preprocessPattern();
11201          if (!token.empty()) {
11202              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::NamePattern&gt;(token, m_substring);
11203              if (m_exclusion)
11204                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11205              m_currentFilter.m_patterns.push_back(pattern);
11206          }
11207          m_substring.clear();
11208          m_exclusion = false;
11209          m_mode = None;
11210      }
11211      void TestSpecParser::addTagPattern() {
11212          auto token = preprocessPattern();
11213          if (!token.empty()) {
11214              if (token.size() &gt; 1 &amp;&amp; token[0] == &#x27;.&#x27;) {
11215                  token.erase(token.begin());
11216                  TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(&quot;.&quot;, m_substring);
11217                  if (m_exclusion) {
11218                      pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11219                  }
11220                  m_currentFilter.m_patterns.push_back(pattern);
11221              }
11222              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(token, m_substring);
11223              if (m_exclusion) {
11224                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11225              }
11226              m_currentFilter.m_patterns.push_back(pattern);
11227          }
11228          m_substring.clear();
11229          m_exclusion = false;
11230          m_mode = None;
11231      }
11232      TestSpec parseTestSpec( std::string const&amp; arg ) {
11233          return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
11234      }
11235  } 
11236  #include &lt;chrono&gt;
11237  static const uint64_t nanosecondsInSecond = 1000000000;
11238  namespace Catch {
11239      auto getCurrentNanosecondsSinceEpoch() -&gt; uint64_t {
11240          return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
11241      }
11242      namespace {
11243          auto estimateClockResolution() -&gt; uint64_t {
11244              uint64_t sum = 0;
11245              static const uint64_t iterations = 1000000;
11246              auto startTime = getCurrentNanosecondsSinceEpoch();
11247              for( std::size_t i = 0; i &lt; iterations; ++i ) {
11248                  uint64_t ticks;
11249                  uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
11250                  do {
11251                      ticks = getCurrentNanosecondsSinceEpoch();
11252                  } while( ticks == baseTicks );
11253                  auto delta = ticks - baseTicks;
11254                  sum += delta;
11255                  if (ticks &gt; startTime + 3 * nanosecondsInSecond) {
11256                      return sum / ( i + 1u );
11257                  }
11258              }
11259              return sum/iterations;
11260          }
11261      }
11262      auto getEstimatedClockResolution() -&gt; uint64_t {
11263          static auto s_resolution = estimateClockResolution();
11264          return s_resolution;
11265      }
11266      void Timer::start() {
11267         m_nanoseconds = getCurrentNanosecondsSinceEpoch();
11268      }
11269      auto Timer::getElapsedNanoseconds() const -&gt; uint64_t {
11270          return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
11271      }
11272      auto Timer::getElapsedMicroseconds() const -&gt; uint64_t {
11273          return getElapsedNanoseconds()/1000;
11274      }
11275      auto Timer::getElapsedMilliseconds() const -&gt; unsigned int {
11276          return static_cast&lt;unsigned int&gt;(getElapsedMicroseconds()/1000);
11277      }
11278      auto Timer::getElapsedSeconds() const -&gt; double {
11279          return getElapsedMicroseconds()/1000000.0;
11280      }
11281  } 
11282  #if defined(__clang__)
11283  #    pragma clang diagnostic push
11284  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
11285  #    pragma clang diagnostic ignored &quot;-Wglobal-constructors&quot;
11286  #endif
11287  #if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
11288  #define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
11289  #endif
11290  #include &lt;cmath&gt;
11291  #include &lt;iomanip&gt;
11292  namespace Catch {
11293  namespace Detail {
11294      const std::string unprintableString = &quot;{?}&quot;;
11295      namespace {
11296          const int hexThreshold = 255;
11297          struct Endianness {
11298              enum Arch { Big, Little };
11299              static Arch which() {
11300                  int one = 1;
11301                  auto value = *reinterpret_cast&lt;char*&gt;(&amp;one);
11302                  return value ? Little : Big;
11303              }
11304          };
11305      }
11306      std::string rawMemoryToString( const void *object, std::size_t size ) {
11307          int i = 0, end = static_cast&lt;int&gt;( size ), inc = 1;
11308          if( Endianness::which() == Endianness::Little ) {
11309              i = end-1;
11310              end = inc = -1;
11311          }
11312          unsigned char const *bytes = static_cast&lt;unsigned char const *&gt;(object);
11313          ReusableStringStream rss;
11314          rss &lt;&lt; &quot;0x&quot; &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::hex;
11315          for( ; i != end; i += inc )
11316               rss &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(bytes[i]);
11317         return rss.str();
11318      }
11319  }
11320  template&lt;typename T&gt;
11321  std::string fpToString( T value, int precision ) {
11322      if (Catch::isnan(value)) {
11323          return &quot;nan&quot;;
11324      }
11325      ReusableStringStream rss;
11326      rss &lt;&lt; std::setprecision( precision )
11327          &lt;&lt; std::fixed
11328          &lt;&lt; value;
11329      std::string d = rss.str();
11330      std::size_t i = d.find_last_not_of( &#x27;0&#x27; );
11331      if( i != std::string::npos &amp;&amp; i != d.size()-1 ) {
11332          if( d[i] == &#x27;.&#x27; )
11333              i++;
11334          d = d.substr( 0, i+1 );
11335      }
11336      return d;
11337  }
11338  std::string StringMaker&lt;std::string&gt;::convert(const std::string&amp; str) {
11339      if (!getCurrentContext().getConfig()-&gt;showInvisibles()) {
11340          return &#x27;&quot;&#x27; + str + &#x27;&quot;&#x27;;
11341      }
11342      std::string s(&quot;\&quot;&quot;);
11343      for (char c : str) {
11344          switch (c) {
11345          case &#x27;\n&#x27;:
11346              s.append(&quot;\\n&quot;);
11347              break;
11348          case &#x27;\t&#x27;:
11349              s.append(&quot;\\t&quot;);
11350              break;
11351          default:
11352              s.push_back(c);
11353              break;
11354          }
11355      }
11356      s.append(&quot;\&quot;&quot;);
11357      return s;
11358  }
11359  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11360  std::string StringMaker&lt;std::string_view&gt;::convert(std::string_view str) {
11361      return ::Catch::Detail::stringify(std::string{ str });
11362  }
11363  #endif
11364  std::string StringMaker&lt;char const*&gt;::convert(char const* str) {
11365      if (str) {
11366          return ::Catch::Detail::stringify(std::string{ str });
11367      } else {
11368          return{ &quot;{null string}&quot; };
11369      }
11370  }
11371  std::string StringMaker&lt;char*&gt;::convert(char* str) {
11372      if (str) {
11373          return ::Catch::Detail::stringify(std::string{ str });
11374      } else {
11375          return{ &quot;{null string}&quot; };
11376      }
11377  }
11378  #ifdef CATCH_CONFIG_WCHAR
11379  std::string StringMaker&lt;std::wstring&gt;::convert(const std::wstring&amp; wstr) {
11380      std::string s;
11381      s.reserve(wstr.size());
11382      for (auto c : wstr) {
11383          s += (c &lt;= 0xff) ? static_cast&lt;char&gt;(c) : &#x27;?&#x27;;
11384      }
11385      return ::Catch::Detail::stringify(s);
11386  }
11387  # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11388  std::string StringMaker&lt;std::wstring_view&gt;::convert(std::wstring_view str) {
11389      return StringMaker&lt;std::wstring&gt;::convert(std::wstring(str));
11390  }
11391  # endif
11392  std::string StringMaker&lt;wchar_t const*&gt;::convert(wchar_t const * str) {
11393      if (str) {
11394          return ::Catch::Detail::stringify(std::wstring{ str });
11395      } else {
11396          return{ &quot;{null string}&quot; };
11397      }
11398  }
11399  std::string StringMaker&lt;wchar_t *&gt;::convert(wchar_t * str) {
11400      if (str) {
11401          return ::Catch::Detail::stringify(std::wstring{ str });
11402      } else {
11403          return{ &quot;{null string}&quot; };
11404      }
11405  }
11406  #endif
11407  #if defined(CATCH_CONFIG_CPP17_BYTE)
11408  #include &lt;cstddef&gt;
11409  std::string StringMaker&lt;std::byte&gt;::convert(std::byte value) {
11410      return ::Catch::Detail::stringify(std::to_integer&lt;unsigned long long&gt;(value));
11411  }
11412  #endif 
11413  std::string StringMaker&lt;int&gt;::convert(int value) {
11414      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11415  }
11416  std::string StringMaker&lt;long&gt;::convert(long value) {
11417      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11418  }
11419  std::string StringMaker&lt;long long&gt;::convert(long long value) {
11420      ReusableStringStream rss;
11421      rss &lt;&lt; value;
11422      if (value &gt; Detail::hexThreshold) {
11423          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11424      }
11425      return rss.str();
11426  }
11427  std::string StringMaker&lt;unsigned int&gt;::convert(unsigned int value) {
11428      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11429  }
11430  std::string StringMaker&lt;unsigned long&gt;::convert(unsigned long value) {
11431      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11432  }
11433  std::string StringMaker&lt;unsigned long long&gt;::convert(unsigned long long value) {
11434      ReusableStringStream rss;
11435      rss &lt;&lt; value;
11436      if (value &gt; Detail::hexThreshold) {
11437          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11438      }
11439      return rss.str();
11440  }
11441  std::string StringMaker&lt;bool&gt;::convert(bool b) {
11442      return b ? &quot;true&quot; : &quot;false&quot;;
11443  }
11444  std::string StringMaker&lt;signed char&gt;::convert(signed char value) {
11445      if (value == &#x27;\r&#x27;) {
11446          return &quot;&#x27;\\r&#x27;&quot;;
11447      } else if (value == &#x27;\f&#x27;) {
11448          return &quot;&#x27;\\f&#x27;&quot;;
11449      } else if (value == &#x27;\n&#x27;) {
11450          return &quot;&#x27;\\n&#x27;&quot;;
11451      } else if (value == &#x27;\t&#x27;) {
11452          return &quot;&#x27;\\t&#x27;&quot;;
11453      } else if (&#x27;\0&#x27; &lt;= value &amp;&amp; value &lt; &#x27; &#x27;) {
11454          return ::Catch::Detail::stringify(static_cast&lt;unsigned int&gt;(value));
11455      } else {
11456          char chstr[] = &quot;&#x27; &#x27;&quot;;
11457          chstr[1] = value;
11458          return chstr;
11459      }
11460  }
11461  std::string StringMaker&lt;char&gt;::convert(char c) {
11462      return ::Catch::Detail::stringify(static_cast&lt;signed char&gt;(c));
11463  }
11464  std::string StringMaker&lt;unsigned char&gt;::convert(unsigned char c) {
11465      return ::Catch::Detail::stringify(static_cast&lt;char&gt;(c));
11466  }
11467  std::string StringMaker&lt;std::nullptr_t&gt;::convert(std::nullptr_t) {
11468      return &quot;nullptr&quot;;
11469  }
11470  int StringMaker&lt;float&gt;::precision = 5;
11471  std::string StringMaker&lt;float&gt;::convert(float value) {
11472      return fpToString(value, precision) + &#x27;f&#x27;;
11473  }
11474  int StringMaker&lt;double&gt;::precision = 10;
11475  std::string StringMaker&lt;double&gt;::convert(double value) {
11476      return fpToString(value, precision);
11477  }
11478  std::string ratio_string&lt;std::atto&gt;::symbol() { return &quot;a&quot;; }
11479  std::string ratio_string&lt;std::femto&gt;::symbol() { return &quot;f&quot;; }
11480  std::string ratio_string&lt;std::pico&gt;::symbol() { return &quot;p&quot;; }
11481  std::string ratio_string&lt;std::nano&gt;::symbol() { return &quot;n&quot;; }
11482  std::string ratio_string&lt;std::micro&gt;::symbol() { return &quot;u&quot;; }
11483  std::string ratio_string&lt;std::milli&gt;::symbol() { return &quot;m&quot;; }
11484  } 
11485  #if defined(__clang__)
11486  #    pragma clang diagnostic pop
11487  #endif
11488  namespace Catch {
11489      Counts Counts::operator - ( Counts const&amp; other ) const {
11490          Counts diff;
11491          diff.passed = passed - other.passed;
11492          diff.failed = failed - other.failed;
11493          diff.failedButOk = failedButOk - other.failedButOk;
11494          return diff;
11495      }
11496      Counts&amp; Counts::operator += ( Counts const&amp; other ) {
11497          passed += other.passed;
11498          failed += other.failed;
11499          failedButOk += other.failedButOk;
11500          return *this;
11501      }
11502      std::size_t Counts::total() const {
11503          return passed + failed + failedButOk;
11504      }
11505      bool Counts::allPassed() const {
11506          return failed == 0 &amp;&amp; failedButOk == 0;
11507      }
11508      bool Counts::allOk() const {
11509          return failed == 0;
11510      }
11511      Totals Totals::operator - ( Totals const&amp; other ) const {
11512          Totals diff;
11513          diff.assertions = assertions - other.assertions;
11514          diff.testCases = testCases - other.testCases;
11515          return diff;
11516      }
11517      Totals&amp; Totals::operator += ( Totals const&amp; other ) {
11518          assertions += other.assertions;
11519          testCases += other.testCases;
11520          return *this;
11521      }
11522      Totals Totals::delta( Totals const&amp; prevTotals ) const {
11523          Totals diff = *this - prevTotals;
11524          if( diff.assertions.failed &gt; 0 )
11525              ++diff.testCases.failed;
11526          else if( diff.assertions.failedButOk &gt; 0 )
11527              ++diff.testCases.failedButOk;
11528          else
11529              ++diff.testCases.passed;
11530          return diff;
11531      }
11532  }
11533  #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11534  #define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11535  #if defined(_MSC_VER)
11536  #  if _MSC_VER &gt;= 1900 
11537  #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11538  #  endif
11539  #endif
11540  #include &lt;exception&gt;
11541  #if defined(__cpp_lib_uncaught_exceptions) \
11542      &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11543  #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11544  #endif 
11545  #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \
11546      &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \
11547      &amp;&amp; !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11548  #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11549  #endif
11550  #endif 
11551  #include &lt;exception&gt;
11552  namespace Catch {
11553      bool uncaught_exceptions() {
11554  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
11555          return false;
11556  #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11557          return std::uncaught_exceptions() &gt; 0;
11558  #else
11559          return std::uncaught_exception();
11560  #endif
11561    }
11562  } 
11563  #include &lt;ostream&gt;
11564  namespace Catch {
11565      Version::Version
11566          (   unsigned int _majorVersion,
11567              unsigned int _minorVersion,
11568              unsigned int _patchNumber,
11569              char const * const _branchName,
11570              unsigned int _buildNumber )
11571      :   majorVersion( _majorVersion ),
11572          minorVersion( _minorVersion ),
11573          patchNumber( _patchNumber ),
11574          branchName( _branchName ),
11575          buildNumber( _buildNumber )
11576      {}
11577      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version ) {
11578          os  &lt;&lt; version.majorVersion &lt;&lt; &#x27;.&#x27;
11579              &lt;&lt; version.minorVersion &lt;&lt; &#x27;.&#x27;
11580              &lt;&lt; version.patchNumber;
11581          if (version.branchName[0]) {
11582              os &lt;&lt; &#x27;-&#x27; &lt;&lt; version.branchName
11583                 &lt;&lt; &#x27;.&#x27; &lt;&lt; version.buildNumber;
11584          }
11585          return os;
11586      }
11587      Version const&amp; libraryVersion() {
11588          static Version version( 2, 13, 7, &quot;&quot;, 0 );
11589          return version;
11590      }
11591  }
11592  namespace Catch {
11593      WildcardPattern::WildcardPattern( std::string const&amp; pattern,
11594                                        CaseSensitive::Choice caseSensitivity )
11595      :   m_caseSensitivity( caseSensitivity ),
11596          m_pattern( normaliseString( pattern ) )
11597      {
11598          if( startsWith( m_pattern, &#x27;*&#x27; ) ) {
11599              m_pattern = m_pattern.substr( 1 );
11600              m_wildcard = WildcardAtStart;
11601          }
11602          if( endsWith( m_pattern, &#x27;*&#x27; ) ) {
11603              m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
11604              m_wildcard = static_cast&lt;WildcardPosition&gt;( m_wildcard | WildcardAtEnd );
11605          }
11606      }
11607      bool WildcardPattern::matches( std::string const&amp; str ) const {
11608          switch( m_wildcard ) {
11609              case NoWildcard:
11610                  return m_pattern == normaliseString( str );
11611              case WildcardAtStart:
11612                  return endsWith( normaliseString( str ), m_pattern );
11613              case WildcardAtEnd:
11614                  return startsWith( normaliseString( str ), m_pattern );
11615              case WildcardAtBothEnds:
11616                  return contains( normaliseString( str ), m_pattern );
11617              default:
11618                  CATCH_INTERNAL_ERROR( &quot;Unknown enum&quot; );
11619          }
11620      }
11621      std::string WildcardPattern::normaliseString( std::string const&amp; str ) const {
11622          return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
11623      }
11624  }
11625  #include &lt;iomanip&gt;
11626  #include &lt;type_traits&gt;
11627  namespace Catch {
11628  namespace {
11629      size_t trailingBytes(unsigned char c) {
11630          if ((c &amp; 0xE0) == 0xC0) {
11631              return 2;
11632          }
11633          if ((c &amp; 0xF0) == 0xE0) {
11634              return 3;
11635          }
11636          if ((c &amp; 0xF8) == 0xF0) {
11637              return 4;
11638          }
11639          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11640      }
11641      uint32_t headerValue(unsigned char c) {
11642          if ((c &amp; 0xE0) == 0xC0) {
11643              return c &amp; 0x1F;
11644          }
11645          if ((c &amp; 0xF0) == 0xE0) {
11646              return c &amp; 0x0F;
11647          }
11648          if ((c &amp; 0xF8) == 0xF0) {
11649              return c &amp; 0x07;
11650          }
11651          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11652      }
11653      void hexEscapeChar(std::ostream&amp; os, unsigned char c) {
11654          std::ios_base::fmtflags f(os.flags());
11655          os &lt;&lt; &quot;\\x&quot;
11656              &lt;&lt; std::uppercase &lt;&lt; std::hex &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(2)
11657              &lt;&lt; static_cast&lt;int&gt;(c);
11658          os.flags(f);
11659      }
11660      bool shouldNewline(XmlFormatting fmt) {
11661          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Newline));
11662      }
11663      bool shouldIndent(XmlFormatting fmt) {
11664          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Indent));
11665      }
11666  } 
11667      XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
11668          return static_cast&lt;XmlFormatting&gt;(
11669              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) |
11670              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11671          );
11672      }
11673      XmlFormatting operator &amp; (XmlFormatting lhs, XmlFormatting rhs) {
11674          return static_cast&lt;XmlFormatting&gt;(
11675              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) &amp;
11676              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11677          );
11678      }
11679      XmlEncode::XmlEncode( std::string const&amp; str, ForWhat forWhat )
11680      :   m_str( str ),
11681          m_forWhat( forWhat )
11682      {}
11683      void XmlEncode::encodeTo( std::ostream&amp; os ) const {
11684          for( std::size_t idx = 0; idx &lt; m_str.size(); ++ idx ) {
11685              unsigned char c = m_str[idx];
11686              switch (c) {
11687              case &#x27;&lt;&#x27;:   os &lt;&lt; &quot;&amp;lt;&quot;; break;
11688              case &#x27;&amp;&#x27;:   os &lt;&lt; &quot;&amp;amp;&quot;; break;
11689              case &#x27;&gt;&#x27;:
11690                  if (idx &gt; 2 &amp;&amp; m_str[idx - 1] == &#x27;]&#x27; &amp;&amp; m_str[idx - 2] == &#x27;]&#x27;)
11691                      os &lt;&lt; &quot;&amp;gt;&quot;;
11692                  else
11693                      os &lt;&lt; c;
11694                  break;
11695              case &#x27;\&quot;&#x27;:
11696                  if (m_forWhat == ForAttributes)
11697                      os &lt;&lt; &quot;&amp;quot;&quot;;
11698                  else
11699                      os &lt;&lt; c;
11700                  break;
11701              default:
11702                  if (c &lt; 0x09 || (c &gt; 0x0D &amp;&amp; c &lt; 0x20) || c == 0x7F) {
11703                      hexEscapeChar(os, c);
11704                      break;
11705                  }
11706                  if (c &lt; 0x7F) {
11707                      os &lt;&lt; c;
11708                      break;
11709                  }
11710                  if (c &lt;  0xC0 ||
11711                      c &gt;= 0xF8) {
11712                      hexEscapeChar(os, c);
11713                      break;
11714                  }
11715                  auto encBytes = trailingBytes(c);
11716                  if (idx + encBytes - 1 &gt;= m_str.size()) {
11717                      hexEscapeChar(os, c);
11718                      break;
11719                  }
11720                  bool valid = true;
11721                  uint32_t value = headerValue(c);
11722                  for (std::size_t n = 1; n &lt; encBytes; ++n) {
11723                      unsigned char nc = m_str[idx + n];
11724                      valid &amp;= ((nc &amp; 0xC0) == 0x80);
11725                      value = (value &lt;&lt; 6) | (nc &amp; 0x3F);
11726                  }
11727                  if (
11728                      (!valid) ||
11729                      (value &lt; 0x80) ||
11730                      (0x80 &lt;= value &amp;&amp; value &lt; 0x800   &amp;&amp; encBytes &gt; 2) ||
11731                      (0x800 &lt; value &amp;&amp; value &lt; 0x10000 &amp;&amp; encBytes &gt; 3) ||
11732                      (value &gt;= 0x110000)
11733                      ) {
11734                      hexEscapeChar(os, c);
11735                      break;
11736                  }
11737                  for (std::size_t n = 0; n &lt; encBytes; ++n) {
11738                      os &lt;&lt; m_str[idx + n];
11739                  }
11740                  idx += encBytes - 1;
11741                  break;
11742              }
11743          }
11744      }
11745      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode ) {
11746          xmlEncode.encodeTo( os );
11747          return os;
11748      }
11749      XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
11750      :   m_writer( writer ),
11751          m_fmt(fmt)
11752      {}
11753      XmlWriter::ScopedElement::ScopedElement( ScopedElement&amp;&amp; other ) noexcept
11754      :   m_writer( other.m_writer ),
11755          m_fmt(other.m_fmt)
11756      {
11757          other.m_writer = nullptr;
11758          other.m_fmt = XmlFormatting::None;
11759      }
11760      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::operator=( ScopedElement&amp;&amp; other ) noexcept {
11761          if ( m_writer ) {
11762              m_writer-&gt;endElement();
11763          }
11764          m_writer = other.m_writer;
11765          other.m_writer = nullptr;
11766          m_fmt = other.m_fmt;
11767          other.m_fmt = XmlFormatting::None;
11768          return *this;
11769      }
11770      XmlWriter::ScopedElement::~ScopedElement() {
11771          if (m_writer) {
11772              m_writer-&gt;endElement(m_fmt);
11773          }
11774      }
11775      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::writeText( std::string const&amp; text, XmlFormatting fmt ) {
11776          m_writer-&gt;writeText( text, fmt );
11777          return *this;
11778      }
11779      XmlWriter::XmlWriter( std::ostream&amp; os ) : m_os( os )
11780      {
11781          writeDeclaration();
11782      }
11783      XmlWriter::~XmlWriter() {
11784          while (!m_tags.empty()) {
11785              endElement();
11786          }
11787          newlineIfNecessary();
11788      }
11789      XmlWriter&amp; XmlWriter::startElement( std::string const&amp; name, XmlFormatting fmt ) {
11790          ensureTagClosed();
11791          newlineIfNecessary();
11792          if (shouldIndent(fmt)) {
11793              m_os &lt;&lt; m_indent;
11794              m_indent += &quot;  &quot;;
11795          }
11796          m_os &lt;&lt; &#x27;&lt;&#x27; &lt;&lt; name;
11797          m_tags.push_back( name );
11798          m_tagIsOpen = true;
11799          applyFormatting(fmt);
11800          return *this;
11801      }
11802      XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const&amp; name, XmlFormatting fmt ) {
11803          ScopedElement scoped( this, fmt );
11804          startElement( name, fmt );
11805          return scoped;
11806      }
11807      XmlWriter&amp; XmlWriter::endElement(XmlFormatting fmt) {
11808          m_indent = m_indent.substr(0, m_indent.size() - 2);
11809          if( m_tagIsOpen ) {
11810              m_os &lt;&lt; &quot;/&gt;&quot;;
11811              m_tagIsOpen = false;
11812          } else {
11813              newlineIfNecessary();
11814              if (shouldIndent(fmt)) {
11815                  m_os &lt;&lt; m_indent;
11816              }
11817              m_os &lt;&lt; &quot;&lt;/&quot; &lt;&lt; m_tags.back() &lt;&lt; &quot;&gt;&quot;;
11818          }
11819          m_os &lt;&lt; std::flush;
11820          applyFormatting(fmt);
11821          m_tags.pop_back();
11822          return *this;
11823      }
11824      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, std::string const&amp; attribute ) {
11825          if( !name.empty() &amp;&amp; !attribute.empty() )
11826              m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; XmlEncode( attribute, XmlEncode::ForAttributes ) &lt;&lt; &#x27;&quot;&#x27;;
11827          return *this;
11828      }
11829      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, bool attribute ) {
11830          m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; ( attribute ? &quot;true&quot; : &quot;false&quot; ) &lt;&lt; &#x27;&quot;&#x27;;
11831          return *this;
11832      }
11833      XmlWriter&amp; XmlWriter::writeText( std::string const&amp; text, XmlFormatting fmt) {
11834          if( !text.empty() ){
11835              bool tagWasOpen = m_tagIsOpen;
11836              ensureTagClosed();
11837              if (tagWasOpen &amp;&amp; shouldIndent(fmt)) {
11838                  m_os &lt;&lt; m_indent;
11839              }
11840              m_os &lt;&lt; XmlEncode( text );
11841              applyFormatting(fmt);
11842          }
11843          return *this;
11844      }
11845      XmlWriter&amp; XmlWriter::writeComment( std::string const&amp; text, XmlFormatting fmt) {
11846          ensureTagClosed();
11847          if (shouldIndent(fmt)) {
11848              m_os &lt;&lt; m_indent;
11849          }
11850          m_os &lt;&lt; &quot;&lt;!--&quot; &lt;&lt; text &lt;&lt; &quot;--&gt;&quot;;
11851          applyFormatting(fmt);
11852          return *this;
11853      }
11854      void XmlWriter::writeStylesheetRef( std::string const&amp; url ) {
11855          m_os &lt;&lt; &quot;&lt;?xml-stylesheet type=\&quot;text/xsl\&quot; href=\&quot;&quot; &lt;&lt; url &lt;&lt; &quot;\&quot;?&gt;\n&quot;;
11856      }
11857      XmlWriter&amp; XmlWriter::writeBlankLine() {
11858          ensureTagClosed();
11859          m_os &lt;&lt; &#x27;\n&#x27;;
11860          return *this;
11861      }
11862      void XmlWriter::ensureTagClosed() {
11863          if( m_tagIsOpen ) {
11864              m_os &lt;&lt; &#x27;&gt;&#x27; &lt;&lt; std::flush;
11865              newlineIfNecessary();
11866              m_tagIsOpen = false;
11867          }
11868      }
11869      void XmlWriter::applyFormatting(XmlFormatting fmt) {
11870          m_needsNewline = shouldNewline(fmt);
11871      }
11872      void XmlWriter::writeDeclaration() {
11873          m_os &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;
11874      }
11875      void XmlWriter::newlineIfNecessary() {
11876          if( m_needsNewline ) {
11877              m_os &lt;&lt; std::endl;
11878              m_needsNewline = false;
11879          }
11880      }
11881  }
11882  #include &lt;cstring&gt;
11883  #include &lt;cfloat&gt;
11884  #include &lt;cstdio&gt;
11885  #include &lt;cassert&gt;
11886  #include &lt;memory&gt;
11887  namespace Catch {
11888      void prepareExpandedExpression(AssertionResult&amp; result) {
11889          result.getExpandedExpression();
11890      }
11891      std::string getFormattedDuration( double duration ) {
11892          const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
11893          char buffer[maxDoubleSize];
11894          ErrnoGuard guard;
11895  #ifdef _MSC_VER
11896          sprintf_s(buffer, &quot;%.3f&quot;, duration);
11897  #else
11898          std::sprintf(buffer, &quot;%.3f&quot;, duration);
11899  #endif
11900          return std::string(buffer);
11901      }
11902      bool shouldShowDuration( IConfig const&amp; config, double duration ) {
11903          if ( config.showDurations() == ShowDurations::Always ) {
11904              return true;
11905          }
11906          if ( config.showDurations() == ShowDurations::Never ) {
11907              return false;
11908          }
11909          const double min = config.minDuration();
11910          return min &gt;= 0 &amp;&amp; duration &gt;= min;
11911      }
11912      std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; container ) {
11913          ReusableStringStream oss;
11914          bool first = true;
11915          for (auto&amp;&amp; filter : container)
11916          {
11917              if (!first)
11918                  oss &lt;&lt; &#x27; &#x27;;
11919              else
11920                  first = false;
11921              oss &lt;&lt; filter;
11922          }
11923          return oss.str();
11924      }
11925      TestEventListenerBase::TestEventListenerBase(ReporterConfig const &amp; _config)
11926          :StreamingReporterBase(_config) {}
11927      std::set&lt;Verbosity&gt; TestEventListenerBase::getSupportedVerbosities() {
11928          return { Verbosity::Quiet, Verbosity::Normal, Verbosity::High };
11929      }
11930      void TestEventListenerBase::assertionStarting(AssertionInfo const &amp;) {}
11931      bool TestEventListenerBase::assertionEnded(AssertionStats const &amp;) {
11932          return false;
11933      }
11934  } 
11935  namespace {
11936  #ifdef CATCH_PLATFORM_MAC
11937      const char* failedString() { return &quot;FAILED&quot;; }
11938      const char* passedString() { return &quot;PASSED&quot;; }
11939  #else
11940      const char* failedString() { return &quot;failed&quot;; }
11941      const char* passedString() { return &quot;passed&quot;; }
11942  #endif
11943      Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
11944      std::string bothOrAll( std::size_t count ) {
11945          return count == 1 ? std::string() :
11946                 count == 2 ? &quot;both &quot; : &quot;all &quot; ;
11947      }
11948  } 
11949  namespace Catch {
11950  namespace {
11951  void printTotals(std::ostream&amp; out, const Totals&amp; totals) {
11952      if (totals.testCases.total() == 0) {
11953          out &lt;&lt; &quot;No tests ran.&quot;;
11954      } else if (totals.testCases.failed == totals.testCases.total()) {
11955          Colour colour(Colour::ResultError);
11956          const std::string qualify_assertions_failed =
11957              totals.assertions.failed == totals.assertions.total() ?
11958              bothOrAll(totals.assertions.failed) : std::string();
11959          out &lt;&lt;
11960              &quot;Failed &quot; &lt;&lt; bothOrAll(totals.testCases.failed)
11961              &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11962              &quot;failed &quot; &lt;&lt; qualify_assertions_failed &lt;&lt;
11963              pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11964      } else if (totals.assertions.total() == 0) {
11965          out &lt;&lt;
11966              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.total())
11967              &lt;&lt; pluralise(totals.testCases.total(), &quot;test case&quot;)
11968              &lt;&lt; &quot; (no assertions).&quot;;
11969      } else if (totals.assertions.failed) {
11970          Colour colour(Colour::ResultError);
11971          out &lt;&lt;
11972              &quot;Failed &quot; &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11973              &quot;failed &quot; &lt;&lt; pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11974      } else {
11975          Colour colour(Colour::ResultSuccess);
11976          out &lt;&lt;
11977              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.passed)
11978              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt;
11979              &quot; with &quot; &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11980      }
11981  }
11982  class AssertionPrinter {
11983  public:
11984      AssertionPrinter&amp; operator= (AssertionPrinter const&amp;) = delete;
11985      AssertionPrinter(AssertionPrinter const&amp;) = delete;
11986      AssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
11987          : stream(_stream)
11988          , result(_stats.assertionResult)
11989          , messages(_stats.infoMessages)
11990          , itMessage(_stats.infoMessages.begin())
11991          , printInfoMessages(_printInfoMessages) {}
11992      void print() {
11993          printSourceInfo();
11994          itMessage = messages.begin();
11995          switch (result.getResultType()) {
11996          case ResultWas::Ok:
11997              printResultType(Colour::ResultSuccess, passedString());
11998              printOriginalExpression();
11999              printReconstructedExpression();
12000              if (!result.hasExpression())
12001                  printRemainingMessages(Colour::None);
12002              else
12003                  printRemainingMessages();
12004              break;
12005          case ResultWas::ExpressionFailed:
12006              if (result.isOk())
12007                  printResultType(Colour::ResultSuccess, failedString() + std::string(&quot; - but was ok&quot;));
12008              else
12009                  printResultType(Colour::Error, failedString());
12010              printOriginalExpression();
12011              printReconstructedExpression();
12012              printRemainingMessages();
12013              break;
12014          case ResultWas::ThrewException:
12015              printResultType(Colour::Error, failedString());
12016              printIssue(&quot;unexpected exception with message:&quot;);
12017              printMessage();
12018              printExpressionWas();
12019              printRemainingMessages();
12020              break;
12021          case ResultWas::FatalErrorCondition:
12022              printResultType(Colour::Error, failedString());
12023              printIssue(&quot;fatal error condition with message:&quot;);
12024              printMessage();
12025              printExpressionWas();
12026              printRemainingMessages();
12027              break;
12028          case ResultWas::DidntThrowException:
12029              printResultType(Colour::Error, failedString());
12030              printIssue(&quot;expected exception, got none&quot;);
12031              printExpressionWas();
12032              printRemainingMessages();
12033              break;
12034          case ResultWas::Info:
12035              printResultType(Colour::None, &quot;info&quot;);
12036              printMessage();
12037              printRemainingMessages();
12038              break;
12039          case ResultWas::Warning:
12040              printResultType(Colour::None, &quot;warning&quot;);
12041              printMessage();
12042              printRemainingMessages();
12043              break;
12044          case ResultWas::ExplicitFailure:
12045              printResultType(Colour::Error, failedString());
12046              printIssue(&quot;explicitly&quot;);
12047              printRemainingMessages(Colour::None);
12048              break;
12049          case ResultWas::Unknown:
12050          case ResultWas::FailureBit:
12051          case ResultWas::Exception:
12052              printResultType(Colour::Error, &quot;** internal error **&quot;);
12053              break;
12054          }
12055      }
12056  private:
12057      void printSourceInfo() const {
12058          Colour colourGuard(Colour::FileName);
12059          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &#x27;:&#x27;;
12060      }
12061      void printResultType(Colour::Code colour, std::string const&amp; passOrFail) const {
12062          if (!passOrFail.empty()) {
12063              {
12064                  Colour colourGuard(colour);
12065                  stream &lt;&lt; &#x27; &#x27; &lt;&lt; passOrFail;
12066              }
12067              stream &lt;&lt; &#x27;:&#x27;;
12068          }
12069      }
12070      void printIssue(std::string const&amp; issue) const {
12071          stream &lt;&lt; &#x27; &#x27; &lt;&lt; issue;
12072      }
12073      void printExpressionWas() {
12074          if (result.hasExpression()) {
12075              stream &lt;&lt; &#x27;;&#x27;;
12076              {
12077                  Colour colour(dimColour());
12078                  stream &lt;&lt; &quot; expression was:&quot;;
12079              }
12080              printOriginalExpression();
12081          }
12082      }
12083      void printOriginalExpression() const {
12084          if (result.hasExpression()) {
12085              stream &lt;&lt; &#x27; &#x27; &lt;&lt; result.getExpression();
12086          }
12087      }
12088      void printReconstructedExpression() const {
12089          if (result.hasExpandedExpression()) {
12090              {
12091                  Colour colour(dimColour());
12092                  stream &lt;&lt; &quot; for: &quot;;
12093              }
12094              stream &lt;&lt; result.getExpandedExpression();
12095          }
12096      }
12097      void printMessage() {
12098          if (itMessage != messages.end()) {
12099              stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; itMessage-&gt;message &lt;&lt; &#x27;\&#x27;&#x27;;
12100              ++itMessage;
12101          }
12102      }
12103      void printRemainingMessages(Colour::Code colour = dimColour()) {
12104          if (itMessage == messages.end())
12105              return;
12106          const auto itEnd = messages.cend();
12107          const auto N = static_cast&lt;std::size_t&gt;(std::distance(itMessage, itEnd));
12108          {
12109              Colour colourGuard(colour);
12110              stream &lt;&lt; &quot; with &quot; &lt;&lt; pluralise(N, &quot;message&quot;) &lt;&lt; &#x27;:&#x27;;
12111          }
12112          while (itMessage != itEnd) {
12113              if (printInfoMessages || itMessage-&gt;type != ResultWas::Info) {
12114                  printMessage();
12115                  if (itMessage != itEnd) {
12116                      Colour colourGuard(dimColour());
12117                      stream &lt;&lt; &quot; and&quot;;
12118                  }
12119                  continue;
12120              }
12121              ++itMessage;
12122          }
12123      }
12124  private:
12125      std::ostream&amp; stream;
12126      AssertionResult const&amp; result;
12127      std::vector&lt;MessageInfo&gt; messages;
12128      std::vector&lt;MessageInfo&gt;::const_iterator itMessage;
12129      bool printInfoMessages;
12130  };
12131  } 
12132          std::string CompactReporter::getDescription() {
12133              return &quot;Reports test results on a single line, suitable for IDEs&quot;;
12134          }
12135          void CompactReporter::noMatchingTestCases( std::string const&amp; spec ) {
12136              stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12137          }
12138          void CompactReporter::assertionStarting( AssertionInfo const&amp; ) {}
12139          bool CompactReporter::assertionEnded( AssertionStats const&amp; _assertionStats ) {
12140              AssertionResult const&amp; result = _assertionStats.assertionResult;
12141              bool printInfoMessages = true;
12142              if( !m_config-&gt;includeSuccessfulResults() &amp;&amp; result.isOk() ) {
12143                  if( result.getResultType() != ResultWas::Warning )
12144                      return false;
12145                  printInfoMessages = false;
12146              }
12147              AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
12148              printer.print();
12149              stream &lt;&lt; std::endl;
12150              return true;
12151          }
12152          void CompactReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12153              double dur = _sectionStats.durationInSeconds;
12154              if ( shouldShowDuration( *m_config, dur ) ) {
12155                  stream &lt;&lt; getFormattedDuration( dur ) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12156              }
12157          }
12158          void CompactReporter::testRunEnded( TestRunStats const&amp; _testRunStats ) {
12159              printTotals( stream, _testRunStats.totals );
12160              stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12161              StreamingReporterBase::testRunEnded( _testRunStats );
12162          }
12163          CompactReporter::~CompactReporter() {}
12164      CATCH_REGISTER_REPORTER( &quot;compact&quot;, CompactReporter )
12165  } 
12166  #include &lt;cfloat&gt;
12167  #include &lt;cstdio&gt;
12168  #if defined(_MSC_VER)
12169  #pragma warning(push)
12170  #pragma warning(disable:4061) 
12171  #endif
12172  #if defined(__clang__)
12173  #  pragma clang diagnostic push
12174  #  pragma clang diagnostic ignored &quot;-Wunused-function&quot;
12175  #endif
12176  namespace Catch {
12177  namespace {
12178  class ConsoleAssertionPrinter {
12179  public:
12180      ConsoleAssertionPrinter&amp; operator= (ConsoleAssertionPrinter const&amp;) = delete;
12181      ConsoleAssertionPrinter(ConsoleAssertionPrinter const&amp;) = delete;
12182      ConsoleAssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
12183          : stream(_stream),
12184          stats(_stats),
12185          result(_stats.assertionResult),
12186          colour(Colour::None),
12187          message(result.getMessage()),
12188          messages(_stats.infoMessages),
12189          printInfoMessages(_printInfoMessages) {
12190          switch (result.getResultType()) {
12191          case ResultWas::Ok:
12192              colour = Colour::Success;
12193              passOrFail = &quot;PASSED&quot;;
12194              if (_stats.infoMessages.size() == 1)
12195                  messageLabel = &quot;with message&quot;;
12196              if (_stats.infoMessages.size() &gt; 1)
12197                  messageLabel = &quot;with messages&quot;;
12198              break;
12199          case ResultWas::ExpressionFailed:
12200              if (result.isOk()) {
12201                  colour = Colour::Success;
12202                  passOrFail = &quot;FAILED - but was ok&quot;;
12203              } else {
12204                  colour = Colour::Error;
12205                  passOrFail = &quot;FAILED&quot;;
12206              }
12207              if (_stats.infoMessages.size() == 1)
12208                  messageLabel = &quot;with message&quot;;
12209              if (_stats.infoMessages.size() &gt; 1)
12210                  messageLabel = &quot;with messages&quot;;
12211              break;
12212          case ResultWas::ThrewException:
12213              colour = Colour::Error;
12214              passOrFail = &quot;FAILED&quot;;
12215              messageLabel = &quot;due to unexpected exception with &quot;;
12216              if (_stats.infoMessages.size() == 1)
12217                  messageLabel += &quot;message&quot;;
12218              if (_stats.infoMessages.size() &gt; 1)
12219                  messageLabel += &quot;messages&quot;;
12220              break;
12221          case ResultWas::FatalErrorCondition:
12222              colour = Colour::Error;
12223              passOrFail = &quot;FAILED&quot;;
12224              messageLabel = &quot;due to a fatal error condition&quot;;
12225              break;
12226          case ResultWas::DidntThrowException:
12227              colour = Colour::Error;
12228              passOrFail = &quot;FAILED&quot;;
12229              messageLabel = &quot;because no exception was thrown where one was expected&quot;;
12230              break;
12231          case ResultWas::Info:
12232              messageLabel = &quot;info&quot;;
12233              break;
12234          case ResultWas::Warning:
12235              messageLabel = &quot;warning&quot;;
12236              break;
12237          case ResultWas::ExplicitFailure:
12238              passOrFail = &quot;FAILED&quot;;
12239              colour = Colour::Error;
12240              if (_stats.infoMessages.size() == 1)
12241                  messageLabel = &quot;explicitly with message&quot;;
12242              if (_stats.infoMessages.size() &gt; 1)
12243                  messageLabel = &quot;explicitly with messages&quot;;
12244              break;
12245          case ResultWas::Unknown:
12246          case ResultWas::FailureBit:
12247          case ResultWas::Exception:
12248              passOrFail = &quot;** internal error **&quot;;
12249              colour = Colour::Error;
12250              break;
12251          }
12252      }
12253      void print() const {
12254          printSourceInfo();
12255          if (stats.totals.assertions.total() &gt; 0) {
12256              printResultType();
12257              printOriginalExpression();
12258              printReconstructedExpression();
12259          } else {
12260              stream &lt;&lt; &#x27;\n&#x27;;
12261          }
12262          printMessage();
12263      }
12264  private:
12265      void printResultType() const {
12266          if (!passOrFail.empty()) {
12267              Colour colourGuard(colour);
12268              stream &lt;&lt; passOrFail &lt;&lt; &quot;:\n&quot;;
12269          }
12270      }
12271      void printOriginalExpression() const {
12272          if (result.hasExpression()) {
12273              Colour colourGuard(Colour::OriginalExpression);
12274              stream &lt;&lt; &quot;  &quot;;
12275              stream &lt;&lt; result.getExpressionInMacro();
12276              stream &lt;&lt; &#x27;\n&#x27;;
12277          }
12278      }
12279      void printReconstructedExpression() const {
12280          if (result.hasExpandedExpression()) {
12281              stream &lt;&lt; &quot;with expansion:\n&quot;;
12282              Colour colourGuard(Colour::ReconstructedExpression);
12283              stream &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12284          }
12285      }
12286      void printMessage() const {
12287          if (!messageLabel.empty())
12288              stream &lt;&lt; messageLabel &lt;&lt; &#x27;:&#x27; &lt;&lt; &#x27;\n&#x27;;
12289          for (auto const&amp; msg : messages) {
12290              if (printInfoMessages || msg.type != ResultWas::Info)
12291                  stream &lt;&lt; Column(msg.message).indent(2) &lt;&lt; &#x27;\n&#x27;;
12292          }
12293      }
12294      void printSourceInfo() const {
12295          Colour colourGuard(Colour::FileName);
12296          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &quot;: &quot;;
12297      }
12298      std::ostream&amp; stream;
12299      AssertionStats const&amp; stats;
12300      AssertionResult const&amp; result;
12301      Colour::Code colour;
12302      std::string passOrFail;
12303      std::string messageLabel;
12304      std::string message;
12305      std::vector&lt;MessageInfo&gt; messages;
12306      bool printInfoMessages;
12307  };
12308  std::size_t makeRatio(std::size_t number, std::size_t total) {
12309      std::size_t ratio = total &gt; 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
12310      return (ratio == 0 &amp;&amp; number &gt; 0) ? 1 : ratio;
12311  }
12312  std::size_t&amp; findMax(std::size_t&amp; i, std::size_t&amp; j, std::size_t&amp; k) {
12313      if (i &gt; j &amp;&amp; i &gt; k)
12314          return i;
12315      else if (j &gt; k)
12316          return j;
12317      else
12318          return k;
12319  }
12320  struct ColumnInfo {
12321      enum Justification { Left, Right };
12322      std::string name;
12323      int width;
12324      Justification justification;
12325  };
12326  struct ColumnBreak {};
12327  struct RowBreak {};
12328  class Duration {
12329      enum class Unit {
12330          Auto,
12331          Nanoseconds,
12332          Microseconds,
12333          Milliseconds,
12334          Seconds,
12335          Minutes
12336      };
12337      static const uint64_t s_nanosecondsInAMicrosecond = 1000;
12338      static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
12339      static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
12340      static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
12341      double m_inNanoseconds;
12342      Unit m_units;
12343  public:
12344      explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
12345          : m_inNanoseconds(inNanoseconds),
12346          m_units(units) {
12347          if (m_units == Unit::Auto) {
12348              if (m_inNanoseconds &lt; s_nanosecondsInAMicrosecond)
12349                  m_units = Unit::Nanoseconds;
12350              else if (m_inNanoseconds &lt; s_nanosecondsInAMillisecond)
12351                  m_units = Unit::Microseconds;
12352              else if (m_inNanoseconds &lt; s_nanosecondsInASecond)
12353                  m_units = Unit::Milliseconds;
12354              else if (m_inNanoseconds &lt; s_nanosecondsInAMinute)
12355                  m_units = Unit::Seconds;
12356              else
12357                  m_units = Unit::Minutes;
12358          }
12359      }
12360      auto value() const -&gt; double {
12361          switch (m_units) {
12362          case Unit::Microseconds:
12363              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMicrosecond);
12364          case Unit::Milliseconds:
12365              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMillisecond);
12366          case Unit::Seconds:
12367              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInASecond);
12368          case Unit::Minutes:
12369              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMinute);
12370          default:
12371              return m_inNanoseconds;
12372          }
12373      }
12374      auto unitsAsString() const -&gt; std::string {
12375          switch (m_units) {
12376          case Unit::Nanoseconds:
12377              return &quot;ns&quot;;
12378          case Unit::Microseconds:
12379              return &quot;us&quot;;
12380          case Unit::Milliseconds:
12381              return &quot;ms&quot;;
12382          case Unit::Seconds:
12383              return &quot;s&quot;;
12384          case Unit::Minutes:
12385              return &quot;m&quot;;
12386          default:
12387              return &quot;** internal error **&quot;;
12388          }
12389      }
12390      friend auto operator &lt;&lt; (std::ostream&amp; os, Duration const&amp; duration) -&gt; std::ostream&amp; {
12391          return os &lt;&lt; duration.value() &lt;&lt; &#x27; &#x27; &lt;&lt; duration.unitsAsString();
12392      }
12393  };
12394  } 
12395  class TablePrinter {
12396      std::ostream&amp; m_os;
12397      std::vector&lt;ColumnInfo&gt; m_columnInfos;
12398      std::ostringstream m_oss;
12399      int m_currentColumn = -1;
12400      bool m_isOpen = false;
12401  public:
12402      TablePrinter( std::ostream&amp; os, std::vector&lt;ColumnInfo&gt; columnInfos )
12403      :   m_os( os ),
12404          m_columnInfos( std::move( columnInfos ) ) {}
12405      auto columnInfos() const -&gt; std::vector&lt;ColumnInfo&gt; const&amp; {
12406          return m_columnInfos;
12407      }
12408      void open() {
12409          if (!m_isOpen) {
12410              m_isOpen = true;
12411              *this &lt;&lt; RowBreak();
12412  			Columns headerCols;
12413  			Spacer spacer(2);
12414  			for (auto const&amp; info : m_columnInfos) {
12415  				headerCols += Column(info.name).width(static_cast&lt;std::size_t&gt;(info.width - 2));
12416  				headerCols += spacer;
12417  			}
12418  			m_os &lt;&lt; headerCols &lt;&lt; &#x27;\n&#x27;;
12419              m_os &lt;&lt; Catch::getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12420          }
12421      }
12422      void close() {
12423          if (m_isOpen) {
12424              *this &lt;&lt; RowBreak();
12425              m_os &lt;&lt; std::endl;
12426              m_isOpen = false;
12427          }
12428      }
12429      template&lt;typename T&gt;
12430      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, T const&amp; value) {
12431          tp.m_oss &lt;&lt; value;
12432          return tp;
12433      }
12434      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, ColumnBreak) {
12435          auto colStr = tp.m_oss.str();
12436          const auto strSize = colStr.size();
12437          tp.m_oss.str(&quot;&quot;);
12438          tp.open();
12439          if (tp.m_currentColumn == static_cast&lt;int&gt;(tp.m_columnInfos.size() - 1)) {
12440              tp.m_currentColumn = -1;
12441              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12442          }
12443          tp.m_currentColumn++;
12444          auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
12445          auto padding = (strSize + 1 &lt; static_cast&lt;std::size_t&gt;(colInfo.width))
12446              ? std::string(colInfo.width - (strSize + 1), &#x27; &#x27;)
12447              : std::string();
12448          if (colInfo.justification == ColumnInfo::Left)
12449              tp.m_os &lt;&lt; colStr &lt;&lt; padding &lt;&lt; &#x27; &#x27;;
12450          else
12451              tp.m_os &lt;&lt; padding &lt;&lt; colStr &lt;&lt; &#x27; &#x27;;
12452          return tp;
12453      }
12454      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, RowBreak) {
12455          if (tp.m_currentColumn &gt; 0) {
12456              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12457              tp.m_currentColumn = -1;
12458          }
12459          return tp;
12460      }
12461  };
12462  ConsoleReporter::ConsoleReporter(ReporterConfig const&amp; config)
12463      : StreamingReporterBase(config),
12464      m_tablePrinter(new TablePrinter(config.stream(),
12465          [&amp;config]() -&gt; std::vector&lt;ColumnInfo&gt; {
12466          if (config.fullConfig()-&gt;benchmarkNoAnalysis())
12467          {
12468              return{
12469                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12470                  { &quot;     samples&quot;, 14, ColumnInfo::Right },
12471                  { &quot;  iterations&quot;, 14, ColumnInfo::Right },
12472                  { &quot;        mean&quot;, 14, ColumnInfo::Right }
12473              };
12474          }
12475          else
12476          {
12477              return{
12478                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12479                  { &quot;samples      mean       std dev&quot;, 14, ColumnInfo::Right },
12480                  { &quot;iterations   low mean   low std dev&quot;, 14, ColumnInfo::Right },
12481                  { &quot;estimated    high mean  high std dev&quot;, 14, ColumnInfo::Right }
12482              };
12483          }
12484      }())) {}
12485  ConsoleReporter::~ConsoleReporter() = default;
12486  std::string ConsoleReporter::getDescription() {
12487      return &quot;Reports test results as plain lines of text&quot;;
12488  }
12489  void ConsoleReporter::noMatchingTestCases(std::string const&amp; spec) {
12490      stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12491  }
12492  void ConsoleReporter::reportInvalidArguments(std::string const&amp;arg){
12493      stream &lt;&lt; &quot;Invalid Filter: &quot; &lt;&lt; arg &lt;&lt; std::endl;
12494  }
12495  void ConsoleReporter::assertionStarting(AssertionInfo const&amp;) {}
12496  bool ConsoleReporter::assertionEnded(AssertionStats const&amp; _assertionStats) {
12497      AssertionResult const&amp; result = _assertionStats.assertionResult;
12498      bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
12499      if (!includeResults &amp;&amp; result.getResultType() != ResultWas::Warning)
12500          return false;
12501      lazyPrint();
12502      ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
12503      printer.print();
12504      stream &lt;&lt; std::endl;
12505      return true;
12506  }
12507  void ConsoleReporter::sectionStarting(SectionInfo const&amp; _sectionInfo) {
12508      m_tablePrinter-&gt;close();
12509      m_headerPrinted = false;
12510      StreamingReporterBase::sectionStarting(_sectionInfo);
12511  }
12512  void ConsoleReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12513      m_tablePrinter-&gt;close();
12514      if (_sectionStats.missingAssertions) {
12515          lazyPrint();
12516          Colour colour(Colour::ResultError);
12517          if (m_sectionStack.size() &gt; 1)
12518              stream &lt;&lt; &quot;\nNo assertions in section&quot;;
12519          else
12520              stream &lt;&lt; &quot;\nNo assertions in test case&quot;;
12521          stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; &quot;&#x27;\n&quot; &lt;&lt; std::endl;
12522      }
12523      double dur = _sectionStats.durationInSeconds;
12524      if (shouldShowDuration(*m_config, dur)) {
12525          stream &lt;&lt; getFormattedDuration(dur) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12526      }
12527      if (m_headerPrinted) {
12528          m_headerPrinted = false;
12529      }
12530      StreamingReporterBase::sectionEnded(_sectionStats);
12531  }
12532  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
12533  void ConsoleReporter::benchmarkPreparing(std::string const&amp; name) {
12534  	lazyPrintWithoutClosingBenchmarkTable();
12535  	auto nameCol = Column(name).width(static_cast&lt;std::size_t&gt;(m_tablePrinter-&gt;columnInfos()[0].width - 2));
12536  	bool firstLine = true;
12537  	for (auto line : nameCol) {
12538  		if (!firstLine)
12539  			(*m_tablePrinter) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12540  		else
12541  			firstLine = false;
12542  		(*m_tablePrinter) &lt;&lt; line &lt;&lt; ColumnBreak();
12543  	}
12544  }
12545  void ConsoleReporter::benchmarkStarting(BenchmarkInfo const&amp; info) {
12546      (*m_tablePrinter) &lt;&lt; info.samples &lt;&lt; ColumnBreak()
12547          &lt;&lt; info.iterations &lt;&lt; ColumnBreak();
12548      if (!m_config-&gt;benchmarkNoAnalysis())
12549          (*m_tablePrinter) &lt;&lt; Duration(info.estimatedDuration) &lt;&lt; ColumnBreak();
12550  }
12551  void ConsoleReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) {
12552      if (m_config-&gt;benchmarkNoAnalysis())
12553      {
12554          (*m_tablePrinter) &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak();
12555      }
12556      else
12557      {
12558          (*m_tablePrinter) &lt;&lt; ColumnBreak()
12559              &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak()
12560              &lt;&lt; Duration(stats.mean.lower_bound.count()) &lt;&lt; ColumnBreak()
12561              &lt;&lt; Duration(stats.mean.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak()
12562              &lt;&lt; Duration(stats.standardDeviation.point.count()) &lt;&lt; ColumnBreak()
12563              &lt;&lt; Duration(stats.standardDeviation.lower_bound.count()) &lt;&lt; ColumnBreak()
12564              &lt;&lt; Duration(stats.standardDeviation.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12565      }
12566  }
12567  void ConsoleReporter::benchmarkFailed(std::string const&amp; error) {
12568  	Colour colour(Colour::Red);
12569      (*m_tablePrinter)
12570          &lt;&lt; &quot;Benchmark failed (&quot; &lt;&lt; error &lt;&lt; &#x27;)&#x27;
12571          &lt;&lt; ColumnBreak() &lt;&lt; RowBreak();
12572  }
12573  #endif 
12574  void ConsoleReporter::testCaseEnded(TestCaseStats const&amp; _testCaseStats) {
12575      m_tablePrinter-&gt;close();
12576      StreamingReporterBase::testCaseEnded(_testCaseStats);
12577      m_headerPrinted = false;
12578  }
12579  void ConsoleReporter::testGroupEnded(TestGroupStats const&amp; _testGroupStats) {
12580      if (currentGroupInfo.used) {
12581          printSummaryDivider();
12582          stream &lt;&lt; &quot;Summary for group &#x27;&quot; &lt;&lt; _testGroupStats.groupInfo.name &lt;&lt; &quot;&#x27;:\n&quot;;
12583          printTotals(_testGroupStats.totals);
12584          stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12585      }
12586      StreamingReporterBase::testGroupEnded(_testGroupStats);
12587  }
12588  void ConsoleReporter::testRunEnded(TestRunStats const&amp; _testRunStats) {
12589      printTotalsDivider(_testRunStats.totals);
12590      printTotals(_testRunStats.totals);
12591      stream &lt;&lt; std::endl;
12592      StreamingReporterBase::testRunEnded(_testRunStats);
12593  }
12594  void ConsoleReporter::testRunStarting(TestRunInfo const&amp; _testInfo) {
12595      StreamingReporterBase::testRunStarting(_testInfo);
12596      printTestFilters();
12597  }
12598  void ConsoleReporter::lazyPrint() {
12599      m_tablePrinter-&gt;close();
12600      lazyPrintWithoutClosingBenchmarkTable();
12601  }
12602  void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
12603      if (!currentTestRunInfo.used)
12604          lazyPrintRunInfo();
12605      if (!currentGroupInfo.used)
12606          lazyPrintGroupInfo();
12607      if (!m_headerPrinted) {
12608          printTestCaseAndSectionHeader();
12609          m_headerPrinted = true;
12610      }
12611  }
12612  void ConsoleReporter::lazyPrintRunInfo() {
12613      stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; getLineOfChars&lt;&#x27;~&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12614      Colour colour(Colour::SecondaryText);
12615      stream &lt;&lt; currentTestRunInfo-&gt;name
12616          &lt;&lt; &quot; is a Catch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot; host application.\n&quot;
12617          &lt;&lt; &quot;Run with -? for options\n\n&quot;;
12618      if (m_config-&gt;rngSeed() != 0)
12619          stream &lt;&lt; &quot;Randomness seeded to: &quot; &lt;&lt; m_config-&gt;rngSeed() &lt;&lt; &quot;\n\n&quot;;
12620      currentTestRunInfo.used = true;
12621  }
12622  void ConsoleReporter::lazyPrintGroupInfo() {
12623      if (!currentGroupInfo-&gt;name.empty() &amp;&amp; currentGroupInfo-&gt;groupsCounts &gt; 1) {
12624          printClosedHeader(&quot;Group: &quot; + currentGroupInfo-&gt;name);
12625          currentGroupInfo.used = true;
12626      }
12627  }
12628  void ConsoleReporter::printTestCaseAndSectionHeader() {
12629      assert(!m_sectionStack.empty());
12630      printOpenHeader(currentTestCaseInfo-&gt;name);
12631      if (m_sectionStack.size() &gt; 1) {
12632          Colour colourGuard(Colour::Headers);
12633          auto
12634              it = m_sectionStack.begin() + 1, 
12635              itEnd = m_sectionStack.end();
12636          for (; it != itEnd; ++it)
12637              printHeaderString(it-&gt;name, 2);
12638      }
12639      SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
12640      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12641      Colour colourGuard(Colour::FileName);
12642      stream &lt;&lt; lineInfo &lt;&lt; &#x27;\n&#x27;;
12643      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12644  }
12645  void ConsoleReporter::printClosedHeader(std::string const&amp; _name) {
12646      printOpenHeader(_name);
12647      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12648  }
12649  void ConsoleReporter::printOpenHeader(std::string const&amp; _name) {
12650      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12651      {
12652          Colour colourGuard(Colour::Headers);
12653          printHeaderString(_name);
12654      }
12655  }
12656  void ConsoleReporter::printHeaderString(std::string const&amp; _string, std::size_t indent) {
12657      std::size_t i = _string.find(&quot;: &quot;);
12658      if (i != std::string::npos)
12659          i += 2;
12660      else
12661          i = 0;
12662      stream &lt;&lt; Column(_string).indent(indent + i).initialIndent(indent) &lt;&lt; &#x27;\n&#x27;;
12663  }
12664  struct SummaryColumn {
12665      SummaryColumn( std::string _label, Colour::Code _colour )
12666      :   label( std::move( _label ) ),
12667          colour( _colour ) {}
12668      SummaryColumn addRow( std::size_t count ) {
12669          ReusableStringStream rss;
12670          rss &lt;&lt; count;
12671          std::string row = rss.str();
12672          for (auto&amp; oldRow : rows) {
12673              while (oldRow.size() &lt; row.size())
12674                  oldRow = &#x27; &#x27; + oldRow;
12675              while (oldRow.size() &gt; row.size())
12676                  row = &#x27; &#x27; + row;
12677          }
12678          rows.push_back(row);
12679          return *this;
12680      }
12681      std::string label;
12682      Colour::Code colour;
12683      std::vector&lt;std::string&gt; rows;
12684  };
12685  void ConsoleReporter::printTotals( Totals const&amp; totals ) {
12686      if (totals.testCases.total() == 0) {
12687          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;No tests ran\n&quot;;
12688      } else if (totals.assertions.total() &gt; 0 &amp;&amp; totals.testCases.allPassed()) {
12689          stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; &quot;All tests passed&quot;;
12690          stream &lt;&lt; &quot; (&quot;
12691              &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &quot; in &quot;
12692              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt; &#x27;)&#x27;
12693              &lt;&lt; &#x27;\n&#x27;;
12694      } else {
12695          std::vector&lt;SummaryColumn&gt; columns;
12696          columns.push_back(SummaryColumn(&quot;&quot;, Colour::None)
12697                            .addRow(totals.testCases.total())
12698                            .addRow(totals.assertions.total()));
12699          columns.push_back(SummaryColumn(&quot;passed&quot;, Colour::Success)
12700                            .addRow(totals.testCases.passed)
12701                            .addRow(totals.assertions.passed));
12702          columns.push_back(SummaryColumn(&quot;failed&quot;, Colour::ResultError)
12703                            .addRow(totals.testCases.failed)
12704                            .addRow(totals.assertions.failed));
12705          columns.push_back(SummaryColumn(&quot;failed as expected&quot;, Colour::ResultExpectedFailure)
12706                            .addRow(totals.testCases.failedButOk)
12707                            .addRow(totals.assertions.failedButOk));
12708          printSummaryRow(&quot;test cases&quot;, columns, 0);
12709          printSummaryRow(&quot;assertions&quot;, columns, 1);
12710      }
12711  }
12712  void ConsoleReporter::printSummaryRow(std::string const&amp; label, std::vector&lt;SummaryColumn&gt; const&amp; cols, std::size_t row) {
12713      for (auto col : cols) {
12714          std::string value = col.rows[row];
12715          if (col.label.empty()) {
12716              stream &lt;&lt; label &lt;&lt; &quot;: &quot;;
12717              if (value != &quot;0&quot;)
12718                  stream &lt;&lt; value;
12719              else
12720                  stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;- none -&quot;;
12721          } else if (value != &quot;0&quot;) {
12722              stream &lt;&lt; Colour(Colour::LightGrey) &lt;&lt; &quot; | &quot;;
12723              stream &lt;&lt; Colour(col.colour)
12724                  &lt;&lt; value &lt;&lt; &#x27; &#x27; &lt;&lt; col.label;
12725          }
12726      }
12727      stream &lt;&lt; &#x27;\n&#x27;;
12728  }
12729  void ConsoleReporter::printTotalsDivider(Totals const&amp; totals) {
12730      if (totals.testCases.total() &gt; 0) {
12731          std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
12732          std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
12733          std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
12734          while (failedRatio + failedButOkRatio + passedRatio &lt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12735              findMax(failedRatio, failedButOkRatio, passedRatio)++;
12736          while (failedRatio + failedButOkRatio + passedRatio &gt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12737              findMax(failedRatio, failedButOkRatio, passedRatio)--;
12738          stream &lt;&lt; Colour(Colour::Error) &lt;&lt; std::string(failedRatio, &#x27;=&#x27;);
12739          stream &lt;&lt; Colour(Colour::ResultExpectedFailure) &lt;&lt; std::string(failedButOkRatio, &#x27;=&#x27;);
12740          if (totals.testCases.allPassed())
12741              stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12742          else
12743              stream &lt;&lt; Colour(Colour::Success) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12744      } else {
12745          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, &#x27;=&#x27;);
12746      }
12747      stream &lt;&lt; &#x27;\n&#x27;;
12748  }
12749  void ConsoleReporter::printSummaryDivider() {
12750      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12751  }
12752  void ConsoleReporter::printTestFilters() {
12753      if (m_config-&gt;testSpec().hasFilters()) {
12754          Colour guard(Colour::BrightYellow);
12755          stream &lt;&lt; &quot;Filters: &quot; &lt;&lt; serializeFilters(m_config-&gt;getTestsOrTags()) &lt;&lt; &#x27;\n&#x27;;
12756      }
12757  }
12758  CATCH_REGISTER_REPORTER(&quot;console&quot;, ConsoleReporter)
12759  } 
12760  #if defined(_MSC_VER)
12761  #pragma warning(pop)
12762  #endif
12763  #if defined(__clang__)
12764  #  pragma clang diagnostic pop
12765  #endif
12766  #include &lt;cassert&gt;
12767  #include &lt;sstream&gt;
12768  #include &lt;ctime&gt;
12769  #include &lt;algorithm&gt;
12770  #include &lt;iomanip&gt;
12771  namespace Catch {
12772      namespace {
12773          std::string getCurrentTimestamp() {
12774              time_t rawtime;
12775              std::time(&amp;rawtime);
12776              auto const timeStampSize = sizeof(&quot;2017-01-16T17:06:45Z&quot;);
12777  #ifdef _MSC_VER
12778              std::tm timeInfo = {};
12779              gmtime_s(&amp;timeInfo, &amp;rawtime);
12780  #else
12781              std::tm* timeInfo;
12782              timeInfo = std::gmtime(&amp;rawtime);
12783  #endif
12784              char timeStamp[timeStampSize];
12785              const char * const fmt = &quot;%Y-%m-%dT%H:%M:%SZ&quot;;
12786  #ifdef _MSC_VER
12787              std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
12788  #else
12789              std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
12790  #endif
12791              return std::string(timeStamp, timeStampSize-1);
12792          }
12793          std::string fileNameTag(const std::vector&lt;std::string&gt; &amp;tags) {
12794              auto it = std::find_if(begin(tags),
12795                                     end(tags),
12796                                     [] (std::string const&amp; tag) {return tag.front() == &#x27;#&#x27;; });
12797              if (it != tags.end())
12798                  return it-&gt;substr(1);
12799              return std::string();
12800          }
12801          std::string formatDuration( double seconds ) {
12802              ReusableStringStream rss;
12803              rss &lt;&lt; std::fixed &lt;&lt; std::setprecision( 3 ) &lt;&lt; seconds;
12804              return rss.str();
12805          }
12806      } 
12807      JunitReporter::JunitReporter( ReporterConfig const&amp; _config )
12808          :   CumulativeReporterBase( _config ),
12809              xml( _config.stream() )
12810          {
12811              m_reporterPrefs.shouldRedirectStdOut = true;
12812              m_reporterPrefs.shouldReportAllAssertions = true;
12813          }
12814      JunitReporter::~JunitReporter() {}
12815      std::string JunitReporter::getDescription() {
12816          return &quot;Reports test results in an XML format that looks like Ant&#x27;s junitreport target&quot;;
12817      }
12818      void JunitReporter::noMatchingTestCases( std::string const&amp; &amp;bsol;*spec*/ ) {}
12819      void JunitReporter::testRunStarting( TestRunInfo const&amp; runInfo )  {
12820          CumulativeReporterBase::testRunStarting( runInfo );
12821          xml.startElement( &quot;testsuites&quot; );
12822      }
12823      void JunitReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
12824          suiteTimer.start();
12825          stdOutForSuite.clear();
12826          stdErrForSuite.clear();
12827          unexpectedExceptions = 0;
12828          CumulativeReporterBase::testGroupStarting( groupInfo );
12829      }
12830      void JunitReporter::testCaseStarting( TestCaseInfo const&amp; testCaseInfo ) {
12831          m_okToFail = testCaseInfo.okToFail();
12832      }
12833      bool JunitReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
12834          if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException &amp;&amp; !m_okToFail )
12835              unexpectedExceptions++;
12836          return CumulativeReporterBase::assertionEnded( assertionStats );
12837      }
12838      void JunitReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
12839          stdOutForSuite += testCaseStats.stdOut;
12840          stdErrForSuite += testCaseStats.stdErr;
12841          CumulativeReporterBase::testCaseEnded( testCaseStats );
12842      }
12843      void JunitReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
12844          double suiteTime = suiteTimer.getElapsedSeconds();
12845          CumulativeReporterBase::testGroupEnded( testGroupStats );
12846          writeGroup( *m_testGroups.back(), suiteTime );
12847      }
12848      void JunitReporter::testRunEndedCumulative() {
12849          xml.endElement();
12850      }
12851      void JunitReporter::writeGroup( TestGroupNode const&amp; groupNode, double suiteTime ) {
12852          XmlWriter::ScopedElement e = xml.scopedElement( &quot;testsuite&quot; );
12853          TestGroupStats const&amp; stats = groupNode.value;
12854          xml.writeAttribute( &quot;name&quot;, stats.groupInfo.name );
12855          xml.writeAttribute( &quot;errors&quot;, unexpectedExceptions );
12856          xml.writeAttribute( &quot;failures&quot;, stats.totals.assertions.failed-unexpectedExceptions );
12857          xml.writeAttribute( &quot;tests&quot;, stats.totals.assertions.total() );
12858          xml.writeAttribute( &quot;hostname&quot;, &quot;tbd&quot; ); 
12859          if( m_config-&gt;showDurations() == ShowDurations::Never )
12860              xml.writeAttribute( &quot;time&quot;, &quot;&quot; );
12861          else
12862              xml.writeAttribute( &quot;time&quot;, formatDuration( suiteTime ) );
12863          xml.writeAttribute( &quot;timestamp&quot;, getCurrentTimestamp() );
12864          if (m_config-&gt;hasTestFilters() || m_config-&gt;rngSeed() != 0) {
12865              auto properties = xml.scopedElement(&quot;properties&quot;);
12866              if (m_config-&gt;hasTestFilters()) {
12867                  xml.scopedElement(&quot;property&quot;)
12868                      .writeAttribute(&quot;name&quot;, &quot;filters&quot;)
12869                      .writeAttribute(&quot;value&quot;, serializeFilters(m_config-&gt;getTestsOrTags()));
12870              }
12871              if (m_config-&gt;rngSeed() != 0) {
12872                  xml.scopedElement(&quot;property&quot;)
12873                      .writeAttribute(&quot;name&quot;, &quot;random-seed&quot;)
12874                      .writeAttribute(&quot;value&quot;, m_config-&gt;rngSeed());
12875              }
12876          }
12877          for( auto const&amp; child : groupNode.children )
12878              writeTestCase( *child );
12879          xml.scopedElement( &quot;system-out&quot; ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
12880          xml.scopedElement( &quot;system-err&quot; ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
12881      }
12882      void JunitReporter::writeTestCase( TestCaseNode const&amp; testCaseNode ) {
12883          TestCaseStats const&amp; stats = testCaseNode.value;
12884          assert( testCaseNode.children.size() == 1 );
12885          SectionNode const&amp; rootSection = *testCaseNode.children.front();
12886          std::string className = stats.testInfo.className;
12887          if( className.empty() ) {
12888              className = fileNameTag(stats.testInfo.tags);
12889              if ( className.empty() )
12890                  className = &quot;global&quot;;
12891          }
12892          if ( !m_config-&gt;name().empty() )
12893              className = m_config-&gt;name() + &quot;.&quot; + className;
12894          writeSection( className, &quot;&quot;, rootSection, stats.testInfo.okToFail() );
12895      }
12896      void JunitReporter::writeSection( std::string const&amp; className,
12897                                        std::string const&amp; rootName,
12898                                        SectionNode const&amp; sectionNode,
12899                                        bool testOkToFail) {
12900          std::string name = trim( sectionNode.stats.sectionInfo.name );
12901          if( !rootName.empty() )
12902              name = rootName + &#x27;/&#x27; + name;
12903          if( !sectionNode.assertions.empty() ||
12904              !sectionNode.stdOut.empty() ||
12905              !sectionNode.stdErr.empty() ) {
12906              XmlWriter::ScopedElement e = xml.scopedElement( &quot;testcase&quot; );
12907              if( className.empty() ) {
12908                  xml.writeAttribute( &quot;classname&quot;, name );
12909                  xml.writeAttribute( &quot;name&quot;, &quot;root&quot; );
12910              }
12911              else {
12912                  xml.writeAttribute( &quot;classname&quot;, className );
12913                  xml.writeAttribute( &quot;name&quot;, name );
12914              }
12915              xml.writeAttribute( &quot;time&quot;, formatDuration( sectionNode.stats.durationInSeconds ) );
12916              xml.writeAttribute( &quot;status&quot;, &quot;run&quot; );
12917              if (sectionNode.stats.assertions.failedButOk) {
12918                  xml.scopedElement(&quot;skipped&quot;)
12919                      .writeAttribute(&quot;message&quot;, &quot;TEST_CASE tagged with !mayfail&quot;);
12920              }
12921              writeAssertions( sectionNode );
12922              if( !sectionNode.stdOut.empty() )
12923                  xml.scopedElement( &quot;system-out&quot; ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
12924              if( !sectionNode.stdErr.empty() )
12925                  xml.scopedElement( &quot;system-err&quot; ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
12926          }
12927          for( auto const&amp; childNode : sectionNode.childSections )
12928              if( className.empty() )
12929                  writeSection( name, &quot;&quot;, *childNode, testOkToFail );
12930              else
12931                  writeSection( className, name, *childNode, testOkToFail );
12932      }
12933      void JunitReporter::writeAssertions( SectionNode const&amp; sectionNode ) {
12934          for( auto const&amp; assertion : sectionNode.assertions )
12935              writeAssertion( assertion );
12936      }
12937      void JunitReporter::writeAssertion( AssertionStats const&amp; stats ) {
12938          AssertionResult const&amp; result = stats.assertionResult;
12939          if( !result.isOk() ) {
12940              std::string elementName;
12941              switch( result.getResultType() ) {
12942                  case ResultWas::ThrewException:
12943                  case ResultWas::FatalErrorCondition:
12944                      elementName = &quot;error&quot;;
12945                      break;
12946                  case ResultWas::ExplicitFailure:
12947                  case ResultWas::ExpressionFailed:
12948                  case ResultWas::DidntThrowException:
12949                      elementName = &quot;failure&quot;;
12950                      break;
12951                  case ResultWas::Info:
12952                  case ResultWas::Warning:
12953                  case ResultWas::Ok:
12954                  case ResultWas::Unknown:
12955                  case ResultWas::FailureBit:
12956                  case ResultWas::Exception:
12957                      elementName = &quot;internalError&quot;;
12958                      break;
12959              }
12960              XmlWriter::ScopedElement e = xml.scopedElement( elementName );
12961              xml.writeAttribute( &quot;message&quot;, result.getExpression() );
12962              xml.writeAttribute( &quot;type&quot;, result.getTestMacroName() );
12963              ReusableStringStream rss;
12964              if (stats.totals.assertions.total() &gt; 0) {
12965                  rss &lt;&lt; &quot;FAILED&quot; &lt;&lt; &quot;:\n&quot;;
12966                  if (result.hasExpression()) {
12967                      rss &lt;&lt; &quot;  &quot;;
12968                      rss &lt;&lt; result.getExpressionInMacro();
12969                      rss &lt;&lt; &#x27;\n&#x27;;
12970                  }
12971                  if (result.hasExpandedExpression()) {
12972                      rss &lt;&lt; &quot;with expansion:\n&quot;;
12973                      rss &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12974                  }
12975              } else {
12976                  rss &lt;&lt; &#x27;\n&#x27;;
12977              }
12978              if( !result.getMessage().empty() )
12979                  rss &lt;&lt; result.getMessage() &lt;&lt; &#x27;\n&#x27;;
12980              for( auto const&amp; msg : stats.infoMessages )
12981                  if( msg.type == ResultWas::Info )
12982                      rss &lt;&lt; msg.message &lt;&lt; &#x27;\n&#x27;;
12983              rss &lt;&lt; &quot;at &quot; &lt;&lt; result.getSourceInfo();
12984              xml.writeText( rss.str(), XmlFormatting::Newline );
12985          }
12986      }
12987      CATCH_REGISTER_REPORTER( &quot;junit&quot;, JunitReporter )
12988  } 
12989  #include &lt;cassert&gt;
12990  namespace Catch {
12991      ListeningReporter::ListeningReporter() {
12992          m_preferences.shouldReportAllAssertions = true;
12993      }
12994      void ListeningReporter::addListener( IStreamingReporterPtr&amp;&amp; listener ) {
12995          m_listeners.push_back( std::move( listener ) );
12996      }
12997      void ListeningReporter::addReporter(IStreamingReporterPtr&amp;&amp; reporter) {
12998          assert(!m_reporter &amp;&amp; &quot;Listening reporter can wrap only 1 real reporter&quot;);
12999          m_reporter = std::move( reporter );
13000          m_preferences.shouldRedirectStdOut = m_reporter-&gt;getPreferences().shouldRedirectStdOut;
13001      }
13002      ReporterPreferences ListeningReporter::getPreferences() const {
13003          return m_preferences;
13004      }
13005      std::set&lt;Verbosity&gt; ListeningReporter::getSupportedVerbosities() {
13006          return std::set&lt;Verbosity&gt;{ };
13007      }
13008      void ListeningReporter::noMatchingTestCases( std::string const&amp; spec ) {
13009          for ( auto const&amp; listener : m_listeners ) {
13010              listener-&gt;noMatchingTestCases( spec );
13011          }
13012          m_reporter-&gt;noMatchingTestCases( spec );
13013      }
13014      void ListeningReporter::reportInvalidArguments(std::string const&amp;arg){
13015          for ( auto const&amp; listener : m_listeners ) {
13016              listener-&gt;reportInvalidArguments( arg );
13017          }
13018          m_reporter-&gt;reportInvalidArguments( arg );
13019      }
13020  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13021      void ListeningReporter::benchmarkPreparing( std::string const&amp; name ) {
13022  		for (auto const&amp; listener : m_listeners) {
13023  			listener-&gt;benchmarkPreparing(name);
13024  		}
13025  		m_reporter-&gt;benchmarkPreparing(name);
13026  	}
13027      void ListeningReporter::benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) {
13028          for ( auto const&amp; listener : m_listeners ) {
13029              listener-&gt;benchmarkStarting( benchmarkInfo );
13030          }
13031          m_reporter-&gt;benchmarkStarting( benchmarkInfo );
13032      }
13033      void ListeningReporter::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) {
13034          for ( auto const&amp; listener : m_listeners ) {
13035              listener-&gt;benchmarkEnded( benchmarkStats );
13036          }
13037          m_reporter-&gt;benchmarkEnded( benchmarkStats );
13038      }
13039  	void ListeningReporter::benchmarkFailed( std::string const&amp; error ) {
13040  		for (auto const&amp; listener : m_listeners) {
13041  			listener-&gt;benchmarkFailed(error);
13042  		}
13043  		m_reporter-&gt;benchmarkFailed(error);
13044  	}
13045  #endif 
13046      void ListeningReporter::testRunStarting( TestRunInfo const&amp; testRunInfo ) {
13047          for ( auto const&amp; listener : m_listeners ) {
13048              listener-&gt;testRunStarting( testRunInfo );
13049          }
13050          m_reporter-&gt;testRunStarting( testRunInfo );
13051      }
13052      void ListeningReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13053          for ( auto const&amp; listener : m_listeners ) {
13054              listener-&gt;testGroupStarting( groupInfo );
13055          }
13056          m_reporter-&gt;testGroupStarting( groupInfo );
13057      }
13058      void ListeningReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13059          for ( auto const&amp; listener : m_listeners ) {
13060              listener-&gt;testCaseStarting( testInfo );
13061          }
13062          m_reporter-&gt;testCaseStarting( testInfo );
13063      }
13064      void ListeningReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13065          for ( auto const&amp; listener : m_listeners ) {
13066              listener-&gt;sectionStarting( sectionInfo );
13067          }
13068          m_reporter-&gt;sectionStarting( sectionInfo );
13069      }
13070      void ListeningReporter::assertionStarting( AssertionInfo const&amp; assertionInfo ) {
13071          for ( auto const&amp; listener : m_listeners ) {
13072              listener-&gt;assertionStarting( assertionInfo );
13073          }
13074          m_reporter-&gt;assertionStarting( assertionInfo );
13075      }
13076      bool ListeningReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13077          for( auto const&amp; listener : m_listeners ) {
13078              static_cast&lt;void&gt;( listener-&gt;assertionEnded( assertionStats ) );
13079          }
13080          return m_reporter-&gt;assertionEnded( assertionStats );
13081      }
13082      void ListeningReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13083          for ( auto const&amp; listener : m_listeners ) {
13084              listener-&gt;sectionEnded( sectionStats );
13085          }
13086          m_reporter-&gt;sectionEnded( sectionStats );
13087      }
13088      void ListeningReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13089          for ( auto const&amp; listener : m_listeners ) {
13090              listener-&gt;testCaseEnded( testCaseStats );
13091          }
13092          m_reporter-&gt;testCaseEnded( testCaseStats );
13093      }
13094      void ListeningReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13095          for ( auto const&amp; listener : m_listeners ) {
13096              listener-&gt;testGroupEnded( testGroupStats );
13097          }
13098          m_reporter-&gt;testGroupEnded( testGroupStats );
13099      }
13100      void ListeningReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13101          for ( auto const&amp; listener : m_listeners ) {
13102              listener-&gt;testRunEnded( testRunStats );
13103          }
13104          m_reporter-&gt;testRunEnded( testRunStats );
13105      }
13106      void ListeningReporter::skipTest( TestCaseInfo const&amp; testInfo ) {
13107          for ( auto const&amp; listener : m_listeners ) {
13108              listener-&gt;skipTest( testInfo );
13109          }
13110          m_reporter-&gt;skipTest( testInfo );
13111      }
13112      bool ListeningReporter::isMulti() const {
13113          return true;
13114      }
13115  } 
13116  #if defined(_MSC_VER)
13117  #pragma warning(push)
13118  #pragma warning(disable:4061) 
13119  #endif
13120  namespace Catch {
13121      XmlReporter::XmlReporter( ReporterConfig const&amp; _config )
13122      :   StreamingReporterBase( _config ),
13123          m_xml(_config.stream())
13124      {
13125          m_reporterPrefs.shouldRedirectStdOut = true;
13126          m_reporterPrefs.shouldReportAllAssertions = true;
13127      }
13128      XmlReporter::~XmlReporter() = default;
13129      std::string XmlReporter::getDescription() {
13130          return &quot;Reports test results as an XML document&quot;;
13131      }
13132      std::string XmlReporter::getStylesheetRef() const {
13133          return std::string();
13134      }
13135      void XmlReporter::writeSourceInfo( SourceLineInfo const&amp; sourceInfo ) {
13136          m_xml
13137              .writeAttribute( &quot;filename&quot;, sourceInfo.file )
13138              .writeAttribute( &quot;line&quot;, sourceInfo.line );
13139      }
13140      void XmlReporter::noMatchingTestCases( std::string const&amp; s ) {
13141          StreamingReporterBase::noMatchingTestCases( s );
13142      }
13143      void XmlReporter::testRunStarting( TestRunInfo const&amp; testInfo ) {
13144          StreamingReporterBase::testRunStarting( testInfo );
13145          std::string stylesheetRef = getStylesheetRef();
13146          if( !stylesheetRef.empty() )
13147              m_xml.writeStylesheetRef( stylesheetRef );
13148          m_xml.startElement( &quot;Catch&quot; );
13149          if( !m_config-&gt;name().empty() )
13150              m_xml.writeAttribute( &quot;name&quot;, m_config-&gt;name() );
13151          if (m_config-&gt;testSpec().hasFilters())
13152              m_xml.writeAttribute( &quot;filters&quot;, serializeFilters( m_config-&gt;getTestsOrTags() ) );
13153          if( m_config-&gt;rngSeed() != 0 )
13154              m_xml.scopedElement( &quot;Randomness&quot; )
13155                  .writeAttribute( &quot;seed&quot;, m_config-&gt;rngSeed() );
13156      }
13157      void XmlReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13158          StreamingReporterBase::testGroupStarting( groupInfo );
13159          m_xml.startElement( &quot;Group&quot; )
13160              .writeAttribute( &quot;name&quot;, groupInfo.name );
13161      }
13162      void XmlReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13163          StreamingReporterBase::testCaseStarting(testInfo);
13164          m_xml.startElement( &quot;TestCase&quot; )
13165              .writeAttribute( &quot;name&quot;, trim( testInfo.name ) )
13166              .writeAttribute( &quot;description&quot;, testInfo.description )
13167              .writeAttribute( &quot;tags&quot;, testInfo.tagsAsString() );
13168          writeSourceInfo( testInfo.lineInfo );
13169          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13170              m_testCaseTimer.start();
13171          m_xml.ensureTagClosed();
13172      }
13173      void XmlReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13174          StreamingReporterBase::sectionStarting( sectionInfo );
13175          if( m_sectionDepth++ &gt; 0 ) {
13176              m_xml.startElement( &quot;Section&quot; )
13177                  .writeAttribute( &quot;name&quot;, trim( sectionInfo.name ) );
13178              writeSourceInfo( sectionInfo.lineInfo );
13179              m_xml.ensureTagClosed();
13180          }
13181      }
13182      void XmlReporter::assertionStarting( AssertionInfo const&amp; ) { }
13183      bool XmlReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13184          AssertionResult const&amp; result = assertionStats.assertionResult;
13185          bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
13186          if( includeResults || result.getResultType() == ResultWas::Warning ) {
13187              for( auto const&amp; msg : assertionStats.infoMessages ) {
13188                  if( msg.type == ResultWas::Info &amp;&amp; includeResults ) {
13189                      m_xml.scopedElement( &quot;Info&quot; )
13190                              .writeText( msg.message );
13191                  } else if ( msg.type == ResultWas::Warning ) {
13192                      m_xml.scopedElement( &quot;Warning&quot; )
13193                              .writeText( msg.message );
13194                  }
13195              }
13196          }
13197          if( !includeResults &amp;&amp; result.getResultType() != ResultWas::Warning )
13198              return true;
13199          if( result.hasExpression() ) {
13200              m_xml.startElement( &quot;Expression&quot; )
13201                  .writeAttribute( &quot;success&quot;, result.succeeded() )
13202                  .writeAttribute( &quot;type&quot;, result.getTestMacroName() );
13203              writeSourceInfo( result.getSourceInfo() );
13204              m_xml.scopedElement( &quot;Original&quot; )
13205                  .writeText( result.getExpression() );
13206              m_xml.scopedElement( &quot;Expanded&quot; )
13207                  .writeText( result.getExpandedExpression() );
13208          }
13209          switch( result.getResultType() ) {
13210              case ResultWas::ThrewException:
13211                  m_xml.startElement( &quot;Exception&quot; );
13212                  writeSourceInfo( result.getSourceInfo() );
13213                  m_xml.writeText( result.getMessage() );
13214                  m_xml.endElement();
13215                  break;
13216              case ResultWas::FatalErrorCondition:
13217                  m_xml.startElement( &quot;FatalErrorCondition&quot; );
13218                  writeSourceInfo( result.getSourceInfo() );
13219                  m_xml.writeText( result.getMessage() );
13220                  m_xml.endElement();
13221                  break;
13222              case ResultWas::Info:
13223                  m_xml.scopedElement( &quot;Info&quot; )
13224                      .writeText( result.getMessage() );
13225                  break;
13226              case ResultWas::Warning:
13227                  break;
13228              case ResultWas::ExplicitFailure:
13229                  m_xml.startElement( &quot;Failure&quot; );
13230                  writeSourceInfo( result.getSourceInfo() );
13231                  m_xml.writeText( result.getMessage() );
13232                  m_xml.endElement();
13233                  break;
13234              default:
13235                  break;
13236          }
13237          if( result.hasExpression() )
13238              m_xml.endElement();
13239          return true;
13240      }
13241      void XmlReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13242          StreamingReporterBase::sectionEnded( sectionStats );
13243          if( --m_sectionDepth &gt; 0 ) {
13244              XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResults&quot; );
13245              e.writeAttribute( &quot;successes&quot;, sectionStats.assertions.passed );
13246              e.writeAttribute( &quot;failures&quot;, sectionStats.assertions.failed );
13247              e.writeAttribute( &quot;expectedFailures&quot;, sectionStats.assertions.failedButOk );
13248              if ( m_config-&gt;showDurations() == ShowDurations::Always )
13249                  e.writeAttribute( &quot;durationInSeconds&quot;, sectionStats.durationInSeconds );
13250              m_xml.endElement();
13251          }
13252      }
13253      void XmlReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13254          StreamingReporterBase::testCaseEnded( testCaseStats );
13255          XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResult&quot; );
13256          e.writeAttribute( &quot;success&quot;, testCaseStats.totals.assertions.allOk() );
13257          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13258              e.writeAttribute( &quot;durationInSeconds&quot;, m_testCaseTimer.getElapsedSeconds() );
13259          if( !testCaseStats.stdOut.empty() )
13260              m_xml.scopedElement( &quot;StdOut&quot; ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
13261          if( !testCaseStats.stdErr.empty() )
13262              m_xml.scopedElement( &quot;StdErr&quot; ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );
13263          m_xml.endElement();
13264      }
13265      void XmlReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13266          StreamingReporterBase::testGroupEnded( testGroupStats );
13267          m_xml.scopedElement( &quot;OverallResults&quot; )
13268              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.assertions.passed )
13269              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.assertions.failed )
13270              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.assertions.failedButOk );
13271          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13272              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.testCases.passed )
13273              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.testCases.failed )
13274              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.testCases.failedButOk );
13275          m_xml.endElement();
13276      }
13277      void XmlReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13278          StreamingReporterBase::testRunEnded( testRunStats );
13279          m_xml.scopedElement( &quot;OverallResults&quot; )
13280              .writeAttribute( &quot;successes&quot;, testRunStats.totals.assertions.passed )
13281              .writeAttribute( &quot;failures&quot;, testRunStats.totals.assertions.failed )
13282              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.assertions.failedButOk );
13283          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13284              .writeAttribute( &quot;successes&quot;, testRunStats.totals.testCases.passed )
13285              .writeAttribute( &quot;failures&quot;, testRunStats.totals.testCases.failed )
13286              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.testCases.failedButOk );
13287          m_xml.endElement();
13288      }
13289  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13290      void XmlReporter::benchmarkPreparing(std::string const&amp; name) {
13291          m_xml.startElement(&quot;BenchmarkResults&quot;)
13292              .writeAttribute(&quot;name&quot;, name);
13293      }
13294      void XmlReporter::benchmarkStarting(BenchmarkInfo const &amp;info) {
13295          m_xml.writeAttribute(&quot;samples&quot;, info.samples)
13296              .writeAttribute(&quot;resamples&quot;, info.resamples)
13297              .writeAttribute(&quot;iterations&quot;, info.iterations)
13298              .writeAttribute(&quot;clockResolution&quot;, info.clockResolution)
13299              .writeAttribute(&quot;estimatedDuration&quot;, info.estimatedDuration)
13300              .writeComment(&quot;All values in nano seconds&quot;);
13301      }
13302      void XmlReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; benchmarkStats) {
13303          m_xml.startElement(&quot;mean&quot;)
13304              .writeAttribute(&quot;value&quot;, benchmarkStats.mean.point.count())
13305              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.mean.lower_bound.count())
13306              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.mean.upper_bound.count())
13307              .writeAttribute(&quot;ci&quot;, benchmarkStats.mean.confidence_interval);
13308          m_xml.endElement();
13309          m_xml.startElement(&quot;standardDeviation&quot;)
13310              .writeAttribute(&quot;value&quot;, benchmarkStats.standardDeviation.point.count())
13311              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.standardDeviation.lower_bound.count())
13312              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.standardDeviation.upper_bound.count())
13313              .writeAttribute(&quot;ci&quot;, benchmarkStats.standardDeviation.confidence_interval);
13314          m_xml.endElement();
13315          m_xml.startElement(&quot;outliers&quot;)
13316              .writeAttribute(&quot;variance&quot;, benchmarkStats.outlierVariance)
13317              .writeAttribute(&quot;lowMild&quot;, benchmarkStats.outliers.low_mild)
13318              .writeAttribute(&quot;lowSevere&quot;, benchmarkStats.outliers.low_severe)
13319              .writeAttribute(&quot;highMild&quot;, benchmarkStats.outliers.high_mild)
13320              .writeAttribute(&quot;highSevere&quot;, benchmarkStats.outliers.high_severe);
13321          m_xml.endElement();
13322          m_xml.endElement();
13323      }
13324      void XmlReporter::benchmarkFailed(std::string const &amp;error) {
13325          m_xml.scopedElement(&quot;failed&quot;).
13326              writeAttribute(&quot;message&quot;, error);
13327          m_xml.endElement();
13328      }
13329  #endif 
13330      CATCH_REGISTER_REPORTER( &quot;xml&quot;, XmlReporter )
13331  } 
13332  #if defined(_MSC_VER)
13333  #pragma warning(pop)
13334  #endif
13335  namespace Catch {
13336      LeakDetector leakDetector;
13337  }
13338  #ifdef __clang__
13339  #pragma clang diagnostic pop
13340  #endif
13341  #endif
13342  #ifdef CATCH_CONFIG_MAIN
13343  #ifndef __OBJC__
13344  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; defined(_UNICODE) &amp;&amp; !defined(DO_NOT_USE_WMAIN)
13345  extern &quot;C&quot; int wmain (int argc, wchar_t * argv[], wchar_t * []) {
13346  #else
13347  int main (int argc, char * argv[]) {
13348  #endif
13349      return Catch::Session().run( argc, argv );
13350  }
13351  #else 
13352  int main (int argc, char * const argv[]) {
13353  #if !CATCH_ARC_ENABLED
13354      NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
13355  #endif
13356      Catch::registerTestMethods();
13357      int result = Catch::Session().run( argc, (char**)argv );
13358  #if !CATCH_ARC_ENABLED
13359      [pool drain];
13360  #endif
13361      return result;
13362  }
13363  #endif 
13364  #endif
13365  #if !defined(CATCH_CONFIG_IMPL_ONLY)
13366  #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
13367  #  undef CLARA_CONFIG_MAIN
13368  #endif
13369  #if !defined(CATCH_CONFIG_DISABLE)
13370  #ifdef CATCH_CONFIG_PREFIX_ALL
13371  #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13372  #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13373  #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;CATCH_REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13374  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13375  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13376  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13377  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13378  #endif
13379  #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13380  #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13381  #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13382  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CATCH_CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13383  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CATCH_CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13384  #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13385  #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CATCH_CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13386  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13387  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13388  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13389  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13390  #endif 
13391  #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13392  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13393  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13394  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13395  #endif 
13396  #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( &quot;CATCH_INFO&quot;, msg )
13397  #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;CATCH_UNSCOPED_INFO&quot;, msg )
13398  #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( &quot;CATCH_WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13399  #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CATCH_CAPTURE&quot;,__VA_ARGS__ )
13400  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13401  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13402  #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13403  #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13404  #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13405  #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13406  #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13407  #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13408  #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13409  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13410  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13411  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13412  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13413  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13414  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13415  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13416  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13417  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13418  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13419  #else
13420  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13421  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13422  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13423  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13424  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13425  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13426  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13427  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13428  #endif
13429  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13430  #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
13431  #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); CATCH_SUCCEED( #__VA_ARGS__ )
13432  #else
13433  #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
13434  #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
13435  #endif
13436  #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13437  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13438  #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13439  #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13440  #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13441  #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13442  #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13443  #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13444  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13445  #define CATCH_BENCHMARK(...) \
13446      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13447  #define CATCH_BENCHMARK_ADVANCED(name) \
13448      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13449  #endif 
13450  #else
13451  #define REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__  )
13452  #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13453  #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13454  #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13455  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13456  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13457  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13458  #endif 
13459  #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13460  #define CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13461  #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13462  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13463  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13464  #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13465  #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13466  #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13467  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13468  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13469  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13470  #endif 
13471  #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13472  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13473  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13474  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13475  #endif 
13476  #define INFO( msg ) INTERNAL_CATCH_INFO( &quot;INFO&quot;, msg )
13477  #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;UNSCOPED_INFO&quot;, msg )
13478  #define WARN( msg ) INTERNAL_CATCH_MSG( &quot;WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13479  #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CAPTURE&quot;,__VA_ARGS__ )
13480  #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13481  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13482  #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13483  #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13484  #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13485  #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13486  #define FAIL( ... ) INTERNAL_CATCH_MSG( &quot;FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13487  #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13488  #define SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13489  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13490  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13491  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13492  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13493  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13494  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13495  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13496  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13497  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13498  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13499  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
13500  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
13501  #else
13502  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13503  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13504  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13505  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13506  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13507  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13508  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13509  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13510  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
13511  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13512  #endif
13513  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13514  #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
13515  #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); SUCCEED( &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; )
13516  #else
13517  #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
13518  #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
13519  #endif
13520  #endif
13521  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
13522  #define SCENARIO( ... ) TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13523  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13524  #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13525  #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13526  #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13527  #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13528  #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13529  #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13530  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13531  #define BENCHMARK(...) \
13532      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13533  #define BENCHMARK_ADVANCED(name) \
13534      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13535  #endif 
13536  using Catch::Detail::Approx;
13537  #else 
13538  #ifdef CATCH_CONFIG_PREFIX_ALL
13539  #define CATCH_REQUIRE( ... )        (void)(0)
13540  #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
13541  #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
13542  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13543  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
13544  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13545  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13546  #endif
13547  #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
13548  #define CATCH_CHECK( ... )         (void)(0)
13549  #define CATCH_CHECK_FALSE( ... )   (void)(0)
13550  #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
13551  #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
13552  #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
13553  #define CATCH_CHECK_THROWS( ... )  (void)(0)
13554  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13555  #define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
13556  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13557  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13558  #endif 
13559  #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
13560  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13561  #define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
13562  #define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
13563  #endif 
13564  #define CATCH_INFO( msg )          (void)(0)
13565  #define CATCH_UNSCOPED_INFO( msg ) (void)(0)
13566  #define CATCH_WARN( msg )          (void)(0)
13567  #define CATCH_CAPTURE( msg )       (void)(0)
13568  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13569  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13570  #define CATCH_METHOD_AS_TEST_CASE( method, ... )
13571  #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
13572  #define CATCH_SECTION( ... )
13573  #define CATCH_DYNAMIC_SECTION( ... )
13574  #define CATCH_FAIL( ... ) (void)(0)
13575  #define CATCH_FAIL_CHECK( ... ) (void)(0)
13576  #define CATCH_SUCCEED( ... ) (void)(0)
13577  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13578  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13579  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13580  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13581  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13582  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13583  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13584  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13585  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13586  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13587  #else
13588  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13589  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13590  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13591  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13592  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13593  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13594  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13595  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13596  #endif
13597  #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13598  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13599  #define CATCH_GIVEN( desc )
13600  #define CATCH_AND_GIVEN( desc )
13601  #define CATCH_WHEN( desc )
13602  #define CATCH_AND_WHEN( desc )
13603  #define CATCH_THEN( desc )
13604  #define CATCH_AND_THEN( desc )
13605  #define CATCH_STATIC_REQUIRE( ... )       (void)(0)
13606  #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
13607  #else
13608  #define REQUIRE( ... )       (void)(0)
13609  #define REQUIRE_FALSE( ... ) (void)(0)
13610  #define REQUIRE_THROWS( ... ) (void)(0)
13611  #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13612  #define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
13613  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13614  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13615  #endif 
13616  #define REQUIRE_NOTHROW( ... ) (void)(0)
13617  #define CHECK( ... ) (void)(0)
13618  #define CHECK_FALSE( ... ) (void)(0)
13619  #define CHECKED_IF( ... ) if (__VA_ARGS__)
13620  #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
13621  #define CHECK_NOFAIL( ... ) (void)(0)
13622  #define CHECK_THROWS( ... )  (void)(0)
13623  #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13624  #define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
13625  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13626  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13627  #endif 
13628  #define CHECK_NOTHROW( ... ) (void)(0)
13629  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13630  #define CHECK_THAT( arg, matcher ) (void)(0)
13631  #define REQUIRE_THAT( arg, matcher ) (void)(0)
13632  #endif 
13633  #define INFO( msg ) (void)(0)
13634  #define UNSCOPED_INFO( msg ) (void)(0)
13635  #define WARN( msg ) (void)(0)
13636  #define CAPTURE( msg ) (void)(0)
13637  #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13638  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13639  #define METHOD_AS_TEST_CASE( method, ... )
13640  #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
13641  #define SECTION( ... )
13642  #define DYNAMIC_SECTION( ... )
13643  #define FAIL( ... ) (void)(0)
13644  #define FAIL_CHECK( ... ) (void)(0)
13645  #define SUCCEED( ... ) (void)(0)
13646  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13647  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13648  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13649  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13650  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13651  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13652  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13653  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13654  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13655  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13656  #else
13657  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13658  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13659  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13660  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13661  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13662  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13663  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13664  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13665  #endif
13666  #define STATIC_REQUIRE( ... )       (void)(0)
13667  #define STATIC_REQUIRE_FALSE( ... ) (void)(0)
13668  #endif
13669  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
13670  #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
13671  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13672  #define GIVEN( desc )
13673  #define AND_GIVEN( desc )
13674  #define WHEN( desc )
13675  #define AND_WHEN( desc )
13676  #define THEN( desc )
13677  #define AND_THEN( desc )
13678  using Catch::Detail::Approx;
13679  #endif
13680  #endif 
13681  #ifdef __clang__
13682  #    ifdef __ICC 
13683  #        pragma warning(pop)
13684  #    else
13685  #        pragma clang diagnostic pop
13686  #    endif
13687  #elif defined __GNUC__
13688  #    pragma GCC diagnostic pop
13689  #endif
13690  #endif 
</span></code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-catch.hpp</h3>
            <pre><code>1  #ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
2  #define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
3  #define CATCH_VERSION_MAJOR 2
4  #define CATCH_VERSION_MINOR 13
5  #define CATCH_VERSION_PATCH 7
6  #ifdef __clang__
7  #    pragma clang system_header
8  #elif defined __GNUC__
9  #    pragma GCC system_header
10  #endif
11  #ifdef __clang__
12  #   ifdef __ICC 
13  #       pragma warning(push)
14  #       pragma warning(disable: 161 1682)
15  #   else 
16  #       pragma clang diagnostic push
17  #       pragma clang diagnostic ignored &quot;-Wpadded&quot;
18  #       pragma clang diagnostic ignored &quot;-Wswitch-enum&quot;
19  #       pragma clang diagnostic ignored &quot;-Wcovered-switch-default&quot;
20  #    endif
21  #elif defined __GNUC__
22  #    pragma GCC diagnostic ignored &quot;-Wparentheses&quot; 
23  #    pragma GCC diagnostic push
24  #    pragma GCC diagnostic ignored &quot;-Wunused-variable&quot;
25  #    pragma GCC diagnostic ignored &quot;-Wpadded&quot;
26  #endif
27  #if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
28  #  define CATCH_IMPL
29  #  define CATCH_CONFIG_ALL_PARTS
30  #endif
31  #if defined(CATCH_CONFIG_ALL_PARTS)
32  #  define CATCH_CONFIG_EXTERNAL_INTERFACES
33  #  if defined(CATCH_CONFIG_DISABLE_MATCHERS)
34  #    undef CATCH_CONFIG_DISABLE_MATCHERS
35  #  endif
36  #  if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
37  #    define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
38  #  endif
39  #endif
40  #if !defined(CATCH_CONFIG_IMPL_ONLY)
41  #ifdef __APPLE__
42  #  include &lt;TargetConditionals.h&gt;
43  #  if (defined(TARGET_OS_OSX) &amp;&amp; TARGET_OS_OSX == 1) || \
44        (defined(TARGET_OS_MAC) &amp;&amp; TARGET_OS_MAC == 1)
45  #    define CATCH_PLATFORM_MAC
46  #  elif (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE == 1)
47  #    define CATCH_PLATFORM_IPHONE
48  #  endif
49  #elif defined(linux) || defined(__linux) || defined(__linux__)
50  #  define CATCH_PLATFORM_LINUX
51  #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
52  #  define CATCH_PLATFORM_WINDOWS
53  #endif
54  #ifdef CATCH_IMPL
55  #  ifndef CLARA_CONFIG_MAIN
56  #    define CLARA_CONFIG_MAIN_NOT_DEFINED
57  #    define CLARA_CONFIG_MAIN
58  #  endif
59  #endif
60  namespace Catch {
61      unsigned int rngSeed();
62  }
63  #ifdef __cplusplus
64  #  if (__cplusplus &gt;= 201402L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201402L)
65  #    define CATCH_CPP14_OR_GREATER
66  #  endif
67  #  if (__cplusplus &gt;= 201703L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)
68  #    define CATCH_CPP17_OR_GREATER
69  #  endif
70  #endif
71  #if defined(__GNUC__) &amp;&amp; !defined(__clang__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__CUDACC__) &amp;&amp; !defined(__LCC__)
72  #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( &quot;GCC diagnostic push&quot; )
73  #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( &quot;GCC diagnostic pop&quot; )
74  #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)
75  #endif
76  #if defined(__clang__)
77  #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( &quot;clang diagnostic push&quot; )
78  #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( &quot;clang diagnostic pop&quot; )
79  #  if !defined(__ibmxl__) &amp;&amp; !defined(__CUDACC__)
80  #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) &amp;bsol;* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */
81  #  endif
82  #    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
83           _Pragma( &quot;clang diagnostic ignored \&quot;-Wexit-time-destructors\&quot;&quot; ) \
84           _Pragma( &quot;clang diagnostic ignored \&quot;-Wglobal-constructors\&quot;&quot;)
85  #    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
86           _Pragma( &quot;clang diagnostic ignored \&quot;-Wparentheses\&quot;&quot; )
87  #    define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
88           _Pragma( &quot;clang diagnostic ignored \&quot;-Wunused-variable\&quot;&quot; )
89  #    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
90           _Pragma( &quot;clang diagnostic ignored \&quot;-Wgnu-zero-variadic-macro-arguments\&quot;&quot; )
91  #    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
92           _Pragma( &quot;clang diagnostic ignored \&quot;-Wunused-template\&quot;&quot; )
93  #endif 
94  #if !defined(CATCH_PLATFORM_WINDOWS)
95      #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
96  #endif
97  #if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
98      #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
99  #endif
100  #ifdef __OS400__
101  #       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
102  #       define CATCH_CONFIG_COLOUR_NONE
103  #endif
104  #if defined(__ANDROID__)
105  #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
106  #    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE
107  #endif
108  #if defined(__MINGW32__)
109  #    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
110  #endif
111  #if defined(__ORBIS__)
112  #    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
113  #endif
114  #ifdef __CYGWIN__
115  #   define _BSD_SOURCE
116  # if !((__cplusplus &gt;= 201103L) &amp;&amp; defined(_GLIBCXX_USE_C99) \
117             &amp;&amp; !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))
118  #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
119  # endif
120  #endif 
121  #if defined(_MSC_VER)
122  #  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
123  #  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )
124  #  if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY == WINAPI_FAMILY_APP)
125  #    define CATCH_CONFIG_COLOUR_NONE
126  #  else
127  #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
128  #  endif
129  #  if !defined(__clang__) 
130  #    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) &amp;&amp; _MSVC_TRADITIONAL)
131  #      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
132  #    endif 
133  #  endif 
134  #endif 
135  #if defined(_REENTRANT) || defined(_MSC_VER)
136  # define CATCH_INTERNAL_CONFIG_USE_ASYNC
137  #endif 
138  #if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
139  #  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
140  #endif
141  #ifdef __DJGPP__
142  #  define CATCH_INTERNAL_CONFIG_NO_WCHAR
143  #endif 
144  #if defined(__BORLANDC__)
145      #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
146  #endif
147  #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ &gt;= 20170300L )
148      #define CATCH_INTERNAL_CONFIG_COUNTER
149  #endif
150  #if defined(UNDER_RTSS) || defined(RTX64_BUILD)
151      #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
152      #define CATCH_INTERNAL_CONFIG_NO_ASYNC
153      #define CATCH_CONFIG_COLOUR_NONE
154  #endif
155  #if !defined(_GLIBCXX_USE_C99_MATH_TR1)
156  #define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER
157  #endif
158  #if defined(__has_include)
159    #if __has_include(&lt;string_view&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
160    #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
161    #endif
162    #  if __has_include(&lt;optional&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
163    #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
164    #  endif 
165    #  if __has_include(&lt;cstddef&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
166    #    include &lt;cstddef&gt;
167    #    if defined(__cpp_lib_byte) &amp;&amp; (__cpp_lib_byte &gt; 0)
168    #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE
169    #    endif
170    #  endif 
171    #  if __has_include(&lt;variant&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)
172    #    if defined(__clang__) &amp;&amp; (__clang_major__ &lt; 8)
173    #      include &lt;ciso646&gt;
174    #      if defined(__GLIBCXX__) &amp;&amp; defined(_GLIBCXX_RELEASE) &amp;&amp; (_GLIBCXX_RELEASE &lt; 9)
175    #        define CATCH_CONFIG_NO_CPP17_VARIANT
176    #      else
177    #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
178    #      endif 
179    #    else
180    #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
181    #    endif 
182    #  endif 
183  #endif 
184  #if defined(CATCH_INTERNAL_CONFIG_COUNTER) &amp;&amp; !defined(CATCH_CONFIG_NO_COUNTER) &amp;&amp; !defined(CATCH_CONFIG_COUNTER)
185  #   define CATCH_CONFIG_COUNTER
186  #endif
187  #if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) &amp;&amp; !defined(CATCH_CONFIG_NO_WINDOWS_SEH) &amp;&amp; !defined(CATCH_CONFIG_WINDOWS_SEH) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
188  #   define CATCH_CONFIG_WINDOWS_SEH
189  #endif
190  #if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_CONFIG_POSIX_SIGNALS)
191  #   define CATCH_CONFIG_POSIX_SIGNALS
192  #endif
193  #if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) &amp;&amp; !defined(CATCH_CONFIG_NO_WCHAR) &amp;&amp; !defined(CATCH_CONFIG_WCHAR)
194  #   define CATCH_CONFIG_WCHAR
195  #endif
196  #if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) &amp;&amp; !defined(CATCH_CONFIG_CPP11_TO_STRING)
197  #    define CATCH_CONFIG_CPP11_TO_STRING
198  #endif
199  #if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) &amp;&amp; !defined(CATCH_CONFIG_CPP17_OPTIONAL)
200  #  define CATCH_CONFIG_CPP17_OPTIONAL
201  #endif
202  #if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) &amp;&amp; !defined(CATCH_CONFIG_CPP17_STRING_VIEW)
203  #  define CATCH_CONFIG_CPP17_STRING_VIEW
204  #endif
205  #if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_VARIANT) &amp;&amp; !defined(CATCH_CONFIG_CPP17_VARIANT)
206  #  define CATCH_CONFIG_CPP17_VARIANT
207  #endif
208  #if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_BYTE) &amp;&amp; !defined(CATCH_CONFIG_CPP17_BYTE)
209  #  define CATCH_CONFIG_CPP17_BYTE
210  #endif
211  #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
212  #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
213  #endif
214  #if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) &amp;&amp; !defined(CATCH_CONFIG_NO_NEW_CAPTURE) &amp;&amp; !defined(CATCH_CONFIG_NEW_CAPTURE)
215  #  define CATCH_CONFIG_NEW_CAPTURE
216  #endif
217  #if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
218  #  define CATCH_CONFIG_DISABLE_EXCEPTIONS
219  #endif
220  #if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) &amp;&amp; !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) &amp;&amp; !defined(CATCH_CONFIG_POLYFILL_ISNAN)
221  #  define CATCH_CONFIG_POLYFILL_ISNAN
222  #endif
223  #if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) &amp;&amp; !defined(CATCH_CONFIG_NO_USE_ASYNC) &amp;&amp; !defined(CATCH_CONFIG_USE_ASYNC)
224  #  define CATCH_CONFIG_USE_ASYNC
225  #endif
226  #if defined(CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE) &amp;&amp; !defined(CATCH_CONFIG_NO_ANDROID_LOGWRITE) &amp;&amp; !defined(CATCH_CONFIG_ANDROID_LOGWRITE)
227  #  define CATCH_CONFIG_ANDROID_LOGWRITE
228  #endif
229  #if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) &amp;&amp; !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) &amp;&amp; !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
230  #  define CATCH_CONFIG_GLOBAL_NEXTAFTER
231  #endif
232  #if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)
233  #   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
234  #endif
235  #if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)
236  #   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
237  #endif
238  #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
239  #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
240  #endif
241  #if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
242  #   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
243  #endif
244  #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS)
245  #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS
246  #endif
247  #if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)
248  #   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
249  #endif
250  #if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)
251  #   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)
252  #endif
253  #if defined(__APPLE__) &amp;&amp; defined(__apple_build_version__) &amp;&amp; (__clang_major__ &lt; 10)
254  #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
255  #elif defined(__clang__) &amp;&amp; (__clang_major__ &lt; 5)
256  #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
257  #endif
258  #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS)
259  #   define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
260  #endif
261  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
262  #define CATCH_TRY if ((true))
263  #define CATCH_CATCH_ALL if ((false))
264  #define CATCH_CATCH_ANON(type) if ((false))
265  #else
266  #define CATCH_TRY try
267  #define CATCH_CATCH_ALL catch (...)
268  #define CATCH_CATCH_ANON(type) catch (type)
269  #endif
270  #if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) &amp;&amp; !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) &amp;&amp; !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)
271  #define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
272  #endif
273  #define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
274  #define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
275  #ifdef CATCH_CONFIG_COUNTER
276  #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
277  #else
278  #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
279  #endif
280  #include &lt;iosfwd&gt;
281  #include &lt;string&gt;
282  #include &lt;cstdint&gt;
283  struct Catch_global_namespace_dummy {};
284  std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, Catch_global_namespace_dummy);
285  namespace Catch {
286      struct CaseSensitive { enum Choice {
287          Yes,
288          No
289      }; };
290      class NonCopyable {
291          NonCopyable( NonCopyable const&amp; )              = delete;
292          NonCopyable( NonCopyable &amp;&amp; )                  = delete;
293          NonCopyable&amp; operator = ( NonCopyable const&amp; ) = delete;
294          NonCopyable&amp; operator = ( NonCopyable &amp;&amp; )     = delete;
295      protected:
296          NonCopyable();
297          virtual ~NonCopyable();
298      };
299      struct SourceLineInfo {
300          SourceLineInfo() = delete;
301          SourceLineInfo( char const* _file, std::size_t _line ) noexcept
302          :   file( _file ),
303              line( _line )
304          {}
305          SourceLineInfo( SourceLineInfo const&amp; other )            = default;
306          SourceLineInfo&amp; operator = ( SourceLineInfo const&amp; )     = default;
307          SourceLineInfo( SourceLineInfo&amp;&amp; )              noexcept = default;
308          SourceLineInfo&amp; operator = ( SourceLineInfo&amp;&amp; ) noexcept = default;
309          bool empty() const noexcept { return file[0] == &#x27;\0&#x27;; }
310          bool operator == ( SourceLineInfo const&amp; other ) const noexcept;
311          bool operator &lt; ( SourceLineInfo const&amp; other ) const noexcept;
312          char const* file;
313          std::size_t line;
314      };
315      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, SourceLineInfo const&amp; info );
316      using ::operator&lt;&lt;;
317      struct StreamEndStop {
318          std::string operator+() const;
319      };
320      template&lt;typename T&gt;
321      T const&amp; operator + ( T const&amp; value, StreamEndStop ) {
322          return value;
323      }
324  }
325  #define CATCH_INTERNAL_LINEINFO \
326      ::Catch::SourceLineInfo( __FILE__, static_cast&lt;std::size_t&gt;( __LINE__ ) )
327  namespace Catch {
328      struct RegistrarForTagAliases {
329          RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const&amp; lineInfo );
330      };
331  } 
332  #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
333      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
334      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
335      namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
336      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
337  #include &lt;vector&gt;
338  namespace Catch {
339      class TestSpec;
340      struct ITestInvoker {
341          virtual void invoke () const = 0;
342          virtual ~ITestInvoker();
343      };
344      class TestCase;
345      struct IConfig;
346      struct ITestCaseRegistry {
347          virtual ~ITestCaseRegistry();
348          virtual std::vector&lt;TestCase&gt; const&amp; getAllTests() const = 0;
349          virtual std::vector&lt;TestCase&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const = 0;
350      };
351      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config );
352      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config );
353      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );
354      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );
355  }
356  #include &lt;cstddef&gt;
357  #include &lt;string&gt;
358  #include &lt;iosfwd&gt;
359  #include &lt;cassert&gt;
360  namespace Catch {
361      class StringRef {
362      public:
363          using size_type = std::size_t;
364          using const_iterator = const char*;
365      private:
366          static constexpr char const* const s_empty = &quot;&quot;;
367          char const* m_start = s_empty;
368          size_type m_size = 0;
369      public: 
370          constexpr StringRef() noexcept = default;
371          StringRef( char const* rawChars ) noexcept;
372          constexpr StringRef( char const* rawChars, size_type size ) noexcept
373          :   m_start( rawChars ),
374              m_size( size )
375          {}
376          StringRef( std::string const&amp; stdString ) noexcept
377          :   m_start( stdString.c_str() ),
378              m_size( stdString.size() )
379          {}
380          explicit operator std::string() const {
381              return std::string(m_start, m_size);
382          }
383      public: 
384          auto operator == ( StringRef const&amp; other ) const noexcept -&gt; bool;
385          auto operator != (StringRef const&amp; other) const noexcept -&gt; bool {
386              return !(*this == other);
387          }
388          auto operator[] ( size_type index ) const noexcept -&gt; char {
389              assert(index &lt; m_size);
390              return m_start[index];
391          }
392      public: 
393          constexpr auto empty() const noexcept -&gt; bool {
394              return m_size == 0;
395          }
396          constexpr auto size() const noexcept -&gt; size_type {
397              return m_size;
398          }
399          auto c_str() const -&gt; char const*;
400      public: 
401          auto substr( size_type start, size_type length ) const noexcept -&gt; StringRef;
402          auto data() const noexcept -&gt; char const*;
403          constexpr auto isNullTerminated() const noexcept -&gt; bool {
404              return m_start[m_size] == &#x27;\0&#x27;;
405          }
406      public: 
407          constexpr const_iterator begin() const { return m_start; }
408          constexpr const_iterator end() const { return m_start + m_size; }
409      };
410      auto operator += ( std::string&amp; lhs, StringRef const&amp; sr ) -&gt; std::string&amp;;
411      auto operator &lt;&lt; ( std::ostream&amp; os, StringRef const&amp; sr ) -&gt; std::ostream&amp;;
412      constexpr auto operator &quot;&quot; _sr( char const* rawChars, std::size_t size ) noexcept -&gt; StringRef {
413          return StringRef( rawChars, size );
414      }
415  } 
416  constexpr auto operator &quot;&quot; _catch_sr( char const* rawChars, std::size_t size ) noexcept -&gt; Catch::StringRef {
417      return Catch::StringRef( rawChars, size );
418  }
419  #define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__
420  #define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))
421  #define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))
422  #define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))
423  #define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))
424  #define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))
425  #ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
426  #define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__
427  #define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))
428  #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))
429  #else
430  #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)
431  #endif
432  #define CATCH_REC_END(...)
433  #define CATCH_REC_OUT
434  #define CATCH_EMPTY()
435  #define CATCH_DEFER(id) id CATCH_EMPTY()
436  #define CATCH_REC_GET_END2() 0, CATCH_REC_END
437  #define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2
438  #define CATCH_REC_GET_END(...) CATCH_REC_GET_END1
439  #define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT
440  #define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)
441  #define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)
442  #define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
443  #define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )
444  #define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
445  #define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
446  #define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )
447  #define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
448  #define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
449  #define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
450  #define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)
451  #define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__
452  #define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__
453  #define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
454  #define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)
455  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
456  #define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__
457  #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))
458  #else
459  #define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)
460  #define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__
461  #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)
462  #endif
463  #define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__
464  #define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)
465  #define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)
466  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
467  #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)&gt;())
468  #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))
469  #else
470  #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)&gt;()))
471  #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))
472  #endif
473  #define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\
474      CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)
475  #define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)
476  #define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)
477  #define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)
478  #define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)
479  #define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)
480  #define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)
481  #define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)
482  #define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)
483  #define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)
484  #define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)
485  #define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)
486  #define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
487  #define INTERNAL_CATCH_TYPE_GEN\
488      template&lt;typename...&gt; struct TypeList {};\
489      template&lt;typename...Ts&gt;\
490      constexpr auto get_wrapper() noexcept -&gt; TypeList&lt;Ts...&gt; { return {}; }\
491      template&lt;template&lt;typename...&gt; class...&gt; struct TemplateTypeList{};\
492      template&lt;template&lt;typename...&gt; class...Cs&gt;\
493      constexpr auto get_wrapper() noexcept -&gt; TemplateTypeList&lt;Cs...&gt; { return {}; }\
494      template&lt;typename...&gt;\
495      struct append;\
496      template&lt;typename...&gt;\
497      struct rewrap;\
498      template&lt;template&lt;typename...&gt; class, typename...&gt;\
499      struct create;\
500      template&lt;template&lt;typename...&gt; class, typename&gt;\
501      struct convert;\
502      \
503      template&lt;typename T&gt; \
504      struct append&lt;T&gt; { using type = T; };\
505      template&lt; template&lt;typename...&gt; class L1, typename...E1, template&lt;typename...&gt; class L2, typename...E2, typename...Rest&gt;\
506      struct append&lt;L1&lt;E1...&gt;, L2&lt;E2...&gt;, Rest...&gt; { using type = typename append&lt;L1&lt;E1...,E2...&gt;, Rest...&gt;::type; };\
507      template&lt; template&lt;typename...&gt; class L1, typename...E1, typename...Rest&gt;\
508      struct append&lt;L1&lt;E1...&gt;, TypeList&lt;mpl_::na&gt;, Rest...&gt; { using type = L1&lt;E1...&gt;; };\
509      \
510      template&lt; template&lt;typename...&gt; class Container, template&lt;typename...&gt; class List, typename...elems&gt;\
511      struct rewrap&lt;TemplateTypeList&lt;Container&gt;, List&lt;elems...&gt;&gt; { using type = TypeList&lt;Container&lt;elems...&gt;&gt;; };\
512      template&lt; template&lt;typename...&gt; class Container, template&lt;typename...&gt; class List, class...Elems, typename...Elements&gt;\
513      struct rewrap&lt;TemplateTypeList&lt;Container&gt;, List&lt;Elems...&gt;, Elements...&gt; { using type = typename append&lt;TypeList&lt;Container&lt;Elems...&gt;&gt;, typename rewrap&lt;TemplateTypeList&lt;Container&gt;, Elements...&gt;::type&gt;::type; };\
514      \
515      template&lt;template &lt;typename...&gt; class Final, template&lt; typename...&gt; class...Containers, typename...Types&gt;\
516      struct create&lt;Final, TemplateTypeList&lt;Containers...&gt;, TypeList&lt;Types...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;, typename rewrap&lt;TemplateTypeList&lt;Containers&gt;, Types...&gt;::type...&gt;::type; };\
517      template&lt;template &lt;typename...&gt; class Final, template &lt;typename...&gt; class List, typename...Ts&gt;\
518      struct convert&lt;Final, List&lt;Ts...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;,TypeList&lt;Ts&gt;...&gt;::type; };
519  #define INTERNAL_CATCH_NTTP_1(signature, ...)\
520      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; struct Nttp{};\
521      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
522      constexpr auto get_wrapper() noexcept -&gt; Nttp&lt;__VA_ARGS__&gt; { return {}; } \
523      template&lt;template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...&gt; struct NttpTemplateTypeList{};\
524      template&lt;template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...Cs&gt;\
525      constexpr auto get_wrapper() noexcept -&gt; NttpTemplateTypeList&lt;Cs...&gt; { return {}; } \
526      \
527      template&lt; template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class Container, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class List, INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
528      struct rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, List&lt;__VA_ARGS__&gt;&gt; { using type = TypeList&lt;Container&lt;__VA_ARGS__&gt;&gt;; };\
529      template&lt; template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class Container, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements&gt;\
530      struct rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, List&lt;__VA_ARGS__&gt;, Elements...&gt; { using type = typename append&lt;TypeList&lt;Container&lt;__VA_ARGS__&gt;&gt;, typename rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, Elements...&gt;::type&gt;::type; };\
531      template&lt;template &lt;typename...&gt; class Final, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...Containers, typename...Types&gt;\
532      struct create&lt;Final, NttpTemplateTypeList&lt;Containers...&gt;, TypeList&lt;Types...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;, typename rewrap&lt;NttpTemplateTypeList&lt;Containers&gt;, Types...&gt;::type...&gt;::type; };
533  #define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)
534  #define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\
535      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
536      static void TestName()
537  #define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\
538      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
539      static void TestName()
540  #define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)
541  #define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\
542      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
543      static void TestName()
544  #define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\
545      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
546      static void TestName()
547  #define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\
548      template&lt;typename Type&gt;\
549      void reg_test(TypeList&lt;Type&gt;, Catch::NameAndTags nameAndTags)\
550      {\
551          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestFunc&lt;Type&gt;), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
552      }
553  #define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\
554      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
555      void reg_test(Nttp&lt;__VA_ARGS__&gt;, Catch::NameAndTags nameAndTags)\
556      {\
557          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestFunc&lt;__VA_ARGS__&gt;), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
558      }
559  #define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\
560      template&lt;typename Type&gt;\
561      void reg_test(TypeList&lt;Type&gt;, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
562      {\
563          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestName&lt;Type&gt;::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
564      }
565  #define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\
566      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\
567      void reg_test(Nttp&lt;__VA_ARGS__&gt;, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
568      {\
569          Catch::AutoReg( Catch::makeTestInvoker(&amp;TestName&lt;__VA_ARGS__&gt;::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
570      }
571  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)
572  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\
573      template&lt;typename TestType&gt; \
574      struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)&lt;TestType&gt; { \
575          void test();\
576      }
577  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\
578      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; \
579      struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)&lt;__VA_ARGS__&gt; { \
580          void test();\
581      }
582  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)
583  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\
584      template&lt;typename TestType&gt; \
585      void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName&lt;TestType&gt;::test()
586  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\
587      template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; \
588      void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName&lt;__VA_ARGS__&gt;::test()
589  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
590  #define INTERNAL_CATCH_NTTP_0
591  #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)
592  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)
593  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)
594  #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)
595  #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)
596  #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)
597  #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)
598  #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)
599  #else
600  #define INTERNAL_CATCH_NTTP_0(signature)
601  #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))
602  #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))
603  #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))
604  #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))
605  #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))
606  #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))
607  #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))
608  #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))
609  #endif
610  #include &lt;type_traits&gt;
611  namespace Catch {
612      template&lt;typename T&gt;
613      struct always_false : std::false_type {};
614      template &lt;typename&gt; struct true_given : std::true_type {};
615      struct is_callable_tester {
616          template &lt;typename Fun, typename... Args&gt;
617          true_given&lt;decltype(std::declval&lt;Fun&gt;()(std::declval&lt;Args&gt;()...))&gt; static test(int);
618          template &lt;typename...&gt;
619          std::false_type static test(...);
620      };
621      template &lt;typename T&gt;
622      struct is_callable;
623      template &lt;typename Fun, typename... Args&gt;
624      struct is_callable&lt;Fun(Args...)&gt; : decltype(is_callable_tester::test&lt;Fun, Args...&gt;(0)) {};
625  #if defined(__cpp_lib_is_invocable) &amp;&amp; __cpp_lib_is_invocable &gt;= 201703
626      template &lt;typename Func, typename... U&gt;
627      using FunctionReturnType = std::remove_reference_t&lt;std::remove_cv_t&lt;std::invoke_result_t&lt;Func, U...&gt;&gt;&gt;;
628  #else
629      template &lt;typename Func, typename... U&gt;
630      using FunctionReturnType = typename std::remove_reference&lt;typename std::remove_cv&lt;typename std::result_of&lt;Func(U...)&gt;::type&gt;::type&gt;::type;
631  #endif
632  } 
633  namespace mpl_{
634      struct na;
635  }
636  namespace Catch {
637  template&lt;typename C&gt;
638  class TestInvokerAsMethod : public ITestInvoker {
639      void (C::*m_testAsMethod)();
640  public:
641      TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
642      void invoke() const override {
643          C obj;
644          (obj.*m_testAsMethod)();
645      }
646  };
647  auto makeTestInvoker( void(*testAsFunction)() ) noexcept -&gt; ITestInvoker*;
648  template&lt;typename C&gt;
649  auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -&gt; ITestInvoker* {
650      return new(std::nothrow) TestInvokerAsMethod&lt;C&gt;( testAsMethod );
651  }
652  struct NameAndTags {
653      NameAndTags( StringRef const&amp; name_ = StringRef(), StringRef const&amp; tags_ = StringRef() ) noexcept;
654      StringRef name;
655      StringRef tags;
656  };
657  struct AutoReg : NonCopyable {
658      AutoReg( ITestInvoker* invoker, SourceLineInfo const&amp; lineInfo, StringRef const&amp; classOrMethod, NameAndTags const&amp; nameAndTags ) noexcept;
659      ~AutoReg();
660  };
661  } 
662  #if defined(CATCH_CONFIG_DISABLE)
663      #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
664          static void TestName()
665      #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
666          namespace{                        \
667              struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
668                  void test();              \
669              };                            \
670          }                                 \
671          void TestName::test()
672      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \
673          INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))
674      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \
675          namespace{                                                                                  \
676              namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \
677              INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
678          }                                                                                           \
679          }                                                                                           \
680          INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
681      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
682          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
683              INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
684      #else
685          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
686              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
687      #endif
688      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
689          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
690              INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
691      #else
692          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
693              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
694      #endif
695      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
696          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
697              INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
698      #else
699          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
700              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
701      #endif
702      #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
703          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
704              INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
705      #else
706          #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
707              INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
708      #endif
709  #endif
710      #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
711          static void TestName(); \
712          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
713          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
714          namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &amp;TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } &amp;bsol;* NOLINT */ \
715          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
716          static void TestName()
717      #define INTERNAL_CATCH_TESTCASE( ... ) \
718          INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
719      #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
720          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
721          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
722          namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &amp;QualifiedMethod ), CATCH_INTERNAL_LINEINFO, &quot;&amp;&quot; #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } &amp;bsol;* NOLINT */ \
723          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
724      #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
725          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
726          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
727          namespace{ \
728              struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
729                  void test(); \
730              }; \
731              Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &amp;TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); &amp;bsol;* NOLINT */ \
732          } \
733          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
734          void TestName::test()
735      #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
736          INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
737      #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
738          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
739          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
740          Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); &amp;bsol;* NOLINT */ \
741          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
742      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
743          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
744          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
745          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
746          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
747          INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
748          namespace {\
749          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
750              INTERNAL_CATCH_TYPE_GEN\
751              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
752              INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\
753              template&lt;typename...Types&gt; \
754              struct TestName{\
755                  TestName(){\
756                      int index = 0;                                    \
757                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
758                      using expander = int[];\
759                      (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index]), Tags } ), index++)... };&amp;bsol;* NOLINT */ \
760                  }\
761              };\
762              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
763              TestName&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)&gt;();\
764              return 0;\
765          }();\
766          }\
767          }\
768          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
769          INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))
770  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
771      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
772          INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
773  #else
774      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
775          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
776  #endif
777  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
778      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
779          INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
780  #else
781      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
782          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
783  #endif
784      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
785          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
786          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
787          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
788          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS              \
789          template&lt;typename TestType&gt; static void TestFuncName();       \
790          namespace {\
791          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \
792              INTERNAL_CATCH_TYPE_GEN                                                  \
793              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \
794              template&lt;typename... Types&gt;                               \
795              struct TestName {                                         \
796                  void reg_tests() {                                          \
797                      int index = 0;                                    \
798                      using expander = int[];                           \
799                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
800                      constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
801                      constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
802                      (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestFuncName&lt;Types&gt; ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index / num_types]) + &quot;&lt;&quot; + std::string(types_list[index % num_types]) + &quot;&gt;&quot;, Tags } ), index++)... };&amp;bsol;* NOLINT */\
803                  }                                                     \
804              };                                                        \
805              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
806                  using TestInit = typename create&lt;TestName, decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)&gt;()), TypeList&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))&gt;&gt;::type; \
807                  TestInit t;                                           \
808                  t.reg_tests();                                        \
809                  return 0;                                             \
810              }();                                                      \
811          }                                                             \
812          }                                                             \
813          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
814          template&lt;typename TestType&gt;                                   \
815          static void TestFuncName()
816  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
817      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
818          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)
819  #else
820      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
821          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )
822  #endif
823  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
824      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
825          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)
826  #else
827      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
828          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
829  #endif
830      #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
831          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
832          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
833          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
834          template&lt;typename TestType&gt; static void TestFunc();       \
835          namespace {\
836          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
837          INTERNAL_CATCH_TYPE_GEN\
838          template&lt;typename... Types&gt;                               \
839          struct TestName {                                         \
840              void reg_tests() {                                          \
841                  int index = 0;                                    \
842                  using expander = int[];                           \
843                  (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestFunc&lt;Types&gt; ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name &quot; - &quot; + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + &quot; - &quot; + std::to_string(index), Tags } ), index++)... };&amp;bsol;* NOLINT */\
844              }                                                     \
845          };\
846          static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
847                  using TestInit = typename convert&lt;TestName, TmplList&gt;::type; \
848                  TestInit t;                                           \
849                  t.reg_tests();                                        \
850                  return 0;                                             \
851              }();                                                      \
852          }}\
853          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
854          template&lt;typename TestType&gt;                                   \
855          static void TestFunc()
856      #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
857          INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )
858      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
859          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
860          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
861          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
862          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
863          namespace {\
864          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
865              INTERNAL_CATCH_TYPE_GEN\
866              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
867              INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
868              INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\
869              template&lt;typename...Types&gt; \
870              struct TestNameClass{\
871                  TestNameClass(){\
872                      int index = 0;                                    \
873                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
874                      using expander = int[];\
875                      (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index]), Tags } ), index++)... };&amp;bsol;* NOLINT */ \
876                  }\
877              };\
878              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
879                  TestNameClass&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)&gt;();\
880                  return 0;\
881          }();\
882          }\
883          }\
884          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
885          INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
886  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
887      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
888          INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
889  #else
890      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
891          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
892  #endif
893  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
894      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
895          INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
896  #else
897      #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
898          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
899  #endif
900      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
901          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
902          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
903          CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
904          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
905          template&lt;typename TestType&gt; \
906              struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName &lt;TestType&gt;) { \
907                  void test();\
908              };\
909          namespace {\
910          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\
911              INTERNAL_CATCH_TYPE_GEN                  \
912              INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
913              template&lt;typename...Types&gt;\
914              struct TestNameClass{\
915                  void reg_tests(){\
916                      int index = 0;\
917                      using expander = int[];\
918                      constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
919                      constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
920                      constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
921                      (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestName&lt;Types&gt;::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index / num_types]) + &quot;&lt;&quot; + std::string(types_list[index % num_types]) + &quot;&gt;&quot;, Tags } ), index++)... };&amp;bsol;* NOLINT */ \
922                  }\
923              };\
924              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
925                  using TestInit = typename create&lt;TestNameClass, decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)&gt;()), TypeList&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))&gt;&gt;::type;\
926                  TestInit t;\
927                  t.reg_tests();\
928                  return 0;\
929              }(); \
930          }\
931          }\
932          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
933          template&lt;typename TestType&gt; \
934          void TestName&lt;TestType&gt;::test()
935  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
936      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
937          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
938  #else
939      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
940          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
941  #endif
942  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
943      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
944          INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
945  #else
946      #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
947          INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
948  #endif
949      #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
950          CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
951          CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
952          CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
953          template&lt;typename TestType&gt; \
954          struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName &lt;TestType&gt;) { \
955              void test();\
956          };\
957          namespace {\
958          namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
959              INTERNAL_CATCH_TYPE_GEN\
960              template&lt;typename...Types&gt;\
961              struct TestNameClass{\
962                  void reg_tests(){\
963                      int index = 0;\
964                      using expander = int[];\
965                      (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestName&lt;Types&gt;::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + &quot; - &quot; + std::to_string(index), Tags } ), index++)... };&amp;bsol;* NOLINT */ \
966                  }\
967              };\
968              static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
969                  using TestInit = typename convert&lt;TestNameClass, TmplList&gt;::type;\
970                  TestInit t;\
971                  t.reg_tests();\
972                  return 0;\
973              }(); \
974          }}\
975          CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
976          template&lt;typename TestType&gt; \
977          void TestName&lt;TestType&gt;::test()
978  #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
979          INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )
980  namespace Catch {
981      struct ResultWas { enum OfType {
982          Unknown = -1,
983          Ok = 0,
984          Info = 1,
985          Warning = 2,
986          FailureBit = 0x10,
987          ExpressionFailed = FailureBit | 1,
988          ExplicitFailure = FailureBit | 2,
989          Exception = 0x100 | FailureBit,
990          ThrewException = Exception | 1,
991          DidntThrowException = Exception | 2,
992          FatalErrorCondition = 0x200 | FailureBit
993      }; };
994      bool isOk( ResultWas::OfType resultType );
995      bool isJustInfo( int flags );
996      struct ResultDisposition { enum Flags {
997          Normal = 0x01,
998          ContinueOnFailure = 0x02,   
999          FalseTest = 0x04,           
1000          SuppressFail = 0x08         
1001      }; };
1002      ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
1003      bool shouldContinueOnFailure( int flags );
1004      inline bool isFalseTest( int flags ) { return ( flags &amp; ResultDisposition::FalseTest ) != 0; }
1005      bool shouldSuppressFailure( int flags );
1006  } 
1007  namespace Catch {
1008      struct AssertionInfo
1009      {
1010          StringRef macroName;
1011          SourceLineInfo lineInfo;
1012          StringRef capturedExpression;
1013          ResultDisposition::Flags resultDisposition;
1014      };
1015  } 
1016  #include &lt;vector&gt;
1017  #include &lt;cstddef&gt;
1018  #include &lt;type_traits&gt;
1019  #include &lt;string&gt;
1020  #include &lt;iosfwd&gt;
1021  #include &lt;cstddef&gt;
1022  #include &lt;ostream&gt;
1023  namespace Catch {
1024      std::ostream&amp; cout();
1025      std::ostream&amp; cerr();
1026      std::ostream&amp; clog();
1027      class StringRef;
1028      struct IStream {
1029          virtual ~IStream();
1030          virtual std::ostream&amp; stream() const = 0;
1031      };
1032      auto makeStream( StringRef const &amp;filename ) -&gt; IStream const*;
1033      class ReusableStringStream : NonCopyable {
1034          std::size_t m_index;
1035          std::ostream* m_oss;
1036      public:
1037          ReusableStringStream();
1038          ~ReusableStringStream();
1039          auto str() const -&gt; std::string;
1040          template&lt;typename T&gt;
1041          auto operator &lt;&lt; ( T const&amp; value ) -&gt; ReusableStringStream&amp; {
1042              *m_oss &lt;&lt; value;
1043              return *this;
1044          }
1045          auto get() -&gt; std::ostream&amp; { return *m_oss; }
1046      };
1047  }
1048  #include &lt;vector&gt;
1049  namespace Catch {
1050      namespace Detail {
1051          struct EnumInfo {
1052              StringRef m_name;
1053              std::vector&lt;std::pair&lt;int, StringRef&gt;&gt; m_values;
1054              ~EnumInfo();
1055              StringRef lookup( int value ) const;
1056          };
1057      } 
1058      struct IMutableEnumValuesRegistry {
1059          virtual ~IMutableEnumValuesRegistry();
1060          virtual Detail::EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::vector&lt;int&gt; const&amp; values ) = 0;
1061          template&lt;typename E&gt;
1062          Detail::EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list&lt;E&gt; values ) {
1063              static_assert(sizeof(int) &gt;= sizeof(E), &quot;Cannot serialize enum to int&quot;);
1064              std::vector&lt;int&gt; intValues;
1065              intValues.reserve( values.size() );
1066              for( auto enumValue : values )
1067                  intValues.push_back( static_cast&lt;int&gt;( enumValue ) );
1068              return registerEnum( enumName, allEnums, intValues );
1069          }
1070      };
1071  } 
1072  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
1073  #include &lt;string_view&gt;
1074  #endif
1075  #ifdef __OBJC__
1076  #import &lt;Foundation/Foundation.h&gt;
1077  #ifdef __has_feature
1078  #define CATCH_ARC_ENABLED __has_feature(objc_arc)
1079  #else
1080  #define CATCH_ARC_ENABLED 0
1081  #endif
1082  void arcSafeRelease( NSObject* obj );
1083  id performOptionalSelector( id obj, SEL sel );
1084  #if !CATCH_ARC_ENABLED
1085  inline void arcSafeRelease( NSObject* obj ) {
1086      [obj release];
1087  }
1088  inline id performOptionalSelector( id obj, SEL sel ) {
1089      if( [obj respondsToSelector: sel] )
1090          return [obj performSelector: sel];
1091      return nil;
1092  }
1093  #define CATCH_UNSAFE_UNRETAINED
1094  #define CATCH_ARC_STRONG
1095  #else
1096  inline void arcSafeRelease( NSObject* ){}
1097  inline id performOptionalSelector( id obj, SEL sel ) {
1098  #ifdef __clang__
1099  #pragma clang diagnostic push
1100  #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;
1101  #endif
1102      if( [obj respondsToSelector: sel] )
1103          return [obj performSelector: sel];
1104  #ifdef __clang__
1105  #pragma clang diagnostic pop
1106  #endif
1107      return nil;
1108  }
1109  #define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
1110  #define CATCH_ARC_STRONG __strong
1111  #endif
1112  #endif
1113  #ifdef _MSC_VER
1114  #pragma warning(push)
1115  #pragma warning(disable:4180) 
1116  #endif
1117  namespace Catch {
1118      namespace Detail {
1119          extern const std::string unprintableString;
1120          std::string rawMemoryToString( const void *object, std::size_t size );
1121          template&lt;typename T&gt;
1122          std::string rawMemoryToString( const T&amp; object ) {
1123            return rawMemoryToString( &amp;object, sizeof(object) );
1124          }
1125          template&lt;typename T&gt;
1126          class IsStreamInsertable {
1127              template&lt;typename Stream, typename U&gt;
1128              static auto test(int)
1129                  -&gt; decltype(std::declval&lt;Stream&amp;&gt;() &lt;&lt; std::declval&lt;U&gt;(), std::true_type());
1130              template&lt;typename, typename&gt;
1131              static auto test(...)-&gt;std::false_type;
1132          public:
1133              static const bool value = decltype(test&lt;std::ostream, const T&amp;&gt;(0))::value;
1134          };
1135          template&lt;typename E&gt;
1136          std::string convertUnknownEnumToString( E e );
1137          template&lt;typename T&gt;
1138          typename std::enable_if&lt;
1139              !std::is_enum&lt;T&gt;::value &amp;&amp; !std::is_base_of&lt;std::exception, T&gt;::value,
1140          std::string&gt;::type convertUnstreamable( T const&amp; ) {
1141              return Detail::unprintableString;
1142          }
1143          template&lt;typename T&gt;
1144          typename std::enable_if&lt;
1145              !std::is_enum&lt;T&gt;::value &amp;&amp; std::is_base_of&lt;std::exception, T&gt;::value,
1146           std::string&gt;::type convertUnstreamable(T const&amp; ex) {
1147              return ex.what();
1148          }
1149          template&lt;typename T&gt;
1150          typename std::enable_if&lt;
1151              std::is_enum&lt;T&gt;::value
1152          , std::string&gt;::type convertUnstreamable( T const&amp; value ) {
1153              return convertUnknownEnumToString( value );
1154          }
1155  #if defined(_MANAGED)
1156          template&lt;typename T&gt;
1157          std::string clrReferenceToString( T^ ref ) {
1158              if (ref == nullptr)
1159                  return std::string(&quot;null&quot;);
1160              auto bytes = System::Text::Encoding::UTF8-&gt;GetBytes(ref-&gt;ToString());
1161              cli::pin_ptr&lt;System::Byte&gt; p = &amp;bytes[0];
1162              return std::string(reinterpret_cast&lt;char const *&gt;(p), bytes-&gt;Length);
1163          }
1164  #endif
1165      } 
1166      template &lt;typename T, typename = void&gt;
1167      struct StringMaker {
1168          template &lt;typename Fake = T&gt;
1169          static
1170          typename std::enable_if&lt;::Catch::Detail::IsStreamInsertable&lt;Fake&gt;::value, std::string&gt;::type
1171              convert(const Fake&amp; value) {
1172                  ReusableStringStream rss;
1173                  rss.operator&lt;&lt;(value);
1174                  return rss.str();
1175          }
1176          template &lt;typename Fake = T&gt;
1177          static
1178          typename std::enable_if&lt;!::Catch::Detail::IsStreamInsertable&lt;Fake&gt;::value, std::string&gt;::type
1179              convert( const Fake&amp; value ) {
1180  #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
1181              return Detail::convertUnstreamable(value);
1182  #else
1183              return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
1184  #endif
1185          }
1186      };
1187      namespace Detail {
1188          template &lt;typename T&gt;
1189          std::string stringify(const T&amp; e) {
1190              return ::Catch::StringMaker&lt;typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::convert(e);
1191          }
1192          template&lt;typename E&gt;
1193          std::string convertUnknownEnumToString( E e ) {
1194              return ::Catch::Detail::stringify(static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e));
1195          }
1196  #if defined(_MANAGED)
1197          template &lt;typename T&gt;
1198          std::string stringify( T^ e ) {
1199              return ::Catch::StringMaker&lt;T^&gt;::convert(e);
1200          }
1201  #endif
1202      } 
1203      template&lt;&gt;
1204      struct StringMaker&lt;std::string&gt; {
1205          static std::string convert(const std::string&amp; str);
1206      };
1207  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
1208      template&lt;&gt;
1209      struct StringMaker&lt;std::string_view&gt; {
1210          static std::string convert(std::string_view str);
1211      };
1212  #endif
1213      template&lt;&gt;
1214      struct StringMaker&lt;char const *&gt; {
1215          static std::string convert(char const * str);
1216      };
1217      template&lt;&gt;
1218      struct StringMaker&lt;char *&gt; {
1219          static std::string convert(char * str);
1220      };
1221  #ifdef CATCH_CONFIG_WCHAR
1222      template&lt;&gt;
1223      struct StringMaker&lt;std::wstring&gt; {
1224          static std::string convert(const std::wstring&amp; wstr);
1225      };
1226  # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
1227      template&lt;&gt;
1228      struct StringMaker&lt;std::wstring_view&gt; {
1229          static std::string convert(std::wstring_view str);
1230      };
1231  # endif
1232      template&lt;&gt;
1233      struct StringMaker&lt;wchar_t const *&gt; {
1234          static std::string convert(wchar_t const * str);
1235      };
1236      template&lt;&gt;
1237      struct StringMaker&lt;wchar_t *&gt; {
1238          static std::string convert(wchar_t * str);
1239      };
1240  #endif
1241      template&lt;int SZ&gt;
1242      struct StringMaker&lt;char[SZ]&gt; {
1243          static std::string convert(char const* str) {
1244              return ::Catch::Detail::stringify(std::string{ str });
1245          }
1246      };
1247      template&lt;int SZ&gt;
1248      struct StringMaker&lt;signed char[SZ]&gt; {
1249          static std::string convert(signed char const* str) {
1250              return ::Catch::Detail::stringify(std::string{ reinterpret_cast&lt;char const *&gt;(str) });
1251          }
1252      };
1253      template&lt;int SZ&gt;
1254      struct StringMaker&lt;unsigned char[SZ]&gt; {
1255          static std::string convert(unsigned char const* str) {
1256              return ::Catch::Detail::stringify(std::string{ reinterpret_cast&lt;char const *&gt;(str) });
1257          }
1258      };
1259  #if defined(CATCH_CONFIG_CPP17_BYTE)
1260      template&lt;&gt;
1261      struct StringMaker&lt;std::byte&gt; {
1262          static std::string convert(std::byte value);
1263      };
1264  #endif 
1265      template&lt;&gt;
1266      struct StringMaker&lt;int&gt; {
1267          static std::string convert(int value);
1268      };
1269      template&lt;&gt;
1270      struct StringMaker&lt;long&gt; {
1271          static std::string convert(long value);
1272      };
1273      template&lt;&gt;
1274      struct StringMaker&lt;long long&gt; {
1275          static std::string convert(long long value);
1276      };
1277      template&lt;&gt;
1278      struct StringMaker&lt;unsigned int&gt; {
1279          static std::string convert(unsigned int value);
1280      };
1281      template&lt;&gt;
1282      struct StringMaker&lt;unsigned long&gt; {
1283          static std::string convert(unsigned long value);
1284      };
1285      template&lt;&gt;
1286      struct StringMaker&lt;unsigned long long&gt; {
1287          static std::string convert(unsigned long long value);
1288      };
1289      template&lt;&gt;
1290      struct StringMaker&lt;bool&gt; {
1291          static std::string convert(bool b);
1292      };
1293      template&lt;&gt;
1294      struct StringMaker&lt;char&gt; {
1295          static std::string convert(char c);
1296      };
1297      template&lt;&gt;
1298      struct StringMaker&lt;signed char&gt; {
1299          static std::string convert(signed char c);
1300      };
1301      template&lt;&gt;
1302      struct StringMaker&lt;unsigned char&gt; {
1303          static std::string convert(unsigned char c);
1304      };
1305      template&lt;&gt;
1306      struct StringMaker&lt;std::nullptr_t&gt; {
1307          static std::string convert(std::nullptr_t);
1308      };
1309      template&lt;&gt;
1310      struct StringMaker&lt;float&gt; {
1311          static std::string convert(float value);
1312          static int precision;
1313      };
1314      template&lt;&gt;
1315      struct StringMaker&lt;double&gt; {
1316          static std::string convert(double value);
1317          static int precision;
1318      };
1319      template &lt;typename T&gt;
1320      struct StringMaker&lt;T*&gt; {
1321          template &lt;typename U&gt;
1322          static std::string convert(U* p) {
1323              if (p) {
1324                  return ::Catch::Detail::rawMemoryToString(p);
1325              } else {
1326                  return &quot;nullptr&quot;;
1327              }
1328          }
1329      };
1330      template &lt;typename R, typename C&gt;
1331      struct StringMaker&lt;R C::*&gt; {
1332          static std::string convert(R C::* p) {
1333              if (p) {
1334                  return ::Catch::Detail::rawMemoryToString(p);
1335              } else {
1336                  return &quot;nullptr&quot;;
1337              }
1338          }
1339      };
1340  #if defined(_MANAGED)
1341      template &lt;typename T&gt;
1342      struct StringMaker&lt;T^&gt; {
1343          static std::string convert( T^ ref ) {
1344              return ::Catch::Detail::clrReferenceToString(ref);
1345          }
1346      };
1347  #endif
1348      namespace Detail {
1349          template&lt;typename InputIterator, typename Sentinel = InputIterator&gt;
1350          std::string rangeToString(InputIterator first, Sentinel last) {
1351              ReusableStringStream rss;
1352              rss &lt;&lt; &quot;{ &quot;;
1353              if (first != last) {
1354                  rss &lt;&lt; ::Catch::Detail::stringify(*first);
1355                  for (++first; first != last; ++first)
1356                      rss &lt;&lt; &quot;, &quot; &lt;&lt; ::Catch::Detail::stringify(*first);
1357              }
1358              rss &lt;&lt; &quot; }&quot;;
1359              return rss.str();
1360          }
1361      }
1362  #ifdef __OBJC__
1363      template&lt;&gt;
1364      struct StringMaker&lt;NSString*&gt; {
1365          static std::string convert(NSString * nsstring) {
1366              if (!nsstring)
1367                  return &quot;nil&quot;;
1368              return std::string(&quot;@&quot;) + [nsstring UTF8String];
1369          }
1370      };
1371      template&lt;&gt;
1372      struct StringMaker&lt;NSObject*&gt; {
1373          static std::string convert(NSObject* nsObject) {
1374              return ::Catch::Detail::stringify([nsObject description]);
1375          }
1376      };
1377      namespace Detail {
1378          inline std::string stringify( NSString* nsstring ) {
1379              return StringMaker&lt;NSString*&gt;::convert( nsstring );
1380          }
1381      } 
1382  #endif 
1383  } 
1384  #if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
1385  #  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
1386  #  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
1387  #  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
1388  #  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
1389  #  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
1390  #endif
1391  #if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
1392  #include &lt;utility&gt;
1393  namespace Catch {
1394      template&lt;typename T1, typename T2&gt;
1395      struct StringMaker&lt;std::pair&lt;T1, T2&gt; &gt; {
1396          static std::string convert(const std::pair&lt;T1, T2&gt;&amp; pair) {
1397              ReusableStringStream rss;
1398              rss &lt;&lt; &quot;{ &quot;
1399                  &lt;&lt; ::Catch::Detail::stringify(pair.first)
1400                  &lt;&lt; &quot;, &quot;
1401                  &lt;&lt; ::Catch::Detail::stringify(pair.second)
1402                  &lt;&lt; &quot; }&quot;;
1403              return rss.str();
1404          }
1405      };
1406  }
1407  #endif 
1408  #if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) &amp;&amp; defined(CATCH_CONFIG_CPP17_OPTIONAL)
1409  #include &lt;optional&gt;
1410  namespace Catch {
1411      template&lt;typename T&gt;
1412      struct StringMaker&lt;std::optional&lt;T&gt; &gt; {
1413          static std::string convert(const std::optional&lt;T&gt;&amp; optional) {
1414              ReusableStringStream rss;
1415              if (optional.has_value()) {
1416                  rss &lt;&lt; ::Catch::Detail::stringify(*optional);
1417              } else {
1418                  rss &lt;&lt; &quot;{ }&quot;;
1419              }
1420              return rss.str();
1421          }
1422      };
1423  }
1424  #endif 
1425  #if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
1426  #include &lt;tuple&gt;
1427  namespace Catch {
1428      namespace Detail {
1429          template&lt;
1430              typename Tuple,
1431              std::size_t N = 0,
1432              bool = (N &lt; std::tuple_size&lt;Tuple&gt;::value)
1433              &gt;
1434              struct TupleElementPrinter {
1435              static void print(const Tuple&amp; tuple, std::ostream&amp; os) {
1436                  os &lt;&lt; (N ? &quot;, &quot; : &quot; &quot;)
1437                      &lt;&lt; ::Catch::Detail::stringify(std::get&lt;N&gt;(tuple));
1438                  TupleElementPrinter&lt;Tuple, N + 1&gt;::print(tuple, os);
1439              }
1440          };
1441          template&lt;
1442              typename Tuple,
1443              std::size_t N
1444          &gt;
1445              struct TupleElementPrinter&lt;Tuple, N, false&gt; {
1446              static void print(const Tuple&amp;, std::ostream&amp;) {}
1447          };
1448      }
1449      template&lt;typename ...Types&gt;
1450      struct StringMaker&lt;std::tuple&lt;Types...&gt;&gt; {
1451          static std::string convert(const std::tuple&lt;Types...&gt;&amp; tuple) {
1452              ReusableStringStream rss;
1453              rss &lt;&lt; &#x27;{&#x27;;
1454              Detail::TupleElementPrinter&lt;std::tuple&lt;Types...&gt;&gt;::print(tuple, rss.get());
1455              rss &lt;&lt; &quot; }&quot;;
1456              return rss.str();
1457          }
1458      };
1459  }
1460  #endif 
1461  #if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) &amp;&amp; defined(CATCH_CONFIG_CPP17_VARIANT)
1462  #include &lt;variant&gt;
1463  namespace Catch {
1464      template&lt;&gt;
1465      struct StringMaker&lt;std::monostate&gt; {
1466          static std::string convert(const std::monostate&amp;) {
1467              return &quot;{ }&quot;;
1468          }
1469      };
1470      template&lt;typename... Elements&gt;
1471      struct StringMaker&lt;std::variant&lt;Elements...&gt;&gt; {
1472          static std::string convert(const std::variant&lt;Elements...&gt;&amp; variant) {
1473              if (variant.valueless_by_exception()) {
1474                  return &quot;{valueless variant}&quot;;
1475              } else {
1476                  return std::visit(
1477                      [](const auto&amp; value) {
1478                          return ::Catch::Detail::stringify(value);
1479                      },
1480                      variant
1481                  );
1482              }
1483          }
1484      };
1485  }
1486  #endif 
1487  namespace Catch {
1488      using std::begin;
1489      using std::end;
1490      namespace detail {
1491          template &lt;typename...&gt;
1492          struct void_type {
1493              using type = void;
1494          };
1495          template &lt;typename T, typename = void&gt;
1496          struct is_range_impl : std::false_type {
1497          };
1498          template &lt;typename T&gt;
1499          struct is_range_impl&lt;T, typename void_type&lt;decltype(begin(std::declval&lt;T&gt;()))&gt;::type&gt; : std::true_type {
1500          };
1501      } 
1502      template &lt;typename T&gt;
1503      struct is_range : detail::is_range_impl&lt;T&gt; {
1504      };
1505  #if defined(_MANAGED) 
1506      template &lt;typename T&gt;
1507      struct is_range&lt;T^&gt; {
1508          static const bool value = false;
1509      };
1510  #endif
1511      template&lt;typename Range&gt;
1512      std::string rangeToString( Range const&amp; range ) {
1513          return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
1514      }
1515      template&lt;typename Allocator&gt;
1516      std::string rangeToString( std::vector&lt;bool, Allocator&gt; const&amp; v ) {
1517          ReusableStringStream rss;
1518          rss &lt;&lt; &quot;{ &quot;;
1519          bool first = true;
1520          for( bool b : v ) {
1521              if( first )
1522                  first = false;
1523              else
1524                  rss &lt;&lt; &quot;, &quot;;
1525              rss &lt;&lt; ::Catch::Detail::stringify( b );
1526          }
1527          rss &lt;&lt; &quot; }&quot;;
1528          return rss.str();
1529      }
1530      template&lt;typename R&gt;
1531      struct StringMaker&lt;R, typename std::enable_if&lt;is_range&lt;R&gt;::value &amp;&amp; !::Catch::Detail::IsStreamInsertable&lt;R&gt;::value&gt;::type&gt; {
1532          static std::string convert( R const&amp; range ) {
1533              return rangeToString( range );
1534          }
1535      };
1536      template &lt;typename T, int SZ&gt;
1537      struct StringMaker&lt;T[SZ]&gt; {
1538          static std::string convert(T const(&amp;arr)[SZ]) {
1539              return rangeToString(arr);
1540          }
1541      };
1542  } 
1543  #if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
1544  #include &lt;ctime&gt;
1545  #include &lt;ratio&gt;
1546  #include &lt;chrono&gt;
1547  namespace Catch {
1548  template &lt;class Ratio&gt;
1549  struct ratio_string {
1550      static std::string symbol();
1551  };
1552  template &lt;class Ratio&gt;
1553  std::string ratio_string&lt;Ratio&gt;::symbol() {
1554      Catch::ReusableStringStream rss;
1555      rss &lt;&lt; &#x27;[&#x27; &lt;&lt; Ratio::num &lt;&lt; &#x27;/&#x27;
1556          &lt;&lt; Ratio::den &lt;&lt; &#x27;]&#x27;;
1557      return rss.str();
1558  }
1559  template &lt;&gt;
1560  struct ratio_string&lt;std::atto&gt; {
1561      static std::string symbol();
1562  };
1563  template &lt;&gt;
1564  struct ratio_string&lt;std::femto&gt; {
1565      static std::string symbol();
1566  };
1567  template &lt;&gt;
1568  struct ratio_string&lt;std::pico&gt; {
1569      static std::string symbol();
1570  };
1571  template &lt;&gt;
1572  struct ratio_string&lt;std::nano&gt; {
1573      static std::string symbol();
1574  };
1575  template &lt;&gt;
1576  struct ratio_string&lt;std::micro&gt; {
1577      static std::string symbol();
1578  };
1579  template &lt;&gt;
1580  struct ratio_string&lt;std::milli&gt; {
1581      static std::string symbol();
1582  };
1583      template&lt;typename Value, typename Ratio&gt;
1584      struct StringMaker&lt;std::chrono::duration&lt;Value, Ratio&gt;&gt; {
1585          static std::string convert(std::chrono::duration&lt;Value, Ratio&gt; const&amp; duration) {
1586              ReusableStringStream rss;
1587              rss &lt;&lt; duration.count() &lt;&lt; &#x27; &#x27; &lt;&lt; ratio_string&lt;Ratio&gt;::symbol() &lt;&lt; &#x27;s&#x27;;
1588              return rss.str();
1589          }
1590      };
1591      template&lt;typename Value&gt;
1592      struct StringMaker&lt;std::chrono::duration&lt;Value, std::ratio&lt;1&gt;&gt;&gt; {
1593          static std::string convert(std::chrono::duration&lt;Value, std::ratio&lt;1&gt;&gt; const&amp; duration) {
1594              ReusableStringStream rss;
1595              rss &lt;&lt; duration.count() &lt;&lt; &quot; s&quot;;
1596              return rss.str();
1597          }
1598      };
1599      template&lt;typename Value&gt;
1600      struct StringMaker&lt;std::chrono::duration&lt;Value, std::ratio&lt;60&gt;&gt;&gt; {
1601          static std::string convert(std::chrono::duration&lt;Value, std::ratio&lt;60&gt;&gt; const&amp; duration) {
1602              ReusableStringStream rss;
1603              rss &lt;&lt; duration.count() &lt;&lt; &quot; m&quot;;
1604              return rss.str();
1605          }
1606      };
1607      template&lt;typename Value&gt;
1608      struct StringMaker&lt;std::chrono::duration&lt;Value, std::ratio&lt;3600&gt;&gt;&gt; {
1609          static std::string convert(std::chrono::duration&lt;Value, std::ratio&lt;3600&gt;&gt; const&amp; duration) {
1610              ReusableStringStream rss;
1611              rss &lt;&lt; duration.count() &lt;&lt; &quot; h&quot;;
1612              return rss.str();
1613          }
1614      };
1615      template&lt;typename Clock, typename Duration&gt;
1616      struct StringMaker&lt;std::chrono::time_point&lt;Clock, Duration&gt;&gt; {
1617          static std::string convert(std::chrono::time_point&lt;Clock, Duration&gt; const&amp; time_point) {
1618              return ::Catch::Detail::stringify(time_point.time_since_epoch()) + &quot; since epoch&quot;;
1619          }
1620      };
1621      template&lt;typename Duration&gt;
1622      struct StringMaker&lt;std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt;&gt; {
1623          static std::string convert(std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt; const&amp; time_point) {
1624              auto converted = std::chrono::system_clock::to_time_t(time_point);
1625  #ifdef _MSC_VER
1626              std::tm timeInfo = {};
1627              gmtime_s(&amp;timeInfo, &amp;converted);
1628  #else
1629              std::tm* timeInfo = std::gmtime(&amp;converted);
1630  #endif
1631              auto const timeStampSize = sizeof(&quot;2017-01-16T17:06:45Z&quot;);
1632              char timeStamp[timeStampSize];
1633              const char * const fmt = &quot;%Y-%m-%dT%H:%M:%SZ&quot;;
1634  #ifdef _MSC_VER
1635              std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
1636  #else
1637              std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
1638  #endif
1639              return std::string(timeStamp);
1640          }
1641      };
1642  }
1643  #endif 
1644  #define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \
1645  namespace Catch { \
1646      template&lt;&gt; struct StringMaker&lt;enumName&gt; { \
1647          static std::string convert( enumName value ) { \
1648              static const auto&amp; enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \
1649              return static_cast&lt;std::string&gt;(enumInfo.lookup( static_cast&lt;int&gt;( value ) )); \
1650          } \
1651      }; \
1652  }
1653  #define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )
1654  #ifdef _MSC_VER
1655  #pragma warning(pop)
1656  #endif
1657  #include &lt;iosfwd&gt;
1658  #ifdef _MSC_VER
1659  #pragma warning(push)
1660  #pragma warning(disable:4389) 
1661  #pragma warning(disable:4018) 
1662  #pragma warning(disable:4312) 
1663  #pragma warning(disable:4180) 
1664  #pragma warning(disable:4800) 
1665  #endif
1666  namespace Catch {
1667      struct ITransientExpression {
1668          auto isBinaryExpression() const -&gt; bool { return m_isBinaryExpression; }
1669          auto getResult() const -&gt; bool { return m_result; }
1670          virtual void streamReconstructedExpression( std::ostream &amp;os ) const = 0;
1671          ITransientExpression( bool isBinaryExpression, bool result )
1672          :   m_isBinaryExpression( isBinaryExpression ),
1673              m_result( result )
1674          {}
1675          virtual ~ITransientExpression();
1676          bool m_isBinaryExpression;
1677          bool m_result;
1678      };
1679      void formatReconstructedExpression( std::ostream &amp;os, std::string const&amp; lhs, StringRef op, std::string const&amp; rhs );
1680      template&lt;typename LhsT, typename RhsT&gt;
1681      class BinaryExpr  : public ITransientExpression {
1682          LhsT m_lhs;
1683          StringRef m_op;
1684          RhsT m_rhs;
1685          void streamReconstructedExpression( std::ostream &amp;os ) const override {
1686              formatReconstructedExpression
1687                      ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
1688          }
1689      public:
1690          BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
1691          :   ITransientExpression{ true, comparisonResult },
1692              m_lhs( lhs ),
1693              m_op( op ),
1694              m_rhs( rhs )
1695          {}
1696          template&lt;typename T&gt;
1697          auto operator &amp;&amp; ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1698              static_assert(always_false&lt;T&gt;::value,
1699              &quot;chained comparisons are not supported inside assertions, &quot;
1700              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1701          }
1702          template&lt;typename T&gt;
1703          auto operator || ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1704              static_assert(always_false&lt;T&gt;::value,
1705              &quot;chained comparisons are not supported inside assertions, &quot;
1706              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1707          }
1708          template&lt;typename T&gt;
1709          auto operator == ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1710              static_assert(always_false&lt;T&gt;::value,
1711              &quot;chained comparisons are not supported inside assertions, &quot;
1712              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1713          }
1714          template&lt;typename T&gt;
1715          auto operator != ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1716              static_assert(always_false&lt;T&gt;::value,
1717              &quot;chained comparisons are not supported inside assertions, &quot;
1718              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1719          }
1720          template&lt;typename T&gt;
1721          auto operator &gt; ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1722              static_assert(always_false&lt;T&gt;::value,
1723              &quot;chained comparisons are not supported inside assertions, &quot;
1724              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1725          }
1726          template&lt;typename T&gt;
1727          auto operator &lt; ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1728              static_assert(always_false&lt;T&gt;::value,
1729              &quot;chained comparisons are not supported inside assertions, &quot;
1730              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1731          }
1732          template&lt;typename T&gt;
1733          auto operator &gt;= ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1734              static_assert(always_false&lt;T&gt;::value,
1735              &quot;chained comparisons are not supported inside assertions, &quot;
1736              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1737          }
1738          template&lt;typename T&gt;
1739          auto operator &lt;= ( T ) const -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1740              static_assert(always_false&lt;T&gt;::value,
1741              &quot;chained comparisons are not supported inside assertions, &quot;
1742              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1743          }
1744      };
1745      template&lt;typename LhsT&gt;
1746      class UnaryExpr : public ITransientExpression {
1747          LhsT m_lhs;
1748          void streamReconstructedExpression( std::ostream &amp;os ) const override {
1749              os &lt;&lt; Catch::Detail::stringify( m_lhs );
1750          }
1751      public:
1752          explicit UnaryExpr( LhsT lhs )
1753          :   ITransientExpression{ false, static_cast&lt;bool&gt;(lhs) },
1754              m_lhs( lhs )
1755          {}
1756      };
1757      template&lt;typename LhsT, typename RhsT&gt;
1758      auto compareEqual( LhsT const&amp; lhs, RhsT const&amp; rhs ) -&gt; bool { return static_cast&lt;bool&gt;(lhs == rhs); }
1759      template&lt;typename T&gt;
1760      auto compareEqual( T* const&amp; lhs, int rhs ) -&gt; bool { return lhs == reinterpret_cast&lt;void const*&gt;( rhs ); }
1761      template&lt;typename T&gt;
1762      auto compareEqual( T* const&amp; lhs, long rhs ) -&gt; bool { return lhs == reinterpret_cast&lt;void const*&gt;( rhs ); }
1763      template&lt;typename T&gt;
1764      auto compareEqual( int lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) == rhs; }
1765      template&lt;typename T&gt;
1766      auto compareEqual( long lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) == rhs; }
1767      template&lt;typename LhsT, typename RhsT&gt;
1768      auto compareNotEqual( LhsT const&amp; lhs, RhsT&amp;&amp; rhs ) -&gt; bool { return static_cast&lt;bool&gt;(lhs != rhs); }
1769      template&lt;typename T&gt;
1770      auto compareNotEqual( T* const&amp; lhs, int rhs ) -&gt; bool { return lhs != reinterpret_cast&lt;void const*&gt;( rhs ); }
1771      template&lt;typename T&gt;
1772      auto compareNotEqual( T* const&amp; lhs, long rhs ) -&gt; bool { return lhs != reinterpret_cast&lt;void const*&gt;( rhs ); }
1773      template&lt;typename T&gt;
1774      auto compareNotEqual( int lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) != rhs; }
1775      template&lt;typename T&gt;
1776      auto compareNotEqual( long lhs, T* const&amp; rhs ) -&gt; bool { return reinterpret_cast&lt;void const*&gt;( lhs ) != rhs; }
1777      template&lt;typename LhsT&gt;
1778      class ExprLhs {
1779          LhsT m_lhs;
1780      public:
1781          explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
1782          template&lt;typename RhsT&gt;
1783          auto operator == ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1784              return { compareEqual( m_lhs, rhs ), m_lhs, &quot;==&quot;, rhs };
1785          }
1786          auto operator == ( bool rhs ) -&gt; BinaryExpr&lt;LhsT, bool&gt; const {
1787              return { m_lhs == rhs, m_lhs, &quot;==&quot;, rhs };
1788          }
1789          template&lt;typename RhsT&gt;
1790          auto operator != ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1791              return { compareNotEqual( m_lhs, rhs ), m_lhs, &quot;!=&quot;, rhs };
1792          }
1793          auto operator != ( bool rhs ) -&gt; BinaryExpr&lt;LhsT, bool&gt; const {
1794              return { m_lhs != rhs, m_lhs, &quot;!=&quot;, rhs };
1795          }
1796          template&lt;typename RhsT&gt;
1797          auto operator &gt; ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1798              return { static_cast&lt;bool&gt;(m_lhs &gt; rhs), m_lhs, &quot;&gt;&quot;, rhs };
1799          }
1800          template&lt;typename RhsT&gt;
1801          auto operator &lt; ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1802              return { static_cast&lt;bool&gt;(m_lhs &lt; rhs), m_lhs, &quot;&lt;&quot;, rhs };
1803          }
1804          template&lt;typename RhsT&gt;
1805          auto operator &gt;= ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1806              return { static_cast&lt;bool&gt;(m_lhs &gt;= rhs), m_lhs, &quot;&gt;=&quot;, rhs };
1807          }
1808          template&lt;typename RhsT&gt;
1809          auto operator &lt;= ( RhsT const&amp; rhs ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1810              return { static_cast&lt;bool&gt;(m_lhs &lt;= rhs), m_lhs, &quot;&lt;=&quot;, rhs };
1811          }
1812          template &lt;typename RhsT&gt;
1813          auto operator | (RhsT const&amp; rhs) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1814              return { static_cast&lt;bool&gt;(m_lhs | rhs), m_lhs, &quot;|&quot;, rhs };
1815          }
1816          template &lt;typename RhsT&gt;
1817          auto operator &amp; (RhsT const&amp; rhs) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1818              return { static_cast&lt;bool&gt;(m_lhs &amp; rhs), m_lhs, &quot;&amp;&quot;, rhs };
1819          }
1820          template &lt;typename RhsT&gt;
1821          auto operator ^ (RhsT const&amp; rhs) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1822              return { static_cast&lt;bool&gt;(m_lhs ^ rhs), m_lhs, &quot;^&quot;, rhs };
1823          }
1824          template&lt;typename RhsT&gt;
1825          auto operator &amp;&amp; ( RhsT const&amp; ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1826              static_assert(always_false&lt;RhsT&gt;::value,
1827              &quot;operator&amp;&amp; is not supported inside assertions, &quot;
1828              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1829          }
1830          template&lt;typename RhsT&gt;
1831          auto operator || ( RhsT const&amp; ) -&gt; BinaryExpr&lt;LhsT, RhsT const&amp;&gt; const {
1832              static_assert(always_false&lt;RhsT&gt;::value,
1833              &quot;operator|| is not supported inside assertions, &quot;
1834              &quot;wrap the expression inside parentheses, or decompose it&quot;);
1835          }
1836          auto makeUnaryExpr() const -&gt; UnaryExpr&lt;LhsT&gt; {
1837              return UnaryExpr&lt;LhsT&gt;{ m_lhs };
1838          }
1839      };
1840      void handleExpression( ITransientExpression const&amp; expr );
1841      template&lt;typename T&gt;
1842      void handleExpression( ExprLhs&lt;T&gt; const&amp; expr ) {
1843          handleExpression( expr.makeUnaryExpr() );
1844      }
1845      struct Decomposer {
1846          template&lt;typename T&gt;
1847          auto operator &lt;= ( T const&amp; lhs ) -&gt; ExprLhs&lt;T const&amp;&gt; {
1848              return ExprLhs&lt;T const&amp;&gt;{ lhs };
1849          }
1850          auto operator &lt;=( bool value ) -&gt; ExprLhs&lt;bool&gt; {
1851              return ExprLhs&lt;bool&gt;{ value };
1852          }
1853      };
1854  } 
1855  #ifdef _MSC_VER
1856  #pragma warning(pop)
1857  #endif
1858  #include &lt;string&gt;
1859  #include &lt;chrono&gt;
1860  namespace Catch {
1861      class AssertionResult;
1862      struct AssertionInfo;
1863      struct SectionInfo;
1864      struct SectionEndInfo;
1865      struct MessageInfo;
1866      struct MessageBuilder;
1867      struct Counts;
1868      struct AssertionReaction;
1869      struct SourceLineInfo;
1870      struct ITransientExpression;
1871      struct IGeneratorTracker;
1872  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
1873      struct BenchmarkInfo;
1874      template &lt;typename Duration = std::chrono::duration&lt;double, std::nano&gt;&gt;
1875      struct BenchmarkStats;
1876  #endif 
1877      struct IResultCapture {
1878          virtual ~IResultCapture();
1879          virtual bool sectionStarted(    SectionInfo const&amp; sectionInfo,
1880                                          Counts&amp; assertions ) = 0;
1881          virtual void sectionEnded( SectionEndInfo const&amp; endInfo ) = 0;
1882          virtual void sectionEndedEarly( SectionEndInfo const&amp; endInfo ) = 0;
1883          virtual auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; = 0;
1884  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
1885          virtual void benchmarkPreparing( std::string const&amp; name ) = 0;
1886          virtual void benchmarkStarting( BenchmarkInfo const&amp; info ) = 0;
1887          virtual void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) = 0;
1888          virtual void benchmarkFailed( std::string const&amp; error ) = 0;
1889  #endif 
1890          virtual void pushScopedMessage( MessageInfo const&amp; message ) = 0;
1891          virtual void popScopedMessage( MessageInfo const&amp; message ) = 0;
1892          virtual void emplaceUnscopedMessage( MessageBuilder const&amp; builder ) = 0;
1893          virtual void handleFatalErrorCondition( StringRef message ) = 0;
1894          virtual void handleExpr
1895                  (   AssertionInfo const&amp; info,
1896                      ITransientExpression const&amp; expr,
1897                      AssertionReaction&amp; reaction ) = 0;
1898          virtual void handleMessage
1899                  (   AssertionInfo const&amp; info,
1900                      ResultWas::OfType resultType,
1901                      StringRef const&amp; message,
1902                      AssertionReaction&amp; reaction ) = 0;
1903          virtual void handleUnexpectedExceptionNotThrown
1904                  (   AssertionInfo const&amp; info,
1905                      AssertionReaction&amp; reaction ) = 0;
1906          virtual void handleUnexpectedInflightException
1907                  (   AssertionInfo const&amp; info,
1908                      std::string const&amp; message,
1909                      AssertionReaction&amp; reaction ) = 0;
1910          virtual void handleIncomplete
1911                  (   AssertionInfo const&amp; info ) = 0;
1912          virtual void handleNonExpr
1913                  (   AssertionInfo const &amp;info,
1914                      ResultWas::OfType resultType,
1915                      AssertionReaction &amp;reaction ) = 0;
1916          virtual bool lastAssertionPassed() = 0;
1917          virtual void assertionPassed() = 0;
1918          virtual std::string getCurrentTestName() const = 0;
1919          virtual const AssertionResult* getLastResult() const = 0;
1920          virtual void exceptionEarlyReported() = 0;
1921      };
1922      IResultCapture&amp; getResultCapture();
1923  }
1924  namespace Catch {
1925      struct TestFailureException{};
1926      struct AssertionResultData;
1927      struct IResultCapture;
1928      class RunContext;
1929      class LazyExpression {
1930          friend class AssertionHandler;
1931          friend struct AssertionStats;
1932          friend class RunContext;
1933          ITransientExpression const* m_transientExpression = nullptr;
1934          bool m_isNegated;
1935      public:
1936          LazyExpression( bool isNegated );
1937          LazyExpression( LazyExpression const&amp; other );
1938          LazyExpression&amp; operator = ( LazyExpression const&amp; ) = delete;
1939          explicit operator bool() const;
1940          friend auto operator &lt;&lt; ( std::ostream&amp; os, LazyExpression const&amp; lazyExpr ) -&gt; std::ostream&amp;;
1941      };
1942      struct AssertionReaction {
1943          bool shouldDebugBreak = false;
1944          bool shouldThrow = false;
1945      };
1946      class AssertionHandler {
1947          AssertionInfo m_assertionInfo;
1948          AssertionReaction m_reaction;
1949          bool m_completed = false;
1950          IResultCapture&amp; m_resultCapture;
1951      public:
1952          AssertionHandler
1953              (   StringRef const&amp; macroName,
1954                  SourceLineInfo const&amp; lineInfo,
1955                  StringRef capturedExpression,
1956                  ResultDisposition::Flags resultDisposition );
1957          ~AssertionHandler() {
1958              if ( !m_completed ) {
1959                  m_resultCapture.handleIncomplete( m_assertionInfo );
1960              }
1961          }
1962          template&lt;typename T&gt;
1963          void handleExpr( ExprLhs&lt;T&gt; const&amp; expr ) {
1964              handleExpr( expr.makeUnaryExpr() );
1965          }
1966          void handleExpr( ITransientExpression const&amp; expr );
1967          void handleMessage(ResultWas::OfType resultType, StringRef const&amp; message);
1968          void handleExceptionThrownAsExpected();
1969          void handleUnexpectedExceptionNotThrown();
1970          void handleExceptionNotThrownAsExpected();
1971          void handleThrowingCallSkipped();
1972          void handleUnexpectedInflightException();
1973          void complete();
1974          void setCompleted();
1975          auto allowThrows() const -&gt; bool;
1976      };
1977      void handleExceptionMatchExpr( AssertionHandler&amp; handler, std::string const&amp; str, StringRef const&amp; matcherString );
1978  } 
1979  #include &lt;string&gt;
1980  #include &lt;vector&gt;
1981  namespace Catch {
1982      struct MessageInfo {
1983          MessageInfo(    StringRef const&amp; _macroName,
1984                          SourceLineInfo const&amp; _lineInfo,
1985                          ResultWas::OfType _type );
1986          StringRef macroName;
1987          std::string message;
1988          SourceLineInfo lineInfo;
1989          ResultWas::OfType type;
1990          unsigned int sequence;
1991          bool operator == ( MessageInfo const&amp; other ) const;
1992          bool operator &lt; ( MessageInfo const&amp; other ) const;
1993      private:
1994          static unsigned int globalCount;
1995      };
1996      struct MessageStream {
1997          template&lt;typename T&gt;
1998          MessageStream&amp; operator &lt;&lt; ( T const&amp; value ) {
1999              m_stream &lt;&lt; value;
2000              return *this;
2001          }
2002          ReusableStringStream m_stream;
2003      };
2004      struct MessageBuilder : MessageStream {
2005          MessageBuilder( StringRef const&amp; macroName,
2006                          SourceLineInfo const&amp; lineInfo,
2007                          ResultWas::OfType type );
2008          template&lt;typename T&gt;
2009          MessageBuilder&amp; operator &lt;&lt; ( T const&amp; value ) {
2010              m_stream &lt;&lt; value;
2011              return *this;
2012          }
2013          MessageInfo m_info;
2014      };
2015      class ScopedMessage {
2016      public:
2017          explicit ScopedMessage( MessageBuilder const&amp; builder );
2018          ScopedMessage( ScopedMessage&amp; duplicate ) = delete;
2019          ScopedMessage( ScopedMessage&amp;&amp; old );
2020          ~ScopedMessage();
2021          MessageInfo m_info;
2022          bool m_moved;
2023      };
2024      class Capturer {
2025          std::vector&lt;MessageInfo&gt; m_messages;
2026          IResultCapture&amp; m_resultCapture = getResultCapture();
2027          size_t m_captured = 0;
2028      public:
2029          Capturer( StringRef macroName, SourceLineInfo const&amp; lineInfo, ResultWas::OfType resultType, StringRef names );
2030          ~Capturer();
2031          void captureValue( size_t index, std::string const&amp; value );
2032          template&lt;typename T&gt;
2033          void captureValues( size_t index, T const&amp; value ) {
2034              captureValue( index, Catch::Detail::stringify( value ) );
2035          }
2036          template&lt;typename T, typename... Ts&gt;
2037          void captureValues( size_t index, T const&amp; value, Ts const&amp;... values ) {
2038              captureValue( index, Catch::Detail::stringify(value) );
2039              captureValues( index+1, values... );
2040          }
2041      };
2042  } 
2043  #if !defined(CATCH_CONFIG_DISABLE)
2044  #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
2045    #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
2046  #else
2047    #define CATCH_INTERNAL_STRINGIFY(...) &quot;Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION&quot;
2048  #endif
2049  #if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2050  #define INTERNAL_CATCH_TRY
2051  #define INTERNAL_CATCH_CATCH( capturer )
2052  #else 
2053  #define INTERNAL_CATCH_TRY try
2054  #define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }
2055  #endif
2056  #define INTERNAL_CATCH_REACT( handler ) handler.complete();
2057  #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
2058      do { \
2059          CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \
2060          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
2061          INTERNAL_CATCH_TRY { \
2062              CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2063              CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
2064              catchAssertionHandler.handleExpr( Catch::Decomposer() &lt;= __VA_ARGS__ ); \
2065              CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
2066          } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
2067          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2068      } while( (void)0, (false) &amp;&amp; static_cast&lt;bool&gt;( !!(__VA_ARGS__) ) )
2069  #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
2070      INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
2071      if( Catch::getResultCapture().lastAssertionPassed() )
2072  #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
2073      INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
2074      if( !Catch::getResultCapture().lastAssertionPassed() )
2075  #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
2076      do { \
2077          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
2078          try { \
2079              static_cast&lt;void&gt;(__VA_ARGS__); \
2080              catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
2081          } \
2082          catch( ... ) { \
2083              catchAssertionHandler.handleUnexpectedInflightException(); \
2084          } \
2085          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2086      } while( false )
2087  #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
2088      do { \
2089          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
2090          if( catchAssertionHandler.allowThrows() ) \
2091              try { \
2092                  static_cast&lt;void&gt;(__VA_ARGS__); \
2093                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2094              } \
2095              catch( ... ) { \
2096                  catchAssertionHandler.handleExceptionThrownAsExpected(); \
2097              } \
2098          else \
2099              catchAssertionHandler.handleThrowingCallSkipped(); \
2100          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2101      } while( false )
2102  #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
2103      do { \
2104          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
2105          if( catchAssertionHandler.allowThrows() ) \
2106              try { \
2107                  static_cast&lt;void&gt;(expr); \
2108                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2109              } \
2110              catch( exceptionType const&amp; ) { \
2111                  catchAssertionHandler.handleExceptionThrownAsExpected(); \
2112              } \
2113              catch( ... ) { \
2114                  catchAssertionHandler.handleUnexpectedInflightException(); \
2115              } \
2116          else \
2117              catchAssertionHandler.handleThrowingCallSkipped(); \
2118          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2119      } while( false )
2120  #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
2121      do { \
2122          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
2123          catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() &lt;&lt; __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
2124          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2125      } while( false )
2126  #define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
2127      auto varName = Catch::Capturer( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \
2128      varName.captureValues( 0, __VA_ARGS__ )
2129  #define INTERNAL_CATCH_INFO( macroName, log ) \
2130      Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) &lt;&lt; log );
2131  #define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \
2132      Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) &lt;&lt; log )
2133  #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
2134      do { \
2135          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2136          if( catchAssertionHandler.allowThrows() ) \
2137              try { \
2138                  static_cast&lt;void&gt;(__VA_ARGS__); \
2139                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2140              } \
2141              catch( ... ) { \
2142                  Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \
2143              } \
2144          else \
2145              catchAssertionHandler.handleThrowingCallSkipped(); \
2146          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2147      } while( false )
2148  #endif 
2149  #include &lt;cstddef&gt;
2150  namespace Catch {
2151      struct Counts {
2152          Counts operator - ( Counts const&amp; other ) const;
2153          Counts&amp; operator += ( Counts const&amp; other );
2154          std::size_t total() const;
2155          bool allPassed() const;
2156          bool allOk() const;
2157          std::size_t passed = 0;
2158          std::size_t failed = 0;
2159          std::size_t failedButOk = 0;
2160      };
2161      struct Totals {
2162          Totals operator - ( Totals const&amp; other ) const;
2163          Totals&amp; operator += ( Totals const&amp; other );
2164          Totals delta( Totals const&amp; prevTotals ) const;
2165          int error = 0;
2166          Counts assertions;
2167          Counts testCases;
2168      };
2169  }
2170  #include &lt;string&gt;
2171  namespace Catch {
2172      struct SectionInfo {
2173          SectionInfo
2174              (   SourceLineInfo const&amp; _lineInfo,
2175                  std::string const&amp; _name );
2176          SectionInfo
2177              (   SourceLineInfo const&amp; _lineInfo,
2178                  std::string const&amp; _name,
2179                  std::string const&amp; ) : SectionInfo( _lineInfo, _name ) {}
2180          std::string name;
2181          std::string description; 
2182          SourceLineInfo lineInfo;
2183      };
2184      struct SectionEndInfo {
2185          SectionInfo sectionInfo;
2186          Counts prevAssertions;
2187          double durationInSeconds;
2188      };
2189  } 
2190  #include &lt;cstdint&gt;
2191  namespace Catch {
2192      auto getCurrentNanosecondsSinceEpoch() -&gt; uint64_t;
2193      auto getEstimatedClockResolution() -&gt; uint64_t;
2194      class Timer {
2195          uint64_t m_nanoseconds = 0;
2196      public:
2197          void start();
2198          auto getElapsedNanoseconds() const -&gt; uint64_t;
2199          auto getElapsedMicroseconds() const -&gt; uint64_t;
2200          auto getElapsedMilliseconds() const -&gt; unsigned int;
2201          auto getElapsedSeconds() const -&gt; double;
2202      };
2203  } 
2204  #include &lt;string&gt;
2205  namespace Catch {
2206      class Section : NonCopyable {
2207      public:
2208          Section( SectionInfo const&amp; info );
2209          ~Section();
2210          explicit operator bool() const;
2211      private:
2212          SectionInfo m_info;
2213          std::string m_name;
2214          Counts m_assertions;
2215          bool m_sectionIncluded;
2216          Timer m_timer;
2217      };
2218  } 
2219  #define INTERNAL_CATCH_SECTION( ... ) \
2220      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2221      CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
2222      if( Catch::Section const&amp; INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
2223      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
2224  #define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \
2225      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2226      CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
2227      if( Catch::Section const&amp; INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str() ) ) \
2228      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
2229  #include &lt;string&gt;
2230  #include &lt;memory&gt;
2231  namespace Catch {
2232      class TestCase;
2233      struct ITestCaseRegistry;
2234      struct IExceptionTranslatorRegistry;
2235      struct IExceptionTranslator;
2236      struct IReporterRegistry;
2237      struct IReporterFactory;
2238      struct ITagAliasRegistry;
2239      struct IMutableEnumValuesRegistry;
2240      class StartupExceptionRegistry;
2241      using IReporterFactoryPtr = std::shared_ptr&lt;IReporterFactory&gt;;
2242      struct IRegistryHub {
2243          virtual ~IRegistryHub();
2244          virtual IReporterRegistry const&amp; getReporterRegistry() const = 0;
2245          virtual ITestCaseRegistry const&amp; getTestCaseRegistry() const = 0;
2246          virtual ITagAliasRegistry const&amp; getTagAliasRegistry() const = 0;
2247          virtual IExceptionTranslatorRegistry const&amp; getExceptionTranslatorRegistry() const = 0;
2248          virtual StartupExceptionRegistry const&amp; getStartupExceptionRegistry() const = 0;
2249      };
2250      struct IMutableRegistryHub {
2251          virtual ~IMutableRegistryHub();
2252          virtual void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) = 0;
2253          virtual void registerListener( IReporterFactoryPtr const&amp; factory ) = 0;
2254          virtual void registerTest( TestCase const&amp; testInfo ) = 0;
2255          virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
2256          virtual void registerTagAlias( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) = 0;
2257          virtual void registerStartupException() noexcept = 0;
2258          virtual IMutableEnumValuesRegistry&amp; getMutableEnumValuesRegistry() = 0;
2259      };
2260      IRegistryHub const&amp; getRegistryHub();
2261      IMutableRegistryHub&amp; getMutableRegistryHub();
2262      void cleanUp();
2263      std::string translateActiveException();
2264  }
2265  #if defined(CATCH_CONFIG_DISABLE)
2266      #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
2267          static std::string translatorName( signature )
2268  #endif
2269  #include &lt;exception&gt;
2270  #include &lt;string&gt;
2271  #include &lt;vector&gt;
2272  namespace Catch {
2273      using exceptionTranslateFunction = std::string(*)();
2274      struct IExceptionTranslator;
2275      using ExceptionTranslators = std::vector&lt;std::unique_ptr&lt;IExceptionTranslator const&gt;&gt;;
2276      struct IExceptionTranslator {
2277          virtual ~IExceptionTranslator();
2278          virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
2279      };
2280      struct IExceptionTranslatorRegistry {
2281          virtual ~IExceptionTranslatorRegistry();
2282          virtual std::string translateActiveException() const = 0;
2283      };
2284      class ExceptionTranslatorRegistrar {
2285          template&lt;typename T&gt;
2286          class ExceptionTranslator : public IExceptionTranslator {
2287          public:
2288              ExceptionTranslator( std::string(*translateFunction)( T&amp; ) )
2289              : m_translateFunction( translateFunction )
2290              {}
2291              std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
2292  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2293                  return &quot;&quot;;
2294  #else
2295                  try {
2296                      if( it == itEnd )
2297                          std::rethrow_exception(std::current_exception());
2298                      else
2299                          return (*it)-&gt;translate( it+1, itEnd );
2300                  }
2301                  catch( T&amp; ex ) {
2302                      return m_translateFunction( ex );
2303                  }
2304  #endif
2305              }
2306          protected:
2307              std::string(*m_translateFunction)( T&amp; );
2308          };
2309      public:
2310          template&lt;typename T&gt;
2311          ExceptionTranslatorRegistrar( std::string(*translateFunction)( T&amp; ) ) {
2312              getMutableRegistryHub().registerTranslator
2313                  ( new ExceptionTranslator&lt;T&gt;( translateFunction ) );
2314          }
2315      };
2316  }
2317  #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
2318      static std::string translatorName( signature ); \
2319      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
2320      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
2321      namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &amp;translatorName ); } \
2322      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
2323      static std::string translatorName( signature )
2324  #define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
2325  #include &lt;type_traits&gt;
2326  namespace Catch {
2327  namespace Detail {
2328      class Approx {
2329      private:
2330          bool equalityComparisonImpl(double other) const;
2331          void setMargin(double margin);
2332          void setEpsilon(double epsilon);
2333      public:
2334          explicit Approx ( double value );
2335          static Approx custom();
2336          Approx operator-() const;
2337          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2338          Approx operator()( T const&amp; value ) {
2339              Approx approx( static_cast&lt;double&gt;(value) );
2340              approx.m_epsilon = m_epsilon;
2341              approx.m_margin = m_margin;
2342              approx.m_scale = m_scale;
2343              return approx;
2344          }
2345          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2346          explicit Approx( T const&amp; value ): Approx(static_cast&lt;double&gt;(value))
2347          {}
2348          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2349          friend bool operator == ( const T&amp; lhs, Approx const&amp; rhs ) {
2350              auto lhs_v = static_cast&lt;double&gt;(lhs);
2351              return rhs.equalityComparisonImpl(lhs_v);
2352          }
2353          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2354          friend bool operator == ( Approx const&amp; lhs, const T&amp; rhs ) {
2355              return operator==( rhs, lhs );
2356          }
2357          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2358          friend bool operator != ( T const&amp; lhs, Approx const&amp; rhs ) {
2359              return !operator==( lhs, rhs );
2360          }
2361          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2362          friend bool operator != ( Approx const&amp; lhs, T const&amp; rhs ) {
2363              return !operator==( rhs, lhs );
2364          }
2365          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2366          friend bool operator &lt;= ( T const&amp; lhs, Approx const&amp; rhs ) {
2367              return static_cast&lt;double&gt;(lhs) &lt; rhs.m_value || lhs == rhs;
2368          }
2369          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2370          friend bool operator &lt;= ( Approx const&amp; lhs, T const&amp; rhs ) {
2371              return lhs.m_value &lt; static_cast&lt;double&gt;(rhs) || lhs == rhs;
2372          }
2373          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2374          friend bool operator &gt;= ( T const&amp; lhs, Approx const&amp; rhs ) {
2375              return static_cast&lt;double&gt;(lhs) &gt; rhs.m_value || lhs == rhs;
2376          }
2377          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2378          friend bool operator &gt;= ( Approx const&amp; lhs, T const&amp; rhs ) {
2379              return lhs.m_value &gt; static_cast&lt;double&gt;(rhs) || lhs == rhs;
2380          }
2381          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2382          Approx&amp; epsilon( T const&amp; newEpsilon ) {
2383              double epsilonAsDouble = static_cast&lt;double&gt;(newEpsilon);
2384              setEpsilon(epsilonAsDouble);
2385              return *this;
2386          }
2387          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2388          Approx&amp; margin( T const&amp; newMargin ) {
2389              double marginAsDouble = static_cast&lt;double&gt;(newMargin);
2390              setMargin(marginAsDouble);
2391              return *this;
2392          }
2393          template &lt;typename T, typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2394          Approx&amp; scale( T const&amp; newScale ) {
2395              m_scale = static_cast&lt;double&gt;(newScale);
2396              return *this;
2397          }
2398          std::string toString() const;
2399      private:
2400          double m_epsilon;
2401          double m_margin;
2402          double m_scale;
2403          double m_value;
2404      };
2405  } 
2406  namespace literals {
2407      Detail::Approx operator &quot;&quot; _a(long double val);
2408      Detail::Approx operator &quot;&quot; _a(unsigned long long val);
2409  } 
2410  template&lt;&gt;
2411  struct StringMaker&lt;Catch::Detail::Approx&gt; {
2412      static std::string convert(Catch::Detail::Approx const&amp; value);
2413  };
2414  } 
2415  #include &lt;string&gt;
2416  #include &lt;iosfwd&gt;
2417  #include &lt;vector&gt;
2418  namespace Catch {
2419      bool startsWith( std::string const&amp; s, std::string const&amp; prefix );
2420      bool startsWith( std::string const&amp; s, char prefix );
2421      bool endsWith( std::string const&amp; s, std::string const&amp; suffix );
2422      bool endsWith( std::string const&amp; s, char suffix );
2423      bool contains( std::string const&amp; s, std::string const&amp; infix );
2424      void toLowerInPlace( std::string&amp; s );
2425      std::string toLower( std::string const&amp; s );
2426      std::string trim( std::string const&amp; str );
2427      StringRef trim(StringRef ref);
2428      std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter );
2429      bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis );
2430      struct pluralise {
2431          pluralise( std::size_t count, std::string const&amp; label );
2432          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser );
2433          std::size_t m_count;
2434          std::string m_label;
2435      };
2436  }
2437  #ifndef CATCH_CONFIG_DISABLE_MATCHERS
2438  #include &lt;string&gt;
2439  #include &lt;vector&gt;
2440  namespace Catch {
2441  namespace Matchers {
2442      namespace Impl {
2443          template&lt;typename ArgT&gt; struct MatchAllOf;
2444          template&lt;typename ArgT&gt; struct MatchAnyOf;
2445          template&lt;typename ArgT&gt; struct MatchNotOf;
2446          class MatcherUntypedBase {
2447          public:
2448              MatcherUntypedBase() = default;
2449              MatcherUntypedBase ( MatcherUntypedBase const&amp; ) = default;
2450              MatcherUntypedBase&amp; operator = ( MatcherUntypedBase const&amp; ) = delete;
2451              std::string toString() const;
2452          protected:
2453              virtual ~MatcherUntypedBase();
2454              virtual std::string describe() const = 0;
2455              mutable std::string m_cachedToString;
2456          };
2457  #ifdef __clang__
2458  #    pragma clang diagnostic push
2459  #    pragma clang diagnostic ignored &quot;-Wnon-virtual-dtor&quot;
2460  #endif
2461          template&lt;typename ObjectT&gt;
2462          struct MatcherMethod {
2463              virtual bool match( ObjectT const&amp; arg ) const = 0;
2464          };
2465  #if defined(__OBJC__)
2466          template&lt;&gt;
2467          struct MatcherMethod&lt;NSString*&gt; {
2468              virtual bool match( NSString* arg ) const = 0;
2469          };
2470  #endif
2471  #ifdef __clang__
2472  #    pragma clang diagnostic pop
2473  #endif
2474          template&lt;typename T&gt;
2475          struct MatcherBase : MatcherUntypedBase, MatcherMethod&lt;T&gt; {
2476              MatchAllOf&lt;T&gt; operator &amp;&amp; ( MatcherBase const&amp; other ) const;
2477              MatchAnyOf&lt;T&gt; operator || ( MatcherBase const&amp; other ) const;
2478              MatchNotOf&lt;T&gt; operator ! () const;
2479          };
2480          template&lt;typename ArgT&gt;
2481          struct MatchAllOf : MatcherBase&lt;ArgT&gt; {
2482              bool match( ArgT const&amp; arg ) const override {
2483                  for( auto matcher : m_matchers ) {
2484                      if (!matcher-&gt;match(arg))
2485                          return false;
2486                  }
2487                  return true;
2488              }
2489              std::string describe() const override {
2490                  std::string description;
2491                  description.reserve( 4 + m_matchers.size()*32 );
2492                  description += &quot;( &quot;;
2493                  bool first = true;
2494                  for( auto matcher : m_matchers ) {
2495                      if( first )
2496                          first = false;
2497                      else
2498                          description += &quot; and &quot;;
2499                      description += matcher-&gt;toString();
2500                  }
2501                  description += &quot; )&quot;;
2502                  return description;
2503              }
2504              MatchAllOf&lt;ArgT&gt; operator &amp;&amp; ( MatcherBase&lt;ArgT&gt; const&amp; other ) {
2505                  auto copy(*this);
2506                  copy.m_matchers.push_back( &amp;other );
2507                  return copy;
2508              }
2509              std::vector&lt;MatcherBase&lt;ArgT&gt; const*&gt; m_matchers;
2510          };
2511          template&lt;typename ArgT&gt;
2512          struct MatchAnyOf : MatcherBase&lt;ArgT&gt; {
2513              bool match( ArgT const&amp; arg ) const override {
2514                  for( auto matcher : m_matchers ) {
2515                      if (matcher-&gt;match(arg))
2516                          return true;
2517                  }
2518                  return false;
2519              }
2520              std::string describe() const override {
2521                  std::string description;
2522                  description.reserve( 4 + m_matchers.size()*32 );
2523                  description += &quot;( &quot;;
2524                  bool first = true;
2525                  for( auto matcher : m_matchers ) {
2526                      if( first )
2527                          first = false;
2528                      else
2529                          description += &quot; or &quot;;
2530                      description += matcher-&gt;toString();
2531                  }
2532                  description += &quot; )&quot;;
2533                  return description;
2534              }
2535              MatchAnyOf&lt;ArgT&gt; operator || ( MatcherBase&lt;ArgT&gt; const&amp; other ) {
2536                  auto copy(*this);
2537                  copy.m_matchers.push_back( &amp;other );
2538                  return copy;
2539              }
2540              std::vector&lt;MatcherBase&lt;ArgT&gt; const*&gt; m_matchers;
2541          };
2542          template&lt;typename ArgT&gt;
2543          struct MatchNotOf : MatcherBase&lt;ArgT&gt; {
2544              MatchNotOf( MatcherBase&lt;ArgT&gt; const&amp; underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
2545              bool match( ArgT const&amp; arg ) const override {
2546                  return !m_underlyingMatcher.match( arg );
2547              }
2548              std::string describe() const override {
2549                  return &quot;not &quot; + m_underlyingMatcher.toString();
2550              }
2551              MatcherBase&lt;ArgT&gt; const&amp; m_underlyingMatcher;
2552          };
2553          template&lt;typename T&gt;
2554          MatchAllOf&lt;T&gt; MatcherBase&lt;T&gt;::operator &amp;&amp; ( MatcherBase const&amp; other ) const {
2555              return MatchAllOf&lt;T&gt;() &amp;&amp; *this &amp;&amp; other;
2556          }
2557          template&lt;typename T&gt;
2558          MatchAnyOf&lt;T&gt; MatcherBase&lt;T&gt;::operator || ( MatcherBase const&amp; other ) const {
2559              return MatchAnyOf&lt;T&gt;() || *this || other;
2560          }
2561          template&lt;typename T&gt;
2562          MatchNotOf&lt;T&gt; MatcherBase&lt;T&gt;::operator ! () const {
2563              return MatchNotOf&lt;T&gt;( *this );
2564          }
2565      } 
2566  } 
2567  using namespace Matchers;
2568  using Matchers::Impl::MatcherBase;
2569  } 
2570  namespace Catch {
2571  namespace Matchers {
2572  namespace Exception {
2573  class ExceptionMessageMatcher : public MatcherBase&lt;std::exception&gt; {
2574      std::string m_message;
2575  public:
2576      ExceptionMessageMatcher(std::string const&amp; message):
2577          m_message(message)
2578      {}
2579      bool match(std::exception const&amp; ex) const override;
2580      std::string describe() const override;
2581  };
2582  } 
2583  Exception::ExceptionMessageMatcher Message(std::string const&amp; message);
2584  } 
2585  } 
2586  namespace Catch {
2587  namespace Matchers {
2588      namespace Floating {
2589          enum class FloatingPointKind : uint8_t;
2590          struct WithinAbsMatcher : MatcherBase&lt;double&gt; {
2591              WithinAbsMatcher(double target, double margin);
2592              bool match(double const&amp; matchee) const override;
2593              std::string describe() const override;
2594          private:
2595              double m_target;
2596              double m_margin;
2597          };
2598          struct WithinUlpsMatcher : MatcherBase&lt;double&gt; {
2599              WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType);
2600              bool match(double const&amp; matchee) const override;
2601              std::string describe() const override;
2602          private:
2603              double m_target;
2604              uint64_t m_ulps;
2605              FloatingPointKind m_type;
2606          };
2607          struct WithinRelMatcher : MatcherBase&lt;double&gt; {
2608              WithinRelMatcher(double target, double epsilon);
2609              bool match(double const&amp; matchee) const override;
2610              std::string describe() const override;
2611          private:
2612              double m_target;
2613              double m_epsilon;
2614          };
2615      } 
2616      Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
2617      Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
2618      Floating::WithinAbsMatcher WithinAbs(double target, double margin);
2619      Floating::WithinRelMatcher WithinRel(double target, double eps);
2620      Floating::WithinRelMatcher WithinRel(double target);
2621      Floating::WithinRelMatcher WithinRel(float target, float eps);
2622      Floating::WithinRelMatcher WithinRel(float target);
2623  } 
2624  } 
2625  #include &lt;functional&gt;
2626  #include &lt;string&gt;
2627  namespace Catch {
2628  namespace Matchers {
2629  namespace Generic {
2630  namespace Detail {
2631      std::string finalizeDescription(const std::string&amp; desc);
2632  }
2633  template &lt;typename T&gt;
2634  class PredicateMatcher : public MatcherBase&lt;T&gt; {
2635      std::function&lt;bool(T const&amp;)&gt; m_predicate;
2636      std::string m_description;
2637  public:
2638      PredicateMatcher(std::function&lt;bool(T const&amp;)&gt; const&amp; elem, std::string const&amp; descr)
2639          :m_predicate(std::move(elem)),
2640          m_description(Detail::finalizeDescription(descr))
2641      {}
2642      bool match( T const&amp; item ) const override {
2643          return m_predicate(item);
2644      }
2645      std::string describe() const override {
2646          return m_description;
2647      }
2648  };
2649  } 
2650      template&lt;typename T&gt;
2651      Generic::PredicateMatcher&lt;T&gt; Predicate(std::function&lt;bool(T const&amp;)&gt; const&amp; predicate, std::string const&amp; description = &quot;&quot;) {
2652          return Generic::PredicateMatcher&lt;T&gt;(predicate, description);
2653      }
2654  } 
2655  } 
2656  #include &lt;string&gt;
2657  namespace Catch {
2658  namespace Matchers {
2659      namespace StdString {
2660          struct CasedString
2661          {
2662              CasedString( std::string const&amp; str, CaseSensitive::Choice caseSensitivity );
2663              std::string adjustString( std::string const&amp; str ) const;
2664              std::string caseSensitivitySuffix() const;
2665              CaseSensitive::Choice m_caseSensitivity;
2666              std::string m_str;
2667          };
2668          struct StringMatcherBase : MatcherBase&lt;std::string&gt; {
2669              StringMatcherBase( std::string const&amp; operation, CasedString const&amp; comparator );
2670              std::string describe() const override;
2671              CasedString m_comparator;
2672              std::string m_operation;
2673          };
2674          struct EqualsMatcher : StringMatcherBase {
2675              EqualsMatcher( CasedString const&amp; comparator );
2676              bool match( std::string const&amp; source ) const override;
2677          };
2678          struct ContainsMatcher : StringMatcherBase {
2679              ContainsMatcher( CasedString const&amp; comparator );
2680              bool match( std::string const&amp; source ) const override;
2681          };
2682          struct StartsWithMatcher : StringMatcherBase {
2683              StartsWithMatcher( CasedString const&amp; comparator );
2684              bool match( std::string const&amp; source ) const override;
2685          };
2686          struct EndsWithMatcher : StringMatcherBase {
2687              EndsWithMatcher( CasedString const&amp; comparator );
2688              bool match( std::string const&amp; source ) const override;
2689          };
2690          struct RegexMatcher : MatcherBase&lt;std::string&gt; {
2691              RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
2692              bool match( std::string const&amp; matchee ) const override;
2693              std::string describe() const override;
2694          private:
2695              std::string m_regex;
2696              CaseSensitive::Choice m_caseSensitivity;
2697          };
2698      } 
2699      StdString::EqualsMatcher Equals( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2700      StdString::ContainsMatcher Contains( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2701      StdString::EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2702      StdString::StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2703      StdString::RegexMatcher Matches( std::string const&amp; regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2704  } 
2705  } 
2706  #include &lt;algorithm&gt;
2707  namespace Catch {
2708  namespace Matchers {
2709      namespace Vector {
2710          template&lt;typename T, typename Alloc&gt;
2711          struct ContainsElementMatcher : MatcherBase&lt;std::vector&lt;T, Alloc&gt;&gt; {
2712              ContainsElementMatcher(T const &amp;comparator) : m_comparator( comparator) {}
2713              bool match(std::vector&lt;T, Alloc&gt; const &amp;v) const override {
2714                  for (auto const&amp; el : v) {
2715                      if (el == m_comparator) {
2716                          return true;
2717                      }
2718                  }
2719                  return false;
2720              }
2721              std::string describe() const override {
2722                  return &quot;Contains: &quot; + ::Catch::Detail::stringify( m_comparator );
2723              }
2724              T const&amp; m_comparator;
2725          };
2726          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2727          struct ContainsMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2728              ContainsMatcher(std::vector&lt;T, AllocComp&gt; const &amp;comparator) : m_comparator( comparator ) {}
2729              bool match(std::vector&lt;T, AllocMatch&gt; const &amp;v) const override {
2730                  if (m_comparator.size() &gt; v.size())
2731                      return false;
2732                  for (auto const&amp; comparator : m_comparator) {
2733                      auto present = false;
2734                      for (const auto&amp; el : v) {
2735                          if (el == comparator) {
2736                              present = true;
2737                              break;
2738                          }
2739                      }
2740                      if (!present) {
2741                          return false;
2742                      }
2743                  }
2744                  return true;
2745              }
2746              std::string describe() const override {
2747                  return &quot;Contains: &quot; + ::Catch::Detail::stringify( m_comparator );
2748              }
2749              std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;
2750          };
2751          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2752          struct EqualsMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2753              EqualsMatcher(std::vector&lt;T, AllocComp&gt; const &amp;comparator) : m_comparator( comparator ) {}
2754              bool match(std::vector&lt;T, AllocMatch&gt; const &amp;v) const override {
2755                  if (m_comparator.size() != v.size())
2756                      return false;
2757                  for (std::size_t i = 0; i &lt; v.size(); ++i)
2758                      if (m_comparator[i] != v[i])
2759                          return false;
2760                  return true;
2761              }
2762              std::string describe() const override {
2763                  return &quot;Equals: &quot; + ::Catch::Detail::stringify( m_comparator );
2764              }
2765              std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;
2766          };
2767          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2768          struct ApproxMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2769              ApproxMatcher(std::vector&lt;T, AllocComp&gt; const&amp; comparator) : m_comparator( comparator ) {}
2770              bool match(std::vector&lt;T, AllocMatch&gt; const &amp;v) const override {
2771                  if (m_comparator.size() != v.size())
2772                      return false;
2773                  for (std::size_t i = 0; i &lt; v.size(); ++i)
2774                      if (m_comparator[i] != approx(v[i]))
2775                          return false;
2776                  return true;
2777              }
2778              std::string describe() const override {
2779                  return &quot;is approx: &quot; + ::Catch::Detail::stringify( m_comparator );
2780              }
2781              template &lt;typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2782              ApproxMatcher&amp; epsilon( T const&amp; newEpsilon ) {
2783                  approx.epsilon(newEpsilon);
2784                  return *this;
2785              }
2786              template &lt;typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2787              ApproxMatcher&amp; margin( T const&amp; newMargin ) {
2788                  approx.margin(newMargin);
2789                  return *this;
2790              }
2791              template &lt;typename = typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type&gt;
2792              ApproxMatcher&amp; scale( T const&amp; newScale ) {
2793                  approx.scale(newScale);
2794                  return *this;
2795              }
2796              std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;
2797              mutable Catch::Detail::Approx approx = Catch::Detail::Approx::custom();
2798          };
2799          template&lt;typename T, typename AllocComp, typename AllocMatch&gt;
2800          struct UnorderedEqualsMatcher : MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {
2801              UnorderedEqualsMatcher(std::vector&lt;T, AllocComp&gt; const&amp; target) : m_target(target) {}
2802              bool match(std::vector&lt;T, AllocMatch&gt; const&amp; vec) const override {
2803                  if (m_target.size() != vec.size()) {
2804                      return false;
2805                  }
2806                  return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
2807              }
2808              std::string describe() const override {
2809                  return &quot;UnorderedEquals: &quot; + ::Catch::Detail::stringify(m_target);
2810              }
2811          private:
2812              std::vector&lt;T, AllocComp&gt; const&amp; m_target;
2813          };
2814      } 
2815      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2816      Vector::ContainsMatcher&lt;T, AllocComp, AllocMatch&gt; Contains( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {
2817          return Vector::ContainsMatcher&lt;T, AllocComp, AllocMatch&gt;( comparator );
2818      }
2819      template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;
2820      Vector::ContainsElementMatcher&lt;T, Alloc&gt; VectorContains( T const&amp; comparator ) {
2821          return Vector::ContainsElementMatcher&lt;T, Alloc&gt;( comparator );
2822      }
2823      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2824      Vector::EqualsMatcher&lt;T, AllocComp, AllocMatch&gt; Equals( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {
2825          return Vector::EqualsMatcher&lt;T, AllocComp, AllocMatch&gt;( comparator );
2826      }
2827      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2828      Vector::ApproxMatcher&lt;T, AllocComp, AllocMatch&gt; Approx( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {
2829          return Vector::ApproxMatcher&lt;T, AllocComp, AllocMatch&gt;( comparator );
2830      }
2831      template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;
2832      Vector::UnorderedEqualsMatcher&lt;T, AllocComp, AllocMatch&gt; UnorderedEquals(std::vector&lt;T, AllocComp&gt; const&amp; target) {
2833          return Vector::UnorderedEqualsMatcher&lt;T, AllocComp, AllocMatch&gt;( target );
2834      }
2835  } 
2836  } 
2837  namespace Catch {
2838      template&lt;typename ArgT, typename MatcherT&gt;
2839      class MatchExpr : public ITransientExpression {
2840          ArgT const&amp; m_arg;
2841          MatcherT m_matcher;
2842          StringRef m_matcherString;
2843      public:
2844          MatchExpr( ArgT const&amp; arg, MatcherT const&amp; matcher, StringRef const&amp; matcherString )
2845          :   ITransientExpression{ true, matcher.match( arg ) },
2846              m_arg( arg ),
2847              m_matcher( matcher ),
2848              m_matcherString( matcherString )
2849          {}
2850          void streamReconstructedExpression( std::ostream &amp;os ) const override {
2851              auto matcherAsString = m_matcher.toString();
2852              os &lt;&lt; Catch::Detail::stringify( m_arg ) &lt;&lt; &#x27; &#x27;;
2853              if( matcherAsString == Detail::unprintableString )
2854                  os &lt;&lt; m_matcherString;
2855              else
2856                  os &lt;&lt; matcherAsString;
2857          }
2858      };
2859      using StringMatcher = Matchers::Impl::MatcherBase&lt;std::string&gt;;
2860      void handleExceptionMatchExpr( AssertionHandler&amp; handler, StringMatcher const&amp; matcher, StringRef const&amp; matcherString  );
2861      template&lt;typename ArgT, typename MatcherT&gt;
2862      auto makeMatchExpr( ArgT const&amp; arg, MatcherT const&amp; matcher, StringRef const&amp; matcherString  ) -&gt; MatchExpr&lt;ArgT, MatcherT&gt; {
2863          return MatchExpr&lt;ArgT, MatcherT&gt;( arg, matcher, matcherString );
2864      }
2865  } 
2866  #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
2867      do { \
2868          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2869          INTERNAL_CATCH_TRY { \
2870              catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \
2871          } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
2872          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2873      } while( false )
2874  #define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
2875      do { \
2876          Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2877          if( catchAssertionHandler.allowThrows() ) \
2878              try { \
2879                  static_cast&lt;void&gt;(__VA_ARGS__ ); \
2880                  catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2881              } \
2882              catch( exceptionType const&amp; ex ) { \
2883                  catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \
2884              } \
2885              catch( ... ) { \
2886                  catchAssertionHandler.handleUnexpectedInflightException(); \
2887              } \
2888          else \
2889              catchAssertionHandler.handleThrowingCallSkipped(); \
2890          INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2891      } while( false )
2892  #endif
2893  #include &lt;memory&gt;
2894  namespace Catch {
2895      namespace Generators {
2896          class GeneratorUntypedBase {
2897          public:
2898              GeneratorUntypedBase() = default;
2899              virtual ~GeneratorUntypedBase();
2900              virtual bool next() = 0;
2901          };
2902          using GeneratorBasePtr = std::unique_ptr&lt;GeneratorUntypedBase&gt;;
2903      } 
2904      struct IGeneratorTracker {
2905          virtual ~IGeneratorTracker();
2906          virtual auto hasGenerator() const -&gt; bool = 0;
2907          virtual auto getGenerator() const -&gt; Generators::GeneratorBasePtr const&amp; = 0;
2908          virtual void setGenerator( Generators::GeneratorBasePtr&amp;&amp; generator ) = 0;
2909      };
2910  } 
2911  #include &lt;exception&gt;
2912  namespace Catch {
2913  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2914      template &lt;typename Ex&gt;
2915      [[noreturn]]
2916      void throw_exception(Ex const&amp; e) {
2917          throw e;
2918      }
2919  #else 
2920      [[noreturn]]
2921      void throw_exception(std::exception const&amp; e);
2922  #endif
2923      [[noreturn]]
2924      void throw_logic_error(std::string const&amp; msg);
2925      [[noreturn]]
2926      void throw_domain_error(std::string const&amp; msg);
2927      [[noreturn]]
2928      void throw_runtime_error(std::string const&amp; msg);
2929  } 
2930  #define CATCH_MAKE_MSG(...) \
2931      (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str()
2932  #define CATCH_INTERNAL_ERROR(...) \
2933      Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO &lt;&lt; &quot;: Internal Catch2 error: &quot; &lt;&lt; __VA_ARGS__))
2934  #define CATCH_ERROR(...) \
2935      Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
2936  #define CATCH_RUNTIME_ERROR(...) \
2937      Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
2938  #define CATCH_ENFORCE( condition, ... ) \
2939      do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)
2940  #include &lt;memory&gt;
2941  #include &lt;vector&gt;
2942  #include &lt;cassert&gt;
2943  #include &lt;utility&gt;
2944  #include &lt;exception&gt;
2945  namespace Catch {
2946  class GeneratorException : public std::exception {
2947      const char* const m_msg = &quot;&quot;;
2948  public:
2949      GeneratorException(const char* msg):
2950          m_msg(msg)
2951      {}
2952      const char* what() const noexcept override final;
2953  };
2954  namespace Generators {
2955      namespace pf{
2956          template&lt;typename T, typename... Args&gt;
2957          std::unique_ptr&lt;T&gt; make_unique( Args&amp;&amp;... args ) {
2958              return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
2959          }
2960      }
2961      template&lt;typename T&gt;
2962      struct IGenerator : GeneratorUntypedBase {
2963          virtual ~IGenerator() = default;
2964          virtual T const&amp; get() const = 0;
2965          using type = T;
2966      };
2967      template&lt;typename T&gt;
2968      class SingleValueGenerator final : public IGenerator&lt;T&gt; {
2969          T m_value;
2970      public:
2971          SingleValueGenerator(T&amp;&amp; value) : m_value(std::move(value)) {}
2972          T const&amp; get() const override {
2973              return m_value;
2974          }
2975          bool next() override {
2976              return false;
2977          }
2978      };
2979      template&lt;typename T&gt;
2980      class FixedValuesGenerator final : public IGenerator&lt;T&gt; {
2981          static_assert(!std::is_same&lt;T, bool&gt;::value,
2982              &quot;FixedValuesGenerator does not support bools because of std::vector&lt;bool&gt;&quot;
2983              &quot;specialization, use SingleValue Generator instead.&quot;);
2984          std::vector&lt;T&gt; m_values;
2985          size_t m_idx = 0;
2986      public:
2987          FixedValuesGenerator( std::initializer_list&lt;T&gt; values ) : m_values( values ) {}
2988          T const&amp; get() const override {
2989              return m_values[m_idx];
2990          }
2991          bool next() override {
2992              ++m_idx;
2993              return m_idx &lt; m_values.size();
2994          }
2995      };
2996      template &lt;typename T&gt;
2997      class GeneratorWrapper final {
2998          std::unique_ptr&lt;IGenerator&lt;T&gt;&gt; m_generator;
2999      public:
3000          GeneratorWrapper(std::unique_ptr&lt;IGenerator&lt;T&gt;&gt; generator):
3001              m_generator(std::move(generator))
3002          {}
3003          T const&amp; get() const {
3004              return m_generator-&gt;get();
3005          }
3006          bool next() {
3007              return m_generator-&gt;next();
3008          }
3009      };
3010      template &lt;typename T&gt;
3011      GeneratorWrapper&lt;T&gt; value(T&amp;&amp; value) {
3012          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;SingleValueGenerator&lt;T&gt;&gt;(std::forward&lt;T&gt;(value)));
3013      }
3014      template &lt;typename T&gt;
3015      GeneratorWrapper&lt;T&gt; values(std::initializer_list&lt;T&gt; values) {
3016          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;FixedValuesGenerator&lt;T&gt;&gt;(values));
3017      }
3018      template&lt;typename T&gt;
3019      class Generators : public IGenerator&lt;T&gt; {
3020          std::vector&lt;GeneratorWrapper&lt;T&gt;&gt; m_generators;
3021          size_t m_current = 0;
3022          void populate(GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3023              m_generators.emplace_back(std::move(generator));
3024          }
3025          void populate(T&amp;&amp; val) {
3026              m_generators.emplace_back(value(std::forward&lt;T&gt;(val)));
3027          }
3028          template&lt;typename U&gt;
3029          void populate(U&amp;&amp; val) {
3030              populate(T(std::forward&lt;U&gt;(val)));
3031          }
3032          template&lt;typename U, typename... Gs&gt;
3033          void populate(U&amp;&amp; valueOrGenerator, Gs &amp;&amp;... moreGenerators) {
3034              populate(std::forward&lt;U&gt;(valueOrGenerator));
3035              populate(std::forward&lt;Gs&gt;(moreGenerators)...);
3036          }
3037      public:
3038          template &lt;typename... Gs&gt;
3039          Generators(Gs &amp;&amp;... moreGenerators) {
3040              m_generators.reserve(sizeof...(Gs));
3041              populate(std::forward&lt;Gs&gt;(moreGenerators)...);
3042          }
3043          T const&amp; get() const override {
3044              return m_generators[m_current].get();
3045          }
3046          bool next() override {
3047              if (m_current &gt;= m_generators.size()) {
3048                  return false;
3049              }
3050              const bool current_status = m_generators[m_current].next();
3051              if (!current_status) {
3052                  ++m_current;
3053              }
3054              return m_current &lt; m_generators.size();
3055          }
3056      };
3057      template&lt;typename... Ts&gt;
3058      GeneratorWrapper&lt;std::tuple&lt;Ts...&gt;&gt; table( std::initializer_list&lt;std::tuple&lt;typename std::decay&lt;Ts&gt;::type...&gt;&gt; tuples ) {
3059          return values&lt;std::tuple&lt;Ts...&gt;&gt;( tuples );
3060      }
3061      template &lt;typename T&gt;
3062      struct as {};
3063      template&lt;typename T, typename... Gs&gt;
3064      auto makeGenerators( GeneratorWrapper&lt;T&gt;&amp;&amp; generator, Gs &amp;&amp;... moreGenerators ) -&gt; Generators&lt;T&gt; {
3065          return Generators&lt;T&gt;(std::move(generator), std::forward&lt;Gs&gt;(moreGenerators)...);
3066      }
3067      template&lt;typename T&gt;
3068      auto makeGenerators( GeneratorWrapper&lt;T&gt;&amp;&amp; generator ) -&gt; Generators&lt;T&gt; {
3069          return Generators&lt;T&gt;(std::move(generator));
3070      }
3071      template&lt;typename T, typename... Gs&gt;
3072      auto makeGenerators( T&amp;&amp; val, Gs &amp;&amp;... moreGenerators ) -&gt; Generators&lt;T&gt; {
3073          return makeGenerators( value( std::forward&lt;T&gt;( val ) ), std::forward&lt;Gs&gt;( moreGenerators )... );
3074      }
3075      template&lt;typename T, typename U, typename... Gs&gt;
3076      auto makeGenerators( as&lt;T&gt;, U&amp;&amp; val, Gs &amp;&amp;... moreGenerators ) -&gt; Generators&lt;T&gt; {
3077          return makeGenerators( value( T( std::forward&lt;U&gt;( val ) ) ), std::forward&lt;Gs&gt;( moreGenerators )... );
3078      }
3079      auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp;;
3080      template&lt;typename L&gt;
3081      auto generate( StringRef generatorName, SourceLineInfo const&amp; lineInfo, L const&amp; generatorExpression ) -&gt; decltype(std::declval&lt;decltype(generatorExpression())&gt;().get()) {
3082          using UnderlyingType = typename decltype(generatorExpression())::type;
3083          IGeneratorTracker&amp; tracker = acquireGeneratorTracker( generatorName, lineInfo );
3084          if (!tracker.hasGenerator()) {
3085              tracker.setGenerator(pf::make_unique&lt;Generators&lt;UnderlyingType&gt;&gt;(generatorExpression()));
3086          }
3087          auto const&amp; generator = static_cast&lt;IGenerator&lt;UnderlyingType&gt; const&amp;&gt;( *tracker.getGenerator() );
3088          return generator.get();
3089      }
3090  } 
3091  } 
3092  #define GENERATE( ... ) \
3093      Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
3094                                   CATCH_INTERNAL_LINEINFO, \
3095                                   [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) 
3096  #define GENERATE_COPY( ... ) \
3097      Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
3098                                   CATCH_INTERNAL_LINEINFO, \
3099                                   [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) 
3100  #define GENERATE_REF( ... ) \
3101      Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
3102                                   CATCH_INTERNAL_LINEINFO, \
3103                                   [&amp;]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) 
3104  namespace Catch {
3105  namespace Generators {
3106      template &lt;typename T&gt;
3107      class TakeGenerator : public IGenerator&lt;T&gt; {
3108          GeneratorWrapper&lt;T&gt; m_generator;
3109          size_t m_returned = 0;
3110          size_t m_target;
3111      public:
3112          TakeGenerator(size_t target, GeneratorWrapper&lt;T&gt;&amp;&amp; generator):
3113              m_generator(std::move(generator)),
3114              m_target(target)
3115          {
3116              assert(target != 0 &amp;&amp; &quot;Empty generators are not allowed&quot;);
3117          }
3118          T const&amp; get() const override {
3119              return m_generator.get();
3120          }
3121          bool next() override {
3122              ++m_returned;
3123              if (m_returned &gt;= m_target) {
3124                  return false;
3125              }
3126              const auto success = m_generator.next();
3127              if (!success) {
3128                  m_returned = m_target;
3129              }
3130              return success;
3131          }
3132      };
3133      template &lt;typename T&gt;
3134      GeneratorWrapper&lt;T&gt; take(size_t target, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3135          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;TakeGenerator&lt;T&gt;&gt;(target, std::move(generator)));
3136      }
3137      template &lt;typename T, typename Predicate&gt;
3138      class FilterGenerator : public IGenerator&lt;T&gt; {
3139          GeneratorWrapper&lt;T&gt; m_generator;
3140          Predicate m_predicate;
3141      public:
3142          template &lt;typename P = Predicate&gt;
3143          FilterGenerator(P&amp;&amp; pred, GeneratorWrapper&lt;T&gt;&amp;&amp; generator):
3144              m_generator(std::move(generator)),
3145              m_predicate(std::forward&lt;P&gt;(pred))
3146          {
3147              if (!m_predicate(m_generator.get())) {
3148                  auto has_initial_value = next();
3149                  if (!has_initial_value) {
3150                      Catch::throw_exception(GeneratorException(&quot;No valid value found in filtered generator&quot;));
3151                  }
3152              }
3153          }
3154          T const&amp; get() const override {
3155              return m_generator.get();
3156          }
3157          bool next() override {
3158              bool success = m_generator.next();
3159              if (!success) {
3160                  return false;
3161              }
3162              while (!m_predicate(m_generator.get()) &amp;&amp; (success = m_generator.next()) == true);
3163              return success;
3164          }
3165      };
3166      template &lt;typename T, typename Predicate&gt;
3167      GeneratorWrapper&lt;T&gt; filter(Predicate&amp;&amp; pred, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3168          return GeneratorWrapper&lt;T&gt;(std::unique_ptr&lt;IGenerator&lt;T&gt;&gt;(pf::make_unique&lt;FilterGenerator&lt;T, Predicate&gt;&gt;(std::forward&lt;Predicate&gt;(pred), std::move(generator))));
3169      }
3170      template &lt;typename T&gt;
3171      class RepeatGenerator : public IGenerator&lt;T&gt; {
3172          static_assert(!std::is_same&lt;T, bool&gt;::value,
3173              &quot;RepeatGenerator currently does not support bools&quot;
3174              &quot;because of std::vector&lt;bool&gt; specialization&quot;);
3175          GeneratorWrapper&lt;T&gt; m_generator;
3176          mutable std::vector&lt;T&gt; m_returned;
3177          size_t m_target_repeats;
3178          size_t m_current_repeat = 0;
3179          size_t m_repeat_index = 0;
3180      public:
3181          RepeatGenerator(size_t repeats, GeneratorWrapper&lt;T&gt;&amp;&amp; generator):
3182              m_generator(std::move(generator)),
3183              m_target_repeats(repeats)
3184          {
3185              assert(m_target_repeats &gt; 0 &amp;&amp; &quot;Repeat generator must repeat at least once&quot;);
3186          }
3187          T const&amp; get() const override {
3188              if (m_current_repeat == 0) {
3189                  m_returned.push_back(m_generator.get());
3190                  return m_returned.back();
3191              }
3192              return m_returned[m_repeat_index];
3193          }
3194          bool next() override {
3195              if (m_current_repeat == 0) {
3196                  const auto success = m_generator.next();
3197                  if (!success) {
3198                      ++m_current_repeat;
3199                  }
3200                  return m_current_repeat &lt; m_target_repeats;
3201              }
3202              ++m_repeat_index;
3203              if (m_repeat_index == m_returned.size()) {
3204                  m_repeat_index = 0;
3205                  ++m_current_repeat;
3206              }
3207              return m_current_repeat &lt; m_target_repeats;
3208          }
3209      };
3210      template &lt;typename T&gt;
3211      GeneratorWrapper&lt;T&gt; repeat(size_t repeats, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3212          return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;RepeatGenerator&lt;T&gt;&gt;(repeats, std::move(generator)));
3213      }
3214      template &lt;typename T, typename U, typename Func&gt;
3215      class MapGenerator : public IGenerator&lt;T&gt; {
3216          GeneratorWrapper&lt;U&gt; m_generator;
3217          Func m_function;
3218          T m_cache;
3219      public:
3220          template &lt;typename F2 = Func&gt;
3221          MapGenerator(F2&amp;&amp; function, GeneratorWrapper&lt;U&gt;&amp;&amp; generator) :
3222              m_generator(std::move(generator)),
3223              m_function(std::forward&lt;F2&gt;(function)),
3224              m_cache(m_function(m_generator.get()))
3225          {}
3226          T const&amp; get() const override {
3227              return m_cache;
3228          }
3229          bool next() override {
3230              const auto success = m_generator.next();
3231              if (success) {
3232                  m_cache = m_function(m_generator.get());
3233              }
3234              return success;
3235          }
3236      };
3237      template &lt;typename Func, typename U, typename T = FunctionReturnType&lt;Func, U&gt;&gt;
3238      GeneratorWrapper&lt;T&gt; map(Func&amp;&amp; function, GeneratorWrapper&lt;U&gt;&amp;&amp; generator) {
3239          return GeneratorWrapper&lt;T&gt;(
3240              pf::make_unique&lt;MapGenerator&lt;T, U, Func&gt;&gt;(std::forward&lt;Func&gt;(function), std::move(generator))
3241          );
3242      }
3243      template &lt;typename T, typename U, typename Func&gt;
3244      GeneratorWrapper&lt;T&gt; map(Func&amp;&amp; function, GeneratorWrapper&lt;U&gt;&amp;&amp; generator) {
3245          return GeneratorWrapper&lt;T&gt;(
3246              pf::make_unique&lt;MapGenerator&lt;T, U, Func&gt;&gt;(std::forward&lt;Func&gt;(function), std::move(generator))
3247          );
3248      }
3249      template &lt;typename T&gt;
3250      class ChunkGenerator final : public IGenerator&lt;std::vector&lt;T&gt;&gt; {
3251          std::vector&lt;T&gt; m_chunk;
3252          size_t m_chunk_size;
3253          GeneratorWrapper&lt;T&gt; m_generator;
3254          bool m_used_up = false;
3255      public:
3256          ChunkGenerator(size_t size, GeneratorWrapper&lt;T&gt; generator) :
3257              m_chunk_size(size), m_generator(std::move(generator))
3258          {
3259              m_chunk.reserve(m_chunk_size);
3260              if (m_chunk_size != 0) {
3261                  m_chunk.push_back(m_generator.get());
3262                  for (size_t i = 1; i &lt; m_chunk_size; ++i) {
3263                      if (!m_generator.next()) {
3264                          Catch::throw_exception(GeneratorException(&quot;Not enough values to initialize the first chunk&quot;));
3265                      }
3266                      m_chunk.push_back(m_generator.get());
3267                  }
3268              }
3269          }
3270          std::vector&lt;T&gt; const&amp; get() const override {
3271              return m_chunk;
3272          }
3273          bool next() override {
3274              m_chunk.clear();
3275              for (size_t idx = 0; idx &lt; m_chunk_size; ++idx) {
3276                  if (!m_generator.next()) {
3277                      return false;
3278                  }
3279                  m_chunk.push_back(m_generator.get());
3280              }
3281              return true;
3282          }
3283      };
3284      template &lt;typename T&gt;
3285      GeneratorWrapper&lt;std::vector&lt;T&gt;&gt; chunk(size_t size, GeneratorWrapper&lt;T&gt;&amp;&amp; generator) {
3286          return GeneratorWrapper&lt;std::vector&lt;T&gt;&gt;(
3287              pf::make_unique&lt;ChunkGenerator&lt;T&gt;&gt;(size, std::move(generator))
3288          );
3289      }
3290  } 
3291  } 
3292  #include &lt;memory&gt;
3293  namespace Catch {
3294      struct IResultCapture;
3295      struct IRunner;
3296      struct IConfig;
3297      struct IMutableContext;
3298      using IConfigPtr = std::shared_ptr&lt;IConfig const&gt;;
3299      struct IContext
3300      {
3301          virtual ~IContext();
3302          virtual IResultCapture* getResultCapture() = 0;
3303          virtual IRunner* getRunner() = 0;
3304          virtual IConfigPtr const&amp; getConfig() const = 0;
3305      };
3306      struct IMutableContext : IContext
3307      {
3308          virtual ~IMutableContext();
3309          virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
3310          virtual void setRunner( IRunner* runner ) = 0;
3311          virtual void setConfig( IConfigPtr const&amp; config ) = 0;
3312      private:
3313          static IMutableContext *currentContext;
3314          friend IMutableContext&amp; getCurrentMutableContext();
3315          friend void cleanUpContext();
3316          static void createContext();
3317      };
3318      inline IMutableContext&amp; getCurrentMutableContext()
3319      {
3320          if( !IMutableContext::currentContext )
3321              IMutableContext::createContext();
3322          return *IMutableContext::currentContext;
3323      }
3324      inline IContext&amp; getCurrentContext()
3325      {
3326          return getCurrentMutableContext();
3327      }
3328      void cleanUpContext();
3329      class SimplePcg32;
3330      SimplePcg32&amp; rng();
3331  }
3332  namespace Catch {
3333      template&lt;typename T&gt;
3334      class Option {
3335      public:
3336          Option() : nullableValue( nullptr ) {}
3337          Option( T const&amp; _value )
3338          : nullableValue( new( storage ) T( _value ) )
3339          {}
3340          Option( Option const&amp; _other )
3341          : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
3342          {}
3343          ~Option() {
3344              reset();
3345          }
3346          Option&amp; operator= ( Option const&amp; _other ) {
3347              if( &amp;_other != this ) {
3348                  reset();
3349                  if( _other )
3350                      nullableValue = new( storage ) T( *_other );
3351              }
3352              return *this;
3353          }
3354          Option&amp; operator = ( T const&amp; _value ) {
3355              reset();
3356              nullableValue = new( storage ) T( _value );
3357              return *this;
3358          }
3359          void reset() {
3360              if( nullableValue )
3361                  nullableValue-&gt;~T();
3362              nullableValue = nullptr;
3363          }
3364          T&amp; operator*() { return *nullableValue; }
3365          T const&amp; operator*() const { return *nullableValue; }
3366          T* operator-&gt;() { return nullableValue; }
3367          const T* operator-&gt;() const { return nullableValue; }
3368          T valueOr( T const&amp; defaultValue ) const {
3369              return nullableValue ? *nullableValue : defaultValue;
3370          }
3371          bool some() const { return nullableValue != nullptr; }
3372          bool none() const { return nullableValue == nullptr; }
3373          bool operator !() const { return nullableValue == nullptr; }
3374          explicit operator bool() const {
3375              return some();
3376          }
3377      private:
3378          T *nullableValue;
3379          alignas(alignof(T)) char storage[sizeof(T)];
3380      };
3381  } 
3382  #include &lt;chrono&gt;
3383  #include &lt;iosfwd&gt;
3384  #include &lt;string&gt;
3385  #include &lt;vector&gt;
3386  #include &lt;memory&gt;
3387  namespace Catch {
3388      enum class Verbosity {
3389          Quiet = 0,
3390          Normal,
3391          High
3392      };
3393      struct WarnAbout { enum What {
3394          Nothing = 0x00,
3395          NoAssertions = 0x01,
3396          NoTests = 0x02
3397      }; };
3398      struct ShowDurations { enum OrNot {
3399          DefaultForReporter,
3400          Always,
3401          Never
3402      }; };
3403      struct RunTests { enum InWhatOrder {
3404          InDeclarationOrder,
3405          InLexicographicalOrder,
3406          InRandomOrder
3407      }; };
3408      struct UseColour { enum YesOrNo {
3409          Auto,
3410          Yes,
3411          No
3412      }; };
3413      struct WaitForKeypress { enum When {
3414          Never,
3415          BeforeStart = 1,
3416          BeforeExit = 2,
3417          BeforeStartAndExit = BeforeStart | BeforeExit
3418      }; };
3419      class TestSpec;
3420      struct IConfig : NonCopyable {
3421          virtual ~IConfig();
3422          virtual bool allowThrows() const = 0;
3423          virtual std::ostream&amp; stream() const = 0;
3424          virtual std::string name() const = 0;
3425          virtual bool includeSuccessfulResults() const = 0;
3426          virtual bool shouldDebugBreak() const = 0;
3427          virtual bool warnAboutMissingAssertions() const = 0;
3428          virtual bool warnAboutNoTests() const = 0;
3429          virtual int abortAfter() const = 0;
3430          virtual bool showInvisibles() const = 0;
3431          virtual ShowDurations::OrNot showDurations() const = 0;
3432          virtual double minDuration() const = 0;
3433          virtual TestSpec const&amp; testSpec() const = 0;
3434          virtual bool hasTestFilters() const = 0;
3435          virtual std::vector&lt;std::string&gt; const&amp; getTestsOrTags() const = 0;
3436          virtual RunTests::InWhatOrder runOrder() const = 0;
3437          virtual unsigned int rngSeed() const = 0;
3438          virtual UseColour::YesOrNo useColour() const = 0;
3439          virtual std::vector&lt;std::string&gt; const&amp; getSectionsToRun() const = 0;
3440          virtual Verbosity verbosity() const = 0;
3441          virtual bool benchmarkNoAnalysis() const = 0;
3442          virtual int benchmarkSamples() const = 0;
3443          virtual double benchmarkConfidenceInterval() const = 0;
3444          virtual unsigned int benchmarkResamples() const = 0;
3445          virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
3446      };
3447      using IConfigPtr = std::shared_ptr&lt;IConfig const&gt;;
3448  }
3449  #include &lt;cstdint&gt;
3450  namespace Catch {
3451      class SimplePcg32 {
3452          using state_type = std::uint64_t;
3453      public:
3454          using result_type = std::uint32_t;
3455          static constexpr result_type (min)() {
3456              return 0;
3457          }
3458          static constexpr result_type (max)() {
3459              return static_cast&lt;result_type&gt;(-1);
3460          }
3461          SimplePcg32():SimplePcg32(0xed743cc4U) {}
3462          explicit SimplePcg32(result_type seed_);
3463          void seed(result_type seed_);
3464          void discard(uint64_t skip);
3465          result_type operator()();
3466      private:
3467          friend bool operator==(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs);
3468          friend bool operator!=(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs);
3469          std::uint64_t m_state;
3470          static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL &lt;&lt; 1ULL) | 1ULL;
3471      };
3472  } 
3473  #include &lt;random&gt;
3474  namespace Catch {
3475  namespace Generators {
3476  template &lt;typename Float&gt;
3477  class RandomFloatingGenerator final : public IGenerator&lt;Float&gt; {
3478      Catch::SimplePcg32&amp; m_rng;
3479      std::uniform_real_distribution&lt;Float&gt; m_dist;
3480      Float m_current_number;
3481  public:
3482      RandomFloatingGenerator(Float a, Float b):
3483          m_rng(rng()),
3484          m_dist(a, b) {
3485          static_cast&lt;void&gt;(next());
3486      }
3487      Float const&amp; get() const override {
3488          return m_current_number;
3489      }
3490      bool next() override {
3491          m_current_number = m_dist(m_rng);
3492          return true;
3493      }
3494  };
3495  template &lt;typename Integer&gt;
3496  class RandomIntegerGenerator final : public IGenerator&lt;Integer&gt; {
3497      Catch::SimplePcg32&amp; m_rng;
3498      std::uniform_int_distribution&lt;Integer&gt; m_dist;
3499      Integer m_current_number;
3500  public:
3501      RandomIntegerGenerator(Integer a, Integer b):
3502          m_rng(rng()),
3503          m_dist(a, b) {
3504          static_cast&lt;void&gt;(next());
3505      }
3506      Integer const&amp; get() const override {
3507          return m_current_number;
3508      }
3509      bool next() override {
3510          m_current_number = m_dist(m_rng);
3511          return true;
3512      }
3513  };
3514  template &lt;typename T&gt;
3515  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value,
3516  GeneratorWrapper&lt;T&gt;&gt;::type
3517  random(T a, T b) {
3518      return GeneratorWrapper&lt;T&gt;(
3519          pf::make_unique&lt;RandomIntegerGenerator&lt;T&gt;&gt;(a, b)
3520      );
3521  }
3522  template &lt;typename T&gt;
3523  typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value,
3524  GeneratorWrapper&lt;T&gt;&gt;::type
3525  random(T a, T b) {
3526      return GeneratorWrapper&lt;T&gt;(
3527          pf::make_unique&lt;RandomFloatingGenerator&lt;T&gt;&gt;(a, b)
3528      );
3529  }
3530  template &lt;typename T&gt;
3531  class RangeGenerator final : public IGenerator&lt;T&gt; {
3532      T m_current;
3533      T m_end;
3534      T m_step;
3535      bool m_positive;
3536  public:
3537      RangeGenerator(T const&amp; start, T const&amp; end, T const&amp; step):
3538          m_current(start),
3539          m_end(end),
3540          m_step(step),
3541          m_positive(m_step &gt; T(0))
3542      {
3543          assert(m_current != m_end &amp;&amp; &quot;Range start and end cannot be equal&quot;);
3544          assert(m_step != T(0) &amp;&amp; &quot;Step size cannot be zero&quot;);
3545          assert(((m_positive &amp;&amp; m_current &lt;= m_end) || (!m_positive &amp;&amp; m_current &gt;= m_end)) &amp;&amp; &quot;Step moves away from end&quot;);
3546      }
3547      RangeGenerator(T const&amp; start, T const&amp; end):
3548          RangeGenerator(start, end, (start &lt; end) ? T(1) : T(-1))
3549      {}
3550      T const&amp; get() const override {
3551          return m_current;
3552      }
3553      bool next() override {
3554          m_current += m_step;
3555          return (m_positive) ? (m_current &lt; m_end) : (m_current &gt; m_end);
3556      }
3557  };
3558  template &lt;typename T&gt;
3559  GeneratorWrapper&lt;T&gt; range(T const&amp; start, T const&amp; end, T const&amp; step) {
3560      static_assert(std::is_arithmetic&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, &quot;Type must be numeric&quot;);
3561      return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;RangeGenerator&lt;T&gt;&gt;(start, end, step));
3562  }
3563  template &lt;typename T&gt;
3564  GeneratorWrapper&lt;T&gt; range(T const&amp; start, T const&amp; end) {
3565      static_assert(std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, &quot;Type must be an integer&quot;);
3566      return GeneratorWrapper&lt;T&gt;(pf::make_unique&lt;RangeGenerator&lt;T&gt;&gt;(start, end));
3567  }
3568  template &lt;typename T&gt;
3569  class IteratorGenerator final : public IGenerator&lt;T&gt; {
3570      static_assert(!std::is_same&lt;T, bool&gt;::value,
3571          &quot;IteratorGenerator currently does not support bools&quot;
3572          &quot;because of std::vector&lt;bool&gt; specialization&quot;);
3573      std::vector&lt;T&gt; m_elems;
3574      size_t m_current = 0;
3575  public:
3576      template &lt;typename InputIterator, typename InputSentinel&gt;
3577      IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
3578          if (m_elems.empty()) {
3579              Catch::throw_exception(GeneratorException(&quot;IteratorGenerator received no valid values&quot;));
3580          }
3581      }
3582      T const&amp; get() const override {
3583          return m_elems[m_current];
3584      }
3585      bool next() override {
3586          ++m_current;
3587          return m_current != m_elems.size();
3588      }
3589  };
3590  template &lt;typename InputIterator,
3591            typename InputSentinel,
3592            typename ResultType = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
3593  GeneratorWrapper&lt;ResultType&gt; from_range(InputIterator from, InputSentinel to) {
3594      return GeneratorWrapper&lt;ResultType&gt;(pf::make_unique&lt;IteratorGenerator&lt;ResultType&gt;&gt;(from, to));
3595  }
3596  template &lt;typename Container,
3597            typename ResultType = typename Container::value_type&gt;
3598  GeneratorWrapper&lt;ResultType&gt; from_range(Container const&amp; cnt) {
3599      return GeneratorWrapper&lt;ResultType&gt;(pf::make_unique&lt;IteratorGenerator&lt;ResultType&gt;&gt;(cnt.begin(), cnt.end()));
3600  }
3601  } 
3602  } 
3603  #include &lt;string&gt;
3604  #include &lt;vector&gt;
3605  #include &lt;memory&gt;
3606  #ifdef __clang__
3607  #pragma clang diagnostic push
3608  #pragma clang diagnostic ignored &quot;-Wpadded&quot;
3609  #endif
3610  namespace Catch {
3611      struct ITestInvoker;
3612      struct TestCaseInfo {
3613          enum SpecialProperties{
3614              None = 0,
3615              IsHidden = 1 &lt;&lt; 1,
3616              ShouldFail = 1 &lt;&lt; 2,
3617              MayFail = 1 &lt;&lt; 3,
3618              Throws = 1 &lt;&lt; 4,
3619              NonPortable = 1 &lt;&lt; 5,
3620              Benchmark = 1 &lt;&lt; 6
3621          };
3622          TestCaseInfo(   std::string const&amp; _name,
3623                          std::string const&amp; _className,
3624                          std::string const&amp; _description,
3625                          std::vector&lt;std::string&gt; const&amp; _tags,
3626                          SourceLineInfo const&amp; _lineInfo );
3627          friend void setTags( TestCaseInfo&amp; testCaseInfo, std::vector&lt;std::string&gt; tags );
3628          bool isHidden() const;
3629          bool throws() const;
3630          bool okToFail() const;
3631          bool expectedToFail() const;
3632          std::string tagsAsString() const;
3633          std::string name;
3634          std::string className;
3635          std::string description;
3636          std::vector&lt;std::string&gt; tags;
3637          std::vector&lt;std::string&gt; lcaseTags;
3638          SourceLineInfo lineInfo;
3639          SpecialProperties properties;
3640      };
3641      class TestCase : public TestCaseInfo {
3642      public:
3643          TestCase( ITestInvoker* testCase, TestCaseInfo&amp;&amp; info );
3644          TestCase withName( std::string const&amp; _newName ) const;
3645          void invoke() const;
3646          TestCaseInfo const&amp; getTestCaseInfo() const;
3647          bool operator == ( TestCase const&amp; other ) const;
3648          bool operator &lt; ( TestCase const&amp; other ) const;
3649      private:
3650          std::shared_ptr&lt;ITestInvoker&gt; test;
3651      };
3652      TestCase makeTestCase(  ITestInvoker* testCase,
3653                              std::string const&amp; className,
3654                              NameAndTags const&amp; nameAndTags,
3655                              SourceLineInfo const&amp; lineInfo );
3656  }
3657  #ifdef __clang__
3658  #pragma clang diagnostic pop
3659  #endif
3660  namespace Catch {
3661      struct IRunner {
3662          virtual ~IRunner();
3663          virtual bool aborting() const = 0;
3664      };
3665  }
3666  #ifdef __OBJC__
3667  #import &lt;objc/runtime.h&gt;
3668  #include &lt;string&gt;
3669  @protocol OcFixture
3670  @optional
3671  -(void) setUp;
3672  -(void) tearDown;
3673  @end
3674  namespace Catch {
3675      class OcMethod : public ITestInvoker {
3676      public:
3677          OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
3678          virtual void invoke() const {
3679              id obj = [[m_cls alloc] init];
3680              performOptionalSelector( obj, @selector(setUp)  );
3681              performOptionalSelector( obj, m_sel );
3682              performOptionalSelector( obj, @selector(tearDown)  );
3683              arcSafeRelease( obj );
3684          }
3685      private:
3686          virtual ~OcMethod() {}
3687          Class m_cls;
3688          SEL m_sel;
3689      };
3690      namespace Detail{
3691          inline std::string getAnnotation(   Class cls,
3692                                              std::string const&amp; annotationName,
3693                                              std::string const&amp; testCaseName ) {
3694              NSString* selStr = [[NSString alloc] initWithFormat:@&quot;Catch_%s_%s&quot;, annotationName.c_str(), testCaseName.c_str()];
3695              SEL sel = NSSelectorFromString( selStr );
3696              arcSafeRelease( selStr );
3697              id value = performOptionalSelector( cls, sel );
3698              if( value )
3699                  return [(NSString*)value UTF8String];
3700              return &quot;&quot;;
3701          }
3702      }
3703      inline std::size_t registerTestMethods() {
3704          std::size_t noTestMethods = 0;
3705          int noClasses = objc_getClassList( nullptr, 0 );
3706          Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
3707          objc_getClassList( classes, noClasses );
3708          for( int c = 0; c &lt; noClasses; c++ ) {
3709              Class cls = classes[c];
3710              {
3711                  u_int count;
3712                  Method* methods = class_copyMethodList( cls, &amp;count );
3713                  for( u_int m = 0; m &lt; count ; m++ ) {
3714                      SEL selector = method_getName(methods[m]);
3715                      std::string methodName = sel_getName(selector);
3716                      if( startsWith( methodName, &quot;Catch_TestCase_&quot; ) ) {
3717                          std::string testCaseName = methodName.substr( 15 );
3718                          std::string name = Detail::getAnnotation( cls, &quot;Name&quot;, testCaseName );
3719                          std::string desc = Detail::getAnnotation( cls, &quot;Description&quot;, testCaseName );
3720                          const char* className = class_getName( cls );
3721                          getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, NameAndTags( name.c_str(), desc.c_str() ), SourceLineInfo(&quot;&quot;,0) ) );
3722                          noTestMethods++;
3723                      }
3724                  }
3725                  free(methods);
3726              }
3727          }
3728          return noTestMethods;
3729      }
3730  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
3731      namespace Matchers {
3732          namespace Impl {
3733          namespace NSStringMatchers {
3734              struct StringHolder : MatcherBase&lt;NSString*&gt;{
3735                  StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
3736                  StringHolder( StringHolder const&amp; other ) : m_substr( [other.m_substr copy] ){}
3737                  StringHolder() {
3738                      arcSafeRelease( m_substr );
3739                  }
3740                  bool match( NSString* str ) const override {
3741                      return false;
3742                  }
3743                  NSString* CATCH_ARC_STRONG m_substr;
3744              };
3745              struct Equals : StringHolder {
3746                  Equals( NSString* substr ) : StringHolder( substr ){}
3747                  bool match( NSString* str ) const override {
3748                      return  (str != nil || m_substr == nil ) &amp;&amp;
3749                              [str isEqualToString:m_substr];
3750                  }
3751                  std::string describe() const override {
3752                      return &quot;equals string: &quot; + Catch::Detail::stringify( m_substr );
3753                  }
3754              };
3755              struct Contains : StringHolder {
3756                  Contains( NSString* substr ) : StringHolder( substr ){}
3757                  bool match( NSString* str ) const override {
3758                      return  (str != nil || m_substr == nil ) &amp;&amp;
3759                              [str rangeOfString:m_substr].location != NSNotFound;
3760                  }
3761                  std::string describe() const override {
3762                      return &quot;contains string: &quot; + Catch::Detail::stringify( m_substr );
3763                  }
3764              };
3765              struct StartsWith : StringHolder {
3766                  StartsWith( NSString* substr ) : StringHolder( substr ){}
3767                  bool match( NSString* str ) const override {
3768                      return  (str != nil || m_substr == nil ) &amp;&amp;
3769                              [str rangeOfString:m_substr].location == 0;
3770                  }
3771                  std::string describe() const override {
3772                      return &quot;starts with: &quot; + Catch::Detail::stringify( m_substr );
3773                  }
3774              };
3775              struct EndsWith : StringHolder {
3776                  EndsWith( NSString* substr ) : StringHolder( substr ){}
3777                  bool match( NSString* str ) const override {
3778                      return  (str != nil || m_substr == nil ) &amp;&amp;
3779                              [str rangeOfString:m_substr].location == [str length] - [m_substr length];
3780                  }
3781                  std::string describe() const override {
3782                      return &quot;ends with: &quot; + Catch::Detail::stringify( m_substr );
3783                  }
3784              };
3785          } 
3786          } 
3787          inline Impl::NSStringMatchers::Equals
3788              Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
3789          inline Impl::NSStringMatchers::Contains
3790              Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
3791          inline Impl::NSStringMatchers::StartsWith
3792              StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
3793          inline Impl::NSStringMatchers::EndsWith
3794              EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
3795      } 
3796      using namespace Matchers;
3797  #endif 
3798  } 
3799  #define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix
3800  #define OC_TEST_CASE2( name, desc, uniqueSuffix ) \
3801  +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \
3802  { \
3803  return @ name; \
3804  } \
3805  +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \
3806  { \
3807  return @ desc; \
3808  } \
3809  -(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )
3810  #define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )
3811  #endif
3812  #if defined(CATCH_CONFIG_EXTERNAL_INTERFACES) || defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
3813  #ifdef __clang__
3814  #pragma clang diagnostic push
3815  #pragma clang diagnostic ignored &quot;-Wpadded&quot;
3816  #endif
3817  #ifdef __clang__
3818  #pragma clang diagnostic push
3819  #pragma clang diagnostic ignored &quot;-Wpadded&quot;
3820  #endif
3821  namespace Catch
3822  {
3823      class WildcardPattern {
3824          enum WildcardPosition {
3825              NoWildcard = 0,
3826              WildcardAtStart = 1,
3827              WildcardAtEnd = 2,
3828              WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
3829          };
3830      public:
3831          WildcardPattern( std::string const&amp; pattern, CaseSensitive::Choice caseSensitivity );
3832          virtual ~WildcardPattern() = default;
3833          virtual bool matches( std::string const&amp; str ) const;
3834      private:
3835          std::string normaliseString( std::string const&amp; str ) const;
3836          CaseSensitive::Choice m_caseSensitivity;
3837          WildcardPosition m_wildcard = NoWildcard;
3838          std::string m_pattern;
3839      };
3840  }
3841  #include &lt;string&gt;
3842  #include &lt;vector&gt;
3843  #include &lt;memory&gt;
3844  namespace Catch {
3845      struct IConfig;
3846      class TestSpec {
3847          class Pattern {
3848          public:
3849              explicit Pattern( std::string const&amp; name );
3850              virtual ~Pattern();
3851              virtual bool matches( TestCaseInfo const&amp; testCase ) const = 0;
3852              std::string const&amp; name() const;
3853          private:
3854              std::string const m_name;
3855          };
3856          using PatternPtr = std::shared_ptr&lt;Pattern&gt;;
3857          class NamePattern : public Pattern {
3858          public:
3859              explicit NamePattern( std::string const&amp; name, std::string const&amp; filterString );
3860              bool matches( TestCaseInfo const&amp; testCase ) const override;
3861          private:
3862              WildcardPattern m_wildcardPattern;
3863          };
3864          class TagPattern : public Pattern {
3865          public:
3866              explicit TagPattern( std::string const&amp; tag, std::string const&amp; filterString );
3867              bool matches( TestCaseInfo const&amp; testCase ) const override;
3868          private:
3869              std::string m_tag;
3870          };
3871          class ExcludedPattern : public Pattern {
3872          public:
3873              explicit ExcludedPattern( PatternPtr const&amp; underlyingPattern );
3874              bool matches( TestCaseInfo const&amp; testCase ) const override;
3875          private:
3876              PatternPtr m_underlyingPattern;
3877          };
3878          struct Filter {
3879              std::vector&lt;PatternPtr&gt; m_patterns;
3880              bool matches( TestCaseInfo const&amp; testCase ) const;
3881              std::string name() const;
3882          };
3883      public:
3884          struct FilterMatch {
3885              std::string name;
3886              std::vector&lt;TestCase const*&gt; tests;
3887          };
3888          using Matches = std::vector&lt;FilterMatch&gt;;
3889          using vectorStrings = std::vector&lt;std::string&gt;;
3890          bool hasFilters() const;
3891          bool matches( TestCaseInfo const&amp; testCase ) const;
3892          Matches matchesByFilter( std::vector&lt;TestCase&gt; const&amp; testCases, IConfig const&amp; config ) const;
3893          const vectorStrings &amp; getInvalidArgs() const;
3894      private:
3895          std::vector&lt;Filter&gt; m_filters;
3896          std::vector&lt;std::string&gt; m_invalidArgs;
3897          friend class TestSpecParser;
3898      };
3899  }
3900  #ifdef __clang__
3901  #pragma clang diagnostic pop
3902  #endif
3903  #include &lt;string&gt;
3904  namespace Catch {
3905      struct TagAlias;
3906      struct ITagAliasRegistry {
3907          virtual ~ITagAliasRegistry();
3908          virtual TagAlias const* find( std::string const&amp; alias ) const = 0;
3909          virtual std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const = 0;
3910          static ITagAliasRegistry const&amp; get();
3911      };
3912  } 
3913  namespace Catch {
3914      class TestSpecParser {
3915          enum Mode{ None, Name, QuotedName, Tag, EscapedName };
3916          Mode m_mode = None;
3917          Mode lastMode = None;
3918          bool m_exclusion = false;
3919          std::size_t m_pos = 0;
3920          std::size_t m_realPatternPos = 0;
3921          std::string m_arg;
3922          std::string m_substring;
3923          std::string m_patternName;
3924          std::vector&lt;std::size_t&gt; m_escapeChars;
3925          TestSpec::Filter m_currentFilter;
3926          TestSpec m_testSpec;
3927          ITagAliasRegistry const* m_tagAliases = nullptr;
3928      public:
3929          TestSpecParser( ITagAliasRegistry const&amp; tagAliases );
3930          TestSpecParser&amp; parse( std::string const&amp; arg );
3931          TestSpec testSpec();
3932      private:
3933          bool visitChar( char c );
3934          void startNewMode( Mode mode );
3935          bool processNoneChar( char c );
3936          void processNameChar( char c );
3937          bool processOtherChar( char c );
3938          void endMode();
3939          void escape();
3940          bool isControlChar( char c ) const;
3941          void saveLastMode();
3942          void revertBackToLastMode();
3943          void addFilter();
3944          bool separate();
3945          std::string preprocessPattern();
3946          void addNamePattern();
3947          void addTagPattern();
3948          inline void addCharToPattern(char c) {
3949              m_substring += c;
3950              m_patternName += c;
3951              m_realPatternPos++;
3952          }
3953      };
3954      TestSpec parseTestSpec( std::string const&amp; arg );
3955  } 
3956  #ifdef __clang__
3957  #pragma clang diagnostic pop
3958  #endif
3959  #include &lt;memory&gt;
3960  #include &lt;vector&gt;
3961  #include &lt;string&gt;
3962  #ifndef CATCH_CONFIG_CONSOLE_WIDTH
3963  #define CATCH_CONFIG_CONSOLE_WIDTH 80
3964  #endif
3965  namespace Catch {
3966      struct IStream;
3967      struct ConfigData {
3968          bool listTests = false;
3969          bool listTags = false;
3970          bool listReporters = false;
3971          bool listTestNamesOnly = false;
3972          bool showSuccessfulTests = false;
3973          bool shouldDebugBreak = false;
3974          bool noThrow = false;
3975          bool showHelp = false;
3976          bool showInvisibles = false;
3977          bool filenamesAsTags = false;
3978          bool libIdentify = false;
3979          int abortAfter = -1;
3980          unsigned int rngSeed = 0;
3981          bool benchmarkNoAnalysis = false;
3982          unsigned int benchmarkSamples = 100;
3983          double benchmarkConfidenceInterval = 0.95;
3984          unsigned int benchmarkResamples = 100000;
3985          std::chrono::milliseconds::rep benchmarkWarmupTime = 100;
3986          Verbosity verbosity = Verbosity::Normal;
3987          WarnAbout::What warnings = WarnAbout::Nothing;
3988          ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;
3989          double minDuration = -1;
3990          RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;
3991          UseColour::YesOrNo useColour = UseColour::Auto;
3992          WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
3993          std::string outputFilename;
3994          std::string name;
3995          std::string processName;
3996  #ifndef CATCH_CONFIG_DEFAULT_REPORTER
3997  #define CATCH_CONFIG_DEFAULT_REPORTER &quot;console&quot;
3998  #endif
3999          std::string reporterName = CATCH_CONFIG_DEFAULT_REPORTER;
4000  #undef CATCH_CONFIG_DEFAULT_REPORTER
4001          std::vector&lt;std::string&gt; testsOrTags;
4002          std::vector&lt;std::string&gt; sectionsToRun;
4003      };
4004      class Config : public IConfig {
4005      public:
4006          Config() = default;
4007          Config( ConfigData const&amp; data );
4008          virtual ~Config() = default;
4009          std::string const&amp; getFilename() const;
4010          bool listTests() const;
4011          bool listTestNamesOnly() const;
4012          bool listTags() const;
4013          bool listReporters() const;
4014          std::string getProcessName() const;
4015          std::string const&amp; getReporterName() const;
4016          std::vector&lt;std::string&gt; const&amp; getTestsOrTags() const override;
4017          std::vector&lt;std::string&gt; const&amp; getSectionsToRun() const override;
4018          TestSpec const&amp; testSpec() const override;
4019          bool hasTestFilters() const override;
4020          bool showHelp() const;
4021          bool allowThrows() const override;
4022          std::ostream&amp; stream() const override;
4023          std::string name() const override;
4024          bool includeSuccessfulResults() const override;
4025          bool warnAboutMissingAssertions() const override;
4026          bool warnAboutNoTests() const override;
4027          ShowDurations::OrNot showDurations() const override;
4028          double minDuration() const override;
4029          RunTests::InWhatOrder runOrder() const override;
4030          unsigned int rngSeed() const override;
4031          UseColour::YesOrNo useColour() const override;
4032          bool shouldDebugBreak() const override;
4033          int abortAfter() const override;
4034          bool showInvisibles() const override;
4035          Verbosity verbosity() const override;
4036          bool benchmarkNoAnalysis() const override;
4037          int benchmarkSamples() const override;
4038          double benchmarkConfidenceInterval() const override;
4039          unsigned int benchmarkResamples() const override;
4040          std::chrono::milliseconds benchmarkWarmupTime() const override;
4041      private:
4042          IStream const* openStream();
4043          ConfigData m_data;
4044          std::unique_ptr&lt;IStream const&gt; m_stream;
4045          TestSpec m_testSpec;
4046          bool m_hasTestFilters = false;
4047      };
4048  } 
4049  #include &lt;string&gt;
4050  namespace Catch {
4051      struct AssertionResultData
4052      {
4053          AssertionResultData() = delete;
4054          AssertionResultData( ResultWas::OfType _resultType, LazyExpression const&amp; _lazyExpression );
4055          std::string message;
4056          mutable std::string reconstructedExpression;
4057          LazyExpression lazyExpression;
4058          ResultWas::OfType resultType;
4059          std::string reconstructExpression() const;
4060      };
4061      class AssertionResult {
4062      public:
4063          AssertionResult() = delete;
4064          AssertionResult( AssertionInfo const&amp; info, AssertionResultData const&amp; data );
4065          bool isOk() const;
4066          bool succeeded() const;
4067          ResultWas::OfType getResultType() const;
4068          bool hasExpression() const;
4069          bool hasMessage() const;
4070          std::string getExpression() const;
4071          std::string getExpressionInMacro() const;
4072          bool hasExpandedExpression() const;
4073          std::string getExpandedExpression() const;
4074          std::string getMessage() const;
4075          SourceLineInfo getSourceInfo() const;
4076          StringRef getTestMacroName() const;
4077          AssertionInfo m_info;
4078          AssertionResultData m_resultData;
4079      };
4080  } 
4081  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4082  namespace Catch {
4083      namespace Benchmark {
4084          template &lt;typename Duration&gt;
4085          struct Estimate {
4086              Duration point;
4087              Duration lower_bound;
4088              Duration upper_bound;
4089              double confidence_interval;
4090              template &lt;typename Duration2&gt;
4091              operator Estimate&lt;Duration2&gt;() const {
4092                  return { point, lower_bound, upper_bound, confidence_interval };
4093              }
4094          };
4095      } 
4096  } 
4097  namespace Catch {
4098      namespace Benchmark {
4099          struct OutlierClassification {
4100              int samples_seen = 0;
4101              int low_severe = 0;     
4102              int low_mild = 0;       
4103              int high_mild = 0;      
4104              int high_severe = 0;    
4105              int total() const {
4106                  return low_severe + low_mild + high_mild + high_severe;
4107              }
4108          };
4109      } 
4110  } 
4111  #include &lt;iterator&gt;
4112  #endif 
4113  #include &lt;string&gt;
4114  #include &lt;iosfwd&gt;
4115  #include &lt;map&gt;
4116  #include &lt;set&gt;
4117  #include &lt;memory&gt;
4118  #include &lt;algorithm&gt;
4119  namespace Catch {
4120      struct ReporterConfig {
4121          explicit ReporterConfig( IConfigPtr const&amp; _fullConfig );
4122          ReporterConfig( IConfigPtr const&amp; _fullConfig, std::ostream&amp; _stream );
4123          std::ostream&amp; stream() const;
4124          IConfigPtr fullConfig() const;
4125      private:
4126          std::ostream* m_stream;
4127          IConfigPtr m_fullConfig;
4128      };
4129      struct ReporterPreferences {
4130          bool shouldRedirectStdOut = false;
4131          bool shouldReportAllAssertions = false;
4132      };
4133      template&lt;typename T&gt;
4134      struct LazyStat : Option&lt;T&gt; {
4135          LazyStat&amp; operator=( T const&amp; _value ) {
4136              Option&lt;T&gt;::operator=( _value );
4137              used = false;
4138              return *this;
4139          }
4140          void reset() {
4141              Option&lt;T&gt;::reset();
4142              used = false;
4143          }
4144          bool used = false;
4145      };
4146      struct TestRunInfo {
4147          TestRunInfo( std::string const&amp; _name );
4148          std::string name;
4149      };
4150      struct GroupInfo {
4151          GroupInfo(  std::string const&amp; _name,
4152                      std::size_t _groupIndex,
4153                      std::size_t _groupsCount );
4154          std::string name;
4155          std::size_t groupIndex;
4156          std::size_t groupsCounts;
4157      };
4158      struct AssertionStats {
4159          AssertionStats( AssertionResult const&amp; _assertionResult,
4160                          std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,
4161                          Totals const&amp; _totals );
4162          AssertionStats( AssertionStats const&amp; )              = default;
4163          AssertionStats( AssertionStats &amp;&amp; )                  = default;
4164          AssertionStats&amp; operator = ( AssertionStats const&amp; ) = delete;
4165          AssertionStats&amp; operator = ( AssertionStats &amp;&amp; )     = delete;
4166          virtual ~AssertionStats();
4167          AssertionResult assertionResult;
4168          std::vector&lt;MessageInfo&gt; infoMessages;
4169          Totals totals;
4170      };
4171      struct SectionStats {
4172          SectionStats(   SectionInfo const&amp; _sectionInfo,
4173                          Counts const&amp; _assertions,
4174                          double _durationInSeconds,
4175                          bool _missingAssertions );
4176          SectionStats( SectionStats const&amp; )              = default;
4177          SectionStats( SectionStats &amp;&amp; )                  = default;
4178          SectionStats&amp; operator = ( SectionStats const&amp; ) = default;
4179          SectionStats&amp; operator = ( SectionStats &amp;&amp; )     = default;
4180          virtual ~SectionStats();
4181          SectionInfo sectionInfo;
4182          Counts assertions;
4183          double durationInSeconds;
4184          bool missingAssertions;
4185      };
4186      struct TestCaseStats {
4187          TestCaseStats(  TestCaseInfo const&amp; _testInfo,
4188                          Totals const&amp; _totals,
4189                          std::string const&amp; _stdOut,
4190                          std::string const&amp; _stdErr,
4191                          bool _aborting );
4192          TestCaseStats( TestCaseStats const&amp; )              = default;
4193          TestCaseStats( TestCaseStats &amp;&amp; )                  = default;
4194          TestCaseStats&amp; operator = ( TestCaseStats const&amp; ) = default;
4195          TestCaseStats&amp; operator = ( TestCaseStats &amp;&amp; )     = default;
4196          virtual ~TestCaseStats();
4197          TestCaseInfo testInfo;
4198          Totals totals;
4199          std::string stdOut;
4200          std::string stdErr;
4201          bool aborting;
4202      };
4203      struct TestGroupStats {
4204          TestGroupStats( GroupInfo const&amp; _groupInfo,
4205                          Totals const&amp; _totals,
4206                          bool _aborting );
4207          TestGroupStats( GroupInfo const&amp; _groupInfo );
4208          TestGroupStats( TestGroupStats const&amp; )              = default;
4209          TestGroupStats( TestGroupStats &amp;&amp; )                  = default;
4210          TestGroupStats&amp; operator = ( TestGroupStats const&amp; ) = default;
4211          TestGroupStats&amp; operator = ( TestGroupStats &amp;&amp; )     = default;
4212          virtual ~TestGroupStats();
4213          GroupInfo groupInfo;
4214          Totals totals;
4215          bool aborting;
4216      };
4217      struct TestRunStats {
4218          TestRunStats(   TestRunInfo const&amp; _runInfo,
4219                          Totals const&amp; _totals,
4220                          bool _aborting );
4221          TestRunStats( TestRunStats const&amp; )              = default;
4222          TestRunStats( TestRunStats &amp;&amp; )                  = default;
4223          TestRunStats&amp; operator = ( TestRunStats const&amp; ) = default;
4224          TestRunStats&amp; operator = ( TestRunStats &amp;&amp; )     = default;
4225          virtual ~TestRunStats();
4226          TestRunInfo runInfo;
4227          Totals totals;
4228          bool aborting;
4229      };
4230  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4231      struct BenchmarkInfo {
4232          std::string name;
4233          double estimatedDuration;
4234          int iterations;
4235          int samples;
4236          unsigned int resamples;
4237          double clockResolution;
4238          double clockCost;
4239      };
4240      template &lt;class Duration&gt;
4241      struct BenchmarkStats {
4242          BenchmarkInfo info;
4243          std::vector&lt;Duration&gt; samples;
4244          Benchmark::Estimate&lt;Duration&gt; mean;
4245          Benchmark::Estimate&lt;Duration&gt; standardDeviation;
4246          Benchmark::OutlierClassification outliers;
4247          double outlierVariance;
4248          template &lt;typename Duration2&gt;
4249          operator BenchmarkStats&lt;Duration2&gt;() const {
4250              std::vector&lt;Duration2&gt; samples2;
4251              samples2.reserve(samples.size());
4252              std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
4253              return {
4254                  info,
4255                  std::move(samples2),
4256                  mean,
4257                  standardDeviation,
4258                  outliers,
4259                  outlierVariance,
4260              };
4261          }
4262      };
4263  #endif 
4264      struct IStreamingReporter {
4265          virtual ~IStreamingReporter() = default;
4266          virtual ReporterPreferences getPreferences() const = 0;
4267          virtual void noMatchingTestCases( std::string const&amp; spec ) = 0;
4268          virtual void reportInvalidArguments(std::string const&amp;) {}
4269          virtual void testRunStarting( TestRunInfo const&amp; testRunInfo ) = 0;
4270          virtual void testGroupStarting( GroupInfo const&amp; groupInfo ) = 0;
4271          virtual void testCaseStarting( TestCaseInfo const&amp; testInfo ) = 0;
4272          virtual void sectionStarting( SectionInfo const&amp; sectionInfo ) = 0;
4273  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4274          virtual void benchmarkPreparing( std::string const&amp; ) {}
4275          virtual void benchmarkStarting( BenchmarkInfo const&amp; ) {}
4276          virtual void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; ) {}
4277          virtual void benchmarkFailed( std::string const&amp; ) {}
4278  #endif 
4279          virtual void assertionStarting( AssertionInfo const&amp; assertionInfo ) = 0;
4280          virtual bool assertionEnded( AssertionStats const&amp; assertionStats ) = 0;
4281          virtual void sectionEnded( SectionStats const&amp; sectionStats ) = 0;
4282          virtual void testCaseEnded( TestCaseStats const&amp; testCaseStats ) = 0;
4283          virtual void testGroupEnded( TestGroupStats const&amp; testGroupStats ) = 0;
4284          virtual void testRunEnded( TestRunStats const&amp; testRunStats ) = 0;
4285          virtual void skipTest( TestCaseInfo const&amp; testInfo ) = 0;
4286          virtual void fatalErrorEncountered( StringRef name );
4287          virtual bool isMulti() const;
4288      };
4289      using IStreamingReporterPtr = std::unique_ptr&lt;IStreamingReporter&gt;;
4290      struct IReporterFactory {
4291          virtual ~IReporterFactory();
4292          virtual IStreamingReporterPtr create( ReporterConfig const&amp; config ) const = 0;
4293          virtual std::string getDescription() const = 0;
4294      };
4295      using IReporterFactoryPtr = std::shared_ptr&lt;IReporterFactory&gt;;
4296      struct IReporterRegistry {
4297          using FactoryMap = std::map&lt;std::string, IReporterFactoryPtr&gt;;
4298          using Listeners = std::vector&lt;IReporterFactoryPtr&gt;;
4299          virtual ~IReporterRegistry();
4300          virtual IStreamingReporterPtr create( std::string const&amp; name, IConfigPtr const&amp; config ) const = 0;
4301          virtual FactoryMap const&amp; getFactories() const = 0;
4302          virtual Listeners const&amp; getListeners() const = 0;
4303      };
4304  } 
4305  #include &lt;algorithm&gt;
4306  #include &lt;cstring&gt;
4307  #include &lt;cfloat&gt;
4308  #include &lt;cstdio&gt;
4309  #include &lt;cassert&gt;
4310  #include &lt;memory&gt;
4311  #include &lt;ostream&gt;
4312  namespace Catch {
4313      void prepareExpandedExpression(AssertionResult&amp; result);
4314      std::string getFormattedDuration( double duration );
4315      bool shouldShowDuration( IConfig const&amp; config, double duration );
4316      std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; container );
4317      template&lt;typename DerivedT&gt;
4318      struct StreamingReporterBase : IStreamingReporter {
4319          StreamingReporterBase( ReporterConfig const&amp; _config )
4320          :   m_config( _config.fullConfig() ),
4321              stream( _config.stream() )
4322          {
4323              m_reporterPrefs.shouldRedirectStdOut = false;
4324              if( !DerivedT::getSupportedVerbosities().count( m_config-&gt;verbosity() ) )
4325                  CATCH_ERROR( &quot;Verbosity level not supported by this reporter&quot; );
4326          }
4327          ReporterPreferences getPreferences() const override {
4328              return m_reporterPrefs;
4329          }
4330          static std::set&lt;Verbosity&gt; getSupportedVerbosities() {
4331              return { Verbosity::Normal };
4332          }
4333          ~StreamingReporterBase() override = default;
4334          void noMatchingTestCases(std::string const&amp;) override {}
4335          void reportInvalidArguments(std::string const&amp;) override {}
4336          void testRunStarting(TestRunInfo const&amp; _testRunInfo) override {
4337              currentTestRunInfo = _testRunInfo;
4338          }
4339          void testGroupStarting(GroupInfo const&amp; _groupInfo) override {
4340              currentGroupInfo = _groupInfo;
4341          }
4342          void testCaseStarting(TestCaseInfo const&amp; _testInfo) override  {
4343              currentTestCaseInfo = _testInfo;
4344          }
4345          void sectionStarting(SectionInfo const&amp; _sectionInfo) override {
4346              m_sectionStack.push_back(_sectionInfo);
4347          }
4348          void sectionEnded(SectionStats const&amp; &amp;bsol;* _sectionStats */) override {
4349              m_sectionStack.pop_back();
4350          }
4351          void testCaseEnded(TestCaseStats const&amp; &amp;bsol;* _testCaseStats */) override {
4352              currentTestCaseInfo.reset();
4353          }
4354          void testGroupEnded(TestGroupStats const&amp; &amp;bsol;* _testGroupStats */) override {
4355              currentGroupInfo.reset();
4356          }
4357          void testRunEnded(TestRunStats const&amp; &amp;bsol;* _testRunStats */) override {
4358              currentTestCaseInfo.reset();
4359              currentGroupInfo.reset();
4360              currentTestRunInfo.reset();
4361          }
4362          void skipTest(TestCaseInfo const&amp;) override {
4363          }
4364          IConfigPtr m_config;
4365          std::ostream&amp; stream;
4366          LazyStat&lt;TestRunInfo&gt; currentTestRunInfo;
4367          LazyStat&lt;GroupInfo&gt; currentGroupInfo;
4368          LazyStat&lt;TestCaseInfo&gt; currentTestCaseInfo;
4369          std::vector&lt;SectionInfo&gt; m_sectionStack;
4370          ReporterPreferences m_reporterPrefs;
4371      };
4372      template&lt;typename DerivedT&gt;
4373      struct CumulativeReporterBase : IStreamingReporter {
4374          template&lt;typename T, typename ChildNodeT&gt;
4375          struct Node {
4376              explicit Node( T const&amp; _value ) : value( _value ) {}
4377              virtual ~Node() {}
4378              using ChildNodes = std::vector&lt;std::shared_ptr&lt;ChildNodeT&gt;&gt;;
4379              T value;
4380              ChildNodes children;
4381          };
4382          struct SectionNode {
4383              explicit SectionNode(SectionStats const&amp; _stats) : stats(_stats) {}
4384              virtual ~SectionNode() = default;
4385              bool operator == (SectionNode const&amp; other) const {
4386                  return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
4387              }
4388              bool operator == (std::shared_ptr&lt;SectionNode&gt; const&amp; other) const {
4389                  return operator==(*other);
4390              }
4391              SectionStats stats;
4392              using ChildSections = std::vector&lt;std::shared_ptr&lt;SectionNode&gt;&gt;;
4393              using Assertions = std::vector&lt;AssertionStats&gt;;
4394              ChildSections childSections;
4395              Assertions assertions;
4396              std::string stdOut;
4397              std::string stdErr;
4398          };
4399          struct BySectionInfo {
4400              BySectionInfo( SectionInfo const&amp; other ) : m_other( other ) {}
4401              BySectionInfo( BySectionInfo const&amp; other ) : m_other( other.m_other ) {}
4402              bool operator() (std::shared_ptr&lt;SectionNode&gt; const&amp; node) const {
4403                  return ((node-&gt;stats.sectionInfo.name == m_other.name) &amp;&amp;
4404                          (node-&gt;stats.sectionInfo.lineInfo == m_other.lineInfo));
4405              }
4406              void operator=(BySectionInfo const&amp;) = delete;
4407          private:
4408              SectionInfo const&amp; m_other;
4409          };
4410          using TestCaseNode = Node&lt;TestCaseStats, SectionNode&gt;;
4411          using TestGroupNode = Node&lt;TestGroupStats, TestCaseNode&gt;;
4412          using TestRunNode = Node&lt;TestRunStats, TestGroupNode&gt;;
4413          CumulativeReporterBase( ReporterConfig const&amp; _config )
4414          :   m_config( _config.fullConfig() ),
4415              stream( _config.stream() )
4416          {
4417              m_reporterPrefs.shouldRedirectStdOut = false;
4418              if( !DerivedT::getSupportedVerbosities().count( m_config-&gt;verbosity() ) )
4419                  CATCH_ERROR( &quot;Verbosity level not supported by this reporter&quot; );
4420          }
4421          ~CumulativeReporterBase() override = default;
4422          ReporterPreferences getPreferences() const override {
4423              return m_reporterPrefs;
4424          }
4425          static std::set&lt;Verbosity&gt; getSupportedVerbosities() {
4426              return { Verbosity::Normal };
4427          }
4428          void testRunStarting( TestRunInfo const&amp; ) override {}
4429          void testGroupStarting( GroupInfo const&amp; ) override {}
4430          void testCaseStarting( TestCaseInfo const&amp; ) override {}
4431          void sectionStarting( SectionInfo const&amp; sectionInfo ) override {
4432              SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
4433              std::shared_ptr&lt;SectionNode&gt; node;
4434              if( m_sectionStack.empty() ) {
4435                  if( !m_rootSection )
4436                      m_rootSection = std::make_shared&lt;SectionNode&gt;( incompleteStats );
4437                  node = m_rootSection;
4438              }
4439              else {
4440                  SectionNode&amp; parentNode = *m_sectionStack.back();
4441                  auto it =
4442                      std::find_if(   parentNode.childSections.begin(),
4443                                      parentNode.childSections.end(),
4444                                      BySectionInfo( sectionInfo ) );
4445                  if( it == parentNode.childSections.end() ) {
4446                      node = std::make_shared&lt;SectionNode&gt;( incompleteStats );
4447                      parentNode.childSections.push_back( node );
4448                  }
4449                  else
4450                      node = *it;
4451              }
4452              m_sectionStack.push_back( node );
4453              m_deepestSection = std::move(node);
4454          }
4455          void assertionStarting(AssertionInfo const&amp;) override {}
4456          bool assertionEnded(AssertionStats const&amp; assertionStats) override {
4457              assert(!m_sectionStack.empty());
4458              prepareExpandedExpression(const_cast&lt;AssertionResult&amp;&gt;( assertionStats.assertionResult ) );
4459              SectionNode&amp; sectionNode = *m_sectionStack.back();
4460              sectionNode.assertions.push_back(assertionStats);
4461              return true;
4462          }
4463          void sectionEnded(SectionStats const&amp; sectionStats) override {
4464              assert(!m_sectionStack.empty());
4465              SectionNode&amp; node = *m_sectionStack.back();
4466              node.stats = sectionStats;
4467              m_sectionStack.pop_back();
4468          }
4469          void testCaseEnded(TestCaseStats const&amp; testCaseStats) override {
4470              auto node = std::make_shared&lt;TestCaseNode&gt;(testCaseStats);
4471              assert(m_sectionStack.size() == 0);
4472              node-&gt;children.push_back(m_rootSection);
4473              m_testCases.push_back(node);
4474              m_rootSection.reset();
4475              assert(m_deepestSection);
4476              m_deepestSection-&gt;stdOut = testCaseStats.stdOut;
4477              m_deepestSection-&gt;stdErr = testCaseStats.stdErr;
4478          }
4479          void testGroupEnded(TestGroupStats const&amp; testGroupStats) override {
4480              auto node = std::make_shared&lt;TestGroupNode&gt;(testGroupStats);
4481              node-&gt;children.swap(m_testCases);
4482              m_testGroups.push_back(node);
4483          }
4484          void testRunEnded(TestRunStats const&amp; testRunStats) override {
4485              auto node = std::make_shared&lt;TestRunNode&gt;(testRunStats);
4486              node-&gt;children.swap(m_testGroups);
4487              m_testRuns.push_back(node);
4488              testRunEndedCumulative();
4489          }
4490          virtual void testRunEndedCumulative() = 0;
4491          void skipTest(TestCaseInfo const&amp;) override {}
4492          IConfigPtr m_config;
4493          std::ostream&amp; stream;
4494          std::vector&lt;AssertionStats&gt; m_assertions;
4495          std::vector&lt;std::vector&lt;std::shared_ptr&lt;SectionNode&gt;&gt;&gt; m_sections;
4496          std::vector&lt;std::shared_ptr&lt;TestCaseNode&gt;&gt; m_testCases;
4497          std::vector&lt;std::shared_ptr&lt;TestGroupNode&gt;&gt; m_testGroups;
4498          std::vector&lt;std::shared_ptr&lt;TestRunNode&gt;&gt; m_testRuns;
4499          std::shared_ptr&lt;SectionNode&gt; m_rootSection;
4500          std::shared_ptr&lt;SectionNode&gt; m_deepestSection;
4501          std::vector&lt;std::shared_ptr&lt;SectionNode&gt;&gt; m_sectionStack;
4502          ReporterPreferences m_reporterPrefs;
4503      };
4504      template&lt;char C&gt;
4505      char const* getLineOfChars() {
4506          static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
4507          if( !*line ) {
4508              std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
4509              line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
4510          }
4511          return line;
4512      }
4513      struct TestEventListenerBase : StreamingReporterBase&lt;TestEventListenerBase&gt; {
4514          TestEventListenerBase( ReporterConfig const&amp; _config );
4515          static std::set&lt;Verbosity&gt; getSupportedVerbosities();
4516          void assertionStarting(AssertionInfo const&amp;) override;
4517          bool assertionEnded(AssertionStats const&amp;) override;
4518      };
4519  } 
4520  namespace Catch {
4521      struct Colour {
4522          enum Code {
4523              None = 0,
4524              White,
4525              Red,
4526              Green,
4527              Blue,
4528              Cyan,
4529              Yellow,
4530              Grey,
4531              Bright = 0x10,
4532              BrightRed = Bright | Red,
4533              BrightGreen = Bright | Green,
4534              LightGrey = Bright | Grey,
4535              BrightWhite = Bright | White,
4536              BrightYellow = Bright | Yellow,
4537              FileName = LightGrey,
4538              Warning = BrightYellow,
4539              ResultError = BrightRed,
4540              ResultSuccess = BrightGreen,
4541              ResultExpectedFailure = Warning,
4542              Error = BrightRed,
4543              Success = Green,
4544              OriginalExpression = Cyan,
4545              ReconstructedExpression = BrightYellow,
4546              SecondaryText = LightGrey,
4547              Headers = White
4548          };
4549          Colour( Code _colourCode );
4550          Colour( Colour&amp;&amp; other ) noexcept;
4551          Colour&amp; operator=( Colour&amp;&amp; other ) noexcept;
4552          ~Colour();
4553          static void use( Code _colourCode );
4554      private:
4555          bool m_moved = false;
4556      };
4557      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Colour const&amp; );
4558  } 
4559  namespace Catch {
4560      template&lt;typename T&gt;
4561      class ReporterRegistrar {
4562          class ReporterFactory : public IReporterFactory {
4563              IStreamingReporterPtr create( ReporterConfig const&amp; config ) const override {
4564                  return std::unique_ptr&lt;T&gt;( new T( config ) );
4565              }
4566              std::string getDescription() const override {
4567                  return T::getDescription();
4568              }
4569          };
4570      public:
4571          explicit ReporterRegistrar( std::string const&amp; name ) {
4572              getMutableRegistryHub().registerReporter( name, std::make_shared&lt;ReporterFactory&gt;() );
4573          }
4574      };
4575      template&lt;typename T&gt;
4576      class ListenerRegistrar {
4577          class ListenerFactory : public IReporterFactory {
4578              IStreamingReporterPtr create( ReporterConfig const&amp; config ) const override {
4579                  return std::unique_ptr&lt;T&gt;( new T( config ) );
4580              }
4581              std::string getDescription() const override {
4582                  return std::string();
4583              }
4584          };
4585      public:
4586          ListenerRegistrar() {
4587              getMutableRegistryHub().registerListener( std::make_shared&lt;ListenerFactory&gt;() );
4588          }
4589      };
4590  }
4591  #if !defined(CATCH_CONFIG_DISABLE)
4592  #define CATCH_REGISTER_REPORTER( name, reporterType ) \
4593      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION         \
4594      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
4595      namespace{ Catch::ReporterRegistrar&lt;reporterType&gt; catch_internal_RegistrarFor##reporterType( name ); } \
4596      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
4597  #define CATCH_REGISTER_LISTENER( listenerType ) \
4598      CATCH_INTERNAL_START_WARNINGS_SUPPRESSION   \
4599      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS    \
4600      namespace{ Catch::ListenerRegistrar&lt;listenerType&gt; catch_internal_RegistrarFor##listenerType; } \
4601      CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
4602  #else 
4603  #define CATCH_REGISTER_REPORTER(name, reporterType)
4604  #define CATCH_REGISTER_LISTENER(listenerType)
4605  #endif 
4606  namespace Catch {
4607      struct CompactReporter : StreamingReporterBase&lt;CompactReporter&gt; {
4608          using StreamingReporterBase::StreamingReporterBase;
4609          ~CompactReporter() override;
4610          static std::string getDescription();
4611          void noMatchingTestCases(std::string const&amp; spec) override;
4612          void assertionStarting(AssertionInfo const&amp;) override;
4613          bool assertionEnded(AssertionStats const&amp; _assertionStats) override;
4614          void sectionEnded(SectionStats const&amp; _sectionStats) override;
4615          void testRunEnded(TestRunStats const&amp; _testRunStats) override;
4616      };
4617  } 
4618  #if defined(_MSC_VER)
4619  #pragma warning(push)
4620  #pragma warning(disable:4061) 
4621  #endif
4622  namespace Catch {
4623      struct SummaryColumn;
4624      class TablePrinter;
4625      struct ConsoleReporter : StreamingReporterBase&lt;ConsoleReporter&gt; {
4626          std::unique_ptr&lt;TablePrinter&gt; m_tablePrinter;
4627          ConsoleReporter(ReporterConfig const&amp; config);
4628          ~ConsoleReporter() override;
4629          static std::string getDescription();
4630          void noMatchingTestCases(std::string const&amp; spec) override;
4631          void reportInvalidArguments(std::string const&amp;arg) override;
4632          void assertionStarting(AssertionInfo const&amp;) override;
4633          bool assertionEnded(AssertionStats const&amp; _assertionStats) override;
4634          void sectionStarting(SectionInfo const&amp; _sectionInfo) override;
4635          void sectionEnded(SectionStats const&amp; _sectionStats) override;
4636  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4637          void benchmarkPreparing(std::string const&amp; name) override;
4638          void benchmarkStarting(BenchmarkInfo const&amp; info) override;
4639          void benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) override;
4640          void benchmarkFailed(std::string const&amp; error) override;
4641  #endif 
4642          void testCaseEnded(TestCaseStats const&amp; _testCaseStats) override;
4643          void testGroupEnded(TestGroupStats const&amp; _testGroupStats) override;
4644          void testRunEnded(TestRunStats const&amp; _testRunStats) override;
4645          void testRunStarting(TestRunInfo const&amp; _testRunInfo) override;
4646      private:
4647          void lazyPrint();
4648          void lazyPrintWithoutClosingBenchmarkTable();
4649          void lazyPrintRunInfo();
4650          void lazyPrintGroupInfo();
4651          void printTestCaseAndSectionHeader();
4652          void printClosedHeader(std::string const&amp; _name);
4653          void printOpenHeader(std::string const&amp; _name);
4654          void printHeaderString(std::string const&amp; _string, std::size_t indent = 0);
4655          void printTotals(Totals const&amp; totals);
4656          void printSummaryRow(std::string const&amp; label, std::vector&lt;SummaryColumn&gt; const&amp; cols, std::size_t row);
4657          void printTotalsDivider(Totals const&amp; totals);
4658          void printSummaryDivider();
4659          void printTestFilters();
4660      private:
4661          bool m_headerPrinted = false;
4662      };
4663  } 
4664  #if defined(_MSC_VER)
4665  #pragma warning(pop)
4666  #endif
4667  #include &lt;vector&gt;
4668  namespace Catch {
4669      enum class XmlFormatting {
4670          None = 0x00,
4671          Indent = 0x01,
4672          Newline = 0x02,
4673      };
4674      XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);
4675      XmlFormatting operator &amp; (XmlFormatting lhs, XmlFormatting rhs);
4676      class XmlEncode {
4677      public:
4678          enum ForWhat { ForTextNodes, ForAttributes };
4679          XmlEncode( std::string const&amp; str, ForWhat forWhat = ForTextNodes );
4680          void encodeTo( std::ostream&amp; os ) const;
4681          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode );
4682      private:
4683          std::string m_str;
4684          ForWhat m_forWhat;
4685      };
4686      class XmlWriter {
4687      public:
4688          class ScopedElement {
4689          public:
4690              ScopedElement( XmlWriter* writer, XmlFormatting fmt );
4691              ScopedElement( ScopedElement&amp;&amp; other ) noexcept;
4692              ScopedElement&amp; operator=( ScopedElement&amp;&amp; other ) noexcept;
4693              ~ScopedElement();
4694              ScopedElement&amp; writeText( std::string const&amp; text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );
4695              template&lt;typename T&gt;
4696              ScopedElement&amp; writeAttribute( std::string const&amp; name, T const&amp; attribute ) {
4697                  m_writer-&gt;writeAttribute( name, attribute );
4698                  return *this;
4699              }
4700          private:
4701              mutable XmlWriter* m_writer = nullptr;
4702              XmlFormatting m_fmt;
4703          };
4704          XmlWriter( std::ostream&amp; os = Catch::cout() );
4705          ~XmlWriter();
4706          XmlWriter( XmlWriter const&amp; ) = delete;
4707          XmlWriter&amp; operator=( XmlWriter const&amp; ) = delete;
4708          XmlWriter&amp; startElement( std::string const&amp; name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4709          ScopedElement scopedElement( std::string const&amp; name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4710          XmlWriter&amp; endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4711          XmlWriter&amp; writeAttribute( std::string const&amp; name, std::string const&amp; attribute );
4712          XmlWriter&amp; writeAttribute( std::string const&amp; name, bool attribute );
4713          template&lt;typename T&gt;
4714          XmlWriter&amp; writeAttribute( std::string const&amp; name, T const&amp; attribute ) {
4715              ReusableStringStream rss;
4716              rss &lt;&lt; attribute;
4717              return writeAttribute( name, rss.str() );
4718          }
4719          XmlWriter&amp; writeText( std::string const&amp; text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4720          XmlWriter&amp; writeComment(std::string const&amp; text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
4721          void writeStylesheetRef( std::string const&amp; url );
4722          XmlWriter&amp; writeBlankLine();
4723          void ensureTagClosed();
4724      private:
4725          void applyFormatting(XmlFormatting fmt);
4726          void writeDeclaration();
4727          void newlineIfNecessary();
4728          bool m_tagIsOpen = false;
4729          bool m_needsNewline = false;
4730          std::vector&lt;std::string&gt; m_tags;
4731          std::string m_indent;
4732          std::ostream&amp; m_os;
4733      };
4734  }
4735  namespace Catch {
4736      class JunitReporter : public CumulativeReporterBase&lt;JunitReporter&gt; {
4737      public:
4738          JunitReporter(ReporterConfig const&amp; _config);
4739          ~JunitReporter() override;
4740          static std::string getDescription();
4741          void noMatchingTestCases(std::string const&amp; &amp;bsol;*spec*/) override;
4742          void testRunStarting(TestRunInfo const&amp; runInfo) override;
4743          void testGroupStarting(GroupInfo const&amp; groupInfo) override;
4744          void testCaseStarting(TestCaseInfo const&amp; testCaseInfo) override;
4745          bool assertionEnded(AssertionStats const&amp; assertionStats) override;
4746          void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;
4747          void testGroupEnded(TestGroupStats const&amp; testGroupStats) override;
4748          void testRunEndedCumulative() override;
4749          void writeGroup(TestGroupNode const&amp; groupNode, double suiteTime);
4750          void writeTestCase(TestCaseNode const&amp; testCaseNode);
4751          void writeSection( std::string const&amp; className,
4752                             std::string const&amp; rootName,
4753                             SectionNode const&amp; sectionNode,
4754                             bool testOkToFail );
4755          void writeAssertions(SectionNode const&amp; sectionNode);
4756          void writeAssertion(AssertionStats const&amp; stats);
4757          XmlWriter xml;
4758          Timer suiteTimer;
4759          std::string stdOutForSuite;
4760          std::string stdErrForSuite;
4761          unsigned int unexpectedExceptions = 0;
4762          bool m_okToFail = false;
4763      };
4764  } 
4765  namespace Catch {
4766      class XmlReporter : public StreamingReporterBase&lt;XmlReporter&gt; {
4767      public:
4768          XmlReporter(ReporterConfig const&amp; _config);
4769          ~XmlReporter() override;
4770          static std::string getDescription();
4771          virtual std::string getStylesheetRef() const;
4772          void writeSourceInfo(SourceLineInfo const&amp; sourceInfo);
4773      public: 
4774          void noMatchingTestCases(std::string const&amp; s) override;
4775          void testRunStarting(TestRunInfo const&amp; testInfo) override;
4776          void testGroupStarting(GroupInfo const&amp; groupInfo) override;
4777          void testCaseStarting(TestCaseInfo const&amp; testInfo) override;
4778          void sectionStarting(SectionInfo const&amp; sectionInfo) override;
4779          void assertionStarting(AssertionInfo const&amp;) override;
4780          bool assertionEnded(AssertionStats const&amp; assertionStats) override;
4781          void sectionEnded(SectionStats const&amp; sectionStats) override;
4782          void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;
4783          void testGroupEnded(TestGroupStats const&amp; testGroupStats) override;
4784          void testRunEnded(TestRunStats const&amp; testRunStats) override;
4785  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4786          void benchmarkPreparing(std::string const&amp; name) override;
4787          void benchmarkStarting(BenchmarkInfo const&amp;) override;
4788          void benchmarkEnded(BenchmarkStats&lt;&gt; const&amp;) override;
4789          void benchmarkFailed(std::string const&amp;) override;
4790  #endif 
4791      private:
4792          Timer m_testCaseTimer;
4793          XmlWriter m_xml;
4794          int m_sectionDepth = 0;
4795      };
4796  } 
4797  #endif
4798  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
4799  #include &lt;chrono&gt;
4800  #include &lt;ratio&gt;
4801  namespace Catch {
4802      namespace Benchmark {
4803          template &lt;typename Clock&gt;
4804          using ClockDuration = typename Clock::duration;
4805          template &lt;typename Clock&gt;
4806          using FloatDuration = std::chrono::duration&lt;double, typename Clock::period&gt;;
4807          template &lt;typename Clock&gt;
4808          using TimePoint = typename Clock::time_point;
4809          using default_clock = std::chrono::steady_clock;
4810          template &lt;typename Clock&gt;
4811          struct now {
4812              TimePoint&lt;Clock&gt; operator()() const {
4813                  return Clock::now();
4814              }
4815          };
4816          using fp_seconds = std::chrono::duration&lt;double, std::ratio&lt;1&gt;&gt;;
4817      } 
4818  } 
4819  #if defined(_MSC_VER)
4820  #   include &lt;atomic&gt; 
4821  #endif
4822  namespace Catch {
4823      namespace Benchmark {
4824  #if defined(__GNUC__) || defined(__clang__)
4825          template &lt;typename T&gt;
4826          inline void keep_memory(T* p) {
4827              asm volatile(&quot;&quot; : : &quot;g&quot;(p) : &quot;memory&quot;);
4828          }
4829          inline void keep_memory() {
4830              asm volatile(&quot;&quot; : : : &quot;memory&quot;);
4831          }
4832          namespace Detail {
4833              inline void optimizer_barrier() { keep_memory(); }
4834          } 
4835  #elif defined(_MSC_VER)
4836  #pragma optimize(&quot;&quot;, off)
4837          template &lt;typename T&gt;
4838          inline void keep_memory(T* p) {
4839              *reinterpret_cast&lt;char volatile*&gt;(p) = *reinterpret_cast&lt;char const volatile*&gt;(p);
4840          }
4841  #pragma optimize(&quot;&quot;, on)
4842          namespace Detail {
4843              inline void optimizer_barrier() {
4844                  std::atomic_thread_fence(std::memory_order_seq_cst);
4845              }
4846          } 
4847  #endif
4848          template &lt;typename T&gt;
4849          inline void deoptimize_value(T&amp;&amp; x) {
4850              keep_memory(&amp;x);
4851          }
4852          template &lt;typename Fn, typename... Args&gt;
4853          inline auto invoke_deoptimized(Fn&amp;&amp; fn, Args&amp;&amp;... args) -&gt; typename std::enable_if&lt;!std::is_same&lt;void, decltype(fn(args...))&gt;::value&gt;::type {
4854              deoptimize_value(std::forward&lt;Fn&gt;(fn) (std::forward&lt;Args...&gt;(args...)));
4855          }
4856          template &lt;typename Fn, typename... Args&gt;
4857          inline auto invoke_deoptimized(Fn&amp;&amp; fn, Args&amp;&amp;... args) -&gt; typename std::enable_if&lt;std::is_same&lt;void, decltype(fn(args...))&gt;::value&gt;::type {
4858              std::forward&lt;Fn&gt;(fn) (std::forward&lt;Args...&gt;(args...));
4859          }
4860      } 
4861  } 
4862  #include &lt;type_traits&gt;
4863  #include &lt;utility&gt;
4864  namespace Catch {
4865      namespace Benchmark {
4866          namespace Detail {
4867              template &lt;typename T&gt;
4868              struct CompleteType { using type = T; };
4869              template &lt;&gt;
4870              struct CompleteType&lt;void&gt; { struct type {}; };
4871              template &lt;typename T&gt;
4872              using CompleteType_t = typename CompleteType&lt;T&gt;::type;
4873              template &lt;typename Result&gt;
4874              struct CompleteInvoker {
4875                  template &lt;typename Fun, typename... Args&gt;
4876                  static Result invoke(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
4877                      return std::forward&lt;Fun&gt;(fun)(std::forward&lt;Args&gt;(args)...);
4878                  }
4879              };
4880              template &lt;&gt;
4881              struct CompleteInvoker&lt;void&gt; {
4882                  template &lt;typename Fun, typename... Args&gt;
4883                  static CompleteType_t&lt;void&gt; invoke(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
4884                      std::forward&lt;Fun&gt;(fun)(std::forward&lt;Args&gt;(args)...);
4885                      return {};
4886                  }
4887              };
4888              template &lt;typename Fun, typename... Args&gt;
4889              CompleteType_t&lt;FunctionReturnType&lt;Fun, Args...&gt;&gt; complete_invoke(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
4890                  return CompleteInvoker&lt;FunctionReturnType&lt;Fun, Args...&gt;&gt;::invoke(std::forward&lt;Fun&gt;(fun), std::forward&lt;Args&gt;(args)...);
4891              }
4892              const std::string benchmarkErrorMsg = &quot;a benchmark failed to run successfully&quot;;
4893          } 
4894          template &lt;typename Fun&gt;
4895          Detail::CompleteType_t&lt;FunctionReturnType&lt;Fun&gt;&gt; user_code(Fun&amp;&amp; fun) {
4896              CATCH_TRY{
4897                  return Detail::complete_invoke(std::forward&lt;Fun&gt;(fun));
4898              } CATCH_CATCH_ALL{
4899                  getResultCapture().benchmarkFailed(translateActiveException());
4900                  CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);
4901              }
4902          }
4903      } 
4904  } 
4905  namespace Catch {
4906      namespace Benchmark {
4907          namespace Detail {
4908              struct ChronometerConcept {
4909                  virtual void start() = 0;
4910                  virtual void finish() = 0;
4911                  virtual ~ChronometerConcept() = default;
4912              };
4913              template &lt;typename Clock&gt;
4914              struct ChronometerModel final : public ChronometerConcept {
4915                  void start() override { started = Clock::now(); }
4916                  void finish() override { finished = Clock::now(); }
4917                  ClockDuration&lt;Clock&gt; elapsed() const { return finished - started; }
4918                  TimePoint&lt;Clock&gt; started;
4919                  TimePoint&lt;Clock&gt; finished;
4920              };
4921          } 
4922          struct Chronometer {
4923          public:
4924              template &lt;typename Fun&gt;
4925              void measure(Fun&amp;&amp; fun) { measure(std::forward&lt;Fun&gt;(fun), is_callable&lt;Fun(int)&gt;()); }
4926              int runs() const { return k; }
4927              Chronometer(Detail::ChronometerConcept&amp; meter, int k)
4928                  : impl(&amp;meter)
4929                  , k(k) {}
4930          private:
4931              template &lt;typename Fun&gt;
4932              void measure(Fun&amp;&amp; fun, std::false_type) {
4933                  measure([&amp;fun](int) { return fun(); }, std::true_type());
4934              }
4935              template &lt;typename Fun&gt;
4936              void measure(Fun&amp;&amp; fun, std::true_type) {
4937                  Detail::optimizer_barrier();
4938                  impl-&gt;start();
4939                  for (int i = 0; i &lt; k; ++i) invoke_deoptimized(fun, i);
4940                  impl-&gt;finish();
4941                  Detail::optimizer_barrier();
4942              }
4943              Detail::ChronometerConcept* impl;
4944              int k;
4945          };
4946      } 
4947  } 
4948  namespace Catch {
4949      namespace Benchmark {
4950          template &lt;typename Duration&gt;
4951          struct EnvironmentEstimate {
4952              Duration mean;
4953              OutlierClassification outliers;
4954              template &lt;typename Duration2&gt;
4955              operator EnvironmentEstimate&lt;Duration2&gt;() const {
4956                  return { mean, outliers };
4957              }
4958          };
4959          template &lt;typename Clock&gt;
4960          struct Environment {
4961              using clock_type = Clock;
4962              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; clock_resolution;
4963              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; clock_cost;
4964          };
4965      } 
4966  } 
4967  #include &lt;cassert&gt;
4968  #include &lt;type_traits&gt;
4969  #include &lt;utility&gt;
4970  #include &lt;memory&gt;
4971  namespace Catch {
4972      namespace Benchmark {
4973          namespace Detail {
4974              template &lt;typename T&gt;
4975              using Decay = typename std::decay&lt;T&gt;::type;
4976              template &lt;typename T, typename U&gt;
4977              struct is_related
4978                  : std::is_same&lt;Decay&lt;T&gt;, Decay&lt;U&gt;&gt; {};
4979              struct BenchmarkFunction {
4980              private:
4981                  struct callable {
4982                      virtual void call(Chronometer meter) const = 0;
4983                      virtual callable* clone() const = 0;
4984                      virtual ~callable() = default;
4985                  };
4986                  template &lt;typename Fun&gt;
4987                  struct model : public callable {
4988                      model(Fun&amp;&amp; fun) : fun(std::move(fun)) {}
4989                      model(Fun const&amp; fun) : fun(fun) {}
4990                      model&lt;Fun&gt;* clone() const override { return new model&lt;Fun&gt;(*this); }
4991                      void call(Chronometer meter) const override {
4992                          call(meter, is_callable&lt;Fun(Chronometer)&gt;());
4993                      }
4994                      void call(Chronometer meter, std::true_type) const {
4995                          fun(meter);
4996                      }
4997                      void call(Chronometer meter, std::false_type) const {
4998                          meter.measure(fun);
4999                      }
5000                      Fun fun;
5001                  };
5002                  struct do_nothing { void operator()() const {} };
5003                  template &lt;typename T&gt;
5004                  BenchmarkFunction(model&lt;T&gt;* c) : f(c) {}
5005              public:
5006                  BenchmarkFunction()
5007                      : f(new model&lt;do_nothing&gt;{ {} }) {}
5008                  template &lt;typename Fun,
5009                      typename std::enable_if&lt;!is_related&lt;Fun, BenchmarkFunction&gt;::value, int&gt;::type = 0&gt;
5010                      BenchmarkFunction(Fun&amp;&amp; fun)
5011                      : f(new model&lt;typename std::decay&lt;Fun&gt;::type&gt;(std::forward&lt;Fun&gt;(fun))) {}
5012                  BenchmarkFunction(BenchmarkFunction&amp;&amp; that)
5013                      : f(std::move(that.f)) {}
5014                  BenchmarkFunction(BenchmarkFunction const&amp; that)
5015                      : f(that.f-&gt;clone()) {}
5016                  BenchmarkFunction&amp; operator=(BenchmarkFunction&amp;&amp; that) {
5017                      f = std::move(that.f);
5018                      return *this;
5019                  }
5020                  BenchmarkFunction&amp; operator=(BenchmarkFunction const&amp; that) {
5021                      f.reset(that.f-&gt;clone());
5022                      return *this;
5023                  }
5024                  void operator()(Chronometer meter) const { f-&gt;call(meter); }
5025              private:
5026                  std::unique_ptr&lt;callable&gt; f;
5027              };
5028          } 
5029      } 
5030  } 
5031  #include &lt;type_traits&gt;
5032  #include &lt;utility&gt;
5033  namespace Catch {
5034      namespace Benchmark {
5035          namespace Detail {
5036              template &lt;typename Fun&gt;
5037              struct repeater {
5038                  void operator()(int k) const {
5039                      for (int i = 0; i &lt; k; ++i) {
5040                          fun();
5041                      }
5042                  }
5043                  Fun fun;
5044              };
5045              template &lt;typename Fun&gt;
5046              repeater&lt;typename std::decay&lt;Fun&gt;::type&gt; repeat(Fun&amp;&amp; fun) {
5047                  return { std::forward&lt;Fun&gt;(fun) };
5048              }
5049          } 
5050      } 
5051  } 
5052  #include &lt;tuple&gt;
5053  #include &lt;type_traits&gt;
5054  namespace Catch {
5055      namespace Benchmark {
5056          template &lt;typename Duration, typename Result&gt;
5057          struct Timing {
5058              Duration elapsed;
5059              Result result;
5060              int iterations;
5061          };
5062          template &lt;typename Clock, typename Func, typename... Args&gt;
5063          using TimingOf = Timing&lt;ClockDuration&lt;Clock&gt;, Detail::CompleteType_t&lt;FunctionReturnType&lt;Func, Args...&gt;&gt;&gt;;
5064      } 
5065  } 
5066  #include &lt;utility&gt;
5067  namespace Catch {
5068      namespace Benchmark {
5069          namespace Detail {
5070              template &lt;typename Clock, typename Fun, typename... Args&gt;
5071              TimingOf&lt;Clock, Fun, Args...&gt; measure(Fun&amp;&amp; fun, Args&amp;&amp;... args) {
5072                  auto start = Clock::now();
5073                  auto&amp;&amp; r = Detail::complete_invoke(fun, std::forward&lt;Args&gt;(args)...);
5074                  auto end = Clock::now();
5075                  auto delta = end - start;
5076                  return { delta, std::forward&lt;decltype(r)&gt;(r), 1 };
5077              }
5078          } 
5079      } 
5080  } 
5081  #include &lt;utility&gt;
5082  #include &lt;type_traits&gt;
5083  namespace Catch {
5084      namespace Benchmark {
5085          namespace Detail {
5086              template &lt;typename Clock, typename Fun&gt;
5087              TimingOf&lt;Clock, Fun, int&gt; measure_one(Fun&amp;&amp; fun, int iters, std::false_type) {
5088                  return Detail::measure&lt;Clock&gt;(fun, iters);
5089              }
5090              template &lt;typename Clock, typename Fun&gt;
5091              TimingOf&lt;Clock, Fun, Chronometer&gt; measure_one(Fun&amp;&amp; fun, int iters, std::true_type) {
5092                  Detail::ChronometerModel&lt;Clock&gt; meter;
5093                  auto&amp;&amp; result = Detail::complete_invoke(fun, Chronometer(meter, iters));
5094                  return { meter.elapsed(), std::move(result), iters };
5095              }
5096              template &lt;typename Clock, typename Fun&gt;
5097              using run_for_at_least_argument_t = typename std::conditional&lt;is_callable&lt;Fun(Chronometer)&gt;::value, Chronometer, int&gt;::type;
5098              struct optimized_away_error : std::exception {
5099                  const char* what() const noexcept override {
5100                      return &quot;could not measure benchmark, maybe it was optimized away&quot;;
5101                  }
5102              };
5103              template &lt;typename Clock, typename Fun&gt;
5104              TimingOf&lt;Clock, Fun, run_for_at_least_argument_t&lt;Clock, Fun&gt;&gt; run_for_at_least(ClockDuration&lt;Clock&gt; how_long, int seed, Fun&amp;&amp; fun) {
5105                  auto iters = seed;
5106                  while (iters &lt; (1 &lt;&lt; 30)) {
5107                      auto&amp;&amp; Timing = measure_one&lt;Clock&gt;(fun, iters, is_callable&lt;Fun(Chronometer)&gt;());
5108                      if (Timing.elapsed &gt;= how_long) {
5109                          return { Timing.elapsed, std::move(Timing.result), iters };
5110                      }
5111                      iters *= 2;
5112                  }
5113                  Catch::throw_exception(optimized_away_error{});
5114              }
5115          } 
5116      } 
5117  } 
5118  #include &lt;algorithm&gt;
5119  #include &lt;iterator&gt;
5120  namespace Catch {
5121      namespace Benchmark {
5122          template &lt;typename Duration&gt;
5123          struct ExecutionPlan {
5124              int iterations_per_sample;
5125              Duration estimated_duration;
5126              Detail::BenchmarkFunction benchmark;
5127              Duration warmup_time;
5128              int warmup_iterations;
5129              template &lt;typename Duration2&gt;
5130              operator ExecutionPlan&lt;Duration2&gt;() const {
5131                  return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };
5132              }
5133              template &lt;typename Clock&gt;
5134              std::vector&lt;FloatDuration&lt;Clock&gt;&gt; run(const IConfig &amp;cfg, Environment&lt;FloatDuration&lt;Clock&gt;&gt; env) const {
5135                  Detail::run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(warmup_time), warmup_iterations, Detail::repeat(now&lt;Clock&gt;{}));
5136                  std::vector&lt;FloatDuration&lt;Clock&gt;&gt; times;
5137                  times.reserve(cfg.benchmarkSamples());
5138                  std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {
5139                      Detail::ChronometerModel&lt;Clock&gt; model;
5140                      this-&gt;benchmark(Chronometer(model, iterations_per_sample));
5141                      auto sample_time = model.elapsed() - env.clock_cost.mean;
5142                      if (sample_time &lt; FloatDuration&lt;Clock&gt;::zero()) sample_time = FloatDuration&lt;Clock&gt;::zero();
5143                      return sample_time / iterations_per_sample;
5144                  });
5145                  return times;
5146              }
5147          };
5148      } 
5149  } 
5150  #include &lt;algorithm&gt;
5151  #include &lt;functional&gt;
5152  #include &lt;vector&gt;
5153  #include &lt;iterator&gt;
5154  #include &lt;numeric&gt;
5155  #include &lt;tuple&gt;
5156  #include &lt;cmath&gt;
5157  #include &lt;utility&gt;
5158  #include &lt;cstddef&gt;
5159  #include &lt;random&gt;
5160  namespace Catch {
5161      namespace Benchmark {
5162          namespace Detail {
5163              using sample = std::vector&lt;double&gt;;
5164              double weighted_average_quantile(int k, int q, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last);
5165              template &lt;typename Iterator&gt;
5166              OutlierClassification classify_outliers(Iterator first, Iterator last) {
5167                  std::vector&lt;double&gt; copy(first, last);
5168                  auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());
5169                  auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());
5170                  auto iqr = q3 - q1;
5171                  auto los = q1 - (iqr * 3.);
5172                  auto lom = q1 - (iqr * 1.5);
5173                  auto him = q3 + (iqr * 1.5);
5174                  auto his = q3 + (iqr * 3.);
5175                  OutlierClassification o;
5176                  for (; first != last; ++first) {
5177                      auto&amp;&amp; t = *first;
5178                      if (t &lt; los) ++o.low_severe;
5179                      else if (t &lt; lom) ++o.low_mild;
5180                      else if (t &gt; his) ++o.high_severe;
5181                      else if (t &gt; him) ++o.high_mild;
5182                      ++o.samples_seen;
5183                  }
5184                  return o;
5185              }
5186              template &lt;typename Iterator&gt;
5187              double mean(Iterator first, Iterator last) {
5188                  auto count = last - first;
5189                  double sum = std::accumulate(first, last, 0.);
5190                  return sum / count;
5191              }
5192              template &lt;typename URng, typename Iterator, typename Estimator&gt;
5193              sample resample(URng&amp; rng, int resamples, Iterator first, Iterator last, Estimator&amp; estimator) {
5194                  auto n = last - first;
5195                  std::uniform_int_distribution&lt;decltype(n)&gt; dist(0, n - 1);
5196                  sample out;
5197                  out.reserve(resamples);
5198                  std::generate_n(std::back_inserter(out), resamples, [n, first, &amp;estimator, &amp;dist, &amp;rng] {
5199                      std::vector&lt;double&gt; resampled;
5200                      resampled.reserve(n);
5201                      std::generate_n(std::back_inserter(resampled), n, [first, &amp;dist, &amp;rng] { return first[dist(rng)]; });
5202                      return estimator(resampled.begin(), resampled.end());
5203                  });
5204                  std::sort(out.begin(), out.end());
5205                  return out;
5206              }
5207              template &lt;typename Estimator, typename Iterator&gt;
5208              sample jackknife(Estimator&amp;&amp; estimator, Iterator first, Iterator last) {
5209                  auto n = last - first;
5210                  auto second = std::next(first);
5211                  sample results;
5212                  results.reserve(n);
5213                  for (auto it = first; it != last; ++it) {
5214                      std::iter_swap(it, first);
5215                      results.push_back(estimator(second, last));
5216                  }
5217                  return results;
5218              }
5219              inline double normal_cdf(double x) {
5220                  return std::erfc(-x / std::sqrt(2.0)) / 2.0;
5221              }
5222              double erfc_inv(double x);
5223              double normal_quantile(double p);
5224              template &lt;typename Iterator, typename Estimator&gt;
5225              Estimate&lt;double&gt; bootstrap(double confidence_level, Iterator first, Iterator last, sample const&amp; resample, Estimator&amp;&amp; estimator) {
5226                  auto n_samples = last - first;
5227                  double point = estimator(first, last);
5228                  if (n_samples == 1) return { point, point, point, confidence_level };
5229                  sample jack = jackknife(estimator, first, last);
5230                  double jack_mean = mean(jack.begin(), jack.end());
5231                  double sum_squares, sum_cubes;
5232                  std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair&lt;double, double&gt; sqcb, double x) -&gt; std::pair&lt;double, double&gt; {
5233                      auto d = jack_mean - x;
5234                      auto d2 = d * d;
5235                      auto d3 = d2 * d;
5236                      return { sqcb.first + d2, sqcb.second + d3 };
5237                  });
5238                  double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));
5239                  int n = static_cast&lt;int&gt;(resample.size());
5240                  double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x &lt; point; }) / (double)n;
5241                  if (prob_n == 0) return { point, point, point, confidence_level };
5242                  double bias = normal_quantile(prob_n);
5243                  double z1 = normal_quantile((1. - confidence_level) / 2.);
5244                  auto cumn = [n](double x) -&gt; int {
5245                      return std::lround(normal_cdf(x) * n); };
5246                  auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };
5247                  double b1 = bias + z1;
5248                  double b2 = bias - z1;
5249                  double a1 = a(b1);
5250                  double a2 = a(b2);
5251                  auto lo = (std::max)(cumn(a1), 0);
5252                  auto hi = (std::min)(cumn(a2), n - 1);
5253                  return { point, resample[lo], resample[hi], confidence_level };
5254              }
5255              double outlier_variance(Estimate&lt;double&gt; mean, Estimate&lt;double&gt; stddev, int n);
5256              struct bootstrap_analysis {
5257                  Estimate&lt;double&gt; mean;
5258                  Estimate&lt;double&gt; standard_deviation;
5259                  double outlier_variance;
5260              };
5261              bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last);
5262          } 
5263      } 
5264  } 
5265  #include &lt;algorithm&gt;
5266  #include &lt;iterator&gt;
5267  #include &lt;tuple&gt;
5268  #include &lt;vector&gt;
5269  #include &lt;cmath&gt;
5270  namespace Catch {
5271      namespace Benchmark {
5272          namespace Detail {
5273              template &lt;typename Clock&gt;
5274              std::vector&lt;double&gt; resolution(int k) {
5275                  std::vector&lt;TimePoint&lt;Clock&gt;&gt; times;
5276                  times.reserve(k + 1);
5277                  std::generate_n(std::back_inserter(times), k + 1, now&lt;Clock&gt;{});
5278                  std::vector&lt;double&gt; deltas;
5279                  deltas.reserve(k);
5280                  std::transform(std::next(times.begin()), times.end(), times.begin(),
5281                      std::back_inserter(deltas),
5282                      [](TimePoint&lt;Clock&gt; a, TimePoint&lt;Clock&gt; b) { return static_cast&lt;double&gt;((a - b).count()); });
5283                  return deltas;
5284              }
5285              const auto warmup_iterations = 10000;
5286              const auto warmup_time = std::chrono::milliseconds(100);
5287              const auto minimum_ticks = 1000;
5288              const auto warmup_seed = 10000;
5289              const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);
5290              const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);
5291              const auto clock_cost_estimation_tick_limit = 100000;
5292              const auto clock_cost_estimation_time = std::chrono::milliseconds(10);
5293              const auto clock_cost_estimation_iterations = 10000;
5294              template &lt;typename Clock&gt;
5295              int warmup() {
5296                  return run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(warmup_time), warmup_seed, &amp;resolution&lt;Clock&gt;)
5297                      .iterations;
5298              }
5299              template &lt;typename Clock&gt;
5300              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; estimate_clock_resolution(int iterations) {
5301                  auto r = run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(clock_resolution_estimation_time), iterations, &amp;resolution&lt;Clock&gt;)
5302                      .result;
5303                  return {
5304                      FloatDuration&lt;Clock&gt;(mean(r.begin(), r.end())),
5305                      classify_outliers(r.begin(), r.end()),
5306                  };
5307              }
5308              template &lt;typename Clock&gt;
5309              EnvironmentEstimate&lt;FloatDuration&lt;Clock&gt;&gt; estimate_clock_cost(FloatDuration&lt;Clock&gt; resolution) {
5310                  auto time_limit = (std::min)(
5311                      resolution * clock_cost_estimation_tick_limit,
5312                      FloatDuration&lt;Clock&gt;(clock_cost_estimation_time_limit));
5313                  auto time_clock = [](int k) {
5314                      return Detail::measure&lt;Clock&gt;([k] {
5315                          for (int i = 0; i &lt; k; ++i) {
5316                              volatile auto ignored = Clock::now();
5317                              (void)ignored;
5318                          }
5319                      }).elapsed;
5320                  };
5321                  time_clock(1);
5322                  int iters = clock_cost_estimation_iterations;
5323                  auto&amp;&amp; r = run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(clock_cost_estimation_time), iters, time_clock);
5324                  std::vector&lt;double&gt; times;
5325                  int nsamples = static_cast&lt;int&gt;(std::ceil(time_limit / r.elapsed));
5326                  times.reserve(nsamples);
5327                  std::generate_n(std::back_inserter(times), nsamples, [time_clock, &amp;r] {
5328                      return static_cast&lt;double&gt;((time_clock(r.iterations) / r.iterations).count());
5329                  });
5330                  return {
5331                      FloatDuration&lt;Clock&gt;(mean(times.begin(), times.end())),
5332                      classify_outliers(times.begin(), times.end()),
5333                  };
5334              }
5335              template &lt;typename Clock&gt;
5336              Environment&lt;FloatDuration&lt;Clock&gt;&gt; measure_environment() {
5337                  static Environment&lt;FloatDuration&lt;Clock&gt;&gt;* env = nullptr;
5338                  if (env) {
5339                      return *env;
5340                  }
5341                  auto iters = Detail::warmup&lt;Clock&gt;();
5342                  auto resolution = Detail::estimate_clock_resolution&lt;Clock&gt;(iters);
5343                  auto cost = Detail::estimate_clock_cost&lt;Clock&gt;(resolution.mean);
5344                  env = new Environment&lt;FloatDuration&lt;Clock&gt;&gt;{ resolution, cost };
5345                  return *env;
5346              }
5347          } 
5348      } 
5349  } 
5350  #include &lt;algorithm&gt;
5351  #include &lt;vector&gt;
5352  #include &lt;string&gt;
5353  #include &lt;iterator&gt;
5354  namespace Catch {
5355      namespace Benchmark {
5356          template &lt;typename Duration&gt;
5357          struct SampleAnalysis {
5358              std::vector&lt;Duration&gt; samples;
5359              Estimate&lt;Duration&gt; mean;
5360              Estimate&lt;Duration&gt; standard_deviation;
5361              OutlierClassification outliers;
5362              double outlier_variance;
5363              template &lt;typename Duration2&gt;
5364              operator SampleAnalysis&lt;Duration2&gt;() const {
5365                  std::vector&lt;Duration2&gt; samples2;
5366                  samples2.reserve(samples.size());
5367                  std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
5368                  return {
5369                      std::move(samples2),
5370                      mean,
5371                      standard_deviation,
5372                      outliers,
5373                      outlier_variance,
5374                  };
5375              }
5376          };
5377      } 
5378  } 
5379  #include &lt;algorithm&gt;
5380  #include &lt;iterator&gt;
5381  #include &lt;vector&gt;
5382  namespace Catch {
5383      namespace Benchmark {
5384          namespace Detail {
5385              template &lt;typename Duration, typename Iterator&gt;
5386              SampleAnalysis&lt;Duration&gt; analyse(const IConfig &amp;cfg, Environment&lt;Duration&gt;, Iterator first, Iterator last) {
5387                  if (!cfg.benchmarkNoAnalysis()) {
5388                      std::vector&lt;double&gt; samples;
5389                      samples.reserve(last - first);
5390                      std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });
5391                      auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());
5392                      auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());
5393                      auto wrap_estimate = [](Estimate&lt;double&gt; e) {
5394                          return Estimate&lt;Duration&gt; {
5395                              Duration(e.point),
5396                                  Duration(e.lower_bound),
5397                                  Duration(e.upper_bound),
5398                                  e.confidence_interval,
5399                          };
5400                      };
5401                      std::vector&lt;Duration&gt; samples2;
5402                      samples2.reserve(samples.size());
5403                      std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });
5404                      return {
5405                          std::move(samples2),
5406                          wrap_estimate(analysis.mean),
5407                          wrap_estimate(analysis.standard_deviation),
5408                          outliers,
5409                          analysis.outlier_variance,
5410                      };
5411                  } else {
5412                      std::vector&lt;Duration&gt; samples;
5413                      samples.reserve(last - first);
5414                      Duration mean = Duration(0);
5415                      int i = 0;
5416                      for (auto it = first; it &lt; last; ++it, ++i) {
5417                          samples.push_back(Duration(*it));
5418                          mean += Duration(*it);
5419                      }
5420                      mean /= i;
5421                      return {
5422                          std::move(samples),
5423                          Estimate&lt;Duration&gt;{mean, mean, mean, 0.0},
5424                          Estimate&lt;Duration&gt;{Duration(0), Duration(0), Duration(0), 0.0},
5425                          OutlierClassification{},
5426                          0.0
5427                      };
5428                  }
5429              }
5430          } 
5431      } 
5432  } 
5433  #include &lt;algorithm&gt;
5434  #include &lt;functional&gt;
5435  #include &lt;string&gt;
5436  #include &lt;vector&gt;
5437  #include &lt;cmath&gt;
5438  namespace Catch {
5439      namespace Benchmark {
5440          struct Benchmark {
5441              Benchmark(std::string &amp;&amp;name)
5442                  : name(std::move(name)) {}
5443              template &lt;class FUN&gt;
5444              Benchmark(std::string &amp;&amp;name, FUN &amp;&amp;func)
5445                  : fun(std::move(func)), name(std::move(name)) {}
5446              template &lt;typename Clock&gt;
5447              ExecutionPlan&lt;FloatDuration&lt;Clock&gt;&gt; prepare(const IConfig &amp;cfg, Environment&lt;FloatDuration&lt;Clock&gt;&gt; env) const {
5448                  auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;
5449                  auto run_time = std::max(min_time, std::chrono::duration_cast&lt;decltype(min_time)&gt;(cfg.benchmarkWarmupTime()));
5450                  auto&amp;&amp; test = Detail::run_for_at_least&lt;Clock&gt;(std::chrono::duration_cast&lt;ClockDuration&lt;Clock&gt;&gt;(run_time), 1, fun);
5451                  int new_iters = static_cast&lt;int&gt;(std::ceil(min_time * test.iterations / test.elapsed));
5452                  return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast&lt;FloatDuration&lt;Clock&gt;&gt;(cfg.benchmarkWarmupTime()), Detail::warmup_iterations };
5453              }
5454              template &lt;typename Clock = default_clock&gt;
5455              void run() {
5456                  IConfigPtr cfg = getCurrentContext().getConfig();
5457                  auto env = Detail::measure_environment&lt;Clock&gt;();
5458                  getResultCapture().benchmarkPreparing(name);
5459                  CATCH_TRY{
5460                      auto plan = user_code([&amp;] {
5461                          return prepare&lt;Clock&gt;(*cfg, env);
5462                      });
5463                      BenchmarkInfo info {
5464                          name,
5465                          plan.estimated_duration.count(),
5466                          plan.iterations_per_sample,
5467                          cfg-&gt;benchmarkSamples(),
5468                          cfg-&gt;benchmarkResamples(),
5469                          env.clock_resolution.mean.count(),
5470                          env.clock_cost.mean.count()
5471                      };
5472                      getResultCapture().benchmarkStarting(info);
5473                      auto samples = user_code([&amp;] {
5474                          return plan.template run&lt;Clock&gt;(*cfg, env);
5475                      });
5476                      auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());
5477                      BenchmarkStats&lt;FloatDuration&lt;Clock&gt;&gt; stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };
5478                      getResultCapture().benchmarkEnded(stats);
5479                  } CATCH_CATCH_ALL{
5480                      if (translateActiveException() != Detail::benchmarkErrorMsg) 
5481                          std::rethrow_exception(std::current_exception());
5482                  }
5483              }
5484              template &lt;typename Fun,
5485                  typename std::enable_if&lt;!Detail::is_related&lt;Fun, Benchmark&gt;::value, int&gt;::type = 0&gt;
5486                  Benchmark &amp; operator=(Fun func) {
5487                  fun = Detail::BenchmarkFunction(func);
5488                  run();
5489                  return *this;
5490              }
5491              explicit operator bool() {
5492                  return true;
5493              }
5494          private:
5495              Detail::BenchmarkFunction fun;
5496              std::string name;
5497          };
5498      }
5499  } 
5500  #define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1
5501  #define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2
5502  #define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\
5503      if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
5504          BenchmarkName = [&amp;](int benchmarkIndex)
5505  #define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\
5506      if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
5507          BenchmarkName = [&amp;]
5508  #include &lt;type_traits&gt;
5509  namespace Catch {
5510      namespace Benchmark {
5511          namespace Detail {
5512              template &lt;typename T, bool Destruct&gt;
5513              struct ObjectStorage
5514              {
5515                  using TStorage = typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type;
5516                  ObjectStorage() : data() {}
5517                  ObjectStorage(const ObjectStorage&amp; other)
5518                  {
5519                      new(&amp;data) T(other.stored_object());
5520                  }
5521                  ObjectStorage(ObjectStorage&amp;&amp; other)
5522                  {
5523                      new(&amp;data) T(std::move(other.stored_object()));
5524                  }
5525                  ~ObjectStorage() { destruct_on_exit&lt;T&gt;(); }
5526                  template &lt;typename... Args&gt;
5527                  void construct(Args&amp;&amp;... args)
5528                  {
5529                      new (&amp;data) T(std::forward&lt;Args&gt;(args)...);
5530                  }
5531                  template &lt;bool AllowManualDestruction = !Destruct&gt;
5532                  typename std::enable_if&lt;AllowManualDestruction&gt;::type destruct()
5533                  {
5534                      stored_object().~T();
5535                  }
5536              private:
5537                  template &lt;typename U&gt;
5538                  void destruct_on_exit(typename std::enable_if&lt;Destruct, U&gt;::type* = 0) { destruct&lt;true&gt;(); }
5539                  template &lt;typename U&gt;
5540                  void destruct_on_exit(typename std::enable_if&lt;!Destruct, U&gt;::type* = 0) { }
5541                  T&amp; stored_object() {
5542                      return *static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;data));
5543                  }
5544                  T const&amp; stored_object() const {
5545                      return *static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;data));
5546                  }
5547                  TStorage data;
5548              };
5549          }
5550          template &lt;typename T&gt;
5551          using storage_for = Detail::ObjectStorage&lt;T, true&gt;;
5552          template &lt;typename T&gt;
5553          using destructable_object = Detail::ObjectStorage&lt;T, false&gt;;
5554      }
5555  }
5556  #endif
5557  #endif 
5558  #ifdef CATCH_IMPL
5559  #ifdef __clang__
5560  #pragma clang diagnostic push
5561  #pragma clang diagnostic ignored &quot;-Wweak-vtables&quot;
5562  #endif
5563  #include &lt;string&gt;
5564  #include &lt;vector&gt;
5565  #include &lt;memory&gt;
5566  namespace Catch {
5567  namespace TestCaseTracking {
5568      struct NameAndLocation {
5569          std::string name;
5570          SourceLineInfo location;
5571          NameAndLocation( std::string const&amp; _name, SourceLineInfo const&amp; _location );
5572          friend bool operator==(NameAndLocation const&amp; lhs, NameAndLocation const&amp; rhs) {
5573              return lhs.name == rhs.name
5574                  &amp;&amp; lhs.location == rhs.location;
5575          }
5576      };
5577      class ITracker;
5578      using ITrackerPtr = std::shared_ptr&lt;ITracker&gt;;
5579      class  ITracker {
5580          NameAndLocation m_nameAndLocation;
5581      public:
5582          ITracker(NameAndLocation const&amp; nameAndLoc) :
5583              m_nameAndLocation(nameAndLoc)
5584          {}
5585          NameAndLocation const&amp; nameAndLocation() const {
5586              return m_nameAndLocation;
5587          }
5588          virtual ~ITracker();
5589          virtual bool isComplete() const = 0; 
5590          virtual bool isSuccessfullyCompleted() const = 0;
5591          virtual bool isOpen() const = 0; 
5592          virtual bool hasChildren() const = 0;
5593          virtual bool hasStarted() const = 0;
5594          virtual ITracker&amp; parent() = 0;
5595          virtual void close() = 0; 
5596          virtual void fail() = 0;
5597          virtual void markAsNeedingAnotherRun() = 0;
5598          virtual void addChild( ITrackerPtr const&amp; child ) = 0;
5599          virtual ITrackerPtr findChild( NameAndLocation const&amp; nameAndLocation ) = 0;
5600          virtual void openChild() = 0;
5601          virtual bool isSectionTracker() const = 0;
5602          virtual bool isGeneratorTracker() const = 0;
5603      };
5604      class TrackerContext {
5605          enum RunState {
5606              NotStarted,
5607              Executing,
5608              CompletedCycle
5609          };
5610          ITrackerPtr m_rootTracker;
5611          ITracker* m_currentTracker = nullptr;
5612          RunState m_runState = NotStarted;
5613      public:
5614          ITracker&amp; startRun();
5615          void endRun();
5616          void startCycle();
5617          void completeCycle();
5618          bool completedCycle() const;
5619          ITracker&amp; currentTracker();
5620          void setCurrentTracker( ITracker* tracker );
5621      };
5622      class TrackerBase : public ITracker {
5623      protected:
5624          enum CycleState {
5625              NotStarted,
5626              Executing,
5627              ExecutingChildren,
5628              NeedsAnotherRun,
5629              CompletedSuccessfully,
5630              Failed
5631          };
5632          using Children = std::vector&lt;ITrackerPtr&gt;;
5633          TrackerContext&amp; m_ctx;
5634          ITracker* m_parent;
5635          Children m_children;
5636          CycleState m_runState = NotStarted;
5637      public:
5638          TrackerBase( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent );
5639          bool isComplete() const override;
5640          bool isSuccessfullyCompleted() const override;
5641          bool isOpen() const override;
5642          bool hasChildren() const override;
5643          bool hasStarted() const override {
5644              return m_runState != NotStarted;
5645          }
5646          void addChild( ITrackerPtr const&amp; child ) override;
5647          ITrackerPtr findChild( NameAndLocation const&amp; nameAndLocation ) override;
5648          ITracker&amp; parent() override;
5649          void openChild() override;
5650          bool isSectionTracker() const override;
5651          bool isGeneratorTracker() const override;
5652          void open();
5653          void close() override;
5654          void fail() override;
5655          void markAsNeedingAnotherRun() override;
5656      private:
5657          void moveToParent();
5658          void moveToThis();
5659      };
5660      class SectionTracker : public TrackerBase {
5661          std::vector&lt;std::string&gt; m_filters;
5662          std::string m_trimmed_name;
5663      public:
5664          SectionTracker( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent );
5665          bool isSectionTracker() const override;
5666          bool isComplete() const override;
5667          static SectionTracker&amp; acquire( TrackerContext&amp; ctx, NameAndLocation const&amp; nameAndLocation );
5668          void tryOpen();
5669          void addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters );
5670          void addNextFilters( std::vector&lt;std::string&gt; const&amp; filters );
5671          std::vector&lt;std::string&gt; const&amp; getFilters() const;
5672          std::string const&amp; trimmedName() const;
5673      };
5674  } 
5675  using TestCaseTracking::ITracker;
5676  using TestCaseTracking::TrackerContext;
5677  using TestCaseTracking::SectionTracker;
5678  } 
5679  namespace Catch {
5680      struct LeakDetector {
5681          LeakDetector();
5682          ~LeakDetector();
5683      };
5684  }
5685  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
5686  #include &lt;cassert&gt;
5687  #include &lt;random&gt;
5688  #if defined(CATCH_CONFIG_USE_ASYNC)
5689  #include &lt;future&gt;
5690  #endif
5691  namespace {
5692      double erf_inv(double x) {
5693          double w, p;
5694          w = -log((1.0 - x) * (1.0 + x));
5695          if (w &lt; 6.250000) {
5696              w = w - 3.125000;
5697              p = -3.6444120640178196996e-21;
5698              p = -1.685059138182016589e-19 + p * w;
5699              p = 1.2858480715256400167e-18 + p * w;
5700              p = 1.115787767802518096e-17 + p * w;
5701              p = -1.333171662854620906e-16 + p * w;
5702              p = 2.0972767875968561637e-17 + p * w;
5703              p = 6.6376381343583238325e-15 + p * w;
5704              p = -4.0545662729752068639e-14 + p * w;
5705              p = -8.1519341976054721522e-14 + p * w;
5706              p = 2.6335093153082322977e-12 + p * w;
5707              p = -1.2975133253453532498e-11 + p * w;
5708              p = -5.4154120542946279317e-11 + p * w;
5709              p = 1.051212273321532285e-09 + p * w;
5710              p = -4.1126339803469836976e-09 + p * w;
5711              p = -2.9070369957882005086e-08 + p * w;
5712              p = 4.2347877827932403518e-07 + p * w;
5713              p = -1.3654692000834678645e-06 + p * w;
5714              p = -1.3882523362786468719e-05 + p * w;
5715              p = 0.0001867342080340571352 + p * w;
5716              p = -0.00074070253416626697512 + p * w;
5717              p = -0.0060336708714301490533 + p * w;
5718              p = 0.24015818242558961693 + p * w;
5719              p = 1.6536545626831027356 + p * w;
5720          } else if (w &lt; 16.000000) {
5721              w = sqrt(w) - 3.250000;
5722              p = 2.2137376921775787049e-09;
5723              p = 9.0756561938885390979e-08 + p * w;
5724              p = -2.7517406297064545428e-07 + p * w;
5725              p = 1.8239629214389227755e-08 + p * w;
5726              p = 1.5027403968909827627e-06 + p * w;
5727              p = -4.013867526981545969e-06 + p * w;
5728              p = 2.9234449089955446044e-06 + p * w;
5729              p = 1.2475304481671778723e-05 + p * w;
5730              p = -4.7318229009055733981e-05 + p * w;
5731              p = 6.8284851459573175448e-05 + p * w;
5732              p = 2.4031110387097893999e-05 + p * w;
5733              p = -0.0003550375203628474796 + p * w;
5734              p = 0.00095328937973738049703 + p * w;
5735              p = -0.0016882755560235047313 + p * w;
5736              p = 0.0024914420961078508066 + p * w;
5737              p = -0.0037512085075692412107 + p * w;
5738              p = 0.005370914553590063617 + p * w;
5739              p = 1.0052589676941592334 + p * w;
5740              p = 3.0838856104922207635 + p * w;
5741          } else {
5742              w = sqrt(w) - 5.000000;
5743              p = -2.7109920616438573243e-11;
5744              p = -2.5556418169965252055e-10 + p * w;
5745              p = 1.5076572693500548083e-09 + p * w;
5746              p = -3.7894654401267369937e-09 + p * w;
5747              p = 7.6157012080783393804e-09 + p * w;
5748              p = -1.4960026627149240478e-08 + p * w;
5749              p = 2.9147953450901080826e-08 + p * w;
5750              p = -6.7711997758452339498e-08 + p * w;
5751              p = 2.2900482228026654717e-07 + p * w;
5752              p = -9.9298272942317002539e-07 + p * w;
5753              p = 4.5260625972231537039e-06 + p * w;
5754              p = -1.9681778105531670567e-05 + p * w;
5755              p = 7.5995277030017761139e-05 + p * w;
5756              p = -0.00021503011930044477347 + p * w;
5757              p = -0.00013871931833623122026 + p * w;
5758              p = 1.0103004648645343977 + p * w;
5759              p = 4.8499064014085844221 + p * w;
5760          }
5761          return p * x;
5762      }
5763      double standard_deviation(std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last) {
5764          auto m = Catch::Benchmark::Detail::mean(first, last);
5765          double variance = std::accumulate(first, last, 0., [m](double a, double b) {
5766              double diff = b - m;
5767              return a + diff * diff;
5768              }) / (last - first);
5769              return std::sqrt(variance);
5770      }
5771  }
5772  namespace Catch {
5773      namespace Benchmark {
5774          namespace Detail {
5775              double weighted_average_quantile(int k, int q, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last) {
5776                  auto count = last - first;
5777                  double idx = (count - 1) * k / static_cast&lt;double&gt;(q);
5778                  int j = static_cast&lt;int&gt;(idx);
5779                  double g = idx - j;
5780                  std::nth_element(first, first + j, last);
5781                  auto xj = first[j];
5782                  if (g == 0) return xj;
5783                  auto xj1 = *std::min_element(first + (j + 1), last);
5784                  return xj + g * (xj1 - xj);
5785              }
5786              double erfc_inv(double x) {
5787                  return erf_inv(1.0 - x);
5788              }
5789              double normal_quantile(double p) {
5790                  static const double ROOT_TWO = std::sqrt(2.0);
5791                  double result = 0.0;
5792                  assert(p &gt;= 0 &amp;&amp; p &lt;= 1);
5793                  if (p &lt; 0 || p &gt; 1) {
5794                      return result;
5795                  }
5796                  result = -erfc_inv(2.0 * p);
5797                  result *= &amp;bsol;*sd * */ ROOT_TWO;
5798                  return result;
5799              }
5800              double outlier_variance(Estimate&lt;double&gt; mean, Estimate&lt;double&gt; stddev, int n) {
5801                  double sb = stddev.point;
5802                  double mn = mean.point / n;
5803                  double mg_min = mn / 2.;
5804                  double sg = (std::min)(mg_min / 4., sb / std::sqrt(n));
5805                  double sg2 = sg * sg;
5806                  double sb2 = sb * sb;
5807                  auto c_max = [n, mn, sb2, sg2](double x) -&gt; double {
5808                      double k = mn - x;
5809                      double d = k * k;
5810                      double nd = n * d;
5811                      double k0 = -n * nd;
5812                      double k1 = sb2 - n * sg2 + nd;
5813                      double det = k1 * k1 - 4 * sg2 * k0;
5814                      return (int)(-2. * k0 / (k1 + std::sqrt(det)));
5815                  };
5816                  auto var_out = [n, sb2, sg2](double c) {
5817                      double nc = n - c;
5818                      return (nc / n) * (sb2 - nc * sg2);
5819                  };
5820                  return (std::min)(var_out(1), var_out((std::min)(c_max(0.), c_max(mg_min)))) / sb2;
5821              }
5822              bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector&lt;double&gt;::iterator first, std::vector&lt;double&gt;::iterator last) {
5823                  CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
5824                  CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
5825                  static std::random_device entropy;
5826                  CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
5827                  auto n = static_cast&lt;int&gt;(last - first); 
5828                  auto mean = &amp;Detail::mean&lt;std::vector&lt;double&gt;::iterator&gt;;
5829                  auto stddev = &amp;standard_deviation;
5830  #if defined(CATCH_CONFIG_USE_ASYNC)
5831                  auto Estimate = [=](double(*f)(std::vector&lt;double&gt;::iterator, std::vector&lt;double&gt;::iterator)) {
5832                      auto seed = entropy();
5833                      return std::async(std::launch::async, [=] {
5834                          std::mt19937 rng(seed);
5835                          auto resampled = resample(rng, n_resamples, first, last, f);
5836                          return bootstrap(confidence_level, first, last, resampled, f);
5837                      });
5838                  };
5839                  auto mean_future = Estimate(mean);
5840                  auto stddev_future = Estimate(stddev);
5841                  auto mean_estimate = mean_future.get();
5842                  auto stddev_estimate = stddev_future.get();
5843  #else
5844                  auto Estimate = [=](double(*f)(std::vector&lt;double&gt;::iterator, std::vector&lt;double&gt;::iterator)) {
5845                      auto seed = entropy();
5846                      std::mt19937 rng(seed);
5847                      auto resampled = resample(rng, n_resamples, first, last, f);
5848                      return bootstrap(confidence_level, first, last, resampled, f);
5849                  };
5850                  auto mean_estimate = Estimate(mean);
5851                  auto stddev_estimate = Estimate(stddev);
5852  #endif 
5853                  double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);
5854                  return { mean_estimate, stddev_estimate, outlier_variance };
5855              }
5856          } 
5857      } 
5858  } 
5859  #endif 
5860  #include &lt;cmath&gt;
5861  #include &lt;limits&gt;
5862  namespace {
5863  bool marginComparison(double lhs, double rhs, double margin) {
5864      return (lhs + margin &gt;= rhs) &amp;&amp; (rhs + margin &gt;= lhs);
5865  }
5866  }
5867  namespace Catch {
5868  namespace Detail {
5869      Approx::Approx ( double value )
5870      :   m_epsilon( std::numeric_limits&lt;float&gt;::epsilon()*100 ),
5871          m_margin( 0.0 ),
5872          m_scale( 0.0 ),
5873          m_value( value )
5874      {}
5875      Approx Approx::custom() {
5876          return Approx( 0 );
5877      }
5878      Approx Approx::operator-() const {
5879          auto temp(*this);
5880          temp.m_value = -temp.m_value;
5881          return temp;
5882      }
5883      std::string Approx::toString() const {
5884          ReusableStringStream rss;
5885          rss &lt;&lt; &quot;Approx( &quot; &lt;&lt; ::Catch::Detail::stringify( m_value ) &lt;&lt; &quot; )&quot;;
5886          return rss.str();
5887      }
5888      bool Approx::equalityComparisonImpl(const double other) const {
5889          return marginComparison(m_value, other, m_margin)
5890              || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));
5891      }
5892      void Approx::setMargin(double newMargin) {
5893          CATCH_ENFORCE(newMargin &gt;= 0,
5894              &quot;Invalid Approx::margin: &quot; &lt;&lt; newMargin &lt;&lt; &#x27;.&#x27;
5895              &lt;&lt; &quot; Approx::Margin has to be non-negative.&quot;);
5896          m_margin = newMargin;
5897      }
5898      void Approx::setEpsilon(double newEpsilon) {
5899          CATCH_ENFORCE(newEpsilon &gt;= 0 &amp;&amp; newEpsilon &lt;= 1.0,
5900              &quot;Invalid Approx::epsilon: &quot; &lt;&lt; newEpsilon &lt;&lt; &#x27;.&#x27;
5901              &lt;&lt; &quot; Approx::epsilon has to be in [0, 1]&quot;);
5902          m_epsilon = newEpsilon;
5903      }
5904  } 
5905  namespace literals {
5906      Detail::Approx operator &quot;&quot; _a(long double val) {
5907          return Detail::Approx(val);
5908      }
5909      Detail::Approx operator &quot;&quot; _a(unsigned long long val) {
5910          return Detail::Approx(val);
5911      }
5912  } 
5913  std::string StringMaker&lt;Catch::Detail::Approx&gt;::convert(Catch::Detail::Approx const&amp; value) {
5914      return value.toString();
5915  }
5916  } 
5917  namespace Catch {
5918      bool isDebuggerActive();
5919  }
5920  #ifdef CATCH_PLATFORM_MAC
5921      #if defined(__i386__) || defined(__x86_64__)
5922          #define CATCH_TRAP() __asm__(&quot;int $3\n&quot; : : ) &amp;bsol;* NOLINT */
5923      #elif defined(__aarch64__)
5924          #define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)
5925      #endif
5926  #elif defined(CATCH_PLATFORM_IPHONE)
5927      #if defined(__i386__) || defined(__x86_64__)
5928          #define CATCH_TRAP()  __asm__(&quot;int $3&quot;)
5929      #elif defined(__aarch64__)
5930          #define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)
5931      #elif defined(__arm__) &amp;&amp; !defined(__thumb__)
5932          #define CATCH_TRAP()  __asm__(&quot;.inst 0xe7f001f0&quot;)
5933      #elif defined(__arm__) &amp;&amp;  defined(__thumb__)
5934          #define CATCH_TRAP()  __asm__(&quot;.inst 0xde01&quot;)
5935      #endif
5936  #elif defined(CATCH_PLATFORM_LINUX)
5937      #if defined(__GNUC__) &amp;&amp; (defined(__i386) || defined(__x86_64))
5938          #define CATCH_TRAP() asm volatile (&quot;int $3&quot;) &amp;bsol;* NOLINT */
5939      #else 
5940          #include &lt;signal.h&gt;
5941          #define CATCH_TRAP() raise(SIGTRAP)
5942      #endif
5943  #elif defined(_MSC_VER)
5944      #define CATCH_TRAP() __debugbreak()
5945  #elif defined(__MINGW32__)
5946      extern &quot;C&quot; __declspec(dllimport) void __stdcall DebugBreak();
5947      #define CATCH_TRAP() DebugBreak()
5948  #endif
5949  #ifndef CATCH_BREAK_INTO_DEBUGGER
5950      #ifdef CATCH_TRAP
5951          #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()
5952      #else
5953          #define CATCH_BREAK_INTO_DEBUGGER() []{}()
5954      #endif
5955  #endif
5956  #include &lt;cassert&gt;
5957  namespace Catch {
5958      class FatalConditionHandler {
5959          bool m_started = false;
5960          void engage_platform();
5961          void disengage_platform();
5962      public:
5963          FatalConditionHandler();
5964          ~FatalConditionHandler();
5965          void engage() {
5966              assert(!m_started &amp;&amp; &quot;Handler cannot be installed twice.&quot;);
5967              m_started = true;
5968              engage_platform();
5969          }
5970          void disengage() {
5971              assert(m_started &amp;&amp; &quot;Handler cannot be uninstalled without being installed first&quot;);
5972              m_started = false;
5973              disengage_platform();
5974          }
5975      };
5976      class FatalConditionHandlerGuard {
5977          FatalConditionHandler* m_handler;
5978      public:
5979          FatalConditionHandlerGuard(FatalConditionHandler* handler):
5980              m_handler(handler) {
5981              m_handler-&gt;engage();
5982          }
5983          ~FatalConditionHandlerGuard() {
5984              m_handler-&gt;disengage();
5985          }
5986      };
5987  } 
5988  #include &lt;string&gt;
5989  namespace Catch {
5990      struct IMutableContext;
5991      class RunContext : public IResultCapture, public IRunner {
5992      public:
5993          RunContext( RunContext const&amp; ) = delete;
5994          RunContext&amp; operator =( RunContext const&amp; ) = delete;
5995          explicit RunContext( IConfigPtr const&amp; _config, IStreamingReporterPtr&amp;&amp; reporter );
5996          ~RunContext() override;
5997          void testGroupStarting( std::string const&amp; testSpec, std::size_t groupIndex, std::size_t groupsCount );
5998          void testGroupEnded( std::string const&amp; testSpec, Totals const&amp; totals, std::size_t groupIndex, std::size_t groupsCount );
5999          Totals runTest(TestCase const&amp; testCase);
6000          IConfigPtr config() const;
6001          IStreamingReporter&amp; reporter() const;
6002      public: 
6003          void handleExpr
6004                  (   AssertionInfo const&amp; info,
6005                      ITransientExpression const&amp; expr,
6006                      AssertionReaction&amp; reaction ) override;
6007          void handleMessage
6008                  (   AssertionInfo const&amp; info,
6009                      ResultWas::OfType resultType,
6010                      StringRef const&amp; message,
6011                      AssertionReaction&amp; reaction ) override;
6012          void handleUnexpectedExceptionNotThrown
6013                  (   AssertionInfo const&amp; info,
6014                      AssertionReaction&amp; reaction ) override;
6015          void handleUnexpectedInflightException
6016                  (   AssertionInfo const&amp; info,
6017                      std::string const&amp; message,
6018                      AssertionReaction&amp; reaction ) override;
6019          void handleIncomplete
6020                  (   AssertionInfo const&amp; info ) override;
6021          void handleNonExpr
6022                  (   AssertionInfo const &amp;info,
6023                      ResultWas::OfType resultType,
6024                      AssertionReaction &amp;reaction ) override;
6025          bool sectionStarted( SectionInfo const&amp; sectionInfo, Counts&amp; assertions ) override;
6026          void sectionEnded( SectionEndInfo const&amp; endInfo ) override;
6027          void sectionEndedEarly( SectionEndInfo const&amp; endInfo ) override;
6028          auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; override;
6029  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
6030          void benchmarkPreparing( std::string const&amp; name ) override;
6031          void benchmarkStarting( BenchmarkInfo const&amp; info ) override;
6032          void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) override;
6033          void benchmarkFailed( std::string const&amp; error ) override;
6034  #endif 
6035          void pushScopedMessage( MessageInfo const&amp; message ) override;
6036          void popScopedMessage( MessageInfo const&amp; message ) override;
6037          void emplaceUnscopedMessage( MessageBuilder const&amp; builder ) override;
6038          std::string getCurrentTestName() const override;
6039          const AssertionResult* getLastResult() const override;
6040          void exceptionEarlyReported() override;
6041          void handleFatalErrorCondition( StringRef message ) override;
6042          bool lastAssertionPassed() override;
6043          void assertionPassed() override;
6044      public:
6045          bool aborting() const final;
6046      private:
6047          void runCurrentTest( std::string&amp; redirectedCout, std::string&amp; redirectedCerr );
6048          void invokeActiveTestCase();
6049          void resetAssertionInfo();
6050          bool testForMissingAssertions( Counts&amp; assertions );
6051          void assertionEnded( AssertionResult const&amp; result );
6052          void reportExpr
6053                  (   AssertionInfo const &amp;info,
6054                      ResultWas::OfType resultType,
6055                      ITransientExpression const *expr,
6056                      bool negated );
6057          void populateReaction( AssertionReaction&amp; reaction );
6058      private:
6059          void handleUnfinishedSections();
6060          TestRunInfo m_runInfo;
6061          IMutableContext&amp; m_context;
6062          TestCase const* m_activeTestCase = nullptr;
6063          ITracker* m_testCaseTracker = nullptr;
6064          Option&lt;AssertionResult&gt; m_lastResult;
6065          IConfigPtr m_config;
6066          Totals m_totals;
6067          IStreamingReporterPtr m_reporter;
6068          std::vector&lt;MessageInfo&gt; m_messages;
6069          std::vector&lt;ScopedMessage&gt; m_messageScopes; &amp;bsol;* Keeps owners of so-called unscoped messages. */
6070          AssertionInfo m_lastAssertionInfo;
6071          std::vector&lt;SectionEndInfo&gt; m_unfinishedSections;
6072          std::vector&lt;ITracker*&gt; m_activeSections;
6073          TrackerContext m_trackerContext;
6074          FatalConditionHandler m_fatalConditionhandler;
6075          bool m_lastAssertionPassed = false;
6076          bool m_shouldReportUnexpected = true;
6077          bool m_includeSuccessfulResults;
6078      };
6079      void seedRng(IConfig const&amp; config);
6080      unsigned int rngSeed();
6081  } 
6082  namespace Catch {
6083      namespace {
6084          auto operator &lt;&lt;( std::ostream&amp; os, ITransientExpression const&amp; expr ) -&gt; std::ostream&amp; {
6085              expr.streamReconstructedExpression( os );
6086              return os;
6087          }
6088      }
6089      LazyExpression::LazyExpression( bool isNegated )
6090      :   m_isNegated( isNegated )
6091      {}
6092      LazyExpression::LazyExpression( LazyExpression const&amp; other ) : m_isNegated( other.m_isNegated ) {}
6093      LazyExpression::operator bool() const {
6094          return m_transientExpression != nullptr;
6095      }
6096      auto operator &lt;&lt; ( std::ostream&amp; os, LazyExpression const&amp; lazyExpr ) -&gt; std::ostream&amp; {
6097          if( lazyExpr.m_isNegated )
6098              os &lt;&lt; &quot;!&quot;;
6099          if( lazyExpr ) {
6100              if( lazyExpr.m_isNegated &amp;&amp; lazyExpr.m_transientExpression-&gt;isBinaryExpression() )
6101                  os &lt;&lt; &quot;(&quot; &lt;&lt; *lazyExpr.m_transientExpression &lt;&lt; &quot;)&quot;;
6102              else
6103                  os &lt;&lt; *lazyExpr.m_transientExpression;
6104          }
6105          else {
6106              os &lt;&lt; &quot;{** error - unchecked empty expression requested **}&quot;;
6107          }
6108          return os;
6109      }
6110      AssertionHandler::AssertionHandler
6111          (   StringRef const&amp; macroName,
6112              SourceLineInfo const&amp; lineInfo,
6113              StringRef capturedExpression,
6114              ResultDisposition::Flags resultDisposition )
6115      :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
6116          m_resultCapture( getResultCapture() )
6117      {}
6118      void AssertionHandler::handleExpr( ITransientExpression const&amp; expr ) {
6119          m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
6120      }
6121      void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const&amp; message) {
6122          m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
6123      }
6124      auto AssertionHandler::allowThrows() const -&gt; bool {
6125          return getCurrentContext().getConfig()-&gt;allowThrows();
6126      }
6127      void AssertionHandler::complete() {
6128          setCompleted();
6129          if( m_reaction.shouldDebugBreak ) {
6130              CATCH_BREAK_INTO_DEBUGGER();
6131          }
6132          if (m_reaction.shouldThrow) {
6133  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
6134              throw Catch::TestFailureException();
6135  #else
6136              CATCH_ERROR( &quot;Test failure requires aborting test!&quot; );
6137  #endif
6138          }
6139      }
6140      void AssertionHandler::setCompleted() {
6141          m_completed = true;
6142      }
6143      void AssertionHandler::handleUnexpectedInflightException() {
6144          m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
6145      }
6146      void AssertionHandler::handleExceptionThrownAsExpected() {
6147          m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
6148      }
6149      void AssertionHandler::handleExceptionNotThrownAsExpected() {
6150          m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
6151      }
6152      void AssertionHandler::handleUnexpectedExceptionNotThrown() {
6153          m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
6154      }
6155      void AssertionHandler::handleThrowingCallSkipped() {
6156          m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
6157      }
6158      void handleExceptionMatchExpr( AssertionHandler&amp; handler, std::string const&amp; str, StringRef const&amp; matcherString  ) {
6159          handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
6160      }
6161  } 
6162  namespace Catch {
6163      AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const &amp; _lazyExpression):
6164          lazyExpression(_lazyExpression),
6165          resultType(_resultType) {}
6166      std::string AssertionResultData::reconstructExpression() const {
6167          if( reconstructedExpression.empty() ) {
6168              if( lazyExpression ) {
6169                  ReusableStringStream rss;
6170                  rss &lt;&lt; lazyExpression;
6171                  reconstructedExpression = rss.str();
6172              }
6173          }
6174          return reconstructedExpression;
6175      }
6176      AssertionResult::AssertionResult( AssertionInfo const&amp; info, AssertionResultData const&amp; data )
6177      :   m_info( info ),
6178          m_resultData( data )
6179      {}
6180      bool AssertionResult::succeeded() const {
6181          return Catch::isOk( m_resultData.resultType );
6182      }
6183      bool AssertionResult::isOk() const {
6184          return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
6185      }
6186      ResultWas::OfType AssertionResult::getResultType() const {
6187          return m_resultData.resultType;
6188      }
6189      bool AssertionResult::hasExpression() const {
6190          return !m_info.capturedExpression.empty();
6191      }
6192      bool AssertionResult::hasMessage() const {
6193          return !m_resultData.message.empty();
6194      }
6195      std::string AssertionResult::getExpression() const {
6196          std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);
6197          if (isFalseTest(m_info.resultDisposition)) {
6198              expr += &quot;!(&quot;;
6199          }
6200          expr += m_info.capturedExpression;
6201          if (isFalseTest(m_info.resultDisposition)) {
6202              expr += &#x27;)&#x27;;
6203          }
6204          return expr;
6205      }
6206      std::string AssertionResult::getExpressionInMacro() const {
6207          std::string expr;
6208          if( m_info.macroName.empty() )
6209              expr = static_cast&lt;std::string&gt;(m_info.capturedExpression);
6210          else {
6211              expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
6212              expr += m_info.macroName;
6213              expr += &quot;( &quot;;
6214              expr += m_info.capturedExpression;
6215              expr += &quot; )&quot;;
6216          }
6217          return expr;
6218      }
6219      bool AssertionResult::hasExpandedExpression() const {
6220          return hasExpression() &amp;&amp; getExpandedExpression() != getExpression();
6221      }
6222      std::string AssertionResult::getExpandedExpression() const {
6223          std::string expr = m_resultData.reconstructExpression();
6224          return expr.empty()
6225                  ? getExpression()
6226                  : expr;
6227      }
6228      std::string AssertionResult::getMessage() const {
6229          return m_resultData.message;
6230      }
6231      SourceLineInfo AssertionResult::getSourceInfo() const {
6232          return m_info.lineInfo;
6233      }
6234      StringRef AssertionResult::getTestMacroName() const {
6235          return m_info.macroName;
6236      }
6237  } 
6238  namespace Catch {
6239      using StringMatcher = Matchers::Impl::MatcherBase&lt;std::string&gt;;
6240      void handleExceptionMatchExpr( AssertionHandler&amp; handler, StringMatcher const&amp; matcher, StringRef const&amp; matcherString  ) {
6241          std::string exceptionMessage = Catch::translateActiveException();
6242          MatchExpr&lt;std::string, StringMatcher const&amp;&gt; expr( exceptionMessage, matcher, matcherString );
6243          handler.handleExpr( expr );
6244      }
6245  } 
6246  #ifdef CLARA_CONFIG_CONSOLE_WIDTH
6247  #define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6248  #undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6249  #endif
6250  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1
6251  #ifdef __clang__
6252  #pragma clang diagnostic push
6253  #pragma clang diagnostic ignored &quot;-Wweak-vtables&quot;
6254  #pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
6255  #pragma clang diagnostic ignored &quot;-Wshadow&quot;
6256  #endif
6257  #ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH
6258  #define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80
6259  #endif
6260  #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6261  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH
6262  #endif
6263  #ifndef CLARA_CONFIG_OPTIONAL_TYPE
6264  #ifdef __has_include
6265  #if __has_include(&lt;optional&gt;) &amp;&amp; __cplusplus &gt;= 201703L
6266  #include &lt;optional&gt;
6267  #define CLARA_CONFIG_OPTIONAL_TYPE std::optional
6268  #endif
6269  #endif
6270  #endif
6271  #include &lt;cassert&gt;
6272  #include &lt;ostream&gt;
6273  #include &lt;sstream&gt;
6274  #include &lt;vector&gt;
6275  #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
6276  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80
6277  #endif
6278  namespace Catch {
6279  namespace clara {
6280  namespace TextFlow {
6281  inline auto isWhitespace(char c) -&gt; bool {
6282  	static std::string chars = &quot; \t\n\r&quot;;
6283  	return chars.find(c) != std::string::npos;
6284  }
6285  inline auto isBreakableBefore(char c) -&gt; bool {
6286  	static std::string chars = &quot;[({&lt;|&quot;;
6287  	return chars.find(c) != std::string::npos;
6288  }
6289  inline auto isBreakableAfter(char c) -&gt; bool {
6290  	static std::string chars = &quot;])}&gt;.,:;*+-=&amp;/\\&quot;;
6291  	return chars.find(c) != std::string::npos;
6292  }
6293  class Columns;
6294  class Column {
6295  	std::vector&lt;std::string&gt; m_strings;
6296  	size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;
6297  	size_t m_indent = 0;
6298  	size_t m_initialIndent = std::string::npos;
6299  public:
6300  	class iterator {
6301  		friend Column;
6302  		Column const&amp; m_column;
6303  		size_t m_stringIndex = 0;
6304  		size_t m_pos = 0;
6305  		size_t m_len = 0;
6306  		size_t m_end = 0;
6307  		bool m_suffix = false;
6308  		iterator(Column const&amp; column, size_t stringIndex)
6309  			: m_column(column),
6310  			m_stringIndex(stringIndex) {}
6311  		auto line() const -&gt; std::string const&amp; { return m_column.m_strings[m_stringIndex]; }
6312  		auto isBoundary(size_t at) const -&gt; bool {
6313  			assert(at &gt; 0);
6314  			assert(at &lt;= line().size());
6315  			return at == line().size() ||
6316  				(isWhitespace(line()[at]) &amp;&amp; !isWhitespace(line()[at - 1])) ||
6317  				isBreakableBefore(line()[at]) ||
6318  				isBreakableAfter(line()[at - 1]);
6319  		}
6320  		void calcLength() {
6321  			assert(m_stringIndex &lt; m_column.m_strings.size());
6322  			m_suffix = false;
6323  			auto width = m_column.m_width - indent();
6324  			m_end = m_pos;
6325  			if (line()[m_pos] == &#x27;\n&#x27;) {
6326  				++m_end;
6327  			}
6328  			while (m_end &lt; line().size() &amp;&amp; line()[m_end] != &#x27;\n&#x27;)
6329  				++m_end;
6330  			if (m_end &lt; m_pos + width) {
6331  				m_len = m_end - m_pos;
6332  			} else {
6333  				size_t len = width;
6334  				while (len &gt; 0 &amp;&amp; !isBoundary(m_pos + len))
6335  					--len;
6336  				while (len &gt; 0 &amp;&amp; isWhitespace(line()[m_pos + len - 1]))
6337  					--len;
6338  				if (len &gt; 0) {
<span onclick='openModal()' class='match'>6339  					m_len = len;
6340  				} else {
6341  					m_suffix = true;
6342  					m_len = width - 1;
6343  				}
6344  			}
6345  		}
6346  		auto indent() const -&gt; size_t {
6347  			auto initial = m_pos == 0 &amp;&amp; m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
6348  			return initial == std::string::npos ? m_column.m_indent : initial;
6349  		}
6350  		auto addIndentAndSuffix(std::string const &amp;plain) const -&gt; std::string {
6351  			return std::string(indent(), &#x27; &#x27;) + (m_suffix ? plain + &quot;-&quot; : plain);
6352  		}
6353  	public:
6354  		using difference_type = std::ptrdiff_t;
6355  		using value_type = std::string;
6356  		using pointer = value_type * ;
6357  		using reference = value_type &amp; ;
6358  		using iterator_category = std::forward_iterator_tag;
6359  		explicit iterator(Column const&amp; column) : m_column(column) {
6360  			assert(m_column.m_width &gt; m_column.m_indent);
6361  			assert(m_column.m_initialIndent == std::string::npos || m_column.m_width &gt; m_column.m_initialIndent);
6362  			calcLength();
6363  			if (m_len == 0)
6364  				m_stringIndex++; 
6365  		}
6366  		auto operator *() const -&gt; std::string {
6367  			assert(m_stringIndex &lt; m_column.m_strings.size());
6368  			assert(m_pos &lt;= m_end);
6369  			return addIndentAndSuffix(line().substr(m_pos, m_len));
6370  		}
6371  		auto operator ++() -&gt; iterator&amp; {
6372  			m_pos += m_len;
6373  			if (m_pos &lt; line().size() &amp;&amp; line()[m_pos] == &#x27;\n&#x27;)
6374  				m_pos += 1;
6375  			else
6376  				while (m_pos &lt; line().size() &amp;&amp; isWhitespace(line()[m_pos]))
6377  					++m_pos;
6378  			if (m_pos == line().size()) {
6379  				m_pos = 0;
6380  				++m_stringIndex;
6381  			}
6382  			if (m_stringIndex &lt; m_column.m_strings.size())
6383  				calcLength();
6384  			return *this;
6385  		}
6386  		auto operator ++(int) -&gt; iterator {
6387  			iterator prev(*this);
6388  			operator++();
6389  			return prev;
6390  		}
6391  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6392  			return
6393  				m_pos == other.m_pos &amp;&amp;
6394  				m_stringIndex == other.m_stringIndex &amp;&amp;
6395  				&amp;m_column == &amp;other.m_column;
6396  		}
6397  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6398  			return !operator==(other);
6399  		}
6400  	};
6401  	using const_iterator = iterator;
6402  	explicit Column(std::string const&amp; text) { m_strings.push_back(text); }
6403  	auto width(size_t newWidth) -&gt; Column&amp; {
6404  		assert(newWidth &gt; 0);
6405  		m_width = newWidth;
6406  		return *this;
6407  	}
6408  	auto indent(size_t newIndent) -&gt; Column&amp; {
6409  		m_indent = newIndent;
6410  		return *this;
6411  	}
6412  	auto initialIndent(size_t newIndent) -&gt; Column&amp; {
6413  		m_initialIndent = newIndent;
6414  		return *this;
6415  	}
6416  	auto width() const -&gt; size_t { return m_width; }
6417  	auto begin() const -&gt; iterator { return iterator(*this); }
6418  	auto end() const -&gt; iterator { return { *this, m_strings.size() }; }
6419  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Column const&amp; col) {
6420  		bool first = true;
6421  		for (auto line : col) {
6422  			if (first)
6423  				first = false;
6424  			else
6425  				os &lt;&lt; &quot;\n&quot;;
6426  			os &lt;&lt; line;
6427  		}
6428  		return os;
6429  	}
6430  	auto operator + (Column const&amp; other)-&gt;Columns;
6431  	auto toString() const -&gt; std::string {
6432  		std::ostringstream oss;
6433  		oss &lt;&lt; *this;
6434  		return oss.str();
6435  	}
6436  };
6437  class Spacer : public Column {
6438  public:
6439  	explicit Spacer(size_t spaceWidth) : Column(&quot;&quot;) {
6440  		width(spaceWidth);
6441  	}
6442  };
6443  class Columns {
6444  	std::vector&lt;Column&gt; m_columns;
6445  public:
6446  	class iterator {
6447  		friend Columns;
6448  		struct EndTag {};
6449  		std::vector&lt;Column&gt; const&amp; m_columns;
6450  		std::vector&lt;Column::iterator&gt; m_iterators;
6451  		size_t m_activeIterators;
6452  		iterator(Columns const&amp; columns, EndTag)
6453  			: m_columns(columns.m_columns),
6454  			m_activeIterators(0) {
6455  			m_iterators.reserve(m_columns.size());
6456  			for (auto const&amp; col : m_columns)
6457  				m_iterators.push_back(col.end());
6458  		}
6459  	public:
6460  		using difference_type = std::ptrdiff_t;
6461  		using value_type = std::string;
6462  		using pointer = value_type * ;
6463  		using reference = value_type &amp; ;
6464  		using iterator_category = std::forward_iterator_tag;
6465  		explicit iterator(Columns const&amp; columns)
6466  			: m_columns(columns.m_columns),
6467  			m_activeIterators(m_columns.size()) {
6468  			m_iterators.reserve(m_columns.size());
6469  			for (auto const&amp; col : m_columns)
6470  				m_iterators.push_back(col.begin());
6471  		}
6472  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6473  			return m_iterators == other.m_iterators;
6474  		}
6475  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6476  			return m_iterators != other.m_iterators;
6477  		}
6478  		auto operator *() const -&gt; std::string {
6479  			std::string row, padding;
6480  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6481  				auto width = m_columns[i].width();
6482  				if (m_iterators[i] != m_columns[i].end()) {
6483  					std::string col = *m_iterators[i];
6484  					row += padding + col;
6485  					if (col.size() &lt; width)
6486  						padding = std::string(width - col.size(), &#x27; &#x27;);
6487  					else
6488  						padding = &quot;&quot;;
6489  				} else {
6490  					padding += std::string(width, &#x27; &#x27;);
6491  				}
6492  			}
6493  			return row;
6494  		}
6495  		auto operator ++() -&gt; iterator&amp; {
6496  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6497  				if (m_iterators[i] != m_columns[i].end())
6498  					++m_iterators[i];
6499  			}
6500  			return *this;
6501  		}
6502  		auto operator ++(int) -&gt; iterator {
6503  			iterator prev(*this);
6504  			operator++();
6505  			return prev;
6506  		}
6507  	};
6508  	using const_iterator = iterator;
6509  	auto begin() const -&gt; iterator { return iterator(*this); }
6510  	auto end() const -&gt; iterator { return { *this, iterator::EndTag() }; }
6511  	auto operator += (Column const&amp; col) -&gt; Columns&amp; {
6512  		m_columns.push_back(col);
6513  		return *this;
6514  	}
6515  	auto operator + (Column const&amp; col) -&gt; Columns {
6516  		Columns combined = *this;
6517  		combined += col;
6518  		return combined;
6519  	}
6520  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Columns const&amp; cols) {
6521  		bool first = true;
6522  		for (auto line : cols) {
6523  			if (first)
6524  				first = false;
6525  			else
6526  				os &lt;&lt; &quot;\n&quot;;
6527  			os &lt;&lt; line;
6528  		}
6529  		return os;
6530  	}
6531  	auto toString() const -&gt; std::string {
6532  		std::ostringstream oss;
6533  		oss &lt;&lt; *this;
6534  		return oss.str();
6535  	}
6536  };
6537  inline auto Column::operator + (Column const&amp; other) -&gt; Columns {
6538  	Columns cols;
6539  	cols += *this;
6540  	cols += other;
6541  	return cols;
6542  }
6543  }
6544  }
6545  }
6546  #include &lt;cctype&gt;
6547  #include &lt;string&gt;
6548  #include &lt;memory&gt;
6549  #include &lt;set&gt;
6550  #include &lt;algorithm&gt;
6551  #if !defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
6552  #define CATCH_PLATFORM_WINDOWS
6553  #endif
6554  namespace Catch { namespace clara {
6555  namespace detail {
6556      template&lt;typename L&gt;
6557      struct UnaryLambdaTraits : UnaryLambdaTraits&lt;decltype( &amp;L::operator() )&gt; {};
6558      template&lt;typename ClassT, typename ReturnT, typename... Args&gt;
6559      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( Args... ) const&gt; {
6560          static const bool isValid = false;
6561      };
6562      template&lt;typename ClassT, typename ReturnT, typename ArgT&gt;
6563      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( ArgT ) const&gt; {
6564          static const bool isValid = true;
6565          using ArgType = typename std::remove_const&lt;typename std::remove_reference&lt;ArgT&gt;::type&gt;::type;
6566          using ReturnType = ReturnT;
6567      };
6568      class TokenStream;
6569      class Args {
6570          friend TokenStream;
6571          std::string m_exeName;
6572          std::vector&lt;std::string&gt; m_args;
6573      public:
6574          Args( int argc, char const* const* argv )
6575              : m_exeName(argv[0]),
6576                m_args(argv + 1, argv + argc) {}
6577          Args( std::initializer_list&lt;std::string&gt; args )
6578          :   m_exeName( *args.begin() ),
6579              m_args( args.begin()+1, args.end() )
6580          {}
6581          auto exeName() const -&gt; std::string {
6582              return m_exeName;
6583          }
6584      };
6585      enum class TokenType {
6586          Option, Argument
6587      };
6588      struct Token {
6589          TokenType type;
6590          std::string token;
6591      };
6592      inline auto isOptPrefix( char c ) -&gt; bool {
6593          return c == &#x27;-&#x27;
6594  #ifdef CATCH_PLATFORM_WINDOWS
6595              || c == &#x27;/&#x27;
6596  #endif
6597          ;
6598      }
6599      class TokenStream {
6600          using Iterator = std::vector&lt;std::string&gt;::const_iterator;
6601          Iterator it;
6602          Iterator itEnd;
6603          std::vector&lt;Token&gt; m_tokenBuffer;
6604          void loadBuffer() {
6605              m_tokenBuffer.resize( 0 );
6606              while( it != itEnd &amp;&amp; it-&gt;empty() )
6607                  ++it;
6608              if( it != itEnd ) {
6609                  auto const &amp;next = *it;
6610                  if( isOptPrefix( next[0] ) ) {
6611                      auto delimiterPos = next.find_first_of( &quot; :=&quot; );
6612                      if( delimiterPos != std::string::npos ) {
6613                          m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
6614                          m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
6615                      } else {
6616                          if( next[1] != &#x27;-&#x27; &amp;&amp; next.size() &gt; 2 ) {
6617                              std::string opt = &quot;- &quot;;
6618                              for( size_t i = 1; i &lt; next.size(); ++i ) {
6619                                  opt[1] = next[i];
6620                                  m_tokenBuffer.push_back( { TokenType::Option, opt } );
6621                              }
6622                          } else {
6623                              m_tokenBuffer.push_back( { TokenType::Option, next } );
6624                          }
6625                      }
6626                  } else {
6627                      m_tokenBuffer.push_back( { TokenType::Argument, next } );
6628                  }
6629              }
6630          }
6631      public:
6632          explicit TokenStream( Args const &amp;args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
6633          TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
6634              loadBuffer();
6635          }
6636          explicit operator bool() const {
6637              return !m_tokenBuffer.empty() || it != itEnd;
6638          }
6639          auto count() const -&gt; size_t { return m_tokenBuffer.size() + (itEnd - it); }
6640          auto operator*() const -&gt; Token {
6641              assert( !m_tokenBuffer.empty() );
6642              return m_tokenBuffer.front();
6643          }
6644          auto operator-&gt;() const -&gt; Token const * {
6645              assert( !m_tokenBuffer.empty() );
6646              return &amp;m_tokenBuffer.front();
6647          }
6648          auto operator++() -&gt; TokenStream &amp; {
6649              if( m_tokenBuffer.size() &gt;= 2 ) {
6650                  m_tokenBuffer.erase( m_tokenBuffer.begin() );
6651              } else {
6652                  if( it != itEnd )
6653                      ++it;
6654                  loadBuffer();
6655              }
6656              return *this;
6657          }
6658      };
6659      class ResultBase {
6660      public:
6661          enum Type {
6662              Ok, LogicError, RuntimeError
6663          };
6664      protected:
6665          ResultBase( Type type ) : m_type( type ) {}
6666          virtual ~ResultBase() = default;
6667          virtual void enforceOk() const = 0;
6668          Type m_type;
6669      };
6670      template&lt;typename T&gt;
6671      class ResultValueBase : public ResultBase {
6672      public:
6673          auto value() const -&gt; T const &amp; {
6674              enforceOk();
6675              return m_value;
6676          }
6677      protected:
6678          ResultValueBase( Type type ) : ResultBase( type ) {}
6679          ResultValueBase( ResultValueBase const &amp;other ) : ResultBase( other ) {
6680              if( m_type == ResultBase::Ok )
6681                  new( &amp;m_value ) T( other.m_value );
6682          }
6683          ResultValueBase( Type, T const &amp;value ) : ResultBase( Ok ) {
6684              new( &amp;m_value ) T( value );
6685          }
6686          auto operator=( ResultValueBase const &amp;other ) -&gt; ResultValueBase &amp; {
6687              if( m_type == ResultBase::Ok )
6688                  m_value.~T();
6689              ResultBase::operator=(other);
6690              if( m_type == ResultBase::Ok )
6691                  new( &amp;m_value ) T( other.m_value );
6692              return *this;
6693          }
6694          ~ResultValueBase() override {
6695              if( m_type == Ok )
6696                  m_value.~T();
6697          }
6698          union {
6699              T m_value;
6700          };
6701      };
6702      template&lt;&gt;
6703      class ResultValueBase&lt;void&gt; : public ResultBase {
6704      protected:
6705          using ResultBase::ResultBase;
6706      };
6707      template&lt;typename T = void&gt;
6708      class BasicResult : public ResultValueBase&lt;T&gt; {
6709      public:
6710          template&lt;typename U&gt;
6711          explicit BasicResult( BasicResult&lt;U&gt; const &amp;other )
6712          :   ResultValueBase&lt;T&gt;( other.type() ),
6713              m_errorMessage( other.errorMessage() )
6714          {
6715              assert( type() != ResultBase::Ok );
6716          }
6717          template&lt;typename U&gt;
6718          static auto ok( U const &amp;value ) -&gt; BasicResult { return { ResultBase::Ok, value }; }
6719          static auto ok() -&gt; BasicResult { return { ResultBase::Ok }; }
6720          static auto logicError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::LogicError, message }; }
6721          static auto runtimeError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::RuntimeError, message }; }
6722          explicit operator bool() const { return m_type == ResultBase::Ok; }
6723          auto type() const -&gt; ResultBase::Type { return m_type; }
6724          auto errorMessage() const -&gt; std::string { return m_errorMessage; }
6725      protected:
6726          void enforceOk() const override {
6727              assert( m_type != ResultBase::LogicError );
6728              assert( m_type != ResultBase::RuntimeError );
6729              if( m_type != ResultBase::Ok )
6730                  std::abort();
6731          }
6732          std::string m_errorMessage; 
6733          BasicResult( ResultBase::Type type, std::string const &amp;message )
6734          :   ResultValueBase&lt;T&gt;(type),
6735              m_errorMessage(message)
6736          {
6737              assert( m_type != ResultBase::Ok );
6738          }
6739          using ResultValueBase&lt;T&gt;::ResultValueBase;
6740          using ResultBase::m_type;
6741      };
6742      enum class ParseResultType {
6743          Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
6744      };
6745      class ParseState {
6746      public:
6747          ParseState( ParseResultType type, TokenStream const &amp;remainingTokens )
6748          : m_type(type),
6749            m_remainingTokens( remainingTokens )
6750          {}
6751          auto type() const -&gt; ParseResultType { return m_type; }
6752          auto remainingTokens() const -&gt; TokenStream { return m_remainingTokens; }
6753      private:
6754          ParseResultType m_type;
6755          TokenStream m_remainingTokens;
6756      };
6757      using Result = BasicResult&lt;void&gt;;
6758      using ParserResult = BasicResult&lt;ParseResultType&gt;;
6759      using InternalParseResult = BasicResult&lt;ParseState&gt;;
6760      struct HelpColumns {
6761          std::string left;
6762          std::string right;
6763      };
6764      template&lt;typename T&gt;
6765      inline auto convertInto( std::string const &amp;source, T&amp; target ) -&gt; ParserResult {
6766          std::stringstream ss;
6767          ss &lt;&lt; source;
6768          ss &gt;&gt; target;
6769          if( ss.fail() )
6770              return ParserResult::runtimeError( &quot;Unable to convert &#x27;&quot; + source + &quot;&#x27; to destination type&quot; );
6771          else
6772              return ParserResult::ok( ParseResultType::Matched );
6773      }
6774      inline auto convertInto( std::string const &amp;source, std::string&amp; target ) -&gt; ParserResult {
6775          target = source;
6776          return ParserResult::ok( ParseResultType::Matched );
6777      }
6778      inline auto convertInto( std::string const &amp;source, bool &amp;target ) -&gt; ParserResult {
6779          std::string srcLC = source;
6780          std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( unsigned char c ) { return static_cast&lt;char&gt;( std::tolower(c) ); } );
6781          if (srcLC == &quot;y&quot; || srcLC == &quot;1&quot; || srcLC == &quot;true&quot; || srcLC == &quot;yes&quot; || srcLC == &quot;on&quot;)
6782              target = true;
6783          else if (srcLC == &quot;n&quot; || srcLC == &quot;0&quot; || srcLC == &quot;false&quot; || srcLC == &quot;no&quot; || srcLC == &quot;off&quot;)
6784              target = false;
6785          else
6786              return ParserResult::runtimeError( &quot;Expected a boolean value but did not recognise: &#x27;&quot; + source + &quot;&#x27;&quot; );
6787          return ParserResult::ok( ParseResultType::Matched );
6788      }
6789  #ifdef CLARA_CONFIG_OPTIONAL_TYPE
6790      template&lt;typename T&gt;
6791      inline auto convertInto( std::string const &amp;source, CLARA_CONFIG_OPTIONAL_TYPE&lt;T&gt;&amp; target ) -&gt; ParserResult {
6792          T temp;
6793          auto result = convertInto( source, temp );
6794          if( result )
6795              target = std::move(temp);
6796          return result;
6797      }
6798  #endif 
6799      struct NonCopyable {
6800          NonCopyable() = default;
6801          NonCopyable( NonCopyable const &amp; ) = delete;
6802          NonCopyable( NonCopyable &amp;&amp; ) = delete;
6803          NonCopyable &amp;operator=( NonCopyable const &amp; ) = delete;
6804          NonCopyable &amp;operator=( NonCopyable &amp;&amp; ) = delete;
6805      };
6806      struct BoundRef : NonCopyable {
6807          virtual ~BoundRef() = default;
6808          virtual auto isContainer() const -&gt; bool { return false; }
6809          virtual auto isFlag() const -&gt; bool { return false; }
6810      };
6811      struct BoundValueRefBase : BoundRef {
6812          virtual auto setValue( std::string const &amp;arg ) -&gt; ParserResult = 0;
6813      };
6814      struct BoundFlagRefBase : BoundRef {
6815          virtual auto setFlag( bool flag ) -&gt; ParserResult = 0;
6816          virtual auto isFlag() const -&gt; bool { return true; }
6817      };
6818      template&lt;typename T&gt;
6819      struct BoundValueRef : BoundValueRefBase {
6820          T &amp;m_ref;
6821          explicit BoundValueRef( T &amp;ref ) : m_ref( ref ) {}
6822          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6823              return convertInto( arg, m_ref );
6824          }
6825      };
6826      template&lt;typename T&gt;
6827      struct BoundValueRef&lt;std::vector&lt;T&gt;&gt; : BoundValueRefBase {
6828          std::vector&lt;T&gt; &amp;m_ref;
6829          explicit BoundValueRef( std::vector&lt;T&gt; &amp;ref ) : m_ref( ref ) {}
6830          auto isContainer() const -&gt; bool override { return true; }
6831          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6832              T temp;
6833              auto result = convertInto( arg, temp );
6834              if( result )
6835                  m_ref.push_back( temp );
6836              return result;
6837          }
6838      };
6839      struct BoundFlagRef : BoundFlagRefBase {
6840          bool &amp;m_ref;
6841          explicit BoundFlagRef( bool &amp;ref ) : m_ref( ref ) {}
6842          auto setFlag( bool flag ) -&gt; ParserResult override {
6843              m_ref = flag;
6844              return ParserResult::ok( ParseResultType::Matched );
6845          }
6846      };
6847      template&lt;typename ReturnType&gt;
6848      struct LambdaInvoker {
6849          static_assert( std::is_same&lt;ReturnType, ParserResult&gt;::value, &quot;Lambda must return void or clara::ParserResult&quot; );
6850          template&lt;typename L, typename ArgType&gt;
6851          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6852              return lambda( arg );
6853          }
6854      };
6855      template&lt;&gt;
6856      struct LambdaInvoker&lt;void&gt; {
6857          template&lt;typename L, typename ArgType&gt;
6858          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6859              lambda( arg );
6860              return ParserResult::ok( ParseResultType::Matched );
6861          }
6862      };
6863      template&lt;typename ArgType, typename L&gt;
6864      inline auto invokeLambda( L const &amp;lambda, std::string const &amp;arg ) -&gt; ParserResult {
6865          ArgType temp{};
6866          auto result = convertInto( arg, temp );
6867          return !result
6868             ? result
6869             : LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( lambda, temp );
6870      }
6871      template&lt;typename L&gt;
6872      struct BoundLambda : BoundValueRefBase {
6873          L m_lambda;
6874          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6875          explicit BoundLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6876          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6877              return invokeLambda&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType&gt;( m_lambda, arg );
6878          }
6879      };
6880      template&lt;typename L&gt;
6881      struct BoundFlagLambda : BoundFlagRefBase {
6882          L m_lambda;
6883          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6884          static_assert( std::is_same&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType, bool&gt;::value, &quot;flags must be boolean&quot; );
6885          explicit BoundFlagLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6886          auto setFlag( bool flag ) -&gt; ParserResult override {
6887              return LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( m_lambda, flag );
6888          }
6889      };
6890      enum class Optionality { Optional, Required };
6891      struct Parser;
6892      class ParserBase {
6893      public:
6894          virtual ~ParserBase() = default;
6895          virtual auto validate() const -&gt; Result { return Result::ok(); }
6896          virtual auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens) const -&gt; InternalParseResult  = 0;
6897          virtual auto cardinality() const -&gt; size_t { return 1; }
6898          auto parse( Args const &amp;args ) const -&gt; InternalParseResult {
6899              return parse( args.exeName(), TokenStream( args ) );
6900          }
6901      };
6902      template&lt;typename DerivedT&gt;
6903      class ComposableParserImpl : public ParserBase {
6904      public:
6905          template&lt;typename T&gt;
6906          auto operator|( T const &amp;other ) const -&gt; Parser;
6907  		template&lt;typename T&gt;
6908          auto operator+( T const &amp;other ) const -&gt; Parser;
6909      };
6910      template&lt;typename DerivedT&gt;
6911      class ParserRefImpl : public ComposableParserImpl&lt;DerivedT&gt; {
6912      protected:
6913          Optionality m_optionality = Optionality::Optional;
6914          std::shared_ptr&lt;BoundRef&gt; m_ref;
6915          std::string m_hint;
6916          std::string m_description;
6917          explicit ParserRefImpl( std::shared_ptr&lt;BoundRef&gt; const &amp;ref ) : m_ref( ref ) {}
6918      public:
6919          template&lt;typename T&gt;
6920          ParserRefImpl( T &amp;ref, std::string const &amp;hint )
6921          :   m_ref( std::make_shared&lt;BoundValueRef&lt;T&gt;&gt;( ref ) ),
6922              m_hint( hint )
6923          {}
6924          template&lt;typename LambdaT&gt;
6925          ParserRefImpl( LambdaT const &amp;ref, std::string const &amp;hint )
6926          :   m_ref( std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( ref ) ),
6927              m_hint(hint)
6928          {}
6929          auto operator()( std::string const &amp;description ) -&gt; DerivedT &amp; {
6930              m_description = description;
6931              return static_cast&lt;DerivedT &amp;&gt;( *this );
6932          }
6933          auto optional() -&gt; DerivedT &amp; {
6934              m_optionality = Optionality::Optional;
6935              return static_cast&lt;DerivedT &amp;&gt;( *this );
6936          };
6937          auto required() -&gt; DerivedT &amp; {
6938              m_optionality = Optionality::Required;
6939              return static_cast&lt;DerivedT &amp;&gt;( *this );
6940          };
6941          auto isOptional() const -&gt; bool {
6942              return m_optionality == Optionality::Optional;
6943          }
6944          auto cardinality() const -&gt; size_t override {
6945              if( m_ref-&gt;isContainer() )
6946                  return 0;
6947              else
6948                  return 1;
6949          }
6950          auto hint() const -&gt; std::string { return m_hint; }
6951      };
6952      class ExeName : public ComposableParserImpl&lt;ExeName&gt; {
6953          std::shared_ptr&lt;std::string&gt; m_name;
6954          std::shared_ptr&lt;BoundValueRefBase&gt; m_ref;
6955          template&lt;typename LambdaT&gt;
6956          static auto makeRef(LambdaT const &amp;lambda) -&gt; std::shared_ptr&lt;BoundValueRefBase&gt; {
6957              return std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda) ;
6958          }
6959      public:
6960          ExeName() : m_name( std::make_shared&lt;std::string&gt;( &quot;&lt;executable&gt;&quot; ) ) {}
6961          explicit ExeName( std::string &amp;ref ) : ExeName() {
6962              m_ref = std::make_shared&lt;BoundValueRef&lt;std::string&gt;&gt;( ref );
6963          }
6964          template&lt;typename LambdaT&gt;
6965          explicit ExeName( LambdaT const&amp; lambda ) : ExeName() {
6966              m_ref = std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda );
6967          }
6968          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6969              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
6970          }
6971          auto name() const -&gt; std::string { return *m_name; }
6972          auto set( std::string const&amp; newName ) -&gt; ParserResult {
6973              auto lastSlash = newName.find_last_of( &quot;\\/&quot; );
6974              auto filename = ( lastSlash == std::string::npos )
6975                      ? newName
6976                      : newName.substr( lastSlash+1 );
6977              *m_name = filename;
6978              if( m_ref )
6979                  return m_ref-&gt;setValue( filename );
6980              else
6981                  return ParserResult::ok( ParseResultType::Matched );
6982          }
6983      };
6984      class Arg : public ParserRefImpl&lt;Arg&gt; {
6985      public:
6986          using ParserRefImpl::ParserRefImpl;
6987          auto parse( std::string const &amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6988              auto validationResult = validate();
6989              if( !validationResult )
6990                  return InternalParseResult( validationResult );
6991              auto remainingTokens = tokens;
6992              auto const &amp;token = *remainingTokens;
6993              if( token.type != TokenType::Argument )
6994                  return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
6995              assert( !m_ref-&gt;isFlag() );
6996              auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
6997              auto result = valueRef-&gt;setValue( remainingTokens-&gt;token );
6998              if( !result )
6999                  return InternalParseResult( result );
7000              else
7001                  return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7002          }
7003      };
7004      inline auto normaliseOpt( std::string const &amp;optName ) -&gt; std::string {
7005  #ifdef CATCH_PLATFORM_WINDOWS
7006          if( optName[0] == &#x27;/&#x27; )
7007              return &quot;-&quot; + optName.substr( 1 );
7008          else
7009  #endif
7010              return optName;
7011      }
7012      class Opt : public ParserRefImpl&lt;Opt&gt; {
7013      protected:
7014          std::vector&lt;std::string&gt; m_optNames;
7015      public:
7016          template&lt;typename LambdaT&gt;
7017          explicit Opt( LambdaT const &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagLambda&lt;LambdaT&gt;&gt;( ref ) ) {}
7018          explicit Opt( bool &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagRef&gt;( ref ) ) {}
7019          template&lt;typename LambdaT&gt;
7020          Opt( LambdaT const &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7021          template&lt;typename T&gt;
7022          Opt( T &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7023          auto operator[]( std::string const &amp;optName ) -&gt; Opt &amp; {
7024              m_optNames.push_back( optName );
7025              return *this;
7026          }
7027          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7028              std::ostringstream oss;
7029              bool first = true;
7030              for( auto const &amp;opt : m_optNames ) {
7031                  if (first)
7032                      first = false;
7033                  else
7034                      oss &lt;&lt; &quot;, &quot;;
7035                  oss &lt;&lt; opt;
7036              }
7037              if( !m_hint.empty() )
7038                  oss &lt;&lt; &quot; &lt;&quot; &lt;&lt; m_hint &lt;&lt; &quot;&gt;&quot;;
7039              return { { oss.str(), m_description } };
7040          }
7041          auto isMatch( std::string const &amp;optToken ) const -&gt; bool {
7042              auto normalisedToken = normaliseOpt( optToken );
7043              for( auto const &amp;name : m_optNames ) {
7044                  if( normaliseOpt( name ) == normalisedToken )
7045                      return true;
7046              }
7047              return false;
7048          }
7049          using ParserBase::parse;
7050          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7051              auto validationResult = validate();
7052              if( !validationResult )
7053                  return InternalParseResult( validationResult );
7054              auto remainingTokens = tokens;
7055              if( remainingTokens &amp;&amp; remainingTokens-&gt;type == TokenType::Option ) {
7056                  auto const &amp;token = *remainingTokens;
7057                  if( isMatch(token.token ) ) {
7058                      if( m_ref-&gt;isFlag() ) {
7059                          auto flagRef = static_cast&lt;detail::BoundFlagRefBase*&gt;( m_ref.get() );
7060                          auto result = flagRef-&gt;setFlag( true );
7061                          if( !result )
7062                              return InternalParseResult( result );
7063                          if( result.value() == ParseResultType::ShortCircuitAll )
7064                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7065                      } else {
7066                          auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
7067                          ++remainingTokens;
7068                          if( !remainingTokens )
7069                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7070                          auto const &amp;argToken = *remainingTokens;
7071                          if( argToken.type != TokenType::Argument )
7072                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7073                          auto result = valueRef-&gt;setValue( argToken.token );
7074                          if( !result )
7075                              return InternalParseResult( result );
7076                          if( result.value() == ParseResultType::ShortCircuitAll )
7077                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7078                      }
7079                      return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7080                  }
7081              }
7082              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
7083          }
7084          auto validate() const -&gt; Result override {
7085              if( m_optNames.empty() )
7086                  return Result::logicError( &quot;No options supplied to Opt&quot; );
7087              for( auto const &amp;name : m_optNames ) {
7088                  if( name.empty() )
7089                      return Result::logicError( &quot;Option name cannot be empty&quot; );
7090  #ifdef CATCH_PLATFORM_WINDOWS
7091                  if( name[0] != &#x27;-&#x27; &amp;&amp; name[0] != &#x27;/&#x27; )
7092                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27; or &#x27;/&#x27;&quot; );
7093  #else
7094                  if( name[0] != &#x27;-&#x27; )
7095                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27;&quot; );
7096  #endif
7097              }
7098              return ParserRefImpl::validate();
7099          }
7100      };
7101      struct Help : Opt {
7102          Help( bool &amp;showHelpFlag )
7103          :   Opt([&amp;]( bool flag ) {
7104                  showHelpFlag = flag;
7105                  return ParserResult::ok( ParseResultType::ShortCircuitAll );
7106              })
7107          {
7108              static_cast&lt;Opt &amp;&gt;( *this )
7109                      (&quot;display usage information&quot;)
7110                      [&quot;-?&quot;][&quot;-h&quot;][&quot;--help&quot;]
7111                      .optional();
7112          }
7113      };
7114      struct Parser : ParserBase {
7115          mutable ExeName m_exeName;
7116          std::vector&lt;Opt&gt; m_options;
7117          std::vector&lt;Arg&gt; m_args;
7118          auto operator|=( ExeName const &amp;exeName ) -&gt; Parser &amp; {
7119              m_exeName = exeName;
7120              return *this;
7121          }
7122          auto operator|=( Arg const &amp;arg ) -&gt; Parser &amp; {
7123              m_args.push_back(arg);
7124              return *this;
7125          }
7126          auto operator|=( Opt const &amp;opt ) -&gt; Parser &amp; {
7127              m_options.push_back(opt);
7128              return *this;
7129          }
7130          auto operator|=( Parser const &amp;other ) -&gt; Parser &amp; {
7131              m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
7132              m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
7133              return *this;
7134          }
7135          template&lt;typename T&gt;
7136          auto operator|( T const &amp;other ) const -&gt; Parser {
7137              return Parser( *this ) |= other;
7138          }
7139          template&lt;typename T&gt;
7140          auto operator+=( T const &amp;other ) -&gt; Parser &amp; { return operator|=( other ); }
7141          template&lt;typename T&gt;
7142          auto operator+( T const &amp;other ) const -&gt; Parser { return operator|( other ); }
7143          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7144              std::vector&lt;HelpColumns&gt; cols;
7145              for (auto const &amp;o : m_options) {
7146                  auto childCols = o.getHelpColumns();
7147                  cols.insert( cols.end(), childCols.begin(), childCols.end() );
7148              }
7149              return cols;
7150          }
7151          void writeToStream( std::ostream &amp;os ) const {
7152              if (!m_exeName.name().empty()) {
7153                  os &lt;&lt; &quot;usage:\n&quot; &lt;&lt; &quot;  &quot; &lt;&lt; m_exeName.name() &lt;&lt; &quot; &quot;;
7154                  bool required = true, first = true;
7155                  for( auto const &amp;arg : m_args ) {
7156                      if (first)
7157                          first = false;
7158                      else
7159                          os &lt;&lt; &quot; &quot;;
7160                      if( arg.isOptional() &amp;&amp; required ) {
7161                          os &lt;&lt; &quot;[&quot;;
7162                          required = false;
7163                      }
7164                      os &lt;&lt; &quot;&lt;&quot; &lt;&lt; arg.hint() &lt;&lt; &quot;&gt;&quot;;
7165                      if( arg.cardinality() == 0 )
7166                          os &lt;&lt; &quot; ... &quot;;
7167                  }
7168                  if( !required )
7169                      os &lt;&lt; &quot;]&quot;;
7170                  if( !m_options.empty() )
7171                      os &lt;&lt; &quot; options&quot;;
7172                  os &lt;&lt; &quot;\n\nwhere options are:&quot; &lt;&lt; std::endl;
7173              }
7174              auto rows = getHelpColumns();
7175              size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
7176              size_t optWidth = 0;
7177              for( auto const &amp;cols : rows )
7178                  optWidth = (std::max)(optWidth, cols.left.size() + 2);
7179              optWidth = (std::min)(optWidth, consoleWidth/2);
7180              for( auto const &amp;cols : rows ) {
7181                  auto row =
7182                          TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
7183                          TextFlow::Spacer(4) +
7184                          TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
7185                  os &lt;&lt; row &lt;&lt; std::endl;
7186              }
7187          }
7188          friend auto operator&lt;&lt;( std::ostream &amp;os, Parser const &amp;parser ) -&gt; std::ostream&amp; {
7189              parser.writeToStream( os );
7190              return os;
7191          }
7192          auto validate() const -&gt; Result override {
7193              for( auto const &amp;opt : m_options ) {
7194                  auto result = opt.validate();
7195                  if( !result )
7196                      return result;
7197              }
7198              for( auto const &amp;arg : m_args ) {
7199                  auto result = arg.validate();
7200                  if( !result )
7201                      return result;
7202              }
7203              return Result::ok();
7204          }
7205          using ParserBase::parse;
7206          auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7207              struct ParserInfo {
7208                  ParserBase const* parser = nullptr;
7209                  size_t count = 0;
7210              };
7211              const size_t totalParsers = m_options.size() + m_args.size();
7212              assert( totalParsers &lt; 512 );
7213              ParserInfo parseInfos[512];
7214              {
7215                  size_t i = 0;
7216                  for (auto const &amp;opt : m_options) parseInfos[i++].parser = &amp;opt;
7217                  for (auto const &amp;arg : m_args) parseInfos[i++].parser = &amp;arg;
7218              }
7219              m_exeName.set( exeName );
7220              auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
7221              while( result.value().remainingTokens() ) {
7222                  bool tokenParsed = false;
7223                  for( size_t i = 0; i &lt; totalParsers; ++i ) {
7224                      auto&amp;  parseInfo = parseInfos[i];
7225                      if( parseInfo.parser-&gt;cardinality() == 0 || parseInfo.count &lt; parseInfo.parser-&gt;cardinality() ) {
7226                          result = parseInfo.parser-&gt;parse(exeName, result.value().remainingTokens());
7227                          if (!result)
7228                              return result;
7229                          if (result.value().type() != ParseResultType::NoMatch) {
7230                              tokenParsed = true;
7231                              ++parseInfo.count;
7232                              break;
7233                          }
7234                      }
7235                  }
7236                  if( result.value().type() == ParseResultType::ShortCircuitAll )
7237                      return result;
7238                  if( !tokenParsed )
7239                      return InternalParseResult::runtimeError( &quot;Unrecognised token: &quot; + result.value().remainingTokens()-&gt;token );
7240              }
7241              return result;
7242          }
7243      };
7244      template&lt;typename DerivedT&gt;
7245      template&lt;typename T&gt;
7246      auto ComposableParserImpl&lt;DerivedT&gt;::operator|( T const &amp;other ) const -&gt; Parser {
7247          return Parser() | static_cast&lt;DerivedT const &amp;&gt;( *this ) | other;
7248      }
7249  } 
7250  using detail::Parser;
7251  using detail::Opt;
7252  using detail::Arg;
7253  using detail::Args;
7254  using detail::ExeName;
7255  using detail::Help;
7256  using detail::ParseResultType;
7257  using detail::ParserResult;
7258  }} 
7259  #ifdef __clang__
7260  #pragma clang diagnostic pop
7261  #endif
7262  #ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7263  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7264  #undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7265  #endif
7266  namespace Catch {
7267      clara::Parser makeCommandLineParser( ConfigData&amp; config );
7268  } 
7269  #include &lt;fstream&gt;
7270  #include &lt;ctime&gt;
7271  namespace Catch {
7272      clara::Parser makeCommandLineParser( ConfigData&amp; config ) {
7273          using namespace clara;
7274          auto const setWarning = [&amp;]( std::string const&amp; warning ) {
7275                  auto warningSet = [&amp;]() {
7276                      if( warning == &quot;NoAssertions&quot; )
7277                          return WarnAbout::NoAssertions;
7278                      if ( warning == &quot;NoTests&quot; )
7279                          return WarnAbout::NoTests;
7280                      return WarnAbout::Nothing;
7281                  }();
7282                  if (warningSet == WarnAbout::Nothing)
7283                      return ParserResult::runtimeError( &quot;Unrecognised warning: &#x27;&quot; + warning + &quot;&#x27;&quot; );
7284                  config.warnings = static_cast&lt;WarnAbout::What&gt;( config.warnings | warningSet );
7285                  return ParserResult::ok( ParseResultType::Matched );
7286              };
7287          auto const loadTestNamesFromFile = [&amp;]( std::string const&amp; filename ) {
7288                  std::ifstream f( filename.c_str() );
7289                  if( !f.is_open() )
7290                      return ParserResult::runtimeError( &quot;Unable to load input file: &#x27;&quot; + filename + &quot;&#x27;&quot; );
7291                  std::string line;
7292                  while( std::getline( f, line ) ) {
7293                      line = trim(line);
7294                      if( !line.empty() &amp;&amp; !startsWith( line, &#x27;#&#x27; ) ) {
7295                          if( !startsWith( line, &#x27;&quot;&#x27; ) )
7296                              line = &#x27;&quot;&#x27; + line + &#x27;&quot;&#x27;;
7297                          config.testsOrTags.push_back( line );
7298                          config.testsOrTags.emplace_back( &quot;,&quot; );
7299                      }
7300                  }
7301                  if(!config.testsOrTags.empty())
7302                      config.testsOrTags.erase( config.testsOrTags.end()-1 );
7303                  return ParserResult::ok( ParseResultType::Matched );
7304              };
7305          auto const setTestOrder = [&amp;]( std::string const&amp; order ) {
7306                  if( startsWith( &quot;declared&quot;, order ) )
7307                      config.runOrder = RunTests::InDeclarationOrder;
7308                  else if( startsWith( &quot;lexical&quot;, order ) )
7309                      config.runOrder = RunTests::InLexicographicalOrder;
7310                  else if( startsWith( &quot;random&quot;, order ) )
7311                      config.runOrder = RunTests::InRandomOrder;
7312                  else
7313                      return clara::ParserResult::runtimeError( &quot;Unrecognised ordering: &#x27;&quot; + order + &quot;&#x27;&quot; );
7314                  return ParserResult::ok( ParseResultType::Matched );
7315              };
7316          auto const setRngSeed = [&amp;]( std::string const&amp; seed ) {
7317                  if( seed != &quot;time&quot; )
7318                      return clara::detail::convertInto( seed, config.rngSeed );
7319                  config.rngSeed = static_cast&lt;unsigned int&gt;( std::time(nullptr) );
7320                  return ParserResult::ok( ParseResultType::Matched );
7321              };
7322          auto const setColourUsage = [&amp;]( std::string const&amp; useColour ) {
7323                      auto mode = toLower( useColour );
7324                      if( mode == &quot;yes&quot; )
7325                          config.useColour = UseColour::Yes;
7326                      else if( mode == &quot;no&quot; )
7327                          config.useColour = UseColour::No;
7328                      else if( mode == &quot;auto&quot; )
7329                          config.useColour = UseColour::Auto;
7330                      else
7331                          return ParserResult::runtimeError( &quot;colour mode must be one of: auto, yes or no. &#x27;&quot; + useColour + &quot;&#x27; not recognised&quot; );
7332                  return ParserResult::ok( ParseResultType::Matched );
7333              };
7334          auto const setWaitForKeypress = [&amp;]( std::string const&amp; keypress ) {
7335                  auto keypressLc = toLower( keypress );
7336                  if (keypressLc == &quot;never&quot;)
7337                      config.waitForKeypress = WaitForKeypress::Never;
7338                  else if( keypressLc == &quot;start&quot; )
7339                      config.waitForKeypress = WaitForKeypress::BeforeStart;
7340                  else if( keypressLc == &quot;exit&quot; )
7341                      config.waitForKeypress = WaitForKeypress::BeforeExit;
7342                  else if( keypressLc == &quot;both&quot; )
7343                      config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
7344                  else
7345                      return ParserResult::runtimeError( &quot;keypress argument must be one of: never, start, exit or both. &#x27;&quot; + keypress + &quot;&#x27; not recognised&quot; );
7346              return ParserResult::ok( ParseResultType::Matched );
7347              };
7348          auto const setVerbosity = [&amp;]( std::string const&amp; verbosity ) {
7349              auto lcVerbosity = toLower( verbosity );
7350              if( lcVerbosity == &quot;quiet&quot; )
7351                  config.verbosity = Verbosity::Quiet;
7352              else if( lcVerbosity == &quot;normal&quot; )
7353                  config.verbosity = Verbosity::Normal;
7354              else if( lcVerbosity == &quot;high&quot; )
7355                  config.verbosity = Verbosity::High;
7356              else
7357                  return ParserResult::runtimeError( &quot;Unrecognised verbosity, &#x27;&quot; + verbosity + &quot;&#x27;&quot; );
7358              return ParserResult::ok( ParseResultType::Matched );
7359          };
7360          auto const setReporter = [&amp;]( std::string const&amp; reporter ) {
7361              IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
7362              auto lcReporter = toLower( reporter );
7363              auto result = factories.find( lcReporter );
7364              if( factories.end() != result )
7365                  config.reporterName = lcReporter;
7366              else
7367                  return ParserResult::runtimeError( &quot;Unrecognized reporter, &#x27;&quot; + reporter + &quot;&#x27;. Check available with --list-reporters&quot; );
7368              return ParserResult::ok( ParseResultType::Matched );
7369          };
7370          auto cli
7371              = ExeName( config.processName )
7372              | Help( config.showHelp )
7373              | Opt( config.listTests )
7374                  [&quot;-l&quot;][&quot;--list-tests&quot;]
7375                  ( &quot;list all/matching test cases&quot; )
7376              | Opt( config.listTags )
7377                  [&quot;-t&quot;][&quot;--list-tags&quot;]
7378                  ( &quot;list all/matching tags&quot; )
7379              | Opt( config.showSuccessfulTests )
7380                  [&quot;-s&quot;][&quot;--success&quot;]
7381                  ( &quot;include successful tests in output&quot; )
7382              | Opt( config.shouldDebugBreak )
7383                  [&quot;-b&quot;][&quot;--break&quot;]
7384                  ( &quot;break into debugger on failure&quot; )
7385              | Opt( config.noThrow )
7386                  [&quot;-e&quot;][&quot;--nothrow&quot;]
7387                  ( &quot;skip exception tests&quot; )
7388              | Opt( config.showInvisibles )
7389                  [&quot;-i&quot;][&quot;--invisibles&quot;]
7390                  ( &quot;show invisibles (tabs, newlines)&quot; )
7391              | Opt( config.outputFilename, &quot;filename&quot; )
7392                  [&quot;-o&quot;][&quot;--out&quot;]
7393                  ( &quot;output filename&quot; )
7394              | Opt( setReporter, &quot;name&quot; )
7395                  [&quot;-r&quot;][&quot;--reporter&quot;]
7396                  ( &quot;reporter to use (defaults to console)&quot; )
7397              | Opt( config.name, &quot;name&quot; )
7398                  [&quot;-n&quot;][&quot;--name&quot;]
7399                  ( &quot;suite name&quot; )
7400              | Opt( [&amp;]( bool ){ config.abortAfter = 1; } )
7401                  [&quot;-a&quot;][&quot;--abort&quot;]
7402                  ( &quot;abort at first failure&quot; )
7403              | Opt( [&amp;]( int x ){ config.abortAfter = x; }, &quot;no. failures&quot; )
7404                  [&quot;-x&quot;][&quot;--abortx&quot;]
7405                  ( &quot;abort after x failures&quot; )
7406              | Opt( setWarning, &quot;warning name&quot; )
7407                  [&quot;-w&quot;][&quot;--warn&quot;]
7408                  ( &quot;enable warnings&quot; )
7409              | Opt( [&amp;]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, &quot;yes|no&quot; )
7410                  [&quot;-d&quot;][&quot;--durations&quot;]
7411                  ( &quot;show test durations&quot; )
7412              | Opt( config.minDuration, &quot;seconds&quot; )
7413                  [&quot;-D&quot;][&quot;--min-duration&quot;]
7414                  ( &quot;show test durations for tests taking at least the given number of seconds&quot; )
7415              | Opt( loadTestNamesFromFile, &quot;filename&quot; )
7416                  [&quot;-f&quot;][&quot;--input-file&quot;]
7417                  ( &quot;load test names to run from a file&quot; )
7418              | Opt( config.filenamesAsTags )
7419                  [&quot;-#&quot;][&quot;--filenames-as-tags&quot;]
7420                  ( &quot;adds a tag for the filename&quot; )
7421              | Opt( config.sectionsToRun, &quot;section name&quot; )
7422                  [&quot;-c&quot;][&quot;--section&quot;]
7423                  ( &quot;specify section to run&quot; )
7424              | Opt( setVerbosity, &quot;quiet|normal|high&quot; )
7425                  [&quot;-v&quot;][&quot;--verbosity&quot;]
7426                  ( &quot;set output verbosity&quot; )
7427              | Opt( config.listTestNamesOnly )
7428                  [&quot;--list-test-names-only&quot;]
7429                  ( &quot;list all/matching test cases names only&quot; )
7430              | Opt( config.listReporters )
7431                  [&quot;--list-reporters&quot;]
7432                  ( &quot;list all reporters&quot; )
7433              | Opt( setTestOrder, &quot;decl|lex|rand&quot; )
7434                  [&quot;--order&quot;]
7435                  ( &quot;test case order (defaults to decl)&quot; )
7436              | Opt( setRngSeed, &quot;&#x27;time&#x27;|number&quot; )
7437                  [&quot;--rng-seed&quot;]
7438                  ( &quot;set a specific seed for random numbers&quot; )
7439              | Opt( setColourUsage, &quot;yes|no&quot; )
7440                  [&quot;--use-colour&quot;]
7441                  ( &quot;should output be colourised&quot; )
7442              | Opt( config.libIdentify )
7443                  [&quot;--libidentify&quot;]
7444                  ( &quot;report name and version according to libidentify standard&quot; )
7445              | Opt( setWaitForKeypress, &quot;never|start|exit|both&quot; )
7446                  [&quot;--wait-for-keypress&quot;]
7447                  ( &quot;waits for a keypress before exiting&quot; )
7448              | Opt( config.benchmarkSamples, &quot;samples&quot; )
7449                  [&quot;--benchmark-samples&quot;]
7450                  ( &quot;number of samples to collect (default: 100)&quot; )
7451              | Opt( config.benchmarkResamples, &quot;resamples&quot; )
7452                  [&quot;--benchmark-resamples&quot;]
7453                  ( &quot;number of resamples for the bootstrap (default: 100000)&quot; )
7454              | Opt( config.benchmarkConfidenceInterval, &quot;confidence interval&quot; )
7455                  [&quot;--benchmark-confidence-interval&quot;]
7456                  ( &quot;confidence interval for the bootstrap (between 0 and 1, default: 0.95)&quot; )
7457              | Opt( config.benchmarkNoAnalysis )
7458                  [&quot;--benchmark-no-analysis&quot;]
7459                  ( &quot;perform only measurements; do not perform any analysis&quot; )
7460              | Opt( config.benchmarkWarmupTime, &quot;benchmarkWarmupTime&quot; )
7461                  [&quot;--benchmark-warmup-time&quot;]
7462                  ( &quot;amount of time in milliseconds spent on warming up each test (default: 100)&quot; )
7463              | Arg( config.testsOrTags, &quot;test name|pattern|tags&quot; )
7464                  ( &quot;which test or tests to use&quot; );
7465          return cli;
7466      }
7467  } 
7468  #include &lt;cstring&gt;
7469  #include &lt;ostream&gt;
7470  namespace Catch {
7471      bool SourceLineInfo::operator == ( SourceLineInfo const&amp; other ) const noexcept {
7472          return line == other.line &amp;&amp; (file == other.file || std::strcmp(file, other.file) == 0);
7473      }
7474      bool SourceLineInfo::operator &lt; ( SourceLineInfo const&amp; other ) const noexcept {
7475          return line &lt; other.line || ( line == other.line &amp;&amp; file != other.file &amp;&amp; (std::strcmp(file, other.file) &lt; 0));
7476      }
7477      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, SourceLineInfo const&amp; info ) {
7478  #ifndef __GNUG__
7479          os &lt;&lt; info.file &lt;&lt; &#x27;(&#x27; &lt;&lt; info.line &lt;&lt; &#x27;)&#x27;;
7480  #else
7481          os &lt;&lt; info.file &lt;&lt; &#x27;:&#x27; &lt;&lt; info.line;
7482  #endif
7483          return os;
7484      }
7485      std::string StreamEndStop::operator+() const {
7486          return std::string();
7487      }
7488      NonCopyable::NonCopyable() = default;
7489      NonCopyable::~NonCopyable() = default;
7490  }
7491  namespace Catch {
7492      Config::Config( ConfigData const&amp; data )
7493      :   m_data( data ),
7494          m_stream( openStream() )
7495      {
7496          for (auto&amp; elem : m_data.testsOrTags) {
7497              elem = trim(elem);
7498          }
7499          for (auto&amp; elem : m_data.sectionsToRun) {
7500              elem = trim(elem);
7501          }
7502          TestSpecParser parser(ITagAliasRegistry::get());
7503          if (!m_data.testsOrTags.empty()) {
7504              m_hasTestFilters = true;
7505              for (auto const&amp; testOrTags : m_data.testsOrTags) {
7506                  parser.parse(testOrTags);
7507              }
7508          }
7509          m_testSpec = parser.testSpec();
7510      }
7511      std::string const&amp; Config::getFilename() const {
7512          return m_data.outputFilename ;
7513      }
7514      bool Config::listTests() const          { return m_data.listTests; }
7515      bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
7516      bool Config::listTags() const           { return m_data.listTags; }
7517      bool Config::listReporters() const      { return m_data.listReporters; }
7518      std::string Config::getProcessName() const { return m_data.processName; }
7519      std::string const&amp; Config::getReporterName() const { return m_data.reporterName; }
7520      std::vector&lt;std::string&gt; const&amp; Config::getTestsOrTags() const { return m_data.testsOrTags; }
7521      std::vector&lt;std::string&gt; const&amp; Config::getSectionsToRun() const { return m_data.sectionsToRun; }
7522      TestSpec const&amp; Config::testSpec() const { return m_testSpec; }
7523      bool Config::hasTestFilters() const { return m_hasTestFilters; }
7524      bool Config::showHelp() const { return m_data.showHelp; }
7525      bool Config::allowThrows() const                   { return !m_data.noThrow; }
7526      std::ostream&amp; Config::stream() const               { return m_stream-&gt;stream(); }
7527      std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
7528      bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
7529      bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings &amp; WarnAbout::NoAssertions); }
7530      bool Config::warnAboutNoTests() const              { return !!(m_data.warnings &amp; WarnAbout::NoTests); }
7531      ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
7532      double Config::minDuration() const                 { return m_data.minDuration; }
7533      RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
7534      unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
7535      UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
7536      bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
7537      int Config::abortAfter() const                     { return m_data.abortAfter; }
7538      bool Config::showInvisibles() const                { return m_data.showInvisibles; }
7539      Verbosity Config::verbosity() const                { return m_data.verbosity; }
7540      bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
7541      int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
7542      double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
7543      unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
7544      std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }
7545      IStream const* Config::openStream() {
7546          return Catch::makeStream(m_data.outputFilename);
7547      }
7548  } 
7549  #if defined(__clang__)
7550  #    pragma clang diagnostic push
7551  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
7552  #endif
7553  namespace Catch {
7554      class ErrnoGuard {
7555      public:
7556          ErrnoGuard();
7557          ~ErrnoGuard();
7558      private:
7559          int m_oldErrno;
7560      };
7561  }
7562  #if defined(CATCH_PLATFORM_WINDOWS)
7563  #if !defined(NOMINMAX) &amp;&amp; !defined(CATCH_CONFIG_NO_NOMINMAX)
7564  #  define CATCH_DEFINED_NOMINMAX
7565  #  define NOMINMAX
7566  #endif
7567  #if !defined(WIN32_LEAN_AND_MEAN) &amp;&amp; !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
7568  #  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7569  #  define WIN32_LEAN_AND_MEAN
7570  #endif
7571  #ifdef __AFXDLL
7572  #include &lt;AfxWin.h&gt;
7573  #else
7574  #include &lt;windows.h&gt;
7575  #endif
7576  #ifdef CATCH_DEFINED_NOMINMAX
7577  #  undef NOMINMAX
7578  #endif
7579  #ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7580  #  undef WIN32_LEAN_AND_MEAN
7581  #endif
7582  #endif 
7583  #include &lt;sstream&gt;
7584  namespace Catch {
7585      namespace {
7586          struct IColourImpl {
7587              virtual ~IColourImpl() = default;
7588              virtual void use( Colour::Code _colourCode ) = 0;
7589          };
7590          struct NoColourImpl : IColourImpl {
7591              void use( Colour::Code ) override {}
7592              static IColourImpl* instance() {
7593                  static NoColourImpl s_instance;
7594                  return &amp;s_instance;
7595              }
7596          };
7597      } 
7598  } 
7599  #if !defined( CATCH_CONFIG_COLOUR_NONE ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_WINDOWS ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_ANSI )
7600  #   ifdef CATCH_PLATFORM_WINDOWS
7601  #       define CATCH_CONFIG_COLOUR_WINDOWS
7602  #   else
7603  #       define CATCH_CONFIG_COLOUR_ANSI
7604  #   endif
7605  #endif
7606  #if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) 
7607  namespace Catch {
7608  namespace {
7609      class Win32ColourImpl : public IColourImpl {
7610      public:
7611          Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
7612          {
7613              CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
7614              GetConsoleScreenBufferInfo( stdoutHandle, &amp;csbiInfo );
7615              originalForegroundAttributes = csbiInfo.wAttributes &amp; ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
7616              originalBackgroundAttributes = csbiInfo.wAttributes &amp; ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
7617          }
7618          void use( Colour::Code _colourCode ) override {
7619              switch( _colourCode ) {
7620                  case Colour::None:      return setTextAttribute( originalForegroundAttributes );
7621                  case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7622                  case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
7623                  case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
7624                  case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
7625                  case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
7626                  case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
7627                  case Colour::Grey:      return setTextAttribute( 0 );
7628                  case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
7629                  case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
7630                  case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
7631                  case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7632                  case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
7633                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7634                  default:
7635                      CATCH_ERROR( &quot;Unknown colour requested&quot; );
7636              }
7637          }
7638      private:
7639          void setTextAttribute( WORD _textAttribute ) {
7640              SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
7641          }
7642          HANDLE stdoutHandle;
7643          WORD originalForegroundAttributes;
7644          WORD originalBackgroundAttributes;
7645      };
7646      IColourImpl* platformColourInstance() {
7647          static Win32ColourImpl s_instance;
7648          IConfigPtr config = getCurrentContext().getConfig();
7649          UseColour::YesOrNo colourMode = config
7650              ? config-&gt;useColour()
7651              : UseColour::Auto;
7652          if( colourMode == UseColour::Auto )
7653              colourMode = UseColour::Yes;
7654          return colourMode == UseColour::Yes
7655              ? &amp;s_instance
7656              : NoColourImpl::instance();
7657      }
7658  } 
7659  } 
7660  #elif defined( CATCH_CONFIG_COLOUR_ANSI ) 
7661  #include &lt;unistd.h&gt;
7662  namespace Catch {
7663  namespace {
7664      class PosixColourImpl : public IColourImpl {
7665      public:
7666          void use( Colour::Code _colourCode ) override {
7667              switch( _colourCode ) {
7668                  case Colour::None:
7669                  case Colour::White:     return setColour( &quot;[0m&quot; );
7670                  case Colour::Red:       return setColour( &quot;[0;31m&quot; );
7671                  case Colour::Green:     return setColour( &quot;[0;32m&quot; );
7672                  case Colour::Blue:      return setColour( &quot;[0;34m&quot; );
7673                  case Colour::Cyan:      return setColour( &quot;[0;36m&quot; );
7674                  case Colour::Yellow:    return setColour( &quot;[0;33m&quot; );
7675                  case Colour::Grey:      return setColour( &quot;[1;30m&quot; );
7676                  case Colour::LightGrey:     return setColour( &quot;[0;37m&quot; );
7677                  case Colour::BrightRed:     return setColour( &quot;[1;31m&quot; );
7678                  case Colour::BrightGreen:   return setColour( &quot;[1;32m&quot; );
7679                  case Colour::BrightWhite:   return setColour( &quot;[1;37m&quot; );
7680                  case Colour::BrightYellow:  return setColour( &quot;[1;33m&quot; );
7681                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7682                  default: CATCH_INTERNAL_ERROR( &quot;Unknown colour requested&quot; );
7683              }
7684          }
7685          static IColourImpl* instance() {
7686              static PosixColourImpl s_instance;
7687              return &amp;s_instance;
7688          }
7689      private:
7690          void setColour( const char* _escapeCode ) {
7691              getCurrentContext().getConfig()-&gt;stream()
7692                  &lt;&lt; &#x27;\033&#x27; &lt;&lt; _escapeCode;
7693          }
7694      };
7695      bool useColourOnPlatform() {
7696          return
7697  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7698              !isDebuggerActive() &amp;&amp;
7699  #endif
7700  #if !(defined(__DJGPP__) &amp;&amp; defined(__STRICT_ANSI__))
7701              isatty(STDOUT_FILENO)
7702  #else
7703              false
7704  #endif
7705              ;
7706      }
7707      IColourImpl* platformColourInstance() {
7708          ErrnoGuard guard;
7709          IConfigPtr config = getCurrentContext().getConfig();
7710          UseColour::YesOrNo colourMode = config
7711              ? config-&gt;useColour()
7712              : UseColour::Auto;
7713          if( colourMode == UseColour::Auto )
7714              colourMode = useColourOnPlatform()
7715                  ? UseColour::Yes
7716                  : UseColour::No;
7717          return colourMode == UseColour::Yes
7718              ? PosixColourImpl::instance()
7719              : NoColourImpl::instance();
7720      }
7721  } 
7722  } 
7723  #else  
7724  namespace Catch {
7725      static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
7726  } 
7727  #endif 
7728  namespace Catch {
7729      Colour::Colour( Code _colourCode ) { use( _colourCode ); }
7730      Colour::Colour( Colour&amp;&amp; other ) noexcept {
7731          m_moved = other.m_moved;
7732          other.m_moved = true;
7733      }
7734      Colour&amp; Colour::operator=( Colour&amp;&amp; other ) noexcept {
7735          m_moved = other.m_moved;
7736          other.m_moved  = true;
7737          return *this;
7738      }
7739      Colour::~Colour(){ if( !m_moved ) use( None ); }
7740      void Colour::use( Code _colourCode ) {
7741          static IColourImpl* impl = platformColourInstance();
7742          if (impl != nullptr) {
7743              impl-&gt;use( _colourCode );
7744          }
7745      }
7746      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Colour const&amp; ) {
7747          return os;
7748      }
7749  } 
7750  #if defined(__clang__)
7751  #    pragma clang diagnostic pop
7752  #endif
7753  namespace Catch {
7754      class Context : public IMutableContext, NonCopyable {
7755      public: 
7756          IResultCapture* getResultCapture() override {
7757              return m_resultCapture;
7758          }
7759          IRunner* getRunner() override {
7760              return m_runner;
7761          }
7762          IConfigPtr const&amp; getConfig() const override {
7763              return m_config;
7764          }
7765          ~Context() override;
7766      public: 
7767          void setResultCapture( IResultCapture* resultCapture ) override {
7768              m_resultCapture = resultCapture;
7769          }
7770          void setRunner( IRunner* runner ) override {
7771              m_runner = runner;
7772          }
7773          void setConfig( IConfigPtr const&amp; config ) override {
7774              m_config = config;
7775          }
7776          friend IMutableContext&amp; getCurrentMutableContext();
7777      private:
7778          IConfigPtr m_config;
7779          IRunner* m_runner = nullptr;
7780          IResultCapture* m_resultCapture = nullptr;
7781      };
7782      IMutableContext *IMutableContext::currentContext = nullptr;
7783      void IMutableContext::createContext()
7784      {
7785          currentContext = new Context();
7786      }
7787      void cleanUpContext() {
7788          delete IMutableContext::currentContext;
7789          IMutableContext::currentContext = nullptr;
7790      }
7791      IContext::~IContext() = default;
7792      IMutableContext::~IMutableContext() = default;
7793      Context::~Context() = default;
7794      SimplePcg32&amp; rng() {
7795          static SimplePcg32 s_rng;
7796          return s_rng;
7797      }
7798  }
7799  #include &lt;string&gt;
7800  namespace Catch {
7801      void writeToDebugConsole( std::string const&amp; text );
7802  }
7803  #if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
7804  #include &lt;android/log.h&gt;
7805      namespace Catch {
7806          void writeToDebugConsole( std::string const&amp; text ) {
7807              __android_log_write( ANDROID_LOG_DEBUG, &quot;Catch&quot;, text.c_str() );
7808          }
7809      }
7810  #elif defined(CATCH_PLATFORM_WINDOWS)
7811      namespace Catch {
7812          void writeToDebugConsole( std::string const&amp; text ) {
7813              ::OutputDebugStringA( text.c_str() );
7814          }
7815      }
7816  #else
7817      namespace Catch {
7818          void writeToDebugConsole( std::string const&amp; text ) {
7819              Catch::cout() &lt;&lt; text;
7820          }
7821      }
7822  #endif 
7823  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7824  #  include &lt;cassert&gt;
7825  #  include &lt;sys/types.h&gt;
7826  #  include &lt;unistd.h&gt;
7827  #  include &lt;cstddef&gt;
7828  #  include &lt;ostream&gt;
7829  #ifdef __apple_build_version__
7830  #  include &lt;sys/sysctl.h&gt;
7831  #endif
7832      namespace Catch {
7833          #ifdef __apple_build_version__
7834          bool isDebuggerActive(){
7835              int                 mib[4];
7836              struct kinfo_proc   info;
7837              std::size_t         size;
7838              info.kp_proc.p_flag = 0;
7839              mib[0] = CTL_KERN;
7840              mib[1] = KERN_PROC;
7841              mib[2] = KERN_PROC_PID;
7842              mib[3] = getpid();
7843              size = sizeof(info);
7844              if( sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, nullptr, 0) != 0 ) {
7845                  Catch::cerr() &lt;&lt; &quot;\n** Call to sysctl failed - unable to determine if debugger is active **\n&quot; &lt;&lt; std::endl;
7846                  return false;
7847              }
7848              return ( (info.kp_proc.p_flag &amp; P_TRACED) != 0 );
7849          }
7850          #else
7851          bool isDebuggerActive() {
7852              return false;
7853          }
7854          #endif
7855      } 
7856  #elif defined(CATCH_PLATFORM_LINUX)
7857      #include &lt;fstream&gt;
7858      #include &lt;string&gt;
7859      namespace Catch{
7860          bool isDebuggerActive(){
7861              ErrnoGuard guard;
7862              std::ifstream in(&quot;/proc/self/status&quot;);
7863              for( std::string line; std::getline(in, line); ) {
7864                  static const int PREFIX_LEN = 11;
7865                  if( line.compare(0, PREFIX_LEN, &quot;TracerPid:\t&quot;) == 0 ) {
7866                      return line.length() &gt; PREFIX_LEN &amp;&amp; line[PREFIX_LEN] != &#x27;0&#x27;;
7867                  }
7868              }
7869              return false;
7870          }
7871      } 
7872  #elif defined(_MSC_VER)
7873      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7874      namespace Catch {
7875          bool isDebuggerActive() {
7876              return IsDebuggerPresent() != 0;
7877          }
7878      }
7879  #elif defined(__MINGW32__)
7880      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7881      namespace Catch {
7882          bool isDebuggerActive() {
7883              return IsDebuggerPresent() != 0;
7884          }
7885      }
7886  #else
7887      namespace Catch {
7888         bool isDebuggerActive() { return false; }
7889      }
7890  #endif 
7891  namespace Catch {
7892      ITransientExpression::~ITransientExpression() = default;
7893      void formatReconstructedExpression( std::ostream &amp;os, std::string const&amp; lhs, StringRef op, std::string const&amp; rhs ) {
7894          if( lhs.size() + rhs.size() &lt; 40 &amp;&amp;
7895                  lhs.find(&#x27;\n&#x27;) == std::string::npos &amp;&amp;
7896                  rhs.find(&#x27;\n&#x27;) == std::string::npos )
7897              os &lt;&lt; lhs &lt;&lt; &quot; &quot; &lt;&lt; op &lt;&lt; &quot; &quot; &lt;&lt; rhs;
7898          else
7899              os &lt;&lt; lhs &lt;&lt; &quot;\n&quot; &lt;&lt; op &lt;&lt; &quot;\n&quot; &lt;&lt; rhs;
7900      }
7901  }
7902  #include &lt;stdexcept&gt;
7903  namespace Catch {
7904  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
7905      [[noreturn]]
7906      void throw_exception(std::exception const&amp; e) {
7907          Catch::cerr() &lt;&lt; &quot;Catch will terminate because it needed to throw an exception.\n&quot;
7908                        &lt;&lt; &quot;The message was: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;
7909          std::terminate();
7910      }
7911  #endif
7912      [[noreturn]]
7913      void throw_logic_error(std::string const&amp; msg) {
7914          throw_exception(std::logic_error(msg));
7915      }
7916      [[noreturn]]
7917      void throw_domain_error(std::string const&amp; msg) {
7918          throw_exception(std::domain_error(msg));
7919      }
7920      [[noreturn]]
7921      void throw_runtime_error(std::string const&amp; msg) {
7922          throw_exception(std::runtime_error(msg));
7923      }
7924  } 
7925  #include &lt;vector&gt;
7926  #include &lt;memory&gt;
7927  namespace Catch {
7928      namespace Detail {
7929          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values );
7930          class EnumValuesRegistry : public IMutableEnumValuesRegistry {
7931              std::vector&lt;std::unique_ptr&lt;EnumInfo&gt;&gt; m_enumInfos;
7932              EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::vector&lt;int&gt; const&amp; values) override;
7933          };
7934          std::vector&lt;StringRef&gt; parseEnums( StringRef enums );
7935      } 
7936  } 
7937  #include &lt;map&gt;
7938  #include &lt;cassert&gt;
7939  namespace Catch {
7940      IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}
7941      namespace Detail {
7942          namespace {
7943              StringRef extractInstanceName(StringRef enumInstance) {
7944                  size_t name_start = enumInstance.size();
7945                  while (name_start &gt; 0 &amp;&amp; enumInstance[name_start - 1] != &#x27;:&#x27;) {
7946                      --name_start;
7947                  }
7948                  return enumInstance.substr(name_start, enumInstance.size() - name_start);
7949              }
7950          }
7951          std::vector&lt;StringRef&gt; parseEnums( StringRef enums ) {
7952              auto enumValues = splitStringRef( enums, &#x27;,&#x27; );
7953              std::vector&lt;StringRef&gt; parsed;
7954              parsed.reserve( enumValues.size() );
7955              for( auto const&amp; enumValue : enumValues ) {
7956                  parsed.push_back(trim(extractInstanceName(enumValue)));
7957              }
7958              return parsed;
7959          }
7960          EnumInfo::~EnumInfo() {}
7961          StringRef EnumInfo::lookup( int value ) const {
7962              for( auto const&amp; valueToName : m_values ) {
7963                  if( valueToName.first == value )
7964                      return valueToName.second;
7965              }
7966              return &quot;{** unexpected enum value **}&quot;_sr;
7967          }
7968          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7969              std::unique_ptr&lt;EnumInfo&gt; enumInfo( new EnumInfo );
7970              enumInfo-&gt;m_name = enumName;
7971              enumInfo-&gt;m_values.reserve( values.size() );
7972              const auto valueNames = Catch::Detail::parseEnums( allValueNames );
7973              assert( valueNames.size() == values.size() );
7974              std::size_t i = 0;
7975              for( auto value : values )
7976                  enumInfo-&gt;m_values.emplace_back(value, valueNames[i++]);
7977              return enumInfo;
7978          }
7979          EnumInfo const&amp; EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7980              m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
7981              return *m_enumInfos.back();
7982          }
7983      } 
7984  } 
7985  #include &lt;cerrno&gt;
7986  namespace Catch {
7987          ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
7988          ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
7989  }
7990  #include &lt;vector&gt;
7991  #include &lt;string&gt;
7992  #include &lt;memory&gt;
7993  namespace Catch {
7994      class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
7995      public:
7996          ~ExceptionTranslatorRegistry();
7997          virtual void registerTranslator( const IExceptionTranslator* translator );
7998          std::string translateActiveException() const override;
7999          std::string tryTranslators() const;
8000      private:
8001          std::vector&lt;std::unique_ptr&lt;IExceptionTranslator const&gt;&gt; m_translators;
8002      };
8003  }
8004  #ifdef __OBJC__
8005  #import &quot;Foundation/Foundation.h&quot;
8006  #endif
8007  namespace Catch {
8008      ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
8009      }
8010      void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
8011          m_translators.push_back( std::unique_ptr&lt;const IExceptionTranslator&gt;( translator ) );
8012      }
8013  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
8014      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8015          try {
8016  #ifdef __OBJC__
8017              @try {
8018                  return tryTranslators();
8019              }
8020              @catch (NSException *exception) {
8021                  return Catch::Detail::stringify( [exception description] );
8022              }
8023  #else
8024              if (std::current_exception() == nullptr) {
8025                  return &quot;Non C++ exception. Possibly a CLR exception.&quot;;
8026              }
8027              return tryTranslators();
8028  #endif
8029          }
8030          catch( TestFailureException&amp; ) {
8031              std::rethrow_exception(std::current_exception());
8032          }
8033          catch( std::exception&amp; ex ) {
8034              return ex.what();
8035          }
8036          catch( std::string&amp; msg ) {
8037              return msg;
8038          }
8039          catch( const char* msg ) {
8040              return msg;
8041          }
8042          catch(...) {
8043              return &quot;Unknown exception&quot;;
8044          }
8045      }
8046      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8047          if (m_translators.empty()) {
8048              std::rethrow_exception(std::current_exception());
8049          } else {
8050              return m_translators[0]-&gt;translate(m_translators.begin() + 1, m_translators.end());
8051          }
8052      }
8053  #else 
8054      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8055          CATCH_INTERNAL_ERROR(&quot;Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8056      }
8057      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8058          CATCH_INTERNAL_ERROR(&quot;Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8059      }
8060  #endif
8061  }
8062  #include &lt;algorithm&gt;
8063  #if !defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; !defined( CATCH_CONFIG_POSIX_SIGNALS )
8064  namespace Catch {
8065      void FatalConditionHandler::engage_platform() {}
8066      void FatalConditionHandler::disengage_platform() {}
8067      FatalConditionHandler::FatalConditionHandler() = default;
8068      FatalConditionHandler::~FatalConditionHandler() = default;
8069  } 
8070  #endif 
8071  #if defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; defined( CATCH_CONFIG_POSIX_SIGNALS )
8072  #error &quot;Inconsistent configuration: Windows&#x27; SEH handling and POSIX signals cannot be enabled at the same time&quot;
8073  #endif 
8074  #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
8075  namespace {
8076      void reportFatal( char const * const message ) {
8077          Catch::getCurrentContext().getResultCapture()-&gt;handleFatalErrorCondition( message );
8078      }
8079      constexpr std::size_t minStackSizeForErrors = 32 * 1024;
8080  } 
8081  #endif 
8082  #if defined( CATCH_CONFIG_WINDOWS_SEH )
8083  namespace Catch {
8084      struct SignalDefs { DWORD id; const char* name; };
8085      static SignalDefs signalDefs[] = {
8086          { static_cast&lt;DWORD&gt;(EXCEPTION_ILLEGAL_INSTRUCTION),  &quot;SIGILL - Illegal instruction signal&quot; },
8087          { static_cast&lt;DWORD&gt;(EXCEPTION_STACK_OVERFLOW), &quot;SIGSEGV - Stack overflow&quot; },
8088          { static_cast&lt;DWORD&gt;(EXCEPTION_ACCESS_VIOLATION), &quot;SIGSEGV - Segmentation violation signal&quot; },
8089          { static_cast&lt;DWORD&gt;(EXCEPTION_INT_DIVIDE_BY_ZERO), &quot;Divide by zero error&quot; },
8090      };
8091      static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
8092          for (auto const&amp; def : signalDefs) {
8093              if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == def.id) {
8094                  reportFatal(def.name);
8095              }
8096          }
8097          return EXCEPTION_CONTINUE_SEARCH;
8098      }
8099      static PVOID exceptionHandlerHandle = nullptr;
8100      FatalConditionHandler::FatalConditionHandler() {
8101          ULONG guaranteeSize = static_cast&lt;ULONG&gt;(minStackSizeForErrors);
8102          if (!SetThreadStackGuarantee(&amp;guaranteeSize)) {
8103              Catch::cerr()
8104                  &lt;&lt; &quot;Failed to reserve piece of stack.&quot;
8105                  &lt;&lt; &quot; Stack overflows will not be reported successfully.&quot;;
8106          }
8107      }
8108      FatalConditionHandler::~FatalConditionHandler() = default;
8109      void FatalConditionHandler::engage_platform() {
8110          exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
8111          if (!exceptionHandlerHandle) {
8112              CATCH_RUNTIME_ERROR(&quot;Could not register vectored exception handler&quot;);
8113          }
8114      }
8115      void FatalConditionHandler::disengage_platform() {
8116          if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {
8117              CATCH_RUNTIME_ERROR(&quot;Could not unregister vectored exception handler&quot;);
8118          }
8119          exceptionHandlerHandle = nullptr;
8120      }
8121  } 
8122  #endif 
8123  #if defined( CATCH_CONFIG_POSIX_SIGNALS )
8124  #include &lt;signal.h&gt;
8125  namespace Catch {
8126      struct SignalDefs {
8127          int id;
8128          const char* name;
8129      };
8130      static SignalDefs signalDefs[] = {
8131          { SIGINT,  &quot;SIGINT - Terminal interrupt signal&quot; },
8132          { SIGILL,  &quot;SIGILL - Illegal instruction signal&quot; },
8133          { SIGFPE,  &quot;SIGFPE - Floating point error signal&quot; },
8134          { SIGSEGV, &quot;SIGSEGV - Segmentation violation signal&quot; },
8135          { SIGTERM, &quot;SIGTERM - Termination request signal&quot; },
8136          { SIGABRT, &quot;SIGABRT - Abort (abnormal termination) signal&quot; }
8137      };
8138  #if defined(__GNUC__)
8139  #    pragma GCC diagnostic push
8140  #    pragma GCC diagnostic ignored &quot;-Wmissing-field-initializers&quot;
8141  #endif
8142      static char* altStackMem = nullptr;
8143      static std::size_t altStackSize = 0;
8144      static stack_t oldSigStack{};
8145      static struct sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]{};
8146      static void restorePreviousSignalHandlers() {
8147          for (std::size_t i = 0; i &lt; sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
8148              sigaction(signalDefs[i].id, &amp;oldSigActions[i], nullptr);
8149          }
8150          sigaltstack(&amp;oldSigStack, nullptr);
8151      }
8152      static void handleSignal( int sig ) {
8153          char const * name = &quot;&lt;unknown signal&gt;&quot;;
8154          for (auto const&amp; def : signalDefs) {
8155              if (sig == def.id) {
8156                  name = def.name;
8157                  break;
8158              }
8159          }
8160          restorePreviousSignalHandlers();
8161          reportFatal( name );
8162          raise( sig );
8163      }
8164      FatalConditionHandler::FatalConditionHandler() {
8165          assert(!altStackMem &amp;&amp; &quot;Cannot initialize POSIX signal handler when one already exists&quot;);
8166          if (altStackSize == 0) {
8167              altStackSize = std::max(static_cast&lt;size_t&gt;(SIGSTKSZ), minStackSizeForErrors);
8168          }
8169          altStackMem = new char[altStackSize]();
8170      }
8171      FatalConditionHandler::~FatalConditionHandler() {
8172          delete[] altStackMem;
8173          altStackMem = nullptr;
8174      }
8175      void FatalConditionHandler::engage_platform() {
8176          stack_t sigStack;
8177          sigStack.ss_sp = altStackMem;
8178          sigStack.ss_size = altStackSize;
8179          sigStack.ss_flags = 0;
8180          sigaltstack(&amp;sigStack, &amp;oldSigStack);
8181          struct sigaction sa = { };
8182          sa.sa_handler = handleSignal;
8183          sa.sa_flags = SA_ONSTACK;
8184          for (std::size_t i = 0; i &lt; sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
8185              sigaction(signalDefs[i].id, &amp;sa, &amp;oldSigActions[i]);
8186          }
8187      }
8188  #if defined(__GNUC__)
8189  #    pragma GCC diagnostic pop
8190  #endif
8191      void FatalConditionHandler::disengage_platform() {
8192          restorePreviousSignalHandlers();
8193      }
8194  } 
8195  #endif 
8196  #include &lt;limits&gt;
8197  #include &lt;set&gt;
8198  namespace Catch {
8199  IGeneratorTracker::~IGeneratorTracker() {}
8200  const char* GeneratorException::what() const noexcept {
8201      return m_msg;
8202  }
8203  namespace Generators {
8204      GeneratorUntypedBase::~GeneratorUntypedBase() {}
8205      auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
8206          return getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );
8207      }
8208  } 
8209  } 
8210  namespace Catch {
8211      IResultCapture::~IResultCapture() = default;
8212  }
8213  namespace Catch {
8214      IConfig::~IConfig() = default;
8215  }
8216  namespace Catch {
8217      IExceptionTranslator::~IExceptionTranslator() = default;
8218      IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
8219  }
8220  namespace Catch {
8221      IRegistryHub::~IRegistryHub() = default;
8222      IMutableRegistryHub::~IMutableRegistryHub() = default;
8223  }
8224  namespace Catch {
8225      class ListeningReporter : public IStreamingReporter {
8226          using Reporters = std::vector&lt;IStreamingReporterPtr&gt;;
8227          Reporters m_listeners;
8228          IStreamingReporterPtr m_reporter = nullptr;
8229          ReporterPreferences m_preferences;
8230      public:
8231          ListeningReporter();
8232          void addListener( IStreamingReporterPtr&amp;&amp; listener );
8233          void addReporter( IStreamingReporterPtr&amp;&amp; reporter );
8234      public: 
8235          ReporterPreferences getPreferences() const override;
8236          void noMatchingTestCases( std::string const&amp; spec ) override;
8237          void reportInvalidArguments(std::string const&amp;arg) override;
8238          static std::set&lt;Verbosity&gt; getSupportedVerbosities();
8239  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
8240          void benchmarkPreparing(std::string const&amp; name) override;
8241          void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;
8242          void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;
8243          void benchmarkFailed(std::string const&amp;) override;
8244  #endif 
8245          void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;
8246          void testGroupStarting( GroupInfo const&amp; groupInfo ) override;
8247          void testCaseStarting( TestCaseInfo const&amp; testInfo ) override;
8248          void sectionStarting( SectionInfo const&amp; sectionInfo ) override;
8249          void assertionStarting( AssertionInfo const&amp; assertionInfo ) override;
8250          bool assertionEnded( AssertionStats const&amp; assertionStats ) override;
8251          void sectionEnded( SectionStats const&amp; sectionStats ) override;
8252          void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;
8253          void testGroupEnded( TestGroupStats const&amp; testGroupStats ) override;
8254          void testRunEnded( TestRunStats const&amp; testRunStats ) override;
8255          void skipTest( TestCaseInfo const&amp; testInfo ) override;
8256          bool isMulti() const override;
8257      };
8258  } 
8259  namespace Catch {
8260      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig )
8261      :   m_stream( &amp;_fullConfig-&gt;stream() ), m_fullConfig( _fullConfig ) {}
8262      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig, std::ostream&amp; _stream )
8263      :   m_stream( &amp;_stream ), m_fullConfig( _fullConfig ) {}
8264      std::ostream&amp; ReporterConfig::stream() const { return *m_stream; }
8265      IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
8266      TestRunInfo::TestRunInfo( std::string const&amp; _name ) : name( _name ) {}
8267      GroupInfo::GroupInfo(  std::string const&amp; _name,
8268                             std::size_t _groupIndex,
8269                             std::size_t _groupsCount )
8270      :   name( _name ),
8271          groupIndex( _groupIndex ),
8272          groupsCounts( _groupsCount )
8273      {}
8274       AssertionStats::AssertionStats( AssertionResult const&amp; _assertionResult,
8275                                       std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,
8276                                       Totals const&amp; _totals )
8277      :   assertionResult( _assertionResult ),
8278          infoMessages( _infoMessages ),
8279          totals( _totals )
8280      {
8281          assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
8282          if( assertionResult.hasMessage() ) {
8283              MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
8284              builder &lt;&lt; assertionResult.getMessage();
8285              builder.m_info.message = builder.m_stream.str();
8286              infoMessages.push_back( builder.m_info );
8287          }
8288      }
8289       AssertionStats::~AssertionStats() = default;
8290      SectionStats::SectionStats(  SectionInfo const&amp; _sectionInfo,
8291                                   Counts const&amp; _assertions,
8292                                   double _durationInSeconds,
8293                                   bool _missingAssertions )
8294      :   sectionInfo( _sectionInfo ),
8295          assertions( _assertions ),
8296          durationInSeconds( _durationInSeconds ),
8297          missingAssertions( _missingAssertions )
8298      {}
8299      SectionStats::~SectionStats() = default;
8300      TestCaseStats::TestCaseStats(  TestCaseInfo const&amp; _testInfo,
8301                                     Totals const&amp; _totals,
8302                                     std::string const&amp; _stdOut,
8303                                     std::string const&amp; _stdErr,
8304                                     bool _aborting )
8305      : testInfo( _testInfo ),
8306          totals( _totals ),
8307          stdOut( _stdOut ),
8308          stdErr( _stdErr ),
8309          aborting( _aborting )
8310      {}
8311      TestCaseStats::~TestCaseStats() = default;
8312      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo,
8313                                      Totals const&amp; _totals,
8314                                      bool _aborting )
8315      :   groupInfo( _groupInfo ),
8316          totals( _totals ),
8317          aborting( _aborting )
8318      {}
8319      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo )
8320      :   groupInfo( _groupInfo ),
8321          aborting( false )
8322      {}
8323      TestGroupStats::~TestGroupStats() = default;
8324      TestRunStats::TestRunStats(   TestRunInfo const&amp; _runInfo,
8325                      Totals const&amp; _totals,
8326                      bool _aborting )
8327      :   runInfo( _runInfo ),
8328          totals( _totals ),
8329          aborting( _aborting )
8330      {}
8331      TestRunStats::~TestRunStats() = default;
8332      void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
8333      bool IStreamingReporter::isMulti() const { return false; }
8334      IReporterFactory::~IReporterFactory() = default;
8335      IReporterRegistry::~IReporterRegistry() = default;
8336  } 
8337  namespace Catch {
8338      IRunner::~IRunner() = default;
8339  }
8340  namespace Catch {
8341      ITestInvoker::~ITestInvoker() = default;
8342      ITestCaseRegistry::~ITestCaseRegistry() = default;
8343  }
8344  #ifdef CATCH_CONFIG_WINDOWS_CRTDBG
8345  #include &lt;crtdbg.h&gt;
8346  namespace Catch {
8347      LeakDetector::LeakDetector() {
8348          int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
8349          flag |= _CRTDBG_LEAK_CHECK_DF;
8350          flag |= _CRTDBG_ALLOC_MEM_DF;
8351          _CrtSetDbgFlag(flag);
8352          _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
8353          _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
8354          _CrtSetBreakAlloc(-1);
8355      }
8356  }
8357  #else
8358      Catch::LeakDetector::LeakDetector() {}
8359  #endif
8360  Catch::LeakDetector::~LeakDetector() {
8361      Catch::cleanUp();
8362  }
8363  #include &lt;set&gt;
8364  namespace Catch {
8365      std::size_t listTests( Config const&amp; config );
8366      std::size_t listTestsNamesOnly( Config const&amp; config );
8367      struct TagInfo {
8368          void add( std::string const&amp; spelling );
8369          std::string all() const;
8370          std::set&lt;std::string&gt; spellings;
8371          std::size_t count = 0;
8372      };
8373      std::size_t listTags( Config const&amp; config );
8374      std::size_t listReporters();
8375      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config );
8376  } 
8377  namespace Catch {
8378      using namespace clara::TextFlow;
8379  }
8380  #include &lt;limits&gt;
8381  #include &lt;algorithm&gt;
8382  #include &lt;iomanip&gt;
8383  namespace Catch {
8384      std::size_t listTests( Config const&amp; config ) {
8385          TestSpec const&amp; testSpec = config.testSpec();
8386          if( config.hasTestFilters() )
8387              Catch::cout() &lt;&lt; &quot;Matching test cases:\n&quot;;
8388          else {
8389              Catch::cout() &lt;&lt; &quot;All available test cases:\n&quot;;
8390          }
8391          auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8392          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8393              Colour::Code colour = testCaseInfo.isHidden()
8394                  ? Colour::SecondaryText
8395                  : Colour::None;
8396              Colour colourGuard( colour );
8397              Catch::cout() &lt;&lt; Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) &lt;&lt; &quot;\n&quot;;
8398              if( config.verbosity() &gt;= Verbosity::High ) {
8399                  Catch::cout() &lt;&lt; Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) &lt;&lt; std::endl;
8400                  std::string description = testCaseInfo.description;
8401                  if( description.empty() )
8402                      description = &quot;(NO DESCRIPTION)&quot;;
8403                  Catch::cout() &lt;&lt; Column( description ).indent(4) &lt;&lt; std::endl;
8404              }
8405              if( !testCaseInfo.tags.empty() )
8406                  Catch::cout() &lt;&lt; Column( testCaseInfo.tagsAsString() ).indent( 6 ) &lt;&lt; &quot;\n&quot;;
8407          }
8408          if( !config.hasTestFilters() )
8409              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8410          else
8411              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;matching test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8412          return matchedTestCases.size();
8413      }
8414      std::size_t listTestsNamesOnly( Config const&amp; config ) {
8415          TestSpec const&amp; testSpec = config.testSpec();
8416          std::size_t matchedTests = 0;
8417          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8418          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8419              matchedTests++;
8420              if( startsWith( testCaseInfo.name, &#x27;#&#x27; ) )
8421                 Catch::cout() &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; testCaseInfo.name &lt;&lt; &#x27;&quot;&#x27;;
8422              else
8423                 Catch::cout() &lt;&lt; testCaseInfo.name;
8424              if ( config.verbosity() &gt;= Verbosity::High )
8425                  Catch::cout() &lt;&lt; &quot;\t@&quot; &lt;&lt; testCaseInfo.lineInfo;
8426              Catch::cout() &lt;&lt; std::endl;
8427          }
8428          return matchedTests;
8429      }
8430      void TagInfo::add( std::string const&amp; spelling ) {
8431          ++count;
8432          spellings.insert( spelling );
8433      }
8434      std::string TagInfo::all() const {
8435          size_t size = 0;
8436          for (auto const&amp; spelling : spellings) {
8437              size += spelling.size() + 2;
8438          }
8439          std::string out; out.reserve(size);
8440          for (auto const&amp; spelling : spellings) {
8441              out += &#x27;[&#x27;;
8442              out += spelling;
8443              out += &#x27;]&#x27;;
8444          }
8445          return out;
8446      }
8447      std::size_t listTags( Config const&amp; config ) {
8448          TestSpec const&amp; testSpec = config.testSpec();
8449          if( config.hasTestFilters() )
8450              Catch::cout() &lt;&lt; &quot;Tags for matching test cases:\n&quot;;
8451          else {
8452              Catch::cout() &lt;&lt; &quot;All available tags:\n&quot;;
8453          }
8454          std::map&lt;std::string, TagInfo&gt; tagCounts;
8455          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8456          for( auto const&amp; testCase : matchedTestCases ) {
8457              for( auto const&amp; tagName : testCase.getTestCaseInfo().tags ) {
8458                  std::string lcaseTagName = toLower( tagName );
8459                  auto countIt = tagCounts.find( lcaseTagName );
8460                  if( countIt == tagCounts.end() )
8461                      countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
8462                  countIt-&gt;second.add( tagName );
8463              }
8464          }
8465          for( auto const&amp; tagCount : tagCounts ) {
8466              ReusableStringStream rss;
8467              rss &lt;&lt; &quot;  &quot; &lt;&lt; std::setw(2) &lt;&lt; tagCount.second.count &lt;&lt; &quot;  &quot;;
8468              auto str = rss.str();
8469              auto wrapper = Column( tagCount.second.all() )
8470                                                      .initialIndent( 0 )
8471                                                      .indent( str.size() )
8472                                                      .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
8473              Catch::cout() &lt;&lt; str &lt;&lt; wrapper &lt;&lt; &#x27;\n&#x27;;
8474          }
8475          Catch::cout() &lt;&lt; pluralise( tagCounts.size(), &quot;tag&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8476          return tagCounts.size();
8477      }
8478      std::size_t listReporters() {
8479          Catch::cout() &lt;&lt; &quot;Available reporters:\n&quot;;
8480          IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
8481          std::size_t maxNameLen = 0;
8482          for( auto const&amp; factoryKvp : factories )
8483              maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
8484          for( auto const&amp; factoryKvp : factories ) {
8485              Catch::cout()
8486                      &lt;&lt; Column( factoryKvp.first + &quot;:&quot; )
8487                              .indent(2)
8488                              .width( 5+maxNameLen )
8489                      +  Column( factoryKvp.second-&gt;getDescription() )
8490                              .initialIndent(0)
8491                              .indent(2)
8492                              .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
8493                      &lt;&lt; &quot;\n&quot;;
8494          }
8495          Catch::cout() &lt;&lt; std::endl;
8496          return factories.size();
8497      }
8498      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config ) {
8499          Option&lt;std::size_t&gt; listedCount;
8500          getCurrentMutableContext().setConfig( config );
8501          if( config-&gt;listTests() )
8502              listedCount = listedCount.valueOr(0) + listTests( *config );
8503          if( config-&gt;listTestNamesOnly() )
8504              listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );
8505          if( config-&gt;listTags() )
8506              listedCount = listedCount.valueOr(0) + listTags( *config );
8507          if( config-&gt;listReporters() )
8508              listedCount = listedCount.valueOr(0) + listReporters();
8509          return listedCount;
8510      }
8511  } 
8512  namespace Catch {
8513  namespace Matchers {
8514      namespace Impl {
8515          std::string MatcherUntypedBase::toString() const {
8516              if( m_cachedToString.empty() )
8517                  m_cachedToString = describe();
8518              return m_cachedToString;
8519          }
8520          MatcherUntypedBase::~MatcherUntypedBase() = default;
8521      } 
8522  } 
8523  using namespace Matchers;
8524  using Matchers::Impl::MatcherBase;
8525  } 
8526  namespace Catch {
8527  namespace Matchers {
8528  namespace Exception {
8529  bool ExceptionMessageMatcher::match(std::exception const&amp; ex) const {
8530      return ex.what() == m_message;
8531  }
8532  std::string ExceptionMessageMatcher::describe() const {
8533      return &quot;exception message matches \&quot;&quot; + m_message + &quot;\&quot;&quot;;
8534  }
8535  }
8536  Exception::ExceptionMessageMatcher Message(std::string const&amp; message) {
8537      return Exception::ExceptionMessageMatcher(message);
8538  }
8539  } 
8540  } 
8541  namespace Catch {
8542      bool isnan(float f);
8543      bool isnan(double d);
8544  }
8545  #include &lt;string&gt;
8546  namespace Catch {
8547      template &lt;typename T&gt;
8548      std::string to_string(T const&amp; t) {
8549  #if defined(CATCH_CONFIG_CPP11_TO_STRING)
8550          return std::to_string(t);
8551  #else
8552          ReusableStringStream rss;
8553          rss &lt;&lt; t;
8554          return rss.str();
8555  #endif
8556      }
8557  } 
8558  #include &lt;algorithm&gt;
8559  #include &lt;cmath&gt;
8560  #include &lt;cstdlib&gt;
8561  #include &lt;cstdint&gt;
8562  #include &lt;cstring&gt;
8563  #include &lt;sstream&gt;
8564  #include &lt;type_traits&gt;
8565  #include &lt;iomanip&gt;
8566  #include &lt;limits&gt;
8567  namespace Catch {
8568  namespace {
8569      int32_t convert(float f) {
8570          static_assert(sizeof(float) == sizeof(int32_t), &quot;Important ULP matcher assumption violated&quot;);
8571          int32_t i;
8572          std::memcpy(&amp;i, &amp;f, sizeof(f));
8573          return i;
8574      }
8575      int64_t convert(double d) {
8576          static_assert(sizeof(double) == sizeof(int64_t), &quot;Important ULP matcher assumption violated&quot;);
8577          int64_t i;
8578          std::memcpy(&amp;i, &amp;d, sizeof(d));
8579          return i;
8580      }
8581      template &lt;typename FP&gt;
8582      bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
8583          if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
8584              return false;
8585          }
8586          auto lc = convert(lhs);
8587          auto rc = convert(rhs);
8588          if ((lc &lt; 0) != (rc &lt; 0)) {
8589              return lhs == rhs;
8590          }
8591          auto ulpDiff = std::abs(static_cast&lt;FP&gt;(lc - rc));
8592          return static_cast&lt;uint64_t&gt;(ulpDiff) &lt;= maxUlpDiff;
8593      }
8594  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8595      float nextafter(float x, float y) {
8596          return ::nextafterf(x, y);
8597      }
8598      double nextafter(double x, double y) {
8599          return ::nextafter(x, y);
8600      }
8601  #endif 
8602  template &lt;typename FP&gt;
8603  FP step(FP start, FP direction, uint64_t steps) {
8604      for (uint64_t i = 0; i &lt; steps; ++i) {
8605  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8606          start = Catch::nextafter(start, direction);
8607  #else
8608          start = std::nextafter(start, direction);
8609  #endif
8610      }
8611      return start;
8612  }
8613  bool marginComparison(double lhs, double rhs, double margin) {
8614      return (lhs + margin &gt;= rhs) &amp;&amp; (rhs + margin &gt;= lhs);
8615  }
8616  template &lt;typename FloatingPoint&gt;
8617  void write(std::ostream&amp; out, FloatingPoint num) {
8618      out &lt;&lt; std::scientific
8619          &lt;&lt; std::setprecision(std::numeric_limits&lt;FloatingPoint&gt;::max_digits10 - 1)
8620          &lt;&lt; num;
8621  }
8622  } 
8623  namespace Matchers {
8624  namespace Floating {
8625      enum class FloatingPointKind : uint8_t {
8626          Float,
8627          Double
8628      };
8629      WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
8630          :m_target{ target }, m_margin{ margin } {
8631          CATCH_ENFORCE(margin &gt;= 0, &quot;Invalid margin: &quot; &lt;&lt; margin &lt;&lt; &#x27;.&#x27;
8632              &lt;&lt; &quot; Margin has to be non-negative.&quot;);
8633      }
8634      bool WithinAbsMatcher::match(double const&amp; matchee) const {
8635          return (matchee + m_margin &gt;= m_target) &amp;&amp; (m_target + m_margin &gt;= matchee);
8636      }
8637      std::string WithinAbsMatcher::describe() const {
8638          return &quot;is within &quot; + ::Catch::Detail::stringify(m_margin) + &quot; of &quot; + ::Catch::Detail::stringify(m_target);
8639      }
8640      WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType)
8641          :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
8642          CATCH_ENFORCE(m_type == FloatingPointKind::Double
8643                     || m_ulps &lt; (std::numeric_limits&lt;uint32_t&gt;::max)(),
8644              &quot;Provided ULP is impossibly large for a float comparison.&quot;);
8645      }
8646  #if defined(__clang__)
8647  #pragma clang diagnostic push
8648  #pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;
8649  #endif
8650      bool WithinUlpsMatcher::match(double const&amp; matchee) const {
8651          switch (m_type) {
8652          case FloatingPointKind::Float:
8653              return almostEqualUlps&lt;float&gt;(static_cast&lt;float&gt;(matchee), static_cast&lt;float&gt;(m_target), m_ulps);
8654          case FloatingPointKind::Double:
8655              return almostEqualUlps&lt;double&gt;(matchee, m_target, m_ulps);
8656          default:
8657              CATCH_INTERNAL_ERROR( &quot;Unknown FloatingPointKind value&quot; );
8658          }
8659      }
8660  #if defined(__clang__)
8661  #pragma clang diagnostic pop
8662  #endif
8663      std::string WithinUlpsMatcher::describe() const {
8664          std::stringstream ret;
8665          ret &lt;&lt; &quot;is within &quot; &lt;&lt; m_ulps &lt;&lt; &quot; ULPs of &quot;;
8666          if (m_type == FloatingPointKind::Float) {
8667              write(ret, static_cast&lt;float&gt;(m_target));
8668              ret &lt;&lt; &#x27;f&#x27;;
8669          } else {
8670              write(ret, m_target);
8671          }
8672          ret &lt;&lt; &quot; ([&quot;;
8673          if (m_type == FloatingPointKind::Double) {
8674              write(ret, step(m_target, static_cast&lt;double&gt;(-INFINITY), m_ulps));
8675              ret &lt;&lt; &quot;, &quot;;
8676              write(ret, step(m_target, static_cast&lt;double&gt;( INFINITY), m_ulps));
8677          } else {
8678              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;(-INFINITY), m_ulps));
8679              ret &lt;&lt; &quot;, &quot;;
8680              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;( INFINITY), m_ulps));
8681          }
8682          ret &lt;&lt; &quot;])&quot;;
8683          return ret.str();
8684      }
8685      WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
8686          m_target(target),
8687          m_epsilon(epsilon){
8688          CATCH_ENFORCE(m_epsilon &gt;= 0., &quot;Relative comparison with epsilon &lt;  0 does not make sense.&quot;);
8689          CATCH_ENFORCE(m_epsilon  &lt; 1., &quot;Relative comparison with epsilon &gt;= 1 does not make sense.&quot;);
8690      }
8691      bool WithinRelMatcher::match(double const&amp; matchee) const {
8692          const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
8693          return marginComparison(matchee, m_target,
8694                                  std::isinf(relMargin)? 0 : relMargin);
8695      }
8696      std::string WithinRelMatcher::describe() const {
8697          Catch::ReusableStringStream sstr;
8698          sstr &lt;&lt; &quot;and &quot; &lt;&lt; m_target &lt;&lt; &quot; are within &quot; &lt;&lt; m_epsilon * 100. &lt;&lt; &quot;% of each other&quot;;
8699          return sstr.str();
8700      }
8701  }
8702  Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
8703      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
8704  }
8705  Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
8706      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
8707  }
8708  Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
8709      return Floating::WithinAbsMatcher(target, margin);
8710  }
8711  Floating::WithinRelMatcher WithinRel(double target, double eps) {
8712      return Floating::WithinRelMatcher(target, eps);
8713  }
8714  Floating::WithinRelMatcher WithinRel(double target) {
8715      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;double&gt;::epsilon() * 100);
8716  }
8717  Floating::WithinRelMatcher WithinRel(float target, float eps) {
8718      return Floating::WithinRelMatcher(target, eps);
8719  }
8720  Floating::WithinRelMatcher WithinRel(float target) {
8721      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;float&gt;::epsilon() * 100);
8722  }
8723  } 
8724  } 
8725  std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string&amp; desc) {
8726      if (desc.empty()) {
8727          return &quot;matches undescribed predicate&quot;;
8728      } else {
8729          return &quot;matches predicate: \&quot;&quot; + desc + &#x27;&quot;&#x27;;
8730      }
8731  }
8732  #include &lt;regex&gt;
8733  namespace Catch {
8734  namespace Matchers {
8735      namespace StdString {
8736          CasedString::CasedString( std::string const&amp; str, CaseSensitive::Choice caseSensitivity )
8737          :   m_caseSensitivity( caseSensitivity ),
8738              m_str( adjustString( str ) )
8739          {}
8740          std::string CasedString::adjustString( std::string const&amp; str ) const {
8741              return m_caseSensitivity == CaseSensitive::No
8742                     ? toLower( str )
8743                     : str;
8744          }
8745          std::string CasedString::caseSensitivitySuffix() const {
8746              return m_caseSensitivity == CaseSensitive::No
8747                     ? &quot; (case insensitive)&quot;
8748                     : std::string();
8749          }
8750          StringMatcherBase::StringMatcherBase( std::string const&amp; operation, CasedString const&amp; comparator )
8751          : m_comparator( comparator ),
8752            m_operation( operation ) {
8753          }
8754          std::string StringMatcherBase::describe() const {
8755              std::string description;
8756              description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
8757                                          m_comparator.caseSensitivitySuffix().size());
8758              description += m_operation;
8759              description += &quot;: \&quot;&quot;;
8760              description += m_comparator.m_str;
8761              description += &quot;\&quot;&quot;;
8762              description += m_comparator.caseSensitivitySuffix();
8763              return description;
8764          }
8765          EqualsMatcher::EqualsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;equals&quot;, comparator ) {}
8766          bool EqualsMatcher::match( std::string const&amp; source ) const {
8767              return m_comparator.adjustString( source ) == m_comparator.m_str;
8768          }
8769          ContainsMatcher::ContainsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;contains&quot;, comparator ) {}
8770          bool ContainsMatcher::match( std::string const&amp; source ) const {
8771              return contains( m_comparator.adjustString( source ), m_comparator.m_str );
8772          }
8773          StartsWithMatcher::StartsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;starts with&quot;, comparator ) {}
8774          bool StartsWithMatcher::match( std::string const&amp; source ) const {
8775              return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8776          }
8777          EndsWithMatcher::EndsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;ends with&quot;, comparator ) {}
8778          bool EndsWithMatcher::match( std::string const&amp; source ) const {
8779              return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8780          }
8781          RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
8782          bool RegexMatcher::match(std::string const&amp; matchee) const {
8783              auto flags = std::regex::ECMAScript; 
8784              if (m_caseSensitivity == CaseSensitive::Choice::No) {
8785                  flags |= std::regex::icase;
8786              }
8787              auto reg = std::regex(m_regex, flags);
8788              return std::regex_match(matchee, reg);
8789          }
8790          std::string RegexMatcher::describe() const {
8791              return &quot;matches &quot; + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? &quot; case sensitively&quot; : &quot; case insensitively&quot;);
8792          }
8793      } 
8794      StdString::EqualsMatcher Equals( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8795          return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
8796      }
8797      StdString::ContainsMatcher Contains( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8798          return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
8799      }
8800      StdString::EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8801          return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8802      }
8803      StdString::StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8804          return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8805      }
8806      StdString::RegexMatcher Matches(std::string const&amp; regex, CaseSensitive::Choice caseSensitivity) {
8807          return StdString::RegexMatcher(regex, caseSensitivity);
8808      }
8809  } 
8810  } 
8811  namespace Catch {
8812      bool uncaught_exceptions();
8813  } 
8814  #include &lt;cassert&gt;
8815  #include &lt;stack&gt;
8816  namespace Catch {
8817      MessageInfo::MessageInfo(   StringRef const&amp; _macroName,
8818                                  SourceLineInfo const&amp; _lineInfo,
8819                                  ResultWas::OfType _type )
8820      :   macroName( _macroName ),
8821          lineInfo( _lineInfo ),
8822          type( _type ),
8823          sequence( ++globalCount )
8824      {}
8825      bool MessageInfo::operator==( MessageInfo const&amp; other ) const {
8826          return sequence == other.sequence;
8827      }
8828      bool MessageInfo::operator&lt;( MessageInfo const&amp; other ) const {
8829          return sequence &lt; other.sequence;
8830      }
8831      unsigned int MessageInfo::globalCount = 0;
8832      Catch::MessageBuilder::MessageBuilder( StringRef const&amp; macroName,
8833                                             SourceLineInfo const&amp; lineInfo,
8834                                             ResultWas::OfType type )
8835          :m_info(macroName, lineInfo, type) {}
8836      ScopedMessage::ScopedMessage( MessageBuilder const&amp; builder )
8837      : m_info( builder.m_info ), m_moved()
8838      {
8839          m_info.message = builder.m_stream.str();
8840          getResultCapture().pushScopedMessage( m_info );
8841      }
8842      ScopedMessage::ScopedMessage( ScopedMessage&amp;&amp; old )
8843      : m_info( old.m_info ), m_moved()
8844      {
8845          old.m_moved = true;
8846      }
8847      ScopedMessage::~ScopedMessage() {
8848          if ( !uncaught_exceptions() &amp;&amp; !m_moved ){
8849              getResultCapture().popScopedMessage(m_info);
8850          }
8851      }
8852      Capturer::Capturer( StringRef macroName, SourceLineInfo const&amp; lineInfo, ResultWas::OfType resultType, StringRef names ) {
8853          auto trimmed = [&amp;] (size_t start, size_t end) {
8854              while (names[start] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[start]))) {
8855                  ++start;
8856              }
8857              while (names[end] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[end]))) {
8858                  --end;
8859              }
8860              return names.substr(start, end - start + 1);
8861          };
8862          auto skipq = [&amp;] (size_t start, char quote) {
8863              for (auto i = start + 1; i &lt; names.size() ; ++i) {
8864                  if (names[i] == quote)
8865                      return i;
8866                  if (names[i] == &#x27;\\&#x27;)
8867                      ++i;
8868              }
8869              CATCH_INTERNAL_ERROR(&quot;CAPTURE parsing encountered unmatched quote&quot;);
8870          };
8871          size_t start = 0;
8872          std::stack&lt;char&gt; openings;
8873          for (size_t pos = 0; pos &lt; names.size(); ++pos) {
8874              char c = names[pos];
8875              switch (c) {
8876              case &#x27;[&#x27;:
8877              case &#x27;{&#x27;:
8878              case &#x27;(&#x27;:
8879                  openings.push(c);
8880                  break;
8881              case &#x27;]&#x27;:
8882              case &#x27;}&#x27;:
8883              case &#x27;)&#x27;:
8884                  openings.pop();
8885                  break;
8886              case &#x27;&quot;&#x27;:
8887              case &#x27;\&#x27;&#x27;:
8888                  pos = skipq(pos, c);
8889                  break;
8890              case &#x27;,&#x27;:
8891                  if (start != pos &amp;&amp; openings.empty()) {
8892                      m_messages.emplace_back(macroName, lineInfo, resultType);
8893                      m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, pos));
8894                      m_messages.back().message += &quot; := &quot;;
8895                      start = pos;
8896                  }
8897              }
8898          }
8899          assert(openings.empty() &amp;&amp; &quot;Mismatched openings&quot;);
8900          m_messages.emplace_back(macroName, lineInfo, resultType);
8901          m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, names.size() - 1));
8902          m_messages.back().message += &quot; := &quot;;
8903      }
8904      Capturer::~Capturer() {
8905          if ( !uncaught_exceptions() ){
8906              assert( m_captured == m_messages.size() );
8907              for( size_t i = 0; i &lt; m_captured; ++i  )
8908                  m_resultCapture.popScopedMessage( m_messages[i] );
8909          }
8910      }
8911      void Capturer::captureValue( size_t index, std::string const&amp; value ) {
8912          assert( index &lt; m_messages.size() );
8913          m_messages[index].message += value;
8914          m_resultCapture.pushScopedMessage( m_messages[index] );
8915          m_captured++;
8916      }
8917  } 
8918  #ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8919  #define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8920  #include &lt;cstdio&gt;
8921  #include &lt;iosfwd&gt;
8922  #include &lt;string&gt;
8923  namespace Catch {
8924      class RedirectedStream {
8925          std::ostream&amp; m_originalStream;
8926          std::ostream&amp; m_redirectionStream;
8927          std::streambuf* m_prevBuf;
8928      public:
8929          RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream );
8930          ~RedirectedStream();
8931      };
8932      class RedirectedStdOut {
8933          ReusableStringStream m_rss;
8934          RedirectedStream m_cout;
8935      public:
8936          RedirectedStdOut();
8937          auto str() const -&gt; std::string;
8938      };
8939      class RedirectedStdErr {
8940          ReusableStringStream m_rss;
8941          RedirectedStream m_cerr;
8942          RedirectedStream m_clog;
8943      public:
8944          RedirectedStdErr();
8945          auto str() const -&gt; std::string;
8946      };
8947      class RedirectedStreams {
8948      public:
8949          RedirectedStreams(RedirectedStreams const&amp;) = delete;
8950          RedirectedStreams&amp; operator=(RedirectedStreams const&amp;) = delete;
8951          RedirectedStreams(RedirectedStreams&amp;&amp;) = delete;
8952          RedirectedStreams&amp; operator=(RedirectedStreams&amp;&amp;) = delete;
8953          RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr);
8954          ~RedirectedStreams();
8955      private:
8956          std::string&amp; m_redirectedCout;
8957          std::string&amp; m_redirectedCerr;
8958          RedirectedStdOut m_redirectedStdOut;
8959          RedirectedStdErr m_redirectedStdErr;
8960      };
8961  #if defined(CATCH_CONFIG_NEW_CAPTURE)
8962      class TempFile {
8963      public:
8964          TempFile(TempFile const&amp;) = delete;
8965          TempFile&amp; operator=(TempFile const&amp;) = delete;
8966          TempFile(TempFile&amp;&amp;) = delete;
8967          TempFile&amp; operator=(TempFile&amp;&amp;) = delete;
8968          TempFile();
8969          ~TempFile();
8970          std::FILE* getFile();
8971          std::string getContents();
8972      private:
8973          std::FILE* m_file = nullptr;
8974      #if defined(_MSC_VER)
8975          char m_buffer[L_tmpnam] = { 0 };
8976      #endif
8977      };
8978      class OutputRedirect {
8979      public:
8980          OutputRedirect(OutputRedirect const&amp;) = delete;
8981          OutputRedirect&amp; operator=(OutputRedirect const&amp;) = delete;
8982          OutputRedirect(OutputRedirect&amp;&amp;) = delete;
8983          OutputRedirect&amp; operator=(OutputRedirect&amp;&amp;) = delete;
8984          OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest);
8985          ~OutputRedirect();
8986      private:
8987          int m_originalStdout = -1;
8988          int m_originalStderr = -1;
8989          TempFile m_stdoutFile;
8990          TempFile m_stderrFile;
8991          std::string&amp; m_stdoutDest;
8992          std::string&amp; m_stderrDest;
8993      };
8994  #endif
8995  } 
8996  #endif 
8997  #include &lt;cstdio&gt;
8998  #include &lt;cstring&gt;
8999  #include &lt;fstream&gt;
9000  #include &lt;sstream&gt;
9001  #include &lt;stdexcept&gt;
9002  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9003      #if defined(_MSC_VER)
9004      #include &lt;io.h&gt;      
9005      #define dup _dup
9006      #define dup2 _dup2
9007      #define fileno _fileno
9008      #else
9009      #include &lt;unistd.h&gt;  
9010      #endif
9011  #endif
9012  namespace Catch {
9013      RedirectedStream::RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream )
9014      :   m_originalStream( originalStream ),
9015          m_redirectionStream( redirectionStream ),
9016          m_prevBuf( m_originalStream.rdbuf() )
9017      {
9018          m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
9019      }
9020      RedirectedStream::~RedirectedStream() {
9021          m_originalStream.rdbuf( m_prevBuf );
9022      }
9023      RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
9024      auto RedirectedStdOut::str() const -&gt; std::string { return m_rss.str(); }
9025      RedirectedStdErr::RedirectedStdErr()
9026      :   m_cerr( Catch::cerr(), m_rss.get() ),
9027          m_clog( Catch::clog(), m_rss.get() )
9028      {}
9029      auto RedirectedStdErr::str() const -&gt; std::string { return m_rss.str(); }
9030      RedirectedStreams::RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr)
9031      :   m_redirectedCout(redirectedCout),
9032          m_redirectedCerr(redirectedCerr)
9033      {}
9034      RedirectedStreams::~RedirectedStreams() {
9035          m_redirectedCout += m_redirectedStdOut.str();
9036          m_redirectedCerr += m_redirectedStdErr.str();
9037      }
9038  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9039  #if defined(_MSC_VER)
9040      TempFile::TempFile() {
9041          if (tmpnam_s(m_buffer)) {
9042              CATCH_RUNTIME_ERROR(&quot;Could not get a temp filename&quot;);
9043          }
9044          if (fopen_s(&amp;m_file, m_buffer, &quot;w+&quot;)) {
9045              char buffer[100];
9046              if (strerror_s(buffer, errno)) {
9047                  CATCH_RUNTIME_ERROR(&quot;Could not translate errno to a string&quot;);
9048              }
9049              CATCH_RUNTIME_ERROR(&quot;Could not open the temp file: &#x27;&quot; &lt;&lt; m_buffer &lt;&lt; &quot;&#x27; because: &quot; &lt;&lt; buffer);
9050          }
9051      }
9052  #else
9053      TempFile::TempFile() {
9054          m_file = std::tmpfile();
9055          if (!m_file) {
9056              CATCH_RUNTIME_ERROR(&quot;Could not create a temp file.&quot;);
9057          }
9058      }
9059  #endif
9060      TempFile::~TempFile() {
9061           std::fclose(m_file);
9062  #if defined(_MSC_VER)
9063           std::remove(m_buffer);
9064  #endif
9065      }
9066      FILE* TempFile::getFile() {
9067          return m_file;
9068      }
9069      std::string TempFile::getContents() {
9070          std::stringstream sstr;
9071          char buffer[100] = {};
9072          std::rewind(m_file);
9073          while (std::fgets(buffer, sizeof(buffer), m_file)) {
9074              sstr &lt;&lt; buffer;
9075          }
9076          return sstr.str();
9077      }
9078      OutputRedirect::OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest) :
9079          m_originalStdout(dup(1)),
9080          m_originalStderr(dup(2)),
9081          m_stdoutDest(stdout_dest),
9082          m_stderrDest(stderr_dest) {
9083          dup2(fileno(m_stdoutFile.getFile()), 1);
9084          dup2(fileno(m_stderrFile.getFile()), 2);
9085      }
9086      OutputRedirect::~OutputRedirect() {
9087          Catch::cout() &lt;&lt; std::flush;
9088          fflush(stdout);
9089          Catch::cerr() &lt;&lt; std::flush;
9090          Catch::clog() &lt;&lt; std::flush;
9091          fflush(stderr);
9092          dup2(m_originalStdout, 1);
9093          dup2(m_originalStderr, 2);
9094          m_stdoutDest += m_stdoutFile.getContents();
9095          m_stderrDest += m_stderrFile.getContents();
9096      }
9097  #endif 
9098  } 
9099  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9100      #if defined(_MSC_VER)
9101      #undef dup
9102      #undef dup2
9103      #undef fileno
9104      #endif
9105  #endif
9106  #include &lt;cmath&gt;
9107  namespace Catch {
9108  #if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
9109      bool isnan(float f) {
9110          return std::isnan(f);
9111      }
9112      bool isnan(double d) {
9113          return std::isnan(d);
9114      }
9115  #else
9116      bool isnan(float f) {
9117          return std::_isnan(f);
9118      }
9119      bool isnan(double d) {
9120          return std::_isnan(d);
9121      }
9122  #endif
9123  } 
9124  namespace Catch {
9125  namespace {
9126  #if defined(_MSC_VER)
9127  #pragma warning(push)
9128  #pragma warning(disable:4146) 
9129  #endif
9130          uint32_t rotate_right(uint32_t val, uint32_t count) {
9131              const uint32_t mask = 31;
9132              count &amp;= mask;
9133              return (val &gt;&gt; count) | (val &lt;&lt; (-count &amp; mask));
9134          }
9135  #if defined(_MSC_VER)
9136  #pragma warning(pop)
9137  #endif
9138  }
9139      SimplePcg32::SimplePcg32(result_type seed_) {
9140          seed(seed_);
9141      }
9142      void SimplePcg32::seed(result_type seed_) {
9143          m_state = 0;
9144          (*this)();
9145          m_state += seed_;
9146          (*this)();
9147      }
9148      void SimplePcg32::discard(uint64_t skip) {
9149          for (uint64_t s = 0; s &lt; skip; ++s) {
9150              static_cast&lt;void&gt;((*this)());
9151          }
9152      }
9153      SimplePcg32::result_type SimplePcg32::operator()() {
9154          const uint32_t xorshifted = static_cast&lt;uint32_t&gt;(((m_state &gt;&gt; 18u) ^ m_state) &gt;&gt; 27u);
9155          const auto output = rotate_right(xorshifted, m_state &gt;&gt; 59u);
9156          m_state = m_state * 6364136223846793005ULL + s_inc;
9157          return output;
9158      }
9159      bool operator==(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9160          return lhs.m_state == rhs.m_state;
9161      }
9162      bool operator!=(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9163          return lhs.m_state != rhs.m_state;
9164      }
9165  }
9166  #include &lt;vector&gt;
9167  #include &lt;set&gt;
9168  #include &lt;algorithm&gt;
9169  #include &lt;ios&gt;
9170  namespace Catch {
9171      class TestCase;
9172      struct IConfig;
9173      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases );
9174      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config );
9175      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config );
9176      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions );
9177      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );
9178      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );
9179      class TestRegistry : public ITestCaseRegistry {
9180      public:
9181          virtual ~TestRegistry() = default;
9182          virtual void registerTest( TestCase const&amp; testCase );
9183          std::vector&lt;TestCase&gt; const&amp; getAllTests() const override;
9184          std::vector&lt;TestCase&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const override;
9185      private:
9186          std::vector&lt;TestCase&gt; m_functions;
9187          mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
9188          mutable std::vector&lt;TestCase&gt; m_sortedFunctions;
9189          std::size_t m_unnamedCount = 0;
9190          std::ios_base::Init m_ostreamInit; 
9191      };
9192      class TestInvokerAsFunction : public ITestInvoker {
9193          void(*m_testAsFunction)();
9194      public:
9195          TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
9196          void invoke() const override;
9197      };
9198      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName );
9199  } 
9200  #include &lt;map&gt;
9201  namespace Catch {
9202      class ReporterRegistry : public IReporterRegistry {
9203      public:
9204          ~ReporterRegistry() override;
9205          IStreamingReporterPtr create( std::string const&amp; name, IConfigPtr const&amp; config ) const override;
9206          void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory );
9207          void registerListener( IReporterFactoryPtr const&amp; factory );
9208          FactoryMap const&amp; getFactories() const override;
9209          Listeners const&amp; getListeners() const override;
9210      private:
9211          FactoryMap m_factories;
9212          Listeners m_listeners;
9213      };
9214  }
9215  #include &lt;string&gt;
9216  namespace Catch {
9217      struct TagAlias {
9218          TagAlias(std::string const&amp; _tag, SourceLineInfo _lineInfo);
9219          std::string tag;
9220          SourceLineInfo lineInfo;
9221      };
9222  } 
9223  #include &lt;map&gt;
9224  namespace Catch {
9225      class TagAliasRegistry : public ITagAliasRegistry {
9226      public:
9227          ~TagAliasRegistry() override;
9228          TagAlias const* find( std::string const&amp; alias ) const override;
9229          std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const override;
9230          void add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo );
9231      private:
9232          std::map&lt;std::string, TagAlias&gt; m_registry;
9233      };
9234  } 
9235  #include &lt;vector&gt;
9236  #include &lt;exception&gt;
9237  namespace Catch {
9238      class StartupExceptionRegistry {
9239  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9240      public:
9241          void add(std::exception_ptr const&amp; exception) noexcept;
9242          std::vector&lt;std::exception_ptr&gt; const&amp; getExceptions() const noexcept;
9243      private:
9244          std::vector&lt;std::exception_ptr&gt; m_exceptions;
9245  #endif
9246      };
9247  } 
9248  namespace Catch {
9249      struct ISingleton {
9250          virtual ~ISingleton();
9251      };
9252      void addSingleton( ISingleton* singleton );
9253      void cleanupSingletons();
9254      template&lt;typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT&gt;
9255      class Singleton : SingletonImplT, public ISingleton {
9256          static auto getInternal() -&gt; Singleton* {
9257              static Singleton* s_instance = nullptr;
9258              if( !s_instance ) {
9259                  s_instance = new Singleton;
9260                  addSingleton( s_instance );
9261              }
9262              return s_instance;
9263          }
9264      public:
9265          static auto get() -&gt; InterfaceT const&amp; {
9266              return *getInternal();
9267          }
9268          static auto getMutable() -&gt; MutableInterfaceT&amp; {
9269              return *getInternal();
9270          }
9271      };
9272  } 
9273  namespace Catch {
9274      namespace {
9275          class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
9276                              private NonCopyable {
9277          public: 
9278              RegistryHub() = default;
9279              IReporterRegistry const&amp; getReporterRegistry() const override {
9280                  return m_reporterRegistry;
9281              }
9282              ITestCaseRegistry const&amp; getTestCaseRegistry() const override {
9283                  return m_testCaseRegistry;
9284              }
9285              IExceptionTranslatorRegistry const&amp; getExceptionTranslatorRegistry() const override {
9286                  return m_exceptionTranslatorRegistry;
9287              }
9288              ITagAliasRegistry const&amp; getTagAliasRegistry() const override {
9289                  return m_tagAliasRegistry;
9290              }
9291              StartupExceptionRegistry const&amp; getStartupExceptionRegistry() const override {
9292                  return m_exceptionRegistry;
9293              }
9294          public: 
9295              void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) override {
9296                  m_reporterRegistry.registerReporter( name, factory );
9297              }
9298              void registerListener( IReporterFactoryPtr const&amp; factory ) override {
9299                  m_reporterRegistry.registerListener( factory );
9300              }
9301              void registerTest( TestCase const&amp; testInfo ) override {
9302                  m_testCaseRegistry.registerTest( testInfo );
9303              }
9304              void registerTranslator( const IExceptionTranslator* translator ) override {
9305                  m_exceptionTranslatorRegistry.registerTranslator( translator );
9306              }
9307              void registerTagAlias( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) override {
9308                  m_tagAliasRegistry.add( alias, tag, lineInfo );
9309              }
9310              void registerStartupException() noexcept override {
9311  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9312                  m_exceptionRegistry.add(std::current_exception());
9313  #else
9314                  CATCH_INTERNAL_ERROR(&quot;Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
9315  #endif
9316              }
9317              IMutableEnumValuesRegistry&amp; getMutableEnumValuesRegistry() override {
9318                  return m_enumValuesRegistry;
9319              }
9320          private:
9321              TestRegistry m_testCaseRegistry;
9322              ReporterRegistry m_reporterRegistry;
9323              ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
9324              TagAliasRegistry m_tagAliasRegistry;
9325              StartupExceptionRegistry m_exceptionRegistry;
9326              Detail::EnumValuesRegistry m_enumValuesRegistry;
9327          };
9328      }
9329      using RegistryHubSingleton = Singleton&lt;RegistryHub, IRegistryHub, IMutableRegistryHub&gt;;
9330      IRegistryHub const&amp; getRegistryHub() {
9331          return RegistryHubSingleton::get();
9332      }
9333      IMutableRegistryHub&amp; getMutableRegistryHub() {
9334          return RegistryHubSingleton::getMutable();
9335      }
9336      void cleanUp() {
9337          cleanupSingletons();
9338          cleanUpContext();
9339      }
9340      std::string translateActiveException() {
9341          return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
9342      }
9343  } 
9344  namespace Catch {
9345      ReporterRegistry::~ReporterRegistry() = default;
9346      IStreamingReporterPtr ReporterRegistry::create( std::string const&amp; name, IConfigPtr const&amp; config ) const {
9347          auto it =  m_factories.find( name );
9348          if( it == m_factories.end() )
9349              return nullptr;
9350          return it-&gt;second-&gt;create( ReporterConfig( config ) );
9351      }
9352      void ReporterRegistry::registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) {
9353          m_factories.emplace(name, factory);
9354      }
9355      void ReporterRegistry::registerListener( IReporterFactoryPtr const&amp; factory ) {
9356          m_listeners.push_back( factory );
9357      }
9358      IReporterRegistry::FactoryMap const&amp; ReporterRegistry::getFactories() const {
9359          return m_factories;
9360      }
9361      IReporterRegistry::Listeners const&amp; ReporterRegistry::getListeners() const {
9362          return m_listeners;
9363      }
9364  }
9365  namespace Catch {
9366      bool isOk( ResultWas::OfType resultType ) {
9367          return ( resultType &amp; ResultWas::FailureBit ) == 0;
9368      }
9369      bool isJustInfo( int flags ) {
9370          return flags == ResultWas::Info;
9371      }
9372      ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
9373          return static_cast&lt;ResultDisposition::Flags&gt;( static_cast&lt;int&gt;( lhs ) | static_cast&lt;int&gt;( rhs ) );
9374      }
9375      bool shouldContinueOnFailure( int flags )    { return ( flags &amp; ResultDisposition::ContinueOnFailure ) != 0; }
9376      bool shouldSuppressFailure( int flags )      { return ( flags &amp; ResultDisposition::SuppressFail ) != 0; }
9377  } 
9378  #include &lt;cassert&gt;
9379  #include &lt;algorithm&gt;
9380  #include &lt;sstream&gt;
9381  namespace Catch {
9382      namespace Generators {
9383          struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
9384              GeneratorBasePtr m_generator;
9385              GeneratorTracker( TestCaseTracking::NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
9386              :   TrackerBase( nameAndLocation, ctx, parent )
9387              {}
9388              ~GeneratorTracker();
9389              static GeneratorTracker&amp; acquire( TrackerContext&amp; ctx, TestCaseTracking::NameAndLocation const&amp; nameAndLocation ) {
9390                  std::shared_ptr&lt;GeneratorTracker&gt; tracker;
9391                  ITracker&amp; currentTracker = ctx.currentTracker();
9392                  if (currentTracker.nameAndLocation() == nameAndLocation) {
9393                      auto thisTracker = currentTracker.parent().findChild(nameAndLocation);
9394                      assert(thisTracker);
9395                      assert(thisTracker-&gt;isGeneratorTracker());
9396                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;(thisTracker);
9397                  } else if ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
9398                      assert( childTracker );
9399                      assert( childTracker-&gt;isGeneratorTracker() );
9400                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;( childTracker );
9401                  } else {
9402                      tracker = std::make_shared&lt;GeneratorTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
9403                      currentTracker.addChild( tracker );
9404                  }
9405                  if( !tracker-&gt;isComplete() ) {
9406                      tracker-&gt;open();
9407                  }
9408                  return *tracker;
9409              }
9410              bool isGeneratorTracker() const override { return true; }
9411              auto hasGenerator() const -&gt; bool override {
9412                  return !!m_generator;
9413              }
9414              void close() override {
9415                  TrackerBase::close();
9416                  const bool should_wait_for_child = [&amp;]() {
9417                      if ( m_children.empty() ) {
9418                          return false;
9419                      }
9420                      if ( std::find_if(
9421                               m_children.begin(),
9422                               m_children.end(),
9423                               []( TestCaseTracking::ITrackerPtr tracker ) {
9424                                   return tracker-&gt;hasStarted();
9425                               } ) != m_children.end() ) {
9426                          return false;
9427                      }
9428                      auto* parent = m_parent;
9429                      while ( !parent-&gt;isSectionTracker() ) {
9430                          parent = &amp;( parent-&gt;parent() );
9431                      }
9432                      assert( parent &amp;&amp;
9433                              &quot;Missing root (test case) level section&quot; );
9434                      auto const&amp; parentSection =
9435                          static_cast&lt;SectionTracker&amp;&gt;( *parent );
9436                      auto const&amp; filters = parentSection.getFilters();
9437                      if ( filters.empty() ) {
9438                          return true;
9439                      }
9440                      for ( auto const&amp; child : m_children ) {
9441                          if ( child-&gt;isSectionTracker() &amp;&amp;
9442                               std::find( filters.begin(),
9443                                          filters.end(),
9444                                          static_cast&lt;SectionTracker&amp;&gt;( *child )
9445                                              .trimmedName() ) !=
9446                                   filters.end() ) {
9447                              return true;
9448                          }
9449                      }
9450                      return false;
9451                  }();
9452                  if ( should_wait_for_child ||
9453                       ( m_runState == CompletedSuccessfully &amp;&amp;
9454                         m_generator-&gt;next() ) ) {
9455                      m_children.clear();
9456                      m_runState = Executing;
9457                  }
9458              }
9459              auto getGenerator() const -&gt; GeneratorBasePtr const&amp; override {
9460                  return m_generator;
9461              }
9462              void setGenerator( GeneratorBasePtr&amp;&amp; generator ) override {
9463                  m_generator = std::move( generator );
9464              }
9465          };
9466          GeneratorTracker::~GeneratorTracker() {}
9467      }
9468      RunContext::RunContext(IConfigPtr const&amp; _config, IStreamingReporterPtr&amp;&amp; reporter)
9469      :   m_runInfo(_config-&gt;name()),
9470          m_context(getCurrentMutableContext()),
9471          m_config(_config),
9472          m_reporter(std::move(reporter)),
9473          m_lastAssertionInfo{ StringRef(), SourceLineInfo(&quot;&quot;,0), StringRef(), ResultDisposition::Normal },
9474          m_includeSuccessfulResults( m_config-&gt;includeSuccessfulResults() || m_reporter-&gt;getPreferences().shouldReportAllAssertions )
9475      {
9476          m_context.setRunner(this);
9477          m_context.setConfig(m_config);
9478          m_context.setResultCapture(this);
9479          m_reporter-&gt;testRunStarting(m_runInfo);
9480      }
9481      RunContext::~RunContext() {
9482          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
9483      }
9484      void RunContext::testGroupStarting(std::string const&amp; testSpec, std::size_t groupIndex, std::size_t groupsCount) {
9485          m_reporter-&gt;testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
9486      }
9487      void RunContext::testGroupEnded(std::string const&amp; testSpec, Totals const&amp; totals, std::size_t groupIndex, std::size_t groupsCount) {
9488          m_reporter-&gt;testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
9489      }
9490      Totals RunContext::runTest(TestCase const&amp; testCase) {
9491          Totals prevTotals = m_totals;
9492          std::string redirectedCout;
9493          std::string redirectedCerr;
9494          auto const&amp; testInfo = testCase.getTestCaseInfo();
9495          m_reporter-&gt;testCaseStarting(testInfo);
9496          m_activeTestCase = &amp;testCase;
9497          ITracker&amp; rootTracker = m_trackerContext.startRun();
9498          assert(rootTracker.isSectionTracker());
9499          static_cast&lt;SectionTracker&amp;&gt;(rootTracker).addInitialFilters(m_config-&gt;getSectionsToRun());
9500          do {
9501              m_trackerContext.startCycle();
9502              m_testCaseTracker = &amp;SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
9503              runCurrentTest(redirectedCout, redirectedCerr);
9504          } while (!m_testCaseTracker-&gt;isSuccessfullyCompleted() &amp;&amp; !aborting());
9505          Totals deltaTotals = m_totals.delta(prevTotals);
9506          if (testInfo.expectedToFail() &amp;&amp; deltaTotals.testCases.passed &gt; 0) {
9507              deltaTotals.assertions.failed++;
9508              deltaTotals.testCases.passed--;
9509              deltaTotals.testCases.failed++;
9510          }
9511          m_totals.testCases += deltaTotals.testCases;
9512          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9513                                    deltaTotals,
9514                                    redirectedCout,
9515                                    redirectedCerr,
9516                                    aborting()));
9517          m_activeTestCase = nullptr;
9518          m_testCaseTracker = nullptr;
9519          return deltaTotals;
9520      }
9521      IConfigPtr RunContext::config() const {
9522          return m_config;
9523      }
9524      IStreamingReporter&amp; RunContext::reporter() const {
9525          return *m_reporter;
9526      }
9527      void RunContext::assertionEnded(AssertionResult const &amp; result) {
9528          if (result.getResultType() == ResultWas::Ok) {
9529              m_totals.assertions.passed++;
9530              m_lastAssertionPassed = true;
9531          } else if (!result.isOk()) {
9532              m_lastAssertionPassed = false;
9533              if( m_activeTestCase-&gt;getTestCaseInfo().okToFail() )
9534                  m_totals.assertions.failedButOk++;
9535              else
9536                  m_totals.assertions.failed++;
9537          }
9538          else {
9539              m_lastAssertionPassed = true;
9540          }
9541          static_cast&lt;void&gt;(m_reporter-&gt;assertionEnded(AssertionStats(result, m_messages, m_totals)));
9542          if (result.getResultType() != ResultWas::Warning)
9543              m_messageScopes.clear();
9544          resetAssertionInfo();
9545          m_lastResult = result;
9546      }
9547      void RunContext::resetAssertionInfo() {
9548          m_lastAssertionInfo.macroName = StringRef();
9549          m_lastAssertionInfo.capturedExpression = &quot;{Unknown expression after the reported line}&quot;_sr;
9550      }
9551      bool RunContext::sectionStarted(SectionInfo const &amp; sectionInfo, Counts &amp; assertions) {
9552          ITracker&amp; sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
9553          if (!sectionTracker.isOpen())
9554              return false;
9555          m_activeSections.push_back(&amp;sectionTracker);
9556          m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
9557          m_reporter-&gt;sectionStarting(sectionInfo);
9558          assertions = m_totals.assertions;
9559          return true;
9560      }
9561      auto RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
9562          using namespace Generators;
9563          GeneratorTracker&amp; tracker = GeneratorTracker::acquire(m_trackerContext,
9564                                                                TestCaseTracking::NameAndLocation( static_cast&lt;std::string&gt;(generatorName), lineInfo ) );
9565          m_lastAssertionInfo.lineInfo = lineInfo;
9566          return tracker;
9567      }
9568      bool RunContext::testForMissingAssertions(Counts&amp; assertions) {
9569          if (assertions.total() != 0)
9570              return false;
9571          if (!m_config-&gt;warnAboutMissingAssertions())
9572              return false;
9573          if (m_trackerContext.currentTracker().hasChildren())
9574              return false;
9575          m_totals.assertions.failed++;
9576          assertions.failed++;
9577          return true;
9578      }
9579      void RunContext::sectionEnded(SectionEndInfo const &amp; endInfo) {
9580          Counts assertions = m_totals.assertions - endInfo.prevAssertions;
9581          bool missingAssertions = testForMissingAssertions(assertions);
9582          if (!m_activeSections.empty()) {
9583              m_activeSections.back()-&gt;close();
9584              m_activeSections.pop_back();
9585          }
9586          m_reporter-&gt;sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
9587          m_messages.clear();
9588          m_messageScopes.clear();
9589      }
9590      void RunContext::sectionEndedEarly(SectionEndInfo const &amp; endInfo) {
9591          if (m_unfinishedSections.empty())
9592              m_activeSections.back()-&gt;fail();
9593          else
9594              m_activeSections.back()-&gt;close();
9595          m_activeSections.pop_back();
9596          m_unfinishedSections.push_back(endInfo);
9597      }
9598  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
9599      void RunContext::benchmarkPreparing(std::string const&amp; name) {
9600          m_reporter-&gt;benchmarkPreparing(name);
9601      }
9602      void RunContext::benchmarkStarting( BenchmarkInfo const&amp; info ) {
9603          m_reporter-&gt;benchmarkStarting( info );
9604      }
9605      void RunContext::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) {
9606          m_reporter-&gt;benchmarkEnded( stats );
9607      }
9608      void RunContext::benchmarkFailed(std::string const &amp; error) {
9609          m_reporter-&gt;benchmarkFailed(error);
9610      }
9611  #endif 
9612      void RunContext::pushScopedMessage(MessageInfo const &amp; message) {
9613          m_messages.push_back(message);
9614      }
9615      void RunContext::popScopedMessage(MessageInfo const &amp; message) {
9616          m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
9617      }
9618      void RunContext::emplaceUnscopedMessage( MessageBuilder const&amp; builder ) {
9619          m_messageScopes.emplace_back( builder );
9620      }
9621      std::string RunContext::getCurrentTestName() const {
9622          return m_activeTestCase
9623              ? m_activeTestCase-&gt;getTestCaseInfo().name
9624              : std::string();
9625      }
9626      const AssertionResult * RunContext::getLastResult() const {
9627          return &amp;(*m_lastResult);
9628      }
9629      void RunContext::exceptionEarlyReported() {
9630          m_shouldReportUnexpected = false;
9631      }
9632      void RunContext::handleFatalErrorCondition( StringRef message ) {
9633          m_reporter-&gt;fatalErrorEncountered(message);
9634          AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
9635          tempResult.message = static_cast&lt;std::string&gt;(message);
9636          AssertionResult result(m_lastAssertionInfo, tempResult);
9637          assertionEnded(result);
9638          handleUnfinishedSections();
9639          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9640          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9641          Counts assertions;
9642          assertions.failed = 1;
9643          SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
9644          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9645          auto const&amp; testInfo = m_activeTestCase-&gt;getTestCaseInfo();
9646          Totals deltaTotals;
9647          deltaTotals.testCases.failed = 1;
9648          deltaTotals.assertions.failed = 1;
9649          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9650                                    deltaTotals,
9651                                    std::string(),
9652                                    std::string(),
9653                                    false));
9654          m_totals.testCases.failed++;
9655          testGroupEnded(std::string(), m_totals, 1, 1);
9656          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, false));
9657      }
9658      bool RunContext::lastAssertionPassed() {
9659           return m_lastAssertionPassed;
9660      }
9661      void RunContext::assertionPassed() {
9662          m_lastAssertionPassed = true;
9663          ++m_totals.assertions.passed;
9664          resetAssertionInfo();
9665          m_messageScopes.clear();
9666      }
9667      bool RunContext::aborting() const {
9668          return m_totals.assertions.failed &gt;= static_cast&lt;std::size_t&gt;(m_config-&gt;abortAfter());
9669      }
9670      void RunContext::runCurrentTest(std::string &amp; redirectedCout, std::string &amp; redirectedCerr) {
9671          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9672          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9673          m_reporter-&gt;sectionStarting(testCaseSection);
9674          Counts prevAssertions = m_totals.assertions;
9675          double duration = 0;
9676          m_shouldReportUnexpected = true;
9677          m_lastAssertionInfo = { &quot;TEST_CASE&quot;_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
9678          seedRng(*m_config);
9679          Timer timer;
9680          CATCH_TRY {
9681              if (m_reporter-&gt;getPreferences().shouldRedirectStdOut) {
9682  #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
9683                  RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);
9684                  timer.start();
9685                  invokeActiveTestCase();
9686  #else
9687                  OutputRedirect r(redirectedCout, redirectedCerr);
9688                  timer.start();
9689                  invokeActiveTestCase();
9690  #endif
9691              } else {
9692                  timer.start();
9693                  invokeActiveTestCase();
9694              }
9695              duration = timer.getElapsedSeconds();
9696          } CATCH_CATCH_ANON (TestFailureException&amp;) {
9697          } CATCH_CATCH_ALL {
9698              if( m_shouldReportUnexpected ) {
9699                  AssertionReaction dummyReaction;
9700                  handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
9701              }
9702          }
9703          Counts assertions = m_totals.assertions - prevAssertions;
9704          bool missingAssertions = testForMissingAssertions(assertions);
9705          m_testCaseTracker-&gt;close();
9706          handleUnfinishedSections();
9707          m_messages.clear();
9708          m_messageScopes.clear();
9709          SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
9710          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9711      }
9712      void RunContext::invokeActiveTestCase() {
9713          FatalConditionHandlerGuard _(&amp;m_fatalConditionhandler);
9714          m_activeTestCase-&gt;invoke();
9715      }
9716      void RunContext::handleUnfinishedSections() {
9717          for (auto it = m_unfinishedSections.rbegin(),
9718               itEnd = m_unfinishedSections.rend();
9719               it != itEnd;
9720               ++it)
9721              sectionEnded(*it);
9722          m_unfinishedSections.clear();
9723      }
9724      void RunContext::handleExpr(
9725          AssertionInfo const&amp; info,
9726          ITransientExpression const&amp; expr,
9727          AssertionReaction&amp; reaction
9728      ) {
9729          m_reporter-&gt;assertionStarting( info );
9730          bool negated = isFalseTest( info.resultDisposition );
9731          bool result = expr.getResult() != negated;
9732          if( result ) {
9733              if (!m_includeSuccessfulResults) {
9734                  assertionPassed();
9735              }
9736              else {
9737                  reportExpr(info, ResultWas::Ok, &amp;expr, negated);
9738              }
9739          }
9740          else {
9741              reportExpr(info, ResultWas::ExpressionFailed, &amp;expr, negated );
9742              populateReaction( reaction );
9743          }
9744      }
9745      void RunContext::reportExpr(
9746              AssertionInfo const &amp;info,
9747              ResultWas::OfType resultType,
9748              ITransientExpression const *expr,
9749              bool negated ) {
9750          m_lastAssertionInfo = info;
9751          AssertionResultData data( resultType, LazyExpression( negated ) );
9752          AssertionResult assertionResult{ info, data };
9753          assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
9754          assertionEnded( assertionResult );
9755      }
9756      void RunContext::handleMessage(
9757              AssertionInfo const&amp; info,
9758              ResultWas::OfType resultType,
9759              StringRef const&amp; message,
9760              AssertionReaction&amp; reaction
9761      ) {
9762          m_reporter-&gt;assertionStarting( info );
9763          m_lastAssertionInfo = info;
9764          AssertionResultData data( resultType, LazyExpression( false ) );
9765          data.message = static_cast&lt;std::string&gt;(message);
9766          AssertionResult assertionResult{ m_lastAssertionInfo, data };
9767          assertionEnded( assertionResult );
9768          if( !assertionResult.isOk() )
9769              populateReaction( reaction );
9770      }
9771      void RunContext::handleUnexpectedExceptionNotThrown(
9772              AssertionInfo const&amp; info,
9773              AssertionReaction&amp; reaction
9774      ) {
9775          handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
9776      }
9777      void RunContext::handleUnexpectedInflightException(
9778              AssertionInfo const&amp; info,
9779              std::string const&amp; message,
9780              AssertionReaction&amp; reaction
9781      ) {
9782          m_lastAssertionInfo = info;
9783          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9784          data.message = message;
9785          AssertionResult assertionResult{ info, data };
9786          assertionEnded( assertionResult );
9787          populateReaction( reaction );
9788      }
9789      void RunContext::populateReaction( AssertionReaction&amp; reaction ) {
9790          reaction.shouldDebugBreak = m_config-&gt;shouldDebugBreak();
9791          reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition &amp; ResultDisposition::Normal);
9792      }
9793      void RunContext::handleIncomplete(
9794              AssertionInfo const&amp; info
9795      ) {
9796          m_lastAssertionInfo = info;
9797          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9798          data.message = &quot;Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE&quot;;
9799          AssertionResult assertionResult{ info, data };
9800          assertionEnded( assertionResult );
9801      }
9802      void RunContext::handleNonExpr(
9803              AssertionInfo const &amp;info,
9804              ResultWas::OfType resultType,
9805              AssertionReaction &amp;reaction
9806      ) {
9807          m_lastAssertionInfo = info;
9808          AssertionResultData data( resultType, LazyExpression( false ) );
9809          AssertionResult assertionResult{ info, data };
9810          assertionEnded( assertionResult );
9811          if( !assertionResult.isOk() )
9812              populateReaction( reaction );
9813      }
9814      IResultCapture&amp; getResultCapture() {
9815          if (auto* capture = getCurrentContext().getResultCapture())
9816              return *capture;
9817          else
9818              CATCH_INTERNAL_ERROR(&quot;No result capture instance&quot;);
9819      }
9820      void seedRng(IConfig const&amp; config) {
9821          if (config.rngSeed() != 0) {
9822              std::srand(config.rngSeed());
9823              rng().seed(config.rngSeed());
9824          }
9825      }
9826      unsigned int rngSeed() {
9827          return getCurrentContext().getConfig()-&gt;rngSeed();
9828      }
9829  }
9830  namespace Catch {
9831      Section::Section( SectionInfo const&amp; info )
9832      :   m_info( info ),
9833          m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
9834      {
9835          m_timer.start();
9836      }
9837      Section::~Section() {
9838          if( m_sectionIncluded ) {
9839              SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
9840              if( uncaught_exceptions() )
9841                  getResultCapture().sectionEndedEarly( endInfo );
9842              else
9843                  getResultCapture().sectionEnded( endInfo );
9844          }
9845      }
9846      Section::operator bool() const {
9847          return m_sectionIncluded;
9848      }
9849  } 
9850  namespace Catch {
9851      SectionInfo::SectionInfo
9852          (   SourceLineInfo const&amp; _lineInfo,
9853              std::string const&amp; _name )
9854      :   name( _name ),
9855          lineInfo( _lineInfo )
9856      {}
9857  } 
9858  #include &lt;memory&gt;
9859  namespace Catch {
9860      class Session : NonCopyable {
9861      public:
9862          Session();
9863          ~Session() override;
9864          void showHelp() const;
9865          void libIdentify();
9866          int applyCommandLine( int argc, char const * const * argv );
9867      #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
9868          int applyCommandLine( int argc, wchar_t const * const * argv );
9869      #endif
9870          void useConfigData( ConfigData const&amp; configData );
9871          template&lt;typename CharT&gt;
9872          int run(int argc, CharT const * const argv[]) {
9873              if (m_startupExceptions)
9874                  return 1;
9875              int returnCode = applyCommandLine(argc, argv);
9876              if (returnCode == 0)
9877                  returnCode = run();
9878              return returnCode;
9879          }
9880          int run();
9881          clara::Parser const&amp; cli() const;
9882          void cli( clara::Parser const&amp; newParser );
9883          ConfigData&amp; configData();
9884          Config&amp; config();
9885      private:
9886          int runInternal();
9887          clara::Parser m_cli;
9888          ConfigData m_configData;
9889          std::shared_ptr&lt;Config&gt; m_config;
9890          bool m_startupExceptions = false;
9891      };
9892  } 
9893  #include &lt;iosfwd&gt;
9894  namespace Catch {
9895      struct Version {
9896          Version( Version const&amp; ) = delete;
9897          Version&amp; operator=( Version const&amp; ) = delete;
9898          Version(    unsigned int _majorVersion,
9899                      unsigned int _minorVersion,
9900                      unsigned int _patchNumber,
9901                      char const * const _branchName,
9902                      unsigned int _buildNumber );
9903          unsigned int const majorVersion;
9904          unsigned int const minorVersion;
9905          unsigned int const patchNumber;
9906          char const * const branchName;
9907          unsigned int const buildNumber;
9908          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version );
9909      };
9910      Version const&amp; libraryVersion();
9911  }
9912  #include &lt;cstdlib&gt;
9913  #include &lt;iomanip&gt;
9914  #include &lt;set&gt;
9915  #include &lt;iterator&gt;
9916  namespace Catch {
9917      namespace {
9918          const int MaxExitCode = 255;
9919          IStreamingReporterPtr createReporter(std::string const&amp; reporterName, IConfigPtr const&amp; config) {
9920              auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
9921              CATCH_ENFORCE(reporter, &quot;No reporter registered with name: &#x27;&quot; &lt;&lt; reporterName &lt;&lt; &quot;&#x27;&quot;);
9922              return reporter;
9923          }
9924          IStreamingReporterPtr makeReporter(std::shared_ptr&lt;Config&gt; const&amp; config) {
9925              if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
9926                  return createReporter(config-&gt;getReporterName(), config);
9927              }
9928              auto ret = std::unique_ptr&lt;IStreamingReporter&gt;(new ListeningReporter);
9929              auto&amp; multi = static_cast&lt;ListeningReporter&amp;&gt;(*ret);
9930              auto const&amp; listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
9931              for (auto const&amp; listener : listeners) {
9932                  multi.addListener(listener-&gt;create(Catch::ReporterConfig(config)));
9933              }
9934              multi.addReporter(createReporter(config-&gt;getReporterName(), config));
9935              return ret;
9936          }
9937          class TestGroup {
9938          public:
9939              explicit TestGroup(std::shared_ptr&lt;Config&gt; const&amp; config)
9940              : m_config{config}
9941              , m_context{config, makeReporter(config)}
9942              {
9943                  auto const&amp; allTestCases = getAllTestCasesSorted(*m_config);
9944                  m_matches = m_config-&gt;testSpec().matchesByFilter(allTestCases, *m_config);
9945                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9946                  if (m_matches.empty() &amp;&amp; invalidArgs.empty()) {
9947                      for (auto const&amp; test : allTestCases)
9948                          if (!test.isHidden())
9949                              m_tests.emplace(&amp;test);
9950                  } else {
9951                      for (auto const&amp; match : m_matches)
9952                          m_tests.insert(match.tests.begin(), match.tests.end());
9953                  }
9954              }
9955              Totals execute() {
9956                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9957                  Totals totals;
9958                  m_context.testGroupStarting(m_config-&gt;name(), 1, 1);
9959                  for (auto const&amp; testCase : m_tests) {
9960                      if (!m_context.aborting())
9961                          totals += m_context.runTest(*testCase);
9962                      else
9963                          m_context.reporter().skipTest(*testCase);
9964                  }
9965                  for (auto const&amp; match : m_matches) {
9966                      if (match.tests.empty()) {
9967                          m_context.reporter().noMatchingTestCases(match.name);
9968                          totals.error = -1;
9969                      }
9970                  }
9971                  if (!invalidArgs.empty()) {
9972                      for (auto const&amp; invalidArg: invalidArgs)
9973                           m_context.reporter().reportInvalidArguments(invalidArg);
9974                  }
9975                  m_context.testGroupEnded(m_config-&gt;name(), totals, 1, 1);
9976                  return totals;
9977              }
9978          private:
9979              using Tests = std::set&lt;TestCase const*&gt;;
9980              std::shared_ptr&lt;Config&gt; m_config;
9981              RunContext m_context;
9982              Tests m_tests;
9983              TestSpec::Matches m_matches;
9984          };
9985          void applyFilenamesAsTags(Catch::IConfig const&amp; config) {
9986              auto&amp; tests = const_cast&lt;std::vector&lt;TestCase&gt;&amp;&gt;(getAllTestCasesSorted(config));
9987              for (auto&amp; testCase : tests) {
9988                  auto tags = testCase.tags;
9989                  std::string filename = testCase.lineInfo.file;
9990                  auto lastSlash = filename.find_last_of(&quot;\\/&quot;);
9991                  if (lastSlash != std::string::npos) {
9992                      filename.erase(0, lastSlash);
9993                      filename[0] = &#x27;#&#x27;;
9994                  }
9995                  auto lastDot = filename.find_last_of(&#x27;.&#x27;);
9996                  if (lastDot != std::string::npos) {
9997                      filename.erase(lastDot);
9998                  }
9999                  tags.push_back(std::move(filename));
10000                  setTags(testCase, tags);
10001              }
10002          }
10003      } 
10004      Session::Session() {
10005          static bool alreadyInstantiated = false;
10006          if( alreadyInstantiated ) {
10007              CATCH_TRY { CATCH_INTERNAL_ERROR( &quot;Only one instance of Catch::Session can ever be used&quot; ); }
10008              CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
10009          }
10010  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10011          const auto&amp; exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
10012          if ( !exceptions.empty() ) {
10013              config();
10014              getCurrentMutableContext().setConfig(m_config);
10015              m_startupExceptions = true;
10016              Colour colourGuard( Colour::Red );
10017              Catch::cerr() &lt;&lt; &quot;Errors occurred during startup!&quot; &lt;&lt; &#x27;\n&#x27;;
10018              for ( const auto&amp; ex_ptr : exceptions ) {
10019                  try {
10020                      std::rethrow_exception(ex_ptr);
10021                  } catch ( std::exception const&amp; ex ) {
10022                      Catch::cerr() &lt;&lt; Column( ex.what() ).indent(2) &lt;&lt; &#x27;\n&#x27;;
10023                  }
10024              }
10025          }
10026  #endif
10027          alreadyInstantiated = true;
10028          m_cli = makeCommandLineParser( m_configData );
10029      }
10030      Session::~Session() {
10031          Catch::cleanUp();
10032      }
10033      void Session::showHelp() const {
10034          Catch::cout()
10035                  &lt;&lt; &quot;\nCatch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot;\n&quot;
10036                  &lt;&lt; m_cli &lt;&lt; std::endl
10037                  &lt;&lt; &quot;For more detailed usage please see the project docs\n&quot; &lt;&lt; std::endl;
10038      }
10039      void Session::libIdentify() {
10040          Catch::cout()
10041                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;description: &quot; &lt;&lt; &quot;A Catch2 test executable\n&quot;
10042                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;category: &quot; &lt;&lt; &quot;testframework\n&quot;
10043                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;framework: &quot; &lt;&lt; &quot;Catch Test\n&quot;
10044                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;version: &quot; &lt;&lt; libraryVersion() &lt;&lt; std::endl;
10045      }
10046      int Session::applyCommandLine( int argc, char const * const * argv ) {
10047          if( m_startupExceptions )
10048              return 1;
10049          auto result = m_cli.parse( clara::Args( argc, argv ) );
10050          if( !result ) {
10051              config();
10052              getCurrentMutableContext().setConfig(m_config);
10053              Catch::cerr()
10054                  &lt;&lt; Colour( Colour::Red )
10055                  &lt;&lt; &quot;\nError(s) in input:\n&quot;
10056                  &lt;&lt; Column( result.errorMessage() ).indent( 2 )
10057                  &lt;&lt; &quot;\n\n&quot;;
10058              Catch::cerr() &lt;&lt; &quot;Run with -? for usage\n&quot; &lt;&lt; std::endl;
10059              return MaxExitCode;
10060          }
10061          if( m_configData.showHelp )
10062              showHelp();
10063          if( m_configData.libIdentify )
10064              libIdentify();
10065          m_config.reset();
10066          return 0;
10067      }
10068  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
10069      int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {
10070          char **utf8Argv = new char *[ argc ];
10071          for ( int i = 0; i &lt; argc; ++i ) {
10072              int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );
10073              utf8Argv[ i ] = new char[ bufSize ];
10074              WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
10075          }
10076          int returnCode = applyCommandLine( argc, utf8Argv );
10077          for ( int i = 0; i &lt; argc; ++i )
10078              delete [] utf8Argv[ i ];
10079          delete [] utf8Argv;
10080          return returnCode;
10081      }
10082  #endif
10083      void Session::useConfigData( ConfigData const&amp; configData ) {
10084          m_configData = configData;
10085          m_config.reset();
10086      }
10087      int Session::run() {
10088          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeStart ) != 0 ) {
10089              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before starting&quot; &lt;&lt; std::endl;
10090              static_cast&lt;void&gt;(std::getchar());
10091          }
10092          int exitCode = runInternal();
10093          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeExit ) != 0 ) {
10094              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before exiting, with code: &quot; &lt;&lt; exitCode &lt;&lt; std::endl;
10095              static_cast&lt;void&gt;(std::getchar());
10096          }
10097          return exitCode;
10098      }
10099      clara::Parser const&amp; Session::cli() const {
10100          return m_cli;
10101      }
10102      void Session::cli( clara::Parser const&amp; newParser ) {
10103          m_cli = newParser;
10104      }
10105      ConfigData&amp; Session::configData() {
10106          return m_configData;
10107      }
10108      Config&amp; Session::config() {
10109          if( !m_config )
10110              m_config = std::make_shared&lt;Config&gt;( m_configData );
10111          return *m_config;
10112      }
10113      int Session::runInternal() {
10114          if( m_startupExceptions )
10115              return 1;
10116          if (m_configData.showHelp || m_configData.libIdentify) {
10117              return 0;
10118          }
10119          CATCH_TRY {
10120              config(); 
10121              seedRng( *m_config );
10122              if( m_configData.filenamesAsTags )
10123                  applyFilenamesAsTags( *m_config );
10124              if( Option&lt;std::size_t&gt; listed = list( m_config ) )
10125                  return static_cast&lt;int&gt;( *listed );
10126              TestGroup tests { m_config };
10127              auto const totals = tests.execute();
10128              if( m_config-&gt;warnAboutNoTests() &amp;&amp; totals.error == -1 )
10129                  return 2;
10130              return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast&lt;int&gt;(totals.assertions.failed)));
10131          }
10132  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10133          catch( std::exception&amp; ex ) {
10134              Catch::cerr() &lt;&lt; ex.what() &lt;&lt; std::endl;
10135              return MaxExitCode;
10136          }
10137  #endif
10138      }
10139  } 
10140  #include &lt;vector&gt;
10141  namespace Catch {
10142      namespace {
10143          static auto getSingletons() -&gt; std::vector&lt;ISingleton*&gt;*&amp; {
10144              static std::vector&lt;ISingleton*&gt;* g_singletons = nullptr;
10145              if( !g_singletons )
10146                  g_singletons = new std::vector&lt;ISingleton*&gt;();
10147              return g_singletons;
10148          }
10149      }
10150      ISingleton::~ISingleton() {}
10151      void addSingleton(ISingleton* singleton ) {
10152          getSingletons()-&gt;push_back( singleton );
10153      }
10154      void cleanupSingletons() {
10155          auto&amp; singletons = getSingletons();
10156          for( auto singleton : *singletons )
10157              delete singleton;
10158          delete singletons;
10159          singletons = nullptr;
10160      }
10161  } 
10162  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10163  namespace Catch {
10164  void StartupExceptionRegistry::add( std::exception_ptr const&amp; exception ) noexcept {
10165          CATCH_TRY {
10166              m_exceptions.push_back(exception);
10167          } CATCH_CATCH_ALL {
10168              std::terminate();
10169          }
10170      }
10171      std::vector&lt;std::exception_ptr&gt; const&amp; StartupExceptionRegistry::getExceptions() const noexcept {
10172          return m_exceptions;
10173      }
10174  } 
10175  #endif
10176  #include &lt;cstdio&gt;
10177  #include &lt;iostream&gt;
10178  #include &lt;fstream&gt;
10179  #include &lt;sstream&gt;
10180  #include &lt;vector&gt;
10181  #include &lt;memory&gt;
10182  namespace Catch {
10183      Catch::IStream::~IStream() = default;
10184      namespace Detail { namespace {
10185          template&lt;typename WriterF, std::size_t bufferSize=256&gt;
10186          class StreamBufImpl : public std::streambuf {
10187              char data[bufferSize];
10188              WriterF m_writer;
10189          public:
10190              StreamBufImpl() {
10191                  setp( data, data + sizeof(data) );
10192              }
10193              ~StreamBufImpl() noexcept {
10194                  StreamBufImpl::sync();
10195              }
10196          private:
10197              int overflow( int c ) override {
10198                  sync();
10199                  if( c != EOF ) {
10200                      if( pbase() == epptr() )
10201                          m_writer( std::string( 1, static_cast&lt;char&gt;( c ) ) );
10202                      else
10203                          sputc( static_cast&lt;char&gt;( c ) );
10204                  }
10205                  return 0;
10206              }
10207              int sync() override {
10208                  if( pbase() != pptr() ) {
10209                      m_writer( std::string( pbase(), static_cast&lt;std::string::size_type&gt;( pptr() - pbase() ) ) );
10210                      setp( pbase(), epptr() );
10211                  }
10212                  return 0;
10213              }
10214          };
10215          struct OutputDebugWriter {
10216              void operator()( std::string const&amp;str ) {
10217                  writeToDebugConsole( str );
10218              }
10219          };
10220          class FileStream : public IStream {
10221              mutable std::ofstream m_ofs;
10222          public:
10223              FileStream( StringRef filename ) {
10224                  m_ofs.open( filename.c_str() );
10225                  CATCH_ENFORCE( !m_ofs.fail(), &quot;Unable to open file: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10226              }
10227              ~FileStream() override = default;
10228          public: 
10229              std::ostream&amp; stream() const override {
10230                  return m_ofs;
10231              }
10232          };
10233          class CoutStream : public IStream {
10234              mutable std::ostream m_os;
10235          public:
10236              CoutStream() : m_os( Catch::cout().rdbuf() ) {}
10237              ~CoutStream() override = default;
10238          public: 
10239              std::ostream&amp; stream() const override { return m_os; }
10240          };
10241          class DebugOutStream : public IStream {
10242              std::unique_ptr&lt;StreamBufImpl&lt;OutputDebugWriter&gt;&gt; m_streamBuf;
10243              mutable std::ostream m_os;
10244          public:
10245              DebugOutStream()
10246              :   m_streamBuf( new StreamBufImpl&lt;OutputDebugWriter&gt;() ),
10247                  m_os( m_streamBuf.get() )
10248              {}
10249              ~DebugOutStream() override = default;
10250          public: 
10251              std::ostream&amp; stream() const override { return m_os; }
10252          };
10253      }} 
10254      auto makeStream( StringRef const &amp;filename ) -&gt; IStream const* {
10255          if( filename.empty() )
10256              return new Detail::CoutStream();
10257          else if( filename[0] == &#x27;%&#x27; ) {
10258              if( filename == &quot;%debug&quot; )
10259                  return new Detail::DebugOutStream();
10260              else
10261                  CATCH_ERROR( &quot;Unrecognised stream: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10262          }
10263          else
10264              return new Detail::FileStream( filename );
10265      }
10266      struct StringStreams {
10267          std::vector&lt;std::unique_ptr&lt;std::ostringstream&gt;&gt; m_streams;
10268          std::vector&lt;std::size_t&gt; m_unused;
10269          std::ostringstream m_referenceStream; 
10270          auto add() -&gt; std::size_t {
10271              if( m_unused.empty() ) {
10272                  m_streams.push_back( std::unique_ptr&lt;std::ostringstream&gt;( new std::ostringstream ) );
10273                  return m_streams.size()-1;
10274              }
10275              else {
10276                  auto index = m_unused.back();
10277                  m_unused.pop_back();
10278                  return index;
10279              }
10280          }
10281          void release( std::size_t index ) {
10282              m_streams[index]-&gt;copyfmt( m_referenceStream ); 
10283              m_unused.push_back(index);
10284          }
10285      };
10286      ReusableStringStream::ReusableStringStream()
10287      :   m_index( Singleton&lt;StringStreams&gt;::getMutable().add() ),
10288          m_oss( Singleton&lt;StringStreams&gt;::getMutable().m_streams[m_index].get() )
10289      {}
10290      ReusableStringStream::~ReusableStringStream() {
10291          static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str(&quot;&quot;);
10292          m_oss-&gt;clear();
10293          Singleton&lt;StringStreams&gt;::getMutable().release( m_index );
10294      }
10295      auto ReusableStringStream::str() const -&gt; std::string {
10296          return static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str();
10297      }
10298  #ifndef CATCH_CONFIG_NOSTDOUT 
10299      std::ostream&amp; cout() { return std::cout; }
10300      std::ostream&amp; cerr() { return std::cerr; }
10301      std::ostream&amp; clog() { return std::clog; }
10302  #endif
10303  }
10304  #include &lt;algorithm&gt;
10305  #include &lt;ostream&gt;
10306  #include &lt;cstring&gt;
10307  #include &lt;cctype&gt;
10308  #include &lt;vector&gt;
10309  namespace Catch {
10310      namespace {
10311          char toLowerCh(char c) {
10312              return static_cast&lt;char&gt;( std::tolower( static_cast&lt;unsigned char&gt;(c) ) );
10313          }
10314      }
10315      bool startsWith( std::string const&amp; s, std::string const&amp; prefix ) {
10316          return s.size() &gt;= prefix.size() &amp;&amp; std::equal(prefix.begin(), prefix.end(), s.begin());
10317      }
10318      bool startsWith( std::string const&amp; s, char prefix ) {
10319          return !s.empty() &amp;&amp; s[0] == prefix;
10320      }
10321      bool endsWith( std::string const&amp; s, std::string const&amp; suffix ) {
10322          return s.size() &gt;= suffix.size() &amp;&amp; std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
10323      }
10324      bool endsWith( std::string const&amp; s, char suffix ) {
10325          return !s.empty() &amp;&amp; s[s.size()-1] == suffix;
10326      }
10327      bool contains( std::string const&amp; s, std::string const&amp; infix ) {
10328          return s.find( infix ) != std::string::npos;
10329      }
10330      void toLowerInPlace( std::string&amp; s ) {
10331          std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
10332      }
10333      std::string toLower( std::string const&amp; s ) {
10334          std::string lc = s;
10335          toLowerInPlace( lc );
10336          return lc;
10337      }
10338      std::string trim( std::string const&amp; str ) {
10339          static char const* whitespaceChars = &quot;\n\r\t &quot;;
10340          std::string::size_type start = str.find_first_not_of( whitespaceChars );
10341          std::string::size_type end = str.find_last_not_of( whitespaceChars );
10342          return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
10343      }
10344      StringRef trim(StringRef ref) {
10345          const auto is_ws = [](char c) {
10346              return c == &#x27; &#x27; || c == &#x27;\t&#x27; || c == &#x27;\n&#x27; || c == &#x27;\r&#x27;;
10347          };
10348          size_t real_begin = 0;
10349          while (real_begin &lt; ref.size() &amp;&amp; is_ws(ref[real_begin])) { ++real_begin; }
10350          size_t real_end = ref.size();
10351          while (real_end &gt; real_begin &amp;&amp; is_ws(ref[real_end - 1])) { --real_end; }
10352          return ref.substr(real_begin, real_end - real_begin);
10353      }
10354      bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis ) {
10355          bool replaced = false;
10356          std::size_t i = str.find( replaceThis );
10357          while( i != std::string::npos ) {
10358              replaced = true;
10359              str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
10360              if( i &lt; str.size()-withThis.size() )
10361                  i = str.find( replaceThis, i+withThis.size() );
10362              else
10363                  i = std::string::npos;
10364          }
10365          return replaced;
10366      }
10367      std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter ) {
10368          std::vector&lt;StringRef&gt; subStrings;
10369          std::size_t start = 0;
10370          for(std::size_t pos = 0; pos &lt; str.size(); ++pos ) {
10371              if( str[pos] == delimiter ) {
10372                  if( pos - start &gt; 1 )
10373                      subStrings.push_back( str.substr( start, pos-start ) );
10374                  start = pos+1;
10375              }
10376          }
10377          if( start &lt; str.size() )
10378              subStrings.push_back( str.substr( start, str.size()-start ) );
10379          return subStrings;
10380      }
10381      pluralise::pluralise( std::size_t count, std::string const&amp; label )
10382      :   m_count( count ),
10383          m_label( label )
10384      {}
10385      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser ) {
10386          os &lt;&lt; pluraliser.m_count &lt;&lt; &#x27; &#x27; &lt;&lt; pluraliser.m_label;
10387          if( pluraliser.m_count != 1 )
10388              os &lt;&lt; &#x27;s&#x27;;
10389          return os;
10390      }
10391  }
10392  #include &lt;algorithm&gt;
10393  #include &lt;ostream&gt;
10394  #include &lt;cstring&gt;
10395  #include &lt;cstdint&gt;
10396  namespace Catch {
10397      StringRef::StringRef( char const* rawChars ) noexcept
10398      : StringRef( rawChars, static_cast&lt;StringRef::size_type&gt;(std::strlen(rawChars) ) )
10399      {}
10400      auto StringRef::c_str() const -&gt; char const* {
10401          CATCH_ENFORCE(isNullTerminated(), &quot;Called StringRef::c_str() on a non-null-terminated instance&quot;);
10402          return m_start;
10403      }
10404      auto StringRef::data() const noexcept -&gt; char const* {
10405          return m_start;
10406      }
10407      auto StringRef::substr( size_type start, size_type size ) const noexcept -&gt; StringRef {
10408          if (start &lt; m_size) {
10409              return StringRef(m_start + start, (std::min)(m_size - start, size));
10410          } else {
10411              return StringRef();
10412          }
10413      }
10414      auto StringRef::operator == ( StringRef const&amp; other ) const noexcept -&gt; bool {
10415          return m_size == other.m_size
10416              &amp;&amp; (std::memcmp( m_start, other.m_start, m_size ) == 0);
10417      }
10418      auto operator &lt;&lt; ( std::ostream&amp; os, StringRef const&amp; str ) -&gt; std::ostream&amp; {
10419          return os.write(str.data(), str.size());
10420      }
10421      auto operator+=( std::string&amp; lhs, StringRef const&amp; rhs ) -&gt; std::string&amp; {
10422          lhs.append(rhs.data(), rhs.size());
10423          return lhs;
10424      }
10425  } 
10426  namespace Catch {
10427      TagAlias::TagAlias(std::string const &amp; _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
10428  }
10429  namespace Catch {
10430      RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const&amp; lineInfo) {
10431          CATCH_TRY {
10432              getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
10433          } CATCH_CATCH_ALL {
10434              getMutableRegistryHub().registerStartupException();
10435          }
10436      }
10437  }
10438  #include &lt;sstream&gt;
10439  namespace Catch {
10440      TagAliasRegistry::~TagAliasRegistry() {}
10441      TagAlias const* TagAliasRegistry::find( std::string const&amp; alias ) const {
10442          auto it = m_registry.find( alias );
10443          if( it != m_registry.end() )
10444              return &amp;(it-&gt;second);
10445          else
10446              return nullptr;
10447      }
10448      std::string TagAliasRegistry::expandAliases( std::string const&amp; unexpandedTestSpec ) const {
10449          std::string expandedTestSpec = unexpandedTestSpec;
10450          for( auto const&amp; registryKvp : m_registry ) {
10451              std::size_t pos = expandedTestSpec.find( registryKvp.first );
10452              if( pos != std::string::npos ) {
10453                  expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
10454                                      registryKvp.second.tag +
10455                                      expandedTestSpec.substr( pos + registryKvp.first.size() );
10456              }
10457          }
10458          return expandedTestSpec;
10459      }
10460      void TagAliasRegistry::add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) {
10461          CATCH_ENFORCE( startsWith(alias, &quot;[@&quot;) &amp;&amp; endsWith(alias, &#x27;]&#x27;),
10462                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; is not of the form [@alias name].\n&quot; &lt;&lt; lineInfo );
10463          CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
10464                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; already registered.\n&quot;
10465                        &lt;&lt; &quot;\tFirst seen at: &quot; &lt;&lt; find(alias)-&gt;lineInfo &lt;&lt; &quot;\n&quot;
10466                        &lt;&lt; &quot;\tRedefined at: &quot; &lt;&lt; lineInfo );
10467      }
10468      ITagAliasRegistry::~ITagAliasRegistry() {}
10469      ITagAliasRegistry const&amp; ITagAliasRegistry::get() {
10470          return getRegistryHub().getTagAliasRegistry();
10471      }
10472  } 
10473  #include &lt;cctype&gt;
10474  #include &lt;exception&gt;
10475  #include &lt;algorithm&gt;
10476  #include &lt;sstream&gt;
10477  namespace Catch {
10478      namespace {
10479          TestCaseInfo::SpecialProperties parseSpecialTag( std::string const&amp; tag ) {
10480              if( startsWith( tag, &#x27;.&#x27; ) ||
10481                  tag == &quot;!hide&quot; )
10482                  return TestCaseInfo::IsHidden;
10483              else if( tag == &quot;!throws&quot; )
10484                  return TestCaseInfo::Throws;
10485              else if( tag == &quot;!shouldfail&quot; )
10486                  return TestCaseInfo::ShouldFail;
10487              else if( tag == &quot;!mayfail&quot; )
10488                  return TestCaseInfo::MayFail;
10489              else if( tag == &quot;!nonportable&quot; )
10490                  return TestCaseInfo::NonPortable;
10491              else if( tag == &quot;!benchmark&quot; )
10492                  return static_cast&lt;TestCaseInfo::SpecialProperties&gt;( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
10493              else
10494                  return TestCaseInfo::None;
10495          }
10496          bool isReservedTag( std::string const&amp; tag ) {
10497              return parseSpecialTag( tag ) == TestCaseInfo::None &amp;&amp; tag.size() &gt; 0 &amp;&amp; !std::isalnum( static_cast&lt;unsigned char&gt;(tag[0]) );
10498          }
10499          void enforceNotReservedTag( std::string const&amp; tag, SourceLineInfo const&amp; _lineInfo ) {
10500              CATCH_ENFORCE( !isReservedTag(tag),
10501                            &quot;Tag name: [&quot; &lt;&lt; tag &lt;&lt; &quot;] is not allowed.\n&quot;
10502                            &lt;&lt; &quot;Tag names starting with non alphanumeric characters are reserved\n&quot;
10503                            &lt;&lt; _lineInfo );
10504          }
10505      }
10506      TestCase makeTestCase(  ITestInvoker* _testCase,
10507                              std::string const&amp; _className,
10508                              NameAndTags const&amp; nameAndTags,
10509                              SourceLineInfo const&amp; _lineInfo )
10510      {
10511          bool isHidden = false;
10512          std::vector&lt;std::string&gt; tags;
10513          std::string desc, tag;
10514          bool inTag = false;
10515          for (char c : nameAndTags.tags) {
10516              if( !inTag ) {
10517                  if( c == &#x27;[&#x27; )
10518                      inTag = true;
10519                  else
10520                      desc += c;
10521              }
10522              else {
10523                  if( c == &#x27;]&#x27; ) {
10524                      TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
10525                      if( ( prop &amp; TestCaseInfo::IsHidden ) != 0 )
10526                          isHidden = true;
10527                      else if( prop == TestCaseInfo::None )
10528                          enforceNotReservedTag( tag, _lineInfo );
10529                      if (startsWith(tag, &#x27;.&#x27;) &amp;&amp; tag.size() &gt; 1) {
10530                          tag.erase(0, 1);
10531                      }
10532                      tags.push_back( tag );
10533                      tag.clear();
10534                      inTag = false;
10535                  }
10536                  else
10537                      tag += c;
10538              }
10539          }
10540          if( isHidden ) {
10541              tags.insert( tags.end(), { &quot;.&quot;, &quot;!hide&quot; } );
10542          }
10543          TestCaseInfo info( static_cast&lt;std::string&gt;(nameAndTags.name), _className, desc, tags, _lineInfo );
10544          return TestCase( _testCase, std::move(info) );
10545      }
10546      void setTags( TestCaseInfo&amp; testCaseInfo, std::vector&lt;std::string&gt; tags ) {
10547          std::sort(begin(tags), end(tags));
10548          tags.erase(std::unique(begin(tags), end(tags)), end(tags));
10549          testCaseInfo.lcaseTags.clear();
10550          for( auto const&amp; tag : tags ) {
10551              std::string lcaseTag = toLower( tag );
10552              testCaseInfo.properties = static_cast&lt;TestCaseInfo::SpecialProperties&gt;( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
10553              testCaseInfo.lcaseTags.push_back( lcaseTag );
10554          }
10555          testCaseInfo.tags = std::move(tags);
10556      }
10557      TestCaseInfo::TestCaseInfo( std::string const&amp; _name,
10558                                  std::string const&amp; _className,
10559                                  std::string const&amp; _description,
10560                                  std::vector&lt;std::string&gt; const&amp; _tags,
10561                                  SourceLineInfo const&amp; _lineInfo )
10562      :   name( _name ),
10563          className( _className ),
10564          description( _description ),
10565          lineInfo( _lineInfo ),
10566          properties( None )
10567      {
10568          setTags( *this, _tags );
10569      }
10570      bool TestCaseInfo::isHidden() const {
10571          return ( properties &amp; IsHidden ) != 0;
10572      }
10573      bool TestCaseInfo::throws() const {
10574          return ( properties &amp; Throws ) != 0;
10575      }
10576      bool TestCaseInfo::okToFail() const {
10577          return ( properties &amp; (ShouldFail | MayFail ) ) != 0;
10578      }
10579      bool TestCaseInfo::expectedToFail() const {
10580          return ( properties &amp; (ShouldFail ) ) != 0;
10581      }
10582      std::string TestCaseInfo::tagsAsString() const {
10583          std::string ret;
10584          std::size_t full_size = 2 * tags.size();
10585          for (const auto&amp; tag : tags) {
10586              full_size += tag.size();
10587          }
10588          ret.reserve(full_size);
10589          for (const auto&amp; tag : tags) {
10590              ret.push_back(&#x27;[&#x27;);
10591              ret.append(tag);
10592              ret.push_back(&#x27;]&#x27;);
10593          }
10594          return ret;
10595      }
10596      TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&amp;&amp; info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
10597      TestCase TestCase::withName( std::string const&amp; _newName ) const {
10598          TestCase other( *this );
10599          other.name = _newName;
10600          return other;
10601      }
10602      void TestCase::invoke() const {
10603          test-&gt;invoke();
10604      }
10605      bool TestCase::operator == ( TestCase const&amp; other ) const {
10606          return  test.get() == other.test.get() &amp;&amp;
10607                  name == other.name &amp;&amp;
10608                  className == other.className;
10609      }
10610      bool TestCase::operator &lt; ( TestCase const&amp; other ) const {
10611          return name &lt; other.name;
10612      }
10613      TestCaseInfo const&amp; TestCase::getTestCaseInfo() const
10614      {
10615          return *this;
10616      }
10617  } 
10618  #include &lt;algorithm&gt;
10619  #include &lt;sstream&gt;
10620  namespace Catch {
10621      namespace {
10622          struct TestHasher {
10623              using hash_t = uint64_t;
10624              explicit TestHasher( hash_t hashSuffix ):
10625                  m_hashSuffix{ hashSuffix } {}
10626              uint32_t operator()( TestCase const&amp; t ) const {
10627                  const hash_t prime = 1099511628211u;
10628                  hash_t hash = 14695981039346656037u;
10629                  for ( const char c : t.name ) {
10630                      hash ^= c;
10631                      hash *= prime;
10632                  }
10633                  hash ^= m_hashSuffix;
10634                  hash *= prime;
10635                  const uint32_t low{ static_cast&lt;uint32_t&gt;( hash ) };
10636                  const uint32_t high{ static_cast&lt;uint32_t&gt;( hash &gt;&gt; 32 ) };
10637                  return low * high;
10638              }
10639          private:
10640              hash_t m_hashSuffix;
10641          };
10642      } 
10643      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases ) {
10644          switch( config.runOrder() ) {
10645              case RunTests::InDeclarationOrder:
10646                  break;
10647              case RunTests::InLexicographicalOrder: {
10648                  std::vector&lt;TestCase&gt; sorted = unsortedTestCases;
10649                  std::sort( sorted.begin(), sorted.end() );
10650                  return sorted;
10651              }
10652              case RunTests::InRandomOrder: {
10653                  seedRng( config );
10654                  TestHasher h{ config.rngSeed() };
10655                  using hashedTest = std::pair&lt;TestHasher::hash_t, TestCase const*&gt;;
10656                  std::vector&lt;hashedTest&gt; indexed_tests;
10657                  indexed_tests.reserve( unsortedTestCases.size() );
10658                  for (auto const&amp; testCase : unsortedTestCases) {
10659                      indexed_tests.emplace_back(h(testCase), &amp;testCase);
10660                  }
10661                  std::sort(indexed_tests.begin(), indexed_tests.end(),
10662                            [](hashedTest const&amp; lhs, hashedTest const&amp; rhs) {
10663                            if (lhs.first == rhs.first) {
10664                                return lhs.second-&gt;name &lt; rhs.second-&gt;name;
10665                            }
10666                            return lhs.first &lt; rhs.first;
10667                  });
10668                  std::vector&lt;TestCase&gt; sorted;
10669                  sorted.reserve( indexed_tests.size() );
10670                  for (auto const&amp; hashed : indexed_tests) {
10671                      sorted.emplace_back(*hashed.second);
10672                  }
10673                  return sorted;
10674              }
10675          }
10676          return unsortedTestCases;
10677      }
10678      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config ) {
10679          return !testCase.throws() || config.allowThrows();
10680      }
10681      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10682          return testSpec.matches( testCase ) &amp;&amp; isThrowSafe( testCase, config );
10683      }
10684      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions ) {
10685          std::set&lt;TestCase&gt; seenFunctions;
10686          for( auto const&amp; function : functions ) {
10687              auto prev = seenFunctions.insert( function );
10688              CATCH_ENFORCE( prev.second,
10689                      &quot;error: TEST_CASE( \&quot;&quot; &lt;&lt; function.name &lt;&lt; &quot;\&quot; ) already defined.\n&quot;
10690                      &lt;&lt; &quot;\tFirst seen at &quot; &lt;&lt; prev.first-&gt;getTestCaseInfo().lineInfo &lt;&lt; &quot;\n&quot;
10691                      &lt;&lt; &quot;\tRedefined at &quot; &lt;&lt; function.getTestCaseInfo().lineInfo );
10692          }
10693      }
10694      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10695          std::vector&lt;TestCase&gt; filtered;
10696          filtered.reserve( testCases.size() );
10697          for (auto const&amp; testCase : testCases) {
10698              if ((!testSpec.hasFilters() &amp;&amp; !testCase.isHidden()) ||
10699                  (testSpec.hasFilters() &amp;&amp; matchTest(testCase, testSpec, config))) {
10700                  filtered.push_back(testCase);
10701              }
10702          }
10703          return filtered;
10704      }
10705      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config ) {
10706          return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
10707      }
10708      void TestRegistry::registerTest( TestCase const&amp; testCase ) {
10709          std::string name = testCase.getTestCaseInfo().name;
10710          if( name.empty() ) {
10711              ReusableStringStream rss;
10712              rss &lt;&lt; &quot;Anonymous test case &quot; &lt;&lt; ++m_unnamedCount;
10713              return registerTest( testCase.withName( rss.str() ) );
10714          }
10715          m_functions.push_back( testCase );
10716      }
10717      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTests() const {
10718          return m_functions;
10719      }
10720      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTestsSorted( IConfig const&amp; config ) const {
10721          if( m_sortedFunctions.empty() )
10722              enforceNoDuplicateTestCases( m_functions );
10723          if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
10724              m_sortedFunctions = sortTests( config, m_functions );
10725              m_currentSortOrder = config.runOrder();
10726          }
10727          return m_sortedFunctions;
10728      }
10729      TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
10730      void TestInvokerAsFunction::invoke() const {
10731          m_testAsFunction();
10732      }
10733      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName ) {
10734          std::string className(classOrQualifiedMethodName);
10735          if( startsWith( className, &#x27;&amp;&#x27; ) )
10736          {
10737              std::size_t lastColons = className.rfind( &quot;::&quot; );
10738              std::size_t penultimateColons = className.rfind( &quot;::&quot;, lastColons-1 );
10739              if( penultimateColons == std::string::npos )
10740                  penultimateColons = 1;
10741              className = className.substr( penultimateColons, lastColons-penultimateColons );
10742          }
10743          return className;
10744      }
10745  } 
10746  #include &lt;algorithm&gt;
10747  #include &lt;cassert&gt;
10748  #include &lt;stdexcept&gt;
10749  #include &lt;memory&gt;
10750  #include &lt;sstream&gt;
10751  #if defined(__clang__)
10752  #    pragma clang diagnostic push
10753  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
10754  #endif
10755  namespace Catch {
10756  namespace TestCaseTracking {
10757      NameAndLocation::NameAndLocation( std::string const&amp; _name, SourceLineInfo const&amp; _location )
10758      :   name( _name ),
10759          location( _location )
10760      {}
10761      ITracker::~ITracker() = default;
10762      ITracker&amp; TrackerContext::startRun() {
10763          m_rootTracker = std::make_shared&lt;SectionTracker&gt;( NameAndLocation( &quot;{root}&quot;, CATCH_INTERNAL_LINEINFO ), *this, nullptr );
10764          m_currentTracker = nullptr;
10765          m_runState = Executing;
10766          return *m_rootTracker;
10767      }
10768      void TrackerContext::endRun() {
10769          m_rootTracker.reset();
10770          m_currentTracker = nullptr;
10771          m_runState = NotStarted;
10772      }
10773      void TrackerContext::startCycle() {
10774          m_currentTracker = m_rootTracker.get();
10775          m_runState = Executing;
10776      }
10777      void TrackerContext::completeCycle() {
10778          m_runState = CompletedCycle;
10779      }
10780      bool TrackerContext::completedCycle() const {
10781          return m_runState == CompletedCycle;
10782      }
10783      ITracker&amp; TrackerContext::currentTracker() {
10784          return *m_currentTracker;
10785      }
10786      void TrackerContext::setCurrentTracker( ITracker* tracker ) {
10787          m_currentTracker = tracker;
10788      }
10789      TrackerBase::TrackerBase( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent ):
10790          ITracker(nameAndLocation),
10791          m_ctx( ctx ),
10792          m_parent( parent )
10793      {}
10794      bool TrackerBase::isComplete() const {
10795          return m_runState == CompletedSuccessfully || m_runState == Failed;
10796      }
10797      bool TrackerBase::isSuccessfullyCompleted() const {
10798          return m_runState == CompletedSuccessfully;
10799      }
10800      bool TrackerBase::isOpen() const {
10801          return m_runState != NotStarted &amp;&amp; !isComplete();
10802      }
10803      bool TrackerBase::hasChildren() const {
10804          return !m_children.empty();
10805      }
10806      void TrackerBase::addChild( ITrackerPtr const&amp; child ) {
10807          m_children.push_back( child );
10808      }
10809      ITrackerPtr TrackerBase::findChild( NameAndLocation const&amp; nameAndLocation ) {
10810          auto it = std::find_if( m_children.begin(), m_children.end(),
10811              [&amp;nameAndLocation]( ITrackerPtr const&amp; tracker ){
10812                  return
10813                      tracker-&gt;nameAndLocation().location == nameAndLocation.location &amp;&amp;
10814                      tracker-&gt;nameAndLocation().name == nameAndLocation.name;
10815              } );
10816          return( it != m_children.end() )
10817              ? *it
10818              : nullptr;
10819      }
10820      ITracker&amp; TrackerBase::parent() {
10821          assert( m_parent ); 
10822          return *m_parent;
10823      }
10824      void TrackerBase::openChild() {
10825          if( m_runState != ExecutingChildren ) {
10826              m_runState = ExecutingChildren;
10827              if( m_parent )
10828                  m_parent-&gt;openChild();
10829          }
10830      }
10831      bool TrackerBase::isSectionTracker() const { return false; }
10832      bool TrackerBase::isGeneratorTracker() const { return false; }
10833      void TrackerBase::open() {
10834          m_runState = Executing;
10835          moveToThis();
10836          if( m_parent )
10837              m_parent-&gt;openChild();
10838      }
10839      void TrackerBase::close() {
10840          while( &amp;m_ctx.currentTracker() != this )
10841              m_ctx.currentTracker().close();
10842          switch( m_runState ) {
10843              case NeedsAnotherRun:
10844                  break;
10845              case Executing:
10846                  m_runState = CompletedSuccessfully;
10847                  break;
10848              case ExecutingChildren:
10849                  if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const&amp; t){ return t-&gt;isComplete(); }) )
10850                      m_runState = CompletedSuccessfully;
10851                  break;
10852              case NotStarted:
10853              case CompletedSuccessfully:
10854              case Failed:
10855                  CATCH_INTERNAL_ERROR( &quot;Illogical state: &quot; &lt;&lt; m_runState );
10856              default:
10857                  CATCH_INTERNAL_ERROR( &quot;Unknown state: &quot; &lt;&lt; m_runState );
10858          }
10859          moveToParent();
10860          m_ctx.completeCycle();
10861      }
10862      void TrackerBase::fail() {
10863          m_runState = Failed;
10864          if( m_parent )
10865              m_parent-&gt;markAsNeedingAnotherRun();
10866          moveToParent();
10867          m_ctx.completeCycle();
10868      }
10869      void TrackerBase::markAsNeedingAnotherRun() {
10870          m_runState = NeedsAnotherRun;
10871      }
10872      void TrackerBase::moveToParent() {
10873          assert( m_parent );
10874          m_ctx.setCurrentTracker( m_parent );
10875      }
10876      void TrackerBase::moveToThis() {
10877          m_ctx.setCurrentTracker( this );
10878      }
10879      SectionTracker::SectionTracker( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
10880      :   TrackerBase( nameAndLocation, ctx, parent ),
10881          m_trimmed_name(trim(nameAndLocation.name))
10882      {
10883          if( parent ) {
10884              while( !parent-&gt;isSectionTracker() )
10885                  parent = &amp;parent-&gt;parent();
10886              SectionTracker&amp; parentSection = static_cast&lt;SectionTracker&amp;&gt;( *parent );
10887              addNextFilters( parentSection.m_filters );
10888          }
10889      }
10890      bool SectionTracker::isComplete() const {
10891          bool complete = true;
10892          if (m_filters.empty()
10893              || m_filters[0] == &quot;&quot;
10894              || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
10895              complete = TrackerBase::isComplete();
10896          }
10897          return complete;
10898      }
10899      bool SectionTracker::isSectionTracker() const { return true; }
10900      SectionTracker&amp; SectionTracker::acquire( TrackerContext&amp; ctx, NameAndLocation const&amp; nameAndLocation ) {
10901          std::shared_ptr&lt;SectionTracker&gt; section;
10902          ITracker&amp; currentTracker = ctx.currentTracker();
10903          if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
10904              assert( childTracker );
10905              assert( childTracker-&gt;isSectionTracker() );
10906              section = std::static_pointer_cast&lt;SectionTracker&gt;( childTracker );
10907          }
10908          else {
10909              section = std::make_shared&lt;SectionTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
10910              currentTracker.addChild( section );
10911          }
10912          if( !ctx.completedCycle() )
10913              section-&gt;tryOpen();
10914          return *section;
10915      }
10916      void SectionTracker::tryOpen() {
10917          if( !isComplete() )
10918              open();
10919      }
10920      void SectionTracker::addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10921          if( !filters.empty() ) {
10922              m_filters.reserve( m_filters.size() + filters.size() + 2 );
10923              m_filters.emplace_back(&quot;&quot;); 
10924              m_filters.emplace_back(&quot;&quot;); 
10925              m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
10926          }
10927      }
10928      void SectionTracker::addNextFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10929          if( filters.size() &gt; 1 )
10930              m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
10931      }
10932      std::vector&lt;std::string&gt; const&amp; SectionTracker::getFilters() const {
10933          return m_filters;
10934      }
10935      std::string const&amp; SectionTracker::trimmedName() const {
10936          return m_trimmed_name;
10937      }
10938  } 
10939  using TestCaseTracking::ITracker;
10940  using TestCaseTracking::TrackerContext;
10941  using TestCaseTracking::SectionTracker;
10942  } 
10943  #if defined(__clang__)
10944  #    pragma clang diagnostic pop
10945  #endif
10946  namespace Catch {
10947      auto makeTestInvoker( void(*testAsFunction)() ) noexcept -&gt; ITestInvoker* {
10948          return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
10949      }
10950      NameAndTags::NameAndTags( StringRef const&amp; name_ , StringRef const&amp; tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
10951      AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const&amp; lineInfo, StringRef const&amp; classOrMethod, NameAndTags const&amp; nameAndTags ) noexcept {
10952          CATCH_TRY {
10953              getMutableRegistryHub()
10954                      .registerTest(
10955                          makeTestCase(
10956                              invoker,
10957                              extractClassName( classOrMethod ),
10958                              nameAndTags,
10959                              lineInfo));
10960          } CATCH_CATCH_ALL {
10961              getMutableRegistryHub().registerStartupException();
10962          }
10963      }
10964      AutoReg::~AutoReg() = default;
10965  }
10966  #include &lt;algorithm&gt;
10967  #include &lt;string&gt;
10968  #include &lt;vector&gt;
10969  #include &lt;memory&gt;
10970  namespace Catch {
10971      TestSpec::Pattern::Pattern( std::string const&amp; name )
10972      : m_name( name )
10973      {}
10974      TestSpec::Pattern::~Pattern() = default;
10975      std::string const&amp; TestSpec::Pattern::name() const {
10976          return m_name;
10977      }
10978      TestSpec::NamePattern::NamePattern( std::string const&amp; name, std::string const&amp; filterString )
10979      : Pattern( filterString )
10980      , m_wildcardPattern( toLower( name ), CaseSensitive::No )
10981      {}
10982      bool TestSpec::NamePattern::matches( TestCaseInfo const&amp; testCase ) const {
10983          return m_wildcardPattern.matches( testCase.name );
10984      }
10985      TestSpec::TagPattern::TagPattern( std::string const&amp; tag, std::string const&amp; filterString )
10986      : Pattern( filterString )
10987      , m_tag( toLower( tag ) )
10988      {}
10989      bool TestSpec::TagPattern::matches( TestCaseInfo const&amp; testCase ) const {
10990          return std::find(begin(testCase.lcaseTags),
10991                           end(testCase.lcaseTags),
10992                           m_tag) != end(testCase.lcaseTags);
10993      }
10994      TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const&amp; underlyingPattern )
10995      : Pattern( underlyingPattern-&gt;name() )
10996      , m_underlyingPattern( underlyingPattern )
10997      {}
10998      bool TestSpec::ExcludedPattern::matches( TestCaseInfo const&amp; testCase ) const {
10999          return !m_underlyingPattern-&gt;matches( testCase );
11000      }
11001      bool TestSpec::Filter::matches( TestCaseInfo const&amp; testCase ) const {
11002          return std::all_of( m_patterns.begin(), m_patterns.end(), [&amp;]( PatternPtr const&amp; p ){ return p-&gt;matches( testCase ); } );
11003      }
11004      std::string TestSpec::Filter::name() const {
11005          std::string name;
11006          for( auto const&amp; p : m_patterns )
11007              name += p-&gt;name();
11008          return name;
11009      }
11010      bool TestSpec::hasFilters() const {
11011          return !m_filters.empty();
11012      }
11013      bool TestSpec::matches( TestCaseInfo const&amp; testCase ) const {
11014          return std::any_of( m_filters.begin(), m_filters.end(), [&amp;]( Filter const&amp; f ){ return f.matches( testCase ); } );
11015      }
11016      TestSpec::Matches TestSpec::matchesByFilter( std::vector&lt;TestCase&gt; const&amp; testCases, IConfig const&amp; config ) const
11017      {
11018          Matches matches( m_filters.size() );
11019          std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&amp;]( Filter const&amp; filter ){
11020              std::vector&lt;TestCase const*&gt; currentMatches;
11021              for( auto const&amp; test : testCases )
11022                  if( isThrowSafe( test, config ) &amp;&amp; filter.matches( test ) )
11023                      currentMatches.emplace_back( &amp;test );
11024              return FilterMatch{ filter.name(), currentMatches };
11025          } );
11026          return matches;
11027      }
11028      const TestSpec::vectorStrings&amp; TestSpec::getInvalidArgs() const{
11029          return  (m_invalidArgs);
11030      }
11031  }
11032  namespace Catch {
11033      TestSpecParser::TestSpecParser( ITagAliasRegistry const&amp; tagAliases ) : m_tagAliases( &amp;tagAliases ) {}
11034      TestSpecParser&amp; TestSpecParser::parse( std::string const&amp; arg ) {
11035          m_mode = None;
11036          m_exclusion = false;
11037          m_arg = m_tagAliases-&gt;expandAliases( arg );
11038          m_escapeChars.clear();
11039          m_substring.reserve(m_arg.size());
11040          m_patternName.reserve(m_arg.size());
11041          m_realPatternPos = 0;
11042          for( m_pos = 0; m_pos &lt; m_arg.size(); ++m_pos )
11043             if( !visitChar( m_arg[m_pos] ) ){
11044                 m_testSpec.m_invalidArgs.push_back(arg);
11045                 break;
11046             }
11047          endMode();
11048          return *this;
11049      }
11050      TestSpec TestSpecParser::testSpec() {
11051          addFilter();
11052          return m_testSpec;
11053      }
11054      bool TestSpecParser::visitChar( char c ) {
11055          if( (m_mode != EscapedName) &amp;&amp; (c == &#x27;\\&#x27;) ) {
11056              escape();
11057              addCharToPattern(c);
11058              return true;
11059          }else if((m_mode != EscapedName) &amp;&amp; (c == &#x27;,&#x27;) )  {
11060              return separate();
11061          }
11062          switch( m_mode ) {
11063          case None:
11064              if( processNoneChar( c ) )
11065                  return true;
11066              break;
11067          case Name:
11068              processNameChar( c );
11069              break;
11070          case EscapedName:
11071              endMode();
11072              addCharToPattern(c);
11073              return true;
11074          default:
11075          case Tag:
11076          case QuotedName:
11077              if( processOtherChar( c ) )
11078                  return true;
11079              break;
11080          }
11081          m_substring += c;
11082          if( !isControlChar( c ) ) {
11083              m_patternName += c;
11084              m_realPatternPos++;
11085          }
11086          return true;
11087      }
11088      bool TestSpecParser::processNoneChar( char c ) {
11089          switch( c ) {
11090          case &#x27; &#x27;:
11091              return true;
11092          case &#x27;~&#x27;:
11093              m_exclusion = true;
11094              return false;
11095          case &#x27;[&#x27;:
11096              startNewMode( Tag );
11097              return false;
11098          case &#x27;&quot;&#x27;:
11099              startNewMode( QuotedName );
11100              return false;
11101          default:
11102              startNewMode( Name );
11103              return false;
11104          }
11105      }
11106      void TestSpecParser::processNameChar( char c ) {
11107          if( c == &#x27;[&#x27; ) {
11108              if( m_substring == &quot;exclude:&quot; )
11109                  m_exclusion = true;
11110              else
11111                  endMode();
11112              startNewMode( Tag );
11113          }
11114      }
11115      bool TestSpecParser::processOtherChar( char c ) {
11116          if( !isControlChar( c ) )
11117              return false;
11118          m_substring += c;
11119          endMode();
11120          return true;
11121      }
11122      void TestSpecParser::startNewMode( Mode mode ) {
11123          m_mode = mode;
11124      }
11125      void TestSpecParser::endMode() {
11126          switch( m_mode ) {
11127          case Name:
11128          case QuotedName:
11129              return addNamePattern();
11130          case Tag:
11131              return addTagPattern();
11132          case EscapedName:
11133              revertBackToLastMode();
11134              return;
11135          case None:
11136          default:
11137              return startNewMode( None );
11138          }
11139      }
11140      void TestSpecParser::escape() {
11141          saveLastMode();
11142          m_mode = EscapedName;
11143          m_escapeChars.push_back(m_realPatternPos);
11144      }
11145      bool TestSpecParser::isControlChar( char c ) const {
11146          switch( m_mode ) {
11147              default:
11148                  return false;
11149              case None:
11150                  return c == &#x27;~&#x27;;
11151              case Name:
11152                  return c == &#x27;[&#x27;;
11153              case EscapedName:
11154                  return true;
11155              case QuotedName:
11156                  return c == &#x27;&quot;&#x27;;
11157              case Tag:
11158                  return c == &#x27;[&#x27; || c == &#x27;]&#x27;;
11159          }
11160      }
11161      void TestSpecParser::addFilter() {
11162          if( !m_currentFilter.m_patterns.empty() ) {
11163              m_testSpec.m_filters.push_back( m_currentFilter );
11164              m_currentFilter = TestSpec::Filter();
11165          }
11166      }
11167      void TestSpecParser::saveLastMode() {
11168        lastMode = m_mode;
11169      }
11170      void TestSpecParser::revertBackToLastMode() {
11171        m_mode = lastMode;
11172      }
11173      bool TestSpecParser::separate() {
11174        if( (m_mode==QuotedName) || (m_mode==Tag) ){
11175           m_mode = None;
11176           m_pos = m_arg.size();
11177           m_substring.clear();
11178           m_patternName.clear();
11179           m_realPatternPos = 0;
11180           return false;
11181        }
11182        endMode();
11183        addFilter();
11184        return true; 
11185      }
11186      std::string TestSpecParser::preprocessPattern() {
11187          std::string token = m_patternName;
11188          for (std::size_t i = 0; i &lt; m_escapeChars.size(); ++i)
11189              token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
11190          m_escapeChars.clear();
11191          if (startsWith(token, &quot;exclude:&quot;)) {
11192              m_exclusion = true;
11193              token = token.substr(8);
11194          }
11195          m_patternName.clear();
11196          m_realPatternPos = 0;
11197          return token;
11198      }
11199      void TestSpecParser::addNamePattern() {
11200          auto token = preprocessPattern();
11201          if (!token.empty()) {
11202              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::NamePattern&gt;(token, m_substring);
11203              if (m_exclusion)
11204                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11205              m_currentFilter.m_patterns.push_back(pattern);
11206          }
11207          m_substring.clear();
11208          m_exclusion = false;
11209          m_mode = None;
11210      }
11211      void TestSpecParser::addTagPattern() {
11212          auto token = preprocessPattern();
11213          if (!token.empty()) {
11214              if (token.size() &gt; 1 &amp;&amp; token[0] == &#x27;.&#x27;) {
11215                  token.erase(token.begin());
11216                  TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(&quot;.&quot;, m_substring);
11217                  if (m_exclusion) {
11218                      pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11219                  }
11220                  m_currentFilter.m_patterns.push_back(pattern);
11221              }
11222              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(token, m_substring);
11223              if (m_exclusion) {
11224                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11225              }
11226              m_currentFilter.m_patterns.push_back(pattern);
11227          }
11228          m_substring.clear();
11229          m_exclusion = false;
11230          m_mode = None;
11231      }
11232      TestSpec parseTestSpec( std::string const&amp; arg ) {
11233          return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
11234      }
11235  } 
11236  #include &lt;chrono&gt;
11237  static const uint64_t nanosecondsInSecond = 1000000000;
11238  namespace Catch {
11239      auto getCurrentNanosecondsSinceEpoch() -&gt; uint64_t {
11240          return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
11241      }
11242      namespace {
11243          auto estimateClockResolution() -&gt; uint64_t {
11244              uint64_t sum = 0;
11245              static const uint64_t iterations = 1000000;
11246              auto startTime = getCurrentNanosecondsSinceEpoch();
11247              for( std::size_t i = 0; i &lt; iterations; ++i ) {
11248                  uint64_t ticks;
11249                  uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
11250                  do {
11251                      ticks = getCurrentNanosecondsSinceEpoch();
11252                  } while( ticks == baseTicks );
11253                  auto delta = ticks - baseTicks;
11254                  sum += delta;
11255                  if (ticks &gt; startTime + 3 * nanosecondsInSecond) {
11256                      return sum / ( i + 1u );
11257                  }
11258              }
11259              return sum/iterations;
11260          }
11261      }
11262      auto getEstimatedClockResolution() -&gt; uint64_t {
11263          static auto s_resolution = estimateClockResolution();
11264          return s_resolution;
11265      }
11266      void Timer::start() {
11267         m_nanoseconds = getCurrentNanosecondsSinceEpoch();
11268      }
11269      auto Timer::getElapsedNanoseconds() const -&gt; uint64_t {
11270          return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
11271      }
11272      auto Timer::getElapsedMicroseconds() const -&gt; uint64_t {
11273          return getElapsedNanoseconds()/1000;
11274      }
11275      auto Timer::getElapsedMilliseconds() const -&gt; unsigned int {
11276          return static_cast&lt;unsigned int&gt;(getElapsedMicroseconds()/1000);
11277      }
11278      auto Timer::getElapsedSeconds() const -&gt; double {
11279          return getElapsedMicroseconds()/1000000.0;
11280      }
11281  } 
11282  #if defined(__clang__)
11283  #    pragma clang diagnostic push
11284  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
11285  #    pragma clang diagnostic ignored &quot;-Wglobal-constructors&quot;
11286  #endif
11287  #if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
11288  #define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
11289  #endif
11290  #include &lt;cmath&gt;
11291  #include &lt;iomanip&gt;
11292  namespace Catch {
11293  namespace Detail {
11294      const std::string unprintableString = &quot;{?}&quot;;
11295      namespace {
11296          const int hexThreshold = 255;
11297          struct Endianness {
11298              enum Arch { Big, Little };
11299              static Arch which() {
11300                  int one = 1;
11301                  auto value = *reinterpret_cast&lt;char*&gt;(&amp;one);
11302                  return value ? Little : Big;
11303              }
11304          };
11305      }
11306      std::string rawMemoryToString( const void *object, std::size_t size ) {
11307          int i = 0, end = static_cast&lt;int&gt;( size ), inc = 1;
11308          if( Endianness::which() == Endianness::Little ) {
11309              i = end-1;
11310              end = inc = -1;
11311          }
11312          unsigned char const *bytes = static_cast&lt;unsigned char const *&gt;(object);
11313          ReusableStringStream rss;
11314          rss &lt;&lt; &quot;0x&quot; &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::hex;
11315          for( ; i != end; i += inc )
11316               rss &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(bytes[i]);
11317         return rss.str();
11318      }
11319  }
11320  template&lt;typename T&gt;
11321  std::string fpToString( T value, int precision ) {
11322      if (Catch::isnan(value)) {
11323          return &quot;nan&quot;;
11324      }
11325      ReusableStringStream rss;
11326      rss &lt;&lt; std::setprecision( precision )
11327          &lt;&lt; std::fixed
11328          &lt;&lt; value;
11329      std::string d = rss.str();
11330      std::size_t i = d.find_last_not_of( &#x27;0&#x27; );
11331      if( i != std::string::npos &amp;&amp; i != d.size()-1 ) {
11332          if( d[i] == &#x27;.&#x27; )
11333              i++;
11334          d = d.substr( 0, i+1 );
11335      }
11336      return d;
11337  }
11338  std::string StringMaker&lt;std::string&gt;::convert(const std::string&amp; str) {
11339      if (!getCurrentContext().getConfig()-&gt;showInvisibles()) {
11340          return &#x27;&quot;&#x27; + str + &#x27;&quot;&#x27;;
11341      }
11342      std::string s(&quot;\&quot;&quot;);
11343      for (char c : str) {
11344          switch (c) {
11345          case &#x27;\n&#x27;:
11346              s.append(&quot;\\n&quot;);
11347              break;
11348          case &#x27;\t&#x27;:
11349              s.append(&quot;\\t&quot;);
11350              break;
11351          default:
11352              s.push_back(c);
11353              break;
11354          }
11355      }
11356      s.append(&quot;\&quot;&quot;);
11357      return s;
11358  }
11359  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11360  std::string StringMaker&lt;std::string_view&gt;::convert(std::string_view str) {
11361      return ::Catch::Detail::stringify(std::string{ str });
11362  }
11363  #endif
11364  std::string StringMaker&lt;char const*&gt;::convert(char const* str) {
11365      if (str) {
11366          return ::Catch::Detail::stringify(std::string{ str });
11367      } else {
11368          return{ &quot;{null string}&quot; };
11369      }
11370  }
11371  std::string StringMaker&lt;char*&gt;::convert(char* str) {
11372      if (str) {
11373          return ::Catch::Detail::stringify(std::string{ str });
11374      } else {
11375          return{ &quot;{null string}&quot; };
11376      }
11377  }
11378  #ifdef CATCH_CONFIG_WCHAR
11379  std::string StringMaker&lt;std::wstring&gt;::convert(const std::wstring&amp; wstr) {
11380      std::string s;
11381      s.reserve(wstr.size());
11382      for (auto c : wstr) {
11383          s += (c &lt;= 0xff) ? static_cast&lt;char&gt;(c) : &#x27;?&#x27;;
11384      }
11385      return ::Catch::Detail::stringify(s);
11386  }
11387  # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11388  std::string StringMaker&lt;std::wstring_view&gt;::convert(std::wstring_view str) {
11389      return StringMaker&lt;std::wstring&gt;::convert(std::wstring(str));
11390  }
11391  # endif
11392  std::string StringMaker&lt;wchar_t const*&gt;::convert(wchar_t const * str) {
11393      if (str) {
11394          return ::Catch::Detail::stringify(std::wstring{ str });
11395      } else {
11396          return{ &quot;{null string}&quot; };
11397      }
11398  }
11399  std::string StringMaker&lt;wchar_t *&gt;::convert(wchar_t * str) {
11400      if (str) {
11401          return ::Catch::Detail::stringify(std::wstring{ str });
11402      } else {
11403          return{ &quot;{null string}&quot; };
11404      }
11405  }
11406  #endif
11407  #if defined(CATCH_CONFIG_CPP17_BYTE)
11408  #include &lt;cstddef&gt;
11409  std::string StringMaker&lt;std::byte&gt;::convert(std::byte value) {
11410      return ::Catch::Detail::stringify(std::to_integer&lt;unsigned long long&gt;(value));
11411  }
11412  #endif 
11413  std::string StringMaker&lt;int&gt;::convert(int value) {
11414      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11415  }
11416  std::string StringMaker&lt;long&gt;::convert(long value) {
11417      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11418  }
11419  std::string StringMaker&lt;long long&gt;::convert(long long value) {
11420      ReusableStringStream rss;
11421      rss &lt;&lt; value;
11422      if (value &gt; Detail::hexThreshold) {
11423          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11424      }
11425      return rss.str();
11426  }
11427  std::string StringMaker&lt;unsigned int&gt;::convert(unsigned int value) {
11428      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11429  }
11430  std::string StringMaker&lt;unsigned long&gt;::convert(unsigned long value) {
11431      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11432  }
11433  std::string StringMaker&lt;unsigned long long&gt;::convert(unsigned long long value) {
11434      ReusableStringStream rss;
11435      rss &lt;&lt; value;
11436      if (value &gt; Detail::hexThreshold) {
11437          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11438      }
11439      return rss.str();
11440  }
11441  std::string StringMaker&lt;bool&gt;::convert(bool b) {
11442      return b ? &quot;true&quot; : &quot;false&quot;;
11443  }
11444  std::string StringMaker&lt;signed char&gt;::convert(signed char value) {
11445      if (value == &#x27;\r&#x27;) {
11446          return &quot;&#x27;\\r&#x27;&quot;;
11447      } else if (value == &#x27;\f&#x27;) {
11448          return &quot;&#x27;\\f&#x27;&quot;;
11449      } else if (value == &#x27;\n&#x27;) {
11450          return &quot;&#x27;\\n&#x27;&quot;;
11451      } else if (value == &#x27;\t&#x27;) {
11452          return &quot;&#x27;\\t&#x27;&quot;;
11453      } else if (&#x27;\0&#x27; &lt;= value &amp;&amp; value &lt; &#x27; &#x27;) {
11454          return ::Catch::Detail::stringify(static_cast&lt;unsigned int&gt;(value));
11455      } else {
11456          char chstr[] = &quot;&#x27; &#x27;&quot;;
11457          chstr[1] = value;
11458          return chstr;
11459      }
11460  }
11461  std::string StringMaker&lt;char&gt;::convert(char c) {
11462      return ::Catch::Detail::stringify(static_cast&lt;signed char&gt;(c));
11463  }
11464  std::string StringMaker&lt;unsigned char&gt;::convert(unsigned char c) {
11465      return ::Catch::Detail::stringify(static_cast&lt;char&gt;(c));
11466  }
11467  std::string StringMaker&lt;std::nullptr_t&gt;::convert(std::nullptr_t) {
11468      return &quot;nullptr&quot;;
11469  }
11470  int StringMaker&lt;float&gt;::precision = 5;
11471  std::string StringMaker&lt;float&gt;::convert(float value) {
11472      return fpToString(value, precision) + &#x27;f&#x27;;
11473  }
11474  int StringMaker&lt;double&gt;::precision = 10;
11475  std::string StringMaker&lt;double&gt;::convert(double value) {
11476      return fpToString(value, precision);
11477  }
11478  std::string ratio_string&lt;std::atto&gt;::symbol() { return &quot;a&quot;; }
11479  std::string ratio_string&lt;std::femto&gt;::symbol() { return &quot;f&quot;; }
11480  std::string ratio_string&lt;std::pico&gt;::symbol() { return &quot;p&quot;; }
11481  std::string ratio_string&lt;std::nano&gt;::symbol() { return &quot;n&quot;; }
11482  std::string ratio_string&lt;std::micro&gt;::symbol() { return &quot;u&quot;; }
11483  std::string ratio_string&lt;std::milli&gt;::symbol() { return &quot;m&quot;; }
11484  } 
11485  #if defined(__clang__)
11486  #    pragma clang diagnostic pop
11487  #endif
11488  namespace Catch {
11489      Counts Counts::operator - ( Counts const&amp; other ) const {
11490          Counts diff;
11491          diff.passed = passed - other.passed;
11492          diff.failed = failed - other.failed;
11493          diff.failedButOk = failedButOk - other.failedButOk;
11494          return diff;
11495      }
11496      Counts&amp; Counts::operator += ( Counts const&amp; other ) {
11497          passed += other.passed;
11498          failed += other.failed;
11499          failedButOk += other.failedButOk;
11500          return *this;
11501      }
11502      std::size_t Counts::total() const {
11503          return passed + failed + failedButOk;
11504      }
11505      bool Counts::allPassed() const {
11506          return failed == 0 &amp;&amp; failedButOk == 0;
11507      }
11508      bool Counts::allOk() const {
11509          return failed == 0;
11510      }
11511      Totals Totals::operator - ( Totals const&amp; other ) const {
11512          Totals diff;
11513          diff.assertions = assertions - other.assertions;
11514          diff.testCases = testCases - other.testCases;
11515          return diff;
11516      }
11517      Totals&amp; Totals::operator += ( Totals const&amp; other ) {
11518          assertions += other.assertions;
11519          testCases += other.testCases;
11520          return *this;
11521      }
11522      Totals Totals::delta( Totals const&amp; prevTotals ) const {
11523          Totals diff = *this - prevTotals;
11524          if( diff.assertions.failed &gt; 0 )
11525              ++diff.testCases.failed;
11526          else if( diff.assertions.failedButOk &gt; 0 )
11527              ++diff.testCases.failedButOk;
11528          else
11529              ++diff.testCases.passed;
11530          return diff;
11531      }
11532  }
11533  #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11534  #define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11535  #if defined(_MSC_VER)
11536  #  if _MSC_VER &gt;= 1900 
11537  #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11538  #  endif
11539  #endif
11540  #include &lt;exception&gt;
11541  #if defined(__cpp_lib_uncaught_exceptions) \
11542      &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11543  #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11544  #endif 
11545  #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \
11546      &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \
11547      &amp;&amp; !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11548  #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11549  #endif
11550  #endif 
11551  #include &lt;exception&gt;
11552  namespace Catch {
11553      bool uncaught_exceptions() {
11554  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
11555          return false;
11556  #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11557          return std::uncaught_exceptions() &gt; 0;
11558  #else
11559          return std::uncaught_exception();
11560  #endif
11561    }
11562  } 
11563  #include &lt;ostream&gt;
11564  namespace Catch {
11565      Version::Version
11566          (   unsigned int _majorVersion,
11567              unsigned int _minorVersion,
11568              unsigned int _patchNumber,
11569              char const * const _branchName,
11570              unsigned int _buildNumber )
11571      :   majorVersion( _majorVersion ),
11572          minorVersion( _minorVersion ),
11573          patchNumber( _patchNumber ),
11574          branchName( _branchName ),
11575          buildNumber( _buildNumber )
11576      {}
11577      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version ) {
11578          os  &lt;&lt; version.majorVersion &lt;&lt; &#x27;.&#x27;
11579              &lt;&lt; version.minorVersion &lt;&lt; &#x27;.&#x27;
11580              &lt;&lt; version.patchNumber;
11581          if (version.branchName[0]) {
11582              os &lt;&lt; &#x27;-&#x27; &lt;&lt; version.branchName
11583                 &lt;&lt; &#x27;.&#x27; &lt;&lt; version.buildNumber;
11584          }
11585          return os;
11586      }
11587      Version const&amp; libraryVersion() {
11588          static Version version( 2, 13, 7, &quot;&quot;, 0 );
11589          return version;
11590      }
11591  }
11592  namespace Catch {
11593      WildcardPattern::WildcardPattern( std::string const&amp; pattern,
11594                                        CaseSensitive::Choice caseSensitivity )
11595      :   m_caseSensitivity( caseSensitivity ),
11596          m_pattern( normaliseString( pattern ) )
11597      {
11598          if( startsWith( m_pattern, &#x27;*&#x27; ) ) {
11599              m_pattern = m_pattern.substr( 1 );
11600              m_wildcard = WildcardAtStart;
11601          }
11602          if( endsWith( m_pattern, &#x27;*&#x27; ) ) {
11603              m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
11604              m_wildcard = static_cast&lt;WildcardPosition&gt;( m_wildcard | WildcardAtEnd );
11605          }
11606      }
11607      bool WildcardPattern::matches( std::string const&amp; str ) const {
11608          switch( m_wildcard ) {
11609              case NoWildcard:
11610                  return m_pattern == normaliseString( str );
11611              case WildcardAtStart:
11612                  return endsWith( normaliseString( str ), m_pattern );
11613              case WildcardAtEnd:
11614                  return startsWith( normaliseString( str ), m_pattern );
11615              case WildcardAtBothEnds:
11616                  return contains( normaliseString( str ), m_pattern );
11617              default:
11618                  CATCH_INTERNAL_ERROR( &quot;Unknown enum&quot; );
11619          }
11620      }
11621      std::string WildcardPattern::normaliseString( std::string const&amp; str ) const {
11622          return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
11623      }
11624  }
11625  #include &lt;iomanip&gt;
11626  #include &lt;type_traits&gt;
11627  namespace Catch {
11628  namespace {
11629      size_t trailingBytes(unsigned char c) {
11630          if ((c &amp; 0xE0) == 0xC0) {
11631              return 2;
11632          }
11633          if ((c &amp; 0xF0) == 0xE0) {
11634              return 3;
11635          }
11636          if ((c &amp; 0xF8) == 0xF0) {
11637              return 4;
11638          }
11639          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11640      }
11641      uint32_t headerValue(unsigned char c) {
11642          if ((c &amp; 0xE0) == 0xC0) {
11643              return c &amp; 0x1F;
11644          }
11645          if ((c &amp; 0xF0) == 0xE0) {
11646              return c &amp; 0x0F;
11647          }
11648          if ((c &amp; 0xF8) == 0xF0) {
11649              return c &amp; 0x07;
11650          }
11651          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11652      }
11653      void hexEscapeChar(std::ostream&amp; os, unsigned char c) {
11654          std::ios_base::fmtflags f(os.flags());
11655          os &lt;&lt; &quot;\\x&quot;
11656              &lt;&lt; std::uppercase &lt;&lt; std::hex &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(2)
11657              &lt;&lt; static_cast&lt;int&gt;(c);
11658          os.flags(f);
11659      }
11660      bool shouldNewline(XmlFormatting fmt) {
11661          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Newline));
11662      }
11663      bool shouldIndent(XmlFormatting fmt) {
11664          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Indent));
11665      }
11666  } 
11667      XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
11668          return static_cast&lt;XmlFormatting&gt;(
11669              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) |
11670              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11671          );
11672      }
11673      XmlFormatting operator &amp; (XmlFormatting lhs, XmlFormatting rhs) {
11674          return static_cast&lt;XmlFormatting&gt;(
11675              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) &amp;
11676              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11677          );
11678      }
11679      XmlEncode::XmlEncode( std::string const&amp; str, ForWhat forWhat )
11680      :   m_str( str ),
11681          m_forWhat( forWhat )
11682      {}
11683      void XmlEncode::encodeTo( std::ostream&amp; os ) const {
11684          for( std::size_t idx = 0; idx &lt; m_str.size(); ++ idx ) {
11685              unsigned char c = m_str[idx];
11686              switch (c) {
11687              case &#x27;&lt;&#x27;:   os &lt;&lt; &quot;&amp;lt;&quot;; break;
11688              case &#x27;&amp;&#x27;:   os &lt;&lt; &quot;&amp;amp;&quot;; break;
11689              case &#x27;&gt;&#x27;:
11690                  if (idx &gt; 2 &amp;&amp; m_str[idx - 1] == &#x27;]&#x27; &amp;&amp; m_str[idx - 2] == &#x27;]&#x27;)
11691                      os &lt;&lt; &quot;&amp;gt;&quot;;
11692                  else
11693                      os &lt;&lt; c;
11694                  break;
11695              case &#x27;\&quot;&#x27;:
11696                  if (m_forWhat == ForAttributes)
11697                      os &lt;&lt; &quot;&amp;quot;&quot;;
11698                  else
11699                      os &lt;&lt; c;
11700                  break;
11701              default:
11702                  if (c &lt; 0x09 || (c &gt; 0x0D &amp;&amp; c &lt; 0x20) || c == 0x7F) {
11703                      hexEscapeChar(os, c);
11704                      break;
11705                  }
11706                  if (c &lt; 0x7F) {
11707                      os &lt;&lt; c;
11708                      break;
11709                  }
11710                  if (c &lt;  0xC0 ||
11711                      c &gt;= 0xF8) {
11712                      hexEscapeChar(os, c);
11713                      break;
11714                  }
11715                  auto encBytes = trailingBytes(c);
11716                  if (idx + encBytes - 1 &gt;= m_str.size()) {
11717                      hexEscapeChar(os, c);
11718                      break;
11719                  }
11720                  bool valid = true;
11721                  uint32_t value = headerValue(c);
11722                  for (std::size_t n = 1; n &lt; encBytes; ++n) {
11723                      unsigned char nc = m_str[idx + n];
11724                      valid &amp;= ((nc &amp; 0xC0) == 0x80);
11725                      value = (value &lt;&lt; 6) | (nc &amp; 0x3F);
11726                  }
11727                  if (
11728                      (!valid) ||
11729                      (value &lt; 0x80) ||
11730                      (0x80 &lt;= value &amp;&amp; value &lt; 0x800   &amp;&amp; encBytes &gt; 2) ||
11731                      (0x800 &lt; value &amp;&amp; value &lt; 0x10000 &amp;&amp; encBytes &gt; 3) ||
11732                      (value &gt;= 0x110000)
11733                      ) {
11734                      hexEscapeChar(os, c);
11735                      break;
11736                  }
11737                  for (std::size_t n = 0; n &lt; encBytes; ++n) {
11738                      os &lt;&lt; m_str[idx + n];
11739                  }
11740                  idx += encBytes - 1;
11741                  break;
11742              }
11743          }
11744      }
11745      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode ) {
11746          xmlEncode.encodeTo( os );
11747          return os;
11748      }
11749      XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
11750      :   m_writer( writer ),
11751          m_fmt(fmt)
11752      {}
11753      XmlWriter::ScopedElement::ScopedElement( ScopedElement&amp;&amp; other ) noexcept
11754      :   m_writer( other.m_writer ),
11755          m_fmt(other.m_fmt)
11756      {
11757          other.m_writer = nullptr;
11758          other.m_fmt = XmlFormatting::None;
11759      }
11760      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::operator=( ScopedElement&amp;&amp; other ) noexcept {
11761          if ( m_writer ) {
11762              m_writer-&gt;endElement();
11763          }
11764          m_writer = other.m_writer;
11765          other.m_writer = nullptr;
11766          m_fmt = other.m_fmt;
11767          other.m_fmt = XmlFormatting::None;
11768          return *this;
11769      }
11770      XmlWriter::ScopedElement::~ScopedElement() {
11771          if (m_writer) {
11772              m_writer-&gt;endElement(m_fmt);
11773          }
11774      }
11775      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::writeText( std::string const&amp; text, XmlFormatting fmt ) {
11776          m_writer-&gt;writeText( text, fmt );
11777          return *this;
11778      }
11779      XmlWriter::XmlWriter( std::ostream&amp; os ) : m_os( os )
11780      {
11781          writeDeclaration();
11782      }
11783      XmlWriter::~XmlWriter() {
11784          while (!m_tags.empty()) {
11785              endElement();
11786          }
11787          newlineIfNecessary();
11788      }
11789      XmlWriter&amp; XmlWriter::startElement( std::string const&amp; name, XmlFormatting fmt ) {
11790          ensureTagClosed();
11791          newlineIfNecessary();
11792          if (shouldIndent(fmt)) {
11793              m_os &lt;&lt; m_indent;
11794              m_indent += &quot;  &quot;;
11795          }
11796          m_os &lt;&lt; &#x27;&lt;&#x27; &lt;&lt; name;
11797          m_tags.push_back( name );
11798          m_tagIsOpen = true;
11799          applyFormatting(fmt);
11800          return *this;
11801      }
11802      XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const&amp; name, XmlFormatting fmt ) {
11803          ScopedElement scoped( this, fmt );
11804          startElement( name, fmt );
11805          return scoped;
11806      }
11807      XmlWriter&amp; XmlWriter::endElement(XmlFormatting fmt) {
11808          m_indent = m_indent.substr(0, m_indent.size() - 2);
11809          if( m_tagIsOpen ) {
11810              m_os &lt;&lt; &quot;/&gt;&quot;;
11811              m_tagIsOpen = false;
11812          } else {
11813              newlineIfNecessary();
11814              if (shouldIndent(fmt)) {
11815                  m_os &lt;&lt; m_indent;
11816              }
11817              m_os &lt;&lt; &quot;&lt;/&quot; &lt;&lt; m_tags.back() &lt;&lt; &quot;&gt;&quot;;
11818          }
11819          m_os &lt;&lt; std::flush;
11820          applyFormatting(fmt);
11821          m_tags.pop_back();
11822          return *this;
11823      }
11824      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, std::string const&amp; attribute ) {
11825          if( !name.empty() &amp;&amp; !attribute.empty() )
11826              m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; XmlEncode( attribute, XmlEncode::ForAttributes ) &lt;&lt; &#x27;&quot;&#x27;;
11827          return *this;
11828      }
11829      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, bool attribute ) {
11830          m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; ( attribute ? &quot;true&quot; : &quot;false&quot; ) &lt;&lt; &#x27;&quot;&#x27;;
11831          return *this;
11832      }
11833      XmlWriter&amp; XmlWriter::writeText( std::string const&amp; text, XmlFormatting fmt) {
11834          if( !text.empty() ){
11835              bool tagWasOpen = m_tagIsOpen;
11836              ensureTagClosed();
11837              if (tagWasOpen &amp;&amp; shouldIndent(fmt)) {
11838                  m_os &lt;&lt; m_indent;
11839              }
11840              m_os &lt;&lt; XmlEncode( text );
11841              applyFormatting(fmt);
11842          }
11843          return *this;
11844      }
11845      XmlWriter&amp; XmlWriter::writeComment( std::string const&amp; text, XmlFormatting fmt) {
11846          ensureTagClosed();
11847          if (shouldIndent(fmt)) {
11848              m_os &lt;&lt; m_indent;
11849          }
11850          m_os &lt;&lt; &quot;&lt;!--&quot; &lt;&lt; text &lt;&lt; &quot;--&gt;&quot;;
11851          applyFormatting(fmt);
11852          return *this;
11853      }
11854      void XmlWriter::writeStylesheetRef( std::string const&amp; url ) {
11855          m_os &lt;&lt; &quot;&lt;?xml-stylesheet type=\&quot;text/xsl\&quot; href=\&quot;&quot; &lt;&lt; url &lt;&lt; &quot;\&quot;?&gt;\n&quot;;
11856      }
11857      XmlWriter&amp; XmlWriter::writeBlankLine() {
11858          ensureTagClosed();
11859          m_os &lt;&lt; &#x27;\n&#x27;;
11860          return *this;
11861      }
11862      void XmlWriter::ensureTagClosed() {
11863          if( m_tagIsOpen ) {
11864              m_os &lt;&lt; &#x27;&gt;&#x27; &lt;&lt; std::flush;
11865              newlineIfNecessary();
11866              m_tagIsOpen = false;
11867          }
11868      }
11869      void XmlWriter::applyFormatting(XmlFormatting fmt) {
11870          m_needsNewline = shouldNewline(fmt);
11871      }
11872      void XmlWriter::writeDeclaration() {
11873          m_os &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;
11874      }
11875      void XmlWriter::newlineIfNecessary() {
11876          if( m_needsNewline ) {
11877              m_os &lt;&lt; std::endl;
11878              m_needsNewline = false;
11879          }
11880      }
11881  }
11882  #include &lt;cstring&gt;
11883  #include &lt;cfloat&gt;
11884  #include &lt;cstdio&gt;
11885  #include &lt;cassert&gt;
11886  #include &lt;memory&gt;
11887  namespace Catch {
11888      void prepareExpandedExpression(AssertionResult&amp; result) {
11889          result.getExpandedExpression();
11890      }
11891      std::string getFormattedDuration( double duration ) {
11892          const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
11893          char buffer[maxDoubleSize];
11894          ErrnoGuard guard;
11895  #ifdef _MSC_VER
11896          sprintf_s(buffer, &quot;%.3f&quot;, duration);
11897  #else
11898          std::sprintf(buffer, &quot;%.3f&quot;, duration);
11899  #endif
11900          return std::string(buffer);
11901      }
11902      bool shouldShowDuration( IConfig const&amp; config, double duration ) {
11903          if ( config.showDurations() == ShowDurations::Always ) {
11904              return true;
11905          }
11906          if ( config.showDurations() == ShowDurations::Never ) {
11907              return false;
11908          }
11909          const double min = config.minDuration();
11910          return min &gt;= 0 &amp;&amp; duration &gt;= min;
11911      }
11912      std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; container ) {
11913          ReusableStringStream oss;
11914          bool first = true;
11915          for (auto&amp;&amp; filter : container)
11916          {
11917              if (!first)
11918                  oss &lt;&lt; &#x27; &#x27;;
11919              else
11920                  first = false;
11921              oss &lt;&lt; filter;
11922          }
11923          return oss.str();
11924      }
11925      TestEventListenerBase::TestEventListenerBase(ReporterConfig const &amp; _config)
11926          :StreamingReporterBase(_config) {}
11927      std::set&lt;Verbosity&gt; TestEventListenerBase::getSupportedVerbosities() {
11928          return { Verbosity::Quiet, Verbosity::Normal, Verbosity::High };
11929      }
11930      void TestEventListenerBase::assertionStarting(AssertionInfo const &amp;) {}
11931      bool TestEventListenerBase::assertionEnded(AssertionStats const &amp;) {
11932          return false;
11933      }
11934  } 
11935  namespace {
11936  #ifdef CATCH_PLATFORM_MAC
11937      const char* failedString() { return &quot;FAILED&quot;; }
11938      const char* passedString() { return &quot;PASSED&quot;; }
11939  #else
11940      const char* failedString() { return &quot;failed&quot;; }
11941      const char* passedString() { return &quot;passed&quot;; }
11942  #endif
11943      Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
11944      std::string bothOrAll( std::size_t count ) {
11945          return count == 1 ? std::string() :
11946                 count == 2 ? &quot;both &quot; : &quot;all &quot; ;
11947      }
11948  } 
11949  namespace Catch {
11950  namespace {
11951  void printTotals(std::ostream&amp; out, const Totals&amp; totals) {
11952      if (totals.testCases.total() == 0) {
11953          out &lt;&lt; &quot;No tests ran.&quot;;
11954      } else if (totals.testCases.failed == totals.testCases.total()) {
11955          Colour colour(Colour::ResultError);
11956          const std::string qualify_assertions_failed =
11957              totals.assertions.failed == totals.assertions.total() ?
11958              bothOrAll(totals.assertions.failed) : std::string();
11959          out &lt;&lt;
11960              &quot;Failed &quot; &lt;&lt; bothOrAll(totals.testCases.failed)
11961              &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11962              &quot;failed &quot; &lt;&lt; qualify_assertions_failed &lt;&lt;
11963              pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11964      } else if (totals.assertions.total() == 0) {
11965          out &lt;&lt;
11966              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.total())
11967              &lt;&lt; pluralise(totals.testCases.total(), &quot;test case&quot;)
11968              &lt;&lt; &quot; (no assertions).&quot;;
11969      } else if (totals.assertions.failed) {
11970          Colour colour(Colour::ResultError);
11971          out &lt;&lt;
11972              &quot;Failed &quot; &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11973              &quot;failed &quot; &lt;&lt; pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11974      } else {
11975          Colour colour(Colour::ResultSuccess);
11976          out &lt;&lt;
11977              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.passed)
11978              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt;
11979              &quot; with &quot; &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11980      }
11981  }
11982  class AssertionPrinter {
11983  public:
11984      AssertionPrinter&amp; operator= (AssertionPrinter const&amp;) = delete;
11985      AssertionPrinter(AssertionPrinter const&amp;) = delete;
11986      AssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
11987          : stream(_stream)
11988          , result(_stats.assertionResult)
11989          , messages(_stats.infoMessages)
11990          , itMessage(_stats.infoMessages.begin())
11991          , printInfoMessages(_printInfoMessages) {}
11992      void print() {
11993          printSourceInfo();
11994          itMessage = messages.begin();
11995          switch (result.getResultType()) {
11996          case ResultWas::Ok:
11997              printResultType(Colour::ResultSuccess, passedString());
11998              printOriginalExpression();
11999              printReconstructedExpression();
12000              if (!result.hasExpression())
12001                  printRemainingMessages(Colour::None);
12002              else
12003                  printRemainingMessages();
12004              break;
12005          case ResultWas::ExpressionFailed:
12006              if (result.isOk())
12007                  printResultType(Colour::ResultSuccess, failedString() + std::string(&quot; - but was ok&quot;));
12008              else
12009                  printResultType(Colour::Error, failedString());
12010              printOriginalExpression();
12011              printReconstructedExpression();
12012              printRemainingMessages();
12013              break;
12014          case ResultWas::ThrewException:
12015              printResultType(Colour::Error, failedString());
12016              printIssue(&quot;unexpected exception with message:&quot;);
12017              printMessage();
12018              printExpressionWas();
12019              printRemainingMessages();
12020              break;
12021          case ResultWas::FatalErrorCondition:
12022              printResultType(Colour::Error, failedString());
12023              printIssue(&quot;fatal error condition with message:&quot;);
12024              printMessage();
12025              printExpressionWas();
12026              printRemainingMessages();
12027              break;
12028          case ResultWas::DidntThrowException:
12029              printResultType(Colour::Error, failedString());
12030              printIssue(&quot;expected exception, got none&quot;);
12031              printExpressionWas();
12032              printRemainingMessages();
12033              break;
12034          case ResultWas::Info:
12035              printResultType(Colour::None, &quot;info&quot;);
12036              printMessage();
12037              printRemainingMessages();
12038              break;
12039          case ResultWas::Warning:
12040              printResultType(Colour::None, &quot;warning&quot;);
12041              printMessage();
12042              printRemainingMessages();
12043              break;
12044          case ResultWas::ExplicitFailure:
12045              printResultType(Colour::Error, failedString());
12046              printIssue(&quot;explicitly&quot;);
12047              printRemainingMessages(Colour::None);
12048              break;
12049          case ResultWas::Unknown:
12050          case ResultWas::FailureBit:
12051          case ResultWas::Exception:
12052              printResultType(Colour::Error, &quot;** internal error **&quot;);
12053              break;
12054          }
12055      }
12056  private:
12057      void printSourceInfo() const {
12058          Colour colourGuard(Colour::FileName);
12059          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &#x27;:&#x27;;
12060      }
12061      void printResultType(Colour::Code colour, std::string const&amp; passOrFail) const {
12062          if (!passOrFail.empty()) {
12063              {
12064                  Colour colourGuard(colour);
12065                  stream &lt;&lt; &#x27; &#x27; &lt;&lt; passOrFail;
12066              }
12067              stream &lt;&lt; &#x27;:&#x27;;
12068          }
12069      }
12070      void printIssue(std::string const&amp; issue) const {
12071          stream &lt;&lt; &#x27; &#x27; &lt;&lt; issue;
12072      }
12073      void printExpressionWas() {
12074          if (result.hasExpression()) {
12075              stream &lt;&lt; &#x27;;&#x27;;
12076              {
12077                  Colour colour(dimColour());
12078                  stream &lt;&lt; &quot; expression was:&quot;;
12079              }
12080              printOriginalExpression();
12081          }
12082      }
12083      void printOriginalExpression() const {
12084          if (result.hasExpression()) {
12085              stream &lt;&lt; &#x27; &#x27; &lt;&lt; result.getExpression();
12086          }
12087      }
12088      void printReconstructedExpression() const {
12089          if (result.hasExpandedExpression()) {
12090              {
12091                  Colour colour(dimColour());
12092                  stream &lt;&lt; &quot; for: &quot;;
12093              }
12094              stream &lt;&lt; result.getExpandedExpression();
12095          }
12096      }
12097      void printMessage() {
12098          if (itMessage != messages.end()) {
12099              stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; itMessage-&gt;message &lt;&lt; &#x27;\&#x27;&#x27;;
12100              ++itMessage;
12101          }
12102      }
12103      void printRemainingMessages(Colour::Code colour = dimColour()) {
12104          if (itMessage == messages.end())
12105              return;
12106          const auto itEnd = messages.cend();
12107          const auto N = static_cast&lt;std::size_t&gt;(std::distance(itMessage, itEnd));
12108          {
12109              Colour colourGuard(colour);
12110              stream &lt;&lt; &quot; with &quot; &lt;&lt; pluralise(N, &quot;message&quot;) &lt;&lt; &#x27;:&#x27;;
12111          }
12112          while (itMessage != itEnd) {
12113              if (printInfoMessages || itMessage-&gt;type != ResultWas::Info) {
12114                  printMessage();
12115                  if (itMessage != itEnd) {
12116                      Colour colourGuard(dimColour());
12117                      stream &lt;&lt; &quot; and&quot;;
12118                  }
12119                  continue;
12120              }
12121              ++itMessage;
12122          }
12123      }
12124  private:
12125      std::ostream&amp; stream;
12126      AssertionResult const&amp; result;
12127      std::vector&lt;MessageInfo&gt; messages;
12128      std::vector&lt;MessageInfo&gt;::const_iterator itMessage;
12129      bool printInfoMessages;
12130  };
12131  } 
12132          std::string CompactReporter::getDescription() {
12133              return &quot;Reports test results on a single line, suitable for IDEs&quot;;
12134          }
12135          void CompactReporter::noMatchingTestCases( std::string const&amp; spec ) {
12136              stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12137          }
12138          void CompactReporter::assertionStarting( AssertionInfo const&amp; ) {}
12139          bool CompactReporter::assertionEnded( AssertionStats const&amp; _assertionStats ) {
12140              AssertionResult const&amp; result = _assertionStats.assertionResult;
12141              bool printInfoMessages = true;
12142              if( !m_config-&gt;includeSuccessfulResults() &amp;&amp; result.isOk() ) {
12143                  if( result.getResultType() != ResultWas::Warning )
12144                      return false;
12145                  printInfoMessages = false;
12146              }
12147              AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
12148              printer.print();
12149              stream &lt;&lt; std::endl;
12150              return true;
12151          }
12152          void CompactReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12153              double dur = _sectionStats.durationInSeconds;
12154              if ( shouldShowDuration( *m_config, dur ) ) {
12155                  stream &lt;&lt; getFormattedDuration( dur ) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12156              }
12157          }
12158          void CompactReporter::testRunEnded( TestRunStats const&amp; _testRunStats ) {
12159              printTotals( stream, _testRunStats.totals );
12160              stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12161              StreamingReporterBase::testRunEnded( _testRunStats );
12162          }
12163          CompactReporter::~CompactReporter() {}
12164      CATCH_REGISTER_REPORTER( &quot;compact&quot;, CompactReporter )
12165  } 
12166  #include &lt;cfloat&gt;
12167  #include &lt;cstdio&gt;
12168  #if defined(_MSC_VER)
12169  #pragma warning(push)
12170  #pragma warning(disable:4061) 
12171  #endif
12172  #if defined(__clang__)
12173  #  pragma clang diagnostic push
12174  #  pragma clang diagnostic ignored &quot;-Wunused-function&quot;
12175  #endif
12176  namespace Catch {
12177  namespace {
12178  class ConsoleAssertionPrinter {
12179  public:
12180      ConsoleAssertionPrinter&amp; operator= (ConsoleAssertionPrinter const&amp;) = delete;
12181      ConsoleAssertionPrinter(ConsoleAssertionPrinter const&amp;) = delete;
12182      ConsoleAssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
12183          : stream(_stream),
12184          stats(_stats),
12185          result(_stats.assertionResult),
12186          colour(Colour::None),
12187          message(result.getMessage()),
12188          messages(_stats.infoMessages),
12189          printInfoMessages(_printInfoMessages) {
12190          switch (result.getResultType()) {
12191          case ResultWas::Ok:
12192              colour = Colour::Success;
12193              passOrFail = &quot;PASSED&quot;;
12194              if (_stats.infoMessages.size() == 1)
12195                  messageLabel = &quot;with message&quot;;
12196              if (_stats.infoMessages.size() &gt; 1)
12197                  messageLabel = &quot;with messages&quot;;
12198              break;
12199          case ResultWas::ExpressionFailed:
12200              if (result.isOk()) {
12201                  colour = Colour::Success;
12202                  passOrFail = &quot;FAILED - but was ok&quot;;
12203              } else {
12204                  colour = Colour::Error;
12205                  passOrFail = &quot;FAILED&quot;;
12206              }
12207              if (_stats.infoMessages.size() == 1)
12208                  messageLabel = &quot;with message&quot;;
12209              if (_stats.infoMessages.size() &gt; 1)
12210                  messageLabel = &quot;with messages&quot;;
12211              break;
12212          case ResultWas::ThrewException:
12213              colour = Colour::Error;
12214              passOrFail = &quot;FAILED&quot;;
12215              messageLabel = &quot;due to unexpected exception with &quot;;
12216              if (_stats.infoMessages.size() == 1)
12217                  messageLabel += &quot;message&quot;;
12218              if (_stats.infoMessages.size() &gt; 1)
12219                  messageLabel += &quot;messages&quot;;
12220              break;
12221          case ResultWas::FatalErrorCondition:
12222              colour = Colour::Error;
12223              passOrFail = &quot;FAILED&quot;;
12224              messageLabel = &quot;due to a fatal error condition&quot;;
12225              break;
12226          case ResultWas::DidntThrowException:
12227              colour = Colour::Error;
12228              passOrFail = &quot;FAILED&quot;;
12229              messageLabel = &quot;because no exception was thrown where one was expected&quot;;
12230              break;
12231          case ResultWas::Info:
12232              messageLabel = &quot;info&quot;;
12233              break;
12234          case ResultWas::Warning:
12235              messageLabel = &quot;warning&quot;;
12236              break;
12237          case ResultWas::ExplicitFailure:
12238              passOrFail = &quot;FAILED&quot;;
12239              colour = Colour::Error;
12240              if (_stats.infoMessages.size() == 1)
12241                  messageLabel = &quot;explicitly with message&quot;;
12242              if (_stats.infoMessages.size() &gt; 1)
12243                  messageLabel = &quot;explicitly with messages&quot;;
12244              break;
12245          case ResultWas::Unknown:
12246          case ResultWas::FailureBit:
12247          case ResultWas::Exception:
12248              passOrFail = &quot;** internal error **&quot;;
12249              colour = Colour::Error;
12250              break;
12251          }
12252      }
12253      void print() const {
12254          printSourceInfo();
12255          if (stats.totals.assertions.total() &gt; 0) {
12256              printResultType();
12257              printOriginalExpression();
12258              printReconstructedExpression();
12259          } else {
12260              stream &lt;&lt; &#x27;\n&#x27;;
12261          }
12262          printMessage();
12263      }
12264  private:
12265      void printResultType() const {
12266          if (!passOrFail.empty()) {
12267              Colour colourGuard(colour);
12268              stream &lt;&lt; passOrFail &lt;&lt; &quot;:\n&quot;;
12269          }
12270      }
12271      void printOriginalExpression() const {
12272          if (result.hasExpression()) {
12273              Colour colourGuard(Colour::OriginalExpression);
12274              stream &lt;&lt; &quot;  &quot;;
12275              stream &lt;&lt; result.getExpressionInMacro();
12276              stream &lt;&lt; &#x27;\n&#x27;;
12277          }
12278      }
12279      void printReconstructedExpression() const {
12280          if (result.hasExpandedExpression()) {
12281              stream &lt;&lt; &quot;with expansion:\n&quot;;
12282              Colour colourGuard(Colour::ReconstructedExpression);
12283              stream &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12284          }
12285      }
12286      void printMessage() const {
12287          if (!messageLabel.empty())
12288              stream &lt;&lt; messageLabel &lt;&lt; &#x27;:&#x27; &lt;&lt; &#x27;\n&#x27;;
12289          for (auto const&amp; msg : messages) {
12290              if (printInfoMessages || msg.type != ResultWas::Info)
12291                  stream &lt;&lt; Column(msg.message).indent(2) &lt;&lt; &#x27;\n&#x27;;
12292          }
12293      }
12294      void printSourceInfo() const {
12295          Colour colourGuard(Colour::FileName);
12296          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &quot;: &quot;;
12297      }
12298      std::ostream&amp; stream;
12299      AssertionStats const&amp; stats;
12300      AssertionResult const&amp; result;
12301      Colour::Code colour;
12302      std::string passOrFail;
12303      std::string messageLabel;
12304      std::string message;
12305      std::vector&lt;MessageInfo&gt; messages;
12306      bool printInfoMessages;
12307  };
12308  std::size_t makeRatio(std::size_t number, std::size_t total) {
12309      std::size_t ratio = total &gt; 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
12310      return (ratio == 0 &amp;&amp; number &gt; 0) ? 1 : ratio;
12311  }
12312  std::size_t&amp; findMax(std::size_t&amp; i, std::size_t&amp; j, std::size_t&amp; k) {
12313      if (i &gt; j &amp;&amp; i &gt; k)
12314          return i;
12315      else if (j &gt; k)
12316          return j;
12317      else
12318          return k;
12319  }
12320  struct ColumnInfo {
12321      enum Justification { Left, Right };
12322      std::string name;
12323      int width;
12324      Justification justification;
12325  };
12326  struct ColumnBreak {};
12327  struct RowBreak {};
12328  class Duration {
12329      enum class Unit {
12330          Auto,
12331          Nanoseconds,
12332          Microseconds,
12333          Milliseconds,
12334          Seconds,
12335          Minutes
12336      };
12337      static const uint64_t s_nanosecondsInAMicrosecond = 1000;
12338      static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
12339      static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
12340      static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
12341      double m_inNanoseconds;
12342      Unit m_units;
12343  public:
12344      explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
12345          : m_inNanoseconds(inNanoseconds),
12346          m_units(units) {
12347          if (m_units == Unit::Auto) {
12348              if (m_inNanoseconds &lt; s_nanosecondsInAMicrosecond)
12349                  m_units = Unit::Nanoseconds;
12350              else if (m_inNanoseconds &lt; s_nanosecondsInAMillisecond)
12351                  m_units = Unit::Microseconds;
12352              else if (m_inNanoseconds &lt; s_nanosecondsInASecond)
12353                  m_units = Unit::Milliseconds;
12354              else if (m_inNanoseconds &lt; s_nanosecondsInAMinute)
12355                  m_units = Unit::Seconds;
12356              else
12357                  m_units = Unit::Minutes;
12358          }
12359      }
12360      auto value() const -&gt; double {
12361          switch (m_units) {
12362          case Unit::Microseconds:
12363              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMicrosecond);
12364          case Unit::Milliseconds:
12365              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMillisecond);
12366          case Unit::Seconds:
12367              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInASecond);
12368          case Unit::Minutes:
12369              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMinute);
12370          default:
12371              return m_inNanoseconds;
12372          }
12373      }
12374      auto unitsAsString() const -&gt; std::string {
12375          switch (m_units) {
12376          case Unit::Nanoseconds:
12377              return &quot;ns&quot;;
12378          case Unit::Microseconds:
12379              return &quot;us&quot;;
12380          case Unit::Milliseconds:
12381              return &quot;ms&quot;;
12382          case Unit::Seconds:
12383              return &quot;s&quot;;
12384          case Unit::Minutes:
12385              return &quot;m&quot;;
12386          default:
12387              return &quot;** internal error **&quot;;
12388          }
12389      }
12390      friend auto operator &lt;&lt; (std::ostream&amp; os, Duration const&amp; duration) -&gt; std::ostream&amp; {
12391          return os &lt;&lt; duration.value() &lt;&lt; &#x27; &#x27; &lt;&lt; duration.unitsAsString();
12392      }
12393  };
12394  } 
12395  class TablePrinter {
12396      std::ostream&amp; m_os;
12397      std::vector&lt;ColumnInfo&gt; m_columnInfos;
12398      std::ostringstream m_oss;
12399      int m_currentColumn = -1;
12400      bool m_isOpen = false;
12401  public:
12402      TablePrinter( std::ostream&amp; os, std::vector&lt;ColumnInfo&gt; columnInfos )
12403      :   m_os( os ),
12404          m_columnInfos( std::move( columnInfos ) ) {}
12405      auto columnInfos() const -&gt; std::vector&lt;ColumnInfo&gt; const&amp; {
12406          return m_columnInfos;
12407      }
12408      void open() {
12409          if (!m_isOpen) {
12410              m_isOpen = true;
12411              *this &lt;&lt; RowBreak();
12412  			Columns headerCols;
12413  			Spacer spacer(2);
12414  			for (auto const&amp; info : m_columnInfos) {
12415  				headerCols += Column(info.name).width(static_cast&lt;std::size_t&gt;(info.width - 2));
12416  				headerCols += spacer;
12417  			}
12418  			m_os &lt;&lt; headerCols &lt;&lt; &#x27;\n&#x27;;
12419              m_os &lt;&lt; Catch::getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12420          }
12421      }
12422      void close() {
12423          if (m_isOpen) {
12424              *this &lt;&lt; RowBreak();
12425              m_os &lt;&lt; std::endl;
12426              m_isOpen = false;
12427          }
12428      }
12429      template&lt;typename T&gt;
12430      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, T const&amp; value) {
12431          tp.m_oss &lt;&lt; value;
12432          return tp;
12433      }
12434      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, ColumnBreak) {
12435          auto colStr = tp.m_oss.str();
12436          const auto strSize = colStr.size();
12437          tp.m_oss.str(&quot;&quot;);
12438          tp.open();
12439          if (tp.m_currentColumn == static_cast&lt;int&gt;(tp.m_columnInfos.size() - 1)) {
12440              tp.m_currentColumn = -1;
12441              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12442          }
12443          tp.m_currentColumn++;
12444          auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
12445          auto padding = (strSize + 1 &lt; static_cast&lt;std::size_t&gt;(colInfo.width))
12446              ? std::string(colInfo.width - (strSize + 1), &#x27; &#x27;)
12447              : std::string();
12448          if (colInfo.justification == ColumnInfo::Left)
12449              tp.m_os &lt;&lt; colStr &lt;&lt; padding &lt;&lt; &#x27; &#x27;;
12450          else
12451              tp.m_os &lt;&lt; padding &lt;&lt; colStr &lt;&lt; &#x27; &#x27;;
12452          return tp;
12453      }
12454      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, RowBreak) {
12455          if (tp.m_currentColumn &gt; 0) {
12456              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12457              tp.m_currentColumn = -1;
12458          }
12459          return tp;
12460      }
12461  };
12462  ConsoleReporter::ConsoleReporter(ReporterConfig const&amp; config)
12463      : StreamingReporterBase(config),
12464      m_tablePrinter(new TablePrinter(config.stream(),
12465          [&amp;config]() -&gt; std::vector&lt;ColumnInfo&gt; {
12466          if (config.fullConfig()-&gt;benchmarkNoAnalysis())
12467          {
12468              return{
12469                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12470                  { &quot;     samples&quot;, 14, ColumnInfo::Right },
12471                  { &quot;  iterations&quot;, 14, ColumnInfo::Right },
12472                  { &quot;        mean&quot;, 14, ColumnInfo::Right }
12473              };
12474          }
12475          else
12476          {
12477              return{
12478                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12479                  { &quot;samples      mean       std dev&quot;, 14, ColumnInfo::Right },
12480                  { &quot;iterations   low mean   low std dev&quot;, 14, ColumnInfo::Right },
12481                  { &quot;estimated    high mean  high std dev&quot;, 14, ColumnInfo::Right }
12482              };
12483          }
12484      }())) {}
12485  ConsoleReporter::~ConsoleReporter() = default;
12486  std::string ConsoleReporter::getDescription() {
12487      return &quot;Reports test results as plain lines of text&quot;;
12488  }
12489  void ConsoleReporter::noMatchingTestCases(std::string const&amp; spec) {
12490      stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12491  }
12492  void ConsoleReporter::reportInvalidArguments(std::string const&amp;arg){
12493      stream &lt;&lt; &quot;Invalid Filter: &quot; &lt;&lt; arg &lt;&lt; std::endl;
12494  }
12495  void ConsoleReporter::assertionStarting(AssertionInfo const&amp;) {}
12496  bool ConsoleReporter::assertionEnded(AssertionStats const&amp; _assertionStats) {
12497      AssertionResult const&amp; result = _assertionStats.assertionResult;
12498      bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
12499      if (!includeResults &amp;&amp; result.getResultType() != ResultWas::Warning)
12500          return false;
12501      lazyPrint();
12502      ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
12503      printer.print();
12504      stream &lt;&lt; std::endl;
12505      return true;
12506  }
12507  void ConsoleReporter::sectionStarting(SectionInfo const&amp; _sectionInfo) {
12508      m_tablePrinter-&gt;close();
12509      m_headerPrinted = false;
12510      StreamingReporterBase::sectionStarting(_sectionInfo);
12511  }
12512  void ConsoleReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12513      m_tablePrinter-&gt;close();
12514      if (_sectionStats.missingAssertions) {
12515          lazyPrint();
12516          Colour colour(Colour::ResultError);
12517          if (m_sectionStack.size() &gt; 1)
12518              stream &lt;&lt; &quot;\nNo assertions in section&quot;;
12519          else
12520              stream &lt;&lt; &quot;\nNo assertions in test case&quot;;
12521          stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; &quot;&#x27;\n&quot; &lt;&lt; std::endl;
12522      }
12523      double dur = _sectionStats.durationInSeconds;
12524      if (shouldShowDuration(*m_config, dur)) {
12525          stream &lt;&lt; getFormattedDuration(dur) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12526      }
12527      if (m_headerPrinted) {
12528          m_headerPrinted = false;
12529      }
12530      StreamingReporterBase::sectionEnded(_sectionStats);
12531  }
12532  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
12533  void ConsoleReporter::benchmarkPreparing(std::string const&amp; name) {
12534  	lazyPrintWithoutClosingBenchmarkTable();
12535  	auto nameCol = Column(name).width(static_cast&lt;std::size_t&gt;(m_tablePrinter-&gt;columnInfos()[0].width - 2));
12536  	bool firstLine = true;
12537  	for (auto line : nameCol) {
12538  		if (!firstLine)
12539  			(*m_tablePrinter) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12540  		else
12541  			firstLine = false;
12542  		(*m_tablePrinter) &lt;&lt; line &lt;&lt; ColumnBreak();
12543  	}
12544  }
12545  void ConsoleReporter::benchmarkStarting(BenchmarkInfo const&amp; info) {
12546      (*m_tablePrinter) &lt;&lt; info.samples &lt;&lt; ColumnBreak()
12547          &lt;&lt; info.iterations &lt;&lt; ColumnBreak();
12548      if (!m_config-&gt;benchmarkNoAnalysis())
12549          (*m_tablePrinter) &lt;&lt; Duration(info.estimatedDuration) &lt;&lt; ColumnBreak();
12550  }
12551  void ConsoleReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) {
12552      if (m_config-&gt;benchmarkNoAnalysis())
12553      {
12554          (*m_tablePrinter) &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak();
12555      }
12556      else
12557      {
12558          (*m_tablePrinter) &lt;&lt; ColumnBreak()
12559              &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak()
12560              &lt;&lt; Duration(stats.mean.lower_bound.count()) &lt;&lt; ColumnBreak()
12561              &lt;&lt; Duration(stats.mean.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak()
12562              &lt;&lt; Duration(stats.standardDeviation.point.count()) &lt;&lt; ColumnBreak()
12563              &lt;&lt; Duration(stats.standardDeviation.lower_bound.count()) &lt;&lt; ColumnBreak()
12564              &lt;&lt; Duration(stats.standardDeviation.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12565      }
12566  }
12567  void ConsoleReporter::benchmarkFailed(std::string const&amp; error) {
12568  	Colour colour(Colour::Red);
12569      (*m_tablePrinter)
12570          &lt;&lt; &quot;Benchmark failed (&quot; &lt;&lt; error &lt;&lt; &#x27;)&#x27;
12571          &lt;&lt; ColumnBreak() &lt;&lt; RowBreak();
12572  }
12573  #endif 
12574  void ConsoleReporter::testCaseEnded(TestCaseStats const&amp; _testCaseStats) {
12575      m_tablePrinter-&gt;close();
12576      StreamingReporterBase::testCaseEnded(_testCaseStats);
12577      m_headerPrinted = false;
12578  }
12579  void ConsoleReporter::testGroupEnded(TestGroupStats const&amp; _testGroupStats) {
12580      if (currentGroupInfo.used) {
12581          printSummaryDivider();
12582          stream &lt;&lt; &quot;Summary for group &#x27;&quot; &lt;&lt; _testGroupStats.groupInfo.name &lt;&lt; &quot;&#x27;:\n&quot;;
12583          printTotals(_testGroupStats.totals);
12584          stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12585      }
12586      StreamingReporterBase::testGroupEnded(_testGroupStats);
12587  }
12588  void ConsoleReporter::testRunEnded(TestRunStats const&amp; _testRunStats) {
12589      printTotalsDivider(_testRunStats.totals);
12590      printTotals(_testRunStats.totals);
12591      stream &lt;&lt; std::endl;
12592      StreamingReporterBase::testRunEnded(_testRunStats);
12593  }
12594  void ConsoleReporter::testRunStarting(TestRunInfo const&amp; _testInfo) {
12595      StreamingReporterBase::testRunStarting(_testInfo);
12596      printTestFilters();
12597  }
12598  void ConsoleReporter::lazyPrint() {
12599      m_tablePrinter-&gt;close();
12600      lazyPrintWithoutClosingBenchmarkTable();
12601  }
12602  void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
12603      if (!currentTestRunInfo.used)
12604          lazyPrintRunInfo();
12605      if (!currentGroupInfo.used)
12606          lazyPrintGroupInfo();
12607      if (!m_headerPrinted) {
12608          printTestCaseAndSectionHeader();
12609          m_headerPrinted = true;
12610      }
12611  }
12612  void ConsoleReporter::lazyPrintRunInfo() {
12613      stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; getLineOfChars&lt;&#x27;~&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12614      Colour colour(Colour::SecondaryText);
12615      stream &lt;&lt; currentTestRunInfo-&gt;name
12616          &lt;&lt; &quot; is a Catch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot; host application.\n&quot;
12617          &lt;&lt; &quot;Run with -? for options\n\n&quot;;
12618      if (m_config-&gt;rngSeed() != 0)
12619          stream &lt;&lt; &quot;Randomness seeded to: &quot; &lt;&lt; m_config-&gt;rngSeed() &lt;&lt; &quot;\n\n&quot;;
12620      currentTestRunInfo.used = true;
12621  }
12622  void ConsoleReporter::lazyPrintGroupInfo() {
12623      if (!currentGroupInfo-&gt;name.empty() &amp;&amp; currentGroupInfo-&gt;groupsCounts &gt; 1) {
12624          printClosedHeader(&quot;Group: &quot; + currentGroupInfo-&gt;name);
12625          currentGroupInfo.used = true;
12626      }
12627  }
12628  void ConsoleReporter::printTestCaseAndSectionHeader() {
12629      assert(!m_sectionStack.empty());
12630      printOpenHeader(currentTestCaseInfo-&gt;name);
12631      if (m_sectionStack.size() &gt; 1) {
12632          Colour colourGuard(Colour::Headers);
12633          auto
12634              it = m_sectionStack.begin() + 1, 
12635              itEnd = m_sectionStack.end();
12636          for (; it != itEnd; ++it)
12637              printHeaderString(it-&gt;name, 2);
12638      }
12639      SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
12640      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12641      Colour colourGuard(Colour::FileName);
12642      stream &lt;&lt; lineInfo &lt;&lt; &#x27;\n&#x27;;
12643      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12644  }
12645  void ConsoleReporter::printClosedHeader(std::string const&amp; _name) {
12646      printOpenHeader(_name);
12647      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12648  }
12649  void ConsoleReporter::printOpenHeader(std::string const&amp; _name) {
12650      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12651      {
12652          Colour colourGuard(Colour::Headers);
12653          printHeaderString(_name);
12654      }
12655  }
12656  void ConsoleReporter::printHeaderString(std::string const&amp; _string, std::size_t indent) {
12657      std::size_t i = _string.find(&quot;: &quot;);
12658      if (i != std::string::npos)
12659          i += 2;
12660      else
12661          i = 0;
12662      stream &lt;&lt; Column(_string).indent(indent + i).initialIndent(indent) &lt;&lt; &#x27;\n&#x27;;
12663  }
12664  struct SummaryColumn {
12665      SummaryColumn( std::string _label, Colour::Code _colour )
12666      :   label( std::move( _label ) ),
12667          colour( _colour ) {}
12668      SummaryColumn addRow( std::size_t count ) {
12669          ReusableStringStream rss;
12670          rss &lt;&lt; count;
12671          std::string row = rss.str();
12672          for (auto&amp; oldRow : rows) {
12673              while (oldRow.size() &lt; row.size())
12674                  oldRow = &#x27; &#x27; + oldRow;
12675              while (oldRow.size() &gt; row.size())
12676                  row = &#x27; &#x27; + row;
12677          }
12678          rows.push_back(row);
12679          return *this;
12680      }
12681      std::string label;
12682      Colour::Code colour;
12683      std::vector&lt;std::string&gt; rows;
12684  };
12685  void ConsoleReporter::printTotals( Totals const&amp; totals ) {
12686      if (totals.testCases.total() == 0) {
12687          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;No tests ran\n&quot;;
12688      } else if (totals.assertions.total() &gt; 0 &amp;&amp; totals.testCases.allPassed()) {
12689          stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; &quot;All tests passed&quot;;
12690          stream &lt;&lt; &quot; (&quot;
12691              &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &quot; in &quot;
12692              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt; &#x27;)&#x27;
12693              &lt;&lt; &#x27;\n&#x27;;
12694      } else {
12695          std::vector&lt;SummaryColumn&gt; columns;
12696          columns.push_back(SummaryColumn(&quot;&quot;, Colour::None)
12697                            .addRow(totals.testCases.total())
12698                            .addRow(totals.assertions.total()));
12699          columns.push_back(SummaryColumn(&quot;passed&quot;, Colour::Success)
12700                            .addRow(totals.testCases.passed)
12701                            .addRow(totals.assertions.passed));
12702          columns.push_back(SummaryColumn(&quot;failed&quot;, Colour::ResultError)
12703                            .addRow(totals.testCases.failed)
12704                            .addRow(totals.assertions.failed));
12705          columns.push_back(SummaryColumn(&quot;failed as expected&quot;, Colour::ResultExpectedFailure)
12706                            .addRow(totals.testCases.failedButOk)
12707                            .addRow(totals.assertions.failedButOk));
12708          printSummaryRow(&quot;test cases&quot;, columns, 0);
12709          printSummaryRow(&quot;assertions&quot;, columns, 1);
12710      }
12711  }
12712  void ConsoleReporter::printSummaryRow(std::string const&amp; label, std::vector&lt;SummaryColumn&gt; const&amp; cols, std::size_t row) {
12713      for (auto col : cols) {
12714          std::string value = col.rows[row];
12715          if (col.label.empty()) {
12716              stream &lt;&lt; label &lt;&lt; &quot;: &quot;;
12717              if (value != &quot;0&quot;)
12718                  stream &lt;&lt; value;
12719              else
12720                  stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;- none -&quot;;
12721          } else if (value != &quot;0&quot;) {
12722              stream &lt;&lt; Colour(Colour::LightGrey) &lt;&lt; &quot; | &quot;;
12723              stream &lt;&lt; Colour(col.colour)
12724                  &lt;&lt; value &lt;&lt; &#x27; &#x27; &lt;&lt; col.label;
12725          }
12726      }
12727      stream &lt;&lt; &#x27;\n&#x27;;
12728  }
12729  void ConsoleReporter::printTotalsDivider(Totals const&amp; totals) {
12730      if (totals.testCases.total() &gt; 0) {
12731          std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
12732          std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
12733          std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
12734          while (failedRatio + failedButOkRatio + passedRatio &lt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12735              findMax(failedRatio, failedButOkRatio, passedRatio)++;
12736          while (failedRatio + failedButOkRatio + passedRatio &gt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12737              findMax(failedRatio, failedButOkRatio, passedRatio)--;
12738          stream &lt;&lt; Colour(Colour::Error) &lt;&lt; std::string(failedRatio, &#x27;=&#x27;);
12739          stream &lt;&lt; Colour(Colour::ResultExpectedFailure) &lt;&lt; std::string(failedButOkRatio, &#x27;=&#x27;);
12740          if (totals.testCases.allPassed())
12741              stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12742          else
12743              stream &lt;&lt; Colour(Colour::Success) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12744      } else {
12745          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, &#x27;=&#x27;);
12746      }
12747      stream &lt;&lt; &#x27;\n&#x27;;
12748  }
12749  void ConsoleReporter::printSummaryDivider() {
12750      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12751  }
12752  void ConsoleReporter::printTestFilters() {
12753      if (m_config-&gt;testSpec().hasFilters()) {
12754          Colour guard(Colour::BrightYellow);
12755          stream &lt;&lt; &quot;Filters: &quot; &lt;&lt; serializeFilters(m_config-&gt;getTestsOrTags()) &lt;&lt; &#x27;\n&#x27;;
12756      }
12757  }
12758  CATCH_REGISTER_REPORTER(&quot;console&quot;, ConsoleReporter)
12759  } 
12760  #if defined(_MSC_VER)
12761  #pragma warning(pop)
12762  #endif
12763  #if defined(__clang__)
12764  #  pragma clang diagnostic pop
12765  #endif
12766  #include &lt;cassert&gt;
12767  #include &lt;sstream&gt;
12768  #include &lt;ctime&gt;
12769  #include &lt;algorithm&gt;
12770  #include &lt;iomanip&gt;
12771  namespace Catch {
12772      namespace {
12773          std::string getCurrentTimestamp() {
12774              time_t rawtime;
12775              std::time(&amp;rawtime);
12776              auto const timeStampSize = sizeof(&quot;2017-01-16T17:06:45Z&quot;);
12777  #ifdef _MSC_VER
12778              std::tm timeInfo = {};
12779              gmtime_s(&amp;timeInfo, &amp;rawtime);
12780  #else
12781              std::tm* timeInfo;
12782              timeInfo = std::gmtime(&amp;rawtime);
12783  #endif
12784              char timeStamp[timeStampSize];
12785              const char * const fmt = &quot;%Y-%m-%dT%H:%M:%SZ&quot;;
12786  #ifdef _MSC_VER
12787              std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
12788  #else
12789              std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
12790  #endif
12791              return std::string(timeStamp, timeStampSize-1);
12792          }
12793          std::string fileNameTag(const std::vector&lt;std::string&gt; &amp;tags) {
12794              auto it = std::find_if(begin(tags),
12795                                     end(tags),
12796                                     [] (std::string const&amp; tag) {return tag.front() == &#x27;#&#x27;; });
12797              if (it != tags.end())
12798                  return it-&gt;substr(1);
12799              return std::string();
12800          }
12801          std::string formatDuration( double seconds ) {
12802              ReusableStringStream rss;
12803              rss &lt;&lt; std::fixed &lt;&lt; std::setprecision( 3 ) &lt;&lt; seconds;
12804              return rss.str();
12805          }
12806      } 
12807      JunitReporter::JunitReporter( ReporterConfig const&amp; _config )
12808          :   CumulativeReporterBase( _config ),
12809              xml( _config.stream() )
12810          {
12811              m_reporterPrefs.shouldRedirectStdOut = true;
12812              m_reporterPrefs.shouldReportAllAssertions = true;
12813          }
12814      JunitReporter::~JunitReporter() {}
12815      std::string JunitReporter::getDescription() {
12816          return &quot;Reports test results in an XML format that looks like Ant&#x27;s junitreport target&quot;;
12817      }
12818      void JunitReporter::noMatchingTestCases( std::string const&amp; &amp;bsol;*spec*/ ) {}
12819      void JunitReporter::testRunStarting( TestRunInfo const&amp; runInfo )  {
12820          CumulativeReporterBase::testRunStarting( runInfo );
12821          xml.startElement( &quot;testsuites&quot; );
12822      }
12823      void JunitReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
12824          suiteTimer.start();
12825          stdOutForSuite.clear();
12826          stdErrForSuite.clear();
12827          unexpectedExceptions = 0;
12828          CumulativeReporterBase::testGroupStarting( groupInfo );
12829      }
12830      void JunitReporter::testCaseStarting( TestCaseInfo const&amp; testCaseInfo ) {
12831          m_okToFail = testCaseInfo.okToFail();
12832      }
12833      bool JunitReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
12834          if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException &amp;&amp; !m_okToFail )
12835              unexpectedExceptions++;
12836          return CumulativeReporterBase::assertionEnded( assertionStats );
12837      }
12838      void JunitReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
12839          stdOutForSuite += testCaseStats.stdOut;
12840          stdErrForSuite += testCaseStats.stdErr;
12841          CumulativeReporterBase::testCaseEnded( testCaseStats );
12842      }
12843      void JunitReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
12844          double suiteTime = suiteTimer.getElapsedSeconds();
12845          CumulativeReporterBase::testGroupEnded( testGroupStats );
12846          writeGroup( *m_testGroups.back(), suiteTime );
12847      }
12848      void JunitReporter::testRunEndedCumulative() {
12849          xml.endElement();
12850      }
12851      void JunitReporter::writeGroup( TestGroupNode const&amp; groupNode, double suiteTime ) {
12852          XmlWriter::ScopedElement e = xml.scopedElement( &quot;testsuite&quot; );
12853          TestGroupStats const&amp; stats = groupNode.value;
12854          xml.writeAttribute( &quot;name&quot;, stats.groupInfo.name );
12855          xml.writeAttribute( &quot;errors&quot;, unexpectedExceptions );
12856          xml.writeAttribute( &quot;failures&quot;, stats.totals.assertions.failed-unexpectedExceptions );
12857          xml.writeAttribute( &quot;tests&quot;, stats.totals.assertions.total() );
12858          xml.writeAttribute( &quot;hostname&quot;, &quot;tbd&quot; ); 
12859          if( m_config-&gt;showDurations() == ShowDurations::Never )
12860              xml.writeAttribute( &quot;time&quot;, &quot;&quot; );
12861          else
12862              xml.writeAttribute( &quot;time&quot;, formatDuration( suiteTime ) );
12863          xml.writeAttribute( &quot;timestamp&quot;, getCurrentTimestamp() );
12864          if (m_config-&gt;hasTestFilters() || m_config-&gt;rngSeed() != 0) {
12865              auto properties = xml.scopedElement(&quot;properties&quot;);
12866              if (m_config-&gt;hasTestFilters()) {
12867                  xml.scopedElement(&quot;property&quot;)
12868                      .writeAttribute(&quot;name&quot;, &quot;filters&quot;)
12869                      .writeAttribute(&quot;value&quot;, serializeFilters(m_config-&gt;getTestsOrTags()));
12870              }
12871              if (m_config-&gt;rngSeed() != 0) {
12872                  xml.scopedElement(&quot;property&quot;)
12873                      .writeAttribute(&quot;name&quot;, &quot;random-seed&quot;)
12874                      .writeAttribute(&quot;value&quot;, m_config-&gt;rngSeed());
12875              }
12876          }
12877          for( auto const&amp; child : groupNode.children )
12878              writeTestCase( *child );
12879          xml.scopedElement( &quot;system-out&quot; ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
12880          xml.scopedElement( &quot;system-err&quot; ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
12881      }
12882      void JunitReporter::writeTestCase( TestCaseNode const&amp; testCaseNode ) {
12883          TestCaseStats const&amp; stats = testCaseNode.value;
12884          assert( testCaseNode.children.size() == 1 );
12885          SectionNode const&amp; rootSection = *testCaseNode.children.front();
12886          std::string className = stats.testInfo.className;
12887          if( className.empty() ) {
12888              className = fileNameTag(stats.testInfo.tags);
12889              if ( className.empty() )
12890                  className = &quot;global&quot;;
12891          }
12892          if ( !m_config-&gt;name().empty() )
12893              className = m_config-&gt;name() + &quot;.&quot; + className;
12894          writeSection( className, &quot;&quot;, rootSection, stats.testInfo.okToFail() );
12895      }
12896      void JunitReporter::writeSection( std::string const&amp; className,
12897                                        std::string const&amp; rootName,
12898                                        SectionNode const&amp; sectionNode,
12899                                        bool testOkToFail) {
12900          std::string name = trim( sectionNode.stats.sectionInfo.name );
12901          if( !rootName.empty() )
12902              name = rootName + &#x27;/&#x27; + name;
12903          if( !sectionNode.assertions.empty() ||
12904              !sectionNode.stdOut.empty() ||
12905              !sectionNode.stdErr.empty() ) {
12906              XmlWriter::ScopedElement e = xml.scopedElement( &quot;testcase&quot; );
12907              if( className.empty() ) {
12908                  xml.writeAttribute( &quot;classname&quot;, name );
12909                  xml.writeAttribute( &quot;name&quot;, &quot;root&quot; );
12910              }
12911              else {
12912                  xml.writeAttribute( &quot;classname&quot;, className );
12913                  xml.writeAttribute( &quot;name&quot;, name );
12914              }
12915              xml.writeAttribute( &quot;time&quot;, formatDuration( sectionNode.stats.durationInSeconds ) );
12916              xml.writeAttribute( &quot;status&quot;, &quot;run&quot; );
12917              if (sectionNode.stats.assertions.failedButOk) {
12918                  xml.scopedElement(&quot;skipped&quot;)
12919                      .writeAttribute(&quot;message&quot;, &quot;TEST_CASE tagged with !mayfail&quot;);
12920              }
12921              writeAssertions( sectionNode );
12922              if( !sectionNode.stdOut.empty() )
12923                  xml.scopedElement( &quot;system-out&quot; ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
12924              if( !sectionNode.stdErr.empty() )
12925                  xml.scopedElement( &quot;system-err&quot; ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
12926          }
12927          for( auto const&amp; childNode : sectionNode.childSections )
12928              if( className.empty() )
12929                  writeSection( name, &quot;&quot;, *childNode, testOkToFail );
12930              else
12931                  writeSection( className, name, *childNode, testOkToFail );
12932      }
12933      void JunitReporter::writeAssertions( SectionNode const&amp; sectionNode ) {
12934          for( auto const&amp; assertion : sectionNode.assertions )
12935              writeAssertion( assertion );
12936      }
12937      void JunitReporter::writeAssertion( AssertionStats const&amp; stats ) {
12938          AssertionResult const&amp; result = stats.assertionResult;
12939          if( !result.isOk() ) {
12940              std::string elementName;
12941              switch( result.getResultType() ) {
12942                  case ResultWas::ThrewException:
12943                  case ResultWas::FatalErrorCondition:
12944                      elementName = &quot;error&quot;;
12945                      break;
12946                  case ResultWas::ExplicitFailure:
12947                  case ResultWas::ExpressionFailed:
12948                  case ResultWas::DidntThrowException:
12949                      elementName = &quot;failure&quot;;
12950                      break;
12951                  case ResultWas::Info:
12952                  case ResultWas::Warning:
12953                  case ResultWas::Ok:
12954                  case ResultWas::Unknown:
12955                  case ResultWas::FailureBit:
12956                  case ResultWas::Exception:
12957                      elementName = &quot;internalError&quot;;
12958                      break;
12959              }
12960              XmlWriter::ScopedElement e = xml.scopedElement( elementName );
12961              xml.writeAttribute( &quot;message&quot;, result.getExpression() );
12962              xml.writeAttribute( &quot;type&quot;, result.getTestMacroName() );
12963              ReusableStringStream rss;
12964              if (stats.totals.assertions.total() &gt; 0) {
12965                  rss &lt;&lt; &quot;FAILED&quot; &lt;&lt; &quot;:\n&quot;;
12966                  if (result.hasExpression()) {
12967                      rss &lt;&lt; &quot;  &quot;;
12968                      rss &lt;&lt; result.getExpressionInMacro();
12969                      rss &lt;&lt; &#x27;\n&#x27;;
12970                  }
12971                  if (result.hasExpandedExpression()) {
12972                      rss &lt;&lt; &quot;with expansion:\n&quot;;
12973                      rss &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12974                  }
12975              } else {
12976                  rss &lt;&lt; &#x27;\n&#x27;;
12977              }
12978              if( !result.getMessage().empty() )
12979                  rss &lt;&lt; result.getMessage() &lt;&lt; &#x27;\n&#x27;;
12980              for( auto const&amp; msg : stats.infoMessages )
12981                  if( msg.type == ResultWas::Info )
12982                      rss &lt;&lt; msg.message &lt;&lt; &#x27;\n&#x27;;
12983              rss &lt;&lt; &quot;at &quot; &lt;&lt; result.getSourceInfo();
12984              xml.writeText( rss.str(), XmlFormatting::Newline );
12985          }
12986      }
12987      CATCH_REGISTER_REPORTER( &quot;junit&quot;, JunitReporter )
12988  } 
12989  #include &lt;cassert&gt;
12990  namespace Catch {
12991      ListeningReporter::ListeningReporter() {
12992          m_preferences.shouldReportAllAssertions = true;
12993      }
12994      void ListeningReporter::addListener( IStreamingReporterPtr&amp;&amp; listener ) {
12995          m_listeners.push_back( std::move( listener ) );
12996      }
12997      void ListeningReporter::addReporter(IStreamingReporterPtr&amp;&amp; reporter) {
12998          assert(!m_reporter &amp;&amp; &quot;Listening reporter can wrap only 1 real reporter&quot;);
12999          m_reporter = std::move( reporter );
13000          m_preferences.shouldRedirectStdOut = m_reporter-&gt;getPreferences().shouldRedirectStdOut;
13001      }
13002      ReporterPreferences ListeningReporter::getPreferences() const {
13003          return m_preferences;
13004      }
13005      std::set&lt;Verbosity&gt; ListeningReporter::getSupportedVerbosities() {
13006          return std::set&lt;Verbosity&gt;{ };
13007      }
13008      void ListeningReporter::noMatchingTestCases( std::string const&amp; spec ) {
13009          for ( auto const&amp; listener : m_listeners ) {
13010              listener-&gt;noMatchingTestCases( spec );
13011          }
13012          m_reporter-&gt;noMatchingTestCases( spec );
13013      }
13014      void ListeningReporter::reportInvalidArguments(std::string const&amp;arg){
13015          for ( auto const&amp; listener : m_listeners ) {
13016              listener-&gt;reportInvalidArguments( arg );
13017          }
13018          m_reporter-&gt;reportInvalidArguments( arg );
13019      }
13020  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13021      void ListeningReporter::benchmarkPreparing( std::string const&amp; name ) {
13022  		for (auto const&amp; listener : m_listeners) {
13023  			listener-&gt;benchmarkPreparing(name);
13024  		}
13025  		m_reporter-&gt;benchmarkPreparing(name);
13026  	}
13027      void ListeningReporter::benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) {
13028          for ( auto const&amp; listener : m_listeners ) {
13029              listener-&gt;benchmarkStarting( benchmarkInfo );
13030          }
13031          m_reporter-&gt;benchmarkStarting( benchmarkInfo );
13032      }
13033      void ListeningReporter::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) {
13034          for ( auto const&amp; listener : m_listeners ) {
13035              listener-&gt;benchmarkEnded( benchmarkStats );
13036          }
13037          m_reporter-&gt;benchmarkEnded( benchmarkStats );
13038      }
13039  	void ListeningReporter::benchmarkFailed( std::string const&amp; error ) {
13040  		for (auto const&amp; listener : m_listeners) {
13041  			listener-&gt;benchmarkFailed(error);
13042  		}
13043  		m_reporter-&gt;benchmarkFailed(error);
13044  	}
13045  #endif 
13046      void ListeningReporter::testRunStarting( TestRunInfo const&amp; testRunInfo ) {
13047          for ( auto const&amp; listener : m_listeners ) {
13048              listener-&gt;testRunStarting( testRunInfo );
13049          }
13050          m_reporter-&gt;testRunStarting( testRunInfo );
13051      }
13052      void ListeningReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13053          for ( auto const&amp; listener : m_listeners ) {
13054              listener-&gt;testGroupStarting( groupInfo );
13055          }
13056          m_reporter-&gt;testGroupStarting( groupInfo );
13057      }
13058      void ListeningReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13059          for ( auto const&amp; listener : m_listeners ) {
13060              listener-&gt;testCaseStarting( testInfo );
13061          }
13062          m_reporter-&gt;testCaseStarting( testInfo );
13063      }
13064      void ListeningReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13065          for ( auto const&amp; listener : m_listeners ) {
13066              listener-&gt;sectionStarting( sectionInfo );
13067          }
13068          m_reporter-&gt;sectionStarting( sectionInfo );
13069      }
13070      void ListeningReporter::assertionStarting( AssertionInfo const&amp; assertionInfo ) {
13071          for ( auto const&amp; listener : m_listeners ) {
13072              listener-&gt;assertionStarting( assertionInfo );
13073          }
13074          m_reporter-&gt;assertionStarting( assertionInfo );
13075      }
13076      bool ListeningReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13077          for( auto const&amp; listener : m_listeners ) {
13078              static_cast&lt;void&gt;( listener-&gt;assertionEnded( assertionStats ) );
13079          }
13080          return m_reporter-&gt;assertionEnded( assertionStats );
13081      }
13082      void ListeningReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13083          for ( auto const&amp; listener : m_listeners ) {
13084              listener-&gt;sectionEnded( sectionStats );
13085          }
13086          m_reporter-&gt;sectionEnded( sectionStats );
13087      }
13088      void ListeningReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13089          for ( auto const&amp; listener : m_listeners ) {
13090              listener-&gt;testCaseEnded( testCaseStats );
13091          }
13092          m_reporter-&gt;testCaseEnded( testCaseStats );
13093      }
13094      void ListeningReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13095          for ( auto const&amp; listener : m_listeners ) {
13096              listener-&gt;testGroupEnded( testGroupStats );
13097          }
13098          m_reporter-&gt;testGroupEnded( testGroupStats );
13099      }
13100      void ListeningReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13101          for ( auto const&amp; listener : m_listeners ) {
13102              listener-&gt;testRunEnded( testRunStats );
13103          }
13104          m_reporter-&gt;testRunEnded( testRunStats );
13105      }
13106      void ListeningReporter::skipTest( TestCaseInfo const&amp; testInfo ) {
13107          for ( auto const&amp; listener : m_listeners ) {
13108              listener-&gt;skipTest( testInfo );
13109          }
13110          m_reporter-&gt;skipTest( testInfo );
13111      }
13112      bool ListeningReporter::isMulti() const {
13113          return true;
13114      }
13115  } 
13116  #if defined(_MSC_VER)
13117  #pragma warning(push)
13118  #pragma warning(disable:4061) 
13119  #endif
13120  namespace Catch {
13121      XmlReporter::XmlReporter( ReporterConfig const&amp; _config )
13122      :   StreamingReporterBase( _config ),
13123          m_xml(_config.stream())
13124      {
13125          m_reporterPrefs.shouldRedirectStdOut = true;
13126          m_reporterPrefs.shouldReportAllAssertions = true;
13127      }
13128      XmlReporter::~XmlReporter() = default;
13129      std::string XmlReporter::getDescription() {
13130          return &quot;Reports test results as an XML document&quot;;
13131      }
13132      std::string XmlReporter::getStylesheetRef() const {
13133          return std::string();
13134      }
13135      void XmlReporter::writeSourceInfo( SourceLineInfo const&amp; sourceInfo ) {
13136          m_xml
13137              .writeAttribute( &quot;filename&quot;, sourceInfo.file )
13138              .writeAttribute( &quot;line&quot;, sourceInfo.line );
13139      }
13140      void XmlReporter::noMatchingTestCases( std::string const&amp; s ) {
13141          StreamingReporterBase::noMatchingTestCases( s );
13142      }
13143      void XmlReporter::testRunStarting( TestRunInfo const&amp; testInfo ) {
13144          StreamingReporterBase::testRunStarting( testInfo );
13145          std::string stylesheetRef = getStylesheetRef();
13146          if( !stylesheetRef.empty() )
13147              m_xml.writeStylesheetRef( stylesheetRef );
13148          m_xml.startElement( &quot;Catch&quot; );
13149          if( !m_config-&gt;name().empty() )
13150              m_xml.writeAttribute( &quot;name&quot;, m_config-&gt;name() );
13151          if (m_config-&gt;testSpec().hasFilters())
13152              m_xml.writeAttribute( &quot;filters&quot;, serializeFilters( m_config-&gt;getTestsOrTags() ) );
13153          if( m_config-&gt;rngSeed() != 0 )
13154              m_xml.scopedElement( &quot;Randomness&quot; )
13155                  .writeAttribute( &quot;seed&quot;, m_config-&gt;rngSeed() );
13156      }
13157      void XmlReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13158          StreamingReporterBase::testGroupStarting( groupInfo );
13159          m_xml.startElement( &quot;Group&quot; )
13160              .writeAttribute( &quot;name&quot;, groupInfo.name );
13161      }
13162      void XmlReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13163          StreamingReporterBase::testCaseStarting(testInfo);
13164          m_xml.startElement( &quot;TestCase&quot; )
13165              .writeAttribute( &quot;name&quot;, trim( testInfo.name ) )
13166              .writeAttribute( &quot;description&quot;, testInfo.description )
13167              .writeAttribute( &quot;tags&quot;, testInfo.tagsAsString() );
13168          writeSourceInfo( testInfo.lineInfo );
13169          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13170              m_testCaseTimer.start();
13171          m_xml.ensureTagClosed();
13172      }
13173      void XmlReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13174          StreamingReporterBase::sectionStarting( sectionInfo );
13175          if( m_sectionDepth++ &gt; 0 ) {
13176              m_xml.startElement( &quot;Section&quot; )
13177                  .writeAttribute( &quot;name&quot;, trim( sectionInfo.name ) );
13178              writeSourceInfo( sectionInfo.lineInfo );
13179              m_xml.ensureTagClosed();
13180          }
13181      }
13182      void XmlReporter::assertionStarting( AssertionInfo const&amp; ) { }
13183      bool XmlReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13184          AssertionResult const&amp; result = assertionStats.assertionResult;
13185          bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
13186          if( includeResults || result.getResultType() == ResultWas::Warning ) {
13187              for( auto const&amp; msg : assertionStats.infoMessages ) {
13188                  if( msg.type == ResultWas::Info &amp;&amp; includeResults ) {
13189                      m_xml.scopedElement( &quot;Info&quot; )
13190                              .writeText( msg.message );
13191                  } else if ( msg.type == ResultWas::Warning ) {
13192                      m_xml.scopedElement( &quot;Warning&quot; )
13193                              .writeText( msg.message );
13194                  }
13195              }
13196          }
13197          if( !includeResults &amp;&amp; result.getResultType() != ResultWas::Warning )
13198              return true;
13199          if( result.hasExpression() ) {
13200              m_xml.startElement( &quot;Expression&quot; )
13201                  .writeAttribute( &quot;success&quot;, result.succeeded() )
13202                  .writeAttribute( &quot;type&quot;, result.getTestMacroName() );
13203              writeSourceInfo( result.getSourceInfo() );
13204              m_xml.scopedElement( &quot;Original&quot; )
13205                  .writeText( result.getExpression() );
13206              m_xml.scopedElement( &quot;Expanded&quot; )
13207                  .writeText( result.getExpandedExpression() );
13208          }
13209          switch( result.getResultType() ) {
13210              case ResultWas::ThrewException:
13211                  m_xml.startElement( &quot;Exception&quot; );
13212                  writeSourceInfo( result.getSourceInfo() );
13213                  m_xml.writeText( result.getMessage() );
13214                  m_xml.endElement();
13215                  break;
13216              case ResultWas::FatalErrorCondition:
13217                  m_xml.startElement( &quot;FatalErrorCondition&quot; );
13218                  writeSourceInfo( result.getSourceInfo() );
13219                  m_xml.writeText( result.getMessage() );
13220                  m_xml.endElement();
13221                  break;
13222              case ResultWas::Info:
13223                  m_xml.scopedElement( &quot;Info&quot; )
13224                      .writeText( result.getMessage() );
13225                  break;
13226              case ResultWas::Warning:
13227                  break;
13228              case ResultWas::ExplicitFailure:
13229                  m_xml.startElement( &quot;Failure&quot; );
13230                  writeSourceInfo( result.getSourceInfo() );
13231                  m_xml.writeText( result.getMessage() );
13232                  m_xml.endElement();
13233                  break;
13234              default:
13235                  break;
13236          }
13237          if( result.hasExpression() )
13238              m_xml.endElement();
13239          return true;
13240      }
13241      void XmlReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13242          StreamingReporterBase::sectionEnded( sectionStats );
13243          if( --m_sectionDepth &gt; 0 ) {
13244              XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResults&quot; );
13245              e.writeAttribute( &quot;successes&quot;, sectionStats.assertions.passed );
13246              e.writeAttribute( &quot;failures&quot;, sectionStats.assertions.failed );
13247              e.writeAttribute( &quot;expectedFailures&quot;, sectionStats.assertions.failedButOk );
13248              if ( m_config-&gt;showDurations() == ShowDurations::Always )
13249                  e.writeAttribute( &quot;durationInSeconds&quot;, sectionStats.durationInSeconds );
13250              m_xml.endElement();
13251          }
13252      }
13253      void XmlReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13254          StreamingReporterBase::testCaseEnded( testCaseStats );
13255          XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResult&quot; );
13256          e.writeAttribute( &quot;success&quot;, testCaseStats.totals.assertions.allOk() );
13257          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13258              e.writeAttribute( &quot;durationInSeconds&quot;, m_testCaseTimer.getElapsedSeconds() );
13259          if( !testCaseStats.stdOut.empty() )
13260              m_xml.scopedElement( &quot;StdOut&quot; ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
13261          if( !testCaseStats.stdErr.empty() )
13262              m_xml.scopedElement( &quot;StdErr&quot; ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );
13263          m_xml.endElement();
13264      }
13265      void XmlReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13266          StreamingReporterBase::testGroupEnded( testGroupStats );
13267          m_xml.scopedElement( &quot;OverallResults&quot; )
13268              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.assertions.passed )
13269              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.assertions.failed )
13270              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.assertions.failedButOk );
13271          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13272              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.testCases.passed )
13273              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.testCases.failed )
13274              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.testCases.failedButOk );
13275          m_xml.endElement();
13276      }
13277      void XmlReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13278          StreamingReporterBase::testRunEnded( testRunStats );
13279          m_xml.scopedElement( &quot;OverallResults&quot; )
13280              .writeAttribute( &quot;successes&quot;, testRunStats.totals.assertions.passed )
13281              .writeAttribute( &quot;failures&quot;, testRunStats.totals.assertions.failed )
13282              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.assertions.failedButOk );
13283          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13284              .writeAttribute( &quot;successes&quot;, testRunStats.totals.testCases.passed )
13285              .writeAttribute( &quot;failures&quot;, testRunStats.totals.testCases.failed )
13286              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.testCases.failedButOk );
13287          m_xml.endElement();
13288      }
13289  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13290      void XmlReporter::benchmarkPreparing(std::string const&amp; name) {
13291          m_xml.startElement(&quot;BenchmarkResults&quot;)
13292              .writeAttribute(&quot;name&quot;, name);
13293      }
13294      void XmlReporter::benchmarkStarting(BenchmarkInfo const &amp;info) {
13295          m_xml.writeAttribute(&quot;samples&quot;, info.samples)
13296              .writeAttribute(&quot;resamples&quot;, info.resamples)
13297              .writeAttribute(&quot;iterations&quot;, info.iterations)
13298              .writeAttribute(&quot;clockResolution&quot;, info.clockResolution)
13299              .writeAttribute(&quot;estimatedDuration&quot;, info.estimatedDuration)
13300              .writeComment(&quot;All values in nano seconds&quot;);
13301      }
13302      void XmlReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; benchmarkStats) {
13303          m_xml.startElement(&quot;mean&quot;)
13304              .writeAttribute(&quot;value&quot;, benchmarkStats.mean.point.count())
13305              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.mean.lower_bound.count())
13306              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.mean.upper_bound.count())
13307              .writeAttribute(&quot;ci&quot;, benchmarkStats.mean.confidence_interval);
13308          m_xml.endElement();
13309          m_xml.startElement(&quot;standardDeviation&quot;)
13310              .writeAttribute(&quot;value&quot;, benchmarkStats.standardDeviation.point.count())
13311              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.standardDeviation.lower_bound.count())
13312              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.standardDeviation.upper_bound.count())
13313              .writeAttribute(&quot;ci&quot;, benchmarkStats.standardDeviation.confidence_interval);
13314          m_xml.endElement();
13315          m_xml.startElement(&quot;outliers&quot;)
13316              .writeAttribute(&quot;variance&quot;, benchmarkStats.outlierVariance)
13317              .writeAttribute(&quot;lowMild&quot;, benchmarkStats.outliers.low_mild)
13318              .writeAttribute(&quot;lowSevere&quot;, benchmarkStats.outliers.low_severe)
13319              .writeAttribute(&quot;highMild&quot;, benchmarkStats.outliers.high_mild)
13320              .writeAttribute(&quot;highSevere&quot;, benchmarkStats.outliers.high_severe);
13321          m_xml.endElement();
13322          m_xml.endElement();
13323      }
13324      void XmlReporter::benchmarkFailed(std::string const &amp;error) {
13325          m_xml.scopedElement(&quot;failed&quot;).
13326              writeAttribute(&quot;message&quot;, error);
13327          m_xml.endElement();
13328      }
13329  #endif 
13330      CATCH_REGISTER_REPORTER( &quot;xml&quot;, XmlReporter )
13331  } 
13332  #if defined(_MSC_VER)
13333  #pragma warning(pop)
13334  #endif
13335  namespace Catch {
13336      LeakDetector leakDetector;
13337  }
13338  #ifdef __clang__
13339  #pragma clang diagnostic pop
13340  #endif
13341  #endif
13342  #ifdef CATCH_CONFIG_MAIN
13343  #ifndef __OBJC__
13344  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; defined(_UNICODE) &amp;&amp; !defined(DO_NOT_USE_WMAIN)
13345  extern &quot;C&quot; int wmain (int argc, wchar_t * argv[], wchar_t * []) {
13346  #else
13347  int main (int argc, char * argv[]) {
13348  #endif
13349      return Catch::Session().run( argc, argv );
13350  }
13351  #else 
13352  int main (int argc, char * const argv[]) {
13353  #if !CATCH_ARC_ENABLED
13354      NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
13355  #endif
13356      Catch::registerTestMethods();
13357      int result = Catch::Session().run( argc, (char**)argv );
13358  #if !CATCH_ARC_ENABLED
13359      [pool drain];
13360  #endif
13361      return result;
13362  }
13363  #endif 
13364  #endif
13365  #if !defined(CATCH_CONFIG_IMPL_ONLY)
13366  #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
13367  #  undef CLARA_CONFIG_MAIN
13368  #endif
13369  #if !defined(CATCH_CONFIG_DISABLE)
13370  #ifdef CATCH_CONFIG_PREFIX_ALL
13371  #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13372  #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13373  #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;CATCH_REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13374  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13375  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13376  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13377  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13378  #endif
13379  #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13380  #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13381  #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13382  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CATCH_CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13383  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CATCH_CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13384  #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13385  #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CATCH_CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13386  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13387  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13388  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13389  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13390  #endif 
13391  #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13392  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13393  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13394  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13395  #endif 
13396  #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( &quot;CATCH_INFO&quot;, msg )
13397  #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;CATCH_UNSCOPED_INFO&quot;, msg )
13398  #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( &quot;CATCH_WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13399  #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CATCH_CAPTURE&quot;,__VA_ARGS__ )
13400  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13401  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13402  #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13403  #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13404  #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13405  #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13406  #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13407  #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13408  #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13409  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13410  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13411  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13412  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13413  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13414  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13415  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13416  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13417  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13418  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13419  #else
13420  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13421  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13422  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13423  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13424  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13425  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13426  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13427  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13428  #endif
13429  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13430  #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
13431  #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); CATCH_SUCCEED( #__VA_ARGS__ )
13432  #else
13433  #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
13434  #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
13435  #endif
13436  #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13437  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13438  #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13439  #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13440  #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13441  #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13442  #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13443  #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13444  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13445  #define CATCH_BENCHMARK(...) \
13446      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13447  #define CATCH_BENCHMARK_ADVANCED(name) \
13448      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13449  #endif 
13450  #else
13451  #define REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__  )
13452  #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13453  #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13454  #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13455  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13456  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13457  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13458  #endif 
13459  #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13460  #define CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13461  #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13462  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13463  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13464  #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13465  #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13466  #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13467  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13468  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13469  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13470  #endif 
13471  #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13472  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13473  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13474  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13475  #endif 
13476  #define INFO( msg ) INTERNAL_CATCH_INFO( &quot;INFO&quot;, msg )
13477  #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;UNSCOPED_INFO&quot;, msg )
13478  #define WARN( msg ) INTERNAL_CATCH_MSG( &quot;WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13479  #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CAPTURE&quot;,__VA_ARGS__ )
13480  #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13481  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13482  #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13483  #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13484  #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13485  #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13486  #define FAIL( ... ) INTERNAL_CATCH_MSG( &quot;FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13487  #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13488  #define SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13489  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13490  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13491  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13492  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13493  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13494  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13495  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13496  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13497  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13498  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13499  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
13500  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
13501  #else
13502  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13503  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13504  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13505  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13506  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13507  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13508  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13509  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13510  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
13511  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13512  #endif
13513  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13514  #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
13515  #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); SUCCEED( &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; )
13516  #else
13517  #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
13518  #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
13519  #endif
13520  #endif
13521  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
13522  #define SCENARIO( ... ) TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13523  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13524  #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13525  #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13526  #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13527  #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13528  #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13529  #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13530  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13531  #define BENCHMARK(...) \
13532      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13533  #define BENCHMARK_ADVANCED(name) \
13534      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13535  #endif 
13536  using Catch::Detail::Approx;
13537  #else 
13538  #ifdef CATCH_CONFIG_PREFIX_ALL
13539  #define CATCH_REQUIRE( ... )        (void)(0)
13540  #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
13541  #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
13542  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13543  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
13544  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13545  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13546  #endif
13547  #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
13548  #define CATCH_CHECK( ... )         (void)(0)
13549  #define CATCH_CHECK_FALSE( ... )   (void)(0)
13550  #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
13551  #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
13552  #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
13553  #define CATCH_CHECK_THROWS( ... )  (void)(0)
13554  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13555  #define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
13556  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13557  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13558  #endif 
13559  #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
13560  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13561  #define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
13562  #define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
13563  #endif 
13564  #define CATCH_INFO( msg )          (void)(0)
13565  #define CATCH_UNSCOPED_INFO( msg ) (void)(0)
13566  #define CATCH_WARN( msg )          (void)(0)
13567  #define CATCH_CAPTURE( msg )       (void)(0)
13568  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13569  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13570  #define CATCH_METHOD_AS_TEST_CASE( method, ... )
13571  #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
13572  #define CATCH_SECTION( ... )
13573  #define CATCH_DYNAMIC_SECTION( ... )
13574  #define CATCH_FAIL( ... ) (void)(0)
13575  #define CATCH_FAIL_CHECK( ... ) (void)(0)
13576  #define CATCH_SUCCEED( ... ) (void)(0)
13577  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13578  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13579  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13580  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13581  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13582  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13583  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13584  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13585  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13586  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13587  #else
13588  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13589  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13590  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13591  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13592  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13593  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13594  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13595  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13596  #endif
13597  #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13598  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13599  #define CATCH_GIVEN( desc )
13600  #define CATCH_AND_GIVEN( desc )
13601  #define CATCH_WHEN( desc )
13602  #define CATCH_AND_WHEN( desc )
13603  #define CATCH_THEN( desc )
13604  #define CATCH_AND_THEN( desc )
13605  #define CATCH_STATIC_REQUIRE( ... )       (void)(0)
13606  #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
13607  #else
13608  #define REQUIRE( ... )       (void)(0)
13609  #define REQUIRE_FALSE( ... ) (void)(0)
13610  #define REQUIRE_THROWS( ... ) (void)(0)
13611  #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13612  #define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
13613  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13614  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13615  #endif 
13616  #define REQUIRE_NOTHROW( ... ) (void)(0)
13617  #define CHECK( ... ) (void)(0)
13618  #define CHECK_FALSE( ... ) (void)(0)
13619  #define CHECKED_IF( ... ) if (__VA_ARGS__)
13620  #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
13621  #define CHECK_NOFAIL( ... ) (void)(0)
13622  #define CHECK_THROWS( ... )  (void)(0)
13623  #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13624  #define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
13625  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13626  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13627  #endif 
13628  #define CHECK_NOTHROW( ... ) (void)(0)
13629  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13630  #define CHECK_THAT( arg, matcher ) (void)(0)
13631  #define REQUIRE_THAT( arg, matcher ) (void)(0)
13632  #endif 
13633  #define INFO( msg ) (void)(0)
13634  #define UNSCOPED_INFO( msg ) (void)(0)
13635  #define WARN( msg ) (void)(0)
13636  #define CAPTURE( msg ) (void)(0)
13637  #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13638  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13639  #define METHOD_AS_TEST_CASE( method, ... )
13640  #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
13641  #define SECTION( ... )
13642  #define DYNAMIC_SECTION( ... )
13643  #define FAIL( ... ) (void)(0)
13644  #define FAIL_CHECK( ... ) (void)(0)
13645  #define SUCCEED( ... ) (void)(0)
13646  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13647  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13648  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13649  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13650  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13651  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13652  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13653  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13654  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13655  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13656  #else
13657  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13658  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13659  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13660  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13661  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13662  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13663  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13664  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13665  #endif
13666  #define STATIC_REQUIRE( ... )       (void)(0)
13667  #define STATIC_REQUIRE_FALSE( ... ) (void)(0)
13668  #endif
13669  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
13670  #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
13671  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13672  #define GIVEN( desc )
13673  #define AND_GIVEN( desc )
13674  #define WHEN( desc )
13675  #define AND_WHEN( desc )
13676  #define THEN( desc )
13677  #define AND_THEN( desc )
13678  using Catch::Detail::Approx;
13679  #endif
13680  #endif 
13681  #ifdef __clang__
13682  #    ifdef __ICC 
13683  #        pragma warning(pop)
13684  #    else
13685  #        pragma clang diagnostic pop
13686  #    endif
13687  #elif defined __GNUC__
13688  #    pragma GCC diagnostic pop
13689  #endif
13690  #endif 
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-catch_14.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-catch.hpp</div>
                </div>
                <div class="column column_space"><pre><code>6339  					m_len = len;
6340  				} else {
6341  					m_suffix = true;
6342  					m_len = width - 1;
6343  				}
6344  			}
6345  		}
6346  		auto indent() const -&gt; size_t {
6347  			auto initial = m_pos == 0 &amp;&amp; m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
6348  			return initial == std::string::npos ? m_column.m_indent : initial;
6349  		}
6350  		auto addIndentAndSuffix(std::string const &amp;plain) const -&gt; std::string {
6351  			return std::string(indent(), &#x27; &#x27;) + (m_suffix ? plain + &quot;-&quot; : plain);
6352  		}
6353  	public:
6354  		using difference_type = std::ptrdiff_t;
6355  		using value_type = std::string;
6356  		using pointer = value_type * ;
6357  		using reference = value_type &amp; ;
6358  		using iterator_category = std::forward_iterator_tag;
6359  		explicit iterator(Column const&amp; column) : m_column(column) {
6360  			assert(m_column.m_width &gt; m_column.m_indent);
6361  			assert(m_column.m_initialIndent == std::string::npos || m_column.m_width &gt; m_column.m_initialIndent);
6362  			calcLength();
6363  			if (m_len == 0)
6364  				m_stringIndex++; 
6365  		}
6366  		auto operator *() const -&gt; std::string {
6367  			assert(m_stringIndex &lt; m_column.m_strings.size());
6368  			assert(m_pos &lt;= m_end);
6369  			return addIndentAndSuffix(line().substr(m_pos, m_len));
6370  		}
6371  		auto operator ++() -&gt; iterator&amp; {
6372  			m_pos += m_len;
6373  			if (m_pos &lt; line().size() &amp;&amp; line()[m_pos] == &#x27;\n&#x27;)
6374  				m_pos += 1;
6375  			else
6376  				while (m_pos &lt; line().size() &amp;&amp; isWhitespace(line()[m_pos]))
6377  					++m_pos;
6378  			if (m_pos == line().size()) {
6379  				m_pos = 0;
6380  				++m_stringIndex;
6381  			}
6382  			if (m_stringIndex &lt; m_column.m_strings.size())
6383  				calcLength();
6384  			return *this;
6385  		}
6386  		auto operator ++(int) -&gt; iterator {
6387  			iterator prev(*this);
6388  			operator++();
6389  			return prev;
6390  		}
6391  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6392  			return
6393  				m_pos == other.m_pos &amp;&amp;
6394  				m_stringIndex == other.m_stringIndex &amp;&amp;
6395  				&amp;m_column == &amp;other.m_column;
6396  		}
6397  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6398  			return !operator==(other);
6399  		}
6400  	};
6401  	using const_iterator = iterator;
6402  	explicit Column(std::string const&amp; text) { m_strings.push_back(text); }
6403  	auto width(size_t newWidth) -&gt; Column&amp; {
6404  		assert(newWidth &gt; 0);
6405  		m_width = newWidth;
6406  		return *this;
6407  	}
6408  	auto indent(size_t newIndent) -&gt; Column&amp; {
6409  		m_indent = newIndent;
6410  		return *this;
6411  	}
6412  	auto initialIndent(size_t newIndent) -&gt; Column&amp; {
6413  		m_initialIndent = newIndent;
6414  		return *this;
6415  	}
6416  	auto width() const -&gt; size_t { return m_width; }
6417  	auto begin() const -&gt; iterator { return iterator(*this); }
6418  	auto end() const -&gt; iterator { return { *this, m_strings.size() }; }
6419  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Column const&amp; col) {
6420  		bool first = true;
6421  		for (auto line : col) {
6422  			if (first)
6423  				first = false;
6424  			else
6425  				os &lt;&lt; &quot;\n&quot;;
6426  			os &lt;&lt; line;
6427  		}
6428  		return os;
6429  	}
6430  	auto operator + (Column const&amp; other)-&gt;Columns;
6431  	auto toString() const -&gt; std::string {
6432  		std::ostringstream oss;
6433  		oss &lt;&lt; *this;
6434  		return oss.str();
6435  	}
6436  };
6437  class Spacer : public Column {
6438  public:
6439  	explicit Spacer(size_t spaceWidth) : Column(&quot;&quot;) {
6440  		width(spaceWidth);
6441  	}
6442  };
6443  class Columns {
6444  	std::vector&lt;Column&gt; m_columns;
6445  public:
6446  	class iterator {
6447  		friend Columns;
6448  		struct EndTag {};
6449  		std::vector&lt;Column&gt; const&amp; m_columns;
6450  		std::vector&lt;Column::iterator&gt; m_iterators;
6451  		size_t m_activeIterators;
6452  		iterator(Columns const&amp; columns, EndTag)
6453  			: m_columns(columns.m_columns),
6454  			m_activeIterators(0) {
6455  			m_iterators.reserve(m_columns.size());
6456  			for (auto const&amp; col : m_columns)
6457  				m_iterators.push_back(col.end());
6458  		}
6459  	public:
6460  		using difference_type = std::ptrdiff_t;
6461  		using value_type = std::string;
6462  		using pointer = value_type * ;
6463  		using reference = value_type &amp; ;
6464  		using iterator_category = std::forward_iterator_tag;
6465  		explicit iterator(Columns const&amp; columns)
6466  			: m_columns(columns.m_columns),
6467  			m_activeIterators(m_columns.size()) {
6468  			m_iterators.reserve(m_columns.size());
6469  			for (auto const&amp; col : m_columns)
6470  				m_iterators.push_back(col.begin());
6471  		}
6472  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6473  			return m_iterators == other.m_iterators;
6474  		}
6475  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6476  			return m_iterators != other.m_iterators;
6477  		}
6478  		auto operator *() const -&gt; std::string {
6479  			std::string row, padding;
6480  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6481  				auto width = m_columns[i].width();
6482  				if (m_iterators[i] != m_columns[i].end()) {
6483  					std::string col = *m_iterators[i];
6484  					row += padding + col;
6485  					if (col.size() &lt; width)
6486  						padding = std::string(width - col.size(), &#x27; &#x27;);
6487  					else
6488  						padding = &quot;&quot;;
6489  				} else {
6490  					padding += std::string(width, &#x27; &#x27;);
6491  				}
6492  			}
6493  			return row;
6494  		}
6495  		auto operator ++() -&gt; iterator&amp; {
6496  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6497  				if (m_iterators[i] != m_columns[i].end())
6498  					++m_iterators[i];
6499  			}
6500  			return *this;
6501  		}
6502  		auto operator ++(int) -&gt; iterator {
6503  			iterator prev(*this);
6504  			operator++();
6505  			return prev;
6506  		}
6507  	};
6508  	using const_iterator = iterator;
6509  	auto begin() const -&gt; iterator { return iterator(*this); }
6510  	auto end() const -&gt; iterator { return { *this, iterator::EndTag() }; }
6511  	auto operator += (Column const&amp; col) -&gt; Columns&amp; {
6512  		m_columns.push_back(col);
6513  		return *this;
6514  	}
6515  	auto operator + (Column const&amp; col) -&gt; Columns {
6516  		Columns combined = *this;
6517  		combined += col;
6518  		return combined;
6519  	}
6520  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Columns const&amp; cols) {
6521  		bool first = true;
6522  		for (auto line : cols) {
6523  			if (first)
6524  				first = false;
6525  			else
6526  				os &lt;&lt; &quot;\n&quot;;
6527  			os &lt;&lt; line;
6528  		}
6529  		return os;
6530  	}
6531  	auto toString() const -&gt; std::string {
6532  		std::ostringstream oss;
6533  		oss &lt;&lt; *this;
6534  		return oss.str();
6535  	}
6536  };
6537  inline auto Column::operator + (Column const&amp; other) -&gt; Columns {
6538  	Columns cols;
6539  	cols += *this;
6540  	cols += other;
6541  	return cols;
6542  }
6543  }
6544  }
6545  }
6546  #include &lt;cctype&gt;
6547  #include &lt;string&gt;
6548  #include &lt;memory&gt;
6549  #include &lt;set&gt;
6550  #include &lt;algorithm&gt;
6551  #if !defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
6552  #define CATCH_PLATFORM_WINDOWS
6553  #endif
6554  namespace Catch { namespace clara {
6555  namespace detail {
6556      template&lt;typename L&gt;
6557      struct UnaryLambdaTraits : UnaryLambdaTraits&lt;decltype( &amp;L::operator() )&gt; {};
6558      template&lt;typename ClassT, typename ReturnT, typename... Args&gt;
6559      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( Args... ) const&gt; {
6560          static const bool isValid = false;
6561      };
6562      template&lt;typename ClassT, typename ReturnT, typename ArgT&gt;
6563      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( ArgT ) const&gt; {
6564          static const bool isValid = true;
6565          using ArgType = typename std::remove_const&lt;typename std::remove_reference&lt;ArgT&gt;::type&gt;::type;
6566          using ReturnType = ReturnT;
6567      };
6568      class TokenStream;
6569      class Args {
6570          friend TokenStream;
6571          std::string m_exeName;
6572          std::vector&lt;std::string&gt; m_args;
6573      public:
6574          Args( int argc, char const* const* argv )
6575              : m_exeName(argv[0]),
6576                m_args(argv + 1, argv + argc) {}
6577          Args( std::initializer_list&lt;std::string&gt; args )
6578          :   m_exeName( *args.begin() ),
6579              m_args( args.begin()+1, args.end() )
6580          {}
6581          auto exeName() const -&gt; std::string {
6582              return m_exeName;
6583          }
6584      };
6585      enum class TokenType {
6586          Option, Argument
6587      };
6588      struct Token {
6589          TokenType type;
6590          std::string token;
6591      };
6592      inline auto isOptPrefix( char c ) -&gt; bool {
6593          return c == &#x27;-&#x27;
6594  #ifdef CATCH_PLATFORM_WINDOWS
6595              || c == &#x27;/&#x27;
6596  #endif
6597          ;
6598      }
6599      class TokenStream {
6600          using Iterator = std::vector&lt;std::string&gt;::const_iterator;
6601          Iterator it;
6602          Iterator itEnd;
6603          std::vector&lt;Token&gt; m_tokenBuffer;
6604          void loadBuffer() {
6605              m_tokenBuffer.resize( 0 );
6606              while( it != itEnd &amp;&amp; it-&gt;empty() )
6607                  ++it;
6608              if( it != itEnd ) {
6609                  auto const &amp;next = *it;
6610                  if( isOptPrefix( next[0] ) ) {
6611                      auto delimiterPos = next.find_first_of( &quot; :=&quot; );
6612                      if( delimiterPos != std::string::npos ) {
6613                          m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
6614                          m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
6615                      } else {
6616                          if( next[1] != &#x27;-&#x27; &amp;&amp; next.size() &gt; 2 ) {
6617                              std::string opt = &quot;- &quot;;
6618                              for( size_t i = 1; i &lt; next.size(); ++i ) {
6619                                  opt[1] = next[i];
6620                                  m_tokenBuffer.push_back( { TokenType::Option, opt } );
6621                              }
6622                          } else {
6623                              m_tokenBuffer.push_back( { TokenType::Option, next } );
6624                          }
6625                      }
6626                  } else {
6627                      m_tokenBuffer.push_back( { TokenType::Argument, next } );
6628                  }
6629              }
6630          }
6631      public:
6632          explicit TokenStream( Args const &amp;args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
6633          TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
6634              loadBuffer();
6635          }
6636          explicit operator bool() const {
6637              return !m_tokenBuffer.empty() || it != itEnd;
6638          }
6639          auto count() const -&gt; size_t { return m_tokenBuffer.size() + (itEnd - it); }
6640          auto operator*() const -&gt; Token {
6641              assert( !m_tokenBuffer.empty() );
6642              return m_tokenBuffer.front();
6643          }
6644          auto operator-&gt;() const -&gt; Token const * {
6645              assert( !m_tokenBuffer.empty() );
6646              return &amp;m_tokenBuffer.front();
6647          }
6648          auto operator++() -&gt; TokenStream &amp; {
6649              if( m_tokenBuffer.size() &gt;= 2 ) {
6650                  m_tokenBuffer.erase( m_tokenBuffer.begin() );
6651              } else {
6652                  if( it != itEnd )
6653                      ++it;
6654                  loadBuffer();
6655              }
6656              return *this;
6657          }
6658      };
6659      class ResultBase {
6660      public:
6661          enum Type {
6662              Ok, LogicError, RuntimeError
6663          };
6664      protected:
6665          ResultBase( Type type ) : m_type( type ) {}
6666          virtual ~ResultBase() = default;
6667          virtual void enforceOk() const = 0;
6668          Type m_type;
6669      };
6670      template&lt;typename T&gt;
6671      class ResultValueBase : public ResultBase {
6672      public:
6673          auto value() const -&gt; T const &amp; {
6674              enforceOk();
6675              return m_value;
6676          }
6677      protected:
6678          ResultValueBase( Type type ) : ResultBase( type ) {}
6679          ResultValueBase( ResultValueBase const &amp;other ) : ResultBase( other ) {
6680              if( m_type == ResultBase::Ok )
6681                  new( &amp;m_value ) T( other.m_value );
6682          }
6683          ResultValueBase( Type, T const &amp;value ) : ResultBase( Ok ) {
6684              new( &amp;m_value ) T( value );
6685          }
6686          auto operator=( ResultValueBase const &amp;other ) -&gt; ResultValueBase &amp; {
6687              if( m_type == ResultBase::Ok )
6688                  m_value.~T();
6689              ResultBase::operator=(other);
6690              if( m_type == ResultBase::Ok )
6691                  new( &amp;m_value ) T( other.m_value );
6692              return *this;
6693          }
6694          ~ResultValueBase() override {
6695              if( m_type == Ok )
6696                  m_value.~T();
6697          }
6698          union {
6699              T m_value;
6700          };
6701      };
6702      template&lt;&gt;
6703      class ResultValueBase&lt;void&gt; : public ResultBase {
6704      protected:
6705          using ResultBase::ResultBase;
6706      };
6707      template&lt;typename T = void&gt;
6708      class BasicResult : public ResultValueBase&lt;T&gt; {
6709      public:
6710          template&lt;typename U&gt;
6711          explicit BasicResult( BasicResult&lt;U&gt; const &amp;other )
6712          :   ResultValueBase&lt;T&gt;( other.type() ),
6713              m_errorMessage( other.errorMessage() )
6714          {
6715              assert( type() != ResultBase::Ok );
6716          }
6717          template&lt;typename U&gt;
6718          static auto ok( U const &amp;value ) -&gt; BasicResult { return { ResultBase::Ok, value }; }
6719          static auto ok() -&gt; BasicResult { return { ResultBase::Ok }; }
6720          static auto logicError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::LogicError, message }; }
6721          static auto runtimeError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::RuntimeError, message }; }
6722          explicit operator bool() const { return m_type == ResultBase::Ok; }
6723          auto type() const -&gt; ResultBase::Type { return m_type; }
6724          auto errorMessage() const -&gt; std::string { return m_errorMessage; }
6725      protected:
6726          void enforceOk() const override {
6727              assert( m_type != ResultBase::LogicError );
6728              assert( m_type != ResultBase::RuntimeError );
6729              if( m_type != ResultBase::Ok )
6730                  std::abort();
6731          }
6732          std::string m_errorMessage; 
6733          BasicResult( ResultBase::Type type, std::string const &amp;message )
6734          :   ResultValueBase&lt;T&gt;(type),
6735              m_errorMessage(message)
6736          {
6737              assert( m_type != ResultBase::Ok );
6738          }
6739          using ResultValueBase&lt;T&gt;::ResultValueBase;
6740          using ResultBase::m_type;
6741      };
6742      enum class ParseResultType {
6743          Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
6744      };
6745      class ParseState {
6746      public:
6747          ParseState( ParseResultType type, TokenStream const &amp;remainingTokens )
6748          : m_type(type),
6749            m_remainingTokens( remainingTokens )
6750          {}
6751          auto type() const -&gt; ParseResultType { return m_type; }
6752          auto remainingTokens() const -&gt; TokenStream { return m_remainingTokens; }
6753      private:
6754          ParseResultType m_type;
6755          TokenStream m_remainingTokens;
6756      };
6757      using Result = BasicResult&lt;void&gt;;
6758      using ParserResult = BasicResult&lt;ParseResultType&gt;;
6759      using InternalParseResult = BasicResult&lt;ParseState&gt;;
6760      struct HelpColumns {
6761          std::string left;
6762          std::string right;
6763      };
6764      template&lt;typename T&gt;
6765      inline auto convertInto( std::string const &amp;source, T&amp; target ) -&gt; ParserResult {
6766          std::stringstream ss;
6767          ss &lt;&lt; source;
6768          ss &gt;&gt; target;
6769          if( ss.fail() )
6770              return ParserResult::runtimeError( &quot;Unable to convert &#x27;&quot; + source + &quot;&#x27; to destination type&quot; );
6771          else
6772              return ParserResult::ok( ParseResultType::Matched );
6773      }
6774      inline auto convertInto( std::string const &amp;source, std::string&amp; target ) -&gt; ParserResult {
6775          target = source;
6776          return ParserResult::ok( ParseResultType::Matched );
6777      }
6778      inline auto convertInto( std::string const &amp;source, bool &amp;target ) -&gt; ParserResult {
6779          std::string srcLC = source;
6780          std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( unsigned char c ) { return static_cast&lt;char&gt;( std::tolower(c) ); } );
6781          if (srcLC == &quot;y&quot; || srcLC == &quot;1&quot; || srcLC == &quot;true&quot; || srcLC == &quot;yes&quot; || srcLC == &quot;on&quot;)
6782              target = true;
6783          else if (srcLC == &quot;n&quot; || srcLC == &quot;0&quot; || srcLC == &quot;false&quot; || srcLC == &quot;no&quot; || srcLC == &quot;off&quot;)
6784              target = false;
6785          else
6786              return ParserResult::runtimeError( &quot;Expected a boolean value but did not recognise: &#x27;&quot; + source + &quot;&#x27;&quot; );
6787          return ParserResult::ok( ParseResultType::Matched );
6788      }
6789  #ifdef CLARA_CONFIG_OPTIONAL_TYPE
6790      template&lt;typename T&gt;
6791      inline auto convertInto( std::string const &amp;source, CLARA_CONFIG_OPTIONAL_TYPE&lt;T&gt;&amp; target ) -&gt; ParserResult {
6792          T temp;
6793          auto result = convertInto( source, temp );
6794          if( result )
6795              target = std::move(temp);
6796          return result;
6797      }
6798  #endif 
6799      struct NonCopyable {
6800          NonCopyable() = default;
6801          NonCopyable( NonCopyable const &amp; ) = delete;
6802          NonCopyable( NonCopyable &amp;&amp; ) = delete;
6803          NonCopyable &amp;operator=( NonCopyable const &amp; ) = delete;
6804          NonCopyable &amp;operator=( NonCopyable &amp;&amp; ) = delete;
6805      };
6806      struct BoundRef : NonCopyable {
6807          virtual ~BoundRef() = default;
6808          virtual auto isContainer() const -&gt; bool { return false; }
6809          virtual auto isFlag() const -&gt; bool { return false; }
6810      };
6811      struct BoundValueRefBase : BoundRef {
6812          virtual auto setValue( std::string const &amp;arg ) -&gt; ParserResult = 0;
6813      };
6814      struct BoundFlagRefBase : BoundRef {
6815          virtual auto setFlag( bool flag ) -&gt; ParserResult = 0;
6816          virtual auto isFlag() const -&gt; bool { return true; }
6817      };
6818      template&lt;typename T&gt;
6819      struct BoundValueRef : BoundValueRefBase {
6820          T &amp;m_ref;
6821          explicit BoundValueRef( T &amp;ref ) : m_ref( ref ) {}
6822          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6823              return convertInto( arg, m_ref );
6824          }
6825      };
6826      template&lt;typename T&gt;
6827      struct BoundValueRef&lt;std::vector&lt;T&gt;&gt; : BoundValueRefBase {
6828          std::vector&lt;T&gt; &amp;m_ref;
6829          explicit BoundValueRef( std::vector&lt;T&gt; &amp;ref ) : m_ref( ref ) {}
6830          auto isContainer() const -&gt; bool override { return true; }
6831          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6832              T temp;
6833              auto result = convertInto( arg, temp );
6834              if( result )
6835                  m_ref.push_back( temp );
6836              return result;
6837          }
6838      };
6839      struct BoundFlagRef : BoundFlagRefBase {
6840          bool &amp;m_ref;
6841          explicit BoundFlagRef( bool &amp;ref ) : m_ref( ref ) {}
6842          auto setFlag( bool flag ) -&gt; ParserResult override {
6843              m_ref = flag;
6844              return ParserResult::ok( ParseResultType::Matched );
6845          }
6846      };
6847      template&lt;typename ReturnType&gt;
6848      struct LambdaInvoker {
6849          static_assert( std::is_same&lt;ReturnType, ParserResult&gt;::value, &quot;Lambda must return void or clara::ParserResult&quot; );
6850          template&lt;typename L, typename ArgType&gt;
6851          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6852              return lambda( arg );
6853          }
6854      };
6855      template&lt;&gt;
6856      struct LambdaInvoker&lt;void&gt; {
6857          template&lt;typename L, typename ArgType&gt;
6858          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6859              lambda( arg );
6860              return ParserResult::ok( ParseResultType::Matched );
6861          }
6862      };
6863      template&lt;typename ArgType, typename L&gt;
6864      inline auto invokeLambda( L const &amp;lambda, std::string const &amp;arg ) -&gt; ParserResult {
6865          ArgType temp{};
6866          auto result = convertInto( arg, temp );
6867          return !result
6868             ? result
6869             : LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( lambda, temp );
6870      }
6871      template&lt;typename L&gt;
6872      struct BoundLambda : BoundValueRefBase {
6873          L m_lambda;
6874          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6875          explicit BoundLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6876          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6877              return invokeLambda&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType&gt;( m_lambda, arg );
6878          }
6879      };
6880      template&lt;typename L&gt;
6881      struct BoundFlagLambda : BoundFlagRefBase {
6882          L m_lambda;
6883          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6884          static_assert( std::is_same&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType, bool&gt;::value, &quot;flags must be boolean&quot; );
6885          explicit BoundFlagLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6886          auto setFlag( bool flag ) -&gt; ParserResult override {
6887              return LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( m_lambda, flag );
6888          }
6889      };
6890      enum class Optionality { Optional, Required };
6891      struct Parser;
6892      class ParserBase {
6893      public:
6894          virtual ~ParserBase() = default;
6895          virtual auto validate() const -&gt; Result { return Result::ok(); }
6896          virtual auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens) const -&gt; InternalParseResult  = 0;
6897          virtual auto cardinality() const -&gt; size_t { return 1; }
6898          auto parse( Args const &amp;args ) const -&gt; InternalParseResult {
6899              return parse( args.exeName(), TokenStream( args ) );
6900          }
6901      };
6902      template&lt;typename DerivedT&gt;
6903      class ComposableParserImpl : public ParserBase {
6904      public:
6905          template&lt;typename T&gt;
6906          auto operator|( T const &amp;other ) const -&gt; Parser;
6907  		template&lt;typename T&gt;
6908          auto operator+( T const &amp;other ) const -&gt; Parser;
6909      };
6910      template&lt;typename DerivedT&gt;
6911      class ParserRefImpl : public ComposableParserImpl&lt;DerivedT&gt; {
6912      protected:
6913          Optionality m_optionality = Optionality::Optional;
6914          std::shared_ptr&lt;BoundRef&gt; m_ref;
6915          std::string m_hint;
6916          std::string m_description;
6917          explicit ParserRefImpl( std::shared_ptr&lt;BoundRef&gt; const &amp;ref ) : m_ref( ref ) {}
6918      public:
6919          template&lt;typename T&gt;
6920          ParserRefImpl( T &amp;ref, std::string const &amp;hint )
6921          :   m_ref( std::make_shared&lt;BoundValueRef&lt;T&gt;&gt;( ref ) ),
6922              m_hint( hint )
6923          {}
6924          template&lt;typename LambdaT&gt;
6925          ParserRefImpl( LambdaT const &amp;ref, std::string const &amp;hint )
6926          :   m_ref( std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( ref ) ),
6927              m_hint(hint)
6928          {}
6929          auto operator()( std::string const &amp;description ) -&gt; DerivedT &amp; {
6930              m_description = description;
6931              return static_cast&lt;DerivedT &amp;&gt;( *this );
6932          }
6933          auto optional() -&gt; DerivedT &amp; {
6934              m_optionality = Optionality::Optional;
6935              return static_cast&lt;DerivedT &amp;&gt;( *this );
6936          };
6937          auto required() -&gt; DerivedT &amp; {
6938              m_optionality = Optionality::Required;
6939              return static_cast&lt;DerivedT &amp;&gt;( *this );
6940          };
6941          auto isOptional() const -&gt; bool {
6942              return m_optionality == Optionality::Optional;
6943          }
6944          auto cardinality() const -&gt; size_t override {
6945              if( m_ref-&gt;isContainer() )
6946                  return 0;
6947              else
6948                  return 1;
6949          }
6950          auto hint() const -&gt; std::string { return m_hint; }
6951      };
6952      class ExeName : public ComposableParserImpl&lt;ExeName&gt; {
6953          std::shared_ptr&lt;std::string&gt; m_name;
6954          std::shared_ptr&lt;BoundValueRefBase&gt; m_ref;
6955          template&lt;typename LambdaT&gt;
6956          static auto makeRef(LambdaT const &amp;lambda) -&gt; std::shared_ptr&lt;BoundValueRefBase&gt; {
6957              return std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda) ;
6958          }
6959      public:
6960          ExeName() : m_name( std::make_shared&lt;std::string&gt;( &quot;&lt;executable&gt;&quot; ) ) {}
6961          explicit ExeName( std::string &amp;ref ) : ExeName() {
6962              m_ref = std::make_shared&lt;BoundValueRef&lt;std::string&gt;&gt;( ref );
6963          }
6964          template&lt;typename LambdaT&gt;
6965          explicit ExeName( LambdaT const&amp; lambda ) : ExeName() {
6966              m_ref = std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda );
6967          }
6968          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6969              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
6970          }
6971          auto name() const -&gt; std::string { return *m_name; }
6972          auto set( std::string const&amp; newName ) -&gt; ParserResult {
6973              auto lastSlash = newName.find_last_of( &quot;\\/&quot; );
6974              auto filename = ( lastSlash == std::string::npos )
6975                      ? newName
6976                      : newName.substr( lastSlash+1 );
6977              *m_name = filename;
6978              if( m_ref )
6979                  return m_ref-&gt;setValue( filename );
6980              else
6981                  return ParserResult::ok( ParseResultType::Matched );
6982          }
6983      };
6984      class Arg : public ParserRefImpl&lt;Arg&gt; {
6985      public:
6986          using ParserRefImpl::ParserRefImpl;
6987          auto parse( std::string const &amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6988              auto validationResult = validate();
6989              if( !validationResult )
6990                  return InternalParseResult( validationResult );
6991              auto remainingTokens = tokens;
6992              auto const &amp;token = *remainingTokens;
6993              if( token.type != TokenType::Argument )
6994                  return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
6995              assert( !m_ref-&gt;isFlag() );
6996              auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
6997              auto result = valueRef-&gt;setValue( remainingTokens-&gt;token );
6998              if( !result )
6999                  return InternalParseResult( result );
7000              else
7001                  return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7002          }
7003      };
7004      inline auto normaliseOpt( std::string const &amp;optName ) -&gt; std::string {
7005  #ifdef CATCH_PLATFORM_WINDOWS
7006          if( optName[0] == &#x27;/&#x27; )
7007              return &quot;-&quot; + optName.substr( 1 );
7008          else
7009  #endif
7010              return optName;
7011      }
7012      class Opt : public ParserRefImpl&lt;Opt&gt; {
7013      protected:
7014          std::vector&lt;std::string&gt; m_optNames;
7015      public:
7016          template&lt;typename LambdaT&gt;
7017          explicit Opt( LambdaT const &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagLambda&lt;LambdaT&gt;&gt;( ref ) ) {}
7018          explicit Opt( bool &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagRef&gt;( ref ) ) {}
7019          template&lt;typename LambdaT&gt;
7020          Opt( LambdaT const &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7021          template&lt;typename T&gt;
7022          Opt( T &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7023          auto operator[]( std::string const &amp;optName ) -&gt; Opt &amp; {
7024              m_optNames.push_back( optName );
7025              return *this;
7026          }
7027          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7028              std::ostringstream oss;
7029              bool first = true;
7030              for( auto const &amp;opt : m_optNames ) {
7031                  if (first)
7032                      first = false;
7033                  else
7034                      oss &lt;&lt; &quot;, &quot;;
7035                  oss &lt;&lt; opt;
7036              }
7037              if( !m_hint.empty() )
7038                  oss &lt;&lt; &quot; &lt;&quot; &lt;&lt; m_hint &lt;&lt; &quot;&gt;&quot;;
7039              return { { oss.str(), m_description } };
7040          }
7041          auto isMatch( std::string const &amp;optToken ) const -&gt; bool {
7042              auto normalisedToken = normaliseOpt( optToken );
7043              for( auto const &amp;name : m_optNames ) {
7044                  if( normaliseOpt( name ) == normalisedToken )
7045                      return true;
7046              }
7047              return false;
7048          }
7049          using ParserBase::parse;
7050          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7051              auto validationResult = validate();
7052              if( !validationResult )
7053                  return InternalParseResult( validationResult );
7054              auto remainingTokens = tokens;
7055              if( remainingTokens &amp;&amp; remainingTokens-&gt;type == TokenType::Option ) {
7056                  auto const &amp;token = *remainingTokens;
7057                  if( isMatch(token.token ) ) {
7058                      if( m_ref-&gt;isFlag() ) {
7059                          auto flagRef = static_cast&lt;detail::BoundFlagRefBase*&gt;( m_ref.get() );
7060                          auto result = flagRef-&gt;setFlag( true );
7061                          if( !result )
7062                              return InternalParseResult( result );
7063                          if( result.value() == ParseResultType::ShortCircuitAll )
7064                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7065                      } else {
7066                          auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
7067                          ++remainingTokens;
7068                          if( !remainingTokens )
7069                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7070                          auto const &amp;argToken = *remainingTokens;
7071                          if( argToken.type != TokenType::Argument )
7072                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7073                          auto result = valueRef-&gt;setValue( argToken.token );
7074                          if( !result )
7075                              return InternalParseResult( result );
7076                          if( result.value() == ParseResultType::ShortCircuitAll )
7077                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7078                      }
7079                      return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7080                  }
7081              }
7082              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
7083          }
7084          auto validate() const -&gt; Result override {
7085              if( m_optNames.empty() )
7086                  return Result::logicError( &quot;No options supplied to Opt&quot; );
7087              for( auto const &amp;name : m_optNames ) {
7088                  if( name.empty() )
7089                      return Result::logicError( &quot;Option name cannot be empty&quot; );
7090  #ifdef CATCH_PLATFORM_WINDOWS
7091                  if( name[0] != &#x27;-&#x27; &amp;&amp; name[0] != &#x27;/&#x27; )
7092                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27; or &#x27;/&#x27;&quot; );
7093  #else
7094                  if( name[0] != &#x27;-&#x27; )
7095                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27;&quot; );
7096  #endif
7097              }
7098              return ParserRefImpl::validate();
7099          }
7100      };
7101      struct Help : Opt {
7102          Help( bool &amp;showHelpFlag )
7103          :   Opt([&amp;]( bool flag ) {
7104                  showHelpFlag = flag;
7105                  return ParserResult::ok( ParseResultType::ShortCircuitAll );
7106              })
7107          {
7108              static_cast&lt;Opt &amp;&gt;( *this )
7109                      (&quot;display usage information&quot;)
7110                      [&quot;-?&quot;][&quot;-h&quot;][&quot;--help&quot;]
7111                      .optional();
7112          }
7113      };
7114      struct Parser : ParserBase {
7115          mutable ExeName m_exeName;
7116          std::vector&lt;Opt&gt; m_options;
7117          std::vector&lt;Arg&gt; m_args;
7118          auto operator|=( ExeName const &amp;exeName ) -&gt; Parser &amp; {
7119              m_exeName = exeName;
7120              return *this;
7121          }
7122          auto operator|=( Arg const &amp;arg ) -&gt; Parser &amp; {
7123              m_args.push_back(arg);
7124              return *this;
7125          }
7126          auto operator|=( Opt const &amp;opt ) -&gt; Parser &amp; {
7127              m_options.push_back(opt);
7128              return *this;
7129          }
7130          auto operator|=( Parser const &amp;other ) -&gt; Parser &amp; {
7131              m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
7132              m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
7133              return *this;
7134          }
7135          template&lt;typename T&gt;
7136          auto operator|( T const &amp;other ) const -&gt; Parser {
7137              return Parser( *this ) |= other;
7138          }
7139          template&lt;typename T&gt;
7140          auto operator+=( T const &amp;other ) -&gt; Parser &amp; { return operator|=( other ); }
7141          template&lt;typename T&gt;
7142          auto operator+( T const &amp;other ) const -&gt; Parser { return operator|( other ); }
7143          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7144              std::vector&lt;HelpColumns&gt; cols;
7145              for (auto const &amp;o : m_options) {
7146                  auto childCols = o.getHelpColumns();
7147                  cols.insert( cols.end(), childCols.begin(), childCols.end() );
7148              }
7149              return cols;
7150          }
7151          void writeToStream( std::ostream &amp;os ) const {
7152              if (!m_exeName.name().empty()) {
7153                  os &lt;&lt; &quot;usage:\n&quot; &lt;&lt; &quot;  &quot; &lt;&lt; m_exeName.name() &lt;&lt; &quot; &quot;;
7154                  bool required = true, first = true;
7155                  for( auto const &amp;arg : m_args ) {
7156                      if (first)
7157                          first = false;
7158                      else
7159                          os &lt;&lt; &quot; &quot;;
7160                      if( arg.isOptional() &amp;&amp; required ) {
7161                          os &lt;&lt; &quot;[&quot;;
7162                          required = false;
7163                      }
7164                      os &lt;&lt; &quot;&lt;&quot; &lt;&lt; arg.hint() &lt;&lt; &quot;&gt;&quot;;
7165                      if( arg.cardinality() == 0 )
7166                          os &lt;&lt; &quot; ... &quot;;
7167                  }
7168                  if( !required )
7169                      os &lt;&lt; &quot;]&quot;;
7170                  if( !m_options.empty() )
7171                      os &lt;&lt; &quot; options&quot;;
7172                  os &lt;&lt; &quot;\n\nwhere options are:&quot; &lt;&lt; std::endl;
7173              }
7174              auto rows = getHelpColumns();
7175              size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
7176              size_t optWidth = 0;
7177              for( auto const &amp;cols : rows )
7178                  optWidth = (std::max)(optWidth, cols.left.size() + 2);
7179              optWidth = (std::min)(optWidth, consoleWidth/2);
7180              for( auto const &amp;cols : rows ) {
7181                  auto row =
7182                          TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
7183                          TextFlow::Spacer(4) +
7184                          TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
7185                  os &lt;&lt; row &lt;&lt; std::endl;
7186              }
7187          }
7188          friend auto operator&lt;&lt;( std::ostream &amp;os, Parser const &amp;parser ) -&gt; std::ostream&amp; {
7189              parser.writeToStream( os );
7190              return os;
7191          }
7192          auto validate() const -&gt; Result override {
7193              for( auto const &amp;opt : m_options ) {
7194                  auto result = opt.validate();
7195                  if( !result )
7196                      return result;
7197              }
7198              for( auto const &amp;arg : m_args ) {
7199                  auto result = arg.validate();
7200                  if( !result )
7201                      return result;
7202              }
7203              return Result::ok();
7204          }
7205          using ParserBase::parse;
7206          auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7207              struct ParserInfo {
7208                  ParserBase const* parser = nullptr;
7209                  size_t count = 0;
7210              };
7211              const size_t totalParsers = m_options.size() + m_args.size();
7212              assert( totalParsers &lt; 512 );
7213              ParserInfo parseInfos[512];
7214              {
7215                  size_t i = 0;
7216                  for (auto const &amp;opt : m_options) parseInfos[i++].parser = &amp;opt;
7217                  for (auto const &amp;arg : m_args) parseInfos[i++].parser = &amp;arg;
7218              }
7219              m_exeName.set( exeName );
7220              auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
7221              while( result.value().remainingTokens() ) {
7222                  bool tokenParsed = false;
7223                  for( size_t i = 0; i &lt; totalParsers; ++i ) {
7224                      auto&amp;  parseInfo = parseInfos[i];
7225                      if( parseInfo.parser-&gt;cardinality() == 0 || parseInfo.count &lt; parseInfo.parser-&gt;cardinality() ) {
7226                          result = parseInfo.parser-&gt;parse(exeName, result.value().remainingTokens());
7227                          if (!result)
7228                              return result;
7229                          if (result.value().type() != ParseResultType::NoMatch) {
7230                              tokenParsed = true;
7231                              ++parseInfo.count;
7232                              break;
7233                          }
7234                      }
7235                  }
7236                  if( result.value().type() == ParseResultType::ShortCircuitAll )
7237                      return result;
7238                  if( !tokenParsed )
7239                      return InternalParseResult::runtimeError( &quot;Unrecognised token: &quot; + result.value().remainingTokens()-&gt;token );
7240              }
7241              return result;
7242          }
7243      };
7244      template&lt;typename DerivedT&gt;
7245      template&lt;typename T&gt;
7246      auto ComposableParserImpl&lt;DerivedT&gt;::operator|( T const &amp;other ) const -&gt; Parser {
7247          return Parser() | static_cast&lt;DerivedT const &amp;&gt;( *this ) | other;
7248      }
7249  } 
7250  using detail::Parser;
7251  using detail::Opt;
7252  using detail::Arg;
7253  using detail::Args;
7254  using detail::ExeName;
7255  using detail::Help;
7256  using detail::ParseResultType;
7257  using detail::ParserResult;
7258  }} 
7259  #ifdef __clang__
7260  #pragma clang diagnostic pop
7261  #endif
7262  #ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7263  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7264  #undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7265  #endif
7266  namespace Catch {
7267      clara::Parser makeCommandLineParser( ConfigData&amp; config );
7268  } 
7269  #include &lt;fstream&gt;
7270  #include &lt;ctime&gt;
7271  namespace Catch {
7272      clara::Parser makeCommandLineParser( ConfigData&amp; config ) {
7273          using namespace clara;
7274          auto const setWarning = [&amp;]( std::string const&amp; warning ) {
7275                  auto warningSet = [&amp;]() {
7276                      if( warning == &quot;NoAssertions&quot; )
7277                          return WarnAbout::NoAssertions;
7278                      if ( warning == &quot;NoTests&quot; )
7279                          return WarnAbout::NoTests;
7280                      return WarnAbout::Nothing;
7281                  }();
7282                  if (warningSet == WarnAbout::Nothing)
7283                      return ParserResult::runtimeError( &quot;Unrecognised warning: &#x27;&quot; + warning + &quot;&#x27;&quot; );
7284                  config.warnings = static_cast&lt;WarnAbout::What&gt;( config.warnings | warningSet );
7285                  return ParserResult::ok( ParseResultType::Matched );
7286              };
7287          auto const loadTestNamesFromFile = [&amp;]( std::string const&amp; filename ) {
7288                  std::ifstream f( filename.c_str() );
7289                  if( !f.is_open() )
7290                      return ParserResult::runtimeError( &quot;Unable to load input file: &#x27;&quot; + filename + &quot;&#x27;&quot; );
7291                  std::string line;
7292                  while( std::getline( f, line ) ) {
7293                      line = trim(line);
7294                      if( !line.empty() &amp;&amp; !startsWith( line, &#x27;#&#x27; ) ) {
7295                          if( !startsWith( line, &#x27;&quot;&#x27; ) )
7296                              line = &#x27;&quot;&#x27; + line + &#x27;&quot;&#x27;;
7297                          config.testsOrTags.push_back( line );
7298                          config.testsOrTags.emplace_back( &quot;,&quot; );
7299                      }
7300                  }
7301                  if(!config.testsOrTags.empty())
7302                      config.testsOrTags.erase( config.testsOrTags.end()-1 );
7303                  return ParserResult::ok( ParseResultType::Matched );
7304              };
7305          auto const setTestOrder = [&amp;]( std::string const&amp; order ) {
7306                  if( startsWith( &quot;declared&quot;, order ) )
7307                      config.runOrder = RunTests::InDeclarationOrder;
7308                  else if( startsWith( &quot;lexical&quot;, order ) )
7309                      config.runOrder = RunTests::InLexicographicalOrder;
7310                  else if( startsWith( &quot;random&quot;, order ) )
7311                      config.runOrder = RunTests::InRandomOrder;
7312                  else
7313                      return clara::ParserResult::runtimeError( &quot;Unrecognised ordering: &#x27;&quot; + order + &quot;&#x27;&quot; );
7314                  return ParserResult::ok( ParseResultType::Matched );
7315              };
7316          auto const setRngSeed = [&amp;]( std::string const&amp; seed ) {
7317                  if( seed != &quot;time&quot; )
7318                      return clara::detail::convertInto( seed, config.rngSeed );
7319                  config.rngSeed = static_cast&lt;unsigned int&gt;( std::time(nullptr) );
7320                  return ParserResult::ok( ParseResultType::Matched );
7321              };
7322          auto const setColourUsage = [&amp;]( std::string const&amp; useColour ) {
7323                      auto mode = toLower( useColour );
7324                      if( mode == &quot;yes&quot; )
7325                          config.useColour = UseColour::Yes;
7326                      else if( mode == &quot;no&quot; )
7327                          config.useColour = UseColour::No;
7328                      else if( mode == &quot;auto&quot; )
7329                          config.useColour = UseColour::Auto;
7330                      else
7331                          return ParserResult::runtimeError( &quot;colour mode must be one of: auto, yes or no. &#x27;&quot; + useColour + &quot;&#x27; not recognised&quot; );
7332                  return ParserResult::ok( ParseResultType::Matched );
7333              };
7334          auto const setWaitForKeypress = [&amp;]( std::string const&amp; keypress ) {
7335                  auto keypressLc = toLower( keypress );
7336                  if (keypressLc == &quot;never&quot;)
7337                      config.waitForKeypress = WaitForKeypress::Never;
7338                  else if( keypressLc == &quot;start&quot; )
7339                      config.waitForKeypress = WaitForKeypress::BeforeStart;
7340                  else if( keypressLc == &quot;exit&quot; )
7341                      config.waitForKeypress = WaitForKeypress::BeforeExit;
7342                  else if( keypressLc == &quot;both&quot; )
7343                      config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
7344                  else
7345                      return ParserResult::runtimeError( &quot;keypress argument must be one of: never, start, exit or both. &#x27;&quot; + keypress + &quot;&#x27; not recognised&quot; );
7346              return ParserResult::ok( ParseResultType::Matched );
7347              };
7348          auto const setVerbosity = [&amp;]( std::string const&amp; verbosity ) {
7349              auto lcVerbosity = toLower( verbosity );
7350              if( lcVerbosity == &quot;quiet&quot; )
7351                  config.verbosity = Verbosity::Quiet;
7352              else if( lcVerbosity == &quot;normal&quot; )
7353                  config.verbosity = Verbosity::Normal;
7354              else if( lcVerbosity == &quot;high&quot; )
7355                  config.verbosity = Verbosity::High;
7356              else
7357                  return ParserResult::runtimeError( &quot;Unrecognised verbosity, &#x27;&quot; + verbosity + &quot;&#x27;&quot; );
7358              return ParserResult::ok( ParseResultType::Matched );
7359          };
7360          auto const setReporter = [&amp;]( std::string const&amp; reporter ) {
7361              IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
7362              auto lcReporter = toLower( reporter );
7363              auto result = factories.find( lcReporter );
7364              if( factories.end() != result )
7365                  config.reporterName = lcReporter;
7366              else
7367                  return ParserResult::runtimeError( &quot;Unrecognized reporter, &#x27;&quot; + reporter + &quot;&#x27;. Check available with --list-reporters&quot; );
7368              return ParserResult::ok( ParseResultType::Matched );
7369          };
7370          auto cli
7371              = ExeName( config.processName )
7372              | Help( config.showHelp )
7373              | Opt( config.listTests )
7374                  [&quot;-l&quot;][&quot;--list-tests&quot;]
7375                  ( &quot;list all/matching test cases&quot; )
7376              | Opt( config.listTags )
7377                  [&quot;-t&quot;][&quot;--list-tags&quot;]
7378                  ( &quot;list all/matching tags&quot; )
7379              | Opt( config.showSuccessfulTests )
7380                  [&quot;-s&quot;][&quot;--success&quot;]
7381                  ( &quot;include successful tests in output&quot; )
7382              | Opt( config.shouldDebugBreak )
7383                  [&quot;-b&quot;][&quot;--break&quot;]
7384                  ( &quot;break into debugger on failure&quot; )
7385              | Opt( config.noThrow )
7386                  [&quot;-e&quot;][&quot;--nothrow&quot;]
7387                  ( &quot;skip exception tests&quot; )
7388              | Opt( config.showInvisibles )
7389                  [&quot;-i&quot;][&quot;--invisibles&quot;]
7390                  ( &quot;show invisibles (tabs, newlines)&quot; )
7391              | Opt( config.outputFilename, &quot;filename&quot; )
7392                  [&quot;-o&quot;][&quot;--out&quot;]
7393                  ( &quot;output filename&quot; )
7394              | Opt( setReporter, &quot;name&quot; )
7395                  [&quot;-r&quot;][&quot;--reporter&quot;]
7396                  ( &quot;reporter to use (defaults to console)&quot; )
7397              | Opt( config.name, &quot;name&quot; )
7398                  [&quot;-n&quot;][&quot;--name&quot;]
7399                  ( &quot;suite name&quot; )
7400              | Opt( [&amp;]( bool ){ config.abortAfter = 1; } )
7401                  [&quot;-a&quot;][&quot;--abort&quot;]
7402                  ( &quot;abort at first failure&quot; )
7403              | Opt( [&amp;]( int x ){ config.abortAfter = x; }, &quot;no. failures&quot; )
7404                  [&quot;-x&quot;][&quot;--abortx&quot;]
7405                  ( &quot;abort after x failures&quot; )
7406              | Opt( setWarning, &quot;warning name&quot; )
7407                  [&quot;-w&quot;][&quot;--warn&quot;]
7408                  ( &quot;enable warnings&quot; )
7409              | Opt( [&amp;]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, &quot;yes|no&quot; )
7410                  [&quot;-d&quot;][&quot;--durations&quot;]
7411                  ( &quot;show test durations&quot; )
7412              | Opt( config.minDuration, &quot;seconds&quot; )
7413                  [&quot;-D&quot;][&quot;--min-duration&quot;]
7414                  ( &quot;show test durations for tests taking at least the given number of seconds&quot; )
7415              | Opt( loadTestNamesFromFile, &quot;filename&quot; )
7416                  [&quot;-f&quot;][&quot;--input-file&quot;]
7417                  ( &quot;load test names to run from a file&quot; )
7418              | Opt( config.filenamesAsTags )
7419                  [&quot;-#&quot;][&quot;--filenames-as-tags&quot;]
7420                  ( &quot;adds a tag for the filename&quot; )
7421              | Opt( config.sectionsToRun, &quot;section name&quot; )
7422                  [&quot;-c&quot;][&quot;--section&quot;]
7423                  ( &quot;specify section to run&quot; )
7424              | Opt( setVerbosity, &quot;quiet|normal|high&quot; )
7425                  [&quot;-v&quot;][&quot;--verbosity&quot;]
7426                  ( &quot;set output verbosity&quot; )
7427              | Opt( config.listTestNamesOnly )
7428                  [&quot;--list-test-names-only&quot;]
7429                  ( &quot;list all/matching test cases names only&quot; )
7430              | Opt( config.listReporters )
7431                  [&quot;--list-reporters&quot;]
7432                  ( &quot;list all reporters&quot; )
7433              | Opt( setTestOrder, &quot;decl|lex|rand&quot; )
7434                  [&quot;--order&quot;]
7435                  ( &quot;test case order (defaults to decl)&quot; )
7436              | Opt( setRngSeed, &quot;&#x27;time&#x27;|number&quot; )
7437                  [&quot;--rng-seed&quot;]
7438                  ( &quot;set a specific seed for random numbers&quot; )
7439              | Opt( setColourUsage, &quot;yes|no&quot; )
7440                  [&quot;--use-colour&quot;]
7441                  ( &quot;should output be colourised&quot; )
7442              | Opt( config.libIdentify )
7443                  [&quot;--libidentify&quot;]
7444                  ( &quot;report name and version according to libidentify standard&quot; )
7445              | Opt( setWaitForKeypress, &quot;never|start|exit|both&quot; )
7446                  [&quot;--wait-for-keypress&quot;]
7447                  ( &quot;waits for a keypress before exiting&quot; )
7448              | Opt( config.benchmarkSamples, &quot;samples&quot; )
7449                  [&quot;--benchmark-samples&quot;]
7450                  ( &quot;number of samples to collect (default: 100)&quot; )
7451              | Opt( config.benchmarkResamples, &quot;resamples&quot; )
7452                  [&quot;--benchmark-resamples&quot;]
7453                  ( &quot;number of resamples for the bootstrap (default: 100000)&quot; )
7454              | Opt( config.benchmarkConfidenceInterval, &quot;confidence interval&quot; )
7455                  [&quot;--benchmark-confidence-interval&quot;]
7456                  ( &quot;confidence interval for the bootstrap (between 0 and 1, default: 0.95)&quot; )
7457              | Opt( config.benchmarkNoAnalysis )
7458                  [&quot;--benchmark-no-analysis&quot;]
7459                  ( &quot;perform only measurements; do not perform any analysis&quot; )
7460              | Opt( config.benchmarkWarmupTime, &quot;benchmarkWarmupTime&quot; )
7461                  [&quot;--benchmark-warmup-time&quot;]
7462                  ( &quot;amount of time in milliseconds spent on warming up each test (default: 100)&quot; )
7463              | Arg( config.testsOrTags, &quot;test name|pattern|tags&quot; )
7464                  ( &quot;which test or tests to use&quot; );
7465          return cli;
7466      }
7467  } 
7468  #include &lt;cstring&gt;
7469  #include &lt;ostream&gt;
7470  namespace Catch {
7471      bool SourceLineInfo::operator == ( SourceLineInfo const&amp; other ) const noexcept {
7472          return line == other.line &amp;&amp; (file == other.file || std::strcmp(file, other.file) == 0);
7473      }
7474      bool SourceLineInfo::operator &lt; ( SourceLineInfo const&amp; other ) const noexcept {
7475          return line &lt; other.line || ( line == other.line &amp;&amp; file != other.file &amp;&amp; (std::strcmp(file, other.file) &lt; 0));
7476      }
7477      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, SourceLineInfo const&amp; info ) {
7478  #ifndef __GNUG__
7479          os &lt;&lt; info.file &lt;&lt; &#x27;(&#x27; &lt;&lt; info.line &lt;&lt; &#x27;)&#x27;;
7480  #else
7481          os &lt;&lt; info.file &lt;&lt; &#x27;:&#x27; &lt;&lt; info.line;
7482  #endif
7483          return os;
7484      }
7485      std::string StreamEndStop::operator+() const {
7486          return std::string();
7487      }
7488      NonCopyable::NonCopyable() = default;
7489      NonCopyable::~NonCopyable() = default;
7490  }
7491  namespace Catch {
7492      Config::Config( ConfigData const&amp; data )
7493      :   m_data( data ),
7494          m_stream( openStream() )
7495      {
7496          for (auto&amp; elem : m_data.testsOrTags) {
7497              elem = trim(elem);
7498          }
7499          for (auto&amp; elem : m_data.sectionsToRun) {
7500              elem = trim(elem);
7501          }
7502          TestSpecParser parser(ITagAliasRegistry::get());
7503          if (!m_data.testsOrTags.empty()) {
7504              m_hasTestFilters = true;
7505              for (auto const&amp; testOrTags : m_data.testsOrTags) {
7506                  parser.parse(testOrTags);
7507              }
7508          }
7509          m_testSpec = parser.testSpec();
7510      }
7511      std::string const&amp; Config::getFilename() const {
7512          return m_data.outputFilename ;
7513      }
7514      bool Config::listTests() const          { return m_data.listTests; }
7515      bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
7516      bool Config::listTags() const           { return m_data.listTags; }
7517      bool Config::listReporters() const      { return m_data.listReporters; }
7518      std::string Config::getProcessName() const { return m_data.processName; }
7519      std::string const&amp; Config::getReporterName() const { return m_data.reporterName; }
7520      std::vector&lt;std::string&gt; const&amp; Config::getTestsOrTags() const { return m_data.testsOrTags; }
7521      std::vector&lt;std::string&gt; const&amp; Config::getSectionsToRun() const { return m_data.sectionsToRun; }
7522      TestSpec const&amp; Config::testSpec() const { return m_testSpec; }
7523      bool Config::hasTestFilters() const { return m_hasTestFilters; }
7524      bool Config::showHelp() const { return m_data.showHelp; }
7525      bool Config::allowThrows() const                   { return !m_data.noThrow; }
7526      std::ostream&amp; Config::stream() const               { return m_stream-&gt;stream(); }
7527      std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
7528      bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
7529      bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings &amp; WarnAbout::NoAssertions); }
7530      bool Config::warnAboutNoTests() const              { return !!(m_data.warnings &amp; WarnAbout::NoTests); }
7531      ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
7532      double Config::minDuration() const                 { return m_data.minDuration; }
7533      RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
7534      unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
7535      UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
7536      bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
7537      int Config::abortAfter() const                     { return m_data.abortAfter; }
7538      bool Config::showInvisibles() const                { return m_data.showInvisibles; }
7539      Verbosity Config::verbosity() const                { return m_data.verbosity; }
7540      bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
7541      int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
7542      double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
7543      unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
7544      std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }
7545      IStream const* Config::openStream() {
7546          return Catch::makeStream(m_data.outputFilename);
7547      }
7548  } 
7549  #if defined(__clang__)
7550  #    pragma clang diagnostic push
7551  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
7552  #endif
7553  namespace Catch {
7554      class ErrnoGuard {
7555      public:
7556          ErrnoGuard();
7557          ~ErrnoGuard();
7558      private:
7559          int m_oldErrno;
7560      };
7561  }
7562  #if defined(CATCH_PLATFORM_WINDOWS)
7563  #if !defined(NOMINMAX) &amp;&amp; !defined(CATCH_CONFIG_NO_NOMINMAX)
7564  #  define CATCH_DEFINED_NOMINMAX
7565  #  define NOMINMAX
7566  #endif
7567  #if !defined(WIN32_LEAN_AND_MEAN) &amp;&amp; !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
7568  #  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7569  #  define WIN32_LEAN_AND_MEAN
7570  #endif
7571  #ifdef __AFXDLL
7572  #include &lt;AfxWin.h&gt;
7573  #else
7574  #include &lt;windows.h&gt;
7575  #endif
7576  #ifdef CATCH_DEFINED_NOMINMAX
7577  #  undef NOMINMAX
7578  #endif
7579  #ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7580  #  undef WIN32_LEAN_AND_MEAN
7581  #endif
7582  #endif 
7583  #include &lt;sstream&gt;
7584  namespace Catch {
7585      namespace {
7586          struct IColourImpl {
7587              virtual ~IColourImpl() = default;
7588              virtual void use( Colour::Code _colourCode ) = 0;
7589          };
7590          struct NoColourImpl : IColourImpl {
7591              void use( Colour::Code ) override {}
7592              static IColourImpl* instance() {
7593                  static NoColourImpl s_instance;
7594                  return &amp;s_instance;
7595              }
7596          };
7597      } 
7598  } 
7599  #if !defined( CATCH_CONFIG_COLOUR_NONE ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_WINDOWS ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_ANSI )
7600  #   ifdef CATCH_PLATFORM_WINDOWS
7601  #       define CATCH_CONFIG_COLOUR_WINDOWS
7602  #   else
7603  #       define CATCH_CONFIG_COLOUR_ANSI
7604  #   endif
7605  #endif
7606  #if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) 
7607  namespace Catch {
7608  namespace {
7609      class Win32ColourImpl : public IColourImpl {
7610      public:
7611          Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
7612          {
7613              CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
7614              GetConsoleScreenBufferInfo( stdoutHandle, &amp;csbiInfo );
7615              originalForegroundAttributes = csbiInfo.wAttributes &amp; ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
7616              originalBackgroundAttributes = csbiInfo.wAttributes &amp; ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
7617          }
7618          void use( Colour::Code _colourCode ) override {
7619              switch( _colourCode ) {
7620                  case Colour::None:      return setTextAttribute( originalForegroundAttributes );
7621                  case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7622                  case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
7623                  case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
7624                  case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
7625                  case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
7626                  case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
7627                  case Colour::Grey:      return setTextAttribute( 0 );
7628                  case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
7629                  case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
7630                  case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
7631                  case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7632                  case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
7633                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7634                  default:
7635                      CATCH_ERROR( &quot;Unknown colour requested&quot; );
7636              }
7637          }
7638      private:
7639          void setTextAttribute( WORD _textAttribute ) {
7640              SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
7641          }
7642          HANDLE stdoutHandle;
7643          WORD originalForegroundAttributes;
7644          WORD originalBackgroundAttributes;
7645      };
7646      IColourImpl* platformColourInstance() {
7647          static Win32ColourImpl s_instance;
7648          IConfigPtr config = getCurrentContext().getConfig();
7649          UseColour::YesOrNo colourMode = config
7650              ? config-&gt;useColour()
7651              : UseColour::Auto;
7652          if( colourMode == UseColour::Auto )
7653              colourMode = UseColour::Yes;
7654          return colourMode == UseColour::Yes
7655              ? &amp;s_instance
7656              : NoColourImpl::instance();
7657      }
7658  } 
7659  } 
7660  #elif defined( CATCH_CONFIG_COLOUR_ANSI ) 
7661  #include &lt;unistd.h&gt;
7662  namespace Catch {
7663  namespace {
7664      class PosixColourImpl : public IColourImpl {
7665      public:
7666          void use( Colour::Code _colourCode ) override {
7667              switch( _colourCode ) {
7668                  case Colour::None:
7669                  case Colour::White:     return setColour( &quot;[0m&quot; );
7670                  case Colour::Red:       return setColour( &quot;[0;31m&quot; );
7671                  case Colour::Green:     return setColour( &quot;[0;32m&quot; );
7672                  case Colour::Blue:      return setColour( &quot;[0;34m&quot; );
7673                  case Colour::Cyan:      return setColour( &quot;[0;36m&quot; );
7674                  case Colour::Yellow:    return setColour( &quot;[0;33m&quot; );
7675                  case Colour::Grey:      return setColour( &quot;[1;30m&quot; );
7676                  case Colour::LightGrey:     return setColour( &quot;[0;37m&quot; );
7677                  case Colour::BrightRed:     return setColour( &quot;[1;31m&quot; );
7678                  case Colour::BrightGreen:   return setColour( &quot;[1;32m&quot; );
7679                  case Colour::BrightWhite:   return setColour( &quot;[1;37m&quot; );
7680                  case Colour::BrightYellow:  return setColour( &quot;[1;33m&quot; );
7681                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7682                  default: CATCH_INTERNAL_ERROR( &quot;Unknown colour requested&quot; );
7683              }
7684          }
7685          static IColourImpl* instance() {
7686              static PosixColourImpl s_instance;
7687              return &amp;s_instance;
7688          }
7689      private:
7690          void setColour( const char* _escapeCode ) {
7691              getCurrentContext().getConfig()-&gt;stream()
7692                  &lt;&lt; &#x27;\033&#x27; &lt;&lt; _escapeCode;
7693          }
7694      };
7695      bool useColourOnPlatform() {
7696          return
7697  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7698              !isDebuggerActive() &amp;&amp;
7699  #endif
7700  #if !(defined(__DJGPP__) &amp;&amp; defined(__STRICT_ANSI__))
7701              isatty(STDOUT_FILENO)
7702  #else
7703              false
7704  #endif
7705              ;
7706      }
7707      IColourImpl* platformColourInstance() {
7708          ErrnoGuard guard;
7709          IConfigPtr config = getCurrentContext().getConfig();
7710          UseColour::YesOrNo colourMode = config
7711              ? config-&gt;useColour()
7712              : UseColour::Auto;
7713          if( colourMode == UseColour::Auto )
7714              colourMode = useColourOnPlatform()
7715                  ? UseColour::Yes
7716                  : UseColour::No;
7717          return colourMode == UseColour::Yes
7718              ? PosixColourImpl::instance()
7719              : NoColourImpl::instance();
7720      }
7721  } 
7722  } 
7723  #else  
7724  namespace Catch {
7725      static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
7726  } 
7727  #endif 
7728  namespace Catch {
7729      Colour::Colour( Code _colourCode ) { use( _colourCode ); }
7730      Colour::Colour( Colour&amp;&amp; other ) noexcept {
7731          m_moved = other.m_moved;
7732          other.m_moved = true;
7733      }
7734      Colour&amp; Colour::operator=( Colour&amp;&amp; other ) noexcept {
7735          m_moved = other.m_moved;
7736          other.m_moved  = true;
7737          return *this;
7738      }
7739      Colour::~Colour(){ if( !m_moved ) use( None ); }
7740      void Colour::use( Code _colourCode ) {
7741          static IColourImpl* impl = platformColourInstance();
7742          if (impl != nullptr) {
7743              impl-&gt;use( _colourCode );
7744          }
7745      }
7746      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Colour const&amp; ) {
7747          return os;
7748      }
7749  } 
7750  #if defined(__clang__)
7751  #    pragma clang diagnostic pop
7752  #endif
7753  namespace Catch {
7754      class Context : public IMutableContext, NonCopyable {
7755      public: 
7756          IResultCapture* getResultCapture() override {
7757              return m_resultCapture;
7758          }
7759          IRunner* getRunner() override {
7760              return m_runner;
7761          }
7762          IConfigPtr const&amp; getConfig() const override {
7763              return m_config;
7764          }
7765          ~Context() override;
7766      public: 
7767          void setResultCapture( IResultCapture* resultCapture ) override {
7768              m_resultCapture = resultCapture;
7769          }
7770          void setRunner( IRunner* runner ) override {
7771              m_runner = runner;
7772          }
7773          void setConfig( IConfigPtr const&amp; config ) override {
7774              m_config = config;
7775          }
7776          friend IMutableContext&amp; getCurrentMutableContext();
7777      private:
7778          IConfigPtr m_config;
7779          IRunner* m_runner = nullptr;
7780          IResultCapture* m_resultCapture = nullptr;
7781      };
7782      IMutableContext *IMutableContext::currentContext = nullptr;
7783      void IMutableContext::createContext()
7784      {
7785          currentContext = new Context();
7786      }
7787      void cleanUpContext() {
7788          delete IMutableContext::currentContext;
7789          IMutableContext::currentContext = nullptr;
7790      }
7791      IContext::~IContext() = default;
7792      IMutableContext::~IMutableContext() = default;
7793      Context::~Context() = default;
7794      SimplePcg32&amp; rng() {
7795          static SimplePcg32 s_rng;
7796          return s_rng;
7797      }
7798  }
7799  #include &lt;string&gt;
7800  namespace Catch {
7801      void writeToDebugConsole( std::string const&amp; text );
7802  }
7803  #if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
7804  #include &lt;android/log.h&gt;
7805      namespace Catch {
7806          void writeToDebugConsole( std::string const&amp; text ) {
7807              __android_log_write( ANDROID_LOG_DEBUG, &quot;Catch&quot;, text.c_str() );
7808          }
7809      }
7810  #elif defined(CATCH_PLATFORM_WINDOWS)
7811      namespace Catch {
7812          void writeToDebugConsole( std::string const&amp; text ) {
7813              ::OutputDebugStringA( text.c_str() );
7814          }
7815      }
7816  #else
7817      namespace Catch {
7818          void writeToDebugConsole( std::string const&amp; text ) {
7819              Catch::cout() &lt;&lt; text;
7820          }
7821      }
7822  #endif 
7823  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7824  #  include &lt;cassert&gt;
7825  #  include &lt;sys/types.h&gt;
7826  #  include &lt;unistd.h&gt;
7827  #  include &lt;cstddef&gt;
7828  #  include &lt;ostream&gt;
7829  #ifdef __apple_build_version__
7830  #  include &lt;sys/sysctl.h&gt;
7831  #endif
7832      namespace Catch {
7833          #ifdef __apple_build_version__
7834          bool isDebuggerActive(){
7835              int                 mib[4];
7836              struct kinfo_proc   info;
7837              std::size_t         size;
7838              info.kp_proc.p_flag = 0;
7839              mib[0] = CTL_KERN;
7840              mib[1] = KERN_PROC;
7841              mib[2] = KERN_PROC_PID;
7842              mib[3] = getpid();
7843              size = sizeof(info);
7844              if( sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, nullptr, 0) != 0 ) {
7845                  Catch::cerr() &lt;&lt; &quot;\n** Call to sysctl failed - unable to determine if debugger is active **\n&quot; &lt;&lt; std::endl;
7846                  return false;
7847              }
7848              return ( (info.kp_proc.p_flag &amp; P_TRACED) != 0 );
7849          }
7850          #else
7851          bool isDebuggerActive() {
7852              return false;
7853          }
7854          #endif
7855      } 
7856  #elif defined(CATCH_PLATFORM_LINUX)
7857      #include &lt;fstream&gt;
7858      #include &lt;string&gt;
7859      namespace Catch{
7860          bool isDebuggerActive(){
7861              ErrnoGuard guard;
7862              std::ifstream in(&quot;/proc/self/status&quot;);
7863              for( std::string line; std::getline(in, line); ) {
7864                  static const int PREFIX_LEN = 11;
7865                  if( line.compare(0, PREFIX_LEN, &quot;TracerPid:\t&quot;) == 0 ) {
7866                      return line.length() &gt; PREFIX_LEN &amp;&amp; line[PREFIX_LEN] != &#x27;0&#x27;;
7867                  }
7868              }
7869              return false;
7870          }
7871      } 
7872  #elif defined(_MSC_VER)
7873      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7874      namespace Catch {
7875          bool isDebuggerActive() {
7876              return IsDebuggerPresent() != 0;
7877          }
7878      }
7879  #elif defined(__MINGW32__)
7880      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7881      namespace Catch {
7882          bool isDebuggerActive() {
7883              return IsDebuggerPresent() != 0;
7884          }
7885      }
7886  #else
7887      namespace Catch {
7888         bool isDebuggerActive() { return false; }
7889      }
7890  #endif 
7891  namespace Catch {
7892      ITransientExpression::~ITransientExpression() = default;
7893      void formatReconstructedExpression( std::ostream &amp;os, std::string const&amp; lhs, StringRef op, std::string const&amp; rhs ) {
7894          if( lhs.size() + rhs.size() &lt; 40 &amp;&amp;
7895                  lhs.find(&#x27;\n&#x27;) == std::string::npos &amp;&amp;
7896                  rhs.find(&#x27;\n&#x27;) == std::string::npos )
7897              os &lt;&lt; lhs &lt;&lt; &quot; &quot; &lt;&lt; op &lt;&lt; &quot; &quot; &lt;&lt; rhs;
7898          else
7899              os &lt;&lt; lhs &lt;&lt; &quot;\n&quot; &lt;&lt; op &lt;&lt; &quot;\n&quot; &lt;&lt; rhs;
7900      }
7901  }
7902  #include &lt;stdexcept&gt;
7903  namespace Catch {
7904  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
7905      [[noreturn]]
7906      void throw_exception(std::exception const&amp; e) {
7907          Catch::cerr() &lt;&lt; &quot;Catch will terminate because it needed to throw an exception.\n&quot;
7908                        &lt;&lt; &quot;The message was: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;
7909          std::terminate();
7910      }
7911  #endif
7912      [[noreturn]]
7913      void throw_logic_error(std::string const&amp; msg) {
7914          throw_exception(std::logic_error(msg));
7915      }
7916      [[noreturn]]
7917      void throw_domain_error(std::string const&amp; msg) {
7918          throw_exception(std::domain_error(msg));
7919      }
7920      [[noreturn]]
7921      void throw_runtime_error(std::string const&amp; msg) {
7922          throw_exception(std::runtime_error(msg));
7923      }
7924  } 
7925  #include &lt;vector&gt;
7926  #include &lt;memory&gt;
7927  namespace Catch {
7928      namespace Detail {
7929          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values );
7930          class EnumValuesRegistry : public IMutableEnumValuesRegistry {
7931              std::vector&lt;std::unique_ptr&lt;EnumInfo&gt;&gt; m_enumInfos;
7932              EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::vector&lt;int&gt; const&amp; values) override;
7933          };
7934          std::vector&lt;StringRef&gt; parseEnums( StringRef enums );
7935      } 
7936  } 
7937  #include &lt;map&gt;
7938  #include &lt;cassert&gt;
7939  namespace Catch {
7940      IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}
7941      namespace Detail {
7942          namespace {
7943              StringRef extractInstanceName(StringRef enumInstance) {
7944                  size_t name_start = enumInstance.size();
7945                  while (name_start &gt; 0 &amp;&amp; enumInstance[name_start - 1] != &#x27;:&#x27;) {
7946                      --name_start;
7947                  }
7948                  return enumInstance.substr(name_start, enumInstance.size() - name_start);
7949              }
7950          }
7951          std::vector&lt;StringRef&gt; parseEnums( StringRef enums ) {
7952              auto enumValues = splitStringRef( enums, &#x27;,&#x27; );
7953              std::vector&lt;StringRef&gt; parsed;
7954              parsed.reserve( enumValues.size() );
7955              for( auto const&amp; enumValue : enumValues ) {
7956                  parsed.push_back(trim(extractInstanceName(enumValue)));
7957              }
7958              return parsed;
7959          }
7960          EnumInfo::~EnumInfo() {}
7961          StringRef EnumInfo::lookup( int value ) const {
7962              for( auto const&amp; valueToName : m_values ) {
7963                  if( valueToName.first == value )
7964                      return valueToName.second;
7965              }
7966              return &quot;{** unexpected enum value **}&quot;_sr;
7967          }
7968          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7969              std::unique_ptr&lt;EnumInfo&gt; enumInfo( new EnumInfo );
7970              enumInfo-&gt;m_name = enumName;
7971              enumInfo-&gt;m_values.reserve( values.size() );
7972              const auto valueNames = Catch::Detail::parseEnums( allValueNames );
7973              assert( valueNames.size() == values.size() );
7974              std::size_t i = 0;
7975              for( auto value : values )
7976                  enumInfo-&gt;m_values.emplace_back(value, valueNames[i++]);
7977              return enumInfo;
7978          }
7979          EnumInfo const&amp; EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7980              m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
7981              return *m_enumInfos.back();
7982          }
7983      } 
7984  } 
7985  #include &lt;cerrno&gt;
7986  namespace Catch {
7987          ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
7988          ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
7989  }
7990  #include &lt;vector&gt;
7991  #include &lt;string&gt;
7992  #include &lt;memory&gt;
7993  namespace Catch {
7994      class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
7995      public:
7996          ~ExceptionTranslatorRegistry();
7997          virtual void registerTranslator( const IExceptionTranslator* translator );
7998          std::string translateActiveException() const override;
7999          std::string tryTranslators() const;
8000      private:
8001          std::vector&lt;std::unique_ptr&lt;IExceptionTranslator const&gt;&gt; m_translators;
8002      };
8003  }
8004  #ifdef __OBJC__
8005  #import &quot;Foundation/Foundation.h&quot;
8006  #endif
8007  namespace Catch {
8008      ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
8009      }
8010      void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
8011          m_translators.push_back( std::unique_ptr&lt;const IExceptionTranslator&gt;( translator ) );
8012      }
8013  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
8014      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8015          try {
8016  #ifdef __OBJC__
8017              @try {
8018                  return tryTranslators();
8019              }
8020              @catch (NSException *exception) {
8021                  return Catch::Detail::stringify( [exception description] );
8022              }
8023  #else
8024              if (std::current_exception() == nullptr) {
8025                  return &quot;Non C++ exception. Possibly a CLR exception.&quot;;
8026              }
8027              return tryTranslators();
8028  #endif
8029          }
8030          catch( TestFailureException&amp; ) {
8031              std::rethrow_exception(std::current_exception());
8032          }
8033          catch( std::exception&amp; ex ) {
8034              return ex.what();
8035          }
8036          catch( std::string&amp; msg ) {
8037              return msg;
8038          }
8039          catch( const char* msg ) {
8040              return msg;
8041          }
8042          catch(...) {
8043              return &quot;Unknown exception&quot;;
8044          }
8045      }
8046      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8047          if (m_translators.empty()) {
8048              std::rethrow_exception(std::current_exception());
8049          } else {
8050              return m_translators[0]-&gt;translate(m_translators.begin() + 1, m_translators.end());
8051          }
8052      }
8053  #else 
8054      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8055          CATCH_INTERNAL_ERROR(&quot;Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8056      }
8057      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8058          CATCH_INTERNAL_ERROR(&quot;Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8059      }
8060  #endif
8061  }
8062  #include &lt;algorithm&gt;
8063  #if !defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; !defined( CATCH_CONFIG_POSIX_SIGNALS )
8064  namespace Catch {
8065      void FatalConditionHandler::engage_platform() {}
8066      void FatalConditionHandler::disengage_platform() {}
8067      FatalConditionHandler::FatalConditionHandler() = default;
8068      FatalConditionHandler::~FatalConditionHandler() = default;
8069  } 
8070  #endif 
8071  #if defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; defined( CATCH_CONFIG_POSIX_SIGNALS )
8072  #error &quot;Inconsistent configuration: Windows&#x27; SEH handling and POSIX signals cannot be enabled at the same time&quot;
8073  #endif 
8074  #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
8075  namespace {
8076      void reportFatal( char const * const message ) {
8077          Catch::getCurrentContext().getResultCapture()-&gt;handleFatalErrorCondition( message );
8078      }
8079      constexpr std::size_t minStackSizeForErrors = 32 * 1024;
8080  } 
8081  #endif 
8082  #if defined( CATCH_CONFIG_WINDOWS_SEH )
8083  namespace Catch {
8084      struct SignalDefs { DWORD id; const char* name; };
8085      static SignalDefs signalDefs[] = {
8086          { static_cast&lt;DWORD&gt;(EXCEPTION_ILLEGAL_INSTRUCTION),  &quot;SIGILL - Illegal instruction signal&quot; },
8087          { static_cast&lt;DWORD&gt;(EXCEPTION_STACK_OVERFLOW), &quot;SIGSEGV - Stack overflow&quot; },
8088          { static_cast&lt;DWORD&gt;(EXCEPTION_ACCESS_VIOLATION), &quot;SIGSEGV - Segmentation violation signal&quot; },
8089          { static_cast&lt;DWORD&gt;(EXCEPTION_INT_DIVIDE_BY_ZERO), &quot;Divide by zero error&quot; },
8090      };
8091      static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
8092          for (auto const&amp; def : signalDefs) {
8093              if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == def.id) {
8094                  reportFatal(def.name);
8095              }
8096          }
8097          return EXCEPTION_CONTINUE_SEARCH;
8098      }
8099      static PVOID exceptionHandlerHandle = nullptr;
8100      FatalConditionHandler::FatalConditionHandler() {
8101          ULONG guaranteeSize = static_cast&lt;ULONG&gt;(minStackSizeForErrors);
8102          if (!SetThreadStackGuarantee(&amp;guaranteeSize)) {
8103              Catch::cerr()
8104                  &lt;&lt; &quot;Failed to reserve piece of stack.&quot;
8105                  &lt;&lt; &quot; Stack overflows will not be reported successfully.&quot;;
8106          }
8107      }
8108      FatalConditionHandler::~FatalConditionHandler() = default;
8109      void FatalConditionHandler::engage_platform() {
8110          exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
8111          if (!exceptionHandlerHandle) {
8112              CATCH_RUNTIME_ERROR(&quot;Could not register vectored exception handler&quot;);
8113          }
8114      }
8115      void FatalConditionHandler::disengage_platform() {
8116          if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {
8117              CATCH_RUNTIME_ERROR(&quot;Could not unregister vectored exception handler&quot;);
8118          }
8119          exceptionHandlerHandle = nullptr;
8120      }
8121  } 
8122  #endif 
8123  #if defined( CATCH_CONFIG_POSIX_SIGNALS )
8124  #include &lt;signal.h&gt;
8125  namespace Catch {
8126      struct SignalDefs {
8127          int id;
8128          const char* name;
8129      };
8130      static SignalDefs signalDefs[] = {
8131          { SIGINT,  &quot;SIGINT - Terminal interrupt signal&quot; },
8132          { SIGILL,  &quot;SIGILL - Illegal instruction signal&quot; },
8133          { SIGFPE,  &quot;SIGFPE - Floating point error signal&quot; },
8134          { SIGSEGV, &quot;SIGSEGV - Segmentation violation signal&quot; },
8135          { SIGTERM, &quot;SIGTERM - Termination request signal&quot; },
8136          { SIGABRT, &quot;SIGABRT - Abort (abnormal termination) signal&quot; }
8137      };
8138  #if defined(__GNUC__)
8139  #    pragma GCC diagnostic push
8140  #    pragma GCC diagnostic ignored &quot;-Wmissing-field-initializers&quot;
8141  #endif
8142      static char* altStackMem = nullptr;
8143      static std::size_t altStackSize = 0;
8144      static stack_t oldSigStack{};
8145      static struct sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]{};
8146      static void restorePreviousSignalHandlers() {
8147          for (std::size_t i = 0; i &lt; sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
8148              sigaction(signalDefs[i].id, &amp;oldSigActions[i], nullptr);
8149          }
8150          sigaltstack(&amp;oldSigStack, nullptr);
8151      }
8152      static void handleSignal( int sig ) {
8153          char const * name = &quot;&lt;unknown signal&gt;&quot;;
8154          for (auto const&amp; def : signalDefs) {
8155              if (sig == def.id) {
8156                  name = def.name;
8157                  break;
8158              }
8159          }
8160          restorePreviousSignalHandlers();
8161          reportFatal( name );
8162          raise( sig );
8163      }
8164      FatalConditionHandler::FatalConditionHandler() {
8165          assert(!altStackMem &amp;&amp; &quot;Cannot initialize POSIX signal handler when one already exists&quot;);
8166          if (altStackSize == 0) {
8167              altStackSize = std::max(static_cast&lt;size_t&gt;(SIGSTKSZ), minStackSizeForErrors);
8168          }
8169          altStackMem = new char[altStackSize]();
8170      }
8171      FatalConditionHandler::~FatalConditionHandler() {
8172          delete[] altStackMem;
8173          altStackMem = nullptr;
8174      }
8175      void FatalConditionHandler::engage_platform() {
8176          stack_t sigStack;
8177          sigStack.ss_sp = altStackMem;
8178          sigStack.ss_size = altStackSize;
8179          sigStack.ss_flags = 0;
8180          sigaltstack(&amp;sigStack, &amp;oldSigStack);
8181          struct sigaction sa = { };
8182          sa.sa_handler = handleSignal;
8183          sa.sa_flags = SA_ONSTACK;
8184          for (std::size_t i = 0; i &lt; sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
8185              sigaction(signalDefs[i].id, &amp;sa, &amp;oldSigActions[i]);
8186          }
8187      }
8188  #if defined(__GNUC__)
8189  #    pragma GCC diagnostic pop
8190  #endif
8191      void FatalConditionHandler::disengage_platform() {
8192          restorePreviousSignalHandlers();
8193      }
8194  } 
8195  #endif 
8196  #include &lt;limits&gt;
8197  #include &lt;set&gt;
8198  namespace Catch {
8199  IGeneratorTracker::~IGeneratorTracker() {}
8200  const char* GeneratorException::what() const noexcept {
8201      return m_msg;
8202  }
8203  namespace Generators {
8204      GeneratorUntypedBase::~GeneratorUntypedBase() {}
8205      auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
8206          return getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );
8207      }
8208  } 
8209  } 
8210  namespace Catch {
8211      IResultCapture::~IResultCapture() = default;
8212  }
8213  namespace Catch {
8214      IConfig::~IConfig() = default;
8215  }
8216  namespace Catch {
8217      IExceptionTranslator::~IExceptionTranslator() = default;
8218      IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
8219  }
8220  namespace Catch {
8221      IRegistryHub::~IRegistryHub() = default;
8222      IMutableRegistryHub::~IMutableRegistryHub() = default;
8223  }
8224  namespace Catch {
8225      class ListeningReporter : public IStreamingReporter {
8226          using Reporters = std::vector&lt;IStreamingReporterPtr&gt;;
8227          Reporters m_listeners;
8228          IStreamingReporterPtr m_reporter = nullptr;
8229          ReporterPreferences m_preferences;
8230      public:
8231          ListeningReporter();
8232          void addListener( IStreamingReporterPtr&amp;&amp; listener );
8233          void addReporter( IStreamingReporterPtr&amp;&amp; reporter );
8234      public: 
8235          ReporterPreferences getPreferences() const override;
8236          void noMatchingTestCases( std::string const&amp; spec ) override;
8237          void reportInvalidArguments(std::string const&amp;arg) override;
8238          static std::set&lt;Verbosity&gt; getSupportedVerbosities();
8239  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
8240          void benchmarkPreparing(std::string const&amp; name) override;
8241          void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;
8242          void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;
8243          void benchmarkFailed(std::string const&amp;) override;
8244  #endif 
8245          void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;
8246          void testGroupStarting( GroupInfo const&amp; groupInfo ) override;
8247          void testCaseStarting( TestCaseInfo const&amp; testInfo ) override;
8248          void sectionStarting( SectionInfo const&amp; sectionInfo ) override;
8249          void assertionStarting( AssertionInfo const&amp; assertionInfo ) override;
8250          bool assertionEnded( AssertionStats const&amp; assertionStats ) override;
8251          void sectionEnded( SectionStats const&amp; sectionStats ) override;
8252          void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;
8253          void testGroupEnded( TestGroupStats const&amp; testGroupStats ) override;
8254          void testRunEnded( TestRunStats const&amp; testRunStats ) override;
8255          void skipTest( TestCaseInfo const&amp; testInfo ) override;
8256          bool isMulti() const override;
8257      };
8258  } 
8259  namespace Catch {
8260      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig )
8261      :   m_stream( &amp;_fullConfig-&gt;stream() ), m_fullConfig( _fullConfig ) {}
8262      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig, std::ostream&amp; _stream )
8263      :   m_stream( &amp;_stream ), m_fullConfig( _fullConfig ) {}
8264      std::ostream&amp; ReporterConfig::stream() const { return *m_stream; }
8265      IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
8266      TestRunInfo::TestRunInfo( std::string const&amp; _name ) : name( _name ) {}
8267      GroupInfo::GroupInfo(  std::string const&amp; _name,
8268                             std::size_t _groupIndex,
8269                             std::size_t _groupsCount )
8270      :   name( _name ),
8271          groupIndex( _groupIndex ),
8272          groupsCounts( _groupsCount )
8273      {}
8274       AssertionStats::AssertionStats( AssertionResult const&amp; _assertionResult,
8275                                       std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,
8276                                       Totals const&amp; _totals )
8277      :   assertionResult( _assertionResult ),
8278          infoMessages( _infoMessages ),
8279          totals( _totals )
8280      {
8281          assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
8282          if( assertionResult.hasMessage() ) {
8283              MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
8284              builder &lt;&lt; assertionResult.getMessage();
8285              builder.m_info.message = builder.m_stream.str();
8286              infoMessages.push_back( builder.m_info );
8287          }
8288      }
8289       AssertionStats::~AssertionStats() = default;
8290      SectionStats::SectionStats(  SectionInfo const&amp; _sectionInfo,
8291                                   Counts const&amp; _assertions,
8292                                   double _durationInSeconds,
8293                                   bool _missingAssertions )
8294      :   sectionInfo( _sectionInfo ),
8295          assertions( _assertions ),
8296          durationInSeconds( _durationInSeconds ),
8297          missingAssertions( _missingAssertions )
8298      {}
8299      SectionStats::~SectionStats() = default;
8300      TestCaseStats::TestCaseStats(  TestCaseInfo const&amp; _testInfo,
8301                                     Totals const&amp; _totals,
8302                                     std::string const&amp; _stdOut,
8303                                     std::string const&amp; _stdErr,
8304                                     bool _aborting )
8305      : testInfo( _testInfo ),
8306          totals( _totals ),
8307          stdOut( _stdOut ),
8308          stdErr( _stdErr ),
8309          aborting( _aborting )
8310      {}
8311      TestCaseStats::~TestCaseStats() = default;
8312      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo,
8313                                      Totals const&amp; _totals,
8314                                      bool _aborting )
8315      :   groupInfo( _groupInfo ),
8316          totals( _totals ),
8317          aborting( _aborting )
8318      {}
8319      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo )
8320      :   groupInfo( _groupInfo ),
8321          aborting( false )
8322      {}
8323      TestGroupStats::~TestGroupStats() = default;
8324      TestRunStats::TestRunStats(   TestRunInfo const&amp; _runInfo,
8325                      Totals const&amp; _totals,
8326                      bool _aborting )
8327      :   runInfo( _runInfo ),
8328          totals( _totals ),
8329          aborting( _aborting )
8330      {}
8331      TestRunStats::~TestRunStats() = default;
8332      void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
8333      bool IStreamingReporter::isMulti() const { return false; }
8334      IReporterFactory::~IReporterFactory() = default;
8335      IReporterRegistry::~IReporterRegistry() = default;
8336  } 
8337  namespace Catch {
8338      IRunner::~IRunner() = default;
8339  }
8340  namespace Catch {
8341      ITestInvoker::~ITestInvoker() = default;
8342      ITestCaseRegistry::~ITestCaseRegistry() = default;
8343  }
8344  #ifdef CATCH_CONFIG_WINDOWS_CRTDBG
8345  #include &lt;crtdbg.h&gt;
8346  namespace Catch {
8347      LeakDetector::LeakDetector() {
8348          int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
8349          flag |= _CRTDBG_LEAK_CHECK_DF;
8350          flag |= _CRTDBG_ALLOC_MEM_DF;
8351          _CrtSetDbgFlag(flag);
8352          _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
8353          _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
8354          _CrtSetBreakAlloc(-1);
8355      }
8356  }
8357  #else
8358      Catch::LeakDetector::LeakDetector() {}
8359  #endif
8360  Catch::LeakDetector::~LeakDetector() {
8361      Catch::cleanUp();
8362  }
8363  #include &lt;set&gt;
8364  namespace Catch {
8365      std::size_t listTests( Config const&amp; config );
8366      std::size_t listTestsNamesOnly( Config const&amp; config );
8367      struct TagInfo {
8368          void add( std::string const&amp; spelling );
8369          std::string all() const;
8370          std::set&lt;std::string&gt; spellings;
8371          std::size_t count = 0;
8372      };
8373      std::size_t listTags( Config const&amp; config );
8374      std::size_t listReporters();
8375      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config );
8376  } 
8377  namespace Catch {
8378      using namespace clara::TextFlow;
8379  }
8380  #include &lt;limits&gt;
8381  #include &lt;algorithm&gt;
8382  #include &lt;iomanip&gt;
8383  namespace Catch {
8384      std::size_t listTests( Config const&amp; config ) {
8385          TestSpec const&amp; testSpec = config.testSpec();
8386          if( config.hasTestFilters() )
8387              Catch::cout() &lt;&lt; &quot;Matching test cases:\n&quot;;
8388          else {
8389              Catch::cout() &lt;&lt; &quot;All available test cases:\n&quot;;
8390          }
8391          auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8392          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8393              Colour::Code colour = testCaseInfo.isHidden()
8394                  ? Colour::SecondaryText
8395                  : Colour::None;
8396              Colour colourGuard( colour );
8397              Catch::cout() &lt;&lt; Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) &lt;&lt; &quot;\n&quot;;
8398              if( config.verbosity() &gt;= Verbosity::High ) {
8399                  Catch::cout() &lt;&lt; Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) &lt;&lt; std::endl;
8400                  std::string description = testCaseInfo.description;
8401                  if( description.empty() )
8402                      description = &quot;(NO DESCRIPTION)&quot;;
8403                  Catch::cout() &lt;&lt; Column( description ).indent(4) &lt;&lt; std::endl;
8404              }
8405              if( !testCaseInfo.tags.empty() )
8406                  Catch::cout() &lt;&lt; Column( testCaseInfo.tagsAsString() ).indent( 6 ) &lt;&lt; &quot;\n&quot;;
8407          }
8408          if( !config.hasTestFilters() )
8409              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8410          else
8411              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;matching test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8412          return matchedTestCases.size();
8413      }
8414      std::size_t listTestsNamesOnly( Config const&amp; config ) {
8415          TestSpec const&amp; testSpec = config.testSpec();
8416          std::size_t matchedTests = 0;
8417          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8418          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8419              matchedTests++;
8420              if( startsWith( testCaseInfo.name, &#x27;#&#x27; ) )
8421                 Catch::cout() &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; testCaseInfo.name &lt;&lt; &#x27;&quot;&#x27;;
8422              else
8423                 Catch::cout() &lt;&lt; testCaseInfo.name;
8424              if ( config.verbosity() &gt;= Verbosity::High )
8425                  Catch::cout() &lt;&lt; &quot;\t@&quot; &lt;&lt; testCaseInfo.lineInfo;
8426              Catch::cout() &lt;&lt; std::endl;
8427          }
8428          return matchedTests;
8429      }
8430      void TagInfo::add( std::string const&amp; spelling ) {
8431          ++count;
8432          spellings.insert( spelling );
8433      }
8434      std::string TagInfo::all() const {
8435          size_t size = 0;
8436          for (auto const&amp; spelling : spellings) {
8437              size += spelling.size() + 2;
8438          }
8439          std::string out; out.reserve(size);
8440          for (auto const&amp; spelling : spellings) {
8441              out += &#x27;[&#x27;;
8442              out += spelling;
8443              out += &#x27;]&#x27;;
8444          }
8445          return out;
8446      }
8447      std::size_t listTags( Config const&amp; config ) {
8448          TestSpec const&amp; testSpec = config.testSpec();
8449          if( config.hasTestFilters() )
8450              Catch::cout() &lt;&lt; &quot;Tags for matching test cases:\n&quot;;
8451          else {
8452              Catch::cout() &lt;&lt; &quot;All available tags:\n&quot;;
8453          }
8454          std::map&lt;std::string, TagInfo&gt; tagCounts;
8455          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8456          for( auto const&amp; testCase : matchedTestCases ) {
8457              for( auto const&amp; tagName : testCase.getTestCaseInfo().tags ) {
8458                  std::string lcaseTagName = toLower( tagName );
8459                  auto countIt = tagCounts.find( lcaseTagName );
8460                  if( countIt == tagCounts.end() )
8461                      countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
8462                  countIt-&gt;second.add( tagName );
8463              }
8464          }
8465          for( auto const&amp; tagCount : tagCounts ) {
8466              ReusableStringStream rss;
8467              rss &lt;&lt; &quot;  &quot; &lt;&lt; std::setw(2) &lt;&lt; tagCount.second.count &lt;&lt; &quot;  &quot;;
8468              auto str = rss.str();
8469              auto wrapper = Column( tagCount.second.all() )
8470                                                      .initialIndent( 0 )
8471                                                      .indent( str.size() )
8472                                                      .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
8473              Catch::cout() &lt;&lt; str &lt;&lt; wrapper &lt;&lt; &#x27;\n&#x27;;
8474          }
8475          Catch::cout() &lt;&lt; pluralise( tagCounts.size(), &quot;tag&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8476          return tagCounts.size();
8477      }
8478      std::size_t listReporters() {
8479          Catch::cout() &lt;&lt; &quot;Available reporters:\n&quot;;
8480          IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
8481          std::size_t maxNameLen = 0;
8482          for( auto const&amp; factoryKvp : factories )
8483              maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
8484          for( auto const&amp; factoryKvp : factories ) {
8485              Catch::cout()
8486                      &lt;&lt; Column( factoryKvp.first + &quot;:&quot; )
8487                              .indent(2)
8488                              .width( 5+maxNameLen )
8489                      +  Column( factoryKvp.second-&gt;getDescription() )
8490                              .initialIndent(0)
8491                              .indent(2)
8492                              .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
8493                      &lt;&lt; &quot;\n&quot;;
8494          }
8495          Catch::cout() &lt;&lt; std::endl;
8496          return factories.size();
8497      }
8498      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config ) {
8499          Option&lt;std::size_t&gt; listedCount;
8500          getCurrentMutableContext().setConfig( config );
8501          if( config-&gt;listTests() )
8502              listedCount = listedCount.valueOr(0) + listTests( *config );
8503          if( config-&gt;listTestNamesOnly() )
8504              listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );
8505          if( config-&gt;listTags() )
8506              listedCount = listedCount.valueOr(0) + listTags( *config );
8507          if( config-&gt;listReporters() )
8508              listedCount = listedCount.valueOr(0) + listReporters();
8509          return listedCount;
8510      }
8511  } 
8512  namespace Catch {
8513  namespace Matchers {
8514      namespace Impl {
8515          std::string MatcherUntypedBase::toString() const {
8516              if( m_cachedToString.empty() )
8517                  m_cachedToString = describe();
8518              return m_cachedToString;
8519          }
8520          MatcherUntypedBase::~MatcherUntypedBase() = default;
8521      } 
8522  } 
8523  using namespace Matchers;
8524  using Matchers::Impl::MatcherBase;
8525  } 
8526  namespace Catch {
8527  namespace Matchers {
8528  namespace Exception {
8529  bool ExceptionMessageMatcher::match(std::exception const&amp; ex) const {
8530      return ex.what() == m_message;
8531  }
8532  std::string ExceptionMessageMatcher::describe() const {
8533      return &quot;exception message matches \&quot;&quot; + m_message + &quot;\&quot;&quot;;
8534  }
8535  }
8536  Exception::ExceptionMessageMatcher Message(std::string const&amp; message) {
8537      return Exception::ExceptionMessageMatcher(message);
8538  }
8539  } 
8540  } 
8541  namespace Catch {
8542      bool isnan(float f);
8543      bool isnan(double d);
8544  }
8545  #include &lt;string&gt;
8546  namespace Catch {
8547      template &lt;typename T&gt;
8548      std::string to_string(T const&amp; t) {
8549  #if defined(CATCH_CONFIG_CPP11_TO_STRING)
8550          return std::to_string(t);
8551  #else
8552          ReusableStringStream rss;
8553          rss &lt;&lt; t;
8554          return rss.str();
8555  #endif
8556      }
8557  } 
8558  #include &lt;algorithm&gt;
8559  #include &lt;cmath&gt;
8560  #include &lt;cstdlib&gt;
8561  #include &lt;cstdint&gt;
8562  #include &lt;cstring&gt;
8563  #include &lt;sstream&gt;
8564  #include &lt;type_traits&gt;
8565  #include &lt;iomanip&gt;
8566  #include &lt;limits&gt;
8567  namespace Catch {
8568  namespace {
8569      int32_t convert(float f) {
8570          static_assert(sizeof(float) == sizeof(int32_t), &quot;Important ULP matcher assumption violated&quot;);
8571          int32_t i;
8572          std::memcpy(&amp;i, &amp;f, sizeof(f));
8573          return i;
8574      }
8575      int64_t convert(double d) {
8576          static_assert(sizeof(double) == sizeof(int64_t), &quot;Important ULP matcher assumption violated&quot;);
8577          int64_t i;
8578          std::memcpy(&amp;i, &amp;d, sizeof(d));
8579          return i;
8580      }
8581      template &lt;typename FP&gt;
8582      bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
8583          if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
8584              return false;
8585          }
8586          auto lc = convert(lhs);
8587          auto rc = convert(rhs);
8588          if ((lc &lt; 0) != (rc &lt; 0)) {
8589              return lhs == rhs;
8590          }
8591          auto ulpDiff = std::abs(static_cast&lt;FP&gt;(lc - rc));
8592          return static_cast&lt;uint64_t&gt;(ulpDiff) &lt;= maxUlpDiff;
8593      }
8594  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8595      float nextafter(float x, float y) {
8596          return ::nextafterf(x, y);
8597      }
8598      double nextafter(double x, double y) {
8599          return ::nextafter(x, y);
8600      }
8601  #endif 
8602  template &lt;typename FP&gt;
8603  FP step(FP start, FP direction, uint64_t steps) {
8604      for (uint64_t i = 0; i &lt; steps; ++i) {
8605  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8606          start = Catch::nextafter(start, direction);
8607  #else
8608          start = std::nextafter(start, direction);
8609  #endif
8610      }
8611      return start;
8612  }
8613  bool marginComparison(double lhs, double rhs, double margin) {
8614      return (lhs + margin &gt;= rhs) &amp;&amp; (rhs + margin &gt;= lhs);
8615  }
8616  template &lt;typename FloatingPoint&gt;
8617  void write(std::ostream&amp; out, FloatingPoint num) {
8618      out &lt;&lt; std::scientific
8619          &lt;&lt; std::setprecision(std::numeric_limits&lt;FloatingPoint&gt;::max_digits10 - 1)
8620          &lt;&lt; num;
8621  }
8622  } 
8623  namespace Matchers {
8624  namespace Floating {
8625      enum class FloatingPointKind : uint8_t {
8626          Float,
8627          Double
8628      };
8629      WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
8630          :m_target{ target }, m_margin{ margin } {
8631          CATCH_ENFORCE(margin &gt;= 0, &quot;Invalid margin: &quot; &lt;&lt; margin &lt;&lt; &#x27;.&#x27;
8632              &lt;&lt; &quot; Margin has to be non-negative.&quot;);
8633      }
8634      bool WithinAbsMatcher::match(double const&amp; matchee) const {
8635          return (matchee + m_margin &gt;= m_target) &amp;&amp; (m_target + m_margin &gt;= matchee);
8636      }
8637      std::string WithinAbsMatcher::describe() const {
8638          return &quot;is within &quot; + ::Catch::Detail::stringify(m_margin) + &quot; of &quot; + ::Catch::Detail::stringify(m_target);
8639      }
8640      WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType)
8641          :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
8642          CATCH_ENFORCE(m_type == FloatingPointKind::Double
8643                     || m_ulps &lt; (std::numeric_limits&lt;uint32_t&gt;::max)(),
8644              &quot;Provided ULP is impossibly large for a float comparison.&quot;);
8645      }
8646  #if defined(__clang__)
8647  #pragma clang diagnostic push
8648  #pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;
8649  #endif
8650      bool WithinUlpsMatcher::match(double const&amp; matchee) const {
8651          switch (m_type) {
8652          case FloatingPointKind::Float:
8653              return almostEqualUlps&lt;float&gt;(static_cast&lt;float&gt;(matchee), static_cast&lt;float&gt;(m_target), m_ulps);
8654          case FloatingPointKind::Double:
8655              return almostEqualUlps&lt;double&gt;(matchee, m_target, m_ulps);
8656          default:
8657              CATCH_INTERNAL_ERROR( &quot;Unknown FloatingPointKind value&quot; );
8658          }
8659      }
8660  #if defined(__clang__)
8661  #pragma clang diagnostic pop
8662  #endif
8663      std::string WithinUlpsMatcher::describe() const {
8664          std::stringstream ret;
8665          ret &lt;&lt; &quot;is within &quot; &lt;&lt; m_ulps &lt;&lt; &quot; ULPs of &quot;;
8666          if (m_type == FloatingPointKind::Float) {
8667              write(ret, static_cast&lt;float&gt;(m_target));
8668              ret &lt;&lt; &#x27;f&#x27;;
8669          } else {
8670              write(ret, m_target);
8671          }
8672          ret &lt;&lt; &quot; ([&quot;;
8673          if (m_type == FloatingPointKind::Double) {
8674              write(ret, step(m_target, static_cast&lt;double&gt;(-INFINITY), m_ulps));
8675              ret &lt;&lt; &quot;, &quot;;
8676              write(ret, step(m_target, static_cast&lt;double&gt;( INFINITY), m_ulps));
8677          } else {
8678              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;(-INFINITY), m_ulps));
8679              ret &lt;&lt; &quot;, &quot;;
8680              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;( INFINITY), m_ulps));
8681          }
8682          ret &lt;&lt; &quot;])&quot;;
8683          return ret.str();
8684      }
8685      WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
8686          m_target(target),
8687          m_epsilon(epsilon){
8688          CATCH_ENFORCE(m_epsilon &gt;= 0., &quot;Relative comparison with epsilon &lt;  0 does not make sense.&quot;);
8689          CATCH_ENFORCE(m_epsilon  &lt; 1., &quot;Relative comparison with epsilon &gt;= 1 does not make sense.&quot;);
8690      }
8691      bool WithinRelMatcher::match(double const&amp; matchee) const {
8692          const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
8693          return marginComparison(matchee, m_target,
8694                                  std::isinf(relMargin)? 0 : relMargin);
8695      }
8696      std::string WithinRelMatcher::describe() const {
8697          Catch::ReusableStringStream sstr;
8698          sstr &lt;&lt; &quot;and &quot; &lt;&lt; m_target &lt;&lt; &quot; are within &quot; &lt;&lt; m_epsilon * 100. &lt;&lt; &quot;% of each other&quot;;
8699          return sstr.str();
8700      }
8701  }
8702  Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
8703      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
8704  }
8705  Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
8706      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
8707  }
8708  Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
8709      return Floating::WithinAbsMatcher(target, margin);
8710  }
8711  Floating::WithinRelMatcher WithinRel(double target, double eps) {
8712      return Floating::WithinRelMatcher(target, eps);
8713  }
8714  Floating::WithinRelMatcher WithinRel(double target) {
8715      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;double&gt;::epsilon() * 100);
8716  }
8717  Floating::WithinRelMatcher WithinRel(float target, float eps) {
8718      return Floating::WithinRelMatcher(target, eps);
8719  }
8720  Floating::WithinRelMatcher WithinRel(float target) {
8721      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;float&gt;::epsilon() * 100);
8722  }
8723  } 
8724  } 
8725  std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string&amp; desc) {
8726      if (desc.empty()) {
8727          return &quot;matches undescribed predicate&quot;;
8728      } else {
8729          return &quot;matches predicate: \&quot;&quot; + desc + &#x27;&quot;&#x27;;
8730      }
8731  }
8732  #include &lt;regex&gt;
8733  namespace Catch {
8734  namespace Matchers {
8735      namespace StdString {
8736          CasedString::CasedString( std::string const&amp; str, CaseSensitive::Choice caseSensitivity )
8737          :   m_caseSensitivity( caseSensitivity ),
8738              m_str( adjustString( str ) )
8739          {}
8740          std::string CasedString::adjustString( std::string const&amp; str ) const {
8741              return m_caseSensitivity == CaseSensitive::No
8742                     ? toLower( str )
8743                     : str;
8744          }
8745          std::string CasedString::caseSensitivitySuffix() const {
8746              return m_caseSensitivity == CaseSensitive::No
8747                     ? &quot; (case insensitive)&quot;
8748                     : std::string();
8749          }
8750          StringMatcherBase::StringMatcherBase( std::string const&amp; operation, CasedString const&amp; comparator )
8751          : m_comparator( comparator ),
8752            m_operation( operation ) {
8753          }
8754          std::string StringMatcherBase::describe() const {
8755              std::string description;
8756              description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
8757                                          m_comparator.caseSensitivitySuffix().size());
8758              description += m_operation;
8759              description += &quot;: \&quot;&quot;;
8760              description += m_comparator.m_str;
8761              description += &quot;\&quot;&quot;;
8762              description += m_comparator.caseSensitivitySuffix();
8763              return description;
8764          }
8765          EqualsMatcher::EqualsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;equals&quot;, comparator ) {}
8766          bool EqualsMatcher::match( std::string const&amp; source ) const {
8767              return m_comparator.adjustString( source ) == m_comparator.m_str;
8768          }
8769          ContainsMatcher::ContainsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;contains&quot;, comparator ) {}
8770          bool ContainsMatcher::match( std::string const&amp; source ) const {
8771              return contains( m_comparator.adjustString( source ), m_comparator.m_str );
8772          }
8773          StartsWithMatcher::StartsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;starts with&quot;, comparator ) {}
8774          bool StartsWithMatcher::match( std::string const&amp; source ) const {
8775              return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8776          }
8777          EndsWithMatcher::EndsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;ends with&quot;, comparator ) {}
8778          bool EndsWithMatcher::match( std::string const&amp; source ) const {
8779              return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8780          }
8781          RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
8782          bool RegexMatcher::match(std::string const&amp; matchee) const {
8783              auto flags = std::regex::ECMAScript; 
8784              if (m_caseSensitivity == CaseSensitive::Choice::No) {
8785                  flags |= std::regex::icase;
8786              }
8787              auto reg = std::regex(m_regex, flags);
8788              return std::regex_match(matchee, reg);
8789          }
8790          std::string RegexMatcher::describe() const {
8791              return &quot;matches &quot; + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? &quot; case sensitively&quot; : &quot; case insensitively&quot;);
8792          }
8793      } 
8794      StdString::EqualsMatcher Equals( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8795          return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
8796      }
8797      StdString::ContainsMatcher Contains( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8798          return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
8799      }
8800      StdString::EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8801          return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8802      }
8803      StdString::StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8804          return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8805      }
8806      StdString::RegexMatcher Matches(std::string const&amp; regex, CaseSensitive::Choice caseSensitivity) {
8807          return StdString::RegexMatcher(regex, caseSensitivity);
8808      }
8809  } 
8810  } 
8811  namespace Catch {
8812      bool uncaught_exceptions();
8813  } 
8814  #include &lt;cassert&gt;
8815  #include &lt;stack&gt;
8816  namespace Catch {
8817      MessageInfo::MessageInfo(   StringRef const&amp; _macroName,
8818                                  SourceLineInfo const&amp; _lineInfo,
8819                                  ResultWas::OfType _type )
8820      :   macroName( _macroName ),
8821          lineInfo( _lineInfo ),
8822          type( _type ),
8823          sequence( ++globalCount )
8824      {}
8825      bool MessageInfo::operator==( MessageInfo const&amp; other ) const {
8826          return sequence == other.sequence;
8827      }
8828      bool MessageInfo::operator&lt;( MessageInfo const&amp; other ) const {
8829          return sequence &lt; other.sequence;
8830      }
8831      unsigned int MessageInfo::globalCount = 0;
8832      Catch::MessageBuilder::MessageBuilder( StringRef const&amp; macroName,
8833                                             SourceLineInfo const&amp; lineInfo,
8834                                             ResultWas::OfType type )
8835          :m_info(macroName, lineInfo, type) {}
8836      ScopedMessage::ScopedMessage( MessageBuilder const&amp; builder )
8837      : m_info( builder.m_info ), m_moved()
8838      {
8839          m_info.message = builder.m_stream.str();
8840          getResultCapture().pushScopedMessage( m_info );
8841      }
8842      ScopedMessage::ScopedMessage( ScopedMessage&amp;&amp; old )
8843      : m_info( old.m_info ), m_moved()
8844      {
8845          old.m_moved = true;
8846      }
8847      ScopedMessage::~ScopedMessage() {
8848          if ( !uncaught_exceptions() &amp;&amp; !m_moved ){
8849              getResultCapture().popScopedMessage(m_info);
8850          }
8851      }
8852      Capturer::Capturer( StringRef macroName, SourceLineInfo const&amp; lineInfo, ResultWas::OfType resultType, StringRef names ) {
8853          auto trimmed = [&amp;] (size_t start, size_t end) {
8854              while (names[start] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[start]))) {
8855                  ++start;
8856              }
8857              while (names[end] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[end]))) {
8858                  --end;
8859              }
8860              return names.substr(start, end - start + 1);
8861          };
8862          auto skipq = [&amp;] (size_t start, char quote) {
8863              for (auto i = start + 1; i &lt; names.size() ; ++i) {
8864                  if (names[i] == quote)
8865                      return i;
8866                  if (names[i] == &#x27;\\&#x27;)
8867                      ++i;
8868              }
8869              CATCH_INTERNAL_ERROR(&quot;CAPTURE parsing encountered unmatched quote&quot;);
8870          };
8871          size_t start = 0;
8872          std::stack&lt;char&gt; openings;
8873          for (size_t pos = 0; pos &lt; names.size(); ++pos) {
8874              char c = names[pos];
8875              switch (c) {
8876              case &#x27;[&#x27;:
8877              case &#x27;{&#x27;:
8878              case &#x27;(&#x27;:
8879                  openings.push(c);
8880                  break;
8881              case &#x27;]&#x27;:
8882              case &#x27;}&#x27;:
8883              case &#x27;)&#x27;:
8884                  openings.pop();
8885                  break;
8886              case &#x27;&quot;&#x27;:
8887              case &#x27;\&#x27;&#x27;:
8888                  pos = skipq(pos, c);
8889                  break;
8890              case &#x27;,&#x27;:
8891                  if (start != pos &amp;&amp; openings.empty()) {
8892                      m_messages.emplace_back(macroName, lineInfo, resultType);
8893                      m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, pos));
8894                      m_messages.back().message += &quot; := &quot;;
8895                      start = pos;
8896                  }
8897              }
8898          }
8899          assert(openings.empty() &amp;&amp; &quot;Mismatched openings&quot;);
8900          m_messages.emplace_back(macroName, lineInfo, resultType);
8901          m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, names.size() - 1));
8902          m_messages.back().message += &quot; := &quot;;
8903      }
8904      Capturer::~Capturer() {
8905          if ( !uncaught_exceptions() ){
8906              assert( m_captured == m_messages.size() );
8907              for( size_t i = 0; i &lt; m_captured; ++i  )
8908                  m_resultCapture.popScopedMessage( m_messages[i] );
8909          }
8910      }
8911      void Capturer::captureValue( size_t index, std::string const&amp; value ) {
8912          assert( index &lt; m_messages.size() );
8913          m_messages[index].message += value;
8914          m_resultCapture.pushScopedMessage( m_messages[index] );
8915          m_captured++;
8916      }
8917  } 
8918  #ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8919  #define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8920  #include &lt;cstdio&gt;
8921  #include &lt;iosfwd&gt;
8922  #include &lt;string&gt;
8923  namespace Catch {
8924      class RedirectedStream {
8925          std::ostream&amp; m_originalStream;
8926          std::ostream&amp; m_redirectionStream;
8927          std::streambuf* m_prevBuf;
8928      public:
8929          RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream );
8930          ~RedirectedStream();
8931      };
8932      class RedirectedStdOut {
8933          ReusableStringStream m_rss;
8934          RedirectedStream m_cout;
8935      public:
8936          RedirectedStdOut();
8937          auto str() const -&gt; std::string;
8938      };
8939      class RedirectedStdErr {
8940          ReusableStringStream m_rss;
8941          RedirectedStream m_cerr;
8942          RedirectedStream m_clog;
8943      public:
8944          RedirectedStdErr();
8945          auto str() const -&gt; std::string;
8946      };
8947      class RedirectedStreams {
8948      public:
8949          RedirectedStreams(RedirectedStreams const&amp;) = delete;
8950          RedirectedStreams&amp; operator=(RedirectedStreams const&amp;) = delete;
8951          RedirectedStreams(RedirectedStreams&amp;&amp;) = delete;
8952          RedirectedStreams&amp; operator=(RedirectedStreams&amp;&amp;) = delete;
8953          RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr);
8954          ~RedirectedStreams();
8955      private:
8956          std::string&amp; m_redirectedCout;
8957          std::string&amp; m_redirectedCerr;
8958          RedirectedStdOut m_redirectedStdOut;
8959          RedirectedStdErr m_redirectedStdErr;
8960      };
8961  #if defined(CATCH_CONFIG_NEW_CAPTURE)
8962      class TempFile {
8963      public:
8964          TempFile(TempFile const&amp;) = delete;
8965          TempFile&amp; operator=(TempFile const&amp;) = delete;
8966          TempFile(TempFile&amp;&amp;) = delete;
8967          TempFile&amp; operator=(TempFile&amp;&amp;) = delete;
8968          TempFile();
8969          ~TempFile();
8970          std::FILE* getFile();
8971          std::string getContents();
8972      private:
8973          std::FILE* m_file = nullptr;
8974      #if defined(_MSC_VER)
8975          char m_buffer[L_tmpnam] = { 0 };
8976      #endif
8977      };
8978      class OutputRedirect {
8979      public:
8980          OutputRedirect(OutputRedirect const&amp;) = delete;
8981          OutputRedirect&amp; operator=(OutputRedirect const&amp;) = delete;
8982          OutputRedirect(OutputRedirect&amp;&amp;) = delete;
8983          OutputRedirect&amp; operator=(OutputRedirect&amp;&amp;) = delete;
8984          OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest);
8985          ~OutputRedirect();
8986      private:
8987          int m_originalStdout = -1;
8988          int m_originalStderr = -1;
8989          TempFile m_stdoutFile;
8990          TempFile m_stderrFile;
8991          std::string&amp; m_stdoutDest;
8992          std::string&amp; m_stderrDest;
8993      };
8994  #endif
8995  } 
8996  #endif 
8997  #include &lt;cstdio&gt;
8998  #include &lt;cstring&gt;
8999  #include &lt;fstream&gt;
9000  #include &lt;sstream&gt;
9001  #include &lt;stdexcept&gt;
9002  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9003      #if defined(_MSC_VER)
9004      #include &lt;io.h&gt;      
9005      #define dup _dup
9006      #define dup2 _dup2
9007      #define fileno _fileno
9008      #else
9009      #include &lt;unistd.h&gt;  
9010      #endif
9011  #endif
9012  namespace Catch {
9013      RedirectedStream::RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream )
9014      :   m_originalStream( originalStream ),
9015          m_redirectionStream( redirectionStream ),
9016          m_prevBuf( m_originalStream.rdbuf() )
9017      {
9018          m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
9019      }
9020      RedirectedStream::~RedirectedStream() {
9021          m_originalStream.rdbuf( m_prevBuf );
9022      }
9023      RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
9024      auto RedirectedStdOut::str() const -&gt; std::string { return m_rss.str(); }
9025      RedirectedStdErr::RedirectedStdErr()
9026      :   m_cerr( Catch::cerr(), m_rss.get() ),
9027          m_clog( Catch::clog(), m_rss.get() )
9028      {}
9029      auto RedirectedStdErr::str() const -&gt; std::string { return m_rss.str(); }
9030      RedirectedStreams::RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr)
9031      :   m_redirectedCout(redirectedCout),
9032          m_redirectedCerr(redirectedCerr)
9033      {}
9034      RedirectedStreams::~RedirectedStreams() {
9035          m_redirectedCout += m_redirectedStdOut.str();
9036          m_redirectedCerr += m_redirectedStdErr.str();
9037      }
9038  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9039  #if defined(_MSC_VER)
9040      TempFile::TempFile() {
9041          if (tmpnam_s(m_buffer)) {
9042              CATCH_RUNTIME_ERROR(&quot;Could not get a temp filename&quot;);
9043          }
9044          if (fopen_s(&amp;m_file, m_buffer, &quot;w+&quot;)) {
9045              char buffer[100];
9046              if (strerror_s(buffer, errno)) {
9047                  CATCH_RUNTIME_ERROR(&quot;Could not translate errno to a string&quot;);
9048              }
9049              CATCH_RUNTIME_ERROR(&quot;Could not open the temp file: &#x27;&quot; &lt;&lt; m_buffer &lt;&lt; &quot;&#x27; because: &quot; &lt;&lt; buffer);
9050          }
9051      }
9052  #else
9053      TempFile::TempFile() {
9054          m_file = std::tmpfile();
9055          if (!m_file) {
9056              CATCH_RUNTIME_ERROR(&quot;Could not create a temp file.&quot;);
9057          }
9058      }
9059  #endif
9060      TempFile::~TempFile() {
9061           std::fclose(m_file);
9062  #if defined(_MSC_VER)
9063           std::remove(m_buffer);
9064  #endif
9065      }
9066      FILE* TempFile::getFile() {
9067          return m_file;
9068      }
9069      std::string TempFile::getContents() {
9070          std::stringstream sstr;
9071          char buffer[100] = {};
9072          std::rewind(m_file);
9073          while (std::fgets(buffer, sizeof(buffer), m_file)) {
9074              sstr &lt;&lt; buffer;
9075          }
9076          return sstr.str();
9077      }
9078      OutputRedirect::OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest) :
9079          m_originalStdout(dup(1)),
9080          m_originalStderr(dup(2)),
9081          m_stdoutDest(stdout_dest),
9082          m_stderrDest(stderr_dest) {
9083          dup2(fileno(m_stdoutFile.getFile()), 1);
9084          dup2(fileno(m_stderrFile.getFile()), 2);
9085      }
9086      OutputRedirect::~OutputRedirect() {
9087          Catch::cout() &lt;&lt; std::flush;
9088          fflush(stdout);
9089          Catch::cerr() &lt;&lt; std::flush;
9090          Catch::clog() &lt;&lt; std::flush;
9091          fflush(stderr);
9092          dup2(m_originalStdout, 1);
9093          dup2(m_originalStderr, 2);
9094          m_stdoutDest += m_stdoutFile.getContents();
9095          m_stderrDest += m_stderrFile.getContents();
9096      }
9097  #endif 
9098  } 
9099  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9100      #if defined(_MSC_VER)
9101      #undef dup
9102      #undef dup2
9103      #undef fileno
9104      #endif
9105  #endif
9106  #include &lt;cmath&gt;
9107  namespace Catch {
9108  #if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
9109      bool isnan(float f) {
9110          return std::isnan(f);
9111      }
9112      bool isnan(double d) {
9113          return std::isnan(d);
9114      }
9115  #else
9116      bool isnan(float f) {
9117          return std::_isnan(f);
9118      }
9119      bool isnan(double d) {
9120          return std::_isnan(d);
9121      }
9122  #endif
9123  } 
9124  namespace Catch {
9125  namespace {
9126  #if defined(_MSC_VER)
9127  #pragma warning(push)
9128  #pragma warning(disable:4146) 
9129  #endif
9130          uint32_t rotate_right(uint32_t val, uint32_t count) {
9131              const uint32_t mask = 31;
9132              count &amp;= mask;
9133              return (val &gt;&gt; count) | (val &lt;&lt; (-count &amp; mask));
9134          }
9135  #if defined(_MSC_VER)
9136  #pragma warning(pop)
9137  #endif
9138  }
9139      SimplePcg32::SimplePcg32(result_type seed_) {
9140          seed(seed_);
9141      }
9142      void SimplePcg32::seed(result_type seed_) {
9143          m_state = 0;
9144          (*this)();
9145          m_state += seed_;
9146          (*this)();
9147      }
9148      void SimplePcg32::discard(uint64_t skip) {
9149          for (uint64_t s = 0; s &lt; skip; ++s) {
9150              static_cast&lt;void&gt;((*this)());
9151          }
9152      }
9153      SimplePcg32::result_type SimplePcg32::operator()() {
9154          const uint32_t xorshifted = static_cast&lt;uint32_t&gt;(((m_state &gt;&gt; 18u) ^ m_state) &gt;&gt; 27u);
9155          const auto output = rotate_right(xorshifted, m_state &gt;&gt; 59u);
9156          m_state = m_state * 6364136223846793005ULL + s_inc;
9157          return output;
9158      }
9159      bool operator==(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9160          return lhs.m_state == rhs.m_state;
9161      }
9162      bool operator!=(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9163          return lhs.m_state != rhs.m_state;
9164      }
9165  }
9166  #include &lt;vector&gt;
9167  #include &lt;set&gt;
9168  #include &lt;algorithm&gt;
9169  #include &lt;ios&gt;
9170  namespace Catch {
9171      class TestCase;
9172      struct IConfig;
9173      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases );
9174      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config );
9175      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config );
9176      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions );
9177      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );
9178      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );
9179      class TestRegistry : public ITestCaseRegistry {
9180      public:
9181          virtual ~TestRegistry() = default;
9182          virtual void registerTest( TestCase const&amp; testCase );
9183          std::vector&lt;TestCase&gt; const&amp; getAllTests() const override;
9184          std::vector&lt;TestCase&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const override;
9185      private:
9186          std::vector&lt;TestCase&gt; m_functions;
9187          mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
9188          mutable std::vector&lt;TestCase&gt; m_sortedFunctions;
9189          std::size_t m_unnamedCount = 0;
9190          std::ios_base::Init m_ostreamInit; 
9191      };
9192      class TestInvokerAsFunction : public ITestInvoker {
9193          void(*m_testAsFunction)();
9194      public:
9195          TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
9196          void invoke() const override;
9197      };
9198      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName );
9199  } 
9200  #include &lt;map&gt;
9201  namespace Catch {
9202      class ReporterRegistry : public IReporterRegistry {
9203      public:
9204          ~ReporterRegistry() override;
9205          IStreamingReporterPtr create( std::string const&amp; name, IConfigPtr const&amp; config ) const override;
9206          void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory );
9207          void registerListener( IReporterFactoryPtr const&amp; factory );
9208          FactoryMap const&amp; getFactories() const override;
9209          Listeners const&amp; getListeners() const override;
9210      private:
9211          FactoryMap m_factories;
9212          Listeners m_listeners;
9213      };
9214  }
9215  #include &lt;string&gt;
9216  namespace Catch {
9217      struct TagAlias {
9218          TagAlias(std::string const&amp; _tag, SourceLineInfo _lineInfo);
9219          std::string tag;
9220          SourceLineInfo lineInfo;
9221      };
9222  } 
9223  #include &lt;map&gt;
9224  namespace Catch {
9225      class TagAliasRegistry : public ITagAliasRegistry {
9226      public:
9227          ~TagAliasRegistry() override;
9228          TagAlias const* find( std::string const&amp; alias ) const override;
9229          std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const override;
9230          void add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo );
9231      private:
9232          std::map&lt;std::string, TagAlias&gt; m_registry;
9233      };
9234  } 
9235  #include &lt;vector&gt;
9236  #include &lt;exception&gt;
9237  namespace Catch {
9238      class StartupExceptionRegistry {
9239  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9240      public:
9241          void add(std::exception_ptr const&amp; exception) noexcept;
9242          std::vector&lt;std::exception_ptr&gt; const&amp; getExceptions() const noexcept;
9243      private:
9244          std::vector&lt;std::exception_ptr&gt; m_exceptions;
9245  #endif
9246      };
9247  } 
9248  namespace Catch {
9249      struct ISingleton {
9250          virtual ~ISingleton();
9251      };
9252      void addSingleton( ISingleton* singleton );
9253      void cleanupSingletons();
9254      template&lt;typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT&gt;
9255      class Singleton : SingletonImplT, public ISingleton {
9256          static auto getInternal() -&gt; Singleton* {
9257              static Singleton* s_instance = nullptr;
9258              if( !s_instance ) {
9259                  s_instance = new Singleton;
9260                  addSingleton( s_instance );
9261              }
9262              return s_instance;
9263          }
9264      public:
9265          static auto get() -&gt; InterfaceT const&amp; {
9266              return *getInternal();
9267          }
9268          static auto getMutable() -&gt; MutableInterfaceT&amp; {
9269              return *getInternal();
9270          }
9271      };
9272  } 
9273  namespace Catch {
9274      namespace {
9275          class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
9276                              private NonCopyable {
9277          public: 
9278              RegistryHub() = default;
9279              IReporterRegistry const&amp; getReporterRegistry() const override {
9280                  return m_reporterRegistry;
9281              }
9282              ITestCaseRegistry const&amp; getTestCaseRegistry() const override {
9283                  return m_testCaseRegistry;
9284              }
9285              IExceptionTranslatorRegistry const&amp; getExceptionTranslatorRegistry() const override {
9286                  return m_exceptionTranslatorRegistry;
9287              }
9288              ITagAliasRegistry const&amp; getTagAliasRegistry() const override {
9289                  return m_tagAliasRegistry;
9290              }
9291              StartupExceptionRegistry const&amp; getStartupExceptionRegistry() const override {
9292                  return m_exceptionRegistry;
9293              }
9294          public: 
9295              void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) override {
9296                  m_reporterRegistry.registerReporter( name, factory );
9297              }
9298              void registerListener( IReporterFactoryPtr const&amp; factory ) override {
9299                  m_reporterRegistry.registerListener( factory );
9300              }
9301              void registerTest( TestCase const&amp; testInfo ) override {
9302                  m_testCaseRegistry.registerTest( testInfo );
9303              }
9304              void registerTranslator( const IExceptionTranslator* translator ) override {
9305                  m_exceptionTranslatorRegistry.registerTranslator( translator );
9306              }
9307              void registerTagAlias( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) override {
9308                  m_tagAliasRegistry.add( alias, tag, lineInfo );
9309              }
9310              void registerStartupException() noexcept override {
9311  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9312                  m_exceptionRegistry.add(std::current_exception());
9313  #else
9314                  CATCH_INTERNAL_ERROR(&quot;Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
9315  #endif
9316              }
9317              IMutableEnumValuesRegistry&amp; getMutableEnumValuesRegistry() override {
9318                  return m_enumValuesRegistry;
9319              }
9320          private:
9321              TestRegistry m_testCaseRegistry;
9322              ReporterRegistry m_reporterRegistry;
9323              ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
9324              TagAliasRegistry m_tagAliasRegistry;
9325              StartupExceptionRegistry m_exceptionRegistry;
9326              Detail::EnumValuesRegistry m_enumValuesRegistry;
9327          };
9328      }
9329      using RegistryHubSingleton = Singleton&lt;RegistryHub, IRegistryHub, IMutableRegistryHub&gt;;
9330      IRegistryHub const&amp; getRegistryHub() {
9331          return RegistryHubSingleton::get();
9332      }
9333      IMutableRegistryHub&amp; getMutableRegistryHub() {
9334          return RegistryHubSingleton::getMutable();
9335      }
9336      void cleanUp() {
9337          cleanupSingletons();
9338          cleanUpContext();
9339      }
9340      std::string translateActiveException() {
9341          return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
9342      }
9343  } 
9344  namespace Catch {
9345      ReporterRegistry::~ReporterRegistry() = default;
9346      IStreamingReporterPtr ReporterRegistry::create( std::string const&amp; name, IConfigPtr const&amp; config ) const {
9347          auto it =  m_factories.find( name );
9348          if( it == m_factories.end() )
9349              return nullptr;
9350          return it-&gt;second-&gt;create( ReporterConfig( config ) );
9351      }
9352      void ReporterRegistry::registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) {
9353          m_factories.emplace(name, factory);
9354      }
9355      void ReporterRegistry::registerListener( IReporterFactoryPtr const&amp; factory ) {
9356          m_listeners.push_back( factory );
9357      }
9358      IReporterRegistry::FactoryMap const&amp; ReporterRegistry::getFactories() const {
9359          return m_factories;
9360      }
9361      IReporterRegistry::Listeners const&amp; ReporterRegistry::getListeners() const {
9362          return m_listeners;
9363      }
9364  }
9365  namespace Catch {
9366      bool isOk( ResultWas::OfType resultType ) {
9367          return ( resultType &amp; ResultWas::FailureBit ) == 0;
9368      }
9369      bool isJustInfo( int flags ) {
9370          return flags == ResultWas::Info;
9371      }
9372      ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
9373          return static_cast&lt;ResultDisposition::Flags&gt;( static_cast&lt;int&gt;( lhs ) | static_cast&lt;int&gt;( rhs ) );
9374      }
9375      bool shouldContinueOnFailure( int flags )    { return ( flags &amp; ResultDisposition::ContinueOnFailure ) != 0; }
9376      bool shouldSuppressFailure( int flags )      { return ( flags &amp; ResultDisposition::SuppressFail ) != 0; }
9377  } 
9378  #include &lt;cassert&gt;
9379  #include &lt;algorithm&gt;
9380  #include &lt;sstream&gt;
9381  namespace Catch {
9382      namespace Generators {
9383          struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
9384              GeneratorBasePtr m_generator;
9385              GeneratorTracker( TestCaseTracking::NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
9386              :   TrackerBase( nameAndLocation, ctx, parent )
9387              {}
9388              ~GeneratorTracker();
9389              static GeneratorTracker&amp; acquire( TrackerContext&amp; ctx, TestCaseTracking::NameAndLocation const&amp; nameAndLocation ) {
9390                  std::shared_ptr&lt;GeneratorTracker&gt; tracker;
9391                  ITracker&amp; currentTracker = ctx.currentTracker();
9392                  if (currentTracker.nameAndLocation() == nameAndLocation) {
9393                      auto thisTracker = currentTracker.parent().findChild(nameAndLocation);
9394                      assert(thisTracker);
9395                      assert(thisTracker-&gt;isGeneratorTracker());
9396                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;(thisTracker);
9397                  } else if ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
9398                      assert( childTracker );
9399                      assert( childTracker-&gt;isGeneratorTracker() );
9400                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;( childTracker );
9401                  } else {
9402                      tracker = std::make_shared&lt;GeneratorTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
9403                      currentTracker.addChild( tracker );
9404                  }
9405                  if( !tracker-&gt;isComplete() ) {
9406                      tracker-&gt;open();
9407                  }
9408                  return *tracker;
9409              }
9410              bool isGeneratorTracker() const override { return true; }
9411              auto hasGenerator() const -&gt; bool override {
9412                  return !!m_generator;
9413              }
9414              void close() override {
9415                  TrackerBase::close();
9416                  const bool should_wait_for_child = [&amp;]() {
9417                      if ( m_children.empty() ) {
9418                          return false;
9419                      }
9420                      if ( std::find_if(
9421                               m_children.begin(),
9422                               m_children.end(),
9423                               []( TestCaseTracking::ITrackerPtr tracker ) {
9424                                   return tracker-&gt;hasStarted();
9425                               } ) != m_children.end() ) {
9426                          return false;
9427                      }
9428                      auto* parent = m_parent;
9429                      while ( !parent-&gt;isSectionTracker() ) {
9430                          parent = &amp;( parent-&gt;parent() );
9431                      }
9432                      assert( parent &amp;&amp;
9433                              &quot;Missing root (test case) level section&quot; );
9434                      auto const&amp; parentSection =
9435                          static_cast&lt;SectionTracker&amp;&gt;( *parent );
9436                      auto const&amp; filters = parentSection.getFilters();
9437                      if ( filters.empty() ) {
9438                          return true;
9439                      }
9440                      for ( auto const&amp; child : m_children ) {
9441                          if ( child-&gt;isSectionTracker() &amp;&amp;
9442                               std::find( filters.begin(),
9443                                          filters.end(),
9444                                          static_cast&lt;SectionTracker&amp;&gt;( *child )
9445                                              .trimmedName() ) !=
9446                                   filters.end() ) {
9447                              return true;
9448                          }
9449                      }
9450                      return false;
9451                  }();
9452                  if ( should_wait_for_child ||
9453                       ( m_runState == CompletedSuccessfully &amp;&amp;
9454                         m_generator-&gt;next() ) ) {
9455                      m_children.clear();
9456                      m_runState = Executing;
9457                  }
9458              }
9459              auto getGenerator() const -&gt; GeneratorBasePtr const&amp; override {
9460                  return m_generator;
9461              }
9462              void setGenerator( GeneratorBasePtr&amp;&amp; generator ) override {
9463                  m_generator = std::move( generator );
9464              }
9465          };
9466          GeneratorTracker::~GeneratorTracker() {}
9467      }
9468      RunContext::RunContext(IConfigPtr const&amp; _config, IStreamingReporterPtr&amp;&amp; reporter)
9469      :   m_runInfo(_config-&gt;name()),
9470          m_context(getCurrentMutableContext()),
9471          m_config(_config),
9472          m_reporter(std::move(reporter)),
9473          m_lastAssertionInfo{ StringRef(), SourceLineInfo(&quot;&quot;,0), StringRef(), ResultDisposition::Normal },
9474          m_includeSuccessfulResults( m_config-&gt;includeSuccessfulResults() || m_reporter-&gt;getPreferences().shouldReportAllAssertions )
9475      {
9476          m_context.setRunner(this);
9477          m_context.setConfig(m_config);
9478          m_context.setResultCapture(this);
9479          m_reporter-&gt;testRunStarting(m_runInfo);
9480      }
9481      RunContext::~RunContext() {
9482          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
9483      }
9484      void RunContext::testGroupStarting(std::string const&amp; testSpec, std::size_t groupIndex, std::size_t groupsCount) {
9485          m_reporter-&gt;testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
9486      }
9487      void RunContext::testGroupEnded(std::string const&amp; testSpec, Totals const&amp; totals, std::size_t groupIndex, std::size_t groupsCount) {
9488          m_reporter-&gt;testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
9489      }
9490      Totals RunContext::runTest(TestCase const&amp; testCase) {
9491          Totals prevTotals = m_totals;
9492          std::string redirectedCout;
9493          std::string redirectedCerr;
9494          auto const&amp; testInfo = testCase.getTestCaseInfo();
9495          m_reporter-&gt;testCaseStarting(testInfo);
9496          m_activeTestCase = &amp;testCase;
9497          ITracker&amp; rootTracker = m_trackerContext.startRun();
9498          assert(rootTracker.isSectionTracker());
9499          static_cast&lt;SectionTracker&amp;&gt;(rootTracker).addInitialFilters(m_config-&gt;getSectionsToRun());
9500          do {
9501              m_trackerContext.startCycle();
9502              m_testCaseTracker = &amp;SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
9503              runCurrentTest(redirectedCout, redirectedCerr);
9504          } while (!m_testCaseTracker-&gt;isSuccessfullyCompleted() &amp;&amp; !aborting());
9505          Totals deltaTotals = m_totals.delta(prevTotals);
9506          if (testInfo.expectedToFail() &amp;&amp; deltaTotals.testCases.passed &gt; 0) {
9507              deltaTotals.assertions.failed++;
9508              deltaTotals.testCases.passed--;
9509              deltaTotals.testCases.failed++;
9510          }
9511          m_totals.testCases += deltaTotals.testCases;
9512          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9513                                    deltaTotals,
9514                                    redirectedCout,
9515                                    redirectedCerr,
9516                                    aborting()));
9517          m_activeTestCase = nullptr;
9518          m_testCaseTracker = nullptr;
9519          return deltaTotals;
9520      }
9521      IConfigPtr RunContext::config() const {
9522          return m_config;
9523      }
9524      IStreamingReporter&amp; RunContext::reporter() const {
9525          return *m_reporter;
9526      }
9527      void RunContext::assertionEnded(AssertionResult const &amp; result) {
9528          if (result.getResultType() == ResultWas::Ok) {
9529              m_totals.assertions.passed++;
9530              m_lastAssertionPassed = true;
9531          } else if (!result.isOk()) {
9532              m_lastAssertionPassed = false;
9533              if( m_activeTestCase-&gt;getTestCaseInfo().okToFail() )
9534                  m_totals.assertions.failedButOk++;
9535              else
9536                  m_totals.assertions.failed++;
9537          }
9538          else {
9539              m_lastAssertionPassed = true;
9540          }
9541          static_cast&lt;void&gt;(m_reporter-&gt;assertionEnded(AssertionStats(result, m_messages, m_totals)));
9542          if (result.getResultType() != ResultWas::Warning)
9543              m_messageScopes.clear();
9544          resetAssertionInfo();
9545          m_lastResult = result;
9546      }
9547      void RunContext::resetAssertionInfo() {
9548          m_lastAssertionInfo.macroName = StringRef();
9549          m_lastAssertionInfo.capturedExpression = &quot;{Unknown expression after the reported line}&quot;_sr;
9550      }
9551      bool RunContext::sectionStarted(SectionInfo const &amp; sectionInfo, Counts &amp; assertions) {
9552          ITracker&amp; sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
9553          if (!sectionTracker.isOpen())
9554              return false;
9555          m_activeSections.push_back(&amp;sectionTracker);
9556          m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
9557          m_reporter-&gt;sectionStarting(sectionInfo);
9558          assertions = m_totals.assertions;
9559          return true;
9560      }
9561      auto RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
9562          using namespace Generators;
9563          GeneratorTracker&amp; tracker = GeneratorTracker::acquire(m_trackerContext,
9564                                                                TestCaseTracking::NameAndLocation( static_cast&lt;std::string&gt;(generatorName), lineInfo ) );
9565          m_lastAssertionInfo.lineInfo = lineInfo;
9566          return tracker;
9567      }
9568      bool RunContext::testForMissingAssertions(Counts&amp; assertions) {
9569          if (assertions.total() != 0)
9570              return false;
9571          if (!m_config-&gt;warnAboutMissingAssertions())
9572              return false;
9573          if (m_trackerContext.currentTracker().hasChildren())
9574              return false;
9575          m_totals.assertions.failed++;
9576          assertions.failed++;
9577          return true;
9578      }
9579      void RunContext::sectionEnded(SectionEndInfo const &amp; endInfo) {
9580          Counts assertions = m_totals.assertions - endInfo.prevAssertions;
9581          bool missingAssertions = testForMissingAssertions(assertions);
9582          if (!m_activeSections.empty()) {
9583              m_activeSections.back()-&gt;close();
9584              m_activeSections.pop_back();
9585          }
9586          m_reporter-&gt;sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
9587          m_messages.clear();
9588          m_messageScopes.clear();
9589      }
9590      void RunContext::sectionEndedEarly(SectionEndInfo const &amp; endInfo) {
9591          if (m_unfinishedSections.empty())
9592              m_activeSections.back()-&gt;fail();
9593          else
9594              m_activeSections.back()-&gt;close();
9595          m_activeSections.pop_back();
9596          m_unfinishedSections.push_back(endInfo);
9597      }
9598  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
9599      void RunContext::benchmarkPreparing(std::string const&amp; name) {
9600          m_reporter-&gt;benchmarkPreparing(name);
9601      }
9602      void RunContext::benchmarkStarting( BenchmarkInfo const&amp; info ) {
9603          m_reporter-&gt;benchmarkStarting( info );
9604      }
9605      void RunContext::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) {
9606          m_reporter-&gt;benchmarkEnded( stats );
9607      }
9608      void RunContext::benchmarkFailed(std::string const &amp; error) {
9609          m_reporter-&gt;benchmarkFailed(error);
9610      }
9611  #endif 
9612      void RunContext::pushScopedMessage(MessageInfo const &amp; message) {
9613          m_messages.push_back(message);
9614      }
9615      void RunContext::popScopedMessage(MessageInfo const &amp; message) {
9616          m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
9617      }
9618      void RunContext::emplaceUnscopedMessage( MessageBuilder const&amp; builder ) {
9619          m_messageScopes.emplace_back( builder );
9620      }
9621      std::string RunContext::getCurrentTestName() const {
9622          return m_activeTestCase
9623              ? m_activeTestCase-&gt;getTestCaseInfo().name
9624              : std::string();
9625      }
9626      const AssertionResult * RunContext::getLastResult() const {
9627          return &amp;(*m_lastResult);
9628      }
9629      void RunContext::exceptionEarlyReported() {
9630          m_shouldReportUnexpected = false;
9631      }
9632      void RunContext::handleFatalErrorCondition( StringRef message ) {
9633          m_reporter-&gt;fatalErrorEncountered(message);
9634          AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
9635          tempResult.message = static_cast&lt;std::string&gt;(message);
9636          AssertionResult result(m_lastAssertionInfo, tempResult);
9637          assertionEnded(result);
9638          handleUnfinishedSections();
9639          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9640          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9641          Counts assertions;
9642          assertions.failed = 1;
9643          SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
9644          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9645          auto const&amp; testInfo = m_activeTestCase-&gt;getTestCaseInfo();
9646          Totals deltaTotals;
9647          deltaTotals.testCases.failed = 1;
9648          deltaTotals.assertions.failed = 1;
9649          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9650                                    deltaTotals,
9651                                    std::string(),
9652                                    std::string(),
9653                                    false));
9654          m_totals.testCases.failed++;
9655          testGroupEnded(std::string(), m_totals, 1, 1);
9656          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, false));
9657      }
9658      bool RunContext::lastAssertionPassed() {
9659           return m_lastAssertionPassed;
9660      }
9661      void RunContext::assertionPassed() {
9662          m_lastAssertionPassed = true;
9663          ++m_totals.assertions.passed;
9664          resetAssertionInfo();
9665          m_messageScopes.clear();
9666      }
9667      bool RunContext::aborting() const {
9668          return m_totals.assertions.failed &gt;= static_cast&lt;std::size_t&gt;(m_config-&gt;abortAfter());
9669      }
9670      void RunContext::runCurrentTest(std::string &amp; redirectedCout, std::string &amp; redirectedCerr) {
9671          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9672          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9673          m_reporter-&gt;sectionStarting(testCaseSection);
9674          Counts prevAssertions = m_totals.assertions;
9675          double duration = 0;
9676          m_shouldReportUnexpected = true;
9677          m_lastAssertionInfo = { &quot;TEST_CASE&quot;_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
9678          seedRng(*m_config);
9679          Timer timer;
9680          CATCH_TRY {
9681              if (m_reporter-&gt;getPreferences().shouldRedirectStdOut) {
9682  #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
9683                  RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);
9684                  timer.start();
9685                  invokeActiveTestCase();
9686  #else
9687                  OutputRedirect r(redirectedCout, redirectedCerr);
9688                  timer.start();
9689                  invokeActiveTestCase();
9690  #endif
9691              } else {
9692                  timer.start();
9693                  invokeActiveTestCase();
9694              }
9695              duration = timer.getElapsedSeconds();
9696          } CATCH_CATCH_ANON (TestFailureException&amp;) {
9697          } CATCH_CATCH_ALL {
9698              if( m_shouldReportUnexpected ) {
9699                  AssertionReaction dummyReaction;
9700                  handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
9701              }
9702          }
9703          Counts assertions = m_totals.assertions - prevAssertions;
9704          bool missingAssertions = testForMissingAssertions(assertions);
9705          m_testCaseTracker-&gt;close();
9706          handleUnfinishedSections();
9707          m_messages.clear();
9708          m_messageScopes.clear();
9709          SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
9710          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9711      }
9712      void RunContext::invokeActiveTestCase() {
9713          FatalConditionHandlerGuard _(&amp;m_fatalConditionhandler);
9714          m_activeTestCase-&gt;invoke();
9715      }
9716      void RunContext::handleUnfinishedSections() {
9717          for (auto it = m_unfinishedSections.rbegin(),
9718               itEnd = m_unfinishedSections.rend();
9719               it != itEnd;
9720               ++it)
9721              sectionEnded(*it);
9722          m_unfinishedSections.clear();
9723      }
9724      void RunContext::handleExpr(
9725          AssertionInfo const&amp; info,
9726          ITransientExpression const&amp; expr,
9727          AssertionReaction&amp; reaction
9728      ) {
9729          m_reporter-&gt;assertionStarting( info );
9730          bool negated = isFalseTest( info.resultDisposition );
9731          bool result = expr.getResult() != negated;
9732          if( result ) {
9733              if (!m_includeSuccessfulResults) {
9734                  assertionPassed();
9735              }
9736              else {
9737                  reportExpr(info, ResultWas::Ok, &amp;expr, negated);
9738              }
9739          }
9740          else {
9741              reportExpr(info, ResultWas::ExpressionFailed, &amp;expr, negated );
9742              populateReaction( reaction );
9743          }
9744      }
9745      void RunContext::reportExpr(
9746              AssertionInfo const &amp;info,
9747              ResultWas::OfType resultType,
9748              ITransientExpression const *expr,
9749              bool negated ) {
9750          m_lastAssertionInfo = info;
9751          AssertionResultData data( resultType, LazyExpression( negated ) );
9752          AssertionResult assertionResult{ info, data };
9753          assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
9754          assertionEnded( assertionResult );
9755      }
9756      void RunContext::handleMessage(
9757              AssertionInfo const&amp; info,
9758              ResultWas::OfType resultType,
9759              StringRef const&amp; message,
9760              AssertionReaction&amp; reaction
9761      ) {
9762          m_reporter-&gt;assertionStarting( info );
9763          m_lastAssertionInfo = info;
9764          AssertionResultData data( resultType, LazyExpression( false ) );
9765          data.message = static_cast&lt;std::string&gt;(message);
9766          AssertionResult assertionResult{ m_lastAssertionInfo, data };
9767          assertionEnded( assertionResult );
9768          if( !assertionResult.isOk() )
9769              populateReaction( reaction );
9770      }
9771      void RunContext::handleUnexpectedExceptionNotThrown(
9772              AssertionInfo const&amp; info,
9773              AssertionReaction&amp; reaction
9774      ) {
9775          handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
9776      }
9777      void RunContext::handleUnexpectedInflightException(
9778              AssertionInfo const&amp; info,
9779              std::string const&amp; message,
9780              AssertionReaction&amp; reaction
9781      ) {
9782          m_lastAssertionInfo = info;
9783          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9784          data.message = message;
9785          AssertionResult assertionResult{ info, data };
9786          assertionEnded( assertionResult );
9787          populateReaction( reaction );
9788      }
9789      void RunContext::populateReaction( AssertionReaction&amp; reaction ) {
9790          reaction.shouldDebugBreak = m_config-&gt;shouldDebugBreak();
9791          reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition &amp; ResultDisposition::Normal);
9792      }
9793      void RunContext::handleIncomplete(
9794              AssertionInfo const&amp; info
9795      ) {
9796          m_lastAssertionInfo = info;
9797          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9798          data.message = &quot;Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE&quot;;
9799          AssertionResult assertionResult{ info, data };
9800          assertionEnded( assertionResult );
9801      }
9802      void RunContext::handleNonExpr(
9803              AssertionInfo const &amp;info,
9804              ResultWas::OfType resultType,
9805              AssertionReaction &amp;reaction
9806      ) {
9807          m_lastAssertionInfo = info;
9808          AssertionResultData data( resultType, LazyExpression( false ) );
9809          AssertionResult assertionResult{ info, data };
9810          assertionEnded( assertionResult );
9811          if( !assertionResult.isOk() )
9812              populateReaction( reaction );
9813      }
9814      IResultCapture&amp; getResultCapture() {
9815          if (auto* capture = getCurrentContext().getResultCapture())
9816              return *capture;
9817          else
9818              CATCH_INTERNAL_ERROR(&quot;No result capture instance&quot;);
9819      }
9820      void seedRng(IConfig const&amp; config) {
9821          if (config.rngSeed() != 0) {
9822              std::srand(config.rngSeed());
9823              rng().seed(config.rngSeed());
9824          }
9825      }
9826      unsigned int rngSeed() {
9827          return getCurrentContext().getConfig()-&gt;rngSeed();
9828      }
9829  }
9830  namespace Catch {
9831      Section::Section( SectionInfo const&amp; info )
9832      :   m_info( info ),
9833          m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
9834      {
9835          m_timer.start();
9836      }
9837      Section::~Section() {
9838          if( m_sectionIncluded ) {
9839              SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
9840              if( uncaught_exceptions() )
9841                  getResultCapture().sectionEndedEarly( endInfo );
9842              else
9843                  getResultCapture().sectionEnded( endInfo );
9844          }
9845      }
9846      Section::operator bool() const {
9847          return m_sectionIncluded;
9848      }
9849  } 
9850  namespace Catch {
9851      SectionInfo::SectionInfo
9852          (   SourceLineInfo const&amp; _lineInfo,
9853              std::string const&amp; _name )
9854      :   name( _name ),
9855          lineInfo( _lineInfo )
9856      {}
9857  } 
9858  #include &lt;memory&gt;
9859  namespace Catch {
9860      class Session : NonCopyable {
9861      public:
9862          Session();
9863          ~Session() override;
9864          void showHelp() const;
9865          void libIdentify();
9866          int applyCommandLine( int argc, char const * const * argv );
9867      #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
9868          int applyCommandLine( int argc, wchar_t const * const * argv );
9869      #endif
9870          void useConfigData( ConfigData const&amp; configData );
9871          template&lt;typename CharT&gt;
9872          int run(int argc, CharT const * const argv[]) {
9873              if (m_startupExceptions)
9874                  return 1;
9875              int returnCode = applyCommandLine(argc, argv);
9876              if (returnCode == 0)
9877                  returnCode = run();
9878              return returnCode;
9879          }
9880          int run();
9881          clara::Parser const&amp; cli() const;
9882          void cli( clara::Parser const&amp; newParser );
9883          ConfigData&amp; configData();
9884          Config&amp; config();
9885      private:
9886          int runInternal();
9887          clara::Parser m_cli;
9888          ConfigData m_configData;
9889          std::shared_ptr&lt;Config&gt; m_config;
9890          bool m_startupExceptions = false;
9891      };
9892  } 
9893  #include &lt;iosfwd&gt;
9894  namespace Catch {
9895      struct Version {
9896          Version( Version const&amp; ) = delete;
9897          Version&amp; operator=( Version const&amp; ) = delete;
9898          Version(    unsigned int _majorVersion,
9899                      unsigned int _minorVersion,
9900                      unsigned int _patchNumber,
9901                      char const * const _branchName,
9902                      unsigned int _buildNumber );
9903          unsigned int const majorVersion;
9904          unsigned int const minorVersion;
9905          unsigned int const patchNumber;
9906          char const * const branchName;
9907          unsigned int const buildNumber;
9908          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version );
9909      };
9910      Version const&amp; libraryVersion();
9911  }
9912  #include &lt;cstdlib&gt;
9913  #include &lt;iomanip&gt;
9914  #include &lt;set&gt;
9915  #include &lt;iterator&gt;
9916  namespace Catch {
9917      namespace {
9918          const int MaxExitCode = 255;
9919          IStreamingReporterPtr createReporter(std::string const&amp; reporterName, IConfigPtr const&amp; config) {
9920              auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
9921              CATCH_ENFORCE(reporter, &quot;No reporter registered with name: &#x27;&quot; &lt;&lt; reporterName &lt;&lt; &quot;&#x27;&quot;);
9922              return reporter;
9923          }
9924          IStreamingReporterPtr makeReporter(std::shared_ptr&lt;Config&gt; const&amp; config) {
9925              if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
9926                  return createReporter(config-&gt;getReporterName(), config);
9927              }
9928              auto ret = std::unique_ptr&lt;IStreamingReporter&gt;(new ListeningReporter);
9929              auto&amp; multi = static_cast&lt;ListeningReporter&amp;&gt;(*ret);
9930              auto const&amp; listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
9931              for (auto const&amp; listener : listeners) {
9932                  multi.addListener(listener-&gt;create(Catch::ReporterConfig(config)));
9933              }
9934              multi.addReporter(createReporter(config-&gt;getReporterName(), config));
9935              return ret;
9936          }
9937          class TestGroup {
9938          public:
9939              explicit TestGroup(std::shared_ptr&lt;Config&gt; const&amp; config)
9940              : m_config{config}
9941              , m_context{config, makeReporter(config)}
9942              {
9943                  auto const&amp; allTestCases = getAllTestCasesSorted(*m_config);
9944                  m_matches = m_config-&gt;testSpec().matchesByFilter(allTestCases, *m_config);
9945                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9946                  if (m_matches.empty() &amp;&amp; invalidArgs.empty()) {
9947                      for (auto const&amp; test : allTestCases)
9948                          if (!test.isHidden())
9949                              m_tests.emplace(&amp;test);
9950                  } else {
9951                      for (auto const&amp; match : m_matches)
9952                          m_tests.insert(match.tests.begin(), match.tests.end());
9953                  }
9954              }
9955              Totals execute() {
9956                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9957                  Totals totals;
9958                  m_context.testGroupStarting(m_config-&gt;name(), 1, 1);
9959                  for (auto const&amp; testCase : m_tests) {
9960                      if (!m_context.aborting())
9961                          totals += m_context.runTest(*testCase);
9962                      else
9963                          m_context.reporter().skipTest(*testCase);
9964                  }
9965                  for (auto const&amp; match : m_matches) {
9966                      if (match.tests.empty()) {
9967                          m_context.reporter().noMatchingTestCases(match.name);
9968                          totals.error = -1;
9969                      }
9970                  }
9971                  if (!invalidArgs.empty()) {
9972                      for (auto const&amp; invalidArg: invalidArgs)
9973                           m_context.reporter().reportInvalidArguments(invalidArg);
9974                  }
9975                  m_context.testGroupEnded(m_config-&gt;name(), totals, 1, 1);
9976                  return totals;
9977              }
9978          private:
9979              using Tests = std::set&lt;TestCase const*&gt;;
9980              std::shared_ptr&lt;Config&gt; m_config;
9981              RunContext m_context;
9982              Tests m_tests;
9983              TestSpec::Matches m_matches;
9984          };
9985          void applyFilenamesAsTags(Catch::IConfig const&amp; config) {
9986              auto&amp; tests = const_cast&lt;std::vector&lt;TestCase&gt;&amp;&gt;(getAllTestCasesSorted(config));
9987              for (auto&amp; testCase : tests) {
9988                  auto tags = testCase.tags;
9989                  std::string filename = testCase.lineInfo.file;
9990                  auto lastSlash = filename.find_last_of(&quot;\\/&quot;);
9991                  if (lastSlash != std::string::npos) {
9992                      filename.erase(0, lastSlash);
9993                      filename[0] = &#x27;#&#x27;;
9994                  }
9995                  auto lastDot = filename.find_last_of(&#x27;.&#x27;);
9996                  if (lastDot != std::string::npos) {
9997                      filename.erase(lastDot);
9998                  }
9999                  tags.push_back(std::move(filename));
10000                  setTags(testCase, tags);
10001              }
10002          }
10003      } 
10004      Session::Session() {
10005          static bool alreadyInstantiated = false;
10006          if( alreadyInstantiated ) {
10007              CATCH_TRY { CATCH_INTERNAL_ERROR( &quot;Only one instance of Catch::Session can ever be used&quot; ); }
10008              CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
10009          }
10010  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10011          const auto&amp; exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
10012          if ( !exceptions.empty() ) {
10013              config();
10014              getCurrentMutableContext().setConfig(m_config);
10015              m_startupExceptions = true;
10016              Colour colourGuard( Colour::Red );
10017              Catch::cerr() &lt;&lt; &quot;Errors occurred during startup!&quot; &lt;&lt; &#x27;\n&#x27;;
10018              for ( const auto&amp; ex_ptr : exceptions ) {
10019                  try {
10020                      std::rethrow_exception(ex_ptr);
10021                  } catch ( std::exception const&amp; ex ) {
10022                      Catch::cerr() &lt;&lt; Column( ex.what() ).indent(2) &lt;&lt; &#x27;\n&#x27;;
10023                  }
10024              }
10025          }
10026  #endif
10027          alreadyInstantiated = true;
10028          m_cli = makeCommandLineParser( m_configData );
10029      }
10030      Session::~Session() {
10031          Catch::cleanUp();
10032      }
10033      void Session::showHelp() const {
10034          Catch::cout()
10035                  &lt;&lt; &quot;\nCatch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot;\n&quot;
10036                  &lt;&lt; m_cli &lt;&lt; std::endl
10037                  &lt;&lt; &quot;For more detailed usage please see the project docs\n&quot; &lt;&lt; std::endl;
10038      }
10039      void Session::libIdentify() {
10040          Catch::cout()
10041                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;description: &quot; &lt;&lt; &quot;A Catch2 test executable\n&quot;
10042                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;category: &quot; &lt;&lt; &quot;testframework\n&quot;
10043                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;framework: &quot; &lt;&lt; &quot;Catch Test\n&quot;
10044                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;version: &quot; &lt;&lt; libraryVersion() &lt;&lt; std::endl;
10045      }
10046      int Session::applyCommandLine( int argc, char const * const * argv ) {
10047          if( m_startupExceptions )
10048              return 1;
10049          auto result = m_cli.parse( clara::Args( argc, argv ) );
10050          if( !result ) {
10051              config();
10052              getCurrentMutableContext().setConfig(m_config);
10053              Catch::cerr()
10054                  &lt;&lt; Colour( Colour::Red )
10055                  &lt;&lt; &quot;\nError(s) in input:\n&quot;
10056                  &lt;&lt; Column( result.errorMessage() ).indent( 2 )
10057                  &lt;&lt; &quot;\n\n&quot;;
10058              Catch::cerr() &lt;&lt; &quot;Run with -? for usage\n&quot; &lt;&lt; std::endl;
10059              return MaxExitCode;
10060          }
10061          if( m_configData.showHelp )
10062              showHelp();
10063          if( m_configData.libIdentify )
10064              libIdentify();
10065          m_config.reset();
10066          return 0;
10067      }
10068  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
10069      int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {
10070          char **utf8Argv = new char *[ argc ];
10071          for ( int i = 0; i &lt; argc; ++i ) {
10072              int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );
10073              utf8Argv[ i ] = new char[ bufSize ];
10074              WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
10075          }
10076          int returnCode = applyCommandLine( argc, utf8Argv );
10077          for ( int i = 0; i &lt; argc; ++i )
10078              delete [] utf8Argv[ i ];
10079          delete [] utf8Argv;
10080          return returnCode;
10081      }
10082  #endif
10083      void Session::useConfigData( ConfigData const&amp; configData ) {
10084          m_configData = configData;
10085          m_config.reset();
10086      }
10087      int Session::run() {
10088          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeStart ) != 0 ) {
10089              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before starting&quot; &lt;&lt; std::endl;
10090              static_cast&lt;void&gt;(std::getchar());
10091          }
10092          int exitCode = runInternal();
10093          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeExit ) != 0 ) {
10094              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before exiting, with code: &quot; &lt;&lt; exitCode &lt;&lt; std::endl;
10095              static_cast&lt;void&gt;(std::getchar());
10096          }
10097          return exitCode;
10098      }
10099      clara::Parser const&amp; Session::cli() const {
10100          return m_cli;
10101      }
10102      void Session::cli( clara::Parser const&amp; newParser ) {
10103          m_cli = newParser;
10104      }
10105      ConfigData&amp; Session::configData() {
10106          return m_configData;
10107      }
10108      Config&amp; Session::config() {
10109          if( !m_config )
10110              m_config = std::make_shared&lt;Config&gt;( m_configData );
10111          return *m_config;
10112      }
10113      int Session::runInternal() {
10114          if( m_startupExceptions )
10115              return 1;
10116          if (m_configData.showHelp || m_configData.libIdentify) {
10117              return 0;
10118          }
10119          CATCH_TRY {
10120              config(); 
10121              seedRng( *m_config );
10122              if( m_configData.filenamesAsTags )
10123                  applyFilenamesAsTags( *m_config );
10124              if( Option&lt;std::size_t&gt; listed = list( m_config ) )
10125                  return static_cast&lt;int&gt;( *listed );
10126              TestGroup tests { m_config };
10127              auto const totals = tests.execute();
10128              if( m_config-&gt;warnAboutNoTests() &amp;&amp; totals.error == -1 )
10129                  return 2;
10130              return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast&lt;int&gt;(totals.assertions.failed)));
10131          }
10132  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10133          catch( std::exception&amp; ex ) {
10134              Catch::cerr() &lt;&lt; ex.what() &lt;&lt; std::endl;
10135              return MaxExitCode;
10136          }
10137  #endif
10138      }
10139  } 
10140  #include &lt;vector&gt;
10141  namespace Catch {
10142      namespace {
10143          static auto getSingletons() -&gt; std::vector&lt;ISingleton*&gt;*&amp; {
10144              static std::vector&lt;ISingleton*&gt;* g_singletons = nullptr;
10145              if( !g_singletons )
10146                  g_singletons = new std::vector&lt;ISingleton*&gt;();
10147              return g_singletons;
10148          }
10149      }
10150      ISingleton::~ISingleton() {}
10151      void addSingleton(ISingleton* singleton ) {
10152          getSingletons()-&gt;push_back( singleton );
10153      }
10154      void cleanupSingletons() {
10155          auto&amp; singletons = getSingletons();
10156          for( auto singleton : *singletons )
10157              delete singleton;
10158          delete singletons;
10159          singletons = nullptr;
10160      }
10161  } 
10162  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10163  namespace Catch {
10164  void StartupExceptionRegistry::add( std::exception_ptr const&amp; exception ) noexcept {
10165          CATCH_TRY {
10166              m_exceptions.push_back(exception);
10167          } CATCH_CATCH_ALL {
10168              std::terminate();
10169          }
10170      }
10171      std::vector&lt;std::exception_ptr&gt; const&amp; StartupExceptionRegistry::getExceptions() const noexcept {
10172          return m_exceptions;
10173      }
10174  } 
10175  #endif
10176  #include &lt;cstdio&gt;
10177  #include &lt;iostream&gt;
10178  #include &lt;fstream&gt;
10179  #include &lt;sstream&gt;
10180  #include &lt;vector&gt;
10181  #include &lt;memory&gt;
10182  namespace Catch {
10183      Catch::IStream::~IStream() = default;
10184      namespace Detail { namespace {
10185          template&lt;typename WriterF, std::size_t bufferSize=256&gt;
10186          class StreamBufImpl : public std::streambuf {
10187              char data[bufferSize];
10188              WriterF m_writer;
10189          public:
10190              StreamBufImpl() {
10191                  setp( data, data + sizeof(data) );
10192              }
10193              ~StreamBufImpl() noexcept {
10194                  StreamBufImpl::sync();
10195              }
10196          private:
10197              int overflow( int c ) override {
10198                  sync();
10199                  if( c != EOF ) {
10200                      if( pbase() == epptr() )
10201                          m_writer( std::string( 1, static_cast&lt;char&gt;( c ) ) );
10202                      else
10203                          sputc( static_cast&lt;char&gt;( c ) );
10204                  }
10205                  return 0;
10206              }
10207              int sync() override {
10208                  if( pbase() != pptr() ) {
10209                      m_writer( std::string( pbase(), static_cast&lt;std::string::size_type&gt;( pptr() - pbase() ) ) );
10210                      setp( pbase(), epptr() );
10211                  }
10212                  return 0;
10213              }
10214          };
10215          struct OutputDebugWriter {
10216              void operator()( std::string const&amp;str ) {
10217                  writeToDebugConsole( str );
10218              }
10219          };
10220          class FileStream : public IStream {
10221              mutable std::ofstream m_ofs;
10222          public:
10223              FileStream( StringRef filename ) {
10224                  m_ofs.open( filename.c_str() );
10225                  CATCH_ENFORCE( !m_ofs.fail(), &quot;Unable to open file: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10226              }
10227              ~FileStream() override = default;
10228          public: 
10229              std::ostream&amp; stream() const override {
10230                  return m_ofs;
10231              }
10232          };
10233          class CoutStream : public IStream {
10234              mutable std::ostream m_os;
10235          public:
10236              CoutStream() : m_os( Catch::cout().rdbuf() ) {}
10237              ~CoutStream() override = default;
10238          public: 
10239              std::ostream&amp; stream() const override { return m_os; }
10240          };
10241          class DebugOutStream : public IStream {
10242              std::unique_ptr&lt;StreamBufImpl&lt;OutputDebugWriter&gt;&gt; m_streamBuf;
10243              mutable std::ostream m_os;
10244          public:
10245              DebugOutStream()
10246              :   m_streamBuf( new StreamBufImpl&lt;OutputDebugWriter&gt;() ),
10247                  m_os( m_streamBuf.get() )
10248              {}
10249              ~DebugOutStream() override = default;
10250          public: 
10251              std::ostream&amp; stream() const override { return m_os; }
10252          };
10253      }} 
10254      auto makeStream( StringRef const &amp;filename ) -&gt; IStream const* {
10255          if( filename.empty() )
10256              return new Detail::CoutStream();
10257          else if( filename[0] == &#x27;%&#x27; ) {
10258              if( filename == &quot;%debug&quot; )
10259                  return new Detail::DebugOutStream();
10260              else
10261                  CATCH_ERROR( &quot;Unrecognised stream: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10262          }
10263          else
10264              return new Detail::FileStream( filename );
10265      }
10266      struct StringStreams {
10267          std::vector&lt;std::unique_ptr&lt;std::ostringstream&gt;&gt; m_streams;
10268          std::vector&lt;std::size_t&gt; m_unused;
10269          std::ostringstream m_referenceStream; 
10270          auto add() -&gt; std::size_t {
10271              if( m_unused.empty() ) {
10272                  m_streams.push_back( std::unique_ptr&lt;std::ostringstream&gt;( new std::ostringstream ) );
10273                  return m_streams.size()-1;
10274              }
10275              else {
10276                  auto index = m_unused.back();
10277                  m_unused.pop_back();
10278                  return index;
10279              }
10280          }
10281          void release( std::size_t index ) {
10282              m_streams[index]-&gt;copyfmt( m_referenceStream ); 
10283              m_unused.push_back(index);
10284          }
10285      };
10286      ReusableStringStream::ReusableStringStream()
10287      :   m_index( Singleton&lt;StringStreams&gt;::getMutable().add() ),
10288          m_oss( Singleton&lt;StringStreams&gt;::getMutable().m_streams[m_index].get() )
10289      {}
10290      ReusableStringStream::~ReusableStringStream() {
10291          static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str(&quot;&quot;);
10292          m_oss-&gt;clear();
10293          Singleton&lt;StringStreams&gt;::getMutable().release( m_index );
10294      }
10295      auto ReusableStringStream::str() const -&gt; std::string {
10296          return static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str();
10297      }
10298  #ifndef CATCH_CONFIG_NOSTDOUT 
10299      std::ostream&amp; cout() { return std::cout; }
10300      std::ostream&amp; cerr() { return std::cerr; }
10301      std::ostream&amp; clog() { return std::clog; }
10302  #endif
10303  }
10304  #include &lt;algorithm&gt;
10305  #include &lt;ostream&gt;
10306  #include &lt;cstring&gt;
10307  #include &lt;cctype&gt;
10308  #include &lt;vector&gt;
10309  namespace Catch {
10310      namespace {
10311          char toLowerCh(char c) {
10312              return static_cast&lt;char&gt;( std::tolower( static_cast&lt;unsigned char&gt;(c) ) );
10313          }
10314      }
10315      bool startsWith( std::string const&amp; s, std::string const&amp; prefix ) {
10316          return s.size() &gt;= prefix.size() &amp;&amp; std::equal(prefix.begin(), prefix.end(), s.begin());
10317      }
10318      bool startsWith( std::string const&amp; s, char prefix ) {
10319          return !s.empty() &amp;&amp; s[0] == prefix;
10320      }
10321      bool endsWith( std::string const&amp; s, std::string const&amp; suffix ) {
10322          return s.size() &gt;= suffix.size() &amp;&amp; std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
10323      }
10324      bool endsWith( std::string const&amp; s, char suffix ) {
10325          return !s.empty() &amp;&amp; s[s.size()-1] == suffix;
10326      }
10327      bool contains( std::string const&amp; s, std::string const&amp; infix ) {
10328          return s.find( infix ) != std::string::npos;
10329      }
10330      void toLowerInPlace( std::string&amp; s ) {
10331          std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
10332      }
10333      std::string toLower( std::string const&amp; s ) {
10334          std::string lc = s;
10335          toLowerInPlace( lc );
10336          return lc;
10337      }
10338      std::string trim( std::string const&amp; str ) {
10339          static char const* whitespaceChars = &quot;\n\r\t &quot;;
10340          std::string::size_type start = str.find_first_not_of( whitespaceChars );
10341          std::string::size_type end = str.find_last_not_of( whitespaceChars );
10342          return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
10343      }
10344      StringRef trim(StringRef ref) {
10345          const auto is_ws = [](char c) {
10346              return c == &#x27; &#x27; || c == &#x27;\t&#x27; || c == &#x27;\n&#x27; || c == &#x27;\r&#x27;;
10347          };
10348          size_t real_begin = 0;
10349          while (real_begin &lt; ref.size() &amp;&amp; is_ws(ref[real_begin])) { ++real_begin; }
10350          size_t real_end = ref.size();
10351          while (real_end &gt; real_begin &amp;&amp; is_ws(ref[real_end - 1])) { --real_end; }
10352          return ref.substr(real_begin, real_end - real_begin);
10353      }
10354      bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis ) {
10355          bool replaced = false;
10356          std::size_t i = str.find( replaceThis );
10357          while( i != std::string::npos ) {
10358              replaced = true;
10359              str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
10360              if( i &lt; str.size()-withThis.size() )
10361                  i = str.find( replaceThis, i+withThis.size() );
10362              else
10363                  i = std::string::npos;
10364          }
10365          return replaced;
10366      }
10367      std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter ) {
10368          std::vector&lt;StringRef&gt; subStrings;
10369          std::size_t start = 0;
10370          for(std::size_t pos = 0; pos &lt; str.size(); ++pos ) {
10371              if( str[pos] == delimiter ) {
10372                  if( pos - start &gt; 1 )
10373                      subStrings.push_back( str.substr( start, pos-start ) );
10374                  start = pos+1;
10375              }
10376          }
10377          if( start &lt; str.size() )
10378              subStrings.push_back( str.substr( start, str.size()-start ) );
10379          return subStrings;
10380      }
10381      pluralise::pluralise( std::size_t count, std::string const&amp; label )
10382      :   m_count( count ),
10383          m_label( label )
10384      {}
10385      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser ) {
10386          os &lt;&lt; pluraliser.m_count &lt;&lt; &#x27; &#x27; &lt;&lt; pluraliser.m_label;
10387          if( pluraliser.m_count != 1 )
10388              os &lt;&lt; &#x27;s&#x27;;
10389          return os;
10390      }
10391  }
10392  #include &lt;algorithm&gt;
10393  #include &lt;ostream&gt;
10394  #include &lt;cstring&gt;
10395  #include &lt;cstdint&gt;
10396  namespace Catch {
10397      StringRef::StringRef( char const* rawChars ) noexcept
10398      : StringRef( rawChars, static_cast&lt;StringRef::size_type&gt;(std::strlen(rawChars) ) )
10399      {}
10400      auto StringRef::c_str() const -&gt; char const* {
10401          CATCH_ENFORCE(isNullTerminated(), &quot;Called StringRef::c_str() on a non-null-terminated instance&quot;);
10402          return m_start;
10403      }
10404      auto StringRef::data() const noexcept -&gt; char const* {
10405          return m_start;
10406      }
10407      auto StringRef::substr( size_type start, size_type size ) const noexcept -&gt; StringRef {
10408          if (start &lt; m_size) {
10409              return StringRef(m_start + start, (std::min)(m_size - start, size));
10410          } else {
10411              return StringRef();
10412          }
10413      }
10414      auto StringRef::operator == ( StringRef const&amp; other ) const noexcept -&gt; bool {
10415          return m_size == other.m_size
10416              &amp;&amp; (std::memcmp( m_start, other.m_start, m_size ) == 0);
10417      }
10418      auto operator &lt;&lt; ( std::ostream&amp; os, StringRef const&amp; str ) -&gt; std::ostream&amp; {
10419          return os.write(str.data(), str.size());
10420      }
10421      auto operator+=( std::string&amp; lhs, StringRef const&amp; rhs ) -&gt; std::string&amp; {
10422          lhs.append(rhs.data(), rhs.size());
10423          return lhs;
10424      }
10425  } 
10426  namespace Catch {
10427      TagAlias::TagAlias(std::string const &amp; _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
10428  }
10429  namespace Catch {
10430      RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const&amp; lineInfo) {
10431          CATCH_TRY {
10432              getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
10433          } CATCH_CATCH_ALL {
10434              getMutableRegistryHub().registerStartupException();
10435          }
10436      }
10437  }
10438  #include &lt;sstream&gt;
10439  namespace Catch {
10440      TagAliasRegistry::~TagAliasRegistry() {}
10441      TagAlias const* TagAliasRegistry::find( std::string const&amp; alias ) const {
10442          auto it = m_registry.find( alias );
10443          if( it != m_registry.end() )
10444              return &amp;(it-&gt;second);
10445          else
10446              return nullptr;
10447      }
10448      std::string TagAliasRegistry::expandAliases( std::string const&amp; unexpandedTestSpec ) const {
10449          std::string expandedTestSpec = unexpandedTestSpec;
10450          for( auto const&amp; registryKvp : m_registry ) {
10451              std::size_t pos = expandedTestSpec.find( registryKvp.first );
10452              if( pos != std::string::npos ) {
10453                  expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
10454                                      registryKvp.second.tag +
10455                                      expandedTestSpec.substr( pos + registryKvp.first.size() );
10456              }
10457          }
10458          return expandedTestSpec;
10459      }
10460      void TagAliasRegistry::add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) {
10461          CATCH_ENFORCE( startsWith(alias, &quot;[@&quot;) &amp;&amp; endsWith(alias, &#x27;]&#x27;),
10462                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; is not of the form [@alias name].\n&quot; &lt;&lt; lineInfo );
10463          CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
10464                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; already registered.\n&quot;
10465                        &lt;&lt; &quot;\tFirst seen at: &quot; &lt;&lt; find(alias)-&gt;lineInfo &lt;&lt; &quot;\n&quot;
10466                        &lt;&lt; &quot;\tRedefined at: &quot; &lt;&lt; lineInfo );
10467      }
10468      ITagAliasRegistry::~ITagAliasRegistry() {}
10469      ITagAliasRegistry const&amp; ITagAliasRegistry::get() {
10470          return getRegistryHub().getTagAliasRegistry();
10471      }
10472  } 
10473  #include &lt;cctype&gt;
10474  #include &lt;exception&gt;
10475  #include &lt;algorithm&gt;
10476  #include &lt;sstream&gt;
10477  namespace Catch {
10478      namespace {
10479          TestCaseInfo::SpecialProperties parseSpecialTag( std::string const&amp; tag ) {
10480              if( startsWith( tag, &#x27;.&#x27; ) ||
10481                  tag == &quot;!hide&quot; )
10482                  return TestCaseInfo::IsHidden;
10483              else if( tag == &quot;!throws&quot; )
10484                  return TestCaseInfo::Throws;
10485              else if( tag == &quot;!shouldfail&quot; )
10486                  return TestCaseInfo::ShouldFail;
10487              else if( tag == &quot;!mayfail&quot; )
10488                  return TestCaseInfo::MayFail;
10489              else if( tag == &quot;!nonportable&quot; )
10490                  return TestCaseInfo::NonPortable;
10491              else if( tag == &quot;!benchmark&quot; )
10492                  return static_cast&lt;TestCaseInfo::SpecialProperties&gt;( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
10493              else
10494                  return TestCaseInfo::None;
10495          }
10496          bool isReservedTag( std::string const&amp; tag ) {
10497              return parseSpecialTag( tag ) == TestCaseInfo::None &amp;&amp; tag.size() &gt; 0 &amp;&amp; !std::isalnum( static_cast&lt;unsigned char&gt;(tag[0]) );
10498          }
10499          void enforceNotReservedTag( std::string const&amp; tag, SourceLineInfo const&amp; _lineInfo ) {
10500              CATCH_ENFORCE( !isReservedTag(tag),
10501                            &quot;Tag name: [&quot; &lt;&lt; tag &lt;&lt; &quot;] is not allowed.\n&quot;
10502                            &lt;&lt; &quot;Tag names starting with non alphanumeric characters are reserved\n&quot;
10503                            &lt;&lt; _lineInfo );
10504          }
10505      }
10506      TestCase makeTestCase(  ITestInvoker* _testCase,
10507                              std::string const&amp; _className,
10508                              NameAndTags const&amp; nameAndTags,
10509                              SourceLineInfo const&amp; _lineInfo )
10510      {
10511          bool isHidden = false;
10512          std::vector&lt;std::string&gt; tags;
10513          std::string desc, tag;
10514          bool inTag = false;
10515          for (char c : nameAndTags.tags) {
10516              if( !inTag ) {
10517                  if( c == &#x27;[&#x27; )
10518                      inTag = true;
10519                  else
10520                      desc += c;
10521              }
10522              else {
10523                  if( c == &#x27;]&#x27; ) {
10524                      TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
10525                      if( ( prop &amp; TestCaseInfo::IsHidden ) != 0 )
10526                          isHidden = true;
10527                      else if( prop == TestCaseInfo::None )
10528                          enforceNotReservedTag( tag, _lineInfo );
10529                      if (startsWith(tag, &#x27;.&#x27;) &amp;&amp; tag.size() &gt; 1) {
10530                          tag.erase(0, 1);
10531                      }
10532                      tags.push_back( tag );
10533                      tag.clear();
10534                      inTag = false;
10535                  }
10536                  else
10537                      tag += c;
10538              }
10539          }
10540          if( isHidden ) {
10541              tags.insert( tags.end(), { &quot;.&quot;, &quot;!hide&quot; } );
10542          }
10543          TestCaseInfo info( static_cast&lt;std::string&gt;(nameAndTags.name), _className, desc, tags, _lineInfo );
10544          return TestCase( _testCase, std::move(info) );
10545      }
10546      void setTags( TestCaseInfo&amp; testCaseInfo, std::vector&lt;std::string&gt; tags ) {
10547          std::sort(begin(tags), end(tags));
10548          tags.erase(std::unique(begin(tags), end(tags)), end(tags));
10549          testCaseInfo.lcaseTags.clear();
10550          for( auto const&amp; tag : tags ) {
10551              std::string lcaseTag = toLower( tag );
10552              testCaseInfo.properties = static_cast&lt;TestCaseInfo::SpecialProperties&gt;( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
10553              testCaseInfo.lcaseTags.push_back( lcaseTag );
10554          }
10555          testCaseInfo.tags = std::move(tags);
10556      }
10557      TestCaseInfo::TestCaseInfo( std::string const&amp; _name,
10558                                  std::string const&amp; _className,
10559                                  std::string const&amp; _description,
10560                                  std::vector&lt;std::string&gt; const&amp; _tags,
10561                                  SourceLineInfo const&amp; _lineInfo )
10562      :   name( _name ),
10563          className( _className ),
10564          description( _description ),
10565          lineInfo( _lineInfo ),
10566          properties( None )
10567      {
10568          setTags( *this, _tags );
10569      }
10570      bool TestCaseInfo::isHidden() const {
10571          return ( properties &amp; IsHidden ) != 0;
10572      }
10573      bool TestCaseInfo::throws() const {
10574          return ( properties &amp; Throws ) != 0;
10575      }
10576      bool TestCaseInfo::okToFail() const {
10577          return ( properties &amp; (ShouldFail | MayFail ) ) != 0;
10578      }
10579      bool TestCaseInfo::expectedToFail() const {
10580          return ( properties &amp; (ShouldFail ) ) != 0;
10581      }
10582      std::string TestCaseInfo::tagsAsString() const {
10583          std::string ret;
10584          std::size_t full_size = 2 * tags.size();
10585          for (const auto&amp; tag : tags) {
10586              full_size += tag.size();
10587          }
10588          ret.reserve(full_size);
10589          for (const auto&amp; tag : tags) {
10590              ret.push_back(&#x27;[&#x27;);
10591              ret.append(tag);
10592              ret.push_back(&#x27;]&#x27;);
10593          }
10594          return ret;
10595      }
10596      TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&amp;&amp; info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
10597      TestCase TestCase::withName( std::string const&amp; _newName ) const {
10598          TestCase other( *this );
10599          other.name = _newName;
10600          return other;
10601      }
10602      void TestCase::invoke() const {
10603          test-&gt;invoke();
10604      }
10605      bool TestCase::operator == ( TestCase const&amp; other ) const {
10606          return  test.get() == other.test.get() &amp;&amp;
10607                  name == other.name &amp;&amp;
10608                  className == other.className;
10609      }
10610      bool TestCase::operator &lt; ( TestCase const&amp; other ) const {
10611          return name &lt; other.name;
10612      }
10613      TestCaseInfo const&amp; TestCase::getTestCaseInfo() const
10614      {
10615          return *this;
10616      }
10617  } 
10618  #include &lt;algorithm&gt;
10619  #include &lt;sstream&gt;
10620  namespace Catch {
10621      namespace {
10622          struct TestHasher {
10623              using hash_t = uint64_t;
10624              explicit TestHasher( hash_t hashSuffix ):
10625                  m_hashSuffix{ hashSuffix } {}
10626              uint32_t operator()( TestCase const&amp; t ) const {
10627                  const hash_t prime = 1099511628211u;
10628                  hash_t hash = 14695981039346656037u;
10629                  for ( const char c : t.name ) {
10630                      hash ^= c;
10631                      hash *= prime;
10632                  }
10633                  hash ^= m_hashSuffix;
10634                  hash *= prime;
10635                  const uint32_t low{ static_cast&lt;uint32_t&gt;( hash ) };
10636                  const uint32_t high{ static_cast&lt;uint32_t&gt;( hash &gt;&gt; 32 ) };
10637                  return low * high;
10638              }
10639          private:
10640              hash_t m_hashSuffix;
10641          };
10642      } 
10643      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases ) {
10644          switch( config.runOrder() ) {
10645              case RunTests::InDeclarationOrder:
10646                  break;
10647              case RunTests::InLexicographicalOrder: {
10648                  std::vector&lt;TestCase&gt; sorted = unsortedTestCases;
10649                  std::sort( sorted.begin(), sorted.end() );
10650                  return sorted;
10651              }
10652              case RunTests::InRandomOrder: {
10653                  seedRng( config );
10654                  TestHasher h{ config.rngSeed() };
10655                  using hashedTest = std::pair&lt;TestHasher::hash_t, TestCase const*&gt;;
10656                  std::vector&lt;hashedTest&gt; indexed_tests;
10657                  indexed_tests.reserve( unsortedTestCases.size() );
10658                  for (auto const&amp; testCase : unsortedTestCases) {
10659                      indexed_tests.emplace_back(h(testCase), &amp;testCase);
10660                  }
10661                  std::sort(indexed_tests.begin(), indexed_tests.end(),
10662                            [](hashedTest const&amp; lhs, hashedTest const&amp; rhs) {
10663                            if (lhs.first == rhs.first) {
10664                                return lhs.second-&gt;name &lt; rhs.second-&gt;name;
10665                            }
10666                            return lhs.first &lt; rhs.first;
10667                  });
10668                  std::vector&lt;TestCase&gt; sorted;
10669                  sorted.reserve( indexed_tests.size() );
10670                  for (auto const&amp; hashed : indexed_tests) {
10671                      sorted.emplace_back(*hashed.second);
10672                  }
10673                  return sorted;
10674              }
10675          }
10676          return unsortedTestCases;
10677      }
10678      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config ) {
10679          return !testCase.throws() || config.allowThrows();
10680      }
10681      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10682          return testSpec.matches( testCase ) &amp;&amp; isThrowSafe( testCase, config );
10683      }
10684      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions ) {
10685          std::set&lt;TestCase&gt; seenFunctions;
10686          for( auto const&amp; function : functions ) {
10687              auto prev = seenFunctions.insert( function );
10688              CATCH_ENFORCE( prev.second,
10689                      &quot;error: TEST_CASE( \&quot;&quot; &lt;&lt; function.name &lt;&lt; &quot;\&quot; ) already defined.\n&quot;
10690                      &lt;&lt; &quot;\tFirst seen at &quot; &lt;&lt; prev.first-&gt;getTestCaseInfo().lineInfo &lt;&lt; &quot;\n&quot;
10691                      &lt;&lt; &quot;\tRedefined at &quot; &lt;&lt; function.getTestCaseInfo().lineInfo );
10692          }
10693      }
10694      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10695          std::vector&lt;TestCase&gt; filtered;
10696          filtered.reserve( testCases.size() );
10697          for (auto const&amp; testCase : testCases) {
10698              if ((!testSpec.hasFilters() &amp;&amp; !testCase.isHidden()) ||
10699                  (testSpec.hasFilters() &amp;&amp; matchTest(testCase, testSpec, config))) {
10700                  filtered.push_back(testCase);
10701              }
10702          }
10703          return filtered;
10704      }
10705      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config ) {
10706          return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
10707      }
10708      void TestRegistry::registerTest( TestCase const&amp; testCase ) {
10709          std::string name = testCase.getTestCaseInfo().name;
10710          if( name.empty() ) {
10711              ReusableStringStream rss;
10712              rss &lt;&lt; &quot;Anonymous test case &quot; &lt;&lt; ++m_unnamedCount;
10713              return registerTest( testCase.withName( rss.str() ) );
10714          }
10715          m_functions.push_back( testCase );
10716      }
10717      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTests() const {
10718          return m_functions;
10719      }
10720      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTestsSorted( IConfig const&amp; config ) const {
10721          if( m_sortedFunctions.empty() )
10722              enforceNoDuplicateTestCases( m_functions );
10723          if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
10724              m_sortedFunctions = sortTests( config, m_functions );
10725              m_currentSortOrder = config.runOrder();
10726          }
10727          return m_sortedFunctions;
10728      }
10729      TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
10730      void TestInvokerAsFunction::invoke() const {
10731          m_testAsFunction();
10732      }
10733      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName ) {
10734          std::string className(classOrQualifiedMethodName);
10735          if( startsWith( className, &#x27;&amp;&#x27; ) )
10736          {
10737              std::size_t lastColons = className.rfind( &quot;::&quot; );
10738              std::size_t penultimateColons = className.rfind( &quot;::&quot;, lastColons-1 );
10739              if( penultimateColons == std::string::npos )
10740                  penultimateColons = 1;
10741              className = className.substr( penultimateColons, lastColons-penultimateColons );
10742          }
10743          return className;
10744      }
10745  } 
10746  #include &lt;algorithm&gt;
10747  #include &lt;cassert&gt;
10748  #include &lt;stdexcept&gt;
10749  #include &lt;memory&gt;
10750  #include &lt;sstream&gt;
10751  #if defined(__clang__)
10752  #    pragma clang diagnostic push
10753  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
10754  #endif
10755  namespace Catch {
10756  namespace TestCaseTracking {
10757      NameAndLocation::NameAndLocation( std::string const&amp; _name, SourceLineInfo const&amp; _location )
10758      :   name( _name ),
10759          location( _location )
10760      {}
10761      ITracker::~ITracker() = default;
10762      ITracker&amp; TrackerContext::startRun() {
10763          m_rootTracker = std::make_shared&lt;SectionTracker&gt;( NameAndLocation( &quot;{root}&quot;, CATCH_INTERNAL_LINEINFO ), *this, nullptr );
10764          m_currentTracker = nullptr;
10765          m_runState = Executing;
10766          return *m_rootTracker;
10767      }
10768      void TrackerContext::endRun() {
10769          m_rootTracker.reset();
10770          m_currentTracker = nullptr;
10771          m_runState = NotStarted;
10772      }
10773      void TrackerContext::startCycle() {
10774          m_currentTracker = m_rootTracker.get();
10775          m_runState = Executing;
10776      }
10777      void TrackerContext::completeCycle() {
10778          m_runState = CompletedCycle;
10779      }
10780      bool TrackerContext::completedCycle() const {
10781          return m_runState == CompletedCycle;
10782      }
10783      ITracker&amp; TrackerContext::currentTracker() {
10784          return *m_currentTracker;
10785      }
10786      void TrackerContext::setCurrentTracker( ITracker* tracker ) {
10787          m_currentTracker = tracker;
10788      }
10789      TrackerBase::TrackerBase( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent ):
10790          ITracker(nameAndLocation),
10791          m_ctx( ctx ),
10792          m_parent( parent )
10793      {}
10794      bool TrackerBase::isComplete() const {
10795          return m_runState == CompletedSuccessfully || m_runState == Failed;
10796      }
10797      bool TrackerBase::isSuccessfullyCompleted() const {
10798          return m_runState == CompletedSuccessfully;
10799      }
10800      bool TrackerBase::isOpen() const {
10801          return m_runState != NotStarted &amp;&amp; !isComplete();
10802      }
10803      bool TrackerBase::hasChildren() const {
10804          return !m_children.empty();
10805      }
10806      void TrackerBase::addChild( ITrackerPtr const&amp; child ) {
10807          m_children.push_back( child );
10808      }
10809      ITrackerPtr TrackerBase::findChild( NameAndLocation const&amp; nameAndLocation ) {
10810          auto it = std::find_if( m_children.begin(), m_children.end(),
10811              [&amp;nameAndLocation]( ITrackerPtr const&amp; tracker ){
10812                  return
10813                      tracker-&gt;nameAndLocation().location == nameAndLocation.location &amp;&amp;
10814                      tracker-&gt;nameAndLocation().name == nameAndLocation.name;
10815              } );
10816          return( it != m_children.end() )
10817              ? *it
10818              : nullptr;
10819      }
10820      ITracker&amp; TrackerBase::parent() {
10821          assert( m_parent ); 
10822          return *m_parent;
10823      }
10824      void TrackerBase::openChild() {
10825          if( m_runState != ExecutingChildren ) {
10826              m_runState = ExecutingChildren;
10827              if( m_parent )
10828                  m_parent-&gt;openChild();
10829          }
10830      }
10831      bool TrackerBase::isSectionTracker() const { return false; }
10832      bool TrackerBase::isGeneratorTracker() const { return false; }
10833      void TrackerBase::open() {
10834          m_runState = Executing;
10835          moveToThis();
10836          if( m_parent )
10837              m_parent-&gt;openChild();
10838      }
10839      void TrackerBase::close() {
10840          while( &amp;m_ctx.currentTracker() != this )
10841              m_ctx.currentTracker().close();
10842          switch( m_runState ) {
10843              case NeedsAnotherRun:
10844                  break;
10845              case Executing:
10846                  m_runState = CompletedSuccessfully;
10847                  break;
10848              case ExecutingChildren:
10849                  if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const&amp; t){ return t-&gt;isComplete(); }) )
10850                      m_runState = CompletedSuccessfully;
10851                  break;
10852              case NotStarted:
10853              case CompletedSuccessfully:
10854              case Failed:
10855                  CATCH_INTERNAL_ERROR( &quot;Illogical state: &quot; &lt;&lt; m_runState );
10856              default:
10857                  CATCH_INTERNAL_ERROR( &quot;Unknown state: &quot; &lt;&lt; m_runState );
10858          }
10859          moveToParent();
10860          m_ctx.completeCycle();
10861      }
10862      void TrackerBase::fail() {
10863          m_runState = Failed;
10864          if( m_parent )
10865              m_parent-&gt;markAsNeedingAnotherRun();
10866          moveToParent();
10867          m_ctx.completeCycle();
10868      }
10869      void TrackerBase::markAsNeedingAnotherRun() {
10870          m_runState = NeedsAnotherRun;
10871      }
10872      void TrackerBase::moveToParent() {
10873          assert( m_parent );
10874          m_ctx.setCurrentTracker( m_parent );
10875      }
10876      void TrackerBase::moveToThis() {
10877          m_ctx.setCurrentTracker( this );
10878      }
10879      SectionTracker::SectionTracker( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
10880      :   TrackerBase( nameAndLocation, ctx, parent ),
10881          m_trimmed_name(trim(nameAndLocation.name))
10882      {
10883          if( parent ) {
10884              while( !parent-&gt;isSectionTracker() )
10885                  parent = &amp;parent-&gt;parent();
10886              SectionTracker&amp; parentSection = static_cast&lt;SectionTracker&amp;&gt;( *parent );
10887              addNextFilters( parentSection.m_filters );
10888          }
10889      }
10890      bool SectionTracker::isComplete() const {
10891          bool complete = true;
10892          if (m_filters.empty()
10893              || m_filters[0] == &quot;&quot;
10894              || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
10895              complete = TrackerBase::isComplete();
10896          }
10897          return complete;
10898      }
10899      bool SectionTracker::isSectionTracker() const { return true; }
10900      SectionTracker&amp; SectionTracker::acquire( TrackerContext&amp; ctx, NameAndLocation const&amp; nameAndLocation ) {
10901          std::shared_ptr&lt;SectionTracker&gt; section;
10902          ITracker&amp; currentTracker = ctx.currentTracker();
10903          if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
10904              assert( childTracker );
10905              assert( childTracker-&gt;isSectionTracker() );
10906              section = std::static_pointer_cast&lt;SectionTracker&gt;( childTracker );
10907          }
10908          else {
10909              section = std::make_shared&lt;SectionTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
10910              currentTracker.addChild( section );
10911          }
10912          if( !ctx.completedCycle() )
10913              section-&gt;tryOpen();
10914          return *section;
10915      }
10916      void SectionTracker::tryOpen() {
10917          if( !isComplete() )
10918              open();
10919      }
10920      void SectionTracker::addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10921          if( !filters.empty() ) {
10922              m_filters.reserve( m_filters.size() + filters.size() + 2 );
10923              m_filters.emplace_back(&quot;&quot;); 
10924              m_filters.emplace_back(&quot;&quot;); 
10925              m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
10926          }
10927      }
10928      void SectionTracker::addNextFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10929          if( filters.size() &gt; 1 )
10930              m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
10931      }
10932      std::vector&lt;std::string&gt; const&amp; SectionTracker::getFilters() const {
10933          return m_filters;
10934      }
10935      std::string const&amp; SectionTracker::trimmedName() const {
10936          return m_trimmed_name;
10937      }
10938  } 
10939  using TestCaseTracking::ITracker;
10940  using TestCaseTracking::TrackerContext;
10941  using TestCaseTracking::SectionTracker;
10942  } 
10943  #if defined(__clang__)
10944  #    pragma clang diagnostic pop
10945  #endif
10946  namespace Catch {
10947      auto makeTestInvoker( void(*testAsFunction)() ) noexcept -&gt; ITestInvoker* {
10948          return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
10949      }
10950      NameAndTags::NameAndTags( StringRef const&amp; name_ , StringRef const&amp; tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
10951      AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const&amp; lineInfo, StringRef const&amp; classOrMethod, NameAndTags const&amp; nameAndTags ) noexcept {
10952          CATCH_TRY {
10953              getMutableRegistryHub()
10954                      .registerTest(
10955                          makeTestCase(
10956                              invoker,
10957                              extractClassName( classOrMethod ),
10958                              nameAndTags,
10959                              lineInfo));
10960          } CATCH_CATCH_ALL {
10961              getMutableRegistryHub().registerStartupException();
10962          }
10963      }
10964      AutoReg::~AutoReg() = default;
10965  }
10966  #include &lt;algorithm&gt;
10967  #include &lt;string&gt;
10968  #include &lt;vector&gt;
10969  #include &lt;memory&gt;
10970  namespace Catch {
10971      TestSpec::Pattern::Pattern( std::string const&amp; name )
10972      : m_name( name )
10973      {}
10974      TestSpec::Pattern::~Pattern() = default;
10975      std::string const&amp; TestSpec::Pattern::name() const {
10976          return m_name;
10977      }
10978      TestSpec::NamePattern::NamePattern( std::string const&amp; name, std::string const&amp; filterString )
10979      : Pattern( filterString )
10980      , m_wildcardPattern( toLower( name ), CaseSensitive::No )
10981      {}
10982      bool TestSpec::NamePattern::matches( TestCaseInfo const&amp; testCase ) const {
10983          return m_wildcardPattern.matches( testCase.name );
10984      }
10985      TestSpec::TagPattern::TagPattern( std::string const&amp; tag, std::string const&amp; filterString )
10986      : Pattern( filterString )
10987      , m_tag( toLower( tag ) )
10988      {}
10989      bool TestSpec::TagPattern::matches( TestCaseInfo const&amp; testCase ) const {
10990          return std::find(begin(testCase.lcaseTags),
10991                           end(testCase.lcaseTags),
10992                           m_tag) != end(testCase.lcaseTags);
10993      }
10994      TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const&amp; underlyingPattern )
10995      : Pattern( underlyingPattern-&gt;name() )
10996      , m_underlyingPattern( underlyingPattern )
10997      {}
10998      bool TestSpec::ExcludedPattern::matches( TestCaseInfo const&amp; testCase ) const {
10999          return !m_underlyingPattern-&gt;matches( testCase );
11000      }
11001      bool TestSpec::Filter::matches( TestCaseInfo const&amp; testCase ) const {
11002          return std::all_of( m_patterns.begin(), m_patterns.end(), [&amp;]( PatternPtr const&amp; p ){ return p-&gt;matches( testCase ); } );
11003      }
11004      std::string TestSpec::Filter::name() const {
11005          std::string name;
11006          for( auto const&amp; p : m_patterns )
11007              name += p-&gt;name();
11008          return name;
11009      }
11010      bool TestSpec::hasFilters() const {
11011          return !m_filters.empty();
11012      }
11013      bool TestSpec::matches( TestCaseInfo const&amp; testCase ) const {
11014          return std::any_of( m_filters.begin(), m_filters.end(), [&amp;]( Filter const&amp; f ){ return f.matches( testCase ); } );
11015      }
11016      TestSpec::Matches TestSpec::matchesByFilter( std::vector&lt;TestCase&gt; const&amp; testCases, IConfig const&amp; config ) const
11017      {
11018          Matches matches( m_filters.size() );
11019          std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&amp;]( Filter const&amp; filter ){
11020              std::vector&lt;TestCase const*&gt; currentMatches;
11021              for( auto const&amp; test : testCases )
11022                  if( isThrowSafe( test, config ) &amp;&amp; filter.matches( test ) )
11023                      currentMatches.emplace_back( &amp;test );
11024              return FilterMatch{ filter.name(), currentMatches };
11025          } );
11026          return matches;
11027      }
11028      const TestSpec::vectorStrings&amp; TestSpec::getInvalidArgs() const{
11029          return  (m_invalidArgs);
11030      }
11031  }
11032  namespace Catch {
11033      TestSpecParser::TestSpecParser( ITagAliasRegistry const&amp; tagAliases ) : m_tagAliases( &amp;tagAliases ) {}
11034      TestSpecParser&amp; TestSpecParser::parse( std::string const&amp; arg ) {
11035          m_mode = None;
11036          m_exclusion = false;
11037          m_arg = m_tagAliases-&gt;expandAliases( arg );
11038          m_escapeChars.clear();
11039          m_substring.reserve(m_arg.size());
11040          m_patternName.reserve(m_arg.size());
11041          m_realPatternPos = 0;
11042          for( m_pos = 0; m_pos &lt; m_arg.size(); ++m_pos )
11043             if( !visitChar( m_arg[m_pos] ) ){
11044                 m_testSpec.m_invalidArgs.push_back(arg);
11045                 break;
11046             }
11047          endMode();
11048          return *this;
11049      }
11050      TestSpec TestSpecParser::testSpec() {
11051          addFilter();
11052          return m_testSpec;
11053      }
11054      bool TestSpecParser::visitChar( char c ) {
11055          if( (m_mode != EscapedName) &amp;&amp; (c == &#x27;\\&#x27;) ) {
11056              escape();
11057              addCharToPattern(c);
11058              return true;
11059          }else if((m_mode != EscapedName) &amp;&amp; (c == &#x27;,&#x27;) )  {
11060              return separate();
11061          }
11062          switch( m_mode ) {
11063          case None:
11064              if( processNoneChar( c ) )
11065                  return true;
11066              break;
11067          case Name:
11068              processNameChar( c );
11069              break;
11070          case EscapedName:
11071              endMode();
11072              addCharToPattern(c);
11073              return true;
11074          default:
11075          case Tag:
11076          case QuotedName:
11077              if( processOtherChar( c ) )
11078                  return true;
11079              break;
11080          }
11081          m_substring += c;
11082          if( !isControlChar( c ) ) {
11083              m_patternName += c;
11084              m_realPatternPos++;
11085          }
11086          return true;
11087      }
11088      bool TestSpecParser::processNoneChar( char c ) {
11089          switch( c ) {
11090          case &#x27; &#x27;:
11091              return true;
11092          case &#x27;~&#x27;:
11093              m_exclusion = true;
11094              return false;
11095          case &#x27;[&#x27;:
11096              startNewMode( Tag );
11097              return false;
11098          case &#x27;&quot;&#x27;:
11099              startNewMode( QuotedName );
11100              return false;
11101          default:
11102              startNewMode( Name );
11103              return false;
11104          }
11105      }
11106      void TestSpecParser::processNameChar( char c ) {
11107          if( c == &#x27;[&#x27; ) {
11108              if( m_substring == &quot;exclude:&quot; )
11109                  m_exclusion = true;
11110              else
11111                  endMode();
11112              startNewMode( Tag );
11113          }
11114      }
11115      bool TestSpecParser::processOtherChar( char c ) {
11116          if( !isControlChar( c ) )
11117              return false;
11118          m_substring += c;
11119          endMode();
11120          return true;
11121      }
11122      void TestSpecParser::startNewMode( Mode mode ) {
11123          m_mode = mode;
11124      }
11125      void TestSpecParser::endMode() {
11126          switch( m_mode ) {
11127          case Name:
11128          case QuotedName:
11129              return addNamePattern();
11130          case Tag:
11131              return addTagPattern();
11132          case EscapedName:
11133              revertBackToLastMode();
11134              return;
11135          case None:
11136          default:
11137              return startNewMode( None );
11138          }
11139      }
11140      void TestSpecParser::escape() {
11141          saveLastMode();
11142          m_mode = EscapedName;
11143          m_escapeChars.push_back(m_realPatternPos);
11144      }
11145      bool TestSpecParser::isControlChar( char c ) const {
11146          switch( m_mode ) {
11147              default:
11148                  return false;
11149              case None:
11150                  return c == &#x27;~&#x27;;
11151              case Name:
11152                  return c == &#x27;[&#x27;;
11153              case EscapedName:
11154                  return true;
11155              case QuotedName:
11156                  return c == &#x27;&quot;&#x27;;
11157              case Tag:
11158                  return c == &#x27;[&#x27; || c == &#x27;]&#x27;;
11159          }
11160      }
11161      void TestSpecParser::addFilter() {
11162          if( !m_currentFilter.m_patterns.empty() ) {
11163              m_testSpec.m_filters.push_back( m_currentFilter );
11164              m_currentFilter = TestSpec::Filter();
11165          }
11166      }
11167      void TestSpecParser::saveLastMode() {
11168        lastMode = m_mode;
11169      }
11170      void TestSpecParser::revertBackToLastMode() {
11171        m_mode = lastMode;
11172      }
11173      bool TestSpecParser::separate() {
11174        if( (m_mode==QuotedName) || (m_mode==Tag) ){
11175           m_mode = None;
11176           m_pos = m_arg.size();
11177           m_substring.clear();
11178           m_patternName.clear();
11179           m_realPatternPos = 0;
11180           return false;
11181        }
11182        endMode();
11183        addFilter();
11184        return true; 
11185      }
11186      std::string TestSpecParser::preprocessPattern() {
11187          std::string token = m_patternName;
11188          for (std::size_t i = 0; i &lt; m_escapeChars.size(); ++i)
11189              token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
11190          m_escapeChars.clear();
11191          if (startsWith(token, &quot;exclude:&quot;)) {
11192              m_exclusion = true;
11193              token = token.substr(8);
11194          }
11195          m_patternName.clear();
11196          m_realPatternPos = 0;
11197          return token;
11198      }
11199      void TestSpecParser::addNamePattern() {
11200          auto token = preprocessPattern();
11201          if (!token.empty()) {
11202              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::NamePattern&gt;(token, m_substring);
11203              if (m_exclusion)
11204                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11205              m_currentFilter.m_patterns.push_back(pattern);
11206          }
11207          m_substring.clear();
11208          m_exclusion = false;
11209          m_mode = None;
11210      }
11211      void TestSpecParser::addTagPattern() {
11212          auto token = preprocessPattern();
11213          if (!token.empty()) {
11214              if (token.size() &gt; 1 &amp;&amp; token[0] == &#x27;.&#x27;) {
11215                  token.erase(token.begin());
11216                  TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(&quot;.&quot;, m_substring);
11217                  if (m_exclusion) {
11218                      pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11219                  }
11220                  m_currentFilter.m_patterns.push_back(pattern);
11221              }
11222              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(token, m_substring);
11223              if (m_exclusion) {
11224                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11225              }
11226              m_currentFilter.m_patterns.push_back(pattern);
11227          }
11228          m_substring.clear();
11229          m_exclusion = false;
11230          m_mode = None;
11231      }
11232      TestSpec parseTestSpec( std::string const&amp; arg ) {
11233          return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
11234      }
11235  } 
11236  #include &lt;chrono&gt;
11237  static const uint64_t nanosecondsInSecond = 1000000000;
11238  namespace Catch {
11239      auto getCurrentNanosecondsSinceEpoch() -&gt; uint64_t {
11240          return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
11241      }
11242      namespace {
11243          auto estimateClockResolution() -&gt; uint64_t {
11244              uint64_t sum = 0;
11245              static const uint64_t iterations = 1000000;
11246              auto startTime = getCurrentNanosecondsSinceEpoch();
11247              for( std::size_t i = 0; i &lt; iterations; ++i ) {
11248                  uint64_t ticks;
11249                  uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
11250                  do {
11251                      ticks = getCurrentNanosecondsSinceEpoch();
11252                  } while( ticks == baseTicks );
11253                  auto delta = ticks - baseTicks;
11254                  sum += delta;
11255                  if (ticks &gt; startTime + 3 * nanosecondsInSecond) {
11256                      return sum / ( i + 1u );
11257                  }
11258              }
11259              return sum/iterations;
11260          }
11261      }
11262      auto getEstimatedClockResolution() -&gt; uint64_t {
11263          static auto s_resolution = estimateClockResolution();
11264          return s_resolution;
11265      }
11266      void Timer::start() {
11267         m_nanoseconds = getCurrentNanosecondsSinceEpoch();
11268      }
11269      auto Timer::getElapsedNanoseconds() const -&gt; uint64_t {
11270          return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
11271      }
11272      auto Timer::getElapsedMicroseconds() const -&gt; uint64_t {
11273          return getElapsedNanoseconds()/1000;
11274      }
11275      auto Timer::getElapsedMilliseconds() const -&gt; unsigned int {
11276          return static_cast&lt;unsigned int&gt;(getElapsedMicroseconds()/1000);
11277      }
11278      auto Timer::getElapsedSeconds() const -&gt; double {
11279          return getElapsedMicroseconds()/1000000.0;
11280      }
11281  } 
11282  #if defined(__clang__)
11283  #    pragma clang diagnostic push
11284  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
11285  #    pragma clang diagnostic ignored &quot;-Wglobal-constructors&quot;
11286  #endif
11287  #if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
11288  #define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
11289  #endif
11290  #include &lt;cmath&gt;
11291  #include &lt;iomanip&gt;
11292  namespace Catch {
11293  namespace Detail {
11294      const std::string unprintableString = &quot;{?}&quot;;
11295      namespace {
11296          const int hexThreshold = 255;
11297          struct Endianness {
11298              enum Arch { Big, Little };
11299              static Arch which() {
11300                  int one = 1;
11301                  auto value = *reinterpret_cast&lt;char*&gt;(&amp;one);
11302                  return value ? Little : Big;
11303              }
11304          };
11305      }
11306      std::string rawMemoryToString( const void *object, std::size_t size ) {
11307          int i = 0, end = static_cast&lt;int&gt;( size ), inc = 1;
11308          if( Endianness::which() == Endianness::Little ) {
11309              i = end-1;
11310              end = inc = -1;
11311          }
11312          unsigned char const *bytes = static_cast&lt;unsigned char const *&gt;(object);
11313          ReusableStringStream rss;
11314          rss &lt;&lt; &quot;0x&quot; &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::hex;
11315          for( ; i != end; i += inc )
11316               rss &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(bytes[i]);
11317         return rss.str();
11318      }
11319  }
11320  template&lt;typename T&gt;
11321  std::string fpToString( T value, int precision ) {
11322      if (Catch::isnan(value)) {
11323          return &quot;nan&quot;;
11324      }
11325      ReusableStringStream rss;
11326      rss &lt;&lt; std::setprecision( precision )
11327          &lt;&lt; std::fixed
11328          &lt;&lt; value;
11329      std::string d = rss.str();
11330      std::size_t i = d.find_last_not_of( &#x27;0&#x27; );
11331      if( i != std::string::npos &amp;&amp; i != d.size()-1 ) {
11332          if( d[i] == &#x27;.&#x27; )
11333              i++;
11334          d = d.substr( 0, i+1 );
11335      }
11336      return d;
11337  }
11338  std::string StringMaker&lt;std::string&gt;::convert(const std::string&amp; str) {
11339      if (!getCurrentContext().getConfig()-&gt;showInvisibles()) {
11340          return &#x27;&quot;&#x27; + str + &#x27;&quot;&#x27;;
11341      }
11342      std::string s(&quot;\&quot;&quot;);
11343      for (char c : str) {
11344          switch (c) {
11345          case &#x27;\n&#x27;:
11346              s.append(&quot;\\n&quot;);
11347              break;
11348          case &#x27;\t&#x27;:
11349              s.append(&quot;\\t&quot;);
11350              break;
11351          default:
11352              s.push_back(c);
11353              break;
11354          }
11355      }
11356      s.append(&quot;\&quot;&quot;);
11357      return s;
11358  }
11359  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11360  std::string StringMaker&lt;std::string_view&gt;::convert(std::string_view str) {
11361      return ::Catch::Detail::stringify(std::string{ str });
11362  }
11363  #endif
11364  std::string StringMaker&lt;char const*&gt;::convert(char const* str) {
11365      if (str) {
11366          return ::Catch::Detail::stringify(std::string{ str });
11367      } else {
11368          return{ &quot;{null string}&quot; };
11369      }
11370  }
11371  std::string StringMaker&lt;char*&gt;::convert(char* str) {
11372      if (str) {
11373          return ::Catch::Detail::stringify(std::string{ str });
11374      } else {
11375          return{ &quot;{null string}&quot; };
11376      }
11377  }
11378  #ifdef CATCH_CONFIG_WCHAR
11379  std::string StringMaker&lt;std::wstring&gt;::convert(const std::wstring&amp; wstr) {
11380      std::string s;
11381      s.reserve(wstr.size());
11382      for (auto c : wstr) {
11383          s += (c &lt;= 0xff) ? static_cast&lt;char&gt;(c) : &#x27;?&#x27;;
11384      }
11385      return ::Catch::Detail::stringify(s);
11386  }
11387  # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11388  std::string StringMaker&lt;std::wstring_view&gt;::convert(std::wstring_view str) {
11389      return StringMaker&lt;std::wstring&gt;::convert(std::wstring(str));
11390  }
11391  # endif
11392  std::string StringMaker&lt;wchar_t const*&gt;::convert(wchar_t const * str) {
11393      if (str) {
11394          return ::Catch::Detail::stringify(std::wstring{ str });
11395      } else {
11396          return{ &quot;{null string}&quot; };
11397      }
11398  }
11399  std::string StringMaker&lt;wchar_t *&gt;::convert(wchar_t * str) {
11400      if (str) {
11401          return ::Catch::Detail::stringify(std::wstring{ str });
11402      } else {
11403          return{ &quot;{null string}&quot; };
11404      }
11405  }
11406  #endif
11407  #if defined(CATCH_CONFIG_CPP17_BYTE)
11408  #include &lt;cstddef&gt;
11409  std::string StringMaker&lt;std::byte&gt;::convert(std::byte value) {
11410      return ::Catch::Detail::stringify(std::to_integer&lt;unsigned long long&gt;(value));
11411  }
11412  #endif 
11413  std::string StringMaker&lt;int&gt;::convert(int value) {
11414      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11415  }
11416  std::string StringMaker&lt;long&gt;::convert(long value) {
11417      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11418  }
11419  std::string StringMaker&lt;long long&gt;::convert(long long value) {
11420      ReusableStringStream rss;
11421      rss &lt;&lt; value;
11422      if (value &gt; Detail::hexThreshold) {
11423          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11424      }
11425      return rss.str();
11426  }
11427  std::string StringMaker&lt;unsigned int&gt;::convert(unsigned int value) {
11428      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11429  }
11430  std::string StringMaker&lt;unsigned long&gt;::convert(unsigned long value) {
11431      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11432  }
11433  std::string StringMaker&lt;unsigned long long&gt;::convert(unsigned long long value) {
11434      ReusableStringStream rss;
11435      rss &lt;&lt; value;
11436      if (value &gt; Detail::hexThreshold) {
11437          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11438      }
11439      return rss.str();
11440  }
11441  std::string StringMaker&lt;bool&gt;::convert(bool b) {
11442      return b ? &quot;true&quot; : &quot;false&quot;;
11443  }
11444  std::string StringMaker&lt;signed char&gt;::convert(signed char value) {
11445      if (value == &#x27;\r&#x27;) {
11446          return &quot;&#x27;\\r&#x27;&quot;;
11447      } else if (value == &#x27;\f&#x27;) {
11448          return &quot;&#x27;\\f&#x27;&quot;;
11449      } else if (value == &#x27;\n&#x27;) {
11450          return &quot;&#x27;\\n&#x27;&quot;;
11451      } else if (value == &#x27;\t&#x27;) {
11452          return &quot;&#x27;\\t&#x27;&quot;;
11453      } else if (&#x27;\0&#x27; &lt;= value &amp;&amp; value &lt; &#x27; &#x27;) {
11454          return ::Catch::Detail::stringify(static_cast&lt;unsigned int&gt;(value));
11455      } else {
11456          char chstr[] = &quot;&#x27; &#x27;&quot;;
11457          chstr[1] = value;
11458          return chstr;
11459      }
11460  }
11461  std::string StringMaker&lt;char&gt;::convert(char c) {
11462      return ::Catch::Detail::stringify(static_cast&lt;signed char&gt;(c));
11463  }
11464  std::string StringMaker&lt;unsigned char&gt;::convert(unsigned char c) {
11465      return ::Catch::Detail::stringify(static_cast&lt;char&gt;(c));
11466  }
11467  std::string StringMaker&lt;std::nullptr_t&gt;::convert(std::nullptr_t) {
11468      return &quot;nullptr&quot;;
11469  }
11470  int StringMaker&lt;float&gt;::precision = 5;
11471  std::string StringMaker&lt;float&gt;::convert(float value) {
11472      return fpToString(value, precision) + &#x27;f&#x27;;
11473  }
11474  int StringMaker&lt;double&gt;::precision = 10;
11475  std::string StringMaker&lt;double&gt;::convert(double value) {
11476      return fpToString(value, precision);
11477  }
11478  std::string ratio_string&lt;std::atto&gt;::symbol() { return &quot;a&quot;; }
11479  std::string ratio_string&lt;std::femto&gt;::symbol() { return &quot;f&quot;; }
11480  std::string ratio_string&lt;std::pico&gt;::symbol() { return &quot;p&quot;; }
11481  std::string ratio_string&lt;std::nano&gt;::symbol() { return &quot;n&quot;; }
11482  std::string ratio_string&lt;std::micro&gt;::symbol() { return &quot;u&quot;; }
11483  std::string ratio_string&lt;std::milli&gt;::symbol() { return &quot;m&quot;; }
11484  } 
11485  #if defined(__clang__)
11486  #    pragma clang diagnostic pop
11487  #endif
11488  namespace Catch {
11489      Counts Counts::operator - ( Counts const&amp; other ) const {
11490          Counts diff;
11491          diff.passed = passed - other.passed;
11492          diff.failed = failed - other.failed;
11493          diff.failedButOk = failedButOk - other.failedButOk;
11494          return diff;
11495      }
11496      Counts&amp; Counts::operator += ( Counts const&amp; other ) {
11497          passed += other.passed;
11498          failed += other.failed;
11499          failedButOk += other.failedButOk;
11500          return *this;
11501      }
11502      std::size_t Counts::total() const {
11503          return passed + failed + failedButOk;
11504      }
11505      bool Counts::allPassed() const {
11506          return failed == 0 &amp;&amp; failedButOk == 0;
11507      }
11508      bool Counts::allOk() const {
11509          return failed == 0;
11510      }
11511      Totals Totals::operator - ( Totals const&amp; other ) const {
11512          Totals diff;
11513          diff.assertions = assertions - other.assertions;
11514          diff.testCases = testCases - other.testCases;
11515          return diff;
11516      }
11517      Totals&amp; Totals::operator += ( Totals const&amp; other ) {
11518          assertions += other.assertions;
11519          testCases += other.testCases;
11520          return *this;
11521      }
11522      Totals Totals::delta( Totals const&amp; prevTotals ) const {
11523          Totals diff = *this - prevTotals;
11524          if( diff.assertions.failed &gt; 0 )
11525              ++diff.testCases.failed;
11526          else if( diff.assertions.failedButOk &gt; 0 )
11527              ++diff.testCases.failedButOk;
11528          else
11529              ++diff.testCases.passed;
11530          return diff;
11531      }
11532  }
11533  #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11534  #define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11535  #if defined(_MSC_VER)
11536  #  if _MSC_VER &gt;= 1900 
11537  #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11538  #  endif
11539  #endif
11540  #include &lt;exception&gt;
11541  #if defined(__cpp_lib_uncaught_exceptions) \
11542      &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11543  #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11544  #endif 
11545  #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \
11546      &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \
11547      &amp;&amp; !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11548  #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11549  #endif
11550  #endif 
11551  #include &lt;exception&gt;
11552  namespace Catch {
11553      bool uncaught_exceptions() {
11554  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
11555          return false;
11556  #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11557          return std::uncaught_exceptions() &gt; 0;
11558  #else
11559          return std::uncaught_exception();
11560  #endif
11561    }
11562  } 
11563  #include &lt;ostream&gt;
11564  namespace Catch {
11565      Version::Version
11566          (   unsigned int _majorVersion,
11567              unsigned int _minorVersion,
11568              unsigned int _patchNumber,
11569              char const * const _branchName,
11570              unsigned int _buildNumber )
11571      :   majorVersion( _majorVersion ),
11572          minorVersion( _minorVersion ),
11573          patchNumber( _patchNumber ),
11574          branchName( _branchName ),
11575          buildNumber( _buildNumber )
11576      {}
11577      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version ) {
11578          os  &lt;&lt; version.majorVersion &lt;&lt; &#x27;.&#x27;
11579              &lt;&lt; version.minorVersion &lt;&lt; &#x27;.&#x27;
11580              &lt;&lt; version.patchNumber;
11581          if (version.branchName[0]) {
11582              os &lt;&lt; &#x27;-&#x27; &lt;&lt; version.branchName
11583                 &lt;&lt; &#x27;.&#x27; &lt;&lt; version.buildNumber;
11584          }
11585          return os;
11586      }
11587      Version const&amp; libraryVersion() {
11588          static Version version( 2, 13, 7, &quot;&quot;, 0 );
11589          return version;
11590      }
11591  }
11592  namespace Catch {
11593      WildcardPattern::WildcardPattern( std::string const&amp; pattern,
11594                                        CaseSensitive::Choice caseSensitivity )
11595      :   m_caseSensitivity( caseSensitivity ),
11596          m_pattern( normaliseString( pattern ) )
11597      {
11598          if( startsWith( m_pattern, &#x27;*&#x27; ) ) {
11599              m_pattern = m_pattern.substr( 1 );
11600              m_wildcard = WildcardAtStart;
11601          }
11602          if( endsWith( m_pattern, &#x27;*&#x27; ) ) {
11603              m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
11604              m_wildcard = static_cast&lt;WildcardPosition&gt;( m_wildcard | WildcardAtEnd );
11605          }
11606      }
11607      bool WildcardPattern::matches( std::string const&amp; str ) const {
11608          switch( m_wildcard ) {
11609              case NoWildcard:
11610                  return m_pattern == normaliseString( str );
11611              case WildcardAtStart:
11612                  return endsWith( normaliseString( str ), m_pattern );
11613              case WildcardAtEnd:
11614                  return startsWith( normaliseString( str ), m_pattern );
11615              case WildcardAtBothEnds:
11616                  return contains( normaliseString( str ), m_pattern );
11617              default:
11618                  CATCH_INTERNAL_ERROR( &quot;Unknown enum&quot; );
11619          }
11620      }
11621      std::string WildcardPattern::normaliseString( std::string const&amp; str ) const {
11622          return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
11623      }
11624  }
11625  #include &lt;iomanip&gt;
11626  #include &lt;type_traits&gt;
11627  namespace Catch {
11628  namespace {
11629      size_t trailingBytes(unsigned char c) {
11630          if ((c &amp; 0xE0) == 0xC0) {
11631              return 2;
11632          }
11633          if ((c &amp; 0xF0) == 0xE0) {
11634              return 3;
11635          }
11636          if ((c &amp; 0xF8) == 0xF0) {
11637              return 4;
11638          }
11639          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11640      }
11641      uint32_t headerValue(unsigned char c) {
11642          if ((c &amp; 0xE0) == 0xC0) {
11643              return c &amp; 0x1F;
11644          }
11645          if ((c &amp; 0xF0) == 0xE0) {
11646              return c &amp; 0x0F;
11647          }
11648          if ((c &amp; 0xF8) == 0xF0) {
11649              return c &amp; 0x07;
11650          }
11651          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11652      }
11653      void hexEscapeChar(std::ostream&amp; os, unsigned char c) {
11654          std::ios_base::fmtflags f(os.flags());
11655          os &lt;&lt; &quot;\\x&quot;
11656              &lt;&lt; std::uppercase &lt;&lt; std::hex &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(2)
11657              &lt;&lt; static_cast&lt;int&gt;(c);
11658          os.flags(f);
11659      }
11660      bool shouldNewline(XmlFormatting fmt) {
11661          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Newline));
11662      }
11663      bool shouldIndent(XmlFormatting fmt) {
11664          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Indent));
11665      }
11666  } 
11667      XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
11668          return static_cast&lt;XmlFormatting&gt;(
11669              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) |
11670              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11671          );
11672      }
11673      XmlFormatting operator &amp; (XmlFormatting lhs, XmlFormatting rhs) {
11674          return static_cast&lt;XmlFormatting&gt;(
11675              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) &amp;
11676              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11677          );
11678      }
11679      XmlEncode::XmlEncode( std::string const&amp; str, ForWhat forWhat )
11680      :   m_str( str ),
11681          m_forWhat( forWhat )
11682      {}
11683      void XmlEncode::encodeTo( std::ostream&amp; os ) const {
11684          for( std::size_t idx = 0; idx &lt; m_str.size(); ++ idx ) {
11685              unsigned char c = m_str[idx];
11686              switch (c) {
11687              case &#x27;&lt;&#x27;:   os &lt;&lt; &quot;&amp;lt;&quot;; break;
11688              case &#x27;&amp;&#x27;:   os &lt;&lt; &quot;&amp;amp;&quot;; break;
11689              case &#x27;&gt;&#x27;:
11690                  if (idx &gt; 2 &amp;&amp; m_str[idx - 1] == &#x27;]&#x27; &amp;&amp; m_str[idx - 2] == &#x27;]&#x27;)
11691                      os &lt;&lt; &quot;&amp;gt;&quot;;
11692                  else
11693                      os &lt;&lt; c;
11694                  break;
11695              case &#x27;\&quot;&#x27;:
11696                  if (m_forWhat == ForAttributes)
11697                      os &lt;&lt; &quot;&amp;quot;&quot;;
11698                  else
11699                      os &lt;&lt; c;
11700                  break;
11701              default:
11702                  if (c &lt; 0x09 || (c &gt; 0x0D &amp;&amp; c &lt; 0x20) || c == 0x7F) {
11703                      hexEscapeChar(os, c);
11704                      break;
11705                  }
11706                  if (c &lt; 0x7F) {
11707                      os &lt;&lt; c;
11708                      break;
11709                  }
11710                  if (c &lt;  0xC0 ||
11711                      c &gt;= 0xF8) {
11712                      hexEscapeChar(os, c);
11713                      break;
11714                  }
11715                  auto encBytes = trailingBytes(c);
11716                  if (idx + encBytes - 1 &gt;= m_str.size()) {
11717                      hexEscapeChar(os, c);
11718                      break;
11719                  }
11720                  bool valid = true;
11721                  uint32_t value = headerValue(c);
11722                  for (std::size_t n = 1; n &lt; encBytes; ++n) {
11723                      unsigned char nc = m_str[idx + n];
11724                      valid &amp;= ((nc &amp; 0xC0) == 0x80);
11725                      value = (value &lt;&lt; 6) | (nc &amp; 0x3F);
11726                  }
11727                  if (
11728                      (!valid) ||
11729                      (value &lt; 0x80) ||
11730                      (0x80 &lt;= value &amp;&amp; value &lt; 0x800   &amp;&amp; encBytes &gt; 2) ||
11731                      (0x800 &lt; value &amp;&amp; value &lt; 0x10000 &amp;&amp; encBytes &gt; 3) ||
11732                      (value &gt;= 0x110000)
11733                      ) {
11734                      hexEscapeChar(os, c);
11735                      break;
11736                  }
11737                  for (std::size_t n = 0; n &lt; encBytes; ++n) {
11738                      os &lt;&lt; m_str[idx + n];
11739                  }
11740                  idx += encBytes - 1;
11741                  break;
11742              }
11743          }
11744      }
11745      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode ) {
11746          xmlEncode.encodeTo( os );
11747          return os;
11748      }
11749      XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
11750      :   m_writer( writer ),
11751          m_fmt(fmt)
11752      {}
11753      XmlWriter::ScopedElement::ScopedElement( ScopedElement&amp;&amp; other ) noexcept
11754      :   m_writer( other.m_writer ),
11755          m_fmt(other.m_fmt)
11756      {
11757          other.m_writer = nullptr;
11758          other.m_fmt = XmlFormatting::None;
11759      }
11760      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::operator=( ScopedElement&amp;&amp; other ) noexcept {
11761          if ( m_writer ) {
11762              m_writer-&gt;endElement();
11763          }
11764          m_writer = other.m_writer;
11765          other.m_writer = nullptr;
11766          m_fmt = other.m_fmt;
11767          other.m_fmt = XmlFormatting::None;
11768          return *this;
11769      }
11770      XmlWriter::ScopedElement::~ScopedElement() {
11771          if (m_writer) {
11772              m_writer-&gt;endElement(m_fmt);
11773          }
11774      }
11775      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::writeText( std::string const&amp; text, XmlFormatting fmt ) {
11776          m_writer-&gt;writeText( text, fmt );
11777          return *this;
11778      }
11779      XmlWriter::XmlWriter( std::ostream&amp; os ) : m_os( os )
11780      {
11781          writeDeclaration();
11782      }
11783      XmlWriter::~XmlWriter() {
11784          while (!m_tags.empty()) {
11785              endElement();
11786          }
11787          newlineIfNecessary();
11788      }
11789      XmlWriter&amp; XmlWriter::startElement( std::string const&amp; name, XmlFormatting fmt ) {
11790          ensureTagClosed();
11791          newlineIfNecessary();
11792          if (shouldIndent(fmt)) {
11793              m_os &lt;&lt; m_indent;
11794              m_indent += &quot;  &quot;;
11795          }
11796          m_os &lt;&lt; &#x27;&lt;&#x27; &lt;&lt; name;
11797          m_tags.push_back( name );
11798          m_tagIsOpen = true;
11799          applyFormatting(fmt);
11800          return *this;
11801      }
11802      XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const&amp; name, XmlFormatting fmt ) {
11803          ScopedElement scoped( this, fmt );
11804          startElement( name, fmt );
11805          return scoped;
11806      }
11807      XmlWriter&amp; XmlWriter::endElement(XmlFormatting fmt) {
11808          m_indent = m_indent.substr(0, m_indent.size() - 2);
11809          if( m_tagIsOpen ) {
11810              m_os &lt;&lt; &quot;/&gt;&quot;;
11811              m_tagIsOpen = false;
11812          } else {
11813              newlineIfNecessary();
11814              if (shouldIndent(fmt)) {
11815                  m_os &lt;&lt; m_indent;
11816              }
11817              m_os &lt;&lt; &quot;&lt;/&quot; &lt;&lt; m_tags.back() &lt;&lt; &quot;&gt;&quot;;
11818          }
11819          m_os &lt;&lt; std::flush;
11820          applyFormatting(fmt);
11821          m_tags.pop_back();
11822          return *this;
11823      }
11824      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, std::string const&amp; attribute ) {
11825          if( !name.empty() &amp;&amp; !attribute.empty() )
11826              m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; XmlEncode( attribute, XmlEncode::ForAttributes ) &lt;&lt; &#x27;&quot;&#x27;;
11827          return *this;
11828      }
11829      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, bool attribute ) {
11830          m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; ( attribute ? &quot;true&quot; : &quot;false&quot; ) &lt;&lt; &#x27;&quot;&#x27;;
11831          return *this;
11832      }
11833      XmlWriter&amp; XmlWriter::writeText( std::string const&amp; text, XmlFormatting fmt) {
11834          if( !text.empty() ){
11835              bool tagWasOpen = m_tagIsOpen;
11836              ensureTagClosed();
11837              if (tagWasOpen &amp;&amp; shouldIndent(fmt)) {
11838                  m_os &lt;&lt; m_indent;
11839              }
11840              m_os &lt;&lt; XmlEncode( text );
11841              applyFormatting(fmt);
11842          }
11843          return *this;
11844      }
11845      XmlWriter&amp; XmlWriter::writeComment( std::string const&amp; text, XmlFormatting fmt) {
11846          ensureTagClosed();
11847          if (shouldIndent(fmt)) {
11848              m_os &lt;&lt; m_indent;
11849          }
11850          m_os &lt;&lt; &quot;&lt;!--&quot; &lt;&lt; text &lt;&lt; &quot;--&gt;&quot;;
11851          applyFormatting(fmt);
11852          return *this;
11853      }
11854      void XmlWriter::writeStylesheetRef( std::string const&amp; url ) {
11855          m_os &lt;&lt; &quot;&lt;?xml-stylesheet type=\&quot;text/xsl\&quot; href=\&quot;&quot; &lt;&lt; url &lt;&lt; &quot;\&quot;?&gt;\n&quot;;
11856      }
11857      XmlWriter&amp; XmlWriter::writeBlankLine() {
11858          ensureTagClosed();
11859          m_os &lt;&lt; &#x27;\n&#x27;;
11860          return *this;
11861      }
11862      void XmlWriter::ensureTagClosed() {
11863          if( m_tagIsOpen ) {
11864              m_os &lt;&lt; &#x27;&gt;&#x27; &lt;&lt; std::flush;
11865              newlineIfNecessary();
11866              m_tagIsOpen = false;
11867          }
11868      }
11869      void XmlWriter::applyFormatting(XmlFormatting fmt) {
11870          m_needsNewline = shouldNewline(fmt);
11871      }
11872      void XmlWriter::writeDeclaration() {
11873          m_os &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;
11874      }
11875      void XmlWriter::newlineIfNecessary() {
11876          if( m_needsNewline ) {
11877              m_os &lt;&lt; std::endl;
11878              m_needsNewline = false;
11879          }
11880      }
11881  }
11882  #include &lt;cstring&gt;
11883  #include &lt;cfloat&gt;
11884  #include &lt;cstdio&gt;
11885  #include &lt;cassert&gt;
11886  #include &lt;memory&gt;
11887  namespace Catch {
11888      void prepareExpandedExpression(AssertionResult&amp; result) {
11889          result.getExpandedExpression();
11890      }
11891      std::string getFormattedDuration( double duration ) {
11892          const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
11893          char buffer[maxDoubleSize];
11894          ErrnoGuard guard;
11895  #ifdef _MSC_VER
11896          sprintf_s(buffer, &quot;%.3f&quot;, duration);
11897  #else
11898          std::sprintf(buffer, &quot;%.3f&quot;, duration);
11899  #endif
11900          return std::string(buffer);
11901      }
11902      bool shouldShowDuration( IConfig const&amp; config, double duration ) {
11903          if ( config.showDurations() == ShowDurations::Always ) {
11904              return true;
11905          }
11906          if ( config.showDurations() == ShowDurations::Never ) {
11907              return false;
11908          }
11909          const double min = config.minDuration();
11910          return min &gt;= 0 &amp;&amp; duration &gt;= min;
11911      }
11912      std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; container ) {
11913          ReusableStringStream oss;
11914          bool first = true;
11915          for (auto&amp;&amp; filter : container)
11916          {
11917              if (!first)
11918                  oss &lt;&lt; &#x27; &#x27;;
11919              else
11920                  first = false;
11921              oss &lt;&lt; filter;
11922          }
11923          return oss.str();
11924      }
11925      TestEventListenerBase::TestEventListenerBase(ReporterConfig const &amp; _config)
11926          :StreamingReporterBase(_config) {}
11927      std::set&lt;Verbosity&gt; TestEventListenerBase::getSupportedVerbosities() {
11928          return { Verbosity::Quiet, Verbosity::Normal, Verbosity::High };
11929      }
11930      void TestEventListenerBase::assertionStarting(AssertionInfo const &amp;) {}
11931      bool TestEventListenerBase::assertionEnded(AssertionStats const &amp;) {
11932          return false;
11933      }
11934  } 
11935  namespace {
11936  #ifdef CATCH_PLATFORM_MAC
11937      const char* failedString() { return &quot;FAILED&quot;; }
11938      const char* passedString() { return &quot;PASSED&quot;; }
11939  #else
11940      const char* failedString() { return &quot;failed&quot;; }
11941      const char* passedString() { return &quot;passed&quot;; }
11942  #endif
11943      Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
11944      std::string bothOrAll( std::size_t count ) {
11945          return count == 1 ? std::string() :
11946                 count == 2 ? &quot;both &quot; : &quot;all &quot; ;
11947      }
11948  } 
11949  namespace Catch {
11950  namespace {
11951  void printTotals(std::ostream&amp; out, const Totals&amp; totals) {
11952      if (totals.testCases.total() == 0) {
11953          out &lt;&lt; &quot;No tests ran.&quot;;
11954      } else if (totals.testCases.failed == totals.testCases.total()) {
11955          Colour colour(Colour::ResultError);
11956          const std::string qualify_assertions_failed =
11957              totals.assertions.failed == totals.assertions.total() ?
11958              bothOrAll(totals.assertions.failed) : std::string();
11959          out &lt;&lt;
11960              &quot;Failed &quot; &lt;&lt; bothOrAll(totals.testCases.failed)
11961              &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11962              &quot;failed &quot; &lt;&lt; qualify_assertions_failed &lt;&lt;
11963              pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11964      } else if (totals.assertions.total() == 0) {
11965          out &lt;&lt;
11966              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.total())
11967              &lt;&lt; pluralise(totals.testCases.total(), &quot;test case&quot;)
11968              &lt;&lt; &quot; (no assertions).&quot;;
11969      } else if (totals.assertions.failed) {
11970          Colour colour(Colour::ResultError);
11971          out &lt;&lt;
11972              &quot;Failed &quot; &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11973              &quot;failed &quot; &lt;&lt; pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11974      } else {
11975          Colour colour(Colour::ResultSuccess);
11976          out &lt;&lt;
11977              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.passed)
11978              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt;
11979              &quot; with &quot; &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11980      }
11981  }
11982  class AssertionPrinter {
11983  public:
11984      AssertionPrinter&amp; operator= (AssertionPrinter const&amp;) = delete;
11985      AssertionPrinter(AssertionPrinter const&amp;) = delete;
11986      AssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
11987          : stream(_stream)
11988          , result(_stats.assertionResult)
11989          , messages(_stats.infoMessages)
11990          , itMessage(_stats.infoMessages.begin())
11991          , printInfoMessages(_printInfoMessages) {}
11992      void print() {
11993          printSourceInfo();
11994          itMessage = messages.begin();
11995          switch (result.getResultType()) {
11996          case ResultWas::Ok:
11997              printResultType(Colour::ResultSuccess, passedString());
11998              printOriginalExpression();
11999              printReconstructedExpression();
12000              if (!result.hasExpression())
12001                  printRemainingMessages(Colour::None);
12002              else
12003                  printRemainingMessages();
12004              break;
12005          case ResultWas::ExpressionFailed:
12006              if (result.isOk())
12007                  printResultType(Colour::ResultSuccess, failedString() + std::string(&quot; - but was ok&quot;));
12008              else
12009                  printResultType(Colour::Error, failedString());
12010              printOriginalExpression();
12011              printReconstructedExpression();
12012              printRemainingMessages();
12013              break;
12014          case ResultWas::ThrewException:
12015              printResultType(Colour::Error, failedString());
12016              printIssue(&quot;unexpected exception with message:&quot;);
12017              printMessage();
12018              printExpressionWas();
12019              printRemainingMessages();
12020              break;
12021          case ResultWas::FatalErrorCondition:
12022              printResultType(Colour::Error, failedString());
12023              printIssue(&quot;fatal error condition with message:&quot;);
12024              printMessage();
12025              printExpressionWas();
12026              printRemainingMessages();
12027              break;
12028          case ResultWas::DidntThrowException:
12029              printResultType(Colour::Error, failedString());
12030              printIssue(&quot;expected exception, got none&quot;);
12031              printExpressionWas();
12032              printRemainingMessages();
12033              break;
12034          case ResultWas::Info:
12035              printResultType(Colour::None, &quot;info&quot;);
12036              printMessage();
12037              printRemainingMessages();
12038              break;
12039          case ResultWas::Warning:
12040              printResultType(Colour::None, &quot;warning&quot;);
12041              printMessage();
12042              printRemainingMessages();
12043              break;
12044          case ResultWas::ExplicitFailure:
12045              printResultType(Colour::Error, failedString());
12046              printIssue(&quot;explicitly&quot;);
12047              printRemainingMessages(Colour::None);
12048              break;
12049          case ResultWas::Unknown:
12050          case ResultWas::FailureBit:
12051          case ResultWas::Exception:
12052              printResultType(Colour::Error, &quot;** internal error **&quot;);
12053              break;
12054          }
12055      }
12056  private:
12057      void printSourceInfo() const {
12058          Colour colourGuard(Colour::FileName);
12059          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &#x27;:&#x27;;
12060      }
12061      void printResultType(Colour::Code colour, std::string const&amp; passOrFail) const {
12062          if (!passOrFail.empty()) {
12063              {
12064                  Colour colourGuard(colour);
12065                  stream &lt;&lt; &#x27; &#x27; &lt;&lt; passOrFail;
12066              }
12067              stream &lt;&lt; &#x27;:&#x27;;
12068          }
12069      }
12070      void printIssue(std::string const&amp; issue) const {
12071          stream &lt;&lt; &#x27; &#x27; &lt;&lt; issue;
12072      }
12073      void printExpressionWas() {
12074          if (result.hasExpression()) {
12075              stream &lt;&lt; &#x27;;&#x27;;
12076              {
12077                  Colour colour(dimColour());
12078                  stream &lt;&lt; &quot; expression was:&quot;;
12079              }
12080              printOriginalExpression();
12081          }
12082      }
12083      void printOriginalExpression() const {
12084          if (result.hasExpression()) {
12085              stream &lt;&lt; &#x27; &#x27; &lt;&lt; result.getExpression();
12086          }
12087      }
12088      void printReconstructedExpression() const {
12089          if (result.hasExpandedExpression()) {
12090              {
12091                  Colour colour(dimColour());
12092                  stream &lt;&lt; &quot; for: &quot;;
12093              }
12094              stream &lt;&lt; result.getExpandedExpression();
12095          }
12096      }
12097      void printMessage() {
12098          if (itMessage != messages.end()) {
12099              stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; itMessage-&gt;message &lt;&lt; &#x27;\&#x27;&#x27;;
12100              ++itMessage;
12101          }
12102      }
12103      void printRemainingMessages(Colour::Code colour = dimColour()) {
12104          if (itMessage == messages.end())
12105              return;
12106          const auto itEnd = messages.cend();
12107          const auto N = static_cast&lt;std::size_t&gt;(std::distance(itMessage, itEnd));
12108          {
12109              Colour colourGuard(colour);
12110              stream &lt;&lt; &quot; with &quot; &lt;&lt; pluralise(N, &quot;message&quot;) &lt;&lt; &#x27;:&#x27;;
12111          }
12112          while (itMessage != itEnd) {
12113              if (printInfoMessages || itMessage-&gt;type != ResultWas::Info) {
12114                  printMessage();
12115                  if (itMessage != itEnd) {
12116                      Colour colourGuard(dimColour());
12117                      stream &lt;&lt; &quot; and&quot;;
12118                  }
12119                  continue;
12120              }
12121              ++itMessage;
12122          }
12123      }
12124  private:
12125      std::ostream&amp; stream;
12126      AssertionResult const&amp; result;
12127      std::vector&lt;MessageInfo&gt; messages;
12128      std::vector&lt;MessageInfo&gt;::const_iterator itMessage;
12129      bool printInfoMessages;
12130  };
12131  } 
12132          std::string CompactReporter::getDescription() {
12133              return &quot;Reports test results on a single line, suitable for IDEs&quot;;
12134          }
12135          void CompactReporter::noMatchingTestCases( std::string const&amp; spec ) {
12136              stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12137          }
12138          void CompactReporter::assertionStarting( AssertionInfo const&amp; ) {}
12139          bool CompactReporter::assertionEnded( AssertionStats const&amp; _assertionStats ) {
12140              AssertionResult const&amp; result = _assertionStats.assertionResult;
12141              bool printInfoMessages = true;
12142              if( !m_config-&gt;includeSuccessfulResults() &amp;&amp; result.isOk() ) {
12143                  if( result.getResultType() != ResultWas::Warning )
12144                      return false;
12145                  printInfoMessages = false;
12146              }
12147              AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
12148              printer.print();
12149              stream &lt;&lt; std::endl;
12150              return true;
12151          }
12152          void CompactReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12153              double dur = _sectionStats.durationInSeconds;
12154              if ( shouldShowDuration( *m_config, dur ) ) {
12155                  stream &lt;&lt; getFormattedDuration( dur ) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12156              }
12157          }
12158          void CompactReporter::testRunEnded( TestRunStats const&amp; _testRunStats ) {
12159              printTotals( stream, _testRunStats.totals );
12160              stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12161              StreamingReporterBase::testRunEnded( _testRunStats );
12162          }
12163          CompactReporter::~CompactReporter() {}
12164      CATCH_REGISTER_REPORTER( &quot;compact&quot;, CompactReporter )
12165  } 
12166  #include &lt;cfloat&gt;
12167  #include &lt;cstdio&gt;
12168  #if defined(_MSC_VER)
12169  #pragma warning(push)
12170  #pragma warning(disable:4061) 
12171  #endif
12172  #if defined(__clang__)
12173  #  pragma clang diagnostic push
12174  #  pragma clang diagnostic ignored &quot;-Wunused-function&quot;
12175  #endif
12176  namespace Catch {
12177  namespace {
12178  class ConsoleAssertionPrinter {
12179  public:
12180      ConsoleAssertionPrinter&amp; operator= (ConsoleAssertionPrinter const&amp;) = delete;
12181      ConsoleAssertionPrinter(ConsoleAssertionPrinter const&amp;) = delete;
12182      ConsoleAssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
12183          : stream(_stream),
12184          stats(_stats),
12185          result(_stats.assertionResult),
12186          colour(Colour::None),
12187          message(result.getMessage()),
12188          messages(_stats.infoMessages),
12189          printInfoMessages(_printInfoMessages) {
12190          switch (result.getResultType()) {
12191          case ResultWas::Ok:
12192              colour = Colour::Success;
12193              passOrFail = &quot;PASSED&quot;;
12194              if (_stats.infoMessages.size() == 1)
12195                  messageLabel = &quot;with message&quot;;
12196              if (_stats.infoMessages.size() &gt; 1)
12197                  messageLabel = &quot;with messages&quot;;
12198              break;
12199          case ResultWas::ExpressionFailed:
12200              if (result.isOk()) {
12201                  colour = Colour::Success;
12202                  passOrFail = &quot;FAILED - but was ok&quot;;
12203              } else {
12204                  colour = Colour::Error;
12205                  passOrFail = &quot;FAILED&quot;;
12206              }
12207              if (_stats.infoMessages.size() == 1)
12208                  messageLabel = &quot;with message&quot;;
12209              if (_stats.infoMessages.size() &gt; 1)
12210                  messageLabel = &quot;with messages&quot;;
12211              break;
12212          case ResultWas::ThrewException:
12213              colour = Colour::Error;
12214              passOrFail = &quot;FAILED&quot;;
12215              messageLabel = &quot;due to unexpected exception with &quot;;
12216              if (_stats.infoMessages.size() == 1)
12217                  messageLabel += &quot;message&quot;;
12218              if (_stats.infoMessages.size() &gt; 1)
12219                  messageLabel += &quot;messages&quot;;
12220              break;
12221          case ResultWas::FatalErrorCondition:
12222              colour = Colour::Error;
12223              passOrFail = &quot;FAILED&quot;;
12224              messageLabel = &quot;due to a fatal error condition&quot;;
12225              break;
12226          case ResultWas::DidntThrowException:
12227              colour = Colour::Error;
12228              passOrFail = &quot;FAILED&quot;;
12229              messageLabel = &quot;because no exception was thrown where one was expected&quot;;
12230              break;
12231          case ResultWas::Info:
12232              messageLabel = &quot;info&quot;;
12233              break;
12234          case ResultWas::Warning:
12235              messageLabel = &quot;warning&quot;;
12236              break;
12237          case ResultWas::ExplicitFailure:
12238              passOrFail = &quot;FAILED&quot;;
12239              colour = Colour::Error;
12240              if (_stats.infoMessages.size() == 1)
12241                  messageLabel = &quot;explicitly with message&quot;;
12242              if (_stats.infoMessages.size() &gt; 1)
12243                  messageLabel = &quot;explicitly with messages&quot;;
12244              break;
12245          case ResultWas::Unknown:
12246          case ResultWas::FailureBit:
12247          case ResultWas::Exception:
12248              passOrFail = &quot;** internal error **&quot;;
12249              colour = Colour::Error;
12250              break;
12251          }
12252      }
12253      void print() const {
12254          printSourceInfo();
12255          if (stats.totals.assertions.total() &gt; 0) {
12256              printResultType();
12257              printOriginalExpression();
12258              printReconstructedExpression();
12259          } else {
12260              stream &lt;&lt; &#x27;\n&#x27;;
12261          }
12262          printMessage();
12263      }
12264  private:
12265      void printResultType() const {
12266          if (!passOrFail.empty()) {
12267              Colour colourGuard(colour);
12268              stream &lt;&lt; passOrFail &lt;&lt; &quot;:\n&quot;;
12269          }
12270      }
12271      void printOriginalExpression() const {
12272          if (result.hasExpression()) {
12273              Colour colourGuard(Colour::OriginalExpression);
12274              stream &lt;&lt; &quot;  &quot;;
12275              stream &lt;&lt; result.getExpressionInMacro();
12276              stream &lt;&lt; &#x27;\n&#x27;;
12277          }
12278      }
12279      void printReconstructedExpression() const {
12280          if (result.hasExpandedExpression()) {
12281              stream &lt;&lt; &quot;with expansion:\n&quot;;
12282              Colour colourGuard(Colour::ReconstructedExpression);
12283              stream &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12284          }
12285      }
12286      void printMessage() const {
12287          if (!messageLabel.empty())
12288              stream &lt;&lt; messageLabel &lt;&lt; &#x27;:&#x27; &lt;&lt; &#x27;\n&#x27;;
12289          for (auto const&amp; msg : messages) {
12290              if (printInfoMessages || msg.type != ResultWas::Info)
12291                  stream &lt;&lt; Column(msg.message).indent(2) &lt;&lt; &#x27;\n&#x27;;
12292          }
12293      }
12294      void printSourceInfo() const {
12295          Colour colourGuard(Colour::FileName);
12296          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &quot;: &quot;;
12297      }
12298      std::ostream&amp; stream;
12299      AssertionStats const&amp; stats;
12300      AssertionResult const&amp; result;
12301      Colour::Code colour;
12302      std::string passOrFail;
12303      std::string messageLabel;
12304      std::string message;
12305      std::vector&lt;MessageInfo&gt; messages;
12306      bool printInfoMessages;
12307  };
12308  std::size_t makeRatio(std::size_t number, std::size_t total) {
12309      std::size_t ratio = total &gt; 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
12310      return (ratio == 0 &amp;&amp; number &gt; 0) ? 1 : ratio;
12311  }
12312  std::size_t&amp; findMax(std::size_t&amp; i, std::size_t&amp; j, std::size_t&amp; k) {
12313      if (i &gt; j &amp;&amp; i &gt; k)
12314          return i;
12315      else if (j &gt; k)
12316          return j;
12317      else
12318          return k;
12319  }
12320  struct ColumnInfo {
12321      enum Justification { Left, Right };
12322      std::string name;
12323      int width;
12324      Justification justification;
12325  };
12326  struct ColumnBreak {};
12327  struct RowBreak {};
12328  class Duration {
12329      enum class Unit {
12330          Auto,
12331          Nanoseconds,
12332          Microseconds,
12333          Milliseconds,
12334          Seconds,
12335          Minutes
12336      };
12337      static const uint64_t s_nanosecondsInAMicrosecond = 1000;
12338      static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
12339      static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
12340      static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
12341      double m_inNanoseconds;
12342      Unit m_units;
12343  public:
12344      explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
12345          : m_inNanoseconds(inNanoseconds),
12346          m_units(units) {
12347          if (m_units == Unit::Auto) {
12348              if (m_inNanoseconds &lt; s_nanosecondsInAMicrosecond)
12349                  m_units = Unit::Nanoseconds;
12350              else if (m_inNanoseconds &lt; s_nanosecondsInAMillisecond)
12351                  m_units = Unit::Microseconds;
12352              else if (m_inNanoseconds &lt; s_nanosecondsInASecond)
12353                  m_units = Unit::Milliseconds;
12354              else if (m_inNanoseconds &lt; s_nanosecondsInAMinute)
12355                  m_units = Unit::Seconds;
12356              else
12357                  m_units = Unit::Minutes;
12358          }
12359      }
12360      auto value() const -&gt; double {
12361          switch (m_units) {
12362          case Unit::Microseconds:
12363              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMicrosecond);
12364          case Unit::Milliseconds:
12365              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMillisecond);
12366          case Unit::Seconds:
12367              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInASecond);
12368          case Unit::Minutes:
12369              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMinute);
12370          default:
12371              return m_inNanoseconds;
12372          }
12373      }
12374      auto unitsAsString() const -&gt; std::string {
12375          switch (m_units) {
12376          case Unit::Nanoseconds:
12377              return &quot;ns&quot;;
12378          case Unit::Microseconds:
12379              return &quot;us&quot;;
12380          case Unit::Milliseconds:
12381              return &quot;ms&quot;;
12382          case Unit::Seconds:
12383              return &quot;s&quot;;
12384          case Unit::Minutes:
12385              return &quot;m&quot;;
12386          default:
12387              return &quot;** internal error **&quot;;
12388          }
12389      }
12390      friend auto operator &lt;&lt; (std::ostream&amp; os, Duration const&amp; duration) -&gt; std::ostream&amp; {
12391          return os &lt;&lt; duration.value() &lt;&lt; &#x27; &#x27; &lt;&lt; duration.unitsAsString();
12392      }
12393  };
12394  } 
12395  class TablePrinter {
12396      std::ostream&amp; m_os;
12397      std::vector&lt;ColumnInfo&gt; m_columnInfos;
12398      std::ostringstream m_oss;
12399      int m_currentColumn = -1;
12400      bool m_isOpen = false;
12401  public:
12402      TablePrinter( std::ostream&amp; os, std::vector&lt;ColumnInfo&gt; columnInfos )
12403      :   m_os( os ),
12404          m_columnInfos( std::move( columnInfos ) ) {}
12405      auto columnInfos() const -&gt; std::vector&lt;ColumnInfo&gt; const&amp; {
12406          return m_columnInfos;
12407      }
12408      void open() {
12409          if (!m_isOpen) {
12410              m_isOpen = true;
12411              *this &lt;&lt; RowBreak();
12412  			Columns headerCols;
12413  			Spacer spacer(2);
12414  			for (auto const&amp; info : m_columnInfos) {
12415  				headerCols += Column(info.name).width(static_cast&lt;std::size_t&gt;(info.width - 2));
12416  				headerCols += spacer;
12417  			}
12418  			m_os &lt;&lt; headerCols &lt;&lt; &#x27;\n&#x27;;
12419              m_os &lt;&lt; Catch::getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12420          }
12421      }
12422      void close() {
12423          if (m_isOpen) {
12424              *this &lt;&lt; RowBreak();
12425              m_os &lt;&lt; std::endl;
12426              m_isOpen = false;
12427          }
12428      }
12429      template&lt;typename T&gt;
12430      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, T const&amp; value) {
12431          tp.m_oss &lt;&lt; value;
12432          return tp;
12433      }
12434      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, ColumnBreak) {
12435          auto colStr = tp.m_oss.str();
12436          const auto strSize = colStr.size();
12437          tp.m_oss.str(&quot;&quot;);
12438          tp.open();
12439          if (tp.m_currentColumn == static_cast&lt;int&gt;(tp.m_columnInfos.size() - 1)) {
12440              tp.m_currentColumn = -1;
12441              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12442          }
12443          tp.m_currentColumn++;
12444          auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
12445          auto padding = (strSize + 1 &lt; static_cast&lt;std::size_t&gt;(colInfo.width))
12446              ? std::string(colInfo.width - (strSize + 1), &#x27; &#x27;)
12447              : std::string();
12448          if (colInfo.justification == ColumnInfo::Left)
12449              tp.m_os &lt;&lt; colStr &lt;&lt; padding &lt;&lt; &#x27; &#x27;;
12450          else
12451              tp.m_os &lt;&lt; padding &lt;&lt; colStr &lt;&lt; &#x27; &#x27;;
12452          return tp;
12453      }
12454      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, RowBreak) {
12455          if (tp.m_currentColumn &gt; 0) {
12456              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12457              tp.m_currentColumn = -1;
12458          }
12459          return tp;
12460      }
12461  };
12462  ConsoleReporter::ConsoleReporter(ReporterConfig const&amp; config)
12463      : StreamingReporterBase(config),
12464      m_tablePrinter(new TablePrinter(config.stream(),
12465          [&amp;config]() -&gt; std::vector&lt;ColumnInfo&gt; {
12466          if (config.fullConfig()-&gt;benchmarkNoAnalysis())
12467          {
12468              return{
12469                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12470                  { &quot;     samples&quot;, 14, ColumnInfo::Right },
12471                  { &quot;  iterations&quot;, 14, ColumnInfo::Right },
12472                  { &quot;        mean&quot;, 14, ColumnInfo::Right }
12473              };
12474          }
12475          else
12476          {
12477              return{
12478                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12479                  { &quot;samples      mean       std dev&quot;, 14, ColumnInfo::Right },
12480                  { &quot;iterations   low mean   low std dev&quot;, 14, ColumnInfo::Right },
12481                  { &quot;estimated    high mean  high std dev&quot;, 14, ColumnInfo::Right }
12482              };
12483          }
12484      }())) {}
12485  ConsoleReporter::~ConsoleReporter() = default;
12486  std::string ConsoleReporter::getDescription() {
12487      return &quot;Reports test results as plain lines of text&quot;;
12488  }
12489  void ConsoleReporter::noMatchingTestCases(std::string const&amp; spec) {
12490      stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12491  }
12492  void ConsoleReporter::reportInvalidArguments(std::string const&amp;arg){
12493      stream &lt;&lt; &quot;Invalid Filter: &quot; &lt;&lt; arg &lt;&lt; std::endl;
12494  }
12495  void ConsoleReporter::assertionStarting(AssertionInfo const&amp;) {}
12496  bool ConsoleReporter::assertionEnded(AssertionStats const&amp; _assertionStats) {
12497      AssertionResult const&amp; result = _assertionStats.assertionResult;
12498      bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
12499      if (!includeResults &amp;&amp; result.getResultType() != ResultWas::Warning)
12500          return false;
12501      lazyPrint();
12502      ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
12503      printer.print();
12504      stream &lt;&lt; std::endl;
12505      return true;
12506  }
12507  void ConsoleReporter::sectionStarting(SectionInfo const&amp; _sectionInfo) {
12508      m_tablePrinter-&gt;close();
12509      m_headerPrinted = false;
12510      StreamingReporterBase::sectionStarting(_sectionInfo);
12511  }
12512  void ConsoleReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12513      m_tablePrinter-&gt;close();
12514      if (_sectionStats.missingAssertions) {
12515          lazyPrint();
12516          Colour colour(Colour::ResultError);
12517          if (m_sectionStack.size() &gt; 1)
12518              stream &lt;&lt; &quot;\nNo assertions in section&quot;;
12519          else
12520              stream &lt;&lt; &quot;\nNo assertions in test case&quot;;
12521          stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; &quot;&#x27;\n&quot; &lt;&lt; std::endl;
12522      }
12523      double dur = _sectionStats.durationInSeconds;
12524      if (shouldShowDuration(*m_config, dur)) {
12525          stream &lt;&lt; getFormattedDuration(dur) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12526      }
12527      if (m_headerPrinted) {
12528          m_headerPrinted = false;
12529      }
12530      StreamingReporterBase::sectionEnded(_sectionStats);
12531  }
12532  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
12533  void ConsoleReporter::benchmarkPreparing(std::string const&amp; name) {
12534  	lazyPrintWithoutClosingBenchmarkTable();
12535  	auto nameCol = Column(name).width(static_cast&lt;std::size_t&gt;(m_tablePrinter-&gt;columnInfos()[0].width - 2));
12536  	bool firstLine = true;
12537  	for (auto line : nameCol) {
12538  		if (!firstLine)
12539  			(*m_tablePrinter) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12540  		else
12541  			firstLine = false;
12542  		(*m_tablePrinter) &lt;&lt; line &lt;&lt; ColumnBreak();
12543  	}
12544  }
12545  void ConsoleReporter::benchmarkStarting(BenchmarkInfo const&amp; info) {
12546      (*m_tablePrinter) &lt;&lt; info.samples &lt;&lt; ColumnBreak()
12547          &lt;&lt; info.iterations &lt;&lt; ColumnBreak();
12548      if (!m_config-&gt;benchmarkNoAnalysis())
12549          (*m_tablePrinter) &lt;&lt; Duration(info.estimatedDuration) &lt;&lt; ColumnBreak();
12550  }
12551  void ConsoleReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) {
12552      if (m_config-&gt;benchmarkNoAnalysis())
12553      {
12554          (*m_tablePrinter) &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak();
12555      }
12556      else
12557      {
12558          (*m_tablePrinter) &lt;&lt; ColumnBreak()
12559              &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak()
12560              &lt;&lt; Duration(stats.mean.lower_bound.count()) &lt;&lt; ColumnBreak()
12561              &lt;&lt; Duration(stats.mean.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak()
12562              &lt;&lt; Duration(stats.standardDeviation.point.count()) &lt;&lt; ColumnBreak()
12563              &lt;&lt; Duration(stats.standardDeviation.lower_bound.count()) &lt;&lt; ColumnBreak()
12564              &lt;&lt; Duration(stats.standardDeviation.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12565      }
12566  }
12567  void ConsoleReporter::benchmarkFailed(std::string const&amp; error) {
12568  	Colour colour(Colour::Red);
12569      (*m_tablePrinter)
12570          &lt;&lt; &quot;Benchmark failed (&quot; &lt;&lt; error &lt;&lt; &#x27;)&#x27;
12571          &lt;&lt; ColumnBreak() &lt;&lt; RowBreak();
12572  }
12573  #endif 
12574  void ConsoleReporter::testCaseEnded(TestCaseStats const&amp; _testCaseStats) {
12575      m_tablePrinter-&gt;close();
12576      StreamingReporterBase::testCaseEnded(_testCaseStats);
12577      m_headerPrinted = false;
12578  }
12579  void ConsoleReporter::testGroupEnded(TestGroupStats const&amp; _testGroupStats) {
12580      if (currentGroupInfo.used) {
12581          printSummaryDivider();
12582          stream &lt;&lt; &quot;Summary for group &#x27;&quot; &lt;&lt; _testGroupStats.groupInfo.name &lt;&lt; &quot;&#x27;:\n&quot;;
12583          printTotals(_testGroupStats.totals);
12584          stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12585      }
12586      StreamingReporterBase::testGroupEnded(_testGroupStats);
12587  }
12588  void ConsoleReporter::testRunEnded(TestRunStats const&amp; _testRunStats) {
12589      printTotalsDivider(_testRunStats.totals);
12590      printTotals(_testRunStats.totals);
12591      stream &lt;&lt; std::endl;
12592      StreamingReporterBase::testRunEnded(_testRunStats);
12593  }
12594  void ConsoleReporter::testRunStarting(TestRunInfo const&amp; _testInfo) {
12595      StreamingReporterBase::testRunStarting(_testInfo);
12596      printTestFilters();
12597  }
12598  void ConsoleReporter::lazyPrint() {
12599      m_tablePrinter-&gt;close();
12600      lazyPrintWithoutClosingBenchmarkTable();
12601  }
12602  void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
12603      if (!currentTestRunInfo.used)
12604          lazyPrintRunInfo();
12605      if (!currentGroupInfo.used)
12606          lazyPrintGroupInfo();
12607      if (!m_headerPrinted) {
12608          printTestCaseAndSectionHeader();
12609          m_headerPrinted = true;
12610      }
12611  }
12612  void ConsoleReporter::lazyPrintRunInfo() {
12613      stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; getLineOfChars&lt;&#x27;~&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12614      Colour colour(Colour::SecondaryText);
12615      stream &lt;&lt; currentTestRunInfo-&gt;name
12616          &lt;&lt; &quot; is a Catch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot; host application.\n&quot;
12617          &lt;&lt; &quot;Run with -? for options\n\n&quot;;
12618      if (m_config-&gt;rngSeed() != 0)
12619          stream &lt;&lt; &quot;Randomness seeded to: &quot; &lt;&lt; m_config-&gt;rngSeed() &lt;&lt; &quot;\n\n&quot;;
12620      currentTestRunInfo.used = true;
12621  }
12622  void ConsoleReporter::lazyPrintGroupInfo() {
12623      if (!currentGroupInfo-&gt;name.empty() &amp;&amp; currentGroupInfo-&gt;groupsCounts &gt; 1) {
12624          printClosedHeader(&quot;Group: &quot; + currentGroupInfo-&gt;name);
12625          currentGroupInfo.used = true;
12626      }
12627  }
12628  void ConsoleReporter::printTestCaseAndSectionHeader() {
12629      assert(!m_sectionStack.empty());
12630      printOpenHeader(currentTestCaseInfo-&gt;name);
12631      if (m_sectionStack.size() &gt; 1) {
12632          Colour colourGuard(Colour::Headers);
12633          auto
12634              it = m_sectionStack.begin() + 1, 
12635              itEnd = m_sectionStack.end();
12636          for (; it != itEnd; ++it)
12637              printHeaderString(it-&gt;name, 2);
12638      }
12639      SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
12640      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12641      Colour colourGuard(Colour::FileName);
12642      stream &lt;&lt; lineInfo &lt;&lt; &#x27;\n&#x27;;
12643      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12644  }
12645  void ConsoleReporter::printClosedHeader(std::string const&amp; _name) {
12646      printOpenHeader(_name);
12647      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12648  }
12649  void ConsoleReporter::printOpenHeader(std::string const&amp; _name) {
12650      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12651      {
12652          Colour colourGuard(Colour::Headers);
12653          printHeaderString(_name);
12654      }
12655  }
12656  void ConsoleReporter::printHeaderString(std::string const&amp; _string, std::size_t indent) {
12657      std::size_t i = _string.find(&quot;: &quot;);
12658      if (i != std::string::npos)
12659          i += 2;
12660      else
12661          i = 0;
12662      stream &lt;&lt; Column(_string).indent(indent + i).initialIndent(indent) &lt;&lt; &#x27;\n&#x27;;
12663  }
12664  struct SummaryColumn {
12665      SummaryColumn( std::string _label, Colour::Code _colour )
12666      :   label( std::move( _label ) ),
12667          colour( _colour ) {}
12668      SummaryColumn addRow( std::size_t count ) {
12669          ReusableStringStream rss;
12670          rss &lt;&lt; count;
12671          std::string row = rss.str();
12672          for (auto&amp; oldRow : rows) {
12673              while (oldRow.size() &lt; row.size())
12674                  oldRow = &#x27; &#x27; + oldRow;
12675              while (oldRow.size() &gt; row.size())
12676                  row = &#x27; &#x27; + row;
12677          }
12678          rows.push_back(row);
12679          return *this;
12680      }
12681      std::string label;
12682      Colour::Code colour;
12683      std::vector&lt;std::string&gt; rows;
12684  };
12685  void ConsoleReporter::printTotals( Totals const&amp; totals ) {
12686      if (totals.testCases.total() == 0) {
12687          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;No tests ran\n&quot;;
12688      } else if (totals.assertions.total() &gt; 0 &amp;&amp; totals.testCases.allPassed()) {
12689          stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; &quot;All tests passed&quot;;
12690          stream &lt;&lt; &quot; (&quot;
12691              &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &quot; in &quot;
12692              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt; &#x27;)&#x27;
12693              &lt;&lt; &#x27;\n&#x27;;
12694      } else {
12695          std::vector&lt;SummaryColumn&gt; columns;
12696          columns.push_back(SummaryColumn(&quot;&quot;, Colour::None)
12697                            .addRow(totals.testCases.total())
12698                            .addRow(totals.assertions.total()));
12699          columns.push_back(SummaryColumn(&quot;passed&quot;, Colour::Success)
12700                            .addRow(totals.testCases.passed)
12701                            .addRow(totals.assertions.passed));
12702          columns.push_back(SummaryColumn(&quot;failed&quot;, Colour::ResultError)
12703                            .addRow(totals.testCases.failed)
12704                            .addRow(totals.assertions.failed));
12705          columns.push_back(SummaryColumn(&quot;failed as expected&quot;, Colour::ResultExpectedFailure)
12706                            .addRow(totals.testCases.failedButOk)
12707                            .addRow(totals.assertions.failedButOk));
12708          printSummaryRow(&quot;test cases&quot;, columns, 0);
12709          printSummaryRow(&quot;assertions&quot;, columns, 1);
12710      }
12711  }
12712  void ConsoleReporter::printSummaryRow(std::string const&amp; label, std::vector&lt;SummaryColumn&gt; const&amp; cols, std::size_t row) {
12713      for (auto col : cols) {
12714          std::string value = col.rows[row];
12715          if (col.label.empty()) {
12716              stream &lt;&lt; label &lt;&lt; &quot;: &quot;;
12717              if (value != &quot;0&quot;)
12718                  stream &lt;&lt; value;
12719              else
12720                  stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;- none -&quot;;
12721          } else if (value != &quot;0&quot;) {
12722              stream &lt;&lt; Colour(Colour::LightGrey) &lt;&lt; &quot; | &quot;;
12723              stream &lt;&lt; Colour(col.colour)
12724                  &lt;&lt; value &lt;&lt; &#x27; &#x27; &lt;&lt; col.label;
12725          }
12726      }
12727      stream &lt;&lt; &#x27;\n&#x27;;
12728  }
12729  void ConsoleReporter::printTotalsDivider(Totals const&amp; totals) {
12730      if (totals.testCases.total() &gt; 0) {
12731          std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
12732          std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
12733          std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
12734          while (failedRatio + failedButOkRatio + passedRatio &lt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12735              findMax(failedRatio, failedButOkRatio, passedRatio)++;
12736          while (failedRatio + failedButOkRatio + passedRatio &gt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12737              findMax(failedRatio, failedButOkRatio, passedRatio)--;
12738          stream &lt;&lt; Colour(Colour::Error) &lt;&lt; std::string(failedRatio, &#x27;=&#x27;);
12739          stream &lt;&lt; Colour(Colour::ResultExpectedFailure) &lt;&lt; std::string(failedButOkRatio, &#x27;=&#x27;);
12740          if (totals.testCases.allPassed())
12741              stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12742          else
12743              stream &lt;&lt; Colour(Colour::Success) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12744      } else {
12745          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, &#x27;=&#x27;);
12746      }
12747      stream &lt;&lt; &#x27;\n&#x27;;
12748  }
12749  void ConsoleReporter::printSummaryDivider() {
12750      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12751  }
12752  void ConsoleReporter::printTestFilters() {
12753      if (m_config-&gt;testSpec().hasFilters()) {
12754          Colour guard(Colour::BrightYellow);
12755          stream &lt;&lt; &quot;Filters: &quot; &lt;&lt; serializeFilters(m_config-&gt;getTestsOrTags()) &lt;&lt; &#x27;\n&#x27;;
12756      }
12757  }
12758  CATCH_REGISTER_REPORTER(&quot;console&quot;, ConsoleReporter)
12759  } 
12760  #if defined(_MSC_VER)
12761  #pragma warning(pop)
12762  #endif
12763  #if defined(__clang__)
12764  #  pragma clang diagnostic pop
12765  #endif
12766  #include &lt;cassert&gt;
12767  #include &lt;sstream&gt;
12768  #include &lt;ctime&gt;
12769  #include &lt;algorithm&gt;
12770  #include &lt;iomanip&gt;
12771  namespace Catch {
12772      namespace {
12773          std::string getCurrentTimestamp() {
12774              time_t rawtime;
12775              std::time(&amp;rawtime);
12776              auto const timeStampSize = sizeof(&quot;2017-01-16T17:06:45Z&quot;);
12777  #ifdef _MSC_VER
12778              std::tm timeInfo = {};
12779              gmtime_s(&amp;timeInfo, &amp;rawtime);
12780  #else
12781              std::tm* timeInfo;
12782              timeInfo = std::gmtime(&amp;rawtime);
12783  #endif
12784              char timeStamp[timeStampSize];
12785              const char * const fmt = &quot;%Y-%m-%dT%H:%M:%SZ&quot;;
12786  #ifdef _MSC_VER
12787              std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
12788  #else
12789              std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
12790  #endif
12791              return std::string(timeStamp, timeStampSize-1);
12792          }
12793          std::string fileNameTag(const std::vector&lt;std::string&gt; &amp;tags) {
12794              auto it = std::find_if(begin(tags),
12795                                     end(tags),
12796                                     [] (std::string const&amp; tag) {return tag.front() == &#x27;#&#x27;; });
12797              if (it != tags.end())
12798                  return it-&gt;substr(1);
12799              return std::string();
12800          }
12801          std::string formatDuration( double seconds ) {
12802              ReusableStringStream rss;
12803              rss &lt;&lt; std::fixed &lt;&lt; std::setprecision( 3 ) &lt;&lt; seconds;
12804              return rss.str();
12805          }
12806      } 
12807      JunitReporter::JunitReporter( ReporterConfig const&amp; _config )
12808          :   CumulativeReporterBase( _config ),
12809              xml( _config.stream() )
12810          {
12811              m_reporterPrefs.shouldRedirectStdOut = true;
12812              m_reporterPrefs.shouldReportAllAssertions = true;
12813          }
12814      JunitReporter::~JunitReporter() {}
12815      std::string JunitReporter::getDescription() {
12816          return &quot;Reports test results in an XML format that looks like Ant&#x27;s junitreport target&quot;;
12817      }
12818      void JunitReporter::noMatchingTestCases( std::string const&amp; &amp;bsol;*spec*/ ) {}
12819      void JunitReporter::testRunStarting( TestRunInfo const&amp; runInfo )  {
12820          CumulativeReporterBase::testRunStarting( runInfo );
12821          xml.startElement( &quot;testsuites&quot; );
12822      }
12823      void JunitReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
12824          suiteTimer.start();
12825          stdOutForSuite.clear();
12826          stdErrForSuite.clear();
12827          unexpectedExceptions = 0;
12828          CumulativeReporterBase::testGroupStarting( groupInfo );
12829      }
12830      void JunitReporter::testCaseStarting( TestCaseInfo const&amp; testCaseInfo ) {
12831          m_okToFail = testCaseInfo.okToFail();
12832      }
12833      bool JunitReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
12834          if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException &amp;&amp; !m_okToFail )
12835              unexpectedExceptions++;
12836          return CumulativeReporterBase::assertionEnded( assertionStats );
12837      }
12838      void JunitReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
12839          stdOutForSuite += testCaseStats.stdOut;
12840          stdErrForSuite += testCaseStats.stdErr;
12841          CumulativeReporterBase::testCaseEnded( testCaseStats );
12842      }
12843      void JunitReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
12844          double suiteTime = suiteTimer.getElapsedSeconds();
12845          CumulativeReporterBase::testGroupEnded( testGroupStats );
12846          writeGroup( *m_testGroups.back(), suiteTime );
12847      }
12848      void JunitReporter::testRunEndedCumulative() {
12849          xml.endElement();
12850      }
12851      void JunitReporter::writeGroup( TestGroupNode const&amp; groupNode, double suiteTime ) {
12852          XmlWriter::ScopedElement e = xml.scopedElement( &quot;testsuite&quot; );
12853          TestGroupStats const&amp; stats = groupNode.value;
12854          xml.writeAttribute( &quot;name&quot;, stats.groupInfo.name );
12855          xml.writeAttribute( &quot;errors&quot;, unexpectedExceptions );
12856          xml.writeAttribute( &quot;failures&quot;, stats.totals.assertions.failed-unexpectedExceptions );
12857          xml.writeAttribute( &quot;tests&quot;, stats.totals.assertions.total() );
12858          xml.writeAttribute( &quot;hostname&quot;, &quot;tbd&quot; ); 
12859          if( m_config-&gt;showDurations() == ShowDurations::Never )
12860              xml.writeAttribute( &quot;time&quot;, &quot;&quot; );
12861          else
12862              xml.writeAttribute( &quot;time&quot;, formatDuration( suiteTime ) );
12863          xml.writeAttribute( &quot;timestamp&quot;, getCurrentTimestamp() );
12864          if (m_config-&gt;hasTestFilters() || m_config-&gt;rngSeed() != 0) {
12865              auto properties = xml.scopedElement(&quot;properties&quot;);
12866              if (m_config-&gt;hasTestFilters()) {
12867                  xml.scopedElement(&quot;property&quot;)
12868                      .writeAttribute(&quot;name&quot;, &quot;filters&quot;)
12869                      .writeAttribute(&quot;value&quot;, serializeFilters(m_config-&gt;getTestsOrTags()));
12870              }
12871              if (m_config-&gt;rngSeed() != 0) {
12872                  xml.scopedElement(&quot;property&quot;)
12873                      .writeAttribute(&quot;name&quot;, &quot;random-seed&quot;)
12874                      .writeAttribute(&quot;value&quot;, m_config-&gt;rngSeed());
12875              }
12876          }
12877          for( auto const&amp; child : groupNode.children )
12878              writeTestCase( *child );
12879          xml.scopedElement( &quot;system-out&quot; ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
12880          xml.scopedElement( &quot;system-err&quot; ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
12881      }
12882      void JunitReporter::writeTestCase( TestCaseNode const&amp; testCaseNode ) {
12883          TestCaseStats const&amp; stats = testCaseNode.value;
12884          assert( testCaseNode.children.size() == 1 );
12885          SectionNode const&amp; rootSection = *testCaseNode.children.front();
12886          std::string className = stats.testInfo.className;
12887          if( className.empty() ) {
12888              className = fileNameTag(stats.testInfo.tags);
12889              if ( className.empty() )
12890                  className = &quot;global&quot;;
12891          }
12892          if ( !m_config-&gt;name().empty() )
12893              className = m_config-&gt;name() + &quot;.&quot; + className;
12894          writeSection( className, &quot;&quot;, rootSection, stats.testInfo.okToFail() );
12895      }
12896      void JunitReporter::writeSection( std::string const&amp; className,
12897                                        std::string const&amp; rootName,
12898                                        SectionNode const&amp; sectionNode,
12899                                        bool testOkToFail) {
12900          std::string name = trim( sectionNode.stats.sectionInfo.name );
12901          if( !rootName.empty() )
12902              name = rootName + &#x27;/&#x27; + name;
12903          if( !sectionNode.assertions.empty() ||
12904              !sectionNode.stdOut.empty() ||
12905              !sectionNode.stdErr.empty() ) {
12906              XmlWriter::ScopedElement e = xml.scopedElement( &quot;testcase&quot; );
12907              if( className.empty() ) {
12908                  xml.writeAttribute( &quot;classname&quot;, name );
12909                  xml.writeAttribute( &quot;name&quot;, &quot;root&quot; );
12910              }
12911              else {
12912                  xml.writeAttribute( &quot;classname&quot;, className );
12913                  xml.writeAttribute( &quot;name&quot;, name );
12914              }
12915              xml.writeAttribute( &quot;time&quot;, formatDuration( sectionNode.stats.durationInSeconds ) );
12916              xml.writeAttribute( &quot;status&quot;, &quot;run&quot; );
12917              if (sectionNode.stats.assertions.failedButOk) {
12918                  xml.scopedElement(&quot;skipped&quot;)
12919                      .writeAttribute(&quot;message&quot;, &quot;TEST_CASE tagged with !mayfail&quot;);
12920              }
12921              writeAssertions( sectionNode );
12922              if( !sectionNode.stdOut.empty() )
12923                  xml.scopedElement( &quot;system-out&quot; ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
12924              if( !sectionNode.stdErr.empty() )
12925                  xml.scopedElement( &quot;system-err&quot; ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
12926          }
12927          for( auto const&amp; childNode : sectionNode.childSections )
12928              if( className.empty() )
12929                  writeSection( name, &quot;&quot;, *childNode, testOkToFail );
12930              else
12931                  writeSection( className, name, *childNode, testOkToFail );
12932      }
12933      void JunitReporter::writeAssertions( SectionNode const&amp; sectionNode ) {
12934          for( auto const&amp; assertion : sectionNode.assertions )
12935              writeAssertion( assertion );
12936      }
12937      void JunitReporter::writeAssertion( AssertionStats const&amp; stats ) {
12938          AssertionResult const&amp; result = stats.assertionResult;
12939          if( !result.isOk() ) {
12940              std::string elementName;
12941              switch( result.getResultType() ) {
12942                  case ResultWas::ThrewException:
12943                  case ResultWas::FatalErrorCondition:
12944                      elementName = &quot;error&quot;;
12945                      break;
12946                  case ResultWas::ExplicitFailure:
12947                  case ResultWas::ExpressionFailed:
12948                  case ResultWas::DidntThrowException:
12949                      elementName = &quot;failure&quot;;
12950                      break;
12951                  case ResultWas::Info:
12952                  case ResultWas::Warning:
12953                  case ResultWas::Ok:
12954                  case ResultWas::Unknown:
12955                  case ResultWas::FailureBit:
12956                  case ResultWas::Exception:
12957                      elementName = &quot;internalError&quot;;
12958                      break;
12959              }
12960              XmlWriter::ScopedElement e = xml.scopedElement( elementName );
12961              xml.writeAttribute( &quot;message&quot;, result.getExpression() );
12962              xml.writeAttribute( &quot;type&quot;, result.getTestMacroName() );
12963              ReusableStringStream rss;
12964              if (stats.totals.assertions.total() &gt; 0) {
12965                  rss &lt;&lt; &quot;FAILED&quot; &lt;&lt; &quot;:\n&quot;;
12966                  if (result.hasExpression()) {
12967                      rss &lt;&lt; &quot;  &quot;;
12968                      rss &lt;&lt; result.getExpressionInMacro();
12969                      rss &lt;&lt; &#x27;\n&#x27;;
12970                  }
12971                  if (result.hasExpandedExpression()) {
12972                      rss &lt;&lt; &quot;with expansion:\n&quot;;
12973                      rss &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12974                  }
12975              } else {
12976                  rss &lt;&lt; &#x27;\n&#x27;;
12977              }
12978              if( !result.getMessage().empty() )
12979                  rss &lt;&lt; result.getMessage() &lt;&lt; &#x27;\n&#x27;;
12980              for( auto const&amp; msg : stats.infoMessages )
12981                  if( msg.type == ResultWas::Info )
12982                      rss &lt;&lt; msg.message &lt;&lt; &#x27;\n&#x27;;
12983              rss &lt;&lt; &quot;at &quot; &lt;&lt; result.getSourceInfo();
12984              xml.writeText( rss.str(), XmlFormatting::Newline );
12985          }
12986      }
12987      CATCH_REGISTER_REPORTER( &quot;junit&quot;, JunitReporter )
12988  } 
12989  #include &lt;cassert&gt;
12990  namespace Catch {
12991      ListeningReporter::ListeningReporter() {
12992          m_preferences.shouldReportAllAssertions = true;
12993      }
12994      void ListeningReporter::addListener( IStreamingReporterPtr&amp;&amp; listener ) {
12995          m_listeners.push_back( std::move( listener ) );
12996      }
12997      void ListeningReporter::addReporter(IStreamingReporterPtr&amp;&amp; reporter) {
12998          assert(!m_reporter &amp;&amp; &quot;Listening reporter can wrap only 1 real reporter&quot;);
12999          m_reporter = std::move( reporter );
13000          m_preferences.shouldRedirectStdOut = m_reporter-&gt;getPreferences().shouldRedirectStdOut;
13001      }
13002      ReporterPreferences ListeningReporter::getPreferences() const {
13003          return m_preferences;
13004      }
13005      std::set&lt;Verbosity&gt; ListeningReporter::getSupportedVerbosities() {
13006          return std::set&lt;Verbosity&gt;{ };
13007      }
13008      void ListeningReporter::noMatchingTestCases( std::string const&amp; spec ) {
13009          for ( auto const&amp; listener : m_listeners ) {
13010              listener-&gt;noMatchingTestCases( spec );
13011          }
13012          m_reporter-&gt;noMatchingTestCases( spec );
13013      }
13014      void ListeningReporter::reportInvalidArguments(std::string const&amp;arg){
13015          for ( auto const&amp; listener : m_listeners ) {
13016              listener-&gt;reportInvalidArguments( arg );
13017          }
13018          m_reporter-&gt;reportInvalidArguments( arg );
13019      }
13020  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13021      void ListeningReporter::benchmarkPreparing( std::string const&amp; name ) {
13022  		for (auto const&amp; listener : m_listeners) {
13023  			listener-&gt;benchmarkPreparing(name);
13024  		}
13025  		m_reporter-&gt;benchmarkPreparing(name);
13026  	}
13027      void ListeningReporter::benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) {
13028          for ( auto const&amp; listener : m_listeners ) {
13029              listener-&gt;benchmarkStarting( benchmarkInfo );
13030          }
13031          m_reporter-&gt;benchmarkStarting( benchmarkInfo );
13032      }
13033      void ListeningReporter::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) {
13034          for ( auto const&amp; listener : m_listeners ) {
13035              listener-&gt;benchmarkEnded( benchmarkStats );
13036          }
13037          m_reporter-&gt;benchmarkEnded( benchmarkStats );
13038      }
13039  	void ListeningReporter::benchmarkFailed( std::string const&amp; error ) {
13040  		for (auto const&amp; listener : m_listeners) {
13041  			listener-&gt;benchmarkFailed(error);
13042  		}
13043  		m_reporter-&gt;benchmarkFailed(error);
13044  	}
13045  #endif 
13046      void ListeningReporter::testRunStarting( TestRunInfo const&amp; testRunInfo ) {
13047          for ( auto const&amp; listener : m_listeners ) {
13048              listener-&gt;testRunStarting( testRunInfo );
13049          }
13050          m_reporter-&gt;testRunStarting( testRunInfo );
13051      }
13052      void ListeningReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13053          for ( auto const&amp; listener : m_listeners ) {
13054              listener-&gt;testGroupStarting( groupInfo );
13055          }
13056          m_reporter-&gt;testGroupStarting( groupInfo );
13057      }
13058      void ListeningReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13059          for ( auto const&amp; listener : m_listeners ) {
13060              listener-&gt;testCaseStarting( testInfo );
13061          }
13062          m_reporter-&gt;testCaseStarting( testInfo );
13063      }
13064      void ListeningReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13065          for ( auto const&amp; listener : m_listeners ) {
13066              listener-&gt;sectionStarting( sectionInfo );
13067          }
13068          m_reporter-&gt;sectionStarting( sectionInfo );
13069      }
13070      void ListeningReporter::assertionStarting( AssertionInfo const&amp; assertionInfo ) {
13071          for ( auto const&amp; listener : m_listeners ) {
13072              listener-&gt;assertionStarting( assertionInfo );
13073          }
13074          m_reporter-&gt;assertionStarting( assertionInfo );
13075      }
13076      bool ListeningReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13077          for( auto const&amp; listener : m_listeners ) {
13078              static_cast&lt;void&gt;( listener-&gt;assertionEnded( assertionStats ) );
13079          }
13080          return m_reporter-&gt;assertionEnded( assertionStats );
13081      }
13082      void ListeningReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13083          for ( auto const&amp; listener : m_listeners ) {
13084              listener-&gt;sectionEnded( sectionStats );
13085          }
13086          m_reporter-&gt;sectionEnded( sectionStats );
13087      }
13088      void ListeningReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13089          for ( auto const&amp; listener : m_listeners ) {
13090              listener-&gt;testCaseEnded( testCaseStats );
13091          }
13092          m_reporter-&gt;testCaseEnded( testCaseStats );
13093      }
13094      void ListeningReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13095          for ( auto const&amp; listener : m_listeners ) {
13096              listener-&gt;testGroupEnded( testGroupStats );
13097          }
13098          m_reporter-&gt;testGroupEnded( testGroupStats );
13099      }
13100      void ListeningReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13101          for ( auto const&amp; listener : m_listeners ) {
13102              listener-&gt;testRunEnded( testRunStats );
13103          }
13104          m_reporter-&gt;testRunEnded( testRunStats );
13105      }
13106      void ListeningReporter::skipTest( TestCaseInfo const&amp; testInfo ) {
13107          for ( auto const&amp; listener : m_listeners ) {
13108              listener-&gt;skipTest( testInfo );
13109          }
13110          m_reporter-&gt;skipTest( testInfo );
13111      }
13112      bool ListeningReporter::isMulti() const {
13113          return true;
13114      }
13115  } 
13116  #if defined(_MSC_VER)
13117  #pragma warning(push)
13118  #pragma warning(disable:4061) 
13119  #endif
13120  namespace Catch {
13121      XmlReporter::XmlReporter( ReporterConfig const&amp; _config )
13122      :   StreamingReporterBase( _config ),
13123          m_xml(_config.stream())
13124      {
13125          m_reporterPrefs.shouldRedirectStdOut = true;
13126          m_reporterPrefs.shouldReportAllAssertions = true;
13127      }
13128      XmlReporter::~XmlReporter() = default;
13129      std::string XmlReporter::getDescription() {
13130          return &quot;Reports test results as an XML document&quot;;
13131      }
13132      std::string XmlReporter::getStylesheetRef() const {
13133          return std::string();
13134      }
13135      void XmlReporter::writeSourceInfo( SourceLineInfo const&amp; sourceInfo ) {
13136          m_xml
13137              .writeAttribute( &quot;filename&quot;, sourceInfo.file )
13138              .writeAttribute( &quot;line&quot;, sourceInfo.line );
13139      }
13140      void XmlReporter::noMatchingTestCases( std::string const&amp; s ) {
13141          StreamingReporterBase::noMatchingTestCases( s );
13142      }
13143      void XmlReporter::testRunStarting( TestRunInfo const&amp; testInfo ) {
13144          StreamingReporterBase::testRunStarting( testInfo );
13145          std::string stylesheetRef = getStylesheetRef();
13146          if( !stylesheetRef.empty() )
13147              m_xml.writeStylesheetRef( stylesheetRef );
13148          m_xml.startElement( &quot;Catch&quot; );
13149          if( !m_config-&gt;name().empty() )
13150              m_xml.writeAttribute( &quot;name&quot;, m_config-&gt;name() );
13151          if (m_config-&gt;testSpec().hasFilters())
13152              m_xml.writeAttribute( &quot;filters&quot;, serializeFilters( m_config-&gt;getTestsOrTags() ) );
13153          if( m_config-&gt;rngSeed() != 0 )
13154              m_xml.scopedElement( &quot;Randomness&quot; )
13155                  .writeAttribute( &quot;seed&quot;, m_config-&gt;rngSeed() );
13156      }
13157      void XmlReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13158          StreamingReporterBase::testGroupStarting( groupInfo );
13159          m_xml.startElement( &quot;Group&quot; )
13160              .writeAttribute( &quot;name&quot;, groupInfo.name );
13161      }
13162      void XmlReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13163          StreamingReporterBase::testCaseStarting(testInfo);
13164          m_xml.startElement( &quot;TestCase&quot; )
13165              .writeAttribute( &quot;name&quot;, trim( testInfo.name ) )
13166              .writeAttribute( &quot;description&quot;, testInfo.description )
13167              .writeAttribute( &quot;tags&quot;, testInfo.tagsAsString() );
13168          writeSourceInfo( testInfo.lineInfo );
13169          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13170              m_testCaseTimer.start();
13171          m_xml.ensureTagClosed();
13172      }
13173      void XmlReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13174          StreamingReporterBase::sectionStarting( sectionInfo );
13175          if( m_sectionDepth++ &gt; 0 ) {
13176              m_xml.startElement( &quot;Section&quot; )
13177                  .writeAttribute( &quot;name&quot;, trim( sectionInfo.name ) );
13178              writeSourceInfo( sectionInfo.lineInfo );
13179              m_xml.ensureTagClosed();
13180          }
13181      }
13182      void XmlReporter::assertionStarting( AssertionInfo const&amp; ) { }
13183      bool XmlReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13184          AssertionResult const&amp; result = assertionStats.assertionResult;
13185          bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
13186          if( includeResults || result.getResultType() == ResultWas::Warning ) {
13187              for( auto const&amp; msg : assertionStats.infoMessages ) {
13188                  if( msg.type == ResultWas::Info &amp;&amp; includeResults ) {
13189                      m_xml.scopedElement( &quot;Info&quot; )
13190                              .writeText( msg.message );
13191                  } else if ( msg.type == ResultWas::Warning ) {
13192                      m_xml.scopedElement( &quot;Warning&quot; )
13193                              .writeText( msg.message );
13194                  }
13195              }
13196          }
13197          if( !includeResults &amp;&amp; result.getResultType() != ResultWas::Warning )
13198              return true;
13199          if( result.hasExpression() ) {
13200              m_xml.startElement( &quot;Expression&quot; )
13201                  .writeAttribute( &quot;success&quot;, result.succeeded() )
13202                  .writeAttribute( &quot;type&quot;, result.getTestMacroName() );
13203              writeSourceInfo( result.getSourceInfo() );
13204              m_xml.scopedElement( &quot;Original&quot; )
13205                  .writeText( result.getExpression() );
13206              m_xml.scopedElement( &quot;Expanded&quot; )
13207                  .writeText( result.getExpandedExpression() );
13208          }
13209          switch( result.getResultType() ) {
13210              case ResultWas::ThrewException:
13211                  m_xml.startElement( &quot;Exception&quot; );
13212                  writeSourceInfo( result.getSourceInfo() );
13213                  m_xml.writeText( result.getMessage() );
13214                  m_xml.endElement();
13215                  break;
13216              case ResultWas::FatalErrorCondition:
13217                  m_xml.startElement( &quot;FatalErrorCondition&quot; );
13218                  writeSourceInfo( result.getSourceInfo() );
13219                  m_xml.writeText( result.getMessage() );
13220                  m_xml.endElement();
13221                  break;
13222              case ResultWas::Info:
13223                  m_xml.scopedElement( &quot;Info&quot; )
13224                      .writeText( result.getMessage() );
13225                  break;
13226              case ResultWas::Warning:
13227                  break;
13228              case ResultWas::ExplicitFailure:
13229                  m_xml.startElement( &quot;Failure&quot; );
13230                  writeSourceInfo( result.getSourceInfo() );
13231                  m_xml.writeText( result.getMessage() );
13232                  m_xml.endElement();
13233                  break;
13234              default:
13235                  break;
13236          }
13237          if( result.hasExpression() )
13238              m_xml.endElement();
13239          return true;
13240      }
13241      void XmlReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13242          StreamingReporterBase::sectionEnded( sectionStats );
13243          if( --m_sectionDepth &gt; 0 ) {
13244              XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResults&quot; );
13245              e.writeAttribute( &quot;successes&quot;, sectionStats.assertions.passed );
13246              e.writeAttribute( &quot;failures&quot;, sectionStats.assertions.failed );
13247              e.writeAttribute( &quot;expectedFailures&quot;, sectionStats.assertions.failedButOk );
13248              if ( m_config-&gt;showDurations() == ShowDurations::Always )
13249                  e.writeAttribute( &quot;durationInSeconds&quot;, sectionStats.durationInSeconds );
13250              m_xml.endElement();
13251          }
13252      }
13253      void XmlReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13254          StreamingReporterBase::testCaseEnded( testCaseStats );
13255          XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResult&quot; );
13256          e.writeAttribute( &quot;success&quot;, testCaseStats.totals.assertions.allOk() );
13257          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13258              e.writeAttribute( &quot;durationInSeconds&quot;, m_testCaseTimer.getElapsedSeconds() );
13259          if( !testCaseStats.stdOut.empty() )
13260              m_xml.scopedElement( &quot;StdOut&quot; ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
13261          if( !testCaseStats.stdErr.empty() )
13262              m_xml.scopedElement( &quot;StdErr&quot; ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );
13263          m_xml.endElement();
13264      }
13265      void XmlReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13266          StreamingReporterBase::testGroupEnded( testGroupStats );
13267          m_xml.scopedElement( &quot;OverallResults&quot; )
13268              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.assertions.passed )
13269              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.assertions.failed )
13270              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.assertions.failedButOk );
13271          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13272              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.testCases.passed )
13273              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.testCases.failed )
13274              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.testCases.failedButOk );
13275          m_xml.endElement();
13276      }
13277      void XmlReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13278          StreamingReporterBase::testRunEnded( testRunStats );
13279          m_xml.scopedElement( &quot;OverallResults&quot; )
13280              .writeAttribute( &quot;successes&quot;, testRunStats.totals.assertions.passed )
13281              .writeAttribute( &quot;failures&quot;, testRunStats.totals.assertions.failed )
13282              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.assertions.failedButOk );
13283          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13284              .writeAttribute( &quot;successes&quot;, testRunStats.totals.testCases.passed )
13285              .writeAttribute( &quot;failures&quot;, testRunStats.totals.testCases.failed )
13286              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.testCases.failedButOk );
13287          m_xml.endElement();
13288      }
13289  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13290      void XmlReporter::benchmarkPreparing(std::string const&amp; name) {
13291          m_xml.startElement(&quot;BenchmarkResults&quot;)
13292              .writeAttribute(&quot;name&quot;, name);
13293      }
13294      void XmlReporter::benchmarkStarting(BenchmarkInfo const &amp;info) {
13295          m_xml.writeAttribute(&quot;samples&quot;, info.samples)
13296              .writeAttribute(&quot;resamples&quot;, info.resamples)
13297              .writeAttribute(&quot;iterations&quot;, info.iterations)
13298              .writeAttribute(&quot;clockResolution&quot;, info.clockResolution)
13299              .writeAttribute(&quot;estimatedDuration&quot;, info.estimatedDuration)
13300              .writeComment(&quot;All values in nano seconds&quot;);
13301      }
13302      void XmlReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; benchmarkStats) {
13303          m_xml.startElement(&quot;mean&quot;)
13304              .writeAttribute(&quot;value&quot;, benchmarkStats.mean.point.count())
13305              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.mean.lower_bound.count())
13306              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.mean.upper_bound.count())
13307              .writeAttribute(&quot;ci&quot;, benchmarkStats.mean.confidence_interval);
13308          m_xml.endElement();
13309          m_xml.startElement(&quot;standardDeviation&quot;)
13310              .writeAttribute(&quot;value&quot;, benchmarkStats.standardDeviation.point.count())
13311              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.standardDeviation.lower_bound.count())
13312              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.standardDeviation.upper_bound.count())
13313              .writeAttribute(&quot;ci&quot;, benchmarkStats.standardDeviation.confidence_interval);
13314          m_xml.endElement();
13315          m_xml.startElement(&quot;outliers&quot;)
13316              .writeAttribute(&quot;variance&quot;, benchmarkStats.outlierVariance)
13317              .writeAttribute(&quot;lowMild&quot;, benchmarkStats.outliers.low_mild)
13318              .writeAttribute(&quot;lowSevere&quot;, benchmarkStats.outliers.low_severe)
13319              .writeAttribute(&quot;highMild&quot;, benchmarkStats.outliers.high_mild)
13320              .writeAttribute(&quot;highSevere&quot;, benchmarkStats.outliers.high_severe);
13321          m_xml.endElement();
13322          m_xml.endElement();
13323      }
13324      void XmlReporter::benchmarkFailed(std::string const &amp;error) {
13325          m_xml.scopedElement(&quot;failed&quot;).
13326              writeAttribute(&quot;message&quot;, error);
13327          m_xml.endElement();
13328      }
13329  #endif 
13330      CATCH_REGISTER_REPORTER( &quot;xml&quot;, XmlReporter )
13331  } 
13332  #if defined(_MSC_VER)
13333  #pragma warning(pop)
13334  #endif
13335  namespace Catch {
13336      LeakDetector leakDetector;
13337  }
13338  #ifdef __clang__
13339  #pragma clang diagnostic pop
13340  #endif
13341  #endif
13342  #ifdef CATCH_CONFIG_MAIN
13343  #ifndef __OBJC__
13344  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; defined(_UNICODE) &amp;&amp; !defined(DO_NOT_USE_WMAIN)
13345  extern &quot;C&quot; int wmain (int argc, wchar_t * argv[], wchar_t * []) {
13346  #else
13347  int main (int argc, char * argv[]) {
13348  #endif
13349      return Catch::Session().run( argc, argv );
13350  }
13351  #else 
13352  int main (int argc, char * const argv[]) {
13353  #if !CATCH_ARC_ENABLED
13354      NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
13355  #endif
13356      Catch::registerTestMethods();
13357      int result = Catch::Session().run( argc, (char**)argv );
13358  #if !CATCH_ARC_ENABLED
13359      [pool drain];
13360  #endif
13361      return result;
13362  }
13363  #endif 
13364  #endif
13365  #if !defined(CATCH_CONFIG_IMPL_ONLY)
13366  #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
13367  #  undef CLARA_CONFIG_MAIN
13368  #endif
13369  #if !defined(CATCH_CONFIG_DISABLE)
13370  #ifdef CATCH_CONFIG_PREFIX_ALL
13371  #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13372  #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13373  #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;CATCH_REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13374  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13375  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13376  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13377  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13378  #endif
13379  #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13380  #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13381  #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13382  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CATCH_CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13383  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CATCH_CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13384  #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13385  #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CATCH_CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13386  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13387  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13388  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13389  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13390  #endif 
13391  #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13392  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13393  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13394  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13395  #endif 
13396  #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( &quot;CATCH_INFO&quot;, msg )
13397  #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;CATCH_UNSCOPED_INFO&quot;, msg )
13398  #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( &quot;CATCH_WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13399  #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CATCH_CAPTURE&quot;,__VA_ARGS__ )
13400  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13401  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13402  #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13403  #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13404  #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13405  #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13406  #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13407  #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13408  #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13409  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13410  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13411  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13412  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13413  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13414  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13415  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13416  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13417  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13418  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13419  #else
13420  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13421  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13422  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13423  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13424  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13425  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13426  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13427  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13428  #endif
13429  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13430  #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
13431  #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); CATCH_SUCCEED( #__VA_ARGS__ )
13432  #else
13433  #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
13434  #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
13435  #endif
13436  #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13437  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13438  #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13439  #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13440  #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13441  #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13442  #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13443  #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13444  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13445  #define CATCH_BENCHMARK(...) \
13446      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13447  #define CATCH_BENCHMARK_ADVANCED(name) \
13448      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13449  #endif 
13450  #else
13451  #define REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__  )
13452  #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13453  #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13454  #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13455  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13456  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13457  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13458  #endif 
13459  #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13460  #define CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13461  #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13462  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13463  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13464  #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13465  #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13466  #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13467  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13468  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13469  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13470  #endif 
13471  #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13472  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13473  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13474  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13475  #endif 
13476  #define INFO( msg ) INTERNAL_CATCH_INFO( &quot;INFO&quot;, msg )
13477  #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;UNSCOPED_INFO&quot;, msg )
13478  #define WARN( msg ) INTERNAL_CATCH_MSG( &quot;WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13479  #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CAPTURE&quot;,__VA_ARGS__ )
13480  #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13481  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13482  #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13483  #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13484  #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13485  #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13486  #define FAIL( ... ) INTERNAL_CATCH_MSG( &quot;FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13487  #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13488  #define SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13489  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13490  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13491  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13492  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13493  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13494  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13495  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13496  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13497  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13498  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13499  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
13500  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
13501  #else
13502  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13503  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13504  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13505  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13506  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13507  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13508  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13509  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13510  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
13511  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13512  #endif
13513  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13514  #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
13515  #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); SUCCEED( &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; )
13516  #else
13517  #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
13518  #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
13519  #endif
13520  #endif
13521  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
13522  #define SCENARIO( ... ) TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13523  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13524  #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13525  #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13526  #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13527  #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13528  #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13529  #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13530  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13531  #define BENCHMARK(...) \
13532      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13533  #define BENCHMARK_ADVANCED(name) \
13534      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13535  #endif 
13536  using Catch::Detail::Approx;
13537  #else 
13538  #ifdef CATCH_CONFIG_PREFIX_ALL
13539  #define CATCH_REQUIRE( ... )        (void)(0)
13540  #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
13541  #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
13542  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13543  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
13544  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13545  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13546  #endif
13547  #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
13548  #define CATCH_CHECK( ... )         (void)(0)
13549  #define CATCH_CHECK_FALSE( ... )   (void)(0)
13550  #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
13551  #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
13552  #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
13553  #define CATCH_CHECK_THROWS( ... )  (void)(0)
13554  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13555  #define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
13556  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13557  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13558  #endif 
13559  #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
13560  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13561  #define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
13562  #define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
13563  #endif 
13564  #define CATCH_INFO( msg )          (void)(0)
13565  #define CATCH_UNSCOPED_INFO( msg ) (void)(0)
13566  #define CATCH_WARN( msg )          (void)(0)
13567  #define CATCH_CAPTURE( msg )       (void)(0)
13568  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13569  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13570  #define CATCH_METHOD_AS_TEST_CASE( method, ... )
13571  #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
13572  #define CATCH_SECTION( ... )
13573  #define CATCH_DYNAMIC_SECTION( ... )
13574  #define CATCH_FAIL( ... ) (void)(0)
13575  #define CATCH_FAIL_CHECK( ... ) (void)(0)
13576  #define CATCH_SUCCEED( ... ) (void)(0)
13577  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13578  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13579  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13580  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13581  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13582  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13583  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13584  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13585  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13586  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13587  #else
13588  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13589  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13590  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13591  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13592  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13593  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13594  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13595  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13596  #endif
13597  #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13598  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13599  #define CATCH_GIVEN( desc )
13600  #define CATCH_AND_GIVEN( desc )
13601  #define CATCH_WHEN( desc )
13602  #define CATCH_AND_WHEN( desc )
13603  #define CATCH_THEN( desc )
13604  #define CATCH_AND_THEN( desc )
13605  #define CATCH_STATIC_REQUIRE( ... )       (void)(0)
13606  #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
13607  #else
13608  #define REQUIRE( ... )       (void)(0)
13609  #define REQUIRE_FALSE( ... ) (void)(0)
13610  #define REQUIRE_THROWS( ... ) (void)(0)
13611  #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13612  #define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
13613  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13614  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13615  #endif 
13616  #define REQUIRE_NOTHROW( ... ) (void)(0)
13617  #define CHECK( ... ) (void)(0)
13618  #define CHECK_FALSE( ... ) (void)(0)
13619  #define CHECKED_IF( ... ) if (__VA_ARGS__)
13620  #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
13621  #define CHECK_NOFAIL( ... ) (void)(0)
13622  #define CHECK_THROWS( ... )  (void)(0)
13623  #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13624  #define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
13625  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13626  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13627  #endif 
13628  #define CHECK_NOTHROW( ... ) (void)(0)
13629  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13630  #define CHECK_THAT( arg, matcher ) (void)(0)
13631  #define REQUIRE_THAT( arg, matcher ) (void)(0)
13632  #endif 
13633  #define INFO( msg ) (void)(0)
13634  #define UNSCOPED_INFO( msg ) (void)(0)
13635  #define WARN( msg ) (void)(0)
13636  #define CAPTURE( msg ) (void)(0)
13637  #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13638  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13639  #define METHOD_AS_TEST_CASE( method, ... )
13640  #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
13641  #define SECTION( ... )
13642  #define DYNAMIC_SECTION( ... )
13643  #define FAIL( ... ) (void)(0)
13644  #define FAIL_CHECK( ... ) (void)(0)
13645  #define SUCCEED( ... ) (void)(0)
13646  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13647  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13648  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13649  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13650  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13651  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13652  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13653  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13654  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13655  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13656  #else
13657  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13658  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13659  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13660  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13661  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13662  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13663  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13664  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13665  #endif
13666  #define STATIC_REQUIRE( ... )       (void)(0)
13667  #define STATIC_REQUIRE_FALSE( ... ) (void)(0)
13668  #endif
13669  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
13670  #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
13671  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13672  #define GIVEN( desc )
13673  #define AND_GIVEN( desc )
13674  #define WHEN( desc )
13675  #define AND_WHEN( desc )
13676  #define THEN( desc )
13677  #define AND_THEN( desc )
13678  using Catch::Detail::Approx;
13679  #endif
13680  #endif 
13681  #ifdef __clang__
13682  #    ifdef __ICC 
13683  #        pragma warning(pop)
13684  #    else
13685  #        pragma clang diagnostic pop
13686  #    endif
13687  #elif defined __GNUC__
13688  #    pragma GCC diagnostic pop
13689  #endif
13690  #endif 
</pre></code></div>
                <div class="column column_space"><pre><code>6339  					m_len = len;
6340  				} else {
6341  					m_suffix = true;
6342  					m_len = width - 1;
6343  				}
6344  			}
6345  		}
6346  		auto indent() const -&gt; size_t {
6347  			auto initial = m_pos == 0 &amp;&amp; m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
6348  			return initial == std::string::npos ? m_column.m_indent : initial;
6349  		}
6350  		auto addIndentAndSuffix(std::string const &amp;plain) const -&gt; std::string {
6351  			return std::string(indent(), &#x27; &#x27;) + (m_suffix ? plain + &quot;-&quot; : plain);
6352  		}
6353  	public:
6354  		using difference_type = std::ptrdiff_t;
6355  		using value_type = std::string;
6356  		using pointer = value_type * ;
6357  		using reference = value_type &amp; ;
6358  		using iterator_category = std::forward_iterator_tag;
6359  		explicit iterator(Column const&amp; column) : m_column(column) {
6360  			assert(m_column.m_width &gt; m_column.m_indent);
6361  			assert(m_column.m_initialIndent == std::string::npos || m_column.m_width &gt; m_column.m_initialIndent);
6362  			calcLength();
6363  			if (m_len == 0)
6364  				m_stringIndex++; 
6365  		}
6366  		auto operator *() const -&gt; std::string {
6367  			assert(m_stringIndex &lt; m_column.m_strings.size());
6368  			assert(m_pos &lt;= m_end);
6369  			return addIndentAndSuffix(line().substr(m_pos, m_len));
6370  		}
6371  		auto operator ++() -&gt; iterator&amp; {
6372  			m_pos += m_len;
6373  			if (m_pos &lt; line().size() &amp;&amp; line()[m_pos] == &#x27;\n&#x27;)
6374  				m_pos += 1;
6375  			else
6376  				while (m_pos &lt; line().size() &amp;&amp; isWhitespace(line()[m_pos]))
6377  					++m_pos;
6378  			if (m_pos == line().size()) {
6379  				m_pos = 0;
6380  				++m_stringIndex;
6381  			}
6382  			if (m_stringIndex &lt; m_column.m_strings.size())
6383  				calcLength();
6384  			return *this;
6385  		}
6386  		auto operator ++(int) -&gt; iterator {
6387  			iterator prev(*this);
6388  			operator++();
6389  			return prev;
6390  		}
6391  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6392  			return
6393  				m_pos == other.m_pos &amp;&amp;
6394  				m_stringIndex == other.m_stringIndex &amp;&amp;
6395  				&amp;m_column == &amp;other.m_column;
6396  		}
6397  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6398  			return !operator==(other);
6399  		}
6400  	};
6401  	using const_iterator = iterator;
6402  	explicit Column(std::string const&amp; text) { m_strings.push_back(text); }
6403  	auto width(size_t newWidth) -&gt; Column&amp; {
6404  		assert(newWidth &gt; 0);
6405  		m_width = newWidth;
6406  		return *this;
6407  	}
6408  	auto indent(size_t newIndent) -&gt; Column&amp; {
6409  		m_indent = newIndent;
6410  		return *this;
6411  	}
6412  	auto initialIndent(size_t newIndent) -&gt; Column&amp; {
6413  		m_initialIndent = newIndent;
6414  		return *this;
6415  	}
6416  	auto width() const -&gt; size_t { return m_width; }
6417  	auto begin() const -&gt; iterator { return iterator(*this); }
6418  	auto end() const -&gt; iterator { return { *this, m_strings.size() }; }
6419  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Column const&amp; col) {
6420  		bool first = true;
6421  		for (auto line : col) {
6422  			if (first)
6423  				first = false;
6424  			else
6425  				os &lt;&lt; &quot;\n&quot;;
6426  			os &lt;&lt; line;
6427  		}
6428  		return os;
6429  	}
6430  	auto operator + (Column const&amp; other)-&gt;Columns;
6431  	auto toString() const -&gt; std::string {
6432  		std::ostringstream oss;
6433  		oss &lt;&lt; *this;
6434  		return oss.str();
6435  	}
6436  };
6437  class Spacer : public Column {
6438  public:
6439  	explicit Spacer(size_t spaceWidth) : Column(&quot;&quot;) {
6440  		width(spaceWidth);
6441  	}
6442  };
6443  class Columns {
6444  	std::vector&lt;Column&gt; m_columns;
6445  public:
6446  	class iterator {
6447  		friend Columns;
6448  		struct EndTag {};
6449  		std::vector&lt;Column&gt; const&amp; m_columns;
6450  		std::vector&lt;Column::iterator&gt; m_iterators;
6451  		size_t m_activeIterators;
6452  		iterator(Columns const&amp; columns, EndTag)
6453  			: m_columns(columns.m_columns),
6454  			m_activeIterators(0) {
6455  			m_iterators.reserve(m_columns.size());
6456  			for (auto const&amp; col : m_columns)
6457  				m_iterators.push_back(col.end());
6458  		}
6459  	public:
6460  		using difference_type = std::ptrdiff_t;
6461  		using value_type = std::string;
6462  		using pointer = value_type * ;
6463  		using reference = value_type &amp; ;
6464  		using iterator_category = std::forward_iterator_tag;
6465  		explicit iterator(Columns const&amp; columns)
6466  			: m_columns(columns.m_columns),
6467  			m_activeIterators(m_columns.size()) {
6468  			m_iterators.reserve(m_columns.size());
6469  			for (auto const&amp; col : m_columns)
6470  				m_iterators.push_back(col.begin());
6471  		}
6472  		auto operator ==(iterator const&amp; other) const -&gt; bool {
6473  			return m_iterators == other.m_iterators;
6474  		}
6475  		auto operator !=(iterator const&amp; other) const -&gt; bool {
6476  			return m_iterators != other.m_iterators;
6477  		}
6478  		auto operator *() const -&gt; std::string {
6479  			std::string row, padding;
6480  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6481  				auto width = m_columns[i].width();
6482  				if (m_iterators[i] != m_columns[i].end()) {
6483  					std::string col = *m_iterators[i];
6484  					row += padding + col;
6485  					if (col.size() &lt; width)
6486  						padding = std::string(width - col.size(), &#x27; &#x27;);
6487  					else
6488  						padding = &quot;&quot;;
6489  				} else {
6490  					padding += std::string(width, &#x27; &#x27;);
6491  				}
6492  			}
6493  			return row;
6494  		}
6495  		auto operator ++() -&gt; iterator&amp; {
6496  			for (size_t i = 0; i &lt; m_columns.size(); ++i) {
6497  				if (m_iterators[i] != m_columns[i].end())
6498  					++m_iterators[i];
6499  			}
6500  			return *this;
6501  		}
6502  		auto operator ++(int) -&gt; iterator {
6503  			iterator prev(*this);
6504  			operator++();
6505  			return prev;
6506  		}
6507  	};
6508  	using const_iterator = iterator;
6509  	auto begin() const -&gt; iterator { return iterator(*this); }
6510  	auto end() const -&gt; iterator { return { *this, iterator::EndTag() }; }
6511  	auto operator += (Column const&amp; col) -&gt; Columns&amp; {
6512  		m_columns.push_back(col);
6513  		return *this;
6514  	}
6515  	auto operator + (Column const&amp; col) -&gt; Columns {
6516  		Columns combined = *this;
6517  		combined += col;
6518  		return combined;
6519  	}
6520  	inline friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, Columns const&amp; cols) {
6521  		bool first = true;
6522  		for (auto line : cols) {
6523  			if (first)
6524  				first = false;
6525  			else
6526  				os &lt;&lt; &quot;\n&quot;;
6527  			os &lt;&lt; line;
6528  		}
6529  		return os;
6530  	}
6531  	auto toString() const -&gt; std::string {
6532  		std::ostringstream oss;
6533  		oss &lt;&lt; *this;
6534  		return oss.str();
6535  	}
6536  };
6537  inline auto Column::operator + (Column const&amp; other) -&gt; Columns {
6538  	Columns cols;
6539  	cols += *this;
6540  	cols += other;
6541  	return cols;
6542  }
6543  }
6544  }
6545  }
6546  #include &lt;cctype&gt;
6547  #include &lt;string&gt;
6548  #include &lt;memory&gt;
6549  #include &lt;set&gt;
6550  #include &lt;algorithm&gt;
6551  #if !defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
6552  #define CATCH_PLATFORM_WINDOWS
6553  #endif
6554  namespace Catch { namespace clara {
6555  namespace detail {
6556      template&lt;typename L&gt;
6557      struct UnaryLambdaTraits : UnaryLambdaTraits&lt;decltype( &amp;L::operator() )&gt; {};
6558      template&lt;typename ClassT, typename ReturnT, typename... Args&gt;
6559      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( Args... ) const&gt; {
6560          static const bool isValid = false;
6561      };
6562      template&lt;typename ClassT, typename ReturnT, typename ArgT&gt;
6563      struct UnaryLambdaTraits&lt;ReturnT( ClassT::* )( ArgT ) const&gt; {
6564          static const bool isValid = true;
6565          using ArgType = typename std::remove_const&lt;typename std::remove_reference&lt;ArgT&gt;::type&gt;::type;
6566          using ReturnType = ReturnT;
6567      };
6568      class TokenStream;
6569      class Args {
6570          friend TokenStream;
6571          std::string m_exeName;
6572          std::vector&lt;std::string&gt; m_args;
6573      public:
6574          Args( int argc, char const* const* argv )
6575              : m_exeName(argv[0]),
6576                m_args(argv + 1, argv + argc) {}
6577          Args( std::initializer_list&lt;std::string&gt; args )
6578          :   m_exeName( *args.begin() ),
6579              m_args( args.begin()+1, args.end() )
6580          {}
6581          auto exeName() const -&gt; std::string {
6582              return m_exeName;
6583          }
6584      };
6585      enum class TokenType {
6586          Option, Argument
6587      };
6588      struct Token {
6589          TokenType type;
6590          std::string token;
6591      };
6592      inline auto isOptPrefix( char c ) -&gt; bool {
6593          return c == &#x27;-&#x27;
6594  #ifdef CATCH_PLATFORM_WINDOWS
6595              || c == &#x27;/&#x27;
6596  #endif
6597          ;
6598      }
6599      class TokenStream {
6600          using Iterator = std::vector&lt;std::string&gt;::const_iterator;
6601          Iterator it;
6602          Iterator itEnd;
6603          std::vector&lt;Token&gt; m_tokenBuffer;
6604          void loadBuffer() {
6605              m_tokenBuffer.resize( 0 );
6606              while( it != itEnd &amp;&amp; it-&gt;empty() )
6607                  ++it;
6608              if( it != itEnd ) {
6609                  auto const &amp;next = *it;
6610                  if( isOptPrefix( next[0] ) ) {
6611                      auto delimiterPos = next.find_first_of( &quot; :=&quot; );
6612                      if( delimiterPos != std::string::npos ) {
6613                          m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
6614                          m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
6615                      } else {
6616                          if( next[1] != &#x27;-&#x27; &amp;&amp; next.size() &gt; 2 ) {
6617                              std::string opt = &quot;- &quot;;
6618                              for( size_t i = 1; i &lt; next.size(); ++i ) {
6619                                  opt[1] = next[i];
6620                                  m_tokenBuffer.push_back( { TokenType::Option, opt } );
6621                              }
6622                          } else {
6623                              m_tokenBuffer.push_back( { TokenType::Option, next } );
6624                          }
6625                      }
6626                  } else {
6627                      m_tokenBuffer.push_back( { TokenType::Argument, next } );
6628                  }
6629              }
6630          }
6631      public:
6632          explicit TokenStream( Args const &amp;args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
6633          TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
6634              loadBuffer();
6635          }
6636          explicit operator bool() const {
6637              return !m_tokenBuffer.empty() || it != itEnd;
6638          }
6639          auto count() const -&gt; size_t { return m_tokenBuffer.size() + (itEnd - it); }
6640          auto operator*() const -&gt; Token {
6641              assert( !m_tokenBuffer.empty() );
6642              return m_tokenBuffer.front();
6643          }
6644          auto operator-&gt;() const -&gt; Token const * {
6645              assert( !m_tokenBuffer.empty() );
6646              return &amp;m_tokenBuffer.front();
6647          }
6648          auto operator++() -&gt; TokenStream &amp; {
6649              if( m_tokenBuffer.size() &gt;= 2 ) {
6650                  m_tokenBuffer.erase( m_tokenBuffer.begin() );
6651              } else {
6652                  if( it != itEnd )
6653                      ++it;
6654                  loadBuffer();
6655              }
6656              return *this;
6657          }
6658      };
6659      class ResultBase {
6660      public:
6661          enum Type {
6662              Ok, LogicError, RuntimeError
6663          };
6664      protected:
6665          ResultBase( Type type ) : m_type( type ) {}
6666          virtual ~ResultBase() = default;
6667          virtual void enforceOk() const = 0;
6668          Type m_type;
6669      };
6670      template&lt;typename T&gt;
6671      class ResultValueBase : public ResultBase {
6672      public:
6673          auto value() const -&gt; T const &amp; {
6674              enforceOk();
6675              return m_value;
6676          }
6677      protected:
6678          ResultValueBase( Type type ) : ResultBase( type ) {}
6679          ResultValueBase( ResultValueBase const &amp;other ) : ResultBase( other ) {
6680              if( m_type == ResultBase::Ok )
6681                  new( &amp;m_value ) T( other.m_value );
6682          }
6683          ResultValueBase( Type, T const &amp;value ) : ResultBase( Ok ) {
6684              new( &amp;m_value ) T( value );
6685          }
6686          auto operator=( ResultValueBase const &amp;other ) -&gt; ResultValueBase &amp; {
6687              if( m_type == ResultBase::Ok )
6688                  m_value.~T();
6689              ResultBase::operator=(other);
6690              if( m_type == ResultBase::Ok )
6691                  new( &amp;m_value ) T( other.m_value );
6692              return *this;
6693          }
6694          ~ResultValueBase() override {
6695              if( m_type == Ok )
6696                  m_value.~T();
6697          }
6698          union {
6699              T m_value;
6700          };
6701      };
6702      template&lt;&gt;
6703      class ResultValueBase&lt;void&gt; : public ResultBase {
6704      protected:
6705          using ResultBase::ResultBase;
6706      };
6707      template&lt;typename T = void&gt;
6708      class BasicResult : public ResultValueBase&lt;T&gt; {
6709      public:
6710          template&lt;typename U&gt;
6711          explicit BasicResult( BasicResult&lt;U&gt; const &amp;other )
6712          :   ResultValueBase&lt;T&gt;( other.type() ),
6713              m_errorMessage( other.errorMessage() )
6714          {
6715              assert( type() != ResultBase::Ok );
6716          }
6717          template&lt;typename U&gt;
6718          static auto ok( U const &amp;value ) -&gt; BasicResult { return { ResultBase::Ok, value }; }
6719          static auto ok() -&gt; BasicResult { return { ResultBase::Ok }; }
6720          static auto logicError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::LogicError, message }; }
6721          static auto runtimeError( std::string const &amp;message ) -&gt; BasicResult { return { ResultBase::RuntimeError, message }; }
6722          explicit operator bool() const { return m_type == ResultBase::Ok; }
6723          auto type() const -&gt; ResultBase::Type { return m_type; }
6724          auto errorMessage() const -&gt; std::string { return m_errorMessage; }
6725      protected:
6726          void enforceOk() const override {
6727              assert( m_type != ResultBase::LogicError );
6728              assert( m_type != ResultBase::RuntimeError );
6729              if( m_type != ResultBase::Ok )
6730                  std::abort();
6731          }
6732          std::string m_errorMessage; 
6733          BasicResult( ResultBase::Type type, std::string const &amp;message )
6734          :   ResultValueBase&lt;T&gt;(type),
6735              m_errorMessage(message)
6736          {
6737              assert( m_type != ResultBase::Ok );
6738          }
6739          using ResultValueBase&lt;T&gt;::ResultValueBase;
6740          using ResultBase::m_type;
6741      };
6742      enum class ParseResultType {
6743          Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
6744      };
6745      class ParseState {
6746      public:
6747          ParseState( ParseResultType type, TokenStream const &amp;remainingTokens )
6748          : m_type(type),
6749            m_remainingTokens( remainingTokens )
6750          {}
6751          auto type() const -&gt; ParseResultType { return m_type; }
6752          auto remainingTokens() const -&gt; TokenStream { return m_remainingTokens; }
6753      private:
6754          ParseResultType m_type;
6755          TokenStream m_remainingTokens;
6756      };
6757      using Result = BasicResult&lt;void&gt;;
6758      using ParserResult = BasicResult&lt;ParseResultType&gt;;
6759      using InternalParseResult = BasicResult&lt;ParseState&gt;;
6760      struct HelpColumns {
6761          std::string left;
6762          std::string right;
6763      };
6764      template&lt;typename T&gt;
6765      inline auto convertInto( std::string const &amp;source, T&amp; target ) -&gt; ParserResult {
6766          std::stringstream ss;
6767          ss &lt;&lt; source;
6768          ss &gt;&gt; target;
6769          if( ss.fail() )
6770              return ParserResult::runtimeError( &quot;Unable to convert &#x27;&quot; + source + &quot;&#x27; to destination type&quot; );
6771          else
6772              return ParserResult::ok( ParseResultType::Matched );
6773      }
6774      inline auto convertInto( std::string const &amp;source, std::string&amp; target ) -&gt; ParserResult {
6775          target = source;
6776          return ParserResult::ok( ParseResultType::Matched );
6777      }
6778      inline auto convertInto( std::string const &amp;source, bool &amp;target ) -&gt; ParserResult {
6779          std::string srcLC = source;
6780          std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( unsigned char c ) { return static_cast&lt;char&gt;( std::tolower(c) ); } );
6781          if (srcLC == &quot;y&quot; || srcLC == &quot;1&quot; || srcLC == &quot;true&quot; || srcLC == &quot;yes&quot; || srcLC == &quot;on&quot;)
6782              target = true;
6783          else if (srcLC == &quot;n&quot; || srcLC == &quot;0&quot; || srcLC == &quot;false&quot; || srcLC == &quot;no&quot; || srcLC == &quot;off&quot;)
6784              target = false;
6785          else
6786              return ParserResult::runtimeError( &quot;Expected a boolean value but did not recognise: &#x27;&quot; + source + &quot;&#x27;&quot; );
6787          return ParserResult::ok( ParseResultType::Matched );
6788      }
6789  #ifdef CLARA_CONFIG_OPTIONAL_TYPE
6790      template&lt;typename T&gt;
6791      inline auto convertInto( std::string const &amp;source, CLARA_CONFIG_OPTIONAL_TYPE&lt;T&gt;&amp; target ) -&gt; ParserResult {
6792          T temp;
6793          auto result = convertInto( source, temp );
6794          if( result )
6795              target = std::move(temp);
6796          return result;
6797      }
6798  #endif 
6799      struct NonCopyable {
6800          NonCopyable() = default;
6801          NonCopyable( NonCopyable const &amp; ) = delete;
6802          NonCopyable( NonCopyable &amp;&amp; ) = delete;
6803          NonCopyable &amp;operator=( NonCopyable const &amp; ) = delete;
6804          NonCopyable &amp;operator=( NonCopyable &amp;&amp; ) = delete;
6805      };
6806      struct BoundRef : NonCopyable {
6807          virtual ~BoundRef() = default;
6808          virtual auto isContainer() const -&gt; bool { return false; }
6809          virtual auto isFlag() const -&gt; bool { return false; }
6810      };
6811      struct BoundValueRefBase : BoundRef {
6812          virtual auto setValue( std::string const &amp;arg ) -&gt; ParserResult = 0;
6813      };
6814      struct BoundFlagRefBase : BoundRef {
6815          virtual auto setFlag( bool flag ) -&gt; ParserResult = 0;
6816          virtual auto isFlag() const -&gt; bool { return true; }
6817      };
6818      template&lt;typename T&gt;
6819      struct BoundValueRef : BoundValueRefBase {
6820          T &amp;m_ref;
6821          explicit BoundValueRef( T &amp;ref ) : m_ref( ref ) {}
6822          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6823              return convertInto( arg, m_ref );
6824          }
6825      };
6826      template&lt;typename T&gt;
6827      struct BoundValueRef&lt;std::vector&lt;T&gt;&gt; : BoundValueRefBase {
6828          std::vector&lt;T&gt; &amp;m_ref;
6829          explicit BoundValueRef( std::vector&lt;T&gt; &amp;ref ) : m_ref( ref ) {}
6830          auto isContainer() const -&gt; bool override { return true; }
6831          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6832              T temp;
6833              auto result = convertInto( arg, temp );
6834              if( result )
6835                  m_ref.push_back( temp );
6836              return result;
6837          }
6838      };
6839      struct BoundFlagRef : BoundFlagRefBase {
6840          bool &amp;m_ref;
6841          explicit BoundFlagRef( bool &amp;ref ) : m_ref( ref ) {}
6842          auto setFlag( bool flag ) -&gt; ParserResult override {
6843              m_ref = flag;
6844              return ParserResult::ok( ParseResultType::Matched );
6845          }
6846      };
6847      template&lt;typename ReturnType&gt;
6848      struct LambdaInvoker {
6849          static_assert( std::is_same&lt;ReturnType, ParserResult&gt;::value, &quot;Lambda must return void or clara::ParserResult&quot; );
6850          template&lt;typename L, typename ArgType&gt;
6851          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6852              return lambda( arg );
6853          }
6854      };
6855      template&lt;&gt;
6856      struct LambdaInvoker&lt;void&gt; {
6857          template&lt;typename L, typename ArgType&gt;
6858          static auto invoke( L const &amp;lambda, ArgType const &amp;arg ) -&gt; ParserResult {
6859              lambda( arg );
6860              return ParserResult::ok( ParseResultType::Matched );
6861          }
6862      };
6863      template&lt;typename ArgType, typename L&gt;
6864      inline auto invokeLambda( L const &amp;lambda, std::string const &amp;arg ) -&gt; ParserResult {
6865          ArgType temp{};
6866          auto result = convertInto( arg, temp );
6867          return !result
6868             ? result
6869             : LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( lambda, temp );
6870      }
6871      template&lt;typename L&gt;
6872      struct BoundLambda : BoundValueRefBase {
6873          L m_lambda;
6874          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6875          explicit BoundLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6876          auto setValue( std::string const &amp;arg ) -&gt; ParserResult override {
6877              return invokeLambda&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType&gt;( m_lambda, arg );
6878          }
6879      };
6880      template&lt;typename L&gt;
6881      struct BoundFlagLambda : BoundFlagRefBase {
6882          L m_lambda;
6883          static_assert( UnaryLambdaTraits&lt;L&gt;::isValid, &quot;Supplied lambda must take exactly one argument&quot; );
6884          static_assert( std::is_same&lt;typename UnaryLambdaTraits&lt;L&gt;::ArgType, bool&gt;::value, &quot;flags must be boolean&quot; );
6885          explicit BoundFlagLambda( L const &amp;lambda ) : m_lambda( lambda ) {}
6886          auto setFlag( bool flag ) -&gt; ParserResult override {
6887              return LambdaInvoker&lt;typename UnaryLambdaTraits&lt;L&gt;::ReturnType&gt;::invoke( m_lambda, flag );
6888          }
6889      };
6890      enum class Optionality { Optional, Required };
6891      struct Parser;
6892      class ParserBase {
6893      public:
6894          virtual ~ParserBase() = default;
6895          virtual auto validate() const -&gt; Result { return Result::ok(); }
6896          virtual auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens) const -&gt; InternalParseResult  = 0;
6897          virtual auto cardinality() const -&gt; size_t { return 1; }
6898          auto parse( Args const &amp;args ) const -&gt; InternalParseResult {
6899              return parse( args.exeName(), TokenStream( args ) );
6900          }
6901      };
6902      template&lt;typename DerivedT&gt;
6903      class ComposableParserImpl : public ParserBase {
6904      public:
6905          template&lt;typename T&gt;
6906          auto operator|( T const &amp;other ) const -&gt; Parser;
6907  		template&lt;typename T&gt;
6908          auto operator+( T const &amp;other ) const -&gt; Parser;
6909      };
6910      template&lt;typename DerivedT&gt;
6911      class ParserRefImpl : public ComposableParserImpl&lt;DerivedT&gt; {
6912      protected:
6913          Optionality m_optionality = Optionality::Optional;
6914          std::shared_ptr&lt;BoundRef&gt; m_ref;
6915          std::string m_hint;
6916          std::string m_description;
6917          explicit ParserRefImpl( std::shared_ptr&lt;BoundRef&gt; const &amp;ref ) : m_ref( ref ) {}
6918      public:
6919          template&lt;typename T&gt;
6920          ParserRefImpl( T &amp;ref, std::string const &amp;hint )
6921          :   m_ref( std::make_shared&lt;BoundValueRef&lt;T&gt;&gt;( ref ) ),
6922              m_hint( hint )
6923          {}
6924          template&lt;typename LambdaT&gt;
6925          ParserRefImpl( LambdaT const &amp;ref, std::string const &amp;hint )
6926          :   m_ref( std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( ref ) ),
6927              m_hint(hint)
6928          {}
6929          auto operator()( std::string const &amp;description ) -&gt; DerivedT &amp; {
6930              m_description = description;
6931              return static_cast&lt;DerivedT &amp;&gt;( *this );
6932          }
6933          auto optional() -&gt; DerivedT &amp; {
6934              m_optionality = Optionality::Optional;
6935              return static_cast&lt;DerivedT &amp;&gt;( *this );
6936          };
6937          auto required() -&gt; DerivedT &amp; {
6938              m_optionality = Optionality::Required;
6939              return static_cast&lt;DerivedT &amp;&gt;( *this );
6940          };
6941          auto isOptional() const -&gt; bool {
6942              return m_optionality == Optionality::Optional;
6943          }
6944          auto cardinality() const -&gt; size_t override {
6945              if( m_ref-&gt;isContainer() )
6946                  return 0;
6947              else
6948                  return 1;
6949          }
6950          auto hint() const -&gt; std::string { return m_hint; }
6951      };
6952      class ExeName : public ComposableParserImpl&lt;ExeName&gt; {
6953          std::shared_ptr&lt;std::string&gt; m_name;
6954          std::shared_ptr&lt;BoundValueRefBase&gt; m_ref;
6955          template&lt;typename LambdaT&gt;
6956          static auto makeRef(LambdaT const &amp;lambda) -&gt; std::shared_ptr&lt;BoundValueRefBase&gt; {
6957              return std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda) ;
6958          }
6959      public:
6960          ExeName() : m_name( std::make_shared&lt;std::string&gt;( &quot;&lt;executable&gt;&quot; ) ) {}
6961          explicit ExeName( std::string &amp;ref ) : ExeName() {
6962              m_ref = std::make_shared&lt;BoundValueRef&lt;std::string&gt;&gt;( ref );
6963          }
6964          template&lt;typename LambdaT&gt;
6965          explicit ExeName( LambdaT const&amp; lambda ) : ExeName() {
6966              m_ref = std::make_shared&lt;BoundLambda&lt;LambdaT&gt;&gt;( lambda );
6967          }
6968          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6969              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
6970          }
6971          auto name() const -&gt; std::string { return *m_name; }
6972          auto set( std::string const&amp; newName ) -&gt; ParserResult {
6973              auto lastSlash = newName.find_last_of( &quot;\\/&quot; );
6974              auto filename = ( lastSlash == std::string::npos )
6975                      ? newName
6976                      : newName.substr( lastSlash+1 );
6977              *m_name = filename;
6978              if( m_ref )
6979                  return m_ref-&gt;setValue( filename );
6980              else
6981                  return ParserResult::ok( ParseResultType::Matched );
6982          }
6983      };
6984      class Arg : public ParserRefImpl&lt;Arg&gt; {
6985      public:
6986          using ParserRefImpl::ParserRefImpl;
6987          auto parse( std::string const &amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
6988              auto validationResult = validate();
6989              if( !validationResult )
6990                  return InternalParseResult( validationResult );
6991              auto remainingTokens = tokens;
6992              auto const &amp;token = *remainingTokens;
6993              if( token.type != TokenType::Argument )
6994                  return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
6995              assert( !m_ref-&gt;isFlag() );
6996              auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
6997              auto result = valueRef-&gt;setValue( remainingTokens-&gt;token );
6998              if( !result )
6999                  return InternalParseResult( result );
7000              else
7001                  return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7002          }
7003      };
7004      inline auto normaliseOpt( std::string const &amp;optName ) -&gt; std::string {
7005  #ifdef CATCH_PLATFORM_WINDOWS
7006          if( optName[0] == &#x27;/&#x27; )
7007              return &quot;-&quot; + optName.substr( 1 );
7008          else
7009  #endif
7010              return optName;
7011      }
7012      class Opt : public ParserRefImpl&lt;Opt&gt; {
7013      protected:
7014          std::vector&lt;std::string&gt; m_optNames;
7015      public:
7016          template&lt;typename LambdaT&gt;
7017          explicit Opt( LambdaT const &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagLambda&lt;LambdaT&gt;&gt;( ref ) ) {}
7018          explicit Opt( bool &amp;ref ) : ParserRefImpl( std::make_shared&lt;BoundFlagRef&gt;( ref ) ) {}
7019          template&lt;typename LambdaT&gt;
7020          Opt( LambdaT const &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7021          template&lt;typename T&gt;
7022          Opt( T &amp;ref, std::string const &amp;hint ) : ParserRefImpl( ref, hint ) {}
7023          auto operator[]( std::string const &amp;optName ) -&gt; Opt &amp; {
7024              m_optNames.push_back( optName );
7025              return *this;
7026          }
7027          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7028              std::ostringstream oss;
7029              bool first = true;
7030              for( auto const &amp;opt : m_optNames ) {
7031                  if (first)
7032                      first = false;
7033                  else
7034                      oss &lt;&lt; &quot;, &quot;;
7035                  oss &lt;&lt; opt;
7036              }
7037              if( !m_hint.empty() )
7038                  oss &lt;&lt; &quot; &lt;&quot; &lt;&lt; m_hint &lt;&lt; &quot;&gt;&quot;;
7039              return { { oss.str(), m_description } };
7040          }
7041          auto isMatch( std::string const &amp;optToken ) const -&gt; bool {
7042              auto normalisedToken = normaliseOpt( optToken );
7043              for( auto const &amp;name : m_optNames ) {
7044                  if( normaliseOpt( name ) == normalisedToken )
7045                      return true;
7046              }
7047              return false;
7048          }
7049          using ParserBase::parse;
7050          auto parse( std::string const&amp;, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7051              auto validationResult = validate();
7052              if( !validationResult )
7053                  return InternalParseResult( validationResult );
7054              auto remainingTokens = tokens;
7055              if( remainingTokens &amp;&amp; remainingTokens-&gt;type == TokenType::Option ) {
7056                  auto const &amp;token = *remainingTokens;
7057                  if( isMatch(token.token ) ) {
7058                      if( m_ref-&gt;isFlag() ) {
7059                          auto flagRef = static_cast&lt;detail::BoundFlagRefBase*&gt;( m_ref.get() );
7060                          auto result = flagRef-&gt;setFlag( true );
7061                          if( !result )
7062                              return InternalParseResult( result );
7063                          if( result.value() == ParseResultType::ShortCircuitAll )
7064                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7065                      } else {
7066                          auto valueRef = static_cast&lt;detail::BoundValueRefBase*&gt;( m_ref.get() );
7067                          ++remainingTokens;
7068                          if( !remainingTokens )
7069                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7070                          auto const &amp;argToken = *remainingTokens;
7071                          if( argToken.type != TokenType::Argument )
7072                              return InternalParseResult::runtimeError( &quot;Expected argument following &quot; + token.token );
7073                          auto result = valueRef-&gt;setValue( argToken.token );
7074                          if( !result )
7075                              return InternalParseResult( result );
7076                          if( result.value() == ParseResultType::ShortCircuitAll )
7077                              return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
7078                      }
7079                      return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
7080                  }
7081              }
7082              return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
7083          }
7084          auto validate() const -&gt; Result override {
7085              if( m_optNames.empty() )
7086                  return Result::logicError( &quot;No options supplied to Opt&quot; );
7087              for( auto const &amp;name : m_optNames ) {
7088                  if( name.empty() )
7089                      return Result::logicError( &quot;Option name cannot be empty&quot; );
7090  #ifdef CATCH_PLATFORM_WINDOWS
7091                  if( name[0] != &#x27;-&#x27; &amp;&amp; name[0] != &#x27;/&#x27; )
7092                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27; or &#x27;/&#x27;&quot; );
7093  #else
7094                  if( name[0] != &#x27;-&#x27; )
7095                      return Result::logicError( &quot;Option name must begin with &#x27;-&#x27;&quot; );
7096  #endif
7097              }
7098              return ParserRefImpl::validate();
7099          }
7100      };
7101      struct Help : Opt {
7102          Help( bool &amp;showHelpFlag )
7103          :   Opt([&amp;]( bool flag ) {
7104                  showHelpFlag = flag;
7105                  return ParserResult::ok( ParseResultType::ShortCircuitAll );
7106              })
7107          {
7108              static_cast&lt;Opt &amp;&gt;( *this )
7109                      (&quot;display usage information&quot;)
7110                      [&quot;-?&quot;][&quot;-h&quot;][&quot;--help&quot;]
7111                      .optional();
7112          }
7113      };
7114      struct Parser : ParserBase {
7115          mutable ExeName m_exeName;
7116          std::vector&lt;Opt&gt; m_options;
7117          std::vector&lt;Arg&gt; m_args;
7118          auto operator|=( ExeName const &amp;exeName ) -&gt; Parser &amp; {
7119              m_exeName = exeName;
7120              return *this;
7121          }
7122          auto operator|=( Arg const &amp;arg ) -&gt; Parser &amp; {
7123              m_args.push_back(arg);
7124              return *this;
7125          }
7126          auto operator|=( Opt const &amp;opt ) -&gt; Parser &amp; {
7127              m_options.push_back(opt);
7128              return *this;
7129          }
7130          auto operator|=( Parser const &amp;other ) -&gt; Parser &amp; {
7131              m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
7132              m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
7133              return *this;
7134          }
7135          template&lt;typename T&gt;
7136          auto operator|( T const &amp;other ) const -&gt; Parser {
7137              return Parser( *this ) |= other;
7138          }
7139          template&lt;typename T&gt;
7140          auto operator+=( T const &amp;other ) -&gt; Parser &amp; { return operator|=( other ); }
7141          template&lt;typename T&gt;
7142          auto operator+( T const &amp;other ) const -&gt; Parser { return operator|( other ); }
7143          auto getHelpColumns() const -&gt; std::vector&lt;HelpColumns&gt; {
7144              std::vector&lt;HelpColumns&gt; cols;
7145              for (auto const &amp;o : m_options) {
7146                  auto childCols = o.getHelpColumns();
7147                  cols.insert( cols.end(), childCols.begin(), childCols.end() );
7148              }
7149              return cols;
7150          }
7151          void writeToStream( std::ostream &amp;os ) const {
7152              if (!m_exeName.name().empty()) {
7153                  os &lt;&lt; &quot;usage:\n&quot; &lt;&lt; &quot;  &quot; &lt;&lt; m_exeName.name() &lt;&lt; &quot; &quot;;
7154                  bool required = true, first = true;
7155                  for( auto const &amp;arg : m_args ) {
7156                      if (first)
7157                          first = false;
7158                      else
7159                          os &lt;&lt; &quot; &quot;;
7160                      if( arg.isOptional() &amp;&amp; required ) {
7161                          os &lt;&lt; &quot;[&quot;;
7162                          required = false;
7163                      }
7164                      os &lt;&lt; &quot;&lt;&quot; &lt;&lt; arg.hint() &lt;&lt; &quot;&gt;&quot;;
7165                      if( arg.cardinality() == 0 )
7166                          os &lt;&lt; &quot; ... &quot;;
7167                  }
7168                  if( !required )
7169                      os &lt;&lt; &quot;]&quot;;
7170                  if( !m_options.empty() )
7171                      os &lt;&lt; &quot; options&quot;;
7172                  os &lt;&lt; &quot;\n\nwhere options are:&quot; &lt;&lt; std::endl;
7173              }
7174              auto rows = getHelpColumns();
7175              size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
7176              size_t optWidth = 0;
7177              for( auto const &amp;cols : rows )
7178                  optWidth = (std::max)(optWidth, cols.left.size() + 2);
7179              optWidth = (std::min)(optWidth, consoleWidth/2);
7180              for( auto const &amp;cols : rows ) {
7181                  auto row =
7182                          TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
7183                          TextFlow::Spacer(4) +
7184                          TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
7185                  os &lt;&lt; row &lt;&lt; std::endl;
7186              }
7187          }
7188          friend auto operator&lt;&lt;( std::ostream &amp;os, Parser const &amp;parser ) -&gt; std::ostream&amp; {
7189              parser.writeToStream( os );
7190              return os;
7191          }
7192          auto validate() const -&gt; Result override {
7193              for( auto const &amp;opt : m_options ) {
7194                  auto result = opt.validate();
7195                  if( !result )
7196                      return result;
7197              }
7198              for( auto const &amp;arg : m_args ) {
7199                  auto result = arg.validate();
7200                  if( !result )
7201                      return result;
7202              }
7203              return Result::ok();
7204          }
7205          using ParserBase::parse;
7206          auto parse( std::string const&amp; exeName, TokenStream const &amp;tokens ) const -&gt; InternalParseResult override {
7207              struct ParserInfo {
7208                  ParserBase const* parser = nullptr;
7209                  size_t count = 0;
7210              };
7211              const size_t totalParsers = m_options.size() + m_args.size();
7212              assert( totalParsers &lt; 512 );
7213              ParserInfo parseInfos[512];
7214              {
7215                  size_t i = 0;
7216                  for (auto const &amp;opt : m_options) parseInfos[i++].parser = &amp;opt;
7217                  for (auto const &amp;arg : m_args) parseInfos[i++].parser = &amp;arg;
7218              }
7219              m_exeName.set( exeName );
7220              auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
7221              while( result.value().remainingTokens() ) {
7222                  bool tokenParsed = false;
7223                  for( size_t i = 0; i &lt; totalParsers; ++i ) {
7224                      auto&amp;  parseInfo = parseInfos[i];
7225                      if( parseInfo.parser-&gt;cardinality() == 0 || parseInfo.count &lt; parseInfo.parser-&gt;cardinality() ) {
7226                          result = parseInfo.parser-&gt;parse(exeName, result.value().remainingTokens());
7227                          if (!result)
7228                              return result;
7229                          if (result.value().type() != ParseResultType::NoMatch) {
7230                              tokenParsed = true;
7231                              ++parseInfo.count;
7232                              break;
7233                          }
7234                      }
7235                  }
7236                  if( result.value().type() == ParseResultType::ShortCircuitAll )
7237                      return result;
7238                  if( !tokenParsed )
7239                      return InternalParseResult::runtimeError( &quot;Unrecognised token: &quot; + result.value().remainingTokens()-&gt;token );
7240              }
7241              return result;
7242          }
7243      };
7244      template&lt;typename DerivedT&gt;
7245      template&lt;typename T&gt;
7246      auto ComposableParserImpl&lt;DerivedT&gt;::operator|( T const &amp;other ) const -&gt; Parser {
7247          return Parser() | static_cast&lt;DerivedT const &amp;&gt;( *this ) | other;
7248      }
7249  } 
7250  using detail::Parser;
7251  using detail::Opt;
7252  using detail::Arg;
7253  using detail::Args;
7254  using detail::ExeName;
7255  using detail::Help;
7256  using detail::ParseResultType;
7257  using detail::ParserResult;
7258  }} 
7259  #ifdef __clang__
7260  #pragma clang diagnostic pop
7261  #endif
7262  #ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7263  #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7264  #undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
7265  #endif
7266  namespace Catch {
7267      clara::Parser makeCommandLineParser( ConfigData&amp; config );
7268  } 
7269  #include &lt;fstream&gt;
7270  #include &lt;ctime&gt;
7271  namespace Catch {
7272      clara::Parser makeCommandLineParser( ConfigData&amp; config ) {
7273          using namespace clara;
7274          auto const setWarning = [&amp;]( std::string const&amp; warning ) {
7275                  auto warningSet = [&amp;]() {
7276                      if( warning == &quot;NoAssertions&quot; )
7277                          return WarnAbout::NoAssertions;
7278                      if ( warning == &quot;NoTests&quot; )
7279                          return WarnAbout::NoTests;
7280                      return WarnAbout::Nothing;
7281                  }();
7282                  if (warningSet == WarnAbout::Nothing)
7283                      return ParserResult::runtimeError( &quot;Unrecognised warning: &#x27;&quot; + warning + &quot;&#x27;&quot; );
7284                  config.warnings = static_cast&lt;WarnAbout::What&gt;( config.warnings | warningSet );
7285                  return ParserResult::ok( ParseResultType::Matched );
7286              };
7287          auto const loadTestNamesFromFile = [&amp;]( std::string const&amp; filename ) {
7288                  std::ifstream f( filename.c_str() );
7289                  if( !f.is_open() )
7290                      return ParserResult::runtimeError( &quot;Unable to load input file: &#x27;&quot; + filename + &quot;&#x27;&quot; );
7291                  std::string line;
7292                  while( std::getline( f, line ) ) {
7293                      line = trim(line);
7294                      if( !line.empty() &amp;&amp; !startsWith( line, &#x27;#&#x27; ) ) {
7295                          if( !startsWith( line, &#x27;&quot;&#x27; ) )
7296                              line = &#x27;&quot;&#x27; + line + &#x27;&quot;&#x27;;
7297                          config.testsOrTags.push_back( line );
7298                          config.testsOrTags.emplace_back( &quot;,&quot; );
7299                      }
7300                  }
7301                  if(!config.testsOrTags.empty())
7302                      config.testsOrTags.erase( config.testsOrTags.end()-1 );
7303                  return ParserResult::ok( ParseResultType::Matched );
7304              };
7305          auto const setTestOrder = [&amp;]( std::string const&amp; order ) {
7306                  if( startsWith( &quot;declared&quot;, order ) )
7307                      config.runOrder = RunTests::InDeclarationOrder;
7308                  else if( startsWith( &quot;lexical&quot;, order ) )
7309                      config.runOrder = RunTests::InLexicographicalOrder;
7310                  else if( startsWith( &quot;random&quot;, order ) )
7311                      config.runOrder = RunTests::InRandomOrder;
7312                  else
7313                      return clara::ParserResult::runtimeError( &quot;Unrecognised ordering: &#x27;&quot; + order + &quot;&#x27;&quot; );
7314                  return ParserResult::ok( ParseResultType::Matched );
7315              };
7316          auto const setRngSeed = [&amp;]( std::string const&amp; seed ) {
7317                  if( seed != &quot;time&quot; )
7318                      return clara::detail::convertInto( seed, config.rngSeed );
7319                  config.rngSeed = static_cast&lt;unsigned int&gt;( std::time(nullptr) );
7320                  return ParserResult::ok( ParseResultType::Matched );
7321              };
7322          auto const setColourUsage = [&amp;]( std::string const&amp; useColour ) {
7323                      auto mode = toLower( useColour );
7324                      if( mode == &quot;yes&quot; )
7325                          config.useColour = UseColour::Yes;
7326                      else if( mode == &quot;no&quot; )
7327                          config.useColour = UseColour::No;
7328                      else if( mode == &quot;auto&quot; )
7329                          config.useColour = UseColour::Auto;
7330                      else
7331                          return ParserResult::runtimeError( &quot;colour mode must be one of: auto, yes or no. &#x27;&quot; + useColour + &quot;&#x27; not recognised&quot; );
7332                  return ParserResult::ok( ParseResultType::Matched );
7333              };
7334          auto const setWaitForKeypress = [&amp;]( std::string const&amp; keypress ) {
7335                  auto keypressLc = toLower( keypress );
7336                  if (keypressLc == &quot;never&quot;)
7337                      config.waitForKeypress = WaitForKeypress::Never;
7338                  else if( keypressLc == &quot;start&quot; )
7339                      config.waitForKeypress = WaitForKeypress::BeforeStart;
7340                  else if( keypressLc == &quot;exit&quot; )
7341                      config.waitForKeypress = WaitForKeypress::BeforeExit;
7342                  else if( keypressLc == &quot;both&quot; )
7343                      config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
7344                  else
7345                      return ParserResult::runtimeError( &quot;keypress argument must be one of: never, start, exit or both. &#x27;&quot; + keypress + &quot;&#x27; not recognised&quot; );
7346              return ParserResult::ok( ParseResultType::Matched );
7347              };
7348          auto const setVerbosity = [&amp;]( std::string const&amp; verbosity ) {
7349              auto lcVerbosity = toLower( verbosity );
7350              if( lcVerbosity == &quot;quiet&quot; )
7351                  config.verbosity = Verbosity::Quiet;
7352              else if( lcVerbosity == &quot;normal&quot; )
7353                  config.verbosity = Verbosity::Normal;
7354              else if( lcVerbosity == &quot;high&quot; )
7355                  config.verbosity = Verbosity::High;
7356              else
7357                  return ParserResult::runtimeError( &quot;Unrecognised verbosity, &#x27;&quot; + verbosity + &quot;&#x27;&quot; );
7358              return ParserResult::ok( ParseResultType::Matched );
7359          };
7360          auto const setReporter = [&amp;]( std::string const&amp; reporter ) {
7361              IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
7362              auto lcReporter = toLower( reporter );
7363              auto result = factories.find( lcReporter );
7364              if( factories.end() != result )
7365                  config.reporterName = lcReporter;
7366              else
7367                  return ParserResult::runtimeError( &quot;Unrecognized reporter, &#x27;&quot; + reporter + &quot;&#x27;. Check available with --list-reporters&quot; );
7368              return ParserResult::ok( ParseResultType::Matched );
7369          };
7370          auto cli
7371              = ExeName( config.processName )
7372              | Help( config.showHelp )
7373              | Opt( config.listTests )
7374                  [&quot;-l&quot;][&quot;--list-tests&quot;]
7375                  ( &quot;list all/matching test cases&quot; )
7376              | Opt( config.listTags )
7377                  [&quot;-t&quot;][&quot;--list-tags&quot;]
7378                  ( &quot;list all/matching tags&quot; )
7379              | Opt( config.showSuccessfulTests )
7380                  [&quot;-s&quot;][&quot;--success&quot;]
7381                  ( &quot;include successful tests in output&quot; )
7382              | Opt( config.shouldDebugBreak )
7383                  [&quot;-b&quot;][&quot;--break&quot;]
7384                  ( &quot;break into debugger on failure&quot; )
7385              | Opt( config.noThrow )
7386                  [&quot;-e&quot;][&quot;--nothrow&quot;]
7387                  ( &quot;skip exception tests&quot; )
7388              | Opt( config.showInvisibles )
7389                  [&quot;-i&quot;][&quot;--invisibles&quot;]
7390                  ( &quot;show invisibles (tabs, newlines)&quot; )
7391              | Opt( config.outputFilename, &quot;filename&quot; )
7392                  [&quot;-o&quot;][&quot;--out&quot;]
7393                  ( &quot;output filename&quot; )
7394              | Opt( setReporter, &quot;name&quot; )
7395                  [&quot;-r&quot;][&quot;--reporter&quot;]
7396                  ( &quot;reporter to use (defaults to console)&quot; )
7397              | Opt( config.name, &quot;name&quot; )
7398                  [&quot;-n&quot;][&quot;--name&quot;]
7399                  ( &quot;suite name&quot; )
7400              | Opt( [&amp;]( bool ){ config.abortAfter = 1; } )
7401                  [&quot;-a&quot;][&quot;--abort&quot;]
7402                  ( &quot;abort at first failure&quot; )
7403              | Opt( [&amp;]( int x ){ config.abortAfter = x; }, &quot;no. failures&quot; )
7404                  [&quot;-x&quot;][&quot;--abortx&quot;]
7405                  ( &quot;abort after x failures&quot; )
7406              | Opt( setWarning, &quot;warning name&quot; )
7407                  [&quot;-w&quot;][&quot;--warn&quot;]
7408                  ( &quot;enable warnings&quot; )
7409              | Opt( [&amp;]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, &quot;yes|no&quot; )
7410                  [&quot;-d&quot;][&quot;--durations&quot;]
7411                  ( &quot;show test durations&quot; )
7412              | Opt( config.minDuration, &quot;seconds&quot; )
7413                  [&quot;-D&quot;][&quot;--min-duration&quot;]
7414                  ( &quot;show test durations for tests taking at least the given number of seconds&quot; )
7415              | Opt( loadTestNamesFromFile, &quot;filename&quot; )
7416                  [&quot;-f&quot;][&quot;--input-file&quot;]
7417                  ( &quot;load test names to run from a file&quot; )
7418              | Opt( config.filenamesAsTags )
7419                  [&quot;-#&quot;][&quot;--filenames-as-tags&quot;]
7420                  ( &quot;adds a tag for the filename&quot; )
7421              | Opt( config.sectionsToRun, &quot;section name&quot; )
7422                  [&quot;-c&quot;][&quot;--section&quot;]
7423                  ( &quot;specify section to run&quot; )
7424              | Opt( setVerbosity, &quot;quiet|normal|high&quot; )
7425                  [&quot;-v&quot;][&quot;--verbosity&quot;]
7426                  ( &quot;set output verbosity&quot; )
7427              | Opt( config.listTestNamesOnly )
7428                  [&quot;--list-test-names-only&quot;]
7429                  ( &quot;list all/matching test cases names only&quot; )
7430              | Opt( config.listReporters )
7431                  [&quot;--list-reporters&quot;]
7432                  ( &quot;list all reporters&quot; )
7433              | Opt( setTestOrder, &quot;decl|lex|rand&quot; )
7434                  [&quot;--order&quot;]
7435                  ( &quot;test case order (defaults to decl)&quot; )
7436              | Opt( setRngSeed, &quot;&#x27;time&#x27;|number&quot; )
7437                  [&quot;--rng-seed&quot;]
7438                  ( &quot;set a specific seed for random numbers&quot; )
7439              | Opt( setColourUsage, &quot;yes|no&quot; )
7440                  [&quot;--use-colour&quot;]
7441                  ( &quot;should output be colourised&quot; )
7442              | Opt( config.libIdentify )
7443                  [&quot;--libidentify&quot;]
7444                  ( &quot;report name and version according to libidentify standard&quot; )
7445              | Opt( setWaitForKeypress, &quot;never|start|exit|both&quot; )
7446                  [&quot;--wait-for-keypress&quot;]
7447                  ( &quot;waits for a keypress before exiting&quot; )
7448              | Opt( config.benchmarkSamples, &quot;samples&quot; )
7449                  [&quot;--benchmark-samples&quot;]
7450                  ( &quot;number of samples to collect (default: 100)&quot; )
7451              | Opt( config.benchmarkResamples, &quot;resamples&quot; )
7452                  [&quot;--benchmark-resamples&quot;]
7453                  ( &quot;number of resamples for the bootstrap (default: 100000)&quot; )
7454              | Opt( config.benchmarkConfidenceInterval, &quot;confidence interval&quot; )
7455                  [&quot;--benchmark-confidence-interval&quot;]
7456                  ( &quot;confidence interval for the bootstrap (between 0 and 1, default: 0.95)&quot; )
7457              | Opt( config.benchmarkNoAnalysis )
7458                  [&quot;--benchmark-no-analysis&quot;]
7459                  ( &quot;perform only measurements; do not perform any analysis&quot; )
7460              | Opt( config.benchmarkWarmupTime, &quot;benchmarkWarmupTime&quot; )
7461                  [&quot;--benchmark-warmup-time&quot;]
7462                  ( &quot;amount of time in milliseconds spent on warming up each test (default: 100)&quot; )
7463              | Arg( config.testsOrTags, &quot;test name|pattern|tags&quot; )
7464                  ( &quot;which test or tests to use&quot; );
7465          return cli;
7466      }
7467  } 
7468  #include &lt;cstring&gt;
7469  #include &lt;ostream&gt;
7470  namespace Catch {
7471      bool SourceLineInfo::operator == ( SourceLineInfo const&amp; other ) const noexcept {
7472          return line == other.line &amp;&amp; (file == other.file || std::strcmp(file, other.file) == 0);
7473      }
7474      bool SourceLineInfo::operator &lt; ( SourceLineInfo const&amp; other ) const noexcept {
7475          return line &lt; other.line || ( line == other.line &amp;&amp; file != other.file &amp;&amp; (std::strcmp(file, other.file) &lt; 0));
7476      }
7477      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, SourceLineInfo const&amp; info ) {
7478  #ifndef __GNUG__
7479          os &lt;&lt; info.file &lt;&lt; &#x27;(&#x27; &lt;&lt; info.line &lt;&lt; &#x27;)&#x27;;
7480  #else
7481          os &lt;&lt; info.file &lt;&lt; &#x27;:&#x27; &lt;&lt; info.line;
7482  #endif
7483          return os;
7484      }
7485      std::string StreamEndStop::operator+() const {
7486          return std::string();
7487      }
7488      NonCopyable::NonCopyable() = default;
7489      NonCopyable::~NonCopyable() = default;
7490  }
7491  namespace Catch {
7492      Config::Config( ConfigData const&amp; data )
7493      :   m_data( data ),
7494          m_stream( openStream() )
7495      {
7496          for (auto&amp; elem : m_data.testsOrTags) {
7497              elem = trim(elem);
7498          }
7499          for (auto&amp; elem : m_data.sectionsToRun) {
7500              elem = trim(elem);
7501          }
7502          TestSpecParser parser(ITagAliasRegistry::get());
7503          if (!m_data.testsOrTags.empty()) {
7504              m_hasTestFilters = true;
7505              for (auto const&amp; testOrTags : m_data.testsOrTags) {
7506                  parser.parse(testOrTags);
7507              }
7508          }
7509          m_testSpec = parser.testSpec();
7510      }
7511      std::string const&amp; Config::getFilename() const {
7512          return m_data.outputFilename ;
7513      }
7514      bool Config::listTests() const          { return m_data.listTests; }
7515      bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
7516      bool Config::listTags() const           { return m_data.listTags; }
7517      bool Config::listReporters() const      { return m_data.listReporters; }
7518      std::string Config::getProcessName() const { return m_data.processName; }
7519      std::string const&amp; Config::getReporterName() const { return m_data.reporterName; }
7520      std::vector&lt;std::string&gt; const&amp; Config::getTestsOrTags() const { return m_data.testsOrTags; }
7521      std::vector&lt;std::string&gt; const&amp; Config::getSectionsToRun() const { return m_data.sectionsToRun; }
7522      TestSpec const&amp; Config::testSpec() const { return m_testSpec; }
7523      bool Config::hasTestFilters() const { return m_hasTestFilters; }
7524      bool Config::showHelp() const { return m_data.showHelp; }
7525      bool Config::allowThrows() const                   { return !m_data.noThrow; }
7526      std::ostream&amp; Config::stream() const               { return m_stream-&gt;stream(); }
7527      std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
7528      bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
7529      bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings &amp; WarnAbout::NoAssertions); }
7530      bool Config::warnAboutNoTests() const              { return !!(m_data.warnings &amp; WarnAbout::NoTests); }
7531      ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
7532      double Config::minDuration() const                 { return m_data.minDuration; }
7533      RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
7534      unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
7535      UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
7536      bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
7537      int Config::abortAfter() const                     { return m_data.abortAfter; }
7538      bool Config::showInvisibles() const                { return m_data.showInvisibles; }
7539      Verbosity Config::verbosity() const                { return m_data.verbosity; }
7540      bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
7541      int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
7542      double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
7543      unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
7544      std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }
7545      IStream const* Config::openStream() {
7546          return Catch::makeStream(m_data.outputFilename);
7547      }
7548  } 
7549  #if defined(__clang__)
7550  #    pragma clang diagnostic push
7551  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
7552  #endif
7553  namespace Catch {
7554      class ErrnoGuard {
7555      public:
7556          ErrnoGuard();
7557          ~ErrnoGuard();
7558      private:
7559          int m_oldErrno;
7560      };
7561  }
7562  #if defined(CATCH_PLATFORM_WINDOWS)
7563  #if !defined(NOMINMAX) &amp;&amp; !defined(CATCH_CONFIG_NO_NOMINMAX)
7564  #  define CATCH_DEFINED_NOMINMAX
7565  #  define NOMINMAX
7566  #endif
7567  #if !defined(WIN32_LEAN_AND_MEAN) &amp;&amp; !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
7568  #  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7569  #  define WIN32_LEAN_AND_MEAN
7570  #endif
7571  #ifdef __AFXDLL
7572  #include &lt;AfxWin.h&gt;
7573  #else
7574  #include &lt;windows.h&gt;
7575  #endif
7576  #ifdef CATCH_DEFINED_NOMINMAX
7577  #  undef NOMINMAX
7578  #endif
7579  #ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
7580  #  undef WIN32_LEAN_AND_MEAN
7581  #endif
7582  #endif 
7583  #include &lt;sstream&gt;
7584  namespace Catch {
7585      namespace {
7586          struct IColourImpl {
7587              virtual ~IColourImpl() = default;
7588              virtual void use( Colour::Code _colourCode ) = 0;
7589          };
7590          struct NoColourImpl : IColourImpl {
7591              void use( Colour::Code ) override {}
7592              static IColourImpl* instance() {
7593                  static NoColourImpl s_instance;
7594                  return &amp;s_instance;
7595              }
7596          };
7597      } 
7598  } 
7599  #if !defined( CATCH_CONFIG_COLOUR_NONE ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_WINDOWS ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_ANSI )
7600  #   ifdef CATCH_PLATFORM_WINDOWS
7601  #       define CATCH_CONFIG_COLOUR_WINDOWS
7602  #   else
7603  #       define CATCH_CONFIG_COLOUR_ANSI
7604  #   endif
7605  #endif
7606  #if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) 
7607  namespace Catch {
7608  namespace {
7609      class Win32ColourImpl : public IColourImpl {
7610      public:
7611          Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
7612          {
7613              CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
7614              GetConsoleScreenBufferInfo( stdoutHandle, &amp;csbiInfo );
7615              originalForegroundAttributes = csbiInfo.wAttributes &amp; ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
7616              originalBackgroundAttributes = csbiInfo.wAttributes &amp; ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
7617          }
7618          void use( Colour::Code _colourCode ) override {
7619              switch( _colourCode ) {
7620                  case Colour::None:      return setTextAttribute( originalForegroundAttributes );
7621                  case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7622                  case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
7623                  case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
7624                  case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
7625                  case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
7626                  case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
7627                  case Colour::Grey:      return setTextAttribute( 0 );
7628                  case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
7629                  case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
7630                  case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
7631                  case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7632                  case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
7633                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7634                  default:
7635                      CATCH_ERROR( &quot;Unknown colour requested&quot; );
7636              }
7637          }
7638      private:
7639          void setTextAttribute( WORD _textAttribute ) {
7640              SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
7641          }
7642          HANDLE stdoutHandle;
7643          WORD originalForegroundAttributes;
7644          WORD originalBackgroundAttributes;
7645      };
7646      IColourImpl* platformColourInstance() {
7647          static Win32ColourImpl s_instance;
7648          IConfigPtr config = getCurrentContext().getConfig();
7649          UseColour::YesOrNo colourMode = config
7650              ? config-&gt;useColour()
7651              : UseColour::Auto;
7652          if( colourMode == UseColour::Auto )
7653              colourMode = UseColour::Yes;
7654          return colourMode == UseColour::Yes
7655              ? &amp;s_instance
7656              : NoColourImpl::instance();
7657      }
7658  } 
7659  } 
7660  #elif defined( CATCH_CONFIG_COLOUR_ANSI ) 
7661  #include &lt;unistd.h&gt;
7662  namespace Catch {
7663  namespace {
7664      class PosixColourImpl : public IColourImpl {
7665      public:
7666          void use( Colour::Code _colourCode ) override {
7667              switch( _colourCode ) {
7668                  case Colour::None:
7669                  case Colour::White:     return setColour( &quot;[0m&quot; );
7670                  case Colour::Red:       return setColour( &quot;[0;31m&quot; );
7671                  case Colour::Green:     return setColour( &quot;[0;32m&quot; );
7672                  case Colour::Blue:      return setColour( &quot;[0;34m&quot; );
7673                  case Colour::Cyan:      return setColour( &quot;[0;36m&quot; );
7674                  case Colour::Yellow:    return setColour( &quot;[0;33m&quot; );
7675                  case Colour::Grey:      return setColour( &quot;[1;30m&quot; );
7676                  case Colour::LightGrey:     return setColour( &quot;[0;37m&quot; );
7677                  case Colour::BrightRed:     return setColour( &quot;[1;31m&quot; );
7678                  case Colour::BrightGreen:   return setColour( &quot;[1;32m&quot; );
7679                  case Colour::BrightWhite:   return setColour( &quot;[1;37m&quot; );
7680                  case Colour::BrightYellow:  return setColour( &quot;[1;33m&quot; );
7681                  case Colour::Bright: CATCH_INTERNAL_ERROR( &quot;not a colour&quot; );
7682                  default: CATCH_INTERNAL_ERROR( &quot;Unknown colour requested&quot; );
7683              }
7684          }
7685          static IColourImpl* instance() {
7686              static PosixColourImpl s_instance;
7687              return &amp;s_instance;
7688          }
7689      private:
7690          void setColour( const char* _escapeCode ) {
7691              getCurrentContext().getConfig()-&gt;stream()
7692                  &lt;&lt; &#x27;\033&#x27; &lt;&lt; _escapeCode;
7693          }
7694      };
7695      bool useColourOnPlatform() {
7696          return
7697  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7698              !isDebuggerActive() &amp;&amp;
7699  #endif
7700  #if !(defined(__DJGPP__) &amp;&amp; defined(__STRICT_ANSI__))
7701              isatty(STDOUT_FILENO)
7702  #else
7703              false
7704  #endif
7705              ;
7706      }
7707      IColourImpl* platformColourInstance() {
7708          ErrnoGuard guard;
7709          IConfigPtr config = getCurrentContext().getConfig();
7710          UseColour::YesOrNo colourMode = config
7711              ? config-&gt;useColour()
7712              : UseColour::Auto;
7713          if( colourMode == UseColour::Auto )
7714              colourMode = useColourOnPlatform()
7715                  ? UseColour::Yes
7716                  : UseColour::No;
7717          return colourMode == UseColour::Yes
7718              ? PosixColourImpl::instance()
7719              : NoColourImpl::instance();
7720      }
7721  } 
7722  } 
7723  #else  
7724  namespace Catch {
7725      static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
7726  } 
7727  #endif 
7728  namespace Catch {
7729      Colour::Colour( Code _colourCode ) { use( _colourCode ); }
7730      Colour::Colour( Colour&amp;&amp; other ) noexcept {
7731          m_moved = other.m_moved;
7732          other.m_moved = true;
7733      }
7734      Colour&amp; Colour::operator=( Colour&amp;&amp; other ) noexcept {
7735          m_moved = other.m_moved;
7736          other.m_moved  = true;
7737          return *this;
7738      }
7739      Colour::~Colour(){ if( !m_moved ) use( None ); }
7740      void Colour::use( Code _colourCode ) {
7741          static IColourImpl* impl = platformColourInstance();
7742          if (impl != nullptr) {
7743              impl-&gt;use( _colourCode );
7744          }
7745      }
7746      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Colour const&amp; ) {
7747          return os;
7748      }
7749  } 
7750  #if defined(__clang__)
7751  #    pragma clang diagnostic pop
7752  #endif
7753  namespace Catch {
7754      class Context : public IMutableContext, NonCopyable {
7755      public: 
7756          IResultCapture* getResultCapture() override {
7757              return m_resultCapture;
7758          }
7759          IRunner* getRunner() override {
7760              return m_runner;
7761          }
7762          IConfigPtr const&amp; getConfig() const override {
7763              return m_config;
7764          }
7765          ~Context() override;
7766      public: 
7767          void setResultCapture( IResultCapture* resultCapture ) override {
7768              m_resultCapture = resultCapture;
7769          }
7770          void setRunner( IRunner* runner ) override {
7771              m_runner = runner;
7772          }
7773          void setConfig( IConfigPtr const&amp; config ) override {
7774              m_config = config;
7775          }
7776          friend IMutableContext&amp; getCurrentMutableContext();
7777      private:
7778          IConfigPtr m_config;
7779          IRunner* m_runner = nullptr;
7780          IResultCapture* m_resultCapture = nullptr;
7781      };
7782      IMutableContext *IMutableContext::currentContext = nullptr;
7783      void IMutableContext::createContext()
7784      {
7785          currentContext = new Context();
7786      }
7787      void cleanUpContext() {
7788          delete IMutableContext::currentContext;
7789          IMutableContext::currentContext = nullptr;
7790      }
7791      IContext::~IContext() = default;
7792      IMutableContext::~IMutableContext() = default;
7793      Context::~Context() = default;
7794      SimplePcg32&amp; rng() {
7795          static SimplePcg32 s_rng;
7796          return s_rng;
7797      }
7798  }
7799  #include &lt;string&gt;
7800  namespace Catch {
7801      void writeToDebugConsole( std::string const&amp; text );
7802  }
7803  #if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
7804  #include &lt;android/log.h&gt;
7805      namespace Catch {
7806          void writeToDebugConsole( std::string const&amp; text ) {
7807              __android_log_write( ANDROID_LOG_DEBUG, &quot;Catch&quot;, text.c_str() );
7808          }
7809      }
7810  #elif defined(CATCH_PLATFORM_WINDOWS)
7811      namespace Catch {
7812          void writeToDebugConsole( std::string const&amp; text ) {
7813              ::OutputDebugStringA( text.c_str() );
7814          }
7815      }
7816  #else
7817      namespace Catch {
7818          void writeToDebugConsole( std::string const&amp; text ) {
7819              Catch::cout() &lt;&lt; text;
7820          }
7821      }
7822  #endif 
7823  #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
7824  #  include &lt;cassert&gt;
7825  #  include &lt;sys/types.h&gt;
7826  #  include &lt;unistd.h&gt;
7827  #  include &lt;cstddef&gt;
7828  #  include &lt;ostream&gt;
7829  #ifdef __apple_build_version__
7830  #  include &lt;sys/sysctl.h&gt;
7831  #endif
7832      namespace Catch {
7833          #ifdef __apple_build_version__
7834          bool isDebuggerActive(){
7835              int                 mib[4];
7836              struct kinfo_proc   info;
7837              std::size_t         size;
7838              info.kp_proc.p_flag = 0;
7839              mib[0] = CTL_KERN;
7840              mib[1] = KERN_PROC;
7841              mib[2] = KERN_PROC_PID;
7842              mib[3] = getpid();
7843              size = sizeof(info);
7844              if( sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, nullptr, 0) != 0 ) {
7845                  Catch::cerr() &lt;&lt; &quot;\n** Call to sysctl failed - unable to determine if debugger is active **\n&quot; &lt;&lt; std::endl;
7846                  return false;
7847              }
7848              return ( (info.kp_proc.p_flag &amp; P_TRACED) != 0 );
7849          }
7850          #else
7851          bool isDebuggerActive() {
7852              return false;
7853          }
7854          #endif
7855      } 
7856  #elif defined(CATCH_PLATFORM_LINUX)
7857      #include &lt;fstream&gt;
7858      #include &lt;string&gt;
7859      namespace Catch{
7860          bool isDebuggerActive(){
7861              ErrnoGuard guard;
7862              std::ifstream in(&quot;/proc/self/status&quot;);
7863              for( std::string line; std::getline(in, line); ) {
7864                  static const int PREFIX_LEN = 11;
7865                  if( line.compare(0, PREFIX_LEN, &quot;TracerPid:\t&quot;) == 0 ) {
7866                      return line.length() &gt; PREFIX_LEN &amp;&amp; line[PREFIX_LEN] != &#x27;0&#x27;;
7867                  }
7868              }
7869              return false;
7870          }
7871      } 
7872  #elif defined(_MSC_VER)
7873      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7874      namespace Catch {
7875          bool isDebuggerActive() {
7876              return IsDebuggerPresent() != 0;
7877          }
7878      }
7879  #elif defined(__MINGW32__)
7880      extern &quot;C&quot; __declspec(dllimport) int __stdcall IsDebuggerPresent();
7881      namespace Catch {
7882          bool isDebuggerActive() {
7883              return IsDebuggerPresent() != 0;
7884          }
7885      }
7886  #else
7887      namespace Catch {
7888         bool isDebuggerActive() { return false; }
7889      }
7890  #endif 
7891  namespace Catch {
7892      ITransientExpression::~ITransientExpression() = default;
7893      void formatReconstructedExpression( std::ostream &amp;os, std::string const&amp; lhs, StringRef op, std::string const&amp; rhs ) {
7894          if( lhs.size() + rhs.size() &lt; 40 &amp;&amp;
7895                  lhs.find(&#x27;\n&#x27;) == std::string::npos &amp;&amp;
7896                  rhs.find(&#x27;\n&#x27;) == std::string::npos )
7897              os &lt;&lt; lhs &lt;&lt; &quot; &quot; &lt;&lt; op &lt;&lt; &quot; &quot; &lt;&lt; rhs;
7898          else
7899              os &lt;&lt; lhs &lt;&lt; &quot;\n&quot; &lt;&lt; op &lt;&lt; &quot;\n&quot; &lt;&lt; rhs;
7900      }
7901  }
7902  #include &lt;stdexcept&gt;
7903  namespace Catch {
7904  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
7905      [[noreturn]]
7906      void throw_exception(std::exception const&amp; e) {
7907          Catch::cerr() &lt;&lt; &quot;Catch will terminate because it needed to throw an exception.\n&quot;
7908                        &lt;&lt; &quot;The message was: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;
7909          std::terminate();
7910      }
7911  #endif
7912      [[noreturn]]
7913      void throw_logic_error(std::string const&amp; msg) {
7914          throw_exception(std::logic_error(msg));
7915      }
7916      [[noreturn]]
7917      void throw_domain_error(std::string const&amp; msg) {
7918          throw_exception(std::domain_error(msg));
7919      }
7920      [[noreturn]]
7921      void throw_runtime_error(std::string const&amp; msg) {
7922          throw_exception(std::runtime_error(msg));
7923      }
7924  } 
7925  #include &lt;vector&gt;
7926  #include &lt;memory&gt;
7927  namespace Catch {
7928      namespace Detail {
7929          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values );
7930          class EnumValuesRegistry : public IMutableEnumValuesRegistry {
7931              std::vector&lt;std::unique_ptr&lt;EnumInfo&gt;&gt; m_enumInfos;
7932              EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allEnums, std::vector&lt;int&gt; const&amp; values) override;
7933          };
7934          std::vector&lt;StringRef&gt; parseEnums( StringRef enums );
7935      } 
7936  } 
7937  #include &lt;map&gt;
7938  #include &lt;cassert&gt;
7939  namespace Catch {
7940      IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}
7941      namespace Detail {
7942          namespace {
7943              StringRef extractInstanceName(StringRef enumInstance) {
7944                  size_t name_start = enumInstance.size();
7945                  while (name_start &gt; 0 &amp;&amp; enumInstance[name_start - 1] != &#x27;:&#x27;) {
7946                      --name_start;
7947                  }
7948                  return enumInstance.substr(name_start, enumInstance.size() - name_start);
7949              }
7950          }
7951          std::vector&lt;StringRef&gt; parseEnums( StringRef enums ) {
7952              auto enumValues = splitStringRef( enums, &#x27;,&#x27; );
7953              std::vector&lt;StringRef&gt; parsed;
7954              parsed.reserve( enumValues.size() );
7955              for( auto const&amp; enumValue : enumValues ) {
7956                  parsed.push_back(trim(extractInstanceName(enumValue)));
7957              }
7958              return parsed;
7959          }
7960          EnumInfo::~EnumInfo() {}
7961          StringRef EnumInfo::lookup( int value ) const {
7962              for( auto const&amp; valueToName : m_values ) {
7963                  if( valueToName.first == value )
7964                      return valueToName.second;
7965              }
7966              return &quot;{** unexpected enum value **}&quot;_sr;
7967          }
7968          std::unique_ptr&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7969              std::unique_ptr&lt;EnumInfo&gt; enumInfo( new EnumInfo );
7970              enumInfo-&gt;m_name = enumName;
7971              enumInfo-&gt;m_values.reserve( values.size() );
7972              const auto valueNames = Catch::Detail::parseEnums( allValueNames );
7973              assert( valueNames.size() == values.size() );
7974              std::size_t i = 0;
7975              for( auto value : values )
7976                  enumInfo-&gt;m_values.emplace_back(value, valueNames[i++]);
7977              return enumInfo;
7978          }
7979          EnumInfo const&amp; EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values ) {
7980              m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
7981              return *m_enumInfos.back();
7982          }
7983      } 
7984  } 
7985  #include &lt;cerrno&gt;
7986  namespace Catch {
7987          ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
7988          ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
7989  }
7990  #include &lt;vector&gt;
7991  #include &lt;string&gt;
7992  #include &lt;memory&gt;
7993  namespace Catch {
7994      class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
7995      public:
7996          ~ExceptionTranslatorRegistry();
7997          virtual void registerTranslator( const IExceptionTranslator* translator );
7998          std::string translateActiveException() const override;
7999          std::string tryTranslators() const;
8000      private:
8001          std::vector&lt;std::unique_ptr&lt;IExceptionTranslator const&gt;&gt; m_translators;
8002      };
8003  }
8004  #ifdef __OBJC__
8005  #import &quot;Foundation/Foundation.h&quot;
8006  #endif
8007  namespace Catch {
8008      ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
8009      }
8010      void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
8011          m_translators.push_back( std::unique_ptr&lt;const IExceptionTranslator&gt;( translator ) );
8012      }
8013  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
8014      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8015          try {
8016  #ifdef __OBJC__
8017              @try {
8018                  return tryTranslators();
8019              }
8020              @catch (NSException *exception) {
8021                  return Catch::Detail::stringify( [exception description] );
8022              }
8023  #else
8024              if (std::current_exception() == nullptr) {
8025                  return &quot;Non C++ exception. Possibly a CLR exception.&quot;;
8026              }
8027              return tryTranslators();
8028  #endif
8029          }
8030          catch( TestFailureException&amp; ) {
8031              std::rethrow_exception(std::current_exception());
8032          }
8033          catch( std::exception&amp; ex ) {
8034              return ex.what();
8035          }
8036          catch( std::string&amp; msg ) {
8037              return msg;
8038          }
8039          catch( const char* msg ) {
8040              return msg;
8041          }
8042          catch(...) {
8043              return &quot;Unknown exception&quot;;
8044          }
8045      }
8046      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8047          if (m_translators.empty()) {
8048              std::rethrow_exception(std::current_exception());
8049          } else {
8050              return m_translators[0]-&gt;translate(m_translators.begin() + 1, m_translators.end());
8051          }
8052      }
8053  #else 
8054      std::string ExceptionTranslatorRegistry::translateActiveException() const {
8055          CATCH_INTERNAL_ERROR(&quot;Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8056      }
8057      std::string ExceptionTranslatorRegistry::tryTranslators() const {
8058          CATCH_INTERNAL_ERROR(&quot;Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
8059      }
8060  #endif
8061  }
8062  #include &lt;algorithm&gt;
8063  #if !defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; !defined( CATCH_CONFIG_POSIX_SIGNALS )
8064  namespace Catch {
8065      void FatalConditionHandler::engage_platform() {}
8066      void FatalConditionHandler::disengage_platform() {}
8067      FatalConditionHandler::FatalConditionHandler() = default;
8068      FatalConditionHandler::~FatalConditionHandler() = default;
8069  } 
8070  #endif 
8071  #if defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; defined( CATCH_CONFIG_POSIX_SIGNALS )
8072  #error &quot;Inconsistent configuration: Windows&#x27; SEH handling and POSIX signals cannot be enabled at the same time&quot;
8073  #endif 
8074  #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
8075  namespace {
8076      void reportFatal( char const * const message ) {
8077          Catch::getCurrentContext().getResultCapture()-&gt;handleFatalErrorCondition( message );
8078      }
8079      constexpr std::size_t minStackSizeForErrors = 32 * 1024;
8080  } 
8081  #endif 
8082  #if defined( CATCH_CONFIG_WINDOWS_SEH )
8083  namespace Catch {
8084      struct SignalDefs { DWORD id; const char* name; };
8085      static SignalDefs signalDefs[] = {
8086          { static_cast&lt;DWORD&gt;(EXCEPTION_ILLEGAL_INSTRUCTION),  &quot;SIGILL - Illegal instruction signal&quot; },
8087          { static_cast&lt;DWORD&gt;(EXCEPTION_STACK_OVERFLOW), &quot;SIGSEGV - Stack overflow&quot; },
8088          { static_cast&lt;DWORD&gt;(EXCEPTION_ACCESS_VIOLATION), &quot;SIGSEGV - Segmentation violation signal&quot; },
8089          { static_cast&lt;DWORD&gt;(EXCEPTION_INT_DIVIDE_BY_ZERO), &quot;Divide by zero error&quot; },
8090      };
8091      static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
8092          for (auto const&amp; def : signalDefs) {
8093              if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == def.id) {
8094                  reportFatal(def.name);
8095              }
8096          }
8097          return EXCEPTION_CONTINUE_SEARCH;
8098      }
8099      static PVOID exceptionHandlerHandle = nullptr;
8100      FatalConditionHandler::FatalConditionHandler() {
8101          ULONG guaranteeSize = static_cast&lt;ULONG&gt;(minStackSizeForErrors);
8102          if (!SetThreadStackGuarantee(&amp;guaranteeSize)) {
8103              Catch::cerr()
8104                  &lt;&lt; &quot;Failed to reserve piece of stack.&quot;
8105                  &lt;&lt; &quot; Stack overflows will not be reported successfully.&quot;;
8106          }
8107      }
8108      FatalConditionHandler::~FatalConditionHandler() = default;
8109      void FatalConditionHandler::engage_platform() {
8110          exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
8111          if (!exceptionHandlerHandle) {
8112              CATCH_RUNTIME_ERROR(&quot;Could not register vectored exception handler&quot;);
8113          }
8114      }
8115      void FatalConditionHandler::disengage_platform() {
8116          if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {
8117              CATCH_RUNTIME_ERROR(&quot;Could not unregister vectored exception handler&quot;);
8118          }
8119          exceptionHandlerHandle = nullptr;
8120      }
8121  } 
8122  #endif 
8123  #if defined( CATCH_CONFIG_POSIX_SIGNALS )
8124  #include &lt;signal.h&gt;
8125  namespace Catch {
8126      struct SignalDefs {
8127          int id;
8128          const char* name;
8129      };
8130      static SignalDefs signalDefs[] = {
8131          { SIGINT,  &quot;SIGINT - Terminal interrupt signal&quot; },
8132          { SIGILL,  &quot;SIGILL - Illegal instruction signal&quot; },
8133          { SIGFPE,  &quot;SIGFPE - Floating point error signal&quot; },
8134          { SIGSEGV, &quot;SIGSEGV - Segmentation violation signal&quot; },
8135          { SIGTERM, &quot;SIGTERM - Termination request signal&quot; },
8136          { SIGABRT, &quot;SIGABRT - Abort (abnormal termination) signal&quot; }
8137      };
8138  #if defined(__GNUC__)
8139  #    pragma GCC diagnostic push
8140  #    pragma GCC diagnostic ignored &quot;-Wmissing-field-initializers&quot;
8141  #endif
8142      static char* altStackMem = nullptr;
8143      static std::size_t altStackSize = 0;
8144      static stack_t oldSigStack{};
8145      static struct sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]{};
8146      static void restorePreviousSignalHandlers() {
8147          for (std::size_t i = 0; i &lt; sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
8148              sigaction(signalDefs[i].id, &amp;oldSigActions[i], nullptr);
8149          }
8150          sigaltstack(&amp;oldSigStack, nullptr);
8151      }
8152      static void handleSignal( int sig ) {
8153          char const * name = &quot;&lt;unknown signal&gt;&quot;;
8154          for (auto const&amp; def : signalDefs) {
8155              if (sig == def.id) {
8156                  name = def.name;
8157                  break;
8158              }
8159          }
8160          restorePreviousSignalHandlers();
8161          reportFatal( name );
8162          raise( sig );
8163      }
8164      FatalConditionHandler::FatalConditionHandler() {
8165          assert(!altStackMem &amp;&amp; &quot;Cannot initialize POSIX signal handler when one already exists&quot;);
8166          if (altStackSize == 0) {
8167              altStackSize = std::max(static_cast&lt;size_t&gt;(SIGSTKSZ), minStackSizeForErrors);
8168          }
8169          altStackMem = new char[altStackSize]();
8170      }
8171      FatalConditionHandler::~FatalConditionHandler() {
8172          delete[] altStackMem;
8173          altStackMem = nullptr;
8174      }
8175      void FatalConditionHandler::engage_platform() {
8176          stack_t sigStack;
8177          sigStack.ss_sp = altStackMem;
8178          sigStack.ss_size = altStackSize;
8179          sigStack.ss_flags = 0;
8180          sigaltstack(&amp;sigStack, &amp;oldSigStack);
8181          struct sigaction sa = { };
8182          sa.sa_handler = handleSignal;
8183          sa.sa_flags = SA_ONSTACK;
8184          for (std::size_t i = 0; i &lt; sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
8185              sigaction(signalDefs[i].id, &amp;sa, &amp;oldSigActions[i]);
8186          }
8187      }
8188  #if defined(__GNUC__)
8189  #    pragma GCC diagnostic pop
8190  #endif
8191      void FatalConditionHandler::disengage_platform() {
8192          restorePreviousSignalHandlers();
8193      }
8194  } 
8195  #endif 
8196  #include &lt;limits&gt;
8197  #include &lt;set&gt;
8198  namespace Catch {
8199  IGeneratorTracker::~IGeneratorTracker() {}
8200  const char* GeneratorException::what() const noexcept {
8201      return m_msg;
8202  }
8203  namespace Generators {
8204      GeneratorUntypedBase::~GeneratorUntypedBase() {}
8205      auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
8206          return getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );
8207      }
8208  } 
8209  } 
8210  namespace Catch {
8211      IResultCapture::~IResultCapture() = default;
8212  }
8213  namespace Catch {
8214      IConfig::~IConfig() = default;
8215  }
8216  namespace Catch {
8217      IExceptionTranslator::~IExceptionTranslator() = default;
8218      IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
8219  }
8220  namespace Catch {
8221      IRegistryHub::~IRegistryHub() = default;
8222      IMutableRegistryHub::~IMutableRegistryHub() = default;
8223  }
8224  namespace Catch {
8225      class ListeningReporter : public IStreamingReporter {
8226          using Reporters = std::vector&lt;IStreamingReporterPtr&gt;;
8227          Reporters m_listeners;
8228          IStreamingReporterPtr m_reporter = nullptr;
8229          ReporterPreferences m_preferences;
8230      public:
8231          ListeningReporter();
8232          void addListener( IStreamingReporterPtr&amp;&amp; listener );
8233          void addReporter( IStreamingReporterPtr&amp;&amp; reporter );
8234      public: 
8235          ReporterPreferences getPreferences() const override;
8236          void noMatchingTestCases( std::string const&amp; spec ) override;
8237          void reportInvalidArguments(std::string const&amp;arg) override;
8238          static std::set&lt;Verbosity&gt; getSupportedVerbosities();
8239  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
8240          void benchmarkPreparing(std::string const&amp; name) override;
8241          void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;
8242          void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;
8243          void benchmarkFailed(std::string const&amp;) override;
8244  #endif 
8245          void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;
8246          void testGroupStarting( GroupInfo const&amp; groupInfo ) override;
8247          void testCaseStarting( TestCaseInfo const&amp; testInfo ) override;
8248          void sectionStarting( SectionInfo const&amp; sectionInfo ) override;
8249          void assertionStarting( AssertionInfo const&amp; assertionInfo ) override;
8250          bool assertionEnded( AssertionStats const&amp; assertionStats ) override;
8251          void sectionEnded( SectionStats const&amp; sectionStats ) override;
8252          void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;
8253          void testGroupEnded( TestGroupStats const&amp; testGroupStats ) override;
8254          void testRunEnded( TestRunStats const&amp; testRunStats ) override;
8255          void skipTest( TestCaseInfo const&amp; testInfo ) override;
8256          bool isMulti() const override;
8257      };
8258  } 
8259  namespace Catch {
8260      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig )
8261      :   m_stream( &amp;_fullConfig-&gt;stream() ), m_fullConfig( _fullConfig ) {}
8262      ReporterConfig::ReporterConfig( IConfigPtr const&amp; _fullConfig, std::ostream&amp; _stream )
8263      :   m_stream( &amp;_stream ), m_fullConfig( _fullConfig ) {}
8264      std::ostream&amp; ReporterConfig::stream() const { return *m_stream; }
8265      IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
8266      TestRunInfo::TestRunInfo( std::string const&amp; _name ) : name( _name ) {}
8267      GroupInfo::GroupInfo(  std::string const&amp; _name,
8268                             std::size_t _groupIndex,
8269                             std::size_t _groupsCount )
8270      :   name( _name ),
8271          groupIndex( _groupIndex ),
8272          groupsCounts( _groupsCount )
8273      {}
8274       AssertionStats::AssertionStats( AssertionResult const&amp; _assertionResult,
8275                                       std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,
8276                                       Totals const&amp; _totals )
8277      :   assertionResult( _assertionResult ),
8278          infoMessages( _infoMessages ),
8279          totals( _totals )
8280      {
8281          assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
8282          if( assertionResult.hasMessage() ) {
8283              MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
8284              builder &lt;&lt; assertionResult.getMessage();
8285              builder.m_info.message = builder.m_stream.str();
8286              infoMessages.push_back( builder.m_info );
8287          }
8288      }
8289       AssertionStats::~AssertionStats() = default;
8290      SectionStats::SectionStats(  SectionInfo const&amp; _sectionInfo,
8291                                   Counts const&amp; _assertions,
8292                                   double _durationInSeconds,
8293                                   bool _missingAssertions )
8294      :   sectionInfo( _sectionInfo ),
8295          assertions( _assertions ),
8296          durationInSeconds( _durationInSeconds ),
8297          missingAssertions( _missingAssertions )
8298      {}
8299      SectionStats::~SectionStats() = default;
8300      TestCaseStats::TestCaseStats(  TestCaseInfo const&amp; _testInfo,
8301                                     Totals const&amp; _totals,
8302                                     std::string const&amp; _stdOut,
8303                                     std::string const&amp; _stdErr,
8304                                     bool _aborting )
8305      : testInfo( _testInfo ),
8306          totals( _totals ),
8307          stdOut( _stdOut ),
8308          stdErr( _stdErr ),
8309          aborting( _aborting )
8310      {}
8311      TestCaseStats::~TestCaseStats() = default;
8312      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo,
8313                                      Totals const&amp; _totals,
8314                                      bool _aborting )
8315      :   groupInfo( _groupInfo ),
8316          totals( _totals ),
8317          aborting( _aborting )
8318      {}
8319      TestGroupStats::TestGroupStats( GroupInfo const&amp; _groupInfo )
8320      :   groupInfo( _groupInfo ),
8321          aborting( false )
8322      {}
8323      TestGroupStats::~TestGroupStats() = default;
8324      TestRunStats::TestRunStats(   TestRunInfo const&amp; _runInfo,
8325                      Totals const&amp; _totals,
8326                      bool _aborting )
8327      :   runInfo( _runInfo ),
8328          totals( _totals ),
8329          aborting( _aborting )
8330      {}
8331      TestRunStats::~TestRunStats() = default;
8332      void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
8333      bool IStreamingReporter::isMulti() const { return false; }
8334      IReporterFactory::~IReporterFactory() = default;
8335      IReporterRegistry::~IReporterRegistry() = default;
8336  } 
8337  namespace Catch {
8338      IRunner::~IRunner() = default;
8339  }
8340  namespace Catch {
8341      ITestInvoker::~ITestInvoker() = default;
8342      ITestCaseRegistry::~ITestCaseRegistry() = default;
8343  }
8344  #ifdef CATCH_CONFIG_WINDOWS_CRTDBG
8345  #include &lt;crtdbg.h&gt;
8346  namespace Catch {
8347      LeakDetector::LeakDetector() {
8348          int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
8349          flag |= _CRTDBG_LEAK_CHECK_DF;
8350          flag |= _CRTDBG_ALLOC_MEM_DF;
8351          _CrtSetDbgFlag(flag);
8352          _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
8353          _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
8354          _CrtSetBreakAlloc(-1);
8355      }
8356  }
8357  #else
8358      Catch::LeakDetector::LeakDetector() {}
8359  #endif
8360  Catch::LeakDetector::~LeakDetector() {
8361      Catch::cleanUp();
8362  }
8363  #include &lt;set&gt;
8364  namespace Catch {
8365      std::size_t listTests( Config const&amp; config );
8366      std::size_t listTestsNamesOnly( Config const&amp; config );
8367      struct TagInfo {
8368          void add( std::string const&amp; spelling );
8369          std::string all() const;
8370          std::set&lt;std::string&gt; spellings;
8371          std::size_t count = 0;
8372      };
8373      std::size_t listTags( Config const&amp; config );
8374      std::size_t listReporters();
8375      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config );
8376  } 
8377  namespace Catch {
8378      using namespace clara::TextFlow;
8379  }
8380  #include &lt;limits&gt;
8381  #include &lt;algorithm&gt;
8382  #include &lt;iomanip&gt;
8383  namespace Catch {
8384      std::size_t listTests( Config const&amp; config ) {
8385          TestSpec const&amp; testSpec = config.testSpec();
8386          if( config.hasTestFilters() )
8387              Catch::cout() &lt;&lt; &quot;Matching test cases:\n&quot;;
8388          else {
8389              Catch::cout() &lt;&lt; &quot;All available test cases:\n&quot;;
8390          }
8391          auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8392          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8393              Colour::Code colour = testCaseInfo.isHidden()
8394                  ? Colour::SecondaryText
8395                  : Colour::None;
8396              Colour colourGuard( colour );
8397              Catch::cout() &lt;&lt; Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) &lt;&lt; &quot;\n&quot;;
8398              if( config.verbosity() &gt;= Verbosity::High ) {
8399                  Catch::cout() &lt;&lt; Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) &lt;&lt; std::endl;
8400                  std::string description = testCaseInfo.description;
8401                  if( description.empty() )
8402                      description = &quot;(NO DESCRIPTION)&quot;;
8403                  Catch::cout() &lt;&lt; Column( description ).indent(4) &lt;&lt; std::endl;
8404              }
8405              if( !testCaseInfo.tags.empty() )
8406                  Catch::cout() &lt;&lt; Column( testCaseInfo.tagsAsString() ).indent( 6 ) &lt;&lt; &quot;\n&quot;;
8407          }
8408          if( !config.hasTestFilters() )
8409              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8410          else
8411              Catch::cout() &lt;&lt; pluralise( matchedTestCases.size(), &quot;matching test case&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8412          return matchedTestCases.size();
8413      }
8414      std::size_t listTestsNamesOnly( Config const&amp; config ) {
8415          TestSpec const&amp; testSpec = config.testSpec();
8416          std::size_t matchedTests = 0;
8417          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8418          for( auto const&amp; testCaseInfo : matchedTestCases ) {
8419              matchedTests++;
8420              if( startsWith( testCaseInfo.name, &#x27;#&#x27; ) )
8421                 Catch::cout() &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; testCaseInfo.name &lt;&lt; &#x27;&quot;&#x27;;
8422              else
8423                 Catch::cout() &lt;&lt; testCaseInfo.name;
8424              if ( config.verbosity() &gt;= Verbosity::High )
8425                  Catch::cout() &lt;&lt; &quot;\t@&quot; &lt;&lt; testCaseInfo.lineInfo;
8426              Catch::cout() &lt;&lt; std::endl;
8427          }
8428          return matchedTests;
8429      }
8430      void TagInfo::add( std::string const&amp; spelling ) {
8431          ++count;
8432          spellings.insert( spelling );
8433      }
8434      std::string TagInfo::all() const {
8435          size_t size = 0;
8436          for (auto const&amp; spelling : spellings) {
8437              size += spelling.size() + 2;
8438          }
8439          std::string out; out.reserve(size);
8440          for (auto const&amp; spelling : spellings) {
8441              out += &#x27;[&#x27;;
8442              out += spelling;
8443              out += &#x27;]&#x27;;
8444          }
8445          return out;
8446      }
8447      std::size_t listTags( Config const&amp; config ) {
8448          TestSpec const&amp; testSpec = config.testSpec();
8449          if( config.hasTestFilters() )
8450              Catch::cout() &lt;&lt; &quot;Tags for matching test cases:\n&quot;;
8451          else {
8452              Catch::cout() &lt;&lt; &quot;All available tags:\n&quot;;
8453          }
8454          std::map&lt;std::string, TagInfo&gt; tagCounts;
8455          std::vector&lt;TestCase&gt; matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8456          for( auto const&amp; testCase : matchedTestCases ) {
8457              for( auto const&amp; tagName : testCase.getTestCaseInfo().tags ) {
8458                  std::string lcaseTagName = toLower( tagName );
8459                  auto countIt = tagCounts.find( lcaseTagName );
8460                  if( countIt == tagCounts.end() )
8461                      countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
8462                  countIt-&gt;second.add( tagName );
8463              }
8464          }
8465          for( auto const&amp; tagCount : tagCounts ) {
8466              ReusableStringStream rss;
8467              rss &lt;&lt; &quot;  &quot; &lt;&lt; std::setw(2) &lt;&lt; tagCount.second.count &lt;&lt; &quot;  &quot;;
8468              auto str = rss.str();
8469              auto wrapper = Column( tagCount.second.all() )
8470                                                      .initialIndent( 0 )
8471                                                      .indent( str.size() )
8472                                                      .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
8473              Catch::cout() &lt;&lt; str &lt;&lt; wrapper &lt;&lt; &#x27;\n&#x27;;
8474          }
8475          Catch::cout() &lt;&lt; pluralise( tagCounts.size(), &quot;tag&quot; ) &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
8476          return tagCounts.size();
8477      }
8478      std::size_t listReporters() {
8479          Catch::cout() &lt;&lt; &quot;Available reporters:\n&quot;;
8480          IReporterRegistry::FactoryMap const&amp; factories = getRegistryHub().getReporterRegistry().getFactories();
8481          std::size_t maxNameLen = 0;
8482          for( auto const&amp; factoryKvp : factories )
8483              maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
8484          for( auto const&amp; factoryKvp : factories ) {
8485              Catch::cout()
8486                      &lt;&lt; Column( factoryKvp.first + &quot;:&quot; )
8487                              .indent(2)
8488                              .width( 5+maxNameLen )
8489                      +  Column( factoryKvp.second-&gt;getDescription() )
8490                              .initialIndent(0)
8491                              .indent(2)
8492                              .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
8493                      &lt;&lt; &quot;\n&quot;;
8494          }
8495          Catch::cout() &lt;&lt; std::endl;
8496          return factories.size();
8497      }
8498      Option&lt;std::size_t&gt; list( std::shared_ptr&lt;Config&gt; const&amp; config ) {
8499          Option&lt;std::size_t&gt; listedCount;
8500          getCurrentMutableContext().setConfig( config );
8501          if( config-&gt;listTests() )
8502              listedCount = listedCount.valueOr(0) + listTests( *config );
8503          if( config-&gt;listTestNamesOnly() )
8504              listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );
8505          if( config-&gt;listTags() )
8506              listedCount = listedCount.valueOr(0) + listTags( *config );
8507          if( config-&gt;listReporters() )
8508              listedCount = listedCount.valueOr(0) + listReporters();
8509          return listedCount;
8510      }
8511  } 
8512  namespace Catch {
8513  namespace Matchers {
8514      namespace Impl {
8515          std::string MatcherUntypedBase::toString() const {
8516              if( m_cachedToString.empty() )
8517                  m_cachedToString = describe();
8518              return m_cachedToString;
8519          }
8520          MatcherUntypedBase::~MatcherUntypedBase() = default;
8521      } 
8522  } 
8523  using namespace Matchers;
8524  using Matchers::Impl::MatcherBase;
8525  } 
8526  namespace Catch {
8527  namespace Matchers {
8528  namespace Exception {
8529  bool ExceptionMessageMatcher::match(std::exception const&amp; ex) const {
8530      return ex.what() == m_message;
8531  }
8532  std::string ExceptionMessageMatcher::describe() const {
8533      return &quot;exception message matches \&quot;&quot; + m_message + &quot;\&quot;&quot;;
8534  }
8535  }
8536  Exception::ExceptionMessageMatcher Message(std::string const&amp; message) {
8537      return Exception::ExceptionMessageMatcher(message);
8538  }
8539  } 
8540  } 
8541  namespace Catch {
8542      bool isnan(float f);
8543      bool isnan(double d);
8544  }
8545  #include &lt;string&gt;
8546  namespace Catch {
8547      template &lt;typename T&gt;
8548      std::string to_string(T const&amp; t) {
8549  #if defined(CATCH_CONFIG_CPP11_TO_STRING)
8550          return std::to_string(t);
8551  #else
8552          ReusableStringStream rss;
8553          rss &lt;&lt; t;
8554          return rss.str();
8555  #endif
8556      }
8557  } 
8558  #include &lt;algorithm&gt;
8559  #include &lt;cmath&gt;
8560  #include &lt;cstdlib&gt;
8561  #include &lt;cstdint&gt;
8562  #include &lt;cstring&gt;
8563  #include &lt;sstream&gt;
8564  #include &lt;type_traits&gt;
8565  #include &lt;iomanip&gt;
8566  #include &lt;limits&gt;
8567  namespace Catch {
8568  namespace {
8569      int32_t convert(float f) {
8570          static_assert(sizeof(float) == sizeof(int32_t), &quot;Important ULP matcher assumption violated&quot;);
8571          int32_t i;
8572          std::memcpy(&amp;i, &amp;f, sizeof(f));
8573          return i;
8574      }
8575      int64_t convert(double d) {
8576          static_assert(sizeof(double) == sizeof(int64_t), &quot;Important ULP matcher assumption violated&quot;);
8577          int64_t i;
8578          std::memcpy(&amp;i, &amp;d, sizeof(d));
8579          return i;
8580      }
8581      template &lt;typename FP&gt;
8582      bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
8583          if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
8584              return false;
8585          }
8586          auto lc = convert(lhs);
8587          auto rc = convert(rhs);
8588          if ((lc &lt; 0) != (rc &lt; 0)) {
8589              return lhs == rhs;
8590          }
8591          auto ulpDiff = std::abs(static_cast&lt;FP&gt;(lc - rc));
8592          return static_cast&lt;uint64_t&gt;(ulpDiff) &lt;= maxUlpDiff;
8593      }
8594  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8595      float nextafter(float x, float y) {
8596          return ::nextafterf(x, y);
8597      }
8598      double nextafter(double x, double y) {
8599          return ::nextafter(x, y);
8600      }
8601  #endif 
8602  template &lt;typename FP&gt;
8603  FP step(FP start, FP direction, uint64_t steps) {
8604      for (uint64_t i = 0; i &lt; steps; ++i) {
8605  #if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
8606          start = Catch::nextafter(start, direction);
8607  #else
8608          start = std::nextafter(start, direction);
8609  #endif
8610      }
8611      return start;
8612  }
8613  bool marginComparison(double lhs, double rhs, double margin) {
8614      return (lhs + margin &gt;= rhs) &amp;&amp; (rhs + margin &gt;= lhs);
8615  }
8616  template &lt;typename FloatingPoint&gt;
8617  void write(std::ostream&amp; out, FloatingPoint num) {
8618      out &lt;&lt; std::scientific
8619          &lt;&lt; std::setprecision(std::numeric_limits&lt;FloatingPoint&gt;::max_digits10 - 1)
8620          &lt;&lt; num;
8621  }
8622  } 
8623  namespace Matchers {
8624  namespace Floating {
8625      enum class FloatingPointKind : uint8_t {
8626          Float,
8627          Double
8628      };
8629      WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
8630          :m_target{ target }, m_margin{ margin } {
8631          CATCH_ENFORCE(margin &gt;= 0, &quot;Invalid margin: &quot; &lt;&lt; margin &lt;&lt; &#x27;.&#x27;
8632              &lt;&lt; &quot; Margin has to be non-negative.&quot;);
8633      }
8634      bool WithinAbsMatcher::match(double const&amp; matchee) const {
8635          return (matchee + m_margin &gt;= m_target) &amp;&amp; (m_target + m_margin &gt;= matchee);
8636      }
8637      std::string WithinAbsMatcher::describe() const {
8638          return &quot;is within &quot; + ::Catch::Detail::stringify(m_margin) + &quot; of &quot; + ::Catch::Detail::stringify(m_target);
8639      }
8640      WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType)
8641          :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
8642          CATCH_ENFORCE(m_type == FloatingPointKind::Double
8643                     || m_ulps &lt; (std::numeric_limits&lt;uint32_t&gt;::max)(),
8644              &quot;Provided ULP is impossibly large for a float comparison.&quot;);
8645      }
8646  #if defined(__clang__)
8647  #pragma clang diagnostic push
8648  #pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;
8649  #endif
8650      bool WithinUlpsMatcher::match(double const&amp; matchee) const {
8651          switch (m_type) {
8652          case FloatingPointKind::Float:
8653              return almostEqualUlps&lt;float&gt;(static_cast&lt;float&gt;(matchee), static_cast&lt;float&gt;(m_target), m_ulps);
8654          case FloatingPointKind::Double:
8655              return almostEqualUlps&lt;double&gt;(matchee, m_target, m_ulps);
8656          default:
8657              CATCH_INTERNAL_ERROR( &quot;Unknown FloatingPointKind value&quot; );
8658          }
8659      }
8660  #if defined(__clang__)
8661  #pragma clang diagnostic pop
8662  #endif
8663      std::string WithinUlpsMatcher::describe() const {
8664          std::stringstream ret;
8665          ret &lt;&lt; &quot;is within &quot; &lt;&lt; m_ulps &lt;&lt; &quot; ULPs of &quot;;
8666          if (m_type == FloatingPointKind::Float) {
8667              write(ret, static_cast&lt;float&gt;(m_target));
8668              ret &lt;&lt; &#x27;f&#x27;;
8669          } else {
8670              write(ret, m_target);
8671          }
8672          ret &lt;&lt; &quot; ([&quot;;
8673          if (m_type == FloatingPointKind::Double) {
8674              write(ret, step(m_target, static_cast&lt;double&gt;(-INFINITY), m_ulps));
8675              ret &lt;&lt; &quot;, &quot;;
8676              write(ret, step(m_target, static_cast&lt;double&gt;( INFINITY), m_ulps));
8677          } else {
8678              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;(-INFINITY), m_ulps));
8679              ret &lt;&lt; &quot;, &quot;;
8680              write(ret, step(static_cast&lt;float&gt;(m_target), static_cast&lt;float&gt;( INFINITY), m_ulps));
8681          }
8682          ret &lt;&lt; &quot;])&quot;;
8683          return ret.str();
8684      }
8685      WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
8686          m_target(target),
8687          m_epsilon(epsilon){
8688          CATCH_ENFORCE(m_epsilon &gt;= 0., &quot;Relative comparison with epsilon &lt;  0 does not make sense.&quot;);
8689          CATCH_ENFORCE(m_epsilon  &lt; 1., &quot;Relative comparison with epsilon &gt;= 1 does not make sense.&quot;);
8690      }
8691      bool WithinRelMatcher::match(double const&amp; matchee) const {
8692          const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
8693          return marginComparison(matchee, m_target,
8694                                  std::isinf(relMargin)? 0 : relMargin);
8695      }
8696      std::string WithinRelMatcher::describe() const {
8697          Catch::ReusableStringStream sstr;
8698          sstr &lt;&lt; &quot;and &quot; &lt;&lt; m_target &lt;&lt; &quot; are within &quot; &lt;&lt; m_epsilon * 100. &lt;&lt; &quot;% of each other&quot;;
8699          return sstr.str();
8700      }
8701  }
8702  Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
8703      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
8704  }
8705  Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
8706      return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
8707  }
8708  Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
8709      return Floating::WithinAbsMatcher(target, margin);
8710  }
8711  Floating::WithinRelMatcher WithinRel(double target, double eps) {
8712      return Floating::WithinRelMatcher(target, eps);
8713  }
8714  Floating::WithinRelMatcher WithinRel(double target) {
8715      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;double&gt;::epsilon() * 100);
8716  }
8717  Floating::WithinRelMatcher WithinRel(float target, float eps) {
8718      return Floating::WithinRelMatcher(target, eps);
8719  }
8720  Floating::WithinRelMatcher WithinRel(float target) {
8721      return Floating::WithinRelMatcher(target, std::numeric_limits&lt;float&gt;::epsilon() * 100);
8722  }
8723  } 
8724  } 
8725  std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string&amp; desc) {
8726      if (desc.empty()) {
8727          return &quot;matches undescribed predicate&quot;;
8728      } else {
8729          return &quot;matches predicate: \&quot;&quot; + desc + &#x27;&quot;&#x27;;
8730      }
8731  }
8732  #include &lt;regex&gt;
8733  namespace Catch {
8734  namespace Matchers {
8735      namespace StdString {
8736          CasedString::CasedString( std::string const&amp; str, CaseSensitive::Choice caseSensitivity )
8737          :   m_caseSensitivity( caseSensitivity ),
8738              m_str( adjustString( str ) )
8739          {}
8740          std::string CasedString::adjustString( std::string const&amp; str ) const {
8741              return m_caseSensitivity == CaseSensitive::No
8742                     ? toLower( str )
8743                     : str;
8744          }
8745          std::string CasedString::caseSensitivitySuffix() const {
8746              return m_caseSensitivity == CaseSensitive::No
8747                     ? &quot; (case insensitive)&quot;
8748                     : std::string();
8749          }
8750          StringMatcherBase::StringMatcherBase( std::string const&amp; operation, CasedString const&amp; comparator )
8751          : m_comparator( comparator ),
8752            m_operation( operation ) {
8753          }
8754          std::string StringMatcherBase::describe() const {
8755              std::string description;
8756              description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
8757                                          m_comparator.caseSensitivitySuffix().size());
8758              description += m_operation;
8759              description += &quot;: \&quot;&quot;;
8760              description += m_comparator.m_str;
8761              description += &quot;\&quot;&quot;;
8762              description += m_comparator.caseSensitivitySuffix();
8763              return description;
8764          }
8765          EqualsMatcher::EqualsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;equals&quot;, comparator ) {}
8766          bool EqualsMatcher::match( std::string const&amp; source ) const {
8767              return m_comparator.adjustString( source ) == m_comparator.m_str;
8768          }
8769          ContainsMatcher::ContainsMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;contains&quot;, comparator ) {}
8770          bool ContainsMatcher::match( std::string const&amp; source ) const {
8771              return contains( m_comparator.adjustString( source ), m_comparator.m_str );
8772          }
8773          StartsWithMatcher::StartsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;starts with&quot;, comparator ) {}
8774          bool StartsWithMatcher::match( std::string const&amp; source ) const {
8775              return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8776          }
8777          EndsWithMatcher::EndsWithMatcher( CasedString const&amp; comparator ) : StringMatcherBase( &quot;ends with&quot;, comparator ) {}
8778          bool EndsWithMatcher::match( std::string const&amp; source ) const {
8779              return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8780          }
8781          RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
8782          bool RegexMatcher::match(std::string const&amp; matchee) const {
8783              auto flags = std::regex::ECMAScript; 
8784              if (m_caseSensitivity == CaseSensitive::Choice::No) {
8785                  flags |= std::regex::icase;
8786              }
8787              auto reg = std::regex(m_regex, flags);
8788              return std::regex_match(matchee, reg);
8789          }
8790          std::string RegexMatcher::describe() const {
8791              return &quot;matches &quot; + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? &quot; case sensitively&quot; : &quot; case insensitively&quot;);
8792          }
8793      } 
8794      StdString::EqualsMatcher Equals( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8795          return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
8796      }
8797      StdString::ContainsMatcher Contains( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8798          return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
8799      }
8800      StdString::EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8801          return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8802      }
8803      StdString::StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive::Choice caseSensitivity ) {
8804          return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8805      }
8806      StdString::RegexMatcher Matches(std::string const&amp; regex, CaseSensitive::Choice caseSensitivity) {
8807          return StdString::RegexMatcher(regex, caseSensitivity);
8808      }
8809  } 
8810  } 
8811  namespace Catch {
8812      bool uncaught_exceptions();
8813  } 
8814  #include &lt;cassert&gt;
8815  #include &lt;stack&gt;
8816  namespace Catch {
8817      MessageInfo::MessageInfo(   StringRef const&amp; _macroName,
8818                                  SourceLineInfo const&amp; _lineInfo,
8819                                  ResultWas::OfType _type )
8820      :   macroName( _macroName ),
8821          lineInfo( _lineInfo ),
8822          type( _type ),
8823          sequence( ++globalCount )
8824      {}
8825      bool MessageInfo::operator==( MessageInfo const&amp; other ) const {
8826          return sequence == other.sequence;
8827      }
8828      bool MessageInfo::operator&lt;( MessageInfo const&amp; other ) const {
8829          return sequence &lt; other.sequence;
8830      }
8831      unsigned int MessageInfo::globalCount = 0;
8832      Catch::MessageBuilder::MessageBuilder( StringRef const&amp; macroName,
8833                                             SourceLineInfo const&amp; lineInfo,
8834                                             ResultWas::OfType type )
8835          :m_info(macroName, lineInfo, type) {}
8836      ScopedMessage::ScopedMessage( MessageBuilder const&amp; builder )
8837      : m_info( builder.m_info ), m_moved()
8838      {
8839          m_info.message = builder.m_stream.str();
8840          getResultCapture().pushScopedMessage( m_info );
8841      }
8842      ScopedMessage::ScopedMessage( ScopedMessage&amp;&amp; old )
8843      : m_info( old.m_info ), m_moved()
8844      {
8845          old.m_moved = true;
8846      }
8847      ScopedMessage::~ScopedMessage() {
8848          if ( !uncaught_exceptions() &amp;&amp; !m_moved ){
8849              getResultCapture().popScopedMessage(m_info);
8850          }
8851      }
8852      Capturer::Capturer( StringRef macroName, SourceLineInfo const&amp; lineInfo, ResultWas::OfType resultType, StringRef names ) {
8853          auto trimmed = [&amp;] (size_t start, size_t end) {
8854              while (names[start] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[start]))) {
8855                  ++start;
8856              }
8857              while (names[end] == &#x27;,&#x27; || isspace(static_cast&lt;unsigned char&gt;(names[end]))) {
8858                  --end;
8859              }
8860              return names.substr(start, end - start + 1);
8861          };
8862          auto skipq = [&amp;] (size_t start, char quote) {
8863              for (auto i = start + 1; i &lt; names.size() ; ++i) {
8864                  if (names[i] == quote)
8865                      return i;
8866                  if (names[i] == &#x27;\\&#x27;)
8867                      ++i;
8868              }
8869              CATCH_INTERNAL_ERROR(&quot;CAPTURE parsing encountered unmatched quote&quot;);
8870          };
8871          size_t start = 0;
8872          std::stack&lt;char&gt; openings;
8873          for (size_t pos = 0; pos &lt; names.size(); ++pos) {
8874              char c = names[pos];
8875              switch (c) {
8876              case &#x27;[&#x27;:
8877              case &#x27;{&#x27;:
8878              case &#x27;(&#x27;:
8879                  openings.push(c);
8880                  break;
8881              case &#x27;]&#x27;:
8882              case &#x27;}&#x27;:
8883              case &#x27;)&#x27;:
8884                  openings.pop();
8885                  break;
8886              case &#x27;&quot;&#x27;:
8887              case &#x27;\&#x27;&#x27;:
8888                  pos = skipq(pos, c);
8889                  break;
8890              case &#x27;,&#x27;:
8891                  if (start != pos &amp;&amp; openings.empty()) {
8892                      m_messages.emplace_back(macroName, lineInfo, resultType);
8893                      m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, pos));
8894                      m_messages.back().message += &quot; := &quot;;
8895                      start = pos;
8896                  }
8897              }
8898          }
8899          assert(openings.empty() &amp;&amp; &quot;Mismatched openings&quot;);
8900          m_messages.emplace_back(macroName, lineInfo, resultType);
8901          m_messages.back().message = static_cast&lt;std::string&gt;(trimmed(start, names.size() - 1));
8902          m_messages.back().message += &quot; := &quot;;
8903      }
8904      Capturer::~Capturer() {
8905          if ( !uncaught_exceptions() ){
8906              assert( m_captured == m_messages.size() );
8907              for( size_t i = 0; i &lt; m_captured; ++i  )
8908                  m_resultCapture.popScopedMessage( m_messages[i] );
8909          }
8910      }
8911      void Capturer::captureValue( size_t index, std::string const&amp; value ) {
8912          assert( index &lt; m_messages.size() );
8913          m_messages[index].message += value;
8914          m_resultCapture.pushScopedMessage( m_messages[index] );
8915          m_captured++;
8916      }
8917  } 
8918  #ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8919  #define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8920  #include &lt;cstdio&gt;
8921  #include &lt;iosfwd&gt;
8922  #include &lt;string&gt;
8923  namespace Catch {
8924      class RedirectedStream {
8925          std::ostream&amp; m_originalStream;
8926          std::ostream&amp; m_redirectionStream;
8927          std::streambuf* m_prevBuf;
8928      public:
8929          RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream );
8930          ~RedirectedStream();
8931      };
8932      class RedirectedStdOut {
8933          ReusableStringStream m_rss;
8934          RedirectedStream m_cout;
8935      public:
8936          RedirectedStdOut();
8937          auto str() const -&gt; std::string;
8938      };
8939      class RedirectedStdErr {
8940          ReusableStringStream m_rss;
8941          RedirectedStream m_cerr;
8942          RedirectedStream m_clog;
8943      public:
8944          RedirectedStdErr();
8945          auto str() const -&gt; std::string;
8946      };
8947      class RedirectedStreams {
8948      public:
8949          RedirectedStreams(RedirectedStreams const&amp;) = delete;
8950          RedirectedStreams&amp; operator=(RedirectedStreams const&amp;) = delete;
8951          RedirectedStreams(RedirectedStreams&amp;&amp;) = delete;
8952          RedirectedStreams&amp; operator=(RedirectedStreams&amp;&amp;) = delete;
8953          RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr);
8954          ~RedirectedStreams();
8955      private:
8956          std::string&amp; m_redirectedCout;
8957          std::string&amp; m_redirectedCerr;
8958          RedirectedStdOut m_redirectedStdOut;
8959          RedirectedStdErr m_redirectedStdErr;
8960      };
8961  #if defined(CATCH_CONFIG_NEW_CAPTURE)
8962      class TempFile {
8963      public:
8964          TempFile(TempFile const&amp;) = delete;
8965          TempFile&amp; operator=(TempFile const&amp;) = delete;
8966          TempFile(TempFile&amp;&amp;) = delete;
8967          TempFile&amp; operator=(TempFile&amp;&amp;) = delete;
8968          TempFile();
8969          ~TempFile();
8970          std::FILE* getFile();
8971          std::string getContents();
8972      private:
8973          std::FILE* m_file = nullptr;
8974      #if defined(_MSC_VER)
8975          char m_buffer[L_tmpnam] = { 0 };
8976      #endif
8977      };
8978      class OutputRedirect {
8979      public:
8980          OutputRedirect(OutputRedirect const&amp;) = delete;
8981          OutputRedirect&amp; operator=(OutputRedirect const&amp;) = delete;
8982          OutputRedirect(OutputRedirect&amp;&amp;) = delete;
8983          OutputRedirect&amp; operator=(OutputRedirect&amp;&amp;) = delete;
8984          OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest);
8985          ~OutputRedirect();
8986      private:
8987          int m_originalStdout = -1;
8988          int m_originalStderr = -1;
8989          TempFile m_stdoutFile;
8990          TempFile m_stderrFile;
8991          std::string&amp; m_stdoutDest;
8992          std::string&amp; m_stderrDest;
8993      };
8994  #endif
8995  } 
8996  #endif 
8997  #include &lt;cstdio&gt;
8998  #include &lt;cstring&gt;
8999  #include &lt;fstream&gt;
9000  #include &lt;sstream&gt;
9001  #include &lt;stdexcept&gt;
9002  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9003      #if defined(_MSC_VER)
9004      #include &lt;io.h&gt;      
9005      #define dup _dup
9006      #define dup2 _dup2
9007      #define fileno _fileno
9008      #else
9009      #include &lt;unistd.h&gt;  
9010      #endif
9011  #endif
9012  namespace Catch {
9013      RedirectedStream::RedirectedStream( std::ostream&amp; originalStream, std::ostream&amp; redirectionStream )
9014      :   m_originalStream( originalStream ),
9015          m_redirectionStream( redirectionStream ),
9016          m_prevBuf( m_originalStream.rdbuf() )
9017      {
9018          m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
9019      }
9020      RedirectedStream::~RedirectedStream() {
9021          m_originalStream.rdbuf( m_prevBuf );
9022      }
9023      RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
9024      auto RedirectedStdOut::str() const -&gt; std::string { return m_rss.str(); }
9025      RedirectedStdErr::RedirectedStdErr()
9026      :   m_cerr( Catch::cerr(), m_rss.get() ),
9027          m_clog( Catch::clog(), m_rss.get() )
9028      {}
9029      auto RedirectedStdErr::str() const -&gt; std::string { return m_rss.str(); }
9030      RedirectedStreams::RedirectedStreams(std::string&amp; redirectedCout, std::string&amp; redirectedCerr)
9031      :   m_redirectedCout(redirectedCout),
9032          m_redirectedCerr(redirectedCerr)
9033      {}
9034      RedirectedStreams::~RedirectedStreams() {
9035          m_redirectedCout += m_redirectedStdOut.str();
9036          m_redirectedCerr += m_redirectedStdErr.str();
9037      }
9038  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9039  #if defined(_MSC_VER)
9040      TempFile::TempFile() {
9041          if (tmpnam_s(m_buffer)) {
9042              CATCH_RUNTIME_ERROR(&quot;Could not get a temp filename&quot;);
9043          }
9044          if (fopen_s(&amp;m_file, m_buffer, &quot;w+&quot;)) {
9045              char buffer[100];
9046              if (strerror_s(buffer, errno)) {
9047                  CATCH_RUNTIME_ERROR(&quot;Could not translate errno to a string&quot;);
9048              }
9049              CATCH_RUNTIME_ERROR(&quot;Could not open the temp file: &#x27;&quot; &lt;&lt; m_buffer &lt;&lt; &quot;&#x27; because: &quot; &lt;&lt; buffer);
9050          }
9051      }
9052  #else
9053      TempFile::TempFile() {
9054          m_file = std::tmpfile();
9055          if (!m_file) {
9056              CATCH_RUNTIME_ERROR(&quot;Could not create a temp file.&quot;);
9057          }
9058      }
9059  #endif
9060      TempFile::~TempFile() {
9061           std::fclose(m_file);
9062  #if defined(_MSC_VER)
9063           std::remove(m_buffer);
9064  #endif
9065      }
9066      FILE* TempFile::getFile() {
9067          return m_file;
9068      }
9069      std::string TempFile::getContents() {
9070          std::stringstream sstr;
9071          char buffer[100] = {};
9072          std::rewind(m_file);
9073          while (std::fgets(buffer, sizeof(buffer), m_file)) {
9074              sstr &lt;&lt; buffer;
9075          }
9076          return sstr.str();
9077      }
9078      OutputRedirect::OutputRedirect(std::string&amp; stdout_dest, std::string&amp; stderr_dest) :
9079          m_originalStdout(dup(1)),
9080          m_originalStderr(dup(2)),
9081          m_stdoutDest(stdout_dest),
9082          m_stderrDest(stderr_dest) {
9083          dup2(fileno(m_stdoutFile.getFile()), 1);
9084          dup2(fileno(m_stderrFile.getFile()), 2);
9085      }
9086      OutputRedirect::~OutputRedirect() {
9087          Catch::cout() &lt;&lt; std::flush;
9088          fflush(stdout);
9089          Catch::cerr() &lt;&lt; std::flush;
9090          Catch::clog() &lt;&lt; std::flush;
9091          fflush(stderr);
9092          dup2(m_originalStdout, 1);
9093          dup2(m_originalStderr, 2);
9094          m_stdoutDest += m_stdoutFile.getContents();
9095          m_stderrDest += m_stderrFile.getContents();
9096      }
9097  #endif 
9098  } 
9099  #if defined(CATCH_CONFIG_NEW_CAPTURE)
9100      #if defined(_MSC_VER)
9101      #undef dup
9102      #undef dup2
9103      #undef fileno
9104      #endif
9105  #endif
9106  #include &lt;cmath&gt;
9107  namespace Catch {
9108  #if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
9109      bool isnan(float f) {
9110          return std::isnan(f);
9111      }
9112      bool isnan(double d) {
9113          return std::isnan(d);
9114      }
9115  #else
9116      bool isnan(float f) {
9117          return std::_isnan(f);
9118      }
9119      bool isnan(double d) {
9120          return std::_isnan(d);
9121      }
9122  #endif
9123  } 
9124  namespace Catch {
9125  namespace {
9126  #if defined(_MSC_VER)
9127  #pragma warning(push)
9128  #pragma warning(disable:4146) 
9129  #endif
9130          uint32_t rotate_right(uint32_t val, uint32_t count) {
9131              const uint32_t mask = 31;
9132              count &amp;= mask;
9133              return (val &gt;&gt; count) | (val &lt;&lt; (-count &amp; mask));
9134          }
9135  #if defined(_MSC_VER)
9136  #pragma warning(pop)
9137  #endif
9138  }
9139      SimplePcg32::SimplePcg32(result_type seed_) {
9140          seed(seed_);
9141      }
9142      void SimplePcg32::seed(result_type seed_) {
9143          m_state = 0;
9144          (*this)();
9145          m_state += seed_;
9146          (*this)();
9147      }
9148      void SimplePcg32::discard(uint64_t skip) {
9149          for (uint64_t s = 0; s &lt; skip; ++s) {
9150              static_cast&lt;void&gt;((*this)());
9151          }
9152      }
9153      SimplePcg32::result_type SimplePcg32::operator()() {
9154          const uint32_t xorshifted = static_cast&lt;uint32_t&gt;(((m_state &gt;&gt; 18u) ^ m_state) &gt;&gt; 27u);
9155          const auto output = rotate_right(xorshifted, m_state &gt;&gt; 59u);
9156          m_state = m_state * 6364136223846793005ULL + s_inc;
9157          return output;
9158      }
9159      bool operator==(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9160          return lhs.m_state == rhs.m_state;
9161      }
9162      bool operator!=(SimplePcg32 const&amp; lhs, SimplePcg32 const&amp; rhs) {
9163          return lhs.m_state != rhs.m_state;
9164      }
9165  }
9166  #include &lt;vector&gt;
9167  #include &lt;set&gt;
9168  #include &lt;algorithm&gt;
9169  #include &lt;ios&gt;
9170  namespace Catch {
9171      class TestCase;
9172      struct IConfig;
9173      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases );
9174      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config );
9175      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config );
9176      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions );
9177      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );
9178      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );
9179      class TestRegistry : public ITestCaseRegistry {
9180      public:
9181          virtual ~TestRegistry() = default;
9182          virtual void registerTest( TestCase const&amp; testCase );
9183          std::vector&lt;TestCase&gt; const&amp; getAllTests() const override;
9184          std::vector&lt;TestCase&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const override;
9185      private:
9186          std::vector&lt;TestCase&gt; m_functions;
9187          mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
9188          mutable std::vector&lt;TestCase&gt; m_sortedFunctions;
9189          std::size_t m_unnamedCount = 0;
9190          std::ios_base::Init m_ostreamInit; 
9191      };
9192      class TestInvokerAsFunction : public ITestInvoker {
9193          void(*m_testAsFunction)();
9194      public:
9195          TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
9196          void invoke() const override;
9197      };
9198      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName );
9199  } 
9200  #include &lt;map&gt;
9201  namespace Catch {
9202      class ReporterRegistry : public IReporterRegistry {
9203      public:
9204          ~ReporterRegistry() override;
9205          IStreamingReporterPtr create( std::string const&amp; name, IConfigPtr const&amp; config ) const override;
9206          void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory );
9207          void registerListener( IReporterFactoryPtr const&amp; factory );
9208          FactoryMap const&amp; getFactories() const override;
9209          Listeners const&amp; getListeners() const override;
9210      private:
9211          FactoryMap m_factories;
9212          Listeners m_listeners;
9213      };
9214  }
9215  #include &lt;string&gt;
9216  namespace Catch {
9217      struct TagAlias {
9218          TagAlias(std::string const&amp; _tag, SourceLineInfo _lineInfo);
9219          std::string tag;
9220          SourceLineInfo lineInfo;
9221      };
9222  } 
9223  #include &lt;map&gt;
9224  namespace Catch {
9225      class TagAliasRegistry : public ITagAliasRegistry {
9226      public:
9227          ~TagAliasRegistry() override;
9228          TagAlias const* find( std::string const&amp; alias ) const override;
9229          std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const override;
9230          void add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo );
9231      private:
9232          std::map&lt;std::string, TagAlias&gt; m_registry;
9233      };
9234  } 
9235  #include &lt;vector&gt;
9236  #include &lt;exception&gt;
9237  namespace Catch {
9238      class StartupExceptionRegistry {
9239  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9240      public:
9241          void add(std::exception_ptr const&amp; exception) noexcept;
9242          std::vector&lt;std::exception_ptr&gt; const&amp; getExceptions() const noexcept;
9243      private:
9244          std::vector&lt;std::exception_ptr&gt; m_exceptions;
9245  #endif
9246      };
9247  } 
9248  namespace Catch {
9249      struct ISingleton {
9250          virtual ~ISingleton();
9251      };
9252      void addSingleton( ISingleton* singleton );
9253      void cleanupSingletons();
9254      template&lt;typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT&gt;
9255      class Singleton : SingletonImplT, public ISingleton {
9256          static auto getInternal() -&gt; Singleton* {
9257              static Singleton* s_instance = nullptr;
9258              if( !s_instance ) {
9259                  s_instance = new Singleton;
9260                  addSingleton( s_instance );
9261              }
9262              return s_instance;
9263          }
9264      public:
9265          static auto get() -&gt; InterfaceT const&amp; {
9266              return *getInternal();
9267          }
9268          static auto getMutable() -&gt; MutableInterfaceT&amp; {
9269              return *getInternal();
9270          }
9271      };
9272  } 
9273  namespace Catch {
9274      namespace {
9275          class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
9276                              private NonCopyable {
9277          public: 
9278              RegistryHub() = default;
9279              IReporterRegistry const&amp; getReporterRegistry() const override {
9280                  return m_reporterRegistry;
9281              }
9282              ITestCaseRegistry const&amp; getTestCaseRegistry() const override {
9283                  return m_testCaseRegistry;
9284              }
9285              IExceptionTranslatorRegistry const&amp; getExceptionTranslatorRegistry() const override {
9286                  return m_exceptionTranslatorRegistry;
9287              }
9288              ITagAliasRegistry const&amp; getTagAliasRegistry() const override {
9289                  return m_tagAliasRegistry;
9290              }
9291              StartupExceptionRegistry const&amp; getStartupExceptionRegistry() const override {
9292                  return m_exceptionRegistry;
9293              }
9294          public: 
9295              void registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) override {
9296                  m_reporterRegistry.registerReporter( name, factory );
9297              }
9298              void registerListener( IReporterFactoryPtr const&amp; factory ) override {
9299                  m_reporterRegistry.registerListener( factory );
9300              }
9301              void registerTest( TestCase const&amp; testInfo ) override {
9302                  m_testCaseRegistry.registerTest( testInfo );
9303              }
9304              void registerTranslator( const IExceptionTranslator* translator ) override {
9305                  m_exceptionTranslatorRegistry.registerTranslator( translator );
9306              }
9307              void registerTagAlias( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) override {
9308                  m_tagAliasRegistry.add( alias, tag, lineInfo );
9309              }
9310              void registerStartupException() noexcept override {
9311  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
9312                  m_exceptionRegistry.add(std::current_exception());
9313  #else
9314                  CATCH_INTERNAL_ERROR(&quot;Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;);
9315  #endif
9316              }
9317              IMutableEnumValuesRegistry&amp; getMutableEnumValuesRegistry() override {
9318                  return m_enumValuesRegistry;
9319              }
9320          private:
9321              TestRegistry m_testCaseRegistry;
9322              ReporterRegistry m_reporterRegistry;
9323              ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
9324              TagAliasRegistry m_tagAliasRegistry;
9325              StartupExceptionRegistry m_exceptionRegistry;
9326              Detail::EnumValuesRegistry m_enumValuesRegistry;
9327          };
9328      }
9329      using RegistryHubSingleton = Singleton&lt;RegistryHub, IRegistryHub, IMutableRegistryHub&gt;;
9330      IRegistryHub const&amp; getRegistryHub() {
9331          return RegistryHubSingleton::get();
9332      }
9333      IMutableRegistryHub&amp; getMutableRegistryHub() {
9334          return RegistryHubSingleton::getMutable();
9335      }
9336      void cleanUp() {
9337          cleanupSingletons();
9338          cleanUpContext();
9339      }
9340      std::string translateActiveException() {
9341          return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
9342      }
9343  } 
9344  namespace Catch {
9345      ReporterRegistry::~ReporterRegistry() = default;
9346      IStreamingReporterPtr ReporterRegistry::create( std::string const&amp; name, IConfigPtr const&amp; config ) const {
9347          auto it =  m_factories.find( name );
9348          if( it == m_factories.end() )
9349              return nullptr;
9350          return it-&gt;second-&gt;create( ReporterConfig( config ) );
9351      }
9352      void ReporterRegistry::registerReporter( std::string const&amp; name, IReporterFactoryPtr const&amp; factory ) {
9353          m_factories.emplace(name, factory);
9354      }
9355      void ReporterRegistry::registerListener( IReporterFactoryPtr const&amp; factory ) {
9356          m_listeners.push_back( factory );
9357      }
9358      IReporterRegistry::FactoryMap const&amp; ReporterRegistry::getFactories() const {
9359          return m_factories;
9360      }
9361      IReporterRegistry::Listeners const&amp; ReporterRegistry::getListeners() const {
9362          return m_listeners;
9363      }
9364  }
9365  namespace Catch {
9366      bool isOk( ResultWas::OfType resultType ) {
9367          return ( resultType &amp; ResultWas::FailureBit ) == 0;
9368      }
9369      bool isJustInfo( int flags ) {
9370          return flags == ResultWas::Info;
9371      }
9372      ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
9373          return static_cast&lt;ResultDisposition::Flags&gt;( static_cast&lt;int&gt;( lhs ) | static_cast&lt;int&gt;( rhs ) );
9374      }
9375      bool shouldContinueOnFailure( int flags )    { return ( flags &amp; ResultDisposition::ContinueOnFailure ) != 0; }
9376      bool shouldSuppressFailure( int flags )      { return ( flags &amp; ResultDisposition::SuppressFail ) != 0; }
9377  } 
9378  #include &lt;cassert&gt;
9379  #include &lt;algorithm&gt;
9380  #include &lt;sstream&gt;
9381  namespace Catch {
9382      namespace Generators {
9383          struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
9384              GeneratorBasePtr m_generator;
9385              GeneratorTracker( TestCaseTracking::NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
9386              :   TrackerBase( nameAndLocation, ctx, parent )
9387              {}
9388              ~GeneratorTracker();
9389              static GeneratorTracker&amp; acquire( TrackerContext&amp; ctx, TestCaseTracking::NameAndLocation const&amp; nameAndLocation ) {
9390                  std::shared_ptr&lt;GeneratorTracker&gt; tracker;
9391                  ITracker&amp; currentTracker = ctx.currentTracker();
9392                  if (currentTracker.nameAndLocation() == nameAndLocation) {
9393                      auto thisTracker = currentTracker.parent().findChild(nameAndLocation);
9394                      assert(thisTracker);
9395                      assert(thisTracker-&gt;isGeneratorTracker());
9396                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;(thisTracker);
9397                  } else if ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
9398                      assert( childTracker );
9399                      assert( childTracker-&gt;isGeneratorTracker() );
9400                      tracker = std::static_pointer_cast&lt;GeneratorTracker&gt;( childTracker );
9401                  } else {
9402                      tracker = std::make_shared&lt;GeneratorTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
9403                      currentTracker.addChild( tracker );
9404                  }
9405                  if( !tracker-&gt;isComplete() ) {
9406                      tracker-&gt;open();
9407                  }
9408                  return *tracker;
9409              }
9410              bool isGeneratorTracker() const override { return true; }
9411              auto hasGenerator() const -&gt; bool override {
9412                  return !!m_generator;
9413              }
9414              void close() override {
9415                  TrackerBase::close();
9416                  const bool should_wait_for_child = [&amp;]() {
9417                      if ( m_children.empty() ) {
9418                          return false;
9419                      }
9420                      if ( std::find_if(
9421                               m_children.begin(),
9422                               m_children.end(),
9423                               []( TestCaseTracking::ITrackerPtr tracker ) {
9424                                   return tracker-&gt;hasStarted();
9425                               } ) != m_children.end() ) {
9426                          return false;
9427                      }
9428                      auto* parent = m_parent;
9429                      while ( !parent-&gt;isSectionTracker() ) {
9430                          parent = &amp;( parent-&gt;parent() );
9431                      }
9432                      assert( parent &amp;&amp;
9433                              &quot;Missing root (test case) level section&quot; );
9434                      auto const&amp; parentSection =
9435                          static_cast&lt;SectionTracker&amp;&gt;( *parent );
9436                      auto const&amp; filters = parentSection.getFilters();
9437                      if ( filters.empty() ) {
9438                          return true;
9439                      }
9440                      for ( auto const&amp; child : m_children ) {
9441                          if ( child-&gt;isSectionTracker() &amp;&amp;
9442                               std::find( filters.begin(),
9443                                          filters.end(),
9444                                          static_cast&lt;SectionTracker&amp;&gt;( *child )
9445                                              .trimmedName() ) !=
9446                                   filters.end() ) {
9447                              return true;
9448                          }
9449                      }
9450                      return false;
9451                  }();
9452                  if ( should_wait_for_child ||
9453                       ( m_runState == CompletedSuccessfully &amp;&amp;
9454                         m_generator-&gt;next() ) ) {
9455                      m_children.clear();
9456                      m_runState = Executing;
9457                  }
9458              }
9459              auto getGenerator() const -&gt; GeneratorBasePtr const&amp; override {
9460                  return m_generator;
9461              }
9462              void setGenerator( GeneratorBasePtr&amp;&amp; generator ) override {
9463                  m_generator = std::move( generator );
9464              }
9465          };
9466          GeneratorTracker::~GeneratorTracker() {}
9467      }
9468      RunContext::RunContext(IConfigPtr const&amp; _config, IStreamingReporterPtr&amp;&amp; reporter)
9469      :   m_runInfo(_config-&gt;name()),
9470          m_context(getCurrentMutableContext()),
9471          m_config(_config),
9472          m_reporter(std::move(reporter)),
9473          m_lastAssertionInfo{ StringRef(), SourceLineInfo(&quot;&quot;,0), StringRef(), ResultDisposition::Normal },
9474          m_includeSuccessfulResults( m_config-&gt;includeSuccessfulResults() || m_reporter-&gt;getPreferences().shouldReportAllAssertions )
9475      {
9476          m_context.setRunner(this);
9477          m_context.setConfig(m_config);
9478          m_context.setResultCapture(this);
9479          m_reporter-&gt;testRunStarting(m_runInfo);
9480      }
9481      RunContext::~RunContext() {
9482          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
9483      }
9484      void RunContext::testGroupStarting(std::string const&amp; testSpec, std::size_t groupIndex, std::size_t groupsCount) {
9485          m_reporter-&gt;testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
9486      }
9487      void RunContext::testGroupEnded(std::string const&amp; testSpec, Totals const&amp; totals, std::size_t groupIndex, std::size_t groupsCount) {
9488          m_reporter-&gt;testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
9489      }
9490      Totals RunContext::runTest(TestCase const&amp; testCase) {
9491          Totals prevTotals = m_totals;
9492          std::string redirectedCout;
9493          std::string redirectedCerr;
9494          auto const&amp; testInfo = testCase.getTestCaseInfo();
9495          m_reporter-&gt;testCaseStarting(testInfo);
9496          m_activeTestCase = &amp;testCase;
9497          ITracker&amp; rootTracker = m_trackerContext.startRun();
9498          assert(rootTracker.isSectionTracker());
9499          static_cast&lt;SectionTracker&amp;&gt;(rootTracker).addInitialFilters(m_config-&gt;getSectionsToRun());
9500          do {
9501              m_trackerContext.startCycle();
9502              m_testCaseTracker = &amp;SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
9503              runCurrentTest(redirectedCout, redirectedCerr);
9504          } while (!m_testCaseTracker-&gt;isSuccessfullyCompleted() &amp;&amp; !aborting());
9505          Totals deltaTotals = m_totals.delta(prevTotals);
9506          if (testInfo.expectedToFail() &amp;&amp; deltaTotals.testCases.passed &gt; 0) {
9507              deltaTotals.assertions.failed++;
9508              deltaTotals.testCases.passed--;
9509              deltaTotals.testCases.failed++;
9510          }
9511          m_totals.testCases += deltaTotals.testCases;
9512          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9513                                    deltaTotals,
9514                                    redirectedCout,
9515                                    redirectedCerr,
9516                                    aborting()));
9517          m_activeTestCase = nullptr;
9518          m_testCaseTracker = nullptr;
9519          return deltaTotals;
9520      }
9521      IConfigPtr RunContext::config() const {
9522          return m_config;
9523      }
9524      IStreamingReporter&amp; RunContext::reporter() const {
9525          return *m_reporter;
9526      }
9527      void RunContext::assertionEnded(AssertionResult const &amp; result) {
9528          if (result.getResultType() == ResultWas::Ok) {
9529              m_totals.assertions.passed++;
9530              m_lastAssertionPassed = true;
9531          } else if (!result.isOk()) {
9532              m_lastAssertionPassed = false;
9533              if( m_activeTestCase-&gt;getTestCaseInfo().okToFail() )
9534                  m_totals.assertions.failedButOk++;
9535              else
9536                  m_totals.assertions.failed++;
9537          }
9538          else {
9539              m_lastAssertionPassed = true;
9540          }
9541          static_cast&lt;void&gt;(m_reporter-&gt;assertionEnded(AssertionStats(result, m_messages, m_totals)));
9542          if (result.getResultType() != ResultWas::Warning)
9543              m_messageScopes.clear();
9544          resetAssertionInfo();
9545          m_lastResult = result;
9546      }
9547      void RunContext::resetAssertionInfo() {
9548          m_lastAssertionInfo.macroName = StringRef();
9549          m_lastAssertionInfo.capturedExpression = &quot;{Unknown expression after the reported line}&quot;_sr;
9550      }
9551      bool RunContext::sectionStarted(SectionInfo const &amp; sectionInfo, Counts &amp; assertions) {
9552          ITracker&amp; sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
9553          if (!sectionTracker.isOpen())
9554              return false;
9555          m_activeSections.push_back(&amp;sectionTracker);
9556          m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
9557          m_reporter-&gt;sectionStarting(sectionInfo);
9558          assertions = m_totals.assertions;
9559          return true;
9560      }
9561      auto RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const&amp; lineInfo ) -&gt; IGeneratorTracker&amp; {
9562          using namespace Generators;
9563          GeneratorTracker&amp; tracker = GeneratorTracker::acquire(m_trackerContext,
9564                                                                TestCaseTracking::NameAndLocation( static_cast&lt;std::string&gt;(generatorName), lineInfo ) );
9565          m_lastAssertionInfo.lineInfo = lineInfo;
9566          return tracker;
9567      }
9568      bool RunContext::testForMissingAssertions(Counts&amp; assertions) {
9569          if (assertions.total() != 0)
9570              return false;
9571          if (!m_config-&gt;warnAboutMissingAssertions())
9572              return false;
9573          if (m_trackerContext.currentTracker().hasChildren())
9574              return false;
9575          m_totals.assertions.failed++;
9576          assertions.failed++;
9577          return true;
9578      }
9579      void RunContext::sectionEnded(SectionEndInfo const &amp; endInfo) {
9580          Counts assertions = m_totals.assertions - endInfo.prevAssertions;
9581          bool missingAssertions = testForMissingAssertions(assertions);
9582          if (!m_activeSections.empty()) {
9583              m_activeSections.back()-&gt;close();
9584              m_activeSections.pop_back();
9585          }
9586          m_reporter-&gt;sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
9587          m_messages.clear();
9588          m_messageScopes.clear();
9589      }
9590      void RunContext::sectionEndedEarly(SectionEndInfo const &amp; endInfo) {
9591          if (m_unfinishedSections.empty())
9592              m_activeSections.back()-&gt;fail();
9593          else
9594              m_activeSections.back()-&gt;close();
9595          m_activeSections.pop_back();
9596          m_unfinishedSections.push_back(endInfo);
9597      }
9598  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
9599      void RunContext::benchmarkPreparing(std::string const&amp; name) {
9600          m_reporter-&gt;benchmarkPreparing(name);
9601      }
9602      void RunContext::benchmarkStarting( BenchmarkInfo const&amp; info ) {
9603          m_reporter-&gt;benchmarkStarting( info );
9604      }
9605      void RunContext::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) {
9606          m_reporter-&gt;benchmarkEnded( stats );
9607      }
9608      void RunContext::benchmarkFailed(std::string const &amp; error) {
9609          m_reporter-&gt;benchmarkFailed(error);
9610      }
9611  #endif 
9612      void RunContext::pushScopedMessage(MessageInfo const &amp; message) {
9613          m_messages.push_back(message);
9614      }
9615      void RunContext::popScopedMessage(MessageInfo const &amp; message) {
9616          m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
9617      }
9618      void RunContext::emplaceUnscopedMessage( MessageBuilder const&amp; builder ) {
9619          m_messageScopes.emplace_back( builder );
9620      }
9621      std::string RunContext::getCurrentTestName() const {
9622          return m_activeTestCase
9623              ? m_activeTestCase-&gt;getTestCaseInfo().name
9624              : std::string();
9625      }
9626      const AssertionResult * RunContext::getLastResult() const {
9627          return &amp;(*m_lastResult);
9628      }
9629      void RunContext::exceptionEarlyReported() {
9630          m_shouldReportUnexpected = false;
9631      }
9632      void RunContext::handleFatalErrorCondition( StringRef message ) {
9633          m_reporter-&gt;fatalErrorEncountered(message);
9634          AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
9635          tempResult.message = static_cast&lt;std::string&gt;(message);
9636          AssertionResult result(m_lastAssertionInfo, tempResult);
9637          assertionEnded(result);
9638          handleUnfinishedSections();
9639          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9640          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9641          Counts assertions;
9642          assertions.failed = 1;
9643          SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
9644          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9645          auto const&amp; testInfo = m_activeTestCase-&gt;getTestCaseInfo();
9646          Totals deltaTotals;
9647          deltaTotals.testCases.failed = 1;
9648          deltaTotals.assertions.failed = 1;
9649          m_reporter-&gt;testCaseEnded(TestCaseStats(testInfo,
9650                                    deltaTotals,
9651                                    std::string(),
9652                                    std::string(),
9653                                    false));
9654          m_totals.testCases.failed++;
9655          testGroupEnded(std::string(), m_totals, 1, 1);
9656          m_reporter-&gt;testRunEnded(TestRunStats(m_runInfo, m_totals, false));
9657      }
9658      bool RunContext::lastAssertionPassed() {
9659           return m_lastAssertionPassed;
9660      }
9661      void RunContext::assertionPassed() {
9662          m_lastAssertionPassed = true;
9663          ++m_totals.assertions.passed;
9664          resetAssertionInfo();
9665          m_messageScopes.clear();
9666      }
9667      bool RunContext::aborting() const {
9668          return m_totals.assertions.failed &gt;= static_cast&lt;std::size_t&gt;(m_config-&gt;abortAfter());
9669      }
9670      void RunContext::runCurrentTest(std::string &amp; redirectedCout, std::string &amp; redirectedCerr) {
9671          auto const&amp; testCaseInfo = m_activeTestCase-&gt;getTestCaseInfo();
9672          SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9673          m_reporter-&gt;sectionStarting(testCaseSection);
9674          Counts prevAssertions = m_totals.assertions;
9675          double duration = 0;
9676          m_shouldReportUnexpected = true;
9677          m_lastAssertionInfo = { &quot;TEST_CASE&quot;_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
9678          seedRng(*m_config);
9679          Timer timer;
9680          CATCH_TRY {
9681              if (m_reporter-&gt;getPreferences().shouldRedirectStdOut) {
9682  #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
9683                  RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);
9684                  timer.start();
9685                  invokeActiveTestCase();
9686  #else
9687                  OutputRedirect r(redirectedCout, redirectedCerr);
9688                  timer.start();
9689                  invokeActiveTestCase();
9690  #endif
9691              } else {
9692                  timer.start();
9693                  invokeActiveTestCase();
9694              }
9695              duration = timer.getElapsedSeconds();
9696          } CATCH_CATCH_ANON (TestFailureException&amp;) {
9697          } CATCH_CATCH_ALL {
9698              if( m_shouldReportUnexpected ) {
9699                  AssertionReaction dummyReaction;
9700                  handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
9701              }
9702          }
9703          Counts assertions = m_totals.assertions - prevAssertions;
9704          bool missingAssertions = testForMissingAssertions(assertions);
9705          m_testCaseTracker-&gt;close();
9706          handleUnfinishedSections();
9707          m_messages.clear();
9708          m_messageScopes.clear();
9709          SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
9710          m_reporter-&gt;sectionEnded(testCaseSectionStats);
9711      }
9712      void RunContext::invokeActiveTestCase() {
9713          FatalConditionHandlerGuard _(&amp;m_fatalConditionhandler);
9714          m_activeTestCase-&gt;invoke();
9715      }
9716      void RunContext::handleUnfinishedSections() {
9717          for (auto it = m_unfinishedSections.rbegin(),
9718               itEnd = m_unfinishedSections.rend();
9719               it != itEnd;
9720               ++it)
9721              sectionEnded(*it);
9722          m_unfinishedSections.clear();
9723      }
9724      void RunContext::handleExpr(
9725          AssertionInfo const&amp; info,
9726          ITransientExpression const&amp; expr,
9727          AssertionReaction&amp; reaction
9728      ) {
9729          m_reporter-&gt;assertionStarting( info );
9730          bool negated = isFalseTest( info.resultDisposition );
9731          bool result = expr.getResult() != negated;
9732          if( result ) {
9733              if (!m_includeSuccessfulResults) {
9734                  assertionPassed();
9735              }
9736              else {
9737                  reportExpr(info, ResultWas::Ok, &amp;expr, negated);
9738              }
9739          }
9740          else {
9741              reportExpr(info, ResultWas::ExpressionFailed, &amp;expr, negated );
9742              populateReaction( reaction );
9743          }
9744      }
9745      void RunContext::reportExpr(
9746              AssertionInfo const &amp;info,
9747              ResultWas::OfType resultType,
9748              ITransientExpression const *expr,
9749              bool negated ) {
9750          m_lastAssertionInfo = info;
9751          AssertionResultData data( resultType, LazyExpression( negated ) );
9752          AssertionResult assertionResult{ info, data };
9753          assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
9754          assertionEnded( assertionResult );
9755      }
9756      void RunContext::handleMessage(
9757              AssertionInfo const&amp; info,
9758              ResultWas::OfType resultType,
9759              StringRef const&amp; message,
9760              AssertionReaction&amp; reaction
9761      ) {
9762          m_reporter-&gt;assertionStarting( info );
9763          m_lastAssertionInfo = info;
9764          AssertionResultData data( resultType, LazyExpression( false ) );
9765          data.message = static_cast&lt;std::string&gt;(message);
9766          AssertionResult assertionResult{ m_lastAssertionInfo, data };
9767          assertionEnded( assertionResult );
9768          if( !assertionResult.isOk() )
9769              populateReaction( reaction );
9770      }
9771      void RunContext::handleUnexpectedExceptionNotThrown(
9772              AssertionInfo const&amp; info,
9773              AssertionReaction&amp; reaction
9774      ) {
9775          handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
9776      }
9777      void RunContext::handleUnexpectedInflightException(
9778              AssertionInfo const&amp; info,
9779              std::string const&amp; message,
9780              AssertionReaction&amp; reaction
9781      ) {
9782          m_lastAssertionInfo = info;
9783          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9784          data.message = message;
9785          AssertionResult assertionResult{ info, data };
9786          assertionEnded( assertionResult );
9787          populateReaction( reaction );
9788      }
9789      void RunContext::populateReaction( AssertionReaction&amp; reaction ) {
9790          reaction.shouldDebugBreak = m_config-&gt;shouldDebugBreak();
9791          reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition &amp; ResultDisposition::Normal);
9792      }
9793      void RunContext::handleIncomplete(
9794              AssertionInfo const&amp; info
9795      ) {
9796          m_lastAssertionInfo = info;
9797          AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9798          data.message = &quot;Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE&quot;;
9799          AssertionResult assertionResult{ info, data };
9800          assertionEnded( assertionResult );
9801      }
9802      void RunContext::handleNonExpr(
9803              AssertionInfo const &amp;info,
9804              ResultWas::OfType resultType,
9805              AssertionReaction &amp;reaction
9806      ) {
9807          m_lastAssertionInfo = info;
9808          AssertionResultData data( resultType, LazyExpression( false ) );
9809          AssertionResult assertionResult{ info, data };
9810          assertionEnded( assertionResult );
9811          if( !assertionResult.isOk() )
9812              populateReaction( reaction );
9813      }
9814      IResultCapture&amp; getResultCapture() {
9815          if (auto* capture = getCurrentContext().getResultCapture())
9816              return *capture;
9817          else
9818              CATCH_INTERNAL_ERROR(&quot;No result capture instance&quot;);
9819      }
9820      void seedRng(IConfig const&amp; config) {
9821          if (config.rngSeed() != 0) {
9822              std::srand(config.rngSeed());
9823              rng().seed(config.rngSeed());
9824          }
9825      }
9826      unsigned int rngSeed() {
9827          return getCurrentContext().getConfig()-&gt;rngSeed();
9828      }
9829  }
9830  namespace Catch {
9831      Section::Section( SectionInfo const&amp; info )
9832      :   m_info( info ),
9833          m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
9834      {
9835          m_timer.start();
9836      }
9837      Section::~Section() {
9838          if( m_sectionIncluded ) {
9839              SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
9840              if( uncaught_exceptions() )
9841                  getResultCapture().sectionEndedEarly( endInfo );
9842              else
9843                  getResultCapture().sectionEnded( endInfo );
9844          }
9845      }
9846      Section::operator bool() const {
9847          return m_sectionIncluded;
9848      }
9849  } 
9850  namespace Catch {
9851      SectionInfo::SectionInfo
9852          (   SourceLineInfo const&amp; _lineInfo,
9853              std::string const&amp; _name )
9854      :   name( _name ),
9855          lineInfo( _lineInfo )
9856      {}
9857  } 
9858  #include &lt;memory&gt;
9859  namespace Catch {
9860      class Session : NonCopyable {
9861      public:
9862          Session();
9863          ~Session() override;
9864          void showHelp() const;
9865          void libIdentify();
9866          int applyCommandLine( int argc, char const * const * argv );
9867      #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
9868          int applyCommandLine( int argc, wchar_t const * const * argv );
9869      #endif
9870          void useConfigData( ConfigData const&amp; configData );
9871          template&lt;typename CharT&gt;
9872          int run(int argc, CharT const * const argv[]) {
9873              if (m_startupExceptions)
9874                  return 1;
9875              int returnCode = applyCommandLine(argc, argv);
9876              if (returnCode == 0)
9877                  returnCode = run();
9878              return returnCode;
9879          }
9880          int run();
9881          clara::Parser const&amp; cli() const;
9882          void cli( clara::Parser const&amp; newParser );
9883          ConfigData&amp; configData();
9884          Config&amp; config();
9885      private:
9886          int runInternal();
9887          clara::Parser m_cli;
9888          ConfigData m_configData;
9889          std::shared_ptr&lt;Config&gt; m_config;
9890          bool m_startupExceptions = false;
9891      };
9892  } 
9893  #include &lt;iosfwd&gt;
9894  namespace Catch {
9895      struct Version {
9896          Version( Version const&amp; ) = delete;
9897          Version&amp; operator=( Version const&amp; ) = delete;
9898          Version(    unsigned int _majorVersion,
9899                      unsigned int _minorVersion,
9900                      unsigned int _patchNumber,
9901                      char const * const _branchName,
9902                      unsigned int _buildNumber );
9903          unsigned int const majorVersion;
9904          unsigned int const minorVersion;
9905          unsigned int const patchNumber;
9906          char const * const branchName;
9907          unsigned int const buildNumber;
9908          friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version );
9909      };
9910      Version const&amp; libraryVersion();
9911  }
9912  #include &lt;cstdlib&gt;
9913  #include &lt;iomanip&gt;
9914  #include &lt;set&gt;
9915  #include &lt;iterator&gt;
9916  namespace Catch {
9917      namespace {
9918          const int MaxExitCode = 255;
9919          IStreamingReporterPtr createReporter(std::string const&amp; reporterName, IConfigPtr const&amp; config) {
9920              auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
9921              CATCH_ENFORCE(reporter, &quot;No reporter registered with name: &#x27;&quot; &lt;&lt; reporterName &lt;&lt; &quot;&#x27;&quot;);
9922              return reporter;
9923          }
9924          IStreamingReporterPtr makeReporter(std::shared_ptr&lt;Config&gt; const&amp; config) {
9925              if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
9926                  return createReporter(config-&gt;getReporterName(), config);
9927              }
9928              auto ret = std::unique_ptr&lt;IStreamingReporter&gt;(new ListeningReporter);
9929              auto&amp; multi = static_cast&lt;ListeningReporter&amp;&gt;(*ret);
9930              auto const&amp; listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
9931              for (auto const&amp; listener : listeners) {
9932                  multi.addListener(listener-&gt;create(Catch::ReporterConfig(config)));
9933              }
9934              multi.addReporter(createReporter(config-&gt;getReporterName(), config));
9935              return ret;
9936          }
9937          class TestGroup {
9938          public:
9939              explicit TestGroup(std::shared_ptr&lt;Config&gt; const&amp; config)
9940              : m_config{config}
9941              , m_context{config, makeReporter(config)}
9942              {
9943                  auto const&amp; allTestCases = getAllTestCasesSorted(*m_config);
9944                  m_matches = m_config-&gt;testSpec().matchesByFilter(allTestCases, *m_config);
9945                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9946                  if (m_matches.empty() &amp;&amp; invalidArgs.empty()) {
9947                      for (auto const&amp; test : allTestCases)
9948                          if (!test.isHidden())
9949                              m_tests.emplace(&amp;test);
9950                  } else {
9951                      for (auto const&amp; match : m_matches)
9952                          m_tests.insert(match.tests.begin(), match.tests.end());
9953                  }
9954              }
9955              Totals execute() {
9956                  auto const&amp; invalidArgs = m_config-&gt;testSpec().getInvalidArgs();
9957                  Totals totals;
9958                  m_context.testGroupStarting(m_config-&gt;name(), 1, 1);
9959                  for (auto const&amp; testCase : m_tests) {
9960                      if (!m_context.aborting())
9961                          totals += m_context.runTest(*testCase);
9962                      else
9963                          m_context.reporter().skipTest(*testCase);
9964                  }
9965                  for (auto const&amp; match : m_matches) {
9966                      if (match.tests.empty()) {
9967                          m_context.reporter().noMatchingTestCases(match.name);
9968                          totals.error = -1;
9969                      }
9970                  }
9971                  if (!invalidArgs.empty()) {
9972                      for (auto const&amp; invalidArg: invalidArgs)
9973                           m_context.reporter().reportInvalidArguments(invalidArg);
9974                  }
9975                  m_context.testGroupEnded(m_config-&gt;name(), totals, 1, 1);
9976                  return totals;
9977              }
9978          private:
9979              using Tests = std::set&lt;TestCase const*&gt;;
9980              std::shared_ptr&lt;Config&gt; m_config;
9981              RunContext m_context;
9982              Tests m_tests;
9983              TestSpec::Matches m_matches;
9984          };
9985          void applyFilenamesAsTags(Catch::IConfig const&amp; config) {
9986              auto&amp; tests = const_cast&lt;std::vector&lt;TestCase&gt;&amp;&gt;(getAllTestCasesSorted(config));
9987              for (auto&amp; testCase : tests) {
9988                  auto tags = testCase.tags;
9989                  std::string filename = testCase.lineInfo.file;
9990                  auto lastSlash = filename.find_last_of(&quot;\\/&quot;);
9991                  if (lastSlash != std::string::npos) {
9992                      filename.erase(0, lastSlash);
9993                      filename[0] = &#x27;#&#x27;;
9994                  }
9995                  auto lastDot = filename.find_last_of(&#x27;.&#x27;);
9996                  if (lastDot != std::string::npos) {
9997                      filename.erase(lastDot);
9998                  }
9999                  tags.push_back(std::move(filename));
10000                  setTags(testCase, tags);
10001              }
10002          }
10003      } 
10004      Session::Session() {
10005          static bool alreadyInstantiated = false;
10006          if( alreadyInstantiated ) {
10007              CATCH_TRY { CATCH_INTERNAL_ERROR( &quot;Only one instance of Catch::Session can ever be used&quot; ); }
10008              CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
10009          }
10010  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10011          const auto&amp; exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
10012          if ( !exceptions.empty() ) {
10013              config();
10014              getCurrentMutableContext().setConfig(m_config);
10015              m_startupExceptions = true;
10016              Colour colourGuard( Colour::Red );
10017              Catch::cerr() &lt;&lt; &quot;Errors occurred during startup!&quot; &lt;&lt; &#x27;\n&#x27;;
10018              for ( const auto&amp; ex_ptr : exceptions ) {
10019                  try {
10020                      std::rethrow_exception(ex_ptr);
10021                  } catch ( std::exception const&amp; ex ) {
10022                      Catch::cerr() &lt;&lt; Column( ex.what() ).indent(2) &lt;&lt; &#x27;\n&#x27;;
10023                  }
10024              }
10025          }
10026  #endif
10027          alreadyInstantiated = true;
10028          m_cli = makeCommandLineParser( m_configData );
10029      }
10030      Session::~Session() {
10031          Catch::cleanUp();
10032      }
10033      void Session::showHelp() const {
10034          Catch::cout()
10035                  &lt;&lt; &quot;\nCatch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot;\n&quot;
10036                  &lt;&lt; m_cli &lt;&lt; std::endl
10037                  &lt;&lt; &quot;For more detailed usage please see the project docs\n&quot; &lt;&lt; std::endl;
10038      }
10039      void Session::libIdentify() {
10040          Catch::cout()
10041                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;description: &quot; &lt;&lt; &quot;A Catch2 test executable\n&quot;
10042                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;category: &quot; &lt;&lt; &quot;testframework\n&quot;
10043                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;framework: &quot; &lt;&lt; &quot;Catch Test\n&quot;
10044                  &lt;&lt; std::left &lt;&lt; std::setw(16) &lt;&lt; &quot;version: &quot; &lt;&lt; libraryVersion() &lt;&lt; std::endl;
10045      }
10046      int Session::applyCommandLine( int argc, char const * const * argv ) {
10047          if( m_startupExceptions )
10048              return 1;
10049          auto result = m_cli.parse( clara::Args( argc, argv ) );
10050          if( !result ) {
10051              config();
10052              getCurrentMutableContext().setConfig(m_config);
10053              Catch::cerr()
10054                  &lt;&lt; Colour( Colour::Red )
10055                  &lt;&lt; &quot;\nError(s) in input:\n&quot;
10056                  &lt;&lt; Column( result.errorMessage() ).indent( 2 )
10057                  &lt;&lt; &quot;\n\n&quot;;
10058              Catch::cerr() &lt;&lt; &quot;Run with -? for usage\n&quot; &lt;&lt; std::endl;
10059              return MaxExitCode;
10060          }
10061          if( m_configData.showHelp )
10062              showHelp();
10063          if( m_configData.libIdentify )
10064              libIdentify();
10065          m_config.reset();
10066          return 0;
10067      }
10068  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)
10069      int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {
10070          char **utf8Argv = new char *[ argc ];
10071          for ( int i = 0; i &lt; argc; ++i ) {
10072              int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );
10073              utf8Argv[ i ] = new char[ bufSize ];
10074              WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
10075          }
10076          int returnCode = applyCommandLine( argc, utf8Argv );
10077          for ( int i = 0; i &lt; argc; ++i )
10078              delete [] utf8Argv[ i ];
10079          delete [] utf8Argv;
10080          return returnCode;
10081      }
10082  #endif
10083      void Session::useConfigData( ConfigData const&amp; configData ) {
10084          m_configData = configData;
10085          m_config.reset();
10086      }
10087      int Session::run() {
10088          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeStart ) != 0 ) {
10089              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before starting&quot; &lt;&lt; std::endl;
10090              static_cast&lt;void&gt;(std::getchar());
10091          }
10092          int exitCode = runInternal();
10093          if( ( m_configData.waitForKeypress &amp; WaitForKeypress::BeforeExit ) != 0 ) {
10094              Catch::cout() &lt;&lt; &quot;...waiting for enter/ return before exiting, with code: &quot; &lt;&lt; exitCode &lt;&lt; std::endl;
10095              static_cast&lt;void&gt;(std::getchar());
10096          }
10097          return exitCode;
10098      }
10099      clara::Parser const&amp; Session::cli() const {
10100          return m_cli;
10101      }
10102      void Session::cli( clara::Parser const&amp; newParser ) {
10103          m_cli = newParser;
10104      }
10105      ConfigData&amp; Session::configData() {
10106          return m_configData;
10107      }
10108      Config&amp; Session::config() {
10109          if( !m_config )
10110              m_config = std::make_shared&lt;Config&gt;( m_configData );
10111          return *m_config;
10112      }
10113      int Session::runInternal() {
10114          if( m_startupExceptions )
10115              return 1;
10116          if (m_configData.showHelp || m_configData.libIdentify) {
10117              return 0;
10118          }
10119          CATCH_TRY {
10120              config(); 
10121              seedRng( *m_config );
10122              if( m_configData.filenamesAsTags )
10123                  applyFilenamesAsTags( *m_config );
10124              if( Option&lt;std::size_t&gt; listed = list( m_config ) )
10125                  return static_cast&lt;int&gt;( *listed );
10126              TestGroup tests { m_config };
10127              auto const totals = tests.execute();
10128              if( m_config-&gt;warnAboutNoTests() &amp;&amp; totals.error == -1 )
10129                  return 2;
10130              return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast&lt;int&gt;(totals.assertions.failed)));
10131          }
10132  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10133          catch( std::exception&amp; ex ) {
10134              Catch::cerr() &lt;&lt; ex.what() &lt;&lt; std::endl;
10135              return MaxExitCode;
10136          }
10137  #endif
10138      }
10139  } 
10140  #include &lt;vector&gt;
10141  namespace Catch {
10142      namespace {
10143          static auto getSingletons() -&gt; std::vector&lt;ISingleton*&gt;*&amp; {
10144              static std::vector&lt;ISingleton*&gt;* g_singletons = nullptr;
10145              if( !g_singletons )
10146                  g_singletons = new std::vector&lt;ISingleton*&gt;();
10147              return g_singletons;
10148          }
10149      }
10150      ISingleton::~ISingleton() {}
10151      void addSingleton(ISingleton* singleton ) {
10152          getSingletons()-&gt;push_back( singleton );
10153      }
10154      void cleanupSingletons() {
10155          auto&amp; singletons = getSingletons();
10156          for( auto singleton : *singletons )
10157              delete singleton;
10158          delete singletons;
10159          singletons = nullptr;
10160      }
10161  } 
10162  #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10163  namespace Catch {
10164  void StartupExceptionRegistry::add( std::exception_ptr const&amp; exception ) noexcept {
10165          CATCH_TRY {
10166              m_exceptions.push_back(exception);
10167          } CATCH_CATCH_ALL {
10168              std::terminate();
10169          }
10170      }
10171      std::vector&lt;std::exception_ptr&gt; const&amp; StartupExceptionRegistry::getExceptions() const noexcept {
10172          return m_exceptions;
10173      }
10174  } 
10175  #endif
10176  #include &lt;cstdio&gt;
10177  #include &lt;iostream&gt;
10178  #include &lt;fstream&gt;
10179  #include &lt;sstream&gt;
10180  #include &lt;vector&gt;
10181  #include &lt;memory&gt;
10182  namespace Catch {
10183      Catch::IStream::~IStream() = default;
10184      namespace Detail { namespace {
10185          template&lt;typename WriterF, std::size_t bufferSize=256&gt;
10186          class StreamBufImpl : public std::streambuf {
10187              char data[bufferSize];
10188              WriterF m_writer;
10189          public:
10190              StreamBufImpl() {
10191                  setp( data, data + sizeof(data) );
10192              }
10193              ~StreamBufImpl() noexcept {
10194                  StreamBufImpl::sync();
10195              }
10196          private:
10197              int overflow( int c ) override {
10198                  sync();
10199                  if( c != EOF ) {
10200                      if( pbase() == epptr() )
10201                          m_writer( std::string( 1, static_cast&lt;char&gt;( c ) ) );
10202                      else
10203                          sputc( static_cast&lt;char&gt;( c ) );
10204                  }
10205                  return 0;
10206              }
10207              int sync() override {
10208                  if( pbase() != pptr() ) {
10209                      m_writer( std::string( pbase(), static_cast&lt;std::string::size_type&gt;( pptr() - pbase() ) ) );
10210                      setp( pbase(), epptr() );
10211                  }
10212                  return 0;
10213              }
10214          };
10215          struct OutputDebugWriter {
10216              void operator()( std::string const&amp;str ) {
10217                  writeToDebugConsole( str );
10218              }
10219          };
10220          class FileStream : public IStream {
10221              mutable std::ofstream m_ofs;
10222          public:
10223              FileStream( StringRef filename ) {
10224                  m_ofs.open( filename.c_str() );
10225                  CATCH_ENFORCE( !m_ofs.fail(), &quot;Unable to open file: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10226              }
10227              ~FileStream() override = default;
10228          public: 
10229              std::ostream&amp; stream() const override {
10230                  return m_ofs;
10231              }
10232          };
10233          class CoutStream : public IStream {
10234              mutable std::ostream m_os;
10235          public:
10236              CoutStream() : m_os( Catch::cout().rdbuf() ) {}
10237              ~CoutStream() override = default;
10238          public: 
10239              std::ostream&amp; stream() const override { return m_os; }
10240          };
10241          class DebugOutStream : public IStream {
10242              std::unique_ptr&lt;StreamBufImpl&lt;OutputDebugWriter&gt;&gt; m_streamBuf;
10243              mutable std::ostream m_os;
10244          public:
10245              DebugOutStream()
10246              :   m_streamBuf( new StreamBufImpl&lt;OutputDebugWriter&gt;() ),
10247                  m_os( m_streamBuf.get() )
10248              {}
10249              ~DebugOutStream() override = default;
10250          public: 
10251              std::ostream&amp; stream() const override { return m_os; }
10252          };
10253      }} 
10254      auto makeStream( StringRef const &amp;filename ) -&gt; IStream const* {
10255          if( filename.empty() )
10256              return new Detail::CoutStream();
10257          else if( filename[0] == &#x27;%&#x27; ) {
10258              if( filename == &quot;%debug&quot; )
10259                  return new Detail::DebugOutStream();
10260              else
10261                  CATCH_ERROR( &quot;Unrecognised stream: &#x27;&quot; &lt;&lt; filename &lt;&lt; &quot;&#x27;&quot; );
10262          }
10263          else
10264              return new Detail::FileStream( filename );
10265      }
10266      struct StringStreams {
10267          std::vector&lt;std::unique_ptr&lt;std::ostringstream&gt;&gt; m_streams;
10268          std::vector&lt;std::size_t&gt; m_unused;
10269          std::ostringstream m_referenceStream; 
10270          auto add() -&gt; std::size_t {
10271              if( m_unused.empty() ) {
10272                  m_streams.push_back( std::unique_ptr&lt;std::ostringstream&gt;( new std::ostringstream ) );
10273                  return m_streams.size()-1;
10274              }
10275              else {
10276                  auto index = m_unused.back();
10277                  m_unused.pop_back();
10278                  return index;
10279              }
10280          }
10281          void release( std::size_t index ) {
10282              m_streams[index]-&gt;copyfmt( m_referenceStream ); 
10283              m_unused.push_back(index);
10284          }
10285      };
10286      ReusableStringStream::ReusableStringStream()
10287      :   m_index( Singleton&lt;StringStreams&gt;::getMutable().add() ),
10288          m_oss( Singleton&lt;StringStreams&gt;::getMutable().m_streams[m_index].get() )
10289      {}
10290      ReusableStringStream::~ReusableStringStream() {
10291          static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str(&quot;&quot;);
10292          m_oss-&gt;clear();
10293          Singleton&lt;StringStreams&gt;::getMutable().release( m_index );
10294      }
10295      auto ReusableStringStream::str() const -&gt; std::string {
10296          return static_cast&lt;std::ostringstream*&gt;( m_oss )-&gt;str();
10297      }
10298  #ifndef CATCH_CONFIG_NOSTDOUT 
10299      std::ostream&amp; cout() { return std::cout; }
10300      std::ostream&amp; cerr() { return std::cerr; }
10301      std::ostream&amp; clog() { return std::clog; }
10302  #endif
10303  }
10304  #include &lt;algorithm&gt;
10305  #include &lt;ostream&gt;
10306  #include &lt;cstring&gt;
10307  #include &lt;cctype&gt;
10308  #include &lt;vector&gt;
10309  namespace Catch {
10310      namespace {
10311          char toLowerCh(char c) {
10312              return static_cast&lt;char&gt;( std::tolower( static_cast&lt;unsigned char&gt;(c) ) );
10313          }
10314      }
10315      bool startsWith( std::string const&amp; s, std::string const&amp; prefix ) {
10316          return s.size() &gt;= prefix.size() &amp;&amp; std::equal(prefix.begin(), prefix.end(), s.begin());
10317      }
10318      bool startsWith( std::string const&amp; s, char prefix ) {
10319          return !s.empty() &amp;&amp; s[0] == prefix;
10320      }
10321      bool endsWith( std::string const&amp; s, std::string const&amp; suffix ) {
10322          return s.size() &gt;= suffix.size() &amp;&amp; std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
10323      }
10324      bool endsWith( std::string const&amp; s, char suffix ) {
10325          return !s.empty() &amp;&amp; s[s.size()-1] == suffix;
10326      }
10327      bool contains( std::string const&amp; s, std::string const&amp; infix ) {
10328          return s.find( infix ) != std::string::npos;
10329      }
10330      void toLowerInPlace( std::string&amp; s ) {
10331          std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
10332      }
10333      std::string toLower( std::string const&amp; s ) {
10334          std::string lc = s;
10335          toLowerInPlace( lc );
10336          return lc;
10337      }
10338      std::string trim( std::string const&amp; str ) {
10339          static char const* whitespaceChars = &quot;\n\r\t &quot;;
10340          std::string::size_type start = str.find_first_not_of( whitespaceChars );
10341          std::string::size_type end = str.find_last_not_of( whitespaceChars );
10342          return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
10343      }
10344      StringRef trim(StringRef ref) {
10345          const auto is_ws = [](char c) {
10346              return c == &#x27; &#x27; || c == &#x27;\t&#x27; || c == &#x27;\n&#x27; || c == &#x27;\r&#x27;;
10347          };
10348          size_t real_begin = 0;
10349          while (real_begin &lt; ref.size() &amp;&amp; is_ws(ref[real_begin])) { ++real_begin; }
10350          size_t real_end = ref.size();
10351          while (real_end &gt; real_begin &amp;&amp; is_ws(ref[real_end - 1])) { --real_end; }
10352          return ref.substr(real_begin, real_end - real_begin);
10353      }
10354      bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis ) {
10355          bool replaced = false;
10356          std::size_t i = str.find( replaceThis );
10357          while( i != std::string::npos ) {
10358              replaced = true;
10359              str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
10360              if( i &lt; str.size()-withThis.size() )
10361                  i = str.find( replaceThis, i+withThis.size() );
10362              else
10363                  i = std::string::npos;
10364          }
10365          return replaced;
10366      }
10367      std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter ) {
10368          std::vector&lt;StringRef&gt; subStrings;
10369          std::size_t start = 0;
10370          for(std::size_t pos = 0; pos &lt; str.size(); ++pos ) {
10371              if( str[pos] == delimiter ) {
10372                  if( pos - start &gt; 1 )
10373                      subStrings.push_back( str.substr( start, pos-start ) );
10374                  start = pos+1;
10375              }
10376          }
10377          if( start &lt; str.size() )
10378              subStrings.push_back( str.substr( start, str.size()-start ) );
10379          return subStrings;
10380      }
10381      pluralise::pluralise( std::size_t count, std::string const&amp; label )
10382      :   m_count( count ),
10383          m_label( label )
10384      {}
10385      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser ) {
10386          os &lt;&lt; pluraliser.m_count &lt;&lt; &#x27; &#x27; &lt;&lt; pluraliser.m_label;
10387          if( pluraliser.m_count != 1 )
10388              os &lt;&lt; &#x27;s&#x27;;
10389          return os;
10390      }
10391  }
10392  #include &lt;algorithm&gt;
10393  #include &lt;ostream&gt;
10394  #include &lt;cstring&gt;
10395  #include &lt;cstdint&gt;
10396  namespace Catch {
10397      StringRef::StringRef( char const* rawChars ) noexcept
10398      : StringRef( rawChars, static_cast&lt;StringRef::size_type&gt;(std::strlen(rawChars) ) )
10399      {}
10400      auto StringRef::c_str() const -&gt; char const* {
10401          CATCH_ENFORCE(isNullTerminated(), &quot;Called StringRef::c_str() on a non-null-terminated instance&quot;);
10402          return m_start;
10403      }
10404      auto StringRef::data() const noexcept -&gt; char const* {
10405          return m_start;
10406      }
10407      auto StringRef::substr( size_type start, size_type size ) const noexcept -&gt; StringRef {
10408          if (start &lt; m_size) {
10409              return StringRef(m_start + start, (std::min)(m_size - start, size));
10410          } else {
10411              return StringRef();
10412          }
10413      }
10414      auto StringRef::operator == ( StringRef const&amp; other ) const noexcept -&gt; bool {
10415          return m_size == other.m_size
10416              &amp;&amp; (std::memcmp( m_start, other.m_start, m_size ) == 0);
10417      }
10418      auto operator &lt;&lt; ( std::ostream&amp; os, StringRef const&amp; str ) -&gt; std::ostream&amp; {
10419          return os.write(str.data(), str.size());
10420      }
10421      auto operator+=( std::string&amp; lhs, StringRef const&amp; rhs ) -&gt; std::string&amp; {
10422          lhs.append(rhs.data(), rhs.size());
10423          return lhs;
10424      }
10425  } 
10426  namespace Catch {
10427      TagAlias::TagAlias(std::string const &amp; _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
10428  }
10429  namespace Catch {
10430      RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const&amp; lineInfo) {
10431          CATCH_TRY {
10432              getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
10433          } CATCH_CATCH_ALL {
10434              getMutableRegistryHub().registerStartupException();
10435          }
10436      }
10437  }
10438  #include &lt;sstream&gt;
10439  namespace Catch {
10440      TagAliasRegistry::~TagAliasRegistry() {}
10441      TagAlias const* TagAliasRegistry::find( std::string const&amp; alias ) const {
10442          auto it = m_registry.find( alias );
10443          if( it != m_registry.end() )
10444              return &amp;(it-&gt;second);
10445          else
10446              return nullptr;
10447      }
10448      std::string TagAliasRegistry::expandAliases( std::string const&amp; unexpandedTestSpec ) const {
10449          std::string expandedTestSpec = unexpandedTestSpec;
10450          for( auto const&amp; registryKvp : m_registry ) {
10451              std::size_t pos = expandedTestSpec.find( registryKvp.first );
10452              if( pos != std::string::npos ) {
10453                  expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
10454                                      registryKvp.second.tag +
10455                                      expandedTestSpec.substr( pos + registryKvp.first.size() );
10456              }
10457          }
10458          return expandedTestSpec;
10459      }
10460      void TagAliasRegistry::add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo ) {
10461          CATCH_ENFORCE( startsWith(alias, &quot;[@&quot;) &amp;&amp; endsWith(alias, &#x27;]&#x27;),
10462                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; is not of the form [@alias name].\n&quot; &lt;&lt; lineInfo );
10463          CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
10464                        &quot;error: tag alias, &#x27;&quot; &lt;&lt; alias &lt;&lt; &quot;&#x27; already registered.\n&quot;
10465                        &lt;&lt; &quot;\tFirst seen at: &quot; &lt;&lt; find(alias)-&gt;lineInfo &lt;&lt; &quot;\n&quot;
10466                        &lt;&lt; &quot;\tRedefined at: &quot; &lt;&lt; lineInfo );
10467      }
10468      ITagAliasRegistry::~ITagAliasRegistry() {}
10469      ITagAliasRegistry const&amp; ITagAliasRegistry::get() {
10470          return getRegistryHub().getTagAliasRegistry();
10471      }
10472  } 
10473  #include &lt;cctype&gt;
10474  #include &lt;exception&gt;
10475  #include &lt;algorithm&gt;
10476  #include &lt;sstream&gt;
10477  namespace Catch {
10478      namespace {
10479          TestCaseInfo::SpecialProperties parseSpecialTag( std::string const&amp; tag ) {
10480              if( startsWith( tag, &#x27;.&#x27; ) ||
10481                  tag == &quot;!hide&quot; )
10482                  return TestCaseInfo::IsHidden;
10483              else if( tag == &quot;!throws&quot; )
10484                  return TestCaseInfo::Throws;
10485              else if( tag == &quot;!shouldfail&quot; )
10486                  return TestCaseInfo::ShouldFail;
10487              else if( tag == &quot;!mayfail&quot; )
10488                  return TestCaseInfo::MayFail;
10489              else if( tag == &quot;!nonportable&quot; )
10490                  return TestCaseInfo::NonPortable;
10491              else if( tag == &quot;!benchmark&quot; )
10492                  return static_cast&lt;TestCaseInfo::SpecialProperties&gt;( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
10493              else
10494                  return TestCaseInfo::None;
10495          }
10496          bool isReservedTag( std::string const&amp; tag ) {
10497              return parseSpecialTag( tag ) == TestCaseInfo::None &amp;&amp; tag.size() &gt; 0 &amp;&amp; !std::isalnum( static_cast&lt;unsigned char&gt;(tag[0]) );
10498          }
10499          void enforceNotReservedTag( std::string const&amp; tag, SourceLineInfo const&amp; _lineInfo ) {
10500              CATCH_ENFORCE( !isReservedTag(tag),
10501                            &quot;Tag name: [&quot; &lt;&lt; tag &lt;&lt; &quot;] is not allowed.\n&quot;
10502                            &lt;&lt; &quot;Tag names starting with non alphanumeric characters are reserved\n&quot;
10503                            &lt;&lt; _lineInfo );
10504          }
10505      }
10506      TestCase makeTestCase(  ITestInvoker* _testCase,
10507                              std::string const&amp; _className,
10508                              NameAndTags const&amp; nameAndTags,
10509                              SourceLineInfo const&amp; _lineInfo )
10510      {
10511          bool isHidden = false;
10512          std::vector&lt;std::string&gt; tags;
10513          std::string desc, tag;
10514          bool inTag = false;
10515          for (char c : nameAndTags.tags) {
10516              if( !inTag ) {
10517                  if( c == &#x27;[&#x27; )
10518                      inTag = true;
10519                  else
10520                      desc += c;
10521              }
10522              else {
10523                  if( c == &#x27;]&#x27; ) {
10524                      TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
10525                      if( ( prop &amp; TestCaseInfo::IsHidden ) != 0 )
10526                          isHidden = true;
10527                      else if( prop == TestCaseInfo::None )
10528                          enforceNotReservedTag( tag, _lineInfo );
10529                      if (startsWith(tag, &#x27;.&#x27;) &amp;&amp; tag.size() &gt; 1) {
10530                          tag.erase(0, 1);
10531                      }
10532                      tags.push_back( tag );
10533                      tag.clear();
10534                      inTag = false;
10535                  }
10536                  else
10537                      tag += c;
10538              }
10539          }
10540          if( isHidden ) {
10541              tags.insert( tags.end(), { &quot;.&quot;, &quot;!hide&quot; } );
10542          }
10543          TestCaseInfo info( static_cast&lt;std::string&gt;(nameAndTags.name), _className, desc, tags, _lineInfo );
10544          return TestCase( _testCase, std::move(info) );
10545      }
10546      void setTags( TestCaseInfo&amp; testCaseInfo, std::vector&lt;std::string&gt; tags ) {
10547          std::sort(begin(tags), end(tags));
10548          tags.erase(std::unique(begin(tags), end(tags)), end(tags));
10549          testCaseInfo.lcaseTags.clear();
10550          for( auto const&amp; tag : tags ) {
10551              std::string lcaseTag = toLower( tag );
10552              testCaseInfo.properties = static_cast&lt;TestCaseInfo::SpecialProperties&gt;( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
10553              testCaseInfo.lcaseTags.push_back( lcaseTag );
10554          }
10555          testCaseInfo.tags = std::move(tags);
10556      }
10557      TestCaseInfo::TestCaseInfo( std::string const&amp; _name,
10558                                  std::string const&amp; _className,
10559                                  std::string const&amp; _description,
10560                                  std::vector&lt;std::string&gt; const&amp; _tags,
10561                                  SourceLineInfo const&amp; _lineInfo )
10562      :   name( _name ),
10563          className( _className ),
10564          description( _description ),
10565          lineInfo( _lineInfo ),
10566          properties( None )
10567      {
10568          setTags( *this, _tags );
10569      }
10570      bool TestCaseInfo::isHidden() const {
10571          return ( properties &amp; IsHidden ) != 0;
10572      }
10573      bool TestCaseInfo::throws() const {
10574          return ( properties &amp; Throws ) != 0;
10575      }
10576      bool TestCaseInfo::okToFail() const {
10577          return ( properties &amp; (ShouldFail | MayFail ) ) != 0;
10578      }
10579      bool TestCaseInfo::expectedToFail() const {
10580          return ( properties &amp; (ShouldFail ) ) != 0;
10581      }
10582      std::string TestCaseInfo::tagsAsString() const {
10583          std::string ret;
10584          std::size_t full_size = 2 * tags.size();
10585          for (const auto&amp; tag : tags) {
10586              full_size += tag.size();
10587          }
10588          ret.reserve(full_size);
10589          for (const auto&amp; tag : tags) {
10590              ret.push_back(&#x27;[&#x27;);
10591              ret.append(tag);
10592              ret.push_back(&#x27;]&#x27;);
10593          }
10594          return ret;
10595      }
10596      TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&amp;&amp; info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
10597      TestCase TestCase::withName( std::string const&amp; _newName ) const {
10598          TestCase other( *this );
10599          other.name = _newName;
10600          return other;
10601      }
10602      void TestCase::invoke() const {
10603          test-&gt;invoke();
10604      }
10605      bool TestCase::operator == ( TestCase const&amp; other ) const {
10606          return  test.get() == other.test.get() &amp;&amp;
10607                  name == other.name &amp;&amp;
10608                  className == other.className;
10609      }
10610      bool TestCase::operator &lt; ( TestCase const&amp; other ) const {
10611          return name &lt; other.name;
10612      }
10613      TestCaseInfo const&amp; TestCase::getTestCaseInfo() const
10614      {
10615          return *this;
10616      }
10617  } 
10618  #include &lt;algorithm&gt;
10619  #include &lt;sstream&gt;
10620  namespace Catch {
10621      namespace {
10622          struct TestHasher {
10623              using hash_t = uint64_t;
10624              explicit TestHasher( hash_t hashSuffix ):
10625                  m_hashSuffix{ hashSuffix } {}
10626              uint32_t operator()( TestCase const&amp; t ) const {
10627                  const hash_t prime = 1099511628211u;
10628                  hash_t hash = 14695981039346656037u;
10629                  for ( const char c : t.name ) {
10630                      hash ^= c;
10631                      hash *= prime;
10632                  }
10633                  hash ^= m_hashSuffix;
10634                  hash *= prime;
10635                  const uint32_t low{ static_cast&lt;uint32_t&gt;( hash ) };
10636                  const uint32_t high{ static_cast&lt;uint32_t&gt;( hash &gt;&gt; 32 ) };
10637                  return low * high;
10638              }
10639          private:
10640              hash_t m_hashSuffix;
10641          };
10642      } 
10643      std::vector&lt;TestCase&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCase&gt; const&amp; unsortedTestCases ) {
10644          switch( config.runOrder() ) {
10645              case RunTests::InDeclarationOrder:
10646                  break;
10647              case RunTests::InLexicographicalOrder: {
10648                  std::vector&lt;TestCase&gt; sorted = unsortedTestCases;
10649                  std::sort( sorted.begin(), sorted.end() );
10650                  return sorted;
10651              }
10652              case RunTests::InRandomOrder: {
10653                  seedRng( config );
10654                  TestHasher h{ config.rngSeed() };
10655                  using hashedTest = std::pair&lt;TestHasher::hash_t, TestCase const*&gt;;
10656                  std::vector&lt;hashedTest&gt; indexed_tests;
10657                  indexed_tests.reserve( unsortedTestCases.size() );
10658                  for (auto const&amp; testCase : unsortedTestCases) {
10659                      indexed_tests.emplace_back(h(testCase), &amp;testCase);
10660                  }
10661                  std::sort(indexed_tests.begin(), indexed_tests.end(),
10662                            [](hashedTest const&amp; lhs, hashedTest const&amp; rhs) {
10663                            if (lhs.first == rhs.first) {
10664                                return lhs.second-&gt;name &lt; rhs.second-&gt;name;
10665                            }
10666                            return lhs.first &lt; rhs.first;
10667                  });
10668                  std::vector&lt;TestCase&gt; sorted;
10669                  sorted.reserve( indexed_tests.size() );
10670                  for (auto const&amp; hashed : indexed_tests) {
10671                      sorted.emplace_back(*hashed.second);
10672                  }
10673                  return sorted;
10674              }
10675          }
10676          return unsortedTestCases;
10677      }
10678      bool isThrowSafe( TestCase const&amp; testCase, IConfig const&amp; config ) {
10679          return !testCase.throws() || config.allowThrows();
10680      }
10681      bool matchTest( TestCase const&amp; testCase, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10682          return testSpec.matches( testCase ) &amp;&amp; isThrowSafe( testCase, config );
10683      }
10684      void enforceNoDuplicateTestCases( std::vector&lt;TestCase&gt; const&amp; functions ) {
10685          std::set&lt;TestCase&gt; seenFunctions;
10686          for( auto const&amp; function : functions ) {
10687              auto prev = seenFunctions.insert( function );
10688              CATCH_ENFORCE( prev.second,
10689                      &quot;error: TEST_CASE( \&quot;&quot; &lt;&lt; function.name &lt;&lt; &quot;\&quot; ) already defined.\n&quot;
10690                      &lt;&lt; &quot;\tFirst seen at &quot; &lt;&lt; prev.first-&gt;getTestCaseInfo().lineInfo &lt;&lt; &quot;\n&quot;
10691                      &lt;&lt; &quot;\tRedefined at &quot; &lt;&lt; function.getTestCaseInfo().lineInfo );
10692          }
10693      }
10694      std::vector&lt;TestCase&gt; filterTests( std::vector&lt;TestCase&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config ) {
10695          std::vector&lt;TestCase&gt; filtered;
10696          filtered.reserve( testCases.size() );
10697          for (auto const&amp; testCase : testCases) {
10698              if ((!testSpec.hasFilters() &amp;&amp; !testCase.isHidden()) ||
10699                  (testSpec.hasFilters() &amp;&amp; matchTest(testCase, testSpec, config))) {
10700                  filtered.push_back(testCase);
10701              }
10702          }
10703          return filtered;
10704      }
10705      std::vector&lt;TestCase&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config ) {
10706          return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
10707      }
10708      void TestRegistry::registerTest( TestCase const&amp; testCase ) {
10709          std::string name = testCase.getTestCaseInfo().name;
10710          if( name.empty() ) {
10711              ReusableStringStream rss;
10712              rss &lt;&lt; &quot;Anonymous test case &quot; &lt;&lt; ++m_unnamedCount;
10713              return registerTest( testCase.withName( rss.str() ) );
10714          }
10715          m_functions.push_back( testCase );
10716      }
10717      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTests() const {
10718          return m_functions;
10719      }
10720      std::vector&lt;TestCase&gt; const&amp; TestRegistry::getAllTestsSorted( IConfig const&amp; config ) const {
10721          if( m_sortedFunctions.empty() )
10722              enforceNoDuplicateTestCases( m_functions );
10723          if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
10724              m_sortedFunctions = sortTests( config, m_functions );
10725              m_currentSortOrder = config.runOrder();
10726          }
10727          return m_sortedFunctions;
10728      }
10729      TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
10730      void TestInvokerAsFunction::invoke() const {
10731          m_testAsFunction();
10732      }
10733      std::string extractClassName( StringRef const&amp; classOrQualifiedMethodName ) {
10734          std::string className(classOrQualifiedMethodName);
10735          if( startsWith( className, &#x27;&amp;&#x27; ) )
10736          {
10737              std::size_t lastColons = className.rfind( &quot;::&quot; );
10738              std::size_t penultimateColons = className.rfind( &quot;::&quot;, lastColons-1 );
10739              if( penultimateColons == std::string::npos )
10740                  penultimateColons = 1;
10741              className = className.substr( penultimateColons, lastColons-penultimateColons );
10742          }
10743          return className;
10744      }
10745  } 
10746  #include &lt;algorithm&gt;
10747  #include &lt;cassert&gt;
10748  #include &lt;stdexcept&gt;
10749  #include &lt;memory&gt;
10750  #include &lt;sstream&gt;
10751  #if defined(__clang__)
10752  #    pragma clang diagnostic push
10753  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
10754  #endif
10755  namespace Catch {
10756  namespace TestCaseTracking {
10757      NameAndLocation::NameAndLocation( std::string const&amp; _name, SourceLineInfo const&amp; _location )
10758      :   name( _name ),
10759          location( _location )
10760      {}
10761      ITracker::~ITracker() = default;
10762      ITracker&amp; TrackerContext::startRun() {
10763          m_rootTracker = std::make_shared&lt;SectionTracker&gt;( NameAndLocation( &quot;{root}&quot;, CATCH_INTERNAL_LINEINFO ), *this, nullptr );
10764          m_currentTracker = nullptr;
10765          m_runState = Executing;
10766          return *m_rootTracker;
10767      }
10768      void TrackerContext::endRun() {
10769          m_rootTracker.reset();
10770          m_currentTracker = nullptr;
10771          m_runState = NotStarted;
10772      }
10773      void TrackerContext::startCycle() {
10774          m_currentTracker = m_rootTracker.get();
10775          m_runState = Executing;
10776      }
10777      void TrackerContext::completeCycle() {
10778          m_runState = CompletedCycle;
10779      }
10780      bool TrackerContext::completedCycle() const {
10781          return m_runState == CompletedCycle;
10782      }
10783      ITracker&amp; TrackerContext::currentTracker() {
10784          return *m_currentTracker;
10785      }
10786      void TrackerContext::setCurrentTracker( ITracker* tracker ) {
10787          m_currentTracker = tracker;
10788      }
10789      TrackerBase::TrackerBase( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent ):
10790          ITracker(nameAndLocation),
10791          m_ctx( ctx ),
10792          m_parent( parent )
10793      {}
10794      bool TrackerBase::isComplete() const {
10795          return m_runState == CompletedSuccessfully || m_runState == Failed;
10796      }
10797      bool TrackerBase::isSuccessfullyCompleted() const {
10798          return m_runState == CompletedSuccessfully;
10799      }
10800      bool TrackerBase::isOpen() const {
10801          return m_runState != NotStarted &amp;&amp; !isComplete();
10802      }
10803      bool TrackerBase::hasChildren() const {
10804          return !m_children.empty();
10805      }
10806      void TrackerBase::addChild( ITrackerPtr const&amp; child ) {
10807          m_children.push_back( child );
10808      }
10809      ITrackerPtr TrackerBase::findChild( NameAndLocation const&amp; nameAndLocation ) {
10810          auto it = std::find_if( m_children.begin(), m_children.end(),
10811              [&amp;nameAndLocation]( ITrackerPtr const&amp; tracker ){
10812                  return
10813                      tracker-&gt;nameAndLocation().location == nameAndLocation.location &amp;&amp;
10814                      tracker-&gt;nameAndLocation().name == nameAndLocation.name;
10815              } );
10816          return( it != m_children.end() )
10817              ? *it
10818              : nullptr;
10819      }
10820      ITracker&amp; TrackerBase::parent() {
10821          assert( m_parent ); 
10822          return *m_parent;
10823      }
10824      void TrackerBase::openChild() {
10825          if( m_runState != ExecutingChildren ) {
10826              m_runState = ExecutingChildren;
10827              if( m_parent )
10828                  m_parent-&gt;openChild();
10829          }
10830      }
10831      bool TrackerBase::isSectionTracker() const { return false; }
10832      bool TrackerBase::isGeneratorTracker() const { return false; }
10833      void TrackerBase::open() {
10834          m_runState = Executing;
10835          moveToThis();
10836          if( m_parent )
10837              m_parent-&gt;openChild();
10838      }
10839      void TrackerBase::close() {
10840          while( &amp;m_ctx.currentTracker() != this )
10841              m_ctx.currentTracker().close();
10842          switch( m_runState ) {
10843              case NeedsAnotherRun:
10844                  break;
10845              case Executing:
10846                  m_runState = CompletedSuccessfully;
10847                  break;
10848              case ExecutingChildren:
10849                  if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const&amp; t){ return t-&gt;isComplete(); }) )
10850                      m_runState = CompletedSuccessfully;
10851                  break;
10852              case NotStarted:
10853              case CompletedSuccessfully:
10854              case Failed:
10855                  CATCH_INTERNAL_ERROR( &quot;Illogical state: &quot; &lt;&lt; m_runState );
10856              default:
10857                  CATCH_INTERNAL_ERROR( &quot;Unknown state: &quot; &lt;&lt; m_runState );
10858          }
10859          moveToParent();
10860          m_ctx.completeCycle();
10861      }
10862      void TrackerBase::fail() {
10863          m_runState = Failed;
10864          if( m_parent )
10865              m_parent-&gt;markAsNeedingAnotherRun();
10866          moveToParent();
10867          m_ctx.completeCycle();
10868      }
10869      void TrackerBase::markAsNeedingAnotherRun() {
10870          m_runState = NeedsAnotherRun;
10871      }
10872      void TrackerBase::moveToParent() {
10873          assert( m_parent );
10874          m_ctx.setCurrentTracker( m_parent );
10875      }
10876      void TrackerBase::moveToThis() {
10877          m_ctx.setCurrentTracker( this );
10878      }
10879      SectionTracker::SectionTracker( NameAndLocation const&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent )
10880      :   TrackerBase( nameAndLocation, ctx, parent ),
10881          m_trimmed_name(trim(nameAndLocation.name))
10882      {
10883          if( parent ) {
10884              while( !parent-&gt;isSectionTracker() )
10885                  parent = &amp;parent-&gt;parent();
10886              SectionTracker&amp; parentSection = static_cast&lt;SectionTracker&amp;&gt;( *parent );
10887              addNextFilters( parentSection.m_filters );
10888          }
10889      }
10890      bool SectionTracker::isComplete() const {
10891          bool complete = true;
10892          if (m_filters.empty()
10893              || m_filters[0] == &quot;&quot;
10894              || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
10895              complete = TrackerBase::isComplete();
10896          }
10897          return complete;
10898      }
10899      bool SectionTracker::isSectionTracker() const { return true; }
10900      SectionTracker&amp; SectionTracker::acquire( TrackerContext&amp; ctx, NameAndLocation const&amp; nameAndLocation ) {
10901          std::shared_ptr&lt;SectionTracker&gt; section;
10902          ITracker&amp; currentTracker = ctx.currentTracker();
10903          if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
10904              assert( childTracker );
10905              assert( childTracker-&gt;isSectionTracker() );
10906              section = std::static_pointer_cast&lt;SectionTracker&gt;( childTracker );
10907          }
10908          else {
10909              section = std::make_shared&lt;SectionTracker&gt;( nameAndLocation, ctx, &amp;currentTracker );
10910              currentTracker.addChild( section );
10911          }
10912          if( !ctx.completedCycle() )
10913              section-&gt;tryOpen();
10914          return *section;
10915      }
10916      void SectionTracker::tryOpen() {
10917          if( !isComplete() )
10918              open();
10919      }
10920      void SectionTracker::addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10921          if( !filters.empty() ) {
10922              m_filters.reserve( m_filters.size() + filters.size() + 2 );
10923              m_filters.emplace_back(&quot;&quot;); 
10924              m_filters.emplace_back(&quot;&quot;); 
10925              m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
10926          }
10927      }
10928      void SectionTracker::addNextFilters( std::vector&lt;std::string&gt; const&amp; filters ) {
10929          if( filters.size() &gt; 1 )
10930              m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
10931      }
10932      std::vector&lt;std::string&gt; const&amp; SectionTracker::getFilters() const {
10933          return m_filters;
10934      }
10935      std::string const&amp; SectionTracker::trimmedName() const {
10936          return m_trimmed_name;
10937      }
10938  } 
10939  using TestCaseTracking::ITracker;
10940  using TestCaseTracking::TrackerContext;
10941  using TestCaseTracking::SectionTracker;
10942  } 
10943  #if defined(__clang__)
10944  #    pragma clang diagnostic pop
10945  #endif
10946  namespace Catch {
10947      auto makeTestInvoker( void(*testAsFunction)() ) noexcept -&gt; ITestInvoker* {
10948          return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
10949      }
10950      NameAndTags::NameAndTags( StringRef const&amp; name_ , StringRef const&amp; tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
10951      AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const&amp; lineInfo, StringRef const&amp; classOrMethod, NameAndTags const&amp; nameAndTags ) noexcept {
10952          CATCH_TRY {
10953              getMutableRegistryHub()
10954                      .registerTest(
10955                          makeTestCase(
10956                              invoker,
10957                              extractClassName( classOrMethod ),
10958                              nameAndTags,
10959                              lineInfo));
10960          } CATCH_CATCH_ALL {
10961              getMutableRegistryHub().registerStartupException();
10962          }
10963      }
10964      AutoReg::~AutoReg() = default;
10965  }
10966  #include &lt;algorithm&gt;
10967  #include &lt;string&gt;
10968  #include &lt;vector&gt;
10969  #include &lt;memory&gt;
10970  namespace Catch {
10971      TestSpec::Pattern::Pattern( std::string const&amp; name )
10972      : m_name( name )
10973      {}
10974      TestSpec::Pattern::~Pattern() = default;
10975      std::string const&amp; TestSpec::Pattern::name() const {
10976          return m_name;
10977      }
10978      TestSpec::NamePattern::NamePattern( std::string const&amp; name, std::string const&amp; filterString )
10979      : Pattern( filterString )
10980      , m_wildcardPattern( toLower( name ), CaseSensitive::No )
10981      {}
10982      bool TestSpec::NamePattern::matches( TestCaseInfo const&amp; testCase ) const {
10983          return m_wildcardPattern.matches( testCase.name );
10984      }
10985      TestSpec::TagPattern::TagPattern( std::string const&amp; tag, std::string const&amp; filterString )
10986      : Pattern( filterString )
10987      , m_tag( toLower( tag ) )
10988      {}
10989      bool TestSpec::TagPattern::matches( TestCaseInfo const&amp; testCase ) const {
10990          return std::find(begin(testCase.lcaseTags),
10991                           end(testCase.lcaseTags),
10992                           m_tag) != end(testCase.lcaseTags);
10993      }
10994      TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const&amp; underlyingPattern )
10995      : Pattern( underlyingPattern-&gt;name() )
10996      , m_underlyingPattern( underlyingPattern )
10997      {}
10998      bool TestSpec::ExcludedPattern::matches( TestCaseInfo const&amp; testCase ) const {
10999          return !m_underlyingPattern-&gt;matches( testCase );
11000      }
11001      bool TestSpec::Filter::matches( TestCaseInfo const&amp; testCase ) const {
11002          return std::all_of( m_patterns.begin(), m_patterns.end(), [&amp;]( PatternPtr const&amp; p ){ return p-&gt;matches( testCase ); } );
11003      }
11004      std::string TestSpec::Filter::name() const {
11005          std::string name;
11006          for( auto const&amp; p : m_patterns )
11007              name += p-&gt;name();
11008          return name;
11009      }
11010      bool TestSpec::hasFilters() const {
11011          return !m_filters.empty();
11012      }
11013      bool TestSpec::matches( TestCaseInfo const&amp; testCase ) const {
11014          return std::any_of( m_filters.begin(), m_filters.end(), [&amp;]( Filter const&amp; f ){ return f.matches( testCase ); } );
11015      }
11016      TestSpec::Matches TestSpec::matchesByFilter( std::vector&lt;TestCase&gt; const&amp; testCases, IConfig const&amp; config ) const
11017      {
11018          Matches matches( m_filters.size() );
11019          std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&amp;]( Filter const&amp; filter ){
11020              std::vector&lt;TestCase const*&gt; currentMatches;
11021              for( auto const&amp; test : testCases )
11022                  if( isThrowSafe( test, config ) &amp;&amp; filter.matches( test ) )
11023                      currentMatches.emplace_back( &amp;test );
11024              return FilterMatch{ filter.name(), currentMatches };
11025          } );
11026          return matches;
11027      }
11028      const TestSpec::vectorStrings&amp; TestSpec::getInvalidArgs() const{
11029          return  (m_invalidArgs);
11030      }
11031  }
11032  namespace Catch {
11033      TestSpecParser::TestSpecParser( ITagAliasRegistry const&amp; tagAliases ) : m_tagAliases( &amp;tagAliases ) {}
11034      TestSpecParser&amp; TestSpecParser::parse( std::string const&amp; arg ) {
11035          m_mode = None;
11036          m_exclusion = false;
11037          m_arg = m_tagAliases-&gt;expandAliases( arg );
11038          m_escapeChars.clear();
11039          m_substring.reserve(m_arg.size());
11040          m_patternName.reserve(m_arg.size());
11041          m_realPatternPos = 0;
11042          for( m_pos = 0; m_pos &lt; m_arg.size(); ++m_pos )
11043             if( !visitChar( m_arg[m_pos] ) ){
11044                 m_testSpec.m_invalidArgs.push_back(arg);
11045                 break;
11046             }
11047          endMode();
11048          return *this;
11049      }
11050      TestSpec TestSpecParser::testSpec() {
11051          addFilter();
11052          return m_testSpec;
11053      }
11054      bool TestSpecParser::visitChar( char c ) {
11055          if( (m_mode != EscapedName) &amp;&amp; (c == &#x27;\\&#x27;) ) {
11056              escape();
11057              addCharToPattern(c);
11058              return true;
11059          }else if((m_mode != EscapedName) &amp;&amp; (c == &#x27;,&#x27;) )  {
11060              return separate();
11061          }
11062          switch( m_mode ) {
11063          case None:
11064              if( processNoneChar( c ) )
11065                  return true;
11066              break;
11067          case Name:
11068              processNameChar( c );
11069              break;
11070          case EscapedName:
11071              endMode();
11072              addCharToPattern(c);
11073              return true;
11074          default:
11075          case Tag:
11076          case QuotedName:
11077              if( processOtherChar( c ) )
11078                  return true;
11079              break;
11080          }
11081          m_substring += c;
11082          if( !isControlChar( c ) ) {
11083              m_patternName += c;
11084              m_realPatternPos++;
11085          }
11086          return true;
11087      }
11088      bool TestSpecParser::processNoneChar( char c ) {
11089          switch( c ) {
11090          case &#x27; &#x27;:
11091              return true;
11092          case &#x27;~&#x27;:
11093              m_exclusion = true;
11094              return false;
11095          case &#x27;[&#x27;:
11096              startNewMode( Tag );
11097              return false;
11098          case &#x27;&quot;&#x27;:
11099              startNewMode( QuotedName );
11100              return false;
11101          default:
11102              startNewMode( Name );
11103              return false;
11104          }
11105      }
11106      void TestSpecParser::processNameChar( char c ) {
11107          if( c == &#x27;[&#x27; ) {
11108              if( m_substring == &quot;exclude:&quot; )
11109                  m_exclusion = true;
11110              else
11111                  endMode();
11112              startNewMode( Tag );
11113          }
11114      }
11115      bool TestSpecParser::processOtherChar( char c ) {
11116          if( !isControlChar( c ) )
11117              return false;
11118          m_substring += c;
11119          endMode();
11120          return true;
11121      }
11122      void TestSpecParser::startNewMode( Mode mode ) {
11123          m_mode = mode;
11124      }
11125      void TestSpecParser::endMode() {
11126          switch( m_mode ) {
11127          case Name:
11128          case QuotedName:
11129              return addNamePattern();
11130          case Tag:
11131              return addTagPattern();
11132          case EscapedName:
11133              revertBackToLastMode();
11134              return;
11135          case None:
11136          default:
11137              return startNewMode( None );
11138          }
11139      }
11140      void TestSpecParser::escape() {
11141          saveLastMode();
11142          m_mode = EscapedName;
11143          m_escapeChars.push_back(m_realPatternPos);
11144      }
11145      bool TestSpecParser::isControlChar( char c ) const {
11146          switch( m_mode ) {
11147              default:
11148                  return false;
11149              case None:
11150                  return c == &#x27;~&#x27;;
11151              case Name:
11152                  return c == &#x27;[&#x27;;
11153              case EscapedName:
11154                  return true;
11155              case QuotedName:
11156                  return c == &#x27;&quot;&#x27;;
11157              case Tag:
11158                  return c == &#x27;[&#x27; || c == &#x27;]&#x27;;
11159          }
11160      }
11161      void TestSpecParser::addFilter() {
11162          if( !m_currentFilter.m_patterns.empty() ) {
11163              m_testSpec.m_filters.push_back( m_currentFilter );
11164              m_currentFilter = TestSpec::Filter();
11165          }
11166      }
11167      void TestSpecParser::saveLastMode() {
11168        lastMode = m_mode;
11169      }
11170      void TestSpecParser::revertBackToLastMode() {
11171        m_mode = lastMode;
11172      }
11173      bool TestSpecParser::separate() {
11174        if( (m_mode==QuotedName) || (m_mode==Tag) ){
11175           m_mode = None;
11176           m_pos = m_arg.size();
11177           m_substring.clear();
11178           m_patternName.clear();
11179           m_realPatternPos = 0;
11180           return false;
11181        }
11182        endMode();
11183        addFilter();
11184        return true; 
11185      }
11186      std::string TestSpecParser::preprocessPattern() {
11187          std::string token = m_patternName;
11188          for (std::size_t i = 0; i &lt; m_escapeChars.size(); ++i)
11189              token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
11190          m_escapeChars.clear();
11191          if (startsWith(token, &quot;exclude:&quot;)) {
11192              m_exclusion = true;
11193              token = token.substr(8);
11194          }
11195          m_patternName.clear();
11196          m_realPatternPos = 0;
11197          return token;
11198      }
11199      void TestSpecParser::addNamePattern() {
11200          auto token = preprocessPattern();
11201          if (!token.empty()) {
11202              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::NamePattern&gt;(token, m_substring);
11203              if (m_exclusion)
11204                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11205              m_currentFilter.m_patterns.push_back(pattern);
11206          }
11207          m_substring.clear();
11208          m_exclusion = false;
11209          m_mode = None;
11210      }
11211      void TestSpecParser::addTagPattern() {
11212          auto token = preprocessPattern();
11213          if (!token.empty()) {
11214              if (token.size() &gt; 1 &amp;&amp; token[0] == &#x27;.&#x27;) {
11215                  token.erase(token.begin());
11216                  TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(&quot;.&quot;, m_substring);
11217                  if (m_exclusion) {
11218                      pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11219                  }
11220                  m_currentFilter.m_patterns.push_back(pattern);
11221              }
11222              TestSpec::PatternPtr pattern = std::make_shared&lt;TestSpec::TagPattern&gt;(token, m_substring);
11223              if (m_exclusion) {
11224                  pattern = std::make_shared&lt;TestSpec::ExcludedPattern&gt;(pattern);
11225              }
11226              m_currentFilter.m_patterns.push_back(pattern);
11227          }
11228          m_substring.clear();
11229          m_exclusion = false;
11230          m_mode = None;
11231      }
11232      TestSpec parseTestSpec( std::string const&amp; arg ) {
11233          return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
11234      }
11235  } 
11236  #include &lt;chrono&gt;
11237  static const uint64_t nanosecondsInSecond = 1000000000;
11238  namespace Catch {
11239      auto getCurrentNanosecondsSinceEpoch() -&gt; uint64_t {
11240          return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
11241      }
11242      namespace {
11243          auto estimateClockResolution() -&gt; uint64_t {
11244              uint64_t sum = 0;
11245              static const uint64_t iterations = 1000000;
11246              auto startTime = getCurrentNanosecondsSinceEpoch();
11247              for( std::size_t i = 0; i &lt; iterations; ++i ) {
11248                  uint64_t ticks;
11249                  uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
11250                  do {
11251                      ticks = getCurrentNanosecondsSinceEpoch();
11252                  } while( ticks == baseTicks );
11253                  auto delta = ticks - baseTicks;
11254                  sum += delta;
11255                  if (ticks &gt; startTime + 3 * nanosecondsInSecond) {
11256                      return sum / ( i + 1u );
11257                  }
11258              }
11259              return sum/iterations;
11260          }
11261      }
11262      auto getEstimatedClockResolution() -&gt; uint64_t {
11263          static auto s_resolution = estimateClockResolution();
11264          return s_resolution;
11265      }
11266      void Timer::start() {
11267         m_nanoseconds = getCurrentNanosecondsSinceEpoch();
11268      }
11269      auto Timer::getElapsedNanoseconds() const -&gt; uint64_t {
11270          return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
11271      }
11272      auto Timer::getElapsedMicroseconds() const -&gt; uint64_t {
11273          return getElapsedNanoseconds()/1000;
11274      }
11275      auto Timer::getElapsedMilliseconds() const -&gt; unsigned int {
11276          return static_cast&lt;unsigned int&gt;(getElapsedMicroseconds()/1000);
11277      }
11278      auto Timer::getElapsedSeconds() const -&gt; double {
11279          return getElapsedMicroseconds()/1000000.0;
11280      }
11281  } 
11282  #if defined(__clang__)
11283  #    pragma clang diagnostic push
11284  #    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;
11285  #    pragma clang diagnostic ignored &quot;-Wglobal-constructors&quot;
11286  #endif
11287  #if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
11288  #define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
11289  #endif
11290  #include &lt;cmath&gt;
11291  #include &lt;iomanip&gt;
11292  namespace Catch {
11293  namespace Detail {
11294      const std::string unprintableString = &quot;{?}&quot;;
11295      namespace {
11296          const int hexThreshold = 255;
11297          struct Endianness {
11298              enum Arch { Big, Little };
11299              static Arch which() {
11300                  int one = 1;
11301                  auto value = *reinterpret_cast&lt;char*&gt;(&amp;one);
11302                  return value ? Little : Big;
11303              }
11304          };
11305      }
11306      std::string rawMemoryToString( const void *object, std::size_t size ) {
11307          int i = 0, end = static_cast&lt;int&gt;( size ), inc = 1;
11308          if( Endianness::which() == Endianness::Little ) {
11309              i = end-1;
11310              end = inc = -1;
11311          }
11312          unsigned char const *bytes = static_cast&lt;unsigned char const *&gt;(object);
11313          ReusableStringStream rss;
11314          rss &lt;&lt; &quot;0x&quot; &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::hex;
11315          for( ; i != end; i += inc )
11316               rss &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(bytes[i]);
11317         return rss.str();
11318      }
11319  }
11320  template&lt;typename T&gt;
11321  std::string fpToString( T value, int precision ) {
11322      if (Catch::isnan(value)) {
11323          return &quot;nan&quot;;
11324      }
11325      ReusableStringStream rss;
11326      rss &lt;&lt; std::setprecision( precision )
11327          &lt;&lt; std::fixed
11328          &lt;&lt; value;
11329      std::string d = rss.str();
11330      std::size_t i = d.find_last_not_of( &#x27;0&#x27; );
11331      if( i != std::string::npos &amp;&amp; i != d.size()-1 ) {
11332          if( d[i] == &#x27;.&#x27; )
11333              i++;
11334          d = d.substr( 0, i+1 );
11335      }
11336      return d;
11337  }
11338  std::string StringMaker&lt;std::string&gt;::convert(const std::string&amp; str) {
11339      if (!getCurrentContext().getConfig()-&gt;showInvisibles()) {
11340          return &#x27;&quot;&#x27; + str + &#x27;&quot;&#x27;;
11341      }
11342      std::string s(&quot;\&quot;&quot;);
11343      for (char c : str) {
11344          switch (c) {
11345          case &#x27;\n&#x27;:
11346              s.append(&quot;\\n&quot;);
11347              break;
11348          case &#x27;\t&#x27;:
11349              s.append(&quot;\\t&quot;);
11350              break;
11351          default:
11352              s.push_back(c);
11353              break;
11354          }
11355      }
11356      s.append(&quot;\&quot;&quot;);
11357      return s;
11358  }
11359  #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11360  std::string StringMaker&lt;std::string_view&gt;::convert(std::string_view str) {
11361      return ::Catch::Detail::stringify(std::string{ str });
11362  }
11363  #endif
11364  std::string StringMaker&lt;char const*&gt;::convert(char const* str) {
11365      if (str) {
11366          return ::Catch::Detail::stringify(std::string{ str });
11367      } else {
11368          return{ &quot;{null string}&quot; };
11369      }
11370  }
11371  std::string StringMaker&lt;char*&gt;::convert(char* str) {
11372      if (str) {
11373          return ::Catch::Detail::stringify(std::string{ str });
11374      } else {
11375          return{ &quot;{null string}&quot; };
11376      }
11377  }
11378  #ifdef CATCH_CONFIG_WCHAR
11379  std::string StringMaker&lt;std::wstring&gt;::convert(const std::wstring&amp; wstr) {
11380      std::string s;
11381      s.reserve(wstr.size());
11382      for (auto c : wstr) {
11383          s += (c &lt;= 0xff) ? static_cast&lt;char&gt;(c) : &#x27;?&#x27;;
11384      }
11385      return ::Catch::Detail::stringify(s);
11386  }
11387  # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
11388  std::string StringMaker&lt;std::wstring_view&gt;::convert(std::wstring_view str) {
11389      return StringMaker&lt;std::wstring&gt;::convert(std::wstring(str));
11390  }
11391  # endif
11392  std::string StringMaker&lt;wchar_t const*&gt;::convert(wchar_t const * str) {
11393      if (str) {
11394          return ::Catch::Detail::stringify(std::wstring{ str });
11395      } else {
11396          return{ &quot;{null string}&quot; };
11397      }
11398  }
11399  std::string StringMaker&lt;wchar_t *&gt;::convert(wchar_t * str) {
11400      if (str) {
11401          return ::Catch::Detail::stringify(std::wstring{ str });
11402      } else {
11403          return{ &quot;{null string}&quot; };
11404      }
11405  }
11406  #endif
11407  #if defined(CATCH_CONFIG_CPP17_BYTE)
11408  #include &lt;cstddef&gt;
11409  std::string StringMaker&lt;std::byte&gt;::convert(std::byte value) {
11410      return ::Catch::Detail::stringify(std::to_integer&lt;unsigned long long&gt;(value));
11411  }
11412  #endif 
11413  std::string StringMaker&lt;int&gt;::convert(int value) {
11414      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11415  }
11416  std::string StringMaker&lt;long&gt;::convert(long value) {
11417      return ::Catch::Detail::stringify(static_cast&lt;long long&gt;(value));
11418  }
11419  std::string StringMaker&lt;long long&gt;::convert(long long value) {
11420      ReusableStringStream rss;
11421      rss &lt;&lt; value;
11422      if (value &gt; Detail::hexThreshold) {
11423          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11424      }
11425      return rss.str();
11426  }
11427  std::string StringMaker&lt;unsigned int&gt;::convert(unsigned int value) {
11428      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11429  }
11430  std::string StringMaker&lt;unsigned long&gt;::convert(unsigned long value) {
11431      return ::Catch::Detail::stringify(static_cast&lt;unsigned long long&gt;(value));
11432  }
11433  std::string StringMaker&lt;unsigned long long&gt;::convert(unsigned long long value) {
11434      ReusableStringStream rss;
11435      rss &lt;&lt; value;
11436      if (value &gt; Detail::hexThreshold) {
11437          rss &lt;&lt; &quot; (0x&quot; &lt;&lt; std::hex &lt;&lt; value &lt;&lt; &#x27;)&#x27;;
11438      }
11439      return rss.str();
11440  }
11441  std::string StringMaker&lt;bool&gt;::convert(bool b) {
11442      return b ? &quot;true&quot; : &quot;false&quot;;
11443  }
11444  std::string StringMaker&lt;signed char&gt;::convert(signed char value) {
11445      if (value == &#x27;\r&#x27;) {
11446          return &quot;&#x27;\\r&#x27;&quot;;
11447      } else if (value == &#x27;\f&#x27;) {
11448          return &quot;&#x27;\\f&#x27;&quot;;
11449      } else if (value == &#x27;\n&#x27;) {
11450          return &quot;&#x27;\\n&#x27;&quot;;
11451      } else if (value == &#x27;\t&#x27;) {
11452          return &quot;&#x27;\\t&#x27;&quot;;
11453      } else if (&#x27;\0&#x27; &lt;= value &amp;&amp; value &lt; &#x27; &#x27;) {
11454          return ::Catch::Detail::stringify(static_cast&lt;unsigned int&gt;(value));
11455      } else {
11456          char chstr[] = &quot;&#x27; &#x27;&quot;;
11457          chstr[1] = value;
11458          return chstr;
11459      }
11460  }
11461  std::string StringMaker&lt;char&gt;::convert(char c) {
11462      return ::Catch::Detail::stringify(static_cast&lt;signed char&gt;(c));
11463  }
11464  std::string StringMaker&lt;unsigned char&gt;::convert(unsigned char c) {
11465      return ::Catch::Detail::stringify(static_cast&lt;char&gt;(c));
11466  }
11467  std::string StringMaker&lt;std::nullptr_t&gt;::convert(std::nullptr_t) {
11468      return &quot;nullptr&quot;;
11469  }
11470  int StringMaker&lt;float&gt;::precision = 5;
11471  std::string StringMaker&lt;float&gt;::convert(float value) {
11472      return fpToString(value, precision) + &#x27;f&#x27;;
11473  }
11474  int StringMaker&lt;double&gt;::precision = 10;
11475  std::string StringMaker&lt;double&gt;::convert(double value) {
11476      return fpToString(value, precision);
11477  }
11478  std::string ratio_string&lt;std::atto&gt;::symbol() { return &quot;a&quot;; }
11479  std::string ratio_string&lt;std::femto&gt;::symbol() { return &quot;f&quot;; }
11480  std::string ratio_string&lt;std::pico&gt;::symbol() { return &quot;p&quot;; }
11481  std::string ratio_string&lt;std::nano&gt;::symbol() { return &quot;n&quot;; }
11482  std::string ratio_string&lt;std::micro&gt;::symbol() { return &quot;u&quot;; }
11483  std::string ratio_string&lt;std::milli&gt;::symbol() { return &quot;m&quot;; }
11484  } 
11485  #if defined(__clang__)
11486  #    pragma clang diagnostic pop
11487  #endif
11488  namespace Catch {
11489      Counts Counts::operator - ( Counts const&amp; other ) const {
11490          Counts diff;
11491          diff.passed = passed - other.passed;
11492          diff.failed = failed - other.failed;
11493          diff.failedButOk = failedButOk - other.failedButOk;
11494          return diff;
11495      }
11496      Counts&amp; Counts::operator += ( Counts const&amp; other ) {
11497          passed += other.passed;
11498          failed += other.failed;
11499          failedButOk += other.failedButOk;
11500          return *this;
11501      }
11502      std::size_t Counts::total() const {
11503          return passed + failed + failedButOk;
11504      }
11505      bool Counts::allPassed() const {
11506          return failed == 0 &amp;&amp; failedButOk == 0;
11507      }
11508      bool Counts::allOk() const {
11509          return failed == 0;
11510      }
11511      Totals Totals::operator - ( Totals const&amp; other ) const {
11512          Totals diff;
11513          diff.assertions = assertions - other.assertions;
11514          diff.testCases = testCases - other.testCases;
11515          return diff;
11516      }
11517      Totals&amp; Totals::operator += ( Totals const&amp; other ) {
11518          assertions += other.assertions;
11519          testCases += other.testCases;
11520          return *this;
11521      }
11522      Totals Totals::delta( Totals const&amp; prevTotals ) const {
11523          Totals diff = *this - prevTotals;
11524          if( diff.assertions.failed &gt; 0 )
11525              ++diff.testCases.failed;
11526          else if( diff.assertions.failedButOk &gt; 0 )
11527              ++diff.testCases.failedButOk;
11528          else
11529              ++diff.testCases.passed;
11530          return diff;
11531      }
11532  }
11533  #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11534  #define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
11535  #if defined(_MSC_VER)
11536  #  if _MSC_VER &gt;= 1900 
11537  #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11538  #  endif
11539  #endif
11540  #include &lt;exception&gt;
11541  #if defined(__cpp_lib_uncaught_exceptions) \
11542      &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11543  #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11544  #endif 
11545  #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \
11546      &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \
11547      &amp;&amp; !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11548  #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
11549  #endif
11550  #endif 
11551  #include &lt;exception&gt;
11552  namespace Catch {
11553      bool uncaught_exceptions() {
11554  #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
11555          return false;
11556  #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11557          return std::uncaught_exceptions() &gt; 0;
11558  #else
11559          return std::uncaught_exception();
11560  #endif
11561    }
11562  } 
11563  #include &lt;ostream&gt;
11564  namespace Catch {
11565      Version::Version
11566          (   unsigned int _majorVersion,
11567              unsigned int _minorVersion,
11568              unsigned int _patchNumber,
11569              char const * const _branchName,
11570              unsigned int _buildNumber )
11571      :   majorVersion( _majorVersion ),
11572          minorVersion( _minorVersion ),
11573          patchNumber( _patchNumber ),
11574          branchName( _branchName ),
11575          buildNumber( _buildNumber )
11576      {}
11577      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, Version const&amp; version ) {
11578          os  &lt;&lt; version.majorVersion &lt;&lt; &#x27;.&#x27;
11579              &lt;&lt; version.minorVersion &lt;&lt; &#x27;.&#x27;
11580              &lt;&lt; version.patchNumber;
11581          if (version.branchName[0]) {
11582              os &lt;&lt; &#x27;-&#x27; &lt;&lt; version.branchName
11583                 &lt;&lt; &#x27;.&#x27; &lt;&lt; version.buildNumber;
11584          }
11585          return os;
11586      }
11587      Version const&amp; libraryVersion() {
11588          static Version version( 2, 13, 7, &quot;&quot;, 0 );
11589          return version;
11590      }
11591  }
11592  namespace Catch {
11593      WildcardPattern::WildcardPattern( std::string const&amp; pattern,
11594                                        CaseSensitive::Choice caseSensitivity )
11595      :   m_caseSensitivity( caseSensitivity ),
11596          m_pattern( normaliseString( pattern ) )
11597      {
11598          if( startsWith( m_pattern, &#x27;*&#x27; ) ) {
11599              m_pattern = m_pattern.substr( 1 );
11600              m_wildcard = WildcardAtStart;
11601          }
11602          if( endsWith( m_pattern, &#x27;*&#x27; ) ) {
11603              m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
11604              m_wildcard = static_cast&lt;WildcardPosition&gt;( m_wildcard | WildcardAtEnd );
11605          }
11606      }
11607      bool WildcardPattern::matches( std::string const&amp; str ) const {
11608          switch( m_wildcard ) {
11609              case NoWildcard:
11610                  return m_pattern == normaliseString( str );
11611              case WildcardAtStart:
11612                  return endsWith( normaliseString( str ), m_pattern );
11613              case WildcardAtEnd:
11614                  return startsWith( normaliseString( str ), m_pattern );
11615              case WildcardAtBothEnds:
11616                  return contains( normaliseString( str ), m_pattern );
11617              default:
11618                  CATCH_INTERNAL_ERROR( &quot;Unknown enum&quot; );
11619          }
11620      }
11621      std::string WildcardPattern::normaliseString( std::string const&amp; str ) const {
11622          return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
11623      }
11624  }
11625  #include &lt;iomanip&gt;
11626  #include &lt;type_traits&gt;
11627  namespace Catch {
11628  namespace {
11629      size_t trailingBytes(unsigned char c) {
11630          if ((c &amp; 0xE0) == 0xC0) {
11631              return 2;
11632          }
11633          if ((c &amp; 0xF0) == 0xE0) {
11634              return 3;
11635          }
11636          if ((c &amp; 0xF8) == 0xF0) {
11637              return 4;
11638          }
11639          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11640      }
11641      uint32_t headerValue(unsigned char c) {
11642          if ((c &amp; 0xE0) == 0xC0) {
11643              return c &amp; 0x1F;
11644          }
11645          if ((c &amp; 0xF0) == 0xE0) {
11646              return c &amp; 0x0F;
11647          }
11648          if ((c &amp; 0xF8) == 0xF0) {
11649              return c &amp; 0x07;
11650          }
11651          CATCH_INTERNAL_ERROR(&quot;Invalid multibyte utf-8 start byte encountered&quot;);
11652      }
11653      void hexEscapeChar(std::ostream&amp; os, unsigned char c) {
11654          std::ios_base::fmtflags f(os.flags());
11655          os &lt;&lt; &quot;\\x&quot;
11656              &lt;&lt; std::uppercase &lt;&lt; std::hex &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(2)
11657              &lt;&lt; static_cast&lt;int&gt;(c);
11658          os.flags(f);
11659      }
11660      bool shouldNewline(XmlFormatting fmt) {
11661          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Newline));
11662      }
11663      bool shouldIndent(XmlFormatting fmt) {
11664          return !!(static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(fmt &amp; XmlFormatting::Indent));
11665      }
11666  } 
11667      XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
11668          return static_cast&lt;XmlFormatting&gt;(
11669              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) |
11670              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11671          );
11672      }
11673      XmlFormatting operator &amp; (XmlFormatting lhs, XmlFormatting rhs) {
11674          return static_cast&lt;XmlFormatting&gt;(
11675              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(lhs) &amp;
11676              static_cast&lt;std::underlying_type&lt;XmlFormatting&gt;::type&gt;(rhs)
11677          );
11678      }
11679      XmlEncode::XmlEncode( std::string const&amp; str, ForWhat forWhat )
11680      :   m_str( str ),
11681          m_forWhat( forWhat )
11682      {}
11683      void XmlEncode::encodeTo( std::ostream&amp; os ) const {
11684          for( std::size_t idx = 0; idx &lt; m_str.size(); ++ idx ) {
11685              unsigned char c = m_str[idx];
11686              switch (c) {
11687              case &#x27;&lt;&#x27;:   os &lt;&lt; &quot;&amp;lt;&quot;; break;
11688              case &#x27;&amp;&#x27;:   os &lt;&lt; &quot;&amp;amp;&quot;; break;
11689              case &#x27;&gt;&#x27;:
11690                  if (idx &gt; 2 &amp;&amp; m_str[idx - 1] == &#x27;]&#x27; &amp;&amp; m_str[idx - 2] == &#x27;]&#x27;)
11691                      os &lt;&lt; &quot;&amp;gt;&quot;;
11692                  else
11693                      os &lt;&lt; c;
11694                  break;
11695              case &#x27;\&quot;&#x27;:
11696                  if (m_forWhat == ForAttributes)
11697                      os &lt;&lt; &quot;&amp;quot;&quot;;
11698                  else
11699                      os &lt;&lt; c;
11700                  break;
11701              default:
11702                  if (c &lt; 0x09 || (c &gt; 0x0D &amp;&amp; c &lt; 0x20) || c == 0x7F) {
11703                      hexEscapeChar(os, c);
11704                      break;
11705                  }
11706                  if (c &lt; 0x7F) {
11707                      os &lt;&lt; c;
11708                      break;
11709                  }
11710                  if (c &lt;  0xC0 ||
11711                      c &gt;= 0xF8) {
11712                      hexEscapeChar(os, c);
11713                      break;
11714                  }
11715                  auto encBytes = trailingBytes(c);
11716                  if (idx + encBytes - 1 &gt;= m_str.size()) {
11717                      hexEscapeChar(os, c);
11718                      break;
11719                  }
11720                  bool valid = true;
11721                  uint32_t value = headerValue(c);
11722                  for (std::size_t n = 1; n &lt; encBytes; ++n) {
11723                      unsigned char nc = m_str[idx + n];
11724                      valid &amp;= ((nc &amp; 0xC0) == 0x80);
11725                      value = (value &lt;&lt; 6) | (nc &amp; 0x3F);
11726                  }
11727                  if (
11728                      (!valid) ||
11729                      (value &lt; 0x80) ||
11730                      (0x80 &lt;= value &amp;&amp; value &lt; 0x800   &amp;&amp; encBytes &gt; 2) ||
11731                      (0x800 &lt; value &amp;&amp; value &lt; 0x10000 &amp;&amp; encBytes &gt; 3) ||
11732                      (value &gt;= 0x110000)
11733                      ) {
11734                      hexEscapeChar(os, c);
11735                      break;
11736                  }
11737                  for (std::size_t n = 0; n &lt; encBytes; ++n) {
11738                      os &lt;&lt; m_str[idx + n];
11739                  }
11740                  idx += encBytes - 1;
11741                  break;
11742              }
11743          }
11744      }
11745      std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode ) {
11746          xmlEncode.encodeTo( os );
11747          return os;
11748      }
11749      XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
11750      :   m_writer( writer ),
11751          m_fmt(fmt)
11752      {}
11753      XmlWriter::ScopedElement::ScopedElement( ScopedElement&amp;&amp; other ) noexcept
11754      :   m_writer( other.m_writer ),
11755          m_fmt(other.m_fmt)
11756      {
11757          other.m_writer = nullptr;
11758          other.m_fmt = XmlFormatting::None;
11759      }
11760      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::operator=( ScopedElement&amp;&amp; other ) noexcept {
11761          if ( m_writer ) {
11762              m_writer-&gt;endElement();
11763          }
11764          m_writer = other.m_writer;
11765          other.m_writer = nullptr;
11766          m_fmt = other.m_fmt;
11767          other.m_fmt = XmlFormatting::None;
11768          return *this;
11769      }
11770      XmlWriter::ScopedElement::~ScopedElement() {
11771          if (m_writer) {
11772              m_writer-&gt;endElement(m_fmt);
11773          }
11774      }
11775      XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::writeText( std::string const&amp; text, XmlFormatting fmt ) {
11776          m_writer-&gt;writeText( text, fmt );
11777          return *this;
11778      }
11779      XmlWriter::XmlWriter( std::ostream&amp; os ) : m_os( os )
11780      {
11781          writeDeclaration();
11782      }
11783      XmlWriter::~XmlWriter() {
11784          while (!m_tags.empty()) {
11785              endElement();
11786          }
11787          newlineIfNecessary();
11788      }
11789      XmlWriter&amp; XmlWriter::startElement( std::string const&amp; name, XmlFormatting fmt ) {
11790          ensureTagClosed();
11791          newlineIfNecessary();
11792          if (shouldIndent(fmt)) {
11793              m_os &lt;&lt; m_indent;
11794              m_indent += &quot;  &quot;;
11795          }
11796          m_os &lt;&lt; &#x27;&lt;&#x27; &lt;&lt; name;
11797          m_tags.push_back( name );
11798          m_tagIsOpen = true;
11799          applyFormatting(fmt);
11800          return *this;
11801      }
11802      XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const&amp; name, XmlFormatting fmt ) {
11803          ScopedElement scoped( this, fmt );
11804          startElement( name, fmt );
11805          return scoped;
11806      }
11807      XmlWriter&amp; XmlWriter::endElement(XmlFormatting fmt) {
11808          m_indent = m_indent.substr(0, m_indent.size() - 2);
11809          if( m_tagIsOpen ) {
11810              m_os &lt;&lt; &quot;/&gt;&quot;;
11811              m_tagIsOpen = false;
11812          } else {
11813              newlineIfNecessary();
11814              if (shouldIndent(fmt)) {
11815                  m_os &lt;&lt; m_indent;
11816              }
11817              m_os &lt;&lt; &quot;&lt;/&quot; &lt;&lt; m_tags.back() &lt;&lt; &quot;&gt;&quot;;
11818          }
11819          m_os &lt;&lt; std::flush;
11820          applyFormatting(fmt);
11821          m_tags.pop_back();
11822          return *this;
11823      }
11824      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, std::string const&amp; attribute ) {
11825          if( !name.empty() &amp;&amp; !attribute.empty() )
11826              m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; XmlEncode( attribute, XmlEncode::ForAttributes ) &lt;&lt; &#x27;&quot;&#x27;;
11827          return *this;
11828      }
11829      XmlWriter&amp; XmlWriter::writeAttribute( std::string const&amp; name, bool attribute ) {
11830          m_os &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; ( attribute ? &quot;true&quot; : &quot;false&quot; ) &lt;&lt; &#x27;&quot;&#x27;;
11831          return *this;
11832      }
11833      XmlWriter&amp; XmlWriter::writeText( std::string const&amp; text, XmlFormatting fmt) {
11834          if( !text.empty() ){
11835              bool tagWasOpen = m_tagIsOpen;
11836              ensureTagClosed();
11837              if (tagWasOpen &amp;&amp; shouldIndent(fmt)) {
11838                  m_os &lt;&lt; m_indent;
11839              }
11840              m_os &lt;&lt; XmlEncode( text );
11841              applyFormatting(fmt);
11842          }
11843          return *this;
11844      }
11845      XmlWriter&amp; XmlWriter::writeComment( std::string const&amp; text, XmlFormatting fmt) {
11846          ensureTagClosed();
11847          if (shouldIndent(fmt)) {
11848              m_os &lt;&lt; m_indent;
11849          }
11850          m_os &lt;&lt; &quot;&lt;!--&quot; &lt;&lt; text &lt;&lt; &quot;--&gt;&quot;;
11851          applyFormatting(fmt);
11852          return *this;
11853      }
11854      void XmlWriter::writeStylesheetRef( std::string const&amp; url ) {
11855          m_os &lt;&lt; &quot;&lt;?xml-stylesheet type=\&quot;text/xsl\&quot; href=\&quot;&quot; &lt;&lt; url &lt;&lt; &quot;\&quot;?&gt;\n&quot;;
11856      }
11857      XmlWriter&amp; XmlWriter::writeBlankLine() {
11858          ensureTagClosed();
11859          m_os &lt;&lt; &#x27;\n&#x27;;
11860          return *this;
11861      }
11862      void XmlWriter::ensureTagClosed() {
11863          if( m_tagIsOpen ) {
11864              m_os &lt;&lt; &#x27;&gt;&#x27; &lt;&lt; std::flush;
11865              newlineIfNecessary();
11866              m_tagIsOpen = false;
11867          }
11868      }
11869      void XmlWriter::applyFormatting(XmlFormatting fmt) {
11870          m_needsNewline = shouldNewline(fmt);
11871      }
11872      void XmlWriter::writeDeclaration() {
11873          m_os &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;
11874      }
11875      void XmlWriter::newlineIfNecessary() {
11876          if( m_needsNewline ) {
11877              m_os &lt;&lt; std::endl;
11878              m_needsNewline = false;
11879          }
11880      }
11881  }
11882  #include &lt;cstring&gt;
11883  #include &lt;cfloat&gt;
11884  #include &lt;cstdio&gt;
11885  #include &lt;cassert&gt;
11886  #include &lt;memory&gt;
11887  namespace Catch {
11888      void prepareExpandedExpression(AssertionResult&amp; result) {
11889          result.getExpandedExpression();
11890      }
11891      std::string getFormattedDuration( double duration ) {
11892          const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
11893          char buffer[maxDoubleSize];
11894          ErrnoGuard guard;
11895  #ifdef _MSC_VER
11896          sprintf_s(buffer, &quot;%.3f&quot;, duration);
11897  #else
11898          std::sprintf(buffer, &quot;%.3f&quot;, duration);
11899  #endif
11900          return std::string(buffer);
11901      }
11902      bool shouldShowDuration( IConfig const&amp; config, double duration ) {
11903          if ( config.showDurations() == ShowDurations::Always ) {
11904              return true;
11905          }
11906          if ( config.showDurations() == ShowDurations::Never ) {
11907              return false;
11908          }
11909          const double min = config.minDuration();
11910          return min &gt;= 0 &amp;&amp; duration &gt;= min;
11911      }
11912      std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; container ) {
11913          ReusableStringStream oss;
11914          bool first = true;
11915          for (auto&amp;&amp; filter : container)
11916          {
11917              if (!first)
11918                  oss &lt;&lt; &#x27; &#x27;;
11919              else
11920                  first = false;
11921              oss &lt;&lt; filter;
11922          }
11923          return oss.str();
11924      }
11925      TestEventListenerBase::TestEventListenerBase(ReporterConfig const &amp; _config)
11926          :StreamingReporterBase(_config) {}
11927      std::set&lt;Verbosity&gt; TestEventListenerBase::getSupportedVerbosities() {
11928          return { Verbosity::Quiet, Verbosity::Normal, Verbosity::High };
11929      }
11930      void TestEventListenerBase::assertionStarting(AssertionInfo const &amp;) {}
11931      bool TestEventListenerBase::assertionEnded(AssertionStats const &amp;) {
11932          return false;
11933      }
11934  } 
11935  namespace {
11936  #ifdef CATCH_PLATFORM_MAC
11937      const char* failedString() { return &quot;FAILED&quot;; }
11938      const char* passedString() { return &quot;PASSED&quot;; }
11939  #else
11940      const char* failedString() { return &quot;failed&quot;; }
11941      const char* passedString() { return &quot;passed&quot;; }
11942  #endif
11943      Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
11944      std::string bothOrAll( std::size_t count ) {
11945          return count == 1 ? std::string() :
11946                 count == 2 ? &quot;both &quot; : &quot;all &quot; ;
11947      }
11948  } 
11949  namespace Catch {
11950  namespace {
11951  void printTotals(std::ostream&amp; out, const Totals&amp; totals) {
11952      if (totals.testCases.total() == 0) {
11953          out &lt;&lt; &quot;No tests ran.&quot;;
11954      } else if (totals.testCases.failed == totals.testCases.total()) {
11955          Colour colour(Colour::ResultError);
11956          const std::string qualify_assertions_failed =
11957              totals.assertions.failed == totals.assertions.total() ?
11958              bothOrAll(totals.assertions.failed) : std::string();
11959          out &lt;&lt;
11960              &quot;Failed &quot; &lt;&lt; bothOrAll(totals.testCases.failed)
11961              &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11962              &quot;failed &quot; &lt;&lt; qualify_assertions_failed &lt;&lt;
11963              pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11964      } else if (totals.assertions.total() == 0) {
11965          out &lt;&lt;
11966              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.total())
11967              &lt;&lt; pluralise(totals.testCases.total(), &quot;test case&quot;)
11968              &lt;&lt; &quot; (no assertions).&quot;;
11969      } else if (totals.assertions.failed) {
11970          Colour colour(Colour::ResultError);
11971          out &lt;&lt;
11972              &quot;Failed &quot; &lt;&lt; pluralise(totals.testCases.failed, &quot;test case&quot;) &lt;&lt; &quot;, &quot;
11973              &quot;failed &quot; &lt;&lt; pluralise(totals.assertions.failed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11974      } else {
11975          Colour colour(Colour::ResultSuccess);
11976          out &lt;&lt;
11977              &quot;Passed &quot; &lt;&lt; bothOrAll(totals.testCases.passed)
11978              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt;
11979              &quot; with &quot; &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &#x27;.&#x27;;
11980      }
11981  }
11982  class AssertionPrinter {
11983  public:
11984      AssertionPrinter&amp; operator= (AssertionPrinter const&amp;) = delete;
11985      AssertionPrinter(AssertionPrinter const&amp;) = delete;
11986      AssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
11987          : stream(_stream)
11988          , result(_stats.assertionResult)
11989          , messages(_stats.infoMessages)
11990          , itMessage(_stats.infoMessages.begin())
11991          , printInfoMessages(_printInfoMessages) {}
11992      void print() {
11993          printSourceInfo();
11994          itMessage = messages.begin();
11995          switch (result.getResultType()) {
11996          case ResultWas::Ok:
11997              printResultType(Colour::ResultSuccess, passedString());
11998              printOriginalExpression();
11999              printReconstructedExpression();
12000              if (!result.hasExpression())
12001                  printRemainingMessages(Colour::None);
12002              else
12003                  printRemainingMessages();
12004              break;
12005          case ResultWas::ExpressionFailed:
12006              if (result.isOk())
12007                  printResultType(Colour::ResultSuccess, failedString() + std::string(&quot; - but was ok&quot;));
12008              else
12009                  printResultType(Colour::Error, failedString());
12010              printOriginalExpression();
12011              printReconstructedExpression();
12012              printRemainingMessages();
12013              break;
12014          case ResultWas::ThrewException:
12015              printResultType(Colour::Error, failedString());
12016              printIssue(&quot;unexpected exception with message:&quot;);
12017              printMessage();
12018              printExpressionWas();
12019              printRemainingMessages();
12020              break;
12021          case ResultWas::FatalErrorCondition:
12022              printResultType(Colour::Error, failedString());
12023              printIssue(&quot;fatal error condition with message:&quot;);
12024              printMessage();
12025              printExpressionWas();
12026              printRemainingMessages();
12027              break;
12028          case ResultWas::DidntThrowException:
12029              printResultType(Colour::Error, failedString());
12030              printIssue(&quot;expected exception, got none&quot;);
12031              printExpressionWas();
12032              printRemainingMessages();
12033              break;
12034          case ResultWas::Info:
12035              printResultType(Colour::None, &quot;info&quot;);
12036              printMessage();
12037              printRemainingMessages();
12038              break;
12039          case ResultWas::Warning:
12040              printResultType(Colour::None, &quot;warning&quot;);
12041              printMessage();
12042              printRemainingMessages();
12043              break;
12044          case ResultWas::ExplicitFailure:
12045              printResultType(Colour::Error, failedString());
12046              printIssue(&quot;explicitly&quot;);
12047              printRemainingMessages(Colour::None);
12048              break;
12049          case ResultWas::Unknown:
12050          case ResultWas::FailureBit:
12051          case ResultWas::Exception:
12052              printResultType(Colour::Error, &quot;** internal error **&quot;);
12053              break;
12054          }
12055      }
12056  private:
12057      void printSourceInfo() const {
12058          Colour colourGuard(Colour::FileName);
12059          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &#x27;:&#x27;;
12060      }
12061      void printResultType(Colour::Code colour, std::string const&amp; passOrFail) const {
12062          if (!passOrFail.empty()) {
12063              {
12064                  Colour colourGuard(colour);
12065                  stream &lt;&lt; &#x27; &#x27; &lt;&lt; passOrFail;
12066              }
12067              stream &lt;&lt; &#x27;:&#x27;;
12068          }
12069      }
12070      void printIssue(std::string const&amp; issue) const {
12071          stream &lt;&lt; &#x27; &#x27; &lt;&lt; issue;
12072      }
12073      void printExpressionWas() {
12074          if (result.hasExpression()) {
12075              stream &lt;&lt; &#x27;;&#x27;;
12076              {
12077                  Colour colour(dimColour());
12078                  stream &lt;&lt; &quot; expression was:&quot;;
12079              }
12080              printOriginalExpression();
12081          }
12082      }
12083      void printOriginalExpression() const {
12084          if (result.hasExpression()) {
12085              stream &lt;&lt; &#x27; &#x27; &lt;&lt; result.getExpression();
12086          }
12087      }
12088      void printReconstructedExpression() const {
12089          if (result.hasExpandedExpression()) {
12090              {
12091                  Colour colour(dimColour());
12092                  stream &lt;&lt; &quot; for: &quot;;
12093              }
12094              stream &lt;&lt; result.getExpandedExpression();
12095          }
12096      }
12097      void printMessage() {
12098          if (itMessage != messages.end()) {
12099              stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; itMessage-&gt;message &lt;&lt; &#x27;\&#x27;&#x27;;
12100              ++itMessage;
12101          }
12102      }
12103      void printRemainingMessages(Colour::Code colour = dimColour()) {
12104          if (itMessage == messages.end())
12105              return;
12106          const auto itEnd = messages.cend();
12107          const auto N = static_cast&lt;std::size_t&gt;(std::distance(itMessage, itEnd));
12108          {
12109              Colour colourGuard(colour);
12110              stream &lt;&lt; &quot; with &quot; &lt;&lt; pluralise(N, &quot;message&quot;) &lt;&lt; &#x27;:&#x27;;
12111          }
12112          while (itMessage != itEnd) {
12113              if (printInfoMessages || itMessage-&gt;type != ResultWas::Info) {
12114                  printMessage();
12115                  if (itMessage != itEnd) {
12116                      Colour colourGuard(dimColour());
12117                      stream &lt;&lt; &quot; and&quot;;
12118                  }
12119                  continue;
12120              }
12121              ++itMessage;
12122          }
12123      }
12124  private:
12125      std::ostream&amp; stream;
12126      AssertionResult const&amp; result;
12127      std::vector&lt;MessageInfo&gt; messages;
12128      std::vector&lt;MessageInfo&gt;::const_iterator itMessage;
12129      bool printInfoMessages;
12130  };
12131  } 
12132          std::string CompactReporter::getDescription() {
12133              return &quot;Reports test results on a single line, suitable for IDEs&quot;;
12134          }
12135          void CompactReporter::noMatchingTestCases( std::string const&amp; spec ) {
12136              stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12137          }
12138          void CompactReporter::assertionStarting( AssertionInfo const&amp; ) {}
12139          bool CompactReporter::assertionEnded( AssertionStats const&amp; _assertionStats ) {
12140              AssertionResult const&amp; result = _assertionStats.assertionResult;
12141              bool printInfoMessages = true;
12142              if( !m_config-&gt;includeSuccessfulResults() &amp;&amp; result.isOk() ) {
12143                  if( result.getResultType() != ResultWas::Warning )
12144                      return false;
12145                  printInfoMessages = false;
12146              }
12147              AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
12148              printer.print();
12149              stream &lt;&lt; std::endl;
12150              return true;
12151          }
12152          void CompactReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12153              double dur = _sectionStats.durationInSeconds;
12154              if ( shouldShowDuration( *m_config, dur ) ) {
12155                  stream &lt;&lt; getFormattedDuration( dur ) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12156              }
12157          }
12158          void CompactReporter::testRunEnded( TestRunStats const&amp; _testRunStats ) {
12159              printTotals( stream, _testRunStats.totals );
12160              stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12161              StreamingReporterBase::testRunEnded( _testRunStats );
12162          }
12163          CompactReporter::~CompactReporter() {}
12164      CATCH_REGISTER_REPORTER( &quot;compact&quot;, CompactReporter )
12165  } 
12166  #include &lt;cfloat&gt;
12167  #include &lt;cstdio&gt;
12168  #if defined(_MSC_VER)
12169  #pragma warning(push)
12170  #pragma warning(disable:4061) 
12171  #endif
12172  #if defined(__clang__)
12173  #  pragma clang diagnostic push
12174  #  pragma clang diagnostic ignored &quot;-Wunused-function&quot;
12175  #endif
12176  namespace Catch {
12177  namespace {
12178  class ConsoleAssertionPrinter {
12179  public:
12180      ConsoleAssertionPrinter&amp; operator= (ConsoleAssertionPrinter const&amp;) = delete;
12181      ConsoleAssertionPrinter(ConsoleAssertionPrinter const&amp;) = delete;
12182      ConsoleAssertionPrinter(std::ostream&amp; _stream, AssertionStats const&amp; _stats, bool _printInfoMessages)
12183          : stream(_stream),
12184          stats(_stats),
12185          result(_stats.assertionResult),
12186          colour(Colour::None),
12187          message(result.getMessage()),
12188          messages(_stats.infoMessages),
12189          printInfoMessages(_printInfoMessages) {
12190          switch (result.getResultType()) {
12191          case ResultWas::Ok:
12192              colour = Colour::Success;
12193              passOrFail = &quot;PASSED&quot;;
12194              if (_stats.infoMessages.size() == 1)
12195                  messageLabel = &quot;with message&quot;;
12196              if (_stats.infoMessages.size() &gt; 1)
12197                  messageLabel = &quot;with messages&quot;;
12198              break;
12199          case ResultWas::ExpressionFailed:
12200              if (result.isOk()) {
12201                  colour = Colour::Success;
12202                  passOrFail = &quot;FAILED - but was ok&quot;;
12203              } else {
12204                  colour = Colour::Error;
12205                  passOrFail = &quot;FAILED&quot;;
12206              }
12207              if (_stats.infoMessages.size() == 1)
12208                  messageLabel = &quot;with message&quot;;
12209              if (_stats.infoMessages.size() &gt; 1)
12210                  messageLabel = &quot;with messages&quot;;
12211              break;
12212          case ResultWas::ThrewException:
12213              colour = Colour::Error;
12214              passOrFail = &quot;FAILED&quot;;
12215              messageLabel = &quot;due to unexpected exception with &quot;;
12216              if (_stats.infoMessages.size() == 1)
12217                  messageLabel += &quot;message&quot;;
12218              if (_stats.infoMessages.size() &gt; 1)
12219                  messageLabel += &quot;messages&quot;;
12220              break;
12221          case ResultWas::FatalErrorCondition:
12222              colour = Colour::Error;
12223              passOrFail = &quot;FAILED&quot;;
12224              messageLabel = &quot;due to a fatal error condition&quot;;
12225              break;
12226          case ResultWas::DidntThrowException:
12227              colour = Colour::Error;
12228              passOrFail = &quot;FAILED&quot;;
12229              messageLabel = &quot;because no exception was thrown where one was expected&quot;;
12230              break;
12231          case ResultWas::Info:
12232              messageLabel = &quot;info&quot;;
12233              break;
12234          case ResultWas::Warning:
12235              messageLabel = &quot;warning&quot;;
12236              break;
12237          case ResultWas::ExplicitFailure:
12238              passOrFail = &quot;FAILED&quot;;
12239              colour = Colour::Error;
12240              if (_stats.infoMessages.size() == 1)
12241                  messageLabel = &quot;explicitly with message&quot;;
12242              if (_stats.infoMessages.size() &gt; 1)
12243                  messageLabel = &quot;explicitly with messages&quot;;
12244              break;
12245          case ResultWas::Unknown:
12246          case ResultWas::FailureBit:
12247          case ResultWas::Exception:
12248              passOrFail = &quot;** internal error **&quot;;
12249              colour = Colour::Error;
12250              break;
12251          }
12252      }
12253      void print() const {
12254          printSourceInfo();
12255          if (stats.totals.assertions.total() &gt; 0) {
12256              printResultType();
12257              printOriginalExpression();
12258              printReconstructedExpression();
12259          } else {
12260              stream &lt;&lt; &#x27;\n&#x27;;
12261          }
12262          printMessage();
12263      }
12264  private:
12265      void printResultType() const {
12266          if (!passOrFail.empty()) {
12267              Colour colourGuard(colour);
12268              stream &lt;&lt; passOrFail &lt;&lt; &quot;:\n&quot;;
12269          }
12270      }
12271      void printOriginalExpression() const {
12272          if (result.hasExpression()) {
12273              Colour colourGuard(Colour::OriginalExpression);
12274              stream &lt;&lt; &quot;  &quot;;
12275              stream &lt;&lt; result.getExpressionInMacro();
12276              stream &lt;&lt; &#x27;\n&#x27;;
12277          }
12278      }
12279      void printReconstructedExpression() const {
12280          if (result.hasExpandedExpression()) {
12281              stream &lt;&lt; &quot;with expansion:\n&quot;;
12282              Colour colourGuard(Colour::ReconstructedExpression);
12283              stream &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12284          }
12285      }
12286      void printMessage() const {
12287          if (!messageLabel.empty())
12288              stream &lt;&lt; messageLabel &lt;&lt; &#x27;:&#x27; &lt;&lt; &#x27;\n&#x27;;
12289          for (auto const&amp; msg : messages) {
12290              if (printInfoMessages || msg.type != ResultWas::Info)
12291                  stream &lt;&lt; Column(msg.message).indent(2) &lt;&lt; &#x27;\n&#x27;;
12292          }
12293      }
12294      void printSourceInfo() const {
12295          Colour colourGuard(Colour::FileName);
12296          stream &lt;&lt; result.getSourceInfo() &lt;&lt; &quot;: &quot;;
12297      }
12298      std::ostream&amp; stream;
12299      AssertionStats const&amp; stats;
12300      AssertionResult const&amp; result;
12301      Colour::Code colour;
12302      std::string passOrFail;
12303      std::string messageLabel;
12304      std::string message;
12305      std::vector&lt;MessageInfo&gt; messages;
12306      bool printInfoMessages;
12307  };
12308  std::size_t makeRatio(std::size_t number, std::size_t total) {
12309      std::size_t ratio = total &gt; 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
12310      return (ratio == 0 &amp;&amp; number &gt; 0) ? 1 : ratio;
12311  }
12312  std::size_t&amp; findMax(std::size_t&amp; i, std::size_t&amp; j, std::size_t&amp; k) {
12313      if (i &gt; j &amp;&amp; i &gt; k)
12314          return i;
12315      else if (j &gt; k)
12316          return j;
12317      else
12318          return k;
12319  }
12320  struct ColumnInfo {
12321      enum Justification { Left, Right };
12322      std::string name;
12323      int width;
12324      Justification justification;
12325  };
12326  struct ColumnBreak {};
12327  struct RowBreak {};
12328  class Duration {
12329      enum class Unit {
12330          Auto,
12331          Nanoseconds,
12332          Microseconds,
12333          Milliseconds,
12334          Seconds,
12335          Minutes
12336      };
12337      static const uint64_t s_nanosecondsInAMicrosecond = 1000;
12338      static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
12339      static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
12340      static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
12341      double m_inNanoseconds;
12342      Unit m_units;
12343  public:
12344      explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
12345          : m_inNanoseconds(inNanoseconds),
12346          m_units(units) {
12347          if (m_units == Unit::Auto) {
12348              if (m_inNanoseconds &lt; s_nanosecondsInAMicrosecond)
12349                  m_units = Unit::Nanoseconds;
12350              else if (m_inNanoseconds &lt; s_nanosecondsInAMillisecond)
12351                  m_units = Unit::Microseconds;
12352              else if (m_inNanoseconds &lt; s_nanosecondsInASecond)
12353                  m_units = Unit::Milliseconds;
12354              else if (m_inNanoseconds &lt; s_nanosecondsInAMinute)
12355                  m_units = Unit::Seconds;
12356              else
12357                  m_units = Unit::Minutes;
12358          }
12359      }
12360      auto value() const -&gt; double {
12361          switch (m_units) {
12362          case Unit::Microseconds:
12363              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMicrosecond);
12364          case Unit::Milliseconds:
12365              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMillisecond);
12366          case Unit::Seconds:
12367              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInASecond);
12368          case Unit::Minutes:
12369              return m_inNanoseconds / static_cast&lt;double&gt;(s_nanosecondsInAMinute);
12370          default:
12371              return m_inNanoseconds;
12372          }
12373      }
12374      auto unitsAsString() const -&gt; std::string {
12375          switch (m_units) {
12376          case Unit::Nanoseconds:
12377              return &quot;ns&quot;;
12378          case Unit::Microseconds:
12379              return &quot;us&quot;;
12380          case Unit::Milliseconds:
12381              return &quot;ms&quot;;
12382          case Unit::Seconds:
12383              return &quot;s&quot;;
12384          case Unit::Minutes:
12385              return &quot;m&quot;;
12386          default:
12387              return &quot;** internal error **&quot;;
12388          }
12389      }
12390      friend auto operator &lt;&lt; (std::ostream&amp; os, Duration const&amp; duration) -&gt; std::ostream&amp; {
12391          return os &lt;&lt; duration.value() &lt;&lt; &#x27; &#x27; &lt;&lt; duration.unitsAsString();
12392      }
12393  };
12394  } 
12395  class TablePrinter {
12396      std::ostream&amp; m_os;
12397      std::vector&lt;ColumnInfo&gt; m_columnInfos;
12398      std::ostringstream m_oss;
12399      int m_currentColumn = -1;
12400      bool m_isOpen = false;
12401  public:
12402      TablePrinter( std::ostream&amp; os, std::vector&lt;ColumnInfo&gt; columnInfos )
12403      :   m_os( os ),
12404          m_columnInfos( std::move( columnInfos ) ) {}
12405      auto columnInfos() const -&gt; std::vector&lt;ColumnInfo&gt; const&amp; {
12406          return m_columnInfos;
12407      }
12408      void open() {
12409          if (!m_isOpen) {
12410              m_isOpen = true;
12411              *this &lt;&lt; RowBreak();
12412  			Columns headerCols;
12413  			Spacer spacer(2);
12414  			for (auto const&amp; info : m_columnInfos) {
12415  				headerCols += Column(info.name).width(static_cast&lt;std::size_t&gt;(info.width - 2));
12416  				headerCols += spacer;
12417  			}
12418  			m_os &lt;&lt; headerCols &lt;&lt; &#x27;\n&#x27;;
12419              m_os &lt;&lt; Catch::getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12420          }
12421      }
12422      void close() {
12423          if (m_isOpen) {
12424              *this &lt;&lt; RowBreak();
12425              m_os &lt;&lt; std::endl;
12426              m_isOpen = false;
12427          }
12428      }
12429      template&lt;typename T&gt;
12430      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, T const&amp; value) {
12431          tp.m_oss &lt;&lt; value;
12432          return tp;
12433      }
12434      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, ColumnBreak) {
12435          auto colStr = tp.m_oss.str();
12436          const auto strSize = colStr.size();
12437          tp.m_oss.str(&quot;&quot;);
12438          tp.open();
12439          if (tp.m_currentColumn == static_cast&lt;int&gt;(tp.m_columnInfos.size() - 1)) {
12440              tp.m_currentColumn = -1;
12441              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12442          }
12443          tp.m_currentColumn++;
12444          auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
12445          auto padding = (strSize + 1 &lt; static_cast&lt;std::size_t&gt;(colInfo.width))
12446              ? std::string(colInfo.width - (strSize + 1), &#x27; &#x27;)
12447              : std::string();
12448          if (colInfo.justification == ColumnInfo::Left)
12449              tp.m_os &lt;&lt; colStr &lt;&lt; padding &lt;&lt; &#x27; &#x27;;
12450          else
12451              tp.m_os &lt;&lt; padding &lt;&lt; colStr &lt;&lt; &#x27; &#x27;;
12452          return tp;
12453      }
12454      friend TablePrinter&amp; operator &lt;&lt; (TablePrinter&amp; tp, RowBreak) {
12455          if (tp.m_currentColumn &gt; 0) {
12456              tp.m_os &lt;&lt; &#x27;\n&#x27;;
12457              tp.m_currentColumn = -1;
12458          }
12459          return tp;
12460      }
12461  };
12462  ConsoleReporter::ConsoleReporter(ReporterConfig const&amp; config)
12463      : StreamingReporterBase(config),
12464      m_tablePrinter(new TablePrinter(config.stream(),
12465          [&amp;config]() -&gt; std::vector&lt;ColumnInfo&gt; {
12466          if (config.fullConfig()-&gt;benchmarkNoAnalysis())
12467          {
12468              return{
12469                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12470                  { &quot;     samples&quot;, 14, ColumnInfo::Right },
12471                  { &quot;  iterations&quot;, 14, ColumnInfo::Right },
12472                  { &quot;        mean&quot;, 14, ColumnInfo::Right }
12473              };
12474          }
12475          else
12476          {
12477              return{
12478                  { &quot;benchmark name&quot;, CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
12479                  { &quot;samples      mean       std dev&quot;, 14, ColumnInfo::Right },
12480                  { &quot;iterations   low mean   low std dev&quot;, 14, ColumnInfo::Right },
12481                  { &quot;estimated    high mean  high std dev&quot;, 14, ColumnInfo::Right }
12482              };
12483          }
12484      }())) {}
12485  ConsoleReporter::~ConsoleReporter() = default;
12486  std::string ConsoleReporter::getDescription() {
12487      return &quot;Reports test results as plain lines of text&quot;;
12488  }
12489  void ConsoleReporter::noMatchingTestCases(std::string const&amp; spec) {
12490      stream &lt;&lt; &quot;No test cases matched &#x27;&quot; &lt;&lt; spec &lt;&lt; &#x27;\&#x27;&#x27; &lt;&lt; std::endl;
12491  }
12492  void ConsoleReporter::reportInvalidArguments(std::string const&amp;arg){
12493      stream &lt;&lt; &quot;Invalid Filter: &quot; &lt;&lt; arg &lt;&lt; std::endl;
12494  }
12495  void ConsoleReporter::assertionStarting(AssertionInfo const&amp;) {}
12496  bool ConsoleReporter::assertionEnded(AssertionStats const&amp; _assertionStats) {
12497      AssertionResult const&amp; result = _assertionStats.assertionResult;
12498      bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
12499      if (!includeResults &amp;&amp; result.getResultType() != ResultWas::Warning)
12500          return false;
12501      lazyPrint();
12502      ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
12503      printer.print();
12504      stream &lt;&lt; std::endl;
12505      return true;
12506  }
12507  void ConsoleReporter::sectionStarting(SectionInfo const&amp; _sectionInfo) {
12508      m_tablePrinter-&gt;close();
12509      m_headerPrinted = false;
12510      StreamingReporterBase::sectionStarting(_sectionInfo);
12511  }
12512  void ConsoleReporter::sectionEnded(SectionStats const&amp; _sectionStats) {
12513      m_tablePrinter-&gt;close();
12514      if (_sectionStats.missingAssertions) {
12515          lazyPrint();
12516          Colour colour(Colour::ResultError);
12517          if (m_sectionStack.size() &gt; 1)
12518              stream &lt;&lt; &quot;\nNo assertions in section&quot;;
12519          else
12520              stream &lt;&lt; &quot;\nNo assertions in test case&quot;;
12521          stream &lt;&lt; &quot; &#x27;&quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; &quot;&#x27;\n&quot; &lt;&lt; std::endl;
12522      }
12523      double dur = _sectionStats.durationInSeconds;
12524      if (shouldShowDuration(*m_config, dur)) {
12525          stream &lt;&lt; getFormattedDuration(dur) &lt;&lt; &quot; s: &quot; &lt;&lt; _sectionStats.sectionInfo.name &lt;&lt; std::endl;
12526      }
12527      if (m_headerPrinted) {
12528          m_headerPrinted = false;
12529      }
12530      StreamingReporterBase::sectionEnded(_sectionStats);
12531  }
12532  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
12533  void ConsoleReporter::benchmarkPreparing(std::string const&amp; name) {
12534  	lazyPrintWithoutClosingBenchmarkTable();
12535  	auto nameCol = Column(name).width(static_cast&lt;std::size_t&gt;(m_tablePrinter-&gt;columnInfos()[0].width - 2));
12536  	bool firstLine = true;
12537  	for (auto line : nameCol) {
12538  		if (!firstLine)
12539  			(*m_tablePrinter) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12540  		else
12541  			firstLine = false;
12542  		(*m_tablePrinter) &lt;&lt; line &lt;&lt; ColumnBreak();
12543  	}
12544  }
12545  void ConsoleReporter::benchmarkStarting(BenchmarkInfo const&amp; info) {
12546      (*m_tablePrinter) &lt;&lt; info.samples &lt;&lt; ColumnBreak()
12547          &lt;&lt; info.iterations &lt;&lt; ColumnBreak();
12548      if (!m_config-&gt;benchmarkNoAnalysis())
12549          (*m_tablePrinter) &lt;&lt; Duration(info.estimatedDuration) &lt;&lt; ColumnBreak();
12550  }
12551  void ConsoleReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) {
12552      if (m_config-&gt;benchmarkNoAnalysis())
12553      {
12554          (*m_tablePrinter) &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak();
12555      }
12556      else
12557      {
12558          (*m_tablePrinter) &lt;&lt; ColumnBreak()
12559              &lt;&lt; Duration(stats.mean.point.count()) &lt;&lt; ColumnBreak()
12560              &lt;&lt; Duration(stats.mean.lower_bound.count()) &lt;&lt; ColumnBreak()
12561              &lt;&lt; Duration(stats.mean.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak()
12562              &lt;&lt; Duration(stats.standardDeviation.point.count()) &lt;&lt; ColumnBreak()
12563              &lt;&lt; Duration(stats.standardDeviation.lower_bound.count()) &lt;&lt; ColumnBreak()
12564              &lt;&lt; Duration(stats.standardDeviation.upper_bound.count()) &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak() &lt;&lt; ColumnBreak();
12565      }
12566  }
12567  void ConsoleReporter::benchmarkFailed(std::string const&amp; error) {
12568  	Colour colour(Colour::Red);
12569      (*m_tablePrinter)
12570          &lt;&lt; &quot;Benchmark failed (&quot; &lt;&lt; error &lt;&lt; &#x27;)&#x27;
12571          &lt;&lt; ColumnBreak() &lt;&lt; RowBreak();
12572  }
12573  #endif 
12574  void ConsoleReporter::testCaseEnded(TestCaseStats const&amp; _testCaseStats) {
12575      m_tablePrinter-&gt;close();
12576      StreamingReporterBase::testCaseEnded(_testCaseStats);
12577      m_headerPrinted = false;
12578  }
12579  void ConsoleReporter::testGroupEnded(TestGroupStats const&amp; _testGroupStats) {
12580      if (currentGroupInfo.used) {
12581          printSummaryDivider();
12582          stream &lt;&lt; &quot;Summary for group &#x27;&quot; &lt;&lt; _testGroupStats.groupInfo.name &lt;&lt; &quot;&#x27;:\n&quot;;
12583          printTotals(_testGroupStats.totals);
12584          stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12585      }
12586      StreamingReporterBase::testGroupEnded(_testGroupStats);
12587  }
12588  void ConsoleReporter::testRunEnded(TestRunStats const&amp; _testRunStats) {
12589      printTotalsDivider(_testRunStats.totals);
12590      printTotals(_testRunStats.totals);
12591      stream &lt;&lt; std::endl;
12592      StreamingReporterBase::testRunEnded(_testRunStats);
12593  }
12594  void ConsoleReporter::testRunStarting(TestRunInfo const&amp; _testInfo) {
12595      StreamingReporterBase::testRunStarting(_testInfo);
12596      printTestFilters();
12597  }
12598  void ConsoleReporter::lazyPrint() {
12599      m_tablePrinter-&gt;close();
12600      lazyPrintWithoutClosingBenchmarkTable();
12601  }
12602  void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
12603      if (!currentTestRunInfo.used)
12604          lazyPrintRunInfo();
12605      if (!currentGroupInfo.used)
12606          lazyPrintGroupInfo();
12607      if (!m_headerPrinted) {
12608          printTestCaseAndSectionHeader();
12609          m_headerPrinted = true;
12610      }
12611  }
12612  void ConsoleReporter::lazyPrintRunInfo() {
12613      stream &lt;&lt; &#x27;\n&#x27; &lt;&lt; getLineOfChars&lt;&#x27;~&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12614      Colour colour(Colour::SecondaryText);
12615      stream &lt;&lt; currentTestRunInfo-&gt;name
12616          &lt;&lt; &quot; is a Catch v&quot; &lt;&lt; libraryVersion() &lt;&lt; &quot; host application.\n&quot;
12617          &lt;&lt; &quot;Run with -? for options\n\n&quot;;
12618      if (m_config-&gt;rngSeed() != 0)
12619          stream &lt;&lt; &quot;Randomness seeded to: &quot; &lt;&lt; m_config-&gt;rngSeed() &lt;&lt; &quot;\n\n&quot;;
12620      currentTestRunInfo.used = true;
12621  }
12622  void ConsoleReporter::lazyPrintGroupInfo() {
12623      if (!currentGroupInfo-&gt;name.empty() &amp;&amp; currentGroupInfo-&gt;groupsCounts &gt; 1) {
12624          printClosedHeader(&quot;Group: &quot; + currentGroupInfo-&gt;name);
12625          currentGroupInfo.used = true;
12626      }
12627  }
12628  void ConsoleReporter::printTestCaseAndSectionHeader() {
12629      assert(!m_sectionStack.empty());
12630      printOpenHeader(currentTestCaseInfo-&gt;name);
12631      if (m_sectionStack.size() &gt; 1) {
12632          Colour colourGuard(Colour::Headers);
12633          auto
12634              it = m_sectionStack.begin() + 1, 
12635              itEnd = m_sectionStack.end();
12636          for (; it != itEnd; ++it)
12637              printHeaderString(it-&gt;name, 2);
12638      }
12639      SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
12640      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12641      Colour colourGuard(Colour::FileName);
12642      stream &lt;&lt; lineInfo &lt;&lt; &#x27;\n&#x27;;
12643      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27; &lt;&lt; std::endl;
12644  }
12645  void ConsoleReporter::printClosedHeader(std::string const&amp; _name) {
12646      printOpenHeader(_name);
12647      stream &lt;&lt; getLineOfChars&lt;&#x27;.&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12648  }
12649  void ConsoleReporter::printOpenHeader(std::string const&amp; _name) {
12650      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12651      {
12652          Colour colourGuard(Colour::Headers);
12653          printHeaderString(_name);
12654      }
12655  }
12656  void ConsoleReporter::printHeaderString(std::string const&amp; _string, std::size_t indent) {
12657      std::size_t i = _string.find(&quot;: &quot;);
12658      if (i != std::string::npos)
12659          i += 2;
12660      else
12661          i = 0;
12662      stream &lt;&lt; Column(_string).indent(indent + i).initialIndent(indent) &lt;&lt; &#x27;\n&#x27;;
12663  }
12664  struct SummaryColumn {
12665      SummaryColumn( std::string _label, Colour::Code _colour )
12666      :   label( std::move( _label ) ),
12667          colour( _colour ) {}
12668      SummaryColumn addRow( std::size_t count ) {
12669          ReusableStringStream rss;
12670          rss &lt;&lt; count;
12671          std::string row = rss.str();
12672          for (auto&amp; oldRow : rows) {
12673              while (oldRow.size() &lt; row.size())
12674                  oldRow = &#x27; &#x27; + oldRow;
12675              while (oldRow.size() &gt; row.size())
12676                  row = &#x27; &#x27; + row;
12677          }
12678          rows.push_back(row);
12679          return *this;
12680      }
12681      std::string label;
12682      Colour::Code colour;
12683      std::vector&lt;std::string&gt; rows;
12684  };
12685  void ConsoleReporter::printTotals( Totals const&amp; totals ) {
12686      if (totals.testCases.total() == 0) {
12687          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;No tests ran\n&quot;;
12688      } else if (totals.assertions.total() &gt; 0 &amp;&amp; totals.testCases.allPassed()) {
12689          stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; &quot;All tests passed&quot;;
12690          stream &lt;&lt; &quot; (&quot;
12691              &lt;&lt; pluralise(totals.assertions.passed, &quot;assertion&quot;) &lt;&lt; &quot; in &quot;
12692              &lt;&lt; pluralise(totals.testCases.passed, &quot;test case&quot;) &lt;&lt; &#x27;)&#x27;
12693              &lt;&lt; &#x27;\n&#x27;;
12694      } else {
12695          std::vector&lt;SummaryColumn&gt; columns;
12696          columns.push_back(SummaryColumn(&quot;&quot;, Colour::None)
12697                            .addRow(totals.testCases.total())
12698                            .addRow(totals.assertions.total()));
12699          columns.push_back(SummaryColumn(&quot;passed&quot;, Colour::Success)
12700                            .addRow(totals.testCases.passed)
12701                            .addRow(totals.assertions.passed));
12702          columns.push_back(SummaryColumn(&quot;failed&quot;, Colour::ResultError)
12703                            .addRow(totals.testCases.failed)
12704                            .addRow(totals.assertions.failed));
12705          columns.push_back(SummaryColumn(&quot;failed as expected&quot;, Colour::ResultExpectedFailure)
12706                            .addRow(totals.testCases.failedButOk)
12707                            .addRow(totals.assertions.failedButOk));
12708          printSummaryRow(&quot;test cases&quot;, columns, 0);
12709          printSummaryRow(&quot;assertions&quot;, columns, 1);
12710      }
12711  }
12712  void ConsoleReporter::printSummaryRow(std::string const&amp; label, std::vector&lt;SummaryColumn&gt; const&amp; cols, std::size_t row) {
12713      for (auto col : cols) {
12714          std::string value = col.rows[row];
12715          if (col.label.empty()) {
12716              stream &lt;&lt; label &lt;&lt; &quot;: &quot;;
12717              if (value != &quot;0&quot;)
12718                  stream &lt;&lt; value;
12719              else
12720                  stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; &quot;- none -&quot;;
12721          } else if (value != &quot;0&quot;) {
12722              stream &lt;&lt; Colour(Colour::LightGrey) &lt;&lt; &quot; | &quot;;
12723              stream &lt;&lt; Colour(col.colour)
12724                  &lt;&lt; value &lt;&lt; &#x27; &#x27; &lt;&lt; col.label;
12725          }
12726      }
12727      stream &lt;&lt; &#x27;\n&#x27;;
12728  }
12729  void ConsoleReporter::printTotalsDivider(Totals const&amp; totals) {
12730      if (totals.testCases.total() &gt; 0) {
12731          std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
12732          std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
12733          std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
12734          while (failedRatio + failedButOkRatio + passedRatio &lt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12735              findMax(failedRatio, failedButOkRatio, passedRatio)++;
12736          while (failedRatio + failedButOkRatio + passedRatio &gt; CATCH_CONFIG_CONSOLE_WIDTH - 1)
12737              findMax(failedRatio, failedButOkRatio, passedRatio)--;
12738          stream &lt;&lt; Colour(Colour::Error) &lt;&lt; std::string(failedRatio, &#x27;=&#x27;);
12739          stream &lt;&lt; Colour(Colour::ResultExpectedFailure) &lt;&lt; std::string(failedButOkRatio, &#x27;=&#x27;);
12740          if (totals.testCases.allPassed())
12741              stream &lt;&lt; Colour(Colour::ResultSuccess) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12742          else
12743              stream &lt;&lt; Colour(Colour::Success) &lt;&lt; std::string(passedRatio, &#x27;=&#x27;);
12744      } else {
12745          stream &lt;&lt; Colour(Colour::Warning) &lt;&lt; std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, &#x27;=&#x27;);
12746      }
12747      stream &lt;&lt; &#x27;\n&#x27;;
12748  }
12749  void ConsoleReporter::printSummaryDivider() {
12750      stream &lt;&lt; getLineOfChars&lt;&#x27;-&#x27;&gt;() &lt;&lt; &#x27;\n&#x27;;
12751  }
12752  void ConsoleReporter::printTestFilters() {
12753      if (m_config-&gt;testSpec().hasFilters()) {
12754          Colour guard(Colour::BrightYellow);
12755          stream &lt;&lt; &quot;Filters: &quot; &lt;&lt; serializeFilters(m_config-&gt;getTestsOrTags()) &lt;&lt; &#x27;\n&#x27;;
12756      }
12757  }
12758  CATCH_REGISTER_REPORTER(&quot;console&quot;, ConsoleReporter)
12759  } 
12760  #if defined(_MSC_VER)
12761  #pragma warning(pop)
12762  #endif
12763  #if defined(__clang__)
12764  #  pragma clang diagnostic pop
12765  #endif
12766  #include &lt;cassert&gt;
12767  #include &lt;sstream&gt;
12768  #include &lt;ctime&gt;
12769  #include &lt;algorithm&gt;
12770  #include &lt;iomanip&gt;
12771  namespace Catch {
12772      namespace {
12773          std::string getCurrentTimestamp() {
12774              time_t rawtime;
12775              std::time(&amp;rawtime);
12776              auto const timeStampSize = sizeof(&quot;2017-01-16T17:06:45Z&quot;);
12777  #ifdef _MSC_VER
12778              std::tm timeInfo = {};
12779              gmtime_s(&amp;timeInfo, &amp;rawtime);
12780  #else
12781              std::tm* timeInfo;
12782              timeInfo = std::gmtime(&amp;rawtime);
12783  #endif
12784              char timeStamp[timeStampSize];
12785              const char * const fmt = &quot;%Y-%m-%dT%H:%M:%SZ&quot;;
12786  #ifdef _MSC_VER
12787              std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
12788  #else
12789              std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
12790  #endif
12791              return std::string(timeStamp, timeStampSize-1);
12792          }
12793          std::string fileNameTag(const std::vector&lt;std::string&gt; &amp;tags) {
12794              auto it = std::find_if(begin(tags),
12795                                     end(tags),
12796                                     [] (std::string const&amp; tag) {return tag.front() == &#x27;#&#x27;; });
12797              if (it != tags.end())
12798                  return it-&gt;substr(1);
12799              return std::string();
12800          }
12801          std::string formatDuration( double seconds ) {
12802              ReusableStringStream rss;
12803              rss &lt;&lt; std::fixed &lt;&lt; std::setprecision( 3 ) &lt;&lt; seconds;
12804              return rss.str();
12805          }
12806      } 
12807      JunitReporter::JunitReporter( ReporterConfig const&amp; _config )
12808          :   CumulativeReporterBase( _config ),
12809              xml( _config.stream() )
12810          {
12811              m_reporterPrefs.shouldRedirectStdOut = true;
12812              m_reporterPrefs.shouldReportAllAssertions = true;
12813          }
12814      JunitReporter::~JunitReporter() {}
12815      std::string JunitReporter::getDescription() {
12816          return &quot;Reports test results in an XML format that looks like Ant&#x27;s junitreport target&quot;;
12817      }
12818      void JunitReporter::noMatchingTestCases( std::string const&amp; &amp;bsol;*spec*/ ) {}
12819      void JunitReporter::testRunStarting( TestRunInfo const&amp; runInfo )  {
12820          CumulativeReporterBase::testRunStarting( runInfo );
12821          xml.startElement( &quot;testsuites&quot; );
12822      }
12823      void JunitReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
12824          suiteTimer.start();
12825          stdOutForSuite.clear();
12826          stdErrForSuite.clear();
12827          unexpectedExceptions = 0;
12828          CumulativeReporterBase::testGroupStarting( groupInfo );
12829      }
12830      void JunitReporter::testCaseStarting( TestCaseInfo const&amp; testCaseInfo ) {
12831          m_okToFail = testCaseInfo.okToFail();
12832      }
12833      bool JunitReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
12834          if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException &amp;&amp; !m_okToFail )
12835              unexpectedExceptions++;
12836          return CumulativeReporterBase::assertionEnded( assertionStats );
12837      }
12838      void JunitReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
12839          stdOutForSuite += testCaseStats.stdOut;
12840          stdErrForSuite += testCaseStats.stdErr;
12841          CumulativeReporterBase::testCaseEnded( testCaseStats );
12842      }
12843      void JunitReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
12844          double suiteTime = suiteTimer.getElapsedSeconds();
12845          CumulativeReporterBase::testGroupEnded( testGroupStats );
12846          writeGroup( *m_testGroups.back(), suiteTime );
12847      }
12848      void JunitReporter::testRunEndedCumulative() {
12849          xml.endElement();
12850      }
12851      void JunitReporter::writeGroup( TestGroupNode const&amp; groupNode, double suiteTime ) {
12852          XmlWriter::ScopedElement e = xml.scopedElement( &quot;testsuite&quot; );
12853          TestGroupStats const&amp; stats = groupNode.value;
12854          xml.writeAttribute( &quot;name&quot;, stats.groupInfo.name );
12855          xml.writeAttribute( &quot;errors&quot;, unexpectedExceptions );
12856          xml.writeAttribute( &quot;failures&quot;, stats.totals.assertions.failed-unexpectedExceptions );
12857          xml.writeAttribute( &quot;tests&quot;, stats.totals.assertions.total() );
12858          xml.writeAttribute( &quot;hostname&quot;, &quot;tbd&quot; ); 
12859          if( m_config-&gt;showDurations() == ShowDurations::Never )
12860              xml.writeAttribute( &quot;time&quot;, &quot;&quot; );
12861          else
12862              xml.writeAttribute( &quot;time&quot;, formatDuration( suiteTime ) );
12863          xml.writeAttribute( &quot;timestamp&quot;, getCurrentTimestamp() );
12864          if (m_config-&gt;hasTestFilters() || m_config-&gt;rngSeed() != 0) {
12865              auto properties = xml.scopedElement(&quot;properties&quot;);
12866              if (m_config-&gt;hasTestFilters()) {
12867                  xml.scopedElement(&quot;property&quot;)
12868                      .writeAttribute(&quot;name&quot;, &quot;filters&quot;)
12869                      .writeAttribute(&quot;value&quot;, serializeFilters(m_config-&gt;getTestsOrTags()));
12870              }
12871              if (m_config-&gt;rngSeed() != 0) {
12872                  xml.scopedElement(&quot;property&quot;)
12873                      .writeAttribute(&quot;name&quot;, &quot;random-seed&quot;)
12874                      .writeAttribute(&quot;value&quot;, m_config-&gt;rngSeed());
12875              }
12876          }
12877          for( auto const&amp; child : groupNode.children )
12878              writeTestCase( *child );
12879          xml.scopedElement( &quot;system-out&quot; ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
12880          xml.scopedElement( &quot;system-err&quot; ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
12881      }
12882      void JunitReporter::writeTestCase( TestCaseNode const&amp; testCaseNode ) {
12883          TestCaseStats const&amp; stats = testCaseNode.value;
12884          assert( testCaseNode.children.size() == 1 );
12885          SectionNode const&amp; rootSection = *testCaseNode.children.front();
12886          std::string className = stats.testInfo.className;
12887          if( className.empty() ) {
12888              className = fileNameTag(stats.testInfo.tags);
12889              if ( className.empty() )
12890                  className = &quot;global&quot;;
12891          }
12892          if ( !m_config-&gt;name().empty() )
12893              className = m_config-&gt;name() + &quot;.&quot; + className;
12894          writeSection( className, &quot;&quot;, rootSection, stats.testInfo.okToFail() );
12895      }
12896      void JunitReporter::writeSection( std::string const&amp; className,
12897                                        std::string const&amp; rootName,
12898                                        SectionNode const&amp; sectionNode,
12899                                        bool testOkToFail) {
12900          std::string name = trim( sectionNode.stats.sectionInfo.name );
12901          if( !rootName.empty() )
12902              name = rootName + &#x27;/&#x27; + name;
12903          if( !sectionNode.assertions.empty() ||
12904              !sectionNode.stdOut.empty() ||
12905              !sectionNode.stdErr.empty() ) {
12906              XmlWriter::ScopedElement e = xml.scopedElement( &quot;testcase&quot; );
12907              if( className.empty() ) {
12908                  xml.writeAttribute( &quot;classname&quot;, name );
12909                  xml.writeAttribute( &quot;name&quot;, &quot;root&quot; );
12910              }
12911              else {
12912                  xml.writeAttribute( &quot;classname&quot;, className );
12913                  xml.writeAttribute( &quot;name&quot;, name );
12914              }
12915              xml.writeAttribute( &quot;time&quot;, formatDuration( sectionNode.stats.durationInSeconds ) );
12916              xml.writeAttribute( &quot;status&quot;, &quot;run&quot; );
12917              if (sectionNode.stats.assertions.failedButOk) {
12918                  xml.scopedElement(&quot;skipped&quot;)
12919                      .writeAttribute(&quot;message&quot;, &quot;TEST_CASE tagged with !mayfail&quot;);
12920              }
12921              writeAssertions( sectionNode );
12922              if( !sectionNode.stdOut.empty() )
12923                  xml.scopedElement( &quot;system-out&quot; ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
12924              if( !sectionNode.stdErr.empty() )
12925                  xml.scopedElement( &quot;system-err&quot; ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
12926          }
12927          for( auto const&amp; childNode : sectionNode.childSections )
12928              if( className.empty() )
12929                  writeSection( name, &quot;&quot;, *childNode, testOkToFail );
12930              else
12931                  writeSection( className, name, *childNode, testOkToFail );
12932      }
12933      void JunitReporter::writeAssertions( SectionNode const&amp; sectionNode ) {
12934          for( auto const&amp; assertion : sectionNode.assertions )
12935              writeAssertion( assertion );
12936      }
12937      void JunitReporter::writeAssertion( AssertionStats const&amp; stats ) {
12938          AssertionResult const&amp; result = stats.assertionResult;
12939          if( !result.isOk() ) {
12940              std::string elementName;
12941              switch( result.getResultType() ) {
12942                  case ResultWas::ThrewException:
12943                  case ResultWas::FatalErrorCondition:
12944                      elementName = &quot;error&quot;;
12945                      break;
12946                  case ResultWas::ExplicitFailure:
12947                  case ResultWas::ExpressionFailed:
12948                  case ResultWas::DidntThrowException:
12949                      elementName = &quot;failure&quot;;
12950                      break;
12951                  case ResultWas::Info:
12952                  case ResultWas::Warning:
12953                  case ResultWas::Ok:
12954                  case ResultWas::Unknown:
12955                  case ResultWas::FailureBit:
12956                  case ResultWas::Exception:
12957                      elementName = &quot;internalError&quot;;
12958                      break;
12959              }
12960              XmlWriter::ScopedElement e = xml.scopedElement( elementName );
12961              xml.writeAttribute( &quot;message&quot;, result.getExpression() );
12962              xml.writeAttribute( &quot;type&quot;, result.getTestMacroName() );
12963              ReusableStringStream rss;
12964              if (stats.totals.assertions.total() &gt; 0) {
12965                  rss &lt;&lt; &quot;FAILED&quot; &lt;&lt; &quot;:\n&quot;;
12966                  if (result.hasExpression()) {
12967                      rss &lt;&lt; &quot;  &quot;;
12968                      rss &lt;&lt; result.getExpressionInMacro();
12969                      rss &lt;&lt; &#x27;\n&#x27;;
12970                  }
12971                  if (result.hasExpandedExpression()) {
12972                      rss &lt;&lt; &quot;with expansion:\n&quot;;
12973                      rss &lt;&lt; Column(result.getExpandedExpression()).indent(2) &lt;&lt; &#x27;\n&#x27;;
12974                  }
12975              } else {
12976                  rss &lt;&lt; &#x27;\n&#x27;;
12977              }
12978              if( !result.getMessage().empty() )
12979                  rss &lt;&lt; result.getMessage() &lt;&lt; &#x27;\n&#x27;;
12980              for( auto const&amp; msg : stats.infoMessages )
12981                  if( msg.type == ResultWas::Info )
12982                      rss &lt;&lt; msg.message &lt;&lt; &#x27;\n&#x27;;
12983              rss &lt;&lt; &quot;at &quot; &lt;&lt; result.getSourceInfo();
12984              xml.writeText( rss.str(), XmlFormatting::Newline );
12985          }
12986      }
12987      CATCH_REGISTER_REPORTER( &quot;junit&quot;, JunitReporter )
12988  } 
12989  #include &lt;cassert&gt;
12990  namespace Catch {
12991      ListeningReporter::ListeningReporter() {
12992          m_preferences.shouldReportAllAssertions = true;
12993      }
12994      void ListeningReporter::addListener( IStreamingReporterPtr&amp;&amp; listener ) {
12995          m_listeners.push_back( std::move( listener ) );
12996      }
12997      void ListeningReporter::addReporter(IStreamingReporterPtr&amp;&amp; reporter) {
12998          assert(!m_reporter &amp;&amp; &quot;Listening reporter can wrap only 1 real reporter&quot;);
12999          m_reporter = std::move( reporter );
13000          m_preferences.shouldRedirectStdOut = m_reporter-&gt;getPreferences().shouldRedirectStdOut;
13001      }
13002      ReporterPreferences ListeningReporter::getPreferences() const {
13003          return m_preferences;
13004      }
13005      std::set&lt;Verbosity&gt; ListeningReporter::getSupportedVerbosities() {
13006          return std::set&lt;Verbosity&gt;{ };
13007      }
13008      void ListeningReporter::noMatchingTestCases( std::string const&amp; spec ) {
13009          for ( auto const&amp; listener : m_listeners ) {
13010              listener-&gt;noMatchingTestCases( spec );
13011          }
13012          m_reporter-&gt;noMatchingTestCases( spec );
13013      }
13014      void ListeningReporter::reportInvalidArguments(std::string const&amp;arg){
13015          for ( auto const&amp; listener : m_listeners ) {
13016              listener-&gt;reportInvalidArguments( arg );
13017          }
13018          m_reporter-&gt;reportInvalidArguments( arg );
13019      }
13020  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13021      void ListeningReporter::benchmarkPreparing( std::string const&amp; name ) {
13022  		for (auto const&amp; listener : m_listeners) {
13023  			listener-&gt;benchmarkPreparing(name);
13024  		}
13025  		m_reporter-&gt;benchmarkPreparing(name);
13026  	}
13027      void ListeningReporter::benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) {
13028          for ( auto const&amp; listener : m_listeners ) {
13029              listener-&gt;benchmarkStarting( benchmarkInfo );
13030          }
13031          m_reporter-&gt;benchmarkStarting( benchmarkInfo );
13032      }
13033      void ListeningReporter::benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) {
13034          for ( auto const&amp; listener : m_listeners ) {
13035              listener-&gt;benchmarkEnded( benchmarkStats );
13036          }
13037          m_reporter-&gt;benchmarkEnded( benchmarkStats );
13038      }
13039  	void ListeningReporter::benchmarkFailed( std::string const&amp; error ) {
13040  		for (auto const&amp; listener : m_listeners) {
13041  			listener-&gt;benchmarkFailed(error);
13042  		}
13043  		m_reporter-&gt;benchmarkFailed(error);
13044  	}
13045  #endif 
13046      void ListeningReporter::testRunStarting( TestRunInfo const&amp; testRunInfo ) {
13047          for ( auto const&amp; listener : m_listeners ) {
13048              listener-&gt;testRunStarting( testRunInfo );
13049          }
13050          m_reporter-&gt;testRunStarting( testRunInfo );
13051      }
13052      void ListeningReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13053          for ( auto const&amp; listener : m_listeners ) {
13054              listener-&gt;testGroupStarting( groupInfo );
13055          }
13056          m_reporter-&gt;testGroupStarting( groupInfo );
13057      }
13058      void ListeningReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13059          for ( auto const&amp; listener : m_listeners ) {
13060              listener-&gt;testCaseStarting( testInfo );
13061          }
13062          m_reporter-&gt;testCaseStarting( testInfo );
13063      }
13064      void ListeningReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13065          for ( auto const&amp; listener : m_listeners ) {
13066              listener-&gt;sectionStarting( sectionInfo );
13067          }
13068          m_reporter-&gt;sectionStarting( sectionInfo );
13069      }
13070      void ListeningReporter::assertionStarting( AssertionInfo const&amp; assertionInfo ) {
13071          for ( auto const&amp; listener : m_listeners ) {
13072              listener-&gt;assertionStarting( assertionInfo );
13073          }
13074          m_reporter-&gt;assertionStarting( assertionInfo );
13075      }
13076      bool ListeningReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13077          for( auto const&amp; listener : m_listeners ) {
13078              static_cast&lt;void&gt;( listener-&gt;assertionEnded( assertionStats ) );
13079          }
13080          return m_reporter-&gt;assertionEnded( assertionStats );
13081      }
13082      void ListeningReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13083          for ( auto const&amp; listener : m_listeners ) {
13084              listener-&gt;sectionEnded( sectionStats );
13085          }
13086          m_reporter-&gt;sectionEnded( sectionStats );
13087      }
13088      void ListeningReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13089          for ( auto const&amp; listener : m_listeners ) {
13090              listener-&gt;testCaseEnded( testCaseStats );
13091          }
13092          m_reporter-&gt;testCaseEnded( testCaseStats );
13093      }
13094      void ListeningReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13095          for ( auto const&amp; listener : m_listeners ) {
13096              listener-&gt;testGroupEnded( testGroupStats );
13097          }
13098          m_reporter-&gt;testGroupEnded( testGroupStats );
13099      }
13100      void ListeningReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13101          for ( auto const&amp; listener : m_listeners ) {
13102              listener-&gt;testRunEnded( testRunStats );
13103          }
13104          m_reporter-&gt;testRunEnded( testRunStats );
13105      }
13106      void ListeningReporter::skipTest( TestCaseInfo const&amp; testInfo ) {
13107          for ( auto const&amp; listener : m_listeners ) {
13108              listener-&gt;skipTest( testInfo );
13109          }
13110          m_reporter-&gt;skipTest( testInfo );
13111      }
13112      bool ListeningReporter::isMulti() const {
13113          return true;
13114      }
13115  } 
13116  #if defined(_MSC_VER)
13117  #pragma warning(push)
13118  #pragma warning(disable:4061) 
13119  #endif
13120  namespace Catch {
13121      XmlReporter::XmlReporter( ReporterConfig const&amp; _config )
13122      :   StreamingReporterBase( _config ),
13123          m_xml(_config.stream())
13124      {
13125          m_reporterPrefs.shouldRedirectStdOut = true;
13126          m_reporterPrefs.shouldReportAllAssertions = true;
13127      }
13128      XmlReporter::~XmlReporter() = default;
13129      std::string XmlReporter::getDescription() {
13130          return &quot;Reports test results as an XML document&quot;;
13131      }
13132      std::string XmlReporter::getStylesheetRef() const {
13133          return std::string();
13134      }
13135      void XmlReporter::writeSourceInfo( SourceLineInfo const&amp; sourceInfo ) {
13136          m_xml
13137              .writeAttribute( &quot;filename&quot;, sourceInfo.file )
13138              .writeAttribute( &quot;line&quot;, sourceInfo.line );
13139      }
13140      void XmlReporter::noMatchingTestCases( std::string const&amp; s ) {
13141          StreamingReporterBase::noMatchingTestCases( s );
13142      }
13143      void XmlReporter::testRunStarting( TestRunInfo const&amp; testInfo ) {
13144          StreamingReporterBase::testRunStarting( testInfo );
13145          std::string stylesheetRef = getStylesheetRef();
13146          if( !stylesheetRef.empty() )
13147              m_xml.writeStylesheetRef( stylesheetRef );
13148          m_xml.startElement( &quot;Catch&quot; );
13149          if( !m_config-&gt;name().empty() )
13150              m_xml.writeAttribute( &quot;name&quot;, m_config-&gt;name() );
13151          if (m_config-&gt;testSpec().hasFilters())
13152              m_xml.writeAttribute( &quot;filters&quot;, serializeFilters( m_config-&gt;getTestsOrTags() ) );
13153          if( m_config-&gt;rngSeed() != 0 )
13154              m_xml.scopedElement( &quot;Randomness&quot; )
13155                  .writeAttribute( &quot;seed&quot;, m_config-&gt;rngSeed() );
13156      }
13157      void XmlReporter::testGroupStarting( GroupInfo const&amp; groupInfo ) {
13158          StreamingReporterBase::testGroupStarting( groupInfo );
13159          m_xml.startElement( &quot;Group&quot; )
13160              .writeAttribute( &quot;name&quot;, groupInfo.name );
13161      }
13162      void XmlReporter::testCaseStarting( TestCaseInfo const&amp; testInfo ) {
13163          StreamingReporterBase::testCaseStarting(testInfo);
13164          m_xml.startElement( &quot;TestCase&quot; )
13165              .writeAttribute( &quot;name&quot;, trim( testInfo.name ) )
13166              .writeAttribute( &quot;description&quot;, testInfo.description )
13167              .writeAttribute( &quot;tags&quot;, testInfo.tagsAsString() );
13168          writeSourceInfo( testInfo.lineInfo );
13169          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13170              m_testCaseTimer.start();
13171          m_xml.ensureTagClosed();
13172      }
13173      void XmlReporter::sectionStarting( SectionInfo const&amp; sectionInfo ) {
13174          StreamingReporterBase::sectionStarting( sectionInfo );
13175          if( m_sectionDepth++ &gt; 0 ) {
13176              m_xml.startElement( &quot;Section&quot; )
13177                  .writeAttribute( &quot;name&quot;, trim( sectionInfo.name ) );
13178              writeSourceInfo( sectionInfo.lineInfo );
13179              m_xml.ensureTagClosed();
13180          }
13181      }
13182      void XmlReporter::assertionStarting( AssertionInfo const&amp; ) { }
13183      bool XmlReporter::assertionEnded( AssertionStats const&amp; assertionStats ) {
13184          AssertionResult const&amp; result = assertionStats.assertionResult;
13185          bool includeResults = m_config-&gt;includeSuccessfulResults() || !result.isOk();
13186          if( includeResults || result.getResultType() == ResultWas::Warning ) {
13187              for( auto const&amp; msg : assertionStats.infoMessages ) {
13188                  if( msg.type == ResultWas::Info &amp;&amp; includeResults ) {
13189                      m_xml.scopedElement( &quot;Info&quot; )
13190                              .writeText( msg.message );
13191                  } else if ( msg.type == ResultWas::Warning ) {
13192                      m_xml.scopedElement( &quot;Warning&quot; )
13193                              .writeText( msg.message );
13194                  }
13195              }
13196          }
13197          if( !includeResults &amp;&amp; result.getResultType() != ResultWas::Warning )
13198              return true;
13199          if( result.hasExpression() ) {
13200              m_xml.startElement( &quot;Expression&quot; )
13201                  .writeAttribute( &quot;success&quot;, result.succeeded() )
13202                  .writeAttribute( &quot;type&quot;, result.getTestMacroName() );
13203              writeSourceInfo( result.getSourceInfo() );
13204              m_xml.scopedElement( &quot;Original&quot; )
13205                  .writeText( result.getExpression() );
13206              m_xml.scopedElement( &quot;Expanded&quot; )
13207                  .writeText( result.getExpandedExpression() );
13208          }
13209          switch( result.getResultType() ) {
13210              case ResultWas::ThrewException:
13211                  m_xml.startElement( &quot;Exception&quot; );
13212                  writeSourceInfo( result.getSourceInfo() );
13213                  m_xml.writeText( result.getMessage() );
13214                  m_xml.endElement();
13215                  break;
13216              case ResultWas::FatalErrorCondition:
13217                  m_xml.startElement( &quot;FatalErrorCondition&quot; );
13218                  writeSourceInfo( result.getSourceInfo() );
13219                  m_xml.writeText( result.getMessage() );
13220                  m_xml.endElement();
13221                  break;
13222              case ResultWas::Info:
13223                  m_xml.scopedElement( &quot;Info&quot; )
13224                      .writeText( result.getMessage() );
13225                  break;
13226              case ResultWas::Warning:
13227                  break;
13228              case ResultWas::ExplicitFailure:
13229                  m_xml.startElement( &quot;Failure&quot; );
13230                  writeSourceInfo( result.getSourceInfo() );
13231                  m_xml.writeText( result.getMessage() );
13232                  m_xml.endElement();
13233                  break;
13234              default:
13235                  break;
13236          }
13237          if( result.hasExpression() )
13238              m_xml.endElement();
13239          return true;
13240      }
13241      void XmlReporter::sectionEnded( SectionStats const&amp; sectionStats ) {
13242          StreamingReporterBase::sectionEnded( sectionStats );
13243          if( --m_sectionDepth &gt; 0 ) {
13244              XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResults&quot; );
13245              e.writeAttribute( &quot;successes&quot;, sectionStats.assertions.passed );
13246              e.writeAttribute( &quot;failures&quot;, sectionStats.assertions.failed );
13247              e.writeAttribute( &quot;expectedFailures&quot;, sectionStats.assertions.failedButOk );
13248              if ( m_config-&gt;showDurations() == ShowDurations::Always )
13249                  e.writeAttribute( &quot;durationInSeconds&quot;, sectionStats.durationInSeconds );
13250              m_xml.endElement();
13251          }
13252      }
13253      void XmlReporter::testCaseEnded( TestCaseStats const&amp; testCaseStats ) {
13254          StreamingReporterBase::testCaseEnded( testCaseStats );
13255          XmlWriter::ScopedElement e = m_xml.scopedElement( &quot;OverallResult&quot; );
13256          e.writeAttribute( &quot;success&quot;, testCaseStats.totals.assertions.allOk() );
13257          if ( m_config-&gt;showDurations() == ShowDurations::Always )
13258              e.writeAttribute( &quot;durationInSeconds&quot;, m_testCaseTimer.getElapsedSeconds() );
13259          if( !testCaseStats.stdOut.empty() )
13260              m_xml.scopedElement( &quot;StdOut&quot; ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
13261          if( !testCaseStats.stdErr.empty() )
13262              m_xml.scopedElement( &quot;StdErr&quot; ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );
13263          m_xml.endElement();
13264      }
13265      void XmlReporter::testGroupEnded( TestGroupStats const&amp; testGroupStats ) {
13266          StreamingReporterBase::testGroupEnded( testGroupStats );
13267          m_xml.scopedElement( &quot;OverallResults&quot; )
13268              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.assertions.passed )
13269              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.assertions.failed )
13270              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.assertions.failedButOk );
13271          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13272              .writeAttribute( &quot;successes&quot;, testGroupStats.totals.testCases.passed )
13273              .writeAttribute( &quot;failures&quot;, testGroupStats.totals.testCases.failed )
13274              .writeAttribute( &quot;expectedFailures&quot;, testGroupStats.totals.testCases.failedButOk );
13275          m_xml.endElement();
13276      }
13277      void XmlReporter::testRunEnded( TestRunStats const&amp; testRunStats ) {
13278          StreamingReporterBase::testRunEnded( testRunStats );
13279          m_xml.scopedElement( &quot;OverallResults&quot; )
13280              .writeAttribute( &quot;successes&quot;, testRunStats.totals.assertions.passed )
13281              .writeAttribute( &quot;failures&quot;, testRunStats.totals.assertions.failed )
13282              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.assertions.failedButOk );
13283          m_xml.scopedElement( &quot;OverallResultsCases&quot;)
13284              .writeAttribute( &quot;successes&quot;, testRunStats.totals.testCases.passed )
13285              .writeAttribute( &quot;failures&quot;, testRunStats.totals.testCases.failed )
13286              .writeAttribute( &quot;expectedFailures&quot;, testRunStats.totals.testCases.failedButOk );
13287          m_xml.endElement();
13288      }
13289  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13290      void XmlReporter::benchmarkPreparing(std::string const&amp; name) {
13291          m_xml.startElement(&quot;BenchmarkResults&quot;)
13292              .writeAttribute(&quot;name&quot;, name);
13293      }
13294      void XmlReporter::benchmarkStarting(BenchmarkInfo const &amp;info) {
13295          m_xml.writeAttribute(&quot;samples&quot;, info.samples)
13296              .writeAttribute(&quot;resamples&quot;, info.resamples)
13297              .writeAttribute(&quot;iterations&quot;, info.iterations)
13298              .writeAttribute(&quot;clockResolution&quot;, info.clockResolution)
13299              .writeAttribute(&quot;estimatedDuration&quot;, info.estimatedDuration)
13300              .writeComment(&quot;All values in nano seconds&quot;);
13301      }
13302      void XmlReporter::benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; benchmarkStats) {
13303          m_xml.startElement(&quot;mean&quot;)
13304              .writeAttribute(&quot;value&quot;, benchmarkStats.mean.point.count())
13305              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.mean.lower_bound.count())
13306              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.mean.upper_bound.count())
13307              .writeAttribute(&quot;ci&quot;, benchmarkStats.mean.confidence_interval);
13308          m_xml.endElement();
13309          m_xml.startElement(&quot;standardDeviation&quot;)
13310              .writeAttribute(&quot;value&quot;, benchmarkStats.standardDeviation.point.count())
13311              .writeAttribute(&quot;lowerBound&quot;, benchmarkStats.standardDeviation.lower_bound.count())
13312              .writeAttribute(&quot;upperBound&quot;, benchmarkStats.standardDeviation.upper_bound.count())
13313              .writeAttribute(&quot;ci&quot;, benchmarkStats.standardDeviation.confidence_interval);
13314          m_xml.endElement();
13315          m_xml.startElement(&quot;outliers&quot;)
13316              .writeAttribute(&quot;variance&quot;, benchmarkStats.outlierVariance)
13317              .writeAttribute(&quot;lowMild&quot;, benchmarkStats.outliers.low_mild)
13318              .writeAttribute(&quot;lowSevere&quot;, benchmarkStats.outliers.low_severe)
13319              .writeAttribute(&quot;highMild&quot;, benchmarkStats.outliers.high_mild)
13320              .writeAttribute(&quot;highSevere&quot;, benchmarkStats.outliers.high_severe);
13321          m_xml.endElement();
13322          m_xml.endElement();
13323      }
13324      void XmlReporter::benchmarkFailed(std::string const &amp;error) {
13325          m_xml.scopedElement(&quot;failed&quot;).
13326              writeAttribute(&quot;message&quot;, error);
13327          m_xml.endElement();
13328      }
13329  #endif 
13330      CATCH_REGISTER_REPORTER( &quot;xml&quot;, XmlReporter )
13331  } 
13332  #if defined(_MSC_VER)
13333  #pragma warning(pop)
13334  #endif
13335  namespace Catch {
13336      LeakDetector leakDetector;
13337  }
13338  #ifdef __clang__
13339  #pragma clang diagnostic pop
13340  #endif
13341  #endif
13342  #ifdef CATCH_CONFIG_MAIN
13343  #ifndef __OBJC__
13344  #if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; defined(_UNICODE) &amp;&amp; !defined(DO_NOT_USE_WMAIN)
13345  extern &quot;C&quot; int wmain (int argc, wchar_t * argv[], wchar_t * []) {
13346  #else
13347  int main (int argc, char * argv[]) {
13348  #endif
13349      return Catch::Session().run( argc, argv );
13350  }
13351  #else 
13352  int main (int argc, char * const argv[]) {
13353  #if !CATCH_ARC_ENABLED
13354      NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
13355  #endif
13356      Catch::registerTestMethods();
13357      int result = Catch::Session().run( argc, (char**)argv );
13358  #if !CATCH_ARC_ENABLED
13359      [pool drain];
13360  #endif
13361      return result;
13362  }
13363  #endif 
13364  #endif
13365  #if !defined(CATCH_CONFIG_IMPL_ONLY)
13366  #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
13367  #  undef CLARA_CONFIG_MAIN
13368  #endif
13369  #if !defined(CATCH_CONFIG_DISABLE)
13370  #ifdef CATCH_CONFIG_PREFIX_ALL
13371  #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13372  #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13373  #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;CATCH_REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13374  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13375  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13376  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13377  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13378  #endif
13379  #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13380  #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13381  #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13382  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CATCH_CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13383  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CATCH_CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13384  #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13385  #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CATCH_CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13386  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13387  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13388  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13389  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13390  #endif 
13391  #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13392  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13393  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13394  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13395  #endif 
13396  #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( &quot;CATCH_INFO&quot;, msg )
13397  #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;CATCH_UNSCOPED_INFO&quot;, msg )
13398  #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( &quot;CATCH_WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13399  #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CATCH_CAPTURE&quot;,__VA_ARGS__ )
13400  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13401  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13402  #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13403  #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13404  #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13405  #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13406  #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13407  #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13408  #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13409  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13410  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13411  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13412  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13413  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13414  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13415  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13416  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13417  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13418  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13419  #else
13420  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13421  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13422  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13423  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13424  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13425  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13426  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13427  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13428  #endif
13429  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13430  #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
13431  #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); CATCH_SUCCEED( #__VA_ARGS__ )
13432  #else
13433  #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
13434  #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
13435  #endif
13436  #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13437  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13438  #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13439  #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13440  #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13441  #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13442  #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13443  #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13444  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13445  #define CATCH_BENCHMARK(...) \
13446      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13447  #define CATCH_BENCHMARK_ADVANCED(name) \
13448      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13449  #endif 
13450  #else
13451  #define REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__  )
13452  #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13453  #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13454  #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )
13455  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )
13456  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13457  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13458  #endif 
13459  #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13460  #define CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13461  #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13462  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13463  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13464  #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13465  #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13466  #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13467  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13468  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13469  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13470  #endif 
13471  #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13472  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13473  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13474  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )
13475  #endif 
13476  #define INFO( msg ) INTERNAL_CATCH_INFO( &quot;INFO&quot;, msg )
13477  #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;UNSCOPED_INFO&quot;, msg )
13478  #define WARN( msg ) INTERNAL_CATCH_MSG( &quot;WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13479  #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CAPTURE&quot;,__VA_ARGS__ )
13480  #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13481  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13482  #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13483  #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13484  #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13485  #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13486  #define FAIL( ... ) INTERNAL_CATCH_MSG( &quot;FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13487  #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13488  #define SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13489  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13490  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13491  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13492  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
13493  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13494  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13495  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
13496  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
13497  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
13498  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
13499  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
13500  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
13501  #else
13502  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
13503  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
13504  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13505  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13506  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
13507  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
13508  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13509  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
13510  #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
13511  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
13512  #endif
13513  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
13514  #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
13515  #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); SUCCEED( &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; )
13516  #else
13517  #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
13518  #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
13519  #endif
13520  #endif
13521  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
13522  #define SCENARIO( ... ) TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )
13523  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )
13524  #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )
13525  #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )
13526  #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )
13527  #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )
13528  #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )
13529  #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )
13530  #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
13531  #define BENCHMARK(...) \
13532      INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
13533  #define BENCHMARK_ADVANCED(name) \
13534      INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
13535  #endif 
13536  using Catch::Detail::Approx;
13537  #else 
13538  #ifdef CATCH_CONFIG_PREFIX_ALL
13539  #define CATCH_REQUIRE( ... )        (void)(0)
13540  #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
13541  #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
13542  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13543  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
13544  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13545  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13546  #endif
13547  #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
13548  #define CATCH_CHECK( ... )         (void)(0)
13549  #define CATCH_CHECK_FALSE( ... )   (void)(0)
13550  #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
13551  #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
13552  #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
13553  #define CATCH_CHECK_THROWS( ... )  (void)(0)
13554  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13555  #define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
13556  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13557  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13558  #endif 
13559  #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
13560  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13561  #define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
13562  #define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
13563  #endif 
13564  #define CATCH_INFO( msg )          (void)(0)
13565  #define CATCH_UNSCOPED_INFO( msg ) (void)(0)
13566  #define CATCH_WARN( msg )          (void)(0)
13567  #define CATCH_CAPTURE( msg )       (void)(0)
13568  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13569  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13570  #define CATCH_METHOD_AS_TEST_CASE( method, ... )
13571  #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
13572  #define CATCH_SECTION( ... )
13573  #define CATCH_DYNAMIC_SECTION( ... )
13574  #define CATCH_FAIL( ... ) (void)(0)
13575  #define CATCH_FAIL_CHECK( ... ) (void)(0)
13576  #define CATCH_SUCCEED( ... ) (void)(0)
13577  #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13578  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13579  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13580  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13581  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13582  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13583  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13584  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13585  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13586  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13587  #else
13588  #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13589  #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13590  #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13591  #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13592  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13593  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
13594  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13595  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13596  #endif
13597  #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13598  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13599  #define CATCH_GIVEN( desc )
13600  #define CATCH_AND_GIVEN( desc )
13601  #define CATCH_WHEN( desc )
13602  #define CATCH_AND_WHEN( desc )
13603  #define CATCH_THEN( desc )
13604  #define CATCH_AND_THEN( desc )
13605  #define CATCH_STATIC_REQUIRE( ... )       (void)(0)
13606  #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
13607  #else
13608  #define REQUIRE( ... )       (void)(0)
13609  #define REQUIRE_FALSE( ... ) (void)(0)
13610  #define REQUIRE_THROWS( ... ) (void)(0)
13611  #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13612  #define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
13613  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13614  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13615  #endif 
13616  #define REQUIRE_NOTHROW( ... ) (void)(0)
13617  #define CHECK( ... ) (void)(0)
13618  #define CHECK_FALSE( ... ) (void)(0)
13619  #define CHECKED_IF( ... ) if (__VA_ARGS__)
13620  #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
13621  #define CHECK_NOFAIL( ... ) (void)(0)
13622  #define CHECK_THROWS( ... )  (void)(0)
13623  #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13624  #define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
13625  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13626  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13627  #endif 
13628  #define CHECK_NOTHROW( ... ) (void)(0)
13629  #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13630  #define CHECK_THAT( arg, matcher ) (void)(0)
13631  #define REQUIRE_THAT( arg, matcher ) (void)(0)
13632  #endif 
13633  #define INFO( msg ) (void)(0)
13634  #define UNSCOPED_INFO( msg ) (void)(0)
13635  #define WARN( msg ) (void)(0)
13636  #define CAPTURE( msg ) (void)(0)
13637  #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13638  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13639  #define METHOD_AS_TEST_CASE( method, ... )
13640  #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
13641  #define SECTION( ... )
13642  #define DYNAMIC_SECTION( ... )
13643  #define FAIL( ... ) (void)(0)
13644  #define FAIL_CHECK( ... ) (void)(0)
13645  #define SUCCEED( ... ) (void)(0)
13646  #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13647  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
13648  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
13649  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
13650  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
13651  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
13652  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13653  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13654  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13655  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13656  #else
13657  #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
13658  #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
13659  #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
13660  #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
13661  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13662  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
13663  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13664  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
13665  #endif
13666  #define STATIC_REQUIRE( ... )       (void)(0)
13667  #define STATIC_REQUIRE_FALSE( ... ) (void)(0)
13668  #endif
13669  #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
13670  #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
13671  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13672  #define GIVEN( desc )
13673  #define AND_GIVEN( desc )
13674  #define WHEN( desc )
13675  #define AND_WHEN( desc )
13676  #define THEN( desc )
13677  #define AND_THEN( desc )
13678  using Catch::Detail::Approx;
13679  #endif
13680  #endif 
13681  #ifdef __clang__
13682  #    ifdef __ICC 
13683  #        pragma warning(pop)
13684  #    else
13685  #        pragma clang diagnostic pop
13686  #    endif
13687  #elif defined __GNUC__
13688  #    pragma GCC diagnostic pop
13689  #endif
13690  #endif 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    