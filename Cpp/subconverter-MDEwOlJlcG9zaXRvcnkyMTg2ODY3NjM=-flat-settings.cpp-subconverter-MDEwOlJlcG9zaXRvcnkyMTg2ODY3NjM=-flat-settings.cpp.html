
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</h3>
            <pre><code>1  #include <string>
2  #include <mutex>
3  #include <toml.hpp>
4  #include "../config/binding.h"
5  #include "../handler/webget.h"
6  #include "../script/cron.h"
7  #include "../server/webserver.h"
8  #include "../utils/logger.h"
9  #include "../utils/network.h"
10  #include "interfaces.h"
11  #include "multithread.h"
12  #include "settings.h"
13  std::mutex gMutexConfigure;
14  Settings global;
15  extern WebServer webServer;
16  const std::map<std::string, ruleset_type> RulesetTypes = {{"clash-domain:", RULESET_CLASH_DOMAIN}, {"clash-ipcidr:", RULESET_CLASH_IPCIDR}, {"clash-classic:", RULESET_CLASH_CLASSICAL}, \
17              {"quanx:", RULESET_QUANX}, {"surge:", RULESET_SURGE}};
18  int importItems(string_array &target, bool scope_limit)
19  {
20      string_array result;
21      std::stringstream ss;
22      std::string path, content, strLine;
23      unsigned int itemCount = 0;
24      for(std::string &x : target)
25      {
26          if(x.find("!!import:") == x.npos)
27          {
28              result.emplace_back(x);
29              continue;
30          }
31          path = x.substr(x.find(":") + 1);
32          writeLog(0, "Trying to import items from " + path);
33          std::string proxy = parseProxy(global.proxyConfig);
34          if(fileExist(path))
35              content = fileGet(path, scope_limit);
36          else if(isLink(path))
37              content = webGet(path, proxy, global.cacheConfig);
38          else
39              writeLog(0, "File not found or not a valid URL: " + path, LOG_LEVEL_ERROR);
40          if(!content.size())
41              return -1;
42          ss << content;
43          char delimiter = getLineBreak(content);
44          std::string::size_type lineSize;
45          while(getline(ss, strLine, delimiter))
46          {
47              lineSize = strLine.size();
48              if(lineSize && strLine[lineSize - 1] == '\r') 
49                  strLine.erase(--lineSize);
50              if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) 
51                  continue;
52              result.emplace_back(std::move(strLine));
53              itemCount++;
54          }
55          ss.clear();
56      }
<span onclick='openModal()' class='match'>57      target.swap(result);
58      writeLog(0, "Imported " + std::to_string(itemCount) + " item(s).");
59      return 0;
</span>60  }
61  toml::value parseToml(const std::string &content, const std::string &fname)
62  {
63      std::istringstream is(content);
64      return toml::parse(is, fname);
65  }
66  void importItems(std::vector<toml::value> &root, const std::string &import_key, bool scope_limit = true)
67  {
68      std::string content;
69      std::vector<toml::value> newRoot;
70      auto iter = root.begin();
71      size_t count = 0;
72      std::string proxy = parseProxy(global.proxyConfig);
73      while(iter != root.end())
74      {
75          auto& table = iter->as_table();
76          if(table.find("import") == table.end())
77              newRoot.emplace_back(std::move(*iter));
78          else
79          {
80              const std::string &path = toml::get<std::string>(table.at("import"));
81              writeLog(0, "Trying to import items from " + path);
82              if(fileExist(path))
83                  content = fileGet(path, scope_limit);
84              else if(isLink(path))
85                  content = webGet(path, proxy, global.cacheConfig);
86              else
87                  writeLog(0, "File not found or not a valid URL: " + path, LOG_LEVEL_ERROR);
88              if(content.size())
89              {
90                  auto items = parseToml(content, path);
91                  auto list = toml::find<std::vector<toml::value>>(items, import_key);
92                  count += list.size();
93                  std::move(list.begin(), list.end(), std::back_inserter(newRoot));
94              }
95          }
96          iter++;
97      }
98      root.swap(newRoot);
99      writeLog(0, "Imported " + std::to_string(count) + " item(s).");
100      return;
101  }
102  void readRegexMatch(YAML::Node node, const std::string &delimiter, string_array &dest, bool scope_limit = true)
103  {
104      YAML::Node object;
105      std::string script, url, match, rep, strLine;
106      for(unsigned i = 0; i < node.size(); i++)
107      {
108          object = node[i];
109          object["script"] >>= script;
110          if(script.size())
111          {
112              dest.emplace_back("!!script:" + script);
113              continue;
114          }
115          object["import"] >>= url;
116          if(url.size())
117          {
118              dest.emplace_back("!!import:" + url);
119              continue;
120          }
121          object["match"] >>= match;
122          object["replace"] >>= rep;
123          if(match.size() && rep.size())
124              strLine = match + delimiter + rep;
125          else
126              continue;
127          dest.emplace_back(std::move(strLine));
128      }
129      importItems(dest, scope_limit);
130  }
131  void readEmoji(YAML::Node node, string_array &dest, bool scope_limit = true)
132  {
133      YAML::Node object;
134      std::string script, url, match, rep, strLine;
135      for(unsigned i = 0; i < node.size(); i++)
136      {
137          object = node[i];
138          object["script"] >>= script;
139          if(script.size())
140          {
141              dest.emplace_back("!!script:" + script);
142              continue;
143          }
144          object["import"] >>= url;
145          if(url.size())
146          {
147              url = "!!import:" + url;
148              dest.emplace_back(url);
149              continue;
150          }
151          object["match"] >>= match;
152          object["emoji"] >>= rep;
153          if(match.size() && rep.size())
154              strLine = match + "," + rep;
155          else
156              continue;
157          dest.emplace_back(std::move(strLine));
158      }
159      importItems(dest, scope_limit);
160  }
161  void readGroup(YAML::Node node, string_array &dest, bool scope_limit = true)
162  {
163      std::string strLine, name, type;
164      string_array tempArray;
165      YAML::Node object;
166      unsigned int i, j;
167      for(i = 0; i < node.size(); i++)
168      {
169          eraseElements(tempArray);
170          object = node[i];
171          object["import"] >>= name;
172          if(name.size())
173          {
174              dest.emplace_back("!!import:" + name);
175              continue;
176          }
177          std::string url = "http:&bsol;&bsol;www.gstatic.com/generate_204", interval = "300", tolerance, timeout;
178          object["name"] >>= name;
179          object["type"] >>= type;
180          tempArray.emplace_back(name);
181          tempArray.emplace_back(type);
182          object["url"] >>= url;
183          object["interval"] >>= interval;
184          object["tolerance"] >>= tolerance;
185          object["timeout"] >>= timeout;
186          for(j = 0; j < object["rule"].size(); j++)
187              tempArray.emplace_back(safe_as<std::string>(object["rule"][j]));
188          switch(hash_(type))
189          {
190          case "select"_hash:
191              if(tempArray.size() < 3)
192                  continue;
193              break;
194          case "ssid"_hash:
195              if(tempArray.size() < 4)
196                  continue;
197              break;
198          default:
199              if(tempArray.size() < 3)
200                  continue;
201              tempArray.emplace_back(url);
202              tempArray.emplace_back(interval + "," + timeout + "," + tolerance);
203          }
204          strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -> std::string
205          {
206              return std::move(a) + "`" + std::move(b);
207          });
208          dest.emplace_back(std::move(strLine));
209      }
210      importItems(dest, scope_limit);
211  }
212  void readRuleset(YAML::Node node, string_array &dest, bool scope_limit = true)
213  {
214      std::string strLine, name, url, group, interval;
215      YAML::Node object;
216      for(unsigned int i = 0; i < node.size(); i++)
217      {
218          object = node[i];
219          object["import"] >>= name;
220          if(name.size())
221          {
222              dest.emplace_back("!!import:" + name);
223              continue;
224          }
225          object["ruleset"] >>= url;
226          object["group"] >>= group;
227          object["rule"] >>= name;
228          object["interval"] >>= interval;
229          if(url.size())
230          {
231              strLine = group + "," + url;
232              if(interval.size())
233                  strLine += "," + interval;
234          }
235          else if(name.size())
236              strLine = group + ",[]" + name;
237          else
238              continue;
239          dest.emplace_back(std::move(strLine));
240      }
241      importItems(dest, scope_limit);
242  }
243  void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array)
244  {
245      eraseElements(ruleset_content_array);
246      std::string rule_group, rule_url, rule_url_typed, interval;
247      RulesetContent rc;
248      std::string proxy = parseProxy(global.proxyRuleset);
249      for(RulesetConfig &x : ruleset_list)
250      {
251          rule_group = x.Group;
252          rule_url = x.Url;
253          std::string::size_type pos = x.Url.find("[]");
254          if(pos != std::string::npos)
255          {
256              writeLog(0, "Adding rule '" + rule_url.substr(pos + 2) + "," + rule_group + "'.", LOG_LEVEL_INFO);
257              rc = {rule_group, "", "", RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};
258          }
259          else
260          {
261              ruleset_type type = RULESET_SURGE;
262              rule_url_typed = rule_url;
263              auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });
264              if(iter != RulesetTypes.end())
265              {
266                  rule_url.erase(0, iter->first.size());
267                  type = iter->second;
268              }
269              writeLog(0, "Updating ruleset url '" + rule_url + "' with group '" + rule_group + "'.", LOG_LEVEL_INFO);
270              rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, true, global.asyncFetchRuleset), x.Interval};
271          }
272          ruleset_content_array.emplace_back(std::move(rc));
273      }
274      ruleset_content_array.shrink_to_fit();
275  }
276  void readYAMLConf(YAML::Node &node)
277  {
278      YAML::Node section = node["common"];
279      std::string strLine;
280      string_array tempArray;
281      section["api_mode"] >> global.APIMode;
282      section["api_access_token"] >> global.accessToken;
283      if(section["default_url"].IsSequence())
284      {
285          section["default_url"] >> tempArray;
286          if(tempArray.size())
287          {
288              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
289              {
290                  return std::move(a) + "|" + std::move(b);
291              });
292              global.defaultUrls = strLine;
293              eraseElements(tempArray);
294          }
295      }
296      global.enableInsert = safe_as<std::string>(section["enable_insert"]);
297      if(section["insert_url"].IsSequence())
298      {
299          section["insert_url"] >> tempArray;
300          if(tempArray.size())
301          {
302              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
303              {
304                  return std::move(a) + "|" + std::move(b);
305              });
306              global.insertUrls = strLine;
307              eraseElements(tempArray);
308          }
309      }
310      section["prepend_insert_url"] >> global.prependInsert;
311      if(section["exclude_remarks"].IsSequence())
312          section["exclude_remarks"] >> global.excludeRemarks;
313      if(section["include_remarks"].IsSequence())
314          section["include_remarks"] >> global.includeRemarks;
315      global.filterScript = safe_as<bool>(section["enable_filter"]) ? safe_as<std::string>(section["filter_script"]) : "";
316      section["base_path"] >> global.basePath;
317      section["clash_rule_base"] >> global.clashBase;
318      section["surge_rule_base"] >> global.surgeBase;
319      section["surfboard_rule_base"] >> global.surfboardBase;
320      section["mellow_rule_base"] >> global.mellowBase;
321      section["quan_rule_base"] >> global.quanBase;
322      section["quanx_rule_base"] >> global.quanXBase;
323      section["loon_rule_base"] >> global.loonBase;
324      section["sssub_rule_base"] >> global.SSSubBase;
325      section["default_external_config"] >> global.defaultExtConfig;
326      section["append_proxy_type"] >> global.appendType;
327      section["proxy_config"] >> global.proxyConfig;
328      section["proxy_ruleset"] >> global.proxyRuleset;
329      section["proxy_subscription"] >> global.proxySubscription;
330      if(node["userinfo"].IsDefined())
331      {
332          section = node["userinfo"];
333          if(section["stream_rule"].IsSequence())
334          {
335              readRegexMatch(section["stream_rule"], "|", tempArray, false);
336              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
337              safe_set_streams(configs);
338              eraseElements(tempArray);
339          }
340          if(section["time_rule"].IsSequence())
341          {
342              readRegexMatch(section["time_rule"], "|", tempArray, false);
343              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
344              safe_set_times(configs);
345              eraseElements(tempArray);
346          }
347      }
348      if(node["node_pref"].IsDefined())
349      {
350          section = node["node_pref"];
351          global.UDPFlag.set(safe_as<std::string>(section["udp_flag"]));
352          global.TFOFlag.set(safe_as<std::string>(section["tcp_fast_open_flag"]));
353          global.skipCertVerify.set(safe_as<std::string>(section["skip_cert_verify_flag"]));
354          global.TLS13Flag.set(safe_as<std::string>(section["tls13_flag"]));
355          section["sort_flag"] >> global.enableSort;
356          section["sort_script"] >> global.sortScript;
357          section["filter_deprecated_nodes"] >> global.filterDeprecated;
358          section["append_sub_userinfo"] >> global.appendUserinfo;
359          section["clash_use_new_field_name"] >> global.clashUseNewField;
360          section["clash_proxies_style"] >> global.clashProxiesStyle;
361      }
362      if(section["rename_node"].IsSequence())
363      {
364          readRegexMatch(section["rename_node"], "@", tempArray, false);
365          auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "@");
366          safe_set_renames(configs);
367          eraseElements(tempArray);
368      }
369      if(node["managed_config"].IsDefined())
370      {
371          section = node["managed_config"];
372          section["write_managed_config"] >> global.writeManagedConfig;
373          section["managed_config_prefix"] >> global.managedConfigPrefix;
374          section["config_update_interval"] >> global.updateInterval;
375          section["config_update_strict"] >> global.updateStrict;
376          section["quanx_device_id"] >> global.quanXDevID;
377      }
378      if(node["surge_external_proxy"].IsDefined())
379      {
380          node["surge_external_proxy"]["surge_ssr_path"] >> global.surgeSSRPath;
381          node["surge_external_proxy"]["resolve_hostname"] >> global.surgeResolveHostname;
382      }
383      if(node["emojis"].IsDefined())
384      {
385          section = node["emojis"];
386          section["add_emoji"] >> global.addEmoji;
387          section["remove_old_emoji"] >> global.removeEmoji;
388          if(section["rules"].IsSequence())
389          {
390              readEmoji(section["rules"], tempArray, false);
391              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ",");
392              safe_set_emojis(configs);
393              eraseElements(tempArray);
394          }
395      }
396      const char *rulesets_title = node["rulesets"].IsDefined() ? "rulesets" : "ruleset";
397      if(node[rulesets_title].IsDefined())
398      {
399          section = node[rulesets_title];
400          section["enabled"] >> global.enableRuleGen;
401          if(!global.enableRuleGen)
402          {
403              global.overwriteOriginalRules = false;
404              global.updateRulesetOnRequest = false;
405          }
406          else
407          {
408              section["overwrite_original_rules"] >> global.overwriteOriginalRules;
409              section["update_ruleset_on_request"] >> global.updateRulesetOnRequest;
410          }
411          const char *ruleset_title = section["rulesets"].IsDefined() ? "rulesets" : "surge_ruleset";
412          if(section[ruleset_title].IsSequence())
413          {
414              string_array vArray;
415              readRuleset(section[ruleset_title], vArray, false);
416              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
417          }
418      }
419      const char *groups_title = node["proxy_groups"].IsDefined() ? "proxy_groups" : "proxy_group";
420      if(node[groups_title].IsDefined() && node[groups_title]["custom_proxy_group"].IsDefined())
421      {
422          string_array vArray;
423          readGroup(node[groups_title]["custom_proxy_group"], vArray, false);
424          global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
425      }
426      if(node["template"].IsDefined())
427      {
428          node["template"]["template_path"] >> global.templatePath;
429          if(node["template"]["globals"].IsSequence())
430          {
431              eraseElements(global.templateVars);
432              for(size_t i = 0; i < node["template"]["globals"].size(); i++)
433              {
434                  std::string key, value;
435                  node["template"]["globals"][i]["key"] >> key;
436                  node["template"]["globals"][i]["value"] >> value;
437                  global.templateVars[key] = value;
438              }
439          }
440      }
441      if(node["aliases"].IsSequence())
442      {
443          webServer.reset_redirect();
444          for(size_t i = 0; i < node["aliases"].size(); i++)
445          {
446              std::string uri, target;
447              node["aliases"][i]["uri"] >> uri;
448              node["aliases"][i]["target"] >> target;
449              webServer.append_redirect(uri, target);
450          }
451      }
452      if(node["tasks"].IsSequence())
453      {
454          string_array vArray;
455          for(size_t i = 0; i < node["tasks"].size(); i++)
456          {
457              std::string name, exp, path, timeout;
458              node["tasks"][i]["import"] >> name;
459              if(name.size())
460              {
461                  vArray.emplace_back("!!import:" + name);
462                  continue;
463              }
464              node["tasks"][i]["name"] >> name;
465              node["tasks"][i]["cronexp"] >> exp;
466              node["tasks"][i]["path"] >> path;
467              node["tasks"][i]["timeout"] >> timeout;
468              strLine = name + "`" + exp + "`" + path + "`" + timeout;
469              vArray.emplace_back(std::move(strLine));
470          }
471          importItems(vArray, false);
472          global.enableCron = !vArray.empty();
473          global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
474          refresh_schedule();
475      }
476      if(node["server"].IsDefined())
477      {
478          node["server"]["listen"] >> global.listenAddress;
479          node["server"]["port"] >> global.listenPort;
480          node["server"]["serve_file_root"] >>= webServer.serve_file_root;
481          webServer.serve_file = !webServer.serve_file_root.empty();
482      }
483      if(node["advanced"].IsDefined())
484      {
485          std::string log_level;
486          node["advanced"]["log_level"] >> log_level;
487          node["advanced"]["print_debug_info"] >> global.printDbgInfo;
488          if(global.printDbgInfo)
489              global.logLevel = LOG_LEVEL_VERBOSE;
490          else
491          {
492              switch(hash_(log_level))
493              {
494              case "warn"_hash:
495                  global.logLevel = LOG_LEVEL_WARNING;
496                  break;
497              case "error"_hash:
498                  global.logLevel = LOG_LEVEL_ERROR;
499                  break;
500              case "fatal"_hash:
501                  global.logLevel = LOG_LEVEL_FATAL;
502                  break;
503              case "verbose"_hash:
504                  global.logLevel = LOG_LEVEL_VERBOSE;
505                  break;
506              case "debug"_hash:
507                  global.logLevel = LOG_LEVEL_DEBUG;
508                  break;
509              default:
510                  global.logLevel = LOG_LEVEL_INFO;
511              }
512          }
513          node["advanced"]["max_pending_connections"] >> global.maxPendingConns;
514          node["advanced"]["max_concurrent_threads"] >> global.maxConcurThreads;
515          node["advanced"]["max_allowed_rulesets"] >> global.maxAllowedRulesets;
516          node["advanced"]["max_allowed_rules"] >> global.maxAllowedRules;
517          node["advanced"]["max_allowed_download_size"] >> global.maxAllowedDownloadSize;
518          if(node["advanced"]["enable_cache"].IsDefined())
519          {
520              if(safe_as<bool>(node["advanced"]["enable_cache"]))
521              {
522                  node["advanced"]["cache_subscription"] >> global.cacheSubscription;
523                  node["advanced"]["cache_config"] >> global.cacheConfig;
524                  node["advanced"]["cache_ruleset"] >> global.cacheRuleset;
525                  node["advanced"]["serve_cache_on_fetch_fail"] >> global.serveCacheOnFetchFail;
526              }
527              else
528                  global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
529          }
530          node["advanced"]["script_clean_context"] >> global.scriptCleanContext;
531          node["advanced"]["async_fetch_ruleset"] >> global.asyncFetchRuleset;
532          node["advanced"]["skip_failed_links"] >> global.skipFailedLinks;
533      }
534      writeLog(0, "Load preference settings in YAML format completed.", LOG_LEVEL_INFO);
535  }
536  template <class T, class... U>
537  void find_if_exist(const toml::value &v, const toml::key &k, T& target, U&&... args)
538  {
539      if(v.contains(k)) target = toml::find<T>(v, k);
540      if constexpr (sizeof...(args) > 0) find_if_exist(v, std::forward<U>(args)...);
541  }
542  void operate_toml_kv_table(const std::vector<toml::table> &arr, const toml::key &key_name, const toml::key &value_name, std::function<void (const toml::value&, const toml::value&)> binary_op)
543  {
544      for(const toml::table &table : arr)
545      {
546          const auto &key = table.at(key_name), value = table.at(value_name);
547          binary_op(key, value);
548      }
549  }
550  void readTOMLConf(toml::value &root)
551  {
552      const auto &section_common = toml::find(root, "common");
553      string_array default_url, insert_url;
554      find_if_exist(section_common, "default_url", default_url, "insert_url", insert_url);
555      global.defaultUrls = join(default_url, "|");
556      global.insertUrls = join(insert_url, "|");
557      bool filter = false;
558      find_if_exist(section_common,
559                    "api_mode", global.APIMode,
560                    "api_access_token", global.accessToken,
561                    "exclude_remarks", global.excludeRemarks,
562                    "include_remarks", global.includeRemarks,
563                    "enable_insert", global.enableInsert,
564                    "prepend_insert_url", global.prependInsert,
565                    "enable_filter", filter,
566                    "default_external_config", global.defaultExtConfig,
567                    "base_path", global.basePath,
568                    "clash_rule_base", global.clashBase,
569                    "surge_rule_base", global.surgeBase,
570                    "surfboard_rule_base", global.surfboardBase,
571                    "mellow_rule_base", global.mellowBase,
572                    "quan_rule_base", global.quanBase,
573                    "quanx_rule_base", global.quanXBase,
574                    "loon_rule_base", global.loonBase,
575                    "proxy_config", global.proxyConfig,
576                    "proxy_ruleset", global.proxyRuleset,
577                    "proxy_subscription", global.proxySubscription,
578                    "append_proxy_type", global.appendType
579      );
580      if(filter)
581          find_if_exist(section_common, "filter_script", global.filterScript);
582      else
583          global.filterScript.clear();
584      safe_set_streams(toml::find_or<RegexMatchConfigs>(root, "userinfo", "stream_rule", RegexMatchConfigs{}));
585      safe_set_times(toml::find_or<RegexMatchConfigs>(root, "userinfo", "time_rule", RegexMatchConfigs{}));
586      const auto &section_node_pref = toml::find(root, "node_pref");
587      find_if_exist(section_node_pref,
588                    "udp_flag", global.UDPFlag,
589                    "tcp_fast_open_flag", global.TFOFlag,
590                    "skip_cert_verify_flag", global.skipCertVerify,
591                    "tls13_flag", global.TLS13Flag,
592                    "sort_flag", global.enableSort,
593                    "sort_script", global.sortScript,
594                    "filter_deprecated_nodes", global.filterDeprecated,
595                    "append_sub_userinfo", global.appendUserinfo,
596                    "clash_use_new_field_name", global.clashUseNewField,
597                    "clash_proxies_style", global.clashProxiesStyle
598      );
599      auto renameconfs = toml::find_or<std::vector<toml::value>>(section_node_pref, "rename_node", {});
600      importItems(renameconfs, "rename_node", false);
601      safe_set_renames(toml::get<RegexMatchConfigs>(toml::value(renameconfs)));
602      const auto &section_managed = toml::find(root, "managed_config");
603      find_if_exist(section_managed,
604                    "write_managed_config", global.writeManagedConfig,
605                    "managed_config_prefix", global.managedConfigPrefix,
606                    "config_update_interval", global.updateInterval,
607                    "config_update_strict", global.updateStrict,
608                    "quanx_device_id", global.quanXDevID
609      );
610      const auto &section_surge_external = toml::find(root, "surge_external_proxy");
611      find_if_exist(section_surge_external,
612                    "surge_ssr_path", global.surgeSSRPath,
613                    "resolve_hostname", global.surgeResolveHostname
614      );
615      const auto &section_emojis = toml::find(root, "emojis");
616      find_if_exist(section_emojis,
617                    "add_emoji", global.addEmoji,
618                    "remove_old_emoji", global.removeEmoji
619      );
620      auto emojiconfs = toml::find_or<std::vector<toml::value>>(section_emojis, "emoji", {});
621      importItems(emojiconfs, "emoji", false);
622      safe_set_emojis(toml::get<RegexMatchConfigs>(toml::value(emojiconfs)));
623      auto groups = toml::find_or<std::vector<toml::value>>(root, "custom_groups", {});
624      importItems(groups, "custom_groups", false);
625      global.customProxyGroups = toml::get<ProxyGroupConfigs>(toml::value(groups));
626      const auto &section_ruleset = toml::find(root, "ruleset");
627      find_if_exist(section_ruleset,
628                    "enabled", global.enableRuleGen,
629                    "overwrite_original_rules", global.overwriteOriginalRules,
630                    "update_ruleset_on_request", global.updateRulesetOnRequest
631      );
632      auto rulesets = toml::find_or<std::vector<toml::value>>(root, "rulesets", {});
633      importItems(rulesets, "rulesets", false);
634      global.customRulesets = toml::get<RulesetConfigs>(toml::value(rulesets));
635      const auto &section_template = toml::find(root, "template");
636      global.templatePath = toml::find_or(section_template, "template_path", "template");
637      eraseElements(global.templateVars);
638      operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section_template, "globals", {}), "key", "value", [&](const toml::value &key, const toml::value &value)
639      {
640          global.templateVars[key.as_string()] = value.as_string();
641      });
642      webServer.reset_redirect();
643      operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, "aliases", {}), "uri", "target", [&](const toml::value &key, const toml::value &value)
644      {
645          webServer.append_redirect(key.as_string(), value.as_string());
646      });
647      auto tasks = toml::find_or<std::vector<toml::value>>(root, "tasks", {});
648      importItems(tasks, "tasks", false);
649      global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));
650      const auto &section_server = toml::find(root, "server");
651      find_if_exist(section_server,
652                    "listen", global.listenAddress,
653                    "port", global.listenPort,
654                    "serve_file_root", webServer.serve_file_root
655      );
656      webServer.serve_file = !webServer.serve_file_root.empty();
657      const auto &section_advanced = toml::find(root, "advanced");
658      std::string log_level;
659      bool enable_cache = true;
660      int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;
661      find_if_exist(section_advanced,
662                    "log_level", log_level,
663                    "print_debug_info", global.printDbgInfo,
664                    "max_pending_connections", global.maxPendingConns,
665                    "max_concurrent_threads", global.maxConcurThreads,
666                    "max_allowed_rulesets", global.maxAllowedRulesets,
667                    "max_allowed_rules", global.maxAllowedRules,
668                    "max_allowed_download_size", global.maxAllowedDownloadSize,
669                    "enable_cache", enable_cache,
670                    "cache_subscription", cache_subscription,
671                    "cache_config", cache_config,
672                    "cache_ruleset", cache_ruleset,
673                    "script_clean_context", global.scriptCleanContext,
674                    "async_fetch_ruleset", global.asyncFetchRuleset,
675                    "skip_failed_links", global.skipFailedLinks
676      );
677      if(global.printDbgInfo)
678          global.logLevel = LOG_LEVEL_VERBOSE;
679      else
680      {
681          switch(hash_(log_level))
682          {
683          case "warn"_hash:
684              global.logLevel = LOG_LEVEL_WARNING;
685              break;
686          case "error"_hash:
687              global.logLevel = LOG_LEVEL_ERROR;
688              break;
689          case "fatal"_hash:
690              global.logLevel = LOG_LEVEL_FATAL;
691              break;
692          case "verbose"_hash:
693              global.logLevel = LOG_LEVEL_VERBOSE;
694              break;
695          case "debug"_hash:
696              global.logLevel = LOG_LEVEL_DEBUG;
697              break;
698          default:
699              global.logLevel = LOG_LEVEL_INFO;
700          }
701      }
702      if(enable_cache)
703      {
704          global.cacheSubscription = cache_subscription;
705          global.cacheConfig = cache_config;
706          global.cacheRuleset = cache_ruleset;
707      }
708      else
709      {
710          global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;
711      }
712      writeLog(0, "Load preference settings in TOML format completed.", LOG_LEVEL_INFO);
713  }
714  void readConf()
715  {
716      guarded_mutex guard(gMutexConfigure);
717      writeLog(0, "Loading preference settings...", LOG_LEVEL_INFO);
718      eraseElements(global.excludeRemarks);
719      eraseElements(global.includeRemarks);
720      eraseElements(global.customProxyGroups);
721      eraseElements(global.customRulesets);
722      try
723      {
724          std::string prefdata = fileGet(global.prefPath, false);
725          if(prefdata.find("common:") != prefdata.npos)
726          {
727              YAML::Node yaml = YAML::Load(prefdata);
728              if(yaml.size() && yaml["common"])
729                  return readYAMLConf(yaml);
730          }
731          toml::value conf = parseToml(prefdata, global.prefPath);
732          if(!conf.is_uninitialized() && toml::find_or<int>(conf, "version", 0))
733              return readTOMLConf(conf);
734      }
735      catch (YAML::Exception &e)
736      {
737          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
738          writeLog(0, "Unable to load preference settings as YAML.", LOG_LEVEL_DEBUG);
739      }
740      catch (toml::exception &e)
741      {
742          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
743          writeLog(0, "Unable to load preference settings as TOML.", LOG_LEVEL_DEBUG);
744      }
745      INIReader ini;
746      ini.allow_dup_section_titles = true;
747      int retVal = ini.ParseFile(global.prefPath);
748      if(retVal != INIREADER_EXCEPTION_NONE)
749      {
750          writeLog(0, "Unable to load preference settings as INI. Reason: " + ini.GetLastError(), LOG_LEVEL_FATAL);
751          return;
752      }
753      string_array tempArray;
754      ini.EnterSection("common");
755      ini.GetBoolIfExist("api_mode", global.APIMode);
756      ini.GetIfExist("api_access_token", global.accessToken);
757      ini.GetIfExist("default_url", global.defaultUrls);
758      global.enableInsert = ini.Get("enable_insert");
759      ini.GetIfExist("insert_url", global.insertUrls);
760      ini.GetBoolIfExist("prepend_insert_url", global.prependInsert);
761      if(ini.ItemPrefixExist("exclude_remarks"))
762          ini.GetAll("exclude_remarks", global.excludeRemarks);
763      if(ini.ItemPrefixExist("include_remarks"))
764          ini.GetAll("include_remarks", global.includeRemarks);
765      global.filterScript = ini.GetBool("enable_filter") ? ini.Get("filter_script"): "";
766      ini.GetIfExist("base_path", global.basePath);
767      ini.GetIfExist("clash_rule_base", global.clashBase);
768      ini.GetIfExist("surge_rule_base", global.surgeBase);
769      ini.GetIfExist("surfboard_rule_base", global.surfboardBase);
770      ini.GetIfExist("mellow_rule_base", global.mellowBase);
771      ini.GetIfExist("quan_rule_base", global.quanBase);
772      ini.GetIfExist("quanx_rule_base", global.quanXBase);
773      ini.GetIfExist("loon_rule_base", global.loonBase);
774      ini.GetIfExist("default_external_config", global.defaultExtConfig);
775      ini.GetBoolIfExist("append_proxy_type", global.appendType);
776      ini.GetIfExist("proxy_config", global.proxyConfig);
777      ini.GetIfExist("proxy_ruleset", global.proxyRuleset);
778      ini.GetIfExist("proxy_subscription", global.proxySubscription);
779      if(ini.SectionExist("surge_external_proxy"))
780      {
781          ini.EnterSection("surge_external_proxy");
782          ini.GetIfExist("surge_ssr_path", global.surgeSSRPath);
783          ini.GetBoolIfExist("resolve_hostname", global.surgeResolveHostname);
784      }
785      if(ini.SectionExist("node_pref"))
786      {
787          ini.EnterSection("node_pref");
788          global.UDPFlag.set(ini.Get("udp_flag"));
789          global.TFOFlag.set(ini.Get("tcp_fast_open_flag"));
790          global.skipCertVerify.set(ini.Get("skip_cert_verify_flag"));
791          global.TLS13Flag.set(ini.Get("tls13_flag"));
792          ini.GetBoolIfExist("sort_flag", global.enableSort);
793          global.sortScript = ini.Get("sort_script");
794          ini.GetBoolIfExist("filter_deprecated_nodes", global.filterDeprecated);
795          ini.GetBoolIfExist("append_sub_userinfo", global.appendUserinfo);
796          ini.GetBoolIfExist("clash_use_new_field_name", global.clashUseNewField);
797          ini.GetIfExist("clash_proxies_style", global.clashProxiesStyle);
798          if(ini.ItemPrefixExist("rename_node"))
799          {
800              ini.GetAll("rename_node", tempArray);
801              importItems(tempArray, false);
802              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "@");
803              safe_set_renames(configs);
804              eraseElements(tempArray);
805          }
806      }
807      if(ini.SectionExist("userinfo"))
808      {
809          ini.EnterSection("userinfo");
810          if(ini.ItemPrefixExist("stream_rule"))
811          {
812              ini.GetAll("stream_rule", tempArray);
813              importItems(tempArray, false);
814              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
815              safe_set_streams(configs);
816              eraseElements(tempArray);
817          }
818          if(ini.ItemPrefixExist("time_rule"))
819          {
820              ini.GetAll("time_rule", tempArray);
821              importItems(tempArray, false);
822              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
823              safe_set_times(configs);
824              eraseElements(tempArray);
825          }
826      }
827      ini.EnterSection("managed_config");
828      ini.GetBoolIfExist("write_managed_config", global.writeManagedConfig);
829      ini.GetIfExist("managed_config_prefix", global.managedConfigPrefix);
830      ini.GetIntIfExist("config_update_interval", global.updateInterval);
831      ini.GetBoolIfExist("config_update_strict", global.updateStrict);
832      ini.GetIfExist("quanx_device_id", global.quanXDevID);
833      ini.EnterSection("emojis");
834      ini.GetBoolIfExist("add_emoji", global.addEmoji);
835      ini.GetBoolIfExist("remove_old_emoji", global.removeEmoji);
836      if(ini.ItemPrefixExist("rule"))
837      {
838          ini.GetAll("rule", tempArray);
839          importItems(tempArray, false);
840          auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ",");
841          safe_set_emojis(configs);
842          eraseElements(tempArray);
843      }
844      if(ini.SectionExist("rulesets"))
845          ini.EnterSection("rulesets");
846      else
847          ini.EnterSection("ruleset");
848      global.enableRuleGen = ini.GetBool("enabled");
849      if(global.enableRuleGen)
850      {
851          ini.GetBoolIfExist("overwrite_original_rules", global.overwriteOriginalRules);
852          ini.GetBoolIfExist("update_ruleset_on_request", global.updateRulesetOnRequest);
853          if(ini.ItemPrefixExist("ruleset"))
854          {
855              string_array vArray;
856              ini.GetAll("ruleset", vArray);
857              importItems(vArray, false);
858              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
859          }
860          else if(ini.ItemPrefixExist("surge_ruleset"))
861          {
862              string_array vArray;
863              ini.GetAll("surge_ruleset", vArray);
864              importItems(vArray, false);
865              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
866          }
867      }
868      else
869      {
870          global.overwriteOriginalRules = false;
871          global.updateRulesetOnRequest = false;
872      }
873      if(ini.SectionExist("proxy_groups"))
874          ini.EnterSection("proxy_groups");
875      else
876          ini.EnterSection("clash_proxy_group");
877      if(ini.ItemPrefixExist("custom_proxy_group"))
878      {
879          string_array vArray;
880          ini.GetAll("custom_proxy_group", vArray);
881          importItems(vArray, false);
882          global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
883      }
884      ini.EnterSection("template");
885      ini.GetIfExist("template_path", global.templatePath);
886      string_multimap tempmap;
887      ini.GetItems(tempmap);
888      eraseElements(global.templateVars);
889      for(auto &x : tempmap)
890      {
891          if(x.first == "template_path")
892              continue;
893          global.templateVars[x.first] = x.second;
894      }
895      global.templateVars["managed_config_prefix"] = global.managedConfigPrefix;
896      if(ini.SectionExist("aliases"))
897      {
898          ini.EnterSection("aliases");
899          ini.GetItems(tempmap);
900          webServer.reset_redirect();
901          for(auto &x : tempmap)
902              webServer.append_redirect(x.first, x.second);
903      }
904      if(ini.SectionExist("tasks"))
905      {
906          string_array vArray;
907          ini.EnterSection("tasks");
908          ini.GetAll("task", vArray);
909          importItems(vArray, false);
910          global.enableCron = !vArray.empty();
911          global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
912          refresh_schedule();
913      }
914      ini.EnterSection("server");
915      ini.GetIfExist("listen", global.listenAddress);
916      ini.GetIntIfExist("port", global.listenPort);
917      webServer.serve_file_root = ini.Get("serve_file_root");
918      webServer.serve_file = !webServer.serve_file_root.empty();
919      ini.EnterSection("advanced");
920      std::string log_level;
921      ini.GetIfExist("log_level", log_level);
922      ini.GetBoolIfExist("print_debug_info", global.printDbgInfo);
923      if(global.printDbgInfo)
924          global.logLevel = LOG_LEVEL_VERBOSE;
925      else
926      {
927          switch(hash_(log_level))
928          {
929          case "warn"_hash:
930              global.logLevel = LOG_LEVEL_WARNING;
931              break;
932          case "error"_hash:
933              global.logLevel = LOG_LEVEL_ERROR;
934              break;
935          case "fatal"_hash:
936              global.logLevel = LOG_LEVEL_FATAL;
937              break;
938          case "verbose"_hash:
939              global.logLevel = LOG_LEVEL_VERBOSE;
940              break;
941          case "debug"_hash:
942              global.logLevel = LOG_LEVEL_DEBUG;
943              break;
944          default:
945              global.logLevel = LOG_LEVEL_INFO;
946          }
947      }
948      ini.GetIntIfExist("max_pending_connections", global.maxPendingConns);
949      ini.GetIntIfExist("max_concurrent_threads", global.maxConcurThreads);
950      ini.GetNumberIfExist("max_allowed_rulesets", global.maxAllowedRulesets);
951      ini.GetNumberIfExist("max_allowed_rules", global.maxAllowedRules);
952      ini.GetNumberIfExist("max_allowed_download_size", global.maxAllowedDownloadSize);
953      if(ini.ItemExist("enable_cache"))
954      {
955          if(ini.GetBool("enable_cache"))
956          {
957              ini.GetIntIfExist("cache_subscription", global.cacheSubscription);
958              ini.GetIntIfExist("cache_config", global.cacheConfig);
959              ini.GetIntIfExist("cache_ruleset", global.cacheRuleset);
960              ini.GetBoolIfExist("serve_cache_on_fetch_fail", global.serveCacheOnFetchFail);
961          }
962          else
963          {
964              global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
965              global.serveCacheOnFetchFail = false;
966          }
967      }
968      ini.GetBoolIfExist("script_clean_context", global.scriptCleanContext);
969      ini.GetBoolIfExist("async_fetch_ruleset", global.asyncFetchRuleset);
970      ini.GetBoolIfExist("skip_failed_links", global.skipFailedLinks);
971      writeLog(0, "Load preference settings in INI format completed.", LOG_LEVEL_INFO);
972  }
973  int loadExternalYAML(YAML::Node &node, ExternalConfig &ext)
974  {
975      YAML::Node section = node["custom"], object;
976      std::string name, type, url, interval;
977      std::string group, strLine;
978      section["clash_rule_base"] >> ext.clash_rule_base;
979      section["surge_rule_base"] >> ext.surge_rule_base;
980      section["surfboard_rule_base"] >> ext.surfboard_rule_base;
981      section["mellow_rule_base"] >> ext.mellow_rule_base;
982      section["quan_rule_base"] >> ext.quan_rule_base;
983      section["quanx_rule_base"] >> ext.quanx_rule_base;
984      section["loon_rule_base"] >> ext.loon_rule_base;
985      section["sssub_rule_base"] >> ext.sssub_rule_base;
986      section["enable_rule_generator"] >> ext.enable_rule_generator;
987      section["overwrite_original_rules"] >> ext.overwrite_original_rules;
988      const char *group_name = section["proxy_groups"].IsDefined() ? "proxy_groups" : "custom_proxy_group";
989      if(section[group_name].size())
990      {
991          string_array vArray;
992          readGroup(section[group_name], vArray, global.APIMode);
993          ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
994      }
995      const char *ruleset_name = section["rulesets"].IsDefined() ? "rulesets" : "surge_ruleset";
996      if(section[ruleset_name].size())
997      {
998          string_array vArray;
999          readRuleset(section[ruleset_name], vArray, global.APIMode);
1000          if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)
1001          {
1002              writeLog(0, "Ruleset count in external config has exceeded limit.", LOG_LEVEL_WARNING);
1003              return -1;
1004          }
1005          ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);
1006      }
1007      if(section["rename_node"].size())
1008      {
1009          string_array vArray;
1010          readRegexMatch(section["rename_node"], "@", vArray, global.APIMode);
1011          ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, "@");
1012      }
1013      ext.add_emoji = safe_as<std::string>(section["add_emoji"]);
1014      ext.remove_old_emoji = safe_as<std::string>(section["remove_old_emoji"]);
1015      const char *emoji_name = section["emojis"].IsDefined() ? "emojis" : "emoji";
1016      if(section[emoji_name].size())
1017      {
1018          string_array vArray;
1019          readEmoji(section[emoji_name], vArray, global.APIMode);
1020          ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, ",");
1021      }
1022      section["include_remarks"] >> ext.include;
1023      section["exclude_remarks"] >> ext.exclude;
1024      if(node["template_args"].IsSequence() && ext.tpl_args != NULL)
1025      {
1026          std::string key, value;
1027          for(size_t i = 0; i < node["template_args"].size(); i++)
1028          {
1029              node["template_args"][i]["key"] >> key;
1030              node["template_args"][i]["value"] >> value;
1031              ext.tpl_args->local_vars[key] = value;
1032          }
1033      }
1034      return 0;
1035  }
1036  int loadExternalTOML(toml::value &root, ExternalConfig &ext)
1037  {
1038      const auto &section = toml::find(root, "custom");
1039      find_if_exist(section,
1040                    "enable_rule_generator", ext.enable_rule_generator,
1041                    "overwrite_original_rules", ext.overwrite_original_rules,
1042                    "clash_rule_base", ext.clash_rule_base,
1043                    "surge_rule_base", ext.surge_rule_base,
1044                    "surfboard_rule_base", ext.surfboard_rule_base,
1045                    "mellow_rule_base", ext.mellow_rule_base,
1046                    "quan_rule_base", ext.quan_rule_base,
1047                    "quanx_rule_base", ext.quanx_rule_base,
1048                    "sssub_rule_base", ext.sssub_rule_base,
1049                    "add_emoji", ext.add_emoji,
1050                    "remove_old_emoji", ext.remove_old_emoji,
1051                    "include_remarks", ext.include,
1052                    "exclude_remarks", ext.exclude
1053      );
1054      if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section, "template_args", {}), "key", "value",
1055                                                        [&](const toml::value &key, const toml::value &value)
1056      {
1057          std::string val = toml::format(value);
1058          ext.tpl_args->local_vars[key.as_string()] = val;
1059      });
1060      auto groups = toml::find_or<std::vector<toml::value>>(root, "custom_groups", {});
1061      importItems(groups, "custom_groups", false);
1062      ext.custom_proxy_group = toml::get<ProxyGroupConfigs>(toml::value(groups));
1063      auto rulesets = toml::find_or<std::vector<toml::value>>(root, "rulesets", {});
1064      importItems(rulesets, "rulesets", false);
1065      if(global.maxAllowedRulesets && rulesets.size() > global.maxAllowedRulesets)
1066      {
1067          writeLog(0, "Ruleset count in external config has exceeded limit. ", LOG_LEVEL_WARNING);
1068          return -1;
1069      }
1070      ext.surge_ruleset = toml::get<RulesetConfigs>(toml::value(rulesets));
1071      auto emojiconfs = toml::find_or<std::vector<toml::value>>(root, "emoji", {});
1072      importItems(emojiconfs, "emoji", false);
1073      ext.emoji = toml::get<RegexMatchConfigs>(toml::value(emojiconfs));
1074      auto renameconfs = toml::find_or<std::vector<toml::value>>(root, "rename_node", {});
1075      importItems(renameconfs, "rename_node", false);
1076      ext.rename = toml::get<RegexMatchConfigs>(toml::value(renameconfs));
1077      return 0;
1078  }
1079  int loadExternalConfig(std::string &path, ExternalConfig &ext)
1080  {
1081      std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);
1082      if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)
1083          base_content = config;
1084      try
1085      {
1086          YAML::Node yaml = YAML::Load(base_content);
1087          if(yaml.size() && yaml["custom"].IsDefined())
1088              return loadExternalYAML(yaml, ext);
1089          toml::value conf = parseToml(base_content, path);
1090          if(!conf.is_uninitialized() && toml::find_or<int>(conf, "version", 0))
1091              return loadExternalTOML(conf, ext);
1092      }
1093      catch (YAML::Exception &e)
1094      {
1095      }
1096      catch (toml::exception &e)
1097      {
1098      }
1099      INIReader ini;
1100      ini.store_isolated_line = true;
1101      ini.SetIsolatedItemsSection("custom");
1102      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
1103      {
1104          writeLog(0, "Load external configuration failed. Reason: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1105          return -1;
1106      }
1107      ini.EnterSection("custom");
1108      if(ini.ItemPrefixExist("custom_proxy_group"))
1109      {
1110          string_array vArray;
1111          ini.GetAll("custom_proxy_group", vArray);
1112          importItems(vArray, global.APIMode);
1113          ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
1114      }
1115      std::string ruleset_name = ini.ItemPrefixExist("ruleset") ? "ruleset" : "surge_ruleset";
1116      if(ini.ItemPrefixExist(ruleset_name))
1117      {
1118          string_array vArray;
1119          ini.GetAll(ruleset_name, vArray);
1120          importItems(vArray, global.APIMode);
1121          if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)
1122          {
1123              writeLog(0, "Ruleset count in external config has exceeded limit. ", LOG_LEVEL_WARNING);
1124              return -1;
1125          }
1126          ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);
1127      }
1128      ini.GetIfExist("clash_rule_base", ext.clash_rule_base);
1129      ini.GetIfExist("surge_rule_base", ext.surge_rule_base);
1130      ini.GetIfExist("surfboard_rule_base", ext.surfboard_rule_base);
1131      ini.GetIfExist("mellow_rule_base", ext.mellow_rule_base);
1132      ini.GetIfExist("quan_rule_base", ext.quan_rule_base);
1133      ini.GetIfExist("quanx_rule_base", ext.quanx_rule_base);
1134      ini.GetIfExist("loon_rule_base", ext.loon_rule_base);
1135      ini.GetIfExist("sssub_rule_base", ext.sssub_rule_base);
1136      ini.GetBoolIfExist("overwrite_original_rules", ext.overwrite_original_rules);
1137      ini.GetBoolIfExist("enable_rule_generator", ext.enable_rule_generator);
1138      if(ini.ItemPrefixExist("rename"))
1139      {
1140          string_array vArray;
1141          ini.GetAll("rename", vArray);
1142          importItems(vArray, global.APIMode);
1143          ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, "@");
1144      }
1145      ext.add_emoji = ini.Get("add_emoji");
1146      ext.remove_old_emoji = ini.Get("remove_old_emoji");
1147      if(ini.ItemPrefixExist("emoji"))
1148      {
1149          string_array vArray;
1150          ini.GetAll("emoji", vArray);
1151          importItems(vArray, global.APIMode);
1152          ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, ",");
1153      }
1154      if(ini.ItemPrefixExist("include_remarks"))
1155          ini.GetAll("include_remarks", ext.include);
1156      if(ini.ItemPrefixExist("exclude_remarks"))
1157          ini.GetAll("exclude_remarks", ext.exclude);
1158      if(ini.SectionExist("template") && ext.tpl_args != nullptr)
1159      {
1160          ini.EnterSection("template");
1161          string_multimap tempmap;
1162          ini.GetItems(tempmap);
1163          for(auto &x : tempmap)
1164              ext.tpl_args->local_vars[x.first] = x.second;
1165      }
1166      return 0;
1167  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</h3>
            <pre><code>1  #include <string>
2  #include <mutex>
3  #include <toml.hpp>
4  #include "../config/binding.h"
5  #include "../handler/webget.h"
6  #include "../script/cron.h"
7  #include "../server/webserver.h"
8  #include "../utils/logger.h"
9  #include "../utils/network.h"
10  #include "interfaces.h"
11  #include "multithread.h"
12  #include "settings.h"
13  std::mutex gMutexConfigure;
14  Settings global;
15  extern WebServer webServer;
16  const std::map<std::string, ruleset_type> RulesetTypes = {{"clash-domain:", RULESET_CLASH_DOMAIN}, {"clash-ipcidr:", RULESET_CLASH_IPCIDR}, {"clash-classic:", RULESET_CLASH_CLASSICAL}, \
17              {"quanx:", RULESET_QUANX}, {"surge:", RULESET_SURGE}};
18  int importItems(string_array &target, bool scope_limit)
19  {
20      string_array result;
21      std::stringstream ss;
22      std::string path, content, strLine;
23      unsigned int itemCount = 0;
24      for(std::string &x : target)
25      {
26          if(x.find("!!import:") == x.npos)
27          {
28              result.emplace_back(x);
29              continue;
30          }
31          path = x.substr(x.find(":") + 1);
32          writeLog(0, "Trying to import items from " + path);
33          std::string proxy = parseProxy(global.proxyConfig);
34          if(fileExist(path))
35              content = fileGet(path, scope_limit);
36          else if(isLink(path))
37              content = webGet(path, proxy, global.cacheConfig);
38          else
39              writeLog(0, "File not found or not a valid URL: " + path, LOG_LEVEL_ERROR);
40          if(!content.size())
41              return -1;
42          ss << content;
43          char delimiter = getLineBreak(content);
44          std::string::size_type lineSize;
45          while(getline(ss, strLine, delimiter))
46          {
47              lineSize = strLine.size();
48              if(lineSize && strLine[lineSize - 1] == '\r') 
49                  strLine.erase(--lineSize);
50              if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) 
51                  continue;
52              result.emplace_back(std::move(strLine));
53              itemCount++;
54          }
55          ss.clear();
56      }
57      target.swap(result);
58      writeLog(0, "Imported " + std::to_string(itemCount) + " item(s).");
59      return 0;
60  }
61  toml::value parseToml(const std::string &content, const std::string &fname)
62  {
63      std::istringstream is(content);
64      return toml::parse(is, fname);
65  }
66  void importItems(std::vector<toml::value> &root, const std::string &import_key, bool scope_limit = true)
67  {
68      std::string content;
69      std::vector<toml::value> newRoot;
70      auto iter = root.begin();
71      size_t count = 0;
72      std::string proxy = parseProxy(global.proxyConfig);
73      while(iter != root.end())
74      {
75          auto& table = iter->as_table();
76          if(table.find("import") == table.end())
77              newRoot.emplace_back(std::move(*iter));
78          else
79          {
80              const std::string &path = toml::get<std::string>(table.at("import"));
81              writeLog(0, "Trying to import items from " + path);
82              if(fileExist(path))
83                  content = fileGet(path, scope_limit);
84              else if(isLink(path))
85                  content = webGet(path, proxy, global.cacheConfig);
86              else
87                  writeLog(0, "File not found or not a valid URL: " + path, LOG_LEVEL_ERROR);
88              if(content.size())
89              {
90                  auto items = parseToml(content, path);
91                  auto list = toml::find<std::vector<toml::value>>(items, import_key);
92                  count += list.size();
93                  std::move(list.begin(), list.end(), std::back_inserter(newRoot));
94              }
95          }
96          iter++;
97      }
<span onclick='openModal()' class='match'>98      root.swap(newRoot);
99      writeLog(0, "Imported " + std::to_string(count) + " item(s).");
100      return;
</span>101  }
102  void readRegexMatch(YAML::Node node, const std::string &delimiter, string_array &dest, bool scope_limit = true)
103  {
104      YAML::Node object;
105      std::string script, url, match, rep, strLine;
106      for(unsigned i = 0; i < node.size(); i++)
107      {
108          object = node[i];
109          object["script"] >>= script;
110          if(script.size())
111          {
112              dest.emplace_back("!!script:" + script);
113              continue;
114          }
115          object["import"] >>= url;
116          if(url.size())
117          {
118              dest.emplace_back("!!import:" + url);
119              continue;
120          }
121          object["match"] >>= match;
122          object["replace"] >>= rep;
123          if(match.size() && rep.size())
124              strLine = match + delimiter + rep;
125          else
126              continue;
127          dest.emplace_back(std::move(strLine));
128      }
129      importItems(dest, scope_limit);
130  }
131  void readEmoji(YAML::Node node, string_array &dest, bool scope_limit = true)
132  {
133      YAML::Node object;
134      std::string script, url, match, rep, strLine;
135      for(unsigned i = 0; i < node.size(); i++)
136      {
137          object = node[i];
138          object["script"] >>= script;
139          if(script.size())
140          {
141              dest.emplace_back("!!script:" + script);
142              continue;
143          }
144          object["import"] >>= url;
145          if(url.size())
146          {
147              url = "!!import:" + url;
148              dest.emplace_back(url);
149              continue;
150          }
151          object["match"] >>= match;
152          object["emoji"] >>= rep;
153          if(match.size() && rep.size())
154              strLine = match + "," + rep;
155          else
156              continue;
157          dest.emplace_back(std::move(strLine));
158      }
159      importItems(dest, scope_limit);
160  }
161  void readGroup(YAML::Node node, string_array &dest, bool scope_limit = true)
162  {
163      std::string strLine, name, type;
164      string_array tempArray;
165      YAML::Node object;
166      unsigned int i, j;
167      for(i = 0; i < node.size(); i++)
168      {
169          eraseElements(tempArray);
170          object = node[i];
171          object["import"] >>= name;
172          if(name.size())
173          {
174              dest.emplace_back("!!import:" + name);
175              continue;
176          }
177          std::string url = "http:&bsol;&bsol;www.gstatic.com/generate_204", interval = "300", tolerance, timeout;
178          object["name"] >>= name;
179          object["type"] >>= type;
180          tempArray.emplace_back(name);
181          tempArray.emplace_back(type);
182          object["url"] >>= url;
183          object["interval"] >>= interval;
184          object["tolerance"] >>= tolerance;
185          object["timeout"] >>= timeout;
186          for(j = 0; j < object["rule"].size(); j++)
187              tempArray.emplace_back(safe_as<std::string>(object["rule"][j]));
188          switch(hash_(type))
189          {
190          case "select"_hash:
191              if(tempArray.size() < 3)
192                  continue;
193              break;
194          case "ssid"_hash:
195              if(tempArray.size() < 4)
196                  continue;
197              break;
198          default:
199              if(tempArray.size() < 3)
200                  continue;
201              tempArray.emplace_back(url);
202              tempArray.emplace_back(interval + "," + timeout + "," + tolerance);
203          }
204          strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -> std::string
205          {
206              return std::move(a) + "`" + std::move(b);
207          });
208          dest.emplace_back(std::move(strLine));
209      }
210      importItems(dest, scope_limit);
211  }
212  void readRuleset(YAML::Node node, string_array &dest, bool scope_limit = true)
213  {
214      std::string strLine, name, url, group, interval;
215      YAML::Node object;
216      for(unsigned int i = 0; i < node.size(); i++)
217      {
218          object = node[i];
219          object["import"] >>= name;
220          if(name.size())
221          {
222              dest.emplace_back("!!import:" + name);
223              continue;
224          }
225          object["ruleset"] >>= url;
226          object["group"] >>= group;
227          object["rule"] >>= name;
228          object["interval"] >>= interval;
229          if(url.size())
230          {
231              strLine = group + "," + url;
232              if(interval.size())
233                  strLine += "," + interval;
234          }
235          else if(name.size())
236              strLine = group + ",[]" + name;
237          else
238              continue;
239          dest.emplace_back(std::move(strLine));
240      }
241      importItems(dest, scope_limit);
242  }
243  void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array)
244  {
245      eraseElements(ruleset_content_array);
246      std::string rule_group, rule_url, rule_url_typed, interval;
247      RulesetContent rc;
248      std::string proxy = parseProxy(global.proxyRuleset);
249      for(RulesetConfig &x : ruleset_list)
250      {
251          rule_group = x.Group;
252          rule_url = x.Url;
253          std::string::size_type pos = x.Url.find("[]");
254          if(pos != std::string::npos)
255          {
256              writeLog(0, "Adding rule '" + rule_url.substr(pos + 2) + "," + rule_group + "'.", LOG_LEVEL_INFO);
257              rc = {rule_group, "", "", RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};
258          }
259          else
260          {
261              ruleset_type type = RULESET_SURGE;
262              rule_url_typed = rule_url;
263              auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });
264              if(iter != RulesetTypes.end())
265              {
266                  rule_url.erase(0, iter->first.size());
267                  type = iter->second;
268              }
269              writeLog(0, "Updating ruleset url '" + rule_url + "' with group '" + rule_group + "'.", LOG_LEVEL_INFO);
270              rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, true, global.asyncFetchRuleset), x.Interval};
271          }
272          ruleset_content_array.emplace_back(std::move(rc));
273      }
274      ruleset_content_array.shrink_to_fit();
275  }
276  void readYAMLConf(YAML::Node &node)
277  {
278      YAML::Node section = node["common"];
279      std::string strLine;
280      string_array tempArray;
281      section["api_mode"] >> global.APIMode;
282      section["api_access_token"] >> global.accessToken;
283      if(section["default_url"].IsSequence())
284      {
285          section["default_url"] >> tempArray;
286          if(tempArray.size())
287          {
288              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
289              {
290                  return std::move(a) + "|" + std::move(b);
291              });
292              global.defaultUrls = strLine;
293              eraseElements(tempArray);
294          }
295      }
296      global.enableInsert = safe_as<std::string>(section["enable_insert"]);
297      if(section["insert_url"].IsSequence())
298      {
299          section["insert_url"] >> tempArray;
300          if(tempArray.size())
301          {
302              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
303              {
304                  return std::move(a) + "|" + std::move(b);
305              });
306              global.insertUrls = strLine;
307              eraseElements(tempArray);
308          }
309      }
310      section["prepend_insert_url"] >> global.prependInsert;
311      if(section["exclude_remarks"].IsSequence())
312          section["exclude_remarks"] >> global.excludeRemarks;
313      if(section["include_remarks"].IsSequence())
314          section["include_remarks"] >> global.includeRemarks;
315      global.filterScript = safe_as<bool>(section["enable_filter"]) ? safe_as<std::string>(section["filter_script"]) : "";
316      section["base_path"] >> global.basePath;
317      section["clash_rule_base"] >> global.clashBase;
318      section["surge_rule_base"] >> global.surgeBase;
319      section["surfboard_rule_base"] >> global.surfboardBase;
320      section["mellow_rule_base"] >> global.mellowBase;
321      section["quan_rule_base"] >> global.quanBase;
322      section["quanx_rule_base"] >> global.quanXBase;
323      section["loon_rule_base"] >> global.loonBase;
324      section["sssub_rule_base"] >> global.SSSubBase;
325      section["default_external_config"] >> global.defaultExtConfig;
326      section["append_proxy_type"] >> global.appendType;
327      section["proxy_config"] >> global.proxyConfig;
328      section["proxy_ruleset"] >> global.proxyRuleset;
329      section["proxy_subscription"] >> global.proxySubscription;
330      if(node["userinfo"].IsDefined())
331      {
332          section = node["userinfo"];
333          if(section["stream_rule"].IsSequence())
334          {
335              readRegexMatch(section["stream_rule"], "|", tempArray, false);
336              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
337              safe_set_streams(configs);
338              eraseElements(tempArray);
339          }
340          if(section["time_rule"].IsSequence())
341          {
342              readRegexMatch(section["time_rule"], "|", tempArray, false);
343              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
344              safe_set_times(configs);
345              eraseElements(tempArray);
346          }
347      }
348      if(node["node_pref"].IsDefined())
349      {
350          section = node["node_pref"];
351          global.UDPFlag.set(safe_as<std::string>(section["udp_flag"]));
352          global.TFOFlag.set(safe_as<std::string>(section["tcp_fast_open_flag"]));
353          global.skipCertVerify.set(safe_as<std::string>(section["skip_cert_verify_flag"]));
354          global.TLS13Flag.set(safe_as<std::string>(section["tls13_flag"]));
355          section["sort_flag"] >> global.enableSort;
356          section["sort_script"] >> global.sortScript;
357          section["filter_deprecated_nodes"] >> global.filterDeprecated;
358          section["append_sub_userinfo"] >> global.appendUserinfo;
359          section["clash_use_new_field_name"] >> global.clashUseNewField;
360          section["clash_proxies_style"] >> global.clashProxiesStyle;
361      }
362      if(section["rename_node"].IsSequence())
363      {
364          readRegexMatch(section["rename_node"], "@", tempArray, false);
365          auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "@");
366          safe_set_renames(configs);
367          eraseElements(tempArray);
368      }
369      if(node["managed_config"].IsDefined())
370      {
371          section = node["managed_config"];
372          section["write_managed_config"] >> global.writeManagedConfig;
373          section["managed_config_prefix"] >> global.managedConfigPrefix;
374          section["config_update_interval"] >> global.updateInterval;
375          section["config_update_strict"] >> global.updateStrict;
376          section["quanx_device_id"] >> global.quanXDevID;
377      }
378      if(node["surge_external_proxy"].IsDefined())
379      {
380          node["surge_external_proxy"]["surge_ssr_path"] >> global.surgeSSRPath;
381          node["surge_external_proxy"]["resolve_hostname"] >> global.surgeResolveHostname;
382      }
383      if(node["emojis"].IsDefined())
384      {
385          section = node["emojis"];
386          section["add_emoji"] >> global.addEmoji;
387          section["remove_old_emoji"] >> global.removeEmoji;
388          if(section["rules"].IsSequence())
389          {
390              readEmoji(section["rules"], tempArray, false);
391              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ",");
392              safe_set_emojis(configs);
393              eraseElements(tempArray);
394          }
395      }
396      const char *rulesets_title = node["rulesets"].IsDefined() ? "rulesets" : "ruleset";
397      if(node[rulesets_title].IsDefined())
398      {
399          section = node[rulesets_title];
400          section["enabled"] >> global.enableRuleGen;
401          if(!global.enableRuleGen)
402          {
403              global.overwriteOriginalRules = false;
404              global.updateRulesetOnRequest = false;
405          }
406          else
407          {
408              section["overwrite_original_rules"] >> global.overwriteOriginalRules;
409              section["update_ruleset_on_request"] >> global.updateRulesetOnRequest;
410          }
411          const char *ruleset_title = section["rulesets"].IsDefined() ? "rulesets" : "surge_ruleset";
412          if(section[ruleset_title].IsSequence())
413          {
414              string_array vArray;
415              readRuleset(section[ruleset_title], vArray, false);
416              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
417          }
418      }
419      const char *groups_title = node["proxy_groups"].IsDefined() ? "proxy_groups" : "proxy_group";
420      if(node[groups_title].IsDefined() && node[groups_title]["custom_proxy_group"].IsDefined())
421      {
422          string_array vArray;
423          readGroup(node[groups_title]["custom_proxy_group"], vArray, false);
424          global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
425      }
426      if(node["template"].IsDefined())
427      {
428          node["template"]["template_path"] >> global.templatePath;
429          if(node["template"]["globals"].IsSequence())
430          {
431              eraseElements(global.templateVars);
432              for(size_t i = 0; i < node["template"]["globals"].size(); i++)
433              {
434                  std::string key, value;
435                  node["template"]["globals"][i]["key"] >> key;
436                  node["template"]["globals"][i]["value"] >> value;
437                  global.templateVars[key] = value;
438              }
439          }
440      }
441      if(node["aliases"].IsSequence())
442      {
443          webServer.reset_redirect();
444          for(size_t i = 0; i < node["aliases"].size(); i++)
445          {
446              std::string uri, target;
447              node["aliases"][i]["uri"] >> uri;
448              node["aliases"][i]["target"] >> target;
449              webServer.append_redirect(uri, target);
450          }
451      }
452      if(node["tasks"].IsSequence())
453      {
454          string_array vArray;
455          for(size_t i = 0; i < node["tasks"].size(); i++)
456          {
457              std::string name, exp, path, timeout;
458              node["tasks"][i]["import"] >> name;
459              if(name.size())
460              {
461                  vArray.emplace_back("!!import:" + name);
462                  continue;
463              }
464              node["tasks"][i]["name"] >> name;
465              node["tasks"][i]["cronexp"] >> exp;
466              node["tasks"][i]["path"] >> path;
467              node["tasks"][i]["timeout"] >> timeout;
468              strLine = name + "`" + exp + "`" + path + "`" + timeout;
469              vArray.emplace_back(std::move(strLine));
470          }
471          importItems(vArray, false);
472          global.enableCron = !vArray.empty();
473          global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
474          refresh_schedule();
475      }
476      if(node["server"].IsDefined())
477      {
478          node["server"]["listen"] >> global.listenAddress;
479          node["server"]["port"] >> global.listenPort;
480          node["server"]["serve_file_root"] >>= webServer.serve_file_root;
481          webServer.serve_file = !webServer.serve_file_root.empty();
482      }
483      if(node["advanced"].IsDefined())
484      {
485          std::string log_level;
486          node["advanced"]["log_level"] >> log_level;
487          node["advanced"]["print_debug_info"] >> global.printDbgInfo;
488          if(global.printDbgInfo)
489              global.logLevel = LOG_LEVEL_VERBOSE;
490          else
491          {
492              switch(hash_(log_level))
493              {
494              case "warn"_hash:
495                  global.logLevel = LOG_LEVEL_WARNING;
496                  break;
497              case "error"_hash:
498                  global.logLevel = LOG_LEVEL_ERROR;
499                  break;
500              case "fatal"_hash:
501                  global.logLevel = LOG_LEVEL_FATAL;
502                  break;
503              case "verbose"_hash:
504                  global.logLevel = LOG_LEVEL_VERBOSE;
505                  break;
506              case "debug"_hash:
507                  global.logLevel = LOG_LEVEL_DEBUG;
508                  break;
509              default:
510                  global.logLevel = LOG_LEVEL_INFO;
511              }
512          }
513          node["advanced"]["max_pending_connections"] >> global.maxPendingConns;
514          node["advanced"]["max_concurrent_threads"] >> global.maxConcurThreads;
515          node["advanced"]["max_allowed_rulesets"] >> global.maxAllowedRulesets;
516          node["advanced"]["max_allowed_rules"] >> global.maxAllowedRules;
517          node["advanced"]["max_allowed_download_size"] >> global.maxAllowedDownloadSize;
518          if(node["advanced"]["enable_cache"].IsDefined())
519          {
520              if(safe_as<bool>(node["advanced"]["enable_cache"]))
521              {
522                  node["advanced"]["cache_subscription"] >> global.cacheSubscription;
523                  node["advanced"]["cache_config"] >> global.cacheConfig;
524                  node["advanced"]["cache_ruleset"] >> global.cacheRuleset;
525                  node["advanced"]["serve_cache_on_fetch_fail"] >> global.serveCacheOnFetchFail;
526              }
527              else
528                  global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
529          }
530          node["advanced"]["script_clean_context"] >> global.scriptCleanContext;
531          node["advanced"]["async_fetch_ruleset"] >> global.asyncFetchRuleset;
532          node["advanced"]["skip_failed_links"] >> global.skipFailedLinks;
533      }
534      writeLog(0, "Load preference settings in YAML format completed.", LOG_LEVEL_INFO);
535  }
536  template <class T, class... U>
537  void find_if_exist(const toml::value &v, const toml::key &k, T& target, U&&... args)
538  {
539      if(v.contains(k)) target = toml::find<T>(v, k);
540      if constexpr (sizeof...(args) > 0) find_if_exist(v, std::forward<U>(args)...);
541  }
542  void operate_toml_kv_table(const std::vector<toml::table> &arr, const toml::key &key_name, const toml::key &value_name, std::function<void (const toml::value&, const toml::value&)> binary_op)
543  {
544      for(const toml::table &table : arr)
545      {
546          const auto &key = table.at(key_name), value = table.at(value_name);
547          binary_op(key, value);
548      }
549  }
550  void readTOMLConf(toml::value &root)
551  {
552      const auto &section_common = toml::find(root, "common");
553      string_array default_url, insert_url;
554      find_if_exist(section_common, "default_url", default_url, "insert_url", insert_url);
555      global.defaultUrls = join(default_url, "|");
556      global.insertUrls = join(insert_url, "|");
557      bool filter = false;
558      find_if_exist(section_common,
559                    "api_mode", global.APIMode,
560                    "api_access_token", global.accessToken,
561                    "exclude_remarks", global.excludeRemarks,
562                    "include_remarks", global.includeRemarks,
563                    "enable_insert", global.enableInsert,
564                    "prepend_insert_url", global.prependInsert,
565                    "enable_filter", filter,
566                    "default_external_config", global.defaultExtConfig,
567                    "base_path", global.basePath,
568                    "clash_rule_base", global.clashBase,
569                    "surge_rule_base", global.surgeBase,
570                    "surfboard_rule_base", global.surfboardBase,
571                    "mellow_rule_base", global.mellowBase,
572                    "quan_rule_base", global.quanBase,
573                    "quanx_rule_base", global.quanXBase,
574                    "loon_rule_base", global.loonBase,
575                    "proxy_config", global.proxyConfig,
576                    "proxy_ruleset", global.proxyRuleset,
577                    "proxy_subscription", global.proxySubscription,
578                    "append_proxy_type", global.appendType
579      );
580      if(filter)
581          find_if_exist(section_common, "filter_script", global.filterScript);
582      else
583          global.filterScript.clear();
584      safe_set_streams(toml::find_or<RegexMatchConfigs>(root, "userinfo", "stream_rule", RegexMatchConfigs{}));
585      safe_set_times(toml::find_or<RegexMatchConfigs>(root, "userinfo", "time_rule", RegexMatchConfigs{}));
586      const auto &section_node_pref = toml::find(root, "node_pref");
587      find_if_exist(section_node_pref,
588                    "udp_flag", global.UDPFlag,
589                    "tcp_fast_open_flag", global.TFOFlag,
590                    "skip_cert_verify_flag", global.skipCertVerify,
591                    "tls13_flag", global.TLS13Flag,
592                    "sort_flag", global.enableSort,
593                    "sort_script", global.sortScript,
594                    "filter_deprecated_nodes", global.filterDeprecated,
595                    "append_sub_userinfo", global.appendUserinfo,
596                    "clash_use_new_field_name", global.clashUseNewField,
597                    "clash_proxies_style", global.clashProxiesStyle
598      );
599      auto renameconfs = toml::find_or<std::vector<toml::value>>(section_node_pref, "rename_node", {});
600      importItems(renameconfs, "rename_node", false);
601      safe_set_renames(toml::get<RegexMatchConfigs>(toml::value(renameconfs)));
602      const auto &section_managed = toml::find(root, "managed_config");
603      find_if_exist(section_managed,
604                    "write_managed_config", global.writeManagedConfig,
605                    "managed_config_prefix", global.managedConfigPrefix,
606                    "config_update_interval", global.updateInterval,
607                    "config_update_strict", global.updateStrict,
608                    "quanx_device_id", global.quanXDevID
609      );
610      const auto &section_surge_external = toml::find(root, "surge_external_proxy");
611      find_if_exist(section_surge_external,
612                    "surge_ssr_path", global.surgeSSRPath,
613                    "resolve_hostname", global.surgeResolveHostname
614      );
615      const auto &section_emojis = toml::find(root, "emojis");
616      find_if_exist(section_emojis,
617                    "add_emoji", global.addEmoji,
618                    "remove_old_emoji", global.removeEmoji
619      );
620      auto emojiconfs = toml::find_or<std::vector<toml::value>>(section_emojis, "emoji", {});
621      importItems(emojiconfs, "emoji", false);
622      safe_set_emojis(toml::get<RegexMatchConfigs>(toml::value(emojiconfs)));
623      auto groups = toml::find_or<std::vector<toml::value>>(root, "custom_groups", {});
624      importItems(groups, "custom_groups", false);
625      global.customProxyGroups = toml::get<ProxyGroupConfigs>(toml::value(groups));
626      const auto &section_ruleset = toml::find(root, "ruleset");
627      find_if_exist(section_ruleset,
628                    "enabled", global.enableRuleGen,
629                    "overwrite_original_rules", global.overwriteOriginalRules,
630                    "update_ruleset_on_request", global.updateRulesetOnRequest
631      );
632      auto rulesets = toml::find_or<std::vector<toml::value>>(root, "rulesets", {});
633      importItems(rulesets, "rulesets", false);
634      global.customRulesets = toml::get<RulesetConfigs>(toml::value(rulesets));
635      const auto &section_template = toml::find(root, "template");
636      global.templatePath = toml::find_or(section_template, "template_path", "template");
637      eraseElements(global.templateVars);
638      operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section_template, "globals", {}), "key", "value", [&](const toml::value &key, const toml::value &value)
639      {
640          global.templateVars[key.as_string()] = value.as_string();
641      });
642      webServer.reset_redirect();
643      operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, "aliases", {}), "uri", "target", [&](const toml::value &key, const toml::value &value)
644      {
645          webServer.append_redirect(key.as_string(), value.as_string());
646      });
647      auto tasks = toml::find_or<std::vector<toml::value>>(root, "tasks", {});
648      importItems(tasks, "tasks", false);
649      global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));
650      const auto &section_server = toml::find(root, "server");
651      find_if_exist(section_server,
652                    "listen", global.listenAddress,
653                    "port", global.listenPort,
654                    "serve_file_root", webServer.serve_file_root
655      );
656      webServer.serve_file = !webServer.serve_file_root.empty();
657      const auto &section_advanced = toml::find(root, "advanced");
658      std::string log_level;
659      bool enable_cache = true;
660      int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;
661      find_if_exist(section_advanced,
662                    "log_level", log_level,
663                    "print_debug_info", global.printDbgInfo,
664                    "max_pending_connections", global.maxPendingConns,
665                    "max_concurrent_threads", global.maxConcurThreads,
666                    "max_allowed_rulesets", global.maxAllowedRulesets,
667                    "max_allowed_rules", global.maxAllowedRules,
668                    "max_allowed_download_size", global.maxAllowedDownloadSize,
669                    "enable_cache", enable_cache,
670                    "cache_subscription", cache_subscription,
671                    "cache_config", cache_config,
672                    "cache_ruleset", cache_ruleset,
673                    "script_clean_context", global.scriptCleanContext,
674                    "async_fetch_ruleset", global.asyncFetchRuleset,
675                    "skip_failed_links", global.skipFailedLinks
676      );
677      if(global.printDbgInfo)
678          global.logLevel = LOG_LEVEL_VERBOSE;
679      else
680      {
681          switch(hash_(log_level))
682          {
683          case "warn"_hash:
684              global.logLevel = LOG_LEVEL_WARNING;
685              break;
686          case "error"_hash:
687              global.logLevel = LOG_LEVEL_ERROR;
688              break;
689          case "fatal"_hash:
690              global.logLevel = LOG_LEVEL_FATAL;
691              break;
692          case "verbose"_hash:
693              global.logLevel = LOG_LEVEL_VERBOSE;
694              break;
695          case "debug"_hash:
696              global.logLevel = LOG_LEVEL_DEBUG;
697              break;
698          default:
699              global.logLevel = LOG_LEVEL_INFO;
700          }
701      }
702      if(enable_cache)
703      {
704          global.cacheSubscription = cache_subscription;
705          global.cacheConfig = cache_config;
706          global.cacheRuleset = cache_ruleset;
707      }
708      else
709      {
710          global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;
711      }
712      writeLog(0, "Load preference settings in TOML format completed.", LOG_LEVEL_INFO);
713  }
714  void readConf()
715  {
716      guarded_mutex guard(gMutexConfigure);
717      writeLog(0, "Loading preference settings...", LOG_LEVEL_INFO);
718      eraseElements(global.excludeRemarks);
719      eraseElements(global.includeRemarks);
720      eraseElements(global.customProxyGroups);
721      eraseElements(global.customRulesets);
722      try
723      {
724          std::string prefdata = fileGet(global.prefPath, false);
725          if(prefdata.find("common:") != prefdata.npos)
726          {
727              YAML::Node yaml = YAML::Load(prefdata);
728              if(yaml.size() && yaml["common"])
729                  return readYAMLConf(yaml);
730          }
731          toml::value conf = parseToml(prefdata, global.prefPath);
732          if(!conf.is_uninitialized() && toml::find_or<int>(conf, "version", 0))
733              return readTOMLConf(conf);
734      }
735      catch (YAML::Exception &e)
736      {
737          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
738          writeLog(0, "Unable to load preference settings as YAML.", LOG_LEVEL_DEBUG);
739      }
740      catch (toml::exception &e)
741      {
742          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
743          writeLog(0, "Unable to load preference settings as TOML.", LOG_LEVEL_DEBUG);
744      }
745      INIReader ini;
746      ini.allow_dup_section_titles = true;
747      int retVal = ini.ParseFile(global.prefPath);
748      if(retVal != INIREADER_EXCEPTION_NONE)
749      {
750          writeLog(0, "Unable to load preference settings as INI. Reason: " + ini.GetLastError(), LOG_LEVEL_FATAL);
751          return;
752      }
753      string_array tempArray;
754      ini.EnterSection("common");
755      ini.GetBoolIfExist("api_mode", global.APIMode);
756      ini.GetIfExist("api_access_token", global.accessToken);
757      ini.GetIfExist("default_url", global.defaultUrls);
758      global.enableInsert = ini.Get("enable_insert");
759      ini.GetIfExist("insert_url", global.insertUrls);
760      ini.GetBoolIfExist("prepend_insert_url", global.prependInsert);
761      if(ini.ItemPrefixExist("exclude_remarks"))
762          ini.GetAll("exclude_remarks", global.excludeRemarks);
763      if(ini.ItemPrefixExist("include_remarks"))
764          ini.GetAll("include_remarks", global.includeRemarks);
765      global.filterScript = ini.GetBool("enable_filter") ? ini.Get("filter_script"): "";
766      ini.GetIfExist("base_path", global.basePath);
767      ini.GetIfExist("clash_rule_base", global.clashBase);
768      ini.GetIfExist("surge_rule_base", global.surgeBase);
769      ini.GetIfExist("surfboard_rule_base", global.surfboardBase);
770      ini.GetIfExist("mellow_rule_base", global.mellowBase);
771      ini.GetIfExist("quan_rule_base", global.quanBase);
772      ini.GetIfExist("quanx_rule_base", global.quanXBase);
773      ini.GetIfExist("loon_rule_base", global.loonBase);
774      ini.GetIfExist("default_external_config", global.defaultExtConfig);
775      ini.GetBoolIfExist("append_proxy_type", global.appendType);
776      ini.GetIfExist("proxy_config", global.proxyConfig);
777      ini.GetIfExist("proxy_ruleset", global.proxyRuleset);
778      ini.GetIfExist("proxy_subscription", global.proxySubscription);
779      if(ini.SectionExist("surge_external_proxy"))
780      {
781          ini.EnterSection("surge_external_proxy");
782          ini.GetIfExist("surge_ssr_path", global.surgeSSRPath);
783          ini.GetBoolIfExist("resolve_hostname", global.surgeResolveHostname);
784      }
785      if(ini.SectionExist("node_pref"))
786      {
787          ini.EnterSection("node_pref");
788          global.UDPFlag.set(ini.Get("udp_flag"));
789          global.TFOFlag.set(ini.Get("tcp_fast_open_flag"));
790          global.skipCertVerify.set(ini.Get("skip_cert_verify_flag"));
791          global.TLS13Flag.set(ini.Get("tls13_flag"));
792          ini.GetBoolIfExist("sort_flag", global.enableSort);
793          global.sortScript = ini.Get("sort_script");
794          ini.GetBoolIfExist("filter_deprecated_nodes", global.filterDeprecated);
795          ini.GetBoolIfExist("append_sub_userinfo", global.appendUserinfo);
796          ini.GetBoolIfExist("clash_use_new_field_name", global.clashUseNewField);
797          ini.GetIfExist("clash_proxies_style", global.clashProxiesStyle);
798          if(ini.ItemPrefixExist("rename_node"))
799          {
800              ini.GetAll("rename_node", tempArray);
801              importItems(tempArray, false);
802              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "@");
803              safe_set_renames(configs);
804              eraseElements(tempArray);
805          }
806      }
807      if(ini.SectionExist("userinfo"))
808      {
809          ini.EnterSection("userinfo");
810          if(ini.ItemPrefixExist("stream_rule"))
811          {
812              ini.GetAll("stream_rule", tempArray);
813              importItems(tempArray, false);
814              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
815              safe_set_streams(configs);
816              eraseElements(tempArray);
817          }
818          if(ini.ItemPrefixExist("time_rule"))
819          {
820              ini.GetAll("time_rule", tempArray);
821              importItems(tempArray, false);
822              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
823              safe_set_times(configs);
824              eraseElements(tempArray);
825          }
826      }
827      ini.EnterSection("managed_config");
828      ini.GetBoolIfExist("write_managed_config", global.writeManagedConfig);
829      ini.GetIfExist("managed_config_prefix", global.managedConfigPrefix);
830      ini.GetIntIfExist("config_update_interval", global.updateInterval);
831      ini.GetBoolIfExist("config_update_strict", global.updateStrict);
832      ini.GetIfExist("quanx_device_id", global.quanXDevID);
833      ini.EnterSection("emojis");
834      ini.GetBoolIfExist("add_emoji", global.addEmoji);
835      ini.GetBoolIfExist("remove_old_emoji", global.removeEmoji);
836      if(ini.ItemPrefixExist("rule"))
837      {
838          ini.GetAll("rule", tempArray);
839          importItems(tempArray, false);
840          auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ",");
841          safe_set_emojis(configs);
842          eraseElements(tempArray);
843      }
844      if(ini.SectionExist("rulesets"))
845          ini.EnterSection("rulesets");
846      else
847          ini.EnterSection("ruleset");
848      global.enableRuleGen = ini.GetBool("enabled");
849      if(global.enableRuleGen)
850      {
851          ini.GetBoolIfExist("overwrite_original_rules", global.overwriteOriginalRules);
852          ini.GetBoolIfExist("update_ruleset_on_request", global.updateRulesetOnRequest);
853          if(ini.ItemPrefixExist("ruleset"))
854          {
855              string_array vArray;
856              ini.GetAll("ruleset", vArray);
857              importItems(vArray, false);
858              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
859          }
860          else if(ini.ItemPrefixExist("surge_ruleset"))
861          {
862              string_array vArray;
863              ini.GetAll("surge_ruleset", vArray);
864              importItems(vArray, false);
865              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
866          }
867      }
868      else
869      {
870          global.overwriteOriginalRules = false;
871          global.updateRulesetOnRequest = false;
872      }
873      if(ini.SectionExist("proxy_groups"))
874          ini.EnterSection("proxy_groups");
875      else
876          ini.EnterSection("clash_proxy_group");
877      if(ini.ItemPrefixExist("custom_proxy_group"))
878      {
879          string_array vArray;
880          ini.GetAll("custom_proxy_group", vArray);
881          importItems(vArray, false);
882          global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
883      }
884      ini.EnterSection("template");
885      ini.GetIfExist("template_path", global.templatePath);
886      string_multimap tempmap;
887      ini.GetItems(tempmap);
888      eraseElements(global.templateVars);
889      for(auto &x : tempmap)
890      {
891          if(x.first == "template_path")
892              continue;
893          global.templateVars[x.first] = x.second;
894      }
895      global.templateVars["managed_config_prefix"] = global.managedConfigPrefix;
896      if(ini.SectionExist("aliases"))
897      {
898          ini.EnterSection("aliases");
899          ini.GetItems(tempmap);
900          webServer.reset_redirect();
901          for(auto &x : tempmap)
902              webServer.append_redirect(x.first, x.second);
903      }
904      if(ini.SectionExist("tasks"))
905      {
906          string_array vArray;
907          ini.EnterSection("tasks");
908          ini.GetAll("task", vArray);
909          importItems(vArray, false);
910          global.enableCron = !vArray.empty();
911          global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
912          refresh_schedule();
913      }
914      ini.EnterSection("server");
915      ini.GetIfExist("listen", global.listenAddress);
916      ini.GetIntIfExist("port", global.listenPort);
917      webServer.serve_file_root = ini.Get("serve_file_root");
918      webServer.serve_file = !webServer.serve_file_root.empty();
919      ini.EnterSection("advanced");
920      std::string log_level;
921      ini.GetIfExist("log_level", log_level);
922      ini.GetBoolIfExist("print_debug_info", global.printDbgInfo);
923      if(global.printDbgInfo)
924          global.logLevel = LOG_LEVEL_VERBOSE;
925      else
926      {
927          switch(hash_(log_level))
928          {
929          case "warn"_hash:
930              global.logLevel = LOG_LEVEL_WARNING;
931              break;
932          case "error"_hash:
933              global.logLevel = LOG_LEVEL_ERROR;
934              break;
935          case "fatal"_hash:
936              global.logLevel = LOG_LEVEL_FATAL;
937              break;
938          case "verbose"_hash:
939              global.logLevel = LOG_LEVEL_VERBOSE;
940              break;
941          case "debug"_hash:
942              global.logLevel = LOG_LEVEL_DEBUG;
943              break;
944          default:
945              global.logLevel = LOG_LEVEL_INFO;
946          }
947      }
948      ini.GetIntIfExist("max_pending_connections", global.maxPendingConns);
949      ini.GetIntIfExist("max_concurrent_threads", global.maxConcurThreads);
950      ini.GetNumberIfExist("max_allowed_rulesets", global.maxAllowedRulesets);
951      ini.GetNumberIfExist("max_allowed_rules", global.maxAllowedRules);
952      ini.GetNumberIfExist("max_allowed_download_size", global.maxAllowedDownloadSize);
953      if(ini.ItemExist("enable_cache"))
954      {
955          if(ini.GetBool("enable_cache"))
956          {
957              ini.GetIntIfExist("cache_subscription", global.cacheSubscription);
958              ini.GetIntIfExist("cache_config", global.cacheConfig);
959              ini.GetIntIfExist("cache_ruleset", global.cacheRuleset);
960              ini.GetBoolIfExist("serve_cache_on_fetch_fail", global.serveCacheOnFetchFail);
961          }
962          else
963          {
964              global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
965              global.serveCacheOnFetchFail = false;
966          }
967      }
968      ini.GetBoolIfExist("script_clean_context", global.scriptCleanContext);
969      ini.GetBoolIfExist("async_fetch_ruleset", global.asyncFetchRuleset);
970      ini.GetBoolIfExist("skip_failed_links", global.skipFailedLinks);
971      writeLog(0, "Load preference settings in INI format completed.", LOG_LEVEL_INFO);
972  }
973  int loadExternalYAML(YAML::Node &node, ExternalConfig &ext)
974  {
975      YAML::Node section = node["custom"], object;
976      std::string name, type, url, interval;
977      std::string group, strLine;
978      section["clash_rule_base"] >> ext.clash_rule_base;
979      section["surge_rule_base"] >> ext.surge_rule_base;
980      section["surfboard_rule_base"] >> ext.surfboard_rule_base;
981      section["mellow_rule_base"] >> ext.mellow_rule_base;
982      section["quan_rule_base"] >> ext.quan_rule_base;
983      section["quanx_rule_base"] >> ext.quanx_rule_base;
984      section["loon_rule_base"] >> ext.loon_rule_base;
985      section["sssub_rule_base"] >> ext.sssub_rule_base;
986      section["enable_rule_generator"] >> ext.enable_rule_generator;
987      section["overwrite_original_rules"] >> ext.overwrite_original_rules;
988      const char *group_name = section["proxy_groups"].IsDefined() ? "proxy_groups" : "custom_proxy_group";
989      if(section[group_name].size())
990      {
991          string_array vArray;
992          readGroup(section[group_name], vArray, global.APIMode);
993          ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
994      }
995      const char *ruleset_name = section["rulesets"].IsDefined() ? "rulesets" : "surge_ruleset";
996      if(section[ruleset_name].size())
997      {
998          string_array vArray;
999          readRuleset(section[ruleset_name], vArray, global.APIMode);
1000          if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)
1001          {
1002              writeLog(0, "Ruleset count in external config has exceeded limit.", LOG_LEVEL_WARNING);
1003              return -1;
1004          }
1005          ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);
1006      }
1007      if(section["rename_node"].size())
1008      {
1009          string_array vArray;
1010          readRegexMatch(section["rename_node"], "@", vArray, global.APIMode);
1011          ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, "@");
1012      }
1013      ext.add_emoji = safe_as<std::string>(section["add_emoji"]);
1014      ext.remove_old_emoji = safe_as<std::string>(section["remove_old_emoji"]);
1015      const char *emoji_name = section["emojis"].IsDefined() ? "emojis" : "emoji";
1016      if(section[emoji_name].size())
1017      {
1018          string_array vArray;
1019          readEmoji(section[emoji_name], vArray, global.APIMode);
1020          ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, ",");
1021      }
1022      section["include_remarks"] >> ext.include;
1023      section["exclude_remarks"] >> ext.exclude;
1024      if(node["template_args"].IsSequence() && ext.tpl_args != NULL)
1025      {
1026          std::string key, value;
1027          for(size_t i = 0; i < node["template_args"].size(); i++)
1028          {
1029              node["template_args"][i]["key"] >> key;
1030              node["template_args"][i]["value"] >> value;
1031              ext.tpl_args->local_vars[key] = value;
1032          }
1033      }
1034      return 0;
1035  }
1036  int loadExternalTOML(toml::value &root, ExternalConfig &ext)
1037  {
1038      const auto &section = toml::find(root, "custom");
1039      find_if_exist(section,
1040                    "enable_rule_generator", ext.enable_rule_generator,
1041                    "overwrite_original_rules", ext.overwrite_original_rules,
1042                    "clash_rule_base", ext.clash_rule_base,
1043                    "surge_rule_base", ext.surge_rule_base,
1044                    "surfboard_rule_base", ext.surfboard_rule_base,
1045                    "mellow_rule_base", ext.mellow_rule_base,
1046                    "quan_rule_base", ext.quan_rule_base,
1047                    "quanx_rule_base", ext.quanx_rule_base,
1048                    "sssub_rule_base", ext.sssub_rule_base,
1049                    "add_emoji", ext.add_emoji,
1050                    "remove_old_emoji", ext.remove_old_emoji,
1051                    "include_remarks", ext.include,
1052                    "exclude_remarks", ext.exclude
1053      );
1054      if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section, "template_args", {}), "key", "value",
1055                                                        [&](const toml::value &key, const toml::value &value)
1056      {
1057          std::string val = toml::format(value);
1058          ext.tpl_args->local_vars[key.as_string()] = val;
1059      });
1060      auto groups = toml::find_or<std::vector<toml::value>>(root, "custom_groups", {});
1061      importItems(groups, "custom_groups", false);
1062      ext.custom_proxy_group = toml::get<ProxyGroupConfigs>(toml::value(groups));
1063      auto rulesets = toml::find_or<std::vector<toml::value>>(root, "rulesets", {});
1064      importItems(rulesets, "rulesets", false);
1065      if(global.maxAllowedRulesets && rulesets.size() > global.maxAllowedRulesets)
1066      {
1067          writeLog(0, "Ruleset count in external config has exceeded limit. ", LOG_LEVEL_WARNING);
1068          return -1;
1069      }
1070      ext.surge_ruleset = toml::get<RulesetConfigs>(toml::value(rulesets));
1071      auto emojiconfs = toml::find_or<std::vector<toml::value>>(root, "emoji", {});
1072      importItems(emojiconfs, "emoji", false);
1073      ext.emoji = toml::get<RegexMatchConfigs>(toml::value(emojiconfs));
1074      auto renameconfs = toml::find_or<std::vector<toml::value>>(root, "rename_node", {});
1075      importItems(renameconfs, "rename_node", false);
1076      ext.rename = toml::get<RegexMatchConfigs>(toml::value(renameconfs));
1077      return 0;
1078  }
1079  int loadExternalConfig(std::string &path, ExternalConfig &ext)
1080  {
1081      std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);
1082      if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)
1083          base_content = config;
1084      try
1085      {
1086          YAML::Node yaml = YAML::Load(base_content);
1087          if(yaml.size() && yaml["custom"].IsDefined())
1088              return loadExternalYAML(yaml, ext);
1089          toml::value conf = parseToml(base_content, path);
1090          if(!conf.is_uninitialized() && toml::find_or<int>(conf, "version", 0))
1091              return loadExternalTOML(conf, ext);
1092      }
1093      catch (YAML::Exception &e)
1094      {
1095      }
1096      catch (toml::exception &e)
1097      {
1098      }
1099      INIReader ini;
1100      ini.store_isolated_line = true;
1101      ini.SetIsolatedItemsSection("custom");
1102      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
1103      {
1104          writeLog(0, "Load external configuration failed. Reason: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1105          return -1;
1106      }
1107      ini.EnterSection("custom");
1108      if(ini.ItemPrefixExist("custom_proxy_group"))
1109      {
1110          string_array vArray;
1111          ini.GetAll("custom_proxy_group", vArray);
1112          importItems(vArray, global.APIMode);
1113          ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
1114      }
1115      std::string ruleset_name = ini.ItemPrefixExist("ruleset") ? "ruleset" : "surge_ruleset";
1116      if(ini.ItemPrefixExist(ruleset_name))
1117      {
1118          string_array vArray;
1119          ini.GetAll(ruleset_name, vArray);
1120          importItems(vArray, global.APIMode);
1121          if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)
1122          {
1123              writeLog(0, "Ruleset count in external config has exceeded limit. ", LOG_LEVEL_WARNING);
1124              return -1;
1125          }
1126          ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);
1127      }
1128      ini.GetIfExist("clash_rule_base", ext.clash_rule_base);
1129      ini.GetIfExist("surge_rule_base", ext.surge_rule_base);
1130      ini.GetIfExist("surfboard_rule_base", ext.surfboard_rule_base);
1131      ini.GetIfExist("mellow_rule_base", ext.mellow_rule_base);
1132      ini.GetIfExist("quan_rule_base", ext.quan_rule_base);
1133      ini.GetIfExist("quanx_rule_base", ext.quanx_rule_base);
1134      ini.GetIfExist("loon_rule_base", ext.loon_rule_base);
1135      ini.GetIfExist("sssub_rule_base", ext.sssub_rule_base);
1136      ini.GetBoolIfExist("overwrite_original_rules", ext.overwrite_original_rules);
1137      ini.GetBoolIfExist("enable_rule_generator", ext.enable_rule_generator);
1138      if(ini.ItemPrefixExist("rename"))
1139      {
1140          string_array vArray;
1141          ini.GetAll("rename", vArray);
1142          importItems(vArray, global.APIMode);
1143          ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, "@");
1144      }
1145      ext.add_emoji = ini.Get("add_emoji");
1146      ext.remove_old_emoji = ini.Get("remove_old_emoji");
1147      if(ini.ItemPrefixExist("emoji"))
1148      {
1149          string_array vArray;
1150          ini.GetAll("emoji", vArray);
1151          importItems(vArray, global.APIMode);
1152          ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, ",");
1153      }
1154      if(ini.ItemPrefixExist("include_remarks"))
1155          ini.GetAll("include_remarks", ext.include);
1156      if(ini.ItemPrefixExist("exclude_remarks"))
1157          ini.GetAll("exclude_remarks", ext.exclude);
1158      if(ini.SectionExist("template") && ext.tpl_args != nullptr)
1159      {
1160          ini.EnterSection("template");
1161          string_multimap tempmap;
1162          ini.GetItems(tempmap);
1163          for(auto &x : tempmap)
1164              ext.tpl_args->local_vars[x.first] = x.second;
1165      }
1166      return 0;
1167  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</div>
                </div>
                <div class="column column_space"><pre><code>57      target.swap(result);
58      writeLog(0, "Imported " + std::to_string(itemCount) + " item(s).");
59      return 0;
</pre></code></div>
                <div class="column column_space"><pre><code>98      root.swap(newRoot);
99      writeLog(0, "Imported " + std::to_string(count) + " item(s).");
100      return;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    