
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 359, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Sorters.h</h3>
            <pre><code>1  #pragma once
2  #include <algorithm>
3  #include <utility>
4  #include <random>
5  class ISorter
6  {
7  private:
8  	bool _isDescending = true;
9  	size_t _fromColumn = 0;
10  	size_t _toColumn = 0;
11  protected:
12  	bool isDescending() const {
13  		return _isDescending;
14  	};
15  	generic_string getSortKey(const generic_string& input) {
16  		if (isSortingSpecificColumns())
17  		{
18  			if (input.length() < _fromColumn)
19  			{
20  				return TEXT("");
21  			}
22  			else if (_fromColumn == _toColumn)
23  			{
24  				return input.substr(_fromColumn);
25  			}
26  			else
27  			{
28  				return input.substr(_fromColumn, _toColumn - _fromColumn);
29  			}
30  		}
31  		else
32  		{
33  			return input;
34  		}
35  	};
36  	bool isSortingSpecificColumns() {
37  		return _toColumn != 0;
38  	};
39  public:
40  	ISorter(bool isDescending, size_t fromColumn, size_t toColumn) : _isDescending(isDescending), _fromColumn(fromColumn), _toColumn(toColumn) {
41  		assert(_fromColumn <= _toColumn);
42  	};
43  	virtual ~ISorter() { };
44  	virtual std::vector<generic_string> sort(std::vector<generic_string> lines) = 0;
45  };
46  class LexicographicSorter : public ISorter
47  {
48  public:
49  	LexicographicSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
50  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
51  		if (isSortingSpecificColumns())
52  		{
53  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
54  			{
55  				if (isDescending())
56  				{
57  					return getSortKey(a).compare(getSortKey(b)) > 0;
58  				}
59  				else
60  				{
61  					return getSortKey(a).compare(getSortKey(b)) < 0;
62  				}
63  			});
64  		}
65  		else
66  		{
67  			std::sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
68  			{
69  				if (isDescending())
70  				{
71  					return a.compare(b) > 0;
72  				}
73  				else
74  				{
75  					return a.compare(b) < 0;
76  				}
77  			});
78  		}
79  		return lines;
80  	};
81  };
82  class LexicographicCaseInsensitiveSorter : public ISorter
83  {
84  public:
85  	LexicographicCaseInsensitiveSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
86  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
87  		if (isSortingSpecificColumns())
88  		{
89  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
90  				{
91  					if (isDescending())
92  					{
93  						return OrdinalIgnoreCaseCompareStrings(getSortKey(a).c_str(), getSortKey(b).c_str()) > 0;
94  					}
95  					else
96  					{
97  						return OrdinalIgnoreCaseCompareStrings(getSortKey(a).c_str(), getSortKey(b).c_str()) < 0;
98  					}
99  				});
100  		}
101  		else
102  		{
103  			std::sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
104  				{
105  					if (isDescending())
106  					{
107  						return OrdinalIgnoreCaseCompareStrings(a.c_str(), b.c_str()) > 0;
108  					}
109  					else
110  					{
111  						return OrdinalIgnoreCaseCompareStrings(a.c_str(), b.c_str()) < 0;
112  					}
113  				});
114  		}
115  		return lines;
116  	};
117  };
118  class IntegerSorter : public ISorter
119  {
120  public:
121  	IntegerSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
122  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
123  		if (isSortingSpecificColumns())
124  		{
125  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string aIn, generic_string bIn)
126  			{
127  				generic_string a = getSortKey(aIn);
128  				generic_string b = getSortKey(bIn);
129  				long long compareResult = 0;
130  				size_t aNumIndex = 0;
131  				size_t bNumIndex = 0;
132  				while (compareResult == 0)
133  				{
134  					if (aNumIndex >= a.length() || bNumIndex >= b.length())
135  					{
136  						compareResult = a.compare(std::min<size_t>(aNumIndex, a.length()), generic_string::npos, b, std::min<size_t>(bNumIndex, b.length()), generic_string::npos);
137  						break;
138  					}
139  					bool aChunkIsNum = a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9';
140  					bool bChunkIsNum = b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9';
141  					int aNumSign = 1;
142  					if (!aChunkIsNum && (aNumIndex + 1) < a.length())
143  					{
144  						aChunkIsNum = (a[aNumIndex] == L'-' && (a[aNumIndex + 1] >= L'0' && a[aNumIndex + 1] <= L'9'));
145  						aNumSign = -1;
146  					}
147  					int bNumSign = 1;
148  					if (!bChunkIsNum && (bNumIndex + 1) < b.length())
149  					{
150  						bChunkIsNum = (b[bNumIndex] == L'-' && (b[bNumIndex + 1] >= L'0' && b[bNumIndex + 1] <= L'9'));
151  						bNumSign = -1;
152  					}
153  					if (aChunkIsNum != bChunkIsNum)
154  					{
155  						compareResult = a[aNumIndex] - b[bNumIndex];
156  						aNumIndex++;
157  						bNumIndex++;
158  					}
159  					else if (aChunkIsNum)
160  					{
161  						if (aNumSign != bNumSign)
162  						{
163  							if (aNumSign == 1)
164  							{
165  								compareResult = 1;
166  							}
167  							else
168  							{
169  								compareResult = -1;
170  							}
171  						}
172  						else
173  						{
174  							if (aNumSign == -1)
175  							{
176  								aNumIndex++;
177  								bNumIndex++;
178  							}
179  							size_t aNumEnd = a.find_first_not_of(L"1234567890", aNumIndex);
180  							if (aNumEnd == generic_string::npos)
181  							{
<span onclick='openModal()' class='match'>182  								aNumEnd = a.length();
183  							}
184  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
185  							if (bNumEnd == generic_string::npos)
186  							{
187  								bNumEnd = b.length();
188  							}
189  							int aZeroNum = 0;
190  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
191  							{
192  								aZeroNum++;
193  								aNumIndex++;
194  							}
195  							int bZeroNum = 0;
196  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
197  							{
198  								bZeroNum++;
199  								bNumIndex++;
200  							}
201  							size_t aNumLength = aNumEnd - aNumIndex;
202  							size_t bNumLength = bNumEnd - bNumIndex;
203  							if (aNumLength > bNumLength)
204  							{
205  								compareResult = 1 * aNumSign;
206  							}
207  							else if (aNumLength < bNumLength)
208  							{
209  								compareResult = -1 * aNumSign;
210  							}
211  							else
212  							{
213  								while (compareResult == 0
214  									&& aNumIndex < a.length()
215  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
216  									&& bNumIndex < b.length()
217  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
218  								{
219  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
220  									aNumIndex++;
221  									bNumIndex++;
222  								}
223  								if (compareResult == 0)
224  								{
225  									compareResult = bZeroNum - aZeroNum;
226  								}
227  							}
228  						}
229  					}
230  					else
231  					{
232  						if (a[aNumIndex] == L'-')
233  						{
234  							aNumIndex++;
235  						}
236  						if (b[bNumIndex] == L'-')
237  						{
238  							bNumIndex++;
239  						}
240  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
241  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
242  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
243  						aNumIndex = aChunkEnd;
244  						bNumIndex = bChunkEnd;
245  					}
246  				}
247  				if (isDescending())
248  				{
249  					return compareResult > 0;
250  				}
251  				else
252  				{
253  					return compareResult < 0;
254  				}
255  			});
256  		}
257  		else
</span>258  		{
259  			std::sort(lines.begin(), lines.end(), [this](generic_string aIn, generic_string bIn)
260  			{
261  				generic_string a = aIn;
262  				generic_string b = bIn;
263  				long long compareResult = 0;
264  				size_t aNumIndex = 0;
265  				size_t bNumIndex = 0;
266  				while (compareResult == 0)
267  				{
268  					if (aNumIndex >= a.length() || bNumIndex >= b.length())
269  					{
270  						compareResult = a.compare(std::min<size_t>(aNumIndex, a.length()), generic_string::npos, b, std::min<size_t>(bNumIndex, b.length()), generic_string::npos);
271  						break;
272  					}
273  					bool aChunkIsNum = a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9';
274  					bool bChunkIsNum = b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9';
275  					int aNumSign = 1;
276  					if (!aChunkIsNum && (aNumIndex + 1) < a.length())
277  					{
278  						aChunkIsNum = (a[aNumIndex] == L'-' && (a[aNumIndex + 1] >= L'0' && a[aNumIndex + 1] <= L'9'));
279  						aNumSign = -1;
280  					}
281  					int bNumSign = 1;
282  					if (!bChunkIsNum && (bNumIndex + 1) < b.length())
283  					{
284  						bChunkIsNum = (b[bNumIndex] == L'-' && (b[bNumIndex + 1] >= L'0' && b[bNumIndex + 1] <= L'9'));
285  						bNumSign = -1;
286  					}
287  					if (aChunkIsNum != bChunkIsNum)
288  					{
289  						compareResult = a[aNumIndex] - b[bNumIndex];
290  						aNumIndex++;
291  						bNumIndex++;
292  					}
293  					else if (aChunkIsNum)
294  					{
295  						if (aNumSign != bNumSign)
296  						{
297  							if (aNumSign == 1)
298  							{
299  								compareResult = 1;
300  							}
301  							else
302  							{
303  								compareResult = -1;
304  							}
305  						}
306  						else
307  						{
308  							if (aNumSign == -1)
309  							{
310  								aNumIndex++;
311  								bNumIndex++;
312  							}
313  							size_t aNumEnd = a.find_first_not_of(L"1234567890", aNumIndex);
314  							if (aNumEnd == generic_string::npos)
315  							{
316  								aNumEnd = a.length();
317  							}
318  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
319  							if (bNumEnd == generic_string::npos)
320  							{
321  								bNumEnd = b.length();
322  							}
323  							int aZeroNum = 0;
324  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
325  							{
326  								aZeroNum++;
327  								aNumIndex++;
328  							}
329  							int bZeroNum = 0;
330  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
331  							{
332  								bZeroNum++;
333  								bNumIndex++;
334  							}
335  							size_t aNumLength = aNumEnd - aNumIndex;
336  							size_t bNumLength = bNumEnd - bNumIndex;
337  							if (aNumLength > bNumLength)
338  							{
339  								compareResult = 1 * aNumSign;
340  							}
341  							else if (aNumLength < bNumLength)
342  							{
343  								compareResult = -1 * aNumSign;
344  							}
345  							else
346  							{
347  								while (compareResult == 0
348  									&& aNumIndex < a.length()
349  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
350  									&& bNumIndex < b.length()
351  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
352  								{
353  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
354  									aNumIndex++;
355  									bNumIndex++;
356  								}
357  								if (compareResult == 0)
358  								{
359  									compareResult = bZeroNum - aZeroNum;
360  								}
361  							}
362  						}
363  					}
364  					else
365  					{
366  						if (a[aNumIndex] == L'-')
367  						{
368  							aNumIndex++;
369  						}
370  						if (b[bNumIndex] == L'-')
371  						{
372  							bNumIndex++;
373  						}
374  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
375  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
376  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
377  						aNumIndex = aChunkEnd;
378  						bNumIndex = bChunkEnd;
379  					}
380  				}
381  				if (isDescending())
382  				{
383  					return compareResult > 0;
384  				}
385  				else
386  				{
387  					return compareResult < 0;
388  				}
389  			});
390  		}
391  		return lines;
392  	};
393  };
394  template<typename T_Num>
395  class NumericSorter : public ISorter
396  {
397  public:
398  	NumericSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn)
399  	{
400  #ifdef __MINGW32__
401  		_usLocale = NULL;
402  #else
403  		_usLocale = ::_create_locale(LC_NUMERIC, "en-US");
404  #endif
405  	};
406  	~NumericSorter()
407  	{
408  #ifndef __MINGW32__
409  		::_free_locale(_usLocale);
410  #endif
411  	}
412  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
413  		std::vector<std::pair<size_t, T_Num>> nonEmptyInputAsNumbers;
414  		std::vector<generic_string> empties;
415  		nonEmptyInputAsNumbers.reserve(lines.size());
416  		for (size_t lineIndex = 0; lineIndex < lines.size(); ++lineIndex)
417  		{
418  			const generic_string originalLine = lines[lineIndex];
419  			const generic_string preparedLine = prepareStringForConversion(originalLine);
420  			if (considerStringEmpty(preparedLine))
421  			{
422  				empties.push_back(originalLine);
423  			}
424  			else
425  			{
426  				try
427  				{
428  					nonEmptyInputAsNumbers.push_back(std::make_pair(lineIndex, convertStringToNumber(preparedLine)));
429  				}
430  				catch (...)
431  				{
432  					throw lineIndex;
433  				}
434  			}
435  		}
436  		assert(nonEmptyInputAsNumbers.size() + empties.size() == lines.size());
437  		const bool descending = isDescending();
438  		std::stable_sort(nonEmptyInputAsNumbers.begin(), nonEmptyInputAsNumbers.end(), [descending](std::pair<size_t, T_Num> a, std::pair<size_t, T_Num> b)
439  			{
440  				if (descending)
441  				{
442  					return a.second > b.second;
443  				}
444  				else
445  				{
446  					return a.second < b.second;
447  				}
448  			});
449  		std::vector<generic_string> output;
450  		output.reserve(lines.size());
451  		if (!isDescending())
452  		{
453  			output.insert(output.end(), empties.begin(), empties.end());
454  		}
455  		for (auto it = nonEmptyInputAsNumbers.begin(); it != nonEmptyInputAsNumbers.end(); ++it)
456  		{
457  			output.push_back(lines[it->first]);
458  		}
459  		if (isDescending())
460  		{
461  			output.insert(output.end(), empties.begin(), empties.end());
462  		}
463  		assert(output.size() == lines.size());
464  		return output;
465  	};
466  protected:
467  	bool considerStringEmpty(const generic_string& input) {
468  		return input.find_first_not_of(TEXT(" \t\r\n")) == std::string::npos;
469  	}
470  	virtual generic_string prepareStringForConversion(const generic_string& input) = 0;
471  	virtual T_Num convertStringToNumber(const generic_string& input) = 0;
472  	_locale_t _usLocale;
473  };
474  class DecimalCommaSorter : public NumericSorter<double>
475  {
476  public:
477  	DecimalCommaSorter(bool isDescending, size_t fromColumn, size_t toColumn) : NumericSorter<double>(isDescending, fromColumn, toColumn) { };
478  protected:
479  	generic_string prepareStringForConversion(const generic_string& input) override {
480  		generic_string admissablePart = stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789,-"));
481  		return stringReplace(admissablePart, TEXT(","), TEXT("."));
482  	};
483  	double convertStringToNumber(const generic_string& input) override {
484  		return stodLocale(input, _usLocale);
485  	};
486  };
487  class DecimalDotSorter : public NumericSorter<double>
488  {
489  public:
490  	DecimalDotSorter(bool isDescending, size_t fromColumn, size_t toColumn) : NumericSorter<double>(isDescending, fromColumn, toColumn) { };
491  protected:
492  	generic_string prepareStringForConversion(const generic_string& input) override {
493  		return stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789.-"));
494  	};
495  	double convertStringToNumber(const generic_string& input) override {
496  		return stodLocale(input, _usLocale);
497  	};
498  };
499  class ReverseSorter : public ISorter
500  {
501  public:
502  	ReverseSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
503  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
504  		std::reverse(lines.begin(), lines.end());
505  		return lines;
506  	};
507  };
508  class RandomSorter : public ISorter
509  {
510  public:
511  	unsigned seed;
512  	RandomSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) {
513  		seed = static_cast<unsigned>(time(NULL));
514  	};
515  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
516  		std::shuffle(lines.begin(), lines.end(), std::default_random_engine(seed));
517  		return lines;
518  	};
519  };
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Sorters.h</h3>
            <pre><code>1  #pragma once
2  #include <algorithm>
3  #include <utility>
4  #include <random>
5  class ISorter
6  {
7  private:
8  	bool _isDescending = true;
9  	size_t _fromColumn = 0;
10  	size_t _toColumn = 0;
11  protected:
12  	bool isDescending() const {
13  		return _isDescending;
14  	};
15  	generic_string getSortKey(const generic_string& input) {
16  		if (isSortingSpecificColumns())
17  		{
18  			if (input.length() < _fromColumn)
19  			{
20  				return TEXT("");
21  			}
22  			else if (_fromColumn == _toColumn)
23  			{
24  				return input.substr(_fromColumn);
25  			}
26  			else
27  			{
28  				return input.substr(_fromColumn, _toColumn - _fromColumn);
29  			}
30  		}
31  		else
32  		{
33  			return input;
34  		}
35  	};
36  	bool isSortingSpecificColumns() {
37  		return _toColumn != 0;
38  	};
39  public:
40  	ISorter(bool isDescending, size_t fromColumn, size_t toColumn) : _isDescending(isDescending), _fromColumn(fromColumn), _toColumn(toColumn) {
41  		assert(_fromColumn <= _toColumn);
42  	};
43  	virtual ~ISorter() { };
44  	virtual std::vector<generic_string> sort(std::vector<generic_string> lines) = 0;
45  };
46  class LexicographicSorter : public ISorter
47  {
48  public:
49  	LexicographicSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
50  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
51  		if (isSortingSpecificColumns())
52  		{
53  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
54  			{
55  				if (isDescending())
56  				{
57  					return getSortKey(a).compare(getSortKey(b)) > 0;
58  				}
59  				else
60  				{
61  					return getSortKey(a).compare(getSortKey(b)) < 0;
62  				}
63  			});
64  		}
65  		else
66  		{
67  			std::sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
68  			{
69  				if (isDescending())
70  				{
71  					return a.compare(b) > 0;
72  				}
73  				else
74  				{
75  					return a.compare(b) < 0;
76  				}
77  			});
78  		}
79  		return lines;
80  	};
81  };
82  class LexicographicCaseInsensitiveSorter : public ISorter
83  {
84  public:
85  	LexicographicCaseInsensitiveSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
86  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
87  		if (isSortingSpecificColumns())
88  		{
89  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
90  				{
91  					if (isDescending())
92  					{
93  						return OrdinalIgnoreCaseCompareStrings(getSortKey(a).c_str(), getSortKey(b).c_str()) > 0;
94  					}
95  					else
96  					{
97  						return OrdinalIgnoreCaseCompareStrings(getSortKey(a).c_str(), getSortKey(b).c_str()) < 0;
98  					}
99  				});
100  		}
101  		else
102  		{
103  			std::sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
104  				{
105  					if (isDescending())
106  					{
107  						return OrdinalIgnoreCaseCompareStrings(a.c_str(), b.c_str()) > 0;
108  					}
109  					else
110  					{
111  						return OrdinalIgnoreCaseCompareStrings(a.c_str(), b.c_str()) < 0;
112  					}
113  				});
114  		}
115  		return lines;
116  	};
117  };
118  class IntegerSorter : public ISorter
119  {
120  public:
121  	IntegerSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
122  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
123  		if (isSortingSpecificColumns())
124  		{
125  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string aIn, generic_string bIn)
126  			{
127  				generic_string a = getSortKey(aIn);
128  				generic_string b = getSortKey(bIn);
129  				long long compareResult = 0;
130  				size_t aNumIndex = 0;
131  				size_t bNumIndex = 0;
132  				while (compareResult == 0)
133  				{
134  					if (aNumIndex >= a.length() || bNumIndex >= b.length())
135  					{
136  						compareResult = a.compare(std::min<size_t>(aNumIndex, a.length()), generic_string::npos, b, std::min<size_t>(bNumIndex, b.length()), generic_string::npos);
137  						break;
138  					}
139  					bool aChunkIsNum = a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9';
140  					bool bChunkIsNum = b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9';
141  					int aNumSign = 1;
142  					if (!aChunkIsNum && (aNumIndex + 1) < a.length())
143  					{
144  						aChunkIsNum = (a[aNumIndex] == L'-' && (a[aNumIndex + 1] >= L'0' && a[aNumIndex + 1] <= L'9'));
145  						aNumSign = -1;
146  					}
147  					int bNumSign = 1;
148  					if (!bChunkIsNum && (bNumIndex + 1) < b.length())
149  					{
150  						bChunkIsNum = (b[bNumIndex] == L'-' && (b[bNumIndex + 1] >= L'0' && b[bNumIndex + 1] <= L'9'));
151  						bNumSign = -1;
152  					}
153  					if (aChunkIsNum != bChunkIsNum)
154  					{
155  						compareResult = a[aNumIndex] - b[bNumIndex];
156  						aNumIndex++;
157  						bNumIndex++;
158  					}
159  					else if (aChunkIsNum)
160  					{
161  						if (aNumSign != bNumSign)
162  						{
163  							if (aNumSign == 1)
164  							{
165  								compareResult = 1;
166  							}
167  							else
168  							{
169  								compareResult = -1;
170  							}
171  						}
172  						else
173  						{
174  							if (aNumSign == -1)
175  							{
176  								aNumIndex++;
177  								bNumIndex++;
178  							}
179  							size_t aNumEnd = a.find_first_not_of(L"1234567890", aNumIndex);
180  							if (aNumEnd == generic_string::npos)
181  							{
<span onclick='openModal()' class='match'>182  								aNumEnd = a.length();
183  							}
184  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
185  							if (bNumEnd == generic_string::npos)
186  							{
187  								bNumEnd = b.length();
188  							}
189  							int aZeroNum = 0;
190  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
191  							{
192  								aZeroNum++;
193  								aNumIndex++;
194  							}
195  							int bZeroNum = 0;
196  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
197  							{
198  								bZeroNum++;
199  								bNumIndex++;
200  							}
201  							size_t aNumLength = aNumEnd - aNumIndex;
202  							size_t bNumLength = bNumEnd - bNumIndex;
203  							if (aNumLength > bNumLength)
204  							{
205  								compareResult = 1 * aNumSign;
206  							}
207  							else if (aNumLength < bNumLength)
208  							{
209  								compareResult = -1 * aNumSign;
210  							}
211  							else
212  							{
213  								while (compareResult == 0
214  									&& aNumIndex < a.length()
215  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
216  									&& bNumIndex < b.length()
217  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
218  								{
219  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
220  									aNumIndex++;
221  									bNumIndex++;
222  								}
223  								if (compareResult == 0)
224  								{
225  									compareResult = bZeroNum - aZeroNum;
226  								}
227  							}
228  						}
229  					}
230  					else
231  					{
232  						if (a[aNumIndex] == L'-')
233  						{
234  							aNumIndex++;
235  						}
236  						if (b[bNumIndex] == L'-')
237  						{
238  							bNumIndex++;
239  						}
240  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
241  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
242  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
243  						aNumIndex = aChunkEnd;
244  						bNumIndex = bChunkEnd;
245  					}
246  				}
247  				if (isDescending())
248  				{
249  					return compareResult > 0;
250  				}
251  				else
252  				{
253  					return compareResult < 0;
254  				}
255  			});
256  		}
257  		else
</span>258  		{
259  			std::sort(lines.begin(), lines.end(), [this](generic_string aIn, generic_string bIn)
260  			{
261  				generic_string a = aIn;
262  				generic_string b = bIn;
263  				long long compareResult = 0;
264  				size_t aNumIndex = 0;
265  				size_t bNumIndex = 0;
266  				while (compareResult == 0)
267  				{
268  					if (aNumIndex >= a.length() || bNumIndex >= b.length())
269  					{
270  						compareResult = a.compare(std::min<size_t>(aNumIndex, a.length()), generic_string::npos, b, std::min<size_t>(bNumIndex, b.length()), generic_string::npos);
271  						break;
272  					}
273  					bool aChunkIsNum = a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9';
274  					bool bChunkIsNum = b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9';
275  					int aNumSign = 1;
276  					if (!aChunkIsNum && (aNumIndex + 1) < a.length())
277  					{
278  						aChunkIsNum = (a[aNumIndex] == L'-' && (a[aNumIndex + 1] >= L'0' && a[aNumIndex + 1] <= L'9'));
279  						aNumSign = -1;
280  					}
281  					int bNumSign = 1;
282  					if (!bChunkIsNum && (bNumIndex + 1) < b.length())
283  					{
284  						bChunkIsNum = (b[bNumIndex] == L'-' && (b[bNumIndex + 1] >= L'0' && b[bNumIndex + 1] <= L'9'));
285  						bNumSign = -1;
286  					}
287  					if (aChunkIsNum != bChunkIsNum)
288  					{
289  						compareResult = a[aNumIndex] - b[bNumIndex];
290  						aNumIndex++;
291  						bNumIndex++;
292  					}
293  					else if (aChunkIsNum)
294  					{
295  						if (aNumSign != bNumSign)
296  						{
297  							if (aNumSign == 1)
298  							{
299  								compareResult = 1;
300  							}
301  							else
302  							{
303  								compareResult = -1;
304  							}
305  						}
306  						else
307  						{
308  							if (aNumSign == -1)
309  							{
310  								aNumIndex++;
311  								bNumIndex++;
312  							}
313  							size_t aNumEnd = a.find_first_not_of(L"1234567890", aNumIndex);
314  							if (aNumEnd == generic_string::npos)
315  							{
316  								aNumEnd = a.length();
317  							}
318  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
319  							if (bNumEnd == generic_string::npos)
320  							{
321  								bNumEnd = b.length();
322  							}
323  							int aZeroNum = 0;
324  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
325  							{
326  								aZeroNum++;
327  								aNumIndex++;
328  							}
329  							int bZeroNum = 0;
330  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
331  							{
332  								bZeroNum++;
333  								bNumIndex++;
334  							}
335  							size_t aNumLength = aNumEnd - aNumIndex;
336  							size_t bNumLength = bNumEnd - bNumIndex;
337  							if (aNumLength > bNumLength)
338  							{
339  								compareResult = 1 * aNumSign;
340  							}
341  							else if (aNumLength < bNumLength)
342  							{
343  								compareResult = -1 * aNumSign;
344  							}
345  							else
346  							{
347  								while (compareResult == 0
348  									&& aNumIndex < a.length()
349  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
350  									&& bNumIndex < b.length()
351  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
352  								{
353  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
354  									aNumIndex++;
355  									bNumIndex++;
356  								}
357  								if (compareResult == 0)
358  								{
359  									compareResult = bZeroNum - aZeroNum;
360  								}
361  							}
362  						}
363  					}
364  					else
365  					{
366  						if (a[aNumIndex] == L'-')
367  						{
368  							aNumIndex++;
369  						}
370  						if (b[bNumIndex] == L'-')
371  						{
372  							bNumIndex++;
373  						}
374  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
375  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
376  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
377  						aNumIndex = aChunkEnd;
378  						bNumIndex = bChunkEnd;
379  					}
380  				}
381  				if (isDescending())
382  				{
383  					return compareResult > 0;
384  				}
385  				else
386  				{
387  					return compareResult < 0;
388  				}
389  			});
390  		}
391  		return lines;
392  	};
393  };
394  template<typename T_Num>
395  class NumericSorter : public ISorter
396  {
397  public:
398  	NumericSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn)
399  	{
400  #ifdef __MINGW32__
401  		_usLocale = NULL;
402  #else
403  		_usLocale = ::_create_locale(LC_NUMERIC, "en-US");
404  #endif
405  	};
406  	~NumericSorter()
407  	{
408  #ifndef __MINGW32__
409  		::_free_locale(_usLocale);
410  #endif
411  	}
412  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
413  		std::vector<std::pair<size_t, T_Num>> nonEmptyInputAsNumbers;
414  		std::vector<generic_string> empties;
415  		nonEmptyInputAsNumbers.reserve(lines.size());
416  		for (size_t lineIndex = 0; lineIndex < lines.size(); ++lineIndex)
417  		{
418  			const generic_string originalLine = lines[lineIndex];
419  			const generic_string preparedLine = prepareStringForConversion(originalLine);
420  			if (considerStringEmpty(preparedLine))
421  			{
422  				empties.push_back(originalLine);
423  			}
424  			else
425  			{
426  				try
427  				{
428  					nonEmptyInputAsNumbers.push_back(std::make_pair(lineIndex, convertStringToNumber(preparedLine)));
429  				}
430  				catch (...)
431  				{
432  					throw lineIndex;
433  				}
434  			}
435  		}
436  		assert(nonEmptyInputAsNumbers.size() + empties.size() == lines.size());
437  		const bool descending = isDescending();
438  		std::stable_sort(nonEmptyInputAsNumbers.begin(), nonEmptyInputAsNumbers.end(), [descending](std::pair<size_t, T_Num> a, std::pair<size_t, T_Num> b)
439  			{
440  				if (descending)
441  				{
442  					return a.second > b.second;
443  				}
444  				else
445  				{
446  					return a.second < b.second;
447  				}
448  			});
449  		std::vector<generic_string> output;
450  		output.reserve(lines.size());
451  		if (!isDescending())
452  		{
453  			output.insert(output.end(), empties.begin(), empties.end());
454  		}
455  		for (auto it = nonEmptyInputAsNumbers.begin(); it != nonEmptyInputAsNumbers.end(); ++it)
456  		{
457  			output.push_back(lines[it->first]);
458  		}
459  		if (isDescending())
460  		{
461  			output.insert(output.end(), empties.begin(), empties.end());
462  		}
463  		assert(output.size() == lines.size());
464  		return output;
465  	};
466  protected:
467  	bool considerStringEmpty(const generic_string& input) {
468  		return input.find_first_not_of(TEXT(" \t\r\n")) == std::string::npos;
469  	}
470  	virtual generic_string prepareStringForConversion(const generic_string& input) = 0;
471  	virtual T_Num convertStringToNumber(const generic_string& input) = 0;
472  	_locale_t _usLocale;
473  };
474  class DecimalCommaSorter : public NumericSorter<double>
475  {
476  public:
477  	DecimalCommaSorter(bool isDescending, size_t fromColumn, size_t toColumn) : NumericSorter<double>(isDescending, fromColumn, toColumn) { };
478  protected:
479  	generic_string prepareStringForConversion(const generic_string& input) override {
480  		generic_string admissablePart = stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789,-"));
481  		return stringReplace(admissablePart, TEXT(","), TEXT("."));
482  	};
483  	double convertStringToNumber(const generic_string& input) override {
484  		return stodLocale(input, _usLocale);
485  	};
486  };
487  class DecimalDotSorter : public NumericSorter<double>
488  {
489  public:
490  	DecimalDotSorter(bool isDescending, size_t fromColumn, size_t toColumn) : NumericSorter<double>(isDescending, fromColumn, toColumn) { };
491  protected:
492  	generic_string prepareStringForConversion(const generic_string& input) override {
493  		return stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789.-"));
494  	};
495  	double convertStringToNumber(const generic_string& input) override {
496  		return stodLocale(input, _usLocale);
497  	};
498  };
499  class ReverseSorter : public ISorter
500  {
501  public:
502  	ReverseSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
503  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
504  		std::reverse(lines.begin(), lines.end());
505  		return lines;
506  	};
507  };
508  class RandomSorter : public ISorter
509  {
510  public:
511  	unsigned seed;
512  	RandomSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) {
513  		seed = static_cast<unsigned>(time(NULL));
514  	};
515  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
516  		std::shuffle(lines.begin(), lines.end(), std::default_random_engine(seed));
517  		return lines;
518  	};
519  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Sorters.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Sorters.h</div>
                </div>
                <div class="column column_space"><pre><code>182  								aNumEnd = a.length();
183  							}
184  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
185  							if (bNumEnd == generic_string::npos)
186  							{
187  								bNumEnd = b.length();
188  							}
189  							int aZeroNum = 0;
190  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
191  							{
192  								aZeroNum++;
193  								aNumIndex++;
194  							}
195  							int bZeroNum = 0;
196  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
197  							{
198  								bZeroNum++;
199  								bNumIndex++;
200  							}
201  							size_t aNumLength = aNumEnd - aNumIndex;
202  							size_t bNumLength = bNumEnd - bNumIndex;
203  							if (aNumLength > bNumLength)
204  							{
205  								compareResult = 1 * aNumSign;
206  							}
207  							else if (aNumLength < bNumLength)
208  							{
209  								compareResult = -1 * aNumSign;
210  							}
211  							else
212  							{
213  								while (compareResult == 0
214  									&& aNumIndex < a.length()
215  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
216  									&& bNumIndex < b.length()
217  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
218  								{
219  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
220  									aNumIndex++;
221  									bNumIndex++;
222  								}
223  								if (compareResult == 0)
224  								{
225  									compareResult = bZeroNum - aZeroNum;
226  								}
227  							}
228  						}
229  					}
230  					else
231  					{
232  						if (a[aNumIndex] == L'-')
233  						{
234  							aNumIndex++;
235  						}
236  						if (b[bNumIndex] == L'-')
237  						{
238  							bNumIndex++;
239  						}
240  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
241  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
242  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
243  						aNumIndex = aChunkEnd;
244  						bNumIndex = bChunkEnd;
245  					}
246  				}
247  				if (isDescending())
248  				{
249  					return compareResult > 0;
250  				}
251  				else
252  				{
253  					return compareResult < 0;
254  				}
255  			});
256  		}
257  		else
</pre></code></div>
                <div class="column column_space"><pre><code>182  								aNumEnd = a.length();
183  							}
184  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
185  							if (bNumEnd == generic_string::npos)
186  							{
187  								bNumEnd = b.length();
188  							}
189  							int aZeroNum = 0;
190  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
191  							{
192  								aZeroNum++;
193  								aNumIndex++;
194  							}
195  							int bZeroNum = 0;
196  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
197  							{
198  								bZeroNum++;
199  								bNumIndex++;
200  							}
201  							size_t aNumLength = aNumEnd - aNumIndex;
202  							size_t bNumLength = bNumEnd - bNumIndex;
203  							if (aNumLength > bNumLength)
204  							{
205  								compareResult = 1 * aNumSign;
206  							}
207  							else if (aNumLength < bNumLength)
208  							{
209  								compareResult = -1 * aNumSign;
210  							}
211  							else
212  							{
213  								while (compareResult == 0
214  									&& aNumIndex < a.length()
215  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
216  									&& bNumIndex < b.length()
217  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
218  								{
219  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
220  									aNumIndex++;
221  									bNumIndex++;
222  								}
223  								if (compareResult == 0)
224  								{
225  									compareResult = bZeroNum - aZeroNum;
226  								}
227  							}
228  						}
229  					}
230  					else
231  					{
232  						if (a[aNumIndex] == L'-')
233  						{
234  							aNumIndex++;
235  						}
236  						if (b[bNumIndex] == L'-')
237  						{
238  							bNumIndex++;
239  						}
240  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
241  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
242  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
243  						aNumIndex = aChunkEnd;
244  						bNumIndex = bChunkEnd;
245  					}
246  				}
247  				if (isDescending())
248  				{
249  					return compareResult > 0;
250  				}
251  				else
252  				{
253  					return compareResult < 0;
254  				}
255  			});
256  		}
257  		else
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    