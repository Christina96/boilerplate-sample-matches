
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.160475482912332%, Tokens: 14</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sappsrv.h</h3>
            <pre><code>1  ClassTP(TSAppSrvRqEnv, PSAppSrvRqEnv)
2  private:
3  	PWebSrv WebSrv;
4  	int SockId;
5  	PHttpRq HttpRq;
6  public:
7  	TSAppSrvRqEnv(const PWebSrv& _WebSrv, int _SockId, const PHttpRq& _HttpRq):
8  		WebSrv(_WebSrv), SockId(_SockId), HttpRq(_HttpRq) { }
9  	static PSAppSrvRqEnv New(const PWebSrv& WebSrv, int SockId, const PHttpRq& HttpRq) { 
10  		return new TSAppSrvRqEnv(WebSrv, SockId, HttpRq); }
<span onclick='openModal()' class='match'>11  	const PWebSrv& GetWebSrv() const { return WebSrv; }
12  	int GetSockId() const { return SockId; }
13  	const PHttpRq& GetHttpRq() const { return HttpRq; }
</span>14  };
15  typedef enum { saotXml, saotJSon, saotCustom } TSAppOutType;
16  ClassTPV(TSAppSrvFun, PSAppSrvFun, TSAppSrvFunV)
17  public:
18  	static bool IsFldNm(const TStrKdV& FldNmValPrV, const TStr& FldNm);
19  	static TStr GetFldVal(const TStrKdV& FldNmValPrV, const TStr& FldNm, const TStr& DefFldVal = "");
20  	static void GetFldValV(const TStrKdV& FldNmValPrV, const TStr& FldNm, TStrV& FldValV);
21  	static bool IsFldNmVal(const TStrKdV& FldNmValPrV,	const TStr& FldNm, const TStr& FldVal);
22  private:
23  	TSAppOutType OutType;
24  protected:
25  	PXmlDoc GetErrorRes(const TStr& ErrorStr);
26  public:
27  	TSAppSrvFun(const TSAppOutType& _OutType = saotXml): OutType(_OutType) { }
28  	virtual ~TSAppSrvFun() { }
29  	TSAppOutType GetFunOutType() const { return OutType; }
30      virtual TStr GetFunNm() const = 0;
31  	virtual PXmlDoc Exec(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv) { 
32  		EAssert(OutType != saotXml); return TXmlDoc::New(); }
33  	virtual TStr ExecJSon(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv) {
34  		EAssert(OutType != saotJSon); return ""; };
35  	virtual PSIn ExecCustom(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv,
36  		TStr& ContTypeStr) { EAssert(OutType != saotCustom); return NULL; };
37  };
38  ClassTE(TSAppSrv, TWebSrv)
39  private:
40  	TStr XmlHdStr;
41      THash<TStr, PSAppSrvFun> FunNmToFunH;
42  public:
43      TSAppSrv(const int& PortN, const TSAppSrvFunV& SrvFunV, const PNotify& Notify);
44      static PWebSrv New(const int& PortN, const TSAppSrvFunV& SrvFunV, 
45          const PNotify& Notify) { return new TSAppSrv(PortN, SrvFunV, Notify); }
46      virtual void OnHttpRq(const int& SockId, const PHttpRq& HttpRq);
47  };
48  ClassTE(TSASFunHelloWorld, TSAppSrvFun)
49  public:
50  	TSASFunHelloWorld() { }
51      static PSAppSrvFun New() { return new TSASFunHelloWorld(); }
52      TStr GetFunNm() const { return "hello"; }
53      PXmlDoc Exec(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv) {
54          PXmlTok TopTok = TXmlTok::New("logs");
55          TopTok->AddSubTok(TXmlTok::New("HelloWorld"));
56          for (int FldN = 0; FldN < FldNmValPrV.Len(); FldN++) {
57              PXmlTok ArgTok = TXmlTok::New("arg");
58              ArgTok->AddArg(FldNmValPrV[FldN].Key, FldNmValPrV[FldN].Dat);
59              TopTok->AddSubTok(ArgTok);
60          }
61          return TXmlDoc::New(TopTok);
62      }
63  };
64  ClassTE(TSASFunExit, TSAppSrvFun)
65  public:
66  	TSASFunExit() { }
67      static PSAppSrvFun New() { return new TSASFunExit(); }
68      TStr GetFunNm() const { return "exit"; }
69      PXmlDoc Exec(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv) {
70          TSysMsg::Quit();
71          PXmlTok TopTok = TXmlTok::New("exit");
72          return TXmlDoc::New(TopTok);
73      }
74  };
75  ClassTE(TSASFunFile, TSAppSrvFun)
76  private:
77  	TStr Url;
78  	TStr FNm;
79  	TStr ContType;
80  public:
81  	TSASFunFile(const TStr& _Url, const TStr& _FNm, const TStr& _ContType): 
82  	  TSAppSrvFun(saotCustom), Url(_Url), FNm(_FNm), ContType(_ContType) { }
83  	static PSAppSrvFun New(const TStr& Url, const TStr& FNm, const TStr& ContType) {
84  		return new TSASFunFile(Url, FNm, ContType); }
85      TStr GetFunNm() const { return Url; }
86      PSIn ExecCustom(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv, TStr& ContTypeStr) {
87  		ContTypeStr = ContType;
88          return TFIn::New(FNm);
89      }
90  	static void LoadFunFileV(const TStr& FPath, TSAppSrvFunV& SrvFunV);
91  };
92  ClassTE(TSASFunImg, TSAppSrvFun)
93  private:	
94  	TStr ContType;	
95  public:
96  	TSASFunImg(const TStr& _ContType): TSAppSrvFun(saotCustom), ContType(_ContType) { }
97  	static PSAppSrvFun New(const TStr& ContType) {
98  		return new TSASFunImg(ContType); }
99      TStr GetFunNm() const { return "seq-jpg"; }
100      PSIn ExecCustom(const TStrKdV& FldNmValPrV, const PSAppSrvRqEnv RqEnv, TStr& ContTypeStr) {
101  		ContTypeStr = ContType;
102  		TStr FNm = GetFldVal(FldNmValPrV, "file");		
103          return TFIn::New(FNm);
104      }
105  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-conjgrad.h</h3>
            <pre><code>1  #ifndef conj_grad_h
2  #define conj_grad_h
3  template <class TFunction>
4  class TConjGrad {
5  private:
6    TFunction Func;  
7    TFltV Point;     
8    TInt NIters;     
9    TFlt MinFVal;    
10    UndefDefaultCopyAssign(TConjGrad);
11  public:
12    TConjGrad(const TFltV& StartPoint) : Point(StartPoint), NIters(0), MinFVal(TFlt::Mx) { }
13    TConjGrad(const TFltV& StartPoint, const TFunction& Function) : Point(StartPoint), Func(Function) { }
14    void SetStart(const TFltV& StartPoint) { Point=StartPoint; NIters=0; MinFVal=TFlt::Mx; }
15    double At(const int& PointN) const { return Point[PointN]; }
<span onclick='openModal()' class='match'>16    double GetMinVal() const { return MinFVal; }
17    int GetIters() const { return NIters; }
18    const TFltV& GetMinPoint() const { return Point; }
</span>19    TFunction& GetFunc() { return Func; }
20    const TFunction& GetFunc() const { return Func; }
21    void SetFunc(const TFunction& Function) { Func=Function; }
22    void ConjGradMin(const double& Tolerance = 1e-6);
23    void dlinmin(TFltV& p, TFltV& xi);
24    void mnbrak(double& ax, double& bx, double& cx, double& fa, double& fb, double& fc, const TFltV& pcom, const TFltV& xicom);
25    double dbrent(double ax, double bx, double cx, double tol, double& xmin, const TFltV& pcom, const TFltV& xicom);
26    double f1dim(double x, const TFltV& pcom, const TFltV& xicom);
27    double df1dim(double x, const TFltV& pcom, const TFltV& xicom);
28    static void Shift(double& a, double& b, double& c, const double& d) { a=b; b=c; c=d; }
29    static double Sign(const double a, const double b) { return b >= 0.0 ? fabs(a) : -fabs(a); }
30    static void Mov3(double& a,double& b,double& c, const double& d,const double& e,const double& f) { a=d; b=e; c=f; }
31    static void Dump(const TFltV& ValV) { for (int i = 0; i < ValV.Len(); i++) { printf("  %d:%g", i, ValV[i]); } printf("\n"); }
32  };
33  template <class TFunction>
34  void TConjGrad<TFunction>::ConjGradMin(const double& Tolerance) {
35    const double EPS = 1e-10;
36    const double ITMAX = 200;
37    const int N = Point.Len();
38    double gg, gam, fp, dgg;
39    TFltV g(N), h(N), xi(N);
40    fp = Func.FVal(Point);
41    Func.FDeriv(Point, xi);
42    for (int j = 0; j < N; j++) {
43      g[j] = -xi[j];
44      xi[j]=h[j]=g[j];
45    }
46    for (int NIters=1; NIters <= ITMAX; NIters++) {
47      Func.Dump();
48      dlinmin(Point, xi);
49      if (fabs(MinFVal-fp) <= Tolerance) { 
50        return;
51      }
52      fp = Func.FVal(Point);
53      Func.FDeriv(Point, xi);
54      dgg=gg=0.0;
55      for (int j = 0; j < N; j++) {
56        gg += g[j]*g[j];
57        dgg += (xi[j]+g[j])*xi[j];
58      }
59      if (gg == 0.0) { return; }
60      gam = dgg / gg;
61      for (int j = 0; j < N; j++) {
62        g[j] = -xi[j];
63        xi[j]=h[j]=g[j]+gam*h[j];
64      }
65    }
66    FailR("Too many iterations in TConjGrad::ConjGradMin");
67  }
68  template <class TFunction>
69  void TConjGrad<TFunction>::dlinmin(TFltV& p, TFltV& xi) {
70    const double TOL = 2.0e-4;
71    double xx=1.0, xmin, fx, fb, fa, bx, ax=0.0;
72    mnbrak(ax, xx, bx, fa, fx, fb, p, xi);
73    MinFVal = dbrent(ax, xx, bx, TOL, xmin, p, xi);
74    if (MinFVal == 0.0) {
75      return;
76    } else {
77      for (int j = 0; j < xi.Len(); j++) {
78        xi[j] *= xmin;
79        p[j] += xi[j];
80      }
81    }
82  }
83  template <class TFunction>
84  void TConjGrad<TFunction>::mnbrak(double& ax, double& bx, double& cx, double& fa, double& fb, double& fc, const TFltV& pcom, const TFltV& xicom) {
85    const double GOLD = 1.618034;
86    const double GLIMIT = 100.0;
87    const double TINY = 1.0e-20;
88    double ulim,u,r,q,fu,dum;
89    fa = f1dim(ax, pcom, xicom);
90    fb = f1dim(bx, pcom, xicom);
91    if (fb > fa) {
92      Shift(dum, ax, bx, dum);
93      Shift(dum, fb, fa, dum);
94    }
95    cx=(bx)+GOLD*(bx-ax);
96    fc=f1dim(cx, pcom, xicom);
97    while (fb > fc) {
98      r=(bx-ax)*(fb-fc);
99      q=(bx-cx)*(fb-fa);
100      u=(bx)-((bx-cx)*q-(bx-ax)*r)/(2.0*Sign(TMath::Mx(fabs(q-r),TINY),q-r));
101      ulim=(bx)+GLIMIT*(cx-bx);
102      if ((bx-u)*(u-cx) > 0.0) {
103        fu=f1dim(u, pcom, xicom);
104        if (fu < fc) {
105          ax=bx;
106          bx=u;
107          fa=fb;
108          fb=fu;
109          return;
110        } else if (fu > fb) {
111          cx=u;
112          fc=fu;
113          return;
114        }
115        u=(cx)+GOLD*(cx-bx);
116        fu=f1dim(u, pcom, xicom);
117      } else if ((cx-u)*(u-ulim) > 0.0) {
118        fu=f1dim(u, pcom, xicom);
119        if (fu < fc) {
120          Shift(bx,cx,u,cx+GOLD*(cx-bx));
121          Shift(fb,fc,fu,f1dim(u, pcom, xicom));
122        }
123      } else if ((u-ulim)*(ulim-cx) >= 0.0) {
124        u=ulim;
125        fu=f1dim(u, pcom, xicom);
126      } else {
127        u=cx+GOLD*(cx-bx);
128        fu=f1dim(u, pcom, xicom);
129      }
130      Shift(ax,bx,cx,u);
131      Shift(fa,fb,fc,fu);
132    }
133  }
134  template <class TFunction>
135  double TConjGrad<TFunction>::dbrent(double ax, double bx, double cx, double tol, double& xmin, const TFltV& pcom, const TFltV& xicom) {
136    const double ITMAX = 100;
137    const double ZEPS = 1.0e-10;
138    int iter,ok1,ok2;
139    double a,b,d,d1,d2,du,dv,dw,dx,e=0.0;
140    double fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;
141    a=(ax < cx ? ax : cx);
142    b=(ax > cx ? ax : cx);
143    x=w=v=bx;
144    fw=fv=fx=f1dim(x, pcom, xicom);
145    dw=dv=dx=df1dim(x, pcom, xicom);
146    for (iter=1;iter<=ITMAX;iter++) {
147      xm=0.5*(a+b);
148      tol1=tol*fabs(x)+ZEPS;
149      tol2=2.0*tol1;
150      if (fabs(x-xm) <= (tol2-0.5*(b-a))) {
151        xmin=x;
152        return fx;
153      }
154      if (fabs(e) > tol1) {
155        d1=2.0*(b-a);
156        d2=d1;
157        if (dw != dx) d1=(w-x)*dx/(dx-dw);
158        if (dv != dx) d2=(v-x)*dx/(dx-dv);
159        u1=x+d1;
160        u2=x+d2;
161        ok1 = (a-u1)*(u1-b) > 0.0 && dx*d1 <= 0.0;
162        ok2 = (a-u2)*(u2-b) > 0.0 && dx*d2 <= 0.0;
163        olde=e;
164        e=d;
165        if (ok1 || ok2) {
166          if (ok1 && ok2)
167            d=(fabs(d1) < fabs(d2) ? d1 : d2);
168          else if (ok1)
169            d=d1;
170          else
171            d=d2;
172          if (fabs(d) <= fabs(0.5*olde)) {
173            u=x+d;
174            if (u-a < tol2 || b-u < tol2)
175              d=Sign(tol1,xm-x);
176          } else {
177            d=0.5*(e=(dx >= 0.0 ? a-x : b-x));
178          }
179        } else {
180          d=0.5*(e=(dx >= 0.0 ? a-x : b-x));
181        }
182      } else {
183        d=0.5*(e=(dx >= 0.0 ? a-x : b-x));
184      }
185      if (fabs(d) >= tol1) {
186        u=x+d;
187        fu=f1dim(u, pcom, xicom);
188      } else {
189        u=x+Sign(tol1,d);
190        fu=f1dim(u, pcom, xicom);
191        if (fu > fx) {
192          xmin=x;
193          return fx;
194        }
195      }
196      du=df1dim(u, pcom, xicom);
197      if (fu <= fx) {
198        if (u >= x) a=x; else b=x;
199        Mov3(v,fv,dv, w,fw,dw);
200        Mov3(w,fw,dw, x,fx,dx);
201        Mov3(x,fx,dx, u,fu,du);
202      } else {
203        if (u < x) a=u; else b=u;
204        if (fu <= fw || w == x) {
205          Mov3(v,fv,dv, w,fw,dw);
206          Mov3(w,fw,dw, u,fu,du);
207        } else if (fu < fv || v == x || v == w) {
208          Mov3(v,fv,dv, u,fu,du);
209        }
210      }
211    }
212    xmin=-xm;
213    printf("XMin: %f\n", xmin);
214    printf("Point:");  Dump(pcom);
215    printf("Deriv:");  Dump(xicom);
216    return 0.0;
217  }
218  template <class TFunction>
219  double TConjGrad<TFunction>::f1dim(double x, const TFltV& pcom, const TFltV& xicom) {
220    const int ncom = pcom.Len();
221    TFltV xt(ncom);
222    for (int j=0; j<ncom; j++) xt[j] = pcom[j] + x*xicom[j];
223    return Func.FVal(xt);
224  }
225  template <class TFunction>
226  double TConjGrad<TFunction>::df1dim(double x, const TFltV& pcom, const TFltV& xicom) {
227    const int ncom = pcom.Len();
228    double df1=0.0;
229    TFltV xt(ncom), df(ncom);
230    for (int j=0; j<ncom; j++) xt[j]=pcom[j]+x*xicom[j];
231    Func.FDeriv(xt, df);
232    for (int j=0; j<ncom; j++) df1 += df[j]*xicom[j];
233    return df1;
234  }
235  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sappsrv.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-conjgrad.h</div>
                </div>
                <div class="column column_space"><pre><code>11  	const PWebSrv& GetWebSrv() const { return WebSrv; }
12  	int GetSockId() const { return SockId; }
13  	const PHttpRq& GetHttpRq() const { return HttpRq; }
</pre></code></div>
                <div class="column column_space"><pre><code>16    double GetMinVal() const { return MinFVal; }
17    int GetIters() const { return NIters; }
18    const TFltV& GetMinPoint() const { return Point; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    