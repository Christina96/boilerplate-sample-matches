
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.894159653149707%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</h3>
            <pre><code>1  TStr TModeNet::GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const {
2    TStr Cpy(CrossName);
3    if (!isDir || !sameMode) { return Cpy; }
4    if (isOutEdge) {
5      Cpy += ":SRC";
6    } else {
7      Cpy += ":DST";
8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
13    TInt location = CheckDenseOrSparseN(Name);
14    int index = KeyToIndexTypeN.GetDat(Name).Val2;
15    if (location == 1) {
16      TVec<TIntV> Attrs(MxNId);
17      VecOfIntVecVecsN[index] = Attrs;
18    } else {
19      THash<TInt, TIntV> Attrs;
20      VecOfIntHashVecsN[index] = Attrs;
21    }
22  }
23  void TModeNet::Clr() {
24    TStrV CNets;
25    NeighborTypes.GetKeyV(CNets);
26    for (int i=0; i < CNets.Len(); i++) {
27      MMNet->GetCrossNetByName(CNets[i]).Clr();
28    }
29    TNEANet::Clr();
30  }
31  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const int linkId, const bool sameMode, bool isDir){
32    TStr CrossName = MMNet->GetCrossName(linkId);
33    return AddNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
34  }
35  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
36    if (!NeighborTypes.IsKey(CrossName)) {
37      AddNbrType(CrossName, sameMode, isDir);
38    }
39    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
40    return AppendIntVAttrDatN(NId, EId, Name); 
41  }
42  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
43    if (!NeighborTypes.IsKey(CrossName)) {
44      return -1;
45    }
46    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
47    return DelFromIntVAttrDatN(NId, EId, Name);
48  }
49  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir){
50    TStr CrossName = MMNet->GetCrossName(linkId);
51    return DelNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
52  }
53  void TModeNet::DelNode(const int& NId) {
54    TStrV Names;
55    GetCrossNetNames(Names);
56    for (int i=0; i < Names.Len(); i++) {
57      TCrossNet& Cross = MMNet->GetCrossNetByName(Names[i]);
58      TIntV OutEIds;
59      GetNeighborsByCrossNet(NId, Names[i], OutEIds, true);
60      for (int j=0; j < OutEIds.Len(); j++) {
61        Cross.DelEdge(OutEIds[j].Val);
62      }
63      if (Cross.IsDirect && Cross.Mode1 == Cross.Mode2) {
64        TIntV InEIds;
65        GetNeighborsByCrossNet(NId, Names[i], InEIds, false);
66        for (int j=0; j < InEIds.Len(); j++) {
67          Cross.DelEdge(InEIds[j].Val);
68        }
69      }
70    }
71    TNEANet::DelNode(NId);
72  }
73  void TModeNet::SetParentPointer(TMMNet* parent) {
74    MMNet = parent;
75  }
76  int TModeNet::AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir) {
77    if (NeighborTypes.IsKey(CrossName)) { return -1; } 
78    bool hasSingleVector = (!isDir || !sameMode);
79    NeighborTypes.AddDat(CrossName, hasSingleVector);
80    return 0;
81  }
82  int TModeNet::DelNbrType(const TStr& CrossName) {
83    bool hasSingleVector = NeighborTypes.GetDat(CrossName);
84    NeighborTypes.DelKey(CrossName);
85    if (hasSingleVector) {
86      return DelAttrN(CrossName);
87    } else {
88      TStr InName = GetNeighborCrossName(CrossName, true, true, true);
89      TStr OutName = GetNeighborCrossName(CrossName, false, true, true);
90      if (DelAttrN(InName) == -1 || DelAttrN(OutName) == -1) {
91        return -1;
92      }
93    }
94    return 0;
95  }
96  void TModeNet::GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId) const{
97    TBool hasSingleVector = NeighborTypes.GetDat(Name);
98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
105  int TModeNet::AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense){
106    TInt CurrLen;
107    if (UseDense) {
108      CurrLen = VecOfIntVecVecsN.Len();
109      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
110      KeyToDenseN.AddDat(attr, true);
111      VecOfIntVecVecsN.Add(Attrs);
112    } else {
113      THash<TInt, TIntV> NewHash;
114      CurrLen = VecOfIntHashVecsN.Len();
115      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
116      KeyToDenseN.AddDat(attr, false);
117      for (int i=0; i< Attrs.Len(); i++) {
118        NewHash.AddDat(i, Attrs[i]);
119      }
120      VecOfIntHashVecsN.Add(NewHash);
121    }
122    return 0;
123  }
124  int TModeNet::AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs){
125    TInt CurrLen;
126    THash<TInt, TIntV> NewHash;
127    CurrLen = VecOfIntHashVecsN.Len();
128    KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
129    KeyToDenseN.AddDat(attr, false);
130    for (int i=0; i< Attrs.Len(); i++) {
131      NewHash.AddDat(i, Attrs[i]);
132    }
133    VecOfIntHashVecsN.Add(NewHash);
134    return 0;
135  }
136  void TModeNet::RemoveCrossNets(TModeNet& Result, TStrV& CrossNets) {
137    const TModeNet& self = *this;
138    Result = TModeNet(self, false);
139    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
140      TStr AttrName = it.GetKey();
141      TInt AttrType = it.GetDat().GetVal1();
142      TInt AttrIndex = it.GetDat().GetVal2();
143      if (AttrType != IntVType) {
144        Result.KeyToIndexTypeN.AddDat(AttrName, it.GetDat());
145      } else {
146        TStr WithoutSuffix = AttrName;
147        bool removeSuffix = false;
148        if (AttrName.IsSuffix(":SRC") || AttrName.IsSuffix(":DST")) {
149          WithoutSuffix = AttrName.GetSubStr(0, AttrName.Len()-5);
150          removeSuffix = true;
151        }
152        bool isSingleVNbrAttr = (NeighborTypes.IsKey(AttrName) && NeighborTypes.GetDat(AttrName));
153        bool isMultiVNbrAttr = (removeSuffix && NeighborTypes.IsKey(WithoutSuffix) && !NeighborTypes.GetDat(WithoutSuffix));
154        if (isSingleVNbrAttr || isMultiVNbrAttr) {
155          TStr NbrName = isSingleVNbrAttr ? AttrName : WithoutSuffix;
156          if (CrossNets.IsIn(NbrName)) {
157            Result.AddNbrType(NbrName, removeSuffix, removeSuffix);
158            TInt location = CheckDenseOrSparseN(AttrName);
159            if (location == 1) {
160              TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
161              Result.AddIntVAttrByVecN(AttrName, Attrs);
162            } else {
163              THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
164              Result.AddIntVAttrByHashN(AttrName, Attrs);
165            }
166          }
167        } else {
168          TInt location = CheckDenseOrSparseN(AttrName);
169          if (location == 1) {
170            TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
171            Result.AddIntVAttrByVecN(AttrName, Attrs);
172          } else {
173            THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
174            Result.AddIntVAttrByHashN(AttrName, Attrs);
175          }
176        }
177      }
178    }
179  }
180  int TModeNet::GetAttrTypeN(const TStr& attr) const {
181    if (KeyToIndexTypeN.IsKey(attr)) {
182      return KeyToIndexTypeN.GetDat(attr).Val1;
183    }
184    return -1;
185  }
186  int TCrossNet::GetAttrTypeE(const TStr& attr) const {
187    if (KeyToIndexTypeE.IsKey(attr)) {
188      return KeyToIndexTypeE.GetDat(attr).Val1;
189    }
190    return -1;
191  }
192  void TCrossNet::Clr() {
193    CrossH.Clr();
194    MxEId=0;
195    KeyToIndexTypeE.Clr();
196    IntDefaultsE.Clr();
197    StrDefaultsE.Clr();
198    FltDefaultsE.Clr();
199    VecOfIntVecsE.Clr();
200    VecOfStrVecsE.Clr();
201    VecOfFltVecsE.Clr(); 
202    Net->ClrNbr(Mode1, CrossNetId, true, Mode1==Mode2, IsDirect.Val);
203    Net->ClrNbr(Mode2, CrossNetId, false, Mode1==Mode2, IsDirect.Val); 
204  }
205  int TCrossNet::AddEdge(const int& sourceNId, const int& destNId, int EId){
206    if (EId == -1) { EId = MxEId;  MxEId++; }
207    else { MxEId = TMath::Mx(EId+1, MxEId()); }
208    if (Net != NULL) {
209      TModeNet& M1 = Net->TModeNetH.GetDat(this->Mode1);
210      TModeNet& M2 = Net->TModeNetH.GetDat(this->Mode2);
211      if (!M1.IsNode(sourceNId) || !M2.IsNode(destNId)) { return -1; }
212      TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
213      M1.AddNeighbor(sourceNId, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
214      M2.AddNeighbor(destNId, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
215    }
216    TCrossNet::TCrossEdge newEdge(EId, sourceNId, destNId);
217    CrossH.AddDat(EId, newEdge);
218    int i;
219    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
220      TVec<TInt>& IntVec = VecOfIntVecsE[i];
221      int KeyId = CrossH.GetKeyId(EId);
222      if (IntVec.Len() > KeyId) {
223        IntVec[KeyId] = TInt::Mn;
224      } else {
225        IntVec.Ins(KeyId, TInt::Mn);
226      }
227    }
228    TVec<TStr> DefIntVec = TVec<TStr>();
229    IntDefaultsE.GetKeyV(DefIntVec);
230    for (i = 0; i < DefIntVec.Len(); i++) {
231      TStr attr = DefIntVec[i];
232      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
233      IntVec[CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
234    }
235    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
236      TVec<TStr>& StrVec = VecOfStrVecsE[i];
237      int KeyId = CrossH.GetKeyId(EId);
238      if (StrVec.Len() > KeyId) {
239        StrVec[KeyId] = TStr::GetNullStr();
240      } else {
241        StrVec.Ins(KeyId, TStr::GetNullStr());
242      }
243    }
244    TVec<TStr> DefStrVec = TVec<TStr>();
245    StrDefaultsE.GetKeyV(DefStrVec);
246    for (i = 0; i < DefStrVec.Len(); i++) {
247      TStr attr = DefStrVec[i];
248      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
249      StrVec[CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
250    }
251    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
252      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
253      int KeyId = CrossH.GetKeyId(EId);
254      if (FltVec.Len() > KeyId) {
255        FltVec[KeyId] = TFlt::Mn;
256      } else {
257        FltVec.Ins(KeyId, TFlt::Mn);
258      }
259    }
260    TVec<TStr> DefFltVec = TVec<TStr>();
261    FltDefaultsE.GetKeyV(DefFltVec);
262    for (i = 0; i < DefFltVec.Len(); i++) {
263      TStr attr = DefFltVec[i];
264      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
265      FltVec[CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
266    }
267    return EId;
268  }
269  int TCrossNet::DelEdge(const int& EId) {
270    TCrossEdge& Edge = CrossH.GetDat(EId);
271    int srcNode = Edge.SrcNId;
272    int dstNode = Edge.DstNId;
273    TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
274    Net->GetModeNetById(this->Mode1).DelNeighbor(srcNode, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
275    Net->GetModeNetById(this->Mode2).DelNeighbor(dstNode, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
276    int i;
277    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
278      TVec<TInt>& IntVec = VecOfIntVecsE[i];
279      IntVec[CrossH.GetKeyId(EId)] =  TInt::Mn;
280    }
281    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
282      TVec<TStr>& StrVec = VecOfStrVecsE[i];
283      StrVec[CrossH.GetKeyId(EId)] =  TStr::GetNullStr();
284    }
285    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
286      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
287      FltVec[CrossH.GetKeyId(EId)] = TFlt::Mn;
288    }
289    CrossH.DelKey(EId);
290    return 0;
291  }
292  void TCrossNet::SetParentPointer(TMMNet* parent) {
293    Net = parent;
294  }
295  void TCrossNet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
296    Names = TVec<TStr>();
297    while (!CrossHI.IsEnd()) {
298      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
299        Names.Add(CrossHI.GetKey());
300      }
301      CrossHI++;
302    }  
303  }
304  void TCrossNet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
305    Values = TVec<TStr>();
306    while (!CrossHI.IsEnd()) {
307      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
308        Values.Add(GetEdgeAttrValue(EId, CrossHI));
309      }
310      CrossHI++;
311    }  
312  }
313  void TCrossNet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
314    Names = TVec<TStr>();
315    while (!CrossHI.IsEnd()) {
316      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
317        Names.Add(CrossHI.GetKey());
318      }
319      CrossHI++;
320    }  
321  }
322  void TCrossNet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const {
323    Values = TVec<TInt>();
324    while (!CrossHI.IsEnd()) {
325      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
326        TInt val = (this->VecOfIntVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
327        Values.Add(val);
328      }
329      CrossHI++;
330    }  
331  }
332  void TCrossNet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
333    Names = TVec<TStr>();
334    while (!CrossHI.IsEnd()) {
335      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
336        Names.Add(CrossHI.GetKey());
337      }
338      CrossHI++;
339    }  
340  }
341  void TCrossNet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
342    Values = TVec<TStr>();
343    while (!CrossHI.IsEnd()) {
344      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
345        TStr val = this->VecOfStrVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId);
346        Values.Add(val);
347      }
348      CrossHI++;
349    }  
350  }
351  void TCrossNet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
352    Names = TVec<TStr>();
353    while (!CrossHI.IsEnd()) {
354      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
355        Names.Add(CrossHI.GetKey());
356      }
357      CrossHI++;
358    }  
359  }
360  void TCrossNet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const {
361    Values = TVec<TFlt>();
362    while (!CrossHI.IsEnd()) {
363      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
364        TFlt val = (this->VecOfFltVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
365        Values.Add(val);
366      }
367      CrossHI++;
368    }  
369  }
370  bool TCrossNet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
371    bool IntDel = IsIntAttrDeletedE(EId, attr);
372    bool StrDel = IsStrAttrDeletedE(EId, attr);
373    bool FltDel = IsFltAttrDeletedE(EId, attr);
374    return IntDel || StrDel || FltDel;
375  }
376  bool TCrossNet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
377    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
378  }
379  bool TCrossNet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
380    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
381  }
382  bool TCrossNet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
383    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
384  }
385  bool TCrossNet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
386    bool IntDel = EdgeAttrIsIntDeleted(EId, CrossHI);
387    bool StrDel = EdgeAttrIsStrDeleted(EId, CrossHI);
388    bool FltDel = EdgeAttrIsFltDeleted(EId, CrossHI);
389    return IntDel || StrDel || FltDel;
390  }
391  bool TCrossNet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
392    return (CrossHI.GetDat().Val1 == IntType &&
393      GetIntAttrDefaultE(CrossHI.GetKey()) == this->VecOfIntVecsE.GetVal(
394      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
395  }
396  bool TCrossNet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
397    return (CrossHI.GetDat().Val1 == StrType &&
398      GetStrAttrDefaultE(CrossHI.GetKey()) == this->VecOfStrVecsE.GetVal(
399      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
400  }
401  bool TCrossNet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
402    return (CrossHI.GetDat().Val1 == FltType &&
403      GetFltAttrDefaultE(CrossHI.GetKey()) == this->VecOfFltVecsE.GetVal(
404      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
405  }
406  TStr TCrossNet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
407    if (CrossHI.GetDat().Val1 == IntType) {
408      return (this->VecOfIntVecsE.GetVal(
409        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
410    } else if(CrossHI.GetDat().Val1 == StrType) {
411      return this->VecOfStrVecsE.GetVal(
412      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId));
413    } else if (CrossHI.GetDat().Val1 == FltType) {
414      return (this->VecOfFltVecsE.GetVal(
415        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
416    }
417    return TStr::GetNullStr();
418  }
419  int TCrossNet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
420    int i;
421    TInt CurrLen;
422    if (!IsEdge(EId)) {
423       return -1;
424    }
425    if (KeyToIndexTypeE.IsKey(attr)) {
426      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
427      NewVec[CrossH.GetKeyId(EId)] = value;
428    } else {
429      CurrLen = VecOfIntVecsE.Len();
430      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
431      TVec<TInt> NewVec = TVec<TInt>();
432      for (i = 0; i < MxEId; i++) {
433        NewVec.Ins(i, GetIntAttrDefaultE(attr));
434      }
435      NewVec[CrossH.GetKeyId(EId)] = value;
436      VecOfIntVecsE.Add(NewVec);
437    }
438    return 0;
439  }
440  int TCrossNet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
441    int i;
442    TInt CurrLen;
443    if (!IsEdge(EId)) {
444       return -1;
445    }
446    if (KeyToIndexTypeE.IsKey(attr)) {
447      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
448      NewVec[CrossH.GetKeyId(EId)] = value;
449    } else {
450      CurrLen = VecOfStrVecsE.Len();
451      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
452      TVec<TStr> NewVec = TVec<TStr>();
453      for (i = 0; i < MxEId; i++) {
454        NewVec.Ins(i, GetStrAttrDefaultE(attr));
455      }
456      NewVec[CrossH.GetKeyId(EId)] = value;
457      VecOfStrVecsE.Add(NewVec);
458    }
459    return 0;
460  } 
461  int TCrossNet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
462    int i;
463    TInt CurrLen;
464    if (!IsEdge(EId)) {
465       return -1;
466    }
467    if (KeyToIndexTypeE.IsKey(attr)) {
468      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
469      NewVec[CrossH.GetKeyId(EId)] = value;
470    } else {
471      CurrLen = VecOfFltVecsE.Len();
472      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
473      TVec<TFlt> NewVec = TVec<TFlt>();
474      for (i = 0; i < MxEId; i++) {
475        NewVec.Ins(i, GetFltAttrDefaultE(attr));
476      }
477      NewVec[CrossH.GetKeyId(EId)] = value;
478      VecOfFltVecsE.Add(NewVec);
479    }
480    return 0;
481  }
482  TInt TCrossNet::GetIntAttrDatE(const int& EId, const TStr& attr) {
483    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
484  }
485  TStr TCrossNet::GetStrAttrDatE(const int& EId, const TStr& attr) {
486    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
487  }
488  TFlt TCrossNet::GetFltAttrDatE(const int& EId, const TStr& attr) {
489    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
490  }
491  int TCrossNet::DelAttrDatE(const int& EId, const TStr& attr) {
492    TInt vecType = KeyToIndexTypeE(attr).Val1;
493    if (vecType == IntType) {
494      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
495    } else if (vecType == StrType) {
496      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
497    } else if (vecType == FltType) {
498      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
499    } else {
500      return -1;
501    }
502    return 0;
503  }
504  int TCrossNet::AddIntAttrE(const TStr& attr, TInt defaultValue){
505    int i;
506    TInt CurrLen;
507    TVec<TInt> NewVec;
508    CurrLen = VecOfIntVecsE.Len();
509    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
510    NewVec = TVec<TInt>();
511    for (i = 0; i < MxEId; i++) {
512      NewVec.Ins(i, defaultValue);
513    }
514    VecOfIntVecsE.Add(NewVec);
515    if (!IntDefaultsE.IsKey(attr)) {
516      IntDefaultsE.AddDat(attr, defaultValue);
517    } else {
518      return -1;
519    }
520    return 0;
521  }
522  int TCrossNet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
523    int i;
524    TInt CurrLen;
525    TVec<TStr> NewVec;
526    CurrLen = VecOfStrVecsE.Len();
527    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
528    NewVec = TVec<TStr>();
529    for (i = 0; i < MxEId; i++) {
530      NewVec.Ins(i, defaultValue);
531    }
532    VecOfStrVecsE.Add(NewVec);
533    if (!StrDefaultsE.IsKey(attr)) {
534      StrDefaultsE.AddDat(attr, defaultValue);
535    } else {
536      return -1;
537    }
538    return 0;
539  }
540  int TCrossNet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
541    int i;
542    TInt CurrLen;
543    TVec<TFlt> NewVec;
544    CurrLen = VecOfFltVecsE.Len();
545    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
546    NewVec = TVec<TFlt>();
547    for (i = 0; i < MxEId; i++) {
548      NewVec.Ins(i, defaultValue);
549    }
550    VecOfFltVecsE.Add(NewVec);
551    if (!FltDefaultsE.IsKey(attr)) {
552      FltDefaultsE.AddDat(attr, defaultValue);
553    } else {
554      return -1;
555    }
556    return 0;
557  }
558  int TCrossNet::DelAttrE(const TStr& attr) {
559    TInt vecType = KeyToIndexTypeE(attr).Val1;
560    if (vecType == IntType) {
561      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
562      if (IntDefaultsE.IsKey(attr)) {
563        IntDefaultsE.DelKey(attr);
564      }
565    } else if (vecType == StrType) {
566      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
567      if (StrDefaultsE.IsKey(attr)) {
568        StrDefaultsE.DelKey(attr);
569      }  
570    } else if (vecType == FltType) {
571      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
572      if (FltDefaultsE.IsKey(attr)) {
573        FltDefaultsE.DelKey(attr);
574      }
575    } else {
576      return -1;
577    }
578    KeyToIndexTypeE.DelKey(attr);
579    return 0;
580  }
581  void TMMNet::LoadNetworkShM(TShMIn& ShMIn) {
582    MxModeId = TInt(ShMIn);
583    MxCrossNetId = TInt(ShMIn);
584    TModeNetInit Fm;
585    TModeNetH.LoadShM(ShMIn, Fm);
586    TCrossNetInit Fc;
587    TCrossNetH.LoadShM(ShMIn, Fc);
588    ModeIdToNameH.LoadShM(ShMIn);
589    ModeNameToIdH.LoadShM(ShMIn);
590    CrossIdToNameH.LoadShM(ShMIn);
591    CrossNameToIdH.LoadShM(ShMIn);
592    for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
593      it.GetDat().SetParentPointer(this);
594    }
595    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
596      it.GetDat().SetParentPointer(this);
597    }
598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
604    MxModeId++;
605    ModeIdToNameH.AddDat(ModeId, ModeName);
606    ModeNameToIdH.AddDat(ModeName, ModeId);
607    TModeNet NewGraph(ModeId);
608    NewGraph.SetParentPointer(this);
609    TModeNetH.AddDat(ModeId, NewGraph);
610    return ModeId;
611  }
612  int TMMNet::AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir) {
613    TInt ModeId1 = GetModeId(ModeName1);
614    TInt ModeId2 = GetModeId(ModeName2);
615    return AddCrossNet(ModeId1, ModeId2, CrossNetName, isDir);
616  }
617  int TMMNet::AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir) {
618    if (CrossNameToIdH.IsKey(CrossNetName)) {
619      return -1;
620    }
621    TInt CrossNetId = TInt(MxCrossNetId);
622    MxCrossNetId++;
623    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
624    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
625    TCrossNet Cross = TCrossNet(ModeId1, ModeId2, isDir, CrossNetId);
626    Cross.SetParentPointer(this);
627    TCrossNetH.AddDat(CrossNetId, Cross);
628    TModeNetH.GetDat(ModeId1).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
629    TModeNetH.GetDat(ModeId2).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
630    return CrossNetId;
631  }
632  int TMMNet::DelCrossNet(const TInt& CrossNetId) {
633    return DelCrossNet(CrossIdToNameH.GetDat(CrossNetId));
634  }
635  int TMMNet::DelCrossNet(const TStr& CrossNet) {
636    IAssertR(CrossNameToIdH.IsKey(CrossNet),TStr::Fmt("No such link type: %s", CrossNet.CStr()));
637    TInt CrossNetId = CrossNameToIdH.GetDat(CrossNet);
638    TInt Mode1 = GetCrossNetById(CrossNetId).Mode1;
639    TInt Mode2 = GetCrossNetById(CrossNetId).Mode2;
640    if (GetModeNetById(Mode1).DelNbrType(CrossNet) == -1 || (Mode1 != Mode2 && GetModeNetById(Mode2).DelNbrType(CrossNet) == -1)) {
641      return -1;
642    }
643    CrossNameToIdH.DelKey(CrossNet);
644    CrossIdToNameH.DelKey(CrossNetId);
645    GetCrossNetById(CrossNetId).SetParentPointer(NULL);
646    TCrossNetH.DelKey(CrossNetId);
647    return 0;
<span onclick='openModal()' class='match'>648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
</span>653      if (DelCrossNet(CrossNets[i]) == -1) {
654        return -1;
655      }
656    }
657    TStr ModeName = ModeIdToNameH.GetDat(ModeId);
658    ModeNameToIdH.DelKey(ModeName);
659    ModeIdToNameH.DelKey(ModeId);
660    GetModeNetById(ModeId).SetParentPointer(NULL);
661    TModeNetH.DelKey(ModeId);
662    return 0;
663  }
664  int TMMNet::DelModeNet(const TStr& ModeName) {
665    IAssertR(ModeNameToIdH.IsKey(ModeName), TStr::Fmt("No such mode with name: %s", ModeName.CStr()));
666    return DelModeNet(ModeNameToIdH.GetDat(ModeName));
667  }
668  TModeNet& TMMNet::GetModeNetByName(const TStr& ModeName) const {
669    return GetModeNetById(ModeNameToIdH.GetDat(ModeName));
670  }
671  TModeNet& TMMNet::GetModeNetById(const TInt& ModeId) const {
672    TModeNet &Net = (const_cast<TMMNet *>(this))->TModeNetH.GetDat(ModeId);
673    return Net;
674  }
675  TCrossNet& TMMNet::GetCrossNetByName(const TStr& CrossName) const{
676    return GetCrossNetById(CrossNameToIdH.GetDat(CrossName));
677  }
678  TCrossNet& TMMNet::GetCrossNetById(const TInt& CrossId) const{
679    TCrossNet& CrossNet = (const_cast<TMMNet *>(this))->TCrossNetH.GetDat(CrossId);
680    return CrossNet;
681  }
682  int TMMNet::AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet) {
683    ModeIdToNameH.AddDat(ModeId, ModeName);
684    ModeNameToIdH.AddDat(ModeName, ModeId);
685    TModeNetH.AddDat(ModeId, ModeNet);
686    TModeNetH[ModeId].SetParentPointer(this);
687    return ModeId;
688  }
689  int TMMNet::AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet) {
690    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
691    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
692    TCrossNetH.AddDat(CrossNetId, CrossNet);
693    TCrossNetH[CrossNetId].SetParentPointer(this);
694    return CrossNetId;
695  }
696  void TMMNet::ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir) {
697    TStr CrossNetName = CrossIdToNameH[CrossNetId];
698    TModeNetH[ModeId].ClrNbr(CrossNetName, outEdge, sameMode, isDir);
699  }
700  PMMNet TMMNet::GetSubgraphByCrossNet(TStrV& CrossNetTypes) {
701    PMMNet Result = New();
702    TInt MxMode = 0;
703    TInt MxCross = 0;
704    TIntH ModeH;
705    for(int i = 0; i < CrossNetTypes.Len(); i++) {
706      TStr CrossName = CrossNetTypes[i];
707      TInt OldId = CrossNameToIdH.GetDat(CrossName);
708      TInt NewId = MxCross++;
709      TCrossNet NewCrossNet(TCrossNetH.GetDat(OldId));
710      TInt OldModeId1 = NewCrossNet.Mode1;
711      TInt OldModeId2 = NewCrossNet.Mode2;
712      TInt NewModeId1, NewModeId2;
713      if (ModeH.IsKey(OldModeId1)) {
714        NewModeId1 = ModeH.GetDat(OldModeId1);
715      } else {
716        NewModeId1 = MxMode++;
717        ModeH.AddDat(OldModeId1, NewModeId1);
718      }
719      if (ModeH.IsKey(OldModeId2)) {
720        NewModeId2 = ModeH.GetDat(OldModeId2);
721      } else {
722        NewModeId2 = MxMode++;
723        ModeH.AddDat(OldModeId2, NewModeId2);
724      }
725      NewCrossNet.Mode1 = NewModeId1;
726      NewCrossNet.Mode2 = NewModeId2;
727      NewCrossNet.CrossNetId = NewId;
728      Result->AddCrossNet(CrossName, NewId, NewCrossNet);
729    }
730    for(TIntH::TIter it = ModeH.BegI(); it < ModeH.EndI(); it++) {
731      TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
732      TInt NewModeId = it.GetDat();
733      TModeNet NewModeNet;
734      TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, CrossNetTypes);
735      NewModeNet.ModeId = NewModeId;
736      Result->AddMode(ModeName, NewModeId, NewModeNet);
737    }
738    Result->MxModeId = MxMode;
739    Result->MxCrossNetId = MxCross;
740    return Result;
741  }
742  PMMNet TMMNet::GetSubgraphByModeNet(TStrV& ModeNetTypes) {
743    THash<TInt, TBool> ModeTypeIds;
744    for (int i = 0; i < ModeNetTypes.Len(); i++) {
745      ModeTypeIds.AddDat(ModeNameToIdH.GetDat(ModeNetTypes[i]), true);
746    }
747    TStrV CrossNetTypes;
748    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
749      TCrossNet& CrossNet = it.GetDat();
750      if (ModeTypeIds.IsKey(CrossNet.Mode1) && ModeTypeIds.IsKey(CrossNet.Mode2)) {
751        CrossNetTypes.Add(CrossIdToNameH.GetDat(it.GetKey()));
752        ModeTypeIds[CrossNet.Mode1] = false;
753        ModeTypeIds[CrossNet.Mode2] = false;
754      }
755    }
756    PMMNet Result = GetSubgraphByCrossNet(CrossNetTypes);
757    TInt MxMode = Result->MxModeId;
758    TStrV EmptyCrossNetTypes;
759    for (THash<TInt, TBool>::TIter it = ModeTypeIds.BegI(); it < ModeTypeIds.EndI(); it++) {
760      if (it.GetDat().Val) {
761        TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
762        TInt NewModeId = MxMode++;
763        TModeNet NewModeNet;
764        TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, EmptyCrossNetTypes);
765        NewModeNet.ModeId = NewModeId;
766        Result->AddMode(ModeName, NewModeId, NewModeNet);
767      }
768    }
769    Result->MxModeId = MxMode;
770    return Result;
771  }
772  PNEANet TMMNet::ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap) {
773    TIntPrIntH NodeMap;
774    THash<TIntPr, TIntPr> EdgeMap;
775    THashSet<TInt> Modes;
776    PNEANet NewNet = TNEANet::New();
777    for (int i = 0; i < CrossNetTypes.Len(); i++) {
778      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
779      TInt Mode1 = CrossNet.GetMode1();
780      TInt Mode2 = CrossNet.GetMode2();
781      Modes.AddKey(Mode1);
782      Modes.AddKey(Mode2);
783      bool isDirected = CrossNet.IsDirected();
784      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
785        int srcNode = EdgeI.GetSrcNId();
786        int dstNode = EdgeI.GetDstNId();
787        TIntPr SrcNodeMapping(Mode1, srcNode);
788        int srcId = 0;
789        if (NodeMap.IsKey(SrcNodeMapping)) {
790          srcId = NodeMap.GetDat(SrcNodeMapping);
791        } else {
792          srcId = NewNet->AddNode();
793          NodeMap.AddDat(SrcNodeMapping, srcId);
794        }
795        TIntPr DstNodeMapping(Mode2, dstNode);
796        int dstId = 0;
797        if (NodeMap.IsKey(DstNodeMapping)) {
798          dstId = NodeMap.GetDat(DstNodeMapping);
799        } else {
800          dstId = NewNet->AddNode();
801          NodeMap.AddDat(DstNodeMapping, dstId);
802        }
803        int edgeId = EdgeI.GetId();
804        TIntPr EdgeMapping(CrossNetTypes[i], edgeId);
805        int newEId = NewNet->AddEdge(srcId, dstId);
806        int otherEId = -1;
807        if (!isDirected) {
808          otherEId = NewNet->AddEdge(dstId, srcId);
809        }
810        EdgeMap.AddDat(EdgeMapping, TIntPr(newEId, otherEId));
811      }
812    }
813    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
814      TModeNet &ModeNet = GetModeNetById(it.GetKey());
815      TInt ModeId = it.GetKey();
816      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
817        TIntPr NodeKey(ModeId, NodeIt.GetId());
818        if (!NodeMap.IsKey(NodeKey)) {
819          int newId = NewNet->AddNode();
820          NodeMap.AddDat(NodeKey, newId);
821        }
822      }
823    }
824    NewNet->AddIntAttrN(TStr("Mode"));
825    NewNet->AddIntAttrN(TStr("Id"));
826    NewNet->AddIntAttrE(TStr("CrossNet"));
827    NewNet->AddIntAttrE(TStr("Id"));
828    for(TIntPrIntH::TIter it = NodeMap.BegI(); it != NodeMap.EndI(); it++) {
829      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal1(), TStr("Mode"));
830      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal2(), TStr("Id"));
831    }
832    for(THash<TIntPr, TIntPr>::TIter it = EdgeMap.BegI(); it != EdgeMap.EndI(); it++) {
833      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal1(), TStr("CrossNet"));
834      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal2(), TStr("Id"));
835      if (it.GetDat().GetVal2() != -1) {
836        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal1(), TStr("CrossNet"));
837        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal2(), TStr("Id"));
838      }
839    }
840    for (int i = 0; i < NodeAttrMap.Len(); i++) {
841      TInt ModeId = NodeAttrMap[i].Val1;
842      TStr OrigAttr = NodeAttrMap[i].Val2;
843      TStr NewAttr = NodeAttrMap[i].Val3;
844      TModeNet& Net = GetModeNetById(ModeId);
845      int type = Net.GetAttrTypeN(OrigAttr);
846      if (type == TModeNet::IntType) {
847        NewNet->AddIntAttrN(NewAttr, Net.GetIntAttrDefaultN(OrigAttr));
848        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
849          TIntPr OldNId(ModeId, it.GetId());
850          int NewId = NodeMap.GetDat(OldNId);
851          int Val = Net.GetIntAttrDatN(it.GetId(), OrigAttr);
852          NewNet->AddIntAttrDatN(NewId, Val, NewAttr);
853        }
854      } else if (type == TModeNet::FltType) {
855        NewNet->AddFltAttrN(NewAttr, Net.GetFltAttrDefaultN(OrigAttr));
856        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
857          TIntPr OldNId(ModeId, it.GetId());
858          int NewId = NodeMap.GetDat(OldNId);
859          TFlt Val = Net.GetFltAttrDatN(it.GetId(), OrigAttr);
860          NewNet->AddFltAttrDatN(NewId, Val, NewAttr);
861        }
862      } else if (type == TModeNet::StrType) {
863        NewNet->AddStrAttrN(NewAttr, Net.GetStrAttrDefaultN(OrigAttr));
864        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
865          TIntPr OldNId(ModeId, it.GetId());
866          int NewId = NodeMap.GetDat(OldNId);
867          TStr Val = Net.GetStrAttrDatN(it.GetId(), OrigAttr);
868          NewNet->AddStrAttrDatN(NewId, Val, NewAttr);
869        }
870      } else if (type == TModeNet::IntVType) {
871        NewNet->AddIntVAttrN(NewAttr);
872        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
873          TIntPr OldNId(ModeId, it.GetId());
874          int NewId = NodeMap.GetDat(OldNId);
875          TIntV Val = Net.GetIntVAttrDatN(it.GetId(), OrigAttr);
876          NewNet->AddIntVAttrDatN(NewId, Val, NewAttr);
877        }
878      }
879    }
880    for (int i = 0; i < EdgeAttrMap.Len(); i++) {
881      TInt CrossId = EdgeAttrMap[i].Val1;
882      TStr OrigAttr = EdgeAttrMap[i].Val2;
883      TStr NewAttr = EdgeAttrMap[i].Val3;
884      TCrossNet& Net = GetCrossNetById(CrossId);
885      int type = Net.GetAttrTypeE(OrigAttr);
886      if (type == TCrossNet::IntType) {
887        NewNet->AddIntAttrE(NewAttr, Net.GetIntAttrDefaultE(OrigAttr));
888        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
889          TIntPr OldNId(CrossId, it.GetId());
890          TIntPr NewId = EdgeMap.GetDat(OldNId);
891          int Val = Net.GetIntAttrDatE(it.GetId(), OrigAttr);
892          NewNet->AddIntAttrDatE(NewId.Val1, Val, NewAttr);
893          if (NewId.Val2 != -1) {
894            NewNet->AddIntAttrDatE(NewId.Val2, Val, NewAttr);
895          }
896        }
897      } else if (type == TCrossNet::FltType) {
898        NewNet->AddFltAttrE(NewAttr, Net.GetFltAttrDefaultE(OrigAttr));
899        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
900          TIntPr OldNId(CrossId, it.GetId());
901          TIntPr NewId = EdgeMap.GetDat(OldNId);
902          TFlt Val = Net.GetFltAttrDatE(it.GetId(), OrigAttr);
903          NewNet->AddFltAttrDatE(NewId.Val1, Val, NewAttr);
904          if (NewId.Val2 != -1) {
905            NewNet->AddFltAttrDatE(NewId.Val2, Val, NewAttr);
906          }
907        }
908      } else if (type == TCrossNet::StrType) {
909        NewNet->AddStrAttrE(NewAttr, Net.GetStrAttrDefaultE(OrigAttr));
910        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++){
911          TIntPr OldNId(CrossId, it.GetId());
912          TIntPr NewId = EdgeMap.GetDat(OldNId);
913          TStr Val = Net.GetStrAttrDatE(it.GetId(), OrigAttr);
914          NewNet->AddStrAttrDatE(NewId.Val1, Val, NewAttr);
915          if (NewId.Val2 != -1) {
916            NewNet->AddStrAttrDatE(NewId.Val2, Val, NewAttr);
917          }
918        }
919      }
920    }
921    return NewNet;
922  }
923  PNEANet TMMNet::ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap) {
924    TIntPrIntH NodeMap;
925    THashSet<TInt> Modes;
926    PNEANet NewNet = TNEANet::New();
927    NewNet->AddIntAttrN(TStr("Mode"));
928    NewNet->AddIntAttrN(TStr("Id"));
929    NewNet->AddIntAttrE(TStr("CrossNet"));
930    NewNet->AddIntAttrE(TStr("Id"));
931    for (int i = 0; i < CrossNetTypes.Len(); i++) {
932      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
933      TStrPrV CNetAttrs;
934      if (EdgeAttrMap.IsKey(CrossNetTypes[i])) {
935        CNetAttrs = EdgeAttrMap.GetDat(CrossNetTypes[i]);
936      }
937      TInt Mode1 = CrossNet.GetMode1();
938      TInt Mode2 = CrossNet.GetMode2();
939      TModeNet& Mode1Net = GetModeNetById(Mode1);
940      TModeNet& Mode2Net = GetModeNetById(Mode2);
941      TStrPrV Mode1Attrs;
942      if (NodeAttrMap.IsKey(Mode1)) {
943        Mode1Attrs = NodeAttrMap.GetDat(Mode1);
944      }
945      TStrPrV Mode2Attrs;
946      if (NodeAttrMap.IsKey(Mode2)) {
947        Mode2Attrs = NodeAttrMap.GetDat(Mode2);
948      } 
949      Modes.AddKey(Mode1);
950      Modes.AddKey(Mode2);
951      bool isDirected = CrossNet.IsDirected();
952      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
953        int srcNode = EdgeI.GetSrcNId();
954        int dstNode = EdgeI.GetDstNId();
955        TIntPr SrcNodeMapping(Mode1, srcNode);
956        int srcId = 0;
957        if (NodeMap.IsKey(SrcNodeMapping)) {
958          srcId = NodeMap.GetDat(SrcNodeMapping);
959        } else {
960          srcId = NewNet->AddNode();
961          NodeMap.AddDat(SrcNodeMapping, srcId);
962          NewNet->AddIntAttrDatN(srcId, srcNode, TStr("Id"));
963          NewNet->AddIntAttrDatN(srcId, Mode1, TStr("Mode"));
964          AddNodeAttributes(NewNet, Mode1Net, Mode1Attrs, Mode1, srcNode, srcId);
965        }
966        TIntPr DstNodeMapping(Mode2, dstNode);
967        int dstId = 0;
968        if (NodeMap.IsKey(DstNodeMapping)) {
969          dstId = NodeMap.GetDat(DstNodeMapping);
970        } else {
971          dstId = NewNet->AddNode();
972          NodeMap.AddDat(DstNodeMapping, dstId);
973          NewNet->AddIntAttrDatN(dstId, dstNode, TStr("Id"));
974          NewNet->AddIntAttrDatN(dstId, Mode2, TStr("Mode"));
975          AddNodeAttributes(NewNet, Mode2Net, Mode2Attrs, Mode2, dstNode, dstId);
976        }
977        int edgeId = EdgeI.GetId();
978        int newEId = NewNet->AddEdge(srcId, dstId);
979        NewNet->AddIntAttrDatE(newEId, edgeId, TStr("Id"));
980        NewNet->AddIntAttrDatE(newEId, CrossNetTypes[i], TStr("CrossNet"));
981        AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, newEId);
982        if (!isDirected) {
983          int otherEId = NewNet->AddEdge(dstId, srcId);
984          NewNet->AddIntAttrDatE(otherEId, edgeId, TStr("Id"));
985          NewNet->AddIntAttrDatE(otherEId, CrossNetTypes[i], TStr("CrossNet"));
986          AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, otherEId);
987        }
988      }
989    }
990    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
991      TInt ModeId = it.GetKey();
992      TModeNet &ModeNet = GetModeNetById(ModeId);
993      TStrPrV ModeAttrs = NodeAttrMap.GetDat(ModeId);
994      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
995        TIntPr NodeKey(ModeId, NodeIt.GetId());
996        if (!NodeMap.IsKey(NodeKey)) {
997          int newId = NewNet->AddNode();
998          NodeMap.AddDat(NodeKey, newId);
999          AddNodeAttributes(NewNet, ModeNet, ModeAttrs, ModeId, NodeIt.GetId(), newId);
1000        }
1001      }
1002    }
1003    return NewNet;
1004  }
1005  void TMMNet::GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxLen) const {
1006    if (MxLen <= NumPartitions) {
1007        Partitions.Add(TIntPr(0,MxLen));
1008    } else {
1009      TInt PartitionSize = MxLen/NumPartitions;
1010      TInt CurrStart = 0;
1011      bool done = false;
1012      while (!done) {
1013        TInt CurrEnd = CurrStart + PartitionSize;
1014        if (MxLen - CurrEnd < PartitionSize) {
1015          CurrEnd = MxLen;
1016          done = true;
1017        }
1018        Partitions.Add(TIntPr(CurrStart, CurrEnd));
1019        CurrStart = CurrEnd;
1020      }
1021    }
1022  }
1023  #ifdef GCC_ATOMIC
1024  PNEANetMP TMMNet::ToNetworkMP(TStrV& CrossNetNames) {
1025    TStrIntH CrossNetStart;
1026    THashSet<TInt> ModeSet;
1027    int offset = 0;
1028    int NumEdges = 0;
1029    TVec<TCrossNet> CrossNets;
1030    for (int i=0; i < CrossNetNames.Len(); i++) {
1031      CrossNets.Add(GetCrossNetByName(CrossNetNames[i]));
1032      CrossNetStart.AddDat(CrossNetNames[i], offset);
1033      TCrossNet& CrossNet = GetCrossNetByName(CrossNetNames[i]);
1034      int factor = CrossNet.IsDirected() ? 1 : 2;
1035      offset += (CrossNet.GetMxEId() * factor);
1036      NumEdges += (CrossNet.GetEdges() * factor);
1037      ModeSet.AddKey(CrossNet.GetMode1());
1038      ModeSet.AddKey(CrossNet.GetMode2());
1039    }
1040    int MxEId = offset;
1041    int NumNodes = 0;
1042    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1043      TModeNet& ModeNet = GetModeNetById(MI.GetKey());
1044      NumNodes += ModeNet.GetNodes();
1045    }
1046    THashMP<TIntPr, TInt> NodeMap(NumNodes);
1047    THashMP<TIntPr, TIntPr> EdgeMap(NumEdges);
1048    PNEANetMP NewNet = TNEANetMP::New(NumNodes, NumEdges);
1049    int num_threads = omp_get_max_threads();
1050    offset = 0;
1051    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1052      TInt ModeId = MI.GetKey();
1053      TModeNet& ModeNet = GetModeNetById(ModeId);
1054      TIntV KeyIds;
1055      ModeNet.NodeH.GetKeyV(KeyIds);
1056      TIntPrV NodePartitions;
1057      GetPartitionRanges(NodePartitions, num_threads, KeyIds.Len());
1058      int curr_nid;
1059      #pragma omp parallel for schedule(static) private(curr_nid)
1060      for (int i = 0; i < NodePartitions.Len(); i++) {
1061        TInt CurrStart = NodePartitions[i].GetVal1();
1062        TInt CurrEnd = NodePartitions[i].GetVal2();
1063        curr_nid = offset + CurrStart;
1064        for (int idx = CurrStart; idx < CurrEnd ; idx++) {
1065          int n_i = KeyIds[idx];
1066          if (ModeNet.IsNode(n_i)) {
1067            TIntV InNbrs;
1068            TIntV OutNbrs;
1069            for (int j=0; j < CrossNetNames.Len(); j++) {
1070              TStr CrossNetName = TStr(CrossNetNames[j].CStr());
1071              if (ModeNet.NeighborTypes.IsKey(CrossNetName)) {
1072                if (ModeNet.NeighborTypes.GetDat(CrossNetName)) {
1073                  TIntV Neighbors;
1074                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, Neighbors);
1075                  int edge_offset = CrossNetStart.GetDat(CrossNetName);
1076                  TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1077                  bool isDir = CrossNet.IsDirected();
1078                  bool isOutNbr = CrossNet.GetMode1() == ModeId;
1079                  int factor = isDir ? 1 : 2;
1080                  int id_offset = isDir || isOutNbr ? 0 : 1;
1081                  if (!isDir && CrossNet.GetMode1() == CrossNet.GetMode2()) {
1082                    id_offset = n_i == CrossNet.GetEdge(n_i).GetSrcNId() ? 0 : 1;
1083                  }
1084                  for (int k = 0; k < Neighbors.Len(); k++) {
1085                    if (isOutNbr && id_offset == 0) {
1086                      OutNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1087                    } else {
1088                      InNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1089                    }
1090                    if (!isDir) {
1091                      int opp_offset = id_offset == 1 ? 0 : 1;
1092                      if (isOutNbr && id_offset == 0) {
1093                        InNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1094                      } else {
1095                        OutNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1096                      }
1097                    }
1098                  }
1099                } else {
1100                  TIntV TempOut;
1101                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempOut, true);
1102                  OutNbrs.AddV(TempOut);
1103                  TIntV TempIn;
1104                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempIn, false);
1105                  InNbrs.AddV(TempIn);
1106                }
1107              }
1108            }
1109            NewNet->AddNodeWithEdges(curr_nid, InNbrs, OutNbrs);
1110            TIntPr NodeKey(MI.GetKey(), n_i);
1111            NodeMap.AddDat(NodeKey, curr_nid);
1112            curr_nid++;
1113          }
1114        }
1115      }
1116      offset += KeyIds.Len();
1117    }
1118    NewNet->SetNodes(offset);
1119    for (int j=0; j < CrossNetNames.Len(); j++) {
1120      TStr CrossNetName = CrossNetNames[j];
1121      TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1122      TInt CrossNetId = GetCrossId(CrossNetName);
1123      TInt Mode1 = CrossNet.GetMode1();
1124      TInt Mode2 = CrossNet.GetMode2();
1125      TIntPrV EdgePartitions;
1126      GetPartitionRanges(EdgePartitions, num_threads, CrossNet.MxEId);
1127      int curr_eid;
1128      offset = CrossNetStart.GetDat(CrossNetNames[j]);
1129      int factor = CrossNet.IsDirected() ? 1 : 2;
1130      #pragma omp parallel for schedule(static) private(curr_eid)
1131      for (int i = 0; i < EdgePartitions.Len(); i++) {
1132        TInt CurrStart = EdgePartitions[i].GetVal1();
1133        TInt CurrEnd = EdgePartitions[i].GetVal2();
1134        for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) {
1135          curr_eid = offset + factor*e_i;
1136          if (CrossNet.IsEdge(e_i)) {
1137            int new_eid = curr_eid;
1138            TIntPr EdgeKey(CrossNetId, e_i);
1139            TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i);
1140            int srcNode = edge.GetSrcNId();
1141            int dstNode = edge.GetDstNId();
1142            TIntPr NodeKeySrc(Mode1, srcNode);
1143            TIntPr NodeKeyDst(Mode2, dstNode);
1144            int newSrc = NodeMap.GetDat(NodeKeySrc);
1145            int newDst = NodeMap.GetDat(NodeKeyDst);
1146            NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst);
1147            curr_eid++;
1148            int otherEId = -1;
1149            if (!CrossNet.IsDirected()) {
1150              otherEId = curr_eid;
1151              NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc);
1152            }
1153            EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId));
1154          }
1155        }
1156      }
1157    }
1158    NewNet->SetEdges(MxEId);
1159    NewNet->ReserveAttr(2, 0, 0, 2, 0, 0);
1160    NewNet->AddIntAttrN(TStr("Mode"));
1161    NewNet->AddIntAttrN(TStr("Id"));
1162    NewNet->AddIntAttrE(TStr("CrossNet"));
1163    NewNet->AddIntAttrE(TStr("Id"));
1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
1169      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal2(), TStr("Id"));
1170    }
1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1176      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1177      if (EdgeMap.GetDat(NewEdgeIds[i]).GetVal2() != -1) {
1178        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1179        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1180      }
1181    }
1182    return NewNet;
1183  }
1184  #endif 
1185  int TMMNet::AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId) {
1186    for (int i = 0; i < Attrs.Len(); i++) {
1187      TStr OrigAttr = Attrs[i].Val1;
1188      TStr NewAttr = Attrs[i].Val2;
1189      int type = Net.GetAttrTypeN(OrigAttr);
1190      if (type == TModeNet::IntType) {
1191        TIntPr OldNId(ModeId, oldId);
1192        TInt Val = Net.GetIntAttrDatN(oldId, OrigAttr);
1193        NewNet->AddIntAttrDatN(NId, Val, NewAttr);
1194      } else if (type == TModeNet::FltType) {
1195        TIntPr OldNId(ModeId, oldId);
1196        TFlt Val = Net.GetFltAttrDatN(oldId, OrigAttr);
1197        NewNet->AddFltAttrDatN(NId, Val, NewAttr);
1198      } else if (type == TModeNet::StrType) {
1199        TIntPr OldNId(ModeId, oldId);
1200        TStr Val = Net.GetStrAttrDatN(oldId, OrigAttr);
1201        NewNet->AddStrAttrDatN(NId, Val, NewAttr);
1202      } else if (type == TModeNet::IntVType) {
1203        TIntPr OldNId(ModeId, oldId);
1204        TIntV Val = Net.GetIntVAttrDatN(oldId, OrigAttr);
1205        NewNet->AddIntVAttrDatN(NId, Val, NewAttr);
1206      }
1207    }
1208    return 0;
1209  }
1210  int TMMNet::AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId) {
1211    for (int i = 0; i < Attrs.Len(); i++) {
1212      TStr OrigAttr = Attrs[i].Val1;
1213      TStr NewAttr = Attrs[i].Val2;
1214      int type = Net.GetAttrTypeE(OrigAttr);
1215      if (type == TCrossNet::IntType) {
1216        TIntPr OldNId(CrossId, oldId);
1217        TInt Val = Net.GetIntAttrDatE(oldId, OrigAttr);
1218        NewNet->AddIntAttrDatE(EId, Val, NewAttr);
1219      } else if (type == TCrossNet::FltType) {
1220        TIntPr OldNId(CrossId, oldId);
1221        TFlt Val = Net.GetFltAttrDatE(oldId, OrigAttr);
1222        NewNet->AddFltAttrDatE(EId, Val, NewAttr);
1223      } else if (type == TCrossNet::StrType) {
1224        TIntPr OldNId(CrossId, oldId);
1225        TStr Val = Net.GetStrAttrDatE(oldId, OrigAttr);
1226        NewNet->AddStrAttrDatE(EId, Val, NewAttr);
1227      }
1228    }
1229    return 0;
1230  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.cpp</h3>
            <pre><code>1  double TMath::E=2.71828182845904523536;
2  double TMath::Pi=3.14159265358979323846;
3  double TMath::LogOf2=log(double(2));
4  void TSpecFunc::GammaPSeries&bsol;*gser*/(
5   double& gamser, const double& a, const double& x, double& gln){
6    static const int ITMAX=100;
7    static const double EPS=3.0e-7;
8    int n;
9    double sum, del, ap;
10    gln=LnGamma(a);
11    if (x <= 0.0){
12      IAssert(x>=0); &bsol;*if (x < 0.0) nrerror("x less than 0 in routine gser");*/
13      gamser=0.0;
14      return;
15    } else {
16      ap=a;
17      del=sum=1.0/a;
18      for (n=1; n<=ITMAX; n++){
19        ++ap;
20        del *= x/ap;
21        sum += del;
22        if (fabs(del) < fabs(sum)*EPS){
23          gamser=sum*exp(-x+a*log(x)-(gln));
24          return;
25        }
26      }
27      Fail; &bsol;*nrerror("a too large, ITMAX too small in routine gser");*/
28      return;
29    }
30  }
31  void TSpecFunc::GammaQContFrac&bsol;*gcf*/(
32   double& gammcf, const double& a, const double& x, double& gln){
33    static const int ITMAX=100;
34    static const double EPS=3.0e-7;
35    static const double  FPMIN=1.0e-30;
36    int i;
37    double an, b, c, d, del, h;
38    gln=LnGamma(a);
39    b=x+1.0-a;
40    c=1.0/FPMIN;
41    d=1.0/b;
42    h=d;
43    for (i=1;i<=ITMAX;i++){
44      an = -i*(i-a);
45      b += 2.0;
46      d=an*d+b;
47      if (fabs(d) < FPMIN) d=FPMIN;
48      c=b+an/c;
49      if (fabs(c) < FPMIN) c=FPMIN;
50      d=1.0/d;
51      del=d*c;
52      h *= del;
53      if (fabs(del-1.0) < EPS) break;
54    }
55    IAssert(i<=ITMAX);
56    gammcf=exp(-x+a*log(x)-(gln))*h;
57  }
58  double TSpecFunc::GammaQ&bsol;*gammq*/(const double& a, const double& x){
59    IAssert((x>=0)&&(a>0));
60    double gamser, gammcf, gln;
61    if (x<(a+1.0)){
62      GammaPSeries(gamser,a,x,gln);
63      return 1.0-gamser;
64    } else {
65      GammaQContFrac(gammcf,a,x,gln);
66      return gammcf;
67    }
68  }
69  double TSpecFunc::LnGamma&bsol;*gammln*/(const double& xx){
70    double x, y, tmp, ser;
71    static double cof[6]={76.18009172947146,-86.50532032941677,
72            24.01409824083091,-1.231739572450155,
73            0.1208650973866179e-2,-0.5395239384953e-5};
74    int j;
75    y=x=xx;
76    tmp=x+5.5;
77    tmp -= (x+0.5)*log(tmp);
78    ser=1.000000000190015;
79    for (j=0;j<=5;j++) ser += cof[j]/++y;
80    return -tmp+log(2.5066282746310005*ser/x);
81  }
82  double TSpecFunc::LnComb(const int& n, const int& k){
83    return LnGamma(n+1)-LnGamma(k+1)-LnGamma(n-k+1);
84  }
85  double TSpecFunc::BetaCf(const double& a, const double& b, const double& x){
86    static const double MAXIT=100;
87    static const double EPS=3.0e-7;
88    static const double FPMIN=1.0e-30;
89    int m,m2;
90    double aa,c,d,del,h,qab,qam,qap;
91    qab=a+b;
92    qap=a+1.0;
93    qam=a-1.0;
94    c=1.0;
95    d=1.0-qab*x/qap;
96    if (fabs(d) < FPMIN) d=FPMIN;
97    d=1.0/d;
98    h=d;
99    for (m=1;m<=MAXIT;m++) {
100      m2=2*m;
101      aa=m*(b-m)*x/((qam+m2)*(a+m2));
102      d=1.0+aa*d;
103      if (fabs(d) < FPMIN) d=FPMIN;
104      c=1.0+aa/c;
105      if (fabs(c) < FPMIN) c=FPMIN;
106      d=1.0/d;
107      h *= d*c;
108      aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
109      d=1.0+aa*d;
110      if (fabs(d) < FPMIN) d=FPMIN;
111      c=1.0+aa/c;
112      if (fabs(c) < FPMIN) c=FPMIN;
113      d=1.0/d;
114      del=d*c;
115      h *= del;
116      if (fabs(del-1.0) < EPS) break;
117    }
118    if (m > MAXIT){Fail;}
119    return h;
120  }
121  double TSpecFunc::BetaI(const double& a, const double& b, const double& x){
122    double bt;
123    if (x < 0.0 || x > 1.0){Fail;} 
124    if (x == 0.0 || x == 1.0) bt=0.0;
125    else
126      bt=exp(LnGamma(a+b)-LnGamma(a)-LnGamma(b)+a*log(x)+b*log(1.0-x));
127    if (x < (a+1.0)/(a+b+2.0))
128      return bt*BetaCf(a,b,x)/a;
129    else
130      return 1.0-bt*BetaCf(b,a,1.0-x)/b;
131  }
132  void TSpecFunc::LinearFit(
133   const TVec<TFltPr>& XY, double& A, double& B,
134   double& SigA, double& SigB, double& Chi2, double& R2) {
135    int i;
136    double t, sxoss, sx = 0.0, sy = 0.0, st2 = 0.0, ss, sigdat;
137    A = B = SigA = SigB = Chi2 = 0.0;
138    for (i = 0; i < XY.Len(); i++) {
139      sx += XY[i].Val1;
140      sy += XY[i].Val2;
141    }
142    ss = XY.Len();
143    sxoss = sx / ss;
144    for (i = 0; i <XY.Len(); i++) {
145      t = XY[i].Val1 - sxoss;
146      st2 += t*t;
147      B += t * XY[i].Val2;
148    }
149    B /= st2;
150    A = (sy - sx * B) / ss;
151    SigA = sqrt((1.0 + sx * sx / (ss * st2)) / ss);
152    SigB = sqrt(1.0 / st2);
153    for (i = 0; i < XY.Len(); i++)
154      Chi2 += TMath::Sqr(XY[i].Val2 - A - B * XY[i].Val1);
155    sigdat = sqrt(Chi2 / (XY.Len() - 2));
156    SigA *= sigdat;
157    SigB *= sigdat;
158    { double N = XY.Len(), sXY=0.0, sX=0.0, sY=0.0, sSqX=0.0, sSqY=0.0;
159    for (int s =0; s < XY.Len(); s++) {
160      sX += XY[s].Val1;  sY += XY[s].Val2;
161      sXY += XY[s].Val1 * XY[s].Val2;
162      sSqX += TMath::Sqr(XY[s].Val1);
163      sSqY += TMath::Sqr(XY[s].Val2);
164    }
165    R2 = TMath::Sqr(N*sXY - sX*sY) / ((N*sSqX - sX*sX) * (N*sSqY - sY*sY)); }
166    if (1.1 < R2 || -1.1 > R2) R2 = 0.0;
167    if (_isnan(A) || ! _finite(A)) A = 0.0;
168    if (_isnan(B) || ! _finite(B)) B = 0.0;
169  }
170  void TSpecFunc::PowerFit(const TVec<TFltPr>& XY, double& A, double& B,
171   double& SigA, double& SigB, double& Chi2, double& R2) {
172    double AA, BB;
173    TFltPrV LogXY(XY.Len(), 0);
174    for (int s = 0; s < XY.Len(); s++) {
175      LogXY.Add(TFltPr(log((double)XY[s].Val1), log((double)XY[s].Val2)));
176    }
177    TSpecFunc::LinearFit(LogXY, AA, BB, SigA, SigB, Chi2, R2);
178    A = exp(AA);  B = BB;
179    if (_isnan(AA) || ! _finite(AA)) A = 0.0;
180    if (_isnan(BB) || ! _finite(BB)) B = 0.0;
181  }
182  void TSpecFunc::LogFit(const TVec<TFltPr>& XY, double& A, double& B,
183   double& SigA, double& SigB, double& Chi2, double& R2) {
184    TFltPrV LogXY(XY.Len(), 0);
185    for (int s = 0; s < XY.Len(); s++) {
186      LogXY.Add(TFltPr(log((double)XY[s].Val1), XY[s].Val2));
187    }
188    TSpecFunc::LinearFit(LogXY, A, B, SigA, SigB, Chi2, R2);
189  }
190  void TSpecFunc::ExpFit(const TVec<TFltPr>& XY, double& A, double& B,
191   double& SigA, double& SigB, double& Chi2, double& R2) {
192    TFltPrV XLogY(XY.Len(), 0);
193    double AA, BB;
194    for (int s = 0; s < XY.Len(); s++) {
195      XLogY.Add(TFltPr(XY[s].Val1, log((double)XY[s].Val2)));
196    }
197    TSpecFunc::LinearFit(XLogY, AA, BB, SigA, SigB, Chi2, R2);
198    A = exp(AA);
199    B = BB;
<span onclick='openModal()' class='match'>200  }
201  double TSpecFunc::Entropy(const TIntV& ValV) {
202    TFltV NewValV(ValV.Len());
203    for (int i = 0; i < ValV.Len(); i++) { NewValV[i] = ValV[i]; }
</span>204    return Entropy(NewValV);
205  }
206  double TSpecFunc::Entropy(const TFltV& ValV) {
207    double Sum=0, Ent=0;
208    for (int i = 0; i < ValV.Len(); i++) {
209      const double& Val = ValV[i];
210      if (Val > 0.0) { Ent -= Val * log(Val);  Sum += Val; }
211    }
212    if (Sum > 0.0) {
213      Ent /= Sum;
214      Ent += log(Sum);
215      Ent /= TMath::LogOf2;
216    } else return 1.0;
217    return Ent;
218  }
219  void TSpecFunc::EntropyFracDim(const TIntV& ValV, TFltV& EntropyV) {
220    TFltV NewValV(ValV.Len());
221    for (int i = 0; i < ValV.Len(); i++) { 
222      IAssert(ValV[i]==1 || ValV[i] == 0);
223      NewValV[i] = ValV[i]; 
224    }
225    EntropyFracDim(NewValV, EntropyV);
226  }
227  void TSpecFunc::EntropyFracDim(const TFltV& ValV, TFltV& EntropyV) {
228    TFltV ValV1, ValV2;
229    int Pow2 = 1;
230    while (2*Pow2 <= ValV.Len()) { Pow2 *= 2; }
231    ValV1.Gen(Pow2);
232    for (int i = 0; i < Pow2; i++) { ValV1[i] = ValV[i]; 
233      IAssert(ValV[i]==1.0 || ValV[i] == 0.0); }
234    EntropyV.Clr();
235    EntropyV.Add(Entropy(ValV1)); 
236    while (ValV1.Len() > 2) {
237      ValV2.Gen(ValV1.Len() / 2);
238      for (int i = 0; i < ValV1.Len(); i++) {
239        ValV2[i/2] += ValV1[i];
240      }
241      EntropyV.Add(Entropy(ValV2));
242      ValV1.MoveFrom(ValV2);
243    }
244    EntropyV.Reverse();
245  }
246  double TSpecFunc::EntropyBias(const double& B){
247    static TFltFltH BToP;
248    if (BToP.Empty()) {
249      for (double p = 0.5; p < 1.0; p +=0.0001) {
250        double H = p * log(p) + (1.0-p) * log(1.0 - p);
251        H = -H / log(2.0);
252        BToP.AddDat(TMath::Round(H, 3), p);
253      }
254    }
255    if (BToP.IsKey(TMath::Round(B, 3))) { return BToP.GetDat(TMath::Round(B, 3)); }
256    else { return -1.0; }
257  }
258  double TSpecFunc::GetPowerCoef(const TFltV& XValV, double MinX) {
259    for (int i = 0; MinX <= 0.0 && i < XValV.Len(); i++) { 
260      MinX = XValV[i]; }
261    IAssert(MinX > 0.0);
262    double LnSum=0.0;
263    for (int i = 0; i < XValV.Len(); i++) {
264      if (XValV[i].Val < MinX) continue;
265      LnSum += log(XValV[i] / MinX);
266    }
267    return 1.0 + double(XValV.Len()) / LnSum;
268  }
269  double TSpecFunc::GetPowerCoef(const TFltPrV& XValCntV, double MinX) {
270    for (int i = 0; MinX <= 0.0 && i < XValCntV.Len(); i++) { 
271      MinX = XValCntV[i].Val1; }
272    IAssert(MinX > 0.0);
273    double NSamples=0.0, LnSum=0.0;
274    for (int i = 0; i < XValCntV.Len(); i++) {
275      if (XValCntV[i].Val1() < MinX) continue;
276      LnSum += XValCntV[i].Val2 * log(XValCntV[i].Val1 / MinX);
277      NSamples += XValCntV[i].Val2;
278    }
279    return 1.0 + NSamples / LnSum;
280  }
281  TMom::TMom(const TFltV& _ValV):
282    ValWgtV(_ValV.Len(), 0),
283    SumW(), ValSumW(),
284    UsableP(false), UnusableVal(-1),
285    Mn(), Mx(),
286    Mean(), Vari(), SDev(), SErr(),
287    Median(), Quart1(), Quart3(),
288    DecileV(), PercentileV(){
289    for (int ValN=0; ValN<_ValV.Len(); ValN++){Add(_ValV[ValN], 1);}
290    Def();
291  }
292  void TMom::Def(){
293    IAssert(!DefP); DefP=true;
294    UsableP=(SumW>0)&&(ValWgtV.Len()>0);
295    if (UsableP){
296      Mn=ValWgtV[0].Val1;
297      Mx=ValWgtV[0].Val1;
298      Mean=ValSumW/SumW;
299      Vari=0;
300      if (ValWgtV.Len()>1){
301        for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
302          const double Val=ValWgtV[ValN].Val1;
303          Vari+=ValWgtV[ValN].Val2*TMath::Sqr(Val-Mean);
304          if (Val<Mn){Mn=Val;}
305          if (Val>Mx){Mx=Val;}
306        }
307        Vari=Vari/SumW;
308        if (Vari > 0.0 && SumW > 0.0) {
309          SErr=sqrt(double(Vari))/sqrt(double(SumW)); 
310        } else { SErr = Mx; } 
311      }
312      SDev=sqrt(double(Vari));
313      ValWgtV.Sort();
314      double CurSumW = 0;
315      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
316        CurSumW += ValWgtV[ValN].Val2;
317        if (CurSumW > 0.5*SumW) { 
318          Median = ValWgtV[ValN].Val1; break; }
319        else if (CurSumW == 0.5*SumW) {
320          Median = 0.5 * (ValWgtV[ValN].Val1+ValWgtV[ValN+1].Val1); break; }
321      }
322      Quart1=Quart3=TFlt::Mn;
323      CurSumW = 0;
324      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
325        CurSumW += ValWgtV[ValN].Val2;
326        if (Quart1==TFlt::Mn) {
327          if (CurSumW > 0.25*SumW) {  Quart1 = ValWgtV[ValN].Val1; }
328        } 
329        if (Quart3==TFlt::Mn) {
330          if (CurSumW > 0.75*SumW) { Quart3 = ValWgtV[ValN].Val1; }
331        }
332      }
333      THash<TFlt, TFlt> ValWgtH;
334      for (int i = 0; i < ValWgtV.Len(); i++) {
335        ValWgtH.AddDat(ValWgtV[i].Val1) += ValWgtV[i].Val2; }
336      Mode = TFlt::Mn; double MxWgt=TFlt::Mn;
337      for (int v = 0; v < ValWgtH.Len(); v++) {
338        if (ValWgtH[v] > MxWgt) { MxWgt=ValWgtH[v]; Mode=ValWgtH.GetKey(v); }
339      }
340      CurSumW = 0;
341      int DecileN = 1, PercentileN = 1;
342      DecileV.Gen(11);  PercentileV.Gen(101);
343      DecileV[0]=Mn; DecileV[10]=Mx;
344      PercentileV[0]=Mn; PercentileV[100]=Mx;
345      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
346        CurSumW += ValWgtV[ValN].Val2;
347        if (CurSumW > SumW*DecileN*0.1) { 
348          DecileV[DecileN] = ValWgtV[ValN].Val1;  DecileN++; }
349        if (CurSumW > SumW*PercentileN*0.01) {
350          PercentileV[PercentileN] = ValWgtV[ValN].Val1;  PercentileN++; }
351      }
352    }
353    ValWgtV.Clr();
354  }
355  double TMom::GetByNm(const TStr& MomNm) const {
356    if (MomNm=="Mean"){return GetMean();}
357    else if (MomNm=="Vari"){return GetVari();}
358    else if (MomNm=="SDev"){return GetSDev();}
359    else if (MomNm=="SErr"){return GetSErr();}
360    else if (MomNm=="Median"){return GetMedian();}
361    else if (MomNm=="Quart1"){return GetQuart1();}
362    else if (MomNm=="Quart3"){return GetQuart3();}
363    else if (MomNm=="Decile0"){return GetDecile(0);}
364    else if (MomNm=="Decile1"){return GetDecile(1);}
365    else if (MomNm=="Decile2"){return GetDecile(2);}
366    else if (MomNm=="Decile3"){return GetDecile(3);}
367    else if (MomNm=="Decile4"){return GetDecile(4);}
368    else if (MomNm=="Decile5"){return GetDecile(5);}
369    else if (MomNm=="Decile6"){return GetDecile(6);}
370    else if (MomNm=="Decile7"){return GetDecile(7);}
371    else if (MomNm=="Decile8"){return GetDecile(8);}
372    else if (MomNm=="Decile9"){return GetDecile(9);}
373    else if (MomNm=="Decile10"){return GetDecile(10);}
374    else {Fail; return 0;}
375  }
376  TStr TMom::GetStrByNm(const TStr& MomNm, char* FmtStr) const {
377    if (IsUsable()){
378      if (FmtStr==NULL){
379        return TFlt::GetStr(GetByNm(MomNm));
380      } else {
381        return TFlt::GetStr(GetByNm(MomNm), FmtStr);
382      }
383    } else {
384      return "X";
385    }
386  }
387  TStr TMom::GetStr(
388   const char& SepCh, const char& DelimCh,
389   const bool& DecileP, const bool& PercentileP, const TStr& FmtStr) const {
390    TChA ChA;
391    if (IsUsable()){
392      ChA+="["; ChA+=SepCh;
393      ChA+="Vals"; ChA+=DelimCh; ChA+=TInt::GetStr(GetVals()); ChA+=SepCh;
394      ChA+="Min"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMn(), FmtStr.CStr()); ChA+=SepCh;
395      ChA+="Max"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMx(), FmtStr.CStr()); ChA+=SepCh;
396      ChA+="Mean"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMean(), FmtStr.CStr()); ChA+=SepCh;
397      ChA+="SDev"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetSDev(), FmtStr.CStr()); ChA+=SepCh;
398      ChA+="Quart1"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetQuart1(), FmtStr.CStr()); ChA+=SepCh;
399      ChA+="Median"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMedian(), FmtStr.CStr()); ChA+=SepCh;
400      ChA+="Quart3"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetQuart3(), FmtStr.CStr()); ChA+=SepCh;
401      if (DecileP){
402        for (int DecileN=0; DecileN<=10; DecileN++){
403          ChA+="Dec"; ChA+=TInt::GetStr(DecileN);
404          ChA+=DelimCh; ChA+=TFlt::GetStr(GetDecile(DecileN), FmtStr.CStr());
405          ChA+=SepCh;
406        }
407      }
408      if (PercentileP){
409        for (int PercentileN=0; PercentileN<=100; PercentileN++){
410          ChA+="Per"; ChA+=TInt::GetStr(PercentileN);
411          ChA+=DelimCh; ChA+=TFlt::GetStr(GetPercentile(PercentileN), FmtStr.CStr());
412          ChA+=SepCh;
413        }
414      }
415      ChA+="]";
416    } else {
417      ChA="[Unusable]";
418    }
419    return ChA;
420  }
421  TStr TMom::GetNmVStr(const TStr& VarPfx,
422   const char& SepCh, const bool& DecileP, const bool& PercentileP){
423    TChA ChA;
424    ChA+=VarPfx; ChA+="Vals"; ChA+=SepCh;
425    ChA+=VarPfx; ChA+="Min"; ChA+=SepCh;
426    ChA+=VarPfx; ChA+="Max"; ChA+=SepCh;
427    ChA+=VarPfx; ChA+="Mean"; ChA+=SepCh;
428    ChA+=VarPfx; ChA+="SDev"; ChA+=SepCh;
429    ChA+=VarPfx; ChA+="Quart1"; ChA+=SepCh;
430    ChA+=VarPfx; ChA+="Median"; ChA+=SepCh;
431    ChA+=VarPfx; ChA+="Quart3";
432    if (DecileP){
433      ChA+=SepCh;
434      for (int DecileN=0; DecileN<=10; DecileN++){
435        ChA+=VarPfx; ChA+="Dec"; ChA+=TInt::GetStr(DecileN);
436        if (DecileN<10){ChA+=SepCh;}
437      }
438    }
439    if (PercentileP){
440      ChA+=SepCh;
441      for (int PercentileN=0; PercentileN<=100; PercentileN++){
442        ChA+=VarPfx; ChA+="Per"; ChA+=TInt::GetStr(PercentileN);
443        if (PercentileN<100){ChA+=SepCh;}
444      }
445    }
446    return ChA;
447  }
448  TStr TMom::GetValVStr(
449   const char& SepCh, const bool& DecileP, const bool& PercentileP) const {
450    TChA ChA;
451    if (IsUsable()){
452      ChA+=TInt::GetStr(GetVals()); ChA+=SepCh;
453      ChA+=TFlt::GetStr(GetMn()); ChA+=SepCh;
454      ChA+=TFlt::GetStr(GetMx()); ChA+=SepCh;
455      ChA+=TFlt::GetStr(GetMean()); ChA+=SepCh;
456      ChA+=TFlt::GetStr(GetSDev()); ChA+=SepCh;
457      ChA+=TFlt::GetStr(GetQuart1()); ChA+=SepCh;
458      ChA+=TFlt::GetStr(GetMedian()); ChA+=SepCh;
459      ChA+=TFlt::GetStr(GetQuart3()); ChA+=SepCh;
460      if (DecileP){
461        for (int DecileN=0; DecileN<=10; DecileN++){
462          ChA+=TFlt::GetStr(GetDecile(DecileN)); ChA+=SepCh;
463        }
464      }
465      if (PercentileP){
466        for (int PercentileN=0; PercentileN<=100; PercentileN++){
467          ChA+=TFlt::GetStr(GetPercentile(PercentileN)); ChA+=SepCh;
468        }
469      }
470    } else {
471      int Vals=8;
472      if (DecileP){Vals+=11;}
473      if (PercentileP){Vals+=101;}
474      for (int ValN=0; ValN<Vals; ValN++){
475        ChA="[Unusable]";
476        if (ValN<Vals-1){ChA+=SepCh;}
477      }
478    }
479    return ChA;
480  }
481  TCorr::TCorr(const TFltV& ValV1, const TFltV& ValV2):
482    ValVLen(ValV1.Len()), CorrCf(), CorrCfPrb(), FisherZ(){
483    static const double TINY=1.0e-20;
484    IAssert(ValV1.Len()==ValV2.Len());
485    double MeanVal1=0; double MeanVal2=0;
486    {for (int ValN=0; ValN<ValVLen; ValN++){
487      MeanVal1+=ValV1[ValN]; MeanVal2+=ValV2[ValN];}}
488    MeanVal1/=ValVLen; MeanVal2/=ValVLen;
489    double yt, xt;
490    double syy=0.0; double sxy=0.0; double sxx=0.0;
491    {for (int ValN=0; ValN<ValVLen; ValN++){
492      xt=ValV1[ValN]-MeanVal1;
493      yt=ValV2[ValN]-MeanVal2;
494      sxx+=xt*xt;
495      syy+=yt*yt;
496      sxy+=xt*yt;
497    }}
498    if (sxx*syy==0){
499      CorrCf=0; /&bsol;** not in numerical recipes - check why (pojavi se, ko so same nicle)
500    } else {
501      CorrCf=sxy/sqrt(sxx*syy);
502    }
503    double df=ValVLen-2;
504    double t=CorrCf*sqrt(df/((1.0-CorrCf+TINY)*(1.0+CorrCf+TINY)));
505    CorrCfPrb=TSpecFunc::BetaI(0.5*df,0.5,df/(df+t*t));
506    FisherZ=0.5*log((1.0+(CorrCf)+TINY)/(1.0-(CorrCf)+TINY));
507  }
508  void TStatTest::AveVar(const TFltV& ValV, double& Ave, double& Var){
509    Ave=0;
510    for (int ValN=0; ValN<ValV.Len(); ValN++){
511      Ave+=ValV[ValN];}
512    Ave/=ValV.Len();
513    Var=0;
514    double ep=0;
515    for (int ValN=0; ValN<ValV.Len(); ValN++){
516      double s=ValV[ValN]-Ave;
517      ep+=s;
518      Var+=s*s;
519    }
520    Var=(Var-ep*ep/ValV.Len())/(ValV.Len()-1);
521  }
522  double TStatTest::KsProb(const double& Alam) {
523    const double EPS1 = 0.001;
524    const double EPS2 = 1.0e-8;
525    double a2 = -2.0*Alam*Alam, fac = 2.0, sum = 0.0, term, termbf = 0.0;
526    for (int j=1; j <= 100; j++) {
527      term = fac*exp(a2*j*j);
528      sum += term;
529      if (fabs(term) <= EPS1*termbf || fabs(term) <= EPS2*sum)
530        return sum;
531      fac = -fac;
532      termbf = fabs(term);
533    }
534    return 1.0;
535  }
536  void TStatTest::ChiSquareOne(
537   const TFltV& ObservedBinV, const TFltV& ExpectedBinV,
538   double& ChiSquareVal, double& SignificancePrb){
539    IAssert(ObservedBinV.Len()==ExpectedBinV.Len());
540    int Bins=ObservedBinV.Len();
541    int Constraints=0;
542    int DegreesOfFreedom=Bins-Constraints;
543    ChiSquareVal=0.0;
544    for (int BinN=0; BinN<Bins; BinN++){
545      IAssert(ExpectedBinV[BinN]>0);
546      double BinDiff=ObservedBinV[BinN]-ExpectedBinV[BinN];
547      ChiSquareVal+=BinDiff*BinDiff/ExpectedBinV[BinN];
548    }
549    SignificancePrb=
550     TSpecFunc::GammaQ(0.5*(DegreesOfFreedom), 0.5*(ChiSquareVal));
551  }
552  void TStatTest::ChiSquareTwo(
553   const TFltV& ObservedBin1V, const TFltV& ObservedBin2V,
554   double& ChiSquareVal, double& SignificancePrb){
555    IAssert(ObservedBin1V.Len()==ObservedBin1V.Len());
556    int Bins=ObservedBin1V.Len();
557    int Constraints=0;
558    int DegreesOfFreedom=Bins-Constraints;
559    ChiSquareVal=0.0;
560    for (int BinN=0; BinN<Bins; BinN++){
561      if ((ObservedBin1V[BinN]==0.0) && (ObservedBin2V[BinN]==0.0)){
562        DegreesOfFreedom--;
563      } else {
564        double BinDiff=ObservedBin1V[BinN]-ObservedBin2V[BinN];
565        ChiSquareVal+=BinDiff*BinDiff/(ObservedBin1V[BinN]+ObservedBin2V[BinN]);
566      }
567    }
568    SignificancePrb=
569     TSpecFunc::GammaQ(0.5*(DegreesOfFreedom),0.5*(ChiSquareVal));
570  }
571  void TStatTest::TTest(
572   const TFltV& ValV1, const TFltV& ValV2, double& TTestVal, double& TTestPrb){
573    PMom Val1Mom=TMom::New(ValV1);
574    PMom Val2Mom=TMom::New(ValV2);
575    double ave1=Val1Mom->GetMean();
576    double ave2=Val2Mom->GetMean();
577    double var1=Val1Mom->GetVari();
578    double var2=Val2Mom->GetVari();
579    int n1=ValV1.Len();
580    int n2=ValV2.Len();
581    TTestVal=(ave1-ave2)/sqrt(var1/n1+var2/n2);
582    double df=TMath::Sqr(var1/n1+var2/n2)/(TMath::Sqr(var1/n1)/(n1-1)+TMath::Sqr(var2/n2)/(n2-1));
583    TTestPrb=TSpecFunc::BetaI(0.5*df, 0.5, df/(df+TMath::Sqr(TTestVal)));
584  }
585  void TStatTest::KsTest(const TFltV& ValV1, const TFltV& ValV2, double& DStat, double& PVal) {
586    IAssert(ValV1.IsSorted() && ValV2.IsSorted());
587    int i1=0, i2=0;
588    double CumSum1=0.0, CumSum2=0.0, Cdf1=0.0, Cdf2=0.0;
589    const double N1 = ValV1.Len();
590    const double N2 = ValV2.Len();
591    if (! (N1 > 0.0 && N2 > 0.0)) { DStat = 1.0;  PVal = 0.0;  return; }
592    DStat=0.0; PVal=0.0;
593    while (i1 < ValV1.Len() && i2 < ValV2.Len()) {
594      const double X1 = ValV1[i1];
595      const double X2 = ValV2[i2];
596      if (X1 <= X2) {
597        CumSum1 += 1;
598        Cdf1 = (CumSum1 / N1);
599        i1++;
600      }
601      if (X2 <= X1) {
602        CumSum2 += 1;
603        Cdf2 = (CumSum2 / N2);
604        i2++;
605      }
606      DStat = TMath::Mx(DStat, fabs(Cdf1 - Cdf2));
607    }
608    const double En = sqrt( N1*N2 / (N1+N2));
609    PVal = TStatTest::KsProb((En+0.12+0.11/En)*DStat);
610  }
611  void TStatTest::KsTest(const TFltPrV& ValCntV1, const TFltPrV& ValCntV2, double& DStat, double& PVal) {
612    IAssert(ValCntV1.IsSorted() && ValCntV2.IsSorted());
613    int i1=0, i2=0;
614    double N1=0.0, N2=0.0, CumSum1=0.0, CumSum2=0.0, Cdf1=0.0, Cdf2=0.0;
615    DStat=0.0;  PVal=0.0;
616    for (int i = 0; i < ValCntV1.Len(); i++) N1 += ValCntV1[i].Val2;
617    for (int i = 0; i < ValCntV2.Len(); i++) N2 += ValCntV2[i].Val2;
618    if (! (N1 > 0.0 && N2 > 0.0)) { DStat = 1.0;  PVal = 0.0;  return; }
619    while (i1 < ValCntV1.Len() && i2 < ValCntV2.Len()) {
620      const double X1 = ValCntV1[i1].Val1;
621      const double X2 = ValCntV2[i2].Val1;
622      if (X1 <= X2) {
623        CumSum1 += ValCntV1[i1].Val2;
624        Cdf1 = (CumSum1 / N1);
625        i1++;
626      }
627      if (X2 <= X1) {
628        CumSum2 += ValCntV2[i2].Val2;
629        Cdf2 = (CumSum2 / N2);
630        i2++;
631      }
632      DStat = TMath::Mx(DStat, fabs(Cdf1 - Cdf2));
633    }
634    const double En = sqrt( N1*N2 / (N1+N2));
635    PVal = TStatTest::KsProb((En+0.12+0.11/En)*DStat);
636  }
637  bool TComb::GetNext(){
638    if (ItemV.Len()==0){
639      ItemV.Gen(Order, Order);
640      for (int OrderN=0; OrderN<Order; OrderN++){
641        ItemV[OrderN]=OrderN;}
642      return true;
643    } else {
644      if (ItemV.Last()==Items-1){
645        int OrderN=Order-1;
646        while ((OrderN>=0)&&(ItemV[OrderN]==Items-(Order-OrderN-1)-1)){OrderN--;}
647        if (OrderN<0){
648          return false;
649        } else {
650          ItemV[OrderN]++;
651          for (int SubOrderN=OrderN+1; SubOrderN<Order; SubOrderN++){
652            ItemV[SubOrderN]=ItemV[SubOrderN-1]+1;}
653          CombN++; return true;
654        }
655      } else {
656        ItemV.Last()++; CombN++; return true;
657      }
658    }
659  }
660  int TComb::GetCombs() const {
661    int LCombs=1; int HCombs=1;
662    for (int OrderN=0; OrderN<Order; OrderN++){
663      LCombs*=OrderN+1; HCombs*=Items-OrderN;}
664    int Combs=HCombs/LCombs;
665    return Combs;
666  }
667  void TComb::Wr(){
668    printf("%d:[", GetCombN());
669    for (int OrderN=0; OrderN<Order; OrderN++){
670      if (OrderN>0){printf(" ");}
671      printf("%d", ItemV[OrderN]());
672    }
673    printf("]\n");
674  }
675  PLinReg TLinReg::New(const TFltVV& _XVV, const TFltV& _YV, const TFltV& _SigV){
676    PLinReg LinReg=PLinReg(new TLinReg());
677    LinReg->XVV=_XVV;
678    LinReg->YV=_YV;
679    if (_SigV.Empty()){
680      LinReg->SigV.Gen(LinReg->YV.Len());
681      LinReg->SigV.PutAll(1);
682    } else {
683      LinReg->SigV=_SigV;
684    }
685    LinReg->Recs=LinReg->XVV.GetXDim();
686    LinReg->Vars=LinReg->XVV.GetYDim();
687    IAssert(LinReg->Recs>0);
688    IAssert(LinReg->Vars>0);
689    IAssert(LinReg->YV.Len()==LinReg->Recs);
690    IAssert(LinReg->SigV.Len()==LinReg->Recs);
691    LinReg->CovarVV.Gen(LinReg->Vars+1, LinReg->Vars+1);
692    LinReg->CfV.Gen(LinReg->Vars+1);
693    LinReg->NR_lfit();
694    return LinReg;
695  }
696  void TLinReg::NR_covsrt(
697   TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit){
698    for (int i=mfit+1; i<=Vars; i++){
699      for (int j=1; j<=i; j++){
700        CovarVV.At(i, j)=0; CovarVV.At(j, i)=0.0;}
701    }
702    int k=mfit;
703    for (int j=Vars; j>=1; j--){
704      if (ia[j]!=0){
705        for (int i=1; i<=Vars; i++){Swap(CovarVV.At(i, k), CovarVV.At(i, j));}
706        {for (int i=1; i<=Vars; i++){Swap(CovarVV.At(k, i), CovarVV.At(j, i));}}
707        k--;
708      }
709    }
710  }
711  void TLinReg::NR_gaussj(TFltVV& a, const int& n, TFltVV& b, const int& m){
712    int i, icol=0, irow=0, j, k, l, ll;
713    double big, dum, pivinv;
714    TIntV indxc(n+1);
715    TIntV indxr(n+1);
716    TIntV ipiv(n+1);
717    for (j=1; j<=n; j++){ipiv[j]=0;}
718    for (i=1; i<=n; i++){
719      big=0.0;
720      for (j=1; j<=n; j++){
721        if (ipiv[j]!=1){
722          for (k=1; k<=n; k++){
723            if (ipiv[k]==0){
724              if (fabs(double(a.At(j, k))) >= big){
725                big=fabs(double(a.At(j, k)));
726                irow=j;
727                icol=k;
728              }
729            } else
730            if (ipiv[k]>1){
731              TExcept::Throw("Singular Matrix(1) in Gauss");}
732          }
733        }
734      }
735      ipiv[icol]++;
736      if (irow != icol){
737        for (l=1; l<=n; l++){Swap(a.At(irow, l), a.At(icol, l));}
738        for (l=1; l<=m; l++){Swap(b.At(irow, l), b.At(icol, l));}
739      }
740      indxr[i]=irow;
741      indxc[i]=icol;
742      if (a.At(icol, icol)==0.0){
743        TExcept::Throw("Singular Matrix(1) in Gauss");}
744      pivinv=1.0/a.At(icol, icol);
745      a.At(icol, icol)=1.0;
746      for (l=1; l<=n; l++){a.At(icol, l)=a.At(icol, l)*pivinv;}
747      for (l=1; l<=m; l++){b.At(icol, l)=b.At(icol, l)*pivinv;}
748      for (ll=1; ll<=n; ll++){
749        if (ll != icol){
750          dum=a.At(ll, icol);
751          a.At(ll, icol)=0.0;
752          for (l=1;l<=n;l++){a.At(ll, l)-=a.At(icol, l)*dum;}
753          for (l=1;l<=m;l++){b.At(ll, l)-=b.At(icol, l)*dum;}
754        }
755      }
756    }
757    for (l=n; l>=1; l--){
758      if (indxr[l]!=indxc[l]){
759        for (k=1; k<=n; k++){
760          Swap(a.At(k, indxr[l]), a.At(k, indxc[l]));}
761      }
762    }
763  }
764  void TLinReg::NR_lfit(){
765    int i,j,k,l,m,mfit=0;
766    double ym,wt,sum,sig2i;
767    TIntV ia(Vars+1); for (i=1; i<=Vars; i++){ia[i]=1;}
768    TFltVV beta(Vars+1, 1+1);
769    TFltV afunc(Vars+1);
770    for (j=1;j<=Vars;j++){
771      if (ia[j]!=0){mfit++;}}
772    if (mfit==0){TExcept::Throw("No parameters to be fitted in LFit");}
773    for (j=1; j<=mfit; j++){
774      for (k=1; k<=mfit; k++){CovarVV.At(j, k)=0.0;}
775      beta.At(j, 1)=0.0;
776    }
777    for (i=1; i<=Recs; i++){
778      GetXV(i, afunc); 
779      ym=GetY(i);
780      if (mfit<Vars){
781        for (j=1;j<=Vars;j++){
782          if (ia[j]==0){ym-=CfV[j]*afunc[j];}}
783      }
784      sig2i=1.0/TMath::Sqr(GetSig(i));
785      for (j=0, l=1; l<=Vars; l++){
786        if (ia[l]!=0){
787          wt=afunc[l]*sig2i;
788          for (j++, k=0, m=1; m<=l; m++){
789            if (ia[m]!=0){CovarVV.At(j, ++k)+=wt*afunc[m];}
790          }
791          beta.At(j, 1)+=ym*wt;
792        }
793      }
794    }
795    for (j=2; j<=mfit; j++){
796      for (k=1; k<j; k++){CovarVV.At(k, j)=CovarVV.At(j, k);}
797    }
798    NR_gaussj(CovarVV, mfit, beta, 1);
799    for (j=0, l=1; l<=Vars; l++){
800      if (ia[l]!=0){CfV[l]=beta.At(++j, 1);}
801    }
802    ChiSq=0.0;
803    for (i=1; i<=Recs; i++){
804      GetXV(i, afunc); 
805      for (sum=0.0, j=1; j<=Vars; j++){sum+=CfV[j]*afunc[j];}
806      ChiSq+=TMath::Sqr((GetY(i)-sum)/GetSig(i));
807    }
808    NR_covsrt(CovarVV, Vars, ia, mfit);
809  }
810  void TLinReg::Wr() const {
811    printf("\n%11s %21s\n","parameter","uncertainty");
812    for (int i=0; i<Vars;i++){
813      printf("  a[%1d] = %8.6f %12.6f\n",
814       i+1, GetCf(i), GetCfUncer(i));
815    }
816    printf("chi-squared = %12f\n", GetChiSq());
817    printf("full covariance matrix\n");
818    {for (int i=0;i<Vars;i++){
819      for (int j=0;j<Vars;j++){
820        printf("%12f", GetCovar(i, j));}
821      printf("\n");
822    }}
823  }
824  PSvd TSvd::New(const TFltVV& _XVV, const TFltV& _YV, const TFltV& _SigV){
825    PSvd Svd=PSvd(new TSvd());
826    Svd->XVV=_XVV;
827    Svd->YV=_YV;
828    if (_SigV.Empty()){
829      Svd->SigV.Gen(Svd->YV.Len());
830      Svd->SigV.PutAll(1);
831    } else {
832      Svd->SigV=_SigV;
833    }
834    Svd->Recs=Svd->XVV.GetXDim();
835    Svd->Vars=Svd->XVV.GetYDim();
836    IAssert(Svd->Recs>0);
837    IAssert(Svd->Vars>0);
838    IAssert(Svd->YV.Len()==Svd->Recs);
839    IAssert(Svd->SigV.Len()==Svd->Recs);
840    Svd->CovarVV.Gen(Svd->Vars+1, Svd->Vars+1);
841    Svd->CfV.Gen(Svd->Vars+1);
842    Svd->NR_svdfit();
843    return Svd;
844  }
845  double TSvd::NR_pythag(double a, double b){
846    double absa,absb;
847    absa=fabs(a);
848    absb=fabs(b);
849    if (absa > absb){
850      return absa*sqrt(1.0+TMath::Sqr(absb/absa));
851    } else {
852      return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+TMath::Sqr(absa/absb)));
853    }
854  }
855  void TSvd::NR_svdcmp(TFltVV& a, int m, int n, TFltV& w, TFltVV& v){
856    int flag,i,its,j,jj,k,l=0,nm;
857    double anorm,c,f,g,h,s,scale,x,y,z;
858    TFltV rv1(n+1);
859    g=scale=anorm=0.0;
860    for (i=1;i<=n;i++) {
861      l=i+1;
862      rv1[i]=scale*g;
863      g=s=scale=0.0;
864      if (i <= m) {
865        for (k=i;k<=m;k++) scale += fabs(double(a.At(k,i)));
866        if (scale) {
867          for (k=i;k<=m;k++) {
868            a.At(k,i) /= scale;
869            s += a.At(k,i)*a.At(k,i);
870          }
871          f=a.At(i,i);
872          g = -NR_SIGN(sqrt(s),f);
873          h=f*g-s;
874          a.At(i,i)=f-g;
875          for (j=l;j<=n;j++) {
876            for (s=0.0,k=i;k<=m;k++) s += a.At(k,i)*a(k,j);
877            f=s/h;
878            for (k=i;k<=m;k++) a.At(k,j) += f*a.At(k,i);
879          }
880          for (k=i;k<=m;k++) a.At(k,i) *= scale;
881        }
882      }
883      w[i]=scale *g;
884      g=s=scale=0.0;
885      if (i <= m && i != n) {
886        for (k=l;k<=n;k++) scale += fabs(double(a.At(i,k)));
887        if (scale) {
888          for (k=l;k<=n;k++) {
889            a.At(i,k) /= scale;
890            s += a.At(i,k)*a.At(i,k);
891          }
892          f=a.At(i,l);
893          g = -NR_SIGN(sqrt(s),f);
894          h=f*g-s;
895          a.At(i,l)=f-g;
896          for (k=l;k<=n;k++) rv1[k]=a.At(i,k)/h;
897          for (j=l;j<=m;j++) {
898            for (s=0.0,k=l;k<=n;k++) s += a.At(j,k)*a.At(i,k);
899            for (k=l;k<=n;k++) a.At(j,k) += s*rv1[k];
900          }
901          for (k=l;k<=n;k++) a.At(i,k) *= scale;
902        }
903      }
904      anorm=NR_FMAX(anorm,(fabs(double(w[i]))+fabs(double(rv1[i]))));
905    }
906    for (i=n;i>=1;i--) {
907      if (i < n) {
908        if (g) {
909          for (j=l;j<=n;j++)
910            v.At(j,i)=(a.At(i,j)/a.At(i,l))/g;
911          for (j=l;j<=n;j++) {
912            for (s=0.0,k=l;k<=n;k++) s += a.At(i,k)*v.At(k,j);
913            for (k=l;k<=n;k++) v.At(k,j) += s*v.At(k,i);
914          }
915        }
916        for (j=l;j<=n;j++) v.At(i,j)=v.At(j,i)=0.0;
917      }
918      v.At(i,i)=1.0;
919      g=rv1[i];
920      l=i;
921    }
922    for (i=NR_IMIN(m,n);i>=1;i--) {
923      l=i+1;
924      g=w[i];
925      for (j=l;j<=n;j++) a.At(i,j)=0.0;
926      if (g) {
927        g=1.0/g;
928        for (j=l;j<=n;j++) {
929          for (s=0.0,k=l;k<=m;k++) s += a.At(k,i)*a.At(k,j);
930          f=(s/a.At(i,i))*g;
931          for (k=i;k<=m;k++) a.At(k,j) += f*a.At(k,i);
932        }
933        for (j=i;j<=m;j++) a.At(j,i) *= g;
934      } else for (j=i;j<=m;j++) a.At(j,i)=0.0;
935      a.At(i,i)++;
936    }
937    for (k=n;k>=1;k--) {
938      for (its=1;its<=30;its++) {
939        flag=1;
940        for (l=k;l>=1;l--) {
941          nm=l-1;
942          if ((double)(fabs(double(rv1[l])+anorm)) == anorm) {
943            flag=0;
944            break;
945          }
946          if ((double)(fabs(double(w[nm]))+anorm) == anorm) break;
947        }
948        if (flag) {
949          c=0.0;
950          s=1.0;
951          for (i=l;i<=k;i++) {
952            f=s*rv1[i];
953            rv1[i]=c*rv1[i];
954            if ((double)(fabs(f)+anorm) == anorm) break;
955            g=w[i];
956            h=NR_pythag(f,g);
957            w[i]=h;
958            h=1.0/h;
959            c=g*h;
960            s = -f*h;
961            for (j=1;j<=m;j++) {
962              y=a.At(j,nm);
963              z=a.At(j,i);
964              a.At(j,nm)=y*c+z*s;
965              a.At(j,i)=z*c-y*s;
966            }
967          }
968        }
969        z=w[k];
970        if (l == k) {
971          if (z < 0.0) {
972            w[k] = -z;
973            for (j=1;j<=n;j++) v.At(j,k) = -v.At(j,k);
974          }
975          break;
976        }
977        if (its==30){
978          TExcept::Throw("no convergence in 30 svdcmp iterations");}
979        x=w[l];
980        nm=k-1;
981        y=w[nm];
982        g=rv1[nm];
983        h=rv1[k];
984        f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
985        g=NR_pythag(f,1.0);
986        f=((x-z)*(x+z)+h*((y/(f+NR_SIGN(g,f)))-h))/x;
987        c=s=1.0;
988        for (j=l;j<=nm;j++) {
989          i=j+1;
990          g=rv1[i];
991          y=w[i];
992          h=s*g;
993          g=c*g;
994          z=NR_pythag(f,h);
995          rv1[j]=z;
996          c=f/z;
997          s=h/z;
998          f=x*c+g*s;
999          g = g*c-x*s;
1000          h=y*s;
1001          y *= c;
1002          for (jj=1;jj<=n;jj++) {
1003            x=v.At(jj,j);
1004            z=v.At(jj,i);
1005            v.At(jj,j)=x*c+z*s;
1006            v.At(jj,i)=z*c-x*s;
1007          }
1008          z=NR_pythag(f,h);
1009          w[j]=z;
1010          if (z) {
1011            z=1.0/z;
1012            c=f*z;
1013            s=h*z;
1014          }
1015          f=c*g+s*y;
1016          x=c*y-s*g;
1017          for (jj=1;jj<=m;jj++) {
1018            y=a.At(jj,j);
1019            z=a.At(jj,i);
1020            a.At(jj,j)=y*c+z*s;
1021            a.At(jj,i)=z*c-y*s;
1022          }
1023        }
1024        rv1[l]=0.0;
1025        rv1[k]=f;
1026        w[k]=x;
1027      }
1028    }
1029  }
1030  void TSvd::NR_svbksb(
1031   TFltVV& u, TFltV& w, TFltVV& v, int m, int n, TFltV& b, TFltV& x){
1032    int jj,j,i;
1033    double s;
1034    TFltV tmp(n+1);
1035    for (j=1;j<=n;j++) {
1036      s=0.0;
1037      if (w[j]) {
1038        for (i=1;i<=m;i++) s += u.At(i,j)*b[i];
1039        s /= w[j];
1040      }
1041      tmp[j]=s;
1042    }
1043    for (j=1;j<=n;j++) {
1044      s=0.0;
1045      for (jj=1;jj<=n;jj++) s += v.At(j,jj)*tmp[jj];
1046      x[j]=s;
1047    }
1048  }
1049  void TSvd::NR_svdvar(TFltVV& v, int ma, TFltV& w, TFltVV& cvm){
1050    int k,j,i;
1051    double sum;
1052    TFltV wti(ma+1);
1053    for (i=1;i<=ma;i++) {
1054      wti[i]=0.0;
1055      if (w[i]) wti[i]=1.0/(w[i]*w[i]);
1056    }
1057    for (i=1;i<=ma;i++) {
1058      for (j=1;j<=i;j++) {
1059        for (sum=0.0,k=1;k<=ma;k++) sum += v.At(i,k)*v.At(j,k)*wti[k];
1060        cvm.At(j,i)=cvm.At(i,j)=sum;
1061      }
1062    }
1063  }
1064  void TSvd::NR_svdfit(){
1065    int j,i;
1066    double wmax,tmp,thresh,sum;
1067    double TOL=1.0e-5;
1068    TFltVV u(Recs+1, Vars+1);
1069    TFltVV v(Vars+1, Vars+1);
1070    TFltV w(Vars+1);
1071    TFltV b(Recs+1);
1072    TFltV afunc(Vars+1);
1073    for (i=1;i<=Recs;i++) {
1074      GetXV(i, afunc); 
1075      tmp=1.0/GetSig(i);
1076      for (j=1;j<=Vars;j++){u.At(i,j)=afunc[j]*tmp;}
1077      b[i]=GetY(i)*tmp;
1078    }
1079    NR_svdcmp(u,Recs,Vars,w,v);
1080    wmax=0.0;
1081    for (j=1;j<=Vars;j++){
1082      if (w[j] > wmax){wmax=w[j];}}
1083    thresh=TOL*wmax;
1084    for (j=1;j<=Vars;j++){
1085      if (double(w[j])<thresh){w[j]=0.0;}}
1086    NR_svbksb(u,w,v,Recs,Vars,b,CfV);
1087    ChiSq=0.0;
1088    for (i=1;i<=Recs;i++) {
1089      GetXV(i, afunc); 
1090      for (sum=0.0,j=1;j<=Vars;j++){sum += CfV[j]*afunc[j];}
1091      ChiSq += (tmp=(GetY(i)-sum)/GetSig(i),tmp*tmp);
1092    }
1093    CovarVV.Gen(Vars+1, Vars+1);
1094    NR_svdvar(v, Vars, w, CovarVV);
1095  }
1096  void TSvd::GetCfV(TFltV& _CfV){
1097    _CfV=CfV; _CfV.Del(0);
1098  }
1099  void TSvd::GetCfUncerV(TFltV& CfUncerV){
1100    CfUncerV.Gen(Vars);
1101    for (int VarN=0; VarN<Vars; VarN++){
1102      CfUncerV[VarN]=GetCfUncer(VarN);
1103    }
1104  }
1105  void TSvd::Svd(const TFltVV& InMtx, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV) {
1106    LSingV.Gen(InMtx.GetYDim()+1, InMtx.GetYDim()+1);
1107    for (int x = 0; x < InMtx.GetXDim(); x++) {
1108      for (int y = 0; y < InMtx.GetYDim(); y++) {
1109        LSingV.At(x+1, y+1) = InMtx.At(x, y);
1110      }
1111    }
1112    RSingV.Gen(InMtx.GetYDim()+1, InMtx.GetYDim()+1);
1113    SingValV.Gen(InMtx.GetYDim()+1);
1114    TSvd::NR_svdcmp(LSingV, InMtx.GetXDim(), InMtx.GetYDim(), SingValV, RSingV);
1115    SingValV.Del(0);
1116    LSingV.DelX(0); LSingV.DelY(0);
1117    RSingV.DelX(0); RSingV.DelY(0);
1118  }
1119  void TSvd::Svd1Based(const TFltVV& InMtx1, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV) {
1120    LSingV = InMtx1;
1121    SingValV.Gen(InMtx1.GetYDim());
1122    RSingV.Gen(InMtx1.GetYDim(), InMtx1.GetYDim());
1123    TSvd::NR_svdcmp(LSingV, InMtx1.GetXDim()-1, InMtx1.GetYDim()-1, SingValV, RSingV);
1124    SingValV.Del(0);
1125    LSingV.DelX(0); LSingV.DelY(0);
1126    RSingV.DelX(0); RSingV.DelY(0);
1127  }
1128  void TSvd::Wr() const {
1129    printf("\n%11s %21s\n","parameter","uncertainty");
1130    for (int i=0; i<Vars;i++){
1131      printf("  a[%1d] = %8.6f %12.6f\n",
1132       i+1, GetCf(i), GetCfUncer(i));
1133    }
1134    printf("chi-squared = %12f\n", GetChiSq());
1135    printf("full covariance matrix\n");
1136    {for (int i=0;i<Vars;i++){
1137      for (int j=0;j<Vars;j++){
1138        printf("%12f", GetCovar(i, j));}
1139      printf("\n");
1140    }}
1141  }
1142  void THist::Add(const double& Val, const bool& OnlyInP) {
1143      const int BucketN = int(floor((Val - MnVal) / BucketSize));
1144  	if (OnlyInP) { 
1145  		EAssert(MnVal <= Val && Val <= MxVal);
1146  		BucketV[BucketN]++;
1147  	} else {
1148  		if (BucketN < 0) {
1149  			BucketV[0]++;
1150  		} else if (BucketN < BucketV.Len()) {
1151  			BucketV[BucketN]++;
1152  		} else {
1153  			BucketV.Last()++;
1154  		}
1155  	}
1156  	Vals++;
1157  }
1158  void THist::SaveStat(const TStr& ValNm, TSOut& FOut) const {
1159      FOut.PutStrLn("#" + ValNm + ": " + Vals.GetStr());
1160      const int Buckets = BucketV.Len() - 1;
1161      for (int BucketN = 0; BucketN < Buckets; BucketN++) {
1162          FOut.PutStrLn(TStr::Fmt("%d-%d\t%d", BucketSize*BucketN,
1163              BucketSize*(BucketN+1), BucketV[BucketN]()));
1164      }
1165      if (BucketV.Last() > 0) {
1166          FOut.PutStrLn(TStr::Fmt("%d-\t%d", BucketSize*Buckets, BucketV.Last()()));
1167      }
1168  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.cpp</div>
                <div class="column column_space"><pre><code>648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>200  }
201  double TSpecFunc::Entropy(const TIntV& ValV) {
202    TFltV NewValV(ValV.Len());
203    for (int i = 0; i < ValV.Len(); i++) { NewValV[i] = ValV[i]; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    