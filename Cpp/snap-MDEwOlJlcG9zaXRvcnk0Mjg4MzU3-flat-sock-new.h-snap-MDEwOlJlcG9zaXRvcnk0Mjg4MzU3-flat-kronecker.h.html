
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.391375101708705%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock-new.h</h3>
            <pre><code>1  #ifndef _sock_h
2  #define _sock_h
3  #include "base.h"
4  ClassHdTP(TSockEvent, PSockEvent);
5  typedef TVec<PSockEvent> TSockEventV;
6  typedef THash<TInt, PSockEvent> TIdToSockEventH;
7  ClassHdTP(TSock, PSock);
8  ClassHdTP(TSockHost, PSockHost);
9  ClassTP(TSockEvent, PSockEvent)
10  private:
11    static int LastSockEventId;
12    int SockEventId;
13    UndefCopyAssign(TSockEvent);
14  public:
15    TSockEvent():
16      SockEventId(++LastSockEventId){}
17    virtual ~TSockEvent();
18    TSockEvent(TSIn&){Fail;}
19    static PSockEvent Load(TSIn&){Fail; return NULL;}
20    void Save(TSOut&){Fail;}
21    int GetSockEventId() const {return SockEventId;}
22    virtual void CloseConn(){}
23    virtual int GetBytesRead() const {return -1;}
24    virtual void OnRead(const int& &bsol;*SockId*/, const PSIn& &bsol;*SIn*/){}
25    virtual void OnWrite(const int& &bsol;*SockId*/){}
26    virtual void OnOob(const int& &bsol;*SockId*/){}
27    virtual void OnAccept(const int& &bsol;*SockId*/, const PSock& &bsol;*Sock*/){}
28    virtual void OnConnect(const int& &bsol;*SockId*/){}
29    virtual void OnClose(const int& &bsol;*SockId*/){}
30    virtual void OnTimeOut(const int& &bsol;*SockId*/){}
31    virtual void OnError(
32     const int& &bsol;*SockId*/, const int& &bsol;*ErrCd*/, const TStr& &bsol;*ErrStr*/){}
33    virtual void OnGetHost(const PSockHost& &bsol;*SockHost*/){}
34    static bool IsReg(const PSockEvent& SockEvent);
35    static void Reg(const PSockEvent& SockEvent);
36    static void UnReg(const PSockEvent& SockEvent);
37  };
38  typedef enum {
39    shsUndef, shsOk, shsHostNotFound, shsTryAgain, shsError, shsInProgress} TSockHostStatus;
40  ClassTP(TSockHost, PSockHost)
41  private:
42    static int LastSockHostId;		
43    int SockHostId;			
44    TSockHostStatus Status;
45    TStrV HostNmV;
46    TStrV IpNumV;
47  #ifdef GLib_WIN32
48    char HostEntBf[MAXGETHOSTSTRUCT]; 
49  #elif defined(GLib_UNIX)
50    addrinfo request;
51    gaicb GAI;
52  #endif
53    int SockEventId;
54    UndefCopyAssign(TSockHost);
55  private:
56  #ifdef GLib_WIN32
57    void GetFromHostEnt(const TSockHostStatus& Status, const hostent* HostEnt);
58  #elif defined(GLib_UNIX)
59    void GetFromHostEnt(const TSockHostStatus& Status, gaicb *gcb);
60  #endif
61  public:
62    TSockHost():
63      SockHostId(LastSockHostId++), Status(shsUndef), HostNmV(), IpNumV(), SockEventId(-1){}
64    TSockHost(const PSockEvent& SockEvent):
65      SockHostId(LastSockHostId++),
66      Status(shsUndef), HostNmV(), IpNumV(),
67      SockEventId(SockEvent->GetSockEventId()){}
68    TSockHost(TSIn&){Fail;}
69    ~TSockHost();
70    static PSockHost Load(TSIn&){Fail; return NULL;}
71    void Save(TSOut&){Fail;}
72    bool IsOk() const {return Status==shsOk;}
73    int GetStatus() const {return Status;}
74    int GetHostNms() const {return HostNmV.Len();}
75    TStr GetHostNm() const {
76      if (GetHostNms()==0){return GetIpNum();} else {return GetHostNm(0);}}
77    TStr GetHostNm(const int& HostNmN) const {return HostNmV[HostNmN];}
78    int GetIpNums() const {return IpNumV.Len();}
79    TStr GetIpNum(const int& IpNumN=0) const {return IpNumV[IpNumN];}
80    bool HasIpNum(const TStr &IpNum) const {return IpNumV.IsIn(IpNum);}
81    int GetSockEventId() const {return SockEventId;}
82    PSockEvent GetSockEvent() const;
83    static bool IsIpNum(const TStr& HostNm);
84    static TStr GetIpNum(const uint& IpNumN);
85    static PSockHost GetSyncSockHost(const TStr& HostNm);
86    static void GetAsyncSockHost(const TStr& HostNm, const PSockEvent& SockEvent);
87  #ifdef GLib_WIN32
88    static TSockHostStatus GetStatus(const int& ErrCd);
89  #elif defined(GLib_UNIX)
90    static TSockHostStatus GetStatus(gaicb* gcb);
91    static TStr GetGaiErrStr(const int ErrCd);
92    static TSockHostStatus SubmitQuery(const TStr &HostStr, gaicb *gcb, addrinfo *request, bool sync = true, uint32 EventId = 0);
93  #endif
94    static PSockHost GetLocalSockHost();
95    static const TStr LocalHostNm;
96    friend class TSockSys;
97  };
98  #ifdef GLib_WIN32
99  typedef SOCKET TSockHnd;
100  #elif defined(GLib_UNIX)
101  typedef int TSockHnd;
102  typedef enum { scsCreated, scsListening, scsConnected } TSockConnState;
103  #endif
104  ClassTP(TSock, PSock)
105  private:
106    static int LastSockId;
107    int SockId;
108    TSockHnd SockHnd;
109    int SockEventId;
110    TMem UnsentBf;
111    UndefDefaultCopyAssign(TSock);
112  public:
113    TSock(const PSockEvent& SockEvent);
114    static PSock New(const PSockEvent& SockEvent){
115      return PSock(new TSock(SockEvent));}
116    TSock(const TSockHnd& _SockHnd, const PSockEvent& SockEvent);
117    ~TSock();
118    TSock(TSIn&){Fail;}
119    static PSock Load(TSIn&){Fail; return NULL;}
120    void Save(TSOut&){Fail;}
121    int GetSockId() const {return SockId;}
122    TSockHnd GetSockHnd() const {return SockHnd;}
123    int GetSockEventId() const {return SockEventId;}
<span onclick='openModal()' class='match'>124    PSockEvent GetSockEvent() const;
125    bool IsUnsent() const {return UnsentBf.Len()>0;}
126    int GetUnsentLen() const {return UnsentBf.Len();}
</span>127    void Listen(const int& PortN);
128    int GetPortAndListen(const int& MnPortN);
129    void Connect(const PSockHost& SockHost, const int& PortN);
130    void Send(const PSIn& SIn, bool& Ok, int& ErrCd);
131    void Send(const PSIn& SIn);
132    void SendSafe(const PSIn& SIn);
133    TStr GetPeerIpNum() const;
134    TStr GetLocalIpNum() const;
135    void PutTimeOut(const int& MSecs);
136    void DelTimeOut();
137    static PSock Accept(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
138  #ifdef GLib_UNIX
139    static int GetSockErr(const TSockHnd s);
140  #endif
141    static TStr GetSockSysStatusStr();
142    static uint64 GetSockSysBytesRead();
143    static uint64 GetSockSysBytesWritten();
144    static bool IsSockId(const int& SockId);
145  };
146  ClassTP(TReportEvent, PReportEvent)
147  private:
148    static int LastReportEventId;
149    int ReportEventId;
150    UndefCopyAssign(TReportEvent);
151  public:
152    TReportEvent(): ReportEventId(++LastReportEventId){}
153    virtual ~TReportEvent(){}
154    TReportEvent(TSIn&){Fail;}
155    static PReportEvent Load(TSIn&){Fail; return NULL;}
156    void Save(TSOut&){Fail;}
157    int GetReportEventId(){return ReportEventId;}
158    void SendReport();
159    virtual void OnReport(){}
160  };
161  ClassTP(TTTimer, PTimer)
162  private:
163    static int LastTimerId;
164    int TimerId;
165  #ifdef GLib_WIN32
166    uint TimerHnd;
167  #elif defined(GLib_UNIX)
168    timer_t TimerHnd;
169  #endif
170    int TimeOut;
171    int Ticks;
172    TSecTm StartTm;
173  public:
174    TTTimer(const int& _TimeOut=0);
175    virtual ~TTTimer();
176    TTTimer(TSIn&){Fail;}
177    static PTimer Load(TSIn&){Fail; return NULL;}
178    void Save(TSOut&){Fail;}
179    TTTimer& operator=(const TTTimer&){Fail; return *this;}
180    int GetTimerId() const {return TimerId;}
181    int GetTimeOut() const {return TimeOut;}
182    void StartTimer(const int& _TimeOut=-1);
183    void StopTimer();
184    void IncTicks() {
185  #ifdef GLib_WIN32
186      Ticks++;
187  #elif defined(GLib_UNIX)
188      Ticks += 1 + timer_getoverrun(TimerHnd);
189  #endif
190    }
191    int GetTicks() const {return Ticks;}
192    int GetSecs() const {
193      return TSecTm::GetDSecs(StartTm, TSecTm::GetCurTm());}
194    virtual void OnTimeOut(){}
195  };
196  typedef TAPt<TTTimer> ATimer;
197  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.h</h3>
            <pre><code>1  #ifndef snap_kronecker_h
2  #define snap_kronecker_h
3  #include "Snap.h"
4  class TKroneckerLL;
5  typedef TPt<TKroneckerLL> PKroneckerLL;
6  class TKronMtx {
7  public:
8    static const double NInf;
9    static TRnd Rnd;
10  private:
11    TInt MtxDim;
12    TFltV SeedMtx;
13  public:
14    TKronMtx() : MtxDim(-1), SeedMtx() { }
15    TKronMtx(const int& Dim) : MtxDim(Dim), SeedMtx(Dim*Dim) { }
16    TKronMtx(const TFltV& SeedMatrix);
17    TKronMtx(const TKronMtx& Kronecker) : MtxDim(Kronecker.MtxDim), SeedMtx(Kronecker.SeedMtx) { }
18    void SaveTxt(const TStr& OutFNm) const;
19    TKronMtx& operator = (const TKronMtx& Kronecker);
<span onclick='openModal()' class='match'>20    bool operator == (const TKronMtx& Kronecker) const { return SeedMtx==Kronecker.SeedMtx; }
21    int GetPrimHashCd() const { return SeedMtx.GetPrimHashCd(); }
</span>22    int GetSecHashCd() const { return SeedMtx.GetSecHashCd(); }
23    int GetDim() const { return MtxDim; }
24    int Len() const { return SeedMtx.Len(); }
25    bool Empty() const { return SeedMtx.Empty(); }
26    bool IsProbMtx() const; 
27    TFltV& GetMtx() { return SeedMtx; }
28    const TFltV& GetMtx() const { return SeedMtx; }
29    void SetMtx(const TFltV& ParamV) { SeedMtx = ParamV; }
30    void SetRndMtx(const int& MtxDim, const double& MinProb = 0.0);
31    void PutAllMtx(const double& Val) { SeedMtx.PutAll(Val); }
32    void GenMtx(const int& Dim) { MtxDim=Dim;  SeedMtx.Gen(Dim*Dim); }
33    void SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val=1, const int& Eps0Val=0);
34    void SetForEdges(const int& Nodes, const int& Edges); 
35    void AddRndNoise(const double& SDev);
36    TStr GetMtxStr() const;
37    const double& At(const int& Row, const int& Col) const { return SeedMtx[MtxDim*Row+Col].Val; }
38    double& At(const int& Row, const int& Col) { return SeedMtx[MtxDim*Row+Col].Val; }
39    const double& At(const int& ValN) const { return SeedMtx[ValN].Val; }
40    double& At(const int& ValN) { return SeedMtx[ValN].Val; }
41    int GetNodes(const int& NIter) const;
42    int GetEdges(const int& NIter) const;
43    int GetKronIter(const int& Nodes) const;
44    int GetNZeroK(const PNGraph& Graph) const; 
45    double GetEZero(const int& Edges, const int& KronIter) const;
46    double GetMtxSum() const;
47    double GetRowSum(const int& RowId) const;
48    double GetColSum(const int& ColId) const;
49    void ToOneMinusMtx();
50    void GetLLMtx(TKronMtx& LLMtx);
51    void GetProbMtx(TKronMtx& ProbMtx);
52    void Swap(TKronMtx& KronMtx);
53    double GetEdgeProb(int NId1, int NId2, const int& NKronIters) const; 
54    double GetNoEdgeProb(int NId1, int NId2, const int& NKronIters) const; 
55    double GetEdgeLL(int NId1, int NId2, const int& NKronIters) const; 
56    double GetNoEdgeLL(int NId1, int NId2, const int& NKronIters) const; 
57    double GetApxNoEdgeLL(int NId1, int NId2, const int& NKronIters) const; 
58    bool IsEdgePlace(int NId1, int NId2, const int& NKronIters, const double& ProbTresh) const; 
59    double GetEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
60    double GetNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
61    double GetApxNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
62    static uint GetNodeSig(const double& OneProb = 0.5);
63    double GetEdgeProb(const uint& NId1Sig, const uint& NId2Sig, const int& NIter) const;
64    PNGraph GenThreshGraph(const double& Thresh) const;
65    PNGraph GenRndGraph(const double& RndFact=1.0) const;
66    static int GetKronIter(const int& GNodes, const int& SeedMtxSz);
67    static PNGraph GenKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir, const int& Seed=0);
68    static PNGraph GenFastKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir, const int& Seed=0);
69    static PNGraph GenFastKronecker(const TKronMtx& SeedMtx, const int& NIter, const int& Edges, const bool& IsDir, const int& Seed=0);
70    static PNGraph GenDetKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir);
71    static void PlotCmpGraphs(const TKronMtx& SeedMtx, const PNGraph& Graph, const TStr& OutFNm, const TStr& Desc);
72    static void PlotCmpGraphs(const TKronMtx& SeedMtx1, const TKronMtx& SeedMtx2, const PNGraph& Graph, const TStr& OutFNm, const TStr& Desc);
73    static void PlotCmpGraphs(const TVec<TKronMtx>& SeedMtxV, const PNGraph& Graph, const TStr& FNmPref, const TStr& Desc);
74    static void KronMul(const TKronMtx& LeftPt, const TKronMtx& RightPt, TKronMtx& OutMtx);
75    static void KronSum(const TKronMtx& LeftPt, const TKronMtx& RightPt, TKronMtx& OutMtx); 
76    static void KronPwr(const TKronMtx& KronPt, const int& NIter, TKronMtx& OutMtx);
77    void Dump(const TStr& MtxNm = TStr(), const bool& Sort = false) const;
78    static double GetAvgAbsErr(const TKronMtx& Kron1, const TKronMtx& Kron2); 
79    static double GetAvgFroErr(const TKronMtx& Kron1, const TKronMtx& Kron2); 
80    static TKronMtx GetMtx(TStr MatlabMtxStr);
81    static TKronMtx GetRndMtx(const int& Dim, const double& MinProb);
82    static TKronMtx GetInitMtx(const int& Dim, const int& Nodes, const int& Edges);
83    static TKronMtx GetInitMtx(const TStr& MtxStr, const int& Dim, const int& Nodes, const int& Edges);
84    static TKronMtx GetMtxFromNm(const TStr& MtxNm);
85    static TKronMtx LoadTxt(const TStr& MtxFNm);
86    static void PutRndSeed(const int& Seed) { TKronMtx::Rnd.PutSeed(Seed); }
87  };
88  enum TKronEMType {  kronNodeMiss = 0, kronFutureLink, kronEdgeMiss }; 
89  class TKroneckerLL {
90  public:
91  private:
92    TCRef CRef;
93    PNGraph Graph;         
94    TInt Nodes, KronIters;
95    TFlt PermSwapNodeProb; 
96    TIntTrV GEdgeV;        
97    TIntTrV LEdgeV;        
98    TInt LSelfEdge;        
99    TIntV NodePerm;        
100    TIntV InvertPerm;      
101    TInt RealNodes;	
102    TInt RealEdges;	
103    TKronMtx ProbMtx, LLMtx; 
104    TFlt LogLike; 
105    TFltV GradV;  
106    TKronEMType EMType;	
107    TInt MissEdges;		
108    TBool DebugMode;		
109    TFltV LLV;			
110    TVec<TKronMtx> MtxV;	
111  public:
112    TKroneckerLL() : Nodes(-1), KronIters(-1), PermSwapNodeProb(0.2), RealNodes(-1), RealEdges(-1), LogLike(TKronMtx::NInf), EMType(kronNodeMiss), MissEdges(-1), DebugMode(false) { }
113    TKroneckerLL(const PNGraph& GraphPt, const TFltV& ParamV, const double& PermPSwapNd=0.2);
114    TKroneckerLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const double& PermPSwapNd=0.2);
115    TKroneckerLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const TIntV& NodeIdPermV, const double& PermPSwapNd=0.2);
116    static PKroneckerLL New() { return new TKroneckerLL(); }
117    static PKroneckerLL New(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const double& PermPSwapNd=0.1);
118    static PKroneckerLL New(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const TIntV& NodeIdPermV, const double& PermPSwapNd=0.2);
119    int GetNodes() const { return Nodes; }
120    int GetKronIters() const { return KronIters; }
121    PNGraph GetGraph() const { return Graph; }
122    void SetGraph(const PNGraph& GraphPt);
123    const TKronMtx& GetProbMtx() const { return ProbMtx; }
124    const TKronMtx& GetLLMtx() const { return LLMtx; }
125    int GetParams() const { return ProbMtx.Len(); }
126    int GetDim() const { return ProbMtx.GetDim(); }
127    void SetDebug(const bool Debug) { DebugMode = Debug; }
128    const TFltV& GetLLHist() const { return LLV; }
129    const TVec<TKronMtx>& GetParamHist() const { return MtxV; }
130    bool IsObsNode(const int& NId) const { IAssert(RealNodes > 0);	return (NId < RealNodes);	}
131    bool IsObsEdge(const int& NId1, const int& NId2) const { IAssert(RealNodes > 0);	return ((NId1 < RealNodes) && (NId2 < RealNodes));	}
132    bool IsLatentNode(const int& NId) const { return !IsObsNode(NId);	}
133    bool IsLatentEdge(const int& NId1, const int& NId2) const { return !IsObsEdge(NId1, NId2);	}
134    void SetPerm(const char& PermId);
135    void SetOrderPerm(); 
136    void SetRndPerm();   
137    void SetDegPerm();   
138    void SetBestDegPerm();	
139    void SetPerm(const TIntV& NodePermV) { NodePerm = NodePermV; SetIPerm(NodePerm); }
140    void SetIPerm(const TIntV& Perm);	
141    const TIntV& GetPermV() const { return NodePerm; }
142    void AppendIsoNodes();
143    void RestoreGraph(const bool RestoreNodes = true);
144    double GetFullGraphLL() const;
145    double GetFullRowLL(int RowId) const;
146    double GetFullColLL(int ColId) const;
147    double GetEmptyGraphLL() const;
148    double GetApxEmptyGraphLL() const;
149    void InitLL(const TFltV& ParamV);
150    void InitLL(const TKronMtx& ParamMtx);
151    void InitLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx);
152    double CalcGraphLL();
153    double CalcApxGraphLL();
154    double GetLL() const { return LogLike; }
155    double GetAbsErr() const { return fabs(pow((double)Graph->GetEdges(), 1.0/double(KronIters)) - ProbMtx.GetMtxSum()); }
156    double NodeLLDelta(const int& NId) const;
157    double SwapNodesLL(const int& NId1, const int& NId2);
158    bool SampleNextPerm(int& NId1, int& NId2); 
159    double GetEmptyGraphDLL(const int& ParamId) const;
160    double GetApxEmptyGraphDLL(const int& ParamId) const;
161    const TFltV& CalcGraphDLL();
162    const TFltV& CalcFullApxGraphDLL();
163    const TFltV& CalcApxGraphDLL();
164    double NodeDLLDelta(const int ParamId, const int& NId) const;
165    void UpdateGraphDLL(const int& SwapNId1, const int& SwapNId2);
166    const TFltV& GetDLL() const { return GradV; }
167    double GetDLL(const int& ParamId) const { return GradV[ParamId]; }
168    void SampleGradient(const int& WarmUp, const int& NSamples, double& AvgLL, TFltV& GradV);
169    double GradDescent(const int& NIter, const double& LrnRate, double MnStep, double MxStep, const int& WarmUp, const int& NSamples);
170    double GradDescent2(const int& NIter, const double& LrnRate, double MnStep, double MxStep, const int& WarmUp, const int& NSamples);
171    void SetRandomEdges(const int& NEdges, const bool isDir = true);
172    void MetroGibbsSampleSetup(const int& WarmUp);
173    void MetroGibbsSampleNext(const int& WarmUp, const bool DLLUpdate = false);
174    void RunEStep(const int& GibbsWarmUp, const int& WarmUp, const int& NSamples, TFltV& LLV, TVec<TFltV>& DLLV);
175    double RunMStep(const TFltV& LLV, const TVec<TFltV>& DLLV, const int& GradIter, const double& LrnRate, double MnStep, double MxStep);
176    void RunKronEM(const int& EMIter, const int& GradIter, double LrnRate, double MnStep, double MxStep, const int& GibbsWarmUp, const int& WarmUp, const int& NSamples, const TKronEMType& Type = kronNodeMiss, const int& NMissing = -1);
177    TFltV TestSamplePerm(const TStr& OutFNm, const int& WarmUp, const int& NSamples, const TKronMtx& TrueMtx, const bool& DoPlot=true);
178    static double CalcChainR2(const TVec<TFltV>& ChainLLV);
179    static void ChainGelmapRubinPlot(const TVec<TFltV>& ChainLLV, const TStr& OutFNm, const TStr& Desc);
180    TFltQu TestKronDescent(const bool& DoExact, const bool& TruePerm, double LearnRate, const int& WarmUp, const int& NSamples, const TKronMtx& TrueParam);
181    void GradDescentConvergence(const TStr& OutFNm, const TStr& Desc1, const bool& SamplePerm, const int& NIters,
182      double LearnRate, const int& WarmUp, const int& NSamples, const int& AvgKGraphs, const TKronMtx& TrueParam);
183    static void TestBicCriterion(const TStr& OutFNm, const TStr& Desc1, const PNGraph& G, const int& GradIters,
184      double LearnRate, const int& WarmUp, const int& NSamples, const int& TrueN0);
185    static void TestGradDescent(const int& KronIters, const int& KiloSamples, const TStr& Permutation);
186    friend class TPt<TKroneckerLL>;
187  };
188  class TKronNoise {
189  public:
190  	TKronNoise() {};
191  	static int RemoveNodeNoise(PNGraph& Graph, const int& NNodes, const bool Random = true);
192  	static int RemoveNodeNoise(PNGraph& Graph, const double& Rate, const bool Random = true);
193  	static int FlipEdgeNoise(PNGraph& Graph, const int& NEdges, const bool Random = true);
194  	static int FlipEdgeNoise(PNGraph& Graph, const double& Rate, const bool Random = true);
195  	static int RemoveEdgeNoise(PNGraph& Graph, const int& NEdges);
196  	static int RemoveEdgeNoise(PNGraph& Graph, const double& Rate);
197  };
198  class TKronMaxLL {
199  public:
200    class TFEval {
201    public:
202      TFlt LogLike;
203      TFltV GradV;
204    public:
205      TFEval() : LogLike(0), GradV() { }
206      TFEval(const TFlt& LL, const TFltV& DLL) : LogLike(LL), GradV(DLL) { }
207      TFEval(const TFEval& FEval) : LogLike(FEval.LogLike), GradV(FEval.GradV) { }
208      TFEval& operator = (const TFEval& FEval) { if (this!=&FEval) {
209        LogLike=FEval.LogLike; GradV=FEval.GradV; } return *this; }
210    };
211  private:
212    THash<TKronMtx, TFEval> FEvalH; 
213    TKroneckerLL KronLL;
214  public:
215    TKronMaxLL(const PNGraph& GraphPt, const TKronMtx& StartParam) : KronLL(GraphPt, StartParam) { }
216    void SetPerm(const char& PermId);
217    void GradDescent(const int& NIter, const double& LrnRate, const double& MnStep, const double& MxStep,
218      const double& WarmUp, const double& NSamples);
219    static void RoundTheta(const TFltV& ThetaV, TFltV& NewThetaV);
220    static void RoundTheta(const TFltV& ThetaV, TKronMtx& Kronecker);
221    static void Test();
222  };
223  class TKronMomentsFit {
224  public:
225    double Edges, Hairpins, Tripins, Triads;
226  public:
227    TKronMomentsFit(const PUNGraph& G) {
228      Edges=0; Hairpins=0; Tripins=0; Triads=0;
229      for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
230        const int d = NI.GetOutDeg();
231        Edges += d;
232        Hairpins += d*(d-1.0);
233        Tripins += d*(d-1.0)*(d-2.0);
234      }
235      Edges /= 2.0;
236      Hairpins /= 2.0;
237      Tripins /= 6.0;
238      int64 ot,ct;
239      Triads = (int) TSnap::GetTriads(G, ot, ct)/3.0;
240      printf("E:%g\tH:%g\tT:%g\tD:%g\n", Edges, Hairpins, Tripins, Triads);
241    }
242    TFltQu EstABC(const int& R) {
243      const double Step = 0.01;
244      double MinScore=TFlt::Mx;
245      double A=0, B=0, C=0;
246      for (double a = 1.0; a > Step; a-=Step) {
247        for (double b = Step; b <= 1.0; b+=Step) {
248          for (double c = Step; c <= a; c+=Step) {
249            double EE = ( pow(a+2*b+c, R) - pow(a+c, R) ) / 2.0;
250            double EH = ( pow(pow(a+b,2) + pow(b+c,2), R)
251                               -2*pow(a*(a+b)+c*(c+b), R)
252                               -pow(a*a + 2*b*b + c*c, R)
253                               +2*pow(a*a + c*c, R) ) / 2.0;
254            double ET = ( pow(pow(a+b,3)+pow(b+c,3), R)
255                               -3*pow(a*pow(a+b,2)+c*pow(b+c,2), R)
256                               -3*pow(a*a*a + c*c*c + b*(a*a+c*c) + b*b*(a+c) + 2*b*b*b ,R)
257                               +2*pow(a*a*a + 2*b*b*b + c*c*c, R)
258                               +5*pow(a*a*a + c*c*c + b*b*(a+c), R)
259                               +4*pow(a*a*a + c*c*c + b*(a*a+c*c), R)
260                               -6*pow(a*a*a + c*c*c, R) ) / 6.0;
261            double ED = ( pow(a*a*a + 3*b*b*(a+c) + c*c*c, R)
262                               -3*pow(a*(a*a+b*b) + c*(b*b+c*c), R)
263                               +2*pow(a*a*a+c*c*c, R) ) / 6.0;
264            if (EE < 0) { EE = 1; }
265            if (EH < 0) { EH = 1; }
266            if (ET < 0) { ET = 1; }
267            if (ED < 0) { ED = 1; }
268            double Score = pow(Edges-EE,2)/EE + pow(Hairpins-EH ,2)/EH + pow(Tripins-ET, 2)/ET + pow(Triads-ED, 2)/ED;
269            if (MinScore > Score || (a==0.9 && b==0.6 && c==0.2) || (TMath::IsInEps(a-0.99,1e-6) && TMath::IsInEps(b-0.57,1e-6) && TMath::IsInEps(c-0.05,1e-6)))
270            {
271              printf("%.03f %.03f %0.03f %10.4f  %10.10g\t%10.10g\t%10.10g\t%10.10g\n", a,b,c, log10(Score), EE, EH, ET, ED);
272              A=a; B=b; C=c; MinScore=Score;
273            }
274          }
275        }
276      }
277      printf("\t\t\t      %10.10g\t%10.10g\t%10.10g\t%10.10g\n", Edges, Hairpins, Tripins, Triads);
278      return TFltQu(A,B,C,MinScore);
279    }
280    static void Test() {
281      TFIn FIn("as20.ngraph");
282      PUNGraph G = TSnap::ConvertGraph<PUNGraph>(TNGraph::Load(FIn));
283      TSnap::PrintInfo(G);
284      TSnap::DelSelfEdges(G);
285      TSnap::PrintInfo(G);
286      TKronMomentsFit Fit(G);
287      printf("iter %d\n", TKronMtx::GetKronIter(G->GetNodes(), 2));
288      Fit.EstABC(TKronMtx::GetKronIter(G->GetNodes(), 2)); /&bsol;*/
289    }
290  };
291  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock-new.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.h</div>
                </div>
                <div class="column column_space"><pre><code>124    PSockEvent GetSockEvent() const;
125    bool IsUnsent() const {return UnsentBf.Len()>0;}
126    int GetUnsentLen() const {return UnsentBf.Len();}
</pre></code></div>
                <div class="column column_space"><pre><code>20    bool operator == (const TKronMtx& Kronecker) const { return SeedMtx==Kronecker.SeedMtx; }
21    int GetPrimHashCd() const { return SeedMtx.GetPrimHashCd(); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    