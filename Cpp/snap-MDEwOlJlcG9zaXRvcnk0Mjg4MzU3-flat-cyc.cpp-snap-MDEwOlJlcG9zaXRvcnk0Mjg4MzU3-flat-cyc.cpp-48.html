
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</h3>
            <pre><code>1  #include &quot;cyc.h&quot;
2  TStr TCycVrtx::GetCycVrtxFlagStr(const TCycVrtxFlag&amp; CycVrtxFlag){
3    switch (CycVrtxFlag){
4      case cvfUndef: return &quot;Undef&quot;;
5      case cvfNum: return &quot;Num&quot;;
6      case cvfStr: return &quot;Str&quot;;
7      case cvfCycL: return &quot;CycL&quot;;
8      case cvfCycLConst: return &quot;CycLConst&quot;; 
9      case cvfCycLExpr: return &quot;CycLExpr&quot;;
10      case cvfCycLPred: return &quot;CycLPred&quot;;
11      case cvfBackLink: return &quot;BackLink&quot;;
12      case cvfHumanOk: return &quot;HumanOk&quot;;
13      case cvfHumanRelevant: return &quot;HumanRelevant&quot;;
14      case cfvHumanIrrelevant: return &quot;HumanIrrelevant&quot;;
15      case cfvHumanClarifying: return &quot;HumanClarifying&quot;;
16      default: Fail; return &quot;&quot;;
17    }
18  }
19  TStr TCycVrtx::GetFlagStr() const {
20    TChA ChA;
21    ChA+=&#x27;[&#x27;;
22    for (int FlagId=cvfMn; FlagId&lt;cvfMx; FlagId++){
23      if (IsFlag(FlagId)){
24        if (ChA.Len()&gt;1){ChA+=&#x27; &#x27;;}
25        ChA+=GetCycVrtxFlagStr(TCycVrtxFlag(FlagId));
26      }
27    }
28    ChA+=&#x27;]&#x27;;
29    return ChA;
30  }
31  int TCycBs::AddVNm(const TStr&amp; VNm){
32    int VId;
33    if (VNmToVrtxH.IsKey(VNm.CStr(), VId)){
34      return VId;
35    } else {
36      VId=VNmToVrtxH.AddKey(VNm);
37      TCycVrtx&amp; Vrtx=VNmToVrtxH[VId];
38      Vrtx.PutVId(VId);
39      if (VNm.IsPrefix(&quot;~&quot;)){
40        Vrtx.SetFlag(cvfBackLink);
41      } else
42      if (VNm.IsPrefix(&quot;#$&quot;)&amp;&amp;(!VNm.IsChIn(&#x27; &#x27;))){
43        Vrtx.SetFlag(cvfCycL);
44        if (VNm.Len()&gt;2){
45          char Ch=VNm[2];
46          if ((&#x27;a&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;z&#x27;)){
47            Vrtx.SetFlag(cvfCycLPred);
48          } else {
49            Vrtx.SetFlag(cvfCycLConst);
50          }
51        }
52      } else
53      if (VNm.IsPrefix(&quot;(#$&quot;)){
54        Vrtx.SetFlag(cvfCycL);
55        Vrtx.SetFlag(cvfCycLExpr);
56      } else {
57        if (VNm.IsFlt()){
58          Vrtx.SetFlag(cvfNum);
59        } else {
60          Vrtx.SetFlag(cvfStr);
61        }
62      }
63      return VId;
64    }
65  }
66  void TCycBs::GetRelNmV(TStrV&amp; RelNmV){
67    TStrH RelNmH;
68    for (int VId=0; VId&lt;GetVIds(); VId++){
69      TStr VNm=GetVNm(VId);
70      TCycVrtx&amp; Vrtx=GetVrtx(VId);
71      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
72        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
73        TStr RelNm=GetVNm(Edge.GetRelId());
74        RelNmH.AddKey(RelNm);
75      }
76    }
77    RelNmH.GetKeyV(RelNmV);
78  }
79  TStr TCycBs::GetDocStrFromCycLConstStr(const TStr&amp; CycLConstStr){
80    TChA ChA=CycLConstStr;
81    TChA DstChA;
82    if ((ChA.Len()&gt;2)&amp;&amp;(ChA[0]==&#x27;#&#x27;)&amp;&amp;(ChA[1]==&#x27;$&#x27;)){
83      int ChN=2;
84      while (ChN&lt;ChA.Len()){
85        if (DstChA.Len()&gt;0){DstChA+=&#x27; &#x27;;}
86        if ((ChA[ChN]==&#x27;-&#x27;)||(ChA[ChN]==&#x27;_&#x27;)||(ChA[ChN]==&#x27;:&#x27;)){
87          DstChA+=&quot;-&quot;; ChN++;
88        } else
89        if ((&#x27;0&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;9&#x27;)){
90          do {
91            DstChA+=ChA[ChN]; ChN++;
92          } while ((ChN&lt;ChA.Len())&amp;&amp;(&#x27;0&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;9&#x27;));
93        } else
94        if ((&#x27;a&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;z&#x27;)){
95          do {
96            DstChA+=ChA[ChN]; ChN++;
97          } while ((ChN&lt;ChA.Len())&amp;&amp;(&#x27;a&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;z&#x27;));
98        } else
99        if ((&#x27;A&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;Z&#x27;)){
100          if ((ChN+1&lt;ChA.Len())&amp;&amp;(&#x27;a&#x27;&lt;=ChA[ChN+1])&amp;&amp;(ChA[ChN+1]&lt;=&#x27;z&#x27;)){
101            do {
102              DstChA+=ChA[ChN]; ChN++;
103            } while ((ChN&lt;ChA.Len())&amp;&amp;(&#x27;a&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;z&#x27;));
104          } else {
105            do {
106              DstChA+=ChA[ChN]; ChN++;
107            } while (((ChN==ChA.Len()-1)&amp;&amp;(&#x27;A&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;Z&#x27;))||
108              ((ChN+1&lt;ChA.Len())&amp;&amp;(&#x27;A&#x27;&lt;=ChA[ChN+1])&amp;&amp;(ChA[ChN+1]&lt;=&#x27;Z&#x27;)));
109          }
110        } else {
111          DstChA=&quot;&quot;; break;
112        }
113      }
114    } else {
115      DstChA=&quot;&quot;;
116    }
117    return DstChA;
118  }
119  PLwOnto TCycBs::LoadCycVoc(const TStr&amp; CycBsFNm, const bool&amp; HumanOkOnlyP){
120    printf(&quot;Loading Cyc-Base from Binary-File &#x27;%s&#x27; ... &quot;, CycBsFNm.CStr());
121    PCycBs CycBs=TCycBs::LoadBin(CycBsFNm);
122    int VIds=CycBs-&gt;GetVIds();
123    printf(&quot;Done.\n&quot;);
124    PLwOnto LwOnto=TLwOnto::New();
125    int EnLangId=LwOnto-&gt;GetLangBs()-&gt;AddLang(&quot;EN&quot;, &quot;English&quot;);
126    PLwTermType C_TermType=TLwTermType::New(0, &quot;Class&quot;, EnLangId);
127    PLwTermType L_TermType=TLwTermType::New(1, &quot;Lexical&quot;, EnLangId);
128    int C_TermTypeId=LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(C_TermType);
129    int L_TermTypeId=LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(L_TermType);
130    {printf(&quot;Creating link-types ...&quot;);
131    TStrV RelNmV; CycBs-&gt;GetRelNmV(RelNmV);
132    for (int RelNmN=0; RelNmN&lt;RelNmV.Len(); RelNmN++){
133      TStr RelNm=RelNmV[RelNmN];
134      if (RelNm[0]==&#x27;~&#x27;){continue;}
135      PLwLinkType LinkType=TLwLinkType::New(RelNmN, RelNm, EnLangId, &quot;&quot;);
136      LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(LinkType);
137    }
138    printf(&quot; Done. (%d)\n&quot;, LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypes());}
139    {printf(&quot;Creating terms ...\n&quot;);
140    for (int VId=0; VId&lt;VIds; VId++){
141      if (VId%1000==0){printf(&quot;%d/%d\r&quot;, VId, VIds);}
142      TCycVrtx&amp; Vrtx=CycBs-&gt;GetVrtx(VId);
143      if (Vrtx.IsFlag(cvfCycLPred)){continue;}
144      if ((!Vrtx.IsFlag(cvfStr))&amp;&amp;
145       (HumanOkOnlyP&amp;&amp;(!Vrtx.IsFlag(cvfHumanOk)))){continue;}
146      TStr VNm=CycBs-&gt;GetVNm(VId);
147      int TermTypeId=(Vrtx.IsFlag(cvfStr)) ? L_TermTypeId : C_TermTypeId;
148      PLwTerm Term=TLwTerm::New(VId, VNm, EnLangId, TermTypeId);
149      LwOnto-&gt;GetTermBs()-&gt;AddTerm(Term);
150    }
151    printf(&quot;Done. (%d)\n&quot;, LwOnto-&gt;GetTermBs()-&gt;GetTerms());}
152    {printf(&quot;Creating links ...\n&quot;);
153    for (int VId=0; VId&lt;VIds; VId++){
154      if (VId%1000==0){printf(&quot;%d/%d\r&quot;, VId, VIds);}
155      if (!LwOnto-&gt;GetTermBs()-&gt;IsTermId(VId)){continue;}
156      TCycVrtx&amp; Vrtx=CycBs-&gt;GetVrtx(VId);
157      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
158        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
159        int DstVId=Edge.GetDstVId();
160        if (!LwOnto-&gt;GetTermBs()-&gt;IsTermId(DstVId)){continue;}
161        TStr RelNm=CycBs-&gt;GetVNm(Edge.GetRelId());
162        if (LwOnto-&gt;GetLinkTypeBs()-&gt;IsLinkType(RelNm, EnLangId)){
163          int LinkTypeId=LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypeId(RelNm, EnLangId);
164          LwOnto-&gt;GetLinkBs()-&gt;AddLink(VId, LinkTypeId, DstVId);
165        }
166      }
167    }
168    printf(&quot;Done. (%d)\n&quot;, LwOnto-&gt;GetLinkBs()-&gt;GetLinks());}
169    return LwOnto;
170  }
171  void TCycBs::SaveTxt(const TStr&amp; FNm){
172    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
173    for (int VId=0; VId&lt;GetVIds(); VId++){
174      TStr VNm=GetVNm(VId);
175      TCycVrtx&amp; Vrtx=GetVrtx(VId);
176      TStr FlagStr=Vrtx.GetFlagStr();
177      fprintf(fOut, &quot;(%d) %s - %s\n&quot;, VId, VNm.CStr(), FlagStr.CStr());
178      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
179        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
<span onclick='openModal()' class='match'>180        TStr RelNm=GetVNm(Edge.GetRelId());
181        TStr DstVNm=GetVNm(Edge.GetDstVId());
182        fprintf(fOut, &quot;     %d. [%s] --&gt; %s\n&quot;, 1+EdgeN, RelNm.CStr(), DstVNm.CStr());
</span>183      }
184    }
185  }
186  void TCycBs::_SaveTaxonomyTxt(FILE* fOut, 
187   const int&amp; Lev, TIntPrV&amp; RelIdVIdPrV, TIntIntH&amp; VIdToLevH){
188    for (int VidN=0; VidN&lt;RelIdVIdPrV.Len(); VidN++){
189      int FromRelId=RelIdVIdPrV[VidN].Val1;
190      int SrcVId=RelIdVIdPrV[VidN].Val2;
191      TStr SrcVNm=GetVNm(SrcVId);
192      TCycVrtx&amp; SrcVrtx=GetVrtx(SrcVId);
193      if (!SrcVrtx.IsFlag(cvfHumanOk)){continue;}
194      TStr FlagStr=SrcVrtx.GetFlagStr();
195      if (FromRelId==-1){
196        if (Lev&gt;0){fprintf(fOut, &quot;===upper&quot;);} else {fprintf(fOut, &quot;===lower&quot;);}
197        fprintf(fOut, &quot;=======================================================\n&quot;);
198        fprintf(fOut, &quot;%s - %s\n&quot;, SrcVNm.CStr(), FlagStr.CStr());
199      } else {
200        TStr FromRelNm=GetVNm(FromRelId);
201        fprintf(fOut, &quot;%*c[%s] --&gt; %s\n&quot;, (Lev-1)*5, &#x27; &#x27;, FromRelNm.CStr(), SrcVNm.CStr());
202      }
203      TIntPrV UpRelIdVIdPrV;
204      for (int EdgeN=0; EdgeN&lt;SrcVrtx.GetEdges(); EdgeN++){
205        TCycEdge&amp; Edge=SrcVrtx.GetEdge(EdgeN);
206        int RelId=Edge.GetRelId();
207        int DstVId=Edge.GetDstVId();
208        TStr RelNm=GetVNm(RelId);
209        TStr DstVNm=GetVNm(DstVId);
210        if (Lev&gt;0){
211          if ((RelNm==&quot;#$isa&quot;)||(RelNm==&quot;#$genls&quot;)){
212            if (!VIdToLevH.IsKey(DstVId)){
213              VIdToLevH.AddDat(DstVId, Lev+1);
214              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
215            }
216          }
217        } else {
218          if ((RelNm==&quot;~#$isa&quot;)||(RelNm==&quot;~#$genls&quot;)){
219            if (!VIdToLevH.IsKey(DstVId)){
220              VIdToLevH.AddDat(DstVId, Lev-1);
221              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
222            }
223          }
224        }
225      } 
226      if (Lev&gt;0){
227        _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);
228      } else {
229        _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);
230      }
231    }
232  }
233  void TCycBs::SaveTaxonomyTxt(const TStr&amp; FNm){
234    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
235    for (int VId=0; VId&lt;GetVIds(); VId++){
236      printf(&quot;%d/%d (%.1f%%)\r&quot;, 1+VId, GetVIds(), 100.0*(1+VId)/GetVIds());
237      {int Lev=0;
238      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
239      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
240      _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);}
241      {int Lev=0;
242      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
243      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
244      _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);}
245    }
246    printf(&quot;\n&quot;);
247  }
248  void TCycBs::SaveStatTxt(const TStr&amp; FNm){
249    PMom CommentLenMom=TMom::New();
250    PMom StrsLenMom=TMom::New();
251    PMom HumanOk_StrsLenMom=TMom::New();
252    PMom ClassesPerStrMom=TMom::New();
253    PMom StrsPerClassMom=TMom::New();
254    PMom HumanOk_StrsPerClassMom=TMom::New();
255    PMom IsasPerClassMom=TMom::New();
256    PMom HumanOk_IsasPerClassMom=TMom::New();
257    PMom GenlsPerClassMom=TMom::New();
258    PMom HumanOk_GenlsPerClassMom=TMom::New();
259    PMom IsasGenlsPerClassMom=TMom::New();
260    PMom HumanOk_IsasGenlsPerClassMom=TMom::New();
261    int Classes=0;
262    int HumanOk_Classes=0;
263    int Comments=0;
264    int HumanOk_Comments=0;
265    for (int VId=0; VId&lt;GetVIds(); VId++){
266      TStr VNm=GetVNm(VId);
267      TCycVrtx&amp; Vrtx=GetVrtx(VId);
268      TStr FlagStr=Vrtx.GetFlagStr();
269      int StrsLen=0;
270      int ClassesPerStrInstance=0;
271      int NmStrs=0; int BackLinkNmStrs=0;
272      int Isas=0; int Genls=0;
273      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
274        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
275        TStr RelNm=GetVNm(Edge.GetRelId());
276        TStr DstVNm=GetVNm(Edge.GetDstVId());
277        TCycVrtx&amp; DstVrtx=GetVrtx(Edge.GetDstVId());
278        if (RelNm==&quot;#$comment&quot;){
279          CommentLenMom-&gt;Add(DstVNm.Len());
280          Comments++; 
281          if (Vrtx.IsFlag(cvfHumanOk)){HumanOk_Comments++;}
282        }
283        if (DstVrtx.IsFlag(cvfStr)){StrsLen+=DstVNm.Len();}
284        if (Vrtx.IsFlag(cvfStr)){ClassesPerStrInstance++;}
285        if (RelNm==&quot;#$nameString&quot;){NmStrs++;}
286        if (RelNm==&quot;~#$nameString&quot;){BackLinkNmStrs++;}
287        if (RelNm==&quot;#$isa&quot;){Isas++;}
288        if (RelNm==&quot;#$genls&quot;){Genls++;}
289      }
290      if (Vrtx.IsFlag(cvfCycL)){Classes++;}
291      if (Vrtx.IsFlag(cvfCycL)){StrsLenMom-&gt;Add(StrsLen);}
292      if (Vrtx.IsFlag(cvfStr)){ClassesPerStrMom-&gt;Add(BackLinkNmStrs);}
293      if (Vrtx.IsFlag(cvfCycL)){StrsPerClassMom-&gt;Add(NmStrs);}
294      if (Vrtx.IsFlag(cvfCycL)){IsasPerClassMom-&gt;Add(Isas);}
295      if (Vrtx.IsFlag(cvfCycL)){GenlsPerClassMom-&gt;Add(Genls);}
296      if (Vrtx.IsFlag(cvfCycL)){IsasGenlsPerClassMom-&gt;Add(Isas+Genls);}
297      if (Vrtx.IsFlag(cvfHumanOk)){
298        if (Vrtx.IsFlag(cvfCycL)){HumanOk_Classes++;}
299        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsLenMom-&gt;Add(StrsLen);}
300        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsPerClassMom-&gt;Add(NmStrs);}
301        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasPerClassMom-&gt;Add(Isas);}
302        if (Vrtx.IsFlag(cvfCycL)){HumanOk_GenlsPerClassMom-&gt;Add(Genls);}
303        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasGenlsPerClassMom-&gt;Add(Isas+Genls);}
304      }
305    }
306    CommentLenMom-&gt;Def();
307    StrsLenMom-&gt;Def();
308    HumanOk_StrsLenMom-&gt;Def();
309    ClassesPerStrMom-&gt;Def();
310    StrsPerClassMom-&gt;Def();
311    HumanOk_StrsPerClassMom-&gt;Def();
312    IsasPerClassMom-&gt;Def();
313    HumanOk_IsasPerClassMom-&gt;Def();
314    GenlsPerClassMom-&gt;Def();
315    HumanOk_GenlsPerClassMom-&gt;Def();
316    IsasGenlsPerClassMom-&gt;Def();
317    HumanOk_IsasGenlsPerClassMom-&gt;Def();
318    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
319    fprintf(fOut, &quot;CommentLen: %s\n&quot;, CommentLenMom-&gt;GetStr().CStr());
320    fprintf(fOut, &quot;StrsLen: %s\n&quot;, StrsLenMom-&gt;GetStr().CStr());
321    fprintf(fOut, &quot;HumanOk_StrsLen: %s\n&quot;, HumanOk_StrsLenMom-&gt;GetStr().CStr());
322    fprintf(fOut, &quot;ClassesPerStr: %s\n&quot;, ClassesPerStrMom-&gt;GetStr().CStr());
323    fprintf(fOut, &quot;StrsPerClass: %s\n&quot;, StrsPerClassMom-&gt;GetStr().CStr());
324    fprintf(fOut, &quot;HumanOk_StrsPerClass: %s\n&quot;, HumanOk_StrsPerClassMom-&gt;GetStr().CStr());
325    fprintf(fOut, &quot;IsasPerClass: %s\n&quot;, IsasPerClassMom-&gt;GetStr().CStr());
326    fprintf(fOut, &quot;HumanOk_IsasPerClass: %s\n&quot;, HumanOk_IsasPerClassMom-&gt;GetStr().CStr());
327    fprintf(fOut, &quot;GenlsPerClass: %s\n&quot;, GenlsPerClassMom-&gt;GetStr().CStr());
328    fprintf(fOut, &quot;HumanOk_GenlsPerClass: %s\n&quot;, HumanOk_GenlsPerClassMom-&gt;GetStr().CStr());
329    fprintf(fOut, &quot;IsasGenlsPerClass: %s\n&quot;, IsasGenlsPerClassMom-&gt;GetStr().CStr());
330    fprintf(fOut, &quot;HumanOk_IsasGenlsPerClass: %s\n&quot;, HumanOk_IsasGenlsPerClassMom-&gt;GetStr().CStr());
331    fprintf(fOut, &quot;Classes: %d\n&quot;, Classes);
332    fprintf(fOut, &quot;HumanOk_Classes: %d\n&quot;, HumanOk_Classes);
333    fprintf(fOut, &quot;Comments: %d\n&quot;, Comments);
334    fprintf(fOut, &quot;HumanOk_Comments: %d\n&quot;, HumanOk_Comments);
335    fprintf(fOut, &quot;End&quot;);}
336  }
337  PCycBs TCycBs::LoadCycXmlDump(const TStr&amp; FPath){
338    TStr NrFPath=TStr::GetNrFPath(FPath);
339    TStr CycLexiconFNm=NrFPath+&quot;lexicon-dump.xml&quot;;
340    TStr CycTaxonomyFNm=NrFPath+&quot;taxonomy-dump.xml&quot;;
341    TStr CycRelevanceFNm=NrFPath+&quot;relevance-dump.xml&quot;;
342    TStr CycKBaseFNm=NrFPath+&quot;kb-dump.xml&quot;;                                                 
343    PCycBs CycBs=TCycBs::New();
344    {printf(&quot;Processing Lexicon %s ...\n&quot;, CycLexiconFNm.CStr());
345    PSIn CycLexiconSIn=TFIn::New(CycLexiconFNm);
346    PXmlDoc XmlDoc; int XmlDocs=0;
347    TStr PrevCycWStr; TStr PrevCycLStr;
348    forever{
349      XmlDocs++; if (XmlDocs%1000==0){printf(&quot;%d Docs\r&quot;, XmlDocs);}
350      XmlDoc=TXmlDoc::LoadTxt(CycLexiconSIn);
351      if (!XmlDoc-&gt;IsOk()){
352        printf(&quot;%s - %s\n&quot;, PrevCycWStr.CStr(), PrevCycLStr.CStr());
353        Fail;
354      }
355      PXmlTok TopTok=XmlDoc-&gt;GetTok();
356      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
357      IAssert(TopTok-&gt;IsTag(&quot;word&quot;));
358      TStr CycWStr=TopTok-&gt;GetArgVal(&quot;string&quot;);
359      TStr CycLStr=TopTok-&gt;GetArgVal(&quot;cycl&quot;);
360      PrevCycWStr=CycWStr; PrevCycLStr;
361      CycBs-&gt;AddEdge(CycLStr, &quot;#$nameString&quot;, CycWStr);
362      CycBs-&gt;AddEdge(CycWStr, &quot;~#$nameString&quot;, CycLStr);
363    }
364    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
365    {printf(&quot;Processing Taxonomy %s ...\n&quot;, CycTaxonomyFNm.CStr());
366    PSIn CycTaxonomySIn=TFIn::New(CycTaxonomyFNm);
367    PXmlDoc XmlDoc; int XmlDocs=0;
368    TStr PrevSrcCycLStr;
369    forever{
370      XmlDocs++;
371      if (XmlDocs%1000==0){
372        printf(&quot;%d Docs\r&quot;, XmlDocs);}
373      XmlDoc=TXmlDoc::LoadTxt(CycTaxonomySIn);
374      if (!XmlDoc-&gt;IsOk()){
375        printf(&quot;%s\n&quot;, PrevSrcCycLStr.CStr());
376        Fail;
377      }
378      PXmlTok TopTok=XmlDoc-&gt;GetTok();
379      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
380      IAssert(TopTok-&gt;IsTag(&quot;term&quot;));
381      TStr SrcCycLStr=TopTok-&gt;GetArgVal(&quot;cycl&quot;);
382      PrevSrcCycLStr=SrcCycLStr;
383      for (int SubTokN=0; SubTokN&lt;TopTok-&gt;GetSubToks(); SubTokN++){
384        PXmlTok SubTok=TopTok-&gt;GetSubTok(SubTokN);
385        TStr DstCycLStr=SubTok-&gt;GetTagNm();
386        if (SubTok-&gt;IsTag(&quot;isa&quot;)){
387          DstCycLStr=SubTok-&gt;GetArgVal(&quot;value&quot;);
388          CycBs-&gt;AddEdge(SrcCycLStr, &quot;#$isa&quot;, DstCycLStr);
389          CycBs-&gt;AddEdge(DstCycLStr, &quot;~#$isa&quot;, SrcCycLStr);
390        } else
391        if (SubTok-&gt;IsTag(&quot;genl&quot;)){
392          DstCycLStr=SubTok-&gt;GetArgVal(&quot;value&quot;);
393          CycBs-&gt;AddEdge(SrcCycLStr, &quot;#$genls&quot;, DstCycLStr);
394          CycBs-&gt;AddEdge(DstCycLStr, &quot;~#$genls&quot;, SrcCycLStr);
395        } else {
396          Fail;
397        }
398      }
399    }
400    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
401    {printf(&quot;Processing Relevance %s ...\n&quot;, CycRelevanceFNm.CStr());
402    PSIn CycRelevanceSIn=TFIn::New(CycRelevanceFNm);
403    PXmlDoc XmlDoc; int XmlDocs=0;
404    TStr PrevCycStr;
405    forever{
406      XmlDocs++;
407      if (XmlDocs%1000==0){
408        printf(&quot;%d Docs\r&quot;, XmlDocs);}
409      XmlDoc=TXmlDoc::LoadTxt(CycRelevanceSIn);
410      if (!XmlDoc-&gt;IsOk()){
411        printf(&quot;%s\n&quot;, PrevCycStr.CStr());
412        Fail;
413      }
414      PXmlTok TopTok=XmlDoc-&gt;GetTok();
415      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
416      IAssert(TopTok-&gt;IsTag(&quot;term&quot;));
417      TStr CycStr=TopTok-&gt;GetArgVal(&quot;cyc&quot;);
418      PrevCycStr=CycStr;
419      if (CycBs-&gt;IsVNm(CycStr)){
420        if (TopTok-&gt;GetArgVal(&quot;thcl&quot;)==&quot;T&quot;){
421          CycBs-&gt;GetVrtx(CycStr).SetFlag(cvfHumanRelevant, true);}
422        if (TopTok-&gt;GetArgVal(&quot;irrel&quot;)==&quot;T&quot;){
423          CycBs-&gt;GetVrtx(CycStr).SetFlag(cfvHumanIrrelevant, true);}
424        if (TopTok-&gt;GetArgVal(&quot;clarifying&quot;)==&quot;T&quot;){
425          CycBs-&gt;GetVrtx(CycStr).SetFlag(cfvHumanClarifying, true);}
426        if ((TopTok-&gt;GetArgVal(&quot;thcl&quot;)==&quot;T&quot;)||(TopTok-&gt;GetArgVal(&quot;clarifying&quot;)==&quot;T&quot;)){
427          CycBs-&gt;GetVrtx(CycStr).SetFlag(cvfHumanOk, true);}
428      } else {
429      }
430    }
431    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
432    {printf(&quot;Processing KBase %s ...\n&quot;, CycKBaseFNm.CStr());
433    PSIn CycKBaseSIn=TFIn::New(CycKBaseFNm);
434    PXmlDoc XmlDoc; int XmlDocs=0;
435    TStr PrevCycLStr; TStrV PrevArgCycLStrV;
436    TStrIntH HdCycLToFq;
437    forever{
438      XmlDocs++;
439      if (XmlDocs%1000==0){
440        printf(&quot;%d Docs\r&quot;, XmlDocs);}
441      XmlDoc=TXmlDoc::LoadTxt(CycKBaseSIn);
442      if (!XmlDoc-&gt;IsOk()){
443        printf(&quot;%s\n&quot;, PrevCycLStr.CStr());
444        for (int ArgN=0; ArgN&lt;PrevArgCycLStrV.Len(); ArgN++){
445          printf(&quot; [%s]&quot;, PrevArgCycLStrV[ArgN].CStr());}
446        printf(&quot;\n&quot;);
447        Fail;
448      }
449      PXmlTok TopTok=XmlDoc-&gt;GetTok();
450      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
451      IAssert(TopTok-&gt;IsTag(&quot;sentence&quot;));
452      TStr CycLStr=TopTok-&gt;GetArgVal(&quot;cycl&quot;);
453      TXmlTokV ArgXmlTokV; XmlDoc-&gt;GetTagTokV(&quot;sentence|arg&quot;, ArgXmlTokV);
454      TStrV ArgCycLStrV;
455      for (int ArgN=0; ArgN&lt;ArgXmlTokV.Len(); ArgN++){
456        PXmlTok Tok=ArgXmlTokV[ArgN];
457        IAssert(Tok-&gt;IsTag(&quot;arg&quot;));
458        if (Tok-&gt;IsArg(&quot;cycl&quot;)){
459          TStr ArgCycLStr=Tok-&gt;GetArgVal(&quot;cycl&quot;);
460          ArgCycLStrV.Add(ArgCycLStr);
461        } else {
462          ArgCycLStrV.Add(&quot;Empty&quot;);
463        }
464      }
465      PrevCycLStr=CycLStr;
466      PrevArgCycLStrV=ArgCycLStrV;
467      if (ArgCycLStrV.Len()&gt;0){
468        HdCycLToFq.AddDat(ArgCycLStrV[0]+&quot; - &quot;+TInt::GetStr(ArgCycLStrV.Len()-1))++;}
469      if (ArgCycLStrV.Len()==3){
470        TStr PredNm=ArgCycLStrV[0];
471        if ((PredNm!=&quot;#$isa&quot;)&amp;&amp;(PredNm!=&quot;#$termOfUnit&quot;)&amp;&amp;(PredNm!=&quot;#$genls&quot;)){
472          TStr BackLinkPredNm=TStr(&quot;~&quot;)+PredNm;
473          TStr Arg1=ArgCycLStrV[1];
474          TStr Arg2=ArgCycLStrV[2];
475          CycBs-&gt;AddEdge(Arg1, PredNm, Arg2);
476          CycBs-&gt;AddEdge(Arg2, BackLinkPredNm, Arg1);
477        }
478      }
479    }
480    {TFOut CycLSOut(&quot;CycKB-CycLFq.Stat.Txt&quot;); FILE* fCycL=CycLSOut.GetFileId();
481    TIntStrPrV FqCycLStrPrV; HdCycLToFq.GetDatKeyPrV(FqCycLStrPrV); 
482    FqCycLStrPrV.Sort(false);
483    for (int CycLN=0; CycLN&lt;FqCycLStrPrV.Len(); CycLN++){
484      fprintf(fCycL, &quot;%6d. %s\n&quot;, 1+FqCycLStrPrV[CycLN].Val1, FqCycLStrPrV[CycLN].Val2.CStr());
485    }}
486    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
487    return CycBs;
488  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</h3>
            <pre><code>1  #include &quot;cyc.h&quot;
2  TStr TCycVrtx::GetCycVrtxFlagStr(const TCycVrtxFlag&amp; CycVrtxFlag){
3    switch (CycVrtxFlag){
4      case cvfUndef: return &quot;Undef&quot;;
5      case cvfNum: return &quot;Num&quot;;
6      case cvfStr: return &quot;Str&quot;;
7      case cvfCycL: return &quot;CycL&quot;;
8      case cvfCycLConst: return &quot;CycLConst&quot;; 
9      case cvfCycLExpr: return &quot;CycLExpr&quot;;
10      case cvfCycLPred: return &quot;CycLPred&quot;;
11      case cvfBackLink: return &quot;BackLink&quot;;
12      case cvfHumanOk: return &quot;HumanOk&quot;;
13      case cvfHumanRelevant: return &quot;HumanRelevant&quot;;
14      case cfvHumanIrrelevant: return &quot;HumanIrrelevant&quot;;
15      case cfvHumanClarifying: return &quot;HumanClarifying&quot;;
16      default: Fail; return &quot;&quot;;
17    }
18  }
19  TStr TCycVrtx::GetFlagStr() const {
20    TChA ChA;
21    ChA+=&#x27;[&#x27;;
22    for (int FlagId=cvfMn; FlagId&lt;cvfMx; FlagId++){
23      if (IsFlag(FlagId)){
24        if (ChA.Len()&gt;1){ChA+=&#x27; &#x27;;}
25        ChA+=GetCycVrtxFlagStr(TCycVrtxFlag(FlagId));
26      }
27    }
28    ChA+=&#x27;]&#x27;;
29    return ChA;
30  }
31  int TCycBs::AddVNm(const TStr&amp; VNm){
32    int VId;
33    if (VNmToVrtxH.IsKey(VNm.CStr(), VId)){
34      return VId;
35    } else {
36      VId=VNmToVrtxH.AddKey(VNm);
37      TCycVrtx&amp; Vrtx=VNmToVrtxH[VId];
38      Vrtx.PutVId(VId);
39      if (VNm.IsPrefix(&quot;~&quot;)){
40        Vrtx.SetFlag(cvfBackLink);
41      } else
42      if (VNm.IsPrefix(&quot;#$&quot;)&amp;&amp;(!VNm.IsChIn(&#x27; &#x27;))){
43        Vrtx.SetFlag(cvfCycL);
44        if (VNm.Len()&gt;2){
45          char Ch=VNm[2];
46          if ((&#x27;a&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;z&#x27;)){
47            Vrtx.SetFlag(cvfCycLPred);
48          } else {
49            Vrtx.SetFlag(cvfCycLConst);
50          }
51        }
52      } else
53      if (VNm.IsPrefix(&quot;(#$&quot;)){
54        Vrtx.SetFlag(cvfCycL);
55        Vrtx.SetFlag(cvfCycLExpr);
56      } else {
57        if (VNm.IsFlt()){
58          Vrtx.SetFlag(cvfNum);
59        } else {
60          Vrtx.SetFlag(cvfStr);
61        }
62      }
63      return VId;
64    }
65  }
66  void TCycBs::GetRelNmV(TStrV&amp; RelNmV){
67    TStrH RelNmH;
68    for (int VId=0; VId&lt;GetVIds(); VId++){
69      TStr VNm=GetVNm(VId);
70      TCycVrtx&amp; Vrtx=GetVrtx(VId);
71      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
72        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
73        TStr RelNm=GetVNm(Edge.GetRelId());
74        RelNmH.AddKey(RelNm);
75      }
76    }
77    RelNmH.GetKeyV(RelNmV);
78  }
79  TStr TCycBs::GetDocStrFromCycLConstStr(const TStr&amp; CycLConstStr){
80    TChA ChA=CycLConstStr;
81    TChA DstChA;
82    if ((ChA.Len()&gt;2)&amp;&amp;(ChA[0]==&#x27;#&#x27;)&amp;&amp;(ChA[1]==&#x27;$&#x27;)){
83      int ChN=2;
84      while (ChN&lt;ChA.Len()){
85        if (DstChA.Len()&gt;0){DstChA+=&#x27; &#x27;;}
86        if ((ChA[ChN]==&#x27;-&#x27;)||(ChA[ChN]==&#x27;_&#x27;)||(ChA[ChN]==&#x27;:&#x27;)){
87          DstChA+=&quot;-&quot;; ChN++;
88        } else
89        if ((&#x27;0&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;9&#x27;)){
90          do {
91            DstChA+=ChA[ChN]; ChN++;
92          } while ((ChN&lt;ChA.Len())&amp;&amp;(&#x27;0&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;9&#x27;));
93        } else
94        if ((&#x27;a&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;z&#x27;)){
95          do {
96            DstChA+=ChA[ChN]; ChN++;
97          } while ((ChN&lt;ChA.Len())&amp;&amp;(&#x27;a&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;z&#x27;));
98        } else
99        if ((&#x27;A&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;Z&#x27;)){
100          if ((ChN+1&lt;ChA.Len())&amp;&amp;(&#x27;a&#x27;&lt;=ChA[ChN+1])&amp;&amp;(ChA[ChN+1]&lt;=&#x27;z&#x27;)){
101            do {
102              DstChA+=ChA[ChN]; ChN++;
103            } while ((ChN&lt;ChA.Len())&amp;&amp;(&#x27;a&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;z&#x27;));
104          } else {
105            do {
106              DstChA+=ChA[ChN]; ChN++;
107            } while (((ChN==ChA.Len()-1)&amp;&amp;(&#x27;A&#x27;&lt;=ChA[ChN])&amp;&amp;(ChA[ChN]&lt;=&#x27;Z&#x27;))||
108              ((ChN+1&lt;ChA.Len())&amp;&amp;(&#x27;A&#x27;&lt;=ChA[ChN+1])&amp;&amp;(ChA[ChN+1]&lt;=&#x27;Z&#x27;)));
109          }
110        } else {
111          DstChA=&quot;&quot;; break;
112        }
113      }
114    } else {
115      DstChA=&quot;&quot;;
116    }
117    return DstChA;
118  }
119  PLwOnto TCycBs::LoadCycVoc(const TStr&amp; CycBsFNm, const bool&amp; HumanOkOnlyP){
120    printf(&quot;Loading Cyc-Base from Binary-File &#x27;%s&#x27; ... &quot;, CycBsFNm.CStr());
121    PCycBs CycBs=TCycBs::LoadBin(CycBsFNm);
122    int VIds=CycBs-&gt;GetVIds();
123    printf(&quot;Done.\n&quot;);
124    PLwOnto LwOnto=TLwOnto::New();
125    int EnLangId=LwOnto-&gt;GetLangBs()-&gt;AddLang(&quot;EN&quot;, &quot;English&quot;);
126    PLwTermType C_TermType=TLwTermType::New(0, &quot;Class&quot;, EnLangId);
127    PLwTermType L_TermType=TLwTermType::New(1, &quot;Lexical&quot;, EnLangId);
128    int C_TermTypeId=LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(C_TermType);
129    int L_TermTypeId=LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(L_TermType);
130    {printf(&quot;Creating link-types ...&quot;);
131    TStrV RelNmV; CycBs-&gt;GetRelNmV(RelNmV);
132    for (int RelNmN=0; RelNmN&lt;RelNmV.Len(); RelNmN++){
133      TStr RelNm=RelNmV[RelNmN];
134      if (RelNm[0]==&#x27;~&#x27;){continue;}
135      PLwLinkType LinkType=TLwLinkType::New(RelNmN, RelNm, EnLangId, &quot;&quot;);
136      LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(LinkType);
137    }
138    printf(&quot; Done. (%d)\n&quot;, LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypes());}
139    {printf(&quot;Creating terms ...\n&quot;);
140    for (int VId=0; VId&lt;VIds; VId++){
141      if (VId%1000==0){printf(&quot;%d/%d\r&quot;, VId, VIds);}
142      TCycVrtx&amp; Vrtx=CycBs-&gt;GetVrtx(VId);
143      if (Vrtx.IsFlag(cvfCycLPred)){continue;}
144      if ((!Vrtx.IsFlag(cvfStr))&amp;&amp;
145       (HumanOkOnlyP&amp;&amp;(!Vrtx.IsFlag(cvfHumanOk)))){continue;}
146      TStr VNm=CycBs-&gt;GetVNm(VId);
147      int TermTypeId=(Vrtx.IsFlag(cvfStr)) ? L_TermTypeId : C_TermTypeId;
148      PLwTerm Term=TLwTerm::New(VId, VNm, EnLangId, TermTypeId);
149      LwOnto-&gt;GetTermBs()-&gt;AddTerm(Term);
150    }
151    printf(&quot;Done. (%d)\n&quot;, LwOnto-&gt;GetTermBs()-&gt;GetTerms());}
152    {printf(&quot;Creating links ...\n&quot;);
153    for (int VId=0; VId&lt;VIds; VId++){
154      if (VId%1000==0){printf(&quot;%d/%d\r&quot;, VId, VIds);}
155      if (!LwOnto-&gt;GetTermBs()-&gt;IsTermId(VId)){continue;}
156      TCycVrtx&amp; Vrtx=CycBs-&gt;GetVrtx(VId);
157      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
158        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
159        int DstVId=Edge.GetDstVId();
160        if (!LwOnto-&gt;GetTermBs()-&gt;IsTermId(DstVId)){continue;}
161        TStr RelNm=CycBs-&gt;GetVNm(Edge.GetRelId());
162        if (LwOnto-&gt;GetLinkTypeBs()-&gt;IsLinkType(RelNm, EnLangId)){
163          int LinkTypeId=LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypeId(RelNm, EnLangId);
164          LwOnto-&gt;GetLinkBs()-&gt;AddLink(VId, LinkTypeId, DstVId);
165        }
166      }
167    }
168    printf(&quot;Done. (%d)\n&quot;, LwOnto-&gt;GetLinkBs()-&gt;GetLinks());}
169    return LwOnto;
170  }
171  void TCycBs::SaveTxt(const TStr&amp; FNm){
172    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
173    for (int VId=0; VId&lt;GetVIds(); VId++){
174      TStr VNm=GetVNm(VId);
175      TCycVrtx&amp; Vrtx=GetVrtx(VId);
176      TStr FlagStr=Vrtx.GetFlagStr();
177      fprintf(fOut, &quot;(%d) %s - %s\n&quot;, VId, VNm.CStr(), FlagStr.CStr());
178      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
179        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
180        TStr RelNm=GetVNm(Edge.GetRelId());
181        TStr DstVNm=GetVNm(Edge.GetDstVId());
182        fprintf(fOut, &quot;     %d. [%s] --&gt; %s\n&quot;, 1+EdgeN, RelNm.CStr(), DstVNm.CStr());
183      }
184    }
185  }
186  void TCycBs::_SaveTaxonomyTxt(FILE* fOut, 
187   const int&amp; Lev, TIntPrV&amp; RelIdVIdPrV, TIntIntH&amp; VIdToLevH){
188    for (int VidN=0; VidN&lt;RelIdVIdPrV.Len(); VidN++){
189      int FromRelId=RelIdVIdPrV[VidN].Val1;
190      int SrcVId=RelIdVIdPrV[VidN].Val2;
191      TStr SrcVNm=GetVNm(SrcVId);
192      TCycVrtx&amp; SrcVrtx=GetVrtx(SrcVId);
193      if (!SrcVrtx.IsFlag(cvfHumanOk)){continue;}
194      TStr FlagStr=SrcVrtx.GetFlagStr();
195      if (FromRelId==-1){
196        if (Lev&gt;0){fprintf(fOut, &quot;===upper&quot;);} else {fprintf(fOut, &quot;===lower&quot;);}
197        fprintf(fOut, &quot;=======================================================\n&quot;);
198        fprintf(fOut, &quot;%s - %s\n&quot;, SrcVNm.CStr(), FlagStr.CStr());
199      } else {
200        TStr FromRelNm=GetVNm(FromRelId);
201        fprintf(fOut, &quot;%*c[%s] --&gt; %s\n&quot;, (Lev-1)*5, &#x27; &#x27;, FromRelNm.CStr(), SrcVNm.CStr());
202      }
203      TIntPrV UpRelIdVIdPrV;
204      for (int EdgeN=0; EdgeN&lt;SrcVrtx.GetEdges(); EdgeN++){
205        TCycEdge&amp; Edge=SrcVrtx.GetEdge(EdgeN);
206        int RelId=Edge.GetRelId();
207        int DstVId=Edge.GetDstVId();
208        TStr RelNm=GetVNm(RelId);
209        TStr DstVNm=GetVNm(DstVId);
210        if (Lev&gt;0){
211          if ((RelNm==&quot;#$isa&quot;)||(RelNm==&quot;#$genls&quot;)){
212            if (!VIdToLevH.IsKey(DstVId)){
213              VIdToLevH.AddDat(DstVId, Lev+1);
214              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
215            }
216          }
217        } else {
218          if ((RelNm==&quot;~#$isa&quot;)||(RelNm==&quot;~#$genls&quot;)){
219            if (!VIdToLevH.IsKey(DstVId)){
220              VIdToLevH.AddDat(DstVId, Lev-1);
221              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
222            }
223          }
224        }
225      } 
226      if (Lev&gt;0){
227        _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);
228      } else {
229        _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);
230      }
231    }
232  }
233  void TCycBs::SaveTaxonomyTxt(const TStr&amp; FNm){
234    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
235    for (int VId=0; VId&lt;GetVIds(); VId++){
236      printf(&quot;%d/%d (%.1f%%)\r&quot;, 1+VId, GetVIds(), 100.0*(1+VId)/GetVIds());
237      {int Lev=0;
238      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
239      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
240      _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);}
241      {int Lev=0;
242      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
243      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
244      _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);}
245    }
246    printf(&quot;\n&quot;);
247  }
248  void TCycBs::SaveStatTxt(const TStr&amp; FNm){
249    PMom CommentLenMom=TMom::New();
250    PMom StrsLenMom=TMom::New();
251    PMom HumanOk_StrsLenMom=TMom::New();
252    PMom ClassesPerStrMom=TMom::New();
253    PMom StrsPerClassMom=TMom::New();
254    PMom HumanOk_StrsPerClassMom=TMom::New();
255    PMom IsasPerClassMom=TMom::New();
256    PMom HumanOk_IsasPerClassMom=TMom::New();
257    PMom GenlsPerClassMom=TMom::New();
258    PMom HumanOk_GenlsPerClassMom=TMom::New();
259    PMom IsasGenlsPerClassMom=TMom::New();
260    PMom HumanOk_IsasGenlsPerClassMom=TMom::New();
261    int Classes=0;
262    int HumanOk_Classes=0;
263    int Comments=0;
264    int HumanOk_Comments=0;
265    for (int VId=0; VId&lt;GetVIds(); VId++){
266      TStr VNm=GetVNm(VId);
267      TCycVrtx&amp; Vrtx=GetVrtx(VId);
268      TStr FlagStr=Vrtx.GetFlagStr();
269      int StrsLen=0;
270      int ClassesPerStrInstance=0;
271      int NmStrs=0; int BackLinkNmStrs=0;
272      int Isas=0; int Genls=0;
273      for (int EdgeN=0; EdgeN&lt;Vrtx.GetEdges(); EdgeN++){
274        TCycEdge&amp; Edge=Vrtx.GetEdge(EdgeN);
<span onclick='openModal()' class='match'>275        TStr RelNm=GetVNm(Edge.GetRelId());
276        TStr DstVNm=GetVNm(Edge.GetDstVId());
277        TCycVrtx&amp; DstVrtx=GetVrtx(Edge.GetDstVId());
</span>278        if (RelNm==&quot;#$comment&quot;){
279          CommentLenMom-&gt;Add(DstVNm.Len());
280          Comments++; 
281          if (Vrtx.IsFlag(cvfHumanOk)){HumanOk_Comments++;}
282        }
283        if (DstVrtx.IsFlag(cvfStr)){StrsLen+=DstVNm.Len();}
284        if (Vrtx.IsFlag(cvfStr)){ClassesPerStrInstance++;}
285        if (RelNm==&quot;#$nameString&quot;){NmStrs++;}
286        if (RelNm==&quot;~#$nameString&quot;){BackLinkNmStrs++;}
287        if (RelNm==&quot;#$isa&quot;){Isas++;}
288        if (RelNm==&quot;#$genls&quot;){Genls++;}
289      }
290      if (Vrtx.IsFlag(cvfCycL)){Classes++;}
291      if (Vrtx.IsFlag(cvfCycL)){StrsLenMom-&gt;Add(StrsLen);}
292      if (Vrtx.IsFlag(cvfStr)){ClassesPerStrMom-&gt;Add(BackLinkNmStrs);}
293      if (Vrtx.IsFlag(cvfCycL)){StrsPerClassMom-&gt;Add(NmStrs);}
294      if (Vrtx.IsFlag(cvfCycL)){IsasPerClassMom-&gt;Add(Isas);}
295      if (Vrtx.IsFlag(cvfCycL)){GenlsPerClassMom-&gt;Add(Genls);}
296      if (Vrtx.IsFlag(cvfCycL)){IsasGenlsPerClassMom-&gt;Add(Isas+Genls);}
297      if (Vrtx.IsFlag(cvfHumanOk)){
298        if (Vrtx.IsFlag(cvfCycL)){HumanOk_Classes++;}
299        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsLenMom-&gt;Add(StrsLen);}
300        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsPerClassMom-&gt;Add(NmStrs);}
301        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasPerClassMom-&gt;Add(Isas);}
302        if (Vrtx.IsFlag(cvfCycL)){HumanOk_GenlsPerClassMom-&gt;Add(Genls);}
303        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasGenlsPerClassMom-&gt;Add(Isas+Genls);}
304      }
305    }
306    CommentLenMom-&gt;Def();
307    StrsLenMom-&gt;Def();
308    HumanOk_StrsLenMom-&gt;Def();
309    ClassesPerStrMom-&gt;Def();
310    StrsPerClassMom-&gt;Def();
311    HumanOk_StrsPerClassMom-&gt;Def();
312    IsasPerClassMom-&gt;Def();
313    HumanOk_IsasPerClassMom-&gt;Def();
314    GenlsPerClassMom-&gt;Def();
315    HumanOk_GenlsPerClassMom-&gt;Def();
316    IsasGenlsPerClassMom-&gt;Def();
317    HumanOk_IsasGenlsPerClassMom-&gt;Def();
318    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
319    fprintf(fOut, &quot;CommentLen: %s\n&quot;, CommentLenMom-&gt;GetStr().CStr());
320    fprintf(fOut, &quot;StrsLen: %s\n&quot;, StrsLenMom-&gt;GetStr().CStr());
321    fprintf(fOut, &quot;HumanOk_StrsLen: %s\n&quot;, HumanOk_StrsLenMom-&gt;GetStr().CStr());
322    fprintf(fOut, &quot;ClassesPerStr: %s\n&quot;, ClassesPerStrMom-&gt;GetStr().CStr());
323    fprintf(fOut, &quot;StrsPerClass: %s\n&quot;, StrsPerClassMom-&gt;GetStr().CStr());
324    fprintf(fOut, &quot;HumanOk_StrsPerClass: %s\n&quot;, HumanOk_StrsPerClassMom-&gt;GetStr().CStr());
325    fprintf(fOut, &quot;IsasPerClass: %s\n&quot;, IsasPerClassMom-&gt;GetStr().CStr());
326    fprintf(fOut, &quot;HumanOk_IsasPerClass: %s\n&quot;, HumanOk_IsasPerClassMom-&gt;GetStr().CStr());
327    fprintf(fOut, &quot;GenlsPerClass: %s\n&quot;, GenlsPerClassMom-&gt;GetStr().CStr());
328    fprintf(fOut, &quot;HumanOk_GenlsPerClass: %s\n&quot;, HumanOk_GenlsPerClassMom-&gt;GetStr().CStr());
329    fprintf(fOut, &quot;IsasGenlsPerClass: %s\n&quot;, IsasGenlsPerClassMom-&gt;GetStr().CStr());
330    fprintf(fOut, &quot;HumanOk_IsasGenlsPerClass: %s\n&quot;, HumanOk_IsasGenlsPerClassMom-&gt;GetStr().CStr());
331    fprintf(fOut, &quot;Classes: %d\n&quot;, Classes);
332    fprintf(fOut, &quot;HumanOk_Classes: %d\n&quot;, HumanOk_Classes);
333    fprintf(fOut, &quot;Comments: %d\n&quot;, Comments);
334    fprintf(fOut, &quot;HumanOk_Comments: %d\n&quot;, HumanOk_Comments);
335    fprintf(fOut, &quot;End&quot;);}
336  }
337  PCycBs TCycBs::LoadCycXmlDump(const TStr&amp; FPath){
338    TStr NrFPath=TStr::GetNrFPath(FPath);
339    TStr CycLexiconFNm=NrFPath+&quot;lexicon-dump.xml&quot;;
340    TStr CycTaxonomyFNm=NrFPath+&quot;taxonomy-dump.xml&quot;;
341    TStr CycRelevanceFNm=NrFPath+&quot;relevance-dump.xml&quot;;
342    TStr CycKBaseFNm=NrFPath+&quot;kb-dump.xml&quot;;                                                 
343    PCycBs CycBs=TCycBs::New();
344    {printf(&quot;Processing Lexicon %s ...\n&quot;, CycLexiconFNm.CStr());
345    PSIn CycLexiconSIn=TFIn::New(CycLexiconFNm);
346    PXmlDoc XmlDoc; int XmlDocs=0;
347    TStr PrevCycWStr; TStr PrevCycLStr;
348    forever{
349      XmlDocs++; if (XmlDocs%1000==0){printf(&quot;%d Docs\r&quot;, XmlDocs);}
350      XmlDoc=TXmlDoc::LoadTxt(CycLexiconSIn);
351      if (!XmlDoc-&gt;IsOk()){
352        printf(&quot;%s - %s\n&quot;, PrevCycWStr.CStr(), PrevCycLStr.CStr());
353        Fail;
354      }
355      PXmlTok TopTok=XmlDoc-&gt;GetTok();
356      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
357      IAssert(TopTok-&gt;IsTag(&quot;word&quot;));
358      TStr CycWStr=TopTok-&gt;GetArgVal(&quot;string&quot;);
359      TStr CycLStr=TopTok-&gt;GetArgVal(&quot;cycl&quot;);
360      PrevCycWStr=CycWStr; PrevCycLStr;
361      CycBs-&gt;AddEdge(CycLStr, &quot;#$nameString&quot;, CycWStr);
362      CycBs-&gt;AddEdge(CycWStr, &quot;~#$nameString&quot;, CycLStr);
363    }
364    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
365    {printf(&quot;Processing Taxonomy %s ...\n&quot;, CycTaxonomyFNm.CStr());
366    PSIn CycTaxonomySIn=TFIn::New(CycTaxonomyFNm);
367    PXmlDoc XmlDoc; int XmlDocs=0;
368    TStr PrevSrcCycLStr;
369    forever{
370      XmlDocs++;
371      if (XmlDocs%1000==0){
372        printf(&quot;%d Docs\r&quot;, XmlDocs);}
373      XmlDoc=TXmlDoc::LoadTxt(CycTaxonomySIn);
374      if (!XmlDoc-&gt;IsOk()){
375        printf(&quot;%s\n&quot;, PrevSrcCycLStr.CStr());
376        Fail;
377      }
378      PXmlTok TopTok=XmlDoc-&gt;GetTok();
379      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
380      IAssert(TopTok-&gt;IsTag(&quot;term&quot;));
381      TStr SrcCycLStr=TopTok-&gt;GetArgVal(&quot;cycl&quot;);
382      PrevSrcCycLStr=SrcCycLStr;
383      for (int SubTokN=0; SubTokN&lt;TopTok-&gt;GetSubToks(); SubTokN++){
384        PXmlTok SubTok=TopTok-&gt;GetSubTok(SubTokN);
385        TStr DstCycLStr=SubTok-&gt;GetTagNm();
386        if (SubTok-&gt;IsTag(&quot;isa&quot;)){
387          DstCycLStr=SubTok-&gt;GetArgVal(&quot;value&quot;);
388          CycBs-&gt;AddEdge(SrcCycLStr, &quot;#$isa&quot;, DstCycLStr);
389          CycBs-&gt;AddEdge(DstCycLStr, &quot;~#$isa&quot;, SrcCycLStr);
390        } else
391        if (SubTok-&gt;IsTag(&quot;genl&quot;)){
392          DstCycLStr=SubTok-&gt;GetArgVal(&quot;value&quot;);
393          CycBs-&gt;AddEdge(SrcCycLStr, &quot;#$genls&quot;, DstCycLStr);
394          CycBs-&gt;AddEdge(DstCycLStr, &quot;~#$genls&quot;, SrcCycLStr);
395        } else {
396          Fail;
397        }
398      }
399    }
400    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
401    {printf(&quot;Processing Relevance %s ...\n&quot;, CycRelevanceFNm.CStr());
402    PSIn CycRelevanceSIn=TFIn::New(CycRelevanceFNm);
403    PXmlDoc XmlDoc; int XmlDocs=0;
404    TStr PrevCycStr;
405    forever{
406      XmlDocs++;
407      if (XmlDocs%1000==0){
408        printf(&quot;%d Docs\r&quot;, XmlDocs);}
409      XmlDoc=TXmlDoc::LoadTxt(CycRelevanceSIn);
410      if (!XmlDoc-&gt;IsOk()){
411        printf(&quot;%s\n&quot;, PrevCycStr.CStr());
412        Fail;
413      }
414      PXmlTok TopTok=XmlDoc-&gt;GetTok();
415      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
416      IAssert(TopTok-&gt;IsTag(&quot;term&quot;));
417      TStr CycStr=TopTok-&gt;GetArgVal(&quot;cyc&quot;);
418      PrevCycStr=CycStr;
419      if (CycBs-&gt;IsVNm(CycStr)){
420        if (TopTok-&gt;GetArgVal(&quot;thcl&quot;)==&quot;T&quot;){
421          CycBs-&gt;GetVrtx(CycStr).SetFlag(cvfHumanRelevant, true);}
422        if (TopTok-&gt;GetArgVal(&quot;irrel&quot;)==&quot;T&quot;){
423          CycBs-&gt;GetVrtx(CycStr).SetFlag(cfvHumanIrrelevant, true);}
424        if (TopTok-&gt;GetArgVal(&quot;clarifying&quot;)==&quot;T&quot;){
425          CycBs-&gt;GetVrtx(CycStr).SetFlag(cfvHumanClarifying, true);}
426        if ((TopTok-&gt;GetArgVal(&quot;thcl&quot;)==&quot;T&quot;)||(TopTok-&gt;GetArgVal(&quot;clarifying&quot;)==&quot;T&quot;)){
427          CycBs-&gt;GetVrtx(CycStr).SetFlag(cvfHumanOk, true);}
428      } else {
429      }
430    }
431    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
432    {printf(&quot;Processing KBase %s ...\n&quot;, CycKBaseFNm.CStr());
433    PSIn CycKBaseSIn=TFIn::New(CycKBaseFNm);
434    PXmlDoc XmlDoc; int XmlDocs=0;
435    TStr PrevCycLStr; TStrV PrevArgCycLStrV;
436    TStrIntH HdCycLToFq;
437    forever{
438      XmlDocs++;
439      if (XmlDocs%1000==0){
440        printf(&quot;%d Docs\r&quot;, XmlDocs);}
441      XmlDoc=TXmlDoc::LoadTxt(CycKBaseSIn);
442      if (!XmlDoc-&gt;IsOk()){
443        printf(&quot;%s\n&quot;, PrevCycLStr.CStr());
444        for (int ArgN=0; ArgN&lt;PrevArgCycLStrV.Len(); ArgN++){
445          printf(&quot; [%s]&quot;, PrevArgCycLStrV[ArgN].CStr());}
446        printf(&quot;\n&quot;);
447        Fail;
448      }
449      PXmlTok TopTok=XmlDoc-&gt;GetTok();
450      if (TopTok-&gt;IsTag(&quot;end&quot;)){break;}
451      IAssert(TopTok-&gt;IsTag(&quot;sentence&quot;));
452      TStr CycLStr=TopTok-&gt;GetArgVal(&quot;cycl&quot;);
453      TXmlTokV ArgXmlTokV; XmlDoc-&gt;GetTagTokV(&quot;sentence|arg&quot;, ArgXmlTokV);
454      TStrV ArgCycLStrV;
455      for (int ArgN=0; ArgN&lt;ArgXmlTokV.Len(); ArgN++){
456        PXmlTok Tok=ArgXmlTokV[ArgN];
457        IAssert(Tok-&gt;IsTag(&quot;arg&quot;));
458        if (Tok-&gt;IsArg(&quot;cycl&quot;)){
459          TStr ArgCycLStr=Tok-&gt;GetArgVal(&quot;cycl&quot;);
460          ArgCycLStrV.Add(ArgCycLStr);
461        } else {
462          ArgCycLStrV.Add(&quot;Empty&quot;);
463        }
464      }
465      PrevCycLStr=CycLStr;
466      PrevArgCycLStrV=ArgCycLStrV;
467      if (ArgCycLStrV.Len()&gt;0){
468        HdCycLToFq.AddDat(ArgCycLStrV[0]+&quot; - &quot;+TInt::GetStr(ArgCycLStrV.Len()-1))++;}
469      if (ArgCycLStrV.Len()==3){
470        TStr PredNm=ArgCycLStrV[0];
471        if ((PredNm!=&quot;#$isa&quot;)&amp;&amp;(PredNm!=&quot;#$termOfUnit&quot;)&amp;&amp;(PredNm!=&quot;#$genls&quot;)){
472          TStr BackLinkPredNm=TStr(&quot;~&quot;)+PredNm;
473          TStr Arg1=ArgCycLStrV[1];
474          TStr Arg2=ArgCycLStrV[2];
475          CycBs-&gt;AddEdge(Arg1, PredNm, Arg2);
476          CycBs-&gt;AddEdge(Arg2, BackLinkPredNm, Arg1);
477        }
478      }
479    }
480    {TFOut CycLSOut(&quot;CycKB-CycLFq.Stat.Txt&quot;); FILE* fCycL=CycLSOut.GetFileId();
481    TIntStrPrV FqCycLStrPrV; HdCycLToFq.GetDatKeyPrV(FqCycLStrPrV); 
482    FqCycLStrPrV.Sort(false);
483    for (int CycLN=0; CycLN&lt;FqCycLStrPrV.Len(); CycLN++){
484      fprintf(fCycL, &quot;%6d. %s\n&quot;, 1+FqCycLStrPrV[CycLN].Val1, FqCycLStrPrV[CycLN].Val2.CStr());
485    }}
486    printf(&quot;%d Docs\nDone.\n&quot;, XmlDocs);}
487    return CycBs;
488  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</div>
                </div>
                <div class="column column_space"><pre><code>180        TStr RelNm=GetVNm(Edge.GetRelId());
181        TStr DstVNm=GetVNm(Edge.GetDstVId());
182        fprintf(fOut, &quot;     %d. [%s] --&gt; %s\n&quot;, 1+EdgeN, RelNm.CStr(), DstVNm.CStr());
</pre></code></div>
                <div class="column column_space"><pre><code>275        TStr RelNm=GetVNm(Edge.GetRelId());
276        TStr DstVNm=GetVNm(Edge.GetDstVId());
277        TCycVrtx&amp; DstVrtx=GetVrtx(Edge.GetDstVId());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    