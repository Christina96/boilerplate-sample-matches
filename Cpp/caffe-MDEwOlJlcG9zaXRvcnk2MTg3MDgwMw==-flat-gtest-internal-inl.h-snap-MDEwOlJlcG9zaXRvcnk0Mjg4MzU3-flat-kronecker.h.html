
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.163346613545817%, Tokens: 17</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal-inl.h</h3>
            <pre><code>1  #ifndef GTEST_SRC_GTEST_INTERNAL_INL_H_
2  #define GTEST_SRC_GTEST_INTERNAL_INL_H_
3  #if !GTEST_IMPLEMENTATION_
4  # error "gtest-internal-inl.h is part of Google Test's internal implementation."
5  # error "It must not be included except by Google Test itself."
6  #endif  
7  #ifndef _WIN32_WCE
8  # include <errno.h>
9  #endif  
10  #include <stddef.h>
11  #include <stdlib.h>  
12  #include <string.h>  
13  #include <algorithm>
14  #include <string>
15  #include <vector>
16  #include "gtest/internal/gtest-port.h"
17  #if GTEST_CAN_STREAM_RESULTS_
18  # include <arpa/inet.h>  
19  # include <netdb.h>  
20  #endif
21  #if GTEST_OS_WINDOWS
22  # include <windows.h>  
23  #endif  
24  #include "gtest/gtest.h"  
25  #include "gtest/gtest-spi.h"
26  namespace testing {
27  GTEST_DECLARE_bool_(death_test_use_fork);
28  namespace internal {
29  GTEST_API_ extern const TypeId kTestTypeIdInGoogleTest;
30  const char kAlsoRunDisabledTestsFlag[] = "also_run_disabled_tests";
31  const char kBreakOnFailureFlag[] = "break_on_failure";
32  const char kCatchExceptionsFlag[] = "catch_exceptions";
33  const char kColorFlag[] = "color";
34  const char kFilterFlag[] = "filter";
35  const char kListTestsFlag[] = "list_tests";
36  const char kOutputFlag[] = "output";
37  const char kPrintTimeFlag[] = "print_time";
38  const char kRandomSeedFlag[] = "random_seed";
39  const char kRepeatFlag[] = "repeat";
40  const char kShuffleFlag[] = "shuffle";
41  const char kStackTraceDepthFlag[] = "stack_trace_depth";
42  const char kStreamResultToFlag[] = "stream_result_to";
43  const char kThrowOnFailureFlag[] = "throw_on_failure";
44  const int kMaxRandomSeed = 99999;
45  GTEST_API_ extern bool g_help_flag;
46  GTEST_API_ TimeInMillis GetTimeInMillis();
47  GTEST_API_ bool ShouldUseColor(bool stdout_is_tty);
48  GTEST_API_ std::string FormatTimeInMillisAsSeconds(TimeInMillis ms);
49  GTEST_API_ std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms);
50  GTEST_API_ bool ParseInt32Flag(
51      const char* str, const char* flag, Int32* value);
52  inline int GetRandomSeedFromFlag(Int32 random_seed_flag) {
53    const unsigned int raw_seed = (random_seed_flag == 0) ?
54        static_cast<unsigned int>(GetTimeInMillis()) :
55        static_cast<unsigned int>(random_seed_flag);
56    const int normalized_seed =
57        static_cast<int>((raw_seed - 1U) %
58                         static_cast<unsigned int>(kMaxRandomSeed)) + 1;
59    return normalized_seed;
60  }
61  inline int GetNextRandomSeed(int seed) {
62    GTEST_CHECK_(1 <= seed && seed <= kMaxRandomSeed)
63        << "Invalid random seed " << seed << " - must be in [1, "
64        << kMaxRandomSeed << "].";
65    const int next_seed = seed + 1;
66    return (next_seed > kMaxRandomSeed) ? 1 : next_seed;
67  }
68  class GTestFlagSaver {
69   public:
70    GTestFlagSaver() {
71      also_run_disabled_tests_ = GTEST_FLAG(also_run_disabled_tests);
72      break_on_failure_ = GTEST_FLAG(break_on_failure);
73      catch_exceptions_ = GTEST_FLAG(catch_exceptions);
74      color_ = GTEST_FLAG(color);
75      death_test_style_ = GTEST_FLAG(death_test_style);
76      death_test_use_fork_ = GTEST_FLAG(death_test_use_fork);
77      filter_ = GTEST_FLAG(filter);
78      internal_run_death_test_ = GTEST_FLAG(internal_run_death_test);
79      list_tests_ = GTEST_FLAG(list_tests);
80      output_ = GTEST_FLAG(output);
81      print_time_ = GTEST_FLAG(print_time);
82      random_seed_ = GTEST_FLAG(random_seed);
83      repeat_ = GTEST_FLAG(repeat);
84      shuffle_ = GTEST_FLAG(shuffle);
85      stack_trace_depth_ = GTEST_FLAG(stack_trace_depth);
86      stream_result_to_ = GTEST_FLAG(stream_result_to);
87      throw_on_failure_ = GTEST_FLAG(throw_on_failure);
88    }
89    ~GTestFlagSaver() {
90      GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;
91      GTEST_FLAG(break_on_failure) = break_on_failure_;
92      GTEST_FLAG(catch_exceptions) = catch_exceptions_;
93      GTEST_FLAG(color) = color_;
94      GTEST_FLAG(death_test_style) = death_test_style_;
95      GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;
96      GTEST_FLAG(filter) = filter_;
97      GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;
98      GTEST_FLAG(list_tests) = list_tests_;
99      GTEST_FLAG(output) = output_;
100      GTEST_FLAG(print_time) = print_time_;
101      GTEST_FLAG(random_seed) = random_seed_;
102      GTEST_FLAG(repeat) = repeat_;
103      GTEST_FLAG(shuffle) = shuffle_;
104      GTEST_FLAG(stack_trace_depth) = stack_trace_depth_;
105      GTEST_FLAG(stream_result_to) = stream_result_to_;
106      GTEST_FLAG(throw_on_failure) = throw_on_failure_;
107    }
108   private:
109    bool also_run_disabled_tests_;
110    bool break_on_failure_;
111    bool catch_exceptions_;
112    std::string color_;
113    std::string death_test_style_;
114    bool death_test_use_fork_;
115    std::string filter_;
116    std::string internal_run_death_test_;
117    bool list_tests_;
118    std::string output_;
119    bool print_time_;
120    internal::Int32 random_seed_;
121    internal::Int32 repeat_;
122    bool shuffle_;
123    internal::Int32 stack_trace_depth_;
124    std::string stream_result_to_;
125    bool throw_on_failure_;
126  } GTEST_ATTRIBUTE_UNUSED_;
127  GTEST_API_ std::string CodePointToUtf8(UInt32 code_point);
128  GTEST_API_ std::string WideStringToUtf8(const wchar_t* str, int num_chars);
129  void WriteToShardStatusFileIfNeeded();
130  GTEST_API_ bool ShouldShard(const char* total_shards_str,
131                              const char* shard_index_str,
132                              bool in_subprocess_for_death_test);
133  GTEST_API_ Int32 Int32FromEnvOrDie(const char* env_var, Int32 default_val);
134  GTEST_API_ bool ShouldRunTestOnShard(
135      int total_shards, int shard_index, int test_id);
136  template <class Container, typename Predicate>
137  inline int CountIf(const Container& c, Predicate predicate) {
138    int count = 0;
139    for (typename Container::const_iterator it = c.begin(); it != c.end(); ++it) {
140      if (predicate(*it))
141        ++count;
142    }
143    return count;
144  }
145  template <class Container, typename Functor>
146  void ForEach(const Container& c, Functor functor) {
147    std::for_each(c.begin(), c.end(), functor);
148  }
149  template <typename E>
150  inline E GetElementOr(const std::vector<E>& v, int i, E default_value) {
151    return (i < 0 || i >= static_cast<int>(v.size())) ? default_value : v[i];
152  }
153  template <typename E>
154  void ShuffleRange(internal::Random* random, int begin, int end,
155                    std::vector<E>* v) {
156    const int size = static_cast<int>(v->size());
157    GTEST_CHECK_(0 <= begin && begin <= size)
158        << "Invalid shuffle range start " << begin << ": must be in range [0, "
159        << size << "].";
160    GTEST_CHECK_(begin <= end && end <= size)
161        << "Invalid shuffle range finish " << end << ": must be in range ["
162        << begin << ", " << size << "].";
163    for (int range_width = end - begin; range_width >= 2; range_width--) {
164      const int last_in_range = begin + range_width - 1;
165      const int selected = begin + random->Generate(range_width);
166      std::swap((*v)[selected], (*v)[last_in_range]);
167    }
168  }
169  template <typename E>
170  inline void Shuffle(internal::Random* random, std::vector<E>* v) {
171    ShuffleRange(random, 0, static_cast<int>(v->size()), v);
172  }
173  template <typename T>
174  static void Delete(T* x) {
175    delete x;
176  }
177  class TestPropertyKeyIs {
178   public:
179    explicit TestPropertyKeyIs(const std::string& key) : key_(key) {}
180    bool operator()(const TestProperty& test_property) const {
181      return test_property.key() == key_;
182    }
183   private:
184    std::string key_;
185  };
186  class GTEST_API_ UnitTestOptions {
187   public:
188    static std::string GetOutputFormat();
189    static std::string GetAbsolutePathToOutputFile();
190    static bool PatternMatchesString(const char *pattern, const char *str);
191    static bool FilterMatchesTest(const std::string &test_case_name,
192                                  const std::string &test_name);
193  #if GTEST_OS_WINDOWS
194    static int GTestShouldProcessSEH(DWORD exception_code);
195  #endif  
196    static bool MatchesFilter(const std::string& name, const char* filter);
197  };
198  GTEST_API_ FilePath GetCurrentExecutableName();
199  class OsStackTraceGetterInterface {
200   public:
201    OsStackTraceGetterInterface() {}
202    virtual ~OsStackTraceGetterInterface() {}
203    virtual string CurrentStackTrace(int max_depth, int skip_count) = 0;
204    virtual void UponLeavingGTest() = 0;
205   private:
206    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetterInterface);
207  };
208  class OsStackTraceGetter : public OsStackTraceGetterInterface {
209   public:
210    OsStackTraceGetter() : caller_frame_(NULL) {}
211    virtual string CurrentStackTrace(int max_depth, int skip_count)
212        GTEST_LOCK_EXCLUDED_(mutex_);
213    virtual void UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_);
214    static const char* const kElidedFramesMarker;
215   private:
216    Mutex mutex_;  
217    void* caller_frame_;
218    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetter);
219  };
220  struct TraceInfo {
221    const char* file;
222    int line;
223    std::string message;
224  };
225  class DefaultGlobalTestPartResultReporter
226    : public TestPartResultReporterInterface {
227   public:
228    explicit DefaultGlobalTestPartResultReporter(UnitTestImpl* unit_test);
229    virtual void ReportTestPartResult(const TestPartResult& result);
230   private:
231    UnitTestImpl* const unit_test_;
232    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultGlobalTestPartResultReporter);
233  };
234  class DefaultPerThreadTestPartResultReporter
235      : public TestPartResultReporterInterface {
236   public:
237    explicit DefaultPerThreadTestPartResultReporter(UnitTestImpl* unit_test);
238    virtual void ReportTestPartResult(const TestPartResult& result);
239   private:
240    UnitTestImpl* const unit_test_;
241    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultPerThreadTestPartResultReporter);
242  };
243  class GTEST_API_ UnitTestImpl {
244   public:
245    explicit UnitTestImpl(UnitTest* parent);
246    virtual ~UnitTestImpl();
247    TestPartResultReporterInterface* GetGlobalTestPartResultReporter();
248    void SetGlobalTestPartResultReporter(
249        TestPartResultReporterInterface* reporter);
250    TestPartResultReporterInterface* GetTestPartResultReporterForCurrentThread();
251    void SetTestPartResultReporterForCurrentThread(
252        TestPartResultReporterInterface* reporter);
253    int successful_test_case_count() const;
254    int failed_test_case_count() const;
255    int total_test_case_count() const;
256    int test_case_to_run_count() const;
257    int successful_test_count() const;
258    int failed_test_count() const;
259    int reportable_disabled_test_count() const;
260    int disabled_test_count() const;
261    int reportable_test_count() const;
262    int total_test_count() const;
263    int test_to_run_count() const;
264    TimeInMillis start_timestamp() const { return start_timestamp_; }
265    TimeInMillis elapsed_time() const { return elapsed_time_; }
266    bool Passed() const { return !Failed(); }
267    bool Failed() const {
268      return failed_test_case_count() > 0 || ad_hoc_test_result()->Failed();
269    }
270    const TestCase* GetTestCase(int i) const {
271      const int index = GetElementOr(test_case_indices_, i, -1);
272      return index < 0 ? NULL : test_cases_[i];
273    }
274    TestCase* GetMutableTestCase(int i) {
275      const int index = GetElementOr(test_case_indices_, i, -1);
276      return index < 0 ? NULL : test_cases_[index];
277    }
278    TestEventListeners* listeners() { return &listeners_; }
279    TestResult* current_test_result();
280    const TestResult* ad_hoc_test_result() const { return &ad_hoc_test_result_; }
281    void set_os_stack_trace_getter(OsStackTraceGetterInterface* getter);
282    OsStackTraceGetterInterface* os_stack_trace_getter();
283    std::string CurrentOsStackTraceExceptTop(int skip_count) GTEST_NO_INLINE_;
284    TestCase* GetTestCase(const char* test_case_name,
285                          const char* type_param,
286                          Test::SetUpTestCaseFunc set_up_tc,
287                          Test::TearDownTestCaseFunc tear_down_tc);
288    void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,
289                     Test::TearDownTestCaseFunc tear_down_tc,
290                     TestInfo* test_info) {
291      if (original_working_dir_.IsEmpty()) {
292        original_working_dir_.Set(FilePath::GetCurrentDir());
293        GTEST_CHECK_(!original_working_dir_.IsEmpty())
294            << "Failed to get the current working directory.";
295      }
296      GetTestCase(test_info->test_case_name(),
297                  test_info->type_param(),
298                  set_up_tc,
299                  tear_down_tc)->AddTestInfo(test_info);
300    }
301  #if GTEST_HAS_PARAM_TEST
302    internal::ParameterizedTestCaseRegistry& parameterized_test_registry() {
303      return parameterized_test_registry_;
304    }
305  #endif  
306    void set_current_test_case(TestCase* a_current_test_case) {
307      current_test_case_ = a_current_test_case;
308    }
309    void set_current_test_info(TestInfo* a_current_test_info) {
310      current_test_info_ = a_current_test_info;
311    }
312    void RegisterParameterizedTests();
313    bool RunAllTests();
314    void ClearNonAdHocTestResult() {
315      ForEach(test_cases_, TestCase::ClearTestCaseResult);
316    }
317    void ClearAdHocTestResult() {
318      ad_hoc_test_result_.Clear();
319    }
320    void RecordProperty(const TestProperty& test_property);
321    enum ReactionToSharding {
322      HONOR_SHARDING_PROTOCOL,
323      IGNORE_SHARDING_PROTOCOL
324    };
325    int FilterTests(ReactionToSharding shard_tests);
326    void ListTestsMatchingFilter();
327    const TestCase* current_test_case() const { return current_test_case_; }
328    TestInfo* current_test_info() { return current_test_info_; }
329    const TestInfo* current_test_info() const { return current_test_info_; }
330    std::vector<Environment*>& environments() { return environments_; }
331    std::vector<TraceInfo>& gtest_trace_stack() {
332      return *(gtest_trace_stack_.pointer());
333    }
334    const std::vector<TraceInfo>& gtest_trace_stack() const {
335      return gtest_trace_stack_.get();
336    }
337  #if GTEST_HAS_DEATH_TEST
338    void InitDeathTestSubprocessControlInfo() {
339      internal_run_death_test_flag_.reset(ParseInternalRunDeathTestFlag());
340    }
341    const InternalRunDeathTestFlag* internal_run_death_test_flag() const {
342      return internal_run_death_test_flag_.get();
343    }
344    internal::DeathTestFactory* death_test_factory() {
345      return death_test_factory_.get();
346    }
347    void SuppressTestEventsIfInSubprocess();
348    friend class ReplaceDeathTestFactory;
349  #endif  
350    void ConfigureXmlOutput();
351  #if GTEST_CAN_STREAM_RESULTS_
352    void ConfigureStreamingOutput();
353  #endif
354    void PostFlagParsingInit();
355    int random_seed() const { return random_seed_; }
356    internal::Random* random() { return &random_; }
357    void ShuffleTests();
358    void UnshuffleTests();
359    bool catch_exceptions() const { return catch_exceptions_; }
360   private:
361    friend class ::testing::UnitTest;
362    void set_catch_exceptions(bool value) { catch_exceptions_ = value; }
363    UnitTest* const parent_;
364    internal::FilePath original_working_dir_;
365    DefaultGlobalTestPartResultReporter default_global_test_part_result_reporter_;
366    DefaultPerThreadTestPartResultReporter
367        default_per_thread_test_part_result_reporter_;
368    TestPartResultReporterInterface* global_test_part_result_repoter_;
369    internal::Mutex global_test_part_result_reporter_mutex_;
370    internal::ThreadLocal<TestPartResultReporterInterface*>
371        per_thread_test_part_result_reporter_;
372    std::vector<Environment*> environments_;
373    std::vector<TestCase*> test_cases_;
374    std::vector<int> test_case_indices_;
375  #if GTEST_HAS_PARAM_TEST
376    internal::ParameterizedTestCaseRegistry parameterized_test_registry_;
377    bool parameterized_tests_registered_;
378  #endif  
379    int last_death_test_case_;
380    TestCase* current_test_case_;
381    TestInfo* current_test_info_;
382    TestResult ad_hoc_test_result_;
383    TestEventListeners listeners_;
384    OsStackTraceGetterInterface* os_stack_trace_getter_;
385    bool post_flag_parse_init_performed_;
386    int random_seed_;
387    internal::Random random_;
388    TimeInMillis start_timestamp_;
389    TimeInMillis elapsed_time_;
390  #if GTEST_HAS_DEATH_TEST
391    internal::scoped_ptr<InternalRunDeathTestFlag> internal_run_death_test_flag_;
392    internal::scoped_ptr<internal::DeathTestFactory> death_test_factory_;
393  #endif  
394    internal::ThreadLocal<std::vector<TraceInfo> > gtest_trace_stack_;
395    bool catch_exceptions_;
396    GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTestImpl);
397  };  
398  inline UnitTestImpl* GetUnitTestImpl() {
399    return UnitTest::GetInstance()->impl();
400  }
401  #if GTEST_USES_SIMPLE_RE
402  GTEST_API_ bool IsInSet(char ch, const char* str);
403  GTEST_API_ bool IsAsciiDigit(char ch);
404  GTEST_API_ bool IsAsciiPunct(char ch);
405  GTEST_API_ bool IsRepeat(char ch);
406  GTEST_API_ bool IsAsciiWhiteSpace(char ch);
407  GTEST_API_ bool IsAsciiWordChar(char ch);
<span onclick='openModal()' class='match'>408  GTEST_API_ bool IsValidEscape(char ch);
409  GTEST_API_ bool AtomMatchesChar(bool escaped, char pattern, char ch);
410  GTEST_API_ bool ValidateRegex(const char* regex);
411  GTEST_API_ bool MatchRegexAtHead(const char* regex, const char* str);
412  GTEST_API_ bool MatchRepetitionAndRegexAtHead(
413      bool escaped, char ch, char repeat, const char* regex, const char* str);
414  GTEST_API_ bool MatchRegexAnywhere(const char* regex, const char* str);
</span>415  #endif  
416  GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, char** argv);
417  GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv);
418  #if GTEST_HAS_DEATH_TEST
419  GTEST_API_ std::string GetLastErrnoDescription();
420  # if GTEST_OS_WINDOWS
421  class AutoHandle {
422   public:
423    AutoHandle() : handle_(INVALID_HANDLE_VALUE) {}
424    explicit AutoHandle(HANDLE handle) : handle_(handle) {}
425    ~AutoHandle() { Reset(); }
426    HANDLE Get() const { return handle_; }
427    void Reset() { Reset(INVALID_HANDLE_VALUE); }
428    void Reset(HANDLE handle) {
429      if (handle != handle_) {
430        if (handle_ != INVALID_HANDLE_VALUE)
431          ::CloseHandle(handle_);
432        handle_ = handle;
433      }
434    }
435   private:
436    HANDLE handle_;
437    GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);
438  };
439  # endif  
440  template <typename Integer>
441  bool ParseNaturalNumber(const ::std::string& str, Integer* number) {
442    if (str.empty() || !IsDigit(str[0])) {
443      return false;
444    }
445    errno = 0;
446    char* end;
447  # if GTEST_OS_WINDOWS && !defined(__GNUC__)
448    typedef unsigned __int64 BiggestConvertible;
449    const BiggestConvertible parsed = _strtoui64(str.c_str(), &end, 10);
450  # else
451    typedef unsigned long long BiggestConvertible;  
452    const BiggestConvertible parsed = strtoull(str.c_str(), &end, 10);
453  # endif  
454    const bool parse_success = *end == '\0' && errno == 0;
455    GTEST_CHECK_(sizeof(Integer) <= sizeof(parsed));
456    const Integer result = static_cast<Integer>(parsed);
457    if (parse_success && static_cast<BiggestConvertible>(result) == parsed) {
458      *number = result;
459      return true;
460    }
461    return false;
462  }
463  #endif  
464  class TestResultAccessor {
465   public:
466    static void RecordProperty(TestResult* test_result,
467                               const std::string& xml_element,
468                               const TestProperty& property) {
469      test_result->RecordProperty(xml_element, property);
470    }
471    static void ClearTestPartResults(TestResult* test_result) {
472      test_result->ClearTestPartResults();
473    }
474    static const std::vector<testing::TestPartResult>& test_part_results(
475        const TestResult& test_result) {
476      return test_result.test_part_results();
477    }
478  };
479  #if GTEST_CAN_STREAM_RESULTS_
480  class StreamingListener : public EmptyTestEventListener {
481   public:
482    class AbstractSocketWriter {
483     public:
484      virtual ~AbstractSocketWriter() {}
485      virtual void Send(const string& message) = 0;
486      virtual void CloseConnection() {}
487      void SendLn(const string& message) {
488        Send(message + "\n");
489      }
490    };
491    class SocketWriter : public AbstractSocketWriter {
492     public:
493      SocketWriter(const string& host, const string& port)
494          : sockfd_(-1), host_name_(host), port_num_(port) {
495        MakeConnection();
496      }
497      virtual ~SocketWriter() {
498        if (sockfd_ != -1)
499          CloseConnection();
500      }
501      virtual void Send(const string& message) {
502        GTEST_CHECK_(sockfd_ != -1)
503            << "Send() can be called only when there is a connection.";
504        const int len = static_cast<int>(message.length());
505        if (write(sockfd_, message.c_str(), len) != len) {
506          GTEST_LOG_(WARNING)
507              << "stream_result_to: failed to stream to "
508              << host_name_ << ":" << port_num_;
509        }
510      }
511     private:
512      void MakeConnection();
513      void CloseConnection() {
514        GTEST_CHECK_(sockfd_ != -1)
515            << "CloseConnection() can be called only when there is a connection.";
516        close(sockfd_);
517        sockfd_ = -1;
518      }
519      int sockfd_;  
520      const string host_name_;
521      const string port_num_;
522      GTEST_DISALLOW_COPY_AND_ASSIGN_(SocketWriter);
523    };  
524    static string UrlEncode(const char* str);
525    StreamingListener(const string& host, const string& port)
526        : socket_writer_(new SocketWriter(host, port)) { Start(); }
527    explicit StreamingListener(AbstractSocketWriter* socket_writer)
528        : socket_writer_(socket_writer) { Start(); }
529    void OnTestProgramStart(const UnitTest& &bsol;* unit_test */) {
530      SendLn("event=TestProgramStart");
531    }
532    void OnTestProgramEnd(const UnitTest& unit_test) {
533      SendLn("event=TestProgramEnd&passed=" + FormatBool(unit_test.Passed()));
534      socket_writer_->CloseConnection();
535    }
536    void OnTestIterationStart(const UnitTest& &bsol;* unit_test */, int iteration) {
537      SendLn("event=TestIterationStart&iteration=" +
538             StreamableToString(iteration));
539    }
540    void OnTestIterationEnd(const UnitTest& unit_test, int &bsol;* iteration */) {
541      SendLn("event=TestIterationEnd&passed=" +
542             FormatBool(unit_test.Passed()) + "&elapsed_time=" +
543             StreamableToString(unit_test.elapsed_time()) + "ms");
544    }
545    void OnTestCaseStart(const TestCase& test_case) {
546      SendLn(std::string("event=TestCaseStart&name=") + test_case.name());
547    }
548    void OnTestCaseEnd(const TestCase& test_case) {
549      SendLn("event=TestCaseEnd&passed=" + FormatBool(test_case.Passed())
550             + "&elapsed_time=" + StreamableToString(test_case.elapsed_time())
551             + "ms");
552    }
553    void OnTestStart(const TestInfo& test_info) {
554      SendLn(std::string("event=TestStart&name=") + test_info.name());
555    }
556    void OnTestEnd(const TestInfo& test_info) {
557      SendLn("event=TestEnd&passed=" +
558             FormatBool((test_info.result())->Passed()) +
559             "&elapsed_time=" +
560             StreamableToString((test_info.result())->elapsed_time()) + "ms");
561    }
562    void OnTestPartResult(const TestPartResult& test_part_result) {
563      const char* file_name = test_part_result.file_name();
564      if (file_name == NULL)
565        file_name = "";
566      SendLn("event=TestPartResult&file=" + UrlEncode(file_name) +
567             "&line=" + StreamableToString(test_part_result.line_number()) +
568             "&message=" + UrlEncode(test_part_result.message()));
569    }
570   private:
571    void SendLn(const string& message) { socket_writer_->SendLn(message); }
572    void Start() { SendLn("gtest_streaming_protocol_version=1.0"); }
573    string FormatBool(bool value) { return value ? "1" : "0"; }
574    const scoped_ptr<AbstractSocketWriter> socket_writer_;
575    GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamingListener);
576  };  
577  #endif  
578  }  
579  }  
580  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.h</h3>
            <pre><code>1  #ifndef snap_kronecker_h
2  #define snap_kronecker_h
3  #include "Snap.h"
4  class TKroneckerLL;
5  typedef TPt<TKroneckerLL> PKroneckerLL;
6  class TKronMtx {
7  public:
8    static const double NInf;
9    static TRnd Rnd;
10  private:
11    TInt MtxDim;
12    TFltV SeedMtx;
13  public:
14    TKronMtx() : MtxDim(-1), SeedMtx() { }
15    TKronMtx(const int& Dim) : MtxDim(Dim), SeedMtx(Dim*Dim) { }
16    TKronMtx(const TFltV& SeedMatrix);
17    TKronMtx(const TKronMtx& Kronecker) : MtxDim(Kronecker.MtxDim), SeedMtx(Kronecker.SeedMtx) { }
18    void SaveTxt(const TStr& OutFNm) const;
19    TKronMtx& operator = (const TKronMtx& Kronecker);
20    bool operator == (const TKronMtx& Kronecker) const { return SeedMtx==Kronecker.SeedMtx; }
21    int GetPrimHashCd() const { return SeedMtx.GetPrimHashCd(); }
22    int GetSecHashCd() const { return SeedMtx.GetSecHashCd(); }
23    int GetDim() const { return MtxDim; }
24    int Len() const { return SeedMtx.Len(); }
25    bool Empty() const { return SeedMtx.Empty(); }
26    bool IsProbMtx() const; 
27    TFltV& GetMtx() { return SeedMtx; }
28    const TFltV& GetMtx() const { return SeedMtx; }
29    void SetMtx(const TFltV& ParamV) { SeedMtx = ParamV; }
30    void SetRndMtx(const int& MtxDim, const double& MinProb = 0.0);
31    void PutAllMtx(const double& Val) { SeedMtx.PutAll(Val); }
32    void GenMtx(const int& Dim) { MtxDim=Dim;  SeedMtx.Gen(Dim*Dim); }
33    void SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val=1, const int& Eps0Val=0);
34    void SetForEdges(const int& Nodes, const int& Edges); 
35    void AddRndNoise(const double& SDev);
36    TStr GetMtxStr() const;
37    const double& At(const int& Row, const int& Col) const { return SeedMtx[MtxDim*Row+Col].Val; }
38    double& At(const int& Row, const int& Col) { return SeedMtx[MtxDim*Row+Col].Val; }
39    const double& At(const int& ValN) const { return SeedMtx[ValN].Val; }
40    double& At(const int& ValN) { return SeedMtx[ValN].Val; }
41    int GetNodes(const int& NIter) const;
42    int GetEdges(const int& NIter) const;
43    int GetKronIter(const int& Nodes) const;
44    int GetNZeroK(const PNGraph& Graph) const; 
45    double GetEZero(const int& Edges, const int& KronIter) const;
46    double GetMtxSum() const;
47    double GetRowSum(const int& RowId) const;
48    double GetColSum(const int& ColId) const;
49    void ToOneMinusMtx();
50    void GetLLMtx(TKronMtx& LLMtx);
51    void GetProbMtx(TKronMtx& ProbMtx);
52    void Swap(TKronMtx& KronMtx);
53    double GetEdgeProb(int NId1, int NId2, const int& NKronIters) const; 
54    double GetNoEdgeProb(int NId1, int NId2, const int& NKronIters) const; 
55    double GetEdgeLL(int NId1, int NId2, const int& NKronIters) const; 
56    double GetNoEdgeLL(int NId1, int NId2, const int& NKronIters) const; 
57    double GetApxNoEdgeLL(int NId1, int NId2, const int& NKronIters) const; 
58    bool IsEdgePlace(int NId1, int NId2, const int& NKronIters, const double& ProbTresh) const; 
<span onclick='openModal()' class='match'>59    double GetEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
60    double GetNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
61    double GetApxNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
</span>62    static uint GetNodeSig(const double& OneProb = 0.5);
63    double GetEdgeProb(const uint& NId1Sig, const uint& NId2Sig, const int& NIter) const;
64    PNGraph GenThreshGraph(const double& Thresh) const;
65    PNGraph GenRndGraph(const double& RndFact=1.0) const;
66    static int GetKronIter(const int& GNodes, const int& SeedMtxSz);
67    static PNGraph GenKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir, const int& Seed=0);
68    static PNGraph GenFastKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir, const int& Seed=0);
69    static PNGraph GenFastKronecker(const TKronMtx& SeedMtx, const int& NIter, const int& Edges, const bool& IsDir, const int& Seed=0);
70    static PNGraph GenDetKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir);
71    static void PlotCmpGraphs(const TKronMtx& SeedMtx, const PNGraph& Graph, const TStr& OutFNm, const TStr& Desc);
72    static void PlotCmpGraphs(const TKronMtx& SeedMtx1, const TKronMtx& SeedMtx2, const PNGraph& Graph, const TStr& OutFNm, const TStr& Desc);
73    static void PlotCmpGraphs(const TVec<TKronMtx>& SeedMtxV, const PNGraph& Graph, const TStr& FNmPref, const TStr& Desc);
74    static void KronMul(const TKronMtx& LeftPt, const TKronMtx& RightPt, TKronMtx& OutMtx);
75    static void KronSum(const TKronMtx& LeftPt, const TKronMtx& RightPt, TKronMtx& OutMtx); 
76    static void KronPwr(const TKronMtx& KronPt, const int& NIter, TKronMtx& OutMtx);
77    void Dump(const TStr& MtxNm = TStr(), const bool& Sort = false) const;
78    static double GetAvgAbsErr(const TKronMtx& Kron1, const TKronMtx& Kron2); 
79    static double GetAvgFroErr(const TKronMtx& Kron1, const TKronMtx& Kron2); 
80    static TKronMtx GetMtx(TStr MatlabMtxStr);
81    static TKronMtx GetRndMtx(const int& Dim, const double& MinProb);
82    static TKronMtx GetInitMtx(const int& Dim, const int& Nodes, const int& Edges);
83    static TKronMtx GetInitMtx(const TStr& MtxStr, const int& Dim, const int& Nodes, const int& Edges);
84    static TKronMtx GetMtxFromNm(const TStr& MtxNm);
85    static TKronMtx LoadTxt(const TStr& MtxFNm);
86    static void PutRndSeed(const int& Seed) { TKronMtx::Rnd.PutSeed(Seed); }
87  };
88  enum TKronEMType {  kronNodeMiss = 0, kronFutureLink, kronEdgeMiss }; 
89  class TKroneckerLL {
90  public:
91  private:
92    TCRef CRef;
93    PNGraph Graph;         
94    TInt Nodes, KronIters;
95    TFlt PermSwapNodeProb; 
96    TIntTrV GEdgeV;        
97    TIntTrV LEdgeV;        
98    TInt LSelfEdge;        
99    TIntV NodePerm;        
100    TIntV InvertPerm;      
101    TInt RealNodes;	
102    TInt RealEdges;	
103    TKronMtx ProbMtx, LLMtx; 
104    TFlt LogLike; 
105    TFltV GradV;  
106    TKronEMType EMType;	
107    TInt MissEdges;		
108    TBool DebugMode;		
109    TFltV LLV;			
110    TVec<TKronMtx> MtxV;	
111  public:
112    TKroneckerLL() : Nodes(-1), KronIters(-1), PermSwapNodeProb(0.2), RealNodes(-1), RealEdges(-1), LogLike(TKronMtx::NInf), EMType(kronNodeMiss), MissEdges(-1), DebugMode(false) { }
113    TKroneckerLL(const PNGraph& GraphPt, const TFltV& ParamV, const double& PermPSwapNd=0.2);
114    TKroneckerLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const double& PermPSwapNd=0.2);
115    TKroneckerLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const TIntV& NodeIdPermV, const double& PermPSwapNd=0.2);
116    static PKroneckerLL New() { return new TKroneckerLL(); }
117    static PKroneckerLL New(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const double& PermPSwapNd=0.1);
118    static PKroneckerLL New(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const TIntV& NodeIdPermV, const double& PermPSwapNd=0.2);
119    int GetNodes() const { return Nodes; }
120    int GetKronIters() const { return KronIters; }
121    PNGraph GetGraph() const { return Graph; }
122    void SetGraph(const PNGraph& GraphPt);
123    const TKronMtx& GetProbMtx() const { return ProbMtx; }
124    const TKronMtx& GetLLMtx() const { return LLMtx; }
125    int GetParams() const { return ProbMtx.Len(); }
126    int GetDim() const { return ProbMtx.GetDim(); }
127    void SetDebug(const bool Debug) { DebugMode = Debug; }
128    const TFltV& GetLLHist() const { return LLV; }
129    const TVec<TKronMtx>& GetParamHist() const { return MtxV; }
130    bool IsObsNode(const int& NId) const { IAssert(RealNodes > 0);	return (NId < RealNodes);	}
131    bool IsObsEdge(const int& NId1, const int& NId2) const { IAssert(RealNodes > 0);	return ((NId1 < RealNodes) && (NId2 < RealNodes));	}
132    bool IsLatentNode(const int& NId) const { return !IsObsNode(NId);	}
133    bool IsLatentEdge(const int& NId1, const int& NId2) const { return !IsObsEdge(NId1, NId2);	}
134    void SetPerm(const char& PermId);
135    void SetOrderPerm(); 
136    void SetRndPerm();   
137    void SetDegPerm();   
138    void SetBestDegPerm();	
139    void SetPerm(const TIntV& NodePermV) { NodePerm = NodePermV; SetIPerm(NodePerm); }
140    void SetIPerm(const TIntV& Perm);	
141    const TIntV& GetPermV() const { return NodePerm; }
142    void AppendIsoNodes();
143    void RestoreGraph(const bool RestoreNodes = true);
144    double GetFullGraphLL() const;
145    double GetFullRowLL(int RowId) const;
146    double GetFullColLL(int ColId) const;
147    double GetEmptyGraphLL() const;
148    double GetApxEmptyGraphLL() const;
149    void InitLL(const TFltV& ParamV);
150    void InitLL(const TKronMtx& ParamMtx);
151    void InitLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx);
152    double CalcGraphLL();
153    double CalcApxGraphLL();
154    double GetLL() const { return LogLike; }
155    double GetAbsErr() const { return fabs(pow((double)Graph->GetEdges(), 1.0/double(KronIters)) - ProbMtx.GetMtxSum()); }
156    double NodeLLDelta(const int& NId) const;
157    double SwapNodesLL(const int& NId1, const int& NId2);
158    bool SampleNextPerm(int& NId1, int& NId2); 
159    double GetEmptyGraphDLL(const int& ParamId) const;
160    double GetApxEmptyGraphDLL(const int& ParamId) const;
161    const TFltV& CalcGraphDLL();
162    const TFltV& CalcFullApxGraphDLL();
163    const TFltV& CalcApxGraphDLL();
164    double NodeDLLDelta(const int ParamId, const int& NId) const;
165    void UpdateGraphDLL(const int& SwapNId1, const int& SwapNId2);
166    const TFltV& GetDLL() const { return GradV; }
167    double GetDLL(const int& ParamId) const { return GradV[ParamId]; }
168    void SampleGradient(const int& WarmUp, const int& NSamples, double& AvgLL, TFltV& GradV);
169    double GradDescent(const int& NIter, const double& LrnRate, double MnStep, double MxStep, const int& WarmUp, const int& NSamples);
170    double GradDescent2(const int& NIter, const double& LrnRate, double MnStep, double MxStep, const int& WarmUp, const int& NSamples);
171    void SetRandomEdges(const int& NEdges, const bool isDir = true);
172    void MetroGibbsSampleSetup(const int& WarmUp);
173    void MetroGibbsSampleNext(const int& WarmUp, const bool DLLUpdate = false);
174    void RunEStep(const int& GibbsWarmUp, const int& WarmUp, const int& NSamples, TFltV& LLV, TVec<TFltV>& DLLV);
175    double RunMStep(const TFltV& LLV, const TVec<TFltV>& DLLV, const int& GradIter, const double& LrnRate, double MnStep, double MxStep);
176    void RunKronEM(const int& EMIter, const int& GradIter, double LrnRate, double MnStep, double MxStep, const int& GibbsWarmUp, const int& WarmUp, const int& NSamples, const TKronEMType& Type = kronNodeMiss, const int& NMissing = -1);
177    TFltV TestSamplePerm(const TStr& OutFNm, const int& WarmUp, const int& NSamples, const TKronMtx& TrueMtx, const bool& DoPlot=true);
178    static double CalcChainR2(const TVec<TFltV>& ChainLLV);
179    static void ChainGelmapRubinPlot(const TVec<TFltV>& ChainLLV, const TStr& OutFNm, const TStr& Desc);
180    TFltQu TestKronDescent(const bool& DoExact, const bool& TruePerm, double LearnRate, const int& WarmUp, const int& NSamples, const TKronMtx& TrueParam);
181    void GradDescentConvergence(const TStr& OutFNm, const TStr& Desc1, const bool& SamplePerm, const int& NIters,
182      double LearnRate, const int& WarmUp, const int& NSamples, const int& AvgKGraphs, const TKronMtx& TrueParam);
183    static void TestBicCriterion(const TStr& OutFNm, const TStr& Desc1, const PNGraph& G, const int& GradIters,
184      double LearnRate, const int& WarmUp, const int& NSamples, const int& TrueN0);
185    static void TestGradDescent(const int& KronIters, const int& KiloSamples, const TStr& Permutation);
186    friend class TPt<TKroneckerLL>;
187  };
188  class TKronNoise {
189  public:
190  	TKronNoise() {};
191  	static int RemoveNodeNoise(PNGraph& Graph, const int& NNodes, const bool Random = true);
192  	static int RemoveNodeNoise(PNGraph& Graph, const double& Rate, const bool Random = true);
193  	static int FlipEdgeNoise(PNGraph& Graph, const int& NEdges, const bool Random = true);
194  	static int FlipEdgeNoise(PNGraph& Graph, const double& Rate, const bool Random = true);
195  	static int RemoveEdgeNoise(PNGraph& Graph, const int& NEdges);
196  	static int RemoveEdgeNoise(PNGraph& Graph, const double& Rate);
197  };
198  class TKronMaxLL {
199  public:
200    class TFEval {
201    public:
202      TFlt LogLike;
203      TFltV GradV;
204    public:
205      TFEval() : LogLike(0), GradV() { }
206      TFEval(const TFlt& LL, const TFltV& DLL) : LogLike(LL), GradV(DLL) { }
207      TFEval(const TFEval& FEval) : LogLike(FEval.LogLike), GradV(FEval.GradV) { }
208      TFEval& operator = (const TFEval& FEval) { if (this!=&FEval) {
209        LogLike=FEval.LogLike; GradV=FEval.GradV; } return *this; }
210    };
211  private:
212    THash<TKronMtx, TFEval> FEvalH; 
213    TKroneckerLL KronLL;
214  public:
215    TKronMaxLL(const PNGraph& GraphPt, const TKronMtx& StartParam) : KronLL(GraphPt, StartParam) { }
216    void SetPerm(const char& PermId);
217    void GradDescent(const int& NIter, const double& LrnRate, const double& MnStep, const double& MxStep,
218      const double& WarmUp, const double& NSamples);
219    static void RoundTheta(const TFltV& ThetaV, TFltV& NewThetaV);
220    static void RoundTheta(const TFltV& ThetaV, TKronMtx& Kronecker);
221    static void Test();
222  };
223  class TKronMomentsFit {
224  public:
225    double Edges, Hairpins, Tripins, Triads;
226  public:
227    TKronMomentsFit(const PUNGraph& G) {
228      Edges=0; Hairpins=0; Tripins=0; Triads=0;
229      for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
230        const int d = NI.GetOutDeg();
231        Edges += d;
232        Hairpins += d*(d-1.0);
233        Tripins += d*(d-1.0)*(d-2.0);
234      }
235      Edges /= 2.0;
236      Hairpins /= 2.0;
237      Tripins /= 6.0;
238      int64 ot,ct;
239      Triads = (int) TSnap::GetTriads(G, ot, ct)/3.0;
240      printf("E:%g\tH:%g\tT:%g\tD:%g\n", Edges, Hairpins, Tripins, Triads);
241    }
242    TFltQu EstABC(const int& R) {
243      const double Step = 0.01;
244      double MinScore=TFlt::Mx;
245      double A=0, B=0, C=0;
246      for (double a = 1.0; a > Step; a-=Step) {
247        for (double b = Step; b <= 1.0; b+=Step) {
248          for (double c = Step; c <= a; c+=Step) {
249            double EE = ( pow(a+2*b+c, R) - pow(a+c, R) ) / 2.0;
250            double EH = ( pow(pow(a+b,2) + pow(b+c,2), R)
251                               -2*pow(a*(a+b)+c*(c+b), R)
252                               -pow(a*a + 2*b*b + c*c, R)
253                               +2*pow(a*a + c*c, R) ) / 2.0;
254            double ET = ( pow(pow(a+b,3)+pow(b+c,3), R)
255                               -3*pow(a*pow(a+b,2)+c*pow(b+c,2), R)
256                               -3*pow(a*a*a + c*c*c + b*(a*a+c*c) + b*b*(a+c) + 2*b*b*b ,R)
257                               +2*pow(a*a*a + 2*b*b*b + c*c*c, R)
258                               +5*pow(a*a*a + c*c*c + b*b*(a+c), R)
259                               +4*pow(a*a*a + c*c*c + b*(a*a+c*c), R)
260                               -6*pow(a*a*a + c*c*c, R) ) / 6.0;
261            double ED = ( pow(a*a*a + 3*b*b*(a+c) + c*c*c, R)
262                               -3*pow(a*(a*a+b*b) + c*(b*b+c*c), R)
263                               +2*pow(a*a*a+c*c*c, R) ) / 6.0;
264            if (EE < 0) { EE = 1; }
265            if (EH < 0) { EH = 1; }
266            if (ET < 0) { ET = 1; }
267            if (ED < 0) { ED = 1; }
268            double Score = pow(Edges-EE,2)/EE + pow(Hairpins-EH ,2)/EH + pow(Tripins-ET, 2)/ET + pow(Triads-ED, 2)/ED;
269            if (MinScore > Score || (a==0.9 && b==0.6 && c==0.2) || (TMath::IsInEps(a-0.99,1e-6) && TMath::IsInEps(b-0.57,1e-6) && TMath::IsInEps(c-0.05,1e-6)))
270            {
271              printf("%.03f %.03f %0.03f %10.4f  %10.10g\t%10.10g\t%10.10g\t%10.10g\n", a,b,c, log10(Score), EE, EH, ET, ED);
272              A=a; B=b; C=c; MinScore=Score;
273            }
274          }
275        }
276      }
277      printf("\t\t\t      %10.10g\t%10.10g\t%10.10g\t%10.10g\n", Edges, Hairpins, Tripins, Triads);
278      return TFltQu(A,B,C,MinScore);
279    }
280    static void Test() {
281      TFIn FIn("as20.ngraph");
282      PUNGraph G = TSnap::ConvertGraph<PUNGraph>(TNGraph::Load(FIn));
283      TSnap::PrintInfo(G);
284      TSnap::DelSelfEdges(G);
285      TSnap::PrintInfo(G);
286      TKronMomentsFit Fit(G);
287      printf("iter %d\n", TKronMtx::GetKronIter(G->GetNodes(), 2));
288      Fit.EstABC(TKronMtx::GetKronIter(G->GetNodes(), 2)); /&bsol;*/
289    }
290  };
291  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal-inl.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.h</div>
                <div class="column column_space"><pre><code>408  GTEST_API_ bool IsValidEscape(char ch);
409  GTEST_API_ bool AtomMatchesChar(bool escaped, char pattern, char ch);
410  GTEST_API_ bool ValidateRegex(const char* regex);
411  GTEST_API_ bool MatchRegexAtHead(const char* regex, const char* str);
412  GTEST_API_ bool MatchRepetitionAndRegexAtHead(
413      bool escaped, char ch, char repeat, const char* regex, const char* str);
414  GTEST_API_ bool MatchRegexAnywhere(const char* regex, const char* str);
</pre></code></div>
                <div class="column column_space"><pre><code>59    double GetEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
60    double GetNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
61    double GetApxNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    