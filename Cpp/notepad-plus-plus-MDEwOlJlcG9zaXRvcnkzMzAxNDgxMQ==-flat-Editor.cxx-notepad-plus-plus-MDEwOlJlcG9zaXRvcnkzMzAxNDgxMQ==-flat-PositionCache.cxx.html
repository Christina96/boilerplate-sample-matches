
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cassert>
5  #include <cstring>
6  #include <cstdio>
7  #include <cmath>
8  #include <stdexcept>
9  #include <string>
10  #include <string_view>
11  #include <vector>
12  #include <map>
13  #include <set>
14  #include <forward_list>
15  #include <optional>
16  #include <algorithm>
17  #include <iterator>
18  #include <memory>
19  #include <chrono>
20  #include <atomic>
21  #include <mutex>
22  #include <thread>
23  #include <future>
24  #include "ScintillaTypes.h"
25  #include "ScintillaMessages.h"
26  #include "ScintillaStructures.h"
27  #include "ILoader.h"
28  #include "ILexer.h"
29  #include "Debugging.h"
30  #include "Geometry.h"
31  #include "Platform.h"
32  #include "CharacterType.h"
33  #include "CharacterCategoryMap.h"
34  #include "Position.h"
35  #include "UniqueString.h"
36  #include "SplitVector.h"
37  #include "Partitioning.h"
38  #include "RunStyles.h"
39  #include "ContractionState.h"
40  #include "CellBuffer.h"
41  #include "PerLine.h"
42  #include "KeyMap.h"
43  #include "Indicator.h"
44  #include "LineMarker.h"
45  #include "Style.h"
46  #include "ViewStyle.h"
47  #include "CharClassify.h"
48  #include "Decoration.h"
49  #include "CaseFolder.h"
50  #include "Document.h"
51  #include "UniConversion.h"
52  #include "DBCS.h"
53  #include "Selection.h"
54  #include "PositionCache.h"
55  #include "EditModel.h"
56  #include "MarginView.h"
57  #include "EditView.h"
58  #include "Editor.h"
59  #include "ElapsedPeriod.h"
60  using namespace Scintilla;
61  using namespace Scintilla::Internal;
62  namespace {
63  constexpr bool CanDeferToLastStep(const DocModification &mh) noexcept {
64  	if (FlagSet(mh.modificationType, (ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete)))
65  		return true;	
66  	if (!FlagSet(mh.modificationType, (ModificationFlags::Undo | ModificationFlags::Redo)))
67  		return false;	
68  	if (FlagSet(mh.modificationType, ModificationFlags::MultiStepUndoRedo))
69  		return true;	
70  	return false;		
71  }
72  constexpr bool CanEliminate(const DocModification &mh) noexcept {
73  	return
74  		FlagSet(mh.modificationType, (ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete));
75  }
76  constexpr bool IsLastStep(const DocModification &mh) noexcept {
77  	return
78  		FlagSet(mh.modificationType, (ModificationFlags::Undo | ModificationFlags::Redo))
79  	    && (FlagSet(mh.modificationType, ModificationFlags::MultiStepUndoRedo))
80  	    && (FlagSet(mh.modificationType, ModificationFlags::LastStepInUndoRedo))
81  	    && (FlagSet(mh.modificationType, ModificationFlags::MultilineUndoRedo));
82  }
83  }
84  Timer::Timer() noexcept :
85  		ticking(false), ticksToWait(0), tickerID{} {}
86  Idler::Idler() noexcept :
87  		state(false), idlerID(nullptr) {}
88  static constexpr bool IsAllSpacesOrTabs(std::string_view sv) noexcept {
89  	for (const char ch : sv) {
90  		if (!IsSpaceOrTab(ch))
91  			return false;
92  	}
93  	return true;
94  }
95  Editor::Editor() : durationWrapOneByte(0.000001, 0.00000001, 0.00001) {
96  	ctrlID = 0;
97  	stylesValid = false;
98  	technology = Technology::Default;
99  	scaleRGBAImage = 100.0f;
100  	cursorMode = CursorShape::Normal;
101  	errorStatus = Status::Ok;
102  	mouseDownCaptures = true;
103  	mouseWheelCaptures = true;
104  	lastClickTime = 0;
105  	doubleClickCloseThreshold = Point(3, 3);
106  	dwellDelay = TimeForever;
107  	ticksToDwell = TimeForever;
108  	dwelling = false;
109  	ptMouseLast.x = 0;
110  	ptMouseLast.y = 0;
111  	inDragDrop = DragDrop::none;
112  	dropWentOutside = false;
113  	posDrop = SelectionPosition(Sci::invalidPosition);
114  	hotSpotClickPos = Sci::invalidPosition;
115  	selectionUnit = TextUnit::character;
116  	lastXChosen = 0;
117  	lineAnchorPos = 0;
118  	originalAnchorPos = 0;
119  	wordSelectAnchorStartPos = 0;
120  	wordSelectAnchorEndPos = 0;
121  	wordSelectInitialCaretPos = -1;
122  	caretPolicies.x = { CaretPolicy::Slop | CaretPolicy::Even, 50 };
123  	caretPolicies.y = { CaretPolicy::Even, 0 };
124  	visiblePolicy = { 0, 0 };
125  	searchAnchor = 0;
126  	xCaretMargin = 50;
127  	horizontalScrollBarVisible = true;
128  	scrollWidth = 2000;
129  	verticalScrollBarVisible = true;
130  	endAtLastLine = true;
131  	caretSticky = CaretSticky::Off;
132  	marginOptions = MarginOption::None;
133  	mouseSelectionRectangularSwitch = false;
134  	multipleSelection = false;
135  	additionalSelectionTyping = false;
136  	multiPasteMode = MultiPaste::Once;
137  	virtualSpaceOptions = VirtualSpace::None;
138  	targetRange = SelectionSegment();
139  	searchFlags = FindOption::None;
140  	topLine = 0;
141  	posTopLine = 0;
142  	lengthForEncode = -1;
143  	needUpdateUI = Update::None;
144  	ContainerNeedsUpdate(Update::Content);
145  	paintState = PaintState::notPainting;
146  	paintAbandonedByStyling = false;
147  	paintingAllText = false;
148  	willRedrawAll = false;
149  	idleStyling = IdleStyling::None;
150  	needIdleStyling = false;
151  	modEventMask = ModificationFlags::EventMaskAll;
152  	commandEvents = true;
153  	pdoc->AddWatcher(this, nullptr);
154  	recordingMacro = false;
155  	foldAutomatic = AutomaticFold::None;
156  	convertPastes = true;
157  	SetRepresentations();
158  }
159  Editor::~Editor() {
160  	pdoc->RemoveWatcher(this, nullptr);
161  }
162  void Editor::Finalise() {
163  	SetIdle(false);
164  	CancelModes();
165  }
166  void Editor::SetRepresentations() {
167  	reprs.SetDefaultRepresentations(pdoc->dbcsCodePage);
168  }
169  void Editor::DropGraphics() noexcept {
170  	marginView.DropGraphics();
171  	view.DropGraphics();
172  }
173  void Editor::InvalidateStyleData() noexcept {
174  	stylesValid = false;
175  	vs.technology = technology;
176  	DropGraphics();
177  	view.llc.Invalidate(LineLayout::ValidLevel::invalid);
178  	view.posCache->Clear();
179  }
180  void Editor::InvalidateStyleRedraw() {
181  	NeedWrapping();
182  	InvalidateStyleData();
183  	Redraw();
184  }
185  void Editor::RefreshStyleData() {
186  	if (!stylesValid) {
187  		stylesValid = true;
188  		AutoSurface surface(this);
189  		if (surface) {
190  			vs.Refresh(*surface, pdoc->tabInChars);
191  		}
192  		SetScrollBars();
193  		SetRectangularRange();
194  	}
195  }
196  bool Editor::HasMarginWindow() const noexcept {
197  	return wMargin.Created();
198  }
199  Point Editor::GetVisibleOriginInMain() const {
200  	return Point(0, 0);
201  }
202  PointDocument Editor::DocumentPointFromView(Point ptView) const {
203  	PointDocument ptDocument(ptView);
204  	if (HasMarginWindow()) {
205  		const Point ptOrigin = GetVisibleOriginInMain();
206  		ptDocument.x += ptOrigin.x;
207  		ptDocument.y += ptOrigin.y;
208  	} else {
209  		ptDocument.x += xOffset;
210  		ptDocument.y += topLine * vs.lineHeight;
211  	}
212  	return ptDocument;
213  }
214  Sci::Line Editor::TopLineOfMain() const noexcept {
215  	if (HasMarginWindow())
216  		return 0;
217  	else
218  		return topLine;
219  }
220  Point Editor::ClientSize() const {
221  	const PRectangle rcClient = GetClientRectangle();
222  	return Point(rcClient.Width(), rcClient.Height());
223  }
224  PRectangle Editor::GetClientRectangle() const {
225  	return wMain.GetClientPosition();
226  }
227  PRectangle Editor::GetClientDrawingRectangle() {
228  	return GetClientRectangle();
229  }
230  PRectangle Editor::GetTextRectangle() const {
231  	PRectangle rc = GetClientRectangle();
232  	rc.left += vs.textStart;
233  	rc.right -= vs.rightMarginWidth;
234  	return rc;
235  }
236  Sci::Line Editor::LinesOnScreen() const {
237  	const Point sizeClient = ClientSize();
238  	const int htClient = static_cast<int>(sizeClient.y);
239  	return htClient / vs.lineHeight;
240  }
241  Sci::Line Editor::LinesToScroll() const {
242  	const Sci::Line retVal = LinesOnScreen() - 1;
243  	if (retVal < 1)
244  		return 1;
245  	else
246  		return retVal;
247  }
248  Sci::Line Editor::MaxScrollPos() const {
249  	Sci::Line retVal = pcs->LinesDisplayed();
250  	if (endAtLastLine) {
251  		retVal -= LinesOnScreen();
252  	} else {
253  		retVal--;
254  	}
255  	if (retVal < 0) {
256  		return 0;
257  	} else {
258  		return retVal;
259  	}
260  }
261  SelectionPosition Editor::ClampPositionIntoDocument(SelectionPosition sp) const {
262  	if (sp.Position() < 0) {
263  		return SelectionPosition(0);
264  	} else if (sp.Position() > pdoc->Length()) {
265  		return SelectionPosition(pdoc->Length());
266  	} else {
267  		if (!pdoc->IsLineEndPosition(sp.Position()))
268  			sp.SetVirtualSpace(0);
269  		return sp;
270  	}
271  }
272  Point Editor::LocationFromPosition(SelectionPosition pos, PointEnd pe) {
273  	const PRectangle rcClient = GetTextRectangle();
274  	RefreshStyleData();
275  	AutoSurface surface(this);
276  	return view.LocationFromPosition(surface, *this, pos, topLine, vs, pe, rcClient);
277  }
278  Point Editor::LocationFromPosition(Sci::Position pos, PointEnd pe) {
279  	return LocationFromPosition(SelectionPosition(pos), pe);
280  }
281  int Editor::XFromPosition(SelectionPosition sp) {
282  	const Point pt = LocationFromPosition(sp);
283  	return static_cast<int>(pt.x) - vs.textStart + xOffset;
284  }
285  SelectionPosition Editor::SPositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition, bool virtualSpace) {
286  	RefreshStyleData();
287  	AutoSurface surface(this);
288  	PRectangle rcClient = GetTextRectangle();
289  	const Point ptOrigin = GetVisibleOriginInMain();
290  	rcClient.Move(-ptOrigin.x, -ptOrigin.y);
291  	if (canReturnInvalid) {
292  		if (!rcClient.Contains(pt))
293  			return SelectionPosition(Sci::invalidPosition);
294  		if (pt.x < vs.textStart)
295  			return SelectionPosition(Sci::invalidPosition);
296  		if (pt.y < 0)
297  			return SelectionPosition(Sci::invalidPosition);
298  	}
299  	const PointDocument ptdoc = DocumentPointFromView(pt);
300  	return view.SPositionFromLocation(surface, *this, ptdoc, canReturnInvalid,
301  		charPosition, virtualSpace, vs, rcClient);
302  }
303  Sci::Position Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
304  	return SPositionFromLocation(pt, canReturnInvalid, charPosition, false).Position();
305  }
306  SelectionPosition Editor::SPositionFromLineX(Sci::Line lineDoc, int x) {
307  	RefreshStyleData();
308  	if (lineDoc >= pdoc->LinesTotal())
309  		return SelectionPosition(pdoc->Length());
310  	AutoSurface surface(this);
311  	return view.SPositionFromLineX(surface, *this, lineDoc, x, vs);
312  }
313  Sci::Position Editor::PositionFromLineX(Sci::Line lineDoc, int x) {
314  	return SPositionFromLineX(lineDoc, x).Position();
315  }
316  Sci::Line Editor::LineFromLocation(Point pt) const noexcept {
317  	return pcs->DocFromDisplay(static_cast<int>(pt.y) / vs.lineHeight + topLine);
318  }
319  void Editor::SetTopLine(Sci::Line topLineNew) {
320  	if ((topLine != topLineNew) && (topLineNew >= 0)) {
321  		topLine = topLineNew;
322  		ContainerNeedsUpdate(Update::VScroll);
323  	}
324  	posTopLine = pdoc->LineStart(pcs->DocFromDisplay(topLine));
325  }
326  bool Editor::AbandonPaint() {
327  	if ((paintState == PaintState::painting) && !paintingAllText) {
328  		paintState = PaintState::abandoned;
329  	}
330  	return paintState == PaintState::abandoned;
331  }
332  void Editor::RedrawRect(PRectangle rc) {
333  	const PRectangle rcClient = GetClientRectangle();
334  	if (rc.top < rcClient.top)
335  		rc.top = rcClient.top;
336  	if (rc.bottom > rcClient.bottom)
337  		rc.bottom = rcClient.bottom;
338  	if (rc.left < rcClient.left)
339  		rc.left = rcClient.left;
340  	if (rc.right > rcClient.right)
341  		rc.right = rcClient.right;
342  	if ((rc.bottom > rc.top) && (rc.right > rc.left)) {
343  		wMain.InvalidateRectangle(rc);
344  	}
345  }
346  void Editor::DiscardOverdraw() {
347  }
348  void Editor::Redraw() {
349  	if (redrawPendingText) {
350  		return;
351  	}
352  	const PRectangle rcClient = GetClientRectangle();
353  	wMain.InvalidateRectangle(rcClient);
354  	if (HasMarginWindow()) {
355  		wMargin.InvalidateAll();
356  	} else if (paintState == PaintState::notPainting) {
357  		redrawPendingText = true;
358  	}
359  }
360  void Editor::RedrawSelMargin(Sci::Line line, bool allAfter) {
361  	const bool markersInText = vs.maskInLine || vs.maskDrawInText;
362  	if (!HasMarginWindow() || markersInText) {	
363  		if (AbandonPaint()) {
364  			return;
365  		}
366  	}
367  	if (HasMarginWindow() && markersInText) {
368  		Redraw();
369  		return;
370  	}
371  	if (redrawPendingMargin) {
372  		return;
373  	}
374  	PRectangle rcMarkers = GetClientRectangle();
375  	if (!markersInText) {
376  		rcMarkers.right = rcMarkers.left + vs.fixedColumnWidth;
377  	}
378  	const PRectangle rcMarkersFull = rcMarkers;
379  	if (line != -1) {
380  		PRectangle rcLine = RectangleFromRange(Range(pdoc->LineStart(line)), 0);
381  		if (vs.largestMarkerHeight > vs.lineHeight) {
382  			const int delta = (vs.largestMarkerHeight - vs.lineHeight + 1) / 2;
383  			rcLine.top -= delta;
384  			rcLine.bottom += delta;
385  			if (rcLine.top < rcMarkers.top)
386  				rcLine.top = rcMarkers.top;
387  			if (rcLine.bottom > rcMarkers.bottom)
388  				rcLine.bottom = rcMarkers.bottom;
389  		}
390  		rcMarkers.top = rcLine.top;
391  		if (!allAfter)
392  			rcMarkers.bottom = rcLine.bottom;
393  		if (rcMarkers.Empty())
394  			return;
395  	}
396  	if (HasMarginWindow()) {
397  		const Point ptOrigin = GetVisibleOriginInMain();
398  		rcMarkers.Move(-ptOrigin.x, -ptOrigin.y);
399  		wMargin.InvalidateRectangle(rcMarkers);
400  	} else {
401  		wMain.InvalidateRectangle(rcMarkers);
402  		if (rcMarkers == rcMarkersFull) {
403  			redrawPendingMargin = true;
404  		}
405  	}
406  }
407  PRectangle Editor::RectangleFromRange(Range r, int overlap) {
408  	const Sci::Line minLine = pcs->DisplayFromDoc(
409  		pdoc->SciLineFromPosition(r.First()));
410  	const Sci::Line maxLine = pcs->DisplayLastFromDoc(
411  		pdoc->SciLineFromPosition(r.Last()));
412  	const PRectangle rcClientDrawing = GetClientDrawingRectangle();
413  	PRectangle rc;
414  	const int leftTextOverlap = ((xOffset == 0) && (vs.leftMarginWidth > 0)) ? 1 : 0;
415  	rc.left = static_cast<XYPOSITION>(vs.textStart - leftTextOverlap);
416  	rc.top = static_cast<XYPOSITION>((minLine - TopLineOfMain()) * vs.lineHeight - overlap);
417  	if (rc.top < rcClientDrawing.top)
418  		rc.top = rcClientDrawing.top;
419  	rc.right = rcClientDrawing.right;
420  	rc.bottom = static_cast<XYPOSITION>((maxLine - TopLineOfMain() + 1) * vs.lineHeight + overlap);
421  	return rc;
422  }
423  void Editor::InvalidateRange(Sci::Position start, Sci::Position end) {
424  	if (redrawPendingText) {
425  		return;
426  	}
427  	RedrawRect(RectangleFromRange(Range(start, end), view.LinesOverlap() ? vs.lineOverlap : 0));
428  }
429  Sci::Position Editor::CurrentPosition() const noexcept {
430  	return sel.MainCaret();
431  }
432  bool Editor::SelectionEmpty() const noexcept {
433  	return sel.Empty();
434  }
435  SelectionPosition Editor::SelectionStart() noexcept {
436  	return sel.RangeMain().Start();
437  }
438  SelectionPosition Editor::SelectionEnd() noexcept {
439  	return sel.RangeMain().End();
440  }
441  void Editor::SetRectangularRange() {
442  	if (sel.IsRectangular()) {
443  		const int xAnchor = XFromPosition(sel.Rectangular().anchor);
444  		int xCaret = XFromPosition(sel.Rectangular().caret);
445  		if (sel.selType == Selection::SelTypes::thin) {
446  			xCaret = xAnchor;
447  		}
448  		const Sci::Line lineAnchorRect =
449  			pdoc->SciLineFromPosition(sel.Rectangular().anchor.Position());
450  		const Sci::Line lineCaret =
451  			pdoc->SciLineFromPosition(sel.Rectangular().caret.Position());
452  		const int increment = (lineCaret > lineAnchorRect) ? 1 : -1;
453  		AutoSurface surface(this);
454  		for (Sci::Line line=lineAnchorRect; line != lineCaret+increment; line += increment) {
455  			SelectionRange range(
456  				view.SPositionFromLineX(surface, *this, line, xCaret, vs),
457  				view.SPositionFromLineX(surface, *this, line, xAnchor, vs));
458  			if (!FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection))
459  				range.ClearVirtualSpace();
460  			if (line == lineAnchorRect)
461  				sel.SetSelection(range);
462  			else
463  				sel.AddSelectionWithoutTrim(range);
464  		}
465  	}
466  }
467  void Editor::ThinRectangularRange() {
468  	if (sel.IsRectangular()) {
469  		sel.selType = Selection::SelTypes::thin;
470  		if (sel.Rectangular().caret < sel.Rectangular().anchor) {
471  			sel.Rectangular() = SelectionRange(sel.Range(sel.Count()-1).caret, sel.Range(0).anchor);
472  		} else {
473  			sel.Rectangular() = SelectionRange(sel.Range(sel.Count()-1).anchor, sel.Range(0).caret);
474  		}
475  		SetRectangularRange();
476  	}
477  }
478  void Editor::InvalidateSelection(SelectionRange newMain, bool invalidateWholeSelection) {
479  	if (sel.Count() > 1 || !(sel.RangeMain().anchor == newMain.anchor) || sel.IsRectangular()) {
480  		invalidateWholeSelection = true;
481  	}
482  	Sci::Position firstAffected = std::min(sel.RangeMain().Start().Position(), newMain.Start().Position());
483  	Sci::Position lastAffected = std::max(newMain.caret.Position()+1, newMain.anchor.Position());
484  	lastAffected = std::max(lastAffected, sel.RangeMain().End().Position());
485  	if (invalidateWholeSelection) {
486  		for (size_t r=0; r<sel.Count(); r++) {
487  			firstAffected = std::min(firstAffected, sel.Range(r).caret.Position());
488  			firstAffected = std::min(firstAffected, sel.Range(r).anchor.Position());
489  			lastAffected = std::max(lastAffected, sel.Range(r).caret.Position()+1);
490  			lastAffected = std::max(lastAffected, sel.Range(r).anchor.Position());
491  		}
492  	}
493  	ContainerNeedsUpdate(Update::Selection);
494  	InvalidateRange(firstAffected, lastAffected);
495  }
496  void Editor::InvalidateWholeSelection() {
497  	InvalidateSelection(sel.RangeMain(), true);
498  }
499  SelectionRange Editor::LineSelectionRange(SelectionPosition currentPos_, SelectionPosition anchor_) const {
500  	if (currentPos_ > anchor_) {
501  		anchor_ = SelectionPosition(
502  			pdoc->LineStart(pdoc->LineFromPosition(anchor_.Position())));
503  		currentPos_ = SelectionPosition(
504  			pdoc->LineEnd(pdoc->LineFromPosition(currentPos_.Position())));
505  	} else {
506  		currentPos_ = SelectionPosition(
507  			pdoc->LineStart(pdoc->LineFromPosition(currentPos_.Position())));
508  		anchor_ = SelectionPosition(
509  			pdoc->LineEnd(pdoc->LineFromPosition(anchor_.Position())));
510  	}
511  	return SelectionRange(currentPos_, anchor_);
512  }
513  void Editor::SetSelection(SelectionPosition currentPos_, SelectionPosition anchor_) {
514  	currentPos_ = ClampPositionIntoDocument(currentPos_);
515  	anchor_ = ClampPositionIntoDocument(anchor_);
516  	const Sci::Line currentLine = pdoc->SciLineFromPosition(currentPos_.Position());
517  	SelectionRange rangeNew(currentPos_, anchor_);
518  	if (sel.selType == Selection::SelTypes::lines) {
519  		rangeNew = LineSelectionRange(currentPos_, anchor_);
520  	}
521  	if (sel.Count() > 1 || !(sel.RangeMain() == rangeNew)) {
522  		InvalidateSelection(rangeNew);
523  	}
524  	sel.RangeMain() = rangeNew;
525  	SetRectangularRange();
526  	ClaimSelection();
527  	SetHoverIndicatorPosition(sel.MainCaret());
528  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
529  		RedrawSelMargin();
530  	}
531  	QueueIdleWork(WorkItems::updateUI);
532  }
533  void Editor::SetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
534  	SetSelection(SelectionPosition(currentPos_), SelectionPosition(anchor_));
535  }
536  void Editor::SetSelection(SelectionPosition currentPos_) {
537  	currentPos_ = ClampPositionIntoDocument(currentPos_);
538  	const Sci::Line currentLine = pdoc->SciLineFromPosition(currentPos_.Position());
539  	if (sel.Count() > 1 || !(sel.RangeMain().caret == currentPos_)) {
540  		InvalidateSelection(SelectionRange(currentPos_));
541  	}
542  	if (sel.IsRectangular()) {
543  		sel.Rectangular() =
544  			SelectionRange(SelectionPosition(currentPos_), sel.Rectangular().anchor);
545  		SetRectangularRange();
546  	} else if (sel.selType == Selection::SelTypes::lines) {
547  		sel.RangeMain() = LineSelectionRange(currentPos_, sel.RangeMain().anchor);
548  	} else {
549  		sel.RangeMain() =
550  			SelectionRange(SelectionPosition(currentPos_), sel.RangeMain().anchor);
551  	}
552  	ClaimSelection();
553  	SetHoverIndicatorPosition(sel.MainCaret());
554  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
555  		RedrawSelMargin();
556  	}
557  	QueueIdleWork(WorkItems::updateUI);
558  }
559  void Editor::SetEmptySelection(SelectionPosition currentPos_) {
560  	const Sci::Line currentLine = pdoc->SciLineFromPosition(currentPos_.Position());
561  	SelectionRange rangeNew(ClampPositionIntoDocument(currentPos_));
562  	if (sel.Count() > 1 || !(sel.RangeMain() == rangeNew)) {
563  		InvalidateSelection(rangeNew);
564  	}
565  	sel.Clear();
566  	sel.RangeMain() = rangeNew;
567  	SetRectangularRange();
568  	ClaimSelection();
569  	SetHoverIndicatorPosition(sel.MainCaret());
570  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
571  		RedrawSelMargin();
572  	}
573  	QueueIdleWork(WorkItems::updateUI);
574  }
575  void Editor::SetEmptySelection(Sci::Position currentPos_) {
576  	SetEmptySelection(SelectionPosition(currentPos_));
577  }
578  void Editor::MultipleSelectAdd(AddNumber addNumber) {
579  	if (SelectionEmpty() || !multipleSelection) {
580  		const Sci::Position startWord = pdoc->ExtendWordSelect(sel.MainCaret(), -1, true);
581  		const Sci::Position endWord = pdoc->ExtendWordSelect(startWord, 1, true);
582  		TrimAndSetSelection(endWord, startWord);
583  	} else {
584  		if (!pdoc->HasCaseFolder())
585  			pdoc->SetCaseFolder(CaseFolderForEncoding());
586  		const Range rangeMainSelection(sel.RangeMain().Start().Position(), sel.RangeMain().End().Position());
587  		const std::string selectedText = RangeText(rangeMainSelection.start, rangeMainSelection.end);
588  		const Range rangeTarget(targetRange.start.Position(), targetRange.end.Position());
589  		std::vector<Range> searchRanges;
590  		if (rangeTarget.Overlaps(rangeMainSelection)) {
591  			if (rangeMainSelection.end < rangeTarget.end)
592  				searchRanges.push_back(Range(rangeMainSelection.end, rangeTarget.end));
593  			if (rangeTarget.start < rangeMainSelection.start)
594  				searchRanges.push_back(Range(rangeTarget.start, rangeMainSelection.start));
595  		} else {
596  			searchRanges.push_back(rangeTarget);
597  		}
598  		for (const Range range : searchRanges) {
599  			Sci::Position searchStart = range.start;
600  			const Sci::Position searchEnd = range.end;
601  			for (;;) {
602  				Sci::Position lengthFound = selectedText.length();
603  				const Sci::Position pos = pdoc->FindText(searchStart, searchEnd,
604  					selectedText.c_str(), searchFlags, &lengthFound);
605  				if (pos >= 0) {
606  					sel.AddSelection(SelectionRange(pos + lengthFound, pos));
607  					ContainerNeedsUpdate(Update::Selection);
608  					ScrollRange(sel.RangeMain());
609  					Redraw();
610  					if (addNumber == AddNumber::one)
611  						return;
612  					searchStart = pos + lengthFound;
613  				} else {
614  					break;
615  				}
616  			}
617  		}
618  	}
619  }
620  bool Editor::RangeContainsProtected(Sci::Position start, Sci::Position end) const noexcept {
621  	if (vs.ProtectionActive()) {
622  		if (start > end) {
623  			std::swap(start, end);
624  		}
625  		for (Sci::Position pos = start; pos < end; pos++) {
626  			if (vs.styles[pdoc->StyleIndexAt(pos)].IsProtected())
627  				return true;
628  		}
629  	}
630  	return false;
631  }
632  bool Editor::SelectionContainsProtected() const noexcept {
633  	for (size_t r=0; r<sel.Count(); r++) {
634  		if (RangeContainsProtected(sel.Range(r).Start().Position(),
635  			sel.Range(r).End().Position())) {
636  			return true;
637  		}
638  	}
639  	return false;
640  }
641  Sci::Position Editor::MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd) const {
642  	return MovePositionOutsideChar(SelectionPosition(pos), moveDir, checkLineEnd).Position();
643  }
644  SelectionPosition Editor::MovePositionOutsideChar(SelectionPosition pos, Sci::Position moveDir, bool checkLineEnd) const {
645  	const Sci::Position posMoved = pdoc->MovePositionOutsideChar(pos.Position(), moveDir, checkLineEnd);
646  	if (posMoved != pos.Position())
647  		pos.SetPosition(posMoved);
648  	if (vs.ProtectionActive()) {
649  		if (moveDir > 0) {
650  			if ((pos.Position() > 0) && vs.styles[pdoc->StyleIndexAt(pos.Position() - 1)].IsProtected()) {
651  				while ((pos.Position() < pdoc->Length()) &&
652  				        (vs.styles[pdoc->StyleIndexAt(pos.Position())].IsProtected()))
653  					pos.Add(1);
654  			}
655  		} else if (moveDir < 0) {
656  			if (vs.styles[pdoc->StyleIndexAt(pos.Position())].IsProtected()) {
657  				while ((pos.Position() > 0) &&
658  				        (vs.styles[pdoc->StyleIndexAt(pos.Position() - 1)].IsProtected()))
659  					pos.Add(-1);
660  			}
661  		}
662  	}
663  	return pos;
664  }
665  void Editor::MovedCaret(SelectionPosition newPos, SelectionPosition previousPos,
666  	bool ensureVisible, CaretPolicies policies) {
667  	const Sci::Line currentLine = pdoc->SciLineFromPosition(newPos.Position());
668  	if (ensureVisible) {
669  		if (currentLine >= wrapPending.start) {
670  			if (WrapLines(WrapScope::wsAll)) {
671  				Redraw();
672  			}
673  		}
674  		const XYScrollPosition newXY = XYScrollToMakeVisible(
675  			SelectionRange(posDrag.IsValid() ? posDrag : newPos), XYScrollOptions::all, policies);
676  		if (previousPos.IsValid() && (newXY.xOffset == xOffset)) {
677  			ScrollTo(newXY.topLine);
678  			InvalidateSelection(SelectionRange(previousPos), true);
679  		} else {
680  			SetXYScroll(newXY);
681  		}
682  	}
683  	ShowCaretAtCurrentPosition();
684  	NotifyCaretMove();
685  	ClaimSelection();
686  	SetHoverIndicatorPosition(sel.MainCaret());
687  	QueueIdleWork(WorkItems::updateUI);
688  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
689  		RedrawSelMargin();
690  	}
691  }
692  void Editor::MovePositionTo(SelectionPosition newPos, Selection::SelTypes selt, bool ensureVisible) {
693  	const SelectionPosition spCaret = ((sel.Count() == 1) && sel.Empty()) ?
694  		sel.Last() : SelectionPosition(Sci::invalidPosition);
695  	const Sci::Position delta = newPos.Position() - sel.MainCaret();
696  	newPos = ClampPositionIntoDocument(newPos);
697  	newPos = MovePositionOutsideChar(newPos, delta);
698  	if (!multipleSelection && sel.IsRectangular() && (selt == Selection::SelTypes::stream)) {
699  		InvalidateSelection(SelectionRange(newPos), true);
700  		sel.DropAdditionalRanges();
701  	}
702  	if (!sel.IsRectangular() && (selt == Selection::SelTypes::rectangle)) {
703  		InvalidateSelection(sel.RangeMain(), false);
704  		SelectionRange rangeMain = sel.RangeMain();
705  		sel.Clear();
706  		sel.Rectangular() = rangeMain;
707  	}
708  	if (selt != Selection::SelTypes::none) {
709  		sel.selType = selt;
710  	}
711  	if (selt != Selection::SelTypes::none || sel.MoveExtends()) {
712  		SetSelection(newPos);
713  	} else {
714  		SetEmptySelection(newPos);
715  	}
716  	MovedCaret(newPos, spCaret, ensureVisible, caretPolicies);
717  }
718  void Editor::MovePositionTo(Sci::Position newPos, Selection::SelTypes selt, bool ensureVisible) {
719  	MovePositionTo(SelectionPosition(newPos), selt, ensureVisible);
720  }
721  SelectionPosition Editor::MovePositionSoVisible(SelectionPosition pos, int moveDir) {
722  	pos = ClampPositionIntoDocument(pos);
723  	pos = MovePositionOutsideChar(pos, moveDir);
724  	const Sci::Line lineDoc = pdoc->SciLineFromPosition(pos.Position());
725  	if (pcs->GetVisible(lineDoc)) {
726  		return pos;
727  	} else {
728  		Sci::Line lineDisplay = pcs->DisplayFromDoc(lineDoc);
729  		if (moveDir > 0) {
730  			lineDisplay = std::clamp<Sci::Line>(lineDisplay, 0, pcs->LinesDisplayed());
731  			return SelectionPosition(
732  				pdoc->LineStart(pcs->DocFromDisplay(lineDisplay)));
733  		} else {
734  			lineDisplay = std::clamp<Sci::Line>(lineDisplay - 1, 0, pcs->LinesDisplayed());
735  			return SelectionPosition(
736  				pdoc->LineEnd(pcs->DocFromDisplay(lineDisplay)));
737  		}
738  	}
739  }
740  SelectionPosition Editor::MovePositionSoVisible(Sci::Position pos, int moveDir) {
741  	return MovePositionSoVisible(SelectionPosition(pos), moveDir);
742  }
743  Point Editor::PointMainCaret() {
744  	return LocationFromPosition(sel.Range(sel.Main()).caret);
745  }
746  void Editor::SetLastXChosen() {
747  	const Point pt = PointMainCaret();
748  	lastXChosen = static_cast<int>(pt.x) + xOffset;
749  }
750  void Editor::ScrollTo(Sci::Line line, bool moveThumb) {
751  	const Sci::Line topLineNew = std::clamp<Sci::Line>(line, 0, MaxScrollPos());
752  	if (topLineNew != topLine) {
753  #ifndef UNDER_CE
754  		const Sci::Line linesToMove = topLine - topLineNew;
755  		const bool performBlit = (std::abs(linesToMove) <= 10) && (paintState == PaintState::notPainting);
756  		willRedrawAll = !performBlit;
757  #endif
758  		SetTopLine(topLineNew);
759  		StyleAreaBounded(GetClientRectangle(), true);
760  #ifndef UNDER_CE
761  		if (performBlit) {
762  			ScrollText(linesToMove);
763  		} else {
764  			Redraw();
765  		}
766  		willRedrawAll = false;
767  #else
768  		Redraw();
769  #endif
770  		if (moveThumb) {
771  			SetVerticalScrollPos();
772  		}
773  	}
774  }
775  void Editor::ScrollText(Sci::Line &bsol;* linesToMove */) {
<span onclick='openModal()' class='match'>776  	Redraw();
777  }
778  void Editor::HorizontalScrollTo(int xPos) {
779  	if (xPos < 0)
</span>780  		xPos = 0;
781  	if (!Wrapping() && (xOffset != xPos)) {
782  		xOffset = xPos;
783  		ContainerNeedsUpdate(Update::HScroll);
784  		SetHorizontalScrollPos();
785  		RedrawRect(GetClientRectangle());
786  	}
787  }
788  void Editor::VerticalCentreCaret() {
789  	const Sci::Line lineDoc =
790  		pdoc->SciLineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
791  	const Sci::Line lineDisplay = pcs->DisplayFromDoc(lineDoc);
792  	const Sci::Line newTop = lineDisplay - (LinesOnScreen() / 2);
793  	if (topLine != newTop) {
794  		SetTopLine(newTop > 0 ? newTop : 0);
795  		SetVerticalScrollPos();
796  		RedrawRect(GetClientRectangle());
797  	}
798  }
799  void Editor::MoveSelectedLines(int lineDelta) {
800  	if (sel.IsRectangular()) {
801  		return;
802  	}
803  	Sci::Position selectionStart = SelectionStart().Position();
804  	const Sci::Line startLine = pdoc->SciLineFromPosition(selectionStart);
805  	const Sci::Position beginningOfStartLine = pdoc->LineStart(startLine);
806  	selectionStart = beginningOfStartLine;
807  	Sci::Position selectionEnd = SelectionEnd().Position();
808  	const Sci::Line endLine = pdoc->SciLineFromPosition(selectionEnd);
809  	const Sci::Position beginningOfEndLine = pdoc->LineStart(endLine);
810  	bool appendEol = false;
811  	if (selectionEnd > beginningOfEndLine
812  		|| selectionStart == selectionEnd) {
813  		selectionEnd = pdoc->LineStart(endLine + 1);
814  		appendEol = (selectionEnd == pdoc->Length() && pdoc->SciLineFromPosition(selectionEnd) == endLine);
815  	}
816  	if ((selectionStart == 0 && lineDelta < 0)
817  		|| (selectionEnd == pdoc->Length() && lineDelta > 0)
818  	        || selectionStart == selectionEnd) {
819  		return;
820  	}
821  	UndoGroup ug(pdoc);
822  	if (lineDelta > 0 && selectionEnd == pdoc->LineStart(pdoc->LinesTotal() - 1)) {
823  		SetSelection(pdoc->MovePositionOutsideChar(selectionEnd - 1, -1), selectionEnd);
824  		ClearSelection();
825  		selectionEnd = CurrentPosition();
826  	}
827  	SetSelection(selectionStart, selectionEnd);
828  	const std::string selectedText = RangeText(selectionStart, selectionEnd);
829  	const Point currentLocation = LocationFromPosition(CurrentPosition());
830  	const Sci::Line currentLine = LineFromLocation(currentLocation);
831  	if (appendEol)
832  		SetSelection(pdoc->MovePositionOutsideChar(selectionStart - 1, -1), selectionEnd);
833  	ClearSelection();
834  	const std::string_view eol = pdoc->EOLString();
835  	if (currentLine + lineDelta >= pdoc->LinesTotal())
836  		pdoc->InsertString(pdoc->Length(), eol);
837  	GoToLine(currentLine + lineDelta);
838  	Sci::Position selectionLength = pdoc->InsertString(CurrentPosition(), selectedText);
839  	if (appendEol) {
840  		const Sci::Position lengthInserted = pdoc->InsertString(CurrentPosition() + selectionLength, eol);
841  		selectionLength += lengthInserted;
842  	}
843  	SetSelection(CurrentPosition(), CurrentPosition() + selectionLength);
844  }
845  void Editor::MoveSelectedLinesUp() {
846  	MoveSelectedLines(-1);
847  }
848  void Editor::MoveSelectedLinesDown() {
849  	MoveSelectedLines(1);
850  }
851  void Editor::MoveCaretInsideView(bool ensureVisible) {
852  	const PRectangle rcClient = GetTextRectangle();
853  	const Point pt = PointMainCaret();
854  	if (pt.y < rcClient.top) {
855  		MovePositionTo(SPositionFromLocation(
856  		            Point::FromInts(lastXChosen - xOffset, static_cast<int>(rcClient.top)),
857  					false, false, UserVirtualSpace()),
858  					Selection::SelTypes::none, ensureVisible);
859  	} else if ((pt.y + vs.lineHeight - 1) > rcClient.bottom) {
860  		const ptrdiff_t yOfLastLineFullyDisplayed = static_cast<ptrdiff_t>(rcClient.top) + (LinesOnScreen() - 1) * vs.lineHeight;
861  		MovePositionTo(SPositionFromLocation(
862  		            Point::FromInts(lastXChosen - xOffset, static_cast<int>(rcClient.top + yOfLastLineFullyDisplayed)),
863  					false, false, UserVirtualSpace()),
864  		        Selection::SelTypes::none, ensureVisible);
865  	}
866  }
867  Sci::Line Editor::DisplayFromPosition(Sci::Position pos) {
868  	AutoSurface surface(this);
869  	return view.DisplayFromPosition(surface, *this, pos, vs);
870  }
871  Editor::XYScrollPosition Editor::XYScrollToMakeVisible(const SelectionRange &range,
872  	const XYScrollOptions options, CaretPolicies policies) {
873  	const PRectangle rcClient = GetTextRectangle();
874  	const Point ptOrigin = GetVisibleOriginInMain();
875  	const Point pt = LocationFromPosition(range.caret) + ptOrigin;
876  	const Point ptAnchor = LocationFromPosition(range.anchor) + ptOrigin;
877  	const Point ptBottomCaret(pt.x, pt.y + vs.lineHeight - 1);
878  	XYScrollPosition newXY(xOffset, topLine);
879  	if (rcClient.Empty()) {
880  		return newXY;
881  	}
882  	if (FlagSet(options, XYScrollOptions::vertical) &&
883  		(pt.y < rcClient.top || ptBottomCaret.y >= rcClient.bottom || FlagSet(policies.y.policy, CaretPolicy::Strict))) {
884  		const Sci::Line lineCaret = DisplayFromPosition(range.caret.Position());
885  		const Sci::Line linesOnScreen = LinesOnScreen();
886  		const Sci::Line halfScreen = std::max(linesOnScreen - 1, static_cast<Sci::Line>(2)) / 2;
887  		const bool bSlop = FlagSet(policies.y.policy, CaretPolicy::Slop);
888  		const bool bStrict = FlagSet(policies.y.policy, CaretPolicy::Strict);
889  		const bool bJump = FlagSet(policies.y.policy, CaretPolicy::Jumps);
890  		const bool bEven = FlagSet(policies.y.policy, CaretPolicy::Even);
891  		if (bSlop) {	
892  			Sci::Line yMoveT = 0;
893  			Sci::Line yMoveB = 0;
894  			if (bStrict) {
895  				Sci::Line yMarginT = 0;
896  				Sci::Line yMarginB = 0;
897  				if (!FlagSet(options, XYScrollOptions::useMargin)) {
898  					yMarginT = yMarginB = 0;
899  				} else {
900  					yMarginT = std::clamp<Sci::Line>(policies.y.slop, 1, halfScreen);
901  					if (bEven) {
902  						yMarginB = yMarginT;
903  					} else {
904  						yMarginB = linesOnScreen - yMarginT - 1;
905  					}
906  				}
907  				yMoveT = yMarginT;
908  				if (bEven) {
909  					if (bJump) {
910  						yMoveT = std::clamp<Sci::Line>(policies.y.slop * 3, 1, halfScreen);
911  					}
912  					yMoveB = yMoveT;
913  				} else {
914  					yMoveB = linesOnScreen - yMoveT - 1;
915  				}
916  				if (lineCaret < topLine + yMarginT) {
917  					newXY.topLine = lineCaret - yMoveT;
918  				} else if (lineCaret > topLine + linesOnScreen - 1 - yMarginB) {
919  					newXY.topLine = lineCaret - linesOnScreen + 1 + yMoveB;
920  				}
921  			} else {	
922  				yMoveT = bJump ? policies.y.slop * 3 : policies.y.slop;
923  				yMoveT = std::clamp<Sci::Line>(yMoveT, 1, halfScreen);
924  				if (bEven) {
925  					yMoveB = yMoveT;
926  				} else {
927  					yMoveB = linesOnScreen - yMoveT - 1;
928  				}
929  				if (lineCaret < topLine) {
930  					newXY.topLine = lineCaret - yMoveT;
931  				} else if (lineCaret > topLine + linesOnScreen - 1) {
932  					newXY.topLine = lineCaret - linesOnScreen + 1 + yMoveB;
933  				}
934  			}
935  		} else {	
936  			if (!bStrict && !bJump) {
937  				if (lineCaret < topLine) {
938  					newXY.topLine = lineCaret;
939  				} else if (lineCaret > topLine + linesOnScreen - 1) {
940  					if (bEven) {
941  						newXY.topLine = lineCaret - linesOnScreen + 1;
942  					} else {
943  						newXY.topLine = lineCaret;
944  					}
945  				}
946  			} else {	
947  				if (bEven) {
948  					newXY.topLine = lineCaret - halfScreen;
949  				} else {
950  					newXY.topLine = lineCaret;
951  				}
952  			}
953  		}
954  		if (!(range.caret == range.anchor)) {
955  			const Sci::Line lineAnchor = DisplayFromPosition(range.anchor.Position());
956  			if (lineAnchor < lineCaret) {
957  				newXY.topLine = std::min(newXY.topLine, lineAnchor);
958  				newXY.topLine = std::max(newXY.topLine, lineCaret - LinesOnScreen());
959  			} else {
960  				newXY.topLine = std::max(newXY.topLine, lineAnchor - LinesOnScreen());
961  				newXY.topLine = std::min(newXY.topLine, lineCaret);
962  			}
963  		}
964  		newXY.topLine = std::clamp<Sci::Line>(newXY.topLine, 0, MaxScrollPos());
965  	}
966  	if (FlagSet(options, XYScrollOptions::horizontal) && !Wrapping()) {
967  		const int halfScreen = std::max(static_cast<int>(rcClient.Width()) - 4, 4) / 2;
968  		const bool bSlop = FlagSet(policies.x.policy, CaretPolicy::Slop);
969  		const bool bStrict = FlagSet(policies.x.policy, CaretPolicy::Strict);
970  		const bool bJump = FlagSet(policies.x.policy, CaretPolicy::Jumps);
971  		const bool bEven = FlagSet(policies.x.policy, CaretPolicy::Even);
972  		if (bSlop) {	
973  			int xMoveL = 0;
974  			int xMoveR = 0;
975  			if (bStrict) {
976  				int xMarginL = 0;
977  				int xMarginR = 0;
978  				if (!FlagSet(options, XYScrollOptions::useMargin)) {
979  					xMarginL = xMarginR = 2;
980  				} else {
981  					xMarginR = std::clamp(policies.x.slop, 2, halfScreen);
982  					if (bEven) {
983  						xMarginL = xMarginR;
984  					} else {
985  						xMarginL = static_cast<int>(rcClient.Width()) - xMarginR - 4;
986  					}
987  				}
988  				if (bJump && bEven) {
989  					xMoveL = xMoveR = std::clamp(policies.x.slop * 3, 1, halfScreen);
990  				} else {
991  					xMoveL = xMoveR = 0;	
992  				}
993  				if (pt.x < rcClient.left + xMarginL) {
994  					if (bJump && bEven) {
995  						newXY.xOffset -= xMoveL;
996  					} else {
997  						newXY.xOffset -= static_cast<int>((rcClient.left + xMarginL) - pt.x);
998  					}
999  				} else if (pt.x >= rcClient.right - xMarginR) {
1000  					if (bJump && bEven) {
1001  						newXY.xOffset += xMoveR;
1002  					} else {
1003  						newXY.xOffset += static_cast<int>(pt.x - (rcClient.right - xMarginR) + 1);
1004  					}
1005  				}
1006  			} else {	
1007  				xMoveR = bJump ? policies.x.slop * 3 : policies.x.slop;
1008  				xMoveR = std::clamp(xMoveR, 1, halfScreen);
1009  				if (bEven) {
1010  					xMoveL = xMoveR;
1011  				} else {
1012  					xMoveL = static_cast<int>(rcClient.Width()) - xMoveR - 4;
1013  				}
1014  				if (pt.x < rcClient.left) {
1015  					newXY.xOffset -= xMoveL;
1016  				} else if (pt.x >= rcClient.right) {
1017  					newXY.xOffset += xMoveR;
1018  				}
1019  			}
1020  		} else {	
1021  			if (bStrict ||
1022  			        (bJump && (pt.x < rcClient.left || pt.x >= rcClient.right))) {
1023  				if (bEven) {
1024  					newXY.xOffset += static_cast<int>(pt.x - rcClient.left - halfScreen);
1025  				} else {
1026  					newXY.xOffset += static_cast<int>(pt.x - rcClient.right + 1);
1027  				}
1028  			} else {
1029  				if (pt.x < rcClient.left) {
1030  					if (bEven) {
1031  						newXY.xOffset -= static_cast<int>(rcClient.left - pt.x);
1032  					} else {
1033  						newXY.xOffset += static_cast<int>(pt.x - rcClient.right) + 1;
1034  					}
1035  				} else if (pt.x >= rcClient.right) {
1036  					newXY.xOffset += static_cast<int>(pt.x - rcClient.right) + 1;
1037  				}
1038  			}
1039  		}
1040  		if (pt.x + xOffset < rcClient.left + newXY.xOffset) {
1041  			newXY.xOffset = static_cast<int>(pt.x + xOffset - rcClient.left) - 2;
1042  		} else if (pt.x + xOffset >= rcClient.right + newXY.xOffset) {
1043  			newXY.xOffset = static_cast<int>(pt.x + xOffset - rcClient.right) + 2;
1044  			if (vs.IsBlockCaretStyle() || view.imeCaretBlockOverride) {
1045  				newXY.xOffset += static_cast<int>(vs.aveCharWidth);
1046  			}
1047  		}
1048  		if (!(range.caret == range.anchor)) {
1049  			if (ptAnchor.x < pt.x) {
1050  				const int maxOffset = static_cast<int>(ptAnchor.x + xOffset - rcClient.left) - 1;
1051  				const int minOffset = static_cast<int>(pt.x + xOffset - rcClient.right) + 1;
1052  				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
1053  				newXY.xOffset = std::max(newXY.xOffset, minOffset);
1054  			} else {
1055  				const int minOffset = static_cast<int>(ptAnchor.x + xOffset - rcClient.right) + 1;
1056  				const int maxOffset = static_cast<int>(pt.x + xOffset - rcClient.left) - 1;
1057  				newXY.xOffset = std::max(newXY.xOffset, minOffset);
1058  				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
1059  			}
1060  		}
1061  		if (newXY.xOffset < 0) {
1062  			newXY.xOffset = 0;
1063  		}
1064  	}
1065  	return newXY;
1066  }
1067  void Editor::SetXYScroll(XYScrollPosition newXY) {
1068  	if ((newXY.topLine != topLine) || (newXY.xOffset != xOffset)) {
1069  		if (newXY.topLine != topLine) {
1070  			SetTopLine(newXY.topLine);
1071  			SetVerticalScrollPos();
1072  		}
1073  		if (newXY.xOffset != xOffset) {
1074  			xOffset = newXY.xOffset;
1075  			ContainerNeedsUpdate(Update::HScroll);
1076  			if (newXY.xOffset > 0) {
1077  				const PRectangle rcText = GetTextRectangle();
1078  				if (horizontalScrollBarVisible &&
1079  					rcText.Width() + xOffset > scrollWidth) {
1080  					scrollWidth = xOffset + static_cast<int>(rcText.Width());
1081  					SetScrollBars();
1082  				}
1083  			}
1084  			SetHorizontalScrollPos();
1085  		}
1086  		Redraw();
1087  		UpdateSystemCaret();
1088  	}
1089  }
1090  void Editor::ScrollRange(SelectionRange range) {
1091  	SetXYScroll(XYScrollToMakeVisible(range, XYScrollOptions::all, caretPolicies));
1092  }
1093  void Editor::EnsureCaretVisible(bool useMargin, bool vert, bool horiz) {
1094  	SetXYScroll(XYScrollToMakeVisible(SelectionRange(posDrag.IsValid() ? posDrag : sel.RangeMain().caret),
1095  		(useMargin?XYScrollOptions::useMargin:XYScrollOptions::none)|
1096  		(vert?XYScrollOptions::vertical:XYScrollOptions::none)|
1097  		(horiz?XYScrollOptions::horizontal:XYScrollOptions::none),
1098  		caretPolicies));
1099  }
1100  void Editor::ShowCaretAtCurrentPosition() {
1101  	if (hasFocus) {
1102  		caret.active = true;
1103  		caret.on = true;
1104  		FineTickerCancel(TickReason::caret);
1105  		if (caret.period > 0)
1106  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
1107  	} else {
1108  		caret.active = false;
1109  		caret.on = false;
1110  		FineTickerCancel(TickReason::caret);
1111  	}
1112  	InvalidateCaret();
1113  }
1114  void Editor::DropCaret() {
1115  	caret.active = false;
1116  	FineTickerCancel(TickReason::caret);
1117  	InvalidateCaret();
1118  }
1119  void Editor::CaretSetPeriod(int period) {
1120  	if (caret.period != period) {
1121  		caret.period = period;
1122  		caret.on = true;
1123  		FineTickerCancel(TickReason::caret);
1124  		if ((caret.active) && (caret.period > 0))
1125  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
1126  		InvalidateCaret();
1127  	}
1128  }
1129  void Editor::InvalidateCaret() {
1130  	if (posDrag.IsValid()) {
1131  		InvalidateRange(posDrag.Position(), posDrag.Position() + 1);
1132  	} else {
1133  		for (size_t r=0; r<sel.Count(); r++) {
1134  			InvalidateRange(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1);
1135  		}
1136  	}
1137  	UpdateSystemCaret();
1138  }
1139  void Editor::NotifyCaretMove() {
1140  }
1141  void Editor::UpdateSystemCaret() {
1142  }
1143  bool Editor::Wrapping() const noexcept {
1144  	return vs.wrap.state != Wrap::None;
1145  }
1146  void Editor::NeedWrapping(Sci::Line docLineStart, Sci::Line docLineEnd) {
1147  	if (wrapPending.AddRange(docLineStart, docLineEnd)) {
1148  		view.llc.Invalidate(LineLayout::ValidLevel::positions);
1149  	}
1150  	if (Wrapping() && wrapPending.NeedsWrap()) {
1151  		SetIdle(true);
1152  	}
1153  }
1154  bool Editor::WrapOneLine(Surface *surface, Sci::Line lineToWrap) {
1155  	std::shared_ptr<LineLayout> ll = view.RetrieveLineLayout(lineToWrap, *this);
1156  	int linesWrapped = 1;
1157  	if (ll) {
1158  		view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
1159  		linesWrapped = ll->lines;
1160  	}
1161  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
1162  		linesWrapped += pdoc->AnnotationLines(lineToWrap);
1163  	}
1164  	return pcs->SetHeight(lineToWrap, linesWrapped);
1165  }
1166  namespace {
1167  constexpr Sci::Position lengthToMultiThread = 4000;
1168  }
1169  bool Editor::WrapBlock(Surface *surface, Sci::Line lineToWrap, Sci::Line lineToWrapEnd) {
1170  	const size_t linesBeingWrapped = static_cast<size_t>(lineToWrapEnd - lineToWrap);
1171  	std::vector<int> linesAfterWrap(linesBeingWrapped);
1172  	size_t threads = std::min<size_t>({ linesBeingWrapped, view.maxLayoutThreads });
1173  	if (!surface->SupportsFeature(Supports::ThreadSafeMeasureWidths)) {
1174  		threads = 1;
1175  	}
1176  	const bool multiThreaded = threads > 1;
1177  	ElapsedPeriod epWrapping;
1178  	const std::launch policy = multiThreaded ? std::launch::async : std::launch::deferred;
1179  	std::atomic<size_t> nextIndex = 0;
1180  	const SignificantLines significantLines {
1181  		pdoc->SciLineFromPosition(sel.MainCaret()),
1182  		pcs->DocFromDisplay(topLine),
1183  		LinesOnScreen() + 1,
1184  		view.llc.GetLevel(),
1185  	};
1186  	std::mutex mutexRetrieve;
1187  	std::vector<std::future<void>> futures;
1188  	for (size_t th = 0; th < threads; th++) {
1189  		std::future<void> fut = std::async(policy,
1190  			[=, &surface, &nextIndex, &linesAfterWrap, &mutexRetrieve]() {
1191  			std::shared_ptr<LineLayout> llTemporary = std::make_shared<LineLayout>(-1, 200);
1192  			while (true) {
1193  				const size_t i = nextIndex.fetch_add(1, std::memory_order_acq_rel);
1194  				if (i >= linesBeingWrapped) {
1195  					break;
1196  				}
1197  				const Sci::Line lineNumber = lineToWrap + i;
1198  				const Range rangeLine = pdoc->LineRange(lineNumber);
1199  				const Sci::Position lengthLine = rangeLine.Length();
1200  				if (lengthLine < lengthToMultiThread) {
1201  					std::shared_ptr<LineLayout> ll;
1202  					if (significantLines.LineMayCache(lineNumber)) {
1203  						std::lock_guard<std::mutex> guard(mutexRetrieve);
1204  						ll = view.RetrieveLineLayout(lineNumber, *this);
1205  					} else {
1206  						ll = llTemporary;
1207  						ll->ReSet(lineNumber, lengthLine);
1208  					}
1209  					view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth, multiThreaded);
1210  					linesAfterWrap[i] = ll->lines;
1211  				}
1212  			}
1213  		});
1214  		futures.push_back(std::move(fut));
1215  	}
1216  	for (const std::future<void> &f : futures) {
1217  		f.wait();
1218  	}
1219  	const double durationShortLines = epWrapping.Duration(true);
1220  	const double durationShortLinesThreads = durationShortLines * threads;
1221  	std::shared_ptr<LineLayout> llLarge = std::make_shared<LineLayout>(-1, 200);
1222  	for (size_t indexLarge = 0; indexLarge < linesBeingWrapped; indexLarge++) {
1223  		const Sci::Line lineNumber = lineToWrap + indexLarge;
1224  		const Range rangeLine = pdoc->LineRange(lineNumber);
1225  		const Sci::Position lengthLine = rangeLine.Length();
1226  		if (lengthLine >= lengthToMultiThread) {
1227  			std::shared_ptr<LineLayout> ll;
1228  			if (significantLines.LineMayCache(lineNumber)) {
1229  				ll = view.RetrieveLineLayout(lineNumber, *this);
1230  			} else {
1231  				ll = llLarge;
1232  				ll->ReSet(lineNumber, lengthLine);
1233  			}
1234  			view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
1235  			linesAfterWrap[indexLarge] = ll->lines;
1236  		}
1237  	}
1238  	const double durationLongLines = epWrapping.Duration();
1239  	const size_t bytesBeingWrapped = pdoc->LineStart(lineToWrap + linesBeingWrapped) - pdoc->LineStart(lineToWrap);
1240  	size_t wrapsDone = 0;
1241  	for (size_t i = 0; i < linesBeingWrapped; i++) {
1242  		const Sci::Line lineNumber = lineToWrap + i;
1243  		int linesWrapped = linesAfterWrap[i];
1244  		if (vs.annotationVisible != AnnotationVisible::Hidden) {
1245  			linesWrapped += pdoc->AnnotationLines(lineNumber);
1246  		}
1247  		if (pcs->SetHeight(lineNumber, linesWrapped)) {
1248  			wrapsDone++;
1249  		}
1250  		wrapPending.Wrapped(lineNumber);
1251  	}
1252  	durationWrapOneByte.AddSample(bytesBeingWrapped, durationShortLinesThreads + durationLongLines);
1253  	return wrapsDone > 0;
1254  }
1255  bool Editor::WrapLines(WrapScope ws) {
1256  	Sci::Line goodTopLine = topLine;
1257  	bool wrapOccurred = false;
1258  	if (!Wrapping()) {
1259  		if (wrapWidth != LineLayout::wrapWidthInfinite) {
1260  			wrapWidth = LineLayout::wrapWidthInfinite;
1261  			for (Sci::Line lineDoc = 0; lineDoc < pdoc->LinesTotal(); lineDoc++) {
1262  				int linesWrapped = 1;
1263  				if (vs.annotationVisible != AnnotationVisible::Hidden) {
1264  					linesWrapped += pdoc->AnnotationLines(lineDoc);
1265  				}
1266  				pcs->SetHeight(lineDoc, linesWrapped);
1267  			}
1268  			wrapOccurred = true;
1269  		}
1270  		wrapPending.Reset();
1271  	} else if (wrapPending.NeedsWrap()) {
1272  		wrapPending.start = std::min(wrapPending.start, pdoc->LinesTotal());
1273  		if (!SetIdle(true)) {
1274  			ws = WrapScope::wsAll;
1275  		}
1276  		Sci::Line lineToWrap = wrapPending.start;
1277  		Sci::Line lineToWrapEnd = std::min(wrapPending.end, pdoc->LinesTotal());
1278  		const Sci::Line lineDocTop = pcs->DocFromDisplay(topLine);
1279  		const Sci::Line subLineTop = topLine - pcs->DisplayFromDoc(lineDocTop);
1280  		if (ws == WrapScope::wsVisible) {
1281  			lineToWrap = std::clamp(lineDocTop-5, wrapPending.start, pdoc->LinesTotal());
1282  			lineToWrapEnd = lineDocTop;
1283  			Sci::Line lines = LinesOnScreen() + 1;
1284  			constexpr double secondsAllowed = 0.1;
1285  			const size_t actionsInAllowedTime = std::clamp<Sci::Line>(
1286  				durationWrapOneByte.ActionsInAllowedTime(secondsAllowed),
1287  				0x2000, 0x200000);
1288  			const Sci::Line lineLast = pdoc->LineFromPositionAfter(lineToWrap, actionsInAllowedTime);
1289  			const Sci::Line maxLine = std::min(lineLast, pcs->LinesInDoc());
1290  			while ((lineToWrapEnd < maxLine) && (lines>0)) {
1291  				if (pcs->GetVisible(lineToWrapEnd))
1292  					lines--;
1293  				lineToWrapEnd++;
1294  			}
1295  			if ((lineToWrap > wrapPending.end) || (lineToWrapEnd < wrapPending.start)) {
1296  				return false;
1297  			}
1298  		} else if (ws == WrapScope::wsIdle) {
1299  			constexpr double secondsAllowed = 0.01;
1300  			const size_t actionsInAllowedTime = std::clamp<Sci::Line>(
1301  				durationWrapOneByte.ActionsInAllowedTime(secondsAllowed),
1302  				0x200, 0x20000);
1303  			lineToWrapEnd = pdoc->LineFromPositionAfter(lineToWrap, actionsInAllowedTime);
1304  		}
1305  		const Sci::Line lineEndNeedWrap = std::min(wrapPending.end, pdoc->LinesTotal());
1306  		lineToWrapEnd = std::min(lineToWrapEnd, lineEndNeedWrap);
1307  		pdoc->EnsureStyledTo(pdoc->LineStart(lineToWrapEnd));
1308  		if (lineToWrap < lineToWrapEnd) {
1309  			PRectangle rcTextArea = GetClientRectangle();
1310  			rcTextArea.left = static_cast<XYPOSITION>(vs.textStart);
1311  			rcTextArea.right -= vs.rightMarginWidth;
1312  			wrapWidth = static_cast<int>(rcTextArea.Width());
1313  			RefreshStyleData();
1314  			AutoSurface surface(this);
1315  			if (surface) {
1316  				wrapOccurred = WrapBlock(surface, lineToWrap, lineToWrapEnd);
1317  				goodTopLine = pcs->DisplayFromDoc(lineDocTop) + std::min(
1318  					subLineTop, static_cast<Sci::Line>(pcs->GetHeight(lineDocTop)-1));
1319  			}
1320  		}
1321  		if (wrapPending.start >= lineEndNeedWrap) {
1322  			wrapPending.Reset();
1323  		}
1324  	}
1325  	if (wrapOccurred) {
1326  		SetScrollBars();
1327  		SetTopLine(std::clamp<Sci::Line>(goodTopLine, 0, MaxScrollPos()));
1328  		SetVerticalScrollPos();
1329  	}
1330  	return wrapOccurred;
1331  }
1332  void Editor::LinesJoin() {
1333  	if (!RangeContainsProtected(targetRange.start.Position(), targetRange.end.Position())) {
1334  		UndoGroup ug(pdoc);
1335  		const Sci::Line line = pdoc->SciLineFromPosition(targetRange.start.Position());
1336  		for (Sci::Position pos = pdoc->LineEnd(line); pos < targetRange.end.Position(); pos = pdoc->LineEnd(line)) {
1337  			const char chPrev = pdoc->CharAt(pos - 1);
1338  			const Sci::Position widthChar = pdoc->LenChar(pos);
1339  			targetRange.end.Add(-widthChar);
1340  			pdoc->DeleteChars(pos, widthChar);
1341  			if (chPrev != ' ') {
1342  				const Sci::Position lengthInserted = pdoc->InsertString(pos, " ", 1);
1343  				targetRange.end.Add(lengthInserted);
1344  			}
1345  		}
1346  	}
1347  }
1348  void Editor::LinesSplit(int pixelWidth) {
1349  	if (!RangeContainsProtected(targetRange.start.Position(), targetRange.end.Position())) {
1350  		if (pixelWidth == 0) {
1351  			const PRectangle rcText = GetTextRectangle();
1352  			pixelWidth = static_cast<int>(rcText.Width());
1353  		}
1354  		const Sci::Line lineStart = pdoc->SciLineFromPosition(targetRange.start.Position());
1355  		Sci::Line lineEnd = pdoc->SciLineFromPosition(targetRange.end.Position());
1356  		const std::string_view eol = pdoc->EOLString();
1357  		UndoGroup ug(pdoc);
1358  		for (Sci::Line line = lineStart; line <= lineEnd; line++) {
1359  			AutoSurface surface(this);
1360  			std::shared_ptr<LineLayout> ll = view.RetrieveLineLayout(line, *this);
1361  			if (surface && ll) {
1362  				const Sci::Position posLineStart = pdoc->LineStart(line);
1363  				view.LayoutLine(*this, surface, vs, ll.get(), pixelWidth);
1364  				Sci::Position lengthInsertedTotal = 0;
1365  				for (int subLine = 1; subLine < ll->lines; subLine++) {
1366  					const Sci::Position lengthInserted = pdoc->InsertString(
1367  						posLineStart + lengthInsertedTotal + ll->LineStart(subLine), eol);
1368  					targetRange.end.Add(lengthInserted);
1369  					lengthInsertedTotal += lengthInserted;
1370  				}
1371  			}
1372  			lineEnd = pdoc->SciLineFromPosition(targetRange.end.Position());
1373  		}
1374  	}
1375  }
1376  void Editor::PaintSelMargin(Surface *surfaceWindow, const PRectangle &rc) {
1377  	if (vs.fixedColumnWidth == 0)
1378  		return;
1379  	RefreshStyleData();
1380  	RefreshPixMaps(surfaceWindow);
1381  	if (!surfaceWindow->Initialised()) {
1382  		return;
1383  	}
1384  	PRectangle rcMargin = GetClientRectangle();
1385  	const Point ptOrigin = GetVisibleOriginInMain();
1386  	rcMargin.Move(0, -ptOrigin.y);
1387  	rcMargin.left = 0;
1388  	rcMargin.right = static_cast<XYPOSITION>(vs.fixedColumnWidth);
1389  	if (!rc.Intersects(rcMargin))
1390  		return;
1391  	Surface *surface;
1392  	if (view.bufferedDraw) {
1393  		surface = marginView.pixmapSelMargin.get();
1394  	} else {
1395  		surface = surfaceWindow;
1396  	}
1397  	surface->SetMode(CurrentSurfaceMode());
1398  	if (rcMargin.bottom > rc.bottom)
1399  		rcMargin.bottom = rc.bottom;
1400  	if (rcMargin.top < rc.top)
1401  		rcMargin.top = rc.top;
1402  	marginView.PaintMargin(surface, topLine, rc, rcMargin, *this, vs);
1403  	if (view.bufferedDraw) {
1404  		marginView.pixmapSelMargin->FlushDrawing();
1405  		surfaceWindow->Copy(rcMargin, Point(rcMargin.left, rcMargin.top), *marginView.pixmapSelMargin);
1406  	}
1407  }
1408  void Editor::RefreshPixMaps(Surface *surfaceWindow) {
1409  	view.RefreshPixMaps(surfaceWindow, vs);
1410  	marginView.RefreshPixMaps(surfaceWindow, vs);
1411  	if (view.bufferedDraw) {
1412  		const PRectangle rcClient = GetClientRectangle();
1413  		if (!view.pixmapLine) {
1414  			view.pixmapLine = surfaceWindow->AllocatePixMap(static_cast<int>(rcClient.Width()), vs.lineHeight);
1415  		}
1416  		if (!marginView.pixmapSelMargin) {
1417  			marginView.pixmapSelMargin = surfaceWindow->AllocatePixMap(vs.fixedColumnWidth,
1418  				static_cast<int>(rcClient.Height()));
1419  		}
1420  	}
1421  }
1422  void Editor::Paint(Surface *surfaceWindow, PRectangle rcArea) {
1423  	redrawPendingText = false;
1424  	redrawPendingMargin = false;
1425  	RefreshStyleData();
1426  	if (paintState == PaintState::abandoned)
1427  		return;	
1428  	RefreshPixMaps(surfaceWindow);
1429  	paintAbandonedByStyling = false;
1430  	StyleAreaBounded(rcArea, false);
1431  	const PRectangle rcClient = GetClientRectangle();
1432  	if (NotifyUpdateUI()) {
1433  		RefreshStyleData();
1434  		RefreshPixMaps(surfaceWindow);
1435  	}
1436  	if (WrapLines(WrapScope::wsVisible)) {
1437  		if (AbandonPaint()) {
1438  			return;
1439  		}
1440  		RefreshPixMaps(surfaceWindow);	
1441  	}
1442  	if (!marginView.pixmapSelPattern->Initialised()) {
1443  		return;
1444  	}
1445  	if (!view.bufferedDraw)
1446  		surfaceWindow->SetClip(rcArea);
1447  	if (paintState != PaintState::abandoned) {
1448  		if (vs.marginInside) {
1449  			PaintSelMargin(surfaceWindow, rcArea);
1450  			PRectangle rcRightMargin = rcClient;
1451  			rcRightMargin.left = rcRightMargin.right - vs.rightMarginWidth;
1452  			if (rcArea.Intersects(rcRightMargin)) {
1453  				surfaceWindow->FillRectangle(rcRightMargin, vs.styles[StyleDefault].back);
1454  			}
1455  		} else { 
1456  			PRectangle rcLeftMargin = rcArea;
1457  			rcLeftMargin.left = 0;
1458  			rcLeftMargin.right = rcLeftMargin.left + vs.leftMarginWidth;
1459  			if (rcArea.Intersects(rcLeftMargin)) {
1460  				surfaceWindow->FillRectangle(rcLeftMargin, vs.styles[StyleDefault].back);
1461  			}
1462  		}
1463  	}
1464  	if (paintState == PaintState::abandoned) {
1465  		if (Wrapping()) {
1466  			if (paintAbandonedByStyling) {
1467  				NeedWrapping(pcs->DocFromDisplay(topLine));
1468  			}
1469  		}
1470  		if (!view.bufferedDraw)
1471  			surfaceWindow->PopClip();
1472  		return;
1473  	}
1474  	view.PaintText(surfaceWindow, *this, vs, rcArea, rcClient);
1475  	if (horizontalScrollBarVisible && trackLineWidth && (view.lineWidthMaxSeen > scrollWidth)) {
1476  		scrollWidth = view.lineWidthMaxSeen;
1477  		if (!FineTickerRunning(TickReason::widen)) {
1478  			FineTickerStart(TickReason::widen, 50, 5);
1479  		}
1480  	}
1481  	if (!view.bufferedDraw)
1482  		surfaceWindow->PopClip();
1483  	NotifyPainted();
1484  }
1485  Sci::Position Editor::FormatRange(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam) {
1486  	if (!lParam)
1487  		return 0;
1488  	const bool draw = wParam != 0;
1489  	void *ptr = PtrFromSPtr(lParam);
1490  	if (iMessage == Message::FormatRange) {
1491  		RangeToFormat *pfr = static_cast<RangeToFormat *>(ptr);
1492  		const CharacterRangeFull chrg{ pfr->chrg.cpMin,pfr->chrg.cpMax };
1493  		AutoSurface surface(pfr->hdc, this, Technology::Default);
1494  		AutoSurface surfaceMeasure(pfr->hdcTarget, this, Technology::Default);
1495  		if (!surface || !surfaceMeasure) {
1496  			return 0;
1497  		}
1498  		return view.FormatRange(draw, chrg, pfr->rc, surface, surfaceMeasure, *this, vs);
1499  	} else {
1500  		RangeToFormatFull *pfr = static_cast<RangeToFormatFull *>(ptr);
1501  		AutoSurface surface(pfr->hdc, this, Technology::Default);
1502  		AutoSurface surfaceMeasure(pfr->hdcTarget, this, Technology::Default);
1503  		if (!surface || !surfaceMeasure) {
1504  			return 0;
1505  		}
1506  		return view.FormatRange(draw, pfr->chrg, pfr->rc, surface, surfaceMeasure, *this, vs);
1507  	}
1508  }
1509  long Editor::TextWidth(uptr_t style, const char *text) {
1510  	RefreshStyleData();
1511  	AutoSurface surface(this);
1512  	if (surface) {
1513  		return std::lround(surface->WidthText(vs.styles[style].font.get(), text));
1514  	} else {
1515  		return 1;
1516  	}
1517  }
1518  void Editor::ReconfigureScrollBars() {}
1519  void Editor::ChangeScrollBars() {
1520  	RefreshStyleData();
1521  	const Sci::Line nMax = MaxScrollPos();
1522  	const Sci::Line nPage = LinesOnScreen();
1523  	const bool modified = ModifyScrollBars(nMax + nPage - 1, nPage);
1524  	if (modified) {
1525  		DwellEnd(true);
1526  	}
1527  	if (topLine > MaxScrollPos()) {
1528  		SetTopLine(std::clamp<Sci::Line>(topLine, 0, MaxScrollPos()));
1529  		SetVerticalScrollPos();
1530  		Redraw();
1531  	}
1532  	if (modified) {
1533  		if (!AbandonPaint())
1534  			Redraw();
1535  	}
1536  }
1537  void Editor::SetScrollBars() {
1538  	ChangeScrollBars();
1539  }
1540  void Editor::ChangeSize() {
1541  	DropGraphics();
1542  	SetScrollBars();
1543  	if (Wrapping()) {
1544  		PRectangle rcTextArea = GetClientRectangle();
1545  		rcTextArea.left = static_cast<XYPOSITION>(vs.textStart);
1546  		rcTextArea.right -= vs.rightMarginWidth;
1547  		if (wrapWidth != rcTextArea.Width()) {
1548  			NeedWrapping();
1549  			Redraw();
1550  		}
1551  	}
1552  }
1553  Sci::Position Editor::RealizeVirtualSpace(Sci::Position position, Sci::Position virtualSpace) {
1554  	if (virtualSpace > 0) {
1555  		const Sci::Line line = pdoc->SciLineFromPosition(position);
1556  		const Sci::Position indent = pdoc->GetLineIndentPosition(line);
1557  		if (indent == position) {
1558  			return pdoc->SetLineIndentation(line, pdoc->GetLineIndentation(line) + virtualSpace);
1559  		} else {
1560  			const std::string spaceText(virtualSpace, ' ');
1561  			const Sci::Position lengthInserted = pdoc->InsertString(position, spaceText);
1562  			position += lengthInserted;
1563  		}
1564  	}
1565  	return position;
1566  }
1567  SelectionPosition Editor::RealizeVirtualSpace(const SelectionPosition &position) {
1568  	return SelectionPosition(RealizeVirtualSpace(position.Position(), position.VirtualSpace()));
1569  }
1570  void Editor::AddChar(char ch) {
1571  	const char s[1] {ch};
1572  	InsertCharacter(std::string_view(s, 1), CharacterSource::DirectInput);
1573  }
1574  void Editor::FilterSelections() {
1575  	if (!additionalSelectionTyping && (sel.Count() > 1)) {
1576  		InvalidateWholeSelection();
1577  		sel.DropAdditionalRanges();
1578  	}
1579  }
1580  void Editor::InsertCharacter(std::string_view sv, CharacterSource charSource) {
1581  	if (sv.empty()) {
1582  		return;
1583  	}
1584  	FilterSelections();
1585  	bool wrapOccurred = false;
1586  	{
1587  		UndoGroup ug(pdoc, (sel.Count() > 1) || !sel.Empty() || inOverstrike);
1588  		std::vector<SelectionRange *> selPtrs;
1589  		for (size_t r = 0; r < sel.Count(); r++) {
1590  			selPtrs.push_back(&sel.Range(r));
1591  		}
1592  		std::sort(selPtrs.begin(), selPtrs.end(),
1593  			[](const SelectionRange *a, const SelectionRange *b) noexcept {return *a < *b;});
1594  		for (std::vector<SelectionRange *>::reverse_iterator rit = selPtrs.rbegin();
1595  			rit != selPtrs.rend(); ++rit) {
1596  			SelectionRange *currentSel = *rit;
1597  			if (!RangeContainsProtected(currentSel->Start().Position(),
1598  				currentSel->End().Position())) {
1599  				Sci::Position positionInsert = currentSel->Start().Position();
1600  				if (!currentSel->Empty()) {
1601  					if (currentSel->Length()) {
1602  						pdoc->DeleteChars(positionInsert, currentSel->Length());
1603  						currentSel->ClearVirtualSpace();
1604  					} else {
1605  						currentSel->MinimizeVirtualSpace();
1606  					}
1607  				} else if (inOverstrike) {
1608  					if (positionInsert < pdoc->Length()) {
1609  						if (!pdoc->IsPositionInLineEnd(positionInsert)) {
1610  							pdoc->DelChar(positionInsert);
1611  							currentSel->ClearVirtualSpace();
1612  						}
1613  					}
1614  				}
1615  				positionInsert = RealizeVirtualSpace(positionInsert, currentSel->caret.VirtualSpace());
1616  				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, sv);
1617  				if (lengthInserted > 0) {
1618  					currentSel->caret.SetPosition(positionInsert + lengthInserted);
1619  					currentSel->anchor.SetPosition(positionInsert + lengthInserted);
1620  				}
1621  				currentSel->ClearVirtualSpace();
1622  				if (Wrapping()) {
1623  					AutoSurface surface(this);
1624  					if (surface) {
1625  						if (WrapOneLine(surface, pdoc->SciLineFromPosition(positionInsert))) {
1626  							wrapOccurred = true;
1627  						}
1628  					}
1629  				}
1630  			}
1631  		}
1632  	}
1633  	if (wrapOccurred) {
1634  		SetScrollBars();
1635  		SetVerticalScrollPos();
1636  		Redraw();
1637  	}
1638  	ThinRectangularRange();
1639  	EnsureCaretVisible();
1640  	ShowCaretAtCurrentPosition();
1641  	if ((caretSticky == CaretSticky::Off) ||
1642  		((caretSticky == CaretSticky::WhiteSpace) && !IsAllSpacesOrTabs(sv))) {
1643  		SetLastXChosen();
1644  	}
1645  	int ch = static_cast<unsigned char>(sv[0]);
1646  	if (pdoc->dbcsCodePage != CpUtf8) {
1647  		if (sv.length() > 1) {
1648  			ch = (ch << 8) | static_cast<unsigned char>(sv[1]);
1649  		}
1650  	} else {
1651  		if ((ch < 0xC0) || (1 == sv.length())) {
1652  		} else {
1653  			unsigned int utf32[1] = { 0 };
1654  			UTF32FromUTF8(sv, utf32, std::size(utf32));
1655  			ch = utf32[0];
1656  		}
1657  	}
1658  	NotifyChar(ch, charSource);
1659  	if (recordingMacro && charSource != CharacterSource::TentativeInput) {
1660  		std::string copy(sv); 
1661  		NotifyMacroRecord(Message::ReplaceSel, 0, reinterpret_cast<sptr_t>(copy.data()));
1662  	}
1663  }
1664  void Editor::ClearBeforeTentativeStart() {
1665  	FilterSelections();
1666  	UndoGroup ug(pdoc, (sel.Count() > 1) || !sel.Empty() || inOverstrike);
1667  	for (size_t r = 0; r<sel.Count(); r++) {
1668  		if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1669  			sel.Range(r).End().Position())) {
1670  			const Sci::Position positionInsert = sel.Range(r).Start().Position();
1671  			if (!sel.Range(r).Empty()) {
1672  				if (sel.Range(r).Length()) {
1673  					pdoc->DeleteChars(positionInsert, sel.Range(r).Length());
1674  					sel.Range(r).ClearVirtualSpace();
1675  				} else {
1676  					sel.Range(r).MinimizeVirtualSpace();
1677  				}
1678  			}
1679  			RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
1680  			sel.Range(r).ClearVirtualSpace();
1681  		}
1682  	}
1683  }
1684  void Editor::InsertPaste(const char *text, Sci::Position len) {
1685  	if (multiPasteMode == MultiPaste::Once) {
1686  		SelectionPosition selStart = sel.Start();
1687  		selStart = RealizeVirtualSpace(selStart);
1688  		const Sci::Position lengthInserted = pdoc->InsertString(selStart.Position(), text, len);
1689  		if (lengthInserted > 0) {
1690  			SetEmptySelection(selStart.Position() + lengthInserted);
1691  		}
1692  	} else {
1693  		for (size_t r=0; r<sel.Count(); r++) {
1694  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1695  				sel.Range(r).End().Position())) {
1696  				Sci::Position positionInsert = sel.Range(r).Start().Position();
1697  				if (!sel.Range(r).Empty()) {
1698  					if (sel.Range(r).Length()) {
1699  						pdoc->DeleteChars(positionInsert, sel.Range(r).Length());
1700  						sel.Range(r).ClearVirtualSpace();
1701  					} else {
1702  						sel.Range(r).MinimizeVirtualSpace();
1703  					}
1704  				}
1705  				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
1706  				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, text, len);
1707  				if (lengthInserted > 0) {
1708  					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
1709  					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
1710  				}
1711  				sel.Range(r).ClearVirtualSpace();
1712  			}
1713  		}
1714  	}
1715  }
1716  void Editor::InsertPasteShape(const char *text, Sci::Position len, PasteShape shape) {
1717  	std::string convertedText;
1718  	if (convertPastes) {
1719  		convertedText = Document::TransformLineEnds(text, len, pdoc->eolMode);
1720  		len = convertedText.length();
1721  		text = convertedText.c_str();
1722  	}
1723  	if (shape == PasteShape::rectangular) {
1724  		PasteRectangular(sel.Start(), text, len);
1725  	} else {
1726  		if (shape == PasteShape::line) {
1727  			const Sci::Position insertPos =
1728  				pdoc->LineStart(pdoc->LineFromPosition(sel.MainCaret()));
1729  			Sci::Position lengthInserted = pdoc->InsertString(insertPos, text, len);
1730  			if ((len > 0) && (text[len - 1] != '\n' && text[len - 1] != '\r')) {
1731  				const std::string_view endline = pdoc->EOLString();
1732  				lengthInserted += pdoc->InsertString(insertPos + lengthInserted, endline);
1733  			}
1734  			if (sel.MainCaret() == insertPos) {
1735  				SetEmptySelection(sel.MainCaret() + lengthInserted);
1736  			}
1737  		} else {
1738  			InsertPaste(text, len);
1739  		}
1740  	}
1741  }
1742  void Editor::ClearSelection(bool retainMultipleSelections) {
1743  	if (!sel.IsRectangular() && !retainMultipleSelections)
1744  		FilterSelections();
1745  	UndoGroup ug(pdoc);
1746  	for (size_t r=0; r<sel.Count(); r++) {
1747  		if (!sel.Range(r).Empty()) {
1748  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1749  				sel.Range(r).End().Position())) {
1750  				pdoc->DeleteChars(sel.Range(r).Start().Position(),
1751  					sel.Range(r).Length());
1752  				sel.Range(r) = SelectionRange(sel.Range(r).Start());
1753  			}
1754  		}
1755  	}
1756  	ThinRectangularRange();
1757  	sel.RemoveDuplicates();
1758  	ClaimSelection();
1759  	SetHoverIndicatorPosition(sel.MainCaret());
1760  }
1761  void Editor::ClearAll() {
1762  	{
1763  		UndoGroup ug(pdoc);
1764  		if (0 != pdoc->Length()) {
1765  			pdoc->DeleteChars(0, pdoc->Length());
1766  		}
1767  		if (!pdoc->IsReadOnly()) {
1768  			pcs->Clear();
1769  			pdoc->AnnotationClearAll();
1770  			pdoc->EOLAnnotationClearAll();
1771  			pdoc->MarginClearAll();
1772  		}
1773  	}
1774  	view.ClearAllTabstops();
1775  	sel.Clear();
1776  	SetTopLine(0);
1777  	SetVerticalScrollPos();
1778  	InvalidateStyleRedraw();
1779  }
1780  void Editor::ClearDocumentStyle() {
1781  	pdoc->decorations->DeleteLexerDecorations();
1782  	pdoc->StartStyling(0);
1783  	pdoc->SetStyleFor(pdoc->Length(), 0);
1784  	pcs->ShowAll();
1785  	SetAnnotationHeights(0, pdoc->LinesTotal());
1786  	pdoc->ClearLevels();
1787  }
1788  void Editor::CopyAllowLine() {
1789  	SelectionText selectedText;
1790  	CopySelectionRange(&selectedText, true);
1791  	CopyToClipboard(selectedText);
1792  }
1793  void Editor::Cut() {
1794  	pdoc->CheckReadOnly();
1795  	if (!pdoc->IsReadOnly() && !SelectionContainsProtected()) {
1796  		Copy();
1797  		ClearSelection();
1798  	}
1799  }
1800  void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, Sci::Position len) {
1801  	if (pdoc->IsReadOnly() || SelectionContainsProtected()) {
1802  		return;
1803  	}
1804  	sel.Clear();
1805  	sel.RangeMain() = SelectionRange(pos);
1806  	Sci::Line line = pdoc->SciLineFromPosition(sel.MainCaret());
1807  	UndoGroup ug(pdoc);
1808  	sel.RangeMain().caret = RealizeVirtualSpace(sel.RangeMain().caret);
1809  	const int xInsert = XFromPosition(sel.RangeMain().caret);
1810  	bool prevCr = false;
1811  	while ((len > 0) && IsEOLCharacter(ptr[len-1]))
1812  		len--;
1813  	for (Sci::Position i = 0; i < len; i++) {
1814  		if (IsEOLCharacter(ptr[i])) {
1815  			if ((ptr[i] == '\r') || (!prevCr))
1816  				line++;
1817  			if (line >= pdoc->LinesTotal()) {
1818  				const std::string_view eol = pdoc->EOLString();
1819  				pdoc->InsertString(pdoc->LengthNoExcept(), eol);
1820  			}
1821  			sel.RangeMain().caret.SetPosition(PositionFromLineX(line, xInsert));
1822  			if ((XFromPosition(sel.RangeMain().caret) < xInsert) && (i + 1 < len)) {
1823  				while (XFromPosition(sel.RangeMain().caret) < xInsert) {
1824  					assert(pdoc);
1825  					const Sci::Position lengthInserted = pdoc->InsertString(sel.MainCaret(), " ", 1);
1826  					sel.RangeMain().caret.Add(lengthInserted);
1827  				}
1828  			}
1829  			prevCr = ptr[i] == '\r';
1830  		} else {
1831  			const Sci::Position lengthInserted = pdoc->InsertString(sel.MainCaret(), ptr + i, 1);
1832  			sel.RangeMain().caret.Add(lengthInserted);
1833  			prevCr = false;
1834  		}
1835  	}
1836  	SetEmptySelection(pos);
1837  }
1838  bool Editor::CanPaste() {
1839  	return !pdoc->IsReadOnly() && !SelectionContainsProtected();
1840  }
1841  void Editor::Clear() {
1842  	if (sel.Empty()) {
1843  		bool singleVirtual = false;
1844  		if ((sel.Count() == 1) &&
1845  			!RangeContainsProtected(sel.MainCaret(), sel.MainCaret() + 1) &&
1846  			sel.RangeMain().Start().VirtualSpace()) {
1847  			singleVirtual = true;
1848  		}
1849  		UndoGroup ug(pdoc, (sel.Count() > 1) || singleVirtual);
1850  		for (size_t r=0; r<sel.Count(); r++) {
1851  			if (!RangeContainsProtected(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1)) {
1852  				if (sel.Range(r).Start().VirtualSpace()) {
1853  					if (sel.Range(r).anchor < sel.Range(r).caret)
1854  						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
1855  					else
1856  						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
1857  				}
1858  				if ((sel.Count() == 1) || !pdoc->IsPositionInLineEnd(sel.Range(r).caret.Position())) {
1859  					pdoc->DelChar(sel.Range(r).caret.Position());
1860  					sel.Range(r).ClearVirtualSpace();
1861  				}  
1862  			} else {
1863  				sel.Range(r).ClearVirtualSpace();
1864  			}
1865  		}
1866  	} else {
1867  		ClearSelection();
1868  	}
1869  	sel.RemoveDuplicates();
1870  	ShowCaretAtCurrentPosition();		
1871  }
1872  void Editor::SelectAll() {
1873  	sel.Clear();
1874  	SetSelection(0, pdoc->Length());
1875  	Redraw();
1876  }
1877  void Editor::Undo() {
1878  	if (pdoc->CanUndo()) {
1879  		InvalidateCaret();
1880  		const Sci::Position newPos = pdoc->Undo();
1881  		if (newPos >= 0)
1882  			SetEmptySelection(newPos);
1883  		EnsureCaretVisible();
1884  	}
1885  }
1886  void Editor::Redo() {
1887  	if (pdoc->CanRedo()) {
1888  		const Sci::Position newPos = pdoc->Redo();
1889  		if (newPos >= 0)
1890  			SetEmptySelection(newPos);
1891  		EnsureCaretVisible();
1892  	}
1893  }
1894  void Editor::DelCharBack(bool allowLineStartDeletion) {
1895  	RefreshStyleData();
1896  	if (!sel.IsRectangular())
1897  		FilterSelections();
1898  	if (sel.IsRectangular())
1899  		allowLineStartDeletion = false;
1900  	UndoGroup ug(pdoc, (sel.Count() > 1) || !sel.Empty());
1901  	if (sel.Empty()) {
1902  		for (size_t r=0; r<sel.Count(); r++) {
1903  			if (!RangeContainsProtected(sel.Range(r).caret.Position() - 1, sel.Range(r).caret.Position())) {
1904  				if (sel.Range(r).caret.VirtualSpace()) {
1905  					sel.Range(r).caret.SetVirtualSpace(sel.Range(r).caret.VirtualSpace() - 1);
1906  					sel.Range(r).anchor.SetVirtualSpace(sel.Range(r).caret.VirtualSpace());
1907  				} else {
1908  					const Sci::Line lineCurrentPos =
1909  						pdoc->SciLineFromPosition(sel.Range(r).caret.Position());
1910  					if (allowLineStartDeletion || (pdoc->LineStart(lineCurrentPos) != sel.Range(r).caret.Position())) {
1911  						if (pdoc->GetColumn(sel.Range(r).caret.Position()) <= pdoc->GetLineIndentation(lineCurrentPos) &&
1912  								pdoc->GetColumn(sel.Range(r).caret.Position()) > 0 && pdoc->backspaceUnindents) {
1913  							UndoGroup ugInner(pdoc, !ug.Needed());
1914  							const int indentation = pdoc->GetLineIndentation(lineCurrentPos);
1915  							const int indentationStep = pdoc->IndentSize();
1916  							int indentationChange = indentation % indentationStep;
1917  							if (indentationChange == 0)
1918  								indentationChange = indentationStep;
1919  							const Sci::Position posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationChange);
1920  							sel.Range(r) = SelectionRange(posSelect);
1921  						} else {
1922  							pdoc->DelCharBack(sel.Range(r).caret.Position());
1923  						}
1924  					}
1925  				}
1926  			} else {
1927  				sel.Range(r).ClearVirtualSpace();
1928  			}
1929  		}
1930  		ThinRectangularRange();
1931  	} else {
1932  		ClearSelection();
1933  	}
1934  	sel.RemoveDuplicates();
1935  	ContainerNeedsUpdate(Update::Selection);
1936  	ShowCaretAtCurrentPosition();
1937  }
1938  void Editor::NotifyFocus(bool focus) {
1939  	NotificationData scn = {};
1940  	scn.nmhdr.code = focus ? Notification::FocusIn : Notification::FocusOut;
1941  	NotifyParent(scn);
1942  }
1943  void Editor::SetCtrlID(int identifier) {
1944  	ctrlID = identifier;
1945  }
1946  void Editor::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
1947  	NotificationData scn = {};
1948  	scn.nmhdr.code = Notification::StyleNeeded;
1949  	scn.position = endStyleNeeded;
1950  	NotifyParent(scn);
1951  }
1952  void Editor::NotifyStyleNeeded(Document *, void *, Sci::Position endStyleNeeded) {
1953  	NotifyStyleToNeeded(endStyleNeeded);
1954  }
1955  void Editor::NotifyErrorOccurred(Document *, void *, Status status) {
1956  	errorStatus = status;
1957  }
1958  void Editor::NotifyChar(int ch, CharacterSource charSource) {
1959  	NotificationData scn = {};
1960  	scn.nmhdr.code = Notification::CharAdded;
1961  	scn.ch = ch;
1962  	scn.characterSource = charSource;
1963  	NotifyParent(scn);
1964  }
1965  void Editor::NotifySavePoint(bool isSavePoint) {
1966  	NotificationData scn = {};
1967  	if (isSavePoint) {
1968  		scn.nmhdr.code = Notification::SavePointReached;
1969  		if (changeHistoryOption != ChangeHistoryOption::Disabled) {
1970  			Redraw();
1971  		}
1972  	} else {
1973  		scn.nmhdr.code = Notification::SavePointLeft;
1974  	}
1975  	NotifyParent(scn);
1976  }
1977  void Editor::NotifyModifyAttempt() {
1978  	NotificationData scn = {};
1979  	scn.nmhdr.code = Notification::ModifyAttemptRO;
1980  	NotifyParent(scn);
1981  }
1982  void Editor::NotifyDoubleClick(Point pt, KeyMod modifiers) {
1983  	NotificationData scn = {};
1984  	scn.nmhdr.code = Notification::DoubleClick;
1985  	scn.line = LineFromLocation(pt);
1986  	scn.position = PositionFromLocation(pt, true);
1987  	scn.modifiers = modifiers;
1988  	NotifyParent(scn);
1989  }
1990  void Editor::NotifyHotSpotDoubleClicked(Sci::Position position, KeyMod modifiers) {
1991  	NotificationData scn = {};
1992  	scn.nmhdr.code = Notification::HotSpotDoubleClick;
1993  	scn.position = position;
1994  	scn.modifiers = modifiers;
1995  	NotifyParent(scn);
1996  }
1997  void Editor::NotifyHotSpotClicked(Sci::Position position, KeyMod modifiers) {
1998  	NotificationData scn = {};
1999  	scn.nmhdr.code = Notification::HotSpotClick;
2000  	scn.position = position;
2001  	scn.modifiers = modifiers;
2002  	NotifyParent(scn);
2003  }
2004  void Editor::NotifyHotSpotReleaseClick(Sci::Position position, KeyMod modifiers) {
2005  	NotificationData scn = {};
2006  	scn.nmhdr.code = Notification::HotSpotReleaseClick;
2007  	scn.position = position;
2008  	scn.modifiers = modifiers;
2009  	NotifyParent(scn);
2010  }
2011  bool Editor::NotifyUpdateUI() {
2012  	if (needUpdateUI != Update::None) {
2013  		NotificationData scn = {};
2014  		scn.nmhdr.code = Notification::UpdateUI;
2015  		scn.updated = needUpdateUI;
2016  		NotifyParent(scn);
2017  		needUpdateUI = Update::None;
2018  		return true;
2019  	}
2020  	return false;
2021  }
2022  void Editor::NotifyPainted() {
2023  	NotificationData scn = {};
2024  	scn.nmhdr.code = Notification::Painted;
2025  	NotifyParent(scn);
2026  }
2027  void Editor::NotifyIndicatorClick(bool click, Sci::Position position, KeyMod modifiers) {
2028  	const int mask = pdoc->decorations->AllOnFor(position);
2029  	if ((click && mask) || pdoc->decorations->ClickNotified()) {
2030  		NotificationData scn = {};
2031  		pdoc->decorations->SetClickNotified(click);
2032  		scn.nmhdr.code = click ? Notification::IndicatorClick : Notification::IndicatorRelease;
2033  		scn.modifiers = modifiers;
2034  		scn.position = position;
2035  		NotifyParent(scn);
2036  	}
2037  }
2038  bool Editor::NotifyMarginClick(Point pt, KeyMod modifiers) {
2039  	const int marginClicked = vs.MarginFromLocation(pt);
2040  	if ((marginClicked >= 0) && vs.ms[marginClicked].sensitive) {
2041  		const Sci::Position position = pdoc->LineStart(LineFromLocation(pt));
2042  		if ((vs.ms[marginClicked].mask & MaskFolders) && (FlagSet(foldAutomatic, AutomaticFold::Click))) {
2043  			const bool ctrl = FlagSet(modifiers, KeyMod::Ctrl);
2044  			const bool shift = FlagSet(modifiers, KeyMod::Shift);
2045  			const Sci::Line lineClick = pdoc->SciLineFromPosition(position);
2046  			if (shift && ctrl) {
2047  				FoldAll(FoldAction::Toggle);
2048  			} else {
2049  				const FoldLevel levelClick = pdoc->GetFoldLevel(lineClick);
2050  				if (LevelIsHeader(levelClick)) {
2051  					if (shift) {
2052  						FoldExpand(lineClick, FoldAction::Expand, levelClick);
2053  					} else if (ctrl) {
2054  						FoldExpand(lineClick, FoldAction::Toggle, levelClick);
2055  					} else {
2056  						FoldLine(lineClick, FoldAction::Toggle);
2057  					}
2058  				}
2059  			}
2060  			return true;
2061  		}
2062  		NotificationData scn = {};
2063  		scn.nmhdr.code = Notification::MarginClick;
2064  		scn.modifiers = modifiers;
2065  		scn.position = position;
2066  		scn.margin = marginClicked;
2067  		NotifyParent(scn);
2068  		return true;
2069  	} else {
2070  		return false;
2071  	}
2072  }
2073  bool Editor::NotifyMarginRightClick(Point pt, KeyMod modifiers) {
2074  	const int marginRightClicked = vs.MarginFromLocation(pt);
2075  	if ((marginRightClicked >= 0) && vs.ms[marginRightClicked].sensitive) {
2076  		const Sci::Position position = pdoc->LineStart(LineFromLocation(pt));
2077  		NotificationData scn = {};
2078  		scn.nmhdr.code = Notification::MarginRightClick;
2079  		scn.modifiers = modifiers;
2080  		scn.position = position;
2081  		scn.margin = marginRightClicked;
2082  		NotifyParent(scn);
2083  		return true;
2084  	} else {
2085  		return false;
2086  	}
2087  }
2088  void Editor::NotifyNeedShown(Sci::Position pos, Sci::Position len) {
2089  	NotificationData scn = {};
2090  	scn.nmhdr.code = Notification::NeedShown;
2091  	scn.position = pos;
2092  	scn.length = len;
2093  	NotifyParent(scn);
2094  }
2095  void Editor::NotifyDwelling(Point pt, bool state) {
2096  	NotificationData scn = {};
2097  	scn.nmhdr.code = state ? Notification::DwellStart : Notification::DwellEnd;
2098  	scn.position = PositionFromLocation(pt, true);
2099  	scn.x = static_cast<int>(pt.x + vs.ExternalMarginWidth());
2100  	scn.y = static_cast<int>(pt.y);
2101  	NotifyParent(scn);
2102  }
2103  void Editor::NotifyZoom() {
2104  	NotificationData scn = {};
2105  	scn.nmhdr.code = Notification::Zoom;
2106  	NotifyParent(scn);
2107  }
2108  void Editor::NotifyModifyAttempt(Document *, void *) {
2109  	NotifyModifyAttempt();
2110  }
2111  void Editor::NotifySavePoint(Document *, void *, bool atSavePoint) {
2112  	NotifySavePoint(atSavePoint);
2113  }
2114  void Editor::CheckModificationForWrap(DocModification mh) {
2115  	if (FlagSet(mh.modificationType, ModificationFlags::InsertText | ModificationFlags::DeleteText)) {
2116  		view.llc.Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
2117  		const Sci::Line lineDoc = pdoc->SciLineFromPosition(mh.position);
2118  		const Sci::Line lines = std::max(static_cast<Sci::Line>(0), mh.linesAdded);
2119  		if (Wrapping()) {
2120  			NeedWrapping(lineDoc, lineDoc + lines + 1);
2121  		}
2122  		RefreshStyleData();
2123  		SetAnnotationHeights(lineDoc, lineDoc + lines + 2);
2124  	}
2125  }
2126  namespace {
2127  constexpr Sci::Position MovePositionForInsertion(Sci::Position position, Sci::Position startInsertion, Sci::Position length) noexcept {
2128  	if (position > startInsertion) {
2129  		return position + length;
2130  	}
2131  	return position;
2132  }
2133  constexpr Sci::Position MovePositionForDeletion(Sci::Position position, Sci::Position startDeletion, Sci::Position length) noexcept {
2134  	if (position > startDeletion) {
2135  		const Sci::Position endDeletion = startDeletion + length;
2136  		if (position > endDeletion) {
2137  			return position - length;
2138  		} else {
2139  			return startDeletion;
2140  		}
2141  	} else {
2142  		return position;
2143  	}
2144  }
2145  }
2146  void Editor::NotifyModified(Document *, DocModification mh, void *) {
2147  	ContainerNeedsUpdate(Update::Content);
2148  	if (paintState == PaintState::painting) {
2149  		CheckForChangeOutsidePaint(Range(mh.position, mh.position + mh.length));
2150  	}
2151  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeLineState)) {
2152  		if (paintState == PaintState::painting) {
2153  			CheckForChangeOutsidePaint(
2154  			    Range(pdoc->LineStart(mh.line),
2155  					pdoc->LineStart(mh.line + 1)));
2156  		} else {
2157  			Redraw();
2158  		}
2159  	}
2160  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeTabStops)) {
2161  		Redraw();
2162  	}
2163  	if (FlagSet(mh.modificationType, ModificationFlags::LexerState)) {
2164  		if (paintState == PaintState::painting) {
2165  			CheckForChangeOutsidePaint(
2166  			    Range(mh.position, mh.position + mh.length));
2167  		} else {
2168  			Redraw();
2169  		}
2170  	}
2171  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle | ModificationFlags::ChangeIndicator)) {
2172  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle)) {
2173  			pdoc->IncrementStyleClock();
2174  		}
2175  		if (paintState == PaintState::notPainting) {
2176  			const Sci::Line lineDocTop = pcs->DocFromDisplay(topLine);
2177  			if (mh.position < pdoc->LineStart(lineDocTop)) {
2178  				Redraw();
2179  			} else {
2180  				InvalidateRange(mh.position, mh.position + mh.length);
2181  			}
2182  		}
2183  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle)) {
2184  			view.llc.Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
2185  		}
2186  	} else {
2187  		if (FlagSet(mh.modificationType, ModificationFlags::InsertText)) {
2188  			sel.MovePositions(true, mh.position, mh.length);
2189  			braces[0] = MovePositionForInsertion(braces[0], mh.position, mh.length);
2190  			braces[1] = MovePositionForInsertion(braces[1], mh.position, mh.length);
2191  		} else if (FlagSet(mh.modificationType, ModificationFlags::DeleteText)) {
2192  			sel.MovePositions(false, mh.position, mh.length);
2193  			braces[0] = MovePositionForDeletion(braces[0], mh.position, mh.length);
2194  			braces[1] = MovePositionForDeletion(braces[1], mh.position, mh.length);
2195  		}
2196  		if (FlagSet(mh.modificationType, ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete) && pcs->HiddenLines()) {
2197  			const Sci::Line lineOfPos = pdoc->SciLineFromPosition(mh.position);
2198  			Sci::Position endNeedShown = mh.position;
2199  			if (FlagSet(mh.modificationType, ModificationFlags::BeforeInsert)) {
2200  				if (pdoc->ContainsLineEnd(mh.text, mh.length) && (mh.position != pdoc->LineStart(lineOfPos)))
2201  					endNeedShown = pdoc->LineStart(lineOfPos+1);
2202  			} else if (FlagSet(mh.modificationType, ModificationFlags::BeforeDelete)) {
2203  				endNeedShown = mh.position + mh.length;
2204  				Sci::Line lineLast = pdoc->SciLineFromPosition(mh.position+mh.length);
2205  				for (Sci::Line line = lineOfPos + 1; line <= lineLast; line++) {
2206  					const Sci::Line lineMaxSubord = pdoc->GetLastChild(line, {}, -1);
2207  					if (lineLast < lineMaxSubord) {
2208  						lineLast = lineMaxSubord;
2209  						endNeedShown = pdoc->LineEnd(lineLast);
2210  					}
2211  				}
2212  			}
2213  			NeedShown(mh.position, endNeedShown - mh.position);
2214  		}
2215  		if (mh.linesAdded != 0) {
2216  			Sci::Line lineOfPos = pdoc->SciLineFromPosition(mh.position);
2217  			if (mh.position > pdoc->LineStart(lineOfPos))
2218  				lineOfPos++;	
2219  			if (mh.linesAdded > 0) {
2220  				pcs->InsertLines(lineOfPos, mh.linesAdded);
2221  			} else {
2222  				pcs->DeleteLines(lineOfPos, -mh.linesAdded);
2223  			}
2224  			view.LinesAddedOrRemoved(lineOfPos, mh.linesAdded);
2225  		}
2226  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeAnnotation)) {
2227  			const Sci::Line lineDoc = pdoc->SciLineFromPosition(mh.position);
2228  			if (vs.annotationVisible != AnnotationVisible::Hidden) {
2229  				if (pcs->SetHeight(lineDoc, pcs->GetHeight(lineDoc) + static_cast<int>(mh.annotationLinesAdded))) {
2230  					SetScrollBars();
2231  				}
2232  				Redraw();
2233  			}
2234  		}
2235  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeEOLAnnotation)) {
2236  			if (vs.eolAnnotationVisible != EOLAnnotationVisible::Hidden) {
2237  				Redraw();
2238  			}
2239  		}
2240  		CheckModificationForWrap(mh);
2241  		if (mh.linesAdded != 0) {
2242  			if (mh.position < posTopLine && !CanDeferToLastStep(mh)) {
2243  				const Sci::Line newTop = std::clamp<Sci::Line>(topLine + mh.linesAdded, 0, MaxScrollPos());
2244  				if (newTop != topLine) {
2245  					SetTopLine(newTop);
2246  					SetVerticalScrollPos();
2247  				}
2248  			}
2249  			if (paintState == PaintState::notPainting && !CanDeferToLastStep(mh)) {
2250  				if (SynchronousStylingToVisible()) {
2251  					QueueIdleWork(WorkItems::style, pdoc->Length());
2252  				}
2253  				Redraw();
2254  			}
2255  		} else {
2256  			if (paintState == PaintState::notPainting && mh.length && !CanEliminate(mh)) {
2257  				if (SynchronousStylingToVisible()) {
2258  					QueueIdleWork(WorkItems::style, mh.position + mh.length);
2259  				}
2260  				InvalidateRange(mh.position, mh.position + mh.length);
2261  				if (FlagSet(changeHistoryOption, ChangeHistoryOption::Markers)) {
2262  					RedrawSelMargin(pdoc->SciLineFromPosition(mh.position));
2263  				}
2264  			}
2265  		}
2266  	}
2267  	if (mh.linesAdded != 0 && !CanDeferToLastStep(mh)) {
2268  		SetScrollBars();
2269  	}
2270  	if ((FlagSet(mh.modificationType, ModificationFlags::ChangeMarker)) || (FlagSet(mh.modificationType, ModificationFlags::ChangeMargin))) {
2271  		if ((!willRedrawAll) && ((paintState == PaintState::notPainting) || !PaintContainsMargin())) {
2272  			if (FlagSet(mh.modificationType, ModificationFlags::ChangeFold)) {
2273  				RedrawSelMargin(marginView.highlightDelimiter.isEnabled ? -1 : mh.line - 1, true);
2274  			} else {
2275  				RedrawSelMargin(mh.line);
2276  			}
2277  		}
2278  	}
2279  	if ((FlagSet(mh.modificationType, ModificationFlags::ChangeFold)) && (FlagSet(foldAutomatic, AutomaticFold::Change))) {
2280  		FoldChanged(mh.line, mh.foldLevelNow, mh.foldLevelPrev);
2281  	}
2282  	if (IsLastStep(mh)) {
2283  		SetScrollBars();
2284  		Redraw();
2285  	}
2286  	if (FlagSet(mh.modificationType, modEventMask)) {
2287  		if (commandEvents) {
2288  			if ((mh.modificationType & (ModificationFlags::ChangeStyle | ModificationFlags::ChangeIndicator)) == ModificationFlags::None) {
2289  				NotifyChange();	
2290  			}
2291  		}
2292  		NotificationData scn = {};
2293  		scn.nmhdr.code = Notification::Modified;
2294  		scn.position = mh.position;
2295  		scn.modificationType = mh.modificationType;
2296  		scn.text = mh.text;
2297  		scn.length = mh.length;
2298  		scn.linesAdded = mh.linesAdded;
2299  		scn.line = mh.line;
2300  		scn.foldLevelNow = mh.foldLevelNow;
2301  		scn.foldLevelPrev = mh.foldLevelPrev;
2302  		scn.token = static_cast<int>(mh.token);
2303  		scn.annotationLinesAdded = mh.annotationLinesAdded;
2304  		NotifyParent(scn);
2305  	}
2306  }
2307  void Editor::NotifyDeleted(Document *, void *) noexcept {
2308  }
2309  void Editor::NotifyMacroRecord(Message iMessage, uptr_t wParam, sptr_t lParam) {
2310  	switch (iMessage) {
2311  	case Message::Cut:
2312  	case Message::Copy:
2313  	case Message::Paste:
2314  	case Message::Clear:
2315  	case Message::ReplaceSel:
2316  	case Message::AddText:
2317  	case Message::InsertText:
2318  	case Message::AppendText:
2319  	case Message::ClearAll:
2320  	case Message::SelectAll:
2321  	case Message::GotoLine:
2322  	case Message::GotoPos:
2323  	case Message::SearchAnchor:
2324  	case Message::SearchNext:
2325  	case Message::SearchPrev:
2326  	case Message::LineDown:
2327  	case Message::LineDownExtend:
2328  	case Message::ParaDown:
2329  	case Message::ParaDownExtend:
2330  	case Message::LineUp:
2331  	case Message::LineUpExtend:
2332  	case Message::ParaUp:
2333  	case Message::ParaUpExtend:
2334  	case Message::CharLeft:
2335  	case Message::CharLeftExtend:
2336  	case Message::CharRight:
2337  	case Message::CharRightExtend:
2338  	case Message::WordLeft:
2339  	case Message::WordLeftExtend:
2340  	case Message::WordRight:
2341  	case Message::WordRightExtend:
2342  	case Message::WordPartLeft:
2343  	case Message::WordPartLeftExtend:
2344  	case Message::WordPartRight:
2345  	case Message::WordPartRightExtend:
2346  	case Message::WordLeftEnd:
2347  	case Message::WordLeftEndExtend:
2348  	case Message::WordRightEnd:
2349  	case Message::WordRightEndExtend:
2350  	case Message::Home:
2351  	case Message::HomeExtend:
2352  	case Message::LineEnd:
2353  	case Message::LineEndExtend:
2354  	case Message::HomeWrap:
2355  	case Message::HomeWrapExtend:
2356  	case Message::LineEndWrap:
2357  	case Message::LineEndWrapExtend:
2358  	case Message::DocumentStart:
2359  	case Message::DocumentStartExtend:
2360  	case Message::DocumentEnd:
2361  	case Message::DocumentEndExtend:
2362  	case Message::StutteredPageUp:
2363  	case Message::StutteredPageUpExtend:
2364  	case Message::StutteredPageDown:
2365  	case Message::StutteredPageDownExtend:
2366  	case Message::PageUp:
2367  	case Message::PageUpExtend:
2368  	case Message::PageDown:
2369  	case Message::PageDownExtend:
2370  	case Message::EditToggleOvertype:
2371  	case Message::Cancel:
2372  	case Message::DeleteBack:
2373  	case Message::Tab:
2374  	case Message::BackTab:
2375  	case Message::FormFeed:
2376  	case Message::VCHome:
2377  	case Message::VCHomeExtend:
2378  	case Message::VCHomeWrap:
2379  	case Message::VCHomeWrapExtend:
2380  	case Message::VCHomeDisplay:
2381  	case Message::VCHomeDisplayExtend:
2382  	case Message::DelWordLeft:
2383  	case Message::DelWordRight:
2384  	case Message::DelWordRightEnd:
2385  	case Message::DelLineLeft:
2386  	case Message::DelLineRight:
2387  	case Message::LineCopy:
2388  	case Message::LineCut:
2389  	case Message::LineDelete:
2390  	case Message::LineTranspose:
2391  	case Message::LineReverse:
2392  	case Message::LineDuplicate:
2393  	case Message::LowerCase:
2394  	case Message::UpperCase:
2395  	case Message::LineScrollDown:
2396  	case Message::LineScrollUp:
2397  	case Message::DeleteBackNotLine:
2398  	case Message::HomeDisplay:
2399  	case Message::HomeDisplayExtend:
2400  	case Message::LineEndDisplay:
2401  	case Message::LineEndDisplayExtend:
2402  	case Message::SetSelectionMode:
2403  	case Message::LineDownRectExtend:
2404  	case Message::LineUpRectExtend:
2405  	case Message::CharLeftRectExtend:
2406  	case Message::CharRightRectExtend:
2407  	case Message::HomeRectExtend:
2408  	case Message::VCHomeRectExtend:
2409  	case Message::LineEndRectExtend:
2410  	case Message::PageUpRectExtend:
2411  	case Message::PageDownRectExtend:
2412  	case Message::SelectionDuplicate:
2413  	case Message::CopyAllowLine:
2414  	case Message::VerticalCentreCaret:
2415  	case Message::MoveSelectedLinesUp:
2416  	case Message::MoveSelectedLinesDown:
2417  	case Message::ScrollToStart:
2418  	case Message::ScrollToEnd:
2419  		break;
2420  	case Message::NewLine:
2421  	default:
2422  		return;
2423  	}
2424  	NotificationData scn = {};
2425  	scn.nmhdr.code = Notification::MacroRecord;
2426  	scn.message = iMessage;
2427  	scn.wParam = wParam;
2428  	scn.lParam = lParam;
2429  	NotifyParent(scn);
2430  }
2431  void Editor::ContainerNeedsUpdate(Update flags) noexcept {
2432  	needUpdateUI = needUpdateUI | flags;
2433  }
2434  void Editor::PageMove(int direction, Selection::SelTypes selt, bool stuttered) {
2435  	Sci::Line topLineNew;
2436  	SelectionPosition newPos;
2437  	const Sci::Line currentLine = pdoc->SciLineFromPosition(sel.MainCaret());
2438  	const Sci::Line topStutterLine = topLine + caretPolicies.y.slop;
2439  	const Sci::Line bottomStutterLine =
2440  	    pdoc->SciLineFromPosition(PositionFromLocation(
2441  	                Point::FromInts(lastXChosen - xOffset, direction * vs.lineHeight * static_cast<int>(LinesToScroll()))))
2442  	    - caretPolicies.y.slop - 1;
2443  	if (stuttered && (direction < 0 && currentLine > topStutterLine)) {
2444  		topLineNew = topLine;
2445  		newPos = SPositionFromLocation(Point::FromInts(lastXChosen - xOffset, vs.lineHeight * caretPolicies.y.slop),
2446  			false, false, UserVirtualSpace());
2447  	} else if (stuttered && (direction > 0 && currentLine < bottomStutterLine)) {
2448  		topLineNew = topLine;
2449  		newPos = SPositionFromLocation(Point::FromInts(lastXChosen - xOffset, vs.lineHeight * static_cast<int>(LinesToScroll() - caretPolicies.y.slop)),
2450  			false, false, UserVirtualSpace());
2451  	} else {
2452  		const Point pt = LocationFromPosition(sel.MainCaret());
2453  		topLineNew = std::clamp<Sci::Line>(
2454  		            topLine + direction * LinesToScroll(), 0, MaxScrollPos());
2455  		newPos = SPositionFromLocation(
2456  			Point::FromInts(lastXChosen - xOffset, static_cast<int>(pt.y) +
2457  				direction * (vs.lineHeight * static_cast<int>(LinesToScroll()))),
2458  			false, false, UserVirtualSpace());
2459  	}
2460  	if (topLineNew != topLine) {
2461  		SetTopLine(topLineNew);
2462  		MovePositionTo(newPos, selt);
2463  		SetVerticalScrollPos();
2464  		Redraw();
2465  	} else {
2466  		MovePositionTo(newPos, selt);
2467  	}
2468  }
2469  void Editor::ChangeCaseOfSelection(CaseMapping caseMapping) {
2470  	UndoGroup ug(pdoc);
2471  	for (size_t r=0; r<sel.Count(); r++) {
2472  		SelectionRange current = sel.Range(r);
2473  		SelectionRange currentNoVS = current;
2474  		currentNoVS.ClearVirtualSpace();
2475  		const size_t rangeBytes = currentNoVS.Length();
2476  		if (rangeBytes > 0) {
2477  			std::string sText = RangeText(currentNoVS.Start().Position(), currentNoVS.End().Position());
2478  			std::string sMapped = CaseMapString(sText, caseMapping);
2479  			if (sMapped != sText) {
2480  				size_t firstDifference = 0;
2481  				while (sMapped[firstDifference] == sText[firstDifference])
2482  					firstDifference++;
2483  				size_t lastDifferenceText = sText.size() - 1;
2484  				size_t lastDifferenceMapped = sMapped.size() - 1;
2485  				while (sMapped[lastDifferenceMapped] == sText[lastDifferenceText]) {
2486  					lastDifferenceText--;
2487  					lastDifferenceMapped--;
2488  				}
2489  				const size_t endDifferenceText = sText.size() - 1 - lastDifferenceText;
2490  				pdoc->DeleteChars(
2491  					currentNoVS.Start().Position() + firstDifference,
2492  					rangeBytes - firstDifference - endDifferenceText);
2493  				const Sci::Position lengthChange = lastDifferenceMapped - firstDifference + 1;
2494  				const Sci::Position lengthInserted = pdoc->InsertString(
2495  					currentNoVS.Start().Position() + firstDifference,
2496  					sMapped.c_str() + firstDifference,
2497  					lengthChange);
2498  				const Sci::Position diffSizes = sMapped.size() - sText.size() + lengthInserted - lengthChange;
2499  				if (diffSizes != 0) {
2500  					if (current.anchor > current.caret)
2501  						current.anchor.Add(diffSizes);
2502  					else
2503  						current.caret.Add(diffSizes);
2504  				}
2505  				sel.Range(r) = current;
2506  			}
2507  		}
2508  	}
2509  }
2510  void Editor::LineTranspose() {
2511  	const Sci::Line line = pdoc->SciLineFromPosition(sel.MainCaret());
2512  	if (line > 0) {
2513  		UndoGroup ug(pdoc);
2514  		const Sci::Position startPrevious = pdoc->LineStart(line - 1);
2515  		const std::string linePrevious = RangeText(startPrevious, pdoc->LineEnd(line - 1));
2516  		Sci::Position startCurrent = pdoc->LineStart(line);
2517  		const std::string lineCurrent = RangeText(startCurrent, pdoc->LineEnd(line));
2518  		pdoc->DeleteChars(startCurrent, lineCurrent.length());
2519  		pdoc->DeleteChars(startPrevious, linePrevious.length());
2520  		startCurrent -= linePrevious.length();
2521  		startCurrent += pdoc->InsertString(startPrevious, lineCurrent);
2522  		pdoc->InsertString(startCurrent, linePrevious);
2523  		MovePositionTo(SelectionPosition(startCurrent));
2524  	}
2525  }
2526  void Editor::LineReverse() {
2527  	const Sci::Line lineStart =
2528  		pdoc->SciLineFromPosition(sel.RangeMain().Start().Position());
2529  	const Sci::Line lineEnd =
2530  		pdoc->SciLineFromPosition(sel.RangeMain().End().Position()-1);
2531  	const Sci::Line lineDiff = lineEnd - lineStart;
2532  	if (lineDiff <= 0)
2533  		return;
2534  	UndoGroup ug(pdoc);
2535  	for (Sci::Line i=(lineDiff+1)/2-1; i>=0; --i) {
2536  		const Sci::Line lineNum2 = lineEnd - i;
2537  		const Sci::Line lineNum1 = lineStart + i;
2538  		Sci::Position lineStart2 = pdoc->LineStart(lineNum2);
2539  		const Sci::Position lineStart1 = pdoc->LineStart(lineNum1);
2540  		const std::string line2 = RangeText(lineStart2, pdoc->LineEnd(lineNum2));
2541  		const std::string line1 = RangeText(lineStart1, pdoc->LineEnd(lineNum1));
2542  		const Sci::Position lineLen2 = line2.length();
2543  		const Sci::Position lineLen1 = line1.length();
2544  		pdoc->DeleteChars(lineStart2, lineLen2);
2545  		pdoc->DeleteChars(lineStart1, lineLen1);
2546  		lineStart2 -= lineLen1;
2547  		pdoc->InsertString(lineStart2, line1);
2548  		pdoc->InsertString(lineStart1, line2);
2549  	}
2550  	sel.RangeMain() = SelectionRange(pdoc->LineStart(lineStart),
2551  		pdoc->LineStart(lineEnd+1));
2552  }
2553  void Editor::Duplicate(bool forLine) {
2554  	if (sel.Empty()) {
2555  		forLine = true;
2556  	}
2557  	UndoGroup ug(pdoc);
2558  	std::string_view eol;
2559  	if (forLine) {
2560  		eol = pdoc->EOLString();
2561  	}
2562  	for (size_t r=0; r<sel.Count(); r++) {
2563  		SelectionPosition start = sel.Range(r).Start();
2564  		SelectionPosition end = sel.Range(r).End();
2565  		if (forLine) {
2566  			const Sci::Line line = pdoc->SciLineFromPosition(sel.Range(r).caret.Position());
2567  			start = SelectionPosition(pdoc->LineStart(line));
2568  			end = SelectionPosition(pdoc->LineEnd(line));
2569  		}
2570  		std::string text = RangeText(start.Position(), end.Position());
2571  		Sci::Position lengthInserted = 0;
2572  		if (forLine)
2573  			lengthInserted = pdoc->InsertString(end.Position(), eol);
2574  		pdoc->InsertString(end.Position() + lengthInserted, text);
2575  	}
2576  	if (sel.Count() && sel.IsRectangular()) {
2577  		SelectionPosition last = sel.Last();
2578  		if (forLine) {
2579  			const Sci::Line line = pdoc->SciLineFromPosition(last.Position());
2580  			last = SelectionPosition(last.Position() +
2581  				pdoc->LineStart(line+1) - pdoc->LineStart(line));
2582  		}
2583  		if (sel.Rectangular().anchor > sel.Rectangular().caret)
2584  			sel.Rectangular().anchor = last;
2585  		else
2586  			sel.Rectangular().caret = last;
2587  		SetRectangularRange();
2588  	}
2589  }
2590  void Editor::CancelModes() {
2591  	sel.SetMoveExtends(false);
2592  }
2593  void Editor::NewLine() {
2594  	InvalidateWholeSelection();
2595  	if (sel.IsRectangular() || !additionalSelectionTyping) {
2596  		sel.DropAdditionalRanges();
2597  	}
2598  	UndoGroup ug(pdoc, !sel.Empty() || (sel.Count() > 1));
2599  	if (!sel.Empty()) {
2600  		ClearSelection();
2601  	}
2602  	size_t countInsertions = 0;
2603  	const std::string_view eol = pdoc->EOLString();
2604  	for (size_t r = 0; r < sel.Count(); r++) {
2605  		sel.Range(r).ClearVirtualSpace();
2606  		const Sci::Position positionInsert = sel.Range(r).caret.Position();
2607  		const Sci::Position insertLength = pdoc->InsertString(positionInsert, eol);
2608  		if (insertLength > 0) {
2609  			sel.Range(r) = SelectionRange(positionInsert + insertLength);
2610  			countInsertions++;
2611  		}
2612  	}
2613  	for (size_t i = 0; i < countInsertions; i++) {
2614  		for (const char ch : eol) {
2615  			NotifyChar(ch, CharacterSource::DirectInput);
2616  			if (recordingMacro) {
2617  				const char txt[2] = { ch, '\0' };
2618  				NotifyMacroRecord(Message::ReplaceSel, 0, reinterpret_cast<sptr_t>(txt));
2619  			}
2620  		}
2621  	}
2622  	SetLastXChosen();
2623  	SetScrollBars();
2624  	EnsureCaretVisible();
2625  	ShowCaretAtCurrentPosition();
2626  }
2627  SelectionPosition Editor::PositionUpOrDown(SelectionPosition spStart, int direction, int lastX) {
2628  	const Point pt = LocationFromPosition(spStart);
2629  	int skipLines = 0;
2630  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
2631  		const Sci::Line lineDoc = pdoc->SciLineFromPosition(spStart.Position());
2632  		const Point ptStartLine = LocationFromPosition(pdoc->LineStart(lineDoc));
2633  		const int subLine = static_cast<int>(pt.y - ptStartLine.y) / vs.lineHeight;
2634  		if (direction < 0 && subLine == 0) {
2635  			const Sci::Line lineDisplay = pcs->DisplayFromDoc(lineDoc);
2636  			if (lineDisplay > 0) {
2637  				skipLines = pdoc->AnnotationLines(pcs->DocFromDisplay(lineDisplay - 1));
2638  			}
2639  		} else if (direction > 0 && subLine >= (pcs->GetHeight(lineDoc) - 1 - pdoc->AnnotationLines(lineDoc))) {
2640  			skipLines = pdoc->AnnotationLines(lineDoc);
2641  		}
2642  	}
2643  	const Sci::Line newY = static_cast<Sci::Line>(pt.y) + (1 + skipLines) * direction * vs.lineHeight;
2644  	if (lastX < 0) {
2645  		lastX = static_cast<int>(pt.x) + xOffset;
2646  	}
2647  	SelectionPosition posNew = SPositionFromLocation(
2648  		Point::FromInts(lastX - xOffset, static_cast<int>(newY)), false, false, UserVirtualSpace());
2649  	if (direction < 0) {
2650  		Point ptNew = LocationFromPosition(posNew.Position());
2651  		while ((posNew.Position() > 0) && (pt.y == ptNew.y)) {
2652  			posNew.Add(-1);
2653  			posNew.SetVirtualSpace(0);
2654  			ptNew = LocationFromPosition(posNew.Position());
2655  		}
2656  	} else if (direction > 0 && posNew.Position() != pdoc->Length()) {
2657  		Point ptNew = LocationFromPosition(posNew.Position());
2658  		while ((posNew.Position() > spStart.Position()) && (ptNew.y > newY)) {
2659  			posNew.Add(-1);
2660  			posNew.SetVirtualSpace(0);
2661  			ptNew = LocationFromPosition(posNew.Position());
2662  		}
2663  	}
2664  	return posNew;
2665  }
2666  void Editor::CursorUpOrDown(int direction, Selection::SelTypes selt) {
2667  	if ((selt == Selection::SelTypes::none) && sel.MoveExtends()) {
2668  		selt = !sel.IsRectangular() ? Selection::SelTypes::stream : Selection::SelTypes::rectangle;
2669  	}
2670  	SelectionPosition caretToUse = sel.Range(sel.Main()).caret;
2671  	if (sel.IsRectangular()) {
2672  		if (selt ==  Selection::SelTypes::none) {
2673  			caretToUse = (direction > 0) ? sel.Limits().end : sel.Limits().start;
2674  		} else {
2675  			caretToUse = sel.Rectangular().caret;
2676  		}
2677  	}
2678  	if (selt == Selection::SelTypes::rectangle) {
2679  		const SelectionRange rangeBase = sel.IsRectangular() ? sel.Rectangular() : sel.RangeMain();
2680  		if (!sel.IsRectangular()) {
2681  			InvalidateWholeSelection();
2682  			sel.DropAdditionalRanges();
2683  		}
2684  		const SelectionPosition posNew = MovePositionSoVisible(
2685  			PositionUpOrDown(caretToUse, direction, lastXChosen), direction);
2686  		sel.selType = Selection::SelTypes::rectangle;
2687  		sel.Rectangular() = SelectionRange(posNew, rangeBase.anchor);
2688  		SetRectangularRange();
2689  		MovedCaret(posNew, caretToUse, true, caretPolicies);
2690  	} else if (sel.selType == Selection::SelTypes::lines && sel.MoveExtends()) {
2691  		const SelectionPosition posNew = MovePositionSoVisible(
2692  			PositionUpOrDown(caretToUse, direction, -1), direction);
2693  		SetSelection(posNew, sel.Range(sel.Main()).anchor);
2694  	} else {
2695  		InvalidateWholeSelection();
2696  		if (!additionalSelectionTyping || (sel.IsRectangular())) {
2697  			sel.DropAdditionalRanges();
2698  		}
2699  		sel.selType = Selection::SelTypes::stream;
2700  		for (size_t r = 0; r < sel.Count(); r++) {
2701  			const int lastX = (r == sel.Main()) ? lastXChosen : -1;
2702  			const SelectionPosition spCaretNow = sel.Range(r).caret;
2703  			const SelectionPosition posNew = MovePositionSoVisible(
2704  				PositionUpOrDown(spCaretNow, direction, lastX), direction);
2705  			sel.Range(r) = selt == Selection::SelTypes::stream ?
2706  				SelectionRange(posNew, sel.Range(r).anchor) : SelectionRange(posNew);
2707  		}
2708  		sel.RemoveDuplicates();
2709  		MovedCaret(sel.RangeMain().caret, caretToUse, true, caretPolicies);
2710  	}
2711  }
2712  void Editor::ParaUpOrDown(int direction, Selection::SelTypes selt) {
2713  	Sci::Line lineDoc;
2714  	const Sci::Position savedPos = sel.MainCaret();
2715  	do {
2716  		MovePositionTo(SelectionPosition(direction > 0 ? pdoc->ParaDown(sel.MainCaret()) : pdoc->ParaUp(sel.MainCaret())), selt);
2717  		lineDoc = pdoc->SciLineFromPosition(sel.MainCaret());
2718  		if (direction > 0) {
2719  			if (sel.MainCaret() >= pdoc->Length() && !pcs->GetVisible(lineDoc)) {
2720  				if (selt == Selection::SelTypes::none) {
2721  					MovePositionTo(SelectionPosition(pdoc->LineEndPosition(savedPos)));
2722  				}
2723  				break;
2724  			}
2725  		}
2726  	} while (!pcs->GetVisible(lineDoc));
2727  }
2728  Range Editor::RangeDisplayLine(Sci::Line lineVisible) {
2729  	RefreshStyleData();
2730  	AutoSurface surface(this);
2731  	return view.RangeDisplayLine(surface, *this, lineVisible, vs);
2732  }
2733  Sci::Position Editor::StartEndDisplayLine(Sci::Position pos, bool start) {
2734  	RefreshStyleData();
2735  	AutoSurface surface(this);
2736  	const Sci::Position posRet = view.StartEndDisplayLine(surface, *this, pos, start, vs);
2737  	if (posRet == Sci::invalidPosition) {
2738  		return pos;
2739  	} else {
2740  		return posRet;
2741  	}
2742  }
2743  namespace {
2744  constexpr short HighShortFromWParam(uptr_t x) {
2745  	return static_cast<short>(x >> 16);
2746  }
2747  constexpr short LowShortFromWParam(uptr_t x) {
2748  	return static_cast<short>(x & 0xffff);
2749  }
2750  constexpr Message WithExtends(Message iMessage) noexcept {
2751  	switch (iMessage) {
2752  	case Message::CharLeft: return Message::CharLeftExtend;
2753  	case Message::CharRight: return Message::CharRightExtend;
2754  	case Message::WordLeft: return Message::WordLeftExtend;
2755  	case Message::WordRight: return Message::WordRightExtend;
2756  	case Message::WordLeftEnd: return Message::WordLeftEndExtend;
2757  	case Message::WordRightEnd: return Message::WordRightEndExtend;
2758  	case Message::WordPartLeft: return Message::WordPartLeftExtend;
2759  	case Message::WordPartRight: return Message::WordPartRightExtend;
2760  	case Message::Home: return Message::HomeExtend;
2761  	case Message::HomeDisplay: return Message::HomeDisplayExtend;
2762  	case Message::HomeWrap: return Message::HomeWrapExtend;
2763  	case Message::VCHome: return Message::VCHomeExtend;
2764  	case Message::VCHomeDisplay: return Message::VCHomeDisplayExtend;
2765  	case Message::VCHomeWrap: return Message::VCHomeWrapExtend;
2766  	case Message::LineEnd: return Message::LineEndExtend;
2767  	case Message::LineEndDisplay: return Message::LineEndDisplayExtend;
2768  	case Message::LineEndWrap: return Message::LineEndWrapExtend;
2769  	default:	return iMessage;
2770  	}
2771  }
2772  constexpr int NaturalDirection(Message iMessage) noexcept {
2773  	switch (iMessage) {
2774  	case Message::CharLeft:
2775  	case Message::CharLeftExtend:
2776  	case Message::CharLeftRectExtend:
2777  	case Message::WordLeft:
2778  	case Message::WordLeftExtend:
2779  	case Message::WordLeftEnd:
2780  	case Message::WordLeftEndExtend:
2781  	case Message::WordPartLeft:
2782  	case Message::WordPartLeftExtend:
2783  	case Message::Home:
2784  	case Message::HomeExtend:
2785  	case Message::HomeDisplay:
2786  	case Message::HomeDisplayExtend:
2787  	case Message::HomeWrap:
2788  	case Message::HomeWrapExtend:
2789  	case Message::VCHome:
2790  	case Message::VCHomeExtend:
2791  	case Message::VCHomeDisplay:
2792  	case Message::VCHomeDisplayExtend:
2793  	case Message::VCHomeWrap:
2794  	case Message::VCHomeWrapExtend:
2795  		return -1;
2796  	default:
2797  		return 1;
2798  	}
2799  }
2800  constexpr bool IsRectExtend(Message iMessage, bool isRectMoveExtends) noexcept {
2801  	switch (iMessage) {
2802  	case Message::CharLeftRectExtend:
2803  	case Message::CharRightRectExtend:
2804  	case Message::HomeRectExtend:
2805  	case Message::VCHomeRectExtend:
2806  	case Message::LineEndRectExtend:
2807  		return true;
2808  	default:
2809  		if (isRectMoveExtends) {
2810  			switch (iMessage) {
2811  			case Message::CharLeftExtend:
2812  			case Message::CharRightExtend:
2813  			case Message::HomeExtend:
2814  			case Message::VCHomeExtend:
2815  			case Message::LineEndExtend:
2816  				return true;
2817  			default:
2818  				return false;
2819  			}
2820  		}
2821  		return false;
2822  	}
2823  }
2824  }
2825  Sci::Position Editor::VCHomeDisplayPosition(Sci::Position position) {
2826  	const Sci::Position homePos = pdoc->VCHomePosition(position);
2827  	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
2828  	if (viewLineStart > homePos)
2829  		return viewLineStart;
2830  	else
2831  		return homePos;
2832  }
2833  Sci::Position Editor::VCHomeWrapPosition(Sci::Position position) {
2834  	const Sci::Position homePos = pdoc->VCHomePosition(position);
2835  	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
2836  	if ((viewLineStart < position) && (viewLineStart > homePos))
2837  		return viewLineStart;
2838  	else
2839  		return homePos;
2840  }
2841  Sci::Position Editor::LineEndWrapPosition(Sci::Position position) {
2842  	const Sci::Position endPos = StartEndDisplayLine(position, false);
2843  	const Sci::Position realEndPos = pdoc->LineEndPosition(position);
2844  	if (endPos > realEndPos      
2845  		|| position >= endPos) 
2846  		return realEndPos;
2847  	else
2848  		return endPos;
2849  }
2850  int Editor::HorizontalMove(Message iMessage) {
2851  	if (sel.selType == Selection::SelTypes::lines) {
2852  		return 0; 
2853  	}
2854  	if (sel.MoveExtends()) {
2855  		iMessage = WithExtends(iMessage);
2856  	}
2857  	if (!multipleSelection && !sel.IsRectangular()) {
2858  		sel.SetSelection(sel.RangeMain());
2859  	}
2860  	InvalidateWholeSelection();
2861  	if (IsRectExtend(iMessage, sel.IsRectangular() && sel.MoveExtends())) {
2862  		const SelectionRange rangeBase = sel.IsRectangular() ? sel.Rectangular() : sel.RangeMain();
2863  		if (!sel.IsRectangular()) {
2864  			sel.DropAdditionalRanges();
2865  		}
2866  		SelectionPosition spCaret = rangeBase.caret;
2867  		switch (iMessage) {
2868  		case Message::CharLeftRectExtend:
2869  		case Message::CharLeftExtend: 
2870  			if (pdoc->IsLineEndPosition(spCaret.Position()) && spCaret.VirtualSpace()) {
2871  				spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
2872  			} else if (!FlagSet(virtualSpaceOptions, VirtualSpace::NoWrapLineStart) || pdoc->GetColumn(spCaret.Position()) > 0) {
2873  				spCaret = SelectionPosition(spCaret.Position() - 1);
2874  			}
2875  			break;
2876  		case Message::CharRightRectExtend:
2877  		case Message::CharRightExtend: 
2878  			if (FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection) && pdoc->IsLineEndPosition(sel.MainCaret())) {
2879  				spCaret.SetVirtualSpace(spCaret.VirtualSpace() + 1);
2880  			} else {
2881  				spCaret = SelectionPosition(spCaret.Position() + 1);
2882  			}
2883  			break;
2884  		case Message::HomeRectExtend:
2885  		case Message::HomeExtend: 
2886  			spCaret = SelectionPosition(
2887  				pdoc->LineStart(pdoc->LineFromPosition(spCaret.Position())));
2888  			break;
2889  		case Message::VCHomeRectExtend:
2890  		case Message::VCHomeExtend: 
2891  			spCaret = SelectionPosition(pdoc->VCHomePosition(spCaret.Position()));
2892  			break;
2893  		case Message::LineEndRectExtend:
2894  		case Message::LineEndExtend: 
2895  			spCaret = SelectionPosition(pdoc->LineEndPosition(spCaret.Position()));
2896  			break;
2897  		default:
2898  			break;
2899  		}
2900  		const int directionMove = (spCaret < rangeBase.caret) ? -1 : 1;
2901  		spCaret = MovePositionSoVisible(spCaret, directionMove);
2902  		sel.selType = Selection::SelTypes::rectangle;
2903  		sel.Rectangular() = SelectionRange(spCaret, rangeBase.anchor);
2904  		SetRectangularRange();
2905  	} else if (sel.IsRectangular()) {
2906  		SelectionPosition selAtLimit = (NaturalDirection(iMessage) > 0) ? sel.Limits().end : sel.Limits().start;
2907  		switch (iMessage) {
2908  		case Message::Home:
2909  			selAtLimit = SelectionPosition(
2910  				pdoc->LineStart(pdoc->LineFromPosition(selAtLimit.Position())));
2911  			break;
2912  		case Message::VCHome:
2913  			selAtLimit = SelectionPosition(pdoc->VCHomePosition(selAtLimit.Position()));
2914  			break;
2915  		case Message::LineEnd:
2916  			selAtLimit = SelectionPosition(pdoc->LineEndPosition(selAtLimit.Position()));
2917  			break;
2918  		default:
2919  			break;
2920  		}
2921  		sel.selType = Selection::SelTypes::stream;
2922  		sel.SetSelection(SelectionRange(selAtLimit));
2923  	} else {
2924  		if (!additionalSelectionTyping) {
2925  			InvalidateWholeSelection();
2926  			sel.DropAdditionalRanges();
2927  		}
2928  		for (size_t r = 0; r < sel.Count(); r++) {
2929  			const SelectionPosition spCaretNow = sel.Range(r).caret;
2930  			SelectionPosition spCaret = spCaretNow;
2931  			switch (iMessage) {
2932  			case Message::CharLeft:
2933  			case Message::CharLeftExtend:
2934  				if (spCaret.VirtualSpace()) {
2935  					spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
2936  				} else if (!FlagSet(virtualSpaceOptions, VirtualSpace::NoWrapLineStart) || pdoc->GetColumn(spCaret.Position()) > 0) {
2937  					spCaret = SelectionPosition(spCaret.Position() - 1);
2938  				}
2939  				break;
2940  			case Message::CharRight:
2941  			case Message::CharRightExtend:
2942  				if (FlagSet(virtualSpaceOptions, VirtualSpace::UserAccessible) && pdoc->IsLineEndPosition(spCaret.Position())) {
2943  					spCaret.SetVirtualSpace(spCaret.VirtualSpace() + 1);
2944  				} else {
2945  					spCaret = SelectionPosition(spCaret.Position() + 1);
2946  				}
2947  				break;
2948  			case Message::WordLeft:
2949  			case Message::WordLeftExtend:
2950  				spCaret = SelectionPosition(pdoc->NextWordStart(spCaret.Position(), -1));
2951  				break;
2952  			case Message::WordRight:
2953  			case Message::WordRightExtend:
2954  				spCaret = SelectionPosition(pdoc->NextWordStart(spCaret.Position(), 1));
2955  				break;
2956  			case Message::WordLeftEnd:
2957  			case Message::WordLeftEndExtend:
2958  				spCaret = SelectionPosition(pdoc->NextWordEnd(spCaret.Position(), -1));
2959  				break;
2960  			case Message::WordRightEnd:
2961  			case Message::WordRightEndExtend:
2962  				spCaret = SelectionPosition(pdoc->NextWordEnd(spCaret.Position(), 1));
2963  				break;
2964  			case Message::WordPartLeft:
2965  			case Message::WordPartLeftExtend:
2966  				spCaret = SelectionPosition(pdoc->WordPartLeft(spCaret.Position()));
2967  				break;
2968  			case Message::WordPartRight:
2969  			case Message::WordPartRightExtend:
2970  				spCaret = SelectionPosition(pdoc->WordPartRight(spCaret.Position()));
2971  				break;
2972  			case Message::Home:
2973  			case Message::HomeExtend:
2974  				spCaret = SelectionPosition(
2975  					pdoc->LineStart(pdoc->LineFromPosition(spCaret.Position())));
2976  				break;
2977  			case Message::HomeDisplay:
2978  			case Message::HomeDisplayExtend:
2979  				spCaret = SelectionPosition(StartEndDisplayLine(spCaret.Position(), true));
2980  				break;
2981  			case Message::HomeWrap:
2982  			case Message::HomeWrapExtend:
2983  				spCaret = MovePositionSoVisible(StartEndDisplayLine(spCaret.Position(), true), -1);
2984  				if (spCaretNow <= spCaret)
2985  					spCaret = SelectionPosition(
2986  						pdoc->LineStart(pdoc->LineFromPosition(spCaret.Position())));
2987  				break;
2988  			case Message::VCHome:
2989  			case Message::VCHomeExtend:
2990  				spCaret = SelectionPosition(pdoc->VCHomePosition(spCaret.Position()));
2991  				break;
2992  			case Message::VCHomeDisplay:
2993  			case Message::VCHomeDisplayExtend:
2994  				spCaret = SelectionPosition(VCHomeDisplayPosition(spCaret.Position()));
2995  				break;
2996  			case Message::VCHomeWrap:
2997  			case Message::VCHomeWrapExtend:
2998  				spCaret = SelectionPosition(VCHomeWrapPosition(spCaret.Position()));
2999  				break;
3000  			case Message::LineEnd:
3001  			case Message::LineEndExtend:
3002  				spCaret = SelectionPosition(pdoc->LineEndPosition(spCaret.Position()));
3003  				break;
3004  			case Message::LineEndDisplay:
3005  			case Message::LineEndDisplayExtend:
3006  				spCaret = SelectionPosition(StartEndDisplayLine(spCaret.Position(), false));
3007  				break;
3008  			case Message::LineEndWrap:
3009  			case Message::LineEndWrapExtend:
3010  				spCaret = SelectionPosition(LineEndWrapPosition(spCaret.Position()));
3011  				break;
3012  			default:
3013  				PLATFORM_ASSERT(false);
3014  			}
3015  			const int directionMove = (spCaret < spCaretNow) ? -1 : 1;
3016  			spCaret = MovePositionSoVisible(spCaret, directionMove);
3017  			switch (iMessage) {
3018  			case Message::CharLeft:
3019  			case Message::CharRight:
3020  				if (sel.Range(r).Empty()) {
3021  					sel.Range(r) = SelectionRange(spCaret);
3022  				} else {
3023  					sel.Range(r) = SelectionRange(
3024  						(iMessage == Message::CharLeft) ? sel.Range(r).Start() : sel.Range(r).End());
3025  				}
3026  				break;
3027  			case Message::WordLeft:
3028  			case Message::WordRight:
3029  			case Message::WordLeftEnd:
3030  			case Message::WordRightEnd:
3031  			case Message::WordPartLeft:
3032  			case Message::WordPartRight:
3033  			case Message::Home:
3034  			case Message::HomeDisplay:
3035  			case Message::HomeWrap:
3036  			case Message::VCHome:
3037  			case Message::VCHomeDisplay:
3038  			case Message::VCHomeWrap:
3039  			case Message::LineEnd:
3040  			case Message::LineEndDisplay:
3041  			case Message::LineEndWrap:
3042  				sel.Range(r) = SelectionRange(spCaret);
3043  				break;
3044  			case Message::CharLeftExtend:
3045  			case Message::CharRightExtend:
3046  			case Message::WordLeftExtend:
3047  			case Message::WordRightExtend:
3048  			case Message::WordLeftEndExtend:
3049  			case Message::WordRightEndExtend:
3050  			case Message::WordPartLeftExtend:
3051  			case Message::WordPartRightExtend:
3052  			case Message::HomeExtend:
3053  			case Message::HomeDisplayExtend:
3054  			case Message::HomeWrapExtend:
3055  			case Message::VCHomeExtend:
3056  			case Message::VCHomeDisplayExtend:
3057  			case Message::VCHomeWrapExtend:
3058  			case Message::LineEndExtend:
3059  			case Message::LineEndDisplayExtend:
3060  			case Message::LineEndWrapExtend: {
3061  				SelectionRange rangeNew = SelectionRange(spCaret, sel.Range(r).anchor);
3062  				sel.TrimOtherSelections(r, SelectionRange(rangeNew));
3063  				sel.Range(r) = rangeNew;
3064  				}
3065  				break;
3066  			default:
3067  				PLATFORM_ASSERT(false);
3068  			}
3069  		}
3070  	}
3071  	sel.RemoveDuplicates();
3072  	MovedCaret(sel.RangeMain().caret, SelectionPosition(Sci::invalidPosition), true, caretPolicies);
3073  	InvalidateWholeSelection();
3074  	SetLastXChosen();
3075  	return 0;
3076  }
3077  int Editor::DelWordOrLine(Message iMessage) {
3078  	const bool leftwards = (iMessage == Message::DelWordLeft) || (iMessage == Message::DelLineLeft);
3079  	if (!additionalSelectionTyping) {
3080  		InvalidateWholeSelection();
3081  		sel.DropAdditionalRanges();
3082  	}
3083  	UndoGroup ug0(pdoc, (sel.Count() > 1) || !leftwards);
3084  	for (size_t r = 0; r < sel.Count(); r++) {
3085  		if (leftwards) {
3086  			sel.Range(r).ClearVirtualSpace();
3087  		} else {
3088  			sel.Range(r) = SelectionRange(
3089  				RealizeVirtualSpace(sel.Range(r).caret));
3090  		}
3091  		Range rangeDelete;
3092  		switch (iMessage) {
3093  		case Message::DelWordLeft:
3094  			rangeDelete = Range(
3095  				pdoc->NextWordStart(sel.Range(r).caret.Position(), -1),
3096  				sel.Range(r).caret.Position());
3097  			break;
3098  		case Message::DelWordRight:
3099  			rangeDelete = Range(
3100  				sel.Range(r).caret.Position(),
3101  				pdoc->NextWordStart(sel.Range(r).caret.Position(), 1));
3102  			break;
3103  		case Message::DelWordRightEnd:
3104  			rangeDelete = Range(
3105  				sel.Range(r).caret.Position(),
3106  				pdoc->NextWordEnd(sel.Range(r).caret.Position(), 1));
3107  			break;
3108  		case Message::DelLineLeft:
3109  			rangeDelete = Range(
3110  				pdoc->LineStart(pdoc->LineFromPosition(sel.Range(r).caret.Position())),
3111  				sel.Range(r).caret.Position());
3112  			break;
3113  		case Message::DelLineRight:
3114  			rangeDelete = Range(
3115  				sel.Range(r).caret.Position(),
3116  				pdoc->LineEnd(pdoc->LineFromPosition(sel.Range(r).caret.Position())));
3117  			break;
3118  		default:
3119  			break;
3120  		}
3121  		if (!RangeContainsProtected(rangeDelete.start, rangeDelete.end)) {
3122  			pdoc->DeleteChars(rangeDelete.start, rangeDelete.end - rangeDelete.start);
3123  		}
3124  	}
3125  	sel.RemoveDuplicates();
3126  	MovedCaret(sel.RangeMain().caret, SelectionPosition(Sci::invalidPosition), true, caretPolicies);
3127  	InvalidateWholeSelection();
3128  	SetLastXChosen();
3129  	return 0;
3130  }
3131  int Editor::KeyCommand(Message iMessage) {
3132  	switch (iMessage) {
3133  	case Message::LineDown:
3134  		CursorUpOrDown(1, Selection::SelTypes::none);
3135  		break;
3136  	case Message::LineDownExtend:
3137  		CursorUpOrDown(1, Selection::SelTypes::stream);
3138  		break;
3139  	case Message::LineDownRectExtend:
3140  		CursorUpOrDown(1, Selection::SelTypes::rectangle);
3141  		break;
3142  	case Message::ParaDown:
3143  		ParaUpOrDown(1, Selection::SelTypes::none);
3144  		break;
3145  	case Message::ParaDownExtend:
3146  		ParaUpOrDown(1, Selection::SelTypes::stream);
3147  		break;
3148  	case Message::LineScrollDown:
3149  		ScrollTo(topLine + 1);
3150  		MoveCaretInsideView(false);
3151  		break;
3152  	case Message::LineUp:
3153  		CursorUpOrDown(-1, Selection::SelTypes::none);
3154  		break;
3155  	case Message::LineUpExtend:
3156  		CursorUpOrDown(-1, Selection::SelTypes::stream);
3157  		break;
3158  	case Message::LineUpRectExtend:
3159  		CursorUpOrDown(-1, Selection::SelTypes::rectangle);
3160  		break;
3161  	case Message::ParaUp:
3162  		ParaUpOrDown(-1, Selection::SelTypes::none);
3163  		break;
3164  	case Message::ParaUpExtend:
3165  		ParaUpOrDown(-1, Selection::SelTypes::stream);
3166  		break;
3167  	case Message::LineScrollUp:
3168  		ScrollTo(topLine - 1);
3169  		MoveCaretInsideView(false);
3170  		break;
3171  	case Message::CharLeft:
3172  	case Message::CharLeftExtend:
3173  	case Message::CharLeftRectExtend:
3174  	case Message::CharRight:
3175  	case Message::CharRightExtend:
3176  	case Message::CharRightRectExtend:
3177  	case Message::WordLeft:
3178  	case Message::WordLeftExtend:
3179  	case Message::WordRight:
3180  	case Message::WordRightExtend:
3181  	case Message::WordLeftEnd:
3182  	case Message::WordLeftEndExtend:
3183  	case Message::WordRightEnd:
3184  	case Message::WordRightEndExtend:
3185  	case Message::WordPartLeft:
3186  	case Message::WordPartLeftExtend:
3187  	case Message::WordPartRight:
3188  	case Message::WordPartRightExtend:
3189  	case Message::Home:
3190  	case Message::HomeExtend:
3191  	case Message::HomeRectExtend:
3192  	case Message::HomeDisplay:
3193  	case Message::HomeDisplayExtend:
3194  	case Message::HomeWrap:
3195  	case Message::HomeWrapExtend:
3196  	case Message::VCHome:
3197  	case Message::VCHomeExtend:
3198  	case Message::VCHomeRectExtend:
3199  	case Message::VCHomeDisplay:
3200  	case Message::VCHomeDisplayExtend:
3201  	case Message::VCHomeWrap:
3202  	case Message::VCHomeWrapExtend:
3203  	case Message::LineEnd:
3204  	case Message::LineEndExtend:
3205  	case Message::LineEndRectExtend:
3206  	case Message::LineEndDisplay:
3207  	case Message::LineEndDisplayExtend:
3208  	case Message::LineEndWrap:
3209  	case Message::LineEndWrapExtend:
3210  		return HorizontalMove(iMessage);
3211  	case Message::DocumentStart:
3212  		MovePositionTo(0);
3213  		SetLastXChosen();
3214  		break;
3215  	case Message::DocumentStartExtend:
3216  		MovePositionTo(0, Selection::SelTypes::stream);
3217  		SetLastXChosen();
3218  		break;
3219  	case Message::DocumentEnd:
3220  		MovePositionTo(pdoc->Length());
3221  		SetLastXChosen();
3222  		break;
3223  	case Message::DocumentEndExtend:
3224  		MovePositionTo(pdoc->Length(), Selection::SelTypes::stream);
3225  		SetLastXChosen();
3226  		break;
3227  	case Message::StutteredPageUp:
3228  		PageMove(-1, Selection::SelTypes::none, true);
3229  		break;
3230  	case Message::StutteredPageUpExtend:
3231  		PageMove(-1, Selection::SelTypes::stream, true);
3232  		break;
3233  	case Message::StutteredPageDown:
3234  		PageMove(1, Selection::SelTypes::none, true);
3235  		break;
3236  	case Message::StutteredPageDownExtend:
3237  		PageMove(1, Selection::SelTypes::stream, true);
3238  		break;
3239  	case Message::PageUp:
3240  		PageMove(-1);
3241  		break;
3242  	case Message::PageUpExtend:
3243  		PageMove(-1, Selection::SelTypes::stream);
3244  		break;
3245  	case Message::PageUpRectExtend:
3246  		PageMove(-1, Selection::SelTypes::rectangle);
3247  		break;
3248  	case Message::PageDown:
3249  		PageMove(1);
3250  		break;
3251  	case Message::PageDownExtend:
3252  		PageMove(1, Selection::SelTypes::stream);
3253  		break;
3254  	case Message::PageDownRectExtend:
3255  		PageMove(1, Selection::SelTypes::rectangle);
3256  		break;
3257  	case Message::EditToggleOvertype:
3258  		inOverstrike = !inOverstrike;
3259  		ContainerNeedsUpdate(Update::Selection);
3260  		ShowCaretAtCurrentPosition();
3261  		SetIdle(true);
3262  		break;
3263  	case Message::Cancel:            	
3264  		CancelModes();
3265  		if ((sel.Count() > 1) && !sel.IsRectangular()) {
3266  			InvalidateWholeSelection();
3267  			sel.DropAdditionalRanges();
3268  		}
3269  		break;
3270  	case Message::DeleteBack:
3271  		DelCharBack(true);
3272  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3273  			SetLastXChosen();
3274  		}
3275  		EnsureCaretVisible();
3276  		break;
3277  	case Message::DeleteBackNotLine:
3278  		DelCharBack(false);
3279  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3280  			SetLastXChosen();
3281  		}
3282  		EnsureCaretVisible();
3283  		break;
3284  	case Message::Tab:
3285  		Indent(true);
3286  		if (caretSticky == CaretSticky::Off) {
3287  			SetLastXChosen();
3288  		}
3289  		EnsureCaretVisible();
3290  		ShowCaretAtCurrentPosition();		
3291  		break;
3292  	case Message::BackTab:
3293  		Indent(false);
3294  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3295  			SetLastXChosen();
3296  		}
3297  		EnsureCaretVisible();
3298  		ShowCaretAtCurrentPosition();		
3299  		break;
3300  	case Message::NewLine:
3301  		NewLine();
3302  		break;
3303  	case Message::FormFeed:
3304  		AddChar('\f');
3305  		break;
3306  	case Message::ZoomIn:
3307  		if (vs.zoomLevel < 20) {
3308  			vs.zoomLevel++;
3309  			InvalidateStyleRedraw();
3310  			NotifyZoom();
3311  		}
3312  		break;
3313  	case Message::ZoomOut:
3314  		if (vs.zoomLevel > -10) {
3315  			vs.zoomLevel--;
3316  			InvalidateStyleRedraw();
3317  			NotifyZoom();
3318  		}
3319  		break;
3320  	case Message::DelWordLeft:
3321  	case Message::DelWordRight:
3322  	case Message::DelWordRightEnd:
3323  	case Message::DelLineLeft:
3324  	case Message::DelLineRight:
3325  		return DelWordOrLine(iMessage);
3326  	case Message::LineCopy: {
3327  			const Sci::Line lineStart = pdoc->SciLineFromPosition(SelectionStart().Position());
3328  			const Sci::Line lineEnd = pdoc->SciLineFromPosition(SelectionEnd().Position());
3329  			CopyRangeToClipboard(pdoc->LineStart(lineStart),
3330  				pdoc->LineStart(lineEnd + 1));
3331  		}
3332  		break;
3333  	case Message::LineCut: {
3334  			const Sci::Line lineStart = pdoc->SciLineFromPosition(SelectionStart().Position());
3335  			const Sci::Line lineEnd = pdoc->SciLineFromPosition(SelectionEnd().Position());
3336  			const Sci::Position start = pdoc->LineStart(lineStart);
3337  			const Sci::Position end = pdoc->LineStart(lineEnd + 1);
3338  			SetSelection(start, end);
3339  			Cut();
3340  			SetLastXChosen();
3341  		}
3342  		break;
3343  	case Message::LineDelete: {
3344  			const Sci::Line line = pdoc->SciLineFromPosition(sel.MainCaret());
3345  			const Sci::Position start = pdoc->LineStart(line);
3346  			const Sci::Position end = pdoc->LineStart(line + 1);
3347  			pdoc->DeleteChars(start, end - start);
3348  		}
3349  		break;
3350  	case Message::LineTranspose:
3351  		LineTranspose();
3352  		break;
3353  	case Message::LineReverse:
3354  		LineReverse();
3355  		break;
3356  	case Message::LineDuplicate:
3357  		Duplicate(true);
3358  		break;
3359  	case Message::SelectionDuplicate:
3360  		Duplicate(false);
3361  		break;
3362  	case Message::LowerCase:
3363  		ChangeCaseOfSelection(CaseMapping::lower);
3364  		break;
3365  	case Message::UpperCase:
3366  		ChangeCaseOfSelection(CaseMapping::upper);
3367  		break;
3368  	case Message::ScrollToStart:
3369  		ScrollTo(0);
3370  		break;
3371  	case Message::ScrollToEnd:
3372  		ScrollTo(MaxScrollPos());
3373  		break;
3374  	default:
3375  		break;
3376  	}
3377  	return 0;
3378  }
3379  int Editor::KeyDefault(Keys, KeyMod) {
3380  	return 0;
3381  }
3382  int Editor::KeyDownWithModifiers(Keys key, KeyMod modifiers, bool *consumed) {
3383  	DwellEnd(false);
3384  	const Message msg = kmap.Find(key, modifiers);
3385  	if (msg != static_cast<Message>(0)) {
3386  		if (consumed)
3387  			*consumed = true;
3388  		return static_cast<int>(WndProc(msg, 0, 0));
3389  	} else {
3390  		if (consumed)
3391  			*consumed = false;
3392  		return KeyDefault(key, modifiers);
3393  	}
3394  }
3395  void Editor::Indent(bool forwards) {
3396  	UndoGroup ug(pdoc);
3397  	for (size_t r=0; r<sel.Count(); r++) {
3398  		const Sci::Line lineOfAnchor =
3399  			pdoc->SciLineFromPosition(sel.Range(r).anchor.Position());
3400  		Sci::Position caretPosition = sel.Range(r).caret.Position();
3401  		const Sci::Line lineCurrentPos = pdoc->SciLineFromPosition(caretPosition);
3402  		if (lineOfAnchor == lineCurrentPos) {
3403  			if (forwards) {
3404  				pdoc->DeleteChars(sel.Range(r).Start().Position(), sel.Range(r).Length());
3405  				caretPosition = sel.Range(r).caret.Position();
3406  				if (pdoc->GetColumn(caretPosition) <= pdoc->GetColumn(pdoc->GetLineIndentPosition(lineCurrentPos)) &&
3407  						pdoc->tabIndents) {
3408  					const int indentation = pdoc->GetLineIndentation(lineCurrentPos);
3409  					const int indentationStep = pdoc->IndentSize();
3410  					const Sci::Position posSelect = pdoc->SetLineIndentation(
3411  						lineCurrentPos, indentation + indentationStep - indentation % indentationStep);
3412  					sel.Range(r) = SelectionRange(posSelect);
3413  				} else {
3414  					if (pdoc->useTabs) {
3415  						const Sci::Position lengthInserted = pdoc->InsertString(caretPosition, "\t", 1);
3416  						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
3417  					} else {
3418  						int numSpaces = (pdoc->tabInChars) -
3419  								(pdoc->GetColumn(caretPosition) % (pdoc->tabInChars));
3420  						if (numSpaces < 1)
3421  							numSpaces = pdoc->tabInChars;
3422  						const std::string spaceText(numSpaces, ' ');
3423  						const Sci::Position lengthInserted = pdoc->InsertString(caretPosition, spaceText);
3424  						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
3425  					}
3426  				}
3427  			} else {
3428  				if (pdoc->GetColumn(caretPosition) <= pdoc->GetLineIndentation(lineCurrentPos) &&
3429  						pdoc->tabIndents) {
3430  					const int indentation = pdoc->GetLineIndentation(lineCurrentPos);
3431  					const int indentationStep = pdoc->IndentSize();
3432  					const Sci::Position posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationStep);
3433  					sel.Range(r) = SelectionRange(posSelect);
3434  				} else {
3435  					Sci::Position newColumn = ((pdoc->GetColumn(caretPosition) - 1) / pdoc->tabInChars) *
3436  							pdoc->tabInChars;
3437  					if (newColumn < 0)
3438  						newColumn = 0;
3439  					Sci::Position newPos = caretPosition;
3440  					while (pdoc->GetColumn(newPos) > newColumn)
3441  						newPos--;
3442  					sel.Range(r) = SelectionRange(newPos);
3443  				}
3444  			}
3445  		} else {	
3446  			const Sci::Position anchorPosOnLine = sel.Range(r).anchor.Position() -
3447  				pdoc->LineStart(lineOfAnchor);
3448  			const Sci::Position currentPosPosOnLine = caretPosition -
3449  				pdoc->LineStart(lineCurrentPos);
3450  			const Sci::Line lineTopSel = std::min(lineOfAnchor, lineCurrentPos);
3451  			Sci::Line lineBottomSel = std::max(lineOfAnchor, lineCurrentPos);
3452  			if (pdoc->LineStart(lineBottomSel) == sel.Range(r).anchor.Position() || pdoc->LineStart(lineBottomSel) == caretPosition)
3453  				lineBottomSel--;  	
3454  			pdoc->Indent(forwards, lineBottomSel, lineTopSel);
3455  			if (lineOfAnchor < lineCurrentPos) {
3456  				if (currentPosPosOnLine == 0)
3457  					sel.Range(r) = SelectionRange(pdoc->LineStart(lineCurrentPos),
3458  						pdoc->LineStart(lineOfAnchor));
3459  				else
3460  					sel.Range(r) = SelectionRange(pdoc->LineStart(lineCurrentPos + 1),
3461  						pdoc->LineStart(lineOfAnchor));
3462  			} else {
3463  				if (anchorPosOnLine == 0)
3464  					sel.Range(r) = SelectionRange(pdoc->LineStart(lineCurrentPos),
3465  						pdoc->LineStart(lineOfAnchor));
3466  				else
3467  					sel.Range(r) = SelectionRange(pdoc->LineStart(lineCurrentPos),
3468  						pdoc->LineStart(lineOfAnchor + 1));
3469  			}
3470  		}
3471  	}
3472  	ContainerNeedsUpdate(Update::Selection);
3473  }
3474  std::unique_ptr<CaseFolder> Editor::CaseFolderForEncoding() {
3475  	return std::make_unique<CaseFolderTable>();
3476  }
3477  Sci::Position Editor::FindText(
3478      uptr_t wParam,		
3479      sptr_t lParam) {	
3480  	TextToFind *ft = static_cast<TextToFind *>(PtrFromSPtr(lParam));
3481  	Sci::Position lengthFound = strlen(ft->lpstrText);
3482  	if (!pdoc->HasCaseFolder())
3483  		pdoc->SetCaseFolder(CaseFolderForEncoding());
3484  	try {
3485  		const Sci::Position pos = pdoc->FindText(
3486  			static_cast<Sci::Position>(ft->chrg.cpMin),
3487  			static_cast<Sci::Position>(ft->chrg.cpMax),
3488  			ft->lpstrText,
3489  			static_cast<FindOption>(wParam),
3490  			&lengthFound);
3491  		if (pos != -1) {
3492  			ft->chrgText.cpMin = static_cast<Sci_PositionCR>(pos);
3493  			ft->chrgText.cpMax = static_cast<Sci_PositionCR>(pos + lengthFound);
3494  		}
3495  		return pos;
3496  	} catch (RegexError &) {
3497  		errorStatus = Status::RegEx;
3498  		return -1;
3499  	}
3500  }
3501  Sci::Position Editor::FindTextFull(
3502      uptr_t wParam,		
3503      sptr_t lParam) {	
3504  	TextToFindFull *ft = static_cast<TextToFindFull *>(PtrFromSPtr(lParam));
3505  	Sci::Position lengthFound = strlen(ft->lpstrText);
3506  	if (!pdoc->HasCaseFolder())
3507  		pdoc->SetCaseFolder(CaseFolderForEncoding());
3508  	try {
3509  		const Sci::Position pos = pdoc->FindText(
3510  			ft->chrg.cpMin,
3511  			ft->chrg.cpMax,
3512  			ft->lpstrText,
3513  			static_cast<FindOption>(wParam),
3514  			&lengthFound);
3515  		if (pos != -1) {
3516  			ft->chrgText.cpMin = pos;
3517  			ft->chrgText.cpMax = pos + lengthFound;
3518  		}
3519  		return pos;
3520  	} catch (RegexError &) {
3521  		errorStatus = Status::RegEx;
3522  		return -1;
3523  	}
3524  }
3525  void Editor::SearchAnchor() noexcept {
3526  	searchAnchor = SelectionStart().Position();
3527  }
3528  Sci::Position Editor::SearchText(
3529      Message iMessage,		
3530      uptr_t wParam,				
3531      sptr_t lParam) {			
3532  	const char *txt = ConstCharPtrFromSPtr(lParam);
3533  	Sci::Position pos = Sci::invalidPosition;
3534  	Sci::Position lengthFound = strlen(txt);
3535  	if (!pdoc->HasCaseFolder())
3536  		pdoc->SetCaseFolder(CaseFolderForEncoding());
3537  	try {
3538  		if (iMessage == Message::SearchNext) {
3539  			pos = pdoc->FindText(searchAnchor, pdoc->Length(), txt,
3540  					static_cast<FindOption>(wParam),
3541  					&lengthFound);
3542  		} else {
3543  			pos = pdoc->FindText(searchAnchor, 0, txt,
3544  					static_cast<FindOption>(wParam),
3545  					&lengthFound);
3546  		}
3547  	} catch (RegexError &) {
3548  		errorStatus = Status::RegEx;
3549  		return Sci::invalidPosition;
3550  	}
3551  	if (pos != Sci::invalidPosition) {
3552  		SetSelection(pos, pos + lengthFound);
3553  	}
3554  	return pos;
3555  }
3556  std::string Editor::CaseMapString(const std::string &s, CaseMapping caseMapping) {
3557  	std::string ret(s);
3558  	for (char &ch : ret) {
3559  		switch (caseMapping) {
3560  			case CaseMapping::upper:
3561  				ch = MakeUpperCase(ch);
3562  				break;
3563  			case CaseMapping::lower:
3564  				ch = MakeLowerCase(ch);
3565  				break;
3566  			default:	
3567  				break;
3568  		}
3569  	}
3570  	return ret;
3571  }
3572  Sci::Position Editor::SearchInTarget(const char *text, Sci::Position length) {
3573  	Sci::Position lengthFound = length;
3574  	if (!pdoc->HasCaseFolder())
3575  		pdoc->SetCaseFolder(CaseFolderForEncoding());
3576  	try {
3577  		const Sci::Position pos = pdoc->FindText(targetRange.start.Position(), targetRange.end.Position(), text,
3578  				searchFlags,
3579  				&lengthFound);
3580  		if (pos != -1) {
3581  			targetRange.start.SetPosition(pos);
3582  			targetRange.end.SetPosition(pos + lengthFound);
3583  		}
3584  		return pos;
3585  	} catch (RegexError &) {
3586  		errorStatus = Status::RegEx;
3587  		return -1;
3588  	}
3589  }
3590  void Editor::GoToLine(Sci::Line lineNo) {
3591  	if (lineNo > pdoc->LinesTotal())
3592  		lineNo = pdoc->LinesTotal();
3593  	if (lineNo < 0)
3594  		lineNo = 0;
3595  	SetEmptySelection(pdoc->LineStart(lineNo));
3596  	ShowCaretAtCurrentPosition();
3597  	EnsureCaretVisible();
3598  }
3599  static bool Close(Point pt1, Point pt2, Point threshold) noexcept {
3600  	const Point ptDifference = pt2 - pt1;
3601  	if (std::abs(ptDifference.x) > threshold.x)
3602  		return false;
3603  	if (std::abs(ptDifference.y) > threshold.y)
3604  		return false;
3605  	return true;
3606  }
3607  std::string Editor::RangeText(Sci::Position start, Sci::Position end) const {
3608  	if (start < end) {
3609  		const Sci::Position len = end - start;
3610  		std::string ret(len, '\0');
3611  		pdoc->GetCharRange(ret.data(), start, len);
3612  		return ret;
3613  	}
3614  	return std::string();
3615  }
3616  void Editor::CopySelectionRange(SelectionText *ss, bool allowLineCopy) {
3617  	if (sel.Empty()) {
3618  		if (allowLineCopy) {
3619  			const Sci::Line currentLine = pdoc->SciLineFromPosition(sel.MainCaret());
3620  			const Sci::Position start = pdoc->LineStart(currentLine);
3621  			const Sci::Position end = pdoc->LineEnd(currentLine);
3622  			std::string text = RangeText(start, end);
3623  			if (pdoc->eolMode != EndOfLine::Lf)
3624  				text.push_back('\r');
3625  			if (pdoc->eolMode != EndOfLine::Cr)
3626  				text.push_back('\n');
3627  			ss->Copy(text, pdoc->dbcsCodePage,
3628  				vs.styles[StyleDefault].characterSet, false, true);
3629  		}
3630  	} else {
3631  		std::string text;
3632  		std::vector<SelectionRange> rangesInOrder = sel.RangesCopy();
3633  		if (sel.selType == Selection::SelTypes::rectangle)
3634  			std::sort(rangesInOrder.begin(), rangesInOrder.end());
3635  		for (const SelectionRange &current : rangesInOrder) {
3636  				text.append(RangeText(current.Start().Position(), current.End().Position()));
3637  			if (sel.selType == Selection::SelTypes::rectangle) {
3638  				if (pdoc->eolMode != EndOfLine::Lf)
3639  					text.push_back('\r');
3640  				if (pdoc->eolMode != EndOfLine::Cr)
3641  					text.push_back('\n');
3642  			}
3643  		}
3644  		ss->Copy(text, pdoc->dbcsCodePage,
3645  			vs.styles[StyleDefault].characterSet, sel.IsRectangular(), sel.selType == Selection::SelTypes::lines);
3646  	}
3647  }
3648  void Editor::CopyRangeToClipboard(Sci::Position start, Sci::Position end) {
3649  	start = pdoc->ClampPositionIntoDocument(start);
3650  	end = pdoc->ClampPositionIntoDocument(end);
3651  	SelectionText selectedText;
3652  	std::string text = RangeText(start, end);
3653  	selectedText.Copy(text,
3654  		pdoc->dbcsCodePage, vs.styles[StyleDefault].characterSet, false, false);
3655  	CopyToClipboard(selectedText);
3656  }
3657  void Editor::CopyText(size_t length, const char *text) {
3658  	SelectionText selectedText;
3659  	selectedText.Copy(std::string(text, length),
3660  		pdoc->dbcsCodePage, vs.styles[StyleDefault].characterSet, false, false);
3661  	CopyToClipboard(selectedText);
3662  }
3663  void Editor::SetDragPosition(SelectionPosition newPos) {
3664  	if (newPos.Position() >= 0) {
3665  		newPos = MovePositionOutsideChar(newPos, 1);
3666  		posDrop = newPos;
3667  	}
3668  	if (!(posDrag == newPos)) {
3669  		const CaretPolicies dragCaretPolicies = {
3670  			CaretPolicySlop(CaretPolicy::Slop | CaretPolicy::Strict | CaretPolicy::Even, 50),
3671  			CaretPolicySlop(CaretPolicy::Slop | CaretPolicy::Strict | CaretPolicy::Even, 2)
3672  		};
3673  		MovedCaret(newPos, posDrag, true, dragCaretPolicies);
3674  		caret.on = true;
3675  		FineTickerCancel(TickReason::caret);
3676  		if ((caret.active) && (caret.period > 0) && (newPos.Position() < 0))
3677  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
3678  		InvalidateCaret();
3679  		posDrag = newPos;
3680  		InvalidateCaret();
3681  	}
3682  }
3683  void Editor::DisplayCursor(Window::Cursor c) {
3684  	if (cursorMode == CursorShape::Normal)
3685  		wMain.SetCursor(c);
3686  	else
3687  		wMain.SetCursor(static_cast<Window::Cursor>(cursorMode));
3688  }
3689  bool Editor::DragThreshold(Point ptStart, Point ptNow) {
3690  	const Point ptDiff = ptStart - ptNow;
3691  	const XYPOSITION distanceSquared = ptDiff.x * ptDiff.x + ptDiff.y * ptDiff.y;
3692  	return distanceSquared > 16.0f;
3693  }
3694  void Editor::StartDrag() {
3695  }
3696  void Editor::DropAt(SelectionPosition position, const char *value, size_t lengthValue, bool moving, bool rectangular) {
3697  	if (inDragDrop == DragDrop::dragging)
3698  		dropWentOutside = false;
3699  	const bool positionWasInSelection = PositionInSelection(position.Position());
3700  	const bool positionOnEdgeOfSelection =
3701  	    (position == SelectionStart()) || (position == SelectionEnd());
3702  	if ((inDragDrop != DragDrop::dragging) || !(positionWasInSelection) ||
3703  	        (positionOnEdgeOfSelection && !moving)) {
3704  		const SelectionPosition selStart = SelectionStart();
3705  		const SelectionPosition selEnd = SelectionEnd();
3706  		UndoGroup ug(pdoc);
3707  		SelectionPosition positionAfterDeletion = position;
3708  		if ((inDragDrop == DragDrop::dragging) && moving) {
3709  			if (rectangular || sel.selType == Selection::SelTypes::lines) {
3710  				for (size_t r=0; r<sel.Count(); r++) {
3711  					if (position >= sel.Range(r).Start()) {
3712  						if (position > sel.Range(r).End()) {
3713  							positionAfterDeletion.Add(-sel.Range(r).Length());
3714  						} else {
3715  							positionAfterDeletion.Add(-SelectionRange(position, sel.Range(r).Start()).Length());
3716  						}
3717  					}
3718  				}
3719  			} else {
3720  				if (position > selStart) {
3721  					positionAfterDeletion.Add(-SelectionRange(selEnd, selStart).Length());
3722  				}
3723  			}
3724  			ClearSelection();
3725  		}
3726  		position = positionAfterDeletion;
3727  		std::string convertedText = Document::TransformLineEnds(value, lengthValue, pdoc->eolMode);
3728  		if (rectangular) {
3729  			PasteRectangular(position, convertedText.c_str(), convertedText.length());
3730  			SetEmptySelection(position);
3731  		} else {
3732  			position = MovePositionOutsideChar(position, sel.MainCaret() - position.Position());
3733  			position = RealizeVirtualSpace(position);
3734  			const Sci::Position lengthInserted = pdoc->InsertString(
3735  				position.Position(), convertedText);
3736  			if (lengthInserted > 0) {
3737  				SelectionPosition posAfterInsertion = position;
3738  				posAfterInsertion.Add(lengthInserted);
3739  				SetSelection(posAfterInsertion, position);
3740  			}
3741  		}
3742  	} else if (inDragDrop == DragDrop::dragging) {
3743  		SetEmptySelection(position);
3744  	}
3745  }
3746  void Editor::DropAt(SelectionPosition position, const char *value, bool moving, bool rectangular) {
3747  	DropAt(position, value, strlen(value), moving, rectangular);
3748  }
3749  bool Editor::PositionInSelection(Sci::Position pos) {
3750  	pos = MovePositionOutsideChar(pos, sel.MainCaret() - pos);
3751  	for (size_t r=0; r<sel.Count(); r++) {
3752  		if (sel.Range(r).Contains(pos))
3753  			return true;
3754  	}
3755  	return false;
3756  }
3757  bool Editor::PointInSelection(Point pt) {
3758  	const SelectionPosition pos = SPositionFromLocation(pt, false, true);
3759  	const Point ptPos = LocationFromPosition(pos);
3760  	for (size_t r=0; r<sel.Count(); r++) {
3761  		const SelectionRange &range = sel.Range(r);
3762  		if (range.Contains(pos)) {
3763  			bool hit = true;
3764  			if (pos == range.Start()) {
3765  				if (pt.x < ptPos.x) {
3766  					hit = false;
3767  				}
3768  			}
3769  			if (pos == range.End()) {
3770  				if (pt.x > ptPos.x) {
3771  					hit = false;
3772  				}
3773  			}
3774  			if (hit)
3775  				return true;
3776  		}
3777  	}
3778  	return false;
3779  }
3780  bool Editor::PointInSelMargin(Point pt) const {
3781  	if (vs.fixedColumnWidth > 0) {	
3782  		PRectangle rcSelMargin = GetClientRectangle();
3783  		rcSelMargin.right = static_cast<XYPOSITION>(vs.textStart - vs.leftMarginWidth);
3784  		rcSelMargin.left = static_cast<XYPOSITION>(vs.textStart - vs.fixedColumnWidth);
3785  		const Point ptOrigin = GetVisibleOriginInMain();
3786  		rcSelMargin.Move(0, -ptOrigin.y);
3787  		return rcSelMargin.ContainsWholePixel(pt);
3788  	} else {
3789  		return false;
3790  	}
3791  }
3792  Window::Cursor Editor::GetMarginCursor(Point pt) const noexcept {
3793  	int x = 0;
3794  	for (const MarginStyle &m : vs.ms) {
3795  		if ((pt.x >= x) && (pt.x < x + m.width))
3796  			return static_cast<Window::Cursor>(m.cursor);
3797  		x += m.width;
3798  	}
3799  	return Window::Cursor::reverseArrow;
3800  }
3801  void Editor::TrimAndSetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
3802  	sel.TrimSelection(SelectionRange(currentPos_, anchor_));
3803  	SetSelection(currentPos_, anchor_);
3804  }
3805  void Editor::LineSelection(Sci::Position lineCurrentPos_, Sci::Position lineAnchorPos_, bool wholeLine) {
3806  	Sci::Position selCurrentPos;
3807  	Sci::Position selAnchorPos;
3808  	if (wholeLine) {
3809  		const Sci::Line lineCurrent_ = pdoc->SciLineFromPosition(lineCurrentPos_);
3810  		const Sci::Line lineAnchor_ = pdoc->SciLineFromPosition(lineAnchorPos_);
3811  		if (lineAnchorPos_ < lineCurrentPos_) {
3812  			selCurrentPos = pdoc->LineStart(lineCurrent_ + 1);
3813  			selAnchorPos = pdoc->LineStart(lineAnchor_);
3814  		} else if (lineAnchorPos_ > lineCurrentPos_) {
3815  			selCurrentPos = pdoc->LineStart(lineCurrent_);
3816  			selAnchorPos = pdoc->LineStart(lineAnchor_ + 1);
3817  		} else { 
3818  			selCurrentPos = pdoc->LineStart(lineAnchor_ + 1);
3819  			selAnchorPos = pdoc->LineStart(lineAnchor_);
3820  		}
3821  	} else {
3822  		if (lineAnchorPos_ < lineCurrentPos_) {
3823  			selCurrentPos = StartEndDisplayLine(lineCurrentPos_, false) + 1;
3824  			selCurrentPos = pdoc->MovePositionOutsideChar(selCurrentPos, 1);
3825  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, true);
3826  		} else if (lineAnchorPos_ > lineCurrentPos_) {
3827  			selCurrentPos = StartEndDisplayLine(lineCurrentPos_, true);
3828  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, false) + 1;
3829  			selAnchorPos = pdoc->MovePositionOutsideChar(selAnchorPos, 1);
3830  		} else { 
3831  			selCurrentPos = StartEndDisplayLine(lineAnchorPos_, false) + 1;
3832  			selCurrentPos = pdoc->MovePositionOutsideChar(selCurrentPos, 1);
3833  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, true);
3834  		}
3835  	}
3836  	TrimAndSetSelection(selCurrentPos, selAnchorPos);
3837  }
3838  void Editor::WordSelection(Sci::Position pos) {
3839  	if (pos < wordSelectAnchorStartPos) {
3840  		if (!pdoc->IsLineEndPosition(pos))
3841  			pos = pdoc->ExtendWordSelect(pdoc->MovePositionOutsideChar(pos + 1, 1), -1);
3842  		TrimAndSetSelection(pos, wordSelectAnchorEndPos);
3843  	} else if (pos > wordSelectAnchorEndPos) {
3844  		if (pos > pdoc->LineStart(pdoc->LineFromPosition(pos)))
3845  			pos = pdoc->ExtendWordSelect(pdoc->MovePositionOutsideChar(pos - 1, -1), 1);
3846  		TrimAndSetSelection(pos, wordSelectAnchorStartPos);
3847  	} else {
3848  		if (pos >= originalAnchorPos)
3849  			TrimAndSetSelection(wordSelectAnchorEndPos, wordSelectAnchorStartPos);
3850  		else
3851  			TrimAndSetSelection(wordSelectAnchorStartPos, wordSelectAnchorEndPos);
3852  	}
3853  }
3854  void Editor::DwellEnd(bool mouseMoved) {
3855  	if (mouseMoved)
3856  		ticksToDwell = dwellDelay;
3857  	else
3858  		ticksToDwell = TimeForever;
3859  	if (dwelling && (dwellDelay < TimeForever)) {
3860  		dwelling = false;
3861  		NotifyDwelling(ptMouseLast, dwelling);
3862  	}
3863  	FineTickerCancel(TickReason::dwell);
3864  }
3865  void Editor::MouseLeave() {
3866  	SetHotSpotRange(nullptr);
3867  	SetHoverIndicatorPosition(Sci::invalidPosition);
3868  	if (!HaveMouseCapture()) {
3869  		ptMouseLast = Point(-1, -1);
3870  		DwellEnd(true);
3871  	}
3872  }
3873  static constexpr bool AllowVirtualSpace(VirtualSpace virtualSpaceOptions, bool rectangular) noexcept {
3874  	return (!rectangular && (FlagSet(virtualSpaceOptions, VirtualSpace::UserAccessible)))
3875  		|| (rectangular && (FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection)));
3876  }
3877  void Editor::ButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
3878  	SetHoverIndicatorPoint(pt);
3879  	ptMouseLast = pt;
3880  	const bool ctrl = FlagSet(modifiers, KeyMod::Ctrl);
3881  	const bool shift = FlagSet(modifiers, KeyMod::Shift);
3882  	const bool alt = FlagSet(modifiers, KeyMod::Alt);
3883  	SelectionPosition newPos = SPositionFromLocation(pt, false, false, AllowVirtualSpace(virtualSpaceOptions, alt));
3884  	newPos = MovePositionOutsideChar(newPos, sel.MainCaret() - newPos.Position());
3885  	SelectionPosition newCharPos = SPositionFromLocation(pt, false, true, false);
3886  	newCharPos = MovePositionOutsideChar(newCharPos, -1);
3887  	inDragDrop = DragDrop::none;
3888  	sel.SetMoveExtends(false);
3889  	if (NotifyMarginClick(pt, modifiers))
3890  		return;
3891  	NotifyIndicatorClick(true, newPos.Position(), modifiers);
3892  	const bool inSelMargin = PointInSelMargin(pt);
3893  	if (ctrl && inSelMargin) {
3894  		SelectAll();
3895  		lastClickTime = curTime;
3896  		lastClick = pt;
3897  		return;
3898  	}
3899  	if (shift && !inSelMargin) {
3900  		SetSelection(newPos);
3901  	}
3902  	if ((curTime < (lastClickTime+Platform::DoubleClickTime())) && Close(pt, lastClick, doubleClickCloseThreshold)) {
3903  		SetMouseCapture(true);
3904  		FineTickerStart(TickReason::scroll, 100, 10);
3905  		if (!ctrl || !multipleSelection || (selectionUnit != TextUnit::character && selectionUnit != TextUnit::word))
3906  			SetEmptySelection(newPos.Position());
3907  		bool doubleClick = false;
3908  		if (inSelMargin) {
3909  			if (selectionUnit == TextUnit::subLine) {
3910  				selectionUnit = TextUnit::wholeLine;
3911  			} else if (selectionUnit != TextUnit::subLine && selectionUnit != TextUnit::wholeLine) {
3912  				selectionUnit = (Wrapping() && (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3913  			}
3914  		} else {
3915  			if (selectionUnit == TextUnit::character) {
3916  				selectionUnit = TextUnit::word;
3917  				doubleClick = true;
3918  			} else if (selectionUnit == TextUnit::word) {
3919  				selectionUnit = TextUnit::wholeLine;
3920  			} else {
3921  				selectionUnit = TextUnit::character;
3922  				originalAnchorPos = sel.MainCaret();
3923  			}
3924  		}
3925  		if (selectionUnit == TextUnit::word) {
3926  			Sci::Position charPos = originalAnchorPos;
3927  			if (sel.MainCaret() == originalAnchorPos) {
3928  				charPos = PositionFromLocation(pt, false, true);
3929  				charPos = MovePositionOutsideChar(charPos, -1);
3930  			}
3931  			Sci::Position startWord;
3932  			Sci::Position endWord;
3933  			if ((sel.MainCaret() >= originalAnchorPos) && !pdoc->IsLineEndPosition(charPos)) {
3934  				startWord = pdoc->ExtendWordSelect(pdoc->MovePositionOutsideChar(charPos + 1, 1), -1);
3935  				endWord = pdoc->ExtendWordSelect(charPos, 1);
3936  			} else {
3937  				if (charPos > pdoc->LineStart(pdoc->LineFromPosition(charPos))) {
3938  					startWord = pdoc->ExtendWordSelect(charPos, -1);
3939  					endWord = pdoc->ExtendWordSelect(startWord, 1);
3940  				} else {
3941  					startWord = charPos;
3942  					endWord = charPos;
3943  				}
3944  			}
3945  			wordSelectAnchorStartPos = startWord;
3946  			wordSelectAnchorEndPos = endWord;
3947  			wordSelectInitialCaretPos = sel.MainCaret();
3948  			WordSelection(wordSelectInitialCaretPos);
3949  		} else if (selectionUnit == TextUnit::subLine || selectionUnit == TextUnit::wholeLine) {
3950  			lineAnchorPos = newPos.Position();
3951  			LineSelection(lineAnchorPos, lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3952  		} else {
3953  			SetEmptySelection(sel.MainCaret());
3954  		}
3955  		if (doubleClick) {
3956  			NotifyDoubleClick(pt, modifiers);
3957  			if (PositionIsHotspot(newCharPos.Position()))
3958  				NotifyHotSpotDoubleClicked(newCharPos.Position(), modifiers);
3959  		}
3960  	} else {	
3961  		if (inSelMargin) {
3962  			if (sel.IsRectangular() || (sel.Count() > 1)) {
3963  				InvalidateWholeSelection();
3964  				sel.Clear();
3965  			}
3966  			sel.selType = Selection::SelTypes::stream;
3967  			if (!shift) {
3968  				lineAnchorPos = newPos.Position();
3969  				selectionUnit = (Wrapping() && (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3970  				LineSelection(lineAnchorPos, lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3971  			} else {
3972  				if (sel.MainAnchor() > sel.MainCaret())
3973  					lineAnchorPos = sel.MainAnchor() - 1;
3974  				else
3975  					lineAnchorPos = sel.MainAnchor();
3976  				if (sel.Empty() || (selectionUnit != TextUnit::subLine && selectionUnit != TextUnit::wholeLine))
3977  					selectionUnit = (Wrapping() && (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3978  				LineSelection(newPos.Position(), lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3979  			}
3980  			SetDragPosition(SelectionPosition(Sci::invalidPosition));
3981  			SetMouseCapture(true);
3982  			FineTickerStart(TickReason::scroll, 100, 10);
3983  		} else {
3984  			if (PointIsHotspot(pt)) {
3985  				NotifyHotSpotClicked(newCharPos.Position(), modifiers);
3986  				hotSpotClickPos = newCharPos.Position();
3987  			}
3988  			if (!shift) {
3989  				if (PointInSelection(pt) && !SelectionEmpty())
3990  					inDragDrop = DragDrop::initial;
3991  				else
3992  					inDragDrop = DragDrop::none;
3993  			}
3994  			SetMouseCapture(true);
3995  			FineTickerStart(TickReason::scroll, 100, 10);
3996  			if (inDragDrop != DragDrop::initial) {
3997  				SetDragPosition(SelectionPosition(Sci::invalidPosition));
3998  				if (!shift) {
3999  					if (ctrl && multipleSelection) {
4000  						const SelectionRange range(newPos);
4001  						sel.TentativeSelection(range);
4002  						InvalidateSelection(range, true);
4003  					} else {
4004  						InvalidateSelection(SelectionRange(newPos), true);
4005  						if (sel.Count() > 1)
4006  							Redraw();
4007  						if ((sel.Count() > 1) || (sel.selType != Selection::SelTypes::stream))
4008  							sel.Clear();
4009  						sel.selType = alt ? Selection::SelTypes::rectangle : Selection::SelTypes::stream;
4010  						SetSelection(newPos, newPos);
4011  					}
4012  				}
4013  				SelectionPosition anchorCurrent = newPos;
4014  				if (shift)
4015  					anchorCurrent = sel.IsRectangular() ?
4016  						sel.Rectangular().anchor : sel.RangeMain().anchor;
4017  				sel.selType = alt ? Selection::SelTypes::rectangle : Selection::SelTypes::stream;
4018  				selectionUnit = TextUnit::character;
4019  				originalAnchorPos = sel.MainCaret();
4020  				sel.Rectangular() = SelectionRange(newPos, anchorCurrent);
4021  				SetRectangularRange();
4022  			}
4023  		}
4024  	}
4025  	lastClickTime = curTime;
4026  	lastClick = pt;
4027  	lastXChosen = static_cast<int>(pt.x) + xOffset;
4028  	ShowCaretAtCurrentPosition();
4029  }
4030  void Editor::RightButtonDownWithModifiers(Point pt, unsigned int, KeyMod modifiers) {
4031  	if (NotifyMarginRightClick(pt, modifiers))
4032  		return;
4033  }
4034  bool Editor::PositionIsHotspot(Sci::Position position) const noexcept {
4035  	return vs.styles[pdoc->StyleIndexAt(position)].hotspot;
4036  }
4037  bool Editor::PointIsHotspot(Point pt) {
4038  	const Sci::Position pos = PositionFromLocation(pt, true, true);
4039  	if (pos == Sci::invalidPosition)
4040  		return false;
4041  	return PositionIsHotspot(pos);
4042  }
4043  void Editor::SetHoverIndicatorPosition(Sci::Position position) {
4044  	const Sci::Position hoverIndicatorPosPrev = hoverIndicatorPos;
4045  	hoverIndicatorPos = Sci::invalidPosition;
4046  	if (!vs.indicatorsDynamic)
4047  		return;
4048  	if (position != Sci::invalidPosition) {
4049  		for (const IDecoration *deco : pdoc->decorations->View()) {
4050  			if (vs.indicators[deco->Indicator()].IsDynamic()) {
4051  				if (pdoc->decorations->ValueAt(deco->Indicator(), position)) {
4052  					hoverIndicatorPos = position;
4053  				}
4054  			}
4055  		}
4056  	}
4057  	if (hoverIndicatorPosPrev != hoverIndicatorPos) {
4058  		Redraw();
4059  	}
4060  }
4061  void Editor::SetHoverIndicatorPoint(Point pt) {
4062  	if (!vs.indicatorsDynamic) {
4063  		SetHoverIndicatorPosition(Sci::invalidPosition);
4064  	} else {
4065  		SetHoverIndicatorPosition(PositionFromLocation(pt, true, true));
4066  	}
4067  }
4068  void Editor::SetHotSpotRange(const Point *pt) {
4069  	if (pt) {
4070  		const Sci::Position pos = PositionFromLocation(*pt, false, true);
4071  		Range hsNew;
4072  		hsNew.start = pdoc->ExtendStyleRange(pos, -1, hotspotSingleLine);
4073  		hsNew.end = pdoc->ExtendStyleRange(pos, 1, hotspotSingleLine);
4074  		if (!(hsNew == hotspot)) {
4075  			if (hotspot.Valid()) {
4076  				InvalidateRange(hotspot.start, hotspot.end);
4077  			}
4078  			hotspot = hsNew;
4079  			InvalidateRange(hotspot.start, hotspot.end);
4080  		}
4081  	} else {
4082  		if (hotspot.Valid()) {
4083  			InvalidateRange(hotspot.start, hotspot.end);
4084  		}
4085  		hotspot = Range(Sci::invalidPosition);
4086  	}
4087  }
4088  void Editor::ButtonMoveWithModifiers(Point pt, unsigned int, KeyMod modifiers) {
4089  	if (ptMouseLast != pt) {
4090  		DwellEnd(true);
4091  	}
4092  	SelectionPosition movePos = SPositionFromLocation(pt, false, false,
4093  		AllowVirtualSpace(virtualSpaceOptions, sel.IsRectangular()));
4094  	movePos = MovePositionOutsideChar(movePos, sel.MainCaret() - movePos.Position());
4095  	if (inDragDrop == DragDrop::initial) {
4096  		if (DragThreshold(ptMouseLast, pt)) {
4097  			SetMouseCapture(false);
4098  			FineTickerCancel(TickReason::scroll);
4099  			SetDragPosition(movePos);
4100  			CopySelectionRange(&drag);
4101  			StartDrag();
4102  		}
4103  		return;
4104  	}
4105  	ptMouseLast = pt;
4106  	PRectangle rcClient = GetClientRectangle();
4107  	const Point ptOrigin = GetVisibleOriginInMain();
4108  	rcClient.Move(0, -ptOrigin.y);
4109  	if ((dwellDelay < TimeForever) && rcClient.Contains(pt)) {
4110  		FineTickerStart(TickReason::dwell, dwellDelay, dwellDelay/10);
4111  	}
4112  	if (HaveMouseCapture()) {
4113  		autoScrollTimer.ticksToWait -= timer.tickSize;
4114  		if (autoScrollTimer.ticksToWait > 0)
4115  			return;
4116  		autoScrollTimer.ticksToWait = autoScrollDelay;
4117  		if (posDrag.IsValid()) {
4118  			SetDragPosition(movePos);
4119  		} else {
4120  			if (selectionUnit == TextUnit::character) {
4121  				if (sel.selType == Selection::SelTypes::stream && FlagSet(modifiers, KeyMod::Alt) && mouseSelectionRectangularSwitch) {
4122  					sel.selType = Selection::SelTypes::rectangle;
4123  				}
4124  				if (sel.IsRectangular()) {
4125  					sel.Rectangular() = SelectionRange(movePos, sel.Rectangular().anchor);
4126  					SetSelection(movePos, sel.RangeMain().anchor);
4127  				} else if (sel.Count() > 1) {
4128  					InvalidateSelection(sel.RangeMain(), false);
4129  					const SelectionRange range(movePos, sel.RangeMain().anchor);
4130  					sel.TentativeSelection(range);
4131  					InvalidateSelection(range, true);
4132  				} else {
4133  					SetSelection(movePos, sel.RangeMain().anchor);
4134  				}
4135  			} else if (selectionUnit == TextUnit::word) {
4136  				if (movePos.Position() == wordSelectInitialCaretPos) {  
4137  				} else {
4138  					wordSelectInitialCaretPos = -1;
4139  					WordSelection(movePos.Position());
4140  				}
4141  			} else {
4142  				LineSelection(movePos.Position(), lineAnchorPos, selectionUnit == TextUnit::wholeLine);
4143  			}
4144  		}
4145  		const Sci::Line lineMove = DisplayFromPosition(movePos.Position());
4146  		if (pt.y >= rcClient.bottom) {
4147  			ScrollTo(lineMove - LinesOnScreen() + 1);
4148  			Redraw();
4149  		} else if (pt.y < rcClient.top) {
4150  			ScrollTo(lineMove);
4151  			Redraw();
4152  		}
4153  		EnsureCaretVisible(false, false, true);
4154  		if (hotspot.Valid() && !PointIsHotspot(pt))
4155  			SetHotSpotRange(nullptr);
4156  		if (hotSpotClickPos != Sci::invalidPosition && PositionFromLocation(pt, true, true) != hotSpotClickPos) {
4157  			if (inDragDrop == DragDrop::none) {
4158  				DisplayCursor(Window::Cursor::text);
4159  			}
4160  			hotSpotClickPos = Sci::invalidPosition;
4161  		}
4162  	} else {
4163  		if (vs.fixedColumnWidth > 0) {	
4164  			if (PointInSelMargin(pt)) {
4165  				DisplayCursor(GetMarginCursor(pt));
4166  				SetHotSpotRange(nullptr);
4167  				SetHoverIndicatorPosition(Sci::invalidPosition);
4168  				return; 	
4169  			}
4170  		}
4171  		if (PointInSelection(pt) && !SelectionEmpty()) {
4172  			DisplayCursor(Window::Cursor::arrow);
4173  			SetHoverIndicatorPosition(Sci::invalidPosition);
4174  		} else {
4175  			SetHoverIndicatorPoint(pt);
4176  			if (PointIsHotspot(pt)) {
4177  				DisplayCursor(Window::Cursor::hand);
4178  				SetHotSpotRange(&pt);
4179  			} else {
4180  				if (hoverIndicatorPos != Sci::invalidPosition)
4181  					DisplayCursor(Window::Cursor::hand);
4182  				else
4183  					DisplayCursor(Window::Cursor::text);
4184  				SetHotSpotRange(nullptr);
4185  			}
4186  		}
4187  	}
4188  }
4189  void Editor::ButtonUpWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
4190  	SelectionPosition newPos = SPositionFromLocation(pt, false, false,
4191  		AllowVirtualSpace(virtualSpaceOptions, sel.IsRectangular()));
4192  	if (hoverIndicatorPos != Sci::invalidPosition)
4193  		InvalidateRange(newPos.Position(), newPos.Position() + 1);
4194  	newPos = MovePositionOutsideChar(newPos, sel.MainCaret() - newPos.Position());
4195  	if (inDragDrop == DragDrop::initial) {
4196  		inDragDrop = DragDrop::none;
4197  		SetEmptySelection(newPos);
4198  		selectionUnit = TextUnit::character;
4199  		originalAnchorPos = sel.MainCaret();
4200  	}
4201  	if (hotSpotClickPos != Sci::invalidPosition && PointIsHotspot(pt)) {
4202  		hotSpotClickPos = Sci::invalidPosition;
4203  		SelectionPosition newCharPos = SPositionFromLocation(pt, false, true, false);
4204  		newCharPos = MovePositionOutsideChar(newCharPos, -1);
4205  		NotifyHotSpotReleaseClick(newCharPos.Position(), modifiers & KeyMod::Ctrl);
4206  	}
4207  	if (HaveMouseCapture()) {
4208  		if (PointInSelMargin(pt)) {
4209  			DisplayCursor(GetMarginCursor(pt));
4210  		} else {
4211  			DisplayCursor(Window::Cursor::text);
4212  			SetHotSpotRange(nullptr);
4213  		}
4214  		ptMouseLast = pt;
4215  		SetMouseCapture(false);
4216  		FineTickerCancel(TickReason::scroll);
4217  		NotifyIndicatorClick(false, newPos.Position(), modifiers);
4218  		if (inDragDrop == DragDrop::dragging) {
4219  			const SelectionPosition selStart = SelectionStart();
4220  			const SelectionPosition selEnd = SelectionEnd();
4221  			if (selStart < selEnd) {
4222  				if (drag.Length()) {
4223  					const Sci::Position length = drag.Length();
4224  					if (FlagSet(modifiers, KeyMod::Ctrl)) {
4225  						const Sci::Position lengthInserted = pdoc->InsertString(
4226  							newPos.Position(), drag.Data(), length);
4227  						if (lengthInserted > 0) {
4228  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4229  						}
4230  					} else if (newPos < selStart) {
4231  						pdoc->DeleteChars(selStart.Position(), drag.Length());
4232  						const Sci::Position lengthInserted = pdoc->InsertString(
4233  							newPos.Position(), drag.Data(), length);
4234  						if (lengthInserted > 0) {
4235  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4236  						}
4237  					} else if (newPos > selEnd) {
4238  						pdoc->DeleteChars(selStart.Position(), drag.Length());
4239  						newPos.Add(-static_cast<Sci::Position>(drag.Length()));
4240  						const Sci::Position lengthInserted = pdoc->InsertString(
4241  							newPos.Position(), drag.Data(), length);
4242  						if (lengthInserted > 0) {
4243  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4244  						}
4245  					} else {
4246  						SetEmptySelection(newPos.Position());
4247  					}
4248  					drag.Clear();
4249  				}
4250  				selectionUnit = TextUnit::character;
4251  			}
4252  		} else {
4253  			if (selectionUnit == TextUnit::character) {
4254  				if (sel.Count() > 1) {
4255  					sel.RangeMain() =
4256  						SelectionRange(newPos, sel.Range(sel.Count() - 1).anchor);
4257  					InvalidateWholeSelection();
4258  				} else {
4259  					SetSelection(newPos, sel.RangeMain().anchor);
4260  				}
4261  			}
4262  			sel.CommitTentative();
4263  		}
4264  		SetRectangularRange();
4265  		lastClickTime = curTime;
4266  		lastClick = pt;
4267  		lastXChosen = static_cast<int>(pt.x) + xOffset;
4268  		if (sel.selType == Selection::SelTypes::stream) {
4269  			SetLastXChosen();
4270  		}
4271  		inDragDrop = DragDrop::none;
4272  		EnsureCaretVisible(false);
4273  	}
4274  }
4275  bool Editor::Idle() {
4276  	NotifyUpdateUI();
4277  	bool needWrap = Wrapping() && wrapPending.NeedsWrap();
4278  	if (needWrap) {
4279  		WrapLines(WrapScope::wsIdle);
4280  		needWrap = wrapPending.NeedsWrap();
4281  	} else if (needIdleStyling) {
4282  		IdleStyle();
4283  	}
4284  	const bool idleDone = !needWrap && !needIdleStyling; 
4285  	return !idleDone;
4286  }
4287  void Editor::TickFor(TickReason reason) {
4288  	switch (reason) {
4289  		case TickReason::caret:
4290  			caret.on = !caret.on;
4291  			if (caret.active) {
4292  				InvalidateCaret();
4293  			}
4294  			break;
4295  		case TickReason::scroll:
4296  			ButtonMoveWithModifiers(ptMouseLast, 0, KeyMod::Norm);
4297  			break;
4298  		case TickReason::widen:
4299  			SetScrollBars();
4300  			FineTickerCancel(TickReason::widen);
4301  			break;
4302  		case TickReason::dwell:
4303  			if ((!HaveMouseCapture()) &&
4304  				(ptMouseLast.y >= 0)) {
4305  				dwelling = true;
4306  				NotifyDwelling(ptMouseLast, dwelling);
4307  			}
4308  			FineTickerCancel(TickReason::dwell);
4309  			break;
4310  		default:
4311  			break;
4312  	}
4313  }
4314  bool Editor::FineTickerRunning(TickReason) {
4315  	assert(false);
4316  	return false;
4317  }
4318  void Editor::FineTickerStart(TickReason, int, int) {
4319  	assert(false);
4320  }
4321  void Editor::FineTickerCancel(TickReason) {
4322  	assert(false);
4323  }
4324  void Editor::SetFocusState(bool focusState) {
4325  	const bool changing = hasFocus != focusState;
4326  	hasFocus = focusState;
4327  	if (changing) {
4328  		Redraw();
4329  	}
4330  	NotifyFocus(hasFocus);
4331  	if (!hasFocus) {
4332  		CancelModes();
4333  	}
4334  	ShowCaretAtCurrentPosition();
4335  }
4336  void Editor::UpdateBaseElements() {
4337  }
4338  Sci::Position Editor::PositionAfterArea(PRectangle rcArea) const {
4339  	const Sci::Line lineAfter = TopLineOfMain() + static_cast<Sci::Line>(rcArea.bottom - 1) / vs.lineHeight + 1;
4340  	if (lineAfter < pcs->LinesDisplayed())
4341  		return pdoc->LineStart(pcs->DocFromDisplay(lineAfter) + 1);
4342  	else
4343  		return pdoc->Length();
4344  }
4345  void Editor::StyleToPositionInView(Sci::Position pos) {
4346  	Sci::Position endWindow = PositionAfterArea(GetClientDrawingRectangle());
4347  	if (pos > endWindow)
4348  		pos = endWindow;
4349  	const int styleAtEnd = pdoc->StyleIndexAt(pos-1);
4350  	pdoc->EnsureStyledTo(pos);
4351  	if ((endWindow > pos) && (styleAtEnd != pdoc->StyleIndexAt(pos-1))) {
4352  		DiscardOverdraw();	
4353  		endWindow = PositionAfterArea(GetClientDrawingRectangle());
4354  		pdoc->EnsureStyledTo(endWindow);
4355  	}
4356  }
4357  Sci::Position Editor::PositionAfterMaxStyling(Sci::Position posMax, bool scrolling) const {
4358  	if (SynchronousStylingToVisible()) {
4359  		return posMax;
4360  	}
4361  	const double secondsAllowed = scrolling ? 0.005 : 0.02;
4362  	const size_t actionsInAllowedTime = std::clamp<Sci::Line>(
4363  		pdoc->durationStyleOneByte.ActionsInAllowedTime(secondsAllowed),
4364  		0x200, 0x20000);
4365  	const Sci::Line lineLast = pdoc->LineFromPositionAfter(pdoc->SciLineFromPosition(pdoc->GetEndStyled()), actionsInAllowedTime);
4366  	const Sci::Line stylingMaxLine = std::min(lineLast, pdoc->LinesTotal());
4367  	return std::min(pdoc->LineStart(stylingMaxLine), posMax);
4368  }
4369  void Editor::StartIdleStyling(bool truncatedLastStyling) {
4370  	if ((idleStyling == IdleStyling::All) || (idleStyling == IdleStyling::AfterVisible)) {
4371  		if (pdoc->GetEndStyled() < pdoc->Length()) {
4372  			needIdleStyling = true;
4373  		}
4374  	} else if (truncatedLastStyling) {
4375  		needIdleStyling = true;
4376  	}
4377  	if (needIdleStyling) {
4378  		SetIdle(true);
4379  	}
4380  }
4381  void Editor::StyleAreaBounded(PRectangle rcArea, bool scrolling) {
4382  	const Sci::Position posAfterArea = PositionAfterArea(rcArea);
4383  	const Sci::Position posAfterMax = PositionAfterMaxStyling(posAfterArea, scrolling);
4384  	if (posAfterMax < posAfterArea) {
4385  		pdoc->StyleToAdjustingLineDuration(posAfterMax);
4386  	} else {
4387  		StyleToPositionInView(posAfterArea);
4388  	}
4389  	StartIdleStyling(posAfterMax < posAfterArea);
4390  }
4391  void Editor::IdleStyle() {
4392  	const Sci::Position posAfterArea = PositionAfterArea(GetClientRectangle());
4393  	const Sci::Position endGoal = (idleStyling >= IdleStyling::AfterVisible) ?
4394  		pdoc->Length() : posAfterArea;
4395  	const Sci::Position posAfterMax = PositionAfterMaxStyling(endGoal, false);
4396  	pdoc->StyleToAdjustingLineDuration(posAfterMax);
4397  	if (pdoc->GetEndStyled() >= endGoal) {
4398  		needIdleStyling = false;
4399  	}
4400  }
4401  void Editor::IdleWork() {
4402  	if (FlagSet(workNeeded.items, WorkItems::style)) {
4403  		StyleToPositionInView(pdoc->LineStart(pdoc->LineFromPosition(workNeeded.upTo) + 2));
4404  	}
4405  	NotifyUpdateUI();
4406  	workNeeded.Reset();
4407  }
4408  void Editor::QueueIdleWork(WorkItems items, Sci::Position upTo) {
4409  	workNeeded.Need(items, upTo);
4410  }
4411  int Editor::SupportsFeature(Supports feature) {
4412  	AutoSurface surface(this);
4413  	return surface->SupportsFeature(feature);
4414  }
4415  bool Editor::PaintContains(PRectangle rc) {
4416  	if (rc.Empty()) {
4417  		return true;
4418  	} else {
4419  		return rcPaint.Contains(rc);
4420  	}
4421  }
4422  bool Editor::PaintContainsMargin() {
4423  	if (HasMarginWindow()) {
4424  		return false;
4425  	}
4426  	PRectangle rcSelMargin = GetClientRectangle();
4427  	rcSelMargin.right = static_cast<XYPOSITION>(vs.textStart);
4428  	return PaintContains(rcSelMargin);
4429  }
4430  void Editor::CheckForChangeOutsidePaint(Range r) {
4431  	if (paintState == PaintState::painting && !paintingAllText) {
4432  		if (!r.Valid())
4433  			return;
4434  		PRectangle rcRange = RectangleFromRange(r, 0);
4435  		const PRectangle rcText = GetTextRectangle();
4436  		if (rcRange.top < rcText.top) {
4437  			rcRange.top = rcText.top;
4438  		}
4439  		if (rcRange.bottom > rcText.bottom) {
4440  			rcRange.bottom = rcText.bottom;
4441  		}
4442  		if (!PaintContains(rcRange)) {
4443  			AbandonPaint();
4444  			paintAbandonedByStyling = true;
4445  		}
4446  	}
4447  }
4448  void Editor::SetBraceHighlight(Sci::Position pos0, Sci::Position pos1, int matchStyle) {
4449  	if ((pos0 != braces[0]) || (pos1 != braces[1]) || (matchStyle != bracesMatchStyle)) {
4450  		if ((braces[0] != pos0) || (matchStyle != bracesMatchStyle)) {
4451  			CheckForChangeOutsidePaint(Range(braces[0]));
4452  			CheckForChangeOutsidePaint(Range(pos0));
4453  			braces[0] = pos0;
4454  		}
4455  		if ((braces[1] != pos1) || (matchStyle != bracesMatchStyle)) {
4456  			CheckForChangeOutsidePaint(Range(braces[1]));
4457  			CheckForChangeOutsidePaint(Range(pos1));
4458  			braces[1] = pos1;
4459  		}
4460  		bracesMatchStyle = matchStyle;
4461  		if (paintState == PaintState::notPainting) {
4462  			Redraw();
4463  		}
4464  	}
4465  }
4466  void Editor::SetAnnotationHeights(Sci::Line start, Sci::Line end) {
4467  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
4468  		RefreshStyleData();
4469  		bool changedHeight = false;
4470  		for (Sci::Line line=start; line<end && line<pdoc->LinesTotal(); line++) {
4471  			int linesWrapped = 1;
4472  			if (Wrapping()) {
4473  				AutoSurface surface(this);
4474  				std::shared_ptr<LineLayout> ll = view.RetrieveLineLayout(line, *this);
4475  				if (surface && ll) {
4476  					view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
4477  					linesWrapped = ll->lines;
4478  				}
4479  			}
4480  			if (pcs->SetHeight(line, pdoc->AnnotationLines(line) + linesWrapped))
4481  				changedHeight = true;
4482  		}
4483  		if (changedHeight) {
4484  			SetScrollBars();
4485  			SetVerticalScrollPos();
4486  			Redraw();
4487  		}
4488  	}
4489  }
4490  void Editor::SetDocPointer(Document *document) {
4491  	pdoc->RemoveWatcher(this, nullptr);
4492  	pdoc->Release();
4493  	if (!document) {
4494  		pdoc = new Document(DocumentOption::Default);
4495  	} else {
4496  		pdoc = document;
4497  	}
4498  	pdoc->AddRef();
4499  	pcs = ContractionStateCreate(pdoc->IsLarge());
4500  	sel.Clear();
4501  	targetRange = SelectionSegment();
4502  	braces[0] = Sci::invalidPosition;
4503  	braces[1] = Sci::invalidPosition;
4504  	vs.ReleaseAllExtendedStyles();
4505  	SetRepresentations();
4506  	pcs->Clear();
4507  	pcs->InsertLines(0, pdoc->LinesTotal() - 1);
4508  	SetAnnotationHeights(0, pdoc->LinesTotal());
4509  	view.llc.Deallocate();
4510  	NeedWrapping();
4511  	hotspot = Range(Sci::invalidPosition);
4512  	hoverIndicatorPos = Sci::invalidPosition;
4513  	view.ClearAllTabstops();
4514  	pdoc->AddWatcher(this, nullptr);
4515  	SetScrollBars();
4516  	Redraw();
4517  }
4518  void Editor::SetAnnotationVisible(AnnotationVisible visible) {
4519  	if (vs.annotationVisible != visible) {
4520  		const bool changedFromOrToHidden = ((vs.annotationVisible != AnnotationVisible::Hidden) != (visible != AnnotationVisible::Hidden));
4521  		vs.annotationVisible = visible;
4522  		if (changedFromOrToHidden) {
4523  			const int dir = (vs.annotationVisible!= AnnotationVisible::Hidden) ? 1 : -1;
4524  			for (Sci::Line line=0; line<pdoc->LinesTotal(); line++) {
4525  				const int annotationLines = pdoc->AnnotationLines(line);
4526  				if (annotationLines > 0) {
4527  					pcs->SetHeight(line, pcs->GetHeight(line) + annotationLines * dir);
4528  				}
4529  			}
4530  			SetScrollBars();
4531  		}
4532  		Redraw();
4533  	}
4534  }
4535  void Editor::SetEOLAnnotationVisible(EOLAnnotationVisible visible) {
4536  	if (vs.eolAnnotationVisible != visible) {
4537  		vs.eolAnnotationVisible = visible;
4538  		Redraw();
4539  	}
4540  }
4541  Sci::Line Editor::ExpandLine(Sci::Line line) {
4542  	const Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
4543  	line++;
4544  	Sci::Line lineStart = line;
4545  	while (line <= lineMaxSubord) {
4546  		const FoldLevel level = pdoc->GetFoldLevel(line);
4547  		if (LevelIsHeader(level)) {
4548  			pcs->SetVisible(lineStart, line, true);
4549  			if (pcs->GetExpanded(line)) {
4550  				line = ExpandLine(line);
4551  			} else {
4552  				line = pdoc->GetLastChild(line);
4553  			}
4554  			lineStart = line + 1;
4555  		}
4556  		line++;
4557  	}
4558  	if (lineStart <= lineMaxSubord) {
4559  		pcs->SetVisible(lineStart, lineMaxSubord, true);
4560  	}
4561  	return lineMaxSubord;
4562  }
4563  void Editor::SetFoldExpanded(Sci::Line lineDoc, bool expanded) {
4564  	if (pcs->SetExpanded(lineDoc, expanded)) {
4565  		RedrawSelMargin();
4566  	}
4567  }
4568  void Editor::FoldLine(Sci::Line line, FoldAction action) {
4569  	if (line >= 0) {
4570  		if (action == FoldAction::Toggle) {
4571  			if (!LevelIsHeader(pdoc->GetFoldLevel(line))) {
4572  				line = pdoc->GetFoldParent(line);
4573  				if (line < 0)
4574  					return;
4575  			}
4576  			action = (pcs->GetExpanded(line)) ? FoldAction::Contract : FoldAction::Expand;
4577  		}
4578  		if (action == FoldAction::Contract) {
4579  			const Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
4580  			if (lineMaxSubord > line) {
4581  				pcs->SetExpanded(line, false);
4582  				pcs->SetVisible(line + 1, lineMaxSubord, false);
4583  				const Sci::Line lineCurrent =
4584  					pdoc->SciLineFromPosition(sel.MainCaret());
4585  				if (lineCurrent > line && lineCurrent <= lineMaxSubord) {
4586  					EnsureCaretVisible();
4587  				}
4588  			}
4589  		} else {
4590  			if (!(pcs->GetVisible(line))) {
4591  				EnsureLineVisible(line, false);
4592  				GoToLine(line);
4593  			}
4594  			pcs->SetExpanded(line, true);
4595  			ExpandLine(line);
4596  		}
4597  		SetScrollBars();
4598  		Redraw();
4599  	}
4600  }
4601  void Editor::FoldExpand(Sci::Line line, FoldAction action, FoldLevel level) {
4602  	bool expanding = action == FoldAction::Expand;
4603  	if (action == FoldAction::Toggle) {
4604  		expanding = !pcs->GetExpanded(line);
4605  	}
4606  	pdoc->GetLastChild(line, LevelNumberPart(level));
4607  	SetFoldExpanded(line, expanding);
4608  	if (expanding && (pcs->HiddenLines() == 0))
4609  		return;
4610  	const Sci::Line lineMaxSubord = pdoc->GetLastChild(line, LevelNumberPart(level));
4611  	line++;
4612  	pcs->SetVisible(line, lineMaxSubord, expanding);
4613  	while (line <= lineMaxSubord) {
4614  		const FoldLevel levelLine = pdoc->GetFoldLevel(line);
4615  		if (LevelIsHeader(levelLine)) {
4616  			SetFoldExpanded(line, expanding);
4617  		}
4618  		line++;
4619  	}
4620  	SetScrollBars();
4621  	Redraw();
4622  }
4623  Sci::Line Editor::ContractedFoldNext(Sci::Line lineStart) const {
4624  	for (Sci::Line line = lineStart; line<pdoc->LinesTotal();) {
4625  		if (!pcs->GetExpanded(line) && LevelIsHeader(pdoc->GetFoldLevel(line)))
4626  			return line;
4627  		line = pcs->ContractedNext(line+1);
4628  		if (line < 0)
4629  			return -1;
4630  	}
4631  	return -1;
4632  }
4633  void Editor::EnsureLineVisible(Sci::Line lineDoc, bool enforcePolicy) {
4634  	if (lineDoc >= wrapPending.start) {
4635  		if (WrapLines(WrapScope::wsAll)) {
4636  			Redraw();
4637  		}
4638  	}
4639  	if (!pcs->GetVisible(lineDoc)) {
4640  		Sci::Line lookLine = lineDoc;
4641  		FoldLevel lookLineLevel = pdoc->GetFoldLevel(lookLine);
4642  		while ((lookLine > 0) && LevelIsWhitespace(lookLineLevel)) {
4643  			lookLineLevel = pdoc->GetFoldLevel(--lookLine);
4644  		}
4645  		Sci::Line lineParent = pdoc->GetFoldParent(lookLine);
4646  		if (lineParent < 0) {
4647  			lineParent = pdoc->GetFoldParent(lineDoc);
4648  		}
4649  		if (lineParent >= 0) {
4650  			if (lineDoc != lineParent)
4651  				EnsureLineVisible(lineParent, enforcePolicy);
4652  			if (!pcs->GetExpanded(lineParent)) {
4653  				pcs->SetExpanded(lineParent, true);
4654  				ExpandLine(lineParent);
4655  			}
4656  		}
4657  		SetScrollBars();
4658  		Redraw();
4659  	}
4660  	if (enforcePolicy) {
4661  		const Sci::Line lineDisplay = pcs->DisplayFromDoc(lineDoc);
4662  		if (FlagSet(visiblePolicy.policy, VisiblePolicy::Slop)) {
4663  			if ((topLine > lineDisplay) || ((FlagSet(visiblePolicy.policy, VisiblePolicy::Strict)) && (topLine + visiblePolicy.slop > lineDisplay))) {
4664  				SetTopLine(std::clamp<Sci::Line>(lineDisplay - visiblePolicy.slop, 0, MaxScrollPos()));
4665  				SetVerticalScrollPos();
4666  				Redraw();
4667  			} else if ((lineDisplay > topLine + LinesOnScreen() - 1) ||
4668  			        ((FlagSet(visiblePolicy.policy, VisiblePolicy::Strict)) && (lineDisplay > topLine + LinesOnScreen() - 1 - visiblePolicy.slop))) {
4669  				SetTopLine(std::clamp<Sci::Line>(lineDisplay - LinesOnScreen() + 1 + visiblePolicy.slop, 0, MaxScrollPos()));
4670  				SetVerticalScrollPos();
4671  				Redraw();
4672  			}
4673  		} else {
4674  			if ((topLine > lineDisplay) || (lineDisplay > topLine + LinesOnScreen() - 1) || (FlagSet(visiblePolicy.policy, VisiblePolicy::Strict))) {
4675  				SetTopLine(std::clamp<Sci::Line>(lineDisplay - LinesOnScreen() / 2 + 1, 0, MaxScrollPos()));
4676  				SetVerticalScrollPos();
4677  				Redraw();
4678  			}
4679  		}
4680  	}
4681  }
4682  void Editor::FoldAll(FoldAction action) {
4683  	const Sci::Line maxLine = pdoc->LinesTotal();
4684  	const bool contractAll = FlagSet(action, FoldAction::ContractEveryLevel);
4685  	action = static_cast<FoldAction>(static_cast<int>(action) & ~static_cast<int>(FoldAction::ContractEveryLevel));
4686  	bool expanding = action == FoldAction::Expand;
4687  	if (!expanding) {
4688  		pdoc->EnsureStyledTo(pdoc->Length());
4689  	}
4690  	Sci::Line line = 0;
4691  	if (action == FoldAction::Toggle) {
4692  		for (; line < maxLine; line++) {
4693  			if (LevelIsHeader(pdoc->GetFoldLevel(line))) {
4694  				expanding = !pcs->GetExpanded(line);
4695  				break;
4696  			}
4697  		}
4698  	}
4699  	if (expanding) {
4700  		pcs->SetVisible(0, maxLine-1, true);
4701  		pcs->ExpandAll();
4702  	} else {
4703  		for (; line < maxLine; line++) {
4704  			const FoldLevel level = pdoc->GetFoldLevel(line);
4705  			if (LevelIsHeader(level)) {
4706  				if (FoldLevel::Base == LevelNumberPart(level)) {
4707  					SetFoldExpanded(line, false);
4708  					const Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
4709  					if (lineMaxSubord > line) {
4710  						pcs->SetVisible(line + 1, lineMaxSubord, false);
4711  						if (!contractAll) {
4712  							line = lineMaxSubord;
4713  						}
4714  					}
4715  				} else if (contractAll) {
4716  					SetFoldExpanded(line, false);
4717  				}
4718  			}
4719  		}
4720  	}
4721  	SetScrollBars();
4722  	Redraw();
4723  }
4724  void Editor::FoldChanged(Sci::Line line, FoldLevel levelNow, FoldLevel levelPrev) {
4725  	if (LevelIsHeader(levelNow)) {
4726  		if (!LevelIsHeader(levelPrev)) {
4727  			if (pcs->SetExpanded(line, true)) {
4728  				RedrawSelMargin();
4729  			}
4730  			FoldExpand(line, FoldAction::Expand, levelPrev);
4731  		}
4732  	} else if (LevelIsHeader(levelPrev)) {
4733  		const Sci::Line prevLine = line - 1;
4734  		const FoldLevel prevLineLevel = pdoc->GetFoldLevel(prevLine);
4735  		if ((LevelNumber(prevLineLevel) == LevelNumber(levelNow)) && !pcs->GetVisible(prevLine))
4736  			FoldLine(pdoc->GetFoldParent(prevLine), FoldAction::Expand);
4737  		if (!pcs->GetExpanded(line)) {
4738  			if (pcs->SetExpanded(line, true)) {
4739  				RedrawSelMargin();
4740  			}
4741  			FoldExpand(line, FoldAction::Expand, levelPrev);
4742  		}
4743  	}
4744  	if (!LevelIsWhitespace(levelNow) &&
4745  	        (LevelNumber(levelPrev) > LevelNumber(levelNow))) {
4746  		if (pcs->HiddenLines()) {
4747  			const Sci::Line parentLine = pdoc->GetFoldParent(line);
4748  			if ((parentLine < 0) || (pcs->GetExpanded(parentLine) && pcs->GetVisible(parentLine))) {
4749  				pcs->SetVisible(line, line, true);
4750  				SetScrollBars();
4751  				Redraw();
4752  			}
4753  		}
4754  	}
4755  	if (!LevelIsWhitespace(levelNow) && (LevelNumber(levelPrev) < LevelNumber(levelNow))) {
4756  		if (pcs->HiddenLines()) {
4757  			const Sci::Line parentLine = pdoc->GetFoldParent(line);
4758  			if (!pcs->GetExpanded(parentLine) && pcs->GetVisible(line))
4759  				FoldLine(parentLine, FoldAction::Expand);
4760  		}
4761  	}
4762  }
4763  void Editor::NeedShown(Sci::Position pos, Sci::Position len) {
4764  	if (FlagSet(foldAutomatic, AutomaticFold::Show)) {
4765  		const Sci::Line lineStart = pdoc->SciLineFromPosition(pos);
4766  		const Sci::Line lineEnd = pdoc->SciLineFromPosition(pos+len);
4767  		for (Sci::Line line = lineStart; line <= lineEnd; line++) {
4768  			EnsureLineVisible(line, false);
4769  		}
4770  	} else {
4771  		NotifyNeedShown(pos, len);
4772  	}
4773  }
4774  Sci::Position Editor::GetTag(char *tagValue, int tagNumber) {
4775  	const char *text = nullptr;
4776  	Sci::Position length = 0;
4777  	if ((tagNumber >= 1) && (tagNumber <= 9)) {
4778  		char name[3] = "\\?";
4779  		name[1] = static_cast<char>(tagNumber + '0');
4780  		length = 2;
4781  		text = pdoc->SubstituteByPosition(name, &length);
4782  	}
4783  	if (tagValue) {
4784  		if (text)
4785  			memcpy(tagValue, text, length + 1);
4786  		else
4787  			*tagValue = '\0';
4788  	}
4789  	return length;
4790  }
4791  Sci::Position Editor::ReplaceTarget(ReplaceType replaceType, std::string_view text) {
4792  	UndoGroup ug(pdoc);
4793  	if (replaceType == ReplaceType::patterns) {
4794  		Sci::Position length = text.length();
4795  		const char *p = pdoc->SubstituteByPosition(text.data(), &length);
4796  		if (!p) {
4797  			return 0;
4798  		}
4799  		text = std::string_view(p, length);
4800  	}
4801  	if (replaceType == ReplaceType::minimal) {
4802  		Range range(targetRange.start.Position(), targetRange.end.Position());
4803  		pdoc->TrimReplacement(text, range);
4804  		const SelectionPosition start(range.start == targetRange.start.Position() ?
4805  			targetRange.start : SelectionPosition(range.start));
4806  		targetRange = SelectionSegment(start, SelectionPosition(range.end));
4807  	}
4808  	if (targetRange.Length() > 0)
4809  		pdoc->DeleteChars(targetRange.start.Position(), targetRange.Length());
4810  	targetRange.end = targetRange.start;
4811  	const Sci::Position startAfterSpaceInsertion = RealizeVirtualSpace(targetRange.start.Position(), targetRange.start.VirtualSpace());
4812  	targetRange.start.SetPosition(startAfterSpaceInsertion);
4813  	targetRange.end = targetRange.start;
4814  	const Sci::Position lengthInserted = pdoc->InsertString(targetRange.start.Position(), text);
4815  	targetRange.end.SetPosition(targetRange.start.Position() + lengthInserted);
4816  	return text.length();
4817  }
4818  bool Editor::IsUnicodeMode() const noexcept {
4819  	return pdoc && (CpUtf8 == pdoc->dbcsCodePage);
4820  }
4821  int Editor::CodePage() const noexcept {
4822  	if (pdoc)
4823  		return pdoc->dbcsCodePage;
4824  	else
4825  		return 0;
4826  }
4827  std::unique_ptr<Surface> Editor::CreateMeasurementSurface() const {
4828  	if (!wMain.GetID()) {
4829  		return {};
4830  	}
4831  	std::unique_ptr<Surface> surf = Surface::Allocate(technology);
4832  	surf->Init(wMain.GetID());
4833  	surf->SetMode(CurrentSurfaceMode());
4834  	return surf;
4835  }
4836  std::unique_ptr<Surface> Editor::CreateDrawingSurface(SurfaceID sid, std::optional<Scintilla::Technology> technologyOpt) const {
4837  	if (!wMain.GetID()) {
4838  		return {};
4839  	}
4840  	std::unique_ptr<Surface> surf = Surface::Allocate(technologyOpt ? *technologyOpt : technology);
4841  	surf->Init(sid, wMain.GetID());
4842  	surf->SetMode(CurrentSurfaceMode());
4843  	return surf;
4844  }
4845  Sci::Line Editor::WrapCount(Sci::Line line) {
4846  	AutoSurface surface(this);
4847  	std::shared_ptr<LineLayout> ll = view.RetrieveLineLayout(line, *this);
4848  	if (surface && ll) {
4849  		view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
4850  		return ll->lines;
4851  	} else {
4852  		return 1;
4853  	}
4854  }
4855  void Editor::AddStyledText(const char *buffer, Sci::Position appendLength) {
4856  	const Sci::Position textLength = appendLength / 2;
4857  	std::string text(textLength, '\0');
4858  	for (Sci::Position i = 0; i < textLength; i++) {
4859  		text[i] = buffer[i*2];
4860  	}
4861  	const Sci::Position lengthInserted = pdoc->InsertString(CurrentPosition(), text);
4862  	for (Sci::Position i = 0; i < textLength; i++) {
4863  		text[i] = buffer[i*2+1];
4864  	}
4865  	pdoc->StartStyling(CurrentPosition());
4866  	pdoc->SetStyles(textLength, text.c_str());
4867  	SetEmptySelection(sel.MainCaret() + lengthInserted);
4868  }
4869  Sci::Position Editor::GetStyledText(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const noexcept {
4870  	Sci::Position iPlace = 0;
4871  	for (Sci::Position iChar = cpMin; iChar < cpMax; iChar++) {
4872  		buffer[iPlace++] = pdoc->CharAt(iChar);
4873  		buffer[iPlace++] = pdoc->StyleAtNoExcept(iChar);
4874  	}
4875  	buffer[iPlace] = '\0';
4876  	buffer[iPlace + 1] = '\0';
4877  	return iPlace;
4878  }
4879  Sci::Position Editor::GetTextRange(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const {
4880  	const Sci::Position cpEnd = (cpMax == -1) ? pdoc->Length() : cpMax;
4881  	PLATFORM_ASSERT(cpEnd <= pdoc->Length());
4882  	const Sci::Position len = cpEnd - cpMin; 	
4883  	pdoc->GetCharRange(buffer, cpMin, len);
4884  	buffer[len] = '\0';
4885  	return len; 	
4886  }
4887  bool Editor::ValidMargin(uptr_t wParam) const noexcept {
4888  	return wParam < vs.ms.size();
4889  }
4890  void Editor::StyleSetMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
4891  	vs.EnsureStyle(wParam);
4892  	switch (iMessage) {
4893  	case Message::StyleSetFore:
4894  		vs.styles[wParam].fore = ColourRGBA::FromIpRGB(lParam);
4895  		break;
4896  	case Message::StyleSetBack:
4897  		vs.styles[wParam].back = ColourRGBA::FromIpRGB(lParam);
4898  		break;
4899  	case Message::StyleSetBold:
4900  		vs.styles[wParam].weight = lParam != 0 ? FontWeight::Bold : FontWeight::Normal;
4901  		break;
4902  	case Message::StyleSetWeight:
4903  		vs.styles[wParam].weight = static_cast<FontWeight>(lParam);
4904  		break;
4905  	case Message::StyleSetItalic:
4906  		vs.styles[wParam].italic = lParam != 0;
4907  		break;
4908  	case Message::StyleSetEOLFilled:
4909  		vs.styles[wParam].eolFilled = lParam != 0;
4910  		break;
4911  	case Message::StyleSetSize:
4912  		vs.styles[wParam].size = static_cast<int>(lParam * FontSizeMultiplier);
4913  		break;
4914  	case Message::StyleSetSizeFractional:
4915  		vs.styles[wParam].size = static_cast<int>(lParam);
4916  		break;
4917  	case Message::StyleSetFont:
4918  		if (lParam != 0) {
4919  			vs.SetStyleFontName(static_cast<int>(wParam), ConstCharPtrFromSPtr(lParam));
4920  		}
4921  		break;
4922  	case Message::StyleSetUnderline:
4923  		vs.styles[wParam].underline = lParam != 0;
4924  		break;
4925  	case Message::StyleSetCase:
4926  		vs.styles[wParam].caseForce = static_cast<Style::CaseForce>(lParam);
4927  		break;
4928  	case Message::StyleSetCharacterSet:
4929  		vs.styles[wParam].characterSet = static_cast<CharacterSet>(lParam);
4930  		pdoc->SetCaseFolder(nullptr);
4931  		break;
4932  	case Message::StyleSetVisible:
4933  		vs.styles[wParam].visible = lParam != 0;
4934  		break;
4935  	case Message::StyleSetInvisibleRepresentation: {
4936  		const char *utf8 = ConstCharPtrFromSPtr(lParam);
4937  		char *rep = vs.styles[wParam].invisibleRepresentation;
4938  		const int classified = UTF8Classify(utf8);
4939  		if (!(classified & UTF8MaskInvalid)) {
4940  			const int len = classified & UTF8MaskWidth;
4941  			for (int i=0; i<len && i<UTF8MaxBytes; i++)
4942  				*rep++ = *utf8++;
4943  		}
4944  		*rep = 0;
4945  		break;
4946  	}
4947  	case Message::StyleSetChangeable:
4948  		vs.styles[wParam].changeable = lParam != 0;
4949  		break;
4950  	case Message::StyleSetHotSpot:
4951  		vs.styles[wParam].hotspot = lParam != 0;
4952  		break;
4953  	case Message::StyleSetCheckMonospaced:
4954  		vs.styles[wParam].checkMonospaced = lParam != 0;
4955  		break;
4956  	default:
4957  		break;
4958  	}
4959  	InvalidateStyleRedraw();
4960  }
4961  sptr_t Editor::StyleGetMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
4962  	vs.EnsureStyle(wParam);
4963  	switch (iMessage) {
4964  	case Message::StyleGetFore:
4965  		return vs.styles[wParam].fore.OpaqueRGB();
4966  	case Message::StyleGetBack:
4967  		return vs.styles[wParam].back.OpaqueRGB();
4968  	case Message::StyleGetBold:
4969  		return vs.styles[wParam].weight > FontWeight::Normal;
4970  	case Message::StyleGetWeight:
4971  		return static_cast<sptr_t>(vs.styles[wParam].weight);
4972  	case Message::StyleGetItalic:
4973  		return vs.styles[wParam].italic ? 1 : 0;
4974  	case Message::StyleGetEOLFilled:
4975  		return vs.styles[wParam].eolFilled ? 1 : 0;
4976  	case Message::StyleGetSize:
4977  		return vs.styles[wParam].size / FontSizeMultiplier;
4978  	case Message::StyleGetSizeFractional:
4979  		return vs.styles[wParam].size;
4980  	case Message::StyleGetFont:
4981  		return StringResult(lParam, vs.styles[wParam].fontName);
4982  	case Message::StyleGetUnderline:
4983  		return vs.styles[wParam].underline ? 1 : 0;
4984  	case Message::StyleGetCase:
4985  		return static_cast<int>(vs.styles[wParam].caseForce);
4986  	case Message::StyleGetCharacterSet:
4987  		return static_cast<sptr_t>(vs.styles[wParam].characterSet);
4988  	case Message::StyleGetVisible:
4989  		return vs.styles[wParam].visible ? 1 : 0;
4990  	case Message::StyleGetChangeable:
4991  		return vs.styles[wParam].changeable ? 1 : 0;
4992  	case Message::StyleGetInvisibleRepresentation:
4993  		return StringResult(lParam, vs.styles[wParam].invisibleRepresentation);
4994  	case Message::StyleGetHotSpot:
4995  		return vs.styles[wParam].hotspot ? 1 : 0;
4996  	case Message::StyleGetCheckMonospaced:
4997  		return vs.styles[wParam].checkMonospaced ? 1 : 0;
4998  	default:
4999  		break;
5000  	}
5001  	return 0;
5002  }
5003  void Editor::SetSelectionNMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
5004  	if (wParam >= sel.Count()) {
5005  		return;
5006  	}
5007  	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
5008  	switch (iMessage) {
5009  	case Message::SetSelectionNCaret:
5010  		sel.Range(wParam).caret.SetPosition(lParam);
5011  		break;
5012  	case Message::SetSelectionNAnchor:
5013  		sel.Range(wParam).anchor.SetPosition(lParam);
5014  		break;
5015  	case Message::SetSelectionNCaretVirtualSpace:
5016  		sel.Range(wParam).caret.SetVirtualSpace(lParam);
5017  		break;
5018  	case Message::SetSelectionNAnchorVirtualSpace:
5019  		sel.Range(wParam).anchor.SetVirtualSpace(lParam);
5020  		break;
5021  	case Message::SetSelectionNStart:
5022  		sel.Range(wParam).anchor.SetPosition(lParam);
5023  		break;
5024  	case Message::SetSelectionNEnd:
5025  		sel.Range(wParam).caret.SetPosition(lParam);
5026  		break;
5027  	default:
5028  		break;
5029  	}
5030  	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
5031  	ContainerNeedsUpdate(Update::Selection);
5032  }
5033  sptr_t Editor::StringResult(sptr_t lParam, const char *val) noexcept {
5034  	const size_t len = val ? strlen(val) : 0;
5035  	if (lParam) {
5036  		char *ptr = CharPtrFromSPtr(lParam);
5037  		if (val)
5038  			memcpy(ptr, val, len+1);
5039  		else
5040  			*ptr = 0;
5041  	}
5042  	return len;	
5043  }
5044  sptr_t Editor::BytesResult(sptr_t lParam, const unsigned char *val, size_t len) noexcept {
5045  	if ((lParam) && (len > 0)) {
5046  		char *ptr = CharPtrFromSPtr(lParam);
5047  		if (val)
5048  			memcpy(ptr, val, len);
5049  		else
5050  			*ptr = 0;
5051  	}
5052  	return val ? len : 0;
5053  }
5054  sptr_t Editor::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
5055  	if (recordingMacro)
5056  		NotifyMacroRecord(iMessage, wParam, lParam);
5057  	switch (iMessage) {
5058  	case Message::GetText: {
5059  			if (lParam == 0)
5060  				return pdoc->Length();
5061  			char *ptr = CharPtrFromSPtr(lParam);
5062  			const Sci_Position len = std::min<Sci_Position>(wParam, pdoc->Length());
5063  			pdoc->GetCharRange(ptr, 0, len);
5064  			ptr[len] = '\0';
5065  			return len;
5066  		}
5067  	case Message::SetText: {
5068  			if (lParam == 0)
5069  				return 0;
5070  			UndoGroup ug(pdoc);
5071  			pdoc->DeleteChars(0, pdoc->Length());
5072  			SetEmptySelection(0);
5073  			const char *text = ConstCharPtrFromSPtr(lParam);
5074  			pdoc->InsertString(0, text, strlen(text));
5075  			return 1;
5076  		}
5077  	case Message::GetTextLength:
5078  		return pdoc->Length();
5079  	case Message::Cut:
5080  		Cut();
5081  		SetLastXChosen();
5082  		break;
5083  	case Message::Copy:
5084  		Copy();
5085  		break;
5086  	case Message::CopyAllowLine:
5087  		CopyAllowLine();
5088  		break;
5089  	case Message::VerticalCentreCaret:
5090  		VerticalCentreCaret();
5091  		break;
5092  	case Message::MoveSelectedLinesUp:
5093  		MoveSelectedLinesUp();
5094  		break;
5095  	case Message::MoveSelectedLinesDown:
5096  		MoveSelectedLinesDown();
5097  		break;
5098  	case Message::CopyRange:
5099  		CopyRangeToClipboard(PositionFromUPtr(wParam), lParam);
5100  		break;
5101  	case Message::CopyText:
5102  		CopyText(wParam, ConstCharPtrFromSPtr(lParam));
5103  		break;
5104  	case Message::Paste:
5105  		Paste();
5106  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
5107  			SetLastXChosen();
5108  		}
5109  		EnsureCaretVisible();
5110  		break;
5111  	case Message::ReplaceRectangular: {
5112  		UndoGroup ug(pdoc);
5113  		if (!sel.Empty()) {
5114  			ClearSelection(); 
5115  		}
5116  		InsertPasteShape(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam), PasteShape::rectangular);
5117  		break;
5118  	}
5119  	case Message::Clear:
5120  		Clear();
5121  		SetLastXChosen();
5122  		EnsureCaretVisible();
5123  		break;
5124  	case Message::Undo:
5125  		Undo();
5126  		SetLastXChosen();
5127  		break;
5128  	case Message::CanUndo:
5129  		return (pdoc->CanUndo() && !pdoc->IsReadOnly()) ? 1 : 0;
5130  	case Message::EmptyUndoBuffer:
5131  		pdoc->DeleteUndoHistory();
5132  		return 0;
5133  	case Message::GetFirstVisibleLine:
5134  		return topLine;
5135  	case Message::SetFirstVisibleLine:
5136  		ScrollTo(LineFromUPtr(wParam));
5137  		break;
5138  	case Message::GetLine: {	
5139  			const Sci::Position lineStart =
5140  				pdoc->LineStart(LineFromUPtr(wParam));
5141  			const Sci::Position lineEnd =
5142  				pdoc->LineStart(LineFromUPtr(wParam + 1));
5143  			const Sci::Position len = lineEnd - lineStart;
5144  			if (lParam == 0) {
5145  				return len;
5146  			}
5147  			char *ptr = CharPtrFromSPtr(lParam);
5148  			pdoc->GetCharRange(ptr, lineStart, len);
5149  			return len;
5150  		}
5151  	case Message::GetLineCount:
5152  		if (pdoc->LinesTotal() == 0)
5153  			return 1;
5154  		else
5155  			return pdoc->LinesTotal();
5156  	case Message::AllocateLines:
5157  		pdoc->AllocateLines(wParam);
5158  		break;
5159  	case Message::GetModify:
5160  		return !pdoc->IsSavePoint();
5161  	case Message::SetSel: {
5162  			Sci::Position nStart = PositionFromUPtr(wParam);
5163  			Sci::Position nEnd = lParam;
5164  			if (nEnd < 0)
5165  				nEnd = pdoc->Length();
5166  			if (nStart < 0)
5167  				nStart = nEnd; 	
5168  			InvalidateSelection(SelectionRange(nStart, nEnd));
5169  			sel.Clear();
5170  			sel.selType = Selection::SelTypes::stream;
5171  			SetSelection(nEnd, nStart);
5172  			EnsureCaretVisible();
5173  		}
5174  		break;
5175  	case Message::GetSelText: {
5176  			SelectionText selectedText;
5177  			CopySelectionRange(&selectedText);
5178  			if (lParam) {
5179  				char *ptr = CharPtrFromSPtr(lParam);
5180  				size_t iChar = selectedText.Length();
5181  				if (iChar) {
5182  					memcpy(ptr, selectedText.Data(), iChar);
5183  				}
5184  				ptr[iChar] = '\0';
5185  			}
5186  			return selectedText.Length();
5187  	}
5188  	case Message::LineFromPosition:
5189  		if (PositionFromUPtr(wParam) < 0)
5190  			return 0;
5191  		return pdoc->LineFromPosition(PositionFromUPtr(wParam));
5192  	case Message::PositionFromLine:
5193  		if (LineFromUPtr(wParam) < 0)
5194  			wParam = pdoc->LineFromPosition(SelectionStart().Position());
5195  		if (wParam == 0)
5196  			return 0; 	
5197  		if (LineFromUPtr(wParam) > pdoc->LinesTotal())
5198  			return -1;
5199  		return pdoc->LineStart(LineFromUPtr(wParam));
5200  	case Message::LineLength:
5201  		if ((LineFromUPtr(wParam) < 0) ||
5202  		        (LineFromUPtr(wParam) > pdoc->LineFromPosition(pdoc->Length())))
5203  			return 0;
5204  		return pdoc->LineStart(LineFromUPtr(wParam) + 1) - pdoc->LineStart(LineFromUPtr(wParam));
5205  	case Message::ReplaceSel: {
5206  			if (lParam == 0)
5207  				return 0;
5208  			UndoGroup ug(pdoc);
5209  			ClearSelection();
5210  			const char *replacement = ConstCharPtrFromSPtr(lParam);
5211  			const Sci::Position lengthInserted = pdoc->InsertString(
5212  				sel.MainCaret(), replacement, strlen(replacement));
5213  			SetEmptySelection(sel.MainCaret() + lengthInserted);
5214  			SetLastXChosen();
5215  			EnsureCaretVisible();
5216  		}
5217  		break;
5218  	case Message::SetTargetStart:
5219  		targetRange.start.SetPosition(PositionFromUPtr(wParam));
5220  		break;
5221  	case Message::GetTargetStart:
5222  		return targetRange.start.Position();
5223  	case Message::SetTargetStartVirtualSpace:
5224  		targetRange.start.SetVirtualSpace(PositionFromUPtr(wParam));
5225  		break;
5226  	case Message::GetTargetStartVirtualSpace:
5227  		return targetRange.start.VirtualSpace();
5228  	case Message::SetTargetEnd:
5229  		targetRange.end.SetPosition(PositionFromUPtr(wParam));
5230  		break;
5231  	case Message::GetTargetEnd:
5232  		return targetRange.end.Position();
5233  	case Message::SetTargetEndVirtualSpace:
5234  		targetRange.end.SetVirtualSpace(PositionFromUPtr(wParam));
5235  		break;
5236  	case Message::GetTargetEndVirtualSpace:
5237  		return targetRange.end.VirtualSpace();
5238  	case Message::SetTargetRange:
5239  		targetRange.start.SetPosition(PositionFromUPtr(wParam));
5240  		targetRange.end.SetPosition(lParam);
5241  		break;
5242  	case Message::TargetWholeDocument:
5243  		targetRange.start.SetPosition(0);
5244  		targetRange.end.SetPosition(pdoc->Length());
5245  		break;
5246  	case Message::TargetFromSelection:
5247  		targetRange.start = sel.RangeMain().Start();
5248  		targetRange.end = sel.RangeMain().End();
5249  		break;
5250  	case Message::GetTargetText: {
5251  			std::string text = RangeText(targetRange.start.Position(), targetRange.end.Position());
5252  			return BytesResult(lParam, reinterpret_cast<const unsigned char *>(text.c_str()), text.length());
5253  		}
5254  	case Message::ReplaceTarget:
5255  		PLATFORM_ASSERT(lParam);
5256  		return ReplaceTarget(ReplaceType::basic, ViewFromParams(lParam, wParam));
5257  	case Message::ReplaceTargetRE:
5258  		PLATFORM_ASSERT(lParam);
5259  		return ReplaceTarget(ReplaceType::patterns, ViewFromParams(lParam, wParam));
5260  	case Message::ReplaceTargetMinimal:
5261  		PLATFORM_ASSERT(lParam);
5262  		return ReplaceTarget(ReplaceType::minimal, ViewFromParams(lParam, wParam));
5263  	case Message::SearchInTarget:
5264  		PLATFORM_ASSERT(lParam);
5265  		return SearchInTarget(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5266  	case Message::SetSearchFlags:
5267  		searchFlags = static_cast<FindOption>(wParam);
5268  		break;
5269  	case Message::GetSearchFlags:
5270  		return static_cast<sptr_t>(searchFlags);
5271  	case Message::GetTag:
5272  		return GetTag(CharPtrFromSPtr(lParam), static_cast<int>(wParam));
5273  	case Message::PositionBefore:
5274  		return pdoc->MovePositionOutsideChar(PositionFromUPtr(wParam) - 1, -1, true);
5275  	case Message::PositionAfter:
5276  		return pdoc->MovePositionOutsideChar(PositionFromUPtr(wParam) + 1, 1, true);
5277  	case Message::PositionRelative:
5278  		return std::clamp<Sci::Position>(pdoc->GetRelativePosition(
5279  			PositionFromUPtr(wParam), lParam),
5280  			0, pdoc->Length());
5281  	case Message::PositionRelativeCodeUnits:
5282  		return std::clamp<Sci::Position>(pdoc->GetRelativePositionUTF16(
5283  			PositionFromUPtr(wParam), lParam),
5284  			0, pdoc->Length());
5285  	case Message::LineScroll:
5286  		ScrollTo(topLine + lParam);
5287  		HorizontalScrollTo(xOffset + static_cast<int>(static_cast<int>(wParam) * vs.spaceWidth));
5288  		return 1;
5289  	case Message::SetXOffset:
5290  		xOffset = static_cast<int>(wParam);
5291  		ContainerNeedsUpdate(Update::HScroll);
5292  		SetHorizontalScrollPos();
5293  		Redraw();
5294  		break;
5295  	case Message::GetXOffset:
5296  		return xOffset;
5297  	case Message::ChooseCaretX:
5298  		SetLastXChosen();
5299  		break;
5300  	case Message::ScrollCaret:
5301  		EnsureCaretVisible();
5302  		break;
5303  	case Message::SetReadOnly:
5304  		pdoc->SetReadOnly(wParam != 0);
5305  		return 1;
5306  	case Message::GetReadOnly:
5307  		return pdoc->IsReadOnly();
5308  	case Message::CanPaste:
5309  		return CanPaste();
5310  	case Message::PointXFromPosition:
5311  		if (lParam < 0) {
5312  			return 0;
5313  		} else {
5314  			const Point pt = LocationFromPosition(lParam);
5315  			return static_cast<int>(pt.x) - vs.textStart + vs.fixedColumnWidth;
5316  		}
5317  	case Message::PointYFromPosition:
5318  		if (lParam < 0) {
5319  			return 0;
5320  		} else {
5321  			const Point pt = LocationFromPosition(lParam);
5322  			return static_cast<int>(pt.y);
5323  		}
5324  	case Message::FindText:
5325  		return FindText(wParam, lParam);
5326  	case Message::FindTextFull:
5327  		return FindTextFull(wParam, lParam);
5328  	case Message::GetTextRange:
5329  		if (TextRange *tr = static_cast<TextRange *>(PtrFromSPtr(lParam))) {
5330  			return GetTextRange(tr->lpstrText, tr->chrg.cpMin, tr->chrg.cpMax);
5331  		}
5332  		return 0;
5333  	case Message::GetTextRangeFull:
5334  		if (TextRangeFull *tr = static_cast<TextRangeFull *>(PtrFromSPtr(lParam))) {
5335  			return GetTextRange(tr->lpstrText, tr->chrg.cpMin, tr->chrg.cpMax);
5336  		}
5337  		return 0;
5338  	case Message::HideSelection:
5339  		vs.selection.visible = wParam == 0;
5340  		Redraw();
5341  		break;
5342  	case Message::GetSelectionHidden:
5343  		return !vs.selection.visible;
5344  		break;
5345  	case Message::FormatRange:
5346  	case Message::FormatRangeFull:
5347  		return FormatRange(iMessage, wParam, lParam);
5348  	case Message::GetMarginLeft:
5349  		return vs.leftMarginWidth;
5350  	case Message::GetMarginRight:
5351  		return vs.rightMarginWidth;
5352  	case Message::SetMarginLeft:
5353  		lastXChosen += static_cast<int>(lParam) - vs.leftMarginWidth;
5354  		vs.leftMarginWidth = static_cast<int>(lParam);
5355  		InvalidateStyleRedraw();
5356  		break;
5357  	case Message::SetMarginRight:
5358  		vs.rightMarginWidth = static_cast<int>(lParam);
5359  		InvalidateStyleRedraw();
5360  		break;
5361  	case Message::AddText: {
5362  			if (lParam == 0)
5363  				return 0;
5364  			const Sci::Position lengthInserted = pdoc->InsertString(
5365  				CurrentPosition(), ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5366  			SetEmptySelection(sel.MainCaret() + lengthInserted);
5367  			return 0;
5368  		}
5369  	case Message::AddStyledText:
5370  		if (lParam)
5371  			AddStyledText(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5372  		return 0;
5373  	case Message::InsertText: {
5374  			if (lParam == 0)
5375  				return 0;
5376  			Sci::Position insertPos = PositionFromUPtr(wParam);
5377  			if (insertPos == -1)
5378  				insertPos = CurrentPosition();
5379  			Sci::Position newCurrent = CurrentPosition();
5380  			const char *sz = ConstCharPtrFromSPtr(lParam);
5381  			const Sci::Position lengthInserted = pdoc->InsertString(insertPos, sz, strlen(sz));
5382  			if (newCurrent > insertPos)
5383  				newCurrent += lengthInserted;
5384  			SetEmptySelection(newCurrent);
5385  			return 0;
5386  		}
5387  	case Message::ChangeInsertion:
5388  		PLATFORM_ASSERT(lParam);
5389  		pdoc->ChangeInsertion(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5390  		return 0;
5391  	case Message::AppendText:
5392  		pdoc->InsertString(pdoc->Length(),
5393  			ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5394  		return 0;
5395  	case Message::ClearAll:
5396  		ClearAll();
5397  		return 0;
5398  	case Message::DeleteRange:
5399  		pdoc->DeleteChars(PositionFromUPtr(wParam), lParam);
5400  		return 0;
5401  	case Message::ClearDocumentStyle:
5402  		ClearDocumentStyle();
5403  		return 0;
5404  	case Message::SetUndoCollection:
5405  		pdoc->SetUndoCollection(wParam != 0);
5406  		return 0;
5407  	case Message::GetUndoCollection:
5408  		return pdoc->IsCollectingUndo();
5409  	case Message::BeginUndoAction:
5410  		pdoc->BeginUndoAction();
5411  		return 0;
5412  	case Message::EndUndoAction:
5413  		pdoc->EndUndoAction();
5414  		return 0;
5415  	case Message::GetCaretPeriod:
5416  		return caret.period;
5417  	case Message::SetCaretPeriod:
5418  		CaretSetPeriod(static_cast<int>(wParam));
5419  		break;
5420  	case Message::GetWordChars:
5421  		return pdoc->GetCharsOfClass(CharacterClass::word, UCharPtrFromSPtr(lParam));
5422  	case Message::SetWordChars: {
5423  			pdoc->SetDefaultCharClasses(false);
5424  			if (lParam == 0)
5425  				return 0;
5426  			pdoc->SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::word);
5427  		}
5428  		break;
5429  	case Message::GetWhitespaceChars:
5430  		return pdoc->GetCharsOfClass(CharacterClass::space, UCharPtrFromSPtr(lParam));
5431  	case Message::SetWhitespaceChars: {
5432  			if (lParam == 0)
5433  				return 0;
5434  			pdoc->SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::space);
5435  		}
5436  		break;
5437  	case Message::GetPunctuationChars:
5438  		return pdoc->GetCharsOfClass(CharacterClass::punctuation, UCharPtrFromSPtr(lParam));
5439  	case Message::SetPunctuationChars: {
5440  			if (lParam == 0)
5441  				return 0;
5442  			pdoc->SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::punctuation);
5443  		}
5444  		break;
5445  	case Message::SetCharsDefault:
5446  		pdoc->SetDefaultCharClasses(true);
5447  		break;
5448  	case Message::SetCharacterCategoryOptimization:
5449  		pdoc->SetCharacterCategoryOptimization(static_cast<int>(wParam));
5450  		break;
5451  	case Message::GetCharacterCategoryOptimization:
5452  		return pdoc->CharacterCategoryOptimization();
5453  	case Message::GetLength:
5454  		return pdoc->Length();
5455  	case Message::Allocate:
5456  		pdoc->Allocate(PositionFromUPtr(wParam));
5457  		break;
5458  	case Message::GetCharAt:
5459  		return pdoc->CharAt(PositionFromUPtr(wParam));
5460  	case Message::SetCurrentPos:
5461  		if (sel.IsRectangular()) {
5462  			sel.Rectangular().caret.SetPosition(PositionFromUPtr(wParam));
5463  			SetRectangularRange();
5464  			Redraw();
5465  		} else {
5466  			SetSelection(PositionFromUPtr(wParam), sel.MainAnchor());
5467  		}
5468  		break;
5469  	case Message::GetCurrentPos:
5470  		return sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret();
5471  	case Message::SetAnchor:
5472  		if (sel.IsRectangular()) {
5473  			sel.Rectangular().anchor.SetPosition(PositionFromUPtr(wParam));
5474  			SetRectangularRange();
5475  			Redraw();
5476  		} else {
5477  			SetSelection(sel.MainCaret(), PositionFromUPtr(wParam));
5478  		}
5479  		break;
5480  	case Message::GetAnchor:
5481  		return sel.IsRectangular() ? sel.Rectangular().anchor.Position() : sel.MainAnchor();
5482  	case Message::SetSelectionStart:
5483  		SetSelection(std::max(sel.MainCaret(), PositionFromUPtr(wParam)), PositionFromUPtr(wParam));
5484  		break;
5485  	case Message::GetSelectionStart:
5486  		return sel.LimitsForRectangularElseMain().start.Position();
5487  	case Message::SetSelectionEnd:
5488  		SetSelection(PositionFromUPtr(wParam), std::min(sel.MainAnchor(), PositionFromUPtr(wParam)));
5489  		break;
5490  	case Message::GetSelectionEnd:
5491  		return sel.LimitsForRectangularElseMain().end.Position();
5492  	case Message::SetEmptySelection:
5493  		SetEmptySelection(PositionFromUPtr(wParam));
5494  		break;
5495  	case Message::SetPrintMagnification:
5496  		view.printParameters.magnification = static_cast<int>(wParam);
5497  		break;
5498  	case Message::GetPrintMagnification:
5499  		return view.printParameters.magnification;
5500  	case Message::SetPrintColourMode:
5501  		view.printParameters.colourMode = static_cast<PrintOption>(wParam);
5502  		break;
5503  	case Message::GetPrintColourMode:
5504  		return static_cast<sptr_t>(view.printParameters.colourMode);
5505  	case Message::SetPrintWrapMode:
5506  		view.printParameters.wrapState = (static_cast<Wrap>(wParam) == Wrap::Word) ? Wrap::Word : Wrap::None;
5507  		break;
5508  	case Message::GetPrintWrapMode:
5509  		return static_cast<sptr_t>(view.printParameters.wrapState);
5510  	case Message::GetStyleAt:
5511  		if (PositionFromUPtr(wParam) >= pdoc->Length())
5512  			return 0;
5513  		else
5514  			return pdoc->StyleAt(PositionFromUPtr(wParam));
5515  	case Message::GetStyleIndexAt:
5516  		if (PositionFromUPtr(wParam) >= pdoc->Length())
5517  			return 0;
5518  		else
5519  			return pdoc->StyleIndexAt(PositionFromUPtr(wParam));
5520  	case Message::Redo:
5521  		Redo();
5522  		break;
5523  	case Message::SelectAll:
5524  		SelectAll();
5525  		break;
5526  	case Message::SetSavePoint:
5527  		pdoc->SetSavePoint();
5528  		break;
5529  	case Message::GetStyledText:
5530  		if (TextRange *tr = static_cast<TextRange *>(PtrFromSPtr(lParam))) {
5531  			return GetStyledText(tr->lpstrText, tr->chrg.cpMin, tr->chrg.cpMax);
5532  		}
5533  		return 0;
5534  	case Message::GetStyledTextFull:
5535  		if (TextRangeFull *tr = static_cast<TextRangeFull *>(PtrFromSPtr(lParam))) {
5536  			return GetStyledText(tr->lpstrText, tr->chrg.cpMin, tr->chrg.cpMax);
5537  		}
5538  		return 0;
5539  	case Message::CanRedo:
5540  		return (pdoc->CanRedo() && !pdoc->IsReadOnly()) ? 1 : 0;
5541  	case Message::MarkerLineFromHandle:
5542  		return pdoc->LineFromHandle(static_cast<int>(wParam));
5543  	case Message::MarkerDeleteHandle:
5544  		pdoc->DeleteMarkFromHandle(static_cast<int>(wParam));
5545  		break;
5546  	case Message::MarkerHandleFromLine:
5547  		return pdoc->MarkerHandleFromLine(LineFromUPtr(wParam), static_cast<int>(lParam));
5548  	case Message::MarkerNumberFromLine:
5549  		return pdoc->MarkerNumberFromLine(LineFromUPtr(wParam), static_cast<int>(lParam));
5550  	case Message::GetViewWS:
5551  		return static_cast<sptr_t>(vs.viewWhitespace);
5552  	case Message::SetViewWS:
5553  		vs.viewWhitespace = static_cast<WhiteSpace>(wParam);
5554  		Redraw();
5555  		break;
5556  	case Message::GetTabDrawMode:
5557  		return static_cast<sptr_t>(vs.tabDrawMode);
5558  	case Message::SetTabDrawMode:
5559  		vs.tabDrawMode = static_cast<TabDrawMode>(wParam);
5560  		Redraw();
5561  		break;
5562  	case Message::GetWhitespaceSize:
5563  		return vs.whitespaceSize;
5564  	case Message::SetWhitespaceSize:
5565  		vs.whitespaceSize = static_cast<int>(wParam);
5566  		Redraw();
5567  		break;
5568  	case Message::PositionFromPoint:
5569  		return PositionFromLocation(PointFromParameters(wParam, lParam), false, false);
5570  	case Message::PositionFromPointClose:
5571  		return PositionFromLocation(PointFromParameters(wParam, lParam), true, false);
5572  	case Message::CharPositionFromPoint:
5573  		return PositionFromLocation(PointFromParameters(wParam, lParam), false, true);
5574  	case Message::CharPositionFromPointClose:
5575  		return PositionFromLocation(PointFromParameters(wParam, lParam), true, true);
5576  	case Message::GotoLine:
5577  		GoToLine(LineFromUPtr(wParam));
5578  		break;
5579  	case Message::GotoPos:
5580  		SetEmptySelection(PositionFromUPtr(wParam));
5581  		EnsureCaretVisible();
5582  		break;
5583  	case Message::GetCurLine: {
5584  			const Sci::Line lineCurrentPos = pdoc->SciLineFromPosition(sel.MainCaret());
5585  			const Sci::Position lineStart = pdoc->LineStart(lineCurrentPos);
5586  			const Sci::Position lineEnd = pdoc->LineStart(lineCurrentPos + 1);
5587  			if (lParam == 0) {
5588  				return lineEnd - lineStart;
5589  			}
5590  			char *ptr = CharPtrFromSPtr(lParam);
5591  			const Sci::Position len = std::min<uptr_t>(lineEnd - lineStart, wParam);
5592  			pdoc->GetCharRange(ptr, lineStart, len);
5593  			ptr[len] = '\0';
5594  			return sel.MainCaret() - lineStart;
5595  		}
5596  	case Message::GetEndStyled:
5597  		return pdoc->GetEndStyled();
5598  	case Message::GetEOLMode:
5599  		return static_cast<sptr_t>(pdoc->eolMode);
5600  	case Message::SetEOLMode:
5601  		pdoc->eolMode = static_cast<EndOfLine>(wParam);
5602  		break;
5603  	case Message::SetLineEndTypesAllowed:
5604  		if (pdoc->SetLineEndTypesAllowed(static_cast<LineEndType>(wParam))) {
5605  			pcs->Clear();
5606  			pcs->InsertLines(0, pdoc->LinesTotal() - 1);
5607  			SetAnnotationHeights(0, pdoc->LinesTotal());
5608  			InvalidateStyleRedraw();
5609  		}
5610  		break;
5611  	case Message::GetLineEndTypesAllowed:
5612  		return static_cast<sptr_t>(pdoc->GetLineEndTypesAllowed());
5613  	case Message::GetLineEndTypesActive:
5614  		return static_cast<sptr_t>(pdoc->GetLineEndTypesActive());
5615  	case Message::StartStyling:
5616  		pdoc->StartStyling(PositionFromUPtr(wParam));
5617  		break;
5618  	case Message::SetStyling:
5619  		if (PositionFromUPtr(wParam) < 0)
5620  			errorStatus = Status::Failure;
5621  		else
5622  			pdoc->SetStyleFor(PositionFromUPtr(wParam), static_cast<char>(lParam));
5623  		break;
5624  	case Message::SetStylingEx:             
5625  		if (lParam == 0)
5626  			return 0;
5627  		pdoc->SetStyles(PositionFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
5628  		break;
5629  	case Message::SetBufferedDraw:
5630  		view.bufferedDraw = wParam != 0;
5631  		break;
5632  	case Message::GetBufferedDraw:
5633  		return view.bufferedDraw;
5634  #ifdef INCLUDE_DEPRECATED_FEATURES
5635  	case SCI_GETTWOPHASEDRAW:
5636  		return view.phasesDraw == EditView::phasesTwo;
5637  	case SCI_SETTWOPHASEDRAW:
5638  		if (view.SetTwoPhaseDraw(wParam != 0))
5639  			InvalidateStyleRedraw();
5640  		break;
5641  #endif
5642  	case Message::GetPhasesDraw:
5643  		return static_cast<sptr_t>(view.phasesDraw);
5644  	case Message::SetPhasesDraw:
5645  		if (view.SetPhasesDraw(static_cast<int>(wParam)))
5646  			InvalidateStyleRedraw();
5647  		break;
5648  	case Message::SetFontQuality:
5649  		vs.extraFontFlag = static_cast<FontQuality>(
5650  			(static_cast<int>(vs.extraFontFlag) & ~static_cast<int>(FontQuality::QualityMask)) |
5651  			(wParam & static_cast<int>(FontQuality::QualityMask)));
5652  		InvalidateStyleRedraw();
5653  		break;
5654  	case Message::GetFontQuality:
5655  		return static_cast<int>(vs.extraFontFlag) & static_cast<int>(FontQuality::QualityMask);
5656  	case Message::SetTabWidth:
5657  		if (wParam > 0) {
5658  			pdoc->tabInChars = static_cast<int>(wParam);
5659  			if (pdoc->indentInChars == 0)
5660  				pdoc->actualIndentInChars = pdoc->tabInChars;
5661  		}
5662  		InvalidateStyleRedraw();
5663  		break;
5664  	case Message::GetTabWidth:
5665  		return pdoc->tabInChars;
5666  	case Message::SetTabMinimumWidth:
5667  		SetAppearance(view.tabWidthMinimumPixels, static_cast<int>(wParam));
5668  		break;
5669  	case Message::GetTabMinimumWidth:
5670  		return view.tabWidthMinimumPixels;
5671  	case Message::ClearTabStops:
5672  		if (view.ClearTabstops(LineFromUPtr(wParam))) {
5673  			const DocModification mh(ModificationFlags::ChangeTabStops, 0, 0, 0, nullptr, LineFromUPtr(wParam));
5674  			NotifyModified(pdoc, mh, nullptr);
5675  		}
5676  		break;
5677  	case Message::AddTabStop:
5678  		if (view.AddTabstop(LineFromUPtr(wParam), static_cast<int>(lParam))) {
5679  			const DocModification mh(ModificationFlags::ChangeTabStops, 0, 0, 0, nullptr, LineFromUPtr(wParam));
5680  			NotifyModified(pdoc, mh, nullptr);
5681  		}
5682  		break;
5683  	case Message::GetNextTabStop:
5684  		return view.GetNextTabstop(LineFromUPtr(wParam), static_cast<int>(lParam));
5685  	case Message::SetIndent:
5686  		pdoc->indentInChars = static_cast<int>(wParam);
5687  		if (pdoc->indentInChars != 0)
5688  			pdoc->actualIndentInChars = pdoc->indentInChars;
5689  		else
5690  			pdoc->actualIndentInChars = pdoc->tabInChars;
5691  		InvalidateStyleRedraw();
5692  		break;
5693  	case Message::GetIndent:
5694  		return pdoc->indentInChars;
5695  	case Message::SetUseTabs:
5696  		pdoc->useTabs = wParam != 0;
5697  		InvalidateStyleRedraw();
5698  		break;
5699  	case Message::GetUseTabs:
5700  		return pdoc->useTabs;
5701  	case Message::SetLineIndentation:
5702  		pdoc->SetLineIndentation(LineFromUPtr(wParam), lParam);
5703  		break;
5704  	case Message::GetLineIndentation:
5705  		return pdoc->GetLineIndentation(LineFromUPtr(wParam));
5706  	case Message::GetLineIndentPosition:
5707  		return pdoc->GetLineIndentPosition(LineFromUPtr(wParam));
5708  	case Message::SetTabIndents:
5709  		pdoc->tabIndents = wParam != 0;
5710  		break;
5711  	case Message::GetTabIndents:
5712  		return pdoc->tabIndents;
5713  	case Message::SetBackSpaceUnIndents:
5714  		pdoc->backspaceUnindents = wParam != 0;
5715  		break;
5716  	case Message::GetBackSpaceUnIndents:
5717  		return pdoc->backspaceUnindents;
5718  	case Message::SetMouseDwellTime:
5719  		dwellDelay = static_cast<int>(wParam);
5720  		ticksToDwell = dwellDelay;
5721  		break;
5722  	case Message::GetMouseDwellTime:
5723  		return dwellDelay;
5724  	case Message::WordStartPosition:
5725  		return pdoc->ExtendWordSelect(PositionFromUPtr(wParam), -1, lParam != 0);
5726  	case Message::WordEndPosition:
5727  		return pdoc->ExtendWordSelect(PositionFromUPtr(wParam), 1, lParam != 0);
5728  	case Message::IsRangeWord:
5729  		return pdoc->IsWordAt(PositionFromUPtr(wParam), lParam);
5730  	case Message::SetIdleStyling:
5731  		idleStyling = static_cast<IdleStyling>(wParam);
5732  		break;
5733  	case Message::GetIdleStyling:
5734  		return static_cast<sptr_t>(idleStyling);
5735  	case Message::SetWrapMode:
5736  		if (vs.SetWrapState(static_cast<Wrap>(wParam))) {
5737  			xOffset = 0;
5738  			ContainerNeedsUpdate(Update::HScroll);
5739  			InvalidateStyleRedraw();
5740  			ReconfigureScrollBars();
5741  		}
5742  		break;
5743  	case Message::GetWrapMode:
5744  		return static_cast<sptr_t>(vs.wrap.state);
5745  	case Message::SetWrapVisualFlags:
5746  		if (vs.SetWrapVisualFlags(static_cast<WrapVisualFlag>(wParam))) {
5747  			InvalidateStyleRedraw();
5748  			ReconfigureScrollBars();
5749  		}
5750  		break;
5751  	case Message::GetWrapVisualFlags:
5752  		return static_cast<sptr_t>(vs.wrap.visualFlags);
5753  	case Message::SetWrapVisualFlagsLocation:
5754  		if (vs.SetWrapVisualFlagsLocation(static_cast<WrapVisualLocation>(wParam))) {
5755  			InvalidateStyleRedraw();
5756  		}
5757  		break;
5758  	case Message::GetWrapVisualFlagsLocation:
5759  		return static_cast<sptr_t>(vs.wrap.visualFlagsLocation);
5760  	case Message::SetWrapStartIndent:
5761  		if (vs.SetWrapVisualStartIndent(static_cast<int>(wParam))) {
5762  			InvalidateStyleRedraw();
5763  			ReconfigureScrollBars();
5764  		}
5765  		break;
5766  	case Message::GetWrapStartIndent:
5767  		return vs.wrap.visualStartIndent;
5768  	case Message::SetWrapIndentMode:
5769  		if (vs.SetWrapIndentMode(static_cast<WrapIndentMode>(wParam))) {
5770  			InvalidateStyleRedraw();
5771  			ReconfigureScrollBars();
5772  		}
5773  		break;
5774  	case Message::GetWrapIndentMode:
5775  		return static_cast<sptr_t>(vs.wrap.indentMode);
5776  	case Message::SetLayoutCache:
5777  		if (static_cast<LineCache>(wParam) <= LineCache::Document) {
5778  			view.llc.SetLevel(static_cast<LineCache>(wParam));
5779  		}
5780  		break;
5781  	case Message::GetLayoutCache:
5782  		return static_cast<sptr_t>(view.llc.GetLevel());
5783  	case Message::SetPositionCache:
5784  		view.posCache->SetSize(wParam);
5785  		break;
5786  	case Message::GetPositionCache:
5787  		return view.posCache->GetSize();
5788  	case Message::SetLayoutThreads:
5789  		view.SetLayoutThreads(static_cast<unsigned int>(wParam));
5790  		break;
5791  	case Message::GetLayoutThreads:
5792  		return view.GetLayoutThreads();
5793  	case Message::SetScrollWidth:
5794  		PLATFORM_ASSERT(wParam > 0);
5795  		if ((wParam > 0) && (wParam != static_cast<unsigned int>(scrollWidth))) {
5796  			view.lineWidthMaxSeen = 0;
5797  			scrollWidth = static_cast<int>(wParam);
5798  			SetScrollBars();
5799  		}
5800  		break;
5801  	case Message::GetScrollWidth:
5802  		return scrollWidth;
5803  	case Message::SetScrollWidthTracking:
5804  		trackLineWidth = wParam != 0;
5805  		break;
5806  	case Message::GetScrollWidthTracking:
5807  		return trackLineWidth;
5808  	case Message::LinesJoin:
5809  		LinesJoin();
5810  		break;
5811  	case Message::LinesSplit:
5812  		LinesSplit(static_cast<int>(wParam));
5813  		break;
5814  	case Message::TextWidth:
5815  		PLATFORM_ASSERT(wParam < vs.styles.size());
5816  		PLATFORM_ASSERT(lParam);
5817  		return TextWidth(wParam, ConstCharPtrFromSPtr(lParam));
5818  	case Message::TextHeight:
5819  		RefreshStyleData();
5820  		return vs.lineHeight;
5821  	case Message::SetEndAtLastLine:
5822  		PLATFORM_ASSERT((wParam == 0) || (wParam == 1));
5823  		if (endAtLastLine != (wParam != 0)) {
5824  			endAtLastLine = wParam != 0;
5825  			SetScrollBars();
5826  		}
5827  		break;
5828  	case Message::GetEndAtLastLine:
5829  		return endAtLastLine;
5830  	case Message::SetCaretSticky:
5831  		PLATFORM_ASSERT(static_cast<CaretSticky>(wParam) <= CaretSticky::WhiteSpace);
5832  		if (static_cast<CaretSticky>(wParam) <= CaretSticky::WhiteSpace) {
5833  			caretSticky = static_cast<CaretSticky>(wParam);
5834  		}
5835  		break;
5836  	case Message::GetCaretSticky:
5837  		return static_cast<sptr_t>(caretSticky);
5838  	case Message::ToggleCaretSticky:
5839  		caretSticky = (caretSticky == CaretSticky::Off) ? CaretSticky::On : CaretSticky::Off;
5840  		break;
5841  	case Message::GetColumn:
5842  		return pdoc->GetColumn(PositionFromUPtr(wParam));
5843  	case Message::FindColumn:
5844  		return pdoc->FindColumn(LineFromUPtr(wParam), lParam);
5845  	case Message::SetHScrollBar :
5846  		if (horizontalScrollBarVisible != (wParam != 0)) {
5847  			horizontalScrollBarVisible = wParam != 0;
5848  			SetScrollBars();
5849  			ReconfigureScrollBars();
5850  		}
5851  		break;
5852  	case Message::GetHScrollBar:
5853  		return horizontalScrollBarVisible;
5854  	case Message::SetVScrollBar:
5855  		if (verticalScrollBarVisible != (wParam != 0)) {
5856  			verticalScrollBarVisible = wParam != 0;
5857  			SetScrollBars();
5858  			ReconfigureScrollBars();
5859  			if (verticalScrollBarVisible)
5860  				SetVerticalScrollPos();
5861  		}
5862  		break;
5863  	case Message::GetVScrollBar:
5864  		return verticalScrollBarVisible;
5865  	case Message::SetIndentationGuides:
5866  		vs.viewIndentationGuides = static_cast<IndentView>(wParam);
5867  		Redraw();
5868  		break;
5869  	case Message::GetIndentationGuides:
5870  		return static_cast<sptr_t>(vs.viewIndentationGuides);
5871  	case Message::SetHighlightGuide:
5872  		if ((highlightGuideColumn != static_cast<int>(wParam)) || (wParam > 0)) {
5873  			highlightGuideColumn = static_cast<int>(wParam);
5874  			Redraw();
5875  		}
5876  		break;
5877  	case Message::GetHighlightGuide:
5878  		return highlightGuideColumn;
5879  	case Message::GetLineEndPosition:
5880  		return pdoc->LineEnd(LineFromUPtr(wParam));
5881  	case Message::SetCodePage:
5882  		if (ValidCodePage(static_cast<int>(wParam))) {
5883  			if (pdoc->SetDBCSCodePage(static_cast<int>(wParam))) {
5884  				pcs->Clear();
5885  				pcs->InsertLines(0, pdoc->LinesTotal() - 1);
5886  				SetAnnotationHeights(0, pdoc->LinesTotal());
5887  				InvalidateStyleRedraw();
5888  				SetRepresentations();
5889  			}
5890  		}
5891  		break;
5892  	case Message::GetCodePage:
5893  		return pdoc->dbcsCodePage;
5894  	case Message::SetIMEInteraction:
5895  		imeInteraction = static_cast<IMEInteraction>(wParam);
5896  		break;
5897  	case Message::GetIMEInteraction:
5898  		return static_cast<sptr_t>(imeInteraction);
5899  	case Message::SetBidirectional:
5900  		break;
5901  	case Message::GetBidirectional:
5902  		return static_cast<sptr_t>(bidirectional);
5903  	case Message::GetLineCharacterIndex:
5904  		return static_cast<sptr_t>(pdoc->LineCharacterIndex());
5905  	case Message::AllocateLineCharacterIndex:
5906  		pdoc->AllocateLineCharacterIndex(static_cast<LineCharacterIndexType>(wParam));
5907  		break;
5908  	case Message::ReleaseLineCharacterIndex:
5909  		pdoc->ReleaseLineCharacterIndex(static_cast<LineCharacterIndexType>(wParam));
5910  		break;
5911  	case Message::LineFromIndexPosition:
5912  		return pdoc->LineFromPositionIndex(PositionFromUPtr(wParam), static_cast<LineCharacterIndexType>(lParam));
5913  	case Message::IndexPositionFromLine:
5914  		return pdoc->IndexLineStart(LineFromUPtr(wParam), static_cast<LineCharacterIndexType>(lParam));
5915  	case Message::MarkerDefine:
5916  		if (wParam <= MarkerMax) {
5917  			vs.markers[wParam].markType = static_cast<MarkerSymbol>(lParam);
5918  			vs.CalcLargestMarkerHeight();
5919  		}
5920  		InvalidateStyleData();
5921  		RedrawSelMargin();
5922  		break;
5923  	case Message::MarkerSymbolDefined:
5924  		if (wParam <= MarkerMax)
5925  			return static_cast<sptr_t>(vs.markers[wParam].markType);
5926  		else
5927  			return 0;
5928  	case Message::MarkerSetFore:
5929  		if (wParam <= MarkerMax)
5930  			vs.markers[wParam].fore = ColourRGBA::FromIpRGB(lParam);
5931  		InvalidateStyleData();
5932  		RedrawSelMargin();
5933  		break;
5934  	case Message::MarkerSetBack:
5935  		if (wParam <= MarkerMax)
5936  			vs.markers[wParam].back = ColourRGBA::FromIpRGB(lParam);
5937  		InvalidateStyleData();
5938  		RedrawSelMargin();
5939  		break;
5940  	case Message::MarkerSetBackSelected:
5941  		if (wParam <= MarkerMax)
5942  			vs.markers[wParam].backSelected = ColourRGBA::FromIpRGB(lParam);
5943  		InvalidateStyleData();
5944  		RedrawSelMargin();
5945  		break;
5946  	case Message::MarkerSetForeTranslucent:
5947  		if (wParam <= MarkerMax)
5948  			vs.markers[wParam].fore = ColourRGBA(static_cast<int>(lParam));
5949  		InvalidateStyleData();
5950  		RedrawSelMargin();
5951  		break;
5952  	case Message::MarkerSetBackTranslucent:
5953  		if (wParam <= MarkerMax)
5954  			vs.markers[wParam].back = ColourRGBA(static_cast<int>(lParam));
5955  		InvalidateStyleData();
5956  		RedrawSelMargin();
5957  		break;
5958  	case Message::MarkerSetBackSelectedTranslucent:
5959  		if (wParam <= MarkerMax)
5960  			vs.markers[wParam].backSelected = ColourRGBA(static_cast<int>(lParam));
5961  		InvalidateStyleData();
5962  		RedrawSelMargin();
5963  		break;
5964  	case Message::MarkerSetStrokeWidth:
5965  		if (wParam <= MarkerMax)
5966  			vs.markers[wParam].strokeWidth = lParam / 100.0f;
5967  		InvalidateStyleData();
5968  		RedrawSelMargin();
5969  		break;
5970  	case Message::MarkerEnableHighlight:
5971  		marginView.highlightDelimiter.isEnabled = wParam == 1;
5972  		RedrawSelMargin();
5973  		break;
5974  	case Message::MarkerSetAlpha:
5975  		if (wParam <= MarkerMax) {
5976  			if (static_cast<Alpha>(lParam) == Alpha::NoAlpha) {
5977  				SetAppearance(vs.markers[wParam].alpha, Alpha::Opaque);
5978  				SetAppearance(vs.markers[wParam].layer, Layer::Base);
5979  			} else {
5980  				SetAppearance(vs.markers[wParam].alpha, static_cast<Alpha>(lParam));
5981  				SetAppearance(vs.markers[wParam].layer, Layer::OverText);
5982  			}
5983  		}
5984  		break;
5985  	case Message::MarkerSetLayer:
5986  		if (wParam <= MarkerMax) {
5987  			SetAppearance(vs.markers[wParam].layer, static_cast<Layer>(lParam));
5988  		}
5989  		break;
5990  	case Message::MarkerGetLayer:
5991  		if (wParam <= MarkerMax) {
5992  			return static_cast<sptr_t>(vs.markers[wParam].layer);
5993  		}
5994  		return 0;
5995  	case Message::MarkerAdd: {
5996  			const int markerID = pdoc->AddMark(LineFromUPtr(wParam), static_cast<int>(lParam));
5997  			return markerID;
5998  		}
5999  	case Message::MarkerAddSet:
6000  		if (lParam != 0)
6001  			pdoc->AddMarkSet(LineFromUPtr(wParam), static_cast<int>(lParam));
6002  		break;
6003  	case Message::MarkerDelete:
6004  		pdoc->DeleteMark(LineFromUPtr(wParam), static_cast<int>(lParam));
6005  		break;
6006  	case Message::MarkerDeleteAll:
6007  		pdoc->DeleteAllMarks(static_cast<int>(wParam));
6008  		break;
6009  	case Message::MarkerGet:
6010  		return GetMark(LineFromUPtr(wParam));
6011  	case Message::MarkerNext:
6012  		return pdoc->MarkerNext(LineFromUPtr(wParam), static_cast<int>(lParam));
6013  	case Message::MarkerPrevious: {
6014  			for (Sci::Line iLine = LineFromUPtr(wParam); iLine >= 0; iLine--) {
6015  				if ((GetMark(iLine) & lParam) != 0)
6016  					return iLine;
6017  			}
6018  		}
6019  		return -1;
6020  	case Message::MarkerDefinePixmap:
6021  		if (wParam <= MarkerMax) {
6022  			vs.markers[wParam].SetXPM(ConstCharPtrFromSPtr(lParam));
6023  			vs.CalcLargestMarkerHeight();
6024  		}
6025  		InvalidateStyleData();
6026  		RedrawSelMargin();
6027  		break;
6028  	case Message::RGBAImageSetWidth:
6029  		sizeRGBAImage.x = static_cast<XYPOSITION>(wParam);
6030  		break;
6031  	case Message::RGBAImageSetHeight:
6032  		sizeRGBAImage.y = static_cast<XYPOSITION>(wParam);
6033  		break;
6034  	case Message::RGBAImageSetScale:
6035  		scaleRGBAImage = static_cast<float>(wParam);
6036  		break;
6037  	case Message::MarkerDefineRGBAImage:
6038  		if (wParam <= MarkerMax) {
6039  			vs.markers[wParam].SetRGBAImage(sizeRGBAImage, scaleRGBAImage / 100.0f, ConstUCharPtrFromSPtr(lParam));
6040  			vs.CalcLargestMarkerHeight();
6041  		}
6042  		InvalidateStyleData();
6043  		RedrawSelMargin();
6044  		break;
6045  	case Message::SetMarginTypeN:
6046  		if (ValidMargin(wParam)) {
6047  			vs.ms[wParam].style = static_cast<MarginType>(lParam);
6048  			InvalidateStyleRedraw();
6049  		}
6050  		break;
6051  	case Message::GetMarginTypeN:
6052  		if (ValidMargin(wParam))
6053  			return static_cast<sptr_t>(vs.ms[wParam].style);
6054  		else
6055  			return 0;
6056  	case Message::SetMarginWidthN:
6057  		if (ValidMargin(wParam)) {
6058  			if (vs.ms[wParam].width != lParam) {
6059  				lastXChosen += static_cast<int>(lParam) - vs.ms[wParam].width;
6060  				vs.ms[wParam].width = static_cast<int>(lParam);
6061  				InvalidateStyleRedraw();
6062  			}
6063  		}
6064  		break;
6065  	case Message::GetMarginWidthN:
6066  		if (ValidMargin(wParam))
6067  			return vs.ms[wParam].width;
6068  		else
6069  			return 0;
6070  	case Message::SetMarginMaskN:
6071  		if (ValidMargin(wParam)) {
6072  			vs.ms[wParam].mask = static_cast<int>(lParam);
6073  			InvalidateStyleRedraw();
6074  		}
6075  		break;
6076  	case Message::GetMarginMaskN:
6077  		if (ValidMargin(wParam))
6078  			return vs.ms[wParam].mask;
6079  		else
6080  			return 0;
6081  	case Message::SetMarginSensitiveN:
6082  		if (ValidMargin(wParam)) {
6083  			vs.ms[wParam].sensitive = lParam != 0;
6084  			InvalidateStyleRedraw();
6085  		}
6086  		break;
6087  	case Message::GetMarginSensitiveN:
6088  		if (ValidMargin(wParam))
6089  			return vs.ms[wParam].sensitive ? 1 : 0;
6090  		else
6091  			return 0;
6092  	case Message::SetMarginCursorN:
6093  		if (ValidMargin(wParam))
6094  			vs.ms[wParam].cursor = static_cast<CursorShape>(lParam);
6095  		break;
6096  	case Message::GetMarginCursorN:
6097  		if (ValidMargin(wParam))
6098  			return static_cast<sptr_t>(vs.ms[wParam].cursor);
6099  		else
6100  			return 0;
6101  	case Message::SetMarginBackN:
6102  		if (ValidMargin(wParam)) {
6103  			vs.ms[wParam].back = ColourRGBA::FromIpRGB(lParam);
6104  			InvalidateStyleRedraw();
6105  		}
6106  		break;
6107  	case Message::GetMarginBackN:
6108  		if (ValidMargin(wParam))
6109  			return vs.ms[wParam].back.OpaqueRGB();
6110  		else
6111  			return 0;
6112  	case Message::SetMargins:
6113  		if (wParam < 1000)
6114  			vs.ms.resize(wParam);
6115  		break;
6116  	case Message::GetMargins:
6117  		return vs.ms.size();
6118  	case Message::StyleClearAll:
6119  		vs.ClearStyles();
6120  		InvalidateStyleRedraw();
6121  		break;
6122  	case Message::StyleSetFore:
6123  	case Message::StyleSetBack:
6124  	case Message::StyleSetBold:
6125  	case Message::StyleSetWeight:
6126  	case Message::StyleSetItalic:
6127  	case Message::StyleSetEOLFilled:
6128  	case Message::StyleSetSize:
6129  	case Message::StyleSetSizeFractional:
6130  	case Message::StyleSetFont:
6131  	case Message::StyleSetUnderline:
6132  	case Message::StyleSetCase:
6133  	case Message::StyleSetCharacterSet:
6134  	case Message::StyleSetVisible:
6135  	case Message::StyleSetChangeable:
6136  	case Message::StyleSetHotSpot:
6137  	case Message::StyleSetCheckMonospaced:
6138  	case Message::StyleSetInvisibleRepresentation:
6139  		StyleSetMessage(iMessage, wParam, lParam);
6140  		break;
6141  	case Message::StyleGetFore:
6142  	case Message::StyleGetBack:
6143  	case Message::StyleGetBold:
6144  	case Message::StyleGetWeight:
6145  	case Message::StyleGetItalic:
6146  	case Message::StyleGetEOLFilled:
6147  	case Message::StyleGetSize:
6148  	case Message::StyleGetSizeFractional:
6149  	case Message::StyleGetFont:
6150  	case Message::StyleGetUnderline:
6151  	case Message::StyleGetCase:
6152  	case Message::StyleGetCharacterSet:
6153  	case Message::StyleGetVisible:
6154  	case Message::StyleGetChangeable:
6155  	case Message::StyleGetHotSpot:
6156  	case Message::StyleGetCheckMonospaced:
6157  	case Message::StyleGetInvisibleRepresentation:
6158  		return StyleGetMessage(iMessage, wParam, lParam);
6159  	case Message::StyleResetDefault:
6160  		vs.ResetDefaultStyle();
6161  		InvalidateStyleRedraw();
6162  		break;
6163  	case Message::SetElementColour:
6164  		if (vs.SetElementColour(static_cast<Element>(wParam), ColourRGBA(static_cast<int>(lParam)))) {
6165  			InvalidateStyleRedraw();
6166  		}
6167  		break;
6168  	case Message::GetElementColour:
6169  		return vs.ElementColour(static_cast<Element>(wParam)).value_or(ColourRGBA()).AsInteger();
6170  	case Message::ResetElementColour:
6171  		if (vs.ResetElement(static_cast<Element>(wParam))) {
6172  			InvalidateStyleRedraw();
6173  		}
6174  		break;
6175  	case Message::GetElementIsSet:
6176  		return vs.ElementColour(static_cast<Element>(wParam)).has_value();
6177  	case Message::GetElementAllowsTranslucent:
6178  		return vs.ElementAllowsTranslucent(static_cast<Element>(wParam));
6179  	case Message::GetElementBaseColour:
6180  		return vs.elementBaseColours[static_cast<Element>(wParam)].value_or(ColourRGBA()).AsInteger();
6181  	case Message::SetFontLocale:
6182  		if (lParam) {
6183  			vs.SetFontLocaleName(ConstCharPtrFromSPtr(lParam));
6184  			InvalidateStyleRedraw();
6185  		}
6186  		break;
6187  	case Message::GetFontLocale:
6188  		return StringResult(lParam, vs.localeName.c_str());
6189  #ifdef INCLUDE_DEPRECATED_FEATURES
6190  	case SCI_SETSTYLEBITS:
6191  		vs.EnsureStyle(0xff);
6192  		break;
6193  	case SCI_GETSTYLEBITS:
6194  		return 8;
6195  #endif
6196  	case Message::SetLineState:
6197  		return pdoc->SetLineState(LineFromUPtr(wParam), static_cast<int>(lParam));
6198  	case Message::GetLineState:
6199  		return pdoc->GetLineState(LineFromUPtr(wParam));
6200  	case Message::GetMaxLineState:
6201  		return pdoc->GetMaxLineState();
6202  	case Message::GetCaretLineVisible:
6203  		return vs.ElementColour(Element::CaretLineBack) ? 1 : 0;
6204  	case Message::SetCaretLineVisible:
6205  		if (wParam) {
6206  			if (!vs.elementColours.count(Element::CaretLineBack)) {
6207  				vs.elementColours[Element::CaretLineBack] = ColourRGBA(0xFF, 0xFF, 0);
6208  				InvalidateStyleRedraw();
6209  			}
6210  		} else {
6211  			if (vs.ResetElement(Element::CaretLineBack)) {
6212  				InvalidateStyleRedraw();
6213  			}
6214  		}
6215  		break;
6216  	case Message::GetCaretLineVisibleAlways:
6217  		return vs.caretLine.alwaysShow;
6218  	case Message::SetCaretLineVisibleAlways:
6219  		vs.caretLine.alwaysShow = wParam != 0;
6220  		InvalidateStyleRedraw();
6221  		break;
6222  	case Message::GetCaretLineHighlightSubLine:
6223  		return vs.caretLine.subLine;
6224  	case Message::SetCaretLineHighlightSubLine:
6225  		vs.caretLine.subLine = wParam != 0;
6226  		InvalidateStyleRedraw();
6227  		break;
6228  	case Message::GetCaretLineFrame:
6229  		return vs.caretLine.frame;
6230  	case Message::SetCaretLineFrame:
6231  		vs.caretLine.frame = static_cast<int>(wParam);
6232  		InvalidateStyleRedraw();
6233  		break;
6234  	case Message::GetCaretLineBack:
6235  		return vs.ElementColourForced(Element::CaretLineBack).OpaqueRGB();
6236  	case Message::SetCaretLineBack:
6237  		vs.SetElementRGB(Element::CaretLineBack, static_cast<int>(wParam));
6238  		InvalidateStyleRedraw();
6239  		break;
6240  	case Message::GetCaretLineLayer:
6241  		return static_cast<sptr_t>(vs.caretLine.layer);
6242  	case Message::SetCaretLineLayer:
6243  		if (vs.caretLine.layer != static_cast<Layer>(wParam)) {
6244  			vs.caretLine.layer = static_cast<Layer>(wParam);
6245  			UpdateBaseElements();
6246  			InvalidateStyleRedraw();
6247  		}
6248  		break;
6249  	case Message::GetCaretLineBackAlpha:
6250  		if (vs.caretLine.layer == Layer::Base)
6251  			return static_cast<sptr_t>(Alpha::NoAlpha);
6252  		return vs.ElementColour(Element::CaretLineBack).value_or(ColourRGBA()).GetAlpha();
6253  	case Message::SetCaretLineBackAlpha: {
6254  			const Layer layerNew = (static_cast<Alpha>(wParam) == Alpha::NoAlpha) ? Layer::Base : Layer::OverText;
6255  			vs.caretLine.layer = layerNew;
6256  			if (vs.ElementColour(Element::CaretLineBack)) {
6257  				vs.SetElementAlpha(Element::CaretLineBack, static_cast<int>(wParam));
6258  			}
6259  			InvalidateStyleRedraw();
6260  		}
6261  		break;
6262  	case Message::VisibleFromDocLine:
6263  		return pcs->DisplayFromDoc(LineFromUPtr(wParam));
6264  	case Message::DocLineFromVisible:
6265  		return pcs->DocFromDisplay(LineFromUPtr(wParam));
6266  	case Message::WrapCount:
6267  		return WrapCount(LineFromUPtr(wParam));
6268  	case Message::SetFoldLevel: {
6269  			const int prev = pdoc->SetLevel(LineFromUPtr(wParam), static_cast<int>(lParam));
6270  			if (prev != static_cast<int>(lParam))
6271  				RedrawSelMargin();
6272  			return prev;
6273  		}
6274  	case Message::GetFoldLevel:
6275  		return pdoc->GetLevel(LineFromUPtr(wParam));
6276  	case Message::GetLastChild:
6277  		return pdoc->GetLastChild(LineFromUPtr(wParam), OptionalFoldLevel(lParam));
6278  	case Message::GetFoldParent:
6279  		return pdoc->GetFoldParent(LineFromUPtr(wParam));
6280  	case Message::ShowLines:
6281  		pcs->SetVisible(LineFromUPtr(wParam), lParam, true);
6282  		SetScrollBars();
6283  		Redraw();
6284  		break;
6285  	case Message::HideLines:
6286  		pcs->SetVisible(LineFromUPtr(wParam), lParam, false);
6287  		SetScrollBars();
6288  		Redraw();
6289  		break;
6290  	case Message::GetLineVisible:
6291  		return pcs->GetVisible(LineFromUPtr(wParam));
6292  	case Message::GetAllLinesVisible:
6293  		return pcs->HiddenLines() ? 0 : 1;
6294  	case Message::SetFoldExpanded:
6295  		SetFoldExpanded(LineFromUPtr(wParam), lParam != 0);
6296  		break;
6297  	case Message::GetFoldExpanded:
6298  		return pcs->GetExpanded(LineFromUPtr(wParam));
6299  	case Message::SetAutomaticFold:
6300  		foldAutomatic = static_cast<AutomaticFold>(wParam);
6301  		break;
6302  	case Message::GetAutomaticFold:
6303  		return static_cast<sptr_t>(foldAutomatic);
6304  	case Message::SetFoldFlags:
6305  		foldFlags = static_cast<FoldFlag>(wParam);
6306  		Redraw();
6307  		break;
6308  	case Message::ToggleFoldShowText:
6309  		pcs->SetFoldDisplayText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
6310  		FoldLine(LineFromUPtr(wParam), FoldAction::Toggle);
6311  		break;
6312  	case Message::FoldDisplayTextSetStyle:
6313  		foldDisplayTextStyle = static_cast<FoldDisplayTextStyle>(wParam);
6314  		Redraw();
6315  		break;
6316  	case Message::FoldDisplayTextGetStyle:
6317  		return static_cast<sptr_t>(foldDisplayTextStyle);
6318  	case Message::SetDefaultFoldDisplayText:
6319  		SetDefaultFoldDisplayText(ConstCharPtrFromSPtr(lParam));
6320  		Redraw();
6321  		break;
6322  	case Message::GetDefaultFoldDisplayText:
6323  		return StringResult(lParam, GetDefaultFoldDisplayText());
6324  	case Message::ToggleFold:
6325  		FoldLine(LineFromUPtr(wParam), FoldAction::Toggle);
6326  		break;
6327  	case Message::FoldLine:
6328  		FoldLine(LineFromUPtr(wParam), static_cast<FoldAction>(lParam));
6329  		break;
6330  	case Message::FoldChildren:
6331  		FoldExpand(LineFromUPtr(wParam), static_cast<FoldAction>(lParam), pdoc->GetFoldLevel(LineFromUPtr(wParam)));
6332  		break;
6333  	case Message::FoldAll:
6334  		FoldAll(static_cast<FoldAction>(wParam));
6335  		break;
6336  	case Message::ExpandChildren:
6337  		FoldExpand(LineFromUPtr(wParam), FoldAction::Expand, static_cast<FoldLevel>(lParam));
6338  		break;
6339  	case Message::ContractedFoldNext:
6340  		return ContractedFoldNext(LineFromUPtr(wParam));
6341  	case Message::EnsureVisible:
6342  		EnsureLineVisible(LineFromUPtr(wParam), false);
6343  		break;
6344  	case Message::EnsureVisibleEnforcePolicy:
6345  		EnsureLineVisible(LineFromUPtr(wParam), true);
6346  		break;
6347  	case Message::ScrollRange:
6348  		ScrollRange(SelectionRange(PositionFromUPtr(wParam), lParam));
6349  		break;
6350  	case Message::SearchAnchor:
6351  		SearchAnchor();
6352  		break;
6353  	case Message::SearchNext:
6354  	case Message::SearchPrev:
6355  		return SearchText(iMessage, wParam, lParam);
6356  	case Message::SetXCaretPolicy:
6357  		caretPolicies.x = CaretPolicySlop(wParam, lParam);
6358  		break;
6359  	case Message::SetYCaretPolicy:
6360  		caretPolicies.y = CaretPolicySlop(wParam, lParam);
6361  		break;
6362  	case Message::SetVisiblePolicy:
6363  		visiblePolicy = VisiblePolicySlop(wParam, lParam);
6364  		break;
6365  	case Message::LinesOnScreen:
6366  		return LinesOnScreen();
6367  	case Message::SetSelFore:
6368  		vs.elementColours[Element::SelectionText] = OptionalColour(wParam, lParam);
6369  		vs.elementColours[Element::SelectionAdditionalText] = OptionalColour(wParam, lParam);
6370  		InvalidateStyleRedraw();
6371  		break;
6372  	case Message::SetSelBack:
6373  		if (wParam) {
6374  			vs.SetElementRGB(Element::SelectionBack, static_cast<int>(lParam));
6375  			vs.SetElementRGB(Element::SelectionAdditionalBack, static_cast<int>(lParam));
6376  		} else {
6377  			vs.ResetElement(Element::SelectionBack);
6378  			vs.ResetElement(Element::SelectionAdditionalBack);
6379  		}
6380  		InvalidateStyleRedraw();
6381  		break;
6382  	case Message::SetSelAlpha: {
6383  			const Layer layerNew = (static_cast<Alpha>(wParam) == Alpha::NoAlpha) ? Layer::Base : Layer::OverText;
6384  			if (vs.selection.layer != layerNew) {
6385  			    vs.selection.layer = layerNew;
6386  			    UpdateBaseElements();
6387  			}
6388  			const int alpha = static_cast<int>(wParam);
6389  			vs.SetElementAlpha(Element::SelectionBack, alpha);
6390  			vs.SetElementAlpha(Element::SelectionAdditionalBack, alpha);
6391  			vs.SetElementAlpha(Element::SelectionSecondaryBack, alpha);
6392  			vs.SetElementAlpha(Element::SelectionInactiveBack, alpha);
6393  			InvalidateStyleRedraw();
6394  		}
6395  		break;
6396  	case Message::GetSelAlpha:
6397  		if (vs.selection.layer == Layer::Base)
6398  			return static_cast<sptr_t>(Alpha::NoAlpha);
6399  		return vs.ElementColourForced(Element::SelectionBack).GetAlpha();
6400  	case Message::GetSelEOLFilled:
6401  		return vs.selection.eolFilled;
6402  	case Message::SetSelEOLFilled:
6403  		vs.selection.eolFilled = wParam != 0;
6404  		InvalidateStyleRedraw();
6405  		break;
6406  	case Message::SetWhitespaceFore:
6407  		if (vs.SetElementColourOptional(Element::WhiteSpace, wParam, lParam)) {
6408  			InvalidateStyleRedraw();
6409  		}
6410  		break;
6411  	case Message::SetWhitespaceBack:
6412  		if (vs.SetElementColourOptional(Element::WhiteSpaceBack, wParam, lParam)) {
6413  			InvalidateStyleRedraw();
6414  		}
6415  		break;
6416  	case Message::SetSelectionLayer:
6417  		if (vs.selection.layer != static_cast<Layer>(wParam)) {
6418  			vs.selection.layer = static_cast<Layer>(wParam);
6419  			UpdateBaseElements();
6420  			InvalidateStyleRedraw();
6421  		}
6422  		break;
6423  	case Message::GetSelectionLayer:
6424  		return static_cast<sptr_t>(vs.selection.layer);
6425  	case Message::SetCaretFore:
6426  		vs.elementColours[Element::Caret] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
6427  		InvalidateStyleRedraw();
6428  		break;
6429  	case Message::GetCaretFore:
6430  		return vs.ElementColourForced(Element::Caret).OpaqueRGB();
6431  	case Message::SetCaretStyle:
6432  		if (static_cast<CaretStyle>(wParam) <= (CaretStyle::Block | CaretStyle::OverstrikeBlock | CaretStyle::Curses | CaretStyle::BlockAfter))
6433  			vs.caret.style = static_cast<CaretStyle>(wParam);
6434  		else
6435  			vs.caret.style = CaretStyle::Line;
6436  		InvalidateStyleRedraw();
6437  		break;
6438  	case Message::GetCaretStyle:
6439  		return static_cast<sptr_t>(vs.caret.style);
6440  	case Message::SetCaretWidth:
6441  		vs.caret.width = std::clamp(static_cast<int>(wParam), 0, 20);
6442  		InvalidateStyleRedraw();
6443  		break;
6444  	case Message::GetCaretWidth:
6445  		return vs.caret.width;
6446  	case Message::AssignCmdKey:
6447  		kmap.AssignCmdKey(static_cast<Keys>(LowShortFromWParam(wParam)),
6448  			static_cast<KeyMod>(HighShortFromWParam(wParam)), static_cast<Message>(lParam));
6449  		break;
6450  	case Message::ClearCmdKey:
6451  		kmap.AssignCmdKey(static_cast<Keys>(LowShortFromWParam(wParam)),
6452  			static_cast<KeyMod>(HighShortFromWParam(wParam)), Message::Null);
6453  		break;
6454  	case Message::ClearAllCmdKeys:
6455  		kmap.Clear();
6456  		break;
6457  	case Message::IndicSetStyle:
6458  		if (wParam <= IndicatorMax) {
6459  			vs.indicators[wParam].sacNormal.style = static_cast<IndicatorStyle>(lParam);
6460  			vs.indicators[wParam].sacHover.style = static_cast<IndicatorStyle>(lParam);
6461  			InvalidateStyleRedraw();
6462  		}
6463  		break;
6464  	case Message::IndicGetStyle:
6465  		return (wParam <= IndicatorMax) ?
6466  			static_cast<sptr_t>(vs.indicators[wParam].sacNormal.style) : 0;
6467  	case Message::IndicSetFore:
6468  		if (wParam <= IndicatorMax) {
6469  			vs.indicators[wParam].sacNormal.fore = ColourRGBA::FromIpRGB(lParam);
6470  			vs.indicators[wParam].sacHover.fore = ColourRGBA::FromIpRGB(lParam);
6471  			InvalidateStyleRedraw();
6472  		}
6473  		break;
6474  	case Message::IndicGetFore:
6475  		return (wParam <= IndicatorMax) ?
6476  			vs.indicators[wParam].sacNormal.fore.OpaqueRGB() : 0;
6477  	case Message::IndicSetHoverStyle:
6478  		if (wParam <= IndicatorMax) {
6479  			vs.indicators[wParam].sacHover.style = static_cast<IndicatorStyle>(lParam);
6480  			InvalidateStyleRedraw();
6481  		}
6482  		break;
6483  	case Message::IndicGetHoverStyle:
6484  		return (wParam <= IndicatorMax) ?
6485  			static_cast<sptr_t>(vs.indicators[wParam].sacHover.style) : 0;
6486  	case Message::IndicSetHoverFore:
6487  		if (wParam <= IndicatorMax) {
6488  			vs.indicators[wParam].sacHover.fore = ColourRGBA::FromIpRGB(lParam);
6489  			InvalidateStyleRedraw();
6490  		}
6491  		break;
6492  	case Message::IndicGetHoverFore:
6493  		return (wParam <= IndicatorMax) ?
6494  			vs.indicators[wParam].sacHover.fore.OpaqueRGB() : 0;
6495  	case Message::IndicSetFlags:
6496  		if (wParam <= IndicatorMax) {
6497  			vs.indicators[wParam].SetFlags(static_cast<IndicFlag>(lParam));
6498  			InvalidateStyleRedraw();
6499  		}
6500  		break;
6501  	case Message::IndicGetFlags:
6502  		return (wParam <= IndicatorMax) ?
6503  			static_cast<sptr_t>(vs.indicators[wParam].Flags()) : 0;
6504  	case Message::IndicSetUnder:
6505  		if (wParam <= IndicatorMax) {
6506  			vs.indicators[wParam].under = lParam != 0;
6507  			InvalidateStyleRedraw();
6508  		}
6509  		break;
6510  	case Message::IndicGetUnder:
6511  		return (wParam <= IndicatorMax) ?
6512  			vs.indicators[wParam].under : 0;
6513  	case Message::IndicSetAlpha:
6514  		if (wParam <= IndicatorMax && lParam >=0 && lParam <= 255) {
6515  			vs.indicators[wParam].fillAlpha = static_cast<int>(lParam);
6516  			InvalidateStyleRedraw();
6517  		}
6518  		break;
6519  	case Message::IndicGetAlpha:
6520  		return (wParam <= IndicatorMax)
6521  			? vs.indicators[wParam].fillAlpha : 0;
6522  	case Message::IndicSetOutlineAlpha:
6523  		if (wParam <= IndicatorMax && lParam >=0 && lParam <= 255) {
6524  			vs.indicators[wParam].outlineAlpha = static_cast<int>(lParam);
6525  			InvalidateStyleRedraw();
6526  		}
6527  		break;
6528  	case Message::IndicGetOutlineAlpha:
6529  		return (wParam <= IndicatorMax) ? vs.indicators[wParam].outlineAlpha : 0;
6530  	case Message::IndicSetStrokeWidth:
6531  		if (wParam <= IndicatorMax && lParam >= 0 && lParam <= 1000) {
6532  			vs.indicators[wParam].strokeWidth = lParam / 100.0f;
6533  			InvalidateStyleRedraw();
6534  		}
6535  		break;
6536  	case Message::IndicGetStrokeWidth:
6537  		if (wParam <= IndicatorMax) {
6538  			return std::lround(vs.indicators[wParam].strokeWidth * 100);
6539  		}
6540  		break;
6541  	case Message::SetIndicatorCurrent:
6542  		pdoc->DecorationSetCurrentIndicator(static_cast<int>(wParam));
6543  		break;
6544  	case Message::GetIndicatorCurrent:
6545  		return pdoc->decorations->GetCurrentIndicator();
6546  	case Message::SetIndicatorValue:
6547  		pdoc->decorations->SetCurrentValue(static_cast<int>(wParam));
6548  		break;
6549  	case Message::GetIndicatorValue:
6550  		return pdoc->decorations->GetCurrentValue();
6551  	case Message::IndicatorFillRange:
6552  		pdoc->DecorationFillRange(PositionFromUPtr(wParam),
6553  			pdoc->decorations->GetCurrentValue(), lParam);
6554  		break;
6555  	case Message::IndicatorClearRange:
6556  		pdoc->DecorationFillRange(PositionFromUPtr(wParam), 0,
6557  			lParam);
6558  		break;
6559  	case Message::IndicatorAllOnFor:
6560  		return pdoc->decorations->AllOnFor(PositionFromUPtr(wParam));
6561  	case Message::IndicatorValueAt:
6562  		return pdoc->decorations->ValueAt(static_cast<int>(wParam), lParam);
6563  	case Message::IndicatorStart:
6564  		return pdoc->decorations->Start(static_cast<int>(wParam), lParam);
6565  	case Message::IndicatorEnd:
6566  		return pdoc->decorations->End(static_cast<int>(wParam), lParam);
6567  	case Message::LineDown:
6568  	case Message::LineDownExtend:
6569  	case Message::ParaDown:
6570  	case Message::ParaDownExtend:
6571  	case Message::LineUp:
6572  	case Message::LineUpExtend:
6573  	case Message::ParaUp:
6574  	case Message::ParaUpExtend:
6575  	case Message::CharLeft:
6576  	case Message::CharLeftExtend:
6577  	case Message::CharRight:
6578  	case Message::CharRightExtend:
6579  	case Message::WordLeft:
6580  	case Message::WordLeftExtend:
6581  	case Message::WordRight:
6582  	case Message::WordRightExtend:
6583  	case Message::WordLeftEnd:
6584  	case Message::WordLeftEndExtend:
6585  	case Message::WordRightEnd:
6586  	case Message::WordRightEndExtend:
6587  	case Message::Home:
6588  	case Message::HomeExtend:
6589  	case Message::LineEnd:
6590  	case Message::LineEndExtend:
6591  	case Message::HomeWrap:
6592  	case Message::HomeWrapExtend:
6593  	case Message::LineEndWrap:
6594  	case Message::LineEndWrapExtend:
6595  	case Message::DocumentStart:
6596  	case Message::DocumentStartExtend:
6597  	case Message::DocumentEnd:
6598  	case Message::DocumentEndExtend:
6599  	case Message::ScrollToStart:
6600  	case Message::ScrollToEnd:
6601  	case Message::StutteredPageUp:
6602  	case Message::StutteredPageUpExtend:
6603  	case Message::StutteredPageDown:
6604  	case Message::StutteredPageDownExtend:
6605  	case Message::PageUp:
6606  	case Message::PageUpExtend:
6607  	case Message::PageDown:
6608  	case Message::PageDownExtend:
6609  	case Message::EditToggleOvertype:
6610  	case Message::Cancel:
6611  	case Message::DeleteBack:
6612  	case Message::Tab:
6613  	case Message::BackTab:
6614  	case Message::NewLine:
6615  	case Message::FormFeed:
6616  	case Message::VCHome:
6617  	case Message::VCHomeExtend:
6618  	case Message::VCHomeWrap:
6619  	case Message::VCHomeWrapExtend:
6620  	case Message::VCHomeDisplay:
6621  	case Message::VCHomeDisplayExtend:
6622  	case Message::ZoomIn:
6623  	case Message::ZoomOut:
6624  	case Message::DelWordLeft:
6625  	case Message::DelWordRight:
6626  	case Message::DelWordRightEnd:
6627  	case Message::DelLineLeft:
6628  	case Message::DelLineRight:
6629  	case Message::LineCopy:
6630  	case Message::LineCut:
6631  	case Message::LineDelete:
6632  	case Message::LineTranspose:
6633  	case Message::LineReverse:
6634  	case Message::LineDuplicate:
6635  	case Message::LowerCase:
6636  	case Message::UpperCase:
6637  	case Message::LineScrollDown:
6638  	case Message::LineScrollUp:
6639  	case Message::WordPartLeft:
6640  	case Message::WordPartLeftExtend:
6641  	case Message::WordPartRight:
6642  	case Message::WordPartRightExtend:
6643  	case Message::DeleteBackNotLine:
6644  	case Message::HomeDisplay:
6645  	case Message::HomeDisplayExtend:
6646  	case Message::LineEndDisplay:
6647  	case Message::LineEndDisplayExtend:
6648  	case Message::LineDownRectExtend:
6649  	case Message::LineUpRectExtend:
6650  	case Message::CharLeftRectExtend:
6651  	case Message::CharRightRectExtend:
6652  	case Message::HomeRectExtend:
6653  	case Message::VCHomeRectExtend:
6654  	case Message::LineEndRectExtend:
6655  	case Message::PageUpRectExtend:
6656  	case Message::PageDownRectExtend:
6657  	case Message::SelectionDuplicate:
6658  		return KeyCommand(iMessage);
6659  	case Message::BraceHighlight:
6660  		SetBraceHighlight(PositionFromUPtr(wParam), lParam, StyleBraceLight);
6661  		break;
6662  	case Message::BraceHighlightIndicator:
6663  		if (lParam >= 0 && static_cast<size_t>(lParam) <= IndicatorMax) {
6664  			vs.braceHighlightIndicatorSet = wParam != 0;
6665  			vs.braceHighlightIndicator = static_cast<int>(lParam);
6666  		}
6667  		break;
6668  	case Message::BraceBadLight:
6669  		SetBraceHighlight(PositionFromUPtr(wParam), -1, StyleBraceBad);
6670  		break;
6671  	case Message::BraceBadLightIndicator:
6672  		if (lParam >= 0 && static_cast<size_t>(lParam) <= IndicatorMax) {
6673  			vs.braceBadLightIndicatorSet = wParam != 0;
6674  			vs.braceBadLightIndicator = static_cast<int>(lParam);
6675  		}
6676  		break;
6677  	case Message::BraceMatch:
6678  		return pdoc->BraceMatch(PositionFromUPtr(wParam), lParam, 0, false);
6679  	case Message::BraceMatchNext:
6680  		return pdoc->BraceMatch(PositionFromUPtr(wParam), 0, lParam, true);
6681  	case Message::GetViewEOL:
6682  		return vs.viewEOL;
6683  	case Message::SetViewEOL:
6684  		vs.viewEOL = wParam != 0;
6685  		InvalidateStyleRedraw();
6686  		break;
6687  	case Message::SetZoom: {
6688  			const int zoomLevel = static_cast<int>(wParam);
6689  			if (zoomLevel != vs.zoomLevel) {
6690  				vs.zoomLevel = zoomLevel;
6691  				InvalidateStyleRedraw();
6692  				NotifyZoom();
6693  			}
6694  			break;
6695  		}
6696  	case Message::GetZoom:
6697  		return vs.zoomLevel;
6698  	case Message::GetEdgeColumn:
6699  		return vs.theEdge.column;
6700  	case Message::SetEdgeColumn:
6701  		vs.theEdge.column = static_cast<int>(wParam);
6702  		InvalidateStyleRedraw();
6703  		break;
6704  	case Message::GetEdgeMode:
6705  		return static_cast<sptr_t>(vs.edgeState);
6706  	case Message::SetEdgeMode:
6707  		vs.edgeState = static_cast<EdgeVisualStyle>(wParam);
6708  		InvalidateStyleRedraw();
6709  		break;
6710  	case Message::GetEdgeColour:
6711  		return vs.theEdge.colour.OpaqueRGB();
6712  	case Message::SetEdgeColour:
6713  		vs.theEdge.colour = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
6714  		InvalidateStyleRedraw();
6715  		break;
6716  	case Message::MultiEdgeAddLine:
6717  		vs.AddMultiEdge(static_cast<int>(wParam), ColourRGBA::FromIpRGB(lParam));
6718  		InvalidateStyleRedraw();
6719  		break;
6720  	case Message::MultiEdgeClearAll:
6721  		std::vector<EdgeProperties>().swap(vs.theMultiEdge); 
6722  		InvalidateStyleRedraw();
6723  		break;
6724  	case Message::GetMultiEdgeColumn: {
6725  			const size_t which = wParam;
6726  			if (which >= vs.theMultiEdge.size()) {
6727  				return -1;
6728  			}
6729  			return vs.theMultiEdge[which].column;
6730  		}
6731  	case Message::GetAccessibility:
6732  		return static_cast<sptr_t>(Accessibility::Disabled);
6733  	case Message::SetAccessibility:
6734  		break;
6735  	case Message::GetDocPointer:
6736  		return reinterpret_cast<sptr_t>(pdoc);
6737  	case Message::SetDocPointer:
6738  		CancelModes();
6739  		SetDocPointer(static_cast<Document *>(PtrFromSPtr(lParam)));
6740  		return 0;
6741  	case Message::CreateDocument: {
6742  			Document *doc = new Document(static_cast<DocumentOption>(lParam));
6743  			doc->AddRef();
6744  			doc->Allocate(PositionFromUPtr(wParam));
6745  			pcs = ContractionStateCreate(pdoc->IsLarge());
6746  			return reinterpret_cast<sptr_t>(doc);
6747  		}
6748  	case Message::AddRefDocument:
6749  		(static_cast<Document *>(PtrFromSPtr(lParam)))->AddRef();
6750  		break;
6751  	case Message::ReleaseDocument:
6752  		(static_cast<Document *>(PtrFromSPtr(lParam)))->Release();
6753  		break;
6754  	case Message::GetDocumentOptions:
6755  		return static_cast<sptr_t>(pdoc->Options());
6756  	case Message::CreateLoader: {
6757  			Document *doc = new Document(static_cast<DocumentOption>(lParam));
6758  			doc->AddRef();
6759  			doc->Allocate(PositionFromUPtr(wParam));
6760  			doc->SetUndoCollection(false);
6761  			pcs = ContractionStateCreate(pdoc->IsLarge());
6762  			return reinterpret_cast<sptr_t>(static_cast<ILoader *>(doc));
6763  		}
6764  	case Message::SetModEventMask:
6765  		modEventMask = static_cast<ModificationFlags>(wParam);
6766  		return 0;
6767  	case Message::GetModEventMask:
6768  		return static_cast<sptr_t>(modEventMask);
6769  	case Message::SetCommandEvents:
6770  		commandEvents = static_cast<bool>(wParam);
6771  		return 0;
6772  	case Message::GetCommandEvents:
6773  		return commandEvents;
6774  	case Message::ConvertEOLs:
6775  		pdoc->ConvertLineEnds(static_cast<EndOfLine>(wParam));
6776  		SetSelection(sel.MainCaret(), sel.MainAnchor());	
6777  		return 0;
6778  	case Message::SetLengthForEncode:
6779  		lengthForEncode = PositionFromUPtr(wParam);
6780  		return 0;
6781  	case Message::SelectionIsRectangle:
6782  		return sel.selType == Selection::SelTypes::rectangle ? 1 : 0;
6783  	case Message::SetSelectionMode: {
6784  			switch (static_cast<SelectionMode>(wParam)) {
6785  			case SelectionMode::Stream:
6786  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::stream));
6787  				sel.selType = Selection::SelTypes::stream;
6788  				break;
6789  			case SelectionMode::Rectangle:
6790  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::rectangle));
6791  				sel.selType = Selection::SelTypes::rectangle;
6792  				sel.Rectangular() = sel.RangeMain(); 
6793  				break;
6794  			case SelectionMode::Lines:
6795  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::lines));
6796  				sel.selType = Selection::SelTypes::lines;
6797  				SetSelection(sel.RangeMain().caret, sel.RangeMain().anchor); 
6798  				break;
6799  			case SelectionMode::Thin:
6800  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::thin));
6801  				sel.selType = Selection::SelTypes::thin;
6802  				break;
6803  			default:
6804  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::stream));
6805  				sel.selType = Selection::SelTypes::stream;
6806  			}
6807  			InvalidateWholeSelection();
6808  			break;
6809  		}
6810  	case Message::GetSelectionMode:
6811  		switch (sel.selType) {
6812  		case Selection::SelTypes::stream:
6813  			return static_cast<sptr_t>(SelectionMode::Stream);
6814  		case Selection::SelTypes::rectangle:
6815  			return static_cast<sptr_t>(SelectionMode::Rectangle);
6816  		case Selection::SelTypes::lines:
6817  			return static_cast<sptr_t>(SelectionMode::Lines);
6818  		case Selection::SelTypes::thin:
6819  			return static_cast<sptr_t>(SelectionMode::Thin);
6820  		default:	
6821  			return static_cast<sptr_t>(SelectionMode::Stream);
6822  		}
6823  	case Message::GetMoveExtendsSelection:
6824  		return sel.MoveExtends();
6825  	case Message::GetLineSelStartPosition:
6826  	case Message::GetLineSelEndPosition: {
6827  			const SelectionSegment segmentLine(
6828  				SelectionPosition(pdoc->LineStart(LineFromUPtr(wParam))),
6829  				SelectionPosition(pdoc->LineEnd(LineFromUPtr(wParam))));
6830  			for (size_t r=0; r<sel.Count(); r++) {
6831  				const SelectionSegment portion = sel.Range(r).Intersect(segmentLine);
6832  				if (portion.start.IsValid()) {
6833  					return (iMessage == Message::GetLineSelStartPosition) ? portion.start.Position() : portion.end.Position();
6834  				}
6835  			}
6836  			return Sci::invalidPosition;
6837  		}
6838  	case Message::SetOvertype:
6839  		if (inOverstrike != (wParam != 0)) {
6840  			inOverstrike = wParam != 0;
6841  			ContainerNeedsUpdate(Update::Selection);
6842  			ShowCaretAtCurrentPosition();
6843  			SetIdle(true);
6844  		}
6845  		break;
6846  	case Message::GetOvertype:
6847  		return inOverstrike ? 1 : 0;
6848  	case Message::SetFocus:
6849  		SetFocusState(wParam != 0);
6850  		break;
6851  	case Message::GetFocus:
6852  		return hasFocus;
6853  	case Message::SetStatus:
6854  		errorStatus = static_cast<Status>(wParam);
6855  		break;
6856  	case Message::GetStatus:
6857  		return static_cast<sptr_t>(errorStatus);
6858  	case Message::SetMouseDownCaptures:
6859  		mouseDownCaptures = wParam != 0;
6860  		break;
6861  	case Message::GetMouseDownCaptures:
6862  		return mouseDownCaptures;
6863  	case Message::SetMouseWheelCaptures:
6864  		mouseWheelCaptures = wParam != 0;
6865  		break;
6866  	case Message::GetMouseWheelCaptures:
6867  		return mouseWheelCaptures;
6868  	case Message::SetCursor:
6869  		cursorMode = static_cast<CursorShape>(wParam);
6870  		DisplayCursor(Window::Cursor::text);
6871  		break;
6872  	case Message::GetCursor:
6873  		return static_cast<sptr_t>(cursorMode);
6874  	case Message::SetControlCharSymbol:
6875  		vs.controlCharSymbol = static_cast<int>(wParam);
6876  		InvalidateStyleRedraw();
6877  		break;
6878  	case Message::GetControlCharSymbol:
6879  		return vs.controlCharSymbol;
6880  	case Message::SetRepresentation:
6881  		reprs.SetRepresentation(ConstCharPtrFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
6882  		break;
6883  	case Message::GetRepresentation: {
6884  			const Representation *repr = reprs.RepresentationFromCharacter(
6885  				ConstCharPtrFromUPtr(wParam));
6886  			if (repr) {
6887  				return StringResult(lParam, repr->stringRep.c_str());
6888  			}
6889  			return 0;
6890  		}
6891  	case Message::ClearRepresentation:
6892  		reprs.ClearRepresentation(ConstCharPtrFromUPtr(wParam));
6893  		break;
6894  	case Message::ClearAllRepresentations:
6895  		SetRepresentations();
6896  		break;
6897  	case Message::SetRepresentationAppearance:
6898  		reprs.SetRepresentationAppearance(ConstCharPtrFromUPtr(wParam), static_cast<RepresentationAppearance>(lParam));
6899  		break;
6900  	case Message::GetRepresentationAppearance: {
6901  			const Representation *repr = reprs.RepresentationFromCharacter(
6902  				ConstCharPtrFromUPtr(wParam));
6903  			if (repr) {
6904  				return static_cast<sptr_t>(repr->appearance);
6905  			}
6906  			return 0;
6907  		}
6908  	case Message::SetRepresentationColour:
6909  		reprs.SetRepresentationColour(ConstCharPtrFromUPtr(wParam), ColourRGBA(static_cast<int>(lParam)));
6910  		break;
6911  	case Message::GetRepresentationColour: {
6912  			const Representation *repr = reprs.RepresentationFromCharacter(
6913  				ConstCharPtrFromUPtr(wParam));
6914  			if (repr) {
6915  				return repr->colour.AsInteger();
6916  			}
6917  			return 0;
6918  		}
6919  	case Message::StartRecord:
6920  		recordingMacro = true;
6921  		return 0;
6922  	case Message::StopRecord:
6923  		recordingMacro = false;
6924  		return 0;
6925  	case Message::MoveCaretInsideView:
6926  		MoveCaretInsideView();
6927  		break;
6928  	case Message::SetFoldMarginColour:
6929  		vs.foldmarginColour = OptionalColour(wParam, lParam);
6930  		InvalidateStyleRedraw();
6931  		break;
6932  	case Message::SetFoldMarginHiColour:
6933  		vs.foldmarginHighlightColour = OptionalColour(wParam, lParam);
6934  		InvalidateStyleRedraw();
6935  		break;
6936  	case Message::SetHotspotActiveFore:
6937  		if (vs.SetElementColourOptional(Element::HotSpotActive, wParam, lParam)) {
6938  			InvalidateStyleRedraw();
6939  		}
6940  		break;
6941  	case Message::GetHotspotActiveFore:
6942  		return vs.ElementColour(Element::HotSpotActive).value_or(ColourRGBA()).OpaqueRGB();
6943  	case Message::SetHotspotActiveBack:
6944  		if (vs.SetElementColourOptional(Element::HotSpotActiveBack, wParam, lParam)) {
6945  			InvalidateStyleRedraw();
6946  		}
6947  		break;
6948  	case Message::GetHotspotActiveBack:
6949  		return vs.ElementColour(Element::HotSpotActiveBack).value_or(ColourRGBA()).OpaqueRGB();
6950  	case Message::SetHotspotActiveUnderline:
6951  		vs.hotspotUnderline = wParam != 0;
6952  		InvalidateStyleRedraw();
6953  		break;
6954  	case Message::GetHotspotActiveUnderline:
6955  		return vs.hotspotUnderline ? 1 : 0;
6956  	case Message::SetHotspotSingleLine:
6957  		hotspotSingleLine = wParam != 0;
6958  		InvalidateStyleRedraw();
6959  		break;
6960  	case Message::GetHotspotSingleLine:
6961  		return hotspotSingleLine ? 1 : 0;
6962  	case Message::SetPasteConvertEndings:
6963  		convertPastes = wParam != 0;
6964  		break;
6965  	case Message::GetPasteConvertEndings:
6966  		return convertPastes ? 1 : 0;
6967  	case Message::GetCharacterPointer:
6968  		return reinterpret_cast<sptr_t>(pdoc->BufferPointer());
6969  	case Message::GetRangePointer:
6970  		return reinterpret_cast<sptr_t>(pdoc->RangePointer(
6971  			PositionFromUPtr(wParam), lParam));
6972  	case Message::GetGapPosition:
6973  		return pdoc->GapPosition();
6974  	case Message::SetChangeHistory:
6975  		changeHistoryOption = static_cast<ChangeHistoryOption>(wParam);
6976  		pdoc->ChangeHistorySet(wParam & 1);
6977  		break;
6978  	case Message::GetChangeHistory:
6979  		return static_cast<sptr_t>(changeHistoryOption);
6980  	case Message::SetExtraAscent:
6981  		vs.extraAscent = static_cast<int>(wParam);
6982  		InvalidateStyleRedraw();
6983  		break;
6984  	case Message::GetExtraAscent:
6985  		return vs.extraAscent;
6986  	case Message::SetExtraDescent:
6987  		vs.extraDescent = static_cast<int>(wParam);
6988  		InvalidateStyleRedraw();
6989  		break;
6990  	case Message::GetExtraDescent:
6991  		return vs.extraDescent;
6992  	case Message::MarginSetStyleOffset:
6993  		vs.marginStyleOffset = static_cast<int>(wParam);
6994  		InvalidateStyleRedraw();
6995  		break;
6996  	case Message::MarginGetStyleOffset:
6997  		return vs.marginStyleOffset;
6998  	case Message::SetMarginOptions:
6999  		marginOptions = static_cast<MarginOption>(wParam);
7000  		break;
7001  	case Message::GetMarginOptions:
7002  		return static_cast<sptr_t>(marginOptions);
7003  	case Message::MarginSetText:
7004  		pdoc->MarginSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7005  		break;
7006  	case Message::MarginGetText: {
7007  			const StyledText st = pdoc->MarginStyledText(LineFromUPtr(wParam));
7008  			return BytesResult(lParam, reinterpret_cast<const unsigned char *>(st.text), st.length);
7009  		}
7010  	case Message::MarginSetStyle:
7011  		pdoc->MarginSetStyle(LineFromUPtr(wParam), static_cast<int>(lParam));
7012  		break;
7013  	case Message::MarginGetStyle: {
7014  			const StyledText st = pdoc->MarginStyledText(LineFromUPtr(wParam));
7015  			return st.style;
7016  		}
7017  	case Message::MarginSetStyles:
7018  		pdoc->MarginSetStyles(LineFromUPtr(wParam), ConstUCharPtrFromSPtr(lParam));
7019  		break;
7020  	case Message::MarginGetStyles: {
7021  			const StyledText st = pdoc->MarginStyledText(LineFromUPtr(wParam));
7022  			return BytesResult(lParam, st.styles, st.length);
7023  		}
7024  	case Message::MarginTextClearAll:
7025  		pdoc->MarginClearAll();
7026  		break;
7027  	case Message::AnnotationSetText:
7028  		pdoc->AnnotationSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7029  		break;
7030  	case Message::AnnotationGetText: {
7031  			const StyledText st = pdoc->AnnotationStyledText(LineFromUPtr(wParam));
7032  			return BytesResult(lParam, reinterpret_cast<const unsigned char *>(st.text), st.length);
7033  		}
7034  	case Message::AnnotationGetStyle: {
7035  			const StyledText st = pdoc->AnnotationStyledText(LineFromUPtr(wParam));
7036  			return st.style;
7037  		}
7038  	case Message::AnnotationSetStyle:
7039  		pdoc->AnnotationSetStyle(LineFromUPtr(wParam), static_cast<int>(lParam));
7040  		break;
7041  	case Message::AnnotationSetStyles:
7042  		pdoc->AnnotationSetStyles(LineFromUPtr(wParam), ConstUCharPtrFromSPtr(lParam));
7043  		break;
7044  	case Message::AnnotationGetStyles: {
7045  			const StyledText st = pdoc->AnnotationStyledText(LineFromUPtr(wParam));
7046  			return BytesResult(lParam, st.styles, st.length);
7047  		}
7048  	case Message::AnnotationGetLines:
7049  		return pdoc->AnnotationLines(LineFromUPtr(wParam));
7050  	case Message::AnnotationClearAll:
7051  		pdoc->AnnotationClearAll();
7052  		break;
7053  	case Message::AnnotationSetVisible:
7054  		SetAnnotationVisible(static_cast<AnnotationVisible>(wParam));
7055  		break;
7056  	case Message::AnnotationGetVisible:
7057  		return static_cast<sptr_t>(vs.annotationVisible);
7058  	case Message::AnnotationSetStyleOffset:
7059  		vs.annotationStyleOffset = static_cast<int>(wParam);
7060  		InvalidateStyleRedraw();
7061  		break;
7062  	case Message::AnnotationGetStyleOffset:
7063  		return vs.annotationStyleOffset;
7064  	case Message::EOLAnnotationSetText:
7065  		pdoc->EOLAnnotationSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7066  		break;
7067  	case Message::EOLAnnotationGetText: {
7068  			const StyledText st = pdoc->EOLAnnotationStyledText(LineFromUPtr(wParam));
7069  			return BytesResult(lParam, reinterpret_cast<const unsigned char *>(st.text), st.length);
7070  		}
7071  	case Message::EOLAnnotationGetStyle: {
7072  			const StyledText st = pdoc->EOLAnnotationStyledText(LineFromUPtr(wParam));
7073  			return st.style;
7074  		}
7075  	case Message::EOLAnnotationSetStyle:
7076  		pdoc->EOLAnnotationSetStyle(LineFromUPtr(wParam), static_cast<int>(lParam));
7077  		break;
7078  	case Message::EOLAnnotationClearAll:
7079  		pdoc->EOLAnnotationClearAll();
7080  		break;
7081  	case Message::EOLAnnotationSetVisible:
7082  		SetEOLAnnotationVisible(static_cast<EOLAnnotationVisible>(wParam));
7083  		break;
7084  	case Message::EOLAnnotationGetVisible:
7085  		return static_cast<sptr_t>(vs.eolAnnotationVisible);
7086  	case Message::EOLAnnotationSetStyleOffset:
7087  		vs.eolAnnotationStyleOffset = static_cast<int>(wParam);
7088  		InvalidateStyleRedraw();
7089  		break;
7090  	case Message::EOLAnnotationGetStyleOffset:
7091  		return vs.eolAnnotationStyleOffset;
7092  	case Message::ReleaseAllExtendedStyles:
7093  		vs.ReleaseAllExtendedStyles();
7094  		break;
7095  	case Message::AllocateExtendedStyles:
7096  		return vs.AllocateExtendedStyles(static_cast<int>(wParam));
7097  	case Message::SupportsFeature:
7098  		return SupportsFeature(static_cast<Supports>(wParam));
7099  	case Message::AddUndoAction:
7100  		pdoc->AddUndoAction(PositionFromUPtr(wParam),
7101  			FlagSet(static_cast<UndoFlags>(lParam), UndoFlags::MayCoalesce));
7102  		break;
7103  	case Message::SetMouseSelectionRectangularSwitch:
7104  		mouseSelectionRectangularSwitch = wParam != 0;
7105  		break;
7106  	case Message::GetMouseSelectionRectangularSwitch:
7107  		return mouseSelectionRectangularSwitch;
7108  	case Message::SetMultipleSelection:
7109  		multipleSelection = wParam != 0;
7110  		InvalidateCaret();
7111  		break;
7112  	case Message::GetMultipleSelection:
7113  		return multipleSelection;
7114  	case Message::SetAdditionalSelectionTyping:
7115  		additionalSelectionTyping = wParam != 0;
7116  		InvalidateCaret();
7117  		break;
7118  	case Message::GetAdditionalSelectionTyping:
7119  		return additionalSelectionTyping;
7120  	case Message::SetMultiPaste:
7121  		multiPasteMode = static_cast<MultiPaste>(wParam);
7122  		break;
7123  	case Message::GetMultiPaste:
7124  		return static_cast<sptr_t>(multiPasteMode);
7125  	case Message::SetAdditionalCaretsBlink:
7126  		view.additionalCaretsBlink = wParam != 0;
7127  		InvalidateCaret();
7128  		break;
7129  	case Message::GetAdditionalCaretsBlink:
7130  		return view.additionalCaretsBlink;
7131  	case Message::SetAdditionalCaretsVisible:
7132  		view.additionalCaretsVisible = wParam != 0;
7133  		InvalidateCaret();
7134  		break;
7135  	case Message::GetAdditionalCaretsVisible:
7136  		return view.additionalCaretsVisible;
7137  	case Message::GetSelections:
7138  		return sel.Count();
7139  	case Message::GetSelectionEmpty:
7140  		return sel.Empty();
7141  	case Message::ClearSelections:
7142  		sel.Clear();
7143  		ContainerNeedsUpdate(Update::Selection);
7144  		Redraw();
7145  		break;
7146  	case Message::SetSelection:
7147  		sel.SetSelection(SelectionRange(PositionFromUPtr(wParam), lParam));
7148  		Redraw();
7149  		break;
7150  	case Message::AddSelection:
7151  		sel.AddSelection(SelectionRange(PositionFromUPtr(wParam), lParam));
7152  		ContainerNeedsUpdate(Update::Selection);
7153  		Redraw();
7154  		break;
7155  	case Message::DropSelectionN:
7156  		sel.DropSelection(wParam);
7157  		ContainerNeedsUpdate(Update::Selection);
7158  		Redraw();
7159  		break;
7160  	case Message::SetMainSelection:
7161  		sel.SetMain(wParam);
7162  		ContainerNeedsUpdate(Update::Selection);
7163  		Redraw();
7164  		break;
7165  	case Message::GetMainSelection:
7166  		return sel.Main();
7167  	case Message::SetSelectionNCaret:
7168  	case Message::SetSelectionNAnchor:
7169  	case Message::SetSelectionNCaretVirtualSpace:
7170  	case Message::SetSelectionNAnchorVirtualSpace:
7171  	case Message::SetSelectionNStart:
7172  	case Message::SetSelectionNEnd:
7173  		SetSelectionNMessage(iMessage, wParam, lParam);
7174  		break;
7175  	case Message::GetSelectionNCaret:
7176  		return sel.Range(wParam).caret.Position();
7177  	case Message::GetSelectionNAnchor:
7178  		return sel.Range(wParam).anchor.Position();
7179  	case Message::GetSelectionNCaretVirtualSpace:
7180  		return sel.Range(wParam).caret.VirtualSpace();
7181  	case Message::GetSelectionNAnchorVirtualSpace:
7182  		return sel.Range(wParam).anchor.VirtualSpace();
7183  	case Message::GetSelectionNStart:
7184  		return sel.Range(wParam).Start().Position();
7185  	case Message::GetSelectionNStartVirtualSpace:
7186  		return sel.Range(wParam).Start().VirtualSpace();
7187  	case Message::GetSelectionNEnd:
7188  		return sel.Range(wParam).End().Position();
7189  	case Message::GetSelectionNEndVirtualSpace:
7190  		return sel.Range(wParam).End().VirtualSpace();
7191  	case Message::SetRectangularSelectionCaret:
7192  		if (!sel.IsRectangular())
7193  			sel.Clear();
7194  		sel.selType = Selection::SelTypes::rectangle;
7195  		sel.Rectangular().caret.SetPosition(PositionFromUPtr(wParam));
7196  		SetRectangularRange();
7197  		Redraw();
7198  		break;
7199  	case Message::GetRectangularSelectionCaret:
7200  		return sel.Rectangular().caret.Position();
7201  	case Message::SetRectangularSelectionAnchor:
7202  		if (!sel.IsRectangular())
7203  			sel.Clear();
7204  		sel.selType = Selection::SelTypes::rectangle;
7205  		sel.Rectangular().anchor.SetPosition(PositionFromUPtr(wParam));
7206  		SetRectangularRange();
7207  		Redraw();
7208  		break;
7209  	case Message::GetRectangularSelectionAnchor:
7210  		return sel.Rectangular().anchor.Position();
7211  	case Message::SetRectangularSelectionCaretVirtualSpace:
7212  		if (!sel.IsRectangular())
7213  			sel.Clear();
7214  		sel.selType = Selection::SelTypes::rectangle;
7215  		sel.Rectangular().caret.SetVirtualSpace(PositionFromUPtr(wParam));
7216  		SetRectangularRange();
7217  		Redraw();
7218  		break;
7219  	case Message::GetRectangularSelectionCaretVirtualSpace:
7220  		return sel.Rectangular().caret.VirtualSpace();
7221  	case Message::SetRectangularSelectionAnchorVirtualSpace:
7222  		if (!sel.IsRectangular())
7223  			sel.Clear();
7224  		sel.selType = Selection::SelTypes::rectangle;
7225  		sel.Rectangular().anchor.SetVirtualSpace(PositionFromUPtr(wParam));
7226  		SetRectangularRange();
7227  		Redraw();
7228  		break;
7229  	case Message::GetRectangularSelectionAnchorVirtualSpace:
7230  		return sel.Rectangular().anchor.VirtualSpace();
7231  	case Message::SetVirtualSpaceOptions:
7232  		virtualSpaceOptions = static_cast<VirtualSpace>(wParam);
7233  		break;
7234  	case Message::GetVirtualSpaceOptions:
7235  		return static_cast<sptr_t>(virtualSpaceOptions);
7236  	case Message::SetAdditionalSelFore:
7237  		vs.elementColours[Element::SelectionAdditionalText] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
7238  		InvalidateStyleRedraw();
7239  		break;
7240  	case Message::SetAdditionalSelBack:
7241  		vs.SetElementRGB(Element::SelectionAdditionalBack, static_cast<int>(wParam));
7242  		InvalidateStyleRedraw();
7243  		break;
7244  	case Message::SetAdditionalSelAlpha:
7245  		vs.SetElementAlpha(Element::SelectionAdditionalBack, static_cast<int>(wParam));
7246  		InvalidateStyleRedraw();
7247  		break;
7248  	case Message::GetAdditionalSelAlpha:
7249  		if (vs.selection.layer == Layer::Base)
7250  			return static_cast<sptr_t>(Alpha::NoAlpha);
7251  		return vs.ElementColourForced(Element::SelectionAdditionalBack).GetAlpha();
7252  	case Message::SetAdditionalCaretFore:
7253  		vs.elementColours[Element::CaretAdditional] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
7254  		InvalidateStyleRedraw();
7255  		break;
7256  	case Message::GetAdditionalCaretFore:
7257  		return vs.ElementColourForced(Element::CaretAdditional).OpaqueRGB();
7258  	case Message::RotateSelection:
7259  		sel.RotateMain();
7260  		InvalidateWholeSelection();
7261  		break;
7262  	case Message::SwapMainAnchorCaret:
7263  		InvalidateSelection(sel.RangeMain());
7264  		sel.RangeMain().Swap();
7265  		break;
7266  	case Message::MultipleSelectAddNext:
7267  		MultipleSelectAdd(AddNumber::one);
7268  		break;
7269  	case Message::MultipleSelectAddEach:
7270  		MultipleSelectAdd(AddNumber::each);
7271  		break;
7272  	case Message::ChangeLexerState:
7273  		pdoc->ChangeLexerState(PositionFromUPtr(wParam), lParam);
7274  		break;
7275  	case Message::SetIdentifier:
7276  		SetCtrlID(static_cast<int>(wParam));
7277  		break;
7278  	case Message::GetIdentifier:
7279  		return GetCtrlID();
7280  	case Message::SetTechnology:
7281  		break;
7282  	case Message::GetTechnology:
7283  		return static_cast<sptr_t>(technology);
7284  	case Message::CountCharacters:
7285  		return pdoc->CountCharacters(PositionFromUPtr(wParam), lParam);
7286  	case Message::CountCodeUnits:
7287  		return pdoc->CountUTF16(PositionFromUPtr(wParam), lParam);
7288  	default:
7289  		return DefWndProc(iMessage, wParam, lParam);
7290  	}
7291  	return 0;
7292  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PositionCache.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cstring>
5  #include <cmath>
6  #include <stdexcept>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <iterator>
15  #include <memory>
16  #include <mutex>
17  #include "ScintillaTypes.h"
18  #include "ScintillaMessages.h"
19  #include "ILoader.h"
20  #include "ILexer.h"
21  #include "Debugging.h"
22  #include "Geometry.h"
23  #include "Platform.h"
24  #include "CharacterType.h"
25  #include "CharacterCategoryMap.h"
26  #include "Position.h"
27  #include "UniqueString.h"
28  #include "SplitVector.h"
29  #include "Partitioning.h"
30  #include "RunStyles.h"
31  #include "ContractionState.h"
32  #include "CellBuffer.h"
33  #include "KeyMap.h"
34  #include "Indicator.h"
35  #include "LineMarker.h"
36  #include "Style.h"
37  #include "ViewStyle.h"
38  #include "CharClassify.h"
39  #include "Decoration.h"
40  #include "CaseFolder.h"
41  #include "Document.h"
42  #include "UniConversion.h"
43  #include "DBCS.h"
44  #include "Selection.h"
45  #include "PositionCache.h"
46  using namespace Scintilla;
47  using namespace Scintilla::Internal;
48  void BidiData::Resize(size_t maxLineLength_) {
49  	stylesFonts.resize(maxLineLength_ + 1);
50  	widthReprs.resize(maxLineLength_ + 1);
51  }
52  LineLayout::LineLayout(Sci::Line lineNumber_, int maxLineLength_) :
53  	lenLineStarts(0),
54  	lineNumber(lineNumber_),
55  	maxLineLength(-1),
56  	numCharsInLine(0),
57  	numCharsBeforeEOL(0),
58  	validity(ValidLevel::invalid),
59  	xHighlightGuide(0),
60  	highlightColumn(false),
61  	containsCaret(false),
62  	edgeColumn(0),
63  	bracePreviousStyles{},
64  	widthLine(wrapWidthInfinite),
65  	lines(1),
66  	wrapIndent(0) {
67  	Resize(maxLineLength_);
68  }
69  LineLayout::~LineLayout() {
<span onclick='openModal()' class='match'>70  	Free();
71  }
72  void LineLayout::Resize(int maxLineLength_) {
73  	if (maxLineLength_ > maxLineLength) {
</span>74  		Free();
75  		const size_t lineAllocation = maxLineLength_ + 1;
76  		chars = std::make_unique<char[]>(lineAllocation);
77  		styles = std::make_unique<unsigned char []>(lineAllocation);
78  		positions = std::make_unique<XYPOSITION []>(lineAllocation + 1);
79  		if (bidiData) {
80  			bidiData->Resize(maxLineLength_);
81  		}
82  		maxLineLength = maxLineLength_;
83  	}
84  }
85  void LineLayout::ReSet(Sci::Line lineNumber_, Sci::Position maxLineLength_) {
86  	lineNumber = lineNumber_;
87  	Resize(static_cast<int>(maxLineLength_));
88  	lines = 0;
89  	Invalidate(ValidLevel::invalid);
90  }
91  void LineLayout::EnsureBidiData() {
92  	if (!bidiData) {
93  		bidiData = std::make_unique<BidiData>();
94  		bidiData->Resize(maxLineLength);
95  	}
96  }
97  void LineLayout::Free() noexcept {
98  	chars.reset();
99  	styles.reset();
100  	positions.reset();
101  	lineStarts.reset();
102  	lenLineStarts = 0;
103  	bidiData.reset();
104  }
105  void LineLayout::ClearPositions() {
106  	std::fill(&positions[0], &positions[maxLineLength + 2], 0.0f);
107  }
108  void LineLayout::Invalidate(ValidLevel validity_) noexcept {
109  	if (validity > validity_)
110  		validity = validity_;
111  }
112  Sci::Line LineLayout::LineNumber() const noexcept {
113  	return lineNumber;
114  }
115  bool LineLayout::CanHold(Sci::Line lineDoc, int lineLength_) const noexcept {
116  	return (lineNumber == lineDoc) && (lineLength_ <= maxLineLength);
117  }
118  int LineLayout::LineStart(int line) const noexcept {
119  	if (line <= 0) {
120  		return 0;
121  	} else if ((line >= lines) || !lineStarts) {
122  		return numCharsInLine;
123  	} else {
124  		return lineStarts[line];
125  	}
126  }
127  int LineLayout::LineLength(int line) const noexcept {
128  	if (!lineStarts) {
129  		return numCharsInLine;
130  	} if (line >= lines - 1) {
131  		return numCharsInLine - lineStarts[line];
132  	} else {
133  		return lineStarts[line + 1] - lineStarts[line];
134  	}
135  }
136  int LineLayout::LineLastVisible(int line, Scope scope) const noexcept {
137  	if (line < 0) {
138  		return 0;
139  	} else if ((line >= lines-1) || !lineStarts) {
140  		return scope == Scope::visibleOnly ? numCharsBeforeEOL : numCharsInLine;
141  	} else {
142  		return lineStarts[line+1];
143  	}
144  }
145  Range LineLayout::SubLineRange(int subLine, Scope scope) const noexcept {
146  	return Range(LineStart(subLine), LineLastVisible(subLine, scope));
147  }
148  bool LineLayout::InLine(int offset, int line) const noexcept {
149  	return ((offset >= LineStart(line)) && (offset < LineStart(line + 1))) ||
150  		((offset == numCharsInLine) && (line == (lines-1)));
151  }
152  int LineLayout::SubLineFromPosition(int posInLine, PointEnd pe) const noexcept {
153  	if (!lineStarts || (posInLine > maxLineLength)) {
154  		return lines - 1;
155  	}
156  	for (int line = 0; line < lines; line++) {
157  		if (FlagSet(pe, PointEnd::subLineEnd)) {
158  			if (lineStarts[line + 1] <= posInLine + 1)
159  				return line;
160  		} else {
161  			if (lineStarts[line + 1] <= posInLine)
162  				return line;
163  		}
164  	}
165  	return lines - 1;
166  }
167  void LineLayout::AddLineStart(Sci::Position start) {
168  	lines++;
169  	if (lines >= lenLineStarts) {
170  		const int newMaxLines = lines + 20;
171  		std::unique_ptr<int[]> newLineStarts = std::make_unique<int[]>(newMaxLines);
172  		if (lenLineStarts) {
173  			std::copy(lineStarts.get(), lineStarts.get() + lenLineStarts, newLineStarts.get());
174  		}
175  		lineStarts = std::move(newLineStarts);
176  		lenLineStarts = newMaxLines;
177  	}
178  	lineStarts[lines] = static_cast<int>(start);
179  }
180  void LineLayout::SetBracesHighlight(Range rangeLine, const Sci::Position braces[],
181                                      char bracesMatchStyle, int xHighlight, bool ignoreStyle) {
182  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
183  		const Sci::Position braceOffset = braces[0] - rangeLine.start;
184  		if (braceOffset < numCharsInLine) {
185  			bracePreviousStyles[0] = styles[braceOffset];
186  			styles[braceOffset] = bracesMatchStyle;
187  		}
188  	}
189  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[1])) {
190  		const Sci::Position braceOffset = braces[1] - rangeLine.start;
191  		if (braceOffset < numCharsInLine) {
192  			bracePreviousStyles[1] = styles[braceOffset];
193  			styles[braceOffset] = bracesMatchStyle;
194  		}
195  	}
196  	if ((braces[0] >= rangeLine.start && braces[1] <= rangeLine.end) ||
197  	        (braces[1] >= rangeLine.start && braces[0] <= rangeLine.end)) {
198  		xHighlightGuide = xHighlight;
199  	}
200  }
201  void LineLayout::RestoreBracesHighlight(Range rangeLine, const Sci::Position braces[], bool ignoreStyle) {
202  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
203  		const Sci::Position braceOffset = braces[0] - rangeLine.start;
204  		if (braceOffset < numCharsInLine) {
205  			styles[braceOffset] = bracePreviousStyles[0];
206  		}
207  	}
208  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[1])) {
209  		const Sci::Position braceOffset = braces[1] - rangeLine.start;
210  		if (braceOffset < numCharsInLine) {
211  			styles[braceOffset] = bracePreviousStyles[1];
212  		}
213  	}
214  	xHighlightGuide = 0;
215  }
216  int LineLayout::FindBefore(XYPOSITION x, Range range) const noexcept {
217  	Sci::Position lower = range.start;
218  	Sci::Position upper = range.end;
219  	do {
220  		const Sci::Position middle = (upper + lower + 1) / 2; 	
221  		const XYPOSITION posMiddle = positions[middle];
222  		if (x < posMiddle) {
223  			upper = middle - 1;
224  		} else {
225  			lower = middle;
226  		}
227  	} while (lower < upper);
228  	return static_cast<int>(lower);
229  }
230  int LineLayout::FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const noexcept {
231  	int pos = FindBefore(x, range);
232  	while (pos < range.end) {
233  		if (charPosition) {
234  			if (x < (positions[pos + 1])) {
235  				return pos;
236  			}
237  		} else {
238  			if (x < ((positions[pos] + positions[pos + 1]) / 2)) {
239  				return pos;
240  			}
241  		}
242  		pos++;
243  	}
244  	return static_cast<int>(range.end);
245  }
246  Point LineLayout::PointFromPosition(int posInLine, int lineHeight, PointEnd pe) const noexcept {
247  	Point pt;
248  	if (posInLine > maxLineLength) {
249  		pt.x = positions[maxLineLength] - positions[LineStart(lines)];
250  	}
251  	for (int subLine = 0; subLine < lines; subLine++) {
252  		const Range rangeSubLine = SubLineRange(subLine, Scope::visibleOnly);
253  		if (posInLine >= rangeSubLine.start) {
254  			pt.y = static_cast<XYPOSITION>(subLine*lineHeight);
255  			if (posInLine <= rangeSubLine.end) {
256  				pt.x = positions[posInLine] - positions[rangeSubLine.start];
257  				if (rangeSubLine.start != 0)	
258  					pt.x += wrapIndent;
259  				if (FlagSet(pe, PointEnd::subLineEnd))	
260  					break;
261  			} else if (FlagSet(pe, PointEnd::lineEnd) && (subLine == (lines-1))) {
262  				pt.x = positions[numCharsInLine] - positions[rangeSubLine.start];
263  				if (rangeSubLine.start != 0)	
264  					pt.x += wrapIndent;
265  			}
266  		} else {
267  			break;
268  		}
269  	}
270  	return pt;
271  }
272  XYPOSITION LineLayout::XInLine(Sci::Position index) const noexcept {
273  	if (index <= numCharsInLine) {
274  		return positions[index];
275  	}
276  	return positions[numCharsInLine] + 1.0;
277  }
278  Interval LineLayout::Span(int start, int end) const noexcept {
279  	return { positions[start], positions[end] };
280  }
281  Interval LineLayout::SpanByte(int index) const noexcept {
282  	return Span(index, index+1);
283  }
284  int LineLayout::EndLineStyle() const noexcept {
285  	return styles[numCharsBeforeEOL > 0 ? numCharsBeforeEOL-1 : 0];
286  }
287  void LineLayout::WrapLine(const Document *pdoc, Sci::Position posLineStart, Wrap wrapState, XYPOSITION wrapWidth) {
288  	auto CharacterBoundary = [=](Sci::Position i, Sci::Position moveDir) noexcept -> Sci::Position {
289  		return pdoc->MovePositionOutsideChar(i + posLineStart, moveDir) - posLineStart;
290  	};
291  	lines = 0;
292  	Sci::Position lastLineStart = 0;
293  	XYPOSITION startOffset = wrapWidth;
294  	Sci::Position p = 0;
295  	while (p < numCharsInLine) {
296  		while (p < numCharsInLine && positions[p + 1] < startOffset) {
297  			p++;
298  		}
299  		if (p < numCharsInLine) {
300  			Sci::Position lastGoodBreak = p;
301  			if (p > 0) {
302  				lastGoodBreak = CharacterBoundary(p, -1);
303  			}
304  			if (wrapState != Wrap::Char) {
305  				Sci::Position pos = lastGoodBreak;
306  				while (pos > lastLineStart) {
307  					if (wrapState != Wrap::WhiteSpace && (styles[pos - 1] != styles[pos])) {
308  						break;
309  					}
310  					if (IsBreakSpace(chars[pos - 1]) && !IsBreakSpace(chars[pos])) {
311  						break;
312  					}
313  					pos = CharacterBoundary(pos - 1, -1);
314  				}
315  				if (pos > lastLineStart) {
316  					lastGoodBreak = pos;
317  				}
318  			}
319  			if (lastGoodBreak == lastLineStart) {
320  				if (p > 0) {
321  					lastGoodBreak = CharacterBoundary(p, -1);
322  				}
323  				if (lastGoodBreak == lastLineStart) {
324  					lastGoodBreak = CharacterBoundary(lastGoodBreak + 1, 1);
325  				}
326  			}
327  			lastLineStart = lastGoodBreak;
328  			AddLineStart(lastLineStart);
329  			startOffset = positions[lastLineStart];
330  			startOffset += wrapWidth - wrapIndent;
331  			p = lastLineStart + 1;
332  		}
333  	}
334  	lines++;
335  }
336  ScreenLine::ScreenLine(
337  	const LineLayout *ll_,
338  	int subLine,
339  	const ViewStyle &vs,
340  	XYPOSITION width_,
341  	int tabWidthMinimumPixels_) :
342  	ll(ll_),
343  	start(ll->LineStart(subLine)),
344  	len(ll->LineLength(subLine)),
345  	width(width_),
346  	height(static_cast<float>(vs.lineHeight)),
347  	ctrlCharPadding(vs.ctrlCharPadding),
348  	tabWidth(vs.tabWidth),
349  	tabWidthMinimumPixels(tabWidthMinimumPixels_) {
350  }
351  ScreenLine::~ScreenLine() {
352  }
353  std::string_view ScreenLine::Text() const {
354  	return std::string_view(&ll->chars[start], len);
355  }
356  size_t ScreenLine::Length() const {
357  	return len;
358  }
359  size_t ScreenLine::RepresentationCount() const {
360  	return std::count_if(&ll->bidiData->widthReprs[start],
361  		&ll->bidiData->widthReprs[start + len],
362  		[](XYPOSITION w) noexcept { return w > 0.0f; });
363  }
364  XYPOSITION ScreenLine::Width() const {
365  	return width;
366  }
367  XYPOSITION ScreenLine::Height() const {
368  	return height;
369  }
370  XYPOSITION ScreenLine::TabWidth() const {
371  	return tabWidth;
372  }
373  XYPOSITION ScreenLine::TabWidthMinimumPixels() const {
374  	return static_cast<XYPOSITION>(tabWidthMinimumPixels);
375  }
376  const Font *ScreenLine::FontOfPosition(size_t position) const {
377  	return ll->bidiData->stylesFonts[start + position].get();
378  }
379  XYPOSITION ScreenLine::RepresentationWidth(size_t position) const {
380  	return ll->bidiData->widthReprs[start + position];
381  }
382  XYPOSITION ScreenLine::TabPositionAfter(XYPOSITION xPosition) const {
383  	return (std::floor((xPosition + TabWidthMinimumPixels()) / TabWidth()) + 1) * TabWidth();
384  }
385  bool SignificantLines::LineMayCache(Sci::Line line) const noexcept {
386  	switch (level) {
387  	case LineCache::None:
388  		return false;
389  	case LineCache::Caret:
390  		return line == lineCaret;
391  	case LineCache::Page:
392  		return (std::abs(line - lineCaret) < linesOnScreen) ||
393  			((line >= lineTop) && (line <= (lineTop + linesOnScreen)));
394  	case LineCache::Document:
395  	default:
396  		return true;
397  	}
398  }
399  LineLayoutCache::LineLayoutCache() :
400  	level(LineCache::None),
401  	allInvalidated(false), styleClock(-1) {
402  }
403  LineLayoutCache::~LineLayoutCache() = default;
404  namespace {
405  constexpr size_t AlignUp(size_t value, size_t alignment) noexcept {
406  	return ((value - 1) / alignment + 1) * alignment;
407  }
408  constexpr size_t alignmentLLC = 20;
409  constexpr bool GraphicASCII(char ch) noexcept {
410  	return ch >= ' ' && ch <= '~';
411  }
412  bool AllGraphicASCII(std::string_view text) {
413  	return std::all_of(text.cbegin(), text.cend(), GraphicASCII);
414  }
415  }
416  size_t LineLayoutCache::EntryForLine(Sci::Line line) const noexcept {
417  	switch (level) {
418  	case LineCache::None:
419  		return 0;
420  	case LineCache::Caret:
421  		return 0;
422  	case LineCache::Page:
423  		return 1 + (line % (cache.size() - 1));
424  	case LineCache::Document:
425  		return line;
426  	}
427  	return 0;
428  }
429  void LineLayoutCache::AllocateForLevel(Sci::Line linesOnScreen, Sci::Line linesInDoc) {
430  	size_t lengthForLevel = 0;
431  	if (level == LineCache::Caret) {
432  		lengthForLevel = 1;
433  	} else if (level == LineCache::Page) {
434  		lengthForLevel = AlignUp(linesOnScreen + 1, alignmentLLC);
435  	} else if (level == LineCache::Document) {
436  		lengthForLevel = AlignUp(linesInDoc, alignmentLLC);
437  	}
438  	if (lengthForLevel != cache.size()) {
439  		allInvalidated = false;
440  		cache.resize(lengthForLevel);
441  		if (level == LineCache::Page) {
442  			for (size_t i = 1; i < cache.size();) {
443  				size_t increment = 1;
444  				if (cache[i]) {
445  					const size_t posForLine = EntryForLine(cache[i]->LineNumber());
446  					if (posForLine != i) {
447  						if (cache[posForLine]) {
448  							if (EntryForLine(cache[posForLine]->LineNumber()) == posForLine) {
449  								cache[i].reset();	
450  							} else {
451  								std::swap(cache[i], cache[posForLine]);
452  								increment = 0;
453  							}
454  						} else {
455  							cache[posForLine] = std::move(cache[i]);
456  						}
457  					}
458  				}
459  				i += increment;
460  			}
461  #ifdef CHECK_LLC
462  			for (size_t i = 1; i < cache.size(); i++) {
463  				if (cache[i]) {
464  					PLATFORM_ASSERT(EntryForLine(cache[i]->LineNumber()) == i);
465  				}
466  			}
467  #endif
468  		}
469  	}
470  	PLATFORM_ASSERT(cache.size() == lengthForLevel);
471  }
472  void LineLayoutCache::Deallocate() noexcept {
473  	cache.clear();
474  }
475  void LineLayoutCache::Invalidate(LineLayout::ValidLevel validity_) noexcept {
476  	if (!cache.empty() && !allInvalidated) {
477  		for (const std::shared_ptr<LineLayout> &ll : cache) {
478  			if (ll) {
479  				ll->Invalidate(validity_);
480  			}
481  		}
482  		if (validity_ == LineLayout::ValidLevel::invalid) {
483  			allInvalidated = true;
484  		}
485  	}
486  }
487  void LineLayoutCache::SetLevel(LineCache level_) noexcept {
488  	if (level != level_) {
489  		level = level_;
490  		allInvalidated = false;
491  		cache.clear();
492  	}
493  }
494  std::shared_ptr<LineLayout> LineLayoutCache::Retrieve(Sci::Line lineNumber, Sci::Line lineCaret, int maxChars, int styleClock_,
495                                        Sci::Line linesOnScreen, Sci::Line linesInDoc) {
496  	AllocateForLevel(linesOnScreen, linesInDoc);
497  	if (styleClock != styleClock_) {
498  		Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
499  		styleClock = styleClock_;
500  	}
501  	allInvalidated = false;
502  	size_t pos = 0;
503  	if (level == LineCache::Page) {
504  		if (!(cache[0] && (cache[0]->LineNumber() == lineNumber))) {
505  			const size_t posForLine = EntryForLine(lineNumber);
506  			if (lineNumber == lineCaret) {
507  				if (cache[0]) {
508  					const size_t posNewForEntry0 = EntryForLine(cache[0]->LineNumber());
509  					if (posForLine == posNewForEntry0) {
510  						std::swap(cache[0], cache[posNewForEntry0]);
511  					} else {
512  						cache[posNewForEntry0] = std::move(cache[0]);
513  					}
514  				}
515  				if (cache[posForLine] && (cache[posForLine]->LineNumber() == lineNumber)) {
516  					cache[0] = std::move(cache[posForLine]);
517  				}
518  			} else {
519  				pos = posForLine;
520  			}
521  		}
522  	} else if (level == LineCache::Document) {
523  		pos = lineNumber;
524  	}
525  	if (pos < cache.size()) {
526  		if (cache[pos] && !cache[pos]->CanHold(lineNumber, maxChars)) {
527  			cache[pos].reset();
528  		}
529  		if (!cache[pos]) {
530  			cache[pos] = std::make_shared<LineLayout>(lineNumber, maxChars);
531  		}
532  #ifdef CHECK_LLC
533  		std::vector<bool> linesInCache(linesInDoc);
534  		for (const auto &entry : cache) {
535  			if (entry) {
536  				PLATFORM_ASSERT(!linesInCache[entry->LineNumber()]);
537  				linesInCache[entry->LineNumber()] = true;
538  			}
539  		}
540  #endif
541  		return cache[pos];
542  	}
543  	return std::make_shared<LineLayout>(lineNumber, maxChars);
544  }
545  namespace {
546  constexpr unsigned int KeyFromString(std::string_view charBytes) noexcept {
547  	PLATFORM_ASSERT(charBytes.length() <= 4);
548  	unsigned int k=0;
549  	for (const unsigned char uc : charBytes) {
550  		k = k * 0x100 + uc;
551  	}
552  	return k;
553  }
554  constexpr unsigned int representationKeyCrLf = KeyFromString("\r\n");
555  const char *const repsC0[] = {
556  	"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
557  	"BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI",
558  	"DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
559  	"CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"
560  };
561  const char *const repsC1[] = {
562  	"PAD", "HOP", "BPH", "NBH", "IND", "NEL", "SSA", "ESA",
563  	"HTS", "HTJ", "VTS", "PLD", "PLU", "RI", "SS2", "SS3",
564  	"DCS", "PU1", "PU2", "STS", "CCH", "MW", "SPA", "EPA",
565  	"SOS", "SGCI", "SCI", "CSI", "ST", "OSC", "PM", "APC"
566  };
567  }
568  namespace Scintilla::Internal {
569  const char *ControlCharacterString(unsigned char ch) noexcept {
570  	if (ch < std::size(repsC0)) {
571  		return repsC0[ch];
572  	} else {
573  		return "BAD";
574  	}
575  }
576  void Hexits(char *hexits, int ch) noexcept {
577  	hexits[0] = 'x';
578  	hexits[1] = "0123456789ABCDEF"[ch / 0x10];
579  	hexits[2] = "0123456789ABCDEF"[ch % 0x10];
580  	hexits[3] = 0;
581  }
582  }
583  void SpecialRepresentations::SetRepresentation(std::string_view charBytes, std::string_view value) {
584  	if ((charBytes.length() <= 4) && (value.length() <= Representation::maxLength)) {
585  		const unsigned int key = KeyFromString(charBytes);
586  		const bool inserted = mapReprs.insert_or_assign(key, Representation(value)).second;
587  		if (inserted) {
588  			const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
589  			startByteHasReprs[ucStart]++;
590  			if (key > maxKey) {
591  				maxKey = key;
592  			}
593  			if (key == representationKeyCrLf) {
594  				crlf = true;
595  			}
596  		}
597  	}
598  }
599  void SpecialRepresentations::SetRepresentationAppearance(std::string_view charBytes, RepresentationAppearance appearance) {
600  	if (charBytes.length() <= 4) {
601  		const unsigned int key = KeyFromString(charBytes);
602  		const MapRepresentation::iterator it = mapReprs.find(key);
603  		if (it == mapReprs.end()) {
604  			return;
605  		}
606  		it->second.appearance = appearance;
607  	}
608  }
609  void SpecialRepresentations::SetRepresentationColour(std::string_view charBytes, ColourRGBA colour) {
610  	if (charBytes.length() <= 4) {
611  		const unsigned int key = KeyFromString(charBytes);
612  		const MapRepresentation::iterator it = mapReprs.find(key);
613  		if (it == mapReprs.end()) {
614  			return;
615  		}
616  		it->second.appearance = it->second.appearance | RepresentationAppearance::Colour;
617  		it->second.colour = colour;
618  	}
619  }
620  void SpecialRepresentations::ClearRepresentation(std::string_view charBytes) {
621  	if (charBytes.length() <= 4) {
622  		const unsigned int key = KeyFromString(charBytes);
623  		const MapRepresentation::iterator it = mapReprs.find(key);
624  		if (it != mapReprs.end()) {
625  			mapReprs.erase(it);
626  			const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
627  			startByteHasReprs[ucStart]--;
628  			if (key == maxKey && startByteHasReprs[ucStart] == 0) {
629  				maxKey = mapReprs.empty() ? 0 : mapReprs.crbegin()->first;
630  			}
631  			if (key == representationKeyCrLf) {
632  				crlf = false;
633  			}
634  		}
635  	}
636  }
637  const Representation *SpecialRepresentations::GetRepresentation(std::string_view charBytes) const {
638  	const unsigned int key = KeyFromString(charBytes);
639  	if (key > maxKey) {
640  		return nullptr;
641  	}
642  	const MapRepresentation::const_iterator it = mapReprs.find(key);
643  	if (it != mapReprs.end()) {
644  		return &(it->second);
645  	}
646  	return nullptr;
647  }
648  const Representation *SpecialRepresentations::RepresentationFromCharacter(std::string_view charBytes) const {
649  	if (charBytes.length() <= 4) {
650  		const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
651  		if (!startByteHasReprs[ucStart])
652  			return nullptr;
653  		return GetRepresentation(charBytes);
654  	}
655  	return nullptr;
656  }
657  void SpecialRepresentations::Clear() {
658  	mapReprs.clear();
659  	constexpr unsigned short none = 0;
660  	std::fill(startByteHasReprs, std::end(startByteHasReprs), none);
661  	maxKey = 0;
662  	crlf = false;
663  }
664  void SpecialRepresentations::SetDefaultRepresentations(int dbcsCodePage) {
665  	Clear();
666  	for (size_t j = 0; j < std::size(repsC0); j++) {
667  		const char c[2] = { static_cast<char>(j), 0 };
668  		SetRepresentation(std::string_view(c, 1), repsC0[j]);
669  	}
670  	SetRepresentation("\x7f", "DEL");
671  	if (CpUtf8 == dbcsCodePage) {
672  		for (size_t j = 0; j < std::size(repsC1); j++) {
673  			const char c1[3] = { '\xc2',  static_cast<char>(0x80 + j), 0 };
674  			SetRepresentation(c1, repsC1[j]);
675  		}
676  		SetRepresentation("\xe2\x80\xa8", "LS");
677  		SetRepresentation("\xe2\x80\xa9", "PS");
678  	}
679  	if (dbcsCodePage) {
680  		for (int k = 0x80; k < 0x100; k++) {
681  			if ((CpUtf8 == dbcsCodePage) || !IsDBCSValidSingleByte(dbcsCodePage, k)) {
682  				const char hiByte[2] = { static_cast<char>(k), 0 };
683  				char hexits[4];
684  				Hexits(hexits, k);
685  				SetRepresentation(hiByte, hexits);
686  			}
687  		}
688  	}
689  }
690  void BreakFinder::Insert(Sci::Position val) {
691  	const int posInLine = static_cast<int>(val);
692  	if (posInLine > nextBreak) {
693  		const std::vector<int>::iterator it = std::lower_bound(selAndEdge.begin(), selAndEdge.end(), posInLine);
694  		if (it == selAndEdge.end()) {
695  			selAndEdge.push_back(posInLine);
696  		} else if (*it != posInLine) {
697  			selAndEdge.insert(it, 1, posInLine);
698  		}
699  	}
700  }
701  BreakFinder::BreakFinder(const LineLayout *ll_, const Selection *psel, Range lineRange_, Sci::Position posLineStart,
702  	XYPOSITION xStart, BreakFor breakFor, const Document *pdoc_, const SpecialRepresentations *preprs_, const ViewStyle *pvsDraw) :
703  	ll(ll_),
704  	lineRange(lineRange_),
705  	nextBreak(static_cast<int>(lineRange_.start)),
706  	saeCurrentPos(0),
707  	saeNext(0),
708  	subBreak(-1),
709  	pdoc(pdoc_),
710  	encodingFamily(pdoc_->CodePageFamily()),
711  	preprs(preprs_) {
712  	if (xStart > 0.0f)
713  		nextBreak = ll->FindBefore(xStart, lineRange);
714  	while ((nextBreak > lineRange.start) && (ll->styles[nextBreak] == ll->styles[nextBreak - 1])) {
715  		nextBreak--;
716  	}
717  	if (FlagSet(breakFor, BreakFor::Selection)) {
718  		const SelectionPosition posStart(posLineStart);
719  		const SelectionPosition posEnd(posLineStart + lineRange.end);
720  		const SelectionSegment segmentLine(posStart, posEnd);
721  		for (size_t r=0; r<psel->Count(); r++) {
722  			const SelectionSegment portion = psel->Range(r).Intersect(segmentLine);
723  			if (!(portion.start == portion.end)) {
724  				if (portion.start.IsValid())
725  					Insert(portion.start.Position() - posLineStart);
726  				if (portion.end.IsValid())
727  					Insert(portion.end.Position() - posLineStart);
728  			}
729  		}
730  		if (FlagSet(pvsDraw->caret.style, CaretStyle::Curses) && !psel->RangeMain().Empty()) {
731  			const Sci::Position caretPos = psel->RangeMain().caret.Position();
732  			const Sci::Position anchorPos = psel->RangeMain().anchor.Position();
733  			if (caretPos < anchorPos) {
734  				const Sci::Position nextPos = pdoc->MovePositionOutsideChar(caretPos + 1, 1);
735  				Insert(nextPos - posLineStart);
736  			} else if (caretPos > anchorPos && pvsDraw->DrawCaretInsideSelection(false, false)) {
737  				const Sci::Position prevPos = pdoc->MovePositionOutsideChar(caretPos - 1, -1);
738  				if (prevPos > anchorPos)
739  					Insert(prevPos - posLineStart);
740  			}
741  		}
742  	}
743  	if (FlagSet(breakFor, BreakFor::Foreground) && pvsDraw->indicatorsSetFore) {
744  		for (const IDecoration *deco : pdoc->decorations->View()) {
745  			if (pvsDraw->indicators[deco->Indicator()].OverridesTextFore()) {
746  				Sci::Position startPos = deco->EndRun(posLineStart);
747  				while (startPos < (posLineStart + lineRange.end)) {
748  					Insert(startPos - posLineStart);
749  					startPos = deco->EndRun(startPos);
750  				}
751  			}
752  		}
753  	}
754  	Insert(ll->edgeColumn);
755  	Insert(lineRange.end);
756  	saeNext = (!selAndEdge.empty()) ? selAndEdge[0] : -1;
757  }
758  BreakFinder::~BreakFinder() noexcept = default;
759  TextSegment BreakFinder::Next() {
760  	if (subBreak < 0) {
761  		const int prev = nextBreak;
762  		const Representation *repr = nullptr;
763  		while (nextBreak < lineRange.end) {
764  			int charWidth = 1;
765  			const char * const chars = &ll->chars[nextBreak];
766  			const unsigned char ch = chars[0];
767  			bool characterStyleConsistent = true;	
768  			if (!UTF8IsAscii(ch) && encodingFamily != EncodingFamily::eightBit) {
769  				if (encodingFamily == EncodingFamily::unicode) {
770  					charWidth = UTF8DrawBytes(chars, lineRange.end - nextBreak);
771  				} else {
772  					charWidth = pdoc->DBCSDrawBytes(std::string_view(chars, lineRange.end - nextBreak));
773  				}
774  				for (int trail = 1; trail < charWidth; trail++) {
775  					if (ll->styles[nextBreak] != ll->styles[nextBreak + trail]) {
776  						characterStyleConsistent = false;
777  					}
778  				}
779  			}
780  			if (!characterStyleConsistent) {
781  				if (nextBreak == prev) {
782  					charWidth = 1;
783  				} else {
784  					break;
785  				}
786  			}
787  			repr = nullptr;
788  			if (preprs->MayContain(ch)) {
789  				if (ch == '\r' && preprs->ContainsCrLf() && chars[1] == '\n') {
790  					charWidth = 2;
791  				}
792  				repr = preprs->GetRepresentation(std::string_view(chars, charWidth));
793  			}
794  			if (((nextBreak > 0) && (ll->styles[nextBreak] != ll->styles[nextBreak - 1])) ||
795  					repr ||
796  					(nextBreak == saeNext)) {
797  				while ((nextBreak >= saeNext) && (saeNext < lineRange.end)) {
798  					saeCurrentPos++;
799  					saeNext = static_cast<int>((saeCurrentPos < selAndEdge.size()) ? selAndEdge[saeCurrentPos] : lineRange.end);
800  				}
801  				if ((nextBreak > prev) || repr) {
802  					if (nextBreak == prev) {
803  						nextBreak += charWidth;
804  					} else {
805  						repr = nullptr;	
806  					}
807  					break;
808  				}
809  			}
810  			nextBreak += charWidth;
811  		}
812  		const int lengthSegment = nextBreak - prev;
813  		if (lengthSegment < lengthStartSubdivision) {
814  			return TextSegment(prev, lengthSegment, repr);
815  		}
816  		subBreak = prev;
817  	}
818  	const int startSegment = subBreak;
819  	const int remaining = nextBreak - startSegment;
820  	int lengthSegment = remaining;
821  	if (lengthSegment > lengthEachSubdivision) {
822  		lengthSegment = static_cast<int>(pdoc->SafeSegment(std::string_view(&ll->chars[startSegment], lengthEachSubdivision)));
823  	}
824  	if (lengthSegment < remaining) {
825  		subBreak += lengthSegment;
826  	} else {
827  		subBreak = -1;
828  	}
829  	return TextSegment(startSegment, lengthSegment);
830  }
831  bool BreakFinder::More() const noexcept {
832  	return (subBreak >= 0) || (nextBreak < lineRange.end);
833  }
834  class PositionCacheEntry {
835  	uint16_t styleNumber;
836  	uint16_t len;
837  	uint16_t clock;
838  	bool unicode;
839  	std::unique_ptr<XYPOSITION[]> positions;
840  public:
841  	PositionCacheEntry() noexcept;
842  	PositionCacheEntry(const PositionCacheEntry &);
843  	PositionCacheEntry(PositionCacheEntry &&) noexcept = default;
844  	void operator=(const PositionCacheEntry &) = delete;
845  	void operator=(PositionCacheEntry &&) = delete;
846  	~PositionCacheEntry();
847  	void Set(unsigned int styleNumber_, bool unicode_, std::string_view sv, const XYPOSITION *positions_, uint16_t clock_);
848  	void Clear() noexcept;
849  	bool Retrieve(unsigned int styleNumber_, bool unicode_, std::string_view sv, XYPOSITION *positions_) const noexcept;
850  	static size_t Hash(unsigned int styleNumber_, bool unicode_, std::string_view sv) noexcept;
851  	bool NewerThan(const PositionCacheEntry &other) const noexcept;
852  	void ResetClock() noexcept;
853  };
854  class PositionCache : public IPositionCache {
855  	std::vector<PositionCacheEntry> pces;
856  	std::mutex mutex;
857  	uint16_t clock;
858  	bool allClear;
859  public:
860  	PositionCache();
861  	PositionCache(const PositionCache &) = delete;
862  	PositionCache(PositionCache &&) = delete;
863  	void operator=(const PositionCache &) = delete;
864  	void operator=(PositionCache &&) = delete;
865  	~PositionCache() override = default;
866  	void Clear() noexcept override;
867  	void SetSize(size_t size_) override;
868  	size_t GetSize() const noexcept override;
869  	void MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
870  		bool unicode, std::string_view sv, XYPOSITION *positions, bool needsLocking) override;
871  };
872  PositionCacheEntry::PositionCacheEntry() noexcept :
873  	styleNumber(0), len(0), clock(0), unicode(false) {
874  }
875  PositionCacheEntry::PositionCacheEntry(const PositionCacheEntry &other) :
876  	styleNumber(other.styleNumber), len(other.len), clock(other.clock), unicode(other.unicode) {
877  	if (other.positions) {
878  		const size_t lenData = len + (len / sizeof(XYPOSITION)) + 1;
879  		positions = std::make_unique<XYPOSITION[]>(lenData);
880  		memcpy(positions.get(), other.positions.get(), lenData * sizeof(XYPOSITION));
881  	}
882  }
883  void PositionCacheEntry::Set(unsigned int styleNumber_, bool unicode_, std::string_view sv,
884  	const XYPOSITION *positions_, uint16_t clock_) {
885  	Clear();
886  	styleNumber = static_cast<uint16_t>(styleNumber_);
887  	len = static_cast<uint16_t>(sv.length());
888  	clock = clock_;
889  	unicode = unicode_;
890  	if (sv.data() && positions_) {
891  		positions = std::make_unique<XYPOSITION[]>(len + (len / sizeof(XYPOSITION)) + 1);
892  		for (unsigned int i=0; i<len; i++) {
893  			positions[i] = positions_[i];
894  		}
895  		memcpy(&positions[len], sv.data(), sv.length());
896  	}
897  }
898  PositionCacheEntry::~PositionCacheEntry() {
899  	Clear();
900  }
901  void PositionCacheEntry::Clear() noexcept {
902  	positions.reset();
903  	styleNumber = 0;
904  	len = 0;
905  	clock = 0;
906  }
907  bool PositionCacheEntry::Retrieve(unsigned int styleNumber_, bool unicode_, std::string_view sv, XYPOSITION *positions_) const noexcept {
908  	if ((styleNumber == styleNumber_) && (unicode == unicode_) && (len == sv.length()) &&
909  		(memcmp(&positions[len], sv.data(), sv.length())== 0)) {
910  		for (unsigned int i=0; i<len; i++) {
911  			positions_[i] = positions[i];
912  		}
913  		return true;
914  	} else {
915  		return false;
916  	}
917  }
918  size_t PositionCacheEntry::Hash(unsigned int styleNumber_, bool unicode_, std::string_view sv) noexcept {
919  	const size_t h1 = std::hash<std::string_view>{}(sv);
920  	const size_t h2 = std::hash<unsigned int>{}(styleNumber_);
921  	return h1 ^ (h2 << 1) ^ static_cast<size_t>(unicode_);
922  }
923  bool PositionCacheEntry::NewerThan(const PositionCacheEntry &other) const noexcept {
924  	return clock > other.clock;
925  }
926  void PositionCacheEntry::ResetClock() noexcept {
927  	if (clock > 0) {
928  		clock = 1;
929  	}
930  }
931  PositionCache::PositionCache() {
932  	clock = 1;
933  	pces.resize(0x400);
934  	allClear = true;
935  }
936  void PositionCache::Clear() noexcept {
937  	if (!allClear) {
938  		for (PositionCacheEntry &pce : pces) {
939  			pce.Clear();
940  		}
941  	}
942  	clock = 1;
943  	allClear = true;
944  }
945  void PositionCache::SetSize(size_t size_) {
946  	Clear();
947  	pces.resize(size_);
948  }
949  size_t PositionCache::GetSize() const noexcept {
950  	return pces.size();
951  }
952  void PositionCache::MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
953  	bool unicode, std::string_view sv, XYPOSITION *positions, bool needsLocking) {
954  	const Style &style = vstyle.styles[styleNumber];
955  	if (style.monospaceASCII) {
956  		if (AllGraphicASCII(sv)) {
957  			const XYPOSITION monospaceCharacterWidth = style.monospaceCharacterWidth;
958  			for (size_t i = 0; i < sv.length(); i++) {
959  				positions[i] = monospaceCharacterWidth * (i+1);
960  			}
961  			return;
962  		}
963  	}
964  	size_t probe = pces.size();	
965  	if ((!pces.empty()) && (sv.length() < 30)) {
966  		const size_t hashValue = PositionCacheEntry::Hash(styleNumber, unicode, sv);
967  		probe = hashValue % pces.size();
968  		std::unique_lock<std::mutex> guard(mutex, std::defer_lock);
969  		if (needsLocking) {
970  			guard.lock();
971  		}
972  		if (pces[probe].Retrieve(styleNumber, unicode, sv, positions)) {
973  			return;
974  		}
975  		const size_t probe2 = (hashValue * 37) % pces.size();
976  		if (pces[probe2].Retrieve(styleNumber, unicode, sv, positions)) {
977  			return;
978  		}
979  		if (pces[probe].NewerThan(pces[probe2])) {
980  			probe = probe2;
981  		}
982  	}
983  	const Font *fontStyle = style.font.get();
984  	if (unicode) {
985  		surface->MeasureWidthsUTF8(fontStyle, sv, positions);
986  	} else {
987  		surface->MeasureWidths(fontStyle, sv, positions);
988  	}
989  	if (probe < pces.size()) {
990  		std::unique_lock<std::mutex> guard(mutex, std::defer_lock);
991  		if (needsLocking) {
992  			guard.lock();
993  		}
994  		clock++;
995  		if (clock > 60000) {
996  			for (PositionCacheEntry &pce : pces) {
997  				pce.ResetClock();
998  			}
999  			clock = 2;
1000  		}
1001  		allClear = false;
1002  		pces[probe].Set(styleNumber, unicode, sv, positions, clock);
1003  	}
1004  }
1005  std::unique_ptr<IPositionCache> Scintilla::Internal::CreatePositionCache() {
1006  	return std::make_unique<PositionCache>();
1007  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PositionCache.cxx</div>
                </div>
                <div class="column column_space"><pre><code>776  	Redraw();
777  }
778  void Editor::HorizontalScrollTo(int xPos) {
779  	if (xPos < 0)
</pre></code></div>
                <div class="column column_space"><pre><code>70  	Free();
71  }
72  void LineLayout::Resize(int maxLineLength_) {
73  	if (maxLineLength_ > maxLineLength) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    