
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-strip_test.cc</h3>
            <pre><code>1  #include "absl/strings/strip.h"
2  #include <cassert>
3  #include <cstdio>
4  #include <cstring>
5  #include "gmock/gmock.h"
6  #include "gtest/gtest.h"
7  #include "absl/strings/string_view.h"
8  namespace {
9  TEST(Strip, ConsumePrefixOneChar) {
10    absl::string_view input("abc");
11    EXPECT_TRUE(absl::ConsumePrefix(&input, "a"));
12    EXPECT_EQ(input, "bc");
13    EXPECT_FALSE(absl::ConsumePrefix(&input, "x"));
14    EXPECT_EQ(input, "bc");
15    EXPECT_TRUE(absl::ConsumePrefix(&input, "b"));
16    EXPECT_EQ(input, "c");
17    EXPECT_TRUE(absl::ConsumePrefix(&input, "c"));
18    EXPECT_EQ(input, "");
19    EXPECT_FALSE(absl::ConsumePrefix(&input, "a"));
20    EXPECT_EQ(input, "");
21  }
22  TEST(Strip, ConsumePrefix) {
23    absl::string_view input("abcdef");
24    EXPECT_FALSE(absl::ConsumePrefix(&input, "abcdefg"));
25    EXPECT_EQ(input, "abcdef");
26    EXPECT_FALSE(absl::ConsumePrefix(&input, "abce"));
27    EXPECT_EQ(input, "abcdef");
28    EXPECT_TRUE(absl::ConsumePrefix(&input, ""));
29    EXPECT_EQ(input, "abcdef");
30    EXPECT_FALSE(absl::ConsumePrefix(&input, "abcdeg"));
31    EXPECT_EQ(input, "abcdef");
32    EXPECT_TRUE(absl::ConsumePrefix(&input, "abcdef"));
33    EXPECT_EQ(input, "");
34    input = "abcdef";
35    EXPECT_TRUE(absl::ConsumePrefix(&input, "abcde"));
36    EXPECT_EQ(input, "f");
37  }
38  TEST(Strip, ConsumeSuffix) {
39    absl::string_view input("abcdef");
40    EXPECT_FALSE(absl::ConsumeSuffix(&input, "abcdefg"));
41    EXPECT_EQ(input, "abcdef");
42    EXPECT_TRUE(absl::ConsumeSuffix(&input, ""));
43    EXPECT_EQ(input, "abcdef");
44    EXPECT_TRUE(absl::ConsumeSuffix(&input, "def"));
45    EXPECT_EQ(input, "abc");
46    input = "abcdef";
47    EXPECT_FALSE(absl::ConsumeSuffix(&input, "abcdeg"));
48    EXPECT_EQ(input, "abcdef");
49    EXPECT_TRUE(absl::ConsumeSuffix(&input, "f"));
50    EXPECT_EQ(input, "abcde");
51    EXPECT_TRUE(absl::ConsumeSuffix(&input, "abcde"));
52    EXPECT_EQ(input, "");
53  }
54  TEST(Strip, StripPrefix) {
55    const absl::string_view null_str;
56    EXPECT_EQ(absl::StripPrefix("foobar", "foo"), "bar");
57    EXPECT_EQ(absl::StripPrefix("foobar", ""), "foobar");
58    EXPECT_EQ(absl::StripPrefix("foobar", null_str), "foobar");
59    EXPECT_EQ(absl::StripPrefix("foobar", "foobar"), "");
60    EXPECT_EQ(absl::StripPrefix("foobar", "bar"), "foobar");
61    EXPECT_EQ(absl::StripPrefix("foobar", "foobarr"), "foobar");
62    EXPECT_EQ(absl::StripPrefix("", ""), "");
63  }
64  TEST(Strip, StripSuffix) {
65    const absl::string_view null_str;
66    EXPECT_EQ(absl::StripSuffix("foobar", "bar"), "foo");
67    EXPECT_EQ(absl::StripSuffix("foobar", ""), "foobar");
68    EXPECT_EQ(absl::StripSuffix("foobar", null_str), "foobar");
69    EXPECT_EQ(absl::StripSuffix("foobar", "foobar"), "");
70    EXPECT_EQ(absl::StripSuffix("foobar", "foo"), "foobar");
71    EXPECT_EQ(absl::StripSuffix("foobar", "ffoobar"), "foobar");
72    EXPECT_EQ(absl::StripSuffix("", ""), "");
73  }
74  TEST(Strip, RemoveExtraAsciiWhitespace) {
75    const char* inputs[] = {
76        "No extra space",
77        "  Leading whitespace",
<span onclick='openModal()' class='match'>78        "Trailing whitespace  ",
79        "  Leading and trailing  ",
80        " Whitespace \t  in\v   middle  ",
81        "'Eeeeep!  \n Newlines!\n",
82        "nospaces",
83    };
84    const char* outputs[] = {
85        "No extra space",
86        "Leading whitespace",
</span>87        "Trailing whitespace",
88        "Leading and trailing",
89        "Whitespace in middle",
90        "'Eeeeep! Newlines!",
91        "nospaces",
92    };
93    int NUM_TESTS = 7;
94    for (int i = 0; i < NUM_TESTS; i++) {
95      std::string s(inputs[i]);
96      absl::RemoveExtraAsciiWhitespace(&s);
97      EXPECT_STREQ(outputs[i], s.c_str());
98    }
99    std::string zero_string = "";
100    assert(zero_string.empty());
101    absl::RemoveExtraAsciiWhitespace(&zero_string);
102    EXPECT_EQ(zero_string.size(), 0);
103    EXPECT_TRUE(zero_string.empty());
104  }
105  TEST(Strip, StripTrailingAsciiWhitespace) {
106    std::string test = "foo  ";
107    absl::StripTrailingAsciiWhitespace(&test);
108    EXPECT_EQ(test, "foo");
109    test = "   ";
110    absl::StripTrailingAsciiWhitespace(&test);
111    EXPECT_EQ(test, "");
112    test = "";
113    absl::StripTrailingAsciiWhitespace(&test);
114    EXPECT_EQ(test, "");
115    test = " abc\t";
116    absl::StripTrailingAsciiWhitespace(&test);
117    EXPECT_EQ(test, " abc");
118  }
119  TEST(String, StripLeadingAsciiWhitespace) {
120    absl::string_view orig = "\t  \n\f\r\n\vfoo";
121    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace(orig));
122    orig = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
123    EXPECT_EQ(absl::string_view(), absl::StripLeadingAsciiWhitespace(orig));
124  }
125  TEST(Strip, StripAsciiWhitespace) {
126    std::string test2 = "\t  \f\r\n\vfoo \t\f\r\v\n";
127    absl::StripAsciiWhitespace(&test2);
128    EXPECT_EQ(test2, "foo");
129    std::string test3 = "bar";
130    absl::StripAsciiWhitespace(&test3);
131    EXPECT_EQ(test3, "bar");
132    std::string test4 = "\t  \f\r\n\vfoo";
133    absl::StripAsciiWhitespace(&test4);
134    EXPECT_EQ(test4, "foo");
135    std::string test5 = "foo \t\f\r\v\n";
136    absl::StripAsciiWhitespace(&test5);
137    EXPECT_EQ(test5, "foo");
138    absl::string_view test6("\t  \f\r\n\vfoo \t\f\r\v\n");
139    test6 = absl::StripAsciiWhitespace(test6);
140    EXPECT_EQ(test6, "foo");
141    test6 = absl::StripAsciiWhitespace(test6);
142    EXPECT_EQ(test6, "foo");  
143  }
144  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-parse_test.cc</h3>
            <pre><code>1  #include "absl/flags/parse.h"
2  #include <stdlib.h>
3  #include <fstream>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/internal/scoped_set_env.h"
10  #include "absl/flags/flag.h"
11  #include "absl/flags/internal/parse.h"
12  #include "absl/flags/internal/usage.h"
13  #include "absl/flags/reflection.h"
14  #include "absl/log/log.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  #include "absl/strings/substitute.h"
18  #include "absl/types/span.h"
19  #ifdef _WIN32
20  #include <windows.h>
21  #endif
22  #define FLAG_MULT(x) F3(x)
23  #define TEST_FLAG_HEADER FLAG_HEADER_
24  #define F(name) ABSL_FLAG(int, name, 0, "");
25  #define F1(name) \
26    F(name##1);    \
27    F(name##2);    \
28    F(name##3);    \
29    F(name##4);    \
30    F(name##5);
31  #define F2(name) \
32    F1(name##1);   \
33    F1(name##2);   \
34    F1(name##3);   \
35    F1(name##4);   \
36    F1(name##5);
37  #define F3(name) \
38    F2(name##1);   \
39    F2(name##2);   \
40    F2(name##3);   \
41    F2(name##4);   \
42    F2(name##5);
43  FLAG_MULT(TEST_FLAG_HEADER)
44  namespace {
45  using absl::base_internal::ScopedSetEnv;
46  struct UDT {
47    UDT() = default;
48    UDT(const UDT&) = default;
49    UDT& operator=(const UDT&) = default;
50    UDT(int v) : value(v) {}  
51    int value;
52  };
53  bool AbslParseFlag(absl::string_view in, UDT* udt, std::string* err) {
54    if (in == "A") {
55      udt->value = 1;
56      return true;
57    }
58    if (in == "AAA") {
59      udt->value = 10;
60      return true;
61    }
62    *err = "Use values A, AAA instead";
63    return false;
64  }
65  std::string AbslUnparseFlag(const UDT& udt) {
66    return udt.value == 1 ? "A" : "AAA";
67  }
68  std::string GetTestTmpDirEnvVar(const char* const env_var_name) {
69  #ifdef _WIN32
70    char buf[MAX_PATH];
71    auto get_res = GetEnvironmentVariableA(env_var_name, buf, sizeof(buf));
72    if (get_res >= sizeof(buf) || get_res == 0) {
73      return "";
74    }
75    return std::string(buf, get_res);
76  #else
77    const char* val = ::getenv(env_var_name);
78    if (val == nullptr) {
79      return "";
80    }
81    return val;
82  #endif
83  }
84  const std::string& GetTestTempDir() {
85    static std::string* temp_dir_name = []() -> std::string* {
86      std::string* res = new std::string(GetTestTmpDirEnvVar("TEST_TMPDIR"));
87      if (res->empty()) {
88        *res = GetTestTmpDirEnvVar("TMPDIR");
89      }
90      if (res->empty()) {
91  #ifdef _WIN32
92        char temp_path_buffer[MAX_PATH];
93        auto len = GetTempPathA(MAX_PATH, temp_path_buffer);
94        if (len < MAX_PATH && len != 0) {
95          std::string temp_dir_name = temp_path_buffer;
96          if (!absl::EndsWith(temp_dir_name, "\\")) {
97            temp_dir_name.push_back('\\');
98          }
99          absl::StrAppend(&temp_dir_name, "parse_test.", GetCurrentProcessId());
100          if (CreateDirectoryA(temp_dir_name.c_str(), nullptr)) {
101            *res = temp_dir_name;
102          }
103        }
104  #else
105        char temp_dir_template[] = "/tmp/parse_test.XXXXXX";
106        if (auto* unique_name = ::mkdtemp(temp_dir_template)) {
107          *res = unique_name;
108        }
109  #endif
110      }
111      if (res->empty()) {
112        LOG(FATAL) << "Failed to make temporary directory for data files";
113      }
114  #ifdef _WIN32
115      *res += "\\";
116  #else
117      *res += "/";
118  #endif
119      return res;
120    }();
121    return *temp_dir_name;
122  }
123  struct FlagfileData {
124    const absl::string_view file_name;
125    const absl::Span<const char* const> file_lines;
126  };
127  constexpr const char* const ff1_data[] = {
128      "# comment    ",
129      "  # comment  ",
130      "",
131      "     ",
132      "--int_flag=-1",
133      "  --string_flag=q2w2  ",
134      "  ##   ",
135      "  --double_flag=0.1",
136      "--bool_flag=Y  "
137  };
138  constexpr const char* const ff2_data[] = {
139      "# Setting legacy flag",
140      "--legacy_int=1111",
141      "--legacy_bool",
142      "--nobool_flag",
143      "--legacy_str=aqsw",
144      "--int_flag=100",
145      "   ## ============="
146  };
147  const char* GetFlagfileFlag(const std::vector<FlagfileData>& ffd,
148                              std::string& flagfile_flag) {
149    flagfile_flag = "--flagfile=";
150    absl::string_view separator;
151    for (const auto& flagfile_data : ffd) {
152      std::string flagfile_name =
153          absl::StrCat(GetTestTempDir(), flagfile_data.file_name);
154      std::ofstream flagfile_out(flagfile_name);
155      for (auto line : flagfile_data.file_lines) {
156        flagfile_out << absl::Substitute(line, GetTestTempDir()) << "\n";
157      }
158      absl::StrAppend(&flagfile_flag, separator, flagfile_name);
159      separator = ",";
160    }
161    return flagfile_flag.c_str();
162  }
163  }  
164  ABSL_FLAG(int, int_flag, 1, "");
165  ABSL_FLAG(double, double_flag, 1.1, "");
166  ABSL_FLAG(std::string, string_flag, "a", "");
167  ABSL_FLAG(bool, bool_flag, false, "");
168  ABSL_FLAG(UDT, udt_flag, -1, "");
169  ABSL_RETIRED_FLAG(int, legacy_int, 1, "");
170  ABSL_RETIRED_FLAG(bool, legacy_bool, false, "");
171  ABSL_RETIRED_FLAG(std::string, legacy_str, "l", "");
172  namespace {
173  namespace flags = absl::flags_internal;
174  using testing::AllOf;
175  using testing::ElementsAreArray;
176  using testing::HasSubstr;
177  class ParseTest : public testing::Test {
178   public:
179    ~ParseTest() override { flags::SetFlagsHelpMode(flags::HelpMode::kNone); }
180   private:
181    absl::FlagSaver flag_saver_;
182  };
183  template <int N>
184  flags::HelpMode InvokeParseAbslOnlyImpl(const char* (&in_argv)[N]) {
185    std::vector<char*> positional_args;
186    std::vector<absl::UnrecognizedFlag> unrecognized_flags;
187    return flags::ParseAbseilFlagsOnlyImpl(N, const_cast<char**>(in_argv),
188                                           positional_args, unrecognized_flags,
189                                           flags::UsageFlagsAction::kHandleUsage);
190  }
191  template <int N>
192  void InvokeParseAbslOnly(const char* (&in_argv)[N]) {
193    std::vector<char*> positional_args;
194    std::vector<absl::UnrecognizedFlag> unrecognized_flags;
195    absl::ParseAbseilFlagsOnly(2, const_cast<char**>(in_argv), positional_args,
196                               unrecognized_flags);
197  }
198  template <int N>
199  std::vector<char*> InvokeParseCommandLineImpl(const char* (&in_argv)[N]) {
200    return flags::ParseCommandLineImpl(
201        N, const_cast<char**>(in_argv), flags::UsageFlagsAction::kHandleUsage,
202        flags::OnUndefinedFlag::kAbortIfUndefined, std::cerr);
203  }
204  template <int N>
205  std::vector<char*> InvokeParse(const char* (&in_argv)[N]) {
206    return absl::ParseCommandLine(N, const_cast<char**>(in_argv));
207  }
208  template <int N>
209  void TestParse(const char* (&in_argv)[N], int int_flag_value,
210                 double double_flag_val, absl::string_view string_flag_val,
211                 bool bool_flag_val, int exp_position_args = 0) {
212    auto out_args = InvokeParse(in_argv);
213    EXPECT_EQ(out_args.size(), 1 + exp_position_args);
214    EXPECT_STREQ(out_args[0], "testbin");
215    EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), int_flag_value);
216    EXPECT_NEAR(absl::GetFlag(FLAGS_double_flag), double_flag_val, 0.0001);
217    EXPECT_EQ(absl::GetFlag(FLAGS_string_flag), string_flag_val);
218    EXPECT_EQ(absl::GetFlag(FLAGS_bool_flag), bool_flag_val);
219  }
220  TEST_F(ParseTest, TestEmptyArgv) {
221    const char* in_argv[] = {"testbin"};
222    auto out_args = InvokeParse(in_argv);
223    EXPECT_EQ(out_args.size(), 1);
224    EXPECT_STREQ(out_args[0], "testbin");
225  }
226  TEST_F(ParseTest, TestValidIntArg) {
227    const char* in_args1[] = {
228        "testbin",
229        "--int_flag=10",
230    };
231    TestParse(in_args1, 10, 1.1, "a", false);
232    const char* in_args2[] = {
233        "testbin",
234        "-int_flag=020",
235    };
236    TestParse(in_args2, 20, 1.1, "a", false);
237    const char* in_args3[] = {
238        "testbin",
239        "--int_flag",
240        "-30",
241    };
242    TestParse(in_args3, -30, 1.1, "a", false);
243    const char* in_args4[] = {
244        "testbin",
245        "-int_flag",
246        "0x21",
247    };
248    TestParse(in_args4, 33, 1.1, "a", false);
249  }
250  TEST_F(ParseTest, TestValidDoubleArg) {
251    const char* in_args1[] = {
252        "testbin",
253        "--double_flag=2.3",
254    };
255    TestParse(in_args1, 1, 2.3, "a", false);
256    const char* in_args2[] = {
257        "testbin",
258        "--double_flag=0x1.2",
259    };
260    TestParse(in_args2, 1, 1.125, "a", false);
261    const char* in_args3[] = {
262        "testbin",
263        "--double_flag",
264        "99.7",
265    };
266    TestParse(in_args3, 1, 99.7, "a", false);
267    const char* in_args4[] = {
268        "testbin",
269        "--double_flag",
270        "0x20.1",
271    };
272    TestParse(in_args4, 1, 32.0625, "a", false);
273  }
274  TEST_F(ParseTest, TestValidStringArg) {
275    const char* in_args1[] = {
276        "testbin",
277        "--string_flag=aqswde",
278    };
279    TestParse(in_args1, 1, 1.1, "aqswde", false);
280    const char* in_args2[] = {
281        "testbin",
282        "-string_flag=a=b=c",
283    };
284    TestParse(in_args2, 1, 1.1, "a=b=c", false);
285    const char* in_args3[] = {
286        "testbin",
287        "--string_flag",
288        "zaxscd",
289    };
290    TestParse(in_args3, 1, 1.1, "zaxscd", false);
291    const char* in_args4[] = {
292        "testbin",
293        "-string_flag",
294        "--int_flag",
295    };
296    TestParse(in_args4, 1, 1.1, "--int_flag", false);
297    const char* in_args5[] = {
298        "testbin",
299        "--string_flag",
300        "--no_a_flag=11",
301    };
302    TestParse(in_args5, 1, 1.1, "--no_a_flag=11", false);
303  }
304  TEST_F(ParseTest, TestValidBoolArg) {
305    const char* in_args1[] = {
306        "testbin",
307        "--bool_flag",
308    };
309    TestParse(in_args1, 1, 1.1, "a", true);
310    const char* in_args2[] = {
311        "testbin",
312        "--nobool_flag",
313    };
314    TestParse(in_args2, 1, 1.1, "a", false);
315    const char* in_args3[] = {
316        "testbin",
317        "--bool_flag=true",
318    };
319    TestParse(in_args3, 1, 1.1, "a", true);
320    const char* in_args4[] = {
321        "testbin",
322        "-bool_flag=false",
323    };
324    TestParse(in_args4, 1, 1.1, "a", false);
325  }
326  TEST_F(ParseTest, TestValidUDTArg) {
327    const char* in_args1[] = {
328        "testbin",
329        "--udt_flag=A",
330    };
331    InvokeParse(in_args1);
332    EXPECT_EQ(absl::GetFlag(FLAGS_udt_flag).value, 1);
333    const char* in_args2[] = {"testbin", "--udt_flag", "AAA"};
334    InvokeParse(in_args2);
335    EXPECT_EQ(absl::GetFlag(FLAGS_udt_flag).value, 10);
336  }
337  TEST_F(ParseTest, TestValidMultipleArg) {
338    const char* in_args1[] = {
339        "testbin",           "--bool_flag",       "--int_flag=2",
340        "--double_flag=0.1", "--string_flag=asd",
341    };
342    TestParse(in_args1, 2, 0.1, "asd", true);
343    const char* in_args2[] = {
344        "testbin", "--string_flag=", "--nobool_flag", "--int_flag",
345        "-011",    "--double_flag",  "-1e-2",
346    };
347    TestParse(in_args2, -11, -0.01, "", false);
348    const char* in_args3[] = {
349        "testbin",          "--int_flag",         "-0", "--string_flag", "\"\"",
350        "--bool_flag=true", "--double_flag=1e18",
351    };
352    TestParse(in_args3, 0, 1e18, "\"\"", true);
353  }
354  TEST_F(ParseTest, TestPositionalArgs) {
355    const char* in_args1[] = {
356        "testbin",
357        "p1",
358        "p2",
359    };
360    TestParse(in_args1, 1, 1.1, "a", false, 2);
361    auto out_args1 = InvokeParse(in_args1);
362    EXPECT_STREQ(out_args1[1], "p1");
363    EXPECT_STREQ(out_args1[2], "p2");
364    const char* in_args2[] = {
365        "testbin",
366        "--int_flag=2",
367        "p1",
368    };
369    TestParse(in_args2, 2, 1.1, "a", false, 1);
370    auto out_args2 = InvokeParse(in_args2);
371    EXPECT_STREQ(out_args2[1], "p1");
372    const char* in_args3[] = {"testbin", "p1",          "--int_flag=3",
373                              "p2",      "--bool_flag", "true"};
374    TestParse(in_args3, 3, 1.1, "a", true, 3);
375    auto out_args3 = InvokeParse(in_args3);
376    EXPECT_STREQ(out_args3[1], "p1");
377    EXPECT_STREQ(out_args3[2], "p2");
378    EXPECT_STREQ(out_args3[3], "true");
379    const char* in_args4[] = {
380        "testbin",
381        "--",
382        "p1",
383        "p2",
384    };
385    TestParse(in_args4, 3, 1.1, "a", true, 2);
386    auto out_args4 = InvokeParse(in_args4);
387    EXPECT_STREQ(out_args4[1], "p1");
388    EXPECT_STREQ(out_args4[2], "p2");
389    const char* in_args5[] = {
390        "testbin", "p1", "--int_flag=4", "--", "--bool_flag", "false", "p2",
391    };
392    TestParse(in_args5, 4, 1.1, "a", true, 4);
393    auto out_args5 = InvokeParse(in_args5);
394    EXPECT_STREQ(out_args5[1], "p1");
395    EXPECT_STREQ(out_args5[2], "--bool_flag");
396    EXPECT_STREQ(out_args5[3], "false");
397    EXPECT_STREQ(out_args5[4], "p2");
398  }
399  using ParseDeathTest = ParseTest;
400  TEST_F(ParseDeathTest, TestUndefinedArg) {
401    const char* in_args1[] = {
402        "testbin",
403        "--undefined_flag",
404    };
405    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
406                              "Unknown command line flag 'undefined_flag'");
407    const char* in_args2[] = {
408        "testbin",
409        "--noprefixed_flag",
410    };
411    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
412                              "Unknown command line flag 'noprefixed_flag'");
413    const char* in_args3[] = {
414        "testbin",
415        "--Int_flag=1",
416    };
417    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
418                              "Unknown command line flag 'Int_flag'");
419  }
420  TEST_F(ParseDeathTest, TestInvalidBoolFlagFormat) {
421    const char* in_args1[] = {
422        "testbin",
423        "--bool_flag=",
424    };
425    EXPECT_DEATH_IF_SUPPORTED(
426        InvokeParse(in_args1),
427        "Missing the value after assignment for the boolean flag 'bool_flag'");
428    const char* in_args2[] = {
429        "testbin",
430        "--nobool_flag=true",
431    };
432    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
433                 "Negative form with assignment is not valid for the boolean "
434                 "flag 'bool_flag'");
435  }
436  TEST_F(ParseDeathTest, TestInvalidNonBoolFlagFormat) {
437    const char* in_args1[] = {
438        "testbin",
439        "--nostring_flag",
440    };
441    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
442                 "Negative form is not valid for the flag 'string_flag'");
443    const char* in_args2[] = {
444        "testbin",
445        "--int_flag",
446    };
447    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
448                 "Missing the value for the flag 'int_flag'");
449  }
450  TEST_F(ParseDeathTest, TestInvalidUDTFlagFormat) {
451    const char* in_args1[] = {
452        "testbin",
453        "--udt_flag=1",
454    };
455    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
456                 "Illegal value '1' specified for flag 'udt_flag'; Use values A, "
457                 "AAA instead");
458    const char* in_args2[] = {
459        "testbin",
460        "--udt_flag",
461        "AA",
462    };
463    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
464                 "Illegal value 'AA' specified for flag 'udt_flag'; Use values "
465                 "A, AAA instead");
466  }
467  TEST_F(ParseDeathTest, TestFlagSuggestions) {
468    const char* in_args1[] = {
469        "testbin",
470        "--legacy_boo",
471    };
472    EXPECT_DEATH_IF_SUPPORTED(
473        InvokeParse(in_args1),
474        "Unknown command line flag 'legacy_boo'. Did you mean: legacy_bool ?");
475    const char* in_args2[] = {"testbin", "--foo", "--undefok=foo1"};
476    EXPECT_DEATH_IF_SUPPORTED(
477        InvokeParse(in_args2),
478        "Unknown command line flag 'foo'. Did you mean: foo1 \\(undefok\\)?");
479    const char* in_args3[] = {
480        "testbin",
481        "--nolegacy_ino",
482    };
483    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
484                              "Unknown command line flag 'nolegacy_ino'. Did "
485                              "you mean: nolegacy_bool, legacy_int ?");
486  }
487  TEST_F(ParseTest, GetHints) {
488    EXPECT_THAT(absl::flags_internal::GetMisspellingHints("legacy_boo"),
489                testing::ContainerEq(std::vector<std::string>{"legacy_bool"}));
490    EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_itn"),
491                testing::ContainerEq(std::vector<std::string>{"legacy_int"}));
492    EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_int1"),
493                testing::ContainerEq(std::vector<std::string>{"legacy_int"}));
494    EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_int"),
495                testing::ContainerEq(std::vector<std::string>{"legacy_int"}));
496    EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_ino"),
497                testing::ContainerEq(
498                    std::vector<std::string>{"nolegacy_bool", "legacy_int"}));
499    EXPECT_THAT(
500        absl::flags_internal::GetMisspellingHints("FLAG_HEADER_000").size(), 100);
501  }
502  TEST_F(ParseTest, TestLegacyFlags) {
503    const char* in_args1[] = {
504        "testbin",
505        "--legacy_int=11",
506    };
507    TestParse(in_args1, 1, 1.1, "a", false);
508    const char* in_args2[] = {
509        "testbin",
510        "--legacy_bool",
511    };
512    TestParse(in_args2, 1, 1.1, "a", false);
513    const char* in_args3[] = {
514        "testbin",       "--legacy_int", "22",           "--int_flag=2",
515        "--legacy_bool", "true",         "--legacy_str", "--string_flag=qwe",
516    };
517    TestParse(in_args3, 2, 1.1, "a", false, 1);
518  }
519  TEST_F(ParseTest, TestSimpleValidFlagfile) {
520    std::string flagfile_flag;
521    const char* in_args1[] = {
522        "testbin",
523        GetFlagfileFlag({{"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
524                        flagfile_flag),
525    };
526    TestParse(in_args1, -1, 0.1, "q2w2  ", true);
527    const char* in_args2[] = {
528        "testbin",
529        GetFlagfileFlag({{"parse_test.ff2", absl::MakeConstSpan(ff2_data)}},
530                        flagfile_flag),
531    };
532    TestParse(in_args2, 100, 0.1, "q2w2  ", false);
533  }
534  TEST_F(ParseTest, TestValidMultiFlagfile) {
535    std::string flagfile_flag;
536    const char* in_args1[] = {
537        "testbin",
538        GetFlagfileFlag({{"parse_test.ff2", absl::MakeConstSpan(ff2_data)},
539                         {"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
540                        flagfile_flag),
541    };
542    TestParse(in_args1, -1, 0.1, "q2w2  ", true);
543  }
544  TEST_F(ParseTest, TestFlagfileMixedWithRegularFlags) {
545    std::string flagfile_flag;
546    const char* in_args1[] = {
547        "testbin", "--int_flag=3",
548        GetFlagfileFlag({{"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
549                        flagfile_flag),
550        "-double_flag=0.2"};
551    TestParse(in_args1, -1, 0.2, "q2w2  ", true);
552  }
553  TEST_F(ParseTest, TestFlagfileInFlagfile) {
554    std::string flagfile_flag;
555    constexpr const char* const ff3_data[] = {
556        "--flagfile=$0/parse_test.ff1",
557        "--flagfile=$0/parse_test.ff2",
558    };
559    GetFlagfileFlag({{"parse_test.ff2", absl::MakeConstSpan(ff2_data)},
560                     {"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
561                        flagfile_flag);
562    const char* in_args1[] = {
563        "testbin",
564        GetFlagfileFlag({{"parse_test.ff3", absl::MakeConstSpan(ff3_data)}},
565                        flagfile_flag),
566    };
567    TestParse(in_args1, 100, 0.1, "q2w2  ", false);
568  }
569  TEST_F(ParseDeathTest, TestInvalidFlagfiles) {
570    std::string flagfile_flag;
571    constexpr const char* const ff4_data[] = {
572      "--unknown_flag=10"
573    };
574    const char* in_args1[] = {
575        "testbin",
576        GetFlagfileFlag({{"parse_test.ff4",
577                          absl::MakeConstSpan(ff4_data)}}, flagfile_flag),
578    };
579    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
580                 "Unknown command line flag 'unknown_flag'");
581    constexpr const char* const ff5_data[] = {
582      "--int_flag 10",
583    };
584    const char* in_args2[] = {
585        "testbin",
586        GetFlagfileFlag({{"parse_test.ff5",
587                          absl::MakeConstSpan(ff5_data)}}, flagfile_flag),
588    };
589    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
590                 "Unknown command line flag 'int_flag 10'");
591    constexpr const char* const ff6_data[] = {
<span onclick='openModal()' class='match'>592        "--int_flag=10", "--", "arg1", "arg2", "arg3",
593    };
594    const char* in_args3[] = {
595        "testbin",
596        GetFlagfileFlag({{"parse_test.ff6", absl::MakeConstSpan(ff6_data)}},
</span>597                        flagfile_flag),
598    };
599    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
600                 "Flagfile can't contain position arguments or --");
601    const char* in_args4[] = {
602        "testbin",
603        "--flagfile=invalid_flag_file",
604    };
605    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args4),
606                              "Can't open flagfile invalid_flag_file");
607    constexpr const char* const ff7_data[] = {
608        "--int_flag=10",
609        "*bin*",
610        "--str_flag=aqsw",
611    };
612    const char* in_args5[] = {
613        "testbin",
614        GetFlagfileFlag({{"parse_test.ff7", absl::MakeConstSpan(ff7_data)}},
615                        flagfile_flag),
616    };
617    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args5),
618                 "Unexpected line in the flagfile .*: \\*bin\\*");
619  }
620  TEST_F(ParseTest, TestReadingRequiredFlagsFromEnv) {
621    const char* in_args1[] = {"testbin",
622                              "--fromenv=int_flag,bool_flag,string_flag"};
623    ScopedSetEnv set_int_flag("FLAGS_int_flag", "33");
624    ScopedSetEnv set_bool_flag("FLAGS_bool_flag", "True");
625    ScopedSetEnv set_string_flag("FLAGS_string_flag", "AQ12");
626    TestParse(in_args1, 33, 1.1, "AQ12", true);
627  }
628  TEST_F(ParseDeathTest, TestReadingUnsetRequiredFlagsFromEnv) {
629    const char* in_args1[] = {"testbin", "--fromenv=int_flag"};
630    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
631                 "FLAGS_int_flag not found in environment");
632  }
633  TEST_F(ParseDeathTest, TestRecursiveFlagsFromEnv) {
634    const char* in_args1[] = {"testbin", "--fromenv=tryfromenv"};
635    ScopedSetEnv set_tryfromenv("FLAGS_tryfromenv", "int_flag");
636    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
637                              "Infinite recursion on flag tryfromenv");
638  }
639  TEST_F(ParseTest, TestReadingOptionalFlagsFromEnv) {
640    const char* in_args1[] = {
641        "testbin", "--tryfromenv=int_flag,bool_flag,string_flag,other_flag"};
642    ScopedSetEnv set_int_flag("FLAGS_int_flag", "17");
643    ScopedSetEnv set_bool_flag("FLAGS_bool_flag", "Y");
644    TestParse(in_args1, 17, 1.1, "a", true);
645  }
646  TEST_F(ParseTest, TestReadingFlagsFromEnvMoxedWithRegularFlags) {
647    const char* in_args1[] = {
648        "testbin",
649        "--bool_flag=T",
650        "--tryfromenv=int_flag,bool_flag",
651        "--int_flag=-21",
652    };
653    ScopedSetEnv set_int_flag("FLAGS_int_flag", "-15");
654    ScopedSetEnv set_bool_flag("FLAGS_bool_flag", "F");
655    TestParse(in_args1, -21, 1.1, "a", false);
656  }
657  TEST_F(ParseDeathTest, TestSimpleHelpFlagHandling) {
658    const char* in_args1[] = {
659        "testbin",
660        "--help",
661    };
662    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kImportant);
663    EXPECT_EXIT(InvokeParse(in_args1), testing::ExitedWithCode(1), "");
664    const char* in_args2[] = {
665        "testbin",
666        "--help",
667        "--int_flag=3",
668    };
669    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args2), flags::HelpMode::kImportant);
670    EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 3);
671    const char* in_args3[] = {"testbin", "--help", "some_positional_arg"};
672    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args3), flags::HelpMode::kImportant);
673  }
674  TEST_F(ParseTest, TestSubstringHelpFlagHandling) {
675    const char* in_args1[] = {
676        "testbin",
677        "--help=abcd",
678    };
679    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kMatch);
680    EXPECT_EQ(flags::GetFlagsHelpMatchSubstr(), "abcd");
681  }
682  TEST_F(ParseDeathTest, TestVersionHandling) {
683    const char* in_args1[] = {
684        "testbin",
685        "--version",
686    };
687    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kVersion);
688  }
689  TEST_F(ParseTest, TestCheckArgsHandling) {
690    const char* in_args1[] = {"testbin", "--only_check_args", "--int_flag=211"};
691    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kOnlyCheckArgs);
692    EXPECT_EXIT(InvokeParseAbslOnly(in_args1), testing::ExitedWithCode(0), "");
693    EXPECT_EXIT(InvokeParse(in_args1), testing::ExitedWithCode(0), "");
694    const char* in_args2[] = {"testbin", "--only_check_args", "--unknown_flag=a"};
695    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args2), flags::HelpMode::kOnlyCheckArgs);
696    EXPECT_EXIT(InvokeParseAbslOnly(in_args2), testing::ExitedWithCode(0), "");
697    EXPECT_EXIT(InvokeParse(in_args2), testing::ExitedWithCode(1), "");
698  }
699  TEST_F(ParseTest, WasPresentOnCommandLine) {
700    const char* in_args1[] = {
701        "testbin",        "arg1", "--bool_flag",
702        "--int_flag=211", "arg2", "--double_flag=1.1",
703        "--string_flag",  "asd",  "--",
704        "--some_flag",    "arg4",
705    };
706    InvokeParse(in_args1);
707    EXPECT_TRUE(flags::WasPresentOnCommandLine("bool_flag"));
708    EXPECT_TRUE(flags::WasPresentOnCommandLine("int_flag"));
709    EXPECT_TRUE(flags::WasPresentOnCommandLine("double_flag"));
710    EXPECT_TRUE(flags::WasPresentOnCommandLine("string_flag"));
711    EXPECT_FALSE(flags::WasPresentOnCommandLine("some_flag"));
712    EXPECT_FALSE(flags::WasPresentOnCommandLine("another_flag"));
713  }
714  TEST_F(ParseTest, ParseAbseilFlagsOnlySuccess) {
715    const char* in_args[] = {
716        "testbin",
717        "arg1",
718        "--bool_flag",
719        "--int_flag=211",
720        "arg2",
721        "--double_flag=1.1",
722        "--undef_flag1",
723        "--undef_flag2=123",
724        "--string_flag",
725        "asd",
726        "--",
727        "--some_flag",
728        "arg4",
729    };
730    std::vector<char*> positional_args;
731    std::vector<absl::UnrecognizedFlag> unrecognized_flags;
732    absl::ParseAbseilFlagsOnly(13, const_cast<char**>(in_args), positional_args,
733                               unrecognized_flags);
734    EXPECT_THAT(positional_args,
735                ElementsAreArray(
736                    {absl::string_view("testbin"), absl::string_view("arg1"),
737                     absl::string_view("arg2"), absl::string_view("--some_flag"),
738                     absl::string_view("arg4")}));
739    EXPECT_THAT(unrecognized_flags,
740                ElementsAreArray(
741                    {absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
742                                            "undef_flag1"),
743                     absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
744                                            "undef_flag2")}));
745  }
746  TEST_F(ParseDeathTest, ParseAbseilFlagsOnlyFailure) {
747    const char* in_args[] = {
748        "testbin",
749        "--int_flag=21.1",
750    };
751    EXPECT_DEATH_IF_SUPPORTED(
752        InvokeParseAbslOnly(in_args),
753        "Illegal value '21.1' specified for flag 'int_flag'");
754  }
755  TEST_F(ParseTest, UndefOkFlagsAreIgnored) {
756    const char* in_args[] = {
757        "testbin",           "--undef_flag1",
758        "--undef_flag2=123", "--undefok=undef_flag2",
759        "--undef_flag3",     "value",
760    };
761    std::vector<char*> positional_args;
762    std::vector<absl::UnrecognizedFlag> unrecognized_flags;
763    absl::ParseAbseilFlagsOnly(6, const_cast<char**>(in_args), positional_args,
764                               unrecognized_flags);
765    EXPECT_THAT(positional_args, ElementsAreArray({absl::string_view("testbin"),
766                                                   absl::string_view("value")}));
767    EXPECT_THAT(unrecognized_flags,
768                ElementsAreArray(
769                    {absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
770                                            "undef_flag1"),
771                     absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
772                                            "undef_flag3")}));
773  }
774  TEST_F(ParseTest, AllUndefOkFlagsAreIgnored) {
775    const char* in_args[] = {
776        "testbin",
777        "--undef_flag1",
778        "--undef_flag2=123",
779        "--undefok=undef_flag2,undef_flag1,undef_flag3",
780        "--undef_flag3",
781        "value",
782        "--",
783        "--undef_flag4",
784    };
785    std::vector<char*> positional_args;
786    std::vector<absl::UnrecognizedFlag> unrecognized_flags;
787    absl::ParseAbseilFlagsOnly(8, const_cast<char**>(in_args), positional_args,
788                               unrecognized_flags);
789    EXPECT_THAT(positional_args,
790                ElementsAreArray({absl::string_view("testbin"),
791                                  absl::string_view("value"),
792                                  absl::string_view("--undef_flag4")}));
793    EXPECT_THAT(unrecognized_flags, testing::IsEmpty());
794  }
795  TEST_F(ParseDeathTest, ExitOnUnrecognizedFlagPrintsHelp) {
796    const char* in_args[] = {
797        "testbin",
798        "--undef_flag1",
799        "--help=int_flag",
800    };
801    EXPECT_EXIT(InvokeParseCommandLineImpl(in_args), testing::ExitedWithCode(1),
802                AllOf(HasSubstr("Unknown command line flag 'undef_flag1'"),
803                      HasSubstr("Try --helpfull to get a list of all flags")));
804  }
805  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-strip_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-parse_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>78        "Trailing whitespace  ",
79        "  Leading and trailing  ",
80        " Whitespace \t  in\v   middle  ",
81        "'Eeeeep!  \n Newlines!\n",
82        "nospaces",
83    };
84    const char* outputs[] = {
85        "No extra space",
86        "Leading whitespace",
</pre></code></div>
                <div class="column column_space"><pre><code>592        "--int_flag=10", "--", "arg1", "arg2", "arg3",
593    };
594    const char* in_args3[] = {
595        "testbin",
596        GetFlagfileFlag({{"parse_test.ff6", absl::MakeConstSpan(ff6_data)}},
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    