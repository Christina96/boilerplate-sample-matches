
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-http.h</h3>
            <pre><code>1  #include "bd.h"
2  class THttp{
3  public:
4    static const TStr HttpStr;
5    static const TStr SlashStr;
6    static const TStr ColonStr;
7    static const TStr ContTypeFldNm;
8    static const TStr ContLenFldNm;
9    static const TStr HostFldNm;
10    static const TStr AcceptRangesFldNm;
11    static const TStr CacheCtrlFldNm;
12    static const TStr AcceptFldNm;
13    static const TStr SrvFldNm;
14    static const TStr ConnFldNm;
15    static const TStr FetchIdFldNm;
16    static const TStr LocFldNm;
17    static const TStr SetCookieFldNm;
18    static const TStr CookieFldNm;
19    static const TStr TextFldVal;
20    static const TStr TextPlainFldVal;
21    static const TStr TextHtmlFldVal;
22    static const TStr TextXmlFldVal;
23    static const TStr TextWmlFldVal;
24    static const TStr TextJavaScriptFldVal;
25    static const TStr TextCssFldVal;
26    static const TStr ImageIcoFldVal;
27    static const TStr ImagePngFldVal;
28    static const TStr ImageGifFldVal;
29    static const TStr ImageJpgFldVal;
30    static const TStr AppOctetFldVal;
31    static const TStr AppSoapXmlFldVal;
32    static const TStr AppW3FormFldVal;
33    static const TStr AppJSonFldVal;
34    static const TStr ConnKeepAliveFldVal;
35    static bool IsHtmlFExt(const TStr& FExt);
36    static bool IsGifFExt(const TStr& FExt);
37    static const int DfPortN;
38    static const int OkStatusCd;
39    static const int RedirStatusCd;
40    static const int BadRqStatusCd;
41    static const int ErrStatusCd;
42    static const int ErrNotFoundStatusCd;
43    static const int InternalErrStatusCd;
44    static TStr GetReasonPhrase(const int& StatusCd);
45    static const TStr GetMethodNm;
46    static const TStr HeadMethodNm;
47    static const TStr PostMethodNm;
48    static const TStr UndefMethodNm;
49  };
50  typedef enum {
51    hrmUndef, hrmGet, hrmHead, hrmPost} THttpRqMethod;
52  ClassTP(THttpRq, PHttpRq)
53  private:
54    bool Ok;
55    bool CompleteP;
56    int MajorVerN, MinorVerN;
57    THttpRqMethod Method;
58    PUrl Url;
59    TStrStrH FldNmToValH;
60    PUrlEnv UrlEnv;
61    TStr HdStr;
62    TMem BodyMem;
63    void ParseSearch(const TStr& SearchStr);
64    void ParseHttpRq(const PSIn& SIn);
65  public:
66    THttpRq(const PSIn& SIn);
67    static PHttpRq New(const PSIn& SIn){
68      return PHttpRq(new THttpRq(SIn));}
69    THttpRq(
70     const THttpRqMethod& _Method, const PUrl& _Url,
71     const TStr& ContTypeFldVal, const TMem& _BodyMem, const int& FetchId=-1);
72    static PHttpRq New(
73     const THttpRqMethod& Method, const PUrl& Url,
74     const TStr& ContTypeFldVal, const TMem& BodyMem){
75      return PHttpRq(new THttpRq(Method, Url, ContTypeFldVal, BodyMem));}
76    static PHttpRq New(const PUrl& Url, const int& FetchId=-1){
77      return PHttpRq(new THttpRq(hrmGet, Url, "", TMem(), FetchId));}
78    ~THttpRq(){}
79    THttpRq(TSIn&){Fail;}
80    static PHttpRq Load(TSIn&){Fail; return NULL;}
81    void Save(TSOut&){Fail;}
82    THttpRq& operator=(const THttpRq&){Fail; return *this;}
83    bool IsOk() const {return Ok;}
84    bool IsComplete() const {return CompleteP;}
85    THttpRqMethod GetMethod() const {return Method;}
86    const TStr& GetMethodNm() const;
87    PUrl GetUrl() const {return Url;}
88    PUrlEnv GetUrlEnv() const {return UrlEnv;}
89    bool IsFldNm(const TStr& FldNm) const;
90    TStr GetFldVal(const TStr& FldNm) const;
91    bool IsFldVal(const TStr& FldNm, const TStr& FldVal) const;
92    void AddFldVal(const TStr& FldNm, const TStr& FldVal);
93    const TStrStrH& GetFldValH() const;
94    TStr GetHdStr() const {return HdStr;}
95    bool IsBody() const { return !BodyMem.Empty(); }
96    int GetBodyLen() const { return BodyMem.Len(); }
97    TStr GetBodyAsStr() const { return BodyMem.GetAsStr(' ');}
98    PSIn GetBodyAsSIn() const { return TMemIn::New(BodyMem); }
99    void GetBodyAsMem(TMem& Mem) const {Mem.Clr(); Mem += BodyMem;}
100    void GetAsMem(TMem& Mem) const {Mem.Clr(); Mem+=HdStr; Mem+=BodyMem;}
101    bool IsContType(const TStr& ContTypeStr) const {
102      return GetFldVal(THttp::ContTypeFldNm).IsStrIn(ContTypeStr);}
103    bool IsContLen(int& ContLen) const {
104      return GetFldVal(THttp::ContLenFldNm).IsInt(ContLen);}
105    TStr GetStr() const;
106  };
107  ClassTP(THttpResp, PHttpResp)
108  private:
109    bool Ok;
110    int MajorVerN, MinorVerN;
111    int StatusCd;
112    TStr ReasonPhrase;
113    TStrStrVH FldNmToValVH;
114    TStr HdStr;
115    TMem BodyMem;
116    void AddHdFld(const TStr& FldNm, const TStr& FldVal, TChA& HdChA);
117    void ParseHttpResp(const PSIn& SIn);
118  public:
119    THttpResp(const int& _StatusCd, const TStr& ContTypeVal,
120     const bool& CacheCtrlP, const PSIn& BodySIn, const TStr LocStr);
121    static PHttpResp New(const int& StatusCd, const TStr& ContTypeVal,
122     const bool& CacheCtrlP, const PSIn& BodySIn, const TStr LocStr=TStr()){
123      return PHttpResp(new
124       THttpResp(StatusCd, ContTypeVal, CacheCtrlP, BodySIn, LocStr));}
125    THttpResp(const PSIn& SIn);
126    static PHttpResp New(const PSIn& SIn){
127      return PHttpResp(new THttpResp(SIn));}
128    ~THttpResp(){}
129    THttpResp(TSIn&){Fail;}
130    static PHttpResp Load(TSIn&){Fail; return NULL;}
131    void Save(TSOut&){Fail;}
132    THttpResp& operator=(const THttpResp&){Fail; return *this;}
133    bool IsOk() const {return Ok;}
134    int Len() const {return HdStr.Len()+BodyMem.Len();}
135    bool IsContLenOk() const {int ContLen;
136      return IsOk()&&IsContLen(ContLen)&&(ContLen==BodyMem.Len());}
137    void GetAsMem(TMem& Mem) const {
138      Mem.Clr(); Mem+=HdStr; Mem+=BodyMem;}
139    TStr GetHdStr() const {return HdStr;}
140    const TMem& GetBodyAsMem() const {return BodyMem;}
141    TStr GetBodyAsStr() const {return BodyMem.GetAsStr(' ');}
142    PSIn GetBodyAsSIn() const {return BodyMem.GetSIn(); }
143    int GetStatusCd() const {return StatusCd;}
<span onclick='openModal()' class='match'>144    TStr GetReasonPhrase() const {return THttp::GetReasonPhrase(StatusCd);}
145    int GetFlds() const {return FldNmToValVH.Len();}
</span>146    int GetFldVals(const int& FldN) const {
147      return FldNmToValVH[FldN].Len();}
148    void GetFldNmVal(const int& FldN, TStr& FldNm, TStr& FldVal){
149      FldNm=FldNmToValVH.GetKey(FldN); FldVal=FldNmToValVH[FldN][0];}
150    void GetFldNmVal(const int& FldN, const int& ValN, TStr& FldNm, TStr& FldVal){
151      FldNm=FldNmToValVH.GetKey(FldN); FldVal=FldNmToValVH[FldN][ValN];}
152    bool IsFldNm(const TStr& FldNm) const;
153    TStr GetFldVal(const TStr& FldNm, const int& ValN=0) const;
154    void GetFldValV(const TStr& FldNm, TStrV& FldValV) const;
155    bool IsFldVal(const TStr& FldNm, const TStr& FldVal) const;
156    void AddFldVal(const TStr& FldNm, const TStr& FldVal);
157    bool IsStatusCd_Ok() const {
158      return IsOk() && (GetStatusCd()/100==THttp::OkStatusCd/100);}
159    bool IsStatusCd_Redir() const {
160      return IsOk() && (GetStatusCd()/100==THttp::RedirStatusCd/100);}
161    bool IsContType() const {
162      return IsFldNm(THttp::ContTypeFldNm);}
163    bool IsContType(const TStr& ContTypeStr) const {
164      return GetFldVal(THttp::ContTypeFldNm).IsStrIn(ContTypeStr);}
165    bool IsContLen(int& ContLen) const {
166      return GetFldVal(THttp::ContLenFldNm).IsInt(ContLen);}
167    TStr GetSrvNm() const {
168      return GetFldVal(THttp::SrvFldNm);}
169    void GetCookieKeyValDmPathQuV(TStrQuV& CookieKeyValDmPathQuV);
170    int GetTxtLen() const {return HdStr.Len()+BodyMem.Len();}
171    static PHttpResp LoadTxt(PSIn& SIn){
172      return new THttpResp(SIn);}
173    void SaveTxt(const PSOut& SOut) const {
174      HdStr.SaveTxt(SOut); BodyMem.SaveMem(SOut);}
175    void SaveBody(const PSOut& SOut) const {
176      BodyMem.SaveMem(SOut);}
177    PSIn GetSIn() const;
178  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.h</h3>
            <pre><code>1  #include "bd.h"
2  class TXmlObjSer{
3  private:
4    static TStrStrH TypeNmToTagNmH;
5  public:
6    static TStr GetTagNm(const TStr& TypeNm);
7    static void AssertXmlHd(
8     const PXmlTok& XmlTok, const TStr& Nm, const TStr& TypeNm);
9    static bool GetBoolArg(const PXmlTok& XmlTok, const TStr& Nm);
10    static int GetIntArg(const PXmlTok& XmlTok, const TStr& Nm);
11    static int64 GetInt64Arg(const PXmlTok& XmlTok, const TStr& Nm);
12    static double GetFltArg(const PXmlTok& XmlTok, const TStr& Nm);
13  };
14  class TXmlObjSerTagNm{
15  private:
16    TStr TagNm;
17    TSOut* SOut;
18    UndefDefaultCopyAssign(TXmlObjSerTagNm);
19  public:
20    TXmlObjSerTagNm(
21     TSOut& _SOut, const bool& ETagP,
22     const TStr& Nm, const TStr& TypeNm,
23     const TStr& ArgNm="", const TStr& ArgVal="");
24    TXmlObjSerTagNm(
25     TSOut& _SOut, const bool& ETagP,
26     const TStr& Nm, const TStr& TypeNm,
27     const TStr& ArgNm1, const TStr& ArgVal1,
28     const TStr& ArgNm2, const TStr& ArgVal2,
29     const TStr& ArgNm3="", const TStr& ArgVal3="",
30     const TStr& ArgNm4="", const TStr& ArgVal4="");
31    ~TXmlObjSerTagNm();
32  };
33  ClassTP(TXmlChDef, PXmlChDef)
34  private:
35    TInt Chs;
36    TBSet CharChSet, CombChSet, ExtChSet;
37    TBSet LetterChSet, DigitChSet, NameChSet, PubidChSet;
38    TStrStrH EntityNmToValH;
39    void SetChTy(TBSet& ChSet, const int& MnCh, const int& MxCh=-1);
40    void SetChTy(TBSet& ChSet, const TStr& Str);
41    void SetEntityVal(const TStr& Nm, const TStr& Val);
42  public:
43    TXmlChDef();
44    TXmlChDef(TSIn& SIn):
45      Chs(SIn),
46      CharChSet(SIn), CombChSet(SIn), ExtChSet(SIn),
47      LetterChSet(SIn), DigitChSet(SIn), NameChSet(SIn), PubidChSet(SIn),
48      EntityNmToValH(SIn){}
49    static PXmlChDef Load(TSIn& SIn){return new TXmlChDef(SIn);}
50    void Save(TSOut& SOut){
51      Chs.Save(SOut);
52      CharChSet.Save(SOut); CombChSet.Save(SOut); ExtChSet.Save(SOut);
53      LetterChSet.Save(SOut); DigitChSet.Save(SOut); NameChSet.Save(SOut);
54      PubidChSet.Save(SOut);
55      EntityNmToValH.Save(SOut);}
56    TXmlChDef& operator=(const TXmlChDef&){Fail; return *this;}
57    bool IsChar(const uchar& Ch) const {return CharChSet.GetBit(Ch);}
58    bool IsComb(const uchar& Ch) const {return CombChSet.GetBit(Ch);}
59    bool IsExt(const uchar& Ch) const {return ExtChSet.GetBit(Ch);}
60    bool IsLetter(const uchar& Ch) const {return LetterChSet.GetBit(Ch);}
61    bool IsDigit(const uchar& Ch) const {return DigitChSet.GetBit(Ch);}
62    bool IsName(const uchar& Ch) const {return NameChSet.GetBit(Ch);}
63    bool IsPubid(const uchar& Ch) const {return PubidChSet.GetBit(Ch);}
64    bool IsWs(const uchar& Ch) const {
65      return (Ch==' ')||(Ch==TCh::CrCh)||(Ch==TCh::LfCh)||(Ch==TCh::TabCh);}
66    bool IsFirstNameCh(const uchar& Ch) const {
67      return IsLetter(Ch)||(Ch=='_')||(Ch==':');}
68    bool IsEoln(const uchar& Ch) const {
69      return (Ch==TCh::CrCh)||(Ch==TCh::LfCh);}
70    bool IsEntityNm(const TStr& EntityNm, TStr& EntityVal) const {
71      return EntityNmToValH.IsKeyGetDat(EntityNm, EntityVal);}
72  };
73  typedef enum {
74    xsyUndef, xsyWs, xsyComment,
75    xsyXmlDecl, xsyPI,
76    xsyDocTypeDecl, xsyElement, xsyAttList, xsyEntity, xsyNotation,
77    xsyTag, xsySTag, xsyETag, xsySETag, xsyStr, xsyQStr,
78    xsyEof} TXmlLxSym;
79  typedef enum {xspIntact, xspPreserve, xspSeparate, xspTruncate} TXmlSpacing;
80  class TXmlLx{
81  private: 
82    static TXmlChDef ChDef;
83    PSIn SIn;
84    TSIn& RSIn;
85    TChA ChStack;
86    uchar PrevCh, Ch;
87    int LnN, LnChN, ChN;
88    TXmlSpacing Spacing;
89    uchar GetCh();
90    void PutCh(const uchar& _Ch){ChStack.Push(Ch); Ch=_Ch;}
91    void PutStr(const TStr& Str){
92      for (int ChN=Str.Len()-1; ChN>=0; ChN--){PutCh(Str[ChN]);}}
93    void ToNrSpacing();
94  private: 
95    TStrStrH EntityNmToValH, PEntityNmToValH;
96    void GetWs(const bool& IsRq);
97    TStr GetReference();
98    void GetEq();
99    TStr GetName();
100    TStr GetName(const TStr& RqNm);
101    void GetComment();
102    TStr GetAttValue();
103    TStr GetVersionNum();
104    TStr GetEncName();
105    TStr GetStalVal();
106    void GetXmlDecl();
107    void GetPI();
108    TStr GetSystemLiteral();
109    TStr GetPubidLiteral();
110    TStr GetPEReference();
111    void GetExternalId();
112    void GetNData();
113    void GetDocTypeDecl();
114    void GetElement();
115    void GetAttList();
116    TStr GetEntityValue();
117    void GetEntity();
118    void GetNotation();
119    void GetCDSect();
120  public: 
121    TXmlLxSym Sym;
122    TChA TxtChA;
123    TStr TagNm;
124    TStrKdV ArgNmValKdV;
125    void SkipWs();
126  public:
127    TXmlLx(const PSIn& _SIn, const TXmlSpacing& _Spacing=xspIntact):
128      SIn(_SIn), RSIn(*SIn),
129      ChStack(), PrevCh(' '), Ch(' '),
130      LnN(1), LnChN(0), ChN(0), Spacing(_Spacing),
131      EntityNmToValH(100), PEntityNmToValH(100),
132      Sym(xsyUndef), TxtChA(), TagNm(), ArgNmValKdV(10){GetCh();}
133    TXmlLx& operator=(const TXmlLx&){Fail; return *this;}
134    TXmlLxSym GetSym();
135    TStr GetSymStr() const;
136    void EThrow(const TStr& MsgStr) const;
137    TStr GetFPosStr() const;
138    void ClrArgV(){ArgNmValKdV.Clr();}
139    void AddArg(const TStr& ArgNm, const TStr& ArgVal){
140      ArgNmValKdV.Add(TStrKd(ArgNm, ArgVal));}
141    bool IsArgNm(const TStr& ArgNm) const {
142      return ArgNmValKdV.IsIn(TStrKd(ArgNm));}
143    int GetArgs() const {return ArgNmValKdV.Len();}
144    void GetArg(const int& ArgN, TStr& ArgNm, TStr& ArgVal) const {
145      ArgNm=ArgNmValKdV[ArgN].Key; ArgVal=ArgNmValKdV[ArgN].Dat;}
146    TStr GetArgVal(const TStr& ArgNm, const TStr& DfVal=TStr()) const {
147      int ArgN=ArgNmValKdV.SearchForw(TStrKd(ArgNm));
148      if (ArgN==-1){return DfVal;} else {return ArgNmValKdV[ArgN].Dat;}}
149    static char GetArgValQCh(const TStr& ArgVal){
150      if (ArgVal.IsChIn('\"')){return '\'';} else {return '\"';}}
151    bool IsEntityNm(const TStr& EntityNm, TStr& EntityVal) const {
152      return EntityNmToValH.IsKeyGetDat(EntityNm, EntityVal);}
153    void PutEntityVal(const TStr& Nm, const TStr& Val){
154      EntityNmToValH.AddDat(Nm, Val);}
155    bool IsPEntityNm(const TStr& EntityNm, TStr& EntityVal) const {
156      return PEntityNmToValH.IsKeyGetDat(EntityNm, EntityVal);}
157    void PutPEntityVal(const TStr& Nm, const TStr& Val){
158      PEntityNmToValH.AddDat(Nm, Val);}
159    static TStr GetXmlLxSymStr(const TXmlLxSym& XmlLxSym);
160    static bool IsTagNm(const TStr& Str);
161    static TStr GetXmlStrFromPlainMem(const TMem& PlainMem);
162    static TStr GetXmlStrFromPlainStr(const TChA& PlainChA);
163    static TStr GetPlainStrFromXmlStr(const TStr& XmlStr);
164    static TStr GetUsAsciiStrFromXmlStr(const TStr& EntRefStr);
165    static TStr GetChRefFromYuEntRef(const TStr& YuEntRefStr);
166  };
167  ClassTPV(TXmlTok, PXmlTok, TXmlTokV)
168  private:
169    TXmlLxSym Sym;
170    TStr Str;
171    TStrKdV ArgNmValV;
172    TXmlTokV SubTokV;
173  public:
174    TXmlTok(): Sym(xsyUndef), Str(), ArgNmValV(), SubTokV(){}
175    TXmlTok(const TXmlLxSym& _Sym):
176      Sym(_Sym), Str(), ArgNmValV(), SubTokV(){}
177    TXmlTok(const TXmlLxSym& _Sym, const TStr& _Str):
178      Sym(_Sym), Str(_Str), ArgNmValV(), SubTokV(){}
179    TXmlTok(const TXmlLxSym& _Sym, const TStr& _Str, const TStrKdV& _ArgNmValV):
180      Sym(_Sym), Str(_Str), ArgNmValV(_ArgNmValV){}
181    static PXmlTok New(){return PXmlTok(new TXmlTok());}
182    static PXmlTok New(const TXmlLxSym& Sym){return PXmlTok(new TXmlTok(Sym));}
183    static PXmlTok New(const TXmlLxSym& Sym, const TStr& Str){
184      return PXmlTok(new TXmlTok(Sym, Str));}
185    static PXmlTok New(
186     const TXmlLxSym& Sym, const TStr& Str, const TStrKdV& ArgNmValV){
187      return PXmlTok(new TXmlTok(Sym, Str, ArgNmValV));}
188    static PXmlTok New(
189     const TStr& TagNm, const TStrKdV& ArgNmValV){
190      return PXmlTok(new TXmlTok(xsyTag, TagNm, ArgNmValV));}
191    static PXmlTok New(const TStr& TagNm){
192      return PXmlTok(new TXmlTok(xsyTag, TagNm));}
193    static PXmlTok New(const TStr& TagNm, const TStr& ValStr){
194      PXmlTok TagXmlTok=PXmlTok(new TXmlTok(xsyTag, TagNm));
195      PXmlTok StrXmlTok=PXmlTok(new TXmlTok(xsyStr, ValStr));
196      TagXmlTok->AddSubTok(StrXmlTok); return TagXmlTok;}
197    static PXmlTok New(const TStr& TagNm,
198     const PXmlTok& XmlTok1, const PXmlTok& XmlTok2=NULL){
199      PXmlTok TagXmlTok=PXmlTok(new TXmlTok(xsyTag, TagNm));
200      if (!XmlTok1.Empty()){TagXmlTok->AddSubTok(XmlTok1);}
201      if (!XmlTok2.Empty()){TagXmlTok->AddSubTok(XmlTok2);}
202      return TagXmlTok;}
203    TXmlTok(TSIn&){Fail;}
204    static PXmlTok Load(TSIn&){Fail; return NULL;}
205    void Save(TSOut&){Fail;}
206    TXmlTok& operator=(const TXmlTok&){Fail; return *this;}
207    TXmlLxSym GetSym() const {return Sym;}
<span onclick='openModal()' class='match'>208    TStr GetSymStr() const {return TXmlLx::GetXmlLxSymStr(Sym);}
209    void PutStr(const TStr& _Str){Str=_Str;}
</span>210    TStr GetStr() const {return Str;}
211    bool IsTag() const {return (Sym==xsyTag);}
212    bool IsTag(const TStr& TagNm) const {return (Sym==xsyTag)&&(Str==TagNm);}
213    TStr GetTagNm() const {IAssert(Sym==xsyTag); return Str;}
214    void AddArg(const TStr& ArgNm, const bool& ArgVal){
215      ArgNmValV.Add(TStrKd(ArgNm, TBool::GetStr(ArgVal)));}
216    void AddArg(const TStr& ArgNm, const int& ArgVal){
217      ArgNmValV.Add(TStrKd(ArgNm, TInt::GetStr(ArgVal)));}
218    void AddArg(const TStr& ArgNm, const uint64& ArgVal){
219      ArgNmValV.Add(TStrKd(ArgNm, TUInt64::GetStr(ArgVal)));}
220    void AddArg(const TStr& ArgNm, const double& ArgVal){
221      ArgNmValV.Add(TStrKd(ArgNm, TFlt::GetStr(ArgVal)));}
222    void AddArg(const TStr& ArgNm, const TStr& ArgVal){
223      ArgNmValV.Add(TStrKd(ArgNm, ArgVal));}
224    int GetArgs() const {return ArgNmValV.Len();}
225    void GetArg(const int& ArgN, TStr& ArgNm, TStr& ArgVal) const {
226      ArgNm=ArgNmValV[ArgN].Key; ArgVal=ArgNmValV[ArgN].Dat;}
227    bool IsArg(const TStr& ArgNm) const {
228      return ArgNmValV.SearchForw(TStrKd(ArgNm))!=-1;}
229    bool IsArg(const TStr& ArgNm, TStr& ArgVal) const {
230      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
231      if (ArgN!=-1){ArgVal=ArgNmValV[ArgN].Dat;}
232      return ArgN!=-1;}
233    void PutArgVal(const TStr& ArgNm, const TStr& ArgVal){
234      ArgNmValV[ArgNmValV.SearchForw(TStrKd(ArgNm))].Dat=ArgVal;}
235    TStr GetArgVal(const TStr& ArgNm) const {
236      return ArgNmValV[ArgNmValV.SearchForw(TStrKd(ArgNm))].Dat;}
237    TStr GetArgVal(const TStr& ArgNm, const TStr& DfArgVal) const {
238      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
239      return (ArgN==-1) ? DfArgVal : ArgNmValV[ArgN].Dat;}
240    bool GetBoolArgVal(const TStr& ArgNm, const bool& DfVal=false) const;
241    bool GetBoolArgVal(
242     const TStr& ArgNm, const TStr& TrueVal, const bool& DfVal=false) const;
243    bool GetBoolArgVal(const TStr& ArgNm,
244     const TStr& TrueVal, const TStr& FalseVal, const bool& DfVal=false) const;
245    int GetIntArgVal(const TStr& ArgNm, const int& DfVal=0) const;
246    double GetFltArgVal(const TStr& ArgNm, const double& DfVal=0) const;
247    TStr GetStrArgVal(const TStr& ArgNm, const TStr& DfVal=TStr()) const;
248    bool IsSubTag(const TStr& TagNm) const {
249      return !GetTagTok(TagNm).Empty();}
250    bool IsSubTag(const TStr& TagNm, PXmlTok& Tok) const {
251      Tok=GetTagTok(TagNm); return !Tok.Empty();}
252    void AddSubTok(const PXmlTok& Tok){SubTokV.Add(Tok);}
253    int GetSubToks() const {return SubTokV.Len();}
254    PXmlTok GetSubTok(const int& SubTokN) const {return SubTokV[SubTokN];}
255    void ClrSubTok(){SubTokV.Clr();}
256    void PutSubTok(const PXmlTok& Tok, const int& SubTokN=-1);
257    bool IsTagTok(const TStr& TagPath, PXmlTok& TagTok) const {
258      TagTok=GetTagTok(TagPath); return !TagTok.Empty();}
259    bool IsTagTok(const TStr& TagPath) const {
260      PXmlTok TagTok; return IsTagTok(TagPath, TagTok);}
261    PXmlTok GetTagTok(const TStr& TagPath) const;
262    void GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const;
263    void GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const;
264    TStr GetTagVal(const TStr& TagNm, const bool& XmlP) const;
265    TStr GetTagTokStr(const TStr& TagPath) const {
266      return GetTagTok(TagPath)->GetTokStr(false);}
267    TStr GetTagTokStrOrDf(const TStr& TagPath, const TStr& DfVal=TStr()) const {
268      PXmlTok TagTok;
269      if (IsTagTok(TagPath, TagTok)){return TagTok->GetTokStr(false);}
270      else {return DfVal;}}
271    void AddTokToChA(const bool& XmlP, TChA& ChA) const;
272    TStr GetTokStr(const bool& XmlP=true) const {
273      TChA ChA; AddTokToChA(XmlP, ChA); return ChA;}
274    static TStr GetTokVStr(const TXmlTokV& TokV, const bool& XmlP=true);
275    static PXmlTok GetTok(TXmlLx& Lx);
276  };
277  ClassTPV(TXmlDoc, PXmlDoc, TXmlDocV)
278  private:
279    bool Ok;
280    TStr MsgStr;
281    PXmlTok Tok;
282    static void LoadTxtMiscStar(TXmlLx& Lx);
283    static PXmlTok LoadTxtElement(TXmlLx& Lx);
284  public:
285    TXmlDoc(): Ok(false), MsgStr(), Tok(){}
286    static PXmlDoc New(){return PXmlDoc(new TXmlDoc());}
287    TXmlDoc(const PXmlTok& _Tok): Ok(!_Tok.Empty()), MsgStr(), Tok(_Tok){}
288    static PXmlDoc New(const PXmlTok& Tok){return PXmlDoc(new TXmlDoc(Tok));}
289    TXmlDoc(TSIn&){Fail;}
290    static PXmlDoc Load(TSIn& SIn){return new TXmlDoc(SIn);}
291    void Save(TSOut&){Fail;}
292    TXmlDoc& operator=(const TXmlDoc&){Fail; return *this;}
293    bool IsOk() const {return Ok;}
294    TStr GetMsgStr() const {return MsgStr;}
295    PXmlTok GetTok() const {IAssert(Ok); return Tok;}
296    bool IsTagTok(const TStr& TagPath, PXmlTok& TagTok) const {
297      IAssert(Ok); TagTok=GetTagTok(TagPath); return !TagTok.Empty();}
298    bool IsTagTok(const TStr& TagPath) const {
299      PXmlTok TagTok; return IsTagTok(TagPath, TagTok);}
300    PXmlTok GetTagTok(const TStr& TagPath) const;
301    void PutTagTokStr(const TStr& TagPath, const TStr& TokStr) const;
302    TStr GetTagTokStr(const TStr& TagPath) const {
303      return GetTagTok(TagPath)->GetTokStr(false);}
304    void GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const;
305    void GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const {
306      IAssert(Ok); Tok->GetTagValV(TagNm, XmlP, ValV);}
307    TStr GetTagVal(const TStr& TagNm, const bool& XmlP) const {
308      TStrV ValV; GetTagValV(TagNm, XmlP, ValV);
309      if (ValV.Len()>0){return ValV[0];} else {return "";}}
310    bool GetTagTokBoolArgVal(
311     const TStr& TagPath, const TStr& ArgNm, const bool& DfVal=false) const;
312    int GetTagTokIntArgVal(
313     const TStr& TagPath, const TStr& ArgNm, const int& DfVal=0) const;
314    double GetTagTokFltArgVal(
315     const TStr& TagPath, const TStr& ArgNm, const double& DfVal=0) const;
316    TStr GetTagTokStrArgVal(
317     const TStr& TagPath, const TStr& ArgNm, const TStr& DfVal=TStr()) const;
318    static TStr GetXmlStr(const TStr& Str);
319    static bool SkipTopTag(const PSIn& SIn);
320    static PXmlDoc LoadTxt(TXmlLx& Lx);
321    static PXmlDoc LoadTxt(const PSIn& SIn, const TXmlSpacing& Spacing=xspIntact);
322    static PXmlDoc LoadTxt(const TStr& FNm, const TXmlSpacing& Spacing=xspIntact);
323    static void LoadTxt(
324     const TStr& FNm, TXmlDocV& XmlDocV, const TXmlSpacing& Spacing=xspIntact);
325    void SaveTxt(const PSOut& SOut){
326      SOut->PutStr(GetTok()->GetTokStr());}
327    void SaveTxt(const TStr& FNm, const bool& Append=false){
328      PSOut SOut=TFOut::New(FNm, Append); SaveTxt(SOut);}
329    static PXmlDoc LoadStr(const TStr& Str);
330    void SaveStr(TStr& Str);
331  };
332  class TXmlParser;
333  typedef TPt<TXmlParser> PXmlParser;
334  class TXmlParser {  
335  private:
336    TCRef CRef;
337    PSIn SIn;
338    TSIn& RSIn;
339    TChA _SymStr;
340  public:
341    TXmlLxSym Sym, NextSym;
342    TChA SymStr, NextSymStr;
343  private:
344    char GetCh() { return (! RSIn.Eof()) ? RSIn.GetCh() : TCh::EofCh; }
345  public:
346    TXmlParser(const PSIn& _SIn) : SIn(_SIn), RSIn(*SIn), Sym(xsyUndef), NextSym(xsyUndef) { }
347    static PXmlParser New(const PSIn& SIn) { return new TXmlParser(SIn); }
348    TXmlLxSym GetSym();
349    TXmlLxSym GetSym(TChA& _SymStr);
350    TXmlLxSym PeekSym();
351    TXmlLxSym PeekSym(TChA& _SymStr);
352    void SkipTillTag(const TChA& _SymStr);
353    TXmlLxSym GetTag(const TChA& TagStr);
354    void GetTagVal(const TChA& TagStr, TChA& TagVal);
355    static void GetPlainStrFromXmlStr(const TChA& XmlStr, TChA& PlainChA);
356    friend class TPt<TXmlParser>;
357  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-http.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.h</div>
                </div>
                <div class="column column_space"><pre><code>144    TStr GetReasonPhrase() const {return THttp::GetReasonPhrase(StatusCd);}
145    int GetFlds() const {return FldNmToValVH.Len();}
</pre></code></div>
                <div class="column column_space"><pre><code>208    TStr GetSymStr() const {return TXmlLx::GetXmlLxSymStr(Sym);}
209    void PutStr(const TStr& _Str){Str=_Str;}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    