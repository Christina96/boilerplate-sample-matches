
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 286, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ss.h</h3>
            <pre><code>1  #include "bd.h"
2  typedef enum {ssfUndef,
3    ssfTabSep,       
4    ssfCommaSep,     
5    ssfSemicolonSep, 
6    ssfVBar,         
7    ssfSpaceSep,     
8    ssfWhiteSep,     
9    ssfMx} TSsFmt;
10  ClassTP(TSs, PSs)
11  private:
12    TVec<PStrV> CellStrVV;
13  public:
14    TSs(): CellStrVV(){}
15    static PSs New(){return PSs(new TSs());}
16    ~TSs(){}
17    TSs(TSIn& SIn): CellStrVV(SIn){}
18    static PSs Load(TSIn& SIn){return new TSs(SIn);}
19    void Save(TSOut& SOut){CellStrVV.Save(SOut);}
20    TSs& operator=(const TSs& Ss){
21      if (this!=&Ss){CellStrVV=Ss.CellStrVV;} return *this;}
22    TStr& At(const int& X, const int& Y);
23    void PutVal(const int& X, const int& Y, const TStr& Str);
24    TStr GetVal(const int& X, const int& Y) const;
25    int GetXLen() const;
26    int GetXLen(const int& Y) const;
27    int GetYLen() const;
28    void DelX(const int& X);
29    void DelY(const int& Y);
30    int SearchX(const int& Y, const TStr& Str) const;
31    int SearchY(const int& X, const TStr& Str) const;
32    int GetFlds() const {return GetXLen(0);}
33    int GetFldX(const TStr& FldNm, const TStr& NewFldNm="", const int& Y=0) const;
34    int GetFldY(const TStr& FldNm, const TStr& NewFldNm="", const int& X=0) const;
35    TStr GetFldNm(const int& FldX) const {return GetVal(FldX, 0);}
36    static PSs LoadTxt(
37     const TSsFmt& SsFmt, const TStr& FNm,
38     const PNotify& Notify=NULL, const bool& IsExcelEoln=true,
39     const int& MxY=-1, const TIntV& AllowedColNV=TIntV(), const bool& IsQStr=true);
40    void SaveTxt(const TStr& FNm, const PNotify& Notify=NULL) const;
41    static void LoadTxtFldV(
42     const TSsFmt& SsFmt, const PSIn& SIn, char& Ch,
43     TStrV& FldValV, const bool& IsExcelEoln=true, const bool& IsQStr=true);
44    static TSsFmt GetSsFmtFromStr(const TStr& SsFmtNm);
45    static TStr GetStrFromSsFmt(const TSsFmt& SsFmt);
46    static TStr GetSsFmtNmVStr();
47  };
48  ClassTP(TSsParser, PSsParser)
49  private:
50    TSsFmt SsFmt;  
51    bool SkipLeadBlanks;  
52    bool SkipCmt;         
53    bool SkipEmptyFld;    
54    uint64 LineCnt;       
55    char SplitCh;         
56    TChA LineStr;         
57    TVec<char*> FldV;     
58    PSIn FInPt;           
59    UndefDefaultCopyAssign(TSsParser);
60  public:
61    TSsParser(const TStr& FNm, const TSsFmt _SsFmt=ssfTabSep, const bool& _SkipLeadBlanks=false, const bool& _SkipCmt=true, const bool& _SkipEmptyFld=false);
62    TSsParser(const TStr& FNm, const char& Separator, const bool& _SkipLeadBlanks=false, const bool& _SkipCmt=true, const bool& _SkipEmptyFld=false);
63    ~TSsParser();
64    static PSsParser New(const TStr& FNm, const TSsFmt SsFmt) { return new TSsParser(FNm, SsFmt); }
65    bool Next();
66    bool NextSlow();
67    int Len() const { return FldV.Len(); }
68    int GetFlds() const { return Len(); }
69    uint64 GetLineNo() const { return LineCnt; }
70    bool IsCmt() const { return Len()>0 && GetFld(0)[0] == '#'; }
71    bool Eof() const { return FInPt->Eof(); }
<span onclick='openModal()' class='match'>72    TChA GetLnStr() const { TChA LnOut;  for (int i = 0; i < Len(); i++) { LnOut+=GetFld(i); LnOut+=' '; }  if (LnOut.Len() > 0) LnOut.DelLastCh();  return LnOut; }
73    void ToLc();
74    const char* GetFld(const int& FldN) const { return FldV[FldN]; }
75    char* GetFld(const int& FldN) { return FldV[FldN]; }
76    const char* operator [] (const int& FldN) const { return FldV[FldN]; }
77    char* operator [] (const int& FldN) { return FldV[FldN]; }
78    bool GetInt(const int& FldN, int& Val) const;
79    int GetInt(const int& FldN) const {
80      int Val=0; IAssertR(GetInt(FldN, Val), TStr::Fmt("Field %d not INT.\n%s", FldN, DumpStr()).CStr()); return Val; }
81    bool IsInt(const int& FldN) const { int v; return GetInt(FldN, v); }
82    bool GetFlt(const int& FldN, double& Val) const;
83    bool IsFlt(const int& FldN) const { double v; return GetFlt(FldN, v); }
84    double GetFlt(const int& FldN) const { double Val=0.0; IAssert(GetFlt(FldN, Val)); return Val; }
85    bool GetUInt64(const int& FldN, uint64& Val) const;
</span>86    bool IsUInt64(const int& FldN) const { uint64 v; return GetUInt64(FldN, v); }
87    uint64 GetUInt64(const int& FldN) const { uint64 Val=0; IAssert(GetUInt64(FldN, Val)); return Val; }
88    const char* DumpStr() const;
89  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssmp.h</h3>
            <pre><code>1  #include "bd.h"
2  ClassTP(TSsParserMP, PSsParserMP)
3  private:
4    TSsFmt SsFmt;  
5    bool SkipLeadBlanks;  
6    bool SkipCmt;         
7    bool SkipEmptyFld;    
8    uint64 LineCnt;       
9    char SplitCh;         
10    TChA LineStr;         
11    TVec<char*> FldV;     
12    TPt<TMIn> FInPt;      
13    UndefDefaultCopyAssign(TSsParserMP);
14  public:
15    TSsParserMP(const TStr& FNm, const TSsFmt _SsFmt=ssfTabSep, const bool& _SkipLeadBlanks=false, const bool& _SkipCmt=true, const bool& _SkipEmptyFld=false);
16    TSsParserMP(const TStr& FNm, const char& Separator, const bool& _SkipLeadBlanks=false, const bool& _SkipCmt=true, const bool& _SkipEmptyFld=false);
17    ~TSsParserMP();
18    static PSsParserMP New(const TStr& FNm, const TSsFmt SsFmt) { return new TSsParserMP(FNm, SsFmt); }
19    bool Next();
20    bool NextSlow();
21    int Len() const { return FldV.Len(); }
22    int GetFlds() const { return Len(); }
23    uint64 GetLineNo() const { return LineCnt; }
24    bool IsCmt() const { return Len()>0 && GetFld(0)[0] == '#'; }
25    void SkipCommentLines();
26    bool Eof() const { return FInPt->Eof(); }
<span onclick='openModal()' class='match'>27    TChA GetLnStr() const { TChA LnOut;  for (int i = 0; i < Len(); i++) { LnOut+=GetFld(i); LnOut+=' '; }  if (LnOut.Len() > 0) LnOut.DelLastCh();  return LnOut; }
28    void ToLc();
29    const char* GetFld(const int& FldN) const { return FldV[FldN]; }
30    char* GetFld(const int& FldN) { return FldV[FldN]; }
31    const char* operator [] (const int& FldN) const { return FldV[FldN]; }
32    char* operator [] (const int& FldN) { return FldV[FldN]; }
33    bool GetInt(const int& FldN, int& Val) const;
34    int GetInt(const int& FldN) const {
35      int Val=0; IAssertR(GetInt(FldN, Val), TStr::Fmt("Field %d not INT.\n%s", FldN, DumpStr()).CStr()); return Val; }
36    bool IsInt(const int& FldN) const { int v; return GetInt(FldN, v); }
37    bool GetFlt(const int& FldN, double& Val) const;
38    bool IsFlt(const int& FldN) const { double v; return GetFlt(FldN, v); }
39    double GetFlt(const int& FldN) const {
40      double Val=0.0; IAssert(GetFlt(FldN, Val)); return Val; }
41    uint64 GetStreamPos() const {
</span>42      return FInPt->GetBfC(); }
43    uint64 GetStreamLen() const {
44      return FInPt->GetBfL(); }
45    void SetStreamPos(uint64 Pos) {
46      return FInPt->SetBfC(Pos); }
47    uint64 CountNewLinesInRange(uint64 Lb, uint64 Ub) const;
48    TVec<uint64> GetStartPosV(uint64 Lb, uint64 Ub) const;
49    void NextFromIndex(uint64 Index, TVec<char*>& FieldsV);
50    int GetIntFromFldV(TVec<char*>& FieldsV, const int& FldN);
51    double GetFltFromFldV(TVec<char*>& FieldsV, const int& FldN);
52    const char* DumpStr() const;
53  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ss.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssmp.h</div>
                </div>
                <div class="column column_space"><pre><code>72    TChA GetLnStr() const { TChA LnOut;  for (int i = 0; i < Len(); i++) { LnOut+=GetFld(i); LnOut+=' '; }  if (LnOut.Len() > 0) LnOut.DelLastCh();  return LnOut; }
73    void ToLc();
74    const char* GetFld(const int& FldN) const { return FldV[FldN]; }
75    char* GetFld(const int& FldN) { return FldV[FldN]; }
76    const char* operator [] (const int& FldN) const { return FldV[FldN]; }
77    char* operator [] (const int& FldN) { return FldV[FldN]; }
78    bool GetInt(const int& FldN, int& Val) const;
79    int GetInt(const int& FldN) const {
80      int Val=0; IAssertR(GetInt(FldN, Val), TStr::Fmt("Field %d not INT.\n%s", FldN, DumpStr()).CStr()); return Val; }
81    bool IsInt(const int& FldN) const { int v; return GetInt(FldN, v); }
82    bool GetFlt(const int& FldN, double& Val) const;
83    bool IsFlt(const int& FldN) const { double v; return GetFlt(FldN, v); }
84    double GetFlt(const int& FldN) const { double Val=0.0; IAssert(GetFlt(FldN, Val)); return Val; }
85    bool GetUInt64(const int& FldN, uint64& Val) const;
</pre></code></div>
                <div class="column column_space"><pre><code>27    TChA GetLnStr() const { TChA LnOut;  for (int i = 0; i < Len(); i++) { LnOut+=GetFld(i); LnOut+=' '; }  if (LnOut.Len() > 0) LnOut.DelLastCh();  return LnOut; }
28    void ToLc();
29    const char* GetFld(const int& FldN) const { return FldV[FldN]; }
30    char* GetFld(const int& FldN) { return FldV[FldN]; }
31    const char* operator [] (const int& FldN) const { return FldV[FldN]; }
32    char* operator [] (const int& FldN) { return FldV[FldN]; }
33    bool GetInt(const int& FldN, int& Val) const;
34    int GetInt(const int& FldN) const {
35      int Val=0; IAssertR(GetInt(FldN, Val), TStr::Fmt("Field %d not INT.\n%s", FldN, DumpStr()).CStr()); return Val; }
36    bool IsInt(const int& FldN) const { int v; return GetInt(FldN, v); }
37    bool GetFlt(const int& FldN, double& Val) const;
38    bool IsFlt(const int& FldN) const { double v; return GetFlt(FldN, v); }
39    double GetFlt(const int& FldN) const {
40      double Val=0.0; IAssert(GetFlt(FldN, Val)); return Val; }
41    uint64 GetStreamPos() const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    