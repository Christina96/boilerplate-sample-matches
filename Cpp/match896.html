<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lab6.cpp & TestIntervalMatrix.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lab6.cpp & TestIntervalMatrix.cpp
      </h3>
      <h1 align="center">
        13.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lab6.cpp (44.554455%)<TH>TestIntervalMatrix.cpp (7.95053%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match896-0.html#0',2,'match896-1.html#0',3)" NAME="0">(64-65)<TD><A HREF="javascript:ZweiFrames('match896-0.html#0',2,'match896-1.html#0',3)" NAME="0">(23-24)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match896-0.html#1',2,'match896-1.html#1',3)" NAME="1">(62-64)<TD><A HREF="javascript:ZweiFrames('match896-0.html#1',2,'match896-1.html#1',3)" NAME="1">(248-253)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match896-0.html#2',2,'match896-1.html#2',3)" NAME="2">(65-65)<TD><A HREF="javascript:ZweiFrames('match896-0.html#2',2,'match896-1.html#2',3)" NAME="2">(185-186)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lab6.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : lab6.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Jun 8, 2015
//============================================================================

#include &quot;ibex.h&quot;
#include &quot;vibes.cpp&quot;

using namespace std;
using namespace ibex;

class ToVibes : public SetVisitor {

public:

  /**
   * Plot a  box within the frame [-max,max]x[-max,max]
   *
   * The frame avoids, in particular, to plot unbounded OUT boxes.
   */
  ToVibes(double max) : frame(2,max*Interval(0,1)) {  }

  /**
   * Function that will be called automatically on every boxes (leaves) of the set.
   */
  void visit_leaf(const IntervalVector&amp; box, BoolInterval status) {

    // Intersect the box with the frame
    IntervalVector framebox=box &amp; frame;

    //  Associate a color to the box.
    //  - YES (means &quot;inside&quot;) is in green
    //  - NO (means &quot;outside&quot;) is in red
    //  - MAYBE (means &quot;boundary&quot;) is in blue.
    const char* color;

    switch (status) {
    case YES:  color=&quot;g&quot;; break;
    case NO:   color=&quot;r&quot;; break;
    case MAYBE : color=&quot;b&quot;; break;
    }

    // Plot the box with Vibes
    vibes::drawBox(framebox[0].lb(), framebox[0].ub(), framebox[1].lb(), framebox[1].ub(), color);
  }

   IntervalVector frame;
};

int main() {
	vibes::beginDrawing ();
	vibes::newFigure(&quot;lab6&quot;);

	double eps=0.001;
<A NAME="1"></A>
	Function f(&quot;p1&quot;,&quot;p2&quot;,&quot;t&quot;,&quot;20*exp(-p1*t)-8*exp(-p2*t)&quot;);
<A NAME="0"></A>
<A NAME="2"></A><FONT color="#f63526"><A HREF="javascript:ZweiFrames('match896-1.html#1',3,'match896-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	const int n=10;

</B></FONT><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match896-1.html#0',3,'match896-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	double _t[n][2] = {{1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,6}, {7,7}, {8,8}, {9,9}, {10,10}};
	double _y[n][2] = {{4.5,7.5}, {0.67,4.6}, {-1,2.8}, {-1.7,1.7}, {-1.9,0.93}, {-1.8,0.5}, {-1.6,0.24}, {-1.4,0.09}, {-1.2,0.0089}, {-1,-0.031}};</B></FONT><FONT color="#980517"><A HREF="javascript:ZweiFrames('match896-1.html#2',3,'match896-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B></B></FONT>

	IntervalVector t(n,_t);
	IntervalVector y(n,_y);

	double tdelta=0.3;
	t.inflate(tdelta);

	// Used to represent which variables are &quot;quantified&quot;
	BitSet vars=BitSet::empty(3);
	// add &quot;p1&quot; as variable
	vars.add(0);
	// add &quot;p2&quot; as variable
	vars.add(1);

	Array&lt;Ctc&gt; _c_out(n);
	Array&lt;Ctc&gt; _c_in(n);

	for (int i=0; i&lt;n; i++) {
		IntervalVector ti(1,t[i]);
		_c_out.set_ref(i,*new CtcForAll(*new CtcFwdBwd(f,y[i]),vars,ti,tdelta/5));
		_c_in.set_ref(i,*new CtcExist(*new CtcNotIn(f,y[i]),vars,ti,tdelta/5));
	}

	CtcCompo c_out(_c_out);
	CtcUnion c_in(_c_in);

	SepCtcPair sep(c_in,c_out);

	Set set(IntervalVector(2,Interval(0,1)));

	sep.contract(set,eps);

	ToVibes to_vibes(1);
	set.visit(to_vibes);

	vibes::endDrawing();


}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestIntervalMatrix.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - Interval Matrix Tests
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Mar 2, 2012
 * ---------------------------------------------------------------------------- */

#include &quot;TestIntervalMatrix.h&quot;
#include &quot;ibex_IntervalMatrix.h&quot;
#include &quot;ibex_Random.h&quot;
#include &quot;utils.h&quot;

using namespace std;

namespace {
<A NAME="0"></A>
IntervalMatrix M1() {
	IntervalMatrix m(2,3);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match896-0.html#0',2,'match896-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	double _r1[][2]={{0,1},{0,2},{0,3}};
	double _r2[][2]={{-1,0},{-2,0},{-3,0}};</B></FONT>
	IntervalVector r1(3,_r1);
	IntervalVector r2(3,_r2);
	m[0]=r1;
	m[1]=r2;
	return m;
}


IntervalMatrix M2() { // the transpose of M1
	IntervalMatrix m(3,2);
	double _c1[][2]={{0,1},{-1,0}};
	double _c2[][2]={{0,2},{-2,0}};
	double _c3[][2]={{0,3},{-3,0}};
	IntervalVector c1(2,_c1);
	IntervalVector c2(2,_c2);
	IntervalVector c3(2,_c3);
	m[0]=c1;
	m[1]=c2;
	m[2]=c3;
	return m;
}

IntervalMatrix M3() { // non-null intersection with M1
	IntervalMatrix m(2,3);
	double _r1[][2]={{1,2},{1,2},{2,4}};
	double _r2[][2]={{-2,-1},{-2,-1},{-4,-2}};
	IntervalVector r1(3,_r1);
	IntervalVector r2(3,_r2);
	m[0]=r1;
	m[1]=r2;
	return m;
}

}

void TestIntervalMatrix::eq01() {
	IntervalMatrix m(2,3);
	IntervalMatrix m2(3,2);
	CPPUNIT_ASSERT(m!=m2);
	CPPUNIT_ASSERT(!(m==m2));
}

void TestIntervalMatrix::eq02() {
	IntervalMatrix m(3,2);
	IntervalMatrix m2(2,2);
	CPPUNIT_ASSERT(m!=m2);
	CPPUNIT_ASSERT(!(m==m2));
}

void TestIntervalMatrix::eq03() {
	IntervalMatrix m(2,3);
	IntervalMatrix m2(2,3);

	CPPUNIT_ASSERT(m.nb_rows()==2);
	CPPUNIT_ASSERT(m.nb_cols()==3);
	CPPUNIT_ASSERT(m2.nb_rows()==2);
	CPPUNIT_ASSERT(m2.nb_cols()==3);

	m[0][0]=1;
	m[0][1]=2;
	m[0][2]=3;
	m[1][0]=4;
	m[1][1]=5;
	m[1][2]=6;
	m2[0][0]=1;
	m2[0][1]=2;
	m2[0][2]=3;
	m2[1][0]=4;
	m2[1][1]=5;
	m2[1][2]=6;

	CPPUNIT_ASSERT(m==m2);
	CPPUNIT_ASSERT(!(m!=m2));

	m2[1][2]=7;
	CPPUNIT_ASSERT(m!=m2);
	CPPUNIT_ASSERT(!(m==m2));
}

void TestIntervalMatrix::eq04() {
	IntervalMatrix m(2,3);
	IntervalMatrix m2(2,3);
	m[1][1]=-1;
	m2[1][1]=-2;
	CPPUNIT_ASSERT(m!=m2);
	CPPUNIT_ASSERT(!(m==m2));
	m.set_empty();
	m2.set_empty();
	CPPUNIT_ASSERT(m==m2);
	CPPUNIT_ASSERT(!(m!=m2));
}

void TestIntervalMatrix::cons01() {
	IntervalMatrix m(2,3);
	CPPUNIT_ASSERT(m.nb_rows()==2);
	CPPUNIT_ASSERT(m.nb_cols()==3);
	CPPUNIT_ASSERT(m[0][0]==Interval::all_reals());
	CPPUNIT_ASSERT(m[0][1]==Interval::all_reals());
	CPPUNIT_ASSERT(m[0][2]==Interval::all_reals());
	CPPUNIT_ASSERT(m[1][0]==Interval::all_reals());
	CPPUNIT_ASSERT(m[1][1]==Interval::all_reals());
	CPPUNIT_ASSERT(m[1][2]==Interval::all_reals());

	CPPUNIT_ASSERT(m==IntervalMatrix(m));
	CPPUNIT_ASSERT(m==(IntervalMatrix(2,3)=m));
}

void TestIntervalMatrix::cons02() {
	IntervalMatrix m(2,3);
	double _r1[][2]={{0,1},{0,2},{0,3}};
	double _r2[][2]={{-1,0},{-2,0},{-3,0}};
	IntervalVector r1(3,_r1);
	IntervalVector r2(3,_r2);
	m[0]=r1;
	m.set_row(1,r2);

	double _c1[][2]={{0,1},{-1,0}};
	double _c2[][2]={{0,2},{-2,0}};
	double _c3[][2]={{0,3},{-3,0}};
	IntervalVector c1(2,_c1);
	IntervalVector c2(2,_c2);
	IntervalVector c3(2,_c3);

	CPPUNIT_ASSERT(m.nb_rows()==2);
	CPPUNIT_ASSERT(m.nb_cols()==3);
	CPPUNIT_ASSERT(m[0]==r1);
	CPPUNIT_ASSERT(m[1]==r2);
	CPPUNIT_ASSERT(m.row(0)==r1);
	CPPUNIT_ASSERT(m.row(1)==r2);

	CPPUNIT_ASSERT(m.col(0)==c1);
	CPPUNIT_ASSERT(m.col(1)==c2);
	CPPUNIT_ASSERT(m.col(2)==c3);
	CPPUNIT_ASSERT(m[0][0]==Interval(0,1));
	CPPUNIT_ASSERT(m[0][1]==Interval(0,2));
	CPPUNIT_ASSERT(m[0][2]==Interval(0,3));
	CPPUNIT_ASSERT(m[1][0]==Interval(-1,0));
	CPPUNIT_ASSERT(m[1][1]==Interval(-2,0));
	CPPUNIT_ASSERT(m[1][2]==Interval(-3,0));

	CPPUNIT_ASSERT(m==IntervalMatrix(m));
	CPPUNIT_ASSERT(m==(IntervalMatrix(2,3)=m));
}

void TestIntervalMatrix::cons03() {
	Interval x(-1,2);
	IntervalMatrix m(2,3,x);

	CPPUNIT_ASSERT(m.nb_rows()==2);
	CPPUNIT_ASSERT(m.nb_cols()==3);
	for (int i=0; i&lt;2; i++) {
			for (int j=0; j&lt;3; j++)
				CPPUNIT_ASSERT(m[i][j]==x);
	}

	CPPUNIT_ASSERT(m==IntervalMatrix(m));
	CPPUNIT_ASSERT(m==(IntervalMatrix(2,3)=m));
<A NAME="2"></A>}

void TestIntervalMatrix::cons04() {
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match896-0.html#2',2,'match896-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	double _m[][2]={ {0,1}, {0,2}, {0,3},
		             {-1,0},{-2,0},{-3,0} };</B></FONT>
	IntervalMatrix m(2,3,_m);
	CPPUNIT_ASSERT(m==M1());
}

void TestIntervalMatrix::consInitList() {
	IntervalMatrix m{
		{{0,1}, {0,2}, {0,3}},
		{{-1,0},{-2,0},{-3,0}}
	};
	CPPUNIT_ASSERT(m == M1());
}

void TestIntervalMatrix::empty01() {

	CPPUNIT_ASSERT(IntervalMatrix::empty(2,3).nb_rows()==2);
	CPPUNIT_ASSERT(IntervalMatrix::empty(2,3).nb_cols()==3);

	CPPUNIT_ASSERT(IntervalMatrix(IntervalMatrix::empty(2,3))==IntervalMatrix::empty(2,3));
	CPPUNIT_ASSERT((IntervalMatrix(2,3)=IntervalMatrix::empty(2,3))==IntervalMatrix::empty(2,3));
}

void TestIntervalMatrix::is_empty01() {
	CPPUNIT_ASSERT(!IntervalMatrix(2,3).is_empty());
}

void TestIntervalMatrix::is_empty02() {
	CPPUNIT_ASSERT(IntervalMatrix::empty(2,3).is_empty());
}

void TestIntervalMatrix::set_empty01() {
	IntervalMatrix m(2,3);
	m.set_empty();
	CPPUNIT_ASSERT(m.is_empty());
}

// intersection of a matrix with itself
void TestIntervalMatrix::inter01() {
	CPPUNIT_ASSERT((M1()&amp;=M1())==M1());
}

// intersection of two overlapping matrices
void TestIntervalMatrix::inter02() {
	double _m[][2]={{1,1},  {1,2},  {2,3},
			        {-1,-1},{-2,-1},{-3,-2}};

	CPPUNIT_ASSERT((M1()&amp;=M3())==IntervalMatrix(2,3,_m));
}

// intersection of two non-overlapping matrices
void TestIntervalMatrix::inter03() {
	IntervalMatrix m3(M3());
	m3[1][2]=Interval(-5,-4);
	CPPUNIT_ASSERT((M1()&amp;=m3).is_empty());

}

void TestIntervalMatrix::set_col01() {
	IntervalMatrix m(M1());
<A NAME="1"></A>
	IntervalVector v(2);
	v[0]=Interval(1,2);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match896-0.html#1',2,'match896-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	v[1]=Interval(-2,-1);

	m.set_col(1,v);

	double _m2[][2]={ {0,1}, {1,2}, {0,3},
			          {-1,0},{-2,-1},{-3,0} };</B></FONT>
	IntervalMatrix m2(2,3,_m2);

	CPPUNIT_ASSERT(m==m2);
}

void TestIntervalMatrix::rows01() {
	CPPUNIT_ASSERT(M1().rows(0,1)==M1());
}

void TestIntervalMatrix::rows02() {
	double _r0[][2]={ {0,1}, {0,2}, {0,3} };
	CPPUNIT_ASSERT(M1().rows(0,0)==IntervalMatrix(1,3,_r0));
}

void TestIntervalMatrix::rows03() {
	double _r1[][2]={ {-1,0},{-2,0},{-3,0} };
	CPPUNIT_ASSERT(M1().rows(1,1)==IntervalMatrix(1,3,_r1));
}

void TestIntervalMatrix::cols01() {
	CPPUNIT_ASSERT(M1().cols(0,2)==M1());
}

void TestIntervalMatrix::cols02() {
	double _c0[][2]={ {0,1}, {-1,0} };
	CPPUNIT_ASSERT(M1().cols(0,0)==IntervalMatrix(2,1,_c0));
}

void TestIntervalMatrix::cols03() {
	double _c1[][2]={ {0,2}, {-2,0} };
	CPPUNIT_ASSERT(M1().cols(1,1)==IntervalMatrix(2,1,_c1));
}

void TestIntervalMatrix::cols04() {
	double _c2[][2]={ {0,3}, {-3,0} };
	CPPUNIT_ASSERT(M1().cols(2,2)==IntervalMatrix(2,1,_c2));
}

void TestIntervalMatrix::cols05() {
	double _c12[][2]={ {0,2}, {0,3}, {-2,0}, {-3,0} };
	CPPUNIT_ASSERT(M1().cols(1,2)==IntervalMatrix(2,2,_c12));
}

void TestIntervalMatrix::resize01() {
	IntervalMatrix m(2,2);
	double _r1[][2]={{0,1},{0,2}};
	double _r2[][2]={{-1,0},{-2,0}};
	IntervalVector r1(2,_r1);
	IntervalVector r2(2,_r2);
	m[0]=r1;
	m[1]=r2;
	m.resize(2,3);
	m[0][2]=Interval(0,3);
	m[1][2]=Interval(-3,0);

	CPPUNIT_ASSERT(m==M1());
}

void TestIntervalMatrix::resize02() {
	IntervalMatrix m(1,3);
	double _r1[][2]={{0,1},{0,2},{0,3}};
	IntervalVector r1(3,_r1);
	m[0]=r1;
	m.resize(2,3);
	m[1][0]=Interval(-1,0);
	m[1][1]=Interval(-2,0);
	m[1][2]=Interval(-3,0);

	CPPUNIT_ASSERT(m==M1());
}

void TestIntervalMatrix::resize03() {
	IntervalMatrix e(IntervalMatrix::empty(1,1));
	e.resize(2,3);
	CPPUNIT_ASSERT(e.is_empty());
}

void TestIntervalMatrix::minus01() {
	IntervalMatrix m(M1());
	IntervalMatrix m2(-m);
	for (int i=0; i&lt;2; i++) {
		for (int j=0; j&lt;3; j++) {
			CPPUNIT_ASSERT(m2[i][j]==-m[i][j]);
		}
	}
}

void TestIntervalMatrix::minus02() {
	CPPUNIT_ASSERT(-IntervalMatrix::empty(2,3).is_empty());
}

void TestIntervalMatrix::add01() {
	IntervalMatrix m(M1());
	IntervalMatrix m2(m+m);

	for (int i=0; i&lt;2; i++) {
		for (int j=0; j&lt;3; j++) {
			CPPUNIT_ASSERT(m2[i][j]==m[i][j]+m[i][j]);
		}
	}

	CPPUNIT_ASSERT(m2==(IntervalMatrix(m)+=m));
}

void TestIntervalMatrix::add02() {
	IntervalMatrix m1(IntervalMatrix::empty(2,3));
	IntervalMatrix m2(2,3);

	CPPUNIT_ASSERT((m1+m2).is_empty());
	CPPUNIT_ASSERT((m1+=m2).is_empty());
	CPPUNIT_ASSERT((m2+=m1).is_empty());
}

void TestIntervalMatrix::sub01() {
	IntervalMatrix m(M1());
	IntervalMatrix m2(m-m);
	for (int i=0; i&lt;2; i++) {
		for (int j=0; j&lt;3; j++) {
			CPPUNIT_ASSERT(m2[i][j]==m[i][j]-m[i][j]);
		}
	}

	CPPUNIT_ASSERT(m2==(IntervalMatrix(m)-=m));
}

void TestIntervalMatrix::sub02() {
	IntervalMatrix m1(IntervalMatrix::empty(2,3));
	IntervalMatrix m2(2,3);

	CPPUNIT_ASSERT((m1-m2).is_empty());
	CPPUNIT_ASSERT((m1-=m2).is_empty());
	CPPUNIT_ASSERT((m2-=m1).is_empty());
}

void TestIntervalMatrix::mul01() {
	IntervalMatrix m(M1());
	IntervalMatrix m2(M2());
	IntervalMatrix m3(m*m2);
	CPPUNIT_ASSERT(m3.nb_rows()==2);
	CPPUNIT_ASSERT(m3.nb_cols()==2);

	for (int i=0; i&lt;2; i++) {
		for (int j=0; j&lt;2; j++)
			CPPUNIT_ASSERT(m3[i][j]==m[i][0]*m2[0][j]+m[i][1]*m2[1][j]+m[i][2]*m2[2][j]);
	}

	CPPUNIT_ASSERT(m3==(IntervalMatrix(m)*=m2));
}

void TestIntervalMatrix::mul02() {
	IntervalMatrix m1(IntervalMatrix::empty(2,3));
	IntervalMatrix m2(3,2);

	CPPUNIT_ASSERT((m1*m2).is_empty());
	CPPUNIT_ASSERT((m1*=m2).is_empty());
	CPPUNIT_ASSERT((m2*=m1).is_empty());
}

void TestIntervalMatrix::put01() {

	IntervalMatrix M1=2*Matrix::eye(3);
	IntervalVector V1(3);
	V1[0]=3; V1[1]=4; V1[2]=5;
	IntervalMatrix res(4,4);
	res.put(0,0,M1);
	res.put(0,3,V1,false);
	res.put(3,0,Vector::ones(3),true);
	res[3][3]=6;
	double _expected[16] = { 2,0,0,3,
							 0,2,0,4,
							 0,0,2,5,
							 1,1,1,6 };
	CPPUNIT_ASSERT(res==(Matrix(4,4,_expected)));
}

void TestIntervalMatrix::rad01() {
	RNG::srand(1);
	IntervalMatrix M=Matrix::rand(2);
	Matrix R=M.rad();
	CPPUNIT_ASSERT(R[0][0]==M[0][0].rad());
	CPPUNIT_ASSERT(R[0][1]==M[0][1].rad());
	CPPUNIT_ASSERT(R[1][0]==M[1][0].rad());
	CPPUNIT_ASSERT(R[1][1]==M[1][1].rad());
}

void TestIntervalMatrix::diam01() {
	RNG::srand(1);
	IntervalMatrix M=Matrix::rand(2);
	Matrix R=M.diam();
	CPPUNIT_ASSERT(R[0][0]==M[0][0].diam());
	CPPUNIT_ASSERT(R[0][1]==M[0][1].diam());
	CPPUNIT_ASSERT(R[1][0]==M[1][0].diam());
	CPPUNIT_ASSERT(R[1][1]==M[1][1].diam());
}
</PRE>
</div>
  </div>
</body>
</html>
