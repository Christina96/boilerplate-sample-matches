
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_test.cc</h3>
            <pre><code>1  #include "absl/hash/hash.h"
2  #include <algorithm>
3  #include <array>
4  #include <bitset>
5  #include <cstdint>
6  #include <cstring>
7  #include <deque>
8  #include <forward_list>
9  #include <functional>
10  #include <initializer_list>
11  #include <iterator>
12  #include <limits>
13  #include <list>
14  #include <map>
15  #include <memory>
16  #include <numeric>
17  #include <random>
18  #include <set>
19  #include <string>
20  #include <tuple>
21  #include <type_traits>
22  #include <unordered_map>
23  #include <unordered_set>
24  #include <utility>
25  #include <vector>
26  #include "gmock/gmock.h"
27  #include "gtest/gtest.h"
28  #include "absl/container/btree_map.h"
29  #include "absl/container/btree_set.h"
30  #include "absl/container/flat_hash_map.h"
31  #include "absl/container/flat_hash_set.h"
32  #include "absl/container/node_hash_map.h"
33  #include "absl/container/node_hash_set.h"
34  #include "absl/hash/hash_testing.h"
35  #include "absl/hash/internal/hash_test.h"
36  #include "absl/hash/internal/spy_hash_state.h"
37  #include "absl/meta/type_traits.h"
38  #include "absl/numeric/int128.h"
39  #include "absl/strings/cord_test_helpers.h"
40  #ifdef ABSL_HAVE_STD_STRING_VIEW
41  #include <string_view>
42  #endif
43  namespace {
44  using ::absl::hash_test_internal::is_hashable;
45  using ::absl::hash_test_internal::TypeErasedContainer;
46  using ::absl::hash_test_internal::TypeErasedValue;
47  template <typename T>
48  using TypeErasedVector = TypeErasedContainer<std::vector<T>>;
49  using absl::Hash;
50  using absl::hash_internal::SpyHashState;
51  template <typename T>
52  class HashValueIntTest : public testing::Test {
53  };
54  TYPED_TEST_SUITE_P(HashValueIntTest);
55  template <typename T>
56  SpyHashState SpyHash(const T& value) {
57    return SpyHashState::combine(SpyHashState(), value);
58  }
59  TYPED_TEST_P(HashValueIntTest, BasicUsage) {
60    EXPECT_TRUE((is_hashable<TypeParam>::value));
61    TypeParam n = 42;
62    EXPECT_EQ(SpyHash(n), SpyHash(TypeParam{42}));
63    EXPECT_NE(SpyHash(n), SpyHash(TypeParam{0}));
64    EXPECT_NE(SpyHash(std::numeric_limits<TypeParam>::max()),
65              SpyHash(std::numeric_limits<TypeParam>::min()));
66  }
67  TYPED_TEST_P(HashValueIntTest, FastPath) {
68    TypeParam n = 42;
69    EXPECT_EQ(absl::Hash<TypeParam>{}(n),
70              absl::Hash<std::tuple<TypeParam>>{}(std::tuple<TypeParam>(n)));
71  }
72  REGISTER_TYPED_TEST_SUITE_P(HashValueIntTest, BasicUsage, FastPath);
73  using IntTypes = testing::Types<unsigned char, char, int, int32_t, int64_t,
74                                  uint32_t, uint64_t, size_t>;
75  INSTANTIATE_TYPED_TEST_SUITE_P(My, HashValueIntTest, IntTypes);
76  enum LegacyEnum { kValue1, kValue2, kValue3 };
77  enum class EnumClass { kValue4, kValue5, kValue6 };
78  TEST(HashValueTest, EnumAndBool) {
79    EXPECT_TRUE((is_hashable<LegacyEnum>::value));
80    EXPECT_TRUE((is_hashable<EnumClass>::value));
81    EXPECT_TRUE((is_hashable<bool>::value));
82    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
83        LegacyEnum::kValue1, LegacyEnum::kValue2, LegacyEnum::kValue3)));
84    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
85        EnumClass::kValue4, EnumClass::kValue5, EnumClass::kValue6)));
86    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
87        std::make_tuple(true, false)));
88  }
89  TEST(HashValueTest, FloatingPoint) {
90    EXPECT_TRUE((is_hashable<float>::value));
91    EXPECT_TRUE((is_hashable<double>::value));
92    EXPECT_TRUE((is_hashable<long double>::value));
93    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
94        std::make_tuple(42.f, 0.f, -0.f, std::numeric_limits<float>::infinity(),
95                        -std::numeric_limits<float>::infinity())));
96    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
97        std::make_tuple(42., 0., -0., std::numeric_limits<double>::infinity(),
98                        -std::numeric_limits<double>::infinity())));
99    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
100        .5L, 1.L, 2.L, 4.L, 42.L, 0.L, -0.L,
101        17 * static_cast<long double>(std::numeric_limits<double>::max()),
102        std::numeric_limits<long double>::infinity(),
103        -std::numeric_limits<long double>::infinity())));
104  }
105  TEST(HashValueTest, Pointer) {
106    EXPECT_TRUE((is_hashable<int*>::value));
107    EXPECT_TRUE((is_hashable<int(*)(char, float)>::value));
108    EXPECT_TRUE((is_hashable<void(*)(int, int, ...)>::value));
109    int i;
110    int* ptr = &i;
111    int* n = nullptr;
112    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
113        std::make_tuple(&i, ptr, nullptr, ptr + 1, n)));
114  }
115  TEST(HashValueTest, PointerAlignment) {
116    constexpr size_t kTotalSize = 1 << 20;
<span onclick='openModal()' class='match'>117    std::unique_ptr<char[]> data(new char[kTotalSize]);
118    constexpr size_t kLog2NumValues = 5;
</span>119    constexpr size_t kNumValues = 1 << kLog2NumValues;
120    for (size_t align = 1; align < kTotalSize / kNumValues;
121         align < 8 ? align += 1 : align < 1024 ? align += 8 : align += 32) {
122      SCOPED_TRACE(align);
123      ASSERT_LE(align * kNumValues, kTotalSize);
124      size_t bits_or = 0;
125      size_t bits_and = ~size_t{};
126      for (size_t i = 0; i < kNumValues; ++i) {
127        size_t hash = absl::Hash<void*>()(data.get() + i * align);
128        bits_or |= hash;
129        bits_and &= hash;
130      }
131      constexpr size_t kMask = (1 << (kLog2NumValues + 7)) - 1;
132      size_t stuck_bits = (~bits_or | bits_and) & kMask;
133      EXPECT_EQ(stuck_bits, 0u) << "0x" << std::hex << stuck_bits;
134    }
135  }
136  TEST(HashValueTest, PointerToMember) {
137    struct Bass {
138      void q() {}
139    };
140    struct A : Bass {
141      virtual ~A() = default;
142      virtual void vfa() {}
143      static auto pq() -> void (A::*)() { return &A::q; }
144    };
145    struct B : Bass {
146      virtual ~B() = default;
147      virtual void vfb() {}
148      static auto pq() -> void (B::*)() { return &B::q; }
149    };
150    struct Foo : A, B {
151      void f1() {}
152      void f2() const {}
153      int g1() & { return 0; }
154      int g2() const & { return 0; }
155      int g3() && { return 0; }
156      int g4() const && { return 0; }
157      int h1() & { return 0; }
158      int h2() const & { return 0; }
159      int h3() && { return 0; }
160      int h4() const && { return 0; }
161      int a;
162      int b;
163      const int c = 11;
164      const int d = 22;
165    };
166    EXPECT_TRUE((is_hashable<float Foo::*>::value));
167    EXPECT_TRUE((is_hashable<double (Foo::*)(int, int)&&>::value));
168    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
169        std::make_tuple(&Foo::a, &Foo::b, static_cast<int Foo::*>(nullptr))));
170    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
171        std::make_tuple(&Foo::c, &Foo::d, static_cast<const int Foo::*>(nullptr),
172                        &Foo::a, &Foo::b)));
173    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
174        &Foo::f1, static_cast<void (Foo::*)()>(nullptr))));
175    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
176        &Foo::f2, static_cast<void (Foo::*)() const>(nullptr))));
177    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
178        &Foo::g1, &Foo::h1, static_cast<int (Foo::*)() &>(nullptr))));
179    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
180        &Foo::g2, &Foo::h2, static_cast<int (Foo::*)() const &>(nullptr))));
181    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
182        &Foo::g3, &Foo::h3, static_cast<int (Foo::*)() &&>(nullptr))));
183    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
184        &Foo::g4, &Foo::h4, static_cast<int (Foo::*)() const &&>(nullptr))));
185    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
186        std::make_tuple(static_cast<void (Foo::*)()>(&Foo::vfa),
187                        static_cast<void (Foo::*)()>(&Foo::vfb),
188                        static_cast<void (Foo::*)()>(nullptr))));
189    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
190        std::make_tuple(static_cast<void (Foo::*)()>(Foo::A::pq()),
191                        static_cast<void (Foo::*)()>(Foo::B::pq()),
192                        static_cast<void (Foo::*)()>(nullptr))));
193  }
194  TEST(HashValueTest, PairAndTuple) {
195    EXPECT_TRUE((is_hashable<std::pair<int, int>>::value));
196    EXPECT_TRUE((is_hashable<std::pair<const int&, const int&>>::value));
197    EXPECT_TRUE((is_hashable<std::tuple<int&, int&>>::value));
198    EXPECT_TRUE((is_hashable<std::tuple<int&&, int&&>>::value));
199    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
200        std::make_pair(0, 42), std::make_pair(0, 42), std::make_pair(42, 0),
201        std::make_pair(0, 0), std::make_pair(42, 42), std::make_pair(1, 42))));
202    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
203        std::make_tuple(std::make_tuple(0, 0, 0), std::make_tuple(0, 0, 42),
204                        std::make_tuple(0, 23, 0), std::make_tuple(17, 0, 0),
205                        std::make_tuple(42, 0, 0), std::make_tuple(3, 9, 9),
206                        std::make_tuple(0, 0, -42))));
207    int a = 0, b = 1, c = 17, d = 23;
208    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
209        std::tie(a, a), std::tie(a, b), std::tie(b, c), std::tie(c, d))));
210    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
211        std::forward_as_tuple(0, 0, 0), std::forward_as_tuple(0, 0, 42),
212        std::forward_as_tuple(0, 23, 0), std::forward_as_tuple(17, 0, 0),
213        std::forward_as_tuple(42, 0, 0), std::forward_as_tuple(3, 9, 9),
214        std::forward_as_tuple(0, 0, -42))));
215  }
216  TEST(HashValueTest, CombineContiguousWorks) {
217    std::vector<std::tuple<int>> v1 = {std::make_tuple(1), std::make_tuple(3)};
218    std::vector<std::tuple<int>> v2 = {std::make_tuple(1), std::make_tuple(2)};
219    auto vh1 = SpyHash(v1);
220    auto vh2 = SpyHash(v2);
221    EXPECT_NE(vh1, vh2);
222  }
223  struct DummyDeleter {
224    template <typename T>
225    void operator() (T* ptr) {}
226  };
227  struct SmartPointerEq {
228    template <typename T, typename U>
229    bool operator()(const T& t, const U& u) const {
230      return GetPtr(t) == GetPtr(u);
231    }
232    template <typename T>
233    static auto GetPtr(const T& t) -> decltype(&*t) {
234      return t ? &*t : nullptr;
235    }
236    static std::nullptr_t GetPtr(std::nullptr_t) { return nullptr; }
237  };
238  TEST(HashValueTest, SmartPointers) {
239    EXPECT_TRUE((is_hashable<std::unique_ptr<int>>::value));
240    EXPECT_TRUE((is_hashable<std::unique_ptr<int, DummyDeleter>>::value));
241    EXPECT_TRUE((is_hashable<std::shared_ptr<int>>::value));
242    int i, j;
243    std::unique_ptr<int, DummyDeleter> unique1(&i);
244    std::unique_ptr<int, DummyDeleter> unique2(&i);
245    std::unique_ptr<int, DummyDeleter> unique_other(&j);
246    std::unique_ptr<int, DummyDeleter> unique_null;
247    std::shared_ptr<int> shared1(&i, DummyDeleter());
248    std::shared_ptr<int> shared2(&i, DummyDeleter());
249    std::shared_ptr<int> shared_other(&j, DummyDeleter());
250    std::shared_ptr<int> shared_null;
251    ASSERT_TRUE(SmartPointerEq{}(unique1, shared1));
252    ASSERT_FALSE(SmartPointerEq{}(unique1, shared_other));
253    ASSERT_TRUE(SmartPointerEq{}(unique_null, nullptr));
254    ASSERT_FALSE(SmartPointerEq{}(shared2, nullptr));
255    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
256        std::forward_as_tuple(&i, nullptr,                    
257                              unique1, unique2, unique_null,  
258                              absl::make_unique<int>(),       
259                              shared1, shared2, shared_null,  
260                              std::make_shared<int>()),
261        SmartPointerEq{}));
262  }
263  TEST(HashValueTest, FunctionPointer) {
264    using Func = int (*)();
265    EXPECT_TRUE(is_hashable<Func>::value);
266    Func p1 = [] { return 2; }, p2 = [] { return 1; };
267    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
268        std::make_tuple(p1, p2, nullptr)));
269  }
270  struct WrapInTuple {
271    template <typename T>
272    std::tuple<int, T, size_t> operator()(const T& t) const {
273      return std::make_tuple(7, t, 0xdeadbeef);
274    }
275  };
276  absl::Cord FlatCord(absl::string_view sv) {
277    absl::Cord c(sv);
278    c.Flatten();
279    return c;
280  }
281  absl::Cord FragmentedCord(absl::string_view sv) {
282    if (sv.size() < 2) {
283      return absl::Cord(sv);
284    }
285    size_t halfway = sv.size() / 2;
286    std::vector<absl::string_view> parts = {sv.substr(0, halfway),
287                                            sv.substr(halfway)};
288    return absl::MakeFragmentedCord(parts);
289  }
290  TEST(HashValueTest, Strings) {
291    EXPECT_TRUE((is_hashable<std::string>::value));
292    const std::string small = "foo";
293    const std::string dup = "foofoo";
294    const std::string large = std::string(2048, 'x');  
295    const std::string huge = std::string(5000, 'a');   
296    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(  
297        std::string(), absl::string_view(), absl::Cord(),                     
298        std::string(""), absl::string_view(""), absl::Cord(""),               
299        std::string(small), absl::string_view(small), absl::Cord(small),      
300        std::string(dup), absl::string_view(dup), absl::Cord(dup),            
301        std::string(large), absl::string_view(large), absl::Cord(large),      
302        std::string(huge), absl::string_view(huge), FlatCord(huge),           
303        FragmentedCord(huge))));
304    const WrapInTuple t{};
305    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(  
306        t(std::string()), t(absl::string_view()), t(absl::Cord()),            
307        t(std::string("")), t(absl::string_view("")), t(absl::Cord("")),      
308        t(std::string(small)), t(absl::string_view(small)),                   
309            t(absl::Cord(small)),                                             
310        t(std::string(dup)), t(absl::string_view(dup)), t(absl::Cord(dup)),   
311        t(std::string(large)), t(absl::string_view(large)),                   
312            t(absl::Cord(large)),                                             
313        t(std::string(huge)), t(absl::string_view(huge)),                     
314            t(FlatCord(huge)), t(FragmentedCord(huge)))));
315    EXPECT_NE(SpyHash(static_cast<const char*>("ABC")),
316              SpyHash(absl::string_view("ABC")));
317  }
318  TEST(HashValueTest, WString) {
319    EXPECT_TRUE((is_hashable<std::wstring>::value));
320    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
321        std::wstring(), std::wstring(L"ABC"), std::wstring(L"ABC"),
322        std::wstring(L"Some other different string"),
323        std::wstring(L"Iñtërnâtiônàlizætiøn"))));
324  }
325  TEST(HashValueTest, U16String) {
326    EXPECT_TRUE((is_hashable<std::u16string>::value));
327    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
328        std::u16string(), std::u16string(u"ABC"), std::u16string(u"ABC"),
329        std::u16string(u"Some other different string"),
330        std::u16string(u"Iñtërnâtiônàlizætiøn"))));
331  }
332  TEST(HashValueTest, U32String) {
333    EXPECT_TRUE((is_hashable<std::u32string>::value));
334    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
335        std::u32string(), std::u32string(U"ABC"), std::u32string(U"ABC"),
336        std::u32string(U"Some other different string"),
337        std::u32string(U"Iñtërnâtiônàlizætiøn"))));
338  }
339  TEST(HashValueTest, WStringView) {
340  #ifndef ABSL_HAVE_STD_STRING_VIEW
341    GTEST_SKIP();
342  #else
343    EXPECT_TRUE((is_hashable<std::wstring_view>::value));
344    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
345        std::wstring_view(), std::wstring_view(L"ABC"), std::wstring_view(L"ABC"),
346        std::wstring_view(L"Some other different string_view"),
347        std::wstring_view(L"Iñtërnâtiônàlizætiøn"))));
348  #endif
349  }
350  TEST(HashValueTest, U16StringView) {
351  #ifndef ABSL_HAVE_STD_STRING_VIEW
352    GTEST_SKIP();
353  #else
354    EXPECT_TRUE((is_hashable<std::u16string_view>::value));
355    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
356        std::make_tuple(std::u16string_view(), std::u16string_view(u"ABC"),
357                        std::u16string_view(u"ABC"),
358                        std::u16string_view(u"Some other different string_view"),
359                        std::u16string_view(u"Iñtërnâtiônàlizætiøn"))));
360  #endif
361  }
362  TEST(HashValueTest, U32StringView) {
363  #ifndef ABSL_HAVE_STD_STRING_VIEW
364    GTEST_SKIP();
365  #else
366    EXPECT_TRUE((is_hashable<std::u32string_view>::value));
367    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
368        std::make_tuple(std::u32string_view(), std::u32string_view(U"ABC"),
369                        std::u32string_view(U"ABC"),
370                        std::u32string_view(U"Some other different string_view"),
371                        std::u32string_view(U"Iñtërnâtiônàlizætiøn"))));
372  #endif
373  }
374  TEST(HashValueTest, StdArray) {
375    EXPECT_TRUE((is_hashable<std::array<int, 3>>::value));
376    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
377        std::make_tuple(std::array<int, 3>{}, std::array<int, 3>{{0, 23, 42}})));
378  }
379  TEST(HashValueTest, StdBitset) {
380    EXPECT_TRUE((is_hashable<std::bitset<257>>::value));
381    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
382        {std::bitset<2>("00"), std::bitset<2>("01"), std::bitset<2>("10"),
383         std::bitset<2>("11")}));
384    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
385        {std::bitset<5>("10101"), std::bitset<5>("10001"), std::bitset<5>()}));
386    constexpr int kNumBits = 256;
387    std::array<std::string, 6> bit_strings;
388    bit_strings.fill(std::string(kNumBits, '1'));
389    bit_strings[1][0] = '0';
390    bit_strings[2][1] = '0';
391    bit_strings[3][kNumBits / 3] = '0';
392    bit_strings[4][kNumBits - 2] = '0';
393    bit_strings[5][kNumBits - 1] = '0';
394    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
395        {std::bitset<kNumBits>(bit_strings[0].c_str()),
396         std::bitset<kNumBits>(bit_strings[1].c_str()),
397         std::bitset<kNumBits>(bit_strings[2].c_str()),
398         std::bitset<kNumBits>(bit_strings[3].c_str()),
399         std::bitset<kNumBits>(bit_strings[4].c_str()),
400         std::bitset<kNumBits>(bit_strings[5].c_str())}));
401  }  
402  struct Private {
403    int i;
404    template <typename H>
405    friend H AbslHashValue(H h, Private p) {
406      return H::combine(std::move(h), std::abs(p.i));
407    }
408    friend bool operator==(Private a, Private b) {
409      return std::abs(a.i) == std::abs(b.i);
410    }
411    friend std::ostream& operator<<(std::ostream& o, Private p) {
412      return o << p.i;
413    }
414  };
415  class PiecewiseHashTester {
416   public:
417    explicit PiecewiseHashTester(absl::string_view buf)
418        : buf_(buf), piecewise_(false), split_locations_() {}
419    PiecewiseHashTester(absl::string_view buf, std::set<size_t> split_locations)
420        : buf_(buf),
421          piecewise_(true),
422          split_locations_(std::move(split_locations)) {}
423    template <typename H>
424    friend H AbslHashValue(H h, const PiecewiseHashTester& p) {
425      if (!p.piecewise_) {
426        return H::combine_contiguous(std::move(h), p.buf_.data(), p.buf_.size());
427      }
428      absl::hash_internal::PiecewiseCombiner combiner;
429      if (p.split_locations_.empty()) {
430        h = combiner.add_buffer(std::move(h), p.buf_.data(), p.buf_.size());
431        return combiner.finalize(std::move(h));
432      }
433      size_t begin = 0;
434      for (size_t next : p.split_locations_) {
435        absl::string_view chunk = p.buf_.substr(begin, next - begin);
436        h = combiner.add_buffer(std::move(h), chunk.data(), chunk.size());
437        begin = next;
438      }
439      absl::string_view last_chunk = p.buf_.substr(begin);
440      if (!last_chunk.empty()) {
441        h = combiner.add_buffer(std::move(h), last_chunk.data(),
442                                last_chunk.size());
443      }
444      return combiner.finalize(std::move(h));
445    }
446   private:
447    absl::string_view buf_;
448    bool piecewise_;
449    std::set<size_t> split_locations_;
450  };
451  struct DummyFooBar {
452    template <typename H>
453    friend H AbslHashValue(H h, const DummyFooBar&) {
454      const char* foo = "foo";
455      const char* bar = "bar";
456      h = H::combine_contiguous(std::move(h), foo, 3);
457      h = H::combine_contiguous(std::move(h), bar, 3);
458      return h;
459    }
460  };
461  TEST(HashValueTest, CombinePiecewiseBuffer) {
462    absl::Hash<PiecewiseHashTester> hash;
463    EXPECT_EQ(hash(PiecewiseHashTester("")), hash(PiecewiseHashTester("", {})));
464    EXPECT_EQ(hash(PiecewiseHashTester("foobar")),
465              hash(PiecewiseHashTester("foobar", {})));
466    EXPECT_EQ(hash(PiecewiseHashTester("foobar")),
467              hash(PiecewiseHashTester("foobar", {3})));
468    EXPECT_NE(hash(PiecewiseHashTester("foobar", {3})),
469              absl::Hash<DummyFooBar>()(DummyFooBar{}));
470    for (size_t big_buffer_size : {1024u * 2 + 512u, 1024u * 3}) {
471      SCOPED_TRACE(big_buffer_size);
472      std::string big_buffer;
473      for (size_t i = 0; i < big_buffer_size; ++i) {
474        big_buffer.push_back(32 + (i * (i / 3)) % 64);
475      }
476      auto big_buffer_hash = hash(PiecewiseHashTester(big_buffer));
477      const int possible_breaks = 9;
478      size_t breaks[possible_breaks] = {1,    512,  1023, 1024, 1025,
479                                        1536, 2047, 2048, 2049};
480      for (unsigned test_mask = 0; test_mask < (1u << possible_breaks);
481           ++test_mask) {
482        SCOPED_TRACE(test_mask);
483        std::set<size_t> break_locations;
484        for (int j = 0; j < possible_breaks; ++j) {
485          if (test_mask & (1u << j)) {
486            break_locations.insert(breaks[j]);
487          }
488        }
489        EXPECT_EQ(
490            hash(PiecewiseHashTester(big_buffer, std::move(break_locations))),
491            big_buffer_hash);
492      }
493    }
494  }
495  TEST(HashValueTest, PrivateSanity) {
496    EXPECT_TRUE(is_hashable<Private>::value);
497    EXPECT_NE(SpyHash(Private{0}), SpyHash(Private{1}));
498    EXPECT_EQ(SpyHash(Private{1}), SpyHash(Private{1}));
499  }
500  TEST(HashValueTest, Optional) {
501    EXPECT_TRUE(is_hashable<absl::optional<Private>>::value);
502    using O = absl::optional<Private>;
503    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
504        std::make_tuple(O{}, O{{1}}, O{{-1}}, O{{10}})));
505  }
506  TEST(HashValueTest, Variant) {
507    using V = absl::variant<Private, std::string>;
508    EXPECT_TRUE(is_hashable<V>::value);
509    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
510        V(Private{1}), V(Private{-1}), V(Private{2}), V("ABC"), V("BCD"))));
511  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
512    struct S {};
513    EXPECT_FALSE(is_hashable<absl::variant<S>>::value);
514  #endif
515  }
516  TEST(HashValueTest, ReferenceWrapper) {
517    EXPECT_TRUE(is_hashable<std::reference_wrapper<Private>>::value);
518    Private p1{1}, p10{10};
519    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
520        p1, p10, std::ref(p1), std::ref(p10), std::cref(p1), std::cref(p10))));
521    EXPECT_TRUE(is_hashable<std::reference_wrapper<int>>::value);
522    int one = 1, ten = 10;
523    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
524        one, ten, std::ref(one), std::ref(ten), std::cref(one), std::cref(ten))));
525    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
526        std::make_tuple(std::tuple<std::reference_wrapper<int>>(std::ref(one)),
527                        std::tuple<std::reference_wrapper<int>>(std::ref(ten)),
528                        std::tuple<int>(one), std::tuple<int>(ten))));
529  }
530  template <typename T, typename = void>
531  struct IsHashCallable : std::false_type {};
532  template <typename T>
533  struct IsHashCallable<T, absl::void_t<decltype(std::declval<absl::Hash<T>>()(
534                              std::declval<const T&>()))>> : std::true_type {};
535  template <typename T, typename = void>
536  struct IsAggregateInitializable : std::false_type {};
537  template <typename T>
538  struct IsAggregateInitializable<T, absl::void_t<decltype(T{})>>
539      : std::true_type {};
540  TEST(IsHashableTest, ValidHash) {
541    EXPECT_TRUE((is_hashable<int>::value));
542    EXPECT_TRUE(std::is_default_constructible<absl::Hash<int>>::value);
543    EXPECT_TRUE(std::is_copy_constructible<absl::Hash<int>>::value);
544    EXPECT_TRUE(std::is_move_constructible<absl::Hash<int>>::value);
545    EXPECT_TRUE(absl::is_copy_assignable<absl::Hash<int>>::value);
546    EXPECT_TRUE(absl::is_move_assignable<absl::Hash<int>>::value);
547    EXPECT_TRUE(IsHashCallable<int>::value);
548    EXPECT_TRUE(IsAggregateInitializable<absl::Hash<int>>::value);
549  }
550  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
551  TEST(IsHashableTest, PoisonHash) {
552    struct X {};
553    EXPECT_FALSE((is_hashable<X>::value));
554    EXPECT_FALSE(std::is_default_constructible<absl::Hash<X>>::value);
555    EXPECT_FALSE(std::is_copy_constructible<absl::Hash<X>>::value);
556    EXPECT_FALSE(std::is_move_constructible<absl::Hash<X>>::value);
557    EXPECT_FALSE(absl::is_copy_assignable<absl::Hash<X>>::value);
558    EXPECT_FALSE(absl::is_move_assignable<absl::Hash<X>>::value);
559    EXPECT_FALSE(IsHashCallable<X>::value);
560  #if !defined(__GNUC__) || defined(__clang__)
561    EXPECT_FALSE(IsAggregateInitializable<absl::Hash<X>>::value);
562  #endif
563  }
564  #endif  
565  struct NoOp {
566    template <typename HashCode>
567    friend HashCode AbslHashValue(HashCode h, NoOp n) {
568      return h;
569    }
570  };
571  struct EmptyCombine {
572    template <typename HashCode>
573    friend HashCode AbslHashValue(HashCode h, EmptyCombine e) {
574      return HashCode::combine(std::move(h));
575    }
576  };
577  template <typename Int>
578  struct CombineIterative {
579    template <typename HashCode>
580    friend HashCode AbslHashValue(HashCode h, CombineIterative c) {
581      for (int i = 0; i < 5; ++i) {
582        h = HashCode::combine(std::move(h), Int(i));
583      }
584      return h;
585    }
586  };
587  template <typename Int>
588  struct CombineVariadic {
589    template <typename HashCode>
590    friend HashCode AbslHashValue(HashCode h, CombineVariadic c) {
591      return HashCode::combine(std::move(h), Int(0), Int(1), Int(2), Int(3),
592                               Int(4));
593    }
594  };
595  enum class InvokeTag {
596    kUniquelyRepresented,
597    kHashValue,
598  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
599    kLegacyHash,
600  #endif  
601    kStdHash,
602    kNone
603  };
604  template <InvokeTag T>
605  using InvokeTagConstant = std::integral_constant<InvokeTag, T>;
606  template <InvokeTag... Tags>
607  struct MinTag;
608  template <InvokeTag a, InvokeTag b, InvokeTag... Tags>
609  struct MinTag<a, b, Tags...> : MinTag<(a < b ? a : b), Tags...> {};
610  template <InvokeTag a>
611  struct MinTag<a> : InvokeTagConstant<a> {};
612  template <InvokeTag... Tags>
613  struct CustomHashType {
614    explicit CustomHashType(size_t val) : value(val) {}
615    size_t value;
616  };
617  template <InvokeTag allowed, InvokeTag... tags>
618  struct EnableIfContained
619      : std::enable_if<absl::disjunction<
620            std::integral_constant<bool, allowed == tags>...>::value> {};
621  template <
622      typename H, InvokeTag... Tags,
623      typename = typename EnableIfContained<InvokeTag::kHashValue, Tags...>::type>
624  H AbslHashValue(H state, CustomHashType<Tags...> t) {
625    static_assert(MinTag<Tags...>::value == InvokeTag::kHashValue, "");
626    return H::combine(std::move(state),
627                      t.value + static_cast<int>(InvokeTag::kHashValue));
628  }
629  }  
630  namespace absl {
631  ABSL_NAMESPACE_BEGIN
632  namespace hash_internal {
633  template <InvokeTag... Tags>
634  struct is_uniquely_represented<
635      CustomHashType<Tags...>,
636      typename EnableIfContained<InvokeTag::kUniquelyRepresented, Tags...>::type>
637      : std::true_type {};
638  }  
639  ABSL_NAMESPACE_END
640  }  
641  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
642  namespace ABSL_INTERNAL_LEGACY_HASH_NAMESPACE {
643  template <InvokeTag... Tags>
644  struct hash<CustomHashType<Tags...>> {
645    template <InvokeTag... TagsIn, typename = typename EnableIfContained<
646                                       InvokeTag::kLegacyHash, TagsIn...>::type>
647    size_t operator()(CustomHashType<TagsIn...> t) const {
648      static_assert(MinTag<Tags...>::value == InvokeTag::kLegacyHash, "");
649      return t.value + static_cast<int>(InvokeTag::kLegacyHash);
650    }
651  };
652  }  
653  #endif  
654  namespace std {
655  template <InvokeTag... Tags>  
656  struct hash<CustomHashType<Tags...>> {
657    template <InvokeTag... TagsIn, typename = typename EnableIfContained<
658                                       InvokeTag::kStdHash, TagsIn...>::type>
659    size_t operator()(CustomHashType<TagsIn...> t) const {
660      static_assert(MinTag<Tags...>::value == InvokeTag::kStdHash, "");
661      return t.value + static_cast<int>(InvokeTag::kStdHash);
662    }
663  };
664  }  
665  namespace {
666  template <typename... T>
667  void TestCustomHashType(InvokeTagConstant<InvokeTag::kNone>, T...) {
668    using type = CustomHashType<T::value...>;
669    SCOPED_TRACE(testing::PrintToString(std::vector<InvokeTag>{T::value...}));
670    EXPECT_TRUE(is_hashable<type>());
671    EXPECT_TRUE(is_hashable<const type>());
672    EXPECT_TRUE(is_hashable<const type&>());
673    const size_t offset = static_cast<int>(std::min({T::value...}));
674    EXPECT_EQ(SpyHash(type(7)), SpyHash(size_t{7 + offset}));
675  }
676  void TestCustomHashType(InvokeTagConstant<InvokeTag::kNone>) {
677  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
678    using type = CustomHashType<>;
679    EXPECT_FALSE(is_hashable<type>());
680    EXPECT_FALSE(is_hashable<const type>());
681    EXPECT_FALSE(is_hashable<const type&>());
682  #endif  
683  }
684  template <InvokeTag Tag, typename... T>
685  void TestCustomHashType(InvokeTagConstant<Tag> tag, T... t) {
686    constexpr auto next = static_cast<InvokeTag>(static_cast<int>(Tag) + 1);
687    TestCustomHashType(InvokeTagConstant<next>(), tag, t...);
688    TestCustomHashType(InvokeTagConstant<next>(), t...);
689  }
690  TEST(HashTest, CustomHashType) {
691    TestCustomHashType(InvokeTagConstant<InvokeTag{}>());
692  }
693  TEST(HashTest, NoOpsAreEquivalent) {
694    EXPECT_EQ(Hash<NoOp>()({}), Hash<NoOp>()({}));
695    EXPECT_EQ(Hash<NoOp>()({}), Hash<EmptyCombine>()({}));
696  }
697  template <typename T>
698  class HashIntTest : public testing::Test {
699  };
700  TYPED_TEST_SUITE_P(HashIntTest);
701  TYPED_TEST_P(HashIntTest, BasicUsage) {
702    EXPECT_NE(Hash<NoOp>()({}), Hash<TypeParam>()(0));
703    EXPECT_NE(Hash<NoOp>()({}),
704              Hash<TypeParam>()(std::numeric_limits<TypeParam>::max()));
705    if (std::numeric_limits<TypeParam>::min() != 0) {
706      EXPECT_NE(Hash<NoOp>()({}),
707                Hash<TypeParam>()(std::numeric_limits<TypeParam>::min()));
708    }
709    EXPECT_EQ(Hash<CombineIterative<TypeParam>>()({}),
710              Hash<CombineVariadic<TypeParam>>()({}));
711  }
712  REGISTER_TYPED_TEST_SUITE_P(HashIntTest, BasicUsage);
713  using IntTypes = testing::Types<unsigned char, char, int, int32_t, int64_t,
714                                  uint32_t, uint64_t, size_t>;
715  INSTANTIATE_TYPED_TEST_SUITE_P(My, HashIntTest, IntTypes);
716  struct StructWithPadding {
717    char c;
718    int i;
719    template <typename H>
720    friend H AbslHashValue(H hash_state, const StructWithPadding& s) {
721      return H::combine(std::move(hash_state), s.c, s.i);
722    }
723  };
724  static_assert(sizeof(StructWithPadding) > sizeof(char) + sizeof(int),
725                "StructWithPadding doesn't have padding");
726  static_assert(std::is_standard_layout<StructWithPadding>::value, "");
727  template <typename T>
728  struct ArraySlice {
729    T* begin;
730    T* end;
731    template <typename H>
732    friend H AbslHashValue(H hash_state, const ArraySlice& slice) {
733      for (auto t = slice.begin; t != slice.end; ++t) {
734        hash_state = H::combine(std::move(hash_state), *t);
735      }
736      return hash_state;
737    }
738  };
739  TEST(HashTest, HashNonUniquelyRepresentedType) {
740    static const size_t kNumStructs = 10;
741    unsigned char buffer1[kNumStructs * sizeof(StructWithPadding)];
742    std::memset(buffer1, 0, sizeof(buffer1));
743    auto* s1 = reinterpret_cast<StructWithPadding*>(buffer1);
744    unsigned char buffer2[kNumStructs * sizeof(StructWithPadding)];
745    std::memset(buffer2, 255, sizeof(buffer2));
746    auto* s2 = reinterpret_cast<StructWithPadding*>(buffer2);
747    for (size_t i = 0; i < kNumStructs; ++i) {
748      SCOPED_TRACE(i);
749      s1[i].c = s2[i].c = static_cast<char>('0' + i);
750      s1[i].i = s2[i].i = static_cast<int>(i);
751      ASSERT_FALSE(memcmp(buffer1 + i * sizeof(StructWithPadding),
752                          buffer2 + i * sizeof(StructWithPadding),
753                          sizeof(StructWithPadding)) == 0)
754          << "Bug in test code: objects do not have unequal"
755          << " object representations";
756    }
757    EXPECT_EQ(Hash<StructWithPadding>()(s1[0]), Hash<StructWithPadding>()(s2[0]));
758    EXPECT_EQ(Hash<ArraySlice<StructWithPadding>>()({s1, s1 + kNumStructs}),
759              Hash<ArraySlice<StructWithPadding>>()({s2, s2 + kNumStructs}));
760  }
761  TEST(HashTest, StandardHashContainerUsage) {
762    std::unordered_map<int, std::string, Hash<int>> map = {{0, "foo"},
763                                                           {42, "bar"}};
764    EXPECT_NE(map.find(0), map.end());
765    EXPECT_EQ(map.find(1), map.end());
766    EXPECT_NE(map.find(0u), map.end());
767  }
768  struct ConvertibleFromNoOp {
769    ConvertibleFromNoOp(NoOp) {}  
770    template <typename H>
771    friend H AbslHashValue(H hash_state, ConvertibleFromNoOp) {
772      return H::combine(std::move(hash_state), 1);
773    }
774  };
775  TEST(HashTest, HeterogeneousCall) {
776    EXPECT_NE(Hash<ConvertibleFromNoOp>()(NoOp()),
777              Hash<NoOp>()(NoOp()));
778  }
779  TEST(IsUniquelyRepresentedTest, SanityTest) {
780    using absl::hash_internal::is_uniquely_represented;
781    EXPECT_TRUE(is_uniquely_represented<unsigned char>::value);
782    EXPECT_TRUE(is_uniquely_represented<int>::value);
783    EXPECT_FALSE(is_uniquely_represented<bool>::value);
784    EXPECT_FALSE(is_uniquely_represented<int*>::value);
785  }
786  struct IntAndString {
787    int i;
788    std::string s;
789    template <typename H>
790    friend H AbslHashValue(H hash_state, IntAndString int_and_string) {
791      return H::combine(std::move(hash_state), int_and_string.s,
792                        int_and_string.i);
793    }
794  };
795  TEST(HashTest, SmallValueOn64ByteBoundary) {
796    Hash<IntAndString>()(IntAndString{0, std::string(63, '0')});
797  }
798  TEST(HashTest, TypeErased) {
799    EXPECT_TRUE((is_hashable<TypeErasedValue<size_t>>::value));
800    EXPECT_TRUE((is_hashable<std::pair<TypeErasedValue<size_t>, int>>::value));
801    EXPECT_EQ(SpyHash(TypeErasedValue<size_t>(7)), SpyHash(size_t{7}));
802    EXPECT_NE(SpyHash(TypeErasedValue<size_t>(7)), SpyHash(size_t{13}));
803    EXPECT_EQ(SpyHash(std::make_pair(TypeErasedValue<size_t>(7), 17)),
804              SpyHash(std::make_pair(size_t{7}, 17)));
805    absl::flat_hash_set<absl::flat_hash_set<int>> ss = {{1, 2}, {3, 4}};
806    TypeErasedContainer<absl::flat_hash_set<absl::flat_hash_set<int>>> es = {
807        absl::flat_hash_set<int>{1, 2}, {3, 4}};
808    absl::flat_hash_set<TypeErasedContainer<absl::flat_hash_set<int>>> se = {
809        {1, 2}, {3, 4}};
810    EXPECT_EQ(SpyHash(ss), SpyHash(es));
811    EXPECT_EQ(SpyHash(ss), SpyHash(se));
812  }
813  struct ValueWithBoolConversion {
814    operator bool() const { return false; }
815    int i;
816  };
817  }  
818  namespace std {
819  template <>
820  struct hash<ValueWithBoolConversion> {
821    size_t operator()(ValueWithBoolConversion v) {
822      return static_cast<size_t>(v.i);
823    }
824  };
825  }  
826  namespace {
827  TEST(HashTest, DoesNotUseImplicitConversionsToBool) {
828    EXPECT_NE(absl::Hash<ValueWithBoolConversion>()(ValueWithBoolConversion{0}),
829              absl::Hash<ValueWithBoolConversion>()(ValueWithBoolConversion{1}));
830  }
831  TEST(HashOf, MatchesHashForSingleArgument) {
832    std::string s = "forty two";
833    double d = 42.0;
834    std::tuple<int, int> t{4, 2};
835    int i = 42;
836    int neg_i = -42;
837    int16_t i16 = 42;
838    int16_t neg_i16 = -42;
839    int8_t i8 = 42;
840    int8_t neg_i8 = -42;
841    EXPECT_EQ(absl::HashOf(s), absl::Hash<std::string>{}(s));
842    EXPECT_EQ(absl::HashOf(d), absl::Hash<double>{}(d));
843    EXPECT_EQ(absl::HashOf(t), (absl::Hash<std::tuple<int, int>>{}(t)));
844    EXPECT_EQ(absl::HashOf(i), absl::Hash<int>{}(i));
845    EXPECT_EQ(absl::HashOf(neg_i), absl::Hash<int>{}(neg_i));
846    EXPECT_EQ(absl::HashOf(i16), absl::Hash<int16_t>{}(i16));
847    EXPECT_EQ(absl::HashOf(neg_i16), absl::Hash<int16_t>{}(neg_i16));
848    EXPECT_EQ(absl::HashOf(i8), absl::Hash<int8_t>{}(i8));
849    EXPECT_EQ(absl::HashOf(neg_i8), absl::Hash<int8_t>{}(neg_i8));
850  }
851  TEST(HashOf, MatchesHashOfTupleForMultipleArguments) {
852    std::string hello = "hello";
853    std::string world = "world";
854    EXPECT_EQ(absl::HashOf(), absl::HashOf(std::make_tuple()));
855    EXPECT_EQ(absl::HashOf(hello), absl::HashOf(std::make_tuple(hello)));
856    EXPECT_EQ(absl::HashOf(hello, world),
857              absl::HashOf(std::make_tuple(hello, world)));
858  }
859  template <typename T>
860  std::true_type HashOfExplicitParameter(decltype(absl::HashOf<T>(0))) {
861    return {};
862  }
863  template <typename T>
864  std::false_type HashOfExplicitParameter(size_t) {
865    return {};
866  }
867  TEST(HashOf, CantPassExplicitTemplateParameters) {
868    EXPECT_FALSE(HashOfExplicitParameter<int>(0));
869  }
870  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cordz_info.h"
2  #include <vector>
3  #include "gmock/gmock.h"
4  #include "gtest/gtest.h"
5  #include "absl/base/config.h"
6  #include "absl/debugging/stacktrace.h"
7  #include "absl/debugging/symbolize.h"
8  #include "absl/strings/cordz_test_helpers.h"
9  #include "absl/strings/internal/cord_rep_flat.h"
10  #include "absl/strings/internal/cordz_handle.h"
11  #include "absl/strings/internal/cordz_statistics.h"
12  #include "absl/strings/internal/cordz_update_tracker.h"
13  #include "absl/strings/str_cat.h"
14  #include "absl/types/span.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace cord_internal {
18  namespace {
19  using ::testing::ElementsAre;
20  using ::testing::Eq;
21  using ::testing::HasSubstr;
22  using ::testing::Ne;
23  using ::testing::SizeIs;
24  auto constexpr kUnknownMethod = CordzUpdateTracker::kUnknown;
25  auto constexpr kTrackCordMethod = CordzUpdateTracker::kConstructorString;
26  auto constexpr kChildMethod = CordzUpdateTracker::kConstructorCord;
27  auto constexpr kUpdateMethod = CordzUpdateTracker::kAppendString;
28  std::vector<const CordzHandle*> DeleteQueue() {
29    return CordzHandle::DiagnosticsGetDeleteQueue();
30  }
31  std::string FormatStack(absl::Span<void* const> raw_stack) {
32    static constexpr size_t buf_size = 1 << 14;
<span onclick='openModal()' class='match'>33    std::unique_ptr<char[]> buf(new char[buf_size]);
34    std::string output;
</span>35    for (void* stackp : raw_stack) {
36      if (absl::Symbolize(stackp, buf.get(), buf_size)) {
37        absl::StrAppend(&output, "    ", buf.get(), "\n");
38      }
39    }
40    return output;
41  }
42  TEST(CordzInfoTest, TrackCord) {
43    TestCordData data;
44    CordzInfo::TrackCord(data.data, kTrackCordMethod);
45    CordzInfo* info = data.data.cordz_info();
46    ASSERT_THAT(info, Ne(nullptr));
47    EXPECT_FALSE(info->is_snapshot());
48    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
49    EXPECT_THAT(info->GetCordRepForTesting(), Eq(data.rep.rep));
50    info->Untrack();
51  }
52  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSampling) {
53    CordzSamplingIntervalHelper sample_none(99999);
54    TestCordData parent, child;
55    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
56    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
57  }
58  TEST(CordzInfoTest, MaybeTrackChildCordWithSampling) {
59    CordzSamplingIntervalHelper sample_all(1);
60    TestCordData parent, child;
61    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
62    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
63  }
64  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingParentSampled) {
65    CordzSamplingIntervalHelper sample_none(99999);
66    TestCordData parent, child;
67    CordzInfo::TrackCord(parent.data, kTrackCordMethod);
68    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
69    CordzInfo* parent_info = parent.data.cordz_info();
70    CordzInfo* child_info = child.data.cordz_info();
71    ASSERT_THAT(child_info, Ne(nullptr));
72    EXPECT_THAT(child_info->GetCordRepForTesting(), Eq(child.rep.rep));
73    EXPECT_THAT(child_info->GetParentStack(), parent_info->GetStack());
74    parent_info->Untrack();
75    child_info->Untrack();
76  }
77  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingChildSampled) {
78    CordzSamplingIntervalHelper sample_none(99999);
79    TestCordData parent, child;
80    CordzInfo::TrackCord(child.data, kTrackCordMethod);
81    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
82    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
83  }
84  TEST(CordzInfoTest, MaybeTrackChildCordWithSamplingChildSampled) {
85    CordzSamplingIntervalHelper sample_all(1);
86    TestCordData parent, child;
87    CordzInfo::TrackCord(child.data, kTrackCordMethod);
88    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
89    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
90  }
91  TEST(CordzInfoTest, UntrackCord) {
92    TestCordData data;
93    CordzInfo::TrackCord(data.data, kTrackCordMethod);
94    CordzInfo* info = data.data.cordz_info();
95    info->Untrack();
96    EXPECT_THAT(DeleteQueue(), SizeIs(0u));
97  }
98  TEST(CordzInfoTest, UntrackCordWithSnapshot) {
99    TestCordData data;
100    CordzInfo::TrackCord(data.data, kTrackCordMethod);
101    CordzInfo* info = data.data.cordz_info();
102    CordzSnapshot snapshot;
103    info->Untrack();
104    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
105    EXPECT_THAT(info->GetCordRepForTesting(), Eq(data.rep.rep));
106    EXPECT_THAT(DeleteQueue(), ElementsAre(info, &snapshot));
107  }
108  TEST(CordzInfoTest, SetCordRep) {
109    TestCordData data;
110    CordzInfo::TrackCord(data.data, kTrackCordMethod);
111    CordzInfo* info = data.data.cordz_info();
112    TestCordRep rep;
113    info->Lock(CordzUpdateTracker::kAppendCord);
114    info->SetCordRep(rep.rep);
115    info->Unlock();
116    EXPECT_THAT(info->GetCordRepForTesting(), Eq(rep.rep));
117    info->Untrack();
118  }
119  TEST(CordzInfoTest, SetCordRepNullUntracksCordOnUnlock) {
120    TestCordData data;
121    CordzInfo::TrackCord(data.data, kTrackCordMethod);
122    CordzInfo* info = data.data.cordz_info();
123    info->Lock(CordzUpdateTracker::kAppendString);
124    info->SetCordRep(nullptr);
125    EXPECT_THAT(info->GetCordRepForTesting(), Eq(nullptr));
126    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
127    info->Unlock();
128    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
129  }
130  TEST(CordzInfoTest, RefCordRep) {
131    TestCordData data;
132    CordzInfo::TrackCord(data.data, kTrackCordMethod);
133    CordzInfo* info = data.data.cordz_info();
134    size_t refcount = data.rep.rep->refcount.Get();
135    EXPECT_THAT(info->RefCordRep(), Eq(data.rep.rep));
136    EXPECT_THAT(data.rep.rep->refcount.Get(), Eq(refcount + 1));
137    CordRep::Unref(data.rep.rep);
138    info->Untrack();
139  }
140  #if GTEST_HAS_DEATH_TEST
141  TEST(CordzInfoTest, SetCordRepRequiresMutex) {
142    TestCordData data;
143    CordzInfo::TrackCord(data.data, kTrackCordMethod);
144    CordzInfo* info = data.data.cordz_info();
145    TestCordRep rep;
146    EXPECT_DEBUG_DEATH(info->SetCordRep(rep.rep), ".*");
147    info->Untrack();
148  }
149  #endif  
150  TEST(CordzInfoTest, TrackUntrackHeadFirstV2) {
151    CordzSnapshot snapshot;
152    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
153    TestCordData data;
154    CordzInfo::TrackCord(data.data, kTrackCordMethod);
155    CordzInfo* info1 = data.data.cordz_info();
156    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
157    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
158    TestCordData data2;
159    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
160    CordzInfo* info2 = data2.data.cordz_info();
161    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
162    EXPECT_THAT(info2->Next(snapshot), Eq(info1));
163    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
164    info2->Untrack();
165    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
166    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
167    info1->Untrack();
168    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
169  }
170  TEST(CordzInfoTest, TrackUntrackTailFirstV2) {
171    CordzSnapshot snapshot;
172    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
173    TestCordData data;
174    CordzInfo::TrackCord(data.data, kTrackCordMethod);
175    CordzInfo* info1 = data.data.cordz_info();
176    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
177    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
178    TestCordData data2;
179    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
180    CordzInfo* info2 = data2.data.cordz_info();
181    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
182    EXPECT_THAT(info2->Next(snapshot), Eq(info1));
183    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
184    info1->Untrack();
185    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
186    EXPECT_THAT(info2->Next(snapshot), Eq(nullptr));
187    info2->Untrack();
188    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
189  }
190  TEST(CordzInfoTest, StackV2) {
191    TestCordData data;
192    static constexpr int kMaxStackDepth = 50;
193    CordzInfo::TrackCord(data.data, kTrackCordMethod);
194    CordzInfo* info = data.data.cordz_info();
195    std::vector<void*> local_stack;
196    local_stack.resize(kMaxStackDepth);
197    local_stack.resize(static_cast<size_t>(
198        absl::GetStackTrace(local_stack.data(), kMaxStackDepth,
199                            1)));
200    std::string got_stack = FormatStack(info->GetStack());
201    std::string expected_stack = FormatStack(local_stack);
202    EXPECT_THAT(got_stack, HasSubstr(expected_stack));
203    info->Untrack();
204  }
205  CordzInfo* TrackChildCord(InlineData& data, const InlineData& parent) {
206    CordzInfo::TrackCord(data, parent, kChildMethod);
207    return data.cordz_info();
208  }
209  CordzInfo* TrackParentCord(InlineData& data) {
210    CordzInfo::TrackCord(data, kTrackCordMethod);
211    return data.cordz_info();
212  }
213  TEST(CordzInfoTest, GetStatistics) {
214    TestCordData data;
215    CordzInfo* info = TrackParentCord(data.data);
216    CordzStatistics statistics = info->GetCordzStatistics();
217    EXPECT_THAT(statistics.size, Eq(data.rep.rep->length));
218    EXPECT_THAT(statistics.method, Eq(kTrackCordMethod));
219    EXPECT_THAT(statistics.parent_method, Eq(kUnknownMethod));
220    EXPECT_THAT(statistics.update_tracker.Value(kTrackCordMethod), Eq(1));
221    info->Untrack();
222  }
223  TEST(CordzInfoTest, LockCountsMethod) {
224    TestCordData data;
225    CordzInfo* info = TrackParentCord(data.data);
226    info->Lock(kUpdateMethod);
227    info->Unlock();
228    info->Lock(kUpdateMethod);
229    info->Unlock();
230    CordzStatistics statistics = info->GetCordzStatistics();
231    EXPECT_THAT(statistics.update_tracker.Value(kUpdateMethod), Eq(2));
232    info->Untrack();
233  }
234  TEST(CordzInfoTest, FromParent) {
235    TestCordData parent;
236    TestCordData child;
237    CordzInfo* info_parent = TrackParentCord(parent.data);
238    CordzInfo* info_child = TrackChildCord(child.data, parent.data);
239    std::string stack = FormatStack(info_parent->GetStack());
240    std::string parent_stack = FormatStack(info_child->GetParentStack());
241    EXPECT_THAT(stack, Eq(parent_stack));
242    CordzStatistics statistics = info_child->GetCordzStatistics();
243    EXPECT_THAT(statistics.size, Eq(child.rep.rep->length));
244    EXPECT_THAT(statistics.method, Eq(kChildMethod));
245    EXPECT_THAT(statistics.parent_method, Eq(kTrackCordMethod));
246    EXPECT_THAT(statistics.update_tracker.Value(kChildMethod), Eq(1));
247    info_parent->Untrack();
248    info_child->Untrack();
249  }
250  }  
251  }  
252  ABSL_NAMESPACE_END
253  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>117    std::unique_ptr<char[]> data(new char[kTotalSize]);
118    constexpr size_t kLog2NumValues = 5;
</pre></code></div>
                <div class="column column_space"><pre><code>33    std::unique_ptr<char[]> buf(new char[buf_size]);
34    std::string output;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    