
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.435233160621761%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.h</h3>
            <pre><code>1  #ifndef TESSERACT_TEXTORD_COLPARTITION_H_
2  #define TESSERACT_TEXTORD_COLPARTITION_H_
3  #include "bbgrid.h"
4  #include "blobbox.h" 
5  #include "ocrblock.h"
6  #include "rect.h" 
7  #include "scrollview.h"
8  #include "tabfind.h"   
9  #include "tabvector.h" 
10  #include <algorithm>
11  namespace tesseract {
12  const int kRGBRMSColors = 4;
13  class ColPartition;
14  class ColPartitionSet;
15  class ColPartitionGrid;
16  class WorkingPartSet;
17  class WorkingPartSet_LIST;
18  enum ColumnSpanningType {
19    CST_NOISE,   
20    CST_FLOWING, 
21    CST_HEADING, 
22    CST_PULLOUT, 
23    CST_COUNT    
24  };
25  ELIST2IZEH(ColPartition)
26  CLISTIZEH(ColPartition)
27  class TESS_API ColPartition : public ELIST2_LINK {
28  public:
29    ColPartition() = default;
30    ColPartition(BlobRegionType blob_type, const ICOORD &vertical);
31    static ColPartition *MakeLinePartition(BlobRegionType blob_type,
32                                           const ICOORD &vertical, int left,
33                                           int bottom, int right, int top);
34    static ColPartition *FakePartition(const TBOX &box, PolyBlockType block_type,
35                                       BlobRegionType blob_type,
36                                       BlobTextFlowType flow);
37    static ColPartition *MakeBigPartition(BLOBNBOX *box,
38                                          ColPartition_LIST *big_part_list);
39    ~ColPartition();
40    const TBOX &bounding_box() const {
41      return bounding_box_;
42    }
43    int left_margin() const {
44      return left_margin_;
45    }
46    void set_left_margin(int margin) {
47      left_margin_ = margin;
48    }
49    int right_margin() const {
50      return right_margin_;
51    }
52    void set_right_margin(int margin) {
53      right_margin_ = margin;
54    }
55    int median_top() const {
56      return median_top_;
57    }
58    int median_bottom() const {
59      return median_bottom_;
60    }
61    int median_left() const {
62      return median_left_;
63    }
64    int median_right() const {
65      return median_right_;
66    }
67    int median_height() const {
68      return median_height_;
69    }
70    void set_median_height(int height) {
71      median_height_ = height;
72    }
73    int median_width() const {
74      return median_width_;
75    }
76    void set_median_width(int width) {
77      median_width_ = width;
78    }
79    BlobRegionType blob_type() const {
80      return blob_type_;
81    }
82    void set_blob_type(BlobRegionType t) {
83      blob_type_ = t;
84    }
85    BlobTextFlowType flow() const {
86      return flow_;
87    }
88    void set_flow(BlobTextFlowType f) {
89      flow_ = f;
90    }
91    int good_blob_score() const {
92      return good_blob_score_;
93    }
94    bool good_width() const {
95      return good_width_;
96    }
97    bool good_column() const {
98      return good_column_;
99    }
<span onclick='openModal()' class='match'>100    bool left_key_tab() const {
101      return left_key_tab_;
102    }
103    int left_key() const {
104      return left_key_;
105    }
106    bool right_key_tab() const {
</span>107      return right_key_tab_;
108    }
109    int right_key() const {
110      return right_key_;
111    }
112    PolyBlockType type() const {
113      return type_;
114    }
115    void set_type(PolyBlockType t) {
116      type_ = t;
117    }
118    BLOBNBOX_CLIST *boxes() {
119      return &boxes_;
120    }
121    int boxes_count() const {
122      return boxes_.length();
123    }
124    void set_vertical(const ICOORD &v) {
125      vertical_ = v;
126    }
127    ColPartition_CLIST *upper_partners() {
128      return &upper_partners_;
129    }
130    ColPartition_CLIST *lower_partners() {
131      return &lower_partners_;
132    }
133    void set_working_set(WorkingPartSet *working_set) {
134      working_set_ = working_set;
135    }
136    bool block_owned() const {
137      return block_owned_;
138    }
139    void set_block_owned(bool owned) {
140      block_owned_ = owned;
141    }
142    bool desperately_merged() const {
143      return desperately_merged_;
144    }
145    ColPartitionSet *column_set() const {
146      return column_set_;
147    }
148    void set_side_step(int step) {
149      side_step_ = step;
150    }
151    int bottom_spacing() const {
152      return bottom_spacing_;
153    }
154    void set_bottom_spacing(int spacing) {
155      bottom_spacing_ = spacing;
156    }
157    int top_spacing() const {
158      return top_spacing_;
159    }
160    void set_top_spacing(int spacing) {
161      top_spacing_ = spacing;
162    }
163    void set_table_type() {
164      if (type_ != PT_TABLE) {
165        type_before_table_ = type_;
166        type_ = PT_TABLE;
167      }
168    }
169    void clear_table_type() {
170      if (type_ == PT_TABLE) {
171        type_ = type_before_table_;
172      }
173    }
174    bool inside_table_column() {
175      return inside_table_column_;
176    }
177    void set_inside_table_column(bool val) {
178      inside_table_column_ = val;
179    }
180    ColPartition *nearest_neighbor_above() const {
181      return nearest_neighbor_above_;
182    }
183    void set_nearest_neighbor_above(ColPartition *part) {
184      nearest_neighbor_above_ = part;
185    }
186    ColPartition *nearest_neighbor_below() const {
187      return nearest_neighbor_below_;
188    }
189    void set_nearest_neighbor_below(ColPartition *part) {
190      nearest_neighbor_below_ = part;
191    }
192    int space_above() const {
193      return space_above_;
194    }
195    void set_space_above(int space) {
196      space_above_ = space;
197    }
198    int space_below() const {
199      return space_below_;
200    }
201    void set_space_below(int space) {
202      space_below_ = space;
203    }
204    int space_to_left() const {
205      return space_to_left_;
206    }
207    void set_space_to_left(int space) {
208      space_to_left_ = space;
209    }
210    int space_to_right() const {
211      return space_to_right_;
212    }
213    void set_space_to_right(int space) {
214      space_to_right_ = space;
215    }
216    uint8_t *color1() {
217      return color1_;
218    }
219    uint8_t *color2() {
220      return color2_;
221    }
222    bool owns_blobs() const {
223      return owns_blobs_;
224    }
225    void set_owns_blobs(bool owns_blobs) {
226      ASSERT_HOST(boxes_.empty());
227      owns_blobs_ = owns_blobs;
228    }
229    int MidY() const {
230      return (bounding_box_.top() + bounding_box_.bottom()) / 2;
231    }
232    int MedianY() const {
233      return (median_top_ + median_bottom_) / 2;
234    }
235    int MidX() const {
236      return (bounding_box_.left() + bounding_box_.right()) / 2;
237    }
238    int SortKey(int x, int y) const {
239      return TabVector::SortKey(vertical_, x, y);
240    }
241    int XAtY(int sort_key, int y) const {
242      return TabVector::XAtY(vertical_, sort_key, y);
243    }
244    int KeyWidth(int left_key, int right_key) const {
245      return (right_key - left_key) / vertical_.y();
246    }
247    int ColumnWidth() const {
248      return KeyWidth(left_key_, right_key_);
249    }
250    int BoxLeftKey() const {
251      return SortKey(bounding_box_.left(), MidY());
252    }
253    int BoxRightKey() const {
254      return SortKey(bounding_box_.right(), MidY());
255    }
256    int LeftAtY(int y) const {
257      return XAtY(left_key_, y);
258    }
259    int RightAtY(int y) const {
260      return XAtY(right_key_, y);
261    }
262    bool IsLeftOf(const ColPartition &other) const {
263      return bounding_box_.right() < other.bounding_box_.right();
264    }
265    bool ColumnContains(int x, int y) const {
266      return LeftAtY(y) - 1 <= x && x <= RightAtY(y) + 1;
267    }
268    bool IsEmpty() const {
269      return boxes_.empty();
270    }
271    bool IsSingleton() const {
272      return boxes_.singleton();
273    }
274    bool HOverlaps(const ColPartition &other) const {
275      return bounding_box_.x_overlap(other.bounding_box_);
276    }
277    bool VOverlaps(const ColPartition &other) const {
278      return bounding_box_.y_gap(other.bounding_box_) < 0;
279    }
280    int VCoreOverlap(const ColPartition &other) const {
281      if (median_bottom_ == INT32_MAX || other.median_bottom_ == INT32_MAX) {
282        return 0;
283      }
284      return std::min(median_top_, other.median_top_) -
285             std::max(median_bottom_, other.median_bottom_);
286    }
287    int HCoreOverlap(const ColPartition &other) const {
288      return std::min(median_right_, other.median_right_) -
289             std::max(median_left_, other.median_left_);
290    }
291    bool VSignificantCoreOverlap(const ColPartition &other) const {
292      if (median_bottom_ == INT32_MAX || other.median_bottom_ == INT32_MAX) {
293        return false;
294      }
295      int overlap = VCoreOverlap(other);
296      int height = std::min(median_top_ - median_bottom_,
297                            other.median_top_ - other.median_bottom_);
298      return overlap * 3 > height;
299    }
300    bool WithinSameMargins(const ColPartition &other) const {
301      return left_margin_ <= other.bounding_box_.left() &&
302             bounding_box_.left() >= other.left_margin_ &&
303             bounding_box_.right() <= other.right_margin_ &&
304             right_margin_ >= other.bounding_box_.right();
305    }
306    bool TypesMatch(const ColPartition &other) const {
307      return TypesMatch(blob_type_, other.blob_type_);
308    }
309    static bool TypesMatch(BlobRegionType type1, BlobRegionType type2) {
310      return (type1 == type2 || type1 == BRT_UNKNOWN || type2 == BRT_UNKNOWN) &&
311             !BLOBNBOX::IsLineType(type1) && !BLOBNBOX::IsLineType(type2);
312    }
313    static bool TypesSimilar(PolyBlockType type1, PolyBlockType type2) {
314      return (type1 == type2 ||
315              (type1 == PT_FLOWING_TEXT && type2 == PT_INLINE_EQUATION) ||
316              (type2 == PT_FLOWING_TEXT && type1 == PT_INLINE_EQUATION));
317    }
318    bool IsLineType() const {
319      return PTIsLineType(type_);
320    }
321    bool IsImageType() const {
322      return PTIsImageType(type_);
323    }
324    bool IsTextType() const {
325      return PTIsTextType(type_);
326    }
327    bool IsPulloutType() const {
328      return PTIsPulloutType(type_);
329    }
330    bool IsVerticalType() const {
331      return blob_type_ == BRT_VERT_TEXT || blob_type_ == BRT_VLINE;
332    }
333    bool IsHorizontalType() const {
334      return blob_type_ == BRT_TEXT || blob_type_ == BRT_HLINE;
335    }
336    bool IsUnMergeableType() const {
337      return BLOBNBOX::UnMergeableType(blob_type_) || type_ == PT_NOISE;
338    }
339    bool IsVerticalLine() const {
340      return IsVerticalType() && IsLineType();
341    }
342    bool IsHorizontalLine() const {
343      return IsHorizontalType() && IsLineType();
344    }
345    void AddBox(BLOBNBOX *box);
346    void RemoveBox(BLOBNBOX *box);
347    BLOBNBOX *BiggestBox();
348    TBOX BoundsWithoutBox(BLOBNBOX *box);
349    void ClaimBoxes();
350    void DisownBoxes();
351    void DisownBoxesNoAssert();
352    bool ReleaseNonLeaderBoxes();
353    void DeleteBoxes();
354    void ReflectInYAxis();
355    bool IsLegal();
356    bool MatchingColumns(const ColPartition &other) const;
357    bool MatchingTextColor(const ColPartition &other) const;
358    bool MatchingSizes(const ColPartition &other) const;
359    bool ConfirmNoTabViolation(const ColPartition &other) const;
360    bool MatchingStrokeWidth(const ColPartition &other,
361                             double fractional_tolerance,
362                             double constant_tolerance) const;
363    bool OKDiacriticMerge(const ColPartition &candidate, bool debug) const;
364    void SetLeftTab(const TabVector *tab_vector);
365    void SetRightTab(const TabVector *tab_vector);
366    void CopyLeftTab(const ColPartition &src, bool take_box);
367    void CopyRightTab(const ColPartition &src, bool take_box);
368    int LeftBlobRule() const;
369    int RightBlobRule() const;
370    float SpecialBlobsDensity(const BlobSpecialTextType type) const;
371    int SpecialBlobsCount(const BlobSpecialTextType type);
372    void SetSpecialBlobsDensity(const BlobSpecialTextType type,
373                                const float density);
374    void ComputeSpecialBlobsDensity();
375    void AddPartner(bool upper, ColPartition *partner);
376    void RemovePartner(bool upper, ColPartition *partner);
377    ColPartition *SingletonPartner(bool upper);
378    void Absorb(ColPartition *other, const WidthCallback &cb);
379    bool OKMergeOverlap(const ColPartition &merge1, const ColPartition &merge2,
380                        int ok_box_overlap, bool debug);
381    BLOBNBOX *OverlapSplitBlob(const TBOX &box);
382    ColPartition *SplitAtBlob(BLOBNBOX *split_blob);
383    ColPartition *SplitAt(int split_x);
384    void ComputeLimits();
385    int CountOverlappingBoxes(const TBOX &box);
386    void SetPartitionType(int resolution, ColPartitionSet *columns);
387    PolyBlockType PartitionType(ColumnSpanningType flow) const;
388    void ColumnRange(int resolution, ColPartitionSet *columns, int *first_col,
389                     int *last_col);
390    void SetColumnGoodness(const WidthCallback &cb);
391    bool MarkAsLeaderIfMonospaced();
392    void SetRegionAndFlowTypesFromProjectionValue(int value);
393    void SetBlobTypes();
394    bool HasGoodBaseline();
395    void AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
396                         int resolution, ColPartition_LIST *used_parts,
397                         WorkingPartSet_LIST *working_set);
398    static void LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
399                                  int resolution, ColPartition_LIST *block_parts,
400                                  ColPartition_LIST *used_parts,
401                                  BLOCK_LIST *completed_blocks,
402                                  TO_BLOCK_LIST *to_blocks);
403    static TO_BLOCK *MakeBlock(const ICOORD &bleft, const ICOORD &tright,
404                               ColPartition_LIST *block_parts,
405                               ColPartition_LIST *used_parts);
406    static TO_BLOCK *MakeVerticalTextBlock(const ICOORD &bleft,
407                                           const ICOORD &tright,
408                                           ColPartition_LIST *block_parts,
409                                           ColPartition_LIST *used_parts);
410    TO_ROW *MakeToRow();
411    ColPartition *ShallowCopy() const;
412    ColPartition *CopyButDontOwnBlobs();
413  #ifndef GRAPHICS_DISABLED
414    ScrollView::Color BoxColor() const;
415  #endif 
416    void Print() const;
417    void PrintColors();
418    void SmoothPartnerRun(int working_set_count);
419    void RefinePartners(PolyBlockType type, bool get_desperate,
420                        ColPartitionGrid *grid);
421    bool IsInSameColumnAs(const ColPartition &part) const;
422    static int SortByBBox(const void *p1, const void *p2) {
423      const ColPartition *part1 = *static_cast<const ColPartition *const *>(p1);
424      const ColPartition *part2 = *static_cast<const ColPartition *const *>(p2);
425      int mid_y1 = part1->bounding_box_.y_middle();
426      int mid_y2 = part2->bounding_box_.y_middle();
427      if ((part2->bounding_box_.bottom() <= mid_y1 &&
428           mid_y1 <= part2->bounding_box_.top()) ||
429          (part1->bounding_box_.bottom() <= mid_y2 &&
430           mid_y2 <= part1->bounding_box_.top())) {
431        return part1->bounding_box_.x_middle() - part2->bounding_box_.x_middle();
432      }
433      return mid_y2 - mid_y1;
434    }
435    void set_first_column(int column) {
436      first_column_ = column;
437    }
438    void set_last_column(int column) {
439      last_column_ = column;
440    }
441  private:
442    void RefinePartnersInternal(bool upper, bool get_desperate,
443                                ColPartitionGrid *grid);
444    void RefinePartnersByType(bool upper, ColPartition_CLIST *partners);
445    void RefinePartnerShortcuts(bool upper, ColPartition_CLIST *partners);
446    void RefineTextPartnersByMerge(bool upper, bool desperate,
447                                   ColPartition_CLIST *partners,
448                                   ColPartitionGrid *grid);
449    void RefinePartnersByOverlap(bool upper, ColPartition_CLIST *partners);
450    bool ThisPartitionBetter(BLOBNBOX *bbox, const ColPartition &other);
451    static void SmoothSpacings(int resolution, int page_height,
452                               ColPartition_LIST *parts);
453    static bool OKSpacingBlip(int resolution, int median_spacing,
454                              ColPartition **parts, int offset);
455    bool SpacingEqual(int spacing, int resolution) const;
456    bool SpacingsEqual(const ColPartition &other, int resolution) const;
457    bool SummedSpacingOK(const ColPartition &other, int spacing,
458                         int resolution) const;
459    int BottomSpacingMargin(int resolution) const;
460    int TopSpacingMargin(int resolution) const;
461    bool SizesSimilar(const ColPartition &other) const;
462    static void LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start, ICOORD *end);
463    static void RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
464                             ICOORD *end);
465    int left_margin_ = 0;
466    int right_margin_ = 0;
467    TBOX bounding_box_;
468    int median_bottom_ = 0;
469    int median_top_ = 0;
470    int median_height_ = 0;
471    int median_left_ = 0;
472    int median_right_ = 0;
473    int median_width_ = 0;
474    BlobRegionType blob_type_ = BRT_UNKNOWN;
475    BlobTextFlowType flow_ = BTFT_NONE; 
476    int good_blob_score_ = 0;
477    bool good_width_ = false;
478    bool good_column_ = false;
479    bool left_key_tab_ = false;
480    bool right_key_tab_ = false;
481    int left_key_ = 0;
482    int right_key_ = 0;
483    PolyBlockType type_ = PT_UNKNOWN;
484    ICOORD vertical_;
485    BLOBNBOX_CLIST boxes_;
486    ColPartition_CLIST upper_partners_;
487    ColPartition_CLIST lower_partners_;
488    WorkingPartSet *working_set_ = nullptr;
489    ColPartitionSet *column_set_ = nullptr;
490    bool last_add_was_vertical_ = false;
491    bool block_owned_ = false;
492    bool desperately_merged_ = false;
493    bool owns_blobs_ = true; 
494    int first_column_ = -1;
495    int last_column_ = -1;
496    int side_step_ = 0;      
497    int top_spacing_ = 0;    
498    int bottom_spacing_ = 0; 
499    ColPartition *nearest_neighbor_above_ = nullptr;
500    ColPartition *nearest_neighbor_below_ = nullptr;
501    int space_above_ = 0;    
502    int space_below_ = 0;    
503    int space_to_left_ = 0;  
504    int space_to_right_ = 0; 
505    uint8_t color1_[kRGBRMSColors];
506    uint8_t color2_[kRGBRMSColors];
507    float special_blobs_densities_[BSTT_COUNT];
508    PolyBlockType type_before_table_ = PT_UNKNOWN;
509    bool inside_table_column_ = false;
510  };
511  using ColPartitionGridSearch =
512      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>;
513  } 
514  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.h</h3>
            <pre><code>1  #include "bd.h"
2  class TMath{
3  public:
4    static double E;
5    static double Pi;
6    static double LogOf2;
7    static double Inv(const double& x){IAssert(x!=0.0); return (1.0/x);}
8    static double Sqr(const double& x){return x*x;}
9    static double Sqrt(const double& x){IAssert(!(x<0.0)); return sqrt(x);}
10    static double Log(const double& Val){return log(Val);}
11    static double Log2(const double& Val){return log(Val)/LogOf2;}
12    static double Round(const double& Val){
13      return (Val>0)?floor(Val+0.5):ceil(Val-0.5);}
14    static double Round(const double & Val, int Decs){
15      const double pwr=pow(10.0, Decs); return Round(Val * pwr) / pwr;}
16    static int Fac(const int& Val){
17      if (Val<=1){return 1;} else {return Val*Fac(Val-1);}}
18    static int Choose(const int& N, const int& K){ 
19      return Fac(N)/(Fac(K)*Fac(N-K)); }
20    static uint Pow2(const int& pow){return uint(1u<<pow);}
21    static double Power(const double& Base, const double& Exponent){
22      return exp(log(Base)*Exponent);}
23    template <typename T>
24    static int Sign(const T& Val){return Val<0?-1:(Val>0?1:0);}
25    template <class T>
26    static const T& Mx(const T& LVal, const T& RVal) {
27      return LVal > RVal ? LVal : RVal;}
28    template <class T>
29    static const T& Mn(const T& LVal, const T& RVal){
30      return LVal < RVal ? LVal : RVal;}
31    template <class T>
32    static const T& Mx(const T& Val1, const T& Val2, const T& Val3) {
33      if (Val1 > Val2) {
34        if (Val1 > Val3) return Val1;
35        else return Val3;
36      } else {
37        if (Val2 > Val3) return Val2;
38        else return Val3;
39      }
40    }
41    template <class T>
42    static const T& Mn(const T& Val1, const T& Val2, const T& Val3) {
43      if(Val1 < Val2) {
44        if (Val1 < Val3) return Val1;
45        else return Val3;
46      } else {
47        if (Val2 < Val3) return Val2;
48        else return Val3;
49      }
50    }
51    template <class T>
52    static const T& Median(const T& Val1, const T& Val2, const T& Val3) {
53      if (Val1 < Val2) {
54        if (Val2 < Val3) return Val2;
55        else if (Val3 < Val1) return Val1;
56        else return Val3;
57      } else {
58        if (Val1 < Val3) return Val1;
59        else if (Val3 < Val2)  return Val2;
60        else return Val3;
61      }
62    }
63    template <class T>
64    static const T& InRange(const T& Val, const T& Mn, const T& Mx) {
65      IAssert(Mn <= Mx); return Val < Mn ? Mn : (Val > Mx ? Mx : Val);}
66    template <class T>
67    static bool IsInRange(const T& Val, const T& Mn, const T& Mx) {
68      IAssert(Mn <= Mx); return Val >= Mn && Val <= Mx;}
69    template <class T>
70    static bool IsInEps(const T& Val, const T& Eps) {
71      return Val >= -Eps && Val <= Eps;}
72  };
73  class TSpecFunc{
74  public:
75    static void GammaPSeries&bsol;*gser*/(
76     double& gamser, const double& a, const double& x, double& gln);
77    static void GammaQContFrac&bsol;*gcf*/(
78     double& gammcf, const double& a, const double& x, double& gln);
79    static double GammaQ&bsol;*gammq*/(const double& a, const double& x);
80    static double LnGamma&bsol;*gammln*/(const double& xx);
81    static double BetaCf&bsol;*betacf*/(
82     const double& a, const double& b, const double& x);
83    static double BetaI(const double& a, const double& b, const double& x);
84    static void LinearFit( 
85     const TVec<TFltPr>& XY, double& A, double& B,
86     double& SigA, double& SigB, double& Chi2, double& R2);
87    static void PowerFit( 
88     const TVec<TFltPr>& XY, double& A, double& B,
89     double& SigA, double& SigB, double& Chi2, double& R2);
90    static void LogFit( 
91     const TVec<TFltPr>& XY, double& A, double& B,
92     double& SigA, double& SigB, double& Chi2, double& R2);
93    static void ExpFit( 
94     const TVec<TFltPr>& XY, double& A, double& B,
95     double& SigA, double& SigB, double& Chi2, double& R2);
96  public:
97    static double LnComb(const int& n, const int& k);
98  public:
99    static double Entropy(const TIntV& ValV);
100    static double Entropy(const TFltV& ValV);
101    static void EntropyFracDim(const TIntV& ValV, TFltV& EntropyV);
102    static void EntropyFracDim(const TFltV& ValV, TFltV& EntropyV);
103  public:
104    static double EntropyBias(const double& B); 
105    static double GetPowerCoef(const TFltV& XValV, double MinX=-1.0); 
106    static double GetPowerCoef(const TFltPrV& XValCntV, double MinX=-1.0); 
107  };
108  ClassTPV(TMom, PMom, TMomV)
109  private:
110    TBool DefP;
111    TFltPrV ValWgtV;
112    TFlt SumW, ValSumW;
113    TInt Vals;
114    TBool UsableP;
115    TFlt UnusableVal;
116    TFlt Mn, Mx;
117    TFlt Mean, Vari, SDev, SErr;
118    TFlt Median, Quart1, Quart3;
119    TFlt Mode;
120    TFltV DecileV; 
121    TFltV PercentileV; 
122  public:
123    TMom():
124      DefP(false), ValWgtV(),
125      SumW(), ValSumW(), Vals(),
126      UsableP(false), UnusableVal(-1),
127      Mn(), Mx(),
128      Mean(), Vari(), SDev(), SErr(),
129      Median(), Quart1(), Quart3(), Mode(),
130      DecileV(), PercentileV(){}
131    TMom(const TMom& Mom):
132      DefP(Mom.DefP), ValWgtV(Mom.ValWgtV),
133      SumW(Mom.SumW), ValSumW(Mom.ValSumW), Vals(Mom.Vals),
134      UsableP(Mom.UsableP), UnusableVal(Mom.UnusableVal),
135      Mn(Mom.Mn), Mx(Mom.Mx),
136      Mean(Mom.Mean), Vari(Mom.Vari), SDev(Mom.SDev), SErr(Mom.SErr),
137      Median(Mom.Median), Quart1(Mom.Quart1), Quart3(Mom.Quart3), Mode(Mom.Mode),
138      DecileV(Mom.DecileV), PercentileV(Mom.PercentileV){}
139    static PMom New(){return PMom(new TMom());}
140    static void NewV(TMomV& MomV, const int& Moms){
141      MomV.Gen(Moms); for (int MomN=0; MomN<Moms; MomN++){MomV[MomN]=New();}}
142    static void NewVV(TVVec<PMom>& MomVV, const int& XMoms, const int& YMoms){
143      MomVV.Gen(XMoms, YMoms);
144      for (int XMomN=0; XMomN<XMoms; XMomN++){
145        for (int YMomN=0; YMomN<YMoms; YMomN++){
146          MomVV.At(XMomN, YMomN)=New();}}}
147    TMom(const TFltV& _ValV);
148    static PMom New(const TFltV& ValV){
149      return PMom(new TMom(ValV));}
150    TMom(TSIn& SIn):
151      DefP(SIn),
152      ValWgtV(SIn),
153      SumW(SIn), ValSumW(SIn), Vals(SIn),
154      UsableP(SIn), UnusableVal(SIn),
155      Mn(SIn), Mx(SIn),
156      Mean(SIn), Vari(SIn), SDev(SIn), SErr(SIn),
157      Median(SIn), Quart1(SIn), Quart3(SIn), Mode(SIn),
158      DecileV(SIn), PercentileV(SIn){}
159    static PMom Load(TSIn& SIn){return new TMom(SIn);}
160    void Save(TSOut& SOut) const {
161      DefP.Save(SOut);
162      ValWgtV.Save(SOut);
163      SumW.Save(SOut); ValSumW.Save(SOut); Vals.Save(SOut);
164      UsableP.Save(SOut); UnusableVal.Save(SOut);
165      Mn.Save(SOut); Mx.Save(SOut);
166      Mean.Save(SOut); Vari.Save(SOut); SDev.Save(SOut); SErr.Save(SOut);
167      Median.Save(SOut); Quart1.Save(SOut); Quart3.Save(SOut); Mode.Save(SOut);
168      DecileV.Save(SOut); PercentileV.Save(SOut);}
169    TMom& operator=(const TMom& Mom){
170      Assert(!DefP); DefP=Mom.DefP;
171      ValWgtV=Mom.ValWgtV;
172      SumW=Mom.SumW; ValSumW=Mom.ValSumW; Vals=Mom.Vals;
173      UsableP=Mom.UsableP; UnusableVal=Mom.UnusableVal;
174      Mn=Mom.Mn; Mx=Mom.Mx;
175      Mean=Mom.Mean; Vari=Mom.Vari; SDev=Mom.SDev; SErr=Mom.SErr;
176      Median=Mom.Median; Quart1=Mom.Quart1; Quart3=Mom.Quart3; Mode=Mom.Mode;
177      DecileV=Mom.DecileV; PercentileV=Mom.PercentileV;
178      return *this;}
179    bool operator==(const TMom& Mom) const {
180      return Vals==Mom.Vals;}
181    bool operator<(const TMom& Mom) const {
182      return Vals<Mom.Vals;}
183    void Def();
184    static void DefV(TMomV& MomV){
185      for (int MomN=0; MomN<MomV.Len(); MomN++){MomV[MomN]->Def();}}
186    static void DefVV(TVVec<PMom>& MomVV){
187      for (int XMomN=0; XMomN<MomVV.GetXDim(); XMomN++){
188        for (int YMomN=0; YMomN<MomVV.GetYDim(); YMomN++){
189          MomVV.At(XMomN, YMomN)->Def();}}}
190    bool IsDef() const {return DefP;}
191    void Add(const TFlt& Val, const TFlt& Wgt=1){Assert(!DefP);
192      ValWgtV.Add(TFltPr(Val, Wgt)); SumW+=Wgt; ValSumW+=Wgt*Val; Vals++;}
<span onclick='openModal()' class='match'>193    double GetWgt() const {return SumW;}
194    int GetVals() const {return Vals;}
195    TFlt GetVal(const int& ValN) const {IAssert(!IsDef()); return ValWgtV[ValN].Val1;}
</span>196    bool IsUsable() const {Assert(DefP); return UsableP;}
197    static bool IsUsableV(const TMomV& MomV){
198      for (int MomN=0; MomN<MomV.Len(); MomN++){
199        if (!MomV[MomN]->IsUsable()){return false;}}
200      return true;}
201    static bool IsUsableVV(const TVVec<PMom>& MomVV){
202      for (int XMomN=0; XMomN<MomVV.GetXDim(); XMomN++){
203        for (int YMomN=0; YMomN<MomVV.GetYDim(); YMomN++){
204          if (!MomVV.At(XMomN, YMomN)->IsUsable()){return false;}}}
205      return true;}
206    double GetMn() const {Assert(DefP&&UsableP); return Mn;}
207    double GetMx() const {Assert(DefP&&UsableP); return Mx;}
208    double GetExtent() const {Assert(DefP&&UsableP); return Mx-Mn;}
209    double GetMean() const {Assert(DefP&&UsableP); return Mean;}
210    double GetVari() const {Assert(DefP&&UsableP); return Vari;}
211    double GetSDev() const {Assert(DefP&&UsableP); return SDev;}
212    double GetSErr() const {Assert(DefP&&UsableP); return SErr;}
213    double GetMedian() const {Assert(DefP&&UsableP); return Median;}
214    double GetQuart1() const {Assert(DefP&&UsableP); return Quart1;}
215    double GetQuart3() const {Assert(DefP&&UsableP); return Quart3;}
216    double GetMode() const {Assert(DefP&&UsableP); return Mode;}
217    double GetDecile(const int& DecileN) const {
218      Assert(DefP&&UsableP); return DecileV[DecileN];}
219    double GetPercentile(const int& PercentileN) const {
220      Assert(DefP&&UsableP); return PercentileV[PercentileN];}
221    double GetByNm(const TStr& MomNm) const;
222    TStr GetStrByNm(const TStr& MomNm, char* FmtStr=NULL) const;
223    TStr GetStr(const char& SepCh=' ', const char& DelimCh=':',
224     const bool& DecileP=true, const bool& PercentileP=true, const TStr& FmtStr="%g") const;
225    static TStr GetNmVStr(const TStr& VarPfx,
226     const char& SepCh='\t', const bool& DecileP=true, const bool& PercentileP=true);
227    TStr GetValVStr(const char& SepCh='\t', const bool& DecileP=true, const bool& PercentileP=true) const;
228  };
229  typedef TVVec<PMom> TMomVV;
230  typedef THash<TInt, PMom> TIntMomH;
231  typedef THash<TInt, TMomV> TIntMomVH;
232  typedef THash<TInt, TMomVV> TIntMomVVH;
233  ClassTP(TCorr, PCorr)
234  private:
235    int ValVLen;
236    double CorrCf;
237    double CorrCfPrb;
238    double FisherZ;
239  public:
240    TCorr(){}
241    TCorr(const TFltV& ValV1, const TFltV& ValV2);
242    static PCorr New(const TFltV& ValV1, const TFltV& ValV2){
243      return PCorr(new TCorr(ValV1, ValV2));}
244    TCorr(TSIn&){Fail;}
245    static PCorr Load(TSIn& SIn){return new TCorr(SIn);}
246    void Save(TSOut&){Fail;}
247    TCorr& operator=(const TCorr&){Fail; return *this;}
248    double GetCorrCf() const {return CorrCf;}
249    double GetCorrCfPrb() const {return CorrCfPrb;}
250    TStr GetStr() const;
251  };
252  class TStatTest {
253  private:
254    static void AveVar(const TFltV& ValV, double& Ave, double& Var);
255    static double KsProb(const double& Alam);
256  public:
257    static void ChiSquareOne(
258     const TFltV& ObservedBinV, const TFltV& ExpectedBinV,
259     double& ChiSquareVal, double& SignificancePrb);
260    static void ChiSquareTwo(
261     const TFltV& ObservedBin1V, const TFltV& ObservedBin2V,
262     double& ChiSquareVal, double& SignificancePrb);
263    static void TTest(
264     const TFltV& ValV1, const TFltV& ValV2, double& TTestVal, double& TTestPrb);
265    static void KsTest(const TFltV& ValV1, const TFltV& ValV2, double& DStat, double& PVal);
266    static void KsTest(const TFltPrV& ValCntV1, const TFltPrV& ValCntV2, double& DStat, double& PVal);
267  };
268  ClassTP(TComb, PComb)
269  public:
270    int Items;
271    int Order;
272    int CombN;
273    TIntV ItemV;
274  public:
275    TComb(): Items(-1), Order(-1), CombN(-1), ItemV(){}
276    TComb(const int& _Items, const int& _Order):
277      Items(_Items), Order(_Order), CombN(0), ItemV(){
278      IAssert((Order>0)&&(Order<=Items));}
279    static PComb New(const int& Items, const int& Order){
280      return PComb(new TComb(Items, Order));}
281    ~TComb(){}
282    TComb(TSIn&){Fail;}
283    static PComb Load(TSIn& SIn){return new TComb(SIn);}
284    void Save(TSOut&){Fail;}
285    TComb& operator=(const TComb&){Fail; return *this;}
286    bool GetNext();
287    TIntV& GetItemV(){return ItemV;}
288    int GetCombN() const {return CombN;}
289    int GetCombs() const;
290    void Wr();
291  };
292  ClassTP(TLinReg, PLinReg)
293  public:
294    TFltVV XVV;
295    TFltV YV;
296    TFltV SigV;
297    int Recs, Vars;
298    TFltVV CovarVV; 
299    TFltV CfV; 
300    double ChiSq;
301    void GetXV(const int RecN, TFltV& VarV) const {
302      VarV.Gen(Vars+1);
303      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
304    }
305    double GetY(const int RecN) const {return YV[RecN-1];}
306    double GetSig(const int RecN) const {return SigV[RecN-1];}
307    void NR_covsrt(TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit);
308    void NR_gaussj(TFltVV& a, const int& n, TFltVV& b, const int& m);
309    void NR_lfit();
310  public:
311    TLinReg(){}
312    static PLinReg New(
313     const TFltVV& XVV, const TFltV& YV, const TFltV& SigV=TFltV());
314    ~TLinReg(){}
315    TLinReg(TSIn&){Fail;}
316    static PLinReg Load(TSIn& SIn){return new TLinReg(SIn);}
317    void Save(TSOut&){Fail;}
318    TLinReg& operator=(const TLinReg&){Fail; return *this;}
319    int GetRecs() const {return Recs;}
320    int GetVars() const {return Vars;}
321    double GetCf(const int& VarN) const {return CfV[VarN+1];}
322    double GetCfUncer(const int& VarN) const {
323      return sqrt(double(CovarVV.At(VarN+1, VarN+1)));}
324    double GetCovar(const int& VarN1, const int& VarN2) const {
325      return CovarVV.At(VarN1+1, VarN2+1);}
326    double GetChiSq() const {return ChiSq;}
327    static double LinInterp(const double& x1, const double& y1,
328     const double& x2, const double& y2, const double& AtX) _CMPWARN{
329      if (x1 == x2) return (y1+y2)/2.0;
330      const double k = (y2 - y1) / (x2 - x1);
331      return k*(AtX - x1) + y1;
332    }
333    void Wr() const;
334  };
335  ClassTP(TSvd, PSvd)
336  public:
337    TFltVV XVV;
338    TFltV YV;
339    TFltV SigV;
340    int Recs, Vars;
341    TFltVV CovarVV; 
342    TFltV CfV; 
343    double ChiSq;
344    void GetXV(const int RecN, TFltV& VarV) const {
345      VarV.Gen(Vars+1);
346      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
347    }
348    double GetY(const int RecN) const {return YV[RecN-1];}
349    double GetSig(const int RecN) const {return SigV[RecN-1];}
350    static double NR_SIGN(double a, double b){return b >= 0.0 ? fabs(a) : -fabs(a);}
351    static double NR_FMAX(double maxarg1, double maxarg2){
352      return maxarg1 > maxarg2 ? maxarg1 : maxarg2;}
353    static int NR_IMIN(int iminarg1, int iminarg2){
354      return iminarg1 < iminarg2 ? iminarg1 : iminarg2;}
355    static double NR_pythag(double a, double b);
356    static void NR_svdcmp(TFltVV& a, int m, int n, TFltV& w, TFltVV& v);
357    void NR_svbksb(
358     TFltVV& u, TFltV& w, TFltVV& v, int m, int n, TFltV& b, TFltV& x);
359    void NR_svdvar(TFltVV& v, int ma, TFltV& w, TFltVV& cvm);
360    void NR_svdfit();
361  public:
362    TSvd(){}
363    static PSvd New(
364     const TFltVV& XVV, const TFltV& YV, const TFltV& SigV=TFltV());
365    ~TSvd(){}
366    TSvd(TSIn&){Fail;}
367    static PSvd Load(TSIn& SIn){return new TSvd(SIn);}
368    void Save(TSOut&){Fail;}
369    TSvd& operator=(const TSvd&){Fail; return *this;}
370    int GetRecs() const {return Recs;}
371    int GetVars() const {return Vars;}
372    double GetCf(const int& VarN) const {return CfV[VarN+1];}
373    double GetCfUncer(const int& VarN) const {
374      return sqrt(double(CovarVV.At(VarN+1, VarN+1)));}
375    double GetCovar(const int& VarN1, const int& VarN2) const {
376      return CovarVV.At(VarN1+1, VarN2+1);}
377    double GetChiSq() const {return ChiSq;}
378    void GetCfV(TFltV& _CfV);
379    void GetCfUncerV(TFltV& CfUncerV);
380    static void Svd(const TFltVV& InMtx, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV);
381    static void Svd1Based(const TFltVV& InMtx1, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV);
382    void Wr() const;
383  };
384  class THist {
385  private:
386  	TFlt MnVal;
387  	TFlt MxVal;
388      TIntV BucketV;
389  	TFlt BucketSize;
390      TInt Vals;
391  public:
392      THist() { }
393      THist(const double& _MnVal, const double& _MxVal, const int& Buckets):
394        MnVal(_MnVal), MxVal(_MxVal), BucketV(Buckets) {
395        BucketSize = (MxVal == MnVal) ? 1.0 : (1.01 * double(MxVal - MnVal) / double(Buckets)); }
396      void Add(const double& Val, const bool& OnlyInP);
397  	int GetVals() const { return Vals; }
398  	int GetBuckets() const { return BucketV.Len(); }
399  	double GetBucketMn(const int& BucketN) const { return MnVal + BucketN * BucketSize; }
400  	double GetBucketMx(const int& BucketN) const { return MnVal + (BucketN + 1) * BucketSize; }
401  	int GetBucketVal(const int& BucketN) const { return BucketV[BucketN]; }
402  	double GetBucketValPerc(const int& BucketN) const { 
403  		return (Vals > 0) ? (double(BucketV[BucketN]) / double(Vals)) : 0.0; }
404      void SaveStat(const TStr& ValNm, TSOut& FOut) const;
405      void SaveTxt(const TStr& ValNm, const TStr& FNm) const {
406          TFOut FOut(FNm); SaveStat(ValNm, FOut); }
407  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.h</div>
                <div class="column column_space"><pre><code>100    bool left_key_tab() const {
101      return left_key_tab_;
102    }
103    int left_key() const {
104      return left_key_;
105    }
106    bool right_key_tab() const {
</pre></code></div>
                <div class="column column_space"><pre><code>193    double GetWgt() const {return SumW;}
194    int GetVals() const {return Vals;}
195    TFlt GetVal(const int& ValN) const {IAssert(!IsDef()); return ValWgtV[ValN].Val1;}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    