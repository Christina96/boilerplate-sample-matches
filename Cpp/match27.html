<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for search_1.cpp &amp; search.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for search_1.cpp &amp; search.cpp
      </h3>
<h1 align="center">
        96.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>search_1.cpp (96.680084%)<th>search.cpp (95.43198%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(540-1357)<td><a href="#" name="0">(540-1357)</a><td align="center"><font color="#ff0000">486</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(39-164)<td><a href="#" name="1">(39-164)</a><td align="center"><font color="#3c0000">116</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(320-475)<td><a href="#" name="2">(320-475)</a><td align="center"><font color="#2c0000">85</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1358-1462)<td><a href="#" name="3">(1358-1462)</a><td align="center"><font color="#230000">67</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1535-1624)<td><a href="#" name="4">(1540-1629)</a><td align="center"><font color="#1c0000">54</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(476-537)<td><a href="#" name="5">(476-537)</a><td align="center"><font color="#180000">47</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(165-234)<td><a href="#" name="6">(165-227)</a><td align="center"><font color="#180000">46</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(236-319)<td><a href="#" name="7">(236-319)</a><td align="center"><font color="#130000">37</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1625-1655)<td><a href="#" name="8">(1630-1660)</a><td align="center"><font color="#0c0000">23</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>search_1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;cassert&gt;
3 #include &lt;cfloat&gt;
4 #include &lt;cmath&gt;
5 #include &lt;cstring&gt;
6 #include &lt;iostream&gt;
7 #include &lt;sstream&gt;
8 #include "book.h"
9 #include "evaluate.h"
10 #include "movegen.h"
11 #include "movepick.h"
12 #include "notation.h"
13 #include "search.h"
14 #include "timeman.h"
15 #include "thread.h"
16 <a name="1"></a>#include "tt.h"
17 #include "ucioption.h"
18 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>namespace Search {
19   volatile SignalsType Signals;
20   LimitsType Limits;
21   std::vector&lt;RootMove&gt; RootMoves;
22   Position RootPos;
23   Color RootColor;
24   Time::point SearchTime;
25   StateStackPtr SetupStates;
26 }
27 using std::string;
28 using Eval::evaluate;
29 using namespace Search;
30 namespace {
31   const bool FakeSplit = false;
32   enum NodeType { Root, PV, NonPV };
33   inline Value razor_margin(Depth d) { return Value(512 + 16 * d); }
34   int FutilityMoveCounts[2][32]; 
35   inline Value futility_margin(Depth d) {
36     return Value(100 * d);
37   }
38   int8_t Reductions[2][2][64][64]; 
39   template &lt;bool PvNode&gt; inline Depth reduction(bool i, Depth d, int mn) {
40     return (Depth) Reductions[PvNode][i][std::min(int(d) / ONE_PLY, 63)][std::min(mn, 63)];
41   }
42   size_t MultiPV, PVIdx;
43   TimeManager TimeMgr;
44   double BestMoveChanges;
45   Value DrawValue[COLOR_NB];
46   HistoryStats History;
47   GainsStats Gains;
48   MovesStats Countermoves, Followupmoves;
49   template &lt;NodeType NT, bool SpNode&gt;
50   Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode);
51   template &lt;NodeType NT, bool InCheck&gt;
52   Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth);
53   void id_loop(Position&amp; pos);
54   Value value_to_tt(Value v, int ply);
55   Value value_from_tt(Value v, int ply);
56   void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt);
57   string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta);
58   struct Skill {
59     Skill(int l) : level(l), best(MOVE_NONE) {}
60    ~Skill() {
61       if (enabled())           std::swap(RootMoves[0], *std::find(RootMoves.begin(),
62                     RootMoves.end(), best ? best : pick_move()));
63     }
64     bool enabled() const { return level &lt; 20; }
65     bool time_to_pick(int depth) const { return depth == 1 + level; }
66     Move pick_move();
67     int level;
68     Move best;
69   };
70 } 
71 void Search::init() {
72   int d;    int hd;   int mc; 
73   for (hd = 1; hd &lt; 64; ++hd) for (mc = 1; mc &lt; 64; ++mc)
74   {
75       double    pvRed = 0.00 + log(double(hd)) * log(double(mc)) / 3.00;
76       double nonPVRed = 0.33 + log(double(hd)) * log(double(mc)) / 2.25;
77       Reductions[1][1][hd][mc] = int8_t(   pvRed &gt;= 1.0 ?    pvRed * int(ONE_PLY) : 0);
78       Reductions[0][1][hd][mc] = int8_t(nonPVRed &gt;= 1.0 ? nonPVRed * int(ONE_PLY) : 0);
79       Reductions[1][0][hd][mc] = Reductions[1][1][hd][mc];
80       Reductions[0][0][hd][mc] = Reductions[0][1][hd][mc];
81       if (Reductions[0][0][hd][mc] &gt; 2 * ONE_PLY)
82           Reductions[0][0][hd][mc] += ONE_PLY;
83       else if (Reductions[0][0][hd][mc] &gt; 1 * ONE_PLY)
84           Reductions[0][0][hd][mc] += ONE_PLY / 2;
85   }
86   for (d = 0; d &lt; 32; ++d)
87   {
88       FutilityMoveCounts[0][d] = int(2.4 + 0.222 * pow(d + 0.00, 1.8));
89       FutilityMoveCounts[1][d] = int(3.0 + 0.300 * pow(d + 0.98, 1.8));
90   }
91 }
92 static uint64_t perft(Position&amp; pos, Depth depth) {
93   StateInfo st;
94   uint64_t cnt = 0;
95   CheckInfo ci(pos);
96 <a name="6"></a>  const bool leaf = depth == 2 * ONE_PLY;
97   for (const ExtMove&amp; ms : MoveList&lt;LEGAL&gt;(pos))</b></font>
98 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
99       pos.do_move(ms.move, st, ci, pos.gives_check(ms.move, ci));
100       cnt += leaf ? MoveList&lt;LEGAL&gt;(pos).size() : ::perft(pos, depth - ONE_PLY);
101       pos.undo_move(ms.move);
102   }
103   return cnt;
104 }
105 uint64_t Search::perft(Position&amp; pos, Depth depth) {
106   return depth &gt; ONE_PLY ? ::perft(pos, depth) : MoveList&lt;LEGAL&gt;(pos).size();
107 }
108 void Search::think() {
109   static PolyglotBook book; 
110   RootColor = RootPos.side_to_move();
111   TimeMgr.init(Limits, RootPos.game_ply(), RootColor);
112   int cf = Options["Contempt Factor"] * PawnValueEg / 100;   DrawValue[ RootColor] = VALUE_DRAW - Value(cf);
113   DrawValue[~RootColor] = VALUE_DRAW + Value(cf);
114   if (RootMoves.empty())
115   {
116       RootMoves.push_back(MOVE_NONE);
117       sync_cout &lt;&lt; "info depth 0 score "
118                 &lt;&lt; score_to_uci(RootPos.checkers() ? -VALUE_MATE : VALUE_DRAW)
119                 &lt;&lt; sync_endl;
120       goto finalize;
121   }
122   if (Options["OwnBook"] &amp;&amp; !Limits.infinite &amp;&amp; !Limits.mate)
123   {
124       Move bookMove = book.probe(RootPos, Options["Book File"], Options["Best Book Move"]);
125       if (bookMove &amp;&amp; std::count(RootMoves.begin(), RootMoves.end(), bookMove))
126       {
127           std::swap(RootMoves[0], *std::find(RootMoves.begin(), RootMoves.end(), bookMove));
128           goto finalize;
129       }
130   }
131   if (Options["Write Search Log"])
132   {
133       Log log(Options["Search Log Filename"]);
134       log &lt;&lt; "\nSearching: "  &lt;&lt; RootPos.fen()
135           &lt;&lt; "\ninfinite: "   &lt;&lt; Limits.infinite
136           &lt;&lt; " ponder: "      &lt;&lt; Limits.ponder
137           &lt;&lt; " time: "        &lt;&lt; Limits.time[RootColor]
138           &lt;&lt; " increment: "   &lt;&lt; Limits.inc[RootColor]
139           &lt;&lt; " moves to go: " &lt;&lt; Limits.movestogo
140           &lt;&lt; "\n" &lt;&lt; std::endl;
141   }
142   for (Thread* th : Threads)
143       th-&gt;maxPly = 0;
144   Threads.timer-&gt;run = true;
145   Threads.timer-&gt;notify_one(); 
146   id_loop(RootPos); <a name="7"></a>
147   Threads.timer-&gt;run = false; 
148 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if (Options["Write Search Log"])
149   {
150       Time::point elapsed = Time::now() - SearchTime + 1;
151       Log log(Options["Search Log Filename"]);
152       log &lt;&lt; "Nodes: "          &lt;&lt; RootPos.nodes_searched()
153           &lt;&lt; "\nNodes/second: " &lt;&lt; RootPos.nodes_searched() * 1000 / elapsed
154           &lt;&lt; "\nBest move: "    &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[0]);
155       StateInfo st;
156       RootPos.do_move(RootMoves[0].pv[0], st);
157       log &lt;&lt; "\nPonder move: " &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[1]) &lt;&lt; std::endl;
158       RootPos.undo_move(RootMoves[0].pv[0]);
159   }
160 finalize:
161   sync_cout &lt;&lt; "info nodes " &lt;&lt; RootPos.nodes_searched()
162             &lt;&lt; " time " &lt;&lt; Time::now() - SearchTime + 1 &lt;&lt; sync_endl;
163   if (!Signals.stop &amp;&amp; (Limits.ponder || Limits.infinite))
164   {
165       Signals.stopOnPonderhit = true;
166       RootPos.this_thread()-&gt;wait_for(Signals.stop);
167   }
168   sync_cout &lt;&lt; "bestmove " &lt;&lt; move_to_uci(RootMoves[0].pv[0], RootPos.is_chess960())
169             &lt;&lt; " ponder "  &lt;&lt; move_to_uci(RootMoves[0].pv[1], RootPos.is_chess960())
170             &lt;&lt; sync_endl;
171 }
172 namespace {
173   void id_loop(Position&amp; pos) {
174     Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;     int depth;
175     Value bestValue, alpha, beta, delta;
176     std::memset(ss-2, 0, 5 * sizeof(Stack));
177     (ss-1)-&gt;currentMove = MOVE_NULL; 
178     depth = 0;
179     BestMoveChanges = 0;
180     bestValue = delta = alpha = -VALUE_INFINITE;
181     beta = VALUE_INFINITE;
182     TT.new_search();
183     History.clear();
184     Gains.clear();
185     Countermoves.clear();
186     Followupmoves.clear();
187     MultiPV = Options["MultiPV"];
188     Skill skill(Options["Skill Level"]);
189     if (skill.enabled() &amp;&amp; MultiPV &lt; 4)
190         MultiPV = 4;
191     MultiPV = std::min(MultiPV, RootMoves.size());
192     while (++depth &lt;= MAX_PLY &amp;&amp; !Signals.stop &amp;&amp; (!Limits.depth || depth &lt;= Limits.depth))
193     {
194         BestMoveChanges *= 0.5;
195 <a name="2"></a>                for (RootMove&amp; rm : RootMoves)</b></font>
196 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            rm.prevScore = rm.score;
197         for (PVIdx = 0; PVIdx &lt; MultiPV &amp;&amp; !Signals.stop; ++PVIdx)
198         {
199             if (depth &gt;= 5)
200             {
201                 delta = Value(16);
202                 alpha = std::max(RootMoves[PVIdx].prevScore - delta,-VALUE_INFINITE);
203                 beta  = std::min(RootMoves[PVIdx].prevScore + delta, VALUE_INFINITE);
204             }
205             while (true)
206             {
207                 bestValue = search&lt;Root, false&gt;(pos, ss, alpha, beta, depth * ONE_PLY, false);
208                 std::stable_sort(RootMoves.begin() + PVIdx, RootMoves.end());
209                 for (size_t i = 0; i &lt;= PVIdx; ++i)
210                     RootMoves[i].insert_pv_in_tt(pos);
211                 if (Signals.stop)
212                     break;
213                 if (  (bestValue &lt;= alpha || bestValue &gt;= beta)
214                     &amp;&amp; Time::now() - SearchTime &gt; 3000)
215                     sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
216                 if (bestValue &lt;= alpha)
217                 {
218                     alpha = std::max(bestValue - delta, -VALUE_INFINITE);
219                     Signals.failedLowAtRoot = true;
220                     Signals.stopOnPonderhit = false;
221                 }
222                 else if (bestValue &gt;= beta)
223                     beta = std::min(bestValue + delta, VALUE_INFINITE);
224                 else
225                     break;
226                 delta += delta / 2;
227                 assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; beta &lt;= VALUE_INFINITE);
228             }
229             std::stable_sort(RootMoves.begin(), RootMoves.begin() + PVIdx + 1);
230             if (PVIdx + 1 == MultiPV || Time::now() - SearchTime &gt; 3000)
231                 sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
232         }
233         if (skill.enabled() &amp;&amp; skill.time_to_pick(depth))
234             skill.pick_move();
235         if (Options["Write Search Log"])
236         {
237             RootMove&amp; rm = RootMoves[0];
238             if (skill.best != MOVE_NONE)
239                 rm = *std::find(RootMoves.begin(), RootMoves.end(), skill.best);
240             Log log(Options["Search Log Filename"]);
241             log &lt;&lt; pretty_pv(pos, depth, rm.score, Time::now() - SearchTime, &amp;rm.pv[0])
242                 &lt;&lt; std::endl;
243         }
244         if (   Limits.mate
245             &amp;&amp; bestValue &gt;= VALUE_MATE_IN_MAX_PLY
246             &amp;&amp; VALUE_MATE - bestValue &lt;= 2 * Limits.mate)
247             Signals.stop = true;
248         if (Limits.use_time_management() &amp;&amp; !Signals.stop &amp;&amp; !Signals.stopOnPonderhit)
249         {
250             if (depth &gt; 4 &amp;&amp; depth &lt; 50 &amp;&amp;  MultiPV == 1)
251                 TimeMgr.pv_instability(BestMoveChanges);
252             if (   RootMoves.size() == 1
253                 || Time::now() - SearchTime &gt; TimeMgr.available_time())
254             {
255                 if (Limits.ponder)
256                     Signals.stopOnPonderhit = true;
257                 else
258                     Signals.stop = true;
259             }
260         }
261     }
262   }
263   template &lt;NodeType NT, bool SpNode&gt;
264   Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {
265     const bool RootNode = NT == Root;
266     const bool PvNode   = NT == PV || NT == Root;
267     assert(-VALUE_INFINITE &lt;= alpha &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
268     assert(PvNode || (alpha == beta - 1));
269     assert(depth &gt; DEPTH_ZERO);
270     Move quietsSearched[64];
271     StateInfo st;
272     const TTEntry *tte;
273     SplitPoint* splitPoint;
274     Key posKey;
275     Move ttMove, move, excludedMove, bestMove;
276     Depth ext, newDepth, predictedDepth;
277     Value bestValue, value, ttValue, eval, nullValue, futilityValue;
278     bool inCheck, givesCheck, pvMove, singularExtensionNode, improving;
279     bool captureOrPromotion, dangerous, doFullDepthSearch;
280     int moveCount, quietCount;
281     Thread* thisThread = pos.this_thread();
282     inCheck = pos.checkers();
283     if (SpNode)
284     {
285         splitPoint = ss-&gt;splitPoint;
286 <a name="5"></a>        bestMove   = splitPoint-&gt;bestMove;
287         bestValue  = splitPoint-&gt;bestValue;
288         tte = nullptr;</b></font>
289 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        ttMove = excludedMove = MOVE_NONE;
290         ttValue = VALUE_NONE;
291         assert(splitPoint-&gt;bestValue &gt; -VALUE_INFINITE &amp;&amp; splitPoint-&gt;moveCount &gt; 0);
292         goto moves_loop;
293     }
294     moveCount = quietCount = 0;
295     bestValue = -VALUE_INFINITE;
296     ss-&gt;currentMove = ss-&gt;ttMove = (ss+1)-&gt;excludedMove = bestMove = MOVE_NONE;
297     ss-&gt;ply = (ss-1)-&gt;ply + 1;
298     (ss+1)-&gt;skipNullMove = false; (ss+1)-&gt;reduction = DEPTH_ZERO;
299     (ss+2)-&gt;killers[0] = (ss+2)-&gt;killers[1] = MOVE_NONE;
300     if (PvNode &amp;&amp; thisThread-&gt;maxPly &lt; ss-&gt;ply)
301         thisThread-&gt;maxPly = ss-&gt;ply;
302     if (!RootNode)
303     {
304         if (Signals.stop || pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
305             return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !inCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
306         alpha = std::max(mated_in(ss-&gt;ply), alpha);
307         beta = std::min(mate_in(ss-&gt;ply+1), beta);
308         if (alpha &gt;= beta)
309             return alpha;
310     }
311     excludedMove = ss-&gt;excludedMove;
312     posKey = excludedMove ? pos.exclusion_key() : pos.key();
313     tte = TT.probe(posKey);
314     ss-&gt;ttMove = ttMove = RootNode ? RootMoves[PVIdx].pv[0] : tte ? tte-&gt;move() : MOVE_NONE;
315     ttValue = tte ? value_from_tt(tte-&gt;value(), ss-&gt;ply) : VALUE_NONE;
316     if (   !RootNode
317         &amp;&amp; tte
318         &amp;&amp; tte-&gt;depth() &gt;= depth
319         &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
320             : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
321                               : (tte-&gt;bound() &amp;  BOUND_UPPER)))
322     {
323         ss-&gt;currentMove = ttMove; 
324 <a name="0"></a>        if (ttValue &gt;= beta &amp;&amp; ttMove &amp;&amp; !pos.capture_or_promotion(ttMove) &amp;&amp; !inCheck)</b></font>
325             update_stats(pos, ss, ttMove, depth, nullptr, 0);
326 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return ttValue;
327     }
328     if (inCheck)
329     {
330         ss-&gt;staticEval = eval = VALUE_NONE;
331         goto moves_loop;
332     }
333     else if (tte)
334     {
335         if ((ss-&gt;staticEval = eval = tte-&gt;eval_value()) == VALUE_NONE)
336             eval = ss-&gt;staticEval = evaluate(pos);
337         if (ttValue != VALUE_NONE)
338             if (tte-&gt;bound() &amp; (ttValue &gt; eval ? BOUND_LOWER : BOUND_UPPER))
339                 eval = ttValue;
340     }
341     else
342     {
343         eval = ss-&gt;staticEval = evaluate(pos);
344         TT.store(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
345     }
346     if (   !pos.captured_piece_type()
347         &amp;&amp;  ss-&gt;staticEval != VALUE_NONE
348         &amp;&amp; (ss-1)-&gt;staticEval != VALUE_NONE
349         &amp;&amp; (move = (ss-1)-&gt;currentMove) != MOVE_NULL
350         &amp;&amp;  type_of(move) == NORMAL)
351     {
352         Square to = to_sq(move);
353         Gains.update(pos.piece_on(to), to, -(ss-1)-&gt;staticEval - ss-&gt;staticEval);
354     }
355     if (   !PvNode
356         &amp;&amp;  depth &lt; 4 * ONE_PLY
357         &amp;&amp;  eval + razor_margin(depth) &lt;= alpha
358         &amp;&amp;  ttMove == MOVE_NONE
359         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
360         &amp;&amp; !pos.pawn_on_7th(pos.side_to_move()))
361     {
362         if (   depth &lt;= ONE_PLY
363             &amp;&amp; eval + razor_margin(3 * ONE_PLY) &lt;= alpha)
364             return qsearch&lt;NonPV, false&gt;(pos, ss, alpha, beta, DEPTH_ZERO);
365         Value ralpha = alpha - razor_margin(depth);
366         Value v = qsearch&lt;NonPV, false&gt;(pos, ss, ralpha, ralpha+1, DEPTH_ZERO);
367         if (v &lt;= ralpha)
368             return v;
369     }
370     if (   !PvNode
371         &amp;&amp; !ss-&gt;skipNullMove
372         &amp;&amp;  depth &lt; 7 * ONE_PLY
373         &amp;&amp;  eval - futility_margin(depth) &gt;= beta
374         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
375         &amp;&amp;  abs(eval) &lt; VALUE_KNOWN_WIN
376         &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
377         return eval - futility_margin(depth);
378     if (   !PvNode
379         &amp;&amp; !ss-&gt;skipNullMove
380         &amp;&amp;  depth &gt;= 2 * ONE_PLY
381         &amp;&amp;  eval &gt;= beta
382         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
383         &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
384     {
385         ss-&gt;currentMove = MOVE_NULL;
386         assert(eval - beta &gt;= 0);
387         Depth R =  3 * ONE_PLY
388                  + depth / 4
389                  + int(eval - beta) / PawnValueMg * ONE_PLY;
390         pos.do_null_move(st);
391         (ss+1)-&gt;skipNullMove = true;
392         nullValue = depth-R &lt; ONE_PLY ? -qsearch&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, DEPTH_ZERO)
393                                       : - search&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, depth-R, !cutNode);
394         (ss+1)-&gt;skipNullMove = false;
395         pos.undo_null_move();
396         if (nullValue &gt;= beta)
397         {
398             if (nullValue &gt;= VALUE_MATE_IN_MAX_PLY)
399                 nullValue = beta;
400             if (depth &lt; 12 * ONE_PLY)
401                 return nullValue;
402             ss-&gt;skipNullMove = true;
403             Value v = depth-R &lt; ONE_PLY ? qsearch&lt;NonPV, false&gt;(pos, ss, beta-1, beta, DEPTH_ZERO)
404                                         :  search&lt;NonPV, false&gt;(pos, ss, beta-1, beta, depth-R, false);
405             ss-&gt;skipNullMove = false;
406             if (v &gt;= beta)
407                 return nullValue;
408         }
409     }
410     if (   !PvNode
411         &amp;&amp;  depth &gt;= 5 * ONE_PLY
412         &amp;&amp; !ss-&gt;skipNullMove
413         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY)
414     {
415         Value rbeta = std::min(beta + 200, VALUE_INFINITE);
416         Depth rdepth = depth - 4 * ONE_PLY;
417         assert(rdepth &gt;= ONE_PLY);
418         assert((ss-1)-&gt;currentMove != MOVE_NONE);
419         assert((ss-1)-&gt;currentMove != MOVE_NULL);
420         MovePicker mp(pos, ttMove, History, pos.captured_piece_type());
421         CheckInfo ci(pos);
422         while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
423             if (pos.legal(move, ci.pinned))
424             {
425                 ss-&gt;currentMove = move;
426                 pos.do_move(move, st, ci, pos.gives_check(move, ci));
427                 value = -search&lt;NonPV, false&gt;(pos, ss+1, -rbeta, -rbeta+1, rdepth, !cutNode);
428                 pos.undo_move(move);
429                 if (value &gt;= rbeta)
430                     return value;
431             }
432     }
433     if (    depth &gt;= (PvNode ? 5 * ONE_PLY : 8 * ONE_PLY)
434         &amp;&amp; !ttMove
435         &amp;&amp; (PvNode || ss-&gt;staticEval + 256 &gt;= beta))
436     {
437         Depth d = depth - 2 * ONE_PLY - (PvNode ? DEPTH_ZERO : depth / 4);
438         ss-&gt;skipNullMove = true;
439         search&lt;PvNode ? PV : NonPV, false&gt;(pos, ss, alpha, beta, d, true);
440         ss-&gt;skipNullMove = false;
441         tte = TT.probe(posKey);
442         ttMove = tte ? tte-&gt;move() : MOVE_NONE;
443     }
444 moves_loop: 
445     Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
446     Move countermoves[] = { Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].first,
447                             Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].second };
448     Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
449     Move followupmoves[] = { Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].first,
450                              Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].second };
451     MovePicker mp(pos, ttMove, depth, History, countermoves, followupmoves, ss);
452     CheckInfo ci(pos);
453     value = bestValue;     improving =   ss-&gt;staticEval &gt;= (ss-2)-&gt;staticEval
454                || ss-&gt;staticEval == VALUE_NONE
455                ||(ss-2)-&gt;staticEval == VALUE_NONE;
456     singularExtensionNode =   !RootNode
457                            &amp;&amp; !SpNode
458                            &amp;&amp;  depth &gt;= 8 * ONE_PLY
459                            &amp;&amp;  ttMove != MOVE_NONE
460                            &amp;&amp; !excludedMove                            &amp;&amp; (tte-&gt;bound() &amp; BOUND_LOWER)
461                            &amp;&amp;  tte-&gt;depth() &gt;= depth - 3 * ONE_PLY;
462     while ((move = mp.next_move&lt;SpNode&gt;()) != MOVE_NONE)
463     {
464       assert(is_ok(move));
465       if (move == excludedMove)
466           continue;
467       if (RootNode &amp;&amp; !std::count(RootMoves.begin() + PVIdx, RootMoves.end(), move))
468           continue;
469       if (SpNode)
470       {
471           if (!pos.legal(move, ci.pinned))
472               continue;
473           moveCount = ++splitPoint-&gt;moveCount;
474           splitPoint-&gt;mutex.unlock();
475       }
476       else
477           ++moveCount;
478       if (RootNode)
479       {
480           Signals.firstRootMove = (moveCount == 1);
481           if (thisThread == Threads.main() &amp;&amp; Time::now() - SearchTime &gt; 3000)
482               sync_cout &lt;&lt; "info depth " &lt;&lt; depth / ONE_PLY
483                         &lt;&lt; " currmove " &lt;&lt; move_to_uci(move, pos.is_chess960())
484                         &lt;&lt; " currmovenumber " &lt;&lt; moveCount + PVIdx &lt;&lt; sync_endl;
485       }
486       ext = DEPTH_ZERO;
487       captureOrPromotion = pos.capture_or_promotion(move);
488       givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
489                   ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
490                   : pos.gives_check(move, ci);
491       dangerous =   givesCheck
492                  || type_of(move) != NORMAL
493                  || pos.advanced_pawn_push(move);
494       if (givesCheck &amp;&amp; pos.see_sign(move) &gt;= VALUE_ZERO)
495           ext = ONE_PLY;
496       if (    singularExtensionNode
497           &amp;&amp;  move == ttMove
498           &amp;&amp; !ext
499           &amp;&amp;  pos.legal(move, ci.pinned)
500           &amp;&amp;  abs(ttValue) &lt; VALUE_KNOWN_WIN)
501       {
502           assert(ttValue != VALUE_NONE);
503           Value rBeta = ttValue - int(depth);
504           ss-&gt;excludedMove = move;
505           ss-&gt;skipNullMove = true;
506           value = search&lt;NonPV, false&gt;(pos, ss, rBeta - 1, rBeta, depth / 2, cutNode);
507           ss-&gt;skipNullMove = false;
508           ss-&gt;excludedMove = MOVE_NONE;
509           if (value &lt; rBeta)
510               ext = ONE_PLY;
511       }
512       newDepth = depth - ONE_PLY + ext;
513       if (   !PvNode
514           &amp;&amp; !captureOrPromotion
515           &amp;&amp; !inCheck
516           &amp;&amp; !dangerous
517           &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY)
518       {
519           if (   depth &lt; 16 * ONE_PLY
520               &amp;&amp; moveCount &gt;= FutilityMoveCounts[improving][depth] )
521           {
522               if (SpNode)
523                   splitPoint-&gt;mutex.lock();
524               continue;
525           }
526           predictedDepth = newDepth - reduction&lt;PvNode&gt;(improving, depth, moveCount);
527           if (predictedDepth &lt; 7 * ONE_PLY)
528           {
529               futilityValue = ss-&gt;staticEval + futility_margin(predictedDepth)
530                             + 128 + Gains[pos.moved_piece(move)][to_sq(move)];
531               if (futilityValue &lt;= alpha)
532               {
533                   bestValue = std::max(bestValue, futilityValue);
534                   if (SpNode)
535                   {
536                       splitPoint-&gt;mutex.lock();
537                       if (bestValue &gt; splitPoint-&gt;bestValue)
538                           splitPoint-&gt;bestValue = bestValue;
539                   }
540                   continue;
541               }
542           }
543           if (predictedDepth &lt; 4 * ONE_PLY &amp;&amp; pos.see_sign(move) &lt; VALUE_ZERO)
544           {
545               if (SpNode)
546                   splitPoint-&gt;mutex.lock();
547               continue;
548           }
549       }
550       if (!RootNode &amp;&amp; !SpNode &amp;&amp; !pos.legal(move, ci.pinned))
551       {
552           moveCount--;
553           continue;
554       }
555       pvMove = PvNode &amp;&amp; moveCount == 1;
556       ss-&gt;currentMove = move;
557       if (!SpNode &amp;&amp; !captureOrPromotion &amp;&amp; quietCount &lt; 64)
558           quietsSearched[quietCount++] = move;
559       pos.do_move(move, st, ci, givesCheck);
560       if (    depth &gt;= 3 * ONE_PLY
561           &amp;&amp; !pvMove
562           &amp;&amp; !captureOrPromotion
563           &amp;&amp;  move != ttMove
564           &amp;&amp;  move != ss-&gt;killers[0]
565           &amp;&amp;  move != ss-&gt;killers[1])
566       {
567           ss-&gt;reduction = reduction&lt;PvNode&gt;(improving, depth, moveCount);
568           if (!PvNode &amp;&amp; cutNode)
569               ss-&gt;reduction += ONE_PLY;
570           else if (History[pos.piece_on(to_sq(move))][to_sq(move)] &lt; 0)
571               ss-&gt;reduction += ONE_PLY / 2;
572           if (move == countermoves[0] || move == countermoves[1])
573               ss-&gt;reduction = std::max(DEPTH_ZERO, ss-&gt;reduction - ONE_PLY);
574           Depth d = std::max(newDepth - ss-&gt;reduction, ONE_PLY);
575           if (SpNode)
576               alpha = splitPoint-&gt;alpha;
577           value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d, true);
578           if (value &gt; alpha &amp;&amp; ss-&gt;reduction &gt;= 4 * ONE_PLY)
579           {
580               Depth d2 = std::max(newDepth - 2 * ONE_PLY, ONE_PLY);
581               value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d2, true);
582           }
583           doFullDepthSearch = (value &gt; alpha &amp;&amp; ss-&gt;reduction != DEPTH_ZERO);
584           ss-&gt;reduction = DEPTH_ZERO;
585       }
586       else
587           doFullDepthSearch = !pvMove;
588       if (doFullDepthSearch)
589       {
590           if (SpNode)
591               alpha = splitPoint-&gt;alpha;
592           value = newDepth &lt; ONE_PLY ?
593                           givesCheck ? -qsearch&lt;NonPV,  true&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
594                                      : -qsearch&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
595                                      : - search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, newDepth, !cutNode);
596       }
597       if (PvNode &amp;&amp; (pvMove || (value &gt; alpha &amp;&amp; (RootNode || value &lt; beta))))
598           value = newDepth &lt; ONE_PLY ?
599                           givesCheck ? -qsearch&lt;PV,  true&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
600                                      : -qsearch&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
601                                      : - search&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, newDepth, false);
602       pos.undo_move(move);
603       assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
604       if (SpNode)
605       {
606           splitPoint-&gt;mutex.lock();
607           bestValue = splitPoint-&gt;bestValue;
608           alpha = splitPoint-&gt;alpha;
609       }
610       if (Signals.stop || thisThread-&gt;cutoff_occurred())
611           return VALUE_ZERO;
612       if (RootNode)
613       {
614           RootMove&amp; rm = *std::find(RootMoves.begin(), RootMoves.end(), move);
615           if (pvMove || value &gt; alpha)
616           {
617               rm.score = value;
618               rm.extract_pv_from_tt(pos);
619               if (!pvMove)
620                   ++BestMoveChanges;
621           }
622           else
623               rm.score = -VALUE_INFINITE;
624       }
625       if (value &gt; bestValue)
626       {
627           bestValue = SpNode ? splitPoint-&gt;bestValue = value : value;
628           if (value &gt; alpha)
629           {
630               bestMove = SpNode ? splitPoint-&gt;bestMove = move : move;
631               if (PvNode &amp;&amp; value &lt; beta)                   alpha = SpNode ? splitPoint-&gt;alpha = value : value;
632               else
633               {
634                   assert(value &gt;= beta); 
635                   if (SpNode)
636                       splitPoint-&gt;cutoff = true;
637                   break;
638               }
639           }
640       }
641       if (   !SpNode
642           &amp;&amp;  Threads.size() &gt;= 2
643           &amp;&amp;  depth &gt;= Threads.minimumSplitDepth
644           &amp;&amp;  (   !thisThread-&gt;activeSplitPoint
645                || !thisThread-&gt;activeSplitPoint-&gt;allSlavesSearching)
646           &amp;&amp;  thisThread-&gt;splitPointsSize &lt; MAX_SPLITPOINTS_PER_THREAD)
647       {
648           assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; beta);
649           thisThread-&gt;split&lt;FakeSplit&gt;(pos, ss, alpha, beta, &amp;bestValue, &amp;bestMove,
650                                        depth, moveCount, &amp;mp, NT, cutNode);
651           if (Signals.stop || thisThread-&gt;cutoff_occurred())
652               return VALUE_ZERO;
653           if (bestValue &gt;= beta)
654               break;
655       }
656     }
657     if (SpNode)
658         return bestValue;
659     if (!moveCount)
660         bestValue = excludedMove ? alpha
661                    :     inCheck ? mated_in(ss-&gt;ply) : DrawValue[pos.side_to_move()];
662     else if (bestValue &gt;= beta &amp;&amp; !pos.capture_or_promotion(bestMove) &amp;&amp; !inCheck)
663         update_stats(pos, ss, bestMove, depth, quietsSearched, quietCount - 1);
664     TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
665              bestValue &gt;= beta  ? BOUND_LOWER :
666              PvNode &amp;&amp; bestMove ? BOUND_EXACT : BOUND_UPPER,
667              depth, bestMove, ss-&gt;staticEval);
668     assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
669     return bestValue;
670   }
671   template &lt;NodeType NT, bool InCheck&gt;
672   Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth) {
673     const bool PvNode = NT == PV;
674     assert(NT == PV || NT == NonPV);
675     assert(InCheck == !!pos.checkers());
676     assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
677     assert(PvNode || (alpha == beta - 1));
678     assert(depth &lt;= DEPTH_ZERO);
679     StateInfo st;
680     const TTEntry* tte;
681     Key posKey;
682     Move ttMove, move, bestMove;
683     Value bestValue, value, ttValue, futilityValue, futilityBase, oldAlpha;
684     bool givesCheck, evasionPrunable;
685     Depth ttDepth;
686     if (PvNode)
687         oldAlpha = alpha;
688     ss-&gt;currentMove = bestMove = MOVE_NONE;
689     ss-&gt;ply = (ss-1)-&gt;ply + 1;
690     if (pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
691         return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !InCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
692     ttDepth = InCheck || depth &gt;= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS
693                                                   : DEPTH_QS_NO_CHECKS;
694     posKey = pos.key();
695     tte = TT.probe(posKey);
696     ttMove = tte ? tte-&gt;move() : MOVE_NONE;
697     ttValue = tte ? value_from_tt(tte-&gt;value(),ss-&gt;ply) : VALUE_NONE;
698     if (   tte
699         &amp;&amp; tte-&gt;depth() &gt;= ttDepth
700         &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
701             : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
702                               : (tte-&gt;bound() &amp;  BOUND_UPPER)))
703     {
704         ss-&gt;currentMove = ttMove;         return ttValue;
705     }
706     if (InCheck)
707     {
708         ss-&gt;staticEval = VALUE_NONE;
709         bestValue = futilityBase = -VALUE_INFINITE;
710     }
711     else
712     {
713         if (tte)
714         {
715             if ((ss-&gt;staticEval = bestValue = tte-&gt;eval_value()) == VALUE_NONE)
716                 ss-&gt;staticEval = bestValue = evaluate(pos);
717             if (ttValue != VALUE_NONE)
718                 if (tte-&gt;bound() &amp; (ttValue &gt; bestValue ? BOUND_LOWER : BOUND_UPPER))
719                     bestValue = ttValue;
720         }
721         else
722             ss-&gt;staticEval = bestValue = evaluate(pos);
723         if (bestValue &gt;= beta)
724         {
725             if (!tte)
726                 TT.store(pos.key(), value_to_tt(bestValue, ss-&gt;ply), BOUND_LOWER,
727                          DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
728             return bestValue;
729         }
730         if (PvNode &amp;&amp; bestValue &gt; alpha)
731             alpha = bestValue;
732         futilityBase = bestValue + 128;
733     }
734     MovePicker mp(pos, ttMove, depth, History, to_sq((ss-1)-&gt;currentMove));
735     CheckInfo ci(pos);
736     while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
737     {
738       assert(is_ok(move));
739       givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
740                   ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
741                   : pos.gives_check(move, ci);
742       if (   !PvNode
743           &amp;&amp; !InCheck
744           &amp;&amp; !givesCheck
745           &amp;&amp;  move != ttMove
746           &amp;&amp;  futilityBase &gt; -VALUE_KNOWN_WIN
747           &amp;&amp; !pos.advanced_pawn_push(move))
748       {
749           assert(type_of(move) != ENPASSANT); 
750           futilityValue = futilityBase + PieceValue[EG][pos.piece_on(to_sq(move))];
751           if (futilityValue &lt; beta)
752           {
753               bestValue = std::max(bestValue, futilityValue);
754               continue;
755           }
756           if (futilityBase &lt; beta &amp;&amp; pos.see(move) &lt;= VALUE_ZERO)
757           {
758               bestValue = std::max(bestValue, futilityBase);
759               continue;
760           }
761       }
762       evasionPrunable =    InCheck
763                        &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY
764                        &amp;&amp; !pos.capture(move)
765                        &amp;&amp; !pos.can_castle(pos.side_to_move());
766       if (   !PvNode
767           &amp;&amp; (!InCheck || evasionPrunable)
768           &amp;&amp;  move != ttMove
769           &amp;&amp;  type_of(move) != PROMOTION
770           &amp;&amp;  pos.see_sign(move) &lt; VALUE_ZERO)
771           continue;
772       if (!pos.legal(move, ci.pinned))
773           continue;
774       ss-&gt;currentMove = move;
775       pos.do_move(move, st, ci, givesCheck);
776       value = givesCheck ? -qsearch&lt;NT,  true&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY)
777                          : -qsearch&lt;NT, false&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY);
778       pos.undo_move(move);
779       assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
780       if (value &gt; bestValue)
781       {
782           bestValue = value;
783           if (value &gt; alpha)
784           {
785               if (PvNode &amp;&amp; value &lt; beta)               {
786                   alpha = value;
787                   bestMove = move;
788               }
789               else               {
790                   TT.store(posKey, value_to_tt(value, ss-&gt;ply), BOUND_LOWER,
791                            ttDepth, move, ss-&gt;staticEval);
792                   return value;
793               }
794           }
795        }
796     }
797     if (InCheck &amp;&amp; bestValue == -VALUE_INFINITE)
798         return mated_in(ss-&gt;ply); 
799     TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
800              PvNode &amp;&amp; bestValue &gt; oldAlpha ? BOUND_EXACT : BOUND_UPPER,
801              ttDepth, bestMove, ss-&gt;staticEval);
802     assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
803     return bestValue;
804   }
805   Value value_to_tt(Value v, int ply) {
806     assert(v != VALUE_NONE);
807     return  v &gt;= VALUE_MATE_IN_MAX_PLY  ? v + ply
808           : v &lt;= VALUE_MATED_IN_MAX_PLY ? v - ply : v;
809   }
810   Value value_from_tt(Value v, int ply) {
811     return  v == VALUE_NONE             ? VALUE_NONE
812           : v &gt;= VALUE_MATE_IN_MAX_PLY  ? v - ply
813           : v &lt;= VALUE_MATED_IN_MAX_PLY ? v + ply : v;
814   }
815   void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt) {
816     if (ss-&gt;killers[0] != move)
817     {
818         ss-&gt;killers[1] = ss-&gt;killers[0];
819         ss-&gt;killers[0] = move;
820     }
821     Value bonus = Value(int(depth) * int(depth));
822     History.update(pos.moved_piece(move), to_sq(move), bonus);
823     for (int i = 0; i &lt; quietsCnt; ++i)
824     {
825         Move m = quiets[i];
826         History.update(pos.moved_piece(m), to_sq(m), -bonus);
827     }
828     if (is_ok((ss-1)-&gt;currentMove))
829     {
830         Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
831         Countermoves.update(pos.piece_on(prevMoveSq), prevMoveSq, move);
832     }
833     if (is_ok((ss-2)-&gt;currentMove) &amp;&amp; (ss-1)-&gt;currentMove == (ss-1)-&gt;ttMove)
834     {
835         Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
836         Followupmoves.update(pos.piece_on(prevOwnMoveSq), prevOwnMoveSq, move);
837     }
838   }
839   Move Skill::pick_move() {
840     static RKISS rk;
841     for (int i = Time::now() % 50; i &gt; 0; --i)
842         rk.rand&lt;unsigned&gt;();
843     int variance = std::min(RootMoves[0].score - RootMoves[MultiPV - 1].score, PawnValueMg);
844     int weakness = 120 - 2 * level;
845     int max_s = -VALUE_INFINITE;
846     best = MOVE_NONE;
847     for (size_t i = 0; i &lt; MultiPV; ++i)
848     {
849         int s = RootMoves[i].score;
850         if (i &gt; 0 &amp;&amp; RootMoves[i-1].score &gt; s + 2 * PawnValueMg)
851             break;
852         s += (  weakness * int(RootMoves[0].score - s)
853               + variance * (rk.rand&lt;unsigned&gt;() % weakness)) / 128;
854         if (s &gt; max_s)
855         {
856             max_s = s;
857             best = RootMoves[i].pv[0];
858         }
859     }
860     return best;
861   }
862   string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta) {
863     std::stringstream ss;
864     Time::point elapsed = Time::now() - SearchTime + 1;
865     size_t uciPVSize = std::min((size_t)Options["MultiPV"], RootMoves.size());
866 <a name="3"></a>    int selDepth = 0;
867     for (Thread* th : Threads)</b></font>
868 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        if (th-&gt;maxPly &gt; selDepth)
869             selDepth = th-&gt;maxPly;
870     for (size_t i = 0; i &lt; uciPVSize; ++i)
871     {
872         bool updated = (i &lt;= PVIdx);
873         if (depth == 1 &amp;&amp; !updated)
874             continue;
875         int d   = updated ? depth : depth - 1;
876         Value v = updated ? RootMoves[i].score : RootMoves[i].prevScore;
877         if (ss.rdbuf()-&gt;in_avail())             ss &lt;&lt; "\n";
878         ss &lt;&lt; "info depth " &lt;&lt; d
879            &lt;&lt; " seldepth "  &lt;&lt; selDepth
880            &lt;&lt; " score "     &lt;&lt; (i == PVIdx ? score_to_uci(v, alpha, beta) : score_to_uci(v))
881            &lt;&lt; " nodes "     &lt;&lt; pos.nodes_searched()
882            &lt;&lt; " nps "       &lt;&lt; pos.nodes_searched() * 1000 / elapsed
883            &lt;&lt; " time "      &lt;&lt; elapsed
884            &lt;&lt; " multipv "   &lt;&lt; i + 1
885            &lt;&lt; " pv";
886         for (size_t j = 0; RootMoves[i].pv[j] != MOVE_NONE; ++j)
887             ss &lt;&lt; " " &lt;&lt; move_to_uci(RootMoves[i].pv[j], pos.is_chess960());
888     }
889     return ss.str();
890   }
891 } 
892 void RootMove::extract_pv_from_tt(Position&amp; pos) {
893   StateInfo state[MAX_PLY_PLUS_6], *st = state;
894   const TTEntry* tte;
895   int ply = 1;      Move m = pv[0];   Value expectedScore = score;
896   pv.clear();
897   do {
898       pv.push_back(m);
899       assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[ply - 1]));
900       pos.do_move(pv[ply++ - 1], *st++);
901       tte = TT.probe(pos.key());
902       expectedScore = -expectedScore;
903   } while (   tte
904            &amp;&amp; expectedScore == value_from_tt(tte-&gt;value(), ply)
905            &amp;&amp; pos.pseudo_legal(m = tte-&gt;move())            &amp;&amp; pos.legal(m, pos.pinned_pieces(pos.side_to_move()))
906            &amp;&amp; ply &lt; MAX_PLY
907            &amp;&amp; (!pos.is_draw() || ply &lt;= 2));
908   pv.push_back(MOVE_NONE); 
909   while (--ply) pos.undo_move(pv[ply - 1]);
910 }
911 void RootMove::insert_pv_in_tt(Position&amp; pos) {
912   StateInfo state[MAX_PLY_PLUS_6], *st = state;
913   const TTEntry* tte;
914   int idx = 0; 
915   do {
916       tte = TT.probe(pos.key());
917       if (!tte || tte-&gt;move() != pv[idx])           TT.store(pos.key(), VALUE_NONE, BOUND_NONE, DEPTH_NONE, pv[idx], VALUE_NONE);
918       assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[idx]));
919       pos.do_move(pv[idx++], *st++);
920   } while (pv[idx] != MOVE_NONE);
921   while (idx) pos.undo_move(pv[--idx]);
922 }
923 void Thread::idle_loop() {
924   SplitPoint* this_sp = splitPointsSize ? activeSplitPoint : nullptr;</b></font>
925   assert(!this_sp || (this_sp-&gt;masterThread == this &amp;&amp; searching));
926   while (true)
927   {
928       while (!searching || exit)
929       {
930           if (exit)
931           {
932               assert(!this_sp);
933               return;
934           }
935           std::unique_lock&lt;std::mutex&gt; lk(mutex);
936           if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
937               break;
938           if (!searching &amp;&amp; !exit)
939               sleepCondition.wait(lk);
940       }
941       if (searching)
942       {
943           assert(!exit);
944           Threads.mutex.lock();
945           assert(searching);
946           assert(activeSplitPoint);
947           SplitPoint* sp = activeSplitPoint;
948           Threads.mutex.unlock();
949           Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;           Position pos(*sp-&gt;pos, this);
950           std::memcpy(ss-2, sp-&gt;ss-2, 5 * sizeof(Stack));
951           ss-&gt;splitPoint = sp;
952           sp-&gt;mutex.lock();
953           assert(activePosition == nullptr);
954           activePosition = &amp;pos;
955           if (sp-&gt;nodeType == NonPV)
956               search&lt;NonPV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
957           else if (sp-&gt;nodeType == PV)
958               search&lt;PV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
959           else if (sp-&gt;nodeType == Root)
960               search&lt;Root, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
961           else
962               assert(false);
963           assert(searching);
964 <a name="4"></a>          searching = false;
965           activePosition = nullptr;
966           sp-&gt;slavesMask.reset(idx);
967 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          sp-&gt;allSlavesSearching = false;
968           sp-&gt;nodes += pos.nodes_searched();
969           if (    this != sp-&gt;masterThread
970               &amp;&amp;  sp-&gt;slavesMask.none())
971           {
972               assert(!sp-&gt;masterThread-&gt;searching);
973               sp-&gt;masterThread-&gt;notify_one();
974           }
975           sp-&gt;mutex.unlock();
976           if (Threads.size() &gt; 2)
977               for (size_t i = 0; i &lt; Threads.size(); ++i)
978               {
979                   int size = Threads[i]-&gt;splitPointsSize;                   sp = size ? &amp;Threads[i]-&gt;splitPoints[size - 1] : NULL;
980                   if (   sp
981                       &amp;&amp; sp-&gt;allSlavesSearching
982                       &amp;&amp; available_to(Threads[i]))
983                   {
984                       Threads.mutex.lock();
985                       sp-&gt;mutex.lock();
986                       if (   sp-&gt;allSlavesSearching
987                           &amp;&amp; available_to(Threads[i]))
988                       {
989                            sp-&gt;slavesMask.set(idx);
990                            activeSplitPoint = sp;
991                            searching = true;
992                       }
993                       sp-&gt;mutex.unlock();
994                       Threads.mutex.unlock();
995                       break;                   }
996               }
997       }
998       if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
999       {
1000           this_sp-&gt;mutex.lock();
1001           bool finished = this_sp-&gt;slavesMask.none();           this_sp-&gt;mutex.unlock();
1002           if (finished)
1003               return;
1004       }
1005   }
1006 }
1007 void check_time() {
1008   static Time::point lastInfoTime = Time::now();
1009   int64_t nodes = 0; 
1010   if (Time::now() - lastInfoTime &gt;= 1000)
1011   {
1012       lastInfoTime = Time::now();
1013       dbg_print();
1014   }
1015   if (Limits.ponder)
1016       return;
1017   if (Limits.nodes)
1018   {
1019       Threads.mutex.lock();
1020       nodes = RootPos.nodes_searched();
1021 <a name="8"></a>            for (Thread* th : Threads)</b></font>
1022 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          for (int i = 0; i &lt; th-&gt;splitPointsSize; ++i)
1023           {
1024               SplitPoint&amp; sp = th-&gt;splitPoints[i];
1025               sp.mutex.lock();
1026               nodes += sp.nodes;
1027               for (size_t idx = 0; idx &lt; Threads.size(); ++idx)
1028                   if (sp.slavesMask.test(idx) &amp;&amp; Threads[idx]-&gt;activePosition)
1029                       nodes += Threads[idx]-&gt;activePosition-&gt;nodes_searched();
1030               sp.mutex.unlock();
1031           }
1032       Threads.mutex.unlock();
1033   }
1034   Time::point elapsed = Time::now() - SearchTime;
1035   bool stillAtFirstMove =    Signals.firstRootMove
1036                          &amp;&amp; !Signals.failedLowAtRoot
1037                          &amp;&amp;  elapsed &gt; TimeMgr.available_time() * 75 / 100;
1038   bool noMoreTime =   elapsed &gt; TimeMgr.maximum_time() - 2 * TimerThread::Resolution
1039                    || stillAtFirstMove;
1040   if (   (Limits.use_time_management() &amp;&amp; noMoreTime)
1041       || (Limits.movetime &amp;&amp; elapsed &gt;= Limits.movetime)
1042       || (Limits.nodes &amp;&amp; nodes &gt;= Limits.nodes))
1043       Signals.stop = true;
1044 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>search.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;cassert&gt;
3 #include &lt;cfloat&gt;
4 #include &lt;cmath&gt;
5 #include &lt;cstring&gt;
6 #include &lt;iostream&gt;
7 #include &lt;sstream&gt;
8 #include "book.h"
9 #include "evaluate.h"
10 #include "movegen.h"
11 #include "movepick.h"
12 #include "notation.h"
13 #include "search.h"
14 #include "timeman.h"
15 #include "thread.h"
16 <a name="1"></a>#include "tt.h"
17 #include "ucioption.h"
18 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>namespace Search {
19   volatile SignalsType Signals;
20   LimitsType Limits;
21   std::vector&lt;RootMove&gt; RootMoves;
22   Position RootPos;
23   Color RootColor;
24   Time::point SearchTime;
25   StateStackPtr SetupStates;
26 }
27 using std::string;
28 using Eval::evaluate;
29 using namespace Search;
30 namespace {
31   const bool FakeSplit = false;
32   enum NodeType { Root, PV, NonPV };
33   inline Value razor_margin(Depth d) { return Value(512 + 16 * d); }
34   int FutilityMoveCounts[2][32]; 
35   inline Value futility_margin(Depth d) {
36     return Value(100 * d);
37   }
38   int8_t Reductions[2][2][64][64]; 
39   template &lt;bool PvNode&gt; inline Depth reduction(bool i, Depth d, int mn) {
40     return (Depth) Reductions[PvNode][i][std::min(int(d) / ONE_PLY, 63)][std::min(mn, 63)];
41   }
42   size_t MultiPV, PVIdx;
43   TimeManager TimeMgr;
44   double BestMoveChanges;
45   Value DrawValue[COLOR_NB];
46   HistoryStats History;
47   GainsStats Gains;
48   MovesStats Countermoves, Followupmoves;
49   template &lt;NodeType NT, bool SpNode&gt;
50   Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode);
51   template &lt;NodeType NT, bool InCheck&gt;
52   Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth);
53   void id_loop(Position&amp; pos);
54   Value value_to_tt(Value v, int ply);
55   Value value_from_tt(Value v, int ply);
56   void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt);
57   string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta);
58   struct Skill {
59     Skill(int l) : level(l), best(MOVE_NONE) {}
60    ~Skill() {
61       if (enabled())           std::swap(RootMoves[0], *std::find(RootMoves.begin(),
62                     RootMoves.end(), best ? best : pick_move()));
63     }
64     bool enabled() const { return level &lt; 20; }
65     bool time_to_pick(int depth) const { return depth == 1 + level; }
66     Move pick_move();
67     int level;
68     Move best;
69   };
70 } 
71 void Search::init() {
72   int d;    int hd;   int mc; 
73   for (hd = 1; hd &lt; 64; ++hd) for (mc = 1; mc &lt; 64; ++mc)
74   {
75       double    pvRed = 0.00 + log(double(hd)) * log(double(mc)) / 3.00;
76       double nonPVRed = 0.33 + log(double(hd)) * log(double(mc)) / 2.25;
77       Reductions[1][1][hd][mc] = int8_t(   pvRed &gt;= 1.0 ?    pvRed * int(ONE_PLY) : 0);
78       Reductions[0][1][hd][mc] = int8_t(nonPVRed &gt;= 1.0 ? nonPVRed * int(ONE_PLY) : 0);
79       Reductions[1][0][hd][mc] = Reductions[1][1][hd][mc];
80       Reductions[0][0][hd][mc] = Reductions[0][1][hd][mc];
81       if (Reductions[0][0][hd][mc] &gt; 2 * ONE_PLY)
82           Reductions[0][0][hd][mc] += ONE_PLY;
83       else if (Reductions[0][0][hd][mc] &gt; 1 * ONE_PLY)
84           Reductions[0][0][hd][mc] += ONE_PLY / 2;
85   }
86   for (d = 0; d &lt; 32; ++d)
87   {
88       FutilityMoveCounts[0][d] = int(2.4 + 0.222 * pow(d + 0.00, 1.8));
89       FutilityMoveCounts[1][d] = int(3.0 + 0.300 * pow(d + 0.98, 1.8));
90   }
91 }
92 static uint64_t perft(Position&amp; pos, Depth depth) {
93   StateInfo st;
94   uint64_t cnt = 0;
95   CheckInfo ci(pos);
96 <a name="6"></a>  const bool leaf = depth == 2 * ONE_PLY;
97   for (MoveList&lt;LEGAL&gt; it(pos); *it; ++it)</b></font>
98 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
99       pos.do_move(*it, st, ci, pos.gives_check(*it, ci));
100       cnt += leaf ? MoveList&lt;LEGAL&gt;(pos).size() : ::perft(pos, depth - ONE_PLY);
101       pos.undo_move(*it);
102   }
103   return cnt;
104 }
105 uint64_t Search::perft(Position&amp; pos, Depth depth) {
106   return depth &gt; ONE_PLY ? ::perft(pos, depth) : MoveList&lt;LEGAL&gt;(pos).size();
107 }
108 void Search::think() {
109   static PolyglotBook book; 
110   RootColor = RootPos.side_to_move();
111   TimeMgr.init(Limits, RootPos.game_ply(), RootColor);
112   int cf = Options["Contempt Factor"] * PawnValueEg / 100;   DrawValue[ RootColor] = VALUE_DRAW - Value(cf);
113   DrawValue[~RootColor] = VALUE_DRAW + Value(cf);
114   if (RootMoves.empty())
115   {
116       RootMoves.push_back(MOVE_NONE);
117       sync_cout &lt;&lt; "info depth 0 score "
118                 &lt;&lt; score_to_uci(RootPos.checkers() ? -VALUE_MATE : VALUE_DRAW)
119                 &lt;&lt; sync_endl;
120       goto finalize;
121   }
122   if (Options["OwnBook"] &amp;&amp; !Limits.infinite &amp;&amp; !Limits.mate)
123   {
124       Move bookMove = book.probe(RootPos, Options["Book File"], Options["Best Book Move"]);
125       if (bookMove &amp;&amp; std::count(RootMoves.begin(), RootMoves.end(), bookMove))
126       {
127           std::swap(RootMoves[0], *std::find(RootMoves.begin(), RootMoves.end(), bookMove));
128           goto finalize;
129       }
130   }
131   if (Options["Write Search Log"])
132   {
133       Log log(Options["Search Log Filename"]);
134       log &lt;&lt; "\nSearching: "  &lt;&lt; RootPos.fen()
135           &lt;&lt; "\ninfinite: "   &lt;&lt; Limits.infinite
136           &lt;&lt; " ponder: "      &lt;&lt; Limits.ponder
137           &lt;&lt; " time: "        &lt;&lt; Limits.time[RootColor]
138           &lt;&lt; " increment: "   &lt;&lt; Limits.inc[RootColor]
139           &lt;&lt; " moves to go: " &lt;&lt; Limits.movestogo
140           &lt;&lt; "\n" &lt;&lt; std::endl;
141   }
142   for (size_t i = 0; i &lt; Threads.size(); ++i)
143       Threads[i]-&gt;maxPly = 0;</b></font>
144   Threads.timer-&gt;run = true;
145   Threads.timer-&gt;notify_one(); 
146   id_loop(RootPos); <a name="7"></a>
147   Threads.timer-&gt;run = false; 
148 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if (Options["Write Search Log"])
149   {
150       Time::point elapsed = Time::now() - SearchTime + 1;
151       Log log(Options["Search Log Filename"]);
152       log &lt;&lt; "Nodes: "          &lt;&lt; RootPos.nodes_searched()
153           &lt;&lt; "\nNodes/second: " &lt;&lt; RootPos.nodes_searched() * 1000 / elapsed
154           &lt;&lt; "\nBest move: "    &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[0]);
155       StateInfo st;
156       RootPos.do_move(RootMoves[0].pv[0], st);
157       log &lt;&lt; "\nPonder move: " &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[1]) &lt;&lt; std::endl;
158       RootPos.undo_move(RootMoves[0].pv[0]);
159   }
160 finalize:
161   sync_cout &lt;&lt; "info nodes " &lt;&lt; RootPos.nodes_searched()
162             &lt;&lt; " time " &lt;&lt; Time::now() - SearchTime + 1 &lt;&lt; sync_endl;
163   if (!Signals.stop &amp;&amp; (Limits.ponder || Limits.infinite))
164   {
165       Signals.stopOnPonderhit = true;
166       RootPos.this_thread()-&gt;wait_for(Signals.stop);
167   }
168   sync_cout &lt;&lt; "bestmove " &lt;&lt; move_to_uci(RootMoves[0].pv[0], RootPos.is_chess960())
169             &lt;&lt; " ponder "  &lt;&lt; move_to_uci(RootMoves[0].pv[1], RootPos.is_chess960())
170             &lt;&lt; sync_endl;
171 }
172 namespace {
173   void id_loop(Position&amp; pos) {
174     Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;     int depth;
175     Value bestValue, alpha, beta, delta;
176     std::memset(ss-2, 0, 5 * sizeof(Stack));
177     (ss-1)-&gt;currentMove = MOVE_NULL; 
178     depth = 0;
179     BestMoveChanges = 0;
180     bestValue = delta = alpha = -VALUE_INFINITE;
181     beta = VALUE_INFINITE;
182     TT.new_search();
183     History.clear();
184     Gains.clear();
185     Countermoves.clear();
186     Followupmoves.clear();
187     MultiPV = Options["MultiPV"];
188     Skill skill(Options["Skill Level"]);
189     if (skill.enabled() &amp;&amp; MultiPV &lt; 4)
190         MultiPV = 4;
191     MultiPV = std::min(MultiPV, RootMoves.size());
192     while (++depth &lt;= MAX_PLY &amp;&amp; !Signals.stop &amp;&amp; (!Limits.depth || depth &lt;= Limits.depth))
193     {
194         BestMoveChanges *= 0.5;
195 <a name="2"></a>                for (size_t i = 0; i &lt; RootMoves.size(); ++i)</b></font>
196 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            RootMoves[i].prevScore = RootMoves[i].score;
197         for (PVIdx = 0; PVIdx &lt; MultiPV &amp;&amp; !Signals.stop; ++PVIdx)
198         {
199             if (depth &gt;= 5)
200             {
201                 delta = Value(16);
202                 alpha = std::max(RootMoves[PVIdx].prevScore - delta,-VALUE_INFINITE);
203                 beta  = std::min(RootMoves[PVIdx].prevScore + delta, VALUE_INFINITE);
204             }
205             while (true)
206             {
207                 bestValue = search&lt;Root, false&gt;(pos, ss, alpha, beta, depth * ONE_PLY, false);
208                 std::stable_sort(RootMoves.begin() + PVIdx, RootMoves.end());
209                 for (size_t i = 0; i &lt;= PVIdx; ++i)
210                     RootMoves[i].insert_pv_in_tt(pos);
211                 if (Signals.stop)
212                     break;
213                 if (  (bestValue &lt;= alpha || bestValue &gt;= beta)
214                     &amp;&amp; Time::now() - SearchTime &gt; 3000)
215                     sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
216                 if (bestValue &lt;= alpha)
217                 {
218                     alpha = std::max(bestValue - delta, -VALUE_INFINITE);
219                     Signals.failedLowAtRoot = true;
220                     Signals.stopOnPonderhit = false;
221                 }
222                 else if (bestValue &gt;= beta)
223                     beta = std::min(bestValue + delta, VALUE_INFINITE);
224                 else
225                     break;
226                 delta += delta / 2;
227                 assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; beta &lt;= VALUE_INFINITE);
228             }
229             std::stable_sort(RootMoves.begin(), RootMoves.begin() + PVIdx + 1);
230             if (PVIdx + 1 == MultiPV || Time::now() - SearchTime &gt; 3000)
231                 sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
232         }
233         if (skill.enabled() &amp;&amp; skill.time_to_pick(depth))
234             skill.pick_move();
235         if (Options["Write Search Log"])
236         {
237             RootMove&amp; rm = RootMoves[0];
238             if (skill.best != MOVE_NONE)
239                 rm = *std::find(RootMoves.begin(), RootMoves.end(), skill.best);
240             Log log(Options["Search Log Filename"]);
241             log &lt;&lt; pretty_pv(pos, depth, rm.score, Time::now() - SearchTime, &amp;rm.pv[0])
242                 &lt;&lt; std::endl;
243         }
244         if (   Limits.mate
245             &amp;&amp; bestValue &gt;= VALUE_MATE_IN_MAX_PLY
246             &amp;&amp; VALUE_MATE - bestValue &lt;= 2 * Limits.mate)
247             Signals.stop = true;
248         if (Limits.use_time_management() &amp;&amp; !Signals.stop &amp;&amp; !Signals.stopOnPonderhit)
249         {
250             if (depth &gt; 4 &amp;&amp; depth &lt; 50 &amp;&amp;  MultiPV == 1)
251                 TimeMgr.pv_instability(BestMoveChanges);
252             if (   RootMoves.size() == 1
253                 || Time::now() - SearchTime &gt; TimeMgr.available_time())
254             {
255                 if (Limits.ponder)
256                     Signals.stopOnPonderhit = true;
257                 else
258                     Signals.stop = true;
259             }
260         }
261     }
262   }
263   template &lt;NodeType NT, bool SpNode&gt;
264   Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {
265     const bool RootNode = NT == Root;
266     const bool PvNode   = NT == PV || NT == Root;
267     assert(-VALUE_INFINITE &lt;= alpha &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
268     assert(PvNode || (alpha == beta - 1));
269     assert(depth &gt; DEPTH_ZERO);
270     Move quietsSearched[64];
271     StateInfo st;
272     const TTEntry *tte;
273     SplitPoint* splitPoint;
274     Key posKey;
275     Move ttMove, move, excludedMove, bestMove;
276     Depth ext, newDepth, predictedDepth;
277     Value bestValue, value, ttValue, eval, nullValue, futilityValue;
278     bool inCheck, givesCheck, pvMove, singularExtensionNode, improving;
279     bool captureOrPromotion, dangerous, doFullDepthSearch;
280     int moveCount, quietCount;
281     Thread* thisThread = pos.this_thread();
282     inCheck = pos.checkers();
283     if (SpNode)
284     {
285         splitPoint = ss-&gt;splitPoint;
286 <a name="5"></a>        bestMove   = splitPoint-&gt;bestMove;
287         bestValue  = splitPoint-&gt;bestValue;
288         tte = NULL;</b></font>
289 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        ttMove = excludedMove = MOVE_NONE;
290         ttValue = VALUE_NONE;
291         assert(splitPoint-&gt;bestValue &gt; -VALUE_INFINITE &amp;&amp; splitPoint-&gt;moveCount &gt; 0);
292         goto moves_loop;
293     }
294     moveCount = quietCount = 0;
295     bestValue = -VALUE_INFINITE;
296     ss-&gt;currentMove = ss-&gt;ttMove = (ss+1)-&gt;excludedMove = bestMove = MOVE_NONE;
297     ss-&gt;ply = (ss-1)-&gt;ply + 1;
298     (ss+1)-&gt;skipNullMove = false; (ss+1)-&gt;reduction = DEPTH_ZERO;
299     (ss+2)-&gt;killers[0] = (ss+2)-&gt;killers[1] = MOVE_NONE;
300     if (PvNode &amp;&amp; thisThread-&gt;maxPly &lt; ss-&gt;ply)
301         thisThread-&gt;maxPly = ss-&gt;ply;
302     if (!RootNode)
303     {
304         if (Signals.stop || pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
305             return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !inCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
306         alpha = std::max(mated_in(ss-&gt;ply), alpha);
307         beta = std::min(mate_in(ss-&gt;ply+1), beta);
308         if (alpha &gt;= beta)
309             return alpha;
310     }
311     excludedMove = ss-&gt;excludedMove;
312     posKey = excludedMove ? pos.exclusion_key() : pos.key();
313     tte = TT.probe(posKey);
314     ss-&gt;ttMove = ttMove = RootNode ? RootMoves[PVIdx].pv[0] : tte ? tte-&gt;move() : MOVE_NONE;
315     ttValue = tte ? value_from_tt(tte-&gt;value(), ss-&gt;ply) : VALUE_NONE;
316     if (   !RootNode
317         &amp;&amp; tte
318         &amp;&amp; tte-&gt;depth() &gt;= depth
319         &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
320             : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
321                               : (tte-&gt;bound() &amp;  BOUND_UPPER)))
322     {
323         ss-&gt;currentMove = ttMove; 
324 <a name="0"></a>        if (ttValue &gt;= beta &amp;&amp; ttMove &amp;&amp; !pos.capture_or_promotion(ttMove) &amp;&amp; !inCheck)</b></font>
325             update_stats(pos, ss, ttMove, depth, NULL, 0);
326 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        return ttValue;
327     }
328     if (inCheck)
329     {
330         ss-&gt;staticEval = eval = VALUE_NONE;
331         goto moves_loop;
332     }
333     else if (tte)
334     {
335         if ((ss-&gt;staticEval = eval = tte-&gt;eval_value()) == VALUE_NONE)
336             eval = ss-&gt;staticEval = evaluate(pos);
337         if (ttValue != VALUE_NONE)
338             if (tte-&gt;bound() &amp; (ttValue &gt; eval ? BOUND_LOWER : BOUND_UPPER))
339                 eval = ttValue;
340     }
341     else
342     {
343         eval = ss-&gt;staticEval = evaluate(pos);
344         TT.store(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
345     }
346     if (   !pos.captured_piece_type()
347         &amp;&amp;  ss-&gt;staticEval != VALUE_NONE
348         &amp;&amp; (ss-1)-&gt;staticEval != VALUE_NONE
349         &amp;&amp; (move = (ss-1)-&gt;currentMove) != MOVE_NULL
350         &amp;&amp;  type_of(move) == NORMAL)
351     {
352         Square to = to_sq(move);
353         Gains.update(pos.piece_on(to), to, -(ss-1)-&gt;staticEval - ss-&gt;staticEval);
354     }
355     if (   !PvNode
356         &amp;&amp;  depth &lt; 4 * ONE_PLY
357         &amp;&amp;  eval + razor_margin(depth) &lt;= alpha
358         &amp;&amp;  ttMove == MOVE_NONE
359         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
360         &amp;&amp; !pos.pawn_on_7th(pos.side_to_move()))
361     {
362         if (   depth &lt;= ONE_PLY
363             &amp;&amp; eval + razor_margin(3 * ONE_PLY) &lt;= alpha)
364             return qsearch&lt;NonPV, false&gt;(pos, ss, alpha, beta, DEPTH_ZERO);
365         Value ralpha = alpha - razor_margin(depth);
366         Value v = qsearch&lt;NonPV, false&gt;(pos, ss, ralpha, ralpha+1, DEPTH_ZERO);
367         if (v &lt;= ralpha)
368             return v;
369     }
370     if (   !PvNode
371         &amp;&amp; !ss-&gt;skipNullMove
372         &amp;&amp;  depth &lt; 7 * ONE_PLY
373         &amp;&amp;  eval - futility_margin(depth) &gt;= beta
374         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
375         &amp;&amp;  abs(eval) &lt; VALUE_KNOWN_WIN
376         &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
377         return eval - futility_margin(depth);
378     if (   !PvNode
379         &amp;&amp; !ss-&gt;skipNullMove
380         &amp;&amp;  depth &gt;= 2 * ONE_PLY
381         &amp;&amp;  eval &gt;= beta
382         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
383         &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
384     {
385         ss-&gt;currentMove = MOVE_NULL;
386         assert(eval - beta &gt;= 0);
387         Depth R =  3 * ONE_PLY
388                  + depth / 4
389                  + int(eval - beta) / PawnValueMg * ONE_PLY;
390         pos.do_null_move(st);
391         (ss+1)-&gt;skipNullMove = true;
392         nullValue = depth-R &lt; ONE_PLY ? -qsearch&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, DEPTH_ZERO)
393                                       : - search&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, depth-R, !cutNode);
394         (ss+1)-&gt;skipNullMove = false;
395         pos.undo_null_move();
396         if (nullValue &gt;= beta)
397         {
398             if (nullValue &gt;= VALUE_MATE_IN_MAX_PLY)
399                 nullValue = beta;
400             if (depth &lt; 12 * ONE_PLY)
401                 return nullValue;
402             ss-&gt;skipNullMove = true;
403             Value v = depth-R &lt; ONE_PLY ? qsearch&lt;NonPV, false&gt;(pos, ss, beta-1, beta, DEPTH_ZERO)
404                                         :  search&lt;NonPV, false&gt;(pos, ss, beta-1, beta, depth-R, false);
405             ss-&gt;skipNullMove = false;
406             if (v &gt;= beta)
407                 return nullValue;
408         }
409     }
410     if (   !PvNode
411         &amp;&amp;  depth &gt;= 5 * ONE_PLY
412         &amp;&amp; !ss-&gt;skipNullMove
413         &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY)
414     {
415         Value rbeta = std::min(beta + 200, VALUE_INFINITE);
416         Depth rdepth = depth - 4 * ONE_PLY;
417         assert(rdepth &gt;= ONE_PLY);
418         assert((ss-1)-&gt;currentMove != MOVE_NONE);
419         assert((ss-1)-&gt;currentMove != MOVE_NULL);
420         MovePicker mp(pos, ttMove, History, pos.captured_piece_type());
421         CheckInfo ci(pos);
422         while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
423             if (pos.legal(move, ci.pinned))
424             {
425                 ss-&gt;currentMove = move;
426                 pos.do_move(move, st, ci, pos.gives_check(move, ci));
427                 value = -search&lt;NonPV, false&gt;(pos, ss+1, -rbeta, -rbeta+1, rdepth, !cutNode);
428                 pos.undo_move(move);
429                 if (value &gt;= rbeta)
430                     return value;
431             }
432     }
433     if (    depth &gt;= (PvNode ? 5 * ONE_PLY : 8 * ONE_PLY)
434         &amp;&amp; !ttMove
435         &amp;&amp; (PvNode || ss-&gt;staticEval + 256 &gt;= beta))
436     {
437         Depth d = depth - 2 * ONE_PLY - (PvNode ? DEPTH_ZERO : depth / 4);
438         ss-&gt;skipNullMove = true;
439         search&lt;PvNode ? PV : NonPV, false&gt;(pos, ss, alpha, beta, d, true);
440         ss-&gt;skipNullMove = false;
441         tte = TT.probe(posKey);
442         ttMove = tte ? tte-&gt;move() : MOVE_NONE;
443     }
444 moves_loop: 
445     Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
446     Move countermoves[] = { Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].first,
447                             Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].second };
448     Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
449     Move followupmoves[] = { Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].first,
450                              Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].second };
451     MovePicker mp(pos, ttMove, depth, History, countermoves, followupmoves, ss);
452     CheckInfo ci(pos);
453     value = bestValue;     improving =   ss-&gt;staticEval &gt;= (ss-2)-&gt;staticEval
454                || ss-&gt;staticEval == VALUE_NONE
455                ||(ss-2)-&gt;staticEval == VALUE_NONE;
456     singularExtensionNode =   !RootNode
457                            &amp;&amp; !SpNode
458                            &amp;&amp;  depth &gt;= 8 * ONE_PLY
459                            &amp;&amp;  ttMove != MOVE_NONE
460                            &amp;&amp; !excludedMove                            &amp;&amp; (tte-&gt;bound() &amp; BOUND_LOWER)
461                            &amp;&amp;  tte-&gt;depth() &gt;= depth - 3 * ONE_PLY;
462     while ((move = mp.next_move&lt;SpNode&gt;()) != MOVE_NONE)
463     {
464       assert(is_ok(move));
465       if (move == excludedMove)
466           continue;
467       if (RootNode &amp;&amp; !std::count(RootMoves.begin() + PVIdx, RootMoves.end(), move))
468           continue;
469       if (SpNode)
470       {
471           if (!pos.legal(move, ci.pinned))
472               continue;
473           moveCount = ++splitPoint-&gt;moveCount;
474           splitPoint-&gt;mutex.unlock();
475       }
476       else
477           ++moveCount;
478       if (RootNode)
479       {
480           Signals.firstRootMove = (moveCount == 1);
481           if (thisThread == Threads.main() &amp;&amp; Time::now() - SearchTime &gt; 3000)
482               sync_cout &lt;&lt; "info depth " &lt;&lt; depth / ONE_PLY
483                         &lt;&lt; " currmove " &lt;&lt; move_to_uci(move, pos.is_chess960())
484                         &lt;&lt; " currmovenumber " &lt;&lt; moveCount + PVIdx &lt;&lt; sync_endl;
485       }
486       ext = DEPTH_ZERO;
487       captureOrPromotion = pos.capture_or_promotion(move);
488       givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
489                   ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
490                   : pos.gives_check(move, ci);
491       dangerous =   givesCheck
492                  || type_of(move) != NORMAL
493                  || pos.advanced_pawn_push(move);
494       if (givesCheck &amp;&amp; pos.see_sign(move) &gt;= VALUE_ZERO)
495           ext = ONE_PLY;
496       if (    singularExtensionNode
497           &amp;&amp;  move == ttMove
498           &amp;&amp; !ext
499           &amp;&amp;  pos.legal(move, ci.pinned)
500           &amp;&amp;  abs(ttValue) &lt; VALUE_KNOWN_WIN)
501       {
502           assert(ttValue != VALUE_NONE);
503           Value rBeta = ttValue - int(depth);
504           ss-&gt;excludedMove = move;
505           ss-&gt;skipNullMove = true;
506           value = search&lt;NonPV, false&gt;(pos, ss, rBeta - 1, rBeta, depth / 2, cutNode);
507           ss-&gt;skipNullMove = false;
508           ss-&gt;excludedMove = MOVE_NONE;
509           if (value &lt; rBeta)
510               ext = ONE_PLY;
511       }
512       newDepth = depth - ONE_PLY + ext;
513       if (   !PvNode
514           &amp;&amp; !captureOrPromotion
515           &amp;&amp; !inCheck
516           &amp;&amp; !dangerous
517           &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY)
518       {
519           if (   depth &lt; 16 * ONE_PLY
520               &amp;&amp; moveCount &gt;= FutilityMoveCounts[improving][depth] )
521           {
522               if (SpNode)
523                   splitPoint-&gt;mutex.lock();
524               continue;
525           }
526           predictedDepth = newDepth - reduction&lt;PvNode&gt;(improving, depth, moveCount);
527           if (predictedDepth &lt; 7 * ONE_PLY)
528           {
529               futilityValue = ss-&gt;staticEval + futility_margin(predictedDepth)
530                             + 128 + Gains[pos.moved_piece(move)][to_sq(move)];
531               if (futilityValue &lt;= alpha)
532               {
533                   bestValue = std::max(bestValue, futilityValue);
534                   if (SpNode)
535                   {
536                       splitPoint-&gt;mutex.lock();
537                       if (bestValue &gt; splitPoint-&gt;bestValue)
538                           splitPoint-&gt;bestValue = bestValue;
539                   }
540                   continue;
541               }
542           }
543           if (predictedDepth &lt; 4 * ONE_PLY &amp;&amp; pos.see_sign(move) &lt; VALUE_ZERO)
544           {
545               if (SpNode)
546                   splitPoint-&gt;mutex.lock();
547               continue;
548           }
549       }
550       if (!RootNode &amp;&amp; !SpNode &amp;&amp; !pos.legal(move, ci.pinned))
551       {
552           moveCount--;
553           continue;
554       }
555       pvMove = PvNode &amp;&amp; moveCount == 1;
556       ss-&gt;currentMove = move;
557       if (!SpNode &amp;&amp; !captureOrPromotion &amp;&amp; quietCount &lt; 64)
558           quietsSearched[quietCount++] = move;
559       pos.do_move(move, st, ci, givesCheck);
560       if (    depth &gt;= 3 * ONE_PLY
561           &amp;&amp; !pvMove
562           &amp;&amp; !captureOrPromotion
563           &amp;&amp;  move != ttMove
564           &amp;&amp;  move != ss-&gt;killers[0]
565           &amp;&amp;  move != ss-&gt;killers[1])
566       {
567           ss-&gt;reduction = reduction&lt;PvNode&gt;(improving, depth, moveCount);
568           if (!PvNode &amp;&amp; cutNode)
569               ss-&gt;reduction += ONE_PLY;
570           else if (History[pos.piece_on(to_sq(move))][to_sq(move)] &lt; 0)
571               ss-&gt;reduction += ONE_PLY / 2;
572           if (move == countermoves[0] || move == countermoves[1])
573               ss-&gt;reduction = std::max(DEPTH_ZERO, ss-&gt;reduction - ONE_PLY);
574           Depth d = std::max(newDepth - ss-&gt;reduction, ONE_PLY);
575           if (SpNode)
576               alpha = splitPoint-&gt;alpha;
577           value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d, true);
578           if (value &gt; alpha &amp;&amp; ss-&gt;reduction &gt;= 4 * ONE_PLY)
579           {
580               Depth d2 = std::max(newDepth - 2 * ONE_PLY, ONE_PLY);
581               value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d2, true);
582           }
583           doFullDepthSearch = (value &gt; alpha &amp;&amp; ss-&gt;reduction != DEPTH_ZERO);
584           ss-&gt;reduction = DEPTH_ZERO;
585       }
586       else
587           doFullDepthSearch = !pvMove;
588       if (doFullDepthSearch)
589       {
590           if (SpNode)
591               alpha = splitPoint-&gt;alpha;
592           value = newDepth &lt; ONE_PLY ?
593                           givesCheck ? -qsearch&lt;NonPV,  true&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
594                                      : -qsearch&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
595                                      : - search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, newDepth, !cutNode);
596       }
597       if (PvNode &amp;&amp; (pvMove || (value &gt; alpha &amp;&amp; (RootNode || value &lt; beta))))
598           value = newDepth &lt; ONE_PLY ?
599                           givesCheck ? -qsearch&lt;PV,  true&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
600                                      : -qsearch&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
601                                      : - search&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, newDepth, false);
602       pos.undo_move(move);
603       assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
604       if (SpNode)
605       {
606           splitPoint-&gt;mutex.lock();
607           bestValue = splitPoint-&gt;bestValue;
608           alpha = splitPoint-&gt;alpha;
609       }
610       if (Signals.stop || thisThread-&gt;cutoff_occurred())
611           return VALUE_ZERO;
612       if (RootNode)
613       {
614           RootMove&amp; rm = *std::find(RootMoves.begin(), RootMoves.end(), move);
615           if (pvMove || value &gt; alpha)
616           {
617               rm.score = value;
618               rm.extract_pv_from_tt(pos);
619               if (!pvMove)
620                   ++BestMoveChanges;
621           }
622           else
623               rm.score = -VALUE_INFINITE;
624       }
625       if (value &gt; bestValue)
626       {
627           bestValue = SpNode ? splitPoint-&gt;bestValue = value : value;
628           if (value &gt; alpha)
629           {
630               bestMove = SpNode ? splitPoint-&gt;bestMove = move : move;
631               if (PvNode &amp;&amp; value &lt; beta)                   alpha = SpNode ? splitPoint-&gt;alpha = value : value;
632               else
633               {
634                   assert(value &gt;= beta); 
635                   if (SpNode)
636                       splitPoint-&gt;cutoff = true;
637                   break;
638               }
639           }
640       }
641       if (   !SpNode
642           &amp;&amp;  Threads.size() &gt;= 2
643           &amp;&amp;  depth &gt;= Threads.minimumSplitDepth
644           &amp;&amp;  (   !thisThread-&gt;activeSplitPoint
645                || !thisThread-&gt;activeSplitPoint-&gt;allSlavesSearching)
646           &amp;&amp;  thisThread-&gt;splitPointsSize &lt; MAX_SPLITPOINTS_PER_THREAD)
647       {
648           assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; beta);
649           thisThread-&gt;split&lt;FakeSplit&gt;(pos, ss, alpha, beta, &amp;bestValue, &amp;bestMove,
650                                        depth, moveCount, &amp;mp, NT, cutNode);
651           if (Signals.stop || thisThread-&gt;cutoff_occurred())
652               return VALUE_ZERO;
653           if (bestValue &gt;= beta)
654               break;
655       }
656     }
657     if (SpNode)
658         return bestValue;
659     if (!moveCount)
660         bestValue = excludedMove ? alpha
661                    :     inCheck ? mated_in(ss-&gt;ply) : DrawValue[pos.side_to_move()];
662     else if (bestValue &gt;= beta &amp;&amp; !pos.capture_or_promotion(bestMove) &amp;&amp; !inCheck)
663         update_stats(pos, ss, bestMove, depth, quietsSearched, quietCount - 1);
664     TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
665              bestValue &gt;= beta  ? BOUND_LOWER :
666              PvNode &amp;&amp; bestMove ? BOUND_EXACT : BOUND_UPPER,
667              depth, bestMove, ss-&gt;staticEval);
668     assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
669     return bestValue;
670   }
671   template &lt;NodeType NT, bool InCheck&gt;
672   Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth) {
673     const bool PvNode = NT == PV;
674     assert(NT == PV || NT == NonPV);
675     assert(InCheck == !!pos.checkers());
676     assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
677     assert(PvNode || (alpha == beta - 1));
678     assert(depth &lt;= DEPTH_ZERO);
679     StateInfo st;
680     const TTEntry* tte;
681     Key posKey;
682     Move ttMove, move, bestMove;
683     Value bestValue, value, ttValue, futilityValue, futilityBase, oldAlpha;
684     bool givesCheck, evasionPrunable;
685     Depth ttDepth;
686     if (PvNode)
687         oldAlpha = alpha;
688     ss-&gt;currentMove = bestMove = MOVE_NONE;
689     ss-&gt;ply = (ss-1)-&gt;ply + 1;
690     if (pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
691         return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !InCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
692     ttDepth = InCheck || depth &gt;= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS
693                                                   : DEPTH_QS_NO_CHECKS;
694     posKey = pos.key();
695     tte = TT.probe(posKey);
696     ttMove = tte ? tte-&gt;move() : MOVE_NONE;
697     ttValue = tte ? value_from_tt(tte-&gt;value(),ss-&gt;ply) : VALUE_NONE;
698     if (   tte
699         &amp;&amp; tte-&gt;depth() &gt;= ttDepth
700         &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
701             : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
702                               : (tte-&gt;bound() &amp;  BOUND_UPPER)))
703     {
704         ss-&gt;currentMove = ttMove;         return ttValue;
705     }
706     if (InCheck)
707     {
708         ss-&gt;staticEval = VALUE_NONE;
709         bestValue = futilityBase = -VALUE_INFINITE;
710     }
711     else
712     {
713         if (tte)
714         {
715             if ((ss-&gt;staticEval = bestValue = tte-&gt;eval_value()) == VALUE_NONE)
716                 ss-&gt;staticEval = bestValue = evaluate(pos);
717             if (ttValue != VALUE_NONE)
718                 if (tte-&gt;bound() &amp; (ttValue &gt; bestValue ? BOUND_LOWER : BOUND_UPPER))
719                     bestValue = ttValue;
720         }
721         else
722             ss-&gt;staticEval = bestValue = evaluate(pos);
723         if (bestValue &gt;= beta)
724         {
725             if (!tte)
726                 TT.store(pos.key(), value_to_tt(bestValue, ss-&gt;ply), BOUND_LOWER,
727                          DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
728             return bestValue;
729         }
730         if (PvNode &amp;&amp; bestValue &gt; alpha)
731             alpha = bestValue;
732         futilityBase = bestValue + 128;
733     }
734     MovePicker mp(pos, ttMove, depth, History, to_sq((ss-1)-&gt;currentMove));
735     CheckInfo ci(pos);
736     while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
737     {
738       assert(is_ok(move));
739       givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
740                   ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
741                   : pos.gives_check(move, ci);
742       if (   !PvNode
743           &amp;&amp; !InCheck
744           &amp;&amp; !givesCheck
745           &amp;&amp;  move != ttMove
746           &amp;&amp;  futilityBase &gt; -VALUE_KNOWN_WIN
747           &amp;&amp; !pos.advanced_pawn_push(move))
748       {
749           assert(type_of(move) != ENPASSANT); 
750           futilityValue = futilityBase + PieceValue[EG][pos.piece_on(to_sq(move))];
751           if (futilityValue &lt; beta)
752           {
753               bestValue = std::max(bestValue, futilityValue);
754               continue;
755           }
756           if (futilityBase &lt; beta &amp;&amp; pos.see(move) &lt;= VALUE_ZERO)
757           {
758               bestValue = std::max(bestValue, futilityBase);
759               continue;
760           }
761       }
762       evasionPrunable =    InCheck
763                        &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY
764                        &amp;&amp; !pos.capture(move)
765                        &amp;&amp; !pos.can_castle(pos.side_to_move());
766       if (   !PvNode
767           &amp;&amp; (!InCheck || evasionPrunable)
768           &amp;&amp;  move != ttMove
769           &amp;&amp;  type_of(move) != PROMOTION
770           &amp;&amp;  pos.see_sign(move) &lt; VALUE_ZERO)
771           continue;
772       if (!pos.legal(move, ci.pinned))
773           continue;
774       ss-&gt;currentMove = move;
775       pos.do_move(move, st, ci, givesCheck);
776       value = givesCheck ? -qsearch&lt;NT,  true&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY)
777                          : -qsearch&lt;NT, false&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY);
778       pos.undo_move(move);
779       assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
780       if (value &gt; bestValue)
781       {
782           bestValue = value;
783           if (value &gt; alpha)
784           {
785               if (PvNode &amp;&amp; value &lt; beta)               {
786                   alpha = value;
787                   bestMove = move;
788               }
789               else               {
790                   TT.store(posKey, value_to_tt(value, ss-&gt;ply), BOUND_LOWER,
791                            ttDepth, move, ss-&gt;staticEval);
792                   return value;
793               }
794           }
795        }
796     }
797     if (InCheck &amp;&amp; bestValue == -VALUE_INFINITE)
798         return mated_in(ss-&gt;ply); 
799     TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
800              PvNode &amp;&amp; bestValue &gt; oldAlpha ? BOUND_EXACT : BOUND_UPPER,
801              ttDepth, bestMove, ss-&gt;staticEval);
802     assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
803     return bestValue;
804   }
805   Value value_to_tt(Value v, int ply) {
806     assert(v != VALUE_NONE);
807     return  v &gt;= VALUE_MATE_IN_MAX_PLY  ? v + ply
808           : v &lt;= VALUE_MATED_IN_MAX_PLY ? v - ply : v;
809   }
810   Value value_from_tt(Value v, int ply) {
811     return  v == VALUE_NONE             ? VALUE_NONE
812           : v &gt;= VALUE_MATE_IN_MAX_PLY  ? v - ply
813           : v &lt;= VALUE_MATED_IN_MAX_PLY ? v + ply : v;
814   }
815   void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt) {
816     if (ss-&gt;killers[0] != move)
817     {
818         ss-&gt;killers[1] = ss-&gt;killers[0];
819         ss-&gt;killers[0] = move;
820     }
821     Value bonus = Value(int(depth) * int(depth));
822     History.update(pos.moved_piece(move), to_sq(move), bonus);
823     for (int i = 0; i &lt; quietsCnt; ++i)
824     {
825         Move m = quiets[i];
826         History.update(pos.moved_piece(m), to_sq(m), -bonus);
827     }
828     if (is_ok((ss-1)-&gt;currentMove))
829     {
830         Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
831         Countermoves.update(pos.piece_on(prevMoveSq), prevMoveSq, move);
832     }
833     if (is_ok((ss-2)-&gt;currentMove) &amp;&amp; (ss-1)-&gt;currentMove == (ss-1)-&gt;ttMove)
834     {
835         Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
836         Followupmoves.update(pos.piece_on(prevOwnMoveSq), prevOwnMoveSq, move);
837     }
838   }
839   Move Skill::pick_move() {
840     static RKISS rk;
841     for (int i = Time::now() % 50; i &gt; 0; --i)
842         rk.rand&lt;unsigned&gt;();
843     int variance = std::min(RootMoves[0].score - RootMoves[MultiPV - 1].score, PawnValueMg);
844     int weakness = 120 - 2 * level;
845     int max_s = -VALUE_INFINITE;
846     best = MOVE_NONE;
847     for (size_t i = 0; i &lt; MultiPV; ++i)
848     {
849         int s = RootMoves[i].score;
850         if (i &gt; 0 &amp;&amp; RootMoves[i-1].score &gt; s + 2 * PawnValueMg)
851             break;
852         s += (  weakness * int(RootMoves[0].score - s)
853               + variance * (rk.rand&lt;unsigned&gt;() % weakness)) / 128;
854         if (s &gt; max_s)
855         {
856             max_s = s;
857             best = RootMoves[i].pv[0];
858         }
859     }
860     return best;
861   }
862   string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta) {
863     std::stringstream ss;
864     Time::point elapsed = Time::now() - SearchTime + 1;
865     size_t uciPVSize = std::min((size_t)Options["MultiPV"], RootMoves.size());
866 <a name="3"></a>    int selDepth = 0;
867     for (size_t i = 0; i &lt; Threads.size(); ++i)</b></font>
868 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        if (Threads[i]-&gt;maxPly &gt; selDepth)
869             selDepth = Threads[i]-&gt;maxPly;
870     for (size_t i = 0; i &lt; uciPVSize; ++i)
871     {
872         bool updated = (i &lt;= PVIdx);
873         if (depth == 1 &amp;&amp; !updated)
874             continue;
875         int d   = updated ? depth : depth - 1;
876         Value v = updated ? RootMoves[i].score : RootMoves[i].prevScore;
877         if (ss.rdbuf()-&gt;in_avail())             ss &lt;&lt; "\n";
878         ss &lt;&lt; "info depth " &lt;&lt; d
879            &lt;&lt; " seldepth "  &lt;&lt; selDepth
880            &lt;&lt; " score "     &lt;&lt; (i == PVIdx ? score_to_uci(v, alpha, beta) : score_to_uci(v))
881            &lt;&lt; " nodes "     &lt;&lt; pos.nodes_searched()
882            &lt;&lt; " nps "       &lt;&lt; pos.nodes_searched() * 1000 / elapsed
883            &lt;&lt; " time "      &lt;&lt; elapsed
884            &lt;&lt; " multipv "   &lt;&lt; i + 1
885            &lt;&lt; " pv";
886         for (size_t j = 0; RootMoves[i].pv[j] != MOVE_NONE; ++j)
887             ss &lt;&lt; " " &lt;&lt; move_to_uci(RootMoves[i].pv[j], pos.is_chess960());
888     }
889     return ss.str();
890   }
891 } 
892 void RootMove::extract_pv_from_tt(Position&amp; pos) {
893   StateInfo state[MAX_PLY_PLUS_6], *st = state;
894   const TTEntry* tte;
895   int ply = 1;      Move m = pv[0];   Value expectedScore = score;
896   pv.clear();
897   do {
898       pv.push_back(m);
899       assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[ply - 1]));
900       pos.do_move(pv[ply++ - 1], *st++);
901       tte = TT.probe(pos.key());
902       expectedScore = -expectedScore;
903   } while (   tte
904            &amp;&amp; expectedScore == value_from_tt(tte-&gt;value(), ply)
905            &amp;&amp; pos.pseudo_legal(m = tte-&gt;move())            &amp;&amp; pos.legal(m, pos.pinned_pieces(pos.side_to_move()))
906            &amp;&amp; ply &lt; MAX_PLY
907            &amp;&amp; (!pos.is_draw() || ply &lt;= 2));
908   pv.push_back(MOVE_NONE); 
909   while (--ply) pos.undo_move(pv[ply - 1]);
910 }
911 void RootMove::insert_pv_in_tt(Position&amp; pos) {
912   StateInfo state[MAX_PLY_PLUS_6], *st = state;
913   const TTEntry* tte;
914   int idx = 0; 
915   do {
916       tte = TT.probe(pos.key());
917       if (!tte || tte-&gt;move() != pv[idx])           TT.store(pos.key(), VALUE_NONE, BOUND_NONE, DEPTH_NONE, pv[idx], VALUE_NONE);
918       assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[idx]));
919       pos.do_move(pv[idx++], *st++);
920   } while (pv[idx] != MOVE_NONE);
921   while (idx) pos.undo_move(pv[--idx]);
922 }
923 void Thread::idle_loop() {
924   SplitPoint* this_sp = splitPointsSize ? activeSplitPoint : NULL;</b></font>
925   assert(!this_sp || (this_sp-&gt;masterThread == this &amp;&amp; searching));
926   while (true)
927   {
928       while (!searching || exit)
929       {
930           if (exit)
931           {
932               assert(!this_sp);
933               return;
934           }
935           mutex.lock();
936           if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
937           {
938               mutex.unlock();
939               break;
940           }
941           if (!searching &amp;&amp; !exit)
942               sleepCondition.wait(mutex);
943           mutex.unlock();
944       }
945       if (searching)
946       {
947           assert(!exit);
948           Threads.mutex.lock();
949           assert(searching);
950           assert(activeSplitPoint);
951           SplitPoint* sp = activeSplitPoint;
952           Threads.mutex.unlock();
953           Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;           Position pos(*sp-&gt;pos, this);
954           std::memcpy(ss-2, sp-&gt;ss-2, 5 * sizeof(Stack));
955           ss-&gt;splitPoint = sp;
956           sp-&gt;mutex.lock();
957           assert(activePosition == NULL);
958           activePosition = &amp;pos;
959           if (sp-&gt;nodeType == NonPV)
960               search&lt;NonPV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
961           else if (sp-&gt;nodeType == PV)
962               search&lt;PV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
963           else if (sp-&gt;nodeType == Root)
964               search&lt;Root, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
965           else
966               assert(false);
967           assert(searching);
968 <a name="4"></a>          searching = false;
969           activePosition = NULL;
970           sp-&gt;slavesMask.reset(idx);
971 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          sp-&gt;allSlavesSearching = false;
972           sp-&gt;nodes += pos.nodes_searched();
973           if (    this != sp-&gt;masterThread
974               &amp;&amp;  sp-&gt;slavesMask.none())
975           {
976               assert(!sp-&gt;masterThread-&gt;searching);
977               sp-&gt;masterThread-&gt;notify_one();
978           }
979           sp-&gt;mutex.unlock();
980           if (Threads.size() &gt; 2)
981               for (size_t i = 0; i &lt; Threads.size(); ++i)
982               {
983                   int size = Threads[i]-&gt;splitPointsSize;                   sp = size ? &amp;Threads[i]-&gt;splitPoints[size - 1] : NULL;
984                   if (   sp
985                       &amp;&amp; sp-&gt;allSlavesSearching
986                       &amp;&amp; available_to(Threads[i]))
987                   {
988                       Threads.mutex.lock();
989                       sp-&gt;mutex.lock();
990                       if (   sp-&gt;allSlavesSearching
991                           &amp;&amp; available_to(Threads[i]))
992                       {
993                            sp-&gt;slavesMask.set(idx);
994                            activeSplitPoint = sp;
995                            searching = true;
996                       }
997                       sp-&gt;mutex.unlock();
998                       Threads.mutex.unlock();
999                       break;                   }
1000               }
1001       }
1002       if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
1003       {
1004           this_sp-&gt;mutex.lock();
1005           bool finished = this_sp-&gt;slavesMask.none();           this_sp-&gt;mutex.unlock();
1006           if (finished)
1007               return;
1008       }
1009   }
1010 }
1011 void check_time() {
1012   static Time::point lastInfoTime = Time::now();
1013   int64_t nodes = 0; 
1014   if (Time::now() - lastInfoTime &gt;= 1000)
1015   {
1016       lastInfoTime = Time::now();
1017       dbg_print();
1018   }
1019   if (Limits.ponder)
1020       return;
1021   if (Limits.nodes)
1022   {
1023       Threads.mutex.lock();
1024       nodes = RootPos.nodes_searched();
1025 <a name="8"></a>            for (size_t i = 0; i &lt; Threads.size(); ++i)</b></font>
1026 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          for (int j = 0; j &lt; Threads[i]-&gt;splitPointsSize; ++j)
1027           {
1028               SplitPoint&amp; sp = Threads[i]-&gt;splitPoints[j];
1029               sp.mutex.lock();
1030               nodes += sp.nodes;
1031               for (size_t idx = 0; idx &lt; Threads.size(); ++idx)
1032                   if (sp.slavesMask.test(idx) &amp;&amp; Threads[idx]-&gt;activePosition)
1033                       nodes += Threads[idx]-&gt;activePosition-&gt;nodes_searched();
1034               sp.mutex.unlock();
1035           }
1036       Threads.mutex.unlock();
1037   }
1038   Time::point elapsed = Time::now() - SearchTime;
1039   bool stillAtFirstMove =    Signals.firstRootMove
1040                          &amp;&amp; !Signals.failedLowAtRoot
1041                          &amp;&amp;  elapsed &gt; TimeMgr.available_time() * 75 / 100;
1042   bool noMoreTime =   elapsed &gt; TimeMgr.maximum_time() - 2 * TimerThread::Resolution
1043                    || stillAtFirstMove;
1044   if (   (Limits.use_time_management() &amp;&amp; noMoreTime)
1045       || (Limits.movetime &amp;&amp; elapsed &gt;= Limits.movetime)
1046       || (Limits.nodes &amp;&amp; nodes &gt;= Limits.nodes))
1047       Signals.stop = true;
1048 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
