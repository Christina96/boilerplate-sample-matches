<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for search_1.cpp &amp; search.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for search_1.cpp &amp; search.cpp
      </h3>
<h1 align="center">
        96.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>search_1.cpp (96.680084%)<th>search.cpp (95.43198%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(540-1357)<td><a href="#" name="0">(540-1357)</a><td align="center"><font color="#ff0000">486</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(39-164)<td><a href="#" name="1">(39-164)</a><td align="center"><font color="#3c0000">116</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(320-475)<td><a href="#" name="2">(320-475)</a><td align="center"><font color="#2c0000">85</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1358-1462)<td><a href="#" name="3">(1358-1462)</a><td align="center"><font color="#230000">67</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1535-1624)<td><a href="#" name="4">(1540-1629)</a><td align="center"><font color="#1c0000">54</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(476-537)<td><a href="#" name="5">(476-537)</a><td align="center"><font color="#180000">47</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(165-234)<td><a href="#" name="6">(165-227)</a><td align="center"><font color="#180000">46</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(236-319)<td><a href="#" name="7">(236-319)</a><td align="center"><font color="#130000">37</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1625-1655)<td><a href="#" name="8">(1630-1660)</a><td align="center"><font color="#0c0000">23</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>search_1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cfloat&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include "book.h"
#include "evaluate.h"
#include "movegen.h"
#include "movepick.h"
#include "notation.h"
#include "search.h"
#include "timeman.h"
#include "thread.h"
<a name="1"></a>#include "tt.h"
#include "ucioption.h"
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>namespace Search {
  volatile SignalsType Signals;
  LimitsType Limits;
  std::vector&lt;RootMove&gt; RootMoves;
  Position RootPos;
  Color RootColor;
  Time::point SearchTime;
  StateStackPtr SetupStates;
}
using std::string;
using Eval::evaluate;
using namespace Search;
namespace {
  const bool FakeSplit = false;
  enum NodeType { Root, PV, NonPV };
  inline Value razor_margin(Depth d) { return Value(512 + 16 * d); }
  int FutilityMoveCounts[2][32]; 
  inline Value futility_margin(Depth d) {
    return Value(100 * d);
  }
  int8_t Reductions[2][2][64][64]; 
  template &lt;bool PvNode&gt; inline Depth reduction(bool i, Depth d, int mn) {
    return (Depth) Reductions[PvNode][i][std::min(int(d) / ONE_PLY, 63)][std::min(mn, 63)];
  }
  size_t MultiPV, PVIdx;
  TimeManager TimeMgr;
  double BestMoveChanges;
  Value DrawValue[COLOR_NB];
  HistoryStats History;
  GainsStats Gains;
  MovesStats Countermoves, Followupmoves;
  template &lt;NodeType NT, bool SpNode&gt;
  Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode);
  template &lt;NodeType NT, bool InCheck&gt;
  Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth);
  void id_loop(Position&amp; pos);
  Value value_to_tt(Value v, int ply);
  Value value_from_tt(Value v, int ply);
  void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt);
  string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta);
  struct Skill {
    Skill(int l) : level(l), best(MOVE_NONE) {}
   ~Skill() {
      if (enabled())           std::swap(RootMoves[0], *std::find(RootMoves.begin(),
                    RootMoves.end(), best ? best : pick_move()));
    }
    bool enabled() const { return level &lt; 20; }
    bool time_to_pick(int depth) const { return depth == 1 + level; }
    Move pick_move();
    int level;
    Move best;
  };
} 
void Search::init() {
  int d;    int hd;   int mc; 
  for (hd = 1; hd &lt; 64; ++hd) for (mc = 1; mc &lt; 64; ++mc)
  {
      double    pvRed = 0.00 + log(double(hd)) * log(double(mc)) / 3.00;
      double nonPVRed = 0.33 + log(double(hd)) * log(double(mc)) / 2.25;
      Reductions[1][1][hd][mc] = int8_t(   pvRed &gt;= 1.0 ?    pvRed * int(ONE_PLY) : 0);
      Reductions[0][1][hd][mc] = int8_t(nonPVRed &gt;= 1.0 ? nonPVRed * int(ONE_PLY) : 0);
      Reductions[1][0][hd][mc] = Reductions[1][1][hd][mc];
      Reductions[0][0][hd][mc] = Reductions[0][1][hd][mc];
      if (Reductions[0][0][hd][mc] &gt; 2 * ONE_PLY)
          Reductions[0][0][hd][mc] += ONE_PLY;
      else if (Reductions[0][0][hd][mc] &gt; 1 * ONE_PLY)
          Reductions[0][0][hd][mc] += ONE_PLY / 2;
  }
  for (d = 0; d &lt; 32; ++d)
  {
      FutilityMoveCounts[0][d] = int(2.4 + 0.222 * pow(d + 0.00, 1.8));
      FutilityMoveCounts[1][d] = int(3.0 + 0.300 * pow(d + 0.98, 1.8));
  }
}
static uint64_t perft(Position&amp; pos, Depth depth) {
  StateInfo st;
  uint64_t cnt = 0;
  CheckInfo ci(pos);
<a name="6"></a>  const bool leaf = depth == 2 * ONE_PLY;
  for (const ExtMove&amp; ms : MoveList&lt;LEGAL&gt;(pos))</b></font>
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
      pos.do_move(ms.move, st, ci, pos.gives_check(ms.move, ci));
      cnt += leaf ? MoveList&lt;LEGAL&gt;(pos).size() : ::perft(pos, depth - ONE_PLY);
      pos.undo_move(ms.move);
  }
  return cnt;
}
uint64_t Search::perft(Position&amp; pos, Depth depth) {
  return depth &gt; ONE_PLY ? ::perft(pos, depth) : MoveList&lt;LEGAL&gt;(pos).size();
}
void Search::think() {
  static PolyglotBook book; 
  RootColor = RootPos.side_to_move();
  TimeMgr.init(Limits, RootPos.game_ply(), RootColor);
  int cf = Options["Contempt Factor"] * PawnValueEg / 100;   DrawValue[ RootColor] = VALUE_DRAW - Value(cf);
  DrawValue[~RootColor] = VALUE_DRAW + Value(cf);
  if (RootMoves.empty())
  {
      RootMoves.push_back(MOVE_NONE);
      sync_cout &lt;&lt; "info depth 0 score "
                &lt;&lt; score_to_uci(RootPos.checkers() ? -VALUE_MATE : VALUE_DRAW)
                &lt;&lt; sync_endl;
      goto finalize;
  }
  if (Options["OwnBook"] &amp;&amp; !Limits.infinite &amp;&amp; !Limits.mate)
  {
      Move bookMove = book.probe(RootPos, Options["Book File"], Options["Best Book Move"]);
      if (bookMove &amp;&amp; std::count(RootMoves.begin(), RootMoves.end(), bookMove))
      {
          std::swap(RootMoves[0], *std::find(RootMoves.begin(), RootMoves.end(), bookMove));
          goto finalize;
      }
  }
  if (Options["Write Search Log"])
  {
      Log log(Options["Search Log Filename"]);
      log &lt;&lt; "\nSearching: "  &lt;&lt; RootPos.fen()
          &lt;&lt; "\ninfinite: "   &lt;&lt; Limits.infinite
          &lt;&lt; " ponder: "      &lt;&lt; Limits.ponder
          &lt;&lt; " time: "        &lt;&lt; Limits.time[RootColor]
          &lt;&lt; " increment: "   &lt;&lt; Limits.inc[RootColor]
          &lt;&lt; " moves to go: " &lt;&lt; Limits.movestogo
          &lt;&lt; "\n" &lt;&lt; std::endl;
  }
  for (Thread* th : Threads)
      th-&gt;maxPly = 0;
  Threads.timer-&gt;run = true;
  Threads.timer-&gt;notify_one(); 
  id_loop(RootPos); <a name="7"></a>
  Threads.timer-&gt;run = false; 
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if (Options["Write Search Log"])
  {
      Time::point elapsed = Time::now() - SearchTime + 1;
      Log log(Options["Search Log Filename"]);
      log &lt;&lt; "Nodes: "          &lt;&lt; RootPos.nodes_searched()
          &lt;&lt; "\nNodes/second: " &lt;&lt; RootPos.nodes_searched() * 1000 / elapsed
          &lt;&lt; "\nBest move: "    &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[0]);
      StateInfo st;
      RootPos.do_move(RootMoves[0].pv[0], st);
      log &lt;&lt; "\nPonder move: " &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[1]) &lt;&lt; std::endl;
      RootPos.undo_move(RootMoves[0].pv[0]);
  }
finalize:
  sync_cout &lt;&lt; "info nodes " &lt;&lt; RootPos.nodes_searched()
            &lt;&lt; " time " &lt;&lt; Time::now() - SearchTime + 1 &lt;&lt; sync_endl;
  if (!Signals.stop &amp;&amp; (Limits.ponder || Limits.infinite))
  {
      Signals.stopOnPonderhit = true;
      RootPos.this_thread()-&gt;wait_for(Signals.stop);
  }
  sync_cout &lt;&lt; "bestmove " &lt;&lt; move_to_uci(RootMoves[0].pv[0], RootPos.is_chess960())
            &lt;&lt; " ponder "  &lt;&lt; move_to_uci(RootMoves[0].pv[1], RootPos.is_chess960())
            &lt;&lt; sync_endl;
}
namespace {
  void id_loop(Position&amp; pos) {
    Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;     int depth;
    Value bestValue, alpha, beta, delta;
    std::memset(ss-2, 0, 5 * sizeof(Stack));
    (ss-1)-&gt;currentMove = MOVE_NULL; 
    depth = 0;
    BestMoveChanges = 0;
    bestValue = delta = alpha = -VALUE_INFINITE;
    beta = VALUE_INFINITE;
    TT.new_search();
    History.clear();
    Gains.clear();
    Countermoves.clear();
    Followupmoves.clear();
    MultiPV = Options["MultiPV"];
    Skill skill(Options["Skill Level"]);
    if (skill.enabled() &amp;&amp; MultiPV &lt; 4)
        MultiPV = 4;
    MultiPV = std::min(MultiPV, RootMoves.size());
    while (++depth &lt;= MAX_PLY &amp;&amp; !Signals.stop &amp;&amp; (!Limits.depth || depth &lt;= Limits.depth))
    {
        BestMoveChanges *= 0.5;
<a name="2"></a>                for (RootMove&amp; rm : RootMoves)</b></font>
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            rm.prevScore = rm.score;
        for (PVIdx = 0; PVIdx &lt; MultiPV &amp;&amp; !Signals.stop; ++PVIdx)
        {
            if (depth &gt;= 5)
            {
                delta = Value(16);
                alpha = std::max(RootMoves[PVIdx].prevScore - delta,-VALUE_INFINITE);
                beta  = std::min(RootMoves[PVIdx].prevScore + delta, VALUE_INFINITE);
            }
            while (true)
            {
                bestValue = search&lt;Root, false&gt;(pos, ss, alpha, beta, depth * ONE_PLY, false);
                std::stable_sort(RootMoves.begin() + PVIdx, RootMoves.end());
                for (size_t i = 0; i &lt;= PVIdx; ++i)
                    RootMoves[i].insert_pv_in_tt(pos);
                if (Signals.stop)
                    break;
                if (  (bestValue &lt;= alpha || bestValue &gt;= beta)
                    &amp;&amp; Time::now() - SearchTime &gt; 3000)
                    sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
                if (bestValue &lt;= alpha)
                {
                    alpha = std::max(bestValue - delta, -VALUE_INFINITE);
                    Signals.failedLowAtRoot = true;
                    Signals.stopOnPonderhit = false;
                }
                else if (bestValue &gt;= beta)
                    beta = std::min(bestValue + delta, VALUE_INFINITE);
                else
                    break;
                delta += delta / 2;
                assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; beta &lt;= VALUE_INFINITE);
            }
            std::stable_sort(RootMoves.begin(), RootMoves.begin() + PVIdx + 1);
            if (PVIdx + 1 == MultiPV || Time::now() - SearchTime &gt; 3000)
                sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
        }
        if (skill.enabled() &amp;&amp; skill.time_to_pick(depth))
            skill.pick_move();
        if (Options["Write Search Log"])
        {
            RootMove&amp; rm = RootMoves[0];
            if (skill.best != MOVE_NONE)
                rm = *std::find(RootMoves.begin(), RootMoves.end(), skill.best);
            Log log(Options["Search Log Filename"]);
            log &lt;&lt; pretty_pv(pos, depth, rm.score, Time::now() - SearchTime, &amp;rm.pv[0])
                &lt;&lt; std::endl;
        }
        if (   Limits.mate
            &amp;&amp; bestValue &gt;= VALUE_MATE_IN_MAX_PLY
            &amp;&amp; VALUE_MATE - bestValue &lt;= 2 * Limits.mate)
            Signals.stop = true;
        if (Limits.use_time_management() &amp;&amp; !Signals.stop &amp;&amp; !Signals.stopOnPonderhit)
        {
            if (depth &gt; 4 &amp;&amp; depth &lt; 50 &amp;&amp;  MultiPV == 1)
                TimeMgr.pv_instability(BestMoveChanges);
            if (   RootMoves.size() == 1
                || Time::now() - SearchTime &gt; TimeMgr.available_time())
            {
                if (Limits.ponder)
                    Signals.stopOnPonderhit = true;
                else
                    Signals.stop = true;
            }
        }
    }
  }
  template &lt;NodeType NT, bool SpNode&gt;
  Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {
    const bool RootNode = NT == Root;
    const bool PvNode   = NT == PV || NT == Root;
    assert(-VALUE_INFINITE &lt;= alpha &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(depth &gt; DEPTH_ZERO);
    Move quietsSearched[64];
    StateInfo st;
    const TTEntry *tte;
    SplitPoint* splitPoint;
    Key posKey;
    Move ttMove, move, excludedMove, bestMove;
    Depth ext, newDepth, predictedDepth;
    Value bestValue, value, ttValue, eval, nullValue, futilityValue;
    bool inCheck, givesCheck, pvMove, singularExtensionNode, improving;
    bool captureOrPromotion, dangerous, doFullDepthSearch;
    int moveCount, quietCount;
    Thread* thisThread = pos.this_thread();
    inCheck = pos.checkers();
    if (SpNode)
    {
        splitPoint = ss-&gt;splitPoint;
<a name="5"></a>        bestMove   = splitPoint-&gt;bestMove;
        bestValue  = splitPoint-&gt;bestValue;
        tte = nullptr;</b></font>
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        ttMove = excludedMove = MOVE_NONE;
        ttValue = VALUE_NONE;
        assert(splitPoint-&gt;bestValue &gt; -VALUE_INFINITE &amp;&amp; splitPoint-&gt;moveCount &gt; 0);
        goto moves_loop;
    }
    moveCount = quietCount = 0;
    bestValue = -VALUE_INFINITE;
    ss-&gt;currentMove = ss-&gt;ttMove = (ss+1)-&gt;excludedMove = bestMove = MOVE_NONE;
    ss-&gt;ply = (ss-1)-&gt;ply + 1;
    (ss+1)-&gt;skipNullMove = false; (ss+1)-&gt;reduction = DEPTH_ZERO;
    (ss+2)-&gt;killers[0] = (ss+2)-&gt;killers[1] = MOVE_NONE;
    if (PvNode &amp;&amp; thisThread-&gt;maxPly &lt; ss-&gt;ply)
        thisThread-&gt;maxPly = ss-&gt;ply;
    if (!RootNode)
    {
        if (Signals.stop || pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
            return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !inCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
        alpha = std::max(mated_in(ss-&gt;ply), alpha);
        beta = std::min(mate_in(ss-&gt;ply+1), beta);
        if (alpha &gt;= beta)
            return alpha;
    }
    excludedMove = ss-&gt;excludedMove;
    posKey = excludedMove ? pos.exclusion_key() : pos.key();
    tte = TT.probe(posKey);
    ss-&gt;ttMove = ttMove = RootNode ? RootMoves[PVIdx].pv[0] : tte ? tte-&gt;move() : MOVE_NONE;
    ttValue = tte ? value_from_tt(tte-&gt;value(), ss-&gt;ply) : VALUE_NONE;
    if (   !RootNode
        &amp;&amp; tte
        &amp;&amp; tte-&gt;depth() &gt;= depth
        &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
            : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
                              : (tte-&gt;bound() &amp;  BOUND_UPPER)))
    {
        ss-&gt;currentMove = ttMove; 
<a name="0"></a>        if (ttValue &gt;= beta &amp;&amp; ttMove &amp;&amp; !pos.capture_or_promotion(ttMove) &amp;&amp; !inCheck)</b></font>
            update_stats(pos, ss, ttMove, depth, nullptr, 0);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return ttValue;
    }
    if (inCheck)
    {
        ss-&gt;staticEval = eval = VALUE_NONE;
        goto moves_loop;
    }
    else if (tte)
    {
        if ((ss-&gt;staticEval = eval = tte-&gt;eval_value()) == VALUE_NONE)
            eval = ss-&gt;staticEval = evaluate(pos);
        if (ttValue != VALUE_NONE)
            if (tte-&gt;bound() &amp; (ttValue &gt; eval ? BOUND_LOWER : BOUND_UPPER))
                eval = ttValue;
    }
    else
    {
        eval = ss-&gt;staticEval = evaluate(pos);
        TT.store(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
    }
    if (   !pos.captured_piece_type()
        &amp;&amp;  ss-&gt;staticEval != VALUE_NONE
        &amp;&amp; (ss-1)-&gt;staticEval != VALUE_NONE
        &amp;&amp; (move = (ss-1)-&gt;currentMove) != MOVE_NULL
        &amp;&amp;  type_of(move) == NORMAL)
    {
        Square to = to_sq(move);
        Gains.update(pos.piece_on(to), to, -(ss-1)-&gt;staticEval - ss-&gt;staticEval);
    }
    if (   !PvNode
        &amp;&amp;  depth &lt; 4 * ONE_PLY
        &amp;&amp;  eval + razor_margin(depth) &lt;= alpha
        &amp;&amp;  ttMove == MOVE_NONE
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
        &amp;&amp; !pos.pawn_on_7th(pos.side_to_move()))
    {
        if (   depth &lt;= ONE_PLY
            &amp;&amp; eval + razor_margin(3 * ONE_PLY) &lt;= alpha)
            return qsearch&lt;NonPV, false&gt;(pos, ss, alpha, beta, DEPTH_ZERO);
        Value ralpha = alpha - razor_margin(depth);
        Value v = qsearch&lt;NonPV, false&gt;(pos, ss, ralpha, ralpha+1, DEPTH_ZERO);
        if (v &lt;= ralpha)
            return v;
    }
    if (   !PvNode
        &amp;&amp; !ss-&gt;skipNullMove
        &amp;&amp;  depth &lt; 7 * ONE_PLY
        &amp;&amp;  eval - futility_margin(depth) &gt;= beta
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
        &amp;&amp;  abs(eval) &lt; VALUE_KNOWN_WIN
        &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
        return eval - futility_margin(depth);
    if (   !PvNode
        &amp;&amp; !ss-&gt;skipNullMove
        &amp;&amp;  depth &gt;= 2 * ONE_PLY
        &amp;&amp;  eval &gt;= beta
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
        &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
    {
        ss-&gt;currentMove = MOVE_NULL;
        assert(eval - beta &gt;= 0);
        Depth R =  3 * ONE_PLY
                 + depth / 4
                 + int(eval - beta) / PawnValueMg * ONE_PLY;
        pos.do_null_move(st);
        (ss+1)-&gt;skipNullMove = true;
        nullValue = depth-R &lt; ONE_PLY ? -qsearch&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, DEPTH_ZERO)
                                      : - search&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, depth-R, !cutNode);
        (ss+1)-&gt;skipNullMove = false;
        pos.undo_null_move();
        if (nullValue &gt;= beta)
        {
            if (nullValue &gt;= VALUE_MATE_IN_MAX_PLY)
                nullValue = beta;
            if (depth &lt; 12 * ONE_PLY)
                return nullValue;
            ss-&gt;skipNullMove = true;
            Value v = depth-R &lt; ONE_PLY ? qsearch&lt;NonPV, false&gt;(pos, ss, beta-1, beta, DEPTH_ZERO)
                                        :  search&lt;NonPV, false&gt;(pos, ss, beta-1, beta, depth-R, false);
            ss-&gt;skipNullMove = false;
            if (v &gt;= beta)
                return nullValue;
        }
    }
    if (   !PvNode
        &amp;&amp;  depth &gt;= 5 * ONE_PLY
        &amp;&amp; !ss-&gt;skipNullMove
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY)
    {
        Value rbeta = std::min(beta + 200, VALUE_INFINITE);
        Depth rdepth = depth - 4 * ONE_PLY;
        assert(rdepth &gt;= ONE_PLY);
        assert((ss-1)-&gt;currentMove != MOVE_NONE);
        assert((ss-1)-&gt;currentMove != MOVE_NULL);
        MovePicker mp(pos, ttMove, History, pos.captured_piece_type());
        CheckInfo ci(pos);
        while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
            if (pos.legal(move, ci.pinned))
            {
                ss-&gt;currentMove = move;
                pos.do_move(move, st, ci, pos.gives_check(move, ci));
                value = -search&lt;NonPV, false&gt;(pos, ss+1, -rbeta, -rbeta+1, rdepth, !cutNode);
                pos.undo_move(move);
                if (value &gt;= rbeta)
                    return value;
            }
    }
    if (    depth &gt;= (PvNode ? 5 * ONE_PLY : 8 * ONE_PLY)
        &amp;&amp; !ttMove
        &amp;&amp; (PvNode || ss-&gt;staticEval + 256 &gt;= beta))
    {
        Depth d = depth - 2 * ONE_PLY - (PvNode ? DEPTH_ZERO : depth / 4);
        ss-&gt;skipNullMove = true;
        search&lt;PvNode ? PV : NonPV, false&gt;(pos, ss, alpha, beta, d, true);
        ss-&gt;skipNullMove = false;
        tte = TT.probe(posKey);
        ttMove = tte ? tte-&gt;move() : MOVE_NONE;
    }
moves_loop: 
    Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
    Move countermoves[] = { Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].first,
                            Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].second };
    Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
    Move followupmoves[] = { Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].first,
                             Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].second };
    MovePicker mp(pos, ttMove, depth, History, countermoves, followupmoves, ss);
    CheckInfo ci(pos);
    value = bestValue;     improving =   ss-&gt;staticEval &gt;= (ss-2)-&gt;staticEval
               || ss-&gt;staticEval == VALUE_NONE
               ||(ss-2)-&gt;staticEval == VALUE_NONE;
    singularExtensionNode =   !RootNode
                           &amp;&amp; !SpNode
                           &amp;&amp;  depth &gt;= 8 * ONE_PLY
                           &amp;&amp;  ttMove != MOVE_NONE
                           &amp;&amp; !excludedMove                            &amp;&amp; (tte-&gt;bound() &amp; BOUND_LOWER)
                           &amp;&amp;  tte-&gt;depth() &gt;= depth - 3 * ONE_PLY;
    while ((move = mp.next_move&lt;SpNode&gt;()) != MOVE_NONE)
    {
      assert(is_ok(move));
      if (move == excludedMove)
          continue;
      if (RootNode &amp;&amp; !std::count(RootMoves.begin() + PVIdx, RootMoves.end(), move))
          continue;
      if (SpNode)
      {
          if (!pos.legal(move, ci.pinned))
              continue;
          moveCount = ++splitPoint-&gt;moveCount;
          splitPoint-&gt;mutex.unlock();
      }
      else
          ++moveCount;
      if (RootNode)
      {
          Signals.firstRootMove = (moveCount == 1);
          if (thisThread == Threads.main() &amp;&amp; Time::now() - SearchTime &gt; 3000)
              sync_cout &lt;&lt; "info depth " &lt;&lt; depth / ONE_PLY
                        &lt;&lt; " currmove " &lt;&lt; move_to_uci(move, pos.is_chess960())
                        &lt;&lt; " currmovenumber " &lt;&lt; moveCount + PVIdx &lt;&lt; sync_endl;
      }
      ext = DEPTH_ZERO;
      captureOrPromotion = pos.capture_or_promotion(move);
      givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
                  ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
                  : pos.gives_check(move, ci);
      dangerous =   givesCheck
                 || type_of(move) != NORMAL
                 || pos.advanced_pawn_push(move);
      if (givesCheck &amp;&amp; pos.see_sign(move) &gt;= VALUE_ZERO)
          ext = ONE_PLY;
      if (    singularExtensionNode
          &amp;&amp;  move == ttMove
          &amp;&amp; !ext
          &amp;&amp;  pos.legal(move, ci.pinned)
          &amp;&amp;  abs(ttValue) &lt; VALUE_KNOWN_WIN)
      {
          assert(ttValue != VALUE_NONE);
          Value rBeta = ttValue - int(depth);
          ss-&gt;excludedMove = move;
          ss-&gt;skipNullMove = true;
          value = search&lt;NonPV, false&gt;(pos, ss, rBeta - 1, rBeta, depth / 2, cutNode);
          ss-&gt;skipNullMove = false;
          ss-&gt;excludedMove = MOVE_NONE;
          if (value &lt; rBeta)
              ext = ONE_PLY;
      }
      newDepth = depth - ONE_PLY + ext;
      if (   !PvNode
          &amp;&amp; !captureOrPromotion
          &amp;&amp; !inCheck
          &amp;&amp; !dangerous
          &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY)
      {
          if (   depth &lt; 16 * ONE_PLY
              &amp;&amp; moveCount &gt;= FutilityMoveCounts[improving][depth] )
          {
              if (SpNode)
                  splitPoint-&gt;mutex.lock();
              continue;
          }
          predictedDepth = newDepth - reduction&lt;PvNode&gt;(improving, depth, moveCount);
          if (predictedDepth &lt; 7 * ONE_PLY)
          {
              futilityValue = ss-&gt;staticEval + futility_margin(predictedDepth)
                            + 128 + Gains[pos.moved_piece(move)][to_sq(move)];
              if (futilityValue &lt;= alpha)
              {
                  bestValue = std::max(bestValue, futilityValue);
                  if (SpNode)
                  {
                      splitPoint-&gt;mutex.lock();
                      if (bestValue &gt; splitPoint-&gt;bestValue)
                          splitPoint-&gt;bestValue = bestValue;
                  }
                  continue;
              }
          }
          if (predictedDepth &lt; 4 * ONE_PLY &amp;&amp; pos.see_sign(move) &lt; VALUE_ZERO)
          {
              if (SpNode)
                  splitPoint-&gt;mutex.lock();
              continue;
          }
      }
      if (!RootNode &amp;&amp; !SpNode &amp;&amp; !pos.legal(move, ci.pinned))
      {
          moveCount--;
          continue;
      }
      pvMove = PvNode &amp;&amp; moveCount == 1;
      ss-&gt;currentMove = move;
      if (!SpNode &amp;&amp; !captureOrPromotion &amp;&amp; quietCount &lt; 64)
          quietsSearched[quietCount++] = move;
      pos.do_move(move, st, ci, givesCheck);
      if (    depth &gt;= 3 * ONE_PLY
          &amp;&amp; !pvMove
          &amp;&amp; !captureOrPromotion
          &amp;&amp;  move != ttMove
          &amp;&amp;  move != ss-&gt;killers[0]
          &amp;&amp;  move != ss-&gt;killers[1])
      {
          ss-&gt;reduction = reduction&lt;PvNode&gt;(improving, depth, moveCount);
          if (!PvNode &amp;&amp; cutNode)
              ss-&gt;reduction += ONE_PLY;
          else if (History[pos.piece_on(to_sq(move))][to_sq(move)] &lt; 0)
              ss-&gt;reduction += ONE_PLY / 2;
          if (move == countermoves[0] || move == countermoves[1])
              ss-&gt;reduction = std::max(DEPTH_ZERO, ss-&gt;reduction - ONE_PLY);
          Depth d = std::max(newDepth - ss-&gt;reduction, ONE_PLY);
          if (SpNode)
              alpha = splitPoint-&gt;alpha;
          value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d, true);
          if (value &gt; alpha &amp;&amp; ss-&gt;reduction &gt;= 4 * ONE_PLY)
          {
              Depth d2 = std::max(newDepth - 2 * ONE_PLY, ONE_PLY);
              value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d2, true);
          }
          doFullDepthSearch = (value &gt; alpha &amp;&amp; ss-&gt;reduction != DEPTH_ZERO);
          ss-&gt;reduction = DEPTH_ZERO;
      }
      else
          doFullDepthSearch = !pvMove;
      if (doFullDepthSearch)
      {
          if (SpNode)
              alpha = splitPoint-&gt;alpha;
          value = newDepth &lt; ONE_PLY ?
                          givesCheck ? -qsearch&lt;NonPV,  true&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
                                     : -qsearch&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
                                     : - search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, newDepth, !cutNode);
      }
      if (PvNode &amp;&amp; (pvMove || (value &gt; alpha &amp;&amp; (RootNode || value &lt; beta))))
          value = newDepth &lt; ONE_PLY ?
                          givesCheck ? -qsearch&lt;PV,  true&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
                                     : -qsearch&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
                                     : - search&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, newDepth, false);
      pos.undo_move(move);
      assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
      if (SpNode)
      {
          splitPoint-&gt;mutex.lock();
          bestValue = splitPoint-&gt;bestValue;
          alpha = splitPoint-&gt;alpha;
      }
      if (Signals.stop || thisThread-&gt;cutoff_occurred())
          return VALUE_ZERO;
      if (RootNode)
      {
          RootMove&amp; rm = *std::find(RootMoves.begin(), RootMoves.end(), move);
          if (pvMove || value &gt; alpha)
          {
              rm.score = value;
              rm.extract_pv_from_tt(pos);
              if (!pvMove)
                  ++BestMoveChanges;
          }
          else
              rm.score = -VALUE_INFINITE;
      }
      if (value &gt; bestValue)
      {
          bestValue = SpNode ? splitPoint-&gt;bestValue = value : value;
          if (value &gt; alpha)
          {
              bestMove = SpNode ? splitPoint-&gt;bestMove = move : move;
              if (PvNode &amp;&amp; value &lt; beta)                   alpha = SpNode ? splitPoint-&gt;alpha = value : value;
              else
              {
                  assert(value &gt;= beta); 
                  if (SpNode)
                      splitPoint-&gt;cutoff = true;
                  break;
              }
          }
      }
      if (   !SpNode
          &amp;&amp;  Threads.size() &gt;= 2
          &amp;&amp;  depth &gt;= Threads.minimumSplitDepth
          &amp;&amp;  (   !thisThread-&gt;activeSplitPoint
               || !thisThread-&gt;activeSplitPoint-&gt;allSlavesSearching)
          &amp;&amp;  thisThread-&gt;splitPointsSize &lt; MAX_SPLITPOINTS_PER_THREAD)
      {
          assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; beta);
          thisThread-&gt;split&lt;FakeSplit&gt;(pos, ss, alpha, beta, &amp;bestValue, &amp;bestMove,
                                       depth, moveCount, &amp;mp, NT, cutNode);
          if (Signals.stop || thisThread-&gt;cutoff_occurred())
              return VALUE_ZERO;
          if (bestValue &gt;= beta)
              break;
      }
    }
    if (SpNode)
        return bestValue;
    if (!moveCount)
        bestValue = excludedMove ? alpha
                   :     inCheck ? mated_in(ss-&gt;ply) : DrawValue[pos.side_to_move()];
    else if (bestValue &gt;= beta &amp;&amp; !pos.capture_or_promotion(bestMove) &amp;&amp; !inCheck)
        update_stats(pos, ss, bestMove, depth, quietsSearched, quietCount - 1);
    TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
             bestValue &gt;= beta  ? BOUND_LOWER :
             PvNode &amp;&amp; bestMove ? BOUND_EXACT : BOUND_UPPER,
             depth, bestMove, ss-&gt;staticEval);
    assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
    return bestValue;
  }
  template &lt;NodeType NT, bool InCheck&gt;
  Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth) {
    const bool PvNode = NT == PV;
    assert(NT == PV || NT == NonPV);
    assert(InCheck == !!pos.checkers());
    assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(depth &lt;= DEPTH_ZERO);
    StateInfo st;
    const TTEntry* tte;
    Key posKey;
    Move ttMove, move, bestMove;
    Value bestValue, value, ttValue, futilityValue, futilityBase, oldAlpha;
    bool givesCheck, evasionPrunable;
    Depth ttDepth;
    if (PvNode)
        oldAlpha = alpha;
    ss-&gt;currentMove = bestMove = MOVE_NONE;
    ss-&gt;ply = (ss-1)-&gt;ply + 1;
    if (pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
        return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !InCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
    ttDepth = InCheck || depth &gt;= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS
                                                  : DEPTH_QS_NO_CHECKS;
    posKey = pos.key();
    tte = TT.probe(posKey);
    ttMove = tte ? tte-&gt;move() : MOVE_NONE;
    ttValue = tte ? value_from_tt(tte-&gt;value(),ss-&gt;ply) : VALUE_NONE;
    if (   tte
        &amp;&amp; tte-&gt;depth() &gt;= ttDepth
        &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
            : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
                              : (tte-&gt;bound() &amp;  BOUND_UPPER)))
    {
        ss-&gt;currentMove = ttMove;         return ttValue;
    }
    if (InCheck)
    {
        ss-&gt;staticEval = VALUE_NONE;
        bestValue = futilityBase = -VALUE_INFINITE;
    }
    else
    {
        if (tte)
        {
            if ((ss-&gt;staticEval = bestValue = tte-&gt;eval_value()) == VALUE_NONE)
                ss-&gt;staticEval = bestValue = evaluate(pos);
            if (ttValue != VALUE_NONE)
                if (tte-&gt;bound() &amp; (ttValue &gt; bestValue ? BOUND_LOWER : BOUND_UPPER))
                    bestValue = ttValue;
        }
        else
            ss-&gt;staticEval = bestValue = evaluate(pos);
        if (bestValue &gt;= beta)
        {
            if (!tte)
                TT.store(pos.key(), value_to_tt(bestValue, ss-&gt;ply), BOUND_LOWER,
                         DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
            return bestValue;
        }
        if (PvNode &amp;&amp; bestValue &gt; alpha)
            alpha = bestValue;
        futilityBase = bestValue + 128;
    }
    MovePicker mp(pos, ttMove, depth, History, to_sq((ss-1)-&gt;currentMove));
    CheckInfo ci(pos);
    while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
    {
      assert(is_ok(move));
      givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
                  ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
                  : pos.gives_check(move, ci);
      if (   !PvNode
          &amp;&amp; !InCheck
          &amp;&amp; !givesCheck
          &amp;&amp;  move != ttMove
          &amp;&amp;  futilityBase &gt; -VALUE_KNOWN_WIN
          &amp;&amp; !pos.advanced_pawn_push(move))
      {
          assert(type_of(move) != ENPASSANT); 
          futilityValue = futilityBase + PieceValue[EG][pos.piece_on(to_sq(move))];
          if (futilityValue &lt; beta)
          {
              bestValue = std::max(bestValue, futilityValue);
              continue;
          }
          if (futilityBase &lt; beta &amp;&amp; pos.see(move) &lt;= VALUE_ZERO)
          {
              bestValue = std::max(bestValue, futilityBase);
              continue;
          }
      }
      evasionPrunable =    InCheck
                       &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY
                       &amp;&amp; !pos.capture(move)
                       &amp;&amp; !pos.can_castle(pos.side_to_move());
      if (   !PvNode
          &amp;&amp; (!InCheck || evasionPrunable)
          &amp;&amp;  move != ttMove
          &amp;&amp;  type_of(move) != PROMOTION
          &amp;&amp;  pos.see_sign(move) &lt; VALUE_ZERO)
          continue;
      if (!pos.legal(move, ci.pinned))
          continue;
      ss-&gt;currentMove = move;
      pos.do_move(move, st, ci, givesCheck);
      value = givesCheck ? -qsearch&lt;NT,  true&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY)
                         : -qsearch&lt;NT, false&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY);
      pos.undo_move(move);
      assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
      if (value &gt; bestValue)
      {
          bestValue = value;
          if (value &gt; alpha)
          {
              if (PvNode &amp;&amp; value &lt; beta)               {
                  alpha = value;
                  bestMove = move;
              }
              else               {
                  TT.store(posKey, value_to_tt(value, ss-&gt;ply), BOUND_LOWER,
                           ttDepth, move, ss-&gt;staticEval);
                  return value;
              }
          }
       }
    }
    if (InCheck &amp;&amp; bestValue == -VALUE_INFINITE)
        return mated_in(ss-&gt;ply); 
    TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
             PvNode &amp;&amp; bestValue &gt; oldAlpha ? BOUND_EXACT : BOUND_UPPER,
             ttDepth, bestMove, ss-&gt;staticEval);
    assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
    return bestValue;
  }
  Value value_to_tt(Value v, int ply) {
    assert(v != VALUE_NONE);
    return  v &gt;= VALUE_MATE_IN_MAX_PLY  ? v + ply
          : v &lt;= VALUE_MATED_IN_MAX_PLY ? v - ply : v;
  }
  Value value_from_tt(Value v, int ply) {
    return  v == VALUE_NONE             ? VALUE_NONE
          : v &gt;= VALUE_MATE_IN_MAX_PLY  ? v - ply
          : v &lt;= VALUE_MATED_IN_MAX_PLY ? v + ply : v;
  }
  void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt) {
    if (ss-&gt;killers[0] != move)
    {
        ss-&gt;killers[1] = ss-&gt;killers[0];
        ss-&gt;killers[0] = move;
    }
    Value bonus = Value(int(depth) * int(depth));
    History.update(pos.moved_piece(move), to_sq(move), bonus);
    for (int i = 0; i &lt; quietsCnt; ++i)
    {
        Move m = quiets[i];
        History.update(pos.moved_piece(m), to_sq(m), -bonus);
    }
    if (is_ok((ss-1)-&gt;currentMove))
    {
        Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
        Countermoves.update(pos.piece_on(prevMoveSq), prevMoveSq, move);
    }
    if (is_ok((ss-2)-&gt;currentMove) &amp;&amp; (ss-1)-&gt;currentMove == (ss-1)-&gt;ttMove)
    {
        Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
        Followupmoves.update(pos.piece_on(prevOwnMoveSq), prevOwnMoveSq, move);
    }
  }
  Move Skill::pick_move() {
    static RKISS rk;
    for (int i = Time::now() % 50; i &gt; 0; --i)
        rk.rand&lt;unsigned&gt;();
    int variance = std::min(RootMoves[0].score - RootMoves[MultiPV - 1].score, PawnValueMg);
    int weakness = 120 - 2 * level;
    int max_s = -VALUE_INFINITE;
    best = MOVE_NONE;
    for (size_t i = 0; i &lt; MultiPV; ++i)
    {
        int s = RootMoves[i].score;
        if (i &gt; 0 &amp;&amp; RootMoves[i-1].score &gt; s + 2 * PawnValueMg)
            break;
        s += (  weakness * int(RootMoves[0].score - s)
              + variance * (rk.rand&lt;unsigned&gt;() % weakness)) / 128;
        if (s &gt; max_s)
        {
            max_s = s;
            best = RootMoves[i].pv[0];
        }
    }
    return best;
  }
  string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta) {
    std::stringstream ss;
    Time::point elapsed = Time::now() - SearchTime + 1;
    size_t uciPVSize = std::min((size_t)Options["MultiPV"], RootMoves.size());
<a name="3"></a>    int selDepth = 0;
    for (Thread* th : Threads)</b></font>
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        if (th-&gt;maxPly &gt; selDepth)
            selDepth = th-&gt;maxPly;
    for (size_t i = 0; i &lt; uciPVSize; ++i)
    {
        bool updated = (i &lt;= PVIdx);
        if (depth == 1 &amp;&amp; !updated)
            continue;
        int d   = updated ? depth : depth - 1;
        Value v = updated ? RootMoves[i].score : RootMoves[i].prevScore;
        if (ss.rdbuf()-&gt;in_avail())             ss &lt;&lt; "\n";
        ss &lt;&lt; "info depth " &lt;&lt; d
           &lt;&lt; " seldepth "  &lt;&lt; selDepth
           &lt;&lt; " score "     &lt;&lt; (i == PVIdx ? score_to_uci(v, alpha, beta) : score_to_uci(v))
           &lt;&lt; " nodes "     &lt;&lt; pos.nodes_searched()
           &lt;&lt; " nps "       &lt;&lt; pos.nodes_searched() * 1000 / elapsed
           &lt;&lt; " time "      &lt;&lt; elapsed
           &lt;&lt; " multipv "   &lt;&lt; i + 1
           &lt;&lt; " pv";
        for (size_t j = 0; RootMoves[i].pv[j] != MOVE_NONE; ++j)
            ss &lt;&lt; " " &lt;&lt; move_to_uci(RootMoves[i].pv[j], pos.is_chess960());
    }
    return ss.str();
  }
} 
void RootMove::extract_pv_from_tt(Position&amp; pos) {
  StateInfo state[MAX_PLY_PLUS_6], *st = state;
  const TTEntry* tte;
  int ply = 1;      Move m = pv[0];   Value expectedScore = score;
  pv.clear();
  do {
      pv.push_back(m);
      assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[ply - 1]));
      pos.do_move(pv[ply++ - 1], *st++);
      tte = TT.probe(pos.key());
      expectedScore = -expectedScore;
  } while (   tte
           &amp;&amp; expectedScore == value_from_tt(tte-&gt;value(), ply)
           &amp;&amp; pos.pseudo_legal(m = tte-&gt;move())            &amp;&amp; pos.legal(m, pos.pinned_pieces(pos.side_to_move()))
           &amp;&amp; ply &lt; MAX_PLY
           &amp;&amp; (!pos.is_draw() || ply &lt;= 2));
  pv.push_back(MOVE_NONE); 
  while (--ply) pos.undo_move(pv[ply - 1]);
}
void RootMove::insert_pv_in_tt(Position&amp; pos) {
  StateInfo state[MAX_PLY_PLUS_6], *st = state;
  const TTEntry* tte;
  int idx = 0; 
  do {
      tte = TT.probe(pos.key());
      if (!tte || tte-&gt;move() != pv[idx])           TT.store(pos.key(), VALUE_NONE, BOUND_NONE, DEPTH_NONE, pv[idx], VALUE_NONE);
      assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[idx]));
      pos.do_move(pv[idx++], *st++);
  } while (pv[idx] != MOVE_NONE);
  while (idx) pos.undo_move(pv[--idx]);
}
void Thread::idle_loop() {
  SplitPoint* this_sp = splitPointsSize ? activeSplitPoint : nullptr;</b></font>
  assert(!this_sp || (this_sp-&gt;masterThread == this &amp;&amp; searching));
  while (true)
  {
      while (!searching || exit)
      {
          if (exit)
          {
              assert(!this_sp);
              return;
          }
          std::unique_lock&lt;std::mutex&gt; lk(mutex);
          if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
              break;
          if (!searching &amp;&amp; !exit)
              sleepCondition.wait(lk);
      }
      if (searching)
      {
          assert(!exit);
          Threads.mutex.lock();
          assert(searching);
          assert(activeSplitPoint);
          SplitPoint* sp = activeSplitPoint;
          Threads.mutex.unlock();
          Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;           Position pos(*sp-&gt;pos, this);
          std::memcpy(ss-2, sp-&gt;ss-2, 5 * sizeof(Stack));
          ss-&gt;splitPoint = sp;
          sp-&gt;mutex.lock();
          assert(activePosition == nullptr);
          activePosition = &amp;pos;
          if (sp-&gt;nodeType == NonPV)
              search&lt;NonPV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
          else if (sp-&gt;nodeType == PV)
              search&lt;PV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
          else if (sp-&gt;nodeType == Root)
              search&lt;Root, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
          else
              assert(false);
          assert(searching);
<a name="4"></a>          searching = false;
          activePosition = nullptr;
          sp-&gt;slavesMask.reset(idx);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          sp-&gt;allSlavesSearching = false;
          sp-&gt;nodes += pos.nodes_searched();
          if (    this != sp-&gt;masterThread
              &amp;&amp;  sp-&gt;slavesMask.none())
          {
              assert(!sp-&gt;masterThread-&gt;searching);
              sp-&gt;masterThread-&gt;notify_one();
          }
          sp-&gt;mutex.unlock();
          if (Threads.size() &gt; 2)
              for (size_t i = 0; i &lt; Threads.size(); ++i)
              {
                  int size = Threads[i]-&gt;splitPointsSize;                   sp = size ? &amp;Threads[i]-&gt;splitPoints[size - 1] : NULL;
                  if (   sp
                      &amp;&amp; sp-&gt;allSlavesSearching
                      &amp;&amp; available_to(Threads[i]))
                  {
                      Threads.mutex.lock();
                      sp-&gt;mutex.lock();
                      if (   sp-&gt;allSlavesSearching
                          &amp;&amp; available_to(Threads[i]))
                      {
                           sp-&gt;slavesMask.set(idx);
                           activeSplitPoint = sp;
                           searching = true;
                      }
                      sp-&gt;mutex.unlock();
                      Threads.mutex.unlock();
                      break;                   }
              }
      }
      if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
      {
          this_sp-&gt;mutex.lock();
          bool finished = this_sp-&gt;slavesMask.none();           this_sp-&gt;mutex.unlock();
          if (finished)
              return;
      }
  }
}
void check_time() {
  static Time::point lastInfoTime = Time::now();
  int64_t nodes = 0; 
  if (Time::now() - lastInfoTime &gt;= 1000)
  {
      lastInfoTime = Time::now();
      dbg_print();
  }
  if (Limits.ponder)
      return;
  if (Limits.nodes)
  {
      Threads.mutex.lock();
      nodes = RootPos.nodes_searched();
<a name="8"></a>            for (Thread* th : Threads)</b></font>
<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          for (int i = 0; i &lt; th-&gt;splitPointsSize; ++i)
          {
              SplitPoint&amp; sp = th-&gt;splitPoints[i];
              sp.mutex.lock();
              nodes += sp.nodes;
              for (size_t idx = 0; idx &lt; Threads.size(); ++idx)
                  if (sp.slavesMask.test(idx) &amp;&amp; Threads[idx]-&gt;activePosition)
                      nodes += Threads[idx]-&gt;activePosition-&gt;nodes_searched();
              sp.mutex.unlock();
          }
      Threads.mutex.unlock();
  }
  Time::point elapsed = Time::now() - SearchTime;
  bool stillAtFirstMove =    Signals.firstRootMove
                         &amp;&amp; !Signals.failedLowAtRoot
                         &amp;&amp;  elapsed &gt; TimeMgr.available_time() * 75 / 100;
  bool noMoreTime =   elapsed &gt; TimeMgr.maximum_time() - 2 * TimerThread::Resolution
                   || stillAtFirstMove;
  if (   (Limits.use_time_management() &amp;&amp; noMoreTime)
      || (Limits.movetime &amp;&amp; elapsed &gt;= Limits.movetime)
      || (Limits.nodes &amp;&amp; nodes &gt;= Limits.nodes))
      Signals.stop = true;
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>search.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cfloat&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include "book.h"
#include "evaluate.h"
#include "movegen.h"
#include "movepick.h"
#include "notation.h"
#include "search.h"
#include "timeman.h"
#include "thread.h"
<a name="1"></a>#include "tt.h"
#include "ucioption.h"
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>namespace Search {
  volatile SignalsType Signals;
  LimitsType Limits;
  std::vector&lt;RootMove&gt; RootMoves;
  Position RootPos;
  Color RootColor;
  Time::point SearchTime;
  StateStackPtr SetupStates;
}
using std::string;
using Eval::evaluate;
using namespace Search;
namespace {
  const bool FakeSplit = false;
  enum NodeType { Root, PV, NonPV };
  inline Value razor_margin(Depth d) { return Value(512 + 16 * d); }
  int FutilityMoveCounts[2][32]; 
  inline Value futility_margin(Depth d) {
    return Value(100 * d);
  }
  int8_t Reductions[2][2][64][64]; 
  template &lt;bool PvNode&gt; inline Depth reduction(bool i, Depth d, int mn) {
    return (Depth) Reductions[PvNode][i][std::min(int(d) / ONE_PLY, 63)][std::min(mn, 63)];
  }
  size_t MultiPV, PVIdx;
  TimeManager TimeMgr;
  double BestMoveChanges;
  Value DrawValue[COLOR_NB];
  HistoryStats History;
  GainsStats Gains;
  MovesStats Countermoves, Followupmoves;
  template &lt;NodeType NT, bool SpNode&gt;
  Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode);
  template &lt;NodeType NT, bool InCheck&gt;
  Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth);
  void id_loop(Position&amp; pos);
  Value value_to_tt(Value v, int ply);
  Value value_from_tt(Value v, int ply);
  void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt);
  string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta);
  struct Skill {
    Skill(int l) : level(l), best(MOVE_NONE) {}
   ~Skill() {
      if (enabled())           std::swap(RootMoves[0], *std::find(RootMoves.begin(),
                    RootMoves.end(), best ? best : pick_move()));
    }
    bool enabled() const { return level &lt; 20; }
    bool time_to_pick(int depth) const { return depth == 1 + level; }
    Move pick_move();
    int level;
    Move best;
  };
} 
void Search::init() {
  int d;    int hd;   int mc; 
  for (hd = 1; hd &lt; 64; ++hd) for (mc = 1; mc &lt; 64; ++mc)
  {
      double    pvRed = 0.00 + log(double(hd)) * log(double(mc)) / 3.00;
      double nonPVRed = 0.33 + log(double(hd)) * log(double(mc)) / 2.25;
      Reductions[1][1][hd][mc] = int8_t(   pvRed &gt;= 1.0 ?    pvRed * int(ONE_PLY) : 0);
      Reductions[0][1][hd][mc] = int8_t(nonPVRed &gt;= 1.0 ? nonPVRed * int(ONE_PLY) : 0);
      Reductions[1][0][hd][mc] = Reductions[1][1][hd][mc];
      Reductions[0][0][hd][mc] = Reductions[0][1][hd][mc];
      if (Reductions[0][0][hd][mc] &gt; 2 * ONE_PLY)
          Reductions[0][0][hd][mc] += ONE_PLY;
      else if (Reductions[0][0][hd][mc] &gt; 1 * ONE_PLY)
          Reductions[0][0][hd][mc] += ONE_PLY / 2;
  }
  for (d = 0; d &lt; 32; ++d)
  {
      FutilityMoveCounts[0][d] = int(2.4 + 0.222 * pow(d + 0.00, 1.8));
      FutilityMoveCounts[1][d] = int(3.0 + 0.300 * pow(d + 0.98, 1.8));
  }
}
static uint64_t perft(Position&amp; pos, Depth depth) {
  StateInfo st;
  uint64_t cnt = 0;
  CheckInfo ci(pos);
<a name="6"></a>  const bool leaf = depth == 2 * ONE_PLY;
  for (MoveList&lt;LEGAL&gt; it(pos); *it; ++it)</b></font>
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
      pos.do_move(*it, st, ci, pos.gives_check(*it, ci));
      cnt += leaf ? MoveList&lt;LEGAL&gt;(pos).size() : ::perft(pos, depth - ONE_PLY);
      pos.undo_move(*it);
  }
  return cnt;
}
uint64_t Search::perft(Position&amp; pos, Depth depth) {
  return depth &gt; ONE_PLY ? ::perft(pos, depth) : MoveList&lt;LEGAL&gt;(pos).size();
}
void Search::think() {
  static PolyglotBook book; 
  RootColor = RootPos.side_to_move();
  TimeMgr.init(Limits, RootPos.game_ply(), RootColor);
  int cf = Options["Contempt Factor"] * PawnValueEg / 100;   DrawValue[ RootColor] = VALUE_DRAW - Value(cf);
  DrawValue[~RootColor] = VALUE_DRAW + Value(cf);
  if (RootMoves.empty())
  {
      RootMoves.push_back(MOVE_NONE);
      sync_cout &lt;&lt; "info depth 0 score "
                &lt;&lt; score_to_uci(RootPos.checkers() ? -VALUE_MATE : VALUE_DRAW)
                &lt;&lt; sync_endl;
      goto finalize;
  }
  if (Options["OwnBook"] &amp;&amp; !Limits.infinite &amp;&amp; !Limits.mate)
  {
      Move bookMove = book.probe(RootPos, Options["Book File"], Options["Best Book Move"]);
      if (bookMove &amp;&amp; std::count(RootMoves.begin(), RootMoves.end(), bookMove))
      {
          std::swap(RootMoves[0], *std::find(RootMoves.begin(), RootMoves.end(), bookMove));
          goto finalize;
      }
  }
  if (Options["Write Search Log"])
  {
      Log log(Options["Search Log Filename"]);
      log &lt;&lt; "\nSearching: "  &lt;&lt; RootPos.fen()
          &lt;&lt; "\ninfinite: "   &lt;&lt; Limits.infinite
          &lt;&lt; " ponder: "      &lt;&lt; Limits.ponder
          &lt;&lt; " time: "        &lt;&lt; Limits.time[RootColor]
          &lt;&lt; " increment: "   &lt;&lt; Limits.inc[RootColor]
          &lt;&lt; " moves to go: " &lt;&lt; Limits.movestogo
          &lt;&lt; "\n" &lt;&lt; std::endl;
  }
  for (size_t i = 0; i &lt; Threads.size(); ++i)
      Threads[i]-&gt;maxPly = 0;</b></font>
  Threads.timer-&gt;run = true;
  Threads.timer-&gt;notify_one(); 
  id_loop(RootPos); <a name="7"></a>
  Threads.timer-&gt;run = false; 
<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if (Options["Write Search Log"])
  {
      Time::point elapsed = Time::now() - SearchTime + 1;
      Log log(Options["Search Log Filename"]);
      log &lt;&lt; "Nodes: "          &lt;&lt; RootPos.nodes_searched()
          &lt;&lt; "\nNodes/second: " &lt;&lt; RootPos.nodes_searched() * 1000 / elapsed
          &lt;&lt; "\nBest move: "    &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[0]);
      StateInfo st;
      RootPos.do_move(RootMoves[0].pv[0], st);
      log &lt;&lt; "\nPonder move: " &lt;&lt; move_to_san(RootPos, RootMoves[0].pv[1]) &lt;&lt; std::endl;
      RootPos.undo_move(RootMoves[0].pv[0]);
  }
finalize:
  sync_cout &lt;&lt; "info nodes " &lt;&lt; RootPos.nodes_searched()
            &lt;&lt; " time " &lt;&lt; Time::now() - SearchTime + 1 &lt;&lt; sync_endl;
  if (!Signals.stop &amp;&amp; (Limits.ponder || Limits.infinite))
  {
      Signals.stopOnPonderhit = true;
      RootPos.this_thread()-&gt;wait_for(Signals.stop);
  }
  sync_cout &lt;&lt; "bestmove " &lt;&lt; move_to_uci(RootMoves[0].pv[0], RootPos.is_chess960())
            &lt;&lt; " ponder "  &lt;&lt; move_to_uci(RootMoves[0].pv[1], RootPos.is_chess960())
            &lt;&lt; sync_endl;
}
namespace {
  void id_loop(Position&amp; pos) {
    Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;     int depth;
    Value bestValue, alpha, beta, delta;
    std::memset(ss-2, 0, 5 * sizeof(Stack));
    (ss-1)-&gt;currentMove = MOVE_NULL; 
    depth = 0;
    BestMoveChanges = 0;
    bestValue = delta = alpha = -VALUE_INFINITE;
    beta = VALUE_INFINITE;
    TT.new_search();
    History.clear();
    Gains.clear();
    Countermoves.clear();
    Followupmoves.clear();
    MultiPV = Options["MultiPV"];
    Skill skill(Options["Skill Level"]);
    if (skill.enabled() &amp;&amp; MultiPV &lt; 4)
        MultiPV = 4;
    MultiPV = std::min(MultiPV, RootMoves.size());
    while (++depth &lt;= MAX_PLY &amp;&amp; !Signals.stop &amp;&amp; (!Limits.depth || depth &lt;= Limits.depth))
    {
        BestMoveChanges *= 0.5;
<a name="2"></a>                for (size_t i = 0; i &lt; RootMoves.size(); ++i)</b></font>
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            RootMoves[i].prevScore = RootMoves[i].score;
        for (PVIdx = 0; PVIdx &lt; MultiPV &amp;&amp; !Signals.stop; ++PVIdx)
        {
            if (depth &gt;= 5)
            {
                delta = Value(16);
                alpha = std::max(RootMoves[PVIdx].prevScore - delta,-VALUE_INFINITE);
                beta  = std::min(RootMoves[PVIdx].prevScore + delta, VALUE_INFINITE);
            }
            while (true)
            {
                bestValue = search&lt;Root, false&gt;(pos, ss, alpha, beta, depth * ONE_PLY, false);
                std::stable_sort(RootMoves.begin() + PVIdx, RootMoves.end());
                for (size_t i = 0; i &lt;= PVIdx; ++i)
                    RootMoves[i].insert_pv_in_tt(pos);
                if (Signals.stop)
                    break;
                if (  (bestValue &lt;= alpha || bestValue &gt;= beta)
                    &amp;&amp; Time::now() - SearchTime &gt; 3000)
                    sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
                if (bestValue &lt;= alpha)
                {
                    alpha = std::max(bestValue - delta, -VALUE_INFINITE);
                    Signals.failedLowAtRoot = true;
                    Signals.stopOnPonderhit = false;
                }
                else if (bestValue &gt;= beta)
                    beta = std::min(bestValue + delta, VALUE_INFINITE);
                else
                    break;
                delta += delta / 2;
                assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; beta &lt;= VALUE_INFINITE);
            }
            std::stable_sort(RootMoves.begin(), RootMoves.begin() + PVIdx + 1);
            if (PVIdx + 1 == MultiPV || Time::now() - SearchTime &gt; 3000)
                sync_cout &lt;&lt; uci_pv(pos, depth, alpha, beta) &lt;&lt; sync_endl;
        }
        if (skill.enabled() &amp;&amp; skill.time_to_pick(depth))
            skill.pick_move();
        if (Options["Write Search Log"])
        {
            RootMove&amp; rm = RootMoves[0];
            if (skill.best != MOVE_NONE)
                rm = *std::find(RootMoves.begin(), RootMoves.end(), skill.best);
            Log log(Options["Search Log Filename"]);
            log &lt;&lt; pretty_pv(pos, depth, rm.score, Time::now() - SearchTime, &amp;rm.pv[0])
                &lt;&lt; std::endl;
        }
        if (   Limits.mate
            &amp;&amp; bestValue &gt;= VALUE_MATE_IN_MAX_PLY
            &amp;&amp; VALUE_MATE - bestValue &lt;= 2 * Limits.mate)
            Signals.stop = true;
        if (Limits.use_time_management() &amp;&amp; !Signals.stop &amp;&amp; !Signals.stopOnPonderhit)
        {
            if (depth &gt; 4 &amp;&amp; depth &lt; 50 &amp;&amp;  MultiPV == 1)
                TimeMgr.pv_instability(BestMoveChanges);
            if (   RootMoves.size() == 1
                || Time::now() - SearchTime &gt; TimeMgr.available_time())
            {
                if (Limits.ponder)
                    Signals.stopOnPonderhit = true;
                else
                    Signals.stop = true;
            }
        }
    }
  }
  template &lt;NodeType NT, bool SpNode&gt;
  Value search(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {
    const bool RootNode = NT == Root;
    const bool PvNode   = NT == PV || NT == Root;
    assert(-VALUE_INFINITE &lt;= alpha &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(depth &gt; DEPTH_ZERO);
    Move quietsSearched[64];
    StateInfo st;
    const TTEntry *tte;
    SplitPoint* splitPoint;
    Key posKey;
    Move ttMove, move, excludedMove, bestMove;
    Depth ext, newDepth, predictedDepth;
    Value bestValue, value, ttValue, eval, nullValue, futilityValue;
    bool inCheck, givesCheck, pvMove, singularExtensionNode, improving;
    bool captureOrPromotion, dangerous, doFullDepthSearch;
    int moveCount, quietCount;
    Thread* thisThread = pos.this_thread();
    inCheck = pos.checkers();
    if (SpNode)
    {
        splitPoint = ss-&gt;splitPoint;
<a name="5"></a>        bestMove   = splitPoint-&gt;bestMove;
        bestValue  = splitPoint-&gt;bestValue;
        tte = NULL;</b></font>
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        ttMove = excludedMove = MOVE_NONE;
        ttValue = VALUE_NONE;
        assert(splitPoint-&gt;bestValue &gt; -VALUE_INFINITE &amp;&amp; splitPoint-&gt;moveCount &gt; 0);
        goto moves_loop;
    }
    moveCount = quietCount = 0;
    bestValue = -VALUE_INFINITE;
    ss-&gt;currentMove = ss-&gt;ttMove = (ss+1)-&gt;excludedMove = bestMove = MOVE_NONE;
    ss-&gt;ply = (ss-1)-&gt;ply + 1;
    (ss+1)-&gt;skipNullMove = false; (ss+1)-&gt;reduction = DEPTH_ZERO;
    (ss+2)-&gt;killers[0] = (ss+2)-&gt;killers[1] = MOVE_NONE;
    if (PvNode &amp;&amp; thisThread-&gt;maxPly &lt; ss-&gt;ply)
        thisThread-&gt;maxPly = ss-&gt;ply;
    if (!RootNode)
    {
        if (Signals.stop || pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
            return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !inCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
        alpha = std::max(mated_in(ss-&gt;ply), alpha);
        beta = std::min(mate_in(ss-&gt;ply+1), beta);
        if (alpha &gt;= beta)
            return alpha;
    }
    excludedMove = ss-&gt;excludedMove;
    posKey = excludedMove ? pos.exclusion_key() : pos.key();
    tte = TT.probe(posKey);
    ss-&gt;ttMove = ttMove = RootNode ? RootMoves[PVIdx].pv[0] : tte ? tte-&gt;move() : MOVE_NONE;
    ttValue = tte ? value_from_tt(tte-&gt;value(), ss-&gt;ply) : VALUE_NONE;
    if (   !RootNode
        &amp;&amp; tte
        &amp;&amp; tte-&gt;depth() &gt;= depth
        &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
            : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
                              : (tte-&gt;bound() &amp;  BOUND_UPPER)))
    {
        ss-&gt;currentMove = ttMove; 
<a name="0"></a>        if (ttValue &gt;= beta &amp;&amp; ttMove &amp;&amp; !pos.capture_or_promotion(ttMove) &amp;&amp; !inCheck)</b></font>
            update_stats(pos, ss, ttMove, depth, NULL, 0);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        return ttValue;
    }
    if (inCheck)
    {
        ss-&gt;staticEval = eval = VALUE_NONE;
        goto moves_loop;
    }
    else if (tte)
    {
        if ((ss-&gt;staticEval = eval = tte-&gt;eval_value()) == VALUE_NONE)
            eval = ss-&gt;staticEval = evaluate(pos);
        if (ttValue != VALUE_NONE)
            if (tte-&gt;bound() &amp; (ttValue &gt; eval ? BOUND_LOWER : BOUND_UPPER))
                eval = ttValue;
    }
    else
    {
        eval = ss-&gt;staticEval = evaluate(pos);
        TT.store(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
    }
    if (   !pos.captured_piece_type()
        &amp;&amp;  ss-&gt;staticEval != VALUE_NONE
        &amp;&amp; (ss-1)-&gt;staticEval != VALUE_NONE
        &amp;&amp; (move = (ss-1)-&gt;currentMove) != MOVE_NULL
        &amp;&amp;  type_of(move) == NORMAL)
    {
        Square to = to_sq(move);
        Gains.update(pos.piece_on(to), to, -(ss-1)-&gt;staticEval - ss-&gt;staticEval);
    }
    if (   !PvNode
        &amp;&amp;  depth &lt; 4 * ONE_PLY
        &amp;&amp;  eval + razor_margin(depth) &lt;= alpha
        &amp;&amp;  ttMove == MOVE_NONE
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
        &amp;&amp; !pos.pawn_on_7th(pos.side_to_move()))
    {
        if (   depth &lt;= ONE_PLY
            &amp;&amp; eval + razor_margin(3 * ONE_PLY) &lt;= alpha)
            return qsearch&lt;NonPV, false&gt;(pos, ss, alpha, beta, DEPTH_ZERO);
        Value ralpha = alpha - razor_margin(depth);
        Value v = qsearch&lt;NonPV, false&gt;(pos, ss, ralpha, ralpha+1, DEPTH_ZERO);
        if (v &lt;= ralpha)
            return v;
    }
    if (   !PvNode
        &amp;&amp; !ss-&gt;skipNullMove
        &amp;&amp;  depth &lt; 7 * ONE_PLY
        &amp;&amp;  eval - futility_margin(depth) &gt;= beta
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
        &amp;&amp;  abs(eval) &lt; VALUE_KNOWN_WIN
        &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
        return eval - futility_margin(depth);
    if (   !PvNode
        &amp;&amp; !ss-&gt;skipNullMove
        &amp;&amp;  depth &gt;= 2 * ONE_PLY
        &amp;&amp;  eval &gt;= beta
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY
        &amp;&amp;  pos.non_pawn_material(pos.side_to_move()))
    {
        ss-&gt;currentMove = MOVE_NULL;
        assert(eval - beta &gt;= 0);
        Depth R =  3 * ONE_PLY
                 + depth / 4
                 + int(eval - beta) / PawnValueMg * ONE_PLY;
        pos.do_null_move(st);
        (ss+1)-&gt;skipNullMove = true;
        nullValue = depth-R &lt; ONE_PLY ? -qsearch&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, DEPTH_ZERO)
                                      : - search&lt;NonPV, false&gt;(pos, ss+1, -beta, -beta+1, depth-R, !cutNode);
        (ss+1)-&gt;skipNullMove = false;
        pos.undo_null_move();
        if (nullValue &gt;= beta)
        {
            if (nullValue &gt;= VALUE_MATE_IN_MAX_PLY)
                nullValue = beta;
            if (depth &lt; 12 * ONE_PLY)
                return nullValue;
            ss-&gt;skipNullMove = true;
            Value v = depth-R &lt; ONE_PLY ? qsearch&lt;NonPV, false&gt;(pos, ss, beta-1, beta, DEPTH_ZERO)
                                        :  search&lt;NonPV, false&gt;(pos, ss, beta-1, beta, depth-R, false);
            ss-&gt;skipNullMove = false;
            if (v &gt;= beta)
                return nullValue;
        }
    }
    if (   !PvNode
        &amp;&amp;  depth &gt;= 5 * ONE_PLY
        &amp;&amp; !ss-&gt;skipNullMove
        &amp;&amp;  abs(beta) &lt; VALUE_MATE_IN_MAX_PLY)
    {
        Value rbeta = std::min(beta + 200, VALUE_INFINITE);
        Depth rdepth = depth - 4 * ONE_PLY;
        assert(rdepth &gt;= ONE_PLY);
        assert((ss-1)-&gt;currentMove != MOVE_NONE);
        assert((ss-1)-&gt;currentMove != MOVE_NULL);
        MovePicker mp(pos, ttMove, History, pos.captured_piece_type());
        CheckInfo ci(pos);
        while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
            if (pos.legal(move, ci.pinned))
            {
                ss-&gt;currentMove = move;
                pos.do_move(move, st, ci, pos.gives_check(move, ci));
                value = -search&lt;NonPV, false&gt;(pos, ss+1, -rbeta, -rbeta+1, rdepth, !cutNode);
                pos.undo_move(move);
                if (value &gt;= rbeta)
                    return value;
            }
    }
    if (    depth &gt;= (PvNode ? 5 * ONE_PLY : 8 * ONE_PLY)
        &amp;&amp; !ttMove
        &amp;&amp; (PvNode || ss-&gt;staticEval + 256 &gt;= beta))
    {
        Depth d = depth - 2 * ONE_PLY - (PvNode ? DEPTH_ZERO : depth / 4);
        ss-&gt;skipNullMove = true;
        search&lt;PvNode ? PV : NonPV, false&gt;(pos, ss, alpha, beta, d, true);
        ss-&gt;skipNullMove = false;
        tte = TT.probe(posKey);
        ttMove = tte ? tte-&gt;move() : MOVE_NONE;
    }
moves_loop: 
    Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
    Move countermoves[] = { Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].first,
                            Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].second };
    Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
    Move followupmoves[] = { Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].first,
                             Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].second };
    MovePicker mp(pos, ttMove, depth, History, countermoves, followupmoves, ss);
    CheckInfo ci(pos);
    value = bestValue;     improving =   ss-&gt;staticEval &gt;= (ss-2)-&gt;staticEval
               || ss-&gt;staticEval == VALUE_NONE
               ||(ss-2)-&gt;staticEval == VALUE_NONE;
    singularExtensionNode =   !RootNode
                           &amp;&amp; !SpNode
                           &amp;&amp;  depth &gt;= 8 * ONE_PLY
                           &amp;&amp;  ttMove != MOVE_NONE
                           &amp;&amp; !excludedMove                            &amp;&amp; (tte-&gt;bound() &amp; BOUND_LOWER)
                           &amp;&amp;  tte-&gt;depth() &gt;= depth - 3 * ONE_PLY;
    while ((move = mp.next_move&lt;SpNode&gt;()) != MOVE_NONE)
    {
      assert(is_ok(move));
      if (move == excludedMove)
          continue;
      if (RootNode &amp;&amp; !std::count(RootMoves.begin() + PVIdx, RootMoves.end(), move))
          continue;
      if (SpNode)
      {
          if (!pos.legal(move, ci.pinned))
              continue;
          moveCount = ++splitPoint-&gt;moveCount;
          splitPoint-&gt;mutex.unlock();
      }
      else
          ++moveCount;
      if (RootNode)
      {
          Signals.firstRootMove = (moveCount == 1);
          if (thisThread == Threads.main() &amp;&amp; Time::now() - SearchTime &gt; 3000)
              sync_cout &lt;&lt; "info depth " &lt;&lt; depth / ONE_PLY
                        &lt;&lt; " currmove " &lt;&lt; move_to_uci(move, pos.is_chess960())
                        &lt;&lt; " currmovenumber " &lt;&lt; moveCount + PVIdx &lt;&lt; sync_endl;
      }
      ext = DEPTH_ZERO;
      captureOrPromotion = pos.capture_or_promotion(move);
      givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
                  ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
                  : pos.gives_check(move, ci);
      dangerous =   givesCheck
                 || type_of(move) != NORMAL
                 || pos.advanced_pawn_push(move);
      if (givesCheck &amp;&amp; pos.see_sign(move) &gt;= VALUE_ZERO)
          ext = ONE_PLY;
      if (    singularExtensionNode
          &amp;&amp;  move == ttMove
          &amp;&amp; !ext
          &amp;&amp;  pos.legal(move, ci.pinned)
          &amp;&amp;  abs(ttValue) &lt; VALUE_KNOWN_WIN)
      {
          assert(ttValue != VALUE_NONE);
          Value rBeta = ttValue - int(depth);
          ss-&gt;excludedMove = move;
          ss-&gt;skipNullMove = true;
          value = search&lt;NonPV, false&gt;(pos, ss, rBeta - 1, rBeta, depth / 2, cutNode);
          ss-&gt;skipNullMove = false;
          ss-&gt;excludedMove = MOVE_NONE;
          if (value &lt; rBeta)
              ext = ONE_PLY;
      }
      newDepth = depth - ONE_PLY + ext;
      if (   !PvNode
          &amp;&amp; !captureOrPromotion
          &amp;&amp; !inCheck
          &amp;&amp; !dangerous
          &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY)
      {
          if (   depth &lt; 16 * ONE_PLY
              &amp;&amp; moveCount &gt;= FutilityMoveCounts[improving][depth] )
          {
              if (SpNode)
                  splitPoint-&gt;mutex.lock();
              continue;
          }
          predictedDepth = newDepth - reduction&lt;PvNode&gt;(improving, depth, moveCount);
          if (predictedDepth &lt; 7 * ONE_PLY)
          {
              futilityValue = ss-&gt;staticEval + futility_margin(predictedDepth)
                            + 128 + Gains[pos.moved_piece(move)][to_sq(move)];
              if (futilityValue &lt;= alpha)
              {
                  bestValue = std::max(bestValue, futilityValue);
                  if (SpNode)
                  {
                      splitPoint-&gt;mutex.lock();
                      if (bestValue &gt; splitPoint-&gt;bestValue)
                          splitPoint-&gt;bestValue = bestValue;
                  }
                  continue;
              }
          }
          if (predictedDepth &lt; 4 * ONE_PLY &amp;&amp; pos.see_sign(move) &lt; VALUE_ZERO)
          {
              if (SpNode)
                  splitPoint-&gt;mutex.lock();
              continue;
          }
      }
      if (!RootNode &amp;&amp; !SpNode &amp;&amp; !pos.legal(move, ci.pinned))
      {
          moveCount--;
          continue;
      }
      pvMove = PvNode &amp;&amp; moveCount == 1;
      ss-&gt;currentMove = move;
      if (!SpNode &amp;&amp; !captureOrPromotion &amp;&amp; quietCount &lt; 64)
          quietsSearched[quietCount++] = move;
      pos.do_move(move, st, ci, givesCheck);
      if (    depth &gt;= 3 * ONE_PLY
          &amp;&amp; !pvMove
          &amp;&amp; !captureOrPromotion
          &amp;&amp;  move != ttMove
          &amp;&amp;  move != ss-&gt;killers[0]
          &amp;&amp;  move != ss-&gt;killers[1])
      {
          ss-&gt;reduction = reduction&lt;PvNode&gt;(improving, depth, moveCount);
          if (!PvNode &amp;&amp; cutNode)
              ss-&gt;reduction += ONE_PLY;
          else if (History[pos.piece_on(to_sq(move))][to_sq(move)] &lt; 0)
              ss-&gt;reduction += ONE_PLY / 2;
          if (move == countermoves[0] || move == countermoves[1])
              ss-&gt;reduction = std::max(DEPTH_ZERO, ss-&gt;reduction - ONE_PLY);
          Depth d = std::max(newDepth - ss-&gt;reduction, ONE_PLY);
          if (SpNode)
              alpha = splitPoint-&gt;alpha;
          value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d, true);
          if (value &gt; alpha &amp;&amp; ss-&gt;reduction &gt;= 4 * ONE_PLY)
          {
              Depth d2 = std::max(newDepth - 2 * ONE_PLY, ONE_PLY);
              value = -search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, d2, true);
          }
          doFullDepthSearch = (value &gt; alpha &amp;&amp; ss-&gt;reduction != DEPTH_ZERO);
          ss-&gt;reduction = DEPTH_ZERO;
      }
      else
          doFullDepthSearch = !pvMove;
      if (doFullDepthSearch)
      {
          if (SpNode)
              alpha = splitPoint-&gt;alpha;
          value = newDepth &lt; ONE_PLY ?
                          givesCheck ? -qsearch&lt;NonPV,  true&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
                                     : -qsearch&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
                                     : - search&lt;NonPV, false&gt;(pos, ss+1, -(alpha+1), -alpha, newDepth, !cutNode);
      }
      if (PvNode &amp;&amp; (pvMove || (value &gt; alpha &amp;&amp; (RootNode || value &lt; beta))))
          value = newDepth &lt; ONE_PLY ?
                          givesCheck ? -qsearch&lt;PV,  true&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
                                     : -qsearch&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
                                     : - search&lt;PV, false&gt;(pos, ss+1, -beta, -alpha, newDepth, false);
      pos.undo_move(move);
      assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
      if (SpNode)
      {
          splitPoint-&gt;mutex.lock();
          bestValue = splitPoint-&gt;bestValue;
          alpha = splitPoint-&gt;alpha;
      }
      if (Signals.stop || thisThread-&gt;cutoff_occurred())
          return VALUE_ZERO;
      if (RootNode)
      {
          RootMove&amp; rm = *std::find(RootMoves.begin(), RootMoves.end(), move);
          if (pvMove || value &gt; alpha)
          {
              rm.score = value;
              rm.extract_pv_from_tt(pos);
              if (!pvMove)
                  ++BestMoveChanges;
          }
          else
              rm.score = -VALUE_INFINITE;
      }
      if (value &gt; bestValue)
      {
          bestValue = SpNode ? splitPoint-&gt;bestValue = value : value;
          if (value &gt; alpha)
          {
              bestMove = SpNode ? splitPoint-&gt;bestMove = move : move;
              if (PvNode &amp;&amp; value &lt; beta)                   alpha = SpNode ? splitPoint-&gt;alpha = value : value;
              else
              {
                  assert(value &gt;= beta); 
                  if (SpNode)
                      splitPoint-&gt;cutoff = true;
                  break;
              }
          }
      }
      if (   !SpNode
          &amp;&amp;  Threads.size() &gt;= 2
          &amp;&amp;  depth &gt;= Threads.minimumSplitDepth
          &amp;&amp;  (   !thisThread-&gt;activeSplitPoint
               || !thisThread-&gt;activeSplitPoint-&gt;allSlavesSearching)
          &amp;&amp;  thisThread-&gt;splitPointsSize &lt; MAX_SPLITPOINTS_PER_THREAD)
      {
          assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; beta);
          thisThread-&gt;split&lt;FakeSplit&gt;(pos, ss, alpha, beta, &amp;bestValue, &amp;bestMove,
                                       depth, moveCount, &amp;mp, NT, cutNode);
          if (Signals.stop || thisThread-&gt;cutoff_occurred())
              return VALUE_ZERO;
          if (bestValue &gt;= beta)
              break;
      }
    }
    if (SpNode)
        return bestValue;
    if (!moveCount)
        bestValue = excludedMove ? alpha
                   :     inCheck ? mated_in(ss-&gt;ply) : DrawValue[pos.side_to_move()];
    else if (bestValue &gt;= beta &amp;&amp; !pos.capture_or_promotion(bestMove) &amp;&amp; !inCheck)
        update_stats(pos, ss, bestMove, depth, quietsSearched, quietCount - 1);
    TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
             bestValue &gt;= beta  ? BOUND_LOWER :
             PvNode &amp;&amp; bestMove ? BOUND_EXACT : BOUND_UPPER,
             depth, bestMove, ss-&gt;staticEval);
    assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
    return bestValue;
  }
  template &lt;NodeType NT, bool InCheck&gt;
  Value qsearch(Position&amp; pos, Stack* ss, Value alpha, Value beta, Depth depth) {
    const bool PvNode = NT == PV;
    assert(NT == PV || NT == NonPV);
    assert(InCheck == !!pos.checkers());
    assert(alpha &gt;= -VALUE_INFINITE &amp;&amp; alpha &lt; beta &amp;&amp; beta &lt;= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(depth &lt;= DEPTH_ZERO);
    StateInfo st;
    const TTEntry* tte;
    Key posKey;
    Move ttMove, move, bestMove;
    Value bestValue, value, ttValue, futilityValue, futilityBase, oldAlpha;
    bool givesCheck, evasionPrunable;
    Depth ttDepth;
    if (PvNode)
        oldAlpha = alpha;
    ss-&gt;currentMove = bestMove = MOVE_NONE;
    ss-&gt;ply = (ss-1)-&gt;ply + 1;
    if (pos.is_draw() || ss-&gt;ply &gt; MAX_PLY)
        return ss-&gt;ply &gt; MAX_PLY &amp;&amp; !InCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
    ttDepth = InCheck || depth &gt;= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS
                                                  : DEPTH_QS_NO_CHECKS;
    posKey = pos.key();
    tte = TT.probe(posKey);
    ttMove = tte ? tte-&gt;move() : MOVE_NONE;
    ttValue = tte ? value_from_tt(tte-&gt;value(),ss-&gt;ply) : VALUE_NONE;
    if (   tte
        &amp;&amp; tte-&gt;depth() &gt;= ttDepth
        &amp;&amp; ttValue != VALUE_NONE         &amp;&amp; (           PvNode ?  tte-&gt;bound() == BOUND_EXACT
            : ttValue &gt;= beta ? (tte-&gt;bound() &amp;  BOUND_LOWER)
                              : (tte-&gt;bound() &amp;  BOUND_UPPER)))
    {
        ss-&gt;currentMove = ttMove;         return ttValue;
    }
    if (InCheck)
    {
        ss-&gt;staticEval = VALUE_NONE;
        bestValue = futilityBase = -VALUE_INFINITE;
    }
    else
    {
        if (tte)
        {
            if ((ss-&gt;staticEval = bestValue = tte-&gt;eval_value()) == VALUE_NONE)
                ss-&gt;staticEval = bestValue = evaluate(pos);
            if (ttValue != VALUE_NONE)
                if (tte-&gt;bound() &amp; (ttValue &gt; bestValue ? BOUND_LOWER : BOUND_UPPER))
                    bestValue = ttValue;
        }
        else
            ss-&gt;staticEval = bestValue = evaluate(pos);
        if (bestValue &gt;= beta)
        {
            if (!tte)
                TT.store(pos.key(), value_to_tt(bestValue, ss-&gt;ply), BOUND_LOWER,
                         DEPTH_NONE, MOVE_NONE, ss-&gt;staticEval);
            return bestValue;
        }
        if (PvNode &amp;&amp; bestValue &gt; alpha)
            alpha = bestValue;
        futilityBase = bestValue + 128;
    }
    MovePicker mp(pos, ttMove, depth, History, to_sq((ss-1)-&gt;currentMove));
    CheckInfo ci(pos);
    while ((move = mp.next_move&lt;false&gt;()) != MOVE_NONE)
    {
      assert(is_ok(move));
      givesCheck =  type_of(move) == NORMAL &amp;&amp; !ci.dcCandidates
                  ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] &amp; to_sq(move)
                  : pos.gives_check(move, ci);
      if (   !PvNode
          &amp;&amp; !InCheck
          &amp;&amp; !givesCheck
          &amp;&amp;  move != ttMove
          &amp;&amp;  futilityBase &gt; -VALUE_KNOWN_WIN
          &amp;&amp; !pos.advanced_pawn_push(move))
      {
          assert(type_of(move) != ENPASSANT); 
          futilityValue = futilityBase + PieceValue[EG][pos.piece_on(to_sq(move))];
          if (futilityValue &lt; beta)
          {
              bestValue = std::max(bestValue, futilityValue);
              continue;
          }
          if (futilityBase &lt; beta &amp;&amp; pos.see(move) &lt;= VALUE_ZERO)
          {
              bestValue = std::max(bestValue, futilityBase);
              continue;
          }
      }
      evasionPrunable =    InCheck
                       &amp;&amp;  bestValue &gt; VALUE_MATED_IN_MAX_PLY
                       &amp;&amp; !pos.capture(move)
                       &amp;&amp; !pos.can_castle(pos.side_to_move());
      if (   !PvNode
          &amp;&amp; (!InCheck || evasionPrunable)
          &amp;&amp;  move != ttMove
          &amp;&amp;  type_of(move) != PROMOTION
          &amp;&amp;  pos.see_sign(move) &lt; VALUE_ZERO)
          continue;
      if (!pos.legal(move, ci.pinned))
          continue;
      ss-&gt;currentMove = move;
      pos.do_move(move, st, ci, givesCheck);
      value = givesCheck ? -qsearch&lt;NT,  true&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY)
                         : -qsearch&lt;NT, false&gt;(pos, ss+1, -beta, -alpha, depth - ONE_PLY);
      pos.undo_move(move);
      assert(value &gt; -VALUE_INFINITE &amp;&amp; value &lt; VALUE_INFINITE);
      if (value &gt; bestValue)
      {
          bestValue = value;
          if (value &gt; alpha)
          {
              if (PvNode &amp;&amp; value &lt; beta)               {
                  alpha = value;
                  bestMove = move;
              }
              else               {
                  TT.store(posKey, value_to_tt(value, ss-&gt;ply), BOUND_LOWER,
                           ttDepth, move, ss-&gt;staticEval);
                  return value;
              }
          }
       }
    }
    if (InCheck &amp;&amp; bestValue == -VALUE_INFINITE)
        return mated_in(ss-&gt;ply); 
    TT.store(posKey, value_to_tt(bestValue, ss-&gt;ply),
             PvNode &amp;&amp; bestValue &gt; oldAlpha ? BOUND_EXACT : BOUND_UPPER,
             ttDepth, bestMove, ss-&gt;staticEval);
    assert(bestValue &gt; -VALUE_INFINITE &amp;&amp; bestValue &lt; VALUE_INFINITE);
    return bestValue;
  }
  Value value_to_tt(Value v, int ply) {
    assert(v != VALUE_NONE);
    return  v &gt;= VALUE_MATE_IN_MAX_PLY  ? v + ply
          : v &lt;= VALUE_MATED_IN_MAX_PLY ? v - ply : v;
  }
  Value value_from_tt(Value v, int ply) {
    return  v == VALUE_NONE             ? VALUE_NONE
          : v &gt;= VALUE_MATE_IN_MAX_PLY  ? v - ply
          : v &lt;= VALUE_MATED_IN_MAX_PLY ? v + ply : v;
  }
  void update_stats(const Position&amp; pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt) {
    if (ss-&gt;killers[0] != move)
    {
        ss-&gt;killers[1] = ss-&gt;killers[0];
        ss-&gt;killers[0] = move;
    }
    Value bonus = Value(int(depth) * int(depth));
    History.update(pos.moved_piece(move), to_sq(move), bonus);
    for (int i = 0; i &lt; quietsCnt; ++i)
    {
        Move m = quiets[i];
        History.update(pos.moved_piece(m), to_sq(m), -bonus);
    }
    if (is_ok((ss-1)-&gt;currentMove))
    {
        Square prevMoveSq = to_sq((ss-1)-&gt;currentMove);
        Countermoves.update(pos.piece_on(prevMoveSq), prevMoveSq, move);
    }
    if (is_ok((ss-2)-&gt;currentMove) &amp;&amp; (ss-1)-&gt;currentMove == (ss-1)-&gt;ttMove)
    {
        Square prevOwnMoveSq = to_sq((ss-2)-&gt;currentMove);
        Followupmoves.update(pos.piece_on(prevOwnMoveSq), prevOwnMoveSq, move);
    }
  }
  Move Skill::pick_move() {
    static RKISS rk;
    for (int i = Time::now() % 50; i &gt; 0; --i)
        rk.rand&lt;unsigned&gt;();
    int variance = std::min(RootMoves[0].score - RootMoves[MultiPV - 1].score, PawnValueMg);
    int weakness = 120 - 2 * level;
    int max_s = -VALUE_INFINITE;
    best = MOVE_NONE;
    for (size_t i = 0; i &lt; MultiPV; ++i)
    {
        int s = RootMoves[i].score;
        if (i &gt; 0 &amp;&amp; RootMoves[i-1].score &gt; s + 2 * PawnValueMg)
            break;
        s += (  weakness * int(RootMoves[0].score - s)
              + variance * (rk.rand&lt;unsigned&gt;() % weakness)) / 128;
        if (s &gt; max_s)
        {
            max_s = s;
            best = RootMoves[i].pv[0];
        }
    }
    return best;
  }
  string uci_pv(const Position&amp; pos, int depth, Value alpha, Value beta) {
    std::stringstream ss;
    Time::point elapsed = Time::now() - SearchTime + 1;
    size_t uciPVSize = std::min((size_t)Options["MultiPV"], RootMoves.size());
<a name="3"></a>    int selDepth = 0;
    for (size_t i = 0; i &lt; Threads.size(); ++i)</b></font>
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        if (Threads[i]-&gt;maxPly &gt; selDepth)
            selDepth = Threads[i]-&gt;maxPly;
    for (size_t i = 0; i &lt; uciPVSize; ++i)
    {
        bool updated = (i &lt;= PVIdx);
        if (depth == 1 &amp;&amp; !updated)
            continue;
        int d   = updated ? depth : depth - 1;
        Value v = updated ? RootMoves[i].score : RootMoves[i].prevScore;
        if (ss.rdbuf()-&gt;in_avail())             ss &lt;&lt; "\n";
        ss &lt;&lt; "info depth " &lt;&lt; d
           &lt;&lt; " seldepth "  &lt;&lt; selDepth
           &lt;&lt; " score "     &lt;&lt; (i == PVIdx ? score_to_uci(v, alpha, beta) : score_to_uci(v))
           &lt;&lt; " nodes "     &lt;&lt; pos.nodes_searched()
           &lt;&lt; " nps "       &lt;&lt; pos.nodes_searched() * 1000 / elapsed
           &lt;&lt; " time "      &lt;&lt; elapsed
           &lt;&lt; " multipv "   &lt;&lt; i + 1
           &lt;&lt; " pv";
        for (size_t j = 0; RootMoves[i].pv[j] != MOVE_NONE; ++j)
            ss &lt;&lt; " " &lt;&lt; move_to_uci(RootMoves[i].pv[j], pos.is_chess960());
    }
    return ss.str();
  }
} 
void RootMove::extract_pv_from_tt(Position&amp; pos) {
  StateInfo state[MAX_PLY_PLUS_6], *st = state;
  const TTEntry* tte;
  int ply = 1;      Move m = pv[0];   Value expectedScore = score;
  pv.clear();
  do {
      pv.push_back(m);
      assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[ply - 1]));
      pos.do_move(pv[ply++ - 1], *st++);
      tte = TT.probe(pos.key());
      expectedScore = -expectedScore;
  } while (   tte
           &amp;&amp; expectedScore == value_from_tt(tte-&gt;value(), ply)
           &amp;&amp; pos.pseudo_legal(m = tte-&gt;move())            &amp;&amp; pos.legal(m, pos.pinned_pieces(pos.side_to_move()))
           &amp;&amp; ply &lt; MAX_PLY
           &amp;&amp; (!pos.is_draw() || ply &lt;= 2));
  pv.push_back(MOVE_NONE); 
  while (--ply) pos.undo_move(pv[ply - 1]);
}
void RootMove::insert_pv_in_tt(Position&amp; pos) {
  StateInfo state[MAX_PLY_PLUS_6], *st = state;
  const TTEntry* tte;
  int idx = 0; 
  do {
      tte = TT.probe(pos.key());
      if (!tte || tte-&gt;move() != pv[idx])           TT.store(pos.key(), VALUE_NONE, BOUND_NONE, DEPTH_NONE, pv[idx], VALUE_NONE);
      assert(MoveList&lt;LEGAL&gt;(pos).contains(pv[idx]));
      pos.do_move(pv[idx++], *st++);
  } while (pv[idx] != MOVE_NONE);
  while (idx) pos.undo_move(pv[--idx]);
}
void Thread::idle_loop() {
  SplitPoint* this_sp = splitPointsSize ? activeSplitPoint : NULL;</b></font>
  assert(!this_sp || (this_sp-&gt;masterThread == this &amp;&amp; searching));
  while (true)
  {
      while (!searching || exit)
      {
          if (exit)
          {
              assert(!this_sp);
              return;
          }
          mutex.lock();
          if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
          {
              mutex.unlock();
              break;
          }
          if (!searching &amp;&amp; !exit)
              sleepCondition.wait(mutex);
          mutex.unlock();
      }
      if (searching)
      {
          assert(!exit);
          Threads.mutex.lock();
          assert(searching);
          assert(activeSplitPoint);
          SplitPoint* sp = activeSplitPoint;
          Threads.mutex.unlock();
          Stack stack[MAX_PLY_PLUS_6], *ss = stack+2;           Position pos(*sp-&gt;pos, this);
          std::memcpy(ss-2, sp-&gt;ss-2, 5 * sizeof(Stack));
          ss-&gt;splitPoint = sp;
          sp-&gt;mutex.lock();
          assert(activePosition == NULL);
          activePosition = &amp;pos;
          if (sp-&gt;nodeType == NonPV)
              search&lt;NonPV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
          else if (sp-&gt;nodeType == PV)
              search&lt;PV, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
          else if (sp-&gt;nodeType == Root)
              search&lt;Root, true&gt;(pos, ss, sp-&gt;alpha, sp-&gt;beta, sp-&gt;depth, sp-&gt;cutNode);
          else
              assert(false);
          assert(searching);
<a name="4"></a>          searching = false;
          activePosition = NULL;
          sp-&gt;slavesMask.reset(idx);
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          sp-&gt;allSlavesSearching = false;
          sp-&gt;nodes += pos.nodes_searched();
          if (    this != sp-&gt;masterThread
              &amp;&amp;  sp-&gt;slavesMask.none())
          {
              assert(!sp-&gt;masterThread-&gt;searching);
              sp-&gt;masterThread-&gt;notify_one();
          }
          sp-&gt;mutex.unlock();
          if (Threads.size() &gt; 2)
              for (size_t i = 0; i &lt; Threads.size(); ++i)
              {
                  int size = Threads[i]-&gt;splitPointsSize;                   sp = size ? &amp;Threads[i]-&gt;splitPoints[size - 1] : NULL;
                  if (   sp
                      &amp;&amp; sp-&gt;allSlavesSearching
                      &amp;&amp; available_to(Threads[i]))
                  {
                      Threads.mutex.lock();
                      sp-&gt;mutex.lock();
                      if (   sp-&gt;allSlavesSearching
                          &amp;&amp; available_to(Threads[i]))
                      {
                           sp-&gt;slavesMask.set(idx);
                           activeSplitPoint = sp;
                           searching = true;
                      }
                      sp-&gt;mutex.unlock();
                      Threads.mutex.unlock();
                      break;                   }
              }
      }
      if (this_sp &amp;&amp; this_sp-&gt;slavesMask.none())
      {
          this_sp-&gt;mutex.lock();
          bool finished = this_sp-&gt;slavesMask.none();           this_sp-&gt;mutex.unlock();
          if (finished)
              return;
      }
  }
}
void check_time() {
  static Time::point lastInfoTime = Time::now();
  int64_t nodes = 0; 
  if (Time::now() - lastInfoTime &gt;= 1000)
  {
      lastInfoTime = Time::now();
      dbg_print();
  }
  if (Limits.ponder)
      return;
  if (Limits.nodes)
  {
      Threads.mutex.lock();
      nodes = RootPos.nodes_searched();
<a name="8"></a>            for (size_t i = 0; i &lt; Threads.size(); ++i)</b></font>
<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          for (int j = 0; j &lt; Threads[i]-&gt;splitPointsSize; ++j)
          {
              SplitPoint&amp; sp = Threads[i]-&gt;splitPoints[j];
              sp.mutex.lock();
              nodes += sp.nodes;
              for (size_t idx = 0; idx &lt; Threads.size(); ++idx)
                  if (sp.slavesMask.test(idx) &amp;&amp; Threads[idx]-&gt;activePosition)
                      nodes += Threads[idx]-&gt;activePosition-&gt;nodes_searched();
              sp.mutex.unlock();
          }
      Threads.mutex.unlock();
  }
  Time::point elapsed = Time::now() - SearchTime;
  bool stillAtFirstMove =    Signals.firstRootMove
                         &amp;&amp; !Signals.failedLowAtRoot
                         &amp;&amp;  elapsed &gt; TimeMgr.available_time() * 75 / 100;
  bool noMoreTime =   elapsed &gt; TimeMgr.maximum_time() - 2 * TimerThread::Resolution
                   || stillAtFirstMove;
  if (   (Limits.use_time_management() &amp;&amp; noMoreTime)
      || (Limits.movetime &amp;&amp; elapsed &gt;= Limits.movetime)
      || (Limits.nodes &amp;&amp; nodes &gt;= Limits.nodes))
      Signals.stop = true;
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
