
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6548672566371683%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ViewStyle.h</h3>
            <pre><code>1  #ifndef VIEWSTYLE_H
2  #define VIEWSTYLE_H
3  namespace Scintilla::Internal {
4  class MarginStyle {
5  public:
6  	Scintilla::MarginType style;
7  	ColourRGBA back;
8  	int width;
9  	int mask;
10  	bool sensitive;
11  	Scintilla::CursorShape cursor;
12  	MarginStyle(Scintilla::MarginType style_= Scintilla::MarginType::Symbol, int width_=0, int mask_=0) noexcept;
13  	bool ShowsFolding() const noexcept;
14  };
15  class FontRealised {
16  public:
17  	FontMeasurements measurements;
18  	std::shared_ptr<Font> font;
19  	void Realise(Surface &surface, int zoomLevel, Scintilla::Technology technology, const FontSpecification &fs, const char *localeName);
20  };
21  typedef std::map<FontSpecification, std::unique_ptr<FontRealised>> FontMap;
22  using ColourOptional = std::optional<ColourRGBA>;
23  inline ColourOptional OptionalColour(Scintilla::uptr_t wParam, Scintilla::sptr_t lParam) noexcept {
24  	if (wParam) {
25  		return ColourRGBA::FromIpRGB(lParam);
26  	} else {
27  		return {};
28  	}
29  }
30  struct SelectionAppearance {
31  	bool visible = true;
32  	Scintilla::Layer layer = Layer::Base;
33  	bool eolFilled = false;
34  };
35  struct CaretLineAppearance {
36  	Scintilla::Layer layer = Layer::Base;
37  	bool alwaysShow = false;
38  	bool subLine = false;
39  	int frame = 0;
40  };
41  struct CaretAppearance {
42  	Scintilla::CaretStyle style = CaretStyle::Line;
43  	int width = 1;
44  };
45  struct WrapAppearance {
46  	Scintilla::Wrap state = Wrap::None;
47  	Scintilla::WrapVisualFlag visualFlags = WrapVisualFlag::None;
48  	Scintilla::WrapVisualLocation visualFlagsLocation = WrapVisualLocation::Default;
49  	int visualStartIndent = 0;
50  	Scintilla::WrapIndentMode indentMode = WrapIndentMode::Fixed;
51  };
52  struct EdgeProperties {
53  	int column = 0;
54  	ColourRGBA colour;
55  	constexpr EdgeProperties(int column_ = 0, ColourRGBA colour_ = ColourRGBA::FromRGB(0)) noexcept :
56  		column(column_), colour(colour_) {
57  	}
58  };
59  enum StyleIndices {
60  	StyleDefault = static_cast<int>(Scintilla::StylesCommon::Default),
61  	StyleLineNumber = static_cast<int>(Scintilla::StylesCommon::LineNumber),
62  	StyleBraceLight = static_cast<int>(Scintilla::StylesCommon::BraceLight),
63  	StyleBraceBad = static_cast<int>(Scintilla::StylesCommon::BraceBad),
64  	StyleControlChar = static_cast<int>(Scintilla::StylesCommon::ControlChar),
65  	StyleIndentGuide = static_cast<int>(Scintilla::StylesCommon::IndentGuide),
66  	StyleCallTip = static_cast<int>(Scintilla::StylesCommon::CallTip),
67  	StyleFoldDisplayText = static_cast<int>(Scintilla::StylesCommon::FoldDisplayText),
68  };
69  class ViewStyle {
70  	UniqueStringSet fontNames;
71  	FontMap fonts;
72  public:
73  	std::vector<Style> styles;
74  	int nextExtendedStyle;
75  	std::vector<LineMarker> markers;
76  	int largestMarkerHeight;
77  	std::vector<Indicator> indicators;
78  	bool indicatorsDynamic;
79  	bool indicatorsSetFore;
80  	Scintilla::Technology technology;
81  	int lineHeight;
82  	int lineOverlap;
83  	XYPOSITION maxAscent;
84  	XYPOSITION maxDescent;
85  	XYPOSITION aveCharWidth;
86  	XYPOSITION spaceWidth;
87  	XYPOSITION tabWidth;
88  	SelectionAppearance selection;
89  	int controlCharSymbol;
90  	XYPOSITION controlCharWidth;
91  	ColourRGBA selbar;
92  	ColourRGBA selbarlight;
93  	ColourOptional foldmarginColour;
94  	ColourOptional foldmarginHighlightColour;
95  	bool hotspotUnderline;
96  	int leftMarginWidth;	
97  	int rightMarginWidth;	
98  	int maskInLine = 0;	
99  	int maskDrawInText = 0;	
100  	int maskDrawWrapped = 0;	
101  	std::vector<MarginStyle> ms;
102  	int fixedColumnWidth = 0;	
103  	bool marginInside;	
104  	int textStart;	
105  	int zoomLevel;
106  	Scintilla::WhiteSpace viewWhitespace;
107  	Scintilla::TabDrawMode tabDrawMode;
108  	int whitespaceSize;
109  	Scintilla::IndentView viewIndentationGuides;
110  	bool viewEOL;
111  	CaretAppearance caret;
112  	CaretLineAppearance caretLine;
113  	bool someStylesProtected;
114  	bool someStylesForceCase;
115  	Scintilla::FontQuality extraFontFlag;
116  	int extraAscent;
117  	int extraDescent;
118  	int marginStyleOffset;
119  	Scintilla::AnnotationVisible annotationVisible;
120  	int annotationStyleOffset;
121  	Scintilla::EOLAnnotationVisible eolAnnotationVisible;
122  	int eolAnnotationStyleOffset;
123  	bool braceHighlightIndicatorSet;
124  	int braceHighlightIndicator;
125  	bool braceBadLightIndicatorSet;
126  	int braceBadLightIndicator;
127  	Scintilla::EdgeVisualStyle edgeState;
128  	EdgeProperties theEdge;
129  	std::vector<EdgeProperties> theMultiEdge;
130  	int marginNumberPadding; 
131  	int ctrlCharPadding; 
132  	int lastSegItalicsOffset; 
133  	using ElementMap = std::map<Scintilla::Element, ColourOptional>;
134  	ElementMap elementColours;
135  	ElementMap elementBaseColours;
136  	std::set<Scintilla::Element> elementAllowsTranslucent;
137  	WrapAppearance wrap;
138  	std::string localeName;
139  	ViewStyle(size_t stylesSize_=256);
140  	ViewStyle(const ViewStyle &source);
141  	ViewStyle(ViewStyle &&) = delete;
142  	ViewStyle &operator=(const ViewStyle &) = delete;
143  	ViewStyle &operator=(ViewStyle &&) = delete;
144  	~ViewStyle();
145  	void CalculateMarginWidthAndMask() noexcept;
146  	void Refresh(Surface &surface, int tabInChars);
147  	void ReleaseAllExtendedStyles() noexcept;
148  	int AllocateExtendedStyles(int numberStyles);
149  	void EnsureStyle(size_t index);
150  	void ResetDefaultStyle();
151  	void ClearStyles();
152  	void SetStyleFontName(int styleIndex, const char *name);
153  	void SetFontLocaleName(const char *name);
154  	bool ProtectionActive() const noexcept;
155  	int ExternalMarginWidth() const noexcept;
<span onclick='openModal()' class='match'>156  	int MarginFromLocation(Point pt) const noexcept;
157  	bool ValidStyle(size_t styleIndex) const noexcept;
158  	void CalcLargestMarkerHeight() noexcept;
159  	int GetFrameWidth() const noexcept;
160  	bool IsLineFrameOpaque(bool caretActive, bool lineContainsCaret) const;
161  	ColourOptional Background(int marksOfLine, bool caretActive, bool lineContainsCaret) const;
162  	bool SelectionBackgroundDrawn() const noexcept;
</span>163  	bool SelectionTextDrawn() const;
164  	bool WhitespaceBackgroundDrawn() const;
165  	ColourRGBA WrapColour() const;
166  	void AddMultiEdge(int column, ColourRGBA colour);
167  	ColourOptional ElementColour(Scintilla::Element element) const;
168  	ColourRGBA ElementColourForced(Scintilla::Element element) const;
169  	bool ElementAllowsTranslucent(Scintilla::Element element) const;
170  	bool ResetElement(Scintilla::Element element);
171  	bool SetElementColour(Scintilla::Element element, ColourRGBA colour);
172  	bool SetElementColourOptional(Scintilla::Element element, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
173  	void SetElementRGB(Scintilla::Element element, int rgb);
174  	void SetElementAlpha(Scintilla::Element element, int alpha);
175  	bool ElementIsSet(Scintilla::Element element) const;
176  	bool SetElementBase(Scintilla::Element element, ColourRGBA colour);
177  	bool SetWrapState(Scintilla::Wrap wrapState_) noexcept;
178  	bool SetWrapVisualFlags(Scintilla::WrapVisualFlag wrapVisualFlags_) noexcept;
179  	bool SetWrapVisualFlagsLocation(Scintilla::WrapVisualLocation wrapVisualFlagsLocation_) noexcept;
180  	bool SetWrapVisualStartIndent(int wrapVisualStartIndent_) noexcept;
181  	bool SetWrapIndentMode(Scintilla::WrapIndentMode wrapIndentMode_) noexcept;
182  	bool WhiteSpaceVisible(bool inIndent) const noexcept;
183  	enum class CaretShape { invisible, line, block, bar };
184  	bool IsBlockCaretStyle() const noexcept;
185  	bool IsCaretVisible(bool isMainSelection) const noexcept;
186  	bool DrawCaretInsideSelection(bool inOverstrike, bool imeCaretBlockOverride) const noexcept;
187  	CaretShape CaretShapeForMode(bool inOverstrike, bool isMainSelection) const noexcept;
188  private:
189  	void AllocStyles(size_t sizeNew);
190  	void CreateAndAddFont(const FontSpecification &fs);
191  	FontRealised *Find(const FontSpecification &fs);
192  	void FindMaxAscentDescent() noexcept;
193  };
194  }
195  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</h3>
            <pre><code>1  #ifndef CLST_H
2  #define CLST_H
3  #include "list.h"
4  #include "lsterr.h"
5  #include "serialis.h"
6  #include <cstdio>
7  namespace tesseract {
8  class CLIST_ITERATOR;
9  class CLIST_LINK {
10    friend class CLIST_ITERATOR;
11    friend class CLIST;
12    CLIST_LINK *next;
13    void *data;
14  public:
15    CLIST_LINK() { 
16      data = next = nullptr;
17    }
18    CLIST_LINK(const CLIST_LINK &) = delete;
19    void operator=(const CLIST_LINK &) = delete;
20  };
21  class TESS_API CLIST {
22    friend class CLIST_ITERATOR;
23    CLIST_LINK *last = nullptr; 
24    CLIST_LINK *First() { 
25      return last != nullptr ? last->next : nullptr;
26    }
27    const CLIST_LINK *First() const { 
28      return last != nullptr ? last->next : nullptr;
29    }
30  public:
31    ~CLIST() { 
32      shallow_clear();
33    }
34    void internal_deep_clear(    
35        void (*zapper)(void *)); 
36    void shallow_clear(); 
37    bool empty() const { 
38      return !last;
39    }
40    bool singleton() const {
41      return last != nullptr ? (last == last->next) : false;
42    }
43    void shallow_copy(      
44        CLIST *from_list) { 
45      last = from_list->last;
46    }
47    void assign_to_sublist(       
48        CLIST_ITERATOR *start_it, 
49        CLIST_ITERATOR *end_it);  
50    int32_t length() const { 
51      int32_t count = 0;
52      if (last != nullptr) {
53        count = 1;
54        for (auto it = last->next; it != last; it = it->next) {
55          count++;
56        }
57      }
58      return count;
59    }
60    void sort(          
<span onclick='openModal()' class='match'>61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
64    void set_subtract(int comparator(const void *, const void *), bool unique, CLIST *minuend,
</span>65                      CLIST *subtrahend);
66  };
67  class TESS_API CLIST_ITERATOR {
68    friend void CLIST::assign_to_sublist(CLIST_ITERATOR *, CLIST_ITERATOR *);
69    CLIST *list;                  
70    CLIST_LINK *prev;             
71    CLIST_LINK *current;          
72    CLIST_LINK *next;             
73    CLIST_LINK *cycle_pt;         
74    bool ex_current_was_last;     
75    bool ex_current_was_cycle_pt; 
76    bool started_cycling;         
77    CLIST_LINK *extract_sublist(   
78        CLIST_ITERATOR *other_it); 
79  public:
80    CLIST_ITERATOR() { 
81      list = nullptr;
82    } 
83    CLIST_ITERATOR( 
84        CLIST *list_to_iterate);
85    void set_to_list( 
86        CLIST *list_to_iterate);
87    void add_after_then_move( 
88        void *new_data);      
89    void add_after_stay_put( 
90        void *new_data);     
91    void add_before_then_move( 
92        void *new_data);       
93    void add_before_stay_put( 
94        void *new_data);      
95    void add_list_after(     
96        CLIST *list_to_add); 
97    void add_list_before(    
98        CLIST *list_to_add); 
99    void *data() { 
100  #ifndef NDEBUG
101      if (!list) {
102        NO_LIST.error("CLIST_ITERATOR::data", ABORT);
103      }
104  #endif
105      return current->data;
106    }
107    void *data_relative( 
108        int8_t offset);  
109    void *forward(); 
110    void *extract(); 
111    void *move_to_first(); 
112    void *move_to_last(); 
113    void mark_cycle_pt(); 
114    bool empty() const { 
115      return list->empty();
116    }
117    bool current_extracted() const { 
118      return !current;
119    }
120    bool at_first() const; 
121    bool at_last() const; 
122    bool cycled_list() const; 
123    void add_to_end(     
124        void *new_data); 
125    void exchange(                 
126        CLIST_ITERATOR *other_it); 
127    int32_t length() const; 
128    void sort(          
129        int comparator( 
130            const void *, const void *));
131  };
132  inline void CLIST_ITERATOR::set_to_list( 
133      CLIST *list_to_iterate) {
134    list = list_to_iterate;
135    prev = list->last;
136    current = list->First();
137    next = current != nullptr ? current->next : nullptr;
138    cycle_pt = nullptr; 
139    started_cycling = false;
140    ex_current_was_last = false;
141    ex_current_was_cycle_pt = false;
142  }
143  inline CLIST_ITERATOR::CLIST_ITERATOR(CLIST *list_to_iterate) {
144    set_to_list(list_to_iterate);
145  }
146  inline void CLIST_ITERATOR::add_after_then_move( 
147      void *new_data) {
148  #ifndef NDEBUG
149    if (!new_data) {
150      BAD_PARAMETER.error("CLIST_ITERATOR::add_after_then_move", ABORT, "new_data is nullptr");
151    }
152  #endif
153    auto new_element = new CLIST_LINK;
154    new_element->data = new_data;
155    if (list->empty()) {
156      new_element->next = new_element;
157      list->last = new_element;
158      prev = next = new_element;
159    } else {
160      new_element->next = next;
161      if (current) { 
162        current->next = new_element;
163        prev = current;
164        if (current == list->last) {
165          list->last = new_element;
166        }
167      } else { 
168        prev->next = new_element;
169        if (ex_current_was_last) {
170          list->last = new_element;
171        }
172        if (ex_current_was_cycle_pt) {
173          cycle_pt = new_element;
174        }
175      }
176    }
177    current = new_element;
178  }
179  inline void CLIST_ITERATOR::add_after_stay_put( 
180      void *new_data) {
181  #ifndef NDEBUG
182    if (!new_data) {
183      BAD_PARAMETER.error("CLIST_ITERATOR::add_after_stay_put", ABORT, "new_data is nullptr");
184    }
185  #endif
186    auto new_element = new CLIST_LINK;
187    new_element->data = new_data;
188    if (list->empty()) {
189      new_element->next = new_element;
190      list->last = new_element;
191      prev = next = new_element;
192      ex_current_was_last = false;
193      current = nullptr;
194    } else {
195      new_element->next = next;
196      if (current) { 
197        current->next = new_element;
198        if (prev == current) {
199          prev = new_element;
200        }
201        if (current == list->last) {
202          list->last = new_element;
203        }
204      } else { 
205        prev->next = new_element;
206        if (ex_current_was_last) {
207          list->last = new_element;
208          ex_current_was_last = false;
209        }
210      }
211      next = new_element;
212    }
213  }
214  inline void CLIST_ITERATOR::add_before_then_move( 
215      void *new_data) {
216  #ifndef NDEBUG
217    if (!new_data) {
218      BAD_PARAMETER.error("CLIST_ITERATOR::add_before_then_move", ABORT, "new_data is nullptr");
219    }
220  #endif
221    auto new_element = new CLIST_LINK;
222    new_element->data = new_data;
223    if (list->empty()) {
224      new_element->next = new_element;
225      list->last = new_element;
226      prev = next = new_element;
227    } else {
228      prev->next = new_element;
229      if (current) { 
230        new_element->next = current;
231        next = current;
232      } else { 
233        new_element->next = next;
234        if (ex_current_was_last) {
235          list->last = new_element;
236        }
237        if (ex_current_was_cycle_pt) {
238          cycle_pt = new_element;
239        }
240      }
241    }
242    current = new_element;
243  }
244  inline void CLIST_ITERATOR::add_before_stay_put( 
245      void *new_data) {
246  #ifndef NDEBUG
247    if (!new_data) {
248      BAD_PARAMETER.error("CLIST_ITERATOR::add_before_stay_put", ABORT, "new_data is nullptr");
249    }
250  #endif
251    auto new_element = new CLIST_LINK;
252    new_element->data = new_data;
253    if (list->empty()) {
254      new_element->next = new_element;
255      list->last = new_element;
256      prev = next = new_element;
257      ex_current_was_last = true;
258      current = nullptr;
259    } else {
260      prev->next = new_element;
261      if (current) { 
262        new_element->next = current;
263        if (next == current) {
264          next = new_element;
265        }
266      } else { 
267        new_element->next = next;
268        if (ex_current_was_last) {
269          list->last = new_element;
270        }
271      }
272      prev = new_element;
273    }
274  }
275  inline void CLIST_ITERATOR::add_list_after(CLIST *list_to_add) {
276    if (!list_to_add->empty()) {
277      if (list->empty()) {
278        list->last = list_to_add->last;
279        prev = list->last;
280        next = list->First();
281        ex_current_was_last = true;
282        current = nullptr;
283      } else {
284        if (current) { 
285          current->next = list_to_add->First();
286          if (current == list->last) {
287            list->last = list_to_add->last;
288          }
289          list_to_add->last->next = next;
290          next = current->next;
291        } else { 
292          prev->next = list_to_add->First();
293          if (ex_current_was_last) {
294            list->last = list_to_add->last;
295            ex_current_was_last = false;
296          }
297          list_to_add->last->next = next;
298          next = prev->next;
299        }
300      }
301      list_to_add->last = nullptr;
302    }
303  }
304  inline void CLIST_ITERATOR::add_list_before(CLIST *list_to_add) {
305    if (!list_to_add->empty()) {
306      if (list->empty()) {
307        list->last = list_to_add->last;
308        prev = list->last;
309        current = list->First();
310        next = current->next;
311        ex_current_was_last = false;
312      } else {
313        prev->next = list_to_add->First();
314        if (current) { 
315          list_to_add->last->next = current;
316        } else { 
317          list_to_add->last->next = next;
318          if (ex_current_was_last) {
319            list->last = list_to_add->last;
320          }
321          if (ex_current_was_cycle_pt) {
322            cycle_pt = prev->next;
323          }
324        }
325        current = prev->next;
326        next = current->next;
327      }
328      list_to_add->last = nullptr;
329    }
330  }
331  inline void *CLIST_ITERATOR::extract() {
332  #ifndef NDEBUG
333    if (!current) { 
334      NULL_CURRENT.error("CLIST_ITERATOR::extract", ABORT);
335    }
336  #endif
337    if (list->singleton()) {
338      prev = next = list->last = nullptr;
339    } else {
340      prev->next = next; 
341      if (current == list->last) {
342        list->last = prev;
343        ex_current_was_last = true;
344      } else {
345        ex_current_was_last = false;
346      }
347    }
348    ex_current_was_cycle_pt = (current == cycle_pt);
349    auto extracted_data = current->data;
350    delete (current); 
351    current = nullptr;
352    return extracted_data;
353  }
354  inline void *CLIST_ITERATOR::move_to_first() {
355    current = list->First();
356    prev = list->last;
357    next = current != nullptr ? current->next : nullptr;
358    return current != nullptr ? current->data : nullptr;
359  }
360  inline void CLIST_ITERATOR::mark_cycle_pt() {
361  #ifndef NDEBUG
362    if (!list) {
363      NO_LIST.error("CLIST_ITERATOR::mark_cycle_pt", ABORT);
364    }
365  #endif
366    if (current) {
367      cycle_pt = current;
368    } else {
369      ex_current_was_cycle_pt = true;
370    }
371    started_cycling = false;
372  }
373  inline bool CLIST_ITERATOR::at_first() const {
374    return ((list->empty()) || (current == list->First()) ||
375            ((current == nullptr) && (prev == list->last) && 
376             !ex_current_was_last));                         
377  }
378  inline bool CLIST_ITERATOR::at_last() const {
379    return ((list->empty()) || (current == list->last) ||
380            ((current == nullptr) && (prev == list->last) && 
381             ex_current_was_last));                          
382  }
383  inline bool CLIST_ITERATOR::cycled_list() const {
384    return ((list->empty()) || ((current == cycle_pt) && started_cycling));
385  }
386  inline int32_t CLIST_ITERATOR::length() const {
387    return list->length();
388  }
389  inline void CLIST_ITERATOR::sort( 
390      int comparator(               
391          const void *, const void *)) {
392    list->sort(comparator);
393    move_to_first();
394  }
395  inline void CLIST_ITERATOR::add_to_end( 
396      void *new_data) {
397  #ifndef NDEBUG
398    if (!list) {
399      NO_LIST.error("CLIST_ITERATOR::add_to_end", ABORT);
400    }
401    if (!new_data) {
402      BAD_PARAMETER.error("CLIST_ITERATOR::add_to_end", ABORT, "new_data is nullptr");
403    }
404  #endif
405    if (this->at_last()) {
406      this->add_after_stay_put(new_data);
407    } else {
408      if (this->at_first()) {
409        this->add_before_stay_put(new_data);
410        list->last = prev;
411      } else { 
412        auto new_element = new CLIST_LINK;
413        new_element->data = new_data;
414        new_element->next = list->last->next;
415        list->last->next = new_element;
416        list->last = new_element;
417      }
418    }
419  }
420  template <typename CLASSNAME>
421  class X_CLIST : public CLIST {
422  public:
423    X_CLIST() = default;
424    X_CLIST(const X_CLIST &) = delete;
425    X_CLIST &operator=(const X_CLIST &) = delete;
426    void deep_clear() {
427      internal_deep_clear([](void *link) {delete static_cast<CLASSNAME *>(link);});
428    }
429  };
430  #define CLISTIZEH(CLASSNAME)                                    \
431    class CLASSNAME##_CLIST : public X_CLIST<CLASSNAME> {         \
432      using X_CLIST<CLASSNAME>::X_CLIST;                          \
433    };                                                            \
434    struct CLASSNAME##_C_IT : X_ITER<CLIST_ITERATOR, CLASSNAME> { \
435      using X_ITER<CLIST_ITERATOR, CLASSNAME>::X_ITER;            \
436    };
437  } 
438  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ViewStyle.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</div>
                <div class="column column_space"><pre><code>156  	int MarginFromLocation(Point pt) const noexcept;
157  	bool ValidStyle(size_t styleIndex) const noexcept;
158  	void CalcLargestMarkerHeight() noexcept;
159  	int GetFrameWidth() const noexcept;
160  	bool IsLineFrameOpaque(bool caretActive, bool lineContainsCaret) const;
161  	ColourOptional Background(int marksOfLine, bool caretActive, bool lineContainsCaret) const;
162  	bool SelectionBackgroundDrawn() const noexcept;
</pre></code></div>
                <div class="column column_space"><pre><code>61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
64    void set_subtract(int comparator(const void *, const void *), bool unique, CLIST *minuend,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    