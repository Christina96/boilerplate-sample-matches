
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.953308972797402%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.h</h3>
            <pre><code>1  #pragma once
2  #include "Scintilla.h"
3  #include "ScintillaRef.h"
4  #include "SciLexer.h"
5  #include "Buffer.h"
6  #include "colors.h"
7  #include "UserDefineDialog.h"
8  #include "rgba_icons.h"
9  #ifndef WM_MOUSEWHEEL
10  #define WM_MOUSEWHEEL 0x020A
11  #endif 
12  #ifndef WM_MOUSEHWHEEL
13  #define WM_MOUSEHWHEEL 0x020E
14  #endif 
15  #ifndef WM_APPCOMMAND
16  #define WM_APPCOMMAND                   0x0319
17  #define APPCOMMAND_BROWSER_BACKWARD       1
18  #define APPCOMMAND_BROWSER_FORWARD        2
19  #define FAPPCOMMAND_MASK  0xF000
20  #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
21  #endif 
22  class NppParameters;
23  #define NB_WORD_LIST 4
24  #define WORD_LIST_LEN 256
25  typedef sptr_t(*SCINTILLA_FUNC) (void *, unsigned int, uptr_t, sptr_t);
26  typedef void * SCINTILLA_PTR;
27  #define WM_DOCK_USERDEFINE_DLG      (SCINTILLA_USER + 1)
28  #define WM_UNDOCK_USERDEFINE_DLG    (SCINTILLA_USER + 2)
29  #define WM_CLOSE_USERDEFINE_DLG     (SCINTILLA_USER + 3)
30  #define WM_REMOVE_USERLANG          (SCINTILLA_USER + 4)
31  #define WM_RENAME_USERLANG          (SCINTILLA_USER + 5)
32  #define WM_REPLACEALL_INOPENEDDOC   (SCINTILLA_USER + 6)
33  #define WM_FINDALL_INOPENEDDOC      (SCINTILLA_USER + 7)
34  #define WM_DOOPEN                   (SCINTILLA_USER + 8)
35  #define WM_FINDINFILES              (SCINTILLA_USER + 9)
36  #define WM_REPLACEINFILES           (SCINTILLA_USER + 10)
37  #define WM_FINDALL_INCURRENTDOC     (SCINTILLA_USER + 11)
38  #define WM_FRSAVE_INT               (SCINTILLA_USER + 12)
39  #define WM_FRSAVE_STR               (SCINTILLA_USER + 13)
40  #define WM_FINDALL_INCURRENTFINDER  (SCINTILLA_USER + 14)
41  #define WM_FINDINPROJECTS           (SCINTILLA_USER + 15)
42  #define WM_REPLACEINPROJECTS        (SCINTILLA_USER + 16)
43  const int NB_FOLDER_STATE = 7;
44  const int CP_CHINESE_TRADITIONAL = 950;
45  const int CP_CHINESE_SIMPLIFIED = 936;
46  const int CP_JAPANESE = 932;
47  const int CP_KOREAN = 949;
48  const int CP_GREEK = 1253;
49  #define LIST_NONE 0
50  #define LIST_0 1
51  #define LIST_1 2
52  #define LIST_2 4
53  #define LIST_3 8
54  #define LIST_4 16
55  #define LIST_5 32
56  #define LIST_6 64
57  #define LIST_7 128
58  #define LIST_8 256
59  const bool fold_uncollapse = true;
60  const bool fold_collapse = false;
61  #define MAX_FOLD_COLLAPSE_LEVEL	8
62  enum TextCase : UCHAR
63  {
64  	UPPERCASE,
65  	LOWERCASE,
66  	TITLECASE_FORCE,
67  	TITLECASE_BLEND,
68  	SENTENCECASE_FORCE,
69  	SENTENCECASE_BLEND,
70  	INVERTCASE,
71  	RANDOMCASE
72  };
73  const UCHAR MASK_FORMAT = 0x03;
74  const UCHAR BASE_10 = 0x00; 
75  const UCHAR BASE_16 = 0x01; 
76  const UCHAR BASE_08 = 0x02; 
77  const UCHAR BASE_02 = 0x03; 
78  const int MARK_BOOKMARK = 20;
79  const int MARK_HIDELINESBEGIN = 19;
80  const int MARK_HIDELINESEND = 18;
81  constexpr char g_ZWSP[] = "\xE2\x80\x8B";
82  const std::vector<std::vector<const char*>> g_ccUniEolChars =
83  {
84  	{"\x00", "NUL", "U+0000"},               
85  	{"\x01", "SOH", "U+0001"},               
86  	{"\x02", "STX", "U+0002"},               
87  	{"\x03", "ETX", "U+0003"},               
88  	{"\x04", "EOT", "U+0004"},               
89  	{"\x05", "ENQ", "U+0005"},               
90  	{"\x06", "ACK", "U+0006"},               
91  	{"\a", "BEL", "U+0007"},                 
92  	{"\b", "BS", "U+0008"},                  
93  	{"\v", "VT", "U+000B"},                  
94  	{"\f", "FF", "U+000C"},                  
95  	{"\x0E", "SO", "U+000E"},                
96  	{"\x0F", "SI", "U+000F"},                
97  	{"\x10", "DLE", "U+0010"},               
98  	{"\x11", "DC1", "U+0011"},               
99  	{"\x12", "DC2", "U+0012"},               
100  	{"\x13", "DC3", "U+0013"},               
101  	{"\x14", "DC4", "U+0014"},               
102  	{"\x15", "NAK", "U+0015"},               
103  	{"\x16", "SYN", "U+0016"},               
104  	{"\x17", "ETB", "U+0017"},               
105  	{"\x18", "CAN", "U+0018"},               
106  	{"\x19", "EM", "U+0019"},                
107  	{"\x1A", "SUB", "U+001A"},               
108  	{"\x1B", "ESC", "U+001B"},               
109  	{"\x1C", "FS", "U+001C"},                
110  	{"\x1D", "GS", "U+001D"},                
111  	{"\x1E", "RS", "U+001E"},                
112  	{"\x1F", "US", "U+001F"},                
113  	{"\x7F", "DEL", "U+007F"},               
114  	{"\xC2\x80", "PAD", "U+0080"},           
115  	{"\xC2\x81", "HOP", "U+0081"},           
116  	{"\xC2\x82", "BPH", "U+0082"},           
117  	{"\xC2\x83", "NBH", "U+0083"},           
118  	{"\xC2\x84", "IND", "U+0084"},           
119  	{"\xC2\x86", "SSA", "U+0086"},           
120  	{"\xC2\x87", "ESA", "U+0087"},           
121  	{"\xC2\x88", "HTS", "U+0088"},           
122  	{"\xC2\x89", "HTJ", "U+0089"},           
123  	{"\xC2\x8A", "LTS", "U+008A"},           
124  	{"\xC2\x8B", "PLD", "U+008B"},           
125  	{"\xC2\x8C", "PLU", "U+008C"},           
126  	{"\xC2\x8D", "RI", "U+008D"},            
127  	{"\xC2\x8E", "SS2", "U+008E"},           
128  	{"\xC2\x8F", "SS3", "U+008F"},           
129  	{"\xC2\x90", "DCS", "U+0090"},           
130  	{"\xC2\x91", "PU1", "U+0091"},           
131  	{"\xC2\x92", "PU2", "U+0092"},           
132  	{"\xC2\x93", "STS", "U+0093"},           
133  	{"\xC2\x94", "CCH", "U+0094"},           
134  	{"\xC2\x95", "MW", "U+0095"},            
135  	{"\xC2\x96", "SPA", "U+0096"},           
136  	{"\xC2\x97", "EPA", "U+0097"},           
137  	{"\xC2\x98", "SOS", "U+0098"},           
138  	{"\xC2\x99", "SGCI", "U+0099"},          
139  	{"\xC2\x9A", "SCI", "U+009A"},           
140  	{"\xC2\x9B", "CSI", "U+009B"},           
141  	{"\xC2\x9C", "ST", "U+009C"},            
142  	{"\xC2\x9D", "OSC", "U+009D"},           
143  	{"\xC2\x9E", "PM", "U+009E"},            
144  	{"\xC2\x9F", "APC", "U+009F"},           
145  	{"\xC2\x85", "NEL", "U+0085"},           
146  	{"\xE2\x80\xA8", "LS", "U+2028"},        
147  	{"\xE2\x80\xA9", "PS", "U+2029"}         
148  };
149  const std::vector<std::vector<const char*>> g_nonPrintingChars =
150  {
151  	{"\xC2\xA0", "NBSP", "U+00A0"},          
152  	{"\xC2\xAD", "SHY", "U+00AD"},           
153  	{"\xD8\x9C", "ALM", "U+061C"},           
154  	{"\xDC\x8F", "SAM", "U+070F"},           
155  	{"\xE1\x9A\x80", "OSPM", "U+1680"},      
156  	{"\xE1\xA0\x8E", "MVS", "U+180E"},       
157  	{"\xE2\x80\x80", "NQSP", "U+2000"},      
158  	{"\xE2\x80\x81", "MQSP", "U+2001"},      
159  	{"\xE2\x80\x82", "ENSP", "U+2002"},      
160  	{"\xE2\x80\x83", "EMSP", "U+2003"},      
161  	{"\xE2\x80\x84", "3/MSP", "U+2004"},     
162  	{"\xE2\x80\x85", "4/MSP", "U+2005"},     
163  	{"\xE2\x80\x86", "6/MSP", "U+2006"},     
164  	{"\xE2\x80\x87", "FSP", "U+2007"},       
165  	{"\xE2\x80\x88", "PSP", "U+2008"},       
166  	{"\xE2\x80\x89", "THSP", "U+2009"},      
167  	{"\xE2\x80\x8A", "HSP", "U+200A"},       
168  	{"\xE2\x80\x8B", "ZWSP", "U+200B"},      
169  	{"\xE2\x80\x8C", "ZWNJ", "U+200C"},      
170  	{"\xE2\x80\x8D", "ZWJ", "U+200D"},       
171  	{"\xE2\x80\x8E", "LRM", "U+200E"},       
172  	{"\xE2\x80\x8F", "RLM", "U+200F"},       
173  	{"\xE2\x80\xAA", "LRE", "U+202A"},       
174  	{"\xE2\x80\xAB", "RLE", "U+202B"},       
175  	{"\xE2\x80\xAC", "PDF", "U+202C"},       
176  	{"\xE2\x80\xAD", "LRO", "U+202D"},       
177  	{"\xE2\x80\xAE", "RLO", "U+202E"},       
178  	{"\xE2\x80\xAF", "NNBSP", "U+202F"},     
179  	{"\xE2\x81\x9F", "MMSP", "U+205F"},      
180  	{"\xE2\x81\xA0", "WJ", "U+2060"},        
181  	{"\xE2\x81\xA1", "(FA)", "U+2061"},      
182  	{"\xE2\x81\xA2", "(IT)", "U+2062"},      
183  	{"\xE2\x81\xA3", "(IS)", "U+2063"},      
184  	{"\xE2\x81\xA4", "(IP)", "U+2064"},      
185  	{"\xE2\x81\xA6", "LRI", "U+2066"},       
186  	{"\xE2\x81\xA7", "RLI", "U+2067"},       
187  	{"\xE2\x81\xA8", "FSI", "U+2068"},       
188  	{"\xE2\x81\xA9", "PDI", "U+2069"},       
189  	{"\xE2\x81\xAA", "ISS", "U+206A"},       
190  	{"\xE2\x81\xAB", "ASS", "U+206B"},       
191  	{"\xE2\x81\xAC", "IAFS", "U+206C"},      
192  	{"\xE2\x81\xAD", "AAFS", "U+206D"},      
193  	{"\xE2\x81\xAE", "NADS", "U+206E"},      
194  	{"\xE2\x81\xAF", "NODS", "U+206F"},      
195  	{"\xE3\x80\x80", "IDSP", "U+3000"},      
196  	{"\xEF\xBB\xBF", "ZWNBSP", "U+FEFF"},    
197  	{"\xEF\xBF\xB9", "IAA", "U+FFF9"},       
198  	{"\xEF\xBF\xBA", "IAS", "U+FFFA"},       
199  	{"\xEF\xBF\xBB", "IAT", "U+FFFB"}        
200  };
201  int getNbDigits(int aNum, int base);
202  TCHAR* int2str(TCHAR* str, int strLen, int number, int base, int nbDigits, ColumnEditorParam::leadingChoice lead);
203  typedef LRESULT (WINAPI *CallWindowProcFunc) (WNDPROC,HWND,UINT,WPARAM,LPARAM);
204  const bool L2R = true;
205  const bool R2L = false;
206  struct ColumnModeInfo {
207  	intptr_t _selLpos = 0;
208  	intptr_t _selRpos = 0;
209  	intptr_t _order = -1; 
210  	bool _direction = L2R; 
211  	intptr_t _nbVirtualAnchorSpc = 0;
212  	intptr_t _nbVirtualCaretSpc = 0;
213  	ColumnModeInfo(intptr_t lPos, intptr_t rPos, intptr_t order, bool dir = L2R, intptr_t vAnchorNbSpc = 0, intptr_t vCaretNbSpc = 0)
214  		: _selLpos(lPos), _selRpos(rPos), _order(order), _direction(dir), _nbVirtualAnchorSpc(vAnchorNbSpc), _nbVirtualCaretSpc(vCaretNbSpc){};
215  	bool isValid() const {
216  		return (_order >= 0 && _selLpos >= 0 && _selRpos >= 0 && _selLpos <= _selRpos);
217  	};
218  };
219  struct SortInSelectOrder {
220  	bool operator() (ColumnModeInfo & l, ColumnModeInfo & r) {
221  		return (l._order < r._order);
222  	}
223  };
224  struct SortInPositionOrder {
225  	bool operator() (ColumnModeInfo & l, ColumnModeInfo & r) {
226  		return (l._selLpos < r._selLpos);
227  	}
228  };
229  typedef std::vector<ColumnModeInfo> ColumnModeInfos;
230  struct LanguageNameInfo {
231  	const TCHAR* _langName = nullptr;
232  	const TCHAR* _shortName = nullptr;
233  	const TCHAR* _longName = nullptr;
234  	LangType _langID = L_TEXT;
235  	const char* _lexerID = nullptr;
236  };
237  #define URL_INDIC 8
238  class ISorter;
239  class ScintillaEditView : public Window
240  {
241  friend class Finder;
242  public:
243  	ScintillaEditView(): Window() {
244  		++_refCount;
245  	};
246  	virtual ~ScintillaEditView()
247  	{
248  		--_refCount;
249  		if ((!_refCount)&&(_SciInit))
250  		{
251  			Scintilla_ReleaseResources();
252  			for (BufferStyleMap::iterator it(_hotspotStyles.begin()); it != _hotspotStyles.end(); ++it )
253  			{
254  				delete it->second;
255  			}
256  		}
257  	};
258  	virtual void destroy()
259  	{
260  		::DestroyWindow(_hSelf);
261  		_hSelf = NULL;
262  		_pScintillaFunc = NULL;
263  	};
264  	virtual void init(HINSTANCE hInst, HWND hPere);
265  	LRESULT execute(UINT Msg, WPARAM wParam=0, LPARAM lParam=0) const {
266  		try {
267  			return (_pScintillaFunc) ? _pScintillaFunc(_pScintillaPtr, Msg, wParam, lParam) : -1;
268  		}
269  		catch (...)
270  		{
271  			return -1;
272  		}
273  	};
274  	void activateBuffer(BufferID buffer, bool force = false);
275  	void getCurrentFoldStates(std::vector<size_t> & lineStateVector);
276  	void syncFoldStateWith(const std::vector<size_t> & lineStateVectorNew);
277  	void getText(char *dest, size_t start, size_t end) const;
278  	void getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end) const;
279  	void getGenericText(TCHAR *dest, size_t deslen, size_t start, size_t end, intptr_t* mstart, intptr_t* mend) const;
280  	generic_string getGenericTextAsString(size_t start, size_t end) const;
281  	void insertGenericTextFrom(size_t position, const TCHAR *text2insert) const;
282  	void replaceSelWith(const char * replaceText);
283  	intptr_t getSelectedTextCount() {
284  		Sci_CharacterRangeFull range = getSelection();
285  		return (range.cpMax - range.cpMin);
286  	};
287  	void getVisibleStartAndEndPosition(intptr_t* startPos, intptr_t* endPos);
288      char * getWordFromRange(char * txt, size_t size, size_t pos1, size_t pos2);
289  	char * getSelectedText(char * txt, size_t size, bool expand = true);
290      char * getWordOnCaretPos(char * txt, size_t size);
291      TCHAR * getGenericWordOnCaretPos(TCHAR * txt, int size);
292  	TCHAR * getGenericSelectedText(TCHAR * txt, int size, bool expand = true);
293  	intptr_t searchInTarget(const TCHAR * Text2Find, size_t lenOfText2Find, size_t fromPos, size_t toPos) const;
294  	void appandGenericText(const TCHAR * text2Append) const;
295  	void addGenericText(const TCHAR * text2Append) const;
296  	void addGenericText(const TCHAR * text2Append, intptr_t* mstart, intptr_t* mend) const;
297  	intptr_t replaceTarget(const TCHAR * str2replace, intptr_t fromTargetPos = -1, intptr_t toTargetPos = -1) const;
298  	intptr_t replaceTargetRegExMode(const TCHAR * re, intptr_t fromTargetPos = -1, intptr_t toTargetPos = -1) const;
299  	void showAutoComletion(size_t lenEntered, const TCHAR * list);
300  	void showCallTip(size_t startPos, const TCHAR * def);
301  	generic_string getLine(size_t lineNumber);
302  	void getLine(size_t lineNumber, TCHAR * line, size_t lineBufferLen);
303  	void addText(size_t length, const char *buf);
304  	void insertNewLineAboveCurrentLine();
305  	void insertNewLineBelowCurrentLine();
306  	void saveCurrentPos();
307  	void restoreCurrentPosPreStep();
308  	void restoreCurrentPosPostStep();
309  	void beginOrEndSelect(bool isColumnMode);
310  	bool beginEndSelectedIsStarted() const {
311  		return _beginSelectPosition != -1;
312  	};
313  	size_t getCurrentDocLen() const {
314  		return size_t(execute(SCI_GETLENGTH));
315  	};
316  	Sci_CharacterRangeFull getSelection() const {
317  		Sci_CharacterRangeFull crange{};
318  		crange.cpMin = execute(SCI_GETSELECTIONSTART);
319  		crange.cpMax = execute(SCI_GETSELECTIONEND);
320  		return crange;
321  	};
322  	void getWordToCurrentPos(TCHAR * str, intptr_t strLen) const {
323  		auto caretPos = execute(SCI_GETCURRENTPOS);
324  		auto startPos = execute(SCI_WORDSTARTPOSITION, caretPos, true);
325  		str[0] = '\0';
326  		if ((caretPos - startPos) < strLen)
327  			getGenericText(str, strLen, startPos, caretPos);
328  	};
329      void doUserDefineDlg(bool willBeShown = true, bool isRTL = false) {
330          _userDefineDlg.doDialog(willBeShown, isRTL);
331      };
332      static UserDefineDialog * getUserDefineDlg() {return &_userDefineDlg;};
333      void setCaretColorWidth(int color, int width = 1) const {
334          execute(SCI_SETCARETFORE, color);
335          execute(SCI_SETCARETWIDTH, width);
336      };
337  	void beSwitched() {
338  		_userDefineDlg.setScintilla(this);
339  	};
340      static const int _SC_MARGE_LINENUMBER;
341      static const int _SC_MARGE_SYMBOL;
342      static const int _SC_MARGE_FOLDER;
343      static const int _SC_MARGE_CHANGEHISTORY;
344      void showMargin(int whichMarge, bool willBeShowed = true);
345      void showChangeHistoryMargin(bool willBeShowed = true);
346      bool hasMarginShowed(int witchMarge) {
347  		return (execute(SCI_GETMARGINWIDTHN, witchMarge, 0) != 0);
348      };
349      void updateBeginEndSelectPosition(bool is_insert, size_t position, size_t length);
350      void marginClick(Sci_Position position, int modifiers);
351      void setMakerStyle(folderStyle style) {
352  		bool display;
353  		if (style == FOLDER_STYLE_NONE)
354  		{
355  			style = FOLDER_STYLE_BOX;
356  			display = false;
357  		}
358  		else
359  		{
360  			display = true;
361  		}
362  		COLORREF foldfgColor = white, foldbgColor = grey, activeFoldFgColor = red;
363  		getFoldColor(foldfgColor, foldbgColor, activeFoldFgColor);
364  		for (int i = 0 ; i < NB_FOLDER_STATE ; ++i)
365  			defineMarker(_markersArray[FOLDER_TYPE][i], _markersArray[style][i], foldfgColor, foldbgColor, activeFoldFgColor);
366  		showMargin(ScintillaEditView::_SC_MARGE_FOLDER, display);
367      };
368  	void setWrapMode(lineWrapMethod meth) {
369  		int mode = (meth == LINEWRAP_ALIGNED)?SC_WRAPINDENT_SAME:\
370  				(meth == LINEWRAP_INDENT)?SC_WRAPINDENT_INDENT:SC_WRAPINDENT_FIXED;
371  		execute(SCI_SETWRAPINDENTMODE, mode);
372  	};
373  	void showWSAndTab(bool willBeShowed = true) {
374  		execute(SCI_SETVIEWWS, willBeShowed?SCWS_VISIBLEALWAYS:SCWS_INVISIBLE);
375  		execute(SCI_SETWHITESPACESIZE, 2, 0);
376  	};
377  	bool isShownSpaceAndTab() {
378  		return (execute(SCI_GETVIEWWS) != 0);
379  	};
380  	void showEOL(bool willBeShowed = true) {
381  		execute(SCI_SETVIEWEOL, willBeShowed);
382  	};
383  	bool isShownEol() {
384  		return (execute(SCI_GETVIEWEOL) != 0);
385  	};
386  	void showNpc(bool willBeShowed = true, bool isSearchResult = false);
387  	bool isShownNpc() {
388  		auto& svp = NppParameters::getInstance().getSVP();
389  		return svp._npcShow;
390  	};
391  	void maintainStateForNpc() {
392  		const auto& svp = NppParameters::getInstance().getSVP();
393  		const bool isShownNpc = svp._npcShow;
394  		const bool isNpcIncCcUniEol = svp._npcIncludeCcUniEol;
395  		const bool isShownCcUniEol = svp._ccUniEolShow;
396  		if (isShownNpc || isNpcIncCcUniEol)
397  		{
398  			showNpc(isShownNpc);
399  		}
400  		showCcUniEol(isShownCcUniEol);
401  	}
402  	void showCcUniEol(bool willBeShowed = true, bool isSearchResult = false);
403  	bool isShownCcUniEol() {
404  		auto& svp = NppParameters::getInstance().getSVP();
405  		return svp._ccUniEolShow;
406  	};
407  	void showInvisibleChars(bool willBeShowed = true) {
408  		showNpc(willBeShowed);
409  		showCcUniEol(willBeShowed);
410  		showWSAndTab(willBeShowed);
411  		showEOL(willBeShowed);
412  	};
413  	void showIndentGuideLine(bool willBeShowed = true);
414  	bool isShownIndentGuide() const {
415  		return (execute(SCI_GETINDENTATIONGUIDES) != 0);
416  	};
417      void wrap(bool willBeWrapped = true) {
418          execute(SCI_SETWRAPMODE, willBeWrapped);
419      };
420      bool isWrap() const {
421          return (execute(SCI_GETWRAPMODE) == SC_WRAP_WORD);
422      };
423  	bool isWrapSymbolVisible() const {
424  		return (execute(SCI_GETWRAPVISUALFLAGS) != SC_WRAPVISUALFLAG_NONE);
425  	};
426      void showWrapSymbol(bool willBeShown = true) {
427  		execute(SCI_SETWRAPVISUALFLAGSLOCATION, SC_WRAPVISUALFLAGLOC_DEFAULT);
428  		execute(SCI_SETWRAPVISUALFLAGS, willBeShown?SC_WRAPVISUALFLAG_END:SC_WRAPVISUALFLAG_NONE);
429      };
430  	intptr_t getCurrentLineNumber()const {
431  		return execute(SCI_LINEFROMPOSITION, execute(SCI_GETCURRENTPOS));
432  	};
433  	intptr_t lastZeroBasedLineNumber() const {
434  		auto endPos = execute(SCI_GETLENGTH);
435  		return execute(SCI_LINEFROMPOSITION, endPos);
436  	};
437  	intptr_t getCurrentXOffset()const{
438  		return execute(SCI_GETXOFFSET);
439  	};
440  	void setCurrentXOffset(long xOffset){
441  		execute(SCI_SETXOFFSET,xOffset);
442  	};
443  	void scroll(intptr_t column, intptr_t line){
444  		execute(SCI_LINESCROLL, column, line);
445  	};
446  	intptr_t getCurrentPointX()const{
447  		return execute(SCI_POINTXFROMPOSITION, 0, execute(SCI_GETCURRENTPOS));
448  	};
449  	intptr_t getCurrentPointY()const{
450  		return execute(SCI_POINTYFROMPOSITION, 0, execute(SCI_GETCURRENTPOS));
451  	};
452  	intptr_t getTextHeight()const{
453  		return execute(SCI_TEXTHEIGHT);
454  	};
455  	int getTextZoneWidth() const;
456  	void gotoLine(intptr_t line){
457  		if (line < execute(SCI_GETLINECOUNT))
458  			execute(SCI_GOTOLINE,line);
459  	};
460  	intptr_t getCurrentColumnNumber() const {
461          return execute(SCI_GETCOLUMN, execute(SCI_GETCURRENTPOS));
462      };
463  	std::pair<size_t, size_t> getSelectedCharsAndLinesCount(long long maxSelectionsForLineCount = -1) const;
464  	size_t getUnicodeSelectedLength() const;
465  	intptr_t getLineLength(size_t line) const {
466  		return execute(SCI_GETLINEENDPOSITION, line) - execute(SCI_POSITIONFROMLINE, line);
467  	};
468  	intptr_t getLineIndent(size_t line) const {
469  		return execute(SCI_GETLINEINDENTATION, line);
470  	};
471  	void setLineIndent(size_t line, size_t indent) const;
472  	void updateLineNumbersMargin(bool forcedToHide) {
473  		const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
474  		if (forcedToHide)
475  		{
476  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, 0);
477  		}
478  		else if (svp._lineNumberMarginShow)
479  		{
480  			updateLineNumberWidth();
481  		}
482  		else
483  		{
484  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, 0);
485  		}
486  	}
487  	void updateLineNumberWidth();
488  	void performGlobalStyles();
489  	void expand(size_t& line, bool doExpand, bool force = false, intptr_t visLevels = 0, intptr_t level = -1);
490  	std::pair<size_t, size_t> getSelectionLinesRange(intptr_t selectionNumber = -1) const;
491      void currentLinesUp() const;
492      void currentLinesDown() const;
493  	intptr_t caseConvertRange(intptr_t start, intptr_t end, TextCase caseToConvert);
494  	void changeCase(__inout wchar_t * const strWToConvert, const int & nbChars, const TextCase & caseToConvert) const;
495  	void convertSelectedTextTo(const TextCase & caseToConvert);
496  	void setMultiSelections(const ColumnModeInfos & cmi);
497      void convertSelectedTextToLowerCase() {
498  		if ((NppParameters::getInstance()).isTransparentAvailable())
499  			convertSelectedTextTo(LOWERCASE);
500  		else
501  			execute(SCI_LOWERCASE);
502  	};
503      void convertSelectedTextToUpperCase() {
504  		if ((NppParameters::getInstance()).isTransparentAvailable())
505  			convertSelectedTextTo(UPPERCASE);
506  		else
507  			execute(SCI_UPPERCASE);
508  	};
509  	void convertSelectedTextToNewerCase(const TextCase & caseToConvert) {
510  		if ((NppParameters::getInstance()).isTransparentAvailable())
511  			convertSelectedTextTo(caseToConvert);
512  		else
513  			::MessageBox(_hSelf, TEXT("This function needs a newer OS version."), TEXT("Change Case Error"), MB_OK | MB_ICONHAND);
514  	};
515  	bool isFoldIndentationBased() const;
516  	void collapseFoldIndentationBased(int level2Collapse, bool mode);
517  	void collapse(int level2Collapse, bool mode);
518  	void foldAll(bool mode);
519  	void fold(size_t line, bool mode);
520  	bool isFolded(size_t line) const {
521  		return (execute(SCI_GETFOLDEXPANDED, line) != 0);
522  	};
523  	bool isCurrentLineFolded() const;
524  	void foldCurrentPos(bool mode);
525  	int getCodepage() const {return _codepage;};
526  	ColumnModeInfos getColumnModeSelectInfo();
527  	void columnReplace(ColumnModeInfos & cmi, const TCHAR *str);
528  	void columnReplace(ColumnModeInfos & cmi, int initial, int incr, int repeat, UCHAR format, ColumnEditorParam::leadingChoice lead);
529  	void clearIndicator(int indicatorNumber) {
530  		size_t docStart = 0;
531  		size_t docEnd = getCurrentDocLen();
532  		execute(SCI_SETINDICATORCURRENT, indicatorNumber);
533  		execute(SCI_INDICATORCLEARRANGE, docStart, docEnd - docStart);
534  	};
535  	bool getIndicatorRange(size_t indicatorNumber, size_t* from = NULL, size_t* to = NULL, size_t* cur = NULL);
536  	static LanguageNameInfo _langNameInfoArray[L_EXTERNAL+1];
537  	void bufferUpdated(Buffer * buffer, int mask);
538  	BufferID getCurrentBufferID() { return _currentBufferID; };
539  	Buffer * getCurrentBuffer() { return _currentBuffer; };
540  	void setCurrentBuffer(Buffer *buf2set) { _currentBuffer = buf2set; };
541  	void styleChange();
542  	void hideLines();
543  	bool markerMarginClick(intptr_t lineNumber);	
544  	void notifyMarkers(Buffer * buf, bool isHide, size_t location, bool del);
545  	void runMarkers(bool doHide, size_t searchStart, bool endOfDoc, bool doDelete);
546  	bool isSelecting() const {
547  		static Sci_CharacterRangeFull previousSelRange = getSelection();
548  		Sci_CharacterRangeFull currentSelRange = getSelection();
549  		if (currentSelRange.cpMin == currentSelRange.cpMax)
550  		{
551  			previousSelRange = currentSelRange;
552  			return false;
553  		}
554  		if ((previousSelRange.cpMin == currentSelRange.cpMin) || (previousSelRange.cpMax == currentSelRange.cpMax))
555  		{
556  			previousSelRange = currentSelRange;
557  			return true;
558  		}
559  		previousSelRange = currentSelRange;
560  		return false;
561  	};
562  	bool isPythonStyleIndentation(LangType typeDoc) const{
563  		return (typeDoc == L_PYTHON || typeDoc == L_COFFEESCRIPT || typeDoc == L_HASKELL ||\
564  			typeDoc == L_C || typeDoc == L_CPP || typeDoc == L_OBJC || typeDoc == L_CS || typeDoc == L_JAVA ||\
565  			typeDoc == L_PHP || typeDoc == L_JS || typeDoc == L_JAVASCRIPT || typeDoc == L_MAKEFILE ||\
566  			typeDoc == L_ASN1 || typeDoc == L_GDSCRIPT);
567  	};
568  	void defineDocType(LangType typeDoc);	
569  	void addCustomWordChars();
570  	void restoreDefaultWordChars();
571  	void setWordChars();
572  	void setCRLF(long color = -1);
573  	void setNpcAndCcUniEOL(long color = -1);
574  	void mouseWheel(WPARAM wParam, LPARAM lParam) {
575  		scintillaNew_Proc(_hSelf, WM_MOUSEWHEEL, wParam, lParam);
576  	};
577  	void setHotspotStyle(const Style& styleToSet);
578      void setTabSettings(Lang *lang);
579  	bool isWrapRestoreNeeded() const {return _wrapRestoreNeeded;};
580  	void setWrapRestoreNeeded(bool isWrapRestoredNeeded) {_wrapRestoreNeeded = isWrapRestoredNeeded;};
581  	bool isCJK() const {
582  		return ((_codepage == CP_CHINESE_TRADITIONAL) || (_codepage == CP_CHINESE_SIMPLIFIED) ||
583  			    (_codepage == CP_JAPANESE) || (_codepage == CP_KOREAN));
584  	};
585  	void scrollPosToCenter(size_t pos);
586  	generic_string getEOLString();
587  	void setBorderEdge(bool doWithBorderEdge);
588  	void sortLines(size_t fromLine, size_t toLine, ISorter *pSort);
589  	void changeTextDirection(bool isRTL);
590  	bool isTextDirectionRTL() const;
591  	void setPositionRestoreNeeded(bool val) { _positionRestoreNeeded = val; };
592  	void markedTextToClipboard(int indiStyle, bool doAll = false);
593  	void removeAnyDuplicateLines();
594  protected:
595  	static bool _SciInit;
596  	static int _refCount;
597      static UserDefineDialog _userDefineDlg;
598      static const int _markersArray[][NB_FOLDER_STATE];
599  	static LRESULT CALLBACK scintillaStatic_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
600  	LRESULT scintillaNew_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
601  	SCINTILLA_FUNC _pScintillaFunc = nullptr;
602  	SCINTILLA_PTR  _pScintillaPtr = nullptr;
603  	static WNDPROC _scintillaDefaultProc;
604  	CallWindowProcFunc _callWindowProc = nullptr;
605  	BufferID attachDefaultDoc();
606  	BufferID _currentBufferID = nullptr;
607  	Buffer * _currentBuffer = nullptr;
608  	int _codepage = CP_ACP;
609  	bool _wrapRestoreNeeded = false;
610  	bool _positionRestoreNeeded = false;
611  	uint32_t _restorePositionRetryCount = 0;
612  	typedef std::unordered_map<int, Style> StyleMap;
613  	typedef std::unordered_map<BufferID, StyleMap*> BufferStyleMap;
614  	BufferStyleMap _hotspotStyles;
615  	intptr_t _beginSelectPosition = -1;
616  	static std::string _defaultCharList;
617  	void restyleBuffer();
618  	const char * getCompleteKeywordList(std::basic_string<char> & kwl, LangType langType, int keywordIndex);
619  	void setKeywords(LangType langType, const char *keywords, int index);
620  	void setLexer(LangType langID, int whichList);
621  	bool setLexerFromLangID(int langID);
622  	void makeStyle(LangType langType, const TCHAR **keywordArray = NULL);
623  	void setStyle(Style styleToSet);			
624  	void setSpecialStyle(const Style & styleToSet);	
625  	void setSpecialIndicator(const Style & styleToSet) {
626  		execute(SCI_INDICSETFORE, styleToSet._styleID, styleToSet._bgColor);
627  	};
628  	void setXmlLexer(LangType type);
629   	void setCppLexer(LangType type);
630  	void setJsLexer();
631  	void setTclLexer();
632      void setObjCLexer(LangType type);
633  	void setUserLexer(const TCHAR *userLangName = NULL);
634  	void setExternalLexer(LangType typeDoc);
635  	void setEmbeddedJSLexer();
636      void setEmbeddedPhpLexer();
637      void setEmbeddedAspLexer();
638  	void setJsonLexer(bool isJson5 = false);
639  	void setTypeScriptLexer();
640  	void setCssLexer() {
641  		setLexer(L_CSS, LIST_0 | LIST_1 | LIST_4 | LIST_6);
642  	};
643  	void setLuaLexer() {
644  		setLexer(L_LUA, LIST_0 | LIST_1 | LIST_2 | LIST_3);
645  	};
646  	void setMakefileLexer() {
647  		setLexer(L_MAKEFILE, LIST_NONE);
648  	};
649  	void setPropsLexer(bool isPropsButNotIni = true) {
650  		LangType L_id = isPropsButNotIni ? L_PROPS : L_INI;
651  		setLexer(L_id, LIST_NONE);
652  		execute(SCI_STYLESETEOLFILLED, SCE_PROPS_SECTION, true);
653  	};
654  	void setSqlLexer() {
655  		const bool kbBackSlash = NppParameters::getInstance().getNppGUI()._backSlashIsEscapeCharacterForSql;
656  		setLexer(L_SQL, LIST_0 | LIST_1 | LIST_4);
657  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("sql.backslash.escapes"), reinterpret_cast<LPARAM>(kbBackSlash ? "1" : "0"));
658  	};
659  	void setMSSqlLexer() {
660  		setLexer(L_MSSQL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
661  	};
662  	void setBashLexer() {
663  		setLexer(L_BASH, LIST_0);
664  	};
665  	void setVBLexer() {
666  		setLexer(L_VB, LIST_0);
667  	};
668  	void setPascalLexer() {
669  		setLexer(L_PASCAL, LIST_0);
670  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
671  	};
672  	void setPerlLexer() {
673  		setLexer(L_PERL, LIST_0);
674  	};
675  	void setPythonLexer() {
676  		setLexer(L_PYTHON, LIST_0 | LIST_1);
677  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.quotes.python"), reinterpret_cast<LPARAM>("1"));
678  	};
679  	void setGDScriptLexer() {
680  		setLexer(L_GDSCRIPT, LIST_0 | LIST_1);
681  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.gdscript.keywords2.no.sub.identifiers"), reinterpret_cast<LPARAM>("1"));
682  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.gdscript.whinge.level"), reinterpret_cast<LPARAM>("1"));
683  	};
684  	void setBatchLexer() {
685  		setLexer(L_BATCH, LIST_0);
686  	};
687  	void setTeXLexer() {
688  		for (int i = 0 ; i < 4 ; ++i)
689  			execute(SCI_SETKEYWORDS, i, reinterpret_cast<LPARAM>(TEXT("")));
690  		setLexer(L_TEX, LIST_NONE);
691  	};
692  	void setNsisLexer() {
693  		setLexer(L_NSIS, LIST_0 | LIST_1 | LIST_2 | LIST_3);
694  	};
695  	void setFortranLexer() {
696  		setLexer(L_FORTRAN, LIST_0 | LIST_1 | LIST_2);
697  	};
698  	void setFortran77Lexer() {
699  		setLexer(L_FORTRAN_77, LIST_0 | LIST_1 | LIST_2);
700  	};
701  	void setLispLexer(){
702  		setLexer(L_LISP, LIST_0 | LIST_1);
703  	};
704  	void setSchemeLexer(){
705  		setLexer(L_SCHEME, LIST_0 | LIST_1);
706  	};
707  	void setAsmLexer(){
708  		setLexer(L_ASM, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
709  	};
710  	void setDiffLexer(){
711  		setLexer(L_DIFF, LIST_NONE);
712  	};
713  	void setPostscriptLexer(){
714  		setLexer(L_PS, LIST_0 | LIST_1 | LIST_2 | LIST_3);
715  	};
716  	void setRubyLexer(){
717  		setLexer(L_RUBY, LIST_0);
718  		execute(SCI_STYLESETEOLFILLED, SCE_RB_POD, true);
719  	};
720  	void setSmalltalkLexer(){
721  		setLexer(L_SMALLTALK, LIST_0);
722  	};
723  	void setVhdlLexer(){
724  		setLexer(L_VHDL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
725  	};
726  	void setKixLexer(){
727  		setLexer(L_KIX, LIST_0 | LIST_1 | LIST_2);
728  	};
729  	void setAutoItLexer(){
730  		setLexer(L_AU3, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
731  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
732  	};
733  	void setCamlLexer(){
734  		setLexer(L_CAML, LIST_0 | LIST_1 | LIST_2);
735  	};
736  	void setAdaLexer(){
737  		setLexer(L_ADA, LIST_0);
738  	};
739  	void setVerilogLexer(){
740  		setLexer(L_VERILOG, LIST_0 | LIST_1);
741  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
742  	};
743  	void setMatlabLexer(){
744  		setLexer(L_MATLAB, LIST_0);
745  	};
746  	void setHaskellLexer(){
747  		setLexer(L_HASKELL, LIST_0);
748  	};
749  	void setInnoLexer() {
750  		setLexer(L_INNO, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
751  	};
752  	void setCmakeLexer() {
753  		setLexer(L_CMAKE, LIST_0 | LIST_1 | LIST_2);
754  	};
755  	void setYamlLexer() {
756  		setLexer(L_YAML, LIST_0);
757  	};
758      void setCobolLexer() {
759  		setLexer(L_COBOL, LIST_0 | LIST_1 | LIST_2);
760  	};
761      void setGui4CliLexer() {
762  		setLexer(L_GUI4CLI, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4);
763  	};
764      void setDLexer() {
765  		setLexer(L_D, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
766  	};
767      void setPowerShellLexer() {
768  		setLexer(L_POWERSHELL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
769  	};
770      void setRLexer() {
771  		setLexer(L_R, LIST_0 | LIST_1 | LIST_2);
772  	};
773      void setCoffeeScriptLexer() {
774  		setLexer(L_COFFEESCRIPT, LIST_0 | LIST_1 | LIST_2  | LIST_3);
775  	};
776  	void setBaanCLexer() {
777  		setLexer(L_BAANC, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6 | LIST_7 | LIST_8);
778  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.baan.styling.within.preprocessor"), reinterpret_cast<LPARAM>("1"));
779  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$:"));
780  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
781  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.syntax.based"), reinterpret_cast<LPARAM>("1"));
782  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.keywords.based"), reinterpret_cast<LPARAM>("1"));
783  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.sections"), reinterpret_cast<LPARAM>("1"));
784  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.inner.level"), reinterpret_cast<LPARAM>("1"));
785  		execute(SCI_STYLESETEOLFILLED, SCE_BAAN_STRINGEOL, true);
786  	};
787  	void setSrecLexer() {
788  		setLexer(L_SREC, LIST_NONE);
789  	};
790  	void setIHexLexer() {
791  		setLexer(L_IHEX, LIST_NONE);
792  	};
793  	void setTEHexLexer() {
794  		setLexer(L_TEHEX, LIST_NONE);
795  	};
796  	void setAsn1Lexer() {
797  		setLexer(L_ASN1, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
798  	};
799  	void setAVSLexer() {
800  		setLexer(L_AVS, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
801  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#"));
802  	};
803  	void setBlitzBasicLexer() {
804  		setLexer(L_BLITZBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
805  	};
806  	void setPureBasicLexer() {
807  		setLexer(L_PUREBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
808  	};
809  	void setFreeBasicLexer() {
810  		setLexer(L_FREEBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
811  	};
812  	void setCsoundLexer() {
813  		setLexer(L_CSOUND, LIST_0 | LIST_1 | LIST_2);
814  		execute(SCI_STYLESETEOLFILLED, SCE_CSOUND_STRINGEOL, true);
815  	};
816  	void setErlangLexer() {
817  		setLexer(L_ERLANG, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5); 
818  	};
819  	void setESCRIPTLexer() {
820  		setLexer(L_ESCRIPT, LIST_0 | LIST_1 | LIST_2); 
821  	};
822  	void setForthLexer() {
823  		setLexer(L_FORTH, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
824  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%-"));
825  	};
826  	void setLatexLexer() {
827  		setLexer(L_LATEX, LIST_NONE); 
828  	};
829  	void setMMIXALLexer() {
830  		setLexer(L_MMIXAL, LIST_0 | LIST_1 | LIST_2); 
831  	};
832  	void setNimrodLexer() {
833  		setLexer(L_NIM, LIST_0);
834  	};
835  	void setNncrontabLexer() {
836  		setLexer(L_NNCRONTAB, LIST_0 | LIST_1 | LIST_2); 
837  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%-"));
838  	};
839  	void setOScriptLexer() {
840  		setLexer(L_OSCRIPT, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
841  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$"));
842  	};
843  	void setREBOLLexer() {
844  		setLexer(L_REBOL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
845  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?!.'+-*&|=_~"));
846  	};
847  	void setRegistryLexer() {
848  		setLexer(L_REGISTRY, LIST_NONE); 
849  	};
850  	void setRustLexer() {
851  		setLexer(L_RUST, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6); 
852  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#"));
853  	};
854  	void setSpiceLexer() {
855  		setLexer(L_SPICE, LIST_0 | LIST_1 | LIST_2); 
856  	};
857  	void setTxt2tagsLexer() {
858  		setLexer(L_TXT2TAGS, LIST_NONE); 
859  	};
860  	void setVisualPrologLexer() {
861  		setLexer(L_VISUALPROLOG, LIST_0 | LIST_1 | LIST_2 | LIST_3);
862  	}
863  	void setHollywoodLexer() {
864  		setLexer(L_HOLLYWOOD, LIST_0 | LIST_1 | LIST_2 | LIST_3);
865  	};	
866  	void setSearchResultLexer() {
867  		if (execute(SCI_GETLEXER) == SCLEX_SEARCHRESULT)
868  		{
869  			makeStyle(L_SEARCHRESULT, nullptr);
870  			return;
871  		}
872  		execute(SCI_STYLESETEOLFILLED, SCE_SEARCHRESULT_FILE_HEADER, true);
873  		execute(SCI_STYLESETEOLFILLED, SCE_SEARCHRESULT_SEARCH_HEADER, true);
874  		setLexer(L_SEARCHRESULT, LIST_NONE);
875  	};
876  	bool isNeededFolderMarge(LangType typeDoc) const {
877  		switch (typeDoc)
878  		{
<span onclick='openModal()' class='match'>879  			case L_ASCII:
880  			case L_BATCH:
881  			case L_TEXT:
882  			case L_MAKEFILE:
883  			case L_ASM:
884  			case L_HASKELL:
885  			case L_SMALLTALK:
886  			case L_KIX:
887  			case L_ADA:
</span>888  				return false;
889  			default:
890  				return true;
891  		}
892  	};
893      void defineMarker(int marker, int markerType, COLORREF fore, COLORREF back, COLORREF foreActive) {
894  	    execute(SCI_MARKERDEFINE, marker, markerType);
895  	    execute(SCI_MARKERSETFORE, marker, fore);
896  	    execute(SCI_MARKERSETBACK, marker, back);
897  		execute(SCI_MARKERSETBACKSELECTED, marker, foreActive);
898  	};
899  	int codepage2CharSet() const {
900  		switch (_codepage)
901  		{
902  			case CP_CHINESE_TRADITIONAL : return SC_CHARSET_CHINESEBIG5;
903  			case CP_CHINESE_SIMPLIFIED : return SC_CHARSET_GB2312;
904  			case CP_KOREAN : return SC_CHARSET_HANGUL;
905  			case CP_JAPANESE : return SC_CHARSET_SHIFTJIS;
906  			case CP_GREEK : return SC_CHARSET_GREEK;
907  			default : return 0;
908  		}
909  	};
910  	std::pair<size_t, size_t> getWordRange();
911  	bool expandWordSelection();
912  	void getFoldColor(COLORREF& fgColor, COLORREF& bgColor, COLORREF& activeFgColor);
913  };
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_creator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_CREATOR_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_CREATOR_HPP
3  #ifdef BOOST_REGEX_MSVC
4  #  pragma warning(push)
5  #pragma warning(disable:4459)
6  #if BOOST_REGEX_MSVC < 1910
7  #pragma warning(disable:4800)
8  #endif
9  #endif
10  #include <set>
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template <class charT>
14  struct digraph : public std::pair<charT, charT>
15  {
16     digraph() : std::pair<charT, charT>(charT(0), charT(0)){}
17     digraph(charT c1) : std::pair<charT, charT>(c1, charT(0)){}
18     digraph(charT c1, charT c2) : std::pair<charT, charT>(c1, c2)
19     {}
20     digraph(const digraph<charT>& d) : std::pair<charT, charT>(d.first, d.second){}
21     digraph<charT>& operator=(const digraph<charT>&) = default;
22     template <class Seq>
23     digraph(const Seq& s) : std::pair<charT, charT>()
24     {
25        BOOST_REGEX_ASSERT(s.size() <= 2);
26        BOOST_REGEX_ASSERT(s.size());
27        this->first = s[0];
28        this->second = (s.size() > 1) ? s[1] : 0;
29     }
30  };
31  template <class charT, class traits>
32  class basic_char_set
33  {
34  public:
35     typedef digraph<charT>                   digraph_type;
36     typedef typename traits::string_type     string_type;
37     typedef typename traits::char_class_type m_type;
38     basic_char_set()
39     {
40        m_negate = false;
41        m_has_digraphs = false;
42        m_classes = 0;
43        m_negated_classes = 0;
44        m_empty = true;
45     }
46     void add_single(const digraph_type& s)
47     {
48        m_singles.insert(s);
49        if(s.second)
50           m_has_digraphs = true;
51        m_empty = false;
52     }
53     void add_range(const digraph_type& first, const digraph_type& end)
54     {
55        m_ranges.push_back(first);
56        m_ranges.push_back(end);
57        if(first.second)
58        {
59           m_has_digraphs = true;
60           add_single(first);
61        }
62        if(end.second)
63        {
64           m_has_digraphs = true;
65           add_single(end);
66        }
67        m_empty = false;
68     }
69     void add_class(m_type m)
70     {
71        m_classes |= m;
72        m_empty = false;
73     }
74     void add_negated_class(m_type m)
75     {
76        m_negated_classes |= m;
77        m_empty = false;
78     }
79     void add_equivalent(const digraph_type& s)
80     {
81        m_equivalents.insert(s);
82        if(s.second)
83        {
84           m_has_digraphs = true;
85           add_single(s);
86        }
87        m_empty = false;
88     }
89     void negate()
90     { 
91        m_negate = true;
92     }
93     bool has_digraphs()const
94     {
95        return m_has_digraphs;
96     }
97     bool is_negated()const
98     {
99        return m_negate;
100     }
101     typedef typename std::vector<digraph_type>::const_iterator  list_iterator;
102     typedef typename std::set<digraph_type>::const_iterator     set_iterator;
103     set_iterator singles_begin()const
104     {
105        return m_singles.begin();
106     }
107     set_iterator singles_end()const
108     {
109        return m_singles.end();
110     }
111     list_iterator ranges_begin()const
112     {
113        return m_ranges.begin();
114     }
115     list_iterator ranges_end()const
116     {
117        return m_ranges.end();
118     }
119     set_iterator equivalents_begin()const
120     {
121        return m_equivalents.begin();
122     }
123     set_iterator equivalents_end()const
124     {
125        return m_equivalents.end();
126     }
127     m_type classes()const
128     {
129        return m_classes;
130     }
131     m_type negated_classes()const
132     {
133        return m_negated_classes;
134     }
135     bool empty()const
136     {
137        return m_empty;
138     }
139  private:
140     std::set<digraph_type>    m_singles;         
141     std::vector<digraph_type> m_ranges;          
142     bool                      m_negate;          
143     bool                      m_has_digraphs;    
144     m_type                    m_classes;         
145     m_type                    m_negated_classes; 
146     bool                      m_empty;           
147     std::set<digraph_type>    m_equivalents;     
148  };
149  template <class charT, class traits>
150  class basic_regex_creator
151  {
152  public:
153     basic_regex_creator(regex_data<charT, traits>* data);
154     std::ptrdiff_t getoffset(void* addr)
155     {
156        return getoffset(addr, m_pdata->m_data.data());
157     }
158     std::ptrdiff_t getoffset(const void* addr, const void* base)
159     {
160        return static_cast<const char*>(addr) - static_cast<const char*>(base);
161     }
162     re_syntax_base* getaddress(std::ptrdiff_t off)
163     {
164        return getaddress(off, m_pdata->m_data.data());
165     }
166     re_syntax_base* getaddress(std::ptrdiff_t off, void* base)
167     {
168        return static_cast<re_syntax_base*>(static_cast<void*>(static_cast<char*>(base) + off));
169     }
170     void init(unsigned l_flags)
171     {
172        m_pdata->m_flags = l_flags;
173        m_icase = l_flags & regex_constants::icase;
174     }
175     regbase::flag_type flags()
176     {
177        return m_pdata->m_flags;
178     }
179     void flags(regbase::flag_type f)
180     {
181        m_pdata->m_flags = f;
182        if(m_icase != static_cast<bool>(f & regbase::icase))
183        {
184           m_icase = static_cast<bool>(f & regbase::icase);
185        }
186     }
187     re_syntax_base* append_state(syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
188     re_syntax_base* insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
189     re_literal* append_literal(charT c);
190     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set);
191     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, false>*);
192     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, true>*);
193     void finalize(const charT* p1, const charT* p2);
194  protected:
195     regex_data<charT, traits>*    m_pdata;              
196     const ::boost::regex_traits_wrapper<traits>&  
197                                   m_traits;             
198     re_syntax_base*               m_last_state;         
199     bool                          m_icase;              
200     unsigned                      m_repeater_id;        
201     bool                          m_has_backrefs;       
202     std::uintmax_t                m_bad_repeats;        
203     bool                          m_has_recursions;     
204     std::vector<unsigned char>    m_recursion_checks;   
205     typename traits::char_class_type m_word_mask;       
206     typename traits::char_class_type m_mask_space;      
207     typename traits::char_class_type m_lower_mask;       
208     typename traits::char_class_type m_upper_mask;      
209     typename traits::char_class_type m_alpha_mask;      
210  private:
211     basic_regex_creator& operator=(const basic_regex_creator&);
212     basic_regex_creator(const basic_regex_creator&);
213     void fixup_pointers(re_syntax_base* state);
214     void fixup_recursions(re_syntax_base* state);
215     void create_startmaps(re_syntax_base* state);
216     int calculate_backstep(re_syntax_base* state);
217     void create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask);
218     unsigned get_restart_type(re_syntax_base* state);
219     void set_all_masks(unsigned char* bits, unsigned char);
220     bool is_bad_repeat(re_syntax_base* pt);
221     void set_bad_repeat(re_syntax_base* pt);
222     syntax_element_type get_repeat_type(re_syntax_base* state);
223     void probe_leading_repeat(re_syntax_base* state);
224  };
225  template <class charT, class traits>
226  basic_regex_creator<charT, traits>::basic_regex_creator(regex_data<charT, traits>* data)
227     : m_pdata(data), m_traits(*(data->m_ptraits)), m_last_state(0), m_icase(false), m_repeater_id(0), 
228     m_has_backrefs(false), m_bad_repeats(0), m_has_recursions(false), m_word_mask(0), m_mask_space(0), m_lower_mask(0), m_upper_mask(0), m_alpha_mask(0)
229  {
230     m_pdata->m_data.clear();
231     m_pdata->m_status = ::boost::regex_constants::error_ok;
232     static const charT w = 'w';
233     static const charT s = 's';
234     static const charT l[5] = { 'l', 'o', 'w', 'e', 'r', };
235     static const charT u[5] = { 'u', 'p', 'p', 'e', 'r', };
236     static const charT a[5] = { 'a', 'l', 'p', 'h', 'a', };
237     m_word_mask = m_traits.lookup_classname(&w, &w +1);
238     m_mask_space = m_traits.lookup_classname(&s, &s +1);
239     m_lower_mask = m_traits.lookup_classname(l, l + 5);
240     m_upper_mask = m_traits.lookup_classname(u, u + 5);
241     m_alpha_mask = m_traits.lookup_classname(a, a + 5);
242     m_pdata->m_word_mask = m_word_mask;
243     BOOST_REGEX_ASSERT(m_word_mask != 0); 
244     BOOST_REGEX_ASSERT(m_mask_space != 0); 
245     BOOST_REGEX_ASSERT(m_lower_mask != 0); 
246     BOOST_REGEX_ASSERT(m_upper_mask != 0); 
247     BOOST_REGEX_ASSERT(m_alpha_mask != 0); 
248  }
249  template <class charT, class traits>
250  re_syntax_base* basic_regex_creator<charT, traits>::append_state(syntax_element_type t, std::size_t s)
251  {
252     if(t == syntax_element_backref)
253        this->m_has_backrefs = true;
254     m_pdata->m_data.align();
255     if(m_last_state)
256        m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);
257     m_last_state = static_cast<re_syntax_base*>(m_pdata->m_data.extend(s));
258     m_last_state->next.i = 0;
259     m_last_state->type = t;
260     return m_last_state;
261  }
262  template <class charT, class traits>
263  re_syntax_base* basic_regex_creator<charT, traits>::insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)
264  {
265     m_pdata->m_data.align();
266     if(m_last_state)
267        m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);
268     std::ptrdiff_t off = getoffset(m_last_state) + s;
269     re_syntax_base* new_state = static_cast<re_syntax_base*>(m_pdata->m_data.insert(pos, s));
270     new_state->next.i = s;
271     new_state->type = t;
272     m_last_state = getaddress(off);
273     return new_state;
274  }
275  template <class charT, class traits>
276  re_literal* basic_regex_creator<charT, traits>::append_literal(charT c)
277  {
278     re_literal* result;
279     if((0 == m_last_state) || (m_last_state->type != syntax_element_literal))
280     {
281        result = static_cast<re_literal*>(append_state(syntax_element_literal, sizeof(re_literal) + sizeof(charT)));
282        result->length = 1;
283        *static_cast<charT*>(static_cast<void*>(result+1)) = m_traits.translate(c, m_icase);
284     }
285     else
286     {
287        std::ptrdiff_t off = getoffset(m_last_state);
288        m_pdata->m_data.extend(sizeof(charT));
289        m_last_state = result = static_cast<re_literal*>(getaddress(off));
290        charT* characters = static_cast<charT*>(static_cast<void*>(result+1));
291        characters[result->length] = m_traits.translate(c, m_icase);
292        result->length += 1;
293     }
294     return result;
295  }
296  template <class charT, class traits>
297  inline re_syntax_base* basic_regex_creator<charT, traits>::append_set(
298     const basic_char_set<charT, traits>& char_set)
299  {
300     typedef std::integral_constant<bool, (sizeof(charT) == 1) > truth_type;
301     return char_set.has_digraphs() 
302        ? append_set(char_set, static_cast<std::integral_constant<bool, false>*>(0))
303        : append_set(char_set, static_cast<truth_type*>(0));
304  }
305  template <class charT, class traits>
306  re_syntax_base* basic_regex_creator<charT, traits>::append_set(
307     const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, false>*)
308  {
309     typedef typename traits::string_type string_type;
310     typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
311     typedef typename basic_char_set<charT, traits>::set_iterator  set_iterator;
312     typedef typename traits::char_class_type m_type;
313     re_set_long<m_type>* result = static_cast<re_set_long<m_type>*>(append_state(syntax_element_long_set, sizeof(re_set_long<m_type>)));
314     result->csingles = static_cast<unsigned int>(std::distance(char_set.singles_begin(), char_set.singles_end()));
315     result->cranges = static_cast<unsigned int>(std::distance(char_set.ranges_begin(), char_set.ranges_end())) / 2;
316     result->cequivalents = static_cast<unsigned int>(std::distance(char_set.equivalents_begin(), char_set.equivalents_end()));
317     result->cclasses = char_set.classes();
318     result->cnclasses = char_set.negated_classes();
319     if(flags() & regbase::icase)
320     {
321        if(((result->cclasses & m_lower_mask) == m_lower_mask) || ((result->cclasses & m_upper_mask) == m_upper_mask))
322           result->cclasses |= m_alpha_mask;
323        if(((result->cnclasses & m_lower_mask) == m_lower_mask) || ((result->cnclasses & m_upper_mask) == m_upper_mask))
324           result->cnclasses |= m_alpha_mask;
325     }
326     result->isnot = char_set.is_negated();
327     result->singleton = !char_set.has_digraphs();
328     std::ptrdiff_t offset = getoffset(result);
329     item_iterator first, last;
330     set_iterator sfirst, slast;
331     sfirst = char_set.singles_begin();
332     slast = char_set.singles_end();
333     while(sfirst != slast)
334     {
335        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (sfirst->first == static_cast<charT>(0) ? 1 : sfirst->second ? 3 : 2)));
336        p[0] = m_traits.translate(sfirst->first, m_icase);
337        if(sfirst->first == static_cast<charT>(0))
338        {
339           p[0] = 0;
340        }
341        else if(sfirst->second)
342        {
343           p[1] = m_traits.translate(sfirst->second, m_icase);
344           p[2] = 0;
345        }
346        else
347           p[1] = 0;
348        ++sfirst;
349     }
350     first = char_set.ranges_begin();
351     last = char_set.ranges_end();
352     while(first != last)
353     {
354        digraph<charT> c1 = *first;
355        c1.first = this->m_traits.translate(c1.first, this->m_icase);
356        c1.second = this->m_traits.translate(c1.second, this->m_icase);
357        ++first;
358        digraph<charT> c2 = *first;
359        c2.first = this->m_traits.translate(c2.first, this->m_icase);
360        c2.second = this->m_traits.translate(c2.second, this->m_icase);
361        ++first;
362        string_type s1, s2;
363        if(flags() & regex_constants::collate)
364        {
365           charT a1[3] = { c1.first, c1.second, charT(0), };
366           charT a2[3] = { c2.first, c2.second, charT(0), };
367           s1 = this->m_traits.transform(a1, (a1[1] ? a1+2 : a1+1));
368           s2 = this->m_traits.transform(a2, (a2[1] ? a2+2 : a2+1));
369           if(s1.empty())
370              s1 = string_type(1, charT(0));
371           if(s2.empty())
372              s2 = string_type(1, charT(0));
373        }
374        else
375        {
376           if(c1.second)
377           {
378              s1.insert(s1.end(), c1.first);
379              s1.insert(s1.end(), c1.second);
380           }
381           else
382              s1 = string_type(1, c1.first);
383           if(c2.second)
384           {
385              s2.insert(s2.end(), c2.first);
386              s2.insert(s2.end(), c2.second);
387           }
388           else
389              s2.insert(s2.end(), c2.first);
390        }
391        if(s1 > s2)
392        {
393           return 0;
394        }
395        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s1.size() + s2.size() + 2) ) );
396        BOOST_REGEX_DETAIL_NS::copy(s1.begin(), s1.end(), p);
397        p[s1.size()] = charT(0);
398        p += s1.size() + 1;
399        BOOST_REGEX_DETAIL_NS::copy(s2.begin(), s2.end(), p);
400        p[s2.size()] = charT(0);
401     }
402     sfirst = char_set.equivalents_begin();
403     slast = char_set.equivalents_end();
404     while(sfirst != slast)
405     {
406        string_type s;
407        if(sfirst->second)
408        {
409           charT cs[3] = { sfirst->first, sfirst->second, charT(0), };
410           s = m_traits.transform_primary(cs, cs+2);
411        }
412        else
413           s = m_traits.transform_primary(&sfirst->first, &sfirst->first+1);
414        if(s.empty())
415           return 0;  
416        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s.size()+1) ) );
417        BOOST_REGEX_DETAIL_NS::copy(s.begin(), s.end(), p);
418        p[s.size()] = charT(0);
419        ++sfirst;
420     }
421     m_last_state = result = static_cast<re_set_long<m_type>*>(getaddress(offset));
422     return result;
423  }
424  template<class T>
425  inline bool char_less(T t1, T t2)
426  {
427     return t1 < t2;
428  }
429  inline bool char_less(char t1, char t2)
430  {
431     return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
432  }
433  inline bool char_less(signed char t1, signed char t2)
434  {
435     return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
436  }
437  template <class charT, class traits>
438  re_syntax_base* basic_regex_creator<charT, traits>::append_set(
439     const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, true>*)
440  {
441     typedef typename traits::string_type string_type;
442     typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
443     typedef typename basic_char_set<charT, traits>::set_iterator set_iterator;
444     re_set* result = static_cast<re_set*>(append_state(syntax_element_set, sizeof(re_set)));
445     bool negate = char_set.is_negated();
446     std::memset(result->_map, 0, sizeof(result->_map));
447     item_iterator first, last;
448     set_iterator sfirst, slast;
449     sfirst = char_set.singles_begin();
450     slast = char_set.singles_end();
451     while(sfirst != slast)
452     {
453        for(unsigned int i = 0; i < (1 << CHAR_BIT); ++i)
454        {
455           if(this->m_traits.translate(static_cast<charT>(i), this->m_icase)
456              == this->m_traits.translate(sfirst->first, this->m_icase))
457              result->_map[i] = true;
458        }
459        ++sfirst;
460     }
461     first = char_set.ranges_begin();
462     last = char_set.ranges_end();
463     while(first != last)
464     {
465        charT c1 = this->m_traits.translate(first->first, this->m_icase);
466        ++first;
467        charT c2 = this->m_traits.translate(first->first, this->m_icase);
468        ++first;
469        if(flags() & regex_constants::collate)
470        {
471           charT c3[2] = { c1, charT(0), };
472           string_type s1 = this->m_traits.transform(c3, c3+1);
473           c3[0] = c2;
474           string_type s2 = this->m_traits.transform(c3, c3+1);
475           if(s1 > s2)
476           {
477              return 0;
478           }
479           BOOST_REGEX_ASSERT(c3[1] == charT(0));
480           for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
481           {
482              c3[0] = static_cast<charT>(i);
483              string_type s3 = this->m_traits.transform(c3, c3 +1);
484              if((s1 <= s3) && (s3 <= s2))
485                 result->_map[i] = true;
486           }
487        }
488        else
489        {
490           if(char_less(c2, c1))
491           {
492              return 0;
493           }
494           std::memset(result->_map + static_cast<unsigned char>(c1), true, static_cast<unsigned char>(1u) + static_cast<unsigned char>(static_cast<unsigned char>(c2) - static_cast<unsigned char>(c1)));
495        }
496     }
497     typedef typename traits::char_class_type m_type;
498     m_type m = char_set.classes();
499     if(flags() & regbase::icase)
500     {
501        if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
502           m |= m_alpha_mask;
503     }
504     if(m != 0)
505     {
506        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
507        {
508           if(this->m_traits.isctype(static_cast<charT>(i), m))
509              result->_map[i] = true;
510        }
511     }
512     m = char_set.negated_classes();
513     if(flags() & regbase::icase)
514     {
515        if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
516           m |= m_alpha_mask;
517     }
518     if(m != 0)
519     {
520        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
521        {
522           if(0 == this->m_traits.isctype(static_cast<charT>(i), m))
523              result->_map[i] = true;
524        }
525     }
526     sfirst = char_set.equivalents_begin();
527     slast = char_set.equivalents_end();
528     while(sfirst != slast)
529     {
530        string_type s;
531        BOOST_REGEX_ASSERT(static_cast<charT>(0) == sfirst->second);
532        s = m_traits.transform_primary(&sfirst->first, &sfirst->first+1);
533        if(s.empty())
534           return 0;  
535        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
536        {
537           charT c[2] = { (static_cast<charT>(i)), charT(0), };
538           string_type s2 = this->m_traits.transform_primary(c, c+1);
539           if(s == s2)
540              result->_map[i] = true;
541        }
542        ++sfirst;
543     }
544     if(negate)
545     {
546        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
547        {
548           result->_map[i] = !(result->_map[i]);
549        }
550     }
551     return result;
552  }
553  template <class charT, class traits>
554  void basic_regex_creator<charT, traits>::finalize(const charT* p1, const charT* p2)
555  {
556     if(this->m_pdata->m_status)
557        return;
558     append_state(syntax_element_match);
559     std::ptrdiff_t len = p2 - p1;
560     m_pdata->m_expression_len = len;
561     charT* ps = static_cast<charT*>(m_pdata->m_data.extend(sizeof(charT) * (1 + (p2 - p1))));
562     m_pdata->m_expression = ps;
563     BOOST_REGEX_DETAIL_NS::copy(p1, p2, ps);
564     ps[p2 - p1] = 0;
565     m_pdata->m_status = 0;
566     m_pdata->m_first_state = static_cast<re_syntax_base*>(m_pdata->m_data.data());
567     fixup_pointers(m_pdata->m_first_state);
568     if(m_has_recursions)
569     {
570        m_pdata->m_has_recursions = true;
571        fixup_recursions(m_pdata->m_first_state);
572        if(this->m_pdata->m_status)
573           return;
574     }
575     else
576        m_pdata->m_has_recursions = false;
577     create_startmaps(m_pdata->m_first_state);
578     std::memset(m_pdata->m_startmap, 0, sizeof(m_pdata->m_startmap));
579     m_pdata->m_can_be_null = 0;
580     m_bad_repeats = 0;
581     if(m_has_recursions)
582        m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
583     create_startmap(m_pdata->m_first_state, m_pdata->m_startmap, &(m_pdata->m_can_be_null), mask_all);
584     m_pdata->m_restart_type = get_restart_type(m_pdata->m_first_state);
585     probe_leading_repeat(m_pdata->m_first_state);
586  }
587  template <class charT, class traits>
588  void basic_regex_creator<charT, traits>::fixup_pointers(re_syntax_base* state)
589  {
590     while(state)
591     {
592        switch(state->type)
593        {
594        case syntax_element_recurse:
595           m_has_recursions = true;
596           if(state->next.i)
597              state->next.p = getaddress(state->next.i, state);
598           else
599              state->next.p = 0;
600           break;
601        case syntax_element_rep:
602        case syntax_element_dot_rep:
603        case syntax_element_char_rep:
604        case syntax_element_short_set_rep:
605        case syntax_element_long_set_rep:
606           static_cast<re_repeat*>(state)->state_id = m_repeater_id++;
607           BOOST_REGEX_FALLTHROUGH;
608        case syntax_element_alt:
609           std::memset(static_cast<re_alt*>(state)->_map, 0, sizeof(static_cast<re_alt*>(state)->_map));
610           static_cast<re_alt*>(state)->can_be_null = 0;
611           BOOST_REGEX_FALLTHROUGH;
612        case syntax_element_jump:
613           static_cast<re_jump*>(state)->alt.p = getaddress(static_cast<re_jump*>(state)->alt.i, state);
614           BOOST_REGEX_FALLTHROUGH;
615        default:
616           if(state->next.i)
617              state->next.p = getaddress(state->next.i, state);
618           else
619              state->next.p = 0;
620        }
621        state = state->next.p;
622     }
623  }
624  template <class charT, class traits>
625  void basic_regex_creator<charT, traits>::fixup_recursions(re_syntax_base* state)
626  {
627     re_syntax_base* base = state;
628     while(state)
629     {
630        switch(state->type)
631        {
632        case syntax_element_assert_backref:
633           {
634              int idx = static_cast<const re_brace*>(state)->index;
635              if(idx < 0)
636              {
637                 idx = -idx-1;
638                 if(idx >= hash_value_mask)
639                 {
640                    idx = m_pdata->get_id(idx);
641                    if(idx <= 0)
642                    {
643                       if(0 == this->m_pdata->m_status) 
644                          this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
645                       this->m_pdata->m_expression = 0;
646                       this->m_pdata->m_expression_len = 0;
647                       if(0 == (this->flags() & regex_constants::no_except))
648                       {
649                          std::string message = "Encountered a forward reference to a marked sub-expression that does not exist.";
650                          boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
651                          e.raise();
652                       }
653                    }
654                 }
655              }
656           }
657           break;
658        case syntax_element_recurse:
659           {
660              bool ok = false;
661              re_syntax_base* p = base;
662              std::ptrdiff_t idx = static_cast<re_jump*>(state)->alt.i;
663              if(idx >= hash_value_mask)
664              {
665                 idx = m_pdata->get_id(static_cast<int>(idx));
666              }
667              if(idx < 0)
668              {
669                 ok = false;
670              }
671              else
672              {
673                 while(p)
674                 {
675                    if((p->type == syntax_element_startmark) && (static_cast<re_brace*>(p)->index == idx))
676                    {
677                       static_cast<re_jump*>(state)->alt.p = p;
678                       ok = true;
679                       p = p->next.p;
680                       int next_rep_id = 0;
681                       while(p)
682                       {
683                          switch(p->type)
684                          {
685                          case syntax_element_rep:
686                          case syntax_element_dot_rep:
687                          case syntax_element_char_rep:
688                          case syntax_element_short_set_rep:
689                          case syntax_element_long_set_rep:
690                             next_rep_id = static_cast<re_repeat*>(p)->state_id;
691                             break;
692                          case syntax_element_endmark:
693                             if(static_cast<const re_brace*>(p)->index == idx)
694                                next_rep_id = -1;
695                             break;
696                          default:
697                             break;
698                          }
699                          if(next_rep_id)
700                             break;
701                          p = p->next.p;
702                       }
703                       if(next_rep_id > 0)
704                       {
705                          static_cast<re_recurse*>(state)->state_id = next_rep_id - 1;
706                       }
707                       break;
708                    }
709                    p = p->next.p;
710                 }
711              }
712              if(!ok)
713              {
714                 if(0 == this->m_pdata->m_status) 
715                    this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
716                 this->m_pdata->m_expression = 0;
717                 this->m_pdata->m_expression_len = 0;
718                 if(0 == (this->flags() & regex_constants::no_except))
719                 {
720                    std::string message = "Encountered a forward reference to a recursive sub-expression that does not exist.";
721                    boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
722                    e.raise();
723                 }
724              }
725           }
726           break;
727        default:
728           break;
729        }
730        state = state->next.p;
731     }
732  }
733  template <class charT, class traits>
734  void basic_regex_creator<charT, traits>::create_startmaps(re_syntax_base* state)
735  {
736     bool l_icase = m_icase;
737     std::vector<std::pair<bool, re_syntax_base*> > v;
738     while(state)
739     {
740        switch(state->type)
741        {
742        case syntax_element_toggle_case:
743           m_icase = static_cast<re_case*>(state)->icase;
744           state = state->next.p;
745           continue;
746        case syntax_element_alt:
747        case syntax_element_rep:
748        case syntax_element_dot_rep:
749        case syntax_element_char_rep:
750        case syntax_element_short_set_rep:
751        case syntax_element_long_set_rep:
752           v.push_back(std::pair<bool, re_syntax_base*>(m_icase, state));
753           state = state->next.p;
754           break;
755        case syntax_element_backstep:
756           static_cast<re_brace*>(state)->index
757              = this->calculate_backstep(state->next.p);
758           if(static_cast<re_brace*>(state)->index < 0)
759           {
760              if(0 == this->m_pdata->m_status) 
761                 this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
762              this->m_pdata->m_expression = 0;
763              this->m_pdata->m_expression_len = 0;
764              if(0 == (this->flags() & regex_constants::no_except))
765              {
766                 std::string message = "Invalid lookbehind assertion encountered in the regular expression.";
767                 boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
768                 e.raise();
769              }
770           }
771           BOOST_REGEX_FALLTHROUGH;
772        default:
773           state = state->next.p;
774        }
775     }
776     while(!v.empty())
777     {
778        if(m_has_recursions)
779           m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
780        const std::pair<bool, re_syntax_base*>& p = v.back();
781        m_icase = p.first;
782        state = p.second;
783        v.pop_back();
784        m_bad_repeats = 0;
785        create_startmap(state->next.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_take);
786        m_bad_repeats = 0;
787        if(m_has_recursions)
788           m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
789        create_startmap(static_cast<re_alt*>(state)->alt.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_skip);
790        state->type = this->get_repeat_type(state);
791     }
792     m_icase = l_icase;
793  }
794  template <class charT, class traits>
795  int basic_regex_creator<charT, traits>::calculate_backstep(re_syntax_base* state)
796  {
797     typedef typename traits::char_class_type m_type;
798     int result = 0;
799     while(state)
800     {
801        switch(state->type)
802        {
803        case syntax_element_startmark:
804           if((static_cast<re_brace*>(state)->index == -1)
805              || (static_cast<re_brace*>(state)->index == -2))
806           {
807              state = static_cast<re_jump*>(state->next.p)->alt.p->next.p;
808              continue;
809           }
810           else if(static_cast<re_brace*>(state)->index == -3)
811           {
812              state = state->next.p->next.p;
813              continue;
814           }
815           break;
816        case syntax_element_endmark:
817           if((static_cast<re_brace*>(state)->index == -1)
818              || (static_cast<re_brace*>(state)->index == -2))
819              return result;
820           break;
821        case syntax_element_literal:
822           result += static_cast<re_literal*>(state)->length;
823           break;
824        case syntax_element_wild:
825        case syntax_element_set:
826           result += 1;
827           break;
828        case syntax_element_dot_rep:
829        case syntax_element_char_rep:
830        case syntax_element_short_set_rep:
831        case syntax_element_backref:
832        case syntax_element_rep:
833        case syntax_element_combining:
834        case syntax_element_long_set_rep:
835        case syntax_element_backstep:
836           {
837              re_repeat* rep = static_cast<re_repeat *>(state);
838              state->type = this->get_repeat_type(state);
839              if((state->type == syntax_element_dot_rep) 
840                 || (state->type == syntax_element_char_rep)
841                 || (state->type == syntax_element_short_set_rep))
842              {
843                 if(rep->max != rep->min)
844                    return -1;
845                 if (static_cast<std::size_t>((std::numeric_limits<int>::max)() - result) < rep->min)
846                    return -1; 
847                 result += static_cast<int>(rep->min);
848                 state = rep->alt.p;
849                 continue;
850              }
851              else if(state->type == syntax_element_long_set_rep)
852              {
853                 BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_long_set);
854                 if(static_cast<re_set_long<m_type>*>(rep->next.p)->singleton == 0)
855                    return -1;
856                 if(rep->max != rep->min)
857                    return -1;
858                 result += static_cast<int>(rep->min);
859                 state = rep->alt.p;
860                 continue;
861              }
862           }
863           return -1;
864        case syntax_element_long_set:
865           if(static_cast<re_set_long<m_type>*>(state)->singleton == 0)
866              return -1;
867           result += 1;
868           break;
869        case syntax_element_jump:
870           state = static_cast<re_jump*>(state)->alt.p;
871           continue;
872        case syntax_element_alt:
873           {
874              int r1 = calculate_backstep(state->next.p);
875              int r2 = calculate_backstep(static_cast<re_alt*>(state)->alt.p);
876              if((r1 < 0) || (r1 != r2))
877                 return -1;
878              return result + r1;
879           }
880        default:
881           break;
882        }
883        state = state->next.p;
884     }
885     return -1;
886  }
887  struct recursion_saver
888  {
889     std::vector<unsigned char> saved_state;
890     std::vector<unsigned char>* state;
891     recursion_saver(std::vector<unsigned char>* p) : saved_state(*p), state(p) {}
892     ~recursion_saver()
893     {
894        state->swap(saved_state);
895     }
896  };
897  template <class charT, class traits>
898  void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
899  {
900     recursion_saver saved_recursions(&m_recursion_checks);
901     int not_last_jump = 1;
902     re_syntax_base* recursion_start = 0;
903     int recursion_sub = 0;
904     re_syntax_base* recursion_restart = 0;
905     bool l_icase = m_icase;
906     while(state)
907     {
908        switch(state->type)
909        {
910        case syntax_element_toggle_case:
911           l_icase = static_cast<re_case*>(state)->icase;
912           state = state->next.p;
913           break;
914        case syntax_element_literal:
915        {
916           if(l_map)
917           {
918              l_map[0] |= mask_init;
919              charT first_char = *static_cast<charT*>(static_cast<void*>(static_cast<re_literal*>(state) + 1));
920              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
921              {
922                 if(m_traits.translate(static_cast<charT>(i), l_icase) == first_char)
923                    l_map[i] |= mask;
924              }
925           }
926           return;
927        }
928        case syntax_element_end_line:
929        {
930           if(l_map)
931           {
932              l_map[0] |= mask_init;
933              l_map[static_cast<unsigned>('\n')] |= mask;
934              l_map[static_cast<unsigned>('\r')] |= mask;
935              l_map[static_cast<unsigned>('\f')] |= mask;
936              l_map[0x85] |= mask;
937           }
938           if(pnull)
939              create_startmap(state->next.p, 0, pnull, mask);
940           return;
941        }
942        case syntax_element_recurse:
943           {
944              BOOST_REGEX_ASSERT(static_cast<const re_jump*>(state)->alt.p->type == syntax_element_startmark);
945              recursion_sub = static_cast<re_brace*>(static_cast<const re_jump*>(state)->alt.p)->index;
946              if(m_recursion_checks[recursion_sub] & 1u)
947              {
948                 if(0 == this->m_pdata->m_status) 
949                    this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
950                 this->m_pdata->m_expression = 0;
951                 this->m_pdata->m_expression_len = 0;
952                 if(0 == (this->flags() & regex_constants::no_except))
953                 {
954                    std::string message = "Encountered an infinite recursion.";
955                    boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
956                    e.raise();
957                 }
958              }
959              else if(recursion_start == 0)
960              {
961                 recursion_start = state;
962                 recursion_restart = state->next.p;
963                 state = static_cast<re_jump*>(state)->alt.p;
964                 m_recursion_checks[recursion_sub] |= 1u;
965                 break;
966              }
967              m_recursion_checks[recursion_sub] |= 1u;
968              BOOST_REGEX_FALLTHROUGH;
969           }
970        case syntax_element_backref:
971           if(pnull)
972              *pnull |= mask;
973           BOOST_REGEX_FALLTHROUGH;
974        case syntax_element_wild:
975        {
976           set_all_masks(l_map, mask);
977           return;
978        }
979        case syntax_element_accept:
980        case syntax_element_match:
981        {
982           set_all_masks(l_map, mask);
983           if(pnull)
984              *pnull |= mask;
985           return;
986        }
987        case syntax_element_word_start:
988        {
989           create_startmap(state->next.p, l_map, pnull, mask);
990           if(l_map)
991           {
992              l_map[0] |= mask_init;
993              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
994              {
995                 if(!m_traits.isctype(static_cast<charT>(i), m_word_mask))
996                    l_map[i] &= static_cast<unsigned char>(~mask);
997              }
998           }
999           return;
1000        }
1001        case syntax_element_word_end:
1002        {
1003           create_startmap(state->next.p, l_map, pnull, mask);
1004           if(l_map)
1005           {
1006              l_map[0] |= mask_init;
1007              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1008              {
1009                 if(m_traits.isctype(static_cast<charT>(i), m_word_mask))
1010                    l_map[i] &= static_cast<unsigned char>(~mask);
1011              }
1012           }
1013           return;
1014        }
1015        case syntax_element_buffer_end:
1016        {
1017           if(pnull)
1018              *pnull |= mask;
1019           return;
1020        }
1021        case syntax_element_long_set:
1022           if(l_map)
1023           {
1024              typedef typename traits::char_class_type m_type;
1025              if(static_cast<re_set_long<m_type>*>(state)->singleton)
1026              {
1027                 l_map[0] |= mask_init;
1028                 for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1029                 {
1030                    charT c = static_cast<charT>(i);
1031                    if(&c != re_is_set_member(&c, &c + 1, static_cast<re_set_long<m_type>*>(state), *m_pdata, l_icase))
1032                       l_map[i] |= mask;
1033                 }
1034              }
1035              else
1036                 set_all_masks(l_map, mask);
1037           }
1038           return;
1039        case syntax_element_set:
1040           if(l_map)
1041           {
1042              l_map[0] |= mask_init;
1043              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1044              {
1045                 if(static_cast<re_set*>(state)->_map[
1046                    static_cast<unsigned char>(m_traits.translate(static_cast<charT>(i), l_icase))])
1047                    l_map[i] |= mask;
1048              }
1049           }
1050           return;
1051        case syntax_element_jump:
1052           state = static_cast<re_alt*>(state)->alt.p;
1053           not_last_jump = -1;
1054           break;
1055        case syntax_element_alt:
1056        case syntax_element_rep:
1057        case syntax_element_dot_rep:
1058        case syntax_element_char_rep:
1059        case syntax_element_short_set_rep:
1060        case syntax_element_long_set_rep:
1061           {
1062              re_alt* rep = static_cast<re_alt*>(state);
1063              if(rep->_map[0] & mask_init)
1064              {
1065                 if(l_map)
1066                 {
1067                    l_map[0] |= mask_init;
1068                    for(unsigned int i = 0; i <= UCHAR_MAX; ++i)
1069                    {
1070                       if(rep->_map[i] & mask_any)
1071                          l_map[i] |= mask;
1072                    }
1073                 }
1074                 if(pnull)
1075                 {
1076                    if(rep->can_be_null & mask_any)
1077                       *pnull |= mask;
1078                 }
1079              }
1080              else
1081              {
1082                 if(is_bad_repeat(state))
1083                 {
1084                    set_all_masks(l_map, mask);
1085                    if(pnull)
1086                       *pnull |= mask;
1087                    return;
1088                 }
1089                 set_bad_repeat(state);
1090                 create_startmap(state->next.p, l_map, pnull, mask);
1091                 if((state->type == syntax_element_alt)
1092                    || (static_cast<re_repeat*>(state)->min == 0)
1093                    || (not_last_jump == 0))
1094                    create_startmap(rep->alt.p, l_map, pnull, mask);
1095              }
1096           }
1097           return;
1098        case syntax_element_soft_buffer_end:
1099           if(l_map)
1100           {
1101              l_map[0] |= mask_init;
1102              l_map[static_cast<unsigned>('\n')] |= mask;
1103              l_map[static_cast<unsigned>('\r')] |= mask;
1104           }
1105           if(pnull)
1106              *pnull |= mask;
1107           return;
1108        case syntax_element_endmark:
1109           if(static_cast<re_brace*>(state)->index < 0)
1110           {
1111              set_all_masks(l_map, mask);
1112              if(pnull)
1113                 *pnull |= mask;
1114              return;
1115           }
1116           else if(recursion_start && (recursion_sub != 0) && (recursion_sub == static_cast<re_brace*>(state)->index))
1117           {
1118              recursion_start = 0;
1119              state = recursion_restart;
1120              break;
1121           }
1122           if(m_pdata->m_has_recursions && static_cast<re_brace*>(state)->index)
1123           {
1124              bool ok = false;
1125              re_syntax_base* p = m_pdata->m_first_state;
1126              while(p)
1127              {
1128                 if(p->type == syntax_element_recurse)
1129                 {
1130                    re_brace* p2 = static_cast<re_brace*>(static_cast<re_jump*>(p)->alt.p);
1131                    if((p2->type == syntax_element_startmark) && (p2->index == static_cast<re_brace*>(state)->index))
1132                    {
1133                       ok = true;
1134                       break;
1135                    }
1136                 }
1137                 p = p->next.p;
1138              }
1139              if(ok && ((m_recursion_checks[static_cast<re_brace*>(state)->index] & 2u) == 0))
1140              {
1141                 m_recursion_checks[static_cast<re_brace*>(state)->index] |= 2u;
1142                 create_startmap(p->next.p, l_map, pnull, mask);
1143              }
1144           }
1145           state = state->next.p;
1146           break;
1147        case syntax_element_commit:
1148           set_all_masks(l_map, mask);
1149           state = state->next.p;
1150           break;
1151        case syntax_element_startmark:
1152           if(static_cast<re_brace*>(state)->index == -3)
1153           {
1154              state = state->next.p->next.p;
1155              break;
1156           }
1157           BOOST_REGEX_FALLTHROUGH;
1158        default:
1159           state = state->next.p;
1160        }
1161        ++not_last_jump;
1162     }
1163  }
1164  template <class charT, class traits>
1165  unsigned basic_regex_creator<charT, traits>::get_restart_type(re_syntax_base* state)
1166  {
1167     while(state)
1168     {
1169        switch(state->type)
1170        {
1171        case syntax_element_startmark:
1172        case syntax_element_endmark:
1173           state = state->next.p;
1174           continue;
1175        case syntax_element_start_line:
1176           return regbase::restart_line;
1177        case syntax_element_word_start:
1178           return regbase::restart_word;
1179        case syntax_element_buffer_start:
1180           return regbase::restart_buf;
1181        case syntax_element_restart_continue:
1182           return regbase::restart_continue;
1183        default:
1184           state = 0;
1185           continue;
1186        }
1187     }
1188     return regbase::restart_any;
1189  }
1190  template <class charT, class traits>
1191  void basic_regex_creator<charT, traits>::set_all_masks(unsigned char* bits, unsigned char mask)
1192  {
1193     if(bits)
1194     {
1195        if(bits[0] == 0)
1196           (std::memset)(bits, mask, 1u << CHAR_BIT);
1197        else
1198        {
1199           for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
1200              bits[i] |= mask;
1201        }
1202        bits[0] |= mask_init;
1203     }
1204  }
1205  template <class charT, class traits>
1206  bool basic_regex_creator<charT, traits>::is_bad_repeat(re_syntax_base* pt)
1207  {
1208     switch(pt->type)
1209     {
1210     case syntax_element_rep:
1211     case syntax_element_dot_rep:
1212     case syntax_element_char_rep:
1213     case syntax_element_short_set_rep:
1214     case syntax_element_long_set_rep:
1215        {
1216           unsigned state_id = static_cast<re_repeat*>(pt)->state_id;
1217           if(state_id >= sizeof(m_bad_repeats) * CHAR_BIT)
1218              return true;  
1219           static const std::uintmax_t one = 1uL;
1220           return m_bad_repeats & (one << state_id);
1221        }
1222     default:
1223        return false;
1224     }
1225  }
1226  template <class charT, class traits>
1227  void basic_regex_creator<charT, traits>::set_bad_repeat(re_syntax_base* pt)
1228  {
1229     switch(pt->type)
1230     {
1231     case syntax_element_rep:
1232     case syntax_element_dot_rep:
1233     case syntax_element_char_rep:
1234     case syntax_element_short_set_rep:
1235     case syntax_element_long_set_rep:
1236        {
1237           unsigned state_id = static_cast<re_repeat*>(pt)->state_id;
1238           static const std::uintmax_t one = 1uL;
1239           if(state_id <= sizeof(m_bad_repeats) * CHAR_BIT)
1240              m_bad_repeats |= (one << state_id);
1241        }
1242        break;
1243     default:
1244        break;
1245     }
1246  }
1247  template <class charT, class traits>
1248  syntax_element_type basic_regex_creator<charT, traits>::get_repeat_type(re_syntax_base* state)
1249  {
1250     typedef typename traits::char_class_type m_type;
1251     if(state->type == syntax_element_rep)
1252     {
1253        if(state->next.p->next.p->next.p == static_cast<re_alt*>(state)->alt.p)
1254        {
1255           switch(state->next.p->type)
1256           {
1257           case BOOST_REGEX_DETAIL_NS::syntax_element_wild:
1258              return BOOST_REGEX_DETAIL_NS::syntax_element_dot_rep;
1259           case BOOST_REGEX_DETAIL_NS::syntax_element_literal:
1260              return BOOST_REGEX_DETAIL_NS::syntax_element_char_rep;
1261           case BOOST_REGEX_DETAIL_NS::syntax_element_set:
1262              return BOOST_REGEX_DETAIL_NS::syntax_element_short_set_rep;
1263           case BOOST_REGEX_DETAIL_NS::syntax_element_long_set:
1264              if(static_cast<BOOST_REGEX_DETAIL_NS::re_set_long<m_type>*>(state->next.p)->singleton)
1265                 return BOOST_REGEX_DETAIL_NS::syntax_element_long_set_rep;
1266              break;
1267           default:
1268              break;
1269           }
1270        }
1271     }
1272     return state->type;
1273  }
1274  template <class charT, class traits>
1275  void basic_regex_creator<charT, traits>::probe_leading_repeat(re_syntax_base* state)
1276  {
1277     do
1278     {
1279        switch(state->type)
1280        {
1281        case syntax_element_startmark:
1282           if(static_cast<re_brace*>(state)->index >= 0)
1283           {
1284              state = state->next.p;
1285              continue;
1286           }
1287  #ifdef BOOST_REGEX_MSVC
1288  #  pragma warning(push)
1289  #pragma warning(disable:6011)
1290  #endif
1291           if((static_cast<re_brace*>(state)->index == -1)
1292              || (static_cast<re_brace*>(state)->index == -2))
1293           {
1294              state = static_cast<const re_jump*>(state->next.p)->alt.p->next.p;
1295              continue;
1296           }
1297  #ifdef BOOST_REGEX_MSVC
1298  #  pragma warning(pop)
1299  #endif
1300           if(static_cast<re_brace*>(state)->index == -3)
1301           {
1302              state = state->next.p->next.p;
1303              continue;
1304           }
1305           return;
<span onclick='openModal()' class='match'>1306        case syntax_element_endmark:
1307        case syntax_element_start_line:
1308        case syntax_element_end_line:
1309        case syntax_element_word_boundary:
1310        case syntax_element_within_word:
1311        case syntax_element_word_start:
1312        case syntax_element_word_end:
1313        case syntax_element_buffer_start:
1314        case syntax_element_buffer_end:
</span>1315        case syntax_element_restart_continue:
1316           state = state->next.p;
1317           break;
1318        case syntax_element_dot_rep:
1319        case syntax_element_char_rep:
1320        case syntax_element_short_set_rep:
1321        case syntax_element_long_set_rep:
1322           if(this->m_has_backrefs == 0)
1323              static_cast<re_repeat*>(state)->leading = true;
1324           BOOST_REGEX_FALLTHROUGH;
1325        default:
1326           return;
1327        }
1328     }while(state);
1329  }
1330  } 
1331  } 
1332  #ifdef BOOST_REGEX_MSVC
1333  #  pragma warning(pop)
1334  #endif
1335  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_creator.hpp</div>
                <div class="column column_space"><pre><code>879  			case L_ASCII:
880  			case L_BATCH:
881  			case L_TEXT:
882  			case L_MAKEFILE:
883  			case L_ASM:
884  			case L_HASKELL:
885  			case L_SMALLTALK:
886  			case L_KIX:
887  			case L_ADA:
</pre></code></div>
                <div class="column column_space"><pre><code>1306        case syntax_element_endmark:
1307        case syntax_element_start_line:
1308        case syntax_element_end_line:
1309        case syntax_element_word_boundary:
1310        case syntax_element_within_word:
1311        case syntax_element_word_start:
1312        case syntax_element_word_end:
1313        case syntax_element_buffer_start:
1314        case syntax_element_buffer_end:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    