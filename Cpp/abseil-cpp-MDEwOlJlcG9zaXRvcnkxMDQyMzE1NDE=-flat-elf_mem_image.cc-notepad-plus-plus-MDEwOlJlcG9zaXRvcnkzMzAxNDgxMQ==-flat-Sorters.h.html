
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.8054968287526427%, Tokens: 9</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-elf_mem_image.cc</h3>
            <pre><code>1  #include "absl/debugging/internal/elf_mem_image.h"
2  #ifdef ABSL_HAVE_ELF_MEM_IMAGE  
3  #include <string.h>
4  #include <cassert>
5  #include <cstddef>
6  #include "absl/base/config.h"
7  #include "absl/base/internal/raw_logging.h"
8  #define VERSYM_VERSION 0x7fff
9  namespace absl {
10  ABSL_NAMESPACE_BEGIN
11  namespace debugging_internal {
12  namespace {
13  #if __SIZEOF_POINTER__ == 4
14  const int kElfClass = ELFCLASS32;
<span onclick='openModal()' class='match'>15  int ElfBind(const ElfW(Sym) *symbol) { return ELF32_ST_BIND(symbol->st_info); }
16  int ElfType(const ElfW(Sym) *symbol) { return ELF32_ST_TYPE(symbol->st_info); }
</span>17  #elif __SIZEOF_POINTER__ == 8
18  const int kElfClass = ELFCLASS64;
19  int ElfBind(const ElfW(Sym) *symbol) { return ELF64_ST_BIND(symbol->st_info); }
20  int ElfType(const ElfW(Sym) *symbol) { return ELF64_ST_TYPE(symbol->st_info); }
21  #else
22  const int kElfClass = -1;
23  int ElfBind(const ElfW(Sym) *) {
24    ABSL_RAW_LOG(FATAL, "Unexpected word size");
25    return 0;
26  }
27  int ElfType(const ElfW(Sym) *) {
28    ABSL_RAW_LOG(FATAL, "Unexpected word size");
29    return 0;
30  }
31  #endif
32  template <typename T>
33  const T *GetTableElement(const ElfW(Ehdr) * ehdr, ElfW(Off) table_offset,
34                           ElfW(Word) element_size, size_t index) {
35    return reinterpret_cast<const T*>(reinterpret_cast<const char *>(ehdr)
36                                      + table_offset
37                                      + index * element_size);
38  }
39  }  
40  const int ElfMemImage::kInvalidBaseSentinel = 0;
41  ElfMemImage::ElfMemImage(const void *base) {
42    ABSL_RAW_CHECK(base != kInvalidBase, "bad pointer");
43    Init(base);
44  }
45  int ElfMemImage::GetNumSymbols() const {
46    if (!hash_) {
47      return 0;
48    }
49    return static_cast<int>(hash_[1]);
50  }
51  const ElfW(Sym) *ElfMemImage::GetDynsym(int index) const {
52    ABSL_RAW_CHECK(index < GetNumSymbols(), "index out of range");
53    return dynsym_ + index;
54  }
55  const ElfW(Versym) *ElfMemImage::GetVersym(int index) const {
56    ABSL_RAW_CHECK(index < GetNumSymbols(), "index out of range");
57    return versym_ + index;
58  }
59  const ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {
60    ABSL_RAW_CHECK(index >= 0 && index < ehdr_->e_phnum, "index out of range");
61    return GetTableElement<ElfW(Phdr)>(ehdr_, ehdr_->e_phoff, ehdr_->e_phentsize,
62                                       static_cast<size_t>(index));
63  }
64  const char *ElfMemImage::GetDynstr(ElfW(Word) offset) const {
65    ABSL_RAW_CHECK(offset < strsize_, "offset out of range");
66    return dynstr_ + offset;
67  }
68  const void *ElfMemImage::GetSymAddr(const ElfW(Sym) *sym) const {
69    if (sym->st_shndx == SHN_UNDEF || sym->st_shndx >= SHN_LORESERVE) {
70      return reinterpret_cast<const void *>(sym->st_value);
71    }
72    ABSL_RAW_CHECK(link_base_ < sym->st_value, "symbol out of range");
73    return GetTableElement<char>(ehdr_, 0, 1, sym->st_value - link_base_);
74  }
75  const ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {
76    ABSL_RAW_CHECK(0 <= index && static_cast<size_t>(index) <= verdefnum_,
77                   "index out of range");
78    const ElfW(Verdef) *version_definition = verdef_;
79    while (version_definition->vd_ndx < index && version_definition->vd_next) {
80      const char *const version_definition_as_char =
81          reinterpret_cast<const char *>(version_definition);
82      version_definition =
83          reinterpret_cast<const ElfW(Verdef) *>(version_definition_as_char +
84                                                 version_definition->vd_next);
85    }
86    return version_definition->vd_ndx == index ? version_definition : nullptr;
87  }
88  const ElfW(Verdaux) *ElfMemImage::GetVerdefAux(
89      const ElfW(Verdef) *verdef) const {
90    return reinterpret_cast<const ElfW(Verdaux) *>(verdef+1);
91  }
92  const char *ElfMemImage::GetVerstr(ElfW(Word) offset) const {
93    ABSL_RAW_CHECK(offset < strsize_, "offset out of range");
94    return dynstr_ + offset;
95  }
96  void ElfMemImage::Init(const void *base) {
97    ehdr_      = nullptr;
98    dynsym_    = nullptr;
99    dynstr_    = nullptr;
100    versym_    = nullptr;
101    verdef_    = nullptr;
102    hash_      = nullptr;
103    strsize_   = 0;
104    verdefnum_ = 0;
105    link_base_ = ~ElfW(Addr){0};  
106    if (!base) {
107      return;
108    }
109    const char *const base_as_char = reinterpret_cast<const char *>(base);
110    if (base_as_char[EI_MAG0] != ELFMAG0 || base_as_char[EI_MAG1] != ELFMAG1 ||
111        base_as_char[EI_MAG2] != ELFMAG2 || base_as_char[EI_MAG3] != ELFMAG3) {
112      assert(false);
113      return;
114    }
115    int elf_class = base_as_char[EI_CLASS];
116    if (elf_class != kElfClass) {
117      assert(false);
118      return;
119    }
120    switch (base_as_char[EI_DATA]) {
121      case ELFDATA2LSB: {
122  #ifndef ABSL_IS_LITTLE_ENDIAN
123        assert(false);
124        return;
125  #endif
126        break;
127      }
128      case ELFDATA2MSB: {
129  #ifndef ABSL_IS_BIG_ENDIAN
130        assert(false);
131        return;
132  #endif
133        break;
134      }
135      default: {
136        assert(false);
137        return;
138      }
139    }
140    ehdr_ = reinterpret_cast<const ElfW(Ehdr) *>(base);
141    const ElfW(Phdr) *dynamic_program_header = nullptr;
142    for (int i = 0; i < ehdr_->e_phnum; ++i) {
143      const ElfW(Phdr) *const program_header = GetPhdr(i);
144      switch (program_header->p_type) {
145        case PT_LOAD:
146          if (!~link_base_) {
147            link_base_ = program_header->p_vaddr;
148          }
149          break;
150        case PT_DYNAMIC:
151          dynamic_program_header = program_header;
152          break;
153      }
154    }
155    if (!~link_base_ || !dynamic_program_header) {
156      assert(false);
157      Init(nullptr);
158      return;
159    }
160    ptrdiff_t relocation =
161        base_as_char - reinterpret_cast<const char *>(link_base_);
162    ElfW(Dyn)* dynamic_entry = reinterpret_cast<ElfW(Dyn)*>(
163        static_cast<intptr_t>(dynamic_program_header->p_vaddr) + relocation);
164    for (; dynamic_entry->d_tag != DT_NULL; ++dynamic_entry) {
165      const auto value =
166          static_cast<intptr_t>(dynamic_entry->d_un.d_val) + relocation;
167      switch (dynamic_entry->d_tag) {
168        case DT_HASH:
169          hash_ = reinterpret_cast<ElfW(Word) *>(value);
170          break;
171        case DT_SYMTAB:
172          dynsym_ = reinterpret_cast<ElfW(Sym) *>(value);
173          break;
174        case DT_STRTAB:
175          dynstr_ = reinterpret_cast<const char *>(value);
176          break;
177        case DT_VERSYM:
178          versym_ = reinterpret_cast<ElfW(Versym) *>(value);
179          break;
180        case DT_VERDEF:
181          verdef_ = reinterpret_cast<ElfW(Verdef) *>(value);
182          break;
183        case DT_VERDEFNUM:
184          verdefnum_ = static_cast<size_t>(dynamic_entry->d_un.d_val);
185          break;
186        case DT_STRSZ:
187          strsize_ = static_cast<size_t>(dynamic_entry->d_un.d_val);
188          break;
189        default:
190          break;
191      }
192    }
193    if (!hash_ || !dynsym_ || !dynstr_ || !versym_ ||
194        !verdef_ || !verdefnum_ || !strsize_) {
195      assert(false);  
196      Init(nullptr);
197      return;
198    }
199  }
200  bool ElfMemImage::LookupSymbol(const char *name,
201                                 const char *version,
202                                 int type,
203                                 SymbolInfo *info_out) const {
204    for (const SymbolInfo& info : *this) {
205      if (strcmp(info.name, name) == 0 && strcmp(info.version, version) == 0 &&
206          ElfType(info.symbol) == type) {
207        if (info_out) {
208          *info_out = info;
209        }
210        return true;
211      }
212    }
213    return false;
214  }
215  bool ElfMemImage::LookupSymbolByAddress(const void *address,
216                                          SymbolInfo *info_out) const {
217    for (const SymbolInfo& info : *this) {
218      const char *const symbol_start =
219          reinterpret_cast<const char *>(info.address);
220      const char *const symbol_end = symbol_start + info.symbol->st_size;
221      if (symbol_start <= address && address < symbol_end) {
222        if (info_out) {
223          if (ElfBind(info.symbol) == STB_GLOBAL) {
224            *info_out = info;
225            return true;
226          } else {
227            *info_out = info;
228          }
229        } else {
230          return true;
231        }
232      }
233    }
234    return false;
235  }
236  ElfMemImage::SymbolIterator::SymbolIterator(const void *const image, int index)
237      : index_(index), image_(image) {
238  }
239  const ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {
240    return &info_;
241  }
242  const ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {
243    return info_;
244  }
245  bool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {
246    return this->image_ == rhs.image_ && this->index_ == rhs.index_;
247  }
248  bool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {
249    return !(*this == rhs);
250  }
251  ElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {
252    this->Update(1);
253    return *this;
254  }
255  ElfMemImage::SymbolIterator ElfMemImage::begin() const {
256    SymbolIterator it(this, 0);
257    it.Update(0);
258    return it;
259  }
260  ElfMemImage::SymbolIterator ElfMemImage::end() const {
261    return SymbolIterator(this, GetNumSymbols());
262  }
263  void ElfMemImage::SymbolIterator::Update(int increment) {
264    const ElfMemImage *image = reinterpret_cast<const ElfMemImage *>(image_);
265    ABSL_RAW_CHECK(image->IsPresent() || increment == 0, "");
266    if (!image->IsPresent()) {
267      return;
268    }
269    index_ += increment;
270    if (index_ >= image->GetNumSymbols()) {
271      index_ = image->GetNumSymbols();
272      return;
273    }
274    const ElfW(Sym)    *symbol = image->GetDynsym(index_);
275    const ElfW(Versym) *version_symbol = image->GetVersym(index_);
276    ABSL_RAW_CHECK(symbol && version_symbol, "");
277    const char *const symbol_name = image->GetDynstr(symbol->st_name);
278  #if defined(__NetBSD__)
279    const int version_index = version_symbol->vs_vers & VERSYM_VERSION;
280  #else
281    const ElfW(Versym) version_index = version_symbol[0] & VERSYM_VERSION;
282  #endif
283    const ElfW(Verdef) *version_definition = nullptr;
284    const char *version_name = "";
285    if (symbol->st_shndx == SHN_UNDEF) {
286    } else {
287      version_definition = image->GetVerdef(version_index);
288    }
289    if (version_definition) {
290      ABSL_RAW_CHECK(
291          version_definition->vd_cnt == 1 || version_definition->vd_cnt == 2,
292          "wrong number of entries");
293      const ElfW(Verdaux) *version_aux = image->GetVerdefAux(version_definition);
294      version_name = image->GetVerstr(version_aux->vda_name);
295    }
296    info_.name    = symbol_name;
297    info_.version = version_name;
298    info_.address = image->GetSymAddr(symbol);
299    info_.symbol  = symbol;
300  }
301  }  
302  ABSL_NAMESPACE_END
303  }  
304  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Sorters.h</h3>
            <pre><code>1  #pragma once
2  #include <algorithm>
3  #include <utility>
4  #include <random>
5  class ISorter
6  {
7  private:
8  	bool _isDescending = true;
9  	size_t _fromColumn = 0;
10  	size_t _toColumn = 0;
11  protected:
12  	bool isDescending() const {
13  		return _isDescending;
14  	};
15  	generic_string getSortKey(const generic_string& input) {
16  		if (isSortingSpecificColumns())
17  		{
18  			if (input.length() < _fromColumn)
19  			{
20  				return TEXT("");
21  			}
22  			else if (_fromColumn == _toColumn)
23  			{
24  				return input.substr(_fromColumn);
25  			}
26  			else
27  			{
28  				return input.substr(_fromColumn, _toColumn - _fromColumn);
29  			}
30  		}
31  		else
32  		{
33  			return input;
34  		}
35  	};
36  	bool isSortingSpecificColumns() {
37  		return _toColumn != 0;
38  	};
39  public:
40  	ISorter(bool isDescending, size_t fromColumn, size_t toColumn) : _isDescending(isDescending), _fromColumn(fromColumn), _toColumn(toColumn) {
41  		assert(_fromColumn <= _toColumn);
42  	};
43  	virtual ~ISorter() { };
44  	virtual std::vector<generic_string> sort(std::vector<generic_string> lines) = 0;
45  };
46  class LexicographicSorter : public ISorter
47  {
48  public:
49  	LexicographicSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
50  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
51  		if (isSortingSpecificColumns())
52  		{
53  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
54  			{
55  				if (isDescending())
56  				{
57  					return getSortKey(a).compare(getSortKey(b)) > 0;
58  				}
59  				else
60  				{
61  					return getSortKey(a).compare(getSortKey(b)) < 0;
62  				}
63  			});
64  		}
65  		else
66  		{
67  			std::sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
68  			{
69  				if (isDescending())
70  				{
71  					return a.compare(b) > 0;
72  				}
73  				else
74  				{
75  					return a.compare(b) < 0;
76  				}
77  			});
78  		}
79  		return lines;
80  	};
81  };
82  class LexicographicCaseInsensitiveSorter : public ISorter
83  {
84  public:
85  	LexicographicCaseInsensitiveSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
86  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
87  		if (isSortingSpecificColumns())
88  		{
89  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
90  				{
91  					if (isDescending())
92  					{
93  						return OrdinalIgnoreCaseCompareStrings(getSortKey(a).c_str(), getSortKey(b).c_str()) > 0;
94  					}
95  					else
96  					{
97  						return OrdinalIgnoreCaseCompareStrings(getSortKey(a).c_str(), getSortKey(b).c_str()) < 0;
98  					}
99  				});
100  		}
101  		else
102  		{
103  			std::sort(lines.begin(), lines.end(), [this](generic_string a, generic_string b)
104  				{
105  					if (isDescending())
106  					{
107  						return OrdinalIgnoreCaseCompareStrings(a.c_str(), b.c_str()) > 0;
108  					}
109  					else
110  					{
111  						return OrdinalIgnoreCaseCompareStrings(a.c_str(), b.c_str()) < 0;
112  					}
113  				});
114  		}
115  		return lines;
116  	};
117  };
118  class IntegerSorter : public ISorter
119  {
120  public:
121  	IntegerSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
122  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
123  		if (isSortingSpecificColumns())
124  		{
125  			std::stable_sort(lines.begin(), lines.end(), [this](generic_string aIn, generic_string bIn)
126  			{
127  				generic_string a = getSortKey(aIn);
128  				generic_string b = getSortKey(bIn);
129  				long long compareResult = 0;
130  				size_t aNumIndex = 0;
131  				size_t bNumIndex = 0;
132  				while (compareResult == 0)
133  				{
134  					if (aNumIndex >= a.length() || bNumIndex >= b.length())
135  					{
136  						compareResult = a.compare(std::min<size_t>(aNumIndex, a.length()), generic_string::npos, b, std::min<size_t>(bNumIndex, b.length()), generic_string::npos);
137  						break;
138  					}
139  					bool aChunkIsNum = a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9';
140  					bool bChunkIsNum = b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9';
141  					int aNumSign = 1;
142  					if (!aChunkIsNum && (aNumIndex + 1) < a.length())
143  					{
144  						aChunkIsNum = (a[aNumIndex] == L'-' && (a[aNumIndex + 1] >= L'0' && a[aNumIndex + 1] <= L'9'));
145  						aNumSign = -1;
146  					}
147  					int bNumSign = 1;
148  					if (!bChunkIsNum && (bNumIndex + 1) < b.length())
149  					{
150  						bChunkIsNum = (b[bNumIndex] == L'-' && (b[bNumIndex + 1] >= L'0' && b[bNumIndex + 1] <= L'9'));
151  						bNumSign = -1;
152  					}
153  					if (aChunkIsNum != bChunkIsNum)
154  					{
155  						compareResult = a[aNumIndex] - b[bNumIndex];
156  						aNumIndex++;
157  						bNumIndex++;
158  					}
159  					else if (aChunkIsNum)
160  					{
161  						if (aNumSign != bNumSign)
162  						{
163  							if (aNumSign == 1)
164  							{
165  								compareResult = 1;
166  							}
167  							else
168  							{
169  								compareResult = -1;
170  							}
171  						}
172  						else
173  						{
174  							if (aNumSign == -1)
175  							{
176  								aNumIndex++;
177  								bNumIndex++;
178  							}
179  							size_t aNumEnd = a.find_first_not_of(L"1234567890", aNumIndex);
180  							if (aNumEnd == generic_string::npos)
181  							{
182  								aNumEnd = a.length();
183  							}
184  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
185  							if (bNumEnd == generic_string::npos)
186  							{
187  								bNumEnd = b.length();
188  							}
189  							int aZeroNum = 0;
190  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
191  							{
192  								aZeroNum++;
193  								aNumIndex++;
194  							}
195  							int bZeroNum = 0;
196  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
197  							{
198  								bZeroNum++;
199  								bNumIndex++;
200  							}
201  							size_t aNumLength = aNumEnd - aNumIndex;
202  							size_t bNumLength = bNumEnd - bNumIndex;
203  							if (aNumLength > bNumLength)
204  							{
205  								compareResult = 1 * aNumSign;
206  							}
207  							else if (aNumLength < bNumLength)
208  							{
209  								compareResult = -1 * aNumSign;
210  							}
211  							else
212  							{
213  								while (compareResult == 0
214  									&& aNumIndex < a.length()
215  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
216  									&& bNumIndex < b.length()
217  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
218  								{
219  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
220  									aNumIndex++;
221  									bNumIndex++;
222  								}
223  								if (compareResult == 0)
224  								{
225  									compareResult = bZeroNum - aZeroNum;
226  								}
227  							}
228  						}
229  					}
230  					else
231  					{
232  						if (a[aNumIndex] == L'-')
233  						{
234  							aNumIndex++;
235  						}
236  						if (b[bNumIndex] == L'-')
237  						{
238  							bNumIndex++;
239  						}
240  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
241  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
242  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
243  						aNumIndex = aChunkEnd;
244  						bNumIndex = bChunkEnd;
245  					}
246  				}
247  				if (isDescending())
248  				{
249  					return compareResult > 0;
250  				}
251  				else
252  				{
253  					return compareResult < 0;
254  				}
255  			});
256  		}
257  		else
258  		{
259  			std::sort(lines.begin(), lines.end(), [this](generic_string aIn, generic_string bIn)
260  			{
261  				generic_string a = aIn;
262  				generic_string b = bIn;
263  				long long compareResult = 0;
264  				size_t aNumIndex = 0;
265  				size_t bNumIndex = 0;
266  				while (compareResult == 0)
267  				{
268  					if (aNumIndex >= a.length() || bNumIndex >= b.length())
269  					{
270  						compareResult = a.compare(std::min<size_t>(aNumIndex, a.length()), generic_string::npos, b, std::min<size_t>(bNumIndex, b.length()), generic_string::npos);
271  						break;
272  					}
273  					bool aChunkIsNum = a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9';
274  					bool bChunkIsNum = b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9';
275  					int aNumSign = 1;
276  					if (!aChunkIsNum && (aNumIndex + 1) < a.length())
277  					{
278  						aChunkIsNum = (a[aNumIndex] == L'-' && (a[aNumIndex + 1] >= L'0' && a[aNumIndex + 1] <= L'9'));
279  						aNumSign = -1;
280  					}
281  					int bNumSign = 1;
282  					if (!bChunkIsNum && (bNumIndex + 1) < b.length())
283  					{
284  						bChunkIsNum = (b[bNumIndex] == L'-' && (b[bNumIndex + 1] >= L'0' && b[bNumIndex + 1] <= L'9'));
285  						bNumSign = -1;
286  					}
287  					if (aChunkIsNum != bChunkIsNum)
288  					{
289  						compareResult = a[aNumIndex] - b[bNumIndex];
290  						aNumIndex++;
291  						bNumIndex++;
292  					}
293  					else if (aChunkIsNum)
294  					{
295  						if (aNumSign != bNumSign)
296  						{
297  							if (aNumSign == 1)
298  							{
299  								compareResult = 1;
300  							}
301  							else
302  							{
303  								compareResult = -1;
304  							}
305  						}
306  						else
307  						{
308  							if (aNumSign == -1)
309  							{
310  								aNumIndex++;
311  								bNumIndex++;
312  							}
313  							size_t aNumEnd = a.find_first_not_of(L"1234567890", aNumIndex);
314  							if (aNumEnd == generic_string::npos)
315  							{
316  								aNumEnd = a.length();
317  							}
318  							size_t bNumEnd = b.find_first_not_of(L"1234567890", bNumIndex);
319  							if (bNumEnd == generic_string::npos)
320  							{
321  								bNumEnd = b.length();
322  							}
323  							int aZeroNum = 0;
324  							while (aNumIndex < a.length() && a[aNumIndex] == '0')
325  							{
326  								aZeroNum++;
327  								aNumIndex++;
328  							}
329  							int bZeroNum = 0;
330  							while (bNumIndex < b.length() && b[bNumIndex] == '0')
331  							{
332  								bZeroNum++;
333  								bNumIndex++;
334  							}
335  							size_t aNumLength = aNumEnd - aNumIndex;
336  							size_t bNumLength = bNumEnd - bNumIndex;
337  							if (aNumLength > bNumLength)
338  							{
339  								compareResult = 1 * aNumSign;
340  							}
341  							else if (aNumLength < bNumLength)
342  							{
343  								compareResult = -1 * aNumSign;
344  							}
345  							else
346  							{
347  								while (compareResult == 0
348  									&& aNumIndex < a.length()
349  									&& (a[aNumIndex] >= L'0' && a[aNumIndex] <= L'9')
350  									&& bNumIndex < b.length()
351  									&& (b[bNumIndex] >= L'0' && b[bNumIndex] <= L'9'))
352  								{
353  									compareResult = (a[aNumIndex] - b[bNumIndex]) * aNumSign;
354  									aNumIndex++;
355  									bNumIndex++;
356  								}
357  								if (compareResult == 0)
358  								{
359  									compareResult = bZeroNum - aZeroNum;
360  								}
361  							}
362  						}
363  					}
364  					else
365  					{
366  						if (a[aNumIndex] == L'-')
367  						{
368  							aNumIndex++;
369  						}
370  						if (b[bNumIndex] == L'-')
371  						{
372  							bNumIndex++;
373  						}
374  						size_t aChunkEnd = a.find_first_of(L"1234567890-", aNumIndex);
375  						size_t bChunkEnd = b.find_first_of(L"1234567890-", bNumIndex);
376  						compareResult = a.compare(aNumIndex, aChunkEnd - aNumIndex, b, bNumIndex, bChunkEnd - bNumIndex);
377  						aNumIndex = aChunkEnd;
378  						bNumIndex = bChunkEnd;
379  					}
380  				}
381  				if (isDescending())
382  				{
383  					return compareResult > 0;
384  				}
385  				else
386  				{
387  					return compareResult < 0;
388  				}
389  			});
390  		}
391  		return lines;
392  	};
393  };
394  template<typename T_Num>
395  class NumericSorter : public ISorter
396  {
397  public:
398  	NumericSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn)
399  	{
400  #ifdef __MINGW32__
401  		_usLocale = NULL;
402  #else
403  		_usLocale = ::_create_locale(LC_NUMERIC, "en-US");
404  #endif
405  	};
406  	~NumericSorter()
407  	{
408  #ifndef __MINGW32__
409  		::_free_locale(_usLocale);
410  #endif
411  	}
412  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
413  		std::vector<std::pair<size_t, T_Num>> nonEmptyInputAsNumbers;
414  		std::vector<generic_string> empties;
415  		nonEmptyInputAsNumbers.reserve(lines.size());
416  		for (size_t lineIndex = 0; lineIndex < lines.size(); ++lineIndex)
417  		{
418  			const generic_string originalLine = lines[lineIndex];
419  			const generic_string preparedLine = prepareStringForConversion(originalLine);
420  			if (considerStringEmpty(preparedLine))
421  			{
422  				empties.push_back(originalLine);
423  			}
424  			else
425  			{
426  				try
427  				{
428  					nonEmptyInputAsNumbers.push_back(std::make_pair(lineIndex, convertStringToNumber(preparedLine)));
429  				}
430  				catch (...)
431  				{
432  					throw lineIndex;
433  				}
434  			}
435  		}
436  		assert(nonEmptyInputAsNumbers.size() + empties.size() == lines.size());
437  		const bool descending = isDescending();
438  		std::stable_sort(nonEmptyInputAsNumbers.begin(), nonEmptyInputAsNumbers.end(), [descending](std::pair<size_t, T_Num> a, std::pair<size_t, T_Num> b)
439  			{
440  				if (descending)
441  				{
442  					return a.second > b.second;
443  				}
444  				else
445  				{
446  					return a.second < b.second;
447  				}
448  			});
449  		std::vector<generic_string> output;
450  		output.reserve(lines.size());
451  		if (!isDescending())
452  		{
453  			output.insert(output.end(), empties.begin(), empties.end());
454  		}
455  		for (auto it = nonEmptyInputAsNumbers.begin(); it != nonEmptyInputAsNumbers.end(); ++it)
456  		{
457  			output.push_back(lines[it->first]);
458  		}
459  		if (isDescending())
460  		{
461  			output.insert(output.end(), empties.begin(), empties.end());
462  		}
463  		assert(output.size() == lines.size());
464  		return output;
465  	};
466  protected:
467  	bool considerStringEmpty(const generic_string& input) {
468  		return input.find_first_not_of(TEXT(" \t\r\n")) == std::string::npos;
469  	}
470  	virtual generic_string prepareStringForConversion(const generic_string& input) = 0;
471  	virtual T_Num convertStringToNumber(const generic_string& input) = 0;
472  	_locale_t _usLocale;
473  };
474  class DecimalCommaSorter : public NumericSorter<double>
475  {
476  public:
477  	DecimalCommaSorter(bool isDescending, size_t fromColumn, size_t toColumn) : NumericSorter<double>(isDescending, fromColumn, toColumn) { };
478  protected:
479  	generic_string prepareStringForConversion(const generic_string& input) override {
480  		generic_string admissablePart = stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789,-"));
481  		return stringReplace(admissablePart, TEXT(","), TEXT("."));
482  	};
483  	double convertStringToNumber(const generic_string& input) override {
484  		return stodLocale(input, _usLocale);
485  	};
486  };
487  class DecimalDotSorter : public NumericSorter<double>
488  {
489  public:
490  	DecimalDotSorter(bool isDescending, size_t fromColumn, size_t toColumn) : NumericSorter<double>(isDescending, fromColumn, toColumn) { };
491  protected:
<span onclick='openModal()' class='match'>492  	generic_string prepareStringForConversion(const generic_string& input) override {
493  		return stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789.-"));
494  	};
495  	double convertStringToNumber(const generic_string& input) override {
496  		return stodLocale(input, _usLocale);
497  	};
</span>498  };
499  class ReverseSorter : public ISorter
500  {
501  public:
502  	ReverseSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) { };
503  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
504  		std::reverse(lines.begin(), lines.end());
505  		return lines;
506  	};
507  };
508  class RandomSorter : public ISorter
509  {
510  public:
511  	unsigned seed;
512  	RandomSorter(bool isDescending, size_t fromColumn, size_t toColumn) : ISorter(isDescending, fromColumn, toColumn) {
513  		seed = static_cast<unsigned>(time(NULL));
514  	};
515  	std::vector<generic_string> sort(std::vector<generic_string> lines) override {
516  		std::shuffle(lines.begin(), lines.end(), std::default_random_engine(seed));
517  		return lines;
518  	};
519  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-elf_mem_image.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Sorters.h</div>
                <div class="column column_space"><pre><code>15  int ElfBind(const ElfW(Sym) *symbol) { return ELF32_ST_BIND(symbol->st_info); }
16  int ElfType(const ElfW(Sym) *symbol) { return ELF32_ST_TYPE(symbol->st_info); }
</pre></code></div>
                <div class="column column_space"><pre><code>492  	generic_string prepareStringForConversion(const generic_string& input) override {
493  		return stringTakeWhileAdmissable(getSortKey(input), TEXT(" \t\r\n0123456789.-"));
494  	};
495  	double convertStringToNumber(const generic_string& input) override {
496  		return stodLocale(input, _usLocale);
497  	};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    