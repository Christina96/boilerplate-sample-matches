
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5584415584415585%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkl_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MKLPoolingLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MKLPoolingLayerTest()
16        : blob_bottom_(new Blob<Dtype>()),
17          blob_top_(new Blob<Dtype>()),
18          blob_top_mask_(new Blob<size_t>()) {}
19    virtual void SetUp() {
20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
23      GaussianFiller<Dtype> filler(filler_param);
24      filler.Fill(this->blob_bottom_);
25      blob_bottom_vec_.push_back(blob_bottom_);
26      blob_top_vec_.push_back(blob_top_);
27    }
28    virtual ~MKLPoolingLayerTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31      delete blob_top_mask_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    Blob<size_t>* const blob_top_mask_;
36    vector<Blob<Dtype>*> blob_bottom_vec_;
37    vector<Blob<Dtype>*> blob_top_vec_;
38    void TestForwardSquare() {
39      LayerParameter layer_param;
40      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
41      pooling_param->set_kernel_size(2);
42      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
43      const int num = 2;
44      const int channels = 2;
45      blob_bottom_->Reshape(num, channels, 3, 5);
46      for (int i = 0; i < 15 * num * channels; i += 15) {
47        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
48        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
49        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
50        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
52        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
53        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
54        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
55        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
57        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
58        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
59        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
60        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
62      }
63      MKLPoolingLayer<Dtype> layer(layer_param);
64      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
65      EXPECT_EQ(blob_top_->num(), num);
66      EXPECT_EQ(blob_top_->channels(), channels);
67      EXPECT_EQ(blob_top_->height(), 2);
68      EXPECT_EQ(blob_top_->width(), 4);
69      if (blob_top_vec_.size() > 1) {
70        EXPECT_EQ(blob_top_mask_->num(), num);
71        EXPECT_EQ(blob_top_mask_->channels(), channels);
72        EXPECT_EQ(blob_top_mask_->height(), 2);
73        EXPECT_EQ(blob_top_mask_->width(), 4);
74      }
75      layer.Forward(blob_bottom_vec_, blob_top_vec_);
76      for (int i = 0; i < 8 * num * channels; i += 8) {
77        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
78        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
79        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
85      }
<span onclick='openModal()' class='match'>86      if (blob_top_vec_.size() > 1) {
87        for (int i = 0; i < 8 * num * channels; i += 8) {
88          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
89          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
90          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
91          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
92          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
93          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
94          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
95          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
96        }
97      }
</span>98    }
99    void TestForwardRectHigh() {
100      LayerParameter layer_param;
101      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
102      pooling_param->set_kernel_h(3);
103      pooling_param->set_kernel_w(2);
104      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
105      const int num = 2;
106      const int channels = 2;
107      blob_bottom_->Reshape(num, channels, 6, 6);
108      for (int i = 0; i < 36 * num * channels; i += 36) {
109        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
110        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
111        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
112        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
113        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
114        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
115        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
116        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
117        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
118        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
119        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
120        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
121        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
122        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
123        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
124        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
125        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
126        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
127        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
128        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
129        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
130        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
131        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
132        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
133        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
134        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
135        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
136        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
137        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
138        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
139        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
140        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
141        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
142        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
143        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
144        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
145      }
146      MKLPoolingLayer<Dtype> layer(layer_param);
147      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
148      EXPECT_EQ(blob_top_->num(), num);
149      EXPECT_EQ(blob_top_->channels(), channels);
150      EXPECT_EQ(blob_top_->height(), 4);
151      EXPECT_EQ(blob_top_->width(), 5);
152      if (blob_top_vec_.size() > 1) {
153        EXPECT_EQ(blob_top_mask_->num(), num);
154        EXPECT_EQ(blob_top_mask_->channels(), channels);
155        EXPECT_EQ(blob_top_mask_->height(), 4);
156        EXPECT_EQ(blob_top_mask_->width(), 5);
157      }
158      layer.Forward(blob_bottom_vec_, blob_top_vec_);
159      for (int i = 0; i < 20 * num * channels; i += 20) {
160        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
161        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
162        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
170        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
171        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
180      }
181      if (blob_top_vec_.size() > 1) {
182        for (int i = 0; i < 20 * num * channels; i += 20) {
183          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
184          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
185          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
186          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
187          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
188          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
189          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
190          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
191          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
192          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
193          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
194          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
195          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
196          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
197          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
198          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
199          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
200          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
201          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
202          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
203        }
204      }
205    }
206    void TestForwardRectWide() {
207      LayerParameter layer_param;
208      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
209      pooling_param->set_kernel_h(2);
210      pooling_param->set_kernel_w(3);
211      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
212      const int num = 2;
213      const int channels = 2;
214      blob_bottom_->Reshape(num, channels, 6, 6);
215      for (int i = 0; i < 36 * num * channels; i += 36) {
216        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
217        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
218        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
219        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
220        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
221        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
222        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
223        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
224        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
225        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
226        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
227        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
228        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
229        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
230        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
231        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
232        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
233        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
234        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
235        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
236        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
237        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
238        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
239        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
240        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
241        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
242        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
243        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
244        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
245        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
246        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
247        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
248        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
249        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
250        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
251        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
252      }
253      MKLPoolingLayer<Dtype> layer(layer_param);
254      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
255      EXPECT_EQ(blob_top_->num(), num);
256      EXPECT_EQ(blob_top_->channels(), channels);
257      EXPECT_EQ(blob_top_->height(), 5);
258      EXPECT_EQ(blob_top_->width(), 4);
259      if (blob_top_vec_.size() > 1) {
260        EXPECT_EQ(blob_top_mask_->num(), num);
261        EXPECT_EQ(blob_top_mask_->channels(), channels);
262        EXPECT_EQ(blob_top_mask_->height(), 5);
263        EXPECT_EQ(blob_top_mask_->width(), 4);
264      }
265      layer.Forward(blob_bottom_vec_, blob_top_vec_);
266      for (int i = 0; i < 20 * num * channels; i += 20) {
267        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
268        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
269        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
277        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
287      }
288      if (blob_top_vec_.size() > 1) {
289        for (int i = 0; i < 20 * num * channels; i += 20) {
290          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
291          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
292          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
293          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
294          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
295          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
296          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
297          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
298          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
299          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
300          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
301          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
302          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
303          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
304          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
305          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
306          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
307          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
308          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
309          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
310        }
311      }
312    }
313  };
314  typedef ::testing::Types<CPUDevice<float>,
315                           CPUDevice<double> > TestDtypesCPU;
316  TYPED_TEST_CASE(MKLPoolingLayerTest, TestDtypesCPU);
317  TYPED_TEST(MKLPoolingLayerTest, TestSetup) {
318    typedef typename TypeParam::Dtype Dtype;
319    LayerParameter layer_param;
320    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
321    pooling_param->set_kernel_size(3);
322    pooling_param->set_stride(2);
323    MKLPoolingLayer<Dtype> layer(layer_param);
324    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
325    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
326    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
327    EXPECT_EQ(this->blob_top_->height(), 3);
328    EXPECT_EQ(this->blob_top_->width(), 2);
329  }
330  TYPED_TEST(MKLPoolingLayerTest, TestSetupPadded) {
331    typedef typename TypeParam::Dtype Dtype;
332    LayerParameter layer_param;
333    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
334    pooling_param->set_kernel_size(3);
335    pooling_param->set_stride(2);
336    pooling_param->set_pad(1);
337    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
338    MKLPoolingLayer<Dtype> layer(layer_param);
339    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
340    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
341    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
342    EXPECT_EQ(this->blob_top_->height(), 4);
343    EXPECT_EQ(this->blob_top_->width(), 3);
344  }
345  TYPED_TEST(MKLPoolingLayerTest, TestSetupGlobalPooling) {
346    typedef typename TypeParam::Dtype Dtype;
347    LayerParameter layer_param;
348    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
349    pooling_param->set_global_pooling(true);
350    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
351    MKLPoolingLayer<Dtype> layer(layer_param);
352    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
353    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
354    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
355    EXPECT_EQ(this->blob_top_->height(), 1);
356    EXPECT_EQ(this->blob_top_->width(), 1);
357  }
358  TYPED_TEST(MKLPoolingLayerTest, TestForwardMax) {
359    this->TestForwardSquare();
360    this->TestForwardRectHigh();
361    this->TestForwardRectWide();
362  }
363  TYPED_TEST(MKLPoolingLayerTest, TestForwardMaxTopMask) {
364    typedef typename TypeParam::Dtype Dtype;
365    this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
366            (this->blob_top_mask_));
367    this->TestForwardSquare();
368    this->TestForwardRectHigh();
369    this->TestForwardRectWide();
370  }
371  TYPED_TEST(MKLPoolingLayerTest, TestGradientMax) {
372    typedef typename TypeParam::Dtype Dtype;
373    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
374      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
375        LayerParameter layer_param;
376        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
377        pooling_param->set_kernel_h(kernel_h);
378        pooling_param->set_kernel_w(kernel_w);
379        pooling_param->set_stride(2);
380        pooling_param->set_pad(1);
381        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
382        MKLPoolingLayer<Dtype> layer(layer_param);
383        GradientChecker<Dtype> checker(1e-4, 1e-2);
384        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
385            this->blob_top_vec_);
386      }
387    }
388  }
389  TYPED_TEST(MKLPoolingLayerTest, TestForwardMaxPadded) {
390    typedef typename TypeParam::Dtype Dtype;
391    LayerParameter layer_param;
392    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
393    pooling_param->set_kernel_size(3);
394    pooling_param->set_stride(2);
395    pooling_param->set_pad(2);
396    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
397    this->blob_bottom_->Reshape(1, 1, 3, 3);
398    this->blob_bottom_->mutable_cpu_data()[0] = 1;
399    this->blob_bottom_->mutable_cpu_data()[1] = 2;
400    this->blob_bottom_->mutable_cpu_data()[2] = 4;
401    this->blob_bottom_->mutable_cpu_data()[3] = 2;
402    this->blob_bottom_->mutable_cpu_data()[4] = 3;
403    this->blob_bottom_->mutable_cpu_data()[5] = 2;
404    this->blob_bottom_->mutable_cpu_data()[6] = 4;
405    this->blob_bottom_->mutable_cpu_data()[7] = 2;
406    this->blob_bottom_->mutable_cpu_data()[8] = 1;
407    MKLPoolingLayer<Dtype> layer(layer_param);
408    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
409    EXPECT_EQ(this->blob_top_->num(), 1);
410    EXPECT_EQ(this->blob_top_->channels(), 1);
411    EXPECT_EQ(this->blob_top_->height(), 3);
412    EXPECT_EQ(this->blob_top_->width(), 3);
413    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
414    Dtype epsilon = 1e-8;
415    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
416    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
417    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
418    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
419    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
422    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
423    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
424  }
425  #if 0
426  TYPED_TEST(MKLPoolingLayerTest, TestGradientMaxTopMask) {
427    typedef typename TypeParam::Dtype Dtype;
428    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
429      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
430        LayerParameter layer_param;
431        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
432        pooling_param->set_kernel_h(kernel_h);
433        pooling_param->set_kernel_w(kernel_w);
434        pooling_param->set_stride(2);
435        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
436        this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
437                (this->blob_top_mask_));
438        MKLPoolingLayer<Dtype> layer(layer_param);
439        GradientChecker<Dtype> checker(1e-4, 1e-2);
440        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
441            this->blob_top_vec_);
442        this->blob_top_vec_.pop_back();
443      }
444    }
445  }
446  #endif
447  #if 0  
448  TYPED_TEST(MKLPoolingLayerTest, TestForwardAve) {
449    typedef typename TypeParam::Dtype Dtype;
450    LayerParameter layer_param;
451    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
452    pooling_param->set_kernel_size(3);
453    pooling_param->set_stride(1);
454    pooling_param->set_pad(1);
455    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
456    this->blob_bottom_->Reshape(1, 1, 3, 3);
457    FillerParameter filler_param;
458    filler_param.set_value(Dtype(2));
459    ConstantFiller<Dtype> filler(filler_param);
460    filler.Fill(this->blob_bottom_);
461    MKLPoolingLayer<Dtype> layer(layer_param);
462    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
463    EXPECT_EQ(this->blob_top_->num(), 1);
464    EXPECT_EQ(this->blob_top_->channels(), 1);
465    EXPECT_EQ(this->blob_top_->height(), 3);
466    EXPECT_EQ(this->blob_top_->width(), 3);
467    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
468    Dtype epsilon = 1e-5;
469    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
470    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4.0 / 3, epsilon);
471    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
472    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4.0 / 3, epsilon);
473    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
474    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4.0 / 3, epsilon);
475    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
476    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4.0 / 3, epsilon);
477    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
478  }
479  TYPED_TEST(MKLPoolingLayerTest, TestGradientAve) {
480    typedef typename TypeParam::Dtype Dtype;
481    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
482      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
483        LayerParameter layer_param;
484        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
485        pooling_param->set_kernel_h(kernel_h);
486        pooling_param->set_kernel_w(kernel_w);
487        pooling_param->set_stride(2);
488        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
489        MKLPoolingLayer<Dtype> layer(layer_param);
490        GradientChecker<Dtype> checker(1e-2, 1e-2);
491        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
492            this->blob_top_vec_);
493      }
494    }
495  }
496  TYPED_TEST(MKLPoolingLayerTest, TestGradientAvePadded) {
497    typedef typename TypeParam::Dtype Dtype;
498    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
499      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
500        LayerParameter layer_param;
501        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
502        pooling_param->set_kernel_h(kernel_h);
503        pooling_param->set_kernel_w(kernel_w);
504        pooling_param->set_stride(2);
505        pooling_param->set_pad(2);
506        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
507        MKLPoolingLayer<Dtype> layer(layer_param);
508        GradientChecker<Dtype> checker(1e-2, 1e-2);
509        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
510            this->blob_top_vec_);
511      }
512    }
513  }
514  #endif
515  }  
516  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baselinedetect.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "baselinedetect.h"
6  #include <allheaders.h>
7  #include <algorithm>
8  #include <cfloat> 
9  #include <cmath>  
10  #include "blobbox.h"
11  #include "detlinefit.h"
12  #include "drawtord.h"
13  #include "helpers.h"
14  #include "linlsq.h"
15  #include "makerow.h"
16  #include "textord.h"
17  #include "tprintf.h"
18  #include "underlin.h"
19  const int kMaxDisplacementsModes = 3;
20  const int kNumSkipPoints = 3;
21  const double kMaxSkewDeviation = 1.0 / 64;
22  const double kOffsetQuantizationFactor = 3.0 / 64;
23  const double kFitHalfrangeFactor = 6.0 / 64;
24  const double kMaxBaselineError = 3.0 / 64;
25  const double kMaxBlobSizeMultiple = 1.3;
26  const double kMinFittingLinespacings = 0.25;
27  namespace tesseract {
28  BaselineRow::BaselineRow(double line_spacing, TO_ROW *to_row)
29      : blobs_(to_row->blob_list()),
30        baseline_pt1_(0.0f, 0.0f),
31        baseline_pt2_(0.0f, 0.0f),
32        baseline_error_(0.0),
33        good_baseline_(false) {
34    ComputeBoundingBox();
35    disp_quant_factor_ = kOffsetQuantizationFactor * line_spacing;
36    fit_halfrange_ = kFitHalfrangeFactor * line_spacing;
37    max_baseline_error_ = kMaxBaselineError * line_spacing;
38  }
39  void BaselineRow::SetupOldLineParameters(TO_ROW *row) const {
40    double gradient = tan(BaselineAngle());
41    float para_c = StraightYAtX(0.0);
42    row->set_line(gradient, para_c, baseline_error_);
43    row->set_parallel_line(gradient, para_c, baseline_error_);
44  }
45  void BaselineRow::Print() const {
46    tprintf("Baseline (%g,%g)->(%g,%g), angle=%g, intercept=%g\n",
47            baseline_pt1_.x(), baseline_pt1_.y(), baseline_pt2_.x(),
48            baseline_pt2_.y(), BaselineAngle(), StraightYAtX(0.0));
49    tprintf("Quant factor=%g, error=%g, good=%d, box:", disp_quant_factor_,
50            baseline_error_, good_baseline_);
51    bounding_box_.print();
52  }
53  double BaselineRow::BaselineAngle() const {
54    FCOORD baseline_dir(baseline_pt2_ - baseline_pt1_);
55    double angle = baseline_dir.angle();
56    return fmod(angle + M_PI * 1.5, M_PI) - M_PI * 0.5;
57  }
58  double BaselineRow::SpaceBetween(const BaselineRow &other) const {
59    float x = (std::max(bounding_box_.left(), other.bounding_box_.left()) +
60               std::min(bounding_box_.right(), other.bounding_box_.right())) /
61              2.0f;
62    float y = (StraightYAtX(x) + other.StraightYAtX(x)) / 2.0f;
63    FCOORD pt(x, y);
64    return PerpDistanceFromBaseline(pt) + other.PerpDistanceFromBaseline(pt);
65  }
66  double BaselineRow::PerpDisp(const FCOORD &direction) const {
67    float middle_x = (bounding_box_.left() + bounding_box_.right()) / 2.0f;
68    FCOORD middle_pos(middle_x, StraightYAtX(middle_x));
69    return direction * middle_pos / direction.length();
70  }
71  double BaselineRow::StraightYAtX(double x) const {
72    double denominator = baseline_pt2_.x() - baseline_pt1_.x();
73    if (denominator == 0.0) {
74      return (baseline_pt1_.y() + baseline_pt2_.y()) / 2.0;
75    }
76    return baseline_pt1_.y() + (x - baseline_pt1_.x()) *
77                                   (baseline_pt2_.y() - baseline_pt1_.y()) /
78                                   denominator;
79  }
80  bool BaselineRow::FitBaseline(bool use_box_bottoms) {
81    fitter_.Clear();
82    LLSQ llsq;
83    BLOBNBOX_IT blob_it(blobs_);
84    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
85      BLOBNBOX *blob = blob_it.data();
86      if (!use_box_bottoms) {
87        blob->EstimateBaselinePosition();
88      }
89      const TBOX &box = blob->bounding_box();
90      int x_middle = (box.left() + box.right()) / 2;
91  #ifdef kDebugYCoord
92      if (box.bottom() < kDebugYCoord && box.top() > kDebugYCoord) {
93        tprintf("Box bottom = %d, baseline pos=%d for box at:", box.bottom(),
94                blob->baseline_position());
95        box.print();
96      }
97  #endif
98      fitter_.Add(ICOORD(x_middle, blob->baseline_position()), box.width() / 2);
99      llsq.add(x_middle, blob->baseline_position());
100    }
101    ICOORD pt1, pt2;
102    baseline_error_ = fitter_.Fit(&pt1, &pt2);
103    baseline_pt1_ = pt1;
104    baseline_pt2_ = pt2;
105    if (baseline_error_ > max_baseline_error_ &&
106        fitter_.SufficientPointsForIndependentFit()) {
107      double error = fitter_.Fit(kNumSkipPoints, kNumSkipPoints, &pt1, &pt2);
108      if (error < baseline_error_ / 2.0) {
109        baseline_error_ = error;
110        baseline_pt1_ = pt1;
111        baseline_pt2_ = pt2;
112      }
113    }
114    int debug = 0;
115  #ifdef kDebugYCoord
116    Print();
117    debug = bounding_box_.bottom() < kDebugYCoord &&
118                    bounding_box_.top() > kDebugYCoord
119                ? 3
120                : 2;
121  #endif
122    FCOORD direction(pt2 - pt1);
123    double target_offset = direction * pt1;
124    good_baseline_ = false;
125    FitConstrainedIfBetter(debug, direction, 0.0, target_offset);
126    double angle = BaselineAngle();
127    if (fabs(angle) > M_PI * 0.25) {
128      baseline_pt1_ = llsq.mean_point();
129      baseline_pt2_ = baseline_pt1_ + FCOORD(1.0f, llsq.m());
130      double m = llsq.m();
131      double c = llsq.c(m);
132      baseline_error_ = llsq.rms(m, c);
133      good_baseline_ = false;
134    }
135    return good_baseline_;
136  }
137  void BaselineRow::AdjustBaselineToParallel(int debug, const FCOORD &direction) {
138    SetupBlobDisplacements(direction);
139    if (displacement_modes_.empty()) {
140      return;
141    }
142  #ifdef kDebugYCoord
143    if (bounding_box_.bottom() < kDebugYCoord &&
144        bounding_box_.top() > kDebugYCoord && debug < 3)
145      debug = 3;
146  #endif
147    FitConstrainedIfBetter(debug, direction, 0.0, displacement_modes_[0]);
148  }
149  double BaselineRow::AdjustBaselineToGrid(int debug, const FCOORD &direction,
150                                           double line_spacing,
151                                           double line_offset) {
152    if (blobs_->empty()) {
153      if (debug > 1) {
154        tprintf("Row empty at:");
155        bounding_box_.print();
156      }
157      return line_offset;
158    }
159    double best_error = 0.0;
160    int best_index = -1;
161    for (unsigned i = 0; i < displacement_modes_.size(); ++i) {
162      double blob_y = displacement_modes_[i];
163      double error =
164          BaselineBlock::SpacingModelError(blob_y, line_spacing, line_offset);
165      if (debug > 1) {
166        tprintf("Mode at %g has error %g from model \n", blob_y, error);
167      }
168      if (best_index < 0 || error < best_error) {
169        best_error = error;
170        best_index = i;
171      }
172    }
173    double model_margin = max_baseline_error_ - best_error;
174    if (best_index >= 0 && model_margin > 0.0) {
175      double perp_disp = PerpDisp(direction);
176      double shift = displacement_modes_[best_index] - perp_disp;
177      if (fabs(shift) > max_baseline_error_) {
178        if (debug > 1) {
179          tprintf("Attempting linespacing model fit with mode %g to row at:",
180                  displacement_modes_[best_index]);
181          bounding_box_.print();
182        }
183        FitConstrainedIfBetter(debug, direction, model_margin,
184                               displacement_modes_[best_index]);
185      } else if (debug > 1) {
186        tprintf("Linespacing model only moves current line by %g for row at:",
187                shift);
188        bounding_box_.print();
189      }
190    } else if (debug > 1) {
191      tprintf("Linespacing model not close enough to any mode for row at:");
192      bounding_box_.print();
193    }
194    return fmod(PerpDisp(direction), line_spacing);
195  }
196  void BaselineRow::SetupBlobDisplacements(const FCOORD &direction) {
197    std::vector<double> perp_blob_dists;
198    displacement_modes_.clear();
199    double min_dist = FLT_MAX;
200    double max_dist = -FLT_MAX;
201    BLOBNBOX_IT blob_it(blobs_);
202  #ifdef kDebugYCoord
203    bool debug = false;
204  #endif
205    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
206      BLOBNBOX *blob = blob_it.data();
207      const TBOX &box = blob->bounding_box();
208  #ifdef kDebugYCoord
209      if (box.bottom() < kDebugYCoord && box.top() > kDebugYCoord)
210        debug = true;
211  #endif
212      FCOORD blob_pos((box.left() + box.right()) / 2.0f,
213                      blob->baseline_position());
214      double offset = direction * blob_pos;
215      perp_blob_dists.push_back(offset);
216  #ifdef kDebugYCoord
217      if (debug) {
218        tprintf("Displacement %g for blob at:", offset);
219        box.print();
220      }
221  #endif
222      UpdateRange(offset, &min_dist, &max_dist);
223    }
224    STATS dist_stats(IntCastRounded(min_dist / disp_quant_factor_),
225                     IntCastRounded(max_dist / disp_quant_factor_));
226    for (double perp_blob_dist : perp_blob_dists) {
227      dist_stats.add(IntCastRounded(perp_blob_dist / disp_quant_factor_), 1);
228    }
229    std::vector<KDPairInc<float, int>> scaled_modes;
230    dist_stats.top_n_modes(kMaxDisplacementsModes, scaled_modes);
231  #ifdef kDebugYCoord
<span onclick='openModal()' class='match'>232    if (debug) {
233      for (int i = 0; i < scaled_modes.size(); ++i) {
234        tprintf("Top mode = %g * %d\n", scaled_modes[i].key * disp_quant_factor_,
235                scaled_modes[i].data());
236      }
237    }
</span>238  #endif
239    for (auto &scaled_mode : scaled_modes) {
240      displacement_modes_.push_back(disp_quant_factor_ * scaled_mode.key());
241    }
242  }
243  void BaselineRow::FitConstrainedIfBetter(int debug, const FCOORD &direction,
244                                           double cheat_allowance,
245                                           double target_offset) {
246    double halfrange = fit_halfrange_ * direction.length();
247    double min_dist = target_offset - halfrange;
248    double max_dist = target_offset + halfrange;
249    ICOORD line_pt;
250    double new_error = fitter_.ConstrainedFit(direction, min_dist, max_dist,
251                                              debug > 2, &line_pt);
252    new_error -= cheat_allowance;
253    double old_angle = BaselineAngle();
254    double new_angle = direction.angle();
255    if (debug > 1) {
256      tprintf("Constrained error = %g, original = %g", new_error,
257              baseline_error_);
258      tprintf(" angles = %g, %g, delta=%g vs threshold %g\n", old_angle,
259              new_angle, new_angle - old_angle, kMaxSkewDeviation);
260    }
261    bool new_good_baseline =
262        new_error <= max_baseline_error_ &&
263        (cheat_allowance > 0.0 || fitter_.SufficientPointsForIndependentFit());
264    if (new_error <= baseline_error_ || (!good_baseline_ && new_good_baseline) ||
265        fabs(new_angle - old_angle) > kMaxSkewDeviation) {
266      baseline_error_ = new_error;
267      baseline_pt1_ = line_pt;
268      baseline_pt2_ = baseline_pt1_ + direction;
269      good_baseline_ = new_good_baseline;
270      if (debug > 1) {
271        tprintf("Replacing with constrained baseline, good = %d\n",
272                good_baseline_);
273      }
274    } else if (debug > 1) {
275      tprintf("Keeping old baseline\n");
276    }
277  }
278  float BaselineRow::PerpDistanceFromBaseline(const FCOORD &pt) const {
279    FCOORD baseline_vector(baseline_pt2_ - baseline_pt1_);
280    FCOORD offset_vector(pt - baseline_pt1_);
281    float distance = baseline_vector * offset_vector;
282    float sqlength = baseline_vector.sqlength();
283    if (sqlength == 0.0f) {
284      tprintf("unexpected baseline vector (0,0)\n");
285      return 0.0f;
286    }
287    return std::sqrt(distance * distance / sqlength);
288  }
289  void BaselineRow::ComputeBoundingBox() {
290    BLOBNBOX_IT it(blobs_);
291    TBOX box;
292    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
293      box += it.data()->bounding_box();
294    }
295    bounding_box_ = box;
296  }
297  BaselineBlock::BaselineBlock(int debug_level, bool non_text, TO_BLOCK *block)
298      : block_(block),
299        debug_level_(debug_level),
300        non_text_block_(non_text),
301        good_skew_angle_(false),
302        skew_angle_(0.0),
303        line_spacing_(block->line_spacing),
304        line_offset_(0.0),
305        model_error_(0.0) {
306    TO_ROW_IT row_it(block_->get_rows());
307    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
308      row_it.data()->blob_list()->sort(blob_x_order);
309      rows_.push_back(new BaselineRow(block->line_spacing, row_it.data()));
310    }
311  }
312  double BaselineBlock::SpacingModelError(double perp_disp, double line_spacing,
313                                          double line_offset) {
314    int multiple = IntCastRounded((perp_disp - line_offset) / line_spacing);
315    double model_y = line_spacing * multiple + line_offset;
316    return fabs(perp_disp - model_y);
317  }
318  bool BaselineBlock::FitBaselinesAndFindSkew(bool use_box_bottoms) {
319    if (non_text_block_) {
320      return false;
321    }
322    std::vector<double> angles;
323    for (auto row : rows_) {
324      if (row->FitBaseline(use_box_bottoms)) {
325        double angle = row->BaselineAngle();
326        angles.push_back(angle);
327      }
328      if (debug_level_ > 1) {
329        row->Print();
330      }
331    }
332    if (!angles.empty()) {
333      skew_angle_ = MedianOfCircularValues(M_PI, angles);
334      good_skew_angle_ = true;
335    } else {
336      skew_angle_ = 0.0f;
337      good_skew_angle_ = false;
338    }
339    if (debug_level_ > 0) {
340      tprintf("Initial block skew angle = %g, good = %d\n", skew_angle_,
341              good_skew_angle_);
342    }
343    return good_skew_angle_;
344  }
345  void BaselineBlock::ParallelizeBaselines(double default_block_skew) {
346    if (non_text_block_) {
347      return;
348    }
349    if (!good_skew_angle_) {
350      skew_angle_ = default_block_skew;
351    }
352    if (debug_level_ > 0) {
353      tprintf("Adjusting block to skew angle %g\n", skew_angle_);
354    }
355    FCOORD direction(cos(skew_angle_), sin(skew_angle_));
356    for (auto row : rows_) {
357      row->AdjustBaselineToParallel(debug_level_, direction);
358      if (debug_level_ > 1) {
359        row->Print();
360      }
361    }
362    if (rows_.size() < 3 || !ComputeLineSpacing()) {
363      return;
364    }
365    unsigned best_row = 0;
366    double best_error = SpacingModelError(rows_[0]->PerpDisp(direction),
367                                          line_spacing_, line_offset_);
368    for (unsigned r = 1; r < rows_.size(); ++r) {
369      double error = SpacingModelError(rows_[r]->PerpDisp(direction),
370                                       line_spacing_, line_offset_);
371      if (error < best_error) {
372        best_error = error;
373        best_row = r;
374      }
375    }
376    double offset = line_offset_;
377    for (auto r = best_row + 1; r < rows_.size(); ++r) {
378      offset = rows_[r]->AdjustBaselineToGrid(debug_level_, direction,
379                                              line_spacing_, offset);
380    }
381    offset = line_offset_;
382    for (int r = best_row - 1; r >= 0; --r) {
383      offset = rows_[r]->AdjustBaselineToGrid(debug_level_, direction,
384                                              line_spacing_, offset);
385    }
386  }
387  void BaselineBlock::SetupBlockParameters() const {
388    if (line_spacing_ > 0.0) {
389      float min_spacing =
390          std::min(block_->line_spacing, static_cast<float>(line_spacing_));
391      if (min_spacing < block_->line_size) {
392        block_->line_size = min_spacing;
393      }
394      block_->line_spacing = line_spacing_;
395      block_->baseline_offset = line_offset_;
396      block_->max_blob_size = line_spacing_ * kMaxBlobSizeMultiple;
397    }
398    TO_ROW_IT row_it(block_->get_rows());
399    for (unsigned r = 0; r < rows_.size(); ++r, row_it.forward()) {
400      BaselineRow *row = rows_[r];
401      TO_ROW *to_row = row_it.data();
402      row->SetupOldLineParameters(to_row);
403    }
404  }
405  void BaselineBlock::PrepareForSplineFitting(ICOORD page_tr, bool remove_noise) {
406    if (non_text_block_) {
407      return;
408    }
409    if (remove_noise) {
410      vigorous_noise_removal(block_);
411    }
412    FCOORD rotation(1.0f, 0.0f);
413    double gradient = tan(skew_angle_);
414    separate_underlines(block_, gradient, rotation, true);
415    pre_associate_blobs(page_tr, block_, rotation, true);
416  }
417  void BaselineBlock::FitBaselineSplines(bool enable_splines,
418                                         bool show_final_rows, Textord *textord) {
419    double gradient = tan(skew_angle_);
420    FCOORD rotation(1.0f, 0.0f);
421    if (enable_splines) {
422      textord->make_spline_rows(block_, gradient, show_final_rows);
423    } else {
424      TBOX block_box = block_->block->pdblk.bounding_box();
425      TO_ROW_IT row_it = block_->get_rows();
426      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
427        TO_ROW *row = row_it.data();
428        int32_t xstarts[2] = {block_box.left(), block_box.right()};
429        double coeffs[3] = {0.0, row->line_m(), row->line_c()};
430        row->baseline = QSPLINE(1, xstarts, coeffs);
431        textord->compute_row_xheight(row, block_->block->classify_rotation(),
432                                     row->line_m(), block_->line_size);
433      }
434    }
435    textord->compute_block_xheight(block_, gradient);
436    block_->block->set_xheight(block_->xheight);
437    if (textord_restore_underlines) { 
438      restore_underlined_blobs(block_);
439    }
440  }
441  #ifndef GRAPHICS_DISABLED
442  void BaselineBlock::DrawFinalRows(const ICOORD &page_tr) {
443    if (non_text_block_) {
444      return;
445    }
446    double gradient = tan(skew_angle_);
447    FCOORD rotation(1.0f, 0.0f);
448    int left_edge = block_->block->pdblk.bounding_box().left();
449    ScrollView *win = create_to_win(page_tr);
450    ScrollView::Color colour = ScrollView::RED;
451    TO_ROW_IT row_it = block_->get_rows();
452    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
453      plot_parallel_row(row_it.data(), gradient, left_edge, colour, rotation);
454      colour = static_cast<ScrollView::Color>(colour + 1);
455      if (colour > ScrollView::MAGENTA) {
456        colour = ScrollView::RED;
457      }
458    }
459    plot_blob_list(win, &block_->blobs, ScrollView::MAGENTA, ScrollView::WHITE);
460    plot_blob_list(win, &block_->underlines, ScrollView::YELLOW,
461                   ScrollView::CORAL);
462    if (block_->blobs.length() > 0) {
463      tprintf("%d blobs discarded as noise\n", block_->blobs.length());
464    }
465    draw_meanlines(block_, gradient, left_edge, ScrollView::WHITE, rotation);
466  }
467  #endif 
468  void BaselineBlock::DrawPixSpline(Image pix_in) {
469    if (non_text_block_) {
470      return;
471    }
472    TO_ROW_IT row_it = block_->get_rows();
473    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
474      row_it.data()->baseline.plot(pix_in);
475    }
476  }
477  bool BaselineBlock::ComputeLineSpacing() {
478    FCOORD direction(cos(skew_angle_), sin(skew_angle_));
479    std::vector<double> row_positions;
480    ComputeBaselinePositions(direction, &row_positions);
481    if (row_positions.size() < 2) {
482      return false;
483    }
484    EstimateLineSpacing();
485    RefineLineSpacing(row_positions);
486    double max_baseline_error = kMaxBaselineError * line_spacing_;
487    int non_trivial_gaps = 0;
488    int fitting_gaps = 0;
489    for (unsigned i = 1; i < row_positions.size(); ++i) {
490      double row_gap = fabs(row_positions[i - 1] - row_positions[i]);
491      if (row_gap > max_baseline_error) {
492        ++non_trivial_gaps;
493        if (fabs(row_gap - line_spacing_) <= max_baseline_error) {
494          ++fitting_gaps;
495        }
496      }
497    }
498    if (debug_level_ > 0) {
499      tprintf("Spacing %g, in %zu rows, %d gaps fitted out of %d non-trivial\n",
500              line_spacing_, row_positions.size(), fitting_gaps,
501              non_trivial_gaps);
502    }
503    return fitting_gaps > non_trivial_gaps * kMinFittingLinespacings;
504  }
505  void BaselineBlock::ComputeBaselinePositions(const FCOORD &direction,
506                                               std::vector<double> *positions) {
507    positions->clear();
508    for (auto row : rows_) {
509      const TBOX &row_box = row->bounding_box();
510      float x_middle = (row_box.left() + row_box.right()) / 2.0f;
511      FCOORD row_pos(x_middle, static_cast<float>(row->StraightYAtX(x_middle)));
512      float offset = direction * row_pos;
513      positions->push_back(offset);
514    }
515  }
516  void BaselineBlock::EstimateLineSpacing() {
517    std::vector<float> spacings;
518    for (unsigned r = 0; r < rows_.size(); ++r) {
519      BaselineRow *row = rows_[r];
520      if (fabs(row->BaselineAngle()) > M_PI * 0.25) {
521        continue;
522      }
523      const TBOX &row_box = row->bounding_box();
524      unsigned r2;
525      for (r2 = r + 1; r2 < rows_.size() &&
526                       !row_box.major_x_overlap(rows_[r2]->bounding_box());
527           ++r2) {
528        ;
529      }
530      if (r2 < rows_.size()) {
531        BaselineRow *row2 = rows_[r2];
532        if (fabs(row2->BaselineAngle()) > M_PI * 0.25) {
533          continue;
534        }
535        float spacing = row->SpaceBetween(*row2);
536        spacings.push_back(spacing);
537      }
538    }
539    if (!spacings.empty()) {
540      std::nth_element(spacings.begin(), spacings.begin() + spacings.size() / 2,
541                       spacings.end());
542      line_spacing_ = spacings[spacings.size() / 2];
543      if (debug_level_ > 1) {
544        tprintf("Estimate of linespacing = %g\n", line_spacing_);
545      }
546    }
547  }
548  void BaselineBlock::RefineLineSpacing(const std::vector<double> &positions) {
549    double spacings[3], offsets[3], errors[3];
550    int index_range;
551    errors[0] = FitLineSpacingModel(positions, line_spacing_, &spacings[0],
552                                    &offsets[0], &index_range);
553    if (index_range > 1) {
554      double spacing_plus = line_spacing_ / (1.0 + 1.0 / index_range);
555      errors[1] = FitLineSpacingModel(positions, spacing_plus, &spacings[1],
556                                      &offsets[1], nullptr);
557      double spacing_minus = line_spacing_ / (1.0 - 1.0 / index_range);
558      errors[2] = FitLineSpacingModel(positions, spacing_minus, &spacings[2],
559                                      &offsets[2], nullptr);
560      for (int i = 1; i <= 2; ++i) {
561        if (errors[i] < errors[0]) {
562          spacings[0] = spacings[i];
563          offsets[0] = offsets[i];
564          errors[0] = errors[i];
565        }
566      }
567    }
568    if (spacings[0] > 0.0) {
569      line_spacing_ = spacings[0];
570      line_offset_ = offsets[0];
571      model_error_ = errors[0];
572      if (debug_level_ > 0) {
573        tprintf("Final linespacing model = %g + offset %g, error %g\n",
574                line_spacing_, line_offset_, model_error_);
575      }
576    }
577  }
578  double BaselineBlock::FitLineSpacingModel(const std::vector<double> &positions,
579                                            double m_in, double *m_out,
580                                            double *c_out, int *index_delta) {
581    if (m_in == 0.0f || positions.size() < 2) {
582      *m_out = m_in;
583      *c_out = 0.0;
584      if (index_delta != nullptr) {
585        *index_delta = 0;
586      }
587      return 0.0;
588    }
589    std::vector<double> offsets;
590    offsets.reserve(positions.size());
591    for (double position : positions) {
592      offsets.push_back(fmod(position, m_in));
593    }
594    double median_offset = MedianOfCircularValues(m_in, offsets);
595    LLSQ llsq;
596    int min_index = INT32_MAX;
597    int max_index = -INT32_MAX;
598    for (double y_pos : positions) {
599      int row_index = IntCastRounded((y_pos - median_offset) / m_in);
600      UpdateRange(row_index, &min_index, &max_index);
601      llsq.add(row_index, y_pos);
602    }
603    *m_out = llsq.m();
604    offsets.clear();
605    if (*m_out != 0.0) {
606      for (double position : positions) {
607        offsets.push_back(fmod(position, *m_out));
608      }
609      if (debug_level_ > 2) {
610        for (unsigned i = 0; i < offsets.size(); ++i) {
611          tprintf("%u: %g\n", i, offsets[i]);
612        }
613      }
614      *c_out = MedianOfCircularValues(*m_out, offsets);
615    } else {
616      *c_out = 0.0;
617    }
618    if (debug_level_ > 1) {
619      tprintf("Median offset = %g, compared to mean of %g.\n", *c_out,
620              llsq.c(*m_out));
621    }
622    if (index_delta != nullptr) {
623      *index_delta = max_index - min_index;
624    }
625    double rms_error = llsq.rms(*m_out, llsq.c(*m_out));
626    if (debug_level_ > 1) {
627      tprintf("Linespacing of y=%g x + %g improved to %g x + %g, rms=%g\n", m_in,
628              median_offset, *m_out, *c_out, rms_error);
629    }
630    return rms_error;
631  }
632  BaselineDetect::BaselineDetect(int debug_level, const FCOORD &page_skew,
633                                 TO_BLOCK_LIST *blocks)
634      : page_skew_(page_skew), debug_level_(debug_level) {
635    TO_BLOCK_IT it(blocks);
636    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
637      TO_BLOCK *to_block = it.data();
638      BLOCK *block = to_block->block;
639      POLY_BLOCK *pb = block->pdblk.poly_block();
640      bool non_text = pb != nullptr && !pb->IsText();
641      blocks_.push_back(new BaselineBlock(debug_level_, non_text, to_block));
642    }
643  }
644  void BaselineDetect::ComputeStraightBaselines(bool use_box_bottoms) {
645    std::vector<double> block_skew_angles;
646    for (auto bl_block : blocks_) {
647      if (debug_level_ > 0) {
648        tprintf("Fitting initial baselines...\n");
649      }
650      if (bl_block->FitBaselinesAndFindSkew(use_box_bottoms)) {
651        block_skew_angles.push_back(bl_block->skew_angle());
652      }
653    }
654    double default_block_skew = page_skew_.angle();
655    if (!block_skew_angles.empty()) {
656      default_block_skew = MedianOfCircularValues(M_PI, block_skew_angles);
657    }
658    if (debug_level_ > 0) {
659      tprintf("Page skew angle = %g\n", default_block_skew);
660    }
661    for (auto bl_block : blocks_) {
662      bl_block->ParallelizeBaselines(default_block_skew);
663      bl_block->SetupBlockParameters(); 
664    }
665  }
666  void BaselineDetect::ComputeBaselineSplinesAndXheights(const ICOORD &page_tr,
667                                                         bool enable_splines,
668                                                         bool remove_noise,
669                                                         bool show_final_rows,
670                                                         Textord *textord) {
671    for (auto bl_block : blocks_) {
672      if (enable_splines) {
673        bl_block->PrepareForSplineFitting(page_tr, remove_noise);
674      }
675      bl_block->FitBaselineSplines(enable_splines, show_final_rows, textord);
676  #ifndef GRAPHICS_DISABLED
677      if (show_final_rows) {
678        bl_block->DrawFinalRows(page_tr);
679      }
680  #endif
681    }
682  }
683  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_pooling_layer.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baselinedetect.cpp</div>
                <div class="column column_space"><pre><code>86      if (blob_top_vec_.size() > 1) {
87        for (int i = 0; i < 8 * num * channels; i += 8) {
88          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
89          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
90          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
91          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
92          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
93          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
94          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
95          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
96        }
97      }
</pre></code></div>
                <div class="column column_space"><pre><code>232    if (debug) {
233      for (int i = 0; i < scaled_modes.size(); ++i) {
234        tprintf("Top mode = %g * %d\n", scaled_modes[i].key * disp_quant_factor_,
235                scaled_modes[i].data());
236      }
237    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    