
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-documentMap.cpp</h3>
            <pre><code>1  #include "documentMap.h"
2  #include "ScintillaEditView.h"
3  void DocumentMap::reloadMap()
4  {
5  	if (_pMapView && _ppEditView)
6  	{
7  		Document currentDoc = (*_ppEditView)->execute(SCI_GETDOCPOINTER);
8  		_pMapView->execute(SCI_SETDOCPOINTER, 0, static_cast<LPARAM>(currentDoc));
9  		Buffer *editBuf = (*_ppEditView)->getCurrentBuffer();
10  		_pMapView->setCurrentBuffer(editBuf);
11  		std::vector<size_t> lineStateVector;
12  		(*_ppEditView)->getCurrentFoldStates(lineStateVector);
13  		_pMapView->syncFoldStateWith(lineStateVector);
14  		if ((*_ppEditView)->isWrap() && needToRecomputeWith())
15  		{
16  			wrapMap();
17  		}
18  		scrollMap();
19  	}
20  }
21  void DocumentMap::showInMapTemporarily(Buffer *buf2show, ScintillaEditView *fromEditView)
22  {
23  	if (_pMapView && fromEditView)
24  	{
25  		_pMapView->execute(SCI_SETDOCPOINTER, 0, static_cast<LPARAM>(buf2show->getDocument()));
26  		_pMapView->setCurrentBuffer(buf2show);
27  		const std::vector<size_t> & lineStateVector = buf2show->getHeaderLineState(fromEditView);
28  		_pMapView->syncFoldStateWith(lineStateVector);
29  		if (fromEditView->isWrap() && needToRecomputeWith(fromEditView))
30  		{
31  			wrapMap(fromEditView);
32  		}
33  		MapPosition mp = buf2show->getMapPosition();
34  		if (mp.isValid())
35  			scrollMapWith(mp);
36  	}
37  }
38  void DocumentMap::setSyntaxHiliting()
39  {
40  	Buffer *buf = _pMapView->getCurrentBuffer();
41  	_pMapView->defineDocType(buf->getLangType());
42  	_pMapView->showMargin(ScintillaEditView::_SC_MARGE_FOLDER, false);
43  }
44  bool DocumentMap::needToRecomputeWith(const ScintillaEditView *editView)
45  {
46  	const ScintillaEditView *pEditView = editView ? editView : *_ppEditView;
47  	auto currentZoom = pEditView->execute(SCI_GETZOOM);
48  	if (_displayZoom != currentZoom)
49  		return true;
50  	int currentTextZoneWidth = pEditView->getTextZoneWidth();
51  	if (_displayWidth != currentTextZoneWidth)
52  		return true;
53  	return false;
54  }
55  void DocumentMap::initWrapMap()
56  {
57  	if (_pMapView && _ppEditView)
58  	{
59  		RECT rect;
60  		getClientRect(rect);
61  		::MoveWindow(_pMapView->getHSelf(), 0, 0, rect.right - rect.left, rect.bottom-rect.top, TRUE);
62  		_pMapView->wrap(false);
63  		_pMapView->redraw(true);
64  		bool isRTL = (*_ppEditView)->isTextDirectionRTL();
65  		if (_pMapView->isTextDirectionRTL() != isRTL)
66  			_pMapView->changeTextDirection(isRTL);
67  	}
68  }
69  void DocumentMap::changeTextDirection(bool isRTL)
70  {
71  	_pMapView->changeTextDirection(isRTL);
72  }
73  double zoomRatio[] = {1, 1, 1, 1, 1.5, 2, 2.5, 2.5, 3.5, 3.5,\
74  4, 4.5, 5, 5, 5.5, 6, 6.5, 7, 7, 7.5, 8, 8.5, 8.5, 9.5, 9.5, 10, 10.5, 11, 11, 11.5, 12};
75  void DocumentMap::wrapMap(const ScintillaEditView *editView)
76  {
77  	const ScintillaEditView *pEditView = editView ? editView : *_ppEditView;
78  	RECT rect;
79  	getClientRect(rect);
80  	if (pEditView->isWrap())
81  	{
82  		int editZoneWidth = pEditView->getTextZoneWidth();
83  		_displayWidth = editZoneWidth;
84  		_displayZoom = pEditView->execute(SCI_GETZOOM);
85  		double zr = zoomRatio[_displayZoom + 10];
86  		double docMapWidth = editZoneWidth / zr;
87  		::MoveWindow(_pMapView->getHSelf(), 0, 0, int(docMapWidth), rect.bottom-rect.top, TRUE);
88  		_pMapView->wrap(true);
89  		_pMapView->execute(SCI_SETWRAPINDENTMODE, pEditView->execute(SCI_GETWRAPINDENTMODE));
90  		const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
91  		if (svp._paddingLeft || svp._paddingRight)
92  		{
93  			intptr_t paddingMapLeft = static_cast<intptr_t>(svp._paddingLeft / (editZoneWidth / docMapWidth));
94  			intptr_t paddingMapRight = static_cast<intptr_t>(svp._paddingRight / (editZoneWidth / docMapWidth));
95  			_pMapView->execute(SCI_SETMARGINLEFT, 0, paddingMapLeft);
96  			_pMapView->execute(SCI_SETMARGINRIGHT, 0, paddingMapRight);
97  		}
98  	}
99  	doMove();
100  }
101  void DocumentMap::scrollMap()
102  {
103  	if (_pMapView && _ppEditView)
104  	{
105  		RECT rcEditView;
106  		(*_ppEditView)->getClientRect(rcEditView);
107  		LRESULT higherPos = (*_ppEditView)->execute(SCI_POSITIONFROMPOINT, 0, 0);
108  		LRESULT lowerPos = (*_ppEditView)->execute(SCI_POSITIONFROMPOINT, rcEditView.right - rcEditView.left, rcEditView.bottom - rcEditView.top);
109  		_pMapView->execute(SCI_GOTOPOS, higherPos);
110  		_pMapView->execute(SCI_GOTOPOS, lowerPos);
111  		RECT rcMapView;
112  		_pMapView->getClientRect(rcMapView);
113  		LRESULT higherY = _pMapView->execute(SCI_POINTYFROMPOSITION, 0, higherPos);
114  		LRESULT lowerY = 0;
115  		LRESULT lineHeightMapView  = _pMapView->execute(SCI_TEXTHEIGHT, 0);
116  		if (!(*_ppEditView)->isWrap())
117  		{ 
118  			LRESULT lineHeightEditView = (*_ppEditView)->execute(SCI_TEXTHEIGHT, 0);
119  			lowerY = higherY + lineHeightMapView * (rcEditView.bottom - rcEditView.top) / lineHeightEditView;
120  		}
121  		else
122  		{ 
123  			lowerY = _pMapView->execute(SCI_POINTYFROMPOSITION, 0, lowerPos) + lineHeightMapView;
124  		}
125  		_vzDlg.drawZone(static_cast<int32_t>(higherY), static_cast<int32_t>(lowerY));
126  	}
127  }
128  void DocumentMap::scrollMapWith(const MapPosition & mapPos)
129  {
130  	if (_pMapView)
131  	{
132  		auto firstVisibleDisplayLineMap = _pMapView->execute(SCI_GETFIRSTVISIBLELINE);
133  		auto firstVisibleDocLineMap = _pMapView->execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLineMap);
134  		auto nbLineMap = _pMapView->execute(SCI_LINESONSCREEN, firstVisibleDocLineMap);
135  		auto lastVisibleDocLineMap = _pMapView->execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLineMap + nbLineMap);
136  		LRESULT mapLineToScroll = 0;
137  		if (lastVisibleDocLineMap < mapPos._lastVisibleDocLine)
138  			mapLineToScroll = mapPos._lastVisibleDocLine;
139  		else
140  			mapLineToScroll = mapPos._firstVisibleDocLine;
141  		_pMapView->execute(SCI_GOTOLINE, mapLineToScroll);
142  		LRESULT higherY = 0;
143  		LRESULT lowerY = 0;
144  		if (!mapPos._isWrap)
145  		{
146  			auto higherPos = _pMapView->execute(SCI_POSITIONFROMLINE, mapPos._firstVisibleDocLine);
147  			auto lowerPos = _pMapView->execute(SCI_POSITIONFROMLINE, mapPos._lastVisibleDocLine);
148  			higherY = _pMapView->execute(SCI_POINTYFROMPOSITION, 0, higherPos);
149  			lowerY = _pMapView->execute(SCI_POINTYFROMPOSITION, 0, lowerPos);
150  			if (lowerY == 0)
151  			{
152  				auto lineHeight = _pMapView->execute(SCI_TEXTHEIGHT, mapPos._firstVisibleDocLine);
153  				lowerY = mapPos._nbLine * lineHeight + mapPos._firstVisibleDocLine;
154  			}
155  		}
156  		else
157  		{
158  			higherY = _pMapView->execute(SCI_POINTYFROMPOSITION, 0, mapPos._higherPos);
159  			auto lineHeight = _pMapView->execute(SCI_TEXTHEIGHT, mapPos._firstVisibleDocLine);
160  			lowerY = mapPos._nbLine * lineHeight + higherY;
161  		}
162  		_vzDlg.drawZone(static_cast<int32_t>(higherY), static_cast<int32_t>(lowerY));
163  	}
164  }
165  void DocumentMap::doMove()
166  {
167  	RECT rc;
168  	::GetClientRect (_hwndScintilla, & rc);
169  	bool isChild = (::GetWindowLongPtr (_vzDlg.getHSelf(), GWL_STYLE) & WS_CHILD) != 0;
170  	::MapWindowPoints (_hwndScintilla, isChild ? _pMapView->getHParent() : HWND_DESKTOP, reinterpret_cast<POINT*>(& rc), 2);
171  	::MoveWindow(_vzDlg.getHSelf(), rc.left, rc.top, (rc.right - rc.left), (rc.bottom - rc.top), TRUE);
172  }
173  void DocumentMap::fold(size_t line, bool foldOrNot)
174  {
175  	_pMapView->fold(line, foldOrNot);
176  }
177  void DocumentMap::foldAll(bool mode)
178  {
179  	_pMapView->foldAll(mode);
180  }
181  void DocumentMap::scrollMap(bool direction, moveMode whichMode)
182  {
183  	auto firstVisibleDisplayLine = (*_ppEditView)->execute(SCI_GETFIRSTVISIBLELINE);
184  	auto nbLine = (*_ppEditView)->execute(SCI_LINESONSCREEN, firstVisibleDisplayLine);
185  	auto nbLine2go = (whichMode == perLine ? 1 : nbLine);
186  	(*_ppEditView)->execute(SCI_LINESCROLL, 0, (direction == moveDown) ? nbLine2go : -nbLine2go);
187  	scrollMap();
188  }
189  void DocumentMap::redraw(bool) const
190  {
191  	_pMapView->execute(SCI_COLOURISE, 0, -1);
192  	DockingDlgInterface::redraw(true);
193  }
194  intptr_t CALLBACK DocumentMap::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
195  {
196      switch (message)
197      {
198          case WM_INITDIALOG :
199          {
200  			_hwndScintilla = reinterpret_cast<HWND>(::SendMessage(_hParent, NPPM_CREATESCINTILLAHANDLE, 0, reinterpret_cast<LPARAM>(_hSelf)));
201  			_pMapView = reinterpret_cast<ScintillaEditView *>(::SendMessage(_hParent, NPPM_INTERNAL_GETSCINTEDTVIEW, 0, reinterpret_cast<LPARAM>(_hwndScintilla)));
202  			_pMapView->execute(SCI_SETZOOM, static_cast<WPARAM>(-10), 0);
203  			_pMapView->execute(SCI_SETVSCROLLBAR, FALSE, 0);
204  			_pMapView->execute(SCI_SETHSCROLLBAR, FALSE, 0);
205  			_pMapView->showIndentGuideLine(false);
206  			_pMapView->display();
207  			reloadMap();
208  			_vzDlg.init(::GetModuleHandle(NULL), _hSelf);
209  			_vzDlg.doDialog();
210  			(NppParameters::getInstance()).SetTransparent(_vzDlg.getHSelf(), 50); 
211  			BringWindowToTop (_vzDlg.getHSelf());
212  			setSyntaxHiliting();
213  			_pMapView->showMargin(0, false);
214  			_pMapView->showMargin(1, false);
215  			_pMapView->showMargin(2, false);
216  			_pMapView->showMargin(3, false);
217  			NppDarkMode::setBorder(_hwndScintilla);
218              return TRUE;
219          }
220          case WM_SIZE:
221          {
222  			if (_pMapView)
223  			{
224  				int width = LOWORD(lParam);
225  				int height = HIWORD(lParam);
226  				if (_vzDlg.isCreated())
227  				{
228  					if (!_pMapView->isWrap())
229  						::MoveWindow(_pMapView->getHSelf(), 0, 0, width, height, TRUE);
230  					doMove();
231  				}
232  			}
233              break;
234          }
235  		case WM_NOTIFY:
236  		{
237  			switch (((LPNMHDR)lParam)->code)
238  			{
239  				case DMN_CLOSE:
240  				{
241  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DOC_MAP, 0);
242  					return TRUE;
243  				}
<span onclick='openModal()' class='match'>244  				case DMN_SWITCHIN:
245  				{
246  					_vzDlg.display();
247  					reloadMap();
248  					setSyntaxHiliting();
</span>249  					return TRUE;
250  				}
251  				case DMN_SWITCHOFF:
252  				{
253  					_vzDlg.display(false);
254  					return TRUE;
255  				}
256  				case DMN_FLOATDROPPED:
257  				{
258  					doMove();
259  					scrollMap();
260  					return TRUE;
261  				}
262  				case NM_DBLCLK:
263  				{
264  					return TRUE;
265  				}
266  				default:
267  					break;
268  			}
269  		}
270  		return TRUE;
271  		case DOCUMENTMAP_SCROLL:
272  		{
273  			bool dir = (wParam != 0);
274  			moveMode mode = (lParam == 0)?perLine:perPage;
275  			scrollMap(dir, mode);
276  		}
277  		return TRUE;
278  		case DOCUMENTMAP_MOUSECLICKED:
279  		{
280  			int newPosY = HIWORD(lParam);
281  			int currentCenterPosY = _vzDlg.getCurrentCenterPosY();
282  			intptr_t pixelPerLine = _pMapView->execute(SCI_TEXTHEIGHT, 0);
283  			intptr_t jumpDistance = newPosY - currentCenterPosY;
284  			intptr_t nbLine2jump = jumpDistance/pixelPerLine;
285  			(*_ppEditView)->execute(SCI_LINESCROLL, 0, nbLine2jump);
286  			scrollMap();
287  		}
288  		return TRUE;
289  		case DOCUMENTMAP_MOUSEWHEEL:
290  		{
291  			(*_ppEditView)->mouseWheel(wParam, lParam);
292  		}
293  		return TRUE;
294          default :
295              return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
296      }
297  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
298  }
299  COLORREF ViewZoneDlg::_focus = RGB(0xFF, 0x80, 0x00);
300  COLORREF ViewZoneDlg::_frost = RGB(0xFF, 0xFF, 0xFF);
301  void ViewZoneDlg::setColour(COLORREF colour2Set, ViewZoneColorIndex i)
302  {
303  	switch (i)
304  	{
305  		case ViewZoneColorIndex::focus:
306  		{
307  			_focus = colour2Set;
308  			break;
309  		}
310  		case ViewZoneColorIndex::frost:
311  		{
312  			_frost = colour2Set;
313  			break;
314  		}
315  		default:
316  			return;
317  	}
318  }
319  void ViewZoneDlg::drawPreviewZone(DRAWITEMSTRUCT *pdis)
320  {
321  	RECT rc = pdis->rcItem;
322  	HBRUSH hbrushFg = CreateSolidBrush(ViewZoneDlg::_focus);
323  	HBRUSH hbrushBg = CreateSolidBrush(ViewZoneDlg::_frost);
324  	FillRect(pdis->hDC, &rc, hbrushBg);
325  	rc.top = _higherY;
326  	rc.bottom = _lowerY;
327  	FillRect(pdis->hDC, &rc, hbrushFg);
328  	DeleteObject(hbrushFg);
329  	DeleteObject(hbrushBg);
330  }
331  void ViewZoneDlg::doDialog()
332  {
333  	if (!isCreated())
334  	{
335  		bool win10 = (NppParameters::getInstance()).getWinVersion() >= WV_WIN10;
336  		create(win10 ? IDD_VIEWZONE : IDD_VIEWZONE_CLASSIC);
337  	}
338  	display();
339  }
340  intptr_t CALLBACK ViewZoneDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
341  {
342  	switch (message) 
343  	{
344          case WM_INITDIALOG :
345  		{
346  			_viewZoneCanvas = ::GetDlgItem(_hSelf, IDC_VIEWZONECANVAS);
347  			if (NULL != _viewZoneCanvas)
348  			{
349  				::SetWindowLongPtr(_viewZoneCanvas, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
350  				_canvasDefaultProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_viewZoneCanvas, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(canvasStaticProc)));
351  				return TRUE;
352  			}
353  			break;
354  		}
355  		case WM_LBUTTONDOWN:
356  		{
357  			::SendMessage(_hParent, DOCUMENTMAP_MOUSECLICKED, wParam, lParam);
358  			break;
359  		}
360  		case WM_MOUSEMOVE:
361  		{
362  			if (wParam & MK_LBUTTON)
363  				::SendMessage(_hParent, DOCUMENTMAP_MOUSECLICKED, wParam, lParam);
364  			break;
365  		}
366  		case WM_DRAWITEM :
367  		{
368  			drawPreviewZone((DRAWITEMSTRUCT *)lParam);
369  			return TRUE;
370  		}
371  		case WM_SIZE:
372          {
373  			if (NULL != _viewZoneCanvas)
374  			{
375  				int width = LOWORD(lParam);
376  				int height = HIWORD(lParam);
377  				::MoveWindow(_viewZoneCanvas, 0, 0, width , height, TRUE);
378  			}
379              break;
380          }
381  		case WM_MOUSEWHEEL :
382  		{
383  			::SendMessage(_hParent, DOCUMENTMAP_MOUSEWHEEL, wParam, lParam);
384  			return TRUE;
385  		}
386  		case WM_DESTROY :
387  		{
388  			return TRUE;
389  		}
390  	}
391  	return FALSE;
392  }
393  LRESULT CALLBACK ViewZoneDlg::canvasStaticProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) 
394  {
395  	ViewZoneDlg *pViewZoneDlg = reinterpret_cast<ViewZoneDlg *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
396  	if (!pViewZoneDlg)
397  		return FALSE;
398  	return pViewZoneDlg->canvas_runProc(hwnd, message, wParam, lParam);
399  }
400  LRESULT CALLBACK ViewZoneDlg::canvas_runProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
401  {
402  	switch (message)
403      {
404  		case WM_DESTROY:
405  		{
406  		}
407  		return TRUE;
408  		case WM_KEYDOWN:
409  			if (wParam == VK_UP)
410  			{
411  				::SendMessage(_hParent, DOCUMENTMAP_SCROLL, static_cast<WPARAM>(moveUp), 0);
412  			}
413  			if (wParam == VK_DOWN)
414  			{
415  				::SendMessage(_hParent, DOCUMENTMAP_SCROLL, static_cast<WPARAM>(moveDown), 0);
416  			}
417  			if (wParam == VK_PRIOR)
418  			{
419  				::SendMessage(_hParent, DOCUMENTMAP_SCROLL, static_cast<WPARAM>(moveUp), 1);
420  			}
421  			if (wParam == VK_NEXT)
422  			{
423  				::SendMessage(_hParent, DOCUMENTMAP_SCROLL, static_cast<WPARAM>(moveDown), 1);
424  			}
425  			break;
426          case WM_SIZE:
427          {
428              break;
429          }
430  		case WM_NOTIFY:
431  		{
432  		}
433  		return TRUE;
434          default :
435              return _canvasDefaultProc(hwnd, message, wParam, lParam);
436      }
437  	return _canvasDefaultProc(hwnd, message, wParam, lParam);
438  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</h3>
            <pre><code>1  #include <windowsx.h>
2  #include "ProjectPanel.h"
3  #include "resource.h"
4  #include "CustomFileDialog.h"
5  #include "localization.h"
6  #include "Parameters.h"
7  #define INDEX_CLEAN_ROOT     0
8  #define INDEX_DIRTY_ROOT     1
9  #define INDEX_PROJECT        2
10  #define INDEX_OPEN_NODE	     3
11  #define INDEX_CLOSED_NODE    4
12  #define INDEX_LEAF           5
13  #define INDEX_LEAF_INVALID   6
14  ProjectPanel::~ProjectPanel()
15  {
16  	for (const auto& s : fullPathStrs)
17  	{
18  		delete s;
19  	}
20  }
21  intptr_t CALLBACK ProjectPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
22  {
23  	switch (message)
24  	{
25  		case WM_INITDIALOG :
26  		{
27  			ProjectPanel::initMenus();
28  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST;
29  			_hToolbarMenu = CreateWindowEx(0,TOOLBARCLASSNAME,NULL, style,
30  								   0,0,0,0,_hSelf, nullptr, _hInst, nullptr);
31  			TBBUTTON tbButtons[2]{};
32  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
33  			generic_string workspace_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 0, PM_WORKSPACEMENUENTRY);
34  			generic_string edit_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 1, PM_EDITMENUENTRY);
35  			tbButtons[0].idCommand = IDB_PROJECT_BTN;
36  			tbButtons[0].iBitmap = I_IMAGENONE;
37  			tbButtons[0].fsState = TBSTATE_ENABLED;
38  			tbButtons[0].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
39  			tbButtons[0].iString = (intptr_t)workspace_entry.c_str();
40  			tbButtons[1].idCommand = IDB_EDIT_BTN;
41  			tbButtons[1].iBitmap = I_IMAGENONE;
42  			tbButtons[1].fsState = TBSTATE_ENABLED;
43  			tbButtons[1].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
44  			tbButtons[1].iString = (intptr_t)edit_entry.c_str();
45  			SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
46  			SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
47  			SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0); 
48  			ShowWindow(_hToolbarMenu, SW_SHOW);
49  			_treeView.init(_hInst, _hSelf, ID_PROJECTTREEVIEW);
50  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 7, IDI_PROJECT_WORKSPACE, IDI_PROJECT_WORKSPACEDIRTY, IDI_PROJECT_PROJECT, IDI_PROJECT_FOLDEROPEN, IDI_PROJECT_FOLDERCLOSE, IDI_PROJECT_FILE, IDI_PROJECT_FILEINVALID);
51  			_treeView.addCanNotDropInList(INDEX_LEAF);
52  			_treeView.addCanNotDropInList(INDEX_LEAF_INVALID);
53  			_treeView.addCanNotDragOutList(INDEX_CLEAN_ROOT);
54  			_treeView.addCanNotDragOutList(INDEX_DIRTY_ROOT);
55  			_treeView.addCanNotDragOutList(INDEX_PROJECT);
56  			_treeView.display();
57  			if (!openWorkSpace(_workSpaceFilePath.c_str(), true))
58  				newWorkSpace();
59  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
60  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
61  			return TRUE;
62  		}
63  		case NPPM_INTERNAL_REFRESHDARKMODE:
64  		{
65  			if (static_cast<BOOL>(lParam) != TRUE)
66  			{
67  				NppDarkMode::autoThemeChildControls(_hSelf);
68  			}
69  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
70  			return TRUE;
71  		}
72  		case WM_MOUSEMOVE:
73  			if (_treeView.isDragging())
74  				_treeView.dragItem(_hSelf, LOWORD(lParam), HIWORD(lParam));
75  			break;
76  		case WM_LBUTTONUP:
77  			if (_treeView.isDragging())
78  				if (_treeView.dropItem())
79  					setWorkSpaceDirty(true);
80  			break;
81  		case WM_NOTIFY:
82  		{
83  			notified((LPNMHDR)lParam);
84  		}
85  		return TRUE;
86  		case WM_SIZE:
87  		{
88  			int width = LOWORD(lParam);
89  			int height = HIWORD(lParam);
90  			RECT toolbarMenuRect{};
91  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
92  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
93  			HWND hwnd = _treeView.getHSelf();
94  			if (hwnd)
95  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + 2, width, height - toolbarMenuRect.bottom - 2, TRUE);
96  			break;
97  		}
98  		case WM_CONTEXTMENU:
99  			if (!_treeView.isDragging())
100  			{
101  				int xPos = GET_X_LPARAM(lParam);
102  				int yPos = GET_Y_LPARAM(lParam);
103  				if (xPos == -1 && yPos == -1)
104  				{
105  					HTREEITEM selectedItem = _treeView.getSelection();
106  					if (selectedItem)
107  					{
108  						RECT selectedItemRect{};
109  						if (TreeView_GetItemRect(_treeView.getHSelf(), selectedItem, &selectedItemRect, TRUE))
110  						{
111  							showContextMenuFromMenuKey(selectedItem, (selectedItemRect.left + selectedItemRect.right) / 2, (selectedItemRect.top + selectedItemRect.bottom) / 2);
112  						}
113  					}
114  				}
115  				else
116  				{
117  					showContextMenu(xPos, yPos);
118  				}
119  			}
120  		return TRUE;
121  		case WM_COMMAND:
122  		{
123  			popupMenuCmd(LOWORD(wParam));
124  			break;
125  		}
<span onclick='openModal()' class='match'>126  		case WM_DESTROY:
127  		{
128  			_treeView.destroy();
129  			destroyMenus();
130  			::DestroyWindow(_hToolbarMenu);
</span>131  			break;
132  		}
133  		default :
134  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
135  	}
136  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
137  }
138  bool ProjectPanel::checkIfNeedSave()
139  {
140  	if (_isDirty)
141  	{
142  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
143  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
144  		int res = pNativeSpeaker->messageBox("ProjectPanelChanged",
145  			_hSelf,
146  			TEXT("The workspace was modified. Do you want to save it?"),
147  			TEXT("$STR_REPLACE$"),
148  			MB_YESNOCANCEL | MB_ICONQUESTION,
149  			0,
150  			title);
151  		if (res == IDYES)
152  		{
153  			if (!saveWorkSpace())
154  				return false;
155  		}
156  		else if (res == IDNO)
157  		{
158  		}
159  		else
160  		{
161  			return false;
162  		}
163  	}
164  	return true;
165  }
166  void ProjectPanel::initMenus()
167  {
168  	_hWorkSpaceMenu = ::CreatePopupMenu();
169  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
170  	generic_string new_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWWS, PM_NEWWORKSPACE);
171  	generic_string open_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_OPENWS, PM_OPENWORKSPACE);
172  	generic_string reload_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_RELOADWS, PM_RELOADWORKSPACE);
173  	generic_string save_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEWS, PM_SAVEWORKSPACE);
174  	generic_string saveas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEASWS, PM_SAVEASWORKSPACE);
175  	generic_string saveacopyas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEACOPYASWS, PM_SAVEACOPYASWORKSPACE);
176  	generic_string newproject_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWPROJECT, PM_NEWPROJECTWORKSPACE);
177  	generic_string findinprojects_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_FINDINPROJECTSWS, PM_FINDINFILESWORKSPACE);
178  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWWS, new_workspace.c_str());
179  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_OPENWS, open_workspace.c_str());
180  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RELOADWS, reload_workspace.c_str());
181  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEWS, save_workspace.c_str());
182  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEASWS, saveas_workspace.c_str());
183  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEACOPYASWS, saveacopyas_workspace.c_str());
184  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
185  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWPROJECT, newproject_workspace.c_str());
186  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
187  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_FINDINPROJECTSWS, findinprojects_workspace.c_str());
188  	generic_string edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
189  	generic_string edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
190  	generic_string edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
191  	generic_string edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
192  	generic_string edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
193  	generic_string edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
194  	generic_string edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
195  	_hProjectMenu = ::CreatePopupMenu();
196  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
197  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
198  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
199  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
200  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER, edit_addfolder.c_str());
201  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES, edit_addfiles.c_str());
202  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
203  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER, edit_remove.c_str());
204  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
205  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
206  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
207  	edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
208  	edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
209  	edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
210  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
211  	_hFolderMenu = ::CreatePopupMenu();
212  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP,        edit_moveup.c_str());
213  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN,      edit_movedown.c_str());
214  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
215  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME,        edit_rename.c_str());
216  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER,     edit_addfolder.c_str());
217  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES,      edit_addfiles.c_str());
218  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
219  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER,  edit_remove.c_str());
220  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
221  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
222  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
223  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_DELETEFILE, PM_EDITREMOVE);
224  	generic_string edit_modifyfile = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MODIFYFILEPATH, PM_EDITMODIFYFILE);
225  	_hFileMenu = ::CreatePopupMenu();
226  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
227  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
228  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
229  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
230  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFILE, edit_remove.c_str());
231  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MODIFYFILEPATH, edit_modifyfile.c_str());
232  }
233  void ProjectPanel::destroyMenus() 
234  {
235  	::DestroyMenu(_hWorkSpaceMenu);
236  	::DestroyMenu(_hProjectMenu);
237  	::DestroyMenu(_hFolderMenu);
238  	::DestroyMenu(_hFileMenu);
239  }
240  bool ProjectPanel::openWorkSpace(const TCHAR *projectFileName, bool force)
241  {
242  	if ((!force) && (_workSpaceFilePath.length() > 0))
243  	{ 
244  		generic_string newWorkspace = projectFileName;
245  		if (newWorkspace == _workSpaceFilePath)
246  			return true;
247  		if (!saveWorkspaceRequest())
248  			return true;
249  	}
250  	TiXmlDocument *pXmlDocProject = new TiXmlDocument(projectFileName);
251  	bool loadOkay = pXmlDocProject->LoadFile();
252  	if (!loadOkay)
253  	{
254  		delete pXmlDocProject;
255  		return false;
256  	}
257  	TiXmlNode *root = pXmlDocProject->FirstChild(TEXT("NotepadPlus"));
258  	if (!root) 
259  	{
260  		delete pXmlDocProject;
261  		return false;
262  	}
263  	TiXmlNode *childNode = root->FirstChildElement(TEXT("Project"));
264  	if (!childNode) 
265  	{
266  		delete pXmlDocProject;
267  		return false;
268  	}
269  	if (!::PathFileExists(projectFileName))
270  	{
271  		delete pXmlDocProject;
272  		return false;
273  	}
274  	_treeView.removeAllItems();
275  	_workSpaceFilePath = projectFileName;
276  	TCHAR * fileName = PathFindFileName(projectFileName);
277  	HTREEITEM rootItem = _treeView.addItem(fileName, TVI_ROOT, INDEX_CLEAN_ROOT);
278  	for ( ; childNode ; childNode = childNode->NextSibling(TEXT("Project")))
279  	{
280  		HTREEITEM projectItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), rootItem, INDEX_PROJECT);
281  		buildTreeFrom(childNode, projectItem);
282  	}
283  	setWorkSpaceDirty(false);
284  	_treeView.expand(rootItem);
285  	delete pXmlDocProject;
286  	return loadOkay;
287  }
288  void ProjectPanel::newWorkSpace()
289  {
290  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
291  	generic_string workspace = pNativeSpeaker->getAttrNameStr(PM_WORKSPACEROOTNAME, "ProjectManager", "WorkspaceRootName");
292  	_treeView.addItem(workspace.c_str(), TVI_ROOT, INDEX_CLEAN_ROOT);
293  	setWorkSpaceDirty(false);
294  	_workSpaceFilePath = TEXT("");
295  }
296  bool ProjectPanel::saveWorkSpace()
297  {
298  	if (_workSpaceFilePath == TEXT(""))
299  	{
300  		return saveWorkSpaceAs(false);
301  	}
302  	else
303  	{
304  		if (!writeWorkSpace())
305  			return false;
306  		setWorkSpaceDirty(false);
307  		return true;
308  	} 
309  }
310  bool ProjectPanel::writeWorkSpace(const TCHAR *projectFileName, bool doUpdateGUI)
311  {
312  	const TCHAR * fn2write = projectFileName?projectFileName:_workSpaceFilePath.c_str();
313  	TiXmlDocument projDoc(fn2write);
314  	TiXmlNode *root = projDoc.InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
315  	TCHAR textBuffer[MAX_PATH] = { '\0' };
316  	TVITEM tvItem{};
317  	tvItem.mask = TVIF_TEXT;
318  	tvItem.pszText = textBuffer;
319  	tvItem.cchTextMax = MAX_PATH;
320  	HTREEITEM tvRoot = _treeView.getRoot();
321  	if (!tvRoot)
322  		return false;
323  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
324  		tvProj != NULL;
325  		tvProj = _treeView.getNextSibling(tvProj))
326  	{
327  		tvItem.hItem = tvProj;
328  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
329  		TiXmlNode *projRoot = root->InsertEndChild(TiXmlElement(TEXT("Project")));
330  		projRoot->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
331  		buildProjectXml(projRoot, tvProj, fn2write);
332  	}
333  	if (!projDoc.SaveFile())
334  	{
335  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
336  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
337  		pNativeSpeaker->messageBox("ProjectPanelSaveError",
338  		_hSelf,
339  		TEXT("An error occurred while writing your workspace file.\nYour workspace has not been saved."),
340  		TEXT("$STR_REPLACE$"),
341  		MB_OK | MB_ICONERROR,
342  		0,
343  		title);
344  		return false;
345  	}
346  	TCHAR * fileName = PathFindFileName(fn2write);
347  	if (doUpdateGUI)
348  	{
349  		_treeView.renameItem(tvRoot, fileName);
350  	}
351  	return true;
352  }
353  void ProjectPanel::buildProjectXml(TiXmlNode *node, HTREEITEM hItem, const TCHAR* fn2write)
354  {
355  	TCHAR textBuffer[MAX_PATH] = { '\0' };
356  	TVITEM tvItem{};
357  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
358  	tvItem.pszText = textBuffer;
359  	tvItem.cchTextMax = MAX_PATH;
360  	for (HTREEITEM hItemNode = _treeView.getChildFrom(hItem);
361  		hItemNode != NULL;
362  		hItemNode = _treeView.getNextSibling(hItemNode))
363  	{
364  		tvItem.hItem = hItemNode;
365  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
366  		if (tvItem.lParam)
367  		{
368  			generic_string *fn = (generic_string *)tvItem.lParam;
369  			generic_string newFn = getRelativePath(*fn, fn2write);
370  			TiXmlNode *fileLeaf = node->InsertEndChild(TiXmlElement(TEXT("File")));
371  			fileLeaf->ToElement()->SetAttribute(TEXT("name"), newFn.c_str());
372  		}
373  		else
374  		{
375  			TiXmlNode *folderNode = node->InsertEndChild(TiXmlElement(TEXT("Folder")));
376  			folderNode->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
377  			buildProjectXml(folderNode, hItemNode, fn2write);
378  		}
379  	}
380  }
381  bool ProjectPanel::enumWorkSpaceFiles(HTREEITEM tvFrom, const std::vector<generic_string> & patterns, std::vector<generic_string> & fileNames)
382  {
383  	TCHAR textBuffer[MAX_PATH] = { '\0' };
384  	TVITEM tvItem{};
385  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
386  	tvItem.pszText = textBuffer;
387  	tvItem.cchTextMax = MAX_PATH;
388  	HTREEITEM tvRoot = tvFrom ? tvFrom : _treeView.getRoot();
389  	if (!tvRoot) return false;
390  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
391  		tvProj != NULL;
392  		tvProj = _treeView.getNextSibling(tvProj))
393  	{
394  		tvItem.hItem = tvProj;
395  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
396  		if (tvItem.lParam)
397  		{
398  			if (matchInList(tvItem.pszText, patterns))
399  			{
400  				generic_string *fn = (generic_string *)tvItem.lParam;
401  				fileNames.push_back (*fn);
402  			}
403  		}
404  		else
405  		{
406  			if (!enumWorkSpaceFiles (tvProj, patterns, fileNames)) return false;
407  		}
408  	}
409  	return true;
410  }
411  generic_string ProjectPanel::getRelativePath(const generic_string & filePath, const TCHAR *workSpaceFileName)
412  {
413  	TCHAR wsfn[MAX_PATH] = { '\0' };
414  	wcscpy_s(wsfn, workSpaceFileName);
415  	::PathRemoveFileSpec(wsfn);
416  	size_t pos_found = filePath.find(wsfn);
417  	if (pos_found == generic_string::npos)
418  		return filePath;
419  	const TCHAR *relativeFile = filePath.c_str() + lstrlen(wsfn);
420  	if (relativeFile[0] == '\\')
421  		++relativeFile;
422  	return relativeFile;
423  }
424  bool ProjectPanel::buildTreeFrom(TiXmlNode *projectRoot, HTREEITEM hParentItem)
425  {
426  	for (TiXmlNode *childNode = projectRoot->FirstChildElement();
427  		childNode ;
428  		childNode = childNode->NextSibling())
429  	{
430  		const TCHAR *v = childNode->Value();
431  		if (lstrcmp(TEXT("Folder"), v) == 0)
432  		{
433  			HTREEITEM addedItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), hParentItem, INDEX_CLOSED_NODE);
434  			if (!childNode->NoChildren())
435  			{
436  				bool isOK = buildTreeFrom(childNode, addedItem);
437  				if (!isOK)
438  					return false;
439  			}
440  		}
441  		else if (lstrcmp(TEXT("File"), v) == 0)
442  		{
443  			const TCHAR *strValue = (childNode->ToElement())->Attribute(TEXT("name"));
444  			generic_string fullPath = getAbsoluteFilePath(strValue);
445  			TCHAR *strValueLabel = ::PathFindFileName(strValue);
446  			int iImage = ::PathFileExists(fullPath.c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
447  			generic_string* fullPathStr = new generic_string(fullPath);
448  			fullPathStrs.push_back(fullPathStr);
449  			LPARAM lParamFullPathStr = reinterpret_cast<LPARAM>(fullPathStr);
450  			_treeView.addItem(strValueLabel, hParentItem, iImage, lParamFullPathStr);
451  		}
452  	}
453  	return true;
454  }
455  generic_string ProjectPanel::getAbsoluteFilePath(const TCHAR * relativePath)
456  {
457  	if (!::PathIsRelative(relativePath))
458  		return relativePath;
459  	TCHAR absolutePath[MAX_PATH] = { '\0' };
460  	wcscpy_s(absolutePath, _workSpaceFilePath.c_str());
461  	::PathRemoveFileSpec(absolutePath);
462  	::PathAppend(absolutePath, relativePath);
463  	return absolutePath;
464  }
465  void ProjectPanel::openSelectFile()
466  {
467  	TVITEM tvItem{};
468  	tvItem.mask = TVIF_PARAM;
469  	tvItem.hItem = _treeView.getSelection();
470  	::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
471  	NodeType nType = getNodeType(tvItem.hItem);
472  	generic_string *fn = (generic_string *)tvItem.lParam;
473  	if (nType == nodeType_file && fn)
474  	{
475  		tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
476  		if (::PathFileExists(fn->c_str()))
477  		{
478  			::PostMessage(_hParent, NPPM_DOOPEN, 0, reinterpret_cast<LPARAM>(fn->c_str()));
479  			tvItem.iImage = INDEX_LEAF;
480  			tvItem.iSelectedImage = INDEX_LEAF;
481  		}
482  		else
483  		{
484  			tvItem.iImage = INDEX_LEAF_INVALID;
485  			tvItem.iSelectedImage = INDEX_LEAF_INVALID;
486  		}
487  		TreeView_SetItem(_treeView.getHSelf(), &tvItem);
488  	}
489  }
490  void ProjectPanel::notified(LPNMHDR notification)
491  {
492  	if (notification->code == DMN_CLOSE)
493  	{
494  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_PROJECT_PANEL_1 + _panelID, 0);
495  		SetWindowLongPtr (getHSelf(), DWLP_MSGRESULT, _isClosed ? 0 : 1);
496  	}
497  	else if (notification->hwndFrom == _treeView.getHSelf())
498  	{
499  		TCHAR textBuffer[MAX_PATH] = { '\0' };
500  		TVITEM tvItem{};
501  		tvItem.mask = TVIF_TEXT | TVIF_PARAM;
502  		tvItem.pszText = textBuffer;
503  		tvItem.cchTextMax = MAX_PATH;
504  		switch (notification->code)
505  		{
506  			case NM_DBLCLK:
507  			{
508  				openSelectFile();
509  			}
510  			break;
511  			case NM_RETURN:
512  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1);
513  			break;
514  			case TVN_ENDLABELEDIT:
515  			{
516  				LPNMTVDISPINFO tvnotif = (LPNMTVDISPINFO)notification;
517  				if (!tvnotif->item.pszText)
518  					return;
519  				if (getNodeType(tvnotif->item.hItem) == nodeType_root)
520  					return;
521  				if (tvnotif->item.lParam) 
522  				{
523  					tvItem.hItem = _treeView.getSelection();
524  					::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
525  					size_t len = lstrlen(tvItem.pszText);
526  					generic_string *filePath = (generic_string *)tvnotif->item.lParam;
527  					size_t found = filePath->rfind(tvItem.pszText);
528  					if (found != generic_string::npos)
529  						filePath->replace(found, len, tvnotif->item.pszText);
530  					tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
531  					if (::PathFileExists(filePath->c_str()))
532  					{
533  						tvItem.iImage = INDEX_LEAF;
534  						tvItem.iSelectedImage = INDEX_LEAF;
535  					}
536  					else
537  					{
538  						tvItem.iImage = INDEX_LEAF_INVALID;
539  						tvItem.iSelectedImage = INDEX_LEAF_INVALID;
540  					}
541  					TreeView_SetItem(_treeView.getHSelf(), &tvItem);
542  				}
543  				::SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&(tvnotif->item)));
544  				setWorkSpaceDirty(true);
545  			}
546  			break;
547  			case TVN_GETINFOTIP:
548  			{
549  				LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)notification;
550  				generic_string *str = NULL ;
551  				if (_treeView.getRoot() == lpGetInfoTip->hItem)
552  				{
553  					str = &_workSpaceFilePath;
554  				}
555  				else
556  				{
557  					str = (generic_string *)lpGetInfoTip->lParam;
558  					if (!str)
559  						return;
560  				}
561  				lpGetInfoTip->pszText = (LPTSTR)str->c_str();
562  				lpGetInfoTip->cchTextMax = static_cast<int32_t>(str->size());
563  			}
564  			break;
565  			case TVN_KEYDOWN:
566  			{
567  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
568  				if (ptvkd->wVKey == VK_DELETE)
569  				{
570  					HTREEITEM hItem = _treeView.getSelection();
571  					NodeType nType = getNodeType(hItem);
572  					if (nType == nodeType_project || nType == nodeType_folder)
573  						popupMenuCmd(IDM_PROJECT_DELETEFOLDER);
574  					else if (nType == nodeType_file)
575  						popupMenuCmd(IDM_PROJECT_DELETEFILE);
576  				}
577  				else if (ptvkd->wVKey == VK_RETURN)
578  				{
579  					HTREEITEM hItem = _treeView.getSelection();
580  					NodeType nType = getNodeType(hItem);
581  					if (nType == nodeType_file)
582  						openSelectFile();
583  					else
584  						_treeView.toggleExpandCollapse(hItem);
585  				}
586  				else if (ptvkd->wVKey == VK_UP)
587  				{
588  					if (0x80 & GetKeyState(VK_CONTROL))
589  					{
590  						popupMenuCmd(IDM_PROJECT_MOVEUP);
591  					}
592  				}
593  				else if (ptvkd->wVKey == VK_DOWN)
594  				{
595  					if (0x80 & GetKeyState(VK_CONTROL))
596  					{
597  						popupMenuCmd(IDM_PROJECT_MOVEDOWN);
598  					}
599  				}
600  				else if (ptvkd->wVKey == VK_F2)
601  					popupMenuCmd(IDM_PROJECT_RENAME);
602  			}
603  			break;
604  			case TVN_ITEMEXPANDED:
605  			{
606  				LPNMTREEVIEW nmtv = (LPNMTREEVIEW)notification;
607  				tvItem.hItem = nmtv->itemNew.hItem;
608  				tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
609  				if (getNodeType(nmtv->itemNew.hItem) == nodeType_folder)
610  				{
611  					if (nmtv->action == TVE_COLLAPSE)
612  					{
613  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
614  					}
615  					else if (nmtv->action == TVE_EXPAND)
616  					{
617  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
618  					}
619  				}
620  			}
621  			break;
622  			case TVN_BEGINDRAG:
623  			{
624  				_treeView.beginDrag((LPNMTREEVIEW)notification);
625  			}
626  			break;
627  		}
628  	}
629  }
630  void ProjectPanel::setWorkSpaceDirty(bool isDirty)
631  {
632  	_isDirty = isDirty;
633  	int iImg = _isDirty?INDEX_DIRTY_ROOT:INDEX_CLEAN_ROOT;
634  	_treeView.setItemImage(_treeView.getRoot(), iImg, iImg);
635  }
636  NodeType ProjectPanel::getNodeType(HTREEITEM hItem)
637  {
638  	TVITEM tvItem{};
639  	tvItem.hItem = hItem;
640  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
641  	SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
642  	if (tvItem.iImage == INDEX_CLEAN_ROOT || tvItem.iImage == INDEX_DIRTY_ROOT)
643  	{
644  		return nodeType_root;
645  	}
646  	else if (tvItem.iImage == INDEX_PROJECT)
647  	{
648  		return nodeType_project;
649  	}
650  	else if (!tvItem.lParam)
651  	{
652  		return nodeType_folder;
653  	}
654  	else
655  	{
656  		return nodeType_file;
657  	}
658  }
659  void ProjectPanel::showContextMenu(int x, int y)
660  {
661  	TVHITTESTINFO tvHitInfo{};
662  	tvHitInfo.pt.x = x;
663  	tvHitInfo.pt.y = y;
664  	tvHitInfo.flags = 0;
665  	ScreenToClient(_treeView.getHSelf(), &(tvHitInfo.pt));
666  	TreeView_HitTest(_treeView.getHSelf(), &tvHitInfo);
667  	if (tvHitInfo.hItem != NULL)
668  	{
669  		_treeView.selectItem(tvHitInfo.hItem);
670  		HMENU hMenu = getMenuHandler(tvHitInfo.hItem);
671  		TrackPopupMenu(hMenu,
672  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
673  			x, y, 0, _hSelf, NULL);
674  	}
675  }
676  void ProjectPanel::showContextMenuFromMenuKey(HTREEITEM selectedItem, int x, int y)
677  {
678  	POINT p{};
679  	p.x = x;
680  	p.y = y;
681  	ClientToScreen(_treeView.getHSelf(), &p);
682  	if (selectedItem != NULL)
683  	{
684  		HMENU hMenu = getMenuHandler(selectedItem);
685  		TrackPopupMenu(hMenu,
686  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
687  			x, y, 0, _hSelf, NULL);
688  	}
689  }
690  HMENU ProjectPanel::getMenuHandler(HTREEITEM selectedItem)
691  {
692  	NodeType nodeType = getNodeType(selectedItem);
693  	HMENU hMenu = NULL;
694  	if (nodeType == nodeType_root)
695  		hMenu = _hWorkSpaceMenu;
696  	else if (nodeType == nodeType_project)
697  		hMenu = _hProjectMenu;
698  	else if (nodeType == nodeType_folder)
699  		hMenu = _hFolderMenu;
700  	else 
701  		hMenu = _hFileMenu;
702  	return hMenu;
703  }
704  POINT ProjectPanel::getMenuDisplayPoint(int iButton)
705  {
706  	POINT p{};
707  	RECT btnRect{};
708  	SendMessage(_hToolbarMenu, TB_GETITEMRECT, iButton, reinterpret_cast<LPARAM>(&btnRect));
709  	p.x = btnRect.left;
710  	p.y = btnRect.top + btnRect.bottom;
711  	ClientToScreen(_hToolbarMenu, &p);
712  	return p;
713  }
714  HTREEITEM ProjectPanel::addFolder(HTREEITEM hTreeItem, const TCHAR *folderName)
715  {
716  	HTREEITEM addedItem = _treeView.addItem(folderName, hTreeItem, INDEX_CLOSED_NODE);
717  	TreeView_Expand(_treeView.getHSelf(), hTreeItem, TVE_EXPAND);
718  	TreeView_EditLabel(_treeView.getHSelf(), addedItem);
719  	if (getNodeType(hTreeItem) == nodeType_folder)
720  		_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
721  	return addedItem;
722  }
723  bool ProjectPanel::saveWorkspaceRequest()
724  { 
725  	if (_isDirty)
726  	{
727  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
728  		int res = pNativeSpeaker->messageBox("ProjectPanelOpenDoSaveDirtyWsOrNot",
729  					_hSelf,
730  					TEXT("The current workspace was modified. Do you want to save the current project?"),
731  					TEXT("Open Workspace"),
732  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
733  		if (res == IDYES)
734  		{
735  			if (!saveWorkSpace())
736  				return false;
737  		}
738  		else if (res == IDNO)
739  		{
740  		}
741  		else if (res == IDCANCEL) 
742  		{
743  			return false;
744  		}
745  	}
746  	return true;
747  }
748  void ProjectPanel::popupMenuCmd(int cmdID)
749  {
750  	HTREEITEM hTreeItem = _treeView.getSelection();
751  	if (!hTreeItem)
752  		return;
753  	switch (cmdID)
754  	{
755  		case IDB_PROJECT_BTN:
756  		{
757  		  POINT p = getMenuDisplayPoint(0);
758  		  TrackPopupMenu(_hWorkSpaceMenu,
759  			  NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
760  			  p.x, p.y, 0, _hSelf, NULL);
761  		}
762  		break;
763  		case IDB_EDIT_BTN:
764  		{
765  			POINT p = getMenuDisplayPoint(1);
766  			HMENU hMenu = NULL;
767  			NodeType nodeType = getNodeType(hTreeItem);
768  			if (nodeType == nodeType_project)
769  				hMenu = _hProjectMenu;
770  			else if (nodeType == nodeType_folder)
771  				hMenu = _hFolderMenu;
772  			else if (nodeType == nodeType_file)
773  				hMenu = _hFileMenu;
774  			if (hMenu)
775  				TrackPopupMenu(hMenu,
776  					NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
777  					p.x, p.y, 0, _hSelf, NULL);
778  		}
779  		break;
780  		case IDM_PROJECT_NEWPROJECT :
781  		{
782  			HTREEITEM root = _treeView.getRoot();
783  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
784  			generic_string newProjectLabel = pNativeSpeaker->getAttrNameStr(PM_NEWPROJECTNAME, "ProjectManager", "NewProjectName");
785  			HTREEITEM addedItem = _treeView.addItem(newProjectLabel.c_str(),  root, INDEX_PROJECT);
786  			setWorkSpaceDirty(true);
787  			_treeView.expand(hTreeItem);
788  			TreeView_EditLabel(_treeView.getHSelf(), addedItem);
789  		}
790  		break;
791  		case IDM_PROJECT_NEWWS :
792  		{
793  			if (_isDirty)
794  			{
795  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
796  				int res = pNativeSpeaker->messageBox("ProjectPanelNewDoSaveDirtyWsOrNot",
797  					_hSelf,
798  					TEXT("The current workspace was modified. Do you want to save the current project?"),
799  					TEXT("New Workspace"),
800  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
801  				if (res == IDYES)
802  				{
803  					if (!saveWorkSpace())
804  						return;
805  				}
806  				else if (res == IDNO)
807  				{
808  				}
809  				else if (res == IDCANCEL) 
810  				{
811  					return;
812  				}
813  			}
814  			_treeView.removeAllItems();
815  			newWorkSpace();
816  		}
817  		break;
818  		case IDM_PROJECT_RENAME :
819  			TreeView_EditLabel(_treeView.getHSelf(), hTreeItem);
820  		break;
821  		case IDM_PROJECT_NEWFOLDER :
822  		{
823  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
824  			generic_string newFolderLabel = pNativeSpeaker->getAttrNameStr(PM_NEWFOLDERNAME, "ProjectManager", "NewFolderName");
825  			addFolder(hTreeItem, newFolderLabel.c_str());
826  			setWorkSpaceDirty(true);
827  		}
828  		break;
829  		case IDM_PROJECT_MOVEDOWN :
830  		{
831  			if (_treeView.moveDown(hTreeItem))
832  				setWorkSpaceDirty(true);
833  		}
834  		break;
835  		case IDM_PROJECT_MOVEUP :
836  		{
837  			if (_treeView.moveUp(hTreeItem))
838  				setWorkSpaceDirty(true);
839  		}
840  		break;
841  		case IDM_PROJECT_ADDFILES :
842  		{
843  			addFiles(hTreeItem);
844  			if (getNodeType(hTreeItem) == nodeType_folder)
845  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
846  		}
847  		break;
848  		case IDM_PROJECT_ADDFILESRECUSIVELY :
849  		{
850  			addFilesFromDirectory(hTreeItem);
851  			if (getNodeType(hTreeItem) == nodeType_folder)
852  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
853  		}
854  		break;
855  		case IDM_PROJECT_OPENWS:
856  		{
857  			if (!saveWorkspaceRequest())
858  				break;
859  			CustomFileDialog fDlg(_hSelf);
860  			setFileExtFilter(fDlg);
861  			const generic_string fn = fDlg.doOpenSingleFileDlg();
862  			if (!fn.empty())
863  			{
864  				if (!openWorkSpace(fn.c_str(), true))
865  				{
866  					NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
867  					pNativeSpeaker->messageBox("ProjectPanelOpenFailed",
868  						_hSelf,
869  						TEXT("The workspace could not be opened.\rIt seems the file to open is not a valid project file."),
870  						TEXT("Open Workspace"),
871  						MB_OK);
872  					return;
873  				}
874  			}
875  		}
876  		break;
877  		case IDM_PROJECT_RELOADWS:
878  		{
879  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
880  			bool forceOpen = false;
881  			if (_isDirty)
882  			{
883  				int res = pNativeSpeaker->messageBox("ProjectPanelReloadDirty",
884  					_hSelf,
885  					TEXT("The current workspace was modified. Reloading will discard all modifications.\rDo you want to continue?"),
886  					TEXT("Reload Workspace"),
887  					MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);
888  				if (res == IDYES)
889  				{
890  					forceOpen = true;
891  				}
892  				else if (res == IDNO)
893  				{
894  					return;
895  				}
896  			}
897  			if (::PathFileExists(_workSpaceFilePath.c_str()))
898  			{
899  				openWorkSpace(_workSpaceFilePath.c_str(), forceOpen);
900  			}
901  			else
902  			{
903  				pNativeSpeaker->messageBox("ProjectPanelReloadError",
904  					_hSelf,
905  					TEXT("Cannot find the file to reload."),
906  					TEXT("Reload Workspace"),
907  					MB_OK);
908  			}
909  		}
910  		break;
911  		case IDM_PROJECT_SAVEWS:
912  			saveWorkSpace();
913  		break;
914  		case IDM_PROJECT_SAVEACOPYASWS:
915  		case IDM_PROJECT_SAVEASWS:
916  		{
917  			saveWorkSpaceAs(cmdID == IDM_PROJECT_SAVEACOPYASWS);
918  		}
919  		break;
920  		case IDM_PROJECT_FINDINPROJECTSWS:
921  		{
922  			::SendMessage(_hParent, NPPM_INTERNAL_FINDINPROJECTS, (WPARAM) 1 << _panelID, 0);
923  		}
924  		break;
925  		case IDM_PROJECT_DELETEFOLDER :
926  		{
927  			HTREEITEM parent = _treeView.getParent(hTreeItem);
928  			if (_treeView.getChildFrom(hTreeItem) != NULL)
929  			{
930  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
931  				int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFolderFromProject",
932  					_hSelf,
933  					TEXT("All the sub-items will be removed.\rAre you sure you want to remove this folder from the project?"),
934  					TEXT("Remove folder from project"),
935  					MB_YESNO);
936  				if (res == IDYES)
937  				{
938  					_treeView.removeItem(hTreeItem);
939  					setWorkSpaceDirty(true);
940  				}
941  			}
942  			else
943  			{
944  				_treeView.removeItem(hTreeItem);
945  				setWorkSpaceDirty(true);
946  			}
947  			if (getNodeType(parent) == nodeType_folder)
948  				_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
949  		}
950  		break;
951  		case IDM_PROJECT_DELETEFILE :
952  		{
953  			HTREEITEM parent = _treeView.getParent(hTreeItem);
954  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
955  			int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFileFromProject",
956  				_hSelf,
957  				TEXT("Are you sure you want to remove this file from the project?"),
958  				TEXT("Remove file from project"),
959  				MB_YESNO);
960  			if (res == IDYES)
961  			{
962  				_treeView.removeItem(hTreeItem);
963  				setWorkSpaceDirty(true);
964  				if (getNodeType(parent) == nodeType_folder)
965  					_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
966  			}
967  		}
968  		break;
969  		case IDM_PROJECT_MODIFYFILEPATH :
970  		{
971  			FileRelocalizerDlg fileRelocalizerDlg;
972  			fileRelocalizerDlg.init(_hInst, _hParent);
973  			TCHAR textBuffer[MAX_PATH] = { '\0' };
974  			TVITEM tvItem{};
975  			tvItem.hItem = hTreeItem;
976  			tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
977  			tvItem.pszText = textBuffer;
978  			tvItem.cchTextMax = MAX_PATH;
979  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
980  			if (!tvItem.lParam)
981  				return;
982  			generic_string * fn = (generic_string *)tvItem.lParam;
983  			if (fileRelocalizerDlg.doDialog(fn->c_str()) == 0)
984  			{
985  				generic_string newValue = fileRelocalizerDlg.getFullFilePath();
986  				if (*fn == newValue)
987  					return;
988  				*fn = newValue;
989  				TCHAR *strValueLabel = ::PathFindFileName(fn->c_str());
990  				wcscpy_s(textBuffer, strValueLabel);
991  				int iImage = ::PathFileExists(fn->c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
992  				tvItem.iImage = tvItem.iSelectedImage = iImage;
993  				SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
994  				setWorkSpaceDirty(true);
995  			}
996  		}
997  		break;
998  	}
999  }
1000  bool ProjectPanel::saveWorkSpaceAs(bool saveCopyAs)
1001  {
1002  	CustomFileDialog fDlg(_hSelf);
1003  	setFileExtFilter(fDlg);
1004  	fDlg.setExtIndex(0);		
1005  	const generic_string fn = fDlg.doSaveDlg();
1006  	if (fn.empty())
1007  		return false;
1008  	if (!writeWorkSpace(fn.c_str(), !saveCopyAs))
1009  		return false;
1010  	if (!saveCopyAs)
1011  	{
1012  		_workSpaceFilePath = fn;
1013  		setWorkSpaceDirty(false);
1014  	}
1015  	return true;
1016  }
1017  void ProjectPanel::setFileExtFilter(CustomFileDialog & fDlg)
1018  {
1019  	const TCHAR *ext = NppParameters::getInstance().getNppGUI()._definedWorkspaceExt.c_str();
1020  	generic_string workspaceExt = TEXT("");
1021  	if (*ext != '\0')
1022  	{
1023  		if (*ext != '.')
1024  			workspaceExt += TEXT(".");
1025  		workspaceExt += ext;
1026  		fDlg.setExtFilter(TEXT("Workspace file"), workspaceExt.c_str());
1027  		fDlg.setDefExt(ext);
1028  	}
1029  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1030  }
1031  void ProjectPanel::addFiles(HTREEITEM hTreeItem)
1032  {
1033  	CustomFileDialog fDlg(_hSelf);
1034  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1035  	const auto& fns = fDlg.doOpenMultiFilesDlg();
1036  	if (!fns.empty())
1037  	{
1038  		size_t sz = fns.size();
1039  		for (size_t i = 0 ; i < sz ; ++i)
1040  		{
1041  			TCHAR *strValueLabel = ::PathFindFileName(fns.at(i).c_str());
1042  			generic_string* pathFileStr = new generic_string(fns.at(i));
1043  			fullPathStrs.push_back(pathFileStr);
1044  			LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1045  			_treeView.addItem(strValueLabel, hTreeItem, INDEX_LEAF, lParamPathFileStr);
1046  		}
1047  		_treeView.expand(hTreeItem);
1048  		setWorkSpaceDirty(true);
1049  	}
1050  }
1051  void ProjectPanel::recursiveAddFilesFrom(const TCHAR *folderPath, HTREEITEM hTreeItem)
1052  {
1053  	bool isRecursive = true;
1054  	bool isInHiddenDir = false;
1055  	generic_string dirFilter(folderPath);
1056  	if (folderPath[lstrlen(folderPath)-1] != '\\')
1057  		dirFilter += TEXT("\\");
1058  	dirFilter += TEXT("*.*");
1059  	WIN32_FIND_DATA foundData;
1060  	std::vector<generic_string> files;
1061  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
1062  	do {
1063  		if (hFile == INVALID_HANDLE_VALUE)
1064  			break;
1065  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1066  		{
1067  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1068  			{
1069  			}
1070  			else if (isRecursive)
1071  			{
1072  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0))
1073  				{
1074  					generic_string pathDir(folderPath);
1075  					if (folderPath[lstrlen(folderPath)-1] != '\\')
1076  						pathDir += TEXT("\\");
1077  					pathDir += foundData.cFileName;
1078  					pathDir += TEXT("\\");
1079  					HTREEITEM addedItem = addFolder(hTreeItem, foundData.cFileName);
1080  					recursiveAddFilesFrom(pathDir.c_str(), addedItem);
1081  				}
1082  			}
1083  		}
1084  		else
1085  		{
1086  			files.push_back(foundData.cFileName);
1087  		}
1088  	} while (::FindNextFile(hFile, &foundData));
1089  	for (size_t i = 0, len = files.size() ; i < len ; ++i)
1090  	{
1091  		generic_string pathFile(folderPath);
1092  		if (folderPath[lstrlen(folderPath)-1] != '\\')
1093  			pathFile += TEXT("\\");
1094  		pathFile += files[i];
1095  		generic_string* pathFileStr = new generic_string(pathFile);
1096  		fullPathStrs.push_back(pathFileStr);
1097  		LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1098  		_treeView.addItem(files[i].c_str(), hTreeItem, INDEX_LEAF, lParamPathFileStr);
1099  	}
1100  	::FindClose(hFile);
1101  }
1102  void ProjectPanel::addFilesFromDirectory(HTREEITEM hTreeItem)
1103  {
1104  	if (_selDirOfFilesFromDirDlg == TEXT("") && _workSpaceFilePath != TEXT(""))
1105  	{
1106  		TCHAR dir[MAX_PATH] = { '\0' };
1107  		wcscpy_s(dir, _workSpaceFilePath.c_str());
1108  		::PathRemoveFileSpec(dir);
1109  		_selDirOfFilesFromDirDlg = dir;
1110  	}
1111  	generic_string dirPath;
1112  	if (_selDirOfFilesFromDirDlg != TEXT(""))
1113  		dirPath = getFolderName(_hSelf, _selDirOfFilesFromDirDlg.c_str());
1114  	else
1115  		dirPath = getFolderName(_hSelf);
1116  	if (dirPath != TEXT(""))
1117  	{
1118  		recursiveAddFilesFrom(dirPath.c_str(), hTreeItem);
1119  		_treeView.expand(hTreeItem);
1120  		setWorkSpaceDirty(true);
1121  		_selDirOfFilesFromDirDlg = dirPath;
1122  	}
1123  }
1124  intptr_t CALLBACK FileRelocalizerDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM) 
1125  {
1126  	switch (Message)
1127  	{
1128  		case WM_INITDIALOG:
1129  		{
1130  			::SetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, _fullFilePath.c_str());
1131  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
1132  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
1133  			return TRUE;
1134  		}
1135  		case WM_ERASEBKGND:
1136  		{
1137  			if (NppDarkMode::isEnabled())
1138  			{
1139  				RECT rect{};
1140  				GetClientRect(_hSelf, &rect);
1141  				::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
1142  				return TRUE;
1143  			}
1144  			break;
1145  		}
1146  		case WM_CTLCOLOREDIT:
1147  		{
1148  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1149  		}
1150  		case WM_PRINTCLIENT:
1151  		{
1152  			if (NppDarkMode::isEnabled())
1153  			{
1154  				return TRUE;
1155  			}
1156  			break;
1157  		}
1158  		case WM_COMMAND:
1159  		{
1160  			switch (wParam)
1161  			{
1162  				case IDOK :
1163  				{
1164  					TCHAR textBuf[MAX_PATH] = { '\0' };
1165  					::GetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, textBuf, MAX_PATH);
1166  					_fullFilePath = textBuf;
1167  					::EndDialog(_hSelf, 0);
1168  				}
1169  				return TRUE;
1170  				case IDCANCEL :
1171  					::EndDialog(_hSelf, -1);
1172  				return TRUE;
1173  				default:
1174  					return FALSE;
1175  			}
1176  		}
1177  		default :
1178  			return FALSE;
1179  	}
1180  	return FALSE;
1181  }
1182  int FileRelocalizerDlg::doDialog(const TCHAR *fn, bool isRTL)
1183  {
1184  	_fullFilePath = fn;
1185  	if (isRTL)
1186  	{
1187  		DLGTEMPLATE *pMyDlgTemplate = NULL;
1188  		HGLOBAL hMyDlgTemplate = makeRTLResource(IDD_FILERELOCALIZER_DIALOG, &pMyDlgTemplate);
1189  		int result = static_cast<int32_t>(::DialogBoxIndirectParam(_hInst, pMyDlgTemplate, _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1190  		::GlobalFree(hMyDlgTemplate);
1191  		return result;
1192  	}
1193  	return static_cast<int32_t>(::DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_FILERELOCALIZER_DIALOG), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-documentMap.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>244  				case DMN_SWITCHIN:
245  				{
246  					_vzDlg.display();
247  					reloadMap();
248  					setSyntaxHiliting();
</pre></code></div>
                <div class="column column_space"><pre><code>126  		case WM_DESTROY:
127  		{
128  			_treeView.destroy();
129  			destroyMenus();
130  			::DestroyWindow(_hToolbarMenu);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    