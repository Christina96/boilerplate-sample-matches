
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "memes.h"
3  int TQuote::GetFq() const {
4    int fq=0;
5    for(int i=0; i<TmUrlCntV.Len(); i++) {
6      fq+=TmUrlCntV[i].Cnt(); }
7    return fq;
8  }
9  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm) const {
10    int fq=0;
11    for(int i=0; i<TmUrlCntV.Len(); i++) {
12      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm) {
13        fq += TmUrlCntV[i].Cnt(); } 
14    }
15    return fq;
16  }
17  int TQuote::GetDoms(const TQuoteBs& QtBs) const {
18    THashSet<TChA> DomSet;
19    for (int u = 0; u < TmUrlCntV.Len(); u++) {
20      DomSet.AddKey(TStrUtil::GetDomNm(QtBs.GetStr(TmUrlCntV[u].UrlId())));
21    }
22    return DomSet.Len();
23  }
24  int TQuote::GetFq(const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
25    int fq=0;
26    for(int i=0; i<TmUrlCntV.Len(); i++) {
27      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
28        fq += TmUrlCntV[i].Cnt(); } 
29    }
30    return fq;
31  }
32  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
33    int fq=0;
34    for(int i=0; i<TmUrlCntV.Len(); i++) {
35      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() <= EndTm &&
36       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
37        fq+=1; }
38    }
39    return fq;
40  }
41  int TQuote::GetUrls(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
42    int urls=0;
43    for(int i=0; i<TmUrlCntV.Len(); i++) {
44      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm &&
45       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
46        urls+=1; }
47    }
48    return urls;
49  }
50  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm) const {
51    TInt FreqAtPeak;
52    return GetPeakTm(TmUnit, AfterTm, FreqAtPeak);
53  }
54  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, TInt& FreqAtPeak) const {
55    const TSecTm After = AfterTm.Round(TmUnit);
56    THash<TSecTm, TInt> TmFqH;
57    for(int i=0; i<TmUrlCntV.Len(); i++) {
58      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After) {
59        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); }
60    }
61    if (TmFqH.Empty()) {
62      FreqAtPeak = 0;
63      return GetPeakTm(TmUnit, TSecTm(1));
64    }
65    TmFqH.SortByDat(false);
66    FreqAtPeak = TmFqH[0];
67    return TmFqH.GetKey(0);
68  }
69  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
70    const TSecTm After = AfterTm.Round(TmUnit);
71    THash<TSecTm, TInt> TmFqH;
72    for(int i=0; i<TmUrlCntV.Len(); i++) {
73      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
74        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); } 
75    }
76    if (TmFqH.Empty()) {
77      return GetPeakTm(TmUnit, TSecTm(1)); }
78    TmFqH.SortByDat(false);
79    return TmFqH.GetKey(0);
80  }
81  TSecTm TQuote::GetMeanTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
82    const TSecTm After = AfterTm.Round(TmUnit);
83    double MeanTm = 0;
84    int Cnt = 0;
85    for(int i=0; i<TmUrlCntV.Len(); i++) {
86      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
87        MeanTm += TmUrlCntV[i].Tm().Round(TmUnit) * TmUrlCntV[i].Cnt();
88        Cnt += TmUrlCntV[i].Cnt();
89      }
90    }
91    return TSecTm(uint(MeanTm/double(Cnt))).Round(TmUnit);
92  }
93  TSecTm TQuote::GetMedianTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
94    const TSecTm After = AfterTm.Round(TmUnit);
95    TMom Mom;
96    for(int i=0; i<TmUrlCntV.Len(); i++) {
97      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
98        Mom.Add(TmUrlCntV[i].Tm().Round(TmUnit).GetAbsSecs(), TmUrlCntV[i].Cnt());
99      }
100    }
101    Mom.Def();
102    return TSecTm(uint(Mom.GetMedian())).Round(TmUnit);
103  }
104  bool TQuote::IsSinglePeak(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
105    const double PeakThresh = 0.4;
106    TTmFltPrV FqOtV, SmoothV;
107    GetFqOt(FqOtV, TmUnit, UrlTy, QtBs);
108    TQuote::GetSmoothFqOt(SmoothV, FqOtV, TmUnit, 48, 1.2, AfterTm); 
109    SmoothV.Swap(FqOtV);
110    double MaxVal=0;
111    int maxI=0, maxL=0, maxR=0;
112    for (int i = 0; i < FqOtV.Len(); i++) {
113      if (MaxVal < FqOtV[i].Val2) {
114        MaxVal = FqOtV[i].Val2;  maxI=i; }
115    }
116    MaxVal *= PeakThresh;
117    for (maxL = maxI; maxL>0 && FqOtV[maxL].Val2 > MaxVal; maxL--) { }
118    for (maxR = maxI; maxR<FqOtV.Len() && FqOtV[maxR].Val2 > MaxVal; maxR++) { }
119    if (maxR-maxL > 100) { return false; }
120    for (int i = maxR; i < FqOtV.Len(); i++) {
121      if (FqOtV[i].Val2 > MaxVal) { return false; }
122    }
123    for (int i = maxL; i >= 0; i--) {
124      if (FqOtV[i].Val2 > MaxVal) { return false; }
125    }
126    return true;
127  }
128  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit) const {
129    THash<TSecTm, TFlt> TmCntH;
130    for (int i = 0; i < TmUrlCntV.Len(); i++) {
131      TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
132    }
133    TmCntH.SortByKey();
134    TmCntH.GetKeyDatPrV(RawFqOtV);
135  }
136  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
137    THash<TSecTm, TFlt> TmCntH;
138    for (int i = 0; i < TmUrlCntV.Len(); i++) {
139      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
140        TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
141      }
142    }
143    TmCntH.SortByKey();
144    TmCntH.GetKeyDatPrV(RawFqOtV);
145  }
146  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm) const {
147    const TSecTm RBegTm = BegTm.Round(TmUnit);
148    const TSecTm REndTm = EndTm.Round(TmUnit);
149    THash<TSecTm, TFlt> TmCntH;
150    for (int i = 0; i < TmUrlCntV.Len(); i++) {
151      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
152      if (Tm >= RBegTm && Tm <= REndTm) {
153        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
154      }
155    }
156    TmCntH.SortByKey();
157    TmCntH.GetKeyDatPrV(RawFqOtV);
158  }
159  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
160    const TSecTm RBegTm = BegTm.Round(TmUnit);
161    const TSecTm REndTm = EndTm.Round(TmUnit);
162    THash<TSecTm, TFlt> TmCntH;
163    for (int i = 0; i < TmUrlCntV.Len(); i++) {
164      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
165      if (Tm >= RBegTm && Tm <= REndTm && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
166        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
167      }
168    }
169    TmCntH.SortByKey();
170    TmCntH.GetKeyDatPrV(RawFqOtV);
171  }
172  void TQuote::GetSmoothFqOt(TTmFltPrV& FqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) const {
173    TTmFltPrV RawFqOtV;
174    GetFqOt(RawFqOtV, TmUnit, BegTm, EndTm);
175    GetSmoothFqOt(FqOtV, RawFqOtV, TmUnit, WndSz, Smooth, BegTm, EndTm);
176  }
177  void TQuote::GetSmoothFqOt(TTmFltPrV& SmoothFqOtV, const TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) {
178    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
179    const int HalfWndSecs = (WndSz/2)*TmUnitSecs;
180    double FullNormConst = 1;
181    for (int j = 1; j <= WndSz/2; j++) {
182      FullNormConst += 2*pow(Smooth, -j); }
183    THash<TSecTm, TFlt> TmCntH;
184    for (int i = 0; i < RawFqOtV.Len(); i++) {
185      const TSecTm Tm = RawFqOtV[i].Val1;
186      double NormConst = FullNormConst;
187      if (Tm < BegTm+HalfWndSecs || Tm+HalfWndSecs > EndTm) {
188        NormConst = 1;
189        for (int j = 1; j <= WndSz/2; j++) {
190          if (Tm >= BegTm+j*TmUnitSecs) { NormConst += pow(Smooth, -j);  }
191          if (Tm+j*TmUnitSecs <= EndTm) { NormConst += pow(Smooth, -j);  }
192      } }
193      const double NormFq = RawFqOtV[i].Val2 / NormConst;
194      for (int j = 1; j <= WndSz/2; j++) {
195        const int Off = j*TmUnitSecs;
196        if (Tm+Off <= EndTm) {
197          TmCntH.AddDat(TSecTm(Tm+Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
198        if (Tm >= BegTm + Off) {
199          TmCntH.AddDat(TSecTm(Tm-Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
200      }
201      TmCntH.AddDat(Tm.Round(TmUnit)) += NormFq;
202    }
203    TmCntH.SortByKey();
204    TmCntH.GetKeyDatPrV(SmoothFqOtV);
205  }
206  TStr TQuote::GetDesc() const {
207    return TStr::Fmt("#:%d U:%d  %s", GetFq(), GetUrls(), QtStr.CStr());
208  }
209  void TQuote::PlotOverTm(const TStr& OutFNm) {
210    TFltFltH HrCntH;
211    TmUrlCntV.Sort();
212    if (TmUrlCntV.Empty()) { return; }
213    for (int i = 0; i < TmUrlCntV.Len(); i++) {
214      double Hr = TSecTm(TmUrlCntV[i].Tm()-TmUrlCntV[0].Tm()).Round(tmu6Hour)/(24*3600.0);
215      HrCntH.AddDat(Hr) += TmUrlCntV[i].Cnt();
216    }
217    HrCntH.SortByKey();
218    TGnuPlot::PlotValCntH(HrCntH, OutFNm, TStr::Fmt("%d occurences, %d urls: %s", GetFq(), GetUrls(), QtStr.CStr()),
219      TStr::Fmt("Time [days] from %s", TmUrlCntV[0].Tm().GetYmdTmStr().CStr()), "Frequency");
220  }
221  void TQuote::LoadQtV(const TStr& InFNm, TVec<TQuote>& QtV) {
222    PSIn SIn = TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm);
223    QtV.Clr(false);
224    while (! SIn->Eof()) {
225      QtV.Add();
226      QtV.Last().Load(*SIn);
227    }
228  }
229  TQuoteBs::TQuoteBs(TSIn& SIn) : StrQtIdH(SIn), QuoteH(SIn), UrlInDegH(SIn), UrlTyH(SIn) {
230    if (! SIn.Eof()) { ClustQtIdVH.Load(SIn); }
231    TIntSet CIdSet;
232    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c < ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
242  void TQuoteBs::Save(TSOut& SOut) const {
243    StrQtIdH.Save(SOut);
244    QuoteH.Save(SOut);
245    UrlInDegH.Save(SOut);
246    UrlTyH.Save(SOut);
247    ClustQtIdVH.Save(SOut);
248  }
249  PQuoteBs TQuoteBs::New() {
250    return PQuoteBs(new TQuoteBs());
251  }
252  PQuoteBs TQuoteBs::Load(TSIn& SIn) {
253    printf("loading %s...", SIn.GetSNm().CStr());
254    return PQuoteBs(new TQuoteBs(SIn));
255  }
256  void TQuoteBs::GetQtIdV(TIntV& QtIdV) const {
257    QtIdV.Clr();
258    for (int q = 0; q < QuoteH.Len(); q++) {
259      QtIdV.Add(QuoteH.GetKey(q)); }
260  }
261  TUrlTy TQuoteBs::GetUrlTy(const int& UrlId) const {
262    if (UrlTyH.IsKey(UrlId)) {
263      return (TUrlTy) UrlTyH.GetDat(UrlId).Val; } 
264    return utBlog; 
265  }
266  void TQuoteBs::SetUrlTy(const TStr& InFNm, const TUrlTy& SetTy) {
267    printf("Set url type\n");
268    TStrHash<TIntV> DomUrlV; 
269    for (int q = 0; q < Len(); q++) {
270      const TQuote::TTmUrlCntV& V = GetQtN(q).TmUrlCntV;
271      for (int u = 0; u < V.Len(); u++) {
272        const TChA Url = GetStr(V[u].UrlId());
273        DomUrlV.AddDat(TStrUtil::GetDomNm(Url).CStr()).Add(V[u].UrlId());
274      }
275    }
276    printf("  %d domains\n", DomUrlV.Len());
277    TStrV TyUrlV; TStr Ln;
278    if (! TFile::Exists(InFNm)) {
279      printf("!!! %s does not exist\n", InFNm.CStr());
280      return;
281    }
282    for (TFIn FIn(InFNm); FIn.GetNextLn(Ln); ) { TyUrlV.Add(Ln.GetTrunc()); }
283    printf("  %d domains with type label loaded\n", TyUrlV.Len());
284    int NDomSet=0, NUrlSet=0;
285    TExeTm ExeTm;
286    for (int d = 0; d < DomUrlV.Len(); d++) {
287      for (int u = 0; u < TyUrlV.Len(); u++) {
288        if (strstr(DomUrlV.GetKey(d), TyUrlV[u].CStr()) != NULL) {
289          const TIntV& urlV = DomUrlV[d];
290          for (int i = 0; i < urlV.Len(); i++) {
291            UrlTyH.AddDat(urlV[i], SetTy); }
292          NDomSet++;  NUrlSet+=urlV.Len();
293          break;
294        }
295      }
296      if (d % 1000 == 0) { printf("  %d/%d: labeled %d doms, %d urls [%s]\n", d, DomUrlV.Len(), NDomSet, NUrlSet, ExeTm.GetStr()); }
297    }
298    printf("  labeled %d doms, %d urls [%s]\n", NDomSet, NUrlSet, ExeTm.GetStr());
299    printf("  %d total labeled urls\n", UrlTyH.Len());
300  }
301  bool AppearsAt(const TIntSet& UrlSet, const TQuote& Q) {
302    for (int u = 0; u < Q.GetUrls(); u++) {
303      if (UrlSet.IsKey(Q.GetUrlId(u))) { return true; }
304    }
305    return false;
306  }
307  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const bool& OnlyClustRoots, const TStr& HasWord, const TStr& AppearsAtUrl, const TUrlTy& OnlyCountTy, const TSecTm& BegTm, const TSecTm& EndTm) const {
308    printf("Get top quotes from %d quotes\n", QuoteH.Len());
309    printf("  %s -- %s\n", BegTm.GetYmdTmStr().CStr(), EndTm.GetYmdTmStr().CStr());
310    TIntPrV FqQtIdV;
311    int words=0, minFq=0, hasWord=0;
312    TIntSet CSet, QSet;
313    TIntSet UrlSet;
314    if (! AppearsAtUrl.Empty()) {
315      for (int q = 0; q < QuoteH.Len(); q++) {
316        const TQuote& Q = GetQtN(q);
317        TQuote::TTmUrlCntV TmUrlCntV(Q.GetUrls(), 0);
318        for (int u = 0; u < Q.GetUrls(); u++) {
319          if (UrlSet.IsKey(Q.GetUrlId(u))) {
320            TmUrlCntV.Add(Q.TmUrlCntV[u]);
321            continue; }
322          if (strstr(GetStr(Q.GetUrlId(u)), AppearsAtUrl.CStr())!=NULL) {
323            TmUrlCntV.Add(Q.TmUrlCntV[u]);
324            UrlSet.AddKey(Q.GetUrlId(u)); } 
325        }
326        TQuote* QPt = (TQuote*) &(QuoteH[q]);
327        QPt->TmUrlCntV = TmUrlCntV; 
328      }
329    }
330    printf("done.");
331    for (int q = 0; q < QuoteH.Len(); q++) {
332      const TQuote& Qt = GetQtN(q);
333      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { words++;  continue; }
334      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { hasWord++;  continue; }
335      int Fq = 0;
336      if (OnlyClustRoots && Qt.GetTy() == qtRoot) {
337        IAssert(Qt.GetCId() == GetQtId(q));
338        IAssert(! CSet.IsKey(Qt.GetCId()));  CSet.AddKey(Qt.GetCId());
339        if ((! HasWord.Empty()) && GetQt(GetCentrQtId(Qt.GetCId())).GetStr().SearchStr(HasWord)==-1) { hasWord++; continue; } 
340        TQuote CentrQt;  GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
341        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, CentrQt)) { continue; }
342        Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
343        if (Fq < MinQtFq) { minFq++; continue; }
344        const int Doms = CentrQt.GetDoms(*this);
345        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
346      }
347      else {
348        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, Qt)) { continue; }
349        Fq = Qt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
350        if (Fq < MinQtFq) { minFq++; continue; }
351        const int Doms = Qt.GetDoms(*this);
352        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
353      }
354      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
355      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
356    }
357    printf("  skip %d : word len < %d\n", words, MinWrdLen);
358    printf("  skip %d : qt fq < %d\n", minFq, MinQtFq);
359    if (! HasWord.Empty()) { printf("  skip %d : not containing '%s'\n", hasWord, HasWord.CStr()); }
360    printf("  remaining %d quotes\n", FqQtIdV.Len());
361    FqQtIdV.Sort(false);
362    QtIdV.Clr(false);
363    TIntSet SeenSet;
364    for (int i = 0; i < FqQtIdV.Len(); i++) {
365      if (i < 100) { printf(" fq:%d", FqQtIdV[i].Val1()); }
366      const int qid = FqQtIdV[i].Val2;
367      if (! SeenSet.IsKey(qid)) {
368        QtIdV.Add(qid);
369        SeenSet.AddKey(qid);
370        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
371          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
372          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
373        }
374      }
375    }
376    printf("  return %d quotes\n", QtIdV.Len());
377  }
378  int AppearsAtDom(const TQuote& CentrQt, const TIntSet& GoodDom, const TIntH& UrlDomH) {
379    int DomCnt = 0;
380    for (int u = 0; u < CentrQt.GetUrls(); u++) {
381      const int U = CentrQt.GetUrlId(u);
382      IAssert(UrlDomH.IsKey(U));
383      if (GoodDom.IsKey(UrlDomH.GetDat(U))) { 
384        DomCnt++; }
385    }
386    return DomCnt;
387  }
388  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const TStrV& FromDomains,
389                              const bool& OnlyClustRoots, const TStr& HasWord, int MinDoms) const {
390    printf("Get top quotes from %d quotes appearing at %d domains\n", QuoteH.Len(), FromDomains.Len());
391    TIntPrV FqQtIdV;
<span onclick='openModal()' class='match'>392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q < QuoteH.Len(); q++) {
396      const TQuote& Q = GetQtN(q);
</span>397      for (int u = 0; u < Q.GetUrls(); u++) {
398        const int U = Q.GetUrlId(u);
399        const int D = DomainSet.AddKey(TStrUtil::GetDomNm2(GetStr(U)));
400        UrlDomH.AddDat(U, D);
401      }
402    }
403    TIntSet GoodDom;
404    for (int d = 0; d < DomainSet.Len(); d++) {
405      for (int f = 0; f < FromDomains.Len(); f++) {
406        if (DomainSet[d].SearchStr(FromDomains[f]) != -1) {
407          GoodDom.AddKey(d); break; }
408      }
409    }
410    printf("%d total domains\n", DomainSet.Len());
411    printf("%d from domains\n", FromDomains.Len());
412    printf("%d good domains\n", GoodDom.Len());
413    printf("done.\n\n");
414    const TSecTm BegTm(1), EndTm(TSecTm::GetCurTm());
415    for (int q = 0; q < QuoteH.Len(); q++) {
416      const TQuote& Qt = GetQtN(q);
417      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { continue; }
418      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { continue; }
419      int Fq = 0;
420      if (Qt.GetTy() == qtRoot) {
421        TQuote CentrQt;
422        GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
423        if (AppearsAtDom(CentrQt, GoodDom, UrlDomH) < MinDoms) { continue; }
424        Fq = CentrQt.GetFq(BegTm, EndTm, utUndef, *this);
425        if (Fq < MinQtFq) { continue; }
426        const int Doms = CentrQt.GetDoms(*this);
427        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
428      }
429      else if (! OnlyClustRoots) {
430        if (AppearsAtDom(Qt, GoodDom, UrlDomH) < MinDoms) { continue; }
431        Fq = Qt.GetFq(BegTm, EndTm, utUndef, *this);
432        if (Fq < MinQtFq) { continue; }
433        const int Doms = Qt.GetDoms(*this);
434        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
435      }
436      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
437      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
438    }
439    printf("  remaining %d quotes\n", FqQtIdV.Len());
440    FqQtIdV.Sort(false);
441    QtIdV.Clr(false);
442    TIntSet SeenSet;
443    for (int i = 0; i < FqQtIdV.Len(); i++) {
444      const int qid = FqQtIdV[i].Val2;
445      if (! SeenSet.IsKey(qid)) {
446        QtIdV.Add(qid);
447        SeenSet.AddKey(qid);
448        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
449          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
450          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
451        }
452      }
453    }
454    printf("  return %d quotes\n", QtIdV.Len());
455  }
456  void TQuoteBs::GetQtIdVByTm(const int& WndSzHr, const int& StepHr, const int& MinWrdLen, const int& MinQtFq, const int& TakePerStep) const {
457    const TTmUnit TmUnit = tmu4Hour;
458    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
459    MinTm=MinTm.Round(TmUnit); MaxTm=MaxTm.Round(TmUnit);
460    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
461    printf("  time window %dh, step size %dh, min wrd len %d, take top %d per step\n", WndSzHr, StepHr, MinWrdLen, TakePerStep);
462    TIntSet TopQtIdSet;
463    TIntV TopQtIdV;
464    int cnt=0;
465    FILE *F = fopen("top_qts_per_time_unit.txt", "wt");
466    for (TSecTm Tm=MinTm; Tm <= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, "", "", utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
468      fprintf(F,"week of: %s\n", Tm.GetYmdTmStr().CStr());
469      for (int q = 0, j=0; q < TopQtIdV.Len() && j<3; q++) {
470        if (! TopQtIdSet.IsKey(TopQtIdV[q])) {
471          fprintf(F, "%s\t%d\n", GetQt(GetCentrQtId(TopQtIdV[q])).GetStr().CStr(), GetClustFq(TopQtIdV[q]));
472          j++; }
473        TopQtIdSet.AddKey(TopQtIdV[q]);
474      }
475      fprintf(F, "\n");
476    }
477    fclose(F);
478    printf("  done %d quotes\n", TopQtIdSet.Len());
479  }
480  void TQuoteBs::GetCIdVByFq(TIntV& CIdV, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy, const bool& OnlyAfterRoot, const TSecTm& BegTm, const TSecTm& EndTm) const {
481    printf("Get top clusters from %d clusters\n", GetClusts());
482    TIntPrV FqCIdV;
483    for (int c = 0; c < GetClusts(); c++) {
484      const int CId = GetCId(c);
485      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
486      IAssert(GetQt(CId).GetTy()==qtRoot);
487      const int CentrQId = GetCentrQtId(CId);
488      if (CentrQId == -1) { continue; }
489      if ((! RootHasWord.Empty()) && GetQt(CentrQId).GetStr().SearchStr(RootHasWord)==-1) { continue; } 
490      TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, OnlyAfterRoot); 
491      const int Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
492      if (Fq < MinClFq) { continue; }
493      FqCIdV.Add(TIntPr(Fq, CId));
494    }
495    printf("  remaining %d clusters\n", FqCIdV.Len());
496    FqCIdV.Sort(false);
497    CIdV.Clr(false);
498    for (int i = 0; i < FqCIdV.Len(); i++) {
499      CIdV.Add(FqCIdV[i].Val2); }
500  }
501  void TQuoteBs::GetMinMaxTm(TSecTm& MinTm, TSecTm& MaxTm) const {
502    MinTm = MaxTm = TSecTm();
503    for (int q = 0; q < QuoteH.Len(); q++) {
504      const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
505      if (V.Empty()) { continue; }
506      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
507        MinTm = V[0].Tm(); }
508      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
509        MaxTm = V[0].Tm(); }
510    }
511  }
512  void TQuoteBs::GetMinMaxTm(const TIntV& QtIdV, TSecTm& MinTm, TSecTm&MaxTm) const {
513    MinTm = MaxTm = TSecTm();
514    for (int q = 0; q < QtIdV.Len(); q++) {
515      const TQuote::TTmUrlCntV& V = GetQt(QtIdV[q]).TmUrlCntV;
516      if (V.Empty()) { continue; }
517      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
518        MinTm = V[0].Tm(); }
519      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
520        MaxTm = V[0].Tm(); }
521    }
522  }
523  void TQuoteBs::GetQtPageUrl(const TIntV& QtIdV, TIntH& QtUrlIdH) const {
524    THash<TChA, TInt> DomQtCntH;
525    for (int q = 0; q < Len(); q++) {
526      const TQuote& Q = GetQtN(q);
527      for (int u = 0; u < Q.GetUrls(); u++) {
528        DomQtCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += Q.TmUrlCntV[u].Cnt(); }
529    }
530    const TStr StopList = "blog.myspace.com|www.newsmeat.com|us.rd.yahoo.com|www.startribune.com|"
531      "news.originalsignal.com|uk.news.yahoo.com|ap.google.com|www.cnn.com|www.opednews.com";
532    TStrV StopListV; StopList.SplitOnAllCh('|', StopListV);
533    for (int s = 0; s < StopListV.Len(); s++) {
534      DomQtCntH.AddDat(StopListV[s]) = 1; }
535    DomQtCntH.SortByDat(false);
536    QtUrlIdH.Clr(false);
537    for (int q = 0; q < QtIdV.Len(); q++) {
538      const TQuote& Q = GetQt(QtIdV[q]);
539      int DomFq=0, BestUrlId=0;
540      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
541        const TChA Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
542        if (DomFq < DomQtCntH.GetDat(Dom)) {
543          DomFq = DomQtCntH.GetDat(Dom);
544          BestUrlId = Q.TmUrlCntV[u].UrlId();
545        }
546      }
547      QtUrlIdH.AddDat(QtIdV[q], BestUrlId);
548    }
549  }
550  void TQuoteBs::AddQuote(const TQuote& Quote, const TQuoteBs& CurQtBs) {
551    const int QtId = CurQtBs.GetQtId(Quote.GetStr().CStr());
552    TQuote& Qt = QuoteH.AddDat(QtId);
553    StrQtIdH.AddDat(Quote.GetStr().CStr(), QtId);
554    Qt.QtCIdTy = TQuote::TQtIdTy(Quote.GetCId(), Quote.GetTy());
555    Qt.QtStr = Quote.QtStr;
556    Qt.TmUrlCntV = Quote.TmUrlCntV;
557    for (int u = 0; u < Qt.TmUrlCntV.Len(); u++) {
558      Qt.TmUrlCntV[u].SetUrlId(AddStr(CurQtBs.GetStr(Quote.TmUrlCntV[u].UrlId())));
559    }
560  }
561  void TQuoteBs::AddQuote(const TVec<TChA>& QuoteV, const TVec<TChA>& LinkV, const TChA& PostUrlStr, const TSecTm& PubTm, const int& MinQtWrdLen) {
562    TIntH QtCntH; 
563    for (int q = 0; q < QuoteV.Len(); q++) {
564      if (TStrUtil::CountWords(QuoteV[q].CStr()) < MinQtWrdLen) { continue; } 
565      int QtId = GetQtId(QuoteV[q].CStr());
566      if (QtId == -1) { 
567        IAssert(! IsStr(QuoteV[q].CStr()));
568        QtId = QuoteH.Len();
569        TQuote& Qt = QuoteH.AddDat(QtId);
570        Qt.QtCIdTy = TQuote::TQtIdTy(QtId, qtQuote);
571        Qt.QtStr = QuoteV[q];
572        StrQtIdH.AddDat(QuoteV[q].CStr(), QtId);
573      } else { IAssert(IsStr(QuoteV[q].CStr())); }
574      IAssert(IsQtId(QtId));
575      QtCntH.AddDat(QtId) += 1; 
576    }
577    if (QtCntH.Len() > 0) {
578      const int PostUrlId = AddStr(PostUrlStr);
579      for (int i = 0; i < QtCntH.Len(); i++) {
580        QuoteH.GetDat(QtCntH.GetKey(i)).TmUrlCntV.Add(TQuote::TTmUrlCnt(PubTm, PostUrlId, QtCntH[i]));
581      }
582    }
583    const TChA PostDomain = TStrUtil::GetDomNm(PostUrlStr);
584    for (int l = 0; l < LinkV.Len(); l++) {
585      const TChA& Url = LinkV[l];
586      if (TStrUtil::GetDomNm(Url) == PostDomain) { continue; } 
587      if (IsStr(Url.CStr())) { UrlInDegH.AddDat(GetStrId(Url.CStr())) += 1; }
588    }
589  }
590  PQuoteBs TQuoteBs::GetQuoteBs(const TIntV& QtIdV) const {
591    PQuoteBs _NewQtBs = TQuoteBs::New();
592    TQuoteBs& NewQtBs = *_NewQtBs;
593    for (int q = 0; q < QtIdV.Len(); q++) {
594      const TQuote& Qt = GetQt(QtIdV[q]);
595      NewQtBs.AddQuote(Qt, *this);
596    }
597    for (int u = 0; u < UrlInDegH.Len(); u++) {
598      const char* UrlStr = GetStr(UrlInDegH.GetKey(u));
599      if (NewQtBs.IsStr(UrlStr)) {
600        NewQtBs.UrlInDegH.AddDat(NewQtBs.GetStrId(UrlStr), UrlInDegH[u]); }
601    }
602    for (int t = 0; t < UrlTyH.Len(); t++) {
603      const char* UrlStr = GetStr(UrlTyH.GetKey(t));
604      if (NewQtBs.IsStr(UrlStr)) {
605        NewQtBs.UrlTyH.AddDat(NewQtBs.GetStrId(UrlStr), UrlTyH[t]); }
606    }
607    for (int c = 0; c < GetClusts(); c++) {
608      const int CId = GetCId(c);
609      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
610      const TIntV& CQtIdV = GetClust(CId);
611      if (NewQtBs.IsQtId(CId)) {
612        IAssert(! NewQtBs.ClustQtIdVH.IsKey(CId));
613        TIntV& CIdV = NewQtBs.ClustQtIdVH.AddDat(CId);
614        for (int i = 0; i < CQtIdV.Len(); i++) {
615          if (NewQtBs.IsQtId(CQtIdV[i])) { CIdV.Add(CQtIdV[i]); }
616        }
617        IAssert(CIdV.Len() > 0);
618      }
619    }
620    return _NewQtBs;
621  }
622  int TQuoteBs::GetQtsInClust() const {
623    int qts = 0;
624    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
625      qts += ClustQtIdVH[q].Len();
626    }
627    return qts;
628  }
629  int TQuoteBs::GetClustFq(const int& CId) const {
630    int fq = 0;
631    TIntSet S;
632    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
633    for (int c = 0; c < ClustV.Len(); c++) {
634      fq += GetQt(ClustV[c]).GetFq();
635      IAssert(! S.IsKey(ClustV[c]));
636      S.AddKey((ClustV[c]));
637    }
638    return fq;
639  }
640  int TQuoteBs::GetClustFq(const int& CId, const TUrlTy& UrlTy) const {
641    int fq = 0;
642    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
643    for (int c = 0; c < ClustV.Len(); c++) {
644      fq += GetQt(ClustV[c]).GetFq(UrlTy, *this);
645    }
646    return fq;
647  }
648  int TQuoteBs::GetCentrQtId(const int& CId) const {
649    return GetCentrQtId(GetClust(CId));
650  }
651  int TQuoteBs::GetCentrQtId(const TIntV& ClustV) const {
652    TIntPrV QtFqIdV;
653    for (int c = 0; c < ClustV.Len(); c++) {
654      if (! IsQtId(ClustV[c])) { continue; }
655      const TQuote& Q = GetQt(ClustV[c]);
656      QtFqIdV.Add(TIntPr(Q.GetUrls(), ClustV[c]));
657    }
658    if (QtFqIdV.Empty()) { return -1; }
659    QtFqIdV.Sort(false);
660    const TStr FqStr = GetQt(QtFqIdV[0].Val2).GetStr(); 
661    for (int c = 0; c < QtFqIdV.Len(); c++) {
662      IAssert(IsQtId(QtFqIdV[c].Val2));
663      const TQuote& Q = GetQt(QtFqIdV[c].Val2);
664      const int Words = TStrUtil::CountWords(Q.GetStr().CStr());
665      if (Words >= 6 && Words < 50 && strstr(Q.GetStr().CStr(), FqStr.CStr())!=NULL) {
666        return QtFqIdV[c].Val2; }
667    }
668    return QtFqIdV[0].Val2;
669  }
670  void TQuoteBs::GetMergedClustQt(const int& CId, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
671    const TIntV& ClustV = GetClust(CId);
672    GetMergedClustQt(ClustV, NewQt, OnlyAfterBegTm);
673  }
674  void TQuoteBs::GetMergedClustQt(const TIntV& ClustV, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
675    const int CentrQtId = GetCentrQtId(ClustV);
676    const TSecTm BegTm = OnlyAfterBegTm ? GetClustBegTm(ClustV, CentrQtId) : TSecTm(1);
677    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
678    for (int c = 0; c < ClustV.Len(); c++) {
679      const TQuote& Q = GetQt(ClustV[c]);
680      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
681        if (Q.TmUrlCntV[u].Tm() >= BegTm) {
682          TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.TmUrlCntV[u].Tm(), Q.TmUrlCntV[u].UrlId())) += Q.TmUrlCntV[u].Cnt(); }
683      }
684    }
685    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
686    NewQt.QtStr = GetQt(CentrQtId).GetStr(); 
687    if (! TmUrlCntH.Empty()) {
688      NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
689      for (int u = 0; u < TmUrlCntH.Len(); u++) {
690        NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
691      }
692      NewQt.TmUrlCntV.Sort();
693    }
694  }
695  TSecTm TQuoteBs::GetClustBegTm(const int& CId, const int& CentrQtId) const {
696    const TIntV& ClustV = GetClust(CId);
697    return GetClustBegTm(ClustV, CentrQtId);
698  }
699  TSecTm TQuoteBs::GetClustBegTm(const TIntV& ClustV, const int& CentrQtId) const {
700    TStrHash<TInt> StrH;
701    TIntV CntrWIdV, WIdV;
702    int WIdV1Start, WIdV2Start, SkipId;
703    TStrUtil::GetAddWIdV(StrH, GetQt(CentrQtId).GetStr().CStr(), CntrWIdV);
704    TSecTm BegTm = TSecTm::GetCurTm();
705    for (int c = 0; c < ClustV.Len(); c++) {
706      TStrUtil::GetAddWIdV(StrH, GetQt(ClustV[c]).GetStr().CStr(), WIdV);
707      if (WIdV.Len() < CntrWIdV.Len()) { continue; }
708      const int Overlap = LongestCmnSubSq(CntrWIdV, WIdV, WIdV1Start, WIdV2Start, SkipId);
709      if (Overlap >= CntrWIdV.Len() && SkipId==0) { 
710        if (GetQt(ClustV[c]).TmUrlCntV.Empty()) { continue; }
711        BegTm = TMath::Mn(BegTm, GetQt(ClustV[c]).TmUrlCntV[0].Tm()); 
712      }
713    }
714    return BegTm;
715  }
716  int TQuoteBs::LongestCmnSubSq(const TIntV& WIdV1, const TIntV& WIdV2, int& WIdV1Start, int& WIdV2Start, int& SkipId) {
717    const TIntV& V1 = WIdV1.Len()>WIdV2.Len() ? WIdV1:WIdV2; 
718    const TIntV& V2 = WIdV1.Len()>WIdV2.Len() ? WIdV2:WIdV1; 
719    const int V1Len = V1.Len();
720    const int V2Len = V2.Len();
721    static THash<TInt, TIntV> WIdPosH;
722    static THashSet<TInt> V2WIdSet;
723    V2WIdSet.Clr(false);
724    for (int i=0; i < WIdPosH.Len(); i++) { WIdPosH[i].Clr(false); }
725    WIdPosH.Clr(false, -1, false);
726    WIdV1Start = WIdV2Start = SkipId = 0;
727    for (int i = 0; i < V2Len; i++) { 
728      V2WIdSet.AddKey(V2[i]); }
729    for (int i = 0; i < V1Len; i++) { 
730      if (V2WIdSet.IsKey(V1[i])) { WIdPosH.AddDat(V1[i]).Add(i); } }
731    {const int cmnWords = WIdPosH.Len();
732    if (cmnWords < V2WIdSet.Len()) {
733      if (cmnWords < 4) { return 0; }
734      else if (V2Len >= 5 && cmnWords < 5) { return 0; }
735      else if (V2Len > 6 && (2*cmnWords < V2Len && cmnWords < 10)) { return 0; } }
736    }
737    int MaxLen = 0;
738    for (int w = 0; w < V2Len; w++) { 
739      const int wid = V2[w];
740      if (! WIdPosH.IsKey(wid)) { continue; }
741      const TIntV& OccV = WIdPosH.GetDat(wid);
742      for (int o = 0; o < OccV.Len(); o++) {
743        const int beg = OccV[o];
744        int cnt = 0, tmp = 0;
745        while (w+cnt < V2Len && beg+cnt < V1Len && V2[w+cnt]==V1[beg+cnt]) { cnt++; tmp=0; }           
746        while (beg+1+cnt < V1Len && w+cnt < V2Len && V2[w+cnt]==V1[beg+cnt+1]) { cnt++; tmp=-1; }      
747        while (beg+cnt+1 < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt+1]) {  cnt++; tmp=-2;}  
748        while (beg+cnt < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt]) { cnt++; tmp=-3;}       
749        if (MaxLen < cnt) { MaxLen = cnt; SkipId=tmp; WIdV1Start = beg;  WIdV2Start = w; }
750        IAssert(cnt >= 1);
751      }
752    }
753    if (! (WIdV1.Len()>WIdV2.Len())) {
754      int tmp=WIdV1Start; WIdV1Start=WIdV2Start; WIdV2Start=tmp;
755    }
756    return MaxLen;
757  }
758  void TQuoteBs::CreateClusters(const TVec<TIntV>& ClustV) {
759    TIntV CIdV;
760    ClustQtIdVH.Clr();
761    printf("len %d\n", Len());
762    for (int q = 0; q < Len(); q++) {
763      TQuote& Q = GetQt(q);
764      Q.QtCIdTy = TQuote::TQtIdTy(q, qtQuote);
765    }
766    TIntH SeenNId;
767    for (int c = 0; c < ClustV.Len(); c++) {
768      if (ClustV[c].Len() < 3) { continue; } 
769      const int CentrQtId = GetCentrQtId(ClustV[c]);
770      if (CentrQtId == -1) {
771        printf("Cluster %d of size %d has no root!!!\n", c, ClustV[c].Len());
772        for (int i = 0; i < ClustV[c].Len(); i++) {
773          printf("  %d%c", ClustV[c][i].Val, IsQtId(ClustV[c][i])?'t':'f'); } printf("\n");
774        continue;
775      }
776      IAssert(! SeenNId.IsKey(CentrQtId));
777      SeenNId.AddKey(CentrQtId);
778      TQuote& Q = GetQt(CentrQtId);
779      if (Q.GetTy() != qtQuote) { printf("  %d", Q.GetTy()); }
780      IAssert(! ClustQtIdVH.IsKey(CentrQtId));
781      Q.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtRoot);
782      ClustQtIdVH.AddDat(CentrQtId, ClustV[c]);
783      for (int q = 0; q < ClustV[c].Len(); q++) {
784        if (ClustV[c][q] == CentrQtId) { continue; }
785        IAssert(! SeenNId.IsKey(ClustV[c][q]));
786        SeenNId.AddKey(ClustV[c][q]);
787        TQuote& Q2 = GetQt(ClustV[c][q]);
788        Q2.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtInClust);
789      }
790    }
791  }
792  void TQuoteBs::ClusterQts(const int& MinRootWrdLen, const int& MinQtFq, const TStr& OutFNmPref, const TStrV& BlackListV) {
793    printf("Cluster quotes with min Fq >= %d: %d total quotes\n", MinQtFq, Len());
794    TExeTm ExeTm;
795    TStrHash<TInt> StrH;
796    TVec<TPair<TInt, TIntV> > QWIdVV;  
797    { TIntPrV LenQIdV;  TIntV QWIdV;
798    printf("sort qid by len\n");
799    TStrHash<TInt> BlackListH;
800    for (int i = 0; i < BlackListV.Len(); i++) { BlackListH.AddDatId(BlackListV[i].GetTrunc()); }
801    printf("blacklist len: %d\n", BlackListH.Len());
802    for (int q1 = 0; q1 < Len(); q1++) {
803      const TQuote& Q = GetQtN(q1);
804      const int Doms = Q.GetDoms(*this);
805      if ((Q.GetTy()==qtQuote || Q.GetTy()==qtRoot) && Doms>1 && Doms*4>Q.GetUrls()
806        && Q.GetFq() >= MinQtFq && (! BlackListH.IsKey(Q.GetStr().CStr()))) { 
807          LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1))); }
808    }
809    printf("sort %d candidates\n", LenQIdV.Len());
810    LenQIdV.Sort(false);
811    printf("get word id vectors\n");
812    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
813      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
814      QWIdVV.Add(TPair<TInt, TIntV>(LenQIdV[q1].Val2, QWIdV));
815    } }
816    printf("  %d root quotes\n", ClustQtIdVH.Len());
817    printf("  %d quotes to merge\n", QWIdVV.Len());
818    int NMergers=0;
819    FILE *F = fopen(TStr(OutFNmPref+"-merged.txt").CStr(), "wt");
820    const int ClusterQ=QWIdVV.Len();
821    for (int q1 = 0; q1 < ClusterQ; q1++) {
822      if (QWIdVV[q1].Val2.Len() < MinRootWrdLen) { continue; } 
823      const int Qt1Id = QWIdVV[q1].Val1;
824      for (int q2 = q1+1; q2 < ClusterQ; q2++) {
825        int idx1=0, idx2=0, SkipTy=0;
826        bool DoMerge = false;
827        const int ShortLen = TMath::Mn(QWIdVV[q1].Val2.Len(), QWIdVV[q2].Val2.Len());
828        if (ShortLen == 0) { continue; }
829        const int Overlap = LongestCmnSubSq(QWIdVV[q1].Val2, QWIdVV[q2].Val2, idx1, idx2, SkipTy);
830        if (ShortLen == 4 && Overlap == 4 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
831        else if (ShortLen == 5 && Overlap == 5 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
832        else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
833        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
834        if (DoMerge == true) {
835          NMergers++;
836          const int Qt2Id = QWIdVV[q2].Val1;
837          TQuote& Q1 = GetQt(Qt1Id);
838          TQuote& Q2 = GetQt(Qt2Id);
839          if (Q1.GetTy() != qtRoot) { 
840            IAssert(Q1.GetTy() == qtQuote);
841            IAssert(! ClustQtIdVH.IsKey(Qt1Id));
842            ClustQtIdVH.AddDat(Qt1Id).Add(Qt1Id);
843            Q1.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtRoot);
844          } else { IAssert(Q1.GetTy() == qtRoot); }
845          if (Q2.GetTy() == qtRoot) { 
846            for (int c = 0; c < ClustQtIdVH.GetDat(Qt2Id).Len(); c++) {
847              ClustQtIdVH.AddDat(Qt1Id).Add(ClustQtIdVH.GetDat(Qt2Id)[c]); }
848            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
849            ClustQtIdVH.DelKey(Qt2Id);
850            IAssert(ClustQtIdVH.AddDat(Qt1Id).IsIn(Qt2Id));
851          } else {
852            IAssert(Q2.GetTy() == qtQuote);
853            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
854            ClustQtIdVH.AddDat(Qt1Id).Add(Qt2Id);
855          }
856          QWIdVV[q2].Val2.Clr(true); 
857          { TStr Str= "    :"; if(SkipTy==-1){Str="long=";} else if(SkipTy==-2){Str="both=";} else if(SkipTy==-3){Str="shrt=";}
858          if (Str.Len()>0) { printf("%c", Str[0]); }
859          if (ClustQtIdVH.GetDat(Qt1Id).Len() == 2) { fprintf(F, "\n[%d] %s \t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()), Q1.QtStr.CStr(), Q1.GetFq()); }
860          fprintf(F, "%s%d [%d] %s \t%d\n", Str.CStr(), Overlap, TStrUtil::CountWords(Q2.QtStr.CStr()), Q2.QtStr.CStr(), Q2.GetFq()); }
861        }
862      }
863      if (ClustQtIdVH.IsKey(Qt1Id)) {
864        ClustQtIdVH.GetDat(Qt1Id).Pack();
865        ClustQtIdVH.GetDat(Qt1Id).Sort();
866        QWIdVV[q1].Val2.Clr(true);
867      }
868      if (q1>0 && q1 % 100 == 0) {
869        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMergers, ExeTm.GetStr());
870        if (q1 % 1000 == 0) { printf("save.\n");  fflush(F);
871          TFOut FOut(OutFNmPref+"-QtBs.ClustQtIdVH"); ClustQtIdVH.Save(FOut); }
872      }
873    }
874    fclose(F);
875    printf("\n%d quotes, %d clusters [%s]\n\n.", NMergers, ClustQtIdVH.Len(), ExeTm.GetStr());
876  }
877  void TQuoteBs::ResetClusters() {
878    ClustQtIdVH.Clr();
879    for (int q = 0; q < Len(); q++) {
880      GetQtN(q).QtCIdTy = TQuote::TQtIdTy(GetQtId(q), qtQuote);
881    }
882  }
883  void TQuoteBs::ReassignToClust(const int& QtId, const int& NewCId) {
884    const int QtCl = GetQt(QtId).GetCId();
885    printf("assign %d from clust %d to %d\n", QtId, QtCl, NewCId);
886    if (QtCl != QtId) {
887      ClustQtIdVH.GetDat(QtCl).DelIfIn(QtId); }
888    GetQt(QtId).QtCIdTy = TQuote::TQtIdTy(NewCId, qtInClust);
889    ClustQtIdVH.AddDat(NewCId).Add(QtId);
890  }
891  void TQuoteBs::Mergec2Clusters(const int& ParentCId, const int& ChildCId) {
892    IAssert(IsClust(ParentCId) && IsClust(ChildCId));
893    printf("merging %d (fq: %d) to %d (%d fq)\n", ChildCId, GetClustFq(ChildCId), ParentCId, GetClustFq(ParentCId));
894    TIntSet ClustSet;
895    { const TIntV& ClustV = GetClust(ParentCId);
896    for (int c = 0; c < ClustV.Len(); c++) {
897      ClustSet.AddKey(ClustV[c]); } }
898    { const TIntV& ClustV = GetClust(ChildCId);
899    for (int c = 0; c < ClustV.Len(); c++) {
900      ClustSet.AddKey(ClustV[c]); } }
901    ClustSet.GetKeyV(ClustQtIdVH.GetDat(ParentCId));
902    GetQt(ChildCId).QtCIdTy = TQuote::TQtIdTy(ChildCId, qtInClust);
903    ClustQtIdVH.DelKey(ChildCId);
904    ClustQtIdVH.Defrag();
905  }
906  PClustNet TQuoteBs::GetClustNet(const int& MinQtFq, const TStr& OutFNmPref) const {
907    printf("Cluster quotes with Fq >= %d: %d total quotes\n", MinQtFq, Len());
908    TExeTm ExeTm;
909    TStrHash<TInt> StrH;
910    FILE *F = fopen(TStr(OutFNmPref+"-candidates.txt").CStr(), "wt");
911    THash<TInt, TIntV> QWIdVH;  
912    { TIntPrV LenQIdV;  TIntV QWIdV;
913    printf("sort qid by len\n");
914    for (int q1 = 0; q1 < Len(); q1++) {
915      const TQuote& Q = GetQtN(q1);
916      const int Doms = Q.GetDoms(*this);
917      if ((Q.GetTy()!=qtCentr) && Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
918        LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1)));
919      }
920    }
921    printf("sort %d candidates by word length\n", LenQIdV.Len());
922    LenQIdV.Sort(false);
923    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
924      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
925      QWIdVH.AddDat(LenQIdV[q1].Val2, QWIdV);
926      fprintf(F, "%s\n", GetQt(LenQIdV[q1].Val2).QtStr.CStr());
927    } }
928    printf("  %d root quotes\n", ClustQtIdVH.Len());
929    printf("  %d quotes to merge\n", QWIdVH.Len());
930    const int ClusterQ=QWIdVH.Len();
931    PClustNet ClustNet = TClustNet::New();
932    TIntH NIdDepthH;
933    TIntSet SeenQtIdSet;
934    int NMerges=0, idx1=0, idx2=0, SkipTy=0; 
935    for (int q1 = 0; q1 < ClusterQ; q1++) { 
936      SeenQtIdSet.Clr(false);
937      const int Qt1Id = QWIdVH.GetKey(q1);
938      for (int q2 = q1-1; q2 >= 0; q2--) { 
939        const int Qt2Id = QWIdVH.GetKey(q2);
940        if (SeenQtIdSet.IsKey(Qt2Id)) { continue; }
941        bool DoMerge = false;
942        const int Overlap = LongestCmnSubSq(QWIdVH[q1], QWIdVH[q2], idx1, idx2, SkipTy);
943        const int ShortLen = QWIdVH[q1].Len(); IAssert(QWIdVH[q1].Len()<= QWIdVH[q2].Len());
944        if (ShortLen == 4 && Overlap == 4) { DoMerge=true; } 
945        else if (ShortLen == 5 && Overlap == 5) { DoMerge=true; } 
946        else if (ShortLen == 6 && Overlap >= 5) { DoMerge=true; }
947        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
948        if (DoMerge==true) { NMerges++;
949          if (! ClustNet->IsNode(Qt1Id)) { ClustNet->AddNode(Qt1Id, GetQt(Qt1Id)); }
950          if (! ClustNet->IsNode(Qt2Id)) { ClustNet->AddNode(Qt2Id, GetQt(Qt2Id)); }
951          ClustNet->AddEdge(Qt1Id, Qt2Id);
952          SeenQtIdSet.AddKey(Qt1Id);  SeenQtIdSet.AddKey(Qt2Id);
953          fprintf(F, "%d Merge\t%d\t%d\ttree\t%d\n\t%s\n\t%s\n", q1, QWIdVH[q1].Len(), QWIdVH[q2].Len(), NIdDepthH.Len(), GetQt(Qt2Id).GetStr().CStr(), GetQt(Qt1Id).GetStr().CStr());
954          fflush(F);
955        }
956      }
957      if (q1>0 && q1 % 100 == 0) {
958        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMerges, ExeTm.GetStr());
959        if (q1 % 1000 == 0) {
960          printf("save: %d merges, %d nodes, %d edges in ClustNet [%s]\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
961          TFOut FOut(OutFNmPref+".ClustNet"); ClustNet->Save(FOut); }
962      }
963    }
964    fclose(F);
965    printf("\n%d merges, %d nodes, %d edges in ClustNet [%s]\n\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
966    return ClustNet;
967  }
968  void TQuoteBs::AddMergedQtsToQtBs() {
969    printf("merge quote clusters and add them to the quote base\n");
970    TQuote MergedQt;
971    int toDel = ClustQtIdVH.Len();
972    for (int q = 0; q < QuoteH.Len(); q++) {
973      if (QuoteH[q].GetFq() == 1) { QuoteH.DelKeyId(q); toDel--; }
974      if (toDel == 0) { break; }
975    }
976    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
977      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
978      IAssert(MergedQt.TmUrlCntV.Len() > 0); 
979      QuoteH.AddDat(QuoteH.Len(), MergedQt); 
980    }
981    printf("IsKeyIdEqKeyN: %s\n", QuoteH.IsKeyIdEqKeyN()?"T":"F");
982  }
983  PQuoteBs TQuoteBs::GetMergeClusters(const bool& OnlyClusters) const {
984    printf("Merging clusters into single quotes:\n");
985    PQuoteBs NewQtBs = TQuoteBs::New();
986    TQuote MergedQt;
987    printf("  %d quotes total\n", Len());
988    printf("  %d clusters\n", ClustQtIdVH.Len());
989    TIntSet SeenQtIdSet;
990    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
991      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
992      IAssert(MergedQt.TmUrlCntV.Len() >0);
993      NewQtBs->AddQuote(MergedQt, *this);
994      const TIntV& ClustQtIdV = ClustQtIdVH[q];
995      for (int c = 0; c < ClustQtIdV.Len(); c++) {
996        const int qid = ClustQtIdV[c];
997        IAssert(! SeenQtIdSet.IsKey(qid)); 
998        SeenQtIdSet.AddKey(qid);
999      }
1000    }
1001    if (! OnlyClusters) {
1002      for (int q = 0; q < Len(); q++) {
1003        const TQuote& Q = GetQtN(q);
1004        if (! SeenQtIdSet.IsKey(GetQtId(q))) {
1005          NewQtBs->AddQuote(Q, *this); }
1006      }
1007    }
1008    printf("  %d quotes in new Quotes base\n", NewQtBs->Len());
1009    return NewQtBs;
1010  }
1011  void TQuoteBs::GetTopQtDoms(TStrIntPrV& DomCntV, const int& TakeNClust, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy) const {
1012    TIntV CIdV;
1013    GetCIdVByFq(CIdV, MinClFq, RootHasWord, OnlyCountTy);
1014    THash<TStr, TInt> DomCntH;
1015    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClust); c++) {
1016      const TIntV& ClustV = GetClust(CIdV[c]);
1017      for (int q = 0; q < ClustV.Len(); q++) {
1018        const TQuote& Q = GetQt(ClustV[q]);
1019        for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1020          DomCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += 1;
1021        }
1022      }
1023    }
1024    DomCntH.SortByDat(false);
1025    DomCntH.GetKeyDatPrV(DomCntV);
1026  }
1027  void TQuoteBs::TopDomsByLag(const TTmUnit& TmUnit, const int& TakeNDoms, const int& TakeNClusts, const int& Thresh) const {
1028    THash<TStr, TMom> DomLagH;
1029    TIntV CIdV;  GetCIdVByFq(CIdV, 10, "", utUndef);
1030    TStrIntPrV DomCntV;  GetTopQtDoms(DomCntV, TakeNClusts, 10, "", utUndef);
1031    printf("Take %d clusters, %d domains", TakeNClusts, TakeNDoms);
1032    for (int d = 0; d < TMath::Mn(TakeNDoms, DomCntV.Len()); d++) {
1033      DomLagH.AddDat(DomCntV[d].Val1);
1034      printf("%d\t%s\n", DomCntV[d].Val2(), DomCntV[d].Val1.CStr());
1035    }
1036    int NQuotes=0;
1037    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClusts); c++) {
1038      TQuote Q;  GetMergedClustQt(CIdV[c], Q, false);
1039      const TSecTm MedTm = Q.GetMedianTm(TmUnit, utUndef, *this).Round(TmUnit);
1040      TStrSet DomSet;
1041      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1042        IAssert(IsStrId(Q.TmUrlCntV[u].UrlId()));
1043        const TStr Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
1044        if (DomSet.IsKey(Dom)) { continue; } 
1045        if (! DomLagH.IsKey(Dom)) { continue; }
1046        DomLagH.AddDat(Dom).Add((int(Q.TmUrlCntV[u].Tm().Round(TmUnit))-int(MedTm))/3600.0);
1047        DomSet.AddKey(Dom);
1048      }
1049      NQuotes += GetClust(CIdV[c]).Len();
1050    }
1051    FILE *F = fopen(TStr::Fmt("domsByLag-clust%d.tab", TakeNClusts).CStr(), "wt");
1052    fprintf(F, "Top clusters: %d, total quotes in top clusters: %d\n", TakeNClusts, NQuotes);
1053    TFltFltStrTrV MedLagDomV;
1054    for (int i = 0; i < DomLagH.Len(); i++) {
1055      DomLagH[i].Def();
1056      MedLagDomV.Add(TFltFltStrTr(DomLagH[i].GetMedian(), DomLagH[i].GetVals(), DomLagH.GetKey(i)));
1057    }
1058    MedLagDomV.Sort();
1059    fprintf(F, "AGGREGATE PEAK\nTop domains with least lag (out of top %d considered) that mention at least 10 pct of top %d quotes (clusters) :\n", TakeNDoms, TakeNClusts);
1060    for (int i = 0; i < MedLagDomV.Len(); i++) {
1061      if (MedLagDomV[i].Val2() < Thresh*TakeNClusts/100.0) { continue; }
1062      fprintf(F, "%g\t%g\t%s\n", MedLagDomV[i].Val1(), MedLagDomV[i].Val2(), MedLagDomV[i].Val3.CStr());
1063    }
1064    fclose(F);
1065  }
1066  void TQuoteBs::PlotQtFqCnt(const TStr& OutFNmPref) const {
1067    TIntH UrlCntH, DomCntH, CntFqH;
1068    THashSet<TChA> DomSet;
1069    for (int q = 0; q < QuoteH.Len(); q++) {
1070      const TQuote& Q = GetQtN(q);
1071      UrlCntH.AddDat(Q.GetUrls()) += 1;
1072      CntFqH.AddDat(Q.GetFq()) += 1;
1073      DomSet.Clr(false);
1074      for (int u = 0; u < Q.GetUrls(); u++) {
1075        DomSet.AddKey(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))); }
1076      DomCntH.AddDat(DomSet.Len()) += 1;
1077    }
1078    TGnuPlot::PlotValCntH(UrlCntH, OutFNmPref+"-url", "", "number of urls quote appears at", "count", gpsLog10XY);
1079    TGnuPlot::PlotValCntH(DomCntH, OutFNmPref+"-dom", "", "number of domains quote appears at", "count", gpsLog10XY);
1080    TGnuPlot::PlotValCntH(CntFqH, OutFNmPref+"-fq", "", "number of times quote appears", "count", gpsLog10XY);
1081  }
1082  void TQuoteBs::PlotQtMediaVsBlogFq(const int& QtId, const TStr& OutFNmPref) const {
1083    TQuote::TTmFltPrV BlogFqV, MediaFqV, SmoothV;
1084    TFltPrV FqV;
1085    const TQuote& ClQt = GetQt(QtId);
1086    ClQt.GetFqOt(BlogFqV, tmu4Hour, utBlog, *this);
1087    ClQt.GetFqOt(MediaFqV, tmu4Hour, utMedia, *this);
1088    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1089    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", ClQt.GetStr().CStr(),
1090      ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1091    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, tmu4Hour, 24, 1.2, MinTm);
1092    for (int i = 0; i < SmoothV.Len(); i++) {
1093      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0), SmoothV[i].Val2())); }
1094    GP.AddPlot(FqV, gpwLines, "Blog frequency");
1095    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, tmu4Hour, 24, 1.2, MinTm);
1096    FqV.Clr();
1097    for (int i = 0; i < SmoothV.Len(); i++) {
1098      IAssert(SmoothV[i].Val1>=MinTm);
1099      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0)*(54.0/46.0), SmoothV[i].Val2()));
1100    }
1101    GP.AddPlot(FqV, gpwLines, "Media frequency");
1102    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Quote frequency (normalized for the baseline 46 vs 54)");
1103    GP.SavePng();
1104  }
1105  int NormMaxTo1(const TQuote::TTmFltPrV& TmFqV, TFltPrV& OutV, const TSecTm& BegTm) {
1106    int Idx=0;
1107    double MaxVal=0;
1108    for (int i = 0; i < TmFqV.Len(); i++) {
1109      if (MaxVal < TmFqV[i].Val2) {
1110        MaxVal=TmFqV[i].Val2; Idx = i; }
1111    }
1112    OutV.Gen(TmFqV.Len(), 0);
1113    for (int i = 0; i < TmFqV.Len(); i++) {
1114      OutV.Add(TFltPr(double(TmFqV[i].Val1-BegTm)/(24.0*3600.0), TmFqV[i].Val2())); 
1115    }
1116    return Idx;
1117  }
1118  void TQuoteBs::PlotClustMediaVsBlogFq(const int& CId, const TStr& OutFNmPref) const {
1119    const TTmUnit TmUnit = tmu4Hour;
1120    TQuote::TTmFltPrV BlogFqV, MediaFqV, AllFqV, SmoothV;
1121    TFltPrV FqV, RawFqV;
1122    TQuote ClQt;
1123    GetMergedClustQt(CId, ClQt, false);
1124    ClQt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1125    ClQt.GetFqOt(MediaFqV, TmUnit, utMedia, *this);
1126    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1127    const TSecTm  MediaPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this);
1128    const TSecTm BlogPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utBlog, *this);
1129    const int Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600;
1130    const bool Is1Peak = ClQt.IsSinglePeak(TmUnit, TSecTm(1), utUndef, *this);
1131    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", Is1Peak?"SINGLE PEAK": "MORE PEAKS", 
1132      Lag, ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1133    int mx = NormMaxTo1(BlogFqV, RawFqV, MinTm);
1134    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, TmUnit, 2*24, 1.2, MinTm);
1135    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1136    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Blog : max %s", SmoothV[mx].Val1.GetYmdTmStr().CStr()), "pt 7 ps 1");
1137    const TSecTm SmBlog = SmoothV[mx].Val1;
1138    mx = NormMaxTo1(MediaFqV, RawFqV, MinTm);
1139    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, TmUnit, 2*24, 1.2, MinTm);
1140    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1141    const TSecTm SmMed = SmoothV[mx].Val1;
1142    const int SmLag = (int(SmBlog.Round(TmUnit))-int(SmMed.Round(TmUnit)))/3600;
1143    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Media is behind: %dh, smooth: %dh.", -Lag, -SmLag), "pt 5 ps 1");
1144    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Cluster frequency (normalized for the baseline 46 vs 54)");
1145    GP.AddCmd("set xtics 10");
1146    GP.AddCmd("set mxtics 10");
1147    GP.SavePng();
1148  }
1149  void TQuoteBs::PlotMediaVsBlogLag(const TTmUnit& TmUnit, const bool& TakeClusters, const int& TakeN, const TStr& OutFNmPref) const {
1150    TQuote Qt;  TIntV IdV;
1151    TMom LagMom1d, LagMom2d, LagMom3d, LagMom4d, LagMom7d;
1152    TFltFltH LagCntH, LagBCntH, LagMCntH;
1153    int Cnt=0;
1154    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1155    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1156    for (int c = 0; c < TakeN; c++) {
1157      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1158      else { Qt = GetQt(IdV[c]); }
1159      const TSecTm  AllPeak = Qt.GetMedianTm(TmUnit, utUndef, *this);
1160      const TSecTm BlogPeak = Qt.GetMedianTm(TmUnit, utBlog, *this);
1161      const TSecTm  MediaPeak = Qt.GetMedianTm(TmUnit, utMedia, *this);
1162      const double Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600.0;
1163      const double Lag1 = (int(BlogPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1164      const double Lag2 = (int(MediaPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1165      if (fabs(Lag) < 1*24) { LagMom1d.Add(Lag); }
1166      if (fabs(Lag) < 2*24) { LagMom2d.Add(Lag); }
1167      if (fabs(Lag) < 3*24) { LagMom3d.Add(Lag); }
1168      if (fabs(Lag) < 4*24) { LagMom4d.Add(Lag); }
1169      if (fabs(Lag) < 7*24) { LagMom7d.Add(Lag); }
1170      LagCntH.AddDat(Lag) += 1;
1171      LagBCntH.AddDat(Lag1) += 1;
1172      LagMCntH.AddDat(Lag2) += 1;
1173      Cnt++;
1174    }
1175    TFltPrV PrV;
1176    LagMom1d.Def();  LagMom2d.Def();  LagMom3d.Def();  LagMom4d.Def();  LagMom7d.Def();
1177    { TGnuPlot GP("lagBlogsVsMedia-"+OutFNmPref, TStr::Fmt("Lag: 1D: %.2f %g;   2D: %.2f  %g;   3D: %.2f  %g;   4D: %.2f  %g;   7D: %.2f  %g",
1178      LagMom1d.GetMean(), LagMom1d.GetMedian(), LagMom2d.GetMean(), LagMom2d.GetMedian(), LagMom3d.GetMean(), LagMom3d.GetMedian(),
1179      LagMom4d.GetMean(), LagMom4d.GetMedian(), LagMom7d.GetMean(), LagMom7d.GetMedian()), true);
1180    LagBCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d BLOG", Qt.GetStr().CStr(),
1181      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1182    LagMCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d MEDIA", Qt.GetStr().CStr(),
1183      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1184    GP.AddCmd("set xrange[-24:24]\nset mxtics 5\nset xtics 5");
1185    GP.SetXYLabel("media lag in hours (+: news lag, -: news lead)", "count");
1186    GP.SavePng(); }
1187    printf("\nTake top %d clusters. TmUnit: %s\n", TakeN, TTmInfo::GetTmUnitStr(TmUnit).CStr());
1188    printf("  1d:\tavg:\t%f\tmed:\t%f\n", LagMom1d.GetMean(), LagMom1d.GetMedian());
1189    printf("  2d:\tavg:\t%f\tmed:\t%f\n", LagMom2d.GetMean(), LagMom2d.GetMedian());
1190    printf("  3d:\tavg:\t%f\tmed:\t%f\n", LagMom3d.GetMean(), LagMom3d.GetMedian());
1191    printf("  4d:\tavg:\t%f\tmed:\t%f\n", LagMom4d.GetMean(), LagMom4d.GetMedian());
1192    printf("  7d:\tavg:\t%f\tmed:\t%f\n", LagMom7d.GetMean(), LagMom7d.GetMedian());
1193  }
1194  void TQuoteBs::PlotFqDecay(const TTmUnit& TmUnit, const bool& TakeClusters, const TUrlTy& CntUrlTy, const int& PlotN, const int& MinValsPerTm, const TStr& OutFNmPref) const {
1195    THash<TFlt, TMom> MomH;
1196    TQuote Qt;
1197    TIntV IdV;
1198    TGnuPlot GP("decay-"+OutFNmPref);
1199    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", CntUrlTy, false); }
1200    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", CntUrlTy); }
1201    for (int c = 0; c < PlotN; c++) {
1202      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1203      else { Qt = GetQt(IdV[c]); }
1204      TQuote::TTmFltPrV QtV;  TFltPrV TmV;
1205      Qt.GetFqOt(QtV, TmUnit);
1206      int pos=0;  double val=0.0;
1207      for (int i = 0; i < QtV.Len(); i++) {
1208        if (val < QtV[i].Val2) { pos = i;  val = QtV[i].Val2; }
1209      }
1210      const double PeakVal = val;
1211      const TSecTm PeakTm = QtV[pos].Val1;
1212      for (int i = 0; i < QtV.Len(); i++) {
1213        TmV.Add(TFltPr((double(QtV[i].Val1)-double(PeakTm))/(24.0*3600), QtV[i].Val2/PeakVal));
1214        MomH.AddDat(TmV.Last().Val1).Add(TmV.Last().Val2);
1215      }
1216      const TStr Label = "";
1217    }
1218    TFltPrV AvgV, MedV;
1219    MomH.SortByKey();
1220    for (int i = 0; i < MomH.Len(); i++) {
1221      MomH[i].Def();
1222      if (MomH[i].GetVals()< MinValsPerTm) { printf("."); continue; }
1223      AvgV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMean()));
1224      MedV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMedian()));
1225    }
1226    GP.AddPlot(AvgV, gpwLines, "Average", "lt 2 lw 2");
1227    GP.AddPlot(MedV, gpwLines, TStr::Fmt("Median (last qt: %d %d %d)", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(*this)), "lt 1 lw 2");
1228    GP.SetXYLabel("time [days]", "count");
1229    GP.AddCmd("set mxtics 6");
1230    GP.AddCmd("set xtics 1");
1231    GP.AddCmd("set yrange [0:1]");
1232    GP.AddCmd("set xrange [-5:5]");
1233    GP.AddCmd("set yzeroaxis lt -1");
1234    GP.SavePng();
1235  }
1236  void NormPeakAt1(THash<TInt, TFlt>& H) {
1237    double PeakFq=1;
1238    for (int i = 0; i < H.Len(); i++) {
1239      PeakFq=TMath::Mx((double)H[i], PeakFq); }
1240    for (int i = 0; i < H.Len(); i++) {
1241      H[i]/=PeakFq; }
1242  }
1243  void TQuoteBs::PlotBlogVsMediaFqOt(const TTmUnit& TmUnit, const bool& TakeClusters, int PlotN, const TStr& OutFNmPref) const {
1244    THash<TInt, TFlt> Peak1AllH, Peak2AllH, Peak3AllH;
1245    THash<TInt, TFlt> Peak1MedH, Peak2MedH, Peak3MedH;
1246    THash<TInt, TFlt> Peak1BlogH, Peak2BlogH, Peak3BlogH;
1247    TQuote Qt;
1248    TIntV IdV;
1249    TInt FqAtPeak;
1250    if (TakeClusters) { GetCIdVByFq(IdV, 100, "", utUndef, false); }
1251    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1252    for (int c = 0; c < TMath::Mn(PlotN, IdV.Len()); c++) {
1253      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1254      else { Qt = GetQt(IdV[c]); }
1255      if (! Qt.IsSinglePeak(TmUnit, TSecTm(0), utUndef, *this)) { PlotN++; printf("."); continue; }
1256      TQuote::TTmFltPrV AllFqV, BlogFqV, MedFqV;  TFltPrV TmV;
1257      const double Peak1 = Qt.GetPeakTm(TmUnit, TSecTm(1), FqAtPeak).GetAbsSecs(); 
1258      const double Peak2 = Qt.GetMeanTm(TmUnit, utUndef, *this).GetAbsSecs();    
1259      const double Peak3 = Qt.GetMedianTm(TmUnit, utUndef, *this).GetAbsSecs();  
1260      double PeakFq = FqAtPeak;
1261      Qt.GetFqOt(AllFqV, TmUnit, utUndef, *this);
1262      Qt.GetFqOt(MedFqV, TmUnit, utMedia, *this);
1263      Qt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1264      PeakFq=1;
1265      for (int i = 0; i < MedFqV.Len(); i++) { PeakFq=TMath::Mx((double)MedFqV[i].Val2(), PeakFq); }
1266      for (int i = 0; i < MedFqV.Len(); i++) {
1267        const int T1 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1268        const int T2 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1269        const int T3 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1270        Peak1MedH.AddDat(T1) += MedFqV[i].Val2/PeakFq;
1271        Peak2MedH.AddDat(T2) += MedFqV[i].Val2/PeakFq;
1272        Peak3MedH.AddDat(T3) += MedFqV[i].Val2/PeakFq;
1273      }
1274      PeakFq=1;
1275      for (int i = 0; i < BlogFqV.Len(); i++) { PeakFq=TMath::Mx((double)BlogFqV[i].Val2(), PeakFq); }
1276      for (int i = 0; i < BlogFqV.Len(); i++) {
1277        const int T1 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1278        const int T2 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1279        const int T3 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1280        Peak1BlogH.AddDat(T1) += BlogFqV[i].Val2/PeakFq;
1281        Peak2BlogH.AddDat(T2) += BlogFqV[i].Val2/PeakFq;
1282        Peak3BlogH.AddDat(T3) += BlogFqV[i].Val2/PeakFq;
1283      }
1284    }
1285    NormPeakAt1(Peak1AllH); NormPeakAt1(Peak2AllH); NormPeakAt1(Peak3AllH);
1286    NormPeakAt1(Peak1MedH); NormPeakAt1(Peak2MedH); NormPeakAt1(Peak3MedH);
1287    NormPeakAt1(Peak1BlogH); NormPeakAt1(Peak2BlogH); NormPeakAt1(Peak3BlogH);
1288    TGnuPlot::PlotValCntH(Peak1AllH, "ALL", Peak1MedH, "MEDIA", Peak1BlogH, "BLOG", "peakMax-"+OutFNmPref, "Max is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1289    TGnuPlot::PlotValCntH(Peak3AllH, "ALL", Peak3MedH, "MEDIA", Peak3BlogH, "BLOG", "peakMed-"+OutFNmPref, "Median is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1290  }
1291  void TQuoteBs::PlotBlogFracOt(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1292    TQuote Qt;
1293    TIntV IdV;
1294    THash<TFlt, TMom> TmMomH;
1295    THash<TFlt, TFltPr> TmBmH;
1296    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1297    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1298    for (int c = 0; c < PlotN; c++) {
1299      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1300      else { Qt = GetQt(IdV[c]); }
1301      TQuote::TTmFltPrV MedQtV, BlgQtV;
1302      Qt.GetFqOt(MedQtV, TmUnit, utMedia, *this);
1303      Qt.GetFqOt(BlgQtV, TmUnit, utBlog, *this);
1304      TFltPrV FracV;
1305      const int PeakTm = Qt.GetPeakTm(TmUnit, TSecTm(1), utUndef, *this);
1306      for (int m=0, b=0; m < MedQtV.Len(); m++) {
1307        while (b<BlgQtV.Len() && BlgQtV[b].Val1 < MedQtV[m].Val1) { b++; }
1308        if (b<BlgQtV.Len() && BlgQtV[b].Val1 == MedQtV[m].Val1) {
1309          const double Tm = (int(MedQtV[m].Val1.Round(TmUnit))-PeakTm)/(24*3600.0);
1310            const double Frac = BlgQtV[b].Val2/double(BlgQtV[b].Val2+MedQtV[m].Val2);
1311            FracV.Add(TFltPr(Tm, Frac));
1312            TmMomH.AddDat(Tm).Add(Frac);
1313          TFltPr& BM = TmBmH.AddDat(Tm);
1314          BM.Val1+= BlgQtV[b].Val2;
1315          BM.Val2+= MedQtV[m].Val2;
1316        }
1317      }
1318    }
1319    { TFltPrV PrV;
1320    for (int b = 0; b < TmMomH.Len(); b++) {
1321      TmMomH[b].Def();
1322      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMean())); }
1323    TGnuPlot GP(TStr::Fmt("fqFracA-%s", OutFNmPref.CStr()));
1324    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1325    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1326    { TFltPrV PrV;
1327    for (int b = 0; b < TmMomH.Len(); b++) {
1328      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMedian())); }
1329    TGnuPlot GP(TStr::Fmt("fqFracM-%s", OutFNmPref.CStr()));
1330    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1331    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1332    { TFltPrV PrV;
1333    for (int b = 0; b < TmBmH.Len(); b++) {
1334      PrV.Add(TFltPr(TmBmH.GetKey(b), TmBmH[b].Val1/(TmBmH[b].Val1+TmBmH[b].Val2))); }
1335    TGnuPlot GP(TStr::Fmt("fqFracS-%s", OutFNmPref.CStr()));
1336    PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints);
1337    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1338  }
1339  void TQuoteBs::PlotPopularityCnt(const bool& TakeClusters, const TUrlTy& UrlTy, const int& PlotN, const TStr& OutFNmPref) const {
1340    TIntV IdV;
1341    TIntH FqCntH;
1342    TQuote Qt;
1343    for (int c = 0; c < Len(); c++) {
1344      const TQuote& Qt = GetQtN(c);
1345      if (Qt.GetStr().IsStrIn("lipstick") && Qt.GetStr().IsStrIn("pig")) {
1346        FqCntH.AddDat(Qt.GetFq(UrlTy, *this)) += 1; }
1347    }
1348    TIntPrV FqCntV, CdfV;
1349    FqCntH.GetKeyDatPrV(FqCntV);  FqCntV.Sort();
1350    TGUtil::GetCCdf(FqCntV, CdfV);
1351    TGnuPlot::PlotValV(FqCntV, "pop-"+OutFNmPref, "", "total frequency", "count", gpsLog10XY);
1352    TGnuPlot::PlotValV(CdfV, "popCDF-"+OutFNmPref+"", "", "total frequency", "NCDF", gpsLog10XY);
1353  }
1354  void TQuoteBs::PlotEmptyY(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1355    TQuote Qt;
1356    TIntV IdV;
1357    THash<TInt, TInt> TmCumCntH;
1358    int MaxY=0;
1359    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1360    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1361    for (int c = 0; c < PlotN; c++) {
1362      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1363      else { Qt = GetQt(IdV[c]); }
1364      TQuote::TTmFltPrV QtV;
1365      Qt.GetFqOt(QtV, TmUnit);
1366      for (int i = 0; i < QtV.Len(); i++) {
1367        const int Tm = QtV[i].Val1.Round(tmu1Hour)/3600;
1368        TInt& CumCnt = TmCumCntH.AddDat(Tm);
1369        CumCnt += (int) QtV[i].Val2;
1370        MaxY = TMath::Mx(CumCnt(), MaxY);
1371      }
1372    }
1373    TmCumCntH.SortByKey(true);
1374    const int BegHr = TmCumCntH.GetKey(0);
1375    THash<TFlt, TFlt> EmptyH;
1376    TFltPrV TmV;
1377    for (int t = 0; t < TmCumCntH.Len(); t++) {
1378      printf("%d  ", TmCumCntH[t]());
1379      for (int y = TmCumCntH[t]; y < MaxY; y+=1) {
1380        EmptyH.AddDat(y) += 1; }
1381      TmV.Add(TFltPr((TmCumCntH.GetKey(t)-BegHr)/24.0, TmCumCntH[t].Val));
1382    }
1383    EmptyH.SortByKey(false);
1384    TFltPrV EmptyV;
1385    EmptyV.Add(TFltPr(EmptyH.GetKey(0), EmptyH[0]));
1386    for (int i = 1; i < EmptyH.Len(); i++) {
1387      EmptyV.Add(TFltPr(EmptyH.GetKey(i), EmptyH[i]+EmptyV.Last().Val2));
1388    }
1389    TGnuPlot::PlotValCntH(EmptyH, "emptyF-"+OutFNmPref+"-d", "Amount of empty area above the cummulative query-frequency curve", "y value", "area at y");
1390    TGnuPlot::PlotValV(EmptyV, "emptyF-"+OutFNmPref+"-c", "Amount of empty area above the cummulative query-frequency curve", "y value", "area above y");
1391    TGnuPlot::PlotValV(TmV, "emptyF1"+OutFNmPref, "Cummulative query frequency over time", "time (days)", "frequency");
1392  }
1393  PNGraph TQuoteBs::GetQuotePostNet(const TStr& DatasetFNm) const {
1394    PNGraph Graph = TNGraph::New();
1395    for (TMemesDataLoader Memes(DatasetFNm); Memes.LoadNext(); ) {
1396      if (Memes.MemeV.Empty()) { continue; }
1397      if (! IsStr(Memes.PostUrlStr.CStr())) { continue; }
1398      const int SrcNId = GetStrId(Memes.PostUrlStr.CStr());
1399      for (int u = 0; u < Memes.LinkV.Len(); u++) {
1400        if (! IsStr(Memes.LinkV[u].CStr())) { continue; }
1401        const int DstNId = GetStrId(Memes.LinkV[u].CStr());
1402        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
1403        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
1404        Graph->AddEdge(SrcNId, DstNId);
1405      }
1406    }
1407    TSnap::PrintInfo(Graph);
1408    return Graph;
1409  }
1410  PQtDomNet TQuoteBs::GetQuoteDomNet(const PNGraph& PostGraph, const int& CId) const {
1411    TQuote Qt;  GetMergedClustQt(CId, Qt, false);
1412    PQtDomNet DomG = TQtDomNet::New();
1413    TIntSet UrlSet;
1414    for (int i = 0; i < Qt.GetTimes(); i++) { UrlSet.AddKey(Qt.GetUrlId(i)); }
1415    TStrSet DomH;
1416    for (int i = 0; i < Qt.GetTimes(); i++) {
1417      const int url = Qt.GetUrlId(i);
1418      if (! PostGraph->IsNode(url)) { continue; }
1419      const int dom = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url)));
1420      TNGraph::TNodeI NI = PostGraph->GetNI(url);
1421      for (int o = 0; o < NI.GetOutDeg(); o++) {
1422        if (! UrlSet.IsKey(NI.GetOutNId(o))) { continue; }
1423        const int url2 = NI.GetOutNId(o);
1424        const int dom2 = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url2)));
1425        if (dom==dom2) { continue; }
1426        if (! DomG->IsNode(dom)) {
1427          DomG->AddNode(dom, TPair<TStr, TInt>(DomH[dom], GetUrlTy(url))); }
1428        if (! DomG->IsNode(dom2)) {
1429          DomG->AddNode(dom2, TPair<TStr, TInt>(DomH[dom2], GetUrlTy(url2))); }
1430        if (DomG->IsEdge(dom, dom2)) {
1431          DomG->GetEDat(dom, dom2) += 1; }
1432        else {
1433          DomG->AddEdge(dom, dom2, 1); }
1434      }
1435    }
1436    return DomG;
1437  }
1438  void TQuoteBs::SaveQuotes(const int& MinQtFq, const TStr& OutFNm) const {
1439    TIntV QtIdV;
1440    GetQtIdVByFq(QtIdV, 0, MinQtFq);
1441    SaveQuotes(QtIdV, OutFNm);
1442  }
1443  void TQuoteBs::SaveQuotes(const TIntV& QtIdV, const TStr& OutFNm) const {
1444    TIntSet QtIdSet;
1445    FILE *F = fopen(OutFNm.CStr(), "wt");
1446    printf("saving %d quotes\n", QtIdV.Len());
1447    fprintf(F, "#Freq\tUrls\tDomains\tQuote\n");
1448    for (int q = 0; q < QtIdV.Len(); q++) {
1449      const int QtId = QtIdV[q];
1450      if (QtIdSet.IsKey(QtId)) { continue; } 
1451      QtIdSet.AddKey(QtId);
1452      const TQuote& Q = GetQt(QtId);
1453    fprintf(F, "%d\t%d\t%d\t%s\n", Q.GetFq(), Q.GetUrls(), Q.GetDoms(*this), Q.QtStr.CStr());
1454      if (Q.GetTy() == qtRoot || Q.GetTy() == qtCentr) { 
1455        IAssert(ClustQtIdVH.IsKey(Q.GetCId()));
1456        const TIntV& ClustV = ClustQtIdVH.GetDat(Q.GetCId());
1457        for (int i = 0; i < ClustV.Len(); i++) {
1458          const TQuote& Q1 = GetQt(ClustV[i]);
1459          fprintf(F, "\t[%d] %d=%d %s\t%d\t%d\t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()),
1460            ClustV[i](), Q1.GetCId(), Q1.QtStr.CStr(), Q1.GetFq(), Q1.GetUrls(), Q1.GetDoms(*this));
1461          QtIdSet.AddKey(ClustV[i]);
1462        }
1463      }
1464    }
1465    fclose(F);
1466  }
1467  void TQuoteBs::SaveClusters(const TStr& OutFNm, const bool& SkipUrls) const {
1468    TIntPrV FqCIdV;
1469    TIntH ClSzCntH, ClFqCntH;
1470    for (int c = 0; c < GetClusts(); c++) {
1471      const int CId = GetCId(c);
1472      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
1473      FqCIdV.Add(TIntPr(GetClustFq(CId), CId));
1474      ClSzCntH.AddDat(GetClust(CId).Len()) += 1;
1475      ClFqCntH.AddDat(GetClustFq(CId)) += 1;
1476    }
1477    TGnuPlot::PlotValCntH(ClSzCntH, OutFNm+"-clSz", TStr::Fmt("%d clusters", GetClusts()), "Number of quotes in the cluster", "Number of clusters", gpsLog);
1478    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFq", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, false);
1479    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFqB", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, true);
1480    FqCIdV.Sort(false);
1481    TIntPrV QtFqV;
1482    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1483    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1484    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1485    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1486    for (int c = 0; c < FqCIdV.Len(); c++) {
1487      const int CId = FqCIdV[c].Val2;
1488      const TIntV& ClustV = GetClust(CId);
1489      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), FqCIdV[c].Val1(), GetQt(CId).GetStr().CStr(), CId);
1490      QtFqV.Clr(false);
1491      for (int q = 0; q < ClustV.Len(); q++) {
1492        IAssert(IsQtId(ClustV[q]));
1493        QtFqV.Add(TIntPr(GetQt(ClustV[q]).GetUrls(), ClustV[q])); }
1494      QtFqV.Sort(false);
1495      for (int q = 0; q < QtFqV.Len(); q++) {
1496        IAssert(IsQtId(QtFqV[q].Val2));
1497        const TQuote& Qt = GetQt(QtFqV[q].Val2);
1498        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1499        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), QtFqV[q].Val2());
1500        if (! SkipUrls) {
1501          for (int u = 0; u < Qt.GetUrls(); u++) {
1502            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1503              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1504        }
1505      }
1506    }
1507    fclose(F);
1508  }
1509  void TQuoteBs::SaveClusters(const TIntV& QtIdV, const TStr& OutFNm, const bool& SkipUrls) const {
1510    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1511    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1512    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1513    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1514    for (int c = 0; c < QtIdV.Len(); c++) {
1515      int CId = QtIdV[c];
1516      if (! IsClust(CId)) { CId = GetQt(CId).GetCId(); }
1517      const TIntV& ClustV = GetClust(CId);
1518      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), GetClustFq(CId), GetQt(CId).GetStr().CStr(), CId);
1519      for (int q = 0; q < ClustV.Len(); q++) {
1520        const TQuote& Qt = GetQt(ClustV[q]);
1521        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1522        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), ClustV[q]());
1523        if (! SkipUrls) {
1524          for (int u = 0; u < Qt.GetUrls(); u++) {
1525            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1526              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1527        }
1528      }
1529    }
1530    fclose(F);
1531  }
1532  void TQuoteBs::SaveBigBlogMassQt(const TStr& OutFNm) const {
1533    const TTmUnit TmUnit = tmuDay;
1534    const bool TakeClusters = true;
1535    TIntV IdV;
1536    TQuote Qt;
1537    int Candidates=0;
1538    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1539    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1540    TVec<TPair<TFlt, TStr> > ScoreV;
1541    for (int c = 0; c < IdV.Len(); c++) {
1542      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1543      else { Qt = GetQt(IdV[c]); }
1544      const int MediaPeak = Qt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this); 
1545      const double BlogFq = Qt.GetUrls(TSecTm(MediaPeak-21*24*3600), TSecTm(MediaPeak-7*24*3600), utBlog, *this);  
1546      const double TotFq = Qt.GetUrls();
1547      if (BlogFq < 10) { continue; }
1548      Candidates++;
1549      if (BlogFq < TotFq*0.15 || BlogFq > TotFq*0.75) { continue; }
1550      ScoreV.Add(TFltStrPr(TotFq, TStr::Fmt("%g\t%g\t%s", BlogFq, TotFq, Qt.GetStr().CStr())));
1551    }
1552    printf("Considered: %d quotes\n", IdV.Len());
1553    printf("            %d candidates\n", Candidates);
1554    printf("            %d selected\n", ScoreV.Len());
1555    ScoreV.Sort(false);
1556    FILE *F = fopen(TStr::Fmt("%s.txt", OutFNm.CStr()).CStr(), "wt");
1557    fprintf(F, "total %d items\n", IdV.Len());
1558    fprintf(F, "items above blog threshdolg %d\n", ScoreV.Len());
1559    fprintf(F, "counts are numbers of urls (not actually number of occurences)\n");
1560    fprintf(F, "\nblog\ttotal\tQuote\n");
1561    for (int i = 0; i < ScoreV.Len(); i++) {
1562      fprintf(F, "%s\n", ScoreV[i].Val2.CStr());
1563    }
1564    fclose(F);
1565  }
1566  void TQuoteBs::SaveForFlash(const TIntV& QtIdV, const TStr& OutFNm, const TTmUnit& TmUnit, int SaveN, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& OnlyCountTy) const {
1567    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
1568    TVec<TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV> > QtInfoV, QtInfoV2; 
1569    TQuote::TTmFltPrV FqV, SmoothFqV;
1570    TIntV VizQtIdV;
1571    if (SaveN == -1) { SaveN = TInt::Mx; }
1572    TSecTm MinTm=TSecTm(TInt::Mx-1), MaxTm=TSecTm(1);
1573    printf("Saving top %d out of %d quotes\n", SaveN, QtIdV.Len());
1574    THash<TInt, TIntPr> WeekPeakQtIdH; 
1575    for (int q = 0; q < QtIdV.Len() && QtInfoV2.Len() < (SaveN+100); q++) { 
1576      const TQuote& Qt = GetQt(QtIdV[q]);
1577      if (Qt.GetTy() == qtQuote) {
1578        Qt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1579        if (FqV.Empty()) { continue; }
1580        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)Qt.GetPeakTm(TmUnit, BegTm)+1e-6*Qt.GetUrls(), QtIdV[q], Qt.GetFq(), FqV));
1581        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1582        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1583        VizQtIdV.Add(QtIdV[q]);
1584        TInt PeakFq;
1585        const int PeakTm = Qt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1586        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1587          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1588        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1589          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1590      } else { 
1591        const int CId = Qt.GetCId();
1592        if (! ClustQtIdVH.IsKey(CId)) { continue; }
1593        const int CentrQtId = GetCentrQtId(CId);
1594        TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, true);
1595        CentrQt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1596        if (FqV.Empty()) { continue; }
1597        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)CentrQt.GetPeakTm(TmUnit, BegTm)+1e-6*CentrQt.GetUrls(), CentrQtId, GetClustFq(CId), FqV));
1598        TInt PeakFq;
1599        const int PeakTm = CentrQt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1600        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1601          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1602        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1603          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1604        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1605        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1606        VizQtIdV.Add(CentrQtId);
1607      } /&bsol;*/
1608    }
1609    { TIntSet QtIdSet;
1610    for (int i = 0; i < WeekPeakQtIdH.Len(); i++) {
1611    }
1612    QtInfoV.Clr(true);
1613    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV2.Len()); i++) {
1614      if (QtIdSet.IsKey(i)) { continue; }
1615      QtInfoV.Add(QtInfoV2[i]);
1616    printf("%d  ", (int) QtInfoV2[i].Val3()); 
1617      if (QtInfoV.Len() > SaveN) { break; }
1618    } } 
1619    THash<TSecTm, TIntFltH> TmCntH; 
1620    for (int i = 0; i < QtInfoV.Len(); i++) {
1621      const TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1622      for (int t = 0; t < FqV.Len(); t++) {
1623        TmCntH.AddDat(FqV[t].Val1).AddDat(i, FqV[t].Val2); }
1624    }
1625    for (int i = 0; i < TmCntH.Len(); i++) {
1626      TmCntH[i].SortByDat(false); }
1627    const int K = 10;
1628    const int Slack = 3*24*3600; 
1629    THash<TInt, TSecTm> QtLastTopH; 
1630    for (int i = 0; i < TmCntH.Len(); i++) {
1631      TIntFltH& TmH = TmCntH[i];
1632      for (int j = 0; j < TMath::Mn(K, TmH.Len()); j++) {
1633        QtLastTopH.AddDat(TmH.GetKey(j), TmCntH.GetKey(i));
1634      }
1635    }
1636    for (int i = 0; i < QtInfoV.Len(); i++) {
1637      TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1638      const TSecTm LastTime = QtLastTopH.GetDat(i);
1639      int x = 0; for (x = 0; x < FqV.Len() && FqV[x].Val1 <= LastTime+Slack; x++) { }
1640      if (x < FqV.Len()) { FqV.Del(x, FqV.Len()-1); }
1641    } 
1642    printf("save from %d quotes\n", QtInfoV.Len());
1643    QtInfoV.Sort();
1644    TIntH QtIdUrlH;  GetQtPageUrl(VizQtIdV, QtIdUrlH);
1645    FILE *F = fopen(TStr::Fmt("qtOt-%sQ.tab", OutFNm.CStr()).CStr(), "wt");
1646    fprintf(F, "QuoteId\tQuote\tUrl\tTotalVol\n");
1647    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1648      fprintf(F, "%d\t%s\t%s\t%d\n", SaveN-i, GetQt(QtInfoV[i].Val2).QtStr.CStr(), GetStr(QtIdUrlH.GetDat(QtInfoV[i].Val2)), (int) QtInfoV[i].Val3);
1649    }
1650    fclose(F);
1651    printf("saveT\n");
1652    F = fopen(TStr::Fmt("qtOt-%sT.tab", OutFNm.CStr()).CStr(), "wt");
1653    fprintf(F, "Time\tQuoteId\tSmoothFreq\tRawFreq\n");
1654    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1655      const TQuote::TTmFltPrV RawFqV = QtInfoV[i].Val4;
1656      TQuote::GetSmoothFqOt(SmoothFqV, RawFqV, TmUnit, 6*24*3600/TmUnitSecs, 1.05, MinTm, MaxTm);  
1657      IAssert(SmoothFqV.Len() >= RawFqV.Len());
1658      for (int d=0, ds = 0; ds < SmoothFqV.Len(); ds++) {
1659        if (TmUnit == tmuDay) { fprintf(F, "%s", SmoothFqV[ds].Val1.GetDtYmdStr().CStr()); }
1660        else { fprintf(F, "%s_%02d", SmoothFqV[ds].Val1.GetDtYmdStr().CStr(), SmoothFqV[ds].Val1.GetHourN()); }
1661        fprintf(F, "\t%d\t%.2f", SaveN-i, SmoothFqV[ds].Val2());
1662        if (d < RawFqV.Len() && SmoothFqV[ds].Val1 == RawFqV[d].Val1) { fprintf(F, "\t%.0f", RawFqV[d].Val2()); d++; } else { fprintf(F, "\t0"); }
1663        fprintf(F, "\n");
1664      }
1665    }
1666    fclose(F);
1667    printf("done.\n");
1668  }
1669  void TQuoteBs::SaveDomainStat(const TStr& OutFNm, const int& MinCnt) const {
1670    THash<TInt, TInt> MedOt, BlogOt, AllOt;
1671    int MedCnt=0, BlogCnt=0, AllCnt=0;
1672    TSecTm BegTm(2008,7,31,0,0,0);
1673    THash<TStr, TIntPr> DomCntH;
1674    for (int q = 0; q < QuoteH.Len(); q++) {
1675      const TQuote& Q = QuoteH[q];
1676      for (int u = 0; u < Q.GetUrls(); u++) {
1677        const int Day = TSecTm(Q.GetTm(u)-BegTm).GetInUnits(tmuDay);
1678        AllOt.AddDat(Day) += 1;  AllCnt++;
1679        if (GetUrlTy(Q.GetUrlId(u)) ==  utMedia) { MedOt.AddDat(Day) += 1;  MedCnt++;}
1680        else { BlogOt.AddDat(Day) += 1;  BlogCnt++; }
1681        TStr Dom = TStrUtil::GetDomNm2(GetStr(Q.GetUrlId(u)));
1682        DomCntH.AddDat(Dom).Val1 += 1;
1683        DomCntH.AddDat(Dom).Val2 += Q.GetCnt(u);
1684      }
1685    }
1686    TGnuPlot::PlotValCntH(AllOt, "ALL", MedOt, "MEDIA", BlogOt, "BLOGS", "overTm-"+OutFNm, TStr::Fmt("Quote freq over time: A:%d M:%d B:%d", AllCnt, MedCnt, BlogCnt),
1687      "Time [days]", "Number of quote mentions");
1688    DomCntH.SortByDat(false);
1689    FILE *F = fopen(TStr::Fmt("domains-%s.tab", OutFNm.CStr()).CStr(), "wt");
1690    fprintf(F, "# %d domains, total mentions:\tAll:%d\tMedia:%d\tBlogs:%d", DomCntH.Len(), AllCnt, MedCnt, BlogCnt);
1691    fprintf(F, "#Domain\tNumber of quotes mentioned\tNumber of mentions\n");
1692    for (int d = 0; d < DomCntH.Len(); d++) {
1693      fprintf(F, "%s\t%d\t%d\n", DomCntH.GetKey(d).CStr(), DomCntH[d].Val1(), DomCntH[d].Val2());
1694    }
1695    fclose(F);
1696  }
1697  void TQuoteBs::Dump(const bool& Fast) const {
1698    printf("Quote base:\n");
1699    if (! Fast) {
1700      TSecTm MinTm, MaxTm; GetMinMaxTm(MinTm, MaxTm);
1701      printf("  %s -- %s\n", MinTm.GetYmdTmStr().CStr(), MaxTm.GetYmdTmStr().CStr());
1702      int totCnt=0, totVol=0;
1703      for (int q = 0; q < QuoteH.Len(); q++) {
1704        const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
1705        totCnt += V.Len();
1706        for (int u = 0; u < V.Len(); u++) {
1707          totVol += V[u].Cnt();
1708        }
1709      }
1710      printf("  %d number of posts mentioning quotes\n", totCnt);
1711      printf("  %d number of mentions\n", totVol);
1712    }
1713    printf("  %d quotes\n", Len());
1714    printf("  %d strings (quotes+urls, no domains)\n", StrQtIdH.Len());
1715    printf("  %d clusters\n", ClustQtIdVH.Len());
1716    printf("  %d quotes in clusters\n", GetQtsInClust());
1717    printf("  %d urls with type\n\n", UrlTyH.Len());
1718  }
1719  PQuoteBs TQuoteBs::FindQtInTxtQBs(const TStr& InBinFNmWc, const TStrV& QuoteStrV) {
1720    THashSet<TMd5Sig> SeenUrlH; 
1721    PQuoteBs QtBsPt = TQuoteBs::New();
1722    TQuoteBs& QtBs = *QtBsPt;
1723    TStrHash<TInt> StrH;
1724    TVec<TIntV> QtWIdVV;
1725    TVec<TIntV> QtSkipLenVV; 
1726    for (int q = 0; q < QuoteStrV.Len(); q++) {
1727      const int QId = QtBs.QuoteH.Len(); 
1728      TQuote& Qt = QtBs.QuoteH.AddDat(QId);
1729      Qt.QtCIdTy = TQuote::TQtIdTy(QId, qtQuote);
1730      Qt.QtStr = QuoteStrV[q];
1731      QtWIdVV.Add();  QtSkipLenVV.Add();
1732      TStrUtil::GetAddWIdV(StrH, QuoteStrV[q].CStr(), QtWIdVV.Last());
1733      TIntV& WIdV = QtWIdVV.Last();
1734      TIntV& SkipV = QtSkipLenVV.Last();
1735      SkipV.Add(1);
1736      for (int w = 1; w < WIdV.Len(); w++) {
1737        int skipLen = 1;
1738        while (w-skipLen >= 0 && WIdV[w-skipLen] != WIdV[w]) { skipLen++; }
1739        SkipV.Add(skipLen);
1740      }
1741    }
1742    TInt WId;
1743    TIntV TxtWIdV;
1744    TVec<char *> WrdV;
1745    TQuoteLoader QL(InBinFNmWc);
1746    while (QL.Next()) {
1747      if (SeenUrlH.IsKey(TMd5Sig(QL.PostUrlStr))) { continue; }
1748      SeenUrlH.AddKey(TMd5Sig(QL.PostUrlStr));
1749      TxtWIdV.Clr();  WrdV.Clr(false);
1750      { TStrUtil::SplitWords(QL.ContentStr, WrdV);
1751      for (int w = 0; w < WrdV.Len(); w++) {
1752        if (StrH.IsKeyGetDat(WrdV[w], WId)) { TxtWIdV.Add(WId); }
1753        else if (TxtWIdV.Len()>0 && TxtWIdV.Last()!=-1) { TxtWIdV.Add(-1); }
1754      } }
1755      for (int q = 0; q < QtWIdVV.Len(); q++) {
1756        const TIntV& QWIdV = QtWIdVV[q];
1757        const TIntV& SkipV = QtSkipLenVV[q];
1758        int cnt = 0;
1759        for (int w = 0; w < TxtWIdV.Len()-QWIdV.Len(); ) {
1760          int len = 0;
1761          while (len < QWIdV.Len() && TxtWIdV[w+len] == QWIdV[len]) { len++; }
1762          if (len == QWIdV.Len()) { cnt+=1;  w+=len; }
1763          else { w += SkipV[len]; }
1764        }
1765        if (cnt > 0) {
1766          QtBs.GetQtN(q).TmUrlCntV.Add(TQuote::TTmUrlCnt(QL.PubTm, QtBs.AddStr(QL.PostUrlStr), cnt));
1767          if (cnt > 255) { printf("*"); }
1768        }
1769      }
1770    }
1771    for (int i = 0; i < QtBs.Len(); i++) { QtBs.QuoteH[i].TmUrlCntV.Sort(); }
1772    return QtBsPt;
1773  }
1774  #ifdef false
1775  void TQuoteBs::BuildQtSubSeqCounts(TIntV& QtIdV, const TStr& OutFNm) {
1776  }
1777  void TQuoteBs::PlotQtFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1778    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1779    TGnuPlot GP("fqOT."+OutFNm);
1780    TFltPrV HrFqV;
1781    if (PlotN == -1) { PlotN = TInt::Mx; }
1782    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1783      const TQuote& Qt = GetQt(QtIdV[i]);
1784      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1785      for (int h = 0; h < HrFqV.Len(); h++) {
1786        HrFqV[h].Val1 = TMath::Round(HrFqV[h].Val1/24.0, 2);
1787      }
1788      GP.AddPlot(HrFqV, gpwLines, TStrUtil::GetShorStr(Qt.QtStr), "lt 1");
1789    }
1790    GP.SetXYLabel("Time [days]", "Frequency");
1791    GP.AddCmd("set nokey");
1792    GP.SavePng("fqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1793    GP.AddCmd("set size 2,0.5");
1794    GP.SaveEps(10);
1795  }
1796  void TQuoteBs::PlotQtCumFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1797    const int TmuSecs = TTmInfo::GetTmUnitSecs(tmu1Hour);
1798    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1799    const TSecTm StartTm = MinTm.Round(tmu1Hour);
1800    const TSecTm EndTm = MaxTm.Round(tmu1Hour);
1801    TQuote::TTmFltPrV HrFqV;
1802    TFltFltH SumCntH;
1803    for (TSecTm Tm = StartTm; Tm <= MaxTm.Round(tmu1Hour); Tm += TmuSecs) {
1804      SumCntH.AddDat(double(Tm-StartTm)/(24.0*3600.0)) = 0;
1805    }
1806    TGnuPlot GP("cfqOT."+OutFNm);
1807    if (PlotN == -1) { PlotN = TInt::Mx; }
1808    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1809      const TQuote& Qt = GetQt(QtIdV[i]);
1810      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, 48, 1.2);
1811      for (int h = 0; h < HrFqV.Len(); h++) {
1812        const TSecTm roundTm = HrFqV[h].Val1.Round(tmu1Hour);
1813        if (roundTm >= StartTm && roundTm<=EndTm) {
1814          SumCntH.AddDat(double(roundTm-StartTm)/(24.0*3600.0)) += HrFqV[h].Val2;
1815        }
1816      }
1817      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr, 100).CStr());
1818    }
1819    GP.SetXYLabel(TStr::Fmt("Time [days] since %s", StartTm.GetYmdTmStr().CStr()), "Stacked frequency");
1820    GP.AddCmd("set notitle");
1821    GP.AddCmd("set nogrid");
1822    GP.AddCmd("set mxtics 4");
1823    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 1000,600");
1824  }
1825  void TQuoteBs::PlotQtCumFqOverTm1(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1826    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1827    TGnuPlot GP("cfqOT."+OutFNm);
1828    TFltPrV HrFqV, HrCFqV;
1829    TFltFltH SumCntH;
1830    if (PlotN == -1) { PlotN = TInt::Mx; }
1831    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1832      const TQuote& Qt = GetQt(QtIdV[i]);
1833      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1834      HrCFqV.Clr(false);
1835      for (int h = 0; h < HrFqV.Len(); h++) {
1836        const double hr = TMath::Round(HrFqV[h].Val1/24.0+0.001, 2);
1837        SumCntH.AddDat(hr) += HrFqV[h].Val2;
1838      }
1839      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr).CStr(), "lt 1");
1840    }
1841    GP.SetXYLabel("Time [days]", "Stacked frequency");
1842    GP.AddCmd("set nokey");
1843    GP.AddCmd("set notitle");
1844    GP.AddCmd("set nogrid");
1845    GP.AddCmd("set mxtics 5");
1846    GP.AddCmd("set xtics 5");
1847    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1848    GP.AddCmd("set size 2,0.5");
1849    GP.SaveEps(8);
1850  }
1851  void TQuoteBs::SaveForMatlab(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1852    const TTmUnit TmUnit = tmu1Hour;
1853    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1854    THash<TInt, TFlt> TmCntH;
1855    TVec<TFltV> TmQtFqV;
1856    const int MinTmUnit = MinTm.GetInUnits(TmUnit);
1857    for (uint i = MinTmUnit; i <= MaxTm.GetInUnits(TmUnit); i++) {
1858      TmCntH.AddDat(i, 0);  TmQtFqV.Add();
1859      TmQtFqV.Last().Add(i-MinTmUnit+1); 
1860    }
1861    TQuote::TTmFltPrV DayFqV;
1862    if (SaveN == -1) { SaveN = TInt::Mx; }
1863    for (int i = 0; i < TMath::Mn(SaveN, QtIdV.Len()); i++) {
1864      const TQuote& Qt = GetQt(QtIdV[i]);
1865      Qt.GetSmoothFqOverTm(DayFqV, TmUnit, 48, 1.2);
1866      for (int d = 0; d < TmCntH.Len(); d++) { TmCntH[d] = 0; }
1867      for (int d = 0; d < DayFqV.Len(); d++) {
1868        const int T = DayFqV[d].Val1.GetInUnits(TmUnit);
1869        if (TmCntH.IsKey(T)) {
1870          TmCntH.AddDat(T) += DayFqV[d].Val2; }
1871      }
1872      for (int d = 0; d < TmCntH.Len(); d++) {
1873        TmQtFqV[d].Add(TmCntH[d]); }
1874    }
1875    FILE *F = fopen(TStr::Fmt("qtFqOtMATLAB-%s.tab", OutFNm.CStr()).CStr(), "wt");
1876    for (int d = 0; d < TmQtFqV.Len(); d++) {
1877      fprintf(F, "%g", TmQtFqV[d][0]());
1878      for (int q = 1; q < TmQtFqV[d].Len(); q++) {
1879        fprintf(F, "\t%g", TmQtFqV[d][q]()); }
1880      fprintf(F, "\n");
1881    }
1882    fclose(F);
1883  }
1884  void TQuoteBs::SaveQtTmUrlTxt(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1885    if (SaveN == -1) { SaveN = TInt::Mx; }
1886    SaveN = TMath::Mn(SaveN, QtIdV.Len());
1887    FILE *F = fopen(OutFNm.CStr(), "wt");
1888    for (int q = 0; q < QtIdV.Len(); q++) {
1889      const TQuote& Qt = GetQt(QtIdV[q]);
1890      fprintf(F, "%s\t%d\n", Qt.QtStr.CStr(), Qt.GetFq());
1891      for (int u = 0; u < Qt.GetUrls(); u++) {
1892        fprintf(F, "\t%s\t%s\n", Qt.TmUrlCntV[u].Val1.GetYmdTmStr().CStr(), GetStr(Qt.TmUrlCntV[u].Val2));
1893      }
1894      fprintf(F, "\n");
1895    }
1896    fclose(F);
1897  }
1898  void TQuoteBs::PlotSubQtOverTm(const int& QtId, const TStr& OutFNm) const {
1899    TIntV PlotQtV;
1900    const TQuote Qt = GetQt(QtId);
1901    PlotQtV.Add(QtId);
1902    TIntV WrdBegV; WrdBegV.Add(0);
1903    for (int i = 1; i < Qt.QtStr.Len()-1; i++) {
1904      if (TCh::IsAlNum(Qt.QtStr.GetCh(i)) && TCh::IsWs(Qt.QtStr.GetCh(i-1))) { WrdBegV.Add(i); }
1905    }
1906    TInt subQtId;
1907    WrdBegV.Add(Qt.QtStr.Len()+1); 
1908    const int QtWords = TStrUtil::CountWords(Qt.QtStr.CStr());
1909    for (int WndSz = 5; WndSz < QtWords; WndSz++) {
1910      for (int word = 0; word < QtWords-WndSz; word++) {
1911        const TStr SubQtStr = Qt.QtStr.GetSubStr(WrdBegV[word], WrdBegV[word+WndSz]-2);
1912        if (StrH.IsKeyGetDat(SubQtStr, subQtId) && QuoteH.IsKey(subQtId) && subQtId!=QtId) { PlotQtV.Add(subQtId); printf("."); }
1913      }
1914    }
1915    TGnuPlot GP(OutFNm, TStr::Fmt("%d occurences, %d urls, %d domains: %s", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(), Qt.QtStr.CStr()));
1916    TFltPrV HrFqV;
1917    for (int i = 0; i < PlotQtV.Len(); i++) {
1918      const TQuote& subQt = QuoteH.GetDat(PlotQtV[i]);
1919      subQt.GetSmoothFqOverTm(HrFqV, tmu1Hour);
1920      GP.AddPlot(HrFqV, gpwLines, subQt.QtStr.CStr());
1921    }
1922    GP.SetXYLabel("Time [hours]", "Frequency");
1923    GP.SavePng(OutFNm+".png", -1, -1, "", "set terminal png small size 1000,800");
1924  }
1925  void TQuoteBs::PlotTopQuotesOverTm(const int& StepSecs, const int& IntervalSecs, const int& TakeNPerStep, const TStr& OutFNm) const {
1926    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1927    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1928    TIntSet TopQtIdSet;
1929    int cnt=0;
1930    TIntV TopQtIdV;
1931    for (TSecTm Tm(MinTm); Tm < MaxTm; Tm += StepSecs, cnt++) {
1932      FailR("TopQuotesOverTm: take top quotes from each day");
1933      for (int q = 0; q < TopQtIdV.Len(); q++) { TopQtIdSet.AddKey(TopQtIdV[q]); }
1934    }
1935    printf("\n%d time steps total, %d quotes per step: %d total quotes\n", cnt, TakeNPerStep, TopQtIdSet.Len());
1936    printf("%s   %d\n", MinTm.Round(tmuDay).GetStr().CStr(), MinTm.Round(tmuDay).GetInUnits(tmu1Hour));
1937    TFltPrV FqOverTm;
1938    TGnuPlot GP(TStr("topQtOverTm.")+OutFNm, "");
1939    TFOut FOut(OutFNm+TStr(".Quote"));
1940    for (int q = 0; q < TopQtIdSet.Len(); q++) {
1941      const TQuote& Q = QuoteH.GetDat(TopQtIdSet[q]);
1942      Q.Save(FOut);
1943      Q.GetSmoothFqOverTm(FqOverTm, tmu1Hour, MinTm.Round(tmuDay));
1944      GP.AddPlot(FqOverTm, gpwLines, Q.QtStr);
1945    }
1946    GP.AddCmd("set xtics 24"); GP.AddCmd("set mxtics 4");
1947    GP.SetXYLabel(TStr("time [hours] from "+MinTm.Round(tmuDay).GetStr()), "frequency");
1948    GP.SavePng(TStr("topQtOverTm.")+OutFNm+TStr(".png"), -1, -1, "", "set terminal png small size 2000,800");
1949  }
1950  PQuoteBs TQuoteBs::BuildQuoteBs(const TStr& InBinFNmWc, const int& MinQtWrdLen) {
1951    PQuoteBs QBsPt = TQuoteBs::New(InBinFNmWc);
1952    QBsPt->AddToQuoteBs(InBinFNmWc, MinQtWrdLen);
1953    return QBsPt;
1954  }
1955  #endif
1956  PClustNet TClustNet::GetSubGraph(const TIntV& NIdV) const {
1957    PClustNet NewNetPt = TClustNet::New();
1958    TClustNet& NewNet = *NewNetPt;
1959    NewNet.Reserve(NIdV.Len(), -1);
1960    int node, edge;
1961    TClustNet::TNodeI NI;
1962    for (node = 0; node < NIdV.Len(); node++) {
1963      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
1964    }
1965    for (node = 0; node < NIdV.Len(); node++) {
1966      NI = GetNI(NIdV[node]);
1967      const int SrcNId = NI.GetId();
1968      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
1969        const int OutNId = NI.GetOutNId(edge);
1970        if (NewNet.IsNode(OutNId)) {
1971          NewNet.AddEdge(SrcNId, OutNId); }
1972      }
1973    }
1974    NewNet.Defrag();
1975    return NewNetPt;
1976  }
1977  void TClustNet::AddLink(const TQuote& SrcQt, const TQuote& DstQt) {
1978    const int Qt1Id = SrcQt.GetCId();
1979    const int Qt2Id = DstQt.GetCId();
1980    if (! IsNode(Qt1Id)) {
1981      AddNode(Qt1Id, SrcQt); }
1982    if (! IsNode(Qt2Id)) {
1983      AddNode(Qt2Id, DstQt); }
1984    if (! IsEdge(Qt2Id, Qt1Id)) {
1985      AddEdge(Qt1Id, Qt2Id);
1986    }
1987  }
1988  PClustNet TClustNet::GetSubGraph(const int& MinQtWords, const int& MaxQtWords, const int& MinFq) const {
1989    TIntV NIdV;
1990    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
1991      const int Wrds = TStrUtil::CountWords(NI().GetStr().CStr());
1992      if (NI().GetFq() >= MinFq &&  Wrds >= MinQtWords && Wrds <= MaxQtWords) {
1993        NIdV.Add(NI.GetId()); }
1994    }
1995    return GetSubGraph(NIdV);
1996  }
1997  void TClustNet::RecalcEdges(const double& MinOverlapFrac) {
1998    printf("Recalculating edges...\n");
1999    TIntPrV DelEdgeV;
2000    TStrHash<TInt> StrH(Mega(1), true);
2001    int WIdV1Start, WIdV2Start, SkipTy;
2002    TIntV WIdV1, WIdV2;
2003    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2004      const TStr Q1 = NI().GetStr();
2005      TStrUtil::GetAddWIdV(StrH, Q1.CStr(), WIdV1);
2006      for (int e = 0; e < NI.GetOutDeg(); e++) {
2007        const TStr Q2 = NI.GetOutNDat(e).GetStr();
2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
2010        const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2011        const int LongLen = TMath::Mx(WIdV1.Len(), WIdV2.Len());
2012        IAssert(Overlap<=ShortLen);
2013        if (2*ShortLen>LongLen && Overlap/double(ShortLen) > MinOverlapFrac) { continue; }
2014        DelEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(e)));
2015      }
2016    }
2017    printf("Deleting %d/%d (%.4f) edges\n", DelEdgeV.Len(), GetEdges(), DelEdgeV.Len()/double(GetEdges()));
2018    for (int i = 0; i < DelEdgeV.Len(); i++) {
2019      DelEdge(DelEdgeV[i].Val1, DelEdgeV[i].Val2);
2020    }
2021  }
2022  void TClustNet::MakeClusters(const TIntPrV& KeepEdgeV) {
2023    PUNGraph G = TUNGraph::New();
2024    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2025      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2026        G->AddNode(KeepEdgeV[e].Val1); }
2027      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2028        G->AddNode(KeepEdgeV[e].Val2); }
2029      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2030    }
2031    TCnComV CnComV;
2032    TSnap::GetWccs(G, CnComV);
2033    TIntH NIdCcIdH(GetNodes());
2034    for (int c = 0; c < CnComV.Len(); c++) {
2035      const TIntV& NIdV = CnComV[c].NIdV;
2036      for (int n = 0; n < NIdV.Len(); n++) {
2037        NIdCcIdH.AddDat(NIdV[n], c);
2038      }
2039    }
2040    TIntPrV DelEdgeV;
2041    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2042      const int ccid1 = NIdCcIdH.IsKey(EI.GetSrcNId()) ? NIdCcIdH.GetDat(EI.GetSrcNId()).Val : -1;
2043      const int ccid2 = NIdCcIdH.IsKey(EI.GetDstNId()) ? NIdCcIdH.GetDat(EI.GetDstNId()).Val : -1;
2044      if (ccid1 != ccid2 && ccid1!=-1 && ccid2!=-1) {
2045        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
2046    }
2047    const int Edges = GetEdges();
2048    printf("Deleting %d out of %d  (%f) edges\n", DelEdgeV.Len(), Edges, DelEdgeV.Len()/double(Edges));
2049    for (int d = 0; d < DelEdgeV.Len(); d++) {
2050      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2051    }
2052  }
2053  void TClustNet::KeepOnlyTree(const TIntPrV& KeepEdgeV) {
2054    TIntPrSet EdgeSet(KeepEdgeV.Len());
2055    for (int i = 0; i < KeepEdgeV.Len(); i++) {
2056      EdgeSet.AddKey(TIntPr(TMath::Mn(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2),
2057        TMath::Mx(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2)));
2058    }
2059    TIntPrSet DelEdgeV;
2060    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2061      const int N1 = TMath::Mn(EI.GetSrcNId(), EI.GetDstNId());
2062      const int N2 = TMath::Mx(EI.GetSrcNId(), EI.GetDstNId());
2063      if (! EdgeSet.IsKey(TIntPr(N1, N2))) {
2064        DelEdgeV.AddKey(TIntPr(N1, N2)); }
2065    }
2066    printf("deleting %d edges\n", DelEdgeV.Len());
2067    for (int d = 0; d < DelEdgeV.Len(); d++) {
2068      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2069    }
2070  }
2071  void TClustNet::GetClusters(TVec<TIntV>& QtNIdV) const {
2072    TCnComV CnComV;
2073    TSnap::GetWccs(GetThis(), CnComV);
2074    CnComV.Sort(false);
2075    QtNIdV.Clr(false);
2076    TIntSet SeenSet;
2077    for (int i = 0; i < CnComV.Len(); i++) {
2078      for (int n = 0; n < CnComV[i].NIdV.Len(); n++) {
2079        IAssert(! SeenSet.IsKey(CnComV[i].NIdV[n]));
2080        SeenSet.AddKey(CnComV[i].NIdV[n]);
2081      }
2082      QtNIdV.Add(CnComV[i].NIdV);
2083    }
2084  }
2085  void TClustNet::GetMergedClustQt(const TIntV& QtIdV, TQuote& NewQt) const {
2086    int CentrQtId=-1, MxFq=0;
2087    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
2088    for (int c = 0; c < QtIdV.Len(); c++) {
2089      const TQuote& Q = GetNDat(QtIdV[c]);
2090      IAssert(Q.GetId() == QtIdV[c]);
2091      for (int t = 0; t < Q.GetTimes(); t++) {
2092        TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.GetTm(t), Q.GetUrlId(t))) += Q.GetCnt(t);
2093      }
2094      if (MxFq < Q.GetFq()) {
2095        MxFq = Q.GetFq();
2096        CentrQtId = Q.GetId();
2097      }
2098    }
2099    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
2100    NewQt.QtStr = GetNDat(CentrQtId).GetStr(); 
2101    NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
2102    for (int u = 0; u < TmUrlCntH.Len(); u++) {
2103      NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
2104    }
2105    NewQt.TmUrlCntV.Sort();
2106  }
2107  int TClustNet::EvalPhraseClusters(const TIntPrV& KeepEdgeV, const bool& dump) const {
2108    PNGraph G = TNGraph::New();
2109    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2110      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2111        G->AddNode(KeepEdgeV[e].Val1); }
2112      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2113        G->AddNode(KeepEdgeV[e].Val2); }
2114      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2115    }
2116    TCnComV CnComV;
2117    TSnap::GetWccs(G, CnComV);
2118    G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2119    int TotEdges=0, EdgesInBigClust=0;
2120    int TotNodes=0, NodesInBigClust=0;
2121    int BigClust=0;
2122    for (int cc = 0; cc < CnComV.Len(); cc++) {
2123      if (CnComV[cc].NIdV.Len() < 3) { continue; }
2124      PNGraph CC = TSnap::GetSubGraph(G, CnComV[cc].NIdV);
2125      TotEdges += CC->GetEdges();
2126      TotNodes += CC->GetNodes()-1;
2127      if (CC->GetNodes() > 10) {
2128        EdgesInBigClust += CC->GetEdges();
2129        NodesInBigClust += CC->GetNodes()-1;
2130        BigClust++;
2131      }
2132    }
2133    if (dump) {
2134      printf("                                all\tbig(>10)\n");
2135      printf("  Number of clusters:           %d\t%d\n", CnComV.Len(), BigClust);
2136      printf("  Total edges inside clusters:  %d\t%d\n", TotEdges, TotEdges-TotNodes);
2137      printf("  Total edges deleted:          %d\t%d\n", GetEdges()-TotEdges, GetEdges()-TotEdges-TotNodes);
2138      printf("  Total edges in big clusters:  %d\t%d\n", EdgesInBigClust, EdgesInBigClust-NodesInBigClust);
2139    }
2140    return TotEdges-TotNodes;
2141  }
2142  void TClustNet::ClustKeepSingleEdge(const int& MethodId) const {
2143    TIntPrV KeepEdgeV;
2144    ClustKeepSingleEdge(MethodId, KeepEdgeV);
2145  }
2146  void TClustNet::ClustKeepSingleEdge(const int& MethodId, TIntPrV& KeepEdgeV) const {
2147    PNGraph G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2148    KeepEdgeV.Clr(false);
2149    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2150      IAssert(NI.GetId() == NI().GetId());
2151      int EdgeToKeep = -1, BestVal=0;
2152      for (int e = 0; e < NI.GetOutDeg(); e++) {
2153        if (MethodId==1 && NI.GetOutNDat(e).GetFq() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetFq(); }
2154        if (MethodId==2 && NI.GetOutNDat(e).GetStr().Len() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2155        if (MethodId==3 && NI.GetOutNDat(e).GetStr().Len() < BestVal ||BestVal==0) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2156      }
2157      if (MethodId==4 && NI.GetOutDeg()>0) {
2158        EdgeToKeep = TInt::Rnd.GetUniDevInt(NI.GetOutDeg()); }
2159      if (EdgeToKeep!=-1) {
2160        KeepEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(EdgeToKeep))); }
2161    }
2162    if (MethodId==1) { printf("Keep edge to most frequent quote:\n"); }
2163    if (MethodId==2) { printf("Keep edge to longest quote:\n"); }
2164    if (MethodId==3) { printf("Keep edge to shortest quote:\n"); }
2165    if (MethodId==4) { printf("Keep random edge:\n"); }
2166    EvalPhraseClusters(KeepEdgeV);
2167  }
2168  void TClustNet::ClustGreedyTopDown() const {
2169    TIntPrV KeepEdgeV;
2170    ClustGreedyTopDown(KeepEdgeV);
2171  }
2172  void TClustNet::ClustGreedyTopDown(TIntPrV& KeepEdgeV) const {
2173    TIntH NIdOutDegH;
2174    TIntH NIdClustH;
2175    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2176      NIdOutDegH.AddDat(NI.GetId(), NI.GetOutDeg());
2177      if (NI.GetOutDeg() == 0) {
2178        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2179    }
2180    printf("%d root nodes\n", NIdClustH.Len());
2181    printf("%d nodes\n", NIdOutDegH.Len());
2182    NIdOutDegH.SortByDat(true);
2183    THash<TInt, TIntPr> ClustCntH;
2184    KeepEdgeV.Clr(false);
2185    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2186      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2187        IAssert(IsNode(NIdOutDegH.GetKey(i)));
2188        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2189        for (int e = 0; e < NI.GetInDeg(); e++) {
2190          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2191        ClustCntH.Clr(false);
2192        for (int e = 0; e < NI.GetOutDeg(); e++) {
2193          IAssert(NIdClustH.IsKey(NI.GetOutNId(e)));
2194          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1; 
2195          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2196        }
2197        ClustCntH.SortByDat(false);
2198        if (ClustCntH.Len() > 0) {
2199          const int NId = NI.GetId();
2200          const int NId2 = ClustCntH[0].Val2;
2201          const int CId = NIdClustH.GetDat(NId2);
2202          KeepEdgeV.Add(TIntPr(NId, NId2)); 
2203          NIdClustH.AddDat(NId, CId); 
2204        }
2205        NIdOutDegH[i] = TInt::Mx;
2206      }
2207      NIdOutDegH.SortByDat(true);
2208    }
2209    printf("Greedy top down approach:\n");
2210    EvalPhraseClusters(KeepEdgeV);
2211  }
2212  void TClustNet::ClustGreedyRandom() const {
2213    printf("Greedy random:\n");
2214    THash<TInt, TIntV> OutNIdV;
2215    THash<TInt, TInt> EdgeH;
2216    TIntPrV KeepEdgeV;
2217    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2218      if (NI.GetOutDeg() > 0) {
2219        EdgeH.AddDat(NI.GetId()) = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
2220        if (NI.GetOutDeg() > 1) {
2221          for (int e = 0; e < NI.GetOutDeg(); e++) {
2222            OutNIdV.AddDat(NI.GetId()).Add(NI.GetOutNId(e)); }
2223        }
2224      }
2225    }
2226    { TIntH NIdOutDegH;
2227    TIntH NIdClustH;
2228    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2229      NIdOutDegH.AddDat(NI.GetId()) = NI.GetOutDeg();
2230      if (NI.GetOutDeg() == 0) {
2231        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2232    }
2233    NIdOutDegH.SortByDat(true);
2234    THash<TInt, TIntPr> ClustCntH;
2235    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2236      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2237        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2238        for (int e = 0; e < NI.GetInDeg(); e++) {
2239          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2240        ClustCntH.Clr(false);
2241        for (int e = 0; e < NI.GetOutDeg(); e++) {
2242          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1;
2243          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2244        }
2245        ClustCntH.SortByDat(false);
2246        if (ClustCntH.Len() > 0) {
2247          KeepEdgeV.Add(TIntPr(NI.GetId(), ClustCntH[0].Val2));
2248        }
2249        NIdOutDegH[i] = TInt::Mx;
2250      }
2251      NIdOutDegH.SortByDat(true);
2252    } }
2253    printf("%d\n", EdgeH.Len());
2254    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2255      EdgeH.AddDat(KeepEdgeV[e].Val1) = KeepEdgeV[e].Val2;
2256    }
2257    printf("%d\n", EdgeH.Len());
2258    EdgeH.GetKeyDatPrV(KeepEdgeV);
2259    int CurScore = EvalPhraseClusters(KeepEdgeV);
2260    while (true) {
2261        const int RndNId = OutNIdV.GetKey(TInt::Rnd.GetUniDevInt(OutNIdV.Len()));
2262        const int RndEdge = OutNIdV.GetDat(RndNId)[TInt::Rnd.GetUniDevInt(OutNIdV.GetDat(RndNId).Len())];
2263        const int id = EdgeH.GetKeyId(RndNId);  IAssert(KeepEdgeV[id].Val1 == RndNId);
2264        if (KeepEdgeV[id].Val2 == RndEdge) { continue; } 
2265        const int OldE = KeepEdgeV[id].Val2;
2266        KeepEdgeV[id].Val2 = RndEdge;
2267      const int NewScore = EvalPhraseClusters(KeepEdgeV, false);
2268      if (NewScore > CurScore &bsol;*|| TInt::Rnd.GetUniDev() < 0.1*/) {
2269        printf("%6d --> %6d\n", CurScore, NewScore);
2270        CurScore = NewScore;
2271      }
2272      else {  KeepEdgeV[id].Val2 = OldE; } 
2273    }
2274  }
2275  TChA InsertLineBreaks(const TChA& ChA, const int& BreakAtPost) {
2276    TChA Tmp = ChA, Out;
2277    int Lines = 1;
2278    TVec<char*> WrdV;
2279    TStrUtil::SplitWords(Tmp, WrdV);
2280    for (int w = 0; w < WrdV.Len(); w++) {
2281      if (Out.Len() + (int)strlen(WrdV[w]) > Lines*BreakAtPost) {
2282        Lines++; Out+="\\n"; }
2283      Out += WrdV[w];
2284      Out += " ";
2285    }
2286    return Out;
2287  }
2288  void TClustNet::DrawNet(const TStr& OutFNm, const int& SaveTopN) const {
2289    TCnComV CnComV;
2290    TSnap::GetWccs(GetThis(), CnComV);
2291    CnComV.Sort(false);
2292    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2293      if (CnComV[Comp].Len() < 5) { continue; }
2294      TPt<TNet> SubNet = TSnap::GetSubGraph(TPt<TNet>((TClustNet*) this), CnComV[Comp].NIdV);
2295      printf("draw: %d nodes, %d edges\n", SubNet->GetNodes(), SubNet->GetEdges());
2296      FILE *F = fopen(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp).CStr(), "wt");
2297      fprintf(F, "digraph G { &bsol;*%d nodes, %d edges*/\n", SubNet->GetNodes(), SubNet->GetEdges());
2298      fprintf(F, "  graph [splines=true overlap=false rankdir=LR]\n");
2299      fprintf(F, "  node  [shape=box, fontsize=14]\n");
2300      for (TNet::TNodeI NI = SubNet->BegNI(); NI < SubNet->EndNI(); NI++) {
2301        fprintf(F, "  %d [label=\"%s (%d, %d)\"];\n", NI.GetId(), InsertLineBreaks(NI().GetStr(), 80).CStr(), NI().GetFq(), NI().GetUrls());
2302      }
2303      for (TNet::TEdgeI EI = SubNet->BegEI(); EI < SubNet->EndEI(); EI++) {
2304        fprintf(F, "  %d -> %d;\n", EI.GetSrcNId(), EI.GetDstNId());
2305      }
2306      fprintf(F, "}\n");
2307      fclose(F);
2308      TGraphViz::DoLayout(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp), TStr::Fmt("%s-c%02d.ps", OutFNm.CStr(), Comp), gvlDot);
2309      TSnap::SavePajek(SubNet, TStr::Fmt("%s-c%02d.net", OutFNm.CStr(), Comp));
2310    }
2311  }
2312  void TClustNet::DumpNodes(const TStr& OutFNm, const int& SaveTopN) const {
2313    TIntV NIdV;  GetNIdV(NIdV);
2314    TIntH NIdCompSzH;
2315    { TCnComV CnComV;
2316    TSnap::GetWccs(GetThis(), CnComV);
2317    for (int c = 0; c < CnComV.Len(); c++) {
2318      for (int n = 0; n < CnComV[c].NIdV.Len(); n++) {
2319        NIdCompSzH.AddDat(CnComV[c].NIdV[n], CnComV[c].Len());
2320      }
2321    } }
2322    TIntPrV FqNIdV;
2323    for (int n = 0; n < NIdV.Len(); n++) {
2324      FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2325    }
2326    FqNIdV.Sort(false);
2327    FILE *F = fopen(TStr::Fmt("nodes-%s.txt", OutFNm.CStr()).CStr(), "wt");
2328    fprintf(F, "#Freq\tClustSz\tQuote\n");
2329    for (int i = 0; i < FqNIdV.Len(); i++) {
2330      const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2331      fprintf(F, "%d\t%d\t%s\n", Q.GetFq(), NIdCompSzH.GetDat(FqNIdV[i].Val2).Val, Q.GetStr().CStr());
2332    }
2333  }
2334  void TClustNet::DumpClusters(const TStr& OutFNm, int SaveTopN) const {
2335    TCnComV CnComV;
2336    TSnap::GetWccs(GetThis(), CnComV); 
2337    CnComV.Sort(false);
2338    FILE *F = fopen(TStr::Fmt("clust-%s.txt", OutFNm.CStr()).CStr(), "wt");
2339    if (SaveTopN==-1) { SaveTopN=TInt::Mx; }
2340    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2341      const TIntV& NIdV = CnComV[Comp].NIdV;
2342      TIntPrV FqNIdV;
2343      int SumFq=0;
2344      for (int n = 0; n < NIdV.Len(); n++) {
2345        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2346        SumFq += GetNDat(NIdV[n]).GetFq();
2347      }
2348      FqNIdV.Sort(false);
2349      fprintf(F, "%d quotes, total freq %d\n", FqNIdV.Len(), SumFq);
2350      for (int i = 0; i < FqNIdV.Len(); i++) {
2351        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2352        fprintf(F, "%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2353      }
2354      fprintf(F, "\n");
2355    }
2356  }
2357  void TClustNet::DumpClustersByVol(const TStr& OutFNm, const int& MinClustSz, const int& MinVolume) const {
2358    TCnComV CnComV;
2359    TSnap::GetWccs(GetThis(), CnComV);
2360    CnComV.Sort(false);
2361    TIntPrV FqClustV;
2362    TIntH ClSzH, ClFqH;
2363    int FqMore1k=0;
2364    for (int Comp = 0; Comp < CnComV.Len(); Comp++) {
2365      const TIntV& NIdV = CnComV[Comp].NIdV;
2366      if (NIdV.Len() < MinClustSz) { continue; } 
2367      int SumFq=0;
2368      for (int n = 0; n < NIdV.Len(); n++) {
2369        SumFq += GetNDat(NIdV[n]).GetFq(); }
2370      FqClustV.Add(TIntPr(SumFq, Comp));
2371      ClFqH.AddDat(SumFq) += 1;
2372      ClSzH.AddDat(NIdV.Len()) += 1;
2373      if (SumFq>500) { FqMore1k++; }
2374    }
2375    FqClustV.Sort(false);
2376    FILE *F = fopen(TStr::Fmt("clustFq-%s.txt", OutFNm.CStr()).CStr(), "wt");
2377    fprintf(F, "Cluster network:\n%d nodes\n%d edges\n%d clusters\n%d big clusters (>=%d)\n",
2378      GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz);
2379    for (int c = 0; c < FqClustV.Len(); c++) {
2380      const TIntV& NIdV = CnComV[FqClustV[c].Val2].NIdV;
2381      TIntPrV FqNIdV;
2382      int SumFq=0;
2383      for (int n = 0; n < NIdV.Len(); n++) {
2384        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2385        SumFq += GetNDat(NIdV[n]).GetFq();
2386      }
2387      if (SumFq < MinVolume) { continue; }
2388      FqNIdV.Sort(false);
2389      fprintf(F, "%d\t%d items\t%d totFq\n", c, FqNIdV.Len(), SumFq);
2390      for (int i = 0; i < FqNIdV.Len(); i++) {
2391        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2392        fprintf(F, "\t%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2393      }
2394      fprintf(F, "\n");
2395    }
2396    TGnuPlot::PlotValCntH(ClFqH, "clVol."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2397      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster volume", "Count", gpsLog);
2398    TGnuPlot::PlotValCntH(ClSzH, "clSz."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2399      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster size", "Count", gpsLog);
2400  }
2401  void BuildPhraseInvertIdx(const PQuoteBs& QtBs, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& WIdQtIdVH) {
2402    printf("build quote word inverted index\n");
2403    TIntV WIdV;
2404    TIntSet WIdSet;
2405    for (int q = 0; q < QtBs->Len(); q++) {
2406      const TQuote& Q = QtBs->GetQtN(q);
2407      TStrUtil::GetAddWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2408      const int Doms = Q.GetDoms(*QtBs);
2409      if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= 5)) { 
2410        continue;
2411      }
2412      WIdSet.Clr(false); 
2413      for (int w = 0; w < WIdV.Len(); w++) {
2414        WIdSet.AddKey(WIdV[w]);
2415      }
2416      for (int w = 0; w < WIdSet.Len(); w++) {
2417        WIdQtIdVH.AddDat(WIdSet[w]).Add(q);
2418      }
2419    }
2420    for (int i = 0; i < WIdQtIdVH.Len(); i++) {
2421      WIdQtIdVH[i].Pack();
2422    }
2423    printf("done.\n");
2424  }
2425  bool IsLinkPhrases(const PQuoteBs& QtBs, const int& QtN1, const int& QtN2, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& QtToWordIdVH) {
2426    if (! QtToWordIdVH.IsKey(QtN1)) {
2427      TIntV WIdV;
2428      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN1).GetStr().CStr(), WIdV);
2429      WIdV.Pack();
2430      QtToWordIdVH.AddDat(QtN1, WIdV);
2431    }
2432    if (! QtToWordIdVH.IsKey(QtN2)) {
2433      TIntV WIdV;
2434      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN2).GetStr().CStr(), WIdV);
2435      WIdV.Pack();
2436      QtToWordIdVH.AddDat(QtN2, WIdV);
2437    }
2438    int idx1=0, idx2=0, SkipTy=0;
2439    const TIntV& WIdV1 = QtToWordIdVH.GetDat(QtN1);
2440    const TIntV& WIdV2 = QtToWordIdVH.GetDat(QtN2);
2441    const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2442    const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, idx1, idx2, SkipTy);
2443    bool DoMerge = false;
2444    if (ShortLen <= 5 && Overlap == ShortLen &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
2445    else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
2446    else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
2447    return DoMerge;
2448  }
2449  PClustNet TClustNet::GetFromQtBs(const PQuoteBs& QtBs, int MinQtFq, int MnWrdLen) {
2450    TStrHash<TInt> WordIdH;
2451    THash<TInt, TIntV> WIdQtIdVH; 
2452    BuildPhraseInvertIdx(QtBs, WordIdH, WIdQtIdVH);
2453    PClustNet Net = TClustNet::New();
2454    TVec<int> QtSharCnt(QtBs->Len()), QtWrdLen(QtBs->Len());
2455    THash<TInt, TIntV> QtToWordIdVH;   
2456    TIntV WIdV;
2457    TIntH CandLenH, LinkLenH;
2458    THash<TInt, TIntH> QtLenCandH, QtLenLinkH;
2459    int AllCand=0, AllLinks=0;
2460    TExeTm ExeTm;
2461    for (int qt = 0; qt < QtBs->Len(); qt++) {
2462      QtWrdLen[qt] = TStrUtil::CountWords(QtBs->GetQtN(qt).GetStr().CStr());
2463    }
2464    const int QtBsLen = QtBs->Len();
2465    for (int qt = 0; qt < QtBs->Len(); qt++) {
2466      const TQuote& Q = QtBs->GetQtN(qt);
2467      const int Doms = Q.GetDoms(*QtBs);
2468    if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq &&
2469      TStrUtil::CountWords(Q.GetStr())>=MnWrdLen)) {
2470        continue; }
2471      memset(QtSharCnt.BegI(), 0, sizeof(int)*QtSharCnt.Len());
2472      TStrUtil::GetWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2473      if (! QtToWordIdVH.IsKey(qt)) {
2474        WIdV.Pack();
2475        QtToWordIdVH.AddDat(qt, WIdV);
2476      }
2477      for (int w = 0; w < WIdV.Len(); w++) {
2478        IAssert(WIdQtIdVH.IsKey(WIdV[w]));
2479        const TIntV& QtIdV = WIdQtIdVH.GetDat(WIdV[w]);
2480        for (int q = 0; q < QtIdV.Len(); q++) {
2481          QtSharCnt[QtIdV[q]] += 1;
2482        }
2483      }
2484      const int W = WIdV.Len();
2485      int Candidates = 0, Links = 0, MinSharedWords = W-3;
2486      if (W <= 5) { MinSharedWords = W-1; }
2487      else if (W <= 10) { MinSharedWords = W-2; }
2488      for (int q = 0; q < QtSharCnt.Len(); q++) {
2489        if (QtSharCnt[q] >= MinSharedWords && (QtWrdLen[q] >= W || QtWrdLen[q] > 20)) {
2490          const TQuote& Qt2 = QtBs->GetQtN(q);
2491          if (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
2492            if (IsLinkPhrases(QtBs, qt, q, WordIdH, QtToWordIdVH)) {    
2493              Net->AddLink(Q, Qt2);
2494              Links++;
2495            }
2496          }
2497          Candidates++;
2498        }
2499      }
2500      AllCand += Candidates;
2501      AllLinks += Links;
2502      CandLenH.AddDat(Candidates) += 1;
2503      LinkLenH.AddDat(Links) += 1;
2504      if (W < 21) {
2505        QtLenCandH.AddDat(W).AddDat(Candidates) += 1;
2506        QtLenLinkH.AddDat(W).AddDat(Links) += 1;
2507      }
2508      if (qt % 1000 == 0 || qt==QtBsLen-1) {
2509        printf("\r%d  %s    allCands: %d    allLinks: %d    nodes:%d", qt, ExeTm.GetStr(), AllCand, AllLinks, Net->GetNodes());
2510        if (qt % 100000 == 0 || qt==QtBsLen-1) {
2511          TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2512            "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2513          TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2514            "ClustNet: number of out-links of a quote", "Count", gpsLog);
2515        }
2516      }
2517    }
2518    printf("done.\n");
2519    TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2520      "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2521    TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2522      "ClustNet: number of out-links of a quote", "Count", gpsLog);
2523    return Net;
2524  }
2525  void TQuoteLoader::Clr() {
2526    PostTitleStr.Clr();
2527    PostUrlStr.Clr();
2528    PubTm = TSecTm();
2529    BlogUrlStr.Clr();
2530    BlogTitleStr.Clr();
2531    ContentStr.Clr();
2532    QuoteV.Clr(false);
2533    LinkV.Clr(false);
2534  }
2535  bool TQuoteLoader::LoadItem(TXmlLx& XmlLx) {
2536    static const TSecTm BegOfTm(2008,8,30, 0, 0, 0);
2537    Clr();
2538    try {
2539      EAssert(XmlLx.TagNm == "post");
2540      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, "pubDate");
2541      PubTm = TSecTm(atoi(T.GetSubStr(0,3).CStr()), atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(8,9).CStr()),
2542        atoi(T.GetSubStr(11,12).CStr()), atoi(T.GetSubStr(14,15).CStr()), atoi(T.GetSubStr(17,18).CStr()));
2543      EAssert(PubTm > BegOfTm);
2544      PostUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "postUrl");
2545      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "postTitle");
2546      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "blogUrl");
2547      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "blogTitle");
2548      ContentStr = TStrUtil::GetXmlTagVal(XmlLx, "content");
2549      while (XmlLx.GetSym()==xsySTag && XmlLx.TagNm=="q") {
2550        EAssert(XmlLx.GetSym() == xsyStr);
2551        QuoteV.Add(XmlLx.TxtChA);
2552        EAssert(XmlLx.GetSym() == xsyETag && XmlLx.TagNm=="q");
2553      }
2554    }
2555    catch (PExcept Except){
2556      ErrNotify(Except->GetStr());
2557      Fail;  return false;
2558    }
2559    return true;
2560  }
2561  void TQuoteLoader::Save(TSOut& SOut) const {
2562    PubTm.Save(SOut);
2563    PostUrlStr.Save(SOut);
2564    PostTitleStr.Save(SOut);
2565    BlogUrlStr.Save(SOut);
2566    BlogTitleStr.Save(SOut);
2567    ContentStr.Save(SOut);
2568    QuoteV.Save(SOut);
2569    LinkV.Save(SOut);
2570  }
2571  void TQuoteLoader::Load(TSIn& SIn) {
2572    PubTm.Load(SIn);
2573    PostUrlStr.Load(SIn);
2574    PostTitleStr.Load(SIn);
2575    BlogUrlStr.Load(SIn);
2576    BlogTitleStr.Load(SIn);
2577    ContentStr.Load(SIn);
2578    QuoteV.Load(SIn);
2579    LinkV.Load(SIn);
2580  }
2581  bool TQuoteLoader::Next() {
2582    if (SIn.Empty() || SIn->Eof()) {
2583      printf("  new file");
2584      if (! FFile.Next(CurFNm)) { return false; }
2585      printf(" %s\n", CurFNm.GetFMid().CStr());
2586      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2587      StartProcFile(CurFNm);
2588    }
2589    Load(*SIn);
2590    if (++PostCnt % Kilo(10) == 0) { printf("\r  %dk [%s]  ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2591    return true;
2592  }
2593  void TQuoteLoader::ProcessPosts(const bool& IsXml, int LoadN) {
2594    TExeTm ExeTm, TotalTm;
2595    StartProcess();
2596    if (LoadN < 0) { LoadN = TInt::Mx; }
2597    int FilePostCnt=0;
2598    for (int f = 1; FFile.Next(CurFNm); f++) {
2599      printf("*** FILE:  %s\n", CurFNm.GetFMid().CStr());
2600      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2601      if (IsXml) {
2602        TXmlLx XmlLx(SIn, xspTruncate);
2603        StartProcFile(CurFNm);
2604        for (FilePostCnt=0; XmlLx.GetSym() != xsyEof; FilePostCnt++, PostCnt++) {
2605          if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) {
2606            while (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) { }
2607            if (XmlLx.Sym == xsyEof) { break; }
2608          }
2609          const bool IsGoodPost = LoadItem(XmlLx);
2610          ProcessPost(IsGoodPost);
2611          if (PostCnt % Kilo(1) == 0) {
2612            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2613          if (PostCnt >= LoadN) { break; }
2614        }
2615      } else {
2616        FilePostCnt = 0;
2617        while (! SIn->Eof()) {
2618          Load(*SIn);  FilePostCnt++;  PostCnt++;
2619          ProcessPost(true);
2620          if (PostCnt % Kilo(10) == 0) {
2621            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2622          if (PostCnt >= LoadN) { break; }
2623        }
2624      }
2625      printf("\n================================================================\n");
2626      printf("  file:  %s\n", CurFNm.GetFMid().CStr());
2627      printf("  time:  %s   ", ExeTm.GetStr());
2628      printf("total: %s [%s]\n", TotalTm.GetStr(), TExeTm::GetCurTm());
2629      printf("  posts: %d   total: %d\n", FilePostCnt, PostCnt);
2630      EndProcFile(CurFNm);
2631      fflush(stdout);  ExeTm.Tick();
2632      if (PostCnt >= LoadN) { break; }
2633    }
2634    EndProcess(PostCnt);
2635  }
2636  bool TMemesDataLoader::GetNextFile() {
2637    TStr FNm;
2638    if (! FFile.Empty()) {
2639      if (! FFile->Next(FNm)) { return false; }
2640      printf("NEXT-FL:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2641    } else {
2642      IAssert(! InFNmF.Empty());
2643      if (InFNmF->Eof()) { return false; }
2644    while (! InFNmF->Eof() && InFNmF->GetNextLn(FNm) && FNm.Empty()) { }
2645      printf("NEXT-LN:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2646    }
2647    if (FNm.Empty()) { return false; }
2648    if (TZipIn::IsZipExt(FNm.GetFExt())) {
2649      SInPt = TZipIn::New(FNm); }
2650    else {
2651      SInPt = TFIn::New(FNm); }  LineCnt = 0;
2652    return true;
2653  }
2654  void TMemesDataLoader::Clr() {
2655    PostUrlStr.Clr();
2656    ContentStr.Clr();
2657    PubTm = TSecTm();
2658    MemeV.Clr(false);
2659    MemePosV.Clr(false);
2660    LinkV.Clr(false);
2661    LinkPosV.Clr(false);
2662  }
2663  bool TMemesDataLoader::LoadNext() {
2664    Clr();
2665    if (SInPt.Empty() || SInPt->Eof()) {
2666      if (! GetNextFile()) { return false; }
2667    }
2668    TSIn& SIn = *SInPt;
2669    CurLn.Clr();
2670    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='U' || CurLn[1]!='\t'))) { 
2671      printf("L: %s\n", CurLn.CStr()); LineCnt++; }
2672    LineCnt++;
2673    if (CurLn.Empty()) { return LoadNext(); }
2674    IAssertR((! CurLn.Empty()) && CurLn[0]=='U' && CurLn[1]=='\t', 
2675      TStr::Fmt("ERROR1: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());
2676    PostUrlStr = CurLn.CStr()+2;
2677    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='D' || CurLn[1]!='\t'))) { LineCnt++; }
2678    IAssertR((! CurLn.Empty()) && CurLn[0]=='D', 
2679      TStr::Fmt("ERROR2: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2680    try {
2681      PubTm = TSecTm::GetDtTmFromStr(CurLn);
2682    } catch (PExcept Except){ PubTm = 1; ErrNotify(Except->GetStr());
2683      printf("ERROR3: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()); 
2684    }
2685    IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && (CurLn[0]=='C' || CurLn[0]=='T'), 
2686      TStr::Fmt("ERROR4: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2687    if (CurLn[0] == 'T') { 
2688      IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && CurLn[0]=='C', 
2689        TStr::Fmt("ERROR5: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++; }
2690    ContentStr = CurLn.CStr()+2;
2691    while (SIn.GetNextLn(CurLn)) {  LineCnt++;
2692      if (CurLn.Empty() || CurLn[0]!='L') { break; }
2693      int linkb=2;
2694      while (CurLn[linkb]!='\t') { linkb++; }
2695      CurLn[linkb]=0;
2696      LinkV.Add(CurLn.CStr()+linkb+1);
2697      LinkPosV.Add(atoi(CurLn.CStr()+2));
2698    }
2699    do {
2700      if (CurLn.Empty() || CurLn[0]!='Q') { break; }
2701      int qb1=2;      while (CurLn[qb1]!='\t') { qb1++; }
2702      int qb2=qb1+1;  while (CurLn[qb2]!='\t') { qb2++; }
2703      CurLn[qb1]=0;  CurLn[qb2]=0;
2704      MemeV.Add(CurLn.CStr()+qb2+1);
2705      MemePosV.Add(TIntPr(atoi(CurLn.CStr()+2), atoi(CurLn.CStr()+qb1+1)));
2706      LineCnt++;
2707    } while (SIn.GetNextLn(CurLn));
2708    return true;
2709  }
2710  void TMemesDataLoader::SaveTxt(TSOut& SOut) const {
2711  }
2712  void TMemesDataLoader::Dump(const bool& DumpAll) const {
2713  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-http.cpp</h3>
            <pre><code>1  const TStr THttp::HttpStr="http";
2  const TStr THttp::SlashStr="/";
3  const TStr THttp::ColonStr=":";
4  const TStr THttp::ContTypeFldNm="Content-Type";
5  const TStr THttp::ContLenFldNm="Content-Length";
6  const TStr THttp::HostFldNm="Host";
7  const TStr THttp::AcceptRangesFldNm="Accept-Ranges";
8  const TStr THttp::CacheCtrlFldNm="Cache-Control";
9  const TStr THttp::AcceptFldNm="Accept";
10  const TStr THttp::SrvFldNm="Server";
11  const TStr THttp::ConnFldNm="Connection";
12  const TStr THttp::FetchIdFldNm="FetchId";
13  const TStr THttp::LocFldNm="Location";
14  const TStr THttp::SetCookieFldNm="Set-Cookie";
15  const TStr THttp::CookieFldNm="Cookie";
16  const TStr THttp::TextFldVal="text/";
17  const TStr THttp::TextPlainFldVal="text/plain";
18  const TStr THttp::TextHtmlFldVal="text/html";
19  const TStr THttp::TextXmlFldVal="text/xml";
20  const TStr THttp::TextWmlFldVal="text/vnd.wap.wml";
21  const TStr THttp::TextJavaScriptFldVal="text/javascript";
22  const TStr THttp::TextCssFldVal="text/css";
23  const TStr THttp::ImageIcoFldVal="image/x-icon";
24  const TStr THttp::ImagePngFldVal="image/png";
25  const TStr THttp::ImageGifFldVal="image/gif";
26  const TStr THttp::ImageJpgFldVal="image/jpg";
27  const TStr THttp::AppOctetFldVal="application/octet-stream";
28  const TStr THttp::AppSoapXmlFldVal="application/soap+xml";
29  const TStr THttp::AppW3FormFldVal="application/x-www-form-urlencoded";
30  const TStr THttp::AppJSonFldVal = "application/json";
31  const TStr THttp::ConnKeepAliveFldVal="keep-alive";
32  bool THttp::IsHtmlFExt(const TStr& FExt){
33    TStr UcFExt=FExt.GetUc();
34    return ((UcFExt==TFile::HtmlFExt.GetUc())||(UcFExt==TFile::HtmFExt.GetUc()));
35  }
36  bool THttp::IsGifFExt(const TStr& FExt){
37    return (FExt.GetUc()==TFile::GifFExt.GetUc());
38  }
39  const int THttp::DfPortN=80;
40  const int THttp::OkStatusCd=200;
41  const int THttp::RedirStatusCd=300;
42  const int THttp::BadRqStatusCd=400;
43  const int THttp::ErrStatusCd=400;
44  const int THttp::ErrNotFoundStatusCd=404;
45  const int THttp::InternalErrStatusCd=500;
46  TStr THttp::GetReasonPhrase(const int& StatusCd){
47    switch (StatusCd){
48      case 200: return "OK";
49      case 201: return "Created";
50      case 202: return "Accepted";
51      case 204: return "No Content";
52      case 300: return "Multiple Choices";
53      case 301: return "Moved Permanently";
54      case 302: return "Moved Temporarily";
55      case 304: return "Not Modified";
56      case 400: return "Bad Request";
57      case 401: return "Unauthorized";
58      case 403: return "Forbidden";
59      case 404: return "Not Found";
60      case 500: return "Internal Server Error";
61      case 501: return "Not Implemented";
62      case 502: return "Bad Gateway";
63      case 503: return "Service Unavailable";
64      default: return TStr("Unknown Status Code ")+TInt::GetStr(StatusCd);
65    }
66  }
67  const TStr THttp::GetMethodNm="GET";
68  const TStr THttp::HeadMethodNm="HEAD";
69  const TStr THttp::PostMethodNm="POST";
70  const TStr THttp::UndefMethodNm="UndefinedMethod";
71  typedef enum {hpctUndef, hpctAlpha, hpctDigit, hpctCtl, hpctSpec} THttpChTy;
72  class THttpChDef{
73  private:
74    TIntV ChTyV;
75    TChV LcChV;
76    void SetLcCh(const TStr& Str);
77    void SetChTy(const THttpChTy& ChTy, const char& Ch);
78    void SetChTy(const THttpChTy& ChTy, const TStr& Str);
79  public:
80    THttpChDef();
81    THttpChDef& operator=(const THttpChDef&){Fail; return *this;}
82    int GetChTy(const char& Ch){return ChTyV[Ch-TCh::Mn];}
83    bool IsAlpha(const char& Ch){return ChTyV[Ch-TCh::Mn]==int(hpctAlpha);}
84    bool IsDigit(const char& Ch){return ChTyV[Ch-TCh::Mn]==int(hpctDigit);}
85    bool IsCtl(const char& Ch){return ChTyV[Ch-TCh::Mn]==int(hpctCtl);}
86    bool IsLws(const char& Ch){
87      return (Ch==' ')||(Ch==TCh::TabCh)||(Ch==TCh::CrCh)||(Ch==TCh::LfCh);}
88    bool IsText(const char& Ch){return !IsCtl(Ch)||IsLws(Ch);}
89    bool IsSpec(const char& Ch){
90      return (ChTyV[Ch-TCh::Mn]==int(hpctSpec))||(Ch==9)||(Ch==32);}
91    bool IsCr(const char& Ch){return Ch==13;}
92    bool IsLf(const char& Ch){return Ch==10;}
93    bool IsSp(const char& Ch){return Ch==32;}
94    bool IsHt(const char& Ch){return Ch==9;}
95    bool IsDQuote(const char& Ch){return Ch=='"';}
96    char GetLcCh(const char& Ch){return LcChV[Ch-TCh::Mn];}
97    TStr GetLcStr(const TStr& Str);
98  };
99  void THttpChDef::SetChTy(const THttpChTy& ChTy, const char& Ch){
100    IAssert(ChTyV[Ch-TCh::Mn]==int(hpctUndef)); ChTyV[Ch-TCh::Mn]=TInt(ChTy);}
101  void THttpChDef::SetChTy(const THttpChTy& ChTy, const TStr& Str){
102    for (int ChN=0; ChN<Str.Len(); ChN++){SetChTy(ChTy, Str[ChN]);}}
103  void THttpChDef::SetLcCh(const TStr& Str){
104    for (int ChN=1; ChN<Str.Len(); ChN++){LcChV[Str[ChN]-TCh::Mn]=TCh(Str[0]);}}
105  THttpChDef::THttpChDef():
106    ChTyV(TCh::Vals), LcChV(TCh::Vals){
107    ChTyV.PutAll(TInt(hpctUndef));
108    SetChTy(hpctAlpha, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
109    SetChTy(hpctAlpha, "abcdefghijklmnopqrstuvwxyz");
110    SetChTy(hpctDigit, "0123456789");
111    for (char Ch=0; Ch<=31; Ch++){SetChTy(hpctCtl, Ch);}
112    SetChTy(hpctCtl, 127);
113    SetChTy(hpctSpec, "()<>@,;:\\\"/[]?={}"); 
114    {for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){LcChV[Ch-TCh::Mn]=TCh(char(Ch));}}
115    SetLcCh("aA"); SetLcCh("bB"); SetLcCh("cC"); SetLcCh("dD"); SetLcCh("eE");
116    SetLcCh("fF"); SetLcCh("gG"); SetLcCh("hH"); SetLcCh("iI"); SetLcCh("jJ");
117    SetLcCh("kK"); SetLcCh("lL"); SetLcCh("mM"); SetLcCh("nN"); SetLcCh("oO");
118    SetLcCh("pP"); SetLcCh("qQ"); SetLcCh("rR"); SetLcCh("sS"); SetLcCh("tT");
119    SetLcCh("uU"); SetLcCh("vV"); SetLcCh("wW"); SetLcCh("xX"); SetLcCh("yY");
120    SetLcCh("zZ");
121  }
122  TStr THttpChDef::GetLcStr(const TStr& Str){
123    TChA LcStr;
124    for (int ChN=0; ChN<Str.Len(); ChN++){LcStr+=GetLcCh(Str[ChN]);}
125    return LcStr;
126  }
127  typedef enum {
128    heUnexpectedEof, hePeriodExpected, heTokenExpected, heInvalidToken,
129    heTSpecExpected, heInvalidTSpec, heNumExpected, heInvalidNumPlaces,
130    heCrLfExpected, heMethodNmExpected, heUrlEmpty, heBadUrl,
131    heBadSearchStr} THttpExCd;
132  class THttpEx{
133  private:
134    THttpExCd HttpExCd;
135  public:
136    THttpEx(const THttpExCd& _HttpExCd): HttpExCd(_HttpExCd){}
137  };
138  class THttpLx{
139  private:
140    static THttpChDef ChDef;
141    PSIn SIn;
142    TBoolChS EofChPrS;
143    char Ch;
144    bool AtEof;
145    TMem SfMem;
146  public:
147    THttpLx(const PSIn& _SIn):
148      SIn(_SIn), EofChPrS(), Ch(' '), AtEof(false), SfMem(50000){
149      GetFirstCh();}
150    THttpLx& operator=(const THttpLx&){Fail; return *this;}
151    bool Eof(){return AtEof;}
152    int Len(){return EofChPrS.Len()+SIn->Len();}
153    char GetFirstCh();
154    char GetCh();
155    void GetRest();
156    void PutCh(const char& _Ch){
157      EofChPrS.Push(TBoolChPr(AtEof, Ch)); Ch=_Ch; AtEof=false; SfMem.Pop();}
158    void ClrMemSf(){SfMem.Clr();}
159    TMem& GetMemSf(){return SfMem;}
160    THttpRqMethod GetRqMethod();
161    PUrl GetUrl();
162    TStr GetUrlStr();
163    bool IsRespStatusLn();
164    TStr GetRespReasonPhrase();
165    void GetWs();
166    bool IsLws();
167    void GetLws();
168    bool IsCrLf();
169    void GetCrLf();
170    void GetPeriod();
171    TStr GetToken(const TStr& ExpectStr=TStr());
172    TStr GetSpec(const TStr& ExpectStr=TStr());
173    int GetInt(const int& RqPlaces=-1);
174    TStr GetFldVal();
175    static TStr GetNrStr(const TStr& Str){return ChDef.GetLcStr(Str);}
176  };
177  THttpChDef THttpLx::ChDef;
178  char THttpLx::GetFirstCh(){
179    if (SIn->Eof()){
180      if (AtEof){throw THttpEx(heUnexpectedEof);}
181      AtEof=true; return 0;
182    } else {
183      Ch=SIn->GetCh(); return Ch;
184    }
185  }
186  char THttpLx::GetCh(){
187    if (EofChPrS.Empty()){
188      if (SIn->Eof()){
189        if (AtEof){throw THttpEx(heUnexpectedEof);}
190        AtEof=true; SfMem+=Ch; Ch=TCh::NullCh; return Ch;
191      } else {
192        SfMem+=Ch; Ch=SIn->GetCh(); return Ch;
193      }
194    } else {
195      SfMem+=Ch;
196      AtEof=EofChPrS.Top().Val1; Ch=EofChPrS.Top().Val2; EofChPrS.Pop();
197      return Ch;
198    }
199  }
200  void THttpLx::GetRest(){
201    while ((!SIn->Eof())&&(!EofChPrS.Empty())){GetCh();}
202    if (!SIn->Eof()){SfMem+=Ch;}
203    TMem RestMem; TMem::LoadMem(SIn, RestMem);
204    SfMem+=RestMem;
205  }
206  THttpRqMethod THttpLx::GetRqMethod(){
207    TChA MethodNm;
208    while (!Eof() && ChDef.IsAlpha(Ch)){
209      MethodNm+=Ch; GetCh();}
210    THttpRqMethod Method=hrmUndef;
211    if (MethodNm==THttp::GetMethodNm){Method=hrmGet;}
212    else if (MethodNm==THttp::HeadMethodNm){Method=hrmHead;}
213    else if (MethodNm==THttp::PostMethodNm){Method=hrmPost;}
214    if (Method==hrmUndef){throw THttpEx(heMethodNmExpected);}
215    return Method;
216  }
217  PUrl THttpLx::GetUrl(){
218    TChA UrlChA;
219    while ((!Eof())&&(!ChDef.IsSp(Ch))){
220      UrlChA+=Ch; GetCh();}
221    if (UrlChA.Empty()){
222      throw THttpEx(heUrlEmpty);}
223    static TStr LocalBaseUrlStr="http:&bsol;&bsol;localhost/";
224    PUrl Url=PUrl(new TUrl(UrlChA, LocalBaseUrlStr));
225    if (!Url->IsOk()){
226      throw THttpEx(heBadUrl);}
227    return Url;
228  }
229  TStr THttpLx::GetUrlStr(){
230    TChA UrlChA;
231    while ((!Eof())&&(!ChDef.IsSp(Ch))){
232      UrlChA+=Ch; GetCh();}
233    if (UrlChA.Empty()){
234      throw THttpEx(heUrlEmpty);}
235    return UrlChA;
236  }
237  bool THttpLx::IsRespStatusLn(){
238    static const TChA MouldChA="http/N.N NNN ";
239    TChA TestChA(MouldChA);
240    int TestLen=TestChA.Len();
241    if (1+Len()<TestLen){return false;}
242    TestChA.PutCh(0, ChDef.GetLcCh(Ch));
243    {for (int ChN=1; ChN<TestLen; ChN++){
244      TestChA.PutCh(ChN, ChDef.GetLcCh(GetCh()));}}
245    {for (int ChN=1; ChN<TestLen; ChN++){
246      PutCh(TestChA[TestLen-ChN-1]);}}
247    {for (int ChN=0; ChN<MouldChA.Len(); ChN++){
248      if (MouldChA[ChN]=='N'){
249        if (!ChDef.IsDigit(TestChA[ChN])){return false;}
250      } else {
251        if (MouldChA[ChN]!=TestChA[ChN]){return false;}
252      }
253    }}
254    return true;
255  }
256  TStr THttpLx::GetRespReasonPhrase(){
257    GetLws();
258    TChA RPStr;
259    while (!Eof()&&ChDef.IsText(Ch)&&(Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)){
260      RPStr+=Ch; GetCh();}
261    return RPStr;
262  }
263  void THttpLx::GetWs(){
264    while (!Eof()&&((Ch==' ')||(Ch==TCh::TabCh))){GetCh();}
265  }
266  bool THttpLx::IsLws(){
267    if ((Ch==' ')||(Ch==TCh::TabCh)){
268      return true;
269    } else
270    if (Ch==TCh::CrCh){
271      GetCh();
272      if (Ch==TCh::LfCh){
273        GetCh(); bool Ok=(Ch==' ')||(Ch==TCh::TabCh);
274        PutCh(TCh::LfCh); PutCh(TCh::CrCh); return Ok;
275      } else {
276        PutCh(TCh::CrCh); return false;
277      }
278    } else
279    if (Ch==TCh::LfCh){
280      GetCh(); bool Ok=(Ch==' ')||(Ch==TCh::TabCh);
281      PutCh(TCh::LfCh); return Ok;
282    } else {
283      return false;
284    }
285  }
286  void THttpLx::GetLws(){
287    forever {
288      while ((Ch==' ')||(Ch==TCh::TabCh)){GetCh();}
289      if (Ch==TCh::CrCh){
290        GetCh();
291        if (Ch==TCh::LfCh){
292          GetCh();
293          if ((Ch==' ')||(Ch==TCh::TabCh)){GetCh();}
294          else {PutCh(TCh::LfCh); PutCh(TCh::CrCh); break;}
295        } else {
296          PutCh(TCh::CrCh); break;
297        }
298      } else
299      if (Ch==TCh::LfCh){
300        GetCh();
301        if ((Ch==' ')||(Ch==TCh::TabCh)){GetCh();}
302        else {PutCh(TCh::LfCh); break;}
303      } else {
304        break;
305      }
306    }
307  }
308  bool THttpLx::IsCrLf(){
309    if (Ch==TCh::CrCh){
310      GetCh(); bool Ok=(Ch==TCh::LfCh); PutCh(TCh::CrCh); return Ok;
311    } else
312    if (Ch==TCh::LfCh){
313      return true;
314    } else {
315      return false;
316    }
317  }
318  void THttpLx::GetCrLf(){
319    if (Ch==TCh::CrCh){
320      GetCh();
321      if (Ch==TCh::LfCh){GetCh();} else {throw THttpEx(heCrLfExpected);}
322    } else
323    if (Ch==TCh::LfCh){
324      GetCh();
325    } else {
326      throw THttpEx(heCrLfExpected);
327    }
328  }
329  void THttpLx::GetPeriod(){
330    GetWs();
331    if (Ch!='.'){throw THttpEx(hePeriodExpected);}
332    GetCh();
333  }
334  TStr THttpLx::GetToken(const TStr& ExpectStr){
335    GetLws();
336    TChA TokenStr;
337    while (!Eof() && !ChDef.IsCtl(Ch) && !ChDef.IsSpec(Ch)){
338      TokenStr+=Ch; GetCh();}
339    if (TokenStr.Empty()){throw THttpEx(heTokenExpected);}
340    if (!ExpectStr.Empty()){
341      if (GetNrStr(ExpectStr)!=GetNrStr(TokenStr)){
342        throw THttpEx(heInvalidToken);}
343    }
344    return TokenStr;
345  }
346  TStr THttpLx::GetSpec(const TStr& ExpectStr){
347    GetLws();
348    if (!ChDef.IsSpec(Ch)){throw THttpEx(heTSpecExpected);}
349    TStr SpecStr(Ch); GetCh();
350    if (!ExpectStr.Empty()){
351      if (ExpectStr!=SpecStr){throw THttpEx(heInvalidTSpec);}}
352    return SpecStr;
353  }
354  int THttpLx::GetInt(const int& RqPlaces){
355    GetLws();
356    if (!ChDef.IsDigit(Ch)){throw THttpEx(heNumExpected);}
357    int Int=0; int CurPlaces=0;
358    do {Int=Int*10+Ch-'0'; CurPlaces++; GetCh();
359    } while ((CurPlaces<RqPlaces)&&(ChDef.IsDigit(Ch)));
360    if (RqPlaces!=-1){
361      if (CurPlaces!=RqPlaces){throw THttpEx(heInvalidNumPlaces);}}
362    return Int;
363  }
364  TStr THttpLx::GetFldVal(){
365    TChA FldValStr;
366    do {
367      GetLws();
368      while (!Eof()&&ChDef.IsText(Ch)&&(Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)){
369        FldValStr+=Ch; GetCh();}
370      if (IsLws()){FldValStr+=' ';}
371    } while (IsLws());
372    return FldValStr;
373  }
374  class THttpChRet{
375    PSIn SIn;
376    int Chs, ChN;
377    THttpExCd HttpExCd;
378  public:
379    THttpChRet(const PSIn& _SIn, const THttpExCd& _HttpExCd):
380      SIn(_SIn), Chs(SIn->Len()), ChN(0), HttpExCd(_HttpExCd){}
381    THttpChRet& operator=(const THttpChRet&){Fail; return *this;}
382    bool Eof(){return ChN==Chs;}
383    char GetCh(){
384      if (ChN>=Chs){throw THttpEx(HttpExCd);}
385      ChN++; return SIn->GetCh();}
386  };
387  void THttpRq::ParseSearch(const TStr& SearchStr){
388    PSIn SIn=TStrIn::New(SearchStr);
389    THttpChRet ChRet(SIn, heBadSearchStr);
390    try {
391    if (ChRet.Eof()){return;}
392    if (ChRet.GetCh()!='?'){
393      throw THttpEx(heBadSearchStr);}
394    TChA KeyNm; TChA ValStr;
395    while (!ChRet.Eof()){
396      char Ch; KeyNm.Clr(); ValStr.Clr();
397      while ((Ch=ChRet.GetCh())!='='){
398        switch (Ch){
399          case '%':{
400            char Ch1=ChRet.GetCh();
401  		  if (!TCh::IsHex(Ch1)) { throw THttpEx(heBadSearchStr); }
402  		  char Ch2=ChRet.GetCh();
403  		  if (!TCh::IsHex(Ch2)) { throw THttpEx(heBadSearchStr); }
404            KeyNm.AddCh(char(16*TCh::GetHex(Ch1)+TCh::GetHex(Ch2)));} break;
405          case '+': KeyNm.AddCh(' '); break;
406          case '&': throw THttpEx(heBadSearchStr);
407          default: KeyNm.AddCh(Ch);
408        }
409      }
410      if (Ch!='='){
411        throw THttpEx(heBadSearchStr);}
412      while ((!ChRet.Eof())&&((Ch=ChRet.GetCh())!='&')){
413        switch (Ch){
414          case '%':{
415            char Ch1=ChRet.GetCh();
416  		  if (!TCh::IsHex(Ch1)) { throw THttpEx(heBadSearchStr); }
417            char Ch2=ChRet.GetCh();
418  		  if (!TCh::IsHex(Ch2)) { throw THttpEx(heBadSearchStr); }
419            ValStr.AddCh(char(16*TCh::GetHex(Ch1)+TCh::GetHex(Ch2)));} break;
420          case '+': ValStr.AddCh(' '); break;
421          case '&': throw THttpEx(heBadSearchStr);
422          default: ValStr.AddCh(Ch);
423        }
424      }
425      UrlEnv->AddToKeyVal(KeyNm, ValStr);
426      }
427    }
428    catch (const THttpEx&){Ok=false;}
429  }
430  void THttpRq::ParseHttpRq(const PSIn& SIn){
431    THttpLx Lx(SIn);
432    Ok=false;
433    CompleteP=false;
434    Method=Lx.GetRqMethod();
435    Lx.GetWs();
436    TStr UrlStr=Lx.GetUrlStr();
437    Lx.GetWs();
438    Lx.GetToken(THttp::HttpStr); Lx.GetSpec(THttp::SlashStr);
439    MajorVerN=Lx.GetInt(1); Lx.GetPeriod(); MinorVerN=Lx.GetInt(1);
440    Lx.GetCrLf();
441    while ((!Lx.Eof())&&(!Lx.IsCrLf())){
442      TStr FldNm=Lx.GetToken(); Lx.GetSpec(THttp::ColonStr);
443      TStr FldVal=Lx.GetFldVal();
444      Lx.GetCrLf();
445      TStr NrFldNm=THttpLx::GetNrStr(FldNm);
446      FldNmToValH.AddDat(NrFldNm, FldVal);
447    }
448    if (!Lx.IsCrLf()){return;} 
449    Lx.GetCrLf();
450    HdStr=Lx.GetMemSf().GetAsStr();
451    Lx.ClrMemSf();
452    Lx.GetRest();
453    BodyMem=Lx.GetMemSf();
454    int ContLen=GetFldVal(THttp::ContLenFldNm).GetInt(-1);
455    if (ContLen==-1){
456      CompleteP=true;
457    } else {
458      if (ContLen<=BodyMem.Len()){
459        CompleteP=true;
460        BodyMem.Trunc(ContLen);
461      } else {
462        CompleteP=false;
463      }
464    }
465    if (CompleteP){
466      const TStr LocalBaseUrlStr="http:&bsol;&bsol;localhost/";
467      Url=TUrl::New(UrlStr, LocalBaseUrlStr);
468      if (!Url->IsOk()){
469        throw THttpEx(heBadUrl);}
470    }
471    TStr SearchStr;
472    if (Method==hrmGet){
473      SearchStr=Url->GetSearchStr();
474    } else
475    if ((Method==hrmPost)&&(
476     (!IsFldNm(THttp::ContTypeFldNm))||
477     (GetFldVal(THttp::ContTypeFldNm)==THttp::TextHtmlFldVal)||
478     (GetFldVal(THttp::ContTypeFldNm)==THttp::AppW3FormFldVal))){
479      SearchStr=TStr("?")+BodyMem.GetAsStr();
480    }
481    ParseSearch(SearchStr);
482    Ok=true;
483  }
484  THttpRq::THttpRq(const PSIn& SIn):
485    Ok(false), MajorVerN(0), MinorVerN(0), Method(hrmUndef),
486    FldNmToValH(), UrlEnv(TUrlEnv::New()),
487    HdStr(), BodyMem(){
488    try {
489      ParseHttpRq(SIn);
490    }
491    catch (const THttpEx&){Ok=false;}
492  }
493  THttpRq::THttpRq(
494   const THttpRqMethod& _Method, const PUrl& _Url,
495   const TStr& ContTypeFldVal, const TMem& _BodyMem, const int& FetchId):
496    Ok(false),
497    MajorVerN(1), MinorVerN(0),
498    Method(_Method),
499    Url(_Url),
500    FldNmToValH(),
501    UrlEnv(TUrlEnv::New()),
502    HdStr(), BodyMem(_BodyMem){
503    TChA HdChA;
504    if (Url->IsOk()){
505      TStr AbsPath=Url->GetPathStr()+Url->GetSearchStr();
506      HdChA+=GetMethodNm(); HdChA+=' '; HdChA+=AbsPath; HdChA+=" HTTP/1.0\r\n";
507    }
508    if (!ContTypeFldVal.Empty()){
509      FldNmToValH.AddDat(THttpLx::GetNrStr(THttp::ContTypeFldNm), ContTypeFldVal);
510      HdChA+=THttpLx::GetNrStr(THttp::ContTypeFldNm); HdChA+=": ";
511      HdChA+=ContTypeFldVal; HdChA+="\r\n";
512    }
513    if (Url->IsOk()){
514      TStr HostNm=Url->GetHostNm();
515      FldNmToValH.AddDat(THttpLx::GetNrStr(THttp::HostFldNm), HostNm);
516      HdChA+=THttpLx::GetNrStr(THttp::HostFldNm); HdChA+=": ";
517      HdChA+=HostNm; HdChA+="\r\n";
518      ParseSearch(Url->GetSearchStr());
519    }
520    if (Url->IsOk()&&(FetchId!=-1)){
521      TStr FetchIdStr=TInt::GetStr(FetchId);
522      FldNmToValH.AddDat(THttpLx::GetNrStr(THttp::FetchIdFldNm), FetchIdStr);
523      HdChA+=THttpLx::GetNrStr(THttp::FetchIdFldNm); HdChA+=": ";
524      HdChA+=FetchIdStr; HdChA+="\r\n";
525    }
526    if (Url->IsOk()){
527      HdChA+="\r\n";
528      HdStr=HdChA;
529    }
530    Ok=true;
531  }
532  const TStr& THttpRq::GetMethodNm() const {
533    switch (Method){
534      case hrmGet: return THttp::GetMethodNm;
535      case hrmHead: return THttp::HeadMethodNm;
536      case hrmPost: return THttp::PostMethodNm;
537      default: return  THttp::UndefMethodNm;
538    }
539  }
540  bool THttpRq::IsFldNm(const TStr& FldNm) const {
541    return FldNmToValH.IsKey(THttpLx::GetNrStr(FldNm));
542  }
543  TStr THttpRq::GetFldVal(const TStr& FldNm) const {
544    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
545    if (FldNmToValH.IsKey(NrFldNm)){
546      return FldNmToValH.GetDat(NrFldNm);
547    } else {
548      return TStr();
549    }
550  }
551  bool THttpRq::IsFldVal(const TStr& FldNm, const TStr& FldVal) const {
552    return THttpLx::GetNrStr(FldVal)==THttpLx::GetNrStr(GetFldVal(FldNm));
553  }
554  void THttpRq::AddFldVal(const TStr& FldNm, const TStr& FldVal){
555    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
556    FldNmToValH.AddDat(NrFldNm, FldVal);
557  }
558  const TStrStrH& THttpRq::GetFldValH() const {
559  	return FldNmToValH;
560  }
561  TStr THttpRq::GetStr() const {
562    TChA ChA;
563    ChA+=GetMethodNm(); ChA+=' ';
564    ChA+=Url->GetUrlStr(); ChA+=' ';
565    ChA+="HTTP/1.0\r\n";
566    for (int FldN=0; FldN<FldNmToValH.Len(); FldN++){
567      ChA+=FldNmToValH.GetKey(FldN); ChA+=": ";
568      ChA+=FldNmToValH[FldN]; ChA+="\r\n";
569    }
570    if (!BodyMem.Empty()) {
571      ChA+=THttp::ContLenFldNm; ChA+=": ";
572      ChA+=TInt::GetStr(BodyMem.Len()); ChA+="\r\n";
573    }
574    ChA+="\r\n";
575    ChA+=BodyMem.GetAsStr();
576    return ChA;
577  }
578  void THttpResp::AddHdFld(const TStr& FldNm, const TStr& FldVal, TChA& HdChA){
579    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
580    FldNmToValVH.AddDat(NrFldNm).Add(FldVal);
581    HdChA+=FldNm; HdChA+=": "; HdChA+=FldVal; HdChA+="\r\n";
582  }
583  void THttpResp::ParseHttpResp(const PSIn& SIn){
584    THttpLx Lx(SIn);
585    if (Lx.Eof()){
586      MajorVerN=0; MinorVerN=9; StatusCd=204;
587      HdStr.Clr(); BodyMem.Clr();
588    } else {
589      if (Lx.IsRespStatusLn()){
590        Lx.GetToken(THttp::HttpStr); Lx.GetSpec(THttp::SlashStr);
591        MajorVerN=Lx.GetInt(1); Lx.GetPeriod(); MinorVerN=Lx.GetInt(1);
592        StatusCd=Lx.GetInt(3);
593        ReasonPhrase=Lx.GetRespReasonPhrase();
594        Lx.GetCrLf();
595        while (!Lx.IsCrLf()){
596          TStr FldNm=Lx.GetToken(); Lx.GetSpec(THttp::ColonStr);
597          TStr FldVal=Lx.GetFldVal();
598          Lx.GetCrLf();
599          TStr NrFldNm=THttpLx::GetNrStr(FldNm);
600          FldNmToValVH.AddDat(NrFldNm).Add(FldVal);
601        }
602        Lx.GetCrLf();
603        HdStr=Lx.GetMemSf().GetAsStr();
604        Lx.ClrMemSf();
605        Lx.GetRest();
606        BodyMem=Lx.GetMemSf();
607      } else {
608        MajorVerN=0; MinorVerN=9; StatusCd=200;
609        HdStr.Clr();
610        Lx.ClrMemSf();
611        Lx.GetRest();
612        BodyMem=Lx.GetMemSf();
613      }
614    }
615    Ok=true;
616  }
617  THttpResp::THttpResp(const int& _StatusCd, const TStr& ContTypeVal,
618   const bool& CacheCtrlP, const PSIn& BodySIn, const TStr LocStr):
619    Ok(true), MajorVerN(1), MinorVerN(0), StatusCd(_StatusCd), ReasonPhrase(),
620    FldNmToValVH(20), HdStr(), BodyMem(){
621    ReasonPhrase=THttp::GetReasonPhrase(StatusCd);
622    TChA HdChA;
623    HdChA+="HTTP/"; HdChA+=TInt::GetStr(MajorVerN); HdChA+=".";
624    HdChA+=TInt::GetStr(MinorVerN); HdChA+=' ';
625    HdChA+=TInt::GetStr(StatusCd); HdChA+=' ';
626    HdChA+=ReasonPhrase;
627    HdChA+="\r\n";
628    if (!LocStr.Empty()){
629      AddHdFld("Location", LocStr, HdChA);}
630    if (!BodySIn.Empty()){
631      AddHdFld(THttp::ContTypeFldNm, ContTypeVal, HdChA);
632      AddHdFld(THttp::AcceptRangesFldNm, "bytes", HdChA);
633      TStr ContLenVal=TInt::GetStr(BodySIn->Len());
634      AddHdFld(THttp::ContLenFldNm, ContLenVal, HdChA);
635      if (!CacheCtrlP){
636        AddHdFld(THttp::CacheCtrlFldNm, "no-cache", HdChA);}
637    }
638    HdChA+="\r\n";
639    HdStr=HdChA;
640    if (!BodySIn.Empty()){
641      TMem::LoadMem(BodySIn, BodyMem);}
642  }
643  THttpResp::THttpResp(const PSIn& SIn):
644    Ok(false), MajorVerN(0), MinorVerN(0), StatusCd(-1), ReasonPhrase(),
645    FldNmToValVH(20), HdStr(), BodyMem(){
646    try {
647      ParseHttpResp(SIn);
648    }
649    catch (const THttpEx&){Ok=false;}
650  }
651  bool THttpResp::IsFldNm(const TStr& FldNm) const {
652    return FldNmToValVH.IsKey(THttpLx::GetNrStr(FldNm));
653  }
654  TStr THttpResp::GetFldVal(const TStr& FldNm, const int& ValN) const {
655    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
656    if (FldNmToValVH.IsKey(NrFldNm)){
657      const TStrV& ValV=FldNmToValVH.GetDat(NrFldNm);
658      if (ValV.Len()>0){return ValV[ValN];} else {return TStr();}
659    } else {
660      return TStr();
661    }
662  }
663  void THttpResp::GetFldValV(const TStr& FldNm, TStrV& FldValV) const {
664    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
665    if (FldNmToValVH.IsKey(NrFldNm)){
666      FldValV=FldNmToValVH.GetDat(NrFldNm);
667    } else {
668      FldValV.Clr();
669    }
670  }
671  bool THttpResp::IsFldVal(const TStr& FldNm, const TStr& FldVal) const {
672    return THttpLx::GetNrStr(FldVal)==THttpLx::GetNrStr(GetFldVal(FldNm));
673  }
674  void THttpResp::AddFldVal(const TStr& FldNm, const TStr& FldVal){
675    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
676    FldNmToValVH.AddDat(NrFldNm).Add(FldVal);
677    if (HdStr.IsSuffix("\r\n\r\n")){
678      TChA HdChA=HdStr;
679      HdChA.Pop(); HdChA.Pop(); 
680      HdChA+=NrFldNm; HdChA+=": "; HdChA+=FldVal;
681      HdChA+="\r\n\r\n";
682      HdStr=HdChA;
683    }
684  }
685  void THttpResp::GetCookieKeyValDmPathQuV(TStrQuV& CookieKeyValDmPathQuV){
686    CookieKeyValDmPathQuV.Clr();
687    TStrV CookieFldValV; GetFldValV(THttp::SetCookieFldNm, CookieFldValV);
688    for (int CookieN=0; CookieN<CookieFldValV.Len(); CookieN++){
689      TStr CookieFldVal=CookieFldValV[CookieN];
690      TStrV KeyValStrV;
691      CookieFldVal.SplitOnAllCh(';', KeyValStrV, true);
<span onclick='openModal()' class='match'>692      TStrPrV KeyValPrV; TStr DmNm; TStr PathStr;
693      for (int KeyValStrN=0; KeyValStrN<KeyValStrV.Len(); KeyValStrN++){
694        TStr KeyValStr=KeyValStrV[KeyValStrN];
</span>695        TStr KeyNm; TStr ValStr; 
696        if (KeyValStr.IsChIn('=')){
697          KeyValStrV[KeyValStrN].SplitOnCh(KeyNm, '=', ValStr);
698          KeyNm.ToTrunc(); ValStr.ToTrunc();
699        } else {
700          KeyNm=KeyValStr.GetTrunc();
701        }
702        if (KeyNm=="expires"){}
703        else if (KeyNm=="domain"){DmNm=ValStr;}
704        else if (KeyNm=="path"){PathStr=ValStr;}
705        else if (KeyNm=="expires"){}
706        else if (KeyNm=="secure"){}
707        else if (KeyNm=="httponly"){}
708        else if (!KeyNm.Empty()){
709          KeyValPrV.Add(TStrPr(KeyNm, ValStr));
710        }
711      }
712      for (int KeyValPrN=0; KeyValPrN<KeyValPrV.Len(); KeyValPrN++){
713        TStr KeyNm=KeyValPrV[KeyValPrN].Val1;
714        TStr ValStr=KeyValPrV[KeyValPrN].Val2;
715        CookieKeyValDmPathQuV.Add(TStrQu(KeyNm, ValStr, DmNm, PathStr));
716      }
717    }
718  }
719  PSIn THttpResp::GetSIn() const {
720    TMOut MOut(HdStr.Len()+BodyMem.Len());
721    MOut.PutStr(HdStr); MOut.PutMem(BodyMem);
722    return MOut.GetSIn();
723  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-http.cpp</div>
                </div>
                <div class="column column_space"><pre><code>392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q < QuoteH.Len(); q++) {
396      const TQuote& Q = GetQtN(q);
</pre></code></div>
                <div class="column column_space"><pre><code>692      TStrPrV KeyValPrV; TStr DmNm; TStr PathStr;
693      for (int KeyValStrN=0; KeyValStrN<KeyValStrV.Len(); KeyValStrN++){
694        TStr KeyValStr=KeyValStrV[KeyValStrN];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    