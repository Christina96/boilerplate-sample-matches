
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.cpp</h3>
            <pre><code>1  double TMath::E=2.71828182845904523536;
2  double TMath::Pi=3.14159265358979323846;
3  double TMath::LogOf2=log(double(2));
4  void TSpecFunc::GammaPSeries&bsol;*gser*/(
5   double& gamser, const double& a, const double& x, double& gln){
6    static const int ITMAX=100;
7    static const double EPS=3.0e-7;
8    int n;
9    double sum, del, ap;
10    gln=LnGamma(a);
11    if (x <= 0.0){
12      IAssert(x>=0); &bsol;*if (x < 0.0) nrerror("x less than 0 in routine gser");*/
13      gamser=0.0;
14      return;
15    } else {
16      ap=a;
17      del=sum=1.0/a;
18      for (n=1; n<=ITMAX; n++){
19        ++ap;
20        del *= x/ap;
21        sum += del;
22        if (fabs(del) < fabs(sum)*EPS){
23          gamser=sum*exp(-x+a*log(x)-(gln));
24          return;
25        }
26      }
27      Fail; &bsol;*nrerror("a too large, ITMAX too small in routine gser");*/
28      return;
29    }
30  }
31  void TSpecFunc::GammaQContFrac&bsol;*gcf*/(
32   double& gammcf, const double& a, const double& x, double& gln){
33    static const int ITMAX=100;
34    static const double EPS=3.0e-7;
35    static const double  FPMIN=1.0e-30;
36    int i;
37    double an, b, c, d, del, h;
38    gln=LnGamma(a);
39    b=x+1.0-a;
40    c=1.0/FPMIN;
41    d=1.0/b;
42    h=d;
43    for (i=1;i<=ITMAX;i++){
44      an = -i*(i-a);
45      b += 2.0;
46      d=an*d+b;
47      if (fabs(d) < FPMIN) d=FPMIN;
48      c=b+an/c;
49      if (fabs(c) < FPMIN) c=FPMIN;
50      d=1.0/d;
51      del=d*c;
52      h *= del;
53      if (fabs(del-1.0) < EPS) break;
54    }
55    IAssert(i<=ITMAX);
56    gammcf=exp(-x+a*log(x)-(gln))*h;
57  }
58  double TSpecFunc::GammaQ&bsol;*gammq*/(const double& a, const double& x){
59    IAssert((x>=0)&&(a>0));
60    double gamser, gammcf, gln;
61    if (x<(a+1.0)){
62      GammaPSeries(gamser,a,x,gln);
63      return 1.0-gamser;
64    } else {
65      GammaQContFrac(gammcf,a,x,gln);
66      return gammcf;
67    }
68  }
69  double TSpecFunc::LnGamma&bsol;*gammln*/(const double& xx){
70    double x, y, tmp, ser;
71    static double cof[6]={76.18009172947146,-86.50532032941677,
72            24.01409824083091,-1.231739572450155,
73            0.1208650973866179e-2,-0.5395239384953e-5};
74    int j;
75    y=x=xx;
76    tmp=x+5.5;
77    tmp -= (x+0.5)*log(tmp);
78    ser=1.000000000190015;
79    for (j=0;j<=5;j++) ser += cof[j]/++y;
80    return -tmp+log(2.5066282746310005*ser/x);
81  }
82  double TSpecFunc::LnComb(const int& n, const int& k){
83    return LnGamma(n+1)-LnGamma(k+1)-LnGamma(n-k+1);
84  }
85  double TSpecFunc::BetaCf(const double& a, const double& b, const double& x){
86    static const double MAXIT=100;
87    static const double EPS=3.0e-7;
88    static const double FPMIN=1.0e-30;
89    int m,m2;
90    double aa,c,d,del,h,qab,qam,qap;
91    qab=a+b;
92    qap=a+1.0;
93    qam=a-1.0;
94    c=1.0;
95    d=1.0-qab*x/qap;
96    if (fabs(d) < FPMIN) d=FPMIN;
97    d=1.0/d;
98    h=d;
99    for (m=1;m<=MAXIT;m++) {
100      m2=2*m;
101      aa=m*(b-m)*x/((qam+m2)*(a+m2));
102      d=1.0+aa*d;
103      if (fabs(d) < FPMIN) d=FPMIN;
104      c=1.0+aa/c;
105      if (fabs(c) < FPMIN) c=FPMIN;
106      d=1.0/d;
107      h *= d*c;
108      aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
109      d=1.0+aa*d;
110      if (fabs(d) < FPMIN) d=FPMIN;
111      c=1.0+aa/c;
112      if (fabs(c) < FPMIN) c=FPMIN;
113      d=1.0/d;
114      del=d*c;
115      h *= del;
116      if (fabs(del-1.0) < EPS) break;
117    }
118    if (m > MAXIT){Fail;}
119    return h;
120  }
121  double TSpecFunc::BetaI(const double& a, const double& b, const double& x){
122    double bt;
123    if (x < 0.0 || x > 1.0){Fail;} 
124    if (x == 0.0 || x == 1.0) bt=0.0;
125    else
126      bt=exp(LnGamma(a+b)-LnGamma(a)-LnGamma(b)+a*log(x)+b*log(1.0-x));
127    if (x < (a+1.0)/(a+b+2.0))
128      return bt*BetaCf(a,b,x)/a;
129    else
130      return 1.0-bt*BetaCf(b,a,1.0-x)/b;
131  }
132  void TSpecFunc::LinearFit(
133   const TVec<TFltPr>& XY, double& A, double& B,
134   double& SigA, double& SigB, double& Chi2, double& R2) {
135    int i;
136    double t, sxoss, sx = 0.0, sy = 0.0, st2 = 0.0, ss, sigdat;
137    A = B = SigA = SigB = Chi2 = 0.0;
138    for (i = 0; i < XY.Len(); i++) {
139      sx += XY[i].Val1;
140      sy += XY[i].Val2;
141    }
142    ss = XY.Len();
143    sxoss = sx / ss;
144    for (i = 0; i <XY.Len(); i++) {
145      t = XY[i].Val1 - sxoss;
146      st2 += t*t;
147      B += t * XY[i].Val2;
148    }
149    B /= st2;
150    A = (sy - sx * B) / ss;
151    SigA = sqrt((1.0 + sx * sx / (ss * st2)) / ss);
152    SigB = sqrt(1.0 / st2);
153    for (i = 0; i < XY.Len(); i++)
154      Chi2 += TMath::Sqr(XY[i].Val2 - A - B * XY[i].Val1);
155    sigdat = sqrt(Chi2 / (XY.Len() - 2));
156    SigA *= sigdat;
157    SigB *= sigdat;
158    { double N = XY.Len(), sXY=0.0, sX=0.0, sY=0.0, sSqX=0.0, sSqY=0.0;
159    for (int s =0; s < XY.Len(); s++) {
160      sX += XY[s].Val1;  sY += XY[s].Val2;
161      sXY += XY[s].Val1 * XY[s].Val2;
162      sSqX += TMath::Sqr(XY[s].Val1);
163      sSqY += TMath::Sqr(XY[s].Val2);
164    }
165    R2 = TMath::Sqr(N*sXY - sX*sY) / ((N*sSqX - sX*sX) * (N*sSqY - sY*sY)); }
166    if (1.1 < R2 || -1.1 > R2) R2 = 0.0;
167    if (_isnan(A) || ! _finite(A)) A = 0.0;
168    if (_isnan(B) || ! _finite(B)) B = 0.0;
169  }
170  void TSpecFunc::PowerFit(const TVec<TFltPr>& XY, double& A, double& B,
171   double& SigA, double& SigB, double& Chi2, double& R2) {
172    double AA, BB;
173    TFltPrV LogXY(XY.Len(), 0);
174    for (int s = 0; s < XY.Len(); s++) {
175      LogXY.Add(TFltPr(log((double)XY[s].Val1), log((double)XY[s].Val2)));
176    }
177    TSpecFunc::LinearFit(LogXY, AA, BB, SigA, SigB, Chi2, R2);
178    A = exp(AA);  B = BB;
179    if (_isnan(AA) || ! _finite(AA)) A = 0.0;
180    if (_isnan(BB) || ! _finite(BB)) B = 0.0;
181  }
182  void TSpecFunc::LogFit(const TVec<TFltPr>& XY, double& A, double& B,
183   double& SigA, double& SigB, double& Chi2, double& R2) {
184    TFltPrV LogXY(XY.Len(), 0);
185    for (int s = 0; s < XY.Len(); s++) {
186      LogXY.Add(TFltPr(log((double)XY[s].Val1), XY[s].Val2));
187    }
188    TSpecFunc::LinearFit(LogXY, A, B, SigA, SigB, Chi2, R2);
189  }
190  void TSpecFunc::ExpFit(const TVec<TFltPr>& XY, double& A, double& B,
191   double& SigA, double& SigB, double& Chi2, double& R2) {
192    TFltPrV XLogY(XY.Len(), 0);
193    double AA, BB;
194    for (int s = 0; s < XY.Len(); s++) {
195      XLogY.Add(TFltPr(XY[s].Val1, log((double)XY[s].Val2)));
196    }
197    TSpecFunc::LinearFit(XLogY, AA, BB, SigA, SigB, Chi2, R2);
198    A = exp(AA);
199    B = BB;
200  }
201  double TSpecFunc::Entropy(const TIntV& ValV) {
202    TFltV NewValV(ValV.Len());
203    for (int i = 0; i < ValV.Len(); i++) { NewValV[i] = ValV[i]; }
204    return Entropy(NewValV);
205  }
206  double TSpecFunc::Entropy(const TFltV& ValV) {
207    double Sum=0, Ent=0;
208    for (int i = 0; i < ValV.Len(); i++) {
209      const double& Val = ValV[i];
210      if (Val > 0.0) { Ent -= Val * log(Val);  Sum += Val; }
211    }
212    if (Sum > 0.0) {
213      Ent /= Sum;
214      Ent += log(Sum);
215      Ent /= TMath::LogOf2;
216    } else return 1.0;
217    return Ent;
218  }
219  void TSpecFunc::EntropyFracDim(const TIntV& ValV, TFltV& EntropyV) {
220    TFltV NewValV(ValV.Len());
221    for (int i = 0; i < ValV.Len(); i++) { 
222      IAssert(ValV[i]==1 || ValV[i] == 0);
223      NewValV[i] = ValV[i]; 
224    }
225    EntropyFracDim(NewValV, EntropyV);
226  }
227  void TSpecFunc::EntropyFracDim(const TFltV& ValV, TFltV& EntropyV) {
228    TFltV ValV1, ValV2;
229    int Pow2 = 1;
230    while (2*Pow2 <= ValV.Len()) { Pow2 *= 2; }
231    ValV1.Gen(Pow2);
232    for (int i = 0; i < Pow2; i++) { ValV1[i] = ValV[i]; 
233      IAssert(ValV[i]==1.0 || ValV[i] == 0.0); }
234    EntropyV.Clr();
235    EntropyV.Add(Entropy(ValV1)); 
236    while (ValV1.Len() > 2) {
237      ValV2.Gen(ValV1.Len() / 2);
238      for (int i = 0; i < ValV1.Len(); i++) {
239        ValV2[i/2] += ValV1[i];
240      }
241      EntropyV.Add(Entropy(ValV2));
242      ValV1.MoveFrom(ValV2);
243    }
244    EntropyV.Reverse();
245  }
246  double TSpecFunc::EntropyBias(const double& B){
247    static TFltFltH BToP;
248    if (BToP.Empty()) {
249      for (double p = 0.5; p < 1.0; p +=0.0001) {
250        double H = p * log(p) + (1.0-p) * log(1.0 - p);
251        H = -H / log(2.0);
252        BToP.AddDat(TMath::Round(H, 3), p);
253      }
254    }
255    if (BToP.IsKey(TMath::Round(B, 3))) { return BToP.GetDat(TMath::Round(B, 3)); }
256    else { return -1.0; }
257  }
258  double TSpecFunc::GetPowerCoef(const TFltV& XValV, double MinX) {
259    for (int i = 0; MinX <= 0.0 && i < XValV.Len(); i++) { 
260      MinX = XValV[i]; }
261    IAssert(MinX > 0.0);
262    double LnSum=0.0;
263    for (int i = 0; i < XValV.Len(); i++) {
264      if (XValV[i].Val < MinX) continue;
265      LnSum += log(XValV[i] / MinX);
266    }
267    return 1.0 + double(XValV.Len()) / LnSum;
268  }
269  double TSpecFunc::GetPowerCoef(const TFltPrV& XValCntV, double MinX) {
270    for (int i = 0; MinX <= 0.0 && i < XValCntV.Len(); i++) { 
271      MinX = XValCntV[i].Val1; }
272    IAssert(MinX > 0.0);
273    double NSamples=0.0, LnSum=0.0;
274    for (int i = 0; i < XValCntV.Len(); i++) {
275      if (XValCntV[i].Val1() < MinX) continue;
276      LnSum += XValCntV[i].Val2 * log(XValCntV[i].Val1 / MinX);
277      NSamples += XValCntV[i].Val2;
278    }
279    return 1.0 + NSamples / LnSum;
280  }
281  TMom::TMom(const TFltV& _ValV):
282    ValWgtV(_ValV.Len(), 0),
283    SumW(), ValSumW(),
284    UsableP(false), UnusableVal(-1),
285    Mn(), Mx(),
286    Mean(), Vari(), SDev(), SErr(),
287    Median(), Quart1(), Quart3(),
288    DecileV(), PercentileV(){
289    for (int ValN=0; ValN<_ValV.Len(); ValN++){Add(_ValV[ValN], 1);}
290    Def();
291  }
292  void TMom::Def(){
293    IAssert(!DefP); DefP=true;
294    UsableP=(SumW>0)&&(ValWgtV.Len()>0);
295    if (UsableP){
296      Mn=ValWgtV[0].Val1;
297      Mx=ValWgtV[0].Val1;
298      Mean=ValSumW/SumW;
299      Vari=0;
300      if (ValWgtV.Len()>1){
301        for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
302          const double Val=ValWgtV[ValN].Val1;
303          Vari+=ValWgtV[ValN].Val2*TMath::Sqr(Val-Mean);
304          if (Val<Mn){Mn=Val;}
305          if (Val>Mx){Mx=Val;}
306        }
307        Vari=Vari/SumW;
308        if (Vari > 0.0 && SumW > 0.0) {
309          SErr=sqrt(double(Vari))/sqrt(double(SumW)); 
310        } else { SErr = Mx; } 
311      }
312      SDev=sqrt(double(Vari));
313      ValWgtV.Sort();
314      double CurSumW = 0;
315      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
316        CurSumW += ValWgtV[ValN].Val2;
317        if (CurSumW > 0.5*SumW) { 
318          Median = ValWgtV[ValN].Val1; break; }
319        else if (CurSumW == 0.5*SumW) {
320          Median = 0.5 * (ValWgtV[ValN].Val1+ValWgtV[ValN+1].Val1); break; }
321      }
322      Quart1=Quart3=TFlt::Mn;
323      CurSumW = 0;
324      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
325        CurSumW += ValWgtV[ValN].Val2;
326        if (Quart1==TFlt::Mn) {
327          if (CurSumW > 0.25*SumW) {  Quart1 = ValWgtV[ValN].Val1; }
328        } 
329        if (Quart3==TFlt::Mn) {
330          if (CurSumW > 0.75*SumW) { Quart3 = ValWgtV[ValN].Val1; }
331        }
332      }
333      THash<TFlt, TFlt> ValWgtH;
334      for (int i = 0; i < ValWgtV.Len(); i++) {
335        ValWgtH.AddDat(ValWgtV[i].Val1) += ValWgtV[i].Val2; }
336      Mode = TFlt::Mn; double MxWgt=TFlt::Mn;
337      for (int v = 0; v < ValWgtH.Len(); v++) {
338        if (ValWgtH[v] > MxWgt) { MxWgt=ValWgtH[v]; Mode=ValWgtH.GetKey(v); }
339      }
340      CurSumW = 0;
341      int DecileN = 1, PercentileN = 1;
342      DecileV.Gen(11);  PercentileV.Gen(101);
343      DecileV[0]=Mn; DecileV[10]=Mx;
344      PercentileV[0]=Mn; PercentileV[100]=Mx;
345      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
346        CurSumW += ValWgtV[ValN].Val2;
347        if (CurSumW > SumW*DecileN*0.1) { 
348          DecileV[DecileN] = ValWgtV[ValN].Val1;  DecileN++; }
349        if (CurSumW > SumW*PercentileN*0.01) {
350          PercentileV[PercentileN] = ValWgtV[ValN].Val1;  PercentileN++; }
351      }
352    }
353    ValWgtV.Clr();
354  }
355  double TMom::GetByNm(const TStr& MomNm) const {
356    if (MomNm=="Mean"){return GetMean();}
357    else if (MomNm=="Vari"){return GetVari();}
358    else if (MomNm=="SDev"){return GetSDev();}
359    else if (MomNm=="SErr"){return GetSErr();}
360    else if (MomNm=="Median"){return GetMedian();}
361    else if (MomNm=="Quart1"){return GetQuart1();}
362    else if (MomNm=="Quart3"){return GetQuart3();}
363    else if (MomNm=="Decile0"){return GetDecile(0);}
364    else if (MomNm=="Decile1"){return GetDecile(1);}
365    else if (MomNm=="Decile2"){return GetDecile(2);}
366    else if (MomNm=="Decile3"){return GetDecile(3);}
367    else if (MomNm=="Decile4"){return GetDecile(4);}
368    else if (MomNm=="Decile5"){return GetDecile(5);}
369    else if (MomNm=="Decile6"){return GetDecile(6);}
370    else if (MomNm=="Decile7"){return GetDecile(7);}
371    else if (MomNm=="Decile8"){return GetDecile(8);}
372    else if (MomNm=="Decile9"){return GetDecile(9);}
373    else if (MomNm=="Decile10"){return GetDecile(10);}
374    else {Fail; return 0;}
375  }
376  TStr TMom::GetStrByNm(const TStr& MomNm, char* FmtStr) const {
377    if (IsUsable()){
378      if (FmtStr==NULL){
379        return TFlt::GetStr(GetByNm(MomNm));
380      } else {
381        return TFlt::GetStr(GetByNm(MomNm), FmtStr);
382      }
383    } else {
384      return "X";
385    }
386  }
387  TStr TMom::GetStr(
388   const char& SepCh, const char& DelimCh,
389   const bool& DecileP, const bool& PercentileP, const TStr& FmtStr) const {
390    TChA ChA;
391    if (IsUsable()){
392      ChA+="["; ChA+=SepCh;
393      ChA+="Vals"; ChA+=DelimCh; ChA+=TInt::GetStr(GetVals()); ChA+=SepCh;
394      ChA+="Min"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMn(), FmtStr.CStr()); ChA+=SepCh;
395      ChA+="Max"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMx(), FmtStr.CStr()); ChA+=SepCh;
396      ChA+="Mean"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMean(), FmtStr.CStr()); ChA+=SepCh;
397      ChA+="SDev"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetSDev(), FmtStr.CStr()); ChA+=SepCh;
398      ChA+="Quart1"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetQuart1(), FmtStr.CStr()); ChA+=SepCh;
399      ChA+="Median"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMedian(), FmtStr.CStr()); ChA+=SepCh;
400      ChA+="Quart3"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetQuart3(), FmtStr.CStr()); ChA+=SepCh;
401      if (DecileP){
402        for (int DecileN=0; DecileN<=10; DecileN++){
403          ChA+="Dec"; ChA+=TInt::GetStr(DecileN);
404          ChA+=DelimCh; ChA+=TFlt::GetStr(GetDecile(DecileN), FmtStr.CStr());
405          ChA+=SepCh;
406        }
407      }
408      if (PercentileP){
409        for (int PercentileN=0; PercentileN<=100; PercentileN++){
410          ChA+="Per"; ChA+=TInt::GetStr(PercentileN);
411          ChA+=DelimCh; ChA+=TFlt::GetStr(GetPercentile(PercentileN), FmtStr.CStr());
412          ChA+=SepCh;
413        }
414      }
415      ChA+="]";
416    } else {
417      ChA="[Unusable]";
418    }
419    return ChA;
420  }
421  TStr TMom::GetNmVStr(const TStr& VarPfx,
422   const char& SepCh, const bool& DecileP, const bool& PercentileP){
423    TChA ChA;
424    ChA+=VarPfx; ChA+="Vals"; ChA+=SepCh;
425    ChA+=VarPfx; ChA+="Min"; ChA+=SepCh;
426    ChA+=VarPfx; ChA+="Max"; ChA+=SepCh;
427    ChA+=VarPfx; ChA+="Mean"; ChA+=SepCh;
428    ChA+=VarPfx; ChA+="SDev"; ChA+=SepCh;
429    ChA+=VarPfx; ChA+="Quart1"; ChA+=SepCh;
430    ChA+=VarPfx; ChA+="Median"; ChA+=SepCh;
431    ChA+=VarPfx; ChA+="Quart3";
432    if (DecileP){
433      ChA+=SepCh;
434      for (int DecileN=0; DecileN<=10; DecileN++){
435        ChA+=VarPfx; ChA+="Dec"; ChA+=TInt::GetStr(DecileN);
436        if (DecileN<10){ChA+=SepCh;}
437      }
438    }
439    if (PercentileP){
440      ChA+=SepCh;
441      for (int PercentileN=0; PercentileN<=100; PercentileN++){
442        ChA+=VarPfx; ChA+="Per"; ChA+=TInt::GetStr(PercentileN);
443        if (PercentileN<100){ChA+=SepCh;}
444      }
445    }
446    return ChA;
447  }
448  TStr TMom::GetValVStr(
449   const char& SepCh, const bool& DecileP, const bool& PercentileP) const {
450    TChA ChA;
451    if (IsUsable()){
452      ChA+=TInt::GetStr(GetVals()); ChA+=SepCh;
453      ChA+=TFlt::GetStr(GetMn()); ChA+=SepCh;
454      ChA+=TFlt::GetStr(GetMx()); ChA+=SepCh;
455      ChA+=TFlt::GetStr(GetMean()); ChA+=SepCh;
456      ChA+=TFlt::GetStr(GetSDev()); ChA+=SepCh;
457      ChA+=TFlt::GetStr(GetQuart1()); ChA+=SepCh;
458      ChA+=TFlt::GetStr(GetMedian()); ChA+=SepCh;
459      ChA+=TFlt::GetStr(GetQuart3()); ChA+=SepCh;
460      if (DecileP){
461        for (int DecileN=0; DecileN<=10; DecileN++){
462          ChA+=TFlt::GetStr(GetDecile(DecileN)); ChA+=SepCh;
463        }
464      }
465      if (PercentileP){
466        for (int PercentileN=0; PercentileN<=100; PercentileN++){
467          ChA+=TFlt::GetStr(GetPercentile(PercentileN)); ChA+=SepCh;
468        }
469      }
470    } else {
471      int Vals=8;
472      if (DecileP){Vals+=11;}
473      if (PercentileP){Vals+=101;}
474      for (int ValN=0; ValN<Vals; ValN++){
475        ChA="[Unusable]";
476        if (ValN<Vals-1){ChA+=SepCh;}
477      }
478    }
479    return ChA;
480  }
481  TCorr::TCorr(const TFltV& ValV1, const TFltV& ValV2):
482    ValVLen(ValV1.Len()), CorrCf(), CorrCfPrb(), FisherZ(){
483    static const double TINY=1.0e-20;
484    IAssert(ValV1.Len()==ValV2.Len());
485    double MeanVal1=0; double MeanVal2=0;
486    {for (int ValN=0; ValN<ValVLen; ValN++){
487      MeanVal1+=ValV1[ValN]; MeanVal2+=ValV2[ValN];}}
488    MeanVal1/=ValVLen; MeanVal2/=ValVLen;
489    double yt, xt;
490    double syy=0.0; double sxy=0.0; double sxx=0.0;
491    {for (int ValN=0; ValN<ValVLen; ValN++){
492      xt=ValV1[ValN]-MeanVal1;
493      yt=ValV2[ValN]-MeanVal2;
494      sxx+=xt*xt;
495      syy+=yt*yt;
496      sxy+=xt*yt;
497    }}
498    if (sxx*syy==0){
499      CorrCf=0; /&bsol;** not in numerical recipes - check why (pojavi se, ko so same nicle)
500    } else {
501      CorrCf=sxy/sqrt(sxx*syy);
502    }
503    double df=ValVLen-2;
504    double t=CorrCf*sqrt(df/((1.0-CorrCf+TINY)*(1.0+CorrCf+TINY)));
505    CorrCfPrb=TSpecFunc::BetaI(0.5*df,0.5,df/(df+t*t));
506    FisherZ=0.5*log((1.0+(CorrCf)+TINY)/(1.0-(CorrCf)+TINY));
507  }
508  void TStatTest::AveVar(const TFltV& ValV, double& Ave, double& Var){
509    Ave=0;
510    for (int ValN=0; ValN<ValV.Len(); ValN++){
511      Ave+=ValV[ValN];}
512    Ave/=ValV.Len();
513    Var=0;
514    double ep=0;
515    for (int ValN=0; ValN<ValV.Len(); ValN++){
516      double s=ValV[ValN]-Ave;
517      ep+=s;
518      Var+=s*s;
519    }
520    Var=(Var-ep*ep/ValV.Len())/(ValV.Len()-1);
521  }
522  double TStatTest::KsProb(const double& Alam) {
523    const double EPS1 = 0.001;
524    const double EPS2 = 1.0e-8;
525    double a2 = -2.0*Alam*Alam, fac = 2.0, sum = 0.0, term, termbf = 0.0;
526    for (int j=1; j <= 100; j++) {
527      term = fac*exp(a2*j*j);
528      sum += term;
529      if (fabs(term) <= EPS1*termbf || fabs(term) <= EPS2*sum)
530        return sum;
531      fac = -fac;
532      termbf = fabs(term);
533    }
534    return 1.0;
535  }
536  void TStatTest::ChiSquareOne(
537   const TFltV& ObservedBinV, const TFltV& ExpectedBinV,
538   double& ChiSquareVal, double& SignificancePrb){
539    IAssert(ObservedBinV.Len()==ExpectedBinV.Len());
540    int Bins=ObservedBinV.Len();
541    int Constraints=0;
542    int DegreesOfFreedom=Bins-Constraints;
543    ChiSquareVal=0.0;
544    for (int BinN=0; BinN<Bins; BinN++){
545      IAssert(ExpectedBinV[BinN]>0);
546      double BinDiff=ObservedBinV[BinN]-ExpectedBinV[BinN];
547      ChiSquareVal+=BinDiff*BinDiff/ExpectedBinV[BinN];
548    }
549    SignificancePrb=
550     TSpecFunc::GammaQ(0.5*(DegreesOfFreedom), 0.5*(ChiSquareVal));
551  }
552  void TStatTest::ChiSquareTwo(
553   const TFltV& ObservedBin1V, const TFltV& ObservedBin2V,
554   double& ChiSquareVal, double& SignificancePrb){
555    IAssert(ObservedBin1V.Len()==ObservedBin1V.Len());
556    int Bins=ObservedBin1V.Len();
557    int Constraints=0;
558    int DegreesOfFreedom=Bins-Constraints;
559    ChiSquareVal=0.0;
560    for (int BinN=0; BinN<Bins; BinN++){
561      if ((ObservedBin1V[BinN]==0.0) && (ObservedBin2V[BinN]==0.0)){
562        DegreesOfFreedom--;
563      } else {
564        double BinDiff=ObservedBin1V[BinN]-ObservedBin2V[BinN];
565        ChiSquareVal+=BinDiff*BinDiff/(ObservedBin1V[BinN]+ObservedBin2V[BinN]);
566      }
567    }
568    SignificancePrb=
569     TSpecFunc::GammaQ(0.5*(DegreesOfFreedom),0.5*(ChiSquareVal));
570  }
571  void TStatTest::TTest(
572   const TFltV& ValV1, const TFltV& ValV2, double& TTestVal, double& TTestPrb){
573    PMom Val1Mom=TMom::New(ValV1);
574    PMom Val2Mom=TMom::New(ValV2);
575    double ave1=Val1Mom->GetMean();
576    double ave2=Val2Mom->GetMean();
577    double var1=Val1Mom->GetVari();
578    double var2=Val2Mom->GetVari();
579    int n1=ValV1.Len();
580    int n2=ValV2.Len();
581    TTestVal=(ave1-ave2)/sqrt(var1/n1+var2/n2);
582    double df=TMath::Sqr(var1/n1+var2/n2)/(TMath::Sqr(var1/n1)/(n1-1)+TMath::Sqr(var2/n2)/(n2-1));
583    TTestPrb=TSpecFunc::BetaI(0.5*df, 0.5, df/(df+TMath::Sqr(TTestVal)));
584  }
585  void TStatTest::KsTest(const TFltV& ValV1, const TFltV& ValV2, double& DStat, double& PVal) {
586    IAssert(ValV1.IsSorted() && ValV2.IsSorted());
587    int i1=0, i2=0;
588    double CumSum1=0.0, CumSum2=0.0, Cdf1=0.0, Cdf2=0.0;
589    const double N1 = ValV1.Len();
590    const double N2 = ValV2.Len();
591    if (! (N1 > 0.0 && N2 > 0.0)) { DStat = 1.0;  PVal = 0.0;  return; }
592    DStat=0.0; PVal=0.0;
593    while (i1 < ValV1.Len() && i2 < ValV2.Len()) {
594      const double X1 = ValV1[i1];
595      const double X2 = ValV2[i2];
596      if (X1 <= X2) {
597        CumSum1 += 1;
598        Cdf1 = (CumSum1 / N1);
599        i1++;
600      }
601      if (X2 <= X1) {
602        CumSum2 += 1;
603        Cdf2 = (CumSum2 / N2);
604        i2++;
605      }
606      DStat = TMath::Mx(DStat, fabs(Cdf1 - Cdf2));
607    }
608    const double En = sqrt( N1*N2 / (N1+N2));
609    PVal = TStatTest::KsProb((En+0.12+0.11/En)*DStat);
610  }
611  void TStatTest::KsTest(const TFltPrV& ValCntV1, const TFltPrV& ValCntV2, double& DStat, double& PVal) {
612    IAssert(ValCntV1.IsSorted() && ValCntV2.IsSorted());
613    int i1=0, i2=0;
614    double N1=0.0, N2=0.0, CumSum1=0.0, CumSum2=0.0, Cdf1=0.0, Cdf2=0.0;
615    DStat=0.0;  PVal=0.0;
616    for (int i = 0; i < ValCntV1.Len(); i++) N1 += ValCntV1[i].Val2;
617    for (int i = 0; i < ValCntV2.Len(); i++) N2 += ValCntV2[i].Val2;
618    if (! (N1 > 0.0 && N2 > 0.0)) { DStat = 1.0;  PVal = 0.0;  return; }
619    while (i1 < ValCntV1.Len() && i2 < ValCntV2.Len()) {
620      const double X1 = ValCntV1[i1].Val1;
621      const double X2 = ValCntV2[i2].Val1;
622      if (X1 <= X2) {
623        CumSum1 += ValCntV1[i1].Val2;
624        Cdf1 = (CumSum1 / N1);
625        i1++;
626      }
627      if (X2 <= X1) {
628        CumSum2 += ValCntV2[i2].Val2;
629        Cdf2 = (CumSum2 / N2);
630        i2++;
631      }
632      DStat = TMath::Mx(DStat, fabs(Cdf1 - Cdf2));
633    }
634    const double En = sqrt( N1*N2 / (N1+N2));
635    PVal = TStatTest::KsProb((En+0.12+0.11/En)*DStat);
636  }
637  bool TComb::GetNext(){
638    if (ItemV.Len()==0){
639      ItemV.Gen(Order, Order);
640      for (int OrderN=0; OrderN<Order; OrderN++){
641        ItemV[OrderN]=OrderN;}
642      return true;
643    } else {
644      if (ItemV.Last()==Items-1){
645        int OrderN=Order-1;
646        while ((OrderN>=0)&&(ItemV[OrderN]==Items-(Order-OrderN-1)-1)){OrderN--;}
647        if (OrderN<0){
648          return false;
649        } else {
650          ItemV[OrderN]++;
651          for (int SubOrderN=OrderN+1; SubOrderN<Order; SubOrderN++){
652            ItemV[SubOrderN]=ItemV[SubOrderN-1]+1;}
653          CombN++; return true;
654        }
655      } else {
656        ItemV.Last()++; CombN++; return true;
657      }
658    }
659  }
660  int TComb::GetCombs() const {
661    int LCombs=1; int HCombs=1;
662    for (int OrderN=0; OrderN<Order; OrderN++){
663      LCombs*=OrderN+1; HCombs*=Items-OrderN;}
664    int Combs=HCombs/LCombs;
665    return Combs;
666  }
667  void TComb::Wr(){
668    printf("%d:[", GetCombN());
669    for (int OrderN=0; OrderN<Order; OrderN++){
670      if (OrderN>0){printf(" ");}
671      printf("%d", ItemV[OrderN]());
672    }
673    printf("]\n");
674  }
675  PLinReg TLinReg::New(const TFltVV& _XVV, const TFltV& _YV, const TFltV& _SigV){
676    PLinReg LinReg=PLinReg(new TLinReg());
677    LinReg->XVV=_XVV;
678    LinReg->YV=_YV;
679    if (_SigV.Empty()){
680      LinReg->SigV.Gen(LinReg->YV.Len());
681      LinReg->SigV.PutAll(1);
682    } else {
683      LinReg->SigV=_SigV;
684    }
685    LinReg->Recs=LinReg->XVV.GetXDim();
686    LinReg->Vars=LinReg->XVV.GetYDim();
687    IAssert(LinReg->Recs>0);
688    IAssert(LinReg->Vars>0);
689    IAssert(LinReg->YV.Len()==LinReg->Recs);
690    IAssert(LinReg->SigV.Len()==LinReg->Recs);
691    LinReg->CovarVV.Gen(LinReg->Vars+1, LinReg->Vars+1);
692    LinReg->CfV.Gen(LinReg->Vars+1);
693    LinReg->NR_lfit();
694    return LinReg;
695  }
696  void TLinReg::NR_covsrt(
697   TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit){
698    for (int i=mfit+1; i<=Vars; i++){
699      for (int j=1; j<=i; j++){
700        CovarVV.At(i, j)=0; CovarVV.At(j, i)=0.0;}
701    }
702    int k=mfit;
703    for (int j=Vars; j>=1; j--){
704      if (ia[j]!=0){
705        for (int i=1; i<=Vars; i++){Swap(CovarVV.At(i, k), CovarVV.At(i, j));}
706        {for (int i=1; i<=Vars; i++){Swap(CovarVV.At(k, i), CovarVV.At(j, i));}}
707        k--;
708      }
709    }
710  }
711  void TLinReg::NR_gaussj(TFltVV& a, const int& n, TFltVV& b, const int& m){
712    int i, icol=0, irow=0, j, k, l, ll;
713    double big, dum, pivinv;
714    TIntV indxc(n+1);
715    TIntV indxr(n+1);
716    TIntV ipiv(n+1);
717    for (j=1; j<=n; j++){ipiv[j]=0;}
718    for (i=1; i<=n; i++){
719      big=0.0;
720      for (j=1; j<=n; j++){
721        if (ipiv[j]!=1){
722          for (k=1; k<=n; k++){
723            if (ipiv[k]==0){
724              if (fabs(double(a.At(j, k))) >= big){
725                big=fabs(double(a.At(j, k)));
726                irow=j;
727                icol=k;
728              }
729            } else
730            if (ipiv[k]>1){
731              TExcept::Throw("Singular Matrix(1) in Gauss");}
732          }
733        }
734      }
735      ipiv[icol]++;
736      if (irow != icol){
737        for (l=1; l<=n; l++){Swap(a.At(irow, l), a.At(icol, l));}
738        for (l=1; l<=m; l++){Swap(b.At(irow, l), b.At(icol, l));}
739      }
740      indxr[i]=irow;
741      indxc[i]=icol;
742      if (a.At(icol, icol)==0.0){
743        TExcept::Throw("Singular Matrix(1) in Gauss");}
744      pivinv=1.0/a.At(icol, icol);
745      a.At(icol, icol)=1.0;
746      for (l=1; l<=n; l++){a.At(icol, l)=a.At(icol, l)*pivinv;}
747      for (l=1; l<=m; l++){b.At(icol, l)=b.At(icol, l)*pivinv;}
748      for (ll=1; ll<=n; ll++){
749        if (ll != icol){
750          dum=a.At(ll, icol);
751          a.At(ll, icol)=0.0;
752          for (l=1;l<=n;l++){a.At(ll, l)-=a.At(icol, l)*dum;}
753          for (l=1;l<=m;l++){b.At(ll, l)-=b.At(icol, l)*dum;}
754        }
755      }
756    }
757    for (l=n; l>=1; l--){
758      if (indxr[l]!=indxc[l]){
759        for (k=1; k<=n; k++){
760          Swap(a.At(k, indxr[l]), a.At(k, indxc[l]));}
761      }
762    }
763  }
764  void TLinReg::NR_lfit(){
765    int i,j,k,l,m,mfit=0;
766    double ym,wt,sum,sig2i;
767    TIntV ia(Vars+1); for (i=1; i<=Vars; i++){ia[i]=1;}
768    TFltVV beta(Vars+1, 1+1);
769    TFltV afunc(Vars+1);
770    for (j=1;j<=Vars;j++){
771      if (ia[j]!=0){mfit++;}}
772    if (mfit==0){TExcept::Throw("No parameters to be fitted in LFit");}
773    for (j=1; j<=mfit; j++){
774      for (k=1; k<=mfit; k++){CovarVV.At(j, k)=0.0;}
775      beta.At(j, 1)=0.0;
776    }
777    for (i=1; i<=Recs; i++){
<span onclick='openModal()' class='match'>778      GetXV(i, afunc); 
779      ym=GetY(i);
780      if (mfit<Vars){
</span>781        for (j=1;j<=Vars;j++){
782          if (ia[j]==0){ym-=CfV[j]*afunc[j];}}
783      }
784      sig2i=1.0/TMath::Sqr(GetSig(i));
785      for (j=0, l=1; l<=Vars; l++){
786        if (ia[l]!=0){
787          wt=afunc[l]*sig2i;
788          for (j++, k=0, m=1; m<=l; m++){
789            if (ia[m]!=0){CovarVV.At(j, ++k)+=wt*afunc[m];}
790          }
791          beta.At(j, 1)+=ym*wt;
792        }
793      }
794    }
795    for (j=2; j<=mfit; j++){
796      for (k=1; k<j; k++){CovarVV.At(k, j)=CovarVV.At(j, k);}
797    }
798    NR_gaussj(CovarVV, mfit, beta, 1);
799    for (j=0, l=1; l<=Vars; l++){
800      if (ia[l]!=0){CfV[l]=beta.At(++j, 1);}
801    }
802    ChiSq=0.0;
803    for (i=1; i<=Recs; i++){
804      GetXV(i, afunc); 
805      for (sum=0.0, j=1; j<=Vars; j++){sum+=CfV[j]*afunc[j];}
806      ChiSq+=TMath::Sqr((GetY(i)-sum)/GetSig(i));
807    }
808    NR_covsrt(CovarVV, Vars, ia, mfit);
809  }
810  void TLinReg::Wr() const {
811    printf("\n%11s %21s\n","parameter","uncertainty");
812    for (int i=0; i<Vars;i++){
813      printf("  a[%1d] = %8.6f %12.6f\n",
814       i+1, GetCf(i), GetCfUncer(i));
815    }
816    printf("chi-squared = %12f\n", GetChiSq());
817    printf("full covariance matrix\n");
818    {for (int i=0;i<Vars;i++){
819      for (int j=0;j<Vars;j++){
820        printf("%12f", GetCovar(i, j));}
821      printf("\n");
822    }}
823  }
824  PSvd TSvd::New(const TFltVV& _XVV, const TFltV& _YV, const TFltV& _SigV){
825    PSvd Svd=PSvd(new TSvd());
826    Svd->XVV=_XVV;
827    Svd->YV=_YV;
828    if (_SigV.Empty()){
829      Svd->SigV.Gen(Svd->YV.Len());
830      Svd->SigV.PutAll(1);
831    } else {
832      Svd->SigV=_SigV;
833    }
834    Svd->Recs=Svd->XVV.GetXDim();
835    Svd->Vars=Svd->XVV.GetYDim();
836    IAssert(Svd->Recs>0);
837    IAssert(Svd->Vars>0);
838    IAssert(Svd->YV.Len()==Svd->Recs);
839    IAssert(Svd->SigV.Len()==Svd->Recs);
840    Svd->CovarVV.Gen(Svd->Vars+1, Svd->Vars+1);
841    Svd->CfV.Gen(Svd->Vars+1);
842    Svd->NR_svdfit();
843    return Svd;
844  }
845  double TSvd::NR_pythag(double a, double b){
846    double absa,absb;
847    absa=fabs(a);
848    absb=fabs(b);
849    if (absa > absb){
850      return absa*sqrt(1.0+TMath::Sqr(absb/absa));
851    } else {
852      return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+TMath::Sqr(absa/absb)));
853    }
854  }
855  void TSvd::NR_svdcmp(TFltVV& a, int m, int n, TFltV& w, TFltVV& v){
856    int flag,i,its,j,jj,k,l=0,nm;
857    double anorm,c,f,g,h,s,scale,x,y,z;
858    TFltV rv1(n+1);
859    g=scale=anorm=0.0;
860    for (i=1;i<=n;i++) {
861      l=i+1;
862      rv1[i]=scale*g;
863      g=s=scale=0.0;
864      if (i <= m) {
865        for (k=i;k<=m;k++) scale += fabs(double(a.At(k,i)));
866        if (scale) {
867          for (k=i;k<=m;k++) {
868            a.At(k,i) /= scale;
869            s += a.At(k,i)*a.At(k,i);
870          }
871          f=a.At(i,i);
872          g = -NR_SIGN(sqrt(s),f);
873          h=f*g-s;
874          a.At(i,i)=f-g;
875          for (j=l;j<=n;j++) {
876            for (s=0.0,k=i;k<=m;k++) s += a.At(k,i)*a(k,j);
877            f=s/h;
878            for (k=i;k<=m;k++) a.At(k,j) += f*a.At(k,i);
879          }
880          for (k=i;k<=m;k++) a.At(k,i) *= scale;
881        }
882      }
883      w[i]=scale *g;
884      g=s=scale=0.0;
885      if (i <= m && i != n) {
886        for (k=l;k<=n;k++) scale += fabs(double(a.At(i,k)));
887        if (scale) {
888          for (k=l;k<=n;k++) {
889            a.At(i,k) /= scale;
890            s += a.At(i,k)*a.At(i,k);
891          }
892          f=a.At(i,l);
893          g = -NR_SIGN(sqrt(s),f);
894          h=f*g-s;
895          a.At(i,l)=f-g;
896          for (k=l;k<=n;k++) rv1[k]=a.At(i,k)/h;
897          for (j=l;j<=m;j++) {
898            for (s=0.0,k=l;k<=n;k++) s += a.At(j,k)*a.At(i,k);
899            for (k=l;k<=n;k++) a.At(j,k) += s*rv1[k];
900          }
901          for (k=l;k<=n;k++) a.At(i,k) *= scale;
902        }
903      }
904      anorm=NR_FMAX(anorm,(fabs(double(w[i]))+fabs(double(rv1[i]))));
905    }
906    for (i=n;i>=1;i--) {
907      if (i < n) {
908        if (g) {
909          for (j=l;j<=n;j++)
910            v.At(j,i)=(a.At(i,j)/a.At(i,l))/g;
911          for (j=l;j<=n;j++) {
912            for (s=0.0,k=l;k<=n;k++) s += a.At(i,k)*v.At(k,j);
913            for (k=l;k<=n;k++) v.At(k,j) += s*v.At(k,i);
914          }
915        }
916        for (j=l;j<=n;j++) v.At(i,j)=v.At(j,i)=0.0;
917      }
918      v.At(i,i)=1.0;
919      g=rv1[i];
920      l=i;
921    }
922    for (i=NR_IMIN(m,n);i>=1;i--) {
923      l=i+1;
924      g=w[i];
925      for (j=l;j<=n;j++) a.At(i,j)=0.0;
926      if (g) {
927        g=1.0/g;
928        for (j=l;j<=n;j++) {
929          for (s=0.0,k=l;k<=m;k++) s += a.At(k,i)*a.At(k,j);
930          f=(s/a.At(i,i))*g;
931          for (k=i;k<=m;k++) a.At(k,j) += f*a.At(k,i);
932        }
933        for (j=i;j<=m;j++) a.At(j,i) *= g;
934      } else for (j=i;j<=m;j++) a.At(j,i)=0.0;
935      a.At(i,i)++;
936    }
937    for (k=n;k>=1;k--) {
938      for (its=1;its<=30;its++) {
939        flag=1;
940        for (l=k;l>=1;l--) {
941          nm=l-1;
942          if ((double)(fabs(double(rv1[l])+anorm)) == anorm) {
943            flag=0;
944            break;
945          }
946          if ((double)(fabs(double(w[nm]))+anorm) == anorm) break;
947        }
948        if (flag) {
949          c=0.0;
950          s=1.0;
951          for (i=l;i<=k;i++) {
952            f=s*rv1[i];
953            rv1[i]=c*rv1[i];
954            if ((double)(fabs(f)+anorm) == anorm) break;
955            g=w[i];
956            h=NR_pythag(f,g);
957            w[i]=h;
958            h=1.0/h;
959            c=g*h;
960            s = -f*h;
961            for (j=1;j<=m;j++) {
962              y=a.At(j,nm);
963              z=a.At(j,i);
964              a.At(j,nm)=y*c+z*s;
965              a.At(j,i)=z*c-y*s;
966            }
967          }
968        }
969        z=w[k];
970        if (l == k) {
971          if (z < 0.0) {
972            w[k] = -z;
973            for (j=1;j<=n;j++) v.At(j,k) = -v.At(j,k);
974          }
975          break;
976        }
977        if (its==30){
978          TExcept::Throw("no convergence in 30 svdcmp iterations");}
979        x=w[l];
980        nm=k-1;
981        y=w[nm];
982        g=rv1[nm];
983        h=rv1[k];
984        f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
985        g=NR_pythag(f,1.0);
986        f=((x-z)*(x+z)+h*((y/(f+NR_SIGN(g,f)))-h))/x;
987        c=s=1.0;
988        for (j=l;j<=nm;j++) {
989          i=j+1;
990          g=rv1[i];
991          y=w[i];
992          h=s*g;
993          g=c*g;
994          z=NR_pythag(f,h);
995          rv1[j]=z;
996          c=f/z;
997          s=h/z;
998          f=x*c+g*s;
999          g = g*c-x*s;
1000          h=y*s;
1001          y *= c;
1002          for (jj=1;jj<=n;jj++) {
1003            x=v.At(jj,j);
1004            z=v.At(jj,i);
1005            v.At(jj,j)=x*c+z*s;
1006            v.At(jj,i)=z*c-x*s;
1007          }
1008          z=NR_pythag(f,h);
1009          w[j]=z;
1010          if (z) {
1011            z=1.0/z;
1012            c=f*z;
1013            s=h*z;
1014          }
1015          f=c*g+s*y;
1016          x=c*y-s*g;
1017          for (jj=1;jj<=m;jj++) {
1018            y=a.At(jj,j);
1019            z=a.At(jj,i);
1020            a.At(jj,j)=y*c+z*s;
1021            a.At(jj,i)=z*c-y*s;
1022          }
1023        }
1024        rv1[l]=0.0;
1025        rv1[k]=f;
1026        w[k]=x;
1027      }
1028    }
1029  }
1030  void TSvd::NR_svbksb(
1031   TFltVV& u, TFltV& w, TFltVV& v, int m, int n, TFltV& b, TFltV& x){
1032    int jj,j,i;
1033    double s;
1034    TFltV tmp(n+1);
1035    for (j=1;j<=n;j++) {
1036      s=0.0;
1037      if (w[j]) {
1038        for (i=1;i<=m;i++) s += u.At(i,j)*b[i];
1039        s /= w[j];
1040      }
1041      tmp[j]=s;
1042    }
1043    for (j=1;j<=n;j++) {
1044      s=0.0;
1045      for (jj=1;jj<=n;jj++) s += v.At(j,jj)*tmp[jj];
1046      x[j]=s;
1047    }
1048  }
1049  void TSvd::NR_svdvar(TFltVV& v, int ma, TFltV& w, TFltVV& cvm){
1050    int k,j,i;
1051    double sum;
1052    TFltV wti(ma+1);
1053    for (i=1;i<=ma;i++) {
1054      wti[i]=0.0;
1055      if (w[i]) wti[i]=1.0/(w[i]*w[i]);
1056    }
1057    for (i=1;i<=ma;i++) {
1058      for (j=1;j<=i;j++) {
1059        for (sum=0.0,k=1;k<=ma;k++) sum += v.At(i,k)*v.At(j,k)*wti[k];
1060        cvm.At(j,i)=cvm.At(i,j)=sum;
1061      }
1062    }
1063  }
1064  void TSvd::NR_svdfit(){
1065    int j,i;
1066    double wmax,tmp,thresh,sum;
1067    double TOL=1.0e-5;
1068    TFltVV u(Recs+1, Vars+1);
1069    TFltVV v(Vars+1, Vars+1);
1070    TFltV w(Vars+1);
1071    TFltV b(Recs+1);
1072    TFltV afunc(Vars+1);
1073    for (i=1;i<=Recs;i++) {
1074      GetXV(i, afunc); 
1075      tmp=1.0/GetSig(i);
1076      for (j=1;j<=Vars;j++){u.At(i,j)=afunc[j]*tmp;}
1077      b[i]=GetY(i)*tmp;
1078    }
1079    NR_svdcmp(u,Recs,Vars,w,v);
1080    wmax=0.0;
1081    for (j=1;j<=Vars;j++){
1082      if (w[j] > wmax){wmax=w[j];}}
1083    thresh=TOL*wmax;
1084    for (j=1;j<=Vars;j++){
1085      if (double(w[j])<thresh){w[j]=0.0;}}
1086    NR_svbksb(u,w,v,Recs,Vars,b,CfV);
1087    ChiSq=0.0;
1088    for (i=1;i<=Recs;i++) {
1089      GetXV(i, afunc); 
1090      for (sum=0.0,j=1;j<=Vars;j++){sum += CfV[j]*afunc[j];}
1091      ChiSq += (tmp=(GetY(i)-sum)/GetSig(i),tmp*tmp);
1092    }
1093    CovarVV.Gen(Vars+1, Vars+1);
1094    NR_svdvar(v, Vars, w, CovarVV);
1095  }
1096  void TSvd::GetCfV(TFltV& _CfV){
1097    _CfV=CfV; _CfV.Del(0);
1098  }
1099  void TSvd::GetCfUncerV(TFltV& CfUncerV){
1100    CfUncerV.Gen(Vars);
1101    for (int VarN=0; VarN<Vars; VarN++){
1102      CfUncerV[VarN]=GetCfUncer(VarN);
1103    }
1104  }
1105  void TSvd::Svd(const TFltVV& InMtx, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV) {
1106    LSingV.Gen(InMtx.GetYDim()+1, InMtx.GetYDim()+1);
1107    for (int x = 0; x < InMtx.GetXDim(); x++) {
1108      for (int y = 0; y < InMtx.GetYDim(); y++) {
1109        LSingV.At(x+1, y+1) = InMtx.At(x, y);
1110      }
1111    }
1112    RSingV.Gen(InMtx.GetYDim()+1, InMtx.GetYDim()+1);
1113    SingValV.Gen(InMtx.GetYDim()+1);
1114    TSvd::NR_svdcmp(LSingV, InMtx.GetXDim(), InMtx.GetYDim(), SingValV, RSingV);
1115    SingValV.Del(0);
1116    LSingV.DelX(0); LSingV.DelY(0);
1117    RSingV.DelX(0); RSingV.DelY(0);
1118  }
1119  void TSvd::Svd1Based(const TFltVV& InMtx1, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV) {
1120    LSingV = InMtx1;
1121    SingValV.Gen(InMtx1.GetYDim());
1122    RSingV.Gen(InMtx1.GetYDim(), InMtx1.GetYDim());
1123    TSvd::NR_svdcmp(LSingV, InMtx1.GetXDim()-1, InMtx1.GetYDim()-1, SingValV, RSingV);
1124    SingValV.Del(0);
1125    LSingV.DelX(0); LSingV.DelY(0);
1126    RSingV.DelX(0); RSingV.DelY(0);
1127  }
1128  void TSvd::Wr() const {
1129    printf("\n%11s %21s\n","parameter","uncertainty");
1130    for (int i=0; i<Vars;i++){
1131      printf("  a[%1d] = %8.6f %12.6f\n",
1132       i+1, GetCf(i), GetCfUncer(i));
1133    }
1134    printf("chi-squared = %12f\n", GetChiSq());
1135    printf("full covariance matrix\n");
1136    {for (int i=0;i<Vars;i++){
1137      for (int j=0;j<Vars;j++){
1138        printf("%12f", GetCovar(i, j));}
1139      printf("\n");
1140    }}
1141  }
1142  void THist::Add(const double& Val, const bool& OnlyInP) {
1143      const int BucketN = int(floor((Val - MnVal) / BucketSize));
1144  	if (OnlyInP) { 
1145  		EAssert(MnVal <= Val && Val <= MxVal);
1146  		BucketV[BucketN]++;
1147  	} else {
1148  		if (BucketN < 0) {
1149  			BucketV[0]++;
1150  		} else if (BucketN < BucketV.Len()) {
1151  			BucketV[BucketN]++;
1152  		} else {
1153  			BucketV.Last()++;
1154  		}
1155  	}
1156  	Vals++;
1157  }
1158  void THist::SaveStat(const TStr& ValNm, TSOut& FOut) const {
1159      FOut.PutStrLn("#" + ValNm + ": " + Vals.GetStr());
1160      const int Buckets = BucketV.Len() - 1;
1161      for (int BucketN = 0; BucketN < Buckets; BucketN++) {
1162          FOut.PutStrLn(TStr::Fmt("%d-%d\t%d", BucketSize*BucketN,
1163              BucketSize*(BucketN+1), BucketV[BucketN]()));
1164      }
1165      if (BucketV.Last() > 0) {
1166          FOut.PutStrLn(TStr::Fmt("%d-\t%d", BucketSize*Buckets, BucketV.Last()()));
1167      }
1168  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</h3>
            <pre><code>1  void TNEANet::LoadNetworkShM(TShMIn& ShMIn) {
2    MxNId = TInt(ShMIn);
3    MxEId = TInt(ShMIn);
4    LoadTNodeFunctor NodeFn;
5    NodeH.LoadShM(ShMIn, NodeFn);
6    EdgeH.LoadShM(ShMIn);
7    KeyToIndexTypeN.LoadShM(ShMIn);
8    KeyToIndexTypeE.LoadShM(ShMIn);
9    KeyToDenseN.LoadShM(ShMIn);
10    KeyToDenseE.LoadShM(ShMIn);
11    IntDefaultsN.LoadShM(ShMIn);
12    IntDefaultsE.LoadShM(ShMIn);
13    StrDefaultsN.LoadShM(ShMIn);
14    StrDefaultsE.LoadShM(ShMIn);
15    FltDefaultsE.LoadShM(ShMIn);
16    FltDefaultsE.LoadShM(ShMIn);
17    LoadVecFunctor vec_fn;
18    VecOfIntVecsN.LoadShM(ShMIn, vec_fn);
19    VecOfIntVecsE.LoadShM(ShMIn, vec_fn);
20    VecOfStrVecsN.Load(ShMIn);
21    VecOfStrVecsE.Load(ShMIn);
22    VecOfFltVecsN.Load(ShMIn);
23    VecOfFltVecsE.Load(ShMIn);
24    LoadVecOfVecFunctor vec_of_vec_fn;
25    VecOfIntVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
26    VecOfIntVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
27    VecOfFltVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
28    VecOfFltVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
29    LoadHashOfVecFunctor hash_of_vec_fn;
30    VecOfIntHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
31    VecOfIntHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
32    VecOfFltHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
33    VecOfFltHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
34    SAttrN.Load(ShMIn);
35    SAttrE.Load(ShMIn);
36  }
37  bool TNEANet::HasFlag(const TGraphFlag& Flag) const {
38    return HasGraphFlag(TNEANet::TNet, Flag);
39  }
40  bool TNEANet::TNodeI::IsInNId(const int& NId) const {
41    const TNode& Node = NodeHI.GetDat();
42    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
43      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
44        return true;
45    }
46    return false;
47  }
48  bool TNEANet::TNodeI::IsOutNId(const int& NId) const {
49    const TNode& Node = NodeHI.GetDat();
50    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
51      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
52        return true;
53    }
54    return false;
55  }
56  void TNEANet::AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
57    Names = TVec<TStr>();
58    while (!NodeHI.IsEnd()) {
59      if (!NodeAttrIsDeleted(NId, NodeHI)) {
60        Names.Add(NodeHI.GetKey());
61      }
62      NodeHI++;
63    }  
64  }
65  void TNEANet::AttrValueNI(const TInt& NId , TStrIntPrH::TIter NodeHI, TStrV& Values) const {
66    Values = TVec<TStr>();
67    while (!NodeHI.IsEnd()) {
68      if (!NodeAttrIsDeleted(NId, NodeHI)) {
69        Values.Add(GetNodeAttrValue(NId, NodeHI));
70      }
71      NodeHI++;
72    }
73  }
74  void TNEANet::IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
75    Names = TVec<TStr>();
76    while (!NodeHI.IsEnd()) {
77      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
78        Names.Add(NodeHI.GetKey());
79      }
80      NodeHI++;
81    }  
82  }
83  void TNEANet::IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const {
84    Values = TVec<TInt>();
85    while (!NodeHI.IsEnd()) {
86      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
87        TInt val = this->VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
88        Values.Add(val);
89      }
90      NodeHI++;
91    }  
92  }
93  void TNEANet::IntVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
94    Names = TVec<TStr>();
95    while (!NodeHI.IsEnd()) {
96      if (NodeHI.GetDat().Val1 == IntVType) {
97        Names.Add(NodeHI.GetKey());
98      }
99      NodeHI++;
100    }  
101  }
102  void TNEANet::IntVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TIntV>& Values) const {
103    Values = TVec<TIntV>();
104    while (!NodeHI.IsEnd()) {
105      if (NodeHI.GetDat().Val1 == IntVType) {
106        TInt index = NodeHI.GetDat().Val2;
107        TStr attr =  NodeHI.GetKey();
108        TInt loc = CheckDenseOrSparseN(attr);
109        if (loc == 1) {
110          TIntV val = this->VecOfIntVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
111          if (val.Len() != 0) Values.Add(val);
112        } else {
113          const THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[index];
114          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
115            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
116          }
117        }
118      }
119      NodeHI++;
120    }
121  }
122  void TNEANet::FltVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
123    Names = TVec<TStr>();
124    while (!NodeHI.IsEnd()) {
125      if (NodeHI.GetDat().Val1 == FltVType) {
126        Names.Add(NodeHI.GetKey());
127      }
128      NodeHI++;
129    }  
130  }
131  void TNEANet::FltVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TFltV>& Values) const {
132    Values = TVec<TFltV>();
133    while (!NodeHI.IsEnd()) {
134      if (NodeHI.GetDat().Val1 == FltVType) {
135        TInt index = NodeHI.GetDat().Val2;
136        TStr attr =  NodeHI.GetKey();
137        TInt loc = CheckDenseOrSparseN(attr);
138        if (loc == 1) {
139          TFltV val = this->VecOfFltVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
140          if (val.Len() != 0) Values.Add(val);
141        } else {
142          const THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[index];
143          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
144            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
145          }
146        }
147      }
148      NodeHI++;
149    }
150  }
151  void TNEANet::StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
152    Names = TVec<TStr>();
153    while (!NodeHI.IsEnd()) {
154      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
155        Names.Add(NodeHI.GetKey());
156      }
157      NodeHI++;
158    }  
159  }
160  void TNEANet::StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const {
161    Values = TVec<TStr>();
162    while (!NodeHI.IsEnd()) {
163      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
164        TStr val = this->VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
165        Values.Add(val);
166      }
167      NodeHI++;
168    }  
169  }
170  void TNEANet::FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
171    Names = TVec<TStr>();
172    while (!NodeHI.IsEnd()) {
173      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
174        Names.Add(NodeHI.GetKey());
175      }
176      NodeHI++;
177    }  
178  }
179  void TNEANet::FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const {
180    Values = TVec<TFlt>();
181    while (!NodeHI.IsEnd()) {
182      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
183        TFlt val = (this->VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
184        Values.Add(val);
185      }
186      NodeHI++;
187    }  
188  }
189  bool TNEANet::IsAttrDeletedN(const int& NId, const TStr& attr) const {
190    bool IntDel = IsIntAttrDeletedN(NId, attr);
191    bool StrDel = IsStrAttrDeletedN(NId, attr);
192    bool FltDel = IsFltAttrDeletedN(NId, attr);
193    bool IntVDel = IsIntVAttrDeletedN(NId, attr);
194    bool FltVDel = IsFltVAttrDeletedN(NId, attr);
195    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
196  }
197  bool TNEANet::IsIntAttrDeletedN(const int& NId, const TStr& attr) const {
198    return NodeAttrIsIntDeleted(NId, KeyToIndexTypeN.GetI(attr));
199  }
200  bool TNEANet::IsIntVAttrDeletedN(const int& NId, const TStr& attr) const {
201    return NodeAttrIsIntVDeleted(NId, KeyToIndexTypeN.GetI(attr));
202  }
203  bool TNEANet::IsFltVAttrDeletedN(const int& NId, const TStr& attr) const {
204    return NodeAttrIsFltVDeleted(NId, KeyToIndexTypeN.GetI(attr));
205  }
206  bool TNEANet::IsStrAttrDeletedN(const int& NId, const TStr& attr) const {
207    return NodeAttrIsStrDeleted(NId, KeyToIndexTypeN.GetI(attr));
208  }
209  bool TNEANet::IsFltAttrDeletedN(const int& NId, const TStr& attr) const {
210    return NodeAttrIsFltDeleted(NId, KeyToIndexTypeN.GetI(attr));
211  }
212  bool TNEANet::NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
213    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
214    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
215    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
216    bool IntVDel = NodeAttrIsIntVDeleted(NId, NodeHI);
217    return IntDel || StrDel || FltDel || IntVDel;
218  }
219  bool TNEANet::NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
220    if (NodeHI.GetDat().Val1 != IntType) {
221      return false;
222    }
223    return (GetIntAttrDefaultN(NodeHI.GetKey()) == this->VecOfIntVecsN.GetVal(
224      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
225  }
226  bool TNEANet::NodeAttrIsIntVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
227    if (NodeHI.GetDat().Val1 != IntVType) {
228      return false;
229    }
230    return (TIntV() == this->VecOfIntVecVecsN.GetVal(
231      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
232  }
233  bool TNEANet::NodeAttrIsFltVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
234    if (NodeHI.GetDat().Val1 != FltVType) {
235      return false;
236    }
237    return (TFltV() == this->VecOfFltVecVecsN.GetVal(
238      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
239  }
240  bool TNEANet::NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
241    if (NodeHI.GetDat().Val1 != StrType) {
242      return false;
243    }
244    return (GetStrAttrDefaultN(NodeHI.GetKey()) == this->VecOfStrVecsN.GetVal(
245      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
246  }
247  bool TNEANet::NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
248    if (NodeHI.GetDat().Val1 != FltType) {
249      return false;
250    }
251    return (GetFltAttrDefaultN(NodeHI.GetKey()) == this->VecOfFltVecsN.GetVal(
252      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
253  }
254  TStr TNEANet::GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
255    if (NodeHI.GetDat().Val1 == IntType) {
256      return (this->VecOfIntVecsN.GetVal(
257        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
258    } else if(NodeHI.GetDat().Val1 == StrType) {
259      return this->VecOfStrVecsN.GetVal(
260      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
261    } else if (NodeHI.GetDat().Val1 == FltType) {
262      return (this->VecOfFltVecsN.GetVal(
263        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
264    }
265    return TStr::GetNullStr();
266  }
267  void TNEANet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
268    Names = TVec<TStr>();
269    while (!EdgeHI.IsEnd()) {
270      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
271        Names.Add(EdgeHI.GetKey());
272      }
273      EdgeHI++;
274    }  
275  }
276  void TNEANet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
277    Values = TVec<TStr>();
278    while (!EdgeHI.IsEnd()) {
279      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
280        Values.Add(GetEdgeAttrValue(EId, EdgeHI));
281      }
282      EdgeHI++;
283    }  
284  }
285  void TNEANet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
286    Names = TVec<TStr>();
287    while (!EdgeHI.IsEnd()) {
288      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
289        Names.Add(EdgeHI.GetKey());
290      }
291      EdgeHI++;
292    }  
293  }
294  void TNEANet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const {
295    Values = TVec<TInt>();
296    while (!EdgeHI.IsEnd()) {
297      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
298        TInt val = (this->VecOfIntVecsE[EdgeHI.GetDat().Val2].GetVal(EdgeH.GetKeyId(EId)));
299        Values.Add(val);
300      }
301      EdgeHI++;
302    }  
303  }
304  void TNEANet::IntVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
305    Names = TVec<TStr>();
306    while (!EdgeHI.IsEnd()) {
307      if (EdgeHI.GetDat().Val1 == IntVType) {
308        Names.Add(EdgeHI.GetKey());
309      }
310      EdgeHI++;
311    }  
312  }
313  void TNEANet::IntVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TIntV>& Values) const {
314    Values = TVec<TIntV>();
315    while (!EdgeHI.IsEnd()) {
316      if (EdgeHI.GetDat().Val1 == IntVType) {
317        TInt index = EdgeHI.GetDat().Val2;
318        TStr attr =  EdgeHI.GetKey();
319        TInt loc = CheckDenseOrSparseE(attr);
320        if (loc == 1) {
321          TIntV val = this->VecOfIntVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
322          if (val.Len() != 0) Values.Add(val);
323        } else {
324          const THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[index];
325          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
326            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
327          }
328        }
329      }
330      EdgeHI++;
331    }
332  }
333  void TNEANet::FltVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
334    Names = TVec<TStr>();
335    while (!EdgeHI.IsEnd()) {
336      if (EdgeHI.GetDat().Val1 == FltVType) {
337        Names.Add(EdgeHI.GetKey());
338      }
339      EdgeHI++;
340    }  
341  }
342  void TNEANet::FltVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TFltV>& Values) const {
343    Values = TVec<TFltV>();
344    while (!EdgeHI.IsEnd()) {
345      if (EdgeHI.GetDat().Val1 == FltVType) {
346        TInt index = EdgeHI.GetDat().Val2;
347        TStr attr =  EdgeHI.GetKey();
348        TInt loc = CheckDenseOrSparseE(attr);
349        if (loc == 1) {
350          TFltV val = this->VecOfFltVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
351          if (val.Len() != 0) Values.Add(val);
352        } else {
353          const THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[index];
354          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
355            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
356          }
357        }
358      }
359      EdgeHI++;
360    }
361  }
362  void TNEANet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
363    Names = TVec<TStr>();
364    while (!EdgeHI.IsEnd()) {
365      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
366        Names.Add(EdgeHI.GetKey());
367      }
368      EdgeHI++;
369    }  
370  }
371  void TNEANet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
372    Values = TVec<TStr>();
373    while (!EdgeHI.IsEnd()) {
374      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
375        TStr val = this->VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
376        Values.Add(val);
377      }
378      EdgeHI++;
379    }  
380  }
381  void TNEANet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
382    Names = TVec<TStr>();
383    while (!EdgeHI.IsEnd()) {
384      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
385        Names.Add(EdgeHI.GetKey());
386      }
387      EdgeHI++;
388    }  
389  }
390  void TNEANet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const {
391    Values = TVec<TFlt>();
392    while (!EdgeHI.IsEnd()) {
393      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
394        TFlt val = (this->VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
395        Values.Add(val);
396      }
397      EdgeHI++;
398    }  
399  }
400  bool TNEANet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
401    bool IntDel = IsIntAttrDeletedE(EId, attr);
402    bool IntVDel = IsIntVAttrDeletedE(EId, attr);
403    bool StrDel = IsStrAttrDeletedE(EId, attr);
404    bool FltDel = IsFltAttrDeletedE(EId, attr);
405    bool FltVDel = IsFltVAttrDeletedE(EId, attr);
406    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
407  }
408  bool TNEANet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
409    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
410  }
411  bool TNEANet::IsIntVAttrDeletedE(const int& EId, const TStr& attr) const {
412    return EdgeAttrIsIntVDeleted(EId, KeyToIndexTypeE.GetI(attr));
413  }
414  bool TNEANet::IsFltVAttrDeletedE(const int& EId, const TStr& attr) const {
415    return EdgeAttrIsFltVDeleted(EId, KeyToIndexTypeE.GetI(attr));
416  }
417  bool TNEANet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
418    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
419  }
420  bool TNEANet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
421    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
422  }
423  bool TNEANet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
424    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
425    bool IntVDel = EdgeAttrIsIntVDeleted(EId, EdgeHI);
426    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
427    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
428    bool FltVDel = EdgeAttrIsFltVDeleted(EId, EdgeHI);
429    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
430  }
431  bool TNEANet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
432    return (EdgeHI.GetDat().Val1 == IntType &&
433      GetIntAttrDefaultE(EdgeHI.GetKey()) == this->VecOfIntVecsE.GetVal(
434      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
435  }
436  bool TNEANet::EdgeAttrIsIntVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
437    return (EdgeHI.GetDat().Val1 == IntVType &&
438      TIntV() == this->VecOfIntVecVecsE.GetVal(
439      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
440  }
441  bool TNEANet::EdgeAttrIsFltVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
442    return (EdgeHI.GetDat().Val1 == FltVType &&
443      TFltV() == this->VecOfFltVecVecsE.GetVal(
444      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
445  }
446  bool TNEANet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
447    return (EdgeHI.GetDat().Val1 == StrType &&
448      GetStrAttrDefaultE(EdgeHI.GetKey()) == this->VecOfStrVecsE.GetVal(
449      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
450  }
451  bool TNEANet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
452    return (EdgeHI.GetDat().Val1 == FltType &&
453      GetFltAttrDefaultE(EdgeHI.GetKey()) == this->VecOfFltVecsE.GetVal(
454      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
455  }
456  TStr TNEANet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
457    if (EdgeHI.GetDat().Val1 == IntType) {
458      return (this->VecOfIntVecsE.GetVal(
459        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
460    } else if(EdgeHI.GetDat().Val1 == StrType) {
461      return this->VecOfStrVecsE.GetVal(
462      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
463    } else if (EdgeHI.GetDat().Val1 == FltType) {
464      return (this->VecOfFltVecsE.GetVal(
465        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
466    }
467    return TStr::GetNullStr();
468  }
469  int TNEANet::AddNode(int NId) {
470    if (NId == -1) {
471      NId = MxNId;  MxNId++;
472    } else {
473      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
474      MxNId = TMath::Mx(NId+1, MxNId());
475    }
476    NodeH.AddDat(NId, TNode(NId));
477    AddAttributes(NId);
478    return NId;
479  }
480  int TNEANet::AddNodeUnchecked(int NId) {
481    if (NId == -1) {
482      NId = MxNId;  MxNId++;
483    } else {
484      if (IsNode(NId)) { return -1;}
485      MxNId = TMath::Mx(NId+1, MxNId());
486    }
487    NodeH.AddDat(NId, TNode(NId));
488    AddAttributes(NId);
489    return NId;
490  }
491  int TNEANet::AddAttributes(const int NId) {
492    int i;
493    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
494      TVec<TInt>& IntVec = VecOfIntVecsN[i];
495      int KeyId = NodeH.GetKeyId(NId);
496      if (IntVec.Len() > KeyId) {
497        IntVec[KeyId] = TInt::Mn;
498      } else {
499        IntVec.Ins(KeyId, TInt::Mn);
500      }
501    }
502    TVec<TStr> DefIntVec = TVec<TStr>();
503    IntDefaultsN.GetKeyV(DefIntVec);
504    for (i = 0; i < DefIntVec.Len(); i++) {
505      TStr attr = DefIntVec[i];
506      TVec<TInt>& IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
507      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
508    } 
509    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
510      TVec<TStr>& StrVec = VecOfStrVecsN[i];
511      int KeyId = NodeH.GetKeyId(NId);
512      if (StrVec.Len() > KeyId) {
513        StrVec[KeyId] = TStr::GetNullStr();
514      } else {
515        StrVec.Ins(KeyId, TStr::GetNullStr());
516      }
517    }
518    TVec<TStr> DefStrVec = TVec<TStr>();
519    StrDefaultsN.GetKeyV(DefStrVec);
520    for (i = 0; i < DefStrVec.Len(); i++) {
521      TStr attr = DefStrVec[i];
522      TVec<TStr>& StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
523      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
524    }
525    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
526      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
527      int KeyId = NodeH.GetKeyId(NId);
528      if (FltVec.Len() > KeyId) {
529        FltVec[KeyId] = TFlt::Mn;
530      } else {
531        FltVec.Ins(KeyId, TFlt::Mn);
532      }
533    }
534    TVec<TStr> DefFltVec = TVec<TStr>();
535    FltDefaultsN.GetKeyV(DefFltVec);
536    for (i = 0; i < DefFltVec.Len(); i++) {
537      TStr attr = DefFltVec[i];
538      TVec<TFlt>& FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
539      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
540    }
541    for (i = 0; i < VecOfIntVecVecsN.Len(); i++) {
542      TVec<TIntV>& IntVecV = VecOfIntVecVecsN[i];
543      int KeyId = NodeH.GetKeyId(NId);
544      if (IntVecV.Len() > KeyId) {
545        IntVecV[KeyId] = TIntV();
546      } else {
547        IntVecV.Ins(KeyId, TIntV());
548      }
549    }
550    for (i = 0; i < VecOfFltVecVecsN.Len(); i++) {
551      TVec<TFltV>& FltVecV = VecOfFltVecVecsN[i];
552      int KeyId = NodeH.GetKeyId(NId);
553      if (FltVecV.Len() > KeyId) {
554        FltVecV[KeyId] = TFltV();
555      } else {
556        FltVecV.Ins(KeyId, TFltV());
557      }
558    }
559    return NId;
560  }
561  void TNEANet::DelNode(const int& NId) {
562    int i;
563    TInt Id(NId);
564    SAttrN.DelSAttrId(Id);
565    const TNode& Node = GetNode(NId);
566    for (int out = 0; out < Node.GetOutDeg(); out++) {
567      const int EId = Node.GetOutEId(out);
568      const TEdge& Edge = GetEdge(EId);
569      IAssert(Edge.GetSrcNId() == NId);
570      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
571      for (i = 0; i < VecOfIntVecsE.Len(); i++) {
572        TVec<TInt>& IntVec = VecOfIntVecsE[i];
573        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
574      }
575      for (i = 0; i < VecOfStrVecsE.Len(); i++) {
576        TVec<TStr>& StrVec = VecOfStrVecsE[i];
577        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
578      }
579      for (i = 0; i < VecOfFltVecsE.Len(); i++) {
580        TVec<TFlt>& FltVec = VecOfFltVecsE[i];
581        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
582      }
583      for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
584        TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
585        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
586      }
587      for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
588        TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
589        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
590      }
591      for (i = 0; i < VecOfIntHashVecsE.Len(); i++) {
592        THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsE[i];
593        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
594          IntHashV.DelKey(EdgeH.GetKeyId(EId));
595        }
596      }
597      for (i = 0; i < VecOfFltHashVecsE.Len(); i++) {
598        THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsE[i];
599        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
600          FltHashV.DelKey(EdgeH.GetKeyId(EId));
601        }
602      }
603      EdgeH.DelKey(EId);
604    }
605    for (int in = 0; in < Node.GetInDeg(); in++) {
606      const int EId = Node.GetInEId(in);
607      const TEdge& Edge = GetEdge(EId);
608      IAssert(Edge.GetDstNId() == NId);
609      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
610      for (i = 0; i < VecOfIntVecsE.Len(); i++) {
611        TVec<TInt>& IntVec = VecOfIntVecsE[i];
612        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
613      }
614      for (i = 0; i < VecOfStrVecsE.Len(); i++) {
615        TVec<TStr>& StrVec = VecOfStrVecsE[i];
616        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
617      }
618      for (i = 0; i < VecOfFltVecsE.Len(); i++) {
619        TVec<TFlt>& FltVec = VecOfFltVecsE[i];
620        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
621      }
622      for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
623        TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
624        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
625      }
626      for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
627        TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
628        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
629      }
630      for (i = 0; i < VecOfIntHashVecsE.Len(); i++) {
631        THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsE[i];
632        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
633          IntHashV.DelKey(EdgeH.GetKeyId(EId));
634        }
635      }
636      for (i = 0; i < VecOfFltHashVecsE.Len(); i++) {
637        THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsE[i];
638        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
639          FltHashV.DelKey(EdgeH.GetKeyId(EId));
640        }
641      }
642      EdgeH.DelKey(EId);
643    }
644    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
645      TVec<TInt>& IntVec = VecOfIntVecsN[i];
646      IntVec[NodeH.GetKeyId(NId)] = TInt::Mn;
647    }
648    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
649      TVec<TStr>& StrVec = VecOfStrVecsN[i];
650      StrVec[NodeH.GetKeyId(NId)] = TStr::GetNullStr();
651    }
652    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
653      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
654      FltVec[NodeH.GetKeyId(NId)] = TFlt::Mn;
655    }
656    for (i = 0; i < VecOfIntVecVecsN.Len(); i++) {
657      TVec<TIntV>& IntVecV = VecOfIntVecVecsN[i];
658      IntVecV[NodeH.GetKeyId(NId)] = TIntV();
659    }
660    for (i = 0; i < VecOfFltVecVecsN.Len(); i++) {
661      TVec<TFltV>& FltVecV = VecOfFltVecVecsN[i];
662      FltVecV[NodeH.GetKeyId(NId)] = TFltV();
663    }
664    for (i = 0; i < VecOfIntHashVecsN.Len(); i++) {
665      THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsN[i];
666      if (IntHashV.IsKey(NodeH.GetKeyId(NId))) {
667        IntHashV.DelKey(NodeH.GetKeyId(NId));
668      }
669    }
670    for (i = 0; i < VecOfFltHashVecsN.Len(); i++) {
671      THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsN[i];
672      if (FltHashV.IsKey(NodeH.GetKeyId(NId))) {
673        FltHashV.DelKey(NodeH.GetKeyId(NId));
674      }
675    }
676    NodeH.DelKey(NId);
677  }
678  int TNEANet::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
679    int i;
680    if (EId == -1) { EId = MxEId;  MxEId++; }
681    else { MxEId = TMath::Mx(EId+1, MxEId()); }
682    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
683    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
684    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
685    GetNode(SrcNId).OutEIdV.AddSorted(EId);
686    GetNode(DstNId).InEIdV.AddSorted(EId);
687    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
688      TVec<TInt>& IntVec = VecOfIntVecsE[i];
689      int KeyId = EdgeH.GetKeyId(EId);
690      if (IntVec.Len() > KeyId) {
691        IntVec[KeyId] = TInt::Mn;
692      } else {
693        IntVec.Ins(KeyId, TInt::Mn);
694      }
695    }
696    TVec<TStr> DefIntVec = TVec<TStr>();
697    IntDefaultsE.GetKeyV(DefIntVec);
698    for (i = 0; i < DefIntVec.Len(); i++) {
699      TStr attr = DefIntVec[i];
700      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
701      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
702    }
703    for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
704      TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
705      IntVecV.Ins(EdgeH.GetKeyId(EId), TIntV());
706    }
707    for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
708      TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
709      FltVecV.Ins(EdgeH.GetKeyId(EId), TFltV());
710    }
711    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
712      TVec<TStr>& StrVec = VecOfStrVecsE[i];
713      int KeyId = EdgeH.GetKeyId(EId);
714      if (StrVec.Len() > KeyId) {
715        StrVec[KeyId] = TStr::GetNullStr();
716      } else {
717        StrVec.Ins(KeyId, TStr::GetNullStr());
718      }
719    }
720    TVec<TStr> DefStrVec = TVec<TStr>();
721    StrDefaultsE.GetKeyV(DefStrVec);
722    for (i = 0; i < DefStrVec.Len(); i++) {
723      TStr attr = DefStrVec[i];
724      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
725      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
726    }
727    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
728      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
729      int KeyId = EdgeH.GetKeyId(EId);
730      if (FltVec.Len() > KeyId) {
731        FltVec[KeyId] = TFlt::Mn;
732      } else {
733        FltVec.Ins(KeyId, TFlt::Mn);
734      }
735    }
736    TVec<TStr> DefFltVec = TVec<TStr>();
737    FltDefaultsE.GetKeyV(DefFltVec);
738    for (i = 0; i < DefFltVec.Len(); i++) {
739      TStr attr = DefFltVec[i];
740      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
741      FltVec[EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
742    }
743    return EId;
744  }
745  void TNEANet::DelEdge(const int& EId) {
746    int i;
747    IAssert(IsEdge(EId));
748    const int SrcNId = GetEdge(EId).GetSrcNId();
749    const int DstNId = GetEdge(EId).GetDstNId();
750    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
751    GetNode(DstNId).InEIdV.DelIfIn(EId);
752    TInt Id(EId);
753    SAttrE.DelSAttrId(Id);
754    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
755      TVec<TInt>& IntVec = VecOfIntVecsE[i];
756      IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
757    }
758    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
759      TVec<TStr>& StrVec = VecOfStrVecsE[i];
760      StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
761    }
762    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
763      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
764      FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
765    }
766    EdgeH.DelKey(EId);
767  }
768  void TNEANet::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
769    int EId = 0;
770    bool Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
771    IAssert(Edge); 
772    while (Edge) {
773      DelEdge(EId);
774      Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
775    }
776  }
777  bool TNEANet::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
778    if (! IsNode(SrcNId) || ! IsNode(DstNId)) {
779      return false;
780    }
781    const TNode& SrcNode = GetNode(SrcNId);
782    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
783      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
784      if (DstNId == Edge.GetDstNId()) {
785        EId = Edge.GetId();
786        return true;
787      }
788    }
789    if (! IsDir) {
790      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
791        const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
792        if (DstNId == Edge.GetSrcNId()) {
793          EId = Edge.GetId();
794          return true;
795        }
796      }
797    }
798    return false;
799  }
800  void TNEANet::GetNIdV(TIntV& NIdV) const {
801    NIdV.Gen(GetNodes(), 0);
802    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
803      NIdV.Add(NodeH.GetKey(N));
804    }
805  }
806  void TNEANet::GetEIdV(TIntV& EIdV) const {
807    EIdV.Gen(GetEdges(), 0);
808    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
809      EIdV.Add(EdgeH.GetKey(E));
810    }
811  }
812  void TNEANet::Defrag(const bool& OnlyNodeLinks) {
813    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
814      TNode& Node = NodeH[kid];
815      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
816    }
817    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
818    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
819  }
820  bool TNEANet::IsOk(const bool& ThrowExcept) const {
821    bool RetVal = true;
822    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
823      const TNode& Node = NodeH[N];
824      if (! Node.OutEIdV.IsSorted()) {
825        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
826        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
827      }
828      if (! Node.InEIdV.IsSorted()) {
829        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
830        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
831      }
832      int prevEId = -1;
833      for (int e = 0; e < Node.GetOutDeg(); e++) {
834        if (! IsEdge(Node.GetOutEId(e))) {
835          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
836          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
837        }
838        if (e > 0 && prevEId == Node.GetOutEId(e)) {
839          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
840          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
841        }
842        prevEId = Node.GetOutEId(e);
843      }
844      prevEId = -1;
845      for (int e = 0; e < Node.GetInDeg(); e++) {
846        if (! IsEdge(Node.GetInEId(e))) {
847        const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
848        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
849        }
850        if (e > 0 && prevEId == Node.GetInEId(e)) {
851          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
852          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
853        }
854        prevEId = Node.GetInEId(e);
855      }
856    }
857    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
858      const TEdge& Edge = EdgeH[E];
859      if (! IsNode(Edge.GetSrcNId())) {
860        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
861        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
862      }
863      if (! IsNode(Edge.GetDstNId())) {
864        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
865        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
866      }
867    }
868    return RetVal;
869  }
870  void TNEANet::Dump(FILE *OutF) const {
871    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
872    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
873    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Network with Attributes: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
874    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
875      fprintf(OutF, "  %*d:", NodePlaces, NodeI.GetId());
876      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
877      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
878        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
879      fprintf(OutF, "    out[%d]", NodeI.GetOutDeg());
880      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
881        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
882      TIntV IntAttrN;
883      IntAttrValueNI(NodeI.GetId(), IntAttrN);
884      fprintf(OutF, "    nai[%d]", IntAttrN.Len());
885      for (int i = 0; i < IntAttrN.Len(); i++) {
886        fprintf(OutF, " %*i", NodePlaces, IntAttrN[i]()); }
887      TStrV StrAttrN;
888      StrAttrValueNI(NodeI.GetId(), StrAttrN);
889      fprintf(OutF, "    nas[%d]", StrAttrN.Len());
890      for (int i = 0; i < StrAttrN.Len(); i++) {
891        fprintf(OutF, " %*s", NodePlaces, StrAttrN[i]()); }
892      TFltV FltAttrN;
893      FltAttrValueNI(NodeI.GetId(), FltAttrN);
894      fprintf(OutF, "    naf[%d]", FltAttrN.Len());
895      for (int i = 0; i < FltAttrN.Len(); i++) {
896        fprintf(OutF, " %*f", NodePlaces, FltAttrN[i]()); }
897      fprintf(OutF, "\n");
898    }
899    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
900      fprintf(OutF, "  %*d:  %*d  ->  %*d", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
901      TIntV IntAttrE;
902      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
903      fprintf(OutF, "    eai[%d]", IntAttrE.Len());
904      for (int i = 0; i < IntAttrE.Len(); i++) {
905        fprintf(OutF, " %*i", EdgePlaces, IntAttrE[i]()); 
906      }
907      TStrV StrAttrE;
908      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
909      fprintf(OutF, "    eas[%d]", StrAttrE.Len());
910      for (int i = 0; i < StrAttrE.Len(); i++) {
911        fprintf(OutF, " %*s", EdgePlaces, StrAttrE[i]()); 
912      }
913      TFltV FltAttrE;
914      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
915      fprintf(OutF, "    eaf[%d]", FltAttrE.Len());
916      for (int i = 0; i < FltAttrE.Len(); i++) {
917        fprintf(OutF, " %*f", EdgePlaces, FltAttrE[i]()); 
918      }
919      fprintf(OutF, "\n");
920    }
921  }
922  int TNEANet::AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
923    int i;
924    TInt CurrLen;
925    if (!IsNode(NId)) {
926      return -1;
927    }
928    if (KeyToIndexTypeN.IsKey(attr)) {
929      TVec<TInt>& NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
930      NewVec[NodeH.GetKeyId(NId)] = value;
931    } else {
932      CurrLen = VecOfIntVecsN.Len();
933      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
934      TVec<TInt> NewVec = TVec<TInt>();
935      for (i = 0; i < MxNId; i++) {
936        NewVec.Ins(i, GetIntAttrDefaultN(attr));
937      }
938      NewVec[NodeH.GetKeyId(NId)] = value;
939      VecOfIntVecsN.Add(NewVec);
940    }
941    return 0;
942  }
943  int TNEANet::AddIntVAttrDatN(const int& NId, const TIntV& value, const TStr& attr, TBool UseDense) {
944    if (!IsNode(NId)) {
945      return -1;
946    }
947    TInt location = CheckDenseOrSparseN(attr);
948    if (location==-1) {
949      AddIntVAttrN(attr, UseDense);
950      location = CheckDenseOrSparseN(attr);
951    }
952    if (UseDense) {
953      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
954      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
955      NewVec[NodeH.GetKeyId(NId)] = value;
956    } else {
957      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
958      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
959      NewHash.AddDat(NodeH.GetKeyId(NId), value);
960    }
961    return 0;
962  } 
963  int TNEANet::AddFltVAttrDatN(const int& NId, const TFltV& value, const TStr& attr, TBool UseDense) {
964    if (!IsNode(NId)) {
965      return -1;
966    }
967    TInt location = CheckDenseOrSparseN(attr);
968    if (location==-1) {
969      AddFltVAttrN(attr, UseDense);
970      location = CheckDenseOrSparseN(attr);
971    }
972    if (UseDense) {
973      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
974      TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
975      NewVec[NodeH.GetKeyId(NId)] = value;
976    } else {
977      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
978      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
979      NewHash.AddDat(NodeH.GetKeyId(NId), value);
980    }
981    return 0;
982  } 
983  int TNEANet::AppendIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr, TBool UseDense) {
984    if (!IsNode(NId)) {
985      return -1;
986    }
987    TInt location = CheckDenseOrSparseN(attr);
988    if (location==-1) {
989      AddIntVAttrN(attr, UseDense);
990      location = CheckDenseOrSparseN(attr);
991    }
992    if (UseDense) {
993      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
994      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
995      NewVec[NodeH.GetKeyId(NId)].Add(value);
996    } else {
997      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
998      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
999      NewHash[NodeH.GetKeyId(NId)].Add(value);
1000    }
1001    return 0;
1002  } 
1003  int TNEANet::AppendFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr, TBool UseDense) {
1004    if (!IsNode(NId)) {
1005      return -1;
1006    }
1007    TInt location = CheckDenseOrSparseN(attr);
1008    if (location==-1) {
1009      AddFltVAttrN(attr, UseDense);
1010      location = CheckDenseOrSparseN(attr);
1011    }
1012    if (UseDense) {
1013      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
1014      TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1015      NewVec[NodeH.GetKeyId(NId)].Add(value);
1016    } else {
1017      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
1018      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1019      NewHash[NodeH.GetKeyId(NId)].Add(value);
1020    }
1021    return 0;
1022  } 
1023  int TNEANet::DelFromIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
1024    TInt CurrLen;
1025    if (!IsNode(NId)) {
1026      return -1;
1027    }
1028    TInt location = CheckDenseOrSparseN(attr);
1029    if (location != -1) {
1030      if (location == 1) {
1031        TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1032        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1033          return -1;
1034        }
1035      } else {
1036        THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1037        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1038          return -1;
1039        }
1040      }
1041    } else {
1042      return -1;
1043    }
1044    return 0;
1045  } 
1046  int TNEANet::DelFromFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
1047    TInt CurrLen;
1048    if (!IsNode(NId)) {
1049      return -1;
1050    }
1051    TInt location = CheckDenseOrSparseN(attr);
1052    if (location != -1) {
1053      if (location == 1) {
1054        TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1055        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1056          return -1;
1057        }
1058      } else {
1059        THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1060        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1061          return -1;
1062        }
1063      }
1064    } else {
1065      return -1;
1066    }
1067    return 0;
1068  }
1069  int TNEANet::AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr) {
1070    int i;
1071    TInt CurrLen;
1072    if (!IsNode(NId)) {
1073      return -1;
1074    }
1075    if (KeyToIndexTypeN.IsKey(attr)) {
1076      TVec<TStr>& NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1077      NewVec[NodeH.GetKeyId(NId)] = value;
1078    } else {
1079      CurrLen = VecOfStrVecsN.Len();
1080      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1081      TVec<TStr> NewVec = TVec<TStr>();
1082      for (i = 0; i < MxNId; i++) {
1083          NewVec.Ins(i, GetStrAttrDefaultN(attr));
1084      }
1085      NewVec[NodeH.GetKeyId(NId)] = value;
1086      VecOfStrVecsN.Add(NewVec);
1087    }
1088    return 0;
1089  } 
1090  int TNEANet::AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
1091    int i;
1092    TInt CurrLen;
1093    if (!IsNode(NId)) {
1094      return -1;
1095    }
1096    if (KeyToIndexTypeN.IsKey(attr)) {
1097      TVec<TFlt>& NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1098      NewVec[NodeH.GetKeyId(NId)] = value;
1099    } else {
1100      CurrLen = VecOfFltVecsN.Len();
1101      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1102      TVec<TFlt> NewVec = TVec<TFlt>();
1103      for (i = 0; i < MxNId; i++) {
1104        NewVec.Ins(i, GetFltAttrDefaultN(attr));
1105      }
1106      NewVec[NodeH.GetKeyId(NId)] = value;
1107      VecOfFltVecsN.Add(NewVec);
1108    }
1109    return 0;
1110  } 
1111  int TNEANet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
1112    int i;
1113    TInt CurrLen;
1114    if (!IsEdge(EId)) {
1115       return -1;
1116    }
1117    if (KeyToIndexTypeE.IsKey(attr)) {
1118      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1119      NewVec[EdgeH.GetKeyId(EId)] = value;
1120    } else {
1121      CurrLen = VecOfIntVecsE.Len();
1122      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1123      TVec<TInt> NewVec = TVec<TInt>();
1124      for (i = 0; i < MxEId; i++) {
1125        NewVec.Ins(i, GetIntAttrDefaultE(attr));
1126      }
1127      NewVec[EdgeH.GetKeyId(EId)] = value;
1128      VecOfIntVecsE.Add(NewVec);
1129    }
1130    return 0;
1131  }
1132  int TNEANet::AddIntVAttrDatE(const int& EId, const TIntV& value, const TStr& attr, TBool UseDense) {
1133    if (!IsEdge(EId)) {
1134      return -1;
1135    }
1136    TInt location = CheckDenseOrSparseE(attr);
1137    if (location==-1) {
1138      AddIntVAttrE(attr, UseDense);
1139      location = CheckDenseOrSparseE(attr);
1140    }
1141    if (UseDense) {
1142      IAssertR(location != 0, TStr::Fmt("EdgeID %d exists for %s in sparse representation", EId, attr.CStr()));
1143      TVec<TIntV>& NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1144      NewVec[EdgeH.GetKeyId(EId)] = value;
1145    } else {
1146      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", EId, attr.CStr()));
1147      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1148      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1149    }
1150    return 0;
1151  } 
1152  int TNEANet::AddFltVAttrDatE(const int& EId, const TFltV& value, const TStr& attr, TBool UseDense) {
1153    if (!IsEdge(EId)) {
1154      return -1;
1155    }
1156    TInt location = CheckDenseOrSparseE(attr);
1157    if (location==-1) {
<span onclick='openModal()' class='match'>1158      AddFltVAttrE(attr, UseDense);
1159      location = CheckDenseOrSparseE(attr);
1160    }
</span>1161    if (UseDense) {
1162      IAssertR(location != 0, TStr::Fmt("EdgeID %d exists for %s in sparse representation", EId, attr.CStr()));
1163      TVec<TFltV>& NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1164      NewVec[EdgeH.GetKeyId(EId)] = value;
1165    } else {
1166      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", EId, attr.CStr()));
1167      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1168      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1169    }
1170    return 0;
1171  } 
1172  int TNEANet::AppendIntVAttrDatE(const int& EId, const TInt& value, const TStr& attr, TBool UseDense) {
1173    if (!IsEdge(EId)) {
1174      return -1;
1175    }
1176    TInt location = CheckDenseOrSparseE(attr);
1177    if (location==-1) return -1;
1178    if (UseDense) {
1179      IAssertR(location != 0, TStr::Fmt("Edge %d exists for %s in sparse representation", EId, attr.CStr()));
1180      TVec<TIntV>& NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1181      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1182    } else {
1183      IAssertR(location != 1, TStr::Fmt("Edge %d exists for %s in dense representation", EId, attr.CStr()));
1184      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1185      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1186    }
1187    return 0;
1188  }
1189  int TNEANet::AppendFltVAttrDatE(const int& EId, const TFlt& value, const TStr& attr, TBool UseDense) {
1190    if (!IsEdge(EId)) {
1191      return -1;
1192    }
1193    TInt location = CheckDenseOrSparseE(attr);
1194    if (location==-1) return -1;
1195    if (UseDense) {
1196      IAssertR(location != 0, TStr::Fmt("Edge %d exists for %s in sparse representation", EId, attr.CStr()));
1197      TVec<TFltV>& NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1198      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1199    } else {
1200      IAssertR(location != 1, TStr::Fmt("Edge %d exists for %s in dense representation", EId, attr.CStr()));
1201      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1202      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1203    }
1204    return 0;
1205  }
1206  int TNEANet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
1207    int i;
1208    TInt CurrLen;
1209    if (!IsEdge(EId)) {
1210       return -1;
1211    }
1212    if (KeyToIndexTypeE.IsKey(attr)) {
1213      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1214      NewVec[EdgeH.GetKeyId(EId)] = value;
1215    } else {
1216      CurrLen = VecOfStrVecsE.Len();
1217      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1218      TVec<TStr> NewVec = TVec<TStr>();
1219      for (i = 0; i < MxEId; i++) {
1220        NewVec.Ins(i, GetStrAttrDefaultE(attr));
1221      }
1222      NewVec[EdgeH.GetKeyId(EId)] = value;
1223      VecOfStrVecsE.Add(NewVec);
1224    }
1225    return 0;
1226  } 
1227  int TNEANet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
1228    int i;
1229    TInt CurrLen;
1230    if (!IsEdge(EId)) {
1231       return -1;
1232    }
1233    if (KeyToIndexTypeE.IsKey(attr)) {
1234      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1235      NewVec[EdgeH.GetKeyId(EId)] = value;
1236    } else {
1237      CurrLen = VecOfFltVecsE.Len();
1238      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1239      TVec<TFlt> NewVec = TVec<TFlt>();
1240      for (i = 0; i < MxEId; i++) {
1241        NewVec.Ins(i, GetFltAttrDefaultE(attr));
1242      }
1243      NewVec[EdgeH.GetKeyId(EId)] = value;
1244      VecOfFltVecsE.Add(NewVec);
1245    }
1246    return 0;
1247  }
1248  TVec<TFlt>& TNEANet::GetFltAttrVecE(const TStr& attr) {
1249    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1250  }
1251  int TNEANet::GetFltKeyIdE(const int& EId) {
1252    return EdgeH.GetKeyId(EId);
1253  }
1254  TInt TNEANet::GetIntAttrDatN(const int& NId, const TStr& attr) {
1255    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1256  }
1257  TIntV TNEANet::GetIntVAttrDatN(const int& NId, const TStr& attr) const {
1258    TInt location = CheckDenseOrSparseN(attr);
1259    if (location != 0) return VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1260    else return VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1261  }
1262  TFltV TNEANet::GetFltVAttrDatN(const int& NId, const TStr& attr) const {
1263    TInt location = CheckDenseOrSparseN(attr);
1264    if (location != 0) return VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1265    else return VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1266  }
1267  TStr TNEANet::GetStrAttrDatN(const int& NId, const TStr& attr) {
1268    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1269  }
1270  TFlt TNEANet::GetFltAttrDatN(const int& NId, const TStr& attr) {
1271    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1272  }
1273  TInt TNEANet::GetIntAttrIndDatN(const int& NId, const int& index) {
1274    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
1275  }
1276  TStr TNEANet::GetStrAttrIndDatN(const int& NId, const int& index) {
1277    return VecOfStrVecsN[index][NodeH.GetKeyId(NId)];
1278  }
1279  TFlt TNEANet::GetFltAttrIndDatN(const int& NId, const int& index) {
1280    return VecOfFltVecsN[index][NodeH.GetKeyId(NId)];
1281  }
1282  int TNEANet::GetIntAttrIndN(const TStr& attr) {
1283    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1284  }
1285  int TNEANet::GetAttrIndN(const TStr& attr) {
1286    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1287  }
1288  TInt TNEANet::GetIntAttrDatE(const int& EId, const TStr& attr) {
1289    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1290  }
1291  TIntV TNEANet::GetIntVAttrDatE(const int& EId, const TStr& attr) {
1292    TInt location = CheckDenseOrSparseE(attr);
1293    if (location != 0) return VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1294    else return VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1295  }
1296  TFltV TNEANet::GetFltVAttrDatE(const int& EId, const TStr& attr) {
1297    TInt location = CheckDenseOrSparseE(attr);
1298    if (location != 0) return VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1299    else return VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1300  }
1301  TStr TNEANet::GetStrAttrDatE(const int& EId, const TStr& attr) {
1302    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1303  }
1304  TFlt TNEANet::GetFltAttrDatE(const int& EId, const TStr& attr) {
1305    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1306  }
1307  TInt TNEANet::GetIntAttrIndDatE(const int& EId, const int& index) {
1308    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
1309  }
1310  TStr TNEANet::GetStrAttrIndDatE(const int& EId, const int& index) {
1311    return VecOfStrVecsE[index][EdgeH.GetKeyId(EId)];
1312  }
1313  TFlt TNEANet::GetFltAttrIndDatE(const int& EId, const int& index) {
1314    return VecOfFltVecsE[index][EdgeH.GetKeyId(EId)];
1315  }
1316  int TNEANet::GetIntAttrIndE(const TStr& attr) {
1317    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1318  }
1319  int TNEANet::GetAttrIndE(const TStr& attr) {
1320    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1321  }
1322  int TNEANet::DelAttrDatN(const int& NId, const TStr& attr) {
1323    TInt vecType = KeyToIndexTypeN(attr).Val1;
1324    if (vecType == IntType) {
1325      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
1326    } else if (vecType == StrType) {
1327      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
1328    } else if (vecType == FltType) {
1329      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
1330    } else if (vecType ==IntVType) {
1331      TInt location = CheckDenseOrSparseN(attr);
1332      if (location == 0) VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1333      else VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1334    } else if (vecType == FltVType) { 
1335      TInt location = CheckDenseOrSparseN(attr);
1336      if (location == 0) VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1337      else VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1338    } else {
1339      return -1;
1340    }
1341    return 0;
1342  }
1343  int TNEANet::DelAttrDatE(const int& EId, const TStr& attr) {
1344    TInt vecType = KeyToIndexTypeE(attr).Val1;
1345    if (vecType == IntType) {
1346      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
1347    } else if (vecType == StrType) {
1348      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
1349    } else if (vecType == FltType) {
1350      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
1351    } else if (vecType == IntVType) {
1352      TInt location = CheckDenseOrSparseE(attr);
1353      if (location == 0) VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1354      else VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1355    } else if (vecType == FltVType) {
1356      TInt location = CheckDenseOrSparseE(attr);
1357      if (location == 0) VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1358      else VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1359    } else {
1360      return -1;
1361    }
1362    return 0;
1363  }
1364  int TNEANet::AddIntAttrN(const TStr& attr, TInt defaultValue){
1365    int i;
1366    TInt CurrLen;
1367    TVec<TInt> NewVec;
1368    CurrLen = VecOfIntVecsN.Len();
1369    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
1370    NewVec = TVec<TInt>();
1371    for (i = 0; i < MxNId; i++) {
1372      NewVec.Ins(i, defaultValue);
1373    }
1374    VecOfIntVecsN.Add(NewVec);
1375    if (!IntDefaultsN.IsKey(attr)) {
1376      IntDefaultsN.AddDat(attr, defaultValue);
1377    } else {
1378      return -1;
1379    }
1380    return 0;
1381  }
1382  int TNEANet::AddIntVAttrN(const TStr& attr, TBool UseDense){
1383    TInt CurrLen;
1384    if (UseDense) {
1385      CurrLen = VecOfIntVecVecsN.Len();
1386      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1387      KeyToDenseN.AddDat(attr, true);
1388      TVec<TIntV> NewVec = TVec<TIntV>(MxNId);
1389      VecOfIntVecVecsN.Add(NewVec);
1390    } else {
1391      CurrLen = VecOfIntHashVecsN.Len();
1392      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1393      KeyToDenseN.AddDat(attr, false);
1394      THash<TInt, TIntV> NewHash;
1395      VecOfIntHashVecsN.Add(NewHash);
1396    }
1397    return 0;
1398  }
1399  int TNEANet::AddFltVAttrN(const TStr& attr, TBool UseDense){
1400    TInt CurrLen;
1401    if (UseDense) {
1402      CurrLen = VecOfFltVecVecsN.Len();
1403      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1404      KeyToDenseN.AddDat(attr, true);
1405      TVec<TFltV> NewVec = TVec<TFltV>(MxNId);
1406      VecOfFltVecVecsN.Add(NewVec);
1407    } else {
1408      CurrLen = VecOfFltHashVecsN.Len();
1409      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1410      KeyToDenseN.AddDat(attr, false);
1411      THash<TInt, TFltV> NewHash;
1412      VecOfFltHashVecsN.Add(NewHash);
1413    }
1414    return 0;
1415  }
1416  int TNEANet::AddStrAttrN(const TStr& attr, TStr defaultValue) {
1417    int i;
1418    TInt CurrLen;
1419    TVec<TStr> NewVec;
1420    CurrLen = VecOfStrVecsN.Len();
1421    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1422    NewVec = TVec<TStr>();
1423    for (i = 0; i < MxNId; i++) {
1424      NewVec.Ins(i, defaultValue);
1425    }
1426    VecOfStrVecsN.Add(NewVec);
1427    if (!StrDefaultsN.IsKey(attr)) {
1428      StrDefaultsN.AddDat(attr, defaultValue);
1429    } else {
1430      return -1;
1431    }
1432    return 0;
1433  }
1434  int TNEANet::AddFltAttrN(const TStr& attr, TFlt defaultValue) {
1435    int i;
1436    TInt CurrLen;
1437    TVec<TFlt> NewVec;
1438    CurrLen = VecOfFltVecsN.Len();
1439    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1440    NewVec = TVec<TFlt>();
1441    for (i = 0; i < MxNId; i++) {
1442      NewVec.Ins(i, defaultValue);
1443    }
1444    VecOfFltVecsN.Add(NewVec);
1445    if (!FltDefaultsN.IsKey(attr)) {
1446      FltDefaultsN.AddDat(attr, defaultValue);
1447    } else {
1448      return -1;
1449    }
1450    return 0;
1451  }
1452  int TNEANet::AddIntAttrE(const TStr& attr, TInt defaultValue){
1453    int i;
1454    TInt CurrLen;
1455    TVec<TInt> NewVec;
1456    CurrLen = VecOfIntVecsE.Len();
1457    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1458    NewVec = TVec<TInt>();
1459    for (i = 0; i < MxEId; i++) {
1460      NewVec.Ins(i, defaultValue);
1461    }
1462    VecOfIntVecsE.Add(NewVec);
1463    if (!IntDefaultsE.IsKey(attr)) {
1464      IntDefaultsE.AddDat(attr, defaultValue);
1465    } else {
1466      return -1;
1467    }
1468    return 0;
1469  }
1470  int TNEANet::AddIntVAttrE(const TStr& attr, TBool UseDense){
1471    TInt CurrLen;
1472    if (UseDense) {
1473      CurrLen = VecOfIntVecVecsE.Len();
1474      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1475      KeyToDenseE.AddDat(attr, true);
1476      TVec<TIntV> NewVec = TVec<TIntV>(MxEId);
1477      VecOfIntVecVecsE.Add(NewVec);
1478    } else {
1479      CurrLen = VecOfIntHashVecsE.Len();
1480      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1481      KeyToDenseE.AddDat(attr, false);
1482      THash<TInt, TIntV> NewHash;
1483      VecOfIntHashVecsE.Add(NewHash);
1484    }
1485    return 0;
1486  }
1487  int TNEANet::AddFltVAttrE(const TStr& attr, TBool UseDense){
1488    TInt CurrLen;
1489    if (UseDense) {
1490      CurrLen = VecOfFltVecVecsE.Len();
1491      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1492      KeyToDenseE.AddDat(attr, true);
1493      TVec<TFltV> NewVec = TVec<TFltV>(MxEId);
1494      VecOfFltVecVecsE.Add(NewVec);
1495    } else {
1496      CurrLen = VecOfFltHashVecsE.Len();
1497      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1498      KeyToDenseE.AddDat(attr, false);
1499      THash<TInt, TFltV> NewHash;
1500      VecOfFltHashVecsE.Add(NewHash);
1501    }
1502    return 0;
1503  }
1504  int TNEANet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
1505    int i;
1506    TInt CurrLen;
1507    TVec<TStr> NewVec;
1508    CurrLen = VecOfStrVecsE.Len();
1509    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1510    NewVec = TVec<TStr>();
1511    for (i = 0; i < MxEId; i++) {
1512      NewVec.Ins(i, defaultValue);
1513    }
1514    VecOfStrVecsE.Add(NewVec);
1515    if (!StrDefaultsE.IsKey(attr)) {
1516      StrDefaultsE.AddDat(attr, defaultValue);
1517    } else {
1518      return -1;
1519    }
1520    return 0;
1521  }
1522  int TNEANet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
1523    int i;
1524    TInt CurrLen;
1525    TVec<TFlt> NewVec;
1526    CurrLen = VecOfFltVecsE.Len();
1527    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1528    NewVec = TVec<TFlt>();
1529    for (i = 0; i < MxEId; i++) {
1530      NewVec.Ins(i, defaultValue);
1531    }
1532    VecOfFltVecsE.Add(NewVec);
1533    if (!FltDefaultsE.IsKey(attr)) {
1534      FltDefaultsE.AddDat(attr, defaultValue);
1535    } else {
1536      return -1;
1537    }
1538    return 0;
1539  }
1540  int TNEANet::DelAttrN(const TStr& attr) {
1541    TInt vecType = KeyToIndexTypeN(attr).Val1;
1542    if (vecType == IntType) {
1543      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TInt>();
1544      if (IntDefaultsN.IsKey(attr)) {
1545        IntDefaultsN.DelKey(attr);
1546      }
1547    } else if (vecType == StrType) {
1548      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TStr>();  
1549      if (StrDefaultsN.IsKey(attr)) {
1550        StrDefaultsN.DelKey(attr);
1551      }
1552    } else if (vecType == FltType) {
1553      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TFlt>();
1554      if (FltDefaultsN.IsKey(attr)) {
1555        FltDefaultsN.DelKey(attr);
1556      }
1557    } else if (vecType == IntVType) {
1558      TInt location = CheckDenseOrSparseN(attr);
1559      if (location == 1) VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TIntV>();
1560      else VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash<TInt, TIntV>();
1561      KeyToDenseN.DelKey(attr);
1562    } else if (vecType == FltVType) {
1563      TInt location = CheckDenseOrSparseN(attr);
1564      if (location == 1) VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TFltV>();
1565      else VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash<TInt, TFltV>();
1566      KeyToDenseN.DelKey(attr);
1567    } else {
1568      return -1;
1569    }
1570    KeyToIndexTypeN.DelKey(attr);
1571    return 0;
1572  }
1573  int TNEANet::DelAttrE(const TStr& attr) {
1574    TInt vecType = KeyToIndexTypeE(attr).Val1;
1575    if (vecType == IntType) {
1576      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
1577      if (IntDefaultsE.IsKey(attr)) {
1578        IntDefaultsE.DelKey(attr);
1579      }
1580    } else if (vecType == StrType) {
1581      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
1582      if (StrDefaultsE.IsKey(attr)) {
1583        StrDefaultsE.DelKey(attr);
1584      }  
1585    } else if (vecType == FltType) {
1586      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
1587      if (FltDefaultsE.IsKey(attr)) {
1588        FltDefaultsE.DelKey(attr);
1589      }
1590    } else {
1591      return -1;
1592    }
1593    KeyToIndexTypeE.DelKey(attr);
1594    return 0;
1595  }
1596  PNEANet TNEANet::GetSmallGraph() {
1597    PNEANet Net = TNEANet::New();
1598    for (int i = 0; i < 5; i++) { Net->AddNode(i); }
1599    Net->AddEdge(0,1);  Net->AddEdge(0,2);
1600    Net->AddEdge(0,3);  Net->AddEdge(0,4);
1601    Net->AddEdge(1,2);  Net->AddEdge(1,2);
1602    return Net;
1603  }
1604  void TNEANet::GetAttrNNames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const {
1605    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
1606      if (it.GetDat().GetVal1() == IntType) {
1607        IntAttrNames.Add(it.GetKey());
1608      }
1609      if (it.GetDat().GetVal1() == FltType) {
1610        FltAttrNames.Add(it.GetKey());
1611      }
1612      if (it.GetDat().GetVal1() == StrType) {
1613        StrAttrNames.Add(it.GetKey());
1614      }
1615    }
1616  }
1617  void TNEANet::GetAttrENames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const {
1618    for (TStrIntPrH::TIter it = KeyToIndexTypeE.BegI(); it < KeyToIndexTypeE.EndI(); it++) {
1619      if (it.GetDat().GetVal1() == IntType) {
1620        IntAttrNames.Add(it.GetKey());
1621      }
1622      if (it.GetDat().GetVal1() == FltType) {
1623        FltAttrNames.Add(it.GetKey());
1624      }
1625      if (it.GetDat().GetVal1() == StrType) {
1626        StrAttrNames.Add(it.GetKey());
1627      }
1628    }
1629  }
1630  TFlt TNEANet::GetWeightOutEdges(const TNodeI& NI, const TStr& attr) {
1631    TNode Node = GetNode(NI.GetId());
1632    TIntV OutEIdV = Node.OutEIdV;
1633    TFlt total = 0;
1634    int len = Node.OutEIdV.Len();
1635    for (int i = 0; i < len; i++) {
1636      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
1637    }
1638    return total;
1639  }
1640  void TNEANet::GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) {
1641    for (TEdgeI it = BegEI(); it < EndEI(); it++) {
1642      int EId = it.GetId();
1643      int SrcId = it.GetSrcNId();
1644      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
1645    }
1646  }
1647  bool TNEANet::IsFltAttrE(const TStr& attr) {
1648    return (KeyToIndexTypeE.IsKey(attr) &&
1649      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
1650  }
1651  bool TNEANet::IsIntAttrE(const TStr& attr) {
1652    return (KeyToIndexTypeE.IsKey(attr) &&
1653      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
1654  }
1655  bool TNEANet::IsStrAttrE(const TStr& attr) {
1656    return (KeyToIndexTypeE.IsKey(attr) &&
1657      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
1658  }
1659  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
1660    if (!IsNode(NId)) {
1661      return -1;
1662    }
1663    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1664  }
1665  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
1666    if (!IsNode(NId)) {
1667      return -1;
1668    }
1669    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1670  }
1671  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
1672    if (!IsNode(NId)) {
1673      return -1;
1674    }
1675    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1676  }
1677  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
1678    if (!IsNode(NId)) {
1679      return -1;
1680    }
1681    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1682  }
1683  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
1684    if (!IsNode(NId)) {
1685      return -1;
1686    }
1687    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1688  }
1689  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
1690    if (!IsNode(NId)) {
1691      return -1;
1692    }
1693    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1694  }
1695  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
1696    if (!IsNode(NId)) {
1697      return -1;
1698    }
1699    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1700  }
1701  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
1702    if (!IsNode(NId)) {
1703      return -1;
1704    }
1705    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1706  }
1707  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
1708    if (!IsNode(NId)) {
1709      return -1;
1710    }
1711    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1712  }
1713  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
1714    if (!IsNode(NId)) {
1715      return -1;
1716    }
1717    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1718  }
1719  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
1720    if (!IsNode(NId)) {
1721      return -1;
1722    }
1723    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1724  }
1725  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
1726    if (!IsNode(NId)) {
1727      return -1;
1728    }
1729    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1730  }
1731  int TNEANet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
1732    if (!IsNode(NId)) {
1733      return -1;
1734    }
1735    return SAttrN.DelSAttrDat(NId, AttrName);
1736  }
1737  int TNEANet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
1738    if (!IsNode(NId)) {
1739      return -1;
1740    }
1741    return SAttrN.DelSAttrDat(NId, AttrId);
1742  }
1743  int TNEANet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
1744    if (!IsNode(NId)) {
1745      return -1;
1746    }
1747    SAttrN.GetSAttrV(NId, AttrType, AttrV);
1748    return 0;
1749  }
1750  int TNEANet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
1751    return SAttrN.GetIdVSAttr(AttrName, IdV);
1752  }
1753  int TNEANet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
1754    return SAttrN.GetIdVSAttr(AttrId, IdV);
1755  }
1756  int TNEANet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
1757    return SAttrN.AddSAttr(Name, AttrType, AttrId);
1758  }
1759  int TNEANet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
1760    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
1761  }
1762  int TNEANet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
1763    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
1764  }
1765  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TInt& Val) {
1766    if (!IsEdge(EId)) {
1767      return -1;
1768    }
1769    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1770  }
1771  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TInt& Val) {
1772    if (!IsEdge(EId)) {
1773      return -1;
1774    }
1775    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1776  }
1777  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TFlt& Val) {
1778    if (!IsEdge(EId)) {
1779      return -1;
1780    }
1781    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1782  }
1783  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TFlt& Val) {
1784    if (!IsEdge(EId)) {
1785      return -1;
1786    }
1787    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1788  }
1789  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TStr& Val) {
1790    if (!IsEdge(EId)) {
1791      return -1;
1792    }
1793    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1794  }
1795  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TStr& Val) {
1796    if (!IsEdge(EId)) {
1797      return -1;
1798    }
1799    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1800  }
1801  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TInt& Val) const {
1802    if (!IsEdge(EId)) {
1803      return -1;
1804    }
1805    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1806  }
1807  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TInt& Val) const {
1808    if (!IsEdge(EId)) {
1809      return -1;
1810    }
1811    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1812  }
1813  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TFlt& Val) const {
1814    if (!IsEdge(EId)) {
1815      return -1;
1816    }
1817    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1818  }
1819  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TFlt& Val) const {
1820    if (!IsEdge(EId)) {
1821      return -1;
1822    }
1823    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1824  }
1825  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TStr& Val) const {
1826    if (!IsEdge(EId)) {
1827      return -1;
1828    }
1829    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1830  }
1831  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TStr& Val) const {
1832    if (!IsEdge(EId)) {
1833      return -1;
1834    }
1835    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1836  }
1837  int TNEANet::DelSAttrDatE(const TInt& EId, const TStr& AttrName) {
1838    if (!IsEdge(EId)) {
1839      return -1;
1840    }
1841    return SAttrE.DelSAttrDat(EId, AttrName);
1842  }
1843  int TNEANet::DelSAttrDatE(const TInt& EId, const TInt& AttrId) {
1844    if (!IsEdge(EId)) {
1845      return -1;
1846    }
1847    return SAttrE.DelSAttrDat(EId, AttrId);
1848  }
1849  int TNEANet::GetSAttrVE(const TInt& EId, const TAttrType AttrType, TAttrPrV& AttrV) const {
1850    if (!IsEdge(EId)) {
1851      return -1;
1852    }
1853    SAttrE.GetSAttrV(EId, AttrType, AttrV);
1854    return 0;
1855  }
1856  int TNEANet::GetIdVSAttrE(const TStr& AttrName, TIntV& IdV) const {
1857    return SAttrE.GetIdVSAttr(AttrName, IdV);
1858  }
1859  int TNEANet::GetIdVSAttrE(const TInt& AttrId, TIntV& IdV) const {
1860    return SAttrE.GetIdVSAttr(AttrId, IdV);
1861  }
1862  int TNEANet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
1863    return SAttrE.AddSAttr(Name, AttrType, AttrId);
1864  }
1865  int TNEANet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
1866    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
1867  }
1868  int TNEANet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
1869    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
1870  }
1871  bool TUndirNet::HasFlag(const TGraphFlag& Flag) const {
1872    return HasGraphFlag(TUndirNet::TNet, Flag);
1873  }
1874  int TUndirNet::AddNode(int NId) {
1875    if (NId == -1) {
1876      NId = MxNId;  MxNId++;
1877    } else {
1878      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1879      MxNId = TMath::Mx(NId+1, MxNId());
1880    }
1881    NodeH.AddDat(NId, TNode(NId));
1882    return NId;
1883  }
1884  int TUndirNet::AddNodeUnchecked(int NId) {
1885    if (NId == -1) {
1886      NId = MxNId;  MxNId++;
1887    } else {
1888      if (IsNode(NId)) { return -1;}
1889      MxNId = TMath::Mx(NId+1, MxNId());
1890    }
1891    NodeH.AddDat(NId, TNode(NId));
1892    return NId;
1893  }
1894  int TUndirNet::AddNode(const int& NId, const TIntV& NbrNIdV) {
1895    int NewNId;
1896    if (NId == -1) {
1897      NewNId = MxNId;  MxNId++;
1898    } else {
1899      IAssertR(! IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1900      NewNId = NId;
1901      MxNId = TMath::Mx(NewNId+1, MxNId());
1902    }
1903    TNode& Node = NodeH.AddDat(NewNId);
1904    Node.Id = NewNId;
1905    Node.NIdV = NbrNIdV;
1906    Node.NIdV.Sort();
1907    NEdges += Node.GetDeg();
1908    for (int i = 0; i < NbrNIdV.Len(); i++) {
1909      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
1910    }
1911    return NewNId;
1912  }
1913  int TUndirNet::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId) {
1914    int NewNId;
1915    if (NId == -1) {
1916      NewNId = MxNId;  MxNId++;
1917    } else {
1918      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1919      NewNId = NId;
1920      MxNId = TMath::Mx(NewNId+1, MxNId()); 
1921    }
1922    TNode& Node = NodeH.AddDat(NewNId);
1923    Node.Id = NewNId;
1924    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
1925    Node.NIdV.Sort();
1926    NEdges += Node.GetDeg();
1927    return NewNId;
1928  }
1929  void TUndirNet::DelNode(const int& NId) {
1930    { AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
1931    TInt Id(NId);
1932    SAttrN.DelSAttrId(Id);
1933    TNode& Node = GetNode(NId);
1934    NEdges -= Node.GetDeg();
1935    for (int e = 0; e < Node.GetDeg(); e++) {
1936      const int nbr = Node.GetNbrNId(e);
1937      if (nbr == NId) { continue; }
1938      TNode& N = GetNode(nbr);
1939      const int n = N.NIdV.SearchBin(NId);
1940      IAssert(n != -1); 
1941      if (n!= -1) { N.NIdV.Del(n); }
1942    } }
1943    NodeH.DelKey(NId);
1944  }
1945  int TUndirNet::GetEdges() const {
1946    return NEdges;
1947  }
1948  int TUndirNet::AddEdge(const int& SrcNId, const int& DstNId) {
1949    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1950    if (IsEdge(SrcNId, DstNId)) { return -2; } 
1951    GetNode(SrcNId).NIdV.AddSorted(DstNId);
1952    if (SrcNId!=DstNId) { 
1953      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
1954    NEdges++;
1955    return -1; 
1956  }
1957  int TUndirNet::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
1958    GetNode(SrcNId).NIdV.Add(DstNId);
1959    if (SrcNId!=DstNId) { 
1960      GetNode(DstNId).NIdV.Add(SrcNId); }
1961    NEdges++;
1962    return -1; 
1963  }
1964  void TUndirNet::DelEdge(const int& SrcNId, const int& DstNId) {
1965    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1966    { TNode& N = GetNode(SrcNId);
1967    const int n = N.NIdV.SearchBin(DstNId);
1968    TIntPr Id(SrcNId, DstNId);
1969    SAttrE.DelSAttrId(Id);
1970    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
1971    if (SrcNId != DstNId) { 
1972      TNode& N = GetNode(DstNId);
1973      const int n = N.NIdV.SearchBin(SrcNId);
1974      if (n!= -1) { N.NIdV.Del(n); }
1975    }
1976  }
1977  bool TUndirNet::IsEdge(const int& SrcNId, const int& DstNId) const {
1978    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
1979    return GetNode(SrcNId).IsNbrNId(DstNId);
1980  }
1981  TUndirNet::TEdgeI TUndirNet::GetEI(const int& SrcNId, const int& DstNId) const {
1982    const int MnNId = TMath::Mn(SrcNId, DstNId);
1983    const int MxNId = TMath::Mx(SrcNId, DstNId);
1984    const TNodeI SrcNI = GetNI(MnNId);
1985    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
1986    IAssert(NodeN != -1);
1987    return TEdgeI(SrcNI, EndNI(), NodeN);
1988  }
1989  void TUndirNet::GetNIdV(TIntV& NIdV) const {
1990    NIdV.Gen(GetNodes(), 0);
1991    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1992      NIdV.Add(NodeH.GetKey(N)); }
1993  }
1994  void TUndirNet::Defrag(const bool& OnlyNodeLinks) {
1995    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
1996      NodeH[n].NIdV.Pack();
1997    }
1998    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
1999      NodeH.Defrag();
2000    }
2001  }
2002  bool TUndirNet::IsOk(const bool& ThrowExcept) const {
2003    bool RetVal = true;
2004    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2005      const TNode& Node = NodeH[N];
2006      if (! Node.NIdV.IsSorted()) {
2007        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", Node.GetId());
2008        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2009        RetVal=false;
2010      }
2011      int prevNId = -1;
2012      for (int e = 0; e < Node.GetDeg(); e++) {
2013        if (! IsNode(Node.GetNbrNId(e))) {
2014          const TStr Msg = TStr::Fmt("Edge %d --> %d: node %d does not exist.",
2015            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
2016          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2017          RetVal=false;
2018        }
2019        if (e > 0 && prevNId == Node.GetNbrNId(e)) {
2020          const TStr Msg = TStr::Fmt("Node %d has duplicate edge %d --> %d.",
2021            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
2022          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2023          RetVal=false;
2024        }
2025        prevNId = Node.GetNbrNId(e);
2026      }
2027    }
2028    int EdgeCnt = 0;
2029    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) { EdgeCnt++; }
2030    if (EdgeCnt != GetEdges()) {
2031      const TStr Msg = TStr::Fmt("Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.", GetEdges(), EdgeCnt);
2032      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2033      RetVal=false;
2034    }
2035    return RetVal;
2036  }
2037  void TUndirNet::Dump(FILE *OutF) const {
2038    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2039    fprintf(OutF, "-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
2040    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2041      const TNode& Node = NodeH[N];
2042      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
2043      for (int edge = 0; edge < Node.GetDeg(); edge++) {
2044        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
2045      fprintf(OutF, "\n");
2046    }
2047    fprintf(OutF, "\n");
2048  }
2049  PUndirNet TUndirNet::GetSmallGraph() {
2050    PUndirNet Graph = TUndirNet::New();
2051    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
2052    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
2053    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
2054    Graph->AddEdge(1,2);
2055    return Graph;
2056  }
2057  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
2058    if (!IsNode(NId)) {
2059      return -1;
2060    }
2061    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2062  }
2063  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
2064    if (!IsNode(NId)) {
2065      return -1;
2066    }
2067    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2068  }
2069  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
2070    if (!IsNode(NId)) {
2071      return -1;
2072    }
2073    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2074  }
2075  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
2076    if (!IsNode(NId)) {
2077      return -1;
2078    }
2079    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2080  }
2081  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
2082    if (!IsNode(NId)) {
2083      return -1;
2084    }
2085    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2086  }
2087  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
2088    if (!IsNode(NId)) {
2089      return -1;
2090    }
2091    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2092  }
2093  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
2094    if (!IsNode(NId)) {
2095      return -1;
2096    }
2097    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2098  }
2099  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
2100    if (!IsNode(NId)) {
2101      return -1;
2102    }
2103    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2104  }
2105  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
2106    if (!IsNode(NId)) {
2107      return -1;
2108    }
2109    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2110  }
2111  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
2112    if (!IsNode(NId)) {
2113      return -1;
2114    }
2115    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2116  }
2117  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
2118    if (!IsNode(NId)) {
2119      return -1;
2120    }
2121    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2122  }
2123  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
2124    if (!IsNode(NId)) {
2125      return -1;
2126    }
2127    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2128  }
2129  int TUndirNet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
2130    if (!IsNode(NId)) {
2131      return -1;
2132    }
2133    return SAttrN.DelSAttrDat(NId, AttrName);
2134  }
2135  int TUndirNet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
2136    if (!IsNode(NId)) {
2137      return -1;
2138    }
2139    return SAttrN.DelSAttrDat(NId, AttrId);
2140  }
2141  int TUndirNet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2142    if (!IsNode(NId)) {
2143      return -1;
2144    }
2145    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2146    return 0;
2147  }
2148  int TUndirNet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
2149    return SAttrN.GetIdVSAttr(AttrName, IdV);
2150  }
2151  int TUndirNet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
2152    return SAttrN.GetIdVSAttr(AttrId, IdV);
2153  }
2154  int TUndirNet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2155    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2156  }
2157  int TUndirNet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2158    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2159  }
2160  int TUndirNet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2161    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2162  }
2163  TIntPr TUndirNet::OrderEdgeNodes(const int& SrcNId, const int& DstNId) const{
2164    if (SrcNId < DstNId) {
2165      return TIntPr(SrcNId, DstNId);
2166    }
2167    return TIntPr(DstNId, SrcNId);
2168  }
2169  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val) {
2170    if (!IsEdge(SrcNId, DstNId)) {
2171      return -1;
2172    }
2173    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2174    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2175  }
2176  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val) {
2177    if (!IsEdge(SrcNId, DstNId)) {
2178      return -1;
2179    }
2180    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2181    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2182  }
2183  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val) {
2184    if (!IsEdge(SrcNId, DstNId)) {
2185      return -1;
2186    }
2187    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2188    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2189  }
2190  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val) {
2191    if (!IsEdge(SrcNId, DstNId)) {
2192      return -1;
2193    }
2194    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2195    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2196  }
2197  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val) {
2198    if (!IsEdge(SrcNId, DstNId)) {
2199      return -1;
2200    }
2201    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2202    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2203  }
2204  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val) {
2205    if (!IsEdge(SrcNId, DstNId)) {
2206      return -1;
2207    }
2208    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2209    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2210  }
2211  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& Val) const {
2212    if (!IsEdge(SrcNId, DstNId)) {
2213      return -1;
2214    }
2215    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2216    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2217  }
2218  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& Val) const {
2219    if (!IsEdge(SrcNId, DstNId)) {
2220      return -1;
2221    }
2222    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2223    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2224  }
2225  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& Val) const {
2226    if (!IsEdge(SrcNId, DstNId)) {
2227      return -1;
2228    }
2229    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2230    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2231  }
2232  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& Val) const {
2233    if (!IsEdge(SrcNId, DstNId)) {
2234      return -1;
2235    }
2236    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2237    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2238  }
2239  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& Val) const {
2240    if (!IsEdge(SrcNId, DstNId)) {
2241      return -1;
2242    }
2243    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2244    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2245  }
2246  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& Val) const {
2247    if (!IsEdge(SrcNId, DstNId)) {
2248      return -1;
2249    }
2250    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2251    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2252  }
2253  int TUndirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName) {
2254    if (!IsEdge(SrcNId, DstNId)) {
2255      return -1;
2256    }
2257    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2258    return SAttrE.DelSAttrDat(EId, AttrName);
2259  }
2260  int TUndirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId) {
2261    if (!IsEdge(SrcNId, DstNId)) {
2262      return -1;
2263    }
2264    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2265    return SAttrE.DelSAttrDat(EId, AttrId);
2266  }
2267  int TUndirNet::GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2268    if (!IsEdge(SrcNId, DstNId)) {
2269      return -1;
2270    }
2271    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2272    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2273    return 0;
2274  }
2275  int TUndirNet::GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const {
2276    return SAttrE.GetIdVSAttr(AttrName, IdV);
2277  }
2278  int TUndirNet::GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const {
2279    return SAttrE.GetIdVSAttr(AttrId, IdV);
2280  }
2281  int TUndirNet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2282    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2283  }
2284  int TUndirNet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2285    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2286  }
2287  int TUndirNet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2288    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2289  }
2290  bool TDirNet::HasFlag(const TGraphFlag& Flag) const {
2291    return HasGraphFlag(TDirNet::TNet, Flag);
2292  }
2293  int TDirNet::AddNode(int NId) {
2294    if (NId == -1) {
2295      NId = MxNId;  MxNId++;
2296    } else {
2297      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2298      MxNId = TMath::Mx(NId+1, MxNId());
2299    }
2300    NodeH.AddDat(NId, TNode(NId));
2301    return NId;
2302  }
2303  int TDirNet::AddNodeUnchecked(int NId) {
2304    if (NId == -1) {
2305      NId = MxNId;  MxNId++;
2306    } else {
2307      if (IsNode(NId)) { return -1;}
2308      MxNId = TMath::Mx(NId+1, MxNId());
2309    }
2310    NodeH.AddDat(NId, TNode(NId));
2311    return NId;
2312  }
2313  int TDirNet::AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
2314    int NewNId;
2315    if (NId == -1) {
2316      NewNId = MxNId;  MxNId++;
2317    } else {
2318      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2319      NewNId = NId;
2320      MxNId = TMath::Mx(NewNId+1, MxNId());
2321    }
2322    TNode& Node = NodeH.AddDat(NewNId);
2323    Node.Id = NewNId;
2324    Node.InNIdV = InNIdV;
2325    Node.OutNIdV = OutNIdV;
2326    Node.InNIdV.Sort();
2327    Node.OutNIdV.Sort();
2328    return NewNId;
2329  }
2330  int TDirNet::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
2331    int NewNId;
2332    if (NId == -1) {
2333      NewNId = MxNId;  MxNId++;
2334    } else {
2335      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2336      NewNId = NId;
2337      MxNId = TMath::Mx(NewNId+1, MxNId());
2338    }
2339    TNode& Node = NodeH.AddDat(NewNId);
2340    Node.Id = NewNId;
2341    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
2342    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
2343    Node.InNIdV.Sort();
2344    Node.OutNIdV.Sort();
2345    return NewNId;
2346  }
2347  void TDirNet::DelNode(const int& NId) {
2348    { TNode& Node = GetNode(NId);
2349    TInt Id(NId);
2350    SAttrN.DelSAttrId(Id);
2351    for (int e = 0; e < Node.GetOutDeg(); e++) {
2352    const int nbr = Node.GetOutNId(e);
2353    if (nbr == NId) { continue; }
2354      TNode& N = GetNode(nbr);
2355      const int n = N.InNIdV.SearchBin(NId);
2356      if (n!= -1) { N.InNIdV.Del(n); }
2357    }
2358    for (int e = 0; e < Node.GetInDeg(); e++) {
2359    const int nbr = Node.GetInNId(e);
2360    if (nbr == NId) { continue; }
2361      TNode& N = GetNode(nbr);
2362      const int n = N.OutNIdV.SearchBin(NId);
2363      if (n!= -1) { N.OutNIdV.Del(n); }
2364    } }
2365    NodeH.DelKey(NId);
2366  }
2367  int TDirNet::GetEdges() const {
2368    int edges=0;
2369    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2370      edges+=NodeH[N].GetOutDeg();
2371    }
2372    return edges;
2373  }
2374  int TDirNet::AddEdge(const int& SrcNId, const int& DstNId) {
2375    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
2376    if (IsEdge(SrcNId, DstNId)) { return -2; }
2377    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
2378    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
2379    return -1; 
2380  }
2381  int TDirNet::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
2382    GetNode(SrcNId).OutNIdV.Add(DstNId);
2383    GetNode(DstNId).InNIdV.Add(SrcNId);
2384    return -1; 
2385  }
2386  void TDirNet::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
2387    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
2388    { TNode& N = GetNode(SrcNId);
2389    TIntPr Id(SrcNId, DstNId);
2390    SAttrE.DelSAttrId(Id);
2391    const int n = N.OutNIdV.SearchBin(DstNId);
2392    if (n!= -1) { N.OutNIdV.Del(n); } }
2393    { TNode& N = GetNode(DstNId);
2394    const int n = N.InNIdV.SearchBin(SrcNId);
2395    if (n!= -1) { N.InNIdV.Del(n); } }
2396    if (! IsDir) {
2397      { TNode& N = GetNode(SrcNId);
2398      const int n = N.InNIdV.SearchBin(DstNId);
2399      if (n!= -1) { N.InNIdV.Del(n); } }
2400      { TNode& N = GetNode(DstNId);
2401      const int n = N.OutNIdV.SearchBin(SrcNId);
2402      if (n!= -1) { N.OutNIdV.Del(n); } }
2403    }
2404  }
2405  bool TDirNet::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
2406    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
2407    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
2408    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
2409  }
2410  TDirNet::TEdgeI TDirNet::GetEI(const int& SrcNId, const int& DstNId) const {
2411    const TNodeI SrcNI = GetNI(SrcNId);
2412    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
2413    IAssert(NodeN != -1);
2414    return TEdgeI(SrcNI, EndNI(), NodeN);
2415  }
2416  void TDirNet::GetNIdV(TIntV& NIdV) const {
2417    NIdV.Gen(GetNodes(), 0);
2418    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2419      NIdV.Add(NodeH.GetKey(N)); }
2420  }
2421  void TDirNet::Defrag(const bool& OnlyNodeLinks) {
2422    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
2423      TNode& Node = NodeH[n];
2424      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
2425    }
2426    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
2427  }
2428  bool TDirNet::IsOk(const bool& ThrowExcept) const {
2429    bool RetVal = true;
2430    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2431      const TNode& Node = NodeH[N];
2432      if (! Node.OutNIdV.IsSorted()) {
2433        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
2434        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2435      }
2436      if (! Node.InNIdV.IsSorted()) {
2437        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
2438        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2439      }
2440      int prevNId = -1;
2441      for (int e = 0; e < Node.GetOutDeg(); e++) {
2442        if (! IsNode(Node.GetOutNId(e))) {
2443          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
2444            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
2445          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2446        }
2447        if (e > 0 && prevNId == Node.GetOutNId(e)) {
2448          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
2449            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
2450          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2451        }
2452        prevNId = Node.GetOutNId(e);
2453      }
2454      prevNId = -1;
2455      for (int e = 0; e < Node.GetInDeg(); e++) {
2456        if (! IsNode(Node.GetInNId(e))) {
2457          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
2458            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
2459          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2460        }
2461        if (e > 0 && prevNId == Node.GetInNId(e)) {
2462          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
2463            Node.GetId(), Node.GetId(), Node.GetInNId(e));
2464          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2465        }
2466        prevNId = Node.GetInNId(e);
2467      }
2468    }
2469    return RetVal;
2470  }
2471  void TDirNet::Dump(FILE *OutF) const {
2472    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2473    fprintf(OutF, "-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
2474    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2475      const TNode& Node = NodeH[N];
2476      fprintf(OutF, "  %*d]\n", NodePlaces, Node.GetId());
2477      fprintf(OutF, "    in [%d]", Node.GetInDeg());
2478      for (int edge = 0; edge < Node.GetInDeg(); edge++) {
2479        fprintf(OutF, " %*d", NodePlaces, Node.GetInNId(edge)); }
2480      fprintf(OutF, "\n    out[%d]", Node.GetOutDeg());
2481      for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
2482        fprintf(OutF, " %*d", NodePlaces, Node.GetOutNId(edge)); }
2483      fprintf(OutF, "\n");
2484    }
2485    fprintf(OutF, "\n");
2486  }
2487  PDirNet TDirNet::GetSmallGraph() {
2488    PDirNet G = TDirNet::New();
2489    for (int i = 0; i < 5; i++) { G->AddNode(i); }
2490    G->AddEdge(0,1); G->AddEdge(1,2); G->AddEdge(0,2);
2491    G->AddEdge(1,3); G->AddEdge(3,4); G->AddEdge(2,3);
2492    return G;
2493  }
2494  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
2495    if (!IsNode(NId)) {
2496      return -1;
2497    }
2498    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2499  }
2500  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
2501    if (!IsNode(NId)) {
2502      return -1;
2503    }
2504    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2505  }
2506  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
2507    if (!IsNode(NId)) {
2508      return -1;
2509    }
2510    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2511  }
2512  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
2513    if (!IsNode(NId)) {
2514      return -1;
2515    }
2516    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2517  }
2518  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
2519    if (!IsNode(NId)) {
2520      return -1;
2521    }
2522    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2523  }
2524  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
2525    if (!IsNode(NId)) {
2526      return -1;
2527    }
2528    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2529  }
2530  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
2531    if (!IsNode(NId)) {
2532      return -1;
2533    }
2534    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2535  }
2536  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
2537    if (!IsNode(NId)) {
2538      return -1;
2539    }
2540    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2541  }
2542  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
2543    if (!IsNode(NId)) {
2544      return -1;
2545    }
2546    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2547  }
2548  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
2549    if (!IsNode(NId)) {
2550      return -1;
2551    }
2552    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2553  }
2554  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
2555    if (!IsNode(NId)) {
2556      return -1;
2557    }
2558    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2559  }
2560  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
2561    if (!IsNode(NId)) {
2562      return -1;
2563    }
2564    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2565  }
2566  int TDirNet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
2567    if (!IsNode(NId)) {
2568      return -1;
2569    }
2570    return SAttrN.DelSAttrDat(NId, AttrName);
2571  }
2572  int TDirNet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
2573    if (!IsNode(NId)) {
2574      return -1;
2575    }
2576    return SAttrN.DelSAttrDat(NId, AttrId);
2577  }
2578  int TDirNet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2579    if (!IsNode(NId)) {
2580      return -1;
2581    }
2582    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2583    return 0;
2584  }
2585  int TDirNet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
2586    return SAttrN.GetIdVSAttr(AttrName, IdV);
2587  }
2588  int TDirNet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
2589    return SAttrN.GetIdVSAttr(AttrId, IdV);
2590  }
2591  int TDirNet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2592    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2593  }
2594  int TDirNet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2595    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2596  }
2597  int TDirNet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2598    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2599  }
2600  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val) {
2601    if (!IsEdge(SrcNId, DstNId)) {
2602      return -1;
2603    }
2604    TIntPr EId(SrcNId, DstNId);
2605    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2606  }
2607  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val) {
2608    if (!IsEdge(SrcNId, DstNId)) {
2609      return -1;
2610    }
2611    TIntPr EId(SrcNId, DstNId);
2612    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2613  }
2614  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val) {
2615    if (!IsEdge(SrcNId, DstNId)) {
2616      return -1;
2617    }
2618    TIntPr EId(SrcNId, DstNId);
2619    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2620  }
2621  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val) {
2622    if (!IsEdge(SrcNId, DstNId)) {
2623      return -1;
2624    }
2625    TIntPr EId(SrcNId, DstNId);
2626    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2627  }
2628  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val) {
2629    if (!IsEdge(SrcNId, DstNId)) {
2630      return -1;
2631    }
2632    TIntPr EId(SrcNId, DstNId);
2633    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2634  }
2635  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val) {
2636    if (!IsEdge(SrcNId, DstNId)) {
2637      return -1;
2638    }
2639    TIntPr EId(SrcNId, DstNId);
2640    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2641  }
2642  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& Val) const {
2643    if (!IsEdge(SrcNId, DstNId)) {
2644      return -1;
2645    }
2646    TIntPr EId(SrcNId, DstNId);
2647    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2648  }
2649  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& Val) const {
2650    if (!IsEdge(SrcNId, DstNId)) {
2651      return -1;
2652    }
2653    TIntPr EId(SrcNId, DstNId);
2654    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2655  }
2656  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& Val) const {
2657    if (!IsEdge(SrcNId, DstNId)) {
2658      return -1;
2659    }
2660    TIntPr EId(SrcNId, DstNId);
2661    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2662  }
2663  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& Val) const {
2664    if (!IsEdge(SrcNId, DstNId)) {
2665      return -1;
2666    }
2667    TIntPr EId(SrcNId, DstNId);
2668    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2669  }
2670  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& Val) const {
2671    if (!IsEdge(SrcNId, DstNId)) {
2672      return -1;
2673    }
2674    TIntPr EId(SrcNId, DstNId);
2675    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2676  }
2677  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& Val) const {
2678    if (!IsEdge(SrcNId, DstNId)) {
2679      return -1;
2680    }
2681    TIntPr EId(SrcNId, DstNId);
2682    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2683  }
2684  int TDirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName) {
2685    if (!IsEdge(SrcNId, DstNId)) {
2686      return -1;
2687    }
2688    TIntPr EId(SrcNId, DstNId);
2689    return SAttrE.DelSAttrDat(EId, AttrName);
2690  }
2691  int TDirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId) {
2692    if (!IsEdge(SrcNId, DstNId)) {
2693      return -1;
2694    }
2695    TIntPr EId(SrcNId, DstNId);
2696    return SAttrE.DelSAttrDat(EId, AttrId);
2697  }
2698  int TDirNet::GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2699    if (!IsEdge(SrcNId, DstNId)) {
2700      return -1;
2701    }
2702    TIntPr EId(SrcNId, DstNId);
2703    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2704    return 0;
2705  }
2706  int TDirNet::GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const {
2707    return SAttrE.GetIdVSAttr(AttrName, IdV);
2708  }
2709  int TDirNet::GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const {
2710    return SAttrE.GetIdVSAttr(AttrId, IdV);
2711  }
2712  int TDirNet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2713    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2714  }
2715  int TDirNet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2716    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2717  }
2718  int TDirNet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2719    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2720  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</div>
                </div>
                <div class="column column_space"><pre><code>778      GetXV(i, afunc); 
779      ym=GetY(i);
780      if (mfit<Vars){
</pre></code></div>
                <div class="column column_space"><pre><code>1158      AddFltVAttrE(attr, UseDense);
1159      location = CheckDenseOrSparseE(attr);
1160    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    