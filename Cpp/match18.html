<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Trie.cpp & EncodedColumnStore.hpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Trie.cpp & EncodedColumnStore.hpp
      </h3>
      <h1 align="center">
        8.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Trie.cpp (5.3742805%)<TH>EncodedColumnStore.hpp (16.470589%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match18-0.html#0',2,'match18-1.html#0',3)" NAME="0">(38-46)<TD><A HREF="javascript:ZweiFrames('match18-0.html#0',2,'match18-1.html#0',3)" NAME="0">(116-125)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match18-0.html#1',2,'match18-1.html#1',3)" NAME="1">(16-19)<TD><A HREF="javascript:ZweiFrames('match18-0.html#1',2,'match18-1.html#1',3)" NAME="1">(88-91)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Trie.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
*
* Author: Christopher R. Aberger
*
* The top level datastructure. This class holds the methods to create the 
* trie from a table. The TrieBlock class holds the more interesting methods.
******************************************************************************/
#include &quot;tbb/parallel_sort.h&quot;
#include &quot;tbb/task_scheduler_init.h&quot;
#include &quot;Trie.hpp&quot;
#include &quot;trie/TrieBlock.hpp&quot;
#include &quot;utils/ParMMapBuffer.hpp&quot;
<A NAME="1"></A>#include &quot;utils/ParMemoryBuffer.hpp&quot;

template&lt;class A,class M&gt;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match18-1.html#1',3,'match18-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>void Trie&lt;A,M&gt;::save(){
  std::ofstream *writefile = new std::ofstream();
  std::string file = memoryBuffers-&gt;path+M::folder+std::string(&quot;trieinfo.bin&quot;);
  writefile-&gt;open(file, std::ios::binary | std::ios::trunc);</B></FONT>
  writefile-&gt;write((char *)&amp;annotated, sizeof(annotated));
  writefile-&gt;write((char *)&amp;annotation, sizeof(annotation));
  writefile-&gt;write((char *)&amp;num_rows, sizeof(num_rows));
  writefile-&gt;write((char *)&amp;num_columns, sizeof(num_columns));
  writefile-&gt;write((char *)&amp;memoryBuffers-&gt;num_buffers, sizeof(memoryBuffers-&gt;num_buffers));
  
  const size_t h_size = memoryBuffers-&gt;head-&gt;getSize();
  writefile-&gt;write((char *)&amp;h_size, sizeof(h_size));
  for(size_t i = 0; i &lt; memoryBuffers-&gt;num_buffers; i++){
    const size_t t_size = memoryBuffers-&gt;get_size(i);
    writefile-&gt;write((char *)&amp;t_size, sizeof(t_size));
  }
  writefile-&gt;close();

  memoryBuffers-&gt;save();
<A NAME="0"></A>}

template&lt;class A,class M&gt;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match18-1.html#0',3,'match18-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Trie&lt;A,M&gt;* Trie&lt;A,M&gt;::load(std::string path){
  bool annotated_in;
  A annotation_in;
  size_t num_rows;
  size_t num_columns;

  std::ifstream *infile = new std::ifstream();
  std::string file = path+M::folder+std::string(&quot;trieinfo.bin&quot;);
  infile-&gt;open(file, std::ios::binary | std::ios::in);</B></FONT>
  infile-&gt;read((char *)&amp;annotated_in, sizeof(annotated_in));
  infile-&gt;read((char *)&amp;annotation_in, sizeof(annotation_in));
  infile-&gt;read((char *)&amp;num_rows, sizeof(num_rows));
  infile-&gt;read((char *)&amp;num_columns, sizeof(num_columns));

  size_t w_n_threads;
  infile-&gt;read((char *)&amp;w_n_threads, sizeof(w_n_threads));
  std::vector&lt;size_t&gt; buf_sizes;
  size_t h_size;
  infile-&gt;read((char *)&amp;h_size, sizeof(h_size));
  buf_sizes.push_back(h_size);
  
  for(size_t i = 0 ; i &lt; w_n_threads; i++){
    size_t b_size;
    infile-&gt;read((char *)&amp;b_size, sizeof(b_size));
    buf_sizes.push_back(b_size);
  }
  infile-&gt;close();

  //init memory buffers
  M* memoryBuffers_in = M::load(path,w_n_threads,&amp;buf_sizes);

  return new Trie&lt;A,M&gt;(
    annotated_in,
    annotation_in,
    num_rows,
    num_columns,
    memoryBuffers_in);
}


template&lt;class A,class M&gt;
void recursive_foreach(
  const bool annotated,
  M* memoryBuffers,
  TrieBlock&lt;layout,M&gt; *current, 
  const size_t level, 
  const size_t num_levels,
  std::vector&lt;uint32_t&gt;* tuple,
  const std::function&lt;void(std::vector&lt;uint32_t&gt;*,A)&gt; body){

  if(level+1 == num_levels){
    current-&gt;get_set()-&gt;foreach_index([&amp;](const uint32_t a_i, const uint32_t a_d){
      tuple-&gt;push_back(a_d);
      (void) a_i;
      if(annotated){
        const A annotation = current-&gt;template get_annotation&lt;A&gt;(a_i,a_d);
        body(tuple,annotation);
      } else{
        body(tuple,(A)0);
      } 
      tuple-&gt;pop_back();
    });
  } else {
    current-&gt;get_set()-&gt;foreach_index([&amp;](const uint32_t a_i, const uint32_t a_d){
      //if not done recursing and we have data
      tuple-&gt;push_back(a_d);
      if(current-&gt;get_next_block(a_i,a_d,memoryBuffers) != NULL){
        recursive_foreach&lt;A,M&gt;(
          annotated,
          memoryBuffers,
          current-&gt;get_next_block(a_i,a_d,memoryBuffers),
          level+1,
          num_levels,
          tuple,
          body);
      }
      tuple-&gt;pop_back(); //delete the last element
    });
  }
}

template&lt;class A,class M&gt;
TrieBlock&lt;layout,M&gt;* Trie&lt;A,M&gt;::getHead(){
  if(num_columns == 0)
    return NULL;
  TrieBlock&lt;layout,M&gt;* head = (TrieBlock&lt;layout,M&gt;*)(memoryBuffers-&gt;get_address(NUM_THREADS,0));
  return head; 
}

/*
* Write the trie to a binary file 
*/
template&lt;class A,class M&gt;
void Trie&lt;A,M&gt;::foreach(const std::function&lt;void(std::vector&lt;uint32_t&gt;*,A)&gt; body){
  std::vector&lt;uint32_t&gt;* tuple = new std::vector&lt;uint32_t&gt;();
  TrieBlock&lt;layout,M&gt;* head = this-&gt;getHead();
  if(head != NULL &amp;&amp; head-&gt;get_set()-&gt;cardinality &gt; 0){
    head-&gt;get_set()-&gt;foreach_index([&amp;](uint32_t a_i, uint32_t a_d){
      tuple-&gt;push_back(a_d);
      if(num_columns &gt; 1){
        TrieBlock&lt;layout,M&gt;* next = head-&gt;get_next_block(a_i,a_d,memoryBuffers);
        if(next != NULL){
          recursive_foreach&lt;A,M&gt;(
            annotated,
            memoryBuffers,
            next,
            1,
            num_columns,
            tuple,
            body);
        }
      } else if(annotated) {
        const A annotationValue = head-&gt;template get_annotation&lt;A&gt;(a_i,a_d);
        body(tuple,annotationValue);
      } else if(num_columns == 1){
        body(tuple,(A)0); 
      }
      tuple-&gt;pop_back(); //delete the last element
    });
  } else if(annotated){
    body(tuple,(A)annotation); 
  }
}


/*
/////////////////////////////////////////////////////
Constructor code from here down
/////////////////////////////////////////////////////
*/


/*
* Recursive sort function to get the relation in order for the trie.
*/
struct SortColumns{
  std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *columns; 
  SortColumns(std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *columns_in){
    columns = columns_in;
  }
  bool operator()(uint32_t i, uint32_t j) const {
    for(size_t c = 0; c &lt; columns-&gt;size(); c++){
      if(columns-&gt;at(c).at(i) != columns-&gt;at(c).at(j)){
        return columns-&gt;at(c).at(i) &lt; columns-&gt;at(c).at(j);
      }
    }
    return false;
  }
};

/*
* Given a range of values figure out the distinct values to go in the set.
* Helper method for the constructor
*/
std::tuple&lt;size_t,size_t&gt; produce_ranges(
  size_t start, 
  size_t end, 
  size_t *next_ranges, 
  uint32_t *data,
  uint32_t *indicies, 
  std::vector&lt;uint32_t&gt; * current){

  size_t range = 0;

  size_t num_distinct = 0;
  size_t i = start;
  while(true){
    const size_t start_range = i;
    const uint32_t cur = current-&gt;at(indicies[i]);
    uint32_t prev = cur;

    next_ranges[num_distinct] = start_range;
    data[num_distinct] = cur;

    ++num_distinct;
    range = cur;

    while(cur == prev){
      if((i+1) &gt;= end)
        goto FINISH;
      prev = current-&gt;at(indicies[++i]);
    }
  }
  FINISH:
  next_ranges[num_distinct] = end;
  return std::tuple&lt;size_t,size_t&gt;(num_distinct,range+1);
}

/*
* Produce a TrieBlock
*/
template&lt;class B, class A&gt;
size_t build_block(
  const size_t tid,  
  A *data_allocator, 
  const size_t set_size, 
  uint32_t *set_data_buffer){

  const uint8_t * const start_block = data_allocator-&gt;get_next(tid,sizeof(B));
  const size_t offset = start_block-data_allocator-&gt;get_address(tid);

  Set&lt;hybrid&gt;* myset = (Set&lt;hybrid&gt;*)(data_allocator-&gt;get_next(tid,sizeof(Set&lt;layout&gt;)));
  const size_t set_range = (set_size &gt; 1) ? (set_data_buffer[set_size-1]-set_data_buffer[0]) : 0;
  const size_t set_alloc_size =  layout::get_number_of_bytes(set_size,set_range)*2+100;
  uint8_t* set_data_in = data_allocator-&gt;get_next(tid,set_alloc_size);
  
  TrieBlock&lt;layout,A&gt;* tmp = TrieBlock&lt;layout,A&gt;::get_block(tid,offset,data_allocator);
  myset = tmp-&gt;get_set();
  myset-&gt;from_array(set_data_in,set_data_buffer,set_size);

///some debug code for safety (should be in a debug pragma) FIXME
  size_t check_index = 0;
  myset-&gt;foreach_index([&amp;](uint32_t index, uint32_t data){
    (void) data; (void) index;
    assert(data == set_data_buffer[index]);
    check_index++;
  });
  assert(check_index == set_size);
//end debug code

  assert(set_alloc_size &gt;= myset-&gt;number_of_bytes);
  data_allocator-&gt;roll_back(tid,set_alloc_size-myset-&gt;number_of_bytes);

  return offset;
}

/*
* Produce a TrieBlock
*/
template&lt;class B, class A&gt;
size_t build_head(
  A *data_allocator, 
  const size_t set_size, 
  uint32_t *set_data_buffer){

  const uint8_t * const start_block = (uint8_t*) (data_allocator-&gt;get_next(NUM_THREADS,sizeof(B)));
  const size_t offset = start_block-((uint8_t*)data_allocator-&gt;get_address(NUM_THREADS));

  Set&lt;layout&gt;* myset = (Set&lt;layout&gt;*)(data_allocator-&gt;get_next(NUM_THREADS,sizeof(Set&lt;layout&gt;)));
  const size_t set_range = (set_size &gt; 1) ? (set_data_buffer[set_size-1]-set_data_buffer[0]) : 0;
  const size_t set_alloc_size =  layout::get_number_of_bytes(set_size,set_range)+100;
  uint8_t* set_data_in = (uint8_t*)data_allocator-&gt;get_next(NUM_THREADS,set_alloc_size);
  
  TrieBlock&lt;layout,A&gt;* tmp = TrieBlock&lt;layout,A&gt;::get_block(NUM_THREADS,offset,data_allocator);
  myset = tmp-&gt;get_set();
  myset-&gt;from_array(set_data_in,set_data_buffer,set_size);

  assert(set_alloc_size &gt;= myset-&gt;number_of_bytes);
  data_allocator-&gt;head-&gt;roll_back(set_alloc_size - myset-&gt;number_of_bytes);

  return offset;
}

size_t encode_tail(size_t start, size_t end, uint32_t *data, std::vector&lt;uint32_t&gt; *current, uint32_t *indicies){
  long prev_data = -1;
  size_t data_size = 0;
  for(size_t i = start; i &lt; end; i++){
    if(prev_data != (long)current-&gt;at(indicies[i])){
      *data++ = current-&gt;at(indicies[i]);
      prev_data = (long)current-&gt;at(indicies[i]);
      data_size++;
    }
  }
  return data_size;
}
/*
* Recursively build the trie. Terminates when we hit the number of levels.
*/
template&lt;class B, class M, class A&gt;
void recursive_build(
  const size_t index, 
  const size_t start, 
  const size_t end, 
  const uint32_t data, 
  const size_t prev_offset, 
  const size_t level, 
  const size_t num_levels, 
  const size_t tid, 
  std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *attr_in,
  M *data_allocator, 
  std::vector&lt;size_t*&gt; *ranges_buffer, 
  std::vector&lt;uint32_t*&gt; *set_data_buffer, 
  uint32_t *indicies,
  std::vector&lt;A&gt;* annotation){

  //NUM_THREADS*NUM_COLUMNS
  uint32_t *sb = set_data_buffer-&gt;at(tid*num_levels+level);
  size_t set_size = encode_tail(start,end,sb,&amp;attr_in-&gt;at(level),indicies);

  const size_t next_offset = build_block&lt;B,M&gt;(tid,data_allocator,set_size,sb);

  if(level == 1){
    //get the head
    B* prev_block = B::get_block(NUM_THREADS,prev_offset,data_allocator);
    prev_block-&gt;set_next_block(index,data,tid,next_offset);
  } else {
    B* prev_block = B::get_block(tid,prev_offset,data_allocator);
    prev_block-&gt;set_next_block(index,data,tid,next_offset);
  }

  if(level &lt; (num_levels-1)){
    B* tail = (B*)data_allocator-&gt;get_address(tid,next_offset);
    tail-&gt;init_next(tid,data_allocator);
    auto tup = produce_ranges(start,end,ranges_buffer-&gt;at(tid*num_levels+level),set_data_buffer-&gt;at(tid*num_levels+level),indicies,&amp;attr_in-&gt;at(level));
    const size_t set_size = std::get&lt;0&gt;(tup);
    for(size_t i = 0; i &lt; set_size; i++){
      const size_t next_start = ranges_buffer-&gt;at(tid*num_levels+level)[i];
      const size_t next_end = ranges_buffer-&gt;at(tid*num_levels+level)[i+1];
      const uint32_t next_data = set_data_buffer-&gt;at(tid*num_levels+level)[i];        
      recursive_build&lt;B,M,A&gt;(
        i,
        next_start,
        next_end,
        next_data,
        next_offset,
        level+1,
        num_levels,
        tid,
        attr_in,
        data_allocator,
        ranges_buffer,
        set_data_buffer,
        indicies,
        annotation);
    }
  } else if(annotation-&gt;size() != 0){
    B* tail = (B*)data_allocator-&gt;get_address(tid,next_offset);
    //perform allocation for annotation (0 = tid)
    //nextSize should gets the size of pointers or annotations (should be renamed?)
    data_allocator-&gt;get_next(tid,sizeof(A)*(tail-&gt;nextSize()));
    //could of realloced, get the head again
    tail = (B*)data_allocator-&gt;get_address(tid,next_offset);

    for(size_t i = start; i &lt; end; i++){
      uint32_t data_value = attr_in-&gt;at(level).at(indicies[i]);
      A annotationValue = annotation-&gt;at(indicies[i]);
      tail-&gt;template set_annotation(annotationValue,i-start,data_value);
    }
  }
}

//builds the trie from an encoded relation
template&lt;class A, class M&gt;
Trie&lt;A,M&gt;::Trie(
  std::string path,
  std::vector&lt;uint32_t&gt;* max_set_sizes, 
  std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *attr_in,
  std::vector&lt;A&gt;* annotations){

  annotation = (A)0;
  annotated = annotations-&gt;size() &gt; 0;
  num_rows = attr_in-&gt;at(0).size();
  num_columns = attr_in-&gt;size();
  //fixme: add estimate

  memoryBuffers = new M(path,2);  
  assert(num_columns != 0  &amp;&amp; num_rows != 0);

  //Setup indices buffer
  uint32_t *indicies = new uint32_t[num_rows];
  for(uint32_t i = 0; i &lt; num_rows; i++){
    indicies[i] = i;
  }

  //sort the relation
  tbb::task_scheduler_init init(NUM_THREADS);
  tbb::parallel_sort(indicies,indicies+num_rows,SortColumns(attr_in));

  //DEBUG
  /*
  std::cout &lt;&lt; &quot;TRIEE BUULd&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; num_columns &lt;&lt; std::endl;
  for(size_t i = 0; i &lt; num_rows; i++){
    for(size_t j = 0; j &lt; num_columns; j++){
      std::cout &lt;&lt; attr_in-&gt;at(j).at(indicies[i]) &lt;&lt; &quot;\t&quot;;
    }
    std::cout &lt;&lt; std::endl;
  }
  */
  
  //set up temporary buffers needed for the build
  std::vector&lt;size_t*&gt; *ranges_buffer = new std::vector&lt;size_t*&gt;();
  std::vector&lt;uint32_t*&gt; *set_data_buffer = new std::vector&lt;uint32_t*&gt;();

  size_t alloc_size = 0;
  for(size_t i = 0; i &lt; num_columns; i++){
    alloc_size += max_set_sizes-&gt;at(i)+1;
  }
  size_t* tmp_st = new size_t[alloc_size*NUM_THREADS];
  uint32_t* tmp_i = new uint32_t[alloc_size*NUM_THREADS];

  size_t index = 0;
  for(size_t t = 0; t &lt; NUM_THREADS; t++){
    for(size_t i = 0; i &lt; num_columns; i++){
      ranges_buffer-&gt;push_back(&amp;tmp_st[index]);
      set_data_buffer-&gt;push_back(&amp;tmp_i[index]); 
      index += max_set_sizes-&gt;at(i)+1;
    }
  }

  //Find the ranges for distinct values in the head
  auto tup = produce_ranges(0,
    num_rows,
    ranges_buffer-&gt;at(0),
    set_data_buffer-&gt;at(0),
    indicies,
    &amp;attr_in-&gt;at(0));
  const size_t head_size = std::get&lt;0&gt;(tup);
  
  //Build the head set.
  const size_t head_offset = 
    build_head&lt;TrieBlock&lt;layout,M&gt;,M&gt;(
      memoryBuffers,
      head_size,
      set_data_buffer-&gt;at(0));

  size_t cur_level = 1;
  if(num_columns &gt; 1){
    TrieBlock&lt;layout,M&gt;* new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
    new_head-&gt;init_next(NUM_THREADS,memoryBuffers);

    //encode the set, create a block with NULL pointers to next level
    //should be a 1-1 between pointers in block and next ranges
    //also a 1-1 between blocks and numbers of next ranges

    //reset new_head because a realloc could of occured
    new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
    const size_t loop_size = new_head-&gt;nextSize();
    par::for_range(0,loop_size,100,[&amp;](size_t tid, size_t i){
      (void) tid;
      new_head-&gt;getNext(i)-&gt;index = -1;
    });
    //reset new_head because a realloc could of occured
    par::for_range(0,head_size,100,[&amp;](size_t tid, size_t i){
      const size_t start = ranges_buffer-&gt;at(0)[i];
      const size_t end = ranges_buffer-&gt;at(0)[i+1];
      const uint32_t data = set_data_buffer-&gt;at(0)[i];
      recursive_build&lt;TrieBlock&lt;layout,M&gt;,M,A&gt;(
        i,
        start,
        end,
        data,
        head_offset,
        cur_level,
        num_columns,
        tid,
        attr_in,
        memoryBuffers,
        ranges_buffer,
        set_data_buffer,
        indicies,
        annotations);
    });
  } else if(annotations-&gt;size() &gt; 0){
    TrieBlock&lt;layout,M&gt;* new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
    //perform allocation for annotation (0 = tid)
    //nextSize should gets the size of pointers or annotations (should be renamed?)
    memoryBuffers-&gt;head-&gt;get_next(sizeof(A)*(new_head-&gt;nextSize()));
    //could of realloced, get the head again
    new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);

    for(size_t i = 0; i &lt; head_size; i++){
      const uint32_t data = set_data_buffer-&gt;at(0)[i]; 
      A annotationValue = annotations-&gt;at(indicies[i]);
      new_head-&gt;template set_annotation&lt;A&gt;(annotationValue,i,data);
    }
  }

  delete[] tmp_st;
  delete[] tmp_i;
  delete ranges_buffer;
  delete set_data_buffer;
}


template struct Trie&lt;void*,ParMemoryBuffer&gt;;
template struct Trie&lt;long,ParMemoryBuffer&gt;;
template struct Trie&lt;int,ParMemoryBuffer&gt;;
template struct Trie&lt;float,ParMemoryBuffer&gt;;
template struct Trie&lt;double,ParMemoryBuffer&gt;;

template struct Trie&lt;void*,ParMMapBuffer&gt;;
template struct Trie&lt;long,ParMMapBuffer&gt;;
template struct Trie&lt;int,ParMMapBuffer&gt;;
template struct Trie&lt;float,ParMMapBuffer&gt;;
template struct Trie&lt;double,ParMMapBuffer&gt;;
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>EncodedColumnStore.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
*
* Author: Christopher R. Aberger
*
* Stores a relation in a column wise fashion. Can take in any number of 
* different template arguments. Each template arguments corresponds to the
* type of the column. 
******************************************************************************/

#ifndef _ENCODED_COLUMN_STORE_H_
#define _ENCODED_COLUMN_STORE_H_

#include &quot;utils/common.hpp&quot;

struct EncodedColumnStore {
  size_t num_rows;
  size_t num_attributes;
  size_t num_annotations;

  std::vector&lt;uint32_t&gt; max_set_size;
  std::vector&lt;std::vector&lt;uint32_t&gt;&gt; data;

  std::vector&lt;size_t&gt; annotation_bytes;
  std::vector&lt;void*&gt; annotation;
  
  EncodedColumnStore(
    EncodedColumnStore * in,
    std::vector&lt;size_t&gt; order){
    num_rows = in-&gt;num_rows;
    num_attributes = in-&gt;num_attributes;
    num_annotations = in-&gt;num_annotations;

    //perform a reordering
    assert(order.size() == num_attributes);
    for(size_t i = 0; i &lt; num_attributes; i++){
      max_set_size.push_back(in-&gt;max_set_size.at(order.at(i)));
      data.push_back(in-&gt;data.at((order.at(i))));
    }

    annotation_bytes = in-&gt;annotation_bytes;
    annotation = in-&gt;annotation;
  }

  EncodedColumnStore(
    size_t num_rows_in,
    size_t num_attributes_in,
    size_t num_annotations_in){
    num_rows = num_rows_in;
    num_attributes = num_attributes_in;
    num_annotations = num_annotations_in;
  }

  EncodedColumnStore(
    size_t num_rows_in,
    size_t num_attributes_in,
    size_t num_annotations_in,
    std::vector&lt;uint32_t&gt; max_set_size_in,
    std::vector&lt;std::vector&lt;uint32_t&gt;&gt; data_in,
    std::vector&lt;size_t&gt; annotation_bytes_in,
    std::vector&lt;void*&gt; annotation_in){
    num_rows = num_rows_in;
    num_attributes = num_attributes_in;
    num_annotations = num_annotations_in;
    max_set_size = max_set_size_in;
    data = data_in;
    annotation_bytes = annotation_bytes_in;
    annotation = annotation_in;
  }

  std::vector&lt;uint32_t&gt;* column(const size_t i){
    return &amp;data.at(i);
  }

  void add_column(
    const std::vector&lt;uint32_t&gt; * const column_in,
    const uint32_t num_distinct){
    max_set_size.push_back(num_distinct);
    data.push_back(*column_in);
  }

  void add_annotation(
    const size_t num_bytes,
    void* annotation_in){
    annotation_bytes.push_back(num_bytes);
<A NAME="1"></A>    annotation.push_back(annotation_in);
  }

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#1',2,'match18-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  void to_binary(std::string path){
    std::ofstream *writefile = new std::ofstream();
    std::string file = path+std::string(&quot;encoded.bin&quot;);
    writefile-&gt;open(file, std::ios::binary | std::ios::out);</B></FONT>

    writefile-&gt;write((char *)&amp;num_rows, sizeof(num_rows));
    writefile-&gt;write((char *)&amp;num_attributes, sizeof(num_attributes));
    writefile-&gt;write((char *)&amp;num_annotations, sizeof(num_annotations));
    
    //write the data
    for(size_t i = 0; i &lt; data.size(); i++){
      const uint32_t mss = max_set_size.at(i);
      writefile-&gt;write((char *)&amp;mss, sizeof(mss));
      for(size_t j = 0; j &lt; num_rows; j++){
        writefile-&gt;write((char *)&amp;data.at(i).at(j), sizeof(data.at(i).at(j)));
      }
    }

    //write the annotation
    for(size_t i = 0; i &lt; num_annotations; i++){
      uint8_t* myanno = (uint8_t*)annotation.at(i);
      const size_t num_bytes = annotation_bytes.at(i);
      writefile-&gt;write((char *)&amp;num_bytes, sizeof(num_bytes));
      writefile-&gt;write((char *)myanno, (num_bytes*num_rows));
    }
<A NAME="0"></A>    writefile-&gt;close();
  }
  
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#0',2,'match18-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  static EncodedColumnStore* from_binary(std::string path){
    std::ifstream *infile = new std::ifstream();
    std::string file = path+std::string(&quot;encoded.bin&quot;);
    infile-&gt;open(file, std::ios::binary | std::ios::in);

    size_t num_rows_in;
    size_t num_attributes_in;
    size_t num_annotations_in;

    std::vector&lt;uint32_t&gt; max_set_size_in;</B></FONT>
    std::vector&lt;std::vector&lt;uint32_t&gt;&gt; data_in;

    std::vector&lt;size_t&gt; annotation_bytes_in;
    std::vector&lt;void*&gt; annotation_in;

    infile-&gt;read((char *)&amp;num_rows_in, sizeof(num_rows_in));
    infile-&gt;read((char *)&amp;num_attributes_in, sizeof(num_attributes_in));
    infile-&gt;read((char *)&amp;num_annotations_in, sizeof(num_annotations_in));

    max_set_size_in.resize(num_attributes_in);
    data_in.resize(num_attributes_in);

    annotation_bytes_in.resize(num_annotations_in);
    annotation_in.resize(num_annotations_in);

    for(size_t i = 0; i &lt; num_attributes_in; i++){
      uint32_t mss;
      infile-&gt;read((char *)&amp;mss, sizeof(mss));
      max_set_size_in.at(i) = mss;

      std::vector&lt;uint32_t&gt;* new_column = new std::vector&lt;uint32_t&gt;();
      new_column-&gt;resize(num_rows_in);
      for(size_t j = 0; j &lt; num_rows_in; j++){
        uint32_t value;
        infile-&gt;read((char *)&amp;value, sizeof(value));
        new_column-&gt;at(j) = value;
      }
      data_in.at(i) = *new_column;
    }

    //write the annotation
    for(size_t i = 0; i &lt; num_annotations_in; i++){
      size_t num_bytes;
      infile-&gt;read((char *)&amp;num_bytes, sizeof(num_bytes));

      annotation_bytes_in.at(i) = num_bytes;
      uint8_t* myanno = new uint8_t[num_bytes*num_rows_in];
      infile-&gt;read(
        (char*)myanno, 
        (num_bytes*num_rows_in));
      annotation_in.at(i) = ((void*)myanno);
    }

    infile-&gt;close();
    return new EncodedColumnStore(
      num_rows_in,
      num_attributes_in,
      num_annotations_in,
      max_set_size_in,
      data_in,
      annotation_bytes_in,
      annotation_in);
  }

};


#endif
</PRE>
</div>
  </div>
</body>
</html>
