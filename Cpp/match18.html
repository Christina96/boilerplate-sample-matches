<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Trie.cpp &amp; EncodedColumnStore.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Trie.cpp &amp; EncodedColumnStore.hpp
      </h3>
<h1 align="center">
        8.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Trie.cpp (5.3742805%)<th>EncodedColumnStore.hpp (16.470589%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(38-46)<td><a href="#" name="0">(116-125)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(16-19)<td><a href="#" name="1">(88-91)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Trie.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "tbb/parallel_sort.h"
2 #include "tbb/task_scheduler_init.h"
3 #include "Trie.hpp"
4 #include "trie/TrieBlock.hpp"
5 #include "utils/ParMMapBuffer.hpp"
6 <a name="1"></a>#include "utils/ParMemoryBuffer.hpp"
7 template&lt;class A,class M&gt;
8 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>void Trie&lt;A,M&gt;::save(){
9   std::ofstream *writefile = new std::ofstream();
10   std::string file = memoryBuffers-&gt;path+M::folder+std::string("trieinfo.bin");
11   writefile-&gt;open(file, std::ios::binary | std::ios::trunc);</b></font>
12   writefile-&gt;write((char *)&amp;annotated, sizeof(annotated));
13   writefile-&gt;write((char *)&amp;annotation, sizeof(annotation));
14   writefile-&gt;write((char *)&amp;num_rows, sizeof(num_rows));
15   writefile-&gt;write((char *)&amp;num_columns, sizeof(num_columns));
16   writefile-&gt;write((char *)&amp;memoryBuffers-&gt;num_buffers, sizeof(memoryBuffers-&gt;num_buffers));
17   const size_t h_size = memoryBuffers-&gt;head-&gt;getSize();
18   writefile-&gt;write((char *)&amp;h_size, sizeof(h_size));
19   for(size_t i = 0; i &lt; memoryBuffers-&gt;num_buffers; i++){
20     const size_t t_size = memoryBuffers-&gt;get_size(i);
21     writefile-&gt;write((char *)&amp;t_size, sizeof(t_size));
22   }
23   writefile-&gt;close();
24   memoryBuffers-&gt;save();
25 <a name="0"></a>}
26 template&lt;class A,class M&gt;
27 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Trie&lt;A,M&gt;* Trie&lt;A,M&gt;::load(std::string path){
28   bool annotated_in;
29   A annotation_in;
30   size_t num_rows;
31   size_t num_columns;
32   std::ifstream *infile = new std::ifstream();
33   std::string file = path+M::folder+std::string("trieinfo.bin");
34   infile-&gt;open(file, std::ios::binary | std::ios::in);</b></font>
35   infile-&gt;read((char *)&amp;annotated_in, sizeof(annotated_in));
36   infile-&gt;read((char *)&amp;annotation_in, sizeof(annotation_in));
37   infile-&gt;read((char *)&amp;num_rows, sizeof(num_rows));
38   infile-&gt;read((char *)&amp;num_columns, sizeof(num_columns));
39   size_t w_n_threads;
40   infile-&gt;read((char *)&amp;w_n_threads, sizeof(w_n_threads));
41   std::vector&lt;size_t&gt; buf_sizes;
42   size_t h_size;
43   infile-&gt;read((char *)&amp;h_size, sizeof(h_size));
44   buf_sizes.push_back(h_size);
45   for(size_t i = 0 ; i &lt; w_n_threads; i++){
46     size_t b_size;
47     infile-&gt;read((char *)&amp;b_size, sizeof(b_size));
48     buf_sizes.push_back(b_size);
49   }
50   infile-&gt;close();
51   M* memoryBuffers_in = M::load(path,w_n_threads,&amp;buf_sizes);
52   return new Trie&lt;A,M&gt;(
53     annotated_in,
54     annotation_in,
55     num_rows,
56     num_columns,
57     memoryBuffers_in);
58 }
59 template&lt;class A,class M&gt;
60 void recursive_foreach(
61   const bool annotated,
62   M* memoryBuffers,
63   TrieBlock&lt;layout,M&gt; *current, 
64   const size_t level, 
65   const size_t num_levels,
66   std::vector&lt;uint32_t&gt;* tuple,
67   const std::function&lt;void(std::vector&lt;uint32_t&gt;*,A)&gt; body){
68   if(level+1 == num_levels){
69     current-&gt;get_set()-&gt;foreach_index([&amp;](const uint32_t a_i, const uint32_t a_d){
70       tuple-&gt;push_back(a_d);
71       (void) a_i;
72       if(annotated){
73         const A annotation = current-&gt;template get_annotation&lt;A&gt;(a_i,a_d);
74         body(tuple,annotation);
75       } else{
76         body(tuple,(A)0);
77       } 
78       tuple-&gt;pop_back();
79     });
80   } else {
81     current-&gt;get_set()-&gt;foreach_index([&amp;](const uint32_t a_i, const uint32_t a_d){
82       tuple-&gt;push_back(a_d);
83       if(current-&gt;get_next_block(a_i,a_d,memoryBuffers) != NULL){
84         recursive_foreach&lt;A,M&gt;(
85           annotated,
86           memoryBuffers,
87           current-&gt;get_next_block(a_i,a_d,memoryBuffers),
88           level+1,
89           num_levels,
90           tuple,
91           body);
92       }
93       tuple-&gt;pop_back(); //delete the last element
94     });
95   }
96 }
97 template&lt;class A,class M&gt;
98 TrieBlock&lt;layout,M&gt;* Trie&lt;A,M&gt;::getHead(){
99   if(num_columns == 0)
100     return NULL;
101   TrieBlock&lt;layout,M&gt;* head = (TrieBlock&lt;layout,M&gt;*)(memoryBuffers-&gt;get_address(NUM_THREADS,0));
102   return head; 
103 }
104 template&lt;class A,class M&gt;
105 void Trie&lt;A,M&gt;::foreach(const std::function&lt;void(std::vector&lt;uint32_t&gt;*,A)&gt; body){
106   std::vector&lt;uint32_t&gt;* tuple = new std::vector&lt;uint32_t&gt;();
107   TrieBlock&lt;layout,M&gt;* head = this-&gt;getHead();
108   if(head != NULL &amp;&amp; head-&gt;get_set()-&gt;cardinality &gt; 0){
109     head-&gt;get_set()-&gt;foreach_index([&amp;](uint32_t a_i, uint32_t a_d){
110       tuple-&gt;push_back(a_d);
111       if(num_columns &gt; 1){
112         TrieBlock&lt;layout,M&gt;* next = head-&gt;get_next_block(a_i,a_d,memoryBuffers);
113         if(next != NULL){
114           recursive_foreach&lt;A,M&gt;(
115             annotated,
116             memoryBuffers,
117             next,
118             1,
119             num_columns,
120             tuple,
121             body);
122         }
123       } else if(annotated) {
124         const A annotationValue = head-&gt;template get_annotation&lt;A&gt;(a_i,a_d);
125         body(tuple,annotationValue);
126       } else if(num_columns == 1){
127         body(tuple,(A)0); 
128       }
129       tuple-&gt;pop_back(); //delete the last element
130     });
131   } else if(annotated){
132     body(tuple,(A)annotation); 
133   }
134 }
135 struct SortColumns{
136   std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *columns; 
137   SortColumns(std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *columns_in){
138     columns = columns_in;
139   }
140   bool operator()(uint32_t i, uint32_t j) const {
141     for(size_t c = 0; c &lt; columns-&gt;size(); c++){
142       if(columns-&gt;at(c).at(i) != columns-&gt;at(c).at(j)){
143         return columns-&gt;at(c).at(i) &lt; columns-&gt;at(c).at(j);
144       }
145     }
146     return false;
147   }
148 };
149 std::tuple&lt;size_t,size_t&gt; produce_ranges(
150   size_t start, 
151   size_t end, 
152   size_t *next_ranges, 
153   uint32_t *data,
154   uint32_t *indicies, 
155   std::vector&lt;uint32_t&gt; * current){
156   size_t range = 0;
157   size_t num_distinct = 0;
158   size_t i = start;
159   while(true){
160     const size_t start_range = i;
161     const uint32_t cur = current-&gt;at(indicies[i]);
162     uint32_t prev = cur;
163     next_ranges[num_distinct] = start_range;
164     data[num_distinct] = cur;
165     ++num_distinct;
166     range = cur;
167     while(cur == prev){
168       if((i+1) &gt;= end)
169         goto FINISH;
170       prev = current-&gt;at(indicies[++i]);
171     }
172   }
173   FINISH:
174   next_ranges[num_distinct] = end;
175   return std::tuple&lt;size_t,size_t&gt;(num_distinct,range+1);
176 }
177 template&lt;class B, class A&gt;
178 size_t build_block(
179   const size_t tid,  
180   A *data_allocator, 
181   const size_t set_size, 
182   uint32_t *set_data_buffer){
183   const uint8_t * const start_block = data_allocator-&gt;get_next(tid,sizeof(B));
184   const size_t offset = start_block-data_allocator-&gt;get_address(tid);
185   Set&lt;hybrid&gt;* myset = (Set&lt;hybrid&gt;*)(data_allocator-&gt;get_next(tid,sizeof(Set&lt;layout&gt;)));
186   const size_t set_range = (set_size &gt; 1) ? (set_data_buffer[set_size-1]-set_data_buffer[0]) : 0;
187   const size_t set_alloc_size =  layout::get_number_of_bytes(set_size,set_range)*2+100;
188   uint8_t* set_data_in = data_allocator-&gt;get_next(tid,set_alloc_size);
189   TrieBlock&lt;layout,A&gt;* tmp = TrieBlock&lt;layout,A&gt;::get_block(tid,offset,data_allocator);
190   myset = tmp-&gt;get_set();
191   myset-&gt;from_array(set_data_in,set_data_buffer,set_size);
192   size_t check_index = 0;
193   myset-&gt;foreach_index([&amp;](uint32_t index, uint32_t data){
194     (void) data; (void) index;
195     assert(data == set_data_buffer[index]);
196     check_index++;
197   });
198   assert(check_index == set_size);
199   assert(set_alloc_size &gt;= myset-&gt;number_of_bytes);
200   data_allocator-&gt;roll_back(tid,set_alloc_size-myset-&gt;number_of_bytes);
201   return offset;
202 }
203 template&lt;class B, class A&gt;
204 size_t build_head(
205   A *data_allocator, 
206   const size_t set_size, 
207   uint32_t *set_data_buffer){
208   const uint8_t * const start_block = (uint8_t*) (data_allocator-&gt;get_next(NUM_THREADS,sizeof(B)));
209   const size_t offset = start_block-((uint8_t*)data_allocator-&gt;get_address(NUM_THREADS));
210   Set&lt;layout&gt;* myset = (Set&lt;layout&gt;*)(data_allocator-&gt;get_next(NUM_THREADS,sizeof(Set&lt;layout&gt;)));
211   const size_t set_range = (set_size &gt; 1) ? (set_data_buffer[set_size-1]-set_data_buffer[0]) : 0;
212   const size_t set_alloc_size =  layout::get_number_of_bytes(set_size,set_range)+100;
213   uint8_t* set_data_in = (uint8_t*)data_allocator-&gt;get_next(NUM_THREADS,set_alloc_size);
214   TrieBlock&lt;layout,A&gt;* tmp = TrieBlock&lt;layout,A&gt;::get_block(NUM_THREADS,offset,data_allocator);
215   myset = tmp-&gt;get_set();
216   myset-&gt;from_array(set_data_in,set_data_buffer,set_size);
217   assert(set_alloc_size &gt;= myset-&gt;number_of_bytes);
218   data_allocator-&gt;head-&gt;roll_back(set_alloc_size - myset-&gt;number_of_bytes);
219   return offset;
220 }
221 size_t encode_tail(size_t start, size_t end, uint32_t *data, std::vector&lt;uint32_t&gt; *current, uint32_t *indicies){
222   long prev_data = -1;
223   size_t data_size = 0;
224   for(size_t i = start; i &lt; end; i++){
225     if(prev_data != (long)current-&gt;at(indicies[i])){
226       *data++ = current-&gt;at(indicies[i]);
227       prev_data = (long)current-&gt;at(indicies[i]);
228       data_size++;
229     }
230   }
231   return data_size;
232 }
233 template&lt;class B, class M, class A&gt;
234 void recursive_build(
235   const size_t index, 
236   const size_t start, 
237   const size_t end, 
238   const uint32_t data, 
239   const size_t prev_offset, 
240   const size_t level, 
241   const size_t num_levels, 
242   const size_t tid, 
243   std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *attr_in,
244   M *data_allocator, 
245   std::vector&lt;size_t*&gt; *ranges_buffer, 
246   std::vector&lt;uint32_t*&gt; *set_data_buffer, 
247   uint32_t *indicies,
248   std::vector&lt;A&gt;* annotation){
249   uint32_t *sb = set_data_buffer-&gt;at(tid*num_levels+level);
250   size_t set_size = encode_tail(start,end,sb,&amp;attr_in-&gt;at(level),indicies);
251   const size_t next_offset = build_block&lt;B,M&gt;(tid,data_allocator,set_size,sb);
252   if(level == 1){
253     B* prev_block = B::get_block(NUM_THREADS,prev_offset,data_allocator);
254     prev_block-&gt;set_next_block(index,data,tid,next_offset);
255   } else {
256     B* prev_block = B::get_block(tid,prev_offset,data_allocator);
257     prev_block-&gt;set_next_block(index,data,tid,next_offset);
258   }
259   if(level &lt; (num_levels-1)){
260     B* tail = (B*)data_allocator-&gt;get_address(tid,next_offset);
261     tail-&gt;init_next(tid,data_allocator);
262     auto tup = produce_ranges(start,end,ranges_buffer-&gt;at(tid*num_levels+level),set_data_buffer-&gt;at(tid*num_levels+level),indicies,&amp;attr_in-&gt;at(level));
263     const size_t set_size = std::get&lt;0&gt;(tup);
264     for(size_t i = 0; i &lt; set_size; i++){
265       const size_t next_start = ranges_buffer-&gt;at(tid*num_levels+level)[i];
266       const size_t next_end = ranges_buffer-&gt;at(tid*num_levels+level)[i+1];
267       const uint32_t next_data = set_data_buffer-&gt;at(tid*num_levels+level)[i];        
268       recursive_build&lt;B,M,A&gt;(
269         i,
270         next_start,
271         next_end,
272         next_data,
273         next_offset,
274         level+1,
275         num_levels,
276         tid,
277         attr_in,
278         data_allocator,
279         ranges_buffer,
280         set_data_buffer,
281         indicies,
282         annotation);
283     }
284   } else if(annotation-&gt;size() != 0){
285     B* tail = (B*)data_allocator-&gt;get_address(tid,next_offset);
286     data_allocator-&gt;get_next(tid,sizeof(A)*(tail-&gt;nextSize()));
287     tail = (B*)data_allocator-&gt;get_address(tid,next_offset);
288     for(size_t i = start; i &lt; end; i++){
289       uint32_t data_value = attr_in-&gt;at(level).at(indicies[i]);
290       A annotationValue = annotation-&gt;at(indicies[i]);
291       tail-&gt;template set_annotation(annotationValue,i-start,data_value);
292     }
293   }
294 }
295 template&lt;class A, class M&gt;
296 Trie&lt;A,M&gt;::Trie(
297   std::string path,
298   std::vector&lt;uint32_t&gt;* max_set_sizes, 
299   std::vector&lt;std::vector&lt;uint32_t&gt;&gt; *attr_in,
300   std::vector&lt;A&gt;* annotations){
301   annotation = (A)0;
302   annotated = annotations-&gt;size() &gt; 0;
303   num_rows = attr_in-&gt;at(0).size();
304   num_columns = attr_in-&gt;size();
305   memoryBuffers = new M(path,2);  
306   assert(num_columns != 0  &amp;&amp; num_rows != 0);
307   uint32_t *indicies = new uint32_t[num_rows];
308   for(uint32_t i = 0; i &lt; num_rows; i++){
309     indicies[i] = i;
310   }
311   tbb::task_scheduler_init init(NUM_THREADS);
312   tbb::parallel_sort(indicies,indicies+num_rows,SortColumns(attr_in));
313   std::vector&lt;size_t*&gt; *ranges_buffer = new std::vector&lt;size_t*&gt;();
314   std::vector&lt;uint32_t*&gt; *set_data_buffer = new std::vector&lt;uint32_t*&gt;();
315   size_t alloc_size = 0;
316   for(size_t i = 0; i &lt; num_columns; i++){
317     alloc_size += max_set_sizes-&gt;at(i)+1;
318   }
319   size_t* tmp_st = new size_t[alloc_size*NUM_THREADS];
320   uint32_t* tmp_i = new uint32_t[alloc_size*NUM_THREADS];
321   size_t index = 0;
322   for(size_t t = 0; t &lt; NUM_THREADS; t++){
323     for(size_t i = 0; i &lt; num_columns; i++){
324       ranges_buffer-&gt;push_back(&amp;tmp_st[index]);
325       set_data_buffer-&gt;push_back(&amp;tmp_i[index]); 
326       index += max_set_sizes-&gt;at(i)+1;
327     }
328   }
329   auto tup = produce_ranges(0,
330     num_rows,
331     ranges_buffer-&gt;at(0),
332     set_data_buffer-&gt;at(0),
333     indicies,
334     &amp;attr_in-&gt;at(0));
335   const size_t head_size = std::get&lt;0&gt;(tup);
336   const size_t head_offset = 
337     build_head&lt;TrieBlock&lt;layout,M&gt;,M&gt;(
338       memoryBuffers,
339       head_size,
340       set_data_buffer-&gt;at(0));
341   size_t cur_level = 1;
342   if(num_columns &gt; 1){
343     TrieBlock&lt;layout,M&gt;* new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
344     new_head-&gt;init_next(NUM_THREADS,memoryBuffers);
345     new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
346     const size_t loop_size = new_head-&gt;nextSize();
347     par::for_range(0,loop_size,100,[&amp;](size_t tid, size_t i){
348       (void) tid;
349       new_head-&gt;getNext(i)-&gt;index = -1;
350     });
351     par::for_range(0,head_size,100,[&amp;](size_t tid, size_t i){
352       const size_t start = ranges_buffer-&gt;at(0)[i];
353       const size_t end = ranges_buffer-&gt;at(0)[i+1];
354       const uint32_t data = set_data_buffer-&gt;at(0)[i];
355       recursive_build&lt;TrieBlock&lt;layout,M&gt;,M,A&gt;(
356         i,
357         start,
358         end,
359         data,
360         head_offset,
361         cur_level,
362         num_columns,
363         tid,
364         attr_in,
365         memoryBuffers,
366         ranges_buffer,
367         set_data_buffer,
368         indicies,
369         annotations);
370     });
371   } else if(annotations-&gt;size() &gt; 0){
372     TrieBlock&lt;layout,M&gt;* new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
373     memoryBuffers-&gt;head-&gt;get_next(sizeof(A)*(new_head-&gt;nextSize()));
374     new_head = (TrieBlock&lt;layout,M&gt;*)memoryBuffers-&gt;head-&gt;get_address(head_offset);
375     for(size_t i = 0; i &lt; head_size; i++){
376       const uint32_t data = set_data_buffer-&gt;at(0)[i]; 
377       A annotationValue = annotations-&gt;at(indicies[i]);
378       new_head-&gt;template set_annotation&lt;A&gt;(annotationValue,i,data);
379     }
380   }
381   delete[] tmp_st;
382   delete[] tmp_i;
383   delete ranges_buffer;
384   delete set_data_buffer;
385 }
386 template struct Trie&lt;void*,ParMemoryBuffer&gt;;
387 template struct Trie&lt;long,ParMemoryBuffer&gt;;
388 template struct Trie&lt;int,ParMemoryBuffer&gt;;
389 template struct Trie&lt;float,ParMemoryBuffer&gt;;
390 template struct Trie&lt;double,ParMemoryBuffer&gt;;
391 template struct Trie&lt;void*,ParMMapBuffer&gt;;
392 template struct Trie&lt;long,ParMMapBuffer&gt;;
393 template struct Trie&lt;int,ParMMapBuffer&gt;;
394 template struct Trie&lt;float,ParMMapBuffer&gt;;
395 template struct Trie&lt;double,ParMMapBuffer&gt;;
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>EncodedColumnStore.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef _ENCODED_COLUMN_STORE_H_
2 #define _ENCODED_COLUMN_STORE_H_
3 #include "utils/common.hpp"
4 struct EncodedColumnStore {
5   size_t num_rows;
6   size_t num_attributes;
7   size_t num_annotations;
8   std::vector&lt;uint32_t&gt; max_set_size;
9   std::vector&lt;std::vector&lt;uint32_t&gt;&gt; data;
10   std::vector&lt;size_t&gt; annotation_bytes;
11   std::vector&lt;void*&gt; annotation;
12   EncodedColumnStore(
13     EncodedColumnStore * in,
14     std::vector&lt;size_t&gt; order){
15     num_rows = in-&gt;num_rows;
16     num_attributes = in-&gt;num_attributes;
17     num_annotations = in-&gt;num_annotations;
18     assert(order.size() == num_attributes);
19     for(size_t i = 0; i &lt; num_attributes; i++){
20       max_set_size.push_back(in-&gt;max_set_size.at(order.at(i)));
21       data.push_back(in-&gt;data.at((order.at(i))));
22     }
23     annotation_bytes = in-&gt;annotation_bytes;
24     annotation = in-&gt;annotation;
25   }
26   EncodedColumnStore(
27     size_t num_rows_in,
28     size_t num_attributes_in,
29     size_t num_annotations_in){
30     num_rows = num_rows_in;
31     num_attributes = num_attributes_in;
32     num_annotations = num_annotations_in;
33   }
34   EncodedColumnStore(
35     size_t num_rows_in,
36     size_t num_attributes_in,
37     size_t num_annotations_in,
38     std::vector&lt;uint32_t&gt; max_set_size_in,
39     std::vector&lt;std::vector&lt;uint32_t&gt;&gt; data_in,
40     std::vector&lt;size_t&gt; annotation_bytes_in,
41     std::vector&lt;void*&gt; annotation_in){
42     num_rows = num_rows_in;
43     num_attributes = num_attributes_in;
44     num_annotations = num_annotations_in;
45     max_set_size = max_set_size_in;
46     data = data_in;
47     annotation_bytes = annotation_bytes_in;
48     annotation = annotation_in;
49   }
50   std::vector&lt;uint32_t&gt;* column(const size_t i){
51     return &amp;data.at(i);
52   }
53   void add_column(
54     const std::vector&lt;uint32_t&gt; * const column_in,
55     const uint32_t num_distinct){
56     max_set_size.push_back(num_distinct);
57     data.push_back(*column_in);
58   }
59   void add_annotation(
60     const size_t num_bytes,
61     void* annotation_in){
62     annotation_bytes.push_back(num_bytes);
63 <a name="1"></a>    annotation.push_back(annotation_in);
64   }
65 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  void to_binary(std::string path){
66     std::ofstream *writefile = new std::ofstream();
67     std::string file = path+std::string("encoded.bin");
68     writefile-&gt;open(file, std::ios::binary | std::ios::out);</b></font>
69     writefile-&gt;write((char *)&amp;num_rows, sizeof(num_rows));
70     writefile-&gt;write((char *)&amp;num_attributes, sizeof(num_attributes));
71     writefile-&gt;write((char *)&amp;num_annotations, sizeof(num_annotations));
72     for(size_t i = 0; i &lt; data.size(); i++){
73       const uint32_t mss = max_set_size.at(i);
74       writefile-&gt;write((char *)&amp;mss, sizeof(mss));
75       for(size_t j = 0; j &lt; num_rows; j++){
76         writefile-&gt;write((char *)&amp;data.at(i).at(j), sizeof(data.at(i).at(j)));
77       }
78     }
79     for(size_t i = 0; i &lt; num_annotations; i++){
80       uint8_t* myanno = (uint8_t*)annotation.at(i);
81       const size_t num_bytes = annotation_bytes.at(i);
82       writefile-&gt;write((char *)&amp;num_bytes, sizeof(num_bytes));
83       writefile-&gt;write((char *)myanno, (num_bytes*num_rows));
84     }
85 <a name="0"></a>    writefile-&gt;close();
86   }
87 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  static EncodedColumnStore* from_binary(std::string path){
88     std::ifstream *infile = new std::ifstream();
89     std::string file = path+std::string("encoded.bin");
90     infile-&gt;open(file, std::ios::binary | std::ios::in);
91     size_t num_rows_in;
92     size_t num_attributes_in;
93     size_t num_annotations_in;
94     std::vector&lt;uint32_t&gt; max_set_size_in;</b></font>
95     std::vector&lt;std::vector&lt;uint32_t&gt;&gt; data_in;
96     std::vector&lt;size_t&gt; annotation_bytes_in;
97     std::vector&lt;void*&gt; annotation_in;
98     infile-&gt;read((char *)&amp;num_rows_in, sizeof(num_rows_in));
99     infile-&gt;read((char *)&amp;num_attributes_in, sizeof(num_attributes_in));
100     infile-&gt;read((char *)&amp;num_annotations_in, sizeof(num_annotations_in));
101     max_set_size_in.resize(num_attributes_in);
102     data_in.resize(num_attributes_in);
103     annotation_bytes_in.resize(num_annotations_in);
104     annotation_in.resize(num_annotations_in);
105     for(size_t i = 0; i &lt; num_attributes_in; i++){
106       uint32_t mss;
107       infile-&gt;read((char *)&amp;mss, sizeof(mss));
108       max_set_size_in.at(i) = mss;
109       std::vector&lt;uint32_t&gt;* new_column = new std::vector&lt;uint32_t&gt;();
110       new_column-&gt;resize(num_rows_in);
111       for(size_t j = 0; j &lt; num_rows_in; j++){
112         uint32_t value;
113         infile-&gt;read((char *)&amp;value, sizeof(value));
114         new_column-&gt;at(j) = value;
115       }
116       data_in.at(i) = *new_column;
117     }
118     for(size_t i = 0; i &lt; num_annotations_in; i++){
119       size_t num_bytes;
120       infile-&gt;read((char *)&amp;num_bytes, sizeof(num_bytes));
121       annotation_bytes_in.at(i) = num_bytes;
122       uint8_t* myanno = new uint8_t[num_bytes*num_rows_in];
123       infile-&gt;read(
124         (char*)myanno, 
125         (num_bytes*num_rows_in));
126       annotation_in.at(i) = ((void*)myanno);
127     }
128     infile-&gt;close();
129     return new EncodedColumnStore(
130       num_rows_in,
131       num_attributes_in,
132       num_annotations_in,
133       max_set_size_in,
134       data_in,
135       annotation_bytes_in,
136       annotation_in);
137   }
138 };
139 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
