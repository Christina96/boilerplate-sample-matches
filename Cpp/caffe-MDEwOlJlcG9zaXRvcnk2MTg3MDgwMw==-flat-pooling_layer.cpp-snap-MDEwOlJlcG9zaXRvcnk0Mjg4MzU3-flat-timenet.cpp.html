
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.653457339264053%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-pooling_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cfloat>
3  #include <vector>
4  #include "caffe/common.hpp"
5  #include "caffe/layer.hpp"
6  #include "caffe/syncedmem.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #include "caffe/layers/pooling_layer.hpp"
9  namespace caffe {
10  using std::min;
11  using std::max;
12  template <typename Dtype>
13  void PoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
14        const vector<Blob<Dtype>*>& top) {
15    PoolingParameter pool_param = this->layer_param_.pooling_param();
16    channel_axis_ = bottom[0]->CanonicalAxisIndex(pool_param.axis());
17    channels_ = bottom[0]->shape(channel_axis_);
18    const int first_spatial_axis = channel_axis_ + 1;
19    const int num_axes = bottom[0]->num_axes();
20    num_spatial_axes_ = num_axes - first_spatial_axis;
21    CHECK_GE(num_spatial_axes_, 1);
22    if (num_spatial_axes_ == 2) {
23        if (pool_param.global_pooling()) {
24          CHECK(!(pool_param.has_kernel_size() ||
25            pool_param.has_kernel_h() || pool_param.has_kernel_w()))
26            << "With Global_pooling: true Filter size cannot specified";
27        } else {
28          CHECK(!pool_param.has_kernel_size() !=
29            !(pool_param.has_kernel_h() && pool_param.has_kernel_w()))
30            << "Filter size is kernel_size OR kernel_h and kernel_w; not both";
31          CHECK(pool_param.has_kernel_size() ||
32            (pool_param.has_kernel_h() && pool_param.has_kernel_w()))
33            << "For non-square filters both kernel_h and kernel_w are required.";
34        }
35        CHECK((!pool_param.has_pad() && pool_param.has_pad_h()
36            && pool_param.has_pad_w())
37            || (!pool_param.has_pad_h() && !pool_param.has_pad_w()))
38            << "pad is pad OR pad_h and pad_w are required.";
39        CHECK((!pool_param.has_stride() && pool_param.has_stride_h()
40            && pool_param.has_stride_w())
41            || (!pool_param.has_stride_h() && !pool_param.has_stride_w()))
42            << "Stride is stride OR stride_h and stride_w are required.";
43        global_pooling_ = pool_param.global_pooling();
44        if (global_pooling_) {
45          kernel_h_ = bottom[0]->height();
46          kernel_w_ = bottom[0]->width();
47        } else {
48          if (pool_param.has_kernel_size()) {
49            kernel_h_ = kernel_w_ = pool_param.kernel_size();
50          } else {
51            kernel_h_ = pool_param.kernel_h();
52            kernel_w_ = pool_param.kernel_w();
53          }
54        }
55        CHECK_GT(kernel_h_, 0) << "Filter dimensions cannot be zero.";
56        CHECK_GT(kernel_w_, 0) << "Filter dimensions cannot be zero.";
57        if (!pool_param.has_pad_h()) {
58          pad_h_ = pad_w_ = pool_param.pad();
59        } else {
60          pad_h_ = pool_param.pad_h();
61          pad_w_ = pool_param.pad_w();
62        }
63        if (!pool_param.has_stride_h()) {
64          stride_h_ = stride_w_ = pool_param.stride();
65        } else {
66          stride_h_ = pool_param.stride_h();
67          stride_w_ = pool_param.stride_w();
68        }
69        if (global_pooling_) {
70          CHECK(pad_h_ == 0 && pad_w_ == 0 && stride_h_ == 1 && stride_w_ == 1)
71            << "With Global_pooling: true; only pad = 0 and stride = 1";
72        }
73        if (pad_h_ != 0 || pad_w_ != 0) {
74          CHECK(this->layer_param_.pooling_param().pool()
75              == PoolingParameter_PoolMethod_AVE
76              || this->layer_param_.pooling_param().pool()
77              == PoolingParameter_PoolMethod_MAX)
78              << "Padding implemented only for average and max pooling.";
79          CHECK_LT(pad_h_, kernel_h_);
80          CHECK_LT(pad_w_, kernel_w_);
81        }
82      } else if (num_spatial_axes_ == 3) {
83        vector<int> bottom_dim_blob_shape(1, num_spatial_axes_ + 1);
84        input_shape_.Reshape(bottom_dim_blob_shape);
85        int* input_shape_data = input_shape_.mutable_cpu_data();
86        for (int i = 0; i < num_spatial_axes_ + 1; ++i) {
87          input_shape_data[i] = bottom[0]->shape(channel_axis_ + i);
88        }
89        vector<int> spatial_dim_blob_shape(1, num_spatial_axes_);
90        global_pooling_ = pool_param.global_pooling();
91        kernel_shape_.Reshape(spatial_dim_blob_shape);
92        int* kernel_shape_data = kernel_shape_.mutable_cpu_data();
93        if (global_pooling_) {
94          CHECK_GE(0, pool_param.kernel_size_3d_size())
95              << "With Global_pooling: true Filter size cannot specified.";
96          CHECK(!pool_param.has_kernel_h() || !pool_param.has_kernel_w())
97              << "With Global_pooling: true Filter size cannot specified.";
98          for (int i = 0; i < num_spatial_axes_ + 1; ++i) {
99            kernel_shape_data[i] = bottom[0]->shape(channel_axis_ + i);
100          }
101        } else {
102          if (pool_param.has_kernel_h() || pool_param.has_kernel_w()) {
103              CHECK_EQ(num_spatial_axes_, 2)
104                << "kernel_h & kernel_w can only be used for 2D pooling.";
105              CHECK_EQ(0, pool_param.kernel_size_3d_size())
106                << "Either kernel_size or kernel_h/w should be specified, not both.";
107              kernel_shape_data[0] = pool_param.kernel_h();
108              kernel_shape_data[1] = pool_param.kernel_w();
109          } else {
110              const int num_kernel_dims = pool_param.kernel_size_3d_size();
111              CHECK(num_kernel_dims == 1 || num_kernel_dims == num_spatial_axes_)
112                << "kernel_size must be specified once, or once per spatial dimension"
113                << " (kernel_size specified " << num_kernel_dims << " times "
114                << num_spatial_axes_ << " spatial dims).";
115              for (int i = 0; i < num_spatial_axes_; ++i) {
116                  kernel_shape_data[i] = pool_param.kernel_size_3d((num_kernel_dims == 1) ? 0 : i);
117              }
118          }
119        }
120        for (int i = 0; i < num_spatial_axes_; ++i) {
121            CHECK_GT(kernel_shape_data[i], 0) << "Filter dimensions must be nonzero.";
122        }
123        pad_.Reshape(spatial_dim_blob_shape);
124        int* pad_data = pad_.mutable_cpu_data();
125        int pad_sum = 0;
126        if (pool_param.has_pad_h() || pool_param.has_pad_w()) {
127            CHECK_EQ(num_spatial_axes_, 2)
128              << "pad_h & pad_w can only be used for 2D convolution.";
129            CHECK_EQ(0, pool_param.pad_3d_size())
130              << "Either pad or pad_h/w should be specified, not both.";
131            pad_data[0] = pool_param.pad_h();
132            pad_data[1] = pool_param.pad_w();
133        } else {
134          const int num_pad_dims = pool_param.pad_3d_size();
135          CHECK(num_pad_dims == 0 || num_pad_dims == 1 ||
136                num_pad_dims == num_spatial_axes_)
137              << "pad must be specified once, or once per spatial dimension "
138              << "(pad specified " << num_pad_dims << " times "
139              << num_spatial_axes_ << " spatial dims).";
140          const int kDefaultPad = 0;
141          for (int i = 0; i < num_spatial_axes_; ++i) {
142            pad_data[i] = (num_pad_dims == 0) ? kDefaultPad :
143                pool_param.pad_3d((num_pad_dims == 1) ? 0 : i);
144            if (global_pooling_) {
145                CHECK_EQ(pad_data[i], 0)
146                  << "With Global_pooling: true; pool = 0";
147              }
148            CHECK_LT(pad_data[i], kernel_shape_data[i]);
149            pad_sum += pad_data[i];
150          }
151        }
152        if (pad_sum != 0) {
153           CHECK(this->layer_param_.pooling_param().pool() ==
154            PoolingParameter_PoolMethod_AVE
155            || this->layer_param_.pooling_param().pool() ==
156            PoolingParameter_PoolMethod_MAX)
157              << "Padding implemented only for average and max pooling.";
158        }
159        stride_.Reshape(spatial_dim_blob_shape);
160        int* stride_data = stride_.mutable_cpu_data();
161        if (pool_param.has_stride_h() || pool_param.has_stride_w()) {
162          CHECK_EQ(num_spatial_axes_, 2)
163              << "stride_h & stride_w can only be used for 2D convolution.";
164          CHECK_EQ(0, pool_param.stride_3d_size())
165              << "Either stride or stride_h/w should be specified, not both.";
166          stride_data[0] = pool_param.stride_h();
167          stride_data[1] = pool_param.stride_w();
168        } else {
169          const int num_stride_dims = pool_param.stride_3d_size();
170          CHECK(num_stride_dims == 0 || num_stride_dims == 1 ||
171                num_stride_dims == num_spatial_axes_)
172              << "stride must be specified once, or once per spatial dimension "
173              << "(stride specified " << num_stride_dims << " times "
174              << num_spatial_axes_ << " spatial dims).";
175          const int kDefaultStride = 1;
176          for (int i = 0; i < num_spatial_axes_; ++i) {
177            stride_data[i] = (num_stride_dims == 0) ? kDefaultStride :
178                pool_param.stride_3d((num_stride_dims == 1) ? 0 : i);
179            CHECK_GT(stride_data[i], 0) << "Stride dimensions must be nonzero.";
180            if (global_pooling_) {
181              CHECK_EQ(stride_data[i], 1)
182                << "With Global_pooling: true; stride = 1";
183            }
184          }
185        }
186      } else {
187        NOT_IMPLEMENTED;
188      }
189  }
190  template <typename Dtype>
191  void PoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
192        const vector<Blob<Dtype>*>& top) {
193    PoolingParameter pool_param = this->layer_param_.pooling_param();
194    channel_axis_ = bottom[0]->CanonicalAxisIndex(pool_param.axis());
195    num_ = bottom[0]->count(0, channel_axis_);
196    const int first_spatial_axis = channel_axis_ + 1;
197    const int num_axes = bottom[0]->num_axes();
198    num_spatial_axes_ = num_axes - first_spatial_axis;
199    CHECK_GE(num_spatial_axes_, 1);
200    if (num_spatial_axes_ == 2) {
201        CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
202            << "corresponding to (num, channels, height, width).";
203        channels_ = bottom[0]->channels();
204        height_ = bottom[0]->height();
205        width_ = bottom[0]->width();
206        if (global_pooling_) {
207          kernel_h_ = bottom[0]->height();
208          kernel_w_ = bottom[0]->width();
209        }
210        pooled_height_ = static_cast<int>(ceil(static_cast<float>(
211            height_ + 2 * pad_h_ - kernel_h_) / stride_h_)) + 1;
212        pooled_width_ = static_cast<int>(ceil(static_cast<float>(
213            width_ + 2 * pad_w_ - kernel_w_) / stride_w_)) + 1;
214        if (pad_h_ || pad_w_ || kernel_h_ == 1 || kernel_w_ == 1) {
215          if ((pooled_height_ - 1) * stride_h_ >= height_ + pad_h_) {
216            --pooled_height_;
217          }
218          if ((pooled_width_ - 1) * stride_w_ >= width_ + pad_w_) {
219            --pooled_width_;
220          }
221          CHECK_LT((pooled_height_ - 1) * stride_h_, height_ + pad_h_);
222          CHECK_LT((pooled_width_ - 1) * stride_w_, width_ + pad_w_);
223        }
224        top[0]->Reshape(bottom[0]->num(), channels_, pooled_height_,
225            pooled_width_);
226        if (top.size() > 1) {
227          top[1]->ReshapeLike(*top[0]);
228        }
229        if (this->layer_param_.pooling_param().pool() ==
230            PoolingParameter_PoolMethod_MAX && top.size() == 1) {
231          max_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_,
232              pooled_width_);
233        }
234        if (this->layer_param_.pooling_param().pool() ==
235            PoolingParameter_PoolMethod_STOCHASTIC) {
236          rand_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_, pooled_width_);
237        }
238    } else if (num_spatial_axes_ == 3) {
239        int* kernel_shape_data = kernel_shape_.mutable_cpu_data();
240        const int* input_shape_data = this->input_shape_.cpu_data();
241        if (global_pooling_) {
242          for (int i = 0; i < num_spatial_axes_; ++i) {
243            kernel_shape_data[i] = input_shape_data[i+1];
244          }
245        }
246        const int* pad_data = this->pad_.cpu_data();
247        const int* stride_data = this->stride_.cpu_data();
248        vector<int> spatial_dim_blob_shape(1, num_spatial_axes_);
249        output_shape_.Reshape(spatial_dim_blob_shape);
250        int* output_shape_data = output_shape_.mutable_cpu_data();
251        int pad_sum = 0;
252        for (int i = 0; i < num_spatial_axes_; ++i) {
253          int oc = static_cast<int>(ceil(static_cast<float>(
254                input_shape_data[i+1] + 2 * pad_data[i]
255                - kernel_shape_data[i]) / stride_data[i])) + 1;
256          pad_sum += pad_data[i];
257          output_shape_data[i] = oc;
258        }
259        if (pad_sum) {
260          for (int i = 0; i < num_spatial_axes_; ++i) {
261              if ((output_shape_data[i] - 1) * stride_data[i] >=
262                input_shape_data[i+1] + pad_data[i])
263                  --output_shape_data[i];
264              CHECK_LT((output_shape_data[i] - 1) * stride_data[i],
265                input_shape_data[i+1] + pad_data[i]);
266          }
267        }
268        vector<int> top_shape = bottom[0]->shape();
269        top_shape.resize(first_spatial_axis);
270        for (int i = 0; i < num_spatial_axes_; ++i) {
271            top_shape.push_back(output_shape_data[i]);
272        }
273        top[0]->Reshape(top_shape);
274        if (top.size() > 1) {
275          top[1]->ReshapeLike(*top[0]);
276        }
277        if (this->layer_param_.pooling_param().pool() ==
278            PoolingParameter_PoolMethod_MAX && top.size() == 1) {
279          max_idx_.Reshape(top_shape);
280        }
281        if (this->layer_param_.pooling_param().pool() ==
282            PoolingParameter_PoolMethod_STOCHASTIC) {
283          rand_idx_.Reshape(top_shape);
284        }
285    } else {
286      NOT_IMPLEMENTED;
287    }
288  }
289  template <typename Dtype>
290  void PoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
291        const vector<Blob<Dtype>*>& top) {
292    const Dtype* bottom_data = bottom[0]->cpu_data();
293    Dtype* top_data = top[0]->mutable_cpu_data();
294    const int top_count = top[0]->count();
295    const bool use_top_mask = top.size() > 1;
296    if (num_spatial_axes_ == 2) {
297        typename PoolingCodeGeneratorForward<Dtype>::Callback_t* generator_func =
298                 Forward_code_generator.Get_callback(this, top[0], use_top_mask);
299        void* mask = NULL;
300        if (this->layer_param_.pooling_param().pool() ==
301            PoolingParameter_PoolMethod_MAX ) {
302          mask = (use_top_mask) ? static_cast<void*>(top[1]->mutable_cpu_data()) :
303                                  static_cast<void*>(max_idx_.mutable_cpu_data());
304        }
305        const int batch_size = bottom[0]->num();
306        const int num_channels = bottom[0]->channels();
307  #ifdef _OPENMP
308    #if defined(_MSC_EXTENSIONS)
309      #pragma omp parallel for
310    #else
311      #pragma omp parallel for collapse(2)
312    #endif
313  #endif
314        for (int image = 0; image < batch_size; ++image)
315          for (int channel = 0; channel < num_channels; ++channel)
316            generator_func(bottom_data,
317                           top_data,
318                           top_count,
319                           image,
320                           image+1,
321                           mask,
322                           channel,
323                           channel+1,
324                           this,
325                           use_top_mask);
326    } else if (num_spatial_axes_ == 3) {
327        vector<int> offset(2, 0);
328        offset[1] = 1;
329        const int* kernel_shape = kernel_shape_.cpu_data();
330        const int* pad_data = this->pad_.cpu_data();
331        const int* stride_data = this->stride_.cpu_data();
332        const int* input_shape_data = this->input_shape_.cpu_data();
333        const int* output_shape_data = this->output_shape_.cpu_data();
334        long bottom_offset = bottom[0]->offset(offset);
335        long top_offset = top[0]->offset(offset);
336        switch (this->layer_param_.pooling_param().pool()) {
337        case PoolingParameter_PoolMethod_MAX:
338          if (use_top_mask) {
339            caffe_set(top_count, Dtype(-1), top[1]->mutable_cpu_data());
340          } else {
341            caffe_set(top_count, -1, max_idx_.mutable_cpu_data());
342          }
343          caffe_set(top_count, Dtype(-FLT_MAX), top_data);
344  #ifdef _OPENMP
345    #if defined(_MSC_EXTENSIONS)
346      #pragma omp parallel for
347    #else
348      #pragma omp parallel for collapse(2)
349    #endif
350  #endif
351          for (int n = 0; n < num_; ++n) {
352            for (int c = 0; c < channels_; ++c) {
353              long nc = n * channels_ + c;
354              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
355              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
356              Dtype *top_mask = NULL;
357              int *mask = NULL;
358              if (use_top_mask) {
359                top_mask = top[1]->mutable_cpu_data() + nc * top_offset;
360              } else {
361                mask = max_idx_.mutable_cpu_data() + nc * top_offset;
362              }
363              for (int pz = 0; pz < output_shape_data[0]; ++pz) {
364                for (int ph = 0; ph < output_shape_data[1]; ++ph) {
365                  for (int pw = 0; pw < output_shape_data[2]; ++pw) {
366                      int zstart = pz * stride_data[0] - pad_data[0];
367                      int hstart = ph * stride_data[1] - pad_data[1];
368                      int wstart = pw * stride_data[2] - pad_data[2];
369                      int zend = min(zstart + kernel_shape[0], input_shape_data[1]);
370                      int hend = min(hstart + kernel_shape[1], input_shape_data[2]);
371                      int wend = min(wstart + kernel_shape[2], input_shape_data[3]);
372                      hstart = max(hstart, 0);
373                      wstart = max(wstart, 0);
374                      zstart = max(zstart, 0);
375                      const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
376                      for (int z = zstart; z < zend; ++z) {
377                        for (int h = hstart; h < hend; ++h) {
378                          for (int w = wstart; w < wend; ++w) {
379                            const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
380                            if (bottom_data2[index] > top_data2[pool_index]) {
381                              top_data2[pool_index] = bottom_data2[index];
382                              if (use_top_mask) {
383                                top_mask[pool_index] = static_cast<Dtype>(index);
384                              } else {
385                                mask[pool_index] = index;
386                              }
387                            }
388                          }
389                        }
390                      }
391                  }
392                }
393              }
394            }
395          }
396          break;
397        case PoolingParameter_PoolMethod_AVE:
398          caffe_set(top_count, Dtype(0), top_data);
399  #ifdef _OPENMP
400    #if defined(_MSC_EXTENSIONS)
401      #pragma omp parallel for
402    #else
403      #pragma omp parallel for collapse(2)
404    #endif
405  #endif
406          for (int n = 0; n < num_; ++n) {
407            for (int c = 0; c < channels_; ++c) {
408              long nc = n * channels_ + c;
409              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
410              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
411              for (int pz = 0; pz < output_shape_data[0]; ++pz) {
412                for (int ph = 0; ph < output_shape_data[1]; ++ph) {
413                  for (int pw = 0; pw < output_shape_data[2]; ++pw) {
414                    int zstart = pz * stride_data[0] - pad_data[0];
415                    int hstart = ph * stride_data[1] - pad_data[1];
416                    int wstart = pw * stride_data[2] - pad_data[2];
417                    int zend = min(zstart + kernel_shape[0],
418                             input_shape_data[1] + pad_data[0]);
419                    int hend = min(hstart + kernel_shape[1],
420                              input_shape_data[2] + pad_data[1]);
421                    int wend = min(wstart + kernel_shape[2],
422                            input_shape_data[3] + pad_data[2]);
423                    int pool_size = (hend - hstart) *
424                                    (wend - wstart) *
425                                    (zend - zstart);
426                    hstart = max(hstart, 0);
427                    wstart = max(wstart, 0);
428                    zstart = max(zstart, 0);
429                    zend = min(zend, input_shape_data[1]);
430                    hend = min(hend, input_shape_data[2]);
431                    wend = min(wend, input_shape_data[3]);
432                    const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
433                    for (int z = zstart; z < zend; ++z) {
<span onclick='openModal()' class='match'>434                      for (int h = hstart; h < hend; ++h) {
435                        for (int w = wstart; w < wend; ++w) {
436                          const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
</span>437                          top_data2[pool_index] += bottom_data2[index];
438                        }
439                      }
440                    }
441                    top_data2[pool_index] /= pool_size;
442                  }
443                }
444              }
445            }
446          }
447          break;
448        case PoolingParameter_PoolMethod_STOCHASTIC:
449          NOT_IMPLEMENTED;
450          break;
451        default:
452          LOG(FATAL) << "Unknown pooling method.";
453        }
454      } else {
455        NOT_IMPLEMENTED;
456      }
457  }
458  template <typename Dtype>
459  void PoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
460        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
461    if (!propagate_down[0]) {
462      return;
463    }
464    const Dtype* top_diff = top[0]->cpu_diff();
465    Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
466    caffe_set(bottom[0]->count(), Dtype(0), bottom_diff);
467    const bool use_top_mask = top.size() > 1;
468    if (num_spatial_axes_ == 2) {
469        typename PoolingCodeGeneratorBackward<Dtype>::Callback_t* generator_func =
470                            Backward_code_generator.Get_callback(this, top[0]);
471        void* mask = NULL;
472        if (this->layer_param_.pooling_param().pool() ==
473            PoolingParameter_PoolMethod_MAX ) {
474          mask = (use_top_mask) ? static_cast<void*>(top[1]->mutable_cpu_data()) :
475                                  static_cast<void*>(max_idx_.mutable_cpu_data());
476        }
477        const int batch_size = bottom[0]->num();
478        const int num_channels = bottom[0]->channels();
479  #ifdef _OPENMP
480    #if defined(_MSC_EXTENSIONS)
481      #pragma omp parallel for
482    #else
483      #pragma omp parallel for collapse(2)
484    #endif
485  #endif
486        for (int image = 0; image < batch_size; ++image)
487          for (int channel = 0; channel < num_channels; ++channel)
488            generator_func(top_diff,
489                           bottom_diff,
490                           image,
491                           image+1,
492                           channel,
493                           channel+1,
494                           use_top_mask,
495                           mask,
496                           this);
497        } else if (num_spatial_axes_ == 3) {
498          const int* kernel_shape = this->kernel_shape_.cpu_data();
499          const int* pad_data = this->pad_.cpu_data();
500          const int* stride_data = this->stride_.cpu_data();
501          const int* input_shape_data = this->input_shape_.cpu_data();
502          const int* output_shape_data = this->output_shape_.cpu_data();
503          int top_num = top[0]->count(0, channel_axis_);
504          vector<int> offset(2, 0);
505          offset[1] = 1;
506          long bottom_offset = bottom[0]->offset(offset);
507          long top_offset = top[0]->offset(offset);
508          switch (this->layer_param_.pooling_param().pool()) {
509          case PoolingParameter_PoolMethod_MAX:
510  #ifdef _OPENMP
511    #if defined(_MSC_EXTENSIONS)
512      #pragma omp parallel for
513    #else
514      #pragma omp parallel for collapse(2)
515    #endif
516  #endif
517            for (int n = 0; n < top_num; ++n) {
518              for (int c = 0; c < channels_; ++c) {
519                long nc = n * channels_ + c;
520                Dtype *bottom_diff2 = bottom[0]->mutable_cpu_diff() + nc * bottom_offset;
521                const Dtype *top_diff2 = top[0]->cpu_diff() + nc * top_offset;
522                const Dtype *top_mask = NULL;
523                const int *mask = NULL;
524                if (use_top_mask) {
525                  top_mask = top[1]->cpu_data() + nc * top_offset;
526                } else {
527                  mask = max_idx_.cpu_data() + nc * top_offset;
528                }
529                for (int pz = 0; pz < output_shape_data[0]; ++pz) {
530                  for (int ph = 0; ph < output_shape_data[1]; ++ph) {
531                    for (int pw = 0; pw < output_shape_data[2]; ++pw) {
532                      const int index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
533                      const int bottom_index = use_top_mask ? top_mask[index] : mask[index];
534                      bottom_diff2[bottom_index] += top_diff2[index];
535                    }
536                  }
537                }
538              }
539            }
540            break;
541          case PoolingParameter_PoolMethod_AVE:
542  #ifdef _OPENMP
543    #if defined(_MSC_EXTENSIONS)
544      #pragma omp parallel for
545    #else
546      #pragma omp parallel for collapse(2)
547    #endif
548  #endif
549            for (int n = 0; n < top_num; ++n) {
550              for (int c = 0; c < channels_; ++c) {
551                long nc = n * channels_ + c;
552                Dtype *bottom_diff2 = bottom[0]->mutable_cpu_diff() + nc * bottom_offset;
553                const Dtype *top_diff2 = top[0]->cpu_diff() + nc * top_offset;
554                for (int pz = 0; pz < output_shape_data[0]; ++pz) {
555                  for (int ph = 0; ph < output_shape_data[1]; ++ph) {
556                    for (int pw = 0; pw < output_shape_data[2]; ++pw) {
557                      int zstart = pz * stride_data[0] - pad_data[0];
558                      int hstart = ph * stride_data[1] - pad_data[1];
559                      int wstart = pw * stride_data[2] - pad_data[2];
560                      int zend = min(zstart + kernel_shape[0], input_shape_data[1] + pad_data[0]);
561                      int hend = min(hstart + kernel_shape[1], input_shape_data[2] + pad_data[1]);
562                      int wend = min(wstart + kernel_shape[2], input_shape_data[3] + pad_data[2]);
563                      int pool_size = (hend - hstart) * (wend - wstart) * (zend - zstart);
564                      hstart = max(hstart, 0);
565                      wstart = max(wstart, 0);
566                      zstart = max(zstart, 0);
567                      zend = min(zend, input_shape_data[1]);
568                      hend = min(hend, input_shape_data[2]);
569                      wend = min(wend, input_shape_data[3]);
570                      const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
571                      for (int z = zstart; z < zend; ++z) {
572                        for (int h = hstart; h < hend; ++h) {
573                          for (int w = wstart; w < wend; ++w) {
574                            const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
575                            bottom_diff2[index] += top_diff2[pool_index] / pool_size;
576                          }
577                        }
578                      }
579                    }
580                  }
581                }
582              }
583            }
584            break;
585          case PoolingParameter_PoolMethod_STOCHASTIC:
586            NOT_IMPLEMENTED;
587            break;
588          default:
589            LOG(FATAL) << "Unknown pooling method.";
590        }
591      } else {
592        NOT_IMPLEMENTED;
593      }
594  }
595  #ifdef CPU_ONLY
596  STUB_GPU(PoolingLayer);
597  #endif
598  INSTANTIATE_CLASS(PoolingLayer);
599  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</h3>
            <pre><code>1  TTimeNet& TTimeNet::operator = (const TTimeNet& TimeNet) {
2    if (this != &TimeNet) {
3      TNet::operator=(TimeNet);
4    }
5    return *this;
6  }
7  PTimeNet TTimeNet::GetSubGraph(const TIntV& NIdV) const {
8    PTimeNet NewNetPt = TTimeNet::New();
9    TTimeNet& NewNet = *NewNetPt;
10    NewNet.Reserve(NIdV.Len(), -1);
11    int node, edge;
12    TNodeI NI;
13    for (node = 0; node < NIdV.Len(); node++) {
14      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
15    }
16    for (node = 0; node < NIdV.Len(); node++) {
17      NI = GetNI(NIdV[node]);
18      const int SrcNId = NI.GetId();
19      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
20        const int OutNId = NI.GetOutNId(edge);
21        if (NewNet.IsNode(OutNId)) {
22          NewNet.AddEdge(SrcNId, OutNId); }
23      }
24    }
25    NewNet.Defrag();
26    return NewNetPt;
27  }
28  PTimeNENet TTimeNet::GetTimeNENet() const {
29    TIntV NIdV;  GetNIdByTm(NIdV);
30    PTimeNENet OutNet = TTimeNENet::New(GetNodes(), GetEdges());
31    for (int i = 0; i < NIdV.Len(); i++) {
32      const int Src = NIdV[i];
33      const TTimeNet::TNodeI NI = GetNI(Src);
34      const TSecTm SrcTm = NI.GetDat();
35      if (! OutNet->IsNode(Src)) { OutNet->AddNode(Src, SrcTm); }
36      for (int e = 0; e < NI.GetOutDeg(); e++) {
37        if (! OutNet->IsNode(NI.GetOutNId(e))) { OutNet->AddNode(NI.GetOutNId(e), SrcTm); }
38        OutNet->AddEdge(Src, NI.GetOutNId(e), -1, SrcTm);
39      }
40    }
41    return OutNet;
42  }
43  void TTimeNet::GetNIdByTm(TIntV& NIdV) const {
44    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
45    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
46      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
47    TmToNIdV.Sort();
48    NIdV.Gen(GetNodes(), 0);
49    for (int i = 0; i < TmToNIdV.Len(); i++) {
50      NIdV.Add(TmToNIdV[i].Dat); }
51  }
52  void TTimeNet::GetTmBuckets(const TTmUnit& TmUnit, TTmBucketV& TmBucketV) const {
53    THash<TInt, TIntV> TmIdToNIdVH;
54    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
55      const int TmId = NodeI().Round(TmUnit);
56      if (! TmIdToNIdVH.IsKey(TmId)) TmIdToNIdVH.AddKey(TmId);
57      TmIdToNIdVH.GetDat(TmId).Add(NodeI.GetId());
58    }
59    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
60    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
61    TmIdNIdVV.Sort();
62    TmBucketV.Gen(TmIdNIdVV.Len());
63    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
64      TTmBucket& Bucket = TmBucketV[i];
65      Bucket.BegTm = TmIdNIdVV[i].Val1;
66      Bucket.NIdV = TmIdNIdVV[i].Val2;
67    }
68  }
69  void TTimeNet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
70    TIntV NIdV;
71    GetNIdByTm(NIdV);
72    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
73    for (int i = 0; i < NIdV.Len(); i++) {
74      const int b = i/NodesPerBucket;
75      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
76      TmBucketV[b].NIdV.Add(NIdV[i]);
77    }
78  }
79  PGStatVec TTimeNet::TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const {
80    PGStatVec GrowthStat = new TGStatVec(TmUnit, TakeStat);
81    TTmBucketV TmBucketV;
82    GetTmBuckets(TmUnit, TmBucketV);
83    TIntV NodeIdV;
84    TExeTm ExeTm;
85    for (int t = 0; t < TmBucketV.Len(); t++) {
86      NodeIdV.AddV(TmBucketV[t].NIdV); 
87      printf("\n=== %d/%d] %s (%d nodes)\n", t+1, TmBucketV.Len(),
88        TmBucketV[t].BegTm.GetStr().CStr(), NodeIdV.Len());  ExeTm.Tick();
89      if (TmBucketV[t].BegTm < StartTm) continue;
90      PNGraph PreGraph = TSnap::ConvertSubGraph<PNGraph>(PTimeNet((TTimeNet*)this), NodeIdV); 
91      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
92    }
93    return GrowthStat;
94  }
95  void TTimeNet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
96                             const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc, const bool& AlsoRewire) const {
97    const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
98    TTmBucketV TmBucketV;
99    GetTmBuckets(TmUnit, TmBucketV);
100    TIntV NodeIdV;
101    TExeTm ExeTm, Run1Tm;
102    TFltTrV TmDiamV, NdsDiamV;
103    TFltTrV RwTmDiamV, RwNdsDiamV;
104    for (int t = 0; t < TmBucketV.Len(); t++) {
105      NodeIdV.AddV(TmBucketV[t].NIdV); 
106      printf("\n*** %d/%d] at %s (%d nodes)\n", t+1, TmBucketV.Len(),
107        TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), NodeIdV.Len());  ExeTm.Tick();
108      if (TmBucketV[t].BegTm < StartTm) continue;
109      PUNGraph PreGraph = TSnap::ConvertSubGraph<PUNGraph>(PTimeNet((TTimeNet*)this), NodeIdV);
<span onclick='openModal()' class='match'>110      { TMom Mom;
111      for (int r = 0; r < NDiamRuns; r++) {
112        printf("%d...", r+1);  Run1Tm.Tick();
113        const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph) : PreGraph);
</span>114        Mom.Add(EffDiam);  printf("[%s]\r", Run1Tm.GetTmStr());
115      }
116      Mom.Def();
117      TmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
118      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
119      NdsDiamV.Sort();
120      printf("  [%s]          \n", ExeTm.GetTmStr()); }
121      if (AlsoRewire) {
122        TIntV DegSeqV(PreGraph->GetNodes(), 0);
123        for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) { DegSeqV.Add(NI.GetDeg()); }
124        PUNGraph RwGraph = TSnap::GenConfModel(DegSeqV, TInt::Rnd);
125        printf("Configuration model: (%d, %d) --> (%d, %d)\n", PreGraph->GetNodes(), PreGraph->GetEdges(), RwGraph->GetNodes(), RwGraph->GetEdges());
126        TMom Mom;
127        for (int r = 0; r < NDiamRuns; r++) {
128          printf("  diam run %d...", r+1);  Run1Tm.Tick();
129          const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph):PreGraph);
130          Mom.Add(EffDiam);  printf(" current run [%s]\n", Run1Tm.GetTmStr());
131        }
132        Mom.Def();
133        RwTmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
134        RwNdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
135        RwNdsDiamV.Sort();
136        printf("done with diameter. Total time [%s] \n", ExeTm.GetTmStr());
137      }
138      { TGnuPlot GnuPlot("diamEff-T."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
139      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), WccStr+"Effective Diameter");
140      GnuPlot.AddErrBar(TmDiamV, "True", "");
141      if (! RwTmDiamV.Empty()) { GnuPlot.AddErrBar(RwTmDiamV, "Rewired", "");}
142      GnuPlot.SavePng(); }
143      { TGnuPlot GnuPlot("diamEff-N."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
144      GnuPlot.SetXYLabel("NODES", WccStr+"Effective Diameter");
145      GnuPlot.AddErrBar(NdsDiamV, "True", "");
146      if (! RwNdsDiamV.Empty()) { GnuPlot.AddErrBar(RwNdsDiamV, "Rewired", "");}
147      GnuPlot.SavePng(); }
148    }
149  }
150  void TTimeNet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
151                                 const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam) const {
152    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
153      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
154    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
155      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
156    const int NDiamRuns = 10;
157    const int NSamples = 100;
158    PUNGraph FullGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
159    if (DelPreTmEdges.IsDef()) {
160      int NDelNodes = 0, NDelEdges = 0;
161      printf("Deleting pre-%s node out-links\n", DelPreTmEdges.GetStr().CStr());
162      for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
163        if (NodeI() < DelPreTmEdges) {
164          const int NodeId = NodeI.GetId();
165          for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
166            FullGraph->DelEdge(NodeId, NodeI.GetOutNId(edge)); }
167          NDelEdges += NodeI.GetOutDeg();  NDelNodes++;
168        }
169      }
170      printf("  Deleted %d nodes out-edges (%d edges total).\n", NDelNodes, NDelEdges);
171      FullGraph->Defrag(true);
172    }
173    PGStatVec GrowthStat = TGStatVec::New(TmUnit);
174    TFltV PreDiamSDev, PreEffDiamSDev, WccDiamSDev, WccEffDiamSDev;
175    TIntV NodeIdV;
176    TExeTm ExeTm;
177    TTmBucketV TmBucketV;
178    GetTmBuckets(TmUnit, TmBucketV);
179    for (int t = 0; t < TmBucketV.Len(); t++) {
180      printf("\nGraph: %s (%d / %d) [%s]\n", TmBucketV[t].BegTm.GetTmStr().CStr(),
181        t+1, TmBucketV.Len(), TExeTm::GetCurTm());
182      NodeIdV.AddV(TmBucketV[t].NIdV); 
183      if (TmBucketV[t].BegTm < PostTmDiam) { continue; }
184      const PUNGraph PreGraph = TSnap::GetSubGraph(FullGraph, NodeIdV, true);
185      const PUNGraph WccGraph = TSnap::GetMxWcc(PreGraph);
186      TIntV PostYearNIdV, WccPostYearNIdV;
187      for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) {
188        if (GetNDat(NI.GetId()) >= PostTmDiam) {
189          PostYearNIdV.Add(NI.GetId());
190          if (WccGraph->IsNode(NI.GetId())) { WccPostYearNIdV.Add(NI.GetId()); }
191        }
192      }
193      TMom PreDiamMom, PreEffDiamMom, WccDiamMom, WccEffDiamMom;
194      int FullDiam; double EffDiam;
195      for (int r = 0; r < NDiamRuns; r++) {
196        if (! PostYearNIdV.Empty()) {
197          TSnap::GetBfsEffDiam(PreGraph, NSamples, PostYearNIdV, false, EffDiam, FullDiam);
198          PreDiamMom.Add(FullDiam);  PreEffDiamMom.Add(EffDiam);
199        }
200        if (! WccPostYearNIdV.Empty()) {
201          TSnap::GetBfsEffDiam(WccGraph, NSamples, WccPostYearNIdV, false, EffDiam, FullDiam);
202          WccDiamMom.Add(FullDiam);  WccEffDiamMom.Add(EffDiam);
203        }
204        printf("  diam: %d  [%s]  \r", r+1, ExeTm.GetTmStr());  ExeTm.Tick();
205      }
206      PreDiamMom.Def();  PreEffDiamMom.Def();
207      WccDiamMom.Def();  WccEffDiamMom.Def();
208      PGStat GraphStatPt = GrowthStat->Add(TmBucketV[t].BegTm);
209      TGStat& GS = *GraphStatPt;
210      GS.TakeBasicStat(PreGraph, false);
211      GS.TakeBasicStat(WccGraph, true);
212      GS.SetVal(gsvFullDiam, PreDiamMom.GetMean()); 
213      GS.SetVal(gsvEffDiam, PreEffDiamMom.GetMean());
214      GS.SetVal(gsvFullWccDiam, WccDiamMom.GetMean());
215      GS.SetVal(gsvEffWccDiam, WccEffDiamMom.GetMean());
216      GS.SetVal(gsvFullDiamDev, PreDiamMom.GetSDev()); 
217      GS.SetVal(gsvEffDiamDev, PreEffDiamMom.GetSDev());
218      GS.SetVal(gsvFullWccDiamDev, WccDiamMom.GetSDev());
219      GS.SetVal(gsvEffWccDiamDev, WccEffDiamMom.GetSDev());
220      { TFOut FOut("growth."+FNmPref+".gStatVec");  GrowthStat->Save(FOut); }
221      GrowthStat->SaveTxt(FNmPref, TStr::Fmt("%s. MISSING PAST DIAMETER\nDelPreEdges\t%s\nPostYearDiam\t%s\n",
222        Desc.CStr(), DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr()));
223    }
224  }
225  void TTimeNet::PlotCCfOverTm(const TStr& FNmPref, TStr Desc, const TTmUnit& TmUnit, const int& NodesBucket) const {
226    if (Desc.Empty()) { Desc = FNmPref; }
227    TTimeNet::TTmBucketV TmBucketV;
228    TStr XLbl;
229    if (TmUnit == tmuNodes) {
230      XLbl = "Number of nodes (time)";
231      IAssert(NodesBucket > 0);
232      GetNodeBuckets(NodesBucket, TmBucketV); }
233    else {
234      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
235      GetTmBuckets(TmUnit, TmBucketV);
236    }
237    TIntV NodeIdV;
238    TFltPrV DegToCCfV, CcfV, OpClV, OpV;
239    TVec<TTuple<TFlt, 4> > OpenClsV;
240    TTuple<TFlt, 4> Tuple;
241    TExeTm ExeTm;
242    int XVal = 0;
243    printf("Clustering coefficient over time:\n  %d edges, %d edges per bucket, %d buckets \n", GetEdges(), 100000, TmBucketV.Len());
244    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
245    for (int t = 0; t < TmBucketV.Len(); t++) {
246      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
247      NodeIdV.AddV(TmBucketV[t].NIdV); 
248      int64 Open=0, Close=0;
249      const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);
250      const double CCf = TSnap::GetClustCf(Graph, DegToCCfV, Open, Close);
251      if (TmUnit == tmuNodes) { XVal = Graph->GetNodes(); }
252      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
253      CcfV.Add(TFltPr(XVal, CCf));
254      double FltOpen = static_cast<double>(Open);
255      double FltClose = static_cast<double>(Close);
256      OpClV.Add(TFltPr(XVal, (Open+Close==0 ? 0.0 : FltClose/(FltOpen+FltClose))));
257      OpV.Add(TFltPr(XVal, (Open==0 ? 0.0 : FltClose/FltOpen)));
258      Tuple[0]=Graph->GetNodes();
259      Tuple[1]=Graph->GetEdges();
260      Tuple[2]=FltClose;  Tuple[3]=FltOpen;
261      OpenClsV.Add(Tuple);
262      printf(" %s", ExeTm.GetStr());
263      TGnuPlot::PlotValV(DegToCCfV, TStr::Fmt("ccfAt%02dtm.%s", t+1, FNmPref.CStr()),
264        TStr::Fmt("%s. At time %d. Clustering Coefficient. G(%d,%d)", Desc.CStr(), t+1, Graph->GetNodes(), Graph->GetEdges()),
265        "Degree", "Clustering coefficient", gpsLog10XY, false);
266    }
267    TGnuPlot::PlotValV(CcfV, "ccfOverTm."+FNmPref, Desc+". Average Clustering Coefficient", XLbl, "Average clustering coefficient", gpsAuto, false);
268    TGnuPlot::PlotValV(OpClV, "ClsOpnTr1."+FNmPref, Desc+". Close/(Open+Closed) triads", XLbl, "Close / (Open+Closed) triads", gpsAuto, false);
269    TGnuPlot::PlotValV(OpV, "ClsOpnTr2."+FNmPref, Desc+". Close/Open triads", XLbl, "Close / Open triads", gpsAuto, false);
270    TGnuPlot::SaveTs(OpenClsV, "ClsOpnTr."+FNmPref+".tab", TStr::Fmt("#%s\n#Nodes\tEdges\tClosed\tOpenTriads", Desc.CStr()));
271    printf("\n");
272  }
273  void TTimeNet::PlotMedianDegOverTm(const TStr& FNmPref, const TTmUnit& TmUnit, const int& NodesPerBucket) const {
274    TTimeNet::TTmBucketV TmBucketV;
275    TStr XLbl;
276    if (TmUnit == tmuNodes) {
277      XLbl = "Number of nodes (time)";  IAssert(NodesPerBucket > 0);
278      GetNodeBuckets(NodesPerBucket, TmBucketV); }
279    else {
280      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
281      GetTmBuckets(TmUnit, TmBucketV); }
282    printf("\n\n%s\nMedian degree over time:\n  %d edges, %d edges per bucket, %d buckets \n", FNmPref.CStr(), GetEdges(), NodesPerBucket, TmBucketV.Len());
283    TFltPrV MedDegV, MedInDegV, MedOutDegV;
284    TIntV NodeIdV;
285    int XVal;
286    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
287    PNGraph NGraph = TSnap::ConvertGraph<PNGraph>(PTimeNet((TTimeNet*)this));
288    FILE  *F = fopen(("gStat-"+FNmPref+".tab").CStr(), "wt");
289    fprintf(F, "UndirNodes\tUndirEdges\tUndirNonZNodes\tMedianDeg\tMeanDeg\tDirNodes\tDirEdges\tDirNonzNodes\tMedInDeg\tMedOutDeg\tMeanInDeg\tMeanOutDeg\n");
290    for (int t = 0; t < TmBucketV.Len(); t++) {
291      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
292      NodeIdV.AddV(TmBucketV[t].NIdV); 
293      if (TmUnit == tmuNodes) { XVal = NodeIdV.Len(); }
294      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
295      { const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);  TMom Mom;
296      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) { if (NI.GetOutDeg()>0) { Mom.Add(NI.GetOutDeg());} }
297      Mom.Def();  MedDegV.Add(TFltPr(XVal, Mom.GetMedian()));
298      fprintf(F, "%d\t%d\t%d\t%f\t%f", Graph->GetNodes(), Graph->GetEdges(), TSnap::CntNonZNodes(Graph), (float)Mom.GetMedian(), (float)Mom.GetMean()); }
299      { const PNGraph Graph = TSnap::GetSubGraph<PNGraph>(NGraph, NodeIdV); TMom MomOut, MomIn;
300      for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
301        if (NI.GetOutDeg()>0) { MomOut.Add(NI.GetOutDeg()); }
302        if (NI.GetInDeg()>0) { MomIn.Add(NI.GetInDeg()); } }
303      MomOut.Def();  MedOutDegV.Add(TFltPr(XVal, MomOut.GetMedian()));
304      MomIn.Def();  MedInDegV.Add(TFltPr(XVal, MomIn.GetMedian()));
305      fprintf(F, "\t%d\t%d\t%d\t%f\t%f\t%f\t%f\n", Graph->GetNodes(), Graph->GetEdges(), (int)TSnap::CntNonZNodes(Graph), (float)MomIn.GetMedian(), (float)MomOut.GetMedian(), (float)MomIn.GetMean(), (float)MomOut.GetMean()); }
306    }
307    fclose(F);
308    TGnuPlot::PlotValV(MedDegV, "medDeg."+FNmPref, FNmPref+" Median degree", TTmInfo::GetTmUnitStr(TmUnit), "Median degree");
309    TGnuPlot::PlotValV(MedOutDegV, "medOutDeg."+FNmPref, FNmPref+" Median OUT degree", TTmInfo::GetTmUnitStr(TmUnit), "Median OUT degree");
310    TGnuPlot::PlotValV(MedInDegV, "medInDeg."+FNmPref, FNmPref+" Median IN degree", TTmInfo::GetTmUnitStr(TmUnit), "Median IN degree");
311  }
312  PTimeNet TTimeNet::LoadBipartite(const TStr& InFNm) {
313    PTimeNet TimeNetPt = TTimeNet::New();
314    TTimeNet& TimeNet = *TimeNetPt;
315    PSs Ss = TSs::LoadTxt(ssfTabSep, InFNm.CStr());
316    TIntH Set1IdH; 
317    TStrV StrTimeV;
318    for (int y = 0; y < Ss->GetYLen(); y++) {
319      if (Ss->At(0, y)[0] == '#') continue; 
320      if (Ss->GetXLen(y) < 3) continue;     
321      const int& SrcId = Ss->At(0, y).GetInt();
322      IAssert(! Set1IdH.IsKey(SrcId));
323      IAssert(! TimeNet.IsNode(SrcId));
324      Set1IdH.AddKey(SrcId);
325      Ss->At(1, y).SplitOnAllCh('-', StrTimeV);
326      const int Year = StrTimeV[0].GetInt();
327      const int Month = StrTimeV[1].GetInt();
328      const int Day = StrTimeV[2].GetInt();
329      const TSecTm NodeTm(Year, Month, Day);
330      TimeNet.AddNode(SrcId, NodeTm);
331      for (int dst = 2; dst < Ss->GetXLen(y); dst++) {
332        const int DstId = Ss->At(dst, y).GetInt();
333        IAssert(! Set1IdH.IsKey(DstId));
334        if (! TimeNet.IsNode(DstId)) { TimeNet.AddNode(DstId, NodeTm); }
335        else { TimeNet.GetNDat(DstId) = TMath::Mn(NodeTm, TimeNet.GetNDat(DstId)); }
336        if (! TimeNet.IsEdge(SrcId, DstId)) { TimeNet.AddEdge(SrcId, DstId); }
337      }
338    }
339    TimeNet.Defrag();
340    printf("Bipartate graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
341    printf("  Bipartate sets: %d nodes --> %d nodes\n", TSnap::CntInDegNodes(TimeNetPt, 0),
342      TSnap::CntOutDegNodes(TimeNetPt, 0));
343    return TimeNetPt;
344  }
345  PTimeNet TTimeNet::LoadArxiv(const TStr& PaperFNm, const TStr& CiteFNm) {
346    TExeTm ExeTm;
347    PTimeNet TimeNetPt = TTimeNet::New();
348    TTimeNet& TimeNet = *TimeNetPt;
349    printf("Arxiv citation graph (paper publication year)...\n");
350    char Line [1024];
351    FILE *PprF = fopen(PaperFNm.CStr(), "rt");
352    TStr StrId, StrTime;
353    TStrV StrV, StrTimeV;
354    int N = 0, DuplicateNode = 0;
355    while (! feof(PprF)) {
356      Line[0] = 0;
357      fgets(Line, 1024, PprF);
358      if (strlen(Line) == 0 || Line[0] == '#') continue;
359      Line[strlen(Line)-1] = 0; 
360      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
361      StrId = StrV[0];  StrTime = StrV[1];  IAssert(!StrId.Empty() && !StrTime.Empty());
362      StrTime.SplitOnAllCh('-', StrTimeV);  IAssert(StrTimeV.Len() == 3);
363      const int NodeId = StrId.GetInt();
364      if (! TimeNet.IsNode(NodeId)) {
365        const int Year = StrTimeV[0].GetInt();
366        const int Month = StrTimeV[1].GetInt();
367        const int Day = StrTimeV[2].GetInt();
368        TimeNet.AddNode(NodeId, TSecTm(Year, Month, Day));
369      } else { DuplicateNode++; }
370      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
371    }
372    printf("\r  %d nodes read. %d duplicate nodes. %s\n", N, DuplicateNode, ExeTm.GetTmStr());
373    fclose(PprF);
374    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
375    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
376    N = 0;  ExeTm.Tick();
377    printf("Loading Arxiv citations...\n");
378    TIntPrV EdgeV;
379    THash<TInt, TSecTm> NIdToTimeH;
380    while (! feof(CiteF)) {
381      Line[0] = 0;
382      fgets(Line, 1024, CiteF);
383      if (strlen(Line) == 0 || Line[0] == '#') continue;
384      Line[strlen(Line)-1] = 0; 
385      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
386      const int SrcNId = StrV[0].GetInt();
387      const int DstNId = StrV[1].GetInt();
388      EdgeV.Add(TIntPr(SrcNId, DstNId));
389      if (! TimeNet.IsNode(DstNId) && TimeNet.IsNode(SrcNId)) {
390        const TSecTm& SrcTm = TimeNet.GetNDat(SrcNId);
391        if (! NIdToTimeH.IsKey(DstNId)) {
392          NIdToTimeH.AddDat(DstNId, SrcTm);
393          NewDstIds++;
394        }
395        else if (NIdToTimeH.GetDat(DstNId) < SrcTm) {
396          NIdToTimeH.GetDat(DstNId) = SrcTm; }
397      }
398      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
399    }
400    fclose(CiteF);
401    for (int i = 0; i < NIdToTimeH.Len(); i++) {
402      TimeNet.AddNode(NIdToTimeH.GetKey(i), NIdToTimeH[i]);
403    }
404    for (int i = 0; i < EdgeV.Len(); i++) {
405      const int SrcNId = EdgeV[i].Val1;
406      const int DstNId = EdgeV[i].Val2;
407      if (TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
408        if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
409        else { DupLinks++; }
410      } else {
411        if (! TimeNet.IsNode(SrcNId)) {
412          NewSrcIds++;
413          if (! TimeNet.IsNode(DstNId)) { NewCits++; }
414        }
415      }
416    }
417    printf("\r  %d citations read. %s\n", N, ExeTm.GetTmStr());
418    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
419    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
420    TIntV RmNIdV;
421    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
422      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
423    }
424    for (int i = 0; i < RmNIdV.Len(); i++) {
425      TimeNet.DelNode(RmNIdV[i]);
426    }
427    TimeNet.Defrag(true);
428    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
429    printf("  Duplicate citations                    : %d\n", DupLinks);
430    printf("  Nodes without time which are cited     : %d (add them to graph, use time of the earliest source node)\n", NewDstIds);
431    printf("  Citations between unknown time nodes   : %d\n", NewCits);
432    printf("  Nodes without time which make citations: %d (do not add them into the graph)\n", NewSrcIds);
433    return TimeNetPt;
434  }
435  PTimeNet TTimeNet::LoadPatents(const TStr& PatentFNm, const TStr& CiteFNm) {
436    int N = 0;
437    TExeTm ExeTm;
438    PTimeNet TimeNetPt = TTimeNet::New();
439    TTimeNet& TimeNet = *TimeNetPt;
440    TimeNet.Reserve(4000000, 160000000);
441    printf("parsing patent data (patent grant year)...\n");
442    const int& PatIdCol = 0;
443    const int& GYearCol = 1;
444    TStrV ColV;
445    char Line [1024];
446    FILE *PatF = fopen(PatentFNm.CStr(), "rt");
447    fgets(Line, 1024, PatF); 
448    while (! feof(PatF)) {
449      Line[0] = 0;
450      fgets(Line, 1024, PatF);
451      if (strlen(Line) == 0) break;
452      TStr(Line).SplitOnAllCh(',', ColV, false);
453      IAssert(ColV.Len() == 23);
454      const int PatentId = ColV[PatIdCol].GetInt();
455      const int GrantYear = ColV[GYearCol].GetInt();
456      IAssert(! TimeNet.IsNode(PatentId));
457      TimeNet.AddNode(PatentId, TSecTm(GrantYear)); 
458      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
459    }
460    printf("\r  %d patents read. %s\n", N, ExeTm.GetTmStr());
461    fclose(PatF);
462    printf("\nLoading patent citations...\n");
463    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
464    N = 0;  ExeTm.Tick();
465    TStr SrcId, DstId;
466    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
467    fgets(Line, 1024, CiteF); 
468    while (! feof(CiteF)) {
469      Line[0] = 0;
470      fgets(Line, 1024, CiteF);
471      if (strlen(Line) == 0) break;
472      Line[strlen(Line)-1] = 0; 
473      TStr(Line).SplitOnCh(SrcId, ',', DstId);
474      const int SrcNId = SrcId.GetInt();
475      const int DstNId = DstId.GetInt();
476      if (! TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
477        NewCits++;
478        continue;
479      }
480      else if (TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
481        TimeNet.AddNode(DstNId, TimeNet.GetNDat(SrcNId));  NewDstIds++;
482      }
483      else if (! TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
484        TimeNet.AddNode(SrcNId, TimeNet.GetNDat(DstNId));  NewSrcIds++;
485      }
486      if (! TimeNet.IsEdge(SrcNId, DstNId)) {
487        TimeNet.AddEdge(SrcNId, DstNId);
488      } else { DupLinks++; }
489      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
490    }
491    fclose(CiteF);
492    printf("\r  %d citations read. %s\n\n", N, ExeTm.GetTmStr());
493    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
494    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
495    TIntV RmNIdV;
496    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
497      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
498    }
499    for (int i = 0; i < RmNIdV.Len(); i++) {
500      TimeNet.DelNode(RmNIdV[i]);
501    }
502    TimeNet.Defrag(true);
503    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
504    printf("  Duplicate citations                    : %d\n", DupLinks);
505    printf("  Citations between unknown time nodes   : %d\n", NewCits);
506    printf("  Nodes without time which make citations: %d\n", NewSrcIds);
507    printf("  Nodes without time which are cited     : %d\n", NewDstIds);
508    return TimeNetPt;
509  }
510  PTimeNet TTimeNet::LoadAmazon(const TStr& StlFNm) {
511    PTimeNet TimeNetPt = TTimeNet::New();
512    TTimeNet& TimeNet = *TimeNetPt;
513    TimeNet.Reserve(3953993, -1);
514    printf("Amazon Share-the-Love...\n");
515    char line [2024], MonthStr[4];
516    int NLines=0;
517    TStrV ColV;
518    FILE *F = fopen(StlFNm.CStr(), "rt");
519    while (! feof(F)) {
520      memset(line, 0, 2024);
521      fgets(line, 2024, F);
522      if (strlen(line) == 0) break;
523      TStr(line).SplitOnAllCh(',', ColV);
524      const int SrcNId = ColV[0].GetInt();
525      const int DstNId = ColV[1].GetInt();
526      TStr TmStr = ColV[2]; 
527      int Year = TmStr.GetSubStr(5, 6).GetInt();
528      if (Year < 10) { Year += 2000; } else { Year += 1900; }
529      MonthStr[0]=toupper(TmStr[2]);  MonthStr[1]=tolower(TmStr[3]);
530      MonthStr[2]=tolower(TmStr[4]);  MonthStr[3]=0;
531      const int Month = TTmInfo::GetMonthN(MonthStr, lUs);
532      const int Day = TmStr.GetSubStr(0, 1).GetInt();
533      const int Hour = TmStr.GetSubStr(8, 9).GetInt();
534      const int Min = TmStr.GetSubStr(11, 12).GetInt();
535      const int Sec = TmStr.GetSubStr(14, 15).GetInt();
536      if (! TimeNet.IsNode(SrcNId)) { TimeNet.AddNode(SrcNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
537      if (! TimeNet.IsNode(DstNId)) { TimeNet.AddNode(DstNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
538      if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
539      if (++NLines % 100000 == 0) printf("\r  %dk", NLines/1000);
540    }
541    fclose(F);
542    printf("\r  %d lines read\n", NLines);
543    printf("Graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
544    TimeNet.Defrag(true);
545    return TimeNetPt;
546  }
547  TTimeNENet& TTimeNENet::operator = (const TTimeNENet& TimeNet) {
548    if (this != &TimeNet) {
549      TNet::operator=(TimeNet);
550    }
551    return *this;
552  }
553  PTimeNet TTimeNENet::GetTimeNet() const {
554    PTimeNet NewNet = TTimeNet::New();
555    NewNet->Reserve(GetNodes(), -1);
556    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
557      NewNet->AddNode(NI.GetId(), NI.GetDat());
558    }
559    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
560      const int src = EI.GetSrcNId();
561      const int dst = EI.GetDstNId();
562      if (! NewNet->IsEdge(src, dst)) {
563        NewNet->AddEdge(src, dst); }
564    }
565    NewNet->Defrag();
566    return NewNet;
567  }
568  PTimeNENet TTimeNENet::Get1stEdgeNet() const {
569    PTimeNENet Net = TTimeNENet::New();
570    Net->Reserve(GetNodes(), -1);
571    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
572      Net->AddNode(NI.GetId(), NI.GetDat()); }
573    TIntV EIdV;  GetEIdByTm(EIdV);
574    TIntPrSet EdgeSet(GetEdges());
575    for (int edge = 0; edge < EIdV.Len(); edge++) {
576      const TEdgeI EI = GetEI(EIdV[edge]);
577      const int Src = EI.GetSrcNId();
578      const int Dst = EI.GetDstNId();
579      if (Src==Dst || EdgeSet.IsKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)))) { continue; } 
580      EdgeSet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)));
581      Net->AddEdge(EI);
582    }
583    return Net;
584  }
585  PTimeNENet TTimeNENet::GetSubGraph(const TIntV& NIdV) const {
586    PTimeNENet NewNetPt = TTimeNENet::New();
587    TTimeNENet& NewNet = *NewNetPt;
588    NewNet.Reserve(NIdV.Len(), -1);
589    int node, edge;
590    TNodeI NI;
591    for (node = 0; node < NIdV.Len(); node++) {
592      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node]));
593    }
594    for (node = 0; node < NIdV.Len(); node++) {
595      NI = GetNI(NIdV[node]);
596      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
597        const TEdgeI EI = GetEI(NI.GetOutEId(edge));
598        if (NewNet.IsNode(EI.GetDstNId())) {
599          NewNet.AddEdge(EI); }
600      }
601    }
602    NewNet.Defrag();
603    return NewNetPt;
604  }
605  PTimeNENet TTimeNENet::GetESubGraph(const TIntV& EIdV) const {
606    PTimeNENet NewNetPt = TTimeNENet::New();
607    TTimeNENet& NewNet = *NewNetPt;
608    NewNet.Reserve(-1, EIdV.Len());
609    for (int edge = 0; edge < EIdV.Len(); edge++) {
610      const TEdgeI Edge = GetEI(EIdV[edge]);
611      if (! NewNet.IsNode(Edge.GetSrcNId()))
612        NewNet.AddNode(GetNI(Edge.GetSrcNId()));
613      if (! NewNet.IsNode(Edge.GetDstNId()))
614        NewNet.AddNode(GetNI(Edge.GetDstNId()));
615      NewNet.AddEdge(Edge);
616    }
617    NewNet.Defrag();
618    return NewNetPt;
619  }
620  PTimeNENet TTimeNENet::GetGraphUpToTm(const TSecTm& MaxEdgeTm) const {
621    PTimeNENet NewNetPt = TTimeNENet::New();
622    TTimeNENet& NewNet = *NewNetPt;
623    TSecTm PrevTm;
624    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
625      if (EI() > MaxEdgeTm) { break; }
626      if (! NewNet.IsNode(EI.GetSrcNId()))
627        NewNet.AddNode(GetNI(EI.GetSrcNId()));
628      if (! NewNet.IsNode(EI.GetDstNId()))
629        NewNet.AddNode(GetNI(EI.GetDstNId()));
630      NewNet.AddEdge(EI);
631      IAssert(! PrevTm.IsDef() || PrevTm <= EI()); 
632      PrevTm = EI();
633    }
634    NewNet.Defrag();
635    return NewNetPt;
636  }
637  void TTimeNENet::SortNodeEdgeTimes() {
638    NodeH.SortByDat(true);
639    EdgeH.SortByDat(true);
640  }
641  void TTimeNENet::UpdateNodeTimes() {
642    int Cnt = 0;
643    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
644      TSecTm& NodeTm = NI();
645      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
646        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));
647        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
648      }
649      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
650        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));
651        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
652      }
653    }
654    printf("Update node times: %d/%d updates\n", Cnt, GetNodes());
655  }
656  void TTimeNENet::SetNodeTmToFirstEdgeTm() {
657    int Cnt = 0;
658    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
659      if (NI.GetDeg() == 0) { continue; }
660      TSecTm NodeTm;
661      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
662        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));  IAssert(EdgeTm.IsDef());
663        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
664      }
665      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
666        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));  IAssert(EdgeTm.IsDef());
667        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
668      }
669      GetNDat(NI.GetId()) = NodeTm;
670    }
671    printf("Node times set: %d/%d updates\n", Cnt, GetNodes());
672  }
673  void TTimeNENet::SetRndEdgeTimes(const int& MinTmEdge) {
674    printf("Shuffling last %d (%d%%) edge arrival times..\n", GetEdges()-MinTmEdge, int(100.0*(GetEdges()-MinTmEdge)/double(GetEdges())));
675    TIntV RndEIdV;  GetEIdByTm(RndEIdV);
676    TIntV TrueEIdV = RndEIdV;
677    TSecTmV TrueTmV;
678    const int SwapLen = RndEIdV.Len()-MinTmEdge;
679    for (int R = 0; R < 10; R++) {
680      for (int i = MinTmEdge; i < RndEIdV.Len(); i++) {
681        RndEIdV.Swap(TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge, TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge); }
682    }
683    for (int e = 0; e < TrueEIdV.Len(); e++) {
684      TrueTmV.Add(GetEDat(TrueEIdV[e])); }
685    for (int e = 0; e < RndEIdV.Len(); e++) {
686      GetEDat(RndEIdV[e]) = TrueTmV[e]; }
687    UpdateNodeTimes();
688  }
689  void TTimeNENet::DumpTimeStat() const {
690    TSecTm MnNodeTm, MxNodeTm;
691    TSecTm MnEdgeTm, MxEdgeTm;
692    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
693      const TSecTm NodeTm = NI();
694      if (! MnNodeTm.IsDef() || MnNodeTm>NodeTm) { MnNodeTm = NodeTm; }
695      if (! MxNodeTm.IsDef() || MxNodeTm<NodeTm) { MxNodeTm = NodeTm; }
696    }
697    printf("Node times:\n  %s\n  %s\n", MnNodeTm.GetStr().CStr(), MxNodeTm.GetStr().CStr());
698    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
699      const TSecTm EdgeTm = EI();
700      if (! MnEdgeTm.IsDef() || MnEdgeTm>EdgeTm) { MnEdgeTm = EdgeTm; }
701      if (! MxEdgeTm.IsDef() || MxEdgeTm<EdgeTm) { MxEdgeTm = EdgeTm; }
702    }
703    printf("Edge times:\n  %s\n  %s\n", MnEdgeTm.GetStr().CStr(), MxEdgeTm.GetStr().CStr());
704  }
705  void TTimeNENet::GetNIdByTm(TIntV& NIdV) const {
706    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
707    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
708      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
709    TmToNIdV.Sort();
710    NIdV.Gen(GetNodes(), 0);
711    for (int i = 0; i < TmToNIdV.Len(); i++) {
712      NIdV.Add(TmToNIdV[i].Dat); }
713  }
714  void TTimeNENet::GetEIdByTm(TIntV& EIdV) const {
715    TVec<TKeyDat<TSecTm, TInt> > TmToEIdV(GetEdges(), 0);
716    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
717      TmToEIdV.Add(TKeyDat<TSecTm, TInt>(EI.GetDat(), EI.GetId())); }
718    TmToEIdV.Sort();
719    EIdV.Gen(GetEdges(), 0);
720    for (int i = 0; i < TmToEIdV.Len(); i++) {
721      EIdV.Add(TmToEIdV[i].Dat); }
722  }
723  void TTimeNENet::GetTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
724    THash<TInt, TIntV> TmIdToNIdVH;
725    TIntV NIdV;  GetNIdByTm(NIdV);
726    for (int n = 0; n < NIdV.Len(); n++) {
727      const int TmId = GetNDat(NIdV[n]).Round(TmUnit).GetAbsSecs();
728      if (! TmIdToNIdVH.IsKey(TmId)) { TmIdToNIdVH.AddKey(TmId); }
729      TmIdToNIdVH.GetDat(TmId).Add(NIdV[n]);
730    }
731    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
732    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
733    TmIdNIdVV.Sort();
734    TmBucketV.Gen(TmIdNIdVV.Len());
735    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
736      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
737      Bucket.BegTm = TmIdNIdVV[i].Val1;
738      Bucket.NIdV = TmIdNIdVV[i].Val2;
739    }
740  }
741  void TTimeNENet::GetEdgeTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
742    THash<TInt, TIntV> TmIdToEIdVH;
743    TIntV EIdV;  GetEIdByTm(EIdV);
744    for (int e = 0; e < EIdV.Len(); e++) {
745      const int TmId = GetEDat(EIdV[e]).Round(TmUnit).GetAbsSecs();
746      if (! TmIdToEIdVH.IsKey(TmId)) { TmIdToEIdVH.AddKey(TmId); }
747      TmIdToEIdVH.GetDat(TmId).Add(EIdV[e]);
748    }
749    TVec<TPair<TInt, TIntV> > TmIdEIdVV;
750    TmIdToEIdVH.GetKeyDatPrV(TmIdEIdVV);
751    TmIdEIdVV.Sort();
752    TmBucketV.Gen(TmIdEIdVV.Len());
753    for (int i = 0; i < TmIdEIdVV.Len(); i++) {
754      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
755      Bucket.BegTm = TmIdEIdVV[i].Val1;
756      Bucket.NIdV = TmIdEIdVV[i].Val2;
757    }
758  }
759  void TTimeNENet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
760    TIntV NIdV;  GetNIdByTm(NIdV);
761    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
762    for (int i = 0; i < NIdV.Len(); i++) {
763      const int b = i/NodesPerBucket;
764      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
765      TmBucketV[b].NIdV.Add(NIdV[i]);
766    }
767  }
768  void TTimeNENet::GetEdgeBuckets(const int EdgesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
769    TIntV EIdV;  GetEIdByTm(EIdV);
770    TmBucketV.Gen(EIdV.Len()/EdgesPerBucket + 1, 0);
771    for (int i = 0; i < EIdV.Len(); i++) {
772      const int b = i/EdgesPerBucket;
773      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
774      TmBucketV[b].NIdV.Add(EIdV[i]);
775    }
776  }
777  int TTimeNENet::GetTriadEdges(TIntV& TriadEIdV) const {
778    PUNGraph Graph = TUNGraph::New(GetNodes(), GetEdges());
779    TIntV EIdV;  GetEIdByTm(EIdV);
780    TriadEIdV.Clr();
781    TExeTm ExeTm;
782    for (int edge = 0; edge < EIdV.Len(); edge++) {
783      const TEdgeI EI = GetEI(EIdV[edge]);
784      const int Src = EI.GetSrcNId();
785      const int Dst = EI.GetDstNId();
786      if (Src==Dst || Graph->IsEdge(Src, Dst)) { continue; } 
787      if (! Graph->IsNode(Src)) { Graph->AddNode(Src); }
788      if (! Graph->IsNode(Dst)) { Graph->AddNode(Dst); }
789      if (TSnap::GetCmnNbrs(Graph, Src, Dst) > 0) { TriadEIdV.Add(EIdV[edge]); }
790      Graph->AddEdge(Src, Dst);
791      if (edge % 10000 == 0) {
792        printf("\redges %dk / %dk: triangle edges: %dk [total %s]", edge/1000, EIdV.Len()/1000,
793          TriadEIdV.Len()/1000, ExeTm.GetStr()); }
794    }
795    return Graph->GetEdges();
796  }
797  PGStatVec TTimeNENet::TimeGrowth(const TTmUnit& TimeStep, const TFSet& TakeStat, const TSecTm& StartTm) const {
798    TExeTm ExeTm;
799    PGStatVec GStatVec = TGStatVec::New(TimeStep, TakeStat);
800    TTimeNet::TTmBucketV TmBucketV;
801    GetEdgeTmBuckets(TimeStep, TmBucketV);
802    const PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
803    TIntV EdgeIdV;
804    for (int t = 0; t < TmBucketV.Len(); t++) {
805      EdgeIdV.AddV(TmBucketV[t].NIdV); 
806      printf("\n***%d/%d: %s (%d edges) ", t+1, TmBucketV.Len(), TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
807      if (TmBucketV[t].BegTm < StartTm) { continue; }
808      const PNEGraph PreGraph = TSnap::GetESubGraph(FullGraph, EdgeIdV);
809      GStatVec->Add(PreGraph, TmBucketV[t].BegTm);
810      printf("  [%s]\n", ExeTm.GetTmStr());
811    }
812    return GStatVec;
813  }
814  PGStatVec TTimeNENet::TimeGrowth(const TStr& FNmPref, const TStr& Desc, const TFSet& TakeStat, const int& NDiamRuns,
815                              const TTmUnit& TmUnit, const int& TakeNTmUnits, const bool& LinkBWays) const {
816    TGStat::NDiamRuns = NDiamRuns;
817    PGStatVec GrowthStat = TGStatVec::New(TmUnit, TakeStat);
818    TTimeNet::TTmBucketV TmBucketV;
819    GetEdgeTmBuckets(TmUnit, TmBucketV);
820    TIntV EdgeIdV;
821    TExeTm ExeTm;
822    for (int t = 0; t < TmBucketV.Len(); t++) {
823      if (TakeNTmUnits == -1) {
824        EdgeIdV.AddV(TmBucketV[t].NIdV); }
825      else {
826        if (t < TakeNTmUnits) { continue; }
827        EdgeIdV.Clr(false);
828        for (int i = t-TakeNTmUnits; i < t; i++) { EdgeIdV.AddV(TmBucketV[i].NIdV); }
829      }
830      printf("*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
831      PNEGraph PreGraph = TSnap::ConvertESubGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this), EdgeIdV);
832      if (LinkBWays) {
833        TIntV KeepEIdV; 
834        for (TNEGraph::TEdgeI EI = PreGraph->BegEI(); EI < PreGraph->EndEI(); EI++) {
835          if (PreGraph->IsEdge(EI.GetDstNId(), EI.GetSrcNId(), true)) { KeepEIdV.Add(EI.GetId()); }
836        }
837        PreGraph = TSnap::GetESubGraph(PreGraph, KeepEIdV);
838      }
839      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
840      { TFOut FOut(TStr::Fmt("growth.%s.gStatVec", FNmPref.CStr()));
841      GrowthStat->Save(FOut); }
842      GrowthStat->SaveTxt(FNmPref, Desc);
843      printf("  [%s]\n", ExeTm.GetTmStr());
844    }
845    return GrowthStat;
846  }
847  void TTimeNENet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
848                               const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc) const {
849    TTimeNet::TTmBucketV TmBucketV;
850    GetEdgeTmBuckets(TmUnit, TmBucketV);
851    PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
852    TIntV EdgeIdV;
853    TExeTm ExeTm, Run1Tm;
854    TFltTrV TmDiamV, NdsDiamV;
855    for (int t = 0; t < TmBucketV.Len(); t++) {
856      EdgeIdV.AddV(TmBucketV[t].NIdV); 
857      printf("\n*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), EdgeIdV.Len());  ExeTm.Tick();
858      if (TmBucketV[t].BegTm < StartTm) continue;
859      PNGraph PreGraph = TSnap::ConvertESubGraph<PNGraph>(FullGraph, EdgeIdV);
860      TMom Mom;
861      double EffDiam = 0.0;
862      for (int r = 0; r < NDiamRuns; r++) {
863        printf("%d...", r+1);  Run1Tm.Tick();
864        if (OnlyWcc) { EffDiam = TSnap::GetAnfEffDiam(TSnap::GetMxWcc(PreGraph)); }
865        else { EffDiam = TSnap::GetAnfEffDiam(PreGraph); }
866        Mom.Add(EffDiam);
867        printf("[%s]\r", Run1Tm.GetTmStr());
868      }
869      Mom.Def();
870      TmDiamV.Add(TFltTr(TmBucketV[t].BegTm.Round(TmUnit).GetAbsSecs(), Mom.GetMean(), Mom.GetSDev()));
871      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
872      NdsDiamV.Sort();
873      printf("  [%s]          \n", ExeTm.GetTmStr());
874      const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
875      { TGnuPlot GnuPlot("diamEff1."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
876      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), "AVERAGE "+WccStr+"Effective Diameter");
877      GnuPlot.AddErrBar(TmDiamV, "", "");
878      GnuPlot.SavePng(); }
879      { TGnuPlot GnuPlot("diamEff2."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
880      GnuPlot.SetXYLabel("NODES", "AVERAGE "+WccStr+"Effective Diameter");
881      GnuPlot.AddErrBar(NdsDiamV, "", "");
882      GnuPlot.SavePng(); }
883    }
884  }
885  void TTimeNENet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
886                                   const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam, const bool& LinkBWays) {
887    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
888      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
889    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
890      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
891  }
892  PTimeNENet TTimeNENet::GetGnmRndNet(const int& Nodes, const int& Edges) {
893    printf("Generating G_nm(%d, %d)\n", Nodes, Edges);
894    int Src, Dst;
895    PTimeNENet Net = TTimeNENet::New();
896    Net->Reserve(Nodes, Edges);
897    for (int e = 0; e < Edges; e++) {
898      Src = TInt::Rnd.GetUniDevInt(Nodes);
899      Dst = TInt::Rnd.GetUniDevInt(Nodes);
900      while (Dst == Src || Net->IsEdge(Src, Dst)) {
901        Dst = TInt::Rnd.GetUniDevInt(Nodes); }
902      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(e)); }
903      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(e)); }
904      Net->AddEdge(Src, Dst, -1, TSecTm(e));
905    }
906    return Net;
907  }
908  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& Edges, const double& GammaIn, const double& GammaOut) {
909    const double Alpha = Nodes/double(Edges);
910    printf("Generating PA(%d, %d), with slope in:%.1f, out: %.1f\n", Nodes, Edges,
911      2+GammaIn/(Alpha/(1-Alpha)), 2+GammaOut/(Alpha/(1-Alpha)));
912    int nodes=0, edges=0, time=0, iter=0;
913    TIntV OutW(Edges, 0), InW(Edges, 0);
914    PTimeNENet Net = TTimeNENet::New();
915    Net->Reserve(Nodes, Edges);
916    Net->AddNode(0, TSecTm(time++));  nodes++;
917    OutW.Add(0);  InW.Add(0);
918    while (edges < Edges) {
919      int Src=-1, Dst=-1;  iter++;
920      if (TInt::Rnd.GetUniDev() < Alpha) {
921        if (nodes < Nodes) {
922          IAssert(Net->AddNode(nodes, TSecTm(time++)));
923          nodes++; }
924      } else {
925        if (TInt::Rnd.GetUniDev() < nodes*GammaIn/double(edges+nodes*GammaIn)) {
926          Src = TInt::Rnd.GetUniDevInt(nodes); }
927        else { Src = OutW[TInt::Rnd.GetUniDevInt(OutW.Len())]; }
928        if (TInt::Rnd.GetUniDev() < nodes*GammaOut/double(edges+nodes*GammaOut)) {
929          Dst = TInt::Rnd.GetUniDevInt(nodes); }
930        else { Dst = InW[TInt::Rnd.GetUniDevInt(InW.Len())]; }
931      }
932      if (Src == Dst || Net->IsEdge(Src, Dst)) {
933        continue;
934      }
935      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(time++)); nodes++; }
936      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(time++)); nodes++; }
937      Net->AddEdge(Src, Dst, -1, TSecTm(time++));
938      OutW.Add(Src); InW.Add(Dst); edges++;
939    }
940    for (int node = 0; node < Nodes; node++) {
941      if (! Net->IsNode(node)) {
942        Net->AddNode(node, TSecTm(time++)); }
943    }
944    return Net;
945  }
946  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& OutDeg) {
947    printf("Generating PA, nodes:%d, out-deg:%d\n", Nodes, OutDeg);
948    int time=0;
949    PTimeNENet Net = TTimeNENet::New();
950    Net->Reserve(Nodes, OutDeg*Nodes);
951    Net->AddNode(0, TSecTm(++time));  Net->AddNode(1, TSecTm(++time));
952    Net->AddEdge(0, 1, -1, TSecTm(++time));
953    TIntV NIdV;  NIdV.Add(0);  NIdV.Add(1);
954    TIntSet NodeSet;
955    for (int node = 2; node <= Nodes; node++) {
956      NodeSet.Clr(false);
957      while (NodeSet.Len() < OutDeg && NodeSet.Len() < node) {
958        NodeSet.AddKey(NIdV[TInt::Rnd.GetUniDevInt(NIdV.Len())]);
959      }
960      const int N = Net->AddNode(node, TSecTm(++time));
961      for (int i = 0; i < NodeSet.Len(); i++) {
962        Net->AddEdge(node, NodeSet[i], -1, TSecTm(++time));
963        NIdV.Add(N);  NIdV.Add(NodeSet[i]);
964      }
965    }
966    return Net;
967  }
968  void TTimeNENet::SaveEdgeTm(const TStr& EdgeFNm, const bool& RenumberNId, const bool& RelativeTm) const {
969    TIntV EIdV;  GetEIdByTm(EIdV);
970    const int BegTm = RelativeTm ? GetEDat(EIdV[0]).GetAbsSecs() : 0;
971    TIntSet NIdMap;
972    if (RenumberNId) { NIdMap.Gen(GetNodes()); }
973    FILE *F = fopen(EdgeFNm.CStr(), "wt");
974    for (int e =0; e < EIdV.Len(); e++) {
975      const TEdgeI EI = GetEI(EIdV[e]);
976      if (RenumberNId) {
977        const int src = EI.GetSrcNId();
978        const int dst = EI.GetDstNId();
979        NIdMap.AddKey(src);  NIdMap.AddKey(dst);
980        fprintf(F, "%d\t%d\t%d\n", NIdMap.GetKeyId(src), NIdMap.GetKeyId(dst), EI().GetAbsSecs()-BegTm);
981      }else {
982        fprintf(F, "%d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI().GetAbsSecs()-BegTm); }
983    }
984    fclose(F);
985  }
986  PTimeNENet TTimeNENet::GetSmallNet() {
987    PTimeNENet Net = TTimeNENet::New();
988    for (int i = 1; i <= 6; i++) {
989      Net->AddNode(i, TSecTm(0)); }
990    int tm = 1;
991    Net->AddEdge(1, 2, -1, TSecTm(tm++));
992    Net->AddEdge(3, 4, -1, TSecTm(tm++));
993    Net->AddEdge(3, 1, -1, TSecTm(tm++));
994    Net->AddEdge(5, 6, -1, TSecTm(tm++));
995    Net->AddEdge(6, 4, -1, TSecTm(tm++));
996    Net->AddEdge(5, 3, -1, TSecTm(tm++));
997    Net->AddEdge(5, 4, -1, TSecTm(tm++));
998    Net->AddEdge(5, 2, -1, TSecTm(tm++));
999    return Net;
1000  }
1001  PTimeNENet TTimeNENet::LoadFlickr(const TStr& NodeFNm, const TStr& EdgeFNm) {
1002    const int BegOfTm = 1047369600; 
1003    PTimeNENet Net = TTimeNENet::New();
1004    printf("Adding nodes...");
1005    { TSsParser Ss(NodeFNm, ssfWhiteSep);
1006    while (Ss.Next()) {
1007      const int NId = Ss.GetInt(0);
1008      const int Tm = Ss.GetInt(1)+BegOfTm;
1009      if (TSecTm(Tm) < TSecTm(2002, 1, 1)) {
1010        printf("  skip node %g (time %d)\n", (double) Ss.GetLineNo(), Ss.GetInt(1)); continue; }
1011      Net->AddNode(NId, TSecTm(Tm));
1012    } }
1013    printf(" %d nodes\n", Net->GetNodes());
1014    printf("Adding edges...");
1015    int SkipCnt=0;
1016    { TSsParser Ss(EdgeFNm, ssfWhiteSep);
1017    while (Ss.Next()) {
1018      const int NId1 = Ss.GetInt(0);
1019      const int NId2 = Ss.GetInt(1);
1020      const TSecTm Tm = TSecTm(Ss.GetInt(2)+BegOfTm);
1021      if (! Net->IsNode(NId1) || ! Net->IsNode(NId2)) { printf("not node\n"); continue; }
1022      if (Tm < TSecTm(2002, 1, 1)) { SkipCnt++;
1023        printf("  skip edge %g (time %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr()); continue; }
1024      if (Tm+600 < Net->GetNDat(NId1)) {
1025        printf("  1:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId1).GetStr().CStr());
1026        SkipCnt++;  continue; }
1027      if (Tm+600 < Net->GetNDat(NId2)) { SkipCnt++;
1028        printf("  2:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId2).GetStr().CStr());
1029        SkipCnt++;  continue; }
1030      Net->AddEdge(NId1, NId2, -1, TSecTm(Tm));
1031    } }
1032    printf("  %d edges\n", Net->GetEdges());
1033    printf("  %d edges skipped (edge time < node time)\n", SkipCnt);
1034    Net->UpdateNodeTimes();
1035    return Net;
1036  }
1037  PTimeNENet TTimeNENet::LoadEdgeTm(const TStr& EdgeFNm, const int& SrcFld, const int& DstFld, const int& TimeFld, const TSsFmt& Separator) {
1038    printf("Loading %s\n", EdgeFNm.CStr());
1039    PTimeNENet Net = TTimeNENet::New();
1040    TStrHash<TInt> StrToId(Mega(1), true); 
1041    int LineCnt=0;
1042    TExeTm ExeTm;
1043    TSsParser Ss(EdgeFNm, Separator);
1044    TSecTm MinTm=TSecTm::GetCurTm(), MaxTm=TSecTm(100);
1045    while (Ss.Next()) {
1046      if (Ss.IsCmt()) { continue; }
1047      IAssert(Ss.Len() > TimeFld);
1048      const char* Node1 = Ss.GetFld(SrcFld);
1049      const char* Node2 = Ss.GetFld(DstFld);
1050      const char* TmStr = Ss.GetFld(TimeFld);
1051      if (strcmp(TmStr,"NULL")==0) { continue; }
1052      const TSecTm Tm(atoi(TmStr));
1053      const int NId1 = StrToId.AddKey(Node1);
1054      const int NId2 = StrToId.AddKey(Node2);
1055      if (! Net->IsNode(NId1)) { Net->AddNode(NId1, TSecTm()); }
1056      if (! Net->IsNode(NId2)) { Net->AddNode(NId2, TSecTm()); }
1057      MinTm=TMath::Mn(MinTm, Tm);
1058      MaxTm=TMath::Mx(MaxTm, Tm);
1059      Net->AddEdge(NId1, NId2, -1, Tm);
1060      if (++LineCnt % 1000 == 0) {
1061        printf("\r  %dk lines processed: %d %d [%s]", LineCnt/1000, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr()); }
1062    }
1063    printf("\r  %d lines processed: %d %d [%s]\n", LineCnt, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr());
1064    printf("  Data range %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1065    Net->UpdateNodeTimes();
1066    return Net;
1067  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>434                      for (int h = hstart; h < hend; ++h) {
435                        for (int w = wstart; w < wend; ++w) {
436                          const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
</pre></code></div>
                <div class="column column_space"><pre><code>110      { TMom Mom;
111      for (int r = 0; r < NDiamRuns; r++) {
112        printf("%d...", r+1);  Run1Tm.Tick();
113        const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph) : PreGraph);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    