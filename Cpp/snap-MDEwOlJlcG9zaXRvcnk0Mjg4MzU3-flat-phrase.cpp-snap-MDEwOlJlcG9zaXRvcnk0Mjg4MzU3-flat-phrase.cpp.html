
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-phrase.cpp</h3>
            <pre><code>1  TStr TNGramBs::GetWIdVStr(const TIntV& WIdV) const {
2    TChA ChA;
3    for (int WIdN=0; WIdN<WIdV.Len(); WIdN++){
4      if (WIdN>0){ChA+=' '&bsol;*'_'*/;} ChA+=GetWordStr(WIdV[WIdN]);}
5    if (ChA=="THE TCP PACKET"){ }
6    return ChA;
7  }
8  TStr TNGramBs::GetNGramStr(const int& NGramId) const {
9    int Words=WordStrToFqH.Len();
10    if (NGramId<Words){ 
11      return WordStrToFqH.GetKey(NGramId);
12    } else { 
13      const TIntV& WIdV=WIdVToFqH.GetKey(NGramId-Words);
14      return GetWIdVStr(WIdV);
15    }
16  }
17  int TNGramBs::GetNGramFq(const int& NGramId) const {
18    int Words=WordStrToFqH.Len();
19    if (NGramId<Words){ 
20      return WordStrToFqH[NGramId];
21    } else { 
22      return WIdVToFqH[NGramId-Words];
23    }
24  }
25  void TNGramBs::GetNGramStrFq(const int& NGramId, TStr& NGramStr, int& NGramFq) const {
26    int Words=WordStrToFqH.Len();
27    if (NGramId<Words){
28      NGramStr=WordStrToFqH.GetKey(NGramId);
29      NGramFq=WordStrToFqH[NGramId];
30    } else {
31      const TIntV& WIdV=WIdVToFqH.GetKey(NGramId-Words);
32      NGramStr=GetWIdVStr(WIdV);
33      NGramFq=WIdVToFqH[NGramId-Words];
34    }
35  }
36  void TNGramBs::GetNGramIdV(
37   const TStr& HtmlStr, TIntV& NGramIdV, TIntPrV& NGramBEChXPrV) const {
38    TVec<TIntQ> WIdQV(MxNGramLen);
39    TVec<TIntPrQ> BEChXPrQV(MxNGramLen);
40    for (int NGramLen=1; NGramLen<MxNGramLen; NGramLen++){
41      WIdQV[NGramLen].Gen(100*NGramLen, NGramLen+1);
42      BEChXPrQV[NGramLen].Gen(100*NGramLen, NGramLen+1);
43    }
44    bool AllWIdQClrP=true;
45    PSIn HtmlSIn=TStrIn::New(HtmlStr);
46    THtmlLx HtmlLx(HtmlSIn);
47    while (HtmlLx.Sym!=hsyEof){
48      if ((HtmlLx.Sym==hsyStr)||(HtmlLx.Sym==hsyNum)){
49        TStr WordStr=HtmlLx.UcChA;
50        int WId; int SymBChX=HtmlLx.SymBChX; int SymEChX=HtmlLx.SymEChX;
51        if ((SwSet.Empty())||(!SwSet->IsIn(WordStr))){
52          if (!Stemmer.Empty()){
53            WordStr=Stemmer->GetStem(WordStr);}
54          if (IsWord(WordStr, WId)){
55            if (!IsSkipWord(WId)){
56              NGramIdV.Add(0+WId); 
57              NGramBEChXPrV.Add(TIntPr(SymBChX, SymEChX)); 
58              for (int NGramLen=1; NGramLen<MxNGramLen; NGramLen++){
59                TIntQ& WIdQ=WIdQV[NGramLen];
60                TIntPrQ& BEChXPrQ=BEChXPrQV[NGramLen];
61                WIdQ.Push(WId); BEChXPrQ.Push(TIntPr(SymBChX, SymEChX));
62                AllWIdQClrP=false;
63                if (WIdQ.Len()==NGramLen+1){
64                  TIntV WIdV; WIdQ.GetSubValV(0, WIdQ.Len()-1, WIdV);
65                  TIntPrV BEChXPrV; BEChXPrQ.GetSubValV(0, BEChXPrQ.Len()-1, BEChXPrV);
66                  int WIdVP;
67                  if (WIdVToFqH.IsKey(WIdV, WIdVP)){ 
68                    int NGramId=GetWords()+WIdVP; 
69                    NGramIdV.Add(NGramId); 
70                    NGramBEChXPrV.Add(TIntPr(BEChXPrV[0].Val1, BEChXPrV.Last().Val2)); 
71                  }
72                }
73              }
74            }
75          } else {
76            if (!AllWIdQClrP){
77              for (int NGramLen=1; NGramLen<MxNGramLen; NGramLen++){
78                TIntQ& WIdQ=WIdQV[NGramLen];
79                TIntPrQ& BEChXPrQ=BEChXPrQV[NGramLen];
80                if (!WIdQ.Empty()){WIdQ.Clr(); BEChXPrQ.Clr();}
81              }
82              AllWIdQClrP=true;
83            }
84          }
85        }
86      }
87      HtmlLx.GetSym();
88    }
89  }
90  void TNGramBs::GetNGramStrV(
91   const TStr& HtmlStr, TStrV& NGramStrV, TIntPrV& NGramBEChXPrV) const {
92    TIntV NGramIdV; NGramStrV.Clr(); NGramBEChXPrV.Clr();
93    TNGramBs::GetNGramIdV(HtmlStr, NGramIdV, NGramBEChXPrV);
94    NGramStrV.Gen(NGramIdV.Len(), 0);
95    for (int NGramIdN=0; NGramIdN<NGramIdV.Len(); NGramIdN++){
96      TStr NGramStr=GetNGramStr(NGramIdV[NGramIdN]);
97      NGramStrV.Add(NGramStr);
98    }
99  }
100  void TNGramBs::GetNGramStrV(const TStr& HtmlStr, TStrV& NGramStrV) const {
101    TIntPrV NGramBEChXPrV; GetNGramStrV(HtmlStr, NGramStrV, NGramBEChXPrV);
102  }
103  void TNGramBs::AddWordToCand(const int& WId){
104    Assert(PassN>1);
105    Assert(WId!=-1);
106    Assert(GetWordFq(WId)>=MnNGramFq);
107    CandWIdQ.Push(WId); 
108    int CandWIdQLen=CandWIdQ.Len(); 
109    if (CandWIdQLen==1){return;} 
110    if (PassN==2){ 
111      if (CandWIdQLen==PassN){
112        CandWIdPrToFqH.AddDat(TIntPr(CandWIdQ[0], CandWIdQ[1]))++;}
113    } else { 
114      if ((1<CandWIdQLen)&&(CandWIdQLen<PassN)){
115        TIntV SubWIdV; CandWIdQ.GetSubValV(0, CandWIdQ.Len()-1, SubWIdV);
116        int SubWIdVId=WIdVToFqH.GetKeyId(SubWIdV);
117        if (SubWIdVId==-1){BreakNGram();}
118      } else {
119        Assert(CandWIdQLen==PassN);
120        TIntV SubWIdV; CandWIdQ.GetSubValV(1, CandWIdQ.Len()-1, SubWIdV);
121        int SubWIdVId=WIdVToFqH.GetKeyId(SubWIdV);
122        if (SubWIdVId==-1){
123          BreakNGram(); 
124        } else {
125          TIntV WIdV; CandWIdQ.GetSubValV(0, CandWIdQ.Len()-1, WIdV);
126          CandWIdVToFqH.AddDat(WIdV)++;
127        }
128      }
129    }
130  }
131  int TNGramBs::AddWord(const TStr& WordStr){
132    int WId=-1;
133    if (PassN==1){ 
134      WId=WordStrToFqH.AddKey(WordStr); 
135      WordStrToFqH[WId]++; 
136    } else { 
137      WId=GetWId(WordStr); 
138      if (WId==-1){ 
139        BreakNGram(); 
140      } else
141      if (GetWordFq(WId)!=-1){ 
142        AddWordToCand(WId); 
143      }
144    }
145    return WId;
146  }
147  void TNGramBs::ConcPass(){
148    IAssert(!IsFinished());
149    if (PassN==1){ 
150      TIntV DelWIdV; 
151      int WIds=WordStrToFqH.Len(); 
152      for (int WId=0; WId<WIds; WId++){
153        TStr WordStr=WordStrToFqH.GetKey(WId); 
154        if (WordStrToFqH[WId]<MnNGramFq){
155          DelWIdV.Add(WId); 
156        }
157      }
158      WordStrToFqH.DelKeyIdV(DelWIdV);
159      WordStrToFqH.Defrag();
160    } else
161    if (PassN==2){ 
162      int Cands=CandWIdPrToFqH.Len(); 
163      TIntV WIdV(2); 
164      for (int CandId=0; CandId<Cands; CandId++){
165        int CandFq=CandWIdPrToFqH[CandId]; 
166        if (CandFq>=MnNGramFq){ 
167          const TIntPr& WIdPr=CandWIdPrToFqH.GetKey(CandId); 
168          WIdV[0]=WIdPr.Val1; WIdV[1]=WIdPr.Val2; 
169          WIdVToFqH.AddDat(WIdV, CandFq); 
170        }
171      }
172      CandWIdPrToFqH.Clr();
173    } else
174    if (PassN>2){ 
175      int Cands=CandWIdVToFqH.Len(); 
176      for (int CandId=0; CandId<Cands; CandId++){
177        int CandFq=CandWIdVToFqH[CandId]; 
178        if (CandFq>=MnNGramFq){ 
179          const TIntV& CandWIdV=CandWIdVToFqH.GetKey(CandId); 
180          WIdVToFqH.AddDat(CandWIdV, CandWIdVToFqH[CandId]); 
181        }
182      }
183      CandWIdVToFqH.Clr();
184    } else {
185      Fail;
186    }
187    PassN++;
188    if (IsFinished()){
189      CandWIdQ.Clr();
190      int WIds=WordStrToFqH.Len(); 
191      for (int WId=0; WId<WIds; WId++){
192        TStr WordStr=WordStrToFqH.GetKey(WId); 
193        if ((!SwSet.Empty())&&(SwSet->IsIn(WordStr))){
194          WordStrToFqH[WId]=-1; 
195        }
196      }
197      for (int WIdVId=0; WIdVId<WIdVToFqH.Len(); WIdVId++){
198        int FirstWId=WIdVToFqH.GetKey(WIdVId)[0]; 
199        int LastWId=WIdVToFqH.GetKey(WIdVId).Last(); 
200        if ((WordStrToFqH[FirstWId]==-1)||(WordStrToFqH[LastWId]==-1)){
201          TStr NGramStr=GetWIdVStr(WIdVToFqH.GetKey(WIdVId));
202          WIdVToFqH[WIdVId]=-1;
203        }
204      }
205      for (int WIdVId=0; WIdVId<WIdVToFqH.Len(); WIdVId++){
206        if (WIdVToFqH.GetKey(WIdVId).Len()>1){
207        }
208      }
209    } else {
210      CandWIdQ.Gen(100*PassN, PassN);
211    }
212  }
213  void TNGramBs::SaveTxt(const TStr& FNm, const bool& SortP) const {
214    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
215    if (SortP){
216      int NGrams=GetNGrams(); TStr NGramStr; int NGramFq;
217      TIntPrV FqNGramIdPrV(GetNGrams(), 0);
218      for (int NGramId=0; NGramId<NGrams; NGramId++){
219        GetNGramStrFq(NGramId, NGramStr, NGramFq);
220        if (NGramFq!=-1){
221          FqNGramIdPrV.Add(TIntPr(NGramFq, NGramId));}
222      }
223      FqNGramIdPrV.Sort(false);
224      for (int NGramN=0; NGramN<FqNGramIdPrV.Len(); NGramN++){
225        int NGramFq=FqNGramIdPrV[NGramN].Val1;
226        int NGramId=FqNGramIdPrV[NGramN].Val2;
227        GetNGramStrFq(NGramId, NGramStr, NGramFq);
228        fprintf(fOut, "'%s': %d\n", NGramStr.CStr(), NGramFq);
229      }
230    } else {
231      int NGrams=GetNGrams(); TStr NGramStr; int NGramFq;
232      for (int NGramId=0; NGramId<NGrams; NGramId++){
233        GetNGramStrFq(NGramId, NGramStr,  NGramFq);
234        if (NGramFq!=-1){
235          fprintf(fOut, "'%s': %d\n", NGramStr.CStr(), NGramFq);}
236      }
237    }
238  }
239  void TNGramBs::_UpdateNGramBsFromHtmlStr(
240   const PNGramBs& NGramBs, const TStr& HtmlStr,
241   const PSwSet& SwSet, const PStemmer& Stemmer){
242    PSIn HtmlSIn=TStrIn::New(HtmlStr);
243    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
244    PHtmlTok Tok; THtmlLxSym Sym; TStr Str;
245    PHtmlLxChDef ChDef=THtmlLxChDef::GetChDef();
246    bool InScript=false;
247    NGramBs->BreakNGram();
248    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
249      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
250      HtmlDoc->GetTok(TokN, Sym, Str);
251      switch (Sym){
252        case hsyUndef: break;
253        case hsySSym: break;
254        case hsyStr:
255        case hsyNum:{
256          if (InScript){break;}
257          TStr UcStr=ChDef->GetUcStr(Str);
258          if (true||(SwSet.Empty())||(!SwSet->IsIn(UcStr))){
259            if (!Stemmer.Empty()){
260              UcStr=Stemmer->GetStem(UcStr);}
261            NGramBs->AddWord(UcStr);
262          }
263          break;}
264        case hsyBTag:
265        case hsyETag:
266          if (Str=="<SCRIPT>"){
267            InScript=(Sym==hsyBTag);}
268          if (THtmlTok::IsBreakTag(Str)){
269            NGramBs->BreakNGram();}
270          break;
271        case hsyEof: break;
272        default: break;
273      }
274    }
275  }
276  PNGramBs TNGramBs::GetNGramBsFromHtmlStrV(
277   const TStrV& HtmlStrV,
278   const int& MxNGramLen, const int& MnNGramFq,
279   const PSwSet& SwSet, const PStemmer& Stemmer){
280    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
281    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
282    while (!NGramBs->IsFinished()){
283      for (int HtmlStrN=0; HtmlStrN<HtmlStrV.Len(); HtmlStrN++){
284        if ((HtmlStrN%10==0)||(HtmlStrN+1==HtmlStrV.Len())){
285          printf("  Pass %2d: %6d/%6d Docs\r", NGramBs->GetPassN(), HtmlStrN+1, HtmlStrV.Len());
286          if (HtmlStrN+1==HtmlStrV.Len()){printf("\n");}
287        }
288        _UpdateNGramBsFromHtmlStr(NGramBs, HtmlStrV[HtmlStrN], SwSet, Stemmer);
289      }
290      NGramBs->ConcPass();
291    }
292    printf("Done.\n");
293    return NGramBs;
294  }
295  PNGramBs TNGramBs::GetNGramBsFromHtmlFPathV(
296   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
297   const int& MxNGramLen, const int& MnNGramFq,
298   const PSwSet& SwSet, const PStemmer& Stemmer){
299    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
300    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
301    while (!NGramBs->IsFinished()){
302      TFFile FFile(FPath, "", RecurseDirP);
303      TStr FNm; int Docs=0;
304      while (FFile.Next(FNm)){
305        Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
306        if (Docs%100==0){
307          printf("  Pass %d: %6d\r", NGramBs->GetPassN(), Docs);}
308        if (TFile::Exists(FNm)) {
309          TStr HtmlStr=TStr::LoadTxt(FNm);
310          _UpdateNGramBsFromHtmlStr(NGramBs, HtmlStr, SwSet, Stemmer);
311        }
312      }
313      NGramBs->ConcPass();
314      printf("  Pass %d: %6d\n", NGramBs->GetPassN()-1, Docs);
315    }
316    printf("Done.\n");
317    return NGramBs;
318  }
319  PNGramBs TNGramBs::GetNGramBsFromCpd(
320   const PSIn& CpdSIn, const int& MxDocs,
321   const int& MxNGramLen, const int& MnNGramFq,
322   const PSwSet& SwSet, const PStemmer& Stemmer){
323    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
324    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
325    while (!NGramBs->IsFinished()){
326      PSIn CpDocSIn=TCpDoc::FFirstCpd(CpdSIn);
327      PCpDoc CpDoc; int Docs=0;
328      while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
329        Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
330        if (Docs%100==0){
331          printf("  Pass %d: %6d\r", NGramBs->GetPassN(), Docs);}
332        TStr DocStr=CpDoc->GetTxtStr();
333        _UpdateNGramBsFromHtmlStr(NGramBs, DocStr, SwSet, Stemmer);
334      }
335      NGramBs->ConcPass();
336      printf("  Pass %d: %6d\n", NGramBs->GetPassN()-1, Docs);
337      if (!NGramBs->IsFinished()){
338        CpdSIn->Reset();}
339    }
340    printf("Done.\n");
341    return NGramBs;
342  }
343  PNGramBs TNGramBs::GetNGramBsFromTBs(
344   const TStr& TBsFNm, const int& MxDocs,
345   const int& MxNGramLen, const int& MnNGramFq,
346   const PSwSet& SwSet, const PStemmer& Stemmer){
347    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
348    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
349    while (!NGramBs->IsFinished()){
350      TStr TxtBsNm=TBsFNm.GetFBase();
351      TStr TxtBsFPath=TBsFNm.GetFPath();
352      PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
353      TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
354      while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
355        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
356        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
357        TStr DocNm; TStr DocStr;
358        TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
359        _UpdateNGramBsFromHtmlStr(NGramBs, DocStr, SwSet, Stemmer);
360      }
361      NGramBs->ConcPass();
362      printf("  Pass %2d: %6d\r", NGramBs->GetPassN(), Docs);
363    }
364    printf("\nDone.\n");
365    return NGramBs;
366  }
367  PNGramBs TNGramBs::GetNGramBsFromLnDoc(
368   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
369   const int& MxNGramLen, const int& MnNGramFq,
370   const PSwSet& SwSet, const PStemmer& Stemmer){
371    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
372    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
373    while (!NGramBs->IsFinished()){
374      TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
375      while (!FIn.Eof()){
376        Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
377        TChA DocNm;
378        if (NamedP){
379          Ch=FIn.GetCh();
380          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
381            DocNm+=Ch; Ch=FIn.GetCh();}
382          DocNm.Trunc();
383          if (DocNm.Empty()){Docs--; continue;}
384        }
385        TStrV CatNmV;
386        forever {
387          while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
388          if (Ch=='!'){
389            TChA CatNm;
390            while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
391              CatNm+=Ch; Ch=FIn.GetCh();}
392            if (!CatNm.Empty()){CatNmV.Add(CatNm);}
393          } else {
394            break;
395          }
396        }
397        TChA DocChA;
398        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
399          DocChA+=Ch; Ch=FIn.GetCh();}
400        printf("  Pass %2d: %6d Docs\r", NGramBs->GetPassN(), Docs);
401        _UpdateNGramBsFromHtmlStr(NGramBs, DocChA, SwSet, Stemmer);
402      }
<span onclick='openModal()' class='match'>403      NGramBs->ConcPass();
404    }
405    printf("\nDone.\n");
406    return NGramBs;
407  }
408  PNGramBs TNGramBs::GetNGramBsFromReuters21578(
409   const TStr& FPath, const int& MxDocs,
</span>410   const int& MxNGramLen, const int& MnNGramFq,
411   const PSwSet& SwSet, const PStemmer& Stemmer){
412    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
413    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
414    while (!NGramBs->IsFinished()){
415      TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
416      while (FFile.Next(FNm)){
417        printf("Processing file '%s'\n", FNm.CStr());
418        TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
419        for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
420          Docs++; printf("  Pass %2d: %6d Docs\r", NGramBs->GetPassN(), Docs);
421          if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
422          PXmlDoc Doc=LDocV[LDocN];
423          PXmlTok DocTok=Doc->GetTok();
424          PXmlTok Tok=Doc->GetTagTok("REUTERS|TEXT");
425          TStr HtmlStr=Tok->GetTokStr(false);
426          _UpdateNGramBsFromHtmlStr(NGramBs, HtmlStr, SwSet, Stemmer);
427        }
428        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
429      }
430      NGramBs->ConcPass();
431      printf("  Pass %2d: %6d Docs\r", NGramBs->GetPassN(), Docs);
432    }
433    printf("\nDone.\n");
434    return NGramBs;
435  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-phrase.cpp</h3>
            <pre><code>1  TStr TNGramBs::GetWIdVStr(const TIntV& WIdV) const {
2    TChA ChA;
3    for (int WIdN=0; WIdN<WIdV.Len(); WIdN++){
4      if (WIdN>0){ChA+=' '&bsol;*'_'*/;} ChA+=GetWordStr(WIdV[WIdN]);}
5    if (ChA=="THE TCP PACKET"){ }
6    return ChA;
7  }
8  TStr TNGramBs::GetNGramStr(const int& NGramId) const {
9    int Words=WordStrToFqH.Len();
10    if (NGramId<Words){ 
11      return WordStrToFqH.GetKey(NGramId);
12    } else { 
13      const TIntV& WIdV=WIdVToFqH.GetKey(NGramId-Words);
14      return GetWIdVStr(WIdV);
15    }
16  }
17  int TNGramBs::GetNGramFq(const int& NGramId) const {
18    int Words=WordStrToFqH.Len();
19    if (NGramId<Words){ 
20      return WordStrToFqH[NGramId];
21    } else { 
22      return WIdVToFqH[NGramId-Words];
23    }
24  }
25  void TNGramBs::GetNGramStrFq(const int& NGramId, TStr& NGramStr, int& NGramFq) const {
26    int Words=WordStrToFqH.Len();
27    if (NGramId<Words){
28      NGramStr=WordStrToFqH.GetKey(NGramId);
29      NGramFq=WordStrToFqH[NGramId];
30    } else {
31      const TIntV& WIdV=WIdVToFqH.GetKey(NGramId-Words);
32      NGramStr=GetWIdVStr(WIdV);
33      NGramFq=WIdVToFqH[NGramId-Words];
34    }
35  }
36  void TNGramBs::GetNGramIdV(
37   const TStr& HtmlStr, TIntV& NGramIdV, TIntPrV& NGramBEChXPrV) const {
38    TVec<TIntQ> WIdQV(MxNGramLen);
39    TVec<TIntPrQ> BEChXPrQV(MxNGramLen);
40    for (int NGramLen=1; NGramLen<MxNGramLen; NGramLen++){
41      WIdQV[NGramLen].Gen(100*NGramLen, NGramLen+1);
42      BEChXPrQV[NGramLen].Gen(100*NGramLen, NGramLen+1);
43    }
44    bool AllWIdQClrP=true;
45    PSIn HtmlSIn=TStrIn::New(HtmlStr);
46    THtmlLx HtmlLx(HtmlSIn);
47    while (HtmlLx.Sym!=hsyEof){
48      if ((HtmlLx.Sym==hsyStr)||(HtmlLx.Sym==hsyNum)){
49        TStr WordStr=HtmlLx.UcChA;
50        int WId; int SymBChX=HtmlLx.SymBChX; int SymEChX=HtmlLx.SymEChX;
51        if ((SwSet.Empty())||(!SwSet->IsIn(WordStr))){
52          if (!Stemmer.Empty()){
53            WordStr=Stemmer->GetStem(WordStr);}
54          if (IsWord(WordStr, WId)){
55            if (!IsSkipWord(WId)){
56              NGramIdV.Add(0+WId); 
57              NGramBEChXPrV.Add(TIntPr(SymBChX, SymEChX)); 
58              for (int NGramLen=1; NGramLen<MxNGramLen; NGramLen++){
59                TIntQ& WIdQ=WIdQV[NGramLen];
60                TIntPrQ& BEChXPrQ=BEChXPrQV[NGramLen];
61                WIdQ.Push(WId); BEChXPrQ.Push(TIntPr(SymBChX, SymEChX));
62                AllWIdQClrP=false;
63                if (WIdQ.Len()==NGramLen+1){
64                  TIntV WIdV; WIdQ.GetSubValV(0, WIdQ.Len()-1, WIdV);
65                  TIntPrV BEChXPrV; BEChXPrQ.GetSubValV(0, BEChXPrQ.Len()-1, BEChXPrV);
66                  int WIdVP;
67                  if (WIdVToFqH.IsKey(WIdV, WIdVP)){ 
68                    int NGramId=GetWords()+WIdVP; 
69                    NGramIdV.Add(NGramId); 
70                    NGramBEChXPrV.Add(TIntPr(BEChXPrV[0].Val1, BEChXPrV.Last().Val2)); 
71                  }
72                }
73              }
74            }
75          } else {
76            if (!AllWIdQClrP){
77              for (int NGramLen=1; NGramLen<MxNGramLen; NGramLen++){
78                TIntQ& WIdQ=WIdQV[NGramLen];
79                TIntPrQ& BEChXPrQ=BEChXPrQV[NGramLen];
80                if (!WIdQ.Empty()){WIdQ.Clr(); BEChXPrQ.Clr();}
81              }
82              AllWIdQClrP=true;
83            }
84          }
85        }
86      }
87      HtmlLx.GetSym();
88    }
89  }
90  void TNGramBs::GetNGramStrV(
91   const TStr& HtmlStr, TStrV& NGramStrV, TIntPrV& NGramBEChXPrV) const {
92    TIntV NGramIdV; NGramStrV.Clr(); NGramBEChXPrV.Clr();
93    TNGramBs::GetNGramIdV(HtmlStr, NGramIdV, NGramBEChXPrV);
94    NGramStrV.Gen(NGramIdV.Len(), 0);
95    for (int NGramIdN=0; NGramIdN<NGramIdV.Len(); NGramIdN++){
96      TStr NGramStr=GetNGramStr(NGramIdV[NGramIdN]);
97      NGramStrV.Add(NGramStr);
98    }
99  }
100  void TNGramBs::GetNGramStrV(const TStr& HtmlStr, TStrV& NGramStrV) const {
101    TIntPrV NGramBEChXPrV; GetNGramStrV(HtmlStr, NGramStrV, NGramBEChXPrV);
102  }
103  void TNGramBs::AddWordToCand(const int& WId){
104    Assert(PassN>1);
105    Assert(WId!=-1);
106    Assert(GetWordFq(WId)>=MnNGramFq);
107    CandWIdQ.Push(WId); 
108    int CandWIdQLen=CandWIdQ.Len(); 
109    if (CandWIdQLen==1){return;} 
110    if (PassN==2){ 
111      if (CandWIdQLen==PassN){
112        CandWIdPrToFqH.AddDat(TIntPr(CandWIdQ[0], CandWIdQ[1]))++;}
113    } else { 
114      if ((1<CandWIdQLen)&&(CandWIdQLen<PassN)){
115        TIntV SubWIdV; CandWIdQ.GetSubValV(0, CandWIdQ.Len()-1, SubWIdV);
116        int SubWIdVId=WIdVToFqH.GetKeyId(SubWIdV);
117        if (SubWIdVId==-1){BreakNGram();}
118      } else {
119        Assert(CandWIdQLen==PassN);
120        TIntV SubWIdV; CandWIdQ.GetSubValV(1, CandWIdQ.Len()-1, SubWIdV);
121        int SubWIdVId=WIdVToFqH.GetKeyId(SubWIdV);
122        if (SubWIdVId==-1){
123          BreakNGram(); 
124        } else {
125          TIntV WIdV; CandWIdQ.GetSubValV(0, CandWIdQ.Len()-1, WIdV);
126          CandWIdVToFqH.AddDat(WIdV)++;
127        }
128      }
129    }
130  }
131  int TNGramBs::AddWord(const TStr& WordStr){
132    int WId=-1;
133    if (PassN==1){ 
134      WId=WordStrToFqH.AddKey(WordStr); 
135      WordStrToFqH[WId]++; 
136    } else { 
137      WId=GetWId(WordStr); 
138      if (WId==-1){ 
139        BreakNGram(); 
140      } else
141      if (GetWordFq(WId)!=-1){ 
142        AddWordToCand(WId); 
143      }
144    }
145    return WId;
146  }
147  void TNGramBs::ConcPass(){
148    IAssert(!IsFinished());
149    if (PassN==1){ 
150      TIntV DelWIdV; 
151      int WIds=WordStrToFqH.Len(); 
152      for (int WId=0; WId<WIds; WId++){
153        TStr WordStr=WordStrToFqH.GetKey(WId); 
154        if (WordStrToFqH[WId]<MnNGramFq){
155          DelWIdV.Add(WId); 
156        }
157      }
158      WordStrToFqH.DelKeyIdV(DelWIdV);
159      WordStrToFqH.Defrag();
160    } else
161    if (PassN==2){ 
162      int Cands=CandWIdPrToFqH.Len(); 
163      TIntV WIdV(2); 
164      for (int CandId=0; CandId<Cands; CandId++){
165        int CandFq=CandWIdPrToFqH[CandId]; 
166        if (CandFq>=MnNGramFq){ 
167          const TIntPr& WIdPr=CandWIdPrToFqH.GetKey(CandId); 
168          WIdV[0]=WIdPr.Val1; WIdV[1]=WIdPr.Val2; 
169          WIdVToFqH.AddDat(WIdV, CandFq); 
170        }
171      }
172      CandWIdPrToFqH.Clr();
173    } else
174    if (PassN>2){ 
175      int Cands=CandWIdVToFqH.Len(); 
176      for (int CandId=0; CandId<Cands; CandId++){
177        int CandFq=CandWIdVToFqH[CandId]; 
178        if (CandFq>=MnNGramFq){ 
179          const TIntV& CandWIdV=CandWIdVToFqH.GetKey(CandId); 
180          WIdVToFqH.AddDat(CandWIdV, CandWIdVToFqH[CandId]); 
181        }
182      }
183      CandWIdVToFqH.Clr();
184    } else {
185      Fail;
186    }
187    PassN++;
188    if (IsFinished()){
189      CandWIdQ.Clr();
190      int WIds=WordStrToFqH.Len(); 
191      for (int WId=0; WId<WIds; WId++){
192        TStr WordStr=WordStrToFqH.GetKey(WId); 
193        if ((!SwSet.Empty())&&(SwSet->IsIn(WordStr))){
194          WordStrToFqH[WId]=-1; 
195        }
196      }
197      for (int WIdVId=0; WIdVId<WIdVToFqH.Len(); WIdVId++){
198        int FirstWId=WIdVToFqH.GetKey(WIdVId)[0]; 
199        int LastWId=WIdVToFqH.GetKey(WIdVId).Last(); 
200        if ((WordStrToFqH[FirstWId]==-1)||(WordStrToFqH[LastWId]==-1)){
201          TStr NGramStr=GetWIdVStr(WIdVToFqH.GetKey(WIdVId));
202          WIdVToFqH[WIdVId]=-1;
203        }
204      }
205      for (int WIdVId=0; WIdVId<WIdVToFqH.Len(); WIdVId++){
206        if (WIdVToFqH.GetKey(WIdVId).Len()>1){
207        }
208      }
209    } else {
210      CandWIdQ.Gen(100*PassN, PassN);
211    }
212  }
213  void TNGramBs::SaveTxt(const TStr& FNm, const bool& SortP) const {
214    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
215    if (SortP){
216      int NGrams=GetNGrams(); TStr NGramStr; int NGramFq;
217      TIntPrV FqNGramIdPrV(GetNGrams(), 0);
218      for (int NGramId=0; NGramId<NGrams; NGramId++){
219        GetNGramStrFq(NGramId, NGramStr, NGramFq);
220        if (NGramFq!=-1){
221          FqNGramIdPrV.Add(TIntPr(NGramFq, NGramId));}
222      }
223      FqNGramIdPrV.Sort(false);
224      for (int NGramN=0; NGramN<FqNGramIdPrV.Len(); NGramN++){
225        int NGramFq=FqNGramIdPrV[NGramN].Val1;
226        int NGramId=FqNGramIdPrV[NGramN].Val2;
227        GetNGramStrFq(NGramId, NGramStr, NGramFq);
228        fprintf(fOut, "'%s': %d\n", NGramStr.CStr(), NGramFq);
229      }
230    } else {
231      int NGrams=GetNGrams(); TStr NGramStr; int NGramFq;
232      for (int NGramId=0; NGramId<NGrams; NGramId++){
233        GetNGramStrFq(NGramId, NGramStr,  NGramFq);
234        if (NGramFq!=-1){
235          fprintf(fOut, "'%s': %d\n", NGramStr.CStr(), NGramFq);}
236      }
237    }
238  }
239  void TNGramBs::_UpdateNGramBsFromHtmlStr(
240   const PNGramBs& NGramBs, const TStr& HtmlStr,
241   const PSwSet& SwSet, const PStemmer& Stemmer){
242    PSIn HtmlSIn=TStrIn::New(HtmlStr);
243    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
244    PHtmlTok Tok; THtmlLxSym Sym; TStr Str;
245    PHtmlLxChDef ChDef=THtmlLxChDef::GetChDef();
246    bool InScript=false;
247    NGramBs->BreakNGram();
248    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
249      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
250      HtmlDoc->GetTok(TokN, Sym, Str);
251      switch (Sym){
252        case hsyUndef: break;
253        case hsySSym: break;
254        case hsyStr:
255        case hsyNum:{
256          if (InScript){break;}
257          TStr UcStr=ChDef->GetUcStr(Str);
258          if (true||(SwSet.Empty())||(!SwSet->IsIn(UcStr))){
259            if (!Stemmer.Empty()){
260              UcStr=Stemmer->GetStem(UcStr);}
261            NGramBs->AddWord(UcStr);
262          }
263          break;}
264        case hsyBTag:
265        case hsyETag:
266          if (Str=="<SCRIPT>"){
267            InScript=(Sym==hsyBTag);}
268          if (THtmlTok::IsBreakTag(Str)){
269            NGramBs->BreakNGram();}
270          break;
271        case hsyEof: break;
272        default: break;
273      }
274    }
275  }
276  PNGramBs TNGramBs::GetNGramBsFromHtmlStrV(
277   const TStrV& HtmlStrV,
278   const int& MxNGramLen, const int& MnNGramFq,
279   const PSwSet& SwSet, const PStemmer& Stemmer){
280    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
281    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
282    while (!NGramBs->IsFinished()){
283      for (int HtmlStrN=0; HtmlStrN<HtmlStrV.Len(); HtmlStrN++){
284        if ((HtmlStrN%10==0)||(HtmlStrN+1==HtmlStrV.Len())){
285          printf("  Pass %2d: %6d/%6d Docs\r", NGramBs->GetPassN(), HtmlStrN+1, HtmlStrV.Len());
286          if (HtmlStrN+1==HtmlStrV.Len()){printf("\n");}
287        }
288        _UpdateNGramBsFromHtmlStr(NGramBs, HtmlStrV[HtmlStrN], SwSet, Stemmer);
289      }
290      NGramBs->ConcPass();
291    }
292    printf("Done.\n");
293    return NGramBs;
294  }
295  PNGramBs TNGramBs::GetNGramBsFromHtmlFPathV(
296   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
297   const int& MxNGramLen, const int& MnNGramFq,
298   const PSwSet& SwSet, const PStemmer& Stemmer){
299    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
300    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
301    while (!NGramBs->IsFinished()){
302      TFFile FFile(FPath, "", RecurseDirP);
303      TStr FNm; int Docs=0;
304      while (FFile.Next(FNm)){
305        Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
306        if (Docs%100==0){
307          printf("  Pass %d: %6d\r", NGramBs->GetPassN(), Docs);}
308        if (TFile::Exists(FNm)) {
309          TStr HtmlStr=TStr::LoadTxt(FNm);
310          _UpdateNGramBsFromHtmlStr(NGramBs, HtmlStr, SwSet, Stemmer);
311        }
312      }
313      NGramBs->ConcPass();
314      printf("  Pass %d: %6d\n", NGramBs->GetPassN()-1, Docs);
315    }
316    printf("Done.\n");
317    return NGramBs;
318  }
319  PNGramBs TNGramBs::GetNGramBsFromCpd(
320   const PSIn& CpdSIn, const int& MxDocs,
321   const int& MxNGramLen, const int& MnNGramFq,
322   const PSwSet& SwSet, const PStemmer& Stemmer){
323    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
324    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
325    while (!NGramBs->IsFinished()){
326      PSIn CpDocSIn=TCpDoc::FFirstCpd(CpdSIn);
327      PCpDoc CpDoc; int Docs=0;
328      while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
329        Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
330        if (Docs%100==0){
331          printf("  Pass %d: %6d\r", NGramBs->GetPassN(), Docs);}
332        TStr DocStr=CpDoc->GetTxtStr();
333        _UpdateNGramBsFromHtmlStr(NGramBs, DocStr, SwSet, Stemmer);
334      }
335      NGramBs->ConcPass();
336      printf("  Pass %d: %6d\n", NGramBs->GetPassN()-1, Docs);
337      if (!NGramBs->IsFinished()){
338        CpdSIn->Reset();}
339    }
340    printf("Done.\n");
341    return NGramBs;
342  }
343  PNGramBs TNGramBs::GetNGramBsFromTBs(
344   const TStr& TBsFNm, const int& MxDocs,
345   const int& MxNGramLen, const int& MnNGramFq,
346   const PSwSet& SwSet, const PStemmer& Stemmer){
347    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
348    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
349    while (!NGramBs->IsFinished()){
350      TStr TxtBsNm=TBsFNm.GetFBase();
351      TStr TxtBsFPath=TBsFNm.GetFPath();
352      PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
353      TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
354      while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
355        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
356        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
357        TStr DocNm; TStr DocStr;
358        TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
359        _UpdateNGramBsFromHtmlStr(NGramBs, DocStr, SwSet, Stemmer);
360      }
361      NGramBs->ConcPass();
362      printf("  Pass %2d: %6d\r", NGramBs->GetPassN(), Docs);
363    }
364    printf("\nDone.\n");
365    return NGramBs;
366  }
367  PNGramBs TNGramBs::GetNGramBsFromLnDoc(
368   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
369   const int& MxNGramLen, const int& MnNGramFq,
370   const PSwSet& SwSet, const PStemmer& Stemmer){
371    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
372    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
373    while (!NGramBs->IsFinished()){
374      TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
375      while (!FIn.Eof()){
376        Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
377        TChA DocNm;
378        if (NamedP){
379          Ch=FIn.GetCh();
380          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
381            DocNm+=Ch; Ch=FIn.GetCh();}
382          DocNm.Trunc();
383          if (DocNm.Empty()){Docs--; continue;}
384        }
385        TStrV CatNmV;
386        forever {
387          while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
388          if (Ch=='!'){
389            TChA CatNm;
390            while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
391              CatNm+=Ch; Ch=FIn.GetCh();}
392            if (!CatNm.Empty()){CatNmV.Add(CatNm);}
393          } else {
394            break;
395          }
396        }
397        TChA DocChA;
398        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
399          DocChA+=Ch; Ch=FIn.GetCh();}
400        printf("  Pass %2d: %6d Docs\r", NGramBs->GetPassN(), Docs);
401        _UpdateNGramBsFromHtmlStr(NGramBs, DocChA, SwSet, Stemmer);
402      }
<span onclick='openModal()' class='match'>403      NGramBs->ConcPass();
404    }
405    printf("\nDone.\n");
406    return NGramBs;
407  }
408  PNGramBs TNGramBs::GetNGramBsFromReuters21578(
409   const TStr& FPath, const int& MxDocs,
</span>410   const int& MxNGramLen, const int& MnNGramFq,
411   const PSwSet& SwSet, const PStemmer& Stemmer){
412    printf("Generating frequent n-grams (MaxLen:%d MinFq:%d) ...\n", MxNGramLen, MnNGramFq);
413    PNGramBs NGramBs=TNGramBs::New(MxNGramLen, MnNGramFq, SwSet, Stemmer);
414    while (!NGramBs->IsFinished()){
415      TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
416      while (FFile.Next(FNm)){
417        printf("Processing file '%s'\n", FNm.CStr());
418        TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
419        for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
420          Docs++; printf("  Pass %2d: %6d Docs\r", NGramBs->GetPassN(), Docs);
421          if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
422          PXmlDoc Doc=LDocV[LDocN];
423          PXmlTok DocTok=Doc->GetTok();
424          PXmlTok Tok=Doc->GetTagTok("REUTERS|TEXT");
425          TStr HtmlStr=Tok->GetTokStr(false);
426          _UpdateNGramBsFromHtmlStr(NGramBs, HtmlStr, SwSet, Stemmer);
427        }
428        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
429      }
430      NGramBs->ConcPass();
431      printf("  Pass %2d: %6d Docs\r", NGramBs->GetPassN(), Docs);
432    }
433    printf("\nDone.\n");
434    return NGramBs;
435  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-phrase.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-phrase.cpp</div>
                </div>
                <div class="column column_space"><pre><code>403      NGramBs->ConcPass();
404    }
405    printf("\nDone.\n");
406    return NGramBs;
407  }
408  PNGramBs TNGramBs::GetNGramBsFromReuters21578(
409   const TStr& FPath, const int& MxDocs,
</pre></code></div>
                <div class="column column_space"><pre><code>403      NGramBs->ConcPass();
404    }
405    printf("\nDone.\n");
406    return NGramBs;
407  }
408  PNGramBs TNGramBs::GetNGramBsFromReuters21578(
409   const TStr& FPath, const int& MxDocs,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    