
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCOBOL.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  #define IN_DIVISION 0x01
20  #define IN_DECLARATIVES 0x02
21  #define IN_SECTION 0x04
22  #define IN_PARAGRAPH 0x08
23  #define IN_FLAGS 0xF
24  #define NOT_HEADER 0x10
25  inline bool isCOBOLoperator(char ch)
26      {
27      return isoperator(ch);
28      }
29  inline bool isCOBOLwordchar(char ch)
30      {
31      return IsASCII(ch) && (isalnum(ch) || ch == '-');
32      }
33  inline bool isCOBOLwordstart(char ch)
34      {
35      return IsASCII(ch) && isalnum(ch);
36      }
37  static int CountBits(int nBits)
38  	{
39  	int count = 0;
40  	for (int i = 0; i < 32; ++i)
41  		{
42  		count += nBits & 1;
43  		nBits >>= 1;
44  		}
45  	return count;
46  	}
47  static void getRange(Sci_PositionU start,
48          Sci_PositionU end,
49          Accessor &styler,
50          char *s,
51          Sci_PositionU len) {
52      Sci_PositionU i = 0;
53      while ((i < end - start + 1) && (i < len-1)) {
54          s[i] = static_cast<char>(tolower(styler[start + i]));
55          i++;
56      }
57      s[i] = '\0';
58  }
59  static void ColourTo(Accessor &styler, Sci_PositionU end, unsigned int attr) {
60      styler.ColourTo(end, attr);
61  }
62  static int classifyWordCOBOL(Sci_PositionU start, Sci_PositionU end, &bsol;*WordList &keywords*/WordList *keywordlists[], Accessor &styler, int nContainment, bool *bAarea) {
63      int ret = 0;
64      WordList& a_keywords = *keywordlists[0];
65      WordList& b_keywords = *keywordlists[1];
66      WordList& c_keywords = *keywordlists[2];
67      char s[100];
68      s[0] = '\0';
69      s[1] = '\0';
70      getRange(start, end, styler, s, sizeof(s));
71      char chAttr = SCE_C_IDENTIFIER;
72      if (isdigit(s[0]) || (s[0] == '.') || (s[0] == 'v')) {
73          chAttr = SCE_C_NUMBER;
74  		char *p = s + 1;
75  		while (*p) {
76  			if ((!isdigit(*p) && (*p) != 'v') && isCOBOLwordchar(*p)) {
77  				chAttr = SCE_C_IDENTIFIER;
78  			    break;
79  			}
80  			++p;
81  		}
82      }
83      else {
84          if (a_keywords.InList(s)) {
85              chAttr = SCE_C_WORD;
86          }
87          else if (b_keywords.InList(s)) {
88              chAttr = SCE_C_WORD2;
89          }
90          else if (c_keywords.InList(s)) {
91              chAttr = SCE_C_UUID;
92          }
93      }
94      if (*bAarea) {
95          if (strcmp(s, "division") == 0) {
96              ret = IN_DIVISION;
97  			*bAarea = false;
98  		} else if (strcmp(s, "declaratives") == 0) {
99              ret = IN_DIVISION | IN_DECLARATIVES;
100  			if (nContainment & IN_DECLARATIVES)
101  				ret |= NOT_HEADER | IN_SECTION;
102  			*bAarea = false;
103  		} else if (strcmp(s, "section") == 0) {
104              ret = (nContainment &~ IN_PARAGRAPH) | IN_SECTION;
105  			*bAarea = false;
106  		} else if (strcmp(s, "end") == 0 && (nContainment & IN_DECLARATIVES)) {
107              ret = IN_DIVISION | IN_DECLARATIVES | IN_SECTION | NOT_HEADER;
108  		} else {
109  			ret = nContainment | IN_PARAGRAPH;
110          }
111      }
112      ColourTo(styler, end, chAttr);
113      return ret;
114  }
115  static void ColouriseCOBOLDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
116      Accessor &styler) {
117      styler.StartAt(startPos);
118      int state = initStyle;
119      if (state == SCE_C_CHARACTER)   
120          state = SCE_C_DEFAULT;
121      char chPrev = ' ';
122      char chNext = styler[startPos];
123      Sci_PositionU lengthDoc = startPos + length;
124      int nContainment;
125      Sci_Position currentLine = styler.GetLine(startPos);
126      if (currentLine > 0) {
127          styler.SetLineState(currentLine, styler.GetLineState(currentLine-1));
128          nContainment = styler.GetLineState(currentLine);
129  		nContainment &= ~NOT_HEADER;
130      } else {
131          styler.SetLineState(currentLine, 0);
132          nContainment = 0;
133      }
134      styler.StartSegment(startPos);
135      bool bNewLine = true;
136      bool bAarea = !isspacechar(chNext);
137  	int column = 0;
138      for (Sci_PositionU i = startPos; i < lengthDoc; i++) {
139          char ch = chNext;
140          chNext = styler.SafeGetCharAt(i + 1);
141  		++column;
142          if (bNewLine) {
143  			column = 0;
144          }
145  		if (column <= 1 && !bAarea) {
146  			bAarea = !isspacechar(ch);
147  			}
148          bool bSetNewLine = false;
149          if ((ch == '\r' && chNext != '\n') || (ch == '\n')) {
150              if (state == SCE_C_CHARACTER) {
151                  ColourTo(styler, i, state);
152                  state = SCE_C_DEFAULT;
153              }
154              styler.SetLineState(currentLine, nContainment);
155              currentLine++;
156              bSetNewLine = true;
157  			if (nContainment & NOT_HEADER)
158  				nContainment &= ~(NOT_HEADER | IN_DECLARATIVES | IN_SECTION);
159          }
160          if (styler.IsLeadByte(ch)) {
<span onclick='openModal()' class='match'>161              chNext = styler.SafeGetCharAt(i + 2);
162              chPrev = ' ';
163              i += 1;
</span>164              continue;
165          }
166          if (state == SCE_C_DEFAULT) {
167              if (isCOBOLwordstart(ch) || (ch == '$' && IsASCII(chNext) && isalpha(chNext))) {
168                  ColourTo(styler, i-1, state);
169                  state = SCE_C_IDENTIFIER;
170              } else if (column == 6 && ch == '*') {
171                  ColourTo(styler, i-1, state);
172                  state = SCE_C_COMMENTLINE;
173              } else if (ch == '*' && chNext == '>') {
174                  ColourTo(styler, i-1, state);
175                  state = SCE_C_COMMENTLINE;
176              } else if (column == 0 && ch == '*' && chNext != '*') {
177                  ColourTo(styler, i-1, state);
178                  state = SCE_C_COMMENTLINE;
179              } else if (column == 0 && ch == '/' && chNext != '*') {
180                  ColourTo(styler, i-1, state);
181                  state = SCE_C_COMMENTLINE;
182              } else if (column == 0 && ch == '*' && chNext == '*') {
183                  ColourTo(styler, i-1, state);
184                  state = SCE_C_COMMENTDOC;
185              } else if (column == 0 && ch == '/' && chNext == '*') {
186                  ColourTo(styler, i-1, state);
187                  state = SCE_C_COMMENTDOC;
188              } else if (ch == '"') {
189                  ColourTo(styler, i-1, state);
190                  state = SCE_C_STRING;
191              } else if (ch == '\'') {
192                  ColourTo(styler, i-1, state);
193                  state = SCE_C_CHARACTER;
194              } else if (ch == '?' && column == 0) {
195                  ColourTo(styler, i-1, state);
196                  state = SCE_C_PREPROCESSOR;
197              } else if (isCOBOLoperator(ch)) {
198                  ColourTo(styler, i-1, state);
199                  ColourTo(styler, i, SCE_C_OPERATOR);
200              }
201          } else if (state == SCE_C_IDENTIFIER) {
202              if (!isCOBOLwordchar(ch)) {
203                  int lStateChange = classifyWordCOBOL(styler.GetStartSegment(), i - 1, keywordlists, styler, nContainment, &bAarea);
204                  if(lStateChange != 0) {
205                      styler.SetLineState(currentLine, lStateChange);
206                      nContainment = lStateChange;
207                  }
208                  state = SCE_C_DEFAULT;
209                  chNext = styler.SafeGetCharAt(i + 1);
210                  if (ch == '"') {
211                      state = SCE_C_STRING;
212                  } else if (ch == '\'') {
213                      state = SCE_C_CHARACTER;
214                  } else if (isCOBOLoperator(ch)) {
215                      ColourTo(styler, i, SCE_C_OPERATOR);
216                  }
217              }
218          } else {
219              if (state == SCE_C_PREPROCESSOR) {
220                  if ((ch == '\r' || ch == '\n') && !(chPrev == '\\' || chPrev == '\r')) {
221                      ColourTo(styler, i-1, state);
222                      state = SCE_C_DEFAULT;
223                  }
224              } else if (state == SCE_C_COMMENT) {
225                  if (ch == '\r' || ch == '\n') {
226                      ColourTo(styler, i, state);
227                      state = SCE_C_DEFAULT;
228                  }
229              } else if (state == SCE_C_COMMENTDOC) {
230                  if (ch == '\r' || ch == '\n') {
231                      if (((i > styler.GetStartSegment() + 2) || (
232                          (initStyle == SCE_C_COMMENTDOC) &&
233                          (styler.GetStartSegment() == static_cast<Sci_PositionU>(startPos))))) {
234                              ColourTo(styler, i, state);
235                              state = SCE_C_DEFAULT;
236                      }
237                  }
238              } else if (state == SCE_C_COMMENTLINE) {
239                  if (ch == '\r' || ch == '\n') {
240                      ColourTo(styler, i-1, state);
241                      state = SCE_C_DEFAULT;
242                  }
243              } else if (state == SCE_C_STRING) {
244                  if (ch == '"') {
245                      ColourTo(styler, i, state);
246                      state = SCE_C_DEFAULT;
247                  }
248              } else if (state == SCE_C_CHARACTER) {
249                  if (ch == '\'') {
250                      ColourTo(styler, i, state);
251                      state = SCE_C_DEFAULT;
252                  }
253              }
254          }
255          chPrev = ch;
256          bNewLine = bSetNewLine;
257  		if (bNewLine)
258  			{
259  			bAarea = false;
260  			}
261      }
262      ColourTo(styler, lengthDoc - 1, state);
263  }
264  static void FoldCOBOLDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[],
265                              Accessor &styler) {
266      bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
267      Sci_PositionU endPos = startPos + length;
268      int visibleChars = 0;
269      Sci_Position lineCurrent = styler.GetLine(startPos);
270      int levelPrev = lineCurrent > 0 ? styler.LevelAt(lineCurrent - 1) & SC_FOLDLEVELNUMBERMASK : 0xFFF;
271      char chNext = styler[startPos];
272      bool bNewLine = true;
273      bool bAarea = !isspacechar(chNext);
274  	int column = 0;
275  	bool bComment = false;
276      for (Sci_PositionU i = startPos; i < endPos; i++) {
277          char ch = chNext;
278          chNext = styler.SafeGetCharAt(i + 1);
279  		++column;
280          if (bNewLine) {
281  			column = 0;
282  			bComment = (ch == '*' || ch == '/' || ch == '?');
283          }
284  		if (column <= 1 && !bAarea) {
285  			bAarea = !isspacechar(ch);
286  			}
287          bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
288          if (atEOL) {
289  			int nContainment = styler.GetLineState(lineCurrent);
290              int lev = CountBits(nContainment & IN_FLAGS) | SC_FOLDLEVELBASE;
291  			if (bAarea && !bComment)
292  				--lev;
293              if (visibleChars == 0 && foldCompact)
294                  lev |= SC_FOLDLEVELWHITEFLAG;
295              if ((bAarea) && (visibleChars > 0) && !(nContainment & NOT_HEADER) && !bComment)
296                  lev |= SC_FOLDLEVELHEADERFLAG;
297              if (lev != styler.LevelAt(lineCurrent)) {
298                  styler.SetLevel(lineCurrent, lev);
299              }
300  			if ((lev & SC_FOLDLEVELNUMBERMASK) <= (levelPrev & SC_FOLDLEVELNUMBERMASK)) {
301  				styler.SetLevel(lineCurrent - 1, levelPrev & ~SC_FOLDLEVELHEADERFLAG);
302  			}
303              levelPrev = lev;
304              visibleChars = 0;
305  			bAarea = false;
306              bNewLine = true;
307              lineCurrent++;
308          } else {
309              bNewLine = false;
310          }
311          if (!isspacechar(ch))
312              visibleChars++;
313      }
314      int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
315      styler.SetLevel(lineCurrent, levelPrev | flagsNext);
316  }
317  static const char * const COBOLWordListDesc[] = {
318      "A Keywords",
319      "B Keywords",
320      "Extended Keywords",
321      0
322  };
323  LexerModule lmCOBOL(SCLEX_COBOL, ColouriseCOBOLDoc, "COBOL", FoldCOBOLDoc, COBOLWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexScriptol.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static void ClassifyWordSol(Sci_PositionU start, Sci_PositionU end, WordList &keywords, Accessor &styler, char *prevWord)
20  {
21      char s[100] = "";
22      bool wordIsNumber = isdigit(styler[start]) != 0;
23      for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++)
24       {
25             s[i] = styler[start + i];
26             s[i + 1] = '\0';
27       }
28      char chAttr = SCE_SCRIPTOL_IDENTIFIER;
29      if (0 == strcmp(prevWord, "class"))       chAttr = SCE_SCRIPTOL_CLASSNAME;
30      else if (wordIsNumber)                    chAttr = SCE_SCRIPTOL_NUMBER;
31      else if (keywords.InList(s))              chAttr = SCE_SCRIPTOL_KEYWORD;
32      else for (Sci_PositionU i = 0; i < end - start + 1; i++)  
33      {
34          if (styler[start + i] == '.')
35          {
36              styler.ColourTo(start + i - 1, chAttr);
37              styler.ColourTo(start + i, SCE_SCRIPTOL_OPERATOR);
38          }
39      }
40      styler.ColourTo(end, chAttr);
41      strcpy(prevWord, s);
42  }
43  static bool IsSolComment(Accessor &styler, Sci_Position pos, Sci_Position len)
44  {
45     if(len > 0)
46     {
47       char c = styler[pos];
48       if(c == '`') return true;
49       if(len > 1)
50       {
51          if(c == '/')
52          {
53            c = styler[pos + 1];
54            if(c == '/') return true;
55            if(c == '*') return true;
56          }
57       }
58     }
59     return false;
60  }
61  static bool IsSolStringStart(char ch)
62  {
63      if (ch == '\'' || ch == '"')  return true;
64      return false;
65  }
66  static bool IsSolWordStart(char ch)
67  {
68      return (iswordchar(ch) && !IsSolStringStart(ch));
69  }
70  static int GetSolStringState(Accessor &styler, Sci_Position i, Sci_Position *nextIndex)
71  {
72  	char ch = styler.SafeGetCharAt(i);
73  	char chNext = styler.SafeGetCharAt(i + 1);
74          if (ch != '\"' && ch != '\'')
75          {
76              *nextIndex = i + 1;
77              return SCE_SCRIPTOL_DEFAULT;
78  	}
79  	if (ch == chNext && ch == styler.SafeGetCharAt(i + 2))
80          {
81            *nextIndex = i + 3;
82            if(ch == '\"') return SCE_SCRIPTOL_TRIPLE;
83            if(ch == '\'') return SCE_SCRIPTOL_TRIPLE;
84            return SCE_SCRIPTOL_STRING;
85  	}
86          else
87          {
88            *nextIndex = i + 1;
89            if (ch == '"') return SCE_SCRIPTOL_STRING;
90            else           return SCE_SCRIPTOL_STRING;
91  	}
92  }
93  static void ColouriseSolDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
94                              WordList *keywordlists[], Accessor &styler)
95   {
96  	Sci_Position lengthDoc = startPos + length;
97          char stringType = '\"';
98  	if (startPos > 0)
99          {
100              Sci_Position lineCurrent = styler.GetLine(startPos);
101              if (lineCurrent > 0)
102              {
103                startPos = styler.LineStart(lineCurrent-1);
104                if (startPos == 0) initStyle = SCE_SCRIPTOL_DEFAULT;
105                else               initStyle = styler.StyleAt(startPos-1);
106              }
107  	}
108  	styler.StartAt(startPos);
109  	WordList &keywords = *keywordlists[0];
110  	char prevWord[200];
111  	prevWord[0] = '\0';
112          if (length == 0)  return;
113  	int state = initStyle & 31;
114  	Sci_Position nextIndex = 0;
115          char chPrev  = ' ';
116          char chPrev2 = ' ';
117          char chNext  = styler[startPos];
118  	styler.StartSegment(startPos);
119  	for (Sci_Position i = startPos; i < lengthDoc; i++)
120          {
121         char ch = chNext;
122         chNext = styler.SafeGetCharAt(i + 1);
123         if ((ch == '\r' && chNext != '\n') || (ch == '\n') || (i == lengthDoc))
124         {
125            if ((state == SCE_SCRIPTOL_DEFAULT) ||
126                (state == SCE_SCRIPTOL_TRIPLE) ||
127                (state == SCE_SCRIPTOL_COMMENTBLOCK))
128            {
129                styler.ColourTo(i, state);
130            }
131          }
132          if (styler.IsLeadByte(ch))
133           {
<span onclick='openModal()' class='match'>134               chNext = styler.SafeGetCharAt(i + 2);
135               chPrev  = ' ';
136               chPrev2 = ' ';
</span>137               i += 1;
138               continue;
139           }
140          if (state == SCE_SCRIPTOL_STRINGEOL)
141           {
142               if (ch != '\r' && ch != '\n')
143               {
144                      styler.ColourTo(i - 1, state);
145                      state = SCE_SCRIPTOL_DEFAULT;
146               }
147           }
148          if (state == SCE_SCRIPTOL_DEFAULT)
149           {
150              if (IsSolWordStart(ch))
151              {
152                   styler.ColourTo(i - 1, state);
153                   state = SCE_SCRIPTOL_KEYWORD;
154              }
155              else if (ch == '`')
156              {
157                  styler.ColourTo(i - 1, state);
158                  state = SCE_SCRIPTOL_COMMENTLINE;
159              }
160              else if (ch == '/')
161              {
162                  styler.ColourTo(i - 1, state);
163                  if(chNext == '/') state = SCE_SCRIPTOL_CSTYLE;
164                  if(chNext == '*') state = SCE_SCRIPTOL_COMMENTBLOCK;
165              }
166              else if (IsSolStringStart(ch))
167              {
168                 styler.ColourTo(i - 1, state);
169                 state = GetSolStringState(styler, i, &nextIndex);
170                 if(state == SCE_SCRIPTOL_STRING)
171                 {
172                   stringType = ch;
173                 }
174                 if (nextIndex != i + 1)
175                 {
176                     i = nextIndex - 1;
177                     ch = ' ';
178                     chPrev = ' ';
179                     chNext = styler.SafeGetCharAt(i + 1);
180                 }
181             }
182              else if (isoperator(ch))
183              {
184                   styler.ColourTo(i - 1, state);
185                   styler.ColourTo(i, SCE_SCRIPTOL_OPERATOR);
186              }
187            }
188            else if (state == SCE_SCRIPTOL_KEYWORD)
189            {
190                if (!iswordchar(ch))
191                {
192                   ClassifyWordSol(styler.GetStartSegment(), i - 1, keywords, styler, prevWord);
193                   state = SCE_SCRIPTOL_DEFAULT;
194                   if (ch == '`')
195                   {
196                       state = chNext == '`' ? SCE_SCRIPTOL_PERSISTENT : SCE_SCRIPTOL_COMMENTLINE;
197                   }
198                   else if (IsSolStringStart(ch))
199                   {
200                      styler.ColourTo(i - 1, state);
201                      state = GetSolStringState(styler, i, &nextIndex);
202                      if (nextIndex != i + 1)
203                      {
204                         i = nextIndex - 1;
205                         ch = ' ';
206                         chPrev = ' ';
207                         chNext = styler.SafeGetCharAt(i + 1);
208                       }
209                   }
210                   else if (isoperator(ch))
211                   {
212                       styler.ColourTo(i, SCE_SCRIPTOL_OPERATOR);
213                   }
214               }
215            }
216            else
217            {
218              if (state == SCE_SCRIPTOL_COMMENTLINE ||
219                  state == SCE_SCRIPTOL_PERSISTENT ||
220                  state == SCE_SCRIPTOL_CSTYLE)
221              {
222                   if (ch == '\r' || ch == '\n')
223                   {
224                       styler.ColourTo(i - 1, state);
225                       state = SCE_SCRIPTOL_DEFAULT;
226                   }
227              }
228              else if(state == SCE_SCRIPTOL_COMMENTBLOCK)
229              {
230                if(chPrev == '*' && ch == '/')
231                {
232                  styler.ColourTo(i, state);
233                  state = SCE_SCRIPTOL_DEFAULT;
234                }
235              }
236              else if ((state == SCE_SCRIPTOL_STRING) ||
237                       (state == SCE_SCRIPTOL_CHARACTER))
238              {
239                 if ((ch == '\r' || ch == '\n') && (chPrev != '\\'))
240                  {
241                      styler.ColourTo(i - 1, state);
242                      state = SCE_SCRIPTOL_STRINGEOL;
243                  }
244                  else if (ch == '\\')
245                  {
246                     if (chNext == '\"' || chNext == '\'' || chNext == '\\')
247                     {
248                          i++;
249                          ch = chNext;
250                          chNext = styler.SafeGetCharAt(i + 1);
251                     }
252                   }
253                  else if ((ch == '\"') || (ch == '\''))
254                  {
255                      if(ch == stringType)
256                      {
257                        styler.ColourTo(i, state);
258                        state = SCE_SCRIPTOL_DEFAULT;
259                      }
260                   }
261               }
262               else if (state == SCE_SCRIPTOL_TRIPLE)
263               {
264                  if ((ch == '\'' && chPrev == '\'' && chPrev2 == '\'') ||
265                      (ch == '\"' && chPrev == '\"' && chPrev2 == '\"'))
266                   {
267                      styler.ColourTo(i, state);
268                      state = SCE_SCRIPTOL_DEFAULT;
269                   }
270               }
271             }
272            chPrev2 = chPrev;
273            chPrev = ch;
274  	}
275          if (state == SCE_SCRIPTOL_KEYWORD)
276          {
277              ClassifyWordSol(styler.GetStartSegment(),
278                   lengthDoc-1, keywords, styler, prevWord);
279  	}
280          else
281          {
282              styler.ColourTo(lengthDoc-1, state);
283  	}
284  }
285  static void FoldSolDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
286  						   WordList *[], Accessor &styler)
287   {
288  	Sci_Position lengthDoc = startPos + length;
289  	Sci_Position lineCurrent = styler.GetLine(startPos);
290  	if (startPos > 0)
291          {
292            if (lineCurrent > 0)
293            {
294                 lineCurrent--;
295                 startPos = styler.LineStart(lineCurrent);
296                 if (startPos == 0)
297                      initStyle = SCE_SCRIPTOL_DEFAULT;
298                 else
299                      initStyle = styler.StyleAt(startPos-1);
300             }
301  	}
302  	int state = initStyle & 31;
303  	int spaceFlags = 0;
304          int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, IsSolComment);
305          if (state == SCE_SCRIPTOL_TRIPLE)
306               indentCurrent |= SC_FOLDLEVELWHITEFLAG;
307  	char chNext = styler[startPos];
308  	for (Sci_Position i = startPos; i < lengthDoc; i++)
309           {
310  		char ch = chNext;
311  		chNext = styler.SafeGetCharAt(i + 1);
312  		int style = styler.StyleAt(i) & 31;
313  		if ((ch == '\r' && chNext != '\n') || (ch == '\n') || (i == lengthDoc))
314                  {
315                     int lev = indentCurrent;
316                     int indentNext = styler.IndentAmount(lineCurrent + 1, &spaceFlags, IsSolComment);
317                     if (style == SCE_SCRIPTOL_TRIPLE)
318                          indentNext |= SC_FOLDLEVELWHITEFLAG;
319                     if (!(indentCurrent & SC_FOLDLEVELWHITEFLAG))
320                      {
321                          if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext & SC_FOLDLEVELNUMBERMASK))
322                          {
323                                lev |= SC_FOLDLEVELHEADERFLAG;
324                          }
325                          else if (indentNext & SC_FOLDLEVELWHITEFLAG)
326                          {
327                               int spaceFlags2 = 0;
328                               int indentNext2 = styler.IndentAmount(lineCurrent + 2, &spaceFlags2, IsSolComment);
329                               if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext2 & SC_FOLDLEVELNUMBERMASK))
330                               {
331                                     lev |= SC_FOLDLEVELHEADERFLAG;
332                                }
333                          }
334                      }
335                     indentCurrent = indentNext;
336                     styler.SetLevel(lineCurrent, lev);
337                     lineCurrent++;
338  		}
339  	}
340  }
341  LexerModule lmScriptol(SCLEX_SCRIPTOL, ColouriseSolDoc, "scriptol", FoldSolDoc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCOBOL.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexScriptol.cxx</div>
                </div>
                <div class="column column_space"><pre><code>161              chNext = styler.SafeGetCharAt(i + 2);
162              chPrev = ' ';
163              i += 1;
</pre></code></div>
                <div class="column column_space"><pre><code>134               chNext = styler.SafeGetCharAt(i + 2);
135               chPrev  = ' ';
136               chPrev2 = ' ';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    