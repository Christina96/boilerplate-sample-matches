
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.86141164348274%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-pooling_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cfloat>
3  #include <vector>
4  #include "caffe/common.hpp"
5  #include "caffe/layer.hpp"
6  #include "caffe/syncedmem.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #include "caffe/layers/pooling_layer.hpp"
9  namespace caffe {
10  using std::min;
11  using std::max;
12  template <typename Dtype>
13  void PoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
14        const vector<Blob<Dtype>*>& top) {
15    PoolingParameter pool_param = this->layer_param_.pooling_param();
16    channel_axis_ = bottom[0]->CanonicalAxisIndex(pool_param.axis());
17    channels_ = bottom[0]->shape(channel_axis_);
18    const int first_spatial_axis = channel_axis_ + 1;
19    const int num_axes = bottom[0]->num_axes();
20    num_spatial_axes_ = num_axes - first_spatial_axis;
21    CHECK_GE(num_spatial_axes_, 1);
22    if (num_spatial_axes_ == 2) {
23        if (pool_param.global_pooling()) {
24          CHECK(!(pool_param.has_kernel_size() ||
25            pool_param.has_kernel_h() || pool_param.has_kernel_w()))
26            << "With Global_pooling: true Filter size cannot specified";
27        } else {
28          CHECK(!pool_param.has_kernel_size() !=
29            !(pool_param.has_kernel_h() && pool_param.has_kernel_w()))
30            << "Filter size is kernel_size OR kernel_h and kernel_w; not both";
31          CHECK(pool_param.has_kernel_size() ||
32            (pool_param.has_kernel_h() && pool_param.has_kernel_w()))
33            << "For non-square filters both kernel_h and kernel_w are required.";
34        }
35        CHECK((!pool_param.has_pad() && pool_param.has_pad_h()
36            && pool_param.has_pad_w())
37            || (!pool_param.has_pad_h() && !pool_param.has_pad_w()))
38            << "pad is pad OR pad_h and pad_w are required.";
39        CHECK((!pool_param.has_stride() && pool_param.has_stride_h()
40            && pool_param.has_stride_w())
41            || (!pool_param.has_stride_h() && !pool_param.has_stride_w()))
42            << "Stride is stride OR stride_h and stride_w are required.";
43        global_pooling_ = pool_param.global_pooling();
44        if (global_pooling_) {
45          kernel_h_ = bottom[0]->height();
46          kernel_w_ = bottom[0]->width();
47        } else {
48          if (pool_param.has_kernel_size()) {
49            kernel_h_ = kernel_w_ = pool_param.kernel_size();
50          } else {
51            kernel_h_ = pool_param.kernel_h();
52            kernel_w_ = pool_param.kernel_w();
53          }
54        }
55        CHECK_GT(kernel_h_, 0) << "Filter dimensions cannot be zero.";
56        CHECK_GT(kernel_w_, 0) << "Filter dimensions cannot be zero.";
57        if (!pool_param.has_pad_h()) {
58          pad_h_ = pad_w_ = pool_param.pad();
59        } else {
60          pad_h_ = pool_param.pad_h();
61          pad_w_ = pool_param.pad_w();
62        }
63        if (!pool_param.has_stride_h()) {
64          stride_h_ = stride_w_ = pool_param.stride();
65        } else {
66          stride_h_ = pool_param.stride_h();
67          stride_w_ = pool_param.stride_w();
68        }
69        if (global_pooling_) {
70          CHECK(pad_h_ == 0 && pad_w_ == 0 && stride_h_ == 1 && stride_w_ == 1)
71            << "With Global_pooling: true; only pad = 0 and stride = 1";
72        }
73        if (pad_h_ != 0 || pad_w_ != 0) {
74          CHECK(this->layer_param_.pooling_param().pool()
75              == PoolingParameter_PoolMethod_AVE
76              || this->layer_param_.pooling_param().pool()
77              == PoolingParameter_PoolMethod_MAX)
78              << "Padding implemented only for average and max pooling.";
79          CHECK_LT(pad_h_, kernel_h_);
80          CHECK_LT(pad_w_, kernel_w_);
81        }
82      } else if (num_spatial_axes_ == 3) {
83        vector<int> bottom_dim_blob_shape(1, num_spatial_axes_ + 1);
84        input_shape_.Reshape(bottom_dim_blob_shape);
85        int* input_shape_data = input_shape_.mutable_cpu_data();
86        for (int i = 0; i < num_spatial_axes_ + 1; ++i) {
87          input_shape_data[i] = bottom[0]->shape(channel_axis_ + i);
88        }
89        vector<int> spatial_dim_blob_shape(1, num_spatial_axes_);
90        global_pooling_ = pool_param.global_pooling();
91        kernel_shape_.Reshape(spatial_dim_blob_shape);
92        int* kernel_shape_data = kernel_shape_.mutable_cpu_data();
93        if (global_pooling_) {
94          CHECK_GE(0, pool_param.kernel_size_3d_size())
95              << "With Global_pooling: true Filter size cannot specified.";
96          CHECK(!pool_param.has_kernel_h() || !pool_param.has_kernel_w())
97              << "With Global_pooling: true Filter size cannot specified.";
98          for (int i = 0; i < num_spatial_axes_ + 1; ++i) {
99            kernel_shape_data[i] = bottom[0]->shape(channel_axis_ + i);
100          }
101        } else {
102          if (pool_param.has_kernel_h() || pool_param.has_kernel_w()) {
103              CHECK_EQ(num_spatial_axes_, 2)
104                << "kernel_h & kernel_w can only be used for 2D pooling.";
105              CHECK_EQ(0, pool_param.kernel_size_3d_size())
106                << "Either kernel_size or kernel_h/w should be specified, not both.";
107              kernel_shape_data[0] = pool_param.kernel_h();
108              kernel_shape_data[1] = pool_param.kernel_w();
109          } else {
110              const int num_kernel_dims = pool_param.kernel_size_3d_size();
111              CHECK(num_kernel_dims == 1 || num_kernel_dims == num_spatial_axes_)
112                << "kernel_size must be specified once, or once per spatial dimension"
113                << " (kernel_size specified " << num_kernel_dims << " times "
114                << num_spatial_axes_ << " spatial dims).";
115              for (int i = 0; i < num_spatial_axes_; ++i) {
116                  kernel_shape_data[i] = pool_param.kernel_size_3d((num_kernel_dims == 1) ? 0 : i);
117              }
118          }
119        }
120        for (int i = 0; i < num_spatial_axes_; ++i) {
121            CHECK_GT(kernel_shape_data[i], 0) << "Filter dimensions must be nonzero.";
122        }
123        pad_.Reshape(spatial_dim_blob_shape);
124        int* pad_data = pad_.mutable_cpu_data();
125        int pad_sum = 0;
126        if (pool_param.has_pad_h() || pool_param.has_pad_w()) {
127            CHECK_EQ(num_spatial_axes_, 2)
128              << "pad_h & pad_w can only be used for 2D convolution.";
129            CHECK_EQ(0, pool_param.pad_3d_size())
130              << "Either pad or pad_h/w should be specified, not both.";
131            pad_data[0] = pool_param.pad_h();
132            pad_data[1] = pool_param.pad_w();
133        } else {
134          const int num_pad_dims = pool_param.pad_3d_size();
135          CHECK(num_pad_dims == 0 || num_pad_dims == 1 ||
136                num_pad_dims == num_spatial_axes_)
137              << "pad must be specified once, or once per spatial dimension "
138              << "(pad specified " << num_pad_dims << " times "
139              << num_spatial_axes_ << " spatial dims).";
140          const int kDefaultPad = 0;
141          for (int i = 0; i < num_spatial_axes_; ++i) {
142            pad_data[i] = (num_pad_dims == 0) ? kDefaultPad :
143                pool_param.pad_3d((num_pad_dims == 1) ? 0 : i);
144            if (global_pooling_) {
145                CHECK_EQ(pad_data[i], 0)
146                  << "With Global_pooling: true; pool = 0";
147              }
148            CHECK_LT(pad_data[i], kernel_shape_data[i]);
149            pad_sum += pad_data[i];
150          }
151        }
152        if (pad_sum != 0) {
153           CHECK(this->layer_param_.pooling_param().pool() ==
154            PoolingParameter_PoolMethod_AVE
155            || this->layer_param_.pooling_param().pool() ==
156            PoolingParameter_PoolMethod_MAX)
157              << "Padding implemented only for average and max pooling.";
158        }
159        stride_.Reshape(spatial_dim_blob_shape);
160        int* stride_data = stride_.mutable_cpu_data();
161        if (pool_param.has_stride_h() || pool_param.has_stride_w()) {
162          CHECK_EQ(num_spatial_axes_, 2)
163              << "stride_h & stride_w can only be used for 2D convolution.";
164          CHECK_EQ(0, pool_param.stride_3d_size())
165              << "Either stride or stride_h/w should be specified, not both.";
166          stride_data[0] = pool_param.stride_h();
167          stride_data[1] = pool_param.stride_w();
168        } else {
169          const int num_stride_dims = pool_param.stride_3d_size();
170          CHECK(num_stride_dims == 0 || num_stride_dims == 1 ||
171                num_stride_dims == num_spatial_axes_)
172              << "stride must be specified once, or once per spatial dimension "
173              << "(stride specified " << num_stride_dims << " times "
174              << num_spatial_axes_ << " spatial dims).";
175          const int kDefaultStride = 1;
176          for (int i = 0; i < num_spatial_axes_; ++i) {
177            stride_data[i] = (num_stride_dims == 0) ? kDefaultStride :
178                pool_param.stride_3d((num_stride_dims == 1) ? 0 : i);
179            CHECK_GT(stride_data[i], 0) << "Stride dimensions must be nonzero.";
180            if (global_pooling_) {
181              CHECK_EQ(stride_data[i], 1)
182                << "With Global_pooling: true; stride = 1";
183            }
184          }
185        }
186      } else {
187        NOT_IMPLEMENTED;
188      }
189  }
190  template <typename Dtype>
191  void PoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
192        const vector<Blob<Dtype>*>& top) {
193    PoolingParameter pool_param = this->layer_param_.pooling_param();
194    channel_axis_ = bottom[0]->CanonicalAxisIndex(pool_param.axis());
195    num_ = bottom[0]->count(0, channel_axis_);
196    const int first_spatial_axis = channel_axis_ + 1;
197    const int num_axes = bottom[0]->num_axes();
198    num_spatial_axes_ = num_axes - first_spatial_axis;
199    CHECK_GE(num_spatial_axes_, 1);
200    if (num_spatial_axes_ == 2) {
201        CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
202            << "corresponding to (num, channels, height, width).";
203        channels_ = bottom[0]->channels();
204        height_ = bottom[0]->height();
205        width_ = bottom[0]->width();
206        if (global_pooling_) {
207          kernel_h_ = bottom[0]->height();
208          kernel_w_ = bottom[0]->width();
209        }
210        pooled_height_ = static_cast<int>(ceil(static_cast<float>(
211            height_ + 2 * pad_h_ - kernel_h_) / stride_h_)) + 1;
212        pooled_width_ = static_cast<int>(ceil(static_cast<float>(
213            width_ + 2 * pad_w_ - kernel_w_) / stride_w_)) + 1;
214        if (pad_h_ || pad_w_ || kernel_h_ == 1 || kernel_w_ == 1) {
215          if ((pooled_height_ - 1) * stride_h_ >= height_ + pad_h_) {
216            --pooled_height_;
217          }
218          if ((pooled_width_ - 1) * stride_w_ >= width_ + pad_w_) {
219            --pooled_width_;
220          }
221          CHECK_LT((pooled_height_ - 1) * stride_h_, height_ + pad_h_);
222          CHECK_LT((pooled_width_ - 1) * stride_w_, width_ + pad_w_);
223        }
224        top[0]->Reshape(bottom[0]->num(), channels_, pooled_height_,
225            pooled_width_);
226        if (top.size() > 1) {
227          top[1]->ReshapeLike(*top[0]);
228        }
229        if (this->layer_param_.pooling_param().pool() ==
230            PoolingParameter_PoolMethod_MAX && top.size() == 1) {
231          max_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_,
232              pooled_width_);
233        }
234        if (this->layer_param_.pooling_param().pool() ==
235            PoolingParameter_PoolMethod_STOCHASTIC) {
236          rand_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_, pooled_width_);
237        }
238    } else if (num_spatial_axes_ == 3) {
239        int* kernel_shape_data = kernel_shape_.mutable_cpu_data();
240        const int* input_shape_data = this->input_shape_.cpu_data();
241        if (global_pooling_) {
242          for (int i = 0; i < num_spatial_axes_; ++i) {
243            kernel_shape_data[i] = input_shape_data[i+1];
244          }
245        }
246        const int* pad_data = this->pad_.cpu_data();
247        const int* stride_data = this->stride_.cpu_data();
248        vector<int> spatial_dim_blob_shape(1, num_spatial_axes_);
249        output_shape_.Reshape(spatial_dim_blob_shape);
250        int* output_shape_data = output_shape_.mutable_cpu_data();
251        int pad_sum = 0;
252        for (int i = 0; i < num_spatial_axes_; ++i) {
253          int oc = static_cast<int>(ceil(static_cast<float>(
254                input_shape_data[i+1] + 2 * pad_data[i]
255                - kernel_shape_data[i]) / stride_data[i])) + 1;
256          pad_sum += pad_data[i];
257          output_shape_data[i] = oc;
258        }
259        if (pad_sum) {
260          for (int i = 0; i < num_spatial_axes_; ++i) {
261              if ((output_shape_data[i] - 1) * stride_data[i] >=
262                input_shape_data[i+1] + pad_data[i])
263                  --output_shape_data[i];
264              CHECK_LT((output_shape_data[i] - 1) * stride_data[i],
265                input_shape_data[i+1] + pad_data[i]);
266          }
267        }
268        vector<int> top_shape = bottom[0]->shape();
269        top_shape.resize(first_spatial_axis);
270        for (int i = 0; i < num_spatial_axes_; ++i) {
271            top_shape.push_back(output_shape_data[i]);
272        }
273        top[0]->Reshape(top_shape);
274        if (top.size() > 1) {
275          top[1]->ReshapeLike(*top[0]);
276        }
277        if (this->layer_param_.pooling_param().pool() ==
278            PoolingParameter_PoolMethod_MAX && top.size() == 1) {
279          max_idx_.Reshape(top_shape);
280        }
281        if (this->layer_param_.pooling_param().pool() ==
282            PoolingParameter_PoolMethod_STOCHASTIC) {
283          rand_idx_.Reshape(top_shape);
284        }
285    } else {
286      NOT_IMPLEMENTED;
287    }
288  }
289  template <typename Dtype>
290  void PoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
291        const vector<Blob<Dtype>*>& top) {
292    const Dtype* bottom_data = bottom[0]->cpu_data();
293    Dtype* top_data = top[0]->mutable_cpu_data();
294    const int top_count = top[0]->count();
295    const bool use_top_mask = top.size() > 1;
296    if (num_spatial_axes_ == 2) {
297        typename PoolingCodeGeneratorForward<Dtype>::Callback_t* generator_func =
298                 Forward_code_generator.Get_callback(this, top[0], use_top_mask);
299        void* mask = NULL;
300        if (this->layer_param_.pooling_param().pool() ==
301            PoolingParameter_PoolMethod_MAX ) {
302          mask = (use_top_mask) ? static_cast<void*>(top[1]->mutable_cpu_data()) :
303                                  static_cast<void*>(max_idx_.mutable_cpu_data());
304        }
305        const int batch_size = bottom[0]->num();
306        const int num_channels = bottom[0]->channels();
307  #ifdef _OPENMP
308    #if defined(_MSC_EXTENSIONS)
309      #pragma omp parallel for
310    #else
311      #pragma omp parallel for collapse(2)
312    #endif
313  #endif
314        for (int image = 0; image < batch_size; ++image)
315          for (int channel = 0; channel < num_channels; ++channel)
316            generator_func(bottom_data,
317                           top_data,
318                           top_count,
319                           image,
320                           image+1,
321                           mask,
322                           channel,
323                           channel+1,
324                           this,
325                           use_top_mask);
326    } else if (num_spatial_axes_ == 3) {
327        vector<int> offset(2, 0);
328        offset[1] = 1;
329        const int* kernel_shape = kernel_shape_.cpu_data();
330        const int* pad_data = this->pad_.cpu_data();
331        const int* stride_data = this->stride_.cpu_data();
332        const int* input_shape_data = this->input_shape_.cpu_data();
333        const int* output_shape_data = this->output_shape_.cpu_data();
334        long bottom_offset = bottom[0]->offset(offset);
335        long top_offset = top[0]->offset(offset);
336        switch (this->layer_param_.pooling_param().pool()) {
337        case PoolingParameter_PoolMethod_MAX:
338          if (use_top_mask) {
339            caffe_set(top_count, Dtype(-1), top[1]->mutable_cpu_data());
340          } else {
341            caffe_set(top_count, -1, max_idx_.mutable_cpu_data());
342          }
343          caffe_set(top_count, Dtype(-FLT_MAX), top_data);
344  #ifdef _OPENMP
345    #if defined(_MSC_EXTENSIONS)
346      #pragma omp parallel for
347    #else
348      #pragma omp parallel for collapse(2)
349    #endif
350  #endif
351          for (int n = 0; n < num_; ++n) {
352            for (int c = 0; c < channels_; ++c) {
353              long nc = n * channels_ + c;
354              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
355              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
356              Dtype *top_mask = NULL;
357              int *mask = NULL;
358              if (use_top_mask) {
359                top_mask = top[1]->mutable_cpu_data() + nc * top_offset;
360              } else {
361                mask = max_idx_.mutable_cpu_data() + nc * top_offset;
362              }
363              for (int pz = 0; pz < output_shape_data[0]; ++pz) {
364                for (int ph = 0; ph < output_shape_data[1]; ++ph) {
365                  for (int pw = 0; pw < output_shape_data[2]; ++pw) {
366                      int zstart = pz * stride_data[0] - pad_data[0];
367                      int hstart = ph * stride_data[1] - pad_data[1];
368                      int wstart = pw * stride_data[2] - pad_data[2];
369                      int zend = min(zstart + kernel_shape[0], input_shape_data[1]);
370                      int hend = min(hstart + kernel_shape[1], input_shape_data[2]);
371                      int wend = min(wstart + kernel_shape[2], input_shape_data[3]);
372                      hstart = max(hstart, 0);
373                      wstart = max(wstart, 0);
374                      zstart = max(zstart, 0);
375                      const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
376                      for (int z = zstart; z < zend; ++z) {
377                        for (int h = hstart; h < hend; ++h) {
378                          for (int w = wstart; w < wend; ++w) {
379                            const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
<span onclick='openModal()' class='match'>380                            if (bottom_data2[index] > top_data2[pool_index]) {
381                              top_data2[pool_index] = bottom_data2[index];
382                              if (use_top_mask) {
383                                top_mask[pool_index] = static_cast<Dtype>(index);
384                              } else {
385                                mask[pool_index] = index;
386                              }
</span>387                            }
388                          }
389                        }
390                      }
391                  }
392                }
393              }
394            }
395          }
396          break;
397        case PoolingParameter_PoolMethod_AVE:
398          caffe_set(top_count, Dtype(0), top_data);
399  #ifdef _OPENMP
400    #if defined(_MSC_EXTENSIONS)
401      #pragma omp parallel for
402    #else
403      #pragma omp parallel for collapse(2)
404    #endif
405  #endif
406          for (int n = 0; n < num_; ++n) {
407            for (int c = 0; c < channels_; ++c) {
408              long nc = n * channels_ + c;
409              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
410              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
411              for (int pz = 0; pz < output_shape_data[0]; ++pz) {
412                for (int ph = 0; ph < output_shape_data[1]; ++ph) {
413                  for (int pw = 0; pw < output_shape_data[2]; ++pw) {
414                    int zstart = pz * stride_data[0] - pad_data[0];
415                    int hstart = ph * stride_data[1] - pad_data[1];
416                    int wstart = pw * stride_data[2] - pad_data[2];
417                    int zend = min(zstart + kernel_shape[0],
418                             input_shape_data[1] + pad_data[0]);
419                    int hend = min(hstart + kernel_shape[1],
420                              input_shape_data[2] + pad_data[1]);
421                    int wend = min(wstart + kernel_shape[2],
422                            input_shape_data[3] + pad_data[2]);
423                    int pool_size = (hend - hstart) *
424                                    (wend - wstart) *
425                                    (zend - zstart);
426                    hstart = max(hstart, 0);
427                    wstart = max(wstart, 0);
428                    zstart = max(zstart, 0);
429                    zend = min(zend, input_shape_data[1]);
430                    hend = min(hend, input_shape_data[2]);
431                    wend = min(wend, input_shape_data[3]);
432                    const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
433                    for (int z = zstart; z < zend; ++z) {
434                      for (int h = hstart; h < hend; ++h) {
435                        for (int w = wstart; w < wend; ++w) {
436                          const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
437                          top_data2[pool_index] += bottom_data2[index];
438                        }
439                      }
440                    }
441                    top_data2[pool_index] /= pool_size;
442                  }
443                }
444              }
445            }
446          }
447          break;
448        case PoolingParameter_PoolMethod_STOCHASTIC:
449          NOT_IMPLEMENTED;
450          break;
451        default:
452          LOG(FATAL) << "Unknown pooling method.";
453        }
454      } else {
455        NOT_IMPLEMENTED;
456      }
457  }
458  template <typename Dtype>
459  void PoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
460        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
461    if (!propagate_down[0]) {
462      return;
463    }
464    const Dtype* top_diff = top[0]->cpu_diff();
465    Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
466    caffe_set(bottom[0]->count(), Dtype(0), bottom_diff);
467    const bool use_top_mask = top.size() > 1;
468    if (num_spatial_axes_ == 2) {
469        typename PoolingCodeGeneratorBackward<Dtype>::Callback_t* generator_func =
470                            Backward_code_generator.Get_callback(this, top[0]);
471        void* mask = NULL;
472        if (this->layer_param_.pooling_param().pool() ==
473            PoolingParameter_PoolMethod_MAX ) {
474          mask = (use_top_mask) ? static_cast<void*>(top[1]->mutable_cpu_data()) :
475                                  static_cast<void*>(max_idx_.mutable_cpu_data());
476        }
477        const int batch_size = bottom[0]->num();
478        const int num_channels = bottom[0]->channels();
479  #ifdef _OPENMP
480    #if defined(_MSC_EXTENSIONS)
481      #pragma omp parallel for
482    #else
483      #pragma omp parallel for collapse(2)
484    #endif
485  #endif
486        for (int image = 0; image < batch_size; ++image)
487          for (int channel = 0; channel < num_channels; ++channel)
488            generator_func(top_diff,
489                           bottom_diff,
490                           image,
491                           image+1,
492                           channel,
493                           channel+1,
494                           use_top_mask,
495                           mask,
496                           this);
497        } else if (num_spatial_axes_ == 3) {
498          const int* kernel_shape = this->kernel_shape_.cpu_data();
499          const int* pad_data = this->pad_.cpu_data();
500          const int* stride_data = this->stride_.cpu_data();
501          const int* input_shape_data = this->input_shape_.cpu_data();
502          const int* output_shape_data = this->output_shape_.cpu_data();
503          int top_num = top[0]->count(0, channel_axis_);
504          vector<int> offset(2, 0);
505          offset[1] = 1;
506          long bottom_offset = bottom[0]->offset(offset);
507          long top_offset = top[0]->offset(offset);
508          switch (this->layer_param_.pooling_param().pool()) {
509          case PoolingParameter_PoolMethod_MAX:
510  #ifdef _OPENMP
511    #if defined(_MSC_EXTENSIONS)
512      #pragma omp parallel for
513    #else
514      #pragma omp parallel for collapse(2)
515    #endif
516  #endif
517            for (int n = 0; n < top_num; ++n) {
518              for (int c = 0; c < channels_; ++c) {
519                long nc = n * channels_ + c;
520                Dtype *bottom_diff2 = bottom[0]->mutable_cpu_diff() + nc * bottom_offset;
521                const Dtype *top_diff2 = top[0]->cpu_diff() + nc * top_offset;
522                const Dtype *top_mask = NULL;
523                const int *mask = NULL;
524                if (use_top_mask) {
525                  top_mask = top[1]->cpu_data() + nc * top_offset;
526                } else {
527                  mask = max_idx_.cpu_data() + nc * top_offset;
528                }
529                for (int pz = 0; pz < output_shape_data[0]; ++pz) {
530                  for (int ph = 0; ph < output_shape_data[1]; ++ph) {
531                    for (int pw = 0; pw < output_shape_data[2]; ++pw) {
532                      const int index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
533                      const int bottom_index = use_top_mask ? top_mask[index] : mask[index];
534                      bottom_diff2[bottom_index] += top_diff2[index];
535                    }
536                  }
537                }
538              }
539            }
540            break;
541          case PoolingParameter_PoolMethod_AVE:
542  #ifdef _OPENMP
543    #if defined(_MSC_EXTENSIONS)
544      #pragma omp parallel for
545    #else
546      #pragma omp parallel for collapse(2)
547    #endif
548  #endif
549            for (int n = 0; n < top_num; ++n) {
550              for (int c = 0; c < channels_; ++c) {
551                long nc = n * channels_ + c;
552                Dtype *bottom_diff2 = bottom[0]->mutable_cpu_diff() + nc * bottom_offset;
553                const Dtype *top_diff2 = top[0]->cpu_diff() + nc * top_offset;
554                for (int pz = 0; pz < output_shape_data[0]; ++pz) {
555                  for (int ph = 0; ph < output_shape_data[1]; ++ph) {
556                    for (int pw = 0; pw < output_shape_data[2]; ++pw) {
557                      int zstart = pz * stride_data[0] - pad_data[0];
558                      int hstart = ph * stride_data[1] - pad_data[1];
559                      int wstart = pw * stride_data[2] - pad_data[2];
560                      int zend = min(zstart + kernel_shape[0], input_shape_data[1] + pad_data[0]);
561                      int hend = min(hstart + kernel_shape[1], input_shape_data[2] + pad_data[1]);
562                      int wend = min(wstart + kernel_shape[2], input_shape_data[3] + pad_data[2]);
563                      int pool_size = (hend - hstart) * (wend - wstart) * (zend - zstart);
564                      hstart = max(hstart, 0);
565                      wstart = max(wstart, 0);
566                      zstart = max(zstart, 0);
567                      zend = min(zend, input_shape_data[1]);
568                      hend = min(hend, input_shape_data[2]);
569                      wend = min(wend, input_shape_data[3]);
570                      const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
571                      for (int z = zstart; z < zend; ++z) {
572                        for (int h = hstart; h < hend; ++h) {
573                          for (int w = wstart; w < wend; ++w) {
574                            const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
575                            bottom_diff2[index] += top_diff2[pool_index] / pool_size;
576                          }
577                        }
578                      }
579                    }
580                  }
581                }
582              }
583            }
584            break;
585          case PoolingParameter_PoolMethod_STOCHASTIC:
586            NOT_IMPLEMENTED;
587            break;
588          default:
589            LOG(FATAL) << "Unknown pooling method.";
590        }
591      } else {
592        NOT_IMPLEMENTED;
593      }
594  }
595  #ifdef CPU_ONLY
596  STUB_GPU(PoolingLayer);
597  #endif
598  INSTANTIATE_CLASS(PoolingLayer);
599  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahooex.cpp</h3>
            <pre><code>1  #include "yahooex.h"
2  #include "ss.h"
3  const TStr TYExpr::LogFPfx="Log";
4  const TStr TYExpr::DatFExt=".Dat";
5  const TStr TYExpr::TxtFExt=".Txt";
6  const TStr TYExpr::TmpFExt=".Tmp";
7  const TStr TYExpr::YWebBsFPfx="Y";
8  const TStr TYExpr::YTsWebBsFPfx="YTs";
9  const TStr TYExpr::YBsFPfx="YBs";
10  const TStr TYExpr::YWordFPfx="YWord";
11  const TStr TYExpr::YCtgFPfx="YCtg";
12  const TStr TYExpr::YMdFPfx="YMd";
13  const TStr TYExpr::YDsBsFPfx="YDsBs";
14  const TStr TYExpr::YFSelFPfx="YFSel";
15  const TStr TYExpr::YInvIxFPfx="YInvIx";
16  void TYExpr::GenYBs(
17   const TStr& YRootFPath, const TStr& YDmNm, const PNotify& Notify){
18    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
19    PXWebBs WebBs=PXWebBs(new TWebMemBs(NrYRootFPath+YWebBsFPfx+YDmNm));
20    PYBs YBs=PYBs(new TYBs(WebBs, 5, 4, swstEnglish523, TStrV(), Notify));
21    YBs->Save(NrYRootFPath+YBsFPfx+YDmNm+DatFExt);
22    YBs->SaveTxt(NrYRootFPath+YBsFPfx+YDmNm+TxtFExt);
23    YBs->SaveTxtWords(NrYRootFPath+YWordFPfx+YDmNm+TxtFExt);
24    YBs->SaveTxtCtgs(NrYRootFPath+YCtgFPfx+YDmNm+TxtFExt);
25  }
26  void TYExpr::GenYDsBs(
27   const TStr& YRootFPath, const TStr& YDmNm, const PNotify& Notify){
28    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
29    TStr YBsFNm=NrYRootFPath+YBsFPfx+YDmNm+DatFExt;
30    TStr YDsBsFNm=NrYRootFPath+YDsBsFPfx+YDmNm+DatFExt;
31    TStr YDsBsTxtFNm=NrYRootFPath+YDsBsFPfx+YDmNm+TxtFExt;
32    TFIn YBsFIn(YBsFNm);
33    PYBs YBs=PYBs(new TYBs(YBsFIn));
34    PYDsBs YDsBs=PYDsBs(new TYDsBs(ydnLnSects, 1.00, 0.001, 0.0001, YBs, Notify));
35    YDsBs->Save(YDsBsFNm);
36    YDsBs->SaveTxt(TFOut::New(YDsBsTxtFNm), YBs);
37  }
38  void TYExpr::PutMomHd(TOLx& Lx, const TStr& VarNm){
39    Lx.PutUQStr(VarNm+"Mean"); Lx.PutUQStr(VarNm+"SDev");
40    Lx.PutUQStr(VarNm+"SErr"); Lx.PutUQStr(VarNm+"Med");
41    Lx.PutUQStr(VarNm+"Q1"); Lx.PutUQStr(VarNm+"Q3");
42  }
43  void TYExpr::PutMomVal(TOLx& Lx, const PMom& Mom){
44    if (Mom->IsUsable()){
45      Lx.PutFlt(Mom->GetMean()); Lx.PutFlt(Mom->GetSDev());
46      Lx.PutFlt(Mom->GetSErr()); Lx.PutFlt(Mom->GetMedian());
47      Lx.PutFlt(Mom->GetQuart1()); Lx.PutFlt(Mom->GetQuart3());
48    } else {
49      for (int MomN=0; MomN<6; MomN++){Lx.PutFlt(-1);}
50    }
51  }
52  void TYExpr::Go(
53   const PSOut& SOut, const bool& PutHd, const bool& SaveTmp,
54   const TStr& YDmNm, const TStr& YRootFPath, const TStr& InfoMsg,
55   const PYBs& _YBs, const PYDsBs& _YDsBs,
56   const PYFSelBs& _YFSelBs, const PYInvIx& _YInvIx,
57   const int& SampleDocs,
58   const int& TsRuns, const int& TsDocs,
59   const int& MnTsWords, const double& MnTsWordPrb, const bool& ExclTs,
60   const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
61   const TYDsBsNrType& YDsBsNrType, const double& YDsBsWordFqExp,
62   const double& YDsBsMnDocWordPrb, const double& YDsBsSumAllWordPrb,
63   const TYFSelType& YFSelType, const TFltV& YFSelsV,
64   const bool& YFSelPosWords, const PAttrEstV& YFSelAttrEstV,
65   const TYNegDsType& YNegDsType, const TYPriorType& YPriorType,
66   const double& YInvIxEstExp, const TFltV& YInvIxSumEstPrbV,
67   const TIntV& YInvIxMnDocFqV,
68   const TFltV& PrRePrbTshV,
69   const int& ShowTopHits, const PNotify& Notify){
70    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
71    if (!_YInvIx.Empty()){
72      IAssert((!_YBs.Empty())&&(!_YDsBs.Empty())&&(!_YFSelBs.Empty()));}
73    if (!_YFSelBs.Empty()){
74      IAssert((!_YBs.Empty())&&(!_YDsBs.Empty()));}
75    if (!_YDsBs.Empty()){
76      IAssert(!_YBs.Empty());}
77    PXWebBs TsWebBs=PXWebBs(new TWebMemBs(NrYRootFPath+YTsWebBsFPfx+YDmNm));
78    TIntV TsWebPgIdV;
79    {int TsWebPgP=TsWebBs->FFirstWebPg(); int TsWebPgId;
80    while (TsWebBs->FNextWebPg(TsWebPgP, TsWebPgId)){
81      TsWebPgIdV.Add(TsWebPgId);}}
82    IAssert(TsRuns*TsDocs<=TsWebPgIdV.Len());
83    TRnd Rnd; TsWebPgIdV.Shuffle(Rnd);
84    for (int TsRunN=0; TsRunN<TsRuns; TsRunN++){
85      int MnTsDocN=TsRunN*TsDocs;
86      int MxTsDocN=MnTsDocN+TsDocs-1;
87      PYBs YBs=_YBs;
88      if (YBs.Empty()){
89        if (ExclTs){
90          TStrV TsUrlStrV;
91          for (int TsWebPgN=MnTsDocN; TsWebPgN<=MxTsDocN; TsWebPgN++){
92            int TsWebPgId=TsWebPgIdV[TsWebPgN];
93            TsUrlStrV.Add(TsWebBs->GetUrlStr(TsWebPgId));
94          }
95          PXWebBs WebBs=new TWebMemBs(NrYRootFPath+YWebBsFPfx+YDmNm);
96          YBs=PYBs(new TYBs(
97           WebBs, MxNGram, MnWordFq, SwSetTy, TsUrlStrV, Notify));
98          if (SaveTmp){YBs->SaveTxt(PSOut(new TFOut(YBsFPfx+YDmNm+TxtFExt)));}
99        } else {
100          TFIn YBsFIn(NrYRootFPath+YBsFPfx+YDmNm+DatFExt);
101          YBs=PYBs(new TYBs(YBsFIn));
102          if (SaveTmp){YBs->SaveTxt(PSOut(new TFOut(YBsFPfx+YDmNm+TxtFExt)));}
103        }
104      }
105      PYDsBs YDsBs=_YDsBs;
106      if (YDsBs.Empty()){
107        YDsBs=PYDsBs(new TYDsBs(YDsBsNrType, YDsBsWordFqExp,
108         YDsBsMnDocWordPrb, YDsBsSumAllWordPrb, YBs, Notify));
109        if (SaveTmp){YDsBs->SaveTxt(PSOut(new TFOut(YDsBsFPfx+YDmNm+TxtFExt)), YBs);}
110      }
111      PMom DocDistMom=PMom(new TMom());
112      PMom DocSectsMom=PMom(new TMom());
113      PMom DocWordsMom=PMom(new TMom());
114      for (int DocIdN=0; DocIdN<SampleDocs; DocIdN++){
115        int DocId1=TInt::GetRnd(YBs->GetDocs());
116        int DocId2=TInt::GetRnd(YBs->GetDocs());
117        int DocDist=YBs->GetDocDist(DocId1, DocId2);
118        int DocSects=YBs->GetDocSects(DocId1);
119        int DocWords=YDsBs->GetWordDs(DocId1)->GetWordIds();
120        if (DocDist!=-1){DocDistMom->Add(DocDist);}
121        DocSectsMom->Add(DocSects);
122        DocWordsMom->Add(DocWords);
123      }
124      DocDistMom->Def();
125      DocSectsMom->Def();
126      DocWordsMom->Def();
127      TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
128      if (PutHd){
129        Lx.PutUQStr("DmNm"); Lx.PutUQStr("Info");
130        Lx.PutUQStr("NrType"); Lx.PutUQStr("WordFqExp");
131        Lx.PutUQStr("MnDocWordPrb"); Lx.PutUQStr("SumAllWordPrb");
132        Lx.PutUQStr("FSelType"); Lx.PutUQStr("FSelPosWords");
133        Lx.PutUQStr("FSels"); Lx.PutUQStr("FSelAttrEst");
134        Lx.PutUQStr("NegDsType"); Lx.PutUQStr("PriorType");
135        Lx.PutUQStr("EstExp"); Lx.PutUQStr("SumEstPrb"); Lx.PutUQStr("MnDocFq");
136        Lx.PutUQStr("TsRunN"); Lx.PutUQStr("MnTsDocN"); Lx.PutUQStr("MxTsDocN");
137        Lx.PutUQStr("MnTsWords"); Lx.PutUQStr("MnTsWordPrb");
138        Lx.PutUQStr("ExclTs");
139        Lx.PutUQStr("PrRcPrbTsh");
140        Lx.PutUQStr("TsDocs"); Lx.PutUQStr("BadTsDocsPrb");
141        Lx.PutUQStr("AllCfs"); Lx.PutUQStr("UnknownCfPrb");
142        PutMomHd(Lx, "Visits"); PutMomHd(Lx, "Plc"); PutMomHd(Lx, "Prb");
143        PutMomHd(Lx, "KwF05"); PutMomHd(Lx, "KwF1"); PutMomHd(Lx, "KwF2");
144        PutMomHd(Lx, "KwF4"); PutMomHd(Lx, "KwF8"); PutMomHd(Lx, "KwF16");
145        PutMomHd(Lx, "KwPrecis"); PutMomHd(Lx, "KwRecall");
146        PutMomHd(Lx, "DocF05"); PutMomHd(Lx, "DocF1"); PutMomHd(Lx, "DocF2");
147        PutMomHd(Lx, "DocF4"); PutMomHd(Lx, "DocF8"); PutMomHd(Lx, "DocF16");
148        PutMomHd(Lx, "DocPrecis"); PutMomHd(Lx, "DocRecall");
149        PutMomHd(Lx, "Prb95Dist"); PutMomHd(Lx, "Prb95Docs");
150        Lx.PutUQStr("Prb95DocsPrb"); Lx.PutUQStr("Prb95NoDocs");
151        PutMomHd(Lx, "Dist"); PutMomHd(Lx, "Sects");
152        Lx.PutUQStr("Sects"); Lx.PutUQStr("AbsSects");
153        PutMomHd(Lx, "Words"); PutMomHd(Lx, "FSelWords");
154        Lx.PutLn();
155      }
156      PSOut LogSOut=new TFOut(LogFPfx+YDmNm+TxtFExt);
157      for (int YFSelsN=0; YFSelsN<YFSelsV.Len(); YFSelsN++){
158        double YFSels=YFSelsV[YFSelsN];
159        TNotify::OnNotify(Notify, ntInfo,
160         TStr("  | YFSels: ")+TFlt::GetStr(YFSels)+"%");
<span onclick='openModal()' class='match'>161        for (int AttrEstN=0; AttrEstN<YFSelAttrEstV.Len(); AttrEstN++){
162          PAttrEst YFSelAttrEst=YFSelAttrEstV[AttrEstN];
163          TStr YFSelAttrEstNm;
164          if (YFSelAttrEst.Empty()){YFSelAttrEstNm="OddsRatio";} \
165          else {YFSelAttrEstNm=YFSelAttrEst->GetNm();}
</span>166          TNotify::OnNotify(Notify, ntInfo,
167            TStr("  |  | AttrEst: ")+YFSelAttrEstNm);
168          PYFSelBs YFSelBs=_YFSelBs;
169          if (YFSelBs.Empty()){
170            YFSelBs=PYFSelBs(new TYFSelBs(
171             YFSelType, YFSels, YFSelPosWords, YFSelAttrEst,
172             YNegDsType, YPriorType, YBs, YDsBs, Notify));
173            if (SaveTmp){
174              PSOut SOut=TFOut::New(YFSelFPfx+YDmNm+TxtFExt);
175              YFSelBs->SaveTxt(SOut, YBs, YDsBs);
176            }
177          }
178          PMom DocFSelWordsMom=PMom(new TMom());
179          for (int DocIdN=0; DocIdN<SampleDocs; DocIdN++){
180            int DocId=TInt::GetRnd(YBs->GetDocs());
181            int DocWords=YFSelBs->GetWords(DocId);
182            DocFSelWordsMom->Add(DocWords);
183          }
184          DocFSelWordsMom->Def();
185          for (int SumEstPrbN=0; SumEstPrbN<YInvIxSumEstPrbV.Len(); SumEstPrbN++){
186            double YInvIxSumEstPrb=YInvIxSumEstPrbV[SumEstPrbN];
187            TNotify::OnNotify(Notify, ntInfo,
188             TStr("  |  |  | SumEstPrb: ")+TFlt::GetStr(YInvIxSumEstPrb));
189            PYInvIx YInvIx=_YInvIx;
190            if (YInvIx.Empty()){
191              YInvIx=PYInvIx(new TYInvIx(YInvIxEstExp, YInvIxSumEstPrb,
192               YBs, YDsBs, YFSelBs, Notify));
193              if (SaveTmp){
194                PSOut SOut=PSOut(new TFOut(YInvIxFPfx+YDmNm+TxtFExt));
195                YInvIx->SaveTxt(SOut, YBs);
196              }
197            }
198            PMd Md=new TMdYBayes(
199             YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx);
200            for (int MnDocFqN=0; MnDocFqN<YInvIxMnDocFqV.Len(); MnDocFqN++){
201              int MnDocFq=YInvIxMnDocFqV[MnDocFqN];
202              TNotify::OnNotify(Notify, ntInfo,
203               TStr("  |  |  |  | MnDocFq: ")+TInt::GetStr(MnDocFq));
204              for (int PrRePrbTshN=0; PrRePrbTshN<PrRePrbTshV.Len(); PrRePrbTshN++){
205                double PrRePrbTsh=PrRePrbTshV[PrRePrbTshN];
206                TNotify::OnNotify(Notify, ntInfo,
207                 TStr("  |  |  |  |  | PrRePrbTsh: ")+TFlt::GetStr(PrRePrbTsh));
208                int BadTsDocs=0;
209                int AllCfs=0; int UnknownCfs=0;
210                PMom VisitsMom=PMom(new TMom());
211                PMom RefDocPlcMom=PMom(new TMom());
212                PMom RefDocPrbMom=PMom(new TMom());
213                PMom KwF05Mom=PMom(new TMom());
214                PMom KwF1Mom=PMom(new TMom());
215                PMom KwF2Mom=PMom(new TMom());
216                PMom KwF4Mom=PMom(new TMom());
217                PMom KwF8Mom=PMom(new TMom());
218                PMom KwF16Mom=PMom(new TMom());
219                PMom KwPrecisMom=PMom(new TMom());
220                PMom KwRecallMom=PMom(new TMom());
221                PMom DocF05Mom=PMom(new TMom());
222                PMom DocF1Mom=PMom(new TMom());
223                PMom DocF2Mom=PMom(new TMom());
224                PMom DocF4Mom=PMom(new TMom());
225                PMom DocF8Mom=PMom(new TMom());
226                PMom DocF16Mom=PMom(new TMom());
227                PMom DocPrecisMom=PMom(new TMom());
228                PMom DocRecallMom=PMom(new TMom());
229                PMom Prb95DistMom=PMom(new TMom());
230                PMom Prb95DocsMom=PMom(new TMom());
231                int Prb95NoDocs=0;
232                for (int TsWebPgN=MnTsDocN; TsWebPgN<=MxTsDocN; TsWebPgN++){
233                  int TsWebPgId=TsWebPgIdV[TsWebPgN];
234                  PXWebPg TsWebPg=TsWebBs->GetWebPg(TsWebPgId);
235                  PYWordDs TsWordDs=YBs->GetWordDs(TsWebPg);
236                  if (SaveTmp){TsWordDs->SaveTxt(LogSOut, YBs());}
237                  TOLx LogLx(LogSOut, TFSet()|oloFrcEoln|oloSigNum);
238                  PValRet ValRet=new TYValRet(
239                   MnTsWordPrb, Md->GetDmHd(), YBs, TsWordDs);
240                  TStr TsUrlStr=TsWebPg->GetUrlStr();
241                  TStr RefUrlStr=TsWebPg->GetRefUrlStrV()[0];
242                  TStr RefUrlStrPath=TUrl(RefUrlStr).GetPathStr();
243                  int RefDocId=YBs->GetDocId(RefUrlStr);
244                  if (SaveTmp){
245                    LogLx.PutVarStr("UrlStr", TsWebPg->GetUrlStr());
246                    LogLx.PutVarStr("FromCategory", RefUrlStrPath);
247                  }
248                  if (TsWordDs->GetSumWordFq()<MnTsWords){
249                    if (SaveTmp){
250                      TChA Msg;
251                      Msg+=" *** Bad Document";
252                      Msg+=TStr(' ')+TFlt::GetStr(YFSels)+'%';
253                      Msg+=TStr(' ')+TFlt::GetStr(MnDocFq);
254                      Msg+=TStr(" [")+TFlt::GetStr(TsWordDs->GetSumWordFq());
255                      Msg+=TStr('<')+TFlt::GetStr(MnTsWords)+']';
256                      TNotify::OnNotify(Notify, ntInfo, Msg);
257                      LogLx.PutVarStr("Classification", Msg);
258                    }
259                    BadTsDocs++; continue;
260                  };
261                  TIntV ClassNV; YInvIx->GetDocIdV(TsWordDs, MnDocFq, ClassNV);
262                  TFltStrKdV PrbUrlStrKdV(ClassNV.Len(), 0);
263                  for (int ClassNN=0; ClassNN<ClassNV.Len(); ClassNN++){
264                    int ClassN=ClassNV[ClassNN];
265                    TStr UrlStr=Md->GetDmHd()->GetClassNm(ClassN);
266                    PTbValDs ValDs=Md->GetPostrValDs(ValRet, ClassN);
267                    double ClassPrb=ValDs->GetPrb_RelFq(TTbVal(true));
268                    PrbUrlStrKdV.Add(TFltStrKd(ClassPrb, UrlStr));
269                  }
270                  PrbUrlStrKdV.Sort(false);
271                  TIntV RefCtgIdV; YBs->GetCtgIdV(RefDocId, RefCtgIdV);
272                  TIntV BestCtgIdV;
273                  {int DocPlcN=0;
274                  while ((DocPlcN<PrbUrlStrKdV.Len())&&
275                   (PrbUrlStrKdV[DocPlcN].Key>PrRePrbTsh)){
276                    TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
277                    int DocId=YBs->GetDocId(UrlStr);
278                    TIntV CtgIdV; YBs->GetCtgIdV(DocId, CtgIdV);
279                    BestCtgIdV.AddVMerged(CtgIdV);
280                    DocPlcN++;
281                  }}
282                  TIntV IntsCtgIdV; RefCtgIdV.Intrs(BestCtgIdV, IntsCtgIdV);
283                  double KwPrecis=1; double KwRecall=1;
284                  double KwF05=0; double KwF1=0; double KwF2=0;
285                  double KwF4=0; double KwF8=0; double KwF16=0;
286                  if (BestCtgIdV.Len()>0){
287                    KwPrecis=IntsCtgIdV.Len()/double(BestCtgIdV.Len());}
288                  if (RefCtgIdV.Len()>0){
289                    KwRecall=IntsCtgIdV.Len()/double(RefCtgIdV.Len());}
290                  if (KwPrecis+KwRecall>0){
291                    KwF05=(1.25*KwPrecis*KwRecall)/(0.25*KwPrecis+KwRecall);
292                    KwF1=(2*KwPrecis*KwRecall)/(1*KwPrecis+KwRecall);
293                    KwF2=(5*KwPrecis*KwRecall)/(4*KwPrecis+KwRecall);
294                    KwF4=(17*KwPrecis*KwRecall)/(16*KwPrecis+KwRecall);
295                    KwF8=(65*KwPrecis*KwRecall)/(64*KwPrecis+KwRecall);
296                    KwF16=(257*KwPrecis*KwRecall)/(256*KwPrecis+KwRecall);
297                  }
298                  KwPrecisMom->Add(KwPrecis); KwRecallMom->Add(KwRecall);
299                  KwF05Mom->Add(KwF05); KwF1Mom->Add(KwF1); KwF2Mom->Add(KwF2);
300                  KwF4Mom->Add(KwF4); KwF8Mom->Add(KwF8); KwF16Mom->Add(KwF16);
301                  TIntV ParentDocIdV; YBs->GetParentDocIdV(RefDocId, ParentDocIdV);
302                  TIntV BestDocIdV;
303                  {int DocPlcN=0;
304                  while ((DocPlcN<PrbUrlStrKdV.Len())&&
305                   (PrbUrlStrKdV[DocPlcN].Key>PrRePrbTsh)){
306                    TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
307                    int DocId=YBs->GetDocId(UrlStr);
308                    BestDocIdV.AddSorted(DocId);
309                    DocPlcN++;
310                  }}
311                  TIntV IntsDocIdV; ParentDocIdV.Intrs(BestDocIdV, IntsDocIdV);
312                  double DocPrecis=1; double DocRecall=1;
313                  double DocF05=0; double DocF1=0; double DocF2=0;
314                  double DocF4=0; double DocF8=0; double DocF16=0;
315                  if (BestDocIdV.Len()>0){
316                    DocPrecis=IntsDocIdV.Len()/double(BestDocIdV.Len());}
317                  if (ParentDocIdV.Len()>0){
318                    DocRecall=IntsDocIdV.Len()/double(ParentDocIdV.Len());}
319                  if (DocPrecis+DocRecall>0){
320                    DocF05=(1.25*DocPrecis*DocRecall)/(0.25*DocPrecis+DocRecall);
321                    DocF1=(2*DocPrecis*DocRecall)/(1*DocPrecis+DocRecall);
322                    DocF2=(5*DocPrecis*DocRecall)/(4*DocPrecis+DocRecall);
323                    DocF4=(17*DocPrecis*DocRecall)/(16*DocPrecis+DocRecall);
324                    DocF8=(65*DocPrecis*DocRecall)/(64*DocPrecis+DocRecall);
325                    DocF16=(257*DocPrecis*DocRecall)/(256*DocPrecis+DocRecall);
326                  }
327                  DocPrecisMom->Add(DocPrecis); DocRecallMom->Add(DocRecall);
328                  DocF05Mom->Add(DocF05); DocF1Mom->Add(DocF1); DocF2Mom->Add(DocF2);
329                  DocF4Mom->Add(DocF4); DocF8Mom->Add(DocF8); DocF16Mom->Add(DocF16);
330                  AllCfs++;
331                  {int DocPlcN=0; int Prb95Docs=0;
332                  while ((DocPlcN<PrbUrlStrKdV.Len())&&
333                   ((DocPlcN<10)||(double(PrbUrlStrKdV[DocPlcN].Key))>0.95)){
334                    double DocPrb=PrbUrlStrKdV[DocPlcN].Key;
335                    TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
336                    int DocDist=YBs->GetDocDist(RefDocId, YBs->GetDocId(UrlStr));
337                    if (DocDist!=-1){
338                      if (DocPrb>0.95){Prb95DistMom->Add(DocDist); Prb95Docs++;}
339                    }
340                    DocPlcN++;
341                  }
342                  Prb95DocsMom->Add(Prb95Docs);
343                  if (Prb95Docs==0){Prb95NoDocs++;}}
344                  int RefDocPlcN=0;
345                  while ((RefDocPlcN<PrbUrlStrKdV.Len())&&
346                   (PrbUrlStrKdV[RefDocPlcN].Dat!=RefUrlStr)){RefDocPlcN++;}
347                  if (RefDocPlcN==PrbUrlStrKdV.Len()){
348                    UnknownCfs++;
349                    VisitsMom->Add(PrbUrlStrKdV.Len());
350                    RefDocPlcMom->Add(
351                     PrbUrlStrKdV.Len()+(YBs->GetDocs()-PrbUrlStrKdV.Len())/2);
352                    RefDocPrbMom->Add(0);
353                    if (SaveTmp){
354                      TStr Msg;
355                      Msg+=TInt::GetStr(PrbUrlStrKdV.Len());
356                      Msg+=TStr(" *** Not Found");
357                      Msg+=TStr(' ')+TFlt::GetStr(YFSels)+'%';
358                      Msg+=TStr(' ')+TFlt::GetStr(MnDocFq);
359                      Msg+=TStr(" [")+TFlt::GetStr(TsWordDs->GetSumWordFq());
360                      Msg+=TStr(">=")+TFlt::GetStr(MnTsWords)+']';
361                      TNotify::OnNotify(Notify, ntInfo, Msg);
362                      LogLx.PutVarStr("Classification", Msg);
363                      LogLx.PutVarStr("RefCtgIdV", YBs->GetCtgIdVStr(RefCtgIdV));
364                      LogLx.PutVarStr("BestCtgIdV", YBs->GetCtgIdVStr(BestCtgIdV));
365                      LogLx.PutVarStr("IntsCtgIdV", YBs->GetCtgIdVStr(IntsCtgIdV));
366                    }
367                  } else {
368                    double RefDocPrb=PrbUrlStrKdV[RefDocPlcN].Key;
369                    int MnRefDocPlcN=RefDocPlcN; int MxRefDocPlcN=RefDocPlcN;
370                    while ((MnRefDocPlcN>0)&&
371                     (fabs(RefDocPrb-PrbUrlStrKdV[MnRefDocPlcN-1].Key)<0.00001)){
372                      MnRefDocPlcN--;}
373                    while ((MxRefDocPlcN<PrbUrlStrKdV.Len()-1)&&
374                     (fabs(RefDocPrb-PrbUrlStrKdV[MxRefDocPlcN+1].Key)<0.00001)){
375                      MxRefDocPlcN++;}
376                    int OrigRefDocPlcN=RefDocPlcN;
377                    RefDocPlcN=(MxRefDocPlcN+MnRefDocPlcN)/2;
378                    VisitsMom->Add(PrbUrlStrKdV.Len());
379                    RefDocPlcMom->Add(RefDocPlcN+1); RefDocPrbMom->Add(RefDocPrb);
380                    TChA Msg;
381                    Msg+=TStr(" place:")+TInt::GetStr(RefDocPlcN+1);
382                    Msg+=TStr(" [orig:")+TInt::GetStr(OrigRefDocPlcN+1)+']';
383                    Msg+=TStr(" prob.:")+TFlt::GetStr(RefDocPrb);
384                    Msg+=TStr(" [first:")+TFlt::GetStr(PrbUrlStrKdV[0].Key)+']';
385                    Msg+=TStr(' ')+TInt::GetStr(PrbUrlStrKdV.Len());
386                    Msg+=TStr(' ')+TFlt::GetStr(YFSels)+'%';
387                    Msg+=TStr(' ')+TFlt::GetStr(MnDocFq);
388                    if (SaveTmp){
389                      TNotify::OnNotify(Notify, ntInfo, Msg);
390                      LogLx.PutVarStr("Classification", Msg);
391                      TChA KwPrRcStr; TChA DocPrRcStr;
392                      KwPrRcStr+=TStr(" P:")+TFlt::GetStr(KwPrecis);
393                      KwPrRcStr+=TStr(" R:")+TFlt::GetStr(KwRecall);
394                      DocPrRcStr+=TStr(" P:")+TFlt::GetStr(DocPrecis);
395                      DocPrRcStr+=TStr(" R:")+TFlt::GetStr(DocRecall);
396                      LogLx.PutVarStr("KwPrRc", KwPrRcStr);
397                      LogLx.PutVarStr("DocPrRc", DocPrRcStr);
398                      LogLx.PutVarStr("RefCtgIdV", YBs->GetCtgIdVStr(RefCtgIdV));
399                      LogLx.PutVarStr("BestCtgIdV", YBs->GetCtgIdVStr(BestCtgIdV));
400                      LogLx.PutVarStr("IntsCtgIdV", YBs->GetCtgIdVStr(IntsCtgIdV));
401                    }
402                  }
403                  if (SaveTmp){
404                    int DocPlcN=0;
405                    while ((DocPlcN<PrbUrlStrKdV.Len())&&(DocPlcN<ShowTopHits)){
406                      double DocPrb=PrbUrlStrKdV[DocPlcN].Key;
407                      TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
408                      int DocId=YBs->GetDocId(UrlStr);
409                      int DocDist=YBs->GetDocDist(RefDocId, DocId);
410                      TChA Msg;
411                      Msg+=TStr("  ")+TInt::GetStr(DocPlcN+1)+'.';
412                      Msg+=TStr(' ')+TFlt::GetStr(DocPrb);
413                      Msg+=TStr(' ')+TInt::GetStr(DocDist);
414                      Msg+=TStr(' ')+TUrl(UrlStr).GetPathStr();
415                      LogLx.PutVarStr("Rank", Msg);
416                      DocPlcN++;
417                    }
418                  }
419                  if (SaveTmp){LogLx.PutLn();}
420                } 
421                VisitsMom->Def(); RefDocPlcMom->Def(); RefDocPrbMom->Def();
422                KwF05Mom->Def(); KwF1Mom->Def(); KwF2Mom->Def();
423                KwF4Mom->Def(); KwF8Mom->Def(); KwF16Mom->Def();
424                KwPrecisMom->Def(); KwRecallMom->Def();
425                DocF05Mom->Def(); DocF1Mom->Def(); DocF2Mom->Def();
426                DocF4Mom->Def(); DocF8Mom->Def(); DocF16Mom->Def();
427                DocPrecisMom->Def(); DocRecallMom->Def();
428                Prb95DistMom->Def(); Prb95DocsMom->Def();
429                Lx.PutStr(YDmNm);
430                if (InfoMsg.Empty()){Lx.PutStr("No");} else {Lx.PutStr(InfoMsg);}
431                Lx.PutStr(TYDsBs::GetNrTypeStr(YDsBsNrType));
432                Lx.PutFlt(YDsBsWordFqExp);
433                Lx.PutFlt(YDsBsMnDocWordPrb);
434                Lx.PutFlt(YDsBsSumAllWordPrb);
435                Lx.PutStr(TYFSelBs::GetYFSelTypeStr(YFSelType));
436                Lx.PutBool(YFSelPosWords);
437                Lx.PutFlt(YFSels);
438                Lx.PutStr(YFSelAttrEstNm);
439                Lx.PutStr(TYDmDs::GetYNegDsTypeStr(YNegDsType));
440                Lx.PutStr(TYDmDs::GetYPriorTypeStr(YPriorType));
441                Lx.PutFlt(YInvIxEstExp);
442                Lx.PutFlt(YInvIxSumEstPrb);
443                Lx.PutInt(MnDocFq);
444                Lx.PutInt(TsRunN); Lx.PutInt(MnTsDocN); Lx.PutInt(MxTsDocN);
445                Lx.PutInt(MnTsWords); Lx.PutFlt(MnTsWordPrb);
446                Lx.PutBool(ExclTs);
447                Lx.PutFlt(PrRePrbTsh);
448                Lx.PutFlt(TsDocs); Lx.PutFlt(BadTsDocs/double(TsDocs));
449                Lx.PutFlt(AllCfs); Lx.PutFlt(UnknownCfs/double(AllCfs));
450                PutMomVal(Lx, VisitsMom);
451                PutMomVal(Lx, RefDocPlcMom); PutMomVal(Lx, RefDocPrbMom);
452                PutMomVal(Lx, KwF05Mom); PutMomVal(Lx, KwF1Mom);
453                PutMomVal(Lx, KwF2Mom); PutMomVal(Lx, KwF4Mom);
454                PutMomVal(Lx, KwF8Mom); PutMomVal(Lx, KwF16Mom);
455                PutMomVal(Lx, KwPrecisMom); PutMomVal(Lx, KwRecallMom);
456                PutMomVal(Lx, DocF05Mom); PutMomVal(Lx, DocF1Mom);
457                PutMomVal(Lx, DocF2Mom); PutMomVal(Lx, DocF4Mom);
458                PutMomVal(Lx, DocF8Mom); PutMomVal(Lx, DocF16Mom);
459                PutMomVal(Lx, DocPrecisMom); PutMomVal(Lx, DocRecallMom);
460                PutMomVal(Lx, Prb95DistMom); PutMomVal(Lx, Prb95DocsMom);
461                Lx.PutFlt((AllCfs-Prb95NoDocs)/double(AllCfs)); Lx.PutInt(Prb95NoDocs);
462                PutMomVal(Lx, DocDistMom); PutMomVal(Lx, DocSectsMom);
463                Lx.PutInt(TInt(YBs->GetSects())); Lx.PutInt(TInt(YBs->GetAbsSects()));
464                PutMomVal(Lx, DocWordsMom); PutMomVal(Lx, DocFSelWordsMom);
465                Lx.PutLn();
466                SOut->Flush();
467              } 
468            } 
469          } 
470        } 
471      }  
472    } 
473    TNotify::OnNotify(Notify, ntInfo, "Finished.");
474  }
475  void TYExpr::ExtrResMlj(const PNotify& Notify){
476    TStrStrVH VarToMomVH(100);
477    VarToMomVH.AddDat("FSels").Add("Mean");
478    VarToMomVH.AddDat("MnDocFq").Add("Mean");
479    VarToMomVH.AddDat("PrRcPrbTsh").Add("Mean");
480    VarToMomVH.AddDat("PlcMed").Add("Mean");
481    VarToMomVH.AddDat("PlcMed").Add("SDev");
482    VarToMomVH.AddDat("PlcMed").Add("SErr");
483    VarToMomVH.AddDat("PrbMed").Add("Mean");
484    VarToMomVH.AddDat("PrbMed").Add("SDev");
485    VarToMomVH.AddDat("PrbMed").Add("SErr");
486    VarToMomVH.AddDat("KwPrecisMed").Add("Mean");
487    VarToMomVH.AddDat("KwPrecisMed").Add("SDev");
488    VarToMomVH.AddDat("KwPrecisMed").Add("SErr");
489    VarToMomVH.AddDat("KwRecallMed").Add("Mean");
490    VarToMomVH.AddDat("KwRecallMed").Add("SDev");
491    VarToMomVH.AddDat("KwRecallMed").Add("SErr");
492    VarToMomVH.AddDat("DocPrecisMed").Add("Mean");
493    VarToMomVH.AddDat("DocPrecisMed").Add("SDev");
494    VarToMomVH.AddDat("DocPrecisMed").Add("SErr");
495    VarToMomVH.AddDat("DocRecallMed").Add("Mean");
496    VarToMomVH.AddDat("DocRecallMed").Add("SDev");
497    VarToMomVH.AddDat("DocRecallMed").Add("SErr");
498    VarToMomVH.AddDat("KwF2").Add("Mean");
499    VarToMomVH.AddDat("KwF2").Add("SDev");
500    VarToMomVH.AddDat("KwF2").Add("SErr");
501    VarToMomVH.AddDat("DocF2").Add("Mean");
502    VarToMomVH.AddDat("DocF2").Add("SDev");
503    VarToMomVH.AddDat("DocF2").Add("SErr");
504    TStrV FPathV; FPathV.Add("../results");
505    TStrV FExtV; FExtV.Add("st");
506    TFFile FFile(FPathV, FExtV); TStr FNm;
507    while (FFile.Next(FNm)){
508      PSIn SIn=new TFIn(FNm);
509      TILx ILx(SIn, TFSet()|iloRetEoln|iloSigNum|iloUniStr);
510      TNotify::OnNotify(Notify, ntInfo, TStr("Processing ")+FNm);
511      TStrV VarNmV;
512      TVec<TVec<TStrV> > VarValVVV;
513      ILx.GetSym();
514      while (ILx.Sym!=syEof){
515        TStrV NmV;
516        IAssert((ILx.Sym==syStr)&&(ILx.Str=="DmNm"));
517        while (ILx.Sym!=syEoln){NmV.Add(ILx.Str); ILx.GetSym();}
518        if (VarNmV.Empty()){VarNmV=NmV;} else {IAssert(VarNmV==NmV);}
519        TVec<TStrV> ValVV;
520        ILx.GetSym();
521        while ((ILx.Sym!=syEof)&&((ILx.Sym!=syStr)||(ILx.Str!="DmNm"))){
522          TStrV ValV(VarNmV.Len(), 0);
523          while (ILx.Sym!=syEoln){ValV.Add(ILx.Str); ILx.GetSym();}
524          IAssert(VarNmV.Len()==ValV.Len());
525          ValVV.Add(ValV);
526          ILx.GetSym();
527        }
528        VarValVVV.Add(ValVV);
529        TNotify::OnNotify(Notify, ntInfo,
530         TStr("... lines ")+TInt::GetStr(ValVV.Len()));
531      }
532      int InvIxMnDocFqVarN=VarNmV.SearchForw("MnDocFq");
533      int PrRcPrbTshVarN=VarNmV.SearchForw("PrRcPrbTsh");
534      THash<TStr, TVec<PMom> > VarNmToValMomVH(100);
535      {int VarToMomVP=VarToMomVH.FFirstKeyId();
536      while (VarToMomVH.FNextKeyId(VarToMomVP)){
537        TStr VarNm=VarToMomVH.GetKey(VarToMomVP);
538        int VarN=VarNmV.SearchForw(VarNm);
539        int Vals=VarValVVV[0].Len();
540        for (int ValN=0; ValN<Vals; ValN++){
541          double InvIxMnDocFq=VarValVVV[0][ValN][InvIxMnDocFqVarN].GetFlt();
542          double PrRcPrbTsh=VarValVVV[0][ValN][PrRcPrbTshVarN].GetFlt();
543          if ((fabs(InvIxMnDocFq-3)>0.0001)||(fabs(PrRcPrbTsh-0.95)>0.0001)){
544            VarNmToValMomVH.AddDat(VarNm).Add(NULL); continue;}
545          PMom ValMom=PMom(new TMom());
546          for (int ValSetN=0; ValSetN<VarValVVV.Len(); ValSetN++){
547            TStr ValStr=VarValVVV[ValSetN][ValN][VarN];
548            double Val=ValStr.GetFlt();
549            ValMom->Add(Val);
550          }
551          ValMom->Def();
552          VarNmToValMomVH.AddDat(VarNm).Add(ValMom);
553        }
554      }}
555      PSOut SOut=PSOut(new TFOut(FNm+"t"));
556      TOLx OLx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
557      {int VarToMomVP=VarToMomVH.FFirstKeyId();
558      while (VarToMomVH.FNextKeyId(VarToMomVP)){
559        TStr VarNm=VarToMomVH.GetKey(VarToMomVP);
560        TStrV& MomNmV=VarToMomVH[VarToMomVP];
561        for (int MomNmN=0; MomNmN<MomNmV.Len(); MomNmN++){
562          OLx.PutUQStr(VarNm+"_"+MomNmV[MomNmN]);
563        }
564      }}
565      OLx.PutLn();
566      int Vals=VarValVVV[0].Len();
567      for (int ValN=0; ValN<Vals; ValN++){
568        double InvIxMnDocFq=VarValVVV[0][ValN][InvIxMnDocFqVarN].GetFlt();
569        double PrRcPrbTsh=VarValVVV[0][ValN][PrRcPrbTshVarN].GetFlt();
570        if ((fabs(InvIxMnDocFq-3)>0.0001)||(fabs(PrRcPrbTsh-0.95)>0.0001)){continue;}
571        {int VarToMomVP=VarToMomVH.FFirstKeyId();
572        while (VarToMomVH.FNextKeyId(VarToMomVP)){
573          TStr VarNm=VarToMomVH.GetKey(VarToMomVP);
574          TStrV& MomNmV=VarToMomVH[VarToMomVP];
575          for (int MomNmN=0; MomNmN<MomNmV.Len(); MomNmN++){
576            PMom Mom=VarNmToValMomVH.GetDat(VarNm)[ValN];
577            double Val=Mom->GetByNm(MomNmV[MomNmN]);
578            OLx.PutFlt(Val);
579          }
580        }}
581        OLx.PutLn();
582      }
583    }
584    TNotify::OnNotify(Notify, ntInfo, "Finished.");
585  }
586  void TYExpr::ExtrResKdd(const PNotify& Notify){
587    TStr FNm="../resultsKdd/resultAllA.st";
588    PSIn SIn=new TFIn(FNm);
589    TILx ILx(SIn, TFSet()|iloRetEoln|iloSigNum|iloUniStr);
590    TNotify::OnNotify(Notify, ntInfo, TStr("Processing ")+FNm);
591    TStrV NmV;
592    TVec<TFltV> ValVV;
593    ILx.GetSym(syStr, syEoln);
594    IAssert((ILx.Sym==syStr)&&(ILx.Str=="DmNm"));
595    while (ILx.Sym!=syEoln){NmV.Add(ILx.Str); ILx.GetSym(syStr, syEoln);}
596    ILx.GetSym(syStr, syFlt, syEof);
597    while (ILx.Sym!=syEof){
598      TFltV ValV(NmV.Len(), 0);
599      while (ILx.Sym!=syEoln){
600        if (ILx.Sym==syFlt){ValV.Add(ILx.Flt);}
601        else if (ILx.Sym==syStr){ValV.Add(TStr(ILx.Str).GetPrimHashCd());}
602        else {Fail;}
603        ILx.GetSym(syStr, syFlt, syEoln);
604      }
605      IAssert(NmV.Len()==ValV.Len());
606      ValVV.Add(ValV);
607      ILx.GetSym(syStr, syFlt, syEof);
608    }
609    TNotify::OnNotify(Notify, ntInfo,
610     TStr("... lines ")+TInt::GetStr(ValVV.Len()));
611    TFltV FSelsV;
612    FSelsV.Add(0.25); FSelsV.Add(0.50); FSelsV.Add(0.75); FSelsV.Add(1.0);
613    FSelsV.Add(1.5); FSelsV.Add(2.0); FSelsV.Add(3.0); FSelsV.Add(5.0);
614    FSelsV.Add(7.0); FSelsV.Add(9.0);
615    TIntV MnDocFqV;
616    MnDocFqV.Add(TInt(1)); MnDocFqV.Add(TInt(2)); MnDocFqV.Add(TInt(3)); 
617    MnDocFqV.Add(TInt(4)); MnDocFqV.Add(TInt(5)); MnDocFqV.Add(TInt(6));
618    MnDocFqV.Add(TInt(7)); MnDocFqV.Add(TInt(8)); MnDocFqV.Add(TInt(9));
619    MnDocFqV.Add(TInt(10));
620    TFltV SumEstPrbV;
621    SumEstPrbV.Add(1.00); SumEstPrbV.Add(0.90); SumEstPrbV.Add(0.80);
622    SumEstPrbV.Add(0.70); SumEstPrbV.Add(0.60); SumEstPrbV.Add(0.50);
623    SumEstPrbV.Add(0.40);
624    int DmNmVarN=NmV.SearchForw("DmNm");
625    int FSelsVarN=NmV.SearchForw("FSels");
626    int SumEstPrbVarN=NmV.SearchForw("SumEstPrb");
627    int MnDocFqVarN=NmV.SearchForw("MnDocFq");
628    int VisitsMeanVarN=NmV.SearchForw("VisitsMean");
629    int VisitsSErrVarN=NmV.SearchForw("VisitsErr");
630    int PlcMedVarN=NmV.SearchForw("PlcMed");
631    int KwPrecisMeanVarN=NmV.SearchForw("KwPrecisMean");
632    int KwRecallMeanVarN=NmV.SearchForw("KwRecallMean");
633    int KwF2VarN=NmV.SearchForw("KwF2");
634    for (int SumEstPrbN=0; SumEstPrbN<SumEstPrbV.Len(); SumEstPrbN++){
635      TStr OutFNm="../resultskdd/tt/EntSMF1_"+TInt::GetStr(SumEstPrbN)+".st";
636      TNotify::OnNotify(Notify, ntInfo, TStr("... writing ")+OutFNm);
637      PSOut SOut=PSOut(new TFOut(OutFNm));
638      TOLx OLx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
639      OLx.PutUQStr("FSels");
640      OLx.PutUQStr("SumEstPrb");
641      OLx.PutUQStr("MnDocFq");
642      OLx.PutUQStr("VisitsMean");
643      OLx.PutUQStr("VisitsSErr");
644      OLx.PutUQStr("PlcMed");
645      OLx.PutUQStr("KwPrecisMean");
646      OLx.PutUQStr("KwRecallMean");
647      OLx.PutUQStr("KwF2");
648      OLx.PutLn();
649      double SumEstPrb=SumEstPrbV[SumEstPrbN];
650      for (int MnDocFqN=0; MnDocFqN<MnDocFqV.Len(); MnDocFqN++){
651        double MnDocFq=MnDocFqV[MnDocFqN];
652        for (int FSelsN=0; FSelsN<FSelsV.Len(); FSelsN++){
653          double FSels=FSelsV[FSelsN];
654          if (!TFlt::Eq6(FSels, 1.0)){continue;}
655          for (int ValN=0; ValN<ValVV.Len(); ValN++){
656            int DmNmHashCd=int(ValVV[ValN][DmNmVarN]);
657            if (DmNmHashCd!=TStr("Ent").GetPrimHashCd()){continue;}
658            double FSelsVal=ValVV[ValN][FSelsVarN];
659            double SumEstPrbVal=ValVV[ValN][SumEstPrbVarN];
660            double MnDocFqVal=ValVV[ValN][MnDocFqVarN];
661            double VisitsMeanVal=ValVV[ValN][VisitsMeanVarN];
662            double VisitsSErrVal=ValVV[ValN][VisitsSErrVarN];
663            double PlcMedVal=ValVV[ValN][PlcMedVarN];
664            double KwPrecisMeanVal=ValVV[ValN][KwPrecisMeanVarN];
665            double KwRecallMeanVal=ValVV[ValN][KwRecallMeanVarN];
666            double KwF2Val=ValVV[ValN][KwF2VarN];
667            if ((TFlt::Eq6(FSels, FSelsVal))&&
668             (TFlt::Eq6(SumEstPrb, SumEstPrbVal))&&
669             (TFlt::Eq6(MnDocFq, MnDocFqVal))){
670              OLx.PutFlt(FSelsVal);
671              OLx.PutFlt(SumEstPrbVal);
672              OLx.PutFlt(MnDocFqVal);
673              OLx.PutFlt(VisitsMeanVal);
674              OLx.PutFlt(VisitsSErrVal);
675              OLx.PutFlt(PlcMedVal);
676              OLx.PutFlt(KwPrecisMeanVal);
677              OLx.PutFlt(KwRecallMeanVal);
678              OLx.PutFlt(KwF2Val);
679              OLx.PutLn();
680            }
681          }
682        }
683      }
684    }
685    {for (int SumEstPrbN=0; SumEstPrbN<SumEstPrbV.Len(); SumEstPrbN++){
686      TStr OutFNm="../resultskdd/tt/EntSFM9_"+TInt::GetStr(SumEstPrbN)+".st";
687      TNotify::OnNotify(Notify, ntInfo, TStr("... writing ")+OutFNm);
688      PSOut SOut=PSOut(new TFOut(OutFNm));
689      TOLx OLx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
690      OLx.PutUQStr("FSels");
691      OLx.PutUQStr("SumEstPrb");
692      OLx.PutUQStr("MnDocFq");
693      OLx.PutUQStr("VisitsMean");
694      OLx.PutUQStr("VisitsSErr");
695      OLx.PutUQStr("PlcMed");
696      OLx.PutUQStr("KwF2");
697      OLx.PutUQStr("KwPrecisMean");
698      OLx.PutUQStr("KwRecallMean");
699      OLx.PutLn();
700      double SumEstPrb=SumEstPrbV[SumEstPrbN];
701      for (int MnDocFqN=0; MnDocFqN<MnDocFqV.Len(); MnDocFqN++){
702        double MnDocFq=MnDocFqV[MnDocFqN];
703        if (!TFlt::Eq6(MnDocFq, 9.0)){continue;}
704        for (int FSelsN=0; FSelsN<FSelsV.Len(); FSelsN++){
705          double FSels=FSelsV[FSelsN];
706          for (int ValN=0; ValN<ValVV.Len(); ValN++){
707            int DmNmHashCd=int(ValVV[ValN][DmNmVarN]);
708            if (DmNmHashCd!=TStr("Ent").GetPrimHashCd()){continue;}
709            double FSelsVal=ValVV[ValN][FSelsVarN];
710            double SumEstPrbVal=ValVV[ValN][SumEstPrbVarN];
711            double MnDocFqVal=ValVV[ValN][MnDocFqVarN];
712            double VisitsMeanVal=ValVV[ValN][VisitsMeanVarN];
713            double VisitsSErrVal=ValVV[ValN][VisitsSErrVarN];
714            double PlcMedVal=ValVV[ValN][PlcMedVarN];
715            double KwPrecisMeanVal=ValVV[ValN][KwPrecisMeanVarN];
716            double KwRecallMeanVal=ValVV[ValN][KwRecallMeanVarN];
717            double KwF2Val=ValVV[ValN][KwF2VarN];
718            if ((TFlt::Eq6(FSels, FSelsVal))&&
719             (TFlt::Eq6(SumEstPrb, SumEstPrbVal))&&
720             (TFlt::Eq6(MnDocFq, MnDocFqVal))){
721              OLx.PutFlt(FSelsVal);
722              OLx.PutFlt(SumEstPrbVal);
723              OLx.PutFlt(MnDocFqVal);
724              OLx.PutFlt(VisitsMeanVal);
725              OLx.PutFlt(VisitsSErrVal);
726              OLx.PutFlt(PlcMedVal);
727              OLx.PutFlt(KwPrecisMeanVal);
728              OLx.PutFlt(KwRecallMeanVal);
729              OLx.PutFlt(KwF2Val);
730              OLx.PutLn();
731            }
732          }
733        }
734      }
735    }}
736    TNotify::OnNotify(Notify, ntInfo, "Finished.");
737  }
738  PMd TYExpr::GenMd(
739   const TStr& YDmNm, const TStr& YRootFPath, const bool& DoSave,
740   const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
741   const TYDsBsNrType& YDsBsNrType, const double& YDsBsWordFqExp,
742   const double& YDsBsMnDocWordPrb, const double& YDsBsSumAllWordPrb,
743   const TYFSelType& YFSelType, const double& YFSels,
744   const bool& YFSelPosWords, const PAttrEst& YFSelAttrEst,
745   const TYNegDsType& YNegDsType, const TYPriorType& YPriorType,
746   const double& YInvIxEstExp, const double& YInvIxSumEstPrb,
747   const PNotify& Notify){
748    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
749    PXWebBs WebBs=PXWebBs(new TWebMemBs(NrYRootFPath+YWebBsFPfx+YDmNm));
750    PYBs YBs=PYBs(new TYBs(
751     WebBs, MxNGram, MnWordFq, SwSetTy, TStrV(), Notify));
752    PYDsBs YDsBs=PYDsBs(new TYDsBs(
753     YDsBsNrType, YDsBsWordFqExp, YDsBsMnDocWordPrb, YDsBsSumAllWordPrb,
754     YBs, Notify));
755    PYFSelBs YFSelBs=PYFSelBs(new TYFSelBs(
756     YFSelType, YFSels, YFSelPosWords, YFSelAttrEst,
757     YNegDsType, YPriorType, YBs, YDsBs, Notify));
758    PYInvIx YInvIx=PYInvIx(new TYInvIx(
759     YInvIxEstExp, YInvIxSumEstPrb,
760     YBs, YDsBs, YFSelBs, Notify));
761    PMd Md=PMd(new TMdYBayes(
762     YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx));
763    if (DoSave){
764      YBs->Save(NrYRootFPath+YBsFPfx+YDmNm+DatFExt);
765      YBs->SaveTxt(NrYRootFPath+YBsFPfx+YDmNm+TxtFExt);
766      YBs->SaveTxtWords(NrYRootFPath+YWordFPfx+YDmNm+TxtFExt);
767      YBs->SaveTxtCtgs(NrYRootFPath+YCtgFPfx+YDmNm+TxtFExt);
768      TStr YDsBsFNm=NrYRootFPath+YDsBsFPfx+YDmNm+TxtFExt;
769      TStr YFSelBsFNm=NrYRootFPath+YFSelFPfx+YDmNm+TxtFExt;
770      TStr YInvIxFNm=NrYRootFPath+YInvIxFPfx+YDmNm+TxtFExt;
771      YDsBs->SaveTxt(PSOut(new TFOut(YDsBsFNm)), YBs);
772      YFSelBs->SaveTxt(PSOut(new TFOut(YFSelBsFNm)), YBs, YDsBs);
773      YInvIx->SaveTxt(PSOut(new TFOut(YInvIxFNm)), YBs);
774      TStr MdFNm=NrYRootFPath+YMdFPfx+YDmNm+DatFExt;
775      TStr CheckMdFNm=NrYRootFPath+YMdFPfx+YDmNm+TmpFExt;
776      TNotify::OnNotify(Notify, ntInfo, TStr("Saving to ")+MdFNm);
777      {TFOut FOut(MdFNm); Md->Save(FOut);}
778    }
779    TNotify::OnNotify(Notify, ntInfo, "Finished.");
780    return Md;
781  }
782  void TYExpr::UseMd(
783   const TStr& YDmNm, const TStr& YRootFPath,
784   const PSIn& SIn, const PSOut& SOut,
785   const double& MnDocPrbTsh, const int& MxTopHits,
786   const double& MnTsWordPrb, const int& MnDocFq,
787   const PNotify&){
788    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
789    TStr YMdFNm=
790     TStr::GetNrFPath(YRootFPath)+TYExpr::YMdFPfx+YDmNm+TYExpr::DatFExt;
791    TFIn YMdFIn(YMdFNm);
792    PMd Md=TMdYBayes::Load(YMdFIn);
793    TMdYBayes& YMd=*(TMdYBayes*)Md();
794    PYBs YBs=YMd.GetYBs();
795    PYInvIx YInvIx=YMd.GetYInvIx();
796    PYWordDs TsWordDs=YBs->GetWordDs(SIn);
797    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
798    Lx.PutUQStr("Input Text Distribution"); Lx.PutLn();
799    TsWordDs->SaveTxt(SOut, &(*YBs));
800    PValRet ValRet=
801     PValRet(new TYValRet(MnTsWordPrb, YMd.GetDmHd(), YBs, TsWordDs));
802    TIntV ClassNV; YInvIx->GetDocIdV(TsWordDs, MnDocFq, ClassNV);
803    TDocCfV DocCfV(ClassNV.Len(), 0);
804    for (int ClassNN=0; ClassNN<ClassNV.Len(); ClassNN++){
805      int ClassN=ClassNV[ClassNN];
806      TStr UrlStr=Md->GetDmHd()->GetClassNm(ClassN);
807      TFltIntKdV WordPrbIdV;
808      PTbValDs ValDs=YMd.GetPostrValDs(ValRet, ClassN, WordPrbIdV);
809      double ClassPrb=ValDs->GetPrb_RelFq(TTbVal(true));
810      DocCfV.Add(TDocCf(UrlStr, ClassPrb, WordPrbIdV));
811    }
812    DocCfV.Sort(false);
813    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
814    Lx.PutLn(); Lx.PutUQStr("Best Categories"); Lx.PutLn();
815    {int DocCfN=0; int TbDocCfN=0;
816    while ((DocCfN<DocCfV.Len())&&(DocCfV[DocCfN].DocPrb>MnDocPrbTsh)&&
817     (DocCfN<MxTopHits)){
818      double DocPrb=DocCfV[DocCfN].DocPrb;
819      TStr UrlStr=DocCfV[DocCfN].UrlStr;
820      TStr RankStr=TInt::GetStr(TbDocCfN+1)+'.';
821      TStr DocPrbStr=TFlt::GetStr(DocPrb, 4, 2);
822      TStr DocPathStr=TUrl(UrlStr).GetPathStr();
823      TStrV WordStrV;
824      TFltIntKdV& WordPrbIdV=DocCfV[DocCfN].WordPrbIdV;
825      for (int WordPrbIdN=0; WordPrbIdN<WordPrbIdV.Len(); WordPrbIdN++){
826        double WordPrb=WordPrbIdV[WordPrbIdN].Key;
827        int WordId=WordPrbIdV[WordPrbIdN].Dat;
828        TStr WordStr=YBs->GetWordStr(WordId);
829        TStr WordStrPrbStr=WordStr+" ["+TFlt::GetStr(WordPrb, 0, 4)+"]";
830        WordStrV.Add(WordStrPrbStr);
831      }
832      int Slashes=0;
833      for (int ChN=0; ChN<DocPathStr.Len(); ChN++){
834        if (DocPathStr[ChN]=='/'){Slashes++;}
835      }
836      if (Slashes>2){
837        Lx.PutVarStr("Category", RankStr+" "+DocPrbStr+" "+DocPathStr);
838        Lx.PutVarStrV("Words", WordStrV);
839        TbDocCfN++;
840      }
841      DocCfN++;
842    }}
843    {TIntV CtgIdV;
844    TIntFltH CtgIdToWFqH(1000);
845    int DocCfN=0;
846    while ((DocCfN<DocCfV.Len())&&(DocCfV[DocCfN].DocPrb>MnDocPrbTsh)){
847      double DocPrb=DocCfV[DocCfN].DocPrb;
848      TStr UrlStr=DocCfV[DocCfN].UrlStr;
849      int DocId=YBs->GetDocId(UrlStr);
850      TIntV DocCtgIdV; YBs->GetCtgIdV(DocId, DocCtgIdV);
851      CtgIdV.AddVMerged(DocCtgIdV);
852      for (int DocCtgIdN=0; DocCtgIdN<DocCtgIdV.Len(); DocCtgIdN++){
853        int CtgId=DocCtgIdV[DocCtgIdN];
854        double WFq=DocPrb/log(1+YBs->GetCtgFq(CtgId));
855        CtgIdToWFqH.AddDat(CtgId)+=WFq;
856      }
857      DocCfN++;
858    }
859    TStr CtgIdVStr=YBs->GetCtgIdVStr(CtgIdV);
860    TStrV CtgStrV; YBs->GetCtgStrV(CtgIdV, CtgStrV);
861    TStr CtgIdToWFqHStr=YBs->GetCtgIdToWFqHStr(CtgIdToWFqH, 0.9);
862    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
863    Lx.PutLn();Lx.PutUQStr("Best Keywords"); Lx.PutLn();
864    Lx.PutVarStr("CtgIdV", CtgIdVStr);
865    Lx.PutVarStrV("CtgStrV", CtgStrV);}
866  }
867  void TYExpr::Extr(const TStr& FNm, const PSOut& SOut){
868    TStrV VarNmV;
869    VarNmV.Add("DmNm"); VarNmV.Add("KNNbrs"); VarNmV.Add("RndSel");
870    VarNmV.Add("HldPrecisMean"); VarNmV.Add("HldRecallMean");
871    VarNmV.Add("HldF2Mean");
872    VarNmV.Add("HlLenMed"); VarNmV.Add("DocLenMed");
873    PSs Ss=TSs::LoadTxt(FNm);
874    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
875    int VarNmN=0;
876    for (int Y=0; Y<Ss->GetYLen(); Y++){
877      for (int X=0; X<Ss->GetXLen(Y); X++){
878        if (Ss->GetVal(X, Y)==VarNmV[VarNmN]){
879          TStr VarNm=VarNmV[VarNmN];
880          TStr ValStr;
881          if (Ss->GetVal(X, Y+1).IsFlt()){
882            PMom Mom=PMom(new TMom()); int RelY=1;
883            while (Ss->GetVal(X, Y+RelY).IsFlt()){
884              double Flt=Ss->GetVal(X, Y+RelY).GetFlt();
885              Mom->Add(Flt);
886              RelY++;
887            }
888            Mom->Def();
889            if (Mom->GetWgt()!=5){
890              double Wgt=Mom->GetWgt();
891              printf("%g", Wgt);
892            }
893            ValStr=TFlt::GetStr(Mom->GetMean())+"/"+TFlt::GetStr(Mom->GetSErr());
894          } else {
895            ValStr=Ss->GetVal(X, Y+1);
896          }
897          Lx.PutUQStr(VarNm);
898          Lx.PutUQStr(ValStr);
899          VarNmN=(VarNmN+1)%VarNmV.Len();
900          if (VarNmN==0){Lx.PutLn();}
901        }
902      }
903    }
904  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahooex.cpp</div>
                </div>
                <div class="column column_space"><pre><code>380                            if (bottom_data2[index] > top_data2[pool_index]) {
381                              top_data2[pool_index] = bottom_data2[index];
382                              if (use_top_mask) {
383                                top_mask[pool_index] = static_cast<Dtype>(index);
384                              } else {
385                                mask[pool_index] = index;
386                              }
</pre></code></div>
                <div class="column column_space"><pre><code>161        for (int AttrEstN=0; AttrEstN<YFSelAttrEstV.Len(); AttrEstN++){
162          PAttrEst YFSelAttrEst=YFSelAttrEstV[AttrEstN];
163          TStr YFSelAttrEstNm;
164          if (YFSelAttrEst.Empty()){YFSelAttrEstNm="OddsRatio";} \
165          else {YFSelAttrEstNm=YFSelAttrEst->GetNm();}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    