
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.704626334519573%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stopper.cpp</h3>
            <pre><code>1  #include <cctype>
2  #include <cmath>
3  #include <cstdio>
4  #include <cstring>
5  #include "stopper.h"
6  #ifndef DISABLED_LEGACY_ENGINE
7  #  include "ambigs.h"
8  #endif
9  #include <tesseract/unichar.h>
10  #include "ccutil.h"
11  #include "dict.h"
12  #include "helpers.h"
13  #include "matchdefs.h"
14  #include "pageres.h"
15  #include "params.h"
16  #include "ratngs.h"
17  namespace tesseract {
18  bool Dict::AcceptableChoice(const WERD_CHOICE &best_choice,
19                              XHeightConsistencyEnum xheight_consistency) {
20    float CertaintyThreshold = stopper_nondict_certainty_base;
21    int WordSize;
22    if (stopper_no_acceptable_choices) {
23      return false;
24    }
25    if (best_choice.empty()) {
26      return false;
27    }
28    bool no_dang_ambigs = !best_choice.dangerous_ambig_found();
29    bool is_valid_word = valid_word_permuter(best_choice.permuter(), false);
30    bool is_case_ok = case_ok(best_choice);
31    if (stopper_debug_level >= 1) {
32      const char *xht = "UNKNOWN";
33      switch (xheight_consistency) {
34        case XH_GOOD:
35          xht = "NORMAL";
36          break;
37        case XH_SUBNORMAL:
38          xht = "SUBNORMAL";
39          break;
40        case XH_INCONSISTENT:
41          xht = "INCONSISTENT";
42          break;
43        default:
44          xht = "UNKNOWN";
45      }
46      tprintf("\nStopper:  %s (word=%c, case=%c, xht_ok=%s=[%g,%g])\n",
47              best_choice.unichar_string().c_str(), (is_valid_word ? 'y' : 'n'),
48              (is_case_ok ? 'y' : 'n'), xht, best_choice.min_x_height(), best_choice.max_x_height());
49    }
50    if (reject_offset_ <= 0.0f && !is_valid_word) {
51      return false;
52    }
53    if (is_valid_word && is_case_ok) {
54      WordSize = LengthOfShortestAlphaRun(best_choice);
55      WordSize -= stopper_smallword_size;
56      if (WordSize < 0) {
57        WordSize = 0;
58      }
59      CertaintyThreshold += WordSize * stopper_certainty_per_char;
60    }
61    if (stopper_debug_level >= 1) {
62      tprintf("Stopper:  Rating = %4.1f, Certainty = %4.1f, Threshold = %4.1f\n",
63              best_choice.rating(), best_choice.certainty(), CertaintyThreshold);
64    }
65    if (no_dang_ambigs && best_choice.certainty() > CertaintyThreshold &&
66        xheight_consistency < XH_INCONSISTENT && UniformCertainties(best_choice)) {
67      return true;
68    } else {
69      if (stopper_debug_level >= 1) {
70        tprintf(
71            "AcceptableChoice() returned false"
72            " (no_dang_ambig:%d cert:%.4g thresh:%g uniform:%d)\n",
73            no_dang_ambigs, best_choice.certainty(), CertaintyThreshold,
74            UniformCertainties(best_choice));
75      }
76      return false;
77    }
78  }
79  bool Dict::AcceptableResult(WERD_RES *word) const {
80    if (word->best_choice == nullptr) {
81      return false;
82    }
83    float CertaintyThreshold = stopper_nondict_certainty_base - reject_offset_;
84    int WordSize;
85    if (stopper_debug_level >= 1) {
86      tprintf("\nRejecter: %s (word=%c, case=%c, unambig=%c, multiple=%c)\n",
87              word->best_choice->debug_string().c_str(), (valid_word(*word->best_choice) ? 'y' : 'n'),
88              (case_ok(*word->best_choice) ? 'y' : 'n'),
89              word->best_choice->dangerous_ambig_found() ? 'n' : 'y',
90              word->best_choices.singleton() ? 'n' : 'y');
91    }
92    if (word->best_choice->empty() || !word->best_choices.singleton()) {
93      return false;
94    }
95    if (valid_word(*word->best_choice) && case_ok(*word->best_choice)) {
96      WordSize = LengthOfShortestAlphaRun(*word->best_choice);
97      WordSize -= stopper_smallword_size;
98      if (WordSize < 0) {
99        WordSize = 0;
100      }
101      CertaintyThreshold += WordSize * stopper_certainty_per_char;
102    }
103    if (stopper_debug_level >= 1) {
104      tprintf("Rejecter: Certainty = %4.1f, Threshold = %4.1f   ", word->best_choice->certainty(),
105              CertaintyThreshold);
106    }
107    if (word->best_choice->certainty() > CertaintyThreshold && !stopper_no_acceptable_choices) {
108      if (stopper_debug_level >= 1) {
109        tprintf("ACCEPTED\n");
110      }
111      return true;
112    } else {
113      if (stopper_debug_level >= 1) {
114        tprintf("REJECTED\n");
115      }
116      return false;
117    }
118  }
119  #if !defined(DISABLED_LEGACY_ENGINE)
120  bool Dict::NoDangerousAmbig(WERD_CHOICE *best_choice, DANGERR *fixpt, bool fix_replaceable,
121                              MATRIX *ratings) {
122    if (stopper_debug_level > 2) {
123      tprintf("\nRunning NoDangerousAmbig() for %s\n", best_choice->debug_string().c_str());
124    }
125    BLOB_CHOICE_LIST_VECTOR ambig_blob_choices;
126    bool ambigs_found = false;
127    for (int pass = 0; pass < (fix_replaceable ? 2 : 1); ++pass) {
128      bool replace = (fix_replaceable && pass == 0);
129      const UnicharAmbigsVector &table =
130          replace ? getUnicharAmbigs().replace_ambigs() : getUnicharAmbigs().dang_ambigs();
131      if (!replace) {
132        for (unsigned i = 0; i < best_choice->length(); ++i) {
133          auto *lst = new BLOB_CHOICE_LIST();
134          BLOB_CHOICE_IT lst_it(lst);
135          lst_it.add_to_end(
136              new BLOB_CHOICE(best_choice->unichar_id(i), 0.0, 0.0, -1, 0, 1, 0, BCC_AMBIG));
137          ambig_blob_choices.push_back(lst);
138        }
139      }
140      UNICHAR_ID wrong_ngram[MAX_AMBIG_SIZE + 1];
141      int wrong_ngram_index;
142      int blob_index = 0;
143      for (unsigned i = 0; i < best_choice->length(); blob_index += best_choice->state(i), ++i) {
144        auto curr_unichar_id = best_choice->unichar_id(i);
145        if (stopper_debug_level > 2) {
146          tprintf("Looking for %s ngrams starting with %s:\n", replace ? "replaceable" : "ambiguous",
147                  getUnicharset().debug_str(curr_unichar_id).c_str());
148        }
149        int num_wrong_blobs = best_choice->state(i);
150        wrong_ngram_index = 0;
151        wrong_ngram[wrong_ngram_index] = curr_unichar_id;
152        if (curr_unichar_id == INVALID_UNICHAR_ID || static_cast<size_t>(curr_unichar_id) >= table.size() ||
153            table[curr_unichar_id] == nullptr) {
154          continue; 
155        }
156        AmbigSpec_IT spec_it(table[curr_unichar_id]);
157        for (spec_it.mark_cycle_pt(); !spec_it.cycled_list();) {
158          const AmbigSpec *ambig_spec = spec_it.data();
159          wrong_ngram[wrong_ngram_index + 1] = INVALID_UNICHAR_ID;
160          int compare = UnicharIdArrayUtils::compare(wrong_ngram, ambig_spec->wrong_ngram);
161          if (stopper_debug_level > 2) {
162            tprintf("candidate ngram: ");
163            UnicharIdArrayUtils::print(wrong_ngram, getUnicharset());
164            tprintf("current ngram from spec: ");
165            UnicharIdArrayUtils::print(ambig_spec->wrong_ngram, getUnicharset());
166            tprintf("comparison result: %d\n", compare);
167          }
168          if (compare == 0) {
169            if (fixpt != nullptr) {
170              UNICHAR_ID leftmost_id = ambig_spec->correct_fragments[0];
171              fixpt->push_back(DANGERR_INFO(blob_index, blob_index + num_wrong_blobs, replace,
172                                            getUnicharset().get_isngram(ambig_spec->correct_ngram_id),
173                                            leftmost_id));
174              if (stopper_debug_level > 1) {
175                tprintf("fixpt+=(%d %d %d %d %s)\n", blob_index, blob_index + num_wrong_blobs, false,
176                        getUnicharset().get_isngram(ambig_spec->correct_ngram_id),
177                        getUnicharset().id_to_unichar(leftmost_id));
178              }
179            }
180            if (replace) {
181              if (stopper_debug_level > 2) {
182                tprintf("replace ambiguity with %s : ",
183                        getUnicharset().id_to_unichar(ambig_spec->correct_ngram_id));
184                UnicharIdArrayUtils::print(ambig_spec->correct_fragments, getUnicharset());
185              }
186              ReplaceAmbig(i, ambig_spec->wrong_ngram_size, ambig_spec->correct_ngram_id, best_choice,
187                           ratings);
188            } else if (i > 0 || ambig_spec->type != CASE_AMBIG) {
189              if (stopper_debug_level > 2) {
190                tprintf("found ambiguity: ");
191                UnicharIdArrayUtils::print(ambig_spec->correct_fragments, getUnicharset());
192              }
193              ambigs_found = true;
194              for (int tmp_index = 0; tmp_index <= wrong_ngram_index; ++tmp_index) {
195                BLOB_CHOICE_IT bc_it(ambig_blob_choices[i + tmp_index]);
196                bc_it.add_to_end(new BLOB_CHOICE(ambig_spec->correct_fragments[tmp_index], -1.0, 0.0,
197                                                 -1, 0, 1, 0, BCC_AMBIG));
198              }
199            }
200            spec_it.forward();
201          } else if (compare == -1) {
202            unsigned next_index;
203            if (wrong_ngram_index + 1 < ambig_spec->wrong_ngram_size &&
204                ((next_index = wrong_ngram_index + 1 + i) < best_choice->length())) {
205              wrong_ngram[++wrong_ngram_index] = best_choice->unichar_id(next_index);
206              num_wrong_blobs += best_choice->state(next_index);
207            } else {
208              break; 
209            }
210          } else {
211            spec_it.forward();
212          }
213        } 
214      }   
215    }     
216    if (ambigs_found) {
217      if (stopper_debug_level > 2) {
218        tprintf("\nResulting ambig_blob_choices:\n");
219        for (unsigned i = 0; i < ambig_blob_choices.size(); ++i) {
220          print_ratings_list("", ambig_blob_choices.at(i), getUnicharset());
221          tprintf("\n");
222        }
223      }
224      WERD_CHOICE *alt_word = dawg_permute_and_select(ambig_blob_choices, 0.0);
225      ambigs_found = (alt_word->rating() < 0.0);
226      if (ambigs_found) {
227        if (stopper_debug_level >= 1) {
228          tprintf("Stopper: Possible ambiguous word = %s\n", alt_word->debug_string().c_str());
229        }
230        if (fixpt != nullptr) {
231          int orig_i = 0;
232          for (unsigned i = 0; i < alt_word->length(); ++i) {
233            const UNICHARSET &uchset = getUnicharset();
234            bool replacement_is_ngram = uchset.get_isngram(alt_word->unichar_id(i));
235            UNICHAR_ID leftmost_id = alt_word->unichar_id(i);
236            if (replacement_is_ngram) {
237              const char *str = uchset.id_to_unichar(leftmost_id);
238              int step = uchset.step(str);
239              if (step) {
240                leftmost_id = uchset.unichar_to_id(str, step);
241              }
242            }
243            int end_i = orig_i + alt_word->state(i);
244            if (alt_word->state(i) > 1 || (orig_i + 1 == end_i && replacement_is_ngram)) {
245              int blob_start = 0;
246              for (int j = 0; j < orig_i; ++j) {
247                blob_start += best_choice->state(j);
248              }
249              int blob_end = blob_start;
250              for (int j = orig_i; j < end_i; ++j) {
251                blob_end += best_choice->state(j);
252              }
253              fixpt->push_back(
254                  DANGERR_INFO(blob_start, blob_end, true, replacement_is_ngram, leftmost_id));
255              if (stopper_debug_level > 1) {
256                tprintf("fixpt->dangerous+=(%d %d %d %d %s)\n", orig_i, end_i, true,
257                        replacement_is_ngram, uchset.id_to_unichar(leftmost_id));
258              }
259            }
260            orig_i += alt_word->state(i);
261          }
262        }
263      }
264      delete alt_word;
265    }
266    if (output_ambig_words_file_ != nullptr) {
267      fprintf(output_ambig_words_file_, "\n");
268    }
269    for (auto data : ambig_blob_choices) {
270      delete data;
271    }
272    return !ambigs_found;
273  }
274  void Dict::EndDangerousAmbigs() {}
275  #endif 
276  void Dict::SettupStopperPass1() {
277    reject_offset_ = 0.0;
278  }
279  void Dict::SettupStopperPass2() {
280    reject_offset_ = stopper_phase2_certainty_rejection_offset;
281  }
282  void Dict::ReplaceAmbig(int wrong_ngram_begin_index, int wrong_ngram_size,
283                          UNICHAR_ID correct_ngram_id, WERD_CHOICE *werd_choice, MATRIX *ratings) {
284    int num_blobs_to_replace = 0;
285    int begin_blob_index = 0;
286    int i;
287    float new_rating = 0.0f;
288    float new_certainty = 0.0f;
289    BLOB_CHOICE *old_choice = nullptr;
290    for (i = 0; i < wrong_ngram_begin_index + wrong_ngram_size; ++i) {
291      if (i >= wrong_ngram_begin_index) {
292        int num_blobs = werd_choice->state(i);
293        int col = begin_blob_index + num_blobs_to_replace;
294        int row = col + num_blobs - 1;
295        BLOB_CHOICE_LIST *choices = ratings->get(col, row);
296        ASSERT_HOST(choices != nullptr);
297        old_choice = FindMatchingChoice(werd_choice->unichar_id(i), choices);
298        ASSERT_HOST(old_choice != nullptr);
299        new_rating += old_choice->rating();
300        new_certainty += old_choice->certainty();
301        num_blobs_to_replace += num_blobs;
302      } else {
303        begin_blob_index += werd_choice->state(i);
304      }
305    }
306    new_certainty /= wrong_ngram_size;
307    MATRIX_COORD coord(begin_blob_index, begin_blob_index + num_blobs_to_replace - 1);
308    if (!coord.Valid(*ratings)) {
309      ratings->IncreaseBandSize(coord.row - coord.col + 1);
310    }
311    if (ratings->get(coord.col, coord.row) == nullptr) {
312      ratings->put(coord.col, coord.row, new BLOB_CHOICE_LIST);
313    }
314    BLOB_CHOICE_LIST *new_choices = ratings->get(coord.col, coord.row);
315    BLOB_CHOICE *choice = FindMatchingChoice(correct_ngram_id, new_choices);
316    if (choice != nullptr) {
317      if (new_rating < choice->rating()) {
318        choice->set_rating(new_rating);
319      }
320      if (new_certainty < choice->certainty()) {
321        choice->set_certainty(new_certainty);
322      }
323    } else {
324      choice = new BLOB_CHOICE(*old_choice);
325      choice->set_unichar_id(correct_ngram_id);
326      choice->set_rating(new_rating);
327      choice->set_certainty(new_certainty);
328      choice->set_classifier(BCC_AMBIG);
329      choice->set_matrix_cell(coord.col, coord.row);
330      BLOB_CHOICE_IT it(new_choices);
331      it.add_to_end(choice);
332    }
333    for (int replaced_count = 0; replaced_count < wrong_ngram_size; ++replaced_count) {
334      if (replaced_count + 1 == wrong_ngram_size) {
335        werd_choice->set_blob_choice(wrong_ngram_begin_index, num_blobs_to_replace, choice);
336      } else {
337        werd_choice->remove_unichar_id(wrong_ngram_begin_index + 1);
338      }
339    }
340    if (stopper_debug_level >= 1) {
341      werd_choice->print("ReplaceAmbig() ");
342      tprintf("Modified blob_choices: ");
343      print_ratings_list("\n", new_choices, getUnicharset());
344    }
345  }
346  int Dict::LengthOfShortestAlphaRun(const WERD_CHOICE &WordChoice) const {
347    int shortest = INT32_MAX;
348    int curr_len = 0;
349    for (unsigned w = 0; w < WordChoice.length(); ++w) {
350      if (WordChoice.unicharset()->get_isalpha(WordChoice.unichar_id(w))) {
351        curr_len++;
352      } else if (curr_len > 0) {
353        if (curr_len < shortest) {
354          shortest = curr_len;
355        }
356        curr_len = 0;
357      }
358    }
359    if (curr_len > 0 && curr_len < shortest) {
360      shortest = curr_len;
361    } else if (shortest == INT32_MAX) {
362      shortest = 0;
363    }
364    return shortest;
365  }
366  int Dict::UniformCertainties(const WERD_CHOICE &word) {
367    float Certainty;
368    float WorstCertainty = FLT_MAX;
369    float CertaintyThreshold;
370    double TotalCertainty;
371    double TotalCertaintySquared;
372    double Variance;
373    float Mean, StdDev;
374    int word_length = word.length();
375    if (word_length < 3) {
376      return true;
377    }
<span onclick='openModal()' class='match'>378    TotalCertainty = TotalCertaintySquared = 0.0;
379    for (int i = 0; i < word_length; ++i) {
380      Certainty = word.certainty(i);
381      TotalCertainty += Certainty;
382      TotalCertaintySquared += static_cast<double>(Certainty) * Certainty;
</span>383      if (Certainty < WorstCertainty) {
384        WorstCertainty = Certainty;
385      }
386    }
387    word_length--;
388    TotalCertainty -= WorstCertainty;
389    TotalCertaintySquared -= static_cast<double>(WorstCertainty) * WorstCertainty;
390    Mean = TotalCertainty / word_length;
391    Variance = ((word_length * TotalCertaintySquared - TotalCertainty * TotalCertainty) /
392                (word_length * (word_length - 1)));
393    if (Variance < 0.0) {
394      Variance = 0.0;
395    }
396    StdDev = sqrt(Variance);
397    CertaintyThreshold = Mean - stopper_allowable_character_badness * StdDev;
398    if (CertaintyThreshold > stopper_nondict_certainty_base) {
399      CertaintyThreshold = stopper_nondict_certainty_base;
400    }
401    if (word.certainty() < CertaintyThreshold) {
402      if (stopper_debug_level >= 1) {
403        tprintf(
404            "Stopper: Non-uniform certainty = %4.1f"
405            " (m=%4.1f, s=%4.1f, t=%4.1f)\n",
406            word.certainty(), Mean, StdDev, CertaintyThreshold);
407      }
408      return false;
409    } else {
410      return true;
411    }
412  }
413  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "coutln.h"
5  #include "arrayaccess.h" 
6  #include "blobs.h"       
7  #include "crakedge.h"    
8  #include "environ.h"     
9  #include "errcode.h"     
10  #include "normalis.h"    
11  #include "helpers.h" 
12  #include <allheaders.h> 
13  #include "pix.h"        
14  #include <algorithm> 
15  #include <cmath>     
16  #include <cstdlib>   
17  #include <cstring>   
18  namespace tesseract {
19  ICOORD C_OUTLINE::step_coords[4] = {ICOORD(-1, 0), ICOORD(0, -1), ICOORD(1, 0), ICOORD(0, 1)};
20  C_OUTLINE::C_OUTLINE(CRACKEDGE *startpt, ICOORD bot_left, ICOORD top_right, int16_t length)
21      : box(bot_left, top_right), start(startpt->pos), offsets(nullptr) {
22    int16_t stepindex; 
23    CRACKEDGE *edgept; 
24    stepcount = length; 
25    if (length == 0) {
26      return;
27    }
28    steps.resize(step_mem());
29    edgept = startpt;
30    for (stepindex = 0; stepindex < length; stepindex++) {
31      set_step(stepindex, edgept->stepdir);
32      edgept = edgept->next;
33    }
34  }
35  C_OUTLINE::C_OUTLINE(
36      ICOORD startpt, DIR128 *new_steps,
37      int16_t length 
38      )
39      : start(startpt), offsets(nullptr) {
40    int8_t dirdiff;    
41    DIR128 prevdir;    
42    DIR128 dir;        
43    DIR128 lastdir;    
44    TBOX new_box;      
45    int16_t stepindex; 
46    int16_t srcindex;  
47    ICOORD pos;        
48    pos = startpt;
49    stepcount = length; 
50    ASSERT_HOST(length >= 0);
51    steps.resize(step_mem()); 
52    lastdir = new_steps[length - 1];
53    prevdir = lastdir;
54    for (stepindex = 0, srcindex = 0; srcindex < length; stepindex++, srcindex++) {
55      new_box = TBOX(pos, pos);
56      box += new_box;
57      dir = new_steps[srcindex];
58      set_step(stepindex, dir);
59      dirdiff = dir - prevdir;
60      pos += step(stepindex);
61      if ((dirdiff == 64 || dirdiff == -64) && stepindex > 0) {
62        stepindex -= 2; 
63        prevdir = stepindex >= 0 ? step_dir(stepindex) : lastdir;
64      } else {
65        prevdir = dir;
66      }
67    }
68    ASSERT_HOST(pos.x() == startpt.x() && pos.y() == startpt.y());
69    do {
70      dirdiff = step_dir(stepindex - 1) - step_dir(0);
71      if (dirdiff == 64 || dirdiff == -64) {
72        start += step(0);
73        stepindex -= 2; 
74        for (int i = 0; i < stepindex; ++i) {
75          set_step(i, step_dir(i + 1));
76        }
77      }
78    } while (stepindex > 1 && (dirdiff == 64 || dirdiff == -64));
79    stepcount = stepindex;
80    ASSERT_HOST(stepcount >= 4);
81  }
82  C_OUTLINE::C_OUTLINE(C_OUTLINE *srcline, FCOORD rotation) : offsets(nullptr) {
83    TBOX new_box;      
84    int16_t stepindex; 
85    int16_t dirdiff;   
86    ICOORD pos;        
87    ICOORD prevpos;    
88    ICOORD destpos;                
89    int16_t destindex = INT16_MAX; 
90    DIR128 dir;                    
91    uint8_t new_step;
92    stepcount = srcline->stepcount * 2;
93    if (stepcount == 0) {
94      box = srcline->box;
95      box.rotate(rotation);
96      return;
97    }
98    steps.resize(step_mem());
99    for (int iteration = 0; iteration < 2; ++iteration) {
100      DIR128 round1 = iteration == 0 ? 32 : 0;
101      DIR128 round2 = iteration != 0 ? 32 : 0;
102      pos = srcline->start;
103      prevpos = pos;
104      prevpos.rotate(rotation);
105      start = prevpos;
106      box = TBOX(start, start);
107      destindex = 0;
108      for (stepindex = 0; stepindex < srcline->stepcount; stepindex++) {
109        pos += srcline->step(stepindex);
110        destpos = pos;
111        destpos.rotate(rotation);
112        while (destpos.x() != prevpos.x() || destpos.y() != prevpos.y()) {
113          dir = DIR128(FCOORD(destpos - prevpos));
114          dir += 64; 
115          new_step = dir.get_dir();
116          if (new_step & 31) {
117            set_step(destindex++, dir + round1);
118            prevpos += step(destindex - 1);
119            if (destindex < 2 ||
120                ((dirdiff = step_dir(destindex - 1) - step_dir(destindex - 2)) != -64 &&
121                 dirdiff != 64)) {
122              set_step(destindex++, dir + round2);
123              prevpos += step(destindex - 1);
124            } else {
125              prevpos -= step(destindex - 1);
126              destindex--;
127              prevpos -= step(destindex - 1);
128              set_step(destindex - 1, dir + round2);
129              prevpos += step(destindex - 1);
130            }
131          } else {
132            set_step(destindex++, dir);
133            prevpos += step(destindex - 1);
134          }
135          while (destindex >= 2 &&
136                 ((dirdiff = step_dir(destindex - 1) - step_dir(destindex - 2)) == -64 ||
137                  dirdiff == 64)) {
138            prevpos -= step(destindex - 1);
139            prevpos -= step(destindex - 2);
140            destindex -= 2; 
141          }
142          new_box = TBOX(destpos, destpos);
143          box += new_box;
144        }
145      }
146      ASSERT_HOST(destpos.x() == start.x() && destpos.y() == start.y());
147      while (destindex > 1) {
148        dirdiff = step_dir(destindex - 1) - step_dir(0);
149        if (dirdiff != 64 && dirdiff != -64) {
150          break;
151        }
152        start += step(0);
153        destindex -= 2;
154        for (int i = 0; i < destindex; ++i) {
155          set_step(i, step_dir(i + 1));
156        }
157      }
158      if (destindex >= 4) {
159        break;
160      }
161    }
162    ASSERT_HOST(destindex <= stepcount);
163    stepcount = destindex;
164    destpos = start;
165    for (stepindex = 0; stepindex < stepcount; stepindex++) {
166      destpos += step(stepindex);
167    }
168    ASSERT_HOST(destpos.x() == start.x() && destpos.y() == start.y());
169  }
170  void C_OUTLINE::FakeOutline(const TBOX &box, C_OUTLINE_LIST *outlines) {
171    C_OUTLINE_IT ol_it(outlines);
172    CRACKEDGE start;
173    start.pos = box.topleft();
174    auto *outline = new C_OUTLINE(&start, box.topleft(), box.botright(), 0);
175    ol_it.add_to_end(outline);
176  }
177  int32_t C_OUTLINE::area() const {
178    int stepindex;       
179    int32_t total_steps; 
180    int32_t total;       
181    ICOORD pos;          
182    ICOORD next_step;    
183    C_OUTLINE_IT it(const_cast<C_OUTLINE_LIST *>(&children));
184    pos = start_pos();
185    total_steps = pathlength();
186    total = 0;
187    for (stepindex = 0; stepindex < total_steps; stepindex++) {
188      next_step = step(stepindex);
189      if (next_step.x() < 0) {
190        total += pos.y();
191      } else if (next_step.x() > 0) {
192        total -= pos.y();
193      }
194      pos += next_step;
195    }
196    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
197      total += it.data()->area(); 
198    }
199    return total;
200  }
201  int32_t C_OUTLINE::perimeter() const {
202    int32_t total_steps; 
203    C_OUTLINE_IT it(const_cast<C_OUTLINE_LIST *>(&children));
204    total_steps = pathlength();
205    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
206      total_steps += it.data()->pathlength(); 
207    }
208    return total_steps;
209  }
210  int32_t C_OUTLINE::outer_area() const {
211    int stepindex;       
212    int32_t total_steps; 
213    int32_t total;       
214    ICOORD pos;          
215    ICOORD next_step;    
216    pos = start_pos();
217    total_steps = pathlength();
218    if (total_steps == 0) {
219      return box.area();
220    }
221    total = 0;
222    for (stepindex = 0; stepindex < total_steps; stepindex++) {
223      next_step = step(stepindex);
224      if (next_step.x() < 0) {
225        total += pos.y();
226      } else if (next_step.x() > 0) {
227        total -= pos.y();
228      }
229      pos += next_step;
230    }
231    return total;
232  }
233  int32_t C_OUTLINE::count_transitions(int32_t threshold) {
234    bool first_was_max_x; 
235    bool first_was_max_y;
236    bool looking_for_max_x; 
237    bool looking_for_min_x;
238    bool looking_for_max_y; 
239    bool looking_for_min_y;
240    int stepindex;       
241    int32_t total_steps; 
242    int32_t max_x, min_x, max_y, min_y;
243    int32_t initial_x, initial_y; 
244    int32_t total;                
245    ICOORD pos;                   
246    ICOORD next_step;             
247    pos = start_pos();
248    total_steps = pathlength();
249    total = 0;
250    max_x = min_x = pos.x();
251    max_y = min_y = pos.y();
252    looking_for_max_x = true;
253    looking_for_min_x = true;
254    looking_for_max_y = true;
255    looking_for_min_y = true;
256    first_was_max_x = false;
257    first_was_max_y = false;
258    initial_x = pos.x();
259    initial_y = pos.y(); 
260    for (stepindex = 0; stepindex < total_steps; stepindex++) {
261      next_step = step(stepindex);
262      pos += next_step;
263      if (next_step.x() < 0) {
264        if (looking_for_max_x && pos.x() < min_x) {
265          min_x = pos.x();
266        }
267        if (looking_for_min_x && max_x - pos.x() > threshold) {
268          if (looking_for_max_x) {
269            initial_x = max_x;
270            first_was_max_x = false;
271          }
272          total++;
273          looking_for_max_x = true;
274          looking_for_min_x = false;
275          min_x = pos.x(); 
276        }
277      } else if (next_step.x() > 0) {
278        if (looking_for_min_x && pos.x() > max_x) {
279          max_x = pos.x();
280        }
281        if (looking_for_max_x && pos.x() - min_x > threshold) {
282          if (looking_for_min_x) {
283            initial_x = min_x; 
284            first_was_max_x = true;
285          }
286          total++;
287          looking_for_max_x = false;
288          looking_for_min_x = true;
289          max_x = pos.x();
290        }
291      } else if (next_step.y() < 0) {
292        if (looking_for_max_y && pos.y() < min_y) {
293          min_y = pos.y();
294        }
295        if (looking_for_min_y && max_y - pos.y() > threshold) {
296          if (looking_for_max_y) {
297            initial_y = max_y; 
298            first_was_max_y = false;
299          }
300          total++;
301          looking_for_max_y = true;
302          looking_for_min_y = false;
303          min_y = pos.y(); 
304        }
305      } else {
306        if (looking_for_min_y && pos.y() > max_y) {
307          max_y = pos.y();
308        }
309        if (looking_for_max_y && pos.y() - min_y > threshold) {
310          if (looking_for_min_y) {
311            initial_y = min_y; 
312            first_was_max_y = true;
313          }
314          total++;
315          looking_for_max_y = false;
316          looking_for_min_y = true;
317          max_y = pos.y();
318        }
319      }
320    }
321    if (first_was_max_x && looking_for_min_x) {
322      if (max_x - initial_x > threshold) {
323        total++;
324      } else {
325        total--;
326      }
327    } else if (!first_was_max_x && looking_for_max_x) {
328      if (initial_x - min_x > threshold) {
329        total++;
330      } else {
331        total--;
332      }
333    }
334    if (first_was_max_y && looking_for_min_y) {
335      if (max_y - initial_y > threshold) {
336        total++;
337      } else {
338        total--;
339      }
340    } else if (!first_was_max_y && looking_for_max_y) {
341      if (initial_y - min_y > threshold) {
342        total++;
343      } else {
344        total--;
345      }
346    }
347    return total;
348  }
349  bool C_OUTLINE::operator<(const C_OUTLINE &other) const {
350    int16_t count = 0; 
351    ICOORD pos;        
352    int32_t stepindex; 
353    if (!box.overlap(other.box)) {
354      return false; 
355    }
356    if (stepcount == 0) {
357      return other.box.contains(this->box);
358    }
359    pos = start;
360    for (stepindex = 0; stepindex < stepcount && (count = other.winding_number(pos)) == INTERSECTING;
361         stepindex++) {
362      pos += step(stepindex); 
363    }
364    if (count == INTERSECTING) {
365      pos = other.start;
366      for (stepindex = 0;
367           stepindex < other.stepcount && (count = winding_number(pos)) == INTERSECTING;
368           stepindex++) {
369        pos += other.step(stepindex);
370      }
371      return count == INTERSECTING || count == 0;
372    }
373    return count != 0;
374  }
375  int16_t C_OUTLINE::winding_number(ICOORD point) const {
376    int16_t stepindex; 
377    int16_t count;     
378    ICOORD vec;        
379    ICOORD stepvec;    
380    int32_t cross;     
381    vec = start - point; 
382    count = 0;
383    for (stepindex = 0; stepindex < stepcount; stepindex++) {
384      stepvec = step(stepindex); 
385      if (vec.y() <= 0 && vec.y() + stepvec.y() > 0) {
386        cross = vec * stepvec; 
387        if (cross > 0) {
388          count++; 
389        } else if (cross == 0) {
390          return INTERSECTING; 
391        }
392      } else if (vec.y() > 0 && vec.y() + stepvec.y() <= 0) {
393        cross = vec * stepvec;
394        if (cross < 0) {
395          count--; 
396        } else if (cross == 0) {
397          return INTERSECTING; 
398        }
399      }
400      vec += stepvec; 
401    }
402    return count; 
403  }
404  int16_t C_OUTLINE::turn_direction() const { 
405    DIR128 prevdir;                           
406    DIR128 dir;                               
407    int16_t stepindex;                        
408    int8_t dirdiff;                           
409    int16_t count;                            
410    if (stepcount == 0) {
411      return 128;
412    }
413    count = 0;
414    prevdir = step_dir(stepcount - 1);
415    for (stepindex = 0; stepindex < stepcount; stepindex++) {
416      dir = step_dir(stepindex);
417      dirdiff = dir - prevdir;
418      ASSERT_HOST(dirdiff == 0 || dirdiff == 32 || dirdiff == -32);
419      count += dirdiff;
420      prevdir = dir;
421    }
422    ASSERT_HOST(count == 128 || count == -128);
423    return count; 
424  }
425  void C_OUTLINE::reverse() {      
426    DIR128 halfturn = MODULUS / 2; 
427    DIR128 stepdir;                
428    int16_t stepindex;             
429    int16_t farindex;              
430    int16_t halfsteps;             
431    halfsteps = (stepcount + 1) / 2;
432    for (stepindex = 0; stepindex < halfsteps; stepindex++) {
433      farindex = stepcount - stepindex - 1;
434      stepdir = step_dir(stepindex);
435      set_step(stepindex, step_dir(farindex) + halfturn);
436      set_step(farindex, stepdir + halfturn);
437    }
438  }
439  void C_OUTLINE::move(const ICOORD vec) {
440    C_OUTLINE_IT it(&children); 
441    box.move(vec);
442    start += vec;
443    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
444      it.data()->move(vec); 
445    }
446  }
447  bool C_OUTLINE::IsLegallyNested() const {
448    if (stepcount == 0) {
449      return true;
450    }
451    int64_t parent_area = outer_area();
452    C_OUTLINE_IT child_it(const_cast<C_OUTLINE_LIST *>(&children));
453    for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
454      const C_OUTLINE *child = child_it.data();
455      if (child->outer_area() * parent_area > 0 || !child->IsLegallyNested()) {
456        return false;
457      }
458    }
459    return true;
460  }
461  void C_OUTLINE::RemoveSmallRecursive(int min_size, C_OUTLINE_IT *it) {
462    if (box.width() < min_size || box.height() < min_size) {
463      ASSERT_HOST(this == it->data());
464      delete it->extract(); 
465    } else if (!children.empty()) {
466      C_OUTLINE_IT child_it(&children);
467      for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
468        C_OUTLINE *child = child_it.data();
469        child->RemoveSmallRecursive(min_size, &child_it);
470      }
471    }
472  }
473  static void ComputeGradient(const l_uint32 *data, int wpl, int x, int y, int width, int height,
474                              ICOORD *gradient) {
475    const l_uint32 *line = data + y * wpl;
476    int pix_x_y = x < width && y < height ? GET_DATA_BYTE(line, x) : 255;
477    int pix_x_prevy = x < width && y > 0 ? GET_DATA_BYTE(line - wpl, x) : 255;
478    int pix_prevx_prevy = x > 0 && y > 0 ? GET_DATA_BYTE(line - wpl, x - 1) : 255;
479    int pix_prevx_y = x > 0 && y < height ? GET_DATA_BYTE(line, x - 1) : 255;
480    gradient->set_x(pix_x_y + pix_x_prevy - (pix_prevx_y + pix_prevx_prevy));
481    gradient->set_y(pix_x_prevy + pix_prevx_prevy - (pix_x_y + pix_prevx_y));
482  }
483  static bool EvaluateVerticalDiff(const l_uint32 *data, int wpl, int diff_sign, int x, int y,
484                                   int height, int *best_diff, int *best_sum, int *best_y) {
485    if (y <= 0 || y >= height) {
486      return false;
487    }
488    const l_uint32 *line = data + y * wpl;
489    int pixel1 = GET_DATA_BYTE(line - wpl, x);
490    int pixel2 = GET_DATA_BYTE(line, x);
491    int diff = (pixel2 - pixel1) * diff_sign;
492    if (diff > *best_diff) {
493      *best_diff = diff;
494      *best_sum = pixel1 + pixel2;
495      *best_y = y;
496    }
497    return diff > 0;
498  }
499  static bool EvaluateHorizontalDiff(const l_uint32 *line, int diff_sign, int x, int width,
500                                     int *best_diff, int *best_sum, int *best_x) {
501    if (x <= 0 || x >= width) {
502      return false;
503    }
504    int pixel1 = GET_DATA_BYTE(line, x - 1);
505    int pixel2 = GET_DATA_BYTE(line, x);
506    int diff = (pixel2 - pixel1) * diff_sign;
507    if (diff > *best_diff) {
508      *best_diff = diff;
509      *best_sum = pixel1 + pixel2;
510      *best_x = x;
511    }
512    return diff > 0;
513  }
514  void C_OUTLINE::ComputeEdgeOffsets(int threshold, Image pix) {
515    if (pixGetDepth(pix) != 8) {
516      return;
517    }
518    const l_uint32 *data = pixGetData(pix);
519    int wpl = pixGetWpl(pix);
520    int width = pixGetWidth(pix);
521    int height = pixGetHeight(pix);
522    bool negative = flag(COUT_INVERSE);
523    delete[] offsets;
524    offsets = new EdgeOffset[stepcount];
<span onclick='openModal()' class='match'>525    ICOORD pos = start;
526    ICOORD prev_gradient;
527    ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &prev_gradient);
528    for (int s = 0; s < stepcount; ++s) {
529      ICOORD step_vec = step(s);
530      TPOINT pt1(pos);
531      pos += step_vec;
532      TPOINT pt2(pos);
533      ICOORD next_gradient;
534      ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &next_gradient);
535      ICOORD gradient = prev_gradient + next_gradient;
536      int best_diff = 0;
</span>537      int offset = 0;
538      if (pt1.y == pt2.y && abs(gradient.y()) * 2 >= abs(gradient.x())) {
539        int diff_sign = (pt1.x > pt2.x) == negative ? 1 : -1;
540        int x = std::min(pt1.x, pt2.x);
541        int y = height - pt1.y;
542        int best_sum = 0;
543        int best_y = y;
544        EvaluateVerticalDiff(data, wpl, diff_sign, x, y, height, &best_diff, &best_sum, &best_y);
545        int test_y = y;
546        do {
547          ++test_y;
548        } while (EvaluateVerticalDiff(data, wpl, diff_sign, x, test_y, height, &best_diff, &best_sum,
549                                      &best_y));
550        test_y = y;
551        do {
552          --test_y;
553        } while (EvaluateVerticalDiff(data, wpl, diff_sign, x, test_y, height, &best_diff, &best_sum,
554                                      &best_y));
555        offset = diff_sign * (best_sum / 2 - threshold) + (y - best_y) * best_diff;
556      } else if (pt1.x == pt2.x && abs(gradient.x()) * 2 >= abs(gradient.y())) {
557        int diff_sign = (pt1.y > pt2.y) == negative ? 1 : -1;
558        int x = pt1.x;
559        int y = height - std::max(pt1.y, pt2.y);
560        const l_uint32 *line = pixGetData(pix) + y * wpl;
561        int best_sum = 0;
562        int best_x = x;
563        EvaluateHorizontalDiff(line, diff_sign, x, width, &best_diff, &best_sum, &best_x);
564        int test_x = x;
565        do {
566          ++test_x;
567        } while (
568            EvaluateHorizontalDiff(line, diff_sign, test_x, width, &best_diff, &best_sum, &best_x));
569        test_x = x;
570        do {
571          --test_x;
572        } while (
573            EvaluateHorizontalDiff(line, diff_sign, test_x, width, &best_diff, &best_sum, &best_x));
574        offset = diff_sign * (threshold - best_sum / 2) + (best_x - x) * best_diff;
575      }
576      offsets[s].offset_numerator = ClipToRange<int>(offset, -INT8_MAX, INT8_MAX);
577      offsets[s].pixel_diff = ClipToRange<int>(best_diff, 0, UINT8_MAX);
578      if (negative) {
579        gradient = -gradient;
580      }
581      offsets[s].direction = Modulo(FCOORD::binary_angle_plus_pi(gradient.angle()) + 64, 256);
582      prev_gradient = next_gradient;
583    }
584  }
585  void C_OUTLINE::ComputeBinaryOffsets() {
586    delete[] offsets;
587    offsets = new EdgeOffset[stepcount];
588    int dir_counts[4];
589    int pos_totals[4];
590    memset(dir_counts, 0, sizeof(dir_counts));
591    memset(pos_totals, 0, sizeof(pos_totals));
592    ICOORD pos = start;
593    ICOORD tail_pos = pos;
594    tail_pos -= step(stepcount - 1);
595    tail_pos -= step(stepcount - 2);
596    ICOORD head_pos = tail_pos;
597    for (int s = -2; s < 2; ++s) {
598      increment_step(s, 1, &head_pos, dir_counts, pos_totals);
599    }
600    for (int s = 0; s < stepcount; pos += step(s++)) {
601      increment_step(s + 2, 1, &head_pos, dir_counts, pos_totals);
602      int dir_index = chain_code(s);
603      ICOORD step_vec = step(s);
604      int best_diff = 0;
605      int offset = 0;
606      if (dir_counts[dir_index] >= 2 ||
607          (dir_counts[dir_index] == 1 && dir_counts[Modulo(dir_index - 1, 4)] == 2 &&
608           dir_counts[Modulo(dir_index + 1, 4)] == 2)) {
609        best_diff = dir_counts[dir_index];
610        int edge_pos = step_vec.x() == 0 ? pos.x() : pos.y();
611        offset = pos_totals[dir_index] - best_diff * edge_pos;
612      }
613      offsets[s].offset_numerator = ClipToRange<int>(offset, -INT8_MAX, INT8_MAX);
614      offsets[s].pixel_diff = ClipToRange<int>(best_diff, 0, UINT8_MAX);
615      FCOORD direction(head_pos.x() - tail_pos.x(), head_pos.y() - tail_pos.y());
616      offsets[s].direction = direction.to_direction();
617      increment_step(s - 2, -1, &tail_pos, dir_counts, pos_totals);
618    }
619  }
620  void C_OUTLINE::render(int left, int top, Image pix) const {
621    ICOORD pos = start;
622    for (int stepindex = 0; stepindex < stepcount; ++stepindex) {
623      ICOORD next_step = step(stepindex);
624      if (next_step.y() < 0) {
625        pixRasterop(pix, 0, top - pos.y(), pos.x() - left, 1, PIX_NOT(PIX_DST), nullptr, 0, 0);
626      } else if (next_step.y() > 0) {
627        pixRasterop(pix, 0, top - pos.y() - 1, pos.x() - left, 1, PIX_NOT(PIX_DST), nullptr, 0, 0);
628      }
629      pos += next_step;
630    }
631  }
632  void C_OUTLINE::render_outline(int left, int top, Image pix) const {
633    ICOORD pos = start;
634    for (int stepindex = 0; stepindex < stepcount; ++stepindex) {
635      ICOORD next_step = step(stepindex);
636      if (next_step.y() < 0) {
637        pixSetPixel(pix, pos.x() - left, top - pos.y(), 1);
638      } else if (next_step.y() > 0) {
639        pixSetPixel(pix, pos.x() - left - 1, top - pos.y() - 1, 1);
640      } else if (next_step.x() < 0) {
641        pixSetPixel(pix, pos.x() - left - 1, top - pos.y(), 1);
642      } else if (next_step.x() > 0) {
643        pixSetPixel(pix, pos.x() - left, top - pos.y() - 1, 1);
644      }
645      pos += next_step;
646    }
647  }
648  #ifndef GRAPHICS_DISABLED
649  void C_OUTLINE::plot(ScrollView *window, ScrollView::Color colour) const {
650    int16_t stepindex; 
651    ICOORD pos;        
652    DIR128 stepdir;    
653    pos = start; 
654    window->Pen(colour);
655    if (stepcount == 0) {
656      window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
657      return;
658    }
659    window->SetCursor(pos.x(), pos.y());
660    stepindex = 0;
661    while (stepindex < stepcount) {
662      pos += step(stepindex); 
663      stepdir = step_dir(stepindex);
664      stepindex++; 
665      while (stepindex < stepcount && stepdir.get_dir() == step_dir(stepindex).get_dir()) {
666        pos += step(stepindex);
667        stepindex++;
668      }
669      window->DrawTo(pos.x(), pos.y());
670    }
671  }
672  void C_OUTLINE::plot_normed(const DENORM &denorm, ScrollView::Color colour,
673                              ScrollView *window) const {
674    window->Pen(colour);
675    if (stepcount == 0) {
676      window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
677      return;
678    }
679    const DENORM *root_denorm = denorm.RootDenorm();
680    ICOORD pos = start; 
681    FCOORD f_pos = sub_pixel_pos_at_index(pos, 0);
682    FCOORD pos_normed;
683    denorm.NormTransform(root_denorm, f_pos, &pos_normed);
684    window->SetCursor(IntCastRounded(pos_normed.x()), IntCastRounded(pos_normed.y()));
685    for (int s = 0; s < stepcount; pos += step(s++)) {
686      int edge_weight = edge_strength_at_index(s);
687      if (edge_weight == 0) {
688        continue;
689      }
690      FCOORD f_pos = sub_pixel_pos_at_index(pos, s);
691      FCOORD pos_normed;
692      denorm.NormTransform(root_denorm, f_pos, &pos_normed);
693      window->DrawTo(IntCastRounded(pos_normed.x()), IntCastRounded(pos_normed.y()));
694    }
695  }
696  #endif
697  C_OUTLINE &C_OUTLINE::operator=(const C_OUTLINE &source) {
698    box = source.box;
699    start = source.start;
700    if (!children.empty()) {
701      children.clear();
702    }
703    children.deep_copy(&source.children, &deep_copy);
704    delete[] offsets;
705    offsets = nullptr;
706    stepcount = source.stepcount;
707    if (stepcount > 0) {
708      steps.resize(step_mem());
709      memmove(&steps[0], &source.steps[0], step_mem());
710      if (source.offsets != nullptr) {
711        offsets = new EdgeOffset[stepcount];
712        memcpy(offsets, source.offsets, stepcount * sizeof(*offsets));
713      }
714    }
715    return *this;
716  }
717  void C_OUTLINE::increment_step(int s, int increment, ICOORD *pos, int *dir_counts,
718                                 int *pos_totals) const {
719    int step_index = Modulo(s, stepcount);
720    int dir_index = chain_code(step_index);
721    dir_counts[dir_index] += increment;
722    ICOORD step_vec = step(step_index);
723    if (step_vec.x() == 0) {
724      pos_totals[dir_index] += pos->x() * increment;
725    } else {
726      pos_totals[dir_index] += pos->y() * increment;
727    }
728    *pos += step_vec;
729  }
730  ICOORD C_OUTLINE::chain_step(int chaindir) {
731    return step_coords[chaindir % 4];
732  }
733  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stopper.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.cpp</div>
                </div>
                <div class="column column_space"><pre><code>378    TotalCertainty = TotalCertaintySquared = 0.0;
379    for (int i = 0; i < word_length; ++i) {
380      Certainty = word.certainty(i);
381      TotalCertainty += Certainty;
382      TotalCertaintySquared += static_cast<double>(Certainty) * Certainty;
</pre></code></div>
                <div class="column column_space"><pre><code>525    ICOORD pos = start;
526    ICOORD prev_gradient;
527    ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &prev_gradient);
528    for (int s = 0; s < stepcount; ++s) {
529      ICOORD step_vec = step(s);
530      TPOINT pt1(pos);
531      pos += step_vec;
532      TPOINT pt2(pos);
533      ICOORD next_gradient;
534      ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &next_gradient);
535      ICOORD gradient = prev_gradient + next_gradient;
536      int best_diff = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    