
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</h3>
            <pre><code>1  #include "absl/meta/type_traits.h"
2  #include <cstdint>
3  #include <string>
4  #include <type_traits>
5  #include <utility>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/base/attributes.h"
9  #include "absl/base/config.h"
10  #include "absl/time/clock.h"
11  #include "absl/time/time.h"
12  namespace {
13  using ::testing::StaticAssertTypeEq;
14  template <class T, class U>
15  struct simple_pair {
16    T first;
17    U second;
18  };
19  struct Dummy {};
20  struct ReturnType {};
21  struct ConvertibleToReturnType {
22    operator ReturnType() const;  
23  };
24  struct StructA {};
25  struct StructB {};
26  struct StructC {};
27  struct TypeWithBarFunction {
28    template <class T,
29              absl::enable_if_t<std::is_same<T&&, StructA&>::value, int> = 0>
30    ReturnType bar(T&&, const StructB&, StructC&&) &&;  
31  };
32  struct TypeWithBarFunctionAndConvertibleReturnType {
33    template <class T,
34              absl::enable_if_t<std::is_same<T&&, StructA&>::value, int> = 0>
35    ConvertibleToReturnType bar(T&&, const StructB&, StructC&&) &&;  
36  };
37  template <class Class, class... Ts>
38  using BarIsCallableImpl =
39      decltype(std::declval<Class>().bar(std::declval<Ts>()...));
40  template <class Class, class... T>
41  using BarIsCallable =
42      absl::type_traits_internal::is_detected<BarIsCallableImpl, Class, T...>;
43  template <class Class, class... T>
44  using BarIsCallableConv = absl::type_traits_internal::is_detected_convertible<
45      ReturnType, BarIsCallableImpl, Class, T...>;
46  TEST(IsDetectedTest, BasicUsage) {
47    EXPECT_TRUE((BarIsCallable<TypeWithBarFunction, StructA&, const StructB&,
48                               StructC>::value));
49    EXPECT_TRUE(
50        (BarIsCallable<TypeWithBarFunction, StructA&, StructB&, StructC>::value));
51    EXPECT_TRUE(
52        (BarIsCallable<TypeWithBarFunction, StructA&, StructB, StructC>::value));
53    EXPECT_FALSE((BarIsCallable<int, StructA&, const StructB&, StructC>::value));
54    EXPECT_FALSE((BarIsCallable<TypeWithBarFunction&, StructA&, const StructB&,
55                                StructC>::value));
56    EXPECT_FALSE((BarIsCallable<TypeWithBarFunction, StructA, const StructB&,
57                                StructC>::value));
58  }
59  TEST(IsDetectedConvertibleTest, BasicUsage) {
60    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunction, StructA&, const StructB&,
61                                   StructC>::value));
62    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunction, StructA&, StructB&,
63                                   StructC>::value));
64    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunction, StructA&, StructB,
65                                   StructC>::value));
66    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
67                                   StructA&, const StructB&, StructC>::value));
68    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
69                                   StructA&, StructB&, StructC>::value));
70    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
71                                   StructA&, StructB, StructC>::value));
72    EXPECT_FALSE(
73        (BarIsCallableConv<int, StructA&, const StructB&, StructC>::value));
74    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunction&, StructA&,
75                                    const StructB&, StructC>::value));
76    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunction, StructA, const StructB&,
77                                    StructC>::value));
78    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType&,
79                                    StructA&, const StructB&, StructC>::value));
80    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
81                                    StructA, const StructB&, StructC>::value));
82  }
83  TEST(VoidTTest, BasicUsage) {
84    StaticAssertTypeEq<void, absl::void_t<Dummy>>();
85    StaticAssertTypeEq<void, absl::void_t<Dummy, Dummy, Dummy>>();
86  }
87  TEST(ConjunctionTest, BasicBooleanLogic) {
88    EXPECT_TRUE(absl::conjunction<>::value);
89    EXPECT_TRUE(absl::conjunction<std::true_type>::value);
90    EXPECT_TRUE((absl::conjunction<std::true_type, std::true_type>::value));
91    EXPECT_FALSE((absl::conjunction<std::true_type, std::false_type>::value));
92    EXPECT_FALSE((absl::conjunction<std::false_type, std::true_type>::value));
93    EXPECT_FALSE((absl::conjunction<std::false_type, std::false_type>::value));
94  }
95  struct MyTrueType {
96    static constexpr bool value = true;
97  };
98  struct MyFalseType {
99    static constexpr bool value = false;
100  };
101  TEST(ConjunctionTest, ShortCircuiting) {
102    EXPECT_FALSE(
103        (absl::conjunction<std::true_type, std::false_type, Dummy>::value));
104    EXPECT_TRUE((std::is_base_of<MyFalseType,
105                                 absl::conjunction<std::true_type, MyFalseType,
106                                                   std::false_type>>::value));
107    EXPECT_TRUE(
108        (std::is_base_of<MyTrueType,
109                         absl::conjunction<std::true_type, MyTrueType>>::value));
110  }
111  TEST(DisjunctionTest, BasicBooleanLogic) {
112    EXPECT_FALSE(absl::disjunction<>::value);
113    EXPECT_FALSE(absl::disjunction<std::false_type>::value);
114    EXPECT_TRUE((absl::disjunction<std::true_type, std::true_type>::value));
115    EXPECT_TRUE((absl::disjunction<std::true_type, std::false_type>::value));
116    EXPECT_TRUE((absl::disjunction<std::false_type, std::true_type>::value));
117    EXPECT_FALSE((absl::disjunction<std::false_type, std::false_type>::value));
118  }
119  TEST(DisjunctionTest, ShortCircuiting) {
120    EXPECT_TRUE(
121        (absl::disjunction<std::false_type, std::true_type, Dummy>::value));
122    EXPECT_TRUE((
123        std::is_base_of<MyTrueType, absl::disjunction<std::false_type, MyTrueType,
124                                                      std::true_type>>::value));
125    EXPECT_TRUE((
126        std::is_base_of<MyFalseType,
127                        absl::disjunction<std::false_type, MyFalseType>>::value));
128  }
129  TEST(NegationTest, BasicBooleanLogic) {
130    EXPECT_FALSE(absl::negation<std::true_type>::value);
131    EXPECT_FALSE(absl::negation<MyTrueType>::value);
132    EXPECT_TRUE(absl::negation<std::false_type>::value);
133    EXPECT_TRUE(absl::negation<MyFalseType>::value);
134  }
135  class Trivial {
136    int n_;
137  };
138  struct TrivialDestructor {
139    ~TrivialDestructor() = default;
140  };
141  struct NontrivialDestructor {
142    ~NontrivialDestructor() {}
143  };
144  struct DeletedDestructor {
145    ~DeletedDestructor() = delete;
146  };
147  class TrivialDefaultCtor {
148   public:
149    TrivialDefaultCtor() = default;
150    explicit TrivialDefaultCtor(int n) : n_(n) {}
151   private:
152    int n_;
153  };
154  class NontrivialDefaultCtor {
155   public:
156    NontrivialDefaultCtor() : n_(1) {}
157   private:
158    int n_;
159  };
160  class DeletedDefaultCtor {
161   public:
162    DeletedDefaultCtor() = delete;
163    explicit DeletedDefaultCtor(int n) : n_(n) {}
164   private:
165    int n_;
166  };
167  class TrivialMoveCtor {
168   public:
169    explicit TrivialMoveCtor(int n) : n_(n) {}
170    TrivialMoveCtor(TrivialMoveCtor&&) = default;
171    TrivialMoveCtor& operator=(const TrivialMoveCtor& t) {
172      n_ = t.n_;
173      return *this;
174    }
175   private:
176    int n_;
177  };
178  class NontrivialMoveCtor {
179   public:
180    explicit NontrivialMoveCtor(int n) : n_(n) {}
181    NontrivialMoveCtor(NontrivialMoveCtor&& t) noexcept : n_(t.n_) {}
182    NontrivialMoveCtor& operator=(const NontrivialMoveCtor&) = default;
183   private:
184    int n_;
185  };
186  class TrivialCopyCtor {
187   public:
188    explicit TrivialCopyCtor(int n) : n_(n) {}
189    TrivialCopyCtor(const TrivialCopyCtor&) = default;
190    TrivialCopyCtor& operator=(const TrivialCopyCtor& t) {
191      n_ = t.n_;
192      return *this;
193    }
194   private:
195    int n_;
196  };
197  class NontrivialCopyCtor {
198   public:
199    explicit NontrivialCopyCtor(int n) : n_(n) {}
200    NontrivialCopyCtor(const NontrivialCopyCtor& t) : n_(t.n_) {}
201    NontrivialCopyCtor& operator=(const NontrivialCopyCtor&) = default;
202   private:
203    int n_;
204  };
205  class DeletedCopyCtor {
206   public:
207    explicit DeletedCopyCtor(int n) : n_(n) {}
208    DeletedCopyCtor(const DeletedCopyCtor&) = delete;
209    DeletedCopyCtor& operator=(const DeletedCopyCtor&) = default;
210   private:
211    int n_;
212  };
213  class TrivialMoveAssign {
214   public:
215    explicit TrivialMoveAssign(int n) : n_(n) {}
216    TrivialMoveAssign(const TrivialMoveAssign& t) : n_(t.n_) {}
217    TrivialMoveAssign& operator=(TrivialMoveAssign&&) = default;
218    ~TrivialMoveAssign() {}  
219   private:
220    int n_;
221  };
222  class NontrivialMoveAssign {
223   public:
224    explicit NontrivialMoveAssign(int n) : n_(n) {}
225    NontrivialMoveAssign(const NontrivialMoveAssign&) = default;
226    NontrivialMoveAssign& operator=(NontrivialMoveAssign&& t) noexcept {
<span onclick='openModal()' class='match'>227      n_ = t.n_;
228      return *this;
229    }
230   private:
231    int n_;
232  };
233  class TrivialCopyAssign {
234   public:
235    explicit TrivialCopyAssign(int n) : n_(n) {}
236    TrivialCopyAssign(const TrivialCopyAssign& t) : n_(t.n_) {}
</span>237    TrivialCopyAssign& operator=(const TrivialCopyAssign& t) = default;
238    ~TrivialCopyAssign() {}  
239   private:
240    int n_;
241  };
242  class NontrivialCopyAssign {
243   public:
244    explicit NontrivialCopyAssign(int n) : n_(n) {}
245    NontrivialCopyAssign(const NontrivialCopyAssign&) = default;
246    NontrivialCopyAssign& operator=(const NontrivialCopyAssign& t) {
247      n_ = t.n_;
248      return *this;
249    }
250   private:
251    int n_;
252  };
253  class DeletedCopyAssign {
254   public:
255    explicit DeletedCopyAssign(int n) : n_(n) {}
256    DeletedCopyAssign(const DeletedCopyAssign&) = default;
257    DeletedCopyAssign& operator=(const DeletedCopyAssign&) = delete;
258   private:
259    int n_;
260  };
261  struct MovableNonCopyable {
262    MovableNonCopyable() = default;
263    MovableNonCopyable(const MovableNonCopyable&) = delete;
264    MovableNonCopyable(MovableNonCopyable&&) = default;
265    MovableNonCopyable& operator=(const MovableNonCopyable&) = delete;
266    MovableNonCopyable& operator=(MovableNonCopyable&&) = default;
267  };
268  struct NonCopyableOrMovable {
269    NonCopyableOrMovable() = default;
270    virtual ~NonCopyableOrMovable() = default;
271    NonCopyableOrMovable(const NonCopyableOrMovable&) = delete;
272    NonCopyableOrMovable(NonCopyableOrMovable&&) = delete;
273    NonCopyableOrMovable& operator=(const NonCopyableOrMovable&) = delete;
274    NonCopyableOrMovable& operator=(NonCopyableOrMovable&&) = delete;
275  };
276  class Base {
277   public:
278    virtual ~Base() {}
279  };
280  TEST(TypeTraitsTest, TestIsFunction) {
281    struct Callable {
282      void operator()() {}
283    };
284    EXPECT_TRUE(absl::is_function<void()>::value);
285    EXPECT_TRUE(absl::is_function<void()&>::value);
286    EXPECT_TRUE(absl::is_function<void() const>::value);
287    EXPECT_TRUE(absl::is_function<void() noexcept>::value);
288    EXPECT_TRUE(absl::is_function<void(...) noexcept>::value);
289    EXPECT_FALSE(absl::is_function<void(*)()>::value);
290    EXPECT_FALSE(absl::is_function<void(&)()>::value);
291    EXPECT_FALSE(absl::is_function<int>::value);
292    EXPECT_FALSE(absl::is_function<Callable>::value);
293  }
294  TEST(TypeTraitsTest, TestRemoveCVRef) {
295    EXPECT_TRUE(
296        (std::is_same<typename absl::remove_cvref<int>::type, int>::value));
297    EXPECT_TRUE(
298        (std::is_same<typename absl::remove_cvref<int&>::type, int>::value));
299    EXPECT_TRUE(
300        (std::is_same<typename absl::remove_cvref<int&&>::type, int>::value));
301    EXPECT_TRUE((
302        std::is_same<typename absl::remove_cvref<const int&>::type, int>::value));
303    EXPECT_TRUE(
304        (std::is_same<typename absl::remove_cvref<int*>::type, int*>::value));
305    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int*>::type,
306                              const int*>::value));
307    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<int[2]>::type,
308                              int[2]>::value));
309    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<int(&)[2]>::type,
310                              int[2]>::value));
311    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<int(&&)[2]>::type,
312                              int[2]>::value));
313    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int[2]>::type,
314                              int[2]>::value));
315    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int(&)[2]>::type,
316                              int[2]>::value));
317    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int(&&)[2]>::type,
318                              int[2]>::value));
319  }
320  #define ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(trait_name, ...)          \
321    EXPECT_TRUE((std::is_same<typename std::trait_name<__VA_ARGS__>::type, \
322                              absl::trait_name##_t<__VA_ARGS__>>::value))
323  TEST(TypeTraitsTest, TestRemoveCVAliases) {
324    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, int);
325    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const int);
326    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, volatile int);
327    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const volatile int);
328    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, int);
329    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const int);
330    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, volatile int);
331    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const volatile int);
332    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, int);
333    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const int);
334    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, volatile int);
335    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const volatile int);
336  }
337  TEST(TypeTraitsTest, TestAddCVAliases) {
338    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, int);
339    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const int);
340    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, volatile int);
341    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const volatile int);
342    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, int);
343    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const int);
344    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, volatile int);
345    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const volatile int);
346    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, int);
347    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const int);
348    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, volatile int);
349    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const volatile int);
350  }
351  TEST(TypeTraitsTest, TestReferenceAliases) {
352    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int);
353    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int);
354    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&);
355    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&);
356    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&&);
357    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&&);
358    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int);
359    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int);
360    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&);
361    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&);
362    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&&);
363    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&&);
364    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int);
365    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int);
366    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&);
367    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&);
368    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&&);
369    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&&);
370  }
371  TEST(TypeTraitsTest, TestPointerAliases) {
372    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, int*);
373    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, volatile int*);
374    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, int);
375    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, volatile int);
376  }
377  TEST(TypeTraitsTest, TestSignednessAliases) {
378    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, int);
379    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile int);
380    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, unsigned);
381    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile unsigned);
382    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, int);
383    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile int);
384    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, unsigned);
385    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile unsigned);
386  }
387  TEST(TypeTraitsTest, TestExtentAliases) {
388    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[]);
389    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1]);
390    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1][1]);
391    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[][1]);
392    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[]);
393    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1]);
394    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1][1]);
395    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[][1]);
396  }
397  TEST(TypeTraitsTest, TestAlignedStorageAlias) {
398    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1);
399    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2);
400    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3);
401    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4);
402    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5);
403    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6);
404    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7);
405    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8);
406    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9);
407    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10);
408    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11);
409    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12);
410    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13);
411    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14);
412    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15);
413    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16);
414    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17);
415    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18);
416    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19);
417    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20);
418    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21);
419    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22);
420    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23);
421    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24);
422    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25);
423    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26);
424    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27);
425    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28);
426    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29);
427    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30);
428    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31);
429    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32);
430    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33);
431    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1, 128);
432    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2, 128);
433    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3, 128);
434    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4, 128);
435    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5, 128);
436    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6, 128);
437    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7, 128);
438    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8, 128);
439    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9, 128);
440    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10, 128);
441    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11, 128);
442    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12, 128);
443    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13, 128);
444    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14, 128);
445    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15, 128);
446    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16, 128);
447    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17, 128);
448    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18, 128);
449    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19, 128);
450    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20, 128);
451    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21, 128);
452    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22, 128);
453    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23, 128);
454    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24, 128);
455    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25, 128);
456    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26, 128);
457    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27, 128);
458    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28, 128);
459    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29, 128);
460    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30, 128);
461    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31, 128);
462    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32, 128);
463    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33, 128);
464  }
465  TEST(TypeTraitsTest, TestDecay) {
466    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int);
467    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int);
468    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int);
469    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int);
470    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&);
471    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&);
472    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&);
473    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&);
474    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&);
475    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&);
476    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&);
477    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&);
478    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1]);
479    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1][1]);
480    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[][1]);
481    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int());
482    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(float));  
483    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(char, ...));  
484  }
485  struct TypeA {};
486  struct TypeB {};
487  struct TypeC {};
488  struct TypeD {};
489  template <typename T>
490  struct Wrap {};
491  enum class TypeEnum { A, B, C, D };
492  struct GetTypeT {
493    template <typename T,
494              absl::enable_if_t<std::is_same<T, TypeA>::value, int> = 0>
495    TypeEnum operator()(Wrap<T>) const {
496      return TypeEnum::A;
497    }
498    template <typename T,
499              absl::enable_if_t<std::is_same<T, TypeB>::value, int> = 0>
500    TypeEnum operator()(Wrap<T>) const {
501      return TypeEnum::B;
502    }
503    template <typename T,
504              absl::enable_if_t<std::is_same<T, TypeC>::value, int> = 0>
505    TypeEnum operator()(Wrap<T>) const {
506      return TypeEnum::C;
507    }
508  } constexpr GetType = {};
509  TEST(TypeTraitsTest, TestEnableIf) {
510    EXPECT_EQ(TypeEnum::A, GetType(Wrap<TypeA>()));
511    EXPECT_EQ(TypeEnum::B, GetType(Wrap<TypeB>()));
512    EXPECT_EQ(TypeEnum::C, GetType(Wrap<TypeC>()));
513  }
514  TEST(TypeTraitsTest, TestConditional) {
515    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, true, int, char);
516    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, false, int, char);
517  }
518  TEST(TypeTraitsTest, TestCommonType) {
519    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int);
520    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char);
521    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int);
522    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int&);
523    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char&);
524    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int&);
525  }
526  TEST(TypeTraitsTest, TestUnderlyingType) {
527    enum class enum_char : char {};
528    enum class enum_long_long : long long {};  
529    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_char);
530    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_long_long);
531  }
532  struct GetTypeExtT {
533    template <typename T>
534    absl::result_of_t<const GetTypeT&(T)> operator()(T&& arg) const {
535      return GetType(std::forward<T>(arg));
536    }
537    TypeEnum operator()(Wrap<TypeD>) const { return TypeEnum::D; }
538  } constexpr GetTypeExt = {};
539  TEST(TypeTraitsTest, TestResultOf) {
540    EXPECT_EQ(TypeEnum::A, GetTypeExt(Wrap<TypeA>()));
541    EXPECT_EQ(TypeEnum::B, GetTypeExt(Wrap<TypeB>()));
542    EXPECT_EQ(TypeEnum::C, GetTypeExt(Wrap<TypeC>()));
543    EXPECT_EQ(TypeEnum::D, GetTypeExt(Wrap<TypeD>()));
544  }
545  namespace adl_namespace {
546  struct DeletedSwap {
547  };
548  void swap(DeletedSwap&, DeletedSwap&) = delete;
549  struct SpecialNoexceptSwap {
550    SpecialNoexceptSwap(SpecialNoexceptSwap&&) {}
551    SpecialNoexceptSwap& operator=(SpecialNoexceptSwap&&) { return *this; }
552    ~SpecialNoexceptSwap() = default;
553  };
554  void swap(SpecialNoexceptSwap&, SpecialNoexceptSwap&) noexcept {}
555  }  
556  TEST(TypeTraitsTest, IsSwappable) {
557    using absl::type_traits_internal::IsSwappable;
558    using absl::type_traits_internal::StdSwapIsUnconstrained;
559    EXPECT_TRUE(IsSwappable<int>::value);
560    struct S {};
561    EXPECT_TRUE(IsSwappable<S>::value);
562    struct NoConstruct {
563      NoConstruct(NoConstruct&&) = delete;
564      NoConstruct& operator=(NoConstruct&&) { return *this; }
565      ~NoConstruct() = default;
566    };
567    EXPECT_EQ(IsSwappable<NoConstruct>::value, StdSwapIsUnconstrained::value);
568    struct NoAssign {
569      NoAssign(NoAssign&&) {}
570      NoAssign& operator=(NoAssign&&) = delete;
571      ~NoAssign() = default;
572    };
573    EXPECT_EQ(IsSwappable<NoAssign>::value, StdSwapIsUnconstrained::value);
574    EXPECT_FALSE(IsSwappable<adl_namespace::DeletedSwap>::value);
575    EXPECT_TRUE(IsSwappable<adl_namespace::SpecialNoexceptSwap>::value);
576  }
577  TEST(TypeTraitsTest, IsNothrowSwappable) {
578    using absl::type_traits_internal::IsNothrowSwappable;
579    using absl::type_traits_internal::StdSwapIsUnconstrained;
580    EXPECT_TRUE(IsNothrowSwappable<int>::value);
581    struct NonNoexceptMoves {
582      NonNoexceptMoves(NonNoexceptMoves&&) {}
583      NonNoexceptMoves& operator=(NonNoexceptMoves&&) { return *this; }
584      ~NonNoexceptMoves() = default;
585    };
586    EXPECT_FALSE(IsNothrowSwappable<NonNoexceptMoves>::value);
587    struct NoConstruct {
588      NoConstruct(NoConstruct&&) = delete;
589      NoConstruct& operator=(NoConstruct&&) { return *this; }
590      ~NoConstruct() = default;
591    };
592    EXPECT_FALSE(IsNothrowSwappable<NoConstruct>::value);
593    struct NoAssign {
594      NoAssign(NoAssign&&) {}
595      NoAssign& operator=(NoAssign&&) = delete;
596      ~NoAssign() = default;
597    };
598    EXPECT_FALSE(IsNothrowSwappable<NoAssign>::value);
599    EXPECT_FALSE(IsNothrowSwappable<adl_namespace::DeletedSwap>::value);
600    EXPECT_TRUE(IsNothrowSwappable<adl_namespace::SpecialNoexceptSwap>::value);
601  }
602  TEST(TriviallyRelocatable, PrimitiveTypes) {
603    static_assert(absl::is_trivially_relocatable<int>::value, "");
604    static_assert(absl::is_trivially_relocatable<char>::value, "");
605    static_assert(absl::is_trivially_relocatable<void*>::value, "");
606  }
607  TEST(TriviallyRelocatable, UserDefinedTriviallyReconstructible) {
608    struct S {
609      int x;
610      int y;
611    };
612    static_assert(absl::is_trivially_relocatable<S>::value, "");
613  }
614  TEST(TriviallyRelocatable, UserProvidedMoveConstructor) {
615    struct S {
616      S(S&&) {}  
617    };
618    static_assert(!absl::is_trivially_relocatable<S>::value, "");
619  }
620  TEST(TriviallyRelocatable, UserProvidedCopyConstructor) {
621    struct S {
622      S(const S&) {}  
623    };
624    static_assert(!absl::is_trivially_relocatable<S>::value, "");
625  }
626  TEST(TriviallyRelocatable, UserProvidedDestructor) {
627    struct S {
628      ~S() {}  
629    };
630    static_assert(!absl::is_trivially_relocatable<S>::value, "");
631  }
632  #if defined(ABSL_HAVE_ATTRIBUTE_TRIVIAL_ABI) &&      \
633      ABSL_HAVE_BUILTIN(__is_trivially_relocatable) && \
634      !(defined(__clang__) && (defined(_WIN32) || defined(_WIN64)))
635  TEST(TrivallyRelocatable, TrivialAbi) {
636    struct ABSL_ATTRIBUTE_TRIVIAL_ABI S {
637      S(S&&) {}       
638      S(const S&) {}  
639      ~S() {}         
640    };
641    static_assert(absl::is_trivially_relocatable<S>::value, "");
642  }
643  #endif
644  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
645  constexpr int64_t NegateIfConstantEvaluated(int64_t i) {
646    if (absl::is_constant_evaluated()) {
647      return -i;
648    } else {
649      return i;
650    }
651  }
652  #endif  
653  TEST(TrivallyRelocatable, is_constant_evaluated) {
654  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
655    constexpr int64_t constant = NegateIfConstantEvaluated(42);
656    EXPECT_EQ(constant, -42);
657    int64_t now = absl::ToUnixSeconds(absl::Now());
658    int64_t not_constant = NegateIfConstantEvaluated(now);
659    EXPECT_EQ(not_constant, now);
660    static int64_t const_init = NegateIfConstantEvaluated(42);
661    EXPECT_EQ(const_init, -42);
662  #else
663    GTEST_SKIP() << "absl::is_constant_evaluated is not defined";
664  #endif  
665  }
666  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</h3>
            <pre><code>1  #include "absl/meta/type_traits.h"
2  #include <cstdint>
3  #include <string>
4  #include <type_traits>
5  #include <utility>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/base/attributes.h"
9  #include "absl/base/config.h"
10  #include "absl/time/clock.h"
11  #include "absl/time/time.h"
12  namespace {
13  using ::testing::StaticAssertTypeEq;
14  template <class T, class U>
15  struct simple_pair {
16    T first;
17    U second;
18  };
19  struct Dummy {};
20  struct ReturnType {};
21  struct ConvertibleToReturnType {
22    operator ReturnType() const;  
23  };
24  struct StructA {};
25  struct StructB {};
26  struct StructC {};
27  struct TypeWithBarFunction {
28    template <class T,
29              absl::enable_if_t<std::is_same<T&&, StructA&>::value, int> = 0>
30    ReturnType bar(T&&, const StructB&, StructC&&) &&;  
31  };
32  struct TypeWithBarFunctionAndConvertibleReturnType {
33    template <class T,
34              absl::enable_if_t<std::is_same<T&&, StructA&>::value, int> = 0>
35    ConvertibleToReturnType bar(T&&, const StructB&, StructC&&) &&;  
36  };
37  template <class Class, class... Ts>
38  using BarIsCallableImpl =
39      decltype(std::declval<Class>().bar(std::declval<Ts>()...));
40  template <class Class, class... T>
41  using BarIsCallable =
42      absl::type_traits_internal::is_detected<BarIsCallableImpl, Class, T...>;
43  template <class Class, class... T>
44  using BarIsCallableConv = absl::type_traits_internal::is_detected_convertible<
45      ReturnType, BarIsCallableImpl, Class, T...>;
46  TEST(IsDetectedTest, BasicUsage) {
47    EXPECT_TRUE((BarIsCallable<TypeWithBarFunction, StructA&, const StructB&,
48                               StructC>::value));
49    EXPECT_TRUE(
50        (BarIsCallable<TypeWithBarFunction, StructA&, StructB&, StructC>::value));
51    EXPECT_TRUE(
52        (BarIsCallable<TypeWithBarFunction, StructA&, StructB, StructC>::value));
53    EXPECT_FALSE((BarIsCallable<int, StructA&, const StructB&, StructC>::value));
54    EXPECT_FALSE((BarIsCallable<TypeWithBarFunction&, StructA&, const StructB&,
55                                StructC>::value));
56    EXPECT_FALSE((BarIsCallable<TypeWithBarFunction, StructA, const StructB&,
57                                StructC>::value));
58  }
59  TEST(IsDetectedConvertibleTest, BasicUsage) {
60    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunction, StructA&, const StructB&,
61                                   StructC>::value));
62    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunction, StructA&, StructB&,
63                                   StructC>::value));
64    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunction, StructA&, StructB,
65                                   StructC>::value));
66    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
67                                   StructA&, const StructB&, StructC>::value));
68    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
69                                   StructA&, StructB&, StructC>::value));
70    EXPECT_TRUE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
71                                   StructA&, StructB, StructC>::value));
72    EXPECT_FALSE(
73        (BarIsCallableConv<int, StructA&, const StructB&, StructC>::value));
74    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunction&, StructA&,
75                                    const StructB&, StructC>::value));
76    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunction, StructA, const StructB&,
77                                    StructC>::value));
78    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType&,
79                                    StructA&, const StructB&, StructC>::value));
80    EXPECT_FALSE((BarIsCallableConv<TypeWithBarFunctionAndConvertibleReturnType,
81                                    StructA, const StructB&, StructC>::value));
82  }
83  TEST(VoidTTest, BasicUsage) {
84    StaticAssertTypeEq<void, absl::void_t<Dummy>>();
85    StaticAssertTypeEq<void, absl::void_t<Dummy, Dummy, Dummy>>();
86  }
87  TEST(ConjunctionTest, BasicBooleanLogic) {
88    EXPECT_TRUE(absl::conjunction<>::value);
89    EXPECT_TRUE(absl::conjunction<std::true_type>::value);
90    EXPECT_TRUE((absl::conjunction<std::true_type, std::true_type>::value));
91    EXPECT_FALSE((absl::conjunction<std::true_type, std::false_type>::value));
92    EXPECT_FALSE((absl::conjunction<std::false_type, std::true_type>::value));
93    EXPECT_FALSE((absl::conjunction<std::false_type, std::false_type>::value));
94  }
95  struct MyTrueType {
96    static constexpr bool value = true;
97  };
98  struct MyFalseType {
99    static constexpr bool value = false;
100  };
101  TEST(ConjunctionTest, ShortCircuiting) {
102    EXPECT_FALSE(
103        (absl::conjunction<std::true_type, std::false_type, Dummy>::value));
104    EXPECT_TRUE((std::is_base_of<MyFalseType,
105                                 absl::conjunction<std::true_type, MyFalseType,
106                                                   std::false_type>>::value));
107    EXPECT_TRUE(
108        (std::is_base_of<MyTrueType,
109                         absl::conjunction<std::true_type, MyTrueType>>::value));
110  }
111  TEST(DisjunctionTest, BasicBooleanLogic) {
112    EXPECT_FALSE(absl::disjunction<>::value);
113    EXPECT_FALSE(absl::disjunction<std::false_type>::value);
114    EXPECT_TRUE((absl::disjunction<std::true_type, std::true_type>::value));
115    EXPECT_TRUE((absl::disjunction<std::true_type, std::false_type>::value));
116    EXPECT_TRUE((absl::disjunction<std::false_type, std::true_type>::value));
117    EXPECT_FALSE((absl::disjunction<std::false_type, std::false_type>::value));
118  }
119  TEST(DisjunctionTest, ShortCircuiting) {
120    EXPECT_TRUE(
121        (absl::disjunction<std::false_type, std::true_type, Dummy>::value));
122    EXPECT_TRUE((
123        std::is_base_of<MyTrueType, absl::disjunction<std::false_type, MyTrueType,
124                                                      std::true_type>>::value));
125    EXPECT_TRUE((
126        std::is_base_of<MyFalseType,
127                        absl::disjunction<std::false_type, MyFalseType>>::value));
128  }
129  TEST(NegationTest, BasicBooleanLogic) {
130    EXPECT_FALSE(absl::negation<std::true_type>::value);
131    EXPECT_FALSE(absl::negation<MyTrueType>::value);
132    EXPECT_TRUE(absl::negation<std::false_type>::value);
133    EXPECT_TRUE(absl::negation<MyFalseType>::value);
134  }
135  class Trivial {
136    int n_;
137  };
138  struct TrivialDestructor {
139    ~TrivialDestructor() = default;
140  };
141  struct NontrivialDestructor {
142    ~NontrivialDestructor() {}
143  };
144  struct DeletedDestructor {
145    ~DeletedDestructor() = delete;
146  };
147  class TrivialDefaultCtor {
148   public:
149    TrivialDefaultCtor() = default;
150    explicit TrivialDefaultCtor(int n) : n_(n) {}
151   private:
152    int n_;
153  };
154  class NontrivialDefaultCtor {
155   public:
156    NontrivialDefaultCtor() : n_(1) {}
157   private:
158    int n_;
159  };
160  class DeletedDefaultCtor {
161   public:
162    DeletedDefaultCtor() = delete;
163    explicit DeletedDefaultCtor(int n) : n_(n) {}
164   private:
165    int n_;
166  };
167  class TrivialMoveCtor {
168   public:
169    explicit TrivialMoveCtor(int n) : n_(n) {}
170    TrivialMoveCtor(TrivialMoveCtor&&) = default;
171    TrivialMoveCtor& operator=(const TrivialMoveCtor& t) {
172      n_ = t.n_;
173      return *this;
174    }
175   private:
176    int n_;
177  };
178  class NontrivialMoveCtor {
179   public:
180    explicit NontrivialMoveCtor(int n) : n_(n) {}
181    NontrivialMoveCtor(NontrivialMoveCtor&& t) noexcept : n_(t.n_) {}
182    NontrivialMoveCtor& operator=(const NontrivialMoveCtor&) = default;
183   private:
184    int n_;
185  };
186  class TrivialCopyCtor {
187   public:
188    explicit TrivialCopyCtor(int n) : n_(n) {}
189    TrivialCopyCtor(const TrivialCopyCtor&) = default;
190    TrivialCopyCtor& operator=(const TrivialCopyCtor& t) {
191      n_ = t.n_;
192      return *this;
193    }
194   private:
195    int n_;
196  };
197  class NontrivialCopyCtor {
198   public:
199    explicit NontrivialCopyCtor(int n) : n_(n) {}
200    NontrivialCopyCtor(const NontrivialCopyCtor& t) : n_(t.n_) {}
201    NontrivialCopyCtor& operator=(const NontrivialCopyCtor&) = default;
202   private:
203    int n_;
204  };
205  class DeletedCopyCtor {
206   public:
207    explicit DeletedCopyCtor(int n) : n_(n) {}
208    DeletedCopyCtor(const DeletedCopyCtor&) = delete;
209    DeletedCopyCtor& operator=(const DeletedCopyCtor&) = default;
210   private:
211    int n_;
212  };
213  class TrivialMoveAssign {
214   public:
215    explicit TrivialMoveAssign(int n) : n_(n) {}
216    TrivialMoveAssign(const TrivialMoveAssign& t) : n_(t.n_) {}
217    TrivialMoveAssign& operator=(TrivialMoveAssign&&) = default;
218    ~TrivialMoveAssign() {}  
219   private:
220    int n_;
221  };
222  class NontrivialMoveAssign {
223   public:
224    explicit NontrivialMoveAssign(int n) : n_(n) {}
225    NontrivialMoveAssign(const NontrivialMoveAssign&) = default;
226    NontrivialMoveAssign& operator=(NontrivialMoveAssign&& t) noexcept {
227      n_ = t.n_;
228      return *this;
229    }
230   private:
231    int n_;
232  };
233  class TrivialCopyAssign {
234   public:
235    explicit TrivialCopyAssign(int n) : n_(n) {}
236    TrivialCopyAssign(const TrivialCopyAssign& t) : n_(t.n_) {}
237    TrivialCopyAssign& operator=(const TrivialCopyAssign& t) = default;
238    ~TrivialCopyAssign() {}  
239   private:
240    int n_;
241  };
242  class NontrivialCopyAssign {
243   public:
244    explicit NontrivialCopyAssign(int n) : n_(n) {}
245    NontrivialCopyAssign(const NontrivialCopyAssign&) = default;
246    NontrivialCopyAssign& operator=(const NontrivialCopyAssign& t) {
<span onclick='openModal()' class='match'>247      n_ = t.n_;
248      return *this;
249    }
250   private:
251    int n_;
252  };
253  class DeletedCopyAssign {
254   public:
255    explicit DeletedCopyAssign(int n) : n_(n) {}
256    DeletedCopyAssign(const DeletedCopyAssign&) = default;
</span>257    DeletedCopyAssign& operator=(const DeletedCopyAssign&) = delete;
258   private:
259    int n_;
260  };
261  struct MovableNonCopyable {
262    MovableNonCopyable() = default;
263    MovableNonCopyable(const MovableNonCopyable&) = delete;
264    MovableNonCopyable(MovableNonCopyable&&) = default;
265    MovableNonCopyable& operator=(const MovableNonCopyable&) = delete;
266    MovableNonCopyable& operator=(MovableNonCopyable&&) = default;
267  };
268  struct NonCopyableOrMovable {
269    NonCopyableOrMovable() = default;
270    virtual ~NonCopyableOrMovable() = default;
271    NonCopyableOrMovable(const NonCopyableOrMovable&) = delete;
272    NonCopyableOrMovable(NonCopyableOrMovable&&) = delete;
273    NonCopyableOrMovable& operator=(const NonCopyableOrMovable&) = delete;
274    NonCopyableOrMovable& operator=(NonCopyableOrMovable&&) = delete;
275  };
276  class Base {
277   public:
278    virtual ~Base() {}
279  };
280  TEST(TypeTraitsTest, TestIsFunction) {
281    struct Callable {
282      void operator()() {}
283    };
284    EXPECT_TRUE(absl::is_function<void()>::value);
285    EXPECT_TRUE(absl::is_function<void()&>::value);
286    EXPECT_TRUE(absl::is_function<void() const>::value);
287    EXPECT_TRUE(absl::is_function<void() noexcept>::value);
288    EXPECT_TRUE(absl::is_function<void(...) noexcept>::value);
289    EXPECT_FALSE(absl::is_function<void(*)()>::value);
290    EXPECT_FALSE(absl::is_function<void(&)()>::value);
291    EXPECT_FALSE(absl::is_function<int>::value);
292    EXPECT_FALSE(absl::is_function<Callable>::value);
293  }
294  TEST(TypeTraitsTest, TestRemoveCVRef) {
295    EXPECT_TRUE(
296        (std::is_same<typename absl::remove_cvref<int>::type, int>::value));
297    EXPECT_TRUE(
298        (std::is_same<typename absl::remove_cvref<int&>::type, int>::value));
299    EXPECT_TRUE(
300        (std::is_same<typename absl::remove_cvref<int&&>::type, int>::value));
301    EXPECT_TRUE((
302        std::is_same<typename absl::remove_cvref<const int&>::type, int>::value));
303    EXPECT_TRUE(
304        (std::is_same<typename absl::remove_cvref<int*>::type, int*>::value));
305    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int*>::type,
306                              const int*>::value));
307    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<int[2]>::type,
308                              int[2]>::value));
309    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<int(&)[2]>::type,
310                              int[2]>::value));
311    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<int(&&)[2]>::type,
312                              int[2]>::value));
313    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int[2]>::type,
314                              int[2]>::value));
315    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int(&)[2]>::type,
316                              int[2]>::value));
317    EXPECT_TRUE((std::is_same<typename absl::remove_cvref<const int(&&)[2]>::type,
318                              int[2]>::value));
319  }
320  #define ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(trait_name, ...)          \
321    EXPECT_TRUE((std::is_same<typename std::trait_name<__VA_ARGS__>::type, \
322                              absl::trait_name##_t<__VA_ARGS__>>::value))
323  TEST(TypeTraitsTest, TestRemoveCVAliases) {
324    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, int);
325    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const int);
326    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, volatile int);
327    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const volatile int);
328    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, int);
329    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const int);
330    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, volatile int);
331    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const volatile int);
332    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, int);
333    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const int);
334    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, volatile int);
335    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const volatile int);
336  }
337  TEST(TypeTraitsTest, TestAddCVAliases) {
338    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, int);
339    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const int);
340    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, volatile int);
341    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const volatile int);
342    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, int);
343    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const int);
344    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, volatile int);
345    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const volatile int);
346    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, int);
347    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const int);
348    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, volatile int);
349    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const volatile int);
350  }
351  TEST(TypeTraitsTest, TestReferenceAliases) {
352    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int);
353    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int);
354    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&);
355    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&);
356    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&&);
357    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&&);
358    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int);
359    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int);
360    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&);
361    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&);
362    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&&);
363    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&&);
364    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int);
365    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int);
366    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&);
367    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&);
368    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&&);
369    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&&);
370  }
371  TEST(TypeTraitsTest, TestPointerAliases) {
372    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, int*);
373    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, volatile int*);
374    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, int);
375    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, volatile int);
376  }
377  TEST(TypeTraitsTest, TestSignednessAliases) {
378    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, int);
379    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile int);
380    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, unsigned);
381    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile unsigned);
382    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, int);
383    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile int);
384    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, unsigned);
385    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile unsigned);
386  }
387  TEST(TypeTraitsTest, TestExtentAliases) {
388    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[]);
389    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1]);
390    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1][1]);
391    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[][1]);
392    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[]);
393    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1]);
394    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1][1]);
395    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[][1]);
396  }
397  TEST(TypeTraitsTest, TestAlignedStorageAlias) {
398    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1);
399    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2);
400    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3);
401    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4);
402    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5);
403    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6);
404    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7);
405    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8);
406    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9);
407    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10);
408    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11);
409    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12);
410    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13);
411    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14);
412    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15);
413    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16);
414    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17);
415    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18);
416    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19);
417    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20);
418    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21);
419    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22);
420    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23);
421    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24);
422    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25);
423    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26);
424    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27);
425    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28);
426    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29);
427    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30);
428    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31);
429    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32);
430    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33);
431    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1, 128);
432    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2, 128);
433    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3, 128);
434    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4, 128);
435    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5, 128);
436    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6, 128);
437    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7, 128);
438    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8, 128);
439    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9, 128);
440    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10, 128);
441    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11, 128);
442    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12, 128);
443    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13, 128);
444    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14, 128);
445    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15, 128);
446    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16, 128);
447    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17, 128);
448    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18, 128);
449    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19, 128);
450    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20, 128);
451    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21, 128);
452    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22, 128);
453    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23, 128);
454    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24, 128);
455    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25, 128);
456    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26, 128);
457    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27, 128);
458    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28, 128);
459    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29, 128);
460    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30, 128);
461    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31, 128);
462    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32, 128);
463    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33, 128);
464  }
465  TEST(TypeTraitsTest, TestDecay) {
466    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int);
467    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int);
468    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int);
469    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int);
470    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&);
471    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&);
472    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&);
473    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&);
474    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&);
475    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&);
476    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&);
477    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&);
478    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1]);
479    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1][1]);
480    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[][1]);
481    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int());
482    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(float));  
483    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(char, ...));  
484  }
485  struct TypeA {};
486  struct TypeB {};
487  struct TypeC {};
488  struct TypeD {};
489  template <typename T>
490  struct Wrap {};
491  enum class TypeEnum { A, B, C, D };
492  struct GetTypeT {
493    template <typename T,
494              absl::enable_if_t<std::is_same<T, TypeA>::value, int> = 0>
495    TypeEnum operator()(Wrap<T>) const {
496      return TypeEnum::A;
497    }
498    template <typename T,
499              absl::enable_if_t<std::is_same<T, TypeB>::value, int> = 0>
500    TypeEnum operator()(Wrap<T>) const {
501      return TypeEnum::B;
502    }
503    template <typename T,
504              absl::enable_if_t<std::is_same<T, TypeC>::value, int> = 0>
505    TypeEnum operator()(Wrap<T>) const {
506      return TypeEnum::C;
507    }
508  } constexpr GetType = {};
509  TEST(TypeTraitsTest, TestEnableIf) {
510    EXPECT_EQ(TypeEnum::A, GetType(Wrap<TypeA>()));
511    EXPECT_EQ(TypeEnum::B, GetType(Wrap<TypeB>()));
512    EXPECT_EQ(TypeEnum::C, GetType(Wrap<TypeC>()));
513  }
514  TEST(TypeTraitsTest, TestConditional) {
515    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, true, int, char);
516    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, false, int, char);
517  }
518  TEST(TypeTraitsTest, TestCommonType) {
519    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int);
520    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char);
521    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int);
522    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int&);
523    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char&);
524    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int&);
525  }
526  TEST(TypeTraitsTest, TestUnderlyingType) {
527    enum class enum_char : char {};
528    enum class enum_long_long : long long {};  
529    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_char);
530    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_long_long);
531  }
532  struct GetTypeExtT {
533    template <typename T>
534    absl::result_of_t<const GetTypeT&(T)> operator()(T&& arg) const {
535      return GetType(std::forward<T>(arg));
536    }
537    TypeEnum operator()(Wrap<TypeD>) const { return TypeEnum::D; }
538  } constexpr GetTypeExt = {};
539  TEST(TypeTraitsTest, TestResultOf) {
540    EXPECT_EQ(TypeEnum::A, GetTypeExt(Wrap<TypeA>()));
541    EXPECT_EQ(TypeEnum::B, GetTypeExt(Wrap<TypeB>()));
542    EXPECT_EQ(TypeEnum::C, GetTypeExt(Wrap<TypeC>()));
543    EXPECT_EQ(TypeEnum::D, GetTypeExt(Wrap<TypeD>()));
544  }
545  namespace adl_namespace {
546  struct DeletedSwap {
547  };
548  void swap(DeletedSwap&, DeletedSwap&) = delete;
549  struct SpecialNoexceptSwap {
550    SpecialNoexceptSwap(SpecialNoexceptSwap&&) {}
551    SpecialNoexceptSwap& operator=(SpecialNoexceptSwap&&) { return *this; }
552    ~SpecialNoexceptSwap() = default;
553  };
554  void swap(SpecialNoexceptSwap&, SpecialNoexceptSwap&) noexcept {}
555  }  
556  TEST(TypeTraitsTest, IsSwappable) {
557    using absl::type_traits_internal::IsSwappable;
558    using absl::type_traits_internal::StdSwapIsUnconstrained;
559    EXPECT_TRUE(IsSwappable<int>::value);
560    struct S {};
561    EXPECT_TRUE(IsSwappable<S>::value);
562    struct NoConstruct {
563      NoConstruct(NoConstruct&&) = delete;
564      NoConstruct& operator=(NoConstruct&&) { return *this; }
565      ~NoConstruct() = default;
566    };
567    EXPECT_EQ(IsSwappable<NoConstruct>::value, StdSwapIsUnconstrained::value);
568    struct NoAssign {
569      NoAssign(NoAssign&&) {}
570      NoAssign& operator=(NoAssign&&) = delete;
571      ~NoAssign() = default;
572    };
573    EXPECT_EQ(IsSwappable<NoAssign>::value, StdSwapIsUnconstrained::value);
574    EXPECT_FALSE(IsSwappable<adl_namespace::DeletedSwap>::value);
575    EXPECT_TRUE(IsSwappable<adl_namespace::SpecialNoexceptSwap>::value);
576  }
577  TEST(TypeTraitsTest, IsNothrowSwappable) {
578    using absl::type_traits_internal::IsNothrowSwappable;
579    using absl::type_traits_internal::StdSwapIsUnconstrained;
580    EXPECT_TRUE(IsNothrowSwappable<int>::value);
581    struct NonNoexceptMoves {
582      NonNoexceptMoves(NonNoexceptMoves&&) {}
583      NonNoexceptMoves& operator=(NonNoexceptMoves&&) { return *this; }
584      ~NonNoexceptMoves() = default;
585    };
586    EXPECT_FALSE(IsNothrowSwappable<NonNoexceptMoves>::value);
587    struct NoConstruct {
588      NoConstruct(NoConstruct&&) = delete;
589      NoConstruct& operator=(NoConstruct&&) { return *this; }
590      ~NoConstruct() = default;
591    };
592    EXPECT_FALSE(IsNothrowSwappable<NoConstruct>::value);
593    struct NoAssign {
594      NoAssign(NoAssign&&) {}
595      NoAssign& operator=(NoAssign&&) = delete;
596      ~NoAssign() = default;
597    };
598    EXPECT_FALSE(IsNothrowSwappable<NoAssign>::value);
599    EXPECT_FALSE(IsNothrowSwappable<adl_namespace::DeletedSwap>::value);
600    EXPECT_TRUE(IsNothrowSwappable<adl_namespace::SpecialNoexceptSwap>::value);
601  }
602  TEST(TriviallyRelocatable, PrimitiveTypes) {
603    static_assert(absl::is_trivially_relocatable<int>::value, "");
604    static_assert(absl::is_trivially_relocatable<char>::value, "");
605    static_assert(absl::is_trivially_relocatable<void*>::value, "");
606  }
607  TEST(TriviallyRelocatable, UserDefinedTriviallyReconstructible) {
608    struct S {
609      int x;
610      int y;
611    };
612    static_assert(absl::is_trivially_relocatable<S>::value, "");
613  }
614  TEST(TriviallyRelocatable, UserProvidedMoveConstructor) {
615    struct S {
616      S(S&&) {}  
617    };
618    static_assert(!absl::is_trivially_relocatable<S>::value, "");
619  }
620  TEST(TriviallyRelocatable, UserProvidedCopyConstructor) {
621    struct S {
622      S(const S&) {}  
623    };
624    static_assert(!absl::is_trivially_relocatable<S>::value, "");
625  }
626  TEST(TriviallyRelocatable, UserProvidedDestructor) {
627    struct S {
628      ~S() {}  
629    };
630    static_assert(!absl::is_trivially_relocatable<S>::value, "");
631  }
632  #if defined(ABSL_HAVE_ATTRIBUTE_TRIVIAL_ABI) &&      \
633      ABSL_HAVE_BUILTIN(__is_trivially_relocatable) && \
634      !(defined(__clang__) && (defined(_WIN32) || defined(_WIN64)))
635  TEST(TrivallyRelocatable, TrivialAbi) {
636    struct ABSL_ATTRIBUTE_TRIVIAL_ABI S {
637      S(S&&) {}       
638      S(const S&) {}  
639      ~S() {}         
640    };
641    static_assert(absl::is_trivially_relocatable<S>::value, "");
642  }
643  #endif
644  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
645  constexpr int64_t NegateIfConstantEvaluated(int64_t i) {
646    if (absl::is_constant_evaluated()) {
647      return -i;
648    } else {
649      return i;
650    }
651  }
652  #endif  
653  TEST(TrivallyRelocatable, is_constant_evaluated) {
654  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
655    constexpr int64_t constant = NegateIfConstantEvaluated(42);
656    EXPECT_EQ(constant, -42);
657    int64_t now = absl::ToUnixSeconds(absl::Now());
658    int64_t not_constant = NegateIfConstantEvaluated(now);
659    EXPECT_EQ(not_constant, now);
660    static int64_t const_init = NegateIfConstantEvaluated(42);
661    EXPECT_EQ(const_init, -42);
662  #else
663    GTEST_SKIP() << "absl::is_constant_evaluated is not defined";
664  #endif  
665  }
666  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>227      n_ = t.n_;
228      return *this;
229    }
230   private:
231    int n_;
232  };
233  class TrivialCopyAssign {
234   public:
235    explicit TrivialCopyAssign(int n) : n_(n) {}
236    TrivialCopyAssign(const TrivialCopyAssign& t) : n_(t.n_) {}
</pre></code></div>
                <div class="column column_space"><pre><code>247      n_ = t.n_;
248      return *this;
249    }
250   private:
251    int n_;
252  };
253  class DeletedCopyAssign {
254   public:
255    explicit DeletedCopyAssign(int n) : n_(n) {}
256    DeletedCopyAssign(const DeletedCopyAssign&) = default;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    