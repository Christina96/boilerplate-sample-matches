
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_4.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_VARIANT_H_
2  #define ABSL_TYPES_INTERNAL_VARIANT_H_
3  #include <cassert>
4  #include <cstddef>
5  #include <cstdlib>
6  #include <memory>
7  #include <stdexcept>
8  #include <tuple>
9  #include <type_traits>
10  #include "absl/base/config.h"
11  #include "absl/base/internal/identity.h"
12  #include "absl/base/internal/inline_variable.h"
13  #include "absl/base/internal/invoke.h"
14  #include "absl/base/macros.h"
15  #include "absl/base/optimization.h"
16  #include "absl/meta/type_traits.h"
17  #include "absl/types/bad_variant_access.h"
18  #include "absl/utility/utility.h"
19  #if !defined(ABSL_USES_STD_VARIANT)
20  namespace absl {
21  ABSL_NAMESPACE_BEGIN
22  template <class... Types>
23  class variant;
24  ABSL_INTERNAL_INLINE_CONSTEXPR(size_t, variant_npos, static_cast<size_t>(-1));
25  template <class T>
26  struct variant_size;
27  template <std::size_t I, class T>
28  struct variant_alternative;
29  namespace variant_internal {
30  template <std::size_t I, class T>
31  struct VariantAlternativeSfinae {};
32  template <std::size_t I, class T0, class... Tn>
33  struct VariantAlternativeSfinae<I, variant<T0, Tn...>>
34      : VariantAlternativeSfinae<I - 1, variant<Tn...>> {};
35  template <class T0, class... Ts>
36  struct VariantAlternativeSfinae<0, variant<T0, Ts...>> {
37    using type = T0;
38  };
39  template <std::size_t I, class T>
40  using VariantAlternativeSfinaeT = typename VariantAlternativeSfinae<I, T>::type;
41  template <class T, class U>
42  struct GiveQualsTo;
43  template <class T, class U>
44  struct GiveQualsTo<T&, U> {
45    using type = U&;
46  };
47  template <class T, class U>
48  struct GiveQualsTo<T&&, U> {
49    using type = U&&;
50  };
51  template <class T, class U>
52  struct GiveQualsTo<const T&, U> {
53    using type = const U&;
54  };
55  template <class T, class U>
56  struct GiveQualsTo<const T&&, U> {
57    using type = const U&&;
58  };
59  template <class T, class U>
60  struct GiveQualsTo<volatile T&, U> {
61    using type = volatile U&;
62  };
63  template <class T, class U>
64  struct GiveQualsTo<volatile T&&, U> {
65    using type = volatile U&&;
66  };
67  template <class T, class U>
68  struct GiveQualsTo<volatile const T&, U> {
69    using type = volatile const U&;
70  };
71  template <class T, class U>
72  struct GiveQualsTo<volatile const T&&, U> {
73    using type = volatile const U&&;
74  };
75  template <class T, class U>
76  using GiveQualsToT = typename GiveQualsTo<T, U>::type;
77  template <std::size_t I>
78  using SizeT = std::integral_constant<std::size_t, I>;
79  using NPos = SizeT<variant_npos>;
80  template <class Variant, class T, class = void>
81  struct IndexOfConstructedType {};
82  template <std::size_t I, class Variant>
83  struct VariantAccessResultImpl;
84  template <std::size_t I, template <class...> class Variantemplate, class... T>
85  struct VariantAccessResultImpl<I, Variantemplate<T...>&> {
86    using type = typename absl::variant_alternative<I, variant<T...>>::type&;
87  };
88  template <std::size_t I, template <class...> class Variantemplate, class... T>
89  struct VariantAccessResultImpl<I, const Variantemplate<T...>&> {
90    using type =
91        const typename absl::variant_alternative<I, variant<T...>>::type&;
92  };
93  template <std::size_t I, template <class...> class Variantemplate, class... T>
94  struct VariantAccessResultImpl<I, Variantemplate<T...>&&> {
95    using type = typename absl::variant_alternative<I, variant<T...>>::type&&;
96  };
97  template <std::size_t I, template <class...> class Variantemplate, class... T>
98  struct VariantAccessResultImpl<I, const Variantemplate<T...>&&> {
99    using type =
100        const typename absl::variant_alternative<I, variant<T...>>::type&&;
101  };
102  template <std::size_t I, class Variant>
103  using VariantAccessResult =
104      typename VariantAccessResultImpl<I, Variant&&>::type;
105  template <class T, std::size_t Size>
106  struct SimpleArray {
107    static_assert(Size != 0, "");
108    T value[Size];
109  };
110  template <class T>
111  struct AccessedType {
112    using type = T;
113  };
114  template <class T>
115  using AccessedTypeT = typename AccessedType<T>::type;
116  template <class T, std::size_t Size>
117  struct AccessedType<SimpleArray<T, Size>> {
118    using type = AccessedTypeT<T>;
119  };
120  template <class T>
121  constexpr T AccessSimpleArray(const T& value) {
122    return value;
123  }
124  template <class T, std::size_t Size, class... SizeT>
125  constexpr AccessedTypeT<T> AccessSimpleArray(const SimpleArray<T, Size>& table,
126                                               std::size_t head_index,
127                                               SizeT... tail_indices) {
128    return AccessSimpleArray(table.value[head_index], tail_indices...);
129  }
130  template <class T>
131  using AlwaysZero = SizeT<0>;
132  template <class Op, class... Vs>
133  struct VisitIndicesResultImpl {
134    using type = absl::result_of_t<Op(AlwaysZero<Vs>...)>;
135  };
136  template <class Op, class... Vs>
137  using VisitIndicesResultT = typename VisitIndicesResultImpl<Op, Vs...>::type;
138  template <class ReturnType, class FunctionObject, class EndIndices,
139            class BoundIndices>
140  struct MakeVisitationMatrix;
141  template <class ReturnType, class FunctionObject, std::size_t... Indices>
142  constexpr ReturnType call_with_indices(FunctionObject&& function) {
143    static_assert(
144        std::is_same<ReturnType, decltype(std::declval<FunctionObject>()(
145                                     SizeT<Indices>()...))>::value,
146        "Not all visitation overloads have the same return type.");
147    return absl::forward<FunctionObject>(function)(SizeT<Indices>()...);
148  }
149  template <class ReturnType, class FunctionObject, std::size_t... BoundIndices>
150  struct MakeVisitationMatrix<ReturnType, FunctionObject, index_sequence<>,
151                              index_sequence<BoundIndices...>> {
152    using ResultType = ReturnType (*)(FunctionObject&&);
153    static constexpr ResultType Run() {
154      return &call_with_indices<ReturnType, FunctionObject,
155                                (BoundIndices - 1)...>;
156    }
157  };
158  template <typename Is, std::size_t J>
159  struct AppendToIndexSequence;
160  template <typename Is, std::size_t J>
161  using AppendToIndexSequenceT = typename AppendToIndexSequence<Is, J>::type;
162  template <std::size_t... Is, std::size_t J>
163  struct AppendToIndexSequence<index_sequence<Is...>, J> {
164    using type = index_sequence<Is..., J>;
165  };
166  template <class ReturnType, class FunctionObject, class EndIndices,
167            class CurrIndices, class BoundIndices>
168  struct MakeVisitationMatrixImpl;
169  template <class ReturnType, class FunctionObject, class EndIndices,
170            std::size_t... CurrIndices, class BoundIndices>
171  struct MakeVisitationMatrixImpl<ReturnType, FunctionObject, EndIndices,
172                                  index_sequence<CurrIndices...>, BoundIndices> {
173    using ResultType = SimpleArray<
174        typename MakeVisitationMatrix<ReturnType, FunctionObject, EndIndices,
175                                      index_sequence<>>::ResultType,
176        sizeof...(CurrIndices)>;
177    static constexpr ResultType Run() {
178      return {{MakeVisitationMatrix<
179          ReturnType, FunctionObject, EndIndices,
180          AppendToIndexSequenceT<BoundIndices, CurrIndices>>::Run()...}};
181    }
182  };
183  template <class ReturnType, class FunctionObject, std::size_t HeadEndIndex,
184            std::size_t... TailEndIndices, std::size_t... BoundIndices>
185  struct MakeVisitationMatrix<ReturnType, FunctionObject,
186                              index_sequence<HeadEndIndex, TailEndIndices...>,
187                              index_sequence<BoundIndices...>>
188      : MakeVisitationMatrixImpl<ReturnType, FunctionObject,
189                                 index_sequence<TailEndIndices...>,
190                                 absl::make_index_sequence<HeadEndIndex>,
191                                 index_sequence<BoundIndices...>> {};
192  struct UnreachableSwitchCase {
193    template <class Op>
194    [[noreturn]] static VisitIndicesResultT<Op, std::size_t> Run(
195        Op&& &bsol;*ignored*/) {
196  #if ABSL_HAVE_BUILTIN(__builtin_unreachable) || \
197      (defined(__GNUC__) && !defined(__clang__))
198      __builtin_unreachable();
199  #elif defined(_MSC_VER)
200      __assume(false);
201  #else
202      assert(false);  
203      return Run(absl::forward<Op>(op));
204  #endif  
205    }
206  };
207  template <class Op, std::size_t I>
208  struct ReachableSwitchCase {
209    static VisitIndicesResultT<Op, std::size_t> Run(Op&& op) {
210      return absl::base_internal::invoke(absl::forward<Op>(op), SizeT<I>());
211    }
212  };
213  ABSL_INTERNAL_INLINE_CONSTEXPR(std::size_t, MaxUnrolledVisitCases, 33);
214  template <bool IsReachable>
215  struct PickCaseImpl {
216    template <class Op, std::size_t I>
217    using Apply = UnreachableSwitchCase;
218  };
219  template <>
220  struct PickCaseImpl<&bsol;*IsReachable =*/true> {
221    template <class Op, std::size_t I>
222    using Apply = ReachableSwitchCase<Op, I>;
223  };
224  template <class Op, std::size_t I, std::size_t EndIndex>
225  using PickCase = typename PickCaseImpl<(I < EndIndex)>::template Apply<Op, I>;
226  template <class ReturnType>
227  [[noreturn]] ReturnType TypedThrowBadVariantAccess() {
228    absl::variant_internal::ThrowBadVariantAccess();
229  }
230  template <std::size_t... NumAlternatives>
231  struct NumCasesOfSwitch;
232  template <std::size_t HeadNumAlternatives, std::size_t... TailNumAlternatives>
233  struct NumCasesOfSwitch<HeadNumAlternatives, TailNumAlternatives...> {
234    static constexpr std::size_t value =
235        (HeadNumAlternatives + 1) *
236        NumCasesOfSwitch<TailNumAlternatives...>::value;
237  };
238  template <>
239  struct NumCasesOfSwitch<> {
240    static constexpr std::size_t value = 1;
241  };
242  template <std::size_t EndIndex>
243  struct VisitIndicesSwitch {
244    static_assert(EndIndex <= MaxUnrolledVisitCases,
245                  "Maximum unrolled switch size exceeded.");
246    template <class Op>
247    static VisitIndicesResultT<Op, std::size_t> Run(Op&& op, std::size_t i) {
248      switch (i) {
249        case 0:
250          return PickCase<Op, 0, EndIndex>::Run(absl::forward<Op>(op));
251        case 1:
252          return PickCase<Op, 1, EndIndex>::Run(absl::forward<Op>(op));
253        case 2:
254          return PickCase<Op, 2, EndIndex>::Run(absl::forward<Op>(op));
255        case 3:
256          return PickCase<Op, 3, EndIndex>::Run(absl::forward<Op>(op));
257        case 4:
258          return PickCase<Op, 4, EndIndex>::Run(absl::forward<Op>(op));
259        case 5:
260          return PickCase<Op, 5, EndIndex>::Run(absl::forward<Op>(op));
261        case 6:
262          return PickCase<Op, 6, EndIndex>::Run(absl::forward<Op>(op));
263        case 7:
264          return PickCase<Op, 7, EndIndex>::Run(absl::forward<Op>(op));
265        case 8:
266          return PickCase<Op, 8, EndIndex>::Run(absl::forward<Op>(op));
267        case 9:
268          return PickCase<Op, 9, EndIndex>::Run(absl::forward<Op>(op));
269        case 10:
270          return PickCase<Op, 10, EndIndex>::Run(absl::forward<Op>(op));
271        case 11:
272          return PickCase<Op, 11, EndIndex>::Run(absl::forward<Op>(op));
273        case 12:
274          return PickCase<Op, 12, EndIndex>::Run(absl::forward<Op>(op));
275        case 13:
276          return PickCase<Op, 13, EndIndex>::Run(absl::forward<Op>(op));
277        case 14:
278          return PickCase<Op, 14, EndIndex>::Run(absl::forward<Op>(op));
279        case 15:
280          return PickCase<Op, 15, EndIndex>::Run(absl::forward<Op>(op));
281        case 16:
282          return PickCase<Op, 16, EndIndex>::Run(absl::forward<Op>(op));
283        case 17:
284          return PickCase<Op, 17, EndIndex>::Run(absl::forward<Op>(op));
285        case 18:
286          return PickCase<Op, 18, EndIndex>::Run(absl::forward<Op>(op));
287        case 19:
288          return PickCase<Op, 19, EndIndex>::Run(absl::forward<Op>(op));
289        case 20:
290          return PickCase<Op, 20, EndIndex>::Run(absl::forward<Op>(op));
291        case 21:
292          return PickCase<Op, 21, EndIndex>::Run(absl::forward<Op>(op));
293        case 22:
294          return PickCase<Op, 22, EndIndex>::Run(absl::forward<Op>(op));
295        case 23:
296          return PickCase<Op, 23, EndIndex>::Run(absl::forward<Op>(op));
297        case 24:
298          return PickCase<Op, 24, EndIndex>::Run(absl::forward<Op>(op));
299        case 25:
300          return PickCase<Op, 25, EndIndex>::Run(absl::forward<Op>(op));
301        case 26:
302          return PickCase<Op, 26, EndIndex>::Run(absl::forward<Op>(op));
303        case 27:
304          return PickCase<Op, 27, EndIndex>::Run(absl::forward<Op>(op));
305        case 28:
306          return PickCase<Op, 28, EndIndex>::Run(absl::forward<Op>(op));
307        case 29:
308          return PickCase<Op, 29, EndIndex>::Run(absl::forward<Op>(op));
309        case 30:
310          return PickCase<Op, 30, EndIndex>::Run(absl::forward<Op>(op));
311        case 31:
312          return PickCase<Op, 31, EndIndex>::Run(absl::forward<Op>(op));
313        case 32:
314          return PickCase<Op, 32, EndIndex>::Run(absl::forward<Op>(op));
315        default:
316          ABSL_ASSERT(i == variant_npos);
317          return absl::base_internal::invoke(absl::forward<Op>(op), NPos());
318      }
319    }
320  };
321  template <std::size_t... EndIndices>
322  struct VisitIndicesFallback {
323    template <class Op, class... SizeT>
324    static VisitIndicesResultT<Op, SizeT...> Run(Op&& op, SizeT... indices) {
325      return AccessSimpleArray(
326          MakeVisitationMatrix<VisitIndicesResultT<Op, SizeT...>, Op,
327                               index_sequence<(EndIndices + 1)...>,
328                               index_sequence<>>::Run(),
329          (indices + 1)...)(absl::forward<Op>(op));
330    }
331  };
332  template <std::size_t...>
333  struct FlattenIndices;
334  template <std::size_t HeadSize, std::size_t... TailSize>
335  struct FlattenIndices<HeadSize, TailSize...> {
336    template <class... SizeType>
337    static constexpr std::size_t Run(std::size_t head, SizeType... tail) {
338      return head + HeadSize * FlattenIndices<TailSize...>::Run(tail...);
339    }
340  };
341  template <>
342  struct FlattenIndices<> {
343    static constexpr std::size_t Run() { return 0; }
344  };
345  template <std::size_t I, std::size_t IndexToGet, std::size_t HeadSize,
346            std::size_t... TailSize>
347  struct UnflattenIndex {
348    static constexpr std::size_t value =
349        UnflattenIndex<I / HeadSize, IndexToGet - 1, TailSize...>::value;
350  };
351  template <std::size_t I, std::size_t HeadSize, std::size_t... TailSize>
352  struct UnflattenIndex<I, 0, HeadSize, TailSize...> {
353    static constexpr std::size_t value = (I % HeadSize);
354  };
355  template <class IndexSequence, std::size_t... EndIndices>
356  struct VisitIndicesVariadicImpl;
357  template <std::size_t... N, std::size_t... EndIndices>
358  struct VisitIndicesVariadicImpl<absl::index_sequence<N...>, EndIndices...> {
359    template <class Op>
360    struct FlattenedOp {
361      template <std::size_t I>
362      VisitIndicesResultT<Op, decltype(EndIndices)...> operator()(
363          SizeT<I> &bsol;*index*/) && {
364        return base_internal::invoke(
365            absl::forward<Op>(op),
366            SizeT<UnflattenIndex<I, N, (EndIndices + 1)...>::value -
367                  std::size_t{1}>()...);
368      }
369      Op&& op;
370    };
371    template <class Op, class... SizeType>
372    static VisitIndicesResultT<Op, decltype(EndIndices)...> Run(Op&& op,
373                                                                SizeType... i) {
374      return VisitIndicesSwitch<NumCasesOfSwitch<EndIndices...>::value>::Run(
375          FlattenedOp<Op>{absl::forward<Op>(op)},
376          FlattenIndices<(EndIndices + std::size_t{1})...>::Run(
377              (i + std::size_t{1})...));
378    }
379  };
380  template <std::size_t... EndIndices>
381  struct VisitIndicesVariadic
382      : VisitIndicesVariadicImpl<absl::make_index_sequence<sizeof...(EndIndices)>,
383                                 EndIndices...> {};
384  template <std::size_t... EndIndices>
385  struct VisitIndices
386      : absl::conditional_t<(NumCasesOfSwitch<EndIndices...>::value <=
387                             MaxUnrolledVisitCases),
388                            VisitIndicesVariadic<EndIndices...>,
389                            VisitIndicesFallback<EndIndices...>> {};
390  template <std::size_t EndIndex>
391  struct VisitIndices<EndIndex>
392      : absl::conditional_t<(EndIndex <= MaxUnrolledVisitCases),
393                            VisitIndicesSwitch<EndIndex>,
394                            VisitIndicesFallback<EndIndex>> {};
395  #ifdef _MSC_VER
396  #pragma warning(push)
397  #pragma warning(disable : 4172)
398  #endif  
399  template <class Self, std::size_t I>
400  inline VariantAccessResult<I, Self> AccessUnion(Self&& self, SizeT<I> &bsol;*i*/) {
401    return reinterpret_cast<VariantAccessResult<I, Self>>(self);
402  }
403  #ifdef _MSC_VER
404  #pragma warning(pop)
405  #endif  
406  template <class T>
407  void DeducedDestroy(T& self) {  
408    self.~T();
409  }
410  struct VariantCoreAccess {
411    template <class VariantType>
412    static typename VariantType::Variant& Derived(VariantType& self) {  
413      return static_cast<typename VariantType::Variant&>(self);
414    }
415    template <class VariantType>
416    static const typename VariantType::Variant& Derived(
417        const VariantType& self) {  
418      return static_cast<const typename VariantType::Variant&>(self);
419    }
420    template <class VariantType>
421    static void Destroy(VariantType& self) {  
422      Derived(self).destroy();
423      self.index_ = absl::variant_npos;
424    }
425    template <class Variant>
426    static void SetIndex(Variant& self, std::size_t i) {  
427      self.index_ = i;
428    }
429    template <class Variant>
430    static void InitFrom(Variant& self, Variant&& other) {  
431      VisitIndices<absl::variant_size<Variant>::value>::Run(
432          InitFromVisitor<Variant, Variant&&>{&self,
433                                              std::forward<Variant>(other)},
434          other.index());
435      self.index_ = other.index();
436    }
437    template <std::size_t I, class Variant>
438    static VariantAccessResult<I, Variant> Access(Variant&& self) {
439      return static_cast<VariantAccessResult<I, Variant>>(
440          variant_internal::AccessUnion(self.state_, SizeT<I>()));
441    }
442    template <std::size_t I, class Variant>
443    static VariantAccessResult<I, Variant> CheckedAccess(Variant&& self) {
444      if (ABSL_PREDICT_FALSE(self.index_ != I)) {
445        TypedThrowBadVariantAccess<VariantAccessResult<I, Variant>>();
446      }
447      return Access<I>(absl::forward<Variant>(self));
448    }
449    template <class VType>
450    struct MoveAssignVisitor {
451      using DerivedType = typename VType::Variant;
452      template <std::size_t NewIndex>
453      void operator()(SizeT<NewIndex> &bsol;*new_i*/) const {
454        if (left->index_ == NewIndex) {
455          Access<NewIndex>(*left) = std::move(Access<NewIndex>(*right));
456        } else {
457          Derived(*left).template emplace<NewIndex>(
458              std::move(Access<NewIndex>(*right)));
459        }
460      }
461      void operator()(SizeT<absl::variant_npos> &bsol;*new_i*/) const {
462        Destroy(*left);
463      }
464      VType* left;
465      VType* right;
466    };
467    template <class VType>
468    static MoveAssignVisitor<VType> MakeMoveAssignVisitor(VType* left,
469                                                          VType* other) {
470      return {left, other};
471    }
472    template <class VType>
473    struct CopyAssignVisitor {
474      using DerivedType = typename VType::Variant;
475      template <std::size_t NewIndex>
476      void operator()(SizeT<NewIndex> &bsol;*new_i*/) const {
477        using New =
478            typename absl::variant_alternative<NewIndex, DerivedType>::type;
479        if (left->index_ == NewIndex) {
480          Access<NewIndex>(*left) = Access<NewIndex>(*right);
481        } else if (std::is_nothrow_copy_constructible<New>::value ||
482                   !std::is_nothrow_move_constructible<New>::value) {
483          Derived(*left).template emplace<NewIndex>(Access<NewIndex>(*right));
484        } else {
485          Derived(*left) = DerivedType(Derived(*right));
486        }
487      }
488      void operator()(SizeT<absl::variant_npos> &bsol;*new_i*/) const {
489        Destroy(*left);
490      }
491      VType* left;
492      const VType* right;
493    };
494    template <class VType>
495    static CopyAssignVisitor<VType> MakeCopyAssignVisitor(VType* left,
496                                                          const VType& other) {
497      return {left, &other};
498    }
499    template <class Left, class QualifiedNew>
500    struct ConversionAssignVisitor {
501      using NewIndex =
502          variant_internal::IndexOfConstructedType<Left, QualifiedNew>;
503      void operator()(SizeT<NewIndex::value> &bsol;*old_i*/
504      ) const {
505        Access<NewIndex::value>(*left) = absl::forward<QualifiedNew>(other);
506      }
507      template <std::size_t OldIndex>
508      void operator()(SizeT<OldIndex> &bsol;*old_i*/
509      ) const {
510        using New =
511            typename absl::variant_alternative<NewIndex::value, Left>::type;
512        if (std::is_nothrow_constructible<New, QualifiedNew>::value ||
513            !std::is_nothrow_move_constructible<New>::value) {
514          left->template emplace<NewIndex::value>(
515              absl::forward<QualifiedNew>(other));
516        } else {
517          left->template emplace<NewIndex::value>(
518              New(absl::forward<QualifiedNew>(other)));
519        }
520      }
521      Left* left;
522      QualifiedNew&& other;
523    };
524    template <class Left, class QualifiedNew>
525    static ConversionAssignVisitor<Left, QualifiedNew>
526    MakeConversionAssignVisitor(Left* left, QualifiedNew&& qual) {
527      return {left, absl::forward<QualifiedNew>(qual)};
528    }
529    template <std::size_t NewIndex, class Self, class... Args>
530    static typename absl::variant_alternative<NewIndex, Self>::type& Replace(
531        Self* self, Args&&... args) {
532      Destroy(*self);
533      using New = typename absl::variant_alternative<NewIndex, Self>::type;
534      New* const result = ::new (static_cast<void*>(&self->state_))
535          New(absl::forward<Args>(args)...);
536      self->index_ = NewIndex;
537      return *result;
538    }
539    template <class LeftVariant, class QualifiedRightVariant>
540    struct InitFromVisitor {
541      template <std::size_t NewIndex>
542      void operator()(SizeT<NewIndex> &bsol;*new_i*/) const {
543        using Alternative =
544            typename variant_alternative<NewIndex, LeftVariant>::type;
545        ::new (static_cast<void*>(&left->state_)) Alternative(
546            Access<NewIndex>(std::forward<QualifiedRightVariant>(right)));
547      }
548      void operator()(SizeT<absl::variant_npos> &bsol;*new_i*/) const {
549      }
550      LeftVariant* left;
551      QualifiedRightVariant&& right;
552    };
553  };
554  template <class Expected, class... T>
555  struct IndexOfImpl;
556  template <class Expected>
557  struct IndexOfImpl<Expected> {
558    using IndexFromEnd = SizeT<0>;
559    using MatchedIndexFromEnd = IndexFromEnd;
560    using MultipleMatches = std::false_type;
561  };
562  template <class Expected, class Head, class... Tail>
563  struct IndexOfImpl<Expected, Head, Tail...> : IndexOfImpl<Expected, Tail...> {
564    using IndexFromEnd =
565        SizeT<IndexOfImpl<Expected, Tail...>::IndexFromEnd::value + 1>;
566  };
567  template <class Expected, class... Tail>
568  struct IndexOfImpl<Expected, Expected, Tail...>
569      : IndexOfImpl<Expected, Tail...> {
570    using IndexFromEnd =
571        SizeT<IndexOfImpl<Expected, Tail...>::IndexFromEnd::value + 1>;
572    using MatchedIndexFromEnd = IndexFromEnd;
573    using MultipleMatches = std::integral_constant<
574        bool, IndexOfImpl<Expected, Tail...>::MatchedIndexFromEnd::value != 0>;
575  };
576  template <class Expected, class... Types>
577  struct IndexOfMeta {
578    using Results = IndexOfImpl<Expected, Types...>;
579    static_assert(!Results::MultipleMatches::value,
580                  "Attempted to access a variant by specifying a type that "
581                  "matches more than one alternative.");
582    static_assert(Results::MatchedIndexFromEnd::value != 0,
583                  "Attempted to access a variant by specifying a type that does "
584                  "not match any alternative.");
585    using type = SizeT<sizeof...(Types) - Results::MatchedIndexFromEnd::value>;
586  };
587  template <class Expected, class... Types>
588  using IndexOf = typename IndexOfMeta<Expected, Types...>::type;
589  template <class Variant, class T, std::size_t CurrIndex>
590  struct UnambiguousIndexOfImpl;
591  template <class T, std::size_t CurrIndex>
592  struct UnambiguousIndexOfImpl<variant<>, T, CurrIndex> : SizeT<CurrIndex> {};
593  template <class Head, class... Tail, class T, std::size_t CurrIndex>
594  struct UnambiguousIndexOfImpl<variant<Head, Tail...>, T, CurrIndex>
595      : UnambiguousIndexOfImpl<variant<Tail...>, T, CurrIndex + 1>::type {};
596  template <class Head, class... Tail, std::size_t CurrIndex>
597  struct UnambiguousIndexOfImpl<variant<Head, Tail...>, Head, CurrIndex>
598      : SizeT<UnambiguousIndexOfImpl<variant<Tail...>, Head, 0>::value ==
599                      sizeof...(Tail)
600                  ? CurrIndex
601                  : CurrIndex + sizeof...(Tail) + 1> {};
602  template <class Variant, class T>
603  struct UnambiguousIndexOf;
604  struct NoMatch {
605    struct type {};
606  };
607  template <class... Alts, class T>
608  struct UnambiguousIndexOf<variant<Alts...>, T>
609      : std::conditional<UnambiguousIndexOfImpl<variant<Alts...>, T, 0>::value !=
610                             sizeof...(Alts),
611                         UnambiguousIndexOfImpl<variant<Alts...>, T, 0>,
612                         NoMatch>::type::type {};
613  template <class T, std::size_t &bsol;*Dummy*/>
614  using UnambiguousTypeOfImpl = T;
615  template <class Variant, class T>
616  using UnambiguousTypeOfT =
617      UnambiguousTypeOfImpl<T, UnambiguousIndexOf<Variant, T>::value>;
618  template <class H, class... T>
619  class VariantStateBase;
620  template <class Variant, std::size_t I = 0>
621  struct ImaginaryFun;
622  template <std::size_t I>
623  struct ImaginaryFun<variant<>, I> {
624    static void Run() = delete;
625  };
626  template <class H, class... T, std::size_t I>
627  struct ImaginaryFun<variant<H, T...>, I> : ImaginaryFun<variant<T...>, I + 1> {
628    using ImaginaryFun<variant<T...>, I + 1>::Run;
629    static SizeT<I> Run(const H&, SizeT<I>);
630    static SizeT<I> Run(H&&, SizeT<I>);
631  };
632  template <class Self, class T>
633  struct IsNeitherSelfNorInPlace : std::true_type {};
634  template <class Self>
635  struct IsNeitherSelfNorInPlace<Self, Self> : std::false_type {};
636  template <class Self, class T>
637  struct IsNeitherSelfNorInPlace<Self, in_place_type_t<T>> : std::false_type {};
638  template <class Self, std::size_t I>
639  struct IsNeitherSelfNorInPlace<Self, in_place_index_t<I>> : std::false_type {};
640  template <class Variant, class T>
641  struct IndexOfConstructedType<
642      Variant, T,
643      void_t<decltype(ImaginaryFun<Variant>::Run(std::declval<T>(), {}))>>
644      : decltype(ImaginaryFun<Variant>::Run(std::declval<T>(), {})) {};
645  template <std::size_t... Is>
646  struct ContainsVariantNPos
647      : absl::negation<std::is_same<  
648            std::integer_sequence<bool, 0 <= Is...>,
649            std::integer_sequence<bool, Is != absl::variant_npos...>>> {};
650  template <class Op, class... QualifiedVariants>
651  using RawVisitResult =
652      absl::result_of_t<Op(VariantAccessResult<0, QualifiedVariants>...)>;
653  template <class Op, class... QualifiedVariants>
654  struct VisitResultImpl {
655    using type =
656        absl::result_of_t<Op(VariantAccessResult<0, QualifiedVariants>...)>;
657  };
658  template <class Op, class... QualifiedVariants>
659  using VisitResult = typename VisitResultImpl<Op, QualifiedVariants...>::type;
660  template <class Op, class... QualifiedVariants>
661  struct PerformVisitation {
662    using ReturnType = VisitResult<Op, QualifiedVariants...>;
663    template <std::size_t... Is>
664    constexpr ReturnType operator()(SizeT<Is>... indices) const {
665      return Run(typename ContainsVariantNPos<Is...>::type{},
666                 absl::index_sequence_for<QualifiedVariants...>(), indices...);
667    }
668    template <std::size_t... TupIs, std::size_t... Is>
669    constexpr ReturnType Run(std::false_type &bsol;*has_valueless*/,
670                             index_sequence<TupIs...>, SizeT<Is>...) const {
671      static_assert(
672          std::is_same<ReturnType,
673                       absl::result_of_t<Op(VariantAccessResult<
674                                            Is, QualifiedVariants>...)>>::value,
675          "All visitation overloads must have the same return type.");
676      return absl::base_internal::invoke(
677          absl::forward<Op>(op),
678          VariantCoreAccess::Access<Is>(
679              absl::forward<QualifiedVariants>(std::get<TupIs>(variant_tup)))...);
680    }
681    template <std::size_t... TupIs, std::size_t... Is>
682    [[noreturn]] ReturnType Run(std::true_type &bsol;*has_valueless*/,
683                                index_sequence<TupIs...>, SizeT<Is>...) const {
684      absl::variant_internal::ThrowBadVariantAccess();
685    }
686    std::tuple<QualifiedVariants&&...> variant_tup;
687    Op&& op;
688  };
689  template <class... T>
690  union Union;
691  struct NoopConstructorTag {};
692  template <std::size_t I>
693  struct EmplaceTag {};
694  template <>
695  union Union<> {
696    constexpr explicit Union(NoopConstructorTag) noexcept {}
697  };
698  #ifdef _MSC_VER
699  #pragma warning(push)
700  #pragma warning(disable : 4624)
701  #endif  
702  template <class Head, class... Tail>
703  union Union<Head, Tail...> {
704    using TailUnion = Union<Tail...>;
705    explicit constexpr Union(NoopConstructorTag &bsol;*tag*/) noexcept
706        : tail(NoopConstructorTag()) {}
707    template <class... P>
708    explicit constexpr Union(EmplaceTag<0>, P&&... args)
709        : head(absl::forward<P>(args)...) {}
710    template <std::size_t I, class... P>
711    explicit constexpr Union(EmplaceTag<I>, P&&... args)
712        : tail(EmplaceTag<I - 1>{}, absl::forward<P>(args)...) {}
713    Head head;
714    TailUnion tail;
715  };
716  #ifdef _MSC_VER
717  #pragma warning(pop)
718  #endif  
719  template <class... T>
720  union DestructibleUnionImpl;
721  template <>
722  union DestructibleUnionImpl<> {
723    constexpr explicit DestructibleUnionImpl(NoopConstructorTag) noexcept {}
724  };
725  template <class Head, class... Tail>
726  union DestructibleUnionImpl<Head, Tail...> {
727    using TailUnion = DestructibleUnionImpl<Tail...>;
728    explicit constexpr DestructibleUnionImpl(NoopConstructorTag &bsol;*tag*/) noexcept
729        : tail(NoopConstructorTag()) {}
730    template <class... P>
731    explicit constexpr DestructibleUnionImpl(EmplaceTag<0>, P&&... args)
732        : head(absl::forward<P>(args)...) {}
733    template <std::size_t I, class... P>
734    explicit constexpr DestructibleUnionImpl(EmplaceTag<I>, P&&... args)
735        : tail(EmplaceTag<I - 1>{}, absl::forward<P>(args)...) {}
736    ~DestructibleUnionImpl() {}
737    Head head;
738    TailUnion tail;
739  };
740  template <class... T>
741  using DestructibleUnion =
742      absl::conditional_t<std::is_destructible<Union<T...>>::value, Union<T...>,
743                          DestructibleUnionImpl<T...>>;
744  template <class H, class... T>
745  class VariantStateBase {
746   protected:
747    using Variant = variant<H, T...>;
748    template <class LazyH = H,
749              class ConstructibleH = absl::enable_if_t<
750                  std::is_default_constructible<LazyH>::value, LazyH>>
751    constexpr VariantStateBase() noexcept(
752        std::is_nothrow_default_constructible<ConstructibleH>::value)
753        : state_(EmplaceTag<0>()), index_(0) {}
754    template <std::size_t I, class... P>
755    explicit constexpr VariantStateBase(EmplaceTag<I> tag, P&&... args)
756        : state_(tag, absl::forward<P>(args)...), index_(I) {}
757    explicit constexpr VariantStateBase(NoopConstructorTag)
758        : state_(NoopConstructorTag()), index_(variant_npos) {}
759    void destroy() {}  
760    DestructibleUnion<H, T...> state_;
761    std::size_t index_;
762  };
763  using absl::internal::identity;
764  template <typename... Ts>
765  struct OverloadSet;
766  template <typename T, typename... Ts>
767  struct OverloadSet<T, Ts...> : OverloadSet<Ts...> {
768    using Base = OverloadSet<Ts...>;
769    static identity<T> Overload(const T&);
770    using Base::Overload;
771  };
772  template <>
773  struct OverloadSet<> {
774    static void Overload(...);
775  };
776  template <class T>
777  using LessThanResult = decltype(std::declval<T>() < std::declval<T>());
778  template <class T>
779  using GreaterThanResult = decltype(std::declval<T>() > std::declval<T>());
780  template <class T>
781  using LessThanOrEqualResult = decltype(std::declval<T>() <= std::declval<T>());
782  template <class T>
783  using GreaterThanOrEqualResult =
784      decltype(std::declval<T>() >= std::declval<T>());
785  template <class T>
786  using EqualResult = decltype(std::declval<T>() == std::declval<T>());
787  template <class T>
788  using NotEqualResult = decltype(std::declval<T>() != std::declval<T>());
789  using type_traits_internal::is_detected_convertible;
790  template <class... T>
791  using RequireAllHaveEqualT = absl::enable_if_t<
792      absl::conjunction<is_detected_convertible<bool, EqualResult, T>...>::value,
793      bool>;
794  template <class... T>
795  using RequireAllHaveNotEqualT =
796      absl::enable_if_t<absl::conjunction<is_detected_convertible<
797                            bool, NotEqualResult, T>...>::value,
798                        bool>;
799  template <class... T>
800  using RequireAllHaveLessThanT =
801      absl::enable_if_t<absl::conjunction<is_detected_convertible<
802                            bool, LessThanResult, T>...>::value,
803                        bool>;
804  template <class... T>
805  using RequireAllHaveLessThanOrEqualT =
806      absl::enable_if_t<absl::conjunction<is_detected_convertible<
807                            bool, LessThanOrEqualResult, T>...>::value,
808                        bool>;
809  template <class... T>
810  using RequireAllHaveGreaterThanOrEqualT =
811      absl::enable_if_t<absl::conjunction<is_detected_convertible<
812                            bool, GreaterThanOrEqualResult, T>...>::value,
813                        bool>;
814  template <class... T>
815  using RequireAllHaveGreaterThanT =
816      absl::enable_if_t<absl::conjunction<is_detected_convertible<
817                            bool, GreaterThanResult, T>...>::value,
818                        bool>;
819  template <typename T>
820  struct VariantHelper;
821  template <typename... Ts>
822  struct VariantHelper<variant<Ts...>> {
823    template <typename U>
824    using BestMatch = decltype(variant_internal::OverloadSet<Ts...>::Overload(
825        std::declval<U>()));
826    template <typename U>
827    struct CanAccept
828        : std::integral_constant<bool, !std::is_void<BestMatch<U>>::value> {};
829    template <typename Other>
830    struct CanConvertFrom;
831    template <typename... Us>
832    struct CanConvertFrom<variant<Us...>>
833        : public absl::conjunction<CanAccept<Us>...> {};
834  };
835  struct TrivialMoveOnly {
836    TrivialMoveOnly(TrivialMoveOnly&&) = default;
837  };
838  template <typename T>
839  struct IsTriviallyMoveConstructible
840      : std::is_move_constructible<Union<T, TrivialMoveOnly>> {};
841  template <class... T>
842  class VariantStateBaseDestructorNontrivial;
843  template <class... T>
844  class VariantMoveBaseNontrivial;
845  template <class... T>
846  class VariantCopyBaseNontrivial;
847  template <class... T>
848  class VariantMoveAssignBaseNontrivial;
849  template <class... T>
850  class VariantCopyAssignBaseNontrivial;
851  template <class... T>
852  using VariantStateBaseDestructor =
853      absl::conditional_t<std::is_destructible<Union<T...>>::value,
854                          VariantStateBase<T...>,
855                          VariantStateBaseDestructorNontrivial<T...>>;
856  template <class... T>
857  using VariantMoveBase = absl::conditional_t<
858      absl::disjunction<
859          absl::negation<absl::conjunction<std::is_move_constructible<T>...>>,
860          absl::conjunction<IsTriviallyMoveConstructible<T>...>>::value,
861      VariantStateBaseDestructor<T...>, VariantMoveBaseNontrivial<T...>>;
862  template <class... T>
863  using VariantCopyBase = absl::conditional_t<
864      absl::disjunction<
865          absl::negation<absl::conjunction<std::is_copy_constructible<T>...>>,
866          std::is_copy_constructible<Union<T...>>>::value,
867      VariantMoveBase<T...>, VariantCopyBaseNontrivial<T...>>;
868  template <class... T>
869  using VariantMoveAssignBase = absl::conditional_t<
870      absl::disjunction<
871          absl::conjunction<absl::is_move_assignable<Union<T...>>,
872                            std::is_move_constructible<Union<T...>>,
873                            std::is_destructible<Union<T...>>>,
874          absl::negation<absl::conjunction<std::is_move_constructible<T>...,
875                                           is_move_assignable<T>...>>>::value,
876      VariantCopyBase<T...>, VariantMoveAssignBaseNontrivial<T...>>;
877  template <class... T>
878  using VariantCopyAssignBase = absl::conditional_t<
879      absl::disjunction<
880          absl::conjunction<absl::is_copy_assignable<Union<T...>>,
881                            std::is_copy_constructible<Union<T...>>,
882                            std::is_destructible<Union<T...>>>,
883          absl::negation<absl::conjunction<std::is_copy_constructible<T>...,
884                                           is_copy_assignable<T>...>>>::value,
885      VariantMoveAssignBase<T...>, VariantCopyAssignBaseNontrivial<T...>>;
886  template <class... T>
887  using VariantBase = VariantCopyAssignBase<T...>;
888  template <class... T>
889  class VariantStateBaseDestructorNontrivial : protected VariantStateBase<T...> {
890   private:
891    using Base = VariantStateBase<T...>;
892   protected:
893    using Base::Base;
894    VariantStateBaseDestructorNontrivial() = default;
895    VariantStateBaseDestructorNontrivial(VariantStateBaseDestructorNontrivial&&) =
896        default;
897    VariantStateBaseDestructorNontrivial(
898        const VariantStateBaseDestructorNontrivial&) = default;
899    VariantStateBaseDestructorNontrivial& operator=(
900        VariantStateBaseDestructorNontrivial&&) = default;
901    VariantStateBaseDestructorNontrivial& operator=(
902        const VariantStateBaseDestructorNontrivial&) = default;
903    struct Destroyer {
904      template <std::size_t I>
905      void operator()(SizeT<I> i) const {
906        using Alternative =
907            typename absl::variant_alternative<I, variant<T...>>::type;
908        variant_internal::AccessUnion(self->state_, i).~Alternative();
909      }
910      void operator()(SizeT<absl::variant_npos> &bsol;*i*/) const {
911      }
912      VariantStateBaseDestructorNontrivial* self;
913    };
914    void destroy() { VisitIndices<sizeof...(T)>::Run(Destroyer{this}, index_); }
915    ~VariantStateBaseDestructorNontrivial() { destroy(); }
916   protected:
917    using Base::index_;
918    using Base::state_;
919  };
920  template <class... T>
921  class VariantMoveBaseNontrivial : protected VariantStateBaseDestructor<T...> {
922   private:
923    using Base = VariantStateBaseDestructor<T...>;
924   protected:
925    using Base::Base;
926    struct Construct {
927      template <std::size_t I>
928      void operator()(SizeT<I> i) const {
929        using Alternative =
930            typename absl::variant_alternative<I, variant<T...>>::type;
931        ::new (static_cast<void*>(&self->state_)) Alternative(
932            variant_internal::AccessUnion(absl::move(other->state_), i));
933      }
934      void operator()(SizeT<absl::variant_npos> &bsol;*i*/) const {}
935      VariantMoveBaseNontrivial* self;
936      VariantMoveBaseNontrivial* other;
937    };
938    VariantMoveBaseNontrivial() = default;
939    VariantMoveBaseNontrivial(VariantMoveBaseNontrivial&& other) noexcept(
940        absl::conjunction<std::is_nothrow_move_constructible<T>...>::value)
941        : Base(NoopConstructorTag()) {
942      VisitIndices<sizeof...(T)>::Run(Construct{this, &other}, other.index_);
943      index_ = other.index_;
944    }
945    VariantMoveBaseNontrivial(VariantMoveBaseNontrivial const&) = default;
946    VariantMoveBaseNontrivial& operator=(VariantMoveBaseNontrivial&&) = default;
947    VariantMoveBaseNontrivial& operator=(VariantMoveBaseNontrivial const&) =
948        default;
949   protected:
950    using Base::index_;
951    using Base::state_;
952  };
953  template <class... T>
954  class VariantCopyBaseNontrivial : protected VariantMoveBase<T...> {
955   private:
956    using Base = VariantMoveBase<T...>;
957   protected:
958    using Base::Base;
959    VariantCopyBaseNontrivial() = default;
960    VariantCopyBaseNontrivial(VariantCopyBaseNontrivial&&) = default;
961    struct Construct {
962      template <std::size_t I>
963      void operator()(SizeT<I> i) const {
964        using Alternative =
965            typename absl::variant_alternative<I, variant<T...>>::type;
966        ::new (static_cast<void*>(&self->state_))
967            Alternative(variant_internal::AccessUnion(other->state_, i));
968      }
969      void operator()(SizeT<absl::variant_npos> &bsol;*i*/) const {}
970      VariantCopyBaseNontrivial* self;
971      const VariantCopyBaseNontrivial* other;
972    };
973    VariantCopyBaseNontrivial(VariantCopyBaseNontrivial const& other)
974        : Base(NoopConstructorTag()) {
975      VisitIndices<sizeof...(T)>::Run(Construct{this, &other}, other.index_);
976      index_ = other.index_;
977    }
978    VariantCopyBaseNontrivial& operator=(VariantCopyBaseNontrivial&&) = default;
979    VariantCopyBaseNontrivial& operator=(VariantCopyBaseNontrivial const&) =
980        default;
981   protected:
982    using Base::index_;
983    using Base::state_;
984  };
985  template <class... T>
986  class VariantMoveAssignBaseNontrivial : protected VariantCopyBase<T...> {
987    friend struct VariantCoreAccess;
988   private:
989    using Base = VariantCopyBase<T...>;
990   protected:
991    using Base::Base;
992    VariantMoveAssignBaseNontrivial() = default;
993    VariantMoveAssignBaseNontrivial(VariantMoveAssignBaseNontrivial&&) = default;
994    VariantMoveAssignBaseNontrivial(const VariantMoveAssignBaseNontrivial&) =
995        default;
996    VariantMoveAssignBaseNontrivial& operator=(
997        VariantMoveAssignBaseNontrivial const&) = default;
998    VariantMoveAssignBaseNontrivial&
999    operator=(VariantMoveAssignBaseNontrivial&& other) noexcept(
1000        absl::conjunction<std::is_nothrow_move_constructible<T>...,
1001                          std::is_nothrow_move_assignable<T>...>::value) {
1002      VisitIndices<sizeof...(T)>::Run(
1003          VariantCoreAccess::MakeMoveAssignVisitor(this, &other), other.index_);
1004      return *this;
1005    }
1006   protected:
1007    using Base::index_;
1008    using Base::state_;
1009  };
1010  template <class... T>
1011  class VariantCopyAssignBaseNontrivial : protected VariantMoveAssignBase<T...> {
1012    friend struct VariantCoreAccess;
1013   private:
1014    using Base = VariantMoveAssignBase<T...>;
1015   protected:
1016    using Base::Base;
1017    VariantCopyAssignBaseNontrivial() = default;
1018    VariantCopyAssignBaseNontrivial(VariantCopyAssignBaseNontrivial&&) = default;
1019    VariantCopyAssignBaseNontrivial(const VariantCopyAssignBaseNontrivial&) =
1020        default;
1021    VariantCopyAssignBaseNontrivial& operator=(
1022        VariantCopyAssignBaseNontrivial&&) = default;
1023    VariantCopyAssignBaseNontrivial& operator=(
1024        const VariantCopyAssignBaseNontrivial& other) {
1025      VisitIndices<sizeof...(T)>::Run(
1026          VariantCoreAccess::MakeCopyAssignVisitor(this, other), other.index_);
1027      return *this;
1028    }
1029   protected:
1030    using Base::index_;
1031    using Base::state_;
1032  };
1033  template <class... Types>
1034  struct EqualsOp {
1035    const variant<Types...>* v;
1036    const variant<Types...>* w;
1037    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1038      return true;
1039    }
1040    template <std::size_t I>
1041    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1042      return VariantCoreAccess::Access<I>(*v) == VariantCoreAccess::Access<I>(*w);
1043    }
1044  };
1045  template <class... Types>
1046  struct NotEqualsOp {
1047    const variant<Types...>* v;
1048    const variant<Types...>* w;
1049    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1050      return false;
1051    }
1052    template <std::size_t I>
1053    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1054      return VariantCoreAccess::Access<I>(*v) != VariantCoreAccess::Access<I>(*w);
1055    }
1056  };
1057  template <class... Types>
1058  struct LessThanOp {
1059    const variant<Types...>* v;
1060    const variant<Types...>* w;
1061    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1062      return false;
1063    }
1064    template <std::size_t I>
1065    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1066      return VariantCoreAccess::Access<I>(*v) < VariantCoreAccess::Access<I>(*w);
1067    }
1068  };
1069  template <class... Types>
1070  struct GreaterThanOp {
1071    const variant<Types...>* v;
1072    const variant<Types...>* w;
1073    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1074      return false;
1075    }
1076    template <std::size_t I>
1077    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1078      return VariantCoreAccess::Access<I>(*v) > VariantCoreAccess::Access<I>(*w);
1079    }
1080  };
1081  template <class... Types>
1082  struct LessThanOrEqualsOp {
1083    const variant<Types...>* v;
1084    const variant<Types...>* w;
1085    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1086      return true;
1087    }
1088    template <std::size_t I>
1089    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1090      return VariantCoreAccess::Access<I>(*v) <= VariantCoreAccess::Access<I>(*w);
1091    }
1092  };
1093  template <class... Types>
1094  struct GreaterThanOrEqualsOp {
1095    const variant<Types...>* v;
1096    const variant<Types...>* w;
1097    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1098      return true;
1099    }
1100    template <std::size_t I>
1101    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1102      return VariantCoreAccess::Access<I>(*v) >= VariantCoreAccess::Access<I>(*w);
1103    }
1104  };
1105  template <class... Types>
1106  struct SwapSameIndex {
1107    variant<Types...>* v;
1108    variant<Types...>* w;
1109    template <std::size_t I>
1110    void operator()(SizeT<I>) const {
1111      type_traits_internal::Swap(VariantCoreAccess::Access<I>(*v),
1112                                 VariantCoreAccess::Access<I>(*w));
1113    }
1114    void operator()(SizeT<variant_npos>) const {}
1115  };
1116  template <class... Types>
1117  struct Swap {
1118    variant<Types...>* v;
1119    variant<Types...>* w;
1120    void generic_swap() const {
1121      variant<Types...> tmp(std::move(*w));
1122      VariantCoreAccess::Destroy(*w);
1123      VariantCoreAccess::InitFrom(*w, std::move(*v));
1124      VariantCoreAccess::Destroy(*v);
1125      VariantCoreAccess::InitFrom(*v, std::move(tmp));
1126    }
1127    void operator()(SizeT<absl::variant_npos> &bsol;*w_i*/) const {
1128      if (!v->valueless_by_exception()) {
1129        generic_swap();
1130      }
1131    }
1132    template <std::size_t Wi>
1133    void operator()(SizeT<Wi> &bsol;*w_i*/) {
1134      if (v->index() == Wi) {
1135        VisitIndices<sizeof...(Types)>::Run(SwapSameIndex<Types...>{v, w}, Wi);
1136      } else {
1137        generic_swap();
1138      }
1139    }
1140  };
1141  template <typename Variant, typename = void, typename... Ts>
1142  struct VariantHashBase {
1143    VariantHashBase() = delete;
1144    VariantHashBase(const VariantHashBase&) = delete;
1145    VariantHashBase(VariantHashBase&&) = delete;
1146    VariantHashBase& operator=(const VariantHashBase&) = delete;
<span onclick='openModal()' class='match'>1147    VariantHashBase& operator=(VariantHashBase&&) = delete;
1148  };
1149  struct VariantHashVisitor {
1150    template <typename T>
</span>1151    size_t operator()(const T& t) {
1152      return std::hash<T>{}(t);
1153    }
1154  };
1155  template <typename Variant, typename... Ts>
1156  struct VariantHashBase<Variant,
1157                         absl::enable_if_t<absl::conjunction<
1158                             type_traits_internal::IsHashable<Ts>...>::value>,
1159                         Ts...> {
1160    using argument_type = Variant;
1161    using result_type = size_t;
1162    size_t operator()(const Variant& var) const {
1163      type_traits_internal::AssertHashEnabled<Ts...>();
1164      if (var.valueless_by_exception()) {
1165        return 239799884;
1166      }
1167      size_t result = VisitIndices<variant_size<Variant>::value>::Run(
1168          PerformVisitation<VariantHashVisitor, const Variant&>{
1169              std::forward_as_tuple(var), VariantHashVisitor{}},
1170          var.index());
1171      return result ^ var.index();
1172    }
1173  };
1174  }  
1175  ABSL_NAMESPACE_END
1176  }  
1177  #endif  
1178  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_4.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_VARIANT_H_
2  #define ABSL_TYPES_INTERNAL_VARIANT_H_
3  #include <cassert>
4  #include <cstddef>
5  #include <cstdlib>
6  #include <memory>
7  #include <stdexcept>
8  #include <tuple>
9  #include <type_traits>
10  #include "absl/base/config.h"
11  #include "absl/base/internal/identity.h"
12  #include "absl/base/internal/inline_variable.h"
13  #include "absl/base/internal/invoke.h"
14  #include "absl/base/macros.h"
15  #include "absl/base/optimization.h"
16  #include "absl/meta/type_traits.h"
17  #include "absl/types/bad_variant_access.h"
18  #include "absl/utility/utility.h"
19  #if !defined(ABSL_USES_STD_VARIANT)
20  namespace absl {
21  ABSL_NAMESPACE_BEGIN
22  template <class... Types>
23  class variant;
24  ABSL_INTERNAL_INLINE_CONSTEXPR(size_t, variant_npos, static_cast<size_t>(-1));
25  template <class T>
26  struct variant_size;
27  template <std::size_t I, class T>
28  struct variant_alternative;
29  namespace variant_internal {
30  template <std::size_t I, class T>
31  struct VariantAlternativeSfinae {};
32  template <std::size_t I, class T0, class... Tn>
33  struct VariantAlternativeSfinae<I, variant<T0, Tn...>>
34      : VariantAlternativeSfinae<I - 1, variant<Tn...>> {};
35  template <class T0, class... Ts>
36  struct VariantAlternativeSfinae<0, variant<T0, Ts...>> {
37    using type = T0;
38  };
39  template <std::size_t I, class T>
40  using VariantAlternativeSfinaeT = typename VariantAlternativeSfinae<I, T>::type;
41  template <class T, class U>
42  struct GiveQualsTo;
43  template <class T, class U>
44  struct GiveQualsTo<T&, U> {
45    using type = U&;
46  };
47  template <class T, class U>
48  struct GiveQualsTo<T&&, U> {
49    using type = U&&;
50  };
51  template <class T, class U>
52  struct GiveQualsTo<const T&, U> {
53    using type = const U&;
54  };
55  template <class T, class U>
56  struct GiveQualsTo<const T&&, U> {
57    using type = const U&&;
58  };
59  template <class T, class U>
60  struct GiveQualsTo<volatile T&, U> {
61    using type = volatile U&;
62  };
63  template <class T, class U>
64  struct GiveQualsTo<volatile T&&, U> {
65    using type = volatile U&&;
66  };
67  template <class T, class U>
68  struct GiveQualsTo<volatile const T&, U> {
69    using type = volatile const U&;
70  };
71  template <class T, class U>
72  struct GiveQualsTo<volatile const T&&, U> {
73    using type = volatile const U&&;
74  };
75  template <class T, class U>
76  using GiveQualsToT = typename GiveQualsTo<T, U>::type;
77  template <std::size_t I>
78  using SizeT = std::integral_constant<std::size_t, I>;
79  using NPos = SizeT<variant_npos>;
80  template <class Variant, class T, class = void>
81  struct IndexOfConstructedType {};
82  template <std::size_t I, class Variant>
83  struct VariantAccessResultImpl;
84  template <std::size_t I, template <class...> class Variantemplate, class... T>
85  struct VariantAccessResultImpl<I, Variantemplate<T...>&> {
86    using type = typename absl::variant_alternative<I, variant<T...>>::type&;
87  };
88  template <std::size_t I, template <class...> class Variantemplate, class... T>
89  struct VariantAccessResultImpl<I, const Variantemplate<T...>&> {
90    using type =
91        const typename absl::variant_alternative<I, variant<T...>>::type&;
92  };
93  template <std::size_t I, template <class...> class Variantemplate, class... T>
94  struct VariantAccessResultImpl<I, Variantemplate<T...>&&> {
95    using type = typename absl::variant_alternative<I, variant<T...>>::type&&;
96  };
97  template <std::size_t I, template <class...> class Variantemplate, class... T>
98  struct VariantAccessResultImpl<I, const Variantemplate<T...>&&> {
99    using type =
100        const typename absl::variant_alternative<I, variant<T...>>::type&&;
101  };
102  template <std::size_t I, class Variant>
103  using VariantAccessResult =
104      typename VariantAccessResultImpl<I, Variant&&>::type;
105  template <class T, std::size_t Size>
106  struct SimpleArray {
107    static_assert(Size != 0, "");
108    T value[Size];
109  };
110  template <class T>
111  struct AccessedType {
112    using type = T;
113  };
114  template <class T>
115  using AccessedTypeT = typename AccessedType<T>::type;
116  template <class T, std::size_t Size>
117  struct AccessedType<SimpleArray<T, Size>> {
118    using type = AccessedTypeT<T>;
119  };
120  template <class T>
121  constexpr T AccessSimpleArray(const T& value) {
122    return value;
123  }
124  template <class T, std::size_t Size, class... SizeT>
125  constexpr AccessedTypeT<T> AccessSimpleArray(const SimpleArray<T, Size>& table,
126                                               std::size_t head_index,
127                                               SizeT... tail_indices) {
128    return AccessSimpleArray(table.value[head_index], tail_indices...);
129  }
130  template <class T>
131  using AlwaysZero = SizeT<0>;
132  template <class Op, class... Vs>
133  struct VisitIndicesResultImpl {
134    using type = absl::result_of_t<Op(AlwaysZero<Vs>...)>;
135  };
136  template <class Op, class... Vs>
137  using VisitIndicesResultT = typename VisitIndicesResultImpl<Op, Vs...>::type;
138  template <class ReturnType, class FunctionObject, class EndIndices,
139            class BoundIndices>
140  struct MakeVisitationMatrix;
141  template <class ReturnType, class FunctionObject, std::size_t... Indices>
142  constexpr ReturnType call_with_indices(FunctionObject&& function) {
143    static_assert(
144        std::is_same<ReturnType, decltype(std::declval<FunctionObject>()(
145                                     SizeT<Indices>()...))>::value,
146        "Not all visitation overloads have the same return type.");
147    return absl::forward<FunctionObject>(function)(SizeT<Indices>()...);
148  }
149  template <class ReturnType, class FunctionObject, std::size_t... BoundIndices>
150  struct MakeVisitationMatrix<ReturnType, FunctionObject, index_sequence<>,
151                              index_sequence<BoundIndices...>> {
152    using ResultType = ReturnType (*)(FunctionObject&&);
153    static constexpr ResultType Run() {
154      return &call_with_indices<ReturnType, FunctionObject,
155                                (BoundIndices - 1)...>;
156    }
157  };
158  template <typename Is, std::size_t J>
159  struct AppendToIndexSequence;
160  template <typename Is, std::size_t J>
161  using AppendToIndexSequenceT = typename AppendToIndexSequence<Is, J>::type;
162  template <std::size_t... Is, std::size_t J>
163  struct AppendToIndexSequence<index_sequence<Is...>, J> {
164    using type = index_sequence<Is..., J>;
165  };
166  template <class ReturnType, class FunctionObject, class EndIndices,
167            class CurrIndices, class BoundIndices>
168  struct MakeVisitationMatrixImpl;
169  template <class ReturnType, class FunctionObject, class EndIndices,
170            std::size_t... CurrIndices, class BoundIndices>
171  struct MakeVisitationMatrixImpl<ReturnType, FunctionObject, EndIndices,
172                                  index_sequence<CurrIndices...>, BoundIndices> {
173    using ResultType = SimpleArray<
174        typename MakeVisitationMatrix<ReturnType, FunctionObject, EndIndices,
175                                      index_sequence<>>::ResultType,
176        sizeof...(CurrIndices)>;
177    static constexpr ResultType Run() {
178      return {{MakeVisitationMatrix<
179          ReturnType, FunctionObject, EndIndices,
180          AppendToIndexSequenceT<BoundIndices, CurrIndices>>::Run()...}};
181    }
182  };
183  template <class ReturnType, class FunctionObject, std::size_t HeadEndIndex,
184            std::size_t... TailEndIndices, std::size_t... BoundIndices>
185  struct MakeVisitationMatrix<ReturnType, FunctionObject,
186                              index_sequence<HeadEndIndex, TailEndIndices...>,
187                              index_sequence<BoundIndices...>>
188      : MakeVisitationMatrixImpl<ReturnType, FunctionObject,
189                                 index_sequence<TailEndIndices...>,
190                                 absl::make_index_sequence<HeadEndIndex>,
191                                 index_sequence<BoundIndices...>> {};
192  struct UnreachableSwitchCase {
193    template <class Op>
194    [[noreturn]] static VisitIndicesResultT<Op, std::size_t> Run(
195        Op&& &bsol;*ignored*/) {
196  #if ABSL_HAVE_BUILTIN(__builtin_unreachable) || \
197      (defined(__GNUC__) && !defined(__clang__))
198      __builtin_unreachable();
199  #elif defined(_MSC_VER)
200      __assume(false);
201  #else
202      assert(false);  
203      return Run(absl::forward<Op>(op));
204  #endif  
205    }
206  };
207  template <class Op, std::size_t I>
208  struct ReachableSwitchCase {
209    static VisitIndicesResultT<Op, std::size_t> Run(Op&& op) {
210      return absl::base_internal::invoke(absl::forward<Op>(op), SizeT<I>());
211    }
212  };
213  ABSL_INTERNAL_INLINE_CONSTEXPR(std::size_t, MaxUnrolledVisitCases, 33);
214  template <bool IsReachable>
215  struct PickCaseImpl {
216    template <class Op, std::size_t I>
217    using Apply = UnreachableSwitchCase;
218  };
219  template <>
220  struct PickCaseImpl<&bsol;*IsReachable =*/true> {
221    template <class Op, std::size_t I>
222    using Apply = ReachableSwitchCase<Op, I>;
223  };
224  template <class Op, std::size_t I, std::size_t EndIndex>
225  using PickCase = typename PickCaseImpl<(I < EndIndex)>::template Apply<Op, I>;
226  template <class ReturnType>
227  [[noreturn]] ReturnType TypedThrowBadVariantAccess() {
228    absl::variant_internal::ThrowBadVariantAccess();
229  }
230  template <std::size_t... NumAlternatives>
231  struct NumCasesOfSwitch;
232  template <std::size_t HeadNumAlternatives, std::size_t... TailNumAlternatives>
233  struct NumCasesOfSwitch<HeadNumAlternatives, TailNumAlternatives...> {
234    static constexpr std::size_t value =
235        (HeadNumAlternatives + 1) *
236        NumCasesOfSwitch<TailNumAlternatives...>::value;
237  };
238  template <>
239  struct NumCasesOfSwitch<> {
240    static constexpr std::size_t value = 1;
241  };
242  template <std::size_t EndIndex>
243  struct VisitIndicesSwitch {
244    static_assert(EndIndex <= MaxUnrolledVisitCases,
245                  "Maximum unrolled switch size exceeded.");
246    template <class Op>
247    static VisitIndicesResultT<Op, std::size_t> Run(Op&& op, std::size_t i) {
248      switch (i) {
249        case 0:
250          return PickCase<Op, 0, EndIndex>::Run(absl::forward<Op>(op));
251        case 1:
252          return PickCase<Op, 1, EndIndex>::Run(absl::forward<Op>(op));
253        case 2:
254          return PickCase<Op, 2, EndIndex>::Run(absl::forward<Op>(op));
255        case 3:
256          return PickCase<Op, 3, EndIndex>::Run(absl::forward<Op>(op));
257        case 4:
258          return PickCase<Op, 4, EndIndex>::Run(absl::forward<Op>(op));
259        case 5:
260          return PickCase<Op, 5, EndIndex>::Run(absl::forward<Op>(op));
261        case 6:
262          return PickCase<Op, 6, EndIndex>::Run(absl::forward<Op>(op));
263        case 7:
264          return PickCase<Op, 7, EndIndex>::Run(absl::forward<Op>(op));
265        case 8:
266          return PickCase<Op, 8, EndIndex>::Run(absl::forward<Op>(op));
267        case 9:
268          return PickCase<Op, 9, EndIndex>::Run(absl::forward<Op>(op));
269        case 10:
270          return PickCase<Op, 10, EndIndex>::Run(absl::forward<Op>(op));
271        case 11:
272          return PickCase<Op, 11, EndIndex>::Run(absl::forward<Op>(op));
273        case 12:
274          return PickCase<Op, 12, EndIndex>::Run(absl::forward<Op>(op));
275        case 13:
276          return PickCase<Op, 13, EndIndex>::Run(absl::forward<Op>(op));
277        case 14:
278          return PickCase<Op, 14, EndIndex>::Run(absl::forward<Op>(op));
279        case 15:
280          return PickCase<Op, 15, EndIndex>::Run(absl::forward<Op>(op));
281        case 16:
282          return PickCase<Op, 16, EndIndex>::Run(absl::forward<Op>(op));
283        case 17:
284          return PickCase<Op, 17, EndIndex>::Run(absl::forward<Op>(op));
285        case 18:
286          return PickCase<Op, 18, EndIndex>::Run(absl::forward<Op>(op));
287        case 19:
288          return PickCase<Op, 19, EndIndex>::Run(absl::forward<Op>(op));
289        case 20:
290          return PickCase<Op, 20, EndIndex>::Run(absl::forward<Op>(op));
291        case 21:
292          return PickCase<Op, 21, EndIndex>::Run(absl::forward<Op>(op));
293        case 22:
294          return PickCase<Op, 22, EndIndex>::Run(absl::forward<Op>(op));
295        case 23:
296          return PickCase<Op, 23, EndIndex>::Run(absl::forward<Op>(op));
297        case 24:
298          return PickCase<Op, 24, EndIndex>::Run(absl::forward<Op>(op));
299        case 25:
300          return PickCase<Op, 25, EndIndex>::Run(absl::forward<Op>(op));
301        case 26:
302          return PickCase<Op, 26, EndIndex>::Run(absl::forward<Op>(op));
303        case 27:
304          return PickCase<Op, 27, EndIndex>::Run(absl::forward<Op>(op));
305        case 28:
306          return PickCase<Op, 28, EndIndex>::Run(absl::forward<Op>(op));
307        case 29:
308          return PickCase<Op, 29, EndIndex>::Run(absl::forward<Op>(op));
309        case 30:
310          return PickCase<Op, 30, EndIndex>::Run(absl::forward<Op>(op));
311        case 31:
312          return PickCase<Op, 31, EndIndex>::Run(absl::forward<Op>(op));
313        case 32:
314          return PickCase<Op, 32, EndIndex>::Run(absl::forward<Op>(op));
315        default:
316          ABSL_ASSERT(i == variant_npos);
317          return absl::base_internal::invoke(absl::forward<Op>(op), NPos());
318      }
319    }
320  };
321  template <std::size_t... EndIndices>
322  struct VisitIndicesFallback {
323    template <class Op, class... SizeT>
324    static VisitIndicesResultT<Op, SizeT...> Run(Op&& op, SizeT... indices) {
325      return AccessSimpleArray(
326          MakeVisitationMatrix<VisitIndicesResultT<Op, SizeT...>, Op,
327                               index_sequence<(EndIndices + 1)...>,
328                               index_sequence<>>::Run(),
329          (indices + 1)...)(absl::forward<Op>(op));
330    }
331  };
332  template <std::size_t...>
333  struct FlattenIndices;
334  template <std::size_t HeadSize, std::size_t... TailSize>
335  struct FlattenIndices<HeadSize, TailSize...> {
336    template <class... SizeType>
337    static constexpr std::size_t Run(std::size_t head, SizeType... tail) {
338      return head + HeadSize * FlattenIndices<TailSize...>::Run(tail...);
339    }
340  };
341  template <>
342  struct FlattenIndices<> {
343    static constexpr std::size_t Run() { return 0; }
344  };
345  template <std::size_t I, std::size_t IndexToGet, std::size_t HeadSize,
346            std::size_t... TailSize>
347  struct UnflattenIndex {
348    static constexpr std::size_t value =
349        UnflattenIndex<I / HeadSize, IndexToGet - 1, TailSize...>::value;
350  };
351  template <std::size_t I, std::size_t HeadSize, std::size_t... TailSize>
352  struct UnflattenIndex<I, 0, HeadSize, TailSize...> {
353    static constexpr std::size_t value = (I % HeadSize);
354  };
355  template <class IndexSequence, std::size_t... EndIndices>
356  struct VisitIndicesVariadicImpl;
357  template <std::size_t... N, std::size_t... EndIndices>
358  struct VisitIndicesVariadicImpl<absl::index_sequence<N...>, EndIndices...> {
359    template <class Op>
360    struct FlattenedOp {
361      template <std::size_t I>
362      VisitIndicesResultT<Op, decltype(EndIndices)...> operator()(
363          SizeT<I> &bsol;*index*/) && {
364        return base_internal::invoke(
365            absl::forward<Op>(op),
366            SizeT<UnflattenIndex<I, N, (EndIndices + 1)...>::value -
367                  std::size_t{1}>()...);
368      }
369      Op&& op;
370    };
371    template <class Op, class... SizeType>
372    static VisitIndicesResultT<Op, decltype(EndIndices)...> Run(Op&& op,
373                                                                SizeType... i) {
374      return VisitIndicesSwitch<NumCasesOfSwitch<EndIndices...>::value>::Run(
375          FlattenedOp<Op>{absl::forward<Op>(op)},
376          FlattenIndices<(EndIndices + std::size_t{1})...>::Run(
377              (i + std::size_t{1})...));
378    }
379  };
380  template <std::size_t... EndIndices>
381  struct VisitIndicesVariadic
382      : VisitIndicesVariadicImpl<absl::make_index_sequence<sizeof...(EndIndices)>,
383                                 EndIndices...> {};
384  template <std::size_t... EndIndices>
385  struct VisitIndices
386      : absl::conditional_t<(NumCasesOfSwitch<EndIndices...>::value <=
387                             MaxUnrolledVisitCases),
388                            VisitIndicesVariadic<EndIndices...>,
389                            VisitIndicesFallback<EndIndices...>> {};
390  template <std::size_t EndIndex>
391  struct VisitIndices<EndIndex>
392      : absl::conditional_t<(EndIndex <= MaxUnrolledVisitCases),
393                            VisitIndicesSwitch<EndIndex>,
394                            VisitIndicesFallback<EndIndex>> {};
395  #ifdef _MSC_VER
396  #pragma warning(push)
397  #pragma warning(disable : 4172)
398  #endif  
399  template <class Self, std::size_t I>
400  inline VariantAccessResult<I, Self> AccessUnion(Self&& self, SizeT<I> &bsol;*i*/) {
401    return reinterpret_cast<VariantAccessResult<I, Self>>(self);
402  }
403  #ifdef _MSC_VER
404  #pragma warning(pop)
405  #endif  
406  template <class T>
407  void DeducedDestroy(T& self) {  
408    self.~T();
409  }
410  struct VariantCoreAccess {
411    template <class VariantType>
412    static typename VariantType::Variant& Derived(VariantType& self) {  
413      return static_cast<typename VariantType::Variant&>(self);
414    }
415    template <class VariantType>
416    static const typename VariantType::Variant& Derived(
417        const VariantType& self) {  
418      return static_cast<const typename VariantType::Variant&>(self);
419    }
420    template <class VariantType>
421    static void Destroy(VariantType& self) {  
422      Derived(self).destroy();
423      self.index_ = absl::variant_npos;
424    }
425    template <class Variant>
426    static void SetIndex(Variant& self, std::size_t i) {  
427      self.index_ = i;
428    }
429    template <class Variant>
430    static void InitFrom(Variant& self, Variant&& other) {  
431      VisitIndices<absl::variant_size<Variant>::value>::Run(
432          InitFromVisitor<Variant, Variant&&>{&self,
433                                              std::forward<Variant>(other)},
434          other.index());
435      self.index_ = other.index();
436    }
437    template <std::size_t I, class Variant>
438    static VariantAccessResult<I, Variant> Access(Variant&& self) {
439      return static_cast<VariantAccessResult<I, Variant>>(
440          variant_internal::AccessUnion(self.state_, SizeT<I>()));
441    }
442    template <std::size_t I, class Variant>
443    static VariantAccessResult<I, Variant> CheckedAccess(Variant&& self) {
444      if (ABSL_PREDICT_FALSE(self.index_ != I)) {
445        TypedThrowBadVariantAccess<VariantAccessResult<I, Variant>>();
446      }
447      return Access<I>(absl::forward<Variant>(self));
448    }
449    template <class VType>
450    struct MoveAssignVisitor {
451      using DerivedType = typename VType::Variant;
452      template <std::size_t NewIndex>
453      void operator()(SizeT<NewIndex> &bsol;*new_i*/) const {
454        if (left->index_ == NewIndex) {
455          Access<NewIndex>(*left) = std::move(Access<NewIndex>(*right));
456        } else {
457          Derived(*left).template emplace<NewIndex>(
458              std::move(Access<NewIndex>(*right)));
459        }
460      }
461      void operator()(SizeT<absl::variant_npos> &bsol;*new_i*/) const {
462        Destroy(*left);
463      }
464      VType* left;
465      VType* right;
466    };
467    template <class VType>
468    static MoveAssignVisitor<VType> MakeMoveAssignVisitor(VType* left,
469                                                          VType* other) {
470      return {left, other};
471    }
472    template <class VType>
473    struct CopyAssignVisitor {
474      using DerivedType = typename VType::Variant;
475      template <std::size_t NewIndex>
476      void operator()(SizeT<NewIndex> &bsol;*new_i*/) const {
477        using New =
478            typename absl::variant_alternative<NewIndex, DerivedType>::type;
479        if (left->index_ == NewIndex) {
480          Access<NewIndex>(*left) = Access<NewIndex>(*right);
481        } else if (std::is_nothrow_copy_constructible<New>::value ||
482                   !std::is_nothrow_move_constructible<New>::value) {
483          Derived(*left).template emplace<NewIndex>(Access<NewIndex>(*right));
484        } else {
485          Derived(*left) = DerivedType(Derived(*right));
486        }
487      }
488      void operator()(SizeT<absl::variant_npos> &bsol;*new_i*/) const {
489        Destroy(*left);
490      }
491      VType* left;
492      const VType* right;
493    };
494    template <class VType>
495    static CopyAssignVisitor<VType> MakeCopyAssignVisitor(VType* left,
496                                                          const VType& other) {
497      return {left, &other};
498    }
499    template <class Left, class QualifiedNew>
500    struct ConversionAssignVisitor {
501      using NewIndex =
502          variant_internal::IndexOfConstructedType<Left, QualifiedNew>;
503      void operator()(SizeT<NewIndex::value> &bsol;*old_i*/
504      ) const {
505        Access<NewIndex::value>(*left) = absl::forward<QualifiedNew>(other);
506      }
507      template <std::size_t OldIndex>
508      void operator()(SizeT<OldIndex> &bsol;*old_i*/
509      ) const {
510        using New =
511            typename absl::variant_alternative<NewIndex::value, Left>::type;
512        if (std::is_nothrow_constructible<New, QualifiedNew>::value ||
513            !std::is_nothrow_move_constructible<New>::value) {
514          left->template emplace<NewIndex::value>(
515              absl::forward<QualifiedNew>(other));
516        } else {
517          left->template emplace<NewIndex::value>(
518              New(absl::forward<QualifiedNew>(other)));
519        }
520      }
521      Left* left;
522      QualifiedNew&& other;
523    };
524    template <class Left, class QualifiedNew>
525    static ConversionAssignVisitor<Left, QualifiedNew>
526    MakeConversionAssignVisitor(Left* left, QualifiedNew&& qual) {
527      return {left, absl::forward<QualifiedNew>(qual)};
528    }
529    template <std::size_t NewIndex, class Self, class... Args>
530    static typename absl::variant_alternative<NewIndex, Self>::type& Replace(
531        Self* self, Args&&... args) {
532      Destroy(*self);
533      using New = typename absl::variant_alternative<NewIndex, Self>::type;
534      New* const result = ::new (static_cast<void*>(&self->state_))
535          New(absl::forward<Args>(args)...);
536      self->index_ = NewIndex;
537      return *result;
538    }
539    template <class LeftVariant, class QualifiedRightVariant>
540    struct InitFromVisitor {
541      template <std::size_t NewIndex>
542      void operator()(SizeT<NewIndex> &bsol;*new_i*/) const {
543        using Alternative =
544            typename variant_alternative<NewIndex, LeftVariant>::type;
545        ::new (static_cast<void*>(&left->state_)) Alternative(
546            Access<NewIndex>(std::forward<QualifiedRightVariant>(right)));
547      }
548      void operator()(SizeT<absl::variant_npos> &bsol;*new_i*/) const {
549      }
550      LeftVariant* left;
551      QualifiedRightVariant&& right;
552    };
553  };
554  template <class Expected, class... T>
555  struct IndexOfImpl;
556  template <class Expected>
557  struct IndexOfImpl<Expected> {
558    using IndexFromEnd = SizeT<0>;
559    using MatchedIndexFromEnd = IndexFromEnd;
560    using MultipleMatches = std::false_type;
561  };
562  template <class Expected, class Head, class... Tail>
563  struct IndexOfImpl<Expected, Head, Tail...> : IndexOfImpl<Expected, Tail...> {
564    using IndexFromEnd =
565        SizeT<IndexOfImpl<Expected, Tail...>::IndexFromEnd::value + 1>;
566  };
567  template <class Expected, class... Tail>
568  struct IndexOfImpl<Expected, Expected, Tail...>
569      : IndexOfImpl<Expected, Tail...> {
570    using IndexFromEnd =
571        SizeT<IndexOfImpl<Expected, Tail...>::IndexFromEnd::value + 1>;
572    using MatchedIndexFromEnd = IndexFromEnd;
573    using MultipleMatches = std::integral_constant<
574        bool, IndexOfImpl<Expected, Tail...>::MatchedIndexFromEnd::value != 0>;
575  };
576  template <class Expected, class... Types>
577  struct IndexOfMeta {
578    using Results = IndexOfImpl<Expected, Types...>;
579    static_assert(!Results::MultipleMatches::value,
580                  "Attempted to access a variant by specifying a type that "
581                  "matches more than one alternative.");
582    static_assert(Results::MatchedIndexFromEnd::value != 0,
583                  "Attempted to access a variant by specifying a type that does "
584                  "not match any alternative.");
585    using type = SizeT<sizeof...(Types) - Results::MatchedIndexFromEnd::value>;
586  };
587  template <class Expected, class... Types>
588  using IndexOf = typename IndexOfMeta<Expected, Types...>::type;
589  template <class Variant, class T, std::size_t CurrIndex>
590  struct UnambiguousIndexOfImpl;
591  template <class T, std::size_t CurrIndex>
592  struct UnambiguousIndexOfImpl<variant<>, T, CurrIndex> : SizeT<CurrIndex> {};
593  template <class Head, class... Tail, class T, std::size_t CurrIndex>
594  struct UnambiguousIndexOfImpl<variant<Head, Tail...>, T, CurrIndex>
595      : UnambiguousIndexOfImpl<variant<Tail...>, T, CurrIndex + 1>::type {};
596  template <class Head, class... Tail, std::size_t CurrIndex>
597  struct UnambiguousIndexOfImpl<variant<Head, Tail...>, Head, CurrIndex>
598      : SizeT<UnambiguousIndexOfImpl<variant<Tail...>, Head, 0>::value ==
599                      sizeof...(Tail)
600                  ? CurrIndex
601                  : CurrIndex + sizeof...(Tail) + 1> {};
602  template <class Variant, class T>
603  struct UnambiguousIndexOf;
604  struct NoMatch {
605    struct type {};
606  };
607  template <class... Alts, class T>
608  struct UnambiguousIndexOf<variant<Alts...>, T>
609      : std::conditional<UnambiguousIndexOfImpl<variant<Alts...>, T, 0>::value !=
610                             sizeof...(Alts),
611                         UnambiguousIndexOfImpl<variant<Alts...>, T, 0>,
612                         NoMatch>::type::type {};
613  template <class T, std::size_t &bsol;*Dummy*/>
614  using UnambiguousTypeOfImpl = T;
615  template <class Variant, class T>
616  using UnambiguousTypeOfT =
617      UnambiguousTypeOfImpl<T, UnambiguousIndexOf<Variant, T>::value>;
618  template <class H, class... T>
619  class VariantStateBase;
620  template <class Variant, std::size_t I = 0>
621  struct ImaginaryFun;
622  template <std::size_t I>
623  struct ImaginaryFun<variant<>, I> {
624    static void Run() = delete;
625  };
626  template <class H, class... T, std::size_t I>
627  struct ImaginaryFun<variant<H, T...>, I> : ImaginaryFun<variant<T...>, I + 1> {
628    using ImaginaryFun<variant<T...>, I + 1>::Run;
629    static SizeT<I> Run(const H&, SizeT<I>);
630    static SizeT<I> Run(H&&, SizeT<I>);
631  };
632  template <class Self, class T>
633  struct IsNeitherSelfNorInPlace : std::true_type {};
634  template <class Self>
635  struct IsNeitherSelfNorInPlace<Self, Self> : std::false_type {};
636  template <class Self, class T>
637  struct IsNeitherSelfNorInPlace<Self, in_place_type_t<T>> : std::false_type {};
638  template <class Self, std::size_t I>
639  struct IsNeitherSelfNorInPlace<Self, in_place_index_t<I>> : std::false_type {};
640  template <class Variant, class T>
641  struct IndexOfConstructedType<
642      Variant, T,
643      void_t<decltype(ImaginaryFun<Variant>::Run(std::declval<T>(), {}))>>
644      : decltype(ImaginaryFun<Variant>::Run(std::declval<T>(), {})) {};
645  template <std::size_t... Is>
646  struct ContainsVariantNPos
647      : absl::negation<std::is_same<  
648            std::integer_sequence<bool, 0 <= Is...>,
649            std::integer_sequence<bool, Is != absl::variant_npos...>>> {};
650  template <class Op, class... QualifiedVariants>
651  using RawVisitResult =
652      absl::result_of_t<Op(VariantAccessResult<0, QualifiedVariants>...)>;
653  template <class Op, class... QualifiedVariants>
654  struct VisitResultImpl {
655    using type =
656        absl::result_of_t<Op(VariantAccessResult<0, QualifiedVariants>...)>;
657  };
658  template <class Op, class... QualifiedVariants>
659  using VisitResult = typename VisitResultImpl<Op, QualifiedVariants...>::type;
660  template <class Op, class... QualifiedVariants>
661  struct PerformVisitation {
662    using ReturnType = VisitResult<Op, QualifiedVariants...>;
663    template <std::size_t... Is>
664    constexpr ReturnType operator()(SizeT<Is>... indices) const {
665      return Run(typename ContainsVariantNPos<Is...>::type{},
666                 absl::index_sequence_for<QualifiedVariants...>(), indices...);
667    }
668    template <std::size_t... TupIs, std::size_t... Is>
669    constexpr ReturnType Run(std::false_type &bsol;*has_valueless*/,
670                             index_sequence<TupIs...>, SizeT<Is>...) const {
671      static_assert(
672          std::is_same<ReturnType,
673                       absl::result_of_t<Op(VariantAccessResult<
674                                            Is, QualifiedVariants>...)>>::value,
675          "All visitation overloads must have the same return type.");
676      return absl::base_internal::invoke(
677          absl::forward<Op>(op),
678          VariantCoreAccess::Access<Is>(
679              absl::forward<QualifiedVariants>(std::get<TupIs>(variant_tup)))...);
680    }
681    template <std::size_t... TupIs, std::size_t... Is>
682    [[noreturn]] ReturnType Run(std::true_type &bsol;*has_valueless*/,
683                                index_sequence<TupIs...>, SizeT<Is>...) const {
684      absl::variant_internal::ThrowBadVariantAccess();
685    }
686    std::tuple<QualifiedVariants&&...> variant_tup;
687    Op&& op;
688  };
689  template <class... T>
690  union Union;
691  struct NoopConstructorTag {};
692  template <std::size_t I>
693  struct EmplaceTag {};
694  template <>
695  union Union<> {
696    constexpr explicit Union(NoopConstructorTag) noexcept {}
697  };
698  #ifdef _MSC_VER
699  #pragma warning(push)
700  #pragma warning(disable : 4624)
701  #endif  
702  template <class Head, class... Tail>
703  union Union<Head, Tail...> {
704    using TailUnion = Union<Tail...>;
705    explicit constexpr Union(NoopConstructorTag &bsol;*tag*/) noexcept
706        : tail(NoopConstructorTag()) {}
707    template <class... P>
708    explicit constexpr Union(EmplaceTag<0>, P&&... args)
709        : head(absl::forward<P>(args)...) {}
710    template <std::size_t I, class... P>
711    explicit constexpr Union(EmplaceTag<I>, P&&... args)
712        : tail(EmplaceTag<I - 1>{}, absl::forward<P>(args)...) {}
713    Head head;
714    TailUnion tail;
715  };
716  #ifdef _MSC_VER
717  #pragma warning(pop)
718  #endif  
719  template <class... T>
720  union DestructibleUnionImpl;
721  template <>
722  union DestructibleUnionImpl<> {
723    constexpr explicit DestructibleUnionImpl(NoopConstructorTag) noexcept {}
724  };
725  template <class Head, class... Tail>
726  union DestructibleUnionImpl<Head, Tail...> {
727    using TailUnion = DestructibleUnionImpl<Tail...>;
728    explicit constexpr DestructibleUnionImpl(NoopConstructorTag &bsol;*tag*/) noexcept
729        : tail(NoopConstructorTag()) {}
730    template <class... P>
731    explicit constexpr DestructibleUnionImpl(EmplaceTag<0>, P&&... args)
732        : head(absl::forward<P>(args)...) {}
733    template <std::size_t I, class... P>
734    explicit constexpr DestructibleUnionImpl(EmplaceTag<I>, P&&... args)
735        : tail(EmplaceTag<I - 1>{}, absl::forward<P>(args)...) {}
736    ~DestructibleUnionImpl() {}
737    Head head;
738    TailUnion tail;
739  };
740  template <class... T>
741  using DestructibleUnion =
742      absl::conditional_t<std::is_destructible<Union<T...>>::value, Union<T...>,
743                          DestructibleUnionImpl<T...>>;
744  template <class H, class... T>
745  class VariantStateBase {
746   protected:
747    using Variant = variant<H, T...>;
748    template <class LazyH = H,
749              class ConstructibleH = absl::enable_if_t<
750                  std::is_default_constructible<LazyH>::value, LazyH>>
751    constexpr VariantStateBase() noexcept(
752        std::is_nothrow_default_constructible<ConstructibleH>::value)
753        : state_(EmplaceTag<0>()), index_(0) {}
754    template <std::size_t I, class... P>
755    explicit constexpr VariantStateBase(EmplaceTag<I> tag, P&&... args)
756        : state_(tag, absl::forward<P>(args)...), index_(I) {}
757    explicit constexpr VariantStateBase(NoopConstructorTag)
758        : state_(NoopConstructorTag()), index_(variant_npos) {}
759    void destroy() {}  
760    DestructibleUnion<H, T...> state_;
761    std::size_t index_;
762  };
763  using absl::internal::identity;
764  template <typename... Ts>
765  struct OverloadSet;
766  template <typename T, typename... Ts>
767  struct OverloadSet<T, Ts...> : OverloadSet<Ts...> {
768    using Base = OverloadSet<Ts...>;
769    static identity<T> Overload(const T&);
770    using Base::Overload;
771  };
772  template <>
773  struct OverloadSet<> {
774    static void Overload(...);
775  };
776  template <class T>
777  using LessThanResult = decltype(std::declval<T>() < std::declval<T>());
778  template <class T>
779  using GreaterThanResult = decltype(std::declval<T>() > std::declval<T>());
780  template <class T>
781  using LessThanOrEqualResult = decltype(std::declval<T>() <= std::declval<T>());
782  template <class T>
783  using GreaterThanOrEqualResult =
784      decltype(std::declval<T>() >= std::declval<T>());
785  template <class T>
786  using EqualResult = decltype(std::declval<T>() == std::declval<T>());
787  template <class T>
788  using NotEqualResult = decltype(std::declval<T>() != std::declval<T>());
789  using type_traits_internal::is_detected_convertible;
790  template <class... T>
791  using RequireAllHaveEqualT = absl::enable_if_t<
792      absl::conjunction<is_detected_convertible<bool, EqualResult, T>...>::value,
793      bool>;
794  template <class... T>
795  using RequireAllHaveNotEqualT =
796      absl::enable_if_t<absl::conjunction<is_detected_convertible<
797                            bool, NotEqualResult, T>...>::value,
798                        bool>;
799  template <class... T>
800  using RequireAllHaveLessThanT =
801      absl::enable_if_t<absl::conjunction<is_detected_convertible<
802                            bool, LessThanResult, T>...>::value,
803                        bool>;
804  template <class... T>
805  using RequireAllHaveLessThanOrEqualT =
806      absl::enable_if_t<absl::conjunction<is_detected_convertible<
807                            bool, LessThanOrEqualResult, T>...>::value,
808                        bool>;
809  template <class... T>
810  using RequireAllHaveGreaterThanOrEqualT =
811      absl::enable_if_t<absl::conjunction<is_detected_convertible<
812                            bool, GreaterThanOrEqualResult, T>...>::value,
813                        bool>;
814  template <class... T>
815  using RequireAllHaveGreaterThanT =
816      absl::enable_if_t<absl::conjunction<is_detected_convertible<
817                            bool, GreaterThanResult, T>...>::value,
818                        bool>;
819  template <typename T>
820  struct VariantHelper;
821  template <typename... Ts>
822  struct VariantHelper<variant<Ts...>> {
823    template <typename U>
824    using BestMatch = decltype(variant_internal::OverloadSet<Ts...>::Overload(
825        std::declval<U>()));
826    template <typename U>
827    struct CanAccept
828        : std::integral_constant<bool, !std::is_void<BestMatch<U>>::value> {};
829    template <typename Other>
830    struct CanConvertFrom;
831    template <typename... Us>
832    struct CanConvertFrom<variant<Us...>>
833        : public absl::conjunction<CanAccept<Us>...> {};
834  };
835  struct TrivialMoveOnly {
836    TrivialMoveOnly(TrivialMoveOnly&&) = default;
837  };
838  template <typename T>
839  struct IsTriviallyMoveConstructible
840      : std::is_move_constructible<Union<T, TrivialMoveOnly>> {};
841  template <class... T>
842  class VariantStateBaseDestructorNontrivial;
843  template <class... T>
844  class VariantMoveBaseNontrivial;
845  template <class... T>
846  class VariantCopyBaseNontrivial;
847  template <class... T>
848  class VariantMoveAssignBaseNontrivial;
849  template <class... T>
850  class VariantCopyAssignBaseNontrivial;
851  template <class... T>
852  using VariantStateBaseDestructor =
853      absl::conditional_t<std::is_destructible<Union<T...>>::value,
854                          VariantStateBase<T...>,
855                          VariantStateBaseDestructorNontrivial<T...>>;
856  template <class... T>
857  using VariantMoveBase = absl::conditional_t<
858      absl::disjunction<
859          absl::negation<absl::conjunction<std::is_move_constructible<T>...>>,
860          absl::conjunction<IsTriviallyMoveConstructible<T>...>>::value,
861      VariantStateBaseDestructor<T...>, VariantMoveBaseNontrivial<T...>>;
862  template <class... T>
863  using VariantCopyBase = absl::conditional_t<
864      absl::disjunction<
865          absl::negation<absl::conjunction<std::is_copy_constructible<T>...>>,
866          std::is_copy_constructible<Union<T...>>>::value,
867      VariantMoveBase<T...>, VariantCopyBaseNontrivial<T...>>;
868  template <class... T>
869  using VariantMoveAssignBase = absl::conditional_t<
870      absl::disjunction<
871          absl::conjunction<absl::is_move_assignable<Union<T...>>,
872                            std::is_move_constructible<Union<T...>>,
873                            std::is_destructible<Union<T...>>>,
874          absl::negation<absl::conjunction<std::is_move_constructible<T>...,
875                                           is_move_assignable<T>...>>>::value,
876      VariantCopyBase<T...>, VariantMoveAssignBaseNontrivial<T...>>;
877  template <class... T>
878  using VariantCopyAssignBase = absl::conditional_t<
879      absl::disjunction<
880          absl::conjunction<absl::is_copy_assignable<Union<T...>>,
881                            std::is_copy_constructible<Union<T...>>,
882                            std::is_destructible<Union<T...>>>,
883          absl::negation<absl::conjunction<std::is_copy_constructible<T>...,
884                                           is_copy_assignable<T>...>>>::value,
885      VariantMoveAssignBase<T...>, VariantCopyAssignBaseNontrivial<T...>>;
886  template <class... T>
887  using VariantBase = VariantCopyAssignBase<T...>;
888  template <class... T>
889  class VariantStateBaseDestructorNontrivial : protected VariantStateBase<T...> {
890   private:
891    using Base = VariantStateBase<T...>;
892   protected:
893    using Base::Base;
894    VariantStateBaseDestructorNontrivial() = default;
895    VariantStateBaseDestructorNontrivial(VariantStateBaseDestructorNontrivial&&) =
896        default;
897    VariantStateBaseDestructorNontrivial(
898        const VariantStateBaseDestructorNontrivial&) = default;
899    VariantStateBaseDestructorNontrivial& operator=(
900        VariantStateBaseDestructorNontrivial&&) = default;
901    VariantStateBaseDestructorNontrivial& operator=(
902        const VariantStateBaseDestructorNontrivial&) = default;
903    struct Destroyer {
904      template <std::size_t I>
905      void operator()(SizeT<I> i) const {
906        using Alternative =
907            typename absl::variant_alternative<I, variant<T...>>::type;
908        variant_internal::AccessUnion(self->state_, i).~Alternative();
909      }
910      void operator()(SizeT<absl::variant_npos> &bsol;*i*/) const {
911      }
912      VariantStateBaseDestructorNontrivial* self;
913    };
914    void destroy() { VisitIndices<sizeof...(T)>::Run(Destroyer{this}, index_); }
915    ~VariantStateBaseDestructorNontrivial() { destroy(); }
916   protected:
917    using Base::index_;
918    using Base::state_;
919  };
920  template <class... T>
921  class VariantMoveBaseNontrivial : protected VariantStateBaseDestructor<T...> {
922   private:
923    using Base = VariantStateBaseDestructor<T...>;
924   protected:
925    using Base::Base;
926    struct Construct {
927      template <std::size_t I>
928      void operator()(SizeT<I> i) const {
929        using Alternative =
930            typename absl::variant_alternative<I, variant<T...>>::type;
931        ::new (static_cast<void*>(&self->state_)) Alternative(
932            variant_internal::AccessUnion(absl::move(other->state_), i));
933      }
934      void operator()(SizeT<absl::variant_npos> &bsol;*i*/) const {}
935      VariantMoveBaseNontrivial* self;
936      VariantMoveBaseNontrivial* other;
937    };
938    VariantMoveBaseNontrivial() = default;
939    VariantMoveBaseNontrivial(VariantMoveBaseNontrivial&& other) noexcept(
940        absl::conjunction<std::is_nothrow_move_constructible<T>...>::value)
941        : Base(NoopConstructorTag()) {
942      VisitIndices<sizeof...(T)>::Run(Construct{this, &other}, other.index_);
943      index_ = other.index_;
944    }
945    VariantMoveBaseNontrivial(VariantMoveBaseNontrivial const&) = default;
946    VariantMoveBaseNontrivial& operator=(VariantMoveBaseNontrivial&&) = default;
947    VariantMoveBaseNontrivial& operator=(VariantMoveBaseNontrivial const&) =
948        default;
949   protected:
950    using Base::index_;
951    using Base::state_;
952  };
953  template <class... T>
954  class VariantCopyBaseNontrivial : protected VariantMoveBase<T...> {
955   private:
956    using Base = VariantMoveBase<T...>;
957   protected:
958    using Base::Base;
959    VariantCopyBaseNontrivial() = default;
960    VariantCopyBaseNontrivial(VariantCopyBaseNontrivial&&) = default;
961    struct Construct {
962      template <std::size_t I>
963      void operator()(SizeT<I> i) const {
964        using Alternative =
965            typename absl::variant_alternative<I, variant<T...>>::type;
966        ::new (static_cast<void*>(&self->state_))
967            Alternative(variant_internal::AccessUnion(other->state_, i));
968      }
969      void operator()(SizeT<absl::variant_npos> &bsol;*i*/) const {}
970      VariantCopyBaseNontrivial* self;
971      const VariantCopyBaseNontrivial* other;
972    };
973    VariantCopyBaseNontrivial(VariantCopyBaseNontrivial const& other)
974        : Base(NoopConstructorTag()) {
975      VisitIndices<sizeof...(T)>::Run(Construct{this, &other}, other.index_);
976      index_ = other.index_;
977    }
978    VariantCopyBaseNontrivial& operator=(VariantCopyBaseNontrivial&&) = default;
979    VariantCopyBaseNontrivial& operator=(VariantCopyBaseNontrivial const&) =
980        default;
981   protected:
982    using Base::index_;
983    using Base::state_;
984  };
985  template <class... T>
986  class VariantMoveAssignBaseNontrivial : protected VariantCopyBase<T...> {
987    friend struct VariantCoreAccess;
988   private:
989    using Base = VariantCopyBase<T...>;
990   protected:
991    using Base::Base;
992    VariantMoveAssignBaseNontrivial() = default;
993    VariantMoveAssignBaseNontrivial(VariantMoveAssignBaseNontrivial&&) = default;
994    VariantMoveAssignBaseNontrivial(const VariantMoveAssignBaseNontrivial&) =
995        default;
996    VariantMoveAssignBaseNontrivial& operator=(
997        VariantMoveAssignBaseNontrivial const&) = default;
998    VariantMoveAssignBaseNontrivial&
999    operator=(VariantMoveAssignBaseNontrivial&& other) noexcept(
1000        absl::conjunction<std::is_nothrow_move_constructible<T>...,
1001                          std::is_nothrow_move_assignable<T>...>::value) {
1002      VisitIndices<sizeof...(T)>::Run(
1003          VariantCoreAccess::MakeMoveAssignVisitor(this, &other), other.index_);
1004      return *this;
1005    }
1006   protected:
1007    using Base::index_;
1008    using Base::state_;
1009  };
1010  template <class... T>
1011  class VariantCopyAssignBaseNontrivial : protected VariantMoveAssignBase<T...> {
1012    friend struct VariantCoreAccess;
1013   private:
1014    using Base = VariantMoveAssignBase<T...>;
1015   protected:
1016    using Base::Base;
1017    VariantCopyAssignBaseNontrivial() = default;
1018    VariantCopyAssignBaseNontrivial(VariantCopyAssignBaseNontrivial&&) = default;
1019    VariantCopyAssignBaseNontrivial(const VariantCopyAssignBaseNontrivial&) =
1020        default;
1021    VariantCopyAssignBaseNontrivial& operator=(
1022        VariantCopyAssignBaseNontrivial&&) = default;
1023    VariantCopyAssignBaseNontrivial& operator=(
1024        const VariantCopyAssignBaseNontrivial& other) {
1025      VisitIndices<sizeof...(T)>::Run(
1026          VariantCoreAccess::MakeCopyAssignVisitor(this, other), other.index_);
1027      return *this;
1028    }
1029   protected:
1030    using Base::index_;
1031    using Base::state_;
1032  };
1033  template <class... Types>
1034  struct EqualsOp {
1035    const variant<Types...>* v;
1036    const variant<Types...>* w;
1037    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1038      return true;
1039    }
1040    template <std::size_t I>
1041    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1042      return VariantCoreAccess::Access<I>(*v) == VariantCoreAccess::Access<I>(*w);
1043    }
1044  };
1045  template <class... Types>
1046  struct NotEqualsOp {
1047    const variant<Types...>* v;
1048    const variant<Types...>* w;
1049    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1050      return false;
1051    }
1052    template <std::size_t I>
1053    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1054      return VariantCoreAccess::Access<I>(*v) != VariantCoreAccess::Access<I>(*w);
1055    }
1056  };
1057  template <class... Types>
1058  struct LessThanOp {
1059    const variant<Types...>* v;
1060    const variant<Types...>* w;
1061    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1062      return false;
1063    }
1064    template <std::size_t I>
1065    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1066      return VariantCoreAccess::Access<I>(*v) < VariantCoreAccess::Access<I>(*w);
1067    }
1068  };
1069  template <class... Types>
1070  struct GreaterThanOp {
1071    const variant<Types...>* v;
1072    const variant<Types...>* w;
1073    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1074      return false;
1075    }
1076    template <std::size_t I>
1077    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1078      return VariantCoreAccess::Access<I>(*v) > VariantCoreAccess::Access<I>(*w);
1079    }
1080  };
1081  template <class... Types>
1082  struct LessThanOrEqualsOp {
1083    const variant<Types...>* v;
1084    const variant<Types...>* w;
1085    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1086      return true;
1087    }
1088    template <std::size_t I>
1089    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1090      return VariantCoreAccess::Access<I>(*v) <= VariantCoreAccess::Access<I>(*w);
1091    }
1092  };
1093  template <class... Types>
1094  struct GreaterThanOrEqualsOp {
1095    const variant<Types...>* v;
1096    const variant<Types...>* w;
1097    constexpr bool operator()(SizeT<absl::variant_npos> &bsol;*v_i*/) const {
1098      return true;
1099    }
1100    template <std::size_t I>
1101    constexpr bool operator()(SizeT<I> &bsol;*v_i*/) const {
1102      return VariantCoreAccess::Access<I>(*v) >= VariantCoreAccess::Access<I>(*w);
1103    }
1104  };
1105  template <class... Types>
1106  struct SwapSameIndex {
1107    variant<Types...>* v;
1108    variant<Types...>* w;
1109    template <std::size_t I>
1110    void operator()(SizeT<I>) const {
1111      type_traits_internal::Swap(VariantCoreAccess::Access<I>(*v),
1112                                 VariantCoreAccess::Access<I>(*w));
1113    }
1114    void operator()(SizeT<variant_npos>) const {}
1115  };
1116  template <class... Types>
1117  struct Swap {
1118    variant<Types...>* v;
1119    variant<Types...>* w;
1120    void generic_swap() const {
1121      variant<Types...> tmp(std::move(*w));
1122      VariantCoreAccess::Destroy(*w);
1123      VariantCoreAccess::InitFrom(*w, std::move(*v));
1124      VariantCoreAccess::Destroy(*v);
1125      VariantCoreAccess::InitFrom(*v, std::move(tmp));
1126    }
1127    void operator()(SizeT<absl::variant_npos> &bsol;*w_i*/) const {
1128      if (!v->valueless_by_exception()) {
1129        generic_swap();
1130      }
1131    }
1132    template <std::size_t Wi>
1133    void operator()(SizeT<Wi> &bsol;*w_i*/) {
1134      if (v->index() == Wi) {
1135        VisitIndices<sizeof...(Types)>::Run(SwapSameIndex<Types...>{v, w}, Wi);
1136      } else {
1137        generic_swap();
1138      }
1139    }
1140  };
1141  template <typename Variant, typename = void, typename... Ts>
1142  struct VariantHashBase {
1143    VariantHashBase() = delete;
1144    VariantHashBase(const VariantHashBase&) = delete;
1145    VariantHashBase(VariantHashBase&&) = delete;
1146    VariantHashBase& operator=(const VariantHashBase&) = delete;
<span onclick='openModal()' class='match'>1147    VariantHashBase& operator=(VariantHashBase&&) = delete;
1148  };
1149  struct VariantHashVisitor {
1150    template <typename T>
</span>1151    size_t operator()(const T& t) {
1152      return std::hash<T>{}(t);
1153    }
1154  };
1155  template <typename Variant, typename... Ts>
1156  struct VariantHashBase<Variant,
1157                         absl::enable_if_t<absl::conjunction<
1158                             type_traits_internal::IsHashable<Ts>...>::value>,
1159                         Ts...> {
1160    using argument_type = Variant;
1161    using result_type = size_t;
1162    size_t operator()(const Variant& var) const {
1163      type_traits_internal::AssertHashEnabled<Ts...>();
1164      if (var.valueless_by_exception()) {
1165        return 239799884;
1166      }
1167      size_t result = VisitIndices<variant_size<Variant>::value>::Run(
1168          PerformVisitation<VariantHashVisitor, const Variant&>{
1169              std::forward_as_tuple(var), VariantHashVisitor{}},
1170          var.index());
1171      return result ^ var.index();
1172    }
1173  };
1174  }  
1175  ABSL_NAMESPACE_END
1176  }  
1177  #endif  
1178  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_4.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_4.h</div>
                </div>
                <div class="column column_space"><pre><code>1147    VariantHashBase& operator=(VariantHashBase&&) = delete;
1148  };
1149  struct VariantHashVisitor {
1150    template <typename T>
</pre></code></div>
                <div class="column column_space"><pre><code>1147    VariantHashBase& operator=(VariantHashBase&&) = delete;
1148  };
1149  struct VariantHashVisitor {
1150    template <typename T>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    