
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 264, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr&amp; FPath, TIntV&amp; NewDIdV,
3   const bool&amp; RecurseDirP, const int&amp; MxDocs,
4   const bool&amp; SaveDocP, const PNotify&amp; Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify-&gt;OnStatus(&quot;Creating Bow from file-path &quot; + FPath + &quot; ...&quot;);
7    TFFile FFile(FPath, &quot;&quot;, RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
11      Notify-&gt;OnStatus(TStr::Fmt(&quot;%d\r&quot;, Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn(&#x27;/&#x27;)){
18            TStr Str; DocNm.SplitOnCh(CatNm, &#x27;/&#x27;, Str);
19          } else if (DocNm.IsChIn(&#x27;\\&#x27;)){
20            TStr Str; DocNm.SplitOnCh(CatNm, &#x27;\\&#x27;, Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify-&gt;OnStatus(TStr::Fmt(&quot;%d&quot;, Docs));
29    Notify-&gt;OnStatus(&quot;Done.&quot;);
30    BowDocBs-&gt;AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr&amp; FPath, const bool&amp; RecurseDirP, const int&amp; MxDocs,
34   const PSwSet&amp; SwSet, const PStemmer&amp; Stemmer,
35   const int&amp; MxNGramLen, const int&amp; MnNGramFq,
36   const bool&amp; SaveDocP, const PNotify&amp; Notify){
37    PNGramBs NGramBs;
38    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
39      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
40       FPath, RecurseDirP, MxDocs,
41       MxNGramLen, MnNGramFq, SwSet, Stemmer);
42    }
43    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
44    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
45        RecurseDirP, MxDocs, SaveDocP, Notify);
46    return BowDocBs;
47  }
48  PBowDocBs TBowFl::LoadHtmlTxt(
49   const TStr&amp; FPath, const bool&amp; RecurseDirP, const int&amp; MxDocs,
50   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
51   const int&amp; MxNGramLen, const int&amp; MnNGramFq,
52   const bool&amp; SaveDocP, const PNotify&amp; Notify){
53    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
54    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
55    PNGramBs NGramBs;
56    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
57      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
58       FPath, RecurseDirP, MxDocs,
59       MxNGramLen, MnNGramFq, SwSet, Stemmer);
60    }
61    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
62    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
63        RecurseDirP, MxDocs, SaveDocP, Notify);
64    return BowDocBs;
65  }
66  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx&amp; BowSimMtx){
67    PBowDocBs BowDocBs=TBowDocBs::New();
68    int Docs=BowSimMtx-&gt;GetDocs();
69    BowDocBs-&gt;DocSpVV.Gen(Docs, 0);
70    for (int MtxDIdN=0; MtxDIdN&lt;Docs; MtxDIdN++){
71      int MtxDId=BowSimMtx-&gt;GetMtxDId(MtxDIdN);
72      int DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
73      IAssert(MtxDIdN==DId);
74      BowDocBs-&gt;DocSpVV.Add(TBowSpV::New(DId));
75      IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
76    }
77    BowDocBs-&gt;AssertOk();
78    return BowDocBs;
79  }
80  PBowDocBs TBowFl::LoadTabTxt(const TStr&amp; FNm, const int&amp; &amp;bsol;*MxDocs*/){
81    PBowDocBs BowDocBs=TBowDocBs::New();
82    PDm Dm=TDm::LoadFile(FNm);
83    for (int AttrN=0; AttrN&lt;Dm-&gt;GetAttrs(); AttrN++){
84      PTbVar Var=Dm-&gt;GetAttr(AttrN);
85      TStr VarNm=Var-&gt;GetNm();
86      PTbVarType VarType=Var-&gt;GetVarType();
87      EAssertRA(VarType-&gt;IsFlt(), &quot;Attribute must be continuous&quot;, VarNm);
88      BowDocBs-&gt;WordStrToDescH.AddKey(VarNm);
89    }
90    for (int ExN=0; ExN&lt;Dm-&gt;GetExs(); ExN++){
91      TStr DocNm=TInt::GetStr(ExN);
92      int DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
93      BowDocBs-&gt;DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
94      BowDocBs-&gt;DocCIdVV.Add(); IAssert(DId==BowDocBs-&gt;DocCIdVV.Len()-1);
95      TIntV&amp; DocCIdV=BowDocBs-&gt;DocCIdVV[DId];
96      DocCIdV.Gen(Dm-&gt;GetClasses(), 0);
97      for (int ClassN=0; ClassN&lt;Dm-&gt;GetClasses(); ClassN++){
98        TStr ValStr=Dm-&gt;GetClassValStr(ExN, ClassN);
99        int CId=BowDocBs-&gt;CatNmToFqH.AddKey(ValStr);
100        BowDocBs-&gt;CatNmToFqH[CId]++; DocCIdV.Add(CId);
101      }
102      DocCIdV.Sort();
103      PBowSpV DocSpV=BowDocBs-&gt;DocSpVV[DId];
104      DocSpV-&gt;GenMx(Dm-&gt;GetAttrs());
105      for (int AttrN=0; AttrN&lt;Dm-&gt;GetAttrs(); AttrN++){
106        TStr WordStr=Dm-&gt;GetAttr(AttrN)-&gt;GetNm();
107        int WId=BowDocBs-&gt;WordStrToDescH.GetKeyId(WordStr);
108        TTbVal Val=Dm-&gt;GetAttrVal(ExN, AttrN);
109        double Wgt=Val.GetFlt();
110        TBowWordDesc&amp; WordDesc=BowDocBs-&gt;WordStrToDescH[WId];
111        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
112        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
113        DocSpV-&gt;AddWIdWgt(WId, Wgt);
114      }
115      DocSpV-&gt;Sort();
116    }
117    BowDocBs-&gt;AssertOk();
118    return BowDocBs;
119  }
120  PBowDocBs TBowFl::LoadTsactTxt(const TStr&amp; FNm, const int&amp; MxDocs){
121    PBowDocBs BowDocBs=TBowDocBs::New();
122    PSIn SIn=TFIn::New(FNm);
123    printf(&quot;Loading &#x27;%s&#x27; ...\n&quot;, FNm.CStr());
124    if (!SIn-&gt;Eof()){
125      int CurDId=-1;
126      TIntH CurDocWIdToFqH(100);
127      char Ch=SIn-&gt;GetCh();
128      while ((!SIn-&gt;Eof())&amp;&amp;(!((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)))){
129        Ch=SIn-&gt;GetCh();}
130      while (!SIn-&gt;Eof()){
131        if (BowDocBs-&gt;DocSpVV.Len()%1000==0){
132          printf(&quot;%d transactions read\r&quot;, BowDocBs-&gt;DocSpVV.Len());}
133        IAssert((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;));
134        int TsactN=Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();
135        while ((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)){
136          TsactN=TsactN*10+Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();}
137        while (!((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;))){
138          IAssert((Ch==&#x27; &#x27;)||(Ch==&#x27;\t&#x27;)); Ch=SIn-&gt;GetCh();}
139        IAssert((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;));
140        int ItemN=Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();
141        while ((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)){
142          ItemN=ItemN*10+Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();}
143        while ((!SIn-&gt;Eof())&amp;&amp;(!((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)))){
144          Ch=SIn-&gt;GetCh();}
145        TStr DocNm=TInt::GetStr(TsactN);
146        int DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
147        TStr WordStr=TInt::GetStr(ItemN);
148        int WId=BowDocBs-&gt;WordStrToDescH.AddKey(WordStr);
149        BowDocBs-&gt;WordStrToDescH[WId].Fq++;
150        if (CurDId!=DId){
151          if (CurDId!=-1){
152            if ((MxDocs!=-1)&amp;&amp;(BowDocBs-&gt;GetDocs()&gt;=MxDocs-1)){break;}
153            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
154            int NewDId=BowDocBs-&gt;DocSpVV.Add(NewSpV);
155            IAssert(NewDId==CurDId);
156            for (int DocWIdN=0; DocWIdN&lt;CurDocWIdToFqH.Len(); DocWIdN++){
157              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
158              int WordFq=CurDocWIdToFqH[DocWIdN];
159              NewSpV-&gt;AddWIdWgt(WId, WordFq);
160            }
161            NewSpV-&gt;Sort();
162          }
163          CurDId=DId; CurDocWIdToFqH.Clr(false);
164        }
165        CurDocWIdToFqH.AddDat(WId)++;
166      }
167      if (CurDId!=-1){
168        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
169        BowDocBs-&gt;DocSpVV.Add(NewSpV);
170        for (int DocWIdN=0; DocWIdN&lt;CurDocWIdToFqH.Len(); DocWIdN++){
171          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
172          int WordFq=CurDocWIdToFqH[DocWIdN];
173          NewSpV-&gt;AddWIdWgt(WId, WordFq);
174        }
175        NewSpV-&gt;Sort();
176      }
177      printf(&quot;%d transactions read\n&quot;, BowDocBs-&gt;DocSpVV.Len());
178    }
179    printf(&quot;... Done.\n&quot;);
180    BowDocBs-&gt;AssertOk();
181    return BowDocBs;
182  }
183  PBowDocBs TBowFl::LoadSparseTxt(
184   const TStr&amp; DocDefFNm, const TStr&amp; WordDefFNm,
185   const TStr&amp; TrainDataFNm,
186   const int&amp; MxDocs){
187    PBowDocBs BowDocBs=TBowDocBs::New();
188    if (!DocDefFNm.Empty()){
189      PSIn SIn=TFIn::New(DocDefFNm);
190      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
191      Lx.GetSym(syInt, syEof);
192      while (Lx.Sym==syInt){
193        int DId=Lx.Int;
194        Lx.GetSym(syColon);
195        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
196        Lx.GetSym(syEoln);
197        Lx.GetSym(syInt, syEof);
198        int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
199        EAssertR(DId==NewDId, &quot;Document-Ids don&#x27;t match.&quot;);
200      }
201    }
202    if (!WordDefFNm.Empty()){
203      PSIn SIn=TFIn::New(WordDefFNm);
204      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
205      Lx.GetSym(syInt, syEof);
206      while (Lx.Sym==syInt){
207        int WId=Lx.Int;
208        Lx.GetSym(syColon);
209        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
210        Lx.GetSym(syEoln);
211        Lx.GetSym(syInt, syEof);
212        int NewWId=BowDocBs-&gt;WordStrToDescH.AddKey(WordStr);
213        BowDocBs-&gt;WordStrToDescH[NewWId].Fq=1;
214        EAssertR(WId==NewWId, &quot;Word-Ids don&#x27;t match.&quot;);
215      }
216    }
217    if (!TrainDataFNm.Empty()){
218      PSIn SIn=TFIn::New(TrainDataFNm);
219      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
220      Lx.GetSym(syInt, syEof);
221      while (Lx.Sym==syInt){
222        if ((MxDocs!=-1)&amp;&amp;(BowDocBs-&gt;GetDocs()&gt;=MxDocs)){break;}
223        int DId=Lx.Int;
224        PBowSpV NewSpV=TBowSpV::New(DId);
225        int NewDId=BowDocBs-&gt;DocSpVV.Add(NewSpV);
226        EAssertR(DId==NewDId, &quot;Document-Ids don&#x27;t match.&quot;);
227        Lx.GetSym(syInt, syEoln);
228        while (Lx.Sym==syInt){
229          int WId=Lx.Int;
230          Lx.GetSym(syColon, syInt, syEoln);
231          double WordFq=1;
232          if (Lx.Sym==syColon){
233            WordFq=Lx.GetFlt();
234            Lx.GetSym(syInt, syEoln);
235          }
236          NewSpV-&gt;AddWIdWgt(WId, WordFq);
237        }
238        NewSpV-&gt;Trunc();
239        Lx.GetSym(syInt, syEof);
240      }
241    }
242    BowDocBs-&gt;AssertOk();
243    return BowDocBs;
244  }
245  PBowDocBs TBowFl::LoadSvmLightTxt(
246   const TStr&amp; DocDefFNm, const TStr&amp; WordDefFNm,
247   const TStr&amp; TrainDataFNm, const TStr&amp; TestDataFNm,
248   const int&amp; MxDocs){ 
249    PBowDocBs BowDocBs=TBowDocBs::New();
250    int MOneCId=BowDocBs-&gt;CatNmToFqH.AddKey(&quot;-1&quot;);
251    int POneCId=BowDocBs-&gt;CatNmToFqH.AddKey(&quot;+1&quot;);
252    bool DocDefP=false;
253    if (!DocDefFNm.Empty()&amp;&amp;(TFile::Exists(DocDefFNm))){
254      PSIn SIn=TFIn::New(DocDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syInt, syEof);
257      while (Lx.Sym==syInt){
258        int DId=Lx.Int;
259        Lx.GetSym(syColon);
260        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syInt, syEof);
263        int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
264        EAssertR(DId==NewDId, &quot;Document-Ids don&#x27;t match.&quot;);
265      }
266      DocDefP=true;
267    }
268    if (!WordDefFNm.Empty()&amp;&amp;(TFile::Exists(WordDefFNm))){
269      BowDocBs-&gt;WordStrToDescH.AddDat(&quot;Undef&quot;).Fq=0; 
270      PSIn SIn=TFIn::New(WordDefFNm);
271      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
272      Lx.GetSym(syQStr, syEof);
273      while (Lx.Sym==syQStr){
274        TStr WordStr=Lx.Str;
275        Lx.GetSym(syInt); int WId=Lx.Int;
276        Lx.GetSym(syInt); int WordFq=Lx.Int;
277        Lx.GetSym(syEoln);
278        Lx.GetSym(syQStr, syEof);
279        int NewWId=BowDocBs-&gt;WordStrToDescH.AddKey(WordStr);
280        EAssertR(WId==NewWId, &quot;Word-Ids don&#x27;t match.&quot;);
281        BowDocBs-&gt;WordStrToDescH[WId].Fq=WordFq;
282      }
283    }
284    int MxWId=-1; TIntIntH WIdToFqH;
285    if (!TrainDataFNm.Empty()){
286      PSIn SIn=TFIn::New(TrainDataFNm);
287      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
288      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
289      while (Lx.Sym==syInt){
290        TStr DocNm=TInt::GetStr(BowDocBs-&gt;GetDocs());
291        int DId;
292        if (DocDefP){
293          DId=BowDocBs-&gt;DocNmToDescStrH.GetKeyId(DocNm);
294        } else {
295          DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
296        }
297        BowDocBs-&gt;TrainDIdV.Add(DId);
298        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
299        BowDocBs-&gt;DocCIdVV.Add(); IAssert(DId==BowDocBs-&gt;DocCIdVV.Len()-1);
300        BowDocBs-&gt;DocCIdVV.Last().Gen(1, 0);
301        BowDocBs-&gt;DocCIdVV.Last().Add(CId);
302        PBowSpV SpV=TBowSpV::New(DId);
303        BowDocBs-&gt;DocSpVV.Add(SpV); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
304        Lx.GetSym(syInt, syEoln);
305        while (Lx.Sym==syInt){
306          int WId=Lx.Int;
307          Lx.GetSym(syColon);
308          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
309          Lx.GetSym(syInt, syEoln);
310          SpV-&gt;AddWIdWgt(WId, WordFq);
311          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
312          WIdToFqH.AddDat(WId)++;
313        }
314        if (!Lx.CmtStr.Empty()){
315          TStr CmtStr=Lx.CmtStr;
316          static TStr DocNmPrefixStr=&quot;docDesc=&quot;;
317          if (CmtStr.IsPrefix(DocNmPrefixStr)){
318            TStr NewDocNm=
319             TStr(&quot;D&quot;)+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
320            BowDocBs-&gt;DocNmToDescStrH.DelKey(DocNm);
321            int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(NewDocNm);
322            IAssert(DId==NewDId);
323          }
324        }
325        SpV-&gt;Trunc();
326        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
327      }
328    }
329    if (!TestDataFNm.Empty()){
330      PSIn SIn=TFIn::New(TestDataFNm);
331      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
332      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
333      while (Lx.Sym==syInt){
334        TStr DocNm=TInt::GetStr(BowDocBs-&gt;GetDocs());
335        int DId;
336        if (DocDefP){
337          DId=BowDocBs-&gt;DocNmToDescStrH.GetKeyId(DocNm);
338        } else {
339          DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
340        }
341        BowDocBs-&gt;TestDIdV.Add(DId);
342        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
343        BowDocBs-&gt;DocCIdVV.Add(); IAssert(DId==BowDocBs-&gt;DocCIdVV.Len()-1);
344        BowDocBs-&gt;DocCIdVV.Last().Gen(1, 0);
<span onclick='openModal()' class='match'>345        BowDocBs-&gt;DocCIdVV.Last().Add(CId);
346        PBowSpV SpV=TBowSpV::New(DId);
347        BowDocBs-&gt;DocSpVV.Add(SpV); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
348        Lx.GetSym(syInt, syEoln);
349        while (Lx.Sym==syInt){
350          int WId=Lx.Int;
351          Lx.GetSym(syColon);
352          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
353          Lx.GetSym(syInt, syEoln);
354          SpV-&gt;AddWIdWgt(WId, WordFq);
355          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
356          WIdToFqH.AddDat(WId)++;
357        }
358        if (!Lx.CmtStr.Empty()){
359          TStr CmtStr=Lx.CmtStr;
360          static TStr DocNmPrefixStr=&quot;docDesc=&quot;;
361          if (CmtStr.IsPrefix(DocNmPrefixStr)){
362            TStr NewDocNm=
363             TStr(&quot;D&quot;)+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
364            BowDocBs-&gt;DocNmToDescStrH.DelKey(DocNm);
365            int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(NewDocNm);
366            IAssert(DId==NewDId);
367          }
368        }
369        SpV-&gt;Trunc();
370        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
371      }
372    }
373    for (int WId=0; WId&lt;=MxWId; WId++){
</span>374      if (!BowDocBs-&gt;IsWId(WId)){
375        TStr WordStr=TInt::GetStr(WId, &quot;W%d&quot;);
376        int _WId=BowDocBs-&gt;AddWordStr(WordStr);
377        IAssert(WId==_WId);
378        TInt Fq;
379        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
380          BowDocBs-&gt;PutWordFq(WId, Fq);
381        }
382      }
383    }
384    BowDocBs-&gt;AssertOk();
385    return BowDocBs;
386  }
387  PBowDocBs TBowFl::LoadCpdTxt(
388   const PSIn&amp; CpdSIn, const int&amp; MxDocs,
389   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
390   const int&amp; MxNGramLen, const int&amp; MnNGramFq){
391    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
392    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
393    PNGramBs NGramBs;
394    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
395      NGramBs=TNGramBs::GetNGramBsFromCpd(
396       CpdSIn, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
397    }
398    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
399    printf(&quot;Load Bag-Of-Words from Compact-Documents ...\n&quot;);
400    TIntH DocWIdToFqH(100); CpdSIn-&gt;Reset();
401    PSIn CpDocSIn=TCpDoc::FFirstCpd(CpdSIn); PCpDoc CpDoc; int Docs=0;
402    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
403      Docs++; if (Docs%100==0){printf(&quot;  %d\r&quot;, Docs);}
404      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
405      TStr DocNm=CpDoc-&gt;GetDocNm();
406      TStrV CatNmV;
407      for (int CatN=0; CatN&lt;CpDoc-&gt;GetCats(); CatN++){
408        CatNmV.Add(CpDoc-&gt;GetCatNm(CatN));
409      }
410      TStr DocStr=CpDoc-&gt;GetTxtStr();
411      TStr DateStr=CpDoc-&gt;GetDateStr();
412      int DId=BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocStr, false);
413      BowDocBs-&gt;PutDateStr(DId, DateStr);
414    }
415    printf(&quot;  %d\nDone.\n&quot;, Docs);
416    BowDocBs-&gt;AssertOk();
417    return BowDocBs;
418  }
419  PBowDocBs TBowFl::LoadCpdTxt(
420   const TStr&amp; CpdFNm, const int&amp; MxDocs,
421   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
422   const int&amp; MxNGramLen, const int&amp; MnNGramFq){
423    PSIn CpdSIn=TFIn::New(CpdFNm);
424    return TBowFl::LoadCpdTxt(
425     CpdSIn, MxDocs, SwSetTypeNm, StemmerTypeNm, MxNGramLen, MnNGramFq);
426  }
427  void TBowFl::SaveCpdToLnDocTxt(const TStr&amp; InCpdFNm, const TStr&amp; OutLnDocFNm){
428    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
429    PSIn CpDocSIn=TCpDoc::FFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
430    printf(&quot;Saving &#x27;%s&#x27; to &#x27;%s&#x27; ...\n&quot;, InCpdFNm.CStr(), OutLnDocFNm.CStr());
431    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
432      Docs++; if (Docs%100==0){printf(&quot;%d Docs\r&quot;, Docs);}
433      TStr DocNm=CpDoc-&gt;GetDocNm();
434      DocNm=TStr::GetFNmStr(DocNm);
435      DocNm.ChangeChAll(&#x27; &#x27;, &#x27;_&#x27;);
436      TStrV CatNmV;
437      for (int CatN=0; CatN&lt;CpDoc-&gt;GetCats(); CatN++){
438        CatNmV.Add(CpDoc-&gt;GetCatNm(CatN));}
439      TChA DocChA=CpDoc-&gt;GetTxtStr();
440      DocChA.ChangeCh(&#x27;\r&#x27;, &#x27; &#x27;);
441      DocChA.ChangeCh(&#x27;\n&#x27;, &#x27; &#x27;);
442      fprintf(fOut, &quot;%s&quot;, DocNm.CStr());
443      for (int CatN=0; CatN&lt;CatNmV.Len(); CatN++){
444        fprintf(fOut, &quot; !%s&quot;, CatNmV[CatN].CStr());}
445      fprintf(fOut, &quot; %s\n&quot;, DocChA.CStr());
446    }
447    printf(&quot;%d Docs\nDone.\n&quot;, Docs);
448  }
449  PBowDocBs TBowFl::LoadTBsTxt(
450   const TStr&amp; TBsFNm, const int&amp; MxDocs,
451   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
452   const int&amp; MxNGramLen, const int&amp; MnNGramFq){
453    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
454    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
455    PNGramBs NGramBs;
456    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
457      NGramBs=TNGramBs::GetNGramBsFromTBs(
458       TBsFNm, MxDocs,
459       MxNGramLen, MnNGramFq, SwSet, Stemmer);
460    }
461    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
462    TStr TxtBsNm=TBsFNm.GetFBase();
463    TStr TxtBsFPath=TBsFNm.GetFPath();
464    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
465    TBlobPt TxtBsTrvBlobPt=TxtBs-&gt;FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
466    while (TxtBs-&gt;FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
467      Docs++; if (Docs%100==0){printf(&quot;%d\r&quot;, Docs);}
468      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
469      TStr DocNm; TStr DocStr;
470      TxtBs-&gt;GetDocNmStr(TxtBsDocId, DocNm, DocStr);
471      BowDocBs-&gt;AddHtmlDoc(DocNm, TStrV(), DocStr, false);
472    }
473    BowDocBs-&gt;AssertOk();
474    return BowDocBs;
475  }
476  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr&amp; LnDocFNm,
477   TIntV&amp; NewDIdV, const bool&amp; NamedP, const int&amp; MxDocs, const bool&amp; SaveDocP) {
478    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=&#x27; &#x27;; int Docs=0;
479    while (!FIn.Eof()){
480      Docs++; if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
481      printf(&quot;%d\r&quot;, Docs);
482      TChA DocNm;
483      Ch=FIn.GetCh();
484      if (NamedP){
485        while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)&amp;&amp;(Ch!=&#x27; &#x27;)){
486          DocNm+=Ch; Ch=FIn.GetCh();}
487        DocNm.Trunc();
488        if (DocNm.Empty()){Docs--; continue;}
489      } else {
490          DocNm = TInt::GetStr(Docs);
491      }
492      TStrV CatNmV;
493      forever {
494        while ((!FIn.Eof())&amp;&amp;(Ch==&#x27; &#x27;)){Ch=FIn.GetCh();}
495        if (Ch==&#x27;!&#x27;){
496          if (!FIn.Eof()){Ch=FIn.GetCh();}
497          TChA CatNm;
498          while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)&amp;&amp;(Ch!=&#x27; &#x27;)){
499            CatNm+=Ch; Ch=FIn.GetCh();}
500          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
501        } else {
502          break;
503        }
504      }
505      TChA DocChA;
506      while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)){
507        DocChA+=Ch; Ch=FIn.GetCh();}
508      if (DocNm.Empty()&amp;&amp;DocChA.Empty()){
509        continue;}
510      NewDIdV.Add(BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
511    }
512    BowDocBs-&gt;AssertOk();
513    printf(&quot;\n&quot;);
514  }
515  PBowDocBs TBowFl::LoadLnDocTxt(
516   const TStr&amp; LnDocFNm, const bool&amp; NamedP, const int&amp; MxDocs,
517   const PSwSet&amp; SwSet, const PStemmer&amp; Stemmer,
518   const int&amp; MxNGramLen, const int&amp; MnNGramFq, const bool&amp; SaveDocP){
519    PNGramBs NGramBs;
520    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
521      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
522       LnDocFNm, NamedP, MxDocs,
523       MxNGramLen, MnNGramFq, SwSet, Stemmer);
524    }
525    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
526    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
527    return BowDocBs;
528  }
529  PBowDocBs TBowFl::LoadLnDocTxt(
530   const TStr&amp; LnDocFNm, const bool&amp; NamedP, const int&amp; MxDocs,
531   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
532   const int&amp; MxNGramLen, const int&amp; MnNGramFq, const bool&amp; SaveDocP){
533    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
534    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
535    PNGramBs NGramBs;
536    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
537      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
538       LnDocFNm, NamedP, MxDocs,
539       MxNGramLen, MnNGramFq, SwSet, Stemmer);
540    }
541    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
542    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
543    return BowDocBs;
544  }
545  void TBowFl::SaveLnDocTxt(const PBowDocBs&amp; BowDocBs, const TStr&amp; FNm, const bool&amp; UseDocStrP){
546    TFOut SOut(FNm);
547    int Docs=BowDocBs-&gt;GetDocs();
548    for (int DId=0; DId&lt;Docs; DId++){
549      printf(&quot;%d/%d\r&quot;, DId+1, Docs);
550      TStr DocNm=TStr::GetFNmStr(BowDocBs-&gt;GetDocNm(DId));
551      SOut.PutStr(DocNm);
552      for (int CIdN=0; CIdN&lt;BowDocBs-&gt;GetDocCIds(DId); CIdN++){
553        int CId=BowDocBs-&gt;GetDocCId(DId, CIdN);
554        TStr CatNm=TStr::GetFNmStr(BowDocBs-&gt;GetCatNm(CId));
555        SOut.PutCh(&#x27; &#x27;); SOut.PutCh(&#x27;!&#x27;); SOut.PutStr(CatNm);
556      }
557      if (UseDocStrP){
558        TStr DocStr=BowDocBs-&gt;GetDocStr(DId);
559        SOut.PutCh(&#x27; &#x27;); SOut.PutStr(DocStr);
560      } else {
561          int DocWIds=BowDocBs-&gt;GetDocWIds(DId);
562          int WId; double WordFq;
563          for (int DocWIdN=0; DocWIdN&lt;DocWIds; DocWIdN++){
564            BowDocBs-&gt;GetDocWIdFq(DId, DocWIdN, WId, WordFq);
565            TStr WordStr=BowDocBs-&gt;GetWordStr(WId);
566            for (int WordFqN=0; WordFqN&lt;WordFq; WordFqN++){
567              SOut.PutCh(&#x27; &#x27;); SOut.PutStr(WordStr);
568            }
569          }
570      }
571      SOut.PutLn();
572    }
573    printf(&quot;\n&quot;);
574  }
575  PBowDocBs TBowFl::LoadReuters21578Txt(
576   const TStr&amp; FPath, const int&amp; MxDocs,
577   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
578   const int&amp; MxNGramLen, const int&amp; MnNGramFq, const bool&amp; SaveDocP){
579    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
580    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
581    PNGramBs NGramBs;
582    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
583      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
584       FPath, MxDocs,
585       MxNGramLen, MnNGramFq, SwSet, Stemmer);
586    }
587    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
588    TFFile FFile(FPath, &quot;.SGM&quot;, false); TStr FNm; int Docs=0;
589    while (FFile.Next(FNm)){
590      printf(&quot;Processing file &#x27;%s&#x27;\n&quot;, FNm.CStr());
591      TIntH DocWIdToFqH(100);
592      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
593      for (int LDocN=0; LDocN&lt;LDocV.Len(); LDocN++){
594        Docs++; if (Docs%100==0){printf(&quot;%d\r&quot;, Docs);}
595        if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
596        PXmlDoc Doc=LDocV[LDocN];
597        PXmlTok DocTok=Doc-&gt;GetTok();
598        TStr DocNm=DocTok-&gt;GetArgVal(&quot;NEWID&quot;);
599        TStrV CatNmV;
600        TXmlTokV TopicsTokV; Doc-&gt;GetTagTokV(&quot;REUTERS|TOPICS|D&quot;, TopicsTokV);
601        for (int TopicsTokN=0; TopicsTokN&lt;TopicsTokV.Len(); TopicsTokN++){
602          TStr CatNm=TopicsTokV[TopicsTokN]-&gt;GetTokStr(false);
603          CatNmV.Add(CatNm);
604        }
605        PXmlTok DocStrTok=Doc-&gt;GetTagTok(&quot;REUTERS|TEXT&quot;);
606        TStr DocStr=DocStrTok-&gt;GetTokStr(false);
607        int DId=BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
608        if ((DocTok-&gt;GetArgVal(&quot;LEWISSPLIT&quot;)==&quot;TRAIN&quot;)&amp;&amp;(DocTok-&gt;GetArgVal(&quot;TOPICS&quot;)==&quot;YES&quot;)){
609          BowDocBs-&gt;AddTrainDId(DId);}
610        if ((DocTok-&gt;GetArgVal(&quot;LEWISSPLIT&quot;)==&quot;TEST&quot;)&amp;&amp;(DocTok-&gt;GetArgVal(&quot;TOPICS&quot;)==&quot;YES&quot;)){
611          BowDocBs-&gt;AddTestDId(DId);}
612      }
613      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
614    }
615    BowDocBs-&gt;AssertOk();
616    return BowDocBs;
617  }
618  PBowDocBs TBowFl::LoadCiaWFBTxt(
619   const TStr&amp; FPath, const int&amp; MxDocs,
620   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
621   const int&amp; MxNGramLen, const int&amp; MnNGramFq){
622    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
623    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
624    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
625    PNGramBs NGramBs;
626    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
627      TStrV HtmlStrV;
628      for (int CountryN=0; CountryN&lt;CiaWFBBs-&gt;GetCountries(); CountryN++){
629        PCiaWFBCountry CiaWFBCountry=CiaWFBBs-&gt;GetCountry(CountryN);
630        HtmlStrV.Add(CiaWFBCountry-&gt;GetDescStr());
631      }
632      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
633       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
634    }
635    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
636    for (int CountryN=0; CountryN&lt;CiaWFBBs-&gt;GetCountries(); CountryN++){
637      if (CountryN==MxDocs){break;}
638      PCiaWFBCountry CiaWFBCountry=CiaWFBBs-&gt;GetCountry(CountryN);
639      TStr CountryNm=CiaWFBCountry-&gt;GetCountryNm();
640      TStr DescStr=CiaWFBCountry-&gt;GetDescStr();
641      TStr CatNm=CiaWFBCountry-&gt;GetFldVal(&quot;Map references&quot;).GetTrunc();
642      TStrV CatNmV; CatNmV.Add(CatNm);
643      BowDocBs-&gt;AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
644    }
645    BowDocBs-&gt;AssertOk();
646    return BowDocBs;
647  }
648  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs&amp; BowDocBs,
649   const PBowDocWgtBs&amp; BowDocWgtBs, const TStr&amp; FNm,
650   const TStr&amp; CatFNm, const TIntV&amp; _DIdV) {
651    TIntV DIdV;
652    if (_DIdV.Empty()){
653      BowDocBs-&gt;GetAllDIdV(DIdV);
654    } else {
655      DIdV=_DIdV;
656    }
657    TFOut WdMapSOut(TStr::PutFExt(FNm, &quot;.row-to-word-map.dat&quot;));
658    for (int WId = 0; WId &lt; BowDocWgtBs-&gt;GetWords(); WId++) {
659      TStr WdStr = BowDocBs-&gt;GetWordStr(WId);
660      WdMapSOut.PutStrLn(TStr::Fmt(&quot;%d %s&quot;, WId+1,  WdStr.CStr()));
661    }
662    WdMapSOut.Flush();
663    TFOut DocMapSOut(TStr::PutFExt(FNm, &quot;.col-to-docName-map.dat&quot;));
664    for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++) {
665      const int DId = DIdV[DocN];
666      TStr DocNm = BowDocBs-&gt;GetDocNm(DId);
667      DocMapSOut.PutStrLn(TStr::Fmt(&quot;%d %d %s&quot;, DocN, DId,  DocNm.CStr()));
668    }
669    DocMapSOut.Flush();
670    TFOut SOut(FNm);
671    for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++){
672      const int DId = DIdV[DocN];
673      PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DId);
674      const int DocWIds = DocSpV-&gt;GetWIds();
675      for (int DocWIdN=0; DocWIdN&lt;DocWIds; DocWIdN++){
676        const int WId = DocSpV-&gt;GetWId(DocWIdN);
677        const double WordWgt = DocSpV-&gt;GetWgt(DocWIdN);
678        SOut.PutStrLn(TStr::Fmt(&quot;%d %d %.16f&quot;, WId+1, DocN+1, WordWgt));
679      }
680    }
681    SOut.Flush();
682    if (!CatFNm.Empty()) {
683      TFOut CatSOut(CatFNm);
684      for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++){
685        const int DId = DIdV[DocN];
686        const int DocCIds = BowDocBs-&gt;GetDocCIds(DId);
687        for (int DocCIdN=0; DocCIdN&lt;DocCIds; DocCIdN++){
688          const int CId = BowDocBs-&gt;GetDocCId(DId, DocCIdN);
689          const double CatWgt = 1.0;
690          CatSOut.PutStrLn(TStr::Fmt(&quot;%d %d %.16f&quot;, CId+1, DocN+1, CatWgt));
691        }
692      }
693      CatSOut.Flush();
694    }
695  }
696  PBowDocBs TBowFl::LoadTabTxt(
697   const TStr&amp; FNm, const TStr&amp; SsFmtNm, const int&amp; Recs,
698   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
699   const int&amp; MxNGramLen, const int&amp; MnNGramFq,
700   const int&amp; IdFldN, const TStr&amp; IdFldNm,
701   const TIntV&amp; CatFldNV, const TStrV&amp; CatFldNmV,
702   const TIntV&amp; TxtFldNV, const TStrV&amp; TxtFldNmV){
703    TSsFmt SsFmt=TSs::GetSsFmtFromStr(SsFmtNm);
704    PSs Ss=TSs::LoadTxt(SsFmt, FNm);
705    int FinalIdFldN=IdFldN;
706    if ((FinalIdFldN==-1)&amp;&amp;(!IdFldNm.Empty())){
707      FinalIdFldN=Ss-&gt;GetFldX(IdFldNm);
708    }
709    TIntV FinalCatFldNV=CatFldNV;
710    for (int CatN=0; CatN&lt;CatFldNmV.Len(); CatN++){
711      int CatFldN=Ss-&gt;GetFldX(CatFldNmV[CatN]);
712      FinalCatFldNV.Add(CatFldN);
713    }
714    FinalCatFldNV.Sort();
715    TIntV FinalTxtFldNV=TxtFldNV;
716    for (int TxtN=0; TxtN&lt;TxtFldNmV.Len(); TxtN++){
717      int TxtFldN=Ss-&gt;GetFldX(TxtFldNmV[TxtN]);
718      FinalTxtFldNV.Add(TxtFldN);
719    }
720    FinalTxtFldNV.Sort();
721    TStrV DocNmV;
722    TVec&lt;TStrV&gt; CatNmVV;
723    TStrV DocStrV;
724    for (int Y=1; Y&lt;Ss-&gt;GetYLen(); Y++){
725      TStr DocNm;
726      if (FinalIdFldN==-1){
727        DocNm=TInt::GetStr(Y);
728      } else {
729        DocNm=Ss-&gt;GetVal(FinalIdFldN, Y);
730      }
731      DocNmV.Add(DocNm);
732      TStrV CatNmV;
733      for (int CatN=0; CatN&lt;FinalCatFldNV.Len(); CatN++){
734        int CatFldN=FinalCatFldNV[CatN];
735        TStr CatNm=Ss-&gt;GetVal(CatFldN, Y);
736        if (!CatNm.Empty()){
737          CatNmV.Add(CatNm);
738        }
739      }
740      CatNmVV.Add(CatNmV);
741      TChA DocChA;
742      for (int TxtN=0; TxtN&lt;FinalTxtFldNV.Len(); TxtN++){
743        int TxtFldN=FinalTxtFldNV[TxtN];
744        TStr TxtStr=Ss-&gt;GetVal(TxtFldN, Y);
745        if (!DocChA.Empty()){DocChA+=&quot; &lt;br&gt; &quot;;}
746        if (!TxtStr.Empty()){DocChA+=TxtStr;}
747      }
748      DocStrV.Add(DocChA);
749    }
750    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
751    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
752    PNGramBs NGramBs;
753    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
754      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
755       DocStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
756    }
757    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
758    for (int DocN=0; DocN&lt;DocNmV.Len(); DocN++){
759      BowDocBs-&gt;AddHtmlDoc(DocNmV[DocN], CatNmVV[DocN], DocStrV[DocN], true);
760    }
761    BowDocBs-&gt;AssertOk();
762    return BowDocBs;
763  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowflx.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr&amp; FPath, TIntV&amp; NewDIdV,
3   const bool&amp; RecurseDirP, const int&amp; MxDocs,
4   const bool&amp; SaveDocP, const PNotify&amp; Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify-&gt;OnStatus(&quot;Creating Bow from file-path &quot; + FPath + &quot; ...&quot;);
7    TFFile FFile(FPath, &quot;&quot;, RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
11      Notify-&gt;OnStatus(TStr::Fmt(&quot;%d\r&quot;, Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn(&#x27;/&#x27;)){
18            TStr Str; DocNm.SplitOnCh(CatNm, &#x27;/&#x27;, Str);
19          } else if (DocNm.IsChIn(&#x27;\\&#x27;)){
20            TStr Str; DocNm.SplitOnCh(CatNm, &#x27;\\&#x27;, Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify-&gt;OnStatus(TStr::Fmt(&quot;%d&quot;, Docs));
29    Notify-&gt;OnStatus(&quot;Done.&quot;);
30    BowDocBs-&gt;AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr&amp; FPath, const bool&amp; RecurseDirP, const int&amp; MxDocs,
34   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
35   const int&amp; MxNGramLen, const int&amp; MnNGramFq,
36   const bool&amp; SaveDocP, const PNotify&amp; Notify){
37    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
38    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
39    PNGramBs NGramBs;
40    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
41      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
42       FPath, RecurseDirP, MxDocs,
43       MxNGramLen, MnNGramFq, SwSet, Stemmer, Notify);
44    }
45    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
46    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
47        RecurseDirP, MxDocs, SaveDocP, Notify);
48    return BowDocBs;
49  }
50  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx&amp; BowSimMtx){
51    PBowDocBs BowDocBs=TBowDocBs::New();
52    int Docs=BowSimMtx-&gt;GetDocs();
53    BowDocBs-&gt;DocSpVV.Gen(Docs, 0);
54    for (int MtxDIdN=0; MtxDIdN&lt;Docs; MtxDIdN++){
55      int MtxDId=BowSimMtx-&gt;GetMtxDId(MtxDIdN);
56      int DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
57      IAssert(MtxDIdN==DId);
58      BowDocBs-&gt;DocSpVV.Add(TBowSpV::New(DId));
59      IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
60    }
61    BowDocBs-&gt;AssertOk();
62    return BowDocBs;
63  }
64  PBowDocBs TBowFl::LoadTabTxt(const TStr&amp; FNm, const int&amp; &amp;bsol;*MxDocs*/){
65    PBowDocBs BowDocBs=TBowDocBs::New();
66    PDm Dm=TDm::LoadFile(FNm);
67    for (int AttrN=0; AttrN&lt;Dm-&gt;GetAttrs(); AttrN++){
68      PTbVar Var=Dm-&gt;GetAttr(AttrN);
69      TStr VarNm=Var-&gt;GetNm();
70      PTbVarType VarType=Var-&gt;GetVarType();
71      EAssertRA(VarType-&gt;IsFlt(), &quot;Attribute must be continuous&quot;, VarNm);
72      BowDocBs-&gt;WordStrToDescH.AddKey(VarNm);
73    }
74    for (int ExN=0; ExN&lt;Dm-&gt;GetExs(); ExN++){
75      TStr DocNm=TInt::GetStr(ExN);
76      int DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
77      BowDocBs-&gt;DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
78      BowDocBs-&gt;DocCIdVV.Add(); IAssert(DId==BowDocBs-&gt;DocCIdVV.Len()-1);
79      TIntV&amp; DocCIdV=BowDocBs-&gt;DocCIdVV[DId];
80      DocCIdV.Gen(Dm-&gt;GetClasses(), 0);
81      for (int ClassN=0; ClassN&lt;Dm-&gt;GetClasses(); ClassN++){
82        TStr ValStr=Dm-&gt;GetClassValStr(ExN, ClassN);
83        int CId=BowDocBs-&gt;CatNmToFqH.AddKey(ValStr);
84        BowDocBs-&gt;CatNmToFqH[CId]++; DocCIdV.Add(CId);
85      }
86      DocCIdV.Sort();
87      PBowSpV DocSpV=BowDocBs-&gt;DocSpVV[DId];
88      DocSpV-&gt;GenMx(Dm-&gt;GetAttrs());
89      for (int AttrN=0; AttrN&lt;Dm-&gt;GetAttrs(); AttrN++){
90        TStr WordStr=Dm-&gt;GetAttr(AttrN)-&gt;GetNm();
91        int WId=BowDocBs-&gt;WordStrToDescH.GetKeyId(WordStr);
92        TTbVal Val=Dm-&gt;GetAttrVal(ExN, AttrN);
93        double Wgt=Val.GetFlt();
94        TBowWordDesc&amp; WordDesc=BowDocBs-&gt;WordStrToDescH[WId];
95        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
96        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
97        DocSpV-&gt;AddWIdWgt(WId, Wgt);
98      }
99      DocSpV-&gt;Sort();
100    }
101    BowDocBs-&gt;AssertOk();
102    return BowDocBs;
103  }
104  PBowDocBs TBowFl::LoadTsactTxt(const TStr&amp; FNm, const int&amp; MxDocs){
105    PBowDocBs BowDocBs=TBowDocBs::New();
106    PSIn SIn=TFIn::New(FNm);
107    printf(&quot;Loading %s ...\n&quot;, FNm.CStr());
108    if (!SIn-&gt;Eof()){
109      int CurDId=-1;
110      TIntH CurDocWIdToFqH(100);
111      char Ch=SIn-&gt;GetCh();
112      while ((!SIn-&gt;Eof())&amp;&amp;(!((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)))){
113        Ch=SIn-&gt;GetCh();}
114      while (!SIn-&gt;Eof()){
115        if (BowDocBs-&gt;DocSpVV.Len()%1000==0){
116          printf(&quot;%d transactions read\r&quot;, BowDocBs-&gt;DocSpVV.Len());}
117        IAssert((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;));
118        int TsactN=Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();
119        while ((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)){
120          TsactN=TsactN*10+Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();}
121        while (!((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;))){
122          IAssert((Ch==&#x27; &#x27;)||(Ch==&#x27;\t&#x27;)); Ch=SIn-&gt;GetCh();}
123        IAssert((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;));
124        int ItemN=Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();
125        while ((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)){
126          ItemN=ItemN*10+Ch-&#x27;0&#x27;; Ch=SIn-&gt;GetCh();}
127        while ((!SIn-&gt;Eof())&amp;&amp;(!((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;)))){
128          Ch=SIn-&gt;GetCh();}
129        TStr DocNm=TInt::GetStr(TsactN);
130        int DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
131        TStr WordStr=TInt::GetStr(ItemN);
132        int WId=BowDocBs-&gt;WordStrToDescH.AddKey(WordStr);
133        BowDocBs-&gt;WordStrToDescH[WId].Fq++;
134        if (CurDId!=DId){
135          if (CurDId!=-1){
136            if ((MxDocs!=-1)&amp;&amp;(BowDocBs-&gt;GetDocs()&gt;=MxDocs-1)){break;}
137            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
138            int NewDId=BowDocBs-&gt;DocSpVV.Add(NewSpV);
139            IAssert(NewDId==CurDId);
140            for (int DocWIdN=0; DocWIdN&lt;CurDocWIdToFqH.Len(); DocWIdN++){
141              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
142              int WordFq=CurDocWIdToFqH[DocWIdN];
143              NewSpV-&gt;AddWIdWgt(WId, WordFq);
144            }
145            NewSpV-&gt;Sort();
146          }
147          CurDId=DId; CurDocWIdToFqH.Clr(false);
148        }
149        CurDocWIdToFqH.AddDat(WId)++;
150      }
151      if (CurDId!=-1){
152        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
153        BowDocBs-&gt;DocSpVV.Add(NewSpV);
154        for (int DocWIdN=0; DocWIdN&lt;CurDocWIdToFqH.Len(); DocWIdN++){
155          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
156          int WordFq=CurDocWIdToFqH[DocWIdN];
157          NewSpV-&gt;AddWIdWgt(WId, WordFq);
158        }
159        NewSpV-&gt;Sort();
160      }
161      printf(&quot;%d transactions read\n&quot;, BowDocBs-&gt;DocSpVV.Len());
162    }
163    printf(&quot;... Done.\n&quot;);
164    BowDocBs-&gt;AssertOk();
165    return BowDocBs;
166  }
167  PBowDocBs TBowFl::LoadSparseTxt(
168   const TStr&amp; DocDefFNm, const TStr&amp; WordDefFNm,
169   const TStr&amp; TrainDataFNm,
170   const int&amp; MxDocs){
171    PBowDocBs BowDocBs=TBowDocBs::New();
172    if (!DocDefFNm.Empty()){
173      PSIn SIn=TFIn::New(DocDefFNm);
174      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
175      Lx.GetSym(syInt, syEof);
176      while (Lx.Sym==syInt){
177        int DId=Lx.Int;
178        Lx.GetSym(syColon);
179        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
180        Lx.GetSym(syEoln);
181        Lx.GetSym(syInt, syEof);
182        int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
183        EAssertR(DId==NewDId, &quot;Document-Ids don&#x27;t match.&quot;);
184      }
185    }
186    if (!WordDefFNm.Empty()){
187      PSIn SIn=TFIn::New(WordDefFNm);
188      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
189      Lx.GetSym(syInt, syEof);
190      while (Lx.Sym==syInt){
191        int WId=Lx.Int;
192        Lx.GetSym(syColon);
193        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
194        Lx.GetSym(syEoln);
195        Lx.GetSym(syInt, syEof);
196        int NewWId=BowDocBs-&gt;WordStrToDescH.AddKey(WordStr);
197        BowDocBs-&gt;WordStrToDescH[NewWId].Fq=1;
198        EAssertR(WId==NewWId, &quot;Word-Ids don&#x27;t match.&quot;);
199      }
200    }
201    if (!TrainDataFNm.Empty()){
202      PSIn SIn=TFIn::New(TrainDataFNm);
203      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
204      Lx.GetSym(syInt, syEof);
205      while (Lx.Sym==syInt){
206        if (BowDocBs-&gt;GetDocs()&gt;=MxDocs){break;}
207        int DId=Lx.Int;
208        PBowSpV NewSpV=TBowSpV::New(DId);
209        int NewDId=BowDocBs-&gt;DocSpVV.Add(NewSpV);
210        EAssertR(DId==NewDId, &quot;Document-Ids don&#x27;t match.&quot;);
211        Lx.GetSym(syInt, syEoln);
212        while (Lx.Sym==syInt){
213          int WId=Lx.Int;
214          Lx.GetSym(syColon, syInt, syEoln);
215          double WordFq=1;
216          if (Lx.Sym==syColon){
217            WordFq=Lx.GetFlt();
218            Lx.GetSym(syInt, syEoln);
219          }
220          NewSpV-&gt;AddWIdWgt(WId, WordFq);
221        }
222        NewSpV-&gt;Trunc();
223        Lx.GetSym(syInt, syEof);
224      }
225    }
226    BowDocBs-&gt;AssertOk();
227    return BowDocBs;
228  }
229  PBowDocBs TBowFl::LoadSvmLightTxt(
230   const TStr&amp; DocDefFNm, const TStr&amp; WordDefFNm,
231   const TStr&amp; TrainDataFNm, const TStr&amp; TestDataFNm,
232   const int&amp; MxDocs){
233    PBowDocBs BowDocBs=TBowDocBs::New();
234    int MOneCId=BowDocBs-&gt;CatNmToFqH.AddKey(&quot;-1&quot;);
235    int POneCId=BowDocBs-&gt;CatNmToFqH.AddKey(&quot;+1&quot;);
236    bool DocDefP=false;
237    if (!DocDefFNm.Empty()&amp;&amp;(TFile::Exists(DocDefFNm))){
238      PSIn SIn=TFIn::New(DocDefFNm);
239      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
240      Lx.GetSym(syInt, syEof);
241      while (Lx.Sym==syInt){
242        int DId=Lx.Int;
243        Lx.GetSym(syColon);
244        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
245        Lx.GetSym(syEoln);
246        Lx.GetSym(syInt, syEof);
247        int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
248        EAssertR(DId==NewDId, &quot;Document-Ids don&#x27;t match.&quot;);
249      }
250      DocDefP=true;
251    }
252    if (!WordDefFNm.Empty()&amp;&amp;(TFile::Exists(WordDefFNm))){
253      BowDocBs-&gt;WordStrToDescH.AddDat(&quot;Undef&quot;).Fq=0; 
254      PSIn SIn=TFIn::New(WordDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syQStr, syEof);
257      while (Lx.Sym==syQStr){
258        TStr WordStr=Lx.Str;
259        Lx.GetSym(syInt); int WId=Lx.Int;
260        Lx.GetSym(syInt); int WordFq=Lx.Int;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syQStr, syEof);
263        int NewWId=BowDocBs-&gt;WordStrToDescH.AddKey(WordStr);
264        EAssertR(WId==NewWId, &quot;Word-Ids don&#x27;t match.&quot;);
265        BowDocBs-&gt;WordStrToDescH[WId].Fq=WordFq;
266      }
267    }
268    int MxWId=-1; TIntIntH WIdToFqH;
269    if (!TrainDataFNm.Empty()){
270      PSIn SIn=TFIn::New(TrainDataFNm);
271      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
272      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
273      while (Lx.Sym==syInt){
274        TStr DocNm=TInt::GetStr(BowDocBs-&gt;GetDocs());
275        int DId;
276        if (DocDefP){
277          DId=BowDocBs-&gt;DocNmToDescStrH.GetKeyId(DocNm);
278        } else {
279          DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
280        }
281        BowDocBs-&gt;TrainDIdV.Add(DId);
282        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
283        BowDocBs-&gt;DocCIdVV.Add(); IAssert(DId==BowDocBs-&gt;DocCIdVV.Len()-1);
284        BowDocBs-&gt;DocCIdVV.Last().Gen(1, 0);
285        BowDocBs-&gt;DocCIdVV.Last().Add(CId);
286        PBowSpV SpV=TBowSpV::New(DId);
287        BowDocBs-&gt;DocSpVV.Add(SpV); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
288        Lx.GetSym(syInt, syEoln);
289        while (Lx.Sym==syInt){
290          int WId=Lx.Int;
291          Lx.GetSym(syColon);
292          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
293          Lx.GetSym(syInt, syEoln);
294          SpV-&gt;AddWIdWgt(WId, WordFq);
295          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
296          WIdToFqH.AddDat(WId)++;
297        }
298        if (!Lx.CmtStr.Empty()){
299          TStr CmtStr=Lx.CmtStr;
300          static TStr DocNmPrefixStr=&quot;docDesc=&quot;;
301          if (CmtStr.IsPrefix(DocNmPrefixStr)){
302            TStr NewDocNm=
303             TStr(&quot;D&quot;)+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
304            BowDocBs-&gt;DocNmToDescStrH.DelKey(DocNm);
305            int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(NewDocNm);
306            IAssert(DId==NewDId);
307          }
308        }
309        SpV-&gt;Trunc();
310        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
311      }
312    }
313    if (!TestDataFNm.Empty()){
314      PSIn SIn=TFIn::New(TestDataFNm);
315      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
316      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
317      while (Lx.Sym==syInt){
318        TStr DocNm=TInt::GetStr(BowDocBs-&gt;GetDocs());
319        int DId;
320        if (DocDefP){
321          DId=BowDocBs-&gt;DocNmToDescStrH.GetKeyId(DocNm);
322        } else {
323          DId=BowDocBs-&gt;DocNmToDescStrH.AddKey(DocNm);
324        }
325        BowDocBs-&gt;TestDIdV.Add(DId);
326        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
327        BowDocBs-&gt;DocCIdVV.Add(); IAssert(DId==BowDocBs-&gt;DocCIdVV.Len()-1);
328        BowDocBs-&gt;DocCIdVV.Last().Gen(1, 0);
<span onclick='openModal()' class='match'>329        BowDocBs-&gt;DocCIdVV.Last().Add(CId);
330        PBowSpV SpV=TBowSpV::New(DId);
331        BowDocBs-&gt;DocSpVV.Add(SpV); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
332        Lx.GetSym(syInt, syEoln);
333        while (Lx.Sym==syInt){
334          int WId=Lx.Int;
335          Lx.GetSym(syColon);
336          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
337          Lx.GetSym(syInt, syEoln);
338          SpV-&gt;AddWIdWgt(WId, WordFq);
339          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
340          WIdToFqH.AddDat(WId)++;
341        }
342        if (!Lx.CmtStr.Empty()){
343          TStr CmtStr=Lx.CmtStr;
344          static TStr DocNmPrefixStr=&quot;docDesc=&quot;;
345          if (CmtStr.IsPrefix(DocNmPrefixStr)){
346            TStr NewDocNm=
347             TStr(&quot;D&quot;)+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
348            BowDocBs-&gt;DocNmToDescStrH.DelKey(DocNm);
349            int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(NewDocNm);
350            IAssert(DId==NewDId);
351          }
352        }
353        SpV-&gt;Trunc();
354        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
355      }
356    }
357    for (int WId=0; WId&lt;=MxWId; WId++){
</span>358      if (!BowDocBs-&gt;IsWId(WId)){
359        TStr WordStr=TInt::GetStr(WId, &quot;W%d&quot;);
360        int _WId=BowDocBs-&gt;AddWordStr(WordStr);
361        IAssert(WId==_WId);
362        TInt Fq;
363        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
364          BowDocBs-&gt;PutWordFq(WId, Fq);
365        }
366      }
367    }
368    BowDocBs-&gt;AssertOk();
369    return BowDocBs;
370  }
371  PBowDocBs TBowFl::LoadCpdTxt(
372   const TStr&amp; CpdFNm, const int&amp; MxDocs,
373   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
374   const int&amp; MxNGramLen, const int&amp; MnNGramFq,
375   const bool&amp; SaveDocP, const PNotify&amp; Notify){
376    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
377    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
378    PNGramBs NGramBs;
379    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
380      NGramBs=TNGramBs::GetNGramBsFromCpd(
381       CpdFNm, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
382    }
383    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
384    TIntH DocWIdToFqH(100);
385    PSIn CpdSIn=TCpDoc::GetFirstCpd(CpdFNm); PCpDoc CpDoc; int Docs=0;
386    while (TCpDoc::GetNextCpd(CpdSIn, CpDoc)){
387      Docs++; if (Docs%100==0){printf(&quot;%d\r&quot;, Docs);}
388      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
389      TStr DocNm=CpDoc-&gt;GetDocId();
390      TStrV CatNmV;
391      for (int CatN=0; CatN&lt;CpDoc-&gt;GetCats(); CatN++){
392        CatNmV.Add(CpDoc-&gt;GetCatNm(CatN));
393      }
394      TStr DocStr=CpDoc-&gt;GetTxtStr();
395      TStr DateStr=CpDoc-&gt;GetDateStr();
396      int DId=BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
397      BowDocBs-&gt;PutDateStr(DId, DateStr);
398    }
399    BowDocBs-&gt;AssertOk();
400    return BowDocBs;
401  }
402  void TBowFl::SaveCpdToLnDocTxt(const TStr&amp; InCpdFNm, const TStr&amp; OutLnDocFNm){
403    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
404    PSIn CpdSIn=TCpDoc::GetFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
405    printf(&quot;Saving &#x27;%s&#x27; to &#x27;%s&#x27; ...\n&quot;, InCpdFNm.CStr(), OutLnDocFNm.CStr());
406    while (TCpDoc::GetNextCpd(CpdSIn, CpDoc)){
407      Docs++; if (Docs%100==0){printf(&quot;%d Docs\r&quot;, Docs);}
408      TStr DocNm=CpDoc-&gt;GetDocId();
409      DocNm=TStr::GetFNmStr(DocNm);
410      DocNm.ChangeChAll(&#x27; &#x27;, &#x27;_&#x27;);
411      TStrV CatNmV;
412      for (int CatN=0; CatN&lt;CpDoc-&gt;GetCats(); CatN++){
413        CatNmV.Add(CpDoc-&gt;GetCatNm(CatN));}
414      TChA DocChA=CpDoc-&gt;GetTxtStr();
415      DocChA.ChangeCh(&#x27;\r&#x27;, &#x27; &#x27;);
416      DocChA.ChangeCh(&#x27;\n&#x27;, &#x27; &#x27;);
417      fprintf(fOut, &quot;%s&quot;, DocNm.CStr());
418      for (int CatN=0; CatN&lt;CatNmV.Len(); CatN++){
419        fprintf(fOut, &quot; !%s&quot;, CatNmV[CatN].CStr());}
420      fprintf(fOut, &quot; %s\n&quot;, DocChA.CStr());
421    }
422    printf(&quot;%d Docs\nDone.\n&quot;, Docs);
423  }
424  PBowDocBs TBowFl::LoadTBsTxt(
425   const TStr&amp; TBsFNm, const int&amp; MxDocs,
426   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
427   const int&amp; MxNGramLen, const int&amp; MnNGramFq){
428    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
429    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
430    PNGramBs NGramBs;
431    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
432      NGramBs=TNGramBs::GetNGramBsFromTBs(
433       TBsFNm, MxDocs,
434       MxNGramLen, MnNGramFq, SwSet, Stemmer);
435    }
436    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
437    TStr TxtBsNm=TBsFNm.GetFBase();
438    TStr TxtBsFPath=TBsFNm.GetFPath();
439    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
440    TBlobPt TxtBsTrvBlobPt=TxtBs-&gt;FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
441    while (TxtBs-&gt;FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
442      Docs++; if (Docs%100==0){printf(&quot;%d\r&quot;, Docs);}
443      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
444      TStr DocNm; TStr DocStr;
445      TxtBs-&gt;GetDocNmStr(TxtBsDocId, DocNm, DocStr);
446      BowDocBs-&gt;AddHtmlDoc(DocNm, TStrV(), DocStr, false);
447    }
448    BowDocBs-&gt;AssertOk();
449    return BowDocBs;
450  }
451  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr&amp; LnDocFNm,
452   TIntV&amp; NewDIdV, const bool&amp; NamedP, const int&amp; MxDocs, const bool&amp; SaveDocP,
453   const PNotify&amp; Notify) {
454    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=&#x27; &#x27;; int Docs=0;
455    while (!FIn.Eof()){
456      Docs++; if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
457      printf(&quot;%d\r&quot;, Docs);
458      TChA DocNm;
459      if (NamedP){
460        Ch=FIn.GetCh();
461        while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)&amp;&amp;(Ch!=&#x27; &#x27;)){
462          DocNm+=Ch; Ch=FIn.GetCh();}
463        DocNm.Trunc();
464        if (DocNm.Empty()){Docs--; continue;}
465      }
466      TStrV CatNmV;
467      forever {
468        while ((!FIn.Eof())&amp;&amp;(Ch==&#x27; &#x27;)){Ch=FIn.GetCh();}
469        if (Ch==&#x27;!&#x27;){
470          if (!FIn.Eof()){Ch=FIn.GetCh();}
471          TChA CatNm;
472          while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)&amp;&amp;(Ch!=&#x27; &#x27;)){
473            CatNm+=Ch; Ch=FIn.GetCh();}
474          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
475        } else {
476          break;
477        }
478      }
479      TChA DocChA;
480      while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)){
481        DocChA+=Ch; Ch=FIn.GetCh();}
482      if (DocNm.Empty()&amp;&amp;DocChA.Empty()){
483        continue;}
484      NewDIdV.Add(BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
485    }
486    BowDocBs-&gt;AssertOk();
487    printf(&quot;\n&quot;);
488  }
489  PBowDocBs TBowFl::LoadLnDocTxt(
490   const TStr&amp; LnDocFNm, const bool&amp; NamedP, const int&amp; MxDocs,
491   const PSwSet&amp; SwSet, const PStemmer&amp; Stemmer,
492   const int&amp; MxNGramLen, const int&amp; MnNGramFq, const bool&amp; SaveDocP,
493   const PNotify&amp; Notify){
494    PNGramBs NGramBs;
495    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
496      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
497       LnDocFNm, NamedP, MxDocs,
498       MxNGramLen, MnNGramFq, SwSet, Stemmer);
499    }
500    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
501    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP, Notify);
502    return BowDocBs;
503  }
504  PBowDocBs TBowFl::LoadLnDocTxt(
505   const TStr&amp; LnDocFNm, const bool&amp; NamedP, const int&amp; MxDocs,
506   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
507   const int&amp; MxNGramLen, const int&amp; MnNGramFq, const bool&amp; SaveDocP,
508     const PNotify&amp; Notify){
509    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
510    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
511    PNGramBs NGramBs;
512    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
513      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
514       LnDocFNm, NamedP, MxDocs,
515       MxNGramLen, MnNGramFq, SwSet, Stemmer);
516    }
517    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
518    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP, Notify);
519    return BowDocBs;
520  }
521  void TBowFl::SaveLnDocTxt(const PBowDocBs&amp; BowDocBs, const TStr&amp; FNm, const bool&amp; UseDocStrP){
522    TFOut SOut(FNm);
523    int Docs=BowDocBs-&gt;GetDocs();
524    for (int DId=0; DId&lt;Docs; DId++){
525      printf(&quot;%d/%d\r&quot;, DId+1, Docs);
526      TStr DocNm=TStr::GetFNmStr(BowDocBs-&gt;GetDocNm(DId));
527      SOut.PutStr(DocNm);
528      for (int CIdN=0; CIdN&lt;BowDocBs-&gt;GetDocCIds(DId); CIdN++){
529        int CId=BowDocBs-&gt;GetDocCId(DId, CIdN);
530        TStr CatNm=TStr::GetFNmStr(BowDocBs-&gt;GetCatNm(CId));
531        SOut.PutCh(&#x27; &#x27;); SOut.PutCh(&#x27;!&#x27;); SOut.PutStr(CatNm);
532      }
533      if (UseDocStrP){
534        TStr DocStr=BowDocBs-&gt;GetDocStr(DId);
535        DocStr.DelChAll(&#x27;\n&#x27;); DocStr.DelChAll(&#x27;\r&#x27;);
536        SOut.PutCh(&#x27; &#x27;); SOut.PutStr(DocStr);
537      } else {
538          int DocWIds=BowDocBs-&gt;GetDocWIds(DId);
539          int WId; double WordFq;
540          for (int DocWIdN=0; DocWIdN&lt;DocWIds; DocWIdN++){
541            BowDocBs-&gt;GetDocWIdFq(DId, DocWIdN, WId, WordFq);
542            TStr WordStr=BowDocBs-&gt;GetWordStr(WId);
543            for (int WordFqN=0; WordFqN&lt;WordFq; WordFqN++){
544              SOut.PutCh(&#x27; &#x27;); SOut.PutStr(WordStr);
545            }
546          }
547      }
548      SOut.PutLn();
549    }
550    printf(&quot;\n&quot;);
551  }
552  PBowDocBs TBowFl::LoadReuters21578Txt(
553   const TStr&amp; FPath, const int&amp; MxDocs,
554   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
555   const int&amp; MxNGramLen, const int&amp; MnNGramFq, const bool&amp; SaveDocP,
556   const PNotify&amp; Notify){
557    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
558    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
559    PNGramBs NGramBs;
560    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
561      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
562       FPath, MxDocs,
563       MxNGramLen, MnNGramFq, SwSet, Stemmer);
564    }
565    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
566    TFFile FFile(FPath, &quot;.SGM&quot;, false); TStr FNm; int Docs=0;
567    while (FFile.Next(FNm)){
568      printf(&quot;Processing file &#x27;%s&#x27;\n&quot;, FNm.CStr());
569      TIntH DocWIdToFqH(100);
570      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
571      for (int LDocN=0; LDocN&lt;LDocV.Len(); LDocN++){
572        Docs++; if (Docs%100==0){printf(&quot;%d\r&quot;, Docs);}
573        if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
574        PXmlDoc Doc=LDocV[LDocN];
575        PXmlTok DocTok=Doc-&gt;GetTok();
576        TStr DocNm=DocTok-&gt;GetArgVal(&quot;NEWID&quot;);
577        TStrV CatNmV;
578        TXmlTokV TopicsTokV; Doc-&gt;GetTagTokV(&quot;REUTERS|TOPICS|D&quot;, TopicsTokV);
579        for (int TopicsTokN=0; TopicsTokN&lt;TopicsTokV.Len(); TopicsTokN++){
580          TStr CatNm=TopicsTokV[TopicsTokN]-&gt;GetTokStr(false);
581          CatNmV.Add(CatNm);
582        }
583        PXmlTok DocStrTok=Doc-&gt;GetTagTok(&quot;REUTERS|TEXT&quot;);
584        TStr DocStr=DocStrTok-&gt;GetTokStr(false);
585        int DId=BowDocBs-&gt;AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
586        if ((DocTok-&gt;GetArgVal(&quot;LEWISSPLIT&quot;)==&quot;TRAIN&quot;)&amp;&amp;(DocTok-&gt;GetArgVal(&quot;TOPICS&quot;)==&quot;YES&quot;)){
587          BowDocBs-&gt;AddTrainDId(DId);}
588        if ((DocTok-&gt;GetArgVal(&quot;LEWISSPLIT&quot;)==&quot;TEST&quot;)&amp;&amp;(DocTok-&gt;GetArgVal(&quot;TOPICS&quot;)==&quot;YES&quot;)){
589          BowDocBs-&gt;AddTestDId(DId);}
590      }
591      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
592    }
593    BowDocBs-&gt;AssertOk();
594    return BowDocBs;
595  }
596  PBowDocBs TBowFl::LoadCiaWFBTxt(
597   const TStr&amp; FPath, const int&amp; MxDocs,
598   const TStr&amp; SwSetTypeNm, const TStr&amp; StemmerTypeNm,
599   const int&amp; MxNGramLen, const int&amp; MnNGramFq){
600    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
601    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
602    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
603    PNGramBs NGramBs;
604    if (!((MxNGramLen==1)&amp;&amp;(MnNGramFq==1))){
605      TStrV HtmlStrV;
606      for (int CountryN=0; CountryN&lt;CiaWFBBs-&gt;GetCountries(); CountryN++){
607        PCiaWFBCountry CiaWFBCountry=CiaWFBBs-&gt;GetCountry(CountryN);
608        HtmlStrV.Add(CiaWFBCountry-&gt;GetDescStr());
609      }
610      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
611       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
612    }
613    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
614    for (int CountryN=0; CountryN&lt;CiaWFBBs-&gt;GetCountries(); CountryN++){
615      PCiaWFBCountry CiaWFBCountry=CiaWFBBs-&gt;GetCountry(CountryN);
616      TStr CountryNm=CiaWFBCountry-&gt;GetCountryNm();
617      TStr DescStr=CiaWFBCountry-&gt;GetDescStr();
618      TStr CatNm=CiaWFBCountry-&gt;GetFldVal(&quot;Map references&quot;).GetTrunc();
619      TStrV CatNmV; CatNmV.Add(CatNm);
620      BowDocBs-&gt;AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
621    }
622    BowDocBs-&gt;AssertOk();
623    return BowDocBs;
624  }
625  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs&amp; BowDocBs,
626      const PBowDocWgtBs&amp; BowDocWgtBs, const TStr&amp; FNm,
627      const TStr&amp; CatFNm, const TIntV&amp; _DIdV) {
628    TIntV DIdV;
629    if (_DIdV.Empty()) {
630        BowDocBs-&gt;GetAllDIdV(DIdV);
631    } else {
632        DIdV = _DIdV;
633    }
634    TFOut WdMapSOut(TStr::PutFExt(FNm, &quot;.row-to-word-map.dat&quot;));
635    for (int WId = 0; WId &lt; BowDocWgtBs-&gt;GetWords(); WId++) {
636      TStr WdStr = BowDocBs-&gt;GetWordStr(WId);
637      WdMapSOut.PutStrLn(TStr::Fmt(&quot;%d %s&quot;, WId+1,  WdStr.CStr()));
638    }
639    WdMapSOut.Flush();
640    TFOut DocMapSOut(TStr::PutFExt(FNm, &quot;.col-to-docName-map.dat&quot;));
641    for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++) {
642      const int DId = DIdV[DocN];
643      TStr DocNm = BowDocBs-&gt;GetDocNm(DId);
644      DocMapSOut.PutStrLn(TStr::Fmt(&quot;%d %d %s&quot;, DocN, DId,  DocNm.CStr()));
645    }
646    DocMapSOut.Flush();
647    TFOut SOut(FNm);
648    for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++){
649      const int DId = DIdV[DocN];
650      PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DId);
651      const int DocWIds = DocSpV-&gt;GetWIds();
652      for (int DocWIdN=0; DocWIdN&lt;DocWIds; DocWIdN++){
653        const int WId = DocSpV-&gt;GetWId(DocWIdN);
654        const double WordWgt = DocSpV-&gt;GetWgt(DocWIdN);
655        SOut.PutStrLn(TStr::Fmt(&quot;%d %d %.16f&quot;, WId+1, DocN+1, WordWgt));
656      }
657    }
658    SOut.Flush();
659    if (!CatFNm.Empty()) {
660      TFOut CatSOut(CatFNm);
661      for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++){
662        const int DId = DIdV[DocN];
663        const int DocCIds = BowDocBs-&gt;GetDocCIds(DId);
664        for (int DocCIdN=0; DocCIdN&lt;DocCIds; DocCIdN++){
665          const int CId = BowDocBs-&gt;GetDocCId(DId, DocCIdN);
666          const double CatWgt = 1.0;
667          CatSOut.PutStrLn(TStr::Fmt(&quot;%d %d %.16f&quot;, CId+1, DocN+1, CatWgt));
668        }
669      }
670      CatSOut.Flush();
671    }
672  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowflx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>345        BowDocBs-&gt;DocCIdVV.Last().Add(CId);
346        PBowSpV SpV=TBowSpV::New(DId);
347        BowDocBs-&gt;DocSpVV.Add(SpV); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
348        Lx.GetSym(syInt, syEoln);
349        while (Lx.Sym==syInt){
350          int WId=Lx.Int;
351          Lx.GetSym(syColon);
352          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
353          Lx.GetSym(syInt, syEoln);
354          SpV-&gt;AddWIdWgt(WId, WordFq);
355          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
356          WIdToFqH.AddDat(WId)++;
357        }
358        if (!Lx.CmtStr.Empty()){
359          TStr CmtStr=Lx.CmtStr;
360          static TStr DocNmPrefixStr=&quot;docDesc=&quot;;
361          if (CmtStr.IsPrefix(DocNmPrefixStr)){
362            TStr NewDocNm=
363             TStr(&quot;D&quot;)+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
364            BowDocBs-&gt;DocNmToDescStrH.DelKey(DocNm);
365            int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(NewDocNm);
366            IAssert(DId==NewDId);
367          }
368        }
369        SpV-&gt;Trunc();
370        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
371      }
372    }
373    for (int WId=0; WId&lt;=MxWId; WId++){
</pre></code></div>
                <div class="column column_space"><pre><code>329        BowDocBs-&gt;DocCIdVV.Last().Add(CId);
330        PBowSpV SpV=TBowSpV::New(DId);
331        BowDocBs-&gt;DocSpVV.Add(SpV); IAssert(DId==BowDocBs-&gt;DocSpVV.Len()-1);
332        Lx.GetSym(syInt, syEoln);
333        while (Lx.Sym==syInt){
334          int WId=Lx.Int;
335          Lx.GetSym(syColon);
336          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
337          Lx.GetSym(syInt, syEoln);
338          SpV-&gt;AddWIdWgt(WId, WordFq);
339          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
340          WIdToFqH.AddDat(WId)++;
341        }
342        if (!Lx.CmtStr.Empty()){
343          TStr CmtStr=Lx.CmtStr;
344          static TStr DocNmPrefixStr=&quot;docDesc=&quot;;
345          if (CmtStr.IsPrefix(DocNmPrefixStr)){
346            TStr NewDocNm=
347             TStr(&quot;D&quot;)+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
348            BowDocBs-&gt;DocNmToDescStrH.DelKey(DocNm);
349            int NewDId=BowDocBs-&gt;DocNmToDescStrH.AddKey(NewDocNm);
350            IAssert(DId==NewDId);
351          }
352        }
353        SpV-&gt;Trunc();
354        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
355      }
356    }
357    for (int WId=0; WId&lt;=MxWId; WId++){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    