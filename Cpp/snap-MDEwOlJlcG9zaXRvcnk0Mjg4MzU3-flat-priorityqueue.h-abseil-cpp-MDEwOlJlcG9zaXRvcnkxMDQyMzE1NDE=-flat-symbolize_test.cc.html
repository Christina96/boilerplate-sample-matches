
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.835164835164836%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-priorityqueue.h</h3>
            <pre><code>1  #ifndef snap_core_priorityqueue_h
2  #define snap_core_priorityqueue_h
3  template <class TVal>
4  class TMaxPriorityQueue {
5  public:
6    TMaxPriorityQueue() {}
7    void Insert(const TVal& X, float Priority) {
8      ValToIndex.AddDat(X, IndexToVal.Len());
9      IndexToVal.Add(X);
10      Priorities.Add(INT_MIN);
11      SetPriority(X, Priority);
12    }
13    void SetPriority(const TVal& X, float NewPriority) {
14      if (!ValToIndex.IsKey(X)) {
15        Insert(X, NewPriority);
16      } else {
17        int i = ValToIndex.GetDat(X);
18        if (NewPriority >= GetPriority(X)) {
19          Priorities[i] = NewPriority;
20          while (i > 0 && Priorities[i] > Priorities[Parent(i)]) {
21            Swap(i, Parent(i));
22            i = Parent(i);
23          }
24        } else {
25          Priorities[i] = NewPriority;
26          MaxHeapify(i);
27        }
28      }
29    }
30    float GetPriority(const TVal& X) {
31      if (ValToIndex.IsKey(X)) {
32        return Priorities[ValToIndex.GetDat(X)];
33      } else {
34        return 0.0f; 
35      }
36    }
37    float GetMaxPriority() {
38      IAssertR(Size() > 0, "Attempt to query max priority of empty priority queue.");
39      return Priorities[0];
40    }
41    TVal PopMax() {
42      IAssertR(Size() > 0, "Attempt to query max priority of empty priority queue.");
43      TVal maxVal = IndexToVal[0];
44      Swap(0, Priorities.Len() - 1);
45      Priorities.DelLast();
46      IndexToVal.DelLast();
47      ValToIndex.DelKey(maxVal);
48      MaxHeapify(0);
49      return maxVal;
50    }
51    bool IsEmpty() {
52      return Size() == 0;
53    }
54    int Size() {
55      return Priorities.Len();
56    }
57    void GetPriorities(THash<TVal, TFlt>& Result ) {
58      for (int i = 0; i < Priorities.Len(); i++) {
59        Result.AddDat(IndexToVal[i], Priorities[i]);
60      }
61    }
62  private:
63    TFltV Priorities;
64    THash<TVal, int> ValToIndex;
65    TVec<TVal> IndexToVal;
<span onclick='openModal()' class='match'>66    int Parent(int i) { return (i + 1) / 2 - 1; }
67    int Left(int i) { return i * 2 + 1; }
68    int Right(int i) { return i * 2 + 2; }
</span>69    void Swap(int i, int j) {
70      Priorities.Swap(i, j);
71      IndexToVal.Swap(i, j);
72      ValToIndex.GetDat(IndexToVal[i]) = i;
73      ValToIndex.GetDat(IndexToVal[j]) = j;
74    }
75    void MaxHeapify(int i) {
76      int largest = i;
77      if (Left(i) < Priorities.Len() && Priorities[Left(i)] > Priorities[largest]) {
78        largest = Left(i);
79      }
80      if (Right(i) < Priorities.Len() && Priorities[Right(i)] > Priorities[largest]) {
81        largest = Right(i);
82      }
83      if (largest != i) {
84        Swap(i, largest);
85        MaxHeapify(largest);
86      }
87    }
88  };
89  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-symbolize_test.cc</h3>
            <pre><code>1  #include "absl/debugging/symbolize.h"
2  #ifndef _WIN32
3  #include <fcntl.h>
4  #include <sys/mman.h>
5  #endif
6  #include <cstring>
7  #include <iostream>
8  #include <memory>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/casts.h"
13  #include "absl/base/config.h"
14  #include "absl/base/internal/per_thread_tls.h"
15  #include "absl/base/optimization.h"
16  #include "absl/debugging/internal/stack_consumption.h"
17  #include "absl/log/check.h"
18  #include "absl/log/log.h"
19  #include "absl/memory/memory.h"
20  #include "absl/strings/string_view.h"
21  using testing::Contains;
22  #ifdef _WIN32
23  #define ABSL_SYMBOLIZE_TEST_NOINLINE __declspec(noinline)
24  #else
25  #define ABSL_SYMBOLIZE_TEST_NOINLINE ABSL_ATTRIBUTE_NOINLINE
26  #endif
27  extern "C" {
28  ABSL_SYMBOLIZE_TEST_NOINLINE void nonstatic_func() {
29    volatile int x = __LINE__;
30    static_cast<void>(x);
31    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
32  }
33  ABSL_SYMBOLIZE_TEST_NOINLINE static void static_func() {
34    volatile int x = __LINE__;
35    static_cast<void>(x);
36    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
37  }
38  }  
39  struct Foo {
40    static void func(int x);
41  };
42  ABSL_SYMBOLIZE_TEST_NOINLINE void Foo::func(int) {
43    volatile int x = __LINE__;
44    static_cast<void>(x);
45    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
46  }
47  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.unlikely) unlikely_func() {
48    return 0;
49  }
50  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.hot) hot_func() {
51    return 0;
52  }
53  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.startup) startup_func() {
54    return 0;
55  }
56  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.exit) exit_func() {
57    return 0;
58  }
59  int &bsol;*ABSL_ATTRIBUTE_SECTION_VARIABLE(.text)*/ regular_func() {
60    return 0;
61  }
62  #if ABSL_PER_THREAD_TLS
63  static ABSL_PER_THREAD_TLS_KEYWORD char symbolize_test_thread_small[1];
64  static ABSL_PER_THREAD_TLS_KEYWORD char
65      symbolize_test_thread_big[2 * 1024 * 1024];
66  #endif
67  #if !defined(__EMSCRIPTEN__)
68  static volatile bool volatile_bool = false;
69  static constexpr size_t kHpageSize = 1 << 21;
70  const char kHpageTextPadding[kHpageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(
71      .text) = "";
72  #endif  
73  static char try_symbolize_buffer[4096];
74  static const char *TrySymbolizeWithLimit(void *pc, int limit) {
75    CHECK_LE(limit, sizeof(try_symbolize_buffer))
76        << "try_symbolize_buffer is too small";
77    auto heap_buffer = absl::make_unique<char[]>(sizeof(try_symbolize_buffer));
78    bool found = absl::Symbolize(pc, heap_buffer.get(), limit);
79    if (found) {
80      CHECK_LT(static_cast<int>(
81                   strnlen(heap_buffer.get(), static_cast<size_t>(limit))),
82               limit)
83          << "absl::Symbolize() did not properly terminate the string";
84      strncpy(try_symbolize_buffer, heap_buffer.get(),
85              sizeof(try_symbolize_buffer) - 1);
86      try_symbolize_buffer[sizeof(try_symbolize_buffer) - 1] = '\0';
87    }
88    return found ? try_symbolize_buffer : nullptr;
89  }
90  static const char *TrySymbolize(void *pc) {
91    return TrySymbolizeWithLimit(pc, sizeof(try_symbolize_buffer));
92  }
93  #if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) ||    \
94      defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE) || \
95      defined(ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE)
96  void ABSL_ATTRIBUTE_NOINLINE TestWithReturnAddress() {
97  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
98    void *return_address = __builtin_return_address(0);
99    const char *symbol = TrySymbolize(return_address);
100    CHECK_NE(symbol, nullptr) << "TestWithReturnAddress failed";
101    CHECK_STREQ(symbol, "main") << "TestWithReturnAddress failed";
102    std::cout << "TestWithReturnAddress passed" << std::endl;
103  #endif
104  }
105  #ifndef ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE
106  TEST(Symbolize, Cached) {
107    EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));
108    const char *static_func_symbol = TrySymbolize((void *)(&static_func));
109    EXPECT_TRUE(strcmp("static_func", static_func_symbol) == 0 ||
110                strcmp("static_func()", static_func_symbol) == 0);
111    EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
112  }
113  TEST(Symbolize, Truncation) {
114    constexpr char kNonStaticFunc[] = "nonstatic_func";
115    EXPECT_STREQ("nonstatic_func",
116                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
117                                       strlen(kNonStaticFunc) + 1));
118    EXPECT_STREQ("nonstatic_...",
119                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
120                                       strlen(kNonStaticFunc) + 0));
121    EXPECT_STREQ("nonstatic...",
122                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
123                                       strlen(kNonStaticFunc) - 1));
124    EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
125    EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
126    EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
127    EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
128    EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
129    EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
130  }
131  TEST(Symbolize, SymbolizeWithDemangling) {
132    Foo::func(100);
133    EXPECT_STREQ("Foo::func()", TrySymbolize((void *)(&Foo::func)));
134  }
135  TEST(Symbolize, SymbolizeSplitTextSections) {
136    EXPECT_STREQ("unlikely_func()", TrySymbolize((void *)(&unlikely_func)));
137    EXPECT_STREQ("hot_func()", TrySymbolize((void *)(&hot_func)));
138    EXPECT_STREQ("startup_func()", TrySymbolize((void *)(&startup_func)));
139    EXPECT_STREQ("exit_func()", TrySymbolize((void *)(&exit_func)));
140    EXPECT_STREQ("regular_func()", TrySymbolize((void *)(&regular_func)));
141  }
142  #ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
143  static void *g_pc_to_symbolize;
144  static char g_symbolize_buffer[4096];
145  static char *g_symbolize_result;
146  static void SymbolizeSignalHandler(int signo) {
147    if (absl::Symbolize(g_pc_to_symbolize, g_symbolize_buffer,
148                        sizeof(g_symbolize_buffer))) {
149      g_symbolize_result = g_symbolize_buffer;
150    } else {
151      g_symbolize_result = nullptr;
152    }
153  }
154  static const char *SymbolizeStackConsumption(void *pc, int *stack_consumed) {
155    g_pc_to_symbolize = pc;
156    *stack_consumed = absl::debugging_internal::GetSignalHandlerStackConsumption(
157        SymbolizeSignalHandler);
158    return g_symbolize_result;
159  }
160  static int GetStackConsumptionUpperLimit() {
161    int stack_consumption_upper_limit = 2048;
162  #if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
163      defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
164    stack_consumption_upper_limit *= 5;
165  #endif
166    return stack_consumption_upper_limit;
167  }
168  TEST(Symbolize, SymbolizeStackConsumption) {
169    int stack_consumed = 0;
170    const char *symbol =
171        SymbolizeStackConsumption((void *)(&nonstatic_func), &stack_consumed);
172    EXPECT_STREQ("nonstatic_func", symbol);
173    EXPECT_GT(stack_consumed, 0);
174    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
175    symbol = SymbolizeStackConsumption((void *)(&static_func), &stack_consumed);
176    EXPECT_TRUE(strcmp("static_func", symbol) == 0 ||
177                strcmp("static_func()", symbol) == 0);
178    EXPECT_GT(stack_consumed, 0);
179    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
180  }
181  TEST(Symbolize, SymbolizeWithDemanglingStackConsumption) {
182    Foo::func(100);
183    int stack_consumed = 0;
184    const char *symbol =
185        SymbolizeStackConsumption((void *)(&Foo::func), &stack_consumed);
186    EXPECT_STREQ("Foo::func()", symbol);
187    EXPECT_GT(stack_consumed, 0);
188    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
189  }
190  #endif  
191  #ifndef ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
192  const size_t kPageSize = 64 << 10;
193  const char kPadding0[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) =
194      "";
195  const char kPadding1[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) =
196      "";
197  static int FilterElfHeader(struct dl_phdr_info *info, size_t size, void *data) {
198    for (int i = 0; i < info->dlpi_phnum; i++) {
199      if (info->dlpi_phdr[i].p_type == PT_LOAD &&
200          info->dlpi_phdr[i].p_flags == (PF_R | PF_X)) {
201        const void *const vaddr =
202            absl::bit_cast<void *>(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);
203        const auto segsize = info->dlpi_phdr[i].p_memsz;
204        const char *self_exe;
205        if (info->dlpi_name != nullptr && info->dlpi_name[0] != '\0') {
206          self_exe = info->dlpi_name;
207        } else {
208          self_exe = "/proc/self/exe";
209        }
210        absl::debugging_internal::RegisterFileMappingHint(
211            vaddr, reinterpret_cast<const char *>(vaddr) + segsize,
212            info->dlpi_phdr[i].p_offset, self_exe);
213        return 1;
214      }
215    }
216    return 1;
217  }
218  TEST(Symbolize, SymbolizeWithMultipleMaps) {
219    if (volatile_bool) {
220      LOG(INFO) << kPadding0;
221      LOG(INFO) << kPadding1;
222    }
223    char buf[512];
224    memset(buf, 0, sizeof(buf));
225    absl::Symbolize(kPadding0, buf, sizeof(buf));
226    EXPECT_STREQ("kPadding0", buf);
227    memset(buf, 0, sizeof(buf));
228    absl::Symbolize(kPadding1, buf, sizeof(buf));
229    EXPECT_STREQ("kPadding1", buf);
230    dl_iterate_phdr(FilterElfHeader, nullptr);
231    const char *ptrs[] = {kPadding0, kPadding1};
232    for (const char *ptr : ptrs) {
233      const int kMapFlags = MAP_ANONYMOUS | MAP_PRIVATE;
234      void *addr = mmap(nullptr, kPageSize, PROT_READ, kMapFlags, 0, 0);
235      ASSERT_NE(addr, MAP_FAILED);
236      void *remapped = reinterpret_cast<void *>(
237          reinterpret_cast<uintptr_t>(ptr + kPageSize) & ~(kPageSize - 1ULL));
238      const int kMremapFlags = (MREMAP_MAYMOVE | MREMAP_FIXED);
239      void *ret = mremap(addr, kPageSize, kPageSize, kMremapFlags, remapped);
240      ASSERT_NE(ret, MAP_FAILED);
241    }
242    absl::Symbolize(nullptr, buf, sizeof(buf));
243    const char *expected[] = {"kPadding0", "kPadding1"};
244    const size_t offsets[] = {0, kPageSize, 2 * kPageSize, 3 * kPageSize};
245    for (int i = 0; i < 2; i++) {
246      for (size_t offset : offsets) {
247        memset(buf, 0, sizeof(buf));
248        absl::Symbolize(ptrs[i] + offset, buf, sizeof(buf));
249        EXPECT_STREQ(expected[i], buf);
250      }
251    }
252  }
253  static void DummySymbolDecorator(
254      const absl::debugging_internal::SymbolDecoratorArgs *args) {
255    std::string *message = static_cast<std::string *>(args->arg);
256    strncat(args->symbol_buf, message->c_str(),
257            args->symbol_buf_size - strlen(args->symbol_buf) - 1);
258  }
259  TEST(Symbolize, InstallAndRemoveSymbolDecorators) {
260    int ticket_a;
261    std::string a_message("a");
262    EXPECT_GE(ticket_a = absl::debugging_internal::InstallSymbolDecorator(
263                  DummySymbolDecorator, &a_message),
264              0);
265    int ticket_b;
266    std::string b_message("b");
267    EXPECT_GE(ticket_b = absl::debugging_internal::InstallSymbolDecorator(
268                  DummySymbolDecorator, &b_message),
269              0);
270    int ticket_c;
271    std::string c_message("c");
272    EXPECT_GE(ticket_c = absl::debugging_internal::InstallSymbolDecorator(
273                  DummySymbolDecorator, &c_message),
274              0);
275    char *address = reinterpret_cast<char *>(4);
276    EXPECT_STREQ("abc", TrySymbolize(address));
277    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_b));
278    EXPECT_STREQ("ac", TrySymbolize(address + 4));
279    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_a));
280    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_c));
281  }
282  static int in_data_section = 1;
283  TEST(Symbolize, ForEachSection) {
284    int fd = TEMP_FAILURE_RETRY(open("/proc/self/exe", O_RDONLY));
285    ASSERT_NE(fd, -1);
286    std::vector<std::string> sections;
287    ASSERT_TRUE(absl::debugging_internal::ForEachSection(
288        fd, [&sections](const absl::string_view name, const ElfW(Shdr) &) {
289          sections.emplace_back(name);
290          return true;
291        }));
292    EXPECT_THAT(sections, Contains(".text"));
293    EXPECT_THAT(sections, Contains(".rodata"));
294    EXPECT_THAT(sections, Contains(".bss"));
295    ++in_data_section;
296    EXPECT_THAT(sections, Contains(".data"));
297    close(fd);
298  }
299  #endif  
300  #endif  
301  extern "C" {
302  inline void *ABSL_ATTRIBUTE_ALWAYS_INLINE inline_func() {
303    void *pc = nullptr;
304  #if defined(__i386__)
305    __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [ PC ] "=r"(pc));
306  #elif defined(__x86_64__)
307    __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [ PC ] "=r"(pc));
308  #endif
309    return pc;
310  }
311  void *ABSL_ATTRIBUTE_NOINLINE non_inline_func() {
312    void *pc = nullptr;
313  #if defined(__i386__)
314    __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [ PC ] "=r"(pc));
315  #elif defined(__x86_64__)
316    __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [ PC ] "=r"(pc));
317  #endif
318    return pc;
319  }
320  void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideNonInlineFunction() {
321  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE) && \
322      (defined(__i386__) || defined(__x86_64__))
323    void *pc = non_inline_func();
324    const char *symbol = TrySymbolize(pc);
325    CHECK_NE(symbol, nullptr) << "TestWithPCInsideNonInlineFunction failed";
326    CHECK_STREQ(symbol, "non_inline_func")
327        << "TestWithPCInsideNonInlineFunction failed";
328    std::cout << "TestWithPCInsideNonInlineFunction passed" << std::endl;
329  #endif
330  }
331  void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideInlineFunction() {
332  #if defined(ABSL_HAVE_ATTRIBUTE_ALWAYS_INLINE) && \
333      (defined(__i386__) || defined(__x86_64__))
334    void *pc = inline_func();  
335    const char *symbol = TrySymbolize(pc);
336    CHECK_NE(symbol, nullptr) << "TestWithPCInsideInlineFunction failed";
337    CHECK_STREQ(symbol, __FUNCTION__) << "TestWithPCInsideInlineFunction failed";
338    std::cout << "TestWithPCInsideInlineFunction passed" << std::endl;
339  #endif
340  }
<span onclick='openModal()' class='match'>341  }
342  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
343      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
344  __attribute__((target("thumb"))) int ArmThumbOverlapThumb(int x) {
345    return x * x * x;
346  }
347  __attribute__((target("arm"))) int ArmThumbOverlapArm(int x) {
348    return x * x * x;
349  }
</span>350  void ABSL_ATTRIBUTE_NOINLINE TestArmThumbOverlap() {
351  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
352    const char *symbol = TrySymbolize((void *)&ArmThumbOverlapArm);
353    CHECK_NE(symbol, nullptr) << "TestArmThumbOverlap failed";
354    CHECK_STREQ("ArmThumbOverlapArm()", symbol) << "TestArmThumbOverlap failed";
355    std::cout << "TestArmThumbOverlap passed" << std::endl;
356  #endif
357  }
358  #endif  
359  #elif defined(_WIN32)
360  #if !defined(ABSL_CONSUME_DLL)
361  TEST(Symbolize, Basics) {
362    EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));
363    const char *static_func_symbol = TrySymbolize((void *)(&static_func));
364    ASSERT_TRUE(static_func_symbol != nullptr);
365    EXPECT_TRUE(strstr(static_func_symbol, "static_func") != nullptr);
366    EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
367  }
368  TEST(Symbolize, Truncation) {
369    constexpr char kNonStaticFunc[] = "nonstatic_func";
370    EXPECT_STREQ("nonstatic_func",
371                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
372                                       strlen(kNonStaticFunc) + 1));
373    EXPECT_STREQ("nonstatic_...",
374                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
375                                       strlen(kNonStaticFunc) + 0));
376    EXPECT_STREQ("nonstatic...",
377                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
378                                       strlen(kNonStaticFunc) - 1));
379    EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
380    EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
381    EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
382    EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
383    EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
384    EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
385  }
386  TEST(Symbolize, SymbolizeWithDemangling) {
387    const char *result = TrySymbolize((void *)(&Foo::func));
388    ASSERT_TRUE(result != nullptr);
389    EXPECT_TRUE(strstr(result, "Foo::func") != nullptr) << result;
390  }
391  #endif  
392  #else  
393  TEST(Symbolize, Unimplemented) {
394    char buf[64];
395    EXPECT_FALSE(absl::Symbolize((void *)(&nonstatic_func), buf, sizeof(buf)));
396    EXPECT_FALSE(absl::Symbolize((void *)(&static_func), buf, sizeof(buf)));
397    EXPECT_FALSE(absl::Symbolize((void *)(&Foo::func), buf, sizeof(buf)));
398  }
399  #endif
400  int main(int argc, char **argv) {
401  #if !defined(__EMSCRIPTEN__)
402    if (volatile_bool) {
403      LOG(INFO) << kHpageTextPadding;
404    }
405  #endif  
406  #if ABSL_PER_THREAD_TLS
407    symbolize_test_thread_small[0] = 0;
408    symbolize_test_thread_big[0] = 0;
409  #endif
410    absl::InitializeSymbolizer(argv[0]);
411    testing::InitGoogleTest(&argc, argv);
412  #if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) || \
413      defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE)
414    TestWithPCInsideInlineFunction();
415    TestWithPCInsideNonInlineFunction();
416    TestWithReturnAddress();
417  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
418      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
419    TestArmThumbOverlap();
420  #endif
421  #endif
422    return RUN_ALL_TESTS();
423  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-priorityqueue.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-symbolize_test.cc</div>
                <div class="column column_space"><pre><code>66    int Parent(int i) { return (i + 1) / 2 - 1; }
67    int Left(int i) { return i * 2 + 1; }
68    int Right(int i) { return i * 2 + 2; }
</pre></code></div>
                <div class="column column_space"><pre><code>341  }
342  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
343      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
344  __attribute__((target("thumb"))) int ArmThumbOverlapThumb(int x) {
345    return x * x * x;
346  }
347  __attribute__((target("arm"))) int ArmThumbOverlapArm(int x) {
348    return x * x * x;
349  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    