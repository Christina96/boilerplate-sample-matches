
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 94, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexAbaqus.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static inline bool IsAKeywordChar(const int ch) {
20  	return (ch &lt; 0x80 &amp;&amp; (isalnum(ch) || (ch == &#x27;_&#x27;) || (ch == &#x27; &#x27;)));
21  }
22  static inline bool IsASetChar(const int ch) {
23  	return (ch &lt; 0x80 &amp;&amp; (isalnum(ch) || (ch == &#x27;_&#x27;) || (ch == &#x27;.&#x27;) || (ch == &#x27;-&#x27;)));
24  }
25  static void ColouriseABAQUSDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList*[] &amp;bsol;* *keywordlists[] */,
26                              Accessor &amp;styler) {
27  	enum localState { KW_LINE_KW, KW_LINE_COMMA, KW_LINE_PAR, KW_LINE_EQ, KW_LINE_VAL, \
28  					  DAT_LINE_VAL, DAT_LINE_COMMA,\
29  					  COMMENT_LINE,\
30  					  ST_ERROR, LINE_END } state ;
31  	state = LINE_END ;
32  	initStyle = SCE_ABAQUS_DEFAULT;
33  	StyleContext sc(startPos, length, initStyle, styler);
34  	for (; sc.More(); sc.Forward()) {
35  		switch ( state ) {
36          case KW_LINE_KW :
37              if ( sc.atLineEnd ) {
38                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
39                  state = LINE_END ;
40              } else if ( IsAKeywordChar(sc.ch) ) {
41                  state = KW_LINE_KW ;
42              } else if ( sc.ch == &#x27;,&#x27; ) {
43                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
44                  state = KW_LINE_COMMA ;
45              } else {
46                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
47                  state = ST_ERROR ;
48              }
49              break ;
50          case KW_LINE_COMMA :
51              if ( IsAKeywordChar(sc.ch)) {
52                  sc.SetState(SCE_ABAQUS_ARGUMENT) ;
53                  state = KW_LINE_PAR ;
54              } else if ( sc.atLineEnd || (sc.ch == &#x27;,&#x27;) ) {
55                  state = KW_LINE_COMMA ;
56              } else if ( sc.ch == &#x27; &#x27; ) {
57                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
58                  state = KW_LINE_COMMA ;
59              } else {
60                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
61                  state = ST_ERROR ;
62              }
63              break ;
64          case KW_LINE_PAR :
65              if ( sc.atLineEnd ) {
66                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
67                  state = LINE_END ;
68              } else if ( IsAKeywordChar(sc.ch) || (sc.ch == &#x27;-&#x27;) ) {
69                  state = KW_LINE_PAR ;
70              } else if ( sc.ch == &#x27;,&#x27; ) {
71                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
72                  state = KW_LINE_COMMA ;
73              } else if ( sc.ch == &#x27;=&#x27; ) {
74                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
75                  state = KW_LINE_EQ ;
76              } else {
77                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
78                  state = ST_ERROR ;
79              }
80              break ;
81          case KW_LINE_EQ :
82              if ( sc.ch == &#x27; &#x27; ) {
83                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
84                  state = KW_LINE_EQ ;
85              } else if ( IsADigit(sc.ch) || (sc.ch == &#x27;-&#x27;) || (sc.ch == &#x27;.&#x27; &amp;&amp; IsADigit(sc.chNext)) ) {
86                  sc.SetState(SCE_ABAQUS_NUMBER) ;
87                  state = KW_LINE_VAL ;
88              } else if ( IsAKeywordChar(sc.ch) ) {
89                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
90                  state = KW_LINE_VAL ;
91              } else if ( (sc.ch == &#x27;\&#x27;&#x27;) || (sc.ch == &#x27;\&quot;&#x27;) ) {
92                  sc.SetState(SCE_ABAQUS_STRING) ;
93                  state = KW_LINE_VAL ;
94              } else {
95                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
96                  state = ST_ERROR ;
97              }
98              break ;
99          case KW_LINE_VAL :
100              if ( sc.atLineEnd ) {
101                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
102                  state = LINE_END ;
103              } else if ( IsASetChar(sc.ch) &amp;&amp; (sc.state == SCE_ABAQUS_DEFAULT) ) {
104                  state = KW_LINE_VAL ;
105              } else if (( (IsADigit(sc.ch) || sc.ch == &#x27;.&#x27; || (sc.ch == &#x27;e&#x27; || sc.ch == &#x27;E&#x27;) ||
106                      ((sc.ch == &#x27;+&#x27; || sc.ch == &#x27;-&#x27;) &amp;&amp; (sc.chPrev == &#x27;e&#x27; || sc.chPrev == &#x27;E&#x27;)))) &amp;&amp;
107                      (sc.state == SCE_ABAQUS_NUMBER)) {
108                  state = KW_LINE_VAL ;
109              } else if (sc.state == SCE_ABAQUS_STRING) {
110                  if ( sc.ch == &#x27;\&#x27;&#x27; || sc.ch == &#x27;\&quot;&#x27; ) {
111                      sc.SetState(SCE_ABAQUS_DEFAULT) ;
112                      state = KW_LINE_VAL ;
113                  }
114              } else if ( sc.ch == &#x27;,&#x27; ) {
115                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
116                  state = KW_LINE_COMMA ;
117              } else {
118                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
119                  state = ST_ERROR ;
120              }
121              break ;
122          case DAT_LINE_VAL :
123              if ( sc.atLineEnd ) {
124                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
125                  state = LINE_END ;
126              } else if ( IsASetChar(sc.ch) &amp;&amp; (sc.state == SCE_ABAQUS_DEFAULT) ) {
127                  state = DAT_LINE_VAL ;
128              } else if (( (IsADigit(sc.ch) || sc.ch == &#x27;.&#x27; || (sc.ch == &#x27;e&#x27; || sc.ch == &#x27;E&#x27;) ||
129                      ((sc.ch == &#x27;+&#x27; || sc.ch == &#x27;-&#x27;) &amp;&amp; (sc.chPrev == &#x27;e&#x27; || sc.chPrev == &#x27;E&#x27;)))) &amp;&amp;
130                      (sc.state == SCE_ABAQUS_NUMBER)) {
131                  state = DAT_LINE_VAL ;
132              } else if (sc.state == SCE_ABAQUS_STRING) {
133                  if ( sc.ch == &#x27;\&#x27;&#x27; || sc.ch == &#x27;\&quot;&#x27; ) {
134                      sc.SetState(SCE_ABAQUS_DEFAULT) ;
135                      state = DAT_LINE_VAL ;
136                  }
137              } else if ( sc.ch == &#x27;,&#x27; ) {
138                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
139                  state = DAT_LINE_COMMA ;
140              } else {
141                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
142                  state = ST_ERROR ;
143              }
144              break ;
145          case DAT_LINE_COMMA :
146              if ( sc.atLineEnd ) {
147                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
148                  state = LINE_END ;
149              } else if ( sc.ch == &#x27; &#x27; ) {
150                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
151                  state = DAT_LINE_COMMA ;
152              } else if (sc.ch == &#x27;,&#x27;)  {
153                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
154                  state = DAT_LINE_COMMA ;
155              } else if ( IsADigit(sc.ch) || (sc.ch == &#x27;-&#x27;)|| (sc.ch == &#x27;.&#x27; &amp;&amp; IsADigit(sc.chNext)) ) {
156                  sc.SetState(SCE_ABAQUS_NUMBER) ;
157                  state = DAT_LINE_VAL ;
158              } else if ( IsAKeywordChar(sc.ch) ) {
159                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
160                  state = DAT_LINE_VAL ;
161              } else if ( (sc.ch == &#x27;\&#x27;&#x27;) || (sc.ch == &#x27;\&quot;&#x27;) ) {
162                  sc.SetState(SCE_ABAQUS_STRING) ;
163                  state = DAT_LINE_VAL ;
164              } else {
165                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
166                  state = ST_ERROR ;
167              }
168              break ;
169          case COMMENT_LINE :
170              if ( sc.atLineEnd ) {
171                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
172                  state = LINE_END ;
173              }
174              break ;
175          case ST_ERROR :
176              if ( sc.atLineEnd ) {
177                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
178                  state = LINE_END ;
179              }
180              break ;
181          case LINE_END :
182              if ( sc.atLineEnd || sc.ch == &#x27; &#x27; ) {
183                  state = LINE_END ;
184              } else if ( sc.ch == &#x27;*&#x27; ) {
185                  if ( sc.chNext == &#x27;*&#x27; ) {
186                      state = COMMENT_LINE ;
187                      sc.SetState(SCE_ABAQUS_COMMENT) ;
188                  } else {
189                      state = KW_LINE_KW ;
190                      sc.SetState(SCE_ABAQUS_STARCOMMAND) ;
191                  }
192              } else {
193                  if ( sc.ch == &#x27;,&#x27; ) {
194                      sc.SetState(SCE_ABAQUS_OPERATOR) ;
195                      state = DAT_LINE_COMMA ;
196                  } else if ( IsADigit(sc.ch) || (sc.ch == &#x27;-&#x27;)|| (sc.ch == &#x27;.&#x27; &amp;&amp; IsADigit(sc.chNext)) ) {
197                      sc.SetState(SCE_ABAQUS_NUMBER) ;
198                      state = DAT_LINE_VAL ;
199                  } else if ( IsAKeywordChar(sc.ch) ) {
200                      sc.SetState(SCE_ABAQUS_DEFAULT) ;
201                      state = DAT_LINE_VAL ;
202                  } else if ( (sc.ch == &#x27;\&#x27;&#x27;) || (sc.ch == &#x27;\&quot;&#x27;) ) {
203                      sc.SetState(SCE_ABAQUS_STRING) ;
204                      state = DAT_LINE_VAL ;
205                  } else {
206                      sc.SetState(SCE_ABAQUS_PROCESSOR) ;
207                      state = ST_ERROR ;
208                  }
209              }
210              break ;
211  		  }
212     }
213     sc.Complete();
214  }
215  static int character_classification[128] =
216  {
217      0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,
218      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
219      1,  2,  0,  2,  2,  2,  2,  2,  2,  2,  6,  2,  2,  2,  10, 6,
220      60, 60, 28, 28, 28, 28, 28, 28, 28, 28, 2,  2,  2,  2,  2,  2,
221      2,  20, 20, 20, 20, 20, 20, 4,  4,  4,  4,  4,  4,  4,  4,  4,
222      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  2,  2,  4,
223      2,  20, 20, 20, 20, 20, 20, 4,  4,  4,  4,  4,  4,  4,  4,  4,
224      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  2,  2,  0
225  };
226  static bool IsSpace(int c) {
227  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 1);
228  }
229  static bool IsIdentifier(int c) {
230  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 4);
231  }
232  static int LowerCase(int c)
233  {
234  	if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;)
235  		return &#x27;a&#x27; + c - &#x27;A&#x27;;
236  	return c;
237  }
238  static Sci_Position LineEnd(Sci_Position line, Accessor &amp;styler)
239  {
240      const Sci_Position docLines = styler.GetLine(styler.Length() - 1);  
241      Sci_Position eol_pos ;
242      if ( docLines == line )
243          eol_pos = styler.Length() ;
244      else
245          eol_pos = styler.LineStart(line + 1) - 1;
246      return eol_pos ;
247  }
248  static Sci_Position LineStart(Sci_Position line, Accessor &amp;styler)
249  {
250      return styler.LineStart(line) ;
251  }
252  static int LineType(Sci_Position line, Accessor &amp;styler) {
253      Sci_Position pos = LineStart(line, styler) ;
254      Sci_Position eol_pos = LineEnd(line, styler) ;
255      int c ;
256      char ch = &#x27; &#x27;;
257      Sci_Position i = pos ;
258      while ( i &lt; eol_pos ) {
259          c = styler.SafeGetCharAt(i);
260          ch = static_cast&lt;char&gt;(LowerCase(c));
261          if ( !IsSpace(c) )
262              break ;
263          i++ ;
264      }
265      if ( i &gt;= eol_pos ) {
266          return 3 ;
267      }
268      if ( ch != &#x27;*&#x27; ) {
269          return 1 ;
270      }
271      if ( i == eol_pos - 1 ) {
272          return 4+3 ;
273      }
274      c = styler.SafeGetCharAt(i+1);
275      ch = static_cast&lt;char&gt;(LowerCase(c));
276      if ( ch == &#x27;*&#x27; ) {
277          return 8 ;
278      }
279      char word[256] ;
280      int  wlen = 0;
281      word[wlen] = &#x27;*&#x27; ;
282  	wlen++ ;
283      i++ ;
284      while ( (i &lt; eol_pos) &amp;&amp; (wlen &lt; 255) ) {
285          c = styler.SafeGetCharAt(i);
286          ch = static_cast&lt;char&gt;(LowerCase(c));
287          if ( (!IsSpace(c)) &amp;&amp; (!IsIdentifier(c)) )
288              break ;
289          if ( IsIdentifier(c) ) {
290              word[wlen] = ch ;
291  			wlen++ ;
292  		}
293          i++ ;
294      }
295      word[wlen] = 0 ;
296  	if ( !strcmp(word, &quot;*step&quot;) ||
297           !strcmp(word, &quot;*part&quot;) ||
298           !strcmp(word, &quot;*instance&quot;) ||
299           !strcmp(word, &quot;*assembly&quot;)) {
300         return 4+1 ;
301      }
302  	if ( !strcmp(word, &quot;*endstep&quot;) ||
303           !strcmp(word, &quot;*endpart&quot;) ||
304           !strcmp(word, &quot;*endinstance&quot;) ||
305           !strcmp(word, &quot;*endassembly&quot;)) {
306         return 4+2 ;
307      }
308      return 4 ;
309  }
310  static void SafeSetLevel(Sci_Position line, int level, Accessor &amp;styler)
311  {
312      if ( line &lt; 0 )
313          return ;
314      int mask = ((~SC_FOLDLEVELHEADERFLAG) | (~SC_FOLDLEVELWHITEFLAG));
315      if ( (level &amp; mask) &lt; 0 )
316          return ;
317      if ( styler.LevelAt(line) != level )
318          styler.SetLevel(line, level) ;
319  }
320  static void FoldABAQUSDoc(Sci_PositionU startPos, Sci_Position length, int,
321  WordList *[], Accessor &amp;styler) {
322      Sci_Position startLine = styler.GetLine(startPos) ;
323      Sci_Position endLine   = styler.GetLine(startPos+length-1) ;
324      Sci_Position beginData    = -1 ;
325      Sci_Position beginComment = -1 ;
326      Sci_Position prvKeyLine   = startLine ;
327      Sci_Position prvKeyLineTp =  0 ;
328      while ( prvKeyLine &gt; 0 ) {
329          prvKeyLine-- ;
330          prvKeyLineTp = LineType(prvKeyLine, styler) ;
331          if ( prvKeyLineTp &amp; 4 )
332              break ;
333      }
334      int level = styler.LevelAt(prvKeyLine) &amp; ~SC_FOLDLEVELHEADERFLAG ;
335      prvKeyLine = -1 ;
336      for ( Sci_Position line = startLine; line &lt;= endLine; line++ ) {
337          int lineType = LineType(line, styler) ;
338          if ( lineType == 8 ) {
339              if ( beginComment &lt; 0 ) {
340                  beginComment = line ;
341  			}
342          }
343          if ( (lineType == 1) || (lineType == 3) ) {
344              if ( beginData &lt; 0 ) {
345                  if ( beginComment &gt;= 0 ) {
346                      beginData = beginComment ;
347                  } else {
348                      beginData = line ;
349                  }
350              }
351  			beginComment = -1 ;
352  		}
353          if ( lineType &amp; 4 ) {
354              if ( beginComment &lt; 0 ) {
355                  beginComment = line ;
356  			}
357              if ( beginData &lt; 0 ) {
358                  beginData = beginComment ;
359  				if ( prvKeyLineTp != 5 )
360  					SafeSetLevel(prvKeyLine, level, styler) ;
361  				else
<span onclick='openModal()' class='match'>362  					SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
363              } else {
364                  SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
365              }
366              int datLevel = level + 1 ;
367  			if ( !(prvKeyLineTp &amp; 4) ) {
368  				datLevel = level ;
369  			}
370              for ( Sci_Position ll = beginData; ll &lt; beginComment; ll++ )
371                  SafeSetLevel(ll, datLevel, styler) ;
372              if ( prvKeyLineTp == 5 ) {
373                  level += 1 ;
374  			}
375              if ( prvKeyLineTp == 6 ) {
376                  level -= 1 ;
377  				if ( level &lt; 0 ) {
</span>378  					level = 0 ;
379  				}
380              }
381              for ( Sci_Position lll = beginComment; lll &lt; line; lll++ )
382                  SafeSetLevel(lll, level, styler) ;
383              beginComment = -1 ;
384              beginData    = -1 ;
385              prvKeyLine   = line ;
386              prvKeyLineTp = lineType ;
387          }
388      }
389      if ( beginComment &lt; 0 ) {
390          beginComment = endLine + 1 ;
391      } else {
392          const Sci_Position docLines = styler.GetLine(styler.Length() - 1);
393          for ( Sci_Position line = endLine + 1; line &lt;= docLines; line++ ) {
394              Sci_Position lineType = LineType(line, styler) ;
395              if ( lineType != 8 ) {
396  				if ( !(lineType &amp; 4) )  {
397  					beginComment = endLine + 1 ;
398  				}
399                  break ;
400  			}
401          }
402      }
403      if ( beginData &lt; 0 ) {
404          beginData = beginComment ;
405  		if ( prvKeyLineTp != 5 )
406  			SafeSetLevel(prvKeyLine, level, styler) ;
407  		else
408  			SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
409      } else {
410          SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
411      }
412      int datLevel = level + 1 ;
413  	if ( !(prvKeyLineTp &amp; 4) ) {
414  		datLevel = level ;
415  	}
416      for ( Sci_Position ll = beginData; ll &lt; beginComment; ll++ )
417          SafeSetLevel(ll, datLevel, styler) ;
418      if ( prvKeyLineTp == 5 ) {
419          level += 1 ;
420      }
421      if ( prvKeyLineTp == 6 ) {
422          level -= 1 ;
423      }
424      for ( Sci_Position m = beginComment; m &lt;= endLine; m++ )
425          SafeSetLevel(m, level, styler) ;
426  }
427  static const char * const abaqusWordListDesc[] = {
428      &quot;processors&quot;,
429      &quot;commands&quot;,
430      &quot;slashommands&quot;,
431      &quot;starcommands&quot;,
432      &quot;arguments&quot;,
433      &quot;functions&quot;,
434      0
435  };
436  LexerModule lmAbaqus(SCLEX_ABAQUS, ColouriseABAQUSDoc, &quot;abaqus&quot;, FoldABAQUSDoc, abaqusWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexAbaqus.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static inline bool IsAKeywordChar(const int ch) {
20  	return (ch &lt; 0x80 &amp;&amp; (isalnum(ch) || (ch == &#x27;_&#x27;) || (ch == &#x27; &#x27;)));
21  }
22  static inline bool IsASetChar(const int ch) {
23  	return (ch &lt; 0x80 &amp;&amp; (isalnum(ch) || (ch == &#x27;_&#x27;) || (ch == &#x27;.&#x27;) || (ch == &#x27;-&#x27;)));
24  }
25  static void ColouriseABAQUSDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList*[] &amp;bsol;* *keywordlists[] */,
26                              Accessor &amp;styler) {
27  	enum localState { KW_LINE_KW, KW_LINE_COMMA, KW_LINE_PAR, KW_LINE_EQ, KW_LINE_VAL, \
28  					  DAT_LINE_VAL, DAT_LINE_COMMA,\
29  					  COMMENT_LINE,\
30  					  ST_ERROR, LINE_END } state ;
31  	state = LINE_END ;
32  	initStyle = SCE_ABAQUS_DEFAULT;
33  	StyleContext sc(startPos, length, initStyle, styler);
34  	for (; sc.More(); sc.Forward()) {
35  		switch ( state ) {
36          case KW_LINE_KW :
37              if ( sc.atLineEnd ) {
38                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
39                  state = LINE_END ;
40              } else if ( IsAKeywordChar(sc.ch) ) {
41                  state = KW_LINE_KW ;
42              } else if ( sc.ch == &#x27;,&#x27; ) {
43                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
44                  state = KW_LINE_COMMA ;
45              } else {
46                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
47                  state = ST_ERROR ;
48              }
49              break ;
50          case KW_LINE_COMMA :
51              if ( IsAKeywordChar(sc.ch)) {
52                  sc.SetState(SCE_ABAQUS_ARGUMENT) ;
53                  state = KW_LINE_PAR ;
54              } else if ( sc.atLineEnd || (sc.ch == &#x27;,&#x27;) ) {
55                  state = KW_LINE_COMMA ;
56              } else if ( sc.ch == &#x27; &#x27; ) {
57                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
58                  state = KW_LINE_COMMA ;
59              } else {
60                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
61                  state = ST_ERROR ;
62              }
63              break ;
64          case KW_LINE_PAR :
65              if ( sc.atLineEnd ) {
66                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
67                  state = LINE_END ;
68              } else if ( IsAKeywordChar(sc.ch) || (sc.ch == &#x27;-&#x27;) ) {
69                  state = KW_LINE_PAR ;
70              } else if ( sc.ch == &#x27;,&#x27; ) {
71                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
72                  state = KW_LINE_COMMA ;
73              } else if ( sc.ch == &#x27;=&#x27; ) {
74                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
75                  state = KW_LINE_EQ ;
76              } else {
77                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
78                  state = ST_ERROR ;
79              }
80              break ;
81          case KW_LINE_EQ :
82              if ( sc.ch == &#x27; &#x27; ) {
83                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
84                  state = KW_LINE_EQ ;
85              } else if ( IsADigit(sc.ch) || (sc.ch == &#x27;-&#x27;) || (sc.ch == &#x27;.&#x27; &amp;&amp; IsADigit(sc.chNext)) ) {
86                  sc.SetState(SCE_ABAQUS_NUMBER) ;
87                  state = KW_LINE_VAL ;
88              } else if ( IsAKeywordChar(sc.ch) ) {
89                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
90                  state = KW_LINE_VAL ;
91              } else if ( (sc.ch == &#x27;\&#x27;&#x27;) || (sc.ch == &#x27;\&quot;&#x27;) ) {
92                  sc.SetState(SCE_ABAQUS_STRING) ;
93                  state = KW_LINE_VAL ;
94              } else {
95                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
96                  state = ST_ERROR ;
97              }
98              break ;
99          case KW_LINE_VAL :
100              if ( sc.atLineEnd ) {
101                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
102                  state = LINE_END ;
103              } else if ( IsASetChar(sc.ch) &amp;&amp; (sc.state == SCE_ABAQUS_DEFAULT) ) {
104                  state = KW_LINE_VAL ;
105              } else if (( (IsADigit(sc.ch) || sc.ch == &#x27;.&#x27; || (sc.ch == &#x27;e&#x27; || sc.ch == &#x27;E&#x27;) ||
106                      ((sc.ch == &#x27;+&#x27; || sc.ch == &#x27;-&#x27;) &amp;&amp; (sc.chPrev == &#x27;e&#x27; || sc.chPrev == &#x27;E&#x27;)))) &amp;&amp;
107                      (sc.state == SCE_ABAQUS_NUMBER)) {
108                  state = KW_LINE_VAL ;
109              } else if (sc.state == SCE_ABAQUS_STRING) {
110                  if ( sc.ch == &#x27;\&#x27;&#x27; || sc.ch == &#x27;\&quot;&#x27; ) {
111                      sc.SetState(SCE_ABAQUS_DEFAULT) ;
112                      state = KW_LINE_VAL ;
113                  }
114              } else if ( sc.ch == &#x27;,&#x27; ) {
115                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
116                  state = KW_LINE_COMMA ;
117              } else {
118                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
119                  state = ST_ERROR ;
120              }
121              break ;
122          case DAT_LINE_VAL :
123              if ( sc.atLineEnd ) {
124                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
125                  state = LINE_END ;
126              } else if ( IsASetChar(sc.ch) &amp;&amp; (sc.state == SCE_ABAQUS_DEFAULT) ) {
127                  state = DAT_LINE_VAL ;
128              } else if (( (IsADigit(sc.ch) || sc.ch == &#x27;.&#x27; || (sc.ch == &#x27;e&#x27; || sc.ch == &#x27;E&#x27;) ||
129                      ((sc.ch == &#x27;+&#x27; || sc.ch == &#x27;-&#x27;) &amp;&amp; (sc.chPrev == &#x27;e&#x27; || sc.chPrev == &#x27;E&#x27;)))) &amp;&amp;
130                      (sc.state == SCE_ABAQUS_NUMBER)) {
131                  state = DAT_LINE_VAL ;
132              } else if (sc.state == SCE_ABAQUS_STRING) {
133                  if ( sc.ch == &#x27;\&#x27;&#x27; || sc.ch == &#x27;\&quot;&#x27; ) {
134                      sc.SetState(SCE_ABAQUS_DEFAULT) ;
135                      state = DAT_LINE_VAL ;
136                  }
137              } else if ( sc.ch == &#x27;,&#x27; ) {
138                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
139                  state = DAT_LINE_COMMA ;
140              } else {
141                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
142                  state = ST_ERROR ;
143              }
144              break ;
145          case DAT_LINE_COMMA :
146              if ( sc.atLineEnd ) {
147                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
148                  state = LINE_END ;
149              } else if ( sc.ch == &#x27; &#x27; ) {
150                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
151                  state = DAT_LINE_COMMA ;
152              } else if (sc.ch == &#x27;,&#x27;)  {
153                  sc.SetState(SCE_ABAQUS_OPERATOR) ;
154                  state = DAT_LINE_COMMA ;
155              } else if ( IsADigit(sc.ch) || (sc.ch == &#x27;-&#x27;)|| (sc.ch == &#x27;.&#x27; &amp;&amp; IsADigit(sc.chNext)) ) {
156                  sc.SetState(SCE_ABAQUS_NUMBER) ;
157                  state = DAT_LINE_VAL ;
158              } else if ( IsAKeywordChar(sc.ch) ) {
159                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
160                  state = DAT_LINE_VAL ;
161              } else if ( (sc.ch == &#x27;\&#x27;&#x27;) || (sc.ch == &#x27;\&quot;&#x27;) ) {
162                  sc.SetState(SCE_ABAQUS_STRING) ;
163                  state = DAT_LINE_VAL ;
164              } else {
165                  sc.SetState(SCE_ABAQUS_PROCESSOR) ;
166                  state = ST_ERROR ;
167              }
168              break ;
169          case COMMENT_LINE :
170              if ( sc.atLineEnd ) {
171                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
172                  state = LINE_END ;
173              }
174              break ;
175          case ST_ERROR :
176              if ( sc.atLineEnd ) {
177                  sc.SetState(SCE_ABAQUS_DEFAULT) ;
178                  state = LINE_END ;
179              }
180              break ;
181          case LINE_END :
182              if ( sc.atLineEnd || sc.ch == &#x27; &#x27; ) {
183                  state = LINE_END ;
184              } else if ( sc.ch == &#x27;*&#x27; ) {
185                  if ( sc.chNext == &#x27;*&#x27; ) {
186                      state = COMMENT_LINE ;
187                      sc.SetState(SCE_ABAQUS_COMMENT) ;
188                  } else {
189                      state = KW_LINE_KW ;
190                      sc.SetState(SCE_ABAQUS_STARCOMMAND) ;
191                  }
192              } else {
193                  if ( sc.ch == &#x27;,&#x27; ) {
194                      sc.SetState(SCE_ABAQUS_OPERATOR) ;
195                      state = DAT_LINE_COMMA ;
196                  } else if ( IsADigit(sc.ch) || (sc.ch == &#x27;-&#x27;)|| (sc.ch == &#x27;.&#x27; &amp;&amp; IsADigit(sc.chNext)) ) {
197                      sc.SetState(SCE_ABAQUS_NUMBER) ;
198                      state = DAT_LINE_VAL ;
199                  } else if ( IsAKeywordChar(sc.ch) ) {
200                      sc.SetState(SCE_ABAQUS_DEFAULT) ;
201                      state = DAT_LINE_VAL ;
202                  } else if ( (sc.ch == &#x27;\&#x27;&#x27;) || (sc.ch == &#x27;\&quot;&#x27;) ) {
203                      sc.SetState(SCE_ABAQUS_STRING) ;
204                      state = DAT_LINE_VAL ;
205                  } else {
206                      sc.SetState(SCE_ABAQUS_PROCESSOR) ;
207                      state = ST_ERROR ;
208                  }
209              }
210              break ;
211  		  }
212     }
213     sc.Complete();
214  }
215  static int character_classification[128] =
216  {
217      0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,
218      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
219      1,  2,  0,  2,  2,  2,  2,  2,  2,  2,  6,  2,  2,  2,  10, 6,
220      60, 60, 28, 28, 28, 28, 28, 28, 28, 28, 2,  2,  2,  2,  2,  2,
221      2,  20, 20, 20, 20, 20, 20, 4,  4,  4,  4,  4,  4,  4,  4,  4,
222      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  2,  2,  4,
223      2,  20, 20, 20, 20, 20, 20, 4,  4,  4,  4,  4,  4,  4,  4,  4,
224      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  2,  2,  0
225  };
226  static bool IsSpace(int c) {
227  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 1);
228  }
229  static bool IsIdentifier(int c) {
230  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 4);
231  }
232  static int LowerCase(int c)
233  {
234  	if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;)
235  		return &#x27;a&#x27; + c - &#x27;A&#x27;;
236  	return c;
237  }
238  static Sci_Position LineEnd(Sci_Position line, Accessor &amp;styler)
239  {
240      const Sci_Position docLines = styler.GetLine(styler.Length() - 1);  
241      Sci_Position eol_pos ;
242      if ( docLines == line )
243          eol_pos = styler.Length() ;
244      else
245          eol_pos = styler.LineStart(line + 1) - 1;
246      return eol_pos ;
247  }
248  static Sci_Position LineStart(Sci_Position line, Accessor &amp;styler)
249  {
250      return styler.LineStart(line) ;
251  }
252  static int LineType(Sci_Position line, Accessor &amp;styler) {
253      Sci_Position pos = LineStart(line, styler) ;
254      Sci_Position eol_pos = LineEnd(line, styler) ;
255      int c ;
256      char ch = &#x27; &#x27;;
257      Sci_Position i = pos ;
258      while ( i &lt; eol_pos ) {
259          c = styler.SafeGetCharAt(i);
260          ch = static_cast&lt;char&gt;(LowerCase(c));
261          if ( !IsSpace(c) )
262              break ;
263          i++ ;
264      }
265      if ( i &gt;= eol_pos ) {
266          return 3 ;
267      }
268      if ( ch != &#x27;*&#x27; ) {
269          return 1 ;
270      }
271      if ( i == eol_pos - 1 ) {
272          return 4+3 ;
273      }
274      c = styler.SafeGetCharAt(i+1);
275      ch = static_cast&lt;char&gt;(LowerCase(c));
276      if ( ch == &#x27;*&#x27; ) {
277          return 8 ;
278      }
279      char word[256] ;
280      int  wlen = 0;
281      word[wlen] = &#x27;*&#x27; ;
282  	wlen++ ;
283      i++ ;
284      while ( (i &lt; eol_pos) &amp;&amp; (wlen &lt; 255) ) {
285          c = styler.SafeGetCharAt(i);
286          ch = static_cast&lt;char&gt;(LowerCase(c));
287          if ( (!IsSpace(c)) &amp;&amp; (!IsIdentifier(c)) )
288              break ;
289          if ( IsIdentifier(c) ) {
290              word[wlen] = ch ;
291  			wlen++ ;
292  		}
293          i++ ;
294      }
295      word[wlen] = 0 ;
296  	if ( !strcmp(word, &quot;*step&quot;) ||
297           !strcmp(word, &quot;*part&quot;) ||
298           !strcmp(word, &quot;*instance&quot;) ||
299           !strcmp(word, &quot;*assembly&quot;)) {
300         return 4+1 ;
301      }
302  	if ( !strcmp(word, &quot;*endstep&quot;) ||
303           !strcmp(word, &quot;*endpart&quot;) ||
304           !strcmp(word, &quot;*endinstance&quot;) ||
305           !strcmp(word, &quot;*endassembly&quot;)) {
306         return 4+2 ;
307      }
308      return 4 ;
309  }
310  static void SafeSetLevel(Sci_Position line, int level, Accessor &amp;styler)
311  {
312      if ( line &lt; 0 )
313          return ;
314      int mask = ((~SC_FOLDLEVELHEADERFLAG) | (~SC_FOLDLEVELWHITEFLAG));
315      if ( (level &amp; mask) &lt; 0 )
316          return ;
317      if ( styler.LevelAt(line) != level )
318          styler.SetLevel(line, level) ;
319  }
320  static void FoldABAQUSDoc(Sci_PositionU startPos, Sci_Position length, int,
321  WordList *[], Accessor &amp;styler) {
322      Sci_Position startLine = styler.GetLine(startPos) ;
323      Sci_Position endLine   = styler.GetLine(startPos+length-1) ;
324      Sci_Position beginData    = -1 ;
325      Sci_Position beginComment = -1 ;
326      Sci_Position prvKeyLine   = startLine ;
327      Sci_Position prvKeyLineTp =  0 ;
328      while ( prvKeyLine &gt; 0 ) {
329          prvKeyLine-- ;
330          prvKeyLineTp = LineType(prvKeyLine, styler) ;
331          if ( prvKeyLineTp &amp; 4 )
332              break ;
333      }
334      int level = styler.LevelAt(prvKeyLine) &amp; ~SC_FOLDLEVELHEADERFLAG ;
335      prvKeyLine = -1 ;
336      for ( Sci_Position line = startLine; line &lt;= endLine; line++ ) {
337          int lineType = LineType(line, styler) ;
338          if ( lineType == 8 ) {
339              if ( beginComment &lt; 0 ) {
340                  beginComment = line ;
341  			}
342          }
343          if ( (lineType == 1) || (lineType == 3) ) {
344              if ( beginData &lt; 0 ) {
345                  if ( beginComment &gt;= 0 ) {
346                      beginData = beginComment ;
347                  } else {
348                      beginData = line ;
349                  }
350              }
351  			beginComment = -1 ;
352  		}
353          if ( lineType &amp; 4 ) {
354              if ( beginComment &lt; 0 ) {
355                  beginComment = line ;
356  			}
357              if ( beginData &lt; 0 ) {
358                  beginData = beginComment ;
359  				if ( prvKeyLineTp != 5 )
360  					SafeSetLevel(prvKeyLine, level, styler) ;
361  				else
362  					SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
363              } else {
364                  SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
365              }
366              int datLevel = level + 1 ;
367  			if ( !(prvKeyLineTp &amp; 4) ) {
368  				datLevel = level ;
369  			}
370              for ( Sci_Position ll = beginData; ll &lt; beginComment; ll++ )
371                  SafeSetLevel(ll, datLevel, styler) ;
372              if ( prvKeyLineTp == 5 ) {
373                  level += 1 ;
374  			}
375              if ( prvKeyLineTp == 6 ) {
376                  level -= 1 ;
377  				if ( level &lt; 0 ) {
378  					level = 0 ;
379  				}
380              }
381              for ( Sci_Position lll = beginComment; lll &lt; line; lll++ )
382                  SafeSetLevel(lll, level, styler) ;
383              beginComment = -1 ;
384              beginData    = -1 ;
385              prvKeyLine   = line ;
386              prvKeyLineTp = lineType ;
387          }
388      }
389      if ( beginComment &lt; 0 ) {
390          beginComment = endLine + 1 ;
391      } else {
392          const Sci_Position docLines = styler.GetLine(styler.Length() - 1);
393          for ( Sci_Position line = endLine + 1; line &lt;= docLines; line++ ) {
394              Sci_Position lineType = LineType(line, styler) ;
395              if ( lineType != 8 ) {
396  				if ( !(lineType &amp; 4) )  {
397  					beginComment = endLine + 1 ;
398  				}
399                  break ;
400  			}
401          }
402      }
403      if ( beginData &lt; 0 ) {
404          beginData = beginComment ;
405  		if ( prvKeyLineTp != 5 )
406  			SafeSetLevel(prvKeyLine, level, styler) ;
407  		else
<span onclick='openModal()' class='match'>408  			SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
409      } else {
410          SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
411      }
412      int datLevel = level + 1 ;
413  	if ( !(prvKeyLineTp &amp; 4) ) {
414  		datLevel = level ;
415  	}
416      for ( Sci_Position ll = beginData; ll &lt; beginComment; ll++ )
417          SafeSetLevel(ll, datLevel, styler) ;
418      if ( prvKeyLineTp == 5 ) {
419          level += 1 ;
420      }
421      if ( prvKeyLineTp == 6 ) {
422          level -= 1 ;
423      }
</span>424      for ( Sci_Position m = beginComment; m &lt;= endLine; m++ )
425          SafeSetLevel(m, level, styler) ;
426  }
427  static const char * const abaqusWordListDesc[] = {
428      &quot;processors&quot;,
429      &quot;commands&quot;,
430      &quot;slashommands&quot;,
431      &quot;starcommands&quot;,
432      &quot;arguments&quot;,
433      &quot;functions&quot;,
434      0
435  };
436  LexerModule lmAbaqus(SCLEX_ABAQUS, ColouriseABAQUSDoc, &quot;abaqus&quot;, FoldABAQUSDoc, abaqusWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexAbaqus.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexAbaqus.cxx</div>
                </div>
                <div class="column column_space"><pre><code>362  					SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
363              } else {
364                  SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
365              }
366              int datLevel = level + 1 ;
367  			if ( !(prvKeyLineTp &amp; 4) ) {
368  				datLevel = level ;
369  			}
370              for ( Sci_Position ll = beginData; ll &lt; beginComment; ll++ )
371                  SafeSetLevel(ll, datLevel, styler) ;
372              if ( prvKeyLineTp == 5 ) {
373                  level += 1 ;
374  			}
375              if ( prvKeyLineTp == 6 ) {
376                  level -= 1 ;
377  				if ( level &lt; 0 ) {
</pre></code></div>
                <div class="column column_space"><pre><code>408  			SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
409      } else {
410          SafeSetLevel(prvKeyLine, level | SC_FOLDLEVELHEADERFLAG, styler) ;
411      }
412      int datLevel = level + 1 ;
413  	if ( !(prvKeyLineTp &amp; 4) ) {
414  		datLevel = level ;
415  	}
416      for ( Sci_Position ll = beginData; ll &lt; beginComment; ll++ )
417          SafeSetLevel(ll, datLevel, styler) ;
418      if ( prvKeyLineTp == 5 ) {
419          level += 1 ;
420      }
421      if ( prvKeyLineTp == 6 ) {
422          level -= 1 ;
423      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    