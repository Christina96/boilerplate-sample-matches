
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.496532593619972%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-subprocess.cpp</h3>
            <pre><code>1  #include "subprocess.h"
2  const TStr& TSubProcess::GetCmd() const {
3  	return Cmd;
4  }
5  bool TSubProcess::IsRead(TSubProcessMode M) {
6  	return M == spmRead || M == spmReadWrite;
7  }
8  bool TSubProcess::IsWrite(TSubProcessMode M) {
9  	return M == spmWrite || M == spmReadWrite;
10  }
11  void TSubProcess::Stream(const PSIn& In, const PSOut& Out) {
12  	Stream(*In, *Out);
13  }
14  void TSubProcess::Stream(TSIn& In, TSOut& Out) {
15  	const int MxBfL = 4 * 1024;
16  	char Bf[4 * 1024];
17  	while (!In.Eof()) {
18  		int Len = In.Len();
19  		if (Len == 0 || Len > MxBfL) {
20  			Len = MxBfL;
21  		}
22  		In.GetBf(Bf, Len);
23  		Out.PutBf(Bf, Len);
24  	}
25  }
26  PSubProcess TSubProcess::New(const TStr& Cmd_, TSubProcessMode Mod_) {
27  	return new TSubProcess(Cmd_, Mod_);
28  }
29  #ifndef GLib_WIN
30  int TSubProcess::Open(char *cmd,            
31                  char *argv[],         
32                  const char *type,     
33                  FILE **pfp_read,      
34                  FILE **pfp_write,     
35                  int *ppid,            
36                  int *fd_to_close_in_child,        
37                  int fd_to_close_in_child_count)   
38  {
39      int j, pfd_read[2], pfd_write[2];
40      assert(pfp_read);
41      assert(pfp_write);
42      assert(cmd);
43      assert(argv);
44      assert(type);
45      assert(ppid);
46      assert(!fd_to_close_in_child_count || fd_to_close_in_child);
47      if (!pfp_read || !pfp_write) return 0;
48      *pfp_read=NULL;
49      *pfp_write=NULL;
50      if (!cmd || !argv || !type || !ppid) return 0;
51      if (pipe(pfd_read)<0) return 0;
52      if (pipe(pfd_write)<0) {
53          close(pfd_read[0]);
54          close(pfd_read[1]);
55          return 0;
56      }
57      if ((*ppid=(int)fork())<0) {
58          close(pfd_read[0]);
59          close(pfd_read[1]);
60          close(pfd_write[0]);
61          close(pfd_write[1]);
62          return 0;
63      }
64      if (!*ppid) {
65          if (STDOUT_FILENO!=pfd_read[1]) {
66              dup2(pfd_read[1],STDOUT_FILENO);
67              close(pfd_read[1]);
68          }
69          close(pfd_read[0]);
70          if (STDIN_FILENO!=pfd_write[0]) {
71              dup2(pfd_write[0],STDIN_FILENO);
72              close(pfd_write[0]);
73          }
74          close(pfd_write[1]);
75          for (j=0; j<fd_to_close_in_child_count; j++)
76              close(fd_to_close_in_child[j]);
77          if (strstr(type,"p")) execvp(cmd, argv);
78          else execv(cmd, argv);
79          _exit(127); 
80      }
81      close(pfd_read[1]);
82      close(pfd_write[0]);
83      if (!(*pfp_read=fdopen(pfd_read[0],"r"))) {
84          close(pfd_read[0]);
85          close(pfd_write[1]);
86          return 0;
87      }
88      if (!(*pfp_write=fdopen(pfd_write[1],"w"))) {
89          fclose(*pfp_read);  
90          *pfp_read=NULL;
91          close(pfd_write[1]);
92          return 0;
93      }
94      return 1;
95  }    
96  int TSubProcess::Close(FILE *fp_read,   
97                   FILE *fp_write,  
98                   int pid,         
99                   int *result)     
100  {
101      int res1, res2, status;
102      if (result) *result=255;
103      if (fp_read) res1=fclose(fp_read);
104      else res1=0;
105      if (fp_write) res2=fclose(fp_write);
106      else res2=0;
107      if (res1==EOF || res2==EOF) return 0;
108      if (!pid) return 0;
109      while (waitpid((pid_t)pid,&status,0)<0) if (EINTR!=errno) return 0;
110      if (result && WIFEXITED(status)) *result=WEXITSTATUS(status);
111      return 1;
112  }    
113  #endif
114  TSubProcess::TSubProcess(const TStr& Cmd_, TSubProcessMode Mod_) : 
115  	 Cmd(Cmd_), Mode(Mod_), StdoutWr(NULL), StdinWr(NULL), StdinRd(NULL), StdoutRd(NULL) {
116  	Thr.SetSubProcess(this);
117  	#ifdef GLib_WIN
118  	SECURITY_ATTRIBUTES saAttr;
119  	saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
120  	saAttr.bInheritHandle = TRUE;
121  	saAttr.lpSecurityDescriptor = NULL;
122  	const int PipeBufferSz = 1024*1024;
123  	if (IsRead(Mode)) {
124  		EAssertR(CreatePipe(&StdoutRd, &StdoutWr, &saAttr, PipeBufferSz), "Stdout pipe creation failed");
125  		SetHandleInformation(StdoutRd, HANDLE_FLAG_INHERIT, 0);
126  	}
127  	if (IsWrite(Mode)) {
128  		EAssertR(CreatePipe(&StdinRd, &StdinWr, &saAttr, 0), "Stdout pipe creation failed");
129  		SetHandleInformation(StdinWr, HANDLE_FLAG_INHERIT, 0);
130  	}
131  	PROCESS_INFORMATION piProcInfo;
132  	STARTUPINFO siStartInfo;
133  	ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
134  	ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
135  	siStartInfo.cb = sizeof(STARTUPINFO);
136  	siStartInfo.hStdOutput = StdoutWr;
137  	siStartInfo.hStdInput = StdinRd;
138  	siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
139  	const BOOL FuncRetn = CreateProcess(NULL,
140  		(LPSTR) Cmd.CStr(),  
141  		NULL,          
142  		NULL,          
143  		TRUE,          
144  		0,             
145  		NULL,          
146  		NULL,          
147  		&siStartInfo,  
148  		&piProcInfo);  
149  	EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s'", Cmd.CStr()).CStr());
150  	CloseHandle(piProcInfo.hProcess);
151  	CloseHandle(piProcInfo.hThread);
152  	Thr.Start();
153  	#else
154  		TStrV Args;
155  		Cmd.SplitOnAllCh(' ', Args);
156  		const char **argv = new char *[Args.Len()];
157  		for (int i = 0; i < Args.Len(); i++) {
158  			argv[i] = Args[i].CStr();
159  		}
160  		const char *cmd = argv[0].CStr();
161  		int fd_to_close_in_child, fd_count;
162  		Open(cmd, argv, "p", &StdoutRd, &StdinWr, &Pid, NULL, 0);
163  	#endif
164  }
165  PSIn TSubProcess::OpenForReading() {
166  	Thr.Join();
167  	return TMemIn::New(Thr.Output);
168  }
169  PSOut TSubProcess::OpenForWriting() {
170  	EAssertR(IsWrite(Mode), "Process was not opened in write mode");
171  	return new TSubProcessOut(this);
172  }
173  PSIn TSubProcess::Pipe(const PSIn& In) {
174  	if (IsWrite(Mode)) {
175  		PSOut SOut = OpenForWriting();
176  		Stream(In, SOut);
177  		SOut->Flush();
178  		CloseForWriting();
179  	}
180  	if (IsRead(Mode)) {
181  		return OpenForReading();
182  	} else {
183  		return NULL;
184  	}
185  }
186  void TSubProcess::Execute(const PSIn& Send, PSOut& Receive) { 
<span onclick='openModal()' class='match'>187  	if (IsWrite(Mode)) {
188  		PSOut SOut = OpenForWriting();
189  		Stream(Send, SOut);
190  		SOut->Flush();
191  		CloseForWriting();
192  	}
193  	if (IsRead(Mode)) {
194  		PSIn SIn = OpenForReading();
195  		Stream(SIn, Receive);
196  		Receive->Flush();
197  		CloseForReading();
198  	}
199  }
</span>200  void TSubProcess::CloseForWriting() {
201  	if (StdinRd != NULL) { 
202  		EAssertR(CloseHandle(StdinRd), "Closing read-end of pipe failed");
203  		StdinRd = NULL;
204  	}
205  	if (StdinWr != NULL) { 
206  		EAssertR(CloseHandle(StdinWr), "Closing write-end of pipe failed"); 
207  		StdinWr = NULL;
208  	}
209  }
210  void TSubProcess::CloseForReading() {
211  	if (StdoutRd != NULL) {
212  		EAssertR(CloseHandle(StdoutRd), "Closing read-end of pipe failed"); 
213  		StdoutRd = NULL;
214  	}
215  	if (StdoutWr != NULL) {
216  		EAssertR(CloseHandle(StdoutWr), "Closing write-end of pipe failed"); 
217  		StdoutWr = NULL;
218  	}
219  }
220  TSubProcess::~TSubProcess() {
221  	#ifdef GLib_WIN
222  	CloseForWriting();
223  	CloseForReading();	
224  	#else
225  	int Result = 0;
226  	Close(StdoutRd, StdoutWr,  Pid, &Result);
227  	#endif
228  }
229  TSubProcessHandlerThread::TSubProcessHandlerThread() : Proc(NULL), Output(TMem::New()) {
230  }
231  void TSubProcessHandlerThread::Run() {
232  	PSOut SOut = TMemOut::New(Output);
233  	IAssert(Proc != NULL);
234  	PSIn SIn = new TSubProcessIn(Proc);
235  	TSubProcess::Stream(SIn, SOut);
236  }
237  void TSubProcessHandlerThread::SetSubProcess(TSubProcess *P) {
238  	Proc = P;
239  }
240  const int TSubProcessIn::MxBfL=4096; 
241  void TSubProcessIn::FillBf(){
242  	EAssertR((BfC==BfL)&bsol;*&&((BfL==-1)||(BfL==MxBfL))*/, "Error reading file '"+GetSNm()+"'.");
243  #ifdef GLib_WIN
244  	DWORD BytesRead = 0;
245  	if(ReadFile(Proc->StdoutRd, Bf, MxBfL, &BytesRead, NULL) == 0) {
246  		DWORD error = GetLastError();
247  		if (error != ERROR_HANDLE_EOF) {
248  			EFailR(TStr::Fmt("Error reading archive. %d", error));
249  		}
250  	}
251    #else
252    size_t BytesRead;
253    if (feof(StdoutRd)) {
254  	  FLen = CurFPos;
255  	  BfL = 0;
256  	  BfC = 0;
257    } else {
258  	  BytesRead = fread(Bf, 1, MxBfL, StdoutRd);
259  	  EAssertR(BytesRead != 0, "Error reading archive.");
260    }
261    #endif
262    if (BytesRead < MxBfL) {
263  		FLen = CurFPos + BytesRead;
264    }
265    BfL = (int) BytesRead;
266    CurFPos += BytesRead;
267    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
268    BfC = 0;
269  }
270  TSubProcessIn::TSubProcessIn(const TStr& Cmd) : TSBase(Cmd.CStr()), TSIn(Cmd),
271    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0), IsEof(false) {
272    EAssertR(! Cmd.Empty(), "Empty command.");
273    Proc = new TSubProcess(Cmd, spmRead);
274    Bf = new char[MxBfL]; BfC = BfL=-1;
275  }
276  TSubProcessIn::TSubProcessIn(PSubProcess _Proc) : TSBase(_Proc->GetCmd().CStr()), TSIn(_Proc->GetCmd()), Proc(_Proc),
277    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0), IsEof(false) {
278  	EAssertR((!Proc.Empty() && !Proc->GetCmd().Empty()), "Empty command.");
279  	Bf = new char[MxBfL]; BfC = BfL=-1;
280  }
281  PSIn TSubProcessIn::New(const TStr& FNm) {
282    return PSIn(new TSubProcessIn(FNm));
283  }
284  PSIn TSubProcessIn::New(PSubProcess Proc) {
285    return PSIn(new TSubProcessIn(Proc));
286  }
287  TSubProcessIn::~TSubProcessIn(){
288    if (Bf != NULL) { delete[] Bf; }
289  }
290  int TSubProcessIn::GetBf(const void* LBf, const TSize& LBfL){
291  	#ifdef GLib_WIN
292  	DWORD BytesRead = 0;
293  	if(ReadFile(Proc->StdoutRd, (char *)LBf, (DWORD) LBfL, &BytesRead, NULL) == 0) {
294  		DWORD error = GetLastError();
295  		if (error != ERROR_HANDLE_EOF) {
296  			EFailR(TStr::Fmt("Error reading archive. %d", error));
297  		} else {
298  			IsEof = true;
299  		}
300  	}
301    #else
302    size_t BytesRead;
303    if (feof(StdoutRd)) {
304  	  FLen = CurFPos;
305  	  BfL = 0;
306  	  BfC = 0;
307    } else {
308  	  BytesRead = fread(LBf, 1, LBfL, StdoutRd);
309  	  EAssertR(BytesRead != 0, "Error reading archive.");
310    }
311    #endif
312    if (BytesRead < MxBfL) {
313  		FLen = CurFPos + BytesRead;
314  		IsEof = true;
315    }
316    BfL = (int) BytesRead;
317    CurFPos += BytesRead;
318    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
319    BfC = 0;
320    return 0;
321  }
322  TStrStrH TSubProcessOut::FExtToCmdH;
323  const TSize TSubProcessOut::MxBfL=4*1024;
324  void TSubProcessOut::FlushBf() {
325    #ifdef GLib_WIN
326    DWORD BytesOut;
327    EAssertR(WriteFile(Proc->StdinWr, Bf, DWORD(BfL), &BytesOut, NULL)!=0, "Error writting to the file '"+GetSNm()+"'.");
328    #else
329    size_t BytesOut = fwrite(Bf, 1, BfL, Proc->StdinWr);
330    #endif
331    EAssert(BytesOut == BfL);
332    BfL = 0;
333  }
334  void TSubProcessOut::Write(const char *Bf, int BfL) {
335    #ifdef GLib_WIN
336    DWORD BytesOut;
337    EAssertR(WriteFile(Proc->StdinWr, Bf, DWORD(BfL), &BytesOut, NULL)!=0, "Error writting to pipe '"+GetSNm()+"'.");
338    #else
339    size_t BytesOut = fwrite(Bf, 1, BfL, Proc->StdinWr);
340    #endif
341    EAssert(BytesOut == BfL);
342    BfL = 0;
343  }
344  TSubProcessOut::TSubProcessOut(const TStr& Cmd) : TSBase(Cmd.CStr()), TSOut(Cmd), Bf(NULL), BfL(0) {
345    EAssertR(! Cmd.Empty(), "Empty file-name.");
346    Proc = new TSubProcess(Cmd, spmWrite);
347    Bf=new char[MxBfL];  BfL=0;
348  }
349  PSOut TSubProcessOut::New(const TStr& FNm){
350    return PSOut(new TSubProcessOut(FNm));
351  }
352  TSubProcessOut::TSubProcessOut(PSubProcess _Proc) : TSBase(_Proc->GetCmd().CStr()), TSOut(_Proc->GetCmd()), Proc(_Proc),Bf(NULL), BfL(0) {
353  	EAssertR((!Proc.Empty() && !Proc->GetCmd().Empty()), "Empty command.");
354  	Bf = new char[MxBfL]; 
355  	BfL = 0;
356  }
357  PSOut TSubProcessOut::New(PSubProcess Proc){
358  	return PSOut(new TSubProcessOut(Proc));
359  }
360  TSubProcessOut::~TSubProcessOut() {
361  	if (BfL!=0) { FlushBf(); }
362  	if (Bf!=NULL) { delete[] Bf; }
363  }
364  int TSubProcessOut::PutCh(const char& Ch){
365  	if (BfL==MxBfL) {FlushBf();}
366  	return Bf[BfL++]=Ch;
367  }
368  int TSubProcessOut::PutBf(const void* LBf, const TSize& LBfL){
369  	int LBfS=0;
370  	if (BfL+LBfL>MxBfL){
371  		for (TSize LBfC=0; LBfC<LBfL; LBfC++){
372  			LBfS+=PutCh(((char*)LBf)[LBfC]);}
373  	} else {
374  		for (TSize LBfC=0; LBfC<LBfL; LBfC++){
375  		LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
376  	}
377    return LBfS;
378  }
379  void TSubProcessOut::Flush(){
380    FlushBf();
381    #ifdef GLib_WIN
382    #else
383    EAssertR(fflush(Proc->StdinWr)==0, "Can not flush file '"+GetSNm()+"'.");
384    #endif
385  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.cpp</h3>
            <pre><code>1  #include "shapetable.h"
2  #include "bitvector.h"
3  #include "fontinfo.h"
4  #include "intfeaturespace.h"
5  #include "unicharset.h"
6  #include "unicity_table.h"
7  #include <algorithm>
8  namespace tesseract {
9  int ShapeRating::FirstResultWithUnichar(const std::vector<ShapeRating> &results,
10                                          const ShapeTable &shape_table, UNICHAR_ID unichar_id) {
11    for (unsigned r = 0; r < results.size(); ++r) {
12      const auto shape_id = results[r].shape_id;
13      const Shape &shape = shape_table.GetShape(shape_id);
14      if (shape.ContainsUnichar(unichar_id)) {
15        return r;
16      }
17    }
18    return -1;
19  }
20  int UnicharRating::FirstResultWithUnichar(const std::vector<UnicharRating> &results,
21                                            UNICHAR_ID unichar_id) {
22    for (unsigned r = 0; r < results.size(); ++r) {
23      if (results[r].unichar_id == unichar_id) {
24        return r;
25      }
26    }
27    return -1;
28  }
29  bool UnicharAndFonts::Serialize(FILE *fp) const {
30    return tesseract::Serialize(fp, &unichar_id) && tesseract::Serialize(fp, font_ids);
31  }
32  bool UnicharAndFonts::DeSerialize(TFile *fp) {
33    return fp->DeSerialize(&unichar_id) && fp->DeSerialize(font_ids);
34  }
35  int UnicharAndFonts::SortByUnicharId(const void *v1, const void *v2) {
36    const auto *p1 = static_cast<const UnicharAndFonts *>(v1);
37    const auto *p2 = static_cast<const UnicharAndFonts *>(v2);
38    return p1->unichar_id - p2->unichar_id;
39  }
40  bool UnicharAndFonts::StdSortByUnicharId(const UnicharAndFonts &v1, const UnicharAndFonts &v2) {
41    return v1.unichar_id < v2.unichar_id;
42  }
43  bool Shape::Serialize(FILE *fp) const {
44    uint8_t sorted = unichars_sorted_;
45    return tesseract::Serialize(fp, &sorted) && tesseract::Serialize(fp, unichars_);
46  }
47  bool Shape::DeSerialize(TFile *fp) {
48    uint8_t sorted;
49    if (!fp->DeSerialize(&sorted)) {
50      return false;
51    }
52    unichars_sorted_ = sorted != 0;
53    return fp->DeSerialize(unichars_);
54  }
55  void Shape::AddToShape(int unichar_id, int font_id) {
56    for (auto &unichar : unichars_) {
57      if (unichar.unichar_id == unichar_id) {
58        std::vector<int> &font_list = unichar.font_ids;
59        for (int f : font_list) {
60          if (f == font_id) {
61            return; 
62          }
63        }
64        font_list.push_back(font_id);
65        return;
66      }
67    }
68    unichars_.emplace_back(unichar_id, font_id);
69    unichars_sorted_ = unichars_.size() <= 1;
70  }
71  void Shape::AddShape(const Shape &other) {
72    for (const auto &unichar : other.unichars_) {
73      for (unsigned f = 0; f < unichar.font_ids.size(); ++f) {
74        AddToShape(unichar.unichar_id, unichar.font_ids[f]);
75      }
76    }
77    unichars_sorted_ = unichars_.size() <= 1;
78  }
79  bool Shape::ContainsUnicharAndFont(int unichar_id, int font_id) const {
80    for (const auto &unichar : unichars_) {
81      if (unichar.unichar_id == unichar_id) {
82        auto &font_list = unichar.font_ids;
83        for (int f : font_list) {
84          if (f == font_id) {
85            return true;
86          }
87        }
88        return false;
89      }
90    }
91    return false;
92  }
93  bool Shape::ContainsUnichar(int unichar_id) const {
94    for (const auto &unichar : unichars_) {
95      if (unichar.unichar_id == unichar_id) {
96        return true;
97      }
98    }
99    return false;
100  }
101  bool Shape::ContainsFont(int font_id) const {
102    for (const auto &unichar : unichars_) {
103      auto &font_list = unichar.font_ids;
104      for (int f : font_list) {
105        if (f == font_id) {
106          return true;
107        }
108      }
109    }
110    return false;
111  }
112  bool Shape::ContainsFontProperties(const FontInfoTable &font_table, uint32_t properties) const {
113    for (const auto &unichar : unichars_) {
114      auto &font_list = unichar.font_ids;
115      for (int f : font_list) {
116        if (font_table.at(f).properties == properties) {
117          return true;
118        }
119      }
120    }
121    return false;
122  }
123  bool Shape::ContainsMultipleFontProperties(const FontInfoTable &font_table) const {
124    uint32_t properties = font_table.at(unichars_[0].font_ids[0]).properties;
125    for (const auto &unichar : unichars_) {
126      auto &font_list = unichar.font_ids;
127      for (int f : font_list) {
128        if (font_table.at(f).properties != properties) {
129          return true;
130        }
131      }
132    }
133    return false;
134  }
135  bool Shape::operator==(const Shape &other) const {
136    return IsSubsetOf(other) && other.IsSubsetOf(*this);
137  }
138  bool Shape::IsSubsetOf(const Shape &other) const {
139    for (const auto &unichar : unichars_) {
140      int unichar_id = unichar.unichar_id;
141      const std::vector<int> &font_list = unichar.font_ids;
142      for (int f : font_list) {
143        if (!other.ContainsUnicharAndFont(unichar_id, f)) {
144          return false;
145        }
146      }
147    }
148    return true;
149  }
150  bool Shape::IsEqualUnichars(Shape *other) {
151    if (unichars_.size() != other->unichars_.size()) {
152      return false;
153    }
154    if (!unichars_sorted_) {
155      SortUnichars();
156    }
157    if (!other->unichars_sorted_) {
158      other->SortUnichars();
159    }
160    for (unsigned c = 0; c < unichars_.size(); ++c) {
161      if (unichars_[c].unichar_id != other->unichars_[c].unichar_id) {
162        return false;
163      }
164    }
165    return true;
166  }
167  void Shape::SortUnichars() {
168    std::sort(unichars_.begin(), unichars_.end(), UnicharAndFonts::StdSortByUnicharId);
169    unichars_sorted_ = true;
170  }
171  ShapeTable::ShapeTable() : unicharset_(nullptr), num_fonts_(0) {}
172  ShapeTable::ShapeTable(const UNICHARSET &unicharset) : unicharset_(&unicharset), num_fonts_(0) {}
173  bool ShapeTable::Serialize(FILE *fp) const {
174    return tesseract::Serialize(fp, shape_table_);
175  }
176  bool ShapeTable::DeSerialize(TFile *fp) {
177    if (!fp->DeSerialize(shape_table_)) {
178      return false;
179    }
180    num_fonts_ = 0;
181    return true;
182  }
183  int ShapeTable::NumFonts() const {
184    if (num_fonts_ <= 0) {
185      for (auto shape_id : shape_table_) {
186        const Shape &shape = *shape_id;
187        for (int c = 0; c < shape.size(); ++c) {
188          for (int font_id : shape[c].font_ids) {
189            if (font_id >= num_fonts_) {
190              num_fonts_ = font_id + 1;
191            }
192          }
193        }
194      }
195    }
196    return num_fonts_;
197  }
198  void ShapeTable::ReMapClassIds(const std::vector<int> &unicharset_map) {
199    for (auto shape : shape_table_) {
200      for (int c = 0; c < shape->size(); ++c) {
201        shape->SetUnicharId(c, unicharset_map[(*shape)[c].unichar_id]);
202      }
203    }
204  }
205  std::string ShapeTable::DebugStr(unsigned shape_id) const {
206    if (shape_id >= shape_table_.size()) {
207      return "INVALID_UNICHAR_ID";
208    }
209    const Shape &shape = GetShape(shape_id);
210    std::string result;
211    result += "Shape" + std::to_string(shape_id);
212    if (shape.size() > 100) {
213      result += " Num unichars=" + std::to_string(shape.size());
214      return result;
215    }
216    for (int c = 0; c < shape.size(); ++c) {
217      result += " c_id=" + std::to_string(shape[c].unichar_id);
218      result += "=";
219      result += unicharset_->id_to_unichar(shape[c].unichar_id);
220      if (shape.size() < 10) {
221        result += ", " + std::to_string(shape[c].font_ids.size());
222        result += " fonts =";
223        int num_fonts = shape[c].font_ids.size();
224        if (num_fonts > 10) {
225          result += " " + std::to_string(shape[c].font_ids[0]);
226          result += " ... " + std::to_string(shape[c].font_ids[num_fonts - 1]);
227        } else {
228          for (int f = 0; f < num_fonts; ++f) {
229            result += " " + std::to_string(shape[c].font_ids[f]);
230          }
231        }
232      }
233    }
234    return result;
235  }
236  std::string ShapeTable::SummaryStr() const {
237    int max_unichars = 0;
238    int num_multi_shapes = 0;
239    int num_master_shapes = 0;
240    for (unsigned s = 0; s < shape_table_.size(); ++s) {
241      if (MasterDestinationIndex(s) != s) {
242        continue;
243      }
244      ++num_master_shapes;
245      int shape_size = GetShape(s).size();
<span onclick='openModal()' class='match'>246      if (shape_size > 1) {
247        ++num_multi_shapes;
248      }
249      if (shape_size > max_unichars) {
250        max_unichars = shape_size;
251      }
252    }
</span>253    std::string result;
254    result += "Number of shapes = " + std::to_string(num_master_shapes);
255    result += " max unichars = " + std::to_string(max_unichars);
256    result += " number with multiple unichars = " + std::to_string(num_multi_shapes);
257    return result;
258  }
259  unsigned ShapeTable::AddShape(int unichar_id, int font_id) {
260    auto index = shape_table_.size();
261    auto *shape = new Shape;
262    shape->AddToShape(unichar_id, font_id);
263    shape_table_.push_back(shape);
264    num_fonts_ = std::max(num_fonts_, font_id + 1);
265    return index;
266  }
267  unsigned ShapeTable::AddShape(const Shape &other) {
268    unsigned index;
269    for (index = 0; index < shape_table_.size() && !(other == *shape_table_[index]); ++index) {
270      continue;
271    }
272    if (index == shape_table_.size()) {
273      auto *shape = new Shape(other);
274      shape_table_.push_back(shape);
275    }
276    num_fonts_ = 0;
277    return index;
278  }
279  void ShapeTable::DeleteShape(unsigned shape_id) {
280    delete shape_table_[shape_id];
281    shape_table_.erase(shape_table_.begin() + shape_id);
282  }
283  void ShapeTable::AddToShape(unsigned shape_id, int unichar_id, int font_id) {
284    Shape &shape = *shape_table_[shape_id];
285    shape.AddToShape(unichar_id, font_id);
286    num_fonts_ = std::max(num_fonts_, font_id + 1);
287  }
288  void ShapeTable::AddShapeToShape(unsigned shape_id, const Shape &other) {
289    Shape &shape = *shape_table_[shape_id];
290    shape.AddShape(other);
291    num_fonts_ = 0;
292  }
293  int ShapeTable::FindShape(int unichar_id, int font_id) const {
294    for (unsigned s = 0; s < shape_table_.size(); ++s) {
295      const Shape &shape = GetShape(s);
296      for (int c = 0; c < shape.size(); ++c) {
297        if (shape[c].unichar_id == unichar_id) {
298          if (font_id < 0) {
299            return s; 
300          }
301          for (int f : shape[c].font_ids) {
302            if (f == font_id) {
303              return s;
304            }
305          }
306        }
307      }
308    }
309    return -1;
310  }
311  void ShapeTable::GetFirstUnicharAndFont(unsigned shape_id, int *unichar_id, int *font_id) const {
312    const UnicharAndFonts &unichar_and_fonts = (*shape_table_[shape_id])[0];
313    *unichar_id = unichar_and_fonts.unichar_id;
314    *font_id = unichar_and_fonts.font_ids[0];
315  }
316  int ShapeTable::BuildFromShape(const Shape &shape, const ShapeTable &master_shapes) {
317    BitVector shape_map(master_shapes.NumShapes());
318    for (int u_ind = 0; u_ind < shape.size(); ++u_ind) {
319      for (unsigned f_ind = 0; f_ind < shape[u_ind].font_ids.size(); ++f_ind) {
320        int c = shape[u_ind].unichar_id;
321        int f = shape[u_ind].font_ids[f_ind];
322        int master_id = master_shapes.FindShape(c, f);
323        if (master_id >= 0) {
324          shape_map.SetBit(master_id);
325        } else if (FindShape(c, f) < 0) {
326          AddShape(c, f);
327        }
328      }
329    }
330    int num_masters = 0;
331    for (unsigned s = 0; s < master_shapes.NumShapes(); ++s) {
332      if (shape_map[s]) {
333        AddShape(master_shapes.GetShape(s));
334        ++num_masters;
335      }
336    }
337    return num_masters;
338  }
339  bool ShapeTable::AlreadyMerged(unsigned shape_id1, unsigned shape_id2) const {
340    return MasterDestinationIndex(shape_id1) == MasterDestinationIndex(shape_id2);
341  }
342  bool ShapeTable::AnyMultipleUnichars() const {
343    auto num_shapes = NumShapes();
344    for (unsigned s1 = 0; s1 < num_shapes; ++s1) {
345      if (MasterDestinationIndex(s1) != s1) {
346        continue;
347      }
348      if (GetShape(s1).size() > 1) {
349        return true;
350      }
351    }
352    return false;
353  }
354  int ShapeTable::MaxNumUnichars() const {
355    int max_num_unichars = 0;
356    int num_shapes = NumShapes();
357    for (int s = 0; s < num_shapes; ++s) {
358      if (GetShape(s).size() > max_num_unichars) {
359        max_num_unichars = GetShape(s).size();
360      }
361    }
362    return max_num_unichars;
363  }
364  void ShapeTable::ForceFontMerges(unsigned start, unsigned end) {
365    for (unsigned s1 = start; s1 < end; ++s1) {
366      if (MasterDestinationIndex(s1) == s1 && GetShape(s1).size() == 1) {
367        int unichar_id = GetShape(s1)[0].unichar_id;
368        for (auto s2 = s1 + 1; s2 < end; ++s2) {
369          if (MasterDestinationIndex(s2) == s2 && GetShape(s2).size() == 1 &&
370              unichar_id == GetShape(s2)[0].unichar_id) {
371            MergeShapes(s1, s2);
372          }
373        }
374      }
375    }
376    ShapeTable compacted(*unicharset_);
377    compacted.AppendMasterShapes(*this, nullptr);
378    *this = compacted;
379  }
380  unsigned ShapeTable::MasterUnicharCount(unsigned shape_id) const {
381    int master_id = MasterDestinationIndex(shape_id);
382    return GetShape(master_id).size();
383  }
384  int ShapeTable::MasterFontCount(unsigned shape_id) const {
385    int master_id = MasterDestinationIndex(shape_id);
386    const Shape &shape = GetShape(master_id);
387    int font_count = 0;
388    for (int c = 0; c < shape.size(); ++c) {
389      font_count += shape[c].font_ids.size();
390    }
391    return font_count;
392  }
393  int ShapeTable::MergedUnicharCount(unsigned shape_id1, unsigned shape_id2) const {
394    int master_id1 = MasterDestinationIndex(shape_id1);
395    int master_id2 = MasterDestinationIndex(shape_id2);
396    Shape combined_shape(*shape_table_[master_id1]);
397    combined_shape.AddShape(*shape_table_[master_id2]);
398    return combined_shape.size();
399  }
400  void ShapeTable::MergeShapes(unsigned shape_id1, unsigned shape_id2) {
401    auto master_id1 = MasterDestinationIndex(shape_id1);
402    auto master_id2 = MasterDestinationIndex(shape_id2);
403    shape_table_[master_id2]->set_destination_index(master_id1);
404    shape_table_[master_id1]->AddShape(*shape_table_[master_id2]);
405  }
406  void ShapeTable::SwapShapes(unsigned shape_id1, unsigned shape_id2) {
407    Shape *tmp = shape_table_[shape_id1];
408    shape_table_[shape_id1] = shape_table_[shape_id2];
409    shape_table_[shape_id2] = tmp;
410  }
411  unsigned ShapeTable::MasterDestinationIndex(unsigned shape_id) const {
412    auto dest_id = shape_table_[shape_id]->destination_index();
413    if (static_cast<unsigned>(dest_id) == shape_id || dest_id < 0) {
414      return shape_id; 
415    }
416    auto master_id = shape_table_[dest_id]->destination_index();
417    if (master_id == dest_id || master_id < 0) {
418      return dest_id; 
419    }
420    master_id = MasterDestinationIndex(master_id);
421    return master_id;
422  }
423  bool ShapeTable::SubsetUnichar(unsigned shape_id1, unsigned shape_id2) const {
424    const Shape &shape1 = GetShape(shape_id1);
425    const Shape &shape2 = GetShape(shape_id2);
426    int c1, c2;
427    for (c1 = 0; c1 < shape1.size(); ++c1) {
428      int unichar_id1 = shape1[c1].unichar_id;
429      if (!shape2.ContainsUnichar(unichar_id1)) {
430        break;
431      }
432    }
433    for (c2 = 0; c2 < shape2.size(); ++c2) {
434      int unichar_id2 = shape2[c2].unichar_id;
435      if (!shape1.ContainsUnichar(unichar_id2)) {
436        break;
437      }
438    }
439    return c1 == shape1.size() || c2 == shape2.size();
440  }
441  bool ShapeTable::MergeSubsetUnichar(int merge_id1, int merge_id2, unsigned shape_id) const {
442    const Shape &merge1 = GetShape(merge_id1);
443    const Shape &merge2 = GetShape(merge_id2);
444    const Shape &shape = GetShape(shape_id);
445    int cm1, cm2, cs;
446    for (cs = 0; cs < shape.size(); ++cs) {
447      int unichar_id = shape[cs].unichar_id;
448      if (!merge1.ContainsUnichar(unichar_id) && !merge2.ContainsUnichar(unichar_id)) {
449        break; 
450      }
451    }
452    for (cm1 = 0; cm1 < merge1.size(); ++cm1) {
453      int unichar_id1 = merge1[cm1].unichar_id;
454      if (!shape.ContainsUnichar(unichar_id1)) {
455        break; 
456      }
457    }
458    for (cm2 = 0; cm2 < merge2.size(); ++cm2) {
459      int unichar_id2 = merge2[cm2].unichar_id;
460      if (!shape.ContainsUnichar(unichar_id2)) {
461        break; 
462      }
463    }
464    return cs == shape.size() || (cm1 == merge1.size() && cm2 == merge2.size());
465  }
466  bool ShapeTable::EqualUnichars(unsigned shape_id1, unsigned shape_id2) const {
467    const Shape &shape1 = GetShape(shape_id1);
468    const Shape &shape2 = GetShape(shape_id2);
469    for (int c1 = 0; c1 < shape1.size(); ++c1) {
470      int unichar_id1 = shape1[c1].unichar_id;
471      if (!shape2.ContainsUnichar(unichar_id1)) {
472        return false;
473      }
474    }
475    for (int c2 = 0; c2 < shape2.size(); ++c2) {
476      int unichar_id2 = shape2[c2].unichar_id;
477      if (!shape1.ContainsUnichar(unichar_id2)) {
478        return false;
479      }
480    }
481    return true;
482  }
483  bool ShapeTable::MergeEqualUnichars(int merge_id1, int merge_id2, unsigned shape_id) const {
484    const Shape &merge1 = GetShape(merge_id1);
485    const Shape &merge2 = GetShape(merge_id2);
486    const Shape &shape = GetShape(shape_id);
487    for (int cs = 0; cs < shape.size(); ++cs) {
488      int unichar_id = shape[cs].unichar_id;
489      if (!merge1.ContainsUnichar(unichar_id) && !merge2.ContainsUnichar(unichar_id)) {
490        return false; 
491      }
492    }
493    for (int cm1 = 0; cm1 < merge1.size(); ++cm1) {
494      int unichar_id1 = merge1[cm1].unichar_id;
495      if (!shape.ContainsUnichar(unichar_id1)) {
496        return false; 
497      }
498    }
499    for (int cm2 = 0; cm2 < merge2.size(); ++cm2) {
500      int unichar_id2 = merge2[cm2].unichar_id;
501      if (!shape.ContainsUnichar(unichar_id2)) {
502        return false; 
503      }
504    }
505    return true;
506  }
507  bool ShapeTable::CommonUnichars(unsigned shape_id1, unsigned shape_id2) const {
508    const Shape &shape1 = GetShape(shape_id1);
509    const Shape &shape2 = GetShape(shape_id2);
510    for (int c1 = 0; c1 < shape1.size(); ++c1) {
511      int unichar_id1 = shape1[c1].unichar_id;
512      if (shape2.ContainsUnichar(unichar_id1)) {
513        return true;
514      }
515    }
516    return false;
517  }
518  bool ShapeTable::CommonFont(unsigned shape_id1, unsigned shape_id2) const {
519    const Shape &shape1 = GetShape(shape_id1);
520    const Shape &shape2 = GetShape(shape_id2);
521    for (int c1 = 0; c1 < shape1.size(); ++c1) {
522      const std::vector<int> &font_list1 = shape1[c1].font_ids;
523      for (int f : font_list1) {
524        if (shape2.ContainsFont(f)) {
525          return true;
526        }
527      }
528    }
529    return false;
530  }
531  void ShapeTable::AppendMasterShapes(const ShapeTable &other, std::vector<int> *shape_map) {
532    if (shape_map != nullptr) {
533      shape_map->clear();
534      shape_map->resize(other.NumShapes(), -1);
535    }
536    for (unsigned s = 0; s < other.shape_table_.size(); ++s) {
537      if (other.shape_table_[s]->destination_index() < 0) {
538        int index = AddShape(*other.shape_table_[s]);
539        if (shape_map != nullptr) {
540          (*shape_map)[s] = index;
541        }
542      }
543    }
544  }
545  int ShapeTable::NumMasterShapes() const {
546    int num_shapes = 0;
547    for (auto s : shape_table_) {
548      if (s->destination_index() < 0) {
549        ++num_shapes;
550      }
551    }
552    return num_shapes;
553  }
554  void ShapeTable::AddShapeToResults(const ShapeRating &shape_rating, std::vector<int> *unichar_map,
555                                     std::vector<UnicharRating> *results) const {
556    if (shape_rating.joined) {
557      AddUnicharToResults(UNICHAR_JOINED, shape_rating.rating, unichar_map, results);
558    }
559    if (shape_rating.broken) {
560      AddUnicharToResults(UNICHAR_BROKEN, shape_rating.rating, unichar_map, results);
561    }
562    const Shape &shape = GetShape(shape_rating.shape_id);
563    for (int u = 0; u < shape.size(); ++u) {
564      int result_index =
565          AddUnicharToResults(shape[u].unichar_id, shape_rating.rating, unichar_map, results);
566      for (int font_id : shape[u].font_ids) {
567        (*results)[result_index].fonts.emplace_back(font_id,
568                                                    IntCastRounded(shape_rating.rating * INT16_MAX));
569      }
570    }
571  }
572  int ShapeTable::AddUnicharToResults(int unichar_id, float rating, std::vector<int> *unichar_map,
573                                      std::vector<UnicharRating> *results) const {
574    int result_index = unichar_map->at(unichar_id);
575    if (result_index < 0) {
576      UnicharRating result(unichar_id, rating);
577      result_index = results->size();
578      results->push_back(result);
579      (*unichar_map)[unichar_id] = result_index;
580    }
581    return result_index;
582  }
583  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-subprocess.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.cpp</div>
                </div>
                <div class="column column_space"><pre><code>187  	if (IsWrite(Mode)) {
188  		PSOut SOut = OpenForWriting();
189  		Stream(Send, SOut);
190  		SOut->Flush();
191  		CloseForWriting();
192  	}
193  	if (IsRead(Mode)) {
194  		PSIn SIn = OpenForReading();
195  		Stream(SIn, Receive);
196  		Receive->Flush();
197  		CloseForReading();
198  	}
199  }
</pre></code></div>
                <div class="column column_space"><pre><code>246      if (shape_size > 1) {
247        ++num_multi_shapes;
248      }
249      if (shape_size > max_unichars) {
250        max_unichars = shape_size;
251      }
252    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    