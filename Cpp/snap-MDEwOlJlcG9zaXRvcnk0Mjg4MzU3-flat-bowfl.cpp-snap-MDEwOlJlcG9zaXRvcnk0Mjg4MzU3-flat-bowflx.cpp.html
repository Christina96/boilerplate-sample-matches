
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr& FPath, TIntV& NewDIdV,
3   const bool& RecurseDirP, const int& MxDocs,
4   const bool& SaveDocP, const PNotify& Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify->OnStatus("Creating Bow from file-path " + FPath + " ...");
7    TFFile FFile(FPath, "", RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
11      Notify->OnStatus(TStr::Fmt("%d\r", Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn('/')){
18            TStr Str; DocNm.SplitOnCh(CatNm, '/', Str);
19          } else if (DocNm.IsChIn('\\')){
20            TStr Str; DocNm.SplitOnCh(CatNm, '\\', Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify->OnStatus(TStr::Fmt("%d", Docs));
29    Notify->OnStatus("Done.");
30    BowDocBs->AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
34   const PSwSet& SwSet, const PStemmer& Stemmer,
35   const int& MxNGramLen, const int& MnNGramFq,
36   const bool& SaveDocP, const PNotify& Notify){
37    PNGramBs NGramBs;
38    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
39      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
40       FPath, RecurseDirP, MxDocs,
41       MxNGramLen, MnNGramFq, SwSet, Stemmer);
42    }
43    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
44    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
45        RecurseDirP, MxDocs, SaveDocP, Notify);
46    return BowDocBs;
47  }
48  PBowDocBs TBowFl::LoadHtmlTxt(
49   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
50   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
51   const int& MxNGramLen, const int& MnNGramFq,
52   const bool& SaveDocP, const PNotify& Notify){
53    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
54    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
55    PNGramBs NGramBs;
56    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
57      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
58       FPath, RecurseDirP, MxDocs,
59       MxNGramLen, MnNGramFq, SwSet, Stemmer);
60    }
61    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
62    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
63        RecurseDirP, MxDocs, SaveDocP, Notify);
64    return BowDocBs;
65  }
66  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx& BowSimMtx){
67    PBowDocBs BowDocBs=TBowDocBs::New();
68    int Docs=BowSimMtx->GetDocs();
69    BowDocBs->DocSpVV.Gen(Docs, 0);
70    for (int MtxDIdN=0; MtxDIdN<Docs; MtxDIdN++){
71      int MtxDId=BowSimMtx->GetMtxDId(MtxDIdN);
72      int DId=BowDocBs->DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
73      IAssert(MtxDIdN==DId);
74      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
75      IAssert(DId==BowDocBs->DocSpVV.Len()-1);
76    }
77    BowDocBs->AssertOk();
78    return BowDocBs;
79  }
80  PBowDocBs TBowFl::LoadTabTxt(const TStr& FNm, const int& &bsol;*MxDocs*/){
81    PBowDocBs BowDocBs=TBowDocBs::New();
82    PDm Dm=TDm::LoadFile(FNm);
83    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
84      PTbVar Var=Dm->GetAttr(AttrN);
85      TStr VarNm=Var->GetNm();
86      PTbVarType VarType=Var->GetVarType();
87      EAssertRA(VarType->IsFlt(), "Attribute must be continuous", VarNm);
88      BowDocBs->WordStrToDescH.AddKey(VarNm);
89    }
90    for (int ExN=0; ExN<Dm->GetExs(); ExN++){
91      TStr DocNm=TInt::GetStr(ExN);
92      int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
93      BowDocBs->DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
94      BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
95      TIntV& DocCIdV=BowDocBs->DocCIdVV[DId];
96      DocCIdV.Gen(Dm->GetClasses(), 0);
97      for (int ClassN=0; ClassN<Dm->GetClasses(); ClassN++){
98        TStr ValStr=Dm->GetClassValStr(ExN, ClassN);
99        int CId=BowDocBs->CatNmToFqH.AddKey(ValStr);
100        BowDocBs->CatNmToFqH[CId]++; DocCIdV.Add(CId);
101      }
102      DocCIdV.Sort();
103      PBowSpV DocSpV=BowDocBs->DocSpVV[DId];
104      DocSpV->GenMx(Dm->GetAttrs());
105      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
106        TStr WordStr=Dm->GetAttr(AttrN)->GetNm();
107        int WId=BowDocBs->WordStrToDescH.GetKeyId(WordStr);
108        TTbVal Val=Dm->GetAttrVal(ExN, AttrN);
109        double Wgt=Val.GetFlt();
110        TBowWordDesc& WordDesc=BowDocBs->WordStrToDescH[WId];
111        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
112        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
113        DocSpV->AddWIdWgt(WId, Wgt);
114      }
115      DocSpV->Sort();
116    }
117    BowDocBs->AssertOk();
118    return BowDocBs;
119  }
120  PBowDocBs TBowFl::LoadTsactTxt(const TStr& FNm, const int& MxDocs){
121    PBowDocBs BowDocBs=TBowDocBs::New();
122    PSIn SIn=TFIn::New(FNm);
123    printf("Loading '%s' ...\n", FNm.CStr());
124    if (!SIn->Eof()){
125      int CurDId=-1;
126      TIntH CurDocWIdToFqH(100);
127      char Ch=SIn->GetCh();
128      while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
129        Ch=SIn->GetCh();}
130      while (!SIn->Eof()){
131        if (BowDocBs->DocSpVV.Len()%1000==0){
132          printf("%d transactions read\r", BowDocBs->DocSpVV.Len());}
133        IAssert(('0'<=Ch)&&(Ch<='9'));
134        int TsactN=Ch-'0'; Ch=SIn->GetCh();
135        while (('0'<=Ch)&&(Ch<='9')){
136          TsactN=TsactN*10+Ch-'0'; Ch=SIn->GetCh();}
137        while (!(('0'<=Ch)&&(Ch<='9'))){
138          IAssert((Ch==' ')||(Ch=='\t')); Ch=SIn->GetCh();}
139        IAssert(('0'<=Ch)&&(Ch<='9'));
140        int ItemN=Ch-'0'; Ch=SIn->GetCh();
141        while (('0'<=Ch)&&(Ch<='9')){
142          ItemN=ItemN*10+Ch-'0'; Ch=SIn->GetCh();}
143        while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
144          Ch=SIn->GetCh();}
145        TStr DocNm=TInt::GetStr(TsactN);
146        int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
147        TStr WordStr=TInt::GetStr(ItemN);
148        int WId=BowDocBs->WordStrToDescH.AddKey(WordStr);
149        BowDocBs->WordStrToDescH[WId].Fq++;
150        if (CurDId!=DId){
151          if (CurDId!=-1){
152            if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs-1)){break;}
153            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
154            int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
155            IAssert(NewDId==CurDId);
156            for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
157              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
158              int WordFq=CurDocWIdToFqH[DocWIdN];
159              NewSpV->AddWIdWgt(WId, WordFq);
160            }
161            NewSpV->Sort();
162          }
163          CurDId=DId; CurDocWIdToFqH.Clr(false);
164        }
165        CurDocWIdToFqH.AddDat(WId)++;
166      }
167      if (CurDId!=-1){
168        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
169        BowDocBs->DocSpVV.Add(NewSpV);
170        for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
171          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
172          int WordFq=CurDocWIdToFqH[DocWIdN];
173          NewSpV->AddWIdWgt(WId, WordFq);
174        }
175        NewSpV->Sort();
176      }
177      printf("%d transactions read\n", BowDocBs->DocSpVV.Len());
178    }
179    printf("... Done.\n");
180    BowDocBs->AssertOk();
181    return BowDocBs;
182  }
183  PBowDocBs TBowFl::LoadSparseTxt(
184   const TStr& DocDefFNm, const TStr& WordDefFNm,
185   const TStr& TrainDataFNm,
186   const int& MxDocs){
187    PBowDocBs BowDocBs=TBowDocBs::New();
188    if (!DocDefFNm.Empty()){
189      PSIn SIn=TFIn::New(DocDefFNm);
190      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
191      Lx.GetSym(syInt, syEof);
192      while (Lx.Sym==syInt){
193        int DId=Lx.Int;
194        Lx.GetSym(syColon);
195        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
196        Lx.GetSym(syEoln);
197        Lx.GetSym(syInt, syEof);
198        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
199        EAssertR(DId==NewDId, "Document-Ids don't match.");
200      }
201    }
202    if (!WordDefFNm.Empty()){
203      PSIn SIn=TFIn::New(WordDefFNm);
204      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
205      Lx.GetSym(syInt, syEof);
206      while (Lx.Sym==syInt){
207        int WId=Lx.Int;
208        Lx.GetSym(syColon);
209        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
210        Lx.GetSym(syEoln);
211        Lx.GetSym(syInt, syEof);
212        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
213        BowDocBs->WordStrToDescH[NewWId].Fq=1;
214        EAssertR(WId==NewWId, "Word-Ids don't match.");
215      }
216    }
217    if (!TrainDataFNm.Empty()){
218      PSIn SIn=TFIn::New(TrainDataFNm);
219      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
220      Lx.GetSym(syInt, syEof);
221      while (Lx.Sym==syInt){
222        if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs)){break;}
223        int DId=Lx.Int;
224        PBowSpV NewSpV=TBowSpV::New(DId);
225        int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
226        EAssertR(DId==NewDId, "Document-Ids don't match.");
227        Lx.GetSym(syInt, syEoln);
228        while (Lx.Sym==syInt){
229          int WId=Lx.Int;
230          Lx.GetSym(syColon, syInt, syEoln);
231          double WordFq=1;
232          if (Lx.Sym==syColon){
233            WordFq=Lx.GetFlt();
234            Lx.GetSym(syInt, syEoln);
235          }
236          NewSpV->AddWIdWgt(WId, WordFq);
237        }
238        NewSpV->Trunc();
239        Lx.GetSym(syInt, syEof);
240      }
241    }
242    BowDocBs->AssertOk();
243    return BowDocBs;
244  }
245  PBowDocBs TBowFl::LoadSvmLightTxt(
246   const TStr& DocDefFNm, const TStr& WordDefFNm,
247   const TStr& TrainDataFNm, const TStr& TestDataFNm,
<span onclick='openModal()' class='match'>248   const int& MxDocs){ 
249    PBowDocBs BowDocBs=TBowDocBs::New();
250    int MOneCId=BowDocBs->CatNmToFqH.AddKey("-1");
</span>251    int POneCId=BowDocBs->CatNmToFqH.AddKey("+1");
252    bool DocDefP=false;
253    if (!DocDefFNm.Empty()&&(TFile::Exists(DocDefFNm))){
254      PSIn SIn=TFIn::New(DocDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syInt, syEof);
257      while (Lx.Sym==syInt){
258        int DId=Lx.Int;
259        Lx.GetSym(syColon);
260        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syInt, syEof);
263        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
264        EAssertR(DId==NewDId, "Document-Ids don't match.");
265      }
266      DocDefP=true;
267    }
268    if (!WordDefFNm.Empty()&&(TFile::Exists(WordDefFNm))){
269      BowDocBs->WordStrToDescH.AddDat("Undef").Fq=0; 
270      PSIn SIn=TFIn::New(WordDefFNm);
271      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
272      Lx.GetSym(syQStr, syEof);
273      while (Lx.Sym==syQStr){
274        TStr WordStr=Lx.Str;
275        Lx.GetSym(syInt); int WId=Lx.Int;
276        Lx.GetSym(syInt); int WordFq=Lx.Int;
277        Lx.GetSym(syEoln);
278        Lx.GetSym(syQStr, syEof);
279        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
280        EAssertR(WId==NewWId, "Word-Ids don't match.");
281        BowDocBs->WordStrToDescH[WId].Fq=WordFq;
282      }
283    }
284    int MxWId=-1; TIntIntH WIdToFqH;
285    if (!TrainDataFNm.Empty()){
286      PSIn SIn=TFIn::New(TrainDataFNm);
287      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
288      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
289      while (Lx.Sym==syInt){
290        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
291        int DId;
292        if (DocDefP){
293          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
294        } else {
295          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
296        }
297        BowDocBs->TrainDIdV.Add(DId);
298        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
299        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
300        BowDocBs->DocCIdVV.Last().Gen(1, 0);
301        BowDocBs->DocCIdVV.Last().Add(CId);
302        PBowSpV SpV=TBowSpV::New(DId);
303        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
304        Lx.GetSym(syInt, syEoln);
305        while (Lx.Sym==syInt){
306          int WId=Lx.Int;
307          Lx.GetSym(syColon);
308          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
309          Lx.GetSym(syInt, syEoln);
310          SpV->AddWIdWgt(WId, WordFq);
311          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
312          WIdToFqH.AddDat(WId)++;
313        }
314        if (!Lx.CmtStr.Empty()){
315          TStr CmtStr=Lx.CmtStr;
316          static TStr DocNmPrefixStr="docDesc=";
317          if (CmtStr.IsPrefix(DocNmPrefixStr)){
318            TStr NewDocNm=
319             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
320            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
321            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
322            IAssert(DId==NewDId);
323          }
324        }
325        SpV->Trunc();
326        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
327      }
328    }
329    if (!TestDataFNm.Empty()){
330      PSIn SIn=TFIn::New(TestDataFNm);
331      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
332      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
333      while (Lx.Sym==syInt){
334        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
335        int DId;
336        if (DocDefP){
337          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
338        } else {
339          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
340        }
341        BowDocBs->TestDIdV.Add(DId);
342        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
343        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
344        BowDocBs->DocCIdVV.Last().Gen(1, 0);
345        BowDocBs->DocCIdVV.Last().Add(CId);
346        PBowSpV SpV=TBowSpV::New(DId);
347        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
348        Lx.GetSym(syInt, syEoln);
349        while (Lx.Sym==syInt){
350          int WId=Lx.Int;
351          Lx.GetSym(syColon);
352          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
353          Lx.GetSym(syInt, syEoln);
354          SpV->AddWIdWgt(WId, WordFq);
355          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
356          WIdToFqH.AddDat(WId)++;
357        }
358        if (!Lx.CmtStr.Empty()){
359          TStr CmtStr=Lx.CmtStr;
360          static TStr DocNmPrefixStr="docDesc=";
361          if (CmtStr.IsPrefix(DocNmPrefixStr)){
362            TStr NewDocNm=
363             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
364            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
365            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
366            IAssert(DId==NewDId);
367          }
368        }
369        SpV->Trunc();
370        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
371      }
372    }
373    for (int WId=0; WId<=MxWId; WId++){
374      if (!BowDocBs->IsWId(WId)){
375        TStr WordStr=TInt::GetStr(WId, "W%d");
376        int _WId=BowDocBs->AddWordStr(WordStr);
377        IAssert(WId==_WId);
378        TInt Fq;
379        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
380          BowDocBs->PutWordFq(WId, Fq);
381        }
382      }
383    }
384    BowDocBs->AssertOk();
385    return BowDocBs;
386  }
387  PBowDocBs TBowFl::LoadCpdTxt(
388   const PSIn& CpdSIn, const int& MxDocs,
389   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
390   const int& MxNGramLen, const int& MnNGramFq){
391    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
392    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
393    PNGramBs NGramBs;
394    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
395      NGramBs=TNGramBs::GetNGramBsFromCpd(
396       CpdSIn, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
397    }
398    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
399    printf("Load Bag-Of-Words from Compact-Documents ...\n");
400    TIntH DocWIdToFqH(100); CpdSIn->Reset();
401    PSIn CpDocSIn=TCpDoc::FFirstCpd(CpdSIn); PCpDoc CpDoc; int Docs=0;
402    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
403      Docs++; if (Docs%100==0){printf("  %d\r", Docs);}
404      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
405      TStr DocNm=CpDoc->GetDocNm();
406      TStrV CatNmV;
407      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
408        CatNmV.Add(CpDoc->GetCatNm(CatN));
409      }
410      TStr DocStr=CpDoc->GetTxtStr();
411      TStr DateStr=CpDoc->GetDateStr();
412      int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, false);
413      BowDocBs->PutDateStr(DId, DateStr);
414    }
415    printf("  %d\nDone.\n", Docs);
416    BowDocBs->AssertOk();
417    return BowDocBs;
418  }
419  PBowDocBs TBowFl::LoadCpdTxt(
420   const TStr& CpdFNm, const int& MxDocs,
421   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
422   const int& MxNGramLen, const int& MnNGramFq){
423    PSIn CpdSIn=TFIn::New(CpdFNm);
424    return TBowFl::LoadCpdTxt(
425     CpdSIn, MxDocs, SwSetTypeNm, StemmerTypeNm, MxNGramLen, MnNGramFq);
426  }
427  void TBowFl::SaveCpdToLnDocTxt(const TStr& InCpdFNm, const TStr& OutLnDocFNm){
428    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
429    PSIn CpDocSIn=TCpDoc::FFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
430    printf("Saving '%s' to '%s' ...\n", InCpdFNm.CStr(), OutLnDocFNm.CStr());
431    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
432      Docs++; if (Docs%100==0){printf("%d Docs\r", Docs);}
433      TStr DocNm=CpDoc->GetDocNm();
434      DocNm=TStr::GetFNmStr(DocNm);
435      DocNm.ChangeChAll(' ', '_');
436      TStrV CatNmV;
437      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
438        CatNmV.Add(CpDoc->GetCatNm(CatN));}
439      TChA DocChA=CpDoc->GetTxtStr();
440      DocChA.ChangeCh('\r', ' ');
441      DocChA.ChangeCh('\n', ' ');
442      fprintf(fOut, "%s", DocNm.CStr());
443      for (int CatN=0; CatN<CatNmV.Len(); CatN++){
444        fprintf(fOut, " !%s", CatNmV[CatN].CStr());}
445      fprintf(fOut, " %s\n", DocChA.CStr());
446    }
447    printf("%d Docs\nDone.\n", Docs);
448  }
449  PBowDocBs TBowFl::LoadTBsTxt(
450   const TStr& TBsFNm, const int& MxDocs,
451   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
452   const int& MxNGramLen, const int& MnNGramFq){
453    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
454    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
455    PNGramBs NGramBs;
456    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
457      NGramBs=TNGramBs::GetNGramBsFromTBs(
458       TBsFNm, MxDocs,
459       MxNGramLen, MnNGramFq, SwSet, Stemmer);
460    }
461    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
462    TStr TxtBsNm=TBsFNm.GetFBase();
463    TStr TxtBsFPath=TBsFNm.GetFPath();
464    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
465    TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
466    while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
467      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
468      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
469      TStr DocNm; TStr DocStr;
470      TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
471      BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, false);
472    }
473    BowDocBs->AssertOk();
474    return BowDocBs;
475  }
476  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr& LnDocFNm,
477   TIntV& NewDIdV, const bool& NamedP, const int& MxDocs, const bool& SaveDocP) {
478    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
479    while (!FIn.Eof()){
480      Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
481      printf("%d\r", Docs);
482      TChA DocNm;
483      Ch=FIn.GetCh();
484      if (NamedP){
485        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
486          DocNm+=Ch; Ch=FIn.GetCh();}
487        DocNm.Trunc();
488        if (DocNm.Empty()){Docs--; continue;}
489      } else {
490          DocNm = TInt::GetStr(Docs);
491      }
492      TStrV CatNmV;
493      forever {
494        while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
495        if (Ch=='!'){
496          if (!FIn.Eof()){Ch=FIn.GetCh();}
497          TChA CatNm;
498          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
499            CatNm+=Ch; Ch=FIn.GetCh();}
500          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
501        } else {
502          break;
503        }
504      }
505      TChA DocChA;
506      while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
507        DocChA+=Ch; Ch=FIn.GetCh();}
508      if (DocNm.Empty()&&DocChA.Empty()){
509        continue;}
510      NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
511    }
512    BowDocBs->AssertOk();
513    printf("\n");
514  }
515  PBowDocBs TBowFl::LoadLnDocTxt(
516   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
517   const PSwSet& SwSet, const PStemmer& Stemmer,
518   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
519    PNGramBs NGramBs;
520    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
521      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
522       LnDocFNm, NamedP, MxDocs,
523       MxNGramLen, MnNGramFq, SwSet, Stemmer);
524    }
525    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
526    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
527    return BowDocBs;
528  }
529  PBowDocBs TBowFl::LoadLnDocTxt(
530   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
531   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
532   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
533    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
534    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
535    PNGramBs NGramBs;
536    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
537      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
538       LnDocFNm, NamedP, MxDocs,
539       MxNGramLen, MnNGramFq, SwSet, Stemmer);
540    }
541    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
542    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
543    return BowDocBs;
544  }
545  void TBowFl::SaveLnDocTxt(const PBowDocBs& BowDocBs, const TStr& FNm, const bool& UseDocStrP){
546    TFOut SOut(FNm);
547    int Docs=BowDocBs->GetDocs();
548    for (int DId=0; DId<Docs; DId++){
549      printf("%d/%d\r", DId+1, Docs);
550      TStr DocNm=TStr::GetFNmStr(BowDocBs->GetDocNm(DId));
551      SOut.PutStr(DocNm);
552      for (int CIdN=0; CIdN<BowDocBs->GetDocCIds(DId); CIdN++){
553        int CId=BowDocBs->GetDocCId(DId, CIdN);
554        TStr CatNm=TStr::GetFNmStr(BowDocBs->GetCatNm(CId));
555        SOut.PutCh(' '); SOut.PutCh('!'); SOut.PutStr(CatNm);
556      }
557      if (UseDocStrP){
558        TStr DocStr=BowDocBs->GetDocStr(DId);
559        SOut.PutCh(' '); SOut.PutStr(DocStr);
560      } else {
561          int DocWIds=BowDocBs->GetDocWIds(DId);
562          int WId; double WordFq;
563          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
564            BowDocBs->GetDocWIdFq(DId, DocWIdN, WId, WordFq);
565            TStr WordStr=BowDocBs->GetWordStr(WId);
566            for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
567              SOut.PutCh(' '); SOut.PutStr(WordStr);
568            }
569          }
570      }
571      SOut.PutLn();
572    }
573    printf("\n");
574  }
575  PBowDocBs TBowFl::LoadReuters21578Txt(
576   const TStr& FPath, const int& MxDocs,
577   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
578   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
579    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
580    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
581    PNGramBs NGramBs;
582    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
583      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
584       FPath, MxDocs,
585       MxNGramLen, MnNGramFq, SwSet, Stemmer);
586    }
587    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
588    TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
589    while (FFile.Next(FNm)){
590      printf("Processing file '%s'\n", FNm.CStr());
591      TIntH DocWIdToFqH(100);
592      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
593      for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
594        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
595        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
596        PXmlDoc Doc=LDocV[LDocN];
597        PXmlTok DocTok=Doc->GetTok();
598        TStr DocNm=DocTok->GetArgVal("NEWID");
599        TStrV CatNmV;
600        TXmlTokV TopicsTokV; Doc->GetTagTokV("REUTERS|TOPICS|D", TopicsTokV);
601        for (int TopicsTokN=0; TopicsTokN<TopicsTokV.Len(); TopicsTokN++){
602          TStr CatNm=TopicsTokV[TopicsTokN]->GetTokStr(false);
603          CatNmV.Add(CatNm);
604        }
605        PXmlTok DocStrTok=Doc->GetTagTok("REUTERS|TEXT");
606        TStr DocStr=DocStrTok->GetTokStr(false);
607        int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
608        if ((DocTok->GetArgVal("LEWISSPLIT")=="TRAIN")&&(DocTok->GetArgVal("TOPICS")=="YES")){
609          BowDocBs->AddTrainDId(DId);}
610        if ((DocTok->GetArgVal("LEWISSPLIT")=="TEST")&&(DocTok->GetArgVal("TOPICS")=="YES")){
611          BowDocBs->AddTestDId(DId);}
612      }
613      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
614    }
615    BowDocBs->AssertOk();
616    return BowDocBs;
617  }
618  PBowDocBs TBowFl::LoadCiaWFBTxt(
619   const TStr& FPath, const int& MxDocs,
620   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
621   const int& MxNGramLen, const int& MnNGramFq){
622    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
623    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
624    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
625    PNGramBs NGramBs;
626    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
627      TStrV HtmlStrV;
628      for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
629        PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
630        HtmlStrV.Add(CiaWFBCountry->GetDescStr());
631      }
632      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
633       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
634    }
635    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
636    for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
637      if (CountryN==MxDocs){break;}
638      PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
639      TStr CountryNm=CiaWFBCountry->GetCountryNm();
640      TStr DescStr=CiaWFBCountry->GetDescStr();
641      TStr CatNm=CiaWFBCountry->GetFldVal("Map references").GetTrunc();
642      TStrV CatNmV; CatNmV.Add(CatNm);
643      BowDocBs->AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
644    }
645    BowDocBs->AssertOk();
646    return BowDocBs;
647  }
648  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs& BowDocBs,
649   const PBowDocWgtBs& BowDocWgtBs, const TStr& FNm,
650   const TStr& CatFNm, const TIntV& _DIdV) {
651    TIntV DIdV;
652    if (_DIdV.Empty()){
653      BowDocBs->GetAllDIdV(DIdV);
654    } else {
655      DIdV=_DIdV;
656    }
657    TFOut WdMapSOut(TStr::PutFExt(FNm, ".row-to-word-map.dat"));
658    for (int WId = 0; WId < BowDocWgtBs->GetWords(); WId++) {
659      TStr WdStr = BowDocBs->GetWordStr(WId);
660      WdMapSOut.PutStrLn(TStr::Fmt("%d %s", WId+1,  WdStr.CStr()));
661    }
662    WdMapSOut.Flush();
663    TFOut DocMapSOut(TStr::PutFExt(FNm, ".col-to-docName-map.dat"));
664    for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
665      const int DId = DIdV[DocN];
666      TStr DocNm = BowDocBs->GetDocNm(DId);
667      DocMapSOut.PutStrLn(TStr::Fmt("%d %d %s", DocN, DId,  DocNm.CStr()));
668    }
669    DocMapSOut.Flush();
670    TFOut SOut(FNm);
671    for (int DocN = 0; DocN < DIdV.Len(); DocN++){
672      const int DId = DIdV[DocN];
673      PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
674      const int DocWIds = DocSpV->GetWIds();
675      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
676        const int WId = DocSpV->GetWId(DocWIdN);
677        const double WordWgt = DocSpV->GetWgt(DocWIdN);
678        SOut.PutStrLn(TStr::Fmt("%d %d %.16f", WId+1, DocN+1, WordWgt));
679      }
680    }
681    SOut.Flush();
682    if (!CatFNm.Empty()) {
683      TFOut CatSOut(CatFNm);
684      for (int DocN = 0; DocN < DIdV.Len(); DocN++){
685        const int DId = DIdV[DocN];
686        const int DocCIds = BowDocBs->GetDocCIds(DId);
687        for (int DocCIdN=0; DocCIdN<DocCIds; DocCIdN++){
688          const int CId = BowDocBs->GetDocCId(DId, DocCIdN);
689          const double CatWgt = 1.0;
690          CatSOut.PutStrLn(TStr::Fmt("%d %d %.16f", CId+1, DocN+1, CatWgt));
691        }
692      }
693      CatSOut.Flush();
694    }
695  }
696  PBowDocBs TBowFl::LoadTabTxt(
697   const TStr& FNm, const TStr& SsFmtNm, const int& Recs,
698   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
699   const int& MxNGramLen, const int& MnNGramFq,
700   const int& IdFldN, const TStr& IdFldNm,
701   const TIntV& CatFldNV, const TStrV& CatFldNmV,
702   const TIntV& TxtFldNV, const TStrV& TxtFldNmV){
703    TSsFmt SsFmt=TSs::GetSsFmtFromStr(SsFmtNm);
704    PSs Ss=TSs::LoadTxt(SsFmt, FNm);
705    int FinalIdFldN=IdFldN;
706    if ((FinalIdFldN==-1)&&(!IdFldNm.Empty())){
707      FinalIdFldN=Ss->GetFldX(IdFldNm);
708    }
709    TIntV FinalCatFldNV=CatFldNV;
710    for (int CatN=0; CatN<CatFldNmV.Len(); CatN++){
711      int CatFldN=Ss->GetFldX(CatFldNmV[CatN]);
712      FinalCatFldNV.Add(CatFldN);
713    }
714    FinalCatFldNV.Sort();
715    TIntV FinalTxtFldNV=TxtFldNV;
716    for (int TxtN=0; TxtN<TxtFldNmV.Len(); TxtN++){
717      int TxtFldN=Ss->GetFldX(TxtFldNmV[TxtN]);
718      FinalTxtFldNV.Add(TxtFldN);
719    }
720    FinalTxtFldNV.Sort();
721    TStrV DocNmV;
722    TVec<TStrV> CatNmVV;
723    TStrV DocStrV;
724    for (int Y=1; Y<Ss->GetYLen(); Y++){
725      TStr DocNm;
726      if (FinalIdFldN==-1){
727        DocNm=TInt::GetStr(Y);
728      } else {
729        DocNm=Ss->GetVal(FinalIdFldN, Y);
730      }
731      DocNmV.Add(DocNm);
732      TStrV CatNmV;
733      for (int CatN=0; CatN<FinalCatFldNV.Len(); CatN++){
734        int CatFldN=FinalCatFldNV[CatN];
735        TStr CatNm=Ss->GetVal(CatFldN, Y);
736        if (!CatNm.Empty()){
737          CatNmV.Add(CatNm);
738        }
739      }
740      CatNmVV.Add(CatNmV);
741      TChA DocChA;
742      for (int TxtN=0; TxtN<FinalTxtFldNV.Len(); TxtN++){
743        int TxtFldN=FinalTxtFldNV[TxtN];
744        TStr TxtStr=Ss->GetVal(TxtFldN, Y);
745        if (!DocChA.Empty()){DocChA+=" <br> ";}
746        if (!TxtStr.Empty()){DocChA+=TxtStr;}
747      }
748      DocStrV.Add(DocChA);
749    }
750    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
751    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
752    PNGramBs NGramBs;
753    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
754      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
755       DocStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
756    }
757    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
758    for (int DocN=0; DocN<DocNmV.Len(); DocN++){
759      BowDocBs->AddHtmlDoc(DocNmV[DocN], CatNmVV[DocN], DocStrV[DocN], true);
760    }
761    BowDocBs->AssertOk();
762    return BowDocBs;
763  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowflx.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr& FPath, TIntV& NewDIdV,
3   const bool& RecurseDirP, const int& MxDocs,
4   const bool& SaveDocP, const PNotify& Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify->OnStatus("Creating Bow from file-path " + FPath + " ...");
7    TFFile FFile(FPath, "", RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
11      Notify->OnStatus(TStr::Fmt("%d\r", Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn('/')){
18            TStr Str; DocNm.SplitOnCh(CatNm, '/', Str);
19          } else if (DocNm.IsChIn('\\')){
20            TStr Str; DocNm.SplitOnCh(CatNm, '\\', Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify->OnStatus(TStr::Fmt("%d", Docs));
29    Notify->OnStatus("Done.");
30    BowDocBs->AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
34   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
35   const int& MxNGramLen, const int& MnNGramFq,
36   const bool& SaveDocP, const PNotify& Notify){
37    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
38    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
39    PNGramBs NGramBs;
40    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
41      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
42       FPath, RecurseDirP, MxDocs,
43       MxNGramLen, MnNGramFq, SwSet, Stemmer, Notify);
44    }
45    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
46    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
47        RecurseDirP, MxDocs, SaveDocP, Notify);
48    return BowDocBs;
49  }
50  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx& BowSimMtx){
51    PBowDocBs BowDocBs=TBowDocBs::New();
52    int Docs=BowSimMtx->GetDocs();
53    BowDocBs->DocSpVV.Gen(Docs, 0);
54    for (int MtxDIdN=0; MtxDIdN<Docs; MtxDIdN++){
55      int MtxDId=BowSimMtx->GetMtxDId(MtxDIdN);
56      int DId=BowDocBs->DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
57      IAssert(MtxDIdN==DId);
58      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
59      IAssert(DId==BowDocBs->DocSpVV.Len()-1);
60    }
61    BowDocBs->AssertOk();
62    return BowDocBs;
63  }
64  PBowDocBs TBowFl::LoadTabTxt(const TStr& FNm, const int& &bsol;*MxDocs*/){
65    PBowDocBs BowDocBs=TBowDocBs::New();
66    PDm Dm=TDm::LoadFile(FNm);
67    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
68      PTbVar Var=Dm->GetAttr(AttrN);
69      TStr VarNm=Var->GetNm();
70      PTbVarType VarType=Var->GetVarType();
71      EAssertRA(VarType->IsFlt(), "Attribute must be continuous", VarNm);
72      BowDocBs->WordStrToDescH.AddKey(VarNm);
73    }
74    for (int ExN=0; ExN<Dm->GetExs(); ExN++){
75      TStr DocNm=TInt::GetStr(ExN);
76      int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
77      BowDocBs->DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
78      BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
79      TIntV& DocCIdV=BowDocBs->DocCIdVV[DId];
80      DocCIdV.Gen(Dm->GetClasses(), 0);
81      for (int ClassN=0; ClassN<Dm->GetClasses(); ClassN++){
82        TStr ValStr=Dm->GetClassValStr(ExN, ClassN);
83        int CId=BowDocBs->CatNmToFqH.AddKey(ValStr);
84        BowDocBs->CatNmToFqH[CId]++; DocCIdV.Add(CId);
85      }
86      DocCIdV.Sort();
87      PBowSpV DocSpV=BowDocBs->DocSpVV[DId];
88      DocSpV->GenMx(Dm->GetAttrs());
89      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
90        TStr WordStr=Dm->GetAttr(AttrN)->GetNm();
91        int WId=BowDocBs->WordStrToDescH.GetKeyId(WordStr);
92        TTbVal Val=Dm->GetAttrVal(ExN, AttrN);
93        double Wgt=Val.GetFlt();
94        TBowWordDesc& WordDesc=BowDocBs->WordStrToDescH[WId];
95        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
96        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
97        DocSpV->AddWIdWgt(WId, Wgt);
98      }
99      DocSpV->Sort();
100    }
101    BowDocBs->AssertOk();
102    return BowDocBs;
103  }
104  PBowDocBs TBowFl::LoadTsactTxt(const TStr& FNm, const int& MxDocs){
105    PBowDocBs BowDocBs=TBowDocBs::New();
106    PSIn SIn=TFIn::New(FNm);
107    printf("Loading %s ...\n", FNm.CStr());
108    if (!SIn->Eof()){
109      int CurDId=-1;
110      TIntH CurDocWIdToFqH(100);
111      char Ch=SIn->GetCh();
112      while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
113        Ch=SIn->GetCh();}
114      while (!SIn->Eof()){
115        if (BowDocBs->DocSpVV.Len()%1000==0){
116          printf("%d transactions read\r", BowDocBs->DocSpVV.Len());}
117        IAssert(('0'<=Ch)&&(Ch<='9'));
118        int TsactN=Ch-'0'; Ch=SIn->GetCh();
119        while (('0'<=Ch)&&(Ch<='9')){
120          TsactN=TsactN*10+Ch-'0'; Ch=SIn->GetCh();}
121        while (!(('0'<=Ch)&&(Ch<='9'))){
122          IAssert((Ch==' ')||(Ch=='\t')); Ch=SIn->GetCh();}
123        IAssert(('0'<=Ch)&&(Ch<='9'));
124        int ItemN=Ch-'0'; Ch=SIn->GetCh();
125        while (('0'<=Ch)&&(Ch<='9')){
126          ItemN=ItemN*10+Ch-'0'; Ch=SIn->GetCh();}
127        while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
128          Ch=SIn->GetCh();}
129        TStr DocNm=TInt::GetStr(TsactN);
130        int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
131        TStr WordStr=TInt::GetStr(ItemN);
132        int WId=BowDocBs->WordStrToDescH.AddKey(WordStr);
133        BowDocBs->WordStrToDescH[WId].Fq++;
134        if (CurDId!=DId){
135          if (CurDId!=-1){
136            if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs-1)){break;}
137            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
138            int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
139            IAssert(NewDId==CurDId);
140            for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
141              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
142              int WordFq=CurDocWIdToFqH[DocWIdN];
143              NewSpV->AddWIdWgt(WId, WordFq);
144            }
145            NewSpV->Sort();
146          }
147          CurDId=DId; CurDocWIdToFqH.Clr(false);
148        }
149        CurDocWIdToFqH.AddDat(WId)++;
150      }
151      if (CurDId!=-1){
152        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
153        BowDocBs->DocSpVV.Add(NewSpV);
154        for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
155          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
156          int WordFq=CurDocWIdToFqH[DocWIdN];
157          NewSpV->AddWIdWgt(WId, WordFq);
158        }
159        NewSpV->Sort();
160      }
161      printf("%d transactions read\n", BowDocBs->DocSpVV.Len());
162    }
163    printf("... Done.\n");
164    BowDocBs->AssertOk();
165    return BowDocBs;
166  }
167  PBowDocBs TBowFl::LoadSparseTxt(
168   const TStr& DocDefFNm, const TStr& WordDefFNm,
169   const TStr& TrainDataFNm,
<span onclick='openModal()' class='match'>170   const int& MxDocs){
171    PBowDocBs BowDocBs=TBowDocBs::New();
172    if (!DocDefFNm.Empty()){
</span>173      PSIn SIn=TFIn::New(DocDefFNm);
174      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
175      Lx.GetSym(syInt, syEof);
176      while (Lx.Sym==syInt){
177        int DId=Lx.Int;
178        Lx.GetSym(syColon);
179        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
180        Lx.GetSym(syEoln);
181        Lx.GetSym(syInt, syEof);
182        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
183        EAssertR(DId==NewDId, "Document-Ids don't match.");
184      }
185    }
186    if (!WordDefFNm.Empty()){
187      PSIn SIn=TFIn::New(WordDefFNm);
188      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
189      Lx.GetSym(syInt, syEof);
190      while (Lx.Sym==syInt){
191        int WId=Lx.Int;
192        Lx.GetSym(syColon);
193        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
194        Lx.GetSym(syEoln);
195        Lx.GetSym(syInt, syEof);
196        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
197        BowDocBs->WordStrToDescH[NewWId].Fq=1;
198        EAssertR(WId==NewWId, "Word-Ids don't match.");
199      }
200    }
201    if (!TrainDataFNm.Empty()){
202      PSIn SIn=TFIn::New(TrainDataFNm);
203      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
204      Lx.GetSym(syInt, syEof);
205      while (Lx.Sym==syInt){
206        if (BowDocBs->GetDocs()>=MxDocs){break;}
207        int DId=Lx.Int;
208        PBowSpV NewSpV=TBowSpV::New(DId);
209        int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
210        EAssertR(DId==NewDId, "Document-Ids don't match.");
211        Lx.GetSym(syInt, syEoln);
212        while (Lx.Sym==syInt){
213          int WId=Lx.Int;
214          Lx.GetSym(syColon, syInt, syEoln);
215          double WordFq=1;
216          if (Lx.Sym==syColon){
217            WordFq=Lx.GetFlt();
218            Lx.GetSym(syInt, syEoln);
219          }
220          NewSpV->AddWIdWgt(WId, WordFq);
221        }
222        NewSpV->Trunc();
223        Lx.GetSym(syInt, syEof);
224      }
225    }
226    BowDocBs->AssertOk();
227    return BowDocBs;
228  }
229  PBowDocBs TBowFl::LoadSvmLightTxt(
230   const TStr& DocDefFNm, const TStr& WordDefFNm,
231   const TStr& TrainDataFNm, const TStr& TestDataFNm,
232   const int& MxDocs){
233    PBowDocBs BowDocBs=TBowDocBs::New();
234    int MOneCId=BowDocBs->CatNmToFqH.AddKey("-1");
235    int POneCId=BowDocBs->CatNmToFqH.AddKey("+1");
236    bool DocDefP=false;
237    if (!DocDefFNm.Empty()&&(TFile::Exists(DocDefFNm))){
238      PSIn SIn=TFIn::New(DocDefFNm);
239      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
240      Lx.GetSym(syInt, syEof);
241      while (Lx.Sym==syInt){
242        int DId=Lx.Int;
243        Lx.GetSym(syColon);
244        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
245        Lx.GetSym(syEoln);
246        Lx.GetSym(syInt, syEof);
247        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
248        EAssertR(DId==NewDId, "Document-Ids don't match.");
249      }
250      DocDefP=true;
251    }
252    if (!WordDefFNm.Empty()&&(TFile::Exists(WordDefFNm))){
253      BowDocBs->WordStrToDescH.AddDat("Undef").Fq=0; 
254      PSIn SIn=TFIn::New(WordDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syQStr, syEof);
257      while (Lx.Sym==syQStr){
258        TStr WordStr=Lx.Str;
259        Lx.GetSym(syInt); int WId=Lx.Int;
260        Lx.GetSym(syInt); int WordFq=Lx.Int;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syQStr, syEof);
263        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
264        EAssertR(WId==NewWId, "Word-Ids don't match.");
265        BowDocBs->WordStrToDescH[WId].Fq=WordFq;
266      }
267    }
268    int MxWId=-1; TIntIntH WIdToFqH;
269    if (!TrainDataFNm.Empty()){
270      PSIn SIn=TFIn::New(TrainDataFNm);
271      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
272      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
273      while (Lx.Sym==syInt){
274        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
275        int DId;
276        if (DocDefP){
277          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
278        } else {
279          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
280        }
281        BowDocBs->TrainDIdV.Add(DId);
282        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
283        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
284        BowDocBs->DocCIdVV.Last().Gen(1, 0);
285        BowDocBs->DocCIdVV.Last().Add(CId);
286        PBowSpV SpV=TBowSpV::New(DId);
287        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
288        Lx.GetSym(syInt, syEoln);
289        while (Lx.Sym==syInt){
290          int WId=Lx.Int;
291          Lx.GetSym(syColon);
292          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
293          Lx.GetSym(syInt, syEoln);
294          SpV->AddWIdWgt(WId, WordFq);
295          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
296          WIdToFqH.AddDat(WId)++;
297        }
298        if (!Lx.CmtStr.Empty()){
299          TStr CmtStr=Lx.CmtStr;
300          static TStr DocNmPrefixStr="docDesc=";
301          if (CmtStr.IsPrefix(DocNmPrefixStr)){
302            TStr NewDocNm=
303             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
304            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
305            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
306            IAssert(DId==NewDId);
307          }
308        }
309        SpV->Trunc();
310        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
311      }
312    }
313    if (!TestDataFNm.Empty()){
314      PSIn SIn=TFIn::New(TestDataFNm);
315      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
316      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
317      while (Lx.Sym==syInt){
318        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
319        int DId;
320        if (DocDefP){
321          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
322        } else {
323          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
324        }
325        BowDocBs->TestDIdV.Add(DId);
326        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
327        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
328        BowDocBs->DocCIdVV.Last().Gen(1, 0);
329        BowDocBs->DocCIdVV.Last().Add(CId);
330        PBowSpV SpV=TBowSpV::New(DId);
331        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
332        Lx.GetSym(syInt, syEoln);
333        while (Lx.Sym==syInt){
334          int WId=Lx.Int;
335          Lx.GetSym(syColon);
336          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
337          Lx.GetSym(syInt, syEoln);
338          SpV->AddWIdWgt(WId, WordFq);
339          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
340          WIdToFqH.AddDat(WId)++;
341        }
342        if (!Lx.CmtStr.Empty()){
343          TStr CmtStr=Lx.CmtStr;
344          static TStr DocNmPrefixStr="docDesc=";
345          if (CmtStr.IsPrefix(DocNmPrefixStr)){
346            TStr NewDocNm=
347             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
348            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
349            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
350            IAssert(DId==NewDId);
351          }
352        }
353        SpV->Trunc();
354        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
355      }
356    }
357    for (int WId=0; WId<=MxWId; WId++){
358      if (!BowDocBs->IsWId(WId)){
359        TStr WordStr=TInt::GetStr(WId, "W%d");
360        int _WId=BowDocBs->AddWordStr(WordStr);
361        IAssert(WId==_WId);
362        TInt Fq;
363        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
364          BowDocBs->PutWordFq(WId, Fq);
365        }
366      }
367    }
368    BowDocBs->AssertOk();
369    return BowDocBs;
370  }
371  PBowDocBs TBowFl::LoadCpdTxt(
372   const TStr& CpdFNm, const int& MxDocs,
373   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
374   const int& MxNGramLen, const int& MnNGramFq,
375   const bool& SaveDocP, const PNotify& Notify){
376    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
377    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
378    PNGramBs NGramBs;
379    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
380      NGramBs=TNGramBs::GetNGramBsFromCpd(
381       CpdFNm, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
382    }
383    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
384    TIntH DocWIdToFqH(100);
385    PSIn CpdSIn=TCpDoc::GetFirstCpd(CpdFNm); PCpDoc CpDoc; int Docs=0;
386    while (TCpDoc::GetNextCpd(CpdSIn, CpDoc)){
387      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
388      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
389      TStr DocNm=CpDoc->GetDocId();
390      TStrV CatNmV;
391      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
392        CatNmV.Add(CpDoc->GetCatNm(CatN));
393      }
394      TStr DocStr=CpDoc->GetTxtStr();
395      TStr DateStr=CpDoc->GetDateStr();
396      int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
397      BowDocBs->PutDateStr(DId, DateStr);
398    }
399    BowDocBs->AssertOk();
400    return BowDocBs;
401  }
402  void TBowFl::SaveCpdToLnDocTxt(const TStr& InCpdFNm, const TStr& OutLnDocFNm){
403    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
404    PSIn CpdSIn=TCpDoc::GetFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
405    printf("Saving '%s' to '%s' ...\n", InCpdFNm.CStr(), OutLnDocFNm.CStr());
406    while (TCpDoc::GetNextCpd(CpdSIn, CpDoc)){
407      Docs++; if (Docs%100==0){printf("%d Docs\r", Docs);}
408      TStr DocNm=CpDoc->GetDocId();
409      DocNm=TStr::GetFNmStr(DocNm);
410      DocNm.ChangeChAll(' ', '_');
411      TStrV CatNmV;
412      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
413        CatNmV.Add(CpDoc->GetCatNm(CatN));}
414      TChA DocChA=CpDoc->GetTxtStr();
415      DocChA.ChangeCh('\r', ' ');
416      DocChA.ChangeCh('\n', ' ');
417      fprintf(fOut, "%s", DocNm.CStr());
418      for (int CatN=0; CatN<CatNmV.Len(); CatN++){
419        fprintf(fOut, " !%s", CatNmV[CatN].CStr());}
420      fprintf(fOut, " %s\n", DocChA.CStr());
421    }
422    printf("%d Docs\nDone.\n", Docs);
423  }
424  PBowDocBs TBowFl::LoadTBsTxt(
425   const TStr& TBsFNm, const int& MxDocs,
426   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
427   const int& MxNGramLen, const int& MnNGramFq){
428    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
429    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
430    PNGramBs NGramBs;
431    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
432      NGramBs=TNGramBs::GetNGramBsFromTBs(
433       TBsFNm, MxDocs,
434       MxNGramLen, MnNGramFq, SwSet, Stemmer);
435    }
436    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
437    TStr TxtBsNm=TBsFNm.GetFBase();
438    TStr TxtBsFPath=TBsFNm.GetFPath();
439    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
440    TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
441    while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
442      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
443      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
444      TStr DocNm; TStr DocStr;
445      TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
446      BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, false);
447    }
448    BowDocBs->AssertOk();
449    return BowDocBs;
450  }
451  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr& LnDocFNm,
452   TIntV& NewDIdV, const bool& NamedP, const int& MxDocs, const bool& SaveDocP,
453   const PNotify& Notify) {
454    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
455    while (!FIn.Eof()){
456      Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
457      printf("%d\r", Docs);
458      TChA DocNm;
459      if (NamedP){
460        Ch=FIn.GetCh();
461        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
462          DocNm+=Ch; Ch=FIn.GetCh();}
463        DocNm.Trunc();
464        if (DocNm.Empty()){Docs--; continue;}
465      }
466      TStrV CatNmV;
467      forever {
468        while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
469        if (Ch=='!'){
470          if (!FIn.Eof()){Ch=FIn.GetCh();}
471          TChA CatNm;
472          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
473            CatNm+=Ch; Ch=FIn.GetCh();}
474          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
475        } else {
476          break;
477        }
478      }
479      TChA DocChA;
480      while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
481        DocChA+=Ch; Ch=FIn.GetCh();}
482      if (DocNm.Empty()&&DocChA.Empty()){
483        continue;}
484      NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
485    }
486    BowDocBs->AssertOk();
487    printf("\n");
488  }
489  PBowDocBs TBowFl::LoadLnDocTxt(
490   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
491   const PSwSet& SwSet, const PStemmer& Stemmer,
492   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP,
493   const PNotify& Notify){
494    PNGramBs NGramBs;
495    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
496      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
497       LnDocFNm, NamedP, MxDocs,
498       MxNGramLen, MnNGramFq, SwSet, Stemmer);
499    }
500    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
501    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP, Notify);
502    return BowDocBs;
503  }
504  PBowDocBs TBowFl::LoadLnDocTxt(
505   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
506   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
507   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP,
508     const PNotify& Notify){
509    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
510    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
511    PNGramBs NGramBs;
512    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
513      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
514       LnDocFNm, NamedP, MxDocs,
515       MxNGramLen, MnNGramFq, SwSet, Stemmer);
516    }
517    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
518    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP, Notify);
519    return BowDocBs;
520  }
521  void TBowFl::SaveLnDocTxt(const PBowDocBs& BowDocBs, const TStr& FNm, const bool& UseDocStrP){
522    TFOut SOut(FNm);
523    int Docs=BowDocBs->GetDocs();
524    for (int DId=0; DId<Docs; DId++){
525      printf("%d/%d\r", DId+1, Docs);
526      TStr DocNm=TStr::GetFNmStr(BowDocBs->GetDocNm(DId));
527      SOut.PutStr(DocNm);
528      for (int CIdN=0; CIdN<BowDocBs->GetDocCIds(DId); CIdN++){
529        int CId=BowDocBs->GetDocCId(DId, CIdN);
530        TStr CatNm=TStr::GetFNmStr(BowDocBs->GetCatNm(CId));
531        SOut.PutCh(' '); SOut.PutCh('!'); SOut.PutStr(CatNm);
532      }
533      if (UseDocStrP){
534        TStr DocStr=BowDocBs->GetDocStr(DId);
535        DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
536        SOut.PutCh(' '); SOut.PutStr(DocStr);
537      } else {
538          int DocWIds=BowDocBs->GetDocWIds(DId);
539          int WId; double WordFq;
540          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
541            BowDocBs->GetDocWIdFq(DId, DocWIdN, WId, WordFq);
542            TStr WordStr=BowDocBs->GetWordStr(WId);
543            for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
544              SOut.PutCh(' '); SOut.PutStr(WordStr);
545            }
546          }
547      }
548      SOut.PutLn();
549    }
550    printf("\n");
551  }
552  PBowDocBs TBowFl::LoadReuters21578Txt(
553   const TStr& FPath, const int& MxDocs,
554   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
555   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP,
556   const PNotify& Notify){
557    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
558    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
559    PNGramBs NGramBs;
560    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
561      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
562       FPath, MxDocs,
563       MxNGramLen, MnNGramFq, SwSet, Stemmer);
564    }
565    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
566    TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
567    while (FFile.Next(FNm)){
568      printf("Processing file '%s'\n", FNm.CStr());
569      TIntH DocWIdToFqH(100);
570      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
571      for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
572        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
573        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
574        PXmlDoc Doc=LDocV[LDocN];
575        PXmlTok DocTok=Doc->GetTok();
576        TStr DocNm=DocTok->GetArgVal("NEWID");
577        TStrV CatNmV;
578        TXmlTokV TopicsTokV; Doc->GetTagTokV("REUTERS|TOPICS|D", TopicsTokV);
579        for (int TopicsTokN=0; TopicsTokN<TopicsTokV.Len(); TopicsTokN++){
580          TStr CatNm=TopicsTokV[TopicsTokN]->GetTokStr(false);
581          CatNmV.Add(CatNm);
582        }
583        PXmlTok DocStrTok=Doc->GetTagTok("REUTERS|TEXT");
584        TStr DocStr=DocStrTok->GetTokStr(false);
585        int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
586        if ((DocTok->GetArgVal("LEWISSPLIT")=="TRAIN")&&(DocTok->GetArgVal("TOPICS")=="YES")){
587          BowDocBs->AddTrainDId(DId);}
588        if ((DocTok->GetArgVal("LEWISSPLIT")=="TEST")&&(DocTok->GetArgVal("TOPICS")=="YES")){
589          BowDocBs->AddTestDId(DId);}
590      }
591      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
592    }
593    BowDocBs->AssertOk();
594    return BowDocBs;
595  }
596  PBowDocBs TBowFl::LoadCiaWFBTxt(
597   const TStr& FPath, const int& MxDocs,
598   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
599   const int& MxNGramLen, const int& MnNGramFq){
600    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
601    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
602    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
603    PNGramBs NGramBs;
604    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
605      TStrV HtmlStrV;
606      for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
607        PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
608        HtmlStrV.Add(CiaWFBCountry->GetDescStr());
609      }
610      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
611       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
612    }
613    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
614    for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
615      PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
616      TStr CountryNm=CiaWFBCountry->GetCountryNm();
617      TStr DescStr=CiaWFBCountry->GetDescStr();
618      TStr CatNm=CiaWFBCountry->GetFldVal("Map references").GetTrunc();
619      TStrV CatNmV; CatNmV.Add(CatNm);
620      BowDocBs->AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
621    }
622    BowDocBs->AssertOk();
623    return BowDocBs;
624  }
625  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs& BowDocBs,
626      const PBowDocWgtBs& BowDocWgtBs, const TStr& FNm,
627      const TStr& CatFNm, const TIntV& _DIdV) {
628    TIntV DIdV;
629    if (_DIdV.Empty()) {
630        BowDocBs->GetAllDIdV(DIdV);
631    } else {
632        DIdV = _DIdV;
633    }
634    TFOut WdMapSOut(TStr::PutFExt(FNm, ".row-to-word-map.dat"));
635    for (int WId = 0; WId < BowDocWgtBs->GetWords(); WId++) {
636      TStr WdStr = BowDocBs->GetWordStr(WId);
637      WdMapSOut.PutStrLn(TStr::Fmt("%d %s", WId+1,  WdStr.CStr()));
638    }
639    WdMapSOut.Flush();
640    TFOut DocMapSOut(TStr::PutFExt(FNm, ".col-to-docName-map.dat"));
641    for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
642      const int DId = DIdV[DocN];
643      TStr DocNm = BowDocBs->GetDocNm(DId);
644      DocMapSOut.PutStrLn(TStr::Fmt("%d %d %s", DocN, DId,  DocNm.CStr()));
645    }
646    DocMapSOut.Flush();
647    TFOut SOut(FNm);
648    for (int DocN = 0; DocN < DIdV.Len(); DocN++){
649      const int DId = DIdV[DocN];
650      PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
651      const int DocWIds = DocSpV->GetWIds();
652      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
653        const int WId = DocSpV->GetWId(DocWIdN);
654        const double WordWgt = DocSpV->GetWgt(DocWIdN);
655        SOut.PutStrLn(TStr::Fmt("%d %d %.16f", WId+1, DocN+1, WordWgt));
656      }
657    }
658    SOut.Flush();
659    if (!CatFNm.Empty()) {
660      TFOut CatSOut(CatFNm);
661      for (int DocN = 0; DocN < DIdV.Len(); DocN++){
662        const int DId = DIdV[DocN];
663        const int DocCIds = BowDocBs->GetDocCIds(DId);
664        for (int DocCIdN=0; DocCIdN<DocCIds; DocCIdN++){
665          const int CId = BowDocBs->GetDocCId(DId, DocCIdN);
666          const double CatWgt = 1.0;
667          CatSOut.PutStrLn(TStr::Fmt("%d %d %.16f", CId+1, DocN+1, CatWgt));
668        }
669      }
670      CatSOut.Flush();
671    }
672  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowflx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>248   const int& MxDocs){ 
249    PBowDocBs BowDocBs=TBowDocBs::New();
250    int MOneCId=BowDocBs->CatNmToFqH.AddKey("-1");
</pre></code></div>
                <div class="column column_space"><pre><code>170   const int& MxDocs){
171    PBowDocBs BowDocBs=TBowDocBs::New();
172    if (!DocDefFNm.Empty()){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    