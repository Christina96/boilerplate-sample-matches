
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.880736466062105%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.cpp</h3>
            <pre><code>1  #include "crawler.h"
2  bool TCrawlerDef::IsHostNmOk(const TStr& HostNm){
3    bool HostNmOkP=false;
4    if (RqDmNmV.Empty()){
5      HostNmOkP=true;
6    } else {
7      for (int RqDmNmN=0; RqDmNmN<RqDmNmV.Len(); RqDmNmN++){
8        if (HostNm.IsSuffix(RqDmNmV[RqDmNmN])){
9          HostNmOkP=true; break;
10        }
11      }
12    }
13    if (HostNmOkP){
14      for (int BadDmNmN=0; BadDmNmN<BadDmNmV.Len(); BadDmNmN++){
15        if (HostNm.IsSuffix(BadDmNmV[BadDmNmN])){
16          HostNmOkP=false; break;
17        }
18      }
19    }
20    return HostNmOkP;
21  }
22  bool TCrawlerDef::IsContTypeNmOk(const TStr& ContTypeNm){
23    if (RqContTypeNmV.Empty()){
24      return true;
25    } else {
26      TStr LcContTypeNm=ContTypeNm.GetLc();
27      for (int ContTypeNmN=0; ContTypeNmN<RqContTypeNmV.Len(); ContTypeNmN++){
28        if (LcContTypeNm.IsWcMatch(RqContTypeNmV[ContTypeNmN])){return true;}
29      }
30      return false;
31    }
32  }
33  bool TCrawlerDef::IsFExtOk(const PUrl& Url) const {
34    if (BadFExtV.Empty()||(Url->GetPathSegs()==0)){
35      return true;
36    } else {
37      TStr UrlStr=Url->GetUrlStr();
38      TStr FBase=Url->GetPathSeg(Url->GetPathSegs()-1);
39      TStr FExt=FBase.GetFExt().GetUc();
40      return (!BadFExtH.IsKey(FExt));
41    }
42  }
43  void TCrawlerDef::OptHtmlCrawling(){
44    AddBadFExt(".JPEG"); AddBadFExt(".JPG"); AddBadFExt(".GIF"); AddBadFExt(".BMP");
45    AddBadFExt(".MPEG"); AddBadFExt(".MPG"); AddBadFExt(".AVI"); AddBadFExt(".MOV");
46    AddBadFExt(".MP3"); AddBadFExt(".WAV"); AddBadFExt(".MID"); AddBadFExt(".RA");
47    AddBadFExt(".ZIP"); AddBadFExt(".RAR"); AddBadFExt(".GZ"); AddBadFExt(".TAR");
48    AddBadFExt(".PDF"); AddBadFExt(".DOC"); AddBadFExt(".XSL"); AddBadFExt(".PPT");
49    AddRqContTypeNm("text&bsol;*");
50  }
51  void TCrawlerDef::AddSiteUrlStr(const TStr& SiteUrlStr){
52    PUrl Url=TUrl::New(SiteUrlStr);
53    if (Url->IsOk(usHttp)){
54      AddRqDmNm(Url->GetHostNm());
55      AddStartUrlStr(SiteUrlStr);
56    }
57  }
58  void TCrawlerDef::AddSiteUrlStrV(const TStrV& SiteUrlStrV){
59    for (int UrlStrN=0; UrlStrN<SiteUrlStrV.Len(); UrlStrN++){
60      AddSiteUrlStr(SiteUrlStrV[UrlStrN]);
61    }
62  }
63  void TCrawlerDef::LoadUrlStrV(const TStr& SiteUrlStrVFNm){
64    if (SiteUrlStrVFNm.Empty()){return;}
65    PSIn SIn=TFIn::New(SiteUrlStrVFNm);
66    TILx Lx(SIn);
67    while (Lx.GetSym(syLn, syEof)!=syEof){
68      TStr UrlStr=TStr(Lx.Str).GetTrunc();
69      AddSiteUrlStr(UrlStr);
70    }
71  }
72  TStr TCrawlerDef::GetStr(){
73    TChA ChA;
74    ChA+=TStr::Fmt("                  Max. Urls: %d\n", GetMxUrls());
75    ChA+=TStr::Fmt("           Min. Connections: %d\n", GetMnConns());
76    ChA+=TStr::Fmt("           Max. Connections: %d\n", GetMxConns());
77    ChA+=TStr::Fmt("Max. Connections Per Server: %d\n", GetMxConnsPerSrv());
78    ChA+=TStr::Fmt("          After Fetch Delay: %d\n", GetAfterFetchDelaySecs());
79    ChA+=TStr::Fmt("                 Max. Level: %d\n", GetMxLev());
80    ChA+=TStr::Fmt("                 Max. Depth: %d\n", GetMxDep());
81    ChA+=TStr::Fmt("        Max. Content Length: %d\n", GetMxContLen());
82    ChA+=TStr::Fmt("          Min. Queue Length: %d\n", GetMnQLen());
83    ChA+=TStr::Fmt("         Queue Reset Modulo: %d\n", GetQResetMod());
84    ChA+=TStr::Fmt("  Max. Queue Segment Length: %d\n", GetMxQSegLen());
85    ChA+=TStr::Fmt("               Max. Retries: %d\n", GetMxRetries());
86    ChA+=TStr::Fmt("           Revisits Seconds: %d\n", GetRevisitSecs());
87    ChA+=TStr::Fmt("Redirection Domains Allowed: %d\n", TBool::GetYesNoStr(IsRedirDmAllowed()));
88    ChA+=TStr::Fmt("                 Start Urls:");
89    for (int UrlN=0; UrlN<GetStartUrls(); UrlN++){
90      ChA+=" "; ChA+=GetStartUrl(UrlN);}
91    ChA+="\n";
92    ChA+=TStr::Fmt("           Required Domains:");
93    for (int DmNmN=0; DmNmN<RqDmNmV.Len(); DmNmN++){
94      ChA+=" "; ChA+=RqDmNmV[DmNmN];}
95    ChA+="\n";
96    ChA+=TStr::Fmt("                Bad Domains:");
97    for (int DmNmN=0; DmNmN<BadDmNmV.Len(); DmNmN++){
98      ChA+=" "; ChA+=BadDmNmV[DmNmN];}
99    ChA+="\n";
100    ChA+=TStr::Fmt("                Geo-IP Base: %s\n", TBool::GetYesNoStr(IsGeoIpBs()).CStr());
101    ChA+=TStr::Fmt("                  Countries:");
102    for (int CountryNmN=0; CountryNmN<RqCountryNmV.Len(); CountryNmN++){
103      ChA+=" "; ChA+=RqCountryNmV[CountryNmN];}
104    ChA+="\n";
105    ChA+=TStr::Fmt("              Content Types:");
106    for (int ContTypeNmN=0; ContTypeNmN<RqContTypeNmV.Len(); ContTypeNmN++){
107      ChA+=" "; ChA+=RqContTypeNmV[ContTypeNmN];}
108    ChA+="\n";
109    ChA+=TStr::Fmt("        Bad File Extensions:");
110    for (int FExtN=0; FExtN<BadFExtV.Len(); FExtN++){
111      ChA+=" "; ChA+=BadFExtV[FExtN];}
112    ChA+="\n";
113    return ChA;
114  }
115  TCrawlerUrlDescBs::TCrawlerUrlDescBs(TCrawler* _Crawler):
116    Crawler(_Crawler){
117    IAssert(Crawler->GetDef()->GetMxUrls()!=-1);
118    UrlMd5SigToDescH.Gen(Crawler->GetDef()->GetMxUrls());
119  }
120  TStr TCrawlerUrlDescBs::GetFNm() const {
121    return
122     Crawler->GetDocBs()->GetDocBsNrFPath()+
123     Crawler->GetDocBs()->GetDocBsNm()+".UrlBs";
124  }
125  void TCrawlerUrlDescBs::Load(){
126    TFIn SIn(GetFNm()); UrlMd5SigToDescH.Load(SIn);
127  }
128  void TCrawlerUrlDescBs::Save(){
129    TFOut SOut(GetFNm()); UrlMd5SigToDescH.Save(SOut);
130  }
131  TCrawlerHostBs::TCrawlerHostBs(TCrawler* _Crawler):
132    Crawler(_Crawler){
133  }
134  PCrawlerHost TCrawlerHostBs::AddGetHost(const TStr& HostNm){
135    int HostId;
136    if (!NmToHostH.IsKey(HostNm, HostId)){
137      HostId=NmToHostH.AddKey(HostNm);
138      NmToHostH[HostId]=TCrawlerHost::New(HostNm);
139    }
140    return NmToHostH[HostId];
141  }
142  void TCrawlerHostBs::GetSortedHostV(TCrawlerHostV& HostV, const TStr& SortOrderNm){
143    typedef TKeyDat<TStr, PCrawlerHost> TNmHostKd;
144    TVec<TNmHostKd> NmHostKdV;
145    int Hosts=GetHosts(); bool SortAscP=true;
146    for (int HostN=0; HostN<Hosts; HostN++){
<span onclick='openModal()' class='match'>147      PCrawlerHost Host=GetHost(HostN);
148      TStr KeyStr;
149      if (SortOrderNm=="Host"){KeyStr=Host->GetRevHostNm(); SortAscP=true;}
150      else if (SortOrderNm=="Active"){KeyStr=TInt::GetStr(Host->GetActiveConns(), "%012d"); SortAscP=false;}
151      else if (SortOrderNm=="Fetched"){KeyStr=TInt::GetStr(Host->GetFetchedUrls(), "%012d"); SortAscP=false;}
</span>152      else if (SortOrderNm=="Errors"){KeyStr=TInt::GetStr(Host->GetFetchErrors(), "%012d"); SortAscP=false;}
153      else if (SortOrderNm=="Queue"){KeyStr=TInt::GetStr(Host->GetQueueUrls(), "%012d"); SortAscP=false;}
154      else if (SortOrderNm=="Bytes"){KeyStr=TFlt::GetStr(double(Host->GetTransferBytes()), "%012.0f"); SortAscP=false;}
155      else if (SortOrderNm=="Time"){KeyStr=TFlt::GetStr(Host->GetTransferMSecs(), "%012.0f"); SortAscP=false;}
156      else if (SortOrderNm=="PageLen"){KeyStr=TFlt::GetStr(Host->GetAvgHttpRespLen(), "%012.0f"); SortAscP=false;}
157      else if (SortOrderNm=="Speed"){KeyStr=TFlt::GetStr(Host->GetAvgTransferBps(), "%012.0f"); SortAscP=false;}
158      else {KeyStr=Host->GetRevHostNm(); SortAscP=true;}
159      NmHostKdV.Add(TNmHostKd(KeyStr, Host));
160    }
161    NmHostKdV.Sort(SortAscP);
162    HostV.Gen(NmHostKdV.Len(), 0);
163    for (int HostN=0; HostN<NmHostKdV.Len(); HostN++){
164      HostV.Add(NmHostKdV[HostN].Dat);
165    }
166  }
167  void TCrawlerHostBs::GetSummaryInfo(
168   int& ActiveConns, int& FetchedUrls, int& FetchErrors, int& QueueUrls, 
169   double& TransferBytes, double& TransferMSecs, double& AvgHttpRespLen, 
170   double& AvgTransferBps){
171    ActiveConns=0; FetchedUrls=0; FetchErrors=0; QueueUrls=0;
172    TransferBytes=0; TransferMSecs=0; 
173    AvgHttpRespLen=0; AvgTransferBps=0;
174    int Hosts=GetHosts();
175    for (int HostN=0; HostN<Hosts; HostN++){
176      PCrawlerHost Host=GetHost(HostN);
177      ActiveConns+=Host->GetActiveConns();
178      FetchedUrls+=Host->GetFetchedUrls();
179      FetchErrors+=Host->GetFetchErrors();
180      QueueUrls+=Host->GetQueueUrls();
181      TransferBytes+=Host->GetTransferBytes();
182      TransferMSecs+=Host->GetTransferMSecs();
183      AvgHttpRespLen+=Host->GetAvgHttpRespLen();
184      AvgTransferBps+=Host->GetAvgTransferBps();
185    }
186    if (Hosts>0){
187      AvgHttpRespLen=AvgHttpRespLen/Hosts;
188      AvgTransferBps=AvgTransferBps/Hosts;
189    }
190  }
191  TCrawlerQueue::TCrawlerQueue(TCrawler* _Crawler):
192    Crawler(_Crawler), UrlMd5SigToUrlStrHostNmLevDepQuH(){
193  }
194  void TCrawlerQueue::GetQUrlsHostPrV(TIntStrPrV& QUrlsHostPrV){
195    QUrlsHostPrV.Clr();
196    TStrIntH HostToQUrlsH;
197    int QUrlP=UrlMd5SigToUrlStrHostNmLevDepQuH.FFirstKeyId();
198    while (UrlMd5SigToUrlStrHostNmLevDepQuH.FNextKeyId(QUrlP)){
199      TStr HostNm=GetQHostNm(QUrlP);
200      int Lev=GetQUrlLev(QUrlP);
201      HostToQUrlsH.AddDat(HostNm+":"+TInt::GetStr(Lev))++;
202    }
203    HostToQUrlsH.GetDatKeyPrV(QUrlsHostPrV);
204    QUrlsHostPrV.Sort(false);
205  }
206  void TCrawlerQueue::PushQUrl(const PUrl& Url, const int& Lev, const int& Dep){
207    PCrawlerDef Def=Crawler->GetDef();
208    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
209    PCrawlerHostBs HostBs=Crawler->GetHostBs();
210    IAssert(Url->IsOk(usHttp));
211    TMd5Sig UrlMd5Sig=TCrawler::GetUrlMd5Sig(Url->GetUrlStr());
212    if (UrlDescBs->IsUrl(UrlMd5Sig)){ 
213      if (UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev>Lev){
214        UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev=Lev;}
215    } else
216    if (IsQUrl(UrlMd5Sig)){ 
217    } else
218    if ((Def->GetMxLev()==-1)||(Lev<=Def->GetMxLev())&&
219     ((Def->GetMxDep()==-1)||(Dep<=Def->GetMxDep()))){
220      int QUrlId=AddQUrl(UrlMd5Sig, Url->GetUrlStr(), Url->GetHostNm(), Lev, Dep);
221      while (LevUrlIdQV.Len()-1<Lev){LevUrlIdQV.Add();}
222      LevUrlIdQV[Lev].Push(QUrlId);
223      HostBs->AddGetHost(Url->GetHostNm())->GetQueueUrls()++;
224    }
225  }
226  void TCrawlerQueue::PushQUrl(const TStr& UrlStr, const int& Lev, const int& Dep){
227    PUrl Url=TUrl::New(UrlStr);
228    if (Url->IsOk(usHttp)){
229      PushQUrl(Url, Lev, Dep);
230    }
231  }
232  bool TCrawlerQueue::PopQUrl(int& QUrlId, TStr& UrlStr){
233    PCrawlerDef Def=Crawler->GetDef();
234    PCrawlerHostBs HostBs=Crawler->GetHostBs();
235    int MxCheckedUrlsPerLev=100; 
236    while (MxCheckedUrlsPerLev<=100000){
237      for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
238        int CheckedUrls=0;
239        if (!LevUrlIdQV[Lev].Empty()){
240          bool FirstP=true; int FirstQUrlId;
241          forever {
242            QUrlId=LevUrlIdQV[Lev].Top();
243            if (FirstP){FirstQUrlId=QUrlId; FirstP=false;}
244            else if (QUrlId==FirstQUrlId){break;}
245            CheckedUrls++;
246            if (CheckedUrls>MxCheckedUrlsPerLev){break;}
247            LevUrlIdQV[Lev].Pop();
248            UrlStr=GetQUrlStr(QUrlId);
249            TStr HostNm=GetQHostNm(QUrlId);
250            PCrawlerHost Host=HostBs->AddGetHost(HostNm);
251            int ActiveConns=Host->GetActiveConns();
252            int MxConnsPerSrv=Def->GetMxConnsPerSrv();
253            TSecTm LastFetchTm=Host->GetLastFetchTm();
254            TSecTm CurTm=TSecTm::GetCurTm();
255            int AfterFetchDelaySecs=Def->GetAfterFetchDelaySecs();
256  		  int FetchDSecs=TInt::Abs(TSecTm::GetDSecs(LastFetchTm, CurTm));
257            if ((ActiveConns<MxConnsPerSrv)&&(FetchDSecs>=AfterFetchDelaySecs)){
258              Host->GetQueueUrls()--;
259              return true;
260            } else {
261              LevUrlIdQV[Lev].Push(QUrlId);
262            }
263          }
264        }
265      }
266      MxCheckedUrlsPerLev=MxCheckedUrlsPerLev*10;
267    }
268    return false;
269  }
270  void TCrawlerQueue::ShuffleUrlQ(){
271    if (Crawler->GetUrlDescBs()->GetUrls()%1000==0){
272      printf("*** Shuffle Queues\n");
273      for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
274        TRnd Rnd(0); LevUrlIdQV[Lev].Shuffle(Rnd);
275        printf("    Queue Level %d: %d\n", Lev, LevUrlIdQV[Lev].Len());
276      }
277    }
278  }
279  void TCrawlerQueue::ResetQUrlBs(){
280    PCrawlerDef Def=Crawler->GetDef();
281    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
282    if ((Def->GetQResetMod()>0)&&(UrlDescBs->GetUrls()%Def->GetQResetMod()==0)){
283      PopSaveQUrlBs();
284      PushQUrlBs();
285    }
286  }
287  TStr TCrawlerQueue::GetUrlQBBsFNm() const {
288    TStr UrlQBBsFNm=
289     Crawler->GetDocBs()->GetDocBsNrFPath()+
290     Crawler->GetDocBs()->GetDocBsNm()+"."+
291     TTm::GetUniqueCurUniTm().GetIdStr()+".UrlQBs";
292    return UrlQBBsFNm;
293  }
294  TStr TCrawlerQueue::GetUrlQBBsWcFNm() const {
295    TStr UrlQBBsFNm=
296     Crawler->GetDocBs()->GetDocBsNrFPath()+
297     Crawler->GetDocBs()->GetDocBsNm()+".*.UrlQBs";
298    return UrlQBBsFNm;
299  }
300  void TCrawlerQueue::PushQUrlBs(){
301    if (Empty()){
302      UrlMd5SigToUrlStrHostNmLevDepQuH.Clr(); 
303      LevUrlIdQV.Clr(); 
304    }
305    UrlQBBs=NULL; 
306    if (!ToDelUrlQBBsFNm.Empty()){ 
307      TFile::Del(ToDelUrlQBBsFNm); ToDelUrlQBBsFNm="";
308    }
309    TFFile FFile(GetUrlQBBsWcFNm(), false); TStr UrlQBBsFNm;
310    if (FFile.Next(UrlQBBsFNm)){
311      PBlobBs UrlQBBs=TGBlobBs::New(UrlQBBsFNm);
312      ToDelUrlQBBsFNm=UrlQBBsFNm;
313      TBlobPt TrvUrlQBlobPt=UrlQBBs->FFirstBlobPt();
314      TBlobPt UrlQBlobPt; PSIn UrlQBlobSIn;
315      while (UrlQBBs->FNextBlobPt(TrvUrlQBlobPt, UrlQBlobPt, UrlQBlobSIn)){
316        TStr UrlStr=TStr(*UrlQBlobSIn);
317        int Lev=TInt(*UrlQBlobSIn);
318        int Dep=TInt(*UrlQBlobSIn);
319        PushQUrl(UrlStr, Lev, Dep);
320      }
321    }
322  }
323  void TCrawlerQueue::PushQUrlToUrlQBs(const PUrl& Url, const int& Lev, const int& Dep){
324    PCrawlerDef Def=Crawler->GetDef();
325    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
326    PCrawlerHostBs HostBs=Crawler->GetHostBs();
327    IAssert(Url->IsOk(usHttp));
328    TMd5Sig UrlMd5Sig=TCrawler::GetUrlMd5Sig(Url->GetUrlStr());
329    if (UrlDescBs->IsUrl(UrlMd5Sig)){ 
330      if (UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev>Lev){
331        UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev=Lev;}
332    } else
333    if (IsQUrl(UrlMd5Sig)){ 
334    } else
335    if ((Def->GetMxLev()==-1)||(Lev<=Def->GetMxLev())&&
336     ((Def->GetMxDep()==-1)||(Dep<=Def->GetMxDep()))){
337      if (UrlQBBs.Empty()){
338        TStr UrlQBBsFNm=GetUrlQBBsFNm(); printf("*** %s\n", UrlQBBsFNm.CStr());
339        UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate, Def->GetMxQSegLen());
340      }
341      TMOut UrlQSOut(Url->GetUrlStr().Len()+100);
342      Url->GetUrlStr().Save(UrlQSOut);
343      TInt(Lev).Save(UrlQSOut);
344      TInt(Dep).Save(UrlQSOut);
345      PSIn UrlQSIn=UrlQSOut.GetSIn();
346      TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
347      if (UrlQBlobPt.Empty()){
348        TStr UrlQBBsFNm=GetUrlQBBsFNm(); printf("*** %s\n", UrlQBBsFNm.CStr());
349        UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate, Def->GetMxQSegLen());
350        UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
351        IAssert(!UrlQBlobPt.Empty());
352      }
353    }
354  }
355  void TCrawlerQueue::PushQUrlToUrlQBs(const TStr& UrlStr, const int& Lev, const int& Dep){
356    PUrl Url=TUrl::New(UrlStr);
357    if (Url->IsOk(usHttp)){
358      PushQUrlToUrlQBs(Url, Lev, Dep);
359    }
360  }
361  void TCrawlerQueue::PopSaveQUrlBs(){
362    PCrawlerHostBs HostBs=Crawler->GetHostBs();
363    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
364    TStr UrlQBBsFNm=GetUrlQBBsFNm(); 
365    printf("*** Saving Active Queue-Url-Base To %s\n", UrlQBBsFNm.CStr());
366    UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate);
367    for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
368      while (!LevUrlIdQV[Lev].Empty()){
369        int QUrlId=LevUrlIdQV[Lev].Top();
370        TStr HostNm=GetQHostNm(QUrlId);
371        PCrawlerHost Host=HostBs->GetHost(HostNm);
372        TStr UrlStr=GetQUrlStr(QUrlId);
373        int Dep=GetQUrlDep(QUrlId);
374        LevUrlIdQV[Lev].Pop();
375        Host->GetQueueUrls()--;
376        DelQUrl(QUrlId);
377        TMOut UrlQSOut(UrlStr.Len()+100);
378        UrlStr.Save(UrlQSOut);
379        TInt(Lev).Save(UrlQSOut);
380        TInt(Dep).Save(UrlQSOut);
381        PSIn UrlQSIn=UrlQSOut.GetSIn();
382        TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
383      }
384    }
385  }
386  void TCrawlerFetcher::DelCrawlerFetcherConn(const int& ConnId){
387    PCrawlerHostBs HostBs=Crawler->GetHostBs();
388    int QUrlId; PUrl Url; int FetchMSecs; GetDelConn(ConnId, QUrlId, Url, FetchMSecs);
389    Crawler->GetQueue()->DelQUrl(QUrlId);
390    PCrawlerHost Host=HostBs->GetHost(Url->GetHostNm());
391    Host->GetActiveConns()--;
392    Host->GetFetchErrors()++;
393    Host->GetLastFetchTm()=TSecTm::GetCurTm();
394  }
395  TCrawlerFetcher::TCrawlerFetcher(TCrawler* _Crawler):
396    TWebPgFetch(), Crawler(_Crawler), CurMxConns(-1), 
397    LastClrZombiesTm(), Zombies(0), ZombieConnIdToFetchSizeH(){
398    IAssert(Crawler->GetDef()->GetMxConns()!=-1);
399    PutMxConns(Crawler->GetDef()->GetMxConns());
400    CurMxConns=1;
401    PutMxContLen(Crawler->GetDef()->GetMxContLen());
402    PutMxRetries(Crawler->GetDef()->GetMxRetries());
403    if (Crawler->GetDef()->GetUserAgentStr()=="ie8"){
404      PutUserAgentStrIE8();
405    } else {
406      PutUserAgentStr(Crawler->GetDef()->GetUserAgentStr());
407    }
408  }
409  void TCrawlerFetcher::GetConnV(TIntStrIntIntQuV& ConnIdUrlStrMSecsSizeQuV){
410    ConnIdUrlStrMSecsSizeQuV.Gen(GetConns(), 0);
411    int ConnP=ConnIdToQUrlIdUrlTmTrH.FFirstKeyId();
412    while (ConnIdToQUrlIdUrlTmTrH.FNextKeyId(ConnP)){
413      int ConnId=ConnIdToQUrlIdUrlTmTrH.GetKey(ConnP);
414      TStr UrlStr=ConnIdToQUrlIdUrlTmTrH[ConnP].Val2->GetUrlStr();
415      int FetchMSecs=int(TTm::GetCurUniMSecs()-ConnIdToQUrlIdUrlTmTrH[ConnP].Val3);
416      int FetchSize=GetConnBytesRead(ConnId);
417      ConnIdUrlStrMSecsSizeQuV.Add(TIntStrIntIntQu(ConnId, UrlStr, FetchMSecs, FetchSize));
418    }
419    ConnIdUrlStrMSecsSizeQuV.Sort();
420  }
421  void TCrawlerFetcher::ClrZombies(){
422    PCrawlerDef Def=Crawler->GetDef();
423    PCrawlerQueue Queue=Crawler->GetQueue();
424    if ((LastClrZombiesTm.IsDef())&&(TTm::GetDiffMSecs(LastClrZombiesTm, TTm::GetCurUniTm())<100000)){return;}
425    LastClrZombiesTm=TTm::GetCurUniTm();
426    TIntStrIntIntQuV ConnIdUrlStrMSecsSizeQuV; GetConnV(ConnIdUrlStrMSecsSizeQuV);
427    int ConnIds=ConnIdUrlStrMSecsSizeQuV.Len();
428    for (int ConnN=0; ConnN<ConnIds; ConnN++){
429      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
430      TStr UrlStr=ConnIdUrlStrMSecsSizeQuV[ConnN].Val2;
431      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
432      if (ZombieConnIdToFetchSizeH.IsKey(ConnId)){
433        int PrevFetchSize=ZombieConnIdToFetchSizeH.GetDat(ConnId);
434        if (FetchSize==PrevFetchSize){
435          printf("*** Zombie: %s\n", UrlStr.CStr()); 
436          Zombies++; 
437          DelConn(ConnId); 
438          DelCrawlerFetcherConn(ConnId); 
439          Queue()->PushQUrl(UrlStr, 0, 0); 
440          PutCurMxConns(Def->GetMnConns()); 
441        }
442      }
443    }
444    ZombieConnIdToFetchSizeH.Clr(false);
445    for (int ConnN=0; ConnN<ConnIds; ConnN++){
446      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
447      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
448      ZombieConnIdToFetchSizeH.AddDat(ConnId)=FetchSize;
449    }
450  }
451  void TCrawlerFetcher::Fetch(){
452    PCrawlerHostBs HostBs=Crawler->GetHostBs();
453    PCrawlerQueue Queue=Crawler->GetQueue();
454    int QUrlId; TStr UrlStr;
455    while ((GetConns()<=GetCurMxConns())&&(GetWaitUrls()==0)&&
456     (Queue->PopQUrl(QUrlId, UrlStr))){
457      PUrl IpUrl=TUrl::New(UrlStr);
458      PCrawlerHost Host=HostBs->AddGetHost(IpUrl->GetHostNm());
459      if (Host->IsIpNum()){
460        IpUrl->PutIpNum(Host->GetIpNum());}
461      int ConnId=FetchUrl(IpUrl);
462      PUrl Url=TUrl::New(UrlStr);
463      AddConn(ConnId, QUrlId, Url);
464      Host->GetActiveConns()++;
465    }
466    int QUrls=Queue->GetQUrls();
467    int MnQLen=Crawler->GetDef()->GetMnQLen();
468    if ((QUrls%100==0)&&(QUrls<MnQLen)){
469      Queue->PushQUrlBs();
470    }
471  }
472  void TCrawlerFetcher::OnFetch(const int& ConnId, const PWebPg& WebPg){
473    PCrawlerDef Def=Crawler->GetDef();
474    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
475    PCrawlerHostBs HostBs=Crawler->GetHostBs();
476    PCrawlerQueue Queue=Crawler->GetQueue();
477    PCrawlerDocBs DocBs=Crawler->GetDocBs();
478    int QUrlId; PUrl Url; int FetchMSecs; GetDelConn(ConnId, QUrlId, Url, FetchMSecs);
479    TMd5Sig UrlMd5Sig; int Lev; int Dep;
480    Queue->GetQUrl(QUrlId, UrlMd5Sig, Lev, Dep);
481    Queue->DelQUrl(QUrlId);
482    if (!UrlDescBs->IsUrl(UrlMd5Sig)){
483      /&bsol;**IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));
484      if (UrlMd5Sig!=TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0))){
485        SaveToErrLog("Begin:IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));");
486        SaveToErrLog(TStr::Fmt("Urls: %d", WebPg->GetUrls()).CStr());
487        SaveToErrLog(TStr::Fmt("Md5: %s", UrlMd5Sig.GetStr().CStr()).CStr());
488        for (int WebPgUrlN=0; WebPgUrlN<WebPg->GetUrls(); WebPgUrlN++){
489          SaveToErrLog(TStr::Fmt("Url #%d: %s",
490           WebPgUrlN,
491           WebPg->GetUrlStr(WebPgUrlN).CStr()).CStr());
492        }
493        SaveToErrLog("End:IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));");
494      }
495      for (int WebPgUrlN=0; WebPgUrlN<WebPg->GetUrls(); WebPgUrlN++){
496        TStr DocUrlStr=WebPg->GetUrlStr(WebPgUrlN);
497        TMd5Sig DocUrlMd5Sig=TCrawler::GetUrlMd5Sig(DocUrlStr);
498        if (!UrlDescBs->IsUrl(DocUrlMd5Sig)){
499          TBlobPt DocBlobPt; TMd5Sig DocMemMd5Sig;
500          TStr ContTypeNm=WebPg->GetHttpResp()->GetFldVal(THttp::ContTypeFldNm);
501          if (Def->IsContTypeNmOk(ContTypeNm)){
502            if (WebPgUrlN==WebPg->GetUrls()-1){
503              TMem DocMem; WebPg->GetHttpResp()->GetAsMem(DocMem);
504              DocMemMd5Sig=TMd5Sig(DocMem);
505              DocBlobPt=DocBs->AddDoc(DocUrlStr, DocMem);
506            } else {
507              TStr FinalUrlStr=WebPg->GetUrlStr(WebPg->GetUrls()-1);
508              PHttpResp RedirHttpResp=THttpResp::New(
509               THttp::RedirStatusCd, THttp::TextPlainFldVal, false, NULL, FinalUrlStr);
510              TMem DocMem; RedirHttpResp->GetAsMem(DocMem);
511              DocMemMd5Sig=TMd5Sig(DocMem);
512              DocBlobPt=DocBs->AddDoc(DocUrlStr, DocMem);
513            }
514          }
515          if (Def->IsRedirDmAllowed()){
516            PUrl Url=TUrl::New(DocUrlStr);
517            TStr HostNm=Url->GetHostNm();
518            Def->AddRqDmNm(HostNm);
519          }
520          TCrawlerUrlDesc UrlDesc(
521           DocBlobPt, DocMemMd5Sig, TSecTm::GetCurTm(), TUCh(Lev), TUCh(Dep));
522          UrlDescBs->AddUrlDesc(DocUrlMd5Sig, UrlDesc);
523        }
524      }
525    }
526    PCrawlerHost Host=HostBs->GetHost(Url->GetHostNm());
527    Host->GetIpNum()=WebPg->GetIpNum(0);
528    Host->GetActiveConns()--;
529    Host->GetFetchedUrls()++;
530    Host->GetTransferBytes()+=WebPg->GetHttpResp()->Len();
531    Host->GetTransferMSecs()+=int(WebPg->GetFetchMSecs());
532    Host->GetLastFetchTm()=TSecTm::GetCurTm();
533    TStr HostNm=Url->GetHostNm();
534    if (WebPg->GetHttpResp()->IsContType(THttp::TextFldVal)){
535      TUrlV OutUrlV; TUrlV OutRedirUrlV; WebPg->GetOutUrlV(OutUrlV, OutRedirUrlV);
536      if (Def->IsRedirDmAllowed()){
537        for (int UrlN=0; UrlN<OutRedirUrlV.Len(); UrlN++){
538          TStr HostNm=OutRedirUrlV[UrlN]->GetHostNm();
539          Def->AddRqDmNm(HostNm);
540        }
541      }
542      for (int UrlN=0; UrlN<OutUrlV.Len(); UrlN++){
543        TStr OutHostNm=OutUrlV[UrlN]->GetHostNm();
544        if (Def->IsHostNmOk(OutHostNm)){
545          if (Def->IsFExtOk(OutUrlV[UrlN])){
546            if (HostNm==OutHostNm){
547              Queue->PushQUrlToUrlQBs(OutUrlV[UrlN], Lev+1, Dep+1);
548            } else {
549              Queue->PushQUrlToUrlQBs(OutUrlV[UrlN], 0, Dep+1);
550            }
551          }
552        }
553      }
554    }
555    printf("Fetched [Lev:%d Dep:%d Queue:%d Fetched:%d Time:%d Size:%d]: %s\n",
556     Lev, Dep, Queue->GetQUrls(), UrlDescBs->GetUrls(), FetchMSecs,
557     WebPg->GetHttpResp()->Len(), WebPg->GetUrlStr().CStr());
558    Queue->ResetQUrlBs();
559    Queue->ShuffleUrlQ();
560    ClrZombies();
561    Fetch();
562    if (UrlDescBs->GetUrls()>=Def->GetMxUrls()){
563      TSysMsg::Quit();
564    }
565  }
566  void TCrawlerFetcher::OnError(const int& ConnId, const TStr& MsgStr){
567    DelCrawlerFetcherConn(ConnId);
568    Fetch();
569    printf("Error: %s\n", MsgStr.CStr());
570  }
571  void TCrawlerTimer::OnTimeOut(){
572    PCrawlerDef Def=Crawler->GetDef();
573    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
574    PCrawlerStat Stat=Crawler->GetStat();
575    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
576    uint64 InterEventMSecs=CurEventMSecs-LastEventMSecs;
577    uint64 ToutMSecs=GetTimeOut();
578    double TimerEventPrecision=(ToutMSecs==0) ? 0 : double(InterEventMSecs)/ToutMSecs;
579    if (TimerEventPrecision>1.01){
580      Fetcher->PutCurMxConns(int(Fetcher->GetCurMxConns()*0.90));
581    } else {
582      Fetcher->PutCurMxConns(Fetcher->GetCurMxConns()+1);
583    }
584    if (Fetcher->GetCurMxConns()<Def->GetMnConns()){
585      Fetcher->PutCurMxConns(Def->GetMnConns());}
586    if (Fetcher->GetCurMxConns()>Def->GetMxConns()){
587      Fetcher->PutCurMxConns(Def->GetMxConns());}
588    printf("---------------------------------------------------------------\n"); 
589    printf("*** Crawler-Timer: Timeout-Precision=%.3f CurMxConns=%d\n", 
590     TimerEventPrecision, Fetcher->GetCurMxConns());
591    if (Crawler->GetFetcher()->Empty()&&Crawler->GetQueue()->Empty()){
592      Crawler->GetQueue()->PushQUrlBs();
593      if (Crawler->GetQueue()->Empty()){
594        TSysMsg::Quit();
595      }
596    } else {
597      int QUrls=Crawler->GetQueue()->GetQUrls();
598      int MnQLen=Crawler->GetDef()->GetMnQLen();
599      if ((QUrls%100==0)&&(QUrls<MnQLen)){
600        Crawler->GetQueue()->PushQUrlBs();
601      }
602      Crawler->GetFetcher()->Fetch();
603    }
604    if (Last100SecsEventMSecs==0){
605      Last100SecsEventMSecs=CurEventMSecs;
606    } else 
607    if (CurEventMSecs-Last100SecsEventMSecs>=100000){
608      Stat->On100Secs();
609      Last100SecsEventMSecs=CurEventMSecs;
610    }
611    if (Last1000SecsEventMSecs==0){
612      Last1000SecsEventMSecs=CurEventMSecs;
613    } else 
614    if (CurEventMSecs-Last1000SecsEventMSecs>=1000000){
615      Stat->On1000Secs();
616      Last1000SecsEventMSecs=CurEventMSecs;
617    }
618    LastEventMSecs=CurEventMSecs;
619  }
620  TStr TCrawlerWebSrv::GetUrlStr(const int& RefreshSecs, const TStr& SortOrderNm){
621    TChA UrlChA;
622    UrlChA+='/';
623    UrlChA+='?';
624    UrlChA+=TStr::Fmt("Refresh=%d", RefreshSecs);
625    UrlChA+='&';
626    UrlChA+=TStr::Fmt("Sort=%s", SortOrderNm.CStr());
627    return UrlChA;
628  }
629  TStr TCrawlerWebSrv::GetAnchorStr(const TStr& DescStr, 
630   const int& RefreshSecs, const TStr& SortOrderNm){
631    TChA AnchorChA;
632    TStr UrlStr=GetUrlStr(RefreshSecs, SortOrderNm);
633    AnchorChA+=TStr::Fmt("<a href=\"%s\">", UrlStr.CStr());
634    AnchorChA+=DescStr;
635    AnchorChA+="</a>";
636    return AnchorChA;
637  }
638  void TCrawlerWebSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
639    PCrawlerHostBs HostBs=Crawler->GetHostBs();
640    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
641    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
642    PCrawlerQueue Queue=Crawler->GetQueue();
643    PCrawlerStat Stat=Crawler->GetStat();
644    TStr UrlStr=HttpRq->GetUrl()->GetUrlStr();
645    TStr UrlPathStr=HttpRq->GetUrl()->GetPathStr();
646    PUrlEnv UrlEnv=HttpRq->GetUrlEnv();
647    bool StopCrawlingP=false;
648    if (UrlPathStr=="/Stop"){
649      StopCrawlingP=true;
650      TSysMsg::Quit();
651    }
652    int RefreshSecs=UrlEnv->GetVal("Refresh").GetInt(100);
653    TStr SortOrderNm=UrlEnv->GetVal("Sort");
654    TChA HtmlChA;
655    int ActiveConns; int FetchedUrls; int FetchErrors; int QueueUrls;
656    double TransferBytes; double TransferMSecs; 
657    double AvgHttpRespLen; double AvgTransferBps;
658    HostBs->GetSummaryInfo(ActiveConns, FetchedUrls, FetchErrors, QueueUrls, 
659     TransferBytes, TransferMSecs, AvgHttpRespLen, AvgTransferBps);
660    {HtmlChA+="<html><head><title>Crawling</title>";
661    if ((!StopCrawlingP)&&(RefreshSecs>0)){
662      HtmlChA+=TStr::Fmt("<meta http-equiv=\"refresh\" content=\"%d\">", RefreshSecs);}
663    HtmlChA+="</head><body>";
664    HtmlChA+="<h1>WebBird-Crawler</h1>";
665    HtmlChA+=TSecTm::GetCurTm().GetStr(); HtmlChA+="<br>";
666    HtmlChA+="<form method=get action=\"/Stop\">";
667    HtmlChA+="<input type=submit value=Stop>";
668    HtmlChA+="</form>";
669    HtmlChA+="<form method=get action=\"/\">";
670    HtmlChA+="<input type=submit value=\"Refresh Seconds\">";
671    HtmlChA+=TStr::Fmt("<input type=text name=\"Refresh\" value=\"%d\" size=2>", RefreshSecs);
672    HtmlChA+="</form>";}
673    {HtmlChA+="<h2>General Info</h2>\n";
674    uint64 StartMSecs=TTm::GetMSecsFromTm(Crawler->GetStartTm());
675    uint64 CurMSecs=TTm::GetCurUniMSecs();
676    uint64 CrawlingMSecs=CurMSecs-StartMSecs;
677    double CrawlingSecs=CrawlingMSecs/1000.0;
678    double CrawlingPpsSpeed=CrawlingSecs<=0 ? 0 : FetchedUrls/CrawlingSecs;
679    double AvgPgLen=(FetchedUrls>0)&&(TransferBytes>0) ? TransferBytes/FetchedUrls : 0;
680    HtmlChA+="<table border=1>\n";
681    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Urls Fetched<td align=right>%d</tr>\n", UrlDescBs->GetUrls());
682    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Queue Length<td align=right>%d</tr>\n", Queue->GetQUrls());
683    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Time<td align=right>%.0fs</tr>\n", CrawlingSecs);
684    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed<td align=right>%.3fpps</tr>\n", CrawlingPpsSpeed);
685    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed (last 1000secs)<td align=right>%.3fpps</tr>\n", 
686      Stat->GetLast1000SecsCrawlingSpeed());
687    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed (last 100secs)<td align=right>%.3fpps</tr>\n", 
688      Stat->GetLast100SecsCrawlingSpeed());
689    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Avg. Page Length<td align=right>%sb</tr>\n", 
690     TFlt::GetGigaStr(AvgPgLen).CStr());
691    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Cleaned Zombies<td align=right>%d</tr>\n", Fetcher->GetZombies());
692    HtmlChA+="</table>\n";}
693    {HtmlChA+="<h2>Hosts</h2>\n";
694    HtmlChA+="<table border=1>\n";
695    HtmlChA+=TStr::Fmt("<tr><th>%s (%d)<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s</tr>\n", 
696     GetAnchorStr("Hosts", RefreshSecs, "Host").CStr(),
697     HostBs->GetHosts(),
698     GetAnchorStr("Active", RefreshSecs, "Active").CStr(),
699     GetAnchorStr("Fetched", RefreshSecs, "Fetched").CStr(),
700     GetAnchorStr("Errors", RefreshSecs, "Errors").CStr(),
701     GetAnchorStr("Queue", RefreshSecs, "Queue").CStr(),
702     GetAnchorStr("Bytes", RefreshSecs, "Bytes").CStr(),
703     GetAnchorStr("Time", RefreshSecs, "Time").CStr(),
704     GetAnchorStr("PageLen", RefreshSecs, "PageLen").CStr(),
705     GetAnchorStr("Speed", RefreshSecs, "Speed").CStr());
706    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Summary</b>"
707      "<td align=right><b>%d</b><td align=right><b>%d</b><td align=right><b>%d</b><td align=right><b>%d</b>"
708      "<td align=right><b>%sb</b><td align=right><b>%ss</b><td align=right><b>%sb</b><td align=right><b>%sbps</b></tr>\n",
709     ActiveConns, FetchedUrls, FetchErrors, QueueUrls, 
710     TFlt::GetGigaStr(TransferBytes).CStr(), 
711     TFlt::GetGigaStr(TransferMSecs/1000).CStr(), 
712     TFlt::GetGigaStr(AvgHttpRespLen).CStr(),
713     TFlt::GetGigaStr(AvgTransferBps).CStr());
714    TCrawlerHostV HostV; HostBs->GetSortedHostV(HostV, SortOrderNm);
715    for (int HostN=0; HostN<HostV.Len(); HostN++){
716      PCrawlerHost Host=HostV[HostN];
717      HtmlChA+=TStr::Fmt("<tr><td align=right><a href=\"http:&bsol;&bsol;%s\">%s<a>"
718       "<td align=right>%d<td align=right>%d<td align=right>%d<td align=right>%d"
719       "<td align=right>%sb<td align=right>%ss<td align=right>%sb<td align=right>%sbps</tr>\n",
720       Host->GetHostNm().CStr(), 
721       Host->GetHostNm().CStr(), 
722       Host->GetActiveConns(),
723       Host->GetFetchedUrls(), 
724       Host->GetFetchErrors(), 
725       Host->GetQueueUrls(),
726       TFlt::GetGigaStr(double(Host->GetTransferBytes())).CStr(), 
727       TFlt::GetGigaStr(Host->GetTransferMSecs()/1000).CStr(),
728       TFlt::GetGigaStr(Host->GetAvgHttpRespLen()).CStr(),
729       TFlt::GetGigaStr(Host->GetAvgTransferBps()).CStr()); 
730    }
731    HtmlChA+="</table>";}
732    {HtmlChA+="<h2>Queue Levels</h2>\n";
733    HtmlChA+="<table border=1>\n";
734    int AllQUrls=Queue->GetQUrls();
735    HtmlChA+=TStr::Fmt("<tr><td align=right>%s<td align=right>%d</tr>\n",
736     "All Queue Urls", AllQUrls);
737    HtmlChA+=TStr::Fmt("<tr><td align=right>%s<td align=right>%d</tr>\n",
738      "Unconn Queue Urls", Queue->GetUnconnQUrls());
739    for (int Lev=0; Lev<Queue->GetQLevs(); Lev++){
740      HtmlChA+=TStr::Fmt("<tr><td align=right>Level-%d Urls<td align=right>%d</tr>\n",
741       Lev, Queue->GetQLevUrls(Lev));
742    }
743    HtmlChA+="</table>";}
744    {HtmlChA+="<h2>Queue</h2>\n";
745    TIntStrPrV QUrlsHostPrV; Queue->GetQUrlsHostPrV(QUrlsHostPrV);
746    HtmlChA+="<table border=1>\n";
747    HtmlChA+=TStr::Fmt("<tr><th>#<th>Host<th>Queue-Urls<th>%%</tr>\n");
748    int AllQUrls=Queue->GetQUrls();
749    for (int HostN=0; HostN<QUrlsHostPrV.Len(); HostN++){
750      TStr HostLevNm=QUrlsHostPrV[HostN].Val2;
751      TStr HostNm; TStr LevStr; HostLevNm.SplitOnCh(HostNm, ':', LevStr);
752      int QUrls=QUrlsHostPrV[HostN].Val1;
753      double QUrlsPrc=double(QUrls)/double(AllQUrls);
754      HtmlChA+=TStr::Fmt("<tr><td align=right>%d<td align=right><a href=\"http:&bsol;&bsol;%s/\">%s</a> / %s"
755       "<td align=right>%d<td align=right>%.3f%%</tr>\n",
756       1+HostN, HostNm.CStr(), HostNm.CStr(), LevStr.CStr(), QUrls, 100*QUrlsPrc);
757    }
758    HtmlChA+="</table>";}
759    {TIntStrIntIntQuV ConnIdUrlStrMSecsSizeQuV;
760    Fetcher->GetConnV(ConnIdUrlStrMSecsSizeQuV);
761    int ConnIds=ConnIdUrlStrMSecsSizeQuV.Len();
762    HtmlChA+="<h2>Connections</h2>\n";
763    HtmlChA+="<table border=1>\n";
764    HtmlChA+="<tr><th>#<th>Connection<th>Time<th>Size<th>Url</tr>\n";
765    for (int ConnN=0; ConnN<ConnIds; ConnN++){
766      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
767      TStr UrlStr=ConnIdUrlStrMSecsSizeQuV[ConnN].Val2;
768      int FetchMSecs=ConnIdUrlStrMSecsSizeQuV[ConnN].Val3;
769      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
770      HtmlChA+=TStr::Fmt("<tr><td>%d<td>%d<td>%ss<td>%sb<td><a href=\"%s\">%s</a></tr>\n",
771       1+ConnN, ConnId, 
772       TFlt::GetGigaStr(FetchMSecs/1000).CStr(), TFlt::GetGigaStr(FetchSize).CStr(), 
773       UrlStr.CStr(), UrlStr.CStr());
774    }
775    HtmlChA+="</table>\n";}
776    HtmlChA+="</body></html>";
777    PSIn BodySIn=TMIn::New(HtmlChA);
778    PHttpResp HttpResp=THttpResp::New(
779     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, BodySIn);
780    SendHttpResp(SockId, HttpResp);
781  }
782  TFAccess TCrawlerDocBs::Open(){
783    TFAccess DocBsFAccess=TFRnd::GetFAccessFromStr(DocBsFAccessNm);
784    IAssert((DocBsFAccess==faCreate)||(DocBsFAccess==faUpdate)||(DocBsFAccess==faRestore));
785    DocBBs=TMBlobBs::New(DocBsNrFPath+DocBsNm, DocBsFAccess, DocBsMxSegLen);
786    return DocBsFAccess;
787  }
788  void TCrawlerDocBs::Close(){
789    DocBBs=NULL;
790  }
791  TBlobPt TCrawlerDocBs::AddDoc(const TStr& DocUrlStr, const TMem& DocMem){
792    TMOut SOut(DocUrlStr.Len()+DocMem.Len()+100);
793    TTm::GetCurUniTm().GetWebLogDateTimeStr().Save(SOut);
794    DocUrlStr.Save(SOut);
795    DocMem.Save(SOut);
796    PSIn SIn=SOut.GetSIn();
797    TBlobPt BPt=DocBBs->PutBlob(SIn);
798    return BPt;
799  }
800  bool TCrawlerDocBs::FNextDocBlobPt(TBlobPt& TrvDocBlobPt,
801   TBlobPt& DocBlobPt, TStr& DateTimeStr, TStr& DocUrlStr, TMem& DocMem){
802    PSIn DocBlobSIn;
803    if (DocBBs->FNextBlobPt(TrvDocBlobPt, DocBlobPt, DocBlobSIn)){
804      DateTimeStr=TStr(*DocBlobSIn); 
805      DocUrlStr=TStr(*DocBlobSIn); 
806      DocMem=TMem(*DocBlobSIn); 
807      return true;
808    } else {
809      return false;
810    }
811  }
812  void TCrawlerStat::On100Secs(){
813    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
814    uint64 CurFetchedUrls=Crawler->GetUrlDescBs()->GetUrls();
815    double DiffSecs=(CurEventMSecs-Last100SecsEventMSecs)/double(1000);
816    if (DiffSecs<1){
817      Last100SecsCrawlingSpeed=0;
818    } else {
819      Last100SecsCrawlingSpeed=(CurFetchedUrls-Last100SecsFetchedUrls)/DiffSecs;
820    }
821    Last100SecsEventMSecs=CurEventMSecs;
822    Last100SecsFetchedUrls=CurFetchedUrls;
823  }
824  void TCrawlerStat::On1000Secs(){
825    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
826    uint64 CurFetchedUrls=Crawler->GetUrlDescBs()->GetUrls();
827    double DiffSecs=(CurEventMSecs-Last1000SecsEventMSecs)/double(1000);
828    if (DiffSecs<1){
829      Last1000SecsCrawlingSpeed=0;
830    } else {
831      Last1000SecsCrawlingSpeed=(CurFetchedUrls-Last1000SecsFetchedUrls)/DiffSecs;
832    }
833    Last1000SecsEventMSecs=CurEventMSecs;
834    Last1000SecsFetchedUrls=CurFetchedUrls;
835  }
836  TCrawler::TCrawler():
837    Def(TCrawlerDef::New()),
838    UrlDescBs(), HostBs(), Queue(), Fetcher(), DocBs(), Timer(), WebSrv(),
839    StartTm(TTm::GetCurUniTm()){
840    DocBs=TCrawlerDocBs::New(this);
841  }
842  void TCrawler::DefCrawlBs(const TStr& CrawlBsNm, const TStr& CrawlBsFPath,
843   const TStr& CrawlBsFAccessNm, const int& CrawlBsMxSegLen){
844    PCrawlerDocBs DocBs=GetDocBs();
845    DocBs->PutDocBsNm(CrawlBsNm);
846    DocBs->PutDocBsNrFPath(TStr::GetNrFPath(CrawlBsFPath));
847    DocBs->PutDocBsFAccessNm(CrawlBsFAccessNm);
848    DocBs->PutDocBsMxSegLen(CrawlBsMxSegLen);
849  }
850  void TCrawler::StartCrawling(){
851    UrlDescBs=TCrawlerUrlDescBs::New(this);
852    HostBs=TCrawlerHostBs::New(this);
853    Queue=TCrawlerQueue::New(this);
854    Fetcher=TCrawlerFetcher::New(this);
855    Stat=TCrawlerStat::New(this);
856    TFAccess DocBsFAccess=GetDocBs()->Open();
857    if (DocBsFAccess==faCreate){
858      PCrawlerDef Def=GetDef();
859      int StartUrls=Def->GetStartUrls();
860      for (int UrlN=0; UrlN<StartUrls; UrlN++){
861        Queue->PushQUrl(Def->GetStartUrl(UrlN), 0, 0);}
862    }
863    if (DocBsFAccess==faRestore){
864      printf("Restoring Crawled Documents...\n");
865      TBlobPt TrvDocBlobPt=GetDocBs()->FFirstDocBlobPt();
866      TBlobPt DocBlobPt; TStr DateTimeStr; TStr DocUrlStr; TMem DocMem; int DocN=0;
867      while (GetDocBs()->FNextDocBlobPt(TrvDocBlobPt, DocBlobPt, DateTimeStr, DocUrlStr, DocMem)){
868        DocN++; printf("%d\r", DocN);
869        TMd5Sig DocUrlMd5Sig=TCrawler::GetUrlMd5Sig(DocUrlStr);
870        TMd5Sig DocMemMd5Sig(DocMem);
871        TCrawlerUrlDesc UrlDesc(DocBlobPt, DocMemMd5Sig, TSecTm::GetCurTm(), TUCh(0), TUCh(0));
872        UrlDescBs->AddUrlDesc(DocUrlMd5Sig, UrlDesc);
873      }
874      printf("\nDone.\n");
875    }
876    if (DocBsFAccess==faUpdate){
877      GetUrlDescBs()->Load();
878    }
879    Timer=TCrawlerTimer::New(this, 1000);
880    WebSrv=TCrawlerWebSrv::New(this);
881    Fetcher->Fetch();
882  }
883  void TCrawler::StopCrawling(){
884    WebSrv=NULL;
885    Timer->StopTimer();
886    GetDocBs()->Close();
887    GetUrlDescBs()->Save();
888    GetQueue()->PopSaveQUrlBs();
889  }
890  TMd5Sig TCrawler::GetUrlMd5Sig(const TStr& UrlStr){
891    TStr LcUrlStr=UrlStr.GetLc();
892    return TMd5Sig(LcUrlStr);
893  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</h3>
            <pre><code>1  void TPredicateNode::GetVariables(TStrV& Variables) {
2    if (Left != NULL) { Left->GetVariables(Variables); }
3    if (Right != NULL) { Right->GetVariables(Variables); }
4    if (Op == NOP) {
5      if (Atom.Lvar != "" ) { Variables.Add(Atom.Lvar); }
6      if (Atom.Rvar != "" ) { Variables.Add(Atom.Rvar); }
7    }
8  }
9  void TPredicate::GetVariables(TStrV& Variables) {
10    Root->GetVariables(Variables);
11  }
12  TBool TPredicate::Eval() {
13    TPredicateNode* Curr = Root;
14    TPredicateNode* Prev = NULL;
15    while (!(Curr == NULL && Prev == Root)) {
16      if (Prev == NULL || Prev == Curr->Parent) {
17        if (Curr->Left != NULL) {
18          Prev = Curr;
19          Curr = Curr->Left;
20        } else if (Curr->Right != NULL) {
21          Prev = Curr;
22          Curr = Curr->Right;
23        } else {
24          Curr->Result = EvalAtomicPredicate(Curr->Atom);
25          Prev = Curr;
26          Curr = Curr->Parent;
27        }
28      } else if (Prev == Curr->Left) {
29        switch (Curr->Op) {
30          case NOT: {
31            Assert(Curr->Right == NULL);
32            Curr->Result = !(Prev->Result);
33            Prev = Curr;
34            Curr = Curr->Parent;
35            break;
36          }
37          case AND: {
38            Assert(Curr->Right != NULL);
39            if (!Prev->Result) {
40              Curr->Result = false;
41              Prev = Curr;
42              Curr = Curr->Parent;
43            } else {
44              Prev = Curr;
45              Curr = Curr->Right;
46            }
47            break;
48          }
49          case OR: {
50            Assert(Curr->Right != NULL);
51            if (Prev->Result) {
52              Curr->Result = true;
53              Prev = Curr;
54              Curr = Curr->Parent;
55            } else {
56              Prev = Curr;
57              Curr = Curr->Right;
58            }
59            break;
60          }
61          case NOP: {
62            break;
63          }
64        }
65      } else {
66        Assert(Prev == Curr->Right);
67        switch (Curr->Op) {
68          case NOT: {
69            Assert(Curr->Left == NULL);
70            Curr->Result = !(Prev->Result);
71            break;
72          }
73          case AND: {
74            Assert(Curr->Left != NULL);
75            Assert(Curr->Left->Result);
76            Curr->Result = Prev->Result;
77            break;
78          }
79          case OR: {
80            Assert(Curr->Left != NULL);
81            Assert(!Curr->Left->Result);
82            Curr->Result = Prev->Result;
83            break;
84          }
85          case NOP: {
86            break;
87          }
88        }
89        Prev = Curr;
90        Curr = Curr->Parent;
91      }
92    }
93    return Root->Result;
94  }
95  TBool TPredicate::EvalAtomicPredicate(const TAtomicPredicate& Atom) {
96    switch (Atom.Type) {
97      case atInt: {
98        if (Atom.IsConst) { 
99          return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), Atom.IntConst, Atom.Compare); 
100        }
101        return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), IntVars.GetDat(Atom.Rvar), Atom.Compare);
102      }
103      case atFlt: {
104        if (Atom.IsConst) { 
105          return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), Atom.FltConst, Atom.Compare); 
106        }
107        return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), FltVars.GetDat(Atom.Rvar), Atom.Compare);
108      }
109      case atStr: {
110        if (Atom.IsConst) { 
111          return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), Atom.StrConst, Atom.Compare); 
112        }
113        return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), StrVars.GetDat(Atom.Rvar), Atom.Compare);
114      }
115    }
116    return false;
117  }
118  TInt const TTable::Last = -1;
119  TInt const TTable::Invalid = -2;
120  TInt TTable::UseMP = 1;
121  TRowIterator& TRowIterator::operator++(int) {
122    return this->Next();
123  }
124  TRowIterator& TRowIterator::Next() {
125    CurrRowIdx = Table->Next[CurrRowIdx];
126    return *this;
127  }
128  bool TRowIterator::operator < (const TRowIterator& RowI) const{
129    if (CurrRowIdx == TTable::Last) { return false; }
130    if (RowI.CurrRowIdx == TTable::Last) { return true; }
131    return CurrRowIdx < RowI.CurrRowIdx;
132  }
133  bool TRowIterator::operator == (const TRowIterator& RowI) const {
134    return CurrRowIdx == RowI.CurrRowIdx;
135  }
136  TInt TRowIterator::GetRowIdx() const {
137    return CurrRowIdx;
138  }
139  TInt TRowIterator::GetIntAttr(TInt ColIdx) const {
140    return Table->IntCols[ColIdx][CurrRowIdx];
141  }
142  TFlt TRowIterator::GetFltAttr(TInt ColIdx) const {
143    return Table->FltCols[ColIdx][CurrRowIdx];
144  }
145  TStr TRowIterator::GetStrAttr(TInt ColIdx) const {
146    return Table->GetStrValIdx(ColIdx, CurrRowIdx);
147  }
148  TInt TRowIterator::GetIntAttr(const TStr& Col) const {
149    TInt ColIdx = Table->GetColIdx(Col);
150    return Table->IntCols[ColIdx][CurrRowIdx];
151  }
152  TFlt TRowIterator::GetFltAttr(const TStr& Col) const {
153    TInt ColIdx = Table->GetColIdx(Col);
154    return Table->FltCols[ColIdx][CurrRowIdx];
155  }
156  TStr TRowIterator::GetStrAttr(const TStr& Col) const {
157    return Table->GetStrVal(Col, CurrRowIdx);
158  }
159  TInt TRowIterator::GetStrMapByName(const TStr& Col) const {
160    TInt ColIdx = Table->GetColIdx(Col);
161    return Table->StrColMaps[ColIdx][CurrRowIdx];
162  }
163  TInt TRowIterator::GetStrMapById(TInt ColIdx) const {
164    return Table->StrColMaps[ColIdx][CurrRowIdx];
165  }
166  TBool TRowIterator::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
167    TBool Result;
168    switch (Val.GetType()) {
169      case atInt:
170        Result = TPredicate::EvalAtom(GetIntAttr(ColIdx), Val.GetInt(), Cmp);
171        break;
172      case atFlt:
173        Result = TPredicate::EvalAtom(GetFltAttr(ColIdx), Val.GetFlt(), Cmp);
174        break;
175      case atStr:
176        Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val.GetStr(), Cmp);
177        break;
178      default:
179        Result = TBool(false);
180    }
181    return Result;
182  }
183  TBool TRowIterator::CompareAtomicConstTStr(TInt ColIdx, const TStr& Val, TPredComp Cmp) {
184    TBool Result;
185    Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val, Cmp);
186    return Result;
187  }
188  TRowIteratorWithRemove::TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr) :
189    CurrRowIdx(RowIdx), Table(TablePtr), Start(RowIdx == TablePtr->FirstValidRow) {}
190  TRowIteratorWithRemove& TRowIteratorWithRemove::operator++(int) {
191    return this->Next();
192  }
193  TRowIteratorWithRemove& TRowIteratorWithRemove::Next() {
194    CurrRowIdx = GetNextRowIdx();
195    Start = false;
196    Assert(CurrRowIdx != TTable::Invalid);
197    return *this;
198  }
199  bool TRowIteratorWithRemove::operator < (const TRowIteratorWithRemove& RowI) const {
200    if (CurrRowIdx == TTable::Last) { return false; }
201    if (RowI.CurrRowIdx == TTable::Last) { return true; }
202    return CurrRowIdx < RowI.CurrRowIdx;
203  }
204  bool TRowIteratorWithRemove::operator == (const TRowIteratorWithRemove& RowI) const {
205    return CurrRowIdx == RowI.CurrRowIdx;
206  }
207  TInt TRowIteratorWithRemove::GetRowIdx() const {
208    return CurrRowIdx;
209  }
210  TInt TRowIteratorWithRemove::GetNextRowIdx() const {
211    return (Start ? Table->FirstValidRow : Table->Next[CurrRowIdx]);
212  }
213  TInt TRowIteratorWithRemove::GetNextIntAttr(TInt ColIdx) const {
214    return Table->IntCols[ColIdx][GetNextRowIdx()];
215  }
216  TFlt TRowIteratorWithRemove::GetNextFltAttr(TInt ColIdx) const {
217    return Table->FltCols[ColIdx][GetNextRowIdx()];
218  }
219  TStr TRowIteratorWithRemove::GetNextStrAttr(TInt ColIdx) const {
220    return Table->GetStrValIdx(ColIdx, GetNextRowIdx());
221  }
222  TInt TRowIteratorWithRemove::GetNextIntAttr(const TStr& Col) const {
223    TInt ColIdx = Table->GetColIdx(Col);
224    return Table->IntCols[ColIdx][GetNextRowIdx()];
225  }
226  TFlt TRowIteratorWithRemove::GetNextFltAttr(const TStr& Col) const {
227    TInt ColIdx = Table->GetColIdx(Col);
228    return Table->FltCols[ColIdx][GetNextRowIdx()];
229  }
230  TStr TRowIteratorWithRemove::GetNextStrAttr(const TStr& Col) const {
231    return Table->GetStrVal(Col, GetNextRowIdx());
232  }
233  TBool TRowIteratorWithRemove::IsFirst() const {
234    return CurrRowIdx == Table->FirstValidRow;
235  }
236  void TRowIteratorWithRemove::RemoveNext() {
237    Table->RemoveRow(GetNextRowIdx(), CurrRowIdx);
238  }
239  TBool TRowIteratorWithRemove::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
240    TBool Result;
241    switch (Val.GetType()) {
242      case atInt:
243        Result = TPredicate::EvalAtom(GetNextIntAttr(ColIdx), Val.GetInt(), Cmp);
244        break;
245      case atFlt:
246        Result = TPredicate::EvalAtom(GetNextFltAttr(ColIdx), Val.GetFlt(), Cmp);
247        break;
248      case atStr:
249        Result = TPredicate::EvalStrAtom(GetNextStrAttr(ColIdx), Val.GetStr(), Cmp);
250        break;
251      default:
252        Result = TBool(false);
253    }
254    return Result;
255  }
256  TTable::TTable(): Context(new TTableContext), NumRows(0), NumValidRows(0),
257    FirstValidRow(0), LastValidRow(-1) {}
258  TTable::TTable(TTableContext* Context): Context(Context), NumRows(0),
259    NumValidRows(0), FirstValidRow(0), LastValidRow(-1) {}
260  TTable::TTable(const Schema& TableSchema, TTableContext* Context): Context(Context), 
261    NumRows(0), NumValidRows(0), FirstValidRow(0), LastValidRow(-1), IsNextDirty(0) {
262    TInt IntColCnt = 0;
263    TInt FltColCnt = 0;
264    TInt StrColCnt = 0;
265    for (TInt i = 0; i < TableSchema.Len(); i++) {
266      TStr ColName = TableSchema[i].Val1;
267      TAttrType ColType = TableSchema[i].Val2;
268      AddSchemaCol(ColName, ColType);
269      switch (ColType) {
270        case atInt:
271          AddColType(ColName, atInt, IntColCnt);
272          IntColCnt++;
273          break;
274        case atFlt:
275          AddColType(ColName, atFlt, FltColCnt);
276          FltColCnt++;
277          break;
278        case atStr:
279          AddColType(ColName, atStr, StrColCnt);
280          StrColCnt++;
281          break;
282      }
283    }
284    IntCols = TVec<TIntV>(IntColCnt);
285    FltCols = TVec<TFltV>(FltColCnt);
286    StrColMaps = TVec<TIntV>(StrColCnt);
287  }
288  void TTable::GenerateColTypeMap(THash<TStr,TPair<TInt,TInt> > & ColTypeIntMap) {
289    ColTypeMap.Clr();
290    Sch.Clr();
291    for (THash<TStr,TPair<TInt,TInt> >::TIter it = ColTypeIntMap.BegI(); it < ColTypeIntMap.EndI(); it++) {
292      TPair<TInt,TInt> dat = it.GetDat();
293      switch (dat.GetVal1()) {
294        case 0:
295          AddColType(it.GetKey(), atInt, dat.GetVal2());
296          AddSchemaCol(it.GetKey(), atInt);
297          break;
298        case 1:
299          AddColType(it.GetKey(), atFlt, dat.GetVal2());
300          AddSchemaCol(it.GetKey(), atFlt);
301          break;
302        case 2:
303          AddColType(it.GetKey(), atStr, dat.GetVal2());
304          AddSchemaCol(it.GetKey(), atStr);
305          break;
306      }
307    }
308    IsNextDirty = 0;
309  }
310  void TTable::LoadTableShM(TShMIn& ShMIn, TTableContext* ContextTable) {
311    Context = ContextTable;
312    NumRows = TInt(ShMIn);
313    NumValidRows = TInt(ShMIn);
314    FirstValidRow = TInt(ShMIn);
315    LastValidRow = TInt(ShMIn);
316    Next.LoadShM(ShMIn);
317    TLoadVecInit Fn;
318    IntCols.LoadShM(ShMIn, Fn);
319    FltCols.Load(ShMIn);
320    StrColMaps.LoadShM(ShMIn, Fn);
321    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
322    ColTypeIntMap.LoadShM(ShMIn);
323    GenerateColTypeMap(ColTypeIntMap);
324  }
325  TTable::TTable(TSIn& SIn, TTableContext* Context): Context(Context), NumRows(SIn),
326    NumValidRows(SIn), FirstValidRow(SIn), LastValidRow(SIn), Next(SIn), IntCols(SIn),
327    FltCols(SIn), StrColMaps(SIn) {
328    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap(SIn);
329    GenerateColTypeMap(ColTypeIntMap);
330  }
331  TTable::TTable(const TIntIntH& H, const TStr& Col1, const TStr& Col2,
332   TTableContext* Context, const TBool IsStrKeys) : Context(Context), NumRows(H.Len()),
333    NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
334      TAttrType KeyType = IsStrKeys ? atStr : atInt;
335      AddSchemaCol(Col1, KeyType);
336      AddSchemaCol(Col2, atInt);
337      AddColType(Col1, KeyType, 0);
338      AddColType(Col2, atInt, 1);
339      if (IsStrKeys) {
340        StrColMaps = TVec<TIntV>(1);
341        IntCols = TVec<TIntV>(1);
342        H.GetKeyV(StrColMaps[0]);
343        H.GetDatV(IntCols[0]);
344      } else {
345        IntCols = TVec<TIntV>(2);
346        H.GetKeyV(IntCols[0]);
347        H.GetDatV(IntCols[1]);
348      }
349      Next = TIntV(NumRows);
350      for (TInt i = 0; i < NumRows; i++) {
351        Next[i] = i+1;
352      }
353      Next[NumRows-1] = Last;
354      IsNextDirty = 0;
355      InitIds();
356  }
357  TTable::TTable(const TIntFltH& H, const TStr& Col1, const TStr& Col2,
358   TTableContext* Context, const TBool IsStrKeys) : Context(Context),
359    NumRows(H.Len()), NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
360    TAttrType KeyType = IsStrKeys ? atStr : atInt;
361    AddSchemaCol(Col1, KeyType);
362    AddSchemaCol(Col2, atFlt);
363    AddColType(Col1, KeyType, 0);
364    AddColType(Col2, atFlt, 0);
365    if (IsStrKeys) {
366      StrColMaps = TVec<TIntV>(1);
367      H.GetKeyV(StrColMaps[0]);
368    } else {
369      IntCols = TVec<TIntV>(1);
370      H.GetKeyV(IntCols[0]);
371    }
372    FltCols = TVec<TFltV>(1);
373    H.GetDatV(FltCols[0]);
374    Next = TIntV(NumRows);
375    for (TInt i = 0; i < NumRows; i++) {
376      Next[i] = i+1;
377    }
378    Next[NumRows-1] = Last;
379    IsNextDirty = 0;
380    InitIds();
381  }
382  TTable::TTable(const TTable& Table, const TIntV& RowIDs) : Context(Table.Context),
383    Sch(Table.Sch), SrcCol(Table.SrcCol), DstCol(Table.DstCol), EdgeAttrV(Table.EdgeAttrV),
384    SrcNodeAttrV(Table.SrcNodeAttrV), DstNodeAttrV(Table.DstNodeAttrV),
385    CommonNodeAttrs(Table.CommonNodeAttrs) {
386    ColTypeMap = Table.ColTypeMap;
387    IntCols = TVec<TIntV>(Table.IntCols.Len());
388    FltCols = TVec<TFltV>(Table.FltCols.Len());
389    StrColMaps = TVec<TIntV>(Table.StrColMaps.Len());
390    FirstValidRow = 0;
391    LastValidRow = -1;
392    NumRows = 0;
393    NumValidRows = 0;
394    AddSelectedRows(Table, RowIDs);
395    IsNextDirty = 0;
396    InitIds();
397  }
398  void TTable::GetSchema(const TStr& InFNm, Schema& S, const char& Separator) {
399    TSsParser Ss(InFNm, '\t', false, false, false);
400    TInt rowsToPeek = 1000;
401    TInt currRow = 0;
402    TInt lastComment = 0;
403    while (Ss.Next()) {
404      if (Ss.IsCmt()) {
405        lastComment += 1;
406      }
407      else break;
408    }
409    if (Ss.Eof()) {TExcept::Throw("No Data to determine attribute types!");}
410    TInt numCols = Ss.GetFlds();
411    TVec<TAttrType> colAttrV(numCols);
412    colAttrV.PutAll(atInt);
413    while (true) {
414      for (TInt i = 0; i < numCols; i++) {
415        if (Ss.IsInt(i)) {
416        }
417        else if (Ss.IsFlt(i)) {
418          colAttrV[i] = atFlt;
419        }
420        else {
421          colAttrV[i] = atStr;
422        }
423      }
424      currRow++;
425      if (currRow > rowsToPeek || Ss.Eof()) break;
426      Ss.Next();
427    }
428    TSsParser SsNames(InFNm, Separator, false, false, false);
429    for (int i = 0; i < lastComment; i++) { SsNames.Next();}
430    TVec<TStr> attrV;
431    TStr first(SsNames[0]);
432    int begin = 0;
433    TStr comment('#');
434    if (first != comment) {
435      for (int i = 1; i < first.Len(); i++){
436        if (first[i] != ' ') { begin = i; break;}
437      }
438      attrV.Add(first.GetSubStr(begin));
439    }
440    for (int i = 1; i < SsNames.GetFlds(); i++) {attrV.Add(SsNames[i]);}
441    for (TInt i = 0; i < numCols; i++) {
442      S.Add(TPair<TStr,TAttrType>(attrV[i],colAttrV[i]));
443    } 
444  }
445  #ifdef GCC_ATOMIC
446  void TTable::LoadSSPar(PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols, 
447                          const char& Separator, TBool HasTitleLine) {
448    TInt RowLen = T->Sch.Len();
449    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
450    for (TInt i = 0; i < RowLen; i++) {
451      ColTypes[i] = T->GetSchemaColType(i);
452    }
453    TSsParserMP Ss(InFNm, Separator);
454    Ss.SkipCommentLines();
455    if (HasTitleLine) {
456      Ss.Next();
457      if (S.Len() != Ss.GetFlds()) {
458        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
459      }
460      for (TInt i = 0; i < Ss.GetFlds(); i++) {
461        TInt L = strlen(Ss[i]);
462        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
463        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
464      }
465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
469    uint64 Rem = Len - Pos;
470    int NumThreads = omp_get_max_threads();
471    uint64 Delta = Rem / NumThreads;
472    if (Delta < 1) Delta = 1;
473    TVec<uint64> StartIntV(NumThreads);
474    TVec<uint64> LineCountV(NumThreads);
475    TVec<uint64> PrefixSumV(NumThreads);
476    StartIntV[0] = Pos;
477    for (int i = 1; i < NumThreads; i++) {
478      StartIntV[i] = StartIntV[i-1] + Delta;
479    }
480    StartIntV.Add(Len);
481    omp_set_num_threads(NumThreads);
482    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
483    for (int i = 0; i < NumThreads; i++) {
484      LineCountV[i] = Ss.CountNewLinesInRange(StartIntV[i], StartIntV[i+1]);
485      Cnt += LineCountV[i];
486    }
487    PrefixSumV[0] = 0;
488    for (int i = 1; i < NumThreads; i++) {
489      PrefixSumV[i] = PrefixSumV[i-1] + LineCountV[i-1];
490    }
491    Ss.SetStreamPos(Pos);
492    TInt IntColIdx = 0;
493    TInt FltColIdx = 0;
494    for (TInt i = 0; i < RowLen; i++) {
495      switch (ColTypes[i]) {
496        case atInt:
497          T->IntCols[IntColIdx].Gen(Cnt);
498          IntColIdx++;
499          break;
500        case atFlt:
501          T->FltCols[FltColIdx].Gen(Cnt);
502          FltColIdx++;
503          break;
504        case atStr:
505          break;
506      }
507    }
508    Cnt = 0;
509    omp_set_num_threads(NumThreads);
510    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
511    for (int i = 0; i < NumThreads; i++) {
512      TVec<uint64> LineStartPosV = Ss.GetStartPosV(StartIntV[i], StartIntV[i+1]);
513      for (uint64 k = 0; k < (uint64) LineStartPosV.Len(); k++) {
514        TVec<char*> FieldsV;
515        Ss.NextFromIndex(LineStartPosV[k], FieldsV);
516        if (FieldsV.Len() != S.Len()) {
517          TExcept::Throw("Error reading tsv file");
518        }
519        TInt IntColIdx = 0;
520        TInt FltColIdx = 0;
521        TInt RowIdx = PrefixSumV[i] + k;
522        for (TInt j = 0; j < RowLen; j++) {
523          switch (ColTypes[j]) {
524            case atInt:
525              if (RelevantCols.Len() == 0) {
526                T->IntCols[IntColIdx][RowIdx] = \
527                  (Ss.GetIntFromFldV(FieldsV, j));
528              } else {
529                T->IntCols[IntColIdx][RowIdx] = \
530                  (Ss.GetIntFromFldV(FieldsV, RelevantCols[j]));
531              }
532              IntColIdx++;
533              break;
534            case atFlt:
535              if (RelevantCols.Len() == 0) {
536                T->FltCols[FltColIdx][RowIdx] = \
537                  (Ss.GetFltFromFldV(FieldsV, j));
538              } else {
539                T->FltCols[FltColIdx][RowIdx] = \
540                  (Ss.GetFltFromFldV(FieldsV, RelevantCols[j]));
541              }
542              FltColIdx++;
543              break;
544            case atStr:
545              TExcept::Throw("TTable::LoadSS:: Str Col found\n");
546              break;
547          }
548        }
549        Cnt++;
550      }
551    }
552    T->NumRows = Cnt;
553    T->NumValidRows = T->NumRows;
554    T->Next.Clr();
555    T->Next.Gen(Cnt);
556    omp_set_num_threads(NumThreads);
557    #pragma omp parallel for schedule(dynamic, 10000)
558    for (int64 i = 0; i < Cnt-1; i++) {
559      T->Next[i] = i+1;
560    }
561    T->IsNextDirty = 0;
562    T->Next[Cnt-1] = Last;
563    T->LastValidRow = T->NumRows - 1;
564    T->IdColName = "_id";
565    TInt IdCol = T->IntCols.Add();
566    T->IntCols[IdCol].Gen(Cnt);
567    omp_set_num_threads(NumThreads);
568    #pragma omp parallel for schedule(dynamic, 10000)
569    for (int64 i = 0; i < Cnt; i++) {
570      T->IntCols[IdCol][i] = i;
571    }
572    T->AddSchemaCol(T->IdColName, atInt);
573    T->AddColType(T->IdColName, atInt, T->IntCols.Len()-1);
574  }
575  #endif 
576  void TTable::LoadSSSeq(
577   PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols,
578   const char& Separator, TBool HasTitleLine) {
579    int RowLen = T->Sch.Len();
580    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
581    for (int i = 0; i < RowLen; i++) {
582      ColTypes[i] = T->GetSchemaColType(i);
583    }
584    TSsParser Ss(InFNm, Separator);
585    if (HasTitleLine) {
586      Ss.Next();
587      if (S.Len() != Ss.GetFlds()) {
588        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
589      }
590      for (int i = 0; i < Ss.GetFlds(); i++) {
591        int L = strlen(Ss[i]);
592        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
593        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
594      }
595    }
596    uint64 Cnt = 0;
597    while (Ss.Next()) {
598      int IntColIdx = 0;
599      int FltColIdx = 0;
600      int StrColIdx = 0;
601      Assert(Ss.GetFlds() == S.Len()); 
602      if (Ss.GetFlds() != S.Len()) {
603        printf("%s\n", Ss[S.Len()]); TExcept::Throw("Error reading tsv file");
604      }
605      for (int i = 0; i < RowLen; i++) {
606        switch (ColTypes[i]) {
607          case atInt:
608            if (RelevantCols.Len() == 0) {
609              T->IntCols[IntColIdx].Add(Ss.GetInt(i));
610            } else {
611              T->IntCols[IntColIdx].Add(Ss.GetInt(RelevantCols[i]));
612            }
613            IntColIdx++;
614            break;
615          case atFlt:
616            if (RelevantCols.Len() == 0) {
617              T->FltCols[FltColIdx].Add(Ss.GetFlt(i));
618            } else {
619              T->FltCols[FltColIdx].Add(Ss.GetFlt(RelevantCols[i]));
620            }
621            FltColIdx++;
622            break;
623          case atStr:
624            int ColIdx;
625            if (RelevantCols.Len() == 0) {
626              ColIdx = i;
627            } else {
628              ColIdx = RelevantCols[i];
629            }
630            TStr Sval = TStr(Ss[ColIdx]);
631            T->AddStrVal(StrColIdx, Sval);
632            StrColIdx++;
633            break;
634        }
635      }
636      Cnt += 1;
637    }
638    T->NumRows = static_cast<int>(Cnt);
639    T->NumValidRows = T->NumRows;
640    T->Next.Clr();
641    T->Next.Gen(static_cast<int>(Cnt));
642    for (uint64 i = 0; i < Cnt-1; i++) {
643      T->Next[static_cast<int>(i)] = static_cast<int>(i+1);
644    }
645    T->IsNextDirty = 0;
646    T->Next[static_cast<int>(Cnt-1)] = Last;
647    T->LastValidRow = T->NumRows - 1;
648    T->InitIds();
649  }
650  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
651   const TIntV& RelevantCols, const char& Separator, TBool HasTitleLine) {
652    TVec<uint64> IntGroupByCols;
653    bool NoStringCols = true;
654    Schema SR;
655    if (RelevantCols.Len() == 0) {
656      SR = S;
657    } else {
658      for (int i = 0; i < RelevantCols.Len(); i++) {
659        SR.Add(S[RelevantCols[i]]);
660      }
661    }
662    PTable T = New(SR, Context);
663    for (int i = 0; i < SR.Len(); i++) {
664      if (T->GetSchemaColType(i) == atStr) {
665        NoStringCols = false;
666        break;
667      }
668    }
669    if (GetMP() && NoStringCols) {
670  #ifdef GLib_LINUX
671      LoadSSPar(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
672  #else
673      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
674  #endif
675    } else {
676      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
677    }
678    return T;
679  }
680  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
681   const char& Separator, TBool HasTitleLine) {
682    return LoadSS(S, InFNm, Context, TIntV(), Separator, HasTitleLine);
683  }
684  void TTable::SaveSS(const TStr& OutFNm) {
685    if (NumValidRows == 0) {
686      printf("Table is empty");
687      return;
688    }
689    FILE* F = fopen(OutFNm.CStr(), "w");
690    if (F == NULL) {
691      printf("failed to open file %s\n", OutFNm.CStr());
692      perror("fail ");
693      return;
694    }
695    Dump(F);
696  #if 0
697    Schema DSch = DenormalizeSchema();
698    TInt L = Sch.Len();
699    fprintf(F, "# ");
700    for (TInt i = 0; i < L-1; i++) {
701      fprintf(F, "%s\t", DSch[i].Val1.CStr());
702    }  
703    fprintf(F, "%s\n", DSch[L-1].Val1.CStr());
704    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
705      for (TInt i = 0; i < L; i++) {
706        char C = (i == L-1) ? '\n' : '\t';
707        switch (GetSchemaColType(i)) {
708          case atInt: {
709            fprintf(F, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
710            break;
711          }
712          case atFlt: {
713            fprintf(F, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
714            break;
715          }
716          case atStr: {
717            fprintf(F, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
718            break;
719          }
720        }
721      }
722    }
723  #endif
724    fclose(F);
725  }
726  void TTable::SaveBin(const TStr& OutFNm) {
727    TFOut SOut(OutFNm);
728    Save(SOut);
729  }
730  void TTable::Save(TSOut& SOut) {
731    NumRows.Save(SOut);
732    NumValidRows.Save(SOut);
733    FirstValidRow.Save(SOut);
734    LastValidRow.Save(SOut);
735    Next.Save(SOut);
736    IntCols.Save(SOut);
737    FltCols.Save(SOut);
738    StrColMaps.Save(SOut);
739    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
740    TInt atIntVal = TInt(0);
741    TInt atFltVal = TInt(1);
742    TInt atStrVal = TInt(2);
743    for (THash<TStr,TPair<TAttrType,TInt> >::TIter it = ColTypeMap.BegI(); it < ColTypeMap.EndI(); it++) {
744      TPair<TAttrType,TInt> dat = it.GetDat();
745      TStr DColName = DenormalizeColName(it.GetKey());
746      switch (dat.GetVal1()) {
747        case atInt:
748          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atIntVal, dat.GetVal2()));
749          break;
750        case atFlt:
751          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atFltVal, dat.GetVal2()));
752          break;
753        case atStr:
754          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atStrVal, dat.GetVal2()));
755          break;
756      }
757    }
758    ColTypeIntMap.Save(SOut);
759    SOut.Flush();
760  }
761  void TTable::Dump(FILE *OutF) const {
762    TInt L = Sch.Len();
763    Schema DSch = DenormalizeSchema();
764    fprintf(OutF, "# ");
765    for (TInt i = 0; i < L-1; i++) {
766      fprintf(OutF, "%s\t", DSch[i].Val1.CStr());
767    }  
768    fprintf(OutF, "%s\n", DSch[L-1].Val1.CStr());
769    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
770      for (TInt i = 0; i < L; i++) {
771        char C = (i == L-1) ? '\n' : '\t';
772        switch (GetSchemaColType(i)) {
773          case atInt: {
774            fprintf(OutF, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
775            break;
776          }
777          case atFlt: {
778            fprintf(OutF, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
779            break;
780          }
781          case atStr: {
782            fprintf(OutF, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
783            break;
784          }
785        }
786      }
787    }
788  }
789  TTableContext* TTable::ChangeContext(TTableContext* NewContext) {
790    TInt L = Sch.Len();
791  #if 0
792    for (TInt i = 0; i < L; i++) {
793      if (GetSchemaColType(i) != atStr) {
794        continue;
795      }
796      TInt ColIdx = GetColIdx(GetSchemaColName(i));
797      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
798        TInt RowIdx = RowI.GetRowIdx();
799        TInt KeyId = StrColMaps[ColIdx][RowIdx];
800        printf("ChangeContext in  %d  %d  %d  .%s.\n",
801            ColIdx.Val, RowIdx.Val, KeyId.Val, GetStrVal(ColIdx, RowIdx).CStr());
802      }
803    }
804  #endif
805    for (TInt i = 0; i < L; i++) {
806      if (GetSchemaColType(i) != atStr) {
807        continue;
808      }
809      TInt ColIdx = GetColIdx(GetSchemaColName(i));
810      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
811        TInt RowIdx = RowI.GetRowIdx();
812        TStr Key = GetStrValIdx(ColIdx, RowIdx);
813        TInt KeyId = TInt(NewContext->StringVals.AddKey(Key));
814        StrColMaps[ColIdx][RowIdx] = KeyId;
815      }
816    }
817    Context = NewContext;
818    return Context;
819  }
820  void TTable::AddStrVal(const TInt& ColIdx, const TStr& Key) {
821    TInt KeyId = TInt(Context->StringVals.AddKey(Key));
822    StrColMaps[ColIdx].Add(KeyId);
823  }
824  void TTable::AddStrVal(const TStr& Col, const TStr& Key) {
825    if (GetColType(Col) != atStr) {
826      TExcept::Throw(Col + " is not a string valued column");
827    }
828    AddStrVal(GetColIdx(Col), Key);
829  }
830  void TTable::AddGraphAttribute(const TStr& Attr, TBool IsEdge, TBool IsSrc, TBool IsDst) {
831    if (!IsColName(Attr)) { TExcept::Throw(Attr + ": No such column"); }
832    if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attr)); }
833    if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attr)); }
834    if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attr)); }
835  }
836  void TTable::AddGraphAttributeV(TStrV& Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst) {
837    for (TInt i = 0; i < Attrs.Len(); i++) {
838      if (!IsColName(Attrs[i])) {
839        TExcept::Throw(Attrs[i] + ": no such column");
840      }
841    }
842    for (TInt i = 0; i < Attrs.Len(); i++) {
843      if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attrs[i])); }
844      if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attrs[i])); }
845      if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attrs[i])); }
846    }
847  }
848  TStrV TTable::GetSrcNodeIntAttrV() const {
849    TStrV IntNA = TStrV(IntCols.Len(),0);
850    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
851      TStr Attr = SrcNodeAttrV[i];
852      if (GetColType(Attr) == atInt) {
853        IntNA.Add(Attr);
854      }
855    }
856    return IntNA;
857  }
858  TStrV TTable::GetDstNodeIntAttrV() const {
859    TStrV IntNA = TStrV(IntCols.Len(),0);
860    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
861      TStr Attr = DstNodeAttrV[i];
862      if (GetColType(Attr) == atInt) {
863        IntNA.Add(Attr);
864      }
865    }
866    return IntNA;
867  }
868  TStrV TTable::GetEdgeIntAttrV() const {
869    TStrV IntEA = TStrV(IntCols.Len(),0);
870    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
871      TStr Attr = EdgeAttrV[i];
872      if (GetColType(Attr) == atInt) {
873        IntEA.Add(Attr);
874      }
875    }
876    return IntEA;
877  }
878  TStrV TTable::GetSrcNodeFltAttrV() const {
879    TStrV FltNA = TStrV(FltCols.Len(),0);
880    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
881      TStr Attr = SrcNodeAttrV[i];
882      if (GetColType(Attr) == atFlt) {
883        FltNA.Add(Attr);
884      }
885    }
886    return FltNA;
887  }
888  TStrV TTable::GetDstNodeFltAttrV() const {
889    TStrV FltNA = TStrV(FltCols.Len(),0);
890    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
891      TStr Attr = DstNodeAttrV[i];
892      if (GetColType(Attr) == atFlt) {
893        FltNA.Add(Attr);
894      }
895    }
896    return FltNA;
897  }
898  TStrV TTable::GetEdgeFltAttrV() const {
899    TStrV FltEA = TStrV(FltCols.Len(),0);;
900    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
901      TStr Attr = EdgeAttrV[i];
902      if (GetColType(Attr) == atFlt) {
903        FltEA.Add(Attr);
904      }
905    }
906    return FltEA;
907  }
908  TStrV TTable::GetSrcNodeStrAttrV() const {
909    TStrV StrNA = TStrV(StrColMaps.Len(),0);
910    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
911      TStr Attr = SrcNodeAttrV[i];
912      if (GetColType(Attr) == atStr) {
913        StrNA.Add(Attr);
914      }
915    }
916    return StrNA;
917  }
918  TStrV TTable::GetDstNodeStrAttrV() const {
919    TStrV StrNA = TStrV(StrColMaps.Len(),0);
920    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
921      TStr Attr = DstNodeAttrV[i];
922      if (GetColType(Attr) == atStr) {
923        StrNA.Add(Attr);
924      }
925    }
926    return StrNA;
927  }
928  TStrV TTable::GetEdgeStrAttrV() const {
929    TStrV StrEA = TStrV(StrColMaps.Len(),0);
930    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
931      TStr Attr = EdgeAttrV[i];
932      if (GetColType(Attr) == atStr) {
933        StrEA.Add(Attr);
934      }
935    }
936    return StrEA;
937  }
938  void TTable::Rename(const TStr& column, const TStr& NewLabel) {
939    if (!IsColName(column)) { TExcept::Throw("no such column " + column); }
940    TPair<TAttrType,TInt> ColVal = GetColTypeMap(column);
941    DelColType(column);
942    AddColType(NewLabel, ColVal);
943    TStr NColName = NormalizeColName(column);
944    TStr NLabel = NormalizeColName(NewLabel);
945    for (TInt c = 0; c < Sch.Len(); c++) {
946      if (Sch[c].Val1 == NColName) {
947        Sch.SetVal(c, TPair<TStr, TAttrType>(NLabel, Sch[c].Val2));
948        break;
949      }
950    }
951  }
952  void TTable::RemoveFirstRow() {
953    if (FirstValidRow == LastValidRow) {
954      LastValidRow = -1;
955    }
956    TInt Old = FirstValidRow;
957    FirstValidRow = Next[FirstValidRow];
958    Next[Old] = TTable::Invalid;
959    NumValidRows--;
960    TInt IdColIdx = GetColIdx(GetIdColName());
961    RowIdMap.AddDat(IntCols[IdColIdx][Old], Invalid);
962  }
963  void TTable::RemoveRow(TInt RowIdx, TInt PrevRowIdx) {
964    if (RowIdx == FirstValidRow) {
965      RemoveFirstRow();
966      return;
967    }
968    Assert(RowIdx != TTable::Invalid);
969    if (RowIdx == TTable::Last) { return; }
970    Next[PrevRowIdx] = Next[RowIdx];
971    if (LastValidRow == RowIdx) {
972      LastValidRow = RowIdx;
973    }
974    Next[RowIdx] = TTable::Invalid;
975    NumValidRows--;
976    TInt IdColIdx = GetColIdx(GetIdColName());
977    RowIdMap.AddDat(IntCols[IdColIdx][RowIdx], Invalid);
978  }
979  void TTable::KeepSortedRows(const TIntV& KeepV) {
980    TIntIntH KeepH(KeepV.Len());
981    for (TInt i = 0; i < KeepV.Len(); i++) {
982      KeepH.AddKey(KeepV[i]);
983    }
984    TRowIteratorWithRemove RowI = BegRIWR();
985    TInt KeepSize = 0;
986    while (RowI.GetNextRowIdx() != Last) {
987      if (KeepSize < KeepV.Len()) {
988        if (KeepH.IsKey(RowI.GetNextRowIdx())) {
989          KeepSize++;
990          RowI++;
991        } else {
992          RowI.RemoveNext();
993        }
994      } else {
995        RowI.RemoveNext();
996      }
997    }
998    LastValidRow = KeepV[KeepV.Len()-1];
999  }
1000  void TTable::GetPartitionRanges(TIntPrV& Partitions, TInt NumPartitions) const {
1001    TInt PartitionSize = NumValidRows / (NumPartitions);
1002    if (NumValidRows % NumPartitions != 0) PartitionSize++;
1003    if (PartitionSize < 10) { 
1004      PartitionSize = 10;
1005      NumPartitions = NumValidRows / PartitionSize; 
1006    }
1007    Partitions.Reserve(NumPartitions+1);
1008    TInt currRow = FirstValidRow;
1009    TInt currStart = currRow;
1010    if (IsNextDirty) {
1011      TInt currCount = PartitionSize;
1012      while (currRow != TTable::Last) {
1013        if (currCount == 0) {
1014          Partitions.Add(TIntPr(currStart, currRow));
1015          currStart = currRow;
1016          currCount = PartitionSize;
1017        }
1018        currRow = Next[currRow];
1019        currCount--;
1020      }
1021      Partitions.Add(TIntPr(currStart, currRow));
1022    } else {
1023      currRow += PartitionSize;
1024      while (currRow != TTable::Last && currRow < Next.Len()) {
1025        if (Next[currRow] == TTable::Invalid) { currRow++; continue; }
1026        Partitions.Add(TIntPr(currStart, currRow));
1027        currStart = currRow;
1028        currRow += PartitionSize;
1029      }
1030      Partitions.Add(TIntPr(currStart, TTable::Last));
1031    }
1032  }
1033  void TTable::GroupingSanityCheck(const TStr& GroupBy, const TAttrType& AttrType) const {
1034    if (!IsColName(GroupBy)) {
1035      TExcept::Throw("no such column " + GroupBy);
1036    }
1037    if (GetColType(GroupBy) != AttrType) {
1038      TExcept::Throw(GroupBy + " values are not of expected type");
1039    }
1040  }
1041  #ifdef GCC_ATOMIC
1042  void TTable::GroupByIntColMP(const TStr& GroupBy, THashMP<TInt, TIntV>& Grouping, TBool UsePhysicalIds) const {
1043    timeval timer0;
1044    gettimeofday(&timer0, NULL);
1045    TInt IdColIdx = GetColIdx(IdColName);
1046    TInt GroupByColIdx = GetColIdx(GroupBy);
1047    if(!UsePhysicalIds && IdColIdx < 0){
1048    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1049    }
1050    GroupingSanityCheck(GroupBy, atInt);
1051    TIntPrV Partitions;
1052    GetPartitionRanges(Partitions, 8*CHUNKS_PER_THREAD);
1053    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1054    Grouping.Gen(NumValidRows);
1055    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1056    for (int i = 0; i < Partitions.Len(); i++){
1057      TRowIterator RowI(Partitions[i].GetVal1(), this);
1058      TRowIterator EndI(Partitions[i].GetVal2(), this);
1059      while (RowI < EndI) {
1060        TInt idx = UsePhysicalIds ? RowI.GetRowIdx() : RowI.GetIntAttr(IdColIdx);
1061        UpdateGrouping<TInt>(Grouping, RowI.GetIntAttr(GroupByColIdx), idx);
1062        RowI++;
1063      }
1064    }
1065    gettimeofday(&timer0, NULL);
1066  }
1067  #endif 
1068  void TTable::Unique(const TStr& Col) {
1069    TIntV RemainingRows;
1070    TStr NCol = NormalizeColName(Col);
1071    switch (GetColType(NCol)) {
1072      case atInt: {
1073        TIntIntVH Grouping;
1074        GroupByIntCol(NCol, Grouping, TIntV(), true, true);
1075        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1076          RemainingRows.Add(it->Dat[0]);
1077        }
1078        break;
1079      }
1080      case atFlt: {
1081        THash<TFlt,TIntV> Grouping;
1082        GroupByFltCol(NCol, Grouping, TIntV(), true, true);
1083        for (THash<TFlt,TIntV>::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1084          RemainingRows.Add(it->Dat[0]);
1085        }
1086        break;
1087      } 
1088      case atStr: {
1089        TIntIntVH Grouping;
1090        GroupByStrCol(NCol, Grouping, TIntV(), true, true);
1091        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1092          RemainingRows.Add(it->Dat[0]);
1093        }
1094        break;
1095      }
1096    }
1097    KeepSortedRows(RemainingRows);
1098  }
1099  void TTable::Unique(const TStrV& Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
1105    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1106    TIntV UniqueVec;
1107    GroupAux(NCols, Grouping, Ordered, "", true, UniqueVec, true);
1108    KeepSortedRows(UniqueVec);
1109  }
1110  void TTable::StoreGroupCol(const TStr& GroupColName, const TVec<TPair<TInt, TInt> >& GroupAndRowIds) {
1111    IntCols.Add(TIntV(NumRows));
1112    TInt L = IntCols.Len();
1113    AddColType(GroupColName, atInt, L-1);
1114    for (TInt i = 0; i < GroupAndRowIds.Len(); i++) {
1115      IntCols[L-1][GroupAndRowIds[i].Val2] = GroupAndRowIds[i].Val1;
1116    }
1117  }
1118  void TTable::GroupAux(const TStrV& GroupBy, THash<TGroupKey, TPair<TInt, TIntV> >& Grouping, 
1119   TBool Ordered, const TStr& GroupColName, TBool KeepUnique, TIntV& UniqueVec, TBool UsePhysicalIds) {
1120    TInt IdColIdx = GetColIdx(IdColName);
1121    if(!UsePhysicalIds && IdColIdx < 0){
1122    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1123    }
1124    TIntV IntGroupByCols;
1125    TIntV FltGroupByCols;
1126    TIntV StrGroupByCols;
1127    for (TInt c = 0; c < GroupBy.Len(); c++) {
1128      if (!IsColName(GroupBy[c])) { 
1129        TExcept::Throw("no such column " + GroupBy[c]); 
1130      }
1131      TPair<TAttrType, TInt> ColType = GetColTypeMap(GroupBy[c]);
1132      switch (ColType.Val1) {
1133        case atInt:
1134          IntGroupByCols.Add(ColType.Val2);
1135          break;
1136        case atFlt:
1137          FltGroupByCols.Add(ColType.Val2);
1138          break;
1139        case atStr:
1140          StrGroupByCols.Add(ColType.Val2);
1141          break;
1142      }
1143    }
1144    TInt IKLen = IntGroupByCols.Len();
1145    TInt FKLen = FltGroupByCols.Len();
1146    TInt SKLen = StrGroupByCols.Len();
1147    TInt GroupNum = 0;
1148    TVec<TPair<TInt, TInt> > GroupAndRowIds;
1149    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
1150      TIntV IKey(IKLen + SKLen, 0);
1151      TFltV FKey(FKLen, 0);
1152      TIntV SKey(SKLen, 0);
1153      for (TInt c = 0; c < IKLen; c++) {
1154        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
1155      }
1156      for (TInt c = 0; c < FKLen; c++) {
1157        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
1158      }
1159      for (TInt c = 0; c < SKLen; c++) {
1160        SKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
1161      }
1162      if (!Ordered) {
1163        if (IKLen > 0) { IKey.ISort(0, IKey.Len()-1, true); }
1164        if (FKLen > 0) { FKey.ISort(0, FKey.Len()-1, true); }
1165        if (SKLen > 0) { SKey.ISort(0, SKey.Len()-1, true); }
1166      }
1167      for (TInt c = 0; c < SKLen; c++) {
1168        IKey.Add(SKey[c]);
1169      }
1170      TGroupKey GroupKey = TGroupKey(IKey, FKey);
1171      TInt RowIdx = it.GetRowIdx();
1172      TInt idx = UsePhysicalIds ? it.GetRowIdx() : IntCols[IdColIdx][it.GetRowIdx()];
1173      if (!Grouping.IsKey(GroupKey)) {
1174        TPair<TInt, TIntV> NewGroup;
1175        NewGroup.Val1 = GroupNum;
1176        NewGroup.Val2.Add(idx);
1177        Grouping.AddDat(GroupKey, NewGroup);
1178        if (GroupColName != "") {
1179          GroupAndRowIds.Add(TPair<TInt, TInt>(GroupNum, RowIdx));
1180        }
1181        if (KeepUnique) { 
1182          UniqueVec.Add(idx);
1183        }
1184        GroupNum++;
1185      } else {
1186        if (!KeepUnique) {
1187          TPair<TInt, TIntV>& NewGroup = Grouping.GetDat(GroupKey);
1188          NewGroup.Val2.Add(idx);
1189          if (GroupColName != "") {
1190            GroupAndRowIds.Add(TPair<TInt, TInt>(NewGroup.Val1, RowIdx));
1191          }
1192        }
1193      }
1194    }
1195    if (!KeepUnique) {
1196      GroupStmt Stmt(NormalizeColNameV(GroupBy), Ordered, UsePhysicalIds);
1197      GroupStmtNames.AddDat(GroupColName, Stmt);
1198      GroupIDMapping.AddKey(Stmt);
1199      GroupMapping.AddKey(Stmt);
1200      for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1201        TGroupKey key = it.GetKey();
1202        TPair<TInt, TIntV> group = it.GetDat();
1203        GroupIDMapping.GetDat(Stmt).AddDat(group.Val1, TGroupKey(key));
1204        GroupMapping.GetDat(Stmt).AddDat(TGroupKey(key), TIntV(group.Val2));
1205      }
1206    }
1207    if (GroupColName != "") {
1208      StoreGroupCol(GroupColName, GroupAndRowIds);
1209      AddSchemaCol(GroupColName, atInt);  
1210    }
1211  }
1212  void TTable::Group(const TStrV& GroupBy, const TStr& GroupColName, TBool Ordered, TBool UsePhysicalIds) {
1213    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1214    TStr NGroupColName = NormalizeColName(GroupColName);
1215    TIntV UniqueVec;
1216    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1217    GroupAux(NGroupBy, Grouping, Ordered, NGroupColName, false, UniqueVec, UsePhysicalIds);
1218  }
1219  void TTable::InvalidatePhysicalGroupings(){
1220  }
1221  void TTable::InvalidateAffectedGroupings(const TStr& Attr){
1222  }
1223  void TTable::Aggregate(const TStrV& GroupByAttrs, TAttrAggr AggOp,
1224   const TStr& ValAttr, const TStr& ResAttr, TBool Ordered) {
1225     for (TInt c = 0; c < GroupByAttrs.Len(); c++) {
1226      if (!IsColName(GroupByAttrs[c])) { 
1227        TExcept::Throw("no such column " + GroupByAttrs[c]); 
1228      }
1229     }
1230    TStrV NGroupByAttrs = NormalizeColNameV(GroupByAttrs);
1231    TBool UsePhysicalIds = (GetColIdx(IdColName) < 0);
1232    THash<TInt,TIntV> GroupByIntMapping;
1233    THash<TFlt,TIntV> GroupByFltMapping;
1234    THash<TInt,TIntV> GroupByStrMapping;
1235    THash<TGroupKey,TIntV> Mapping;
1236  #ifdef GCC_ATOMIC
1237    THashMP<TInt,TIntV> GroupByIntMapping_MP(NumValidRows);
1238    TIntV GroupByIntMPKeys(NumValidRows);
1239  #endif
1240    TInt NumOfGroups = 0;
1241    TInt GroupingCase = 0;
1242    GroupStmt Stmt(NGroupByAttrs, Ordered, UsePhysicalIds);
1243    if (GroupMapping.IsKey(Stmt)) {
1244      Mapping = GroupMapping.GetDat(Stmt);
1245    } else{
1246    	if(NGroupByAttrs.Len() == 1){
1247    		switch(GetColType(NGroupByAttrs[0])){
1248    			case atInt:
1249  #ifdef GCC_ATOMIC
1250    				if(GetMP()){
1251    					GroupByIntColMP(NGroupByAttrs[0], GroupByIntMapping_MP, UsePhysicalIds);
1252    					int x = 0;
1253  					for(THashMP<TInt,TIntV>::TIter it = GroupByIntMapping_MP.BegI(); it < GroupByIntMapping_MP.EndI(); it++){
1254  						GroupByIntMPKeys[x] = it.GetKey();
1255  						x++;
1256  					}
1257    					NumOfGroups = x;
1258    					GroupingCase = 4;
1259    					break;
1260    				}
1261  #endif 
1262    				GroupByIntCol(NGroupByAttrs[0], GroupByIntMapping, TIntV(), true, UsePhysicalIds);
1263    				NumOfGroups = GroupByIntMapping.Len();
1264    				GroupingCase = 1;
1265    				break;
1266    			case atFlt:
1267    				GroupByFltCol(NGroupByAttrs[0], GroupByFltMapping, TIntV(), true, UsePhysicalIds);
1268    				NumOfGroups = GroupByFltMapping.Len();
1269    				GroupingCase = 2;
1270    				break;
1271    			case atStr:
1272    				GroupByStrCol(NGroupByAttrs[0], GroupByStrMapping, TIntV(), true, UsePhysicalIds);
1273    				NumOfGroups = GroupByStrMapping.Len();
1274    				GroupingCase = 3;
1275    				break;
1276    		}
1277    	}
1278    	else{
1279    		TIntV UniqueVector;
1280    		THash<TGroupKey, TPair<TInt, TIntV> > Mapping_aux;
1281    		GroupAux(NGroupByAttrs, Mapping_aux, Ordered, "", false, UniqueVector, UsePhysicalIds);
1282    		for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Mapping_aux.BegI(); it < Mapping_aux.EndI(); it++){
1283    			Mapping.AddDat(it.GetKey(), it.GetDat().Val2);
1284    		}
1285    		NumOfGroups = Mapping.Len();
1286    	}
1287    }
1288    TAttrType T = GetColType(ValAttr);
1289    if (AggOp == aaCount) { AddIntCol(ResAttr); } 
1290    else {
1291      if (T == atInt) { AddIntCol(ResAttr); }
1292      else if (T == atFlt) { AddFltCol(ResAttr); }
1293      else {
1294        TExcept::Throw("Invalid aggregation for Str type!");
1295      }
1296    }
1297    TInt ColIdx = GetColIdx(ResAttr);
1298    TInt AggrColIdx = GetColIdx(ValAttr);
1299  #ifdef USE_OPENMP
1300    #pragma omp parallel for schedule(dynamic)
1301  #endif 
1302    for (int g = 0; g < NumOfGroups; g++) {
1303    	TIntV* GroupRows = NULL;
1304    	switch(GroupingCase){
1305    		case 0:
1306    			GroupRows = & Mapping.GetDat(Mapping.GetKey(g));
1307    			break;
1308    		case 1:
1309    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1310    			break;
1311    		case 2:
1312    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1313    			break;
1314    	    case 3:
1315    			GroupRows = & GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g));
1316    			break;
1317    		case 4:
1318  #ifdef GCC_ATOMIC
1319    			GroupRows = & GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]);
1320  #endif
1321    			break;
1322    	}
1323  	TIntV& ValidRows = *GroupRows;
1324      TInt sz = ValidRows.Len();
1325      if (sz <= 0) continue;
1326      if (AggOp == aaCount) {
1327        for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; }
1328      } else {
1329        if (T == atInt) {
1330          TIntV V;
1331          for (TInt i = 0; i < sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); }
1332          TInt Res = AggregateVector<TInt>(V, AggOp);
1333          if (AggOp == aaMean) { Res = Res / sz; }
1334          for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; }
1335        } else {
1336          TFltV V;
1337          for (TInt i = 0; i < sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); }
1338          TFlt Res = AggregateVector<TFlt>(V, AggOp);
1339          if (AggOp == aaMean) { Res /= sz; }
1340          for (TInt i = 0; i < sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; }
1341        }
1342      }
1343    }
1344  }
1345  void TTable::AggregateCols(const TStrV& AggrAttrs, TAttrAggr AggOp, const TStr& ResAttr) {
1346    TVec<TPair<TAttrType, TInt> >Info;
1347    for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1348      Info.Add(GetColTypeMap(AggrAttrs[i]));
1349      if (Info[i].Val1 != Info[0].Val1) {
1350        TExcept::Throw("AggregateCols: Aggregation attributes must have the same type");
1351      }
1352    }
1353    if (Info[0].Val1 == atInt) {
1354      AddIntCol(ResAttr);
1355      TInt ResIdx = GetColIdx(ResAttr);
1356      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1357        TInt RowIdx = RI.GetRowIdx();
1358        TIntV V;
1359        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1360          V.Add(IntCols[Info[i].Val2][RowIdx]);
1361        }
1362        IntCols[ResIdx][RowIdx] = AggregateVector<TInt>(V, AggOp);
1363      }
1364    } else if (Info[0].Val1 == atFlt) {
1365      AddFltCol(ResAttr);
1366      TInt ResIdx = GetColIdx(ResAttr);
1367      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1368        TInt RowIdx = RI.GetRowIdx();
1369        TFltV V;
1370        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1371          V.Add(FltCols[Info[i].Val2][RowIdx]);
1372        }
1373        FltCols[ResIdx][RowIdx] = AggregateVector<TFlt>(V, AggOp);
1374      }
1375    } else {
1376      TExcept::Throw("AggregateCols: Only Int and Flt aggregation supported right now");
1377    }
1378  }
1379  void TTable::PrintGrouping(const THash<TGroupKey, TIntV>& Mapping) const{
1380  	for(THash<TGroupKey, TIntV>::TIter it = Mapping.BegI(); it < Mapping.EndI(); it++){
1381    		TGroupKey gk = it.GetKey();
1382    		TIntV ik = gk.Val1;
1383    		TFltV fk = gk.Val2;
1384    		for(int i = 0; i < ik.Len(); i++){ printf("%d ",ik[i].Val);} 
1385    		for(int i = 0; i < fk.Len(); i++){ printf("%f ",fk[i].Val);} 
1386    		printf("-->");
1387    		TIntV v = it.GetDat();
1388    		for(int i = 0; i < v.Len(); i++){ printf("%d ",v[i].Val);} 
1389    		printf("\n");
1390    	}
1391  }
1392  void TTable::Count(const TStr& CountColName, const TStr& Col) {
1393    TStrV GroupByAttrs;
1394    GroupByAttrs.Add(CountColName);
1395    Aggregate(GroupByAttrs, aaCount, "", Col);
1396  }
1397  TVec<PTable> TTable::SpliceByGroup(const TStrV& GroupBy, TBool Ordered) {
1398    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1399    TIntV UniqueVec;
1400    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
1401    TVec<PTable> Result;
1402    Schema NewSchema;
1403    for (TInt c = 0; c < Sch.Len(); c++) {
1404      if (Sch[c].Val1 != GetIdColName()) {
1405        NewSchema.Add(Sch[c]);
1406      }
1407    }
1408    GroupAux(NGroupBy, Grouping, Ordered, "", false, UniqueVec);
1409    TInt cnt = 0;
1410    for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it != Grouping.EndI(); it++) {
1411      PTable GroupTable = TTable::New(NewSchema, Context);
1412      TVec<TPair<TAttrType, TInt> > ColInfo;
1413      TIntV V;
1414      for (TInt i = 0; i < Sch.Len(); i++) {
1415        ColInfo.Add(GroupTable->GetColTypeMap(Sch[i].Val1));
1416        if (Sch[i].Val1 == IdColName()) {
1417          ColInfo[i].Val2 = -1;
1418        }
1419        V.Add(GetColIdx(Sch[i].Val1));
1420      }
1421      TIntV& Rows = it.GetDat().Val2;
1422      for (TInt i = 0; i < Rows.Len(); i++) {
1423        TInt RowIdx = RowIdMap.GetDat(Rows[i]);
1424        for (TInt c = 0; c < Sch.Len(); c++) {
1425          TPair<TAttrType, TInt> Info = ColInfo[c];
1426          TInt ColIdx = Info.Val2;
1427          if (ColIdx == -1) { continue; }
1428          switch (Info.Val1) {
1429            case atInt:
1430              GroupTable->IntCols[ColIdx].Add(IntCols[V[c]][RowIdx]);
1431              break;
1432            case atFlt:
1433              GroupTable->FltCols[ColIdx].Add(FltCols[V[c]][RowIdx]);
1434              break;
1435            case atStr:
1436              GroupTable->StrColMaps[ColIdx].Add(StrColMaps[V[c]][RowIdx]);
1437              break;
1438          }
1439        }
1440        if (GroupTable->LastValidRow >= 0) {
1441          GroupTable->Next[GroupTable->LastValidRow] = GroupTable->NumRows;
1442        }
1443        GroupTable->Next.Add(GroupTable->Last);
1444        GroupTable->LastValidRow = GroupTable->NumRows;
1445        GroupTable->NumRows++;
1446        GroupTable->NumValidRows++;
1447      }
1448      GroupTable->InitIds();
1449      Result.Add(GroupTable);
1450      cnt += 1;
1451    }
1452    return Result;
1453  }
1454  void TTable::InitIds() {
1455    IdColName = "_id";
1456    AddIdColumn(IdColName);
1457  }
1458  void TTable::Reindex() {
1459    RowIdMap.Clr();
1460    TInt IdColIdx = GetColIdx(IdColName);
1461    TInt IdCnt = 0;
1462    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1463      IntCols[IdColIdx][RI.GetRowIdx()] = IdCnt;
1464      RowIdMap.AddDat(RI.GetRowIdx(), IdCnt);
1465      IdCnt++;
1466    }
1467  }
1468  void TTable::AddIdColumn(const TStr& ColName) {
1469    TInt IdCol = IntCols.Add();
1470    IntCols[IdCol].Reserve(NumRows, NumRows);
1471    TInt IdCnt = 0;
1472    RowIdMap.Clr();
1473    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1474      IntCols[IdCol][RI.GetRowIdx()] = IdCnt;
1475      RowIdMap.AddDat(IdCnt, RI.GetRowIdx());
1476      IdCnt++;
1477    }
1478    AddSchemaCol(ColName, atInt);
1479    AddColType(ColName, atInt, IntCols.Len()-1);
1480  }
1481   PTable TTable::InitializeJointTable(const TTable& Table) {
1482    PTable JointTable = New(Context);
1483    JointTable->IntCols = TVec<TIntV>(IntCols.Len() + Table.IntCols.Len() + 1);
1484    JointTable->FltCols = TVec<TFltV>(FltCols.Len() + Table.FltCols.Len());
1485    JointTable->StrColMaps = TVec<TIntV>(StrColMaps.Len() + Table.StrColMaps.Len());
1486    for (TInt i = 0; i < Sch.Len(); i++) {
1487      TStr ColName = GetSchemaColName(i);
1488      TAttrType ColType = GetSchemaColType(i);
1489      TStr CName = JointTable->RenumberColName(ColName);
1490      TPair<TAttrType, TInt> TypeMap = GetColTypeMap(ColName);
1491      JointTable->AddColType(CName, TypeMap);
1492      JointTable->AddSchemaCol(CName, ColType);
1493    }
1494    for (TInt i = 0; i < Table.Sch.Len(); i++) {
1495      TStr ColName = Table.GetSchemaColName(i);
1496      TAttrType ColType = Table.GetSchemaColType(i);
1497      TStr CName = JointTable->RenumberColName(ColName);
1498      TPair<TAttrType, TInt> NewDat = Table.GetColTypeMap(ColName);
1499      Assert(ColType == NewDat.Val1);
1500      switch (NewDat.Val1) {
1501        case atInt:
1502          NewDat.Val2 += IntCols.Len();
1503          break;
1504        case atFlt:
1505          NewDat.Val2 += FltCols.Len();
1506          break;
1507        case atStr:
1508          NewDat.Val2 += StrColMaps.Len();
1509          break;
1510      }
1511      JointTable->AddColType(CName, NewDat);
1512      JointTable->AddSchemaCol(CName, ColType);
1513    }
1514    TStr IdColName = "_id";
1515    JointTable->AddColType(IdColName, atInt, IntCols.Len() + Table.IntCols.Len());
1516    JointTable->AddSchemaCol(IdColName, atInt);
1517    return JointTable;
1518  }
1519  void TTable::AddJointRow(const TTable& T1, const TTable& T2, TInt RowIdx1, TInt RowIdx2) {
1520    for (TInt i = 0; i < T1.IntCols.Len(); i++) {
1521      IntCols[i].Add(T1.IntCols[i][RowIdx1]);
1522    }
1523    for (TInt i = 0; i < T1.FltCols.Len(); i++) {
1524      FltCols[i].Add(T1.FltCols[i][RowIdx1]);
1525    }
1526    for (TInt i = 0; i < T1.StrColMaps.Len(); i++) {
1527      StrColMaps[i].Add(T1.StrColMaps[i][RowIdx1]);
1528    }
1529    TInt IntOffset = T1.IntCols.Len();
1530    TInt FltOffset = T1.FltCols.Len();
1531    TInt StrOffset = T1.StrColMaps.Len();
1532    for (TInt i = 0; i < T2.IntCols.Len(); i++) {
1533      IntCols[i+IntOffset].Add(T2.IntCols[i][RowIdx2]);
1534    }
1535    for (TInt i = 0; i < T2.FltCols.Len(); i++) {
1536      FltCols[i+FltOffset].Add(T2.FltCols[i][RowIdx2]);
1537    }
1538    for (TInt i = 0; i < T2.StrColMaps.Len(); i++) {
1539      StrColMaps[i+StrOffset].Add(T2.StrColMaps[i][RowIdx2]);
1540    }
1541    TInt IdOffset = IntOffset + T2.IntCols.Len(); 
1542    NumRows++;
1543    NumValidRows++;
1544    if (!Next.Empty()) {
1545      Next[Next.Len()-1] = NumValidRows-1;
1546      LastValidRow = NumValidRows-1;
1547    }
1548    Next.Add(Last);
1549    RowIdMap.AddDat(NumRows-1,NumRows-1);
1550    IntCols[IdOffset].Add(NumRows-1);
1551  }
1552  PTable TTable::SimJoin(const TStrV& Cols1, const TTable& Table, const TStrV& Cols2, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold)
1553  {
1554  	Assert(Cols1.Len() == Cols2.Len());
1555  	if(Cols1.Len()!=Cols2.Len()){
1556  		TExcept::Throw("Column vectors must match in type and length");
1557  	}
1558  	for (TInt i = 0; i < Cols1.Len(); i++) {
1559  		if(!IsColName(Cols1[i]) || !Table.IsColName(Cols2[i])){
1560  			TExcept::Throw("Column not found in Table");
1561  		}
1562  		TAttrType Type1 = GetColType(Cols1[i]);
1563  		TAttrType Type2 = GetColType(Cols2[i]);
1564  		if(Type1!=Type2){
1565  			TExcept::Throw("Column types on the two tables must match.");
1566  		}
1567  		if((Type1!=atInt && Type1!=atFlt) || (Type2!=atInt && Type2!=atFlt)){
1568  			TExcept::Throw("Column type not supported. Only Flt and Int column types are supported.");
1569  		}
1570    }
1571    PTable JointTable = InitializeJointTable(Table);
1572  	TFltV DistanceV;
1573  	for(TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1574  		for(TRowIterator RowI2 = Table.BegRI(); RowI2 < Table.EndRI(); RowI2++) {
1575  			float distance = 0;
1576  			switch(SimType)
1577  			{
1578  				case L2Norm:
1579  					for(TInt i = 0; i < Cols1.Len(); i++) {
1580  						float attrVal1, attrVal2;
1581  						attrVal1 = GetColType(Cols1[i])==atInt ? (float)RowI.GetIntAttr(Cols1[i]) : (float)RowI.GetFltAttr(Cols1[i]);
1582  						attrVal2 = Table.GetColType(Cols2[i])==atInt ? (float)RowI2.GetIntAttr(Cols2[i]) : (float)RowI2.GetFltAttr(Cols2[i]);
1583  						distance += pow(attrVal1 - attrVal2, 2);
1584  					}
1585  					distance = sqrt(distance);
1586  					if(distance<=Threshold){
1587  						JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1588  						DistanceV.Add(distance);
1589  					}
1590  					break;
1591  				case Haversine:
1592  					{
1593  						if(Cols1.Len()!=2){
1594  							TExcept::Throw("Haversine disance expects exactly two attributes - latitude and longitude - in that order.");
1595  						}
1596  						TFlt Radius = 6373; 
1597  						float Latitude1  = GetColType(Cols1[0])==atInt ? (float)RowI.GetIntAttr(Cols1[0]) : (float)RowI.GetFltAttr(Cols1[0]);
1598  						float Latitude2 = Table.GetColType(Cols2[0])==atInt ? (float)RowI2.GetIntAttr(Cols2[0]) : (float)RowI2.GetFltAttr(Cols2[0]);
1599  						float Longitude1  = GetColType(Cols1[1])==atInt ? (float)RowI.GetIntAttr(Cols1[1]) : (float)RowI.GetFltAttr(Cols1[1]);
1600  						float Longitude2  = Table.GetColType(Cols2[1])==atInt ? (float)RowI2.GetIntAttr(Cols2[1]) : (float)RowI2.GetFltAttr(Cols2[1]);
1601  						Latitude1 *= static_cast<float>(M_PI/180.0);
1602  						Latitude2 *= static_cast<float>(M_PI/180.0);
1603  						Longitude1 *= static_cast<float>(M_PI/180.0);
1604  						Longitude2 *= static_cast<float>(M_PI/180.0);
1605  						float dlon = Longitude2 - Longitude1;
1606  						float dlat = Latitude2 - Latitude1;
1607  						float a = pow(sin(dlat/2), 2) + cos(Latitude1)*cos(Latitude2)*pow(sin(dlon/2), 2);
1608  						float c = 2*atan2(sqrt(a), sqrt(1-a));
1609  						distance = (static_cast<float>(Radius.Val))*c;
1610  						if(distance<=Threshold){
1611  							JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1612  							DistanceV.Add(distance);
1613  						}
1614  					}
1615  					break;
1616  				case L1Norm:
1617  				case Jaccard:
1618  					TExcept::Throw("This distance metric is not supported");
1619  			}
1620  		}	
1621  	}
1622  	JointTable->StoreFltCol(DistanceColName, DistanceV);
1623  	JointTable->InitIds();
1624  	return JointTable;
1625  }
1626  PTable TTable::SelfSimJoinPerGroup(const TStr& GroupAttr, const TStr& SimCol, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) 
1627  {
1628  	if(!IsColName(SimCol) || !IsColName(GroupAttr)){
1629  		TExcept::Throw("No such column found in table");
1630  	}
1631    PTable JointTable = New(Context);
1632  	JointTable->IntCols = TVec<TIntV>(2);
1633  	JointTable->FltCols = TVec<TFltV>(1);
1634  	for(TInt i=0;i<2;i++){
1635      TInt Suffix = i+1;
1636      TStr CName = "GroupId_" + Suffix.GetStr();
1637      TPair<TAttrType, TInt> Group(atInt, (int)i);
1638      JointTable->AddColType(CName, Group);
1639      JointTable->AddSchemaCol(CName, atInt);
1640    }
1641  	TPair<TAttrType, TInt> Group(atFlt, 0);
1642  	JointTable->AddColType(DistanceColName, Group);
1643  	JointTable->AddSchemaCol(DistanceColName, atFlt);
1644  	THash<TInt, THash<TInt, TInt> > TIntHH;
1645  	TAttrType attrType = GetColType(SimCol);
1646  	TInt GroupColIdx = GetColIdx(GroupAttr);
1647  	TInt SimColIdx = GetColIdx(SimCol);
1648  	for (TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1649  		TInt GroupId = IntCols[GroupColIdx][RowI.GetRowIdx()];
1650  		if(attrType==atInt || attrType==atStr)
1651  		{
1652  			if(!TIntHH.IsKey(GroupId)){
1653  				THash<TInt, TInt> TIntH;
1654  				TIntHH.AddDat(GroupId, TIntH);
1655  			}
1656  			THash<TInt, TInt>& TIntH = TIntHH.GetDat(GroupId);
1657  			TInt SimAttrVal = (attrType==atInt ? IntCols[SimColIdx][RowI.GetRowIdx()] : StrColMaps[SimColIdx][RowI.GetRowIdx()]);
1658  			TIntH.AddDat(SimAttrVal, 0);
1659  		}
1660  		else
1661  		{
1662  			TExcept::Throw("Attribute type not supported.");
1663  		}
1664  	}
1665  	for (THash<TInt, THash<TInt, TInt> >::TIter it1 = TIntHH.BegI(); it1 < TIntHH.EndI(); it1++) {
1666  		THash<TInt, TInt> Vals1H = it1.GetDat();
1667  		TInt GroupId1 = it1.GetKey();
1668  		for (THash<TInt, THash<TInt, TInt> >::TIter it2 = TIntHH.BegI(); it2 < TIntHH.EndI(); it2++) {
1669  				int intersectionCount = 0;
1670  				TInt GroupId2 = it2.GetKey();
1671  				THash<TInt, TInt> Vals2H = it2.GetDat();
1672  				for(THash<TInt, TInt>::TIter it = Vals1H.BegI(); it < Vals1H.EndI(); it++)
1673  				{
1674  					TInt Val = it.GetKey();
1675  					if(Vals2H.IsKey(Val)){
1676  						intersectionCount+=1;
1677  					}
1678  				}
1679  				int unionCount = Vals1H.Len() + Vals2H.Len() - intersectionCount;
1680  				float distance = 1.0f - (float)intersectionCount/unionCount;
1681  				if(distance<=Threshold){
1682  						JointTable->IntCols[0].Add(GroupId1);
1683  						JointTable->IntCols[1].Add(GroupId2);
1684  						JointTable->FltCols[0].Add(distance);
1685  						JointTable->IncrementNext();
1686  			}
1687  		}
1688  	}
1689    JointTable->InitIds();
1690  	return JointTable;
1691  }
1692  PTable TTable::SelfSimJoinPerGroup(const TStrV& GroupBy, const TStr& SimCol, 
1693   const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) {
1694    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1695  	TStrV ProjectionV;
1696  	for(TInt i=0; i<GroupBy.Len(); i++)
1697  	{
1698  		ProjectionV.Add(GroupBy[i]);
1699  	}
1700  	ProjectionV.Add(SimCol);
1701  	ProjectInPlace(ProjectionV);
1702  	TStr CName = "Group";
1703    TIntV UniqueVec;
1704    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1705    GroupAux(NGroupBy, Grouping, false, CName, false, UniqueVec);
1706  	PTable GroupJointTable = SelfSimJoinPerGroup(CName, SimCol, DistanceColName, SimType, Threshold);
1707  	PTable JointTable = InitializeJointTable(*this);
1708  	THash<TInt, TInt> GroupIdH;
1709  	for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it=Grouping.BegI(); it<Grouping.EndI(); it++)
1710  	{
1711  		TPair<TInt, TIntV> group = it.GetDat();
1712  		TInt GroupNum = group.Val1;
1713  		TIntV RowIds = group.Val2;
1714  		if(!GroupIdH.IsKey(GroupNum))
1715  		{
1716  			TInt RandomRowId = RowIds[0];  
1717  			GroupIdH.AddDat(GroupNum, RandomRowId);
1718  		}
1719  	}
1720  	for(TRowIterator RowI = GroupJointTable->BegRI(); RowI < GroupJointTable->EndRI(); RowI++)
1721  	{
1722  		TInt GroupId1 = GroupJointTable->IntCols[0][RowI.GetRowIdx()];
1723  		TInt GroupId2 = GroupJointTable->IntCols[1][RowI.GetRowIdx()];
1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
1725  		TInt RowId2 = GroupIdH.GetDat(GroupId2);
1726  		JointTable->AddJointRow(*this, *this, RowId1, RowId2);
1727  	} 
1728  	JointTable->StoreFltCol(DistanceColName, GroupJointTable->FltCols[0]);
1729  	ProjectionV.Clr();
1730  	ProjectionV.Add(DistanceColName);
1731  	for(TInt i=0; i<GroupBy.Len(); i++){
1732  		for(TInt j=0; j<JointTable->Sch.Len(); j++)
1733  		{
1734  			TStr ColName = JointTable->Sch[j].Val1;
1735  			if(ColName.IsStrIn(GroupBy[i]))
1736  			{
1737  				ProjectionV.Add(ColName);
1738  			}
1739  		}
1740  	}
1741  	JointTable->ProjectInPlace(ProjectionV);
1742  	JointTable->InitIds();
1743  	return JointTable;
1744  }
1745  void TTable::IncrementNext()
1746  {
1747  	NumRows++;
1748  	NumValidRows++;
1749  	if (!Next.Empty()) {
1750  		Next[Next.Len()-1] = NumValidRows-1;
1751  		LastValidRow = NumValidRows-1;
1752  	}
1753  	Next.Add(Last);
1754  }
1755  PTable TTable::Join(const TStr& Col1, const TTable& Table, const TStr& Col2) {
1756    if (!IsColName(Col1)) {
1757      TExcept::Throw("no such column " + Col1);
1758      printf("no such column %s\n", Col1.CStr());
1759    }
1760    if (!Table.IsColName(Col2)) {
1761      TExcept::Throw("no such column " + Col2);
1762      printf("no such column %s\n", Col2.CStr());
1763    }
1764    if (GetColType(Col1) != Table.GetColType(Col2)) {
1765      TExcept::Throw("Trying to Join on columns of different type");
1766      printf("Trying to Join on columns of different type\n");
1767    }
1768    PTable JointTable = InitializeJointTable(Table);
1769    TAttrType ColType = GetColType(Col1);
1770    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
1771    const TTable& TS = ThisIsSmaller ? *this : Table;
1772    const TTable& TB = ThisIsSmaller ?  Table : *this;
1773    TStr ColS = ThisIsSmaller ? Col1 : Col2;
1774    TStr ColB = ThisIsSmaller ? Col2 : Col1;
1775    TInt ColBId = ThisIsSmaller ? Table.GetColIdx(ColB) : GetColIdx(ColB);
1776  #ifdef GCC_ATOMIC
1777    if (GetMP()) {
1778      switch(ColType){
1779        case atInt:{
1780          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1781          TS.GroupByIntColMP(ColS, T, true);
1782          TIntPrV Partitions;
1783          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1784          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1785          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1786          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1787          for (int i = 0; i < Partitions.Len(); i++){
1788            JointRowIDSet[i].Reserve(PartitionSize);
1789            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1790            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1791            while (RowI < EndI) {
1792              TInt K = RowI.GetIntAttr(ColBId);
1793              if(T.IsKey(K)){
1794                TIntV& Group = T.GetDat(K);
1795                for(TInt j = 0; j < Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
1803              RowI++;
1804            }
1805          }
1806          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);      
1807          break;
1808        }
1809        case atFlt:{
1810          THashMP<TFlt, TIntV> T(TS.GetNumValidRows());
1811          TS.GroupByFltCol(ColS, T, TIntV(), true);
1812          TIntPrV Partitions;
1813          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1814          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1815          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1816          #pragma omp parallel for schedule(dynamic) 
1817          for (int i = 0; i < Partitions.Len(); i++){
1818            JointRowIDSet[i].Reserve(PartitionSize);
1819            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1820            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1821            while (RowI < EndI) {
1822              TFlt K = RowI.GetFltAttr(ColBId);
1823              if(T.IsKey(K)){
1824                TIntV& Group = T.GetDat(K);
1825                for(TInt j = 0; j < Group.Len(); j++){
1826                  if(ThisIsSmaller){
1827                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1828                  } else{
1829                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1830                  }
1831                }
1832              }
1833              RowI++;
1834            }
1835          }
1836          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1837          break;
1838        }
1839        case atStr:{
1840          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1841          TS.GroupByStrCol(ColS, T, TIntV(), true);
1842          TIntPrV Partitions;
1843          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1844          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1845          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1846          #pragma omp parallel for schedule(dynamic) 
1847          for (int i = 0; i < Partitions.Len(); i++){
1848            JointRowIDSet[i].Reserve(PartitionSize);
1849            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1850            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1851            while (RowI < EndI) {
1852              TInt K = RowI.GetStrMapById(ColBId);
1853              if(T.IsKey(K)){
1854                TIntV& Group = T.GetDat(K);
1855                for(TInt j = 0; j < Group.Len(); j++){
1856                  if(ThisIsSmaller){
1857                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1858                  } else{
1859                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1860                  }
1861                }
1862              }
1863              RowI++;
1864            }
1865          }
1866          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1867        }
1868        break;
1869      }
1870    } else {
1871  #endif 
1872      switch (ColType) {
1873        case atInt:{
1874          TIntIntVH T;
1875          TS.GroupByIntCol(ColS, T, TIntV(), true);
1876          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1877            TInt K = RowI.GetIntAttr(ColBId);
1878            if (T.IsKey(K)) {
1879              TIntV& Group = T.GetDat(K);
1880              for (TInt i = 0; i < Group.Len(); i++) {
1881                if (ThisIsSmaller) {
1882                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1883                } else {
1884                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1885                }
1886              }
1887            }
1888          }
1889          break;
1890        }
1891        case atFlt:{
1892          THash<TFlt, TIntV> T;
1893          TS.GroupByFltCol(ColS, T, TIntV(), true);
1894          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1895            TFlt K = RowI.GetFltAttr(ColBId);
1896            if (T.IsKey(K)) {
1897              TIntV& Group = T.GetDat(K);
1898              for (TInt i = 0; i < Group.Len(); i++) {
1899                if (ThisIsSmaller) {
1900                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1901                } else {
1902                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1903                }
1904              }
1905            }
1906          }
1907          break;
1908        }
1909        case atStr:{
1910          TIntIntVH T;
1911          TS.GroupByStrCol(ColS, T, TIntV(), true);
1912          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1913            TInt K = RowI.GetStrMapById(ColBId);
1914            if (T.IsKey(K)) {
1915              TIntV& Group = T.GetDat(K);
1916              for (TInt i = 0; i < Group.Len(); i++) {
1917                if (ThisIsSmaller) {
1918                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1919                } else {
1920                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1921                }
1922              }
1923            }
1924          }
1925        }
1926        break;
1927      }
1928  #ifdef GCC_ATOMIC
1929    }
1930  #endif
1931    return JointTable; 
1932  }
1933  void TTable::ThresholdJoinInputCorrectness(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
1934    const TStr& KeyCol2, const TStr& JoinCol2){
1935    if (!IsColName(KeyCol1)) {
1936      printf("no such column %s\n", KeyCol1.CStr());
1937      TExcept::Throw("no such column " + KeyCol1);
1938    }
1939    if (!Table.IsColName(KeyCol2)) {
1940      printf("no such column %s\n", KeyCol2.CStr());
1941      TExcept::Throw("no such column " + KeyCol2);
1942    }
1943    if (!IsColName(JoinCol1)) {
1944      printf("no such column %s\n", JoinCol1.CStr());
1945      TExcept::Throw("no such column " + JoinCol1);
1946    }
1947    if (!Table.IsColName(JoinCol2)) {
1948      printf("no such column %s\n", JoinCol2.CStr());
1949      TExcept::Throw("no such column " + JoinCol2);
1950    }
1951    if (GetColType(JoinCol1) != Table.GetColType(JoinCol2)) {
1952      printf("Trying to Join on columns of different type\n");
1953      TExcept::Throw("Trying to Join on columns of different type");
1954    }
1955    if (GetColType(KeyCol1) != Table.GetColType(KeyCol2)) {
1956      printf("Key type mismatch\n");
1957      TExcept::Throw("Key type mismatch");
1958    }
1959  }
1960  void TTable::ThresholdJoinCountCollisions(const TTable& TB, const TTable& TS, 
1961    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
1962    THash<TIntPr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
1963      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1964        TInt JVal = 0;
1965        if(JoinColType == atStr){
1966          JVal = RowI.GetStrMapById(JoinColIdxB);
1967        } else{
1968          JVal = RowI.GetIntAttr(JoinColIdxB);
1969        }
1970        if(T.IsKey(JVal)){
1971          TInt KeyB = 0;
1972          if(KeyType == atStr){
1973            KeyB = RowI.GetStrMapById(KeyColIdxB);
1974          } else{
1975            KeyB = RowI.GetIntAttr(KeyColIdxB);
1976          } 
1977          const TIntV& RelevantRows = T.GetDat(JVal);
1978          for(int i = 0; i < RelevantRows.Len(); i++){
1979            TInt KeyS = 0;
1980            if(KeyType == atStr){
1981              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
1982            } else{
1983              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
1984            }
1985            TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
1986            if(Counters.IsKey(Keys)){
1987              TIntTr& V = Counters.GetDat(Keys);
1988              V.Val3 = V.Val3 + 1;
1989            } else{
1990              if(ThisIsSmaller){
1991                Counters.AddDat(Keys, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
1992              } else{
1993                Counters.AddDat(Keys, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
1994              }
1995            }
1996          }	
1997        }	
1998      } 
1999  }
2000  void TTable::ThresholdJoinCountPerJoinKeyCollisions(const TTable& TB, const TTable& TS, 
2001    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
2002    THash<TIntTr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
2003      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
2004        TInt JVal = 0;
2005        if(JoinColType == atStr){
2006          JVal = RowI.GetStrMapById(JoinColIdxB);
2007         } else{
2008          JVal = RowI.GetIntAttr(JoinColIdxB);
2009         }
2010        if(T.IsKey(JVal)){
2011          TInt KeyB = 0;
2012          if(KeyType == atStr){
2013            KeyB = RowI.GetStrMapById(KeyColIdxB);
2014          } else{
2015            KeyB = RowI.GetIntAttr(KeyColIdxB);
2016          } 
2017          const TIntV& RelevantRows = T.GetDat(JVal);
2018          for(int i = 0; i < RelevantRows.Len(); i++){
2019            TInt KeyS = 0;
2020            if(KeyType == atStr){
2021              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
2022            } else{
2023              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
2024            }
2025          	TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
2026          	TIntTr K(Keys.Val1,Keys.Val2,JVal);
2027            if(Counters.IsKey(K)){
2028              TIntTr& V = Counters.GetDat(K);
2029              V.Val3 = V.Val3 + 1;
2030            } else{
2031              if(ThisIsSmaller){
2032                Counters.AddDat(K, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
2033              } else{
2034                Counters.AddDat(K, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
2035              }
2036            }
2037          }	
2038        }	
2039      } 
2040    }
2041  PTable TTable::ThresholdJoinOutputTable(const THash<TIntPr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2042    PTable JointTable = InitializeJointTable(Table);
2043    for(THash<TIntPr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2044      TIntTr& Counter = iter.GetDat();
2045      if(Counter.Val3 >= Threshold){
2046        JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2047      }
2048    }
2049    return JointTable;
2050  }
2051  PTable TTable::ThresholdJoinPerJoinKeyOutputTable(const THash<TIntTr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2052    PTable JointTable = InitializeJointTable(Table);
2053    for(THash<TIntTr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2054      const TIntTr& Counter = iter.GetDat();
2055      const TIntTr& Keys = iter.GetKey();
2056      THashSet<TIntPr> Pairs;
2057      if(Counter.Val3 >= Threshold){
2058        TIntPr K(Keys.Val1,Keys.Val2);
2059        if(!Pairs.IsKey(K)){
2060          Pairs.AddKey(K);
2061          JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2062        }
2063      }
2064    }
2065    return JointTable;
2066  }
2067  PTable TTable::ThresholdJoin(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
2068    const TStr& KeyCol2, const TStr& JoinCol2, TInt Threshold, TBool PerJoinKey){
2069    ThresholdJoinInputCorrectness(KeyCol1, JoinCol1, Table, KeyCol2, JoinCol2);
2070    TAttrType JoinColType = GetColType(JoinCol1);
2071    TAttrType KeyType = GetColType(KeyCol1);
2072    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
2073    const TTable& TS = ThisIsSmaller ? *this : Table;
2074    const TTable& TB = ThisIsSmaller ?  Table : *this;
2075    TStr JoinColS = JoinCol1;
2076    TInt JoinColIdxB = GetColIdx(JoinCol2);
2077    TInt KeyColIdxS = GetColIdx(KeyCol1);
2078    TInt KeyColIdxB = GetColIdx(KeyCol2);
2079    if(!ThisIsSmaller){
2080    	JoinColS = JoinCol2;
2081      JoinColIdxB = GetColIdx(JoinCol1);
2082    	KeyColIdxS = GetColIdx(KeyCol2);
2083      KeyColIdxB = GetColIdx(KeyCol1);
2084    }
2085    if(KeyType != atInt && KeyType != atStr){
2086      printf("ThresholdJoin only supports integer or string key attributes\n");
2087      TExcept::Throw("ThresholdJoin only supports integer or string key attributes");
2088    }
2089    if(JoinColType != atInt && JoinColType != atStr){
2090      printf("ThresholdJoin only supports integer or string join attributes\n");
2091      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2092    }
2093    TIntIntVH T;
2094    if(JoinColType == atInt){
2095      TS.GroupByIntCol(JoinColS, T, TIntV(), true);
2096    } else if(JoinColType == atStr){
2097      TS.GroupByStrCol(JoinColS, T, TIntV(), true);
2098    } else{
2099      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2100    } 
2101    if(PerJoinKey){
2102      THash<TIntTr,TIntTr> Counters;
2103      ThresholdJoinCountPerJoinKeyCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2104      return ThresholdJoinPerJoinKeyOutputTable(Counters, Threshold, Table);
2105    } else{
2106      THash<TIntPr,TIntTr> Counters;
2107      ThresholdJoinCountCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2108      return ThresholdJoinOutputTable(Counters, Threshold, Table);
2109    }
2110  }
2111  void TTable::Select(TPredicate& Predicate, TIntV& SelectedRows, TBool Remove) {
2112    TIntV Selected;
2113    TStrV RelevantCols;
2114    Predicate.GetVariables(RelevantCols);
2115    TInt NumRelevantCols = RelevantCols.Len();
2116    TVec<TAttrType> ColTypes = TVec<TAttrType>(NumRelevantCols);
2117    TIntV ColIndices = TIntV(NumRelevantCols);
2118    for (TInt i = 0; i < NumRelevantCols; i++) {
2119      ColTypes[i] = GetColType(RelevantCols[i]);
2120      ColIndices[i] = GetColIdx(RelevantCols[i]);
2121    } 
2122    if (Remove) {
2123      TRowIteratorWithRemove RowI = BegRIWR();
2124      while (RowI.GetNextRowIdx() != Last) {
2125        for (TInt i = 0; i < NumRelevantCols; i++) {
2126          switch (ColTypes[i]) {
2127          case atInt:
2128            Predicate.SetIntVal(RelevantCols[i], RowI.GetNextIntAttr(ColIndices[i]));
2129            break;
2130          case atFlt:
2131            Predicate.SetFltVal(RelevantCols[i], RowI.GetNextFltAttr(ColIndices[i]));
2132            break;
2133          case atStr:
2134            Predicate.SetStrVal(RelevantCols[i], RowI.GetNextStrAttr(ColIndices[i]));
2135            break;
2136          }
2137        }
2138        if (!Predicate.Eval()) { 
2139          RowI.RemoveNext();
2140        } else {
2141          RowI++;
2142        }
2143      }
2144    } else {
2145      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2146        for (TInt i = 0; i < NumRelevantCols; i++) {
2147          switch (ColTypes[i]) {
2148          case atInt:
2149            Predicate.SetIntVal(RelevantCols[i], RowI.GetIntAttr(RelevantCols[i]));
2150            break;
2151          case atFlt:
2152            Predicate.SetFltVal(RelevantCols[i], RowI.GetFltAttr(RelevantCols[i]));
2153            break;
2154          case atStr:
2155            Predicate.SetStrVal(RelevantCols[i], RowI.GetStrAttr(RelevantCols[i]));
2156            break;
2157          }
2158        }
2159        if (Predicate.Eval()) { SelectedRows.Add(RowI.GetRowIdx()); }
2160      }
2161    }
2162  }
2163  void TTable::Classify(TPredicate& Predicate, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2164    TIntV SelectedRows;
2165    Select(Predicate, SelectedRows, false);
2166    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2167  }
2168  void TTable::SelectAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp, TIntV& SelectedRows, TBool Remove) {
2169    const TAttrType Ty1 = GetColType(Col1);
2170    const TAttrType Ty2 = GetColType(Col2);
2171    const TInt ColIdx1 = GetColIdx(Col1);
2172    const TInt ColIdx2 = GetColIdx(Col2);
2173    if (Ty1 != Ty2) {
2174      TExcept::Throw("SelectAtomic: diff types");
2175    }
2176    if (Cmp == SUBSTR || Cmp == SUPERSTR) { Assert(Ty1 == atStr); }
2177    if (Remove) {
2178      TRowIteratorWithRemove RowI = BegRIWR();
2179      while (RowI.GetNextRowIdx() != Last) {
2180        TBool Result;
2181        switch (Ty1) {
2182          case atInt:
2183            Result = TPredicate::EvalAtom(RowI.GetNextIntAttr(ColIdx1), RowI.GetNextIntAttr(ColIdx2), Cmp);
2184            break;
2185          case atFlt:
2186            Result = TPredicate::EvalAtom(RowI.GetNextFltAttr(ColIdx1), RowI.GetNextFltAttr(ColIdx2), Cmp);
2187            break;
2188          case atStr:
2189            Result = TPredicate::EvalStrAtom(RowI.GetNextStrAttr(ColIdx1), RowI.GetNextStrAttr(ColIdx2), Cmp);
2190            break;
2191        }
2192        if (!Result) { 
2193          RowI.RemoveNext();
2194        } else {
2195          RowI++;
2196        }
2197      }
2198    } else {
2199      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2200        TBool Result;
2201        switch (Ty1) {
2202          case atInt:
2203            Result = TPredicate::EvalAtom(RowI.GetIntAttr(Col1), RowI.GetIntAttr(Col2), Cmp);
2204            break;
2205          case atFlt:
2206            Result = TPredicate::EvalAtom(RowI.GetFltAttr(Col1), RowI.GetFltAttr(Col2), Cmp);
2207            break;
2208          case atStr:
2209            Result = TPredicate::EvalStrAtom(RowI.GetStrAttr(Col1), RowI.GetStrAttr(Col2), Cmp);
2210            break;
2211        }
2212        if (Result) { SelectedRows.Add(RowI.GetRowIdx()); }
2213      }
2214    }
2215  }
2216  void TTable::ClassifyAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp,
2217    const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2218    TIntV SelectedRows;
2219    SelectAtomic(Col1, Col2, Cmp, SelectedRows, false);
2220    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2221  }
2222  void TTable::SelectAtomicConst(const TStr& Col, const TPrimitive& Val, TPredComp Cmp, 
2223    TIntV& SelectedRows, PTable& SelectedTable, TBool Remove, TBool Table) {
2224    TStr ValTStr(Val.GetStr());
2225    TAttrType Type = GetColType(Col);
2226    TInt ColIdx = GetColIdx(Col);
2227    if (Type != Val.GetType()) { 
2228      TExcept::Throw("SelectAtomicConst: coltype does not match const type"); 
2229    }
2230    if(Remove){
2231  #ifdef USE_OPENMP
2232      if (GetMP()) {
2233        TIntPrV Partitions;
2234        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2235        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2236        int RemoveCount = 0;
2237        TIntPrV Bounds(Partitions.Len());
2238        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:RemoveCount)
2239        for (int i = 0; i < Partitions.Len(); i++){
2240          TRowIterator RowI(Partitions[i].GetVal1(), this);
2241          TRowIterator EndI(Partitions[i].GetVal2(), this);
2242          TInt FirstRowIdx = TTable::Invalid;
2243          TInt LastRowIdx = TTable::Invalid;
2244          TBool First = true;
2245          while (RowI < EndI) {
2246            TInt CurrRowIdx = RowI.GetRowIdx();
2247            TBool Result;
2248            if (Type != atStr) {
2249              Result = RowI.CompareAtomicConst(ColIdx, Val, Cmp);
2250            } else {
2251              Result = RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp);
2252            }
2253            RowI++;
2254            if(!Result) {
2255              Next[CurrRowIdx] = TTable::Invalid;
2256              RemoveCount++;
2257            } else { 
2258              if (First) { FirstRowIdx = CurrRowIdx; First = false; } 
2259              else { Next[LastRowIdx] = CurrRowIdx; }
2260              LastRowIdx = CurrRowIdx; 
2261            }
2262          }
2263          Bounds[i] = TIntPr(FirstRowIdx, LastRowIdx);
2264        }
2265        TInt CurrBound = 0;
2266        while (CurrBound < Bounds.Len() && Bounds[CurrBound].Val1 == TTable::Invalid) {
2267          CurrBound++;
2268        }
2269        if (CurrBound == Bounds.Len()) {
2270          Assert(NumValidRows == RemoveCount);
2271          NumValidRows = 0;
2272          FirstValidRow = TTable::Invalid;
2273          LastValidRow = TTable::Invalid;
2274        } else {
2275          NumValidRows -= RemoveCount;
2276          FirstValidRow = Bounds[CurrBound].Val1;
2277          LastValidRow = Bounds[CurrBound].Val2;
2278          TInt PrevBound = CurrBound;
2279          CurrBound++;
2280          while (CurrBound < Bounds.Len()) {
2281            if (Bounds[CurrBound].Val1 == TTable::Invalid) { CurrBound++; continue; }
2282            Next[Bounds[PrevBound].Val2] = Bounds[CurrBound].Val1;
2283            LastValidRow = Bounds[CurrBound].Val2;
2284            PrevBound = CurrBound;
2285            CurrBound++;
2286          }
2287          Next[Bounds[PrevBound].Val2] = TTable::Last;
2288        }
2289        IsNextDirty = 1;
2290      } else {
2291  #endif
2292        TRowIteratorWithRemove RowI = BegRIWR();
2293        while(RowI.GetNextRowIdx() != Last){
2294          if (!RowI.CompareAtomicConst(ColIdx, Val, Cmp)) {
2295            RowI.RemoveNext();
2296          } else {
2297            RowI++;
2298          }
2299        }
2300        IsNextDirty = 1;
2301  #ifdef USE_OPENMP
2302      }
2303  #endif
2304    } else if (Table) {
2305  #ifdef USE_OPENMP
2306      if (GetMP()) {
2307        TIntPrV Partitions;
2308        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2309        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2310        int TotalSelectedRows = 0;
2311        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:TotalSelectedRows)
2312        for (int i = 0; i < Partitions.Len(); i++){
2313          TRowIterator RowI(Partitions[i].GetVal1(), this);
2314          TRowIterator EndI(Partitions[i].GetVal2(), this);
2315          while (RowI < EndI) {
2316            if (Type != atStr) {
2317              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2318                TotalSelectedRows++;
2319              }
2320            } else {
2321              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2322                TotalSelectedRows++;
2323              }
2324            }
2325            RowI++;
2326          }
2327        }
2328        SelectedTable->ResizeTable(TotalSelectedRows);
2329        if (TotalSelectedRows == 0) {
2330          return;
2331        }
2332        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
2333        for (int i = 0; i < Partitions.Len(); i++){
2334          TIntV LocalSelectedRows;
2335          LocalSelectedRows.Reserve(PartitionSize);
2336          TRowIterator RowI(Partitions[i].GetVal1(), this);
2337          TRowIterator EndI(Partitions[i].GetVal2(), this);
2338          while (RowI < EndI) {
2339            if (Type != atStr) {
2340              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2341                LocalSelectedRows.Add(RowI.GetRowIdx());
2342              }
2343            } else {
2344              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2345                LocalSelectedRows.Add(RowI.GetRowIdx());
2346              }
2347            }
2348            RowI++;
2349          }
2350          SelectedTable->AddSelectedRows(*this, LocalSelectedRows);
2351        }
2352        SelectedTable->SetFirstValidRow();
2353      } else {
2354  #endif
2355        for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2356          if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2357            SelectedTable->AddRowI(RowI);
2358          }
2359        }
2360  #ifdef USE_OPENMP
2361      }
2362  #endif
2363    } else {
2364      for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2365        if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2366          SelectedRows.Add(RowI.GetRowIdx());
2367        }
2368      }
2369    }
2370  }
2371  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TAttrType& CompareByType, const TInt& CompareByIndex, TBool Asc) {
2372    switch (CompareByType) {
2373      case atInt:{
2374        if (IntCols[CompareByIndex][R1] > IntCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2375        if (IntCols[CompareByIndex][R1] < IntCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2376        return 0;
2377      }
2378      case atFlt:{
2379        if (FltCols[CompareByIndex][R1] > FltCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2380        if (FltCols[CompareByIndex][R1] < FltCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2381        return 0;
2382      }
2383      case atStr:{
2384        TStr S1 = GetStrValIdx(CompareByIndex, R1);
2385        TStr S2 = GetStrValIdx(CompareByIndex, R2);
2386        int CmpRes = strcmp(S1.CStr(), S2.CStr());
2387        return (Asc ? CmpRes : -CmpRes);
2388      }
2389    }
2390    return 0;
2391  }
2392  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TVec<TAttrType>& CompareByTypes, const TIntV& CompareByIndices, TBool Asc) {
2393    for (TInt i = 0; i < CompareByTypes.Len(); i++) {
2394      TInt res = CompareRows(R1, R2, CompareByTypes[i], CompareByIndices[i], Asc);
2395      if (res != 0) { return res; }
2396    }
2397    return 0;
2398  }
2399  void TTable::ISort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2400    if (StartIdx < EndIdx) {
2401      for (TInt i = StartIdx+1; i <= EndIdx; i++) {
2402        TInt Val = V[i];
2403        TInt j = i;
2404        while ((StartIdx < j) && (CompareRows(V[j-1], Val, SortByTypes, SortByIndices, Asc) > 0)) {
2405          V[j] = V[j-1];
2406          j--;
2407        }
2408        V[j] = Val;
2409      }
2410    }
2411  }
2412  TInt TTable::GetPivot(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2413    TInt L = EndIdx - StartIdx + 1;
2414    const TInt Idx1 = StartIdx + TInt::GetRnd(L);
2415    const TInt Idx2 = StartIdx + TInt::GetRnd(L);
2416    const TInt Idx3 = StartIdx + TInt::GetRnd(L);
2417    if (CompareRows(V[Idx1], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) {
2418      if (CompareRows(V[Idx2], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2419      if (CompareRows(V[Idx1], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2420      return Idx1;
2421    } else {
2422      if (CompareRows(V[Idx3], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2423      if (CompareRows(V[Idx3], V[Idx1], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2424      return Idx1;
2425    }
2426  }
2427  TInt TTable::Partition(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2428    TInt j;
2429    for (j = StartIdx; j < EndIdx; j++) {
2430      if (CompareRows(V[j], V[j+1], SortByTypes, SortByIndices, Asc) > 0) {
2431        break;
2432      }
2433    }
2434    if (j >= EndIdx) {
2435      return EndIdx+1;
2436    }
2437    TInt PivotIdx = GetPivot(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2438    TInt Pivot = V[PivotIdx];
2439    V.Swap(PivotIdx, EndIdx);
2440    TInt StoreIdx = StartIdx;
2441    for (TInt i = StartIdx; i < EndIdx; i++) {
2442      if (CompareRows(V[i], Pivot, SortByTypes, SortByIndices, Asc) <= 0) {
2443        V.Swap(i, StoreIdx);
2444        StoreIdx++;
2445      }
2446    }
2447    V.Swap(StoreIdx, EndIdx);
2448    return StoreIdx;
2449  }
2450  void TTable::QSort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2451    if (StartIdx < EndIdx) {
2452      if (EndIdx - StartIdx < 20) {
2453        ISort(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2454      } else {
2455        TInt Pivot = Partition(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2456        if (Pivot > EndIdx) {
2457          return;
2458        }
2459        int Ub = Pivot - 1;
2460        while (Ub >= StartIdx && CompareRows(
2461          V[Ub], V[Pivot], SortByTypes, SortByIndices, Asc) == 0) {
2462          Ub -= 1;
2463        }
2464        QSort(V, StartIdx, Ub, SortByTypes, SortByIndices, Asc);
2465        QSort(V, Pivot+1, EndIdx, SortByTypes, SortByIndices, Asc);
2466      }
2467    }
2468  }
2469  void TTable::Merge(TIntV& V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2470    TInt i = Idx1, j = Idx2;
2471    TIntV SortedV;
2472    while  (i < Idx2 && j < Idx3) {
2473      if (CompareRows(V[i], V[j], SortByTypes, SortByIndices, Asc) <= 0) {
2474        SortedV.Add(V[i]);
2475        i++;
2476      }
2477      else {
2478        SortedV.Add(V[j]);
2479        j++;
2480      }
2481    }
2482    while (i < Idx2) {
2483      SortedV.Add(V[i]);
2484      i++;
2485    }
2486    while (j < Idx3) {
2487      SortedV.Add(V[j]);
2488      j++;
2489    }
2490    for (TInt sz = 0; sz < Idx3 - Idx1; sz++) {
2491      V[Idx1 + sz] = SortedV[sz];
2492    }
2493  }
2494  #ifdef USE_OPENMP
2495  void TTable::QSortPar(TIntV& V, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2496    TInt NumThreads = 8; 
2497    TInt Sz = V.Len();
2498    TIntV IndV, NextV;
2499    for (TInt i = 0; i < NumThreads; i++) {
2500      IndV.Add(i * (Sz / NumThreads));
2501    }
2502    IndV.Add(Sz);
2503    omp_set_num_threads(NumThreads);
2504    #pragma omp parallel for
2505    for (int i = 0; i < NumThreads; i++) {
2506      QSort(V, IndV[i], IndV[i+1] - 1, SortByTypes, SortByIndices, Asc);
2507    }
2508    while (NumThreads > 1) {
2509      omp_set_num_threads(NumThreads / 2);
2510      #pragma omp parallel for
2511      for (int i = 0; i < NumThreads; i += 2) {
2512        Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc);
2513      }
2514      NextV.Clr();
2515      for (TInt i = 0; i < NumThreads; i+=2) {
2516        NextV.Add(IndV[i]);
2517      }
2518      NextV.Add(Sz);
2519      IndV = NextV;
2520      NumThreads = NumThreads / 2;
2521    }
2522  }
2523  #endif 
2524  void TTable::Order(const TStrV& OrderBy, TStr OrderColName, TBool ResetRankByMSC, TBool Asc) {
2525    TIntV ValidRows = TIntV(NumValidRows);
2526    if (NumRows == NumValidRows) {
2527      for (TInt i = 0; i < NumValidRows; i++) {
2528        ValidRows[i] = i;
2529      }
2530    } else {
2531      TInt i = 0;
2532      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
2533        ValidRows[i] = RI.GetRowIdx();
2534        i++;
2535      }
2536    }
2537    TVec<TAttrType> OrderByTypes(OrderBy.Len());
2538    TIntV OrderByIndices(OrderBy.Len());
2539    for (TInt i = 0; i < OrderBy.Len(); i++) {
2540      OrderByTypes[i] = GetColType(OrderBy[i]);
2541      OrderByIndices[i] = GetColIdx(OrderBy[i]);
2542    }
2543  #ifdef USE_OPENMP
2544    if (GetMP()) {
2545      QSortPar(ValidRows, OrderByTypes, OrderByIndices, Asc);
2546    } else {
2547  #endif
2548      QSort(ValidRows, 0, NumValidRows-1, OrderByTypes, OrderByIndices, Asc);
2549  #ifdef USE_OPENMP
2550    }
2551  #endif
2552    IsNextDirty = 1;
2553    if (NumValidRows > 0) {
2554      FirstValidRow = ValidRows[0];
2555    } else {
2556      FirstValidRow = Last;
2557    }
2558    for (TInt i = 0; i < NumValidRows-1; i++) {
2559      Next[ValidRows[i]] = ValidRows[i+1];
2560    }
2561    if (NumValidRows > 0) {
2562      Next[ValidRows[NumValidRows-1]] = Last;
2563      LastValidRow = ValidRows[NumValidRows-1];
2564    } else {
2565      LastValidRow = Last;
2566    }
2567    if (!OrderColName.Empty()) {
2568      TIntV RankCol = TIntV(NumRows);
2569      for (TInt i = 0; i < NumValidRows; i++) {
2570        RankCol[ValidRows[i]] = i;
2571      }
2572      if (ResetRankByMSC) {
2573        for (TInt i = 1; i < NumValidRows; i++) {
2574          TStr GroupName = OrderBy[0];
2575          if (GetStrVal(GroupName, ValidRows[i]) != GetStrVal(GroupName, ValidRows[i-1])) { 
2576            RankCol[ValidRows[i]] = 0;
2577          } else {
2578            RankCol[ValidRows[i]] = RankCol[ValidRows[i-1]] + 1;
2579          }
2580        }
2581      }
2582      IntCols.Add(RankCol);
2583      AddSchemaCol(OrderColName, atInt);
2584      AddColType(OrderColName, atInt, IntCols.Len()-1);
2585    }
2586  }
2587  void TTable::Defrag() {
2588    TInt FreeIndex = 0;
2589    TIntV Mapping;  
2590    TInt IdColIdx = GetColIdx(IdColName);
2591    for (TInt i = 0; i < Next.Len(); i++) {
2592      if (Next[i] != TTable::Invalid) {  
2593        if (FreeIndex == 0) {
2594          Assert (i == FirstValidRow);
2595          FirstValidRow = 0;
2596        }
2597        if (Next[i] != Last) { 
2598          Next[FreeIndex] = FreeIndex + 1;
2599          Mapping.Add(FreeIndex);
2600        } else {
2601          Next[FreeIndex] = Last;
2602          LastValidRow = FreeIndex;
2603          Mapping.Add(Last);
2604        }
2605        RowIdMap.AddDat(IntCols[IdColIdx][i], FreeIndex);
2606        for (TInt j = 0; j < IntCols.Len(); j++) {
2607          IntCols[j][FreeIndex] = IntCols[j][i];
2608        }
2609        for (TInt j = 0; j < FltCols.Len(); j++) {
2610          FltCols[j][FreeIndex] = FltCols[j][i];
2611        }
2612        for (TInt j = 0; j < StrColMaps.Len(); j++) {
2613          StrColMaps[j][FreeIndex] = StrColMaps[j][i];
2614        }
2615        FreeIndex++;
2616      } else {
2617        NumRows--;
2618        Mapping.Add(TTable::Invalid);
2619      }
2620    }
2621    Assert (NumValidRows == NumRows);
2622  }
2623  void TTable::SelectFirstNRows(const TInt& N) {
2624    if (N == 0) {
2625      LastValidRow = -1;
2626      return;
2627    }
2628    TRowIterator RowI = BegRI();
2629    TInt count = 1;
2630    while (count < N) {
2631      if (!(RowI < EndRI())) {
2632        return; 
2633      }
2634      RowI++;
2635      count++;
2636    }
2637    NumValidRows = N;
2638    TInt LastId = RowI.GetRowIdx();
2639    if (Next[LastId] == Last) {
2640      return; 
2641    }
2642    TInt CurrId = LastId;
2643    while (Next[CurrId] != Last) {
2644      Assert(Next[CurrId] != Invalid);
2645      TInt NextId = Next[CurrId];
2646      Next[CurrId] = Invalid;
2647      CurrId = NextId;
2648    }
2649    Next[LastId] = Last;
2650    LastValidRow = LastId;
2651  }
2652  inline void TTable::CheckAndAddIntNode(PNEANet Graph, THashSet<TInt>& NodeVals, TInt NodeId) {
2653    if (!NodeVals.IsKey(NodeId)) {
2654      Graph->AddNode(NodeId);
2655      NodeVals.AddKey(NodeId);
2656    }
2657  }
2658  inline void TTable::AddEdgeAttributes(PNEANet& Graph, int RowId) {
2659    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
2660      TStr ColName = EdgeAttrV[i];
2661      TAttrType T = GetColType(ColName);
2662      TInt Index = GetColIdx(ColName);
2663      switch (T) {
2664        case atInt:
2665          Graph->AddIntAttrDatE(RowId, IntCols[Index][RowId], ColName);
2666          break;
2667        case atFlt:
2668          Graph->AddFltAttrDatE(RowId, FltCols[Index][RowId], ColName);
2669          break;
2670        case atStr:
2671          Graph->AddStrAttrDatE(RowId, GetStrValIdx(Index, RowId), ColName);
2672          break;
2673      }
2674    }
2675  }
2676  inline void TTable::AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId, THash<TInt, TStrIntVH>& NodeIntAttrs,
2677    THash<TInt, TStrFltVH>& NodeFltAttrs, THash<TInt, TStrStrVH>& NodeStrAttrs) {
2678    for (TInt i = 0; i < NodeAttrV.Len(); i++) {
2679      TStr ColAttr = NodeAttrV[i];
2680      TAttrType CT = GetColType(ColAttr);
2681      int ColId = GetColIdx(ColAttr);
2682      for (TInt i = 0; i < CommonNodeAttrs.Len(); i++) {
2683        if (CommonNodeAttrs[i].Val1 == ColAttr || CommonNodeAttrs[i].Val2 == ColAttr) {
2684          ColAttr = CommonNodeAttrs[i].Val3;
2685          break;
2686        }
2687      }
2688      if (CT == atInt) {
2689        if (!NodeIntAttrs.IsKey(NId)) { NodeIntAttrs.AddKey(NId); }
2690        if (!NodeIntAttrs.GetDat(NId).IsKey(ColAttr)) { NodeIntAttrs.GetDat(NId).AddKey(ColAttr); }
2691        NodeIntAttrs.GetDat(NId).GetDat(ColAttr).Add(IntCols[ColId][RowId]);
2692      } else if (CT == atFlt) {
2693        if (!NodeFltAttrs.IsKey(NId)) { NodeFltAttrs.AddKey(NId); }
2694        if (!NodeFltAttrs.GetDat(NId).IsKey(ColAttr)) { NodeFltAttrs.GetDat(NId).AddKey(ColAttr); }
2695        NodeFltAttrs.GetDat(NId).GetDat(ColAttr).Add(FltCols[ColId][RowId]);
2696      } else {
2697        if (!NodeStrAttrs.IsKey(NId)) { NodeStrAttrs.AddKey(NId); }
2698        if (!NodeStrAttrs.GetDat(NId).IsKey(ColAttr)) { NodeStrAttrs.GetDat(NId).AddKey(ColAttr); }
2699        NodeStrAttrs.GetDat(NId).GetDat(ColAttr).Add(GetStrValIdx(ColId, RowId));
2700      }
2701    }
2702  }
2703  PNEANet TTable::BuildGraph(const TIntV& RowIds, TAttrAggr AggrPolicy) {
2704    PNEANet Graph = TNEANet::New();
2705    const TAttrType NodeType = GetColType(SrcCol);
2706    Assert(NodeType == GetColType(DstCol));
2707    const TInt SrcColIdx = GetColIdx(SrcCol);
2708    const TInt DstColIdx = GetColIdx(DstCol);
2709    THash<TFlt, TInt> FltNodeVals;
2710    THash<TInt, TStrIntVH> NodeIntAttrs;
2711    THash<TInt, TStrFltVH> NodeFltAttrs;
2712    THash<TInt, TStrStrVH> NodeStrAttrs;
2713    for (TVec<TInt>::TIter it = RowIds.BegI(); it < RowIds.EndI(); it++) {
2714      TInt CurrRowIdx = *it;
2715      TInt SVal, DVal;
2716      if (NodeType == atFlt) {
2717        TFlt FSVal = FltCols[SrcColIdx][CurrRowIdx];
2718        SVal = CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
2719        TFlt FDVal = FltCols[SrcColIdx][CurrRowIdx];
2720        DVal = CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
2721      } else if (NodeType == atInt || NodeType == atStr) {
2722        if (NodeType == atInt) {
2723          SVal = IntCols[SrcColIdx][CurrRowIdx];
2724          DVal = IntCols[DstColIdx][CurrRowIdx];
2725        } else {
2726          SVal = StrColMaps[SrcColIdx][CurrRowIdx];
2727          if (strlen(Context->StringVals.GetKey(SVal)) == 0) { continue; }  
2728          DVal = StrColMaps[DstColIdx][CurrRowIdx];
2729          if (strlen(Context->StringVals.GetKey(DVal)) == 0) { continue; }  
2730        }
2731        if (!Graph->IsNode(SVal)) { Graph->AddNode(SVal); }
2732        if (!Graph->IsNode(DVal)) { Graph->AddNode(DVal); }
2733      } 
2734      Graph->AddEdge(SVal, DVal, CurrRowIdx);
2735      if (EdgeAttrV.Len() > 0) { AddEdgeAttributes(Graph, CurrRowIdx); }
2736      if (SrcNodeAttrV.Len() > 0) { 
2737        AddNodeAttributes(SVal, SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2738      }
2739      if (DstNodeAttrV.Len() > 0) {
2740        AddNodeAttributes(DVal, DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2741      }
2742    }
2743    if (SrcNodeAttrV.Len() > 0 || DstNodeAttrV.Len() > 0) {
2744      for (TNEANet::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
2745        TInt NId = NodeI.GetId();
2746        if (NodeIntAttrs.IsKey(NId)) {
2747          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
2748          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it < IntAttrVals.EndI(); it++) {
2749            TInt AttrVal = AggregateVector<TInt>(it.GetDat(), AggrPolicy);
2750            Graph->AddIntAttrDatN(NId, AttrVal, it.GetKey());
2751          }
2752        }
2753        if (NodeFltAttrs.IsKey(NId)) {
2754          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
2755          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it < FltAttrVals.EndI(); it++) {
2756            TFlt AttrVal = AggregateVector<TFlt>(it.GetDat(), AggrPolicy);
2757            Graph->AddFltAttrDatN(NId, AttrVal, it.GetKey());
2758          }
2759        }
2760        if (NodeStrAttrs.IsKey(NId)) {
2761          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
2762          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it < StrAttrVals.EndI(); it++) {
2763            TStr AttrVal = AggregateVector<TStr>(it.GetDat(), AggrPolicy);
2764            Graph->AddStrAttrDatN(NId, AttrVal, it.GetKey());
2765          }
2766        }
2767      }
2768    }
2769    return Graph;
2770  }
2771  void TTable::InitRowIdBuckets(int NumBuckets) {
2772    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2773      RowIdBuckets[i].Clr();
2774    }
2775    RowIdBuckets.Clr();
2776    RowIdBuckets.Gen(NumBuckets);
2777    for (TInt i = 0; i < NumBuckets; i++) {
2778      RowIdBuckets[i].Gen(10, 0);
2779    }
2780  }
2781  void TTable::FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize, TInt StartVal, TInt EndVal) {
2782    Assert (JumpSize <= WindowSize);
2783    int NumBuckets, MinBucket, MaxBucket;
2784    TInt SplitColId = GetColIdx(SplitAttr);
2785    if (StartVal == TInt::Mn || EndVal == TInt::Mx) {
2786      TInt MinValue = TInt::Mx;
2787      TInt MaxValue = TInt::Mn;
2788      for (TInt i = 0; i < Next.Len(); i++) {
2789        if (Next[i] != Invalid) { 
2790          if (MinValue > IntCols[SplitColId][i]) {
2791            MinValue = IntCols[SplitColId][i];
2792          }
2793          if (MaxValue < IntCols[SplitColId][i]) {
2794            MaxValue = IntCols[SplitColId][i];
2795          }
2796        }
2797      }
2798      if (StartVal == TInt::Mn) StartVal = MinValue;
2799      if (EndVal == TInt::Mx) EndVal = MaxValue;
2800    }
2801    NumBuckets = 1;
2802    if (JumpSize > 0) {
2803      NumBuckets = (EndVal - StartVal)/JumpSize + 1;
2804    }
2805    InitRowIdBuckets(NumBuckets);
2806    for (TInt i = 0; i < Next.Len(); i++) {
2807      if (Next[i] == Invalid) { continue; }
2808      int SplitVal = IntCols[SplitColId][i];
2809      if (SplitVal < StartVal || SplitVal > EndVal) { continue; }
<span onclick='openModal()' class='match'>2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
</span>2817        if (RowVal < WindowSize) { MinBucket = 0; }
2818        else { MinBucket = (RowVal-WindowSize)/JumpSize + 1; }
2819        MaxBucket = RowVal/JumpSize;  
2820      }
2821      for (TInt j = MinBucket; j <= MaxBucket; j++) { RowIdBuckets[j].Add(i); }
2822    }
2823  }
2824  void TTable::FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals) {
2825    TInt SplitColId = GetColIdx(SplitAttr);
2826    int NumBuckets = SplitIntervals.Len();
2827    InitRowIdBuckets(NumBuckets);
2828    for (TInt i = 0; i < Next.Len(); i++) {
2829      if (Next[i] == Invalid) { continue; }
2830      int SplitVal = IntCols[SplitColId][i];
2831      for (TInt j = 0; j < SplitIntervals.Len(); j++) { 
2832        if (SplitVal >= SplitIntervals[j].Val1 && SplitVal < SplitIntervals[j].Val2) {
2833          RowIdBuckets[j].Add(i);
2834        }
2835      }
2836    }
2837  }
2838  TVec<PNEANet> TTable::GetGraphsFromSequence(TAttrAggr AggrPolicy) {
2839    TVec<PNEANet> GraphSequence;
2840    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2841      if (RowIdBuckets[i].Len() == 0) { continue; }
2842      PNEANet PNet = BuildGraph(RowIdBuckets[i], AggrPolicy);
2843      GraphSequence.Add(PNet);
2844    }
2845    return GraphSequence;
2846  }
2847  PNEANet TTable::GetFirstGraphFromSequence(TAttrAggr AggrPolicy) {
2848    CurrBucket = -1;
2849    this->AggrPolicy = AggrPolicy;
2850    return GetNextGraphFromSequence();
2851  }
2852  PNEANet TTable::GetNextGraphFromSequence() {
2853    CurrBucket++;
2854    while (CurrBucket < RowIdBuckets.Len() && RowIdBuckets[CurrBucket].Len() == 0) {
2855      CurrBucket++;
2856    }
2857    if (CurrBucket >= RowIdBuckets.Len()) { return NULL; }
2858    return BuildGraph(RowIdBuckets[CurrBucket], AggrPolicy);
2859  }
2860  TVec<PNEANet> TTable::ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2861    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2862    printf("buckets filled\n");
2863    return GetGraphsFromSequence(AggrPolicy);  
2864  }
2865  TVec<PNEANet> TTable::ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2866    FillBucketsByInterval(SplitAttr, SplitIntervals);
2867    return GetGraphsFromSequence(AggrPolicy);
2868  }
2869  TVec<PNEANet> TTable::ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy) {
2870    return ToGraphSequence(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2871  }
2872  PNEANet TTable::ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2873    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2874    return GetFirstGraphFromSequence(AggrPolicy);  
2875  }
2876  PNEANet TTable::ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2877    FillBucketsByInterval(SplitAttr, SplitIntervals);
2878    return GetFirstGraphFromSequence(AggrPolicy);
2879  }
2880  PNEANet TTable::ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy) {
2881    return ToGraphSequenceIterator(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2882  }
2883  PNEANet TTable::NextGraphIterator() {
2884    return GetNextGraphFromSequence();
2885  }
2886  TBool TTable::IsLastGraphOfSequence() {
2887    return CurrBucket >= RowIdBuckets.Len() - 1;
2888  }
2889  PTable TTable::GetNodeTable(const PNEANet& Network, TTableContext* Context) {
2890    Schema SR;
2891    SR.Add(TPair<TStr,TAttrType>("node_id",atInt));
2892    TStrV IntAttrNames;
2893    TStrV FltAttrNames;
2894    TStrV StrAttrNames;
2895    TNEANet::TNodeI NodeI = Network->BegNI();
2896    NodeI.GetIntAttrNames(IntAttrNames);
2897    NodeI.GetFltAttrNames(FltAttrNames);
2898    NodeI.GetStrAttrNames(StrAttrNames);
2899    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2900      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2901    }
2902    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2903      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2904    }
2905    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2906      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2907    }
2908    PTable T = New(SR, Context);
2909    TInt Cnt = 0;
2910    while (NodeI < Network->EndNI()) {
2911      T->IntCols[0].Add(NodeI.GetId());
2912      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2913        T->IntCols[i+1].Add(Network->GetIntAttrDatN(NodeI,IntAttrNames[i]));
2914      }
2915      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2916        T->FltCols[i].Add(Network->GetFltAttrDatN(NodeI,FltAttrNames[i]));
2917      }
2918      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2919        T->AddStrVal(i, Network->GetStrAttrDatN(NodeI,StrAttrNames[i]));
2920      }
2921      Cnt++;
2922      NodeI++;
2923    }
2924    T->NumRows = Cnt;
2925    T->NumValidRows = T->NumRows;
2926    T->Next = TIntV(T->NumRows,0);
2927    for (TInt i = 0; i < T->NumRows-1; i++) {
2928      T->Next.Add(i+1);
2929    }
2930    T->LastValidRow = T->NumRows-1;
2931    T->Next.Add(Last);
2932    return T;
2933  }
2934  PTable TTable::GetEdgeTable(const PNEANet& Network, TTableContext* Context) {
2935    Schema SR;
2936    SR.Add(TPair<TStr,TAttrType>("edg_id",atInt));
2937    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2938    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2939    TStrV IntAttrNames;
2940    TStrV FltAttrNames;
2941    TStrV StrAttrNames;
2942    TNEANet::TEdgeI EdgeI = Network->BegEI();
2943    EdgeI.GetIntAttrNames(IntAttrNames);
2944    EdgeI.GetFltAttrNames(FltAttrNames);
2945    EdgeI.GetStrAttrNames(StrAttrNames);
2946    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2947      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2948    }
2949    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2950      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2951    }
2952    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2953      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2954    }
2955    PTable T = New(SR, Context);
2956    TInt Cnt = 0;
2957    while (EdgeI < Network->EndEI()) {
2958      T->IntCols[0].Add(EdgeI.GetId());
2959      T->IntCols[1].Add(EdgeI.GetSrcNId());
2960      T->IntCols[2].Add(EdgeI.GetDstNId());
2961      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2962        T->IntCols[i+3].Add(Network->GetIntAttrDatE(EdgeI,IntAttrNames[i]));
2963      }
2964      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2965        T->FltCols[i].Add(Network->GetFltAttrDatE(EdgeI,FltAttrNames[i]));
2966      }
2967      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2968        T->AddStrVal(i, Network->GetStrAttrDatE(EdgeI,StrAttrNames[i]));
2969      }
2970      Cnt++;
2971      EdgeI++;
2972    }
2973    T->NumRows = Cnt;
2974    T->NumValidRows = T->NumRows;
2975    T->Next = TIntV(T->NumRows,0);
2976    for (TInt i = 0; i < T->NumRows-1; i++) {
2977      T->Next.Add(i+1);
2978    }
2979    T->LastValidRow = T->NumRows-1;
2980    T->Next.Add(Last);
2981    return T;
2982  }
2983  #ifdef GCC_ATOMIC
2984  PTable TTable::GetEdgeTablePN(const PNGraphMP& Network, TTableContext* Context){
2985    Schema SR;
2986    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2987    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2988    TNGraphMP::TEdgeI FirstEI = Network->BegEI();
2989    PTable T = New(SR, Context);
2990    TInt NumEdges = Network->GetEdges();
2991    TInt NumPartitions = omp_get_max_threads()*CHUNKS_PER_THREAD;
2992    TInt PartitionSize = NumEdges/NumPartitions;
2993    if (PartitionSize*NumPartitions < NumEdges) { NumPartitions++;}
2994    typedef TPair<TNGraphMP::TEdgeI, TNGraphMP::TEdgeI> TEIPr;
2995    TVec<TEIPr> Partitions;
2996    TIntV PartitionSizes;
2997    TNGraphMP::TEdgeI currStart = FirstEI;
2998    TInt currCount = 0;
2999    while (FirstEI < Network->EndEI()){
3000      if (currCount == PartitionSize) {
3001        Partitions.Add(TEIPr(currStart, FirstEI));
3002        currStart = FirstEI;
3003        PartitionSizes.Add(currCount);
3004        currCount = 0;
3005      }
3006      FirstEI++;
3007      currCount++;
3008    }
3009    Partitions.Add(TEIPr(currStart, FirstEI));
3010    PartitionSizes.Add(currCount);
3011    T->ResizeTable(NumEdges);
3012    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3013    for (int p = 0; p < Partitions.Len(); p++) {
3014      TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();
3015      TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();
3016      int start = T->GetEmptyRowsStart(PartitionSizes[p]);
3017      while (EdgeI < EndI) {
3018        T->IntCols[0][start] = EdgeI.GetSrcNId();
3019        T->IntCols[1][start] = EdgeI.GetDstNId();
3020        EdgeI++;
3021        if (EdgeI < EndI) { T->Next[start] = start+1;}
3022        start++;
3023      }
3024    }
3025    Assert(T->NumRows == NumEdges);
3026    return T;
3027  }
3028  #endif 
3029  PTable TTable::GetFltNodePropertyTable(const PNEANet& Network, const TIntFltH& Property, 
3030   const TStr& NodeAttrName, const TAttrType& NodeAttrType, const TStr& PropertyAttrName, 
3031   TTableContext* Context) {
3032    Schema SR;
3033    SR.Add(TPair<TStr,TAttrType>(NodeAttrName,NodeAttrType));
3034    SR.Add(TPair<TStr,TAttrType>(PropertyAttrName,atFlt));
3035    PTable T = New(SR, Context);
3036    TInt NodeColIdx = T->GetColIdx(NodeAttrName);
3037    TInt Cnt = 0;
3038    for (TNEANet::TNodeI NodeI = Network->BegNI(); NodeI < Network->EndNI(); NodeI++) {
3039      switch (NodeAttrType) {
3040        case atInt:
3041          T->IntCols[NodeColIdx].Add(Network->GetIntAttrDatN(NodeI,NodeAttrName));
3042          break;
3043        case atFlt:
3044          T->FltCols[NodeColIdx].Add(Network->GetFltAttrDatN(NodeI,NodeAttrName));
3045          break;
3046        case atStr:
3047          T->AddStrVal(TInt(0), Network->GetStrAttrDatN(NodeI,NodeAttrName));
3048          break;
3049      }
3050      T->FltCols[0].Add(Property.GetDat(NodeI.GetId()));
3051      Cnt++;
3052    }
3053    T->NumRows = Cnt;
3054    T->NumValidRows = T->NumRows;
3055    T->Next = TIntV(T->NumRows,0);
3056    for (TInt i = 0; i < T->NumRows-1; i++) {
3057      T->Next.Add(i+1);
3058    }
3059    T->LastValidRow = T->NumRows-1;
3060    T->Next.Add(Last);
3061    return T;
3062  }
3063  PTable TTable::IsNextK(const TStr& OrderCol, TInt K, const TStr& GroupBy, const TStr& RankColName) {
3064    TStrV OrderBy;
3065    if (GroupBy.Empty()) {
3066      OrderBy.Add(OrderCol);
3067    } else {
3068      OrderBy.Add(GroupBy);
3069      OrderBy.Add(OrderCol);
3070    }
3071    if (RankColName.Empty()) {
3072      Order(OrderBy);
3073    } else {
3074      Order(OrderBy, RankColName, true);
3075    }
3076    TAttrType GroupByAttrType = GetColType(GroupBy);
3077    PTable T = InitializeJointTable(*this);
3078    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3079      TInt Succ = RI.GetRowIdx();
3080      TBool OutOfGroup = false;
3081      for (TInt i = 0; i < K; i++) {
3082        Succ = Next[Succ];
3083        if (Succ == Last) { break; }
3084        switch (GroupByAttrType) {
3085          case atInt:
3086            if (GetIntVal(GroupBy, Succ) != RI.GetIntAttr(GroupBy)) { OutOfGroup = true; }
3087            break;
3088          case atFlt:
3089            if (GetFltVal(GroupBy, Succ) != RI.GetFltAttr(GroupBy)) { OutOfGroup = true; }
3090            break;
3091          case atStr:
3092            if (GetStrVal(GroupBy, Succ) != RI.GetStrAttr(GroupBy)) { OutOfGroup = true; }
3093            break;
3094        }
3095        if (OutOfGroup) { break; }  
3096        T->AddJointRow(*this, *this, RI.GetRowIdx(), Succ);
3097      }
3098    }
3099    return T;
3100  }
3101  void TTable::PrintSize(){
3102  	printf("Total number of rows: %d\n", NumRows.Val);
3103  	printf("Number of valid rows: %d\n", NumValidRows.Val);
3104  	printf("Number of Int columns: %d\n", IntCols.Len());
3105  	printf("Number of Flt columns: %d\n", FltCols.Len());
3106  	printf("Number of Str columns: %d\n", StrColMaps.Len());
3107  	TSize MemUsed = GetMemUsedKB();
3108  	printf("Approximate table size is %s KB\n", TUInt64::GetStr(MemUsed).CStr());
3109  }
3110  TSize TTable::GetMemUsedKB() {
3111    TSize ApproxSize = 0;
3112    ApproxSize += Next.GetMemUsed()/1000;  
3113    for(int i = 0; i < IntCols.Len(); i++){
3114    	ApproxSize += IntCols[i].GetMemUsed()/1000;
3115    }
3116    for(int i = 0; i < FltCols.Len(); i++){
3117    	ApproxSize += FltCols[i].GetMemUsed()/1000;
3118    }
3119    for(int i = 0; i < StrColMaps.Len(); i++){
3120    	ApproxSize += StrColMaps[i].GetMemUsed()/1000;
3121    }
3122    ApproxSize += RowIdMap.GetMemUsed()/1000;
3123    ApproxSize += GroupIDMapping.GetMemUsed()/1000;
3124    ApproxSize += GroupMapping.GetMemUsed()/1000;
3125    ApproxSize += RowIdBuckets.GetMemUsed() / 1000;
3126    return ApproxSize;
3127  }
3128  void TTable::PrintContextSize(){
3129  	printf("Number of strings in pool: ");
3130  	printf("%d\n", Context->StringVals.Len());
3131  	printf("Number of entries in hash table: ");
3132  	printf("%d\n", Context->StringVals.Reserved());
3133  	TSize MemUsed = GetContextMemUsedKB();
3134  	printf("Approximate context size is %s KB\n",
3135            TUInt64::GetStr(MemUsed).CStr());
3136  }
3137  TSize TTable::GetContextMemUsedKB(){
3138  	TSize ApproxSize = 0;
3139  	ApproxSize += Context->StringVals.GetMemUsed();
3140  	return ApproxSize;
3141  }
3142  void TTable::AddTable(const TTable& T) {
3143    for (TInt c = 0; c < Sch.Len(); c++) {
3144      TStr ColName = GetSchemaColName(c);
3145      TInt ColIdx = GetColIdx(ColName);
3146      TInt TColIdx = ColName == IdColName ? T.GetColIdx(T.IdColName) : T.GetColIdx(ColName);
3147      if (TColIdx < 0) { TExcept::Throw("when adding a table, it must contain all columns of source table!"); }
3148      switch (GetColType(ColName)) { 
3149      case atInt:
3150         IntCols[ColIdx].AddV(T.IntCols[TColIdx]);
3151         break;
3152      case atFlt:
3153         FltCols[ColIdx].AddV(T.FltCols[TColIdx]);
3154         break;
3155      case atStr:
3156         StrColMaps[ColIdx].AddV(T.StrColMaps[TColIdx]);
3157         break;
3158      }
3159    }
3160    TIntV TNext(T.Next);
3161    for (TInt i = 0; i < TNext.Len(); i++) {
3162      if (TNext[i] != Last && TNext[i] != Invalid) { TNext[i] += NumRows; }
3163    }
3164    Next.AddV(TNext);
3165    if (LastValidRow >= 0) {
3166      Next[LastValidRow] = NumRows + T.FirstValidRow;
3167    }
3168    LastValidRow = NumRows + T.LastValidRow;
3169    NumRows += T.NumRows;
3170    NumValidRows += T.NumValidRows;
3171  }
3172  void TTable::GetCollidingRows(const TTable& Table, THashSet<TInt>& Collisions) {
3173    TIntV UniqueVec;
3174    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
3175    TStrV GroupBy;
3176    TIntV IntGroupByCols;
3177    TIntV FltGroupByCols;
3178    TIntV StrGroupByCols;
3179    TInt IKLen, FKLen, SKLen;
3180    for (TInt c = 0; c < Sch.Len(); c++) {
3181      if (Sch[c].Val1 == IdColName) {
3182        if (Table.Sch[c].Val1 != Table.GetIdColName()) {
3183          TExcept::Throw("GetCollidingRows: schemas do not match!");
3184        }
3185        continue;
3186      }
3187      if (Sch[c] != Table.Sch[c]) {
3188        printf("(%s,%d) != (%s,%d)\n", Sch[c].Val1.CStr(), Sch[c].Val2, Table.Sch[c].Val1.CStr(), Table.Sch[c].Val2); 
3189        TExcept::Throw("GetCollidingRows: schemas do not match!");
3190      }
3191      GroupBy.Add(NormalizeColName(Sch[c].Val1));
3192      TPair<TAttrType, TInt> ColType = Table.GetColTypeMap(Sch[c].Val1);
3193      switch (ColType.Val1) {
3194        case atInt:
3195          IntGroupByCols.Add(ColType.Val2);
3196          break;
3197        case atFlt:
3198          FltGroupByCols.Add(ColType.Val2);
3199          break;
3200        case atStr:
3201          StrGroupByCols.Add(ColType.Val2);
3202          break;
3203      }
3204    }
3205    IKLen = IntGroupByCols.Len();
3206    FKLen = FltGroupByCols.Len();
3207    SKLen = StrGroupByCols.Len();
3208    GroupAux(GroupBy, Grouping, true, "", false, UniqueVec, true);
3209    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3210      TIntV IKey(IKLen + SKLen, 0);
3211      TFltV FKey(FKLen, 0);
3212      for (TInt c = 0; c < IKLen; c++) {
3213        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
3214      }
3215      for (TInt c = 0; c < FKLen; c++) {
3216        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
3217      }
3218      for (TInt c = 0; c < SKLen; c++) {
3219        IKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
3220      }
3221      TGroupKey GroupKey = TGroupKey(IKey, FKey);
3222      TInt RowIdx = it.GetRowIdx();
3223      if (Grouping.IsKey(GroupKey)) {
3224        Collisions.AddKey(RowIdx);
3225      }
3226    }
3227  }
3228  void TTable::StoreIntCol(const TStr& ColName, const TIntV& ColVals) {
3229    if (ColVals.Len() != NumRows) {
3230      printf("new column dimension must agree with number of rows\n");
3231      return;
3232    }
3233    AddSchemaCol(ColName, atInt);
3234    IntCols.Add(TIntV(NumRows));
3235    TInt ColIdx = IntCols.Len()-1;
3236    TInt i = 0;
3237    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3238      IntCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3239      i++;
3240    }
3241    TInt L = IntCols.Len();
3242    AddColType(ColName, atInt, L-1);
3243  }
3244  void TTable::StoreFltCol(const TStr& ColName, const TFltV& ColVals) {
3245    if (ColVals.Len() != NumRows) {
3246      printf("new column dimension must agree with number of rows\n");
3247      return;
3248    }
3249    AddSchemaCol(ColName, atFlt);
3250    FltCols.Add(TFltV(NumRows));
3251    TInt ColIdx = FltCols.Len()-1;
3252    TInt i = 0;
3253    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3254      FltCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3255      i++;
3256    }
3257    TInt L = FltCols.Len();
3258    AddColType(ColName, atFlt, L-1);
3259  }
3260  void TTable::StoreStrCol(const TStr& ColName, const TStrV& ColVals) {
3261    if (ColVals.Len() != NumRows) {
3262      printf("new column dimension must agree with number of rows\n");
3263      return;
3264    }
3265    AddSchemaCol(ColName, atStr);
3266    StrColMaps.Add(TIntV(NumRows,0));
3267    TInt ColIdx = FltCols.Len()-1;
3268    TInt i = 0;
3269    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3270      TInt Key = Context->StringVals.GetKeyId(ColVals[i]);
3271      if (Key == -1) { Context->StringVals.AddKey(ColVals[i]); }
3272      StrColMaps[ColIdx][RI.GetRowIdx()] = Key;
3273      i++;
3274    }
3275    TInt L = StrColMaps.Len();
3276    AddColType(ColName, atStr, L-1);
3277  }
3278  void TTable::UpdateTableForNewRow() {
3279    if (LastValidRow >= 0) {
3280      Next[LastValidRow] = NumRows;
3281    }
3282    Next.Add(Last);
3283    LastValidRow = NumRows;
3284    NumRows++;
3285    NumValidRows++;
3286  }
3287  #ifdef GCC_ATOMIC
3288  void TTable::SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal){
3289      if(!GetMP()){ TExcept::Throw("Not Using MP!");}
3290  	TIntPrV Partitions;
3291  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3292  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3293  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3294  	for (int i = 0; i < Partitions.Len(); i++){
3295  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3296  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3297  		while(RowI < EndI){
3298  			FltCols[UpdateColIdx][RowI.GetRowIdx()] = DefaultFltVal;
3299  			RowI++;
3300  		}
3301  	}
3302  }
3303  int sync_bool_compare_and_swap(int *lock) {
3304    return(__sync_bool_compare_and_swap(lock, 0, 1));
3305  }
3306  void TTable::UpdateFltFromTableMP(const TStr& KeyAttr, const TStr& UpdateAttr,
3307      const TTable& Table, const TStr& FKeyAttr, const TStr& ReadAttr,
3308      TFlt DefaultFltVal) {
3309  	if (!GetMP()) {
3310      TExcept::Throw("Not Using MP!");
3311    }
3312    TAttrType KeyType = GetColType(KeyAttr);
3313    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3314    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3315    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3316      TExcept::Throw("Expecting Float values");
3317    }
3318    TStr NKeyAttr = NormalizeColName(KeyAttr);
3319    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3320    TInt FKeyColIdx = GetColIdx(FKeyAttr);
3321    TInt ReadColIdx = GetColIdx(ReadAttr);
3322    SetFltColToConstMP(UpdateColIdx, DefaultFltVal);
3323  	TIntPrV Partitions;
3324  	Table.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3325  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3326  	TIntV Locks(NumRows);
3327  	Locks.PutAll(0);	
3328    switch (KeyType) {
3329      case atInt: {
3330          THashMP<TInt,TIntV> Grouping;
3331          GroupByIntColMP(NKeyAttr, Grouping, true);
3332          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3333  			  for (int i = 0; i < Partitions.Len(); i++) {
3334  				  TRowIterator RowI(Partitions[i].GetVal1(), &Table);
3335  				  TRowIterator EndI(Partitions[i].GetVal2(), &Table);
3336  				  while (RowI < EndI) {
3337              TInt K = RowI.GetIntAttr(FKeyColIdx);
3338              if (Grouping.IsKey(K)) {
3339                TIntV& UpdateRows = Grouping.GetDat(K);
3340                for (int j = 0; j < UpdateRows.Len(); j++) {
3341                  int* lock = &Locks[UpdateRows[j]].Val;
3342                  if (!sync_bool_compare_and_swap(lock)) {
3343                    continue;
3344                  }
3345    							  FltCols[UpdateColIdx][UpdateRows[j]] = RowI.GetFltAttr(ReadColIdx);
3346                } 
3347              } 
3348              RowI++;
3349            } 
3350          }	
3351        } 
3352        break;
3353      default:
3354        break;
3355    } 
3356  }
3357  #endif	
3358  void TTable::UpdateFltFromTable(const TStr& KeyAttr, const TStr& UpdateAttr, const TTable& Table, 
3359    const TStr& FKeyAttr, const TStr& ReadAttr, TFlt DefaultFltVal){
3360    if(!IsColName(KeyAttr)){ TExcept::Throw("Bad KeyAttr parameter");}
3361    if(!IsColName(UpdateAttr)){ TExcept::Throw("Bad UpdateAttr parameter");}
3362    if(!Table.IsColName(FKeyAttr)){ TExcept::Throw("Bad FKeyAttr parameter");}
3363    if(!Table.IsColName(ReadAttr)){ TExcept::Throw("Bad ReadAttr parameter");}
3364  #ifdef GCC_ATOMIC
3365    if(GetMP()){
3366      UpdateFltFromTableMP(KeyAttr, UpdateAttr,Table, FKeyAttr, ReadAttr, DefaultFltVal);
3367      return;
3368    }
3369  #endif	
3370    TAttrType KeyType = GetColType(KeyAttr);
3371    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3372    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3373    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3374      TExcept::Throw("Expecting Float values");
3375    }
3376    TStr NKeyAttr = NormalizeColName(KeyAttr);
3377    TStr NUpdateAttr = NormalizeColName(UpdateAttr);
3378    TStr NFKeyAttr = Table.NormalizeColName(FKeyAttr);
3379    TStr NReadAttr = Table.NormalizeColName(ReadAttr);
3380    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3381    for(TRowIterator iter = BegRI(); iter < EndRI(); iter++){
3382      FltCols[UpdateColIdx][iter.GetRowIdx()] = DefaultFltVal;
3383    }
3384    switch(KeyType) {
3385      case atInt: {
3386          TIntIntVH Grouping;
3387          GroupByIntCol(NKeyAttr, Grouping, TIntV(), true, true);
3388          for (TRowIterator RI = Table.BegRI(); RI < Table.EndRI(); RI++) {
3389            TInt K = RI.GetIntAttr(NFKeyAttr);
3390            if (Grouping.IsKey(K)) {
3391              TIntV& UpdateRows = Grouping.GetDat(K);
3392              for (int i = 0; i < UpdateRows.Len(); i++) {
3393                FltCols[UpdateColIdx][UpdateRows[i]] = RI.GetFltAttr(NReadAttr);
3394              } 
3395            } 
3396          } 
3397        } 
3398        break;
3399      default:
3400        break;
3401    } 
3402  }
3403  void TTable::AddRowI(const TRowIterator& RI) {
3404    for (TInt c = 0; c < Sch.Len(); c++) {
3405      TStr ColName = GetSchemaColName(c);
3406      if (ColName == IdColName) { continue; }
3407      TInt ColIdx = GetColIdx(ColName);
3408      switch (GetColType(ColName)) {
3409      case atInt:
3410         IntCols[ColIdx].Add(RI.GetIntAttr(ColName));
3411         break;
3412      case atFlt:
3413         FltCols[ColIdx].Add(RI.GetFltAttr(ColName));
3414         break;
3415      case atStr:
3416         StrColMaps[ColIdx].Add(RI.GetStrMapByName(ColName));
3417         break;
3418      }
3419    }
3420    UpdateTableForNewRow();
3421  }
3422  void TTable::AddRowV(const TIntV& IntVals, const TFltV& FltVals, const TStrV& StrVals) {
3423    for (TInt c = 0; c < IntVals.Len(); c++) {
3424      IntCols[c].Add(IntVals[c]);
3425    }
3426    for (TInt c = 0; c < FltVals.Len(); c++) {
3427      FltCols[c].Add(FltVals[c]);
3428    }
3429    for (TInt c = 0; c < StrVals.Len(); c++) {
3430      AddStrVal(c, StrVals[c]);
3431    }
3432    UpdateTableForNewRow();
3433  }
3434  void TTable::ResizeTable(int RowCount) {
3435    if (RowCount == 0) {
3436      NumValidRows = 0;
3437      FirstValidRow = TTable::Invalid;
3438      LastValidRow = TTable::Invalid;
3439    }
3440    if (Next.Len() < RowCount) {
3441      TInt FltOffset = IntCols.Len();
3442      TInt StrOffset = FltOffset + FltCols.Len();
3443      TInt TotalCols = StrOffset + StrColMaps.Len();
3444  #ifdef USE_OPENMP
3445      #pragma omp parallel for schedule(static)
3446  #endif
3447      for (int i = 0; i < TotalCols+1; i++) {
3448        if (i < FltOffset) {
3449          IntCols[i].Reserve(RowCount, RowCount); 
3450        } else if (i < StrOffset) {
3451          FltCols[i-FltOffset].Reserve(RowCount, RowCount);
3452        } else if (i < TotalCols) {
3453          StrColMaps[i-StrOffset].Reserve(RowCount, RowCount);  
3454        } else {
3455          Next.Reserve(RowCount, RowCount);    
3456        }
3457      }
3458    } else if (Next.Len() > RowCount) {
3459      TInt FltOffset = IntCols.Len();
3460      TInt StrOffset = FltOffset + FltCols.Len();
3461      TInt TotalCols = StrOffset + StrColMaps.Len();
3462  #ifdef USE_OPENMP
3463      #pragma omp parallel for schedule(static)
3464  #endif
3465      for (int i = 0; i < TotalCols+1; i++) {
3466        if (i < FltOffset) {
3467          IntCols[i].Trunc(RowCount); 
3468        } else if (i < StrOffset) {
3469          FltCols[i-FltOffset].Trunc(RowCount); 
3470        } else if (i < TotalCols) {
3471          StrColMaps[i-StrOffset].Trunc(RowCount); 
3472        } else {
3473          Next.Trunc(RowCount); 
3474        }
3475      }
3476    }
3477  }
3478  int TTable::GetEmptyRowsStart(int NewRows) {
3479    int start = -1;
3480  #ifdef USE_OPENMP
3481    #pragma omp critical
3482    {
3483  #endif
3484      start = NumRows;
3485      NumRows += NewRows;
3486      NumValidRows += NewRows;
3487      Assert(NumRows <= Next.Len());
3488      if (LastValidRow >= 0) {Next[LastValidRow] = start;}
3489      LastValidRow = start+NewRows-1;
3490      Next[LastValidRow] = Last;
3491  #ifdef USE_OPENMP
3492    }
3493  #endif
3494    Assert (start >= 0);
3495    return start;
3496  }
3497  void TTable::AddSelectedRows(const TTable& Table, const TIntV& RowIDs) {
3498    int NewRows = RowIDs.Len();
3499    if (NewRows == 0) { return; }
3500    int start = GetEmptyRowsStart(NewRows);
3501    for (TInt r = 0; r < NewRows; r++) {
3502      TInt CurrRowIdx = RowIDs[r];
3503      for (TInt i = 0; i < Table.IntCols.Len(); i++) {
3504        IntCols[i][start+r] = Table.IntCols[i][CurrRowIdx];
3505      }
3506      for (TInt i = 0; i < Table.FltCols.Len(); i++) {
3507        FltCols[i][start+r] = Table.FltCols[i][CurrRowIdx];
3508      }
3509      for (TInt i = 0; i < Table.StrColMaps.Len(); i++) {
3510        StrColMaps[i][start+r] = Table.StrColMaps[i][CurrRowIdx];
3511      }
3512    }
3513    for (TInt r = 0; r < NewRows-1; r++) {
3514      Next[start+r] = start+r+1;
3515    }
3516  }  
3517  void TTable::AddNRows(int NewRows, const TVec<TIntV>& IntColsP, const TVec<TFltV>& FltColsP, const TVec<TIntV>& StrColMapsP) {
3518    if (NewRows == 0) { return; }
3519    int start = GetEmptyRowsStart(NewRows);
3520    for (TInt r = 0; r < NewRows; r++) {
3521      for (TInt i = 0; i < IntColsP.Len(); i++) {
3522        IntCols[i][start+r] = IntColsP[i][r];
3523      }
3524      for (TInt i = 0; i < FltColsP.Len(); i++) {
3525        FltCols[i][start+r] = FltColsP[i][r];
3526      }
3527      for (TInt i = 0; i < StrColMapsP.Len(); i++) {
3528        StrColMaps[i][start+r] = StrColMapsP[i][r];
3529      }
3530    }
3531    for (TInt r = 0; r < NewRows-1; r++) {
3532      Next[start+r] = start+r+1;
3533    }
3534  }
3535  #ifdef USE_OPENMP
3536  void TTable::AddNJointRowsMP(const TTable& T1, const TTable& T2, const TVec<TIntPrV>& JointRowIDSet) {
3537    int JointTableSize = 0;
3538    TIntV StartOffsets(JointRowIDSet.Len());
3539    for (int i = 0; i < JointRowIDSet.Len(); i++) {
3540      StartOffsets[i] = JointTableSize;
3541      JointTableSize += JointRowIDSet[i].Len();
3542    }
3543    if (JointTableSize == 0) {
3544      TExcept::Throw("Joint table is empty");
3545    }
3546    ResizeTable(JointTableSize);
3547    NumRows = JointTableSize;
3548    NumValidRows = JointTableSize;
3549    Assert(NumRows <= Next.Len());
3550    TInt IntOffset = T1.IntCols.Len();
3551    TInt FltOffset = T1.FltCols.Len();
3552    TInt StrOffset = T1.StrColMaps.Len();
3553    TInt IdOffset = IntOffset + T2.IntCols.Len();
3554    RowIdMap.Clr();
3555    for (TInt IdCnt = 0; IdCnt < JointTableSize; IdCnt++) {
3556      RowIdMap.AddDat(IdCnt, IdCnt);
3557    }
3558    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3559    for (int j = 0; j < JointRowIDSet.Len(); j++) {
3560      const TIntPrV& RowIDs = JointRowIDSet[j];
3561      int start = StartOffsets[j];
3562      int NewRows = RowIDs.Len();
3563      if (NewRows == 0) {continue;}
3564      for (TInt r = 0; r < NewRows; r++){
3565        TIntPr CurrRowIdPr = RowIDs[r]; 
3566        for(TInt i = 0; i < T1.IntCols.Len(); i++){
3567          IntCols[i][start+r] = T1.IntCols[i][CurrRowIdPr.GetVal1()];
3568        }
3569        for(TInt i = 0; i < T1.FltCols.Len(); i++){
3570          FltCols[i][start+r] = T1.FltCols[i][CurrRowIdPr.GetVal1()];
3571        }
3572        for(TInt i = 0; i < T1.StrColMaps.Len(); i++){
3573          StrColMaps[i][start+r] = T1.StrColMaps[i][CurrRowIdPr.GetVal1()];
3574        }
3575        for(TInt i = 0; i < T2.IntCols.Len(); i++){
3576          IntCols[i+IntOffset][start+r] = T2.IntCols[i][CurrRowIdPr.GetVal2()];
3577        }
3578        for(TInt i = 0; i < T2.FltCols.Len(); i++){
3579          FltCols[i+FltOffset][start+r] = T2.FltCols[i][CurrRowIdPr.GetVal2()];
3580        }
3581        for(TInt i = 0; i < T2.StrColMaps.Len(); i++){
3582          StrColMaps[i+StrOffset][start+r] = T2.StrColMaps[i][CurrRowIdPr.GetVal2()];
3583        }
3584        IntCols[IdOffset][start+r] = start+r;
3585      }
3586      for(TInt r = 0; r < NewRows; r++){
3587        Next[start+r] = start+r+1;
3588      }
3589    }      
3590    LastValidRow = JointTableSize-1;
3591    Next[LastValidRow] = Last;
3592  }
3593  #endif 
3594  PTable TTable::UnionAll(const TTable& Table) {
3595    Schema NewSchema;
3596    for (TInt c = 0; c < Sch.Len(); c++) {
3597      if (Sch[c].Val1 != GetIdColName()) {
3598        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3599      }
3600    }
3601    PTable result = TTable::New(NewSchema, Context);
3602    result->AddTable(*this);
3603    result->UnionAllInPlace(Table);
3604    return result;
3605  }
3606  void TTable::UnionAllInPlace(const TTable& Table) {
3607    AddTable(Table);
3608  }
3609  PTable TTable::Union(const TTable& Table) {
3610    Schema NewSchema;
3611    THashSet<TInt> Collisions;
3612    TStrV ColNames;
3613    for (TInt c = 0; c < Sch.Len(); c++) {
3614      if (Sch[c].Val1 != GetIdColName()) {
3615        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3616        ColNames.Add(Sch[c].Val1);
3617      }
3618    }
3619    PTable result = TTable::New(NewSchema, Context);
3620    GetCollidingRows(Table, Collisions); 
3621    result->AddTable(*this);
3622    result->Unique(ColNames);
3623    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3624      if (!Collisions.IsKey(it.GetRowIdx())) {
3625        result->AddRowI(it);
3626      }
3627    }
3628    result->InitIds();
3629    return result;
3630  }
3631  PTable TTable::Intersection(const TTable& Table) {
3632    Schema NewSchema;
3633    THashSet<TInt> Collisions;
3634    for (TInt c = 0; c < Sch.Len(); c++) {
3635      if (Sch[c].Val1 != GetIdColName()) {
3636        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3637      }
3638    }
3639    PTable result = TTable::New(NewSchema, Context);
3640    GetCollidingRows(Table, Collisions);
3641    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3642      if (Collisions.IsKey(it.GetRowIdx())) {
3643        result->AddRowI(it);
3644      }
3645    }
3646    result->InitIds();
3647    return result;
3648  }
3649  PTable TTable::Minus(TTable& Table) {
3650    Schema NewSchema;
3651    THashSet<TInt> Collisions;
3652    for (TInt c = 0; c < Sch.Len(); c++) {
3653      if (Sch[c].Val1 != GetIdColName()) {
3654        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3655      }
3656    }
3657    PTable result = TTable::New(NewSchema, Context);
3658    Table.GetCollidingRows(*this, Collisions);
3659    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
3660      if (!Collisions.IsKey(it.GetRowIdx())) {
3661        result->AddRowI(it);
3662      }
3663    }
3664    result->InitIds();
3665    return result;
3666  }
3667  PTable TTable::Project(const TStrV& ProjectCols) {
3668    Schema NewSchema;
3669    for (TInt c = 0; c < ProjectCols.Len(); c++) {
3670      if (!IsColName(ProjectCols[c])) { TExcept::Throw("no such column " + ProjectCols[c]); }
3671      NewSchema.Add(TPair<TStr,TAttrType>(ProjectCols[c], GetColType(ProjectCols[c])));
3672    }
3673    PTable result = TTable::New(NewSchema, Context);
3674    result->AddTable(*this);
3675    result->InitIds();
3676    return result;
3677  }
3678  TBool TTable::IsAttr(const TStr& Attr) {
3679    return IsColName(Attr);
3680  }
3681  TStr TTable::RenumberColName(const TStr& ColName) const {
3682    TStr NColName = ColName;
3683    if (NColName.GetCh(NColName.Len()-2) == '-') { 
3684      NColName = NColName.GetSubStr(0,NColName.Len()-3); 
3685    }
3686    TInt Conflicts = 0;
3687    for (TInt i = 0; i < Sch.Len(); i++) {
3688      if (NColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3689        Conflicts++;
3690      }
3691    }
3692    Conflicts++;
3693    NColName = NColName + "-" + Conflicts.GetStr();
3694    return NColName;
3695  }
3696  TStr TTable::DenormalizeColName(const TStr& ColName) const {
3697    TStr DColName = ColName;
3698    if (DColName.Len() == 0) { return DColName; }
3699    if (DColName.GetCh(0) == '_') { return DColName; }
3700    if (DColName.GetCh(DColName.Len()-2) == '-') { 
3701      DColName = DColName.GetSubStr(0,DColName.Len()-3); 
3702    }
3703    TInt Conflicts = 0;
3704    for (TInt i = 0; i < Sch.Len(); i++) {
3705      if (DColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3706        Conflicts++;
3707      }
3708    }
3709    if (Conflicts > 1) { return ColName; } 
3710    else { return DColName; }
3711  }
3712  Schema TTable::DenormalizeSchema() const {
3713    Schema DSch;
3714    for (TInt i = 0; i < Sch.Len(); i++) {
3715      DSch.Add(TPair<TStr, TAttrType>(DenormalizeColName(Sch[i].Val1), Sch[i].Val2));
3716    }
3717    return DSch;
3718  }
3719  void TTable::AddIntCol(const TStr& ColName) {
3720    AddSchemaCol(ColName, atInt);
3721    IntCols.Add(TIntV(NumRows));
3722    TInt L = IntCols.Len();
3723    AddColType(ColName, atInt, L-1);
3724  }
3725  void TTable::AddFltCol(const TStr& ColName) {
3726    AddSchemaCol(ColName, atFlt);
3727    FltCols.Add(TFltV(NumRows));
3728    TInt L = FltCols.Len();
3729    AddColType(ColName, atFlt, L-1);
3730  }
3731  void TTable::AddStrCol(const TStr& ColName) {
3732    AddSchemaCol(ColName, atStr);
3733    StrColMaps.Add(TIntV(NumRows));
3734    TInt L = StrColMaps.Len();
3735    AddColType(ColName, atStr, L-1);
3736  }
3737  void TTable::ClassifyAux(const TIntV& SelectedRows, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
3738    AddSchemaCol(LabelName, atInt);
3739    TInt LabelColIdx = IntCols.Len();
3740    AddColType(LabelName, atInt, LabelColIdx);
3741    IntCols.Add(TIntV(NumRows));
3742    for (TInt i = 0; i < NumRows; i++) {
3743      IntCols[LabelColIdx][i] = NegativeLabel;
3744    }
3745    for (TInt i = 0; i < SelectedRows.Len(); i++) {
3746      IntCols[LabelColIdx][SelectedRows[i]] = PositiveLabel;
3747    }
3748  }
3749  #ifdef USE_OPENMP
3750  void TTable::ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op){
3751  	TAttrType ResType = atFlt;
3752  	if(ArgType1 == atInt && ArgType2 == atInt){ ResType = atInt;}
3753  	TIntPrV Partitions;
3754  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3755  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3756  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3757  	for (int i = 0; i < Partitions.Len(); i++){
3758  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3759  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3760  		while(RowI < EndI){
3761  			if(ResType == atInt){
3762  				TInt V1 = RowI.GetIntAttr(ArgColIdx1);
3763  				TInt V2 = RowI.GetIntAttr(ArgColIdx2);
3764  				if (op == aoAdd) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3765        			if (op == aoSub) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3766        			if (op == aoMul) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3767        			if (op == aoDiv) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3768        			if (op == aoMod) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 % V2; }
3769        			if (op == aoMin) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3770        			if (op == aoMax) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3771  			} else{
3772  			    TFlt V1 = (ArgType1 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx1) : RowI.GetFltAttr(ArgColIdx1);
3773  			    TFlt V2 = (ArgType2 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx2) : RowI.GetFltAttr(ArgColIdx2);
3774  				if (op == aoAdd) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3775        			if (op == aoSub) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3776        			if (op == aoMul) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3777        			if (op == aoDiv) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3778        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3779        			if (op == aoMin) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3780        			if (op == aoMax) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3781  			}
3782  			RowI++;
3783  		}
3784  	}
3785  }
3786  #endif	
3787  void TTable::ColGenericOp(const TStr& Attr1, const TStr& Attr2, const TStr& ResAttr, TArithOp op) {
3788    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
3789    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
3790    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3791    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
3792    TAttrType Arg1Type = Info1.Val1;
3793    TAttrType Arg2Type = Info2.Val1;
3794    if (Arg1Type == atStr || Arg2Type == atStr) {
3795      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3796    }
3797    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3798    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3799    }
3800    TInt ColIdx1 = Info1.Val2;
3801    TInt ColIdx2 = Info2.Val2;
3802    TInt ColIdx3 = ColIdx1;
3803    if (ResAttr != "") {
3804        if (Arg1Type == atInt && Arg2Type == atInt) {
3805            AddIntCol(ResAttr);
3806        }
3807        else {
3808            AddFltCol(ResAttr);
3809        }
3810        ColIdx3 = GetColIdx(ResAttr);
3811    }
3812  #ifdef USE_OPENMP
3813    if(GetMP()){
3814    	ColGenericOpMP(ColIdx1, ColIdx2, Arg1Type, Arg2Type, ColIdx3, op);
3815    	return;
3816    }
3817  #endif	
3818    TAttrType ResType = atFlt;
3819    if(Arg1Type == atInt && Arg2Type == atInt){ printf("hooray!\n"); ResType = atInt;}
3820    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3821  		if(ResType == atInt){
3822  			TInt V1 = RowI.GetIntAttr(ColIdx1);
3823  			TInt V2 = RowI.GetIntAttr(ColIdx2);
3824  			if (op == aoAdd) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3825        		if (op == aoSub) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3826        		if (op == aoMul) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3827        		if (op == aoDiv) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3828        		if (op == aoMod) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 % V2; }
3829        		if (op == aoMin) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3830        		if (op == aoMax) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3831  		} else{
3832  			TFlt V1 = (Arg1Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx1) : RowI.GetFltAttr(ColIdx1);
3833  			TFlt V2 = (Arg2Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx2) : RowI.GetFltAttr(ColIdx2);
3834  			if (op == aoAdd) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3835        		if (op == aoSub) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3836        		if (op == aoMul) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3837        		if (op == aoDiv) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3838        		if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3839        		if (op == aoMin) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3840        		if (op == aoMax) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3841  		}
3842    }
3843  }
3844  void TTable::ColAdd(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3845    ColGenericOp(Attr1, Attr2, ResultAttrName, aoAdd);
3846  }
3847  void TTable::ColSub(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3848    ColGenericOp(Attr1, Attr2, ResultAttrName, aoSub);
3849  }
3850  void TTable::ColMul(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3851    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMul);
3852  }
3853  void TTable::ColDiv(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3854    ColGenericOp(Attr1, Attr2, ResultAttrName, aoDiv);
3855  }
3856  void TTable::ColMod(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3857    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMod);
3858  }
3859  void TTable::ColMin(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3860    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMin);
3861  }
3862  void TTable::ColMax(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3863    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMax);
3864  }
3865  void TTable::ColGenericOp(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr,
3866   TArithOp op, TBool AddToFirstTable) {
3867    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3868    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
3869    if (NumValidRows != Table.NumValidRows) {
3870      TExcept::Throw("Tables do not have equal number of rows");
3871    }
3872    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3873    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
3874    TAttrType Arg1Type = Info1.Val1;
3875    TAttrType Arg2Type = Info2.Val1;
3876    if (Info1.Val1 == atStr || Info2.Val1 == atStr) {
3877      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3878    }
3879    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3880    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3881    }
3882    TInt ColIdx1 = Info1.Val2;
3883    TInt ColIdx2 = Info2.Val2;
3884    TInt ColIdx3 = AddToFirstTable ? ColIdx1 : ColIdx2;
3885    if (ResAttr != "") {
3886      if (AddToFirstTable) {
3887        if (Arg1Type == atInt && Arg2Type == atInt) {
3888            AddIntCol(ResAttr);
3889        } else {
3890            AddFltCol(ResAttr);
3891        }
3892        ColIdx3 = GetColIdx(ResAttr);
3893      }
3894      else {
3895        if (Arg1Type == atInt && Arg2Type == atInt) {
3896            Table.AddIntCol(ResAttr);
3897        } else {
3898            Table.AddFltCol(ResAttr);
3899        }
3900        ColIdx3 = Table.GetColIdx(ResAttr);
3901      }
3902    }
3903    TRowIterator RI1, RI2;
3904    RI1 = BegRI();
3905    RI2 = Table.BegRI();
3906    TAttrType ResType = atFlt;
3907    if(Arg1Type == atInt && Arg2Type == atInt){ ResType = atInt;}
3908    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
3909      if (ResType == atInt) {
3910  		TInt V1 = RI1.GetIntAttr(ColIdx1);
3911  		TInt V2 = RI2.GetIntAttr(ColIdx2);
3912          if (AddToFirstTable) {
3913          	if (op == aoAdd) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3914          	if (op == aoSub) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3915          	if (op == aoMul) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3916          	if (op == aoDiv) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3917         		if (op == aoMod) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 % V2; }
3918        	}
3919        	else {
3920          	if (op == aoAdd) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3921          	if (op == aoSub) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3922          	if (op == aoMul) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3923          	if (op == aoDiv) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3924          	if (op == aoMod) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 % V2; }
3925        	}
3926      } else {
3927  	  	TFlt V1 = (Arg1Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx1) : RI2.GetFltAttr(ColIdx1);
3928  		TFlt V2 = (Arg2Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx2) : RI2.GetFltAttr(ColIdx2);
3929        	if (AddToFirstTable) {
3930          	if (op == aoAdd) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3931          	if (op == aoSub) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3932          	if (op == aoMul) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3933         	 	if (op == aoDiv) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3934          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3935        	} else {
3936          	if (op == aoAdd) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3937          	if (op == aoSub) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3938          	if (op == aoMul) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3939          	if (op == aoDiv) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3940          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3941        	}
3942      }
3943      RI1++;
3944      RI2++;
3945    }
3946    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
3947      TExcept::Throw("ColGenericOp: Iteration error");
3948    }
3949  }
3950  void TTable::ColAdd(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3951   const TStr& ResultAttrName, TBool AddToFirstTable) {
3952    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoAdd, AddToFirstTable);
3953  }
3954  void TTable::ColSub(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3955   const TStr& ResultAttrName, TBool AddToFirstTable) {
3956    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoSub, AddToFirstTable);
3957  }
3958  void TTable::ColMul(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3959   const TStr& ResultAttrName, TBool AddToFirstTable) {
3960    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMul, AddToFirstTable);
3961  }
3962  void TTable::ColDiv(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3963   const TStr& ResultAttrName, TBool AddToFirstTable) {
3964    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoDiv, AddToFirstTable);
3965  }
3966  void TTable::ColMod(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3967   const TStr& ResultAttrName, TBool AddToFirstTable) {
3968    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMod, AddToFirstTable);
3969  }
3970  void TTable::ColGenericOp(const TStr& Attr1, const TFlt& Num, const TStr& ResAttr, TArithOp op, const TBool floatCast) {
3971    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3972    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3973    TAttrType ArgType = Info1.Val1;
3974    if (ArgType == atStr) {
3975      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3976    }
3977    TInt ColIdx1 = Info1.Val2;
3978    TInt ColIdx2 = ColIdx1;
3979    TBool shouldCast = floatCast;
3980    if (ResAttr != "") {
3981        if ((ArgType == atInt) & !shouldCast) {
3982            AddIntCol(ResAttr);
3983        } else {
3984            AddFltCol(ResAttr);
3985        }
3986        ColIdx2 = GetColIdx(ResAttr);
3987    } else {
3988      shouldCast = false;
3989    }
3990    #ifdef USE_OPENMP
3991    if(GetMP()){
3992    	ColGenericOpMP(ColIdx1, ColIdx2, ArgType, Num, op, shouldCast);
3993    	return;
3994    }
3995    #endif  
3996    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3997      if ((ArgType == atInt) && !shouldCast) {
3998        TInt CurVal = RowI.GetIntAttr(ColIdx1);
3999        TInt Val = static_cast<int>(Num);
4000        if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4001        if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4002        if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4003        if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4004        if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4005      }
4006      else {
4007        TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4008        if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4009        if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4010        if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4011        if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4012        if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4013      }
4014    }
4015  }
4016  #ifdef USE_OPENMP
4017  void TTable::ColGenericOpMP(const TInt& ColIdx1, const TInt& ColIdx2, TAttrType ArgType, const TFlt& Num, TArithOp op, TBool ShouldCast){
4018  	TIntPrV Partitions;
4019  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
4020  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
4021  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
4022  	for (int i = 0; i < Partitions.Len(); i++){
4023  		TRowIterator RowI(Partitions[i].GetVal1(), this);
4024  		TRowIterator EndI(Partitions[i].GetVal2(), this);
4025  		while(RowI < EndI){
4026  			if ((ArgType == atInt) && !ShouldCast) {
4027        			TInt CurVal = RowI.GetIntAttr(ColIdx1);
4028        			TInt Val = static_cast<int>(Num);
4029        			if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4030        			if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4031        			if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4032        			if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4033        			if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4034      		} else {
4035       			TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4036        			if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4037        			if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4038        			if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4039        			if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4040        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4041      		}
4042      		RowI++;
4043  		}
4044  	}
4045  }
4046  #endif
4047  void TTable::ColAdd(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4048    ColGenericOp(Attr1, Num, ResultAttrName, aoAdd, floatCast);
4049  }
4050  void TTable::ColSub(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4051    ColGenericOp(Attr1, Num, ResultAttrName, aoSub, floatCast);
4052  }
4053  void TTable::ColMul(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4054    ColGenericOp(Attr1, Num, ResultAttrName, aoMul, floatCast);
4055  }
4056  void TTable::ColDiv(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4057    ColGenericOp(Attr1, Num, ResultAttrName, aoDiv, floatCast);
4058  }
4059  void TTable::ColMod(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4060    ColGenericOp(Attr1, Num, ResultAttrName, aoMod, floatCast);
4061  }
4062  void TTable::ColConcat(const TStr& Attr1, const TStr& Attr2, const TStr& Sep, const TStr& ResAttr) {
4063    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
4064    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
4065    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4066    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
4067    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4068      TExcept::Throw("Only string columns supported in concat.");
4069    }
4070    TInt ColIdx1 = Info1.Val2;
4071    TInt ColIdx2 = Info2.Val2;
4072    TInt ColIdx3 = ColIdx1;
4073    if (ResAttr != "") {
4074        AddStrCol(ResAttr);
4075        ColIdx3 = GetColIdx(ResAttr);
4076    }
4077    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4078      TStr CurVal1 = RowI.GetStrAttr(ColIdx1);
4079      TStr CurVal2 = RowI.GetStrAttr(ColIdx2);
4080      TStr NewVal = CurVal1 + Sep + CurVal2;
4081      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4082      StrColMaps[ColIdx3][RowI.GetRowIdx()] = Key;
4083    }
4084  }
4085  void TTable::ColConcat(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& Sep, 
4086   const TStr& ResAttr, TBool AddToFirstTable) {
4087    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4088    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
4089    if (NumValidRows != Table.NumValidRows) {
4090      TExcept::Throw("Tables do not have equal number of rows");
4091    }
4092    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4093    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
4094    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4095      TExcept::Throw("Only string columns supported in concat.");
4096    }
4097    TInt ColIdx1 = Info1.Val2;
4098    TInt ColIdx2 = Info2.Val2;
4099    TInt ColIdx3 = ColIdx1;
4100    if (!AddToFirstTable) {
4101      ColIdx3 = ColIdx2;
4102    }
4103    if (ResAttr != "") {
4104      if (AddToFirstTable) {
4105        AddStrCol(ResAttr);
4106        ColIdx3 = GetColIdx(ResAttr);
4107      }
4108      else {
4109        Table.AddStrCol(ResAttr);
4110        ColIdx3 = Table.GetColIdx(ResAttr);
4111      }
4112    }
4113    TRowIterator RI1, RI2;
4114    RI1 = BegRI();
4115    RI2 = Table.BegRI();
4116    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
4117      TStr CurVal1 = RI1.GetStrAttr(ColIdx1);
4118      TStr CurVal2 = RI2.GetStrAttr(ColIdx2);
4119      TStr NewVal = CurVal1 + Sep + CurVal2;
4120      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4121      if (AddToFirstTable) {
4122        StrColMaps[ColIdx3][RI1.GetRowIdx()] = Key;
4123      }
4124      else {
4125        Table.StrColMaps[ColIdx3][RI2.GetRowIdx()] = Key;
4126      }
4127      RI1++;
4128      RI2++;
4129    }
4130    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
4131      TExcept::Throw("ColGenericOp: Iteration error");
4132    }
4133  }
4134  void TTable::ColConcatConst(const TStr& Attr1, const TStr& Val, const TStr& Sep, const TStr& ResAttr) {
4135    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4136    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4137    if (Info1.Val1 != atStr) {
4138      TExcept::Throw("Only string columns supported in concat.");
4139    }
4140    TInt ColIdx1 = Info1.Val2;
4141    TInt ColIdx2 = ColIdx1;
4142    if (ResAttr != "") {
4143      AddStrCol(ResAttr);
4144      ColIdx2 = GetColIdx(ResAttr);
4145    }
4146    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4147      TStr CurVal = RowI.GetStrAttr(ColIdx1);
4148      TStr NewVal = CurVal + Sep + Val;
4149      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4150      StrColMaps[ColIdx2][RowI.GetRowIdx()] = Key;
4151    }  
4152  }
4153  void TTable::ReadIntCol(const TStr& ColName, TIntV& Result) const{
4154    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4155    if (GetColType(ColName) != atInt) { TExcept::Throw("not an integer column " + ColName); }
4156    TInt ColId = GetColIdx(ColName);
4157    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4158      Result.Add(it.GetIntAttr(ColId));
4159    }
4160  }
4161  void TTable::ReadFltCol(const TStr& ColName, TFltV& Result) const{
4162    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4163    if (GetColType(ColName) != atFlt) { TExcept::Throw("not a floating point column " + ColName); }
4164    TInt ColId = GetColIdx(ColName);
4165    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4166      Result.Add(it.GetFltAttr(ColId));
4167    }
4168  }
4169  void TTable::ReadStrCol(const TStr& ColName, TStrV& Result) const{
4170    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4171    if (GetColType(ColName) != atStr) { TExcept::Throw("not a string column " + ColName); }
4172    TInt ColId = GetColIdx(ColName);
4173    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4174      Result.Add(it.GetStrAttr(ColId));
4175    }
4176  }
4177  void TTable::ProjectInPlace(const TStrV& ProjectCols) {
4178    TStrV NProjectCols = NormalizeColNameV(ProjectCols);
4179    for (TInt c = 0; c < NProjectCols.Len(); c++) {
4180      if (!IsColName(NProjectCols[c])) { TExcept::Throw("no such column " + NProjectCols[c]); }
4181    }
4182    THashSet<TStr> ProjectColsSet = THashSet<TStr>(NProjectCols);
4183    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4184      TStr ColName = GetSchemaColName(i);
4185      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4186      TAttrType ColType = GetSchemaColType(i);
4187      TInt ColId = GetColIdx(ColName);
4188      switch (ColType) {
4189        case atInt:
4190          IntCols.Del(ColId);
4191          break;
4192        case atFlt:
4193          FltCols.Del(ColId);
4194          break;
4195        case atStr:
4196          StrColMaps.Del(ColId);
4197          break;
4198      }
4199    }
4200    TInt IntColCnt = 0;
4201    TInt FltColCnt = 0;
4202    TInt StrColCnt = 0;
4203    ColTypeMap.Clr();
4204    for (TInt i = 0; i < Sch.Len(); i++) {
4205      TStr ColName = GetSchemaColName(i);
4206      if (!ProjectColsSet.IsKey(ColName) && ColName != IdColName) { continue; }
4207      TAttrType ColType = GetSchemaColType(i);
4208      switch (ColType) {
4209        case atInt:
4210          AddColType(ColName, atInt, IntColCnt);
4211          IntColCnt++;
4212          break;
4213        case atFlt:
4214          AddColType(ColName, atFlt, FltColCnt);
4215          FltColCnt++;
4216          break;
4217        case atStr:
4218          AddColType(ColName, atStr, StrColCnt);
4219          StrColCnt++;
4220          break;
4221      }
4222    }
4223    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4224      TStr ColName = GetSchemaColName(i);
4225      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4226      Sch.Del(i);
4227    }
4228  }
4229  TInt TTable::CompareKeyVal(const TInt& K1, const TInt& V1, const TInt& K2, const TInt& V2) {
4230    if (K1 == K2) { return V1 - V2; }
4231    else { return K1 - K2; }
4232  }
4233  TInt TTable::CheckSortedKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4234    TInt j;
4235    for (j = Start; j < End; j++) {
4236      if (CompareKeyVal(Key[j], Val[j], Key[j+1], Val[j+1]) > 0) {
4237        break;
4238      }
4239    }
4240    if (j >= End) { return 0; }
4241    else { return 1; }
4242  }
4243  void TTable::ISortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4244    if (Start < End) {
4245      for (TInt i = Start+1; i <= End; i++) {
4246        TInt K = Key[i];
4247        TInt V = Val[i];
4248        TInt j = i;
4249        while ((Start < j) && (CompareKeyVal(Key[j-1], Val[j-1], K, V) > 0)) {
4250          Key[j] = Key[j-1];
4251          Val[j] = Val[j-1];
4252          j--;
4253        }
4254        Key[j] = K;
4255        Val[j] = V;
4256      }
4257    }
4258  }
4259  TInt TTable::GetPivotKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4260    TInt L = End - Start + 1;
4261    const TInt Idx1 = Start + TInt::GetRnd(L);
4262    const TInt Idx2 = Start + TInt::GetRnd(L);
4263    const TInt Idx3 = Start + TInt::GetRnd(L);
4264    if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx2], Val[Idx2]) < 0) {
4265      if (CompareKeyVal(Key[Idx2], Val[Idx2], Key[Idx3], Val[Idx3]) < 0) { return Idx2; }
4266      if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx3], Val[Idx3]) < 0) { return Idx3; }
4267      return Idx1;
4268    } else {
4269      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx2], Val[Idx2]) < 0) { return Idx2; }
4270      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx1], Val[Idx1]) < 0) { return Idx3; }
4271      return Idx1;
4272    }
4273  }
4274  TInt TTable::PartitionKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4275    TInt Pivot = GetPivotKeyVal(Key, Val, Start, End);
4276    TInt PivotKey = Key[Pivot];
4277    TInt PivotVal = Val[Pivot];
4278    Key.Swap(Pivot, End);
4279    Val.Swap(Pivot, End);
4280    TInt StoreIdx = Start;
4281    for (TInt i = Start; i < End; i++) {
4282      if (CompareKeyVal(Key[i], Val[i], PivotKey, PivotVal) <= 0) {
4283        Key.Swap(i, StoreIdx);
4284        Val.Swap(i, StoreIdx);
4285        StoreIdx++;
4286      }
4287    }
4288    Key.Swap(StoreIdx, End);
4289    Val.Swap(StoreIdx, End);
4290    return StoreIdx;
4291  }
4292  void TTable::QSortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4293    TInt L = End-Start;
4294    if (L <= 0) { return; }
4295    if (CheckSortedKeyVal(Key, Val, Start, End) == 0) { return; }
4296    if (L <= 20) { ISortKeyVal(Key, Val, Start, End); }
4297    else {
4298      TInt Pivot = PartitionKeyVal(Key, Val, Start, End);
4299      if (Pivot > End) { return; }
4300      if (L <= 500000) {
4301        QSortKeyVal(Key, Val, Start, Pivot-1);
4302        QSortKeyVal(Key, Val, Pivot+1, End);
4303      } else {
4304  #ifdef USE_OPENMP
4305  #ifndef GLib_WIN32
4306        #pragma omp task untied shared(Key, Val)
4307  #endif
4308  #endif
4309        { QSortKeyVal(Key, Val, Start, Pivot-1); }
4310  #ifdef USE_OPENMP
4311  #ifndef GLib_WIN32
4312        #pragma omp task untied shared(Key, Val)
4313  #endif
4314  #endif
4315        { QSortKeyVal(Key, Val, Pivot+1, End); }
4316      }
4317    }
4318  }
4319  TIntV TTable::GetIntRowIdxByVal(const TStr& ColName, const TInt& Val) const {
4320    if (IntColIndexes.IsKey(ColName)) {
4321      THash<TInt, TIntV> ColIndex = IntColIndexes.GetDat(ColName);
4322      if (ColIndex.IsKey(Val)) {
4323        return ColIndex.GetDat(Val);
4324      }
4325      else {
4326        TIntV Empty;
4327        return Empty;
4328      }
4329    }
4330    TIntV ToReturn;
4331    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4332      TInt ValAtRow = RowI.GetIntAttr(ColName);
4333      if ( Val == ValAtRow) {
4334        ToReturn.Add(RowI.GetRowIdx());
4335      }
4336    }
4337    return ToReturn;
4338  }
4339  TIntV TTable::GetStrRowIdxByMap(const TStr& ColName, const TInt& Map) const {
4340    if (StrMapColIndexes.IsKey(ColName)) {
4341      THash<TInt, TIntV> ColIndex = StrMapColIndexes.GetDat(ColName);
4342      if (ColIndex.IsKey(Map)) {
4343        return ColIndex.GetDat(Map);
4344      }
4345      else {
4346        TIntV Empty;
4347        return Empty;
4348      }
4349    }
4350    TIntV ToReturn;
4351    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4352      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4353      if ( Map == MapAtRow) {
4354        ToReturn.Add(RowI.GetRowIdx());
4355      }
4356    }
4357    return ToReturn;
4358  }
4359  TIntV TTable::GetFltRowIdxByVal(const TStr& ColName, const TFlt& Val) const {
4360    if (FltColIndexes.IsKey(ColName)) {
4361      THash<TFlt, TIntV> ColIndex = FltColIndexes.GetDat(ColName);
4362      if (ColIndex.IsKey(Val)) {
4363        return ColIndex.GetDat(Val);
4364      }
4365      else {
4366        TIntV Empty;
4367        return Empty;
4368      }
4369    }
4370    TIntV ToReturn;
4371    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4372      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4373      if ( Val == ValAtRow) {
4374        ToReturn.Add(RowI.GetRowIdx());
4375      }
4376    }
4377    return ToReturn;
4378  }
4379  TInt TTable::RequestIndexInt(const TStr& ColName) {
4380    THash<TInt, TIntV> NewIndex;
4381    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4382      TInt ValAtRow = RowI.GetIntAttr(ColName);
4383      TInt RowIdx = RowI.GetRowIdx();
4384      if (NewIndex.IsKey(ValAtRow)) {
4385         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4386         Curr_V.Add(RowIdx);
4387      }
4388      else {
4389        TIntV New_V;
4390        New_V.Add(RowIdx);
4391        NewIndex.AddDat(ValAtRow, New_V);
4392      }
4393    }
4394    IntColIndexes.AddDat(ColName, NewIndex); 
4395    return 0;
4396  }
4397  TInt TTable::RequestIndexFlt(const TStr& ColName) {
4398    THash<TFlt, TIntV> NewIndex;
4399    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4400      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4401      TInt RowIdx = RowI.GetRowIdx();
4402      if (NewIndex.IsKey(ValAtRow)) {
4403         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4404         Curr_V.Add(RowIdx);
4405      }
4406      else {
4407        TIntV New_V;
4408        New_V.Add(RowIdx);
4409        NewIndex.AddDat(ValAtRow, New_V);
4410      }
4411    }
4412    FltColIndexes.AddDat(ColName, NewIndex); 
4413    return 0;
4414  }
4415  TInt TTable::RequestIndexStrMap(const TStr& ColName) {
4416    THash<TInt, TIntV> NewIndex;
4417    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4418      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4419      TInt RowIdx = RowI.GetRowIdx();
4420      if (NewIndex.IsKey(MapAtRow)) {
4421         TIntV Curr_V = NewIndex.GetDat(MapAtRow);
4422         Curr_V.Add(RowIdx);
4423      }
4424      else {
4425        TIntV New_V;
4426        New_V.Add(RowIdx);
4427        NewIndex.AddDat(MapAtRow, New_V);
4428      }
4429    }
4430    StrMapColIndexes.AddDat(ColName, NewIndex); 
4431    return 0;
4432  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</div>
                </div>
                <div class="column column_space"><pre><code>147      PCrawlerHost Host=GetHost(HostN);
148      TStr KeyStr;
149      if (SortOrderNm=="Host"){KeyStr=Host->GetRevHostNm(); SortAscP=true;}
150      else if (SortOrderNm=="Active"){KeyStr=TInt::GetStr(Host->GetActiveConns(), "%012d"); SortAscP=false;}
151      else if (SortOrderNm=="Fetched"){KeyStr=TInt::GetStr(Host->GetFetchedUrls(), "%012d"); SortAscP=false;}
</pre></code></div>
                <div class="column column_space"><pre><code>2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    