
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 63, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "imagefind.h"
5  #include "colpartitiongrid.h"
6  #include "linlsq.h"
7  #include "params.h"
8  #include "statistc.h"
9  #include <allheaders.h>
10  #include <algorithm>
11  namespace tesseract {
12  static INT_VAR(textord_tabfind_show_images, false, "Show image blobs");
13  const double kMinRectangularFraction = 0.125;
14  const double kMaxRectangularFraction = 0.75;
15  const double kMaxRectangularGradient = 0.1; 
16  const int kMinImageFindSize = 100;
17  const int kNoisePadding = 4;
18  static bool HScanForEdge(uint32_t *data, int wpl, int x_start, int x_end, int min_count,
19                           int mid_width, int max_count, int y_end, int y_step, int *y_start) {
20    int mid_rows = 0;
21    for (int y = *y_start; y != y_end; y += y_step) {
22      int pix_count = 0;
23      uint32_t *line = data + wpl * y;
24      for (int x = x_start; x < x_end; ++x) {
25        if (GET_DATA_BIT(line, x)) {
26          ++pix_count;
27        }
28      }
29      if (mid_rows == 0 && pix_count < min_count) {
30        continue; 
31      }
32      if (mid_rows == 0) {
33        *y_start = y; 
34      }
35      if (pix_count > max_count) {
36        return true; 
37      }
38      ++mid_rows;
39      if (mid_rows > mid_width) {
40        break; 
41      }
42    }
43    return false; 
44  }
45  static bool VScanForEdge(uint32_t *data, int wpl, int y_start, int y_end, int min_count,
46                           int mid_width, int max_count, int x_end, int x_step, int *x_start) {
47    int mid_cols = 0;
48    for (int x = *x_start; x != x_end; x += x_step) {
49      int pix_count = 0;
50      uint32_t *line = data + y_start * wpl;
51      for (int y = y_start; y < y_end; ++y, line += wpl) {
52        if (GET_DATA_BIT(line, x)) {
53          ++pix_count;
54        }
55      }
56      if (mid_cols == 0 && pix_count < min_count) {
57        continue; 
58      }
59      if (mid_cols == 0) {
60        *x_start = x; 
61      }
62      if (pix_count > max_count) {
63        return true; 
64      }
65      ++mid_cols;
66      if (mid_cols > mid_width) {
67        break; 
68      }
69    }
70    return false; 
71  }
72  static bool pixNearlyRectangular(Image pix, double min_fraction, double max_fraction,
73                                   double max_skew_gradient, int *x_start, int *y_start,
74                                   int *x_end, int *y_end) {
75    ASSERT_HOST(pix != nullptr);
76    *x_start = 0;
77    *x_end = pixGetWidth(pix);
78    *y_start = 0;
79    *y_end = pixGetHeight(pix);
80    uint32_t *data = pixGetData(pix);
81    int wpl = pixGetWpl(pix);
82    bool any_cut = false;
83    bool left_done = false;
84    bool right_done = false;
85    bool top_done = false;
86    bool bottom_done = false;
87    do {
88      any_cut = false;
89      int width = *x_end - *x_start;
90      int min_count = static_cast<int>(width * min_fraction);
91      int max_count = static_cast<int>(width * max_fraction);
92      int edge_width = static_cast<int>(width * max_skew_gradient);
93      if (HScanForEdge(data, wpl, *x_start, *x_end, min_count, edge_width, max_count, *y_end, 1,
94                       y_start) &&
95          !top_done) {
96        top_done = true;
97        any_cut = true;
98      }
99      --(*y_end);
100      if (HScanForEdge(data, wpl, *x_start, *x_end, min_count, edge_width, max_count, *y_start, -1,
101                       y_end) &&
102          !bottom_done) {
103        bottom_done = true;
104        any_cut = true;
105      }
106      ++(*y_end);
107      int height = *y_end - *y_start;
108      min_count = static_cast<int>(height * min_fraction);
109      max_count = static_cast<int>(height * max_fraction);
110      edge_width = static_cast<int>(height * max_skew_gradient);
111      if (VScanForEdge(data, wpl, *y_start, *y_end, min_count, edge_width, max_count, *x_end, 1,
112                       x_start) &&
113          !left_done) {
114        left_done = true;
115        any_cut = true;
116      }
117      --(*x_end);
118      if (VScanForEdge(data, wpl, *y_start, *y_end, min_count, edge_width, max_count, *x_start, -1,
119                       x_end) &&
120          !right_done) {
121        right_done = true;
122        any_cut = true;
123      }
124      ++(*x_end);
125    } while (any_cut);
126    return left_done && right_done && top_done && bottom_done;
127  }
128  static void ConnCompAndRectangularize(Image pix, DebugPixa *pixa_debug, Boxa **boxa,
129                                        Pixa **pixa) {
130    *boxa = nullptr;
131    *pixa = nullptr;
132    if (textord_tabfind_show_images && pixa_debug != nullptr) {
133      pixa_debug->AddPix(pix, "Conncompimage");
134    }
135    *boxa = pixConnComp(pix, pixa, 8);
136    int npixes = 0;
137    if (*boxa != nullptr && *pixa != nullptr) {
138      npixes = pixaGetCount(*pixa);
139    }
140    for (int i = 0; i < npixes; ++i) {
141      int x_start, x_end, y_start, y_end;
142      Image img_pix = pixaGetPix(*pixa, i, L_CLONE);
143      if (textord_tabfind_show_images && pixa_debug != nullptr) {
144        pixa_debug->AddPix(img_pix, "A component");
145      }
146      if (pixNearlyRectangular(img_pix, kMinRectangularFraction, kMaxRectangularFraction,
147                               kMaxRectangularGradient, &x_start, &y_start, &x_end, &y_end)) {
148        Image simple_pix = pixCreate(x_end - x_start, y_end - y_start, 1);
149        pixSetAll(simple_pix);
150        img_pix.destroy();
151        pixaReplacePix(*pixa, i, simple_pix, nullptr);
152        img_pix = pixaGetPix(*pixa, i, L_CLONE);
153        l_int32 x, y, width, height;
154        boxaGetBoxGeometry(*boxa, i, &x, &y, &width, &height);
155        Box *simple_box = boxCreate(x + x_start, y + y_start, x_end - x_start, y_end - y_start);
156        boxaReplaceBox(*boxa, i, simple_box);
157      }
158      img_pix.destroy();
159    }
160  }
161  Image ImageFind::FindImages(Image pix, DebugPixa *pixa_debug) {
162    if (pixGetWidth(pix) < kMinImageFindSize || pixGetHeight(pix) < kMinImageFindSize) {
163      return pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
164    }
165    Image pixr = pixReduceRankBinaryCascade(pix, 1, 0, 0, 0);
166    if (textord_tabfind_show_images && pixa_debug != nullptr) {
167      pixa_debug->AddPix(pixr, "CascadeReduced");
168    }
169    if (pixGetWidth(pixr) < kMinImageFindSize || pixGetHeight(pixr) < kMinImageFindSize) {
170      pixr.destroy();
171      return pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
172    }
173    l_int32 ht_found = 0;
174    Pixa *pixadb = (textord_tabfind_show_images && pixa_debug != nullptr) ? pixaCreate(0) : nullptr;
175    Image pixht2 = pixGenerateHalftoneMask(pixr, nullptr, &ht_found, pixadb);
176    if (pixadb) {
177      Image pixdb = pixaDisplayTiledInColumns(pixadb, 3, 1.0, 20, 2);
178      if (textord_tabfind_show_images && pixa_debug != nullptr) {
179        pixa_debug->AddPix(pixdb, "HalftoneMask");
180      }
181      pixdb.destroy();
182      pixaDestroy(&pixadb);
183    }
184    pixr.destroy();
185    if (!ht_found && pixht2 != nullptr) {
186      pixht2.destroy();
187    }
188    if (pixht2 == nullptr) {
189      return pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
190    }
191    Image pixht = pixExpandReplicate(pixht2, 2);
192    if (textord_tabfind_show_images && pixa_debug != nullptr) {
193      pixa_debug->AddPix(pixht, "HalftoneReplicated");
194    }
195    pixht2.destroy();
196    Image pixt = pixSeedfillBinary(nullptr, pixht, pix, 8);
197    pixht |= pixt;
198    pixt.destroy();
199    Image pixfinemask = pixReduceRankBinaryCascade(pixht, 1, 1, 3, 3);
200    pixDilateBrick(pixfinemask, pixfinemask, 5, 5);
201    if (textord_tabfind_show_images && pixa_debug != nullptr) {
202      pixa_debug->AddPix(pixfinemask, "FineMask");
203    }
204    Image pixreduced = pixReduceRankBinaryCascade(pixht, 1, 1, 1, 1);
205    Image pixreduced2 = pixReduceRankBinaryCascade(pixreduced, 3, 3, 3, 0);
206    pixreduced.destroy();
207    pixDilateBrick(pixreduced2, pixreduced2, 5, 5);
208    Image pixcoarsemask = pixExpandReplicate(pixreduced2, 8);
209    pixreduced2.destroy();
210    if (textord_tabfind_show_images && pixa_debug != nullptr) {
211      pixa_debug->AddPix(pixcoarsemask, "CoarseMask");
212    }
213    pixcoarsemask &= pixfinemask;
214    pixfinemask.destroy();
215    pixDilateBrick(pixcoarsemask, pixcoarsemask, 3, 3);
216    Image pixmask = pixExpandReplicate(pixcoarsemask, 16);
217    pixcoarsemask.destroy();
218    if (textord_tabfind_show_images && pixa_debug != nullptr) {
219      pixa_debug->AddPix(pixmask, "MaskDilated");
220    }
221    pixht &= pixmask;
222    pixmask.destroy();
223    if (textord_tabfind_show_images && pixa_debug != nullptr) {
224      pixa_debug->AddPix(pixht, "FinalMask");
225    }
226    Image result = pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
227    result |= pixht;
228    pixht.destroy();
229    return result;
230  }
231  bool ImageFind::BoundsWithinRect(Image pix, int *x_start, int *y_start, int *x_end, int *y_end) {
232    Box *input_box = boxCreate(*x_start, *y_start, *x_end - *x_start, *y_end - *y_start);
233    Box *output_box = nullptr;
234    pixClipBoxToForeground(pix, input_box, nullptr, &output_box);
235    bool result = output_box != nullptr;
236    if (result) {
237      l_int32 x, y, width, height;
238      boxGetGeometry(output_box, &x, &y, &width, &height);
239      *x_start = x;
240      *y_start = y;
241      *x_end = x + width;
242      *y_end = y + height;
243      boxDestroy(&output_box);
244    }
245    boxDestroy(&input_box);
246    return result;
247  }
248  double ImageFind::ColorDistanceFromLine(const uint8_t *line1, const uint8_t *line2,
249                                          const uint8_t *point) {
250    int line_vector[kRGBRMSColors];
251    int point_vector[kRGBRMSColors];
252    for (int i = 0; i < kRGBRMSColors; ++i) {
253      line_vector[i] = static_cast<int>(line2[i]) - static_cast<int>(line1[i]);
254      point_vector[i] = static_cast<int>(point[i]) - static_cast<int>(line1[i]);
255    }
256    line_vector[L_ALPHA_CHANNEL] = 0;
257    int cross[kRGBRMSColors];
258    cross[COLOR_RED] = line_vector[COLOR_GREEN] * point_vector[COLOR_BLUE] -
259                       line_vector[COLOR_BLUE] * point_vector[COLOR_GREEN];
260    cross[COLOR_GREEN] = line_vector[COLOR_BLUE] * point_vector[COLOR_RED] -
261                         line_vector[COLOR_RED] * point_vector[COLOR_BLUE];
262    cross[COLOR_BLUE] = line_vector[COLOR_RED] * point_vector[COLOR_GREEN] -
263                        line_vector[COLOR_GREEN] * point_vector[COLOR_RED];
264    cross[L_ALPHA_CHANNEL] = 0;
265    double cross_sq = 0.0;
266    double line_sq = 0.0;
267    for (int j = 0; j < kRGBRMSColors; ++j) {
268      cross_sq += static_cast<double>(cross[j]) * cross[j];
269      line_sq += static_cast<double>(line_vector[j]) * line_vector[j];
270    }
271    if (line_sq == 0.0) {
272      return 0.0;
273    }
274    return cross_sq / line_sq; 
275  }
276  bool ImageFind::BlankImageInBetween(const TBOX &box1, const TBOX &box2, const TBOX &im_box,
277                                      const FCOORD &rotation, Image pix) {
278    TBOX search_box(box1);
279    search_box += box2;
280    if (box1.x_gap(box2) >= box1.y_gap(box2)) {
281      if (box1.x_gap(box2) <= 0) {
282        return true;
283      }
284      search_box.set_left(std::min(box1.right(), box2.right()));
285      search_box.set_right(std::max(box1.left(), box2.left()));
286    } else {
287      if (box1.y_gap(box2) <= 0) {
288        return true;
289      }
290      search_box.set_top(std::max(box1.bottom(), box2.bottom()));
291      search_box.set_bottom(std::min(box1.top(), box2.top()));
292    }
293    return CountPixelsInRotatedBox(search_box, im_box, rotation, pix) == 0;
294  }
295  int ImageFind::CountPixelsInRotatedBox(TBOX box, const TBOX &im_box, const FCOORD &rotation,
296                                         Image pix) {
297    box &= im_box; 
298    if (box.null_box()) {
299      return 0;
300    }
301    box.rotate(rotation);
302    TBOX rotated_im_box(im_box);
303    rotated_im_box.rotate(rotation);
304    Image rect_pix = pixCreate(box.width(), box.height(), 1);
305    pixRasterop(rect_pix, 0, 0, box.width(), box.height(), PIX_SRC, pix,
306                box.left() - rotated_im_box.left(), rotated_im_box.top() - box.top());
307    l_int32 result;
308    pixCountPixels(rect_pix, &result, nullptr);
309    rect_pix.destroy();
310    return result;
311  }
312  static void AttemptToShrinkBox(const FCOORD &rotation, const FCOORD &rerotation, const TBOX &im_box,
313                                 Image pix, TBOX *slice) {
314    TBOX rotated_box(*slice);
315    rotated_box.rotate(rerotation);
316    TBOX rotated_im_box(im_box);
317    rotated_im_box.rotate(rerotation);
318    int left = rotated_box.left() - rotated_im_box.left();
319    int right = rotated_box.right() - rotated_im_box.left();
320    int top = rotated_im_box.top() - rotated_box.top();
321    int bottom = rotated_im_box.top() - rotated_box.bottom();
322    ImageFind::BoundsWithinRect(pix, &left, &top, &right, &bottom);
323    top = rotated_im_box.top() - top;
324    bottom = rotated_im_box.top() - bottom;
325    left += rotated_im_box.left();
326    right += rotated_im_box.left();
327    rotated_box.set_to_given_coords(left, bottom, right, top);
328    rotated_box.rotate(rotation);
329    slice->set_left(rotated_box.left());
330    slice->set_right(rotated_box.right());
331  }
332  static void CutChunkFromParts(const TBOX &box, const TBOX &im_box, const FCOORD &rotation,
333                                const FCOORD &rerotation, Image pix, ColPartition_LIST *part_list) {
334    ASSERT_HOST(!part_list->empty());
335    ColPartition_IT part_it(part_list);
336    do {
337      ColPartition *part = part_it.data();
338      TBOX part_box = part->bounding_box();
339      if (part_box.overlap(box)) {
340        if (box.top() < part_box.top()) {
341          TBOX slice(part_box);
342          slice.set_bottom(box.top());
343          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
344            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
345            part_it.add_before_stay_put(
346                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
347          }
348        }
349        if (box.left() > part_box.left()) {
350          TBOX slice(part_box);
351          slice.set_right(box.left());
352          if (box.top() < part_box.top()) {
353            slice.set_top(box.top());
354          }
355          if (box.bottom() > part_box.bottom()) {
356            slice.set_bottom(box.bottom());
357          }
358          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
359            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
360            part_it.add_before_stay_put(
361                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
362          }
363        }
364        if (box.right() < part_box.right()) {
365          TBOX slice(part_box);
366          slice.set_left(box.right());
367          if (box.top() < part_box.top()) {
368            slice.set_top(box.top());
369          }
370          if (box.bottom() > part_box.bottom()) {
371            slice.set_bottom(box.bottom());
372          }
373          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
374            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
375            part_it.add_before_stay_put(
376                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
377          }
378        }
379        if (box.bottom() > part_box.bottom()) {
380          TBOX slice(part_box);
<span onclick='openModal()' class='match'>381          slice.set_top(box.bottom());
382          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
383            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
384            part_it.add_before_stay_put(
385                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
386          }
387        }
388        part->DeleteBoxes();
</span>389        delete part_it.extract();
390      }
391      part_it.forward();
392    } while (!part_it.at_first());
393  }
394  static void DivideImageIntoParts(const TBOX &im_box, const FCOORD &rotation,
395                                   const FCOORD &rerotation, Image pix,
396                                   ColPartitionGridSearch *rectsearch, ColPartition_LIST *part_list) {
397    ColPartition *pix_part =
398        ColPartition::FakePartition(im_box, PT_UNKNOWN, BRT_RECTIMAGE, BTFT_NONTEXT);
399    ColPartition_IT part_it(part_list);
400    part_it.add_after_then_move(pix_part);
401    rectsearch->StartRectSearch(im_box);
402    ColPartition *part;
403    while ((part = rectsearch->NextRectSearch()) != nullptr) {
404      TBOX part_box = part->bounding_box();
405      if (part_box.contains(im_box) && part->flow() >= BTFT_CHAIN) {
406        for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
407          ColPartition *pix_part = part_it.extract();
408          pix_part->DeleteBoxes();
409          delete pix_part;
410        }
411      } else if (part->flow() == BTFT_STRONG_CHAIN) {
412        TBOX overlap_box = part_box.intersection(im_box);
413        int black_area = ImageFind::CountPixelsInRotatedBox(overlap_box, im_box, rerotation, pix);
414        if (black_area * 2 < part_box.area() || !im_box.contains(part_box)) {
415          int padding = part->blob_type() == BRT_VERT_TEXT ? part_box.width() : part_box.height();
416          part_box.set_top(part_box.top() + padding / 2);
417          part_box.set_bottom(part_box.bottom() - padding / 2);
418          CutChunkFromParts(part_box, im_box, rotation, rerotation, pix, part_list);
419        } else {
420          part->set_flow(BTFT_TEXT_ON_IMAGE);
421        }
422      }
423      if (part_list->empty()) {
424        break;
425      }
426    }
427  }
428  static int ExpandImageLeft(const TBOX &box, int left_limit, ColPartitionGrid *part_grid) {
429    ColPartitionGridSearch search(part_grid);
430    ColPartition *part;
431    search.StartSideSearch(box.left(), box.bottom(), box.top());
432    while ((part = search.NextSideSearch(true)) != nullptr) {
433      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
434        const TBOX &part_box(part->bounding_box());
435        if (part_box.y_gap(box) < 0) {
436          if (part_box.right() > left_limit && part_box.right() < box.left()) {
437            left_limit = part_box.right();
438          }
439          break;
440        }
441      }
442    }
443    if (part != nullptr) {
444      TBOX search_box(left_limit, box.bottom(), box.left(), box.top());
445      search.StartRectSearch(search_box);
446      while ((part = search.NextRectSearch()) != nullptr) {
447        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
448          const TBOX &part_box(part->bounding_box());
449          if (part_box.y_gap(box) < 0) {
450            if (part_box.right() > left_limit && part_box.right() < box.left()) {
451              left_limit = part_box.right();
452            }
453          }
454        }
455      }
456    }
457    return left_limit;
458  }
459  static int ExpandImageRight(const TBOX &box, int right_limit, ColPartitionGrid *part_grid) {
460    ColPartitionGridSearch search(part_grid);
461    ColPartition *part;
462    search.StartSideSearch(box.right(), box.bottom(), box.top());
463    while ((part = search.NextSideSearch(false)) != nullptr) {
464      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
465        const TBOX &part_box(part->bounding_box());
466        if (part_box.y_gap(box) < 0) {
467          if (part_box.left() < right_limit && part_box.left() > box.right()) {
468            right_limit = part_box.left();
469          }
470          break;
471        }
472      }
473    }
474    if (part != nullptr) {
475      TBOX search_box(box.left(), box.bottom(), right_limit, box.top());
476      search.StartRectSearch(search_box);
477      while ((part = search.NextRectSearch()) != nullptr) {
478        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
479          const TBOX &part_box(part->bounding_box());
480          if (part_box.y_gap(box) < 0) {
481            if (part_box.left() < right_limit && part_box.left() > box.right()) {
482              right_limit = part_box.left();
483            }
484          }
485        }
486      }
487    }
488    return right_limit;
489  }
490  static int ExpandImageBottom(const TBOX &box, int bottom_limit, ColPartitionGrid *part_grid) {
491    ColPartitionGridSearch search(part_grid);
492    ColPartition *part;
493    search.StartVerticalSearch(box.left(), box.right(), box.bottom());
494    while ((part = search.NextVerticalSearch(true)) != nullptr) {
495      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
496        const TBOX &part_box(part->bounding_box());
497        if (part_box.x_gap(box) < 0) {
498          if (part_box.top() > bottom_limit && part_box.top() < box.bottom()) {
499            bottom_limit = part_box.top();
500          }
501          break;
502        }
503      }
504    }
505    if (part != nullptr) {
506      TBOX search_box(box.left(), bottom_limit, box.right(), box.bottom());
507      search.StartRectSearch(search_box);
508      while ((part = search.NextRectSearch()) != nullptr) {
509        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
510          const TBOX &part_box(part->bounding_box());
511          if (part_box.x_gap(box) < 0) {
512            if (part_box.top() > bottom_limit && part_box.top() < box.bottom()) {
513              bottom_limit = part_box.top();
514            }
515          }
516        }
517      }
518    }
519    return bottom_limit;
520  }
521  static int ExpandImageTop(const TBOX &box, int top_limit, ColPartitionGrid *part_grid) {
522    ColPartitionGridSearch search(part_grid);
523    ColPartition *part;
524    search.StartVerticalSearch(box.left(), box.right(), box.top());
525    while ((part = search.NextVerticalSearch(false)) != nullptr) {
526      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
527        const TBOX &part_box(part->bounding_box());
528        if (part_box.x_gap(box) < 0) {
529          if (part_box.bottom() < top_limit && part_box.bottom() > box.top()) {
530            top_limit = part_box.bottom();
531          }
532          break;
533        }
534      }
535    }
536    if (part != nullptr) {
537      TBOX search_box(box.left(), box.top(), box.right(), top_limit);
538      search.StartRectSearch(search_box);
539      while ((part = search.NextRectSearch()) != nullptr) {
540        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
541          const TBOX &part_box(part->bounding_box());
542          if (part_box.x_gap(box) < 0) {
543            if (part_box.bottom() < top_limit && part_box.bottom() > box.top()) {
544              top_limit = part_box.bottom();
545            }
546          }
547        }
548      }
549    }
550    return top_limit;
551  }
552  static int ExpandImageDir(BlobNeighbourDir dir, const TBOX &im_box, const TBOX &limit_box,
553                            ColPartitionGrid *part_grid, TBOX *expanded_box) {
554    *expanded_box = im_box;
555    switch (dir) {
556      case BND_LEFT:
557        expanded_box->set_left(ExpandImageLeft(im_box, limit_box.left(), part_grid));
558        break;
559      case BND_RIGHT:
560        expanded_box->set_right(ExpandImageRight(im_box, limit_box.right(), part_grid));
561        break;
562      case BND_ABOVE:
563        expanded_box->set_top(ExpandImageTop(im_box, limit_box.top(), part_grid));
564        break;
565      case BND_BELOW:
566        expanded_box->set_bottom(ExpandImageBottom(im_box, limit_box.bottom(), part_grid));
567        break;
568      default:
569        return 0;
570    }
571    return expanded_box->area() - im_box.area();
572  }
573  static void MaximalImageBoundingBox(ColPartitionGrid *part_grid, TBOX *im_box) {
574    bool dunnit[BND_COUNT];
575    memset(dunnit, 0, sizeof(dunnit));
576    TBOX limit_box(part_grid->bleft().x(), part_grid->bleft().y(), part_grid->tright().x(),
577                   part_grid->tright().y());
578    TBOX text_box(*im_box);
579    for (int iteration = 0; iteration < BND_COUNT; ++iteration) {
580      int best_delta = -1;
581      BlobNeighbourDir best_dir = BND_LEFT;
582      TBOX expanded_boxes[BND_COUNT];
583      for (int dir = 0; dir < BND_COUNT; ++dir) {
584        auto bnd = static_cast<BlobNeighbourDir>(dir);
585        if (!dunnit[bnd]) {
586          TBOX expanded_box;
587          int area_delta = ExpandImageDir(bnd, text_box, limit_box, part_grid, &expanded_boxes[bnd]);
588          if (best_delta < 0 || area_delta < best_delta) {
589            best_delta = area_delta;
590            best_dir = bnd;
591          }
592        }
593      }
594      dunnit[best_dir] = true;
595      text_box = expanded_boxes[best_dir];
596    }
597    *im_box = text_box;
598  }
599  static void DeletePartition(ColPartition *part) {
600    BlobRegionType type = part->blob_type();
601    if (type == BRT_RECTIMAGE || type == BRT_POLYIMAGE) {
602      part->DeleteBoxes(); 
603    } else {
604      part->set_flow(BTFT_NONTEXT);
605      part->set_blob_type(BRT_NOISE);
606      part->SetBlobTypes();
607      part->DisownBoxes(); 
608    }
609    delete part;
610  }
611  static bool ExpandImageIntoParts(const TBOX &max_image_box, ColPartitionGridSearch *rectsearch,
612                                   ColPartitionGrid *part_grid, ColPartition **part_ptr) {
613    ColPartition *image_part = *part_ptr;
614    TBOX im_part_box = image_part->bounding_box();
615    if (textord_tabfind_show_images > 1) {
616      tprintf("Searching for merge with image part:");
617      im_part_box.print();
618      tprintf("Text box=");
619      max_image_box.print();
620    }
621    rectsearch->StartRectSearch(max_image_box);
622    ColPartition *part;
623    ColPartition *best_part = nullptr;
624    int best_dist = 0;
625    while ((part = rectsearch->NextRectSearch()) != nullptr) {
626      if (textord_tabfind_show_images > 1) {
627        tprintf("Considering merge with part:");
628        part->Print();
629        if (im_part_box.contains(part->bounding_box())) {
630          tprintf("Fully contained\n");
631        } else if (!max_image_box.contains(part->bounding_box())) {
632          tprintf("Not within text box\n");
633        } else if (part->flow() == BTFT_STRONG_CHAIN) {
634          tprintf("Too strong text\n");
635        } else {
636          tprintf("Real candidate\n");
637        }
638      }
639      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_TEXT_ON_IMAGE ||
640          part->blob_type() == BRT_POLYIMAGE) {
641        continue;
642      }
643      TBOX box = part->bounding_box();
644      if (max_image_box.contains(box) && part->blob_type() != BRT_NOISE) {
645        if (im_part_box.contains(box)) {
646          rectsearch->RemoveBBox();
647          DeletePartition(part);
648          continue;
649        }
650        int x_dist = std::max(0, box.x_gap(im_part_box));
651        int y_dist = std::max(0, box.y_gap(im_part_box));
652        int dist = x_dist * x_dist + y_dist * y_dist;
653        if (dist > box.area() || dist > im_part_box.area()) {
654          continue; 
655        }
656        if (best_part == nullptr || dist < best_dist) {
657          best_part = part;
658          best_dist = dist;
659        }
660      }
661    }
662    if (best_part != nullptr) {
663      TBOX box = best_part->bounding_box();
664      if (textord_tabfind_show_images > 1) {
665        tprintf("Merging image part:");
666        im_part_box.print();
667        tprintf("with part:");
668        box.print();
669      }
670      im_part_box += box;
671      *part_ptr = ColPartition::FakePartition(im_part_box, PT_UNKNOWN, BRT_RECTIMAGE, BTFT_NONTEXT);
672      DeletePartition(image_part);
673      part_grid->RemoveBBox(best_part);
674      DeletePartition(best_part);
675      rectsearch->RepositionIterator();
676      return true;
677    }
678    return false;
679  }
680  static int IntersectArea(const TBOX &box, ColPartition_LIST *part_list) {
681    int intersect_area = 0;
682    ColPartition_IT part_it(part_list);
683    for (part_it.mark_cycle_pt(); !part_it.cycled_list(); part_it.forward()) {
684      ColPartition *image_part = part_it.data();
685      TBOX intersect = box.intersection(image_part->bounding_box());
686      intersect_area += intersect.area();
687    }
688    return intersect_area;
689  }
690  static bool TestWeakIntersectedPart(const TBOX &im_box, ColPartition_LIST *part_list,
691                                      ColPartition *part) {
692    if (part->flow() < BTFT_STRONG_CHAIN) {
693      const TBOX &part_box = part->bounding_box();
694      if (im_box.contains(part_box)) {
695        int area = part_box.area();
696        int intersect_area = IntersectArea(part_box, part_list);
697        if (area < 2 * intersect_area) {
698          return true;
699        }
700      }
701    }
702    return false;
703  }
704  static void EliminateWeakParts(const TBOX &im_box, ColPartitionGrid *part_grid,
705                                 ColPartition_LIST *big_parts, ColPartition_LIST *part_list) {
706    ColPartitionGridSearch rectsearch(part_grid);
707    ColPartition *part;
708    rectsearch.StartRectSearch(im_box);
709    while ((part = rectsearch.NextRectSearch()) != nullptr) {
710      if (TestWeakIntersectedPart(im_box, part_list, part)) {
711        BlobRegionType type = part->blob_type();
712        if (type == BRT_POLYIMAGE || type == BRT_RECTIMAGE) {
713          rectsearch.RemoveBBox();
714          DeletePartition(part);
715        } else {
716          part->set_flow(BTFT_NONTEXT);
717          part->set_blob_type(BRT_NOISE);
718          part->SetBlobTypes();
719        }
720      }
721    }
722    ColPartition_IT big_it(big_parts);
723    for (big_it.mark_cycle_pt(); !big_it.cycled_list(); big_it.forward()) {
724      part = big_it.data();
725      if (TestWeakIntersectedPart(im_box, part_list, part)) {
726        DeletePartition(big_it.extract());
727      }
728    }
729  }
730  static bool ScanForOverlappingText(ColPartitionGrid *part_grid, TBOX *box) {
731    ColPartitionGridSearch rectsearch(part_grid);
732    TBOX padded_box(*box);
733    padded_box.pad(kNoisePadding, kNoisePadding);
734    rectsearch.StartRectSearch(padded_box);
735    ColPartition *part;
736    bool any_text_in_padded_rect = false;
737    while ((part = rectsearch.NextRectSearch()) != nullptr) {
738      if (part->flow() == BTFT_CHAIN || part->flow() == BTFT_STRONG_CHAIN) {
739        any_text_in_padded_rect = true;
740        const TBOX &part_box = part->bounding_box();
741        if (box->overlap(part_box)) {
742          return true;
743        }
744      }
745    }
746    if (!any_text_in_padded_rect) {
747      *box = padded_box;
748    }
749    return false;
750  }
751  static void MarkAndDeleteImageParts(const FCOORD &rerotate, ColPartitionGrid *part_grid,
752                                      ColPartition_LIST *image_parts, Image image_pix) {
753    if (image_pix == nullptr) {
754      return;
755    }
756    int imageheight = pixGetHeight(image_pix);
757    ColPartition_IT part_it(image_parts);
758    for (; !part_it.empty(); part_it.forward()) {
759      ColPartition *part = part_it.extract();
760      TBOX part_box = part->bounding_box();
761      BlobRegionType type = part->blob_type();
762      if (!ScanForOverlappingText(part_grid, &part_box) || type == BRT_RECTIMAGE ||
763          type == BRT_POLYIMAGE) {
764        part_box.rotate(rerotate);
765        int left = part_box.left();
766        int top = part_box.top();
767        pixRasterop(image_pix, left, imageheight - top, part_box.width(), part_box.height(), PIX_SET,
768                    nullptr, 0, 0);
769      }
770      DeletePartition(part);
771    }
772  }
773  void ImageFind::TransferImagePartsToImageMask(const FCOORD &rerotation, ColPartitionGrid *part_grid,
774                                                Image image_mask) {
775    ColPartition_LIST parts_list;
776    ColPartition_IT part_it(&parts_list);
777    ColPartitionGridSearch gsearch(part_grid);
778    gsearch.StartFullSearch();
779    ColPartition *part;
780    while ((part = gsearch.NextFullSearch()) != nullptr) {
781      BlobRegionType type = part->blob_type();
782      if (type == BRT_NOISE || type == BRT_RECTIMAGE || type == BRT_POLYIMAGE) {
783        part_it.add_after_then_move(part);
784        gsearch.RemoveBBox();
785      }
786    }
787    MarkAndDeleteImageParts(rerotation, part_grid, &parts_list, image_mask);
788  }
789  static void DeleteSmallImages(ColPartitionGrid *part_grid) {
790    if (part_grid != nullptr) {
791      return;
792    }
793    ColPartitionGridSearch gsearch(part_grid);
794    gsearch.StartFullSearch();
795    ColPartition *part;
796    while ((part = gsearch.NextFullSearch()) != nullptr) {
797      if (part->blob_type() == BRT_RECTIMAGE) {
798        const TBOX &part_box = part->bounding_box();
799        if (part_box.width() < kMinImageFindSize || part_box.height() < kMinImageFindSize) {
800          gsearch.RemoveBBox();
801          DeletePartition(part);
802        }
803      }
804    }
805  }
806  void ImageFind::FindImagePartitions(Image image_pix, const FCOORD &rotation,
807                                      const FCOORD &rerotation, TO_BLOCK *block, TabFind *tab_grid,
808                                      DebugPixa *pixa_debug, ColPartitionGrid *part_grid,
809                                      ColPartition_LIST *big_parts) {
810    int imageheight = pixGetHeight(image_pix);
811    Boxa *boxa;
812    Pixa *pixa;
813    ConnCompAndRectangularize(image_pix, pixa_debug, &boxa, &pixa);
814    int nboxes = 0;
815    if (boxa != nullptr && pixa != nullptr) {
816      nboxes = boxaGetCount(boxa);
817    }
818    for (int i = 0; i < nboxes; ++i) {
819      l_int32 x, y, width, height;
820      boxaGetBoxGeometry(boxa, i, &x, &y, &width, &height);
821      Image pix = pixaGetPix(pixa, i, L_CLONE);
822      TBOX im_box(x, imageheight - y - height, x + width, imageheight - y);
823      im_box.rotate(rotation); 
824      ColPartitionGridSearch rectsearch(part_grid);
825      rectsearch.SetUniqueMode(true);
826      ColPartition_LIST part_list;
827      DivideImageIntoParts(im_box, rotation, rerotation, pix, &rectsearch, &part_list);
828      if (textord_tabfind_show_images && pixa_debug != nullptr) {
829        pixa_debug->AddPix(pix, "ImageComponent");
830        tprintf("Component has %d parts\n", part_list.length());
831      }
832      pix.destroy();
833      if (!part_list.empty()) {
834        ColPartition_IT part_it(&part_list);
835        if (part_list.singleton()) {
836          ColPartition *part = part_it.extract();
837          TBOX text_box(im_box);
838          MaximalImageBoundingBox(part_grid, &text_box);
839          while (ExpandImageIntoParts(text_box, &rectsearch, part_grid, &part)) {
840            ;
841          }
842          part_it.set_to_list(&part_list);
843          part_it.add_after_then_move(part);
844          im_box = part->bounding_box();
845        }
846        EliminateWeakParts(im_box, part_grid, big_parts, &part_list);
847        for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
848          ColPartition *image_part = part_it.extract();
849          im_box = image_part->bounding_box();
850          part_grid->InsertBBox(true, true, image_part);
851          if (!part_it.at_last()) {
852            ColPartition *neighbour = part_it.data_relative(1);
853            image_part->AddPartner(false, neighbour);
854            neighbour->AddPartner(true, image_part);
855          }
856        }
857      }
858    }
859    boxaDestroy(&boxa);
860    pixaDestroy(&pixa);
861    DeleteSmallImages(part_grid);
862  #ifndef GRAPHICS_DISABLED
863    if (textord_tabfind_show_images) {
864      ScrollView *images_win_ = part_grid->MakeWindow(1000, 400, "With Images");
865      part_grid->DisplayBoxes(images_win_);
866    }
867  #endif
868  }
869  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "imagefind.h"
5  #include "colpartitiongrid.h"
6  #include "linlsq.h"
7  #include "params.h"
8  #include "statistc.h"
9  #include <allheaders.h>
10  #include <algorithm>
11  namespace tesseract {
12  static INT_VAR(textord_tabfind_show_images, false, "Show image blobs");
13  const double kMinRectangularFraction = 0.125;
14  const double kMaxRectangularFraction = 0.75;
15  const double kMaxRectangularGradient = 0.1; 
16  const int kMinImageFindSize = 100;
17  const int kNoisePadding = 4;
18  static bool HScanForEdge(uint32_t *data, int wpl, int x_start, int x_end, int min_count,
19                           int mid_width, int max_count, int y_end, int y_step, int *y_start) {
20    int mid_rows = 0;
21    for (int y = *y_start; y != y_end; y += y_step) {
22      int pix_count = 0;
23      uint32_t *line = data + wpl * y;
24      for (int x = x_start; x < x_end; ++x) {
25        if (GET_DATA_BIT(line, x)) {
26          ++pix_count;
27        }
28      }
29      if (mid_rows == 0 && pix_count < min_count) {
30        continue; 
31      }
32      if (mid_rows == 0) {
33        *y_start = y; 
34      }
35      if (pix_count > max_count) {
36        return true; 
37      }
38      ++mid_rows;
39      if (mid_rows > mid_width) {
40        break; 
41      }
42    }
43    return false; 
44  }
45  static bool VScanForEdge(uint32_t *data, int wpl, int y_start, int y_end, int min_count,
46                           int mid_width, int max_count, int x_end, int x_step, int *x_start) {
47    int mid_cols = 0;
48    for (int x = *x_start; x != x_end; x += x_step) {
49      int pix_count = 0;
50      uint32_t *line = data + y_start * wpl;
51      for (int y = y_start; y < y_end; ++y, line += wpl) {
52        if (GET_DATA_BIT(line, x)) {
53          ++pix_count;
54        }
55      }
56      if (mid_cols == 0 && pix_count < min_count) {
57        continue; 
58      }
59      if (mid_cols == 0) {
60        *x_start = x; 
61      }
62      if (pix_count > max_count) {
63        return true; 
64      }
65      ++mid_cols;
66      if (mid_cols > mid_width) {
67        break; 
68      }
69    }
70    return false; 
71  }
72  static bool pixNearlyRectangular(Image pix, double min_fraction, double max_fraction,
73                                   double max_skew_gradient, int *x_start, int *y_start,
74                                   int *x_end, int *y_end) {
75    ASSERT_HOST(pix != nullptr);
76    *x_start = 0;
77    *x_end = pixGetWidth(pix);
78    *y_start = 0;
79    *y_end = pixGetHeight(pix);
80    uint32_t *data = pixGetData(pix);
81    int wpl = pixGetWpl(pix);
82    bool any_cut = false;
83    bool left_done = false;
84    bool right_done = false;
85    bool top_done = false;
86    bool bottom_done = false;
87    do {
88      any_cut = false;
89      int width = *x_end - *x_start;
90      int min_count = static_cast<int>(width * min_fraction);
91      int max_count = static_cast<int>(width * max_fraction);
92      int edge_width = static_cast<int>(width * max_skew_gradient);
93      if (HScanForEdge(data, wpl, *x_start, *x_end, min_count, edge_width, max_count, *y_end, 1,
94                       y_start) &&
95          !top_done) {
96        top_done = true;
97        any_cut = true;
98      }
99      --(*y_end);
100      if (HScanForEdge(data, wpl, *x_start, *x_end, min_count, edge_width, max_count, *y_start, -1,
101                       y_end) &&
102          !bottom_done) {
103        bottom_done = true;
104        any_cut = true;
105      }
106      ++(*y_end);
107      int height = *y_end - *y_start;
108      min_count = static_cast<int>(height * min_fraction);
109      max_count = static_cast<int>(height * max_fraction);
110      edge_width = static_cast<int>(height * max_skew_gradient);
111      if (VScanForEdge(data, wpl, *y_start, *y_end, min_count, edge_width, max_count, *x_end, 1,
112                       x_start) &&
113          !left_done) {
114        left_done = true;
115        any_cut = true;
116      }
117      --(*x_end);
118      if (VScanForEdge(data, wpl, *y_start, *y_end, min_count, edge_width, max_count, *x_start, -1,
119                       x_end) &&
120          !right_done) {
121        right_done = true;
122        any_cut = true;
123      }
124      ++(*x_end);
125    } while (any_cut);
126    return left_done && right_done && top_done && bottom_done;
127  }
128  static void ConnCompAndRectangularize(Image pix, DebugPixa *pixa_debug, Boxa **boxa,
129                                        Pixa **pixa) {
130    *boxa = nullptr;
131    *pixa = nullptr;
132    if (textord_tabfind_show_images && pixa_debug != nullptr) {
133      pixa_debug->AddPix(pix, "Conncompimage");
134    }
135    *boxa = pixConnComp(pix, pixa, 8);
136    int npixes = 0;
137    if (*boxa != nullptr && *pixa != nullptr) {
138      npixes = pixaGetCount(*pixa);
139    }
140    for (int i = 0; i < npixes; ++i) {
141      int x_start, x_end, y_start, y_end;
142      Image img_pix = pixaGetPix(*pixa, i, L_CLONE);
143      if (textord_tabfind_show_images && pixa_debug != nullptr) {
144        pixa_debug->AddPix(img_pix, "A component");
145      }
146      if (pixNearlyRectangular(img_pix, kMinRectangularFraction, kMaxRectangularFraction,
147                               kMaxRectangularGradient, &x_start, &y_start, &x_end, &y_end)) {
148        Image simple_pix = pixCreate(x_end - x_start, y_end - y_start, 1);
149        pixSetAll(simple_pix);
150        img_pix.destroy();
151        pixaReplacePix(*pixa, i, simple_pix, nullptr);
152        img_pix = pixaGetPix(*pixa, i, L_CLONE);
153        l_int32 x, y, width, height;
154        boxaGetBoxGeometry(*boxa, i, &x, &y, &width, &height);
155        Box *simple_box = boxCreate(x + x_start, y + y_start, x_end - x_start, y_end - y_start);
156        boxaReplaceBox(*boxa, i, simple_box);
157      }
158      img_pix.destroy();
159    }
160  }
161  Image ImageFind::FindImages(Image pix, DebugPixa *pixa_debug) {
162    if (pixGetWidth(pix) < kMinImageFindSize || pixGetHeight(pix) < kMinImageFindSize) {
163      return pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
164    }
165    Image pixr = pixReduceRankBinaryCascade(pix, 1, 0, 0, 0);
166    if (textord_tabfind_show_images && pixa_debug != nullptr) {
167      pixa_debug->AddPix(pixr, "CascadeReduced");
168    }
169    if (pixGetWidth(pixr) < kMinImageFindSize || pixGetHeight(pixr) < kMinImageFindSize) {
170      pixr.destroy();
171      return pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
172    }
173    l_int32 ht_found = 0;
174    Pixa *pixadb = (textord_tabfind_show_images && pixa_debug != nullptr) ? pixaCreate(0) : nullptr;
175    Image pixht2 = pixGenerateHalftoneMask(pixr, nullptr, &ht_found, pixadb);
176    if (pixadb) {
177      Image pixdb = pixaDisplayTiledInColumns(pixadb, 3, 1.0, 20, 2);
178      if (textord_tabfind_show_images && pixa_debug != nullptr) {
179        pixa_debug->AddPix(pixdb, "HalftoneMask");
180      }
181      pixdb.destroy();
182      pixaDestroy(&pixadb);
183    }
184    pixr.destroy();
185    if (!ht_found && pixht2 != nullptr) {
186      pixht2.destroy();
187    }
188    if (pixht2 == nullptr) {
189      return pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
190    }
191    Image pixht = pixExpandReplicate(pixht2, 2);
192    if (textord_tabfind_show_images && pixa_debug != nullptr) {
193      pixa_debug->AddPix(pixht, "HalftoneReplicated");
194    }
195    pixht2.destroy();
196    Image pixt = pixSeedfillBinary(nullptr, pixht, pix, 8);
197    pixht |= pixt;
198    pixt.destroy();
199    Image pixfinemask = pixReduceRankBinaryCascade(pixht, 1, 1, 3, 3);
200    pixDilateBrick(pixfinemask, pixfinemask, 5, 5);
201    if (textord_tabfind_show_images && pixa_debug != nullptr) {
202      pixa_debug->AddPix(pixfinemask, "FineMask");
203    }
204    Image pixreduced = pixReduceRankBinaryCascade(pixht, 1, 1, 1, 1);
205    Image pixreduced2 = pixReduceRankBinaryCascade(pixreduced, 3, 3, 3, 0);
206    pixreduced.destroy();
207    pixDilateBrick(pixreduced2, pixreduced2, 5, 5);
208    Image pixcoarsemask = pixExpandReplicate(pixreduced2, 8);
209    pixreduced2.destroy();
210    if (textord_tabfind_show_images && pixa_debug != nullptr) {
211      pixa_debug->AddPix(pixcoarsemask, "CoarseMask");
212    }
213    pixcoarsemask &= pixfinemask;
214    pixfinemask.destroy();
215    pixDilateBrick(pixcoarsemask, pixcoarsemask, 3, 3);
216    Image pixmask = pixExpandReplicate(pixcoarsemask, 16);
217    pixcoarsemask.destroy();
218    if (textord_tabfind_show_images && pixa_debug != nullptr) {
219      pixa_debug->AddPix(pixmask, "MaskDilated");
220    }
221    pixht &= pixmask;
222    pixmask.destroy();
223    if (textord_tabfind_show_images && pixa_debug != nullptr) {
224      pixa_debug->AddPix(pixht, "FinalMask");
225    }
226    Image result = pixCreate(pixGetWidth(pix), pixGetHeight(pix), 1);
227    result |= pixht;
228    pixht.destroy();
229    return result;
230  }
231  bool ImageFind::BoundsWithinRect(Image pix, int *x_start, int *y_start, int *x_end, int *y_end) {
232    Box *input_box = boxCreate(*x_start, *y_start, *x_end - *x_start, *y_end - *y_start);
233    Box *output_box = nullptr;
234    pixClipBoxToForeground(pix, input_box, nullptr, &output_box);
235    bool result = output_box != nullptr;
236    if (result) {
237      l_int32 x, y, width, height;
238      boxGetGeometry(output_box, &x, &y, &width, &height);
239      *x_start = x;
240      *y_start = y;
241      *x_end = x + width;
242      *y_end = y + height;
243      boxDestroy(&output_box);
244    }
245    boxDestroy(&input_box);
246    return result;
247  }
248  double ImageFind::ColorDistanceFromLine(const uint8_t *line1, const uint8_t *line2,
249                                          const uint8_t *point) {
250    int line_vector[kRGBRMSColors];
251    int point_vector[kRGBRMSColors];
252    for (int i = 0; i < kRGBRMSColors; ++i) {
253      line_vector[i] = static_cast<int>(line2[i]) - static_cast<int>(line1[i]);
254      point_vector[i] = static_cast<int>(point[i]) - static_cast<int>(line1[i]);
255    }
256    line_vector[L_ALPHA_CHANNEL] = 0;
257    int cross[kRGBRMSColors];
258    cross[COLOR_RED] = line_vector[COLOR_GREEN] * point_vector[COLOR_BLUE] -
259                       line_vector[COLOR_BLUE] * point_vector[COLOR_GREEN];
260    cross[COLOR_GREEN] = line_vector[COLOR_BLUE] * point_vector[COLOR_RED] -
261                         line_vector[COLOR_RED] * point_vector[COLOR_BLUE];
262    cross[COLOR_BLUE] = line_vector[COLOR_RED] * point_vector[COLOR_GREEN] -
263                        line_vector[COLOR_GREEN] * point_vector[COLOR_RED];
264    cross[L_ALPHA_CHANNEL] = 0;
265    double cross_sq = 0.0;
266    double line_sq = 0.0;
267    for (int j = 0; j < kRGBRMSColors; ++j) {
268      cross_sq += static_cast<double>(cross[j]) * cross[j];
269      line_sq += static_cast<double>(line_vector[j]) * line_vector[j];
270    }
271    if (line_sq == 0.0) {
272      return 0.0;
273    }
274    return cross_sq / line_sq; 
275  }
276  bool ImageFind::BlankImageInBetween(const TBOX &box1, const TBOX &box2, const TBOX &im_box,
277                                      const FCOORD &rotation, Image pix) {
278    TBOX search_box(box1);
279    search_box += box2;
280    if (box1.x_gap(box2) >= box1.y_gap(box2)) {
281      if (box1.x_gap(box2) <= 0) {
282        return true;
283      }
284      search_box.set_left(std::min(box1.right(), box2.right()));
285      search_box.set_right(std::max(box1.left(), box2.left()));
286    } else {
287      if (box1.y_gap(box2) <= 0) {
288        return true;
289      }
290      search_box.set_top(std::max(box1.bottom(), box2.bottom()));
291      search_box.set_bottom(std::min(box1.top(), box2.top()));
292    }
293    return CountPixelsInRotatedBox(search_box, im_box, rotation, pix) == 0;
294  }
295  int ImageFind::CountPixelsInRotatedBox(TBOX box, const TBOX &im_box, const FCOORD &rotation,
296                                         Image pix) {
297    box &= im_box; 
298    if (box.null_box()) {
299      return 0;
300    }
301    box.rotate(rotation);
302    TBOX rotated_im_box(im_box);
303    rotated_im_box.rotate(rotation);
304    Image rect_pix = pixCreate(box.width(), box.height(), 1);
305    pixRasterop(rect_pix, 0, 0, box.width(), box.height(), PIX_SRC, pix,
306                box.left() - rotated_im_box.left(), rotated_im_box.top() - box.top());
307    l_int32 result;
308    pixCountPixels(rect_pix, &result, nullptr);
309    rect_pix.destroy();
310    return result;
311  }
312  static void AttemptToShrinkBox(const FCOORD &rotation, const FCOORD &rerotation, const TBOX &im_box,
313                                 Image pix, TBOX *slice) {
314    TBOX rotated_box(*slice);
315    rotated_box.rotate(rerotation);
316    TBOX rotated_im_box(im_box);
317    rotated_im_box.rotate(rerotation);
318    int left = rotated_box.left() - rotated_im_box.left();
319    int right = rotated_box.right() - rotated_im_box.left();
320    int top = rotated_im_box.top() - rotated_box.top();
321    int bottom = rotated_im_box.top() - rotated_box.bottom();
322    ImageFind::BoundsWithinRect(pix, &left, &top, &right, &bottom);
323    top = rotated_im_box.top() - top;
324    bottom = rotated_im_box.top() - bottom;
325    left += rotated_im_box.left();
326    right += rotated_im_box.left();
327    rotated_box.set_to_given_coords(left, bottom, right, top);
328    rotated_box.rotate(rotation);
329    slice->set_left(rotated_box.left());
330    slice->set_right(rotated_box.right());
331  }
332  static void CutChunkFromParts(const TBOX &box, const TBOX &im_box, const FCOORD &rotation,
333                                const FCOORD &rerotation, Image pix, ColPartition_LIST *part_list) {
334    ASSERT_HOST(!part_list->empty());
335    ColPartition_IT part_it(part_list);
336    do {
337      ColPartition *part = part_it.data();
338      TBOX part_box = part->bounding_box();
339      if (part_box.overlap(box)) {
340        if (box.top() < part_box.top()) {
341          TBOX slice(part_box);
<span onclick='openModal()' class='match'>342          slice.set_bottom(box.top());
343          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
344            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
345            part_it.add_before_stay_put(
346                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
347          }
348        }
349        if (box.left() > part_box.left()) {
</span>350          TBOX slice(part_box);
351          slice.set_right(box.left());
352          if (box.top() < part_box.top()) {
353            slice.set_top(box.top());
354          }
355          if (box.bottom() > part_box.bottom()) {
356            slice.set_bottom(box.bottom());
357          }
358          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
359            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
360            part_it.add_before_stay_put(
361                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
362          }
363        }
364        if (box.right() < part_box.right()) {
365          TBOX slice(part_box);
366          slice.set_left(box.right());
367          if (box.top() < part_box.top()) {
368            slice.set_top(box.top());
369          }
370          if (box.bottom() > part_box.bottom()) {
371            slice.set_bottom(box.bottom());
372          }
373          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
374            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
375            part_it.add_before_stay_put(
376                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
377          }
378        }
379        if (box.bottom() > part_box.bottom()) {
380          TBOX slice(part_box);
381          slice.set_top(box.bottom());
382          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
383            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
384            part_it.add_before_stay_put(
385                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
386          }
387        }
388        part->DeleteBoxes();
389        delete part_it.extract();
390      }
391      part_it.forward();
392    } while (!part_it.at_first());
393  }
394  static void DivideImageIntoParts(const TBOX &im_box, const FCOORD &rotation,
395                                   const FCOORD &rerotation, Image pix,
396                                   ColPartitionGridSearch *rectsearch, ColPartition_LIST *part_list) {
397    ColPartition *pix_part =
398        ColPartition::FakePartition(im_box, PT_UNKNOWN, BRT_RECTIMAGE, BTFT_NONTEXT);
399    ColPartition_IT part_it(part_list);
400    part_it.add_after_then_move(pix_part);
401    rectsearch->StartRectSearch(im_box);
402    ColPartition *part;
403    while ((part = rectsearch->NextRectSearch()) != nullptr) {
404      TBOX part_box = part->bounding_box();
405      if (part_box.contains(im_box) && part->flow() >= BTFT_CHAIN) {
406        for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
407          ColPartition *pix_part = part_it.extract();
408          pix_part->DeleteBoxes();
409          delete pix_part;
410        }
411      } else if (part->flow() == BTFT_STRONG_CHAIN) {
412        TBOX overlap_box = part_box.intersection(im_box);
413        int black_area = ImageFind::CountPixelsInRotatedBox(overlap_box, im_box, rerotation, pix);
414        if (black_area * 2 < part_box.area() || !im_box.contains(part_box)) {
415          int padding = part->blob_type() == BRT_VERT_TEXT ? part_box.width() : part_box.height();
416          part_box.set_top(part_box.top() + padding / 2);
417          part_box.set_bottom(part_box.bottom() - padding / 2);
418          CutChunkFromParts(part_box, im_box, rotation, rerotation, pix, part_list);
419        } else {
420          part->set_flow(BTFT_TEXT_ON_IMAGE);
421        }
422      }
423      if (part_list->empty()) {
424        break;
425      }
426    }
427  }
428  static int ExpandImageLeft(const TBOX &box, int left_limit, ColPartitionGrid *part_grid) {
429    ColPartitionGridSearch search(part_grid);
430    ColPartition *part;
431    search.StartSideSearch(box.left(), box.bottom(), box.top());
432    while ((part = search.NextSideSearch(true)) != nullptr) {
433      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
434        const TBOX &part_box(part->bounding_box());
435        if (part_box.y_gap(box) < 0) {
436          if (part_box.right() > left_limit && part_box.right() < box.left()) {
437            left_limit = part_box.right();
438          }
439          break;
440        }
441      }
442    }
443    if (part != nullptr) {
444      TBOX search_box(left_limit, box.bottom(), box.left(), box.top());
445      search.StartRectSearch(search_box);
446      while ((part = search.NextRectSearch()) != nullptr) {
447        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
448          const TBOX &part_box(part->bounding_box());
449          if (part_box.y_gap(box) < 0) {
450            if (part_box.right() > left_limit && part_box.right() < box.left()) {
451              left_limit = part_box.right();
452            }
453          }
454        }
455      }
456    }
457    return left_limit;
458  }
459  static int ExpandImageRight(const TBOX &box, int right_limit, ColPartitionGrid *part_grid) {
460    ColPartitionGridSearch search(part_grid);
461    ColPartition *part;
462    search.StartSideSearch(box.right(), box.bottom(), box.top());
463    while ((part = search.NextSideSearch(false)) != nullptr) {
464      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
465        const TBOX &part_box(part->bounding_box());
466        if (part_box.y_gap(box) < 0) {
467          if (part_box.left() < right_limit && part_box.left() > box.right()) {
468            right_limit = part_box.left();
469          }
470          break;
471        }
472      }
473    }
474    if (part != nullptr) {
475      TBOX search_box(box.left(), box.bottom(), right_limit, box.top());
476      search.StartRectSearch(search_box);
477      while ((part = search.NextRectSearch()) != nullptr) {
478        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
479          const TBOX &part_box(part->bounding_box());
480          if (part_box.y_gap(box) < 0) {
481            if (part_box.left() < right_limit && part_box.left() > box.right()) {
482              right_limit = part_box.left();
483            }
484          }
485        }
486      }
487    }
488    return right_limit;
489  }
490  static int ExpandImageBottom(const TBOX &box, int bottom_limit, ColPartitionGrid *part_grid) {
491    ColPartitionGridSearch search(part_grid);
492    ColPartition *part;
493    search.StartVerticalSearch(box.left(), box.right(), box.bottom());
494    while ((part = search.NextVerticalSearch(true)) != nullptr) {
495      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
496        const TBOX &part_box(part->bounding_box());
497        if (part_box.x_gap(box) < 0) {
498          if (part_box.top() > bottom_limit && part_box.top() < box.bottom()) {
499            bottom_limit = part_box.top();
500          }
501          break;
502        }
503      }
504    }
505    if (part != nullptr) {
506      TBOX search_box(box.left(), bottom_limit, box.right(), box.bottom());
507      search.StartRectSearch(search_box);
508      while ((part = search.NextRectSearch()) != nullptr) {
509        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
510          const TBOX &part_box(part->bounding_box());
511          if (part_box.x_gap(box) < 0) {
512            if (part_box.top() > bottom_limit && part_box.top() < box.bottom()) {
513              bottom_limit = part_box.top();
514            }
515          }
516        }
517      }
518    }
519    return bottom_limit;
520  }
521  static int ExpandImageTop(const TBOX &box, int top_limit, ColPartitionGrid *part_grid) {
522    ColPartitionGridSearch search(part_grid);
523    ColPartition *part;
524    search.StartVerticalSearch(box.left(), box.right(), box.top());
525    while ((part = search.NextVerticalSearch(false)) != nullptr) {
526      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
527        const TBOX &part_box(part->bounding_box());
528        if (part_box.x_gap(box) < 0) {
529          if (part_box.bottom() < top_limit && part_box.bottom() > box.top()) {
530            top_limit = part_box.bottom();
531          }
532          break;
533        }
534      }
535    }
536    if (part != nullptr) {
537      TBOX search_box(box.left(), box.top(), box.right(), top_limit);
538      search.StartRectSearch(search_box);
539      while ((part = search.NextRectSearch()) != nullptr) {
540        if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_CHAIN) {
541          const TBOX &part_box(part->bounding_box());
542          if (part_box.x_gap(box) < 0) {
543            if (part_box.bottom() < top_limit && part_box.bottom() > box.top()) {
544              top_limit = part_box.bottom();
545            }
546          }
547        }
548      }
549    }
550    return top_limit;
551  }
552  static int ExpandImageDir(BlobNeighbourDir dir, const TBOX &im_box, const TBOX &limit_box,
553                            ColPartitionGrid *part_grid, TBOX *expanded_box) {
554    *expanded_box = im_box;
555    switch (dir) {
556      case BND_LEFT:
557        expanded_box->set_left(ExpandImageLeft(im_box, limit_box.left(), part_grid));
558        break;
559      case BND_RIGHT:
560        expanded_box->set_right(ExpandImageRight(im_box, limit_box.right(), part_grid));
561        break;
562      case BND_ABOVE:
563        expanded_box->set_top(ExpandImageTop(im_box, limit_box.top(), part_grid));
564        break;
565      case BND_BELOW:
566        expanded_box->set_bottom(ExpandImageBottom(im_box, limit_box.bottom(), part_grid));
567        break;
568      default:
569        return 0;
570    }
571    return expanded_box->area() - im_box.area();
572  }
573  static void MaximalImageBoundingBox(ColPartitionGrid *part_grid, TBOX *im_box) {
574    bool dunnit[BND_COUNT];
575    memset(dunnit, 0, sizeof(dunnit));
576    TBOX limit_box(part_grid->bleft().x(), part_grid->bleft().y(), part_grid->tright().x(),
577                   part_grid->tright().y());
578    TBOX text_box(*im_box);
579    for (int iteration = 0; iteration < BND_COUNT; ++iteration) {
580      int best_delta = -1;
581      BlobNeighbourDir best_dir = BND_LEFT;
582      TBOX expanded_boxes[BND_COUNT];
583      for (int dir = 0; dir < BND_COUNT; ++dir) {
584        auto bnd = static_cast<BlobNeighbourDir>(dir);
585        if (!dunnit[bnd]) {
586          TBOX expanded_box;
587          int area_delta = ExpandImageDir(bnd, text_box, limit_box, part_grid, &expanded_boxes[bnd]);
588          if (best_delta < 0 || area_delta < best_delta) {
589            best_delta = area_delta;
590            best_dir = bnd;
591          }
592        }
593      }
594      dunnit[best_dir] = true;
595      text_box = expanded_boxes[best_dir];
596    }
597    *im_box = text_box;
598  }
599  static void DeletePartition(ColPartition *part) {
600    BlobRegionType type = part->blob_type();
601    if (type == BRT_RECTIMAGE || type == BRT_POLYIMAGE) {
602      part->DeleteBoxes(); 
603    } else {
604      part->set_flow(BTFT_NONTEXT);
605      part->set_blob_type(BRT_NOISE);
606      part->SetBlobTypes();
607      part->DisownBoxes(); 
608    }
609    delete part;
610  }
611  static bool ExpandImageIntoParts(const TBOX &max_image_box, ColPartitionGridSearch *rectsearch,
612                                   ColPartitionGrid *part_grid, ColPartition **part_ptr) {
613    ColPartition *image_part = *part_ptr;
614    TBOX im_part_box = image_part->bounding_box();
615    if (textord_tabfind_show_images > 1) {
616      tprintf("Searching for merge with image part:");
617      im_part_box.print();
618      tprintf("Text box=");
619      max_image_box.print();
620    }
621    rectsearch->StartRectSearch(max_image_box);
622    ColPartition *part;
623    ColPartition *best_part = nullptr;
624    int best_dist = 0;
625    while ((part = rectsearch->NextRectSearch()) != nullptr) {
626      if (textord_tabfind_show_images > 1) {
627        tprintf("Considering merge with part:");
628        part->Print();
629        if (im_part_box.contains(part->bounding_box())) {
630          tprintf("Fully contained\n");
631        } else if (!max_image_box.contains(part->bounding_box())) {
632          tprintf("Not within text box\n");
633        } else if (part->flow() == BTFT_STRONG_CHAIN) {
634          tprintf("Too strong text\n");
635        } else {
636          tprintf("Real candidate\n");
637        }
638      }
639      if (part->flow() == BTFT_STRONG_CHAIN || part->flow() == BTFT_TEXT_ON_IMAGE ||
640          part->blob_type() == BRT_POLYIMAGE) {
641        continue;
642      }
643      TBOX box = part->bounding_box();
644      if (max_image_box.contains(box) && part->blob_type() != BRT_NOISE) {
645        if (im_part_box.contains(box)) {
646          rectsearch->RemoveBBox();
647          DeletePartition(part);
648          continue;
649        }
650        int x_dist = std::max(0, box.x_gap(im_part_box));
651        int y_dist = std::max(0, box.y_gap(im_part_box));
652        int dist = x_dist * x_dist + y_dist * y_dist;
653        if (dist > box.area() || dist > im_part_box.area()) {
654          continue; 
655        }
656        if (best_part == nullptr || dist < best_dist) {
657          best_part = part;
658          best_dist = dist;
659        }
660      }
661    }
662    if (best_part != nullptr) {
663      TBOX box = best_part->bounding_box();
664      if (textord_tabfind_show_images > 1) {
665        tprintf("Merging image part:");
666        im_part_box.print();
667        tprintf("with part:");
668        box.print();
669      }
670      im_part_box += box;
671      *part_ptr = ColPartition::FakePartition(im_part_box, PT_UNKNOWN, BRT_RECTIMAGE, BTFT_NONTEXT);
672      DeletePartition(image_part);
673      part_grid->RemoveBBox(best_part);
674      DeletePartition(best_part);
675      rectsearch->RepositionIterator();
676      return true;
677    }
678    return false;
679  }
680  static int IntersectArea(const TBOX &box, ColPartition_LIST *part_list) {
681    int intersect_area = 0;
682    ColPartition_IT part_it(part_list);
683    for (part_it.mark_cycle_pt(); !part_it.cycled_list(); part_it.forward()) {
684      ColPartition *image_part = part_it.data();
685      TBOX intersect = box.intersection(image_part->bounding_box());
686      intersect_area += intersect.area();
687    }
688    return intersect_area;
689  }
690  static bool TestWeakIntersectedPart(const TBOX &im_box, ColPartition_LIST *part_list,
691                                      ColPartition *part) {
692    if (part->flow() < BTFT_STRONG_CHAIN) {
693      const TBOX &part_box = part->bounding_box();
694      if (im_box.contains(part_box)) {
695        int area = part_box.area();
696        int intersect_area = IntersectArea(part_box, part_list);
697        if (area < 2 * intersect_area) {
698          return true;
699        }
700      }
701    }
702    return false;
703  }
704  static void EliminateWeakParts(const TBOX &im_box, ColPartitionGrid *part_grid,
705                                 ColPartition_LIST *big_parts, ColPartition_LIST *part_list) {
706    ColPartitionGridSearch rectsearch(part_grid);
707    ColPartition *part;
708    rectsearch.StartRectSearch(im_box);
709    while ((part = rectsearch.NextRectSearch()) != nullptr) {
710      if (TestWeakIntersectedPart(im_box, part_list, part)) {
711        BlobRegionType type = part->blob_type();
712        if (type == BRT_POLYIMAGE || type == BRT_RECTIMAGE) {
713          rectsearch.RemoveBBox();
714          DeletePartition(part);
715        } else {
716          part->set_flow(BTFT_NONTEXT);
717          part->set_blob_type(BRT_NOISE);
718          part->SetBlobTypes();
719        }
720      }
721    }
722    ColPartition_IT big_it(big_parts);
723    for (big_it.mark_cycle_pt(); !big_it.cycled_list(); big_it.forward()) {
724      part = big_it.data();
725      if (TestWeakIntersectedPart(im_box, part_list, part)) {
726        DeletePartition(big_it.extract());
727      }
728    }
729  }
730  static bool ScanForOverlappingText(ColPartitionGrid *part_grid, TBOX *box) {
731    ColPartitionGridSearch rectsearch(part_grid);
732    TBOX padded_box(*box);
733    padded_box.pad(kNoisePadding, kNoisePadding);
734    rectsearch.StartRectSearch(padded_box);
735    ColPartition *part;
736    bool any_text_in_padded_rect = false;
737    while ((part = rectsearch.NextRectSearch()) != nullptr) {
738      if (part->flow() == BTFT_CHAIN || part->flow() == BTFT_STRONG_CHAIN) {
739        any_text_in_padded_rect = true;
740        const TBOX &part_box = part->bounding_box();
741        if (box->overlap(part_box)) {
742          return true;
743        }
744      }
745    }
746    if (!any_text_in_padded_rect) {
747      *box = padded_box;
748    }
749    return false;
750  }
751  static void MarkAndDeleteImageParts(const FCOORD &rerotate, ColPartitionGrid *part_grid,
752                                      ColPartition_LIST *image_parts, Image image_pix) {
753    if (image_pix == nullptr) {
754      return;
755    }
756    int imageheight = pixGetHeight(image_pix);
757    ColPartition_IT part_it(image_parts);
758    for (; !part_it.empty(); part_it.forward()) {
759      ColPartition *part = part_it.extract();
760      TBOX part_box = part->bounding_box();
761      BlobRegionType type = part->blob_type();
762      if (!ScanForOverlappingText(part_grid, &part_box) || type == BRT_RECTIMAGE ||
763          type == BRT_POLYIMAGE) {
764        part_box.rotate(rerotate);
765        int left = part_box.left();
766        int top = part_box.top();
767        pixRasterop(image_pix, left, imageheight - top, part_box.width(), part_box.height(), PIX_SET,
768                    nullptr, 0, 0);
769      }
770      DeletePartition(part);
771    }
772  }
773  void ImageFind::TransferImagePartsToImageMask(const FCOORD &rerotation, ColPartitionGrid *part_grid,
774                                                Image image_mask) {
775    ColPartition_LIST parts_list;
776    ColPartition_IT part_it(&parts_list);
777    ColPartitionGridSearch gsearch(part_grid);
778    gsearch.StartFullSearch();
779    ColPartition *part;
780    while ((part = gsearch.NextFullSearch()) != nullptr) {
781      BlobRegionType type = part->blob_type();
782      if (type == BRT_NOISE || type == BRT_RECTIMAGE || type == BRT_POLYIMAGE) {
783        part_it.add_after_then_move(part);
784        gsearch.RemoveBBox();
785      }
786    }
787    MarkAndDeleteImageParts(rerotation, part_grid, &parts_list, image_mask);
788  }
789  static void DeleteSmallImages(ColPartitionGrid *part_grid) {
790    if (part_grid != nullptr) {
791      return;
792    }
793    ColPartitionGridSearch gsearch(part_grid);
794    gsearch.StartFullSearch();
795    ColPartition *part;
796    while ((part = gsearch.NextFullSearch()) != nullptr) {
797      if (part->blob_type() == BRT_RECTIMAGE) {
798        const TBOX &part_box = part->bounding_box();
799        if (part_box.width() < kMinImageFindSize || part_box.height() < kMinImageFindSize) {
800          gsearch.RemoveBBox();
801          DeletePartition(part);
802        }
803      }
804    }
805  }
806  void ImageFind::FindImagePartitions(Image image_pix, const FCOORD &rotation,
807                                      const FCOORD &rerotation, TO_BLOCK *block, TabFind *tab_grid,
808                                      DebugPixa *pixa_debug, ColPartitionGrid *part_grid,
809                                      ColPartition_LIST *big_parts) {
810    int imageheight = pixGetHeight(image_pix);
811    Boxa *boxa;
812    Pixa *pixa;
813    ConnCompAndRectangularize(image_pix, pixa_debug, &boxa, &pixa);
814    int nboxes = 0;
815    if (boxa != nullptr && pixa != nullptr) {
816      nboxes = boxaGetCount(boxa);
817    }
818    for (int i = 0; i < nboxes; ++i) {
819      l_int32 x, y, width, height;
820      boxaGetBoxGeometry(boxa, i, &x, &y, &width, &height);
821      Image pix = pixaGetPix(pixa, i, L_CLONE);
822      TBOX im_box(x, imageheight - y - height, x + width, imageheight - y);
823      im_box.rotate(rotation); 
824      ColPartitionGridSearch rectsearch(part_grid);
825      rectsearch.SetUniqueMode(true);
826      ColPartition_LIST part_list;
827      DivideImageIntoParts(im_box, rotation, rerotation, pix, &rectsearch, &part_list);
828      if (textord_tabfind_show_images && pixa_debug != nullptr) {
829        pixa_debug->AddPix(pix, "ImageComponent");
830        tprintf("Component has %d parts\n", part_list.length());
831      }
832      pix.destroy();
833      if (!part_list.empty()) {
834        ColPartition_IT part_it(&part_list);
835        if (part_list.singleton()) {
836          ColPartition *part = part_it.extract();
837          TBOX text_box(im_box);
838          MaximalImageBoundingBox(part_grid, &text_box);
839          while (ExpandImageIntoParts(text_box, &rectsearch, part_grid, &part)) {
840            ;
841          }
842          part_it.set_to_list(&part_list);
843          part_it.add_after_then_move(part);
844          im_box = part->bounding_box();
845        }
846        EliminateWeakParts(im_box, part_grid, big_parts, &part_list);
847        for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
848          ColPartition *image_part = part_it.extract();
849          im_box = image_part->bounding_box();
850          part_grid->InsertBBox(true, true, image_part);
851          if (!part_it.at_last()) {
852            ColPartition *neighbour = part_it.data_relative(1);
853            image_part->AddPartner(false, neighbour);
854            neighbour->AddPartner(true, image_part);
855          }
856        }
857      }
858    }
859    boxaDestroy(&boxa);
860    pixaDestroy(&pixa);
861    DeleteSmallImages(part_grid);
862  #ifndef GRAPHICS_DISABLED
863    if (textord_tabfind_show_images) {
864      ScrollView *images_win_ = part_grid->MakeWindow(1000, 400, "With Images");
865      part_grid->DisplayBoxes(images_win_);
866    }
867  #endif
868  }
869  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagefind.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagefind.cpp</div>
                </div>
                <div class="column column_space"><pre><code>381          slice.set_top(box.bottom());
382          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
383            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
384            part_it.add_before_stay_put(
385                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
386          }
387        }
388        part->DeleteBoxes();
</pre></code></div>
                <div class="column column_space"><pre><code>342          slice.set_bottom(box.top());
343          if (ImageFind::CountPixelsInRotatedBox(slice, im_box, rerotation, pix) > 0) {
344            AttemptToShrinkBox(rotation, rerotation, im_box, pix, &slice);
345            part_it.add_before_stay_put(
346                ColPartition::FakePartition(slice, PT_UNKNOWN, BRT_POLYIMAGE, BTFT_NONTEXT));
347          }
348        }
349        if (box.left() > part_box.left()) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    