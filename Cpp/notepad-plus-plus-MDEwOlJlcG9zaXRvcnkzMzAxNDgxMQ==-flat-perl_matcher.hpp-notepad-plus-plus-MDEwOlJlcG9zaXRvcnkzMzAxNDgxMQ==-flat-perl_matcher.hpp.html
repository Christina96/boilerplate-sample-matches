
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_MATCHER_HPP
2  #define BOOST_REGEX_MATCHER_HPP
3  #include <boost/regex/v5/iterator_category.hpp>
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #pragma warning(disable : 4251 4459)
7  #if BOOST_REGEX_MSVC < 1700
8  #     pragma warning(disable : 4231)
9  #endif
10  #  if BOOST_REGEX_MSVC < 1600
11  #     pragma warning(disable : 4660)
12  #  endif
13  #if BOOST_REGEX_MSVC < 1910
14  #pragma warning(disable:4800)
15  #endif
16  #endif
17  namespace boost{
18  namespace BOOST_REGEX_DETAIL_NS{
19  inline void  verify_options(boost::regex_constants::syntax_option_type, match_flag_type mf)
20  {
21     if ((mf & match_extra) && (mf & match_posix))
22     {
23        std::logic_error msg("Usage Error: Can't mix regular expression captures with POSIX matching rules");
24  #ifndef BOOST_REGEX_STANDALONE
25        throw_exception(msg);
26  #else
27        throw msg;
28  #endif
29     }
30  }
31  template <class charT>
32  inline bool can_start(charT c, const unsigned char* map, unsigned char mask)
33  {
34     return ((c < static_cast<charT>(0)) ? true : ((c >= static_cast<charT>(1 << CHAR_BIT)) ? true : map[c] & mask));
35  }
36  inline bool can_start(char c, const unsigned char* map, unsigned char mask)
37  {
38     return map[(unsigned char)c] & mask;
39  }
40  inline bool can_start(signed char c, const unsigned char* map, unsigned char mask)
41  {
42     return map[(unsigned char)c] & mask;
43  }
44  inline bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)
45  {
46     return map[c] & mask;
47  }
48  inline bool can_start(unsigned short c, const unsigned char* map, unsigned char mask)
49  {
50     return ((c >= (1 << CHAR_BIT)) ? true : map[c] & mask);
51  }
52  #if defined(WCHAR_MIN) && (WCHAR_MIN == 0) && !defined(BOOST_NO_INTRINSIC_WCHAR_T)
53  inline bool can_start(wchar_t c, const unsigned char* map, unsigned char mask)
54  {
55     return ((c >= static_cast<wchar_t>(1u << CHAR_BIT)) ? true : map[c] & mask);
56  }
57  #endif
58  #if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
59  inline bool can_start(unsigned int c, const unsigned char* map, unsigned char mask)
60  {
61     return (((c >= static_cast<unsigned int>(1u << CHAR_BIT)) ? true : map[c] & mask));
62  }
63  #endif
64  template <class C, class T, class A>
65  inline int string_compare(const std::basic_string<C,T,A>& s, const C* p)
66  { 
67     if(0 == *p)
68     {
69        if(s.empty() || ((s.size() == 1) && (s[0] == 0)))
70           return 0;
71     }
72     return s.compare(p); 
73  }
74  template <class Seq, class C>
75  inline int string_compare(const Seq& s, const C* p)
76  {
77     std::size_t i = 0;
78     while((i < s.size()) && (p[i] == s[i]))
79     {
80        ++i;
81     }
82     return (i == s.size()) ? -(int)p[i] : (int)s[i] - (int)p[i];
83  }
84  # define STR_COMP(s,p) string_compare(s,p)
85  template<class charT>
86  inline const charT* re_skip_past_null(const charT* p)
87  {
88    while (*p != static_cast<charT>(0)) ++p;
89    return ++p;
90  }
91  template <class iterator, class charT, class traits_type, class char_classT>
92  iterator  re_is_set_member(iterator next, 
93                            iterator last, 
94                            const re_set_long<char_classT>* set_, 
95                            const regex_data<charT, traits_type>& e, bool icase)
96  {   
97     const charT* p = reinterpret_cast<const charT*>(set_+1);
98     iterator ptr;
99     unsigned int i;
100     if(next == last) return next;
101     typedef typename traits_type::string_type traits_string_type;
102     const ::boost::regex_traits_wrapper<traits_type>& traits_inst = *(e.m_ptraits);
103     (void)traits_inst;
104     for(i = 0; i < set_->csingles; ++i)
105     {
106        ptr = next;
107        if(*p == static_cast<charT>(0))
108        {
109           if(traits_inst.translate(*ptr, icase))
110           {
111              ++p;
112              continue;
113           }
<span onclick='openModal()' class='match'>114           return set_->isnot ? next : (ptr == next) ? ++next : ptr;
115        }
</span>116        else
117        {
118           while(*p && (ptr != last))
119           {
120              if(traits_inst.translate(*ptr, icase) != *p)
121                 break;
122              ++p;
123              ++ptr;
124           }
125           if(*p == static_cast<charT>(0)) 
126              return set_->isnot ? next : (ptr == next) ? ++next : ptr;
127           p = re_skip_past_null(p);     
128        }
129     }
130     charT col = traits_inst.translate(*next, icase);
131     if(set_->cranges || set_->cequivalents)
132     {
133        traits_string_type s1;
134        if(set_->cranges)
135        {
136           if((e.m_flags & regex_constants::collate) == 0)
137              s1.assign(1, col);
138           else
139           {
140              charT a[2] = { col, charT(0), };
141              s1 = traits_inst.transform(a, a + 1);
142           }
143           for(i = 0; i < set_->cranges; ++i)
144           {
145              if(STR_COMP(s1, p) >= 0)
146              {
147                 do{ ++p; }while(*p);
148                 ++p;
149                 if(STR_COMP(s1, p) <= 0)
150                    return set_->isnot ? next : ++next;
151              }
152              else
153              {
154                 do{ ++p; }while(*p);
155                 ++p;
156              }
157              do{ ++p; }while(*p);
158              ++p;
159           }
160        }
161        if(set_->cequivalents)
162        {
163           charT a[2] = { col, charT(0), };
164           s1 = traits_inst.transform_primary(a, a +1);
165           for(i = 0; i < set_->cequivalents; ++i)
166           {
167              if(STR_COMP(s1, p) == 0)
168                 return set_->isnot ? next : ++next;
169              do{ ++p; }while(*p);
170              ++p;
171           }
172        }
173     }
174     if(traits_inst.isctype(col, set_->cclasses) == true)
175        return set_->isnot ? next : ++next;
176     if((set_->cnclasses != 0) && (traits_inst.isctype(col, set_->cnclasses) == false))
177        return set_->isnot ? next : ++next;
178     return set_->isnot ? ++next : next;
179  }
180  template <class BidiIterator>
181  class repeater_count
182  {
183     repeater_count** stack;
184     repeater_count* next;
185     int state_id;
186     std::size_t count;        
187     BidiIterator start_pos;   
188     repeater_count* unwind_until(int n, repeater_count* p, int current_recursion_id)
189     { 
190        while(p && (p->state_id != n))
191        {
192           if(-2 - current_recursion_id == p->state_id)
193              return 0;
194           p = p->next;
195           if(p && (p->state_id < 0))
196           {
197              p = unwind_until(p->state_id, p, current_recursion_id);
198              if(!p)
199                 return p;
200              p = p->next;
201           }
202        }
203        return p;
204     }
205  public:
206     repeater_count(repeater_count** s) : stack(s), next(0), state_id(-1), count(0), start_pos() {}
207     repeater_count(int i, repeater_count** s, BidiIterator start, int current_recursion_id)
208        : start_pos(start)
209     {
210        state_id = i;
211        stack = s;
212        next = *stack;
213        *stack = this;
214        if((state_id > next->state_id) && (next->state_id >= 0))
215           count = 0;
216        else
217        {
218           repeater_count* p = next;
219           p = unwind_until(state_id, p, current_recursion_id);
220           if(p)
221           {
222              count = p->count;
223              start_pos = p->start_pos;
224           }
225           else
226              count = 0;
227        }
228     }
229     ~repeater_count()
230     {
231        if(next)
232           *stack = next;
233     }
234     std::size_t get_count() { return count; }
235     int get_id() { return state_id; }
236     std::size_t operator++() { return ++count; }
237     bool check_null_repeat(const BidiIterator& pos, std::size_t max)
238     {
239        bool result = (count == 0) ? false : (pos == start_pos);
240        if(result)
241           count = max;
242        else
243           start_pos = pos;
244        return result;
245     }
246  };
247  struct saved_state;
248  enum saved_state_type
249  {
250     saved_type_end = 0,
251     saved_type_paren = 1,
252     saved_type_recurse = 2,
253     saved_type_assertion = 3,
254     saved_state_alt = 4,
255     saved_state_repeater_count = 5,
256     saved_state_extra_block = 6,
257     saved_state_greedy_single_repeat = 7,
258     saved_state_rep_slow_dot = 8,
259     saved_state_rep_fast_dot = 9,
260     saved_state_rep_char = 10,
261     saved_state_rep_short_set = 11,
262     saved_state_rep_long_set = 12,
263     saved_state_non_greedy_long_repeat = 13, 
264     saved_state_count = 14
265  };
266  #ifdef BOOST_REGEX_MSVC
267  #  pragma warning(push)
268  #if BOOST_REGEX_MSVC >= 1800
269  #pragma warning(disable:26495)
270  #endif
271  #endif
272  template <class Results>
273  struct recursion_info
274  {
275     typedef typename Results::value_type value_type;
276     typedef typename value_type::iterator iterator;
277     int idx;
278     const re_syntax_base* preturn_address;
279     Results results;
280     repeater_count<iterator>* repeater_stack;
281     iterator location_of_start;
282  };
283  #ifdef BOOST_REGEX_MSVC
284  #  pragma warning(pop)
285  #endif
286  template <class BidiIterator, class Allocator, class traits>
287  class perl_matcher
288  {
289  public:
290     typedef typename traits::char_type char_type;
291     typedef perl_matcher<BidiIterator, Allocator, traits> self_type;
292     typedef bool (self_type::*matcher_proc_type)();
293     typedef std::size_t traits_size_type;
294     typedef typename is_byte<char_type>::width_type width_type;
295     typedef typename std::iterator_traits<BidiIterator>::difference_type difference_type;
296     typedef match_results<BidiIterator, Allocator> results_type;
297     perl_matcher(BidiIterator first, BidiIterator end, 
298        match_results<BidiIterator, Allocator>& what, 
299        const basic_regex<char_type, traits>& e,
300        match_flag_type f,
301        BidiIterator l_base)
302        :  m_result(what), base(first), last(end), 
303           position(first), backstop(l_base), re(e), traits_inst(e.get_traits()), 
304           m_independent(false), next_count(&rep_obj), rep_obj(&next_count)
305        , m_recursions(0)
306     {
307        construct_init(e, f);
308     }
309     bool match();
310     bool find();
311     void setf(match_flag_type f)
312     { m_match_flags |= f; }
313     void unsetf(match_flag_type f)
314     { m_match_flags &= ~f; }
315  private:
316     void construct_init(const basic_regex<char_type, traits>& e, match_flag_type f);
317     bool find_imp();
318     bool match_imp();
319     void estimate_max_state_count(std::random_access_iterator_tag*);
320     void estimate_max_state_count(void*);
321     bool match_prefix();
322     bool match_all_states();
323     bool match_startmark();
324     bool match_endmark();
325     bool match_literal();
326     bool match_start_line();
327     bool match_end_line();
328     bool match_wild();
329     bool match_match();
330     bool match_word_boundary();
331     bool match_within_word();
332     bool match_word_start();
333     bool match_word_end();
334     bool match_buffer_start();
335     bool match_buffer_end();
336     bool match_backref();
337     bool match_long_set();
338     bool match_set();
339     bool match_jump();
340     bool match_alt();
341     bool match_rep();
342     bool match_combining();
343     bool match_soft_buffer_end();
344     bool match_restart_continue();
345     bool match_long_set_repeat();
346     bool match_set_repeat();
347     bool match_char_repeat();
348     bool match_dot_repeat_fast();
349     bool match_dot_repeat_slow();
350     bool match_dot_repeat_dispatch()
351     {
352        return ::boost::is_random_access_iterator<BidiIterator>::value ? match_dot_repeat_fast() : match_dot_repeat_slow();
353     }
354     bool match_backstep();
355     bool match_assert_backref();
356     bool match_toggle_case();
357     bool match_recursion();
358     bool match_fail();
359     bool match_accept();
360     bool match_commit();
361     bool match_then();
362     bool skip_until_paren(int index, bool match = true);
363     bool find_restart_any();
364     bool find_restart_word();
365     bool find_restart_line();
366     bool find_restart_buf();
367     bool find_restart_lit();
368  private:
369     match_results<BidiIterator, Allocator>& m_result;
370     std::unique_ptr<match_results<BidiIterator, Allocator> > m_temp_match;
371     match_results<BidiIterator, Allocator>* m_presult;
372     BidiIterator base;
373     BidiIterator last; 
374     BidiIterator position;
375     BidiIterator restart;
376     BidiIterator search_base;
377     BidiIterator backstop;
378     const basic_regex<char_type, traits>& re;
379     const ::boost::regex_traits_wrapper<traits>& traits_inst;
380     const re_syntax_base* pstate;
381     match_flag_type m_match_flags;
382     std::ptrdiff_t state_count;
383     std::ptrdiff_t max_state_count;
384     bool icase;
385     bool m_has_partial_match;
386     bool m_has_found_match;
387     bool m_independent;
388     repeater_count<BidiIterator>* next_count;
389     repeater_count<BidiIterator> rep_obj;
390     typename traits::char_class_type m_word_mask;
391     unsigned char match_any_mask;
392     std::vector<recursion_info<results_type> > recursion_stack;
393     typedef bool (self_type::*unwind_proc_type)(bool);
394     void extend_stack();
395     bool unwind(bool);
396     bool unwind_end(bool);
397     bool unwind_paren(bool);
398     bool unwind_recursion_stopper(bool);
399     bool unwind_assertion(bool);
400     bool unwind_alt(bool);
401     bool unwind_repeater_counter(bool);
402     bool unwind_extra_block(bool);
403     bool unwind_greedy_single_repeat(bool);
404     bool unwind_slow_dot_repeat(bool);
405     bool unwind_fast_dot_repeat(bool);
406     bool unwind_char_repeat(bool);
407     bool unwind_short_set_repeat(bool);
408     bool unwind_long_set_repeat(bool);
409     bool unwind_non_greedy_repeat(bool);
410     bool unwind_recursion(bool);
411     bool unwind_recursion_pop(bool);
412     bool unwind_commit(bool);
413     bool unwind_then(bool);
414     bool unwind_case(bool);
415     void destroy_single_repeat();
416     void push_matched_paren(int index, const sub_match<BidiIterator>& sub);
417     void push_recursion_stopper();
418     void push_assertion(const re_syntax_base* ps, bool positive);
419     void push_alt(const re_syntax_base* ps);
420     void push_repeater_count(int i, repeater_count<BidiIterator>** s);
421     void push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id);
422     void push_non_greedy_repeat(const re_syntax_base* ps);
423     void push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2);
424     void push_recursion_pop();
425     void push_case_change(bool);
426     saved_state* m_stack_base;
427     saved_state* m_backup_state;
428     unsigned used_block_count;
429     bool m_recursive_result;
430     bool m_unwound_lookahead;
431     bool m_unwound_alt;
432     unsigned m_recursions;
433  #ifdef BOOST_REGEX_MSVC
434  #  pragma warning(push)
435  #if BOOST_REGEX_MSVC >= 1800
436  #pragma warning(disable:26495)
437  #endif
438  #endif
439     perl_matcher& operator=(const perl_matcher&)
440     {
441        return *this;
442     }
443     perl_matcher(const perl_matcher& that)
444        : m_result(that.m_result), re(that.re), traits_inst(that.traits_inst), rep_obj(0) {}
445  #ifdef BOOST_REGEX_MSVC
446  #  pragma warning(pop)
447  #endif
448  };
449  } 
450  #ifdef BOOST_REGEX_MSVC
451  #  pragma warning(pop)
452  #endif
453  } 
454  #include <boost/regex/v5/perl_matcher_non_recursive.hpp>
455  #include <boost/regex/v5/perl_matcher_common.hpp>
456  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_MATCHER_HPP
2  #define BOOST_REGEX_MATCHER_HPP
3  #include <boost/regex/v5/iterator_category.hpp>
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #pragma warning(disable : 4251 4459)
7  #if BOOST_REGEX_MSVC < 1700
8  #     pragma warning(disable : 4231)
9  #endif
10  #  if BOOST_REGEX_MSVC < 1600
11  #     pragma warning(disable : 4660)
12  #  endif
13  #if BOOST_REGEX_MSVC < 1910
14  #pragma warning(disable:4800)
15  #endif
16  #endif
17  namespace boost{
18  namespace BOOST_REGEX_DETAIL_NS{
19  inline void  verify_options(boost::regex_constants::syntax_option_type, match_flag_type mf)
20  {
21     if ((mf & match_extra) && (mf & match_posix))
22     {
23        std::logic_error msg("Usage Error: Can't mix regular expression captures with POSIX matching rules");
24  #ifndef BOOST_REGEX_STANDALONE
25        throw_exception(msg);
26  #else
27        throw msg;
28  #endif
29     }
30  }
31  template <class charT>
32  inline bool can_start(charT c, const unsigned char* map, unsigned char mask)
33  {
34     return ((c < static_cast<charT>(0)) ? true : ((c >= static_cast<charT>(1 << CHAR_BIT)) ? true : map[c] & mask));
35  }
36  inline bool can_start(char c, const unsigned char* map, unsigned char mask)
37  {
38     return map[(unsigned char)c] & mask;
39  }
40  inline bool can_start(signed char c, const unsigned char* map, unsigned char mask)
41  {
42     return map[(unsigned char)c] & mask;
43  }
44  inline bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)
45  {
46     return map[c] & mask;
47  }
48  inline bool can_start(unsigned short c, const unsigned char* map, unsigned char mask)
49  {
50     return ((c >= (1 << CHAR_BIT)) ? true : map[c] & mask);
51  }
52  #if defined(WCHAR_MIN) && (WCHAR_MIN == 0) && !defined(BOOST_NO_INTRINSIC_WCHAR_T)
53  inline bool can_start(wchar_t c, const unsigned char* map, unsigned char mask)
54  {
55     return ((c >= static_cast<wchar_t>(1u << CHAR_BIT)) ? true : map[c] & mask);
56  }
57  #endif
58  #if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
59  inline bool can_start(unsigned int c, const unsigned char* map, unsigned char mask)
60  {
61     return (((c >= static_cast<unsigned int>(1u << CHAR_BIT)) ? true : map[c] & mask));
62  }
63  #endif
64  template <class C, class T, class A>
65  inline int string_compare(const std::basic_string<C,T,A>& s, const C* p)
66  { 
67     if(0 == *p)
68     {
69        if(s.empty() || ((s.size() == 1) && (s[0] == 0)))
70           return 0;
71     }
72     return s.compare(p); 
73  }
74  template <class Seq, class C>
75  inline int string_compare(const Seq& s, const C* p)
76  {
77     std::size_t i = 0;
78     while((i < s.size()) && (p[i] == s[i]))
79     {
80        ++i;
81     }
82     return (i == s.size()) ? -(int)p[i] : (int)s[i] - (int)p[i];
83  }
84  # define STR_COMP(s,p) string_compare(s,p)
85  template<class charT>
86  inline const charT* re_skip_past_null(const charT* p)
87  {
88    while (*p != static_cast<charT>(0)) ++p;
89    return ++p;
90  }
91  template <class iterator, class charT, class traits_type, class char_classT>
92  iterator  re_is_set_member(iterator next, 
93                            iterator last, 
94                            const re_set_long<char_classT>* set_, 
95                            const regex_data<charT, traits_type>& e, bool icase)
96  {   
97     const charT* p = reinterpret_cast<const charT*>(set_+1);
98     iterator ptr;
99     unsigned int i;
100     if(next == last) return next;
101     typedef typename traits_type::string_type traits_string_type;
102     const ::boost::regex_traits_wrapper<traits_type>& traits_inst = *(e.m_ptraits);
103     (void)traits_inst;
104     for(i = 0; i < set_->csingles; ++i)
105     {
106        ptr = next;
107        if(*p == static_cast<charT>(0))
108        {
109           if(traits_inst.translate(*ptr, icase))
110           {
111              ++p;
112              continue;
113           }
114           return set_->isnot ? next : (ptr == next) ? ++next : ptr;
115        }
116        else
117        {
118           while(*p && (ptr != last))
119           {
120              if(traits_inst.translate(*ptr, icase) != *p)
121                 break;
122              ++p;
123              ++ptr;
124           }
125           if(*p == static_cast<charT>(0)) 
<span onclick='openModal()' class='match'>126              return set_->isnot ? next : (ptr == next) ? ++next : ptr;
127           p = re_skip_past_null(p);     
</span>128        }
129     }
130     charT col = traits_inst.translate(*next, icase);
131     if(set_->cranges || set_->cequivalents)
132     {
133        traits_string_type s1;
134        if(set_->cranges)
135        {
136           if((e.m_flags & regex_constants::collate) == 0)
137              s1.assign(1, col);
138           else
139           {
140              charT a[2] = { col, charT(0), };
141              s1 = traits_inst.transform(a, a + 1);
142           }
143           for(i = 0; i < set_->cranges; ++i)
144           {
145              if(STR_COMP(s1, p) >= 0)
146              {
147                 do{ ++p; }while(*p);
148                 ++p;
149                 if(STR_COMP(s1, p) <= 0)
150                    return set_->isnot ? next : ++next;
151              }
152              else
153              {
154                 do{ ++p; }while(*p);
155                 ++p;
156              }
157              do{ ++p; }while(*p);
158              ++p;
159           }
160        }
161        if(set_->cequivalents)
162        {
163           charT a[2] = { col, charT(0), };
164           s1 = traits_inst.transform_primary(a, a +1);
165           for(i = 0; i < set_->cequivalents; ++i)
166           {
167              if(STR_COMP(s1, p) == 0)
168                 return set_->isnot ? next : ++next;
169              do{ ++p; }while(*p);
170              ++p;
171           }
172        }
173     }
174     if(traits_inst.isctype(col, set_->cclasses) == true)
175        return set_->isnot ? next : ++next;
176     if((set_->cnclasses != 0) && (traits_inst.isctype(col, set_->cnclasses) == false))
177        return set_->isnot ? next : ++next;
178     return set_->isnot ? ++next : next;
179  }
180  template <class BidiIterator>
181  class repeater_count
182  {
183     repeater_count** stack;
184     repeater_count* next;
185     int state_id;
186     std::size_t count;        
187     BidiIterator start_pos;   
188     repeater_count* unwind_until(int n, repeater_count* p, int current_recursion_id)
189     { 
190        while(p && (p->state_id != n))
191        {
192           if(-2 - current_recursion_id == p->state_id)
193              return 0;
194           p = p->next;
195           if(p && (p->state_id < 0))
196           {
197              p = unwind_until(p->state_id, p, current_recursion_id);
198              if(!p)
199                 return p;
200              p = p->next;
201           }
202        }
203        return p;
204     }
205  public:
206     repeater_count(repeater_count** s) : stack(s), next(0), state_id(-1), count(0), start_pos() {}
207     repeater_count(int i, repeater_count** s, BidiIterator start, int current_recursion_id)
208        : start_pos(start)
209     {
210        state_id = i;
211        stack = s;
212        next = *stack;
213        *stack = this;
214        if((state_id > next->state_id) && (next->state_id >= 0))
215           count = 0;
216        else
217        {
218           repeater_count* p = next;
219           p = unwind_until(state_id, p, current_recursion_id);
220           if(p)
221           {
222              count = p->count;
223              start_pos = p->start_pos;
224           }
225           else
226              count = 0;
227        }
228     }
229     ~repeater_count()
230     {
231        if(next)
232           *stack = next;
233     }
234     std::size_t get_count() { return count; }
235     int get_id() { return state_id; }
236     std::size_t operator++() { return ++count; }
237     bool check_null_repeat(const BidiIterator& pos, std::size_t max)
238     {
239        bool result = (count == 0) ? false : (pos == start_pos);
240        if(result)
241           count = max;
242        else
243           start_pos = pos;
244        return result;
245     }
246  };
247  struct saved_state;
248  enum saved_state_type
249  {
250     saved_type_end = 0,
251     saved_type_paren = 1,
252     saved_type_recurse = 2,
253     saved_type_assertion = 3,
254     saved_state_alt = 4,
255     saved_state_repeater_count = 5,
256     saved_state_extra_block = 6,
257     saved_state_greedy_single_repeat = 7,
258     saved_state_rep_slow_dot = 8,
259     saved_state_rep_fast_dot = 9,
260     saved_state_rep_char = 10,
261     saved_state_rep_short_set = 11,
262     saved_state_rep_long_set = 12,
263     saved_state_non_greedy_long_repeat = 13, 
264     saved_state_count = 14
265  };
266  #ifdef BOOST_REGEX_MSVC
267  #  pragma warning(push)
268  #if BOOST_REGEX_MSVC >= 1800
269  #pragma warning(disable:26495)
270  #endif
271  #endif
272  template <class Results>
273  struct recursion_info
274  {
275     typedef typename Results::value_type value_type;
276     typedef typename value_type::iterator iterator;
277     int idx;
278     const re_syntax_base* preturn_address;
279     Results results;
280     repeater_count<iterator>* repeater_stack;
281     iterator location_of_start;
282  };
283  #ifdef BOOST_REGEX_MSVC
284  #  pragma warning(pop)
285  #endif
286  template <class BidiIterator, class Allocator, class traits>
287  class perl_matcher
288  {
289  public:
290     typedef typename traits::char_type char_type;
291     typedef perl_matcher<BidiIterator, Allocator, traits> self_type;
292     typedef bool (self_type::*matcher_proc_type)();
293     typedef std::size_t traits_size_type;
294     typedef typename is_byte<char_type>::width_type width_type;
295     typedef typename std::iterator_traits<BidiIterator>::difference_type difference_type;
296     typedef match_results<BidiIterator, Allocator> results_type;
297     perl_matcher(BidiIterator first, BidiIterator end, 
298        match_results<BidiIterator, Allocator>& what, 
299        const basic_regex<char_type, traits>& e,
300        match_flag_type f,
301        BidiIterator l_base)
302        :  m_result(what), base(first), last(end), 
303           position(first), backstop(l_base), re(e), traits_inst(e.get_traits()), 
304           m_independent(false), next_count(&rep_obj), rep_obj(&next_count)
305        , m_recursions(0)
306     {
307        construct_init(e, f);
308     }
309     bool match();
310     bool find();
311     void setf(match_flag_type f)
312     { m_match_flags |= f; }
313     void unsetf(match_flag_type f)
314     { m_match_flags &= ~f; }
315  private:
316     void construct_init(const basic_regex<char_type, traits>& e, match_flag_type f);
317     bool find_imp();
318     bool match_imp();
319     void estimate_max_state_count(std::random_access_iterator_tag*);
320     void estimate_max_state_count(void*);
321     bool match_prefix();
322     bool match_all_states();
323     bool match_startmark();
324     bool match_endmark();
325     bool match_literal();
326     bool match_start_line();
327     bool match_end_line();
328     bool match_wild();
329     bool match_match();
330     bool match_word_boundary();
331     bool match_within_word();
332     bool match_word_start();
333     bool match_word_end();
334     bool match_buffer_start();
335     bool match_buffer_end();
336     bool match_backref();
337     bool match_long_set();
338     bool match_set();
339     bool match_jump();
340     bool match_alt();
341     bool match_rep();
342     bool match_combining();
343     bool match_soft_buffer_end();
344     bool match_restart_continue();
345     bool match_long_set_repeat();
346     bool match_set_repeat();
347     bool match_char_repeat();
348     bool match_dot_repeat_fast();
349     bool match_dot_repeat_slow();
350     bool match_dot_repeat_dispatch()
351     {
352        return ::boost::is_random_access_iterator<BidiIterator>::value ? match_dot_repeat_fast() : match_dot_repeat_slow();
353     }
354     bool match_backstep();
355     bool match_assert_backref();
356     bool match_toggle_case();
357     bool match_recursion();
358     bool match_fail();
359     bool match_accept();
360     bool match_commit();
361     bool match_then();
362     bool skip_until_paren(int index, bool match = true);
363     bool find_restart_any();
364     bool find_restart_word();
365     bool find_restart_line();
366     bool find_restart_buf();
367     bool find_restart_lit();
368  private:
369     match_results<BidiIterator, Allocator>& m_result;
370     std::unique_ptr<match_results<BidiIterator, Allocator> > m_temp_match;
371     match_results<BidiIterator, Allocator>* m_presult;
372     BidiIterator base;
373     BidiIterator last; 
374     BidiIterator position;
375     BidiIterator restart;
376     BidiIterator search_base;
377     BidiIterator backstop;
378     const basic_regex<char_type, traits>& re;
379     const ::boost::regex_traits_wrapper<traits>& traits_inst;
380     const re_syntax_base* pstate;
381     match_flag_type m_match_flags;
382     std::ptrdiff_t state_count;
383     std::ptrdiff_t max_state_count;
384     bool icase;
385     bool m_has_partial_match;
386     bool m_has_found_match;
387     bool m_independent;
388     repeater_count<BidiIterator>* next_count;
389     repeater_count<BidiIterator> rep_obj;
390     typename traits::char_class_type m_word_mask;
391     unsigned char match_any_mask;
392     std::vector<recursion_info<results_type> > recursion_stack;
393     typedef bool (self_type::*unwind_proc_type)(bool);
394     void extend_stack();
395     bool unwind(bool);
396     bool unwind_end(bool);
397     bool unwind_paren(bool);
398     bool unwind_recursion_stopper(bool);
399     bool unwind_assertion(bool);
400     bool unwind_alt(bool);
401     bool unwind_repeater_counter(bool);
402     bool unwind_extra_block(bool);
403     bool unwind_greedy_single_repeat(bool);
404     bool unwind_slow_dot_repeat(bool);
405     bool unwind_fast_dot_repeat(bool);
406     bool unwind_char_repeat(bool);
407     bool unwind_short_set_repeat(bool);
408     bool unwind_long_set_repeat(bool);
409     bool unwind_non_greedy_repeat(bool);
410     bool unwind_recursion(bool);
411     bool unwind_recursion_pop(bool);
412     bool unwind_commit(bool);
413     bool unwind_then(bool);
414     bool unwind_case(bool);
415     void destroy_single_repeat();
416     void push_matched_paren(int index, const sub_match<BidiIterator>& sub);
417     void push_recursion_stopper();
418     void push_assertion(const re_syntax_base* ps, bool positive);
419     void push_alt(const re_syntax_base* ps);
420     void push_repeater_count(int i, repeater_count<BidiIterator>** s);
421     void push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id);
422     void push_non_greedy_repeat(const re_syntax_base* ps);
423     void push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2);
424     void push_recursion_pop();
425     void push_case_change(bool);
426     saved_state* m_stack_base;
427     saved_state* m_backup_state;
428     unsigned used_block_count;
429     bool m_recursive_result;
430     bool m_unwound_lookahead;
431     bool m_unwound_alt;
432     unsigned m_recursions;
433  #ifdef BOOST_REGEX_MSVC
434  #  pragma warning(push)
435  #if BOOST_REGEX_MSVC >= 1800
436  #pragma warning(disable:26495)
437  #endif
438  #endif
439     perl_matcher& operator=(const perl_matcher&)
440     {
441        return *this;
442     }
443     perl_matcher(const perl_matcher& that)
444        : m_result(that.m_result), re(that.re), traits_inst(that.traits_inst), rep_obj(0) {}
445  #ifdef BOOST_REGEX_MSVC
446  #  pragma warning(pop)
447  #endif
448  };
449  } 
450  #ifdef BOOST_REGEX_MSVC
451  #  pragma warning(pop)
452  #endif
453  } 
454  #include <boost/regex/v5/perl_matcher_non_recursive.hpp>
455  #include <boost/regex/v5/perl_matcher_common.hpp>
456  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher.hpp</div>
                </div>
                <div class="column column_space"><pre><code>114           return set_->isnot ? next : (ptr == next) ? ++next : ptr;
115        }
</pre></code></div>
                <div class="column column_space"><pre><code>126              return set_->isnot ? next : (ptr == next) ? ++next : ptr;
127           p = re_skip_past_null(p);     
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    