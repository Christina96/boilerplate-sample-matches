
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</h3>
            <pre><code>1  void TPredicateNode::GetVariables(TStrV&amp; Variables) {
2    if (Left != NULL) { Left-&gt;GetVariables(Variables); }
3    if (Right != NULL) { Right-&gt;GetVariables(Variables); }
4    if (Op == NOP) {
5      if (Atom.Lvar != &quot;&quot; ) { Variables.Add(Atom.Lvar); }
6      if (Atom.Rvar != &quot;&quot; ) { Variables.Add(Atom.Rvar); }
7    }
8  }
9  void TPredicate::GetVariables(TStrV&amp; Variables) {
10    Root-&gt;GetVariables(Variables);
11  }
12  TBool TPredicate::Eval() {
13    TPredicateNode* Curr = Root;
14    TPredicateNode* Prev = NULL;
15    while (!(Curr == NULL &amp;&amp; Prev == Root)) {
16      if (Prev == NULL || Prev == Curr-&gt;Parent) {
17        if (Curr-&gt;Left != NULL) {
18          Prev = Curr;
19          Curr = Curr-&gt;Left;
20        } else if (Curr-&gt;Right != NULL) {
21          Prev = Curr;
22          Curr = Curr-&gt;Right;
23        } else {
24          Curr-&gt;Result = EvalAtomicPredicate(Curr-&gt;Atom);
25          Prev = Curr;
26          Curr = Curr-&gt;Parent;
27        }
28      } else if (Prev == Curr-&gt;Left) {
29        switch (Curr-&gt;Op) {
30          case NOT: {
31            Assert(Curr-&gt;Right == NULL);
32            Curr-&gt;Result = !(Prev-&gt;Result);
33            Prev = Curr;
34            Curr = Curr-&gt;Parent;
35            break;
36          }
37          case AND: {
38            Assert(Curr-&gt;Right != NULL);
39            if (!Prev-&gt;Result) {
40              Curr-&gt;Result = false;
41              Prev = Curr;
42              Curr = Curr-&gt;Parent;
43            } else {
44              Prev = Curr;
45              Curr = Curr-&gt;Right;
46            }
47            break;
48          }
49          case OR: {
50            Assert(Curr-&gt;Right != NULL);
51            if (Prev-&gt;Result) {
52              Curr-&gt;Result = true;
53              Prev = Curr;
54              Curr = Curr-&gt;Parent;
55            } else {
56              Prev = Curr;
57              Curr = Curr-&gt;Right;
58            }
59            break;
60          }
61          case NOP: {
62            break;
63          }
64        }
65      } else {
66        Assert(Prev == Curr-&gt;Right);
67        switch (Curr-&gt;Op) {
68          case NOT: {
69            Assert(Curr-&gt;Left == NULL);
70            Curr-&gt;Result = !(Prev-&gt;Result);
71            break;
72          }
73          case AND: {
74            Assert(Curr-&gt;Left != NULL);
75            Assert(Curr-&gt;Left-&gt;Result);
76            Curr-&gt;Result = Prev-&gt;Result;
77            break;
78          }
79          case OR: {
80            Assert(Curr-&gt;Left != NULL);
81            Assert(!Curr-&gt;Left-&gt;Result);
82            Curr-&gt;Result = Prev-&gt;Result;
83            break;
84          }
85          case NOP: {
86            break;
87          }
88        }
89        Prev = Curr;
90        Curr = Curr-&gt;Parent;
91      }
92    }
93    return Root-&gt;Result;
94  }
95  TBool TPredicate::EvalAtomicPredicate(const TAtomicPredicate&amp; Atom) {
96    switch (Atom.Type) {
97      case atInt: {
98        if (Atom.IsConst) { 
99          return EvalAtom&lt;TInt&gt;(IntVars.GetDat(Atom.Lvar), Atom.IntConst, Atom.Compare); 
100        }
101        return EvalAtom&lt;TInt&gt;(IntVars.GetDat(Atom.Lvar), IntVars.GetDat(Atom.Rvar), Atom.Compare);
102      }
103      case atFlt: {
104        if (Atom.IsConst) { 
105          return EvalAtom&lt;TFlt&gt;(FltVars.GetDat(Atom.Lvar), Atom.FltConst, Atom.Compare); 
106        }
107        return EvalAtom&lt;TFlt&gt;(FltVars.GetDat(Atom.Lvar), FltVars.GetDat(Atom.Rvar), Atom.Compare);
108      }
109      case atStr: {
110        if (Atom.IsConst) { 
111          return EvalAtom&lt;TStr&gt;(StrVars.GetDat(Atom.Lvar), Atom.StrConst, Atom.Compare); 
112        }
113        return EvalAtom&lt;TStr&gt;(StrVars.GetDat(Atom.Lvar), StrVars.GetDat(Atom.Rvar), Atom.Compare);
114      }
115    }
116    return false;
117  }
118  TInt const TTable::Last = -1;
119  TInt const TTable::Invalid = -2;
120  TInt TTable::UseMP = 1;
121  TRowIterator&amp; TRowIterator::operator++(int) {
122    return this-&gt;Next();
123  }
124  TRowIterator&amp; TRowIterator::Next() {
125    CurrRowIdx = Table-&gt;Next[CurrRowIdx];
126    return *this;
127  }
128  bool TRowIterator::operator &lt; (const TRowIterator&amp; RowI) const{
129    if (CurrRowIdx == TTable::Last) { return false; }
130    if (RowI.CurrRowIdx == TTable::Last) { return true; }
131    return CurrRowIdx &lt; RowI.CurrRowIdx;
132  }
133  bool TRowIterator::operator == (const TRowIterator&amp; RowI) const {
134    return CurrRowIdx == RowI.CurrRowIdx;
135  }
136  TInt TRowIterator::GetRowIdx() const {
137    return CurrRowIdx;
138  }
139  TInt TRowIterator::GetIntAttr(TInt ColIdx) const {
140    return Table-&gt;IntCols[ColIdx][CurrRowIdx];
141  }
142  TFlt TRowIterator::GetFltAttr(TInt ColIdx) const {
143    return Table-&gt;FltCols[ColIdx][CurrRowIdx];
144  }
145  TStr TRowIterator::GetStrAttr(TInt ColIdx) const {
146    return Table-&gt;GetStrValIdx(ColIdx, CurrRowIdx);
147  }
148  TInt TRowIterator::GetIntAttr(const TStr&amp; Col) const {
149    TInt ColIdx = Table-&gt;GetColIdx(Col);
150    return Table-&gt;IntCols[ColIdx][CurrRowIdx];
151  }
152  TFlt TRowIterator::GetFltAttr(const TStr&amp; Col) const {
153    TInt ColIdx = Table-&gt;GetColIdx(Col);
154    return Table-&gt;FltCols[ColIdx][CurrRowIdx];
155  }
156  TStr TRowIterator::GetStrAttr(const TStr&amp; Col) const {
157    return Table-&gt;GetStrVal(Col, CurrRowIdx);
158  }
159  TInt TRowIterator::GetStrMapByName(const TStr&amp; Col) const {
160    TInt ColIdx = Table-&gt;GetColIdx(Col);
161    return Table-&gt;StrColMaps[ColIdx][CurrRowIdx];
162  }
163  TInt TRowIterator::GetStrMapById(TInt ColIdx) const {
164    return Table-&gt;StrColMaps[ColIdx][CurrRowIdx];
165  }
166  TBool TRowIterator::CompareAtomicConst(TInt ColIdx, const TPrimitive&amp; Val, TPredComp Cmp) {
167    TBool Result;
168    switch (Val.GetType()) {
169      case atInt:
170        Result = TPredicate::EvalAtom(GetIntAttr(ColIdx), Val.GetInt(), Cmp);
171        break;
172      case atFlt:
173        Result = TPredicate::EvalAtom(GetFltAttr(ColIdx), Val.GetFlt(), Cmp);
174        break;
175      case atStr:
176        Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val.GetStr(), Cmp);
177        break;
178      default:
179        Result = TBool(false);
180    }
181    return Result;
182  }
183  TBool TRowIterator::CompareAtomicConstTStr(TInt ColIdx, const TStr&amp; Val, TPredComp Cmp) {
184    TBool Result;
185    Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val, Cmp);
186    return Result;
187  }
188  TRowIteratorWithRemove::TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr) :
189    CurrRowIdx(RowIdx), Table(TablePtr), Start(RowIdx == TablePtr-&gt;FirstValidRow) {}
190  TRowIteratorWithRemove&amp; TRowIteratorWithRemove::operator++(int) {
191    return this-&gt;Next();
192  }
193  TRowIteratorWithRemove&amp; TRowIteratorWithRemove::Next() {
194    CurrRowIdx = GetNextRowIdx();
195    Start = false;
196    Assert(CurrRowIdx != TTable::Invalid);
197    return *this;
198  }
199  bool TRowIteratorWithRemove::operator &lt; (const TRowIteratorWithRemove&amp; RowI) const {
200    if (CurrRowIdx == TTable::Last) { return false; }
201    if (RowI.CurrRowIdx == TTable::Last) { return true; }
202    return CurrRowIdx &lt; RowI.CurrRowIdx;
203  }
204  bool TRowIteratorWithRemove::operator == (const TRowIteratorWithRemove&amp; RowI) const {
205    return CurrRowIdx == RowI.CurrRowIdx;
206  }
207  TInt TRowIteratorWithRemove::GetRowIdx() const {
208    return CurrRowIdx;
209  }
210  TInt TRowIteratorWithRemove::GetNextRowIdx() const {
211    return (Start ? Table-&gt;FirstValidRow : Table-&gt;Next[CurrRowIdx]);
212  }
213  TInt TRowIteratorWithRemove::GetNextIntAttr(TInt ColIdx) const {
214    return Table-&gt;IntCols[ColIdx][GetNextRowIdx()];
215  }
216  TFlt TRowIteratorWithRemove::GetNextFltAttr(TInt ColIdx) const {
217    return Table-&gt;FltCols[ColIdx][GetNextRowIdx()];
218  }
219  TStr TRowIteratorWithRemove::GetNextStrAttr(TInt ColIdx) const {
220    return Table-&gt;GetStrValIdx(ColIdx, GetNextRowIdx());
221  }
222  TInt TRowIteratorWithRemove::GetNextIntAttr(const TStr&amp; Col) const {
223    TInt ColIdx = Table-&gt;GetColIdx(Col);
224    return Table-&gt;IntCols[ColIdx][GetNextRowIdx()];
225  }
226  TFlt TRowIteratorWithRemove::GetNextFltAttr(const TStr&amp; Col) const {
227    TInt ColIdx = Table-&gt;GetColIdx(Col);
228    return Table-&gt;FltCols[ColIdx][GetNextRowIdx()];
229  }
230  TStr TRowIteratorWithRemove::GetNextStrAttr(const TStr&amp; Col) const {
231    return Table-&gt;GetStrVal(Col, GetNextRowIdx());
232  }
233  TBool TRowIteratorWithRemove::IsFirst() const {
234    return CurrRowIdx == Table-&gt;FirstValidRow;
235  }
236  void TRowIteratorWithRemove::RemoveNext() {
237    Table-&gt;RemoveRow(GetNextRowIdx(), CurrRowIdx);
238  }
239  TBool TRowIteratorWithRemove::CompareAtomicConst(TInt ColIdx, const TPrimitive&amp; Val, TPredComp Cmp) {
240    TBool Result;
241    switch (Val.GetType()) {
242      case atInt:
243        Result = TPredicate::EvalAtom(GetNextIntAttr(ColIdx), Val.GetInt(), Cmp);
244        break;
245      case atFlt:
246        Result = TPredicate::EvalAtom(GetNextFltAttr(ColIdx), Val.GetFlt(), Cmp);
247        break;
248      case atStr:
249        Result = TPredicate::EvalStrAtom(GetNextStrAttr(ColIdx), Val.GetStr(), Cmp);
250        break;
251      default:
252        Result = TBool(false);
253    }
254    return Result;
255  }
256  TTable::TTable(): Context(new TTableContext), NumRows(0), NumValidRows(0),
257    FirstValidRow(0), LastValidRow(-1) {}
258  TTable::TTable(TTableContext* Context): Context(Context), NumRows(0),
259    NumValidRows(0), FirstValidRow(0), LastValidRow(-1) {}
260  TTable::TTable(const Schema&amp; TableSchema, TTableContext* Context): Context(Context), 
261    NumRows(0), NumValidRows(0), FirstValidRow(0), LastValidRow(-1), IsNextDirty(0) {
262    TInt IntColCnt = 0;
263    TInt FltColCnt = 0;
264    TInt StrColCnt = 0;
265    for (TInt i = 0; i &lt; TableSchema.Len(); i++) {
266      TStr ColName = TableSchema[i].Val1;
267      TAttrType ColType = TableSchema[i].Val2;
268      AddSchemaCol(ColName, ColType);
269      switch (ColType) {
270        case atInt:
271          AddColType(ColName, atInt, IntColCnt);
272          IntColCnt++;
273          break;
274        case atFlt:
275          AddColType(ColName, atFlt, FltColCnt);
276          FltColCnt++;
277          break;
278        case atStr:
279          AddColType(ColName, atStr, StrColCnt);
280          StrColCnt++;
281          break;
282      }
283    }
284    IntCols = TVec&lt;TIntV&gt;(IntColCnt);
285    FltCols = TVec&lt;TFltV&gt;(FltColCnt);
286    StrColMaps = TVec&lt;TIntV&gt;(StrColCnt);
287  }
288  void TTable::GenerateColTypeMap(THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; &amp; ColTypeIntMap) {
289    ColTypeMap.Clr();
290    Sch.Clr();
291    for (THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt;::TIter it = ColTypeIntMap.BegI(); it &lt; ColTypeIntMap.EndI(); it++) {
292      TPair&lt;TInt,TInt&gt; dat = it.GetDat();
293      switch (dat.GetVal1()) {
294        case 0:
295          AddColType(it.GetKey(), atInt, dat.GetVal2());
296          AddSchemaCol(it.GetKey(), atInt);
297          break;
298        case 1:
299          AddColType(it.GetKey(), atFlt, dat.GetVal2());
300          AddSchemaCol(it.GetKey(), atFlt);
301          break;
302        case 2:
303          AddColType(it.GetKey(), atStr, dat.GetVal2());
304          AddSchemaCol(it.GetKey(), atStr);
305          break;
306      }
307    }
308    IsNextDirty = 0;
309  }
310  void TTable::LoadTableShM(TShMIn&amp; ShMIn, TTableContext* ContextTable) {
311    Context = ContextTable;
312    NumRows = TInt(ShMIn);
313    NumValidRows = TInt(ShMIn);
314    FirstValidRow = TInt(ShMIn);
315    LastValidRow = TInt(ShMIn);
316    Next.LoadShM(ShMIn);
317    TLoadVecInit Fn;
318    IntCols.LoadShM(ShMIn, Fn);
319    FltCols.Load(ShMIn);
320    StrColMaps.LoadShM(ShMIn, Fn);
321    THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; ColTypeIntMap;
322    ColTypeIntMap.LoadShM(ShMIn);
323    GenerateColTypeMap(ColTypeIntMap);
324  }
325  TTable::TTable(TSIn&amp; SIn, TTableContext* Context): Context(Context), NumRows(SIn),
326    NumValidRows(SIn), FirstValidRow(SIn), LastValidRow(SIn), Next(SIn), IntCols(SIn),
327    FltCols(SIn), StrColMaps(SIn) {
328    THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; ColTypeIntMap(SIn);
329    GenerateColTypeMap(ColTypeIntMap);
330  }
331  TTable::TTable(const TIntIntH&amp; H, const TStr&amp; Col1, const TStr&amp; Col2,
332   TTableContext* Context, const TBool IsStrKeys) : Context(Context), NumRows(H.Len()),
333    NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
334      TAttrType KeyType = IsStrKeys ? atStr : atInt;
335      AddSchemaCol(Col1, KeyType);
336      AddSchemaCol(Col2, atInt);
337      AddColType(Col1, KeyType, 0);
338      AddColType(Col2, atInt, 1);
339      if (IsStrKeys) {
340        StrColMaps = TVec&lt;TIntV&gt;(1);
341        IntCols = TVec&lt;TIntV&gt;(1);
342        H.GetKeyV(StrColMaps[0]);
343        H.GetDatV(IntCols[0]);
344      } else {
345        IntCols = TVec&lt;TIntV&gt;(2);
346        H.GetKeyV(IntCols[0]);
347        H.GetDatV(IntCols[1]);
348      }
349      Next = TIntV(NumRows);
350      for (TInt i = 0; i &lt; NumRows; i++) {
351        Next[i] = i+1;
352      }
353      Next[NumRows-1] = Last;
354      IsNextDirty = 0;
355      InitIds();
356  }
357  TTable::TTable(const TIntFltH&amp; H, const TStr&amp; Col1, const TStr&amp; Col2,
358   TTableContext* Context, const TBool IsStrKeys) : Context(Context),
359    NumRows(H.Len()), NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
360    TAttrType KeyType = IsStrKeys ? atStr : atInt;
361    AddSchemaCol(Col1, KeyType);
362    AddSchemaCol(Col2, atFlt);
363    AddColType(Col1, KeyType, 0);
364    AddColType(Col2, atFlt, 0);
365    if (IsStrKeys) {
366      StrColMaps = TVec&lt;TIntV&gt;(1);
367      H.GetKeyV(StrColMaps[0]);
368    } else {
369      IntCols = TVec&lt;TIntV&gt;(1);
370      H.GetKeyV(IntCols[0]);
371    }
372    FltCols = TVec&lt;TFltV&gt;(1);
373    H.GetDatV(FltCols[0]);
374    Next = TIntV(NumRows);
375    for (TInt i = 0; i &lt; NumRows; i++) {
376      Next[i] = i+1;
377    }
378    Next[NumRows-1] = Last;
379    IsNextDirty = 0;
380    InitIds();
381  }
382  TTable::TTable(const TTable&amp; Table, const TIntV&amp; RowIDs) : Context(Table.Context),
383    Sch(Table.Sch), SrcCol(Table.SrcCol), DstCol(Table.DstCol), EdgeAttrV(Table.EdgeAttrV),
384    SrcNodeAttrV(Table.SrcNodeAttrV), DstNodeAttrV(Table.DstNodeAttrV),
385    CommonNodeAttrs(Table.CommonNodeAttrs) {
386    ColTypeMap = Table.ColTypeMap;
387    IntCols = TVec&lt;TIntV&gt;(Table.IntCols.Len());
388    FltCols = TVec&lt;TFltV&gt;(Table.FltCols.Len());
389    StrColMaps = TVec&lt;TIntV&gt;(Table.StrColMaps.Len());
390    FirstValidRow = 0;
391    LastValidRow = -1;
392    NumRows = 0;
393    NumValidRows = 0;
394    AddSelectedRows(Table, RowIDs);
395    IsNextDirty = 0;
396    InitIds();
397  }
398  void TTable::GetSchema(const TStr&amp; InFNm, Schema&amp; S, const char&amp; Separator) {
399    TSsParser Ss(InFNm, &#x27;\t&#x27;, false, false, false);
400    TInt rowsToPeek = 1000;
401    TInt currRow = 0;
402    TInt lastComment = 0;
403    while (Ss.Next()) {
404      if (Ss.IsCmt()) {
405        lastComment += 1;
406      }
407      else break;
408    }
409    if (Ss.Eof()) {TExcept::Throw(&quot;No Data to determine attribute types!&quot;);}
410    TInt numCols = Ss.GetFlds();
411    TVec&lt;TAttrType&gt; colAttrV(numCols);
412    colAttrV.PutAll(atInt);
413    while (true) {
414      for (TInt i = 0; i &lt; numCols; i++) {
415        if (Ss.IsInt(i)) {
416        }
417        else if (Ss.IsFlt(i)) {
418          colAttrV[i] = atFlt;
419        }
420        else {
421          colAttrV[i] = atStr;
422        }
423      }
424      currRow++;
425      if (currRow &gt; rowsToPeek || Ss.Eof()) break;
426      Ss.Next();
427    }
428    TSsParser SsNames(InFNm, Separator, false, false, false);
429    for (int i = 0; i &lt; lastComment; i++) { SsNames.Next();}
430    TVec&lt;TStr&gt; attrV;
431    TStr first(SsNames[0]);
432    int begin = 0;
433    TStr comment(&#x27;#&#x27;);
434    if (first != comment) {
435      for (int i = 1; i &lt; first.Len(); i++){
436        if (first[i] != &#x27; &#x27;) { begin = i; break;}
437      }
438      attrV.Add(first.GetSubStr(begin));
439    }
440    for (int i = 1; i &lt; SsNames.GetFlds(); i++) {attrV.Add(SsNames[i]);}
441    for (TInt i = 0; i &lt; numCols; i++) {
442      S.Add(TPair&lt;TStr,TAttrType&gt;(attrV[i],colAttrV[i]));
443    } 
444  }
445  #ifdef GCC_ATOMIC
446  void TTable::LoadSSPar(PTable&amp; T, const Schema&amp; S, const TStr&amp; InFNm, const TIntV&amp; RelevantCols, 
447                          const char&amp; Separator, TBool HasTitleLine) {
448    TInt RowLen = T-&gt;Sch.Len();
449    TVec&lt;TAttrType&gt; ColTypes = TVec&lt;TAttrType&gt;(RowLen);
450    for (TInt i = 0; i &lt; RowLen; i++) {
451      ColTypes[i] = T-&gt;GetSchemaColType(i);
452    }
453    TSsParserMP Ss(InFNm, Separator);
454    Ss.SkipCommentLines();
455    if (HasTitleLine) {
456      Ss.Next();
457      if (S.Len() != Ss.GetFlds()) {
458        printf(&quot;%s\n&quot;, Ss[0]); TExcept::Throw(&quot;Table Schema Mismatch!&quot;);
459      }
460      for (TInt i = 0; i &lt; Ss.GetFlds(); i++) {
461        TInt L = strlen(Ss[i]);
462        if (Ss[i][L-1] &lt; &#x27; &#x27;) { Ss[i][L-1] = 0; }
463        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw(&quot;Table Schema Mismatch!&quot;); }
464      }
465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
469    uint64 Rem = Len - Pos;
470    int NumThreads = omp_get_max_threads();
471    uint64 Delta = Rem / NumThreads;
472    if (Delta &lt; 1) Delta = 1;
473    TVec&lt;uint64&gt; StartIntV(NumThreads);
474    TVec&lt;uint64&gt; LineCountV(NumThreads);
475    TVec&lt;uint64&gt; PrefixSumV(NumThreads);
476    StartIntV[0] = Pos;
477    for (int i = 1; i &lt; NumThreads; i++) {
478      StartIntV[i] = StartIntV[i-1] + Delta;
479    }
480    StartIntV.Add(Len);
481    omp_set_num_threads(NumThreads);
482    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
483    for (int i = 0; i &lt; NumThreads; i++) {
484      LineCountV[i] = Ss.CountNewLinesInRange(StartIntV[i], StartIntV[i+1]);
485      Cnt += LineCountV[i];
486    }
487    PrefixSumV[0] = 0;
488    for (int i = 1; i &lt; NumThreads; i++) {
489      PrefixSumV[i] = PrefixSumV[i-1] + LineCountV[i-1];
490    }
491    Ss.SetStreamPos(Pos);
492    TInt IntColIdx = 0;
493    TInt FltColIdx = 0;
494    for (TInt i = 0; i &lt; RowLen; i++) {
495      switch (ColTypes[i]) {
496        case atInt:
497          T-&gt;IntCols[IntColIdx].Gen(Cnt);
498          IntColIdx++;
499          break;
500        case atFlt:
501          T-&gt;FltCols[FltColIdx].Gen(Cnt);
502          FltColIdx++;
503          break;
504        case atStr:
505          break;
506      }
507    }
508    Cnt = 0;
509    omp_set_num_threads(NumThreads);
510    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
511    for (int i = 0; i &lt; NumThreads; i++) {
512      TVec&lt;uint64&gt; LineStartPosV = Ss.GetStartPosV(StartIntV[i], StartIntV[i+1]);
513      for (uint64 k = 0; k &lt; (uint64) LineStartPosV.Len(); k++) {
514        TVec&lt;char*&gt; FieldsV;
515        Ss.NextFromIndex(LineStartPosV[k], FieldsV);
516        if (FieldsV.Len() != S.Len()) {
517          TExcept::Throw(&quot;Error reading tsv file&quot;);
518        }
519        TInt IntColIdx = 0;
520        TInt FltColIdx = 0;
521        TInt RowIdx = PrefixSumV[i] + k;
522        for (TInt j = 0; j &lt; RowLen; j++) {
523          switch (ColTypes[j]) {
524            case atInt:
525              if (RelevantCols.Len() == 0) {
526                T-&gt;IntCols[IntColIdx][RowIdx] = \
527                  (Ss.GetIntFromFldV(FieldsV, j));
528              } else {
529                T-&gt;IntCols[IntColIdx][RowIdx] = \
530                  (Ss.GetIntFromFldV(FieldsV, RelevantCols[j]));
531              }
532              IntColIdx++;
533              break;
534            case atFlt:
535              if (RelevantCols.Len() == 0) {
536                T-&gt;FltCols[FltColIdx][RowIdx] = \
537                  (Ss.GetFltFromFldV(FieldsV, j));
538              } else {
539                T-&gt;FltCols[FltColIdx][RowIdx] = \
540                  (Ss.GetFltFromFldV(FieldsV, RelevantCols[j]));
541              }
542              FltColIdx++;
543              break;
544            case atStr:
545              TExcept::Throw(&quot;TTable::LoadSS:: Str Col found\n&quot;);
546              break;
547          }
548        }
549        Cnt++;
550      }
551    }
552    T-&gt;NumRows = Cnt;
553    T-&gt;NumValidRows = T-&gt;NumRows;
554    T-&gt;Next.Clr();
555    T-&gt;Next.Gen(Cnt);
556    omp_set_num_threads(NumThreads);
557    #pragma omp parallel for schedule(dynamic, 10000)
558    for (int64 i = 0; i &lt; Cnt-1; i++) {
559      T-&gt;Next[i] = i+1;
560    }
561    T-&gt;IsNextDirty = 0;
562    T-&gt;Next[Cnt-1] = Last;
563    T-&gt;LastValidRow = T-&gt;NumRows - 1;
564    T-&gt;IdColName = &quot;_id&quot;;
565    TInt IdCol = T-&gt;IntCols.Add();
566    T-&gt;IntCols[IdCol].Gen(Cnt);
567    omp_set_num_threads(NumThreads);
568    #pragma omp parallel for schedule(dynamic, 10000)
569    for (int64 i = 0; i &lt; Cnt; i++) {
570      T-&gt;IntCols[IdCol][i] = i;
571    }
572    T-&gt;AddSchemaCol(T-&gt;IdColName, atInt);
573    T-&gt;AddColType(T-&gt;IdColName, atInt, T-&gt;IntCols.Len()-1);
574  }
575  #endif 
576  void TTable::LoadSSSeq(
577   PTable&amp; T, const Schema&amp; S, const TStr&amp; InFNm, const TIntV&amp; RelevantCols,
578   const char&amp; Separator, TBool HasTitleLine) {
579    int RowLen = T-&gt;Sch.Len();
580    TVec&lt;TAttrType&gt; ColTypes = TVec&lt;TAttrType&gt;(RowLen);
581    for (int i = 0; i &lt; RowLen; i++) {
582      ColTypes[i] = T-&gt;GetSchemaColType(i);
583    }
584    TSsParser Ss(InFNm, Separator);
585    if (HasTitleLine) {
586      Ss.Next();
587      if (S.Len() != Ss.GetFlds()) {
588        printf(&quot;%s\n&quot;, Ss[0]); TExcept::Throw(&quot;Table Schema Mismatch!&quot;);
589      }
590      for (int i = 0; i &lt; Ss.GetFlds(); i++) {
591        int L = strlen(Ss[i]);
592        if (Ss[i][L-1] &lt; &#x27; &#x27;) { Ss[i][L-1] = 0; }
593        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw(&quot;Table Schema Mismatch!&quot;); }
594      }
595    }
596    uint64 Cnt = 0;
597    while (Ss.Next()) {
598      int IntColIdx = 0;
599      int FltColIdx = 0;
600      int StrColIdx = 0;
601      Assert(Ss.GetFlds() == S.Len()); 
602      if (Ss.GetFlds() != S.Len()) {
603        printf(&quot;%s\n&quot;, Ss[S.Len()]); TExcept::Throw(&quot;Error reading tsv file&quot;);
604      }
605      for (int i = 0; i &lt; RowLen; i++) {
606        switch (ColTypes[i]) {
607          case atInt:
608            if (RelevantCols.Len() == 0) {
609              T-&gt;IntCols[IntColIdx].Add(Ss.GetInt(i));
610            } else {
611              T-&gt;IntCols[IntColIdx].Add(Ss.GetInt(RelevantCols[i]));
612            }
613            IntColIdx++;
614            break;
615          case atFlt:
616            if (RelevantCols.Len() == 0) {
617              T-&gt;FltCols[FltColIdx].Add(Ss.GetFlt(i));
618            } else {
619              T-&gt;FltCols[FltColIdx].Add(Ss.GetFlt(RelevantCols[i]));
620            }
621            FltColIdx++;
622            break;
623          case atStr:
624            int ColIdx;
625            if (RelevantCols.Len() == 0) {
626              ColIdx = i;
627            } else {
628              ColIdx = RelevantCols[i];
629            }
630            TStr Sval = TStr(Ss[ColIdx]);
631            T-&gt;AddStrVal(StrColIdx, Sval);
632            StrColIdx++;
633            break;
634        }
635      }
636      Cnt += 1;
637    }
638    T-&gt;NumRows = static_cast&lt;int&gt;(Cnt);
639    T-&gt;NumValidRows = T-&gt;NumRows;
640    T-&gt;Next.Clr();
641    T-&gt;Next.Gen(static_cast&lt;int&gt;(Cnt));
642    for (uint64 i = 0; i &lt; Cnt-1; i++) {
643      T-&gt;Next[static_cast&lt;int&gt;(i)] = static_cast&lt;int&gt;(i+1);
644    }
645    T-&gt;IsNextDirty = 0;
646    T-&gt;Next[static_cast&lt;int&gt;(Cnt-1)] = Last;
647    T-&gt;LastValidRow = T-&gt;NumRows - 1;
648    T-&gt;InitIds();
649  }
650  PTable TTable::LoadSS(const Schema&amp; S, const TStr&amp; InFNm, TTableContext* Context,
651   const TIntV&amp; RelevantCols, const char&amp; Separator, TBool HasTitleLine) {
652    TVec&lt;uint64&gt; IntGroupByCols;
653    bool NoStringCols = true;
654    Schema SR;
655    if (RelevantCols.Len() == 0) {
656      SR = S;
657    } else {
658      for (int i = 0; i &lt; RelevantCols.Len(); i++) {
659        SR.Add(S[RelevantCols[i]]);
660      }
661    }
662    PTable T = New(SR, Context);
663    for (int i = 0; i &lt; SR.Len(); i++) {
664      if (T-&gt;GetSchemaColType(i) == atStr) {
665        NoStringCols = false;
666        break;
667      }
668    }
669    if (GetMP() &amp;&amp; NoStringCols) {
670  #ifdef GLib_LINUX
671      LoadSSPar(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
672  #else
673      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
674  #endif
675    } else {
676      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
677    }
678    return T;
679  }
680  PTable TTable::LoadSS(const Schema&amp; S, const TStr&amp; InFNm, TTableContext* Context,
681   const char&amp; Separator, TBool HasTitleLine) {
682    return LoadSS(S, InFNm, Context, TIntV(), Separator, HasTitleLine);
683  }
684  void TTable::SaveSS(const TStr&amp; OutFNm) {
685    if (NumValidRows == 0) {
686      printf(&quot;Table is empty&quot;);
687      return;
688    }
689    FILE* F = fopen(OutFNm.CStr(), &quot;w&quot;);
690    if (F == NULL) {
691      printf(&quot;failed to open file %s\n&quot;, OutFNm.CStr());
692      perror(&quot;fail &quot;);
693      return;
694    }
695    Dump(F);
696  #if 0
697    Schema DSch = DenormalizeSchema();
698    TInt L = Sch.Len();
699    fprintf(F, &quot;# &quot;);
700    for (TInt i = 0; i &lt; L-1; i++) {
701      fprintf(F, &quot;%s\t&quot;, DSch[i].Val1.CStr());
702    }  
703    fprintf(F, &quot;%s\n&quot;, DSch[L-1].Val1.CStr());
704    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
705      for (TInt i = 0; i &lt; L; i++) {
706        char C = (i == L-1) ? &#x27;\n&#x27; : &#x27;\t&#x27;;
707        switch (GetSchemaColType(i)) {
708          case atInt: {
709            fprintf(F, &quot;%d%c&quot;, RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
710            break;
711          }
712          case atFlt: {
713            fprintf(F, &quot;%f%c&quot;, RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
714            break;
715          }
716          case atStr: {
717            fprintf(F, &quot;%s%c&quot;, RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
718            break;
719          }
720        }
721      }
722    }
723  #endif
724    fclose(F);
725  }
726  void TTable::SaveBin(const TStr&amp; OutFNm) {
727    TFOut SOut(OutFNm);
728    Save(SOut);
729  }
730  void TTable::Save(TSOut&amp; SOut) {
731    NumRows.Save(SOut);
732    NumValidRows.Save(SOut);
733    FirstValidRow.Save(SOut);
734    LastValidRow.Save(SOut);
735    Next.Save(SOut);
736    IntCols.Save(SOut);
737    FltCols.Save(SOut);
738    StrColMaps.Save(SOut);
739    THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; ColTypeIntMap;
740    TInt atIntVal = TInt(0);
741    TInt atFltVal = TInt(1);
742    TInt atStrVal = TInt(2);
743    for (THash&lt;TStr,TPair&lt;TAttrType,TInt&gt; &gt;::TIter it = ColTypeMap.BegI(); it &lt; ColTypeMap.EndI(); it++) {
744      TPair&lt;TAttrType,TInt&gt; dat = it.GetDat();
745      TStr DColName = DenormalizeColName(it.GetKey());
746      switch (dat.GetVal1()) {
747        case atInt:
748          ColTypeIntMap.AddDat(DColName, TPair&lt;TInt,TInt&gt;(atIntVal, dat.GetVal2()));
749          break;
750        case atFlt:
751          ColTypeIntMap.AddDat(DColName, TPair&lt;TInt,TInt&gt;(atFltVal, dat.GetVal2()));
752          break;
753        case atStr:
754          ColTypeIntMap.AddDat(DColName, TPair&lt;TInt,TInt&gt;(atStrVal, dat.GetVal2()));
755          break;
756      }
757    }
758    ColTypeIntMap.Save(SOut);
759    SOut.Flush();
760  }
761  void TTable::Dump(FILE *OutF) const {
762    TInt L = Sch.Len();
763    Schema DSch = DenormalizeSchema();
764    fprintf(OutF, &quot;# &quot;);
765    for (TInt i = 0; i &lt; L-1; i++) {
766      fprintf(OutF, &quot;%s\t&quot;, DSch[i].Val1.CStr());
767    }  
768    fprintf(OutF, &quot;%s\n&quot;, DSch[L-1].Val1.CStr());
769    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
770      for (TInt i = 0; i &lt; L; i++) {
771        char C = (i == L-1) ? &#x27;\n&#x27; : &#x27;\t&#x27;;
772        switch (GetSchemaColType(i)) {
773          case atInt: {
774            fprintf(OutF, &quot;%d%c&quot;, RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
775            break;
776          }
777          case atFlt: {
778            fprintf(OutF, &quot;%f%c&quot;, RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
779            break;
780          }
781          case atStr: {
782            fprintf(OutF, &quot;%s%c&quot;, RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
783            break;
784          }
785        }
786      }
787    }
788  }
789  TTableContext* TTable::ChangeContext(TTableContext* NewContext) {
790    TInt L = Sch.Len();
791  #if 0
792    for (TInt i = 0; i &lt; L; i++) {
793      if (GetSchemaColType(i) != atStr) {
794        continue;
795      }
796      TInt ColIdx = GetColIdx(GetSchemaColName(i));
797      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
798        TInt RowIdx = RowI.GetRowIdx();
799        TInt KeyId = StrColMaps[ColIdx][RowIdx];
800        printf(&quot;ChangeContext in  %d  %d  %d  .%s.\n&quot;,
801            ColIdx.Val, RowIdx.Val, KeyId.Val, GetStrVal(ColIdx, RowIdx).CStr());
802      }
803    }
804  #endif
805    for (TInt i = 0; i &lt; L; i++) {
806      if (GetSchemaColType(i) != atStr) {
807        continue;
808      }
809      TInt ColIdx = GetColIdx(GetSchemaColName(i));
810      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
811        TInt RowIdx = RowI.GetRowIdx();
812        TStr Key = GetStrValIdx(ColIdx, RowIdx);
813        TInt KeyId = TInt(NewContext-&gt;StringVals.AddKey(Key));
814        StrColMaps[ColIdx][RowIdx] = KeyId;
815      }
816    }
817    Context = NewContext;
818    return Context;
819  }
820  void TTable::AddStrVal(const TInt&amp; ColIdx, const TStr&amp; Key) {
821    TInt KeyId = TInt(Context-&gt;StringVals.AddKey(Key));
822    StrColMaps[ColIdx].Add(KeyId);
823  }
824  void TTable::AddStrVal(const TStr&amp; Col, const TStr&amp; Key) {
825    if (GetColType(Col) != atStr) {
826      TExcept::Throw(Col + &quot; is not a string valued column&quot;);
827    }
828    AddStrVal(GetColIdx(Col), Key);
829  }
830  void TTable::AddGraphAttribute(const TStr&amp; Attr, TBool IsEdge, TBool IsSrc, TBool IsDst) {
831    if (!IsColName(Attr)) { TExcept::Throw(Attr + &quot;: No such column&quot;); }
832    if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attr)); }
833    if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attr)); }
834    if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attr)); }
835  }
836  void TTable::AddGraphAttributeV(TStrV&amp; Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst) {
837    for (TInt i = 0; i &lt; Attrs.Len(); i++) {
838      if (!IsColName(Attrs[i])) {
839        TExcept::Throw(Attrs[i] + &quot;: no such column&quot;);
840      }
841    }
842    for (TInt i = 0; i &lt; Attrs.Len(); i++) {
843      if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attrs[i])); }
844      if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attrs[i])); }
845      if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attrs[i])); }
846    }
847  }
848  TStrV TTable::GetSrcNodeIntAttrV() const {
849    TStrV IntNA = TStrV(IntCols.Len(),0);
850    for (TInt i = 0; i &lt; SrcNodeAttrV.Len(); i++) {
851      TStr Attr = SrcNodeAttrV[i];
852      if (GetColType(Attr) == atInt) {
853        IntNA.Add(Attr);
854      }
855    }
856    return IntNA;
857  }
858  TStrV TTable::GetDstNodeIntAttrV() const {
859    TStrV IntNA = TStrV(IntCols.Len(),0);
860    for (TInt i = 0; i &lt; DstNodeAttrV.Len(); i++) {
861      TStr Attr = DstNodeAttrV[i];
862      if (GetColType(Attr) == atInt) {
863        IntNA.Add(Attr);
864      }
865    }
866    return IntNA;
867  }
868  TStrV TTable::GetEdgeIntAttrV() const {
869    TStrV IntEA = TStrV(IntCols.Len(),0);
870    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
871      TStr Attr = EdgeAttrV[i];
872      if (GetColType(Attr) == atInt) {
873        IntEA.Add(Attr);
874      }
875    }
876    return IntEA;
877  }
878  TStrV TTable::GetSrcNodeFltAttrV() const {
879    TStrV FltNA = TStrV(FltCols.Len(),0);
880    for (TInt i = 0; i &lt; SrcNodeAttrV.Len(); i++) {
881      TStr Attr = SrcNodeAttrV[i];
882      if (GetColType(Attr) == atFlt) {
883        FltNA.Add(Attr);
884      }
885    }
886    return FltNA;
887  }
888  TStrV TTable::GetDstNodeFltAttrV() const {
889    TStrV FltNA = TStrV(FltCols.Len(),0);
890    for (TInt i = 0; i &lt; DstNodeAttrV.Len(); i++) {
891      TStr Attr = DstNodeAttrV[i];
892      if (GetColType(Attr) == atFlt) {
893        FltNA.Add(Attr);
894      }
895    }
896    return FltNA;
897  }
898  TStrV TTable::GetEdgeFltAttrV() const {
899    TStrV FltEA = TStrV(FltCols.Len(),0);;
900    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
901      TStr Attr = EdgeAttrV[i];
902      if (GetColType(Attr) == atFlt) {
903        FltEA.Add(Attr);
904      }
905    }
906    return FltEA;
907  }
908  TStrV TTable::GetSrcNodeStrAttrV() const {
909    TStrV StrNA = TStrV(StrColMaps.Len(),0);
910    for (TInt i = 0; i &lt; SrcNodeAttrV.Len(); i++) {
911      TStr Attr = SrcNodeAttrV[i];
912      if (GetColType(Attr) == atStr) {
913        StrNA.Add(Attr);
914      }
915    }
916    return StrNA;
917  }
918  TStrV TTable::GetDstNodeStrAttrV() const {
919    TStrV StrNA = TStrV(StrColMaps.Len(),0);
920    for (TInt i = 0; i &lt; DstNodeAttrV.Len(); i++) {
921      TStr Attr = DstNodeAttrV[i];
922      if (GetColType(Attr) == atStr) {
923        StrNA.Add(Attr);
924      }
925    }
926    return StrNA;
927  }
928  TStrV TTable::GetEdgeStrAttrV() const {
929    TStrV StrEA = TStrV(StrColMaps.Len(),0);
930    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
931      TStr Attr = EdgeAttrV[i];
932      if (GetColType(Attr) == atStr) {
933        StrEA.Add(Attr);
934      }
935    }
936    return StrEA;
937  }
938  void TTable::Rename(const TStr&amp; column, const TStr&amp; NewLabel) {
939    if (!IsColName(column)) { TExcept::Throw(&quot;no such column &quot; + column); }
940    TPair&lt;TAttrType,TInt&gt; ColVal = GetColTypeMap(column);
941    DelColType(column);
942    AddColType(NewLabel, ColVal);
943    TStr NColName = NormalizeColName(column);
944    TStr NLabel = NormalizeColName(NewLabel);
945    for (TInt c = 0; c &lt; Sch.Len(); c++) {
946      if (Sch[c].Val1 == NColName) {
947        Sch.SetVal(c, TPair&lt;TStr, TAttrType&gt;(NLabel, Sch[c].Val2));
948        break;
949      }
950    }
951  }
952  void TTable::RemoveFirstRow() {
953    if (FirstValidRow == LastValidRow) {
954      LastValidRow = -1;
955    }
956    TInt Old = FirstValidRow;
957    FirstValidRow = Next[FirstValidRow];
958    Next[Old] = TTable::Invalid;
959    NumValidRows--;
960    TInt IdColIdx = GetColIdx(GetIdColName());
961    RowIdMap.AddDat(IntCols[IdColIdx][Old], Invalid);
962  }
963  void TTable::RemoveRow(TInt RowIdx, TInt PrevRowIdx) {
964    if (RowIdx == FirstValidRow) {
965      RemoveFirstRow();
966      return;
967    }
968    Assert(RowIdx != TTable::Invalid);
969    if (RowIdx == TTable::Last) { return; }
970    Next[PrevRowIdx] = Next[RowIdx];
971    if (LastValidRow == RowIdx) {
972      LastValidRow = RowIdx;
973    }
974    Next[RowIdx] = TTable::Invalid;
975    NumValidRows--;
976    TInt IdColIdx = GetColIdx(GetIdColName());
977    RowIdMap.AddDat(IntCols[IdColIdx][RowIdx], Invalid);
978  }
979  void TTable::KeepSortedRows(const TIntV&amp; KeepV) {
980    TIntIntH KeepH(KeepV.Len());
981    for (TInt i = 0; i &lt; KeepV.Len(); i++) {
982      KeepH.AddKey(KeepV[i]);
983    }
984    TRowIteratorWithRemove RowI = BegRIWR();
985    TInt KeepSize = 0;
986    while (RowI.GetNextRowIdx() != Last) {
987      if (KeepSize &lt; KeepV.Len()) {
988        if (KeepH.IsKey(RowI.GetNextRowIdx())) {
989          KeepSize++;
990          RowI++;
991        } else {
992          RowI.RemoveNext();
993        }
994      } else {
995        RowI.RemoveNext();
996      }
997    }
998    LastValidRow = KeepV[KeepV.Len()-1];
999  }
1000  void TTable::GetPartitionRanges(TIntPrV&amp; Partitions, TInt NumPartitions) const {
1001    TInt PartitionSize = NumValidRows / (NumPartitions);
1002    if (NumValidRows % NumPartitions != 0) PartitionSize++;
1003    if (PartitionSize &lt; 10) { 
1004      PartitionSize = 10;
1005      NumPartitions = NumValidRows / PartitionSize; 
1006    }
1007    Partitions.Reserve(NumPartitions+1);
1008    TInt currRow = FirstValidRow;
1009    TInt currStart = currRow;
1010    if (IsNextDirty) {
1011      TInt currCount = PartitionSize;
1012      while (currRow != TTable::Last) {
1013        if (currCount == 0) {
1014          Partitions.Add(TIntPr(currStart, currRow));
1015          currStart = currRow;
1016          currCount = PartitionSize;
1017        }
1018        currRow = Next[currRow];
1019        currCount--;
1020      }
1021      Partitions.Add(TIntPr(currStart, currRow));
1022    } else {
1023      currRow += PartitionSize;
1024      while (currRow != TTable::Last &amp;&amp; currRow &lt; Next.Len()) {
1025        if (Next[currRow] == TTable::Invalid) { currRow++; continue; }
1026        Partitions.Add(TIntPr(currStart, currRow));
1027        currStart = currRow;
1028        currRow += PartitionSize;
1029      }
1030      Partitions.Add(TIntPr(currStart, TTable::Last));
1031    }
1032  }
1033  void TTable::GroupingSanityCheck(const TStr&amp; GroupBy, const TAttrType&amp; AttrType) const {
1034    if (!IsColName(GroupBy)) {
1035      TExcept::Throw(&quot;no such column &quot; + GroupBy);
1036    }
1037    if (GetColType(GroupBy) != AttrType) {
1038      TExcept::Throw(GroupBy + &quot; values are not of expected type&quot;);
1039    }
1040  }
1041  #ifdef GCC_ATOMIC
1042  void TTable::GroupByIntColMP(const TStr&amp; GroupBy, THashMP&lt;TInt, TIntV&gt;&amp; Grouping, TBool UsePhysicalIds) const {
1043    timeval timer0;
1044    gettimeofday(&amp;timer0, NULL);
1045    TInt IdColIdx = GetColIdx(IdColName);
1046    TInt GroupByColIdx = GetColIdx(GroupBy);
1047    if(!UsePhysicalIds &amp;&amp; IdColIdx &lt; 0){
1048    	TExcept::Throw(&quot;Grouping: Either use physical row ids, or have an id column&quot;);
1049    }
1050    GroupingSanityCheck(GroupBy, atInt);
1051    TIntPrV Partitions;
1052    GetPartitionRanges(Partitions, 8*CHUNKS_PER_THREAD);
1053    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1054    Grouping.Gen(NumValidRows);
1055    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1056    for (int i = 0; i &lt; Partitions.Len(); i++){
1057      TRowIterator RowI(Partitions[i].GetVal1(), this);
1058      TRowIterator EndI(Partitions[i].GetVal2(), this);
1059      while (RowI &lt; EndI) {
1060        TInt idx = UsePhysicalIds ? RowI.GetRowIdx() : RowI.GetIntAttr(IdColIdx);
1061        UpdateGrouping&lt;TInt&gt;(Grouping, RowI.GetIntAttr(GroupByColIdx), idx);
1062        RowI++;
1063      }
1064    }
1065    gettimeofday(&amp;timer0, NULL);
1066  }
1067  #endif 
1068  void TTable::Unique(const TStr&amp; Col) {
1069    TIntV RemainingRows;
1070    TStr NCol = NormalizeColName(Col);
1071    switch (GetColType(NCol)) {
1072      case atInt: {
1073        TIntIntVH Grouping;
1074        GroupByIntCol(NCol, Grouping, TIntV(), true, true);
1075        for (TIntIntVH::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1076          RemainingRows.Add(it-&gt;Dat[0]);
1077        }
1078        break;
1079      }
1080      case atFlt: {
1081        THash&lt;TFlt,TIntV&gt; Grouping;
1082        GroupByFltCol(NCol, Grouping, TIntV(), true, true);
1083        for (THash&lt;TFlt,TIntV&gt;::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1084          RemainingRows.Add(it-&gt;Dat[0]);
1085        }
1086        break;
1087      } 
1088      case atStr: {
1089        TIntIntVH Grouping;
1090        GroupByStrCol(NCol, Grouping, TIntV(), true, true);
1091        for (TIntIntVH::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1092          RemainingRows.Add(it-&gt;Dat[0]);
1093        }
1094        break;
1095      }
1096    }
1097    KeepSortedRows(RemainingRows);
1098  }
1099  void TTable::Unique(const TStrV&amp; Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
1105    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Grouping;
1106    TIntV UniqueVec;
1107    GroupAux(NCols, Grouping, Ordered, &quot;&quot;, true, UniqueVec, true);
1108    KeepSortedRows(UniqueVec);
1109  }
1110  void TTable::StoreGroupCol(const TStr&amp; GroupColName, const TVec&lt;TPair&lt;TInt, TInt&gt; &gt;&amp; GroupAndRowIds) {
1111    IntCols.Add(TIntV(NumRows));
1112    TInt L = IntCols.Len();
1113    AddColType(GroupColName, atInt, L-1);
1114    for (TInt i = 0; i &lt; GroupAndRowIds.Len(); i++) {
1115      IntCols[L-1][GroupAndRowIds[i].Val2] = GroupAndRowIds[i].Val1;
1116    }
1117  }
1118  void TTable::GroupAux(const TStrV&amp; GroupBy, THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;&amp; Grouping, 
1119   TBool Ordered, const TStr&amp; GroupColName, TBool KeepUnique, TIntV&amp; UniqueVec, TBool UsePhysicalIds) {
1120    TInt IdColIdx = GetColIdx(IdColName);
1121    if(!UsePhysicalIds &amp;&amp; IdColIdx &lt; 0){
1122    	TExcept::Throw(&quot;Grouping: Either use physical row ids, or have an id column&quot;);
1123    }
1124    TIntV IntGroupByCols;
1125    TIntV FltGroupByCols;
1126    TIntV StrGroupByCols;
1127    for (TInt c = 0; c &lt; GroupBy.Len(); c++) {
1128      if (!IsColName(GroupBy[c])) { 
1129        TExcept::Throw(&quot;no such column &quot; + GroupBy[c]); 
1130      }
1131      TPair&lt;TAttrType, TInt&gt; ColType = GetColTypeMap(GroupBy[c]);
1132      switch (ColType.Val1) {
1133        case atInt:
1134          IntGroupByCols.Add(ColType.Val2);
1135          break;
1136        case atFlt:
1137          FltGroupByCols.Add(ColType.Val2);
1138          break;
1139        case atStr:
1140          StrGroupByCols.Add(ColType.Val2);
1141          break;
1142      }
1143    }
1144    TInt IKLen = IntGroupByCols.Len();
1145    TInt FKLen = FltGroupByCols.Len();
1146    TInt SKLen = StrGroupByCols.Len();
1147    TInt GroupNum = 0;
1148    TVec&lt;TPair&lt;TInt, TInt&gt; &gt; GroupAndRowIds;
1149    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
1150      TIntV IKey(IKLen + SKLen, 0);
1151      TFltV FKey(FKLen, 0);
1152      TIntV SKey(SKLen, 0);
1153      for (TInt c = 0; c &lt; IKLen; c++) {
1154        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
1155      }
1156      for (TInt c = 0; c &lt; FKLen; c++) {
1157        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
1158      }
1159      for (TInt c = 0; c &lt; SKLen; c++) {
1160        SKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
1161      }
1162      if (!Ordered) {
1163        if (IKLen &gt; 0) { IKey.ISort(0, IKey.Len()-1, true); }
1164        if (FKLen &gt; 0) { FKey.ISort(0, FKey.Len()-1, true); }
1165        if (SKLen &gt; 0) { SKey.ISort(0, SKey.Len()-1, true); }
1166      }
1167      for (TInt c = 0; c &lt; SKLen; c++) {
1168        IKey.Add(SKey[c]);
1169      }
1170      TGroupKey GroupKey = TGroupKey(IKey, FKey);
1171      TInt RowIdx = it.GetRowIdx();
1172      TInt idx = UsePhysicalIds ? it.GetRowIdx() : IntCols[IdColIdx][it.GetRowIdx()];
1173      if (!Grouping.IsKey(GroupKey)) {
1174        TPair&lt;TInt, TIntV&gt; NewGroup;
1175        NewGroup.Val1 = GroupNum;
1176        NewGroup.Val2.Add(idx);
1177        Grouping.AddDat(GroupKey, NewGroup);
1178        if (GroupColName != &quot;&quot;) {
1179          GroupAndRowIds.Add(TPair&lt;TInt, TInt&gt;(GroupNum, RowIdx));
1180        }
1181        if (KeepUnique) { 
1182          UniqueVec.Add(idx);
1183        }
1184        GroupNum++;
1185      } else {
1186        if (!KeepUnique) {
1187          TPair&lt;TInt, TIntV&gt;&amp; NewGroup = Grouping.GetDat(GroupKey);
1188          NewGroup.Val2.Add(idx);
1189          if (GroupColName != &quot;&quot;) {
1190            GroupAndRowIds.Add(TPair&lt;TInt, TInt&gt;(NewGroup.Val1, RowIdx));
1191          }
1192        }
1193      }
1194    }
1195    if (!KeepUnique) {
1196      GroupStmt Stmt(NormalizeColNameV(GroupBy), Ordered, UsePhysicalIds);
1197      GroupStmtNames.AddDat(GroupColName, Stmt);
1198      GroupIDMapping.AddKey(Stmt);
1199      GroupMapping.AddKey(Stmt);
1200      for (THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1201        TGroupKey key = it.GetKey();
1202        TPair&lt;TInt, TIntV&gt; group = it.GetDat();
1203        GroupIDMapping.GetDat(Stmt).AddDat(group.Val1, TGroupKey(key));
1204        GroupMapping.GetDat(Stmt).AddDat(TGroupKey(key), TIntV(group.Val2));
1205      }
1206    }
1207    if (GroupColName != &quot;&quot;) {
1208      StoreGroupCol(GroupColName, GroupAndRowIds);
1209      AddSchemaCol(GroupColName, atInt);  
1210    }
1211  }
1212  void TTable::Group(const TStrV&amp; GroupBy, const TStr&amp; GroupColName, TBool Ordered, TBool UsePhysicalIds) {
1213    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1214    TStr NGroupColName = NormalizeColName(GroupColName);
1215    TIntV UniqueVec;
1216    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Grouping;
1217    GroupAux(NGroupBy, Grouping, Ordered, NGroupColName, false, UniqueVec, UsePhysicalIds);
1218  }
1219  void TTable::InvalidatePhysicalGroupings(){
1220  }
1221  void TTable::InvalidateAffectedGroupings(const TStr&amp; Attr){
1222  }
1223  void TTable::Aggregate(const TStrV&amp; GroupByAttrs, TAttrAggr AggOp,
1224   const TStr&amp; ValAttr, const TStr&amp; ResAttr, TBool Ordered) {
1225     for (TInt c = 0; c &lt; GroupByAttrs.Len(); c++) {
1226      if (!IsColName(GroupByAttrs[c])) { 
1227        TExcept::Throw(&quot;no such column &quot; + GroupByAttrs[c]); 
1228      }
1229     }
1230    TStrV NGroupByAttrs = NormalizeColNameV(GroupByAttrs);
1231    TBool UsePhysicalIds = (GetColIdx(IdColName) &lt; 0);
1232    THash&lt;TInt,TIntV&gt; GroupByIntMapping;
1233    THash&lt;TFlt,TIntV&gt; GroupByFltMapping;
1234    THash&lt;TInt,TIntV&gt; GroupByStrMapping;
1235    THash&lt;TGroupKey,TIntV&gt; Mapping;
1236  #ifdef GCC_ATOMIC
1237    THashMP&lt;TInt,TIntV&gt; GroupByIntMapping_MP(NumValidRows);
1238    TIntV GroupByIntMPKeys(NumValidRows);
1239  #endif
1240    TInt NumOfGroups = 0;
1241    TInt GroupingCase = 0;
1242    GroupStmt Stmt(NGroupByAttrs, Ordered, UsePhysicalIds);
1243    if (GroupMapping.IsKey(Stmt)) {
1244      Mapping = GroupMapping.GetDat(Stmt);
1245    } else{
1246    	if(NGroupByAttrs.Len() == 1){
1247    		switch(GetColType(NGroupByAttrs[0])){
1248    			case atInt:
1249  #ifdef GCC_ATOMIC
1250    				if(GetMP()){
1251    					GroupByIntColMP(NGroupByAttrs[0], GroupByIntMapping_MP, UsePhysicalIds);
1252    					int x = 0;
1253  					for(THashMP&lt;TInt,TIntV&gt;::TIter it = GroupByIntMapping_MP.BegI(); it &lt; GroupByIntMapping_MP.EndI(); it++){
1254  						GroupByIntMPKeys[x] = it.GetKey();
1255  						x++;
1256  					}
1257    					NumOfGroups = x;
1258    					GroupingCase = 4;
1259    					break;
1260    				}
1261  #endif 
1262    				GroupByIntCol(NGroupByAttrs[0], GroupByIntMapping, TIntV(), true, UsePhysicalIds);
1263    				NumOfGroups = GroupByIntMapping.Len();
1264    				GroupingCase = 1;
1265    				break;
1266    			case atFlt:
1267    				GroupByFltCol(NGroupByAttrs[0], GroupByFltMapping, TIntV(), true, UsePhysicalIds);
1268    				NumOfGroups = GroupByFltMapping.Len();
1269    				GroupingCase = 2;
1270    				break;
1271    			case atStr:
1272    				GroupByStrCol(NGroupByAttrs[0], GroupByStrMapping, TIntV(), true, UsePhysicalIds);
1273    				NumOfGroups = GroupByStrMapping.Len();
1274    				GroupingCase = 3;
1275    				break;
1276    		}
1277    	}
1278    	else{
1279    		TIntV UniqueVector;
1280    		THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Mapping_aux;
1281    		GroupAux(NGroupByAttrs, Mapping_aux, Ordered, &quot;&quot;, false, UniqueVector, UsePhysicalIds);
1282    		for(THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it = Mapping_aux.BegI(); it &lt; Mapping_aux.EndI(); it++){
1283    			Mapping.AddDat(it.GetKey(), it.GetDat().Val2);
1284    		}
1285    		NumOfGroups = Mapping.Len();
1286    	}
1287    }
1288    TAttrType T = GetColType(ValAttr);
1289    if (AggOp == aaCount) { AddIntCol(ResAttr); } 
1290    else {
1291      if (T == atInt) { AddIntCol(ResAttr); }
1292      else if (T == atFlt) { AddFltCol(ResAttr); }
1293      else {
1294        TExcept::Throw(&quot;Invalid aggregation for Str type!&quot;);
1295      }
1296    }
1297    TInt ColIdx = GetColIdx(ResAttr);
1298    TInt AggrColIdx = GetColIdx(ValAttr);
1299  #ifdef USE_OPENMP
1300    #pragma omp parallel for schedule(dynamic)
1301  #endif 
1302    for (int g = 0; g &lt; NumOfGroups; g++) {
1303    	TIntV* GroupRows = NULL;
1304    	switch(GroupingCase){
1305    		case 0:
1306    			GroupRows = &amp; Mapping.GetDat(Mapping.GetKey(g));
1307    			break;
1308    		case 1:
1309    			GroupRows = &amp; GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1310    			break;
1311    		case 2:
1312    			GroupRows = &amp; GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1313    			break;
1314    	    case 3:
1315    			GroupRows = &amp; GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g));
1316    			break;
1317    		case 4:
1318  #ifdef GCC_ATOMIC
1319    			GroupRows = &amp; GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]);
1320  #endif
1321    			break;
1322    	}
1323  	TIntV&amp; ValidRows = *GroupRows;
1324      TInt sz = ValidRows.Len();
1325      if (sz &lt;= 0) continue;
1326      if (AggOp == aaCount) {
1327        for (TInt i = 0; i &lt; sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; }
1328      } else {
1329        if (T == atInt) {
1330          TIntV V;
1331          for (TInt i = 0; i &lt; sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); }
1332          TInt Res = AggregateVector&lt;TInt&gt;(V, AggOp);
1333          if (AggOp == aaMean) { Res = Res / sz; }
1334          for (TInt i = 0; i &lt; sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; }
1335        } else {
1336          TFltV V;
1337          for (TInt i = 0; i &lt; sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); }
1338          TFlt Res = AggregateVector&lt;TFlt&gt;(V, AggOp);
1339          if (AggOp == aaMean) { Res /= sz; }
1340          for (TInt i = 0; i &lt; sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; }
1341        }
1342      }
1343    }
1344  }
1345  void TTable::AggregateCols(const TStrV&amp; AggrAttrs, TAttrAggr AggOp, const TStr&amp; ResAttr) {
1346    TVec&lt;TPair&lt;TAttrType, TInt&gt; &gt;Info;
1347    for (TInt i = 0; i &lt; AggrAttrs.Len(); i++) {
1348      Info.Add(GetColTypeMap(AggrAttrs[i]));
1349      if (Info[i].Val1 != Info[0].Val1) {
1350        TExcept::Throw(&quot;AggregateCols: Aggregation attributes must have the same type&quot;);
1351      }
1352    }
1353    if (Info[0].Val1 == atInt) {
1354      AddIntCol(ResAttr);
1355      TInt ResIdx = GetColIdx(ResAttr);
1356      for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1357        TInt RowIdx = RI.GetRowIdx();
1358        TIntV V;
1359        for (TInt i = 0; i &lt; AggrAttrs.Len(); i++) {
1360          V.Add(IntCols[Info[i].Val2][RowIdx]);
1361        }
1362        IntCols[ResIdx][RowIdx] = AggregateVector&lt;TInt&gt;(V, AggOp);
1363      }
1364    } else if (Info[0].Val1 == atFlt) {
1365      AddFltCol(ResAttr);
1366      TInt ResIdx = GetColIdx(ResAttr);
1367      for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1368        TInt RowIdx = RI.GetRowIdx();
1369        TFltV V;
1370        for (TInt i = 0; i &lt; AggrAttrs.Len(); i++) {
1371          V.Add(FltCols[Info[i].Val2][RowIdx]);
1372        }
1373        FltCols[ResIdx][RowIdx] = AggregateVector&lt;TFlt&gt;(V, AggOp);
1374      }
1375    } else {
1376      TExcept::Throw(&quot;AggregateCols: Only Int and Flt aggregation supported right now&quot;);
1377    }
1378  }
1379  void TTable::PrintGrouping(const THash&lt;TGroupKey, TIntV&gt;&amp; Mapping) const{
1380  	for(THash&lt;TGroupKey, TIntV&gt;::TIter it = Mapping.BegI(); it &lt; Mapping.EndI(); it++){
1381    		TGroupKey gk = it.GetKey();
1382    		TIntV ik = gk.Val1;
1383    		TFltV fk = gk.Val2;
1384    		for(int i = 0; i &lt; ik.Len(); i++){ printf(&quot;%d &quot;,ik[i].Val);} 
1385    		for(int i = 0; i &lt; fk.Len(); i++){ printf(&quot;%f &quot;,fk[i].Val);} 
1386    		printf(&quot;--&gt;&quot;);
1387    		TIntV v = it.GetDat();
1388    		for(int i = 0; i &lt; v.Len(); i++){ printf(&quot;%d &quot;,v[i].Val);} 
1389    		printf(&quot;\n&quot;);
1390    	}
1391  }
1392  void TTable::Count(const TStr&amp; CountColName, const TStr&amp; Col) {
1393    TStrV GroupByAttrs;
1394    GroupByAttrs.Add(CountColName);
1395    Aggregate(GroupByAttrs, aaCount, &quot;&quot;, Col);
1396  }
1397  TVec&lt;PTable&gt; TTable::SpliceByGroup(const TStrV&amp; GroupBy, TBool Ordered) {
1398    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1399    TIntV UniqueVec;
1400    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;Grouping;
1401    TVec&lt;PTable&gt; Result;
1402    Schema NewSchema;
1403    for (TInt c = 0; c &lt; Sch.Len(); c++) {
1404      if (Sch[c].Val1 != GetIdColName()) {
1405        NewSchema.Add(Sch[c]);
1406      }
1407    }
1408    GroupAux(NGroupBy, Grouping, Ordered, &quot;&quot;, false, UniqueVec);
1409    TInt cnt = 0;
1410    for (THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it = Grouping.BegI(); it != Grouping.EndI(); it++) {
1411      PTable GroupTable = TTable::New(NewSchema, Context);
1412      TVec&lt;TPair&lt;TAttrType, TInt&gt; &gt; ColInfo;
1413      TIntV V;
1414      for (TInt i = 0; i &lt; Sch.Len(); i++) {
1415        ColInfo.Add(GroupTable-&gt;GetColTypeMap(Sch[i].Val1));
1416        if (Sch[i].Val1 == IdColName()) {
1417          ColInfo[i].Val2 = -1;
1418        }
1419        V.Add(GetColIdx(Sch[i].Val1));
1420      }
1421      TIntV&amp; Rows = it.GetDat().Val2;
1422      for (TInt i = 0; i &lt; Rows.Len(); i++) {
1423        TInt RowIdx = RowIdMap.GetDat(Rows[i]);
1424        for (TInt c = 0; c &lt; Sch.Len(); c++) {
1425          TPair&lt;TAttrType, TInt&gt; Info = ColInfo[c];
1426          TInt ColIdx = Info.Val2;
1427          if (ColIdx == -1) { continue; }
1428          switch (Info.Val1) {
1429            case atInt:
1430              GroupTable-&gt;IntCols[ColIdx].Add(IntCols[V[c]][RowIdx]);
1431              break;
1432            case atFlt:
1433              GroupTable-&gt;FltCols[ColIdx].Add(FltCols[V[c]][RowIdx]);
1434              break;
1435            case atStr:
1436              GroupTable-&gt;StrColMaps[ColIdx].Add(StrColMaps[V[c]][RowIdx]);
1437              break;
1438          }
1439        }
1440        if (GroupTable-&gt;LastValidRow &gt;= 0) {
1441          GroupTable-&gt;Next[GroupTable-&gt;LastValidRow] = GroupTable-&gt;NumRows;
1442        }
1443        GroupTable-&gt;Next.Add(GroupTable-&gt;Last);
1444        GroupTable-&gt;LastValidRow = GroupTable-&gt;NumRows;
1445        GroupTable-&gt;NumRows++;
1446        GroupTable-&gt;NumValidRows++;
1447      }
1448      GroupTable-&gt;InitIds();
1449      Result.Add(GroupTable);
1450      cnt += 1;
1451    }
1452    return Result;
1453  }
1454  void TTable::InitIds() {
1455    IdColName = &quot;_id&quot;;
1456    AddIdColumn(IdColName);
1457  }
1458  void TTable::Reindex() {
1459    RowIdMap.Clr();
1460    TInt IdColIdx = GetColIdx(IdColName);
1461    TInt IdCnt = 0;
1462    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1463      IntCols[IdColIdx][RI.GetRowIdx()] = IdCnt;
1464      RowIdMap.AddDat(RI.GetRowIdx(), IdCnt);
1465      IdCnt++;
1466    }
1467  }
1468  void TTable::AddIdColumn(const TStr&amp; ColName) {
1469    TInt IdCol = IntCols.Add();
1470    IntCols[IdCol].Reserve(NumRows, NumRows);
1471    TInt IdCnt = 0;
1472    RowIdMap.Clr();
1473    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1474      IntCols[IdCol][RI.GetRowIdx()] = IdCnt;
1475      RowIdMap.AddDat(IdCnt, RI.GetRowIdx());
1476      IdCnt++;
1477    }
1478    AddSchemaCol(ColName, atInt);
1479    AddColType(ColName, atInt, IntCols.Len()-1);
1480  }
1481   PTable TTable::InitializeJointTable(const TTable&amp; Table) {
1482    PTable JointTable = New(Context);
1483    JointTable-&gt;IntCols = TVec&lt;TIntV&gt;(IntCols.Len() + Table.IntCols.Len() + 1);
1484    JointTable-&gt;FltCols = TVec&lt;TFltV&gt;(FltCols.Len() + Table.FltCols.Len());
1485    JointTable-&gt;StrColMaps = TVec&lt;TIntV&gt;(StrColMaps.Len() + Table.StrColMaps.Len());
1486    for (TInt i = 0; i &lt; Sch.Len(); i++) {
1487      TStr ColName = GetSchemaColName(i);
1488      TAttrType ColType = GetSchemaColType(i);
1489      TStr CName = JointTable-&gt;RenumberColName(ColName);
1490      TPair&lt;TAttrType, TInt&gt; TypeMap = GetColTypeMap(ColName);
1491      JointTable-&gt;AddColType(CName, TypeMap);
1492      JointTable-&gt;AddSchemaCol(CName, ColType);
1493    }
1494    for (TInt i = 0; i &lt; Table.Sch.Len(); i++) {
1495      TStr ColName = Table.GetSchemaColName(i);
1496      TAttrType ColType = Table.GetSchemaColType(i);
1497      TStr CName = JointTable-&gt;RenumberColName(ColName);
1498      TPair&lt;TAttrType, TInt&gt; NewDat = Table.GetColTypeMap(ColName);
1499      Assert(ColType == NewDat.Val1);
1500      switch (NewDat.Val1) {
1501        case atInt:
1502          NewDat.Val2 += IntCols.Len();
1503          break;
1504        case atFlt:
1505          NewDat.Val2 += FltCols.Len();
1506          break;
1507        case atStr:
1508          NewDat.Val2 += StrColMaps.Len();
1509          break;
1510      }
1511      JointTable-&gt;AddColType(CName, NewDat);
1512      JointTable-&gt;AddSchemaCol(CName, ColType);
1513    }
1514    TStr IdColName = &quot;_id&quot;;
1515    JointTable-&gt;AddColType(IdColName, atInt, IntCols.Len() + Table.IntCols.Len());
1516    JointTable-&gt;AddSchemaCol(IdColName, atInt);
1517    return JointTable;
1518  }
1519  void TTable::AddJointRow(const TTable&amp; T1, const TTable&amp; T2, TInt RowIdx1, TInt RowIdx2) {
1520    for (TInt i = 0; i &lt; T1.IntCols.Len(); i++) {
1521      IntCols[i].Add(T1.IntCols[i][RowIdx1]);
1522    }
1523    for (TInt i = 0; i &lt; T1.FltCols.Len(); i++) {
1524      FltCols[i].Add(T1.FltCols[i][RowIdx1]);
1525    }
1526    for (TInt i = 0; i &lt; T1.StrColMaps.Len(); i++) {
1527      StrColMaps[i].Add(T1.StrColMaps[i][RowIdx1]);
1528    }
1529    TInt IntOffset = T1.IntCols.Len();
1530    TInt FltOffset = T1.FltCols.Len();
1531    TInt StrOffset = T1.StrColMaps.Len();
1532    for (TInt i = 0; i &lt; T2.IntCols.Len(); i++) {
1533      IntCols[i+IntOffset].Add(T2.IntCols[i][RowIdx2]);
1534    }
1535    for (TInt i = 0; i &lt; T2.FltCols.Len(); i++) {
1536      FltCols[i+FltOffset].Add(T2.FltCols[i][RowIdx2]);
1537    }
1538    for (TInt i = 0; i &lt; T2.StrColMaps.Len(); i++) {
1539      StrColMaps[i+StrOffset].Add(T2.StrColMaps[i][RowIdx2]);
1540    }
1541    TInt IdOffset = IntOffset + T2.IntCols.Len(); 
1542    NumRows++;
1543    NumValidRows++;
1544    if (!Next.Empty()) {
1545      Next[Next.Len()-1] = NumValidRows-1;
1546      LastValidRow = NumValidRows-1;
1547    }
1548    Next.Add(Last);
1549    RowIdMap.AddDat(NumRows-1,NumRows-1);
1550    IntCols[IdOffset].Add(NumRows-1);
1551  }
1552  PTable TTable::SimJoin(const TStrV&amp; Cols1, const TTable&amp; Table, const TStrV&amp; Cols2, const TStr&amp; DistanceColName, const TSimType&amp; SimType, const TFlt&amp; Threshold)
1553  {
1554  	Assert(Cols1.Len() == Cols2.Len());
1555  	if(Cols1.Len()!=Cols2.Len()){
1556  		TExcept::Throw(&quot;Column vectors must match in type and length&quot;);
1557  	}
1558  	for (TInt i = 0; i &lt; Cols1.Len(); i++) {
1559  		if(!IsColName(Cols1[i]) || !Table.IsColName(Cols2[i])){
1560  			TExcept::Throw(&quot;Column not found in Table&quot;);
1561  		}
1562  		TAttrType Type1 = GetColType(Cols1[i]);
1563  		TAttrType Type2 = GetColType(Cols2[i]);
1564  		if(Type1!=Type2){
1565  			TExcept::Throw(&quot;Column types on the two tables must match.&quot;);
1566  		}
1567  		if((Type1!=atInt &amp;&amp; Type1!=atFlt) || (Type2!=atInt &amp;&amp; Type2!=atFlt)){
1568  			TExcept::Throw(&quot;Column type not supported. Only Flt and Int column types are supported.&quot;);
1569  		}
1570    }
1571    PTable JointTable = InitializeJointTable(Table);
1572  	TFltV DistanceV;
1573  	for(TRowIterator RowI = this-&gt;BegRI(); RowI &lt; this-&gt;EndRI(); RowI++) {
1574  		for(TRowIterator RowI2 = Table.BegRI(); RowI2 &lt; Table.EndRI(); RowI2++) {
1575  			float distance = 0;
1576  			switch(SimType)
1577  			{
1578  				case L2Norm:
1579  					for(TInt i = 0; i &lt; Cols1.Len(); i++) {
1580  						float attrVal1, attrVal2;
1581  						attrVal1 = GetColType(Cols1[i])==atInt ? (float)RowI.GetIntAttr(Cols1[i]) : (float)RowI.GetFltAttr(Cols1[i]);
1582  						attrVal2 = Table.GetColType(Cols2[i])==atInt ? (float)RowI2.GetIntAttr(Cols2[i]) : (float)RowI2.GetFltAttr(Cols2[i]);
1583  						distance += pow(attrVal1 - attrVal2, 2);
1584  					}
1585  					distance = sqrt(distance);
1586  					if(distance&lt;=Threshold){
1587  						JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1588  						DistanceV.Add(distance);
1589  					}
1590  					break;
1591  				case Haversine:
1592  					{
1593  						if(Cols1.Len()!=2){
1594  							TExcept::Throw(&quot;Haversine disance expects exactly two attributes - latitude and longitude - in that order.&quot;);
1595  						}
1596  						TFlt Radius = 6373; 
1597  						float Latitude1  = GetColType(Cols1[0])==atInt ? (float)RowI.GetIntAttr(Cols1[0]) : (float)RowI.GetFltAttr(Cols1[0]);
1598  						float Latitude2 = Table.GetColType(Cols2[0])==atInt ? (float)RowI2.GetIntAttr(Cols2[0]) : (float)RowI2.GetFltAttr(Cols2[0]);
1599  						float Longitude1  = GetColType(Cols1[1])==atInt ? (float)RowI.GetIntAttr(Cols1[1]) : (float)RowI.GetFltAttr(Cols1[1]);
1600  						float Longitude2  = Table.GetColType(Cols2[1])==atInt ? (float)RowI2.GetIntAttr(Cols2[1]) : (float)RowI2.GetFltAttr(Cols2[1]);
1601  						Latitude1 *= static_cast&lt;float&gt;(M_PI/180.0);
1602  						Latitude2 *= static_cast&lt;float&gt;(M_PI/180.0);
1603  						Longitude1 *= static_cast&lt;float&gt;(M_PI/180.0);
1604  						Longitude2 *= static_cast&lt;float&gt;(M_PI/180.0);
1605  						float dlon = Longitude2 - Longitude1;
1606  						float dlat = Latitude2 - Latitude1;
1607  						float a = pow(sin(dlat/2), 2) + cos(Latitude1)*cos(Latitude2)*pow(sin(dlon/2), 2);
1608  						float c = 2*atan2(sqrt(a), sqrt(1-a));
1609  						distance = (static_cast&lt;float&gt;(Radius.Val))*c;
1610  						if(distance&lt;=Threshold){
1611  							JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1612  							DistanceV.Add(distance);
1613  						}
1614  					}
1615  					break;
1616  				case L1Norm:
1617  				case Jaccard:
1618  					TExcept::Throw(&quot;This distance metric is not supported&quot;);
1619  			}
1620  		}	
1621  	}
1622  	JointTable-&gt;StoreFltCol(DistanceColName, DistanceV);
1623  	JointTable-&gt;InitIds();
1624  	return JointTable;
1625  }
1626  PTable TTable::SelfSimJoinPerGroup(const TStr&amp; GroupAttr, const TStr&amp; SimCol, const TStr&amp; DistanceColName, const TSimType&amp; SimType, const TFlt&amp; Threshold) 
1627  {
1628  	if(!IsColName(SimCol) || !IsColName(GroupAttr)){
1629  		TExcept::Throw(&quot;No such column found in table&quot;);
1630  	}
1631    PTable JointTable = New(Context);
1632  	JointTable-&gt;IntCols = TVec&lt;TIntV&gt;(2);
1633  	JointTable-&gt;FltCols = TVec&lt;TFltV&gt;(1);
1634  	for(TInt i=0;i&lt;2;i++){
1635      TInt Suffix = i+1;
1636      TStr CName = &quot;GroupId_&quot; + Suffix.GetStr();
1637      TPair&lt;TAttrType, TInt&gt; Group(atInt, (int)i);
1638      JointTable-&gt;AddColType(CName, Group);
1639      JointTable-&gt;AddSchemaCol(CName, atInt);
1640    }
1641  	TPair&lt;TAttrType, TInt&gt; Group(atFlt, 0);
1642  	JointTable-&gt;AddColType(DistanceColName, Group);
1643  	JointTable-&gt;AddSchemaCol(DistanceColName, atFlt);
1644  	THash&lt;TInt, THash&lt;TInt, TInt&gt; &gt; TIntHH;
1645  	TAttrType attrType = GetColType(SimCol);
1646  	TInt GroupColIdx = GetColIdx(GroupAttr);
1647  	TInt SimColIdx = GetColIdx(SimCol);
1648  	for (TRowIterator RowI = this-&gt;BegRI(); RowI &lt; this-&gt;EndRI(); RowI++) {
1649  		TInt GroupId = IntCols[GroupColIdx][RowI.GetRowIdx()];
1650  		if(attrType==atInt || attrType==atStr)
1651  		{
1652  			if(!TIntHH.IsKey(GroupId)){
1653  				THash&lt;TInt, TInt&gt; TIntH;
1654  				TIntHH.AddDat(GroupId, TIntH);
1655  			}
1656  			THash&lt;TInt, TInt&gt;&amp; TIntH = TIntHH.GetDat(GroupId);
1657  			TInt SimAttrVal = (attrType==atInt ? IntCols[SimColIdx][RowI.GetRowIdx()] : StrColMaps[SimColIdx][RowI.GetRowIdx()]);
1658  			TIntH.AddDat(SimAttrVal, 0);
1659  		}
1660  		else
1661  		{
1662  			TExcept::Throw(&quot;Attribute type not supported.&quot;);
1663  		}
1664  	}
1665  	for (THash&lt;TInt, THash&lt;TInt, TInt&gt; &gt;::TIter it1 = TIntHH.BegI(); it1 &lt; TIntHH.EndI(); it1++) {
1666  		THash&lt;TInt, TInt&gt; Vals1H = it1.GetDat();
1667  		TInt GroupId1 = it1.GetKey();
1668  		for (THash&lt;TInt, THash&lt;TInt, TInt&gt; &gt;::TIter it2 = TIntHH.BegI(); it2 &lt; TIntHH.EndI(); it2++) {
1669  				int intersectionCount = 0;
1670  				TInt GroupId2 = it2.GetKey();
1671  				THash&lt;TInt, TInt&gt; Vals2H = it2.GetDat();
1672  				for(THash&lt;TInt, TInt&gt;::TIter it = Vals1H.BegI(); it &lt; Vals1H.EndI(); it++)
1673  				{
1674  					TInt Val = it.GetKey();
1675  					if(Vals2H.IsKey(Val)){
1676  						intersectionCount+=1;
1677  					}
1678  				}
1679  				int unionCount = Vals1H.Len() + Vals2H.Len() - intersectionCount;
1680  				float distance = 1.0f - (float)intersectionCount/unionCount;
1681  				if(distance&lt;=Threshold){
1682  						JointTable-&gt;IntCols[0].Add(GroupId1);
1683  						JointTable-&gt;IntCols[1].Add(GroupId2);
1684  						JointTable-&gt;FltCols[0].Add(distance);
1685  						JointTable-&gt;IncrementNext();
1686  			}
1687  		}
1688  	}
1689    JointTable-&gt;InitIds();
1690  	return JointTable;
1691  }
1692  PTable TTable::SelfSimJoinPerGroup(const TStrV&amp; GroupBy, const TStr&amp; SimCol, 
1693   const TStr&amp; DistanceColName, const TSimType&amp; SimType, const TFlt&amp; Threshold) {
1694    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1695  	TStrV ProjectionV;
1696  	for(TInt i=0; i&lt;GroupBy.Len(); i++)
1697  	{
1698  		ProjectionV.Add(GroupBy[i]);
1699  	}
1700  	ProjectionV.Add(SimCol);
1701  	ProjectInPlace(ProjectionV);
1702  	TStr CName = &quot;Group&quot;;
1703    TIntV UniqueVec;
1704    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Grouping;
1705    GroupAux(NGroupBy, Grouping, false, CName, false, UniqueVec);
1706  	PTable GroupJointTable = SelfSimJoinPerGroup(CName, SimCol, DistanceColName, SimType, Threshold);
1707  	PTable JointTable = InitializeJointTable(*this);
1708  	THash&lt;TInt, TInt&gt; GroupIdH;
1709  	for(THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it=Grouping.BegI(); it&lt;Grouping.EndI(); it++)
1710  	{
1711  		TPair&lt;TInt, TIntV&gt; group = it.GetDat();
1712  		TInt GroupNum = group.Val1;
1713  		TIntV RowIds = group.Val2;
1714  		if(!GroupIdH.IsKey(GroupNum))
1715  		{
1716  			TInt RandomRowId = RowIds[0];  
1717  			GroupIdH.AddDat(GroupNum, RandomRowId);
1718  		}
1719  	}
1720  	for(TRowIterator RowI = GroupJointTable-&gt;BegRI(); RowI &lt; GroupJointTable-&gt;EndRI(); RowI++)
1721  	{
<span onclick='openModal()' class='match'>1722  		TInt GroupId1 = GroupJointTable-&gt;IntCols[0][RowI.GetRowIdx()];
1723  		TInt GroupId2 = GroupJointTable-&gt;IntCols[1][RowI.GetRowIdx()];
</span>1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
1725  		TInt RowId2 = GroupIdH.GetDat(GroupId2);
1726  		JointTable-&gt;AddJointRow(*this, *this, RowId1, RowId2);
1727  	} 
1728  	JointTable-&gt;StoreFltCol(DistanceColName, GroupJointTable-&gt;FltCols[0]);
1729  	ProjectionV.Clr();
1730  	ProjectionV.Add(DistanceColName);
1731  	for(TInt i=0; i&lt;GroupBy.Len(); i++){
1732  		for(TInt j=0; j&lt;JointTable-&gt;Sch.Len(); j++)
1733  		{
1734  			TStr ColName = JointTable-&gt;Sch[j].Val1;
1735  			if(ColName.IsStrIn(GroupBy[i]))
1736  			{
1737  				ProjectionV.Add(ColName);
1738  			}
1739  		}
1740  	}
1741  	JointTable-&gt;ProjectInPlace(ProjectionV);
1742  	JointTable-&gt;InitIds();
1743  	return JointTable;
1744  }
1745  void TTable::IncrementNext()
1746  {
1747  	NumRows++;
1748  	NumValidRows++;
1749  	if (!Next.Empty()) {
1750  		Next[Next.Len()-1] = NumValidRows-1;
1751  		LastValidRow = NumValidRows-1;
1752  	}
1753  	Next.Add(Last);
1754  }
1755  PTable TTable::Join(const TStr&amp; Col1, const TTable&amp; Table, const TStr&amp; Col2) {
1756    if (!IsColName(Col1)) {
1757      TExcept::Throw(&quot;no such column &quot; + Col1);
1758      printf(&quot;no such column %s\n&quot;, Col1.CStr());
1759    }
1760    if (!Table.IsColName(Col2)) {
1761      TExcept::Throw(&quot;no such column &quot; + Col2);
1762      printf(&quot;no such column %s\n&quot;, Col2.CStr());
1763    }
1764    if (GetColType(Col1) != Table.GetColType(Col2)) {
1765      TExcept::Throw(&quot;Trying to Join on columns of different type&quot;);
1766      printf(&quot;Trying to Join on columns of different type\n&quot;);
1767    }
1768    PTable JointTable = InitializeJointTable(Table);
1769    TAttrType ColType = GetColType(Col1);
1770    TBool ThisIsSmaller = (NumValidRows &lt;= Table.NumValidRows);
1771    const TTable&amp; TS = ThisIsSmaller ? *this : Table;
1772    const TTable&amp; TB = ThisIsSmaller ?  Table : *this;
1773    TStr ColS = ThisIsSmaller ? Col1 : Col2;
1774    TStr ColB = ThisIsSmaller ? Col2 : Col1;
1775    TInt ColBId = ThisIsSmaller ? Table.GetColIdx(ColB) : GetColIdx(ColB);
1776  #ifdef GCC_ATOMIC
1777    if (GetMP()) {
1778      switch(ColType){
1779        case atInt:{
1780          THashMP&lt;TInt, TIntV&gt; T(TS.GetNumValidRows());
1781          TS.GroupByIntColMP(ColS, T, true);
1782          TIntPrV Partitions;
1783          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1784          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1785          TVec&lt;TIntPrV&gt; JointRowIDSet(Partitions.Len());
1786          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1787          for (int i = 0; i &lt; Partitions.Len(); i++){
1788            JointRowIDSet[i].Reserve(PartitionSize);
1789            TRowIterator RowI(Partitions[i].GetVal1(), &amp;TB);
1790            TRowIterator EndI(Partitions[i].GetVal2(), &amp;TB);
1791            while (RowI &lt; EndI) {
1792              TInt K = RowI.GetIntAttr(ColBId);
1793              if(T.IsKey(K)){
1794                TIntV&amp; Group = T.GetDat(K);
1795                for(TInt j = 0; j &lt; Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
1803              RowI++;
1804            }
1805          }
1806          JointTable-&gt;AddNJointRowsMP(*this, Table, JointRowIDSet);      
1807          break;
1808        }
1809        case atFlt:{
1810          THashMP&lt;TFlt, TIntV&gt; T(TS.GetNumValidRows());
1811          TS.GroupByFltCol(ColS, T, TIntV(), true);
1812          TIntPrV Partitions;
1813          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1814          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1815          TVec&lt;TIntPrV&gt; JointRowIDSet(Partitions.Len());
1816          #pragma omp parallel for schedule(dynamic) 
1817          for (int i = 0; i &lt; Partitions.Len(); i++){
1818            JointRowIDSet[i].Reserve(PartitionSize);
1819            TRowIterator RowI(Partitions[i].GetVal1(), &amp;TB);
1820            TRowIterator EndI(Partitions[i].GetVal2(), &amp;TB);
1821            while (RowI &lt; EndI) {
1822              TFlt K = RowI.GetFltAttr(ColBId);
1823              if(T.IsKey(K)){
1824                TIntV&amp; Group = T.GetDat(K);
1825                for(TInt j = 0; j &lt; Group.Len(); j++){
1826                  if(ThisIsSmaller){
1827                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1828                  } else{
1829                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1830                  }
1831                }
1832              }
1833              RowI++;
1834            }
1835          }
1836          JointTable-&gt;AddNJointRowsMP(*this, Table, JointRowIDSet);
1837          break;
1838        }
1839        case atStr:{
1840          THashMP&lt;TInt, TIntV&gt; T(TS.GetNumValidRows());
1841          TS.GroupByStrCol(ColS, T, TIntV(), true);
1842          TIntPrV Partitions;
1843          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1844          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1845          TVec&lt;TIntPrV&gt; JointRowIDSet(Partitions.Len());
1846          #pragma omp parallel for schedule(dynamic) 
1847          for (int i = 0; i &lt; Partitions.Len(); i++){
1848            JointRowIDSet[i].Reserve(PartitionSize);
1849            TRowIterator RowI(Partitions[i].GetVal1(), &amp;TB);
1850            TRowIterator EndI(Partitions[i].GetVal2(), &amp;TB);
1851            while (RowI &lt; EndI) {
1852              TInt K = RowI.GetStrMapById(ColBId);
1853              if(T.IsKey(K)){
1854                TIntV&amp; Group = T.GetDat(K);
1855                for(TInt j = 0; j &lt; Group.Len(); j++){
1856                  if(ThisIsSmaller){
1857                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1858                  } else{
1859                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1860                  }
1861                }
1862              }
1863              RowI++;
1864            }
1865          }
1866          JointTable-&gt;AddNJointRowsMP(*this, Table, JointRowIDSet);
1867        }
1868        break;
1869      }
1870    } else {
1871  #endif 
1872      switch (ColType) {
1873        case atInt:{
1874          TIntIntVH T;
1875          TS.GroupByIntCol(ColS, T, TIntV(), true);
1876          for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1877            TInt K = RowI.GetIntAttr(ColBId);
1878            if (T.IsKey(K)) {
1879              TIntV&amp; Group = T.GetDat(K);
1880              for (TInt i = 0; i &lt; Group.Len(); i++) {
1881                if (ThisIsSmaller) {
1882                  JointTable-&gt;AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1883                } else {
1884                  JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1885                }
1886              }
1887            }
1888          }
1889          break;
1890        }
1891        case atFlt:{
1892          THash&lt;TFlt, TIntV&gt; T;
1893          TS.GroupByFltCol(ColS, T, TIntV(), true);
1894          for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1895            TFlt K = RowI.GetFltAttr(ColBId);
1896            if (T.IsKey(K)) {
1897              TIntV&amp; Group = T.GetDat(K);
1898              for (TInt i = 0; i &lt; Group.Len(); i++) {
1899                if (ThisIsSmaller) {
1900                  JointTable-&gt;AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1901                } else {
1902                  JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1903                }
1904              }
1905            }
1906          }
1907          break;
1908        }
1909        case atStr:{
1910          TIntIntVH T;
1911          TS.GroupByStrCol(ColS, T, TIntV(), true);
1912          for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1913            TInt K = RowI.GetStrMapById(ColBId);
1914            if (T.IsKey(K)) {
1915              TIntV&amp; Group = T.GetDat(K);
1916              for (TInt i = 0; i &lt; Group.Len(); i++) {
1917                if (ThisIsSmaller) {
1918                  JointTable-&gt;AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1919                } else {
1920                  JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1921                }
1922              }
1923            }
1924          }
1925        }
1926        break;
1927      }
1928  #ifdef GCC_ATOMIC
1929    }
1930  #endif
1931    return JointTable; 
1932  }
1933  void TTable::ThresholdJoinInputCorrectness(const TStr&amp; KeyCol1, const TStr&amp; JoinCol1, const TTable&amp; Table, 
1934    const TStr&amp; KeyCol2, const TStr&amp; JoinCol2){
1935    if (!IsColName(KeyCol1)) {
1936      printf(&quot;no such column %s\n&quot;, KeyCol1.CStr());
1937      TExcept::Throw(&quot;no such column &quot; + KeyCol1);
1938    }
1939    if (!Table.IsColName(KeyCol2)) {
1940      printf(&quot;no such column %s\n&quot;, KeyCol2.CStr());
1941      TExcept::Throw(&quot;no such column &quot; + KeyCol2);
1942    }
1943    if (!IsColName(JoinCol1)) {
1944      printf(&quot;no such column %s\n&quot;, JoinCol1.CStr());
1945      TExcept::Throw(&quot;no such column &quot; + JoinCol1);
1946    }
1947    if (!Table.IsColName(JoinCol2)) {
1948      printf(&quot;no such column %s\n&quot;, JoinCol2.CStr());
1949      TExcept::Throw(&quot;no such column &quot; + JoinCol2);
1950    }
1951    if (GetColType(JoinCol1) != Table.GetColType(JoinCol2)) {
1952      printf(&quot;Trying to Join on columns of different type\n&quot;);
1953      TExcept::Throw(&quot;Trying to Join on columns of different type&quot;);
1954    }
1955    if (GetColType(KeyCol1) != Table.GetColType(KeyCol2)) {
1956      printf(&quot;Key type mismatch\n&quot;);
1957      TExcept::Throw(&quot;Key type mismatch&quot;);
1958    }
1959  }
1960  void TTable::ThresholdJoinCountCollisions(const TTable&amp; TB, const TTable&amp; TS, 
1961    const TIntIntVH&amp; T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
1962    THash&lt;TIntPr,TIntTr&gt;&amp; Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
1963      for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1964        TInt JVal = 0;
1965        if(JoinColType == atStr){
1966          JVal = RowI.GetStrMapById(JoinColIdxB);
1967        } else{
1968          JVal = RowI.GetIntAttr(JoinColIdxB);
1969        }
1970        if(T.IsKey(JVal)){
1971          TInt KeyB = 0;
1972          if(KeyType == atStr){
1973            KeyB = RowI.GetStrMapById(KeyColIdxB);
1974          } else{
1975            KeyB = RowI.GetIntAttr(KeyColIdxB);
1976          } 
1977          const TIntV&amp; RelevantRows = T.GetDat(JVal);
1978          for(int i = 0; i &lt; RelevantRows.Len(); i++){
1979            TInt KeyS = 0;
1980            if(KeyType == atStr){
1981              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
1982            } else{
1983              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
1984            }
1985            TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
1986            if(Counters.IsKey(Keys)){
1987              TIntTr&amp; V = Counters.GetDat(Keys);
1988              V.Val3 = V.Val3 + 1;
1989            } else{
1990              if(ThisIsSmaller){
1991                Counters.AddDat(Keys, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
1992              } else{
1993                Counters.AddDat(Keys, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
1994              }
1995            }
1996          }	
1997        }	
1998      } 
1999  }
2000  void TTable::ThresholdJoinCountPerJoinKeyCollisions(const TTable&amp; TB, const TTable&amp; TS, 
2001    const TIntIntVH&amp; T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
2002    THash&lt;TIntTr,TIntTr&gt;&amp; Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
2003      for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
2004        TInt JVal = 0;
2005        if(JoinColType == atStr){
2006          JVal = RowI.GetStrMapById(JoinColIdxB);
2007         } else{
2008          JVal = RowI.GetIntAttr(JoinColIdxB);
2009         }
2010        if(T.IsKey(JVal)){
2011          TInt KeyB = 0;
2012          if(KeyType == atStr){
2013            KeyB = RowI.GetStrMapById(KeyColIdxB);
2014          } else{
2015            KeyB = RowI.GetIntAttr(KeyColIdxB);
2016          } 
2017          const TIntV&amp; RelevantRows = T.GetDat(JVal);
2018          for(int i = 0; i &lt; RelevantRows.Len(); i++){
2019            TInt KeyS = 0;
2020            if(KeyType == atStr){
2021              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
2022            } else{
2023              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
2024            }
2025          	TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
2026          	TIntTr K(Keys.Val1,Keys.Val2,JVal);
2027            if(Counters.IsKey(K)){
2028              TIntTr&amp; V = Counters.GetDat(K);
2029              V.Val3 = V.Val3 + 1;
2030            } else{
2031              if(ThisIsSmaller){
2032                Counters.AddDat(K, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
2033              } else{
2034                Counters.AddDat(K, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
2035              }
2036            }
2037          }	
2038        }	
2039      } 
2040    }
2041  PTable TTable::ThresholdJoinOutputTable(const THash&lt;TIntPr,TIntTr&gt;&amp; Counters, TInt Threshold, const TTable&amp; Table){
2042    PTable JointTable = InitializeJointTable(Table);
2043    for(THash&lt;TIntPr,TIntTr&gt;::TIter iter = Counters.BegI(); iter &lt; Counters.EndI(); iter++){
2044      TIntTr&amp; Counter = iter.GetDat();
2045      if(Counter.Val3 &gt;= Threshold){
2046        JointTable-&gt;AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2047      }
2048    }
2049    return JointTable;
2050  }
2051  PTable TTable::ThresholdJoinPerJoinKeyOutputTable(const THash&lt;TIntTr,TIntTr&gt;&amp; Counters, TInt Threshold, const TTable&amp; Table){
2052    PTable JointTable = InitializeJointTable(Table);
2053    for(THash&lt;TIntTr,TIntTr&gt;::TIter iter = Counters.BegI(); iter &lt; Counters.EndI(); iter++){
2054      const TIntTr&amp; Counter = iter.GetDat();
2055      const TIntTr&amp; Keys = iter.GetKey();
2056      THashSet&lt;TIntPr&gt; Pairs;
2057      if(Counter.Val3 &gt;= Threshold){
2058        TIntPr K(Keys.Val1,Keys.Val2);
2059        if(!Pairs.IsKey(K)){
2060          Pairs.AddKey(K);
2061          JointTable-&gt;AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2062        }
2063      }
2064    }
2065    return JointTable;
2066  }
2067  PTable TTable::ThresholdJoin(const TStr&amp; KeyCol1, const TStr&amp; JoinCol1, const TTable&amp; Table, 
2068    const TStr&amp; KeyCol2, const TStr&amp; JoinCol2, TInt Threshold, TBool PerJoinKey){
2069    ThresholdJoinInputCorrectness(KeyCol1, JoinCol1, Table, KeyCol2, JoinCol2);
2070    TAttrType JoinColType = GetColType(JoinCol1);
2071    TAttrType KeyType = GetColType(KeyCol1);
2072    TBool ThisIsSmaller = (NumValidRows &lt;= Table.NumValidRows);
2073    const TTable&amp; TS = ThisIsSmaller ? *this : Table;
2074    const TTable&amp; TB = ThisIsSmaller ?  Table : *this;
2075    TStr JoinColS = JoinCol1;
2076    TInt JoinColIdxB = GetColIdx(JoinCol2);
2077    TInt KeyColIdxS = GetColIdx(KeyCol1);
2078    TInt KeyColIdxB = GetColIdx(KeyCol2);
2079    if(!ThisIsSmaller){
2080    	JoinColS = JoinCol2;
2081      JoinColIdxB = GetColIdx(JoinCol1);
2082    	KeyColIdxS = GetColIdx(KeyCol2);
2083      KeyColIdxB = GetColIdx(KeyCol1);
2084    }
2085    if(KeyType != atInt &amp;&amp; KeyType != atStr){
2086      printf(&quot;ThresholdJoin only supports integer or string key attributes\n&quot;);
2087      TExcept::Throw(&quot;ThresholdJoin only supports integer or string key attributes&quot;);
2088    }
2089    if(JoinColType != atInt &amp;&amp; JoinColType != atStr){
2090      printf(&quot;ThresholdJoin only supports integer or string join attributes\n&quot;);
2091      TExcept::Throw(&quot;ThresholdJoin only supports integer or string join attributes&quot;);
2092    }
2093    TIntIntVH T;
2094    if(JoinColType == atInt){
2095      TS.GroupByIntCol(JoinColS, T, TIntV(), true);
2096    } else if(JoinColType == atStr){
2097      TS.GroupByStrCol(JoinColS, T, TIntV(), true);
2098    } else{
2099      TExcept::Throw(&quot;ThresholdJoin only supports integer or string join attributes&quot;);
2100    } 
2101    if(PerJoinKey){
2102      THash&lt;TIntTr,TIntTr&gt; Counters;
2103      ThresholdJoinCountPerJoinKeyCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2104      return ThresholdJoinPerJoinKeyOutputTable(Counters, Threshold, Table);
2105    } else{
2106      THash&lt;TIntPr,TIntTr&gt; Counters;
2107      ThresholdJoinCountCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2108      return ThresholdJoinOutputTable(Counters, Threshold, Table);
2109    }
2110  }
2111  void TTable::Select(TPredicate&amp; Predicate, TIntV&amp; SelectedRows, TBool Remove) {
2112    TIntV Selected;
2113    TStrV RelevantCols;
2114    Predicate.GetVariables(RelevantCols);
2115    TInt NumRelevantCols = RelevantCols.Len();
2116    TVec&lt;TAttrType&gt; ColTypes = TVec&lt;TAttrType&gt;(NumRelevantCols);
2117    TIntV ColIndices = TIntV(NumRelevantCols);
2118    for (TInt i = 0; i &lt; NumRelevantCols; i++) {
2119      ColTypes[i] = GetColType(RelevantCols[i]);
2120      ColIndices[i] = GetColIdx(RelevantCols[i]);
2121    } 
2122    if (Remove) {
2123      TRowIteratorWithRemove RowI = BegRIWR();
2124      while (RowI.GetNextRowIdx() != Last) {
2125        for (TInt i = 0; i &lt; NumRelevantCols; i++) {
2126          switch (ColTypes[i]) {
2127          case atInt:
2128            Predicate.SetIntVal(RelevantCols[i], RowI.GetNextIntAttr(ColIndices[i]));
2129            break;
2130          case atFlt:
2131            Predicate.SetFltVal(RelevantCols[i], RowI.GetNextFltAttr(ColIndices[i]));
2132            break;
2133          case atStr:
2134            Predicate.SetStrVal(RelevantCols[i], RowI.GetNextStrAttr(ColIndices[i]));
2135            break;
2136          }
2137        }
2138        if (!Predicate.Eval()) { 
2139          RowI.RemoveNext();
2140        } else {
2141          RowI++;
2142        }
2143      }
2144    } else {
2145      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
2146        for (TInt i = 0; i &lt; NumRelevantCols; i++) {
2147          switch (ColTypes[i]) {
2148          case atInt:
2149            Predicate.SetIntVal(RelevantCols[i], RowI.GetIntAttr(RelevantCols[i]));
2150            break;
2151          case atFlt:
2152            Predicate.SetFltVal(RelevantCols[i], RowI.GetFltAttr(RelevantCols[i]));
2153            break;
2154          case atStr:
2155            Predicate.SetStrVal(RelevantCols[i], RowI.GetStrAttr(RelevantCols[i]));
2156            break;
2157          }
2158        }
2159        if (Predicate.Eval()) { SelectedRows.Add(RowI.GetRowIdx()); }
2160      }
2161    }
2162  }
2163  void TTable::Classify(TPredicate&amp; Predicate, const TStr&amp; LabelName, const TInt&amp; PositiveLabel, const TInt&amp; NegativeLabel) {
2164    TIntV SelectedRows;
2165    Select(Predicate, SelectedRows, false);
2166    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2167  }
2168  void TTable::SelectAtomic(const TStr&amp; Col1, const TStr&amp; Col2, TPredComp Cmp, TIntV&amp; SelectedRows, TBool Remove) {
2169    const TAttrType Ty1 = GetColType(Col1);
2170    const TAttrType Ty2 = GetColType(Col2);
2171    const TInt ColIdx1 = GetColIdx(Col1);
2172    const TInt ColIdx2 = GetColIdx(Col2);
2173    if (Ty1 != Ty2) {
2174      TExcept::Throw(&quot;SelectAtomic: diff types&quot;);
2175    }
2176    if (Cmp == SUBSTR || Cmp == SUPERSTR) { Assert(Ty1 == atStr); }
2177    if (Remove) {
2178      TRowIteratorWithRemove RowI = BegRIWR();
2179      while (RowI.GetNextRowIdx() != Last) {
2180        TBool Result;
2181        switch (Ty1) {
2182          case atInt:
2183            Result = TPredicate::EvalAtom(RowI.GetNextIntAttr(ColIdx1), RowI.GetNextIntAttr(ColIdx2), Cmp);
2184            break;
2185          case atFlt:
2186            Result = TPredicate::EvalAtom(RowI.GetNextFltAttr(ColIdx1), RowI.GetNextFltAttr(ColIdx2), Cmp);
2187            break;
2188          case atStr:
2189            Result = TPredicate::EvalStrAtom(RowI.GetNextStrAttr(ColIdx1), RowI.GetNextStrAttr(ColIdx2), Cmp);
2190            break;
2191        }
2192        if (!Result) { 
2193          RowI.RemoveNext();
2194        } else {
2195          RowI++;
2196        }
2197      }
2198    } else {
2199      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
2200        TBool Result;
2201        switch (Ty1) {
2202          case atInt:
2203            Result = TPredicate::EvalAtom(RowI.GetIntAttr(Col1), RowI.GetIntAttr(Col2), Cmp);
2204            break;
2205          case atFlt:
2206            Result = TPredicate::EvalAtom(RowI.GetFltAttr(Col1), RowI.GetFltAttr(Col2), Cmp);
2207            break;
2208          case atStr:
2209            Result = TPredicate::EvalStrAtom(RowI.GetStrAttr(Col1), RowI.GetStrAttr(Col2), Cmp);
2210            break;
2211        }
2212        if (Result) { SelectedRows.Add(RowI.GetRowIdx()); }
2213      }
2214    }
2215  }
2216  void TTable::ClassifyAtomic(const TStr&amp; Col1, const TStr&amp; Col2, TPredComp Cmp,
2217    const TStr&amp; LabelName, const TInt&amp; PositiveLabel, const TInt&amp; NegativeLabel) {
2218    TIntV SelectedRows;
2219    SelectAtomic(Col1, Col2, Cmp, SelectedRows, false);
2220    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2221  }
2222  void TTable::SelectAtomicConst(const TStr&amp; Col, const TPrimitive&amp; Val, TPredComp Cmp, 
2223    TIntV&amp; SelectedRows, PTable&amp; SelectedTable, TBool Remove, TBool Table) {
2224    TStr ValTStr(Val.GetStr());
2225    TAttrType Type = GetColType(Col);
2226    TInt ColIdx = GetColIdx(Col);
2227    if (Type != Val.GetType()) { 
2228      TExcept::Throw(&quot;SelectAtomicConst: coltype does not match const type&quot;); 
2229    }
2230    if(Remove){
2231  #ifdef USE_OPENMP
2232      if (GetMP()) {
2233        TIntPrV Partitions;
2234        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2235        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2236        int RemoveCount = 0;
2237        TIntPrV Bounds(Partitions.Len());
2238        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:RemoveCount)
2239        for (int i = 0; i &lt; Partitions.Len(); i++){
2240          TRowIterator RowI(Partitions[i].GetVal1(), this);
2241          TRowIterator EndI(Partitions[i].GetVal2(), this);
2242          TInt FirstRowIdx = TTable::Invalid;
2243          TInt LastRowIdx = TTable::Invalid;
2244          TBool First = true;
2245          while (RowI &lt; EndI) {
2246            TInt CurrRowIdx = RowI.GetRowIdx();
2247            TBool Result;
2248            if (Type != atStr) {
2249              Result = RowI.CompareAtomicConst(ColIdx, Val, Cmp);
2250            } else {
2251              Result = RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp);
2252            }
2253            RowI++;
2254            if(!Result) {
2255              Next[CurrRowIdx] = TTable::Invalid;
2256              RemoveCount++;
2257            } else { 
2258              if (First) { FirstRowIdx = CurrRowIdx; First = false; } 
2259              else { Next[LastRowIdx] = CurrRowIdx; }
2260              LastRowIdx = CurrRowIdx; 
2261            }
2262          }
2263          Bounds[i] = TIntPr(FirstRowIdx, LastRowIdx);
2264        }
2265        TInt CurrBound = 0;
2266        while (CurrBound &lt; Bounds.Len() &amp;&amp; Bounds[CurrBound].Val1 == TTable::Invalid) {
2267          CurrBound++;
2268        }
2269        if (CurrBound == Bounds.Len()) {
2270          Assert(NumValidRows == RemoveCount);
2271          NumValidRows = 0;
2272          FirstValidRow = TTable::Invalid;
2273          LastValidRow = TTable::Invalid;
2274        } else {
2275          NumValidRows -= RemoveCount;
2276          FirstValidRow = Bounds[CurrBound].Val1;
2277          LastValidRow = Bounds[CurrBound].Val2;
2278          TInt PrevBound = CurrBound;
2279          CurrBound++;
2280          while (CurrBound &lt; Bounds.Len()) {
2281            if (Bounds[CurrBound].Val1 == TTable::Invalid) { CurrBound++; continue; }
2282            Next[Bounds[PrevBound].Val2] = Bounds[CurrBound].Val1;
2283            LastValidRow = Bounds[CurrBound].Val2;
2284            PrevBound = CurrBound;
2285            CurrBound++;
2286          }
2287          Next[Bounds[PrevBound].Val2] = TTable::Last;
2288        }
2289        IsNextDirty = 1;
2290      } else {
2291  #endif
2292        TRowIteratorWithRemove RowI = BegRIWR();
2293        while(RowI.GetNextRowIdx() != Last){
2294          if (!RowI.CompareAtomicConst(ColIdx, Val, Cmp)) {
2295            RowI.RemoveNext();
2296          } else {
2297            RowI++;
2298          }
2299        }
2300        IsNextDirty = 1;
2301  #ifdef USE_OPENMP
2302      }
2303  #endif
2304    } else if (Table) {
2305  #ifdef USE_OPENMP
2306      if (GetMP()) {
2307        TIntPrV Partitions;
2308        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2309        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2310        int TotalSelectedRows = 0;
2311        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:TotalSelectedRows)
2312        for (int i = 0; i &lt; Partitions.Len(); i++){
2313          TRowIterator RowI(Partitions[i].GetVal1(), this);
2314          TRowIterator EndI(Partitions[i].GetVal2(), this);
2315          while (RowI &lt; EndI) {
2316            if (Type != atStr) {
2317              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2318                TotalSelectedRows++;
2319              }
2320            } else {
2321              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2322                TotalSelectedRows++;
2323              }
2324            }
2325            RowI++;
2326          }
2327        }
2328        SelectedTable-&gt;ResizeTable(TotalSelectedRows);
2329        if (TotalSelectedRows == 0) {
2330          return;
2331        }
2332        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
2333        for (int i = 0; i &lt; Partitions.Len(); i++){
2334          TIntV LocalSelectedRows;
2335          LocalSelectedRows.Reserve(PartitionSize);
2336          TRowIterator RowI(Partitions[i].GetVal1(), this);
2337          TRowIterator EndI(Partitions[i].GetVal2(), this);
2338          while (RowI &lt; EndI) {
2339            if (Type != atStr) {
2340              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2341                LocalSelectedRows.Add(RowI.GetRowIdx());
2342              }
2343            } else {
2344              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2345                LocalSelectedRows.Add(RowI.GetRowIdx());
2346              }
2347            }
2348            RowI++;
2349          }
2350          SelectedTable-&gt;AddSelectedRows(*this, LocalSelectedRows);
2351        }
2352        SelectedTable-&gt;SetFirstValidRow();
2353      } else {
2354  #endif
2355        for(TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++){
2356          if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2357            SelectedTable-&gt;AddRowI(RowI);
2358          }
2359        }
2360  #ifdef USE_OPENMP
2361      }
2362  #endif
2363    } else {
2364      for(TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++){
2365        if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2366          SelectedRows.Add(RowI.GetRowIdx());
2367        }
2368      }
2369    }
2370  }
2371  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TAttrType&amp; CompareByType, const TInt&amp; CompareByIndex, TBool Asc) {
2372    switch (CompareByType) {
2373      case atInt:{
2374        if (IntCols[CompareByIndex][R1] &gt; IntCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2375        if (IntCols[CompareByIndex][R1] &lt; IntCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2376        return 0;
2377      }
2378      case atFlt:{
2379        if (FltCols[CompareByIndex][R1] &gt; FltCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2380        if (FltCols[CompareByIndex][R1] &lt; FltCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2381        return 0;
2382      }
2383      case atStr:{
2384        TStr S1 = GetStrValIdx(CompareByIndex, R1);
2385        TStr S2 = GetStrValIdx(CompareByIndex, R2);
2386        int CmpRes = strcmp(S1.CStr(), S2.CStr());
2387        return (Asc ? CmpRes : -CmpRes);
2388      }
2389    }
2390    return 0;
2391  }
2392  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TVec&lt;TAttrType&gt;&amp; CompareByTypes, const TIntV&amp; CompareByIndices, TBool Asc) {
2393    for (TInt i = 0; i &lt; CompareByTypes.Len(); i++) {
2394      TInt res = CompareRows(R1, R2, CompareByTypes[i], CompareByIndices[i], Asc);
2395      if (res != 0) { return res; }
2396    }
2397    return 0;
2398  }
2399  void TTable::ISort(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2400    if (StartIdx &lt; EndIdx) {
2401      for (TInt i = StartIdx+1; i &lt;= EndIdx; i++) {
2402        TInt Val = V[i];
2403        TInt j = i;
2404        while ((StartIdx &lt; j) &amp;&amp; (CompareRows(V[j-1], Val, SortByTypes, SortByIndices, Asc) &gt; 0)) {
2405          V[j] = V[j-1];
2406          j--;
2407        }
2408        V[j] = Val;
2409      }
2410    }
2411  }
2412  TInt TTable::GetPivot(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2413    TInt L = EndIdx - StartIdx + 1;
2414    const TInt Idx1 = StartIdx + TInt::GetRnd(L);
2415    const TInt Idx2 = StartIdx + TInt::GetRnd(L);
2416    const TInt Idx3 = StartIdx + TInt::GetRnd(L);
2417    if (CompareRows(V[Idx1], V[Idx2], SortByTypes, SortByIndices, Asc) &lt; 0) {
2418      if (CompareRows(V[Idx2], V[Idx3], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx2; }
2419      if (CompareRows(V[Idx1], V[Idx3], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx3; }
2420      return Idx1;
2421    } else {
2422      if (CompareRows(V[Idx3], V[Idx2], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx2; }
2423      if (CompareRows(V[Idx3], V[Idx1], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx3; }
2424      return Idx1;
2425    }
2426  }
2427  TInt TTable::Partition(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2428    TInt j;
2429    for (j = StartIdx; j &lt; EndIdx; j++) {
2430      if (CompareRows(V[j], V[j+1], SortByTypes, SortByIndices, Asc) &gt; 0) {
2431        break;
2432      }
2433    }
2434    if (j &gt;= EndIdx) {
2435      return EndIdx+1;
2436    }
2437    TInt PivotIdx = GetPivot(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2438    TInt Pivot = V[PivotIdx];
2439    V.Swap(PivotIdx, EndIdx);
2440    TInt StoreIdx = StartIdx;
2441    for (TInt i = StartIdx; i &lt; EndIdx; i++) {
2442      if (CompareRows(V[i], Pivot, SortByTypes, SortByIndices, Asc) &lt;= 0) {
2443        V.Swap(i, StoreIdx);
2444        StoreIdx++;
2445      }
2446    }
2447    V.Swap(StoreIdx, EndIdx);
2448    return StoreIdx;
2449  }
2450  void TTable::QSort(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2451    if (StartIdx &lt; EndIdx) {
2452      if (EndIdx - StartIdx &lt; 20) {
2453        ISort(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2454      } else {
2455        TInt Pivot = Partition(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2456        if (Pivot &gt; EndIdx) {
2457          return;
2458        }
2459        int Ub = Pivot - 1;
2460        while (Ub &gt;= StartIdx &amp;&amp; CompareRows(
2461          V[Ub], V[Pivot], SortByTypes, SortByIndices, Asc) == 0) {
2462          Ub -= 1;
2463        }
2464        QSort(V, StartIdx, Ub, SortByTypes, SortByIndices, Asc);
2465        QSort(V, Pivot+1, EndIdx, SortByTypes, SortByIndices, Asc);
2466      }
2467    }
2468  }
2469  void TTable::Merge(TIntV&amp; V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2470    TInt i = Idx1, j = Idx2;
2471    TIntV SortedV;
2472    while  (i &lt; Idx2 &amp;&amp; j &lt; Idx3) {
2473      if (CompareRows(V[i], V[j], SortByTypes, SortByIndices, Asc) &lt;= 0) {
2474        SortedV.Add(V[i]);
2475        i++;
2476      }
2477      else {
2478        SortedV.Add(V[j]);
2479        j++;
2480      }
2481    }
2482    while (i &lt; Idx2) {
2483      SortedV.Add(V[i]);
2484      i++;
2485    }
2486    while (j &lt; Idx3) {
2487      SortedV.Add(V[j]);
2488      j++;
2489    }
2490    for (TInt sz = 0; sz &lt; Idx3 - Idx1; sz++) {
2491      V[Idx1 + sz] = SortedV[sz];
2492    }
2493  }
2494  #ifdef USE_OPENMP
2495  void TTable::QSortPar(TIntV&amp; V, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2496    TInt NumThreads = 8; 
2497    TInt Sz = V.Len();
2498    TIntV IndV, NextV;
2499    for (TInt i = 0; i &lt; NumThreads; i++) {
2500      IndV.Add(i * (Sz / NumThreads));
2501    }
2502    IndV.Add(Sz);
2503    omp_set_num_threads(NumThreads);
2504    #pragma omp parallel for
2505    for (int i = 0; i &lt; NumThreads; i++) {
2506      QSort(V, IndV[i], IndV[i+1] - 1, SortByTypes, SortByIndices, Asc);
2507    }
2508    while (NumThreads &gt; 1) {
2509      omp_set_num_threads(NumThreads / 2);
2510      #pragma omp parallel for
2511      for (int i = 0; i &lt; NumThreads; i += 2) {
2512        Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc);
2513      }
2514      NextV.Clr();
2515      for (TInt i = 0; i &lt; NumThreads; i+=2) {
2516        NextV.Add(IndV[i]);
2517      }
2518      NextV.Add(Sz);
2519      IndV = NextV;
2520      NumThreads = NumThreads / 2;
2521    }
2522  }
2523  #endif 
2524  void TTable::Order(const TStrV&amp; OrderBy, TStr OrderColName, TBool ResetRankByMSC, TBool Asc) {
2525    TIntV ValidRows = TIntV(NumValidRows);
2526    if (NumRows == NumValidRows) {
2527      for (TInt i = 0; i &lt; NumValidRows; i++) {
2528        ValidRows[i] = i;
2529      }
2530    } else {
2531      TInt i = 0;
2532      for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
2533        ValidRows[i] = RI.GetRowIdx();
2534        i++;
2535      }
2536    }
2537    TVec&lt;TAttrType&gt; OrderByTypes(OrderBy.Len());
2538    TIntV OrderByIndices(OrderBy.Len());
2539    for (TInt i = 0; i &lt; OrderBy.Len(); i++) {
2540      OrderByTypes[i] = GetColType(OrderBy[i]);
2541      OrderByIndices[i] = GetColIdx(OrderBy[i]);
2542    }
2543  #ifdef USE_OPENMP
2544    if (GetMP()) {
2545      QSortPar(ValidRows, OrderByTypes, OrderByIndices, Asc);
2546    } else {
2547  #endif
2548      QSort(ValidRows, 0, NumValidRows-1, OrderByTypes, OrderByIndices, Asc);
2549  #ifdef USE_OPENMP
2550    }
2551  #endif
2552    IsNextDirty = 1;
2553    if (NumValidRows &gt; 0) {
2554      FirstValidRow = ValidRows[0];
2555    } else {
2556      FirstValidRow = Last;
2557    }
2558    for (TInt i = 0; i &lt; NumValidRows-1; i++) {
2559      Next[ValidRows[i]] = ValidRows[i+1];
2560    }
2561    if (NumValidRows &gt; 0) {
2562      Next[ValidRows[NumValidRows-1]] = Last;
2563      LastValidRow = ValidRows[NumValidRows-1];
2564    } else {
2565      LastValidRow = Last;
2566    }
2567    if (!OrderColName.Empty()) {
2568      TIntV RankCol = TIntV(NumRows);
2569      for (TInt i = 0; i &lt; NumValidRows; i++) {
2570        RankCol[ValidRows[i]] = i;
2571      }
2572      if (ResetRankByMSC) {
2573        for (TInt i = 1; i &lt; NumValidRows; i++) {
2574          TStr GroupName = OrderBy[0];
2575          if (GetStrVal(GroupName, ValidRows[i]) != GetStrVal(GroupName, ValidRows[i-1])) { 
2576            RankCol[ValidRows[i]] = 0;
2577          } else {
2578            RankCol[ValidRows[i]] = RankCol[ValidRows[i-1]] + 1;
2579          }
2580        }
2581      }
2582      IntCols.Add(RankCol);
2583      AddSchemaCol(OrderColName, atInt);
2584      AddColType(OrderColName, atInt, IntCols.Len()-1);
2585    }
2586  }
2587  void TTable::Defrag() {
2588    TInt FreeIndex = 0;
2589    TIntV Mapping;  
2590    TInt IdColIdx = GetColIdx(IdColName);
2591    for (TInt i = 0; i &lt; Next.Len(); i++) {
2592      if (Next[i] != TTable::Invalid) {  
2593        if (FreeIndex == 0) {
2594          Assert (i == FirstValidRow);
2595          FirstValidRow = 0;
2596        }
2597        if (Next[i] != Last) { 
2598          Next[FreeIndex] = FreeIndex + 1;
2599          Mapping.Add(FreeIndex);
2600        } else {
2601          Next[FreeIndex] = Last;
2602          LastValidRow = FreeIndex;
2603          Mapping.Add(Last);
2604        }
2605        RowIdMap.AddDat(IntCols[IdColIdx][i], FreeIndex);
2606        for (TInt j = 0; j &lt; IntCols.Len(); j++) {
2607          IntCols[j][FreeIndex] = IntCols[j][i];
2608        }
2609        for (TInt j = 0; j &lt; FltCols.Len(); j++) {
2610          FltCols[j][FreeIndex] = FltCols[j][i];
2611        }
2612        for (TInt j = 0; j &lt; StrColMaps.Len(); j++) {
2613          StrColMaps[j][FreeIndex] = StrColMaps[j][i];
2614        }
2615        FreeIndex++;
2616      } else {
2617        NumRows--;
2618        Mapping.Add(TTable::Invalid);
2619      }
2620    }
2621    Assert (NumValidRows == NumRows);
2622  }
2623  void TTable::SelectFirstNRows(const TInt&amp; N) {
2624    if (N == 0) {
2625      LastValidRow = -1;
2626      return;
2627    }
2628    TRowIterator RowI = BegRI();
2629    TInt count = 1;
2630    while (count &lt; N) {
2631      if (!(RowI &lt; EndRI())) {
2632        return; 
2633      }
2634      RowI++;
2635      count++;
2636    }
2637    NumValidRows = N;
2638    TInt LastId = RowI.GetRowIdx();
2639    if (Next[LastId] == Last) {
2640      return; 
2641    }
2642    TInt CurrId = LastId;
2643    while (Next[CurrId] != Last) {
2644      Assert(Next[CurrId] != Invalid);
2645      TInt NextId = Next[CurrId];
2646      Next[CurrId] = Invalid;
2647      CurrId = NextId;
2648    }
2649    Next[LastId] = Last;
2650    LastValidRow = LastId;
2651  }
2652  inline void TTable::CheckAndAddIntNode(PNEANet Graph, THashSet&lt;TInt&gt;&amp; NodeVals, TInt NodeId) {
2653    if (!NodeVals.IsKey(NodeId)) {
2654      Graph-&gt;AddNode(NodeId);
2655      NodeVals.AddKey(NodeId);
2656    }
2657  }
2658  inline void TTable::AddEdgeAttributes(PNEANet&amp; Graph, int RowId) {
2659    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
2660      TStr ColName = EdgeAttrV[i];
2661      TAttrType T = GetColType(ColName);
2662      TInt Index = GetColIdx(ColName);
2663      switch (T) {
2664        case atInt:
2665          Graph-&gt;AddIntAttrDatE(RowId, IntCols[Index][RowId], ColName);
2666          break;
2667        case atFlt:
2668          Graph-&gt;AddFltAttrDatE(RowId, FltCols[Index][RowId], ColName);
2669          break;
2670        case atStr:
2671          Graph-&gt;AddStrAttrDatE(RowId, GetStrValIdx(Index, RowId), ColName);
2672          break;
2673      }
2674    }
2675  }
2676  inline void TTable::AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId, THash&lt;TInt, TStrIntVH&gt;&amp; NodeIntAttrs,
2677    THash&lt;TInt, TStrFltVH&gt;&amp; NodeFltAttrs, THash&lt;TInt, TStrStrVH&gt;&amp; NodeStrAttrs) {
2678    for (TInt i = 0; i &lt; NodeAttrV.Len(); i++) {
2679      TStr ColAttr = NodeAttrV[i];
2680      TAttrType CT = GetColType(ColAttr);
2681      int ColId = GetColIdx(ColAttr);
2682      for (TInt i = 0; i &lt; CommonNodeAttrs.Len(); i++) {
2683        if (CommonNodeAttrs[i].Val1 == ColAttr || CommonNodeAttrs[i].Val2 == ColAttr) {
2684          ColAttr = CommonNodeAttrs[i].Val3;
2685          break;
2686        }
2687      }
2688      if (CT == atInt) {
2689        if (!NodeIntAttrs.IsKey(NId)) { NodeIntAttrs.AddKey(NId); }
2690        if (!NodeIntAttrs.GetDat(NId).IsKey(ColAttr)) { NodeIntAttrs.GetDat(NId).AddKey(ColAttr); }
2691        NodeIntAttrs.GetDat(NId).GetDat(ColAttr).Add(IntCols[ColId][RowId]);
2692      } else if (CT == atFlt) {
2693        if (!NodeFltAttrs.IsKey(NId)) { NodeFltAttrs.AddKey(NId); }
2694        if (!NodeFltAttrs.GetDat(NId).IsKey(ColAttr)) { NodeFltAttrs.GetDat(NId).AddKey(ColAttr); }
2695        NodeFltAttrs.GetDat(NId).GetDat(ColAttr).Add(FltCols[ColId][RowId]);
2696      } else {
2697        if (!NodeStrAttrs.IsKey(NId)) { NodeStrAttrs.AddKey(NId); }
2698        if (!NodeStrAttrs.GetDat(NId).IsKey(ColAttr)) { NodeStrAttrs.GetDat(NId).AddKey(ColAttr); }
2699        NodeStrAttrs.GetDat(NId).GetDat(ColAttr).Add(GetStrValIdx(ColId, RowId));
2700      }
2701    }
2702  }
2703  PNEANet TTable::BuildGraph(const TIntV&amp; RowIds, TAttrAggr AggrPolicy) {
2704    PNEANet Graph = TNEANet::New();
2705    const TAttrType NodeType = GetColType(SrcCol);
2706    Assert(NodeType == GetColType(DstCol));
2707    const TInt SrcColIdx = GetColIdx(SrcCol);
2708    const TInt DstColIdx = GetColIdx(DstCol);
2709    THash&lt;TFlt, TInt&gt; FltNodeVals;
2710    THash&lt;TInt, TStrIntVH&gt; NodeIntAttrs;
2711    THash&lt;TInt, TStrFltVH&gt; NodeFltAttrs;
2712    THash&lt;TInt, TStrStrVH&gt; NodeStrAttrs;
2713    for (TVec&lt;TInt&gt;::TIter it = RowIds.BegI(); it &lt; RowIds.EndI(); it++) {
2714      TInt CurrRowIdx = *it;
2715      TInt SVal, DVal;
2716      if (NodeType == atFlt) {
2717        TFlt FSVal = FltCols[SrcColIdx][CurrRowIdx];
2718        SVal = CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
2719        TFlt FDVal = FltCols[SrcColIdx][CurrRowIdx];
2720        DVal = CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
2721      } else if (NodeType == atInt || NodeType == atStr) {
2722        if (NodeType == atInt) {
2723          SVal = IntCols[SrcColIdx][CurrRowIdx];
2724          DVal = IntCols[DstColIdx][CurrRowIdx];
2725        } else {
2726          SVal = StrColMaps[SrcColIdx][CurrRowIdx];
2727          if (strlen(Context-&gt;StringVals.GetKey(SVal)) == 0) { continue; }  
2728          DVal = StrColMaps[DstColIdx][CurrRowIdx];
2729          if (strlen(Context-&gt;StringVals.GetKey(DVal)) == 0) { continue; }  
2730        }
2731        if (!Graph-&gt;IsNode(SVal)) { Graph-&gt;AddNode(SVal); }
2732        if (!Graph-&gt;IsNode(DVal)) { Graph-&gt;AddNode(DVal); }
2733      } 
2734      Graph-&gt;AddEdge(SVal, DVal, CurrRowIdx);
2735      if (EdgeAttrV.Len() &gt; 0) { AddEdgeAttributes(Graph, CurrRowIdx); }
2736      if (SrcNodeAttrV.Len() &gt; 0) { 
2737        AddNodeAttributes(SVal, SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2738      }
2739      if (DstNodeAttrV.Len() &gt; 0) {
2740        AddNodeAttributes(DVal, DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2741      }
2742    }
2743    if (SrcNodeAttrV.Len() &gt; 0 || DstNodeAttrV.Len() &gt; 0) {
2744      for (TNEANet::TNodeI NodeI = Graph-&gt;BegNI(); NodeI &lt; Graph-&gt;EndNI(); NodeI++) {
2745        TInt NId = NodeI.GetId();
2746        if (NodeIntAttrs.IsKey(NId)) {
2747          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
2748          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it &lt; IntAttrVals.EndI(); it++) {
2749            TInt AttrVal = AggregateVector&lt;TInt&gt;(it.GetDat(), AggrPolicy);
2750            Graph-&gt;AddIntAttrDatN(NId, AttrVal, it.GetKey());
2751          }
2752        }
2753        if (NodeFltAttrs.IsKey(NId)) {
2754          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
2755          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it &lt; FltAttrVals.EndI(); it++) {
2756            TFlt AttrVal = AggregateVector&lt;TFlt&gt;(it.GetDat(), AggrPolicy);
2757            Graph-&gt;AddFltAttrDatN(NId, AttrVal, it.GetKey());
2758          }
2759        }
2760        if (NodeStrAttrs.IsKey(NId)) {
2761          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
2762          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it &lt; StrAttrVals.EndI(); it++) {
2763            TStr AttrVal = AggregateVector&lt;TStr&gt;(it.GetDat(), AggrPolicy);
2764            Graph-&gt;AddStrAttrDatN(NId, AttrVal, it.GetKey());
2765          }
2766        }
2767      }
2768    }
2769    return Graph;
2770  }
2771  void TTable::InitRowIdBuckets(int NumBuckets) {
2772    for (TInt i = 0; i &lt; RowIdBuckets.Len(); i++) {
2773      RowIdBuckets[i].Clr();
2774    }
2775    RowIdBuckets.Clr();
2776    RowIdBuckets.Gen(NumBuckets);
2777    for (TInt i = 0; i &lt; NumBuckets; i++) {
2778      RowIdBuckets[i].Gen(10, 0);
2779    }
2780  }
2781  void TTable::FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize, TInt StartVal, TInt EndVal) {
2782    Assert (JumpSize &lt;= WindowSize);
2783    int NumBuckets, MinBucket, MaxBucket;
2784    TInt SplitColId = GetColIdx(SplitAttr);
2785    if (StartVal == TInt::Mn || EndVal == TInt::Mx) {
2786      TInt MinValue = TInt::Mx;
2787      TInt MaxValue = TInt::Mn;
2788      for (TInt i = 0; i &lt; Next.Len(); i++) {
2789        if (Next[i] != Invalid) { 
2790          if (MinValue &gt; IntCols[SplitColId][i]) {
2791            MinValue = IntCols[SplitColId][i];
2792          }
2793          if (MaxValue &lt; IntCols[SplitColId][i]) {
2794            MaxValue = IntCols[SplitColId][i];
2795          }
2796        }
2797      }
2798      if (StartVal == TInt::Mn) StartVal = MinValue;
2799      if (EndVal == TInt::Mx) EndVal = MaxValue;
2800    }
2801    NumBuckets = 1;
2802    if (JumpSize &gt; 0) {
2803      NumBuckets = (EndVal - StartVal)/JumpSize + 1;
2804    }
2805    InitRowIdBuckets(NumBuckets);
2806    for (TInt i = 0; i &lt; Next.Len(); i++) {
2807      if (Next[i] == Invalid) { continue; }
2808      int SplitVal = IntCols[SplitColId][i];
2809      if (SplitVal &lt; StartVal || SplitVal &gt; EndVal) { continue; }
2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
2817        if (RowVal &lt; WindowSize) { MinBucket = 0; }
2818        else { MinBucket = (RowVal-WindowSize)/JumpSize + 1; }
2819        MaxBucket = RowVal/JumpSize;  
2820      }
2821      for (TInt j = MinBucket; j &lt;= MaxBucket; j++) { RowIdBuckets[j].Add(i); }
2822    }
2823  }
2824  void TTable::FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals) {
2825    TInt SplitColId = GetColIdx(SplitAttr);
2826    int NumBuckets = SplitIntervals.Len();
2827    InitRowIdBuckets(NumBuckets);
2828    for (TInt i = 0; i &lt; Next.Len(); i++) {
2829      if (Next[i] == Invalid) { continue; }
2830      int SplitVal = IntCols[SplitColId][i];
2831      for (TInt j = 0; j &lt; SplitIntervals.Len(); j++) { 
2832        if (SplitVal &gt;= SplitIntervals[j].Val1 &amp;&amp; SplitVal &lt; SplitIntervals[j].Val2) {
2833          RowIdBuckets[j].Add(i);
2834        }
2835      }
2836    }
2837  }
2838  TVec&lt;PNEANet&gt; TTable::GetGraphsFromSequence(TAttrAggr AggrPolicy) {
2839    TVec&lt;PNEANet&gt; GraphSequence;
2840    for (TInt i = 0; i &lt; RowIdBuckets.Len(); i++) {
2841      if (RowIdBuckets[i].Len() == 0) { continue; }
2842      PNEANet PNet = BuildGraph(RowIdBuckets[i], AggrPolicy);
2843      GraphSequence.Add(PNet);
2844    }
2845    return GraphSequence;
2846  }
2847  PNEANet TTable::GetFirstGraphFromSequence(TAttrAggr AggrPolicy) {
2848    CurrBucket = -1;
2849    this-&gt;AggrPolicy = AggrPolicy;
2850    return GetNextGraphFromSequence();
2851  }
2852  PNEANet TTable::GetNextGraphFromSequence() {
2853    CurrBucket++;
2854    while (CurrBucket &lt; RowIdBuckets.Len() &amp;&amp; RowIdBuckets[CurrBucket].Len() == 0) {
2855      CurrBucket++;
2856    }
2857    if (CurrBucket &gt;= RowIdBuckets.Len()) { return NULL; }
2858    return BuildGraph(RowIdBuckets[CurrBucket], AggrPolicy);
2859  }
2860  TVec&lt;PNEANet&gt; TTable::ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2861    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2862    printf(&quot;buckets filled\n&quot;);
2863    return GetGraphsFromSequence(AggrPolicy);  
2864  }
2865  TVec&lt;PNEANet&gt; TTable::ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2866    FillBucketsByInterval(SplitAttr, SplitIntervals);
2867    return GetGraphsFromSequence(AggrPolicy);
2868  }
2869  TVec&lt;PNEANet&gt; TTable::ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy) {
2870    return ToGraphSequence(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2871  }
2872  PNEANet TTable::ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2873    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2874    return GetFirstGraphFromSequence(AggrPolicy);  
2875  }
2876  PNEANet TTable::ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2877    FillBucketsByInterval(SplitAttr, SplitIntervals);
2878    return GetFirstGraphFromSequence(AggrPolicy);
2879  }
2880  PNEANet TTable::ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy) {
2881    return ToGraphSequenceIterator(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2882  }
2883  PNEANet TTable::NextGraphIterator() {
2884    return GetNextGraphFromSequence();
2885  }
2886  TBool TTable::IsLastGraphOfSequence() {
2887    return CurrBucket &gt;= RowIdBuckets.Len() - 1;
2888  }
2889  PTable TTable::GetNodeTable(const PNEANet&amp; Network, TTableContext* Context) {
2890    Schema SR;
2891    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;node_id&quot;,atInt));
2892    TStrV IntAttrNames;
2893    TStrV FltAttrNames;
2894    TStrV StrAttrNames;
2895    TNEANet::TNodeI NodeI = Network-&gt;BegNI();
2896    NodeI.GetIntAttrNames(IntAttrNames);
2897    NodeI.GetFltAttrNames(FltAttrNames);
2898    NodeI.GetStrAttrNames(StrAttrNames);
2899    for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2900      SR.Add(TPair&lt;TStr,TAttrType&gt;(IntAttrNames[i],atInt));
2901    }
2902    for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2903      SR.Add(TPair&lt;TStr,TAttrType&gt;(FltAttrNames[i],atFlt));
2904    }
2905    for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2906      SR.Add(TPair&lt;TStr,TAttrType&gt;(StrAttrNames[i],atStr));
2907    }
2908    PTable T = New(SR, Context);
2909    TInt Cnt = 0;
2910    while (NodeI &lt; Network-&gt;EndNI()) {
2911      T-&gt;IntCols[0].Add(NodeI.GetId());
2912      for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2913        T-&gt;IntCols[i+1].Add(Network-&gt;GetIntAttrDatN(NodeI,IntAttrNames[i]));
2914      }
2915      for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2916        T-&gt;FltCols[i].Add(Network-&gt;GetFltAttrDatN(NodeI,FltAttrNames[i]));
2917      }
2918      for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2919        T-&gt;AddStrVal(i, Network-&gt;GetStrAttrDatN(NodeI,StrAttrNames[i]));
2920      }
2921      Cnt++;
2922      NodeI++;
2923    }
2924    T-&gt;NumRows = Cnt;
2925    T-&gt;NumValidRows = T-&gt;NumRows;
2926    T-&gt;Next = TIntV(T-&gt;NumRows,0);
2927    for (TInt i = 0; i &lt; T-&gt;NumRows-1; i++) {
2928      T-&gt;Next.Add(i+1);
2929    }
2930    T-&gt;LastValidRow = T-&gt;NumRows-1;
2931    T-&gt;Next.Add(Last);
2932    return T;
2933  }
2934  PTable TTable::GetEdgeTable(const PNEANet&amp; Network, TTableContext* Context) {
2935    Schema SR;
2936    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;edg_id&quot;,atInt));
2937    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;src_id&quot;,atInt));
2938    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;dst_id&quot;,atInt));
2939    TStrV IntAttrNames;
2940    TStrV FltAttrNames;
2941    TStrV StrAttrNames;
2942    TNEANet::TEdgeI EdgeI = Network-&gt;BegEI();
2943    EdgeI.GetIntAttrNames(IntAttrNames);
2944    EdgeI.GetFltAttrNames(FltAttrNames);
2945    EdgeI.GetStrAttrNames(StrAttrNames);
2946    for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2947      SR.Add(TPair&lt;TStr,TAttrType&gt;(IntAttrNames[i],atInt));
2948    }
2949    for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2950      SR.Add(TPair&lt;TStr,TAttrType&gt;(FltAttrNames[i],atFlt));
2951    }
2952    for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2953      SR.Add(TPair&lt;TStr,TAttrType&gt;(StrAttrNames[i],atStr));
2954    }
2955    PTable T = New(SR, Context);
2956    TInt Cnt = 0;
2957    while (EdgeI &lt; Network-&gt;EndEI()) {
2958      T-&gt;IntCols[0].Add(EdgeI.GetId());
2959      T-&gt;IntCols[1].Add(EdgeI.GetSrcNId());
2960      T-&gt;IntCols[2].Add(EdgeI.GetDstNId());
2961      for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2962        T-&gt;IntCols[i+3].Add(Network-&gt;GetIntAttrDatE(EdgeI,IntAttrNames[i]));
2963      }
2964      for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2965        T-&gt;FltCols[i].Add(Network-&gt;GetFltAttrDatE(EdgeI,FltAttrNames[i]));
2966      }
2967      for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2968        T-&gt;AddStrVal(i, Network-&gt;GetStrAttrDatE(EdgeI,StrAttrNames[i]));
2969      }
2970      Cnt++;
2971      EdgeI++;
2972    }
2973    T-&gt;NumRows = Cnt;
2974    T-&gt;NumValidRows = T-&gt;NumRows;
2975    T-&gt;Next = TIntV(T-&gt;NumRows,0);
2976    for (TInt i = 0; i &lt; T-&gt;NumRows-1; i++) {
2977      T-&gt;Next.Add(i+1);
2978    }
2979    T-&gt;LastValidRow = T-&gt;NumRows-1;
2980    T-&gt;Next.Add(Last);
2981    return T;
2982  }
2983  #ifdef GCC_ATOMIC
2984  PTable TTable::GetEdgeTablePN(const PNGraphMP&amp; Network, TTableContext* Context){
2985    Schema SR;
2986    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;src_id&quot;,atInt));
2987    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;dst_id&quot;,atInt));
2988    TNGraphMP::TEdgeI FirstEI = Network-&gt;BegEI();
2989    PTable T = New(SR, Context);
2990    TInt NumEdges = Network-&gt;GetEdges();
2991    TInt NumPartitions = omp_get_max_threads()*CHUNKS_PER_THREAD;
2992    TInt PartitionSize = NumEdges/NumPartitions;
2993    if (PartitionSize*NumPartitions &lt; NumEdges) { NumPartitions++;}
2994    typedef TPair&lt;TNGraphMP::TEdgeI, TNGraphMP::TEdgeI&gt; TEIPr;
2995    TVec&lt;TEIPr&gt; Partitions;
2996    TIntV PartitionSizes;
2997    TNGraphMP::TEdgeI currStart = FirstEI;
2998    TInt currCount = 0;
2999    while (FirstEI &lt; Network-&gt;EndEI()){
3000      if (currCount == PartitionSize) {
3001        Partitions.Add(TEIPr(currStart, FirstEI));
3002        currStart = FirstEI;
3003        PartitionSizes.Add(currCount);
3004        currCount = 0;
3005      }
3006      FirstEI++;
3007      currCount++;
3008    }
3009    Partitions.Add(TEIPr(currStart, FirstEI));
3010    PartitionSizes.Add(currCount);
3011    T-&gt;ResizeTable(NumEdges);
3012    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3013    for (int p = 0; p &lt; Partitions.Len(); p++) {
3014      TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();
3015      TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();
3016      int start = T-&gt;GetEmptyRowsStart(PartitionSizes[p]);
3017      while (EdgeI &lt; EndI) {
3018        T-&gt;IntCols[0][start] = EdgeI.GetSrcNId();
3019        T-&gt;IntCols[1][start] = EdgeI.GetDstNId();
3020        EdgeI++;
3021        if (EdgeI &lt; EndI) { T-&gt;Next[start] = start+1;}
3022        start++;
3023      }
3024    }
3025    Assert(T-&gt;NumRows == NumEdges);
3026    return T;
3027  }
3028  #endif 
3029  PTable TTable::GetFltNodePropertyTable(const PNEANet&amp; Network, const TIntFltH&amp; Property, 
3030   const TStr&amp; NodeAttrName, const TAttrType&amp; NodeAttrType, const TStr&amp; PropertyAttrName, 
3031   TTableContext* Context) {
3032    Schema SR;
3033    SR.Add(TPair&lt;TStr,TAttrType&gt;(NodeAttrName,NodeAttrType));
3034    SR.Add(TPair&lt;TStr,TAttrType&gt;(PropertyAttrName,atFlt));
3035    PTable T = New(SR, Context);
3036    TInt NodeColIdx = T-&gt;GetColIdx(NodeAttrName);
3037    TInt Cnt = 0;
3038    for (TNEANet::TNodeI NodeI = Network-&gt;BegNI(); NodeI &lt; Network-&gt;EndNI(); NodeI++) {
3039      switch (NodeAttrType) {
3040        case atInt:
3041          T-&gt;IntCols[NodeColIdx].Add(Network-&gt;GetIntAttrDatN(NodeI,NodeAttrName));
3042          break;
3043        case atFlt:
3044          T-&gt;FltCols[NodeColIdx].Add(Network-&gt;GetFltAttrDatN(NodeI,NodeAttrName));
3045          break;
3046        case atStr:
3047          T-&gt;AddStrVal(TInt(0), Network-&gt;GetStrAttrDatN(NodeI,NodeAttrName));
3048          break;
3049      }
3050      T-&gt;FltCols[0].Add(Property.GetDat(NodeI.GetId()));
3051      Cnt++;
3052    }
3053    T-&gt;NumRows = Cnt;
3054    T-&gt;NumValidRows = T-&gt;NumRows;
3055    T-&gt;Next = TIntV(T-&gt;NumRows,0);
3056    for (TInt i = 0; i &lt; T-&gt;NumRows-1; i++) {
3057      T-&gt;Next.Add(i+1);
3058    }
3059    T-&gt;LastValidRow = T-&gt;NumRows-1;
3060    T-&gt;Next.Add(Last);
3061    return T;
3062  }
3063  PTable TTable::IsNextK(const TStr&amp; OrderCol, TInt K, const TStr&amp; GroupBy, const TStr&amp; RankColName) {
3064    TStrV OrderBy;
3065    if (GroupBy.Empty()) {
3066      OrderBy.Add(OrderCol);
3067    } else {
3068      OrderBy.Add(GroupBy);
3069      OrderBy.Add(OrderCol);
3070    }
3071    if (RankColName.Empty()) {
3072      Order(OrderBy);
3073    } else {
3074      Order(OrderBy, RankColName, true);
3075    }
3076    TAttrType GroupByAttrType = GetColType(GroupBy);
3077    PTable T = InitializeJointTable(*this);
3078    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3079      TInt Succ = RI.GetRowIdx();
3080      TBool OutOfGroup = false;
3081      for (TInt i = 0; i &lt; K; i++) {
3082        Succ = Next[Succ];
3083        if (Succ == Last) { break; }
3084        switch (GroupByAttrType) {
3085          case atInt:
3086            if (GetIntVal(GroupBy, Succ) != RI.GetIntAttr(GroupBy)) { OutOfGroup = true; }
3087            break;
3088          case atFlt:
3089            if (GetFltVal(GroupBy, Succ) != RI.GetFltAttr(GroupBy)) { OutOfGroup = true; }
3090            break;
3091          case atStr:
3092            if (GetStrVal(GroupBy, Succ) != RI.GetStrAttr(GroupBy)) { OutOfGroup = true; }
3093            break;
3094        }
3095        if (OutOfGroup) { break; }  
3096        T-&gt;AddJointRow(*this, *this, RI.GetRowIdx(), Succ);
3097      }
3098    }
3099    return T;
3100  }
3101  void TTable::PrintSize(){
3102  	printf(&quot;Total number of rows: %d\n&quot;, NumRows.Val);
3103  	printf(&quot;Number of valid rows: %d\n&quot;, NumValidRows.Val);
3104  	printf(&quot;Number of Int columns: %d\n&quot;, IntCols.Len());
3105  	printf(&quot;Number of Flt columns: %d\n&quot;, FltCols.Len());
3106  	printf(&quot;Number of Str columns: %d\n&quot;, StrColMaps.Len());
3107  	TSize MemUsed = GetMemUsedKB();
3108  	printf(&quot;Approximate table size is %s KB\n&quot;, TUInt64::GetStr(MemUsed).CStr());
3109  }
3110  TSize TTable::GetMemUsedKB() {
3111    TSize ApproxSize = 0;
3112    ApproxSize += Next.GetMemUsed()/1000;  
3113    for(int i = 0; i &lt; IntCols.Len(); i++){
3114    	ApproxSize += IntCols[i].GetMemUsed()/1000;
3115    }
3116    for(int i = 0; i &lt; FltCols.Len(); i++){
3117    	ApproxSize += FltCols[i].GetMemUsed()/1000;
3118    }
3119    for(int i = 0; i &lt; StrColMaps.Len(); i++){
3120    	ApproxSize += StrColMaps[i].GetMemUsed()/1000;
3121    }
3122    ApproxSize += RowIdMap.GetMemUsed()/1000;
3123    ApproxSize += GroupIDMapping.GetMemUsed()/1000;
3124    ApproxSize += GroupMapping.GetMemUsed()/1000;
3125    ApproxSize += RowIdBuckets.GetMemUsed() / 1000;
3126    return ApproxSize;
3127  }
3128  void TTable::PrintContextSize(){
3129  	printf(&quot;Number of strings in pool: &quot;);
3130  	printf(&quot;%d\n&quot;, Context-&gt;StringVals.Len());
3131  	printf(&quot;Number of entries in hash table: &quot;);
3132  	printf(&quot;%d\n&quot;, Context-&gt;StringVals.Reserved());
3133  	TSize MemUsed = GetContextMemUsedKB();
3134  	printf(&quot;Approximate context size is %s KB\n&quot;,
3135            TUInt64::GetStr(MemUsed).CStr());
3136  }
3137  TSize TTable::GetContextMemUsedKB(){
3138  	TSize ApproxSize = 0;
3139  	ApproxSize += Context-&gt;StringVals.GetMemUsed();
3140  	return ApproxSize;
3141  }
3142  void TTable::AddTable(const TTable&amp; T) {
3143    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3144      TStr ColName = GetSchemaColName(c);
3145      TInt ColIdx = GetColIdx(ColName);
3146      TInt TColIdx = ColName == IdColName ? T.GetColIdx(T.IdColName) : T.GetColIdx(ColName);
3147      if (TColIdx &lt; 0) { TExcept::Throw(&quot;when adding a table, it must contain all columns of source table!&quot;); }
3148      switch (GetColType(ColName)) { 
3149      case atInt:
3150         IntCols[ColIdx].AddV(T.IntCols[TColIdx]);
3151         break;
3152      case atFlt:
3153         FltCols[ColIdx].AddV(T.FltCols[TColIdx]);
3154         break;
3155      case atStr:
3156         StrColMaps[ColIdx].AddV(T.StrColMaps[TColIdx]);
3157         break;
3158      }
3159    }
3160    TIntV TNext(T.Next);
3161    for (TInt i = 0; i &lt; TNext.Len(); i++) {
3162      if (TNext[i] != Last &amp;&amp; TNext[i] != Invalid) { TNext[i] += NumRows; }
3163    }
3164    Next.AddV(TNext);
3165    if (LastValidRow &gt;= 0) {
3166      Next[LastValidRow] = NumRows + T.FirstValidRow;
3167    }
3168    LastValidRow = NumRows + T.LastValidRow;
3169    NumRows += T.NumRows;
3170    NumValidRows += T.NumValidRows;
3171  }
3172  void TTable::GetCollidingRows(const TTable&amp; Table, THashSet&lt;TInt&gt;&amp; Collisions) {
3173    TIntV UniqueVec;
3174    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;Grouping;
3175    TStrV GroupBy;
3176    TIntV IntGroupByCols;
3177    TIntV FltGroupByCols;
3178    TIntV StrGroupByCols;
3179    TInt IKLen, FKLen, SKLen;
3180    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3181      if (Sch[c].Val1 == IdColName) {
3182        if (Table.Sch[c].Val1 != Table.GetIdColName()) {
3183          TExcept::Throw(&quot;GetCollidingRows: schemas do not match!&quot;);
3184        }
3185        continue;
3186      }
3187      if (Sch[c] != Table.Sch[c]) {
3188        printf(&quot;(%s,%d) != (%s,%d)\n&quot;, Sch[c].Val1.CStr(), Sch[c].Val2, Table.Sch[c].Val1.CStr(), Table.Sch[c].Val2); 
3189        TExcept::Throw(&quot;GetCollidingRows: schemas do not match!&quot;);
3190      }
3191      GroupBy.Add(NormalizeColName(Sch[c].Val1));
3192      TPair&lt;TAttrType, TInt&gt; ColType = Table.GetColTypeMap(Sch[c].Val1);
3193      switch (ColType.Val1) {
3194        case atInt:
3195          IntGroupByCols.Add(ColType.Val2);
3196          break;
3197        case atFlt:
3198          FltGroupByCols.Add(ColType.Val2);
3199          break;
3200        case atStr:
3201          StrGroupByCols.Add(ColType.Val2);
3202          break;
3203      }
3204    }
3205    IKLen = IntGroupByCols.Len();
3206    FKLen = FltGroupByCols.Len();
3207    SKLen = StrGroupByCols.Len();
3208    GroupAux(GroupBy, Grouping, true, &quot;&quot;, false, UniqueVec, true);
3209    for (TRowIterator it = Table.BegRI(); it &lt; Table.EndRI(); it++) {
3210      TIntV IKey(IKLen + SKLen, 0);
3211      TFltV FKey(FKLen, 0);
3212      for (TInt c = 0; c &lt; IKLen; c++) {
3213        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
3214      }
3215      for (TInt c = 0; c &lt; FKLen; c++) {
3216        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
3217      }
3218      for (TInt c = 0; c &lt; SKLen; c++) {
3219        IKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
3220      }
3221      TGroupKey GroupKey = TGroupKey(IKey, FKey);
3222      TInt RowIdx = it.GetRowIdx();
3223      if (Grouping.IsKey(GroupKey)) {
3224        Collisions.AddKey(RowIdx);
3225      }
3226    }
3227  }
3228  void TTable::StoreIntCol(const TStr&amp; ColName, const TIntV&amp; ColVals) {
3229    if (ColVals.Len() != NumRows) {
3230      printf(&quot;new column dimension must agree with number of rows\n&quot;);
3231      return;
3232    }
3233    AddSchemaCol(ColName, atInt);
3234    IntCols.Add(TIntV(NumRows));
3235    TInt ColIdx = IntCols.Len()-1;
3236    TInt i = 0;
3237    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3238      IntCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3239      i++;
3240    }
3241    TInt L = IntCols.Len();
3242    AddColType(ColName, atInt, L-1);
3243  }
3244  void TTable::StoreFltCol(const TStr&amp; ColName, const TFltV&amp; ColVals) {
3245    if (ColVals.Len() != NumRows) {
3246      printf(&quot;new column dimension must agree with number of rows\n&quot;);
3247      return;
3248    }
3249    AddSchemaCol(ColName, atFlt);
3250    FltCols.Add(TFltV(NumRows));
3251    TInt ColIdx = FltCols.Len()-1;
3252    TInt i = 0;
3253    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3254      FltCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3255      i++;
3256    }
3257    TInt L = FltCols.Len();
3258    AddColType(ColName, atFlt, L-1);
3259  }
3260  void TTable::StoreStrCol(const TStr&amp; ColName, const TStrV&amp; ColVals) {
3261    if (ColVals.Len() != NumRows) {
3262      printf(&quot;new column dimension must agree with number of rows\n&quot;);
3263      return;
3264    }
3265    AddSchemaCol(ColName, atStr);
3266    StrColMaps.Add(TIntV(NumRows,0));
3267    TInt ColIdx = FltCols.Len()-1;
3268    TInt i = 0;
3269    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3270      TInt Key = Context-&gt;StringVals.GetKeyId(ColVals[i]);
3271      if (Key == -1) { Context-&gt;StringVals.AddKey(ColVals[i]); }
3272      StrColMaps[ColIdx][RI.GetRowIdx()] = Key;
3273      i++;
3274    }
3275    TInt L = StrColMaps.Len();
3276    AddColType(ColName, atStr, L-1);
3277  }
3278  void TTable::UpdateTableForNewRow() {
3279    if (LastValidRow &gt;= 0) {
3280      Next[LastValidRow] = NumRows;
3281    }
3282    Next.Add(Last);
3283    LastValidRow = NumRows;
3284    NumRows++;
3285    NumValidRows++;
3286  }
3287  #ifdef GCC_ATOMIC
3288  void TTable::SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal){
3289      if(!GetMP()){ TExcept::Throw(&quot;Not Using MP!&quot;);}
3290  	TIntPrV Partitions;
3291  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3292  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3293  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3294  	for (int i = 0; i &lt; Partitions.Len(); i++){
3295  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3296  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3297  		while(RowI &lt; EndI){
3298  			FltCols[UpdateColIdx][RowI.GetRowIdx()] = DefaultFltVal;
3299  			RowI++;
3300  		}
3301  	}
3302  }
3303  int sync_bool_compare_and_swap(int *lock) {
3304    return(__sync_bool_compare_and_swap(lock, 0, 1));
3305  }
3306  void TTable::UpdateFltFromTableMP(const TStr&amp; KeyAttr, const TStr&amp; UpdateAttr,
3307      const TTable&amp; Table, const TStr&amp; FKeyAttr, const TStr&amp; ReadAttr,
3308      TFlt DefaultFltVal) {
3309  	if (!GetMP()) {
3310      TExcept::Throw(&quot;Not Using MP!&quot;);
3311    }
3312    TAttrType KeyType = GetColType(KeyAttr);
3313    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3314    if(KeyType != FKeyType){TExcept::Throw(&quot;Key Type Mismatch&quot;);}
3315    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3316      TExcept::Throw(&quot;Expecting Float values&quot;);
3317    }
3318    TStr NKeyAttr = NormalizeColName(KeyAttr);
3319    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3320    TInt FKeyColIdx = GetColIdx(FKeyAttr);
3321    TInt ReadColIdx = GetColIdx(ReadAttr);
3322    SetFltColToConstMP(UpdateColIdx, DefaultFltVal);
3323  	TIntPrV Partitions;
3324  	Table.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3325  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3326  	TIntV Locks(NumRows);
3327  	Locks.PutAll(0);	
3328    switch (KeyType) {
3329      case atInt: {
3330          THashMP&lt;TInt,TIntV&gt; Grouping;
3331          GroupByIntColMP(NKeyAttr, Grouping, true);
3332          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3333  			  for (int i = 0; i &lt; Partitions.Len(); i++) {
3334  				  TRowIterator RowI(Partitions[i].GetVal1(), &amp;Table);
3335  				  TRowIterator EndI(Partitions[i].GetVal2(), &amp;Table);
3336  				  while (RowI &lt; EndI) {
3337              TInt K = RowI.GetIntAttr(FKeyColIdx);
3338              if (Grouping.IsKey(K)) {
3339                TIntV&amp; UpdateRows = Grouping.GetDat(K);
3340                for (int j = 0; j &lt; UpdateRows.Len(); j++) {
3341                  int* lock = &amp;Locks[UpdateRows[j]].Val;
3342                  if (!sync_bool_compare_and_swap(lock)) {
3343                    continue;
3344                  }
3345    							  FltCols[UpdateColIdx][UpdateRows[j]] = RowI.GetFltAttr(ReadColIdx);
3346                } 
3347              } 
3348              RowI++;
3349            } 
3350          }	
3351        } 
3352        break;
3353      default:
3354        break;
3355    } 
3356  }
3357  #endif	
3358  void TTable::UpdateFltFromTable(const TStr&amp; KeyAttr, const TStr&amp; UpdateAttr, const TTable&amp; Table, 
3359    const TStr&amp; FKeyAttr, const TStr&amp; ReadAttr, TFlt DefaultFltVal){
3360    if(!IsColName(KeyAttr)){ TExcept::Throw(&quot;Bad KeyAttr parameter&quot;);}
3361    if(!IsColName(UpdateAttr)){ TExcept::Throw(&quot;Bad UpdateAttr parameter&quot;);}
3362    if(!Table.IsColName(FKeyAttr)){ TExcept::Throw(&quot;Bad FKeyAttr parameter&quot;);}
3363    if(!Table.IsColName(ReadAttr)){ TExcept::Throw(&quot;Bad ReadAttr parameter&quot;);}
3364  #ifdef GCC_ATOMIC
3365    if(GetMP()){
3366      UpdateFltFromTableMP(KeyAttr, UpdateAttr,Table, FKeyAttr, ReadAttr, DefaultFltVal);
3367      return;
3368    }
3369  #endif	
3370    TAttrType KeyType = GetColType(KeyAttr);
3371    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3372    if(KeyType != FKeyType){TExcept::Throw(&quot;Key Type Mismatch&quot;);}
3373    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3374      TExcept::Throw(&quot;Expecting Float values&quot;);
3375    }
3376    TStr NKeyAttr = NormalizeColName(KeyAttr);
3377    TStr NUpdateAttr = NormalizeColName(UpdateAttr);
3378    TStr NFKeyAttr = Table.NormalizeColName(FKeyAttr);
3379    TStr NReadAttr = Table.NormalizeColName(ReadAttr);
3380    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3381    for(TRowIterator iter = BegRI(); iter &lt; EndRI(); iter++){
3382      FltCols[UpdateColIdx][iter.GetRowIdx()] = DefaultFltVal;
3383    }
3384    switch(KeyType) {
3385      case atInt: {
3386          TIntIntVH Grouping;
3387          GroupByIntCol(NKeyAttr, Grouping, TIntV(), true, true);
3388          for (TRowIterator RI = Table.BegRI(); RI &lt; Table.EndRI(); RI++) {
3389            TInt K = RI.GetIntAttr(NFKeyAttr);
3390            if (Grouping.IsKey(K)) {
3391              TIntV&amp; UpdateRows = Grouping.GetDat(K);
3392              for (int i = 0; i &lt; UpdateRows.Len(); i++) {
3393                FltCols[UpdateColIdx][UpdateRows[i]] = RI.GetFltAttr(NReadAttr);
3394              } 
3395            } 
3396          } 
3397        } 
3398        break;
3399      default:
3400        break;
3401    } 
3402  }
3403  void TTable::AddRowI(const TRowIterator&amp; RI) {
3404    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3405      TStr ColName = GetSchemaColName(c);
3406      if (ColName == IdColName) { continue; }
3407      TInt ColIdx = GetColIdx(ColName);
3408      switch (GetColType(ColName)) {
3409      case atInt:
3410         IntCols[ColIdx].Add(RI.GetIntAttr(ColName));
3411         break;
3412      case atFlt:
3413         FltCols[ColIdx].Add(RI.GetFltAttr(ColName));
3414         break;
3415      case atStr:
3416         StrColMaps[ColIdx].Add(RI.GetStrMapByName(ColName));
3417         break;
3418      }
3419    }
3420    UpdateTableForNewRow();
3421  }
3422  void TTable::AddRowV(const TIntV&amp; IntVals, const TFltV&amp; FltVals, const TStrV&amp; StrVals) {
3423    for (TInt c = 0; c &lt; IntVals.Len(); c++) {
3424      IntCols[c].Add(IntVals[c]);
3425    }
3426    for (TInt c = 0; c &lt; FltVals.Len(); c++) {
3427      FltCols[c].Add(FltVals[c]);
3428    }
3429    for (TInt c = 0; c &lt; StrVals.Len(); c++) {
3430      AddStrVal(c, StrVals[c]);
3431    }
3432    UpdateTableForNewRow();
3433  }
3434  void TTable::ResizeTable(int RowCount) {
3435    if (RowCount == 0) {
3436      NumValidRows = 0;
3437      FirstValidRow = TTable::Invalid;
3438      LastValidRow = TTable::Invalid;
3439    }
3440    if (Next.Len() &lt; RowCount) {
3441      TInt FltOffset = IntCols.Len();
3442      TInt StrOffset = FltOffset + FltCols.Len();
3443      TInt TotalCols = StrOffset + StrColMaps.Len();
3444  #ifdef USE_OPENMP
3445      #pragma omp parallel for schedule(static)
3446  #endif
3447      for (int i = 0; i &lt; TotalCols+1; i++) {
3448        if (i &lt; FltOffset) {
3449          IntCols[i].Reserve(RowCount, RowCount); 
3450        } else if (i &lt; StrOffset) {
3451          FltCols[i-FltOffset].Reserve(RowCount, RowCount);
3452        } else if (i &lt; TotalCols) {
3453          StrColMaps[i-StrOffset].Reserve(RowCount, RowCount);  
3454        } else {
3455          Next.Reserve(RowCount, RowCount);    
3456        }
3457      }
3458    } else if (Next.Len() &gt; RowCount) {
3459      TInt FltOffset = IntCols.Len();
3460      TInt StrOffset = FltOffset + FltCols.Len();
3461      TInt TotalCols = StrOffset + StrColMaps.Len();
3462  #ifdef USE_OPENMP
3463      #pragma omp parallel for schedule(static)
3464  #endif
3465      for (int i = 0; i &lt; TotalCols+1; i++) {
3466        if (i &lt; FltOffset) {
3467          IntCols[i].Trunc(RowCount); 
3468        } else if (i &lt; StrOffset) {
3469          FltCols[i-FltOffset].Trunc(RowCount); 
3470        } else if (i &lt; TotalCols) {
3471          StrColMaps[i-StrOffset].Trunc(RowCount); 
3472        } else {
3473          Next.Trunc(RowCount); 
3474        }
3475      }
3476    }
3477  }
3478  int TTable::GetEmptyRowsStart(int NewRows) {
3479    int start = -1;
3480  #ifdef USE_OPENMP
3481    #pragma omp critical
3482    {
3483  #endif
3484      start = NumRows;
3485      NumRows += NewRows;
3486      NumValidRows += NewRows;
3487      Assert(NumRows &lt;= Next.Len());
3488      if (LastValidRow &gt;= 0) {Next[LastValidRow] = start;}
3489      LastValidRow = start+NewRows-1;
3490      Next[LastValidRow] = Last;
3491  #ifdef USE_OPENMP
3492    }
3493  #endif
3494    Assert (start &gt;= 0);
3495    return start;
3496  }
3497  void TTable::AddSelectedRows(const TTable&amp; Table, const TIntV&amp; RowIDs) {
3498    int NewRows = RowIDs.Len();
3499    if (NewRows == 0) { return; }
3500    int start = GetEmptyRowsStart(NewRows);
3501    for (TInt r = 0; r &lt; NewRows; r++) {
3502      TInt CurrRowIdx = RowIDs[r];
3503      for (TInt i = 0; i &lt; Table.IntCols.Len(); i++) {
3504        IntCols[i][start+r] = Table.IntCols[i][CurrRowIdx];
3505      }
3506      for (TInt i = 0; i &lt; Table.FltCols.Len(); i++) {
3507        FltCols[i][start+r] = Table.FltCols[i][CurrRowIdx];
3508      }
3509      for (TInt i = 0; i &lt; Table.StrColMaps.Len(); i++) {
3510        StrColMaps[i][start+r] = Table.StrColMaps[i][CurrRowIdx];
3511      }
3512    }
3513    for (TInt r = 0; r &lt; NewRows-1; r++) {
3514      Next[start+r] = start+r+1;
3515    }
3516  }  
3517  void TTable::AddNRows(int NewRows, const TVec&lt;TIntV&gt;&amp; IntColsP, const TVec&lt;TFltV&gt;&amp; FltColsP, const TVec&lt;TIntV&gt;&amp; StrColMapsP) {
3518    if (NewRows == 0) { return; }
3519    int start = GetEmptyRowsStart(NewRows);
3520    for (TInt r = 0; r &lt; NewRows; r++) {
3521      for (TInt i = 0; i &lt; IntColsP.Len(); i++) {
3522        IntCols[i][start+r] = IntColsP[i][r];
3523      }
3524      for (TInt i = 0; i &lt; FltColsP.Len(); i++) {
3525        FltCols[i][start+r] = FltColsP[i][r];
3526      }
3527      for (TInt i = 0; i &lt; StrColMapsP.Len(); i++) {
3528        StrColMaps[i][start+r] = StrColMapsP[i][r];
3529      }
3530    }
3531    for (TInt r = 0; r &lt; NewRows-1; r++) {
3532      Next[start+r] = start+r+1;
3533    }
3534  }
3535  #ifdef USE_OPENMP
3536  void TTable::AddNJointRowsMP(const TTable&amp; T1, const TTable&amp; T2, const TVec&lt;TIntPrV&gt;&amp; JointRowIDSet) {
3537    int JointTableSize = 0;
3538    TIntV StartOffsets(JointRowIDSet.Len());
3539    for (int i = 0; i &lt; JointRowIDSet.Len(); i++) {
3540      StartOffsets[i] = JointTableSize;
3541      JointTableSize += JointRowIDSet[i].Len();
3542    }
3543    if (JointTableSize == 0) {
3544      TExcept::Throw(&quot;Joint table is empty&quot;);
3545    }
3546    ResizeTable(JointTableSize);
3547    NumRows = JointTableSize;
3548    NumValidRows = JointTableSize;
3549    Assert(NumRows &lt;= Next.Len());
3550    TInt IntOffset = T1.IntCols.Len();
3551    TInt FltOffset = T1.FltCols.Len();
3552    TInt StrOffset = T1.StrColMaps.Len();
3553    TInt IdOffset = IntOffset + T2.IntCols.Len();
3554    RowIdMap.Clr();
3555    for (TInt IdCnt = 0; IdCnt &lt; JointTableSize; IdCnt++) {
3556      RowIdMap.AddDat(IdCnt, IdCnt);
3557    }
3558    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3559    for (int j = 0; j &lt; JointRowIDSet.Len(); j++) {
3560      const TIntPrV&amp; RowIDs = JointRowIDSet[j];
3561      int start = StartOffsets[j];
3562      int NewRows = RowIDs.Len();
3563      if (NewRows == 0) {continue;}
3564      for (TInt r = 0; r &lt; NewRows; r++){
3565        TIntPr CurrRowIdPr = RowIDs[r]; 
3566        for(TInt i = 0; i &lt; T1.IntCols.Len(); i++){
3567          IntCols[i][start+r] = T1.IntCols[i][CurrRowIdPr.GetVal1()];
3568        }
3569        for(TInt i = 0; i &lt; T1.FltCols.Len(); i++){
3570          FltCols[i][start+r] = T1.FltCols[i][CurrRowIdPr.GetVal1()];
3571        }
3572        for(TInt i = 0; i &lt; T1.StrColMaps.Len(); i++){
3573          StrColMaps[i][start+r] = T1.StrColMaps[i][CurrRowIdPr.GetVal1()];
3574        }
3575        for(TInt i = 0; i &lt; T2.IntCols.Len(); i++){
3576          IntCols[i+IntOffset][start+r] = T2.IntCols[i][CurrRowIdPr.GetVal2()];
3577        }
3578        for(TInt i = 0; i &lt; T2.FltCols.Len(); i++){
3579          FltCols[i+FltOffset][start+r] = T2.FltCols[i][CurrRowIdPr.GetVal2()];
3580        }
3581        for(TInt i = 0; i &lt; T2.StrColMaps.Len(); i++){
3582          StrColMaps[i+StrOffset][start+r] = T2.StrColMaps[i][CurrRowIdPr.GetVal2()];
3583        }
3584        IntCols[IdOffset][start+r] = start+r;
3585      }
3586      for(TInt r = 0; r &lt; NewRows; r++){
3587        Next[start+r] = start+r+1;
3588      }
3589    }      
3590    LastValidRow = JointTableSize-1;
3591    Next[LastValidRow] = Last;
3592  }
3593  #endif 
3594  PTable TTable::UnionAll(const TTable&amp; Table) {
3595    Schema NewSchema;
3596    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3597      if (Sch[c].Val1 != GetIdColName()) {
3598        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3599      }
3600    }
3601    PTable result = TTable::New(NewSchema, Context);
3602    result-&gt;AddTable(*this);
3603    result-&gt;UnionAllInPlace(Table);
3604    return result;
3605  }
3606  void TTable::UnionAllInPlace(const TTable&amp; Table) {
3607    AddTable(Table);
3608  }
3609  PTable TTable::Union(const TTable&amp; Table) {
3610    Schema NewSchema;
3611    THashSet&lt;TInt&gt; Collisions;
3612    TStrV ColNames;
3613    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3614      if (Sch[c].Val1 != GetIdColName()) {
3615        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3616        ColNames.Add(Sch[c].Val1);
3617      }
3618    }
3619    PTable result = TTable::New(NewSchema, Context);
3620    GetCollidingRows(Table, Collisions); 
3621    result-&gt;AddTable(*this);
3622    result-&gt;Unique(ColNames);
3623    for (TRowIterator it = Table.BegRI(); it &lt; Table.EndRI(); it++) {
3624      if (!Collisions.IsKey(it.GetRowIdx())) {
3625        result-&gt;AddRowI(it);
3626      }
3627    }
3628    result-&gt;InitIds();
3629    return result;
3630  }
3631  PTable TTable::Intersection(const TTable&amp; Table) {
3632    Schema NewSchema;
3633    THashSet&lt;TInt&gt; Collisions;
3634    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3635      if (Sch[c].Val1 != GetIdColName()) {
3636        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3637      }
3638    }
3639    PTable result = TTable::New(NewSchema, Context);
3640    GetCollidingRows(Table, Collisions);
3641    for (TRowIterator it = Table.BegRI(); it &lt; Table.EndRI(); it++) {
3642      if (Collisions.IsKey(it.GetRowIdx())) {
3643        result-&gt;AddRowI(it);
3644      }
3645    }
3646    result-&gt;InitIds();
3647    return result;
3648  }
3649  PTable TTable::Minus(TTable&amp; Table) {
3650    Schema NewSchema;
3651    THashSet&lt;TInt&gt; Collisions;
3652    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3653      if (Sch[c].Val1 != GetIdColName()) {
3654        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3655      }
3656    }
3657    PTable result = TTable::New(NewSchema, Context);
3658    Table.GetCollidingRows(*this, Collisions);
3659    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
3660      if (!Collisions.IsKey(it.GetRowIdx())) {
3661        result-&gt;AddRowI(it);
3662      }
3663    }
3664    result-&gt;InitIds();
3665    return result;
3666  }
3667  PTable TTable::Project(const TStrV&amp; ProjectCols) {
3668    Schema NewSchema;
3669    for (TInt c = 0; c &lt; ProjectCols.Len(); c++) {
3670      if (!IsColName(ProjectCols[c])) { TExcept::Throw(&quot;no such column &quot; + ProjectCols[c]); }
3671      NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(ProjectCols[c], GetColType(ProjectCols[c])));
3672    }
3673    PTable result = TTable::New(NewSchema, Context);
3674    result-&gt;AddTable(*this);
3675    result-&gt;InitIds();
3676    return result;
3677  }
3678  TBool TTable::IsAttr(const TStr&amp; Attr) {
3679    return IsColName(Attr);
3680  }
3681  TStr TTable::RenumberColName(const TStr&amp; ColName) const {
3682    TStr NColName = ColName;
3683    if (NColName.GetCh(NColName.Len()-2) == &#x27;-&#x27;) { 
3684      NColName = NColName.GetSubStr(0,NColName.Len()-3); 
3685    }
3686    TInt Conflicts = 0;
3687    for (TInt i = 0; i &lt; Sch.Len(); i++) {
3688      if (NColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3689        Conflicts++;
3690      }
3691    }
3692    Conflicts++;
3693    NColName = NColName + &quot;-&quot; + Conflicts.GetStr();
3694    return NColName;
3695  }
3696  TStr TTable::DenormalizeColName(const TStr&amp; ColName) const {
3697    TStr DColName = ColName;
3698    if (DColName.Len() == 0) { return DColName; }
3699    if (DColName.GetCh(0) == &#x27;_&#x27;) { return DColName; }
3700    if (DColName.GetCh(DColName.Len()-2) == &#x27;-&#x27;) { 
3701      DColName = DColName.GetSubStr(0,DColName.Len()-3); 
3702    }
3703    TInt Conflicts = 0;
3704    for (TInt i = 0; i &lt; Sch.Len(); i++) {
3705      if (DColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3706        Conflicts++;
3707      }
3708    }
3709    if (Conflicts &gt; 1) { return ColName; } 
3710    else { return DColName; }
3711  }
3712  Schema TTable::DenormalizeSchema() const {
3713    Schema DSch;
3714    for (TInt i = 0; i &lt; Sch.Len(); i++) {
3715      DSch.Add(TPair&lt;TStr, TAttrType&gt;(DenormalizeColName(Sch[i].Val1), Sch[i].Val2));
3716    }
3717    return DSch;
3718  }
3719  void TTable::AddIntCol(const TStr&amp; ColName) {
3720    AddSchemaCol(ColName, atInt);
3721    IntCols.Add(TIntV(NumRows));
3722    TInt L = IntCols.Len();
3723    AddColType(ColName, atInt, L-1);
3724  }
3725  void TTable::AddFltCol(const TStr&amp; ColName) {
3726    AddSchemaCol(ColName, atFlt);
3727    FltCols.Add(TFltV(NumRows));
3728    TInt L = FltCols.Len();
3729    AddColType(ColName, atFlt, L-1);
3730  }
3731  void TTable::AddStrCol(const TStr&amp; ColName) {
3732    AddSchemaCol(ColName, atStr);
3733    StrColMaps.Add(TIntV(NumRows));
3734    TInt L = StrColMaps.Len();
3735    AddColType(ColName, atStr, L-1);
3736  }
3737  void TTable::ClassifyAux(const TIntV&amp; SelectedRows, const TStr&amp; LabelName, const TInt&amp; PositiveLabel, const TInt&amp; NegativeLabel) {
3738    AddSchemaCol(LabelName, atInt);
3739    TInt LabelColIdx = IntCols.Len();
3740    AddColType(LabelName, atInt, LabelColIdx);
3741    IntCols.Add(TIntV(NumRows));
3742    for (TInt i = 0; i &lt; NumRows; i++) {
3743      IntCols[LabelColIdx][i] = NegativeLabel;
3744    }
3745    for (TInt i = 0; i &lt; SelectedRows.Len(); i++) {
3746      IntCols[LabelColIdx][SelectedRows[i]] = PositiveLabel;
3747    }
3748  }
3749  #ifdef USE_OPENMP
3750  void TTable::ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op){
3751  	TAttrType ResType = atFlt;
3752  	if(ArgType1 == atInt &amp;&amp; ArgType2 == atInt){ ResType = atInt;}
3753  	TIntPrV Partitions;
3754  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3755  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3756  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3757  	for (int i = 0; i &lt; Partitions.Len(); i++){
3758  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3759  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3760  		while(RowI &lt; EndI){
3761  			if(ResType == atInt){
3762  				TInt V1 = RowI.GetIntAttr(ArgColIdx1);
3763  				TInt V2 = RowI.GetIntAttr(ArgColIdx2);
3764  				if (op == aoAdd) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3765        			if (op == aoSub) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3766        			if (op == aoMul) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3767        			if (op == aoDiv) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3768        			if (op == aoMod) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 % V2; }
3769        			if (op == aoMin) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3770        			if (op == aoMax) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3771  			} else{
3772  			    TFlt V1 = (ArgType1 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx1) : RowI.GetFltAttr(ArgColIdx1);
3773  			    TFlt V2 = (ArgType2 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx2) : RowI.GetFltAttr(ArgColIdx2);
3774  				if (op == aoAdd) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3775        			if (op == aoSub) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3776        			if (op == aoMul) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3777        			if (op == aoDiv) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3778        			if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;);  }
3779        			if (op == aoMin) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3780        			if (op == aoMax) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3781  			}
3782  			RowI++;
3783  		}
3784  	}
3785  }
3786  #endif	
3787  void TTable::ColGenericOp(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResAttr, TArithOp op) {
3788    if (!IsAttr(Attr1)) TExcept::Throw(&quot;No attribute present: &quot; + Attr1);
3789    if (!IsAttr(Attr2)) TExcept::Throw(&quot;No attribute present: &quot; + Attr2);
3790    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
3791    TPair&lt;TAttrType, TInt&gt; Info2 = GetColTypeMap(Attr2);
3792    TAttrType Arg1Type = Info1.Val1;
3793    TAttrType Arg2Type = Info2.Val1;
3794    if (Arg1Type == atStr || Arg2Type == atStr) {
3795      TExcept::Throw(&quot;Only numeric columns supported in arithmetic operations.&quot;);
3796    }
3797    if(Arg1Type == atInt &amp;&amp; Arg2Type == atFlt &amp;&amp; ResAttr == &quot;&quot;){
3798    	TExcept::Throw(&quot;Trying to write float values to an existing int-typed column&quot;);
3799    }
3800    TInt ColIdx1 = Info1.Val2;
3801    TInt ColIdx2 = Info2.Val2;
3802    TInt ColIdx3 = ColIdx1;
3803    if (ResAttr != &quot;&quot;) {
3804        if (Arg1Type == atInt &amp;&amp; Arg2Type == atInt) {
3805            AddIntCol(ResAttr);
3806        }
3807        else {
3808            AddFltCol(ResAttr);
3809        }
3810        ColIdx3 = GetColIdx(ResAttr);
3811    }
3812  #ifdef USE_OPENMP
3813    if(GetMP()){
3814    	ColGenericOpMP(ColIdx1, ColIdx2, Arg1Type, Arg2Type, ColIdx3, op);
3815    	return;
3816    }
3817  #endif	
3818    TAttrType ResType = atFlt;
3819    if(Arg1Type == atInt &amp;&amp; Arg2Type == atInt){ printf(&quot;hooray!\n&quot;); ResType = atInt;}
3820    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
3821  		if(ResType == atInt){
3822  			TInt V1 = RowI.GetIntAttr(ColIdx1);
3823  			TInt V2 = RowI.GetIntAttr(ColIdx2);
3824  			if (op == aoAdd) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3825        		if (op == aoSub) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3826        		if (op == aoMul) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3827        		if (op == aoDiv) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3828        		if (op == aoMod) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 % V2; }
3829        		if (op == aoMin) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3830        		if (op == aoMax) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3831  		} else{
3832  			TFlt V1 = (Arg1Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx1) : RowI.GetFltAttr(ColIdx1);
3833  			TFlt V2 = (Arg2Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx2) : RowI.GetFltAttr(ColIdx2);
3834  			if (op == aoAdd) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3835        		if (op == aoSub) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3836        		if (op == aoMul) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3837        		if (op == aoDiv) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3838        		if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;);  }
3839        		if (op == aoMin) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3840        		if (op == aoMax) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3841  		}
3842    }
3843  }
3844  void TTable::ColAdd(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3845    ColGenericOp(Attr1, Attr2, ResultAttrName, aoAdd);
3846  }
3847  void TTable::ColSub(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3848    ColGenericOp(Attr1, Attr2, ResultAttrName, aoSub);
3849  }
3850  void TTable::ColMul(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3851    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMul);
3852  }
3853  void TTable::ColDiv(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3854    ColGenericOp(Attr1, Attr2, ResultAttrName, aoDiv);
3855  }
3856  void TTable::ColMod(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3857    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMod);
3858  }
3859  void TTable::ColMin(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3860    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMin);
3861  }
3862  void TTable::ColMax(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3863    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMax);
3864  }
3865  void TTable::ColGenericOp(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, const TStr&amp; ResAttr,
3866   TArithOp op, TBool AddToFirstTable) {
3867    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
3868    if (!Table.IsAttr(Attr2)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr2); }
3869    if (NumValidRows != Table.NumValidRows) {
3870      TExcept::Throw(&quot;Tables do not have equal number of rows&quot;);
3871    }
3872    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
3873    TPair&lt;TAttrType, TInt&gt; Info2 = Table.GetColTypeMap(Attr2);
3874    TAttrType Arg1Type = Info1.Val1;
3875    TAttrType Arg2Type = Info2.Val1;
3876    if (Info1.Val1 == atStr || Info2.Val1 == atStr) {
3877      TExcept::Throw(&quot;Only numeric columns supported in arithmetic operations.&quot;);
3878    }
3879    if(Arg1Type == atInt &amp;&amp; Arg2Type == atFlt &amp;&amp; ResAttr == &quot;&quot;){
3880    	TExcept::Throw(&quot;Trying to write float values to an existing int-typed column&quot;);
3881    }
3882    TInt ColIdx1 = Info1.Val2;
3883    TInt ColIdx2 = Info2.Val2;
3884    TInt ColIdx3 = AddToFirstTable ? ColIdx1 : ColIdx2;
3885    if (ResAttr != &quot;&quot;) {
3886      if (AddToFirstTable) {
3887        if (Arg1Type == atInt &amp;&amp; Arg2Type == atInt) {
3888            AddIntCol(ResAttr);
3889        } else {
3890            AddFltCol(ResAttr);
3891        }
3892        ColIdx3 = GetColIdx(ResAttr);
3893      }
3894      else {
3895        if (Arg1Type == atInt &amp;&amp; Arg2Type == atInt) {
3896            Table.AddIntCol(ResAttr);
3897        } else {
3898            Table.AddFltCol(ResAttr);
3899        }
3900        ColIdx3 = Table.GetColIdx(ResAttr);
3901      }
3902    }
3903    TRowIterator RI1, RI2;
3904    RI1 = BegRI();
3905    RI2 = Table.BegRI();
3906    TAttrType ResType = atFlt;
3907    if(Arg1Type == atInt &amp;&amp; Arg2Type == atInt){ ResType = atInt;}
3908    while (RI1 &lt; EndRI() &amp;&amp; RI2 &lt; Table.EndRI()) {
3909      if (ResType == atInt) {
3910  		TInt V1 = RI1.GetIntAttr(ColIdx1);
3911  		TInt V2 = RI2.GetIntAttr(ColIdx2);
3912          if (AddToFirstTable) {
3913          	if (op == aoAdd) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3914          	if (op == aoSub) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3915          	if (op == aoMul) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3916          	if (op == aoDiv) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3917         		if (op == aoMod) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 % V2; }
3918        	}
3919        	else {
3920          	if (op == aoAdd) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3921          	if (op == aoSub) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3922          	if (op == aoMul) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3923          	if (op == aoDiv) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3924          	if (op == aoMod) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 % V2; }
3925        	}
3926      } else {
3927  	  	TFlt V1 = (Arg1Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx1) : RI2.GetFltAttr(ColIdx1);
3928  		TFlt V2 = (Arg2Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx2) : RI2.GetFltAttr(ColIdx2);
3929        	if (AddToFirstTable) {
3930          	if (op == aoAdd) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3931          	if (op == aoSub) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3932          	if (op == aoMul) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3933         	 	if (op == aoDiv) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3934          	if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
3935        	} else {
3936          	if (op == aoAdd) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3937          	if (op == aoSub) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3938          	if (op == aoMul) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3939          	if (op == aoDiv) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3940          	if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
3941        	}
3942      }
3943      RI1++;
3944      RI2++;
3945    }
3946    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
3947      TExcept::Throw(&quot;ColGenericOp: Iteration error&quot;);
3948    }
3949  }
3950  void TTable::ColAdd(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3951   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3952    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoAdd, AddToFirstTable);
3953  }
3954  void TTable::ColSub(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3955   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3956    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoSub, AddToFirstTable);
3957  }
3958  void TTable::ColMul(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3959   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3960    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMul, AddToFirstTable);
3961  }
3962  void TTable::ColDiv(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3963   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3964    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoDiv, AddToFirstTable);
3965  }
3966  void TTable::ColMod(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3967   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3968    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMod, AddToFirstTable);
3969  }
3970  void TTable::ColGenericOp(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResAttr, TArithOp op, const TBool floatCast) {
3971    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
3972    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
3973    TAttrType ArgType = Info1.Val1;
3974    if (ArgType == atStr) {
3975      TExcept::Throw(&quot;Only numeric columns supported in arithmetic operations.&quot;);
3976    }
3977    TInt ColIdx1 = Info1.Val2;
3978    TInt ColIdx2 = ColIdx1;
3979    TBool shouldCast = floatCast;
3980    if (ResAttr != &quot;&quot;) {
3981        if ((ArgType == atInt) &amp; !shouldCast) {
3982            AddIntCol(ResAttr);
3983        } else {
3984            AddFltCol(ResAttr);
3985        }
3986        ColIdx2 = GetColIdx(ResAttr);
3987    } else {
3988      shouldCast = false;
3989    }
3990    #ifdef USE_OPENMP
3991    if(GetMP()){
3992    	ColGenericOpMP(ColIdx1, ColIdx2, ArgType, Num, op, shouldCast);
3993    	return;
3994    }
3995    #endif  
3996    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
3997      if ((ArgType == atInt) &amp;&amp; !shouldCast) {
3998        TInt CurVal = RowI.GetIntAttr(ColIdx1);
3999        TInt Val = static_cast&lt;int&gt;(Num);
4000        if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4001        if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4002        if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4003        if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4004        if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4005      }
4006      else {
4007        TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4008        if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4009        if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4010        if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4011        if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4012        if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
4013      }
4014    }
4015  }
4016  #ifdef USE_OPENMP
4017  void TTable::ColGenericOpMP(const TInt&amp; ColIdx1, const TInt&amp; ColIdx2, TAttrType ArgType, const TFlt&amp; Num, TArithOp op, TBool ShouldCast){
4018  	TIntPrV Partitions;
4019  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
4020  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
4021  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
4022  	for (int i = 0; i &lt; Partitions.Len(); i++){
4023  		TRowIterator RowI(Partitions[i].GetVal1(), this);
4024  		TRowIterator EndI(Partitions[i].GetVal2(), this);
4025  		while(RowI &lt; EndI){
4026  			if ((ArgType == atInt) &amp;&amp; !ShouldCast) {
4027        			TInt CurVal = RowI.GetIntAttr(ColIdx1);
4028        			TInt Val = static_cast&lt;int&gt;(Num);
4029        			if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4030        			if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4031        			if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4032        			if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4033        			if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4034      		} else {
4035       			TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4036        			if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4037        			if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4038        			if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4039        			if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4040        			if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
4041      		}
4042      		RowI++;
4043  		}
4044  	}
4045  }
4046  #endif
4047  void TTable::ColAdd(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4048    ColGenericOp(Attr1, Num, ResultAttrName, aoAdd, floatCast);
4049  }
4050  void TTable::ColSub(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4051    ColGenericOp(Attr1, Num, ResultAttrName, aoSub, floatCast);
4052  }
4053  void TTable::ColMul(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4054    ColGenericOp(Attr1, Num, ResultAttrName, aoMul, floatCast);
4055  }
4056  void TTable::ColDiv(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4057    ColGenericOp(Attr1, Num, ResultAttrName, aoDiv, floatCast);
4058  }
4059  void TTable::ColMod(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4060    ColGenericOp(Attr1, Num, ResultAttrName, aoMod, floatCast);
4061  }
4062  void TTable::ColConcat(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; Sep, const TStr&amp; ResAttr) {
4063    if (!IsAttr(Attr1)) TExcept::Throw(&quot;No attribute present: &quot; + Attr1);
4064    if (!IsAttr(Attr2)) TExcept::Throw(&quot;No attribute present: &quot; + Attr2);
4065    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
4066    TPair&lt;TAttrType, TInt&gt; Info2 = GetColTypeMap(Attr2);
4067    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4068      TExcept::Throw(&quot;Only string columns supported in concat.&quot;);
4069    }
4070    TInt ColIdx1 = Info1.Val2;
4071    TInt ColIdx2 = Info2.Val2;
4072    TInt ColIdx3 = ColIdx1;
4073    if (ResAttr != &quot;&quot;) {
4074        AddStrCol(ResAttr);
4075        ColIdx3 = GetColIdx(ResAttr);
4076    }
4077    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4078      TStr CurVal1 = RowI.GetStrAttr(ColIdx1);
4079      TStr CurVal2 = RowI.GetStrAttr(ColIdx2);
4080      TStr NewVal = CurVal1 + Sep + CurVal2;
4081      TInt Key = TInt(Context-&gt;StringVals.AddKey(NewVal));
4082      StrColMaps[ColIdx3][RowI.GetRowIdx()] = Key;
4083    }
4084  }
4085  void TTable::ColConcat(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, const TStr&amp; Sep, 
4086   const TStr&amp; ResAttr, TBool AddToFirstTable) {
4087    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
4088    if (!Table.IsAttr(Attr2)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr2); }
4089    if (NumValidRows != Table.NumValidRows) {
4090      TExcept::Throw(&quot;Tables do not have equal number of rows&quot;);
4091    }
4092    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
4093    TPair&lt;TAttrType, TInt&gt; Info2 = Table.GetColTypeMap(Attr2);
4094    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4095      TExcept::Throw(&quot;Only string columns supported in concat.&quot;);
4096    }
4097    TInt ColIdx1 = Info1.Val2;
4098    TInt ColIdx2 = Info2.Val2;
4099    TInt ColIdx3 = ColIdx1;
4100    if (!AddToFirstTable) {
4101      ColIdx3 = ColIdx2;
4102    }
4103    if (ResAttr != &quot;&quot;) {
4104      if (AddToFirstTable) {
4105        AddStrCol(ResAttr);
4106        ColIdx3 = GetColIdx(ResAttr);
4107      }
4108      else {
4109        Table.AddStrCol(ResAttr);
4110        ColIdx3 = Table.GetColIdx(ResAttr);
4111      }
4112    }
4113    TRowIterator RI1, RI2;
4114    RI1 = BegRI();
4115    RI2 = Table.BegRI();
4116    while (RI1 &lt; EndRI() &amp;&amp; RI2 &lt; Table.EndRI()) {
4117      TStr CurVal1 = RI1.GetStrAttr(ColIdx1);
4118      TStr CurVal2 = RI2.GetStrAttr(ColIdx2);
4119      TStr NewVal = CurVal1 + Sep + CurVal2;
4120      TInt Key = TInt(Context-&gt;StringVals.AddKey(NewVal));
4121      if (AddToFirstTable) {
4122        StrColMaps[ColIdx3][RI1.GetRowIdx()] = Key;
4123      }
4124      else {
4125        Table.StrColMaps[ColIdx3][RI2.GetRowIdx()] = Key;
4126      }
4127      RI1++;
4128      RI2++;
4129    }
4130    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
4131      TExcept::Throw(&quot;ColGenericOp: Iteration error&quot;);
4132    }
4133  }
4134  void TTable::ColConcatConst(const TStr&amp; Attr1, const TStr&amp; Val, const TStr&amp; Sep, const TStr&amp; ResAttr) {
4135    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
4136    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
4137    if (Info1.Val1 != atStr) {
4138      TExcept::Throw(&quot;Only string columns supported in concat.&quot;);
4139    }
4140    TInt ColIdx1 = Info1.Val2;
4141    TInt ColIdx2 = ColIdx1;
4142    if (ResAttr != &quot;&quot;) {
4143      AddStrCol(ResAttr);
4144      ColIdx2 = GetColIdx(ResAttr);
4145    }
4146    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4147      TStr CurVal = RowI.GetStrAttr(ColIdx1);
4148      TStr NewVal = CurVal + Sep + Val;
4149      TInt Key = TInt(Context-&gt;StringVals.AddKey(NewVal));
4150      StrColMaps[ColIdx2][RowI.GetRowIdx()] = Key;
4151    }  
4152  }
4153  void TTable::ReadIntCol(const TStr&amp; ColName, TIntV&amp; Result) const{
4154    if (!IsColName(ColName)) { TExcept::Throw(&quot;no such column &quot; + ColName); }
4155    if (GetColType(ColName) != atInt) { TExcept::Throw(&quot;not an integer column &quot; + ColName); }
4156    TInt ColId = GetColIdx(ColName);
4157    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
4158      Result.Add(it.GetIntAttr(ColId));
4159    }
4160  }
4161  void TTable::ReadFltCol(const TStr&amp; ColName, TFltV&amp; Result) const{
4162    if (!IsColName(ColName)) { TExcept::Throw(&quot;no such column &quot; + ColName); }
4163    if (GetColType(ColName) != atFlt) { TExcept::Throw(&quot;not a floating point column &quot; + ColName); }
4164    TInt ColId = GetColIdx(ColName);
4165    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
4166      Result.Add(it.GetFltAttr(ColId));
4167    }
4168  }
4169  void TTable::ReadStrCol(const TStr&amp; ColName, TStrV&amp; Result) const{
4170    if (!IsColName(ColName)) { TExcept::Throw(&quot;no such column &quot; + ColName); }
4171    if (GetColType(ColName) != atStr) { TExcept::Throw(&quot;not a string column &quot; + ColName); }
4172    TInt ColId = GetColIdx(ColName);
4173    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
4174      Result.Add(it.GetStrAttr(ColId));
4175    }
4176  }
4177  void TTable::ProjectInPlace(const TStrV&amp; ProjectCols) {
4178    TStrV NProjectCols = NormalizeColNameV(ProjectCols);
4179    for (TInt c = 0; c &lt; NProjectCols.Len(); c++) {
4180      if (!IsColName(NProjectCols[c])) { TExcept::Throw(&quot;no such column &quot; + NProjectCols[c]); }
4181    }
4182    THashSet&lt;TStr&gt; ProjectColsSet = THashSet&lt;TStr&gt;(NProjectCols);
4183    for (TInt i = Sch.Len() - 1; i &gt;= 0; i--) {
4184      TStr ColName = GetSchemaColName(i);
4185      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4186      TAttrType ColType = GetSchemaColType(i);
4187      TInt ColId = GetColIdx(ColName);
4188      switch (ColType) {
4189        case atInt:
4190          IntCols.Del(ColId);
4191          break;
4192        case atFlt:
4193          FltCols.Del(ColId);
4194          break;
4195        case atStr:
4196          StrColMaps.Del(ColId);
4197          break;
4198      }
4199    }
4200    TInt IntColCnt = 0;
4201    TInt FltColCnt = 0;
4202    TInt StrColCnt = 0;
4203    ColTypeMap.Clr();
4204    for (TInt i = 0; i &lt; Sch.Len(); i++) {
4205      TStr ColName = GetSchemaColName(i);
4206      if (!ProjectColsSet.IsKey(ColName) &amp;&amp; ColName != IdColName) { continue; }
4207      TAttrType ColType = GetSchemaColType(i);
4208      switch (ColType) {
4209        case atInt:
4210          AddColType(ColName, atInt, IntColCnt);
4211          IntColCnt++;
4212          break;
4213        case atFlt:
4214          AddColType(ColName, atFlt, FltColCnt);
4215          FltColCnt++;
4216          break;
4217        case atStr:
4218          AddColType(ColName, atStr, StrColCnt);
4219          StrColCnt++;
4220          break;
4221      }
4222    }
4223    for (TInt i = Sch.Len() - 1; i &gt;= 0; i--) {
4224      TStr ColName = GetSchemaColName(i);
4225      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4226      Sch.Del(i);
4227    }
4228  }
4229  TInt TTable::CompareKeyVal(const TInt&amp; K1, const TInt&amp; V1, const TInt&amp; K2, const TInt&amp; V2) {
4230    if (K1 == K2) { return V1 - V2; }
4231    else { return K1 - K2; }
4232  }
4233  TInt TTable::CheckSortedKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4234    TInt j;
4235    for (j = Start; j &lt; End; j++) {
4236      if (CompareKeyVal(Key[j], Val[j], Key[j+1], Val[j+1]) &gt; 0) {
4237        break;
4238      }
4239    }
4240    if (j &gt;= End) { return 0; }
4241    else { return 1; }
4242  }
4243  void TTable::ISortKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4244    if (Start &lt; End) {
4245      for (TInt i = Start+1; i &lt;= End; i++) {
4246        TInt K = Key[i];
4247        TInt V = Val[i];
4248        TInt j = i;
4249        while ((Start &lt; j) &amp;&amp; (CompareKeyVal(Key[j-1], Val[j-1], K, V) &gt; 0)) {
4250          Key[j] = Key[j-1];
4251          Val[j] = Val[j-1];
4252          j--;
4253        }
4254        Key[j] = K;
4255        Val[j] = V;
4256      }
4257    }
4258  }
4259  TInt TTable::GetPivotKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4260    TInt L = End - Start + 1;
4261    const TInt Idx1 = Start + TInt::GetRnd(L);
4262    const TInt Idx2 = Start + TInt::GetRnd(L);
4263    const TInt Idx3 = Start + TInt::GetRnd(L);
4264    if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx2], Val[Idx2]) &lt; 0) {
4265      if (CompareKeyVal(Key[Idx2], Val[Idx2], Key[Idx3], Val[Idx3]) &lt; 0) { return Idx2; }
4266      if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx3], Val[Idx3]) &lt; 0) { return Idx3; }
4267      return Idx1;
4268    } else {
4269      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx2], Val[Idx2]) &lt; 0) { return Idx2; }
4270      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx1], Val[Idx1]) &lt; 0) { return Idx3; }
4271      return Idx1;
4272    }
4273  }
4274  TInt TTable::PartitionKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4275    TInt Pivot = GetPivotKeyVal(Key, Val, Start, End);
4276    TInt PivotKey = Key[Pivot];
4277    TInt PivotVal = Val[Pivot];
4278    Key.Swap(Pivot, End);
4279    Val.Swap(Pivot, End);
4280    TInt StoreIdx = Start;
4281    for (TInt i = Start; i &lt; End; i++) {
4282      if (CompareKeyVal(Key[i], Val[i], PivotKey, PivotVal) &lt;= 0) {
4283        Key.Swap(i, StoreIdx);
4284        Val.Swap(i, StoreIdx);
4285        StoreIdx++;
4286      }
4287    }
4288    Key.Swap(StoreIdx, End);
4289    Val.Swap(StoreIdx, End);
4290    return StoreIdx;
4291  }
4292  void TTable::QSortKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4293    TInt L = End-Start;
4294    if (L &lt;= 0) { return; }
4295    if (CheckSortedKeyVal(Key, Val, Start, End) == 0) { return; }
4296    if (L &lt;= 20) { ISortKeyVal(Key, Val, Start, End); }
4297    else {
4298      TInt Pivot = PartitionKeyVal(Key, Val, Start, End);
4299      if (Pivot &gt; End) { return; }
4300      if (L &lt;= 500000) {
4301        QSortKeyVal(Key, Val, Start, Pivot-1);
4302        QSortKeyVal(Key, Val, Pivot+1, End);
4303      } else {
4304  #ifdef USE_OPENMP
4305  #ifndef GLib_WIN32
4306        #pragma omp task untied shared(Key, Val)
4307  #endif
4308  #endif
4309        { QSortKeyVal(Key, Val, Start, Pivot-1); }
4310  #ifdef USE_OPENMP
4311  #ifndef GLib_WIN32
4312        #pragma omp task untied shared(Key, Val)
4313  #endif
4314  #endif
4315        { QSortKeyVal(Key, Val, Pivot+1, End); }
4316      }
4317    }
4318  }
4319  TIntV TTable::GetIntRowIdxByVal(const TStr&amp; ColName, const TInt&amp; Val) const {
4320    if (IntColIndexes.IsKey(ColName)) {
4321      THash&lt;TInt, TIntV&gt; ColIndex = IntColIndexes.GetDat(ColName);
4322      if (ColIndex.IsKey(Val)) {
4323        return ColIndex.GetDat(Val);
4324      }
4325      else {
4326        TIntV Empty;
4327        return Empty;
4328      }
4329    }
4330    TIntV ToReturn;
4331    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4332      TInt ValAtRow = RowI.GetIntAttr(ColName);
4333      if ( Val == ValAtRow) {
4334        ToReturn.Add(RowI.GetRowIdx());
4335      }
4336    }
4337    return ToReturn;
4338  }
4339  TIntV TTable::GetStrRowIdxByMap(const TStr&amp; ColName, const TInt&amp; Map) const {
4340    if (StrMapColIndexes.IsKey(ColName)) {
4341      THash&lt;TInt, TIntV&gt; ColIndex = StrMapColIndexes.GetDat(ColName);
4342      if (ColIndex.IsKey(Map)) {
4343        return ColIndex.GetDat(Map);
4344      }
4345      else {
4346        TIntV Empty;
4347        return Empty;
4348      }
4349    }
4350    TIntV ToReturn;
4351    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4352      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4353      if ( Map == MapAtRow) {
4354        ToReturn.Add(RowI.GetRowIdx());
4355      }
4356    }
4357    return ToReturn;
4358  }
4359  TIntV TTable::GetFltRowIdxByVal(const TStr&amp; ColName, const TFlt&amp; Val) const {
4360    if (FltColIndexes.IsKey(ColName)) {
4361      THash&lt;TFlt, TIntV&gt; ColIndex = FltColIndexes.GetDat(ColName);
4362      if (ColIndex.IsKey(Val)) {
4363        return ColIndex.GetDat(Val);
4364      }
4365      else {
4366        TIntV Empty;
4367        return Empty;
4368      }
4369    }
4370    TIntV ToReturn;
4371    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4372      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4373      if ( Val == ValAtRow) {
4374        ToReturn.Add(RowI.GetRowIdx());
4375      }
4376    }
4377    return ToReturn;
4378  }
4379  TInt TTable::RequestIndexInt(const TStr&amp; ColName) {
4380    THash&lt;TInt, TIntV&gt; NewIndex;
4381    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4382      TInt ValAtRow = RowI.GetIntAttr(ColName);
4383      TInt RowIdx = RowI.GetRowIdx();
4384      if (NewIndex.IsKey(ValAtRow)) {
4385         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4386         Curr_V.Add(RowIdx);
4387      }
4388      else {
4389        TIntV New_V;
4390        New_V.Add(RowIdx);
4391        NewIndex.AddDat(ValAtRow, New_V);
4392      }
4393    }
4394    IntColIndexes.AddDat(ColName, NewIndex); 
4395    return 0;
4396  }
4397  TInt TTable::RequestIndexFlt(const TStr&amp; ColName) {
4398    THash&lt;TFlt, TIntV&gt; NewIndex;
4399    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4400      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4401      TInt RowIdx = RowI.GetRowIdx();
4402      if (NewIndex.IsKey(ValAtRow)) {
4403         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4404         Curr_V.Add(RowIdx);
4405      }
4406      else {
4407        TIntV New_V;
4408        New_V.Add(RowIdx);
4409        NewIndex.AddDat(ValAtRow, New_V);
4410      }
4411    }
4412    FltColIndexes.AddDat(ColName, NewIndex); 
4413    return 0;
4414  }
4415  TInt TTable::RequestIndexStrMap(const TStr&amp; ColName) {
4416    THash&lt;TInt, TIntV&gt; NewIndex;
4417    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4418      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4419      TInt RowIdx = RowI.GetRowIdx();
4420      if (NewIndex.IsKey(MapAtRow)) {
4421         TIntV Curr_V = NewIndex.GetDat(MapAtRow);
4422         Curr_V.Add(RowIdx);
4423      }
4424      else {
4425        TIntV New_V;
4426        New_V.Add(RowIdx);
4427        NewIndex.AddDat(MapAtRow, New_V);
4428      }
4429    }
4430    StrMapColIndexes.AddDat(ColName, NewIndex); 
4431    return 0;
4432  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</h3>
            <pre><code>1  void TPredicateNode::GetVariables(TStrV&amp; Variables) {
2    if (Left != NULL) { Left-&gt;GetVariables(Variables); }
3    if (Right != NULL) { Right-&gt;GetVariables(Variables); }
4    if (Op == NOP) {
5      if (Atom.Lvar != &quot;&quot; ) { Variables.Add(Atom.Lvar); }
6      if (Atom.Rvar != &quot;&quot; ) { Variables.Add(Atom.Rvar); }
7    }
8  }
9  void TPredicate::GetVariables(TStrV&amp; Variables) {
10    Root-&gt;GetVariables(Variables);
11  }
12  TBool TPredicate::Eval() {
13    TPredicateNode* Curr = Root;
14    TPredicateNode* Prev = NULL;
15    while (!(Curr == NULL &amp;&amp; Prev == Root)) {
16      if (Prev == NULL || Prev == Curr-&gt;Parent) {
17        if (Curr-&gt;Left != NULL) {
18          Prev = Curr;
19          Curr = Curr-&gt;Left;
20        } else if (Curr-&gt;Right != NULL) {
21          Prev = Curr;
22          Curr = Curr-&gt;Right;
23        } else {
24          Curr-&gt;Result = EvalAtomicPredicate(Curr-&gt;Atom);
25          Prev = Curr;
26          Curr = Curr-&gt;Parent;
27        }
28      } else if (Prev == Curr-&gt;Left) {
29        switch (Curr-&gt;Op) {
30          case NOT: {
31            Assert(Curr-&gt;Right == NULL);
32            Curr-&gt;Result = !(Prev-&gt;Result);
33            Prev = Curr;
34            Curr = Curr-&gt;Parent;
35            break;
36          }
37          case AND: {
38            Assert(Curr-&gt;Right != NULL);
39            if (!Prev-&gt;Result) {
40              Curr-&gt;Result = false;
41              Prev = Curr;
42              Curr = Curr-&gt;Parent;
43            } else {
44              Prev = Curr;
45              Curr = Curr-&gt;Right;
46            }
47            break;
48          }
49          case OR: {
50            Assert(Curr-&gt;Right != NULL);
51            if (Prev-&gt;Result) {
52              Curr-&gt;Result = true;
53              Prev = Curr;
54              Curr = Curr-&gt;Parent;
55            } else {
56              Prev = Curr;
57              Curr = Curr-&gt;Right;
58            }
59            break;
60          }
61          case NOP: {
62            break;
63          }
64        }
65      } else {
66        Assert(Prev == Curr-&gt;Right);
67        switch (Curr-&gt;Op) {
68          case NOT: {
69            Assert(Curr-&gt;Left == NULL);
70            Curr-&gt;Result = !(Prev-&gt;Result);
71            break;
72          }
73          case AND: {
74            Assert(Curr-&gt;Left != NULL);
75            Assert(Curr-&gt;Left-&gt;Result);
76            Curr-&gt;Result = Prev-&gt;Result;
77            break;
78          }
79          case OR: {
80            Assert(Curr-&gt;Left != NULL);
81            Assert(!Curr-&gt;Left-&gt;Result);
82            Curr-&gt;Result = Prev-&gt;Result;
83            break;
84          }
85          case NOP: {
86            break;
87          }
88        }
89        Prev = Curr;
90        Curr = Curr-&gt;Parent;
91      }
92    }
93    return Root-&gt;Result;
94  }
95  TBool TPredicate::EvalAtomicPredicate(const TAtomicPredicate&amp; Atom) {
96    switch (Atom.Type) {
97      case atInt: {
98        if (Atom.IsConst) { 
99          return EvalAtom&lt;TInt&gt;(IntVars.GetDat(Atom.Lvar), Atom.IntConst, Atom.Compare); 
100        }
101        return EvalAtom&lt;TInt&gt;(IntVars.GetDat(Atom.Lvar), IntVars.GetDat(Atom.Rvar), Atom.Compare);
102      }
103      case atFlt: {
104        if (Atom.IsConst) { 
105          return EvalAtom&lt;TFlt&gt;(FltVars.GetDat(Atom.Lvar), Atom.FltConst, Atom.Compare); 
106        }
107        return EvalAtom&lt;TFlt&gt;(FltVars.GetDat(Atom.Lvar), FltVars.GetDat(Atom.Rvar), Atom.Compare);
108      }
109      case atStr: {
110        if (Atom.IsConst) { 
111          return EvalAtom&lt;TStr&gt;(StrVars.GetDat(Atom.Lvar), Atom.StrConst, Atom.Compare); 
112        }
113        return EvalAtom&lt;TStr&gt;(StrVars.GetDat(Atom.Lvar), StrVars.GetDat(Atom.Rvar), Atom.Compare);
114      }
115    }
116    return false;
117  }
118  TInt const TTable::Last = -1;
119  TInt const TTable::Invalid = -2;
120  TInt TTable::UseMP = 1;
121  TRowIterator&amp; TRowIterator::operator++(int) {
122    return this-&gt;Next();
123  }
124  TRowIterator&amp; TRowIterator::Next() {
125    CurrRowIdx = Table-&gt;Next[CurrRowIdx];
126    return *this;
127  }
128  bool TRowIterator::operator &lt; (const TRowIterator&amp; RowI) const{
129    if (CurrRowIdx == TTable::Last) { return false; }
130    if (RowI.CurrRowIdx == TTable::Last) { return true; }
131    return CurrRowIdx &lt; RowI.CurrRowIdx;
132  }
133  bool TRowIterator::operator == (const TRowIterator&amp; RowI) const {
134    return CurrRowIdx == RowI.CurrRowIdx;
135  }
136  TInt TRowIterator::GetRowIdx() const {
137    return CurrRowIdx;
138  }
139  TInt TRowIterator::GetIntAttr(TInt ColIdx) const {
140    return Table-&gt;IntCols[ColIdx][CurrRowIdx];
141  }
142  TFlt TRowIterator::GetFltAttr(TInt ColIdx) const {
143    return Table-&gt;FltCols[ColIdx][CurrRowIdx];
144  }
145  TStr TRowIterator::GetStrAttr(TInt ColIdx) const {
146    return Table-&gt;GetStrValIdx(ColIdx, CurrRowIdx);
147  }
148  TInt TRowIterator::GetIntAttr(const TStr&amp; Col) const {
149    TInt ColIdx = Table-&gt;GetColIdx(Col);
150    return Table-&gt;IntCols[ColIdx][CurrRowIdx];
151  }
152  TFlt TRowIterator::GetFltAttr(const TStr&amp; Col) const {
153    TInt ColIdx = Table-&gt;GetColIdx(Col);
154    return Table-&gt;FltCols[ColIdx][CurrRowIdx];
155  }
156  TStr TRowIterator::GetStrAttr(const TStr&amp; Col) const {
157    return Table-&gt;GetStrVal(Col, CurrRowIdx);
158  }
159  TInt TRowIterator::GetStrMapByName(const TStr&amp; Col) const {
160    TInt ColIdx = Table-&gt;GetColIdx(Col);
161    return Table-&gt;StrColMaps[ColIdx][CurrRowIdx];
162  }
163  TInt TRowIterator::GetStrMapById(TInt ColIdx) const {
164    return Table-&gt;StrColMaps[ColIdx][CurrRowIdx];
165  }
166  TBool TRowIterator::CompareAtomicConst(TInt ColIdx, const TPrimitive&amp; Val, TPredComp Cmp) {
167    TBool Result;
168    switch (Val.GetType()) {
169      case atInt:
170        Result = TPredicate::EvalAtom(GetIntAttr(ColIdx), Val.GetInt(), Cmp);
171        break;
172      case atFlt:
173        Result = TPredicate::EvalAtom(GetFltAttr(ColIdx), Val.GetFlt(), Cmp);
174        break;
175      case atStr:
176        Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val.GetStr(), Cmp);
177        break;
178      default:
179        Result = TBool(false);
180    }
181    return Result;
182  }
183  TBool TRowIterator::CompareAtomicConstTStr(TInt ColIdx, const TStr&amp; Val, TPredComp Cmp) {
184    TBool Result;
185    Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val, Cmp);
186    return Result;
187  }
188  TRowIteratorWithRemove::TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr) :
189    CurrRowIdx(RowIdx), Table(TablePtr), Start(RowIdx == TablePtr-&gt;FirstValidRow) {}
190  TRowIteratorWithRemove&amp; TRowIteratorWithRemove::operator++(int) {
191    return this-&gt;Next();
192  }
193  TRowIteratorWithRemove&amp; TRowIteratorWithRemove::Next() {
194    CurrRowIdx = GetNextRowIdx();
195    Start = false;
196    Assert(CurrRowIdx != TTable::Invalid);
197    return *this;
198  }
199  bool TRowIteratorWithRemove::operator &lt; (const TRowIteratorWithRemove&amp; RowI) const {
200    if (CurrRowIdx == TTable::Last) { return false; }
201    if (RowI.CurrRowIdx == TTable::Last) { return true; }
202    return CurrRowIdx &lt; RowI.CurrRowIdx;
203  }
204  bool TRowIteratorWithRemove::operator == (const TRowIteratorWithRemove&amp; RowI) const {
205    return CurrRowIdx == RowI.CurrRowIdx;
206  }
207  TInt TRowIteratorWithRemove::GetRowIdx() const {
208    return CurrRowIdx;
209  }
210  TInt TRowIteratorWithRemove::GetNextRowIdx() const {
211    return (Start ? Table-&gt;FirstValidRow : Table-&gt;Next[CurrRowIdx]);
212  }
213  TInt TRowIteratorWithRemove::GetNextIntAttr(TInt ColIdx) const {
214    return Table-&gt;IntCols[ColIdx][GetNextRowIdx()];
215  }
216  TFlt TRowIteratorWithRemove::GetNextFltAttr(TInt ColIdx) const {
217    return Table-&gt;FltCols[ColIdx][GetNextRowIdx()];
218  }
219  TStr TRowIteratorWithRemove::GetNextStrAttr(TInt ColIdx) const {
220    return Table-&gt;GetStrValIdx(ColIdx, GetNextRowIdx());
221  }
222  TInt TRowIteratorWithRemove::GetNextIntAttr(const TStr&amp; Col) const {
223    TInt ColIdx = Table-&gt;GetColIdx(Col);
224    return Table-&gt;IntCols[ColIdx][GetNextRowIdx()];
225  }
226  TFlt TRowIteratorWithRemove::GetNextFltAttr(const TStr&amp; Col) const {
227    TInt ColIdx = Table-&gt;GetColIdx(Col);
228    return Table-&gt;FltCols[ColIdx][GetNextRowIdx()];
229  }
230  TStr TRowIteratorWithRemove::GetNextStrAttr(const TStr&amp; Col) const {
231    return Table-&gt;GetStrVal(Col, GetNextRowIdx());
232  }
233  TBool TRowIteratorWithRemove::IsFirst() const {
234    return CurrRowIdx == Table-&gt;FirstValidRow;
235  }
236  void TRowIteratorWithRemove::RemoveNext() {
237    Table-&gt;RemoveRow(GetNextRowIdx(), CurrRowIdx);
238  }
239  TBool TRowIteratorWithRemove::CompareAtomicConst(TInt ColIdx, const TPrimitive&amp; Val, TPredComp Cmp) {
240    TBool Result;
241    switch (Val.GetType()) {
242      case atInt:
243        Result = TPredicate::EvalAtom(GetNextIntAttr(ColIdx), Val.GetInt(), Cmp);
244        break;
245      case atFlt:
246        Result = TPredicate::EvalAtom(GetNextFltAttr(ColIdx), Val.GetFlt(), Cmp);
247        break;
248      case atStr:
249        Result = TPredicate::EvalStrAtom(GetNextStrAttr(ColIdx), Val.GetStr(), Cmp);
250        break;
251      default:
252        Result = TBool(false);
253    }
254    return Result;
255  }
256  TTable::TTable(): Context(new TTableContext), NumRows(0), NumValidRows(0),
257    FirstValidRow(0), LastValidRow(-1) {}
258  TTable::TTable(TTableContext* Context): Context(Context), NumRows(0),
259    NumValidRows(0), FirstValidRow(0), LastValidRow(-1) {}
260  TTable::TTable(const Schema&amp; TableSchema, TTableContext* Context): Context(Context), 
261    NumRows(0), NumValidRows(0), FirstValidRow(0), LastValidRow(-1), IsNextDirty(0) {
262    TInt IntColCnt = 0;
263    TInt FltColCnt = 0;
264    TInt StrColCnt = 0;
265    for (TInt i = 0; i &lt; TableSchema.Len(); i++) {
266      TStr ColName = TableSchema[i].Val1;
267      TAttrType ColType = TableSchema[i].Val2;
268      AddSchemaCol(ColName, ColType);
269      switch (ColType) {
270        case atInt:
271          AddColType(ColName, atInt, IntColCnt);
272          IntColCnt++;
273          break;
274        case atFlt:
275          AddColType(ColName, atFlt, FltColCnt);
276          FltColCnt++;
277          break;
278        case atStr:
279          AddColType(ColName, atStr, StrColCnt);
280          StrColCnt++;
281          break;
282      }
283    }
284    IntCols = TVec&lt;TIntV&gt;(IntColCnt);
285    FltCols = TVec&lt;TFltV&gt;(FltColCnt);
286    StrColMaps = TVec&lt;TIntV&gt;(StrColCnt);
287  }
288  void TTable::GenerateColTypeMap(THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; &amp; ColTypeIntMap) {
289    ColTypeMap.Clr();
290    Sch.Clr();
291    for (THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt;::TIter it = ColTypeIntMap.BegI(); it &lt; ColTypeIntMap.EndI(); it++) {
292      TPair&lt;TInt,TInt&gt; dat = it.GetDat();
293      switch (dat.GetVal1()) {
294        case 0:
295          AddColType(it.GetKey(), atInt, dat.GetVal2());
296          AddSchemaCol(it.GetKey(), atInt);
297          break;
298        case 1:
299          AddColType(it.GetKey(), atFlt, dat.GetVal2());
300          AddSchemaCol(it.GetKey(), atFlt);
301          break;
302        case 2:
303          AddColType(it.GetKey(), atStr, dat.GetVal2());
304          AddSchemaCol(it.GetKey(), atStr);
305          break;
306      }
307    }
308    IsNextDirty = 0;
309  }
310  void TTable::LoadTableShM(TShMIn&amp; ShMIn, TTableContext* ContextTable) {
311    Context = ContextTable;
312    NumRows = TInt(ShMIn);
313    NumValidRows = TInt(ShMIn);
314    FirstValidRow = TInt(ShMIn);
315    LastValidRow = TInt(ShMIn);
316    Next.LoadShM(ShMIn);
317    TLoadVecInit Fn;
318    IntCols.LoadShM(ShMIn, Fn);
319    FltCols.Load(ShMIn);
320    StrColMaps.LoadShM(ShMIn, Fn);
321    THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; ColTypeIntMap;
322    ColTypeIntMap.LoadShM(ShMIn);
323    GenerateColTypeMap(ColTypeIntMap);
324  }
325  TTable::TTable(TSIn&amp; SIn, TTableContext* Context): Context(Context), NumRows(SIn),
326    NumValidRows(SIn), FirstValidRow(SIn), LastValidRow(SIn), Next(SIn), IntCols(SIn),
327    FltCols(SIn), StrColMaps(SIn) {
328    THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; ColTypeIntMap(SIn);
329    GenerateColTypeMap(ColTypeIntMap);
330  }
331  TTable::TTable(const TIntIntH&amp; H, const TStr&amp; Col1, const TStr&amp; Col2,
332   TTableContext* Context, const TBool IsStrKeys) : Context(Context), NumRows(H.Len()),
333    NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
334      TAttrType KeyType = IsStrKeys ? atStr : atInt;
335      AddSchemaCol(Col1, KeyType);
336      AddSchemaCol(Col2, atInt);
337      AddColType(Col1, KeyType, 0);
338      AddColType(Col2, atInt, 1);
339      if (IsStrKeys) {
340        StrColMaps = TVec&lt;TIntV&gt;(1);
341        IntCols = TVec&lt;TIntV&gt;(1);
342        H.GetKeyV(StrColMaps[0]);
343        H.GetDatV(IntCols[0]);
344      } else {
345        IntCols = TVec&lt;TIntV&gt;(2);
346        H.GetKeyV(IntCols[0]);
347        H.GetDatV(IntCols[1]);
348      }
349      Next = TIntV(NumRows);
350      for (TInt i = 0; i &lt; NumRows; i++) {
351        Next[i] = i+1;
352      }
353      Next[NumRows-1] = Last;
354      IsNextDirty = 0;
355      InitIds();
356  }
357  TTable::TTable(const TIntFltH&amp; H, const TStr&amp; Col1, const TStr&amp; Col2,
358   TTableContext* Context, const TBool IsStrKeys) : Context(Context),
359    NumRows(H.Len()), NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
360    TAttrType KeyType = IsStrKeys ? atStr : atInt;
361    AddSchemaCol(Col1, KeyType);
362    AddSchemaCol(Col2, atFlt);
363    AddColType(Col1, KeyType, 0);
364    AddColType(Col2, atFlt, 0);
365    if (IsStrKeys) {
366      StrColMaps = TVec&lt;TIntV&gt;(1);
367      H.GetKeyV(StrColMaps[0]);
368    } else {
369      IntCols = TVec&lt;TIntV&gt;(1);
370      H.GetKeyV(IntCols[0]);
371    }
372    FltCols = TVec&lt;TFltV&gt;(1);
373    H.GetDatV(FltCols[0]);
374    Next = TIntV(NumRows);
375    for (TInt i = 0; i &lt; NumRows; i++) {
376      Next[i] = i+1;
377    }
378    Next[NumRows-1] = Last;
379    IsNextDirty = 0;
380    InitIds();
381  }
382  TTable::TTable(const TTable&amp; Table, const TIntV&amp; RowIDs) : Context(Table.Context),
383    Sch(Table.Sch), SrcCol(Table.SrcCol), DstCol(Table.DstCol), EdgeAttrV(Table.EdgeAttrV),
384    SrcNodeAttrV(Table.SrcNodeAttrV), DstNodeAttrV(Table.DstNodeAttrV),
385    CommonNodeAttrs(Table.CommonNodeAttrs) {
386    ColTypeMap = Table.ColTypeMap;
387    IntCols = TVec&lt;TIntV&gt;(Table.IntCols.Len());
388    FltCols = TVec&lt;TFltV&gt;(Table.FltCols.Len());
389    StrColMaps = TVec&lt;TIntV&gt;(Table.StrColMaps.Len());
390    FirstValidRow = 0;
391    LastValidRow = -1;
392    NumRows = 0;
393    NumValidRows = 0;
394    AddSelectedRows(Table, RowIDs);
395    IsNextDirty = 0;
396    InitIds();
397  }
398  void TTable::GetSchema(const TStr&amp; InFNm, Schema&amp; S, const char&amp; Separator) {
399    TSsParser Ss(InFNm, &#x27;\t&#x27;, false, false, false);
400    TInt rowsToPeek = 1000;
401    TInt currRow = 0;
402    TInt lastComment = 0;
403    while (Ss.Next()) {
404      if (Ss.IsCmt()) {
405        lastComment += 1;
406      }
407      else break;
408    }
409    if (Ss.Eof()) {TExcept::Throw(&quot;No Data to determine attribute types!&quot;);}
410    TInt numCols = Ss.GetFlds();
411    TVec&lt;TAttrType&gt; colAttrV(numCols);
412    colAttrV.PutAll(atInt);
413    while (true) {
414      for (TInt i = 0; i &lt; numCols; i++) {
415        if (Ss.IsInt(i)) {
416        }
417        else if (Ss.IsFlt(i)) {
418          colAttrV[i] = atFlt;
419        }
420        else {
421          colAttrV[i] = atStr;
422        }
423      }
424      currRow++;
425      if (currRow &gt; rowsToPeek || Ss.Eof()) break;
426      Ss.Next();
427    }
428    TSsParser SsNames(InFNm, Separator, false, false, false);
429    for (int i = 0; i &lt; lastComment; i++) { SsNames.Next();}
430    TVec&lt;TStr&gt; attrV;
431    TStr first(SsNames[0]);
432    int begin = 0;
433    TStr comment(&#x27;#&#x27;);
434    if (first != comment) {
435      for (int i = 1; i &lt; first.Len(); i++){
436        if (first[i] != &#x27; &#x27;) { begin = i; break;}
437      }
438      attrV.Add(first.GetSubStr(begin));
439    }
440    for (int i = 1; i &lt; SsNames.GetFlds(); i++) {attrV.Add(SsNames[i]);}
441    for (TInt i = 0; i &lt; numCols; i++) {
442      S.Add(TPair&lt;TStr,TAttrType&gt;(attrV[i],colAttrV[i]));
443    } 
444  }
445  #ifdef GCC_ATOMIC
446  void TTable::LoadSSPar(PTable&amp; T, const Schema&amp; S, const TStr&amp; InFNm, const TIntV&amp; RelevantCols, 
447                          const char&amp; Separator, TBool HasTitleLine) {
448    TInt RowLen = T-&gt;Sch.Len();
449    TVec&lt;TAttrType&gt; ColTypes = TVec&lt;TAttrType&gt;(RowLen);
450    for (TInt i = 0; i &lt; RowLen; i++) {
451      ColTypes[i] = T-&gt;GetSchemaColType(i);
452    }
453    TSsParserMP Ss(InFNm, Separator);
454    Ss.SkipCommentLines();
455    if (HasTitleLine) {
456      Ss.Next();
457      if (S.Len() != Ss.GetFlds()) {
458        printf(&quot;%s\n&quot;, Ss[0]); TExcept::Throw(&quot;Table Schema Mismatch!&quot;);
459      }
460      for (TInt i = 0; i &lt; Ss.GetFlds(); i++) {
461        TInt L = strlen(Ss[i]);
462        if (Ss[i][L-1] &lt; &#x27; &#x27;) { Ss[i][L-1] = 0; }
463        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw(&quot;Table Schema Mismatch!&quot;); }
464      }
465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
469    uint64 Rem = Len - Pos;
470    int NumThreads = omp_get_max_threads();
471    uint64 Delta = Rem / NumThreads;
472    if (Delta &lt; 1) Delta = 1;
473    TVec&lt;uint64&gt; StartIntV(NumThreads);
474    TVec&lt;uint64&gt; LineCountV(NumThreads);
475    TVec&lt;uint64&gt; PrefixSumV(NumThreads);
476    StartIntV[0] = Pos;
477    for (int i = 1; i &lt; NumThreads; i++) {
478      StartIntV[i] = StartIntV[i-1] + Delta;
479    }
480    StartIntV.Add(Len);
481    omp_set_num_threads(NumThreads);
482    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
483    for (int i = 0; i &lt; NumThreads; i++) {
484      LineCountV[i] = Ss.CountNewLinesInRange(StartIntV[i], StartIntV[i+1]);
485      Cnt += LineCountV[i];
486    }
487    PrefixSumV[0] = 0;
488    for (int i = 1; i &lt; NumThreads; i++) {
489      PrefixSumV[i] = PrefixSumV[i-1] + LineCountV[i-1];
490    }
491    Ss.SetStreamPos(Pos);
492    TInt IntColIdx = 0;
493    TInt FltColIdx = 0;
494    for (TInt i = 0; i &lt; RowLen; i++) {
495      switch (ColTypes[i]) {
496        case atInt:
497          T-&gt;IntCols[IntColIdx].Gen(Cnt);
498          IntColIdx++;
499          break;
500        case atFlt:
501          T-&gt;FltCols[FltColIdx].Gen(Cnt);
502          FltColIdx++;
503          break;
504        case atStr:
505          break;
506      }
507    }
508    Cnt = 0;
509    omp_set_num_threads(NumThreads);
510    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
511    for (int i = 0; i &lt; NumThreads; i++) {
512      TVec&lt;uint64&gt; LineStartPosV = Ss.GetStartPosV(StartIntV[i], StartIntV[i+1]);
513      for (uint64 k = 0; k &lt; (uint64) LineStartPosV.Len(); k++) {
514        TVec&lt;char*&gt; FieldsV;
515        Ss.NextFromIndex(LineStartPosV[k], FieldsV);
516        if (FieldsV.Len() != S.Len()) {
517          TExcept::Throw(&quot;Error reading tsv file&quot;);
518        }
519        TInt IntColIdx = 0;
520        TInt FltColIdx = 0;
521        TInt RowIdx = PrefixSumV[i] + k;
522        for (TInt j = 0; j &lt; RowLen; j++) {
523          switch (ColTypes[j]) {
524            case atInt:
525              if (RelevantCols.Len() == 0) {
526                T-&gt;IntCols[IntColIdx][RowIdx] = \
527                  (Ss.GetIntFromFldV(FieldsV, j));
528              } else {
529                T-&gt;IntCols[IntColIdx][RowIdx] = \
530                  (Ss.GetIntFromFldV(FieldsV, RelevantCols[j]));
531              }
532              IntColIdx++;
533              break;
534            case atFlt:
535              if (RelevantCols.Len() == 0) {
536                T-&gt;FltCols[FltColIdx][RowIdx] = \
537                  (Ss.GetFltFromFldV(FieldsV, j));
538              } else {
539                T-&gt;FltCols[FltColIdx][RowIdx] = \
540                  (Ss.GetFltFromFldV(FieldsV, RelevantCols[j]));
541              }
542              FltColIdx++;
543              break;
544            case atStr:
545              TExcept::Throw(&quot;TTable::LoadSS:: Str Col found\n&quot;);
546              break;
547          }
548        }
549        Cnt++;
550      }
551    }
552    T-&gt;NumRows = Cnt;
553    T-&gt;NumValidRows = T-&gt;NumRows;
554    T-&gt;Next.Clr();
555    T-&gt;Next.Gen(Cnt);
556    omp_set_num_threads(NumThreads);
557    #pragma omp parallel for schedule(dynamic, 10000)
558    for (int64 i = 0; i &lt; Cnt-1; i++) {
559      T-&gt;Next[i] = i+1;
560    }
561    T-&gt;IsNextDirty = 0;
562    T-&gt;Next[Cnt-1] = Last;
563    T-&gt;LastValidRow = T-&gt;NumRows - 1;
564    T-&gt;IdColName = &quot;_id&quot;;
565    TInt IdCol = T-&gt;IntCols.Add();
566    T-&gt;IntCols[IdCol].Gen(Cnt);
567    omp_set_num_threads(NumThreads);
568    #pragma omp parallel for schedule(dynamic, 10000)
569    for (int64 i = 0; i &lt; Cnt; i++) {
570      T-&gt;IntCols[IdCol][i] = i;
571    }
572    T-&gt;AddSchemaCol(T-&gt;IdColName, atInt);
573    T-&gt;AddColType(T-&gt;IdColName, atInt, T-&gt;IntCols.Len()-1);
574  }
575  #endif 
576  void TTable::LoadSSSeq(
577   PTable&amp; T, const Schema&amp; S, const TStr&amp; InFNm, const TIntV&amp; RelevantCols,
578   const char&amp; Separator, TBool HasTitleLine) {
579    int RowLen = T-&gt;Sch.Len();
580    TVec&lt;TAttrType&gt; ColTypes = TVec&lt;TAttrType&gt;(RowLen);
581    for (int i = 0; i &lt; RowLen; i++) {
582      ColTypes[i] = T-&gt;GetSchemaColType(i);
583    }
584    TSsParser Ss(InFNm, Separator);
585    if (HasTitleLine) {
586      Ss.Next();
587      if (S.Len() != Ss.GetFlds()) {
588        printf(&quot;%s\n&quot;, Ss[0]); TExcept::Throw(&quot;Table Schema Mismatch!&quot;);
589      }
590      for (int i = 0; i &lt; Ss.GetFlds(); i++) {
591        int L = strlen(Ss[i]);
592        if (Ss[i][L-1] &lt; &#x27; &#x27;) { Ss[i][L-1] = 0; }
593        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw(&quot;Table Schema Mismatch!&quot;); }
594      }
595    }
596    uint64 Cnt = 0;
597    while (Ss.Next()) {
598      int IntColIdx = 0;
599      int FltColIdx = 0;
600      int StrColIdx = 0;
601      Assert(Ss.GetFlds() == S.Len()); 
602      if (Ss.GetFlds() != S.Len()) {
603        printf(&quot;%s\n&quot;, Ss[S.Len()]); TExcept::Throw(&quot;Error reading tsv file&quot;);
604      }
605      for (int i = 0; i &lt; RowLen; i++) {
606        switch (ColTypes[i]) {
607          case atInt:
608            if (RelevantCols.Len() == 0) {
609              T-&gt;IntCols[IntColIdx].Add(Ss.GetInt(i));
610            } else {
611              T-&gt;IntCols[IntColIdx].Add(Ss.GetInt(RelevantCols[i]));
612            }
613            IntColIdx++;
614            break;
615          case atFlt:
616            if (RelevantCols.Len() == 0) {
617              T-&gt;FltCols[FltColIdx].Add(Ss.GetFlt(i));
618            } else {
619              T-&gt;FltCols[FltColIdx].Add(Ss.GetFlt(RelevantCols[i]));
620            }
621            FltColIdx++;
622            break;
623          case atStr:
624            int ColIdx;
625            if (RelevantCols.Len() == 0) {
626              ColIdx = i;
627            } else {
628              ColIdx = RelevantCols[i];
629            }
630            TStr Sval = TStr(Ss[ColIdx]);
631            T-&gt;AddStrVal(StrColIdx, Sval);
632            StrColIdx++;
633            break;
634        }
635      }
636      Cnt += 1;
637    }
638    T-&gt;NumRows = static_cast&lt;int&gt;(Cnt);
639    T-&gt;NumValidRows = T-&gt;NumRows;
640    T-&gt;Next.Clr();
641    T-&gt;Next.Gen(static_cast&lt;int&gt;(Cnt));
642    for (uint64 i = 0; i &lt; Cnt-1; i++) {
643      T-&gt;Next[static_cast&lt;int&gt;(i)] = static_cast&lt;int&gt;(i+1);
644    }
645    T-&gt;IsNextDirty = 0;
646    T-&gt;Next[static_cast&lt;int&gt;(Cnt-1)] = Last;
647    T-&gt;LastValidRow = T-&gt;NumRows - 1;
648    T-&gt;InitIds();
649  }
650  PTable TTable::LoadSS(const Schema&amp; S, const TStr&amp; InFNm, TTableContext* Context,
651   const TIntV&amp; RelevantCols, const char&amp; Separator, TBool HasTitleLine) {
652    TVec&lt;uint64&gt; IntGroupByCols;
653    bool NoStringCols = true;
654    Schema SR;
655    if (RelevantCols.Len() == 0) {
656      SR = S;
657    } else {
658      for (int i = 0; i &lt; RelevantCols.Len(); i++) {
659        SR.Add(S[RelevantCols[i]]);
660      }
661    }
662    PTable T = New(SR, Context);
663    for (int i = 0; i &lt; SR.Len(); i++) {
664      if (T-&gt;GetSchemaColType(i) == atStr) {
665        NoStringCols = false;
666        break;
667      }
668    }
669    if (GetMP() &amp;&amp; NoStringCols) {
670  #ifdef GLib_LINUX
671      LoadSSPar(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
672  #else
673      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
674  #endif
675    } else {
676      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
677    }
678    return T;
679  }
680  PTable TTable::LoadSS(const Schema&amp; S, const TStr&amp; InFNm, TTableContext* Context,
681   const char&amp; Separator, TBool HasTitleLine) {
682    return LoadSS(S, InFNm, Context, TIntV(), Separator, HasTitleLine);
683  }
684  void TTable::SaveSS(const TStr&amp; OutFNm) {
685    if (NumValidRows == 0) {
686      printf(&quot;Table is empty&quot;);
687      return;
688    }
689    FILE* F = fopen(OutFNm.CStr(), &quot;w&quot;);
690    if (F == NULL) {
691      printf(&quot;failed to open file %s\n&quot;, OutFNm.CStr());
692      perror(&quot;fail &quot;);
693      return;
694    }
695    Dump(F);
696  #if 0
697    Schema DSch = DenormalizeSchema();
698    TInt L = Sch.Len();
699    fprintf(F, &quot;# &quot;);
700    for (TInt i = 0; i &lt; L-1; i++) {
701      fprintf(F, &quot;%s\t&quot;, DSch[i].Val1.CStr());
702    }  
703    fprintf(F, &quot;%s\n&quot;, DSch[L-1].Val1.CStr());
704    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
705      for (TInt i = 0; i &lt; L; i++) {
706        char C = (i == L-1) ? &#x27;\n&#x27; : &#x27;\t&#x27;;
707        switch (GetSchemaColType(i)) {
708          case atInt: {
709            fprintf(F, &quot;%d%c&quot;, RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
710            break;
711          }
712          case atFlt: {
713            fprintf(F, &quot;%f%c&quot;, RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
714            break;
715          }
716          case atStr: {
717            fprintf(F, &quot;%s%c&quot;, RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
718            break;
719          }
720        }
721      }
722    }
723  #endif
724    fclose(F);
725  }
726  void TTable::SaveBin(const TStr&amp; OutFNm) {
727    TFOut SOut(OutFNm);
728    Save(SOut);
729  }
730  void TTable::Save(TSOut&amp; SOut) {
731    NumRows.Save(SOut);
732    NumValidRows.Save(SOut);
733    FirstValidRow.Save(SOut);
734    LastValidRow.Save(SOut);
735    Next.Save(SOut);
736    IntCols.Save(SOut);
737    FltCols.Save(SOut);
738    StrColMaps.Save(SOut);
739    THash&lt;TStr,TPair&lt;TInt,TInt&gt; &gt; ColTypeIntMap;
740    TInt atIntVal = TInt(0);
741    TInt atFltVal = TInt(1);
742    TInt atStrVal = TInt(2);
743    for (THash&lt;TStr,TPair&lt;TAttrType,TInt&gt; &gt;::TIter it = ColTypeMap.BegI(); it &lt; ColTypeMap.EndI(); it++) {
744      TPair&lt;TAttrType,TInt&gt; dat = it.GetDat();
745      TStr DColName = DenormalizeColName(it.GetKey());
746      switch (dat.GetVal1()) {
747        case atInt:
748          ColTypeIntMap.AddDat(DColName, TPair&lt;TInt,TInt&gt;(atIntVal, dat.GetVal2()));
749          break;
750        case atFlt:
751          ColTypeIntMap.AddDat(DColName, TPair&lt;TInt,TInt&gt;(atFltVal, dat.GetVal2()));
752          break;
753        case atStr:
754          ColTypeIntMap.AddDat(DColName, TPair&lt;TInt,TInt&gt;(atStrVal, dat.GetVal2()));
755          break;
756      }
757    }
758    ColTypeIntMap.Save(SOut);
759    SOut.Flush();
760  }
761  void TTable::Dump(FILE *OutF) const {
762    TInt L = Sch.Len();
763    Schema DSch = DenormalizeSchema();
764    fprintf(OutF, &quot;# &quot;);
765    for (TInt i = 0; i &lt; L-1; i++) {
766      fprintf(OutF, &quot;%s\t&quot;, DSch[i].Val1.CStr());
767    }  
768    fprintf(OutF, &quot;%s\n&quot;, DSch[L-1].Val1.CStr());
769    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
770      for (TInt i = 0; i &lt; L; i++) {
771        char C = (i == L-1) ? &#x27;\n&#x27; : &#x27;\t&#x27;;
772        switch (GetSchemaColType(i)) {
773          case atInt: {
774            fprintf(OutF, &quot;%d%c&quot;, RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
775            break;
776          }
777          case atFlt: {
778            fprintf(OutF, &quot;%f%c&quot;, RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
779            break;
780          }
781          case atStr: {
782            fprintf(OutF, &quot;%s%c&quot;, RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
783            break;
784          }
785        }
786      }
787    }
788  }
789  TTableContext* TTable::ChangeContext(TTableContext* NewContext) {
790    TInt L = Sch.Len();
791  #if 0
792    for (TInt i = 0; i &lt; L; i++) {
793      if (GetSchemaColType(i) != atStr) {
794        continue;
795      }
796      TInt ColIdx = GetColIdx(GetSchemaColName(i));
797      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
798        TInt RowIdx = RowI.GetRowIdx();
799        TInt KeyId = StrColMaps[ColIdx][RowIdx];
800        printf(&quot;ChangeContext in  %d  %d  %d  .%s.\n&quot;,
801            ColIdx.Val, RowIdx.Val, KeyId.Val, GetStrVal(ColIdx, RowIdx).CStr());
802      }
803    }
804  #endif
805    for (TInt i = 0; i &lt; L; i++) {
806      if (GetSchemaColType(i) != atStr) {
807        continue;
808      }
809      TInt ColIdx = GetColIdx(GetSchemaColName(i));
810      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
811        TInt RowIdx = RowI.GetRowIdx();
812        TStr Key = GetStrValIdx(ColIdx, RowIdx);
813        TInt KeyId = TInt(NewContext-&gt;StringVals.AddKey(Key));
814        StrColMaps[ColIdx][RowIdx] = KeyId;
815      }
816    }
817    Context = NewContext;
818    return Context;
819  }
820  void TTable::AddStrVal(const TInt&amp; ColIdx, const TStr&amp; Key) {
821    TInt KeyId = TInt(Context-&gt;StringVals.AddKey(Key));
822    StrColMaps[ColIdx].Add(KeyId);
823  }
824  void TTable::AddStrVal(const TStr&amp; Col, const TStr&amp; Key) {
825    if (GetColType(Col) != atStr) {
826      TExcept::Throw(Col + &quot; is not a string valued column&quot;);
827    }
828    AddStrVal(GetColIdx(Col), Key);
829  }
830  void TTable::AddGraphAttribute(const TStr&amp; Attr, TBool IsEdge, TBool IsSrc, TBool IsDst) {
831    if (!IsColName(Attr)) { TExcept::Throw(Attr + &quot;: No such column&quot;); }
832    if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attr)); }
833    if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attr)); }
834    if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attr)); }
835  }
836  void TTable::AddGraphAttributeV(TStrV&amp; Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst) {
837    for (TInt i = 0; i &lt; Attrs.Len(); i++) {
838      if (!IsColName(Attrs[i])) {
839        TExcept::Throw(Attrs[i] + &quot;: no such column&quot;);
840      }
841    }
842    for (TInt i = 0; i &lt; Attrs.Len(); i++) {
843      if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attrs[i])); }
844      if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attrs[i])); }
845      if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attrs[i])); }
846    }
847  }
848  TStrV TTable::GetSrcNodeIntAttrV() const {
849    TStrV IntNA = TStrV(IntCols.Len(),0);
850    for (TInt i = 0; i &lt; SrcNodeAttrV.Len(); i++) {
851      TStr Attr = SrcNodeAttrV[i];
852      if (GetColType(Attr) == atInt) {
853        IntNA.Add(Attr);
854      }
855    }
856    return IntNA;
857  }
858  TStrV TTable::GetDstNodeIntAttrV() const {
859    TStrV IntNA = TStrV(IntCols.Len(),0);
860    for (TInt i = 0; i &lt; DstNodeAttrV.Len(); i++) {
861      TStr Attr = DstNodeAttrV[i];
862      if (GetColType(Attr) == atInt) {
863        IntNA.Add(Attr);
864      }
865    }
866    return IntNA;
867  }
868  TStrV TTable::GetEdgeIntAttrV() const {
869    TStrV IntEA = TStrV(IntCols.Len(),0);
870    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
871      TStr Attr = EdgeAttrV[i];
872      if (GetColType(Attr) == atInt) {
873        IntEA.Add(Attr);
874      }
875    }
876    return IntEA;
877  }
878  TStrV TTable::GetSrcNodeFltAttrV() const {
879    TStrV FltNA = TStrV(FltCols.Len(),0);
880    for (TInt i = 0; i &lt; SrcNodeAttrV.Len(); i++) {
881      TStr Attr = SrcNodeAttrV[i];
882      if (GetColType(Attr) == atFlt) {
883        FltNA.Add(Attr);
884      }
885    }
886    return FltNA;
887  }
888  TStrV TTable::GetDstNodeFltAttrV() const {
889    TStrV FltNA = TStrV(FltCols.Len(),0);
890    for (TInt i = 0; i &lt; DstNodeAttrV.Len(); i++) {
891      TStr Attr = DstNodeAttrV[i];
892      if (GetColType(Attr) == atFlt) {
893        FltNA.Add(Attr);
894      }
895    }
896    return FltNA;
897  }
898  TStrV TTable::GetEdgeFltAttrV() const {
899    TStrV FltEA = TStrV(FltCols.Len(),0);;
900    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
901      TStr Attr = EdgeAttrV[i];
902      if (GetColType(Attr) == atFlt) {
903        FltEA.Add(Attr);
904      }
905    }
906    return FltEA;
907  }
908  TStrV TTable::GetSrcNodeStrAttrV() const {
909    TStrV StrNA = TStrV(StrColMaps.Len(),0);
910    for (TInt i = 0; i &lt; SrcNodeAttrV.Len(); i++) {
911      TStr Attr = SrcNodeAttrV[i];
912      if (GetColType(Attr) == atStr) {
913        StrNA.Add(Attr);
914      }
915    }
916    return StrNA;
917  }
918  TStrV TTable::GetDstNodeStrAttrV() const {
919    TStrV StrNA = TStrV(StrColMaps.Len(),0);
920    for (TInt i = 0; i &lt; DstNodeAttrV.Len(); i++) {
921      TStr Attr = DstNodeAttrV[i];
922      if (GetColType(Attr) == atStr) {
923        StrNA.Add(Attr);
924      }
925    }
926    return StrNA;
927  }
928  TStrV TTable::GetEdgeStrAttrV() const {
929    TStrV StrEA = TStrV(StrColMaps.Len(),0);
930    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
931      TStr Attr = EdgeAttrV[i];
932      if (GetColType(Attr) == atStr) {
933        StrEA.Add(Attr);
934      }
935    }
936    return StrEA;
937  }
938  void TTable::Rename(const TStr&amp; column, const TStr&amp; NewLabel) {
939    if (!IsColName(column)) { TExcept::Throw(&quot;no such column &quot; + column); }
940    TPair&lt;TAttrType,TInt&gt; ColVal = GetColTypeMap(column);
941    DelColType(column);
942    AddColType(NewLabel, ColVal);
943    TStr NColName = NormalizeColName(column);
944    TStr NLabel = NormalizeColName(NewLabel);
945    for (TInt c = 0; c &lt; Sch.Len(); c++) {
946      if (Sch[c].Val1 == NColName) {
947        Sch.SetVal(c, TPair&lt;TStr, TAttrType&gt;(NLabel, Sch[c].Val2));
948        break;
949      }
950    }
951  }
952  void TTable::RemoveFirstRow() {
953    if (FirstValidRow == LastValidRow) {
954      LastValidRow = -1;
955    }
956    TInt Old = FirstValidRow;
957    FirstValidRow = Next[FirstValidRow];
958    Next[Old] = TTable::Invalid;
959    NumValidRows--;
960    TInt IdColIdx = GetColIdx(GetIdColName());
961    RowIdMap.AddDat(IntCols[IdColIdx][Old], Invalid);
962  }
963  void TTable::RemoveRow(TInt RowIdx, TInt PrevRowIdx) {
964    if (RowIdx == FirstValidRow) {
965      RemoveFirstRow();
966      return;
967    }
968    Assert(RowIdx != TTable::Invalid);
969    if (RowIdx == TTable::Last) { return; }
970    Next[PrevRowIdx] = Next[RowIdx];
971    if (LastValidRow == RowIdx) {
972      LastValidRow = RowIdx;
973    }
974    Next[RowIdx] = TTable::Invalid;
975    NumValidRows--;
976    TInt IdColIdx = GetColIdx(GetIdColName());
977    RowIdMap.AddDat(IntCols[IdColIdx][RowIdx], Invalid);
978  }
979  void TTable::KeepSortedRows(const TIntV&amp; KeepV) {
980    TIntIntH KeepH(KeepV.Len());
981    for (TInt i = 0; i &lt; KeepV.Len(); i++) {
982      KeepH.AddKey(KeepV[i]);
983    }
984    TRowIteratorWithRemove RowI = BegRIWR();
985    TInt KeepSize = 0;
986    while (RowI.GetNextRowIdx() != Last) {
987      if (KeepSize &lt; KeepV.Len()) {
988        if (KeepH.IsKey(RowI.GetNextRowIdx())) {
989          KeepSize++;
990          RowI++;
991        } else {
992          RowI.RemoveNext();
993        }
994      } else {
995        RowI.RemoveNext();
996      }
997    }
998    LastValidRow = KeepV[KeepV.Len()-1];
999  }
1000  void TTable::GetPartitionRanges(TIntPrV&amp; Partitions, TInt NumPartitions) const {
1001    TInt PartitionSize = NumValidRows / (NumPartitions);
1002    if (NumValidRows % NumPartitions != 0) PartitionSize++;
1003    if (PartitionSize &lt; 10) { 
1004      PartitionSize = 10;
1005      NumPartitions = NumValidRows / PartitionSize; 
1006    }
1007    Partitions.Reserve(NumPartitions+1);
1008    TInt currRow = FirstValidRow;
1009    TInt currStart = currRow;
1010    if (IsNextDirty) {
1011      TInt currCount = PartitionSize;
1012      while (currRow != TTable::Last) {
1013        if (currCount == 0) {
1014          Partitions.Add(TIntPr(currStart, currRow));
1015          currStart = currRow;
1016          currCount = PartitionSize;
1017        }
1018        currRow = Next[currRow];
1019        currCount--;
1020      }
1021      Partitions.Add(TIntPr(currStart, currRow));
1022    } else {
1023      currRow += PartitionSize;
1024      while (currRow != TTable::Last &amp;&amp; currRow &lt; Next.Len()) {
1025        if (Next[currRow] == TTable::Invalid) { currRow++; continue; }
1026        Partitions.Add(TIntPr(currStart, currRow));
1027        currStart = currRow;
1028        currRow += PartitionSize;
1029      }
1030      Partitions.Add(TIntPr(currStart, TTable::Last));
1031    }
1032  }
1033  void TTable::GroupingSanityCheck(const TStr&amp; GroupBy, const TAttrType&amp; AttrType) const {
1034    if (!IsColName(GroupBy)) {
1035      TExcept::Throw(&quot;no such column &quot; + GroupBy);
1036    }
1037    if (GetColType(GroupBy) != AttrType) {
1038      TExcept::Throw(GroupBy + &quot; values are not of expected type&quot;);
1039    }
1040  }
1041  #ifdef GCC_ATOMIC
1042  void TTable::GroupByIntColMP(const TStr&amp; GroupBy, THashMP&lt;TInt, TIntV&gt;&amp; Grouping, TBool UsePhysicalIds) const {
1043    timeval timer0;
1044    gettimeofday(&amp;timer0, NULL);
1045    TInt IdColIdx = GetColIdx(IdColName);
1046    TInt GroupByColIdx = GetColIdx(GroupBy);
1047    if(!UsePhysicalIds &amp;&amp; IdColIdx &lt; 0){
1048    	TExcept::Throw(&quot;Grouping: Either use physical row ids, or have an id column&quot;);
1049    }
1050    GroupingSanityCheck(GroupBy, atInt);
1051    TIntPrV Partitions;
1052    GetPartitionRanges(Partitions, 8*CHUNKS_PER_THREAD);
1053    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1054    Grouping.Gen(NumValidRows);
1055    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1056    for (int i = 0; i &lt; Partitions.Len(); i++){
1057      TRowIterator RowI(Partitions[i].GetVal1(), this);
1058      TRowIterator EndI(Partitions[i].GetVal2(), this);
1059      while (RowI &lt; EndI) {
1060        TInt idx = UsePhysicalIds ? RowI.GetRowIdx() : RowI.GetIntAttr(IdColIdx);
1061        UpdateGrouping&lt;TInt&gt;(Grouping, RowI.GetIntAttr(GroupByColIdx), idx);
1062        RowI++;
1063      }
1064    }
1065    gettimeofday(&amp;timer0, NULL);
1066  }
1067  #endif 
1068  void TTable::Unique(const TStr&amp; Col) {
1069    TIntV RemainingRows;
1070    TStr NCol = NormalizeColName(Col);
1071    switch (GetColType(NCol)) {
1072      case atInt: {
1073        TIntIntVH Grouping;
1074        GroupByIntCol(NCol, Grouping, TIntV(), true, true);
1075        for (TIntIntVH::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1076          RemainingRows.Add(it-&gt;Dat[0]);
1077        }
1078        break;
1079      }
1080      case atFlt: {
1081        THash&lt;TFlt,TIntV&gt; Grouping;
1082        GroupByFltCol(NCol, Grouping, TIntV(), true, true);
1083        for (THash&lt;TFlt,TIntV&gt;::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1084          RemainingRows.Add(it-&gt;Dat[0]);
1085        }
1086        break;
1087      } 
1088      case atStr: {
1089        TIntIntVH Grouping;
1090        GroupByStrCol(NCol, Grouping, TIntV(), true, true);
1091        for (TIntIntVH::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1092          RemainingRows.Add(it-&gt;Dat[0]);
1093        }
1094        break;
1095      }
1096    }
1097    KeepSortedRows(RemainingRows);
1098  }
1099  void TTable::Unique(const TStrV&amp; Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
1105    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Grouping;
1106    TIntV UniqueVec;
1107    GroupAux(NCols, Grouping, Ordered, &quot;&quot;, true, UniqueVec, true);
1108    KeepSortedRows(UniqueVec);
1109  }
1110  void TTable::StoreGroupCol(const TStr&amp; GroupColName, const TVec&lt;TPair&lt;TInt, TInt&gt; &gt;&amp; GroupAndRowIds) {
1111    IntCols.Add(TIntV(NumRows));
1112    TInt L = IntCols.Len();
1113    AddColType(GroupColName, atInt, L-1);
1114    for (TInt i = 0; i &lt; GroupAndRowIds.Len(); i++) {
1115      IntCols[L-1][GroupAndRowIds[i].Val2] = GroupAndRowIds[i].Val1;
1116    }
1117  }
1118  void TTable::GroupAux(const TStrV&amp; GroupBy, THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;&amp; Grouping, 
1119   TBool Ordered, const TStr&amp; GroupColName, TBool KeepUnique, TIntV&amp; UniqueVec, TBool UsePhysicalIds) {
1120    TInt IdColIdx = GetColIdx(IdColName);
1121    if(!UsePhysicalIds &amp;&amp; IdColIdx &lt; 0){
1122    	TExcept::Throw(&quot;Grouping: Either use physical row ids, or have an id column&quot;);
1123    }
1124    TIntV IntGroupByCols;
1125    TIntV FltGroupByCols;
1126    TIntV StrGroupByCols;
1127    for (TInt c = 0; c &lt; GroupBy.Len(); c++) {
1128      if (!IsColName(GroupBy[c])) { 
1129        TExcept::Throw(&quot;no such column &quot; + GroupBy[c]); 
1130      }
1131      TPair&lt;TAttrType, TInt&gt; ColType = GetColTypeMap(GroupBy[c]);
1132      switch (ColType.Val1) {
1133        case atInt:
1134          IntGroupByCols.Add(ColType.Val2);
1135          break;
1136        case atFlt:
1137          FltGroupByCols.Add(ColType.Val2);
1138          break;
1139        case atStr:
1140          StrGroupByCols.Add(ColType.Val2);
1141          break;
1142      }
1143    }
1144    TInt IKLen = IntGroupByCols.Len();
1145    TInt FKLen = FltGroupByCols.Len();
1146    TInt SKLen = StrGroupByCols.Len();
1147    TInt GroupNum = 0;
1148    TVec&lt;TPair&lt;TInt, TInt&gt; &gt; GroupAndRowIds;
1149    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
1150      TIntV IKey(IKLen + SKLen, 0);
1151      TFltV FKey(FKLen, 0);
1152      TIntV SKey(SKLen, 0);
1153      for (TInt c = 0; c &lt; IKLen; c++) {
1154        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
1155      }
1156      for (TInt c = 0; c &lt; FKLen; c++) {
1157        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
1158      }
1159      for (TInt c = 0; c &lt; SKLen; c++) {
1160        SKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
1161      }
1162      if (!Ordered) {
1163        if (IKLen &gt; 0) { IKey.ISort(0, IKey.Len()-1, true); }
1164        if (FKLen &gt; 0) { FKey.ISort(0, FKey.Len()-1, true); }
1165        if (SKLen &gt; 0) { SKey.ISort(0, SKey.Len()-1, true); }
1166      }
1167      for (TInt c = 0; c &lt; SKLen; c++) {
1168        IKey.Add(SKey[c]);
1169      }
1170      TGroupKey GroupKey = TGroupKey(IKey, FKey);
1171      TInt RowIdx = it.GetRowIdx();
1172      TInt idx = UsePhysicalIds ? it.GetRowIdx() : IntCols[IdColIdx][it.GetRowIdx()];
1173      if (!Grouping.IsKey(GroupKey)) {
1174        TPair&lt;TInt, TIntV&gt; NewGroup;
1175        NewGroup.Val1 = GroupNum;
1176        NewGroup.Val2.Add(idx);
1177        Grouping.AddDat(GroupKey, NewGroup);
1178        if (GroupColName != &quot;&quot;) {
1179          GroupAndRowIds.Add(TPair&lt;TInt, TInt&gt;(GroupNum, RowIdx));
1180        }
1181        if (KeepUnique) { 
1182          UniqueVec.Add(idx);
1183        }
1184        GroupNum++;
1185      } else {
1186        if (!KeepUnique) {
1187          TPair&lt;TInt, TIntV&gt;&amp; NewGroup = Grouping.GetDat(GroupKey);
1188          NewGroup.Val2.Add(idx);
1189          if (GroupColName != &quot;&quot;) {
1190            GroupAndRowIds.Add(TPair&lt;TInt, TInt&gt;(NewGroup.Val1, RowIdx));
1191          }
1192        }
1193      }
1194    }
1195    if (!KeepUnique) {
1196      GroupStmt Stmt(NormalizeColNameV(GroupBy), Ordered, UsePhysicalIds);
1197      GroupStmtNames.AddDat(GroupColName, Stmt);
1198      GroupIDMapping.AddKey(Stmt);
1199      GroupMapping.AddKey(Stmt);
1200      for (THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it = Grouping.BegI(); it &lt; Grouping.EndI(); it++) {
1201        TGroupKey key = it.GetKey();
1202        TPair&lt;TInt, TIntV&gt; group = it.GetDat();
1203        GroupIDMapping.GetDat(Stmt).AddDat(group.Val1, TGroupKey(key));
1204        GroupMapping.GetDat(Stmt).AddDat(TGroupKey(key), TIntV(group.Val2));
1205      }
1206    }
1207    if (GroupColName != &quot;&quot;) {
1208      StoreGroupCol(GroupColName, GroupAndRowIds);
1209      AddSchemaCol(GroupColName, atInt);  
1210    }
1211  }
1212  void TTable::Group(const TStrV&amp; GroupBy, const TStr&amp; GroupColName, TBool Ordered, TBool UsePhysicalIds) {
1213    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1214    TStr NGroupColName = NormalizeColName(GroupColName);
1215    TIntV UniqueVec;
1216    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Grouping;
1217    GroupAux(NGroupBy, Grouping, Ordered, NGroupColName, false, UniqueVec, UsePhysicalIds);
1218  }
1219  void TTable::InvalidatePhysicalGroupings(){
1220  }
1221  void TTable::InvalidateAffectedGroupings(const TStr&amp; Attr){
1222  }
1223  void TTable::Aggregate(const TStrV&amp; GroupByAttrs, TAttrAggr AggOp,
1224   const TStr&amp; ValAttr, const TStr&amp; ResAttr, TBool Ordered) {
1225     for (TInt c = 0; c &lt; GroupByAttrs.Len(); c++) {
1226      if (!IsColName(GroupByAttrs[c])) { 
1227        TExcept::Throw(&quot;no such column &quot; + GroupByAttrs[c]); 
1228      }
1229     }
1230    TStrV NGroupByAttrs = NormalizeColNameV(GroupByAttrs);
1231    TBool UsePhysicalIds = (GetColIdx(IdColName) &lt; 0);
1232    THash&lt;TInt,TIntV&gt; GroupByIntMapping;
1233    THash&lt;TFlt,TIntV&gt; GroupByFltMapping;
1234    THash&lt;TInt,TIntV&gt; GroupByStrMapping;
1235    THash&lt;TGroupKey,TIntV&gt; Mapping;
1236  #ifdef GCC_ATOMIC
1237    THashMP&lt;TInt,TIntV&gt; GroupByIntMapping_MP(NumValidRows);
1238    TIntV GroupByIntMPKeys(NumValidRows);
1239  #endif
1240    TInt NumOfGroups = 0;
1241    TInt GroupingCase = 0;
1242    GroupStmt Stmt(NGroupByAttrs, Ordered, UsePhysicalIds);
1243    if (GroupMapping.IsKey(Stmt)) {
1244      Mapping = GroupMapping.GetDat(Stmt);
1245    } else{
1246    	if(NGroupByAttrs.Len() == 1){
1247    		switch(GetColType(NGroupByAttrs[0])){
1248    			case atInt:
1249  #ifdef GCC_ATOMIC
1250    				if(GetMP()){
1251    					GroupByIntColMP(NGroupByAttrs[0], GroupByIntMapping_MP, UsePhysicalIds);
1252    					int x = 0;
1253  					for(THashMP&lt;TInt,TIntV&gt;::TIter it = GroupByIntMapping_MP.BegI(); it &lt; GroupByIntMapping_MP.EndI(); it++){
1254  						GroupByIntMPKeys[x] = it.GetKey();
1255  						x++;
1256  					}
1257    					NumOfGroups = x;
1258    					GroupingCase = 4;
1259    					break;
1260    				}
1261  #endif 
1262    				GroupByIntCol(NGroupByAttrs[0], GroupByIntMapping, TIntV(), true, UsePhysicalIds);
1263    				NumOfGroups = GroupByIntMapping.Len();
1264    				GroupingCase = 1;
1265    				break;
1266    			case atFlt:
1267    				GroupByFltCol(NGroupByAttrs[0], GroupByFltMapping, TIntV(), true, UsePhysicalIds);
1268    				NumOfGroups = GroupByFltMapping.Len();
1269    				GroupingCase = 2;
1270    				break;
1271    			case atStr:
1272    				GroupByStrCol(NGroupByAttrs[0], GroupByStrMapping, TIntV(), true, UsePhysicalIds);
1273    				NumOfGroups = GroupByStrMapping.Len();
1274    				GroupingCase = 3;
1275    				break;
1276    		}
1277    	}
1278    	else{
1279    		TIntV UniqueVector;
1280    		THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Mapping_aux;
1281    		GroupAux(NGroupByAttrs, Mapping_aux, Ordered, &quot;&quot;, false, UniqueVector, UsePhysicalIds);
1282    		for(THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it = Mapping_aux.BegI(); it &lt; Mapping_aux.EndI(); it++){
1283    			Mapping.AddDat(it.GetKey(), it.GetDat().Val2);
1284    		}
1285    		NumOfGroups = Mapping.Len();
1286    	}
1287    }
1288    TAttrType T = GetColType(ValAttr);
1289    if (AggOp == aaCount) { AddIntCol(ResAttr); } 
1290    else {
1291      if (T == atInt) { AddIntCol(ResAttr); }
1292      else if (T == atFlt) { AddFltCol(ResAttr); }
1293      else {
1294        TExcept::Throw(&quot;Invalid aggregation for Str type!&quot;);
1295      }
1296    }
1297    TInt ColIdx = GetColIdx(ResAttr);
1298    TInt AggrColIdx = GetColIdx(ValAttr);
1299  #ifdef USE_OPENMP
1300    #pragma omp parallel for schedule(dynamic)
1301  #endif 
1302    for (int g = 0; g &lt; NumOfGroups; g++) {
1303    	TIntV* GroupRows = NULL;
1304    	switch(GroupingCase){
1305    		case 0:
1306    			GroupRows = &amp; Mapping.GetDat(Mapping.GetKey(g));
1307    			break;
1308    		case 1:
1309    			GroupRows = &amp; GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1310    			break;
1311    		case 2:
1312    			GroupRows = &amp; GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1313    			break;
1314    	    case 3:
1315    			GroupRows = &amp; GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g));
1316    			break;
1317    		case 4:
1318  #ifdef GCC_ATOMIC
1319    			GroupRows = &amp; GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]);
1320  #endif
1321    			break;
1322    	}
1323  	TIntV&amp; ValidRows = *GroupRows;
1324      TInt sz = ValidRows.Len();
1325      if (sz &lt;= 0) continue;
1326      if (AggOp == aaCount) {
1327        for (TInt i = 0; i &lt; sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; }
1328      } else {
1329        if (T == atInt) {
1330          TIntV V;
1331          for (TInt i = 0; i &lt; sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); }
1332          TInt Res = AggregateVector&lt;TInt&gt;(V, AggOp);
1333          if (AggOp == aaMean) { Res = Res / sz; }
1334          for (TInt i = 0; i &lt; sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; }
1335        } else {
1336          TFltV V;
1337          for (TInt i = 0; i &lt; sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); }
1338          TFlt Res = AggregateVector&lt;TFlt&gt;(V, AggOp);
1339          if (AggOp == aaMean) { Res /= sz; }
1340          for (TInt i = 0; i &lt; sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; }
1341        }
1342      }
1343    }
1344  }
1345  void TTable::AggregateCols(const TStrV&amp; AggrAttrs, TAttrAggr AggOp, const TStr&amp; ResAttr) {
1346    TVec&lt;TPair&lt;TAttrType, TInt&gt; &gt;Info;
1347    for (TInt i = 0; i &lt; AggrAttrs.Len(); i++) {
1348      Info.Add(GetColTypeMap(AggrAttrs[i]));
1349      if (Info[i].Val1 != Info[0].Val1) {
1350        TExcept::Throw(&quot;AggregateCols: Aggregation attributes must have the same type&quot;);
1351      }
1352    }
1353    if (Info[0].Val1 == atInt) {
1354      AddIntCol(ResAttr);
1355      TInt ResIdx = GetColIdx(ResAttr);
1356      for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1357        TInt RowIdx = RI.GetRowIdx();
1358        TIntV V;
1359        for (TInt i = 0; i &lt; AggrAttrs.Len(); i++) {
1360          V.Add(IntCols[Info[i].Val2][RowIdx]);
1361        }
1362        IntCols[ResIdx][RowIdx] = AggregateVector&lt;TInt&gt;(V, AggOp);
1363      }
1364    } else if (Info[0].Val1 == atFlt) {
1365      AddFltCol(ResAttr);
1366      TInt ResIdx = GetColIdx(ResAttr);
1367      for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1368        TInt RowIdx = RI.GetRowIdx();
1369        TFltV V;
1370        for (TInt i = 0; i &lt; AggrAttrs.Len(); i++) {
1371          V.Add(FltCols[Info[i].Val2][RowIdx]);
1372        }
1373        FltCols[ResIdx][RowIdx] = AggregateVector&lt;TFlt&gt;(V, AggOp);
1374      }
1375    } else {
1376      TExcept::Throw(&quot;AggregateCols: Only Int and Flt aggregation supported right now&quot;);
1377    }
1378  }
1379  void TTable::PrintGrouping(const THash&lt;TGroupKey, TIntV&gt;&amp; Mapping) const{
1380  	for(THash&lt;TGroupKey, TIntV&gt;::TIter it = Mapping.BegI(); it &lt; Mapping.EndI(); it++){
1381    		TGroupKey gk = it.GetKey();
1382    		TIntV ik = gk.Val1;
1383    		TFltV fk = gk.Val2;
1384    		for(int i = 0; i &lt; ik.Len(); i++){ printf(&quot;%d &quot;,ik[i].Val);} 
1385    		for(int i = 0; i &lt; fk.Len(); i++){ printf(&quot;%f &quot;,fk[i].Val);} 
1386    		printf(&quot;--&gt;&quot;);
1387    		TIntV v = it.GetDat();
1388    		for(int i = 0; i &lt; v.Len(); i++){ printf(&quot;%d &quot;,v[i].Val);} 
1389    		printf(&quot;\n&quot;);
1390    	}
1391  }
1392  void TTable::Count(const TStr&amp; CountColName, const TStr&amp; Col) {
1393    TStrV GroupByAttrs;
1394    GroupByAttrs.Add(CountColName);
1395    Aggregate(GroupByAttrs, aaCount, &quot;&quot;, Col);
1396  }
1397  TVec&lt;PTable&gt; TTable::SpliceByGroup(const TStrV&amp; GroupBy, TBool Ordered) {
1398    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1399    TIntV UniqueVec;
1400    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;Grouping;
1401    TVec&lt;PTable&gt; Result;
1402    Schema NewSchema;
1403    for (TInt c = 0; c &lt; Sch.Len(); c++) {
1404      if (Sch[c].Val1 != GetIdColName()) {
1405        NewSchema.Add(Sch[c]);
1406      }
1407    }
1408    GroupAux(NGroupBy, Grouping, Ordered, &quot;&quot;, false, UniqueVec);
1409    TInt cnt = 0;
1410    for (THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it = Grouping.BegI(); it != Grouping.EndI(); it++) {
1411      PTable GroupTable = TTable::New(NewSchema, Context);
1412      TVec&lt;TPair&lt;TAttrType, TInt&gt; &gt; ColInfo;
1413      TIntV V;
1414      for (TInt i = 0; i &lt; Sch.Len(); i++) {
1415        ColInfo.Add(GroupTable-&gt;GetColTypeMap(Sch[i].Val1));
1416        if (Sch[i].Val1 == IdColName()) {
1417          ColInfo[i].Val2 = -1;
1418        }
1419        V.Add(GetColIdx(Sch[i].Val1));
1420      }
1421      TIntV&amp; Rows = it.GetDat().Val2;
1422      for (TInt i = 0; i &lt; Rows.Len(); i++) {
1423        TInt RowIdx = RowIdMap.GetDat(Rows[i]);
1424        for (TInt c = 0; c &lt; Sch.Len(); c++) {
1425          TPair&lt;TAttrType, TInt&gt; Info = ColInfo[c];
1426          TInt ColIdx = Info.Val2;
1427          if (ColIdx == -1) { continue; }
1428          switch (Info.Val1) {
1429            case atInt:
1430              GroupTable-&gt;IntCols[ColIdx].Add(IntCols[V[c]][RowIdx]);
1431              break;
1432            case atFlt:
1433              GroupTable-&gt;FltCols[ColIdx].Add(FltCols[V[c]][RowIdx]);
1434              break;
1435            case atStr:
1436              GroupTable-&gt;StrColMaps[ColIdx].Add(StrColMaps[V[c]][RowIdx]);
1437              break;
1438          }
1439        }
1440        if (GroupTable-&gt;LastValidRow &gt;= 0) {
1441          GroupTable-&gt;Next[GroupTable-&gt;LastValidRow] = GroupTable-&gt;NumRows;
1442        }
1443        GroupTable-&gt;Next.Add(GroupTable-&gt;Last);
1444        GroupTable-&gt;LastValidRow = GroupTable-&gt;NumRows;
1445        GroupTable-&gt;NumRows++;
1446        GroupTable-&gt;NumValidRows++;
1447      }
1448      GroupTable-&gt;InitIds();
1449      Result.Add(GroupTable);
1450      cnt += 1;
1451    }
1452    return Result;
1453  }
1454  void TTable::InitIds() {
1455    IdColName = &quot;_id&quot;;
1456    AddIdColumn(IdColName);
1457  }
1458  void TTable::Reindex() {
1459    RowIdMap.Clr();
1460    TInt IdColIdx = GetColIdx(IdColName);
1461    TInt IdCnt = 0;
1462    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1463      IntCols[IdColIdx][RI.GetRowIdx()] = IdCnt;
1464      RowIdMap.AddDat(RI.GetRowIdx(), IdCnt);
1465      IdCnt++;
1466    }
1467  }
1468  void TTable::AddIdColumn(const TStr&amp; ColName) {
1469    TInt IdCol = IntCols.Add();
1470    IntCols[IdCol].Reserve(NumRows, NumRows);
1471    TInt IdCnt = 0;
1472    RowIdMap.Clr();
1473    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
1474      IntCols[IdCol][RI.GetRowIdx()] = IdCnt;
1475      RowIdMap.AddDat(IdCnt, RI.GetRowIdx());
1476      IdCnt++;
1477    }
1478    AddSchemaCol(ColName, atInt);
1479    AddColType(ColName, atInt, IntCols.Len()-1);
1480  }
1481   PTable TTable::InitializeJointTable(const TTable&amp; Table) {
1482    PTable JointTable = New(Context);
1483    JointTable-&gt;IntCols = TVec&lt;TIntV&gt;(IntCols.Len() + Table.IntCols.Len() + 1);
1484    JointTable-&gt;FltCols = TVec&lt;TFltV&gt;(FltCols.Len() + Table.FltCols.Len());
1485    JointTable-&gt;StrColMaps = TVec&lt;TIntV&gt;(StrColMaps.Len() + Table.StrColMaps.Len());
1486    for (TInt i = 0; i &lt; Sch.Len(); i++) {
1487      TStr ColName = GetSchemaColName(i);
1488      TAttrType ColType = GetSchemaColType(i);
1489      TStr CName = JointTable-&gt;RenumberColName(ColName);
1490      TPair&lt;TAttrType, TInt&gt; TypeMap = GetColTypeMap(ColName);
1491      JointTable-&gt;AddColType(CName, TypeMap);
1492      JointTable-&gt;AddSchemaCol(CName, ColType);
1493    }
1494    for (TInt i = 0; i &lt; Table.Sch.Len(); i++) {
1495      TStr ColName = Table.GetSchemaColName(i);
1496      TAttrType ColType = Table.GetSchemaColType(i);
1497      TStr CName = JointTable-&gt;RenumberColName(ColName);
1498      TPair&lt;TAttrType, TInt&gt; NewDat = Table.GetColTypeMap(ColName);
1499      Assert(ColType == NewDat.Val1);
1500      switch (NewDat.Val1) {
1501        case atInt:
1502          NewDat.Val2 += IntCols.Len();
1503          break;
1504        case atFlt:
1505          NewDat.Val2 += FltCols.Len();
1506          break;
1507        case atStr:
1508          NewDat.Val2 += StrColMaps.Len();
1509          break;
1510      }
1511      JointTable-&gt;AddColType(CName, NewDat);
1512      JointTable-&gt;AddSchemaCol(CName, ColType);
1513    }
1514    TStr IdColName = &quot;_id&quot;;
1515    JointTable-&gt;AddColType(IdColName, atInt, IntCols.Len() + Table.IntCols.Len());
1516    JointTable-&gt;AddSchemaCol(IdColName, atInt);
1517    return JointTable;
1518  }
1519  void TTable::AddJointRow(const TTable&amp; T1, const TTable&amp; T2, TInt RowIdx1, TInt RowIdx2) {
1520    for (TInt i = 0; i &lt; T1.IntCols.Len(); i++) {
1521      IntCols[i].Add(T1.IntCols[i][RowIdx1]);
1522    }
1523    for (TInt i = 0; i &lt; T1.FltCols.Len(); i++) {
1524      FltCols[i].Add(T1.FltCols[i][RowIdx1]);
1525    }
1526    for (TInt i = 0; i &lt; T1.StrColMaps.Len(); i++) {
1527      StrColMaps[i].Add(T1.StrColMaps[i][RowIdx1]);
1528    }
1529    TInt IntOffset = T1.IntCols.Len();
1530    TInt FltOffset = T1.FltCols.Len();
1531    TInt StrOffset = T1.StrColMaps.Len();
1532    for (TInt i = 0; i &lt; T2.IntCols.Len(); i++) {
1533      IntCols[i+IntOffset].Add(T2.IntCols[i][RowIdx2]);
1534    }
1535    for (TInt i = 0; i &lt; T2.FltCols.Len(); i++) {
1536      FltCols[i+FltOffset].Add(T2.FltCols[i][RowIdx2]);
1537    }
1538    for (TInt i = 0; i &lt; T2.StrColMaps.Len(); i++) {
1539      StrColMaps[i+StrOffset].Add(T2.StrColMaps[i][RowIdx2]);
1540    }
1541    TInt IdOffset = IntOffset + T2.IntCols.Len(); 
1542    NumRows++;
1543    NumValidRows++;
1544    if (!Next.Empty()) {
1545      Next[Next.Len()-1] = NumValidRows-1;
1546      LastValidRow = NumValidRows-1;
1547    }
1548    Next.Add(Last);
1549    RowIdMap.AddDat(NumRows-1,NumRows-1);
1550    IntCols[IdOffset].Add(NumRows-1);
1551  }
1552  PTable TTable::SimJoin(const TStrV&amp; Cols1, const TTable&amp; Table, const TStrV&amp; Cols2, const TStr&amp; DistanceColName, const TSimType&amp; SimType, const TFlt&amp; Threshold)
1553  {
1554  	Assert(Cols1.Len() == Cols2.Len());
1555  	if(Cols1.Len()!=Cols2.Len()){
1556  		TExcept::Throw(&quot;Column vectors must match in type and length&quot;);
1557  	}
1558  	for (TInt i = 0; i &lt; Cols1.Len(); i++) {
1559  		if(!IsColName(Cols1[i]) || !Table.IsColName(Cols2[i])){
1560  			TExcept::Throw(&quot;Column not found in Table&quot;);
1561  		}
1562  		TAttrType Type1 = GetColType(Cols1[i]);
1563  		TAttrType Type2 = GetColType(Cols2[i]);
1564  		if(Type1!=Type2){
1565  			TExcept::Throw(&quot;Column types on the two tables must match.&quot;);
1566  		}
1567  		if((Type1!=atInt &amp;&amp; Type1!=atFlt) || (Type2!=atInt &amp;&amp; Type2!=atFlt)){
1568  			TExcept::Throw(&quot;Column type not supported. Only Flt and Int column types are supported.&quot;);
1569  		}
1570    }
1571    PTable JointTable = InitializeJointTable(Table);
1572  	TFltV DistanceV;
1573  	for(TRowIterator RowI = this-&gt;BegRI(); RowI &lt; this-&gt;EndRI(); RowI++) {
1574  		for(TRowIterator RowI2 = Table.BegRI(); RowI2 &lt; Table.EndRI(); RowI2++) {
1575  			float distance = 0;
1576  			switch(SimType)
1577  			{
1578  				case L2Norm:
1579  					for(TInt i = 0; i &lt; Cols1.Len(); i++) {
1580  						float attrVal1, attrVal2;
1581  						attrVal1 = GetColType(Cols1[i])==atInt ? (float)RowI.GetIntAttr(Cols1[i]) : (float)RowI.GetFltAttr(Cols1[i]);
1582  						attrVal2 = Table.GetColType(Cols2[i])==atInt ? (float)RowI2.GetIntAttr(Cols2[i]) : (float)RowI2.GetFltAttr(Cols2[i]);
1583  						distance += pow(attrVal1 - attrVal2, 2);
1584  					}
1585  					distance = sqrt(distance);
1586  					if(distance&lt;=Threshold){
1587  						JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1588  						DistanceV.Add(distance);
1589  					}
1590  					break;
1591  				case Haversine:
1592  					{
1593  						if(Cols1.Len()!=2){
1594  							TExcept::Throw(&quot;Haversine disance expects exactly two attributes - latitude and longitude - in that order.&quot;);
1595  						}
1596  						TFlt Radius = 6373; 
1597  						float Latitude1  = GetColType(Cols1[0])==atInt ? (float)RowI.GetIntAttr(Cols1[0]) : (float)RowI.GetFltAttr(Cols1[0]);
1598  						float Latitude2 = Table.GetColType(Cols2[0])==atInt ? (float)RowI2.GetIntAttr(Cols2[0]) : (float)RowI2.GetFltAttr(Cols2[0]);
1599  						float Longitude1  = GetColType(Cols1[1])==atInt ? (float)RowI.GetIntAttr(Cols1[1]) : (float)RowI.GetFltAttr(Cols1[1]);
1600  						float Longitude2  = Table.GetColType(Cols2[1])==atInt ? (float)RowI2.GetIntAttr(Cols2[1]) : (float)RowI2.GetFltAttr(Cols2[1]);
1601  						Latitude1 *= static_cast&lt;float&gt;(M_PI/180.0);
1602  						Latitude2 *= static_cast&lt;float&gt;(M_PI/180.0);
1603  						Longitude1 *= static_cast&lt;float&gt;(M_PI/180.0);
1604  						Longitude2 *= static_cast&lt;float&gt;(M_PI/180.0);
1605  						float dlon = Longitude2 - Longitude1;
1606  						float dlat = Latitude2 - Latitude1;
1607  						float a = pow(sin(dlat/2), 2) + cos(Latitude1)*cos(Latitude2)*pow(sin(dlon/2), 2);
1608  						float c = 2*atan2(sqrt(a), sqrt(1-a));
1609  						distance = (static_cast&lt;float&gt;(Radius.Val))*c;
1610  						if(distance&lt;=Threshold){
1611  							JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1612  							DistanceV.Add(distance);
1613  						}
1614  					}
1615  					break;
1616  				case L1Norm:
1617  				case Jaccard:
1618  					TExcept::Throw(&quot;This distance metric is not supported&quot;);
1619  			}
1620  		}	
1621  	}
1622  	JointTable-&gt;StoreFltCol(DistanceColName, DistanceV);
1623  	JointTable-&gt;InitIds();
1624  	return JointTable;
1625  }
1626  PTable TTable::SelfSimJoinPerGroup(const TStr&amp; GroupAttr, const TStr&amp; SimCol, const TStr&amp; DistanceColName, const TSimType&amp; SimType, const TFlt&amp; Threshold) 
1627  {
1628  	if(!IsColName(SimCol) || !IsColName(GroupAttr)){
1629  		TExcept::Throw(&quot;No such column found in table&quot;);
1630  	}
1631    PTable JointTable = New(Context);
1632  	JointTable-&gt;IntCols = TVec&lt;TIntV&gt;(2);
1633  	JointTable-&gt;FltCols = TVec&lt;TFltV&gt;(1);
1634  	for(TInt i=0;i&lt;2;i++){
1635      TInt Suffix = i+1;
1636      TStr CName = &quot;GroupId_&quot; + Suffix.GetStr();
1637      TPair&lt;TAttrType, TInt&gt; Group(atInt, (int)i);
1638      JointTable-&gt;AddColType(CName, Group);
1639      JointTable-&gt;AddSchemaCol(CName, atInt);
1640    }
1641  	TPair&lt;TAttrType, TInt&gt; Group(atFlt, 0);
1642  	JointTable-&gt;AddColType(DistanceColName, Group);
1643  	JointTable-&gt;AddSchemaCol(DistanceColName, atFlt);
1644  	THash&lt;TInt, THash&lt;TInt, TInt&gt; &gt; TIntHH;
1645  	TAttrType attrType = GetColType(SimCol);
1646  	TInt GroupColIdx = GetColIdx(GroupAttr);
1647  	TInt SimColIdx = GetColIdx(SimCol);
1648  	for (TRowIterator RowI = this-&gt;BegRI(); RowI &lt; this-&gt;EndRI(); RowI++) {
1649  		TInt GroupId = IntCols[GroupColIdx][RowI.GetRowIdx()];
1650  		if(attrType==atInt || attrType==atStr)
1651  		{
1652  			if(!TIntHH.IsKey(GroupId)){
1653  				THash&lt;TInt, TInt&gt; TIntH;
1654  				TIntHH.AddDat(GroupId, TIntH);
1655  			}
1656  			THash&lt;TInt, TInt&gt;&amp; TIntH = TIntHH.GetDat(GroupId);
1657  			TInt SimAttrVal = (attrType==atInt ? IntCols[SimColIdx][RowI.GetRowIdx()] : StrColMaps[SimColIdx][RowI.GetRowIdx()]);
1658  			TIntH.AddDat(SimAttrVal, 0);
1659  		}
1660  		else
1661  		{
1662  			TExcept::Throw(&quot;Attribute type not supported.&quot;);
1663  		}
1664  	}
1665  	for (THash&lt;TInt, THash&lt;TInt, TInt&gt; &gt;::TIter it1 = TIntHH.BegI(); it1 &lt; TIntHH.EndI(); it1++) {
1666  		THash&lt;TInt, TInt&gt; Vals1H = it1.GetDat();
1667  		TInt GroupId1 = it1.GetKey();
1668  		for (THash&lt;TInt, THash&lt;TInt, TInt&gt; &gt;::TIter it2 = TIntHH.BegI(); it2 &lt; TIntHH.EndI(); it2++) {
1669  				int intersectionCount = 0;
1670  				TInt GroupId2 = it2.GetKey();
1671  				THash&lt;TInt, TInt&gt; Vals2H = it2.GetDat();
1672  				for(THash&lt;TInt, TInt&gt;::TIter it = Vals1H.BegI(); it &lt; Vals1H.EndI(); it++)
1673  				{
1674  					TInt Val = it.GetKey();
1675  					if(Vals2H.IsKey(Val)){
1676  						intersectionCount+=1;
1677  					}
1678  				}
1679  				int unionCount = Vals1H.Len() + Vals2H.Len() - intersectionCount;
1680  				float distance = 1.0f - (float)intersectionCount/unionCount;
1681  				if(distance&lt;=Threshold){
1682  						JointTable-&gt;IntCols[0].Add(GroupId1);
1683  						JointTable-&gt;IntCols[1].Add(GroupId2);
1684  						JointTable-&gt;FltCols[0].Add(distance);
1685  						JointTable-&gt;IncrementNext();
1686  			}
1687  		}
1688  	}
1689    JointTable-&gt;InitIds();
1690  	return JointTable;
1691  }
1692  PTable TTable::SelfSimJoinPerGroup(const TStrV&amp; GroupBy, const TStr&amp; SimCol, 
1693   const TStr&amp; DistanceColName, const TSimType&amp; SimType, const TFlt&amp; Threshold) {
1694    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1695  	TStrV ProjectionV;
1696  	for(TInt i=0; i&lt;GroupBy.Len(); i++)
1697  	{
1698  		ProjectionV.Add(GroupBy[i]);
1699  	}
1700  	ProjectionV.Add(SimCol);
1701  	ProjectInPlace(ProjectionV);
1702  	TStr CName = &quot;Group&quot;;
1703    TIntV UniqueVec;
1704    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt; Grouping;
1705    GroupAux(NGroupBy, Grouping, false, CName, false, UniqueVec);
1706  	PTable GroupJointTable = SelfSimJoinPerGroup(CName, SimCol, DistanceColName, SimType, Threshold);
1707  	PTable JointTable = InitializeJointTable(*this);
1708  	THash&lt;TInt, TInt&gt; GroupIdH;
1709  	for(THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;::TIter it=Grouping.BegI(); it&lt;Grouping.EndI(); it++)
1710  	{
1711  		TPair&lt;TInt, TIntV&gt; group = it.GetDat();
1712  		TInt GroupNum = group.Val1;
1713  		TIntV RowIds = group.Val2;
1714  		if(!GroupIdH.IsKey(GroupNum))
1715  		{
1716  			TInt RandomRowId = RowIds[0];  
1717  			GroupIdH.AddDat(GroupNum, RandomRowId);
1718  		}
1719  	}
1720  	for(TRowIterator RowI = GroupJointTable-&gt;BegRI(); RowI &lt; GroupJointTable-&gt;EndRI(); RowI++)
1721  	{
1722  		TInt GroupId1 = GroupJointTable-&gt;IntCols[0][RowI.GetRowIdx()];
<span onclick='openModal()' class='match'>1723  		TInt GroupId2 = GroupJointTable-&gt;IntCols[1][RowI.GetRowIdx()];
1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
</span>1725  		TInt RowId2 = GroupIdH.GetDat(GroupId2);
1726  		JointTable-&gt;AddJointRow(*this, *this, RowId1, RowId2);
1727  	} 
1728  	JointTable-&gt;StoreFltCol(DistanceColName, GroupJointTable-&gt;FltCols[0]);
1729  	ProjectionV.Clr();
1730  	ProjectionV.Add(DistanceColName);
1731  	for(TInt i=0; i&lt;GroupBy.Len(); i++){
1732  		for(TInt j=0; j&lt;JointTable-&gt;Sch.Len(); j++)
1733  		{
1734  			TStr ColName = JointTable-&gt;Sch[j].Val1;
1735  			if(ColName.IsStrIn(GroupBy[i]))
1736  			{
1737  				ProjectionV.Add(ColName);
1738  			}
1739  		}
1740  	}
1741  	JointTable-&gt;ProjectInPlace(ProjectionV);
1742  	JointTable-&gt;InitIds();
1743  	return JointTable;
1744  }
1745  void TTable::IncrementNext()
1746  {
1747  	NumRows++;
1748  	NumValidRows++;
1749  	if (!Next.Empty()) {
1750  		Next[Next.Len()-1] = NumValidRows-1;
1751  		LastValidRow = NumValidRows-1;
1752  	}
1753  	Next.Add(Last);
1754  }
1755  PTable TTable::Join(const TStr&amp; Col1, const TTable&amp; Table, const TStr&amp; Col2) {
1756    if (!IsColName(Col1)) {
1757      TExcept::Throw(&quot;no such column &quot; + Col1);
1758      printf(&quot;no such column %s\n&quot;, Col1.CStr());
1759    }
1760    if (!Table.IsColName(Col2)) {
1761      TExcept::Throw(&quot;no such column &quot; + Col2);
1762      printf(&quot;no such column %s\n&quot;, Col2.CStr());
1763    }
1764    if (GetColType(Col1) != Table.GetColType(Col2)) {
1765      TExcept::Throw(&quot;Trying to Join on columns of different type&quot;);
1766      printf(&quot;Trying to Join on columns of different type\n&quot;);
1767    }
1768    PTable JointTable = InitializeJointTable(Table);
1769    TAttrType ColType = GetColType(Col1);
1770    TBool ThisIsSmaller = (NumValidRows &lt;= Table.NumValidRows);
1771    const TTable&amp; TS = ThisIsSmaller ? *this : Table;
1772    const TTable&amp; TB = ThisIsSmaller ?  Table : *this;
1773    TStr ColS = ThisIsSmaller ? Col1 : Col2;
1774    TStr ColB = ThisIsSmaller ? Col2 : Col1;
1775    TInt ColBId = ThisIsSmaller ? Table.GetColIdx(ColB) : GetColIdx(ColB);
1776  #ifdef GCC_ATOMIC
1777    if (GetMP()) {
1778      switch(ColType){
1779        case atInt:{
1780          THashMP&lt;TInt, TIntV&gt; T(TS.GetNumValidRows());
1781          TS.GroupByIntColMP(ColS, T, true);
1782          TIntPrV Partitions;
1783          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1784          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1785          TVec&lt;TIntPrV&gt; JointRowIDSet(Partitions.Len());
1786          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1787          for (int i = 0; i &lt; Partitions.Len(); i++){
1788            JointRowIDSet[i].Reserve(PartitionSize);
1789            TRowIterator RowI(Partitions[i].GetVal1(), &amp;TB);
1790            TRowIterator EndI(Partitions[i].GetVal2(), &amp;TB);
1791            while (RowI &lt; EndI) {
1792              TInt K = RowI.GetIntAttr(ColBId);
1793              if(T.IsKey(K)){
1794                TIntV&amp; Group = T.GetDat(K);
1795                for(TInt j = 0; j &lt; Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
1803              RowI++;
1804            }
1805          }
1806          JointTable-&gt;AddNJointRowsMP(*this, Table, JointRowIDSet);      
1807          break;
1808        }
1809        case atFlt:{
1810          THashMP&lt;TFlt, TIntV&gt; T(TS.GetNumValidRows());
1811          TS.GroupByFltCol(ColS, T, TIntV(), true);
1812          TIntPrV Partitions;
1813          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1814          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1815          TVec&lt;TIntPrV&gt; JointRowIDSet(Partitions.Len());
1816          #pragma omp parallel for schedule(dynamic) 
1817          for (int i = 0; i &lt; Partitions.Len(); i++){
1818            JointRowIDSet[i].Reserve(PartitionSize);
1819            TRowIterator RowI(Partitions[i].GetVal1(), &amp;TB);
1820            TRowIterator EndI(Partitions[i].GetVal2(), &amp;TB);
1821            while (RowI &lt; EndI) {
1822              TFlt K = RowI.GetFltAttr(ColBId);
1823              if(T.IsKey(K)){
1824                TIntV&amp; Group = T.GetDat(K);
1825                for(TInt j = 0; j &lt; Group.Len(); j++){
1826                  if(ThisIsSmaller){
1827                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1828                  } else{
1829                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1830                  }
1831                }
1832              }
1833              RowI++;
1834            }
1835          }
1836          JointTable-&gt;AddNJointRowsMP(*this, Table, JointRowIDSet);
1837          break;
1838        }
1839        case atStr:{
1840          THashMP&lt;TInt, TIntV&gt; T(TS.GetNumValidRows());
1841          TS.GroupByStrCol(ColS, T, TIntV(), true);
1842          TIntPrV Partitions;
1843          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1844          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1845          TVec&lt;TIntPrV&gt; JointRowIDSet(Partitions.Len());
1846          #pragma omp parallel for schedule(dynamic) 
1847          for (int i = 0; i &lt; Partitions.Len(); i++){
1848            JointRowIDSet[i].Reserve(PartitionSize);
1849            TRowIterator RowI(Partitions[i].GetVal1(), &amp;TB);
1850            TRowIterator EndI(Partitions[i].GetVal2(), &amp;TB);
1851            while (RowI &lt; EndI) {
1852              TInt K = RowI.GetStrMapById(ColBId);
1853              if(T.IsKey(K)){
1854                TIntV&amp; Group = T.GetDat(K);
1855                for(TInt j = 0; j &lt; Group.Len(); j++){
1856                  if(ThisIsSmaller){
1857                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1858                  } else{
1859                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1860                  }
1861                }
1862              }
1863              RowI++;
1864            }
1865          }
1866          JointTable-&gt;AddNJointRowsMP(*this, Table, JointRowIDSet);
1867        }
1868        break;
1869      }
1870    } else {
1871  #endif 
1872      switch (ColType) {
1873        case atInt:{
1874          TIntIntVH T;
1875          TS.GroupByIntCol(ColS, T, TIntV(), true);
1876          for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1877            TInt K = RowI.GetIntAttr(ColBId);
1878            if (T.IsKey(K)) {
1879              TIntV&amp; Group = T.GetDat(K);
1880              for (TInt i = 0; i &lt; Group.Len(); i++) {
1881                if (ThisIsSmaller) {
1882                  JointTable-&gt;AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1883                } else {
1884                  JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1885                }
1886              }
1887            }
1888          }
1889          break;
1890        }
1891        case atFlt:{
1892          THash&lt;TFlt, TIntV&gt; T;
1893          TS.GroupByFltCol(ColS, T, TIntV(), true);
1894          for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1895            TFlt K = RowI.GetFltAttr(ColBId);
1896            if (T.IsKey(K)) {
1897              TIntV&amp; Group = T.GetDat(K);
1898              for (TInt i = 0; i &lt; Group.Len(); i++) {
1899                if (ThisIsSmaller) {
1900                  JointTable-&gt;AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1901                } else {
1902                  JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1903                }
1904              }
1905            }
1906          }
1907          break;
1908        }
1909        case atStr:{
1910          TIntIntVH T;
1911          TS.GroupByStrCol(ColS, T, TIntV(), true);
1912          for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1913            TInt K = RowI.GetStrMapById(ColBId);
1914            if (T.IsKey(K)) {
1915              TIntV&amp; Group = T.GetDat(K);
1916              for (TInt i = 0; i &lt; Group.Len(); i++) {
1917                if (ThisIsSmaller) {
1918                  JointTable-&gt;AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1919                } else {
1920                  JointTable-&gt;AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1921                }
1922              }
1923            }
1924          }
1925        }
1926        break;
1927      }
1928  #ifdef GCC_ATOMIC
1929    }
1930  #endif
1931    return JointTable; 
1932  }
1933  void TTable::ThresholdJoinInputCorrectness(const TStr&amp; KeyCol1, const TStr&amp; JoinCol1, const TTable&amp; Table, 
1934    const TStr&amp; KeyCol2, const TStr&amp; JoinCol2){
1935    if (!IsColName(KeyCol1)) {
1936      printf(&quot;no such column %s\n&quot;, KeyCol1.CStr());
1937      TExcept::Throw(&quot;no such column &quot; + KeyCol1);
1938    }
1939    if (!Table.IsColName(KeyCol2)) {
1940      printf(&quot;no such column %s\n&quot;, KeyCol2.CStr());
1941      TExcept::Throw(&quot;no such column &quot; + KeyCol2);
1942    }
1943    if (!IsColName(JoinCol1)) {
1944      printf(&quot;no such column %s\n&quot;, JoinCol1.CStr());
1945      TExcept::Throw(&quot;no such column &quot; + JoinCol1);
1946    }
1947    if (!Table.IsColName(JoinCol2)) {
1948      printf(&quot;no such column %s\n&quot;, JoinCol2.CStr());
1949      TExcept::Throw(&quot;no such column &quot; + JoinCol2);
1950    }
1951    if (GetColType(JoinCol1) != Table.GetColType(JoinCol2)) {
1952      printf(&quot;Trying to Join on columns of different type\n&quot;);
1953      TExcept::Throw(&quot;Trying to Join on columns of different type&quot;);
1954    }
1955    if (GetColType(KeyCol1) != Table.GetColType(KeyCol2)) {
1956      printf(&quot;Key type mismatch\n&quot;);
1957      TExcept::Throw(&quot;Key type mismatch&quot;);
1958    }
1959  }
1960  void TTable::ThresholdJoinCountCollisions(const TTable&amp; TB, const TTable&amp; TS, 
1961    const TIntIntVH&amp; T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
1962    THash&lt;TIntPr,TIntTr&gt;&amp; Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
1963      for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
1964        TInt JVal = 0;
1965        if(JoinColType == atStr){
1966          JVal = RowI.GetStrMapById(JoinColIdxB);
1967        } else{
1968          JVal = RowI.GetIntAttr(JoinColIdxB);
1969        }
1970        if(T.IsKey(JVal)){
1971          TInt KeyB = 0;
1972          if(KeyType == atStr){
1973            KeyB = RowI.GetStrMapById(KeyColIdxB);
1974          } else{
1975            KeyB = RowI.GetIntAttr(KeyColIdxB);
1976          } 
1977          const TIntV&amp; RelevantRows = T.GetDat(JVal);
1978          for(int i = 0; i &lt; RelevantRows.Len(); i++){
1979            TInt KeyS = 0;
1980            if(KeyType == atStr){
1981              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
1982            } else{
1983              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
1984            }
1985            TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
1986            if(Counters.IsKey(Keys)){
1987              TIntTr&amp; V = Counters.GetDat(Keys);
1988              V.Val3 = V.Val3 + 1;
1989            } else{
1990              if(ThisIsSmaller){
1991                Counters.AddDat(Keys, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
1992              } else{
1993                Counters.AddDat(Keys, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
1994              }
1995            }
1996          }	
1997        }	
1998      } 
1999  }
2000  void TTable::ThresholdJoinCountPerJoinKeyCollisions(const TTable&amp; TB, const TTable&amp; TS, 
2001    const TIntIntVH&amp; T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
2002    THash&lt;TIntTr,TIntTr&gt;&amp; Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
2003      for (TRowIterator RowI = TB.BegRI(); RowI &lt; TB.EndRI(); RowI++) {
2004        TInt JVal = 0;
2005        if(JoinColType == atStr){
2006          JVal = RowI.GetStrMapById(JoinColIdxB);
2007         } else{
2008          JVal = RowI.GetIntAttr(JoinColIdxB);
2009         }
2010        if(T.IsKey(JVal)){
2011          TInt KeyB = 0;
2012          if(KeyType == atStr){
2013            KeyB = RowI.GetStrMapById(KeyColIdxB);
2014          } else{
2015            KeyB = RowI.GetIntAttr(KeyColIdxB);
2016          } 
2017          const TIntV&amp; RelevantRows = T.GetDat(JVal);
2018          for(int i = 0; i &lt; RelevantRows.Len(); i++){
2019            TInt KeyS = 0;
2020            if(KeyType == atStr){
2021              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
2022            } else{
2023              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
2024            }
2025          	TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
2026          	TIntTr K(Keys.Val1,Keys.Val2,JVal);
2027            if(Counters.IsKey(K)){
2028              TIntTr&amp; V = Counters.GetDat(K);
2029              V.Val3 = V.Val3 + 1;
2030            } else{
2031              if(ThisIsSmaller){
2032                Counters.AddDat(K, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
2033              } else{
2034                Counters.AddDat(K, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
2035              }
2036            }
2037          }	
2038        }	
2039      } 
2040    }
2041  PTable TTable::ThresholdJoinOutputTable(const THash&lt;TIntPr,TIntTr&gt;&amp; Counters, TInt Threshold, const TTable&amp; Table){
2042    PTable JointTable = InitializeJointTable(Table);
2043    for(THash&lt;TIntPr,TIntTr&gt;::TIter iter = Counters.BegI(); iter &lt; Counters.EndI(); iter++){
2044      TIntTr&amp; Counter = iter.GetDat();
2045      if(Counter.Val3 &gt;= Threshold){
2046        JointTable-&gt;AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2047      }
2048    }
2049    return JointTable;
2050  }
2051  PTable TTable::ThresholdJoinPerJoinKeyOutputTable(const THash&lt;TIntTr,TIntTr&gt;&amp; Counters, TInt Threshold, const TTable&amp; Table){
2052    PTable JointTable = InitializeJointTable(Table);
2053    for(THash&lt;TIntTr,TIntTr&gt;::TIter iter = Counters.BegI(); iter &lt; Counters.EndI(); iter++){
2054      const TIntTr&amp; Counter = iter.GetDat();
2055      const TIntTr&amp; Keys = iter.GetKey();
2056      THashSet&lt;TIntPr&gt; Pairs;
2057      if(Counter.Val3 &gt;= Threshold){
2058        TIntPr K(Keys.Val1,Keys.Val2);
2059        if(!Pairs.IsKey(K)){
2060          Pairs.AddKey(K);
2061          JointTable-&gt;AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2062        }
2063      }
2064    }
2065    return JointTable;
2066  }
2067  PTable TTable::ThresholdJoin(const TStr&amp; KeyCol1, const TStr&amp; JoinCol1, const TTable&amp; Table, 
2068    const TStr&amp; KeyCol2, const TStr&amp; JoinCol2, TInt Threshold, TBool PerJoinKey){
2069    ThresholdJoinInputCorrectness(KeyCol1, JoinCol1, Table, KeyCol2, JoinCol2);
2070    TAttrType JoinColType = GetColType(JoinCol1);
2071    TAttrType KeyType = GetColType(KeyCol1);
2072    TBool ThisIsSmaller = (NumValidRows &lt;= Table.NumValidRows);
2073    const TTable&amp; TS = ThisIsSmaller ? *this : Table;
2074    const TTable&amp; TB = ThisIsSmaller ?  Table : *this;
2075    TStr JoinColS = JoinCol1;
2076    TInt JoinColIdxB = GetColIdx(JoinCol2);
2077    TInt KeyColIdxS = GetColIdx(KeyCol1);
2078    TInt KeyColIdxB = GetColIdx(KeyCol2);
2079    if(!ThisIsSmaller){
2080    	JoinColS = JoinCol2;
2081      JoinColIdxB = GetColIdx(JoinCol1);
2082    	KeyColIdxS = GetColIdx(KeyCol2);
2083      KeyColIdxB = GetColIdx(KeyCol1);
2084    }
2085    if(KeyType != atInt &amp;&amp; KeyType != atStr){
2086      printf(&quot;ThresholdJoin only supports integer or string key attributes\n&quot;);
2087      TExcept::Throw(&quot;ThresholdJoin only supports integer or string key attributes&quot;);
2088    }
2089    if(JoinColType != atInt &amp;&amp; JoinColType != atStr){
2090      printf(&quot;ThresholdJoin only supports integer or string join attributes\n&quot;);
2091      TExcept::Throw(&quot;ThresholdJoin only supports integer or string join attributes&quot;);
2092    }
2093    TIntIntVH T;
2094    if(JoinColType == atInt){
2095      TS.GroupByIntCol(JoinColS, T, TIntV(), true);
2096    } else if(JoinColType == atStr){
2097      TS.GroupByStrCol(JoinColS, T, TIntV(), true);
2098    } else{
2099      TExcept::Throw(&quot;ThresholdJoin only supports integer or string join attributes&quot;);
2100    } 
2101    if(PerJoinKey){
2102      THash&lt;TIntTr,TIntTr&gt; Counters;
2103      ThresholdJoinCountPerJoinKeyCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2104      return ThresholdJoinPerJoinKeyOutputTable(Counters, Threshold, Table);
2105    } else{
2106      THash&lt;TIntPr,TIntTr&gt; Counters;
2107      ThresholdJoinCountCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2108      return ThresholdJoinOutputTable(Counters, Threshold, Table);
2109    }
2110  }
2111  void TTable::Select(TPredicate&amp; Predicate, TIntV&amp; SelectedRows, TBool Remove) {
2112    TIntV Selected;
2113    TStrV RelevantCols;
2114    Predicate.GetVariables(RelevantCols);
2115    TInt NumRelevantCols = RelevantCols.Len();
2116    TVec&lt;TAttrType&gt; ColTypes = TVec&lt;TAttrType&gt;(NumRelevantCols);
2117    TIntV ColIndices = TIntV(NumRelevantCols);
2118    for (TInt i = 0; i &lt; NumRelevantCols; i++) {
2119      ColTypes[i] = GetColType(RelevantCols[i]);
2120      ColIndices[i] = GetColIdx(RelevantCols[i]);
2121    } 
2122    if (Remove) {
2123      TRowIteratorWithRemove RowI = BegRIWR();
2124      while (RowI.GetNextRowIdx() != Last) {
2125        for (TInt i = 0; i &lt; NumRelevantCols; i++) {
2126          switch (ColTypes[i]) {
2127          case atInt:
2128            Predicate.SetIntVal(RelevantCols[i], RowI.GetNextIntAttr(ColIndices[i]));
2129            break;
2130          case atFlt:
2131            Predicate.SetFltVal(RelevantCols[i], RowI.GetNextFltAttr(ColIndices[i]));
2132            break;
2133          case atStr:
2134            Predicate.SetStrVal(RelevantCols[i], RowI.GetNextStrAttr(ColIndices[i]));
2135            break;
2136          }
2137        }
2138        if (!Predicate.Eval()) { 
2139          RowI.RemoveNext();
2140        } else {
2141          RowI++;
2142        }
2143      }
2144    } else {
2145      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
2146        for (TInt i = 0; i &lt; NumRelevantCols; i++) {
2147          switch (ColTypes[i]) {
2148          case atInt:
2149            Predicate.SetIntVal(RelevantCols[i], RowI.GetIntAttr(RelevantCols[i]));
2150            break;
2151          case atFlt:
2152            Predicate.SetFltVal(RelevantCols[i], RowI.GetFltAttr(RelevantCols[i]));
2153            break;
2154          case atStr:
2155            Predicate.SetStrVal(RelevantCols[i], RowI.GetStrAttr(RelevantCols[i]));
2156            break;
2157          }
2158        }
2159        if (Predicate.Eval()) { SelectedRows.Add(RowI.GetRowIdx()); }
2160      }
2161    }
2162  }
2163  void TTable::Classify(TPredicate&amp; Predicate, const TStr&amp; LabelName, const TInt&amp; PositiveLabel, const TInt&amp; NegativeLabel) {
2164    TIntV SelectedRows;
2165    Select(Predicate, SelectedRows, false);
2166    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2167  }
2168  void TTable::SelectAtomic(const TStr&amp; Col1, const TStr&amp; Col2, TPredComp Cmp, TIntV&amp; SelectedRows, TBool Remove) {
2169    const TAttrType Ty1 = GetColType(Col1);
2170    const TAttrType Ty2 = GetColType(Col2);
2171    const TInt ColIdx1 = GetColIdx(Col1);
2172    const TInt ColIdx2 = GetColIdx(Col2);
2173    if (Ty1 != Ty2) {
2174      TExcept::Throw(&quot;SelectAtomic: diff types&quot;);
2175    }
2176    if (Cmp == SUBSTR || Cmp == SUPERSTR) { Assert(Ty1 == atStr); }
2177    if (Remove) {
2178      TRowIteratorWithRemove RowI = BegRIWR();
2179      while (RowI.GetNextRowIdx() != Last) {
2180        TBool Result;
2181        switch (Ty1) {
2182          case atInt:
2183            Result = TPredicate::EvalAtom(RowI.GetNextIntAttr(ColIdx1), RowI.GetNextIntAttr(ColIdx2), Cmp);
2184            break;
2185          case atFlt:
2186            Result = TPredicate::EvalAtom(RowI.GetNextFltAttr(ColIdx1), RowI.GetNextFltAttr(ColIdx2), Cmp);
2187            break;
2188          case atStr:
2189            Result = TPredicate::EvalStrAtom(RowI.GetNextStrAttr(ColIdx1), RowI.GetNextStrAttr(ColIdx2), Cmp);
2190            break;
2191        }
2192        if (!Result) { 
2193          RowI.RemoveNext();
2194        } else {
2195          RowI++;
2196        }
2197      }
2198    } else {
2199      for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
2200        TBool Result;
2201        switch (Ty1) {
2202          case atInt:
2203            Result = TPredicate::EvalAtom(RowI.GetIntAttr(Col1), RowI.GetIntAttr(Col2), Cmp);
2204            break;
2205          case atFlt:
2206            Result = TPredicate::EvalAtom(RowI.GetFltAttr(Col1), RowI.GetFltAttr(Col2), Cmp);
2207            break;
2208          case atStr:
2209            Result = TPredicate::EvalStrAtom(RowI.GetStrAttr(Col1), RowI.GetStrAttr(Col2), Cmp);
2210            break;
2211        }
2212        if (Result) { SelectedRows.Add(RowI.GetRowIdx()); }
2213      }
2214    }
2215  }
2216  void TTable::ClassifyAtomic(const TStr&amp; Col1, const TStr&amp; Col2, TPredComp Cmp,
2217    const TStr&amp; LabelName, const TInt&amp; PositiveLabel, const TInt&amp; NegativeLabel) {
2218    TIntV SelectedRows;
2219    SelectAtomic(Col1, Col2, Cmp, SelectedRows, false);
2220    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2221  }
2222  void TTable::SelectAtomicConst(const TStr&amp; Col, const TPrimitive&amp; Val, TPredComp Cmp, 
2223    TIntV&amp; SelectedRows, PTable&amp; SelectedTable, TBool Remove, TBool Table) {
2224    TStr ValTStr(Val.GetStr());
2225    TAttrType Type = GetColType(Col);
2226    TInt ColIdx = GetColIdx(Col);
2227    if (Type != Val.GetType()) { 
2228      TExcept::Throw(&quot;SelectAtomicConst: coltype does not match const type&quot;); 
2229    }
2230    if(Remove){
2231  #ifdef USE_OPENMP
2232      if (GetMP()) {
2233        TIntPrV Partitions;
2234        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2235        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2236        int RemoveCount = 0;
2237        TIntPrV Bounds(Partitions.Len());
2238        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:RemoveCount)
2239        for (int i = 0; i &lt; Partitions.Len(); i++){
2240          TRowIterator RowI(Partitions[i].GetVal1(), this);
2241          TRowIterator EndI(Partitions[i].GetVal2(), this);
2242          TInt FirstRowIdx = TTable::Invalid;
2243          TInt LastRowIdx = TTable::Invalid;
2244          TBool First = true;
2245          while (RowI &lt; EndI) {
2246            TInt CurrRowIdx = RowI.GetRowIdx();
2247            TBool Result;
2248            if (Type != atStr) {
2249              Result = RowI.CompareAtomicConst(ColIdx, Val, Cmp);
2250            } else {
2251              Result = RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp);
2252            }
2253            RowI++;
2254            if(!Result) {
2255              Next[CurrRowIdx] = TTable::Invalid;
2256              RemoveCount++;
2257            } else { 
2258              if (First) { FirstRowIdx = CurrRowIdx; First = false; } 
2259              else { Next[LastRowIdx] = CurrRowIdx; }
2260              LastRowIdx = CurrRowIdx; 
2261            }
2262          }
2263          Bounds[i] = TIntPr(FirstRowIdx, LastRowIdx);
2264        }
2265        TInt CurrBound = 0;
2266        while (CurrBound &lt; Bounds.Len() &amp;&amp; Bounds[CurrBound].Val1 == TTable::Invalid) {
2267          CurrBound++;
2268        }
2269        if (CurrBound == Bounds.Len()) {
2270          Assert(NumValidRows == RemoveCount);
2271          NumValidRows = 0;
2272          FirstValidRow = TTable::Invalid;
2273          LastValidRow = TTable::Invalid;
2274        } else {
2275          NumValidRows -= RemoveCount;
2276          FirstValidRow = Bounds[CurrBound].Val1;
2277          LastValidRow = Bounds[CurrBound].Val2;
2278          TInt PrevBound = CurrBound;
2279          CurrBound++;
2280          while (CurrBound &lt; Bounds.Len()) {
2281            if (Bounds[CurrBound].Val1 == TTable::Invalid) { CurrBound++; continue; }
2282            Next[Bounds[PrevBound].Val2] = Bounds[CurrBound].Val1;
2283            LastValidRow = Bounds[CurrBound].Val2;
2284            PrevBound = CurrBound;
2285            CurrBound++;
2286          }
2287          Next[Bounds[PrevBound].Val2] = TTable::Last;
2288        }
2289        IsNextDirty = 1;
2290      } else {
2291  #endif
2292        TRowIteratorWithRemove RowI = BegRIWR();
2293        while(RowI.GetNextRowIdx() != Last){
2294          if (!RowI.CompareAtomicConst(ColIdx, Val, Cmp)) {
2295            RowI.RemoveNext();
2296          } else {
2297            RowI++;
2298          }
2299        }
2300        IsNextDirty = 1;
2301  #ifdef USE_OPENMP
2302      }
2303  #endif
2304    } else if (Table) {
2305  #ifdef USE_OPENMP
2306      if (GetMP()) {
2307        TIntPrV Partitions;
2308        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2309        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2310        int TotalSelectedRows = 0;
2311        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:TotalSelectedRows)
2312        for (int i = 0; i &lt; Partitions.Len(); i++){
2313          TRowIterator RowI(Partitions[i].GetVal1(), this);
2314          TRowIterator EndI(Partitions[i].GetVal2(), this);
2315          while (RowI &lt; EndI) {
2316            if (Type != atStr) {
2317              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2318                TotalSelectedRows++;
2319              }
2320            } else {
2321              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2322                TotalSelectedRows++;
2323              }
2324            }
2325            RowI++;
2326          }
2327        }
2328        SelectedTable-&gt;ResizeTable(TotalSelectedRows);
2329        if (TotalSelectedRows == 0) {
2330          return;
2331        }
2332        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
2333        for (int i = 0; i &lt; Partitions.Len(); i++){
2334          TIntV LocalSelectedRows;
2335          LocalSelectedRows.Reserve(PartitionSize);
2336          TRowIterator RowI(Partitions[i].GetVal1(), this);
2337          TRowIterator EndI(Partitions[i].GetVal2(), this);
2338          while (RowI &lt; EndI) {
2339            if (Type != atStr) {
2340              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2341                LocalSelectedRows.Add(RowI.GetRowIdx());
2342              }
2343            } else {
2344              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2345                LocalSelectedRows.Add(RowI.GetRowIdx());
2346              }
2347            }
2348            RowI++;
2349          }
2350          SelectedTable-&gt;AddSelectedRows(*this, LocalSelectedRows);
2351        }
2352        SelectedTable-&gt;SetFirstValidRow();
2353      } else {
2354  #endif
2355        for(TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++){
2356          if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2357            SelectedTable-&gt;AddRowI(RowI);
2358          }
2359        }
2360  #ifdef USE_OPENMP
2361      }
2362  #endif
2363    } else {
2364      for(TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++){
2365        if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2366          SelectedRows.Add(RowI.GetRowIdx());
2367        }
2368      }
2369    }
2370  }
2371  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TAttrType&amp; CompareByType, const TInt&amp; CompareByIndex, TBool Asc) {
2372    switch (CompareByType) {
2373      case atInt:{
2374        if (IntCols[CompareByIndex][R1] &gt; IntCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2375        if (IntCols[CompareByIndex][R1] &lt; IntCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2376        return 0;
2377      }
2378      case atFlt:{
2379        if (FltCols[CompareByIndex][R1] &gt; FltCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2380        if (FltCols[CompareByIndex][R1] &lt; FltCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2381        return 0;
2382      }
2383      case atStr:{
2384        TStr S1 = GetStrValIdx(CompareByIndex, R1);
2385        TStr S2 = GetStrValIdx(CompareByIndex, R2);
2386        int CmpRes = strcmp(S1.CStr(), S2.CStr());
2387        return (Asc ? CmpRes : -CmpRes);
2388      }
2389    }
2390    return 0;
2391  }
2392  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TVec&lt;TAttrType&gt;&amp; CompareByTypes, const TIntV&amp; CompareByIndices, TBool Asc) {
2393    for (TInt i = 0; i &lt; CompareByTypes.Len(); i++) {
2394      TInt res = CompareRows(R1, R2, CompareByTypes[i], CompareByIndices[i], Asc);
2395      if (res != 0) { return res; }
2396    }
2397    return 0;
2398  }
2399  void TTable::ISort(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2400    if (StartIdx &lt; EndIdx) {
2401      for (TInt i = StartIdx+1; i &lt;= EndIdx; i++) {
2402        TInt Val = V[i];
2403        TInt j = i;
2404        while ((StartIdx &lt; j) &amp;&amp; (CompareRows(V[j-1], Val, SortByTypes, SortByIndices, Asc) &gt; 0)) {
2405          V[j] = V[j-1];
2406          j--;
2407        }
2408        V[j] = Val;
2409      }
2410    }
2411  }
2412  TInt TTable::GetPivot(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2413    TInt L = EndIdx - StartIdx + 1;
2414    const TInt Idx1 = StartIdx + TInt::GetRnd(L);
2415    const TInt Idx2 = StartIdx + TInt::GetRnd(L);
2416    const TInt Idx3 = StartIdx + TInt::GetRnd(L);
2417    if (CompareRows(V[Idx1], V[Idx2], SortByTypes, SortByIndices, Asc) &lt; 0) {
2418      if (CompareRows(V[Idx2], V[Idx3], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx2; }
2419      if (CompareRows(V[Idx1], V[Idx3], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx3; }
2420      return Idx1;
2421    } else {
2422      if (CompareRows(V[Idx3], V[Idx2], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx2; }
2423      if (CompareRows(V[Idx3], V[Idx1], SortByTypes, SortByIndices, Asc) &lt; 0) { return Idx3; }
2424      return Idx1;
2425    }
2426  }
2427  TInt TTable::Partition(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2428    TInt j;
2429    for (j = StartIdx; j &lt; EndIdx; j++) {
2430      if (CompareRows(V[j], V[j+1], SortByTypes, SortByIndices, Asc) &gt; 0) {
2431        break;
2432      }
2433    }
2434    if (j &gt;= EndIdx) {
2435      return EndIdx+1;
2436    }
2437    TInt PivotIdx = GetPivot(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2438    TInt Pivot = V[PivotIdx];
2439    V.Swap(PivotIdx, EndIdx);
2440    TInt StoreIdx = StartIdx;
2441    for (TInt i = StartIdx; i &lt; EndIdx; i++) {
2442      if (CompareRows(V[i], Pivot, SortByTypes, SortByIndices, Asc) &lt;= 0) {
2443        V.Swap(i, StoreIdx);
2444        StoreIdx++;
2445      }
2446    }
2447    V.Swap(StoreIdx, EndIdx);
2448    return StoreIdx;
2449  }
2450  void TTable::QSort(TIntV&amp; V, TInt StartIdx, TInt EndIdx, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2451    if (StartIdx &lt; EndIdx) {
2452      if (EndIdx - StartIdx &lt; 20) {
2453        ISort(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2454      } else {
2455        TInt Pivot = Partition(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2456        if (Pivot &gt; EndIdx) {
2457          return;
2458        }
2459        int Ub = Pivot - 1;
2460        while (Ub &gt;= StartIdx &amp;&amp; CompareRows(
2461          V[Ub], V[Pivot], SortByTypes, SortByIndices, Asc) == 0) {
2462          Ub -= 1;
2463        }
2464        QSort(V, StartIdx, Ub, SortByTypes, SortByIndices, Asc);
2465        QSort(V, Pivot+1, EndIdx, SortByTypes, SortByIndices, Asc);
2466      }
2467    }
2468  }
2469  void TTable::Merge(TIntV&amp; V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2470    TInt i = Idx1, j = Idx2;
2471    TIntV SortedV;
2472    while  (i &lt; Idx2 &amp;&amp; j &lt; Idx3) {
2473      if (CompareRows(V[i], V[j], SortByTypes, SortByIndices, Asc) &lt;= 0) {
2474        SortedV.Add(V[i]);
2475        i++;
2476      }
2477      else {
2478        SortedV.Add(V[j]);
2479        j++;
2480      }
2481    }
2482    while (i &lt; Idx2) {
2483      SortedV.Add(V[i]);
2484      i++;
2485    }
2486    while (j &lt; Idx3) {
2487      SortedV.Add(V[j]);
2488      j++;
2489    }
2490    for (TInt sz = 0; sz &lt; Idx3 - Idx1; sz++) {
2491      V[Idx1 + sz] = SortedV[sz];
2492    }
2493  }
2494  #ifdef USE_OPENMP
2495  void TTable::QSortPar(TIntV&amp; V, const TVec&lt;TAttrType&gt;&amp; SortByTypes, const TIntV&amp; SortByIndices, TBool Asc) {
2496    TInt NumThreads = 8; 
2497    TInt Sz = V.Len();
2498    TIntV IndV, NextV;
2499    for (TInt i = 0; i &lt; NumThreads; i++) {
2500      IndV.Add(i * (Sz / NumThreads));
2501    }
2502    IndV.Add(Sz);
2503    omp_set_num_threads(NumThreads);
2504    #pragma omp parallel for
2505    for (int i = 0; i &lt; NumThreads; i++) {
2506      QSort(V, IndV[i], IndV[i+1] - 1, SortByTypes, SortByIndices, Asc);
2507    }
2508    while (NumThreads &gt; 1) {
2509      omp_set_num_threads(NumThreads / 2);
2510      #pragma omp parallel for
2511      for (int i = 0; i &lt; NumThreads; i += 2) {
2512        Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc);
2513      }
2514      NextV.Clr();
2515      for (TInt i = 0; i &lt; NumThreads; i+=2) {
2516        NextV.Add(IndV[i]);
2517      }
2518      NextV.Add(Sz);
2519      IndV = NextV;
2520      NumThreads = NumThreads / 2;
2521    }
2522  }
2523  #endif 
2524  void TTable::Order(const TStrV&amp; OrderBy, TStr OrderColName, TBool ResetRankByMSC, TBool Asc) {
2525    TIntV ValidRows = TIntV(NumValidRows);
2526    if (NumRows == NumValidRows) {
2527      for (TInt i = 0; i &lt; NumValidRows; i++) {
2528        ValidRows[i] = i;
2529      }
2530    } else {
2531      TInt i = 0;
2532      for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
2533        ValidRows[i] = RI.GetRowIdx();
2534        i++;
2535      }
2536    }
2537    TVec&lt;TAttrType&gt; OrderByTypes(OrderBy.Len());
2538    TIntV OrderByIndices(OrderBy.Len());
2539    for (TInt i = 0; i &lt; OrderBy.Len(); i++) {
2540      OrderByTypes[i] = GetColType(OrderBy[i]);
2541      OrderByIndices[i] = GetColIdx(OrderBy[i]);
2542    }
2543  #ifdef USE_OPENMP
2544    if (GetMP()) {
2545      QSortPar(ValidRows, OrderByTypes, OrderByIndices, Asc);
2546    } else {
2547  #endif
2548      QSort(ValidRows, 0, NumValidRows-1, OrderByTypes, OrderByIndices, Asc);
2549  #ifdef USE_OPENMP
2550    }
2551  #endif
2552    IsNextDirty = 1;
2553    if (NumValidRows &gt; 0) {
2554      FirstValidRow = ValidRows[0];
2555    } else {
2556      FirstValidRow = Last;
2557    }
2558    for (TInt i = 0; i &lt; NumValidRows-1; i++) {
2559      Next[ValidRows[i]] = ValidRows[i+1];
2560    }
2561    if (NumValidRows &gt; 0) {
2562      Next[ValidRows[NumValidRows-1]] = Last;
2563      LastValidRow = ValidRows[NumValidRows-1];
2564    } else {
2565      LastValidRow = Last;
2566    }
2567    if (!OrderColName.Empty()) {
2568      TIntV RankCol = TIntV(NumRows);
2569      for (TInt i = 0; i &lt; NumValidRows; i++) {
2570        RankCol[ValidRows[i]] = i;
2571      }
2572      if (ResetRankByMSC) {
2573        for (TInt i = 1; i &lt; NumValidRows; i++) {
2574          TStr GroupName = OrderBy[0];
2575          if (GetStrVal(GroupName, ValidRows[i]) != GetStrVal(GroupName, ValidRows[i-1])) { 
2576            RankCol[ValidRows[i]] = 0;
2577          } else {
2578            RankCol[ValidRows[i]] = RankCol[ValidRows[i-1]] + 1;
2579          }
2580        }
2581      }
2582      IntCols.Add(RankCol);
2583      AddSchemaCol(OrderColName, atInt);
2584      AddColType(OrderColName, atInt, IntCols.Len()-1);
2585    }
2586  }
2587  void TTable::Defrag() {
2588    TInt FreeIndex = 0;
2589    TIntV Mapping;  
2590    TInt IdColIdx = GetColIdx(IdColName);
2591    for (TInt i = 0; i &lt; Next.Len(); i++) {
2592      if (Next[i] != TTable::Invalid) {  
2593        if (FreeIndex == 0) {
2594          Assert (i == FirstValidRow);
2595          FirstValidRow = 0;
2596        }
2597        if (Next[i] != Last) { 
2598          Next[FreeIndex] = FreeIndex + 1;
2599          Mapping.Add(FreeIndex);
2600        } else {
2601          Next[FreeIndex] = Last;
2602          LastValidRow = FreeIndex;
2603          Mapping.Add(Last);
2604        }
2605        RowIdMap.AddDat(IntCols[IdColIdx][i], FreeIndex);
2606        for (TInt j = 0; j &lt; IntCols.Len(); j++) {
2607          IntCols[j][FreeIndex] = IntCols[j][i];
2608        }
2609        for (TInt j = 0; j &lt; FltCols.Len(); j++) {
2610          FltCols[j][FreeIndex] = FltCols[j][i];
2611        }
2612        for (TInt j = 0; j &lt; StrColMaps.Len(); j++) {
2613          StrColMaps[j][FreeIndex] = StrColMaps[j][i];
2614        }
2615        FreeIndex++;
2616      } else {
2617        NumRows--;
2618        Mapping.Add(TTable::Invalid);
2619      }
2620    }
2621    Assert (NumValidRows == NumRows);
2622  }
2623  void TTable::SelectFirstNRows(const TInt&amp; N) {
2624    if (N == 0) {
2625      LastValidRow = -1;
2626      return;
2627    }
2628    TRowIterator RowI = BegRI();
2629    TInt count = 1;
2630    while (count &lt; N) {
2631      if (!(RowI &lt; EndRI())) {
2632        return; 
2633      }
2634      RowI++;
2635      count++;
2636    }
2637    NumValidRows = N;
2638    TInt LastId = RowI.GetRowIdx();
2639    if (Next[LastId] == Last) {
2640      return; 
2641    }
2642    TInt CurrId = LastId;
2643    while (Next[CurrId] != Last) {
2644      Assert(Next[CurrId] != Invalid);
2645      TInt NextId = Next[CurrId];
2646      Next[CurrId] = Invalid;
2647      CurrId = NextId;
2648    }
2649    Next[LastId] = Last;
2650    LastValidRow = LastId;
2651  }
2652  inline void TTable::CheckAndAddIntNode(PNEANet Graph, THashSet&lt;TInt&gt;&amp; NodeVals, TInt NodeId) {
2653    if (!NodeVals.IsKey(NodeId)) {
2654      Graph-&gt;AddNode(NodeId);
2655      NodeVals.AddKey(NodeId);
2656    }
2657  }
2658  inline void TTable::AddEdgeAttributes(PNEANet&amp; Graph, int RowId) {
2659    for (TInt i = 0; i &lt; EdgeAttrV.Len(); i++) {
2660      TStr ColName = EdgeAttrV[i];
2661      TAttrType T = GetColType(ColName);
2662      TInt Index = GetColIdx(ColName);
2663      switch (T) {
2664        case atInt:
2665          Graph-&gt;AddIntAttrDatE(RowId, IntCols[Index][RowId], ColName);
2666          break;
2667        case atFlt:
2668          Graph-&gt;AddFltAttrDatE(RowId, FltCols[Index][RowId], ColName);
2669          break;
2670        case atStr:
2671          Graph-&gt;AddStrAttrDatE(RowId, GetStrValIdx(Index, RowId), ColName);
2672          break;
2673      }
2674    }
2675  }
2676  inline void TTable::AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId, THash&lt;TInt, TStrIntVH&gt;&amp; NodeIntAttrs,
2677    THash&lt;TInt, TStrFltVH&gt;&amp; NodeFltAttrs, THash&lt;TInt, TStrStrVH&gt;&amp; NodeStrAttrs) {
2678    for (TInt i = 0; i &lt; NodeAttrV.Len(); i++) {
2679      TStr ColAttr = NodeAttrV[i];
2680      TAttrType CT = GetColType(ColAttr);
2681      int ColId = GetColIdx(ColAttr);
2682      for (TInt i = 0; i &lt; CommonNodeAttrs.Len(); i++) {
2683        if (CommonNodeAttrs[i].Val1 == ColAttr || CommonNodeAttrs[i].Val2 == ColAttr) {
2684          ColAttr = CommonNodeAttrs[i].Val3;
2685          break;
2686        }
2687      }
2688      if (CT == atInt) {
2689        if (!NodeIntAttrs.IsKey(NId)) { NodeIntAttrs.AddKey(NId); }
2690        if (!NodeIntAttrs.GetDat(NId).IsKey(ColAttr)) { NodeIntAttrs.GetDat(NId).AddKey(ColAttr); }
2691        NodeIntAttrs.GetDat(NId).GetDat(ColAttr).Add(IntCols[ColId][RowId]);
2692      } else if (CT == atFlt) {
2693        if (!NodeFltAttrs.IsKey(NId)) { NodeFltAttrs.AddKey(NId); }
2694        if (!NodeFltAttrs.GetDat(NId).IsKey(ColAttr)) { NodeFltAttrs.GetDat(NId).AddKey(ColAttr); }
2695        NodeFltAttrs.GetDat(NId).GetDat(ColAttr).Add(FltCols[ColId][RowId]);
2696      } else {
2697        if (!NodeStrAttrs.IsKey(NId)) { NodeStrAttrs.AddKey(NId); }
2698        if (!NodeStrAttrs.GetDat(NId).IsKey(ColAttr)) { NodeStrAttrs.GetDat(NId).AddKey(ColAttr); }
2699        NodeStrAttrs.GetDat(NId).GetDat(ColAttr).Add(GetStrValIdx(ColId, RowId));
2700      }
2701    }
2702  }
2703  PNEANet TTable::BuildGraph(const TIntV&amp; RowIds, TAttrAggr AggrPolicy) {
2704    PNEANet Graph = TNEANet::New();
2705    const TAttrType NodeType = GetColType(SrcCol);
2706    Assert(NodeType == GetColType(DstCol));
2707    const TInt SrcColIdx = GetColIdx(SrcCol);
2708    const TInt DstColIdx = GetColIdx(DstCol);
2709    THash&lt;TFlt, TInt&gt; FltNodeVals;
2710    THash&lt;TInt, TStrIntVH&gt; NodeIntAttrs;
2711    THash&lt;TInt, TStrFltVH&gt; NodeFltAttrs;
2712    THash&lt;TInt, TStrStrVH&gt; NodeStrAttrs;
2713    for (TVec&lt;TInt&gt;::TIter it = RowIds.BegI(); it &lt; RowIds.EndI(); it++) {
2714      TInt CurrRowIdx = *it;
2715      TInt SVal, DVal;
2716      if (NodeType == atFlt) {
2717        TFlt FSVal = FltCols[SrcColIdx][CurrRowIdx];
2718        SVal = CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
2719        TFlt FDVal = FltCols[SrcColIdx][CurrRowIdx];
2720        DVal = CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
2721      } else if (NodeType == atInt || NodeType == atStr) {
2722        if (NodeType == atInt) {
2723          SVal = IntCols[SrcColIdx][CurrRowIdx];
2724          DVal = IntCols[DstColIdx][CurrRowIdx];
2725        } else {
2726          SVal = StrColMaps[SrcColIdx][CurrRowIdx];
2727          if (strlen(Context-&gt;StringVals.GetKey(SVal)) == 0) { continue; }  
2728          DVal = StrColMaps[DstColIdx][CurrRowIdx];
2729          if (strlen(Context-&gt;StringVals.GetKey(DVal)) == 0) { continue; }  
2730        }
2731        if (!Graph-&gt;IsNode(SVal)) { Graph-&gt;AddNode(SVal); }
2732        if (!Graph-&gt;IsNode(DVal)) { Graph-&gt;AddNode(DVal); }
2733      } 
2734      Graph-&gt;AddEdge(SVal, DVal, CurrRowIdx);
2735      if (EdgeAttrV.Len() &gt; 0) { AddEdgeAttributes(Graph, CurrRowIdx); }
2736      if (SrcNodeAttrV.Len() &gt; 0) { 
2737        AddNodeAttributes(SVal, SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2738      }
2739      if (DstNodeAttrV.Len() &gt; 0) {
2740        AddNodeAttributes(DVal, DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2741      }
2742    }
2743    if (SrcNodeAttrV.Len() &gt; 0 || DstNodeAttrV.Len() &gt; 0) {
2744      for (TNEANet::TNodeI NodeI = Graph-&gt;BegNI(); NodeI &lt; Graph-&gt;EndNI(); NodeI++) {
2745        TInt NId = NodeI.GetId();
2746        if (NodeIntAttrs.IsKey(NId)) {
2747          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
2748          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it &lt; IntAttrVals.EndI(); it++) {
2749            TInt AttrVal = AggregateVector&lt;TInt&gt;(it.GetDat(), AggrPolicy);
2750            Graph-&gt;AddIntAttrDatN(NId, AttrVal, it.GetKey());
2751          }
2752        }
2753        if (NodeFltAttrs.IsKey(NId)) {
2754          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
2755          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it &lt; FltAttrVals.EndI(); it++) {
2756            TFlt AttrVal = AggregateVector&lt;TFlt&gt;(it.GetDat(), AggrPolicy);
2757            Graph-&gt;AddFltAttrDatN(NId, AttrVal, it.GetKey());
2758          }
2759        }
2760        if (NodeStrAttrs.IsKey(NId)) {
2761          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
2762          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it &lt; StrAttrVals.EndI(); it++) {
2763            TStr AttrVal = AggregateVector&lt;TStr&gt;(it.GetDat(), AggrPolicy);
2764            Graph-&gt;AddStrAttrDatN(NId, AttrVal, it.GetKey());
2765          }
2766        }
2767      }
2768    }
2769    return Graph;
2770  }
2771  void TTable::InitRowIdBuckets(int NumBuckets) {
2772    for (TInt i = 0; i &lt; RowIdBuckets.Len(); i++) {
2773      RowIdBuckets[i].Clr();
2774    }
2775    RowIdBuckets.Clr();
2776    RowIdBuckets.Gen(NumBuckets);
2777    for (TInt i = 0; i &lt; NumBuckets; i++) {
2778      RowIdBuckets[i].Gen(10, 0);
2779    }
2780  }
2781  void TTable::FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize, TInt StartVal, TInt EndVal) {
2782    Assert (JumpSize &lt;= WindowSize);
2783    int NumBuckets, MinBucket, MaxBucket;
2784    TInt SplitColId = GetColIdx(SplitAttr);
2785    if (StartVal == TInt::Mn || EndVal == TInt::Mx) {
2786      TInt MinValue = TInt::Mx;
2787      TInt MaxValue = TInt::Mn;
2788      for (TInt i = 0; i &lt; Next.Len(); i++) {
2789        if (Next[i] != Invalid) { 
2790          if (MinValue &gt; IntCols[SplitColId][i]) {
2791            MinValue = IntCols[SplitColId][i];
2792          }
2793          if (MaxValue &lt; IntCols[SplitColId][i]) {
2794            MaxValue = IntCols[SplitColId][i];
2795          }
2796        }
2797      }
2798      if (StartVal == TInt::Mn) StartVal = MinValue;
2799      if (EndVal == TInt::Mx) EndVal = MaxValue;
2800    }
2801    NumBuckets = 1;
2802    if (JumpSize &gt; 0) {
2803      NumBuckets = (EndVal - StartVal)/JumpSize + 1;
2804    }
2805    InitRowIdBuckets(NumBuckets);
2806    for (TInt i = 0; i &lt; Next.Len(); i++) {
2807      if (Next[i] == Invalid) { continue; }
2808      int SplitVal = IntCols[SplitColId][i];
2809      if (SplitVal &lt; StartVal || SplitVal &gt; EndVal) { continue; }
2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
2817        if (RowVal &lt; WindowSize) { MinBucket = 0; }
2818        else { MinBucket = (RowVal-WindowSize)/JumpSize + 1; }
2819        MaxBucket = RowVal/JumpSize;  
2820      }
2821      for (TInt j = MinBucket; j &lt;= MaxBucket; j++) { RowIdBuckets[j].Add(i); }
2822    }
2823  }
2824  void TTable::FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals) {
2825    TInt SplitColId = GetColIdx(SplitAttr);
2826    int NumBuckets = SplitIntervals.Len();
2827    InitRowIdBuckets(NumBuckets);
2828    for (TInt i = 0; i &lt; Next.Len(); i++) {
2829      if (Next[i] == Invalid) { continue; }
2830      int SplitVal = IntCols[SplitColId][i];
2831      for (TInt j = 0; j &lt; SplitIntervals.Len(); j++) { 
2832        if (SplitVal &gt;= SplitIntervals[j].Val1 &amp;&amp; SplitVal &lt; SplitIntervals[j].Val2) {
2833          RowIdBuckets[j].Add(i);
2834        }
2835      }
2836    }
2837  }
2838  TVec&lt;PNEANet&gt; TTable::GetGraphsFromSequence(TAttrAggr AggrPolicy) {
2839    TVec&lt;PNEANet&gt; GraphSequence;
2840    for (TInt i = 0; i &lt; RowIdBuckets.Len(); i++) {
2841      if (RowIdBuckets[i].Len() == 0) { continue; }
2842      PNEANet PNet = BuildGraph(RowIdBuckets[i], AggrPolicy);
2843      GraphSequence.Add(PNet);
2844    }
2845    return GraphSequence;
2846  }
2847  PNEANet TTable::GetFirstGraphFromSequence(TAttrAggr AggrPolicy) {
2848    CurrBucket = -1;
2849    this-&gt;AggrPolicy = AggrPolicy;
2850    return GetNextGraphFromSequence();
2851  }
2852  PNEANet TTable::GetNextGraphFromSequence() {
2853    CurrBucket++;
2854    while (CurrBucket &lt; RowIdBuckets.Len() &amp;&amp; RowIdBuckets[CurrBucket].Len() == 0) {
2855      CurrBucket++;
2856    }
2857    if (CurrBucket &gt;= RowIdBuckets.Len()) { return NULL; }
2858    return BuildGraph(RowIdBuckets[CurrBucket], AggrPolicy);
2859  }
2860  TVec&lt;PNEANet&gt; TTable::ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2861    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2862    printf(&quot;buckets filled\n&quot;);
2863    return GetGraphsFromSequence(AggrPolicy);  
2864  }
2865  TVec&lt;PNEANet&gt; TTable::ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2866    FillBucketsByInterval(SplitAttr, SplitIntervals);
2867    return GetGraphsFromSequence(AggrPolicy);
2868  }
2869  TVec&lt;PNEANet&gt; TTable::ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy) {
2870    return ToGraphSequence(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2871  }
2872  PNEANet TTable::ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2873    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2874    return GetFirstGraphFromSequence(AggrPolicy);  
2875  }
2876  PNEANet TTable::ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2877    FillBucketsByInterval(SplitAttr, SplitIntervals);
2878    return GetFirstGraphFromSequence(AggrPolicy);
2879  }
2880  PNEANet TTable::ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy) {
2881    return ToGraphSequenceIterator(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2882  }
2883  PNEANet TTable::NextGraphIterator() {
2884    return GetNextGraphFromSequence();
2885  }
2886  TBool TTable::IsLastGraphOfSequence() {
2887    return CurrBucket &gt;= RowIdBuckets.Len() - 1;
2888  }
2889  PTable TTable::GetNodeTable(const PNEANet&amp; Network, TTableContext* Context) {
2890    Schema SR;
2891    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;node_id&quot;,atInt));
2892    TStrV IntAttrNames;
2893    TStrV FltAttrNames;
2894    TStrV StrAttrNames;
2895    TNEANet::TNodeI NodeI = Network-&gt;BegNI();
2896    NodeI.GetIntAttrNames(IntAttrNames);
2897    NodeI.GetFltAttrNames(FltAttrNames);
2898    NodeI.GetStrAttrNames(StrAttrNames);
2899    for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2900      SR.Add(TPair&lt;TStr,TAttrType&gt;(IntAttrNames[i],atInt));
2901    }
2902    for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2903      SR.Add(TPair&lt;TStr,TAttrType&gt;(FltAttrNames[i],atFlt));
2904    }
2905    for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2906      SR.Add(TPair&lt;TStr,TAttrType&gt;(StrAttrNames[i],atStr));
2907    }
2908    PTable T = New(SR, Context);
2909    TInt Cnt = 0;
2910    while (NodeI &lt; Network-&gt;EndNI()) {
2911      T-&gt;IntCols[0].Add(NodeI.GetId());
2912      for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2913        T-&gt;IntCols[i+1].Add(Network-&gt;GetIntAttrDatN(NodeI,IntAttrNames[i]));
2914      }
2915      for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2916        T-&gt;FltCols[i].Add(Network-&gt;GetFltAttrDatN(NodeI,FltAttrNames[i]));
2917      }
2918      for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2919        T-&gt;AddStrVal(i, Network-&gt;GetStrAttrDatN(NodeI,StrAttrNames[i]));
2920      }
2921      Cnt++;
2922      NodeI++;
2923    }
2924    T-&gt;NumRows = Cnt;
2925    T-&gt;NumValidRows = T-&gt;NumRows;
2926    T-&gt;Next = TIntV(T-&gt;NumRows,0);
2927    for (TInt i = 0; i &lt; T-&gt;NumRows-1; i++) {
2928      T-&gt;Next.Add(i+1);
2929    }
2930    T-&gt;LastValidRow = T-&gt;NumRows-1;
2931    T-&gt;Next.Add(Last);
2932    return T;
2933  }
2934  PTable TTable::GetEdgeTable(const PNEANet&amp; Network, TTableContext* Context) {
2935    Schema SR;
2936    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;edg_id&quot;,atInt));
2937    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;src_id&quot;,atInt));
2938    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;dst_id&quot;,atInt));
2939    TStrV IntAttrNames;
2940    TStrV FltAttrNames;
2941    TStrV StrAttrNames;
2942    TNEANet::TEdgeI EdgeI = Network-&gt;BegEI();
2943    EdgeI.GetIntAttrNames(IntAttrNames);
2944    EdgeI.GetFltAttrNames(FltAttrNames);
2945    EdgeI.GetStrAttrNames(StrAttrNames);
2946    for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2947      SR.Add(TPair&lt;TStr,TAttrType&gt;(IntAttrNames[i],atInt));
2948    }
2949    for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2950      SR.Add(TPair&lt;TStr,TAttrType&gt;(FltAttrNames[i],atFlt));
2951    }
2952    for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2953      SR.Add(TPair&lt;TStr,TAttrType&gt;(StrAttrNames[i],atStr));
2954    }
2955    PTable T = New(SR, Context);
2956    TInt Cnt = 0;
2957    while (EdgeI &lt; Network-&gt;EndEI()) {
2958      T-&gt;IntCols[0].Add(EdgeI.GetId());
2959      T-&gt;IntCols[1].Add(EdgeI.GetSrcNId());
2960      T-&gt;IntCols[2].Add(EdgeI.GetDstNId());
2961      for (TInt i = 0; i &lt; IntAttrNames.Len(); i++) {
2962        T-&gt;IntCols[i+3].Add(Network-&gt;GetIntAttrDatE(EdgeI,IntAttrNames[i]));
2963      }
2964      for (TInt i = 0; i &lt; FltAttrNames.Len(); i++) {
2965        T-&gt;FltCols[i].Add(Network-&gt;GetFltAttrDatE(EdgeI,FltAttrNames[i]));
2966      }
2967      for (TInt i = 0; i &lt; StrAttrNames.Len(); i++) {
2968        T-&gt;AddStrVal(i, Network-&gt;GetStrAttrDatE(EdgeI,StrAttrNames[i]));
2969      }
2970      Cnt++;
2971      EdgeI++;
2972    }
2973    T-&gt;NumRows = Cnt;
2974    T-&gt;NumValidRows = T-&gt;NumRows;
2975    T-&gt;Next = TIntV(T-&gt;NumRows,0);
2976    for (TInt i = 0; i &lt; T-&gt;NumRows-1; i++) {
2977      T-&gt;Next.Add(i+1);
2978    }
2979    T-&gt;LastValidRow = T-&gt;NumRows-1;
2980    T-&gt;Next.Add(Last);
2981    return T;
2982  }
2983  #ifdef GCC_ATOMIC
2984  PTable TTable::GetEdgeTablePN(const PNGraphMP&amp; Network, TTableContext* Context){
2985    Schema SR;
2986    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;src_id&quot;,atInt));
2987    SR.Add(TPair&lt;TStr,TAttrType&gt;(&quot;dst_id&quot;,atInt));
2988    TNGraphMP::TEdgeI FirstEI = Network-&gt;BegEI();
2989    PTable T = New(SR, Context);
2990    TInt NumEdges = Network-&gt;GetEdges();
2991    TInt NumPartitions = omp_get_max_threads()*CHUNKS_PER_THREAD;
2992    TInt PartitionSize = NumEdges/NumPartitions;
2993    if (PartitionSize*NumPartitions &lt; NumEdges) { NumPartitions++;}
2994    typedef TPair&lt;TNGraphMP::TEdgeI, TNGraphMP::TEdgeI&gt; TEIPr;
2995    TVec&lt;TEIPr&gt; Partitions;
2996    TIntV PartitionSizes;
2997    TNGraphMP::TEdgeI currStart = FirstEI;
2998    TInt currCount = 0;
2999    while (FirstEI &lt; Network-&gt;EndEI()){
3000      if (currCount == PartitionSize) {
3001        Partitions.Add(TEIPr(currStart, FirstEI));
3002        currStart = FirstEI;
3003        PartitionSizes.Add(currCount);
3004        currCount = 0;
3005      }
3006      FirstEI++;
3007      currCount++;
3008    }
3009    Partitions.Add(TEIPr(currStart, FirstEI));
3010    PartitionSizes.Add(currCount);
3011    T-&gt;ResizeTable(NumEdges);
3012    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3013    for (int p = 0; p &lt; Partitions.Len(); p++) {
3014      TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();
3015      TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();
3016      int start = T-&gt;GetEmptyRowsStart(PartitionSizes[p]);
3017      while (EdgeI &lt; EndI) {
3018        T-&gt;IntCols[0][start] = EdgeI.GetSrcNId();
3019        T-&gt;IntCols[1][start] = EdgeI.GetDstNId();
3020        EdgeI++;
3021        if (EdgeI &lt; EndI) { T-&gt;Next[start] = start+1;}
3022        start++;
3023      }
3024    }
3025    Assert(T-&gt;NumRows == NumEdges);
3026    return T;
3027  }
3028  #endif 
3029  PTable TTable::GetFltNodePropertyTable(const PNEANet&amp; Network, const TIntFltH&amp; Property, 
3030   const TStr&amp; NodeAttrName, const TAttrType&amp; NodeAttrType, const TStr&amp; PropertyAttrName, 
3031   TTableContext* Context) {
3032    Schema SR;
3033    SR.Add(TPair&lt;TStr,TAttrType&gt;(NodeAttrName,NodeAttrType));
3034    SR.Add(TPair&lt;TStr,TAttrType&gt;(PropertyAttrName,atFlt));
3035    PTable T = New(SR, Context);
3036    TInt NodeColIdx = T-&gt;GetColIdx(NodeAttrName);
3037    TInt Cnt = 0;
3038    for (TNEANet::TNodeI NodeI = Network-&gt;BegNI(); NodeI &lt; Network-&gt;EndNI(); NodeI++) {
3039      switch (NodeAttrType) {
3040        case atInt:
3041          T-&gt;IntCols[NodeColIdx].Add(Network-&gt;GetIntAttrDatN(NodeI,NodeAttrName));
3042          break;
3043        case atFlt:
3044          T-&gt;FltCols[NodeColIdx].Add(Network-&gt;GetFltAttrDatN(NodeI,NodeAttrName));
3045          break;
3046        case atStr:
3047          T-&gt;AddStrVal(TInt(0), Network-&gt;GetStrAttrDatN(NodeI,NodeAttrName));
3048          break;
3049      }
3050      T-&gt;FltCols[0].Add(Property.GetDat(NodeI.GetId()));
3051      Cnt++;
3052    }
3053    T-&gt;NumRows = Cnt;
3054    T-&gt;NumValidRows = T-&gt;NumRows;
3055    T-&gt;Next = TIntV(T-&gt;NumRows,0);
3056    for (TInt i = 0; i &lt; T-&gt;NumRows-1; i++) {
3057      T-&gt;Next.Add(i+1);
3058    }
3059    T-&gt;LastValidRow = T-&gt;NumRows-1;
3060    T-&gt;Next.Add(Last);
3061    return T;
3062  }
3063  PTable TTable::IsNextK(const TStr&amp; OrderCol, TInt K, const TStr&amp; GroupBy, const TStr&amp; RankColName) {
3064    TStrV OrderBy;
3065    if (GroupBy.Empty()) {
3066      OrderBy.Add(OrderCol);
3067    } else {
3068      OrderBy.Add(GroupBy);
3069      OrderBy.Add(OrderCol);
3070    }
3071    if (RankColName.Empty()) {
3072      Order(OrderBy);
3073    } else {
3074      Order(OrderBy, RankColName, true);
3075    }
3076    TAttrType GroupByAttrType = GetColType(GroupBy);
3077    PTable T = InitializeJointTable(*this);
3078    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3079      TInt Succ = RI.GetRowIdx();
3080      TBool OutOfGroup = false;
3081      for (TInt i = 0; i &lt; K; i++) {
3082        Succ = Next[Succ];
3083        if (Succ == Last) { break; }
3084        switch (GroupByAttrType) {
3085          case atInt:
3086            if (GetIntVal(GroupBy, Succ) != RI.GetIntAttr(GroupBy)) { OutOfGroup = true; }
3087            break;
3088          case atFlt:
3089            if (GetFltVal(GroupBy, Succ) != RI.GetFltAttr(GroupBy)) { OutOfGroup = true; }
3090            break;
3091          case atStr:
3092            if (GetStrVal(GroupBy, Succ) != RI.GetStrAttr(GroupBy)) { OutOfGroup = true; }
3093            break;
3094        }
3095        if (OutOfGroup) { break; }  
3096        T-&gt;AddJointRow(*this, *this, RI.GetRowIdx(), Succ);
3097      }
3098    }
3099    return T;
3100  }
3101  void TTable::PrintSize(){
3102  	printf(&quot;Total number of rows: %d\n&quot;, NumRows.Val);
3103  	printf(&quot;Number of valid rows: %d\n&quot;, NumValidRows.Val);
3104  	printf(&quot;Number of Int columns: %d\n&quot;, IntCols.Len());
3105  	printf(&quot;Number of Flt columns: %d\n&quot;, FltCols.Len());
3106  	printf(&quot;Number of Str columns: %d\n&quot;, StrColMaps.Len());
3107  	TSize MemUsed = GetMemUsedKB();
3108  	printf(&quot;Approximate table size is %s KB\n&quot;, TUInt64::GetStr(MemUsed).CStr());
3109  }
3110  TSize TTable::GetMemUsedKB() {
3111    TSize ApproxSize = 0;
3112    ApproxSize += Next.GetMemUsed()/1000;  
3113    for(int i = 0; i &lt; IntCols.Len(); i++){
3114    	ApproxSize += IntCols[i].GetMemUsed()/1000;
3115    }
3116    for(int i = 0; i &lt; FltCols.Len(); i++){
3117    	ApproxSize += FltCols[i].GetMemUsed()/1000;
3118    }
3119    for(int i = 0; i &lt; StrColMaps.Len(); i++){
3120    	ApproxSize += StrColMaps[i].GetMemUsed()/1000;
3121    }
3122    ApproxSize += RowIdMap.GetMemUsed()/1000;
3123    ApproxSize += GroupIDMapping.GetMemUsed()/1000;
3124    ApproxSize += GroupMapping.GetMemUsed()/1000;
3125    ApproxSize += RowIdBuckets.GetMemUsed() / 1000;
3126    return ApproxSize;
3127  }
3128  void TTable::PrintContextSize(){
3129  	printf(&quot;Number of strings in pool: &quot;);
3130  	printf(&quot;%d\n&quot;, Context-&gt;StringVals.Len());
3131  	printf(&quot;Number of entries in hash table: &quot;);
3132  	printf(&quot;%d\n&quot;, Context-&gt;StringVals.Reserved());
3133  	TSize MemUsed = GetContextMemUsedKB();
3134  	printf(&quot;Approximate context size is %s KB\n&quot;,
3135            TUInt64::GetStr(MemUsed).CStr());
3136  }
3137  TSize TTable::GetContextMemUsedKB(){
3138  	TSize ApproxSize = 0;
3139  	ApproxSize += Context-&gt;StringVals.GetMemUsed();
3140  	return ApproxSize;
3141  }
3142  void TTable::AddTable(const TTable&amp; T) {
3143    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3144      TStr ColName = GetSchemaColName(c);
3145      TInt ColIdx = GetColIdx(ColName);
3146      TInt TColIdx = ColName == IdColName ? T.GetColIdx(T.IdColName) : T.GetColIdx(ColName);
3147      if (TColIdx &lt; 0) { TExcept::Throw(&quot;when adding a table, it must contain all columns of source table!&quot;); }
3148      switch (GetColType(ColName)) { 
3149      case atInt:
3150         IntCols[ColIdx].AddV(T.IntCols[TColIdx]);
3151         break;
3152      case atFlt:
3153         FltCols[ColIdx].AddV(T.FltCols[TColIdx]);
3154         break;
3155      case atStr:
3156         StrColMaps[ColIdx].AddV(T.StrColMaps[TColIdx]);
3157         break;
3158      }
3159    }
3160    TIntV TNext(T.Next);
3161    for (TInt i = 0; i &lt; TNext.Len(); i++) {
3162      if (TNext[i] != Last &amp;&amp; TNext[i] != Invalid) { TNext[i] += NumRows; }
3163    }
3164    Next.AddV(TNext);
3165    if (LastValidRow &gt;= 0) {
3166      Next[LastValidRow] = NumRows + T.FirstValidRow;
3167    }
3168    LastValidRow = NumRows + T.LastValidRow;
3169    NumRows += T.NumRows;
3170    NumValidRows += T.NumValidRows;
3171  }
3172  void TTable::GetCollidingRows(const TTable&amp; Table, THashSet&lt;TInt&gt;&amp; Collisions) {
3173    TIntV UniqueVec;
3174    THash&lt;TGroupKey, TPair&lt;TInt, TIntV&gt; &gt;Grouping;
3175    TStrV GroupBy;
3176    TIntV IntGroupByCols;
3177    TIntV FltGroupByCols;
3178    TIntV StrGroupByCols;
3179    TInt IKLen, FKLen, SKLen;
3180    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3181      if (Sch[c].Val1 == IdColName) {
3182        if (Table.Sch[c].Val1 != Table.GetIdColName()) {
3183          TExcept::Throw(&quot;GetCollidingRows: schemas do not match!&quot;);
3184        }
3185        continue;
3186      }
3187      if (Sch[c] != Table.Sch[c]) {
3188        printf(&quot;(%s,%d) != (%s,%d)\n&quot;, Sch[c].Val1.CStr(), Sch[c].Val2, Table.Sch[c].Val1.CStr(), Table.Sch[c].Val2); 
3189        TExcept::Throw(&quot;GetCollidingRows: schemas do not match!&quot;);
3190      }
3191      GroupBy.Add(NormalizeColName(Sch[c].Val1));
3192      TPair&lt;TAttrType, TInt&gt; ColType = Table.GetColTypeMap(Sch[c].Val1);
3193      switch (ColType.Val1) {
3194        case atInt:
3195          IntGroupByCols.Add(ColType.Val2);
3196          break;
3197        case atFlt:
3198          FltGroupByCols.Add(ColType.Val2);
3199          break;
3200        case atStr:
3201          StrGroupByCols.Add(ColType.Val2);
3202          break;
3203      }
3204    }
3205    IKLen = IntGroupByCols.Len();
3206    FKLen = FltGroupByCols.Len();
3207    SKLen = StrGroupByCols.Len();
3208    GroupAux(GroupBy, Grouping, true, &quot;&quot;, false, UniqueVec, true);
3209    for (TRowIterator it = Table.BegRI(); it &lt; Table.EndRI(); it++) {
3210      TIntV IKey(IKLen + SKLen, 0);
3211      TFltV FKey(FKLen, 0);
3212      for (TInt c = 0; c &lt; IKLen; c++) {
3213        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
3214      }
3215      for (TInt c = 0; c &lt; FKLen; c++) {
3216        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
3217      }
3218      for (TInt c = 0; c &lt; SKLen; c++) {
3219        IKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
3220      }
3221      TGroupKey GroupKey = TGroupKey(IKey, FKey);
3222      TInt RowIdx = it.GetRowIdx();
3223      if (Grouping.IsKey(GroupKey)) {
3224        Collisions.AddKey(RowIdx);
3225      }
3226    }
3227  }
3228  void TTable::StoreIntCol(const TStr&amp; ColName, const TIntV&amp; ColVals) {
3229    if (ColVals.Len() != NumRows) {
3230      printf(&quot;new column dimension must agree with number of rows\n&quot;);
3231      return;
3232    }
3233    AddSchemaCol(ColName, atInt);
3234    IntCols.Add(TIntV(NumRows));
3235    TInt ColIdx = IntCols.Len()-1;
3236    TInt i = 0;
3237    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3238      IntCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3239      i++;
3240    }
3241    TInt L = IntCols.Len();
3242    AddColType(ColName, atInt, L-1);
3243  }
3244  void TTable::StoreFltCol(const TStr&amp; ColName, const TFltV&amp; ColVals) {
3245    if (ColVals.Len() != NumRows) {
3246      printf(&quot;new column dimension must agree with number of rows\n&quot;);
3247      return;
3248    }
3249    AddSchemaCol(ColName, atFlt);
3250    FltCols.Add(TFltV(NumRows));
3251    TInt ColIdx = FltCols.Len()-1;
3252    TInt i = 0;
3253    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3254      FltCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3255      i++;
3256    }
3257    TInt L = FltCols.Len();
3258    AddColType(ColName, atFlt, L-1);
3259  }
3260  void TTable::StoreStrCol(const TStr&amp; ColName, const TStrV&amp; ColVals) {
3261    if (ColVals.Len() != NumRows) {
3262      printf(&quot;new column dimension must agree with number of rows\n&quot;);
3263      return;
3264    }
3265    AddSchemaCol(ColName, atStr);
3266    StrColMaps.Add(TIntV(NumRows,0));
3267    TInt ColIdx = FltCols.Len()-1;
3268    TInt i = 0;
3269    for (TRowIterator RI = BegRI(); RI &lt; EndRI(); RI++) {
3270      TInt Key = Context-&gt;StringVals.GetKeyId(ColVals[i]);
3271      if (Key == -1) { Context-&gt;StringVals.AddKey(ColVals[i]); }
3272      StrColMaps[ColIdx][RI.GetRowIdx()] = Key;
3273      i++;
3274    }
3275    TInt L = StrColMaps.Len();
3276    AddColType(ColName, atStr, L-1);
3277  }
3278  void TTable::UpdateTableForNewRow() {
3279    if (LastValidRow &gt;= 0) {
3280      Next[LastValidRow] = NumRows;
3281    }
3282    Next.Add(Last);
3283    LastValidRow = NumRows;
3284    NumRows++;
3285    NumValidRows++;
3286  }
3287  #ifdef GCC_ATOMIC
3288  void TTable::SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal){
3289      if(!GetMP()){ TExcept::Throw(&quot;Not Using MP!&quot;);}
3290  	TIntPrV Partitions;
3291  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3292  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3293  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3294  	for (int i = 0; i &lt; Partitions.Len(); i++){
3295  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3296  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3297  		while(RowI &lt; EndI){
3298  			FltCols[UpdateColIdx][RowI.GetRowIdx()] = DefaultFltVal;
3299  			RowI++;
3300  		}
3301  	}
3302  }
3303  int sync_bool_compare_and_swap(int *lock) {
3304    return(__sync_bool_compare_and_swap(lock, 0, 1));
3305  }
3306  void TTable::UpdateFltFromTableMP(const TStr&amp; KeyAttr, const TStr&amp; UpdateAttr,
3307      const TTable&amp; Table, const TStr&amp; FKeyAttr, const TStr&amp; ReadAttr,
3308      TFlt DefaultFltVal) {
3309  	if (!GetMP()) {
3310      TExcept::Throw(&quot;Not Using MP!&quot;);
3311    }
3312    TAttrType KeyType = GetColType(KeyAttr);
3313    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3314    if(KeyType != FKeyType){TExcept::Throw(&quot;Key Type Mismatch&quot;);}
3315    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3316      TExcept::Throw(&quot;Expecting Float values&quot;);
3317    }
3318    TStr NKeyAttr = NormalizeColName(KeyAttr);
3319    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3320    TInt FKeyColIdx = GetColIdx(FKeyAttr);
3321    TInt ReadColIdx = GetColIdx(ReadAttr);
3322    SetFltColToConstMP(UpdateColIdx, DefaultFltVal);
3323  	TIntPrV Partitions;
3324  	Table.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3325  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3326  	TIntV Locks(NumRows);
3327  	Locks.PutAll(0);	
3328    switch (KeyType) {
3329      case atInt: {
3330          THashMP&lt;TInt,TIntV&gt; Grouping;
3331          GroupByIntColMP(NKeyAttr, Grouping, true);
3332          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3333  			  for (int i = 0; i &lt; Partitions.Len(); i++) {
3334  				  TRowIterator RowI(Partitions[i].GetVal1(), &amp;Table);
3335  				  TRowIterator EndI(Partitions[i].GetVal2(), &amp;Table);
3336  				  while (RowI &lt; EndI) {
3337              TInt K = RowI.GetIntAttr(FKeyColIdx);
3338              if (Grouping.IsKey(K)) {
3339                TIntV&amp; UpdateRows = Grouping.GetDat(K);
3340                for (int j = 0; j &lt; UpdateRows.Len(); j++) {
3341                  int* lock = &amp;Locks[UpdateRows[j]].Val;
3342                  if (!sync_bool_compare_and_swap(lock)) {
3343                    continue;
3344                  }
3345    							  FltCols[UpdateColIdx][UpdateRows[j]] = RowI.GetFltAttr(ReadColIdx);
3346                } 
3347              } 
3348              RowI++;
3349            } 
3350          }	
3351        } 
3352        break;
3353      default:
3354        break;
3355    } 
3356  }
3357  #endif	
3358  void TTable::UpdateFltFromTable(const TStr&amp; KeyAttr, const TStr&amp; UpdateAttr, const TTable&amp; Table, 
3359    const TStr&amp; FKeyAttr, const TStr&amp; ReadAttr, TFlt DefaultFltVal){
3360    if(!IsColName(KeyAttr)){ TExcept::Throw(&quot;Bad KeyAttr parameter&quot;);}
3361    if(!IsColName(UpdateAttr)){ TExcept::Throw(&quot;Bad UpdateAttr parameter&quot;);}
3362    if(!Table.IsColName(FKeyAttr)){ TExcept::Throw(&quot;Bad FKeyAttr parameter&quot;);}
3363    if(!Table.IsColName(ReadAttr)){ TExcept::Throw(&quot;Bad ReadAttr parameter&quot;);}
3364  #ifdef GCC_ATOMIC
3365    if(GetMP()){
3366      UpdateFltFromTableMP(KeyAttr, UpdateAttr,Table, FKeyAttr, ReadAttr, DefaultFltVal);
3367      return;
3368    }
3369  #endif	
3370    TAttrType KeyType = GetColType(KeyAttr);
3371    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3372    if(KeyType != FKeyType){TExcept::Throw(&quot;Key Type Mismatch&quot;);}
3373    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3374      TExcept::Throw(&quot;Expecting Float values&quot;);
3375    }
3376    TStr NKeyAttr = NormalizeColName(KeyAttr);
3377    TStr NUpdateAttr = NormalizeColName(UpdateAttr);
3378    TStr NFKeyAttr = Table.NormalizeColName(FKeyAttr);
3379    TStr NReadAttr = Table.NormalizeColName(ReadAttr);
3380    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3381    for(TRowIterator iter = BegRI(); iter &lt; EndRI(); iter++){
3382      FltCols[UpdateColIdx][iter.GetRowIdx()] = DefaultFltVal;
3383    }
3384    switch(KeyType) {
3385      case atInt: {
3386          TIntIntVH Grouping;
3387          GroupByIntCol(NKeyAttr, Grouping, TIntV(), true, true);
3388          for (TRowIterator RI = Table.BegRI(); RI &lt; Table.EndRI(); RI++) {
3389            TInt K = RI.GetIntAttr(NFKeyAttr);
3390            if (Grouping.IsKey(K)) {
3391              TIntV&amp; UpdateRows = Grouping.GetDat(K);
3392              for (int i = 0; i &lt; UpdateRows.Len(); i++) {
3393                FltCols[UpdateColIdx][UpdateRows[i]] = RI.GetFltAttr(NReadAttr);
3394              } 
3395            } 
3396          } 
3397        } 
3398        break;
3399      default:
3400        break;
3401    } 
3402  }
3403  void TTable::AddRowI(const TRowIterator&amp; RI) {
3404    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3405      TStr ColName = GetSchemaColName(c);
3406      if (ColName == IdColName) { continue; }
3407      TInt ColIdx = GetColIdx(ColName);
3408      switch (GetColType(ColName)) {
3409      case atInt:
3410         IntCols[ColIdx].Add(RI.GetIntAttr(ColName));
3411         break;
3412      case atFlt:
3413         FltCols[ColIdx].Add(RI.GetFltAttr(ColName));
3414         break;
3415      case atStr:
3416         StrColMaps[ColIdx].Add(RI.GetStrMapByName(ColName));
3417         break;
3418      }
3419    }
3420    UpdateTableForNewRow();
3421  }
3422  void TTable::AddRowV(const TIntV&amp; IntVals, const TFltV&amp; FltVals, const TStrV&amp; StrVals) {
3423    for (TInt c = 0; c &lt; IntVals.Len(); c++) {
3424      IntCols[c].Add(IntVals[c]);
3425    }
3426    for (TInt c = 0; c &lt; FltVals.Len(); c++) {
3427      FltCols[c].Add(FltVals[c]);
3428    }
3429    for (TInt c = 0; c &lt; StrVals.Len(); c++) {
3430      AddStrVal(c, StrVals[c]);
3431    }
3432    UpdateTableForNewRow();
3433  }
3434  void TTable::ResizeTable(int RowCount) {
3435    if (RowCount == 0) {
3436      NumValidRows = 0;
3437      FirstValidRow = TTable::Invalid;
3438      LastValidRow = TTable::Invalid;
3439    }
3440    if (Next.Len() &lt; RowCount) {
3441      TInt FltOffset = IntCols.Len();
3442      TInt StrOffset = FltOffset + FltCols.Len();
3443      TInt TotalCols = StrOffset + StrColMaps.Len();
3444  #ifdef USE_OPENMP
3445      #pragma omp parallel for schedule(static)
3446  #endif
3447      for (int i = 0; i &lt; TotalCols+1; i++) {
3448        if (i &lt; FltOffset) {
3449          IntCols[i].Reserve(RowCount, RowCount); 
3450        } else if (i &lt; StrOffset) {
3451          FltCols[i-FltOffset].Reserve(RowCount, RowCount);
3452        } else if (i &lt; TotalCols) {
3453          StrColMaps[i-StrOffset].Reserve(RowCount, RowCount);  
3454        } else {
3455          Next.Reserve(RowCount, RowCount);    
3456        }
3457      }
3458    } else if (Next.Len() &gt; RowCount) {
3459      TInt FltOffset = IntCols.Len();
3460      TInt StrOffset = FltOffset + FltCols.Len();
3461      TInt TotalCols = StrOffset + StrColMaps.Len();
3462  #ifdef USE_OPENMP
3463      #pragma omp parallel for schedule(static)
3464  #endif
3465      for (int i = 0; i &lt; TotalCols+1; i++) {
3466        if (i &lt; FltOffset) {
3467          IntCols[i].Trunc(RowCount); 
3468        } else if (i &lt; StrOffset) {
3469          FltCols[i-FltOffset].Trunc(RowCount); 
3470        } else if (i &lt; TotalCols) {
3471          StrColMaps[i-StrOffset].Trunc(RowCount); 
3472        } else {
3473          Next.Trunc(RowCount); 
3474        }
3475      }
3476    }
3477  }
3478  int TTable::GetEmptyRowsStart(int NewRows) {
3479    int start = -1;
3480  #ifdef USE_OPENMP
3481    #pragma omp critical
3482    {
3483  #endif
3484      start = NumRows;
3485      NumRows += NewRows;
3486      NumValidRows += NewRows;
3487      Assert(NumRows &lt;= Next.Len());
3488      if (LastValidRow &gt;= 0) {Next[LastValidRow] = start;}
3489      LastValidRow = start+NewRows-1;
3490      Next[LastValidRow] = Last;
3491  #ifdef USE_OPENMP
3492    }
3493  #endif
3494    Assert (start &gt;= 0);
3495    return start;
3496  }
3497  void TTable::AddSelectedRows(const TTable&amp; Table, const TIntV&amp; RowIDs) {
3498    int NewRows = RowIDs.Len();
3499    if (NewRows == 0) { return; }
3500    int start = GetEmptyRowsStart(NewRows);
3501    for (TInt r = 0; r &lt; NewRows; r++) {
3502      TInt CurrRowIdx = RowIDs[r];
3503      for (TInt i = 0; i &lt; Table.IntCols.Len(); i++) {
3504        IntCols[i][start+r] = Table.IntCols[i][CurrRowIdx];
3505      }
3506      for (TInt i = 0; i &lt; Table.FltCols.Len(); i++) {
3507        FltCols[i][start+r] = Table.FltCols[i][CurrRowIdx];
3508      }
3509      for (TInt i = 0; i &lt; Table.StrColMaps.Len(); i++) {
3510        StrColMaps[i][start+r] = Table.StrColMaps[i][CurrRowIdx];
3511      }
3512    }
3513    for (TInt r = 0; r &lt; NewRows-1; r++) {
3514      Next[start+r] = start+r+1;
3515    }
3516  }  
3517  void TTable::AddNRows(int NewRows, const TVec&lt;TIntV&gt;&amp; IntColsP, const TVec&lt;TFltV&gt;&amp; FltColsP, const TVec&lt;TIntV&gt;&amp; StrColMapsP) {
3518    if (NewRows == 0) { return; }
3519    int start = GetEmptyRowsStart(NewRows);
3520    for (TInt r = 0; r &lt; NewRows; r++) {
3521      for (TInt i = 0; i &lt; IntColsP.Len(); i++) {
3522        IntCols[i][start+r] = IntColsP[i][r];
3523      }
3524      for (TInt i = 0; i &lt; FltColsP.Len(); i++) {
3525        FltCols[i][start+r] = FltColsP[i][r];
3526      }
3527      for (TInt i = 0; i &lt; StrColMapsP.Len(); i++) {
3528        StrColMaps[i][start+r] = StrColMapsP[i][r];
3529      }
3530    }
3531    for (TInt r = 0; r &lt; NewRows-1; r++) {
3532      Next[start+r] = start+r+1;
3533    }
3534  }
3535  #ifdef USE_OPENMP
3536  void TTable::AddNJointRowsMP(const TTable&amp; T1, const TTable&amp; T2, const TVec&lt;TIntPrV&gt;&amp; JointRowIDSet) {
3537    int JointTableSize = 0;
3538    TIntV StartOffsets(JointRowIDSet.Len());
3539    for (int i = 0; i &lt; JointRowIDSet.Len(); i++) {
3540      StartOffsets[i] = JointTableSize;
3541      JointTableSize += JointRowIDSet[i].Len();
3542    }
3543    if (JointTableSize == 0) {
3544      TExcept::Throw(&quot;Joint table is empty&quot;);
3545    }
3546    ResizeTable(JointTableSize);
3547    NumRows = JointTableSize;
3548    NumValidRows = JointTableSize;
3549    Assert(NumRows &lt;= Next.Len());
3550    TInt IntOffset = T1.IntCols.Len();
3551    TInt FltOffset = T1.FltCols.Len();
3552    TInt StrOffset = T1.StrColMaps.Len();
3553    TInt IdOffset = IntOffset + T2.IntCols.Len();
3554    RowIdMap.Clr();
3555    for (TInt IdCnt = 0; IdCnt &lt; JointTableSize; IdCnt++) {
3556      RowIdMap.AddDat(IdCnt, IdCnt);
3557    }
3558    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3559    for (int j = 0; j &lt; JointRowIDSet.Len(); j++) {
3560      const TIntPrV&amp; RowIDs = JointRowIDSet[j];
3561      int start = StartOffsets[j];
3562      int NewRows = RowIDs.Len();
3563      if (NewRows == 0) {continue;}
3564      for (TInt r = 0; r &lt; NewRows; r++){
3565        TIntPr CurrRowIdPr = RowIDs[r]; 
3566        for(TInt i = 0; i &lt; T1.IntCols.Len(); i++){
3567          IntCols[i][start+r] = T1.IntCols[i][CurrRowIdPr.GetVal1()];
3568        }
3569        for(TInt i = 0; i &lt; T1.FltCols.Len(); i++){
3570          FltCols[i][start+r] = T1.FltCols[i][CurrRowIdPr.GetVal1()];
3571        }
3572        for(TInt i = 0; i &lt; T1.StrColMaps.Len(); i++){
3573          StrColMaps[i][start+r] = T1.StrColMaps[i][CurrRowIdPr.GetVal1()];
3574        }
3575        for(TInt i = 0; i &lt; T2.IntCols.Len(); i++){
3576          IntCols[i+IntOffset][start+r] = T2.IntCols[i][CurrRowIdPr.GetVal2()];
3577        }
3578        for(TInt i = 0; i &lt; T2.FltCols.Len(); i++){
3579          FltCols[i+FltOffset][start+r] = T2.FltCols[i][CurrRowIdPr.GetVal2()];
3580        }
3581        for(TInt i = 0; i &lt; T2.StrColMaps.Len(); i++){
3582          StrColMaps[i+StrOffset][start+r] = T2.StrColMaps[i][CurrRowIdPr.GetVal2()];
3583        }
3584        IntCols[IdOffset][start+r] = start+r;
3585      }
3586      for(TInt r = 0; r &lt; NewRows; r++){
3587        Next[start+r] = start+r+1;
3588      }
3589    }      
3590    LastValidRow = JointTableSize-1;
3591    Next[LastValidRow] = Last;
3592  }
3593  #endif 
3594  PTable TTable::UnionAll(const TTable&amp; Table) {
3595    Schema NewSchema;
3596    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3597      if (Sch[c].Val1 != GetIdColName()) {
3598        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3599      }
3600    }
3601    PTable result = TTable::New(NewSchema, Context);
3602    result-&gt;AddTable(*this);
3603    result-&gt;UnionAllInPlace(Table);
3604    return result;
3605  }
3606  void TTable::UnionAllInPlace(const TTable&amp; Table) {
3607    AddTable(Table);
3608  }
3609  PTable TTable::Union(const TTable&amp; Table) {
3610    Schema NewSchema;
3611    THashSet&lt;TInt&gt; Collisions;
3612    TStrV ColNames;
3613    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3614      if (Sch[c].Val1 != GetIdColName()) {
3615        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3616        ColNames.Add(Sch[c].Val1);
3617      }
3618    }
3619    PTable result = TTable::New(NewSchema, Context);
3620    GetCollidingRows(Table, Collisions); 
3621    result-&gt;AddTable(*this);
3622    result-&gt;Unique(ColNames);
3623    for (TRowIterator it = Table.BegRI(); it &lt; Table.EndRI(); it++) {
3624      if (!Collisions.IsKey(it.GetRowIdx())) {
3625        result-&gt;AddRowI(it);
3626      }
3627    }
3628    result-&gt;InitIds();
3629    return result;
3630  }
3631  PTable TTable::Intersection(const TTable&amp; Table) {
3632    Schema NewSchema;
3633    THashSet&lt;TInt&gt; Collisions;
3634    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3635      if (Sch[c].Val1 != GetIdColName()) {
3636        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3637      }
3638    }
3639    PTable result = TTable::New(NewSchema, Context);
3640    GetCollidingRows(Table, Collisions);
3641    for (TRowIterator it = Table.BegRI(); it &lt; Table.EndRI(); it++) {
3642      if (Collisions.IsKey(it.GetRowIdx())) {
3643        result-&gt;AddRowI(it);
3644      }
3645    }
3646    result-&gt;InitIds();
3647    return result;
3648  }
3649  PTable TTable::Minus(TTable&amp; Table) {
3650    Schema NewSchema;
3651    THashSet&lt;TInt&gt; Collisions;
3652    for (TInt c = 0; c &lt; Sch.Len(); c++) {
3653      if (Sch[c].Val1 != GetIdColName()) {
3654        NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(Sch[c].Val1, Sch[c].Val2));
3655      }
3656    }
3657    PTable result = TTable::New(NewSchema, Context);
3658    Table.GetCollidingRows(*this, Collisions);
3659    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
3660      if (!Collisions.IsKey(it.GetRowIdx())) {
3661        result-&gt;AddRowI(it);
3662      }
3663    }
3664    result-&gt;InitIds();
3665    return result;
3666  }
3667  PTable TTable::Project(const TStrV&amp; ProjectCols) {
3668    Schema NewSchema;
3669    for (TInt c = 0; c &lt; ProjectCols.Len(); c++) {
3670      if (!IsColName(ProjectCols[c])) { TExcept::Throw(&quot;no such column &quot; + ProjectCols[c]); }
3671      NewSchema.Add(TPair&lt;TStr,TAttrType&gt;(ProjectCols[c], GetColType(ProjectCols[c])));
3672    }
3673    PTable result = TTable::New(NewSchema, Context);
3674    result-&gt;AddTable(*this);
3675    result-&gt;InitIds();
3676    return result;
3677  }
3678  TBool TTable::IsAttr(const TStr&amp; Attr) {
3679    return IsColName(Attr);
3680  }
3681  TStr TTable::RenumberColName(const TStr&amp; ColName) const {
3682    TStr NColName = ColName;
3683    if (NColName.GetCh(NColName.Len()-2) == &#x27;-&#x27;) { 
3684      NColName = NColName.GetSubStr(0,NColName.Len()-3); 
3685    }
3686    TInt Conflicts = 0;
3687    for (TInt i = 0; i &lt; Sch.Len(); i++) {
3688      if (NColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3689        Conflicts++;
3690      }
3691    }
3692    Conflicts++;
3693    NColName = NColName + &quot;-&quot; + Conflicts.GetStr();
3694    return NColName;
3695  }
3696  TStr TTable::DenormalizeColName(const TStr&amp; ColName) const {
3697    TStr DColName = ColName;
3698    if (DColName.Len() == 0) { return DColName; }
3699    if (DColName.GetCh(0) == &#x27;_&#x27;) { return DColName; }
3700    if (DColName.GetCh(DColName.Len()-2) == &#x27;-&#x27;) { 
3701      DColName = DColName.GetSubStr(0,DColName.Len()-3); 
3702    }
3703    TInt Conflicts = 0;
3704    for (TInt i = 0; i &lt; Sch.Len(); i++) {
3705      if (DColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3706        Conflicts++;
3707      }
3708    }
3709    if (Conflicts &gt; 1) { return ColName; } 
3710    else { return DColName; }
3711  }
3712  Schema TTable::DenormalizeSchema() const {
3713    Schema DSch;
3714    for (TInt i = 0; i &lt; Sch.Len(); i++) {
3715      DSch.Add(TPair&lt;TStr, TAttrType&gt;(DenormalizeColName(Sch[i].Val1), Sch[i].Val2));
3716    }
3717    return DSch;
3718  }
3719  void TTable::AddIntCol(const TStr&amp; ColName) {
3720    AddSchemaCol(ColName, atInt);
3721    IntCols.Add(TIntV(NumRows));
3722    TInt L = IntCols.Len();
3723    AddColType(ColName, atInt, L-1);
3724  }
3725  void TTable::AddFltCol(const TStr&amp; ColName) {
3726    AddSchemaCol(ColName, atFlt);
3727    FltCols.Add(TFltV(NumRows));
3728    TInt L = FltCols.Len();
3729    AddColType(ColName, atFlt, L-1);
3730  }
3731  void TTable::AddStrCol(const TStr&amp; ColName) {
3732    AddSchemaCol(ColName, atStr);
3733    StrColMaps.Add(TIntV(NumRows));
3734    TInt L = StrColMaps.Len();
3735    AddColType(ColName, atStr, L-1);
3736  }
3737  void TTable::ClassifyAux(const TIntV&amp; SelectedRows, const TStr&amp; LabelName, const TInt&amp; PositiveLabel, const TInt&amp; NegativeLabel) {
3738    AddSchemaCol(LabelName, atInt);
3739    TInt LabelColIdx = IntCols.Len();
3740    AddColType(LabelName, atInt, LabelColIdx);
3741    IntCols.Add(TIntV(NumRows));
3742    for (TInt i = 0; i &lt; NumRows; i++) {
3743      IntCols[LabelColIdx][i] = NegativeLabel;
3744    }
3745    for (TInt i = 0; i &lt; SelectedRows.Len(); i++) {
3746      IntCols[LabelColIdx][SelectedRows[i]] = PositiveLabel;
3747    }
3748  }
3749  #ifdef USE_OPENMP
3750  void TTable::ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op){
3751  	TAttrType ResType = atFlt;
3752  	if(ArgType1 == atInt &amp;&amp; ArgType2 == atInt){ ResType = atInt;}
3753  	TIntPrV Partitions;
3754  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3755  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3756  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3757  	for (int i = 0; i &lt; Partitions.Len(); i++){
3758  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3759  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3760  		while(RowI &lt; EndI){
3761  			if(ResType == atInt){
3762  				TInt V1 = RowI.GetIntAttr(ArgColIdx1);
3763  				TInt V2 = RowI.GetIntAttr(ArgColIdx2);
3764  				if (op == aoAdd) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3765        			if (op == aoSub) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3766        			if (op == aoMul) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3767        			if (op == aoDiv) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3768        			if (op == aoMod) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 % V2; }
3769        			if (op == aoMin) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3770        			if (op == aoMax) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3771  			} else{
3772  			    TFlt V1 = (ArgType1 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx1) : RowI.GetFltAttr(ArgColIdx1);
3773  			    TFlt V2 = (ArgType2 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx2) : RowI.GetFltAttr(ArgColIdx2);
3774  				if (op == aoAdd) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3775        			if (op == aoSub) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3776        			if (op == aoMul) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3777        			if (op == aoDiv) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3778        			if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;);  }
3779        			if (op == aoMin) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3780        			if (op == aoMax) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3781  			}
3782  			RowI++;
3783  		}
3784  	}
3785  }
3786  #endif	
3787  void TTable::ColGenericOp(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResAttr, TArithOp op) {
3788    if (!IsAttr(Attr1)) TExcept::Throw(&quot;No attribute present: &quot; + Attr1);
3789    if (!IsAttr(Attr2)) TExcept::Throw(&quot;No attribute present: &quot; + Attr2);
3790    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
3791    TPair&lt;TAttrType, TInt&gt; Info2 = GetColTypeMap(Attr2);
3792    TAttrType Arg1Type = Info1.Val1;
3793    TAttrType Arg2Type = Info2.Val1;
3794    if (Arg1Type == atStr || Arg2Type == atStr) {
3795      TExcept::Throw(&quot;Only numeric columns supported in arithmetic operations.&quot;);
3796    }
3797    if(Arg1Type == atInt &amp;&amp; Arg2Type == atFlt &amp;&amp; ResAttr == &quot;&quot;){
3798    	TExcept::Throw(&quot;Trying to write float values to an existing int-typed column&quot;);
3799    }
3800    TInt ColIdx1 = Info1.Val2;
3801    TInt ColIdx2 = Info2.Val2;
3802    TInt ColIdx3 = ColIdx1;
3803    if (ResAttr != &quot;&quot;) {
3804        if (Arg1Type == atInt &amp;&amp; Arg2Type == atInt) {
3805            AddIntCol(ResAttr);
3806        }
3807        else {
3808            AddFltCol(ResAttr);
3809        }
3810        ColIdx3 = GetColIdx(ResAttr);
3811    }
3812  #ifdef USE_OPENMP
3813    if(GetMP()){
3814    	ColGenericOpMP(ColIdx1, ColIdx2, Arg1Type, Arg2Type, ColIdx3, op);
3815    	return;
3816    }
3817  #endif	
3818    TAttrType ResType = atFlt;
3819    if(Arg1Type == atInt &amp;&amp; Arg2Type == atInt){ printf(&quot;hooray!\n&quot;); ResType = atInt;}
3820    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
3821  		if(ResType == atInt){
3822  			TInt V1 = RowI.GetIntAttr(ColIdx1);
3823  			TInt V2 = RowI.GetIntAttr(ColIdx2);
3824  			if (op == aoAdd) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3825        		if (op == aoSub) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3826        		if (op == aoMul) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3827        		if (op == aoDiv) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3828        		if (op == aoMod) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 % V2; }
3829        		if (op == aoMin) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3830        		if (op == aoMax) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3831  		} else{
3832  			TFlt V1 = (Arg1Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx1) : RowI.GetFltAttr(ColIdx1);
3833  			TFlt V2 = (Arg2Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx2) : RowI.GetFltAttr(ColIdx2);
3834  			if (op == aoAdd) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3835        		if (op == aoSub) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3836        		if (op == aoMul) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3837        		if (op == aoDiv) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3838        		if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;);  }
3839        		if (op == aoMin) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 &lt; V2) ? V1 : V2;}
3840        		if (op == aoMax) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 &gt; V2) ? V1 : V2;}
3841  		}
3842    }
3843  }
3844  void TTable::ColAdd(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3845    ColGenericOp(Attr1, Attr2, ResultAttrName, aoAdd);
3846  }
3847  void TTable::ColSub(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3848    ColGenericOp(Attr1, Attr2, ResultAttrName, aoSub);
3849  }
3850  void TTable::ColMul(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3851    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMul);
3852  }
3853  void TTable::ColDiv(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3854    ColGenericOp(Attr1, Attr2, ResultAttrName, aoDiv);
3855  }
3856  void TTable::ColMod(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3857    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMod);
3858  }
3859  void TTable::ColMin(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3860    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMin);
3861  }
3862  void TTable::ColMax(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; ResultAttrName) {
3863    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMax);
3864  }
3865  void TTable::ColGenericOp(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, const TStr&amp; ResAttr,
3866   TArithOp op, TBool AddToFirstTable) {
3867    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
3868    if (!Table.IsAttr(Attr2)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr2); }
3869    if (NumValidRows != Table.NumValidRows) {
3870      TExcept::Throw(&quot;Tables do not have equal number of rows&quot;);
3871    }
3872    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
3873    TPair&lt;TAttrType, TInt&gt; Info2 = Table.GetColTypeMap(Attr2);
3874    TAttrType Arg1Type = Info1.Val1;
3875    TAttrType Arg2Type = Info2.Val1;
3876    if (Info1.Val1 == atStr || Info2.Val1 == atStr) {
3877      TExcept::Throw(&quot;Only numeric columns supported in arithmetic operations.&quot;);
3878    }
3879    if(Arg1Type == atInt &amp;&amp; Arg2Type == atFlt &amp;&amp; ResAttr == &quot;&quot;){
3880    	TExcept::Throw(&quot;Trying to write float values to an existing int-typed column&quot;);
3881    }
3882    TInt ColIdx1 = Info1.Val2;
3883    TInt ColIdx2 = Info2.Val2;
3884    TInt ColIdx3 = AddToFirstTable ? ColIdx1 : ColIdx2;
3885    if (ResAttr != &quot;&quot;) {
3886      if (AddToFirstTable) {
3887        if (Arg1Type == atInt &amp;&amp; Arg2Type == atInt) {
3888            AddIntCol(ResAttr);
3889        } else {
3890            AddFltCol(ResAttr);
3891        }
3892        ColIdx3 = GetColIdx(ResAttr);
3893      }
3894      else {
3895        if (Arg1Type == atInt &amp;&amp; Arg2Type == atInt) {
3896            Table.AddIntCol(ResAttr);
3897        } else {
3898            Table.AddFltCol(ResAttr);
3899        }
3900        ColIdx3 = Table.GetColIdx(ResAttr);
3901      }
3902    }
3903    TRowIterator RI1, RI2;
3904    RI1 = BegRI();
3905    RI2 = Table.BegRI();
3906    TAttrType ResType = atFlt;
3907    if(Arg1Type == atInt &amp;&amp; Arg2Type == atInt){ ResType = atInt;}
3908    while (RI1 &lt; EndRI() &amp;&amp; RI2 &lt; Table.EndRI()) {
3909      if (ResType == atInt) {
3910  		TInt V1 = RI1.GetIntAttr(ColIdx1);
3911  		TInt V2 = RI2.GetIntAttr(ColIdx2);
3912          if (AddToFirstTable) {
3913          	if (op == aoAdd) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3914          	if (op == aoSub) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3915          	if (op == aoMul) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3916          	if (op == aoDiv) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3917         		if (op == aoMod) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 % V2; }
3918        	}
3919        	else {
3920          	if (op == aoAdd) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3921          	if (op == aoSub) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3922          	if (op == aoMul) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3923          	if (op == aoDiv) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3924          	if (op == aoMod) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 % V2; }
3925        	}
3926      } else {
3927  	  	TFlt V1 = (Arg1Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx1) : RI2.GetFltAttr(ColIdx1);
3928  		TFlt V2 = (Arg2Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx2) : RI2.GetFltAttr(ColIdx2);
3929        	if (AddToFirstTable) {
3930          	if (op == aoAdd) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3931          	if (op == aoSub) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3932          	if (op == aoMul) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3933         	 	if (op == aoDiv) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3934          	if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
3935        	} else {
3936          	if (op == aoAdd) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3937          	if (op == aoSub) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3938          	if (op == aoMul) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3939          	if (op == aoDiv) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3940          	if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
3941        	}
3942      }
3943      RI1++;
3944      RI2++;
3945    }
3946    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
3947      TExcept::Throw(&quot;ColGenericOp: Iteration error&quot;);
3948    }
3949  }
3950  void TTable::ColAdd(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3951   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3952    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoAdd, AddToFirstTable);
3953  }
3954  void TTable::ColSub(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3955   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3956    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoSub, AddToFirstTable);
3957  }
3958  void TTable::ColMul(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3959   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3960    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMul, AddToFirstTable);
3961  }
3962  void TTable::ColDiv(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3963   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3964    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoDiv, AddToFirstTable);
3965  }
3966  void TTable::ColMod(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, 
3967   const TStr&amp; ResultAttrName, TBool AddToFirstTable) {
3968    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMod, AddToFirstTable);
3969  }
3970  void TTable::ColGenericOp(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResAttr, TArithOp op, const TBool floatCast) {
3971    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
3972    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
3973    TAttrType ArgType = Info1.Val1;
3974    if (ArgType == atStr) {
3975      TExcept::Throw(&quot;Only numeric columns supported in arithmetic operations.&quot;);
3976    }
3977    TInt ColIdx1 = Info1.Val2;
3978    TInt ColIdx2 = ColIdx1;
3979    TBool shouldCast = floatCast;
3980    if (ResAttr != &quot;&quot;) {
3981        if ((ArgType == atInt) &amp; !shouldCast) {
3982            AddIntCol(ResAttr);
3983        } else {
3984            AddFltCol(ResAttr);
3985        }
3986        ColIdx2 = GetColIdx(ResAttr);
3987    } else {
3988      shouldCast = false;
3989    }
3990    #ifdef USE_OPENMP
3991    if(GetMP()){
3992    	ColGenericOpMP(ColIdx1, ColIdx2, ArgType, Num, op, shouldCast);
3993    	return;
3994    }
3995    #endif  
3996    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
3997      if ((ArgType == atInt) &amp;&amp; !shouldCast) {
3998        TInt CurVal = RowI.GetIntAttr(ColIdx1);
3999        TInt Val = static_cast&lt;int&gt;(Num);
4000        if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4001        if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4002        if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4003        if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4004        if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4005      }
4006      else {
4007        TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4008        if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4009        if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4010        if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4011        if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4012        if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
4013      }
4014    }
4015  }
4016  #ifdef USE_OPENMP
4017  void TTable::ColGenericOpMP(const TInt&amp; ColIdx1, const TInt&amp; ColIdx2, TAttrType ArgType, const TFlt&amp; Num, TArithOp op, TBool ShouldCast){
4018  	TIntPrV Partitions;
4019  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
4020  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
4021  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
4022  	for (int i = 0; i &lt; Partitions.Len(); i++){
4023  		TRowIterator RowI(Partitions[i].GetVal1(), this);
4024  		TRowIterator EndI(Partitions[i].GetVal2(), this);
4025  		while(RowI &lt; EndI){
4026  			if ((ArgType == atInt) &amp;&amp; !ShouldCast) {
4027        			TInt CurVal = RowI.GetIntAttr(ColIdx1);
4028        			TInt Val = static_cast&lt;int&gt;(Num);
4029        			if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4030        			if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4031        			if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4032        			if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4033        			if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4034      		} else {
4035       			TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4036        			if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4037        			if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4038        			if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4039        			if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4040        			if (op == aoMod) { TExcept::Throw(&quot;Cannot find modulo for float columns&quot;); }
4041      		}
4042      		RowI++;
4043  		}
4044  	}
4045  }
4046  #endif
4047  void TTable::ColAdd(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4048    ColGenericOp(Attr1, Num, ResultAttrName, aoAdd, floatCast);
4049  }
4050  void TTable::ColSub(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4051    ColGenericOp(Attr1, Num, ResultAttrName, aoSub, floatCast);
4052  }
4053  void TTable::ColMul(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4054    ColGenericOp(Attr1, Num, ResultAttrName, aoMul, floatCast);
4055  }
4056  void TTable::ColDiv(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4057    ColGenericOp(Attr1, Num, ResultAttrName, aoDiv, floatCast);
4058  }
4059  void TTable::ColMod(const TStr&amp; Attr1, const TFlt&amp; Num, const TStr&amp; ResultAttrName, const TBool floatCast) {
4060    ColGenericOp(Attr1, Num, ResultAttrName, aoMod, floatCast);
4061  }
4062  void TTable::ColConcat(const TStr&amp; Attr1, const TStr&amp; Attr2, const TStr&amp; Sep, const TStr&amp; ResAttr) {
4063    if (!IsAttr(Attr1)) TExcept::Throw(&quot;No attribute present: &quot; + Attr1);
4064    if (!IsAttr(Attr2)) TExcept::Throw(&quot;No attribute present: &quot; + Attr2);
4065    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
4066    TPair&lt;TAttrType, TInt&gt; Info2 = GetColTypeMap(Attr2);
4067    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4068      TExcept::Throw(&quot;Only string columns supported in concat.&quot;);
4069    }
4070    TInt ColIdx1 = Info1.Val2;
4071    TInt ColIdx2 = Info2.Val2;
4072    TInt ColIdx3 = ColIdx1;
4073    if (ResAttr != &quot;&quot;) {
4074        AddStrCol(ResAttr);
4075        ColIdx3 = GetColIdx(ResAttr);
4076    }
4077    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4078      TStr CurVal1 = RowI.GetStrAttr(ColIdx1);
4079      TStr CurVal2 = RowI.GetStrAttr(ColIdx2);
4080      TStr NewVal = CurVal1 + Sep + CurVal2;
4081      TInt Key = TInt(Context-&gt;StringVals.AddKey(NewVal));
4082      StrColMaps[ColIdx3][RowI.GetRowIdx()] = Key;
4083    }
4084  }
4085  void TTable::ColConcat(const TStr&amp; Attr1, TTable&amp; Table, const TStr&amp; Attr2, const TStr&amp; Sep, 
4086   const TStr&amp; ResAttr, TBool AddToFirstTable) {
4087    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
4088    if (!Table.IsAttr(Attr2)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr2); }
4089    if (NumValidRows != Table.NumValidRows) {
4090      TExcept::Throw(&quot;Tables do not have equal number of rows&quot;);
4091    }
4092    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
4093    TPair&lt;TAttrType, TInt&gt; Info2 = Table.GetColTypeMap(Attr2);
4094    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4095      TExcept::Throw(&quot;Only string columns supported in concat.&quot;);
4096    }
4097    TInt ColIdx1 = Info1.Val2;
4098    TInt ColIdx2 = Info2.Val2;
4099    TInt ColIdx3 = ColIdx1;
4100    if (!AddToFirstTable) {
4101      ColIdx3 = ColIdx2;
4102    }
4103    if (ResAttr != &quot;&quot;) {
4104      if (AddToFirstTable) {
4105        AddStrCol(ResAttr);
4106        ColIdx3 = GetColIdx(ResAttr);
4107      }
4108      else {
4109        Table.AddStrCol(ResAttr);
4110        ColIdx3 = Table.GetColIdx(ResAttr);
4111      }
4112    }
4113    TRowIterator RI1, RI2;
4114    RI1 = BegRI();
4115    RI2 = Table.BegRI();
4116    while (RI1 &lt; EndRI() &amp;&amp; RI2 &lt; Table.EndRI()) {
4117      TStr CurVal1 = RI1.GetStrAttr(ColIdx1);
4118      TStr CurVal2 = RI2.GetStrAttr(ColIdx2);
4119      TStr NewVal = CurVal1 + Sep + CurVal2;
4120      TInt Key = TInt(Context-&gt;StringVals.AddKey(NewVal));
4121      if (AddToFirstTable) {
4122        StrColMaps[ColIdx3][RI1.GetRowIdx()] = Key;
4123      }
4124      else {
4125        Table.StrColMaps[ColIdx3][RI2.GetRowIdx()] = Key;
4126      }
4127      RI1++;
4128      RI2++;
4129    }
4130    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
4131      TExcept::Throw(&quot;ColGenericOp: Iteration error&quot;);
4132    }
4133  }
4134  void TTable::ColConcatConst(const TStr&amp; Attr1, const TStr&amp; Val, const TStr&amp; Sep, const TStr&amp; ResAttr) {
4135    if (!IsAttr(Attr1)) { TExcept::Throw(&quot;No attribute present: &quot; + Attr1); }
4136    TPair&lt;TAttrType, TInt&gt; Info1 = GetColTypeMap(Attr1);
4137    if (Info1.Val1 != atStr) {
4138      TExcept::Throw(&quot;Only string columns supported in concat.&quot;);
4139    }
4140    TInt ColIdx1 = Info1.Val2;
4141    TInt ColIdx2 = ColIdx1;
4142    if (ResAttr != &quot;&quot;) {
4143      AddStrCol(ResAttr);
4144      ColIdx2 = GetColIdx(ResAttr);
4145    }
4146    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4147      TStr CurVal = RowI.GetStrAttr(ColIdx1);
4148      TStr NewVal = CurVal + Sep + Val;
4149      TInt Key = TInt(Context-&gt;StringVals.AddKey(NewVal));
4150      StrColMaps[ColIdx2][RowI.GetRowIdx()] = Key;
4151    }  
4152  }
4153  void TTable::ReadIntCol(const TStr&amp; ColName, TIntV&amp; Result) const{
4154    if (!IsColName(ColName)) { TExcept::Throw(&quot;no such column &quot; + ColName); }
4155    if (GetColType(ColName) != atInt) { TExcept::Throw(&quot;not an integer column &quot; + ColName); }
4156    TInt ColId = GetColIdx(ColName);
4157    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
4158      Result.Add(it.GetIntAttr(ColId));
4159    }
4160  }
4161  void TTable::ReadFltCol(const TStr&amp; ColName, TFltV&amp; Result) const{
4162    if (!IsColName(ColName)) { TExcept::Throw(&quot;no such column &quot; + ColName); }
4163    if (GetColType(ColName) != atFlt) { TExcept::Throw(&quot;not a floating point column &quot; + ColName); }
4164    TInt ColId = GetColIdx(ColName);
4165    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
4166      Result.Add(it.GetFltAttr(ColId));
4167    }
4168  }
4169  void TTable::ReadStrCol(const TStr&amp; ColName, TStrV&amp; Result) const{
4170    if (!IsColName(ColName)) { TExcept::Throw(&quot;no such column &quot; + ColName); }
4171    if (GetColType(ColName) != atStr) { TExcept::Throw(&quot;not a string column &quot; + ColName); }
4172    TInt ColId = GetColIdx(ColName);
4173    for (TRowIterator it = BegRI(); it &lt; EndRI(); it++) {
4174      Result.Add(it.GetStrAttr(ColId));
4175    }
4176  }
4177  void TTable::ProjectInPlace(const TStrV&amp; ProjectCols) {
4178    TStrV NProjectCols = NormalizeColNameV(ProjectCols);
4179    for (TInt c = 0; c &lt; NProjectCols.Len(); c++) {
4180      if (!IsColName(NProjectCols[c])) { TExcept::Throw(&quot;no such column &quot; + NProjectCols[c]); }
4181    }
4182    THashSet&lt;TStr&gt; ProjectColsSet = THashSet&lt;TStr&gt;(NProjectCols);
4183    for (TInt i = Sch.Len() - 1; i &gt;= 0; i--) {
4184      TStr ColName = GetSchemaColName(i);
4185      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4186      TAttrType ColType = GetSchemaColType(i);
4187      TInt ColId = GetColIdx(ColName);
4188      switch (ColType) {
4189        case atInt:
4190          IntCols.Del(ColId);
4191          break;
4192        case atFlt:
4193          FltCols.Del(ColId);
4194          break;
4195        case atStr:
4196          StrColMaps.Del(ColId);
4197          break;
4198      }
4199    }
4200    TInt IntColCnt = 0;
4201    TInt FltColCnt = 0;
4202    TInt StrColCnt = 0;
4203    ColTypeMap.Clr();
4204    for (TInt i = 0; i &lt; Sch.Len(); i++) {
4205      TStr ColName = GetSchemaColName(i);
4206      if (!ProjectColsSet.IsKey(ColName) &amp;&amp; ColName != IdColName) { continue; }
4207      TAttrType ColType = GetSchemaColType(i);
4208      switch (ColType) {
4209        case atInt:
4210          AddColType(ColName, atInt, IntColCnt);
4211          IntColCnt++;
4212          break;
4213        case atFlt:
4214          AddColType(ColName, atFlt, FltColCnt);
4215          FltColCnt++;
4216          break;
4217        case atStr:
4218          AddColType(ColName, atStr, StrColCnt);
4219          StrColCnt++;
4220          break;
4221      }
4222    }
4223    for (TInt i = Sch.Len() - 1; i &gt;= 0; i--) {
4224      TStr ColName = GetSchemaColName(i);
4225      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4226      Sch.Del(i);
4227    }
4228  }
4229  TInt TTable::CompareKeyVal(const TInt&amp; K1, const TInt&amp; V1, const TInt&amp; K2, const TInt&amp; V2) {
4230    if (K1 == K2) { return V1 - V2; }
4231    else { return K1 - K2; }
4232  }
4233  TInt TTable::CheckSortedKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4234    TInt j;
4235    for (j = Start; j &lt; End; j++) {
4236      if (CompareKeyVal(Key[j], Val[j], Key[j+1], Val[j+1]) &gt; 0) {
4237        break;
4238      }
4239    }
4240    if (j &gt;= End) { return 0; }
4241    else { return 1; }
4242  }
4243  void TTable::ISortKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4244    if (Start &lt; End) {
4245      for (TInt i = Start+1; i &lt;= End; i++) {
4246        TInt K = Key[i];
4247        TInt V = Val[i];
4248        TInt j = i;
4249        while ((Start &lt; j) &amp;&amp; (CompareKeyVal(Key[j-1], Val[j-1], K, V) &gt; 0)) {
4250          Key[j] = Key[j-1];
4251          Val[j] = Val[j-1];
4252          j--;
4253        }
4254        Key[j] = K;
4255        Val[j] = V;
4256      }
4257    }
4258  }
4259  TInt TTable::GetPivotKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4260    TInt L = End - Start + 1;
4261    const TInt Idx1 = Start + TInt::GetRnd(L);
4262    const TInt Idx2 = Start + TInt::GetRnd(L);
4263    const TInt Idx3 = Start + TInt::GetRnd(L);
4264    if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx2], Val[Idx2]) &lt; 0) {
4265      if (CompareKeyVal(Key[Idx2], Val[Idx2], Key[Idx3], Val[Idx3]) &lt; 0) { return Idx2; }
4266      if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx3], Val[Idx3]) &lt; 0) { return Idx3; }
4267      return Idx1;
4268    } else {
4269      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx2], Val[Idx2]) &lt; 0) { return Idx2; }
4270      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx1], Val[Idx1]) &lt; 0) { return Idx3; }
4271      return Idx1;
4272    }
4273  }
4274  TInt TTable::PartitionKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4275    TInt Pivot = GetPivotKeyVal(Key, Val, Start, End);
4276    TInt PivotKey = Key[Pivot];
4277    TInt PivotVal = Val[Pivot];
4278    Key.Swap(Pivot, End);
4279    Val.Swap(Pivot, End);
4280    TInt StoreIdx = Start;
4281    for (TInt i = Start; i &lt; End; i++) {
4282      if (CompareKeyVal(Key[i], Val[i], PivotKey, PivotVal) &lt;= 0) {
4283        Key.Swap(i, StoreIdx);
4284        Val.Swap(i, StoreIdx);
4285        StoreIdx++;
4286      }
4287    }
4288    Key.Swap(StoreIdx, End);
4289    Val.Swap(StoreIdx, End);
4290    return StoreIdx;
4291  }
4292  void TTable::QSortKeyVal(TIntV&amp; Key, TIntV&amp; Val, TInt Start, TInt End) {
4293    TInt L = End-Start;
4294    if (L &lt;= 0) { return; }
4295    if (CheckSortedKeyVal(Key, Val, Start, End) == 0) { return; }
4296    if (L &lt;= 20) { ISortKeyVal(Key, Val, Start, End); }
4297    else {
4298      TInt Pivot = PartitionKeyVal(Key, Val, Start, End);
4299      if (Pivot &gt; End) { return; }
4300      if (L &lt;= 500000) {
4301        QSortKeyVal(Key, Val, Start, Pivot-1);
4302        QSortKeyVal(Key, Val, Pivot+1, End);
4303      } else {
4304  #ifdef USE_OPENMP
4305  #ifndef GLib_WIN32
4306        #pragma omp task untied shared(Key, Val)
4307  #endif
4308  #endif
4309        { QSortKeyVal(Key, Val, Start, Pivot-1); }
4310  #ifdef USE_OPENMP
4311  #ifndef GLib_WIN32
4312        #pragma omp task untied shared(Key, Val)
4313  #endif
4314  #endif
4315        { QSortKeyVal(Key, Val, Pivot+1, End); }
4316      }
4317    }
4318  }
4319  TIntV TTable::GetIntRowIdxByVal(const TStr&amp; ColName, const TInt&amp; Val) const {
4320    if (IntColIndexes.IsKey(ColName)) {
4321      THash&lt;TInt, TIntV&gt; ColIndex = IntColIndexes.GetDat(ColName);
4322      if (ColIndex.IsKey(Val)) {
4323        return ColIndex.GetDat(Val);
4324      }
4325      else {
4326        TIntV Empty;
4327        return Empty;
4328      }
4329    }
4330    TIntV ToReturn;
4331    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4332      TInt ValAtRow = RowI.GetIntAttr(ColName);
4333      if ( Val == ValAtRow) {
4334        ToReturn.Add(RowI.GetRowIdx());
4335      }
4336    }
4337    return ToReturn;
4338  }
4339  TIntV TTable::GetStrRowIdxByMap(const TStr&amp; ColName, const TInt&amp; Map) const {
4340    if (StrMapColIndexes.IsKey(ColName)) {
4341      THash&lt;TInt, TIntV&gt; ColIndex = StrMapColIndexes.GetDat(ColName);
4342      if (ColIndex.IsKey(Map)) {
4343        return ColIndex.GetDat(Map);
4344      }
4345      else {
4346        TIntV Empty;
4347        return Empty;
4348      }
4349    }
4350    TIntV ToReturn;
4351    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4352      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4353      if ( Map == MapAtRow) {
4354        ToReturn.Add(RowI.GetRowIdx());
4355      }
4356    }
4357    return ToReturn;
4358  }
4359  TIntV TTable::GetFltRowIdxByVal(const TStr&amp; ColName, const TFlt&amp; Val) const {
4360    if (FltColIndexes.IsKey(ColName)) {
4361      THash&lt;TFlt, TIntV&gt; ColIndex = FltColIndexes.GetDat(ColName);
4362      if (ColIndex.IsKey(Val)) {
4363        return ColIndex.GetDat(Val);
4364      }
4365      else {
4366        TIntV Empty;
4367        return Empty;
4368      }
4369    }
4370    TIntV ToReturn;
4371    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4372      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4373      if ( Val == ValAtRow) {
4374        ToReturn.Add(RowI.GetRowIdx());
4375      }
4376    }
4377    return ToReturn;
4378  }
4379  TInt TTable::RequestIndexInt(const TStr&amp; ColName) {
4380    THash&lt;TInt, TIntV&gt; NewIndex;
4381    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4382      TInt ValAtRow = RowI.GetIntAttr(ColName);
4383      TInt RowIdx = RowI.GetRowIdx();
4384      if (NewIndex.IsKey(ValAtRow)) {
4385         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4386         Curr_V.Add(RowIdx);
4387      }
4388      else {
4389        TIntV New_V;
4390        New_V.Add(RowIdx);
4391        NewIndex.AddDat(ValAtRow, New_V);
4392      }
4393    }
4394    IntColIndexes.AddDat(ColName, NewIndex); 
4395    return 0;
4396  }
4397  TInt TTable::RequestIndexFlt(const TStr&amp; ColName) {
4398    THash&lt;TFlt, TIntV&gt; NewIndex;
4399    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4400      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4401      TInt RowIdx = RowI.GetRowIdx();
4402      if (NewIndex.IsKey(ValAtRow)) {
4403         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4404         Curr_V.Add(RowIdx);
4405      }
4406      else {
4407        TIntV New_V;
4408        New_V.Add(RowIdx);
4409        NewIndex.AddDat(ValAtRow, New_V);
4410      }
4411    }
4412    FltColIndexes.AddDat(ColName, NewIndex); 
4413    return 0;
4414  }
4415  TInt TTable::RequestIndexStrMap(const TStr&amp; ColName) {
4416    THash&lt;TInt, TIntV&gt; NewIndex;
4417    for (TRowIterator RowI = BegRI(); RowI &lt; EndRI(); RowI++) {
4418      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4419      TInt RowIdx = RowI.GetRowIdx();
4420      if (NewIndex.IsKey(MapAtRow)) {
4421         TIntV Curr_V = NewIndex.GetDat(MapAtRow);
4422         Curr_V.Add(RowIdx);
4423      }
4424      else {
4425        TIntV New_V;
4426        New_V.Add(RowIdx);
4427        NewIndex.AddDat(MapAtRow, New_V);
4428      }
4429    }
4430    StrMapColIndexes.AddDat(ColName, NewIndex); 
4431    return 0;
4432  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1722  		TInt GroupId1 = GroupJointTable-&gt;IntCols[0][RowI.GetRowIdx()];
1723  		TInt GroupId2 = GroupJointTable-&gt;IntCols[1][RowI.GetRowIdx()];
</pre></code></div>
                <div class="column column_space"><pre><code>1723  		TInt GroupId2 = GroupJointTable-&gt;IntCols[1][RowI.GetRowIdx()];
1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    