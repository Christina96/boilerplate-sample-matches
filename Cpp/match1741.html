<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for TestValidate.cpp &amp; BaseTestSection.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestValidate.cpp &amp; BaseTestSection.cpp
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestValidate.cpp (2.9411764%)<th>BaseTestSection.cpp (2.8463%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(33-36)<td><a href="#" name="0">(565-569)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestValidate.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include "TestValidate.hpp"

#include &lt;nix/valid/validator.hpp&gt;
#include &lt;nix/valid/checks.hpp&gt;
#include &lt;nix/valid/conditions.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;
#include &lt;nix.hpp&gt;

#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;math.h&gt;

#include &lt;boost/math/constants/constants.hpp&gt;


using namespace nix;
using namespace valid;
using namespace std;

void TestValidate::setUp() {
<a name="0"></a>    startup_time = time(NULL);
    // create file &amp; block
    file = nix::File::open("test_validate.h5", nix::FileMode::Overwrite);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    block = file.createBlock("block_one", "dataset");
    // create data array
    array1 = block.createDataArray("array_one", "testdata", nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));
    array2 = block.createDataArray("array_two", "testdata", nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));</b></font>
    array3 = block.createDataArray("array_three", "testdata", nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));
    array4 = block.createDataArray("array_four", "sindata", nix::DataType::Double, nix::NDSize({ 0, 0}));
    array5 = block.createDataArray("array_five", "dftest", nix::DataType::Double, nix::NDSize{ 0 });
    // create data frame
    std::vector&lt;nix::Column&gt; cols = {{"current", "nA", nix::DataType::Double}};
    frame1 = block.createDataFrame("frame_one", "conditions", cols);
    // set references vector
    refs = {array2, array3};
    // create positions &amp; extents arrays
    positions = block.createDataArray("positions_DataArray", "dataArray", DataType::Double, nix::NDSize({ 0, 0 }));
    extents = block.createDataArray("extents_DataArray", "dataArray", DataType::Double, nix::NDSize({ 0, 0 }));
    // create units
    atomic_units = {"m", "cm", "mm"};
    compound_units = {"mV*cm", "m*s", "s/cm"};
    invalid_units = {"foo"};
    // create multi tag &amp; tag
    mtag = block.createMultiTag("tag_one", "test_tag", positions);
    mtag.extents(extents);
    mtag.references(refs);
    tag = block.createTag("tag_one", "test_tag", {0.0, 2.0, 3.4});
    tag.references(refs);
    units_tmp = tag_tmp(compound_units);
    // create dimensions
    dim_set1 = array1.appendSetDimension();
    dim_set2 = array1.appendSetDimension();
    dim_set3 = array1.appendSetDimension();
    dim_range1 = array2.appendRangeDimension({1, 2, 3});
    dim_range2 = array2.appendRangeDimension({1, 2, 3, 4});
    dim_range3 = array2.appendRangeDimension({1, 2});
    dim_sample1 = array3.appendSampledDimension(42);
    dim_sample2 = array3.appendSampledDimension(42);
    dim_sample3 = array3.appendSampledDimension(42);
    dim_frame1 = array5.appendDataFrameDimension(frame1);
}

void TestValidate::tearDown() {
    return;
}

void TestValidate::setValid() {
    // fill sinus data &amp; leave it in file for plot testing
    typedef boost::multi_array&lt;double, 2&gt; array2D_type;
    typedef array2D_type::index index;
    array2D_type sin_array(boost::extents[1000][1000]);
    const double PI = boost::math::constants::pi&lt;double&gt;();
    for (index i = 0; i &lt; 1000; ++i) {
        for (index j = 0; j &lt; 1000; ++j) {
            sin_array[i][j] = std::sin(PI * j / std::sqrt((i&gt;0)?i:1));
        }
    }
    array4.setData(sin_array);
    array4.deleteDimensions();
    array4.appendSampledDimension(1.);
    array4.appendSetDimension();
    // fill array1 &amp; array2
    typedef boost::multi_array&lt;double, 3&gt; array_type;
    typedef array_type::index index;
    array_type A(boost::extents[3][4][2]);
    int values = 0;
    for (index i = 0; i != 3; ++i)
        for (index j = 0; j != 4; ++j)
            for (index k = 0; k != 2; ++k)
                A[i][j][k] = values++;
    array1.setData(A);
    array2.setData(A);
    array2.deleteDimensions();
    dim_range1 = array2.appendRangeDimension({1, 2, 3});
    dim_range2 = array2.appendRangeDimension({1, 2, 3, 4});
    dim_range3 = array2.appendRangeDimension({1, 2});

    array3.setData(A);

    // fill extent &amp; position
    extent.resize(3);
    position.resize(3);
    std::iota(std::begin(extent), std::end(extent), 0);
    std::iota(std::begin(position), std::end(position), 0);

    // fill extents &amp; positions
    array2D_type B(boost::extents[5][3]);
    for (index i = 0; i &lt; 5; ++i) {
        for (index j = 0; j &lt; 3; ++j) {
            B[i][j] = 100.0*i;
        }
    }
    positions.setData(B);

    array2D_type C(boost::extents[5][3]);
    for (index i = 0; i &lt; 5; ++i) {
        for (index j = 0; j &lt; 3; ++j) {
            C[i][j] = 100.0*i;
        }
    }
    extents.setData(C);

    // ensure correct dimension descriptors for positions
    positions.deleteDimensions();
    positions.appendSetDimension();
    positions.appendSetDimension();
    extents.deleteDimensions();
    extents.appendSetDimension();
    extents.appendSetDimension();

    // fill MultiTag
    refs = {array2, array3};
    mtag.units(atomic_units);
    // fill Tag
    tag.extent(extent);
    tag.position(position);
    tag.units(atomic_units);
    // fill dimensions
    dim_set1.labels({"label_a", "label_b", "label_c"});
    dim_set2.labels({"label_a", "label_b", "label_c", "label_d"});
    dim_set3.labels({"label_a", "label_b"});
    dim_range1.unit(atomic_units[0]);
    dim_range2.unit(atomic_units[1]);
    dim_range3.unit(atomic_units[2]);
    dim_sample1.unit(atomic_units[0]);
    dim_sample2.unit(atomic_units[1]);
    dim_sample3.unit(atomic_units[2]);
    // fill tag_tmp
    units_tmp = tag_tmp(compound_units);

    // fill array5
    size_t count = 10;
    std::vector&lt;double&gt; array5_data(count);
    for (size_t i = 0; i &lt; count; ++i)
        array5_data[i] = i * 3.14;
    array5.setData(array5_data);
    // fill data frame
    frame1.rows(count);
    std::vector&lt;nix::Variant&gt; vals(1);
    for (size_t i = 0; i &lt; count; ++i) {
        vals[0].set(i * 2.5);
        frame1.writeRow(i, vals);
    }

    return;
}

void TestValidate::setInvalid() {
    // fill array1 &amp; array2
    typedef boost::multi_array&lt;double, 3&gt; array_type;
    typedef array_type::index index;
    array_type A(boost::extents[3][4][2]);
    int values = 0;
    for (index i = 0; i != 3; ++i)
        for (index j = 0; j != 4; ++j)
            for (index k = 0; k != 2; ++k)
                A[i][j][k] = values++;
    array1.setData(A);
    array2.setData(A);
    array3.setData(A);

    // fill extent &amp; position
    extent.resize(6);
    position.resize(9);
    std::iota(std::begin(extent), std::end(extent), 0);
    std::iota(std::begin(position), std::end(position), 0);

    // fill extents &amp; positions
    typedef boost::multi_array&lt;double, 2&gt; array2D_type;
    typedef array2D_type::index index;
    array2D_type B(boost::extents[4][2]);
    for (index i = 0; i &lt; 4; ++i) {
        for (index j = 0; j &lt; 2; ++j) {
            B[i][j] = 100.0*i;
        }
    }
    extents.setData(B);
    array2D_type C(boost::extents[5][2]);
    for (index i = 0; i &lt; 5; ++i) {
        for (index j = 0; j &lt; 2; ++j) {
            C[i][j] = 100.0*i;
        }
    }
    positions.setData(C);
    // fill MultiTag
    refs = {array1, array2};
    mtag.units(atomic_units);
    // fill Tag
    tag.extent(extent);
    tag.position(position);
    tag.units(atomic_units);
    // fill dimensions
    dim_set3.labels({"label_a", "label_b", "label_c"});
    dim_set1.labels({"label_a", "label_b", "label_c", "label_d"});
    dim_set2.labels({"label_a", "label_b"});
    dim_range3.ticks({1, 2, 3});
    dim_range1.ticks({1, 2, 3, 4});
    dim_range2.ticks({1, 2});
    dim_sample3.unit(atomic_units[0]);
    dim_sample1.unit(atomic_units[1]);
    dim_sample2.unit(atomic_units[2]);
    // fill tag_tmp
    units_tmp = tag_tmp(invalid_units);
    // remove dimension descriptors from array4, position and extents
    array4.deleteDimensions();
    positions.deleteDimensions();
    extents.deleteDimensions();

    // fill array5
    size_t count = 10;
    std::vector&lt;double&gt; array5_data(count);
    for (size_t i = 0; i &lt; count; ++i)
        array5_data[i] = i * 3.14;
    array5.setData(array5_data);
    // fill data frame
    frame1.rows(count - 5);
    std::vector&lt;nix::Variant&gt; vals(1);
    for (size_t i = 0; i &lt; count - 5; ++i) {
        vals[0].set(i * 2.5);
        frame1.writeRow(i, vals);
    }

    return;
}

void TestValidate::test() {

    // check if nix::getEntityName works correctly
    // this is here because there is currently no better place
    // and we only use that function in the validation code
    boost::optional&lt;std::string&gt; name = nix::getEntityName(block);
    CPPUNIT_ASSERT(!!name);
    CPPUNIT_ASSERT_EQUAL(*name, block.name());

    name = nix::getEntityName(file);
    CPPUNIT_ASSERT(!name);

    valid::Message m1("w1", "meh", std::string("michi"));
    CPPUNIT_ASSERT_EQUAL(m1.id, std::string("w1"));
    CPPUNIT_ASSERT_EQUAL(m1.msg, std::string("meh"));
    CPPUNIT_ASSERT(!!m1.name);
    CPPUNIT_ASSERT_EQUAL(std::string("michi"), *m1.name);

    // test result class
    valid::Result res;
    CPPUNIT_ASSERT_EQUAL(false, res.hasWarnings());
    CPPUNIT_ASSERT_EQUAL(false, res.hasErrors());
    CPPUNIT_ASSERT_EQUAL(true, res.ok());

    valid::Message w1("0xWARN", "You have been warned!");
    valid::Message e1("0xERR", "Told you so!");

    res.addWarning(w1);
    CPPUNIT_ASSERT_EQUAL(false, res.hasErrors());
    CPPUNIT_ASSERT_EQUAL(true, res.hasWarnings());

    res.addError(e1);
    CPPUNIT_ASSERT_EQUAL(true, res.hasErrors());
    CPPUNIT_ASSERT_EQUAL(true, res.hasWarnings());

    std::stringstream out;
    out &lt;&lt; res;
    std::string outs = out.str();

    CPPUNIT_ASSERT(outs.find("0xWARN") != std::string::npos);
    CPPUNIT_ASSERT(outs.find("0xERR") != std::string::npos);
    CPPUNIT_ASSERT(outs.find("You have been warned!") != std::string::npos);
    CPPUNIT_ASSERT(outs.find("Told you so!") != std::string::npos);

    // dummy class to test empty checks
    class fooC {
    public:
        std::string getFoo () const { return std::string("I'm not empty!"); };
        std::string getBar () const { return std::string(); };
        std::vector&lt;int&gt; getSorted () const { return std::vector&lt;int&gt;({1, 2, 3}); };
        std::vector&lt;int&gt; getUnsorted () const { return std::vector&lt;int&gt;({3, 1, 2}); };
    };

    std::vector&lt;std::string&gt; vect = {"foo", "bar"};
    std::vector&lt;std::string&gt; vect2;
    fooC foobar;

    // success cases----------------------------------------------------
    // -----------------------------------------------------------------
    valid::Result myResult = validator({
        could(vect, &amp;std::vector&lt;std::string&gt;::empty, isFalse(), {
            must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(2), "notSmaller(2)") }),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(2), "notSmaller(2)"),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, isSmaller(2), "isSmaller(2)"),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, notGreater(2), "notGreater(2)"),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isGreater(0), "isGreater(0)"),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notEqual&lt;size_t&gt;(0), "notEqual&lt;size_t&gt;(0)"),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isEqual&lt;size_t&gt;(2), "isEqual&lt;size_t&gt;(2)"),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, isFalse(), "isFalse()"),
        must(foobar, &amp;fooC::getFoo, notEmpty(), "notEmpty()"),
        should(foobar, &amp;fooC::getBar, isEmpty(), "isEmpty()"),
        should(foobar, &amp;fooC::getSorted, isSorted(), "isSorted()")
    });
    // have debug info
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT_EQUAL(true, myResult.ok());
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasWarnings());
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasErrors());

    // failure cases----------------------------------------------------
    // -----------------------------------------------------------------
    myResult = validator({
        could(vect, &amp;std::vector&lt;std::string&gt;::empty, isFalse(), {
            must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(3), "notSmaller(3)") }),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(3), "notSmaller(3)"),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, isSmaller(0), "isSmaller(0)"),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, notGreater(1), "notGreater(1)"),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isGreater(2), "isGreater(2)"),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notEqual&lt;size_t&gt;(2), "notEqual&lt;size_t&gt;(2)"),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isEqual&lt;size_t&gt;(0), "isEqual&lt;size_t&gt;(0)"),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, notFalse(), "notFalse()"),
        must(foobar, &amp;fooC::getFoo, isEmpty(), "notEmpty()"),
        should(foobar, &amp;fooC::getBar, notEmpty(), "isEmpty()"),
        should(foobar, &amp;fooC::getUnsorted, isSorted(), "isSorted()")
    });
    // uncomment this to have debug info
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT(myResult.getWarnings().size() == 5);
    CPPUNIT_ASSERT(myResult.getErrors().size() == 6);

    // entity success cases---------------------------------------------
    // -----------------------------------------------------------------
    setValid();
    myResult = validator({
        could(mtag, &amp;nix::MultiTag::positions, dimEquals(2), {
            must(mtag, &amp;nix::MultiTag::extents, dimEquals(2), "dimEquals(2)") }),
        must(  mtag,   &amp;nix::MultiTag::extents, dimEquals(2), "dimEquals(2)"),
        should(array1, &amp;nix::DataArray::dimensions, dimLabelsMatchData(array1), "dimLabelsMatchData(array)"),
        must(  array2, &amp;nix::DataArray::dimensions, dimTicksMatchData(array2),  "dimTicksMatchData(array)"),
        must(  array5, &amp;nix::DataArray::dimensions, dimDataFrameTicksMatchData(array5), "dimDataFrameTicksMatchData(array)"),

        should(dim_range1, &amp;nix::RangeDimension::unit, isAtomicUnit(), "isAtomicUnit(); (dim_range1)"),
        should(tag,       &amp;nix::Tag::units,     isAtomicUnit(), "isAtomicUnit(); (tag)"),
        must(units_tmp, &amp;tag_tmp::unit,  isCompoundUnit(), "isCompoundUnit(); (units_tmp.unit)"),
        must(units_tmp, &amp;tag_tmp::units, isCompoundUnit(), "isCompoundUnit(); (units_tmp.units)"),
        must(units_tmp, &amp;tag_tmp::unito, isCompoundUnit(), "isCompoundUnit(); (units_tmp.unito)"),
        should(units_tmp, &amp;tag_tmp::unit,  isValidUnit(), "isValidUnit(); (units_tmp.unit)"),
        must(  units_tmp, &amp;tag_tmp::units, isValidUnit(), "isValidUnit(); (units_tmp.units)"),
        should(units_tmp, &amp;tag_tmp::unito, isValidUnit(), "isValidUnit(); (units_tmp.unito)"),
        must(tag, &amp;nix::Tag::references, tagUnitsMatchRefsUnits(atomic_units), "tagUnitsMatchRefsUnits(atomic_units); (tag)")
    });
    // have debug info
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasWarnings());
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasErrors());

    myResult = file.validate();
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getWarnings().size());
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getErrors().size());
    // entity failure cases---------------------------------------------
    // -----------------------------------------------------------------

    setInvalid();
    myResult = validator({
        could(mtag, &amp;nix::MultiTag::positions, dimEquals(2), {
            must(mtag, &amp;nix::MultiTag::extents, dimEquals(42), "dimEquals(42)") }),//
        must(  mtag,   &amp;nix::MultiTag::extents, dimEquals(42), "dimEquals(42)"),//
        should(array1, &amp;nix::DataArray::dimensions, dimLabelsMatchData(array1), "dimLabelsMatchData(array)"),
        must(array5, &amp;nix::DataArray::dimensions, dimDataFrameTicksMatchData(array5), "dimDataFrameTicksMatchData(array"),
        must(units_tmp, &amp;tag_tmp::unit,  isAtomicUnit(), "isAtomicUnit(); (units_tmp.unit)"),
        must(units_tmp, &amp;tag_tmp::units, isAtomicUnit(), "isAtomicUnit(); (units_tmp.units)"),
        must(units_tmp, &amp;tag_tmp::unit,  isCompoundUnit(), "isCompoundUnit(); (units_tmp.unit)"),
        must(units_tmp, &amp;tag_tmp::units, isCompoundUnit(), "isCompoundUnit(); (units_tmp.units)"),
        must(units_tmp, &amp;tag_tmp::unito, isCompoundUnit(), "isCompoundUnit(); (units_tmp.unito)"),
        should(units_tmp, &amp;tag_tmp::unit,  isValidUnit(), "isValidUnit(); (units_tmp.unit)"),
        must(  units_tmp, &amp;tag_tmp::units, isValidUnit(), "isValidUnit(); (units_tmp.units)"),
        should(units_tmp, &amp;tag_tmp::unito, isValidUnit(), "isValidUnit(); (units_tmp.unito)"),
        must(tag, &amp;nix::Tag::references, tagUnitsMatchRefsUnits(invalid_units), "tagUnitsMatchRefsUnits(atomic_units); (tag)")
    });
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT(myResult.getWarnings().size() == 3);
    CPPUNIT_ASSERT(myResult.getErrors().size() == 10);

    myResult = file.validate();
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getWarnings().size());
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(6), myResult.getErrors().size());

    // lets leave the file clean &amp; valid
    setValid();

}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestSection.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
// Copyright (c) 2013 - 2015, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in Section and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/util/util.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;

#include "BaseTestSection.hpp"

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;

using namespace nix;
using namespace valid;


void BaseTestSection::testValidate() {
    valid::Result result = validate(section);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestSection::testId() {
    CPPUNIT_ASSERT(section.id().size() == 36);
}


void BaseTestSection::testName() {
    CPPUNIT_ASSERT(section.name() == "section");
}


void BaseTestSection::testType() {
    CPPUNIT_ASSERT(section.type() == "metadata");
    std::string typ = util::createId();
    section.type(typ);
    CPPUNIT_ASSERT(section.type() == typ);
}


void BaseTestSection::testDefinition() {
    std::string def = util::createId();
    section.definition(def);
    CPPUNIT_ASSERT(*section.definition() == def);
    section.definition(nix::none);
    CPPUNIT_ASSERT(section.definition() == nix::none);
}


void BaseTestSection::testParent() {
    CPPUNIT_ASSERT(section.parent() == nix::none);

    Section child = section.createSection("child", "section");
    CPPUNIT_ASSERT(child.parent() != nix::none);
    CPPUNIT_ASSERT(child.parent().id() == section.id());

    CPPUNIT_ASSERT(child.parent().parent() == nix::none);
}


void BaseTestSection::testRepository() {
    CPPUNIT_ASSERT(!section.repository());
    std::string rep = "http://foo.bar/" + util::createId();
    section.repository(rep);
    CPPUNIT_ASSERT(section.repository() == rep);
    section.repository(boost::none);
    CPPUNIT_ASSERT(!section.repository());
    CPPUNIT_ASSERT_THROW(section.repository(""), EmptyString);
}


void BaseTestSection::testLink() {
    CPPUNIT_ASSERT(!section.link());

    section.link(section_other);
    CPPUNIT_ASSERT(section.link());
    CPPUNIT_ASSERT(section.link().id() == section_other.id());

    // test none-unsetter
    section.link(none);
    CPPUNIT_ASSERT(!section.link());
    section.link(section_other);
    CPPUNIT_ASSERT(section.link());
    Section null;
    section.link(null);
    CPPUNIT_ASSERT(!section.link());

    // test id setter and resetter
    CPPUNIT_ASSERT_THROW(section.link(""), EmptyString);
    CPPUNIT_ASSERT_THROW(section.link("invalid id"), std::runtime_error);

    section.link(section.id());
    CPPUNIT_ASSERT(section.link().id() == section.id());
    section.link(section_other.id());
    CPPUNIT_ASSERT(section.link().id() == section_other.id());
    // test deleter removing link too
    section.link(section);
     /* We create the following tree:
     *
     * section---l1n1---l2n1---l3n1------------
     *            |      |                    |
     *            ------l2n2---l3n2---l4n1---l5n1
     *                   |      |      |
     *                   ------l3n3---l4n2
     * section_other------------|
     */
    Section l1n1 = section.createSection("l1n1", "typ1");

    Section l2n1 = l1n1.createSection("l2n1", "t1");
    Section l2n2 = l1n1.createSection("l2n2", "t2");
    Section l3n1 = l2n1.createSection("l3n1", "t3");
    Section l3n2 = l2n2.createSection("l3n2", "t3");
    Section l3n3 = l2n2.createSection("l3n3", "t4");
    Section l4n1 = l3n2.createSection("l4n1", "typ2");
    Section l4n2 = l3n3.createSection("l4n2", "typ2");
    Section l5n1 = l4n1.createSection("l5n1", "typ2");

    l2n1.link(l2n2.id());
    l3n1.link(l5n1.id());
    l3n2.link(l3n3.id());
    l4n1.link(l4n2.id());
    section_other.link(l3n3.id());
    /* Chop the tree to:
     *
     * section---l1n1---l2n1---l3n1
     * section_other
     *
     */
    l1n1.deleteSection(l2n2.id());
    CPPUNIT_ASSERT(section.findSections().size() == 3);

    // test that all (horizontal) links are gone too:
    CPPUNIT_ASSERT(!l2n1.link());
    CPPUNIT_ASSERT(!l3n1.link());
    CPPUNIT_ASSERT(!l3n2.link());
    CPPUNIT_ASSERT(!l4n1.link());

    CPPUNIT_ASSERT(!section_other.link());
    CPPUNIT_ASSERT(!l1n1.hasSection(l2n2));

    /* Extend the tree to:
     *
     * section---l1n1---l2n1---l3n1
     * section_other-----|
     *
     * and then chop it down to:
     *
     * section_other
     *
     */
    section_other.link(l2n1.id());
    file.deleteSection(section.id());
    CPPUNIT_ASSERT(section_other.findSections().size() == 0);
    CPPUNIT_ASSERT(!section_other.link());
    // re-create section
    section = file.createSection("section", "metadata");
}


void BaseTestSection::testSectionAccess() {
    std::vector&lt;std::string&gt; names = { "section_a", "section_b", "section_c", "section_d", "section_e" };
    Section null;

    CPPUNIT_ASSERT(section.sectionCount() == 0);
    CPPUNIT_ASSERT(section.sections().size() == 0);
    CPPUNIT_ASSERT(section.getSection("invalid_id") == false);
    CPPUNIT_ASSERT_EQUAL(false, section.hasSection("invalid_id"));

    std::vector&lt;std::string&gt; ids;
    for (auto name : names) {
        Section child_section = section.createSection(name, "metadata");
        CPPUNIT_ASSERT(child_section.name() == name);
        CPPUNIT_ASSERT_EQUAL(true, section.hasSection(name));

        ids.push_back(child_section.id());
    }
    CPPUNIT_ASSERT(section.sectionCount() == names.size());
    CPPUNIT_ASSERT(section.sections().size() == names.size());

    CPPUNIT_ASSERT_THROW(section.createSection(names[0], "metadata"),
                         DuplicateName);
    CPPUNIT_ASSERT_THROW(section.getSection(section.sectionCount()), OutOfBounds);
    CPPUNIT_ASSERT_THROW(section.createSection("", "some type"), EmptyString);
    CPPUNIT_ASSERT(!section.hasSection(null));

    for (auto id : ids) {
        Section child_section = section.getSection(id);
        CPPUNIT_ASSERT(section.hasSection(id));
        CPPUNIT_ASSERT(section.hasSection(child_section));
        CPPUNIT_ASSERT_EQUAL(id, child_section.id());
        section.deleteSection(id);
    }
    Section s2 = section.createSection("a name", "a type");
    CPPUNIT_ASSERT(!section.deleteSection(null));
    CPPUNIT_ASSERT(section.deleteSection(s2));

    CPPUNIT_ASSERT(section.sectionCount() == 0);
    CPPUNIT_ASSERT(section.sections().size() == 0);
    CPPUNIT_ASSERT(section.getSection("invalid_id") == false);

    Section s = section.createSection("Test", "test");
    CPPUNIT_ASSERT(section.deleteSection(s));
    CPPUNIT_ASSERT(!section.deleteSection(s));
}


void BaseTestSection::testFindSection() {
    /* prepare
   |--- section_other [metadata]
   |
   |--- section [metadata]
         |--- l1n1 [t1]
         |     |--- l2n1 [t1]
         |     |     |--- l3n1 [t1]
         |     |--- l2n2 [t2]
         |     |--- l2n3 [t2]
         |           |--- l3n2 [t2]
         |           |--- l3n3 [t2]
         |
         |--- l1n2 [t2]
         |
         |--- l1n3 [t3]
               |--- l2n4 [t2]
               |--- l2n5 [t2]
               |--- l2n6 [t3]
                     |-- l3n4 [t2]
    */
    Section l1n1 = section.createSection("l1n1", "typ1");
    Section l1n2 = section.createSection("l1n2", "typ2");
    Section l1n3 = section.createSection("l1n3", "typ3");

    Section l2n1 = l1n1.createSection("l2n1", "typ1");
    Section l2n2 = l1n1.createSection("l2n2", "typ2");
    Section l2n3 = l1n1.createSection("l2n3", "typ2");
    Section l2n4 = l1n3.createSection("l2n4", "typ2");
    Section l2n5 = l1n3.createSection("l2n5", "typ2");
    Section l2n6 = l1n3.createSection("l2n6", "typ3");

    Section l3n1 = l2n1.createSection("l3n1", "typ1");
    Section l3n2 = l2n3.createSection("l3n2", "typ2");
    Section l3n3 = l2n3.createSection("l3n3", "typ2");
    Section l3n4 = l2n5.createSection("l3n4", "typ2");

    // test depth limit
    CPPUNIT_ASSERT(section.findSections().size() == 13);
    CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 2).size() == 9);
    CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 1).size() == 3);
    CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 0).size() == 0);

    // test file::findSections with depth
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 0).size() == 0);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 1).size() == 2);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 2).size() == 5);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 3).size() == 11);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 4).size() == 15);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 5).size() == 15);

    // test filter
    auto filter_typ1 = util::TypeFilter&lt;Section&gt;("typ1");
    auto filter_typ2 = util::TypeFilter&lt;Section&gt;("typ2");

    CPPUNIT_ASSERT(section.findSections(filter_typ1).size() == 3);
    CPPUNIT_ASSERT(section.findSections(filter_typ2).size() == 8);
}


bool findSectionsInVector(const std::vector&lt;Section&gt; &amp;results, const std::vector&lt;std::string&gt; &amp;names) {
   bool found = true;
   for (const auto &amp;name : names) {
       found = found &amp;&amp; (std::find_if(results.begin(), results.end(),
                                      [name] (const Section &amp;s) {
                                              return s.name() == name; }) != results.end());
   }
   return found;
}


void BaseTestSection::testFindRelated() {
    /* we create the following tree
    section --- l1n1 [t1]
                 |-- l2n1 [t2]
                 |    |-- l3n1 [t4]
                 |         |-- l4n1 [t5]
                 |
                 |-- l2n2 [t3]
                 |    |-- l3n2 [t1]
                 |
                 |-- l2n3 [t2]
                 |
                 |-- l2n4 [t3]
                      |-- l3n3 [t4]
                      |    |-- l4n2 [t5]
                      |         |-- l5n1 [t4]
                      |
                      |-- l3n4 [t1]
                           |-- l4n3 [t3]
    */
    Section l1n1 = section.createSection("L1N1", "t1");

    Section l2n1 = l1n1.createSection("L2N1", "t2");
    Section l2n2 = l1n1.createSection("L2N2", "t3");
    Section l2n3 = l1n1.createSection("L2N3", "t2");
    Section l2n4 = l1n1.createSection("L2N4", "t3");

    Section l3n1 = l2n1.createSection("L3N1", "t4");
    Section l3n2 = l2n2.createSection("L3N2", "t1");
    Section l3n3 = l2n4.createSection("L3N3", "t4");
    Section l3n4 = l2n4.createSection("L3N4", "t1");

    Section l4n1 = l3n1.createSection("L4N1", "t5");
    Section l4n2 = l3n3.createSection("L4N2", "t5");
    Section l4n3 = l3n4.createSection("L4N3", "t3");

    Section l5n1 = l4n2.createSection("L5N1", "t4");

    std::vector&lt;Section&gt; results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N2", "L3N4"}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1", "L2N3"}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N2", "L2N4"}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N1", "L3N3"}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N1", "L4N2"}));
    // ----------- l2n1 -------------
    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L1N1"}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N3"}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N2", "L2N4"}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N1"}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N1"}));

    // ----------- l2n2 -------------
    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N4"}));

    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1", "L2N3"}));

    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
    CPPUNIT_ASSERT(results.size() == 0);

    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
    CPPUNIT_ASSERT(results.size() == 0);

    // ----------- l2n4 -------------
    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N4"}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1", "L2N3"}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N3"}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N3"}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N2"}));

    // ----------- l3n1 -------------
    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L1N1"}));

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1"}));

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N2", "L2N4"}));

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
    CPPUNIT_ASSERT(results.size() == 0);

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N1"}));

    // ----------- l4n1 --------------
    results = l4n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L1N1"}));

    results = l4n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1"}));
    section.deleteSection(l1n1);
}


void BaseTestSection::testPropertyAccess() {
    std::vector&lt;std::string&gt; names = { "property_a", "property_b", "property_c", "property_d", "property_e" };

    CPPUNIT_ASSERT(section.propertyCount() == 0);
    CPPUNIT_ASSERT(section.properties().size() == 0);
    CPPUNIT_ASSERT(section.getProperty("invalid_id") == false);
    CPPUNIT_ASSERT_EQUAL(false, section.hasProperty("invalid_id"));

    Property p = section.createProperty("empty_prop", DataType::Double);
    CPPUNIT_ASSERT(section.propertyCount() == 1);
    CPPUNIT_ASSERT(section.hasProperty(p));
    CPPUNIT_ASSERT(section.hasProperty("empty_prop"));
    Property prop = section.getProperty("empty_prop");
    CPPUNIT_ASSERT(prop.dataType() == nix::DataType::Double);
    section.deleteProperty(p.id());
    CPPUNIT_ASSERT(section.propertyCount() == 0);
    CPPUNIT_ASSERT(!section.hasProperty(p));
    CPPUNIT_ASSERT(!section.deleteProperty(p));

    Variant dummy(10);
    prop = section.createProperty("single value", dummy);
    CPPUNIT_ASSERT(section.hasProperty("single value"));
    CPPUNIT_ASSERT(section.propertyCount() == 1);
    section.deleteProperty(prop);
    CPPUNIT_ASSERT(section.propertyCount() == 0);

    std::vector&lt;std::string&gt; ids;
    for (auto name : names) {
        prop = section.createProperty(name, dummy);
        CPPUNIT_ASSERT(prop.name() == name);
        CPPUNIT_ASSERT(section.hasProperty(name));

        Property prop_copy = section.getProperty(name);

        CPPUNIT_ASSERT(prop_copy.id() == prop.id());

        ids.push_back(prop.id());
    }
    CPPUNIT_ASSERT_THROW(section.createProperty(names[0], dummy),
                         DuplicateName);

    CPPUNIT_ASSERT(section.propertyCount() == names.size());
    CPPUNIT_ASSERT(section.properties().size() == names.size());
    section_other.createProperty("some_prop", dummy);
    section_other.link(section);
    CPPUNIT_ASSERT(section_other.propertyCount() == 1);
    CPPUNIT_ASSERT(section_other.inheritedProperties().size() == names.size() + 1);

    for (auto id : ids) {
        Property prop = section.getProperty(id);
        CPPUNIT_ASSERT(section.hasProperty(id));
        CPPUNIT_ASSERT(prop.id() == id);

        section.deleteProperty(id);
    }

    CPPUNIT_ASSERT(section.propertyCount() == 0);
    CPPUNIT_ASSERT(section.properties().size() == 0);
    CPPUNIT_ASSERT(section.getProperty("invalid_id") == false);
}


void BaseTestSection::testReferringData() {
    nix::Section ref_sec = file.createSection("referrenced", "test");

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 0);

    b = file.createBlock("test_block", "test");
    b2 = file.createBlock("test_block2", "test");
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 0);

    for (int i = 0; i &lt; 10; i++) {
        std::string name = "data_array_" + nix::util::numToStr(i);
        nix::DataArray da = b.createDataArray(name, "analog signal", nix::DataType::Double, nix::NDSize({ 20, 20 }));
        nix::DataArray da2 = b2.createDataArray(name, "analog signal", nix::DataType::Double, nix::NDSize({ 10, 10 }));
        if (i % 2 == 0) {
            da.metadata(ref_sec);
        } else {
            da2.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays().size() == 10);
}


void BaseTestSection::testReferringTags() {
    nix::Section ref_sec = file.createSection("referrenced", "test");

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 0);

    b = file.createBlock("test_block", "test");
    b2 = file.createBlock("test_block2", "test");
    CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 0);

    for (int i = 0; i &lt; 10; i++) {
        std::string name = "tag_" + nix::util::numToStr(i);
        nix::Tag t = b.createTag(name, "some tag", {1.});
        nix::Tag t2 = b2.createTag(name, "some tag", {1.});
        if (i % 2 == 0) {
            t.metadata(ref_sec);
        } else {
            t2.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringTags().size() == 10);
}


void BaseTestSection::testReferringMultiTags() {
    nix::Section ref_sec = file.createSection("referrenced", "test");

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 0);
<a name="0"></a>    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 0);

    b = file.createBlock("test_block", "test");
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    b2 = file.createBlock("test_block2", "test");
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 0);
    DataArray positions = b.createDataArray("positions", "positions", nix::DataType::Double, nix::NDSize({ 20, 1 }));
    DataArray positions2 = b2.createDataArray("positions", "positions", nix::DataType::Double, nix::NDSize({ 20, 1 }));</b></font>

    for (int i = 0; i &lt; 10; i++) {
        std::string name = "tag_" + nix::util::numToStr(i);
        nix::MultiTag t = b.createMultiTag(name, "some tag", positions);
        nix::MultiTag t2 = b2.createMultiTag(name, "some tag", positions2);
        if (i % 2 == 0) {
            t.metadata(ref_sec);
        } else {
            t2.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags().size() == 10);
}


void BaseTestSection::testReferringSources() {
    nix::Section ref_sec = file.createSection("referrenced", "test");

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 0);

    b = file.createBlock("test_block", "test");
    b2 = file.createBlock("test_block2", "test");
    CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 0);

    for (int i = 0; i &lt; 10; i++) {
        std::string name = "src_" + nix::util::numToStr(i);
        nix::Source s = b.createSource(name, "some src");
        nix::Source s2 = b2.createSource(name, "some src");
        nix::Source s3 = s2.createSource(name + "_child", "child_source");
        if (i % 2 == 0) {
            s.metadata(ref_sec);
        } else {
            s3.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringSources().size() == 10);
}


void BaseTestSection::testReferringBlocks() {
    nix::Section ref_sec = file.createSection("referrenced", "test");
    for (int i = 0; i &lt; 10; i++) {
        std::string name = "block_" + nix::util::numToStr(i);
        nix::Block b = file.createBlock(name, "some blck");
        nix::Block b2 = file.createBlock(name + "_scnd", "test");
        if (i % 2 == 0) {
            b.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringBlocks().size() == 5);
}


void BaseTestSection::testOperators() {
    CPPUNIT_ASSERT(section_null == false);
    CPPUNIT_ASSERT(section_null == none);

    CPPUNIT_ASSERT(section != false);
    CPPUNIT_ASSERT(section != none);

    CPPUNIT_ASSERT(section == section);
    CPPUNIT_ASSERT(section != section_other);

    section_other = section;
    CPPUNIT_ASSERT(section == section_other);

    section_other = none;
    CPPUNIT_ASSERT(section_other == false);
    CPPUNIT_ASSERT(section_other == none);

    std::stringstream str1, str2;
    str1 &lt;&lt;  "Section: {name = " &lt;&lt; section.name();
    str1 &lt;&lt; ", type = " &lt;&lt; section.type();
    str1 &lt;&lt; ", id = " &lt;&lt; section.id() &lt;&lt; "}";
    str2 &lt;&lt; section;
    CPPUNIT_ASSERT(str1.str() == str2.str());

}


void BaseTestSection::testCreatedAt() {
    CPPUNIT_ASSERT(section.createdAt() &gt;= startup_time);
    time_t past_time = time(NULL) - 10000000;
    section.forceCreatedAt(past_time);
    CPPUNIT_ASSERT(section.createdAt() == past_time);
}


void BaseTestSection::testUpdatedAt() {
    CPPUNIT_ASSERT(section.updatedAt() &gt;= startup_time);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
