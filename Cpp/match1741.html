<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TestValidate.cpp &amp; BaseTestSection.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestValidate.cpp &amp; BaseTestSection.cpp
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestValidate.cpp (2.9411764%)<th>BaseTestSection.cpp (2.8463%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(33-36)<td><a href="#" name="0">(565-569)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestValidate.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TestValidate.hpp"
2 #include &lt;nix/valid/validator.hpp&gt;
3 #include &lt;nix/valid/checks.hpp&gt;
4 #include &lt;nix/valid/conditions.hpp&gt;
5 #include &lt;nix/valid/validate.hpp&gt;
6 #include &lt;nix.hpp&gt;
7 #include &lt;ctime&gt;
8 #include &lt;functional&gt;
9 #include &lt;numeric&gt;
10 #include &lt;math.h&gt;
11 #include &lt;boost/math/constants/constants.hpp&gt;
12 using namespace nix;
13 using namespace valid;
14 using namespace std;
15 void TestValidate::setUp() {
16 <a name="0"></a>    startup_time = time(NULL);
17     file = nix::File::open("test_validate.h5", nix::FileMode::Overwrite);
18 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    block = file.createBlock("block_one", "dataset");
19     array1 = block.createDataArray("array_one", "testdata", nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));
20     array2 = block.createDataArray("array_two", "testdata", nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));</b></font>
21     array3 = block.createDataArray("array_three", "testdata", nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));
22     array4 = block.createDataArray("array_four", "sindata", nix::DataType::Double, nix::NDSize({ 0, 0}));
23     array5 = block.createDataArray("array_five", "dftest", nix::DataType::Double, nix::NDSize{ 0 });
24     std::vector&lt;nix::Column&gt; cols = {{"current", "nA", nix::DataType::Double}};
25     frame1 = block.createDataFrame("frame_one", "conditions", cols);
26     refs = {array2, array3};
27     positions = block.createDataArray("positions_DataArray", "dataArray", DataType::Double, nix::NDSize({ 0, 0 }));
28     extents = block.createDataArray("extents_DataArray", "dataArray", DataType::Double, nix::NDSize({ 0, 0 }));
29     atomic_units = {"m", "cm", "mm"};
30     compound_units = {"mV*cm", "m*s", "s/cm"};
31     invalid_units = {"foo"};
32     mtag = block.createMultiTag("tag_one", "test_tag", positions);
33     mtag.extents(extents);
34     mtag.references(refs);
35     tag = block.createTag("tag_one", "test_tag", {0.0, 2.0, 3.4});
36     tag.references(refs);
37     units_tmp = tag_tmp(compound_units);
38     dim_set1 = array1.appendSetDimension();
39     dim_set2 = array1.appendSetDimension();
40     dim_set3 = array1.appendSetDimension();
41     dim_range1 = array2.appendRangeDimension({1, 2, 3});
42     dim_range2 = array2.appendRangeDimension({1, 2, 3, 4});
43     dim_range3 = array2.appendRangeDimension({1, 2});
44     dim_sample1 = array3.appendSampledDimension(42);
45     dim_sample2 = array3.appendSampledDimension(42);
46     dim_sample3 = array3.appendSampledDimension(42);
47     dim_frame1 = array5.appendDataFrameDimension(frame1);
48 }
49 void TestValidate::tearDown() {
50     return;
51 }
52 void TestValidate::setValid() {
53     typedef boost::multi_array&lt;double, 2&gt; array2D_type;
54     typedef array2D_type::index index;
55     array2D_type sin_array(boost::extents[1000][1000]);
56     const double PI = boost::math::constants::pi&lt;double&gt;();
57     for (index i = 0; i &lt; 1000; ++i) {
58         for (index j = 0; j &lt; 1000; ++j) {
59             sin_array[i][j] = std::sin(PI * j / std::sqrt((i&gt;0)?i:1));
60         }
61     }
62     array4.setData(sin_array);
63     array4.deleteDimensions();
64     array4.appendSampledDimension(1.);
65     array4.appendSetDimension();
66     typedef boost::multi_array&lt;double, 3&gt; array_type;
67     typedef array_type::index index;
68     array_type A(boost::extents[3][4][2]);
69     int values = 0;
70     for (index i = 0; i != 3; ++i)
71         for (index j = 0; j != 4; ++j)
72             for (index k = 0; k != 2; ++k)
73                 A[i][j][k] = values++;
74     array1.setData(A);
75     array2.setData(A);
76     array2.deleteDimensions();
77     dim_range1 = array2.appendRangeDimension({1, 2, 3});
78     dim_range2 = array2.appendRangeDimension({1, 2, 3, 4});
79     dim_range3 = array2.appendRangeDimension({1, 2});
80     array3.setData(A);
81     extent.resize(3);
82     position.resize(3);
83     std::iota(std::begin(extent), std::end(extent), 0);
84     std::iota(std::begin(position), std::end(position), 0);
85     array2D_type B(boost::extents[5][3]);
86     for (index i = 0; i &lt; 5; ++i) {
87         for (index j = 0; j &lt; 3; ++j) {
88             B[i][j] = 100.0*i;
89         }
90     }
91     positions.setData(B);
92     array2D_type C(boost::extents[5][3]);
93     for (index i = 0; i &lt; 5; ++i) {
94         for (index j = 0; j &lt; 3; ++j) {
95             C[i][j] = 100.0*i;
96         }
97     }
98     extents.setData(C);
99     positions.deleteDimensions();
100     positions.appendSetDimension();
101     positions.appendSetDimension();
102     extents.deleteDimensions();
103     extents.appendSetDimension();
104     extents.appendSetDimension();
105     refs = {array2, array3};
106     mtag.units(atomic_units);
107     tag.extent(extent);
108     tag.position(position);
109     tag.units(atomic_units);
110     dim_set1.labels({"label_a", "label_b", "label_c"});
111     dim_set2.labels({"label_a", "label_b", "label_c", "label_d"});
112     dim_set3.labels({"label_a", "label_b"});
113     dim_range1.unit(atomic_units[0]);
114     dim_range2.unit(atomic_units[1]);
115     dim_range3.unit(atomic_units[2]);
116     dim_sample1.unit(atomic_units[0]);
117     dim_sample2.unit(atomic_units[1]);
118     dim_sample3.unit(atomic_units[2]);
119     units_tmp = tag_tmp(compound_units);
120     size_t count = 10;
121     std::vector&lt;double&gt; array5_data(count);
122     for (size_t i = 0; i &lt; count; ++i)
123         array5_data[i] = i * 3.14;
124     array5.setData(array5_data);
125     frame1.rows(count);
126     std::vector&lt;nix::Variant&gt; vals(1);
127     for (size_t i = 0; i &lt; count; ++i) {
128         vals[0].set(i * 2.5);
129         frame1.writeRow(i, vals);
130     }
131     return;
132 }
133 void TestValidate::setInvalid() {
134     typedef boost::multi_array&lt;double, 3&gt; array_type;
135     typedef array_type::index index;
136     array_type A(boost::extents[3][4][2]);
137     int values = 0;
138     for (index i = 0; i != 3; ++i)
139         for (index j = 0; j != 4; ++j)
140             for (index k = 0; k != 2; ++k)
141                 A[i][j][k] = values++;
142     array1.setData(A);
143     array2.setData(A);
144     array3.setData(A);
145     extent.resize(6);
146     position.resize(9);
147     std::iota(std::begin(extent), std::end(extent), 0);
148     std::iota(std::begin(position), std::end(position), 0);
149     typedef boost::multi_array&lt;double, 2&gt; array2D_type;
150     typedef array2D_type::index index;
151     array2D_type B(boost::extents[4][2]);
152     for (index i = 0; i &lt; 4; ++i) {
153         for (index j = 0; j &lt; 2; ++j) {
154             B[i][j] = 100.0*i;
155         }
156     }
157     extents.setData(B);
158     array2D_type C(boost::extents[5][2]);
159     for (index i = 0; i &lt; 5; ++i) {
160         for (index j = 0; j &lt; 2; ++j) {
161             C[i][j] = 100.0*i;
162         }
163     }
164     positions.setData(C);
165     refs = {array1, array2};
166     mtag.units(atomic_units);
167     tag.extent(extent);
168     tag.position(position);
169     tag.units(atomic_units);
170     dim_set3.labels({"label_a", "label_b", "label_c"});
171     dim_set1.labels({"label_a", "label_b", "label_c", "label_d"});
172     dim_set2.labels({"label_a", "label_b"});
173     dim_range3.ticks({1, 2, 3});
174     dim_range1.ticks({1, 2, 3, 4});
175     dim_range2.ticks({1, 2});
176     dim_sample3.unit(atomic_units[0]);
177     dim_sample1.unit(atomic_units[1]);
178     dim_sample2.unit(atomic_units[2]);
179     units_tmp = tag_tmp(invalid_units);
180     array4.deleteDimensions();
181     positions.deleteDimensions();
182     extents.deleteDimensions();
183     size_t count = 10;
184     std::vector&lt;double&gt; array5_data(count);
185     for (size_t i = 0; i &lt; count; ++i)
186         array5_data[i] = i * 3.14;
187     array5.setData(array5_data);
188     frame1.rows(count - 5);
189     std::vector&lt;nix::Variant&gt; vals(1);
190     for (size_t i = 0; i &lt; count - 5; ++i) {
191         vals[0].set(i * 2.5);
192         frame1.writeRow(i, vals);
193     }
194     return;
195 }
196 void TestValidate::test() {
197     boost::optional&lt;std::string&gt; name = nix::getEntityName(block);
198     CPPUNIT_ASSERT(!!name);
199     CPPUNIT_ASSERT_EQUAL(*name, block.name());
200     name = nix::getEntityName(file);
201     CPPUNIT_ASSERT(!name);
202     valid::Message m1("w1", "meh", std::string("michi"));
203     CPPUNIT_ASSERT_EQUAL(m1.id, std::string("w1"));
204     CPPUNIT_ASSERT_EQUAL(m1.msg, std::string("meh"));
205     CPPUNIT_ASSERT(!!m1.name);
206     CPPUNIT_ASSERT_EQUAL(std::string("michi"), *m1.name);
207     valid::Result res;
208     CPPUNIT_ASSERT_EQUAL(false, res.hasWarnings());
209     CPPUNIT_ASSERT_EQUAL(false, res.hasErrors());
210     CPPUNIT_ASSERT_EQUAL(true, res.ok());
211     valid::Message w1("0xWARN", "You have been warned!");
212     valid::Message e1("0xERR", "Told you so!");
213     res.addWarning(w1);
214     CPPUNIT_ASSERT_EQUAL(false, res.hasErrors());
215     CPPUNIT_ASSERT_EQUAL(true, res.hasWarnings());
216     res.addError(e1);
217     CPPUNIT_ASSERT_EQUAL(true, res.hasErrors());
218     CPPUNIT_ASSERT_EQUAL(true, res.hasWarnings());
219     std::stringstream out;
220     out &lt;&lt; res;
221     std::string outs = out.str();
222     CPPUNIT_ASSERT(outs.find("0xWARN") != std::string::npos);
223     CPPUNIT_ASSERT(outs.find("0xERR") != std::string::npos);
224     CPPUNIT_ASSERT(outs.find("You have been warned!") != std::string::npos);
225     CPPUNIT_ASSERT(outs.find("Told you so!") != std::string::npos);
226     class fooC {
227     public:
228         std::string getFoo () const { return std::string("I'm not empty!"); };
229         std::string getBar () const { return std::string(); };
230         std::vector&lt;int&gt; getSorted () const { return std::vector&lt;int&gt;({1, 2, 3}); };
231         std::vector&lt;int&gt; getUnsorted () const { return std::vector&lt;int&gt;({3, 1, 2}); };
232     };
233     std::vector&lt;std::string&gt; vect = {"foo", "bar"};
234     std::vector&lt;std::string&gt; vect2;
235     fooC foobar;
236     valid::Result myResult = validator({
237         could(vect, &amp;std::vector&lt;std::string&gt;::empty, isFalse(), {
238             must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(2), "notSmaller(2)") }),
239         must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(2), "notSmaller(2)"),
240         must(vect2, &amp;std::vector&lt;std::string&gt;::size, isSmaller(2), "isSmaller(2)"),
241         should(vect, &amp;std::vector&lt;std::string&gt;::size, notGreater(2), "notGreater(2)"),
242         should(vect, &amp;std::vector&lt;std::string&gt;::size, isGreater(0), "isGreater(0)"),
243         must(vect, &amp;std::vector&lt;std::string&gt;::size, notEqual&lt;size_t&gt;(0), "notEqual&lt;size_t&gt;(0)"),
244         should(vect, &amp;std::vector&lt;std::string&gt;::size, isEqual&lt;size_t&gt;(2), "isEqual&lt;size_t&gt;(2)"),
245         must(vect2, &amp;std::vector&lt;std::string&gt;::size, isFalse(), "isFalse()"),
246         must(foobar, &amp;fooC::getFoo, notEmpty(), "notEmpty()"),
247         should(foobar, &amp;fooC::getBar, isEmpty(), "isEmpty()"),
248         should(foobar, &amp;fooC::getSorted, isSorted(), "isSorted()")
249     });
250     CPPUNIT_ASSERT_EQUAL(true, myResult.ok());
251     CPPUNIT_ASSERT_EQUAL(false, myResult.hasWarnings());
252     CPPUNIT_ASSERT_EQUAL(false, myResult.hasErrors());
253     myResult = validator({
254         could(vect, &amp;std::vector&lt;std::string&gt;::empty, isFalse(), {
255             must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(3), "notSmaller(3)") }),
256         must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(3), "notSmaller(3)"),
257         must(vect2, &amp;std::vector&lt;std::string&gt;::size, isSmaller(0), "isSmaller(0)"),
258         should(vect, &amp;std::vector&lt;std::string&gt;::size, notGreater(1), "notGreater(1)"),
259         should(vect, &amp;std::vector&lt;std::string&gt;::size, isGreater(2), "isGreater(2)"),
260         must(vect, &amp;std::vector&lt;std::string&gt;::size, notEqual&lt;size_t&gt;(2), "notEqual&lt;size_t&gt;(2)"),
261         should(vect, &amp;std::vector&lt;std::string&gt;::size, isEqual&lt;size_t&gt;(0), "isEqual&lt;size_t&gt;(0)"),
262         must(vect2, &amp;std::vector&lt;std::string&gt;::size, notFalse(), "notFalse()"),
263         must(foobar, &amp;fooC::getFoo, isEmpty(), "notEmpty()"),
264         should(foobar, &amp;fooC::getBar, notEmpty(), "isEmpty()"),
265         should(foobar, &amp;fooC::getUnsorted, isSorted(), "isSorted()")
266     });
267     CPPUNIT_ASSERT(myResult.getWarnings().size() == 5);
268     CPPUNIT_ASSERT(myResult.getErrors().size() == 6);
269     setValid();
270     myResult = validator({
271         could(mtag, &amp;nix::MultiTag::positions, dimEquals(2), {
272             must(mtag, &amp;nix::MultiTag::extents, dimEquals(2), "dimEquals(2)") }),
273         must(  mtag,   &amp;nix::MultiTag::extents, dimEquals(2), "dimEquals(2)"),
274         should(array1, &amp;nix::DataArray::dimensions, dimLabelsMatchData(array1), "dimLabelsMatchData(array)"),
275         must(  array2, &amp;nix::DataArray::dimensions, dimTicksMatchData(array2),  "dimTicksMatchData(array)"),
276         must(  array5, &amp;nix::DataArray::dimensions, dimDataFrameTicksMatchData(array5), "dimDataFrameTicksMatchData(array)"),
277         should(dim_range1, &amp;nix::RangeDimension::unit, isAtomicUnit(), "isAtomicUnit(); (dim_range1)"),
278         should(tag,       &amp;nix::Tag::units,     isAtomicUnit(), "isAtomicUnit(); (tag)"),
279         must(units_tmp, &amp;tag_tmp::unit,  isCompoundUnit(), "isCompoundUnit(); (units_tmp.unit)"),
280         must(units_tmp, &amp;tag_tmp::units, isCompoundUnit(), "isCompoundUnit(); (units_tmp.units)"),
281         must(units_tmp, &amp;tag_tmp::unito, isCompoundUnit(), "isCompoundUnit(); (units_tmp.unito)"),
282         should(units_tmp, &amp;tag_tmp::unit,  isValidUnit(), "isValidUnit(); (units_tmp.unit)"),
283         must(  units_tmp, &amp;tag_tmp::units, isValidUnit(), "isValidUnit(); (units_tmp.units)"),
284         should(units_tmp, &amp;tag_tmp::unito, isValidUnit(), "isValidUnit(); (units_tmp.unito)"),
285         must(tag, &amp;nix::Tag::references, tagUnitsMatchRefsUnits(atomic_units), "tagUnitsMatchRefsUnits(atomic_units); (tag)")
286     });
287     CPPUNIT_ASSERT_EQUAL(false, myResult.hasWarnings());
288     CPPUNIT_ASSERT_EQUAL(false, myResult.hasErrors());
289     myResult = file.validate();
290     CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getWarnings().size());
291     CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getErrors().size());
292     setInvalid();
293     myResult = validator({
294         could(mtag, &amp;nix::MultiTag::positions, dimEquals(2), {
295             must(mtag, &amp;nix::MultiTag::extents, dimEquals(42), "dimEquals(42)") }),//
296         must(  mtag,   &amp;nix::MultiTag::extents, dimEquals(42), "dimEquals(42)"),//
297         should(array1, &amp;nix::DataArray::dimensions, dimLabelsMatchData(array1), "dimLabelsMatchData(array)"),
298         must(array5, &amp;nix::DataArray::dimensions, dimDataFrameTicksMatchData(array5), "dimDataFrameTicksMatchData(array"),
299         must(units_tmp, &amp;tag_tmp::unit,  isAtomicUnit(), "isAtomicUnit(); (units_tmp.unit)"),
300         must(units_tmp, &amp;tag_tmp::units, isAtomicUnit(), "isAtomicUnit(); (units_tmp.units)"),
301         must(units_tmp, &amp;tag_tmp::unit,  isCompoundUnit(), "isCompoundUnit(); (units_tmp.unit)"),
302         must(units_tmp, &amp;tag_tmp::units, isCompoundUnit(), "isCompoundUnit(); (units_tmp.units)"),
303         must(units_tmp, &amp;tag_tmp::unito, isCompoundUnit(), "isCompoundUnit(); (units_tmp.unito)"),
304         should(units_tmp, &amp;tag_tmp::unit,  isValidUnit(), "isValidUnit(); (units_tmp.unit)"),
305         must(  units_tmp, &amp;tag_tmp::units, isValidUnit(), "isValidUnit(); (units_tmp.units)"),
306         should(units_tmp, &amp;tag_tmp::unito, isValidUnit(), "isValidUnit(); (units_tmp.unito)"),
307         must(tag, &amp;nix::Tag::references, tagUnitsMatchRefsUnits(invalid_units), "tagUnitsMatchRefsUnits(atomic_units); (tag)")
308     });
309     CPPUNIT_ASSERT(myResult.getWarnings().size() == 3);
310     CPPUNIT_ASSERT(myResult.getErrors().size() == 10);
311     myResult = file.validate();
312     CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getWarnings().size());
313     CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(6), myResult.getErrors().size());
314     setValid();
315 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestSection.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;ctime&gt;
2 #include &lt;iostream&gt;
3 #include &lt;sstream&gt;
4 #include &lt;iterator&gt;
5 #include &lt;stdexcept&gt;
6 #include &lt;nix/util/util.hpp&gt;
7 #include &lt;nix/valid/validate.hpp&gt;
8 #include "BaseTestSection.hpp"
9 #include &lt;cppunit/extensions/HelperMacros.h&gt;
10 #include &lt;cppunit/CompilerOutputter.h&gt;
11 #include &lt;cppunit/TestResult.h&gt;
12 #include &lt;cppunit/TestResultCollector.h&gt;
13 #include &lt;cppunit/TestRunner.h&gt;
14 #include &lt;cppunit/BriefTestProgressListener.h&gt;
15 using namespace nix;
16 using namespace valid;
17 void BaseTestSection::testValidate() {
18     valid::Result result = validate(section);
19     CPPUNIT_ASSERT(result.getErrors().size() == 0);
20     CPPUNIT_ASSERT(result.getWarnings().size() == 0);
21 }
22 void BaseTestSection::testId() {
23     CPPUNIT_ASSERT(section.id().size() == 36);
24 }
25 void BaseTestSection::testName() {
26     CPPUNIT_ASSERT(section.name() == "section");
27 }
28 void BaseTestSection::testType() {
29     CPPUNIT_ASSERT(section.type() == "metadata");
30     std::string typ = util::createId();
31     section.type(typ);
32     CPPUNIT_ASSERT(section.type() == typ);
33 }
34 void BaseTestSection::testDefinition() {
35     std::string def = util::createId();
36     section.definition(def);
37     CPPUNIT_ASSERT(*section.definition() == def);
38     section.definition(nix::none);
39     CPPUNIT_ASSERT(section.definition() == nix::none);
40 }
41 void BaseTestSection::testParent() {
42     CPPUNIT_ASSERT(section.parent() == nix::none);
43     Section child = section.createSection("child", "section");
44     CPPUNIT_ASSERT(child.parent() != nix::none);
45     CPPUNIT_ASSERT(child.parent().id() == section.id());
46     CPPUNIT_ASSERT(child.parent().parent() == nix::none);
47 }
48 void BaseTestSection::testRepository() {
49     CPPUNIT_ASSERT(!section.repository());
50     std::string rep = "http://foo.bar/" + util::createId();
51     section.repository(rep);
52     CPPUNIT_ASSERT(section.repository() == rep);
53     section.repository(boost::none);
54     CPPUNIT_ASSERT(!section.repository());
55     CPPUNIT_ASSERT_THROW(section.repository(""), EmptyString);
56 }
57 void BaseTestSection::testLink() {
58     CPPUNIT_ASSERT(!section.link());
59     section.link(section_other);
60     CPPUNIT_ASSERT(section.link());
61     CPPUNIT_ASSERT(section.link().id() == section_other.id());
62     section.link(none);
63     CPPUNIT_ASSERT(!section.link());
64     section.link(section_other);
65     CPPUNIT_ASSERT(section.link());
66     Section null;
67     section.link(null);
68     CPPUNIT_ASSERT(!section.link());
69     CPPUNIT_ASSERT_THROW(section.link(""), EmptyString);
70     CPPUNIT_ASSERT_THROW(section.link("invalid id"), std::runtime_error);
71     section.link(section.id());
72     CPPUNIT_ASSERT(section.link().id() == section.id());
73     section.link(section_other.id());
74     CPPUNIT_ASSERT(section.link().id() == section_other.id());
75     section.link(section);
76     Section l1n1 = section.createSection("l1n1", "typ1");
77     Section l2n1 = l1n1.createSection("l2n1", "t1");
78     Section l2n2 = l1n1.createSection("l2n2", "t2");
79     Section l3n1 = l2n1.createSection("l3n1", "t3");
80     Section l3n2 = l2n2.createSection("l3n2", "t3");
81     Section l3n3 = l2n2.createSection("l3n3", "t4");
82     Section l4n1 = l3n2.createSection("l4n1", "typ2");
83     Section l4n2 = l3n3.createSection("l4n2", "typ2");
84     Section l5n1 = l4n1.createSection("l5n1", "typ2");
85     l2n1.link(l2n2.id());
86     l3n1.link(l5n1.id());
87     l3n2.link(l3n3.id());
88     l4n1.link(l4n2.id());
89     section_other.link(l3n3.id());
90     l1n1.deleteSection(l2n2.id());
91     CPPUNIT_ASSERT(section.findSections().size() == 3);
92     CPPUNIT_ASSERT(!l2n1.link());
93     CPPUNIT_ASSERT(!l3n1.link());
94     CPPUNIT_ASSERT(!l3n2.link());
95     CPPUNIT_ASSERT(!l4n1.link());
96     CPPUNIT_ASSERT(!section_other.link());
97     CPPUNIT_ASSERT(!l1n1.hasSection(l2n2));
98     section_other.link(l2n1.id());
99     file.deleteSection(section.id());
100     CPPUNIT_ASSERT(section_other.findSections().size() == 0);
101     CPPUNIT_ASSERT(!section_other.link());
102     section = file.createSection("section", "metadata");
103 }
104 void BaseTestSection::testSectionAccess() {
105     std::vector&lt;std::string&gt; names = { "section_a", "section_b", "section_c", "section_d", "section_e" };
106     Section null;
107     CPPUNIT_ASSERT(section.sectionCount() == 0);
108     CPPUNIT_ASSERT(section.sections().size() == 0);
109     CPPUNIT_ASSERT(section.getSection("invalid_id") == false);
110     CPPUNIT_ASSERT_EQUAL(false, section.hasSection("invalid_id"));
111     std::vector&lt;std::string&gt; ids;
112     for (auto name : names) {
113         Section child_section = section.createSection(name, "metadata");
114         CPPUNIT_ASSERT(child_section.name() == name);
115         CPPUNIT_ASSERT_EQUAL(true, section.hasSection(name));
116         ids.push_back(child_section.id());
117     }
118     CPPUNIT_ASSERT(section.sectionCount() == names.size());
119     CPPUNIT_ASSERT(section.sections().size() == names.size());
120     CPPUNIT_ASSERT_THROW(section.createSection(names[0], "metadata"),
121                          DuplicateName);
122     CPPUNIT_ASSERT_THROW(section.getSection(section.sectionCount()), OutOfBounds);
123     CPPUNIT_ASSERT_THROW(section.createSection("", "some type"), EmptyString);
124     CPPUNIT_ASSERT(!section.hasSection(null));
125     for (auto id : ids) {
126         Section child_section = section.getSection(id);
127         CPPUNIT_ASSERT(section.hasSection(id));
128         CPPUNIT_ASSERT(section.hasSection(child_section));
129         CPPUNIT_ASSERT_EQUAL(id, child_section.id());
130         section.deleteSection(id);
131     }
132     Section s2 = section.createSection("a name", "a type");
133     CPPUNIT_ASSERT(!section.deleteSection(null));
134     CPPUNIT_ASSERT(section.deleteSection(s2));
135     CPPUNIT_ASSERT(section.sectionCount() == 0);
136     CPPUNIT_ASSERT(section.sections().size() == 0);
137     CPPUNIT_ASSERT(section.getSection("invalid_id") == false);
138     Section s = section.createSection("Test", "test");
139     CPPUNIT_ASSERT(section.deleteSection(s));
140     CPPUNIT_ASSERT(!section.deleteSection(s));
141 }
142 void BaseTestSection::testFindSection() {
143     Section l1n1 = section.createSection("l1n1", "typ1");
144     Section l1n2 = section.createSection("l1n2", "typ2");
145     Section l1n3 = section.createSection("l1n3", "typ3");
146     Section l2n1 = l1n1.createSection("l2n1", "typ1");
147     Section l2n2 = l1n1.createSection("l2n2", "typ2");
148     Section l2n3 = l1n1.createSection("l2n3", "typ2");
149     Section l2n4 = l1n3.createSection("l2n4", "typ2");
150     Section l2n5 = l1n3.createSection("l2n5", "typ2");
151     Section l2n6 = l1n3.createSection("l2n6", "typ3");
152     Section l3n1 = l2n1.createSection("l3n1", "typ1");
153     Section l3n2 = l2n3.createSection("l3n2", "typ2");
154     Section l3n3 = l2n3.createSection("l3n3", "typ2");
155     Section l3n4 = l2n5.createSection("l3n4", "typ2");
156     CPPUNIT_ASSERT(section.findSections().size() == 13);
157     CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 2).size() == 9);
158     CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 1).size() == 3);
159     CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 0).size() == 0);
160     CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 0).size() == 0);
161     CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 1).size() == 2);
162     CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 2).size() == 5);
163     CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 3).size() == 11);
164     CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 4).size() == 15);
165     CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 5).size() == 15);
166     auto filter_typ1 = util::TypeFilter&lt;Section&gt;("typ1");
167     auto filter_typ2 = util::TypeFilter&lt;Section&gt;("typ2");
168     CPPUNIT_ASSERT(section.findSections(filter_typ1).size() == 3);
169     CPPUNIT_ASSERT(section.findSections(filter_typ2).size() == 8);
170 }
171 bool findSectionsInVector(const std::vector&lt;Section&gt; &amp;results, const std::vector&lt;std::string&gt; &amp;names) {
172    bool found = true;
173    for (const auto &amp;name : names) {
174        found = found &amp;&amp; (std::find_if(results.begin(), results.end(),
175                                       [name] (const Section &amp;s) {
176                                               return s.name() == name; }) != results.end());
177    }
178    return found;
179 }
180 void BaseTestSection::testFindRelated() {
181     Section l1n1 = section.createSection("L1N1", "t1");
182     Section l2n1 = l1n1.createSection("L2N1", "t2");
183     Section l2n2 = l1n1.createSection("L2N2", "t3");
184     Section l2n3 = l1n1.createSection("L2N3", "t2");
185     Section l2n4 = l1n1.createSection("L2N4", "t3");
186     Section l3n1 = l2n1.createSection("L3N1", "t4");
187     Section l3n2 = l2n2.createSection("L3N2", "t1");
188     Section l3n3 = l2n4.createSection("L3N3", "t4");
189     Section l3n4 = l2n4.createSection("L3N4", "t1");
190     Section l4n1 = l3n1.createSection("L4N1", "t5");
191     Section l4n2 = l3n3.createSection("L4N2", "t5");
192     Section l4n3 = l3n4.createSection("L4N3", "t3");
193     Section l5n1 = l4n2.createSection("L5N1", "t4");
194     std::vector&lt;Section&gt; results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
195     CPPUNIT_ASSERT(results.size() == 2);
196     CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N2", "L3N4"}));
197     results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
198     CPPUNIT_ASSERT(results.size() == 2);
199     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1", "L2N3"}));
200     results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
201     CPPUNIT_ASSERT(results.size() == 2);
202     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N2", "L2N4"}));
203     results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
204     CPPUNIT_ASSERT(results.size() == 2);
205     CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N1", "L3N3"}));
206     results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
207     CPPUNIT_ASSERT(results.size() == 2);
208     CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N1", "L4N2"}));
209     results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
210     CPPUNIT_ASSERT(results.size() == 1);
211     CPPUNIT_ASSERT(findSectionsInVector(results, {"L1N1"}));
212     results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
213     CPPUNIT_ASSERT(results.size() == 1);
214     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N3"}));
215     results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
216     CPPUNIT_ASSERT(results.size() == 2);
217     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N2", "L2N4"}));
218     results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
219     CPPUNIT_ASSERT(results.size() == 1);
220     CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N1"}));
221     results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
222     CPPUNIT_ASSERT(results.size() == 1);
223     CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N1"}));
224     results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
225     CPPUNIT_ASSERT(results.size() == 1);
226     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N4"}));
227     results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
228     CPPUNIT_ASSERT(results.size() == 2);
229     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1", "L2N3"}));
230     results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
231     CPPUNIT_ASSERT(results.size() == 0);
232     results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
233     CPPUNIT_ASSERT(results.size() == 0);
234     results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
235     CPPUNIT_ASSERT(results.size() == 1);
236     CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N4"}));
237     results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
238     CPPUNIT_ASSERT(results.size() == 2);
239     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1", "L2N3"}));
240     results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
241     CPPUNIT_ASSERT(results.size() == 1);
242     CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N3"}));
243     results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
244     CPPUNIT_ASSERT(results.size() == 1);
245     CPPUNIT_ASSERT(findSectionsInVector(results, {"L3N3"}));
246     results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
247     CPPUNIT_ASSERT(results.size() == 1);
248     CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N2"}));
249     results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
250     CPPUNIT_ASSERT(results.size() == 1);
251     CPPUNIT_ASSERT(findSectionsInVector(results, {"L1N1"}));
252     results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
253     CPPUNIT_ASSERT(results.size() == 1);
254     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1"}));
255     results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t3"));
256     CPPUNIT_ASSERT(results.size() == 2);
257     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N2", "L2N4"}));
258     results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t4"));
259     CPPUNIT_ASSERT(results.size() == 0);
260     results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t5"));
261     CPPUNIT_ASSERT(results.size() == 1);
262     CPPUNIT_ASSERT(findSectionsInVector(results, {"L4N1"}));
263     results = l4n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t1"));
264     CPPUNIT_ASSERT(results.size() == 1);
265     CPPUNIT_ASSERT(findSectionsInVector(results, {"L1N1"}));
266     results = l4n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;("t2"));
267     CPPUNIT_ASSERT(results.size() == 1);
268     CPPUNIT_ASSERT(findSectionsInVector(results, {"L2N1"}));
269     section.deleteSection(l1n1);
270 }
271 void BaseTestSection::testPropertyAccess() {
272     std::vector&lt;std::string&gt; names = { "property_a", "property_b", "property_c", "property_d", "property_e" };
273     CPPUNIT_ASSERT(section.propertyCount() == 0);
274     CPPUNIT_ASSERT(section.properties().size() == 0);
275     CPPUNIT_ASSERT(section.getProperty("invalid_id") == false);
276     CPPUNIT_ASSERT_EQUAL(false, section.hasProperty("invalid_id"));
277     Property p = section.createProperty("empty_prop", DataType::Double);
278     CPPUNIT_ASSERT(section.propertyCount() == 1);
279     CPPUNIT_ASSERT(section.hasProperty(p));
280     CPPUNIT_ASSERT(section.hasProperty("empty_prop"));
281     Property prop = section.getProperty("empty_prop");
282     CPPUNIT_ASSERT(prop.dataType() == nix::DataType::Double);
283     section.deleteProperty(p.id());
284     CPPUNIT_ASSERT(section.propertyCount() == 0);
285     CPPUNIT_ASSERT(!section.hasProperty(p));
286     CPPUNIT_ASSERT(!section.deleteProperty(p));
287     Variant dummy(10);
288     prop = section.createProperty("single value", dummy);
289     CPPUNIT_ASSERT(section.hasProperty("single value"));
290     CPPUNIT_ASSERT(section.propertyCount() == 1);
291     section.deleteProperty(prop);
292     CPPUNIT_ASSERT(section.propertyCount() == 0);
293     std::vector&lt;std::string&gt; ids;
294     for (auto name : names) {
295         prop = section.createProperty(name, dummy);
296         CPPUNIT_ASSERT(prop.name() == name);
297         CPPUNIT_ASSERT(section.hasProperty(name));
298         Property prop_copy = section.getProperty(name);
299         CPPUNIT_ASSERT(prop_copy.id() == prop.id());
300         ids.push_back(prop.id());
301     }
302     CPPUNIT_ASSERT_THROW(section.createProperty(names[0], dummy),
303                          DuplicateName);
304     CPPUNIT_ASSERT(section.propertyCount() == names.size());
305     CPPUNIT_ASSERT(section.properties().size() == names.size());
306     section_other.createProperty("some_prop", dummy);
307     section_other.link(section);
308     CPPUNIT_ASSERT(section_other.propertyCount() == 1);
309     CPPUNIT_ASSERT(section_other.inheritedProperties().size() == names.size() + 1);
310     for (auto id : ids) {
311         Property prop = section.getProperty(id);
312         CPPUNIT_ASSERT(section.hasProperty(id));
313         CPPUNIT_ASSERT(prop.id() == id);
314         section.deleteProperty(id);
315     }
316     CPPUNIT_ASSERT(section.propertyCount() == 0);
317     CPPUNIT_ASSERT(section.properties().size() == 0);
318     CPPUNIT_ASSERT(section.getProperty("invalid_id") == false);
319 }
320 void BaseTestSection::testReferringData() {
321     nix::Section ref_sec = file.createSection("referrenced", "test");
322     nix::Block b, b2;
323     CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 0);
324     CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 0);
325     b = file.createBlock("test_block", "test");
326     b2 = file.createBlock("test_block2", "test");
327     CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 0);
328     CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 0);
329     for (int i = 0; i &lt; 10; i++) {
330         std::string name = "data_array_" + nix::util::numToStr(i);
331         nix::DataArray da = b.createDataArray(name, "analog signal", nix::DataType::Double, nix::NDSize({ 20, 20 }));
332         nix::DataArray da2 = b2.createDataArray(name, "analog signal", nix::DataType::Double, nix::NDSize({ 10, 10 }));
333         if (i % 2 == 0) {
334             da.metadata(ref_sec);
335         } else {
336             da2.metadata(ref_sec);
337         }
338     }
339     CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 5);
340     CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 5);
341     CPPUNIT_ASSERT(ref_sec.referringDataArrays().size() == 10);
342 }
343 void BaseTestSection::testReferringTags() {
344     nix::Section ref_sec = file.createSection("referrenced", "test");
345     nix::Block b, b2;
346     CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 0);
347     CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 0);
348     b = file.createBlock("test_block", "test");
349     b2 = file.createBlock("test_block2", "test");
350     CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 0);
351     CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 0);
352     for (int i = 0; i &lt; 10; i++) {
353         std::string name = "tag_" + nix::util::numToStr(i);
354         nix::Tag t = b.createTag(name, "some tag", {1.});
355         nix::Tag t2 = b2.createTag(name, "some tag", {1.});
356         if (i % 2 == 0) {
357             t.metadata(ref_sec);
358         } else {
359             t2.metadata(ref_sec);
360         }
361     }
362     CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 5);
363     CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 5);
364     CPPUNIT_ASSERT(ref_sec.referringTags().size() == 10);
365 }
366 void BaseTestSection::testReferringMultiTags() {
367     nix::Section ref_sec = file.createSection("referrenced", "test");
368     nix::Block b, b2;
369     CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 0);
370 <a name="0"></a>    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 0);
371     b = file.createBlock("test_block", "test");
372 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    b2 = file.createBlock("test_block2", "test");
373     CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 0);
374     CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 0);
375     DataArray positions = b.createDataArray("positions", "positions", nix::DataType::Double, nix::NDSize({ 20, 1 }));
376     DataArray positions2 = b2.createDataArray("positions", "positions", nix::DataType::Double, nix::NDSize({ 20, 1 }));</b></font>
377     for (int i = 0; i &lt; 10; i++) {
378         std::string name = "tag_" + nix::util::numToStr(i);
379         nix::MultiTag t = b.createMultiTag(name, "some tag", positions);
380         nix::MultiTag t2 = b2.createMultiTag(name, "some tag", positions2);
381         if (i % 2 == 0) {
382             t.metadata(ref_sec);
383         } else {
384             t2.metadata(ref_sec);
385         }
386     }
387     CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 5);
388     CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 5);
389     CPPUNIT_ASSERT(ref_sec.referringMultiTags().size() == 10);
390 }
391 void BaseTestSection::testReferringSources() {
392     nix::Section ref_sec = file.createSection("referrenced", "test");
393     nix::Block b, b2;
394     CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 0);
395     CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 0);
396     b = file.createBlock("test_block", "test");
397     b2 = file.createBlock("test_block2", "test");
398     CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 0);
399     CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 0);
400     for (int i = 0; i &lt; 10; i++) {
401         std::string name = "src_" + nix::util::numToStr(i);
402         nix::Source s = b.createSource(name, "some src");
403         nix::Source s2 = b2.createSource(name, "some src");
404         nix::Source s3 = s2.createSource(name + "_child", "child_source");
405         if (i % 2 == 0) {
406             s.metadata(ref_sec);
407         } else {
408             s3.metadata(ref_sec);
409         }
410     }
411     CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 5);
412     CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 5);
413     CPPUNIT_ASSERT(ref_sec.referringSources().size() == 10);
414 }
415 void BaseTestSection::testReferringBlocks() {
416     nix::Section ref_sec = file.createSection("referrenced", "test");
417     for (int i = 0; i &lt; 10; i++) {
418         std::string name = "block_" + nix::util::numToStr(i);
419         nix::Block b = file.createBlock(name, "some blck");
420         nix::Block b2 = file.createBlock(name + "_scnd", "test");
421         if (i % 2 == 0) {
422             b.metadata(ref_sec);
423         }
424     }
425     CPPUNIT_ASSERT(ref_sec.referringBlocks().size() == 5);
426 }
427 void BaseTestSection::testOperators() {
428     CPPUNIT_ASSERT(section_null == false);
429     CPPUNIT_ASSERT(section_null == none);
430     CPPUNIT_ASSERT(section != false);
431     CPPUNIT_ASSERT(section != none);
432     CPPUNIT_ASSERT(section == section);
433     CPPUNIT_ASSERT(section != section_other);
434     section_other = section;
435     CPPUNIT_ASSERT(section == section_other);
436     section_other = none;
437     CPPUNIT_ASSERT(section_other == false);
438     CPPUNIT_ASSERT(section_other == none);
439     std::stringstream str1, str2;
440     str1 &lt;&lt;  "Section: {name = " &lt;&lt; section.name();
441     str1 &lt;&lt; ", type = " &lt;&lt; section.type();
442     str1 &lt;&lt; ", id = " &lt;&lt; section.id() &lt;&lt; "}";
443     str2 &lt;&lt; section;
444     CPPUNIT_ASSERT(str1.str() == str2.str());
445 }
446 void BaseTestSection::testCreatedAt() {
447     CPPUNIT_ASSERT(section.createdAt() &gt;= startup_time);
448     time_t past_time = time(NULL) - 10000000;
449     section.forceCreatedAt(past_time);
450     CPPUNIT_ASSERT(section.createdAt() == past_time);
451 }
452 void BaseTestSection::testUpdatedAt() {
453     CPPUNIT_ASSERT(section.updatedAt() &gt;= startup_time);
454 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
