<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TestValidate.cpp & BaseTestSection.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TestValidate.cpp & BaseTestSection.cpp
      </h3>
      <h1 align="center">
        2.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TestValidate.cpp (2.9411764%)<TH>BaseTestSection.cpp (2.8463%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1741-0.html#0',2,'match1741-1.html#0',3)" NAME="0">(33-36)<TD><A HREF="javascript:ZweiFrames('match1741-0.html#0',2,'match1741-1.html#0',3)" NAME="0">(565-569)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestValidate.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &quot;TestValidate.hpp&quot;

#include &lt;nix/valid/validator.hpp&gt;
#include &lt;nix/valid/checks.hpp&gt;
#include &lt;nix/valid/conditions.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;
#include &lt;nix.hpp&gt;

#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;math.h&gt;

#include &lt;boost/math/constants/constants.hpp&gt;


using namespace nix;
using namespace valid;
using namespace std;

void TestValidate::setUp() {
<A NAME="0"></A>    startup_time = time(NULL);
    // create file &amp; block
    file = nix::File::open(&quot;test_validate.h5&quot;, nix::FileMode::Overwrite);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1741-1.html#0',3,'match1741-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    block = file.createBlock(&quot;block_one&quot;, &quot;dataset&quot;);
    // create data array
    array1 = block.createDataArray(&quot;array_one&quot;, &quot;testdata&quot;, nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));
    array2 = block.createDataArray(&quot;array_two&quot;, &quot;testdata&quot;, nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));</B></FONT>
    array3 = block.createDataArray(&quot;array_three&quot;, &quot;testdata&quot;, nix::DataType::Double, nix::NDSize({ 0, 0, 0 }));
    array4 = block.createDataArray(&quot;array_four&quot;, &quot;sindata&quot;, nix::DataType::Double, nix::NDSize({ 0, 0}));
    array5 = block.createDataArray(&quot;array_five&quot;, &quot;dftest&quot;, nix::DataType::Double, nix::NDSize{ 0 });
    // create data frame
    std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double}};
    frame1 = block.createDataFrame(&quot;frame_one&quot;, &quot;conditions&quot;, cols);
    // set references vector
    refs = {array2, array3};
    // create positions &amp; extents arrays
    positions = block.createDataArray(&quot;positions_DataArray&quot;, &quot;dataArray&quot;, DataType::Double, nix::NDSize({ 0, 0 }));
    extents = block.createDataArray(&quot;extents_DataArray&quot;, &quot;dataArray&quot;, DataType::Double, nix::NDSize({ 0, 0 }));
    // create units
    atomic_units = {&quot;m&quot;, &quot;cm&quot;, &quot;mm&quot;};
    compound_units = {&quot;mV*cm&quot;, &quot;m*s&quot;, &quot;s/cm&quot;};
    invalid_units = {&quot;foo&quot;};
    // create multi tag &amp; tag
    mtag = block.createMultiTag(&quot;tag_one&quot;, &quot;test_tag&quot;, positions);
    mtag.extents(extents);
    mtag.references(refs);
    tag = block.createTag(&quot;tag_one&quot;, &quot;test_tag&quot;, {0.0, 2.0, 3.4});
    tag.references(refs);
    units_tmp = tag_tmp(compound_units);
    // create dimensions
    dim_set1 = array1.appendSetDimension();
    dim_set2 = array1.appendSetDimension();
    dim_set3 = array1.appendSetDimension();
    dim_range1 = array2.appendRangeDimension({1, 2, 3});
    dim_range2 = array2.appendRangeDimension({1, 2, 3, 4});
    dim_range3 = array2.appendRangeDimension({1, 2});
    dim_sample1 = array3.appendSampledDimension(42);
    dim_sample2 = array3.appendSampledDimension(42);
    dim_sample3 = array3.appendSampledDimension(42);
    dim_frame1 = array5.appendDataFrameDimension(frame1);
}

void TestValidate::tearDown() {
    return;
}

void TestValidate::setValid() {
    // fill sinus data &amp; leave it in file for plot testing
    typedef boost::multi_array&lt;double, 2&gt; array2D_type;
    typedef array2D_type::index index;
    array2D_type sin_array(boost::extents[1000][1000]);
    const double PI = boost::math::constants::pi&lt;double&gt;();
    for (index i = 0; i &lt; 1000; ++i) {
        for (index j = 0; j &lt; 1000; ++j) {
            sin_array[i][j] = std::sin(PI * j / std::sqrt((i&gt;0)?i:1));
        }
    }
    array4.setData(sin_array);
    array4.deleteDimensions();
    array4.appendSampledDimension(1.);
    array4.appendSetDimension();
    // fill array1 &amp; array2
    typedef boost::multi_array&lt;double, 3&gt; array_type;
    typedef array_type::index index;
    array_type A(boost::extents[3][4][2]);
    int values = 0;
    for (index i = 0; i != 3; ++i)
        for (index j = 0; j != 4; ++j)
            for (index k = 0; k != 2; ++k)
                A[i][j][k] = values++;
    array1.setData(A);
    array2.setData(A);
    array2.deleteDimensions();
    dim_range1 = array2.appendRangeDimension({1, 2, 3});
    dim_range2 = array2.appendRangeDimension({1, 2, 3, 4});
    dim_range3 = array2.appendRangeDimension({1, 2});

    array3.setData(A);

    // fill extent &amp; position
    extent.resize(3);
    position.resize(3);
    std::iota(std::begin(extent), std::end(extent), 0);
    std::iota(std::begin(position), std::end(position), 0);

    // fill extents &amp; positions
    array2D_type B(boost::extents[5][3]);
    for (index i = 0; i &lt; 5; ++i) {
        for (index j = 0; j &lt; 3; ++j) {
            B[i][j] = 100.0*i;
        }
    }
    positions.setData(B);

    array2D_type C(boost::extents[5][3]);
    for (index i = 0; i &lt; 5; ++i) {
        for (index j = 0; j &lt; 3; ++j) {
            C[i][j] = 100.0*i;
        }
    }
    extents.setData(C);

    // ensure correct dimension descriptors for positions
    positions.deleteDimensions();
    positions.appendSetDimension();
    positions.appendSetDimension();
    extents.deleteDimensions();
    extents.appendSetDimension();
    extents.appendSetDimension();

    // fill MultiTag
    refs = {array2, array3};
    mtag.units(atomic_units);
    // fill Tag
    tag.extent(extent);
    tag.position(position);
    tag.units(atomic_units);
    // fill dimensions
    dim_set1.labels({&quot;label_a&quot;, &quot;label_b&quot;, &quot;label_c&quot;});
    dim_set2.labels({&quot;label_a&quot;, &quot;label_b&quot;, &quot;label_c&quot;, &quot;label_d&quot;});
    dim_set3.labels({&quot;label_a&quot;, &quot;label_b&quot;});
    dim_range1.unit(atomic_units[0]);
    dim_range2.unit(atomic_units[1]);
    dim_range3.unit(atomic_units[2]);
    dim_sample1.unit(atomic_units[0]);
    dim_sample2.unit(atomic_units[1]);
    dim_sample3.unit(atomic_units[2]);
    // fill tag_tmp
    units_tmp = tag_tmp(compound_units);

    // fill array5
    size_t count = 10;
    std::vector&lt;double&gt; array5_data(count);
    for (size_t i = 0; i &lt; count; ++i)
        array5_data[i] = i * 3.14;
    array5.setData(array5_data);
    // fill data frame
    frame1.rows(count);
    std::vector&lt;nix::Variant&gt; vals(1);
    for (size_t i = 0; i &lt; count; ++i) {
        vals[0].set(i * 2.5);
        frame1.writeRow(i, vals);
    }

    return;
}

void TestValidate::setInvalid() {
    // fill array1 &amp; array2
    typedef boost::multi_array&lt;double, 3&gt; array_type;
    typedef array_type::index index;
    array_type A(boost::extents[3][4][2]);
    int values = 0;
    for (index i = 0; i != 3; ++i)
        for (index j = 0; j != 4; ++j)
            for (index k = 0; k != 2; ++k)
                A[i][j][k] = values++;
    array1.setData(A);
    array2.setData(A);
    array3.setData(A);

    // fill extent &amp; position
    extent.resize(6);
    position.resize(9);
    std::iota(std::begin(extent), std::end(extent), 0);
    std::iota(std::begin(position), std::end(position), 0);

    // fill extents &amp; positions
    typedef boost::multi_array&lt;double, 2&gt; array2D_type;
    typedef array2D_type::index index;
    array2D_type B(boost::extents[4][2]);
    for (index i = 0; i &lt; 4; ++i) {
        for (index j = 0; j &lt; 2; ++j) {
            B[i][j] = 100.0*i;
        }
    }
    extents.setData(B);
    array2D_type C(boost::extents[5][2]);
    for (index i = 0; i &lt; 5; ++i) {
        for (index j = 0; j &lt; 2; ++j) {
            C[i][j] = 100.0*i;
        }
    }
    positions.setData(C);
    // fill MultiTag
    refs = {array1, array2};
    mtag.units(atomic_units);
    // fill Tag
    tag.extent(extent);
    tag.position(position);
    tag.units(atomic_units);
    // fill dimensions
    dim_set3.labels({&quot;label_a&quot;, &quot;label_b&quot;, &quot;label_c&quot;});
    dim_set1.labels({&quot;label_a&quot;, &quot;label_b&quot;, &quot;label_c&quot;, &quot;label_d&quot;});
    dim_set2.labels({&quot;label_a&quot;, &quot;label_b&quot;});
    dim_range3.ticks({1, 2, 3});
    dim_range1.ticks({1, 2, 3, 4});
    dim_range2.ticks({1, 2});
    dim_sample3.unit(atomic_units[0]);
    dim_sample1.unit(atomic_units[1]);
    dim_sample2.unit(atomic_units[2]);
    // fill tag_tmp
    units_tmp = tag_tmp(invalid_units);
    // remove dimension descriptors from array4, position and extents
    array4.deleteDimensions();
    positions.deleteDimensions();
    extents.deleteDimensions();

    // fill array5
    size_t count = 10;
    std::vector&lt;double&gt; array5_data(count);
    for (size_t i = 0; i &lt; count; ++i)
        array5_data[i] = i * 3.14;
    array5.setData(array5_data);
    // fill data frame
    frame1.rows(count - 5);
    std::vector&lt;nix::Variant&gt; vals(1);
    for (size_t i = 0; i &lt; count - 5; ++i) {
        vals[0].set(i * 2.5);
        frame1.writeRow(i, vals);
    }

    return;
}

void TestValidate::test() {

    // check if nix::getEntityName works correctly
    // this is here because there is currently no better place
    // and we only use that function in the validation code
    boost::optional&lt;std::string&gt; name = nix::getEntityName(block);
    CPPUNIT_ASSERT(!!name);
    CPPUNIT_ASSERT_EQUAL(*name, block.name());

    name = nix::getEntityName(file);
    CPPUNIT_ASSERT(!name);

    valid::Message m1(&quot;w1&quot;, &quot;meh&quot;, std::string(&quot;michi&quot;));
    CPPUNIT_ASSERT_EQUAL(m1.id, std::string(&quot;w1&quot;));
    CPPUNIT_ASSERT_EQUAL(m1.msg, std::string(&quot;meh&quot;));
    CPPUNIT_ASSERT(!!m1.name);
    CPPUNIT_ASSERT_EQUAL(std::string(&quot;michi&quot;), *m1.name);

    // test result class
    valid::Result res;
    CPPUNIT_ASSERT_EQUAL(false, res.hasWarnings());
    CPPUNIT_ASSERT_EQUAL(false, res.hasErrors());
    CPPUNIT_ASSERT_EQUAL(true, res.ok());

    valid::Message w1(&quot;0xWARN&quot;, &quot;You have been warned!&quot;);
    valid::Message e1(&quot;0xERR&quot;, &quot;Told you so!&quot;);

    res.addWarning(w1);
    CPPUNIT_ASSERT_EQUAL(false, res.hasErrors());
    CPPUNIT_ASSERT_EQUAL(true, res.hasWarnings());

    res.addError(e1);
    CPPUNIT_ASSERT_EQUAL(true, res.hasErrors());
    CPPUNIT_ASSERT_EQUAL(true, res.hasWarnings());

    std::stringstream out;
    out &lt;&lt; res;
    std::string outs = out.str();

    CPPUNIT_ASSERT(outs.find(&quot;0xWARN&quot;) != std::string::npos);
    CPPUNIT_ASSERT(outs.find(&quot;0xERR&quot;) != std::string::npos);
    CPPUNIT_ASSERT(outs.find(&quot;You have been warned!&quot;) != std::string::npos);
    CPPUNIT_ASSERT(outs.find(&quot;Told you so!&quot;) != std::string::npos);

    // dummy class to test empty checks
    class fooC {
    public:
        std::string getFoo () const { return std::string(&quot;I'm not empty!&quot;); };
        std::string getBar () const { return std::string(); };
        std::vector&lt;int&gt; getSorted () const { return std::vector&lt;int&gt;({1, 2, 3}); };
        std::vector&lt;int&gt; getUnsorted () const { return std::vector&lt;int&gt;({3, 1, 2}); };
    };

    std::vector&lt;std::string&gt; vect = {&quot;foo&quot;, &quot;bar&quot;};
    std::vector&lt;std::string&gt; vect2;
    fooC foobar;

    // success cases----------------------------------------------------
    // -----------------------------------------------------------------
    valid::Result myResult = validator({
        could(vect, &amp;std::vector&lt;std::string&gt;::empty, isFalse(), {
            must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(2), &quot;notSmaller(2)&quot;) }),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(2), &quot;notSmaller(2)&quot;),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, isSmaller(2), &quot;isSmaller(2)&quot;),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, notGreater(2), &quot;notGreater(2)&quot;),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isGreater(0), &quot;isGreater(0)&quot;),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notEqual&lt;size_t&gt;(0), &quot;notEqual&lt;size_t&gt;(0)&quot;),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isEqual&lt;size_t&gt;(2), &quot;isEqual&lt;size_t&gt;(2)&quot;),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, isFalse(), &quot;isFalse()&quot;),
        must(foobar, &amp;fooC::getFoo, notEmpty(), &quot;notEmpty()&quot;),
        should(foobar, &amp;fooC::getBar, isEmpty(), &quot;isEmpty()&quot;),
        should(foobar, &amp;fooC::getSorted, isSorted(), &quot;isSorted()&quot;)
    });
    // have debug info
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT_EQUAL(true, myResult.ok());
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasWarnings());
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasErrors());

    // failure cases----------------------------------------------------
    // -----------------------------------------------------------------
    myResult = validator({
        could(vect, &amp;std::vector&lt;std::string&gt;::empty, isFalse(), {
            must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(3), &quot;notSmaller(3)&quot;) }),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notSmaller(3), &quot;notSmaller(3)&quot;),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, isSmaller(0), &quot;isSmaller(0)&quot;),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, notGreater(1), &quot;notGreater(1)&quot;),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isGreater(2), &quot;isGreater(2)&quot;),
        must(vect, &amp;std::vector&lt;std::string&gt;::size, notEqual&lt;size_t&gt;(2), &quot;notEqual&lt;size_t&gt;(2)&quot;),
        should(vect, &amp;std::vector&lt;std::string&gt;::size, isEqual&lt;size_t&gt;(0), &quot;isEqual&lt;size_t&gt;(0)&quot;),
        must(vect2, &amp;std::vector&lt;std::string&gt;::size, notFalse(), &quot;notFalse()&quot;),
        must(foobar, &amp;fooC::getFoo, isEmpty(), &quot;notEmpty()&quot;),
        should(foobar, &amp;fooC::getBar, notEmpty(), &quot;isEmpty()&quot;),
        should(foobar, &amp;fooC::getUnsorted, isSorted(), &quot;isSorted()&quot;)
    });
    // uncomment this to have debug info
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT(myResult.getWarnings().size() == 5);
    CPPUNIT_ASSERT(myResult.getErrors().size() == 6);

    // entity success cases---------------------------------------------
    // -----------------------------------------------------------------
    setValid();
    myResult = validator({
        could(mtag, &amp;nix::MultiTag::positions, dimEquals(2), {
            must(mtag, &amp;nix::MultiTag::extents, dimEquals(2), &quot;dimEquals(2)&quot;) }),
        must(  mtag,   &amp;nix::MultiTag::extents, dimEquals(2), &quot;dimEquals(2)&quot;),
        should(array1, &amp;nix::DataArray::dimensions, dimLabelsMatchData(array1), &quot;dimLabelsMatchData(array)&quot;),
        must(  array2, &amp;nix::DataArray::dimensions, dimTicksMatchData(array2),  &quot;dimTicksMatchData(array)&quot;),
        must(  array5, &amp;nix::DataArray::dimensions, dimDataFrameTicksMatchData(array5), &quot;dimDataFrameTicksMatchData(array)&quot;),

        should(dim_range1, &amp;nix::RangeDimension::unit, isAtomicUnit(), &quot;isAtomicUnit(); (dim_range1)&quot;),
        should(tag,       &amp;nix::Tag::units,     isAtomicUnit(), &quot;isAtomicUnit(); (tag)&quot;),
        must(units_tmp, &amp;tag_tmp::unit,  isCompoundUnit(), &quot;isCompoundUnit(); (units_tmp.unit)&quot;),
        must(units_tmp, &amp;tag_tmp::units, isCompoundUnit(), &quot;isCompoundUnit(); (units_tmp.units)&quot;),
        must(units_tmp, &amp;tag_tmp::unito, isCompoundUnit(), &quot;isCompoundUnit(); (units_tmp.unito)&quot;),
        should(units_tmp, &amp;tag_tmp::unit,  isValidUnit(), &quot;isValidUnit(); (units_tmp.unit)&quot;),
        must(  units_tmp, &amp;tag_tmp::units, isValidUnit(), &quot;isValidUnit(); (units_tmp.units)&quot;),
        should(units_tmp, &amp;tag_tmp::unito, isValidUnit(), &quot;isValidUnit(); (units_tmp.unito)&quot;),
        must(tag, &amp;nix::Tag::references, tagUnitsMatchRefsUnits(atomic_units), &quot;tagUnitsMatchRefsUnits(atomic_units); (tag)&quot;)
    });
    // have debug info
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasWarnings());
    CPPUNIT_ASSERT_EQUAL(false, myResult.hasErrors());

    myResult = file.validate();
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getWarnings().size());
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getErrors().size());
    // entity failure cases---------------------------------------------
    // -----------------------------------------------------------------

    setInvalid();
    myResult = validator({
        could(mtag, &amp;nix::MultiTag::positions, dimEquals(2), {
            must(mtag, &amp;nix::MultiTag::extents, dimEquals(42), &quot;dimEquals(42)&quot;) }),//
        must(  mtag,   &amp;nix::MultiTag::extents, dimEquals(42), &quot;dimEquals(42)&quot;),//
        should(array1, &amp;nix::DataArray::dimensions, dimLabelsMatchData(array1), &quot;dimLabelsMatchData(array)&quot;),
        must(array5, &amp;nix::DataArray::dimensions, dimDataFrameTicksMatchData(array5), &quot;dimDataFrameTicksMatchData(array&quot;),
        must(units_tmp, &amp;tag_tmp::unit,  isAtomicUnit(), &quot;isAtomicUnit(); (units_tmp.unit)&quot;),
        must(units_tmp, &amp;tag_tmp::units, isAtomicUnit(), &quot;isAtomicUnit(); (units_tmp.units)&quot;),
        must(units_tmp, &amp;tag_tmp::unit,  isCompoundUnit(), &quot;isCompoundUnit(); (units_tmp.unit)&quot;),
        must(units_tmp, &amp;tag_tmp::units, isCompoundUnit(), &quot;isCompoundUnit(); (units_tmp.units)&quot;),
        must(units_tmp, &amp;tag_tmp::unito, isCompoundUnit(), &quot;isCompoundUnit(); (units_tmp.unito)&quot;),
        should(units_tmp, &amp;tag_tmp::unit,  isValidUnit(), &quot;isValidUnit(); (units_tmp.unit)&quot;),
        must(  units_tmp, &amp;tag_tmp::units, isValidUnit(), &quot;isValidUnit(); (units_tmp.units)&quot;),
        should(units_tmp, &amp;tag_tmp::unito, isValidUnit(), &quot;isValidUnit(); (units_tmp.unito)&quot;),
        must(tag, &amp;nix::Tag::references, tagUnitsMatchRefsUnits(invalid_units), &quot;tagUnitsMatchRefsUnits(atomic_units); (tag)&quot;)
    });
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT(myResult.getWarnings().size() == 3);
    CPPUNIT_ASSERT(myResult.getErrors().size() == 10);

    myResult = file.validate();
    // std::cout &lt;&lt; myResult;
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), myResult.getWarnings().size());
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(6), myResult.getErrors().size());

    // lets leave the file clean &amp; valid
    setValid();

}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestSection.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013 - 2015, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in Section and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/util/util.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;

#include &quot;BaseTestSection.hpp&quot;

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;

using namespace nix;
using namespace valid;


void BaseTestSection::testValidate() {
    valid::Result result = validate(section);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestSection::testId() {
    CPPUNIT_ASSERT(section.id().size() == 36);
}


void BaseTestSection::testName() {
    CPPUNIT_ASSERT(section.name() == &quot;section&quot;);
}


void BaseTestSection::testType() {
    CPPUNIT_ASSERT(section.type() == &quot;metadata&quot;);
    std::string typ = util::createId();
    section.type(typ);
    CPPUNIT_ASSERT(section.type() == typ);
}


void BaseTestSection::testDefinition() {
    std::string def = util::createId();
    section.definition(def);
    CPPUNIT_ASSERT(*section.definition() == def);
    section.definition(nix::none);
    CPPUNIT_ASSERT(section.definition() == nix::none);
}


void BaseTestSection::testParent() {
    CPPUNIT_ASSERT(section.parent() == nix::none);

    Section child = section.createSection(&quot;child&quot;, &quot;section&quot;);
    CPPUNIT_ASSERT(child.parent() != nix::none);
    CPPUNIT_ASSERT(child.parent().id() == section.id());

    CPPUNIT_ASSERT(child.parent().parent() == nix::none);
}


void BaseTestSection::testRepository() {
    CPPUNIT_ASSERT(!section.repository());
    std::string rep = &quot;http://foo.bar/&quot; + util::createId();
    section.repository(rep);
    CPPUNIT_ASSERT(section.repository() == rep);
    section.repository(boost::none);
    CPPUNIT_ASSERT(!section.repository());
    CPPUNIT_ASSERT_THROW(section.repository(&quot;&quot;), EmptyString);
}


void BaseTestSection::testLink() {
    CPPUNIT_ASSERT(!section.link());

    section.link(section_other);
    CPPUNIT_ASSERT(section.link());
    CPPUNIT_ASSERT(section.link().id() == section_other.id());

    // test none-unsetter
    section.link(none);
    CPPUNIT_ASSERT(!section.link());
    section.link(section_other);
    CPPUNIT_ASSERT(section.link());
    Section null;
    section.link(null);
    CPPUNIT_ASSERT(!section.link());

    // test id setter and resetter
    CPPUNIT_ASSERT_THROW(section.link(&quot;&quot;), EmptyString);
    CPPUNIT_ASSERT_THROW(section.link(&quot;invalid id&quot;), std::runtime_error);

    section.link(section.id());
    CPPUNIT_ASSERT(section.link().id() == section.id());
    section.link(section_other.id());
    CPPUNIT_ASSERT(section.link().id() == section_other.id());
    // test deleter removing link too
    section.link(section);
     /* We create the following tree:
     *
     * section---l1n1---l2n1---l3n1------------
     *            |      |                    |
     *            ------l2n2---l3n2---l4n1---l5n1
     *                   |      |      |
     *                   ------l3n3---l4n2
     * section_other------------|
     */
    Section l1n1 = section.createSection(&quot;l1n1&quot;, &quot;typ1&quot;);

    Section l2n1 = l1n1.createSection(&quot;l2n1&quot;, &quot;t1&quot;);
    Section l2n2 = l1n1.createSection(&quot;l2n2&quot;, &quot;t2&quot;);
    Section l3n1 = l2n1.createSection(&quot;l3n1&quot;, &quot;t3&quot;);
    Section l3n2 = l2n2.createSection(&quot;l3n2&quot;, &quot;t3&quot;);
    Section l3n3 = l2n2.createSection(&quot;l3n3&quot;, &quot;t4&quot;);
    Section l4n1 = l3n2.createSection(&quot;l4n1&quot;, &quot;typ2&quot;);
    Section l4n2 = l3n3.createSection(&quot;l4n2&quot;, &quot;typ2&quot;);
    Section l5n1 = l4n1.createSection(&quot;l5n1&quot;, &quot;typ2&quot;);

    l2n1.link(l2n2.id());
    l3n1.link(l5n1.id());
    l3n2.link(l3n3.id());
    l4n1.link(l4n2.id());
    section_other.link(l3n3.id());
    /* Chop the tree to:
     *
     * section---l1n1---l2n1---l3n1
     * section_other
     *
     */
    l1n1.deleteSection(l2n2.id());
    CPPUNIT_ASSERT(section.findSections().size() == 3);

    // test that all (horizontal) links are gone too:
    CPPUNIT_ASSERT(!l2n1.link());
    CPPUNIT_ASSERT(!l3n1.link());
    CPPUNIT_ASSERT(!l3n2.link());
    CPPUNIT_ASSERT(!l4n1.link());

    CPPUNIT_ASSERT(!section_other.link());
    CPPUNIT_ASSERT(!l1n1.hasSection(l2n2));

    /* Extend the tree to:
     *
     * section---l1n1---l2n1---l3n1
     * section_other-----|
     *
     * and then chop it down to:
     *
     * section_other
     *
     */
    section_other.link(l2n1.id());
    file.deleteSection(section.id());
    CPPUNIT_ASSERT(section_other.findSections().size() == 0);
    CPPUNIT_ASSERT(!section_other.link());
    // re-create section
    section = file.createSection(&quot;section&quot;, &quot;metadata&quot;);
}


void BaseTestSection::testSectionAccess() {
    std::vector&lt;std::string&gt; names = { &quot;section_a&quot;, &quot;section_b&quot;, &quot;section_c&quot;, &quot;section_d&quot;, &quot;section_e&quot; };
    Section null;

    CPPUNIT_ASSERT(section.sectionCount() == 0);
    CPPUNIT_ASSERT(section.sections().size() == 0);
    CPPUNIT_ASSERT(section.getSection(&quot;invalid_id&quot;) == false);
    CPPUNIT_ASSERT_EQUAL(false, section.hasSection(&quot;invalid_id&quot;));

    std::vector&lt;std::string&gt; ids;
    for (auto name : names) {
        Section child_section = section.createSection(name, &quot;metadata&quot;);
        CPPUNIT_ASSERT(child_section.name() == name);
        CPPUNIT_ASSERT_EQUAL(true, section.hasSection(name));

        ids.push_back(child_section.id());
    }
    CPPUNIT_ASSERT(section.sectionCount() == names.size());
    CPPUNIT_ASSERT(section.sections().size() == names.size());

    CPPUNIT_ASSERT_THROW(section.createSection(names[0], &quot;metadata&quot;),
                         DuplicateName);
    CPPUNIT_ASSERT_THROW(section.getSection(section.sectionCount()), OutOfBounds);
    CPPUNIT_ASSERT_THROW(section.createSection(&quot;&quot;, &quot;some type&quot;), EmptyString);
    CPPUNIT_ASSERT(!section.hasSection(null));

    for (auto id : ids) {
        Section child_section = section.getSection(id);
        CPPUNIT_ASSERT(section.hasSection(id));
        CPPUNIT_ASSERT(section.hasSection(child_section));
        CPPUNIT_ASSERT_EQUAL(id, child_section.id());
        section.deleteSection(id);
    }
    Section s2 = section.createSection(&quot;a name&quot;, &quot;a type&quot;);
    CPPUNIT_ASSERT(!section.deleteSection(null));
    CPPUNIT_ASSERT(section.deleteSection(s2));

    CPPUNIT_ASSERT(section.sectionCount() == 0);
    CPPUNIT_ASSERT(section.sections().size() == 0);
    CPPUNIT_ASSERT(section.getSection(&quot;invalid_id&quot;) == false);

    Section s = section.createSection(&quot;Test&quot;, &quot;test&quot;);
    CPPUNIT_ASSERT(section.deleteSection(s));
    CPPUNIT_ASSERT(!section.deleteSection(s));
}


void BaseTestSection::testFindSection() {
    /* prepare
   |--- section_other [metadata]
   |
   |--- section [metadata]
         |--- l1n1 [t1]
         |     |--- l2n1 [t1]
         |     |     |--- l3n1 [t1]
         |     |--- l2n2 [t2]
         |     |--- l2n3 [t2]
         |           |--- l3n2 [t2]
         |           |--- l3n3 [t2]
         |
         |--- l1n2 [t2]
         |
         |--- l1n3 [t3]
               |--- l2n4 [t2]
               |--- l2n5 [t2]
               |--- l2n6 [t3]
                     |-- l3n4 [t2]
    */
    Section l1n1 = section.createSection(&quot;l1n1&quot;, &quot;typ1&quot;);
    Section l1n2 = section.createSection(&quot;l1n2&quot;, &quot;typ2&quot;);
    Section l1n3 = section.createSection(&quot;l1n3&quot;, &quot;typ3&quot;);

    Section l2n1 = l1n1.createSection(&quot;l2n1&quot;, &quot;typ1&quot;);
    Section l2n2 = l1n1.createSection(&quot;l2n2&quot;, &quot;typ2&quot;);
    Section l2n3 = l1n1.createSection(&quot;l2n3&quot;, &quot;typ2&quot;);
    Section l2n4 = l1n3.createSection(&quot;l2n4&quot;, &quot;typ2&quot;);
    Section l2n5 = l1n3.createSection(&quot;l2n5&quot;, &quot;typ2&quot;);
    Section l2n6 = l1n3.createSection(&quot;l2n6&quot;, &quot;typ3&quot;);

    Section l3n1 = l2n1.createSection(&quot;l3n1&quot;, &quot;typ1&quot;);
    Section l3n2 = l2n3.createSection(&quot;l3n2&quot;, &quot;typ2&quot;);
    Section l3n3 = l2n3.createSection(&quot;l3n3&quot;, &quot;typ2&quot;);
    Section l3n4 = l2n5.createSection(&quot;l3n4&quot;, &quot;typ2&quot;);

    // test depth limit
    CPPUNIT_ASSERT(section.findSections().size() == 13);
    CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 2).size() == 9);
    CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 1).size() == 3);
    CPPUNIT_ASSERT(section.findSections(util::AcceptAll&lt;Section&gt;(), 0).size() == 0);

    // test file::findSections with depth
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 0).size() == 0);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 1).size() == 2);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 2).size() == 5);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 3).size() == 11);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 4).size() == 15);
    CPPUNIT_ASSERT(file.findSections(util::AcceptAll&lt;Section&gt;(), 5).size() == 15);

    // test filter
    auto filter_typ1 = util::TypeFilter&lt;Section&gt;(&quot;typ1&quot;);
    auto filter_typ2 = util::TypeFilter&lt;Section&gt;(&quot;typ2&quot;);

    CPPUNIT_ASSERT(section.findSections(filter_typ1).size() == 3);
    CPPUNIT_ASSERT(section.findSections(filter_typ2).size() == 8);
}


bool findSectionsInVector(const std::vector&lt;Section&gt; &amp;results, const std::vector&lt;std::string&gt; &amp;names) {
   bool found = true;
   for (const auto &amp;name : names) {
       found = found &amp;&amp; (std::find_if(results.begin(), results.end(),
                                      [name] (const Section &amp;s) {
                                              return s.name() == name; }) != results.end());
   }
   return found;
}


void BaseTestSection::testFindRelated() {
    /* we create the following tree
    section --- l1n1 [t1]
                 |-- l2n1 [t2]
                 |    |-- l3n1 [t4]
                 |         |-- l4n1 [t5]
                 |
                 |-- l2n2 [t3]
                 |    |-- l3n2 [t1]
                 |
                 |-- l2n3 [t2]
                 |
                 |-- l2n4 [t3]
                      |-- l3n3 [t4]
                      |    |-- l4n2 [t5]
                      |         |-- l5n1 [t4]
                      |
                      |-- l3n4 [t1]
                           |-- l4n3 [t3]
    */
    Section l1n1 = section.createSection(&quot;L1N1&quot;, &quot;t1&quot;);

    Section l2n1 = l1n1.createSection(&quot;L2N1&quot;, &quot;t2&quot;);
    Section l2n2 = l1n1.createSection(&quot;L2N2&quot;, &quot;t3&quot;);
    Section l2n3 = l1n1.createSection(&quot;L2N3&quot;, &quot;t2&quot;);
    Section l2n4 = l1n1.createSection(&quot;L2N4&quot;, &quot;t3&quot;);

    Section l3n1 = l2n1.createSection(&quot;L3N1&quot;, &quot;t4&quot;);
    Section l3n2 = l2n2.createSection(&quot;L3N2&quot;, &quot;t1&quot;);
    Section l3n3 = l2n4.createSection(&quot;L3N3&quot;, &quot;t4&quot;);
    Section l3n4 = l2n4.createSection(&quot;L3N4&quot;, &quot;t1&quot;);

    Section l4n1 = l3n1.createSection(&quot;L4N1&quot;, &quot;t5&quot;);
    Section l4n2 = l3n3.createSection(&quot;L4N2&quot;, &quot;t5&quot;);
    Section l4n3 = l3n4.createSection(&quot;L4N3&quot;, &quot;t3&quot;);

    Section l5n1 = l4n2.createSection(&quot;L5N1&quot;, &quot;t4&quot;);

    std::vector&lt;Section&gt; results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t1&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L3N2&quot;, &quot;L3N4&quot;}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t2&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N1&quot;, &quot;L2N3&quot;}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t3&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N2&quot;, &quot;L2N4&quot;}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t4&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L3N1&quot;, &quot;L3N3&quot;}));

    results = l1n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t5&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L4N1&quot;, &quot;L4N2&quot;}));
    // ----------- l2n1 -------------
    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t1&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L1N1&quot;}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t2&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N3&quot;}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t3&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N2&quot;, &quot;L2N4&quot;}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t4&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L3N1&quot;}));

    results = l2n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t5&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L4N1&quot;}));

    // ----------- l2n2 -------------
    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t3&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N4&quot;}));

    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t2&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N1&quot;, &quot;L2N3&quot;}));

    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t4&quot;));
    CPPUNIT_ASSERT(results.size() == 0);

    results = l2n2.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t5&quot;));
    CPPUNIT_ASSERT(results.size() == 0);

    // ----------- l2n4 -------------
    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t1&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L3N4&quot;}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t2&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N1&quot;, &quot;L2N3&quot;}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t3&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L4N3&quot;}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t4&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L3N3&quot;}));

    results = l2n4.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t5&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L4N2&quot;}));

    // ----------- l3n1 -------------
    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t1&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L1N1&quot;}));

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t2&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N1&quot;}));

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t3&quot;));
    CPPUNIT_ASSERT(results.size() == 2);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N2&quot;, &quot;L2N4&quot;}));

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t4&quot;));
    CPPUNIT_ASSERT(results.size() == 0);

    results = l3n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t5&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L4N1&quot;}));

    // ----------- l4n1 --------------
    results = l4n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t1&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L1N1&quot;}));

    results = l4n1.findRelated(nix::util::TypeFilter&lt;nix::Section&gt;(&quot;t2&quot;));
    CPPUNIT_ASSERT(results.size() == 1);
    CPPUNIT_ASSERT(findSectionsInVector(results, {&quot;L2N1&quot;}));
    section.deleteSection(l1n1);
}


void BaseTestSection::testPropertyAccess() {
    std::vector&lt;std::string&gt; names = { &quot;property_a&quot;, &quot;property_b&quot;, &quot;property_c&quot;, &quot;property_d&quot;, &quot;property_e&quot; };

    CPPUNIT_ASSERT(section.propertyCount() == 0);
    CPPUNIT_ASSERT(section.properties().size() == 0);
    CPPUNIT_ASSERT(section.getProperty(&quot;invalid_id&quot;) == false);
    CPPUNIT_ASSERT_EQUAL(false, section.hasProperty(&quot;invalid_id&quot;));

    Property p = section.createProperty(&quot;empty_prop&quot;, DataType::Double);
    CPPUNIT_ASSERT(section.propertyCount() == 1);
    CPPUNIT_ASSERT(section.hasProperty(p));
    CPPUNIT_ASSERT(section.hasProperty(&quot;empty_prop&quot;));
    Property prop = section.getProperty(&quot;empty_prop&quot;);
    CPPUNIT_ASSERT(prop.dataType() == nix::DataType::Double);
    section.deleteProperty(p.id());
    CPPUNIT_ASSERT(section.propertyCount() == 0);
    CPPUNIT_ASSERT(!section.hasProperty(p));
    CPPUNIT_ASSERT(!section.deleteProperty(p));

    Variant dummy(10);
    prop = section.createProperty(&quot;single value&quot;, dummy);
    CPPUNIT_ASSERT(section.hasProperty(&quot;single value&quot;));
    CPPUNIT_ASSERT(section.propertyCount() == 1);
    section.deleteProperty(prop);
    CPPUNIT_ASSERT(section.propertyCount() == 0);

    std::vector&lt;std::string&gt; ids;
    for (auto name : names) {
        prop = section.createProperty(name, dummy);
        CPPUNIT_ASSERT(prop.name() == name);
        CPPUNIT_ASSERT(section.hasProperty(name));

        Property prop_copy = section.getProperty(name);

        CPPUNIT_ASSERT(prop_copy.id() == prop.id());

        ids.push_back(prop.id());
    }
    CPPUNIT_ASSERT_THROW(section.createProperty(names[0], dummy),
                         DuplicateName);

    CPPUNIT_ASSERT(section.propertyCount() == names.size());
    CPPUNIT_ASSERT(section.properties().size() == names.size());
    section_other.createProperty(&quot;some_prop&quot;, dummy);
    section_other.link(section);
    CPPUNIT_ASSERT(section_other.propertyCount() == 1);
    CPPUNIT_ASSERT(section_other.inheritedProperties().size() == names.size() + 1);

    for (auto id : ids) {
        Property prop = section.getProperty(id);
        CPPUNIT_ASSERT(section.hasProperty(id));
        CPPUNIT_ASSERT(prop.id() == id);

        section.deleteProperty(id);
    }

    CPPUNIT_ASSERT(section.propertyCount() == 0);
    CPPUNIT_ASSERT(section.properties().size() == 0);
    CPPUNIT_ASSERT(section.getProperty(&quot;invalid_id&quot;) == false);
}


void BaseTestSection::testReferringData() {
    nix::Section ref_sec = file.createSection(&quot;referrenced&quot;, &quot;test&quot;);

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 0);

    b = file.createBlock(&quot;test_block&quot;, &quot;test&quot;);
    b2 = file.createBlock(&quot;test_block2&quot;, &quot;test&quot;);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 0);

    for (int i = 0; i &lt; 10; i++) {
        std::string name = &quot;data_array_&quot; + nix::util::numToStr(i);
        nix::DataArray da = b.createDataArray(name, &quot;analog signal&quot;, nix::DataType::Double, nix::NDSize({ 20, 20 }));
        nix::DataArray da2 = b2.createDataArray(name, &quot;analog signal&quot;, nix::DataType::Double, nix::NDSize({ 10, 10 }));
        if (i % 2 == 0) {
            da.metadata(ref_sec);
        } else {
            da2.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringDataArrays().size() == 10);
}


void BaseTestSection::testReferringTags() {
    nix::Section ref_sec = file.createSection(&quot;referrenced&quot;, &quot;test&quot;);

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 0);

    b = file.createBlock(&quot;test_block&quot;, &quot;test&quot;);
    b2 = file.createBlock(&quot;test_block2&quot;, &quot;test&quot;);
    CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 0);

    for (int i = 0; i &lt; 10; i++) {
        std::string name = &quot;tag_&quot; + nix::util::numToStr(i);
        nix::Tag t = b.createTag(name, &quot;some tag&quot;, {1.});
        nix::Tag t2 = b2.createTag(name, &quot;some tag&quot;, {1.});
        if (i % 2 == 0) {
            t.metadata(ref_sec);
        } else {
            t2.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringTags(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringTags(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringTags().size() == 10);
}


void BaseTestSection::testReferringMultiTags() {
    nix::Section ref_sec = file.createSection(&quot;referrenced&quot;, &quot;test&quot;);

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 0);
<A NAME="0"></A>    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 0);

    b = file.createBlock(&quot;test_block&quot;, &quot;test&quot;);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1741-0.html#0',2,'match1741-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    b2 = file.createBlock(&quot;test_block2&quot;, &quot;test&quot;);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 0);
    DataArray positions = b.createDataArray(&quot;positions&quot;, &quot;positions&quot;, nix::DataType::Double, nix::NDSize({ 20, 1 }));
    DataArray positions2 = b2.createDataArray(&quot;positions&quot;, &quot;positions&quot;, nix::DataType::Double, nix::NDSize({ 20, 1 }));</B></FONT>

    for (int i = 0; i &lt; 10; i++) {
        std::string name = &quot;tag_&quot; + nix::util::numToStr(i);
        nix::MultiTag t = b.createMultiTag(name, &quot;some tag&quot;, positions);
        nix::MultiTag t2 = b2.createMultiTag(name, &quot;some tag&quot;, positions2);
        if (i % 2 == 0) {
            t.metadata(ref_sec);
        } else {
            t2.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringMultiTags().size() == 10);
}


void BaseTestSection::testReferringSources() {
    nix::Section ref_sec = file.createSection(&quot;referrenced&quot;, &quot;test&quot;);

    nix::Block b, b2;
    CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 0);

    b = file.createBlock(&quot;test_block&quot;, &quot;test&quot;);
    b2 = file.createBlock(&quot;test_block2&quot;, &quot;test&quot;);
    CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 0);
    CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 0);

    for (int i = 0; i &lt; 10; i++) {
        std::string name = &quot;src_&quot; + nix::util::numToStr(i);
        nix::Source s = b.createSource(name, &quot;some src&quot;);
        nix::Source s2 = b2.createSource(name, &quot;some src&quot;);
        nix::Source s3 = s2.createSource(name + &quot;_child&quot;, &quot;child_source&quot;);
        if (i % 2 == 0) {
            s.metadata(ref_sec);
        } else {
            s3.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringSources(b).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringSources(b2).size() == 5);
    CPPUNIT_ASSERT(ref_sec.referringSources().size() == 10);
}


void BaseTestSection::testReferringBlocks() {
    nix::Section ref_sec = file.createSection(&quot;referrenced&quot;, &quot;test&quot;);
    for (int i = 0; i &lt; 10; i++) {
        std::string name = &quot;block_&quot; + nix::util::numToStr(i);
        nix::Block b = file.createBlock(name, &quot;some blck&quot;);
        nix::Block b2 = file.createBlock(name + &quot;_scnd&quot;, &quot;test&quot;);
        if (i % 2 == 0) {
            b.metadata(ref_sec);
        }
    }
    CPPUNIT_ASSERT(ref_sec.referringBlocks().size() == 5);
}


void BaseTestSection::testOperators() {
    CPPUNIT_ASSERT(section_null == false);
    CPPUNIT_ASSERT(section_null == none);

    CPPUNIT_ASSERT(section != false);
    CPPUNIT_ASSERT(section != none);

    CPPUNIT_ASSERT(section == section);
    CPPUNIT_ASSERT(section != section_other);

    section_other = section;
    CPPUNIT_ASSERT(section == section_other);

    section_other = none;
    CPPUNIT_ASSERT(section_other == false);
    CPPUNIT_ASSERT(section_other == none);

    std::stringstream str1, str2;
    str1 &lt;&lt;  &quot;Section: {name = &quot; &lt;&lt; section.name();
    str1 &lt;&lt; &quot;, type = &quot; &lt;&lt; section.type();
    str1 &lt;&lt; &quot;, id = &quot; &lt;&lt; section.id() &lt;&lt; &quot;}&quot;;
    str2 &lt;&lt; section;
    CPPUNIT_ASSERT(str1.str() == str2.str());

}


void BaseTestSection::testCreatedAt() {
    CPPUNIT_ASSERT(section.createdAt() &gt;= startup_time);
    time_t past_time = time(NULL) - 10000000;
    section.forceCreatedAt(past_time);
    CPPUNIT_ASSERT(section.createdAt() == past_time);
}


void BaseTestSection::testUpdatedAt() {
    CPPUNIT_ASSERT(section.updatedAt() &gt;= startup_time);
}
</PRE>
</div>
  </div>
</body>
</html>
