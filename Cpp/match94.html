<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for auth.cpp &amp; main.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for auth.cpp &amp; main.cpp
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>auth.cpp (3.0456853%)<th>main.cpp (2.764977%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(349-359)<td><a href="#" name="0">(203-213)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>auth.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;string&gt;
2 #include &lt;utility&gt;
3 #include "auth.hpp"
4 #include "message.hpp"
5 #include "exception.hpp"
6 #include "socket_types.hpp"
7 #include "signal.hpp"
8 #include "z85.hpp"
9 #if (ZMQ_VERSION_MAJOR &gt; 3)
10 #if defined(ZMQPP_NO_CONSTEXPR)
11 	const char * const zmqpp::auth::zap_endpoint_ = "inproc://zeromq.zap.01";
12 #endif
13 namespace zmqpp
14 {
15 auth::auth(context&amp; ctx) :
16   curve_allow_any(false),
17   terminated(false),
18   verbose(false)
19   {
20     auto zap_auth_server = [this] (socket * pipe, context&amp; auth_ctx) -&gt; bool {
21         socket zap_handler(auth_ctx, socket_type::reply);
22         try {
23             zap_handler.bind(zap_endpoint_);
24             pipe-&gt;send(signal::ok);
25         }
26         catch (zmq_internal_exception const&amp;) {
27             return false;
28         }
29         auth_poller.add(*pipe);
30         auth_poller.add(zap_handler);
31         while (!terminated &amp;&amp; auth_poller.poll()) {
32             if (auth_poller.has_input(zap_handler)) {
33                 authenticate(zap_handler);
34             }
35             if (auth_poller.has_input(*pipe)) {
36                 handle_command(*pipe);
37             }
38         }
39         zap_handler.unbind(zap_endpoint_);
40         return true;        
41     };
42     std::cout &lt;&lt; "auth: Starting ZAP Authentication Server" &lt;&lt; std::endl; 
43     authenticator = std::make_shared&lt;actor&gt;(std::bind(zap_auth_server, std::placeholders::_1, std::ref(ctx)));
44 }
45 auth::~auth() {
46     message msg;
47 	msg &lt;&lt; "TERMINATE";
48 	authenticator-&gt;pipe()-&gt;send(msg);
49     authenticator-&gt;pipe()-&gt;wait();
50 }
51 void auth::allow(const std::string &amp;address) {
52 	message msg;
53 	msg &lt;&lt; "ALLOW" &lt;&lt; address;
54 	authenticator-&gt;pipe()-&gt;send(msg);
55 	authenticator-&gt;pipe()-&gt;wait();
56 }
57 void auth::deny(const std::string &amp;address) {
58 	message msg;
59 	msg &lt;&lt; "DENY" &lt;&lt; address;
60 	authenticator-&gt;pipe()-&gt;send(msg);
61 	authenticator-&gt;pipe()-&gt;wait();
62 }
63 void auth::configure_domain(const std::string &amp;domain) {
64 	message msg;
65 	assert(!domain.empty());
66 	msg &lt;&lt; "DOMAIN" &lt;&lt; domain;
67 	authenticator-&gt;pipe()-&gt;send(msg);
68 	authenticator-&gt;pipe()-&gt;wait();
69 }
70 void auth::configure_plain(const std::string &amp;username, const std::string &amp;password) {
71 	message msg;
72 	assert(!username.empty());
73 	assert(!password.empty());
74 	msg &lt;&lt; "PLAIN" &lt;&lt; username &lt;&lt; password;
75     if (verbose) {
76         std::cout &lt;&lt; "auth: configure PLAIN - username:" &lt;&lt; username &lt;&lt; " password:" &lt;&lt; password &lt;&lt; std::endl; 
77     }
78     authenticator-&gt;pipe()-&gt;send(msg);
79     authenticator-&gt;pipe()-&gt;wait();
80 }
81 void auth::configure_curve(const std::string &amp;client_public_key) {
82 	message msg;
83 	assert(!client_public_key.empty());
84 	msg &lt;&lt; "CURVE" &lt;&lt; client_public_key;
85     if (verbose) {
86         std::cout &lt;&lt; "auth: configure CURVE - client public key:" &lt;&lt; client_public_key &lt;&lt; std::endl; 
87     }
88     authenticator-&gt;pipe()-&gt;send(msg);
89 	authenticator-&gt;pipe()-&gt;wait();
90 }
91 void auth::configure_gssapi() {
92 	message msg;
93 	msg &lt;&lt; "GSSAPI";
94     if (verbose) {
95         std::cout &lt;&lt; "auth: configure GSSAPI - Not implemented yet!!!" &lt;&lt; std::endl; 
96     }
97     authenticator-&gt;pipe()-&gt;send(msg);
98 	authenticator-&gt;pipe()-&gt;wait();
99 }
100 void auth::set_verbose(bool verbose) {
101     std::string verbose_string = (true == verbose) ? "true" : "false"; 
102 	message msg;
103    	msg &lt;&lt; "VERBOSE" &lt;&lt; verbose_string;
104     if(verbose) {
105             std::cout &lt;&lt; "auth: verbose:" &lt;&lt; verbose_string &lt;&lt; std::endl;
106     }
107     authenticator-&gt;pipe()-&gt;send(msg);
108     authenticator-&gt;pipe()-&gt;wait();
109 }
110 void auth::handle_command(socket&amp; pipe) {
111 	message msg;
112 	pipe.receive(msg);
113     if(0 == msg.parts())
114         return;     
115 	std::string command = msg.get(0);
116 	if (verbose) {
117     	std::cout &lt;&lt;"auth: API command=" &lt;&lt; command &lt;&lt; std::endl;
118     }
119     if("ALLOW" == command) {
120     	std::string address = msg.get(1);
121     	if(verbose) {
122     		std::cout &lt;&lt; "auth: whitelisting ipaddress=" &lt;&lt; address &lt;&lt; std::endl;
123     	}
124     	whitelist.insert(address);
125     	pipe.send(signal::ok); 
126     } else if("DENY" == command) {
127     	std::string address = msg.get(1);
128     	if(verbose) {
129     		std::cout &lt;&lt; "auth: blacklisting ipaddress=" &lt;&lt; address &lt;&lt; std::endl;
130     	}
131     	blacklist.insert(address);
132     	pipe.send(signal::ok); 
133     } else if("DOMAIN" == command) {
134     	std::string domain = msg.get(1);
135     	if(verbose) {
136     		std::cout &lt;&lt; "auth: domain=" &lt;&lt; domain &lt;&lt; std::endl;
137     	}
138     	this-&gt;domain = domain;
139     	pipe.send(signal::ok); 
140     } else if("PLAIN" == command) {
141     	std::string user = msg.get(1);
142     	std::string pass = msg.get(2);
143         if (verbose) {
144             std::cout &lt;&lt; "auth: configured PLAIN - user:" &lt;&lt; user &lt;&lt; std::endl; 
145         }
146     	passwords.insert(std::make_pair(user, pass));
147     	pipe.send(signal::ok); 
148     } else if("CURVE" == command) {
149     	std::string client_public_key = msg.get(1);
150     	if("CURVE_ALLOW_ANY" == client_public_key) {
151     		curve_allow_any = true;
152             if(verbose) {
153     		  std::cout &lt;&lt; "auth: configured CURVE - allow ALL clients" &lt;&lt; std::endl;
154             }
155     	} else {
156     		curve_allow_any = false;
157     		client_keys.insert(client_public_key);
158             if(verbose) {
159     		  std::cout &lt;&lt; "auth: configured CURVE - allow client with public key:" &lt;&lt; client_public_key &lt;&lt; std::endl;
160             }
161     	}
162 		pipe.send(signal::ok); 
163     } else if("GSSAPI" == command) {
164         if(verbose) {
165     	   std::cout &lt;&lt; "auth: configure GSSAPI authentication is not yet implemented here" &lt;&lt; std::endl;
166         }
167     	pipe.send(signal::ok); 
168     } else if("VERBOSE" == command) {
169     	std::string verbose_string = msg.get(1);
170     	verbose = ("true" == verbose_string)? true : false;
171     	pipe.send(signal::ok); 
172     } else if("TERMINATE" == command) {
173     	std::cout &lt;&lt; "auth: Shutdown ZAP Authentication Server" &lt;&lt; std::endl;
174     	terminated = true;
175         pipe.send(signal::ok); 
176     } else {
177         if(verbose) {
178     	   std::cout &lt;&lt; "auth: Invalid command=" &lt;&lt; command &lt;&lt; std::endl;
179         }
180     	assert(false);
181     }
182 }
183 bool auth::authenticate_plain(zap_request&amp; request, std::string &amp;user_id)
184 {
185 	auto search = passwords.find(request.get_username());
186     if((search != passwords.end()) &amp;&amp; (search-&gt;second == request.get_password())) {
187         if (verbose) {
188             std::cout &lt;&lt; "auth: allowed (PLAIN) username=" &lt;&lt; request.get_username()
189         		&lt;&lt; " password=" &lt;&lt; request.get_password() &lt;&lt; std::endl;
190         }
191         user_id = request.get_username();
192         return true;
193     }
194     else {
195     	if (verbose) {
196             std::cout &lt;&lt; "auth: denied (PLAIN) username=" &lt;&lt; request.get_username()
197         		&lt;&lt; " password=" &lt;&lt; request.get_password() &lt;&lt; std::endl;
198         }
199         return false;
200     }
201 }
202 bool auth::authenticate_curve(zap_request&amp; request, std::string &amp;user_id)
203 {
204 	if (curve_allow_any) {
205     	if (verbose) {
206         	std::cout &lt;&lt; "auth: allowed (CURVE allow any client)" &lt;&lt; std::endl;
207         }
208         user_id = request.get_client_key();
209     	return true;
210 	} else {
211 		auto search = client_keys.find(request.get_client_key());
212     	if(search != client_keys.end()) {
213     		if (verbose) {
214         		std::cout &lt;&lt; "auth: allowed (CURVE) client_key=" &lt;&lt; request.get_client_key() &lt;&lt; std::endl;
215             }
216             user_id = request.get_client_key();
217     		return true;
218     	}
219     	else {
220     		if (verbose) {
221         		std::cout &lt;&lt; "auth: denied (CURVE) client_key=" &lt;&lt; request.get_client_key() &lt;&lt; std::endl;
222             }
223     		return false;
224     	}
225 	}    	
226 }
227 bool auth::authenticate_gssapi(zap_request&amp; request) {
228 	if (verbose) {
229     	std::cout &lt;&lt; "auth: allowed (GSSAPI) principal=" &lt;&lt; request.get_principal() 
230     		&lt;&lt; " identity=" &lt;&lt; request.get_identity() &lt;&lt; std::endl;
231     }
232 	return true;	
233 }
234 void auth::authenticate(socket&amp; sock) {
235 	zap_request request(sock, verbose);
236     std::string user_id;
237 	if(request.get_version().empty()) {        		request.reply("500", "Internal error", "");
238     	return;     
239 	}
240     bool allowed = false;
241     bool denied = false;
242     if(whitelist.size()) {
243     	auto search = whitelist.find(request.get_address());
244     	if (search != whitelist.end()) {
245             allowed = true;
246             if (verbose) {
247                 std::cout &lt;&lt; "auth: passed (whitelist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
248             }
249         }
250         else {
251             denied = true;
252             if (verbose) {
253                 std::cout &lt;&lt; "auth: denied (not in whitelist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
254             }
255         }
256     } else if(blacklist.size()) {
257     	auto search = blacklist.find(request.get_address());
258     	if (search != blacklist.end()) {
259             denied = true;
260             if (verbose) {
261                 std::cout &lt;&lt; "auth: denied (blacklist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
262             }
263         }
264 <a name="0"></a>        else {
265             allowed = true;
266             if (verbose) {
267 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                std::cout &lt;&lt; "auth: passed (not in blacklist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
268             }
269         }
270     }
271     if(!denied) {
272     	if (("NULL" == request.get_mechanism()) &amp;&amp; !allowed) {
273             if (verbose) {
274                 std::cout &lt;&lt; "auth: allowed (NULL)" &lt;&lt; std::endl;</b></font>
275             }
276             allowed = true;
277         } else if ("PLAIN" == request.get_mechanism()) {
278             allowed = authenticate_plain(request, user_id);
279         } else if ("CURVE" == request.get_mechanism()) {
280             allowed = authenticate_curve(request, user_id);
281         } else if ("GSSAPI" == request.get_mechanism()) {
282             allowed = authenticate_gssapi(request);
283         }
284     }
285     if (allowed)
286     	request.reply("200", "OK", user_id);
287     else
288         request.reply("400", "No access", "");
289 }
290 }
291 #endif
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>main.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;cstdlib&gt;
2 #include &lt;array&gt;
3 #include &lt;iostream&gt;
4 #include &lt;tuple&gt;
5 #include &lt;zmqpp/zmqpp.hpp&gt;
6 #include "options.hpp"
7 #ifndef BUILD_CLIENT_NAME
8 #define BUILD_CLIENT_NAME "zmqpp"
9 #endif
10 int main(int argc, char const* argv[])
11 {
12 	client_options const options = process_command_line( argc, argv );
13 	if( options.show_version )
14 	{
15 		uint8_t major, minor, patch;
16 		zmqpp::zmq_version(major, minor, patch);
17 		std::cout &lt;&lt; BUILD_CLIENT_NAME &lt;&lt; " version " &lt;&lt; zmqpp::version() &lt;&lt; std::endl;
18 		std::cout &lt;&lt; "  built against 0mq version " &lt;&lt; static_cast&lt;int&gt;(major) &lt;&lt; "." &lt;&lt; static_cast&lt;int&gt;(minor) &lt;&lt; "." &lt;&lt; static_cast&lt;int&gt;(patch) &lt;&lt; std::endl;
19 		return EXIT_FAILURE;
20 	}
21 	if( options.show_usage || options.show_help )
22 	{
23 		show_usage( std::cout, BUILD_CLIENT_NAME );
24 		if( options.show_help )
25 		{
26 			std::cout &lt;&lt; std::endl;
27 			show_help( std::cout );
28 		}
29 		return EXIT_FAILURE;
30 	}
31 	bool can_send = false, can_recv = false, toggles = false;
32 	switch( options.type )
33 	{
34 	case zmqpp::socket_type::push:      can_send = true; break;
35 	case zmqpp::socket_type::pull:      can_recv = true; break;
36 	case zmqpp::socket_type::publish:   can_send = true; break;
37 	case zmqpp::socket_type::subscribe: can_recv = true; break;
38 	case zmqpp::socket_type::request:   can_send = true; toggles = true; break;
39 	case zmqpp::socket_type::reply:     can_recv = true; toggles = true; break;
40 	default:
41 		std::cerr &lt;&lt; "Unsupported socket type" &lt;&lt; std::endl;
42 		return EXIT_FAILURE;
43 	}
44 	int standardin = -1;
45 	if( can_send || toggles )
46 	{
47 		if( options.verbose ) { std::cerr &lt;&lt; "Connecting to stdin" &lt;&lt; std::endl; }
48 		standardin = fileno(stdin);
49 		if ( standardin &lt; 0 ) 		{
50 			std::cerr &lt;&lt; "Unable to get standard input, this might be an OS thing, sorry." &lt;&lt; std::endl;
51 			return EXIT_FAILURE;
52 		}
53 	}
54 	zmqpp::context context;
55 	zmqpp::socket socket( context, options.type );
56 	if( zmqpp::socket_type::subscribe == options.type ) { socket.subscribe( "" ); }
57 	if( !options.binds.empty() )
58 	{
59 		for(size_t i = 0; i &lt; options.binds.size(); ++i)
60 		{
61 			if( options.verbose ) { std::cerr &lt;&lt; "binding to " &lt;&lt; options.binds[i] &lt;&lt; std::endl; }
62 			try
63 			{
64 				socket.bind( options.binds[i] );
65 			}
66 			catch(zmqpp::zmq_internal_exception&amp; e)
67 			{
68 				std::cerr &lt;&lt; "failed to bind to endpoint " &lt;&lt; options.binds[i] &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;
69 				return EXIT_FAILURE;
70 			}
71 		}
72 	}
73 	if( !options.connects.empty() )
74 	{
75 		for(size_t i = 0; i &lt; options.connects.size(); ++i)
76 		{
77 			if( options.verbose ) { std::cerr &lt;&lt; "connecting to " &lt;&lt; options.connects[i] &lt;&lt; std::endl; }
78 			try
79 			{
80 				socket.connect( options.connects[i] );
81 			}
82 			catch(zmqpp::zmq_internal_exception&amp; e)
83 			{
84 				std::cerr &lt;&lt; "failed to bind to endpoint " &lt;&lt; options.connects[i] &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;
85 				return EXIT_FAILURE;
86 			}
87 		}
88 	}
89 	zmqpp::poller poller;
90 	poller.add(socket);
91 	if( standardin &gt;= 0 ) { poller.add( standardin ); }
92 	if( options.verbose &amp;&amp; ( can_send || toggles ) )
93 	{
94 		std::cerr &lt;&lt; "While sending packets is allowed data entered on standard in will be sent to the 0mq socket." &lt;&lt; std::endl;
95 		if( options.singlepart )
96 		{
97 			std::cerr &lt;&lt; "messages will be considered terminated by newline." &lt;&lt; std::endl;
98 		}
99 		else
100 		{
101 			std::cerr &lt;&lt; "Message parts will be considered terminated by newline." &lt;&lt; std::endl;
102 			std::cerr &lt;&lt; "Messages will be considered terminated by an empty part." &lt;&lt; std::endl;
103 			std::cerr &lt;&lt; "The empty part itself will not be included." &lt;&lt; std::endl;
104 		}
105 		std::cerr &lt;&lt; std::endl;
106 		if ( toggles &amp;&amp; !can_send )
107 		{
108 			std::cerr &lt;&lt; "Sending starts as disabled for this socket type." &lt;&lt; std::endl;
109 			std::cerr &lt;&lt; std::endl;
110 		}
111 	}
112 	if( options.detailed )
113 	{
114 		if( standardin &gt;= 0 ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "reading from stdin is enabled." &lt;&lt; std::endl; }
115 		if( can_send ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "sending via socket is enabled." &lt;&lt; std::endl; }
116 		if( can_recv ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "receiving via socket is enabled." &lt;&lt; std::endl; }
117 		if( toggles ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "socket will flip between send/recv." &lt;&lt; std::endl; }
118 		if( options.annotate ) { std::cerr &lt;&lt; "**: "; }	std::cerr &lt;&lt; "Warning - Detailed logging is enabled." &lt;&lt; std::endl;
119 	}
120 	zmqpp::message message;
121 	while(true)
122 	{
123 		poller.check_for(socket, (can_recv) ? zmqpp::poller::poll_in : zmqpp::poller::poll_none);
124 		if( standardin &gt;= 0 )
125 		{
126 			poller.check_for(standardin, (can_send) ? zmqpp::poller::poll_in : zmqpp::poller::poll_none);
127 		}
128 		if( options.detailed )
129 		{
130 			if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
131 			std::cerr &lt;&lt; "Polling for incomming message data." &lt;&lt; std::endl;
132 		}
133 		if( poller.poll() )
134 		{
135 			if (poller.has_input(socket))
136 			{
137 				assert(can_recv);
138 				if( options.detailed )
139 				{
140 					if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
141 					std::cerr &lt;&lt; "Message on socket." &lt;&lt; std::endl;
142 				}
143 				do
144 				{
145 					std::string message;
146 					socket.receive(message);
147 					if( options.annotate ) { std::cout &lt;&lt; "&lt;&lt;: "; }
148 					std::cout &lt;&lt; message &lt;&lt; std::endl;
149 				} while(socket.has_more_parts());
150 				if( options.annotate ) { std::cout &lt;&lt; " --- " &lt;&lt; std::endl; }
151 				else { std::cout &lt;&lt; std::endl; }
152 				if (toggles)
153 				{
154 					can_recv = false;
155 					can_send = true;
156 <a name="0"></a>					if( options.detailed )
157 					{
158 						if( options.annotate ) { std::cerr &lt;&lt; "**: " &lt;&lt; std::endl; }
159 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>						std::cerr &lt;&lt; "Toggling to sending enabled" &lt;&lt; std::endl;
160 					}
161 				}
162 			}
163 			if( (standardin &gt;= 0) &amp;&amp; poller.has_input( standardin ) )
164 			{
165 				assert(can_send);
166 				if( options.detailed )
167 				{
168 					if( options.annotate ) { std::cerr &lt;&lt; "**: "; }</b></font>
169 					std::cerr &lt;&lt; "Data on stdin." &lt;&lt; std::endl;
170 				}
171 				std::array&lt;char, 1048576&gt; buffer;
172 				size_t length = 0;
173 				char* result = fgets( buffer.data(), buffer.size(), stdin );
174 				if( !result )
175 				{
176 					if( options.annotate ) { std::cerr &lt;&lt; "!!: "; }
177 					std::cerr &lt;&lt; "Error in standard input" &lt;&lt; std::endl;
178 					return EXIT_FAILURE;
179 				}
180 				assert(message.parts() == 0);
181 				while( result &amp;&amp; (length = strlen( buffer.data() ) - 1) &gt; 0 ) 				{
182 					buffer[length] = 0;
183 					message.add_raw( buffer.data(), static_cast&lt;uint64_t&gt;(length) );
184 					if( options.singlepart ) { break; }
185 					result = fgets(buffer.data(), buffer.size(), stdin);
186 				}
187 				if( message.parts() &gt; 0 )
188 				{
189 					if( options.verbose )
190 					{
191 						for( size_t i = 0; i &lt; message.parts(); ++i )
192 						{
193 							if( options.annotate ) { std::cout &lt;&lt; "&gt;&gt;: "; }
194 							std::cout &lt;&lt; message.get(i) &lt;&lt; std::endl;
195 						}
196 						if( options.annotate ) { std::cout &lt;&lt; " --- " &lt;&lt; std::endl; }
197 						else { std::cout &lt;&lt; std::endl; }
198 					}
199 					if( !socket.send( message, true ) )
200 					{
201 						if( options.detailed )
202 						{
203 							if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
204 							std::cerr &lt;&lt; "Output blocking, waiting to send" &lt;&lt; std::endl;
205 						}
206 						if( !socket.send( message ) )
207 						{
208 							if( options.annotate ) {	std::cerr &lt;&lt; "!!: "; }
209 							std::cerr &lt;&lt; "Send failed, socket would have blocked" &lt;&lt; std::endl;
210 							zmqpp::message tmp;
211 							std::swap( tmp, message );
212 						}
213 					}
214 					if (toggles)
215 					{
216 						can_recv = true;
217 						can_send = false;
218 						if( options.detailed )
219 						{
220 							if( options.annotate ) { std::cerr &lt;&lt; "**: " &lt;&lt; std::endl; }
221 							std::cerr &lt;&lt; "Toggling to receive enabled" &lt;&lt; std::endl;
222 						}
223 					}
224 				}
225 			}
226 			else if( (standardin &gt;= 0) &amp;&amp; can_send &amp;&amp; !can_recv )
227 			{
228 				if( options.detailed )
229 				{
230 					if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
231 					std::cerr &lt;&lt; "No data on stdin, exiting reader." &lt;&lt; std::endl;
232 				}
233 				break;
234 			}
235 		}
236 		else if( options.detailed )
237 		{
238 			if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
239 			std::cerr &lt;&lt; "Poller returned with no data, possibly an interrupt." &lt;&lt; std::endl;
240 		}
241 	}
242 	if( options.detailed )
243 	{
244 		if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
245 		std::cerr &lt;&lt; "Exited reader, shutting down." &lt;&lt; std::endl;
246 	}
247 	return EXIT_SUCCESS;
248 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
