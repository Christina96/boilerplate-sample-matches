<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for auth.cpp & main.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for auth.cpp & main.cpp
      </h3>
      <h1 align="center">
        2.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>auth.cpp (3.0456853%)<TH>main.cpp (2.764977%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match94-0.html#0',2,'match94-1.html#0',3)" NAME="0">(349-359)<TD><A HREF="javascript:ZweiFrames('match94-0.html#0',2,'match94-1.html#0',3)" NAME="0">(203-213)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>auth.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file is part of zmqpp.
 * Copyright (c) 2011-2015 Contributors as noted in the AUTHORS file.
 */

/**
 * \file
 *
 * \date   25 Nov 2014
 * \author Prem Shankar Kumar (\@meprem)
 */

#include &lt;string&gt;
#include &lt;utility&gt;

#include &quot;auth.hpp&quot;
#include &quot;message.hpp&quot;
#include &quot;exception.hpp&quot;
#include &quot;socket_types.hpp&quot;
#include &quot;signal.hpp&quot;
#include &quot;z85.hpp&quot;

#if (ZMQ_VERSION_MAJOR &gt; 3)

#if defined(ZMQPP_NO_CONSTEXPR)
	const char * const zmqpp::auth::zap_endpoint_ = &quot;inproc://zeromq.zap.01&quot;;
#endif

namespace zmqpp
{
auth::auth(context&amp; ctx) :
  curve_allow_any(false),
  terminated(false),
  verbose(false)
  {
    auto zap_auth_server = [this] (socket * pipe, context&amp; auth_ctx) -&gt; bool {
        // spawn ZAP handler
        socket zap_handler(auth_ctx, socket_type::reply);
        try {
            zap_handler.bind(zap_endpoint_);
            pipe-&gt;send(signal::ok);
        }
        catch (zmq_internal_exception const&amp;) {
            // by returning false here, the actor will send signal::ko
            // this will make the actor constructor throw.
            // we could also to the ourselves: pipe-&gt;send(signal::ko);)
            return false;
        }

        auth_poller.add(*pipe);
        auth_poller.add(zap_handler);

        while (!terminated &amp;&amp; auth_poller.poll()) {
            if (auth_poller.has_input(zap_handler)) {
                authenticate(zap_handler);
            }
            if (auth_poller.has_input(*pipe)) {
                handle_command(*pipe);
            }
        }
        zap_handler.unbind(zap_endpoint_);
        return true;        
    };

    // Start ZAP Authentication Server
    std::cout &lt;&lt; &quot;auth: Starting ZAP Authentication Server&quot; &lt;&lt; std::endl; 
    authenticator = std::make_shared&lt;actor&gt;(std::bind(zap_auth_server, std::placeholders::_1, std::ref(ctx)));
}

auth::~auth() {
    message msg;
	msg &lt;&lt; &quot;TERMINATE&quot;;
	authenticator-&gt;pipe()-&gt;send(msg);
    authenticator-&gt;pipe()-&gt;wait();
}

void auth::allow(const std::string &amp;address) {
	message msg;
	msg &lt;&lt; &quot;ALLOW&quot; &lt;&lt; address;
	authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::deny(const std::string &amp;address) {
	message msg;
	msg &lt;&lt; &quot;DENY&quot; &lt;&lt; address;
	authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_domain(const std::string &amp;domain) {
	message msg;
	assert(!domain.empty());
	msg &lt;&lt; &quot;DOMAIN&quot; &lt;&lt; domain;
	authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_plain(const std::string &amp;username, const std::string &amp;password) {
	message msg;
	assert(!username.empty());
	assert(!password.empty());
	msg &lt;&lt; &quot;PLAIN&quot; &lt;&lt; username &lt;&lt; password;

    if (verbose) {
        std::cout &lt;&lt; &quot;auth: configure PLAIN - username:&quot; &lt;&lt; username &lt;&lt; &quot; password:&quot; &lt;&lt; password &lt;&lt; std::endl; 
    }

    authenticator-&gt;pipe()-&gt;send(msg);
    authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_curve(const std::string &amp;client_public_key) {
	message msg;
	assert(!client_public_key.empty());
	msg &lt;&lt; &quot;CURVE&quot; &lt;&lt; client_public_key;

    if (verbose) {
        std::cout &lt;&lt; &quot;auth: configure CURVE - client public key:&quot; &lt;&lt; client_public_key &lt;&lt; std::endl; 
    }

    authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_gssapi() {
	message msg;
	msg &lt;&lt; &quot;GSSAPI&quot;;

    if (verbose) {
        std::cout &lt;&lt; &quot;auth: configure GSSAPI - Not implemented yet!!!&quot; &lt;&lt; std::endl; 
    }

    authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::set_verbose(bool verbose) {
    std::string verbose_string = (true == verbose) ? &quot;true&quot; : &quot;false&quot;; 
	message msg;
   	msg &lt;&lt; &quot;VERBOSE&quot; &lt;&lt; verbose_string;
    
    if(verbose) {
            std::cout &lt;&lt; &quot;auth: verbose:&quot; &lt;&lt; verbose_string &lt;&lt; std::endl;
    }
        
    authenticator-&gt;pipe()-&gt;send(msg);
    authenticator-&gt;pipe()-&gt;wait();
}

void auth::handle_command(socket&amp; pipe) {
    // Get the whole message off the pipe in one go
	message msg;
	pipe.receive(msg);

    if(0 == msg.parts())
        return;     // Interrupted

    // authentication command
	std::string command = msg.get(0);
	if (verbose) {
    	std::cout &lt;&lt;&quot;auth: API command=&quot; &lt;&lt; command &lt;&lt; std::endl;
    }

    if(&quot;ALLOW&quot; == command) {
    	std::string address = msg.get(1);
    	if(verbose) {
    		std::cout &lt;&lt; &quot;auth: whitelisting ipaddress=&quot; &lt;&lt; address &lt;&lt; std::endl;
    	}

    	whitelist.insert(address);
    	pipe.send(signal::ok); 

    } else if(&quot;DENY&quot; == command) {
    	std::string address = msg.get(1);
    	if(verbose) {
    		std::cout &lt;&lt; &quot;auth: blacklisting ipaddress=&quot; &lt;&lt; address &lt;&lt; std::endl;
    	}

    	blacklist.insert(address);
    	pipe.send(signal::ok); 
    	
    } else if(&quot;DOMAIN&quot; == command) {
    	std::string domain = msg.get(1);
    	if(verbose) {
    		std::cout &lt;&lt; &quot;auth: domain=&quot; &lt;&lt; domain &lt;&lt; std::endl;
    	}

    	this-&gt;domain = domain;
    	pipe.send(signal::ok); 
    	
    } else if(&quot;PLAIN&quot; == command) {
    	std::string user = msg.get(1);
    	std::string pass = msg.get(2);

        if (verbose) {
            std::cout &lt;&lt; &quot;auth: configured PLAIN - user:&quot; &lt;&lt; user &lt;&lt; std::endl; 
        }

    	passwords.insert(std::make_pair(user, pass));
    	pipe.send(signal::ok); 

    } else if(&quot;CURVE&quot; == command) {
    	// If client_public_key is CURVE_ALLOW_ANY, allow all clients. Otherwise
    	// treat client_public_key as client public key certificate.
    	std::string client_public_key = msg.get(1);

    	if(&quot;CURVE_ALLOW_ANY&quot; == client_public_key) {
    		curve_allow_any = true;
            if(verbose) {
    		  std::cout &lt;&lt; &quot;auth: configured CURVE - allow ALL clients&quot; &lt;&lt; std::endl;
            }
    	} else {
    		curve_allow_any = false;
    		client_keys.insert(client_public_key);
            if(verbose) {
    		  std::cout &lt;&lt; &quot;auth: configured CURVE - allow client with public key:&quot; &lt;&lt; client_public_key &lt;&lt; std::endl;
            }
    	}
		pipe.send(signal::ok); 

    } else if(&quot;GSSAPI&quot; == command) {
    	// GSSAPI authentication is not yet implemented here
        if(verbose) {
    	   std::cout &lt;&lt; &quot;auth: configure GSSAPI authentication is not yet implemented here&quot; &lt;&lt; std::endl;
        }
    	pipe.send(signal::ok); 

    } else if(&quot;VERBOSE&quot; == command) {
    	std::string verbose_string = msg.get(1);

    	verbose = (&quot;true&quot; == verbose_string)? true : false;
    	pipe.send(signal::ok); 

    } else if(&quot;TERMINATE&quot; == command) {
    	std::cout &lt;&lt; &quot;auth: Shutdown ZAP Authentication Server&quot; &lt;&lt; std::endl;
        
    	terminated = true;
        pipe.send(signal::ok); 

    } else {
        if(verbose) {
    	   std::cout &lt;&lt; &quot;auth: Invalid command=&quot; &lt;&lt; command &lt;&lt; std::endl;
        }
    	assert(false);
    }
}

bool auth::authenticate_plain(zap_request&amp; request, std::string &amp;user_id)
{
	auto search = passwords.find(request.get_username());
    if((search != passwords.end()) &amp;&amp; (search-&gt;second == request.get_password())) {
        if (verbose) {
            std::cout &lt;&lt; &quot;auth: allowed (PLAIN) username=&quot; &lt;&lt; request.get_username()
        		&lt;&lt; &quot; password=&quot; &lt;&lt; request.get_password() &lt;&lt; std::endl;
        }
        user_id = request.get_username();
        return true;
    }
    else {
    	if (verbose) {
            std::cout &lt;&lt; &quot;auth: denied (PLAIN) username=&quot; &lt;&lt; request.get_username()
        		&lt;&lt; &quot; password=&quot; &lt;&lt; request.get_password() &lt;&lt; std::endl;
        }
        return false;
    }
}

bool auth::authenticate_curve(zap_request&amp; request, std::string &amp;user_id)
{
	if (curve_allow_any) {
    	if (verbose) {
        	std::cout &lt;&lt; &quot;auth: allowed (CURVE allow any client)&quot; &lt;&lt; std::endl;
        }
        user_id = request.get_client_key();
    	return true;
	} else {
		auto search = client_keys.find(request.get_client_key());
    	if(search != client_keys.end()) {
    		if (verbose) {
        		std::cout &lt;&lt; &quot;auth: allowed (CURVE) client_key=&quot; &lt;&lt; request.get_client_key() &lt;&lt; std::endl;
            }
            user_id = request.get_client_key();
    		return true;
    	}
    	else {
    		if (verbose) {
        		std::cout &lt;&lt; &quot;auth: denied (CURVE) client_key=&quot; &lt;&lt; request.get_client_key() &lt;&lt; std::endl;
            }
    		return false;
    	}
	}    	
}

bool auth::authenticate_gssapi(zap_request&amp; request) {
	if (verbose) {
    	std::cout &lt;&lt; &quot;auth: allowed (GSSAPI) principal=&quot; &lt;&lt; request.get_principal() 
    		&lt;&lt; &quot; identity=&quot; &lt;&lt; request.get_identity() &lt;&lt; std::endl;
    }
	return true;	
}

void auth::authenticate(socket&amp; sock) {
    // Receive a ZAP request.
	zap_request request(sock, verbose);

    // will be set by mechanism-dependent code
    std::string user_id;

	if(request.get_version().empty()) {        // Interrupted
		request.reply(&quot;500&quot;, &quot;Internal error&quot;, &quot;&quot;);
    	return;     
	}

    // Is address explicitly whitelisted or blacklisted?
    bool allowed = false;
    bool denied = false;

    if(whitelist.size()) {
    	auto search = whitelist.find(request.get_address());
    	if (search != whitelist.end()) {
            allowed = true;
            if (verbose) {
                std::cout &lt;&lt; &quot;auth: passed (whitelist) address=&quot; &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }
        else {
            denied = true;
            if (verbose) {
                std::cout &lt;&lt; &quot;auth: denied (not in whitelist) address=&quot; &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }

    } else if(blacklist.size()) {
    	auto search = blacklist.find(request.get_address());
    	if (search != blacklist.end()) {
            denied = true;
            if (verbose) {
                std::cout &lt;&lt; &quot;auth: denied (blacklist) address=&quot; &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }
<A NAME="0"></A>        else {
            allowed = true;
            if (verbose) {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match94-1.html#0',3,'match94-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>                std::cout &lt;&lt; &quot;auth: passed (not in blacklist) address=&quot; &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }
    }

    // Mechanism-specific checks
    if(!denied) {
    	if ((&quot;NULL&quot; == request.get_mechanism()) &amp;&amp; !allowed) {
            // For NULL, we allow if the address wasn't blacklisted
            if (verbose) {
                std::cout &lt;&lt; &quot;auth: allowed (NULL)&quot; &lt;&lt; std::endl;</B></FONT>
            }
            allowed = true;

        } else if (&quot;PLAIN&quot; == request.get_mechanism()) {
            // For PLAIN, even a whitelisted address must authenticate
            allowed = authenticate_plain(request, user_id);

        } else if (&quot;CURVE&quot; == request.get_mechanism()) {
            // For CURVE, even a whitelisted address must authenticate
            allowed = authenticate_curve(request, user_id);

        } else if (&quot;GSSAPI&quot; == request.get_mechanism()) {
            // For GSSAPI, even a whitelisted address must authenticate
            allowed = authenticate_gssapi(request);
        }
    }
    if (allowed)
    	request.reply(&quot;200&quot;, &quot;OK&quot;, user_id);
    else
        request.reply(&quot;400&quot;, &quot;No access&quot;, &quot;&quot;);
}

}

#endif
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>main.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file is part of zmqpp.
 * Copyright (c) 2011-2015 Contributors as noted in the AUTHORS file.
 */

/*
 *  Created on: 16 Aug 2011
 *      Author: @benjamg
 */

#include &lt;cstdlib&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;tuple&gt;

#include &lt;zmqpp/zmqpp.hpp&gt;

#include &quot;options.hpp&quot;

#ifndef BUILD_CLIENT_NAME
#define BUILD_CLIENT_NAME &quot;zmqpp&quot;
#endif

int main(int argc, char const* argv[])
{
	client_options const options = process_command_line( argc, argv );

	if( options.show_version )
	{
		uint8_t major, minor, patch;
		zmqpp::zmq_version(major, minor, patch);

		std::cout &lt;&lt; BUILD_CLIENT_NAME &lt;&lt; &quot; version &quot; &lt;&lt; zmqpp::version() &lt;&lt; std::endl;
		std::cout &lt;&lt; &quot;  built against 0mq version &quot; &lt;&lt; static_cast&lt;int&gt;(major) &lt;&lt; &quot;.&quot; &lt;&lt; static_cast&lt;int&gt;(minor) &lt;&lt; &quot;.&quot; &lt;&lt; static_cast&lt;int&gt;(patch) &lt;&lt; std::endl;

		return EXIT_FAILURE;
	}

	if( options.show_usage || options.show_help )
	{
		show_usage( std::cout, BUILD_CLIENT_NAME );
		if( options.show_help )
		{
			std::cout &lt;&lt; std::endl;
			show_help( std::cout );
		}

		return EXIT_FAILURE;
	}

	bool can_send = false, can_recv = false, toggles = false;
	switch( options.type )
	{
	case zmqpp::socket_type::push:      can_send = true; break;
	case zmqpp::socket_type::pull:      can_recv = true; break;
	case zmqpp::socket_type::publish:   can_send = true; break;
	case zmqpp::socket_type::subscribe: can_recv = true; break;
	case zmqpp::socket_type::request:   can_send = true; toggles = true; break;
	case zmqpp::socket_type::reply:     can_recv = true; toggles = true; break;
	default:
		std::cerr &lt;&lt; &quot;Unsupported socket type&quot; &lt;&lt; std::endl;
		return EXIT_FAILURE;
	}

	int standardin = -1;
	// If we can send / toggle then we need stdin
	if( can_send || toggles )
	{
		if( options.verbose ) { std::cerr &lt;&lt; &quot;Connecting to stdin&quot; &lt;&lt; std::endl; }
		standardin = fileno(stdin);
		if ( standardin &lt; 0 ) // really?
		{
			std::cerr &lt;&lt; &quot;Unable to get standard input, this might be an OS thing, sorry.&quot; &lt;&lt; std::endl;
			return EXIT_FAILURE;
		}
	}

	zmqpp::context context;
	zmqpp::socket socket( context, options.type );

	// TODO: allow subscriptions on command line
	if( zmqpp::socket_type::subscribe == options.type ) { socket.subscribe( &quot;&quot; ); }

	if( !options.binds.empty() )
	{
		for(size_t i = 0; i &lt; options.binds.size(); ++i)
		{
			if( options.verbose ) { std::cerr &lt;&lt; &quot;binding to &quot; &lt;&lt; options.binds[i] &lt;&lt; std::endl; }
			try
			{
				socket.bind( options.binds[i] );
			}
			catch(zmqpp::zmq_internal_exception&amp; e)
			{
				std::cerr &lt;&lt; &quot;failed to bind to endpoint &quot; &lt;&lt; options.binds[i] &lt;&lt; &quot;: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
				return EXIT_FAILURE;
			}
		}
	}

	if( !options.connects.empty() )
	{
		for(size_t i = 0; i &lt; options.connects.size(); ++i)
		{
			if( options.verbose ) { std::cerr &lt;&lt; &quot;connecting to &quot; &lt;&lt; options.connects[i] &lt;&lt; std::endl; }
			try
			{
				socket.connect( options.connects[i] );
			}
			catch(zmqpp::zmq_internal_exception&amp; e)
			{
				std::cerr &lt;&lt; &quot;failed to bind to endpoint &quot; &lt;&lt; options.connects[i] &lt;&lt; &quot;: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
				return EXIT_FAILURE;
			}
		}
	}

	zmqpp::poller poller;
	poller.add(socket);
	if( standardin &gt;= 0 ) { poller.add( standardin ); }

	if( options.verbose &amp;&amp; ( can_send || toggles ) )
	{
		std::cerr &lt;&lt; &quot;While sending packets is allowed data entered on standard in will be sent to the 0mq socket.&quot; &lt;&lt; std::endl;
		if( options.singlepart )
		{
			std::cerr &lt;&lt; &quot;messages will be considered terminated by newline.&quot; &lt;&lt; std::endl;
		}
		else
		{
			std::cerr &lt;&lt; &quot;Message parts will be considered terminated by newline.&quot; &lt;&lt; std::endl;
			std::cerr &lt;&lt; &quot;Messages will be considered terminated by an empty part.&quot; &lt;&lt; std::endl;
			std::cerr &lt;&lt; &quot;The empty part itself will not be included.&quot; &lt;&lt; std::endl;
		}
		std::cerr &lt;&lt; std::endl;

		if ( toggles &amp;&amp; !can_send )
		{
			std::cerr &lt;&lt; &quot;Sending starts as disabled for this socket type.&quot; &lt;&lt; std::endl;
			std::cerr &lt;&lt; std::endl;
		}
	}

	if( options.detailed )
	{
		if( standardin &gt;= 0 ) { if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; } std::cerr &lt;&lt; &quot;reading from stdin is enabled.&quot; &lt;&lt; std::endl; }
		if( can_send ) { if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; } std::cerr &lt;&lt; &quot;sending via socket is enabled.&quot; &lt;&lt; std::endl; }
		if( can_recv ) { if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; } std::cerr &lt;&lt; &quot;receiving via socket is enabled.&quot; &lt;&lt; std::endl; }
		if( toggles ) { if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; } std::cerr &lt;&lt; &quot;socket will flip between send/recv.&quot; &lt;&lt; std::endl; }
		if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }	std::cerr &lt;&lt; &quot;Warning - Detailed logging is enabled.&quot; &lt;&lt; std::endl;
	}

	zmqpp::message message;
	while(true)
	{
		poller.check_for(socket, (can_recv) ? zmqpp::poller::poll_in : zmqpp::poller::poll_none);
		if( standardin &gt;= 0 )
		{
			poller.check_for(standardin, (can_send) ? zmqpp::poller::poll_in : zmqpp::poller::poll_none);
		}

		if( options.detailed )
		{
			if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }
			std::cerr &lt;&lt; &quot;Polling for incomming message data.&quot; &lt;&lt; std::endl;
		}

		if( poller.poll() )
		{
			if (poller.has_input(socket))
			{
				assert(can_recv);
				if( options.detailed )
				{
					if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }
					std::cerr &lt;&lt; &quot;Message on socket.&quot; &lt;&lt; std::endl;
				}

				do
				{
					std::string message;
					socket.receive(message);

					if( options.annotate ) { std::cout &lt;&lt; &quot;&lt;&lt;: &quot;; }
					std::cout &lt;&lt; message &lt;&lt; std::endl;

				} while(socket.has_more_parts());

				if( options.annotate ) { std::cout &lt;&lt; &quot; --- &quot; &lt;&lt; std::endl; }
				else { std::cout &lt;&lt; std::endl; }

				if (toggles)
				{
					can_recv = false;
					can_send = true;
<A NAME="0"></A>					if( options.detailed )
					{
						if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot; &lt;&lt; std::endl; }
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match94-0.html#0',2,'match94-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>						std::cerr &lt;&lt; &quot;Toggling to sending enabled&quot; &lt;&lt; std::endl;
					}
				}
			}

			if( (standardin &gt;= 0) &amp;&amp; poller.has_input( standardin ) )
			{
				assert(can_send);
				if( options.detailed )
				{
					if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }</B></FONT>
					std::cerr &lt;&lt; &quot;Data on stdin.&quot; &lt;&lt; std::endl;
				}

				// TODO: handle cases where we actually read a mb of data from standard in and still don't have the terminator
				std::array&lt;char, 1048576&gt; buffer;
				size_t length = 0;
				char* result = fgets( buffer.data(), buffer.size(), stdin );

				if( !result )
				{
					if( options.annotate ) { std::cerr &lt;&lt; &quot;!!: &quot;; }

					std::cerr &lt;&lt; &quot;Error in standard input&quot; &lt;&lt; std::endl;
					return EXIT_FAILURE;
				}

				assert(message.parts() == 0);
				while( result &amp;&amp; (length = strlen( buffer.data() ) - 1) &gt; 0 ) // trim newline from gets
				{
					buffer[length] = 0;
					message.add_raw( buffer.data(), static_cast&lt;uint64_t&gt;(length) );

					if( options.singlepart ) { break; }

					result = fgets(buffer.data(), buffer.size(), stdin);
				}

				if( message.parts() &gt; 0 )
				{
					if( options.verbose )
					{
						for( size_t i = 0; i &lt; message.parts(); ++i )
						{
							if( options.annotate ) { std::cout &lt;&lt; &quot;&gt;&gt;: &quot;; }
							std::cout &lt;&lt; message.get(i) &lt;&lt; std::endl;
						}

						if( options.annotate ) { std::cout &lt;&lt; &quot; --- &quot; &lt;&lt; std::endl; }
						else { std::cout &lt;&lt; std::endl; }
					}

					if( !socket.send( message, true ) )
					{
						if( options.detailed )
						{
							if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }
							std::cerr &lt;&lt; &quot;Output blocking, waiting to send&quot; &lt;&lt; std::endl;
						}

						if( !socket.send( message ) )
						{
							if( options.annotate ) {	std::cerr &lt;&lt; &quot;!!: &quot;; }

							std::cerr &lt;&lt; &quot;Send failed, socket would have blocked&quot; &lt;&lt; std::endl;

							zmqpp::message tmp;
							std::swap( tmp, message );
						}
					}

					if (toggles)
					{
						can_recv = true;
						can_send = false;
						if( options.detailed )
						{
							if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot; &lt;&lt; std::endl; }
							std::cerr &lt;&lt; &quot;Toggling to receive enabled&quot; &lt;&lt; std::endl;
						}
					}
				}
			}
			else if( (standardin &gt;= 0) &amp;&amp; can_send &amp;&amp; !can_recv )
			{
				if( options.detailed )
				{
					if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }
					std::cerr &lt;&lt; &quot;No data on stdin, exiting reader.&quot; &lt;&lt; std::endl;
				}
				break;
			}
		}
		else if( options.detailed )
		{
			if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }
			std::cerr &lt;&lt; &quot;Poller returned with no data, possibly an interrupt.&quot; &lt;&lt; std::endl;
		}
	}

	if( options.detailed )
	{
		if( options.annotate ) { std::cerr &lt;&lt; &quot;**: &quot;; }
		std::cerr &lt;&lt; &quot;Exited reader, shutting down.&quot; &lt;&lt; std::endl;
	}

	return EXIT_SUCCESS;
}
</PRE>
</div>
  </div>
</body>
</html>
