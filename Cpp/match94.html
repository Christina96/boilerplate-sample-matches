<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for auth.cpp &amp; main.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for auth.cpp &amp; main.cpp
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>auth.cpp (3.0456853%)<th>main.cpp (2.764977%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(349-359)<td><a href="#" name="0">(203-213)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>auth.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file is part of zmqpp.
 * Copyright (c) 2011-2015 Contributors as noted in the AUTHORS file.
 */

/**
 * \file
 *
 * \date   25 Nov 2014
 * \author Prem Shankar Kumar (\@meprem)
 */

#include &lt;string&gt;
#include &lt;utility&gt;

#include "auth.hpp"
#include "message.hpp"
#include "exception.hpp"
#include "socket_types.hpp"
#include "signal.hpp"
#include "z85.hpp"

#if (ZMQ_VERSION_MAJOR &gt; 3)

#if defined(ZMQPP_NO_CONSTEXPR)
	const char * const zmqpp::auth::zap_endpoint_ = "inproc://zeromq.zap.01";
#endif

namespace zmqpp
{
auth::auth(context&amp; ctx) :
  curve_allow_any(false),
  terminated(false),
  verbose(false)
  {
    auto zap_auth_server = [this] (socket * pipe, context&amp; auth_ctx) -&gt; bool {
        // spawn ZAP handler
        socket zap_handler(auth_ctx, socket_type::reply);
        try {
            zap_handler.bind(zap_endpoint_);
            pipe-&gt;send(signal::ok);
        }
        catch (zmq_internal_exception const&amp;) {
            // by returning false here, the actor will send signal::ko
            // this will make the actor constructor throw.
            // we could also to the ourselves: pipe-&gt;send(signal::ko);)
            return false;
        }

        auth_poller.add(*pipe);
        auth_poller.add(zap_handler);

        while (!terminated &amp;&amp; auth_poller.poll()) {
            if (auth_poller.has_input(zap_handler)) {
                authenticate(zap_handler);
            }
            if (auth_poller.has_input(*pipe)) {
                handle_command(*pipe);
            }
        }
        zap_handler.unbind(zap_endpoint_);
        return true;        
    };

    // Start ZAP Authentication Server
    std::cout &lt;&lt; "auth: Starting ZAP Authentication Server" &lt;&lt; std::endl; 
    authenticator = std::make_shared&lt;actor&gt;(std::bind(zap_auth_server, std::placeholders::_1, std::ref(ctx)));
}

auth::~auth() {
    message msg;
	msg &lt;&lt; "TERMINATE";
	authenticator-&gt;pipe()-&gt;send(msg);
    authenticator-&gt;pipe()-&gt;wait();
}

void auth::allow(const std::string &amp;address) {
	message msg;
	msg &lt;&lt; "ALLOW" &lt;&lt; address;
	authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::deny(const std::string &amp;address) {
	message msg;
	msg &lt;&lt; "DENY" &lt;&lt; address;
	authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_domain(const std::string &amp;domain) {
	message msg;
	assert(!domain.empty());
	msg &lt;&lt; "DOMAIN" &lt;&lt; domain;
	authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_plain(const std::string &amp;username, const std::string &amp;password) {
	message msg;
	assert(!username.empty());
	assert(!password.empty());
	msg &lt;&lt; "PLAIN" &lt;&lt; username &lt;&lt; password;

    if (verbose) {
        std::cout &lt;&lt; "auth: configure PLAIN - username:" &lt;&lt; username &lt;&lt; " password:" &lt;&lt; password &lt;&lt; std::endl; 
    }

    authenticator-&gt;pipe()-&gt;send(msg);
    authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_curve(const std::string &amp;client_public_key) {
	message msg;
	assert(!client_public_key.empty());
	msg &lt;&lt; "CURVE" &lt;&lt; client_public_key;

    if (verbose) {
        std::cout &lt;&lt; "auth: configure CURVE - client public key:" &lt;&lt; client_public_key &lt;&lt; std::endl; 
    }

    authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::configure_gssapi() {
	message msg;
	msg &lt;&lt; "GSSAPI";

    if (verbose) {
        std::cout &lt;&lt; "auth: configure GSSAPI - Not implemented yet!!!" &lt;&lt; std::endl; 
    }

    authenticator-&gt;pipe()-&gt;send(msg);
	authenticator-&gt;pipe()-&gt;wait();
}

void auth::set_verbose(bool verbose) {
    std::string verbose_string = (true == verbose) ? "true" : "false"; 
	message msg;
   	msg &lt;&lt; "VERBOSE" &lt;&lt; verbose_string;
    
    if(verbose) {
            std::cout &lt;&lt; "auth: verbose:" &lt;&lt; verbose_string &lt;&lt; std::endl;
    }
        
    authenticator-&gt;pipe()-&gt;send(msg);
    authenticator-&gt;pipe()-&gt;wait();
}

void auth::handle_command(socket&amp; pipe) {
    // Get the whole message off the pipe in one go
	message msg;
	pipe.receive(msg);

    if(0 == msg.parts())
        return;     // Interrupted

    // authentication command
	std::string command = msg.get(0);
	if (verbose) {
    	std::cout &lt;&lt;"auth: API command=" &lt;&lt; command &lt;&lt; std::endl;
    }

    if("ALLOW" == command) {
    	std::string address = msg.get(1);
    	if(verbose) {
    		std::cout &lt;&lt; "auth: whitelisting ipaddress=" &lt;&lt; address &lt;&lt; std::endl;
    	}

    	whitelist.insert(address);
    	pipe.send(signal::ok); 

    } else if("DENY" == command) {
    	std::string address = msg.get(1);
    	if(verbose) {
    		std::cout &lt;&lt; "auth: blacklisting ipaddress=" &lt;&lt; address &lt;&lt; std::endl;
    	}

    	blacklist.insert(address);
    	pipe.send(signal::ok); 
    	
    } else if("DOMAIN" == command) {
    	std::string domain = msg.get(1);
    	if(verbose) {
    		std::cout &lt;&lt; "auth: domain=" &lt;&lt; domain &lt;&lt; std::endl;
    	}

    	this-&gt;domain = domain;
    	pipe.send(signal::ok); 
    	
    } else if("PLAIN" == command) {
    	std::string user = msg.get(1);
    	std::string pass = msg.get(2);

        if (verbose) {
            std::cout &lt;&lt; "auth: configured PLAIN - user:" &lt;&lt; user &lt;&lt; std::endl; 
        }

    	passwords.insert(std::make_pair(user, pass));
    	pipe.send(signal::ok); 

    } else if("CURVE" == command) {
    	// If client_public_key is CURVE_ALLOW_ANY, allow all clients. Otherwise
    	// treat client_public_key as client public key certificate.
    	std::string client_public_key = msg.get(1);

    	if("CURVE_ALLOW_ANY" == client_public_key) {
    		curve_allow_any = true;
            if(verbose) {
    		  std::cout &lt;&lt; "auth: configured CURVE - allow ALL clients" &lt;&lt; std::endl;
            }
    	} else {
    		curve_allow_any = false;
    		client_keys.insert(client_public_key);
            if(verbose) {
    		  std::cout &lt;&lt; "auth: configured CURVE - allow client with public key:" &lt;&lt; client_public_key &lt;&lt; std::endl;
            }
    	}
		pipe.send(signal::ok); 

    } else if("GSSAPI" == command) {
    	// GSSAPI authentication is not yet implemented here
        if(verbose) {
    	   std::cout &lt;&lt; "auth: configure GSSAPI authentication is not yet implemented here" &lt;&lt; std::endl;
        }
    	pipe.send(signal::ok); 

    } else if("VERBOSE" == command) {
    	std::string verbose_string = msg.get(1);

    	verbose = ("true" == verbose_string)? true : false;
    	pipe.send(signal::ok); 

    } else if("TERMINATE" == command) {
    	std::cout &lt;&lt; "auth: Shutdown ZAP Authentication Server" &lt;&lt; std::endl;
        
    	terminated = true;
        pipe.send(signal::ok); 

    } else {
        if(verbose) {
    	   std::cout &lt;&lt; "auth: Invalid command=" &lt;&lt; command &lt;&lt; std::endl;
        }
    	assert(false);
    }
}

bool auth::authenticate_plain(zap_request&amp; request, std::string &amp;user_id)
{
	auto search = passwords.find(request.get_username());
    if((search != passwords.end()) &amp;&amp; (search-&gt;second == request.get_password())) {
        if (verbose) {
            std::cout &lt;&lt; "auth: allowed (PLAIN) username=" &lt;&lt; request.get_username()
        		&lt;&lt; " password=" &lt;&lt; request.get_password() &lt;&lt; std::endl;
        }
        user_id = request.get_username();
        return true;
    }
    else {
    	if (verbose) {
            std::cout &lt;&lt; "auth: denied (PLAIN) username=" &lt;&lt; request.get_username()
        		&lt;&lt; " password=" &lt;&lt; request.get_password() &lt;&lt; std::endl;
        }
        return false;
    }
}

bool auth::authenticate_curve(zap_request&amp; request, std::string &amp;user_id)
{
	if (curve_allow_any) {
    	if (verbose) {
        	std::cout &lt;&lt; "auth: allowed (CURVE allow any client)" &lt;&lt; std::endl;
        }
        user_id = request.get_client_key();
    	return true;
	} else {
		auto search = client_keys.find(request.get_client_key());
    	if(search != client_keys.end()) {
    		if (verbose) {
        		std::cout &lt;&lt; "auth: allowed (CURVE) client_key=" &lt;&lt; request.get_client_key() &lt;&lt; std::endl;
            }
            user_id = request.get_client_key();
    		return true;
    	}
    	else {
    		if (verbose) {
        		std::cout &lt;&lt; "auth: denied (CURVE) client_key=" &lt;&lt; request.get_client_key() &lt;&lt; std::endl;
            }
    		return false;
    	}
	}    	
}

bool auth::authenticate_gssapi(zap_request&amp; request) {
	if (verbose) {
    	std::cout &lt;&lt; "auth: allowed (GSSAPI) principal=" &lt;&lt; request.get_principal() 
    		&lt;&lt; " identity=" &lt;&lt; request.get_identity() &lt;&lt; std::endl;
    }
	return true;	
}

void auth::authenticate(socket&amp; sock) {
    // Receive a ZAP request.
	zap_request request(sock, verbose);

    // will be set by mechanism-dependent code
    std::string user_id;

	if(request.get_version().empty()) {        // Interrupted
		request.reply("500", "Internal error", "");
    	return;     
	}

    // Is address explicitly whitelisted or blacklisted?
    bool allowed = false;
    bool denied = false;

    if(whitelist.size()) {
    	auto search = whitelist.find(request.get_address());
    	if (search != whitelist.end()) {
            allowed = true;
            if (verbose) {
                std::cout &lt;&lt; "auth: passed (whitelist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }
        else {
            denied = true;
            if (verbose) {
                std::cout &lt;&lt; "auth: denied (not in whitelist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }

    } else if(blacklist.size()) {
    	auto search = blacklist.find(request.get_address());
    	if (search != blacklist.end()) {
            denied = true;
            if (verbose) {
                std::cout &lt;&lt; "auth: denied (blacklist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }
<a name="0"></a>        else {
            allowed = true;
            if (verbose) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                std::cout &lt;&lt; "auth: passed (not in blacklist) address=" &lt;&lt; request.get_address() &lt;&lt; std::endl;
            }
        }
    }

    // Mechanism-specific checks
    if(!denied) {
    	if (("NULL" == request.get_mechanism()) &amp;&amp; !allowed) {
            // For NULL, we allow if the address wasn't blacklisted
            if (verbose) {
                std::cout &lt;&lt; "auth: allowed (NULL)" &lt;&lt; std::endl;</b></font>
            }
            allowed = true;

        } else if ("PLAIN" == request.get_mechanism()) {
            // For PLAIN, even a whitelisted address must authenticate
            allowed = authenticate_plain(request, user_id);

        } else if ("CURVE" == request.get_mechanism()) {
            // For CURVE, even a whitelisted address must authenticate
            allowed = authenticate_curve(request, user_id);

        } else if ("GSSAPI" == request.get_mechanism()) {
            // For GSSAPI, even a whitelisted address must authenticate
            allowed = authenticate_gssapi(request);
        }
    }
    if (allowed)
    	request.reply("200", "OK", user_id);
    else
        request.reply("400", "No access", "");
}

}

#endif
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>main.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file is part of zmqpp.
 * Copyright (c) 2011-2015 Contributors as noted in the AUTHORS file.
 */

/*
 *  Created on: 16 Aug 2011
 *      Author: @benjamg
 */

#include &lt;cstdlib&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;tuple&gt;

#include &lt;zmqpp/zmqpp.hpp&gt;

#include "options.hpp"

#ifndef BUILD_CLIENT_NAME
#define BUILD_CLIENT_NAME "zmqpp"
#endif

int main(int argc, char const* argv[])
{
	client_options const options = process_command_line( argc, argv );

	if( options.show_version )
	{
		uint8_t major, minor, patch;
		zmqpp::zmq_version(major, minor, patch);

		std::cout &lt;&lt; BUILD_CLIENT_NAME &lt;&lt; " version " &lt;&lt; zmqpp::version() &lt;&lt; std::endl;
		std::cout &lt;&lt; "  built against 0mq version " &lt;&lt; static_cast&lt;int&gt;(major) &lt;&lt; "." &lt;&lt; static_cast&lt;int&gt;(minor) &lt;&lt; "." &lt;&lt; static_cast&lt;int&gt;(patch) &lt;&lt; std::endl;

		return EXIT_FAILURE;
	}

	if( options.show_usage || options.show_help )
	{
		show_usage( std::cout, BUILD_CLIENT_NAME );
		if( options.show_help )
		{
			std::cout &lt;&lt; std::endl;
			show_help( std::cout );
		}

		return EXIT_FAILURE;
	}

	bool can_send = false, can_recv = false, toggles = false;
	switch( options.type )
	{
	case zmqpp::socket_type::push:      can_send = true; break;
	case zmqpp::socket_type::pull:      can_recv = true; break;
	case zmqpp::socket_type::publish:   can_send = true; break;
	case zmqpp::socket_type::subscribe: can_recv = true; break;
	case zmqpp::socket_type::request:   can_send = true; toggles = true; break;
	case zmqpp::socket_type::reply:     can_recv = true; toggles = true; break;
	default:
		std::cerr &lt;&lt; "Unsupported socket type" &lt;&lt; std::endl;
		return EXIT_FAILURE;
	}

	int standardin = -1;
	// If we can send / toggle then we need stdin
	if( can_send || toggles )
	{
		if( options.verbose ) { std::cerr &lt;&lt; "Connecting to stdin" &lt;&lt; std::endl; }
		standardin = fileno(stdin);
		if ( standardin &lt; 0 ) // really?
		{
			std::cerr &lt;&lt; "Unable to get standard input, this might be an OS thing, sorry." &lt;&lt; std::endl;
			return EXIT_FAILURE;
		}
	}

	zmqpp::context context;
	zmqpp::socket socket( context, options.type );

	// TODO: allow subscriptions on command line
	if( zmqpp::socket_type::subscribe == options.type ) { socket.subscribe( "" ); }

	if( !options.binds.empty() )
	{
		for(size_t i = 0; i &lt; options.binds.size(); ++i)
		{
			if( options.verbose ) { std::cerr &lt;&lt; "binding to " &lt;&lt; options.binds[i] &lt;&lt; std::endl; }
			try
			{
				socket.bind( options.binds[i] );
			}
			catch(zmqpp::zmq_internal_exception&amp; e)
			{
				std::cerr &lt;&lt; "failed to bind to endpoint " &lt;&lt; options.binds[i] &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;
				return EXIT_FAILURE;
			}
		}
	}

	if( !options.connects.empty() )
	{
		for(size_t i = 0; i &lt; options.connects.size(); ++i)
		{
			if( options.verbose ) { std::cerr &lt;&lt; "connecting to " &lt;&lt; options.connects[i] &lt;&lt; std::endl; }
			try
			{
				socket.connect( options.connects[i] );
			}
			catch(zmqpp::zmq_internal_exception&amp; e)
			{
				std::cerr &lt;&lt; "failed to bind to endpoint " &lt;&lt; options.connects[i] &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;
				return EXIT_FAILURE;
			}
		}
	}

	zmqpp::poller poller;
	poller.add(socket);
	if( standardin &gt;= 0 ) { poller.add( standardin ); }

	if( options.verbose &amp;&amp; ( can_send || toggles ) )
	{
		std::cerr &lt;&lt; "While sending packets is allowed data entered on standard in will be sent to the 0mq socket." &lt;&lt; std::endl;
		if( options.singlepart )
		{
			std::cerr &lt;&lt; "messages will be considered terminated by newline." &lt;&lt; std::endl;
		}
		else
		{
			std::cerr &lt;&lt; "Message parts will be considered terminated by newline." &lt;&lt; std::endl;
			std::cerr &lt;&lt; "Messages will be considered terminated by an empty part." &lt;&lt; std::endl;
			std::cerr &lt;&lt; "The empty part itself will not be included." &lt;&lt; std::endl;
		}
		std::cerr &lt;&lt; std::endl;

		if ( toggles &amp;&amp; !can_send )
		{
			std::cerr &lt;&lt; "Sending starts as disabled for this socket type." &lt;&lt; std::endl;
			std::cerr &lt;&lt; std::endl;
		}
	}

	if( options.detailed )
	{
		if( standardin &gt;= 0 ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "reading from stdin is enabled." &lt;&lt; std::endl; }
		if( can_send ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "sending via socket is enabled." &lt;&lt; std::endl; }
		if( can_recv ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "receiving via socket is enabled." &lt;&lt; std::endl; }
		if( toggles ) { if( options.annotate ) { std::cerr &lt;&lt; "**: "; } std::cerr &lt;&lt; "socket will flip between send/recv." &lt;&lt; std::endl; }
		if( options.annotate ) { std::cerr &lt;&lt; "**: "; }	std::cerr &lt;&lt; "Warning - Detailed logging is enabled." &lt;&lt; std::endl;
	}

	zmqpp::message message;
	while(true)
	{
		poller.check_for(socket, (can_recv) ? zmqpp::poller::poll_in : zmqpp::poller::poll_none);
		if( standardin &gt;= 0 )
		{
			poller.check_for(standardin, (can_send) ? zmqpp::poller::poll_in : zmqpp::poller::poll_none);
		}

		if( options.detailed )
		{
			if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
			std::cerr &lt;&lt; "Polling for incomming message data." &lt;&lt; std::endl;
		}

		if( poller.poll() )
		{
			if (poller.has_input(socket))
			{
				assert(can_recv);
				if( options.detailed )
				{
					if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
					std::cerr &lt;&lt; "Message on socket." &lt;&lt; std::endl;
				}

				do
				{
					std::string message;
					socket.receive(message);

					if( options.annotate ) { std::cout &lt;&lt; "&lt;&lt;: "; }
					std::cout &lt;&lt; message &lt;&lt; std::endl;

				} while(socket.has_more_parts());

				if( options.annotate ) { std::cout &lt;&lt; " --- " &lt;&lt; std::endl; }
				else { std::cout &lt;&lt; std::endl; }

				if (toggles)
				{
					can_recv = false;
					can_send = true;
<a name="0"></a>					if( options.detailed )
					{
						if( options.annotate ) { std::cerr &lt;&lt; "**: " &lt;&lt; std::endl; }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>						std::cerr &lt;&lt; "Toggling to sending enabled" &lt;&lt; std::endl;
					}
				}
			}

			if( (standardin &gt;= 0) &amp;&amp; poller.has_input( standardin ) )
			{
				assert(can_send);
				if( options.detailed )
				{
					if( options.annotate ) { std::cerr &lt;&lt; "**: "; }</b></font>
					std::cerr &lt;&lt; "Data on stdin." &lt;&lt; std::endl;
				}

				// TODO: handle cases where we actually read a mb of data from standard in and still don't have the terminator
				std::array&lt;char, 1048576&gt; buffer;
				size_t length = 0;
				char* result = fgets( buffer.data(), buffer.size(), stdin );

				if( !result )
				{
					if( options.annotate ) { std::cerr &lt;&lt; "!!: "; }

					std::cerr &lt;&lt; "Error in standard input" &lt;&lt; std::endl;
					return EXIT_FAILURE;
				}

				assert(message.parts() == 0);
				while( result &amp;&amp; (length = strlen( buffer.data() ) - 1) &gt; 0 ) // trim newline from gets
				{
					buffer[length] = 0;
					message.add_raw( buffer.data(), static_cast&lt;uint64_t&gt;(length) );

					if( options.singlepart ) { break; }

					result = fgets(buffer.data(), buffer.size(), stdin);
				}

				if( message.parts() &gt; 0 )
				{
					if( options.verbose )
					{
						for( size_t i = 0; i &lt; message.parts(); ++i )
						{
							if( options.annotate ) { std::cout &lt;&lt; "&gt;&gt;: "; }
							std::cout &lt;&lt; message.get(i) &lt;&lt; std::endl;
						}

						if( options.annotate ) { std::cout &lt;&lt; " --- " &lt;&lt; std::endl; }
						else { std::cout &lt;&lt; std::endl; }
					}

					if( !socket.send( message, true ) )
					{
						if( options.detailed )
						{
							if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
							std::cerr &lt;&lt; "Output blocking, waiting to send" &lt;&lt; std::endl;
						}

						if( !socket.send( message ) )
						{
							if( options.annotate ) {	std::cerr &lt;&lt; "!!: "; }

							std::cerr &lt;&lt; "Send failed, socket would have blocked" &lt;&lt; std::endl;

							zmqpp::message tmp;
							std::swap( tmp, message );
						}
					}

					if (toggles)
					{
						can_recv = true;
						can_send = false;
						if( options.detailed )
						{
							if( options.annotate ) { std::cerr &lt;&lt; "**: " &lt;&lt; std::endl; }
							std::cerr &lt;&lt; "Toggling to receive enabled" &lt;&lt; std::endl;
						}
					}
				}
			}
			else if( (standardin &gt;= 0) &amp;&amp; can_send &amp;&amp; !can_recv )
			{
				if( options.detailed )
				{
					if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
					std::cerr &lt;&lt; "No data on stdin, exiting reader." &lt;&lt; std::endl;
				}
				break;
			}
		}
		else if( options.detailed )
		{
			if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
			std::cerr &lt;&lt; "Poller returned with no data, possibly an interrupt." &lt;&lt; std::endl;
		}
	}

	if( options.detailed )
	{
		if( options.annotate ) { std::cerr &lt;&lt; "**: "; }
		std::cerr &lt;&lt; "Exited reader, shutting down." &lt;&lt; std::endl;
	}

	return EXIT_SUCCESS;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
