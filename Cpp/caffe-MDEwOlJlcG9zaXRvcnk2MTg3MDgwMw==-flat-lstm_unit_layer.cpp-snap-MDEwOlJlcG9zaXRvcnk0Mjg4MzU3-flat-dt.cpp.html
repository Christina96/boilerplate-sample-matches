
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1800391389432483%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lstm_unit_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cmath>
3  #include <vector>
4  #include "caffe/layer.hpp"
5  #include "caffe/layers/lstm_layer.hpp"
6  namespace caffe {
7  template <typename Dtype>
8  inline Dtype sigmoid(Dtype x) {
9    return 1. / (1. + exp(-x));
10  }
11  template <typename Dtype>
12  inline Dtype tanh(Dtype x) {
13    return 2. * sigmoid(2. * x) - 1.;
14  }
15  template <typename Dtype>
16  void LSTMUnitLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
17      const vector<Blob<Dtype>*>& top) {
18    const int num_instances = bottom[0]->shape(1);
19    for (int i = 0; i < bottom.size(); ++i) {
20      if (i == 2) {
21        CHECK_EQ(2, bottom[i]->num_axes());
22      } else {
23        CHECK_EQ(3, bottom[i]->num_axes());
24      }
25      CHECK_EQ(1, bottom[i]->shape(0));
26      CHECK_EQ(num_instances, bottom[i]->shape(1));
27    }
28    hidden_dim_ = bottom[0]->shape(2);
29    CHECK_EQ(num_instances, bottom[1]->shape(1));
30    CHECK_EQ(4 * hidden_dim_, bottom[1]->shape(2));
31    top[0]->ReshapeLike(*bottom[0]);
32    top[1]->ReshapeLike(*bottom[0]);
33    X_acts_.ReshapeLike(*bottom[1]);
34  }
35  template <typename Dtype>
36  void LSTMUnitLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
37      const vector<Blob<Dtype>*>& top) {
38    const int num = bottom[0]->shape(1);
39    const int x_dim = hidden_dim_ * 4;
40    const Dtype* C_prev = bottom[0]->cpu_data();
41    const Dtype* X = bottom[1]->cpu_data();
42    const Dtype* cont = bottom[2]->cpu_data();
43    Dtype* C = top[0]->mutable_cpu_data();
44    Dtype* H = top[1]->mutable_cpu_data();
45    for (int n = 0; n < num; ++n) {
46      for (int d = 0; d < hidden_dim_; ++d) {
47        const Dtype i = sigmoid(X[d]);
48        const Dtype f = (*cont == 0) ? 0 :
49            (*cont * sigmoid(X[1 * hidden_dim_ + d]));
50        const Dtype o = sigmoid(X[2 * hidden_dim_ + d]);
51        const Dtype g = tanh(X[3 * hidden_dim_ + d]);
52        const Dtype c_prev = C_prev[d];
53        const Dtype c = f * c_prev + i * g;
54        C[d] = c;
55        const Dtype tanh_c = tanh(c);
56        H[d] = o * tanh_c;
57      }
58      C_prev += hidden_dim_;
59      X += x_dim;
60      C += hidden_dim_;
61      H += hidden_dim_;
62      ++cont;
63    }
64  }
65  template <typename Dtype>
66  void LSTMUnitLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
67      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
68    CHECK(!propagate_down[2]) << "Cannot backpropagate to sequence indicators.";
69    if (!propagate_down[0] && !propagate_down[1]) { return; }
70    const int num = bottom[0]->shape(1);
71    const int x_dim = hidden_dim_ * 4;
72    const Dtype* C_prev = bottom[0]->cpu_data();
73    const Dtype* X = bottom[1]->cpu_data();
74    const Dtype* cont = bottom[2]->cpu_data();
75    const Dtype* C = top[0]->cpu_data();
76    const Dtype* H = top[1]->cpu_data();
77    const Dtype* C_diff = top[0]->cpu_diff();
78    const Dtype* H_diff = top[1]->cpu_diff();
79    Dtype* C_prev_diff = bottom[0]->mutable_cpu_diff();
80    Dtype* X_diff = bottom[1]->mutable_cpu_diff();
<span onclick='openModal()' class='match'>81    for (int n = 0; n < num; ++n) {
82      for (int d = 0; d < hidden_dim_; ++d) {
</span>83        const Dtype i = sigmoid(X[d]);
84        const Dtype f = (*cont == 0) ? 0 :
85            (*cont * sigmoid(X[1 * hidden_dim_ + d]));
86        const Dtype o = sigmoid(X[2 * hidden_dim_ + d]);
87        const Dtype g = tanh(X[3 * hidden_dim_ + d]);
88        const Dtype c_prev = C_prev[d];
89        const Dtype c = C[d];
90        const Dtype tanh_c = tanh(c);
91        Dtype* c_prev_diff = C_prev_diff + d;
92        Dtype* i_diff = X_diff + d;
93        Dtype* f_diff = X_diff + 1 * hidden_dim_ + d;
94        Dtype* o_diff = X_diff + 2 * hidden_dim_ + d;
95        Dtype* g_diff = X_diff + 3 * hidden_dim_ + d;
96        const Dtype c_term_diff =
97            C_diff[d] + H_diff[d] * o * (1 - tanh_c * tanh_c);
98        *c_prev_diff = c_term_diff * f;
99        *i_diff = c_term_diff * g * i * (1 - i);
100        *f_diff = c_term_diff * c_prev * f * (1 - f);
101        *o_diff = H_diff[d] * tanh_c * o * (1 - o);
102        *g_diff = c_term_diff * i * (1 - g * g);
103      }
104      C_prev += hidden_dim_;
105      X += x_dim;
106      C += hidden_dim_;
107      H += hidden_dim_;
108      C_diff += hidden_dim_;
109      H_diff += hidden_dim_;
110      X_diff += x_dim;
111      C_prev_diff += hidden_dim_;
112      ++cont;
113    }
114  }
115  #ifdef CPU_ONLY
116  STUB_GPU(LSTMUnitLayer);
117  #endif
118  INSTANTIATE_CLASS(LSTMUnitLayer);
119  REGISTER_LAYER_CLASS(LSTMUnit);
120  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</h3>
            <pre><code>1  const int TRnd::RndSeed=0;
2  const int TRnd::a=16807;
3  const int TRnd::m=2147483647;
4  const int TRnd::q=127773; 
5  const int TRnd::r=2836; 
6  void TRnd::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
7    XLoadHd(Nm);
8    Seed=TXmlObjSer::GetIntArg(XmlTok, "Seed");
9  }
10  void TRnd::SaveXml(TSOut& SOut, const TStr& Nm) const {
11    XSaveBETagArg(Nm, "Seed", TInt::GetStr(Seed));
12  }
13  void TRnd::PutSeed(const int& _Seed){
14    Assert(_Seed>=0);
15    if (_Seed==0){
16      Seed=abs(int(TSysTm::GetPerfTimerTicks()));
17    } else {
18      Seed=_Seed;
19    }
20  }
21  void TRnd::Move(const int& Steps){
22    for (int StepN=0; StepN<Steps; StepN++){GetNextSeed();}
23  }
24  bool TRnd::Check(){
25    int PSeed=Seed; Seed=1;
26    for (int SeedN=0; SeedN<10000; SeedN++){GetNextSeed();}
27    bool Ok=Seed==1043618065; Seed=PSeed; return Ok;
28  }
29  int TRnd::GetUniDevInt(const int& Range){
30    int Seed=GetNextSeed();
31    if (Range==0){return Seed;}
32    else {return Seed%Range;}
33  }
34  uint TRnd::GetUniDevUInt(const uint& Range){
35    uint Seed=uint(GetNextSeed()%0x10000)*0x10000+uint(GetNextSeed()%0x10000);
36    if (Range==0){return Seed;}
37    else {return Seed%Range;}
38  }
39  int64 TRnd::GetUniDevInt64(const int64& Range){
40    const int64 RndVal = int64((uint64(GetUniDevInt())<<32) | uint64(GetUniDevInt()));
41    if (Range==0){return RndVal;}
42    else {return RndVal%Range;}
43  }
44  uint64 TRnd::GetUniDevUInt64(const uint64& Range){
45   const uint64 RndVal = uint64((uint64(GetUniDevInt())<<32) | uint64(GetUniDevInt()));
46   if (Range==0){return RndVal;}
47   else {return RndVal%Range;}
48  }
49  double TRnd::GetNrmDev(){
50    double v1, v2, rsq;
51    do {
52      v1=2.0*GetUniDev()-1.0; 
53      v2=2.0*GetUniDev()-1.0; 
54      rsq=v1*v1+v2*v2; 
55    } while ((rsq>=1.0)||(rsq==0.0)); 
56    double fac=sqrt(-2.0*log(rsq)/rsq); 
57    return v1*fac;
58  }
59  double TRnd::GetNrmDev(
60   const double& Mean, const double& SDev, const double& Mn, const double& Mx){
61    double Val=Mean+GetNrmDev()*SDev;
62    if (Val<Mn){Val=Mn;}
63    if (Val>Mx){Val=Mx;}
64    return Val;
65  }
66  double TRnd::GetExpDev(){
67    double UniDev;
68    do {
69      UniDev=GetUniDev();
70    } while (UniDev==0.0);
71    return -log(UniDev);
72  }
73  double TRnd::GetExpDev(const double& Lambda) {
74    return GetExpDev()/Lambda;
75  }
76  double TRnd::GetGammaDev(const int& Order){
77    int j;
78    double am,e,s,v1,v2,x,y;
79    if (Order<1){Fail;}
80    if (Order<6) {
81      x=1.0;
82      for (j=1;j<=Order;j++) x *=GetUniDev();
83      x = -log(x);
84    } else {
85      do {
86        do {
87          do {
88            v1=2.0*GetUniDev()-1.0;
89            v2=2.0*GetUniDev()-1.0;
90          } while (v1*v1+v2*v2 > 1.0);
91          y=v2/v1;
92          am=Order-1;
93          s=sqrt(2.0*am+1.0);
94          x=s*y+am;
95        } while (x <= 0.0);
96        e=(1.0+y*y)*exp(am*log(x/am)-s*y);
97      } while (GetUniDev()>e);
98    }
99    return x;
100  }
101  double TRnd::GetPoissonDev(const double& Mean){
102    static double sq,alxm,g,oldm=(-1.0);
103    double em,t,y;
104    if (Mean < 12.0) {
105      if (Mean != oldm) {
106        oldm=Mean;
107        g=exp(-Mean);
108      }
109      em = -1;
110      t=1.0;
111      do {
112        ++em;
113        t *= GetUniDev();
114      } while (t>g);
115    } else {
116      if (Mean != oldm) {
117        oldm=Mean;
118        sq=sqrt(2.0*Mean);
119        alxm=log(Mean);
120        g=Mean*alxm-TSpecFunc::LnGamma(Mean+1.0);
121      }
122      do {
123        do {
124          y=tan(TMath::Pi*GetUniDev());
125          em=sq*y+Mean;
126        } while (em < 0.0);
127        em=floor(em);
128        t=0.9*(1.0+y*y)*exp(em*alxm-TSpecFunc::LnGamma(em+1.0)-g);
129      } while (GetUniDev()>t);
130    }
131    return em;
132  }
133  double TRnd::GetBinomialDev(const double& Prb, const int& Trials){
134    int j;
135    static int nold=(-1);
136    double am,em,g,angle,p,bnl,sq,t,y;
137    static double pold=(-1.0),pc,plog,pclog,en,oldg;
138    p=(Prb <= 0.5 ? Prb : 1.0-Prb);
139    am=Trials*p;
140    if (Trials < 25) {
141      bnl=0.0;
142      for (j=1;j<=Trials;j++)
143        if (GetUniDev() < p) ++bnl;
144    } else if (am < 1.0) {
145      g=exp(-am);
146      t=1.0;
147      for (j=0;j<=Trials;j++) {
148        t *= GetUniDev();
149        if (t < g) break;
150      }
151      bnl=(j <= Trials ? j : Trials);
152    } else {
153      if (Trials != nold) {
154        en=Trials;
155        oldg=TSpecFunc::LnGamma(en+1.0);
156        nold=Trials;
157      } if (p != pold) {
158        pc=1.0-p;
159        plog=log(p);
160        pclog=log(pc);
161        pold=p;
162      }
163      sq=sqrt(2.0*am*pc);
164      do {
165        do {
166          angle=TMath::Pi*GetUniDev();
167          y=tan(angle);
168          em=sq*y+am;
169        } while (em < 0.0 || em >= (en+1.0));
170        em=floor(em);
171        t=1.2*sq*(1.0+y*y)*exp(oldg-(em+1.0)
172          -TSpecFunc::LnGamma(en-em+1.0)+em*plog+(en-em)*pclog);
173      } while (GetUniDev() > t);
174      bnl=em;
175    }
176    if (p != Prb) bnl=Trials-bnl;
177    return bnl;
178  }
179  TRnd TRnd::LoadTxt(TILx& Lx){
180    return TRnd(Lx.GetInt());
181  }
182  void TRnd::SaveTxt(TOLx& Lx) const {
183    Lx.PutInt(Seed);
184  }
185  void TMem::Resize(const int& _MxBfL){
186    if (_MxBfL<=MxBfL){return;}
187    else {if (MxBfL*2<_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
188    char* NewBf=new char[MxBfL]; IAssert(NewBf!=NULL);
189    if (BfL>0){memcpy(NewBf, Bf, BfL);}
190    if (Bf!=NULL){delete[] Bf;}
191    Bf=NewBf;
192  }
193  TMem::TMem(const TStr& Str):
194    MxBfL(Str.Len()), BfL(MxBfL), Bf(NULL){
195    if (MxBfL>0){
196      Bf=new char[MxBfL];
197      if (BfL>0){memcpy(Bf, Str.CStr(), BfL);}
198    }
199  }
200  void TMem::SaveXml(TSOut& SOut, const TStr& Nm) const {
201    XSaveHdArg(Nm, "BfL", TInt::GetStr(BfL));
202    SOut.PutStr(TXmlLx::GetXmlStrFromPlainMem(*this));
203  }
204  bool TMem::DoFitStr(const TStr& Str) const {
205    return DoFitLen(Str.Len()+1);
206  }
207  TMem& TMem::operator+=(const char& Ch){
208    if (BfL==MxBfL){Resize(BfL+1);}
209    Bf[BfL]=Ch; BfL++; return *this;
210  }
211  TMem& TMem::operator+=(const TMem& Mem){
212    int LBfL=Mem.Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
213    if (LBfL>0){memcpy(&Bf[BfL], Mem(), LBfL);}
214    BfL+=LBfL; return *this;
215  }
216  TMem& TMem::operator+=(const TStr& Str){
217    int LBfL=Str.Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
218    if (LBfL>0){memcpy(Bf+BfL, Str.CStr(), LBfL);}
219    BfL+=LBfL; return *this;
220  }
221  TMem& TMem::operator+=(const PSIn& SIn){
222    int LBfL=SIn->Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
223    char* LBf=new char[LBfL];
224    SIn->GetBf(LBf, LBfL);
225    if (LBfL>0){memcpy(Bf+BfL, LBf, LBfL);}
226    delete[] LBf;
227    BfL+=LBfL; return *this;
228  }
229  void TMem::Del(const int& BChN, const int& EChN){
230    if (BChN>EChN){return;}
231    if ((BChN==0)&&(EChN==BfL-1)){Clr(); return;}
232    IAssert((0<=BChN)&&(BChN<=EChN)&&(EChN<BfL));
233    memmove(Bf+BChN, Bf+EChN+1, BfL-EChN-1);
234    BfL-=(EChN-BChN+1);
235  }
236  void TMem::AddBf(const void* _Bf, const int& _BfL){
237  	IAssert((_BfL>=0) && (_Bf != NULL));
238    Reserve(Len() + _BfL, false);
239    memcpy(Bf + BfL, _Bf, _BfL);  
240     BfL+=_BfL;
241  }
242  TStr TMem::GetAsStr(const char& NewNullCh) const {
243    if (NewNullCh!='\0'){
244      TChA ChA(*this);
245      ChA.ChangeCh('\0', NewNullCh);
246      return ChA;
247    } else {
248      return TStr(*this);
249    }
250  }
251  TMemIn::TMemIn(const TMem& _Mem, const int& _BfC):
252    TSBase("Input-Memory"), TSIn("Input-Memory"), Mem(), Bf(_Mem()), BfC(_BfC), BfL(_Mem.Len()){}
253  int TMemIn::GetBf(const void* LBf, const TSize& LBfL){
254    Assert(TSize(BfC+LBfL)<=TSize(BfL));
255    int LBfS=0;
256    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
257      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
258    return LBfS;
259  }
260  bool TMemIn::GetNextLnBf(TChA& LnChA){
261    FailR(TStr::Fmt("TMemIn::GetNextLnBf: not implemented").CStr());
262    return false;
263  }
264  TMemOut::TMemOut(const PMem& _Mem): TSBase("Output-Memory"), TSOut("Output-Memory"), Mem(_Mem){}
265  int TMemOut::PutBf(const void* LBf, const TSize& LBfL){
266    int LBfS=0;
267    TMem& _Mem=*Mem;
268    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
269      char Ch=((char*)LBf)[LBfC];
270      LBfS+=Ch; _Mem+=Ch;
271    }
272    return LBfS;
273  }
274  void TChA::Resize(const int& _MxBfL){
275    if (_MxBfL<=MxBfL){return;}
276    else {if (MxBfL*2<_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
277    char* NewBf=new char[MxBfL+1]; IAssert(NewBf!=NULL);
278    strcpy(NewBf, Bf);
279    delete[] Bf; Bf=NewBf;
280  }
281  TChA::TChA(const TStr& Str){
282    Bf=new char[(MxBfL=BfL=Str.Len())+1];
283    strcpy(Bf, Str.CStr());
284  }
285  void TChA::SaveXml(TSOut& SOut, const TStr& Nm) const {
286    XSaveHdArg(Nm, "BfL", TInt::GetStr(BfL));
287    SOut.PutStr(TXmlLx::GetXmlStrFromPlainStr(*this));
288  }
289  TChA& TChA::operator=(const TChA& ChA){
290    if (this!=&ChA){
291      if (ChA.BfL>MxBfL){delete[] Bf; Bf=new char[(MxBfL=ChA.BfL)+1];}
292      BfL=ChA.BfL; strcpy(Bf, ChA.CStr());
293    }
294    return *this;
295  }
296  TChA& TChA::operator=(const TStr& Str){
297    if (Str.Len()>MxBfL){delete[] Bf; Bf=new char[(MxBfL=Str.Len())+1];}
298    BfL=Str.Len(); strcpy(Bf, Str.CStr());
299    return *this;
300  }
301  TChA& TChA::operator=(const char* CStr){
302    int CStrLen=int(strlen(CStr));
303    if (CStrLen>MxBfL){delete[] Bf; Bf=new char[(MxBfL=CStrLen)+1];}
304    BfL=CStrLen; strcpy(Bf, CStr);
305    return *this;
306  }
307  TChA& TChA::operator+=(const TMem& Mem) {
308    Resize(BfL+Mem.Len());
309    strcpy(Bf+BfL, Mem.GetBf()); BfL+=Mem.Len(); return *this;
310  }
311  TChA& TChA::operator+=(const TChA& ChA){
312    Resize(BfL+ChA.Len());
313    strcpy(Bf+BfL, ChA.CStr()); BfL+=ChA.Len(); return *this;
314  }
315  TChA& TChA::operator+=(const TStr& Str){
316    Resize(BfL+Str.Len());
317    strcpy(Bf+BfL, Str.CStr()); BfL+=Str.Len(); return *this;
318  }
319  TChA& TChA::operator+=(const char* CStr){
320    int CStrLen=(int)strlen(CStr); Resize(BfL+CStrLen);
321    strcpy(Bf+BfL, CStr); BfL+=CStrLen; return *this;
322  }
323  void TChA::Ins(const int& BChN, const char* CStr){
324    Assert((0<=BChN)&&(BChN<=BfL)); /&bsol;** ali je <= v (BChN<=BfL) upravicen?
325    int CStrLen=int(strlen(CStr)); Resize(BfL+CStrLen);
326    memmove(Bf+BChN+CStrLen, Bf+BChN, BfL-BChN+1);
327    memmove(Bf+BChN, CStr, CStrLen); BfL+=CStrLen;
328  }
329  void TChA::Del(const int& ChN){
330    Assert((0<=ChN)&&(ChN<BfL));
331    memmove(Bf+ChN, Bf+ChN+1, BfL-ChN);
332    BfL--;
333  }
334  void TChA::Trunc(){
335    int BChN=0; while ((BChN<BfL)&&(GetCh(BChN)<=' ')){BChN++;}
336    int EChN=BfL-1; while ((0<=EChN)&&(GetCh(EChN)<=' ')){EChN--;}
337    if (BChN<=EChN){
338      for (int ChN=BChN; ChN<=EChN; ChN++){
339        PutCh(ChN-BChN, GetCh(ChN));}
340      Trunc(EChN-BChN+1);
341    } else {
342      Clr();
343    }
344  }
345  void TChA::Reverse(){
346    for (int ChN=0; ChN<BfL/2; ChN++){
347      char Ch=Bf[ChN];
348      Bf[ChN]=Bf[BfL-ChN-1];
349      Bf[BfL-ChN-1]=Ch;
350    }
351  }
352  TChA TChA::GetSubStr(const int& _BChN, const int& _EChN) const {
353    int BChN=TInt::GetMx(_BChN, 0);
354    int EChN=TInt::GetMn(_EChN, Len()-1);
355    int Chs=EChN-BChN+1;
356    if (Chs<=0){return TStr::GetNullStr();}
357    else if (Chs==Len()){return *this;}
358    else {
359      return TChA(CStr()+BChN, Chs);
360    }
361  }
362  int TChA::CountCh(const char& Ch, const int& BChN) const {
363    int ChN=TInt::GetMx(BChN, 0);
364    const int ThisLen=Len();
365    int Cnt = 0;
366    while (ChN<ThisLen){if (Bf[ChN]==Ch){ Cnt++;} ChN++;}
367    return Cnt;
368  }
369  int TChA::SearchCh(const char& Ch, const int& BChN) const {
370    int ChN=TInt::GetMx(BChN, 0);
371    const int ThisLen=Len();
372    while (ChN<ThisLen){if (Bf[ChN]==Ch){return ChN;} ChN++;}
373    return -1;
374  }
375  int TChA::SearchChBack(const char& Ch, int BChN) const {
376    if (BChN >= Len() || BChN < 0) { BChN = Len()-1; }
377    for (int i = BChN; i >= 0; i--) {
378      if (GetCh(i) == Ch) { return i; }
379    }
380    return -1;
381  }
382  int TChA::SearchStr(const TChA& Str, const int& BChN) const {
383    return SearchStr(Str.CStr(), BChN);
384  }
385  int TChA::SearchStr(const TStr& Str, const int& BChN) const {
386    return SearchStr(Str.CStr(), BChN);
387  }
388  int TChA::SearchStr(const char* CStr, const int& BChN) const {
389    const char* BegPos=strstr(Bf+BChN, CStr);
390    if (BegPos==NULL){return -1;}
391    else {return int(BegPos-Bf);}
392  }
393  bool TChA::IsPrefix(const char* CStr, const int& BChN) const {
394    if (BChN+(int)strlen(CStr)>Len()){return false;}
395    const char* B = Bf+BChN;
396    const char* C = CStr;
397    while (*C!=0 && *B==*C) {
398      B++; C++;
399    }
400    if (*C==0){return true;}
401    else {return false;}
402  }
403  bool TChA::IsPrefix(const TStr& Str) const {
404    return IsPrefix(Str.CStr());
405  }
406  bool TChA::IsPrefix(const TChA& Str) const {
407    return IsPrefix(Str.CStr());
408  }
409  bool TChA::IsSuffix(const char* CStr) const {
410    if ((int)strlen(CStr) > Len()) { return false; }
411    const char* E = Bf+Len()-1;
412    const char* C = CStr+strlen(CStr)-1;
413    while (C >= CStr && *E==*C) {
414      E--;  C--;
415    }
416    if (C+1 == CStr) { return true; }
417    else { return false; }
418  }
419  bool TChA::IsSuffix(const TStr& Str) const {
420    return IsSuffix(Str.CStr());
421  }
422  bool TChA::IsSuffix(const TChA& Str) const {
423    return IsSuffix(Str.CStr());
424  }
425  void TChA::ChangeCh(const char& SrcCh, const char& DstCh){
426    int StrLen=Len();
427    for (int ChN=0; ChN<StrLen; ChN++){if (Bf[ChN]==SrcCh){Bf[ChN]=DstCh;}}
428  }
429  TChA& TChA::ToLc() {
430    char *c = Bf;
431    while (*c) {
432      *c = (char) tolower(*c);  c++;
433    }
434    return *this;
435  }
436  TChA& TChA::ToUc() {
437    char *c = Bf;
438    while (*c) {
439      *c = (char) toupper(*c); c++;
440    }
441    return *this;
442  }
443  TChA& TChA::ToTrunc(){
444    int StrLen=Len(); int BChN=0; int EChN=StrLen-1;
445    while ((BChN<StrLen)&&TCh::IsWs(GetCh(BChN))){BChN++;}
446    while ((EChN>=0)&&TCh::IsWs(GetCh(EChN))){EChN--;}
447    if ((BChN!=0)||(EChN!=StrLen-1)){
448      int DstChN=0;
449      for (int SrcChN=BChN; SrcChN<=EChN; SrcChN++){
450        PutCh(DstChN, GetCh(SrcChN)); DstChN++;}
451      Trunc(DstChN);
452    }
453    return *this;
454  }
455  void TChA::CompressWs(){
456    int StrLen=Len(); int SrcChN=0; int DstChN=0;
457    while ((SrcChN<StrLen)&&TCh::IsWs(GetCh(SrcChN))){SrcChN++;}
458    while (SrcChN<StrLen){
459      if ((TCh::IsWs(GetCh(SrcChN)))&&(DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){
460        SrcChN++;
461      } else {
462        PutCh(DstChN, GetCh(SrcChN)); SrcChN++; DstChN++;
463      }
464    }
465    if ((DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){DstChN--;}
466    Trunc(DstChN);
467  }
468  void TChA::Swap(const int& ChN1, const int& ChN2){
469    char Ch=GetCh(ChN1);
470    PutCh(ChN1, GetCh(ChN2));
471    PutCh(ChN2, Ch);
472  }
473  void TChA::Swap(TChA& ChA) {
474    ::Swap(MxBfL, ChA.MxBfL);
475    ::Swap(BfL, ChA.BfL);
476    ::Swap(Bf, ChA.Bf);
477  }
478  int TChA::GetPrimHashCd() const {
479    return TStrHashF_DJB::GetPrimHashCd(CStr());
480  }
481  int TChA::GetSecHashCd() const {
482    return TStrHashF_DJB::GetSecHashCd(CStr());
483  }
484  void TChA::LoadTxt(const PSIn& SIn, TChA& ChA){
485    delete[] ChA.Bf;
486    ChA.Bf=new char[(ChA.MxBfL=ChA.BfL=SIn->Len())+1];
487    SIn->GetBf(ChA.CStr(), SIn->Len()); ChA.Bf[ChA.BfL]=0;
488  }
489  void TChA::SaveTxt(const PSOut& SOut) const {
490    SOut->SaveBf(CStr(), Len());
491  }
492  TChAIn::TChAIn(const TChA& ChA, const int& _BfC):
493    TSBase("Input-Char-Array"), TSIn("Input-Char-Array"), Bf(ChA.CStr()), BfC(_BfC), BfL(ChA.Len()){}
494  int TChAIn::GetBf(const void* LBf, const TSize& LBfL){
495    Assert(TSize(BfC+LBfL)<=TSize(BfL));
496    int LBfS=0;
497    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
498      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
499    return LBfS;
500  }
501  bool TChAIn::GetNextLnBf(TChA& LnChA){
502    FailR(TStr::Fmt("TChAIn::GetNextLnBf: not implemented").CStr());
503    return false;
504  }
505  bool TRStr::IsUc() const {
506    int StrLen=Len();
507    for (int ChN=0; ChN<StrLen; ChN++){
508      if (('a'<=Bf[ChN])&&(Bf[ChN]<='z')){return false;}}
509    return true;
510  }
511  void TRStr::ToUc(){
512    int StrLen=Len();
513    for (int ChN=0; ChN<StrLen; ChN++){
514      Bf[ChN]=(char)toupper(Bf[ChN]);}}
515  bool TRStr::IsLc() const {
516    int StrLen=Len();
517    for (int ChN=0; ChN<StrLen; ChN++){
518      if (('A'<=Bf[ChN])&&(Bf[ChN]<='Z')){return false;}}
519    return true;
520  }
521  void TRStr::ToLc(){
522    int StrLen=Len();
523    for (int ChN=0; ChN<StrLen; ChN++){
524      Bf[ChN]=(char)tolower(Bf[ChN]);}
525  }
526  void TRStr::ToCap(){
527    int StrLen=Len();
528    if (StrLen>0){
529      Bf[0]=(char)toupper(Bf[0]);}
530    for (int ChN=1; ChN<StrLen; ChN++){
531      Bf[ChN]=(char)tolower(Bf[ChN]);}
532  }
533  void TRStr::ConvUsFromYuAscii(){
534    int StrLen=Len();
535    for (int ChN=0; ChN<StrLen; ChN++){
536      Bf[ChN]=TCh::GetUsFromYuAscii(Bf[ChN]);}
537  }
538  int TRStr::CmpI(const char* p, const char* r){
539    if (!p){return r ? (*r ? -1 : 0) : 0;}
540    if (!r){return (*p ? 1 : 0);}
541    while (*p && *r){
542      int i=int(toupper(*p++))-int(toupper(*r++));
543      if (i!=0){return i;}
544    }
545    return int(toupper(*p++))-int(toupper(*r++));
546  }
547  int TRStr::GetPrimHashCd() const {
548    return TStrHashF_DJB::GetPrimHashCd(Bf);
549  }
550  int TRStr::GetSecHashCd() const {
551    return TStrHashF_DJB::GetSecHashCd(Bf);
552  }
553  TRStr* TStr::GetRStr(const char* CStr){
554    int CStrLen;
555    if (CStr==NULL){CStrLen=0;} else {CStrLen=int(strlen(CStr));}
556    if (CStrLen==0){return TRStr::GetNullRStr();}
557    else {return new TRStr(CStr);}
558  }
559  void TStr::Optimize(){
560    char* CStr=RStr->CStr(); int CStrLen=int(strlen(CStr));
561    TRStr* NewRStr;
562    if (CStrLen==0){NewRStr=TRStr::GetNullRStr();}
563    else {NewRStr=RStr;}
564    NewRStr->MkRef(); RStr->UnRef(); RStr=NewRStr;
565  }
566  void TStr::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
567    XLoadHd(Nm);
568    TStr TokStr=XmlTok->GetTokStr(false);
569    operator=(TokStr);
570  }
571  void TStr::SaveXml(TSOut& SOut, const TStr& Nm) const {
572    TStr XmlStr=TXmlLx::GetXmlStrFromPlainStr(*this);
573    if (XmlStr.Empty()){XSaveBETag(Nm);}
574    else {XSaveHd(Nm); SOut.PutStr(XmlStr);}
575  }
576  TStr& TStr::ToUc(){
577    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToUc();
578    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
579    Optimize(); return *this;
580  }
581  TStr& TStr::ToLc(){
582    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToLc();
583    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
584    Optimize(); return *this;
585  }
586  TStr& TStr::ToCap(){
587    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToCap();
588    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
589    Optimize(); return *this;
590  }
591  TStr& TStr::ToTrunc(){
592    int ThisLen=Len(); char* ThisBf=CStr();
593    int BChN=0; int EChN=ThisLen-1;
594    while ((BChN<ThisLen)&&TCh::IsWs(ThisBf[BChN])){BChN++;}
595    while ((EChN>=0)&&TCh::IsWs(ThisBf[EChN])){EChN--;}
596    *this=GetSubStr(BChN, EChN);
597    return *this;
598  }
599  TStr& TStr::ConvUsFromYuAscii(){
600    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ConvUsFromYuAscii();
601    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
602    Optimize(); return *this;
603  }
604  TStr& TStr::ToHex(){
605    TChA ChA;
606    int StrLen=Len();
607    for (int ChN=0; ChN<StrLen; ChN++){
608      uchar Ch=uchar(RStr->Bf[ChN]);
609      char MshCh=TCh::GetHexCh((Ch/16)%16);
610      char LshCh=TCh::GetHexCh(Ch%16);
611      ChA+=MshCh; ChA+=LshCh;
612    }
613    *this=ChA;
614    return *this;
615  }
616  TStr& TStr::FromHex(){
617    int StrLen=Len(); IAssert(StrLen%2==0);
618    TChA ChA; int ChN=0;
619    while (ChN<StrLen){
620      char MshCh=RStr->Bf[ChN]; ChN++;
621      char LshCh=RStr->Bf[ChN]; ChN++;
622      uchar Ch=uchar(TCh::GetHex(MshCh)*16+TCh::GetHex(LshCh));
623      ChA+=Ch;
624    }
625    *this=ChA;
626    return *this;
627  }
628  TStr TStr::GetSubStr(const int& _BChN, const int& _EChN) const {
629    int StrLen=Len();
630    int BChN=TInt::GetMx(_BChN, 0);
631    int EChN=TInt::GetMn(_EChN, StrLen-1);
632    int Chs=EChN-BChN+1;
633    if (Chs<=0){return TStr();}
634    else if (Chs==StrLen){return *this;}
635    else {
636      char* Bf=new char[Chs+1]; strncpy(Bf, CStr()+BChN, Chs); Bf[Chs]=0;
637      TStr Str(Bf); delete[] Bf;
638      return Str;
639    }
640  }
641  void TStr::InsStr(const int& BChN, const TStr& Str){
642    int ThisLen=Len();
643    IAssert((0<=BChN)&&(BChN<=ThisLen));
644    TStr NewStr;
645    if (BChN==0){
646      NewStr=Str+*this;
647    } else
648    if (BChN==ThisLen){
649      NewStr=*this+Str;
650    } else {
651      NewStr=GetSubStr(0, BChN-1)+Str+GetSubStr(BChN, ThisLen-1);
652    }
653    *this=NewStr;
654  }
655  void TStr::DelChAll(const char& Ch){
656    TChA ChA(*this);
657    int ChN=ChA.SearchCh(Ch);
658    while (ChN!=-1){
659      ChA.Del(ChN);
660      ChN=ChA.SearchCh(Ch);
661    }
662    *this=ChA;
663  }
664  void TStr::DelSubStr(const int& _BChN, const int& _EChN){
665    int BChN=TInt::GetMx(_BChN, 0);
666    int EChN=TInt::GetMn(_EChN, Len()-1);
667    int Chs=Len()-(EChN-BChN+1);
668    if (Chs==0){Clr();}
669    else if (Chs<Len()){
670      char* Bf=new char[Chs+1]; strncpy(Bf, CStr(), BChN);
671      strncpy(Bf+BChN, CStr()+EChN+1, Len()-EChN-1); Bf[Chs]=0;
672      TStr Str(Bf); delete[] Bf;
673      *this=Str;
674    }
675  }
676  bool TStr::DelStr(const TStr& Str){
677    int ChN=SearchStr(Str);
678    if (ChN==-1){
679      return false;
680    } else {
681      DelSubStr(ChN, ChN+Str.Len()-1);
682      return true;
683    }
684  }
685  TStr TStr::LeftOf(const char& SplitCh) const {
686    int ThisLen=Len(); const char* ThisBf=CStr();
687    int ChN=0;
688    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
689    return (ChN==ThisLen) ? "" : GetSubStr(0, ChN-1);
690  }
691  TStr TStr::LeftOfLast(const char& SplitCh) const {
692    const char* ThisBf=CStr();
693    int ChN=Len()-1;
694    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
695    return (ChN==-1) ? "" : GetSubStr(0, ChN-1);
696  }
697  TStr TStr::RightOf(const char& SplitCh) const {
698    int ThisLen=Len(); const char* ThisBf=CStr();
699    int ChN=0;
700    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
701    return (ChN==ThisLen) ? "" : GetSubStr(ChN+1, ThisLen-1);
702  }
703  TStr TStr::RightOfLast(const char& SplitCh) const {
704    int ThisLen=Len(); const char* ThisBf=CStr();
705    int ChN=Len()-1;
706    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
707    return (ChN==-1) ? "" : GetSubStr(ChN+1, ThisLen-1);
708  }
709  void TStr::SplitOnCh(TStr& LStr, const char& SplitCh, TStr& RStr) const {
710    int ThisLen=Len(); const char* ThisBf=CStr();
711    int ChN=0;
712    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
713    if (ChN==ThisLen){
714      LStr=GetSubStr(0, ThisLen-1); RStr="";
715    } else {
716      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
717    }
718  }
719  void TStr::SplitOnLastCh(TStr& LStr, const char& SplitCh, TStr& RStr) const {
720    int ThisLen=Len(); const char* ThisBf=CStr();
721    int ChN=Len()-1;
722    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
723    if (ChN==-1){
724      LStr=""; RStr=*this;
725    } else
726    if (ChN==0){
727      LStr=""; RStr=GetSubStr(1, ThisLen-1);
728    } else {
729      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
730    }
731  }
732  void TStr::SplitOnAllCh(
733   const char& SplitCh, TStrV& StrV, const bool& SkipEmpty) const {
734    StrV.Clr();
735    char* Bf=new char[Len()+1];
736    strcpy(Bf, CStr());
737    char* CurStrBf=Bf;
738    forever{
739      char* BfC=CurStrBf;
740      while ((*BfC!=0)&&(*BfC!=SplitCh)){BfC++;}
741      bool IsEnd=(*BfC=='\0');
742      *BfC=0;
743      if ((BfC>CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
744      if (IsEnd){break;}
745      CurStrBf=BfC+1;
746    }
747    delete[] Bf;
748  }
749  void TStr::SplitOnAllAnyCh(
750   const TStr& SplitChStr, TStrV& StrV, const bool& SkipEmpty) const {
751    StrV.Clr();
752    char* Bf=new char[Len()+1];
753    strcpy(Bf, CStr());
754    char* CurStrBf=Bf; 
755    const char* SplitChBf=SplitChStr.CStr();
756    forever{
757      char* BfC=CurStrBf; 
758      while (*BfC!=0){
759        const char* SplitChBfC=SplitChBf; 
760        while ((*SplitChBfC!=0)&&(*SplitChBfC!=*BfC)){SplitChBfC++;}
761        if (*SplitChBfC!=0){break;} 
762        BfC++;
763      }
764      bool IsEnd=(*BfC==0);
765      *BfC=0;
766      if ((BfC>CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
767      if (IsEnd){break;}
768      CurStrBf=BfC+1;
769    }
770    delete[] Bf;
771  }
772  void TStr::SplitOnWs(TStrV& StrV) const {
773    StrV.Clr();
774    char* Bf=new char[Len()+1];
775    strcpy(Bf, CStr());
776    char* StrBf=Bf;
777    forever{
778      while ((*StrBf!=0)&&(TCh::IsWs(*StrBf))){StrBf++;}
779      char* BfC=StrBf;
780      while ((*BfC!=0)&&(!TCh::IsWs(*BfC))){BfC++;}
781      bool IsEnd=(*BfC=='\0');
782      *BfC=0;
783      if (BfC>StrBf){StrV.Add(TStr(StrBf));}
784      if (IsEnd){break;}
785      StrBf=BfC+1;
786    }
787    delete[] Bf;
788  }
789  void TStr::SplitOnNonAlNum(TStrV& StrV) const {
790    StrV.Clr();
791    char* Bf=new char[Len()+1];
792    strcpy(Bf, CStr());
793    char* StrBf=Bf;
794    forever{
795      while ((*StrBf!=0)&&(!TCh::IsAlNum(*StrBf))){StrBf++;}
796      char* BfC=StrBf;
797      while ((*BfC!=0)&&(TCh::IsAlNum(*BfC))){BfC++;}
798      bool IsEnd=(*BfC=='\0');
799      *BfC=0;
800      if (BfC>StrBf){StrV.Add(TStr(StrBf));}
801      if (IsEnd){break;}
802      StrBf=BfC+1;
803    }
804    delete[] Bf;
805  }
806  void TStr::SplitOnStr(const TStr& SplitStr, TStrV& StrV) const {
807    StrV.Clr();
808    int SplitStrLen=SplitStr.Len();
809    int PrevChN=0; int ChN=0;
810    while ((ChN=SearchStr(SplitStr, ChN))!=-1){
811      TStr SubStr=GetSubStr(PrevChN, ChN-1);
812      StrV.Add(SubStr);
813      PrevChN=ChN=ChN+SplitStrLen;
814    }
815    TStr LastSubStr=GetSubStr(PrevChN, Len()-1);
816    StrV.Add(LastSubStr);
817  }
818  void TStr::SplitOnStr(TStr& LeftStr, const TStr& MidStr, TStr& RightStr) const {
819    const int ChN=SearchStr(MidStr);
820    if (ChN==-1){
821      LeftStr=*this; RightStr=GetNullStr();
822    } else {
823      LeftStr=GetSubStr(0, ChN-1);
824      RightStr=GetSubStr(ChN+MidStr.Len(), Len()-1);
825    }
826  }
827  int TStr::CountCh(const char& Ch, const int& BChN) const {
828    const int ThisLen=Len();
829    const char* ThisBf=CStr();
830    int Chs=0;
831    for (int ChN=TInt::GetMx(BChN, 0); ChN<ThisLen; ChN++){
832      if (ThisBf[ChN]==Ch){Chs++;}
833    }
834    return Chs;
835  }
836  int TStr::SearchCh(const char& Ch, const int& BChN) const {
837    int ThisLen=Len(); const char* ThisBf=CStr();
838    int ChN=TInt::GetMx(BChN, 0);
839    while (ChN<ThisLen){
840      if (ThisBf[ChN]==Ch){return ChN;}
841      ChN++;
842    }
843    return -1;
844  }
845  int TStr::SearchChBack(const char& Ch, int BChN) const {
846    const int StrLen=Len();
847    if (BChN==-1||BChN>=StrLen){BChN=StrLen-1;}
848    const char* ThisBf=CStr();
849    const char* Pt=ThisBf + BChN;
850    while (Pt>=ThisBf) {
851      if (*Pt==Ch){return (int)(Pt-ThisBf);}
852      Pt--;
853    }
854    return -1;
855  }
856  int TStr::SearchStr(const TStr& Str, const int& BChN) const {
857    int NrBChN=TInt::GetMx(BChN, 0);
858    const char* StrPt=strstr((const char*)CStr()+NrBChN, Str.CStr());
859    if (StrPt==NULL){return -1;}
860    else {return int(StrPt-CStr());}
861  }
862  bool TStr::IsPrefix(const char *Str) const {
863  	size_t len = strlen(Str);
864  	size_t thisLen = Len();
865  	if (len > thisLen) {
866  		return false;
867  	} else {
868          size_t minLen = MIN(len, thisLen);
869  		int cmp = strncmp(Str, RStr->Bf, minLen);
870  		return cmp == 0;
871  	}
872  }
873  bool TStr::IsSuffix(const char *Str) const {
874  	size_t len = strlen(Str);
875  	size_t thisLen = Len();
876  	if (len > thisLen) {
877  		return false;
878  	} else {
879  		const char *ending = RStr->Bf + thisLen - len;
880  		int cmp = strncmp(Str, ending, len);
881  		return cmp == 0;
882  	}
883  }
884  int TStr::ChangeCh(const char& SrcCh, const char& DstCh, const int& BChN){
885    int ChN=SearchCh(SrcCh, BChN);
886    if (ChN!=-1){PutCh(ChN, DstCh);}
887    return ChN;
888  }
889  int TStr::ChangeChAll(const char& SrcCh, const char& DstCh){
890    int FirstChN=SearchCh(SrcCh);
891    if (FirstChN==-1){
892      return 0;
893    } else {
894      TRStr* NewRStr=new TRStr(RStr->CStr());
895      RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
896      char* ThisBf=CStr(); int StrLen=Len(); int Changes=0;
897      for (int ChN=FirstChN; ChN<StrLen; ChN++){
898        if (ThisBf[ChN]==SrcCh){ThisBf[ChN]=DstCh; Changes++;}
899      }
900      Optimize();
901      return Changes;
902    }
903  }
904  int TStr::ChangeStr(const TStr& SrcStr, const TStr& DstStr, const int& BChN){
905    int ChN=SearchStr(SrcStr, BChN);
906    if (ChN==-1){
907      return -1;
908    } else {
909      DelSubStr(ChN, ChN+SrcStr.Len()-1);
910      InsStr(ChN, DstStr);
911      return ChN;
912    }
913  }
914  int TStr::ChangeStrAll(const TStr& SrcStr, const TStr& DstStr, const bool& FromStartP){
915    const int DstStrLen=DstStr.Len();
916    int Changes=0-1; int BChN=0-DstStrLen;
917    do {
918      Changes++;
919      if (FromStartP){BChN=0-DstStrLen;}
920      BChN+=DstStrLen;
921      BChN=ChangeStr(SrcStr, DstStr, BChN);
922    } while (BChN!=-1);
923    return Changes;
924  }
925  bool TStr::IsBool(bool& Val) const {
926    if (operator==("T")){Val=true; return true;}
927    else if (operator==("F")){Val=false; return true;}
928    else {return false;}
929  }
930  bool TStr::IsInt(
931   const bool& Check, const int& MnVal, const int& MxVal, int& Val) const {
932    int _Val=0;
933    bool Minus=false;
934    TChRet Ch(TStrIn::New(*this));
935    while (TCh::IsWs(Ch.GetCh())){}
936    if (Ch()=='+'){Minus=false; Ch.GetCh();}
937    if (Ch()=='-'){Minus=true; Ch.GetCh();}
938    if (!TCh::IsNum(Ch())){return false;}
939    _Val=TCh::GetNum(Ch());
940    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
941    if (Minus){_Val=-_Val;}
942    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
943    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
944  }
945  bool TStr::IsUInt(
946   const bool& Check, const uint& MnVal, const uint& MxVal, uint& Val) const {
947    uint _Val=0;
948    TChRet Ch(TStrIn::New(*this));
949    while (TCh::IsWs(Ch.GetCh())){}
950    if (Ch()=='+'){Ch.GetCh();}
951    if (!TCh::IsNum(Ch())){return false;}
952    _Val=TCh::GetNum(Ch());
953    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
954    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
955    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
956  }
957  bool TStr::IsHexInt( const bool& Check, const int& MnVal, const int& MxVal, int& Val) const {
958    int _Val=0;
959    bool Minus=false;
960    TChRet Ch(TStrIn::New(*this));
961    while (TCh::IsWs(Ch.GetCh())){}
962    if (Ch()=='+'){Minus=false; Ch.GetCh();}
963    if (Ch()=='-'){Minus=true; Ch.GetCh();}
964    if (Ch()=='0'){
965      Ch.GetCh();
966      if (tolower(Ch())=='x' ){
967        Ch.GetCh(); if (Ch.Eof()){return false;}
968      }
969    }
970    if (!Ch.Eof() && !TCh::IsHex(Ch())){return false;}
971    if (!Ch.Eof()) _Val = TCh::GetHex(Ch());
972    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
973    if (Minus){_Val=-_Val;}
974    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
975    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
976  }
977  bool TStr::IsInt64(
978   const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const {
979    int64 _Val=0;
980    bool Minus=false;
981    TChRet Ch(TStrIn::New(*this));
982    while (TCh::IsWs(Ch.GetCh())){}
983    if (Ch()=='+'){Minus=false; Ch.GetCh();}
984    if (Ch()=='-'){Minus=true; Ch.GetCh();}
985    if (!TCh::IsNum(Ch())){return false;}
986    _Val=TCh::GetNum(Ch());
987    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
988    if (Minus){_Val=-_Val;}
989    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
990    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
991  }
992  bool TStr::IsUInt64(
993   const bool& Check, const uint64& MnVal, const uint64& MxVal, uint64& Val) const {
994    uint64 _Val=0;
995    TChRet Ch(TStrIn::New(*this));
996    while (TCh::IsWs(Ch.GetCh())){}
997    if (Ch()=='+'){Ch.GetCh();}
998    if (!TCh::IsNum(Ch())){return false;}
999    _Val=TCh::GetNum(Ch());
1000    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
1001    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
1002    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1003  }
1004  bool TStr::IsHexInt64(
1005   const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const {
1006    int64 _Val=0;
1007    bool Minus=false;
1008    TChRet Ch(TStrIn::New(*this));
1009    while (TCh::IsWs(Ch.GetCh())){}
1010    if (Ch()=='+'){Minus=false; Ch.GetCh();}
1011    if (Ch()=='-'){Minus=true; Ch.GetCh();}
1012    if (Ch()=='0'){
1013      Ch.GetCh();
1014      if (tolower(Ch())=='x' ){
1015        Ch.GetCh(); if (Ch.Eof()){return false;}
1016      }
1017    }
1018    if (!Ch.Eof()) _Val=TCh::GetHex(Ch());
1019    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
1020    if (Minus){_Val=-_Val;}
1021    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
1022    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1023  }
1024  bool TStr::IsFlt(const bool& Check, const double& MnVal, const double& MxVal,
1025   double& Val, const char& DecDelimCh) const {
1026    TChRet Ch(TStrIn::New(*this));
1027    while (TCh::IsWs(Ch.GetCh())){}
1028    if ((Ch()=='+')||(Ch()=='-')){Ch.GetCh();}
1029    if (!TCh::IsNum(Ch())&&Ch()!=DecDelimCh){return false;}
1030    while (TCh::IsNum(Ch.GetCh())){}
1031    if (Ch()==DecDelimCh){
1032      Ch.GetCh();
1033      while (TCh::IsNum(Ch.GetCh())){}
1034    }
1035    if ((Ch()=='e')||(Ch()=='E')){
1036      Ch.GetCh();
1037      if ((Ch()=='+')||(Ch()=='-')){Ch.GetCh();}
1038      if (!TCh::IsNum(Ch())){return false;}
1039      while (TCh::IsNum(Ch.GetCh())){}
1040    }
1041    if (!Ch.Eof()){return false;}
1042    double _Val=atof(CStr());
1043    if (Check&&((_Val<MnVal)||(_Val>MxVal))){
1044      return false;
1045    } else {
1046      Val=_Val; return true;
1047    }
1048  }
1049  bool TStr::IsWord(const bool& WsPrefixP, const bool& FirstUcAllowedP) const {
1050    TChRet Ch(TStrIn::New(*this));
1051    if (WsPrefixP){while (TCh::IsWs(Ch.GetCh())){}}
1052    else {Ch.GetCh();}
1053    if (!TCh::IsAlpha(Ch())){return false;}
1054    else if (!FirstUcAllowedP&&(TCh::IsUc(Ch()))){return false;}
1055    while (TCh::IsAlNum(Ch.GetCh())){}
1056    if (!Ch.Eof()){return false;}
1057    return true;
1058  }
1059  bool TStr::IsWs() const {
1060    TChRet Ch(TStrIn::New(*this));
1061    while (TCh::IsWs(Ch.GetCh())){}
1062    return Ch.Eof();
1063  }
1064  bool TStr::IsWcMatch(
1065   const int& StrBChN, const TStr& WcStr, const int& WcStrBChN, TStrV& StarStrV,
1066   const char& StarCh, const char& QuestCh) const {
1067    int StrLen=Len(); int WcStrLen=WcStr.Len();
1068    int StrChN=StrBChN; int WcStrChN=WcStrBChN;
1069    while ((StrChN<StrLen)&&(WcStrChN<WcStrLen)){
1070      if ((WcStr[WcStrChN]==QuestCh)||(GetCh(StrChN)==WcStr[WcStrChN])){
1071        StrChN++; WcStrChN++;
1072      } else
1073      if (WcStr[WcStrChN]==StarCh){
1074        TChA StarChA; 
1075        for (int AfterStrChN=StrChN; AfterStrChN<=StrLen; AfterStrChN++){
1076          if (AfterStrChN>StrChN){
1077            StarChA+=GetCh(AfterStrChN-1);}
1078          if (IsWcMatch(AfterStrChN, WcStr, WcStrChN+1, StarStrV, StarCh, QuestCh)){
1079            StarStrV.Add(StarChA); return true;
1080          }
1081        }
1082        return false;
1083      } else {
1084        return false;
1085      }
1086    }
1087    if (StrChN==StrLen){
1088      for (int AfterWcStrChN=WcStrChN; AfterWcStrChN<WcStrLen; AfterWcStrChN++){
1089        if (WcStr[AfterWcStrChN]!=StarCh){return false;}}
1090      return true;
1091    } else {
1092      return false;
1093    }
1094  }
1095  bool TStr::IsWcMatch(
1096   const TStr& WcStr, TStrV& StarStrV, const char& StarCh, const char& QuestCh) const {
1097    bool WcMatch=IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1098    if (WcMatch){
1099      StarStrV.Reverse();
1100      return true;
1101    } else {
1102      return false;
1103    }
1104  }
1105  bool TStr::IsWcMatch(
1106   const TStr& WcStr, const char& StarCh, const char& QuestCh) const {
1107    TStrV StarStrV;
1108    return IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1109  }
1110  bool TStr::IsWcMatch(const TStr& WcStr, const int& StarStrN, TStr& StarStr) const {
1111    TStrV StarStrV;
1112    if (IsWcMatch(WcStr, StarStrV)){
1113      if (StarStrV.Len()>StarStrN){
1114        StarStr=StarStrV[StarStrV.Len()-StarStrN-1];
1115      } else {
1116        StarStr="";
1117      }
1118      return true;
1119    } else {
1120      return false;
1121    }
1122  }
1123  bool TStr::IsWcMatch(const TStr& WcStr) const {
1124    TStrV StarStrV;
1125    return IsWcMatch(0, WcStr, 0, StarStrV);
1126  }
1127  TStr TStr::GetWcMatch(const TStr& WcStr, const int& StarStrN) const {
1128    TStrV StarStrV;
1129    if (IsWcMatch(WcStr, StarStrV)&&(StarStrV.Len()>=StarStrN)){
1130      IAssert(StarStrN>=0);
1131      return StarStrV[StarStrV.Len()-StarStrN-1];
1132    } else {
1133      return "";
1134    }
1135  }
1136  TStr TStr::GetFPath() const {
1137    int ThisLen=Len(); const char* ThisBf=CStr();
1138    int ChN=ThisLen-1;
1139    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1140    return GetSubStr(0, ChN);
1141  }
1142  TStr TStr::GetFBase() const {
1143    int ThisLen=Len(); const char* ThisBf=CStr();
1144    int ChN=ThisLen-1;
1145    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1146    return GetSubStr(ChN+1, ThisLen);
1147  }
1148  TStr TStr::GetFMid() const {
1149    int ThisLen=Len(); const char* ThisBf=CStr();
1150    int ChN=ThisLen-1;
1151    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')&&(ThisBf[ChN]!='.')){
1152      ChN--;}
1153    if (ChN<0){
1154      return *this;
1155    } else {
1156      if (ThisBf[ChN]=='.'){
1157        int EChN= --ChN;
1158        while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1159        return GetSubStr(ChN+1, EChN);
1160      } else {
1161        return GetSubStr(ChN+1, ThisLen);
1162      }
1163    }
1164  }
1165  TStr TStr::GetFExt() const {
1166    int ThisLen=Len(); const char* ThisBf=CStr();
1167    int ChN=ThisLen-1;
1168    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')&&
1169     (ThisBf[ChN]!='.')){ChN--;}
1170    if ((ChN>=0)&&(ThisBf[ChN]=='.')){return GetSubStr(ChN, Len());}
1171    else {return TStr();}
1172  }
1173  TStr TStr::GetNrFPath(const TStr& FPath){
1174    TChA NrFPath(FPath.Len()+4); NrFPath+=FPath;
1175    NrFPath.ChangeCh('\\', '/');
1176    if (NrFPath.Empty()){NrFPath="./";}
1177    if ((NrFPath.Len()>=2)&&isalpha(NrFPath[0])&&(NrFPath[1]==':')){
1178      if (NrFPath.Len()==2){NrFPath+="./";}
1179      if ((NrFPath[2]!='.')&&(NrFPath[2]!='/')){NrFPath.Ins(2, "./");}
1180      if (NrFPath[NrFPath.Len()-1]!='/'){NrFPath+="/";}
1181    } else {
1182      if ((NrFPath[0]!='.')&&(NrFPath[0]!='/')){NrFPath.Ins(0, "./");}
1183      if (NrFPath[NrFPath.Len()-1]!='/'){NrFPath+="/";}
1184    }
1185    return NrFPath;
1186  }
1187  TStr TStr::GetNrFMid(const TStr& FMid){
1188    TChA NrFMid;
1189    int FMidLen=FMid.Len();
1190    for (int ChN=0; ChN<FMidLen; ChN++){
1191      char Ch=FMid[ChN];
1192      if (TCh::IsAlNum(Ch)){NrFMid+=Ch;} else {NrFMid+='_';}
1193    }
1194    return NrFMid;
1195  }
1196  TStr TStr::GetNrFExt(const TStr& FExt){
1197    if (FExt.Empty()||(FExt[0]=='.')){return FExt;}
1198    else {return TStr(".")+FExt;}
1199  }
1200  TStr TStr::GetNrNumFExt(const int& FExtN){
1201    TStr FExtNStr=TInt::GetStr(FExtN);
1202    while (FExtNStr.Len()<3){
1203      FExtNStr=TStr("0")+FExtNStr;}
1204    return FExtNStr;
1205  }
1206  TStr TStr::GetNrFNm(const TStr& FNm){
1207    return GetNrFPath(FNm.GetFPath())+FNm.GetFMid()+GetNrFExt(FNm.GetFExt());
1208  }
1209  TStr TStr::GetNrAbsFPath(const TStr& FPath, const TStr& BaseFPath){
1210    TStr NrBaseFPath;
1211    if (BaseFPath.Empty()){
1212      NrBaseFPath=GetNrFPath(TDir::GetCurDir());
1213    } else {
1214      NrBaseFPath=GetNrFPath(BaseFPath);
1215    }
1216    IAssert(IsAbsFPath(NrBaseFPath));
1217    TStr NrFPath=GetNrFPath(FPath);
1218    TStr NrAbsFPath;
1219    if (IsAbsFPath(NrFPath)){
1220      NrAbsFPath=NrFPath;
1221    } else {
1222      NrAbsFPath=GetNrFPath(NrBaseFPath+NrFPath);
1223    }
1224    NrAbsFPath.ChangeStrAll("/./", "/");
1225    NrAbsFPath.ChangeStrAll("\\.\\", "\\");
1226    return NrAbsFPath;
1227  }
1228  bool TStr::IsAbsFPath(const TStr& FPath){
1229    if ((FPath.Len()>=3)&&isalpha(FPath[0])&&(FPath[1]==':')&&
1230     ((FPath[2]=='/')||(FPath[2]=='\\'))){
1231      return true;
1232    }
1233    return false;
1234  }
1235  TStr TStr::PutFExt(const TStr& FNm, const TStr& FExt){
1236    return FNm.GetFPath()+FNm.GetFMid()+FExt;
1237  }
1238  TStr TStr::PutFExtIfEmpty(const TStr& FNm, const TStr& FExt){
1239    if (FNm.GetFExt().Empty()){
1240      return FNm.GetFPath()+FNm.GetFMid()+FExt;
1241    } else {
1242      return FNm;
1243    }
1244  }
1245  TStr TStr::PutFBase(const TStr& FNm, const TStr& FBase){
1246    return FNm.GetFPath()+FBase;
1247  }
1248  TStr TStr::PutFBaseIfEmpty(const TStr& FNm, const TStr& FBase){
1249    if (FNm.GetFBase().Empty()){
1250      return FNm.GetFPath()+FBase;
1251    } else {
1252      return FNm;
1253    }
1254  }
1255  TStr TStr::AddToFMid(const TStr& FNm, const TStr& ExtFMid){
1256    return FNm.GetFPath()+FNm.GetFMid()+ExtFMid+FNm.GetFExt();
1257  }
1258  TStr TStr::GetNumFNm(const TStr& FNm, const int& Num){
1259    return FNm.GetFPath()+FNm.GetFMid()+TInt::GetStr(Num, "%03d")+FNm.GetFExt();
1260  }
1261  TStr TStr::GetFNmStr(const TStr& Str, const bool& AlNumOnlyP){
1262    TChA FNm=Str;
1263    for (int ChN=0; ChN<FNm.Len(); ChN++){
1264      uchar Ch=FNm[ChN];
1265      if (AlNumOnlyP){
1266        if (
1267         (('0'<=Ch)&&(Ch<='9'))||
1268         (('A'<=Ch)&&(Ch<='Z'))||
1269         (('a'<=Ch)&&(Ch<='z'))||
1270         (Ch=='-')||(Ch=='_')){}
1271        else {Ch='_';}
1272      } else {
1273        if ((Ch<=' ')||(Ch=='/')||(Ch=='\\')||(Ch==':')||(Ch=='.')){
1274          Ch='_';}
1275      }
1276      FNm.PutCh(ChN, Ch);
1277    }
1278    return FNm;
1279  }
1280  TStr& TStr::GetChStr(const char& Ch){
1281    static char MnCh=char(CHAR_MIN);
1282    static char MxCh=char(CHAR_MAX);
1283    static int Chs=int(MxCh)-int(MnCh)+1;
1284    static TStrV ChStrV;
1285    if (ChStrV.Empty()){
1286      ChStrV.Gen(Chs);
1287      for (int ChN=0; ChN<Chs; ChN++){
1288        ChStrV[ChN]=TStr(char(MnCh+ChN), true);}
1289    }
1290    return ChStrV[int(Ch-MnCh)];
1291  }
1292  TStr& TStr::GetDChStr(const char& Ch1, const char& Ch2){
1293    Fail; 
1294    static TStrVV DChStrVV;
1295    if (DChStrVV.Empty()){
1296      DChStrVV.Gen(TCh::Vals, TCh::Vals);
1297      for (int Ch1N=0; Ch1N<TCh::Vals; Ch1N++){
1298        for (int Ch2N=0; Ch2N<TCh::Vals; Ch2N++){
1299          DChStrVV.At(Ch1N, Ch2N)=
1300           TStr(char(TCh::Mn+Ch1N), char(TCh::Mn+Ch2N), true);
1301        }
1302      }
1303    }
1304    return DChStrVV.At(int(Ch1-TCh::Mn), int(Ch2-TCh::Mn));
1305  }
1306  TStr TStr::GetStr(const TStr& Str, const char* FmtStr){
1307    if (FmtStr==NULL){
1308      return Str;
1309    } else {
1310      char Bf[1000];
1311      sprintf(Bf, FmtStr, Str.CStr());
1312      return TStr(Bf);
1313    }
1314  }
1315  TStr TStr::GetStr(const TStrV& StrV, const TStr& DelimiterStr){
1316    if (StrV.Empty()){return TStr();}
1317    TChA ResStr=StrV[0];
1318    for (int StrN=1; StrN<StrV.Len(); StrN++){
1319      ResStr+=DelimiterStr;
1320      ResStr+=StrV[StrN];
1321    }
1322    return ResStr;
1323  }
1324  TStr TStr::Fmt(const char *FmtStr, ...){
1325    char Bf[10*1024];
1326    va_list valist;
1327    va_start(valist, FmtStr);
1328    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
1329    va_end(valist);
1330    return RetVal!=-1 ? TStr(Bf) : TStr::GetNullStr();
1331  }
1332  TStr TStr::GetSpaceStr(const int& Spaces){
1333    static TStrV SpaceStrV;
1334    if (SpaceStrV.Len()==0){
<span onclick='openModal()' class='match'>1335      for (int SpaceStrN=0; SpaceStrN<10; SpaceStrN++){
1336        TChA SpaceChA;
1337        for (int ChN=0; ChN<SpaceStrN; ChN++){SpaceChA+=' ';}
</span>1338        SpaceStrV.Add(SpaceChA);
1339      }
1340    }
1341    if ((0<=Spaces)&&(Spaces<SpaceStrV.Len())){
1342      return SpaceStrV[Spaces];
1343    } else {
1344      TChA SpaceChA;
1345      for (int ChN=0; ChN<Spaces; ChN++){SpaceChA+=' ';}
1346      return SpaceChA;
1347    }
1348  }
1349  TStr TStr::GetNullStr(){
1350    static TStr NullStr="";
1351    return NullStr;
1352  }
1353  TStr operator+(const TStr& LStr, const TStr& RStr){
1354    if (LStr.Empty()){return RStr;}
1355    else if (RStr.Empty()){return LStr;}
1356    else {return TStr(LStr)+=RStr;}
1357  }
1358  TStr operator+(const TStr& LStr, const char* RCStr){
1359    return TStr(LStr)+=RCStr;
1360  }
1361  TStrIn::TStrIn(const TStr& _Str):
1362    TSBase("Input-String"), TSIn("Input-String"), Str(_Str), Bf(Str.CStr()), BfC(0), BfL(Str.Len()){}
1363  int TStrIn::GetBf(const void* LBf, const TSize& LBfL){
1364    Assert(TSize(BfC+LBfL)<=TSize(BfL));
1365    int LBfS=0;
1366    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
1367      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
1368    return LBfS;
1369  }
1370  bool TStrIn::GetNextLnBf(TChA& LnChA){
1371    FailR(TStr::Fmt("TStrIn::GetNextLnBf: not implemented").CStr());
1372    return false;
1373  }
1374  void TStrPool::Resize(const uint& _MxBfL) {
1375    uint newSize = MxBfL;
1376    while (newSize < _MxBfL) {
1377      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
1378      else if (newSize > 0) newSize *= 2;
1379      else newSize = TInt::GetMn(GrowBy, 1024);
1380      IAssertR(newSize >= MxBfL, TStr::Fmt("TStrPool::Resize: %u, %u [Size larger than 4Gb, which is not supported by TStrPool]", newSize, MxBfL).CStr());
1381    }
1382    if (newSize > MxBfL) {
1383      Bf = (char *) realloc(Bf, newSize);
1384      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
1385      MxBfL = newSize;
1386    }
1387    IAssertR(MxBfL >= _MxBfL, TStr::Fmt("new size: %u, requested size: %u", MxBfL, _MxBfL).CStr());
1388  }
1389  TStrPool::TStrPool(const uint& MxBfLen, const uint& _GrowBy) : MxBfL(MxBfLen), BfL(0), GrowBy(_GrowBy), Bf(0) {
1390    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); }
1391    AddStr(""); 
1392  }
1393  TStrPool::TStrPool(TSIn& SIn, bool LoadCompact) : MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1394    SIn.Load(MxBfL);  SIn.Load(BfL);  SIn.Load(GrowBy);
1395    if (LoadCompact) MxBfL = BfL;
1396    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL); IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); }
1397    if (BfL > 0) SIn.LoadBf(Bf, BfL);
1398    SIn.LoadCs();
1399  }
1400  void TStrPool::Save(TSOut& SOut) const {
1401    SOut.Save(MxBfL);  SOut.Save(BfL);  SOut.Save(GrowBy);
1402    SOut.SaveBf(Bf, BfL);
1403    SOut.SaveCs();
1404  }
1405  TStrPool& TStrPool::operator = (const TStrPool& Pool) {
1406    if (this != &Pool) {
1407      GrowBy = Pool.GrowBy;  MxBfL = Pool.MxBfL;  BfL = Pool.BfL;
1408      if (Bf) free(Bf); else IAssertR(MxBfL == 0, TStr::Fmt("size: %u, expected size: 0", MxBfL).CStr());
1409      Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr());  memcpy(Bf, Pool.Bf, BfL);
1410    }
1411    return *this;
1412  }
1413  uint TStrPool::AddStr(const char *Str, const uint& Len) {
1414    IAssertR(Len > 0, "String too short (length includes the null character)");  
1415    if (Len == 1 && BfL > 0) { return 0; } 
1416    Assert(Str);  Assert(Len > 0);
1417    if (BfL + Len > MxBfL) Resize(BfL + Len);
1418    memcpy(Bf + BfL, Str, Len);
1419    uint Pos = BfL;  BfL += Len;  return Pos;
1420  }
1421  int TStrPool::GetPrimHashCd(const char *CStr) {
1422    return TStrHashF_DJB::GetPrimHashCd(CStr);
1423  }
1424  int TStrPool::GetSecHashCd(const char *CStr) {
1425    return TStrHashF_DJB::GetSecHashCd(CStr);
1426  }
1427  void TStrPool64::Resize(const ::TSize& _MxBfL) {
1428    ::TSize newSize = MxBfL;
1429    while (newSize < _MxBfL) {
1430      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
1431      else if (newSize > 0) newSize *= 2;
1432      else newSize = (GrowBy > ::TSize(1024)) ? ::TSize(1024) : GrowBy;
1433      IAssert(newSize >= MxBfL); 
1434    }
1435    if (newSize > MxBfL) {
1436      Bf = (char *) realloc(Bf, newSize);
1437      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
1438      MxBfL = newSize;
1439    }
1440    IAssert(MxBfL >= _MxBfL);
1441  }
1442  TStrPool64::TStrPool64(::TSize _MxBfL, ::TSize _GrowBy):
1443      MxBfL(_MxBfL), BfL(0), GrowBy(_GrowBy), Bf(NULL) {
1444    if (MxBfL > 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1445    AddStr("");
1446  }
1447  TStrPool64::TStrPool64(const TStrPool64& StrPool): 
1448    MxBfL(StrPool.MxBfL), BfL(StrPool.BfL), GrowBy(StrPool.GrowBy) {
1449    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1450    Bf = (char*)malloc(StrPool.MxBfL); IAssert(Bf != NULL); 
1451    memcpy(Bf, StrPool.Bf, BfL);
1452  }
1453  TStrPool64::TStrPool64(TSIn& SIn, bool LoadCompact): 
1454    MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1455    uint64 _GrowBy, _MxBfL, _BfL;
1456    SIn.Load(_GrowBy); SIn.Load(_MxBfL); SIn.Load(_BfL);
1457    GrowBy = (::TSize)_GrowBy; MxBfL = (::TSize)_MxBfL; BfL = (::TSize)_BfL;
1458    if (LoadCompact) { MxBfL = BfL; }
1459    if (MxBfL > 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1460    for (::TSize BfN = 0; BfN < _BfL; BfN++) { Bf[BfN] = SIn.GetCh(); }
1461    SIn.LoadCs();
1462  }
1463  void TStrPool64::Save(TSOut& SOut) const {
1464    uint64 _GrowBy = GrowBy, _MxBfL = MxBfL, _BfL = BfL;
1465    SOut.Save(_GrowBy);  SOut.Save(_MxBfL);  SOut.Save(_BfL);
1466    for (::TSize BfN = 0; BfN < _BfL; BfN++) { SOut.PutCh(Bf[BfN]); }
1467    SOut.SaveCs();
1468  }
1469  TStrPool64& TStrPool64::operator=(const TStrPool64& StrPool) {
1470    if (this != &StrPool) {
1471    GrowBy = StrPool.GrowBy;  MxBfL = StrPool.MxBfL;  BfL = StrPool.BfL;
1472    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1473    Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); 
1474    memcpy(Bf, StrPool.Bf, BfL);
1475    }
1476    return *this;
1477  }
1478  void TStrPool64::Clr(bool DoDel) { 
1479    BfL = 0; 
1480    if (DoDel && (Bf!=NULL)) { 
1481      free(Bf); 
1482      Bf = NULL; MxBfL = 0; 
1483    } 
1484  }
1485  uint64 TStrPool64::AddStr(const TStr& Str) {
1486    const int Len = Str.Len() + 1;
1487    if (BfL + Len > MxBfL) { Resize(BfL + Len); }
1488    memcpy(Bf + BfL, Str.CStr(), Len);
1489    ::TSize Offset = BfL;  BfL += Len;
1490    return uint64(Offset);
1491  }
1492  TStr TStrPool64::GetStr(const uint64& StrId) const {
1493    ::TSize Offset = (::TSize)StrId;
1494    return TStr(Bf + Offset);
1495  }
1496  void TVoid::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1497    XLoadHd(Nm);
1498  }
1499  void TVoid::SaveXml(TSOut& SOut, const TStr& Nm) const {
1500    XSaveBETag(Nm);
1501  }
1502  const bool TBool::Mn=0;
1503  const bool TBool::Mx=1;
1504  const int TBool::Vals=TBool::Mx-TBool::Mn+1;
1505  TRnd TBool::Rnd;
1506  const TStr TBool::FalseStr="F";
1507  const TStr TBool::TrueStr="T";
1508  const TStr TBool::NStr="N";
1509  const TStr TBool::YStr="Y";
1510  const TStr TBool::NoStr="No";
1511  const TStr TBool::YesStr="Yes";
1512  void TBool::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1513    XLoadHd(Nm);
1514    Val=TXmlObjSer::GetBoolArg(XmlTok, "Val");
1515  }
1516  void TBool::SaveXml(TSOut& SOut, const TStr& Nm) const {
1517    XSaveBETagArg(Nm, "Val", TBool::GetStr(Val));
1518  }
1519  bool TBool::IsValStr(const TStr& Str){
1520    TStr UcStr=Str.GetUc();
1521    return
1522     (UcStr==FalseStr)||(UcStr==TrueStr)||
1523     (UcStr==YStr)||(UcStr==NStr)||
1524     (UcStr==YesStr)||(UcStr==NoStr);
1525  }
1526  bool TBool::GetValFromStr(const TStr& Str){
1527    return (Str==TrueStr)||(Str==YStr)||(Str==YesStr);
1528  }
1529  bool TBool::GetValFromStr(const TStr& Str, const bool& DfVal){
1530    TStr UcStr=Str.GetUc();
1531    if (IsValStr(UcStr)){
1532      return (UcStr==TrueStr)||(UcStr==YStr)||(UcStr==YesStr);
1533    } else {
1534      return DfVal;
1535    }
1536  }
1537  const char TCh::Mn=CHAR_MIN;
1538  const char TCh::Mx=CHAR_MAX;
1539  const int TCh::Vals=int(TCh::Mx)-int(TCh::Mn)+1;
1540  const char TCh::NullCh=char(0);
1541  const char TCh::TabCh=char(9);
1542  const char TCh::LfCh=char(10);
1543  const char TCh::CrCh=char(13);
1544  const char TCh::EofCh=char(26);
1545  const char TCh::HashCh='#';
1546  void TCh::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1547    XLoadHd(Nm);
1548    Val=char(TXmlObjSer::GetIntArg(XmlTok, "Val"));
1549  }
1550  void TCh::SaveXml(TSOut& SOut, const TStr& Nm) const {
1551    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1552  }
1553  char TCh::GetUsFromYuAscii(const char& Ch){
1554    switch (Ch){
1555      case '~': return 'c';
1556      case '^': return 'C';
1557      case '{': return 's';
1558      case '[': return 'S';
1559      case '`': return 'z';
1560      case '@': return 'Z';
1561      case '|': return 'd';
1562      case '\\': return 'D';
1563      default: return Ch;
1564    }
1565  }
1566  const uchar TUCh::Mn=0;
1567  const uchar TUCh::Mx=UCHAR_MAX;
1568  const int TUCh::Vals=int(TUCh::Mx)-int(TUCh::Mn)+1;
1569  void TUCh::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1570    XLoadHd(Nm);
1571    Val=uchar(TXmlObjSer::GetIntArg(XmlTok, "Val"));
1572  }
1573  void TUCh::SaveXml(TSOut& SOut, const TStr& Nm) const {
1574    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1575  }
1576  const int TInt::Mn=INT_MIN;
1577  const int TInt::Mx=INT_MAX;
1578  const int TInt::Kilo=1024;
1579  const int TInt::Mega=1024*1024;
1580  const int TInt::Giga=1024*1024*1024;
1581  TRnd TInt::Rnd;
1582  void TInt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1583    XLoadHd(Nm);
1584    Val=TXmlObjSer::GetIntArg(XmlTok, "Val");
1585  }
1586  void TInt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1587    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1588  }
1589  TStr TInt::GetStr(const int& Val, const char* FmtStr){
1590    if (FmtStr==NULL){
1591      return GetStr(Val);
1592    } else {
1593      char Bf[255];
1594      sprintf(Bf, FmtStr, Val);
1595      return TStr(Bf);
1596    }
1597  }
1598  char* TInt::SaveFrugalInt(char *pDest, int i){
1599    i++;
1600    if (i >= 0 && i <= 127) { *pDest++ = char(i); return pDest; }
1601    if (i >= 128 && i < 128 + 8192) { i -= 128; *pDest++ = char(0x80 | (i & 0x7f));
1602      *pDest++ = char((i >> 7) & 0x3f); return pDest; }
1603    if (i <= -1 && i > -1 - 8192) { i = -1 - i;  *pDest++ = char(0x80 | (i & 0x7f));
1604      *pDest++ = char(0x40 | ((i >> 7) & 0x3f)); return pDest; }
1605    if (i >= 128 + 8192 && i < 128 + 8192 + 536870912) { i -= 128 + 8192;
1606      *pDest++ = char(0x80 | (i & 0x7f)); *pDest++ = char(0x80 | ((i >> 7) & 0x7f));
1607      *pDest++ = char((i >> 14) & 0xff); *pDest++ = char((i >> 22) & 0x7f); return pDest; }
1608    if (i <= -1 - 8192 && i > -1 - 8192 - 536870912) { i = (-1 - 8192) - i;
1609      *pDest++ = char(0x80 | (i & 0x7f)); *pDest++ = char(0x80 | ((i >> 7) & 0x7f));
1610      *pDest++ = char((i >> 14) & 0xff); *pDest++ = char(0x80 | ((i >> 22) & 0x7f)); return pDest; }
1611    IAssertR(false, TInt::GetStr(i)); return 0;
1612  }
1613  char* TInt::LoadFrugalInt(char *pSrc, int& i){
1614    i = 0;
1615    int ch = (int) ((unsigned char) (*pSrc++));
1616    if ((ch & 0x80) == 0) { i = ch; i--; return pSrc; }
1617    i = (ch & 0x7f);
1618    ch = (int) ((unsigned char) (*pSrc++));
1619    if ((ch & 0x80) == 0)
1620    {
1621      i |= (ch & 0x3f) << 7;
1622      if ((ch & 0x40) == 0) i += 128; else i = -1 - i;
1623      i--; return pSrc;
1624    }
1625    i |= (ch & 0x7f) << 7;
1626    ch = (int) ((unsigned char) (*pSrc++));
1627    i |= ch << 14;
1628    ch = (int) ((unsigned char) (*pSrc++));
1629    i |= (ch & 0x7f) << 22;
1630    if ((ch & 0x80) == 0) i += 128 + 8192; else i = (-1 - 8192) - i;
1631    i--; return pSrc;
1632  }
1633  void TInt::TestFrugalInt(){
1634    char buf[10], *p = &buf[0], *r, *s;
1635    int i, j;
1636  #define __TEST(from, to, len) \
1637    for (i = (from); i <= (to); i++) \
1638      { if ((i & 0xffff) == 0) printf("%d\r", i); \
1639        r = SaveFrugalInt(p, i); s = LoadFrugalInt(p, j); \
1640        IAssert(r == s); IAssert(i == j); IAssert(r - p == len); }
1641    __TEST(-1, 126, 1);
1642    __TEST(127, 127 + 8191, 2);
1643    __TEST(-2 - 8191, -2, 2);
1644    __TEST(127 + 8192, 127 + 8191 + (1 << 29), 4);
1645    __TEST(-2 - 8191 - (1 << 29), -2 - 8192, 4);
1646  #undef __TEST
1647  }
1648  void TInt::SaveFrugalIntV(TSOut& SOut, const TIntV& v){
1649    int count = v.Len();
1650    char *buf = new char[4 * (count + 1)], *pStart, *pEnd;
1651    pStart = buf + 4; pEnd = pStart;
1652    for (int i = 0; i < count; i++)
1653      pEnd = SaveFrugalInt(pEnd, v[i].Val);
1654    int size = int(pEnd - pStart);
1655    char *pSizeStart = buf;
1656    char *pSizeEnd = SaveFrugalInt(pSizeStart, size);
1657    while (pSizeEnd > pSizeStart) *(--pStart) = *(--pSizeEnd);
1658    SOut.PutBf(pStart, TSize(pEnd - pStart));
1659    delete[] buf;
1660  }
1661  void TInt::LoadFrugalIntV(TSIn& SIn, TIntV& v, bool clearVec){
1662    if (clearVec) v.Clr();
1663    char sizeBuf[4], *p, *pEnd;
1664    sizeBuf[0] = SIn.GetCh(); int count = 1;
1665    if (sizeBuf[0] & 0x80)
1666    {
1667      sizeBuf[1] = SIn.GetCh(); count++;
1668      if (sizeBuf[1] & 0x80) { sizeBuf[2] = SIn.GetCh();
1669        sizeBuf[3] = SIn.GetCh(); count += 2;}
1670    }
1671    int size;
1672    pEnd = LoadFrugalInt(&sizeBuf[0], size);
1673    IAssert(pEnd - &sizeBuf[0] == count);
1674    if (size <= 0) return;
1675    char *buf = new char[size];
1676    SIn.GetBf(buf, size);
1677    p = buf; pEnd = buf + size;
1678    while (p < pEnd)
1679      { int i; p = LoadFrugalInt(p, i); v.Add(i); }
1680    IAssert(p == pEnd);
1681    delete[] buf;
1682  }
1683  const uint TUInt::Mn=0;
1684  const uint TUInt::Mx=UINT_MAX;
1685  TRnd TUInt::Rnd;
1686  void TUInt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1687    XLoadHd(Nm);
1688    Val=TXmlObjSer::GetIntArg(XmlTok, "Val");
1689  }
1690  void TUInt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1691    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1692  }
1693  TStr TUInt::GetStr(const uint& Val, const char* FmtStr){
1694    if (FmtStr==NULL){
1695      return GetStr(Val);
1696    } else {
1697      char Bf[255];
1698      sprintf(Bf, FmtStr, Val);
1699      return TStr(Bf);
1700    }
1701  }
1702  bool TUInt::IsIpStr(const TStr& IpStr, uint& Ip, const char& SplitCh) {
1703  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1704      Ip = 0; int Byte = 0;
1705  	if (IpStrV.Len() != 4) { return false; }
1706  	if (!IpStrV[0].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (uint)Byte;
1707  	if (!IpStrV[1].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1708  	if (!IpStrV[2].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1709  	if (!IpStrV[3].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1710  	return true;
1711  }
1712  uint TUInt::GetUIntFromIpStr(const TStr& IpStr, const char& SplitCh) {
1713  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1714      uint Ip = 0; int Byte = 0;
1715  	EAssertR(IpStrV[0].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (uint)Byte;
1716  	EAssertR(IpStrV[1].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1717  	EAssertR(IpStrV[2].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1718  	EAssertR(IpStrV[3].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1719  	return Ip;
1720  }
1721  TStr TUInt::GetStrFromIpUInt(const uint& Ip) {
1722    return TStr::Fmt("%d.%d.%d.%d", ((Ip>>24) & 0xFF),
1723     ((Ip>>16) & 0xFF), ((Ip>>8) & 0xFF), (Ip & 0xFF));
1724  }
1725  bool TUInt::IsIpv6Str(const TStr& IpStr, const char& SplitCh) {
1726  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV, false);
1727  	if (IpStrV.Len() > 8) { return false; }
1728  	int Group = 0;
1729  	for (int IpStrN = 0; IpStrN < IpStrV.Len(); IpStrN++) {
1730  		if (IpStrV[IpStrN].Empty()) { continue; }
1731  		if (IpStrV[IpStrN].IsHexInt(true, 0x0000, 0xFFFF, Group)) { continue; }
1732  		return false; 
1733  	}
1734  	return true;
1735  }
1736  #if defined (GLib_WIN32)
1737  const TUInt64 TUInt64::Mn(uint64(0x0000000000000000i64));
1738  const TUInt64 TUInt64::Mx(uint64(0xFFFFFFFFFFFFFFFFi64));
1739  #elif defined (GLib_BCB)
1740  const TUInt64 TUInt64::Mn(0x0000000000000000i64);
1741  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFi64);
1742  #else
1743  const TUInt64 TUInt64::Mn((uint64)0x0000000000000000LL);
1744  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFLL);
1745  #endif
1746  void TUInt64::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1747    XLoadHd(Nm);
1748    Val=TXmlObjSer::GetInt64Arg(XmlTok, "Val");
1749  }
1750  void TUInt64::SaveXml(TSOut& SOut, const TStr& Nm) const {
1751    XSaveBETagArg(Nm, "Val", TUInt64::GetStr(Val));
1752  }
1753  const double TFlt::Mn=-DBL_MAX;
1754  const double TFlt::Mx=+DBL_MAX;
1755  const double TFlt::NInf=-DBL_MAX;
1756  const double TFlt::PInf=+DBL_MAX;
1757  const double TFlt::Eps=1e-16;
1758  const double TFlt::EpsHalf  =1e-7;
1759  TRnd TFlt::Rnd;
1760  void TFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1761    XLoadHd(Nm);
1762    Val=TXmlObjSer::GetFltArg(XmlTok, "Val");
1763  }
1764  void TFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1765    XSaveBETagArg(Nm, "Val", TFlt::GetStr(Val));
1766  }
1767  TStr TFlt::GetStr(const double& Val, const int& Width, const int& Prec){
1768    char Bf[255];
1769    if ((Width==-1)&&(Prec==-1)){sprintf(Bf, "%g", Val);}
1770    else {sprintf(Bf, "%*.*f", Width, Prec, Val);}
1771    return TStr(Bf);
1772  }
1773  TStr TFlt::GetStr(const double& Val, const char* FmtStr){
1774    if (FmtStr==NULL){
1775      return GetStr(Val);
1776    } else {
1777      char Bf[255];
1778      sprintf(Bf, FmtStr, Val);
1779      return TStr(Bf);
1780    }
1781  }
1782  const sdouble TSFlt::Mn=-FLT_MIN;
1783  const sdouble TSFlt::Mx=+FLT_MAX;
1784  void TSFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1785    XLoadHd(Nm);
1786    Val=sdouble(TXmlObjSer::GetFltArg(XmlTok, "Val"));
1787  }
1788  void TSFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1789    XSaveBETagArg(Nm, "Val", TFlt::GetStr(Val));
1790  }
1791  const ldouble TLFlt::Mn=-LDBL_MAX;
1792  const ldouble TLFlt::Mx=+LDBL_MAX;
1793  void TLFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1794    XLoadHd(Nm);
1795    Val=TXmlObjSer::GetFltArg(XmlTok, "Val");
1796  }
1797  void TLFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1798    XSaveBETagArg(Nm, "Val", TFlt::GetStr(double(Val)));
1799  }
1800  TStr TLFlt::GetStr(const ldouble& Val, const int& Width, const int& Prec){
1801    char Bf[255];
1802    if ((Width==-1)&&(Prec==-1)){sprintf(Bf, "%Lg", Val);}
1803    else {sprintf(Bf, "%*.*Lf", Width, Prec, Val);}
1804    return TStr(Bf);
1805  }
1806  TStr TLFlt::GetStr(const ldouble& Val, const char* FmtStr){
1807    if (FmtStr==NULL){
1808      return GetStr(Val);
1809    } else {
1810      char Bf[255];
1811      sprintf(Bf, FmtStr, Val);
1812      return TStr(Bf);
1813    }
1814  }
1815  void TFltRect::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1816    XLoadHd(Nm);
1817    MnX=TXmlObjSer::GetFltArg(XmlTok, "MnX");
1818    MnY=TXmlObjSer::GetFltArg(XmlTok, "MnY");
1819    MxX=TXmlObjSer::GetFltArg(XmlTok, "MxX");
1820    MxY=TXmlObjSer::GetFltArg(XmlTok, "MxY");
1821  }
1822  void TFltRect::SaveXml(TSOut& SOut, const TStr& Nm) const {
1823    XSaveBETagArg4(Nm,
1824     "MnX", TFlt::GetStr(double(MnX)), "MnY", TFlt::GetStr(double(MnY)),
1825     "MxX", TFlt::GetStr(double(MxX)), "MxY", TFlt::GetStr(double(MxY)));
1826  }
1827  bool TFltRect::Intersection(const TFltRect& Rect1, const TFltRect& Rect2){
1828    const double MnXX = TFlt::GetMx(Rect1.GetMnX(), Rect2.GetMnX());
1829    const double MnYY = TFlt::GetMx(Rect1.GetMnY(), Rect2.GetMnY());
1830    const double MxXX = TFlt::GetMn(Rect1.GetMxX(), Rect2.GetMxX());
1831    const double MxYY = TFlt::GetMn(Rect1.GetMxY(), Rect2.GetMxY());
1832    return (MnXX < MxXX) && (MnYY < MxYY);
1833  }
1834  TStr TFltRect::GetStr() const {
1835    TChA ChA;
1836    ChA+='(';
1837    ChA+=TFlt::GetStr(MnX, "%0.2f"); ChA+=',';
1838    ChA+=TFlt::GetStr(MnY, "%0.2f"); ChA+=',';
1839    ChA+=TFlt::GetStr(MxX, "%0.2f"); ChA+=',';
1840    ChA+=TFlt::GetStr(MxY, "%0.2f"); ChA+=')';
1841    return ChA;
1842  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lstm_unit_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>81    for (int n = 0; n < num; ++n) {
82      for (int d = 0; d < hidden_dim_; ++d) {
</pre></code></div>
                <div class="column column_space"><pre><code>1335      for (int SpaceStrN=0; SpaceStrN<10; SpaceStrN++){
1336        TChA SpaceChA;
1337        for (int ChN=0; ChN<SpaceStrN; ChN++){SpaceChA+=' ';}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    