
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 45, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparserA.cpp</h3>
            <pre><code>1  #include <sstream>
2  #include "tinyxmlA.h"
3  TiXmlBaseA::Entity TiXmlBaseA::entity[ NUM_ENTITY ] = 
4  {
5  	{ "&amp;",  5, '&' },
6  	{ "&lt;",   4, '<' },
7  	{ "&gt;",   4, '>' },
8  	{ "&quot;", 6, '\"' },
9  	{ "&apos;", 6, '\'' }
10  };
11  class TiXmlParsingDataA
12  {
13  	friend class TiXmlDocumentA;
14    public:
15  	void Stamp( const char* now );
16  	const TiXmlCursorA& Cursor()	{ return cursor; }
17    private:
18  	TiXmlParsingDataA( const char* start, int _tabsize, int row, int col )
19  	{
20  		assert( start );
21  		stamp = start;
22  		tabsize = _tabsize;
23  		cursor.row = row;
24  		cursor.col = col;
25  	}
26  	TiXmlCursorA		cursor;
27  	const char*		stamp;
28  	int				tabsize;
29  };
30  void TiXmlParsingDataA::Stamp( const char* now )
31  {
32  	assert( now );
33  	if ( tabsize < 1 )
34  	{
35  		return;
36  	}
37  	int row = cursor.row;
38  	int col = cursor.col;
39  	const char* p = stamp;
40  	assert( p );
41  	while ( p < now )
42  	{
43  		switch (*p) {
44  			case 0:
45  				return;
46  			case '\r':
47  				++row;
48  				col = 0;				
49  				++p;
50  				if (*p == '\n') {
51  					++p;
52  				}
53  				break;
54  			case '\n':
55  				++row;
56  				col = 0;
57  				++p;
58  				if (*p == '\r') {
59  					++p;
60  				}
61  				break;
62  			case '\t':
63  				++p;
64  				col = (col / tabsize + 1) * tabsize;
65  				break;
66  			default:
67  				++p;
68  				++col;
69  				break;
70  		}
71  	}
72  	cursor.row = row;
73  	cursor.col = col;
74  	assert( cursor.row >= -1 );
75  	assert( cursor.col >= -1 );
76  	stamp = p;
77  	assert( stamp );
78  }
79  const char* TiXmlBaseA::SkipWhiteSpace( const char* p )
80  {
81  	if ( !p || !*p )
82  	{
83  		return 0;
84  	}
85  	while ( p && *p )
86  	{
87  		if ( isspace( *p ) || *p == '\n' || *p =='\r' )		
88  			++p;
89  		else
90  			break;
91  	}
92  	return p;
93  }
94  #ifdef TIXMLA_USE_STL
95   bool TiXmlBaseA::StreamWhiteSpace( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
96  {
97  	for ( ;; )
98  	{
99  		if ( !in->good() ) return false;
100  		int c = in->peek();
101  		if ( !IsWhiteSpace( c ) )
102  			return true;
103  		*tag += static_cast<char>(in->get());
104  	}
105  }
106   bool TiXmlBaseA::StreamTo( TIXMLA_ISTREAM * in, int character, TIXMLA_STRING * tag )
107  {
108  	while ( in->good() )
109  	{
110  		int c = in->peek();
111  		if ( c == character )
112  			return true;
113  		in->get();
114  		*tag += static_cast<char>(c);
115  	}
116  	return false;
117  }
118  #endif
119  const char* TiXmlBaseA::ReadName( const char* p, TIXMLA_STRING * name )
120  {
121  	*name = "";
122  	assert( p );
123  	if ( p && *p 
124  		&& (isalpha(static_cast<unsigned char>(*p)) || *p == '_'))
125  	{
126  		while ( p && *p
127  				&&	(		isalnum( (unsigned char ) *p ) 
128  						 || *p == '_'
129  						 || *p == '-'
130  						 || *p == '.'
131  						 || *p == ':' ) )
132  		{
133  			(*name) += *p;
134  			++p;
135  		}
136  		return p;
137  	}
138  	return 0;
139  }
140  const char* TiXmlBaseA::GetEntity( const char* p, char* value )
141  {
142      TIXMLA_STRING ent;
143  	int i;
144  	if (    strncmp( "&#x", p, 3 ) == 0 
145  	     && *(p+3) 
146  		 && *(p+4) 
147  		 && ( *(p+4) == ';' || *(p+5) == ';' )
148  	   )
149  	{
150  		*value = 0;
151  		if ( *(p+4) == ';' )
152  		{
153  			if ( isalpha( *(p+3) ) ) 
154  				*value += static_cast<char>(static_cast<char>(tolower(*(p + 3))) - 'a' + 10);
155  			else				     
156  				*value += static_cast<char>(static_cast<char>(*(p + 3)) - '0');
157  			return p+5;
158  		}
159  		else
160  		{
161  			if (isalpha(*(p + 3))) *value += static_cast<char>((static_cast<char>(tolower(*(p + 3))) - 'a' + 10) * 16);
162  			else				     *value += static_cast<char>((static_cast<char>(*(p + 3)) - '0') * 16);
163  			if ( isalpha( *(p+4) ) ) 
164  				*value += static_cast<char>(static_cast<char>(tolower(*(p + 4))) - 'a' + 10);
165  			else				     
166  				*value += static_cast<char>(static_cast<char>(*(p + 4)) - '0');
167  			return p+6;
168  		}
169  	}
170  	for ( i=0; i<NUM_ENTITY; ++i )
171  	{
172  		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
173  		{
174  			assert( strlen( entity[i].str ) == entity[i].strLength );
175  			*value = entity[i].chr;
176  			return ( p + entity[i].strLength );
177  		}
178  	}
179  	*value = *p;	
180  	return p+1;
181  }
182  bool TiXmlBaseA::StringEqual( const char* p,
183  							 const char* tag,
184  							 bool ignoreCase )
185  {
186  	assert( p );
187  	if ( !p || !*p )
188  	{
189  		assert( 0 );
190  		return false;
191  	}
192      if ( tolower( *p ) == tolower( *tag ) )
193  	{
194  		const char* q = p;
195  		if (ignoreCase)
196  		{
197  			while ( *q && *tag && *q == *tag )
198  			{
199  				++q;
200  				++tag;
201  			}
202  			if ( *tag == 0 )		
203  			{
204  				return true;
205  			}
206  		}
207  		else
208  		{
209  			while ( *q && *tag && tolower( *q ) == tolower( *tag ) )
210  			{
211  				++q;
212  				++tag;
213  			}
214  			if ( *tag == 0 )
215  			{
216  				return true;
217  			}
218  		}
219  	}
220  	return false;
221  }
222  const char* TiXmlBaseA::ReadText(	const char* p, 
223  									TIXMLA_STRING * text, 
224  									bool trimWhiteSpace, 
225  									const char* endTag, 
226  									bool caseInsensitive )
227  {
228      *text = "";
229  	if (    !trimWhiteSpace			
230  		 || !condenseWhiteSpace )	
231  	{
232  		while (	   p && *p
233  				&& !StringEqual( p, endTag, caseInsensitive )
234  			  )
235  		{
236  			char c;
237  			p = GetChar( p, &c );
238              (* text) += c;
239  		}
240  	}
241  	else
242  	{
243  		bool whitespace = false;
244  		p = SkipWhiteSpace( p );
245  		while (	   p && *p
246  				&& !StringEqual( p, endTag, caseInsensitive ) )
247  		{
248  			if ( *p == '\r' || *p == '\n' )
249  			{
250  				whitespace = true;
251  				++p;
252  			}
253  			else if ( isspace( *p ) )
254  			{
255  				whitespace = true;
256  				++p;
257  			}
258  			else
259  			{
260  				if ( whitespace )
261  				{
262                 (* text) += ' ';
263  					whitespace = false;
264  				}
265  				char c;
266  				p = GetChar( p, &c );
267              (* text) += c;
268  			}
269  		}
270  	}
271  	return p + strlen( endTag );
272  }
273  #ifdef TIXMLA_USE_STL
274  void TiXmlDocumentA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
275  {
276  	if ( !StreamTo( in, '<', tag ) ) 
277  	{
278  		SetError( TIXMLA_ERROR_PARSING_EMPTY, 0, 0 );
279  		return;
280  	}
281  	while ( in->good() )
282  	{
283  		size_t tagIndex = tag->length();
284  		while ( in->good() && in->peek() != '>' )
285  		{
286  			int c = in->get();
287  			(*tag) += static_cast<char>(c);
288  		}
289  		if ( in->good() )
290  		{
291  			TiXmlNodeA* node = Identify( tag->c_str() + tagIndex );
292  			if ( node )
293  			{
294  				node->StreamIn( in, tag );
295  				bool isElement = node->ToElement() != 0;
296  				delete node;
297  				node = 0;
298  				if ( isElement )
299  				{
300  					return;
301  				}
302  			}
303  			else
304  			{
305  				SetError( TIXMLA_ERROR, 0, 0 );
306  				return;
307  			}
308  		}
309  	}
310  	SetError( TIXMLA_ERROR, 0, 0 );
311  }
312  #endif
313  const char* TiXmlDocumentA::Parse( const char* p, TiXmlParsingDataA* prevData )
314  {
315  	ClearError();
316  	if ( !p || !*p )
317  	{
318  		SetError( TIXMLA_ERROR_DOCUMENT_EMPTY, 0, 0 );
319  		return 0;
320  	}
321  	location.Clear();
322  	if ( prevData )
323  	{
324  		location.row = prevData->cursor.row;
325  		location.col = prevData->cursor.col;
326  	}
327  	else
328  	{
329  		location.row = 0;
330  		location.col = 0;
331  	}
332  	TiXmlParsingDataA data( p, TabSize(), location.row, location.col );
333  	location = data.Cursor();
334      p = SkipWhiteSpace( p );
335  	if ( !p )
336  	{
337  		SetError( TIXMLA_ERROR_DOCUMENT_EMPTY, 0, 0 );
338  		return 0;
339  	}
340  	while ( p && *p )
341  	{
342  		TiXmlNodeA* node = Identify( p );
343  		if ( node )
344  		{
345  			p = node->Parse( p, &data );
346  			LinkEndChild( node );
347  		}
348  		else
349  		{
350  			break;
351  		}
352  		p = SkipWhiteSpace( p );
353  	}
354  	return p;
355  }
356  void TiXmlDocumentA::SetError( int err, const char* pError, TiXmlParsingDataA* data )
357  {	
358  	if ( error )
359  		return;
360  	assert( err > 0 && err < TIXMLA_ERROR_STRING_COUNT );
361  	error   = true;
362  	errorId = err;
363  	errorDesc = errorString[ errorId ];
364  	errorLocation.Clear();
365  	if ( pError && data )
366  	{
367  		data->Stamp( pError );
368  		errorLocation = data->Cursor();
369  	}
370  }
371  TiXmlNodeA* TiXmlNodeA::Identify( const char* p )
372  {
373  	TiXmlNodeA* returnNode = 0;
374  	p = SkipWhiteSpace( p );
375  	if ( !p || !*p || *p != '<' )
376  	{
377  		return 0;
378  	}
379  	TiXmlDocumentA* doc = GetDocument();
380  	p = SkipWhiteSpace( p );
381  	if ( !p || !*p )
382  	{
383  		return 0;
384  	}
385  	const char* xmlHeader = { "<?xml" };
386  	const char* commentHeader = { "<!--" };
387  	if ( StringEqual( p, xmlHeader, true ) )
388  	{
389  		#ifdef DEBUG_PARSER
390  			TIXMLA_LOG( "XML parsing Declaration\n" );
391  		#endif
392  		returnNode = new TiXmlDeclarationA();
393  	}
394  	else if (    isalpha( *(p+1) )
395  			  || *(p+1) == '_' )
396  	{
397  		#ifdef DEBUG_PARSER
398  			TIXMLA_LOG( "XML parsing Element\n" );
399  		#endif
400  		returnNode = new TiXmlElementA( "" );
401  	}
402  	else if ( StringEqual( p, commentHeader, false ) )
403  	{
404  		#ifdef DEBUG_PARSER
405  			TIXMLA_LOG( "XML parsing Comment\n" );
406  		#endif
407  		returnNode = new TiXmlCommentA();
408  	}
409  	else
410  	{
411  		#ifdef DEBUG_PARSER
412  			TIXMLA_LOG( "XML parsing Unknown\n" );
413  		#endif
414  		returnNode = new TiXmlUnknownA();
415  	}
416  	if ( returnNode )
417  	{
418  		returnNode->parent = this;
419  	}
420  	else
421  	{
422  		if ( doc )
423  			doc->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
424  	}
425  	return returnNode;
426  }
427  #ifdef TIXMLA_USE_STL
428  void TiXmlElementA::StreamIn (TIXMLA_ISTREAM * in, TIXMLA_STRING * tag)
429  {
430  	while ( in->good() )
431  	{
432  		int c = in->get();
433  		(*tag) += static_cast<char>(c);
434  		if ( c == '>' )
435  			break;
436  	}
437  	if ( tag->length() < 3 ) return;
438  	if (    tag->at( tag->length() - 1 ) == '>' 
439  		 && tag->at( tag->length() - 2 ) == '/' )
440  	{
441  		return;
442  	}
443  	else if ( tag->at( tag->length() - 1 ) == '>' )
444  	{
445  		for ( ;; )
446  		{
447  			StreamWhiteSpace( in, tag );
448  			if ( in->good() && in->peek() != '<' ) 
449  			{
450  				TiXmlTextA text( "" );
451  				text.StreamIn( in, tag );
452  				continue;
453  			}
454  			if ( !in->good() ) return;
455  			assert( in->peek() == '<' );
456  			size_t tagIndex = tag->length();
457  			bool closingTag = false;
458  			bool firstCharFound = false;
459  			for ( ;; )
460  			{
461  				if ( !in->good() )
462  					return;
463  				int c = in->peek();
464  				if ( c == '>' )
465  					break;
466  				*tag += static_cast<char>(c);
467  				in->get();
468  				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
469  				{
470  					firstCharFound = true;
471  					if ( c == '/' )
472  						closingTag = true;
473  				}
474  			}
475  			if ( closingTag )
476  			{
477  				int c = in->get();
478  				assert( c == '>' );
479  				*tag += static_cast<char>(c);
480  				return;
481  			}
482  			else
483  			{
484  				const char* tagloc = tag->c_str() + tagIndex;
485  				TiXmlNodeA* node = Identify( tagloc );
486  				if ( !node )
487  					return;
488  				node->StreamIn( in, tag );
489  				delete node;
490  				node = 0;
491  			}
492  		}
493  	}
494  }
495  #endif
496  const char* TiXmlElementA::Parse( const char* p, TiXmlParsingDataA* data )
497  {
498  	p = SkipWhiteSpace( p );
499  	TiXmlDocumentA* document = GetDocument();
500  	if ( !p || !*p )
501  	{
502  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, 0, 0 );
503  		return 0;
504  	}
505  	if ( data )
506  	{
507  		data->Stamp( p );
<span onclick='openModal()' class='match'>508  		location = data->Cursor();
509  	}
510  	if ( *p != '<' )
511  	{
512  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, p, data );
513  		return 0;
514  	}
515  	p = SkipWhiteSpace( p+1 );
516  	const char* pErr = p;
</span>517      p = ReadName( p, &value );
518  	if ( !p || !*p )
519  	{
520  		if ( document )	document->SetError( TIXMLA_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data );
521  		return 0;
522  	}
523      TIXMLA_STRING endTag ("</");
524  	endTag += value;
525  	endTag += ">";
526  	while ( p && *p )
527  	{
528  		pErr = p;
529  		p = SkipWhiteSpace( p );
530  		if ( !p || !*p )
531  		{
532  			if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, pErr, data );
533  			return 0;
534  		}
535  		if ( *p == '/' )
536  		{
537  			++p;
538  			if ( *p  != '>' )
539  			{
540  				if ( document ) document->SetError( TIXMLA_ERROR_PARSING_EMPTY, p, data );		
541  				return 0;
542  			}
543  			return (p+1);
544  		}
545  		else if ( *p == '>' )
546  		{
547  			++p;
548  			p = ReadValue( p, data );		
549  			if ( !p || !*p )
550  				return 0;
551  			if ( StringEqual( p, endTag.c_str(), false ) )
552  			{
553  				p += endTag.length();
554  				return p;
555  			}
556  			else
557  			{
558  				if ( document ) document->SetError( TIXMLA_ERROR_READING_END_TAG, p, data );
559  				return 0;
560  			}
561  		}
562  		else
563  		{
564  			TiXmlAttributeA* attrib = new TiXmlAttributeA();
565  			if ( !attrib )
566  			{
567  				if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, pErr, data );
568  				return 0;
569  			}
570  			attrib->SetDocument( document );
571  			const char* pErr = p;
572  			p = attrib->Parse( p, data );
573  			if ( !p || !*p )
574  			{
575  				if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, pErr, data );
576  				delete attrib;
577  				return 0;
578  			}
579  			TiXmlAttributeA* node = attributeSet.Find( attrib->Name() );
580  			if ( node )
581  			{
582  				node->SetValue( attrib->Value() );
583  				delete attrib;
584  				return 0;
585  			}
586  			attributeSet.Add( attrib );
587  		}
588  	}
589  	return p;
590  }
591  const char* TiXmlElementA::ReadValue( const char* p, TiXmlParsingDataA* data )
592  {
593  	TiXmlDocumentA* document = GetDocument();
594  	p = SkipWhiteSpace( p );
595  	while ( p && *p )
596  	{
597  		if ( *p != '<' )
598  		{
599  			TiXmlTextA* textNode = new TiXmlTextA( "" );
600  			if ( !textNode )
601  			{
602  				if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
603  				    return 0;
604  			}
605  			p = textNode->Parse( p, data );
606  			if ( !textNode->Blank() )
607  				LinkEndChild( textNode );
608  			else
609  				delete textNode;
610  		} 
611  		else 
612  		{
613  			if ( StringEqual( p, "</", false ) )
614  			{
615  				return p;
616  			}
617  			else
618  			{
619  				TiXmlNodeA* node = Identify( p );
620  				if ( node )
621  				{
622  					p = node->Parse( p, data );
623  					LinkEndChild( node );
624  				}				
625  				else
626  				{
627  					return 0;
628  				}
629  			}
630  		}
631  		p = SkipWhiteSpace( p );
632  	}
633  	if ( !p )
634  	{
635  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ELEMENT_VALUE, 0, 0 );
636  	}	
637  	return p;
638  }
639  #ifdef TIXMLA_USE_STL
640  void TiXmlUnknownA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
641  {
642  	while ( in->good() )
643  	{
644  		int c = in->get();	
645  		(*tag) += static_cast<char>(c);
646  		if ( c == '>' )
647  		{
648  			return;		
649  		}
650  	}
651  }
652  #endif
653  const char* TiXmlUnknownA::Parse( const char* p, TiXmlParsingDataA* data )
654  {
655  	TiXmlDocumentA* document = GetDocument();
656  	p = SkipWhiteSpace( p );
657  	if ( data )
658  	{
659  		data->Stamp( p );
660  		location = data->Cursor();
661  	}
662  	if ( !p || !*p || *p != '<' )
663  	{
664  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_UNKNOWN, p, data );
665  		return 0;
666  	}
667  	++p;
668      value = "";
669  	while ( p && *p && *p != '>' )
670  	{
671  		value += *p;
672  		++p;
673  	}
674  	if ( !p )
675  	{
676  		if ( document )	document->SetError( TIXMLA_ERROR_PARSING_UNKNOWN, 0, 0 );
677  	}
678  	if ( *p == '>' )
679  		return p+1;
680  	return p;
681  }
682  #ifdef TIXMLA_USE_STL
683  void TiXmlCommentA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
684  {
685  	while ( in->good() )
686  	{
687  		int c = in->get();	
688  		(*tag) += static_cast<char>(c);
689  		if ( c == '>' 
690  			 && tag->at( tag->length() - 2 ) == '-'
691  			 && tag->at( tag->length() - 3 ) == '-' )
692  		{
693  			return;		
694  		}
695  	}
696  }
697  #endif
698  const char* TiXmlCommentA::Parse( const char* p, TiXmlParsingDataA* data )
699  {
700  	TiXmlDocumentA* document = GetDocument();
701  	value = "";
702  	p = SkipWhiteSpace( p );
703  	if ( data )
704  	{
705  		data->Stamp( p );
706  		location = data->Cursor();
707  	}
708  	const char* startTag = "<!--";
709  	const char* endTag   = "-->";
710  	if ( !StringEqual( p, startTag, false ) )
711  	{
712  		document->SetError( TIXMLA_ERROR_PARSING_COMMENT, p, data );
713  		return 0;
714  	}
715  	p += strlen( startTag );
716  	p = ReadText( p, &value, false, endTag, false );
717  	return p;
718  }
719  const char* TiXmlAttributeA::Parse( const char* p, TiXmlParsingDataA* data )
720  {
721  	p = SkipWhiteSpace( p );
722  	if ( !p || !*p ) return 0;
723  	if ( data )
724  	{
725  		data->Stamp( p );
726  		location = data->Cursor();
727  	}
728  	const char* pErr = p;
729  	p = ReadName( p, &name );
730  	if ( !p || !*p )
731  	{
732  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, pErr, data );
733  		return 0;
734  	}
735  	p = SkipWhiteSpace( p );
736  	if ( !p || !*p || *p != '=' )
737  	{
738  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, p, data );
739  		return 0;
740  	}
741  	++p;	
742  	p = SkipWhiteSpace( p );
743  	if ( !p || !*p )
744  	{
745  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, p, data );
746  		return 0;
747  	}
748  	const char* end;
749  	if ( *p == '\'' )
750  	{
751  		++p;
752  		end = "\'";
753  		p = ReadText( p, &value, false, end, false );
754  	}
755  	else if ( *p == '"' )
756  	{
757  		++p;
758  		end = "\"";
759  		p = ReadText( p, &value, false, end, false );
760  	}
761  	else
762  	{
763  		value = "";
764  		while (    p && *p										
765  				&& !isspace( *p ) && *p != '\n' && *p != '\r'	
766  				&& *p != '/' && *p != '>' )						
767  		{
768  			value += *p;
769  			++p;
770  		}
771  	}
772  	return p;
773  }
774  #ifdef TIXMLA_USE_STL
775  void TiXmlTextA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
776  {
777  	while ( in->good() )
778  	{
779  		int c = in->peek();	
780  		if ( c == '<' )
781  			return;
782  		(*tag) += static_cast<char>(c);
783  		in->get();
784  	}
785  }
786  #endif
787  const char* TiXmlTextA::Parse( const char* p, TiXmlParsingDataA* data )
788  {
789  	value = "";
790  	if ( data )
791  	{
792  		data->Stamp( p );
793  		location = data->Cursor();
794  	}
795  	bool ignoreWhite = true;
796  	const char* end = "<";
797  	p = ReadText( p, &value, ignoreWhite, end, false );
798  	if ( p )
799  		return p-1;	
800  	return 0;
801  }
802  #ifdef TIXMLA_USE_STL
803  void TiXmlDeclarationA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
804  {
805  	while ( in->good() )
806  	{
807  		int c = in->get();
808  		(*tag) += static_cast<char>(c);
809  		if ( c == '>' )
810  		{
811  			return;
812  		}
813  	}
814  }
815  #endif
816  const char* TiXmlDeclarationA::Parse( const char* p, TiXmlParsingDataA* data )
817  {
818  	p = SkipWhiteSpace( p );
819  	TiXmlDocumentA* document = GetDocument();
820  	if ( !p || !*p || !StringEqual( p, "<?xml", true ) )
821  	{
822  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_DECLARATION, 0, 0 );
823  		return 0;
824  	}
825  	if ( data )
826  	{
827  		data->Stamp( p );
828  		location = data->Cursor();
829  	}
830  	p += 5;
831  	version = "";
832  	encoding = "";
833  	standalone = "";
834  	while ( p && *p )
835  	{
836  		if ( *p == '>' )
837  		{
838  			++p;
839  			return p;
840  		}
841  		p = SkipWhiteSpace( p );
842  		if ( StringEqual( p, "version", true ) )
843  		{
844  			TiXmlAttributeA attrib;
845  			p = attrib.Parse( p, data );		
846  			version = attrib.Value();
847  		}
848  		else if ( StringEqual( p, "encoding", true ) )
849  		{
850  			TiXmlAttributeA attrib;
851  			p = attrib.Parse( p, data );		
852  			encoding = attrib.Value();
853  		}
854  		else if ( StringEqual( p, "standalone", true ) )
855  		{
856  			TiXmlAttributeA attrib;
857  			p = attrib.Parse( p, data );		
858  			standalone = attrib.Value();
859  		}
860  		else
861  		{
862  			while ( p && *p && *p != '>' && !isspace( *p ) )
863  				++p;
864  		}
865  	}
866  	return 0;
867  }
868  bool TiXmlTextA::Blank() const
869  {
870  	for ( size_t i = 0, len = value.length(); i < len; i++ )
871  		if ( !isspace( value[i] ) )
872  			return false;
873  	return true;
874  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparserA.cpp</h3>
            <pre><code>1  #include <sstream>
2  #include "tinyxmlA.h"
3  TiXmlBaseA::Entity TiXmlBaseA::entity[ NUM_ENTITY ] = 
4  {
5  	{ "&amp;",  5, '&' },
6  	{ "&lt;",   4, '<' },
7  	{ "&gt;",   4, '>' },
8  	{ "&quot;", 6, '\"' },
9  	{ "&apos;", 6, '\'' }
10  };
11  class TiXmlParsingDataA
12  {
13  	friend class TiXmlDocumentA;
14    public:
15  	void Stamp( const char* now );
16  	const TiXmlCursorA& Cursor()	{ return cursor; }
17    private:
18  	TiXmlParsingDataA( const char* start, int _tabsize, int row, int col )
19  	{
20  		assert( start );
21  		stamp = start;
22  		tabsize = _tabsize;
23  		cursor.row = row;
24  		cursor.col = col;
25  	}
26  	TiXmlCursorA		cursor;
27  	const char*		stamp;
28  	int				tabsize;
29  };
30  void TiXmlParsingDataA::Stamp( const char* now )
31  {
32  	assert( now );
33  	if ( tabsize < 1 )
34  	{
35  		return;
36  	}
37  	int row = cursor.row;
38  	int col = cursor.col;
39  	const char* p = stamp;
40  	assert( p );
41  	while ( p < now )
42  	{
43  		switch (*p) {
44  			case 0:
45  				return;
46  			case '\r':
47  				++row;
48  				col = 0;				
49  				++p;
50  				if (*p == '\n') {
51  					++p;
52  				}
53  				break;
54  			case '\n':
55  				++row;
56  				col = 0;
57  				++p;
58  				if (*p == '\r') {
59  					++p;
60  				}
61  				break;
62  			case '\t':
63  				++p;
64  				col = (col / tabsize + 1) * tabsize;
65  				break;
66  			default:
67  				++p;
68  				++col;
69  				break;
70  		}
71  	}
72  	cursor.row = row;
73  	cursor.col = col;
74  	assert( cursor.row >= -1 );
75  	assert( cursor.col >= -1 );
76  	stamp = p;
77  	assert( stamp );
78  }
79  const char* TiXmlBaseA::SkipWhiteSpace( const char* p )
80  {
81  	if ( !p || !*p )
82  	{
83  		return 0;
84  	}
85  	while ( p && *p )
86  	{
87  		if ( isspace( *p ) || *p == '\n' || *p =='\r' )		
88  			++p;
89  		else
90  			break;
91  	}
92  	return p;
93  }
94  #ifdef TIXMLA_USE_STL
95   bool TiXmlBaseA::StreamWhiteSpace( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
96  {
97  	for ( ;; )
98  	{
99  		if ( !in->good() ) return false;
100  		int c = in->peek();
101  		if ( !IsWhiteSpace( c ) )
102  			return true;
103  		*tag += static_cast<char>(in->get());
104  	}
105  }
106   bool TiXmlBaseA::StreamTo( TIXMLA_ISTREAM * in, int character, TIXMLA_STRING * tag )
107  {
108  	while ( in->good() )
109  	{
110  		int c = in->peek();
111  		if ( c == character )
112  			return true;
113  		in->get();
114  		*tag += static_cast<char>(c);
115  	}
116  	return false;
117  }
118  #endif
119  const char* TiXmlBaseA::ReadName( const char* p, TIXMLA_STRING * name )
120  {
121  	*name = "";
122  	assert( p );
123  	if ( p && *p 
124  		&& (isalpha(static_cast<unsigned char>(*p)) || *p == '_'))
125  	{
126  		while ( p && *p
127  				&&	(		isalnum( (unsigned char ) *p ) 
128  						 || *p == '_'
129  						 || *p == '-'
130  						 || *p == '.'
131  						 || *p == ':' ) )
132  		{
133  			(*name) += *p;
134  			++p;
135  		}
136  		return p;
137  	}
138  	return 0;
139  }
140  const char* TiXmlBaseA::GetEntity( const char* p, char* value )
141  {
142      TIXMLA_STRING ent;
143  	int i;
144  	if (    strncmp( "&#x", p, 3 ) == 0 
145  	     && *(p+3) 
146  		 && *(p+4) 
147  		 && ( *(p+4) == ';' || *(p+5) == ';' )
148  	   )
149  	{
150  		*value = 0;
151  		if ( *(p+4) == ';' )
152  		{
153  			if ( isalpha( *(p+3) ) ) 
154  				*value += static_cast<char>(static_cast<char>(tolower(*(p + 3))) - 'a' + 10);
155  			else				     
156  				*value += static_cast<char>(static_cast<char>(*(p + 3)) - '0');
157  			return p+5;
158  		}
159  		else
160  		{
161  			if (isalpha(*(p + 3))) *value += static_cast<char>((static_cast<char>(tolower(*(p + 3))) - 'a' + 10) * 16);
162  			else				     *value += static_cast<char>((static_cast<char>(*(p + 3)) - '0') * 16);
163  			if ( isalpha( *(p+4) ) ) 
164  				*value += static_cast<char>(static_cast<char>(tolower(*(p + 4))) - 'a' + 10);
165  			else				     
166  				*value += static_cast<char>(static_cast<char>(*(p + 4)) - '0');
167  			return p+6;
168  		}
169  	}
170  	for ( i=0; i<NUM_ENTITY; ++i )
171  	{
172  		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
173  		{
174  			assert( strlen( entity[i].str ) == entity[i].strLength );
175  			*value = entity[i].chr;
176  			return ( p + entity[i].strLength );
177  		}
178  	}
179  	*value = *p;	
180  	return p+1;
181  }
182  bool TiXmlBaseA::StringEqual( const char* p,
183  							 const char* tag,
184  							 bool ignoreCase )
185  {
186  	assert( p );
187  	if ( !p || !*p )
188  	{
189  		assert( 0 );
190  		return false;
191  	}
192      if ( tolower( *p ) == tolower( *tag ) )
193  	{
194  		const char* q = p;
195  		if (ignoreCase)
196  		{
197  			while ( *q && *tag && *q == *tag )
198  			{
199  				++q;
200  				++tag;
201  			}
202  			if ( *tag == 0 )		
203  			{
204  				return true;
205  			}
206  		}
207  		else
208  		{
209  			while ( *q && *tag && tolower( *q ) == tolower( *tag ) )
210  			{
211  				++q;
212  				++tag;
213  			}
214  			if ( *tag == 0 )
215  			{
216  				return true;
217  			}
218  		}
219  	}
220  	return false;
221  }
222  const char* TiXmlBaseA::ReadText(	const char* p, 
223  									TIXMLA_STRING * text, 
224  									bool trimWhiteSpace, 
225  									const char* endTag, 
226  									bool caseInsensitive )
227  {
228      *text = "";
229  	if (    !trimWhiteSpace			
230  		 || !condenseWhiteSpace )	
231  	{
232  		while (	   p && *p
233  				&& !StringEqual( p, endTag, caseInsensitive )
234  			  )
235  		{
236  			char c;
237  			p = GetChar( p, &c );
238              (* text) += c;
239  		}
240  	}
241  	else
242  	{
243  		bool whitespace = false;
244  		p = SkipWhiteSpace( p );
245  		while (	   p && *p
246  				&& !StringEqual( p, endTag, caseInsensitive ) )
247  		{
248  			if ( *p == '\r' || *p == '\n' )
249  			{
250  				whitespace = true;
251  				++p;
252  			}
253  			else if ( isspace( *p ) )
254  			{
255  				whitespace = true;
256  				++p;
257  			}
258  			else
259  			{
260  				if ( whitespace )
261  				{
262                 (* text) += ' ';
263  					whitespace = false;
264  				}
265  				char c;
266  				p = GetChar( p, &c );
267              (* text) += c;
268  			}
269  		}
270  	}
271  	return p + strlen( endTag );
272  }
273  #ifdef TIXMLA_USE_STL
274  void TiXmlDocumentA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
275  {
276  	if ( !StreamTo( in, '<', tag ) ) 
277  	{
278  		SetError( TIXMLA_ERROR_PARSING_EMPTY, 0, 0 );
279  		return;
280  	}
281  	while ( in->good() )
282  	{
283  		size_t tagIndex = tag->length();
284  		while ( in->good() && in->peek() != '>' )
285  		{
286  			int c = in->get();
287  			(*tag) += static_cast<char>(c);
288  		}
289  		if ( in->good() )
290  		{
291  			TiXmlNodeA* node = Identify( tag->c_str() + tagIndex );
292  			if ( node )
293  			{
294  				node->StreamIn( in, tag );
295  				bool isElement = node->ToElement() != 0;
296  				delete node;
297  				node = 0;
298  				if ( isElement )
299  				{
300  					return;
301  				}
302  			}
303  			else
304  			{
305  				SetError( TIXMLA_ERROR, 0, 0 );
306  				return;
307  			}
308  		}
309  	}
310  	SetError( TIXMLA_ERROR, 0, 0 );
311  }
312  #endif
313  const char* TiXmlDocumentA::Parse( const char* p, TiXmlParsingDataA* prevData )
314  {
315  	ClearError();
316  	if ( !p || !*p )
317  	{
318  		SetError( TIXMLA_ERROR_DOCUMENT_EMPTY, 0, 0 );
319  		return 0;
320  	}
321  	location.Clear();
322  	if ( prevData )
323  	{
324  		location.row = prevData->cursor.row;
325  		location.col = prevData->cursor.col;
326  	}
327  	else
328  	{
329  		location.row = 0;
330  		location.col = 0;
331  	}
332  	TiXmlParsingDataA data( p, TabSize(), location.row, location.col );
333  	location = data.Cursor();
334      p = SkipWhiteSpace( p );
335  	if ( !p )
336  	{
337  		SetError( TIXMLA_ERROR_DOCUMENT_EMPTY, 0, 0 );
338  		return 0;
339  	}
340  	while ( p && *p )
341  	{
342  		TiXmlNodeA* node = Identify( p );
343  		if ( node )
344  		{
345  			p = node->Parse( p, &data );
346  			LinkEndChild( node );
347  		}
348  		else
349  		{
350  			break;
351  		}
352  		p = SkipWhiteSpace( p );
353  	}
354  	return p;
355  }
356  void TiXmlDocumentA::SetError( int err, const char* pError, TiXmlParsingDataA* data )
357  {	
358  	if ( error )
359  		return;
360  	assert( err > 0 && err < TIXMLA_ERROR_STRING_COUNT );
361  	error   = true;
362  	errorId = err;
363  	errorDesc = errorString[ errorId ];
364  	errorLocation.Clear();
365  	if ( pError && data )
366  	{
367  		data->Stamp( pError );
368  		errorLocation = data->Cursor();
369  	}
370  }
371  TiXmlNodeA* TiXmlNodeA::Identify( const char* p )
372  {
373  	TiXmlNodeA* returnNode = 0;
374  	p = SkipWhiteSpace( p );
375  	if ( !p || !*p || *p != '<' )
376  	{
377  		return 0;
378  	}
379  	TiXmlDocumentA* doc = GetDocument();
380  	p = SkipWhiteSpace( p );
381  	if ( !p || !*p )
382  	{
383  		return 0;
384  	}
385  	const char* xmlHeader = { "<?xml" };
386  	const char* commentHeader = { "<!--" };
387  	if ( StringEqual( p, xmlHeader, true ) )
388  	{
389  		#ifdef DEBUG_PARSER
390  			TIXMLA_LOG( "XML parsing Declaration\n" );
391  		#endif
392  		returnNode = new TiXmlDeclarationA();
393  	}
394  	else if (    isalpha( *(p+1) )
395  			  || *(p+1) == '_' )
396  	{
397  		#ifdef DEBUG_PARSER
398  			TIXMLA_LOG( "XML parsing Element\n" );
399  		#endif
400  		returnNode = new TiXmlElementA( "" );
401  	}
402  	else if ( StringEqual( p, commentHeader, false ) )
403  	{
404  		#ifdef DEBUG_PARSER
405  			TIXMLA_LOG( "XML parsing Comment\n" );
406  		#endif
407  		returnNode = new TiXmlCommentA();
408  	}
409  	else
410  	{
411  		#ifdef DEBUG_PARSER
412  			TIXMLA_LOG( "XML parsing Unknown\n" );
413  		#endif
414  		returnNode = new TiXmlUnknownA();
415  	}
416  	if ( returnNode )
417  	{
418  		returnNode->parent = this;
419  	}
420  	else
421  	{
422  		if ( doc )
423  			doc->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
424  	}
425  	return returnNode;
426  }
427  #ifdef TIXMLA_USE_STL
428  void TiXmlElementA::StreamIn (TIXMLA_ISTREAM * in, TIXMLA_STRING * tag)
429  {
430  	while ( in->good() )
431  	{
432  		int c = in->get();
433  		(*tag) += static_cast<char>(c);
434  		if ( c == '>' )
435  			break;
436  	}
437  	if ( tag->length() < 3 ) return;
438  	if (    tag->at( tag->length() - 1 ) == '>' 
439  		 && tag->at( tag->length() - 2 ) == '/' )
440  	{
441  		return;
442  	}
443  	else if ( tag->at( tag->length() - 1 ) == '>' )
444  	{
445  		for ( ;; )
446  		{
447  			StreamWhiteSpace( in, tag );
448  			if ( in->good() && in->peek() != '<' ) 
449  			{
450  				TiXmlTextA text( "" );
451  				text.StreamIn( in, tag );
452  				continue;
453  			}
454  			if ( !in->good() ) return;
455  			assert( in->peek() == '<' );
456  			size_t tagIndex = tag->length();
457  			bool closingTag = false;
458  			bool firstCharFound = false;
459  			for ( ;; )
460  			{
461  				if ( !in->good() )
462  					return;
463  				int c = in->peek();
464  				if ( c == '>' )
465  					break;
466  				*tag += static_cast<char>(c);
467  				in->get();
468  				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
469  				{
470  					firstCharFound = true;
471  					if ( c == '/' )
472  						closingTag = true;
473  				}
474  			}
475  			if ( closingTag )
476  			{
477  				int c = in->get();
478  				assert( c == '>' );
479  				*tag += static_cast<char>(c);
480  				return;
481  			}
482  			else
483  			{
484  				const char* tagloc = tag->c_str() + tagIndex;
485  				TiXmlNodeA* node = Identify( tagloc );
486  				if ( !node )
487  					return;
488  				node->StreamIn( in, tag );
489  				delete node;
490  				node = 0;
491  			}
492  		}
493  	}
494  }
495  #endif
496  const char* TiXmlElementA::Parse( const char* p, TiXmlParsingDataA* data )
497  {
498  	p = SkipWhiteSpace( p );
499  	TiXmlDocumentA* document = GetDocument();
500  	if ( !p || !*p )
501  	{
502  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, 0, 0 );
503  		return 0;
504  	}
505  	if ( data )
506  	{
507  		data->Stamp( p );
<span onclick='openModal()' class='match'>508  		location = data->Cursor();
509  	}
510  	if ( *p != '<' )
511  	{
512  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, p, data );
513  		return 0;
514  	}
515  	p = SkipWhiteSpace( p+1 );
516  	const char* pErr = p;
</span>517      p = ReadName( p, &value );
518  	if ( !p || !*p )
519  	{
520  		if ( document )	document->SetError( TIXMLA_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data );
521  		return 0;
522  	}
523      TIXMLA_STRING endTag ("</");
524  	endTag += value;
525  	endTag += ">";
526  	while ( p && *p )
527  	{
528  		pErr = p;
529  		p = SkipWhiteSpace( p );
530  		if ( !p || !*p )
531  		{
532  			if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, pErr, data );
533  			return 0;
534  		}
535  		if ( *p == '/' )
536  		{
537  			++p;
538  			if ( *p  != '>' )
539  			{
540  				if ( document ) document->SetError( TIXMLA_ERROR_PARSING_EMPTY, p, data );		
541  				return 0;
542  			}
543  			return (p+1);
544  		}
545  		else if ( *p == '>' )
546  		{
547  			++p;
548  			p = ReadValue( p, data );		
549  			if ( !p || !*p )
550  				return 0;
551  			if ( StringEqual( p, endTag.c_str(), false ) )
552  			{
553  				p += endTag.length();
554  				return p;
555  			}
556  			else
557  			{
558  				if ( document ) document->SetError( TIXMLA_ERROR_READING_END_TAG, p, data );
559  				return 0;
560  			}
561  		}
562  		else
563  		{
564  			TiXmlAttributeA* attrib = new TiXmlAttributeA();
565  			if ( !attrib )
566  			{
567  				if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, pErr, data );
568  				return 0;
569  			}
570  			attrib->SetDocument( document );
571  			const char* pErr = p;
572  			p = attrib->Parse( p, data );
573  			if ( !p || !*p )
574  			{
575  				if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, pErr, data );
576  				delete attrib;
577  				return 0;
578  			}
579  			TiXmlAttributeA* node = attributeSet.Find( attrib->Name() );
580  			if ( node )
581  			{
582  				node->SetValue( attrib->Value() );
583  				delete attrib;
584  				return 0;
585  			}
586  			attributeSet.Add( attrib );
587  		}
588  	}
589  	return p;
590  }
591  const char* TiXmlElementA::ReadValue( const char* p, TiXmlParsingDataA* data )
592  {
593  	TiXmlDocumentA* document = GetDocument();
594  	p = SkipWhiteSpace( p );
595  	while ( p && *p )
596  	{
597  		if ( *p != '<' )
598  		{
599  			TiXmlTextA* textNode = new TiXmlTextA( "" );
600  			if ( !textNode )
601  			{
602  				if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
603  				    return 0;
604  			}
605  			p = textNode->Parse( p, data );
606  			if ( !textNode->Blank() )
607  				LinkEndChild( textNode );
608  			else
609  				delete textNode;
610  		} 
611  		else 
612  		{
613  			if ( StringEqual( p, "</", false ) )
614  			{
615  				return p;
616  			}
617  			else
618  			{
619  				TiXmlNodeA* node = Identify( p );
620  				if ( node )
621  				{
622  					p = node->Parse( p, data );
623  					LinkEndChild( node );
624  				}				
625  				else
626  				{
627  					return 0;
628  				}
629  			}
630  		}
631  		p = SkipWhiteSpace( p );
632  	}
633  	if ( !p )
634  	{
635  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ELEMENT_VALUE, 0, 0 );
636  	}	
637  	return p;
638  }
639  #ifdef TIXMLA_USE_STL
640  void TiXmlUnknownA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
641  {
642  	while ( in->good() )
643  	{
644  		int c = in->get();	
645  		(*tag) += static_cast<char>(c);
646  		if ( c == '>' )
647  		{
648  			return;		
649  		}
650  	}
651  }
652  #endif
653  const char* TiXmlUnknownA::Parse( const char* p, TiXmlParsingDataA* data )
654  {
655  	TiXmlDocumentA* document = GetDocument();
656  	p = SkipWhiteSpace( p );
657  	if ( data )
658  	{
659  		data->Stamp( p );
660  		location = data->Cursor();
661  	}
662  	if ( !p || !*p || *p != '<' )
663  	{
664  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_UNKNOWN, p, data );
665  		return 0;
666  	}
667  	++p;
668      value = "";
669  	while ( p && *p && *p != '>' )
670  	{
671  		value += *p;
672  		++p;
673  	}
674  	if ( !p )
675  	{
676  		if ( document )	document->SetError( TIXMLA_ERROR_PARSING_UNKNOWN, 0, 0 );
677  	}
678  	if ( *p == '>' )
679  		return p+1;
680  	return p;
681  }
682  #ifdef TIXMLA_USE_STL
683  void TiXmlCommentA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
684  {
685  	while ( in->good() )
686  	{
687  		int c = in->get();	
688  		(*tag) += static_cast<char>(c);
689  		if ( c == '>' 
690  			 && tag->at( tag->length() - 2 ) == '-'
691  			 && tag->at( tag->length() - 3 ) == '-' )
692  		{
693  			return;		
694  		}
695  	}
696  }
697  #endif
698  const char* TiXmlCommentA::Parse( const char* p, TiXmlParsingDataA* data )
699  {
700  	TiXmlDocumentA* document = GetDocument();
701  	value = "";
702  	p = SkipWhiteSpace( p );
703  	if ( data )
704  	{
705  		data->Stamp( p );
706  		location = data->Cursor();
707  	}
708  	const char* startTag = "<!--";
709  	const char* endTag   = "-->";
710  	if ( !StringEqual( p, startTag, false ) )
711  	{
712  		document->SetError( TIXMLA_ERROR_PARSING_COMMENT, p, data );
713  		return 0;
714  	}
715  	p += strlen( startTag );
716  	p = ReadText( p, &value, false, endTag, false );
717  	return p;
718  }
719  const char* TiXmlAttributeA::Parse( const char* p, TiXmlParsingDataA* data )
720  {
721  	p = SkipWhiteSpace( p );
722  	if ( !p || !*p ) return 0;
723  	if ( data )
724  	{
725  		data->Stamp( p );
726  		location = data->Cursor();
727  	}
728  	const char* pErr = p;
729  	p = ReadName( p, &name );
730  	if ( !p || !*p )
731  	{
732  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, pErr, data );
733  		return 0;
734  	}
735  	p = SkipWhiteSpace( p );
736  	if ( !p || !*p || *p != '=' )
737  	{
738  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, p, data );
739  		return 0;
740  	}
741  	++p;	
742  	p = SkipWhiteSpace( p );
743  	if ( !p || !*p )
744  	{
745  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, p, data );
746  		return 0;
747  	}
748  	const char* end;
749  	if ( *p == '\'' )
750  	{
751  		++p;
752  		end = "\'";
753  		p = ReadText( p, &value, false, end, false );
754  	}
755  	else if ( *p == '"' )
756  	{
757  		++p;
758  		end = "\"";
759  		p = ReadText( p, &value, false, end, false );
760  	}
761  	else
762  	{
763  		value = "";
764  		while (    p && *p										
765  				&& !isspace( *p ) && *p != '\n' && *p != '\r'	
766  				&& *p != '/' && *p != '>' )						
767  		{
768  			value += *p;
769  			++p;
770  		}
771  	}
772  	return p;
773  }
774  #ifdef TIXMLA_USE_STL
775  void TiXmlTextA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
776  {
777  	while ( in->good() )
778  	{
779  		int c = in->peek();	
780  		if ( c == '<' )
781  			return;
782  		(*tag) += static_cast<char>(c);
783  		in->get();
784  	}
785  }
786  #endif
787  const char* TiXmlTextA::Parse( const char* p, TiXmlParsingDataA* data )
788  {
789  	value = "";
790  	if ( data )
791  	{
792  		data->Stamp( p );
793  		location = data->Cursor();
794  	}
795  	bool ignoreWhite = true;
796  	const char* end = "<";
797  	p = ReadText( p, &value, ignoreWhite, end, false );
798  	if ( p )
799  		return p-1;	
800  	return 0;
801  }
802  #ifdef TIXMLA_USE_STL
803  void TiXmlDeclarationA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
804  {
805  	while ( in->good() )
806  	{
807  		int c = in->get();
808  		(*tag) += static_cast<char>(c);
809  		if ( c == '>' )
810  		{
811  			return;
812  		}
813  	}
814  }
815  #endif
816  const char* TiXmlDeclarationA::Parse( const char* p, TiXmlParsingDataA* data )
817  {
818  	p = SkipWhiteSpace( p );
819  	TiXmlDocumentA* document = GetDocument();
820  	if ( !p || !*p || !StringEqual( p, "<?xml", true ) )
821  	{
822  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_DECLARATION, 0, 0 );
823  		return 0;
824  	}
825  	if ( data )
826  	{
827  		data->Stamp( p );
828  		location = data->Cursor();
829  	}
830  	p += 5;
831  	version = "";
832  	encoding = "";
833  	standalone = "";
834  	while ( p && *p )
835  	{
836  		if ( *p == '>' )
837  		{
838  			++p;
839  			return p;
840  		}
841  		p = SkipWhiteSpace( p );
842  		if ( StringEqual( p, "version", true ) )
843  		{
844  			TiXmlAttributeA attrib;
845  			p = attrib.Parse( p, data );		
846  			version = attrib.Value();
847  		}
848  		else if ( StringEqual( p, "encoding", true ) )
849  		{
850  			TiXmlAttributeA attrib;
851  			p = attrib.Parse( p, data );		
852  			encoding = attrib.Value();
853  		}
854  		else if ( StringEqual( p, "standalone", true ) )
855  		{
856  			TiXmlAttributeA attrib;
857  			p = attrib.Parse( p, data );		
858  			standalone = attrib.Value();
859  		}
860  		else
861  		{
862  			while ( p && *p && *p != '>' && !isspace( *p ) )
863  				++p;
864  		}
865  	}
866  	return 0;
867  }
868  bool TiXmlTextA::Blank() const
869  {
870  	for ( size_t i = 0, len = value.length(); i < len; i++ )
871  		if ( !isspace( value[i] ) )
872  			return false;
873  	return true;
874  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparserA.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparserA.cpp</div>
                </div>
                <div class="column column_space"><pre><code>508  		location = data->Cursor();
509  	}
510  	if ( *p != '<' )
511  	{
512  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, p, data );
513  		return 0;
514  	}
515  	p = SkipWhiteSpace( p+1 );
516  	const char* pErr = p;
</pre></code></div>
                <div class="column column_space"><pre><code>508  		location = data->Cursor();
509  	}
510  	if ( *p != '<' )
511  	{
512  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, p, data );
513  		return 0;
514  	}
515  	p = SkipWhiteSpace( p+1 );
516  	const char* pErr = p;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    